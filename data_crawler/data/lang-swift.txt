let n = 1000000 var x = [Int](repeating: 0, count: n) for i in 0..<n { x[i] = random() } let y = sort(x)
xcrun swift -O3 -sdk `xcrun --show-sdk-path --sdk macosx`
xcrun swift -O0 -sdk `xcrun --show-sdk-path --sdk macosx`
let n = 10000000 print(n*n*n*n*n) let x = [Int](repeating: 10, count: n) print(x[n])
let n = 10000 var x = [Int](repeating: 1, count: n) for i in 0..<n { for j in 0..<n { x[i] = x[j] } }
func quicksort_swift(inout a:CInt[], start:Int, end:Int) { if (end - start < 2){ return } var p = a[start + (end - start)/2] var l = start var r = end - 1 while (l <= r){ if (a[l] < p){ l += 1 continue } if (a[r] > p){ r -= 1 continue } var t = a[l] a[l] = a[r] a[r] = t l += 1 r -= 1 } quicksort_swift(&a, start, r + 1) quicksort_swift(&a, r + 1, end) }
void quicksort_c(int *a, int n) { if (n < 2) return; int p = a[n / 2]; int *l = a; int *r = a + n - 1; while (l <= r) { if (*l < p) { l++; continue; } if (*r > p) { r--; continue; } int t = *l; *l++ = *r; *r-- = t; } quicksort_c(a, r - a + 1); quicksort_c(l, a + n - l); }
var a_swift:CInt[] = [0,5,2,8,1234,-1,2] var a_c:CInt[] = [0,5,2,8,1234,-1,2] quicksort_swift(&a_swift, 0, a_swift.count) quicksort_c(&a_c, CInt(a_c.count))
var x_swift = CInt[](count: n, repeatedValue: 0) var x_c = CInt[](count: n, repeatedValue: 0) for var i = 0; i < n; ++i { x_swift[i] = CInt(random()) x_c[i] = CInt(random()) } let swift_start:UInt64 = mach_absolute_time(); quicksort_swift(&x_swift, 0, x_swift.count) let swift_stop:UInt64 = mach_absolute_time(); let c_start:UInt64 = mach_absolute_time(); quicksort_c(&x_c, CInt(x_c.count)) let c_stop:UInt64 = mach_absolute_time();
static const uint64_t NANOS_PER_USEC = 1000ULL; static const uint64_t NANOS_PER_MSEC = 1000ULL * NANOS_PER_USEC; static const uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MSEC; mach_timebase_info_data_t timebase_info; uint64_t abs_to_nanos(uint64_t abs) { if ( timebase_info.denom == 0 ) { (void)mach_timebase_info(&timebase_info); } return abs * timebase_info.numer / timebase_info.denom; } double abs_to_seconds(uint64_t abs) { return abs_to_nanos(abs) / (double)NANOS_PER_SEC; }
[-Onone] no optimizations, the default for debug. [-O] perform optimizations, the default for release. [-Ofast] perform optimizations and disable runtime overflow checks and runtime type checks.
Swift: 0.045478346 C: 0.000784666 Swift_builtin: 0.032513488
Swift: 0.000706745 C: 0.000742374 Swift_builtin: 0.000603576
Swift: 0.107111846 C: 0.114957179 Swift_sort: 0.092688548
Swift: 142.659763258 C: 0.162065333 Swift_sort: 114.095478272
Swift: 0.019697268 C: 0.000718064 Swift_sort: 0.002094721
import Cocoa let swift_start = NSDate.timeIntervalSinceReferenceDate(); let n: Int = 10000 let x = Int[](count: n, repeatedValue: 1) for i in 0..n { for j in 0..n { let tmp: Int = x[j] x[i] = tmp } } let y: Int[] = sort(x) let swift_stop = NSDate.timeIntervalSinceReferenceDate(); println("\(swift_stop - swift_start)s")
Swift 4.0.2 : 0.83s (0.74s with `-Ounchecked`) C++ (Apple LLVM 8.0.0): 0.74s
import Foundation func doTest() -> Void { let arraySize = 10000000 var randomNumbers = [UInt32]() for _ in 0..<arraySize { randomNumbers.append(arc4random_uniform(UInt32(arraySize))) } let start = Date() randomNumbers.sort() let end = Date() print(randomNumbers[0]) print("Elapsed time: \(end.timeIntervalSince(start))") } doTest()
xcrun swiftc --version Swift version 1.1 (swift-600.0.54.20) Target: x86_64-apple-darwin14.0.0 xcrun swiftc -O SwiftSort.swift ./SwiftSort Elapsed time: 1.02204304933548
xcrun swiftc --version Apple Swift version 1.2 (swiftlang-602.0.49.6 clang-602.0.49) Target: x86_64-apple-darwin14.3.0 xcrun -sdk macosx swiftc -O SwiftSort.swift ./SwiftSort Elapsed time: 0.738763988018036
xcrun swiftc --version Apple Swift version 2.0 (swiftlang-700.0.59 clang-700.0.72) Target: x86_64-apple-darwin15.0.0 xcrun -sdk macosx swiftc -O SwiftSort.swift ./SwiftSort Elapsed time: 0.767306983470917
xcrun swiftc --version Apple Swift version 3.0 (swiftlang-800.0.46.2 clang-800.0.38) Target: x86_64-apple-macosx10.9 xcrun -sdk macosx swiftc -O SwiftSort.swift ./SwiftSort Elapsed time: 0.939633965492249 xcrun -sdk macosx swiftc -Ounchecked SwiftSort.swift ./SwiftSort Elapsed time: 0.866258025169373
xcrun swiftc --version Apple Swift version 4.0.2 (swiftlang-900.0.69.2 clang-900.0.38) Target: x86_64-apple-macosx10.9 xcrun -sdk macosx swiftc -O SwiftSort.swift ./SwiftSort Elapsed time: 0.834299981594086 xcrun -sdk macosx swiftc -Ounchecked SwiftSort.swift ./SwiftSort Elapsed time: 0.742045998573303
using namespace std; using namespace std::chrono; int main(int argc, const char * argv[]) { const auto arraySize = 10000000; vector<uint32_t> randomNumbers; for (int i = 0; i < arraySize; ++i) { randomNumbers.emplace_back(arc4random_uniform(arraySize)); } const auto start = high_resolution_clock::now(); sort(begin(randomNumbers), end(randomNumbers)); const auto end = high_resolution_clock::now(); cout << randomNumbers[0] << "\n"; cout << "Elapsed time: " << duration_cast<duration<double>>(end - start).count() << "\n"; return 0; }
clang++ --version Apple LLVM version 6.0 (clang-600.0.54) (based on LLVM 3.5svn) Target: x86_64-apple-darwin14.0.0 Thread model: posix clang++ -O3 -std=c++11 CppSort.cpp -o CppSort ./CppSort Elapsed time: 0.688969
clang++ --version Apple LLVM version 6.1.0 (clang-602.0.49) (based on LLVM 3.6.0svn) Target: x86_64-apple-darwin14.3.0 Thread model: posix clang++ -O3 -std=c++11 CppSort.cpp -o CppSort ./CppSort Elapsed time: 0.670652
clang++ --version Apple LLVM version 7.0.0 (clang-700.0.72) Target: x86_64-apple-darwin15.0.0 Thread model: posix clang++ -O3 -std=c++11 CppSort.cpp -o CppSort ./CppSort Elapsed time: 0.690152
clang++ --version Apple LLVM version 8.0.0 (clang-800.0.38) Target: x86_64-apple-darwin15.6.0 Thread model: posix clang++ -O3 -std=c++11 CppSort.cpp -o CppSort ./CppSort Elapsed time: 0.68253
clang++ --version Apple LLVM version 9.0.0 (clang-900.0.38) Target: x86_64-apple-darwin16.7.0 Thread model: posix clang++ -O3 -std=c++11 CppSort.cpp -o CppSort ./CppSort Elapsed time: 0.736784
func sort<T>(array: T[], pred: (T, T) -> Bool) -> T[]
func sort<T : Comparable>(array: T[]) -> T[] Example: sort( _arrayToSort_ ) { $0 > $1 }
let n = 1000 let x = Int[](count: n, repeatedValue: 0) for i in 0..n { x[i] = random() } let y = sort(x) { $0 > $1 }
import Foundation func quickSort(inout array: Int[], begin: Int, end: Int) { if (begin < end) { let p = partition(&array, begin, end) quickSort(&array, begin, p - 1) quickSort(&array, p + 1, end) } } func partition(inout array: Int[], left: Int, right: Int) -> Int { let numElements = right - left + 1 let pivotIndex = left + numElements / 2 let pivotValue = array[pivotIndex] swap(&array[pivotIndex], &array[right]) var storeIndex = left for i in left..right { let a = 1 if array[i] <= pivotValue { swap(&array[i], &array[storeIndex]) storeIndex++ } } swap(&array[storeIndex], &array[right]) return storeIndex } let n = 1000 var x = Int[](count: n, repeatedValue: 0) for i in 0..n { x[i] = Int(arc4random()) } quickSort(&x, 0, x.count - 1) for i in 0..n { x[i] }
func partition(inout list : [Int], low: Int, high : Int) -> Int { let pivot = list[high] var j = low var i = j - 1 while j < high { if list[j] <= pivot{ i += 1 (list[i], list[j]) = (list[j], list[i]) } j += 1 } (list[i+1], list[high]) = (list[high], list[i+1]) return i+1 } func quikcSort(inout list : [Int] , low : Int , high : Int) { if low < high { let pIndex = partition(&list, low: low, high: high) quikcSort(&list, low: low, high: pIndex-1) quikcSort(&list, low: pIndex + 1, high: high) } } var list = [7,3,15,10,0,8,2,4] quikcSort(&list, low: 0, high: list.count-1) var list2 = [ 10, 0, 3, 9, 2, 14, 26, 27, 1, 5, 8, -1, 8 ] quikcSort(&list2, low: 0, high: list2.count-1) var list3 = [1,3,9,8,2,7,5] quikcSort(&list3, low: 0, high: list3.count-1)
import UIKit class SwiftTableViewController: UITableViewController { init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder) } override func viewDidLoad() { super.viewDidLoad() } } extension SwiftTableViewController { override func numberOfSectionsInTableView(tableView: UITableView?) -> Int { return 1 } override func tableView(tableView: UITableView?, numberOfRowsInSection section: Int) -> Int { return 5 } override func tableView(tableView: UITableView?, cellForRowAtIndexPath indexPath: NSIndexPath?) -> UITableViewCell? { let cell = tableView?.dequeueReusableCellWithIdentifier("myCell", forIndexPath: indexPath) as UITableViewCell; cell.textLabel.text = "Hello World" return cell } }
class ViewController: UIViewController, UICollectionViewDataSource, UICollectionViewDelegate { ... func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { ... } func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell { ... } func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) { ... } }
class ViewController: UIViewController { ... } extension ViewController: UICollectionViewDataSource { func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { ... } func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell { ... } } extension ViewController: UICollectionViewDelegate { func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) { ... } }
private typealias SectionName = ViewController private extension SectionName { }
import Cocoa class MainWindowController: NSWindowController { func fly() { } func turnInvisible() { } }
let unusualMenagerie = "Koala & println("unusualMenagerie has \(count(unusualMenagerie)) characters")
var emoji = "üëç" emoji.characters.count emoji.utf16.count
let str = "Hello" let count = str.length extension String { var length: Int { return countElements(self) } } extension String { var length: Int { return count(self) } } extension String { var length: Int { return characters.count } }
extension String { var length: Int { return self.characters.count } }
let circledStarString = "\(circledStar)" countElements(circledStarString) circledStarString.endIndex
var testString = "Scott" var length = testString.characters.count
var test1: String = "Scott" var length = test1.utf16Count
var test1: String = "Scott" var length = test1.lengthOfBytesUsingEncoding(NSUTF16StringEncoding)
var test1: String = "Scott" var length = test1.bridgeToObjectiveC().length
let regex = try! NSRegularExpression(pattern:"üê∂", options: NSRegularExpressionOptions.UseUnixLineSeparators) let str = "üê∂üê∂üê∂üê∂üê∂üê∂" let result = regex.stringByReplacingMatchesInString(str, options: NSMatchingOptions.WithTransparentBounds, range: NSMakeRange(0, str.utf16.count), withTemplate: "dog") print(result)
let result = regex.stringByReplacingMatchesInString(str, options: NSMatchingOptions.WithTransparentBounds, range: NSMakeRange(0, str.characters.count), withTemplate: "dog") print(result)
let findLength = "This is a string of text" findLength.characters.count
func textViewDidChange(textView: UITextView) { yourStringLabel.text = String(150 - yourStringTextView.text.characters.count) }
let flag = "üáµüá∑" print(flag.count) print(flag.unicodeScalars.count) print(flag.utf16.count) print(flag.utf8.count)
let spain = "Espa√±a" let count1 = spain.count let count2 = spain.utf8.count
extension String { var length : Int { return self.utf16Count } }
let textlengthstring = (yourtextview?.text)! as String
let replacementTextAsDecimal = Double(string) if string.characters.count > 0 && replacementTextAsDecimal == nil && replacementTextHasDecimalSeparator == nil { return false }
extension String { func stringLength(str: String) -> Int { return str.characters.count } func stringLength(_ str: String) -> Int { return str.characters.count } func stringLength(_ str: String) -> Int { return str.count } }
var str = "Hello, playground" var newString = str as NSString countElements(str)
var str = "Hello World" var length = count(str.utf16)
let x = "test" as NSString let y : NSString = "string 2" let lenx = x.count let leny = y.count
test1 = "StackOverflow" print(test1.characters.count)
for (index, element) in list.enumerated() { print("Item \(index): \(element)") }
for (index, element) in list.enumerate() { print("Item \(index): \(element)") }
for (index, element) in enumerate(list) { println("Item \(index): \(element)") }
func enumerated() -> EnumeratedSequence<Array<Element>>
let list = ["Car", "Bike", "Plane", "Boat"] for (index, element) in list.enumerate() { print(index, ":", element) }
let list = [Int](1...5) var arrayOfTuples = [(Int, Int)]() for (index, element) in list.enumerated() { arrayOfTuples += [(index, element)] } print(arrayOfTuples)
let list = [Int](1...5) let arrayOfTuples = Array(list.enumerated()) print(arrayOfTuples)
let list = [Int](1...5) let arrayOfDictionaries = list.enumerated().map { (a, b) in return [a : b] } print(arrayOfDictionaries)
let list = [Int](1...5) list.reversed().enumerated().forEach { print($0, ":", $1) }
import UIKit class ViewController: UIViewController { var generator = ["Car", "Bike", "Plane", "Boat"].enumerated().makeIterator() @IBAction func iterate(_ sender: UIButton) { let tuple: (offset: Int, element: String)? = generator.next() print(String(describing: tuple)) } } /* Will print the following lines for 6 `touch up inside`: Optional((0, "Car")) Optional((1, "Bike")) Optional((2, "Plane")) Optional((3, "Boat")) nil nil */
for (index, element) in list.enumerate() { print("Item \(index): \(element)") }
var list = ["a": 1, "b": 2] for (index, (letter, value)) in list.enumerate() { print("Item \(index): \(letter) \(value)") }
for (index, element) in arrayOfValues.enumerate() { }
for (index, element) in arrayOfValues.enumerated() { }
let evens = arrayOfValues.enumerate().filter({ (index: Int, element: Int) -> Bool in return index % 2 == 0 }).map({ (_: Int, element: Int) -> Double in return Double(element) }) let odds = arrayOfValues.enumerate().filter({ (index: Int, element: Int) -> Bool in return index % 2 != 0 }).map({ (_: Int, element: Int) -> Double in return Double(element) })
for (index, element) in elements.enumerate() { print("\(index): \(element)") }
for (index, element) in elements.enumerated() { print("\(index): \(element)") }
for index in 0..<elements.count { let element = elements[index] print("\(index): \(element)") }
for (index, element) in list.enumerated() { print("Item \(index): \(element)") }
for (index, value) in shoppingList.enumerate() { print("Item \(index + 1): \(value)") }
let a = ["a", "b", "c", "d", "e"] a.indices let aSlice = a[1..<4] aSlice.indices var test = [Int: String]() for (index, element) in aSlice.enumerate() { test[index] = element } test test[0] == aSlice[0]
var someStrs = [String]() someStrs.append("Apple") someStrs.append("Amazon") someStrs += ["Google"] for (index, item) in someStrs.enumerated() { print("Value at index = \(index) is \(item)"). }
Value at index = 0 is Apple Value at index = 1 is Amazon Value at index = 2 is Google
extension Array { func forEachWithIndex(_ body: (Int, Element) throws -> Void) rethrows { try zip((startIndex ..< endIndex), self).forEach(body) } }
list.enumerated().forEach { (index, element) in ... }
list.enumerated().forEach { print("index: \($0.0), value: \($0.1)") }
print("We have a banana") print("Melona") print("Kiwi")
let dic = NSProcessInfo.processInfo().environment if dic["TRIPLE"] != nil { }
‚ÄúActive Compilation Conditions‚Äù is a new build setting for passing conditional compilation flags to the Swift compiler.
func obtain() -> AbstractThing { if _isDebugAssertConfiguration() { return DecoratedThingWithDebugInformation(Thing()) } else { return Thing() } }
let color = UIColor.redColor() let color = NSColor.redColor()
let isDebug: Bool = { var isDebug = false func set(debug: Bool) -> Bool { isDebug = debug return isDebug } assert(set(debug: true)) return isDebug }()
func executeInProduction(_ block: () -> Void) { block() }
executeInProduction { Fabric.with([Crashlytics.self]) }
func Log(_ str: String) { assert(DebugLog(str)) } func DebugLog(_ str: String) -> Bool { print(str) return true }
let iterations = 100_000_000 let time1 = CFAbsoluteTimeGetCurrent() for i in 0 ..< iterations { Log ("‚ßâ unarchiveArray:\(fileName) memoryTime:\(memoryTime) count:\(array.count)") } var time2 = CFAbsoluteTimeGetCurrent() print ("Log: \(time2-time1)" )
func inDebugBuilds(_ code: () -> Void) { assert({ code(); return true }()) }
NSTimer(timeInterval: 1, target: self, selector: test(), userInfo: nil, repeats: true)
let timer = Timer(timeInterval: 1, target: object, selector: userInfo: nil, repeats: false) button.addTarget(object, action: for: .touchUpInside) view.perform( with: button, with: otherButton)
override func viewDidLoad() { super.viewDidLoad() var rightButton = UIBarButtonItem(title: "Title", style: UIBarButtonItemStyle.Plain, target: self, action: Selector("method")) self.navigationItem.rightBarButtonItem = rightButton } func method() { }
var rightButton = UIBarButtonItem(title: "Title", style: UIBarButtonItemStyle.Plain, target: self, action: Selector("method")) @objc func method() { }
let timer = NSTimer(timeInterval: 1, target: self, selector: "test", userInfo: nil, repeats: false) func test () {}
var somethingToPass = "It worked" let timer = NSTimer.scheduledTimerWithTimeInterval(0.01, target: self, selector: "tester:", userInfo: somethingToPass, repeats: false) func tester(timer: NSTimer) { let theStringToPrint = timer.userInfo as String println(theStringToPrint) }
var rightBarButton = UIBarButtonItem( title: "Logout", style: UIBarButtonItemStyle.Plain, target: self, action:"logout" )
var rightBarButton = UIBarButtonItem( title: "Logout", style: UIBarButtonItemStyle.Plain, target: self, action:Selector("logout") )
let gestureRecognizer = UITapGestureRecognizer() self.view.addGestureRecognizer(gestureRecognizer) gestureRecognizer.addTarget(self, action: @objc func dismiss(completion: (() -> Void)?) { self.dismiss(animated: true, completion: completion) }
buttton.addTarget(self, action: buttton.addTarget(self, action: buttton.addTarget(self, action: buttton.addTarget(self, action: buttton.addTarget(self, action: buttton.addTarget(self, action: func tappedButton() { print("tapped") } func tappedButton2(sender: UIButton) { print("tapped 2") } button.addTarget(self, action: func tappedButton(_ sender: UIButton) { } button.addTarget(self, action: func tappedButton(_ sender: UIButton, _ event: UIEvent) { }
Create Refresh control using Selector method. var refreshCntrl : UIRefreshControl! refreshCntrl = UIRefreshControl() refreshCntrl.tintColor = UIColor.whiteColor() refreshCntrl.attributedTitle = NSAttributedString(string: "Please Wait...") refreshCntrl.addTarget(self, action:"refreshControlValueChanged", forControlEvents: UIControlEvents.ValueChanged) atableView.addSubview(refreshCntrl)
func refreshControlValueChanged(){ atableView.reloadData() refreshCntrl.endRefreshing() }
class MyCustomView : UIView { func addTapGestureRecognizer() { let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: tapGestureRecognizer.numberOfTapsRequired = 1 addGestureRecognizer(tapGestureRecognizer) } func handleTapGesture(_ tapGesture : UITapGestureRecognizer) { if tapGesture.state == .ended { print("TapGesture detected") } } }
@objc For Swift 2.0: { self.performSelector(‚ÄúperformMethod‚Äù, withObject: nil , afterDelay: 0.5) btnHome.addTarget(self, action: ‚ÄúbuttonPressed:", forControlEvents: UIControlEvents.TouchUpInside) NSTimer.scheduledTimerWithTimeInterval(0.5, target: self, selector : ‚ÄútimerMethod‚Äù, userInfo: nil, repeats: false) } @objc private func performMethod() { ‚Ä¶ } @objc private func buttonPressed(sender:UIButton){ ‚Ä¶. } @objc private func timerMethod () { ‚Ä¶. }
UIBarButtonItem( title: "Some Title", style: UIBarButtonItemStyle.Done, target: self, action: "flatButtonPressed" )
flatButton.addTarget(self, action: "flatButtonPressed:", forControlEvents: UIControlEvents.TouchUpInside)
func flatButtonPressed(sender: AnyObject) { NSLog("flatButtonPressed") }
var timer = NSTimer.scheduledTimerWithTimeInterval(1.0, target: self, selector: Selector("flatButtonPressed"), userInfo: userInfo, repeats: true) let mainLoop = NSRunLoop.mainRunLoop() mainLoop.addTimer(timer, forMode: NSDefaultRunLoopMode)
let tapRecognizer = UITapGestureRecognizer( target: self, action: "labelTapped:")
let tapRecognizer = UITapGestureRecognizer( target: self, action: Selector("labelTapped:"))
override func viewDidLoad() { super.viewDidLoad() navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: } func addNewFireflyReference() { gratuitousReferences.append("Curse your sudden but inevitable betrayal!") }
override func viewDidLoad() { super.viewDidLoad() let addButton = UIBarButtonItem(image: UIImage(named: "746-plus-circle.png"), style: UIBarButtonItemStyle.Plain, target: self, action: Selector("addAction:")) self.navigationItem.rightBarButtonItem = addButton } func addAction(send: AnyObject?) { NSLog("addAction") }
var timer1 : NSTimer? = nil timer1= NSTimer(timeInterval: 0.1, target: self, selector: Selector("test"), userInfo: nil, repeats: true)
let timer = Timer.scheduledTimer(timeInterval: 0.01, target: self, selector:
Timer.scheduledTimer(timeInterval: 1, target: self, selector: ( WHERE timeInterval:- Interval in which timer should fire like 1s, 10s, 100s etc. [Its value is in secs] target:- function which pointed to class. So here I am pointing to current class. selector:- function that will execute when timer fires. func updateTimer(){ } repeats:- true/false specifies that timer should call again n again.
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { self.window = UIWindow(frame: UIScreen.mainScreen().bounds) var controller = UIViewController() var view = UIView(frame: CGRectMake(0, 0, 320, 568)) view.backgroundColor = UIColor.redColor() controller.view = view var label = UILabel(frame: CGRectMake(0, 0, 200, 21)) label.center = CGPointMake(160, 284) label.textAlignment = NSTextAlignment.Center label.text = "I controller.view.addSubview(label) self.window!.rootViewController = controller self.window!.makeKeyAndVisible() return true }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let button = UIButton.buttonWithType(UIButtonType.System) as UIButton button.frame = CGRectMake(100, 100, 100, 50) button.backgroundColor = UIColor.greenColor() button.setTitle("Test Button", forState: UIControlState.Normal) button.addTarget(self, action: "buttonTapped:", forControlEvents: UIControlEvents.TouchUpInside) self.view.addSubview(button) } func buttonTapped(sender: UIButton!) { println("buttonTapped") } }
Crashed Thread: 0 Exception Type: EXC_BREAKPOINT (SIGTRAP) Exception Codes: 0x0000000000000002, 0x0000000000000000 Application Specific Information: dyld: launch, loading dependent libraries Dyld Error Message: Library not loaded: /System/Library/Frameworks/CoreGraphics.framework/Versions/A/CoreGraphics Referenced from: /Users/USER/Desktop/Swift-Test.app/Contents/MacOS/../Frameworks/libswiftAppKit.dylib Reason: image not found Binary Images: 0x109c65000 - 0x109c6afff +private.Swift-Test (1.0 - 1) <649695D0-58FD-3D02-9176-2D40D4E711F2> /Users/USER/Desktop/Swift-Test.app/Contents/MacOS/Swift-Test 0x109c83000 - 0x109dbffff +libswift_stdlib_core.dylib (1.0 - 600.0.34.4.5) <10AAC369-9404-321D-A892-49F65856D7AF> /Users/USER/Desktop/Swift-Test.app/Contents/Frameworks/libswift_stdlib_core.dylib ...
dyld: F_ADDFILESIGS failed for /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswift_stdlib_core.dylib with errno=1 dyld: F_ADDFILESIGS failed for /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswiftCoreGraphics.dylib with errno=1 dyld: F_ADDFILESIGS failed for /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswiftDarwin.dylib with errno=1 dyld: F_ADDFILESIGS failed for /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswiftDispatch.dylib with errno=1 dyld: F_ADDFILESIGS failed for /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswiftFoundation.dylib with errno=1 dyld: F_ADDFILESIGS failed for /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswiftObjectiveC.dylib with errno=1 dyld: F_ADDFILESIGS failed for /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswiftUIKit.dylib with errno=1 dyld: Symbol not found: _OBJC_CLASS_$_NSObject Referenced from: /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswift_stdlib_core.dylib Expected in: /usr/lib/libobjc.A.dylib in /private/var/mobile/Applications/59E31E79-9525-43B0-9DF6-8FEF3C0080F1/SwiftTestApp.app/Frameworks/libswift_stdlib_core.dylib
Dyld Error Message: Symbol not found: __dispatch_source_type_memorypressure Referenced from: /Volumes/*/SwifTest.app/Contents/MacOS/../Frameworks/libswiftDispatch.dylib Expected in: /usr/lib/libSystem.B.dylib in /Volumes/*/SwifTest.app/Contents/MacOS/../Frameworks/libswiftDispatch.dylib
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { self.window = UIWindow(frame: UIScreen.mainScreen().bounds) self.window!.backgroundColor = UIColor.whiteColor() let nav = UINavigationController() let vc = ViewController(nibName: "ViewController", bundle: nil) nav.pushViewController(vc, animated: false) self.window!.rootViewController = nav self.window!.makeKeyAndVisible() return true }
ld: warning: embedded dylibs/frameworks only run on iOS 8 or later.
var fullNameArr = var firstName: String = fullNameArr[0] var lastName: String? = fullnameArr[1]
var fullName = "First Last" var fullNameArr = split(fullName) {$0 == " "} var firstName: String = fullNameArr[0] var lastName: String? = fullNameArr.count > 1 ? fullNameArr[1] : nil
let fullName = "First Last" let fullNameArr = fullName.characters.split{$0 == " "}.map(String.init) fullNameArr[0] fullNameArr[1]
import Foundation var fullName: String = "First Last" let fullNameArr = fullName.componentsSeparatedByString(" ") var firstName: String = fullNameArr[0] var lastName: String = fullNameArr[1]
import Foundation let fullName = "First Last" let fullNameArr = fullName.components(separatedBy: " ") let name = fullNameArr[0] let surname = fullNameArr[1]
import Foundation let fullName : String = "First Last"; let fullNameArr : [String] = fullName.componentsSeparatedByString(" ") var firstName : String = fullNameArr[0] var lastName : String = fullNameArr[1]
import Foundation let fullName : String = "First Last" let fullNameArr : [String] = fullName.components(separatedBy: " ") var firstName : String = fullNameArr[0] var lastName : String = fullNameArr[1]
import Foundation let sayHello = "Hello Swift 4 2017"; let result = sayHello.split(separator: " ") print(result)
print(result[0]) print(result[1]) print(result[2]) print(result[3])
import Foundation let mathString: String = "12-37*2/5" let numbers = mathString.components(separatedBy: ["-", "*", "/"]) print(numbers)
let separators = NSCharacterSet(charactersInString: " ") var fullName: String = "First Last"; var words = fullName.componentsSeparatedByCharactersInSet(separators)
let separators = NSCharacterSet(charactersInString: " ,") var fullName: String = "Last, First Middle"; var words = fullName.componentsSeparatedByCharactersInSet(separators)
let words = "these words will be elements in an array".components(separatedBy: " ")
let nameFormatter = PersonNameComponentsFormatter() let name = "Mr. Steven Paul Jobs Jr." if let nameComps = nameFormatter.personNameComponents(from: name) { nameComps.namePrefix nameComps.givenName nameComps.middleName nameComps.familyName nameComps.nameSuffix nameFormatter.style = .default nameFormatter.string(from: nameComps) nameFormatter.style = .short nameFormatter.string(from: nameComps) nameFormatter.style = .long nameFormatter.string(from: nameComps) nameFormatter.style = .abbreviated nameFormatter.string(from: nameComps) nameFormatter.style = .long nameFormatter.annotatedString(from: nameComps) }
import Foundation let pieces = "Mary had little lamb".componentsSeparatedByString(" ")
let longerString: String = "This is a test of the character set splitting system" let components = longerString.components(separatedBy: .whitespaces) print(components)
let line = "AAA BBB\t CCC" let fields = line.components(separatedBy: .whitespaces).filter {!$0.isEmpty}
let fullName = "First Last" var fullNameArr = fullName.components(separatedBy: " ") var firstname = fullNameArr[0] var lastname = fullNameArr[1]
var fullName: String = "First Last" fullName += " " var newElement = "" var fullNameArr = [String]() for Character in fullName.characters { if Character == " " { fullNameArr.append(newElement) newElement = "" } else { newElement += "\(Character)" } } var firsName = fullNameArr[0] var lastName = fullNameArr[1]
let items = str.components(separatedBy: " ") let str1 = items[0] let str2 = items[1] let str3 = items[2] let str4 = items[3] print(items.count) print(str1) print(str2) print(str3) print(str4) print(items.first!) print(items.last!)
let items = str.split(separator: " ") let str1 = String(items.first!) let str2 = String(items.last!) print(items.count) print(items) print(str1) print(str2)
let line = "BLANCHE: I don print(line.split(separator: " ")) print(line.split(separator: " ", maxSplits: 1)) print(line.split(separator: " ", maxSplits: 2)) print(line.split(separator: " ", omittingEmptySubsequences: false)) print(line.split(separator: " ", omittingEmptySubsequences: true)) print(line.split(separator: " ", maxSplits: 4, omittingEmptySubsequences: false)) print(line.split(separator: " ", maxSplits: 3, omittingEmptySubsequences: true))
var data:[String] = split( featureData ) { $0 == "\u{003B}" }
var data:[String] = featureData.split {$0 == "\u{003B}"}
var data:[String] = featureData.componentsSeparatedByString("\u{003B}")
let myArray = myString.components(separatedBy: .controlCharacters)
let fullName = "First Last" let fullNameArr = fullName.components(separatedBy: " ") let firstName = fullNameArr[0] let lastName = fullnameArr[1]
let searchInput = " First \r\n \n \t\t\tMiddle Last " let searchTerms = searchInput .replacingOccurrences( of: "\\s+", with: " ", options: .regularExpression ) .trimmingCharacters(in: .whitespaces) .components(separatedBy: " ")
let fullName = "First Last" let fullNameArr = fullName.characters.split(" ") let firstName = String(fullNameArr[0])
let fullName: String = "First Last @ triggerd event of the session by session storage @ it can be divided by the event of the trigger." let fullNameArr = fullName.components(separatedBy: "@") print("split", fullNameArr)
let str = "one two" let strSplit = str.characters.split(" ").map(String.init)
func setFullName(fullName: String) { var fullNameComponents = fullName.componentsSeparatedByString(" ") self.fname = fullNameComponents.count > 0 ? fullNameComponents[0]: "" self.sname = fullNameComponents.count > 1 ? fullNameComponents[1]: "" self.fname = self.fname!.capitalizedString self.sname = self.sname!.capitalizedString }
var fullText = "Hello World" let firstWord = fullText.text?.components(separatedBy: " ").first let lastWord = fullText.text?.components(separatedBy: " ").last
var fullName = "First Last" var fullNameArr = split(fullName) {$0 == " "}
var fullName = "First Last" var fullNameArr = fullName.split {$0 == " "}
let complete_string:String = "Hello world" let string_arr = complete_string.characters.split {$0 == " "}.map(String.init) let hello:String = string_arr[0] let world:String = string_arr[1]
let fullName = "FirstName LastName" var splitedFullName = fullName.componentsSeparatedByString(" ") print(splitedFullName[0]) print(splitedFullName[1])
extension String { func splitBy(characters: [Character], swallow: Bool = false) -> [String] { var substring = "" var array = [String]() var index = 0 for character in self.characters { if let lastCharacter = substring.characters.last { if lastCharacter == character { substring.append(character) } else { var shouldSplit = false for splitCharacter in characters { if character == splitCharacter || lastCharacter == splitCharacter { shouldSplit = true break } } if shouldSplit { array.append(substring) substring = String(character) } else { substring.append(character) } } } else { substring.append(character) } index += 1 if index == self.characters.count { array.append(substring) } } return array.filter { if swallow { return true } else { for splitCharacter in characters { if $0.characters.contains(splitCharacter) { return false } } return true } } } }
"test text".splitBy([" "]) "test++text--".splitBy(["+", "-"], swallow: true)
let chars = CharacterSet(charactersIn: ".,; -") let split = phrase.components(separatedBy: chars) let chars2 = CharacterSet.alphaNumerics let split2 = phrase.components(separatedBy: chars2)
let string = "loremipsum.dolorsant.amet:" let result = string.components(separatedBy: ".") print(result[0]) print(result[1]) print(result[2]) print("total: \(result.count)")
"First ".split(separator: " ", maxSplits: 1, omittingEmptySubsequences: false)
struct NameComponentsSplitter { static func split(fullName: String) -> (String?, String?) { guard !fullName.isEmpty else { return (nil, nil) } let components = fullName.components(separatedBy: .whitespacesAndNewlines) let lastName = components.last let firstName = components.dropLast().joined(separator: " ") return (firstName.isEmpty ? nil : firstName, lastName) } }
func testThatItHandlesTwoComponents() { let (firstName, lastName) = NameComponentsSplitter.split(fullName: "John Smith") XCTAssertEqual(firstName, "John") XCTAssertEqual(lastName, "Smith") } func testThatItHandlesMoreThanTwoComponents() { var (firstName, lastName) = NameComponentsSplitter.split(fullName: "John Clark Smith") XCTAssertEqual(firstName, "John Clark") XCTAssertEqual(lastName, "Smith") (firstName, lastName) = NameComponentsSplitter.split(fullName: "John Clark Jr. Smith") XCTAssertEqual(firstName, "John Clark Jr.") XCTAssertEqual(lastName, "Smith") } func testThatItHandlesEmptyInput() { let (firstName, lastName) = NameComponentsSplitter.split(fullName: "") XCTAssertEqual(firstName, nil) XCTAssertEqual(lastName, nil) }
var fullName = "James Keagan Michael" let first = fullName.components(separatedBy: " ").first?.isEmpty == false ? fullName.components(separatedBy: " ").first! : "John" let last = fullName.components(separatedBy: " ").last?.isEmpty == false && fullName.components(separatedBy: " ").last != fullName.components(separatedBy: " ").first ? fullName.components(separatedBy: " ").last! : "Doe"
class var sharedInstance:TPScopeManager { get { struct Static { static var instance : TPScopeManager? = nil } if !Static.instance { Static.instance = TPScopeManager() } return Static.instance! } }
class var sharedInstance:TPScopeManager { get { struct Static { static var instance : TPScopeManager? = nil static var token : dispatch_once_t = 0 } dispatch_once(Static.token) { Static.instance = TPScopeManager() } return Static.instance! } }
dispatch_once(Static.token, { Static.instance = TPScopeManager() })
class Singleton { static let sharedInstance = Singleton() }
class Singleton { class var sharedInstance: Singleton { struct Static { static let instance: Singleton = Singleton() } return Static.instance } }
class Singleton { class var sharedInstance: Singleton { struct Static { static var onceToken: dispatch_once_t = 0 static var instance: Singleton? = nil } dispatch_once(&Static.onceToken) { Static.instance = Singleton() } return Static.instance! } }
class WithSingleton { class var sharedInstance :WithSingleton { struct Singleton { static let instance = WithSingleton() } return Singleton.instance } }
class Singleton { static let sharedInstance = Singleton() }
private let _singletonInstance = SingletonClass() class SingletonClass { class var sharedInstance: SingletonClass { return _singletonInstance } }
class MySingleton { static let sharedMySingleton = MySingleton() private init() { } }
var tpScopeManagerSharedInstance = TPScopeManager()
var refrence = tpScopeManagerSharedInstance tpScopeManagerSharedInstance.someMethod()
class MyClass { private static let _sharedInstance = MyClass() class func sharedInstance() -> MyClass { return _sharedInstance } }
class Singleton { static let sharedInstance = Singleton() }
class Singleton { static let sharedInstance: Singleton = { let instance = Singleton() return instance }() }
protocol Singleton: class { static var sharedInstance: Self { get } } final class Kraken: Singleton { static let sharedInstance = Kraken() private init() {} }
struct StaticRank { static let shared = RankMapping() } class func sharedInstance() -> RankMapping { return StaticRank.shared } class var shared:RankMapping { return StaticRank.shared }
class Manager { static let sharedInstance = Manager() private init() {} }
class func sharedStore() -> ImageStore { struct Static { static let instance : ImageStore = ImageStore() } return Static.instance }
let SocketManager = SocketManagerSingleton(); class SocketManagerSingleton { }
func someFunction() { var socketManager = SocketManager }
func SocketManager() -> SocketManagerSingleton { return _SocketManager } let _SocketManager = SocketManagerSingleton(); class SocketManagerSingleton { }
func someFunction() { var socketManager = SocketManager() }
final class MySingleton { private init() {} static let shared = MySingleton() }
class UtilSingleton: NSObject { var iVal: Int = 0 class var shareInstance: UtilSingleton { get { struct Static { static var instance: UtilSingleton? = nil static var token: dispatch_once_t = 0 } dispatch_once(&Static.token, { Static.instance = UtilSingleton() }) return Static.instance! } } }
UtilSingleton.shareInstance.iVal++ println("singleton new iVal = \(UtilSingleton.shareInstance.iVal)")
class Shared: NSObject { static let sharedInstance = Shared() private override init() { } }
enum SharedTPScopeManager: TPScopeManager { case Singleton }
class Singleton { static let sharedInstance = Singleton() }
class Singleton { static let sharedInstance: Singleton = { let instance = Singleton() return instance }() }
import Foundation class ItemStore: NSObject { class var sharedStore : ItemStore { struct Singleton { static let instance = ItemStore() } return Singleton.instance } var _privateItems = Item[]() var allItems: Item[] { return _privateItems } init() { super.init() let path = itemArchivePath let unarchivedItems : AnyObject! = NSKeyedUnarchiver.unarchiveObjectWithFile(path) if unarchivedItems { _privateItems = unarchivedItems as Array<Item> } delayOnMainQueueFor(numberOfSeconds: 0.1, action: { assert(self === ItemStore.sharedStore, "Only one instance of ItemStore allowed!") }) } func createItem() -> Item { let item = Item.randomItem() _privateItems.append(item) return item } func removeItem(item: Item) { for (index, element) in enumerate(_privateItems) { if element === item { _privateItems.removeAtIndex(index) ImageStore.sharedStore.deleteImageForKey(item.itemKey) } } } func moveItemAtIndex(fromIndex: Int, toIndex: Int) { _privateItems.moveObjectAtIndex(fromIndex, toIndex: toIndex) } var itemArchivePath: String { let documentDirectories = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.UserDomainMask, true) let documentDirectory = documentDirectories[0] as String return documentDirectory.stringByAppendingPathComponent("items.archive") } func saveChanges() -> Bool { let path = itemArchivePath return NSKeyedArchiver.archiveRootObject(_privateItems, toFile: path) } }
import Foundation import UIKit typealias completionBlock = () -> () extension Array { func contains( return self.bridgeToObjectiveC().containsObject(object) } func indexOf( return self.bridgeToObjectiveC().indexOfObject(object) } mutating func moveObjectAtIndex(fromIndex: Int, toIndex: Int) { if ((fromIndex == toIndex) || (fromIndex > self.count) || (toIndex > self.count)) { return } let object = self[fromIndex] self.removeAtIndex(fromIndex) self.insert(object, atIndex: toIndex) } } func delayOnMainQueueFor(numberOfSeconds delay:Double, action closure:()->()) { dispatch_after( dispatch_time( DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC)) ), dispatch_get_main_queue()) { closure() } }
final class Singleton { static let sharedInstance: Singleton = { let instance = Singleton() return instance }() private init() {} }
class APIClient { } var sharedAPIClient: APIClient = { return APIClient() }() extension APIClient { class func sharedClient() -> APIClient { return sharedAPIClient } }
import Foundation let ConfigurationManagerSharedInstance = ConfigurationManager() class ConfigurationManager : NSObject { var globalDic: NSMutableDictionary = NSMutableDictionary() class var sharedInstance:ConfigurationManager { return ConfigurationManagerSharedInstance } init() { super.init() println ("Config Init been Initiated, this will be called only onece irrespective of many calls") }
println(ConfigurationManager.sharedInstance.globalDic)
ConfigurationManager.sharedInstance.globalDic = tmpDic
let gScopeManagerSharedInstance = ScopeManager() class ScopeManager { }
func init() -> ClassA { struct Static { static var onceToken : dispatch_once_t = 0 static var instance : ClassA? = nil } dispatch_once(&Static.onceToken) { Static.instance = ClassA() } return Static.instance! }
class AppManager { private static let _sharedInstance = AppManager() class func getSharedInstance() -> AppManager { return _sharedInstance } private init() {} } AppManager.getSharedInstance()
class AppManager { static let sharedInstance = AppManager() private init() {} } AppManager.sharedInstance
public class Singleton { private static var sharedInstanceVar = Singleton() public class func sharedInstance()->Singleton { return sharedInstanceVar } } public class SubSingleton: Singleton { private static var sharedInstanceToken:dispatch_once_t = 0 public class override func sharedInstance()->SubSingleton { dispatch_once(&sharedInstanceToken){ sharedInstanceVar = SubSingleton() } return sharedInstanceVar as! SubSingleton } }
struct DataService { private static var _instance : DataService? private init() {} public static var instance : DataService { get { if _instance == nil { DispatchQueue.global().sync(flags: .barrier) { if _instance == nil { _instance = DataService() } } } return _instance! } } }
class MySingletonClass { static let sharedSingleton = MySingletonClass() private init() {} }
let TEST = Test() class Test { private init() { } }
private var sharedURLCacheForRequestsKey:Void? extension URLCache{ public static func sharedURLCacheForRequests()->URLCache{ var cache = objc_getAssociatedObject(OperationQueue.main, &sharedURLCacheForRequestsKey) if cache is URLCache { }else{ cache = URLCache(memoryCapacity: 0, diskCapacity: 1*1024*1024*1024, diskPath: "sharedURLCacheForRequestsKey") objc_setAssociatedObject(OperationQueue.main, &sharedURLCacheForRequestsKey, cache, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } return cache as! URLCache }}
public final class Singleton { private class func sharedInstance() -> Singleton { struct Static { static let sharedInstance = Singleton() } return Static.sharedInstance } private init() { } class var instance: Singleton { return sharedInstance() } }
dispatch_after(when: dispatch_time_t, queue: dispatch_queue_t, block: dispatch_block_t?)
let delayTime = dispatch_time(DISPATCH_TIME_NOW, Int64(1 * Double(NSEC_PER_SEC))) dispatch_after(delayTime, dispatch_get_main_queue()) { print("test") }
let deadlineTime = DispatchTime.now() + .seconds(1) DispatchQueue.main.asyncAfter(deadline: deadlineTime) { print("test") }
func delay(delay:Double, closure:()->()) { dispatch_after( dispatch_time( DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC)) ), dispatch_get_main_queue(), closure) }
func delay(_ delay:Double, closure:@escaping ()->()) { let when = DispatchTime.now() + delay DispatchQueue.main.asyncAfter(deadline: when, execute: closure) }
let delay = 4.5 * Double(NSEC_PER_SEC) let time = dispatch_time(DISPATCH_TIME_NOW, Int64(delay)) dispatch_after(time, dispatch_get_main_queue(), block)
DispatchQueue.main.asyncAfter(deadline: .now() + 4.5) { }
typealias dispatch_cancelable_closure = (cancel : Bool) -> Void func delay(time:NSTimeInterval, closure:()->Void) -> dispatch_cancelable_closure? { func dispatch_later(clsr:()->Void) { dispatch_after( dispatch_time( DISPATCH_TIME_NOW, Int64(time * Double(NSEC_PER_SEC)) ), dispatch_get_main_queue(), clsr) } var closure:dispatch_block_t? = closure var cancelableClosure:dispatch_cancelable_closure? let delayedClosure:dispatch_cancelable_closure = { cancel in if closure != nil { if (cancel == false) { dispatch_async(dispatch_get_main_queue(), closure!); } } closure = nil cancelableClosure = nil } cancelableClosure = delayedClosure dispatch_later { if let delayedClosure = cancelableClosure { delayedClosure(cancel: false) } } return cancelableClosure; } func cancel_delay(closure:dispatch_cancelable_closure?) { if closure != nil { closure!(cancel: true) } }
let retVal = delay(2.0) { println("Later") } delay(1.0) { cancel_delay(retVal) }
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(< < });
DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + < < }
func delayWithSeconds(_ seconds: Double, completion: @escaping () -> ()) { DispatchQueue.main.asyncAfter(deadline: .now() + seconds) { completion() } }
extension Double { var dispatchTime: dispatch_time_t { get { return dispatch_time(DISPATCH_TIME_NOW,Int64(self * Double(NSEC_PER_SEC))) } } }
dispatch_after(Double(2.0).dispatchTime, dispatch_get_main_queue(), { () -> Void in self.dismissViewControllerAnimated(true, completion: nil) })
DispatchQueue(label: "test").async { for obj in 0...1000 { print("async \(obj)") } DispatchQueue.main.async(execute: { print("UI update on main queue") }) } DispatchQueue(label: "m").sync { for obj in 0...1000 { print("sync \(obj)") } DispatchQueue.main.sync(execute: { print("UI update on main queue") }) }
DispatchQueue.main.after(when: DispatchTime.now() + 5) { print("Dispatch after 5 sec") }
extension UIViewController{ func runAfterDelay(delay: NSTimeInterval, block: dispatch_block_t) { let time = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) dispatch_after(time, dispatch_get_main_queue(), block) } }
self.runAfterDelay(5.0, block: { print("run After Delay Success") })
override func viewWillAppear(animated: Bool) { dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 2), dispatch_get_main_queue(), { () -> () in })
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 2), dispatch_get_main_queue()) { }
func performAfterDelay(delay : Double, onCompletion: @escaping() -> Void){ DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + delay, execute: { onCompletion() }) }
timer.invalidate() timer = NSTimer.scheduledTimerWithTimeInterval(2.0, target: self, selector:
func delayedAction() { print("Delayed action has now started." }
NSTimer.scheduledTimerWithTimeInterval(2.0, target: self, selector:
extension DispatchQueue { static func delay(_ delay: DispatchTimeInterval, closure: @escaping () -> ()) { let timeInterval = DispatchTime.now() + delay DispatchQueue.main.asyncAfter(deadline: timeInterval, execute: closure) } }
DispatchQueue.delay(.seconds(1)) { print("This is after delay") }
DispatchQueue.main.asyncAfter(deadline: .now() + 0.9) { DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { } }
* self.startAnimation() DispatchQueue.main.asyncAfter(deadline: .now() + 0.9) { * self.stopAnimation() DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { * self.fetchData() self.updateUI() } }
public func delay(bySeconds seconds: Double, dispatchLevel: DispatchLevel = .main, closure: @escaping () -> Void) { let dispatchTime = DispatchTime.now() + seconds dispatchLevel.dispatchQueue.asyncAfter(deadline: dispatchTime, execute: closure) } public enum DispatchLevel { case main, userInteractive, userInitiated, utility, background var dispatchQueue: DispatchQueue { switch self { case .main: return DispatchQueue.main case .userInteractive: return DispatchQueue.global(qos: .userInteractive) case .userInitiated: return DispatchQueue.global(qos: .userInitiated) case .utility: return DispatchQueue.global(qos: .utility) case .background: return DispatchQueue.global(qos: .background) } } }
delay(bySeconds: 1.5, dispatchLevel: .background) { }
let time1 = 8.23 let time2 = 3.42 DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { print("Sum of times: \(time1 + time2)") }
CGFloat time1 = 3.49; CGFloat time2 = 8.13; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ CGFloat newTime = time1 + time2; NSLog(@"New time: %f", newTime); });
public extension DispatchQueue { private class func delay(delay: TimeInterval, closure: @escaping () -> Void) { let when = DispatchTime.now() + delay DispatchQueue.main.asyncAfter(deadline: when, execute: closure) } class func performAction(after seconds: TimeInterval, callBack: @escaping (() -> Void) ) { DispatchQueue.delay(delay: seconds) { callBack() } } }
let delayQueue = DispatchQueue(label: "com.theappmaker.in", qos: .userInitiated) let additionalTime: DispatchTimeInterval = .seconds(2)
delayQueue.asyncAfter(deadline: .now() + 0.60) { print(Date()) } delayQueue.asyncAfter(deadline: .now() + additionalTime) { print(Date()) }
let delay = 2.0 let delayInNanoSeconds = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) let mainQueue = dispatch_get_main_queue() dispatch_after(delayInNanoSeconds, mainQueue, { print("Some UI related task after delay") })
func performAfterDelay(delay : Double, onCompletion: @escaping() -> Void){ DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + delay, execute: { onCompletion() }) }
let seconds = 3.0 Async.main(after: seconds) { print("Is called after 3 seconds") }.background(after: 6.0) { print("At least 3.0 seconds after previous block, and 6.0 after Async code is called") }
Timer.scheduledTimer(withTimeInterval: 2, repeats: false) { (timer) in print("hello") }
let delayInSec = 1.0 DispatchQueue.main.asyncAfter(deadline: .now() + delayInSec) { print("It works") }
dyld: Library not loaded: @rpath/FrameworkTest03.framework/FrameworkTest03 Referenced from: /var/mobile/Applications/FA6BAAC8-1AAD-49B4-8326-F30F66458CB6/FrameworkTest03App.app/FrameworkTest03App Reason: image not found
PBXCp /Users/xyz/Library/Developer/Xcode/DerivedData/MyApp-cbcnqafhywqkjufwsvbzckecmjjs/Build/Products/Debug-iphoneos/MyFramework.framework
"üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("üë©‚Äçüë©‚Äçüëß‚Äçüë¶") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("üë©") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("\u{200D}") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("üëß") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("üë¶")
let manual = "\u{1F469}\u{200D}\u{1F469}\u{200D}\u{1F467}\u{200D}\u{1F466}" Array(manual.characters)
manual.contains("üë©") manual.contains("üëß") manual.contains("üë¶")
print("üë©‚Äçüë©‚Äçüëß‚Äçüë¶".characters.count) print("üë©‚Äçüë©‚Äçüëß‚Äçüë¶".unicodeScalars.count)
for char in "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".characters { print(char) let scalars = String(char).unicodeScalars.map({ String($0.value, radix: 16) }) print(scalars) }
let s = "\u{1f469}\u{200d}\u{1f469}\u{200d}\u{1f467}\u{200d}\u{1f466}" s.range(of: "\u{1f469}\u{200d}") != nil s.range(of: "\u{1f469}\u{200d}\u{1f469}") != nil
s.range(of: "\u{1f466}") != nil s.range(of: "\u{1f467}\u{200d}\u{1f466}") != nil s.range(of: "\u{1f469}\u{200d}\u{1f467}\u{200d}\u{1f466}") != nil s.contains("\u{1f469}\u{200d}\u{1f467}\u{200d}\u{1f466}")
extension String { func contains(_ string: String) -> Bool { return self.range(of: string, options: String.CompareOptions.literal) != nil } }
s.contains("üë©") s.contains("üë©\u{200d}") s.contains("\u{200d}")
"üë©‚Äçüë©‚Äçüëß‚Äçüë¶".characters.forEach { print($0) } üë©‚Äç üë©‚Äç üëß‚Äç üë¶
"üë©‚Äçüë©‚Äçüëß‚Äçüë¶".characters.forEach { print(String($0).unicodeScalars.map{$0}) } ["\u{0001F469}", "\u{200D}"] ["\u{0001F469}", "\u{200D}"] ["\u{0001F467}", "\u{200D}"] ["\u{0001F466}"]
"üë©‚Äçüë©‚Äçüëß‚Äçüë¶".unicodeScalars.contains("üë©") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".unicodeScalars.contains("\u{200D}") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".unicodeScalars.contains("üëß") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".unicodeScalars.contains("üë¶")
Array(manual.characters).map { $0.description.unicodeScalars }
‚ñø 4 elements ‚ñø 0 : StringUnicodeScalarView("üë©‚Äç") - 0 : "\u{0001F469}" - 1 : "\u{200D}" ‚ñø 1 : StringUnicodeScalarView("üë©‚Äç") - 0 : "\u{0001F469}" - 1 : "\u{200D}" ‚ñø 2 : StringUnicodeScalarView("üëß‚Äç") - 0 : "\u{0001F467}" - 1 : "\u{200D}" ‚ñø 3 : StringUnicodeScalarView("üë¶") - 0 : "\u{0001F466}"
"üëçüèΩ".unicodeScalars.count "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".unicodeScalars.count
"üëçüèΩ".contains("üëç") "üëçüèΩ".contains("üèΩ") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("üë©‚Äçüë©‚Äçüëß‚Äçüë¶") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("üë©") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("\u{200D}") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("üëß") "üë©‚Äçüë©‚Äçüëß‚Äçüë¶".contains("üë¶")
@objc protocol MyProtocol { @objc optional func doSomething() } class MyClass : MyProtocol { }
protocol MyProtocol { func doSomethingNonOptionalMethod() func doSomethingOptionalMethod() } extension MyProtocol { func doSomethingOptionalMethod(){ } }
struct Info { var height: Int var weight: Int } @objc protocol Health { func isInfoHealthy(info: Info) -> Bool }
protocol Health { var isInfoHealthy: (Info) -> (Bool)? { get set } }
class Human: Health { var isInfoHealthy: (Info) -> (Bool)? = { info in if info.weight < 200 && info.height > 72 { return true } return false } }
func returnEntity() -> Health { return Human() } var anEntity: Health = returnEntity() var isHealthy = anEntity.isInfoHealthy(Info(height: 75, weight: 150))?
@objc protocol CounterDataSource { @objc optional func increment(forCount count: Int) -> Int @objc optional var fixedIncrement: Int { get } }
@objc protocol MyProtocol:class { func requiredMethod() optional func optionalMethod() } class MyClass: NSObject { weak var delegate:MyProtocol? func callDelegate() { delegate?.requiredMethod() delegate?.optionalMethod?() } }
class AnotherClass: NSObject, MyProtocol { init() { super.init() let myInstance = MyClass() myInstance.delegate = self } func requiredMethod() { } }
protocol Cancelable { func cancel() } extension Cancelable { func cancel() {} } class Plane: Cancelable { } let plane = Plane() plane.cancel()
protocol MyProtocol { func foo() } protocol MyExtendedProtocol: MyProtocol { func bar() } class MyClass { var delegate: MyProtocol func myMethod() { (delegate as? MyExtendedProtocol).bar() } }
protocol SomeProtocol { func aMethod() } extension SomeProtocol { func aMethod() { print("extensionImplementation") } } class protocolImplementingObject: SomeProtocol { } class protocolImplementingMethodOverridingObject: SomeProtocol { func aMethod() { print("classImplementation") } } let noOverride = protocolImplementingObject() let override = protocolImplementingMethodOverridingObject() noOverride.aMethod() override.aMethod()
protocol SomeProtocol { var required: String { get } var optional: String? { get } }
extension SomeProtocol { var optional: String? { return nil } }
struct ConformsWithoutOptional { let required: String } struct ConformsWithOptional { let required: String let optional: String? }
@objc protocol CollectionOfDataDelegate{ optional func indexDidChange(index: Int) } @objc class RootView: CollectionOfDataDelegate{ var data = CollectionOfData() init(){ data.delegate = self data.indexIsNow() } func indexDidChange(index: Int) { println("The index is currently: \(index)") } } class CollectionOfData{ var index : Int? weak var delegate : CollectionOfDataDelegate? func indexIsNow(){ index = 23 delegate?.indexDidChange?(index!) } }
struct magicDatas { var damagePoints : Int? var manaPoints : Int? } protocol magicCastDelegate { func castFire() -> magicDatas func castIce() -> magicDatas } extension magicCastDelegate { func castFire() -> magicDatas { return magicDatas() } func castIce() -> magicDatas { return magicDatas() } }
@objc protocol Protocol { @objc optional var name:String? } class MyClass: Protocol { }
@IBOutlet var txtBox1 : UITextField @IBOutlet var txtBox2 : UITextField @IBOutlet var txtBox3 : UITextField @IBOutlet var lblAnswer : UILabel @IBAction func btn1(sender : AnyObject) { let answer1 = "The acceleration is" var answer2 = txtBox1 var answer3 = txtBox2 var answer4 = txtBox3
let a:Int? = firstText.text.toInt() let b:Int? = secondText.text.toInt() if a && b { var ans = a! + b! answerLabel.text = "Answer is \(ans)" } else { answerLabel.text = "Input values are not numeric" }
... let a:Int? = Int(firstText.text) let b:Int? = Int(secondText.text) ...
let a:Int? = Int(firstText.text) let b:Int? = Int(secondText.text)
let myString = "556" let myInt = (myString as NSString).integerValue
class IntegerField: UITextField { var integer: Int { return string.digits.integer } override func willMove(toSuperview newSuperview: UIView?) { addTarget(self, action: keyboardType = .numberPad textAlignment = .right editingChanged() } func editingChanged() { text = Formatter.decimal.string(for: integer) print(integer) } }
extension Sequence where Iterator.Element == UnicodeScalar { var string: String { return String(String.UnicodeScalarView(self)) } } extension Formatter { static let decimal = NumberFormatter(numberStyle: .decimal) } extension UITextField { var string: String { return text ?? "" } } extension String { private static var digitsPattern = UnicodeScalar("0")..."9" var digits: String { return unicodeScalars.filter { String.digitsPattern ~= $0 }.string } var integer: Int { return Int(self) ?? 0 } } extension NumberFormatter { convenience init(numberStyle: Style) { self.init() self.numberStyle = numberStyle } }
var myString = "\(10)" if let myNumber = NSNumberFormatter().numberFromString(myString) { var myInt = myNumber.integerValue } else { }
let stringNumber = "123" let number = Int(stringNumber) if number != nil { }
let occur = "10" if let occ = Int(occur) { print("By optional binding :", occ*2) }
@IBOutlet var textFieldA : UITextField @IBOutlet var textFieldB : UITextField @IBOutlet var answerLabel : UILabel @IBAction func calculate(sender : AnyObject) { if let intValueA = Int(textFieldA), let intValueB = Int(textFieldB) { let result = intValueA + intValueB answerLabel.text = "The acceleration is \(result)" } else { answerLabel.text = "The value \(intValueA) and/or \(intValueB) are not a valid integer value" } }
textFieldA.keyboardType = .numberPad textFieldB.keyboardType = .numberPad
extension String { var numberValue:NSNumber? { let formatter = NumberFormatter() formatter.numberStyle = .decimal return formatter.number(from: self) } } let someFloat = "12".numberValue
@IBOutlet weak var result: UILabel! @IBOutlet weak var one: UITextField! @IBOutlet weak var two: UITextField! @IBAction func add(sender: AnyObject) { let count = Int(one.text!) let cal = Int(two.text!) let sum = count! + cal! result.text = "Sum is \(sum)" }
let bytesInternet : Int64 = Int64(bytesInternetString)!
func getNumber(number: Any?) -> NSNumber { guard let statusNumber:NSNumber = number as? NSNumber else { guard let statString:String = number as? String else { return 0 } if let myInteger = Int(statString) { return NSNumber(value:myInteger) } else{ return 0 } } return statusNumber }
let number:String = "9834" print("printing number \(getNumber(number: number))")
let number:Double = 9834 print("printing number \(getNumber(number: number))")
let number = 9834 print("printing number \(getNumber(number: number))")
let string:String = "789" let intValue:Int = Int(string)! print(intValue) let integerValue:Int = 789 let stringValue:String = String(integerValue) print(stringValue)
guard let labelInt:Int = Int(labelString) else { return } useLabelInt()
let a:Double = firstText.text.bridgeToObjectiveC().doubleValue let b:Double = secondText.text.bridgeToObjectiveC().doubleValue if (a != 0.0) && (b != 0.0) { var ans = a + b answerLabel.text = "Answer is \(ans)" } else { answerLabel.text = "Input values are not numberic" }
var ans = a + b answerLabel.text = "Answer is \(ans)"
let num:Int? = Int(firstTextField.text!); let sum:Int = num!-2 print(sum);
extension String { func toInt(defaultValue: Int) -> Int { if let n = Int(self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)) { return n } else { return defaultValue } } }
let myString: String = "256" let myInt: Int? = myString.toInt()
let myString: String = "256" let myInt: Int? = Int(myString)
extension String { func add(a: Int) -> Int? { if let b = Int(self) { return b + a } else { return nil } } }
extension String { func toInt(default: Int) -> Int { if let result = Int(self) { return result } else { return default } } }
@IBAction func calculateAclr(_ sender: Any) { if let addition = addition(arrayString: [txtBox1.text, txtBox2.text, txtBox3.text]) { print("Answer = \(addition)") lblAnswer.text = "\(addition)" } } func addition(arrayString: [Any?]) -> Int? { var answer:Int? for arrayElement in arrayString { if let stringValue = arrayElement, let intValue = Int(stringValue) { answer = (answer ?? 0) + intValue } } return answer }
let prefs = UserDefaults.standard var counter: String! counter = prefs.string(forKey:"counter") print("counter: \(counter!)") var counterInt = Int(counter!) counterInt = counterInt! + 1 print("counterInt: \(counterInt!)") OUTPUT: counter: 1 counterInt: 2
let strValue = "123" let result = (strValue as NSString).integerValue
let strValue:String = "100" let intValue = strValue as! Int var intValueFromString:Int = strValue as! Int or var intValueFromString = Int(strValue)!
var array = ["1", "2", "3"] let stringRepresentation = "-".join(array)
var array = ["1", "2", "3"] let stringRepresentation = array.joinWithSeparator("-")
var array = ["1", "2", "3"] array.joined(separator:"-")
let characterArray: [Character] = ["J", "o", "h", "n"] let string = String(characterArray) print(string)
let stringArray = ["Foo", "Bar", "Baz"] let characterArray = stringArray.flatMap { String.CharacterView($0) } let string = String(characterArray) print(string)
let stringArray = ["Bob", "Dan", "Bryan"] let string = stringArray.joined(separator: " ") print(string)
let stringArray = ["car", "bike", "boat"] let stringArray2 = stringArray.flatMap { String.CharacterView($0) }.map { String($0) } let string = stringArray2.joined(separator: ", ") print(string)
let floatArray = [12, 14.6, 35] let stringArray = floatArray.flatMap { String($0) } let string = stringArray.joined(separator: "-") print(string)
var array = ["1", "2", "3"] let stringRepresentation = array.joinWithSeparator("-")
extension SequenceType where Generator.Element == String { @warn_unused_result public func joinWithSeparator(separator: String) -> String }
let array:[String] = ["Apple", "Pear ","Orange"] array.joined(separator: " ")
let array : [String?] = ["1",nil,"2","3","4"] let separator = "," let joinedString = array.flatMap{ $0 }.joined(separator: separator) let joinedString = array.compactMap{ $0 }.joined(separator: separator print(joinedString)
var array = ["1", "2", "3"] let stringRepresentation = array.componentsJoinedByString("-")
let stringWithCommas = (yourArray as NSArray).componentsJoinedByString(",")
let arrayTemp :[String] = ["Mani","Singh","iOS Developer"] let stringAfterCombining = arrayTemp.componentsJoinedByString(" ") print("Result will be >>> \(stringAfterCombining)")
["Jet", "Fire"].filter { !$0.isEmpty }.joined(separator: "-")
["Jet", nil, "", "Fire"].flatMap { $0 }.filter { !$0.isEmpty }.joined(separator: "-")
extension Array { var string: String? { do { let data = try JSONSerialization.data(withJSONObject: self, options: [.prettyPrinted]) return String(data: data, encoding: .utf8) } catch { return nil } } }
let array = [1,2,3,4] print(array) let string = "\(array)" print(string)
let array: [String] = ["red", "green", "blue"] let arrayAsString: String = array.description let stringAsData = arrayAsString.data(using: String.Encoding.utf16) let arrayBack: [String] = try! JSONDecoder().decode([String].self, from: stringAsData!)
let set: Set<Double> = [1, 2.0, 3] let setAsString: String = set.description let setStringAsData = setAsString.data(using: String.Encoding.utf16) let setBack: Set<Double> = try! JSONDecoder().decode(Set<Double>.self, from: setStringAsData!)
let arrayList = list.map { Int($0)!} arrayList.description
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { if textField == phoneField { let newString = NSString(string: textField.text!).replacingCharacters(in: range, with: string) let components = newString.components(separatedBy: NSCharacterSet.decimalDigits.inverted) let decimalString = NSString(string: components.joined(separator: "")) let length = decimalString.length let hasLeadingOne = length > 0 && decimalString.character(at: 0) == (1 as unichar) if length == 0 || (length > 10 && !hasLeadingOne) || length > 11 { let newLength = NSString(string: textField.text!).length + (string as NSString).length - range.length as Int return (newLength > 10) ? false : true } var index = 0 as Int let formattedString = NSMutableString() if hasLeadingOne { formattedString.append("1 ") index += 1 } if (length - index) > 3 { let areaCode = decimalString.substring(with: NSMakeRange(index, 3)) formattedString.appendFormat("(%@)", areaCode) index += 3 } if length - index > 3 { let prefix = decimalString.substring(with: NSMakeRange(index, 3)) formattedString.appendFormat("%@-", prefix) index += 3 } let remainder = decimalString.substring(from: index) formattedString.append(remainder) textField.text = formattedString as String return false } else { return true } }
let x = 1.23556789 let y = Double(round(1000*x)/1000) print(y)
extension Double { func roundToPlaces(places:Int) -> Double { let divisor = pow(10.0, Double(places)) return round(self * divisor) / divisor } }
extension Double { func rounded(toPlaces places:Int) -> Double { let divisor = pow(10.0, Double(places)) return (self * divisor).rounded() / divisor } }
let x = Double(0.123456789).roundToPlaces(4) let x = Double(0.123456789).rounded(toPlaces: 4)
print(String(format: "%.3f", totalWorkTimeInHours))
let roundedValue1 = (0.6844 * 1000).rounded() / 1000 let roundedValue2 = (0.6849 * 1000).rounded() / 1000 print(roundedValue1) print(roundedValue2)
var roundedValue1 = (0.6844 * 1000).rounded(.toNearestOrEven) / 1000 var roundedValue2 = (0.6849 * 1000).rounded(.toNearestOrEven) / 1000 print(roundedValue1) print(roundedValue2)
import Foundation let roundedValue1 = round(0.6844 * 1000) / 1000 let roundedValue2 = round(0.6849 * 1000) / 1000 print(roundedValue1) print(roundedValue2)
import Foundation extension Double { func roundToDecimal(_ fractionDigits: Int) -> Double { let multiplier = pow(10, Double(fractionDigits)) return Darwin.round(self * multiplier) / multiplier } } let roundedValue1 = 0.6844.roundToDecimal(3) let roundedValue2 = 0.6849.roundToDecimal(3) print(roundedValue1) print(roundedValue2)
import Foundation let scale: Int16 = 3 let behavior = NSDecimalNumberHandler(roundingMode: .plain, scale: scale, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow: false, raiseOnDivideByZero: true) let roundedValue1 = NSDecimalNumber(value: 0.6844).rounding(accordingToBehavior: behavior) let roundedValue2 = NSDecimalNumber(value: 0.6849).rounding(accordingToBehavior: behavior) print(roundedValue1) print(roundedValue2)
import Foundation let scale = 3 var value1 = Decimal(0.6844) var value2 = Decimal(0.6849) var roundedValue1 = Decimal() var roundedValue2 = Decimal() NSDecimalRound(&roundedValue1, &value1, scale, NSDecimalNumber.RoundingMode.plain) NSDecimalRound(&roundedValue2, &value2, scale, NSDecimalNumber.RoundingMode.plain) print(roundedValue1) print(roundedValue2)
import Foundation let roundedValue1 = NSString(format: "%.3f", 0.6844) let roundedValue2 = NSString(format: "%.3f", 0.6849) print(roundedValue1) print(roundedValue2)
import Foundation let roundedValue1 = String(format: "%.3f", 0.6844) let roundedValue2 = String(format: "%.3f", 0.6849) print(roundedValue1) print(roundedValue2)
import Foundation let formatter = NumberFormatter() formatter.numberStyle = NumberFormatter.Style.decimal formatter.roundingMode = NumberFormatter.RoundingMode.halfUp formatter.maximumFractionDigits = 3 let roundedValue1 = formatter.string(from: 0.6844) let roundedValue2 = formatter.string(from: 0.6849) print(String(describing: roundedValue1)) print(String(describing: roundedValue2))
let pi: Double = 3.14159265358979 String(format:"%.2f", pi)
func roundToPlaces(value:Double, places:Int) -> Double { let divisor = pow(10.0, Double(places)) return round(value * divisor) / divisor }
let doubleValue : Double = 123.32565254455 self.lblValue.text = String(format:"%.f", doubleValue) print(self.lblValue.text)
self.lblValue_1.text = String(format:"%.1f", doubleValue) print(self.lblValue_1.text)
self.lblValue_2.text = String(format:"%.2f", doubleValue) print(self.lblValue_2.text)
self.lblValue_3.text = String(format:"%.3f", doubleValue) print(self.lblValue_3.text)
var a = 1.543240952039 var roundedString = String(format: "%.3f", a)
extension Double { func roundTo(places: Int) -> Double { let divisor = pow(10.0, Double(places)) return (self * divisor).rounded() / divisor } }
let doubleValue = 3.567 let roundedValue = doubleValue.roundTo(places: 2) print(roundedValue)
extension Double { var roundTo2f: Double {return Double(round(100 *self)/100) } var roundTo3f: Double {return Double(round(1000*self)/1000) } }
let regularPie: Double = 3.14159 var smallerPie: Double = regularPie.roundTo3f var smallestPie: Double = regularPie.roundTo2f
extension Double { func round(to places: Int) -> Double { let divisor = pow(10.0, Double(places)) return Darwin.round(self * divisor) / divisor } }
let number:Double = 12.987654321 print(number.round(to: 3))
let numberFormatter: NSNumberFormatter = { let nf = NSNumberFormatter() nf.numberStyle = .DecimalStyle nf.minimumFractionDigits = 0 nf.maximumFractionDigits = 1 return nf }()
print(String(format: "%.3f", totalWorkTimeInHours))
pow10np = pow(10,num_places); val = round(val*pow10np) / pow10np;
extension Double { func roundTo(places:Int) -> Double { guard self != 0.0 else { return 0 } let divisor = pow(10.0, Double(places) - ceil(log10(fabs(self)))) return (self * divisor).rounded() / divisor } }
extension Double { func rounded(toDecimalPlaces n: Int) -> Double { return Double(String(format: "%.\(n)f", self))! } }
extension Double { func rounded(toDecimalPlaces n: Int) -> Double { let multiplier = pow(10, Double(n)) return (multiplier * self).rounded()/multiplier } }
mutating func round(_ rule: FloatingPointRoundingRule)
var x = 1.5657676754 var y = (x*10000).rounded()/10000 print(y)
var x = 1.5657676754 var y = (x*100).rounded()/100 print(y)
var x = 1.5657676754 var y = (x*10).rounded()/10 print(y)
extension Double { func roundedDecimal(to scale: Int = 0, mode: NSDecimalNumber.RoundingMode = .plain) -> Decimal { var decimalValue = Decimal(self) var result = Decimal() NSDecimalRound(&result, &decimalValue, scale, mode) return result } }
let foo = 427.3000000002 let value = foo.roundedDecimal(to: 2)
let formatter = NumberFormatter() formatter.maximumFractionDigits = 2 formatter.minimumFractionDigits = 2 if let string = formatter.string(for: value) { print(string) }
func checkDoublesForOnlyTwoDecimalsOrLess()->Bool{ var theTransactionCharacterMinusThree: Character = "A" var theTransactionCharacterMinusTwo: Character = "A" var theTransactionCharacterMinusOne: Character = "A" var result = false var periodCharacter:Character = "." var myCopyString = transactionAmount.text! if myCopyString.containsString(".") { if( myCopyString.characters.count >= 3){ theTransactionCharacterMinusThree = myCopyString[myCopyString.endIndex.advancedBy(-3)] } if( myCopyString.characters.count >= 2){ theTransactionCharacterMinusTwo = myCopyString[myCopyString.endIndex.advancedBy(-2)] } if( myCopyString.characters.count > 1){ theTransactionCharacterMinusOne = myCopyString[myCopyString.endIndex.advancedBy(-1)] } if theTransactionCharacterMinusThree == periodCharacter { result = true } if theTransactionCharacterMinusTwo == periodCharacter { result = true } if theTransactionCharacterMinusOne == periodCharacter { result = true } }else { result = true } return result }
let coordinateSource = CLLocation(latitude: 30.7717625, longitude:76.5741449 ) let coordinateDestination = CLLocation(latitude: 29.9810859, longitude: 76.5663599) let distanceInMeters = coordinateSource.distance(from: coordinateDestination) let valueInKms = distanceInMeters/1000 let preciseValueUptoThreeDigit = Double(round(1000*valueInKms)/1000) self.lblTotalDistance.text = "Distance is : \(preciseValueUptoThreeDigit) kms"
struct utsname systemInfo; uname(&systemInfo); NSString* deviceModel = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];
import UIKit public extension UIDevice { static let modelName: String = { var systemInfo = utsname() uname(&systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") { identifier, element in guard let value = element.value as? Int8, value != 0 else { return identifier } return identifier + String(UnicodeScalar(UInt8(value))) } func mapToDevice(identifier: String) -> String { switch identifier { case "iPod5,1": return "iPod Touch 5" case "iPod7,1": return "iPod Touch 6" case "iPhone3,1", "iPhone3,2", "iPhone3,3": return "iPhone 4" case "iPhone4,1": return "iPhone 4s" case "iPhone5,1", "iPhone5,2": return "iPhone 5" case "iPhone5,3", "iPhone5,4": return "iPhone 5c" case "iPhone6,1", "iPhone6,2": return "iPhone 5s" case "iPhone7,2": return "iPhone 6" case "iPhone7,1": return "iPhone 6 Plus" case "iPhone8,1": return "iPhone 6s" case "iPhone8,2": return "iPhone 6s Plus" case "iPhone9,1", "iPhone9,3": return "iPhone 7" case "iPhone9,2", "iPhone9,4": return "iPhone 7 Plus" case "iPhone8,4": return "iPhone SE" case "iPhone10,1", "iPhone10,4": return "iPhone 8" case "iPhone10,2", "iPhone10,5": return "iPhone 8 Plus" case "iPhone10,3", "iPhone10,6": return "iPhone X" case "iPhone11,2": return "iPhone XS" case "iPhone11,4", "iPhone11,6": return "iPhone XS Max" case "iPhone11,8": return "iPhone XR" case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2" case "iPad3,1", "iPad3,2", "iPad3,3": return "iPad 3" case "iPad3,4", "iPad3,5", "iPad3,6": return "iPad 4" case "iPad4,1", "iPad4,2", "iPad4,3": return "iPad Air" case "iPad5,3", "iPad5,4": return "iPad Air 2" case "iPad6,11", "iPad6,12": return "iPad 5" case "iPad7,5", "iPad7,6": return "iPad 6" case "iPad2,5", "iPad2,6", "iPad2,7": return "iPad Mini" case "iPad4,4", "iPad4,5", "iPad4,6": return "iPad Mini 2" case "iPad4,7", "iPad4,8", "iPad4,9": return "iPad Mini 3" case "iPad5,1", "iPad5,2": return "iPad Mini 4" case "iPad6,3", "iPad6,4": return "iPad Pro (9.7-inch)" case "iPad6,7", "iPad6,8": return "iPad Pro (12.9-inch)" case "iPad7,1", "iPad7,2": return "iPad Pro (12.9-inch) (2nd generation)" case "iPad7,3", "iPad7,4": return "iPad Pro (10.5-inch)" case "iPad8,1", "iPad8,2", "iPad8,3", "iPad8,4":return "iPad Pro (11-inch)" case "iPad8,5", "iPad8,6", "iPad8,7", "iPad8,8":return "iPad Pro (12.9-inch) (3rd generation)" case "AppleTV5,3": return "Apple TV" case "AppleTV6,2": return "Apple TV 4K" case "AudioAccessory1,1": return "HomePod" case "i386", "x86_64": return "Simulator \(mapToDevice(identifier: ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] ?? "iOS"))" default: return identifier } switch identifier { case "AppleTV5,3": return "Apple TV 4" case "AppleTV6,2": return "Apple TV 4K" case "i386", "x86_64": return "Simulator \(mapToDevice(identifier: ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] ?? "tvOS"))" default: return identifier } } return mapToDevice(identifier: identifier) }() }
switch UIDevice().type { case .iPhone5: print("No TouchID sensor") case .iPhone5S: fallthrough case .iPhone6: fallthrough case .iPhone6plus: fallthrough case .iPad_Pro9_7: fallthrough case .iPad_Pro12_9: fallthrough case .iPhone7: fallthrough case .iPhone7plus: print("Put your thumb on the " + UIDevice().type.rawValue + " TouchID sensor") case .unrecognized: print("Device model unrecognized"); default: print(UIDevice().type.rawValue + " not supported by this app"); }
// // import UIKit public enum Model : String { case simulator = "simulator/sandbox", iPod1 = "iPod 1", iPod2 = "iPod 2", iPod3 = "iPod 3", iPod4 = "iPod 4", iPod5 = "iPod 5", iPad2 = "iPad 2", iPad3 = "iPad 3", iPad4 = "iPad 4", iPhone4 = "iPhone 4", iPhone4S = "iPhone 4S", iPhone5 = "iPhone 5", iPhone5S = "iPhone 5S", iPhone5C = "iPhone 5C", iPadMini1 = "iPad Mini 1", iPadMini2 = "iPad Mini 2", iPadMini3 = "iPad Mini 3", iPadAir1 = "iPad Air 1", iPadAir2 = "iPad Air 2", iPadPro9_7 = "iPad Pro 9.7\"", iPadPro9_7_cell = "iPad Pro 9.7\" cellular", iPadPro10_5 = "iPad Pro 10.5\"", iPadPro10_5_cell = "iPad Pro 10.5\" cellular", iPadPro12_9 = "iPad Pro 12.9\"", iPadPro12_9_cell = "iPad Pro 12.9\" cellular", iPhone6 = "iPhone 6", iPhone6plus = "iPhone 6 Plus", iPhone6S = "iPhone 6S", iPhone6Splus = "iPhone 6S Plus", iPhoneSE = "iPhone SE", iPhone7 = "iPhone 7", iPhone7plus = "iPhone 7 Plus", iPhone8 = "iPhone 8", iPhone8plus = "iPhone 8 Plus", iPhoneX = "iPhone X", iPhoneXS = "iPhone XS", iPhoneXSmax = "iPhone XS Max", iPhoneXR = "iPhone XR", unrecognized = "?unrecognized?" } public extension UIDevice { public var type: Model { var systemInfo = utsname() uname(&systemInfo) let modelCode = withUnsafePointer(to: &systemInfo.machine) { $0.withMemoryRebound(to: CChar.self, capacity: 1) { ptr in String.init(validatingUTF8: ptr) } } var modelMap : [ String : Model ] = [ "i386" : .simulator, "x86_64" : .simulator, "iPod1,1" : .iPod1, "iPod2,1" : .iPod2, "iPod3,1" : .iPod3, "iPod4,1" : .iPod4, "iPod5,1" : .iPod5, "iPad2,1" : .iPad2, "iPad2,2" : .iPad2, "iPad2,3" : .iPad2, "iPad2,4" : .iPad2, "iPad2,5" : .iPadMini1, "iPad2,6" : .iPadMini1, "iPad2,7" : .iPadMini1, "iPhone3,1" : .iPhone4, "iPhone3,2" : .iPhone4, "iPhone3,3" : .iPhone4, "iPhone4,1" : .iPhone4S, "iPhone5,1" : .iPhone5, "iPhone5,2" : .iPhone5, "iPhone5,3" : .iPhone5C, "iPhone5,4" : .iPhone5C, "iPad3,1" : .iPad3, "iPad3,2" : .iPad3, "iPad3,3" : .iPad3, "iPad3,4" : .iPad4, "iPad3,5" : .iPad4, "iPad3,6" : .iPad4, "iPhone6,1" : .iPhone5S, "iPhone6,2" : .iPhone5S, "iPad4,1" : .iPadAir1, "iPad4,2" : .iPadAir2, "iPad4,4" : .iPadMini2, "iPad4,5" : .iPadMini2, "iPad4,6" : .iPadMini2, "iPad4,7" : .iPadMini3, "iPad4,8" : .iPadMini3, "iPad4,9" : .iPadMini3, "iPad6,3" : .iPadPro9_7, "iPad6,11" : .iPadPro9_7, "iPad6,4" : .iPadPro9_7_cell, "iPad6,12" : .iPadPro9_7_cell, "iPad6,7" : .iPadPro12_9, "iPad6,8" : .iPadPro12_9_cell, "iPad7,3" : .iPadPro10_5, "iPad7,4" : .iPadPro10_5_cell, "iPhone7,1" : .iPhone6plus, "iPhone7,2" : .iPhone6, "iPhone8,1" : .iPhone6S, "iPhone8,2" : .iPhone6Splus, "iPhone8,4" : .iPhoneSE, "iPhone9,1" : .iPhone7, "iPhone9,2" : .iPhone7plus, "iPhone9,3" : .iPhone7, "iPhone9,4" : .iPhone7plus, "iPhone10,1" : .iPhone8, "iPhone10,2" : .iPhone8plus, "iPhone10,3" : .iPhoneX, "iPhone10,6" : .iPhoneX, "iPhone11,2" : .iPhoneXS, "iPhone11,4" : .iPhoneXSmax, "iPhone11,6" : .iPhoneXSmax, "iPhone11,8" : .iPhoneXR ] if let model = modelMap[String.init(validatingUTF8: modelCode!)!] { return model } return Model.unrecognized } }
func modelIdentifier() -> String { if let simulatorModelIdentifier = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] { return simulatorModelIdentifier } var sysinfo = utsname() uname(&sysinfo) return String(bytes: Data(bytes: &sysinfo.machine, count: Int(_SYS_NAMELEN)), encoding: .ascii)!.trimmingCharacters(in: .controlCharacters) }
func modelIdentifier() -> String { var sysinfo = utsname() uname(&sysinfo) return NSString(bytes: &sysinfo.machine, length: Int(_SYS_NAMELEN), encoding: NSASCIIStringEncoding)! as String }
public enum Model : String { case simulator = "simulator/sandbox", iPod1 = "iPod 1", iPod2 = "iPod 2", iPod3 = "iPod 3", iPod4 = "iPod 4", iPod5 = "iPod 5", iPad2 = "iPad 2", iPad3 = "iPad 3", iPad4 = "iPad 4", iPadAir = "iPad Air ", iPadAir2 = "iPad Air 2", iPad5 = "iPad 5", iPad6 = "iPad 6", iPadMini = "iPad Mini", iPadMini2 = "iPad Mini 2", iPadMini3 = "iPad Mini 3", iPadMini4 = "iPad Mini 4", iPadPro9_7 = "iPad Pro 9.7\"", iPadPro10_5 = "iPad Pro 10.5\"", iPadPro12_9 = "iPad Pro 12.9\"", iPadPro2_12_9 = "iPad Pro 2 12.9\"", iPhone4 = "iPhone 4", iPhone4S = "iPhone 4S", iPhone5 = "iPhone 5", iPhone5S = "iPhone 5S", iPhone5C = "iPhone 5C", iPhone6 = "iPhone 6", iPhone6plus = "iPhone 6 Plus", iPhone6S = "iPhone 6S", iPhone6Splus = "iPhone 6S Plus", iPhoneSE = "iPhone SE", iPhone7 = "iPhone 7", iPhone7plus = "iPhone 7 Plus", iPhone8 = "iPhone 8", iPhone8plus = "iPhone 8 Plus", iPhoneX = "iPhone X", iPhoneXS = "iPhone XS", iPhoneXSMax = "iPhone XS Max", iPhoneXR = "iPhone XR", AppleTV = "Apple TV", AppleTV_4K = "Apple TV 4K", unrecognized = "?unrecognized?" } public extension UIDevice { public var type: Model { var systemInfo = utsname() uname(&systemInfo) let modelCode = withUnsafePointer(to: &systemInfo.machine) { $0.withMemoryRebound(to: CChar.self, capacity: 1) { ptr in String.init(validatingUTF8: ptr) } } var modelMap : [ String : Model ] = [ "i386" : .simulator, "x86_64" : .simulator, "iPod1,1" : .iPod1, "iPod2,1" : .iPod2, "iPod3,1" : .iPod3, "iPod4,1" : .iPod4, "iPod5,1" : .iPod5, "iPad2,1" : .iPad2, "iPad2,2" : .iPad2, "iPad2,3" : .iPad2, "iPad2,4" : .iPad2, "iPad3,1" : .iPad3, "iPad3,2" : .iPad3, "iPad3,3" : .iPad3, "iPad3,4" : .iPad4, "iPad3,5" : .iPad4, "iPad3,6" : .iPad4, "iPad4,1" : .iPadAir, "iPad4,2" : .iPadAir, "iPad4,3" : .iPadAir, "iPad5,3" : .iPadAir2, "iPad5,4" : .iPadAir2, "iPad6,11" : .iPad5, "iPad6,12" : .iPad5, "iPad7,5" : .iPad6, "iPad7,6" : .iPad6, "iPad2,5" : .iPadMini, "iPad2,6" : .iPadMini, "iPad2,7" : .iPadMini, "iPad4,4" : .iPadMini2, "iPad4,5" : .iPadMini2, "iPad4,6" : .iPadMini2, "iPad4,7" : .iPadMini3, "iPad4,8" : .iPadMini3, "iPad4,9" : .iPadMini3, "iPad5,1" : .iPadMini4, "iPad5,2" : .iPadMini4, "iPad6,3" : .iPadPro9_7, "iPad6,4" : .iPadPro9_7, "iPad7,3" : .iPadPro10_5, "iPad7,4" : .iPadPro10_5, "iPad6,7" : .iPadPro12_9, "iPad6,8" : .iPadPro12_9, "iPad7,1" : .iPadPro2_12_9, "iPad7,2" : .iPadPro2_12_9, "iPhone3,1" : .iPhone4, "iPhone3,2" : .iPhone4, "iPhone3,3" : .iPhone4, "iPhone4,1" : .iPhone4S, "iPhone5,1" : .iPhone5, "iPhone5,2" : .iPhone5, "iPhone5,3" : .iPhone5C, "iPhone5,4" : .iPhone5C, "iPhone6,1" : .iPhone5S, "iPhone6,2" : .iPhone5S, "iPhone7,1" : .iPhone6plus, "iPhone7,2" : .iPhone6, "iPhone8,1" : .iPhone6S, "iPhone8,2" : .iPhone6Splus, "iPhone8,4" : .iPhoneSE, "iPhone9,1" : .iPhone7, "iPhone9,3" : .iPhone7, "iPhone9,2" : .iPhone7plus, "iPhone9,4" : .iPhone7plus, "iPhone10,1" : .iPhone8, "iPhone10,4" : .iPhone8, "iPhone10,2" : .iPhone8plus, "iPhone10,5" : .iPhone8plus, "iPhone10,3" : .iPhoneX, "iPhone10,6" : .iPhoneX, "iPhone11,2" : .iPhoneXS, "iPhone11,4" : .iPhoneXSMax, "iPhone11,6" : .iPhoneXSMax, "iPhone11,8" : .iPhoneXR, "AppleTV5,3" : .AppleTV, "AppleTV6,2" : .AppleTV_4K ] if let model = modelMap[String.init(validatingUTF8: modelCode!)!] { if model == .simulator { if let simModelCode = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] { if let simModel = modelMap[String.init(validatingUTF8: simModelCode)!] { return simModel } } } return model } return Model.unrecognized } }
var myDefaultFontSize:CGFloat = 26.0 switch UIDevice().type { case .iPhoneSE,.iPhone5,.iPhone5S: print("default value") case .iPhone6,.iPhone7,.iPhone8,.iPhone6S, .iPhoneX : myDefaultFontSize += 4 default:break }
import UIKit public extension UIDevice { var modelName: String { let DEVICE_IS_SIMULATOR = true let DEVICE_IS_SIMULATOR = false var machineString : String = "" if DEVICE_IS_SIMULATOR == true { if let dir = NSProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] { machineString = dir } } else { var systemInfo = utsname() uname(&systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) machineString = machineMirror.children.reduce("") { identifier, element in guard let value = element.value as? Int8 where value != 0 else { return identifier } return identifier + String(UnicodeScalar(UInt8(value))) } } switch machineString { case "iPod5,1": return "iPod Touch 5" case "iPod7,1": return "iPod Touch 6" case "iPhone3,1", "iPhone3,2", "iPhone3,3": return "iPhone 4" case "iPhone4,1": return "iPhone 4s" case "iPhone5,1", "iPhone5,2": return "iPhone 5" case "iPhone5,3", "iPhone5,4": return "iPhone 5c" case "iPhone6,1", "iPhone6,2": return "iPhone 5s" case "iPhone7,2": return "iPhone 6" case "iPhone7,1": return "iPhone 6 Plus" case "iPhone8,1": return "iPhone 6s" case "iPhone8,2": return "iPhone 6s Plus" case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2" case "iPad3,1", "iPad3,2", "iPad3,3": return "iPad 3" case "iPad3,4", "iPad3,5", "iPad3,6": return "iPad 4" case "iPad4,1", "iPad4,2", "iPad4,3": return "iPad Air" case "iPad5,3", "iPad5,4": return "iPad Air 2" case "iPad2,5", "iPad2,6", "iPad2,7": return "iPad Mini" case "iPad4,4", "iPad4,5", "iPad4,6": return "iPad Mini 2" case "iPad4,7", "iPad4,8", "iPad4,9": return "iPad Mini 3" case "iPad5,1", "iPad5,2": return "iPad Mini 4" case "iPad6,7", "iPad6,8": return "iPad Pro" case "AppleTV5,3": return "Apple TV" default: return machineString } } }
let deviceType = UIDevice.currentDevice().modelName if deviceType.lowercaseString.rangeOfString("iphone 4") != nil { print("iPhone 4 or iphone 4s") } else if deviceType.lowercaseString.rangeOfString("iphone 5") != nil { print("iPhone 5 or iphone 5s or iphone 5c") } else if deviceType.lowercaseString.rangeOfString("iphone 6") != nil { print("iPhone 6 Series") }
@interface DeviceInfo : NSObject + (NSString *)model; @end @implementation DeviceInfo + (NSString *)model { struct utsname systemInfo; uname(&systemInfo); return [NSString stringWithCString: systemInfo.machine encoding: NSUTF8StringEncoding]; } @end
public extension UIDevice { var modelName: String { let identifier = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"]! var systemInfo = utsname() uname(&systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") { identifier, element in guard let value = element.value as? Int8 , value != 0 else { return identifier } return identifier + String(UnicodeScalar(UInt8(value))) } switch identifier { case "iPod5,1": return "iPod Touch 5" case "iPod7,1": return "iPod Touch 6" case "iPhone3,1", "iPhone3,2", "iPhone3,3": return "iPhone 4" case "iPhone4,1": return "iPhone 4s" case "iPhone5,1", "iPhone5,2": return "iPhone 5" case "iPhone5,3", "iPhone5,4": return "iPhone 5c" case "iPhone6,1", "iPhone6,2": return "iPhone 5s" case "iPhone7,2": return "iPhone 6" case "iPhone7,1": return "iPhone 6 Plus" case "iPhone8,1": return "iPhone 6s" case "iPhone8,2": return "iPhone 6s Plus" case "iPhone9,1", "iPhone9,3": return "iPhone 7" case "iPhone9,2", "iPhone9,4": return "iPhone 7 Plus" case "iPhone8,4": return "iPhone SE" case "iPhone10,1", "iPhone10,4": return "iPhone 8" case "iPhone10,2", "iPhone10,5": return "iPhone 8 Plus" case "iPhone10,3", "iPhone10,6": return "iPhone X" case "iPhone11,2": return "iPhone XS" case "iPhone11,4", "iPhone11,6": return "iPhone XS Max" case "iPhone11,8": return "iPhone XR" case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2" case "iPad3,1", "iPad3,2", "iPad3,3": return "iPad 3" case "iPad3,4", "iPad3,5", "iPad3,6": return "iPad 4" case "iPad4,1", "iPad4,2", "iPad4,3": return "iPad Air" case "iPad5,3", "iPad5,4": return "iPad Air 2" case "iPad6,11", "iPad6,12": return "iPad 5" case "iPad7,5", "iPad7,6": return "iPad 6" case "iPad2,5", "iPad2,6", "iPad2,7": return "iPad Mini" case "iPad4,4", "iPad4,5", "iPad4,6": return "iPad Mini 2" case "iPad4,7", "iPad4,8", "iPad4,9": return "iPad Mini 3" case "iPad5,1", "iPad5,2": return "iPad Mini 4" case "iPad6,3", "iPad6,4": return "iPad Pro 9.7 Inch" case "iPad6,7", "iPad6,8": return "iPad Pro 12.9 Inch" case "iPad7,1", "iPad7,2": return "iPad Pro (12.9-inch) (2nd generation)" case "iPad7,3", "iPad7,4": return "iPad Pro (10.5-inch)" case "iPad8,1", "iPad8,2", "iPad8,3", "iPad8,4":return "iPad Pro (11-inch)" case "iPad8,5", "iPad8,6", "iPad8,7", "iPad8,8":return "iPad Pro (12.9-inch) (3rd generation)" case "AppleTV5,3": return "Apple TV" case "AppleTV6,2": return "Apple TV 4K" case "AudioAccessory1,1": return "HomePod" default: return identifier } } }
public extension UIDevice { var modelName: String { let identifier = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"]! var systemInfo = utsname() uname(&systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") { identifier, element in guard let value = element.value as? Int8 , value != 0 else { return identifier } return identifier + String(UnicodeScalar(UInt8(value))) } switch identifier { case "iPod5,1": return "iPod Touch 5" case "iPod7,1": return "iPod Touch 6" case "iPhone3,1", "iPhone3,2", "iPhone3,3": return "iPhone 4" case "iPhone4,1": return "iPhone 4s" case "iPhone5,1", "iPhone5,2": return "iPhone 5" case "iPhone5,3", "iPhone5,4": return "iPhone 5c" case "iPhone6,1", "iPhone6,2": return "iPhone 5s" case "iPhone7,2": return "iPhone 6" case "iPhone7,1": return "iPhone 6 Plus" case "iPhone8,1": return "iPhone 6s" case "iPhone8,2": return "iPhone 6s Plus" case "iPhone9,1", "iPhone9,3": return "iPhone 7" case "iPhone9,2", "iPhone9,4": return "iPhone 7 Plus" case "iPhone8,4": return "iPhone SE" case "iPhone10,1", "iPhone10,4": return "iPhone 8" case "iPhone10,2", "iPhone10,5": return "iPhone 8 Plus" case "iPhone10,3", "iPhone10,6": return "iPhone X" case "iPhone11,2": return "iPhone XS" case "iPhone11,4", "iPhone11,6": return "iPhone XS Max" case "iPhone11,8": return "iPhone XR" case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2" case "iPad3,1", "iPad3,2", "iPad3,3": return "iPad 3" case "iPad3,4", "iPad3,5", "iPad3,6": return "iPad 4" case "iPad4,1", "iPad4,2", "iPad4,3": return "iPad Air" case "iPad5,3", "iPad5,4": return "iPad Air 2" case "iPad6,11", "iPad6,12": return "iPad 5" case "iPad7,5", "iPad7,6": return "iPad 6" case "iPad2,5", "iPad2,6", "iPad2,7": return "iPad Mini" case "iPad4,4", "iPad4,5", "iPad4,6": return "iPad Mini 2" case "iPad4,7", "iPad4,8", "iPad4,9": return "iPad Mini 3" case "iPad5,1", "iPad5,2": return "iPad Mini 4" case "iPad6,3", "iPad6,4": return "iPad Pro 9.7 Inch" case "iPad6,7", "iPad6,8": return "iPad Pro 12.9 Inch" case "iPad7,1", "iPad7,2": return "iPad Pro (12.9-inch) (2nd generation)" case "iPad7,3", "iPad7,4": return "iPad Pro (10.5-inch)" case "iPad8,1", "iPad8,2", "iPad8,3", "iPad8,4":return "iPad Pro (11-inch)" case "iPad8,5", "iPad8,6", "iPad8,7", "iPad8,8":return "iPad Pro (12.9-inch) (3rd generation)" case "AppleTV5,3": return "Apple TV" case "AppleTV6,2": return "Apple TV 4K" case "AudioAccessory1,1": return "HomePod" default: return identifier } } }
import Device let deviceType = UIDevice.currentDevice().deviceType switch deviceType { case .IPhone6: print("Do stuff for iPhone6") case .IPadMini: print("Do stuff for iPad mini") default: print("Check other available cases of DeviceType") }
public enum Devices: String { case IPodTouch5 case IPodTouch6 case IPhone4 case IPhone4S case IPhone5 case IPhone5C case IPhone5S case IPhone6 case IPhone6Plus case IPhone6S case IPhone6SPlus case IPhone7 case IPhone7Plus case IPhoneSE case IPad2 case IPad3 case IPad4 case IPadAir case IPadAir2 case IPadMini case IPadMini2 case IPadMini3 case IPadMini4 case IPadPro case AppleTV case Simulator case Other } public extension UIDevice { public var modelName: Devices { var systemInfo = utsname() uname(&systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") { identifier, element in guard let value = element.value as? Int8 , value != 0 else { return identifier } return identifier + String(UnicodeScalar(UInt8(value))) } switch identifier { case "iPod5,1": return Devices.IPodTouch5 case "iPod7,1": return Devices.IPodTouch6 case "iPhone3,1", "iPhone3,2", "iPhone3,3": return Devices.IPhone4 case "iPhone4,1": return Devices.IPhone4S case "iPhone5,1", "iPhone5,2": return Devices.IPhone5 case "iPhone5,3", "iPhone5,4": return Devices.IPhone5C case "iPhone6,1", "iPhone6,2": return Devices.IPhone5S case "iPhone7,2": return Devices.IPhone6 case "iPhone7,1": return Devices.IPhone6Plus case "iPhone8,1": return Devices.IPhone6S case "iPhone8,2": return Devices.IPhone6SPlus case "iPhone9,1", "iPhone9,3": return Devices.IPhone7 case "iPhone9,2", "iPhone9,4": return Devices.IPhone7Plus case "iPhone8,4": return Devices.IPhoneSE case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return Devices.IPad2 case "iPad3,1", "iPad3,2", "iPad3,3": return Devices.IPad3 case "iPad3,4", "iPad3,5", "iPad3,6": return Devices.IPad4 case "iPad4,1", "iPad4,2", "iPad4,3": return Devices.IPadAir case "iPad5,3", "iPad5,4": return Devices.IPadAir2 case "iPad2,5", "iPad2,6", "iPad2,7": return Devices.IPadMini case "iPad4,4", "iPad4,5", "iPad4,6": return Devices.IPadMini2 case "iPad4,7", "iPad4,8", "iPad4,9": return Devices.IPadMini3 case "iPad5,1", "iPad5,2": return Devices.IPadMini4 case "iPad6,3", "iPad6,4", "iPad6,7", "iPad6,8":return Devices.IPadPro case "AppleTV5,3": return Devices.AppleTV case "i386", "x86_64": return Devices.Simulator default: return Devices.Other } } }
import UIKit public extension UIDevice { var modelName: String { let DEVICE_IS_SIMULATOR = true let DEVICE_IS_SIMULATOR = false var machineString = String() if DEVICE_IS_SIMULATOR == true { if let dir = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] { machineString = dir } } else { var systemInfo = utsname() uname(&systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) machineString = machineMirror.children.reduce("") { identifier, element in guard let value = element.value as? Int8 , value != 0 else { return identifier } return identifier + String(UnicodeScalar(UInt8(value))) } } switch machineString { case "iPod4,1": return "iPod Touch 4G" case "iPod5,1": return "iPod Touch 5G" case "iPod7,1": return "iPod Touch 6G" case "iPhone3,1", "iPhone3,2", "iPhone3,3": return "iPhone 4" case "iPhone4,1": return "iPhone 4s" case "iPhone5,1", "iPhone5,2": return "iPhone 5" case "iPhone5,3", "iPhone5,4": return "iPhone 5c" case "iPhone6,1", "iPhone6,2": return "iPhone 5s" case "iPhone7,2": return "iPhone 6" case "iPhone7,1": return "iPhone 6 Plus" case "iPhone8,1": return "iPhone 6s" case "iPhone8,2": return "iPhone 6s Plus" case "iPhone8,4": return "iPhone SE" case "iPhone9,1", "iPhone9,3": return "iPhone 7" case "iPhone9,2", "iPhone 9,4": return "iPhone 7 Plus" case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2" case "iPad3,1", "iPad3,2", "iPad3,3": return "iPad 3" case "iPad3,4", "iPad3,5", "iPad3,6": return "iPad 4" case "iPad4,1", "iPad4,2", "iPad4,3": return "iPad Air" case "iPad5,3", "iPad5,4": return "iPad Air 2" case "iPad2,5", "iPad2,6", "iPad2,7": return "iPad Mini" case "iPad4,4", "iPad4,5", "iPad4,6": return "iPad Mini 2" case "iPad4,7", "iPad4,8", "iPad4,9": return "iPad Mini 3" case "iPad5,1", "iPad5,2": return "iPad Mini 4" case "iPad6,3", "iPad6,4": return "iPad Pro (9.7 inch)" case "iPad6,7", "iPad6,8": return "iPad Pro (12.9 inch)" case "AppleTV5,3": return "Apple TV" default: return machineString } } }
var platform: String? { var systemInfo = utsname() uname(&systemInfo) return withUnsafeMutablePointer(&systemInfo.machine) { ptr in String.fromCString(UnsafePointer<CChar>(ptr)) } }
func deviceName() -> String { var systemInfo = utsname() uname(&systemInfo) let str = withUnsafePointer(to: &systemInfo.machine.0) { ptr in return String(cString: ptr) } return str }
import Foundation import UIKit public enum Model : String { case simulator = "simulator/sandbox", iPod1 = "iPod 1", iPod2 = "iPod 2", iPod3 = "iPod 3", iPod4 = "iPod 4", iPod5 = "iPod 5", iPad2 = "iPad 2", iPad3 = "iPad 3", iPad4 = "iPad 4", iPhone4 = "iPhone 4", iPhone4S = "iPhone 4S", iPhone5 = "iPhone 5", iPhone5S = "iPhone 5S", iPhone5C = "iPhone 5C", iPadMini1 = "iPad Mini 1", iPadMini2 = "iPad Mini 2", iPadMini3 = "iPad Mini 3", iPadAir1 = "iPad Air 1", iPadAir2 = "iPad Air 2", iPhone6 = "iPhone 6", iPhone6plus = "iPhone 6 Plus", iPhone6S = "iPhone 6S", iPhone6Splus = "iPhone 6S Plus", iPhoneSE = "iPhone SE", iPhone7 = "iPhone 7", iPhone7plus = "iPhone 7 Plus", unrecognized = "?unrecognized?" } public extension UIDevice { public var type: Model { var systemInfo = utsname() uname(&systemInfo) let modelCode = withUnsafePointer(to: &systemInfo.machine) { $0.withMemoryRebound(to: CChar.self, capacity: 1) { ptr in String.init(validatingUTF8: ptr) } } var modelMap : [ String : Model ] = [ "i386" : .simulator, "x86_64" : .simulator, "iPod1,1" : .iPod1, "iPod2,1" : .iPod2, "iPod3,1" : .iPod3, "iPod4,1" : .iPod4, "iPod5,1" : .iPod5, "iPad2,1" : .iPad2, "iPad2,2" : .iPad2, "iPad2,3" : .iPad2, "iPad2,4" : .iPad2, "iPad2,5" : .iPadMini1, "iPad2,6" : .iPadMini1, "iPad2,7" : .iPadMini1, "iPhone3,1" : .iPhone4, "iPhone3,2" : .iPhone4, "iPhone3,3" : .iPhone4, "iPhone4,1" : .iPhone4S, "iPhone5,1" : .iPhone5, "iPhone5,2" : .iPhone5, "iPhone5,3" : .iPhone5C, "iPhone5,4" : .iPhone5C, "iPad3,1" : .iPad3, "iPad3,2" : .iPad3, "iPad3,3" : .iPad3, "iPad3,4" : .iPad4, "iPad3,5" : .iPad4, "iPad3,6" : .iPad4, "iPhone6,1" : .iPhone5S, "iPhone6,2" : .iPhone5S, "iPad4,1" : .iPadAir1, "iPad4,2" : .iPadAir2, "iPad4,4" : .iPadMini2, "iPad4,5" : .iPadMini2, "iPad4,6" : .iPadMini2, "iPad4,7" : .iPadMini3, "iPad4,8" : .iPadMini3, "iPad4,9" : .iPadMini3, "iPhone7,1" : .iPhone6plus, "iPhone7,2" : .iPhone6, "iPhone8,1" : .iPhone6S, "iPhone8,2" : .iPhone6Splus, "iPhone8,4" : .iPhoneSE, "iPhone9,1" : .iPhone7, "iPhone9,2" : .iPhone7plus, "iPhone9,3" : .iPhone7, "iPhone9,4" : .iPhone7plus, ] guard let safeModelCode = modelCode else { return Model.unrecognized } guard let modelString = String.init(validatingUTF8: safeModelCode) else { return Model.unrecognized } guard let model = modelMap[modelString] else { return Model.unrecognized } return model } }
import UIKit class ViewController: UIViewController { let device = UIDevice.current override func viewDidLoad() { super.viewDidLoad() let model = device.model print(model) let modelName = device.modelName print(modelName) let deviceName = device.name print(deviceName) let systemName = device.systemName print(systemName) let systemVersion = device.systemVersion print(systemVersion) if let identifierForVendor = device.identifierForVendor { print(identifierForVendor) } } }
extension UIDevice { var modelName: String { var systemInfo = utsname() uname(&systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") { identifier, element in guard let value = element.value as? Int8, value != 0 else { return identifier } return identifier + String(UnicodeScalar(UInt8(value))) } switch identifier { case "iPod5,1": return "iPod Touch 5" case "iPod7,1": return "iPod Touch 6" case "iPhone3,1", "iPhone3,2", "iPhone3,3": return "iPhone 4" case "iPhone4,1": return "iPhone 4s" case "iPhone5,1", "iPhone5,2": return "iPhone 5" case "iPhone5,3", "iPhone5,4": return "iPhone 5c" case "iPhone6,1", "iPhone6,2": return "iPhone 5s" case "iPhone7,2": return "iPhone 6" case "iPhone7,1": return "iPhone 6 Plus" case "iPhone8,1": return "iPhone 6s" case "iPhone8,2": return "iPhone 6s Plus" case "iPhone9,1", "iPhone9,3": return "iPhone 7" case "iPhone9,2", "iPhone9,4": return "iPhone 7 Plus" case "iPhone8,4": return "iPhone SE" case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2" case "iPad3,1", "iPad3,2", "iPad3,3": return "iPad 3" case "iPad3,4", "iPad3,5", "iPad3,6": return "iPad 4" case "iPad4,1", "iPad4,2", "iPad4,3": return "iPad Air" case "iPad5,3", "iPad5,4": return "iPad Air 2" case "iPad6,11", "iPad6,12": return "iPad 5" case "iPad2,5", "iPad2,6", "iPad2,7": return "iPad Mini" case "iPad4,4", "iPad4,5", "iPad4,6": return "iPad Mini 2" case "iPad4,7", "iPad4,8", "iPad4,9": return "iPad Mini 3" case "iPad5,1", "iPad5,2": return "iPad Mini 4" case "iPad6,3", "iPad6,4": return "iPad Pro 9.7 Inch" case "iPad6,7", "iPad6,8": return "iPad Pro 12.9 Inch" case "iPad7,1", "iPad7,2": return "iPad Pro 12.9 Inch 2. Generation" case "iPad7,3", "iPad7,4": return "iPad Pro 10.5 Inch" case "AppleTV5,3": return "Apple TV" case "i386", "x86_64": return "Simulator" default: return identifier } } }
public func hardwareString() -> String { var name: [Int32] = [CTL_HW, HW_MACHINE] var size: Int = 2 sysctl(&name, 2, nil, &size, &name, 0) var hw_machine = [CChar](count: Int(size), repeatedValue: 0) sysctl(&name, 2, &hw_machine, &size, &name, 0) let hardware: String = String.fromCString(hw_machine)! return hardware }
func platform() -> String { var systemInfo = utsname() uname(&systemInfo) let size = Int(_SYS_NAMELEN) let s = withUnsafeMutablePointer(to: &systemInfo.machine) {p in p.withMemoryRebound(to: CChar.self, capacity: size, {p2 in return String(cString: p2) }) } return s }
public extension UIDevice { var modelName: String { var systemInfo = utsname() uname(&systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifier = machineMirror.children.reduce("") { identifier, element in guard let value = element.value as? Int8, value != 0 else { return identifier } return identifier + String(UnicodeScalar(UInt8(value))) } switch identifier { case "iPhone3,1", "iPhone3,2", "iPhone3,3", "iPhone4,1": return "iPhone 4" case "iPhone5,1", "iPhone5,2", "iPhone5,3", "iPhone5,4", "iPhone6,1", "iPhone6,2", "iPhone8,4": return "iPhone 5" case "iPhone7,2", "iPhone8,1", "iPhone9,1", "iPhone9,3", "iPhone10,1", "iPhone10,4": return "iPhone 6,7,8" case "iPhone7,1", "iPhone8,2", "iPhone9,2", "iPhone9,4", "iPhone10,2", "iPhone10,5": return "iPhone Plus" case "iPhone10,3", "iPhone10,6": return "iPhone X" case "i386", "x86_64": return "Simulator" default: return identifier } } }
switch UIDevice.current.modelName { case "iPhone 4": case "iPhone 5": case "iPhone 6,7,8": case "iPhone Plus": case "iPhone X": case "Simulator": default: }
func platform() -> String { var systemInfo = utsname() uname(&systemInfo) let modelCode = withUnsafeMutablePointer(&systemInfo.machine) { ptr in String.fromCString(UnsafePointer<CChar>(ptr)) } return String.fromCString(modelCode!)! }
extension UIDevice { public static let hardwareModel: String = { var path = [CTL_HW, HW_MACHINE] var n = 0 sysctl(&path, 2, nil, &n, nil, 0) var a: [UInt8] = .init(repeating: 0, count: n) sysctl(&path, 2, &a, &n, nil, 0) return .init(cString: a) }() } UIDevice.hardwareModel
func platformString() -> String { var devSpec: String switch platform() { case "iPhone1,2": devSpec = "iPhone 3G" case "iPhone2,1": devSpec = "iPhone 3GS" case "iPhone3,1": devSpec = "iPhone 4" case "iPhone3,3": devSpec = "Verizon iPhone 4" case "iPhone4,1": devSpec = "iPhone 4S" case "iPhone5,1": devSpec = "iPhone 5 (GSM)" case "iPhone5,2": devSpec = "iPhone 5 (GSM+CDMA)" case "iPhone5,3": devSpec = "iPhone 5c (GSM)" case "iPhone5,4": devSpec = "iPhone 5c (GSM+CDMA)" case "iPhone6,1": devSpec = "iPhone 5s (GSM)" case "iPhone6,2": devSpec = "iPhone 5s (GSM+CDMA)" case "iPhone7,1": devSpec = "iPhone 6 Plus" case "iPhone7,2": devSpec = "iPhone 6" case "iPod1,1": devSpec = "iPod Touch 1G" case "iPod2,1": devSpec = "iPod Touch 2G" case "iPod3,1": devSpec = "iPod Touch 3G" case "iPod4,1": devSpec = "iPod Touch 4G" case "iPod5,1": devSpec = "iPod Touch 5G" case "iPad1,1": devSpec = "iPad" case "iPad2,1": devSpec = "iPad 2 (WiFi)" case "iPad2,2": devSpec = "iPad 2 (GSM)" case "iPad2,3": devSpec = "iPad 2 (CDMA)" case "iPad2,4": devSpec = "iPad 2 (WiFi)" case "iPad2,5": devSpec = "iPad Mini (WiFi)" case "iPad2,6": devSpec = "iPad Mini (GSM)" case "iPad2,7": devSpec = "iPad Mini (GSM+CDMA)" case "iPad3,1": devSpec = "iPad 3 (WiFi)" case "iPad3,2": devSpec = "iPad 3 (GSM+CDMA)" case "iPad3,3": devSpec = "iPad 3 (GSM)" case "iPad3,4": devSpec = "iPad 4 (WiFi)" case "iPad3,5": devSpec = "iPad 4 (GSM)" case "iPad3,6": devSpec = "iPad 4 (GSM+CDMA)" case "iPad4,1": devSpec = "iPad Air (WiFi)" case "iPad4,2": devSpec = "iPad Air (Cellular)" case "iPad4,4": devSpec = "iPad mini 2G (WiFi)" case "iPad4,5": devSpec = "iPad mini 2G (Cellular)" case "iPad4,7": devSpec = "iPad mini 3 (WiFi)" case "iPad4,8": devSpec = "iPad mini 3 (Cellular)" case "iPad4,9": devSpec = "iPad mini 3 (China Model)" case "iPad5,3": devSpec = "iPad Air 2 (WiFi)" case "iPad5,4": devSpec = "iPad Air 2 (Cellular)" case "i386": devSpec = "Simulator" case "x86_64": devSpec = "Simulator" default: devSpec = "Unknown" } return devSpec }
let boolean: Bool = UIDevice.isDevice(ofType: .iPhoneX) let specificDevice: DeviceModel.Model = UIDevice.modelType let model: DeviceModel = UIDevice.model let modelName: String = UIDevice.model.name
public extension UIDevice { public static var modelCode: String { if let simulatorModelIdentifier = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] { return simulatorModelIdentifier } var systemInfo = utsname() uname(&systemInfo) return withUnsafeMutablePointer(to: &systemInfo.machine) { ptr in String(cString: UnsafeRawPointer(ptr).assumingMemoryBound(to: CChar.self)) } } public static var model: DeviceModel { var systemInfo = utsname() uname(&systemInfo) let modelCode = withUnsafeMutablePointer(to: &systemInfo.machine) { ptr in String(cString: UnsafeRawPointer(ptr).assumingMemoryBound(to: CChar.self)) } if modelCode == "i386" || modelCode == "x86_64" { if let simulatorModelCode = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"], let model = DeviceModel.Model(modelCode: simulatorModelCode) { return DeviceModel.simulator(model) } else if let simulatorModelCode = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] { return DeviceModel.unrecognizedSimulator(simulatorModelCode) } else { return DeviceModel.unrecognized(modelCode) } } else if let model = DeviceModel.Model(modelCode: modelCode) { return DeviceModel.real(model) } else { return DeviceModel.unrecognized(modelCode) } } public static var modelType: DeviceModel.Model? { return UIDevice.model.model } public static func isDevice(ofType model: DeviceModel.Model) -> Bool { return UIDevice.modelType == model } } public enum DeviceModel { case simulator(Model) case unrecognizedSimulator(String) case real(Model) case unrecognized(String) public enum Model: String { case iPod1 = "iPod 1" case iPod2 = "iPod 2" case iPod3 = "iPod 3" case iPod4 = "iPod 4" case iPod5 = "iPod 5" case iPad2 = "iPad 2" case iPad3 = "iPad 3" case iPad4 = "iPad 4" case iPhone4 = "iPhone 4" case iPhone4S = "iPhone 4S" case iPhone5 = "iPhone 5" case iPhone5S = "iPhone 5S" case iPhone5C = "iPhone 5C" case iPadMini1 = "iPad Mini 1" case iPadMini2 = "iPad Mini 2" case iPadMini3 = "iPad Mini 3" case iPadAir1 = "iPad Air 1" case iPadAir2 = "iPad Air 2" case iPadPro9_7 = "iPad Pro 9.7\"" case iPadPro9_7_cell = "iPad Pro 9.7\" cellular" case iPadPro10_5 = "iPad Pro 10.5\"" case iPadPro10_5_cell = "iPad Pro 10.5\" cellular" case iPadPro12_9 = "iPad Pro 12.9\"" case iPadPro12_9_cell = "iPad Pro 12.9\" cellular" case iPhone6 = "iPhone 6" case iPhone6plus = "iPhone 6 Plus" case iPhone6S = "iPhone 6S" case iPhone6Splus = "iPhone 6S Plus" case iPhoneSE = "iPhone SE" case iPhone7 = "iPhone 7" case iPhone7plus = "iPhone 7 Plus" case iPhone8 = "iPhone 8" case iPhone8plus = "iPhone 8 Plus" case iPhoneX = "iPhone X" init?(modelCode: String) { switch modelCode { case "iPod1,1": self = .iPod1 case "iPod2,1": self = .iPod2 case "iPod3,1": self = .iPod3 case "iPod4,1": self = .iPod4 case "iPod5,1": self = .iPod5 case "iPad2,1": self = .iPad2 case "iPad2,2": self = .iPad2 case "iPad2,3": self = .iPad2 case "iPad2,4": self = .iPad2 case "iPad2,5": self = .iPadMini1 case "iPad2,6": self = .iPadMini1 case "iPad2,7": self = .iPadMini1 case "iPhone3,1": self = .iPhone4 case "iPhone3,2": self = .iPhone4 case "iPhone3,3": self = .iPhone4 case "iPhone4,1": self = .iPhone4S case "iPhone5,1": self = .iPhone5 case "iPhone5,2": self = .iPhone5 case "iPhone5,3": self = .iPhone5C case "iPhone5,4": self = .iPhone5C case "iPad3,1": self = .iPad3 case "iPad3,2": self = .iPad3 case "iPad3,3": self = .iPad3 case "iPad3,4": self = .iPad4 case "iPad3,5": self = .iPad4 case "iPad3,6": self = .iPad4 case "iPhone6,1": self = .iPhone5S case "iPhone6,2": self = .iPhone5S case "iPad4,1": self = .iPadAir1 case "iPad4,2": self = .iPadAir2 case "iPad4,4": self = .iPadMini2 case "iPad4,5": self = .iPadMini2 case "iPad4,6": self = .iPadMini2 case "iPad4,7": self = .iPadMini3 case "iPad4,8": self = .iPadMini3 case "iPad4,9": self = .iPadMini3 case "iPad6,3": self = .iPadPro9_7 case "iPad6,11": self = .iPadPro9_7 case "iPad6,4": self = .iPadPro9_7_cell case "iPad6,12": self = .iPadPro9_7_cell case "iPad6,7": self = .iPadPro12_9 case "iPad6,8": self = .iPadPro12_9_cell case "iPad7,3": self = .iPadPro10_5 case "iPad7,4": self = .iPadPro10_5_cell case "iPhone7,1": self = .iPhone6plus case "iPhone7,2": self = .iPhone6 case "iPhone8,1": self = .iPhone6S case "iPhone8,2": self = .iPhone6Splus case "iPhone8,4": self = .iPhoneSE case "iPhone9,1": self = .iPhone7 case "iPhone9,2": self = .iPhone7plus case "iPhone9,3": self = .iPhone7 case "iPhone9,4": self = .iPhone7plus case "iPhone10,1": self = .iPhone8 case "iPhone10,2": self = .iPhone8plus case "iPhone10,3": self = .iPhoneX case "iPhone10,6": self = .iPhoneX default: return nil } } } public var name: String { switch self { case .simulator(let model): return "Simulator[\(model.rawValue)]" case .unrecognizedSimulator(let s): return "UnrecognizedSimulator[\(s)]" case .real(let model): return model.rawValue case .unrecognized(let s): return "Unrecognized[\(s)]" } } public var model: DeviceModel.Model? { switch self { case .simulator(let model): return model case .real(let model): return model case .unrecognizedSimulator(_): return nil case .unrecognized(_): return nil } } }
struct utsname systemInfo; uname(&systemInfo); NSString* deviceModel = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];
struct DeviceType { static let IS_IPHONE_4_OR_LESS = UIDevice.current.userInterfaceIdiom == .phone && Constants.SCREEN_MAX_LENGTH < 568 static let IS_IPHONE_5 = UIDevice.current.userInterfaceIdiom == .phone && Constants.SCREEN_MAX_LENGTH == 568 static let IS_IPHONE_6 = UIDevice.current.userInterfaceIdiom == .phone && Constants.SCREEN_MAX_LENGTH == 667 static let IS_IPHONE_6P = UIDevice.current.userInterfaceIdiom == .phone && Constants.SCREEN_MAX_LENGTH == 736 static let IS_IPAD = UIDevice.current.userInterfaceIdiom == .pad && Constants.SCREEN_MAX_LENGTH == 1024 }
func getDevice(){ if UIDevice().userInterfaceIdiom == .phone { switch UIScreen.main.nativeBounds.height { case 1136: print("iPhone 5 or 5S or 5C") case 1334: print("iPhone 6/6S/7/8") case 1920, 2208: print("iPhone 6+/6S+/7+/8+") case 2436: print("iPhone X, Xs") case 2688: print("iPhone Xs Max") case 1792: print("iPhone Xr") default: print("Default") } }else if UIDevice().userInterfaceIdiom == .pad{ switch UIScreen.main.nativeBounds.height { case 1366: print("iPadPro") case 2732: print("iPadPro 12") default: print("Default") } }else{ } }
anArray += ["Moar", "Strings"] anArray.append(contentsOf: ["Moar", "Strings"])
anArray.insert(contentsOf: ["Moar", "Strings"], at: 0)
var str1:String = "John" var str2:String = "Bob" var myArray = ["Steve", "Bill", "Linus", "Bret"] myArray.append(str1) myArray.append(str2)
myArray.insert(str1, atIndex:0) myArray.insert(str2, atIndex:0) myArray.insert(str1, at: 0) myArray.insert(str2, at: 0)
extension Array { } func += <V> (inout left: [V], right: V) { left.append(right) } func + <V>(left: Array<V>, right: V) -> Array<V> { var map = Array<V>() for (v) in left { map.append(v) } map.append(right) return map }
var list = [AnyObject]() list += "hello" list += ["hello", "world!"] var list2 = list + "anything"
extension Array{ mutating func appendAtBeginning(newItem : Element){ let copy = self self = [] self.append(newItem) self.appendContentsOf(copy) } }
let stringOne = "One" let strigTwo = "Two" let stringThree = "Three" var array:[String] = []
var array1 = [1,2,3,4,5] let array2 = [6,7,8,9] let array3 = array1+array2 print(array3) array1.append(contentsOf: array2) print(array1)
extension Array where Element: Equatable { mutating func appendUniqueObject(object: Generator.Element) { if contains(object) == false { append(object) } } }
@IBOutlet weak var viewName: UIView! @IBAction func viewTapped(_ sender: Any) { }
1. Clean Project using Product -> clean. 2. Run the Project.
extension NSObject : Equatable, Hashable { open var hashValue: Int { return hash } }
open class Utils: NSObject { open class func printHello() { print("Hello from utils") } }
dispatch_async(dispatch_get_main_queue(), { () -> Void in self.friendLabel.text = "You are following \(friendCount) accounts" })
DispatchQueue.global(qos: .userInitiated).async { DispatchQueue.main.async { self.friendLabel.text = "You are following \(friendCount) accounts" } }
dispatch_async(dispatch_get_main_queue(), ^{ _bannerForTableFooter = [[GADBannerView alloc] initWithAdSize:kGADAdSizeSmartBannerPortrait]; ... }
NSOperationQueue.mainQueue().addOperationWithBlock { }
DispatchQueue.global(qos: .userInitiated).async { DispatchQueue.main.async { self.myTableview.reloadData() } }
dispatch_async(dispatch_get_main_queue(), { () -> Void in self.tableView.reloadData() })
dispatch_async (dispatch_get_main_queue(), ^{ [self performSegueWithIdentifier:@"ViewController" sender:nil]; });
operationQueue.addOperation({ self.searchFavourites() })
func searchFavourites() { DispatchQueue.main.async { } }
operationQueue.addOperation({ DispatchQueue.main.async { self.searchFavourites() } })
let appVersion = Bundle.main.infoDictionary!["CFBundleShortVersionString"] as? String
let nsObject: AnyObject? = NSBundle.mainBundle().infoDictionary!["CFBundleShortVersionString"]
let nsObject: AnyObject? = NSBundle.mainBundle().infoDictionary["CFBundleShortVersionString"] let version = nsObject as String
if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String { self.labelVersion.text = version }
if let version = NSBundle.mainBundle().infoDictionary?["CFBundleShortVersionString"] as? String { self.labelVersion.text = version }
extension Bundle { var releaseVersionNumber: String? { return infoDictionary?["CFBundleShortVersionString"] as? String } var buildVersionNumber: String? { return infoDictionary?["CFBundleVersion"] as? String } } Bundle.main.releaseVersionNumber Bundle.main.buildVersionNumber
extension NSBundle { var releaseVersionNumber: String? { return self.infoDictionary?["CFBundleShortVersionString"] as? String } var buildVersionNumber: String? { return self.infoDictionary?["CFBundleVersion"] as? String } }
NSBundle.mainBundle().releaseVersionNumber NSBundle.mainBundle().buildVersionNumber NSBundle(URL: someURL)?.releaseVersionNumber NSBundle(URL: someURL)?.buildVersionNumber
extension NSBundle { class var applicationVersionNumber: String { if let version = NSBundle.mainBundle().infoDictionary?["CFBundleShortVersionString"]
class var applicationBuildNumber: String { if let build = NSBundle.mainBundle().infoDictionary?["CFBundleVersion"] as? String { return build } return "Build Number Not Available" } }
let versionNumber = NSBundle.applicationVersionNumber
extension Bundle { var releaseVersionNumber: String? { return infoDictionary?["CFBundleShortVersionString"] as? String } var buildVersionNumber: String? { return infoDictionary?["CFBundleVersion"] as? String } var releaseVersionNumberPretty: String { return "v\(releaseVersionNumber ?? "1.0.0")" } }
someLabel.text = Bundle.main.releaseVersionNumberPretty
class func getVersion() -> String { guard let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String else { return "no version info" } return version }
class func getVersion() -> String { if let version = NSBundle.mainBundle().infoDictionary?["CFBundleShortVersionString"] as? String { return version } return "no version info" }
let version = Bundle.main.infoDictionary!["CFBundleShortVersionString"]! let build = Bundle.main.infoDictionary!["CFBundleVersion"]!
extension Bundle { var appName: String { return infoDictionary?["CFBundleName"] as! String } var bundleId: String { return bundleIdentifier! } var versionNumber: String { return infoDictionary?["CFBundleShortVersionString"] as! String } var buildNumber: String { return infoDictionary?["CFBundleVersion"] as! String } }
versionLabel.text = "\(Bundle.main.appName) v \(Bundle.main.versionNumber) (Build \(Bundle.main.buildNumber))"
let versionNumberString = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as! String
let buildNumberString = Bundle.main.object(forInfoDictionaryKey: "CFBundleVersion") as! String
let gAppVersion = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") ?? "0" let gAppBuild = Bundle.main.object(forInfoDictionaryKey: "CFBundleVersion") ?? "0"
var displayName: String? var version: String? var build: String? override func viewDidLoad() { super.viewDidLoad() if let displayName = Bundle.main.localizedInfoDictionary?["CFBundleDisplayName"] as? String { self.displayName = displayName } if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String { self.version = version } if let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String { self.build = build } }
let version = NSBundle.mainBundle().infoDictionary!["CFBundleVersion"] as! String
let version = NSBundle.mainBundle().objectForInfoDictionaryKey("CFBundleShortVersionString") as? String
let version = NSBundle.mainBundle().infoDictionary!["CFBundleShortVersionString"] as! String let build = NSBundle.mainBundle().infoDictionary!["CFBundleVersion"] as! String
import Foundation public extension Bundle { public var shortVersion: String { if let result = infoDictionary?["CFBundleShortVersionString"] as? String { return result } else { assert(false) return "" } } public var buildVersion: String { if let result = infoDictionary?["CFBundleVersion"] as? String { return result } else { assert(false) return "" } } public var fullVersion: String { return "\(shortVersion)(\(buildVersion))" } }
if let versionNumberString = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String {
if let buildNumberString = Bundle.main.infoDictionary?["CFBundleVersion"] as? String {
func getAppVersion() -> String { return "\(Bundle.main.infoDictionary!["CFBundleShortVersionString"] ?? "")" }
let appVer: AnyObject? = NSBundle.mainBundle().infoDictionary!["CFBundleShortVersionString"]
extension UIApplication { static var appVersion: String { if let appVersion = NSBundle.mainBundle().objectForInfoDictionaryKey("CFBundleShortVersionString") { return "\(appVersion)" } else { return "" } } static var build: String { if let buildVersion = NSBundle.mainBundle().objectForInfoDictionaryKey(kCFBundleVersionKey as String) { return "\(buildVersion)" } else { return "" } } static var versionBuild: String { let version = UIApplication.appVersion let build = UIApplication.build var versionAndBuild = "v\(version)" if version != build { versionAndBuild = "v\(version)(\(build))" } return versionAndBuild } }
public var appVersionNumberString: String { get { return Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as! String } }
extension UIApplication { static var appVersion:String { if let appVersion = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") { return "\(appVersion)" } return "" } static var buildNumber:String { if let buildNum = Bundle.main.object(forInfoDictionaryKey: kCFBundleVersionKey as String) { return "\(buildNum)" } return "" } static var versionString:String { return "\(appVersion).\(buildNumber)" } }
let nsObject: AnyObject? = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as AnyObject
import SwifterSwift let buildNumber = SwifterSwift.appBuild let version = SwifterSwift.appVersion
import Foundation extension Bundle { var versionNumber: String? { return infoDictionary?["CFBundleShortVersionString"] as? String } var buildNumber: String? { return infoDictionary?["CFBundleVersion"] as? String } var bundleName: String? { return infoDictionary?["CFBundleName"] as? String } }
let nsObject: AnyObject? = NSBundle.mainBundle().infoDictionary!["CFBundleShortVersionString"] let version = nsObject as! String
class CTest { var str : String = "" } let letTest = CTest() letTest.str = "test" letTest.str = "another test" var varTest1 = CTest() var varTest2 = CTest() var varTest3 = CTest() varTest1.str = "var 1" varTest2.str = "var 2" varTest3 = varTest1 varTest1.str = "var 3" varTest3.str
let aPerson = Person(name:Foo, first:Bar) var aPerson = Person(name:Foo, first:Bar) eg: var aPersonA = Person(name:A, first: a) var aPersonB = Person(name:B, first: b) aPersonA = aPersonB aPersonA now refers to Person(name:B, first: b)
class Person { let firstName: String let lastName: String init(first: String, last: String) { firstName = first lastName = last super.init() } }
var variableString = "Apple" variableString += " and Banana" let constantString = "Apple" constantString += " and another Banana"
function variable() { var number = 5, number = 6; console.log(number); } variable();
function abc() { let number = 5, number = 6; console.log(number); } abc();
var str = "dog" str = "cat" let strAnimal = "dog" strAnimal = "cat"
import Foundation struct AAA { var inner_value1 = 111 mutating func mutatingMethod1() { inner_value1 = 222 } } let aaa1 = AAA() aaa1.mutatingMethod1() aaa1.inner_value1 = 444 var aaa2 = AAA() aaa2.mutatingMethod1() aaa2.inner_value1 = 444
let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0
println("The current value of friendlyWelcome is \(friendlyWelcome)")
let x = [1, 2, 3].shuffled() let fiveStrings = stride(from: 0, through: 100, by: 5).map(String.init).shuffled() var numbers = [1, 2, 3, 4] numbers.shuffle()
extension MutableCollection { mutating func shuffle() { let c = count guard c > 1 else { return } for (firstUnshuffled, unshuffledCount) in zip(indices, stride(from: c, to: 1, by: -1)) { let d: Int = numericCast(arc4random_uniform(numericCast(unshuffledCount))) let i = index(firstUnshuffled, offsetBy: d) swapAt(firstUnshuffled, i) } } } extension Sequence { func shuffled() -> [Element] { var result = Array(self) result.shuffle() return result } }
extension MutableCollection where Indices.Iterator.Element == Index { mutating func shuffle() { let c = count guard c > 1 else { return } for (firstUnshuffled , unshuffledCount) in zip(indices, stride(from: c, to: 1, by: -1)) { let d: Int = numericCast(arc4random_uniform(numericCast(unshuffledCount))) guard d != 0 else { continue } let i = index(firstUnshuffled, offsetBy: d) self.swapAt(firstUnshuffled, i) } } } extension Sequence { func shuffled() -> [Iterator.Element] { var result = Array(self) result.shuffle() return result } }
extension MutableCollectionType where Index == Int { mutating func shuffleInPlace() { if count < 2 { return } for i in startIndex ..< endIndex - 1 { let j = Int(arc4random_uniform(UInt32(count - i))) + i guard i != j else { continue } swap(&self[i], &self[j]) } } } extension CollectionType { func shuffle() -> [Generator.Element] { var list = Array(self) list.shuffleInPlace() return list } }
[1, 2, 3].shuffle() let fiveStrings = 0.stride(through: 100, by: 5).map(String.init).shuffle() var numbers = [1, 2, 3, 4] numbers.shuffleInPlace()
extension Array { mutating func shuffle() { if count < 2 { return } for i in 0..<(count - 1) { let j = Int(arc4random_uniform(UInt32(count - i))) + i swap(&self[i], &self[j]) } } } var numbers = [1, 2, 3, 4, 5, 6, 7, 8] numbers.shuffle()
extension Array { func shuffled() -> [T] { if count < 2 { return self } var list = self for i in 0..<(list.count - 1) { let j = Int(arc4random_uniform(UInt32(list.count - i))) + i swap(&list[i], &list[j]) } return list } } let numbers = [1, 2, 3, 4, 5, 6, 7, 8] let mixedup = numbers.shuffled()
let shuffled = GKRandomSource.sharedRandom().arrayByShufflingObjects(in: array)
let lcg = GKLinearCongruentialRandomSource(seed: mySeedValue) let shuffled = lcg.arrayByShufflingObjects(in: array)
let shuffled1 = (array as NSArray).shuffled(using: random) let shuffled2 = (array as NSArray).shuffled()
extension Array { func shuffled(using source: GKRandomSource) -> [Element] { return (self as NSArray).shuffled(using: source) as! [Element] } func shuffled() -> [Element] { return (self as NSArray).shuffled() as! [Element] } } let shuffled3 = array.shuffled(using: random) let shuffled4 = array.shuffled()
import GameplayKit func shuffle() { array = GKRandomSource.sharedRandom().arrayByShufflingObjectsInArray(array) }
extension MutableCollectionType where Self.Index == Int { mutating func shuffleInPlace() { let c = self.count for i in 0..<(c - 1) { let j = Int(arc4random_uniform(UInt32(c - i))) + i swap(&self[i], &self[j]) } } } extension MutableCollectionType where Self.Index == Int { func shuffle() -> Self { var r = self let c = self.count for i in 0..<(c - 1) { let j = Int(arc4random_uniform(UInt32(c - i))) + i swap(&r[i], &r[j]) } return r } }
extension Array { func shuffled() -> [Element] { var results = [Element]() var indexes = (0 ..< count).map { $0 } while indexes.count > 0 { let indexOfIndexes = Int(arc4random_uniform(UInt32(indexes.count))) let index = indexes[indexOfIndexes] results.append(self[index]) indexes.remove(at: indexOfIndexes) } return results } }
extension MutableCollection { mutating func shuffle() { for i in indices.dropLast() { let diff = distance(from: i, to: endIndex) let j = index(i, offsetBy: numericCast(arc4random_uniform(numericCast(diff)))) swapAt(i, j) } } } extension Collection { func shuffled() -> [Element] { var list = Array(self) list.shuffle() return list } }
func newShuffledArray(array:NSArray) -> NSArray { var mutableArray = array.mutableCopy() as! NSMutableArray var count = mutableArray.count if count>1 { for var i=count-1;i>0;--i{ mutableArray.exchangeObjectAtIndex(i, withObjectAtIndex: Int(arc4random_uniform(UInt32(i+1)))) } } return mutableArray as NSArray }
var cards = [Int]() let i = 4 func shuffleCards() { for _ in 0 ..< cards.count * i { let card = cards.remove(at: Int(arc4random_uniform(UInt32(cards.count)))) cards.insert(card, at: Int(arc4random_uniform(UInt32(cards.count)))) } }
func shuffleCards() { for _ in 0 ..< cards.count * i { let card = cards.remove(at: cards.count.arc4random) cards.insert(card, at: cards.count.arc4random) } } extension Int { var arc4random: Int { if self > 0 { print("Arc for random positiv self \(Int(arc4random_uniform(UInt32(self))))") return Int(arc4random_uniform(UInt32(self))) } else if self < 0 { print("Arc for random negotiv self \(-Int(arc4random_uniform(UInt32(abs(self)))))") return -Int(arc4random_uniform(UInt32(abs(self)))) } else { print("Arc for random equal 0") return 0 } } }
extension Collection { func shuffle() -> [Generator.Element] { var list = Array(self) list.shuffleInPlace() return list } } extension MutableCollection where Index == Int { mutating func shuffleInPlace() { if count < 2 { return } let countInt = count as! Int for i in 0..<countInt - 1 { let j = Int(arc4random_uniform(UInt32(countInt - i))) + i guard i != j else { continue } swap(&self[i], &self[j]) } } }
import GameplayKit let array: NSArray = ["Jock", "Ellie", "Sue Ellen", "Bobby", "JR", "Pamela"] override func viewDidLoad() { super.viewDidLoad() print(array.shuffled()) }
func suffleString() { let ShuffleArray = array.shuffled() suffleString.text = ShuffleArray.first as? String print(suffleString.text!) }
import Darwin let array = ["Jock", "Ellie", "Sue Ellen", "Bobby", "JR", "Pamela"] var indexArray = Array(array.indices) var index = indexArray.endIndex let indexIterator: AnyIterator<Int> = AnyIterator { guard let nextIndex = indexArray.index(index, offsetBy: -1, limitedBy: indexArray.startIndex) else { return nil } index = nextIndex let randomIndex = Int(arc4random_uniform(UInt32(index))) if randomIndex != index { swap(&indexArray[randomIndex], &indexArray[index]) } return indexArray[index] } let newArray = indexIterator.map { array[$0] } print(newArray)
import Darwin extension Array { func shuffled() -> Array<Element> { var indexArray = Array<Int>(indices) var index = indexArray.endIndex let indexIterator = AnyIterator<Int> { guard let nextIndex = indexArray.index(index, offsetBy: -1, limitedBy: indexArray.startIndex) else { return nil } index = nextIndex let randomIndex = Int(arc4random_uniform(UInt32(index))) if randomIndex != index { swap(&indexArray[randomIndex], &indexArray[index]) } return indexArray[index] } return indexIterator.map { self[$0] } } }
let array = ["Jock", "Ellie", "Sue Ellen", "Bobby", "JR", "Pamela"] let newArray = array.shuffled() print(newArray)
let emptyArray = [String]() let newEmptyArray = emptyArray.shuffled() print(newEmptyArray)
import Darwin extension Array { mutating func shuffle() { var indexArray = Array<Int>(indices) var index = indexArray.endIndex let indexIterator = AnyIterator<Int> { guard let nextIndex = indexArray.index(index, offsetBy: -1, limitedBy: indexArray.startIndex) else { return nil } index = nextIndex let randomIndex = Int(arc4random_uniform(UInt32(index))) if randomIndex != index { swap(&indexArray[randomIndex], &indexArray[index]) } return indexArray[index] } self = indexIterator.map { self[$0] } } }
var mutatingArray = ["Jock", "Ellie", "Sue Ellen", "Bobby", "JR", "Pamela"] mutatingArray.shuffle() print(mutatingArray)
func shuffle<T>(_ array:inout [T]){ var temp = [T]() for _ in array{ let random = arc4random_uniform(UInt32(array.count)) let elementTaken = array[Int(random)] temp.append(elementTaken) array.remove(at: Int(random)) } array = temp }
func shuffle<T>(_ array:inout [T]){ var length = array.count for _ in array{ let random = arc4random_uniform(UInt32(length)) if length-1 != Int(random){ swap(&array[length-1], &array[Int(random)]) } length -= 1 } }
extension Array{ mutating func shuffled(){ var temp = [Element]() for _ in self{ let random = arc4random_uniform(UInt32(self.count)) let elementTaken = self[Int(random)] temp.append(elementTaken) self.remove(at: Int(random)) } self = temp } }
extension Array{ mutating func shuffled(){ var length = self.count for _ in self{ let random = arc4random_uniform(UInt32(length)) if length-1 != Int(random){ self.swapAt(length-1, Int(random)) } length -= 1 } } }
var a = [1,2,3,4,5,6,7,8,9,10] for _ in 1...10{ self.shuffle(&a) /*For shuffled extension, a.shuffled()*/ print(a) }
for idx in 0..<arr.count { let rnd = Int(arc4random_uniform(UInt32(idx))) if rnd != idx { swap(&arr[idx], &arr[rnd]) } }
for idx in 0..<steps.count { swap(&steps[idx], &steps[Int(arc4random_uniform(UInt32(idx)))]) }
extension Array { /** Randomizes the order of an array mutating func shuffle() { for _ in 0..<10 { sort { (_,_) in arc4random() < arc4random() } } } } var organisms = [ "ant", "bacteria", "cougar", "dog", "elephant", "firefly", "goat", "hedgehog", "iguana"] print("Original: \(organisms)") organisms.shuffle() print("Shuffled: \(organisms)")
extension MutableCollection where Indices.Iterator.Element == Index { mutating func shuffle() { let c = count guard c > 1 else { return } for (firstUnshuffled , unshuffledCount) in zip(indices, stride(from: c, to: 1, by: -1)) { srand48(seedNumber) let number:Int = numericCast(unshuffledCount) let r = floor(drand48() * Double(number)) let d: IndexDistance = numericCast(Int(r)) guard d != 0 else { continue } let i = index(firstUnshuffled, offsetBy: d) swap(&self[firstUnshuffled], &self[i]) } } }
let shuffl = GKRandomSource.sharedRandom().arrayByShufflingObjects(in: arrayObject)
import GameplayKit extension Collection { func shuffled() -> [Iterator.Element] { let shuffledArray = (self as? NSArray)?.shuffled() let outputArray = shuffledArray as? [Iterator.Element] return outputArray ?? [] } mutating func shuffle() { if let selfShuffled = self.shuffled() as? Self { self = selfShuffled } } } var numbers = [1,2,3,4,5] numbers.shuffle() print(numbers) print([10, "hi", 9.0].shuffled())
extension Array { mutating func shuffled() { for _ in self { var (a, b) = (Int(arc4random_uniform(UInt32(self.count - 1))), Int(arc4random_uniform(UInt32(self.count - 1)))) if a == b { a = 0 b = self.count - 1 } swap(&self[a], &self[b]) } } } var array = [1,2,3,4,5,6,7,8,9,10] array.shuffled() print(array)
extension Array { var shuffled : Array { let totalCount : Int = self.count var shuffledArray : Array = [] var count : Int = totalCount var tempArray : Array = self for _ in 0..<totalCount { let randomIndex : Int = Int(arc4random_uniform(UInt32(count))) let randomElement : Element = tempArray.remove(at: randomIndex) shuffledArray.append(randomElement) count -= 1 } return shuffledArray } mutating func shuffle() { let totalCount : Int = self.count var shuffledArray : Array = [] var count : Int = totalCount var tempArray : Array = self for _ in 0..<totalCount { let randomIndex : Int = Int(arc4random_uniform(UInt32(count))) let randomElement : Element = tempArray.remove(at: randomIndex) shuffledArray.append(randomElement) count -= 1 } self = shuffledArray } }
let array = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] print(array.shuffled)
var array = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] array.shuffle() print(array)
func createShuffledSequenceOfNumbers(max:UInt)->[UInt] { var array:[UInt]! = [] var myArray:[UInt]! = [] for i in 1...max { myArray.append(i) } for i in 1...max { array.append(i) } var tempArray:[Int]! = [] for index in 0...(myArray.count - 1) { var isNotFinded:Bool = true while(isNotFinded){ let randomNumber = arc4random_uniform(UInt32(myArray.count)) let randomIndex = Int(randomNumber) if(!tempArray.contains(randomIndex)){ tempArray.append(randomIndex) array[randomIndex] = myArray[index] isNotFinded = false } } } return array }
var arrayItems = ["A1", "B2", "C3", "D4", "E5", "F6", "G7", "H8", "X9", "Y10", "Z11"] var shuffledArray = [String]() for i in 0..<arrayItems.count { let randomObject = Int(arc4random_uniform(UInt32(items.count))) shuffledArray.append(items[randomObject]) items.remove(at: randomObject) } print(shuffledArray)
extension Array { mutating func shuffle() { for _ in 0..<count { sort { (_,_) in arc4random() < arc4random() } } } }
import darwin var a = [1,2,3,4,5,6,7] func shuffle<ItemType>(item1: ItemType, item2: ItemType) -> Bool { return drand48() > 0.5 } sort(a, shuffle) println(a)
extension Bool : BooleanLiteralConvertible { static func convertFromBooleanLiteral(value: Bool) -> Bool } protocol BooleanLiteralConvertible { typealias BooleanLiteralType class func convertFromBooleanLiteral(value: BooleanLiteralType) -> Self }
class MyClass { class func myFunc() { println("myClass") } } class MyOtherClass: MyClass { override class func myFunc() { println("myOtherClass") } } var x: MyClass = MyOtherClass() x.dynamicType.myFunc() x = MyClass() x.dynamicType.myFunc()
class ClassA { class func func1() -> String { return "func1" } static func func2() -> String { return "func2" } /* same as above final class func func2() -> String { return "func2" } */ }
class ClassB : ClassA { override class func func1() -> String { return "func1 in ClassB" } override static func func2() -> String { return "func2 in ClassB" } }
class Dog { final func identity() -> String { return "Once a woofer, forever a woofer!" } class func talk() -> String { return "Woof woof!" } static func eat() -> String { return "Miam miam" } func sleep() -> String { return "Zzz" } } class Bulldog: Dog { func talk() -> String { return "I } func eat() -> String { return "I } override func sleep() -> String { return "I } } let dog = Dog() let bullDog = Bulldog() print(dog.identity()) print(bullDog.identity()) print(Dog.talk()) print(Bulldog.talk()) print(bullDog.talk()) print(Dog.eat()) print(Bulldog.eat()) print(bullDog.eat()) print(dog.sleep()) print(bullDog.sleep())
let str = "Hello, playground" let prefixRange = str.startIndex..<str.startIndex.advancedBy(5) let prefix = str.substringWithRange(prefixRange)
str.substring(to: String.Index) str.substring(from: String.Index) str.substring(with: Range<String.Index>)
let index = str.index(str.startIndex, offsetBy: 5) let mySubstring = str[..<index]
let index = str.index(str.startIndex, offsetBy: 5) let mySubstring = str.prefix(upTo: index)
let index = str.index(str.endIndex, offsetBy: -10) let mySubstring = str[index...]
let index = str.index(str.endIndex, offsetBy: -10) let mySubstring = str.suffix(from: index)
let start = str.index(str.startIndex, offsetBy: 7) let end = str.index(str.endIndex, offsetBy: -6) let range = start..<end let mySubstring = str[range]
extension String { func index(from: Int) -> Index { return self.index(startIndex, offsetBy: from) } func substring(from: Int) -> String { let fromIndex = index(from: from) return substring(from: fromIndex) } func substring(to: Int) -> String { let toIndex = index(from: to) return substring(to: toIndex) } func substring(with r: Range<Int>) -> String { let startIndex = index(from: r.lowerBound) let endIndex = index(from: r.upperBound) return substring(with: startIndex..<endIndex) } } let str = "Hello, playground" print(str.substring(from: 7)) print(str.substring(to: 5)) print(str.substring(with: 7..<11))
extension String { subscript(_ range: CountableRange<Int>) -> String { let idx1 = index(startIndex, offsetBy: max(0, range.lowerBound)) let idx2 = index(startIndex, offsetBy: min(self.count, range.upperBound)) return String(self[idx1..<idx2]) } }
var str = "Hello, playground" let start = str.index(str.startIndex, offsetBy: 7) let end = str.index(str.endIndex, offsetBy: -6) let result = str[start..<end]
extension String { subscript(_ range: NSRange) -> String { let start = self.index(self.startIndex, offsetBy: range.lowerBound) let end = self.index(self.startIndex, offsetBy: range.upperBound) let subString = self[start..<end] return String(subString) } }
let rString = cString.substringToIndex(2) let gString = (cString.substringFromIndex(2) as NSString).substringToIndex(2) let bString = (cString.substringFromIndex(4) as NSString).substringToIndex(2)
let rString = String(cString.characters.prefix(2)) cString = String(cString.characters.dropFirst(2)) let gString = String(cString.characters.prefix(2)) cString = String(cString.characters.dropFirst(2)) let bString = String(cString.characters.prefix(2))
func substring(string: String, fromIndex: Int, toIndex: Int) -> String? { if fromIndex < toIndex && toIndex < string.count { let startIndex = string.index(string.startIndex, offsetBy: fromIndex) let endIndex = string.index(string.startIndex, offsetBy: toIndex) return String(string[startIndex..<endIndex]) }else{ return nil } }
let s = "abcdefghi" let i = 2 print (s[s.index(s.startIndex, offsetBy:i)])
let f = 6 print (s[s.index(s.startIndex, offsetBy:i )..<s.index(s.startIndex, offsetBy:f+1 )])
print (s.substring (with:s.index(s.startIndex, offsetBy:i )..<s.index(s.startIndex, offsetBy:f+1 ) ) )
// // // import UIKit let Bigstring = "Why is it so hard to find substrings in Swift3" let searchStrs : Array<String>? = ["Why", "substrings", "Swift3"] FindSubString(inputStr: Bigstring, subStrings: searchStrs) func FindSubString(inputStr : String, subStrings: Array<String>?) -> Array<(String, Int, Int)> { var resultArray : Array<(String, Int, Int)> = [] for i: Int in 0...(subStrings?.count)!-1 { if inputStr.contains((subStrings?[i])!) { let range: Range<String.Index> = inputStr.range(of: subStrings![i])! let lPos = inputStr.distance(from: inputStr.startIndex, to: range.lowerBound) let uPos = inputStr.distance(from: inputStr.startIndex, to: range.upperBound) let element = ((subStrings?[i])! as String, lPos, uPos) resultArray.append(element) } } for words in resultArray { print(words) } return resultArray }
extension String { func substring(location: Int, length: Int) -> String? { guard characters.count >= location + length else { return nil } let start = index(startIndex, offsetBy: location) let end = index(startIndex, offsetBy: location + length) return substring(with: start..<end) } }
extension String { subscript(_ i: Int) -> String { let idx1 = index(startIndex, offsetBy: i) let idx2 = index(idx1, offsetBy: 1) return String(self[idx1..<idx2]) } } let s = "hello" s[0] s[1] s[2] s[3] s[4]
let greeting = "Hi there! It let endOfSentence = greeting.index(of: "!")! let firstSentence = greeting[...endOfSentence]
private typealias HowDoYouLikeThatElonMusk = String private extension HowDoYouLikeThatElonMusk { subscript(_ from: Character?, _ to: Character?, _ include: Bool) -> String? { if let _from: Character = from, let _to: Character = to { let dynamicSourceForEnd: String = (_from == _to ? String(self.reversed()) : self) guard let startOfSentence: String.Index = self.index(of: _from), let endOfSentence: String.Index = dynamicSourceForEnd.index(of: _to) else { return nil } let result: String = String(self[startOfSentence...endOfSentence]) if include == false { guard result.count > 2 else { return nil } return String(result[result.index(result.startIndex, offsetBy: 1)..<result.index(result.endIndex, offsetBy: -1)]) } return result } else if let _from: Character = from { guard let startOfSentence: String.Index = self.index(of: _from) else { return nil } let result: String = String(self[startOfSentence...]) if include == false { guard result.count > 1 else { return nil } return String(result[result.index(result.startIndex, offsetBy: 1)...]) } return result } else if let _to: Character = to { guard let endOfSentence: String.Index = self.index(of: _to) else { return nil } let result: String = String(self[...endOfSentence]) if include == false { guard result.count > 1 else { return nil } return String(result[..<result.index(result.endIndex, offsetBy: -1)]) } return result } return nil } }
let source = ">>>01234..56789<<<" var from = source["3", nil, true] var to = source[nil, "6", true] var fromTo = source["3", "6", true] let notFound = source["a", nil, true] from = source["3", nil, false] to = source[nil, "6", false] fromTo = source["3", "6", false] let outOfBounds = source[".", ".", false] let str = "Hello, playground" let hello = str[nil, ",", false]
extension String { func subString <R> (_ range: R) -> String? where R : RangeExpression, String.Index == R.Bound { return String(self[range]) } func index(at: Int) -> Index { return self.index(self.startIndex, offsetBy: at) } }
let item = "Fred looks funny" item.subString(item.index(at: 2)...)
extension UIColor { convenience init(red: Int, green: Int, blue: Int) { assert(red >= 0 && red <= 255, "Invalid red component") assert(green >= 0 && green <= 255, "Invalid green component") assert(blue >= 0 && blue <= 255, "Invalid blue component") self.init(red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: 1.0) } convenience init(rgb: Int) { self.init( red: (rgb >> 16) & 0xFF, green: (rgb >> 8) & 0xFF, blue: rgb & 0xFF ) } }
let color = UIColor(red: 0xFF, green: 0xFF, blue: 0xFF) let color2 = UIColor(rgb: 0xFFFFFF)
let semitransparentBlack = UIColor(rgb: 0x000000).withAlphaComponent(0.5)
convenience init(red: Int, green: Int, blue: Int, a: CGFloat = 1.0) { self.init( red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: a ) } convenience init(rgb: Int, a: CGFloat = 1.0) { self.init( red: (rgb >> 16) & 0xFF, green: (rgb >> 8) & 0xFF, blue: rgb & 0xFF, a: a ) }
let color = UIColor(red: 0xFF, green: 0xFF, blue: 0xFF, a: 0.5) let color2 = UIColor(rgb: 0xFFFFFF, a: 0.5)
convenience init(red: Int, green: Int, blue: Int, a: Int = 0xFF) { self.init( red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: CGFloat(a) / 255.0 ) } convenience init(argb: Int) { self.init( red: (argb >> 16) & 0xFF, green: (argb >> 8) & 0xFF, blue: argb & 0xFF, a: (argb >> 24) & 0xFF ) }
let color = UIColor(red: 0xFF, green: 0xFF, blue: 0xFF, a: 0xFF) let color2 = UIColor(argb: 0xFFFFFFFF)
func hexStringToUIColor (hex:String) -> UIColor { var cString:String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if (cString.hasPrefix(" cString.remove(at: cString.startIndex) } if ((cString.count) != 6) { return UIColor.gray } var rgbValue:UInt32 = 0 Scanner(string: cString).scanHexInt32(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }
func hexStringToUIColor (hex:String) -> UIColor { var cString:String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if (cString.hasPrefix(" cString.remove(at: cString.startIndex) } if ((cString.characters.count) != 6) { return UIColor.gray } var rgbValue:UInt32 = 0 Scanner(string: cString).scanHexInt32(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }
func hexStringToUIColor (hex:String) -> UIColor { var cString:String = hex.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet() as NSCharacterSet).uppercaseString if (cString.hasPrefix(" cString = cString.substringFromIndex(cString.startIndex.advancedBy(1)) } if ((cString.characters.count) != 6) { return UIColor.grayColor() } var rgbValue:UInt32 = 0 NSScanner(string: cString).scanHexInt(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }
extension UIColor { convenience init(hexString: String) { let hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) var int = UInt32() Scanner(string: hex).scanHexInt32(&int) let a, r, g, b: UInt32 switch hex.count { case 3: (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17) case 6: (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF) case 8: (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF) default: (a, r, g, b) = (255, 0, 0, 0) } self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255) } }
extension UIColor { convenience init(hexString: String) { let hex = hexString.stringByTrimmingCharactersInSet(NSCharacterSet.alphanumericCharacterSet().invertedSet) var int = UInt32() NSScanner(string: hex).scanHexInt(&int) let a, r, g, b: UInt32 switch hex.characters.count { case 3: (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17) case 6: (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF) case 8: (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF) default: (a, r, g, b) = (255, 0, 0, 0) } self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255) } }
extension UIColor { convenience init(hex: Int) { let components = ( R: CGFloat((hex >> 16) & 0xff) / 255, G: CGFloat((hex >> 08) & 0xff) / 255, B: CGFloat((hex >> 00) & 0xff) / 255 ) self.init(red: components.R, green: components.G, blue: components.B, alpha: 1) } }
extension CGColor { class func colorWithHex(hex: Int) -> CGColorRef { return UIColor(hex: hex).CGColor } }
func colorWithHexString (hex:String) -> UIColor { var cString:String = hex.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).uppercaseString if (cString.hasPrefix(" cString = (cString as NSString).substringFromIndex(1) } if (cString.characters.count != 6) { return UIColor.grayColor() } let rString = (cString as NSString).substringToIndex(2) let gString = ((cString as NSString).substringFromIndex(2) as NSString).substringToIndex(2) let bString = ((cString as NSString).substringFromIndex(4) as NSString).substringToIndex(2) var r:CUnsignedInt = 0, g:CUnsignedInt = 0, b:CUnsignedInt = 0; NSScanner(string: rString).scanHexInt(&r) NSScanner(string: gString).scanHexInt(&g) NSScanner(string: bString).scanHexInt(&b) return UIColor(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: CGFloat(1)) }
func colorWithHexString (hex:String) -> UIColor { var cString = hex.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines).uppercased() if (cString.hasPrefix(" cString = (cString as NSString).substring(from: 1) } if (cString.characters.count != 6) { return UIColor.gray } let rString = (cString as NSString).substring(to: 2) let gString = ((cString as NSString).substring(from: 2) as NSString).substring(to: 2) let bString = ((cString as NSString).substring(from: 4) as NSString).substring(to: 2) var r:CUnsignedInt = 0, g:CUnsignedInt = 0, b:CUnsignedInt = 0; Scanner(string: rString).scanHexInt32(&r) Scanner(string: gString).scanHexInt32(&g) Scanner(string: bString).scanHexInt32(&b) return UIColor(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: CGFloat(1)) }
extension UIColor { convenience init(hexFromString:String, alpha:CGFloat = 1.0) { var cString:String = hexFromString.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() var rgbValue:UInt32 = 10066329 if (cString.hasPrefix(" cString.remove(at: cString.startIndex) } if ((cString.count) == 6) { Scanner(string: cString).scanHexInt32(&rgbValue) } self.init( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: alpha ) } }
let myColor = UIColor(hexFromString: "4F9BF5") let myColor = UIColor(hexFromString: " let myColor = UIColor(hexFromString: "
let rgbValue = 0xFFEEDD let r = Float((rgbValue & 0xFF0000) >> 16)/255.0 let g = Float((rgbValue & 0xFF00) >> 8)/255.0 let b = Float((rgbValue & 0xFF))/255.0 self.backgroundColor = UIColor(red:r, green: g, blue: b, alpha: 1.0)
public extension UIColor { convenience init(hex: Int, alpha: Double = 1.0) { self.init(red: CGFloat((hex>>16)&0xFF)/255.0, green: CGFloat((hex>>8)&0xFF)/255.0, blue: CGFloat((hex)&0xFF)/255.0, alpha: CGFloat(255 * alpha) / 255) } convenience init(hexString: String, alpha: Double = 1.0) { let hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) var int = UInt32() Scanner(string: hex).scanHexInt32(&int) let r, g, b: UInt32 switch hex.count { case 3: (r, g, b) = ((int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17) case 6: (r, g, b) = (int >> 16, int >> 8 & 0xFF, int & 0xFF) default: (r, g, b) = (1, 1, 0) } self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(255 * alpha) / 255) } }
extension UIColor { convenience init(hex: Int, alpha: Double = 1.0) { self.init(red: CGFloat((hex>>16)&0xFF)/255.0, green:CGFloat((hex>>8)&0xFF)/255.0, blue: CGFloat((hex)&0xFF)/255.0, alpha: CGFloat(255 * alpha) / 255) } }
UIColor(hex: 0xffffff) UIColor(hex: 0xffffff, alpha: 0.5)
extension UIColor { class func uicolorFromHex(_ rgbValue:UInt32, alpha : CGFloat)->UIColor { let red = CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0 let green = CGFloat((rgbValue & 0xFF00) >> 8) / 255.0 let blue = CGFloat(rgbValue & 0xFF) / 255.0 return UIColor(red:red, green:green, blue:blue, alpha: alpha) } }
let carrot = UIColor.uicolorFromHex(0xe67e22, alpha: 1))
extension UIColor { convenience init(hexString: String) { let hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) var int = UInt32() Scanner(string: hex).scanHexInt32(&int) let a, r, g, b: UInt32 switch hex.characters.count { case 3: (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17) case 6: (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF) case 8: (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF) default: (a, r, g, b) = (255, 0, 0, 0) } self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255) } }
import UIKit extension UIColor { convenience init(hexString: String) { var cleanedHexString = hexString if hexString.hasPrefix(" cleanedHexString = String(hexString.characters.dropFirst()) } var rgbValue: UInt32 = 0 NSScanner(string: cleanedHexString).scanHexInt(&rgbValue) let red = CGFloat((rgbValue >> 16) & 0xff) / 255.0 let green = CGFloat((rgbValue >> 08) & 0xff) / 255.0 let blue = CGFloat((rgbValue >> 00) & 0xff) / 255.0 self.init(red: red, green: green, blue: blue, alpha: 1.0) } }
public static func hexStringToUIColor (hex:String) -> UIColor { var cString:String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if (cString.hasPrefix(" cString.remove(at: cString.startIndex) } if ((cString.characters.count) == 6) { var rgbValue:UInt32 = 0 Scanner(string: cString).scanHexInt32(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }else if ((cString.characters.count) == 8) { var rgbValue:UInt32 = 0 Scanner(string: cString).scanHexInt32(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0x00FF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x0000FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x000000FF) / 255.0, alpha: CGFloat((rgbValue & 0xFF000000) >> 24) / 255.0 ) }else{ return UIColor.gray } }
var color: UIColor = hexStringToUIColor(hex: " var colorWithTransparency: UIColor = hexStringToUIColor(hex: "
extension UIColor { convenience init(hex: String, alpha: CGFloat = 1.0) { var cString:String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if (cString.hasPrefix(" if ((cString.count) != 6) { self.init(hex: "ff0000") return } var rgbValue: UInt32 = 0 Scanner(string: cString).scanHexInt32(&rgbValue) self.init(red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: alpha) } }
UIColor(hex: " UIColor(hex: "ff0000") UIColor(hex: "ff0000", alpha: 0.5)
extension UIColor { convenience init(hexString: String, alpha: CGFloat = 1.0) { let hexString: String = hexString.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) let scanner = Scanner(string: hexString) if (hexString.hasPrefix(" scanner.scanLocation = 1 } var color: UInt32 = 0 scanner.scanHexInt32(&color) let mask = 0x000000FF let r = Int(color >> 16) & mask let g = Int(color >> 8) & mask let b = Int(color) & mask let red = CGFloat(r) / 255.0 let green = CGFloat(g) / 255.0 let blue = CGFloat(b) / 255.0 self.init(red:red, green:green, blue:blue, alpha:alpha) } func toHexString() -> String { var r:CGFloat = 0 var g:CGFloat = 0 var b:CGFloat = 0 var a:CGFloat = 0 getRed(&r, green: &g, blue: &b, alpha: &a) let rgb:Int = (Int)(r*255)<<16 | (Int)(g*255)<<8 | (Int)(b*255)<<0 return String(format:" } }
extension UIColor { convenience init(r: UInt8, g: UInt8, b: UInt8, alpha: CGFloat = 1.0) { let divider: CGFloat = 255.0 self.init(red: CGFloat(r)/divider, green: CGFloat(g)/divider, blue: CGFloat(b)/divider, alpha: alpha) } private convenience init(rgbWithoutValidation value: Int32, alpha: CGFloat = 1.0) { self.init( r: UInt8((value & 0xFF0000) >> 16), g: UInt8((value & 0x00FF00) >> 8), b: UInt8(value & 0x0000FF), alpha: alpha ) } convenience init?(rgb: Int32, alpha: CGFloat = 1.0) { if rgb > 0xFFFFFF || rgb < 0 { return nil } self.init(rgbWithoutValidation: rgb, alpha: alpha) } convenience init?(hex: String, alpha: CGFloat = 1.0) { var charSet = CharacterSet.whitespacesAndNewlines charSet.insert(" let _hex = hex.trimmingCharacters(in: charSet) guard _hex.range(of: "^[0-9A-Fa-f]{6}$", options: .regularExpression) != nil else { return nil } var rgb: UInt32 = 0 Scanner(string: _hex).scanHexInt32(&rgb) self.init(rgbWithoutValidation: Int32(rgb), alpha: alpha) } }
let alpha: CGFloat = 1.0 print(UIColor(rgb: 0x4F9BF5) ?? "nil") print(UIColor(rgb: 0x4F9BF5, alpha: alpha) ?? "nil") print(UIColor(rgb: 5217269) ?? "nil") print(UIColor(rgb: -5217269) ?? "nil") print(UIColor(rgb: 0xFFFFFF1) ?? "nil") print(UIColor(hex: "4F9BF5") ?? "nil") print(UIColor(hex: "4F9BF5", alpha: alpha) ?? "nil") print(UIColor(hex: " print(UIColor(hex: " print(UIColor(hex: " print(UIColor(hex: " print(UIColor(r: 79, g: 155, b: 245)) print(UIColor(r: 79, g: 155, b: 245, alpha: alpha))
NSColorParser.nsColor(" NSColorParser.nsColor("FF0",1) NSColorParser.nsColor("0xFF0000",1) NSColorParser.nsColor(" NSColorParser.nsColor("FF0000",1) NSColorParser.nsColor(0xFF0000,1) NSColorParser.nsColor(16711935,1)
import UIKit extension UIColor{ public convenience init?(colorCodeInHex: String, alpha: Float = 1.0){ var filterColorCode:String = colorCodeInHex.stringByReplacingOccurrencesOfString(" if filterColorCode.characters.count != 6 { self.init(red: 0.0, green: 0.0, blue: 0.0, alpha: CGFloat(alpha)) return } filterColorCode = filterColorCode.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).uppercaseString var range = Range(start: filterColorCode.startIndex.advancedBy(0), end: filterColorCode.startIndex.advancedBy(2)) let rString = filterColorCode.substringWithRange(range) range = Range(start: filterColorCode.startIndex.advancedBy(2), end: filterColorCode.startIndex.advancedBy(4)) let gString = filterColorCode.substringWithRange(range) range = Range(start: filterColorCode.startIndex.advancedBy(4), end: filterColorCode.startIndex.advancedBy(6)) let bString = filterColorCode.substringWithRange(range) var r:CUnsignedInt = 0, g:CUnsignedInt = 0, b:CUnsignedInt = 0; NSScanner(string: rString).scanHexInt(&r) NSScanner(string: gString).scanHexInt(&g) NSScanner(string: bString).scanHexInt(&b) self.init(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: CGFloat(alpha)) return } }
extension UIColor { convenience init(hexString:String) { let hexString:NSString = hexString.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()) let scanner = NSScanner(string: hexString as String) if (hexString.hasPrefix(" scanner.scanLocation = 1 } var color:UInt32 = 0 scanner.scanHexInt(&color) let mask = 0x000000FF let r = Int(color >> 16) & mask let g = Int(color >> 8) & mask let b = Int(color) & mask let red = CGFloat(r) / 255.0 let green = CGFloat(g) / 255.0 let blue = CGFloat(b) / 255.0 self.init(red:red, green:green, blue:blue, alpha:1) } func toHexString() -> String { var r:CGFloat = 0 var g:CGFloat = 0 var b:CGFloat = 0 var a:CGFloat = 0 getRed(&r, green: &g, blue: &b, alpha: &a) let rgb:Int = (Int)(r*255)<<16 | (Int)(g*255)<<8 | (Int)(b*255)<<0 return NSString(format:" } }
let countPartColor = UIColor(hexString: "E43038") let colorHexString = UIColor(red: 228, green: 48, blue: 56, alpha: 1.0).toHexString()
var viewColor:UIColor viewColor = UIColor() let colorInt:UInt colorInt = 0x000000 viewColor = UIColorFromRGB(colorInt) self.View.backgroundColor=viewColor func UIColorFromRGB(rgbValue: UInt) -> UIColor { return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }
extension String { var hexColor: UIColor { let hex = trimmingCharacters(in: CharacterSet.alphanumerics.inverted) var int = UInt32() Scanner(string: hex).scanHexInt32(&int) let a, r, g, b: UInt32 switch hex.characters.count { case 3: (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17) case 6: (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF) case 8: (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF) default: return .clear } return UIColor(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255) } }
extension UIColor { public convenience init?(rgbaString : String){ self.init(ciColor: CIColor(string: rgbaString)) } func toRGBAString()-> String { var r: CGFloat = 0 var g: CGFloat = 0 var b: CGFloat = 0 var a: CGFloat = 0 self.getRed(&r, green: &g, blue: &b, alpha: &a) return "\(r) \(g) \(b) \(a)" } public convenience init?(hexString: String) { let r, g, b, a: CGFloat if hexString.hasPrefix(" let start = hexString.index(hexString.startIndex, offsetBy: 1) let hexColor = hexString.substring(from: start) if hexColor.characters.count == 8 { let scanner = Scanner(string: hexColor) var hexNumber: UInt64 = 0 if scanner.scanHexInt64(&hexNumber) { r = CGFloat((hexNumber & 0xff000000) >> 24) / 255 g = CGFloat((hexNumber & 0x00ff0000) >> 16) / 255 b = CGFloat((hexNumber & 0x0000ff00) >> 8) / 255 a = CGFloat(hexNumber & 0x000000ff) / 255 self.init(red: r, green: g, blue: b, alpha: a) return } } } return nil } func toHexString() -> String { var r: CGFloat = 0 var g: CGFloat = 0 var b: CGFloat = 0 var a: CGFloat = 0 self.getRed(&r, green: &g, blue: &b, alpha: &a) return String( format: "%02X%02X%02X", Int(r * 0xff), Int(g * 0xff), Int(b * 0xff)) } }
import UIKit extension UIColor { convenience init(r: CGFloat, g: CGFloat, b: CGFloat) { self.init(red: r/255.0 ,green: g/255.0 ,blue: b/255.0 ,alpha:1.0) } convenience init(gray: CGFloat) { self.init(red: gray/255.0 ,green: gray/255.0 ,blue: gray/255.0 ,alpha:1.0) } class func randomCGColor() -> UIColor { return UIColor(r: CGFloat(arc4random_uniform(256)), g: CGFloat(arc4random_uniform(256)), b: CGFloat(arc4random_uniform(256))) } convenience init(hex:Int, alpha:CGFloat = 1.0) { self.init( red: CGFloat((hex & 0xFF0000) >> 16) / 255.0, green: CGFloat((hex & 0x00FF00) >> 8) / 255.0, blue: CGFloat((hex & 0x0000FF) >> 0) / 255.0, alpha: alpha ) } convenience init(hexString: String){ var red: CGFloat = 0.0 var green: CGFloat = 0.0 var blue: CGFloat = 0.0 var alpha: CGFloat = 1.0 let scanner = Scanner(string: hexString) var hexValue: CUnsignedLongLong = 0 if scanner.scanHexInt64(&hexValue) { switch (hexString.characters.count) { case 3: red = CGFloat((hexValue & 0xF00) >> 8) / 15.0 green = CGFloat((hexValue & 0x0F0) >> 4) / 15.0 blue = CGFloat(hexValue & 0x00F) / 15.0 case 4: red = CGFloat((hexValue & 0xF000) >> 12) / 15.0 green = CGFloat((hexValue & 0x0F00) >> 8) / 15.0 blue = CGFloat((hexValue & 0x00F0) >> 4) / 15.0 alpha = CGFloat(hexValue & 0x000F) / 15.0 case 6: red = CGFloat((hexValue & 0xFF0000) >> 16) / 255.0 green = CGFloat((hexValue & 0x00FF00) >> 8) / 255.0 blue = CGFloat(hexValue & 0x0000FF) / 255.0 case 8: alpha = CGFloat((hexValue & 0xFF000000) >> 24) / 255.0 red = CGFloat((hexValue & 0x00FF0000) >> 16) / 255.0 green = CGFloat((hexValue & 0x0000FF00) >> 8) / 255.0 blue = CGFloat(hexValue & 0x000000FF) / 255.0 default: log.info("Invalid RGB string, number of characters after } } else { log.error("Scan hex error") } self.init(red:red, green:green, blue:blue, alpha:alpha) }}
public enum ColourParsingError: Error { case invalidInput(String) } extension UIColor { public convenience init(hexString: String) throws { let hexString = hexString.replacingOccurrences(of: " let hex = hexString.trimmingCharacters(in:NSCharacterSet.alphanumerics.inverted) var int = UInt32() Scanner(string: hex).scanHexInt32(&int) let a, r, g, b: UInt32 switch hex.count { case 3: (r, g, b,a) = ((int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17,255) case 4: (r, g, b,a) = ((int >> 12) * 17, (int >> 8 & 0xF) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17) case 6: (r, g, b, a) = (int >> 16, int >> 8 & 0xFF, int & 0xFF,255) case 8: (r, g, b, a) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF) default: throw ColourParsingError.invalidInput("String is not a valid hex colour string: \(hexString)") } self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255) } }
extension UIColor { struct COLORS_HEX { static let Primary = 0xffffff static let PrimaryDark = 0x000000 static let Accent = 0xe89549 static let AccentDark = 0xe27b2a static let TextWhiteSemiTransparent = 0x80ffffff } convenience init(red: Int, green: Int, blue: Int, alphaH: Int) { assert(red >= 0 && red <= 255, "Invalid red component") assert(green >= 0 && green <= 255, "Invalid green component") assert(blue >= 0 && blue <= 255, "Invalid blue component") assert(alphaH >= 0 && alphaH <= 255, "Invalid alpha component") self.init(red: CGFloat(red) / 255.0, green: CGFloat(green) / 255.0, blue: CGFloat(blue) / 255.0, alpha: CGFloat(alphaH) / 255.0) } convenience init(netHex:Int) { self.init(red:(netHex >> 16) & 0xff, green:(netHex >> 8) & 0xff, blue:netHex & 0xff, alphaH: (netHex >> 24) & 0xff) } }
extension UIColor { static func colorFromHex(hexString: String, alpha: CGFloat = 1) -> UIColor { if hexString.characters.count < 7 { return UIColor.whiteColor() } let hexStringWithoutHash = hexString.substringFromIndex(hexString.startIndex.advancedBy(1)) let eachColor = [ hexStringWithoutHash.substringWithRange(hexStringWithoutHash.startIndex...hexStringWithoutHash.startIndex.advancedBy(1)), hexStringWithoutHash.substringWithRange(hexStringWithoutHash.startIndex.advancedBy(2)...hexStringWithoutHash.startIndex.advancedBy(3)), hexStringWithoutHash.substringWithRange(hexStringWithoutHash.startIndex.advancedBy(4)...hexStringWithoutHash.startIndex.advancedBy(5))] let hexForEach = eachColor.map {CGFloat(Int($0, radix: 16) ?? 0)} return UIColor(red: hexForEach[0] / 255, green: hexForEach[1] / 255, blue: hexForEach[2] / 255, alpha: alpha) } }
extension UIColor { convenience init(r: Int, g: Int, b: Int, a: Int = 255) { self.init(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: CGFloat(a) / 255.0) } convenience init(netHex:Int) { self.init(r:(netHex >> 16) & 0xff, g:(netHex >> 8) & 0xff, b:netHex & 0xff) } }
self.view.backgroundColor = UIColor(netHex: 0x27ae60)
override func viewDidLoad() { super.viewDidLoad() let color = UIColor(hexColor: "FF00A0") self.view.backgroundColor = color }
extension UIColor { convenience init(hexColor: String) { let scannHex = Scanner(string: hexColor) var rgbValue: UInt64 = 0 scannHex.scanLocation = 0 scannHex.scanHexInt64(&rgbValue) let r = (rgbValue & 0xff0000) >> 16 let g = (rgbValue & 0xff00) >> 8 let b = rgbValue & 0xff self.init( red: CGFloat(r) / 0xff, green: CGFloat(g) / 0xff, blue: CGFloat(b) / 0xff, alpha: 1 ) } }
extension UIColor { convenience init(hex: Int, alpha: Double = 1.0) { self.init(red: CGFloat((hex>>16)&0xFF)/255.0, green:CGFloat((hex>>8)&0xFF)/255.0, blue: CGFloat((hex)&0xFF)/255.0, alpha: CGFloat(255 * alpha) / 255) } }
let selectedColor = UIColor(hex: 0xFFFFFF) let selectedColor = UIColor(hex: 0xFFFFFF, alpha: 0.5)
@interface Foo : NSObject { @public int x; @protected: int y; @private: int z; } -(int) apple; -(int) pear; -(int) banana; @end
internal struct A { fileprivate static let x: Int } A.x
internal struct A { private static let x: Int internal static func doSomethingWithX() { x } } A.x
protocol MyClass { var publicProperty:Int {get set} func publicMethod(foo:String)->String } class MyClassImplementation : MyClass { var publicProperty:Int = 5 var privateProperty:Int = 8 func publicMethod(foo:String)->String{ return privateMethod(foo) } func privateMethod(foo:String)->String{ return "Hello \(foo)" } }
func breakingAndEntering(foo:MyClass)->String{ return foo.privateMethod() }
class A { private var aPrivate: String? fileprivate var aFileprivate: String? func accessMySelf() { self.aPrivate = "" self.aFileprivate = "" } } class B { func accessA() { let aObject = A() aObject.aPrivate = "I CANNOT set a value for it!" aObject.aFileprivate = "I CAN set a value for it!" } }
struct MyStruct { private let myMessage = "Hello World" } extension MyStruct { func printMyMessage() { print(myMessage) } }
protocol HuhThing { var huh: Int { get set } } func HuhMaker() -> HuhThing { class InnerHuh: HuhThing { var innerVal: Int = 0 var huh: Int { get { return mysteriousMath(innerVal) } set { innerVal = newValue / 2 } } func mysteriousMath(number: Int) -> Int { return number * 3 + 2 } } return InnerHuh() } HuhMaker() var h = HuhMaker() h.huh h.huh = 32 h.huh h.huh = 39 h.huh
public var somePublicVariable = 0 internal let someInternalConstant = 0 private func somePrivateFunction() {}
class Counter { let inc: () -> Int let dec: () -> Int init(start: Int) { var n = start inc = { ++n } dec = { --n } } } let c = Counter(start: 10) c.inc() c.inc() c.dec()
class foo { } private extension foo { func somePrivateHelperFunction01() { } func somePrivateHelperFunction02() { } func somePrivateHelperFunction03() { } }
class BaseClass { private func protectedMethod() { } } class SubClass : BaseClass { func publicMethod() { self.protectedMethod() } }
func test() { var a = BaseClass() a.protectedMethod() var b = SubClass() b.protectedMethod() } class SubClass2 : BaseClass { func publicMethod() { self.protectedMethod() }
var coffeeAmount: String = calculatedCoffee + attributedText
let myString = "Swift Attributed String" let myAttribute = [ NSAttributedString.Key.foregroundColor: UIColor.blue ] let myAttrString = NSAttributedString(string: myString, attributes: myAttribute) myLabel.attributedText = myAttrString
let myAttribute = [ NSAttributedString.Key.foregroundColor: UIColor.blue ]
let myAttribute = [ NSAttributedString.Key.backgroundColor: UIColor.yellow ]
let myAttribute = [ NSAttributedString.Key.font: UIFont(name: "Chalkduster", size: 18.0)! ]
let myAttribute = [ NSAttributedString.Key.underlineStyle: NSUnderlineStyle.single.rawValue ]
let myShadow = NSShadow() myShadow.shadowBlurRadius = 3 myShadow.shadowOffset = CGSize(width: 3, height: 3) myShadow.shadowColor = UIColor.gray let myAttribute = [ NSAttributedString.Key.shadow: myShadow ]
extension NSAttributedString.Key { static let myName = NSAttributedString.Key(rawValue: "myCustomAttributeKey") }
let singleAttribute1 = [ NSAttributedString.Key.foregroundColor: UIColor.green ] let singleAttribute2 = [ NSAttributedString.Key.backgroundColor: UIColor.yellow ] let singleAttribute3 = [ NSAttributedString.Key.underlineStyle: NSUnderlineStyle.double.rawValue ] let multipleAttributes: [NSAttributedString.Key : Any] = [ NSAttributedString.Key.foregroundColor: UIColor.green, NSAttributedString.Key.backgroundColor: UIColor.yellow, NSAttributedString.Key.underlineStyle: NSUnderlineStyle.double.rawValue ] let customAttribute = [ NSAttributedString.Key.myName: "Some value" ]
var multipleAttributes = [NSAttributedString.Key : Any]() multipleAttributes[NSAttributedString.Key.foregroundColor] = UIColor.green multipleAttributes[NSAttributedString.Key.backgroundColor] = UIColor.yellow multipleAttributes[NSAttributedString.Key.underlineStyle] = NSUnderlineStyle.double.rawValue
let attrString1 = NSAttributedString(string: "Hello.") let attrString2 = NSAttributedString(string: "Hello.", attributes: [NSAttributedString.Key.myName: "A value"]) let myAttributes1 = [ NSAttributedString.Key.foregroundColor: UIColor.green ] let attrString3 = NSAttributedString(string: "Hello.", attributes: myAttributes1)
let mutableAttrString1 = NSMutableAttributedString() let mutableAttrString2 = NSMutableAttributedString(string: "Hello.") let mutableAttrString3 = NSMutableAttributedString(string: "Hello.", attributes: [NSAttributedString.Key.myName: "A value"]) let myAttributes2 = [ NSAttributedString.Key.foregroundColor: UIColor.green ] let mutableAttrString4 = NSMutableAttributedString(string: "Hello.", attributes: myAttributes2)
let myAttribute = [ NSAttributedString.Key.font: UIFont(name: "Chalkduster", size: 18.0)! ] let myString = NSMutableAttributedString(string: "Swift", attributes: myAttribute )
let attrString = NSAttributedString(string: " Attributed Strings") myString.append(attrString)
var myRange = NSRange(location: 17, length: 7) myString.addAttribute(NSAttributedString.Key.foregroundColor, value: UIColor.red, range: myRange)
myRange = NSRange(location: 3, length: 17) let anotherAttribute = [ NSAttributedString.Key.backgroundColor: UIColor.yellow ] myString.addAttributes(anotherAttribute, range: myRange)
var attributedString = NSMutableAttributedString(string:"\(calculatedCoffee)")
var attrs = [NSFontAttributeName : UIFont.systemFontOfSize(19.0)!] var gString = NSMutableAttributedString(string:"g", attributes:attrs)
let attributes = [NSAttributedStringKey.font: UIFont(name: "HelveticaNeue-Bold", size: 17)!, NSAttributedStringKey.foregroundColor: UIColor.white]
let font:UIFont? = UIFont(name: "Arial", size: 12.0) let attrString = NSAttributedString( string: titleData, attributes: NSDictionary( object: font!, forKey: NSFontAttributeName))
let attriString = NSAttributedString(string:"attriString", attributes: [NSForegroundColorAttributeName: UIColor.lightGrayColor(), NSFontAttributeName: AttriFont])
let attriString = NSAttributedString(string:"attriString", attributes: [NSAttributedStringKey.foregroundColor: UIColor.lightGray, NSAttributedStringKey.font: AttriFont])
let attriString = NSAttributedString(string:"attriString", attributes: [NSAttributedString.Key.foregroundColor: UIColor.lightGray, NSAttributedString.Key.font: AttriFont])
let magenta = "Hello ".withAttributes([ .textColor(.magenta), .font(.systemFont(ofSize: 15.0)) ]) let cyan = "Sir ".withAttributes([ .textColor(.cyan), .font(.boldSystemFont(ofSize: 15.0)) ]) let green = "Lancelot".withAttributes([ .textColor(.green), .font(.italicSystemFont(ofSize: 15.0)) ]) let blue = "!".withAttributes([ .textColor(.blue), .font(.preferredFont(forTextStyle: UIFontTextStyle.headline)) ]) let finalString = magenta + cyan + green + blue
let attrString = NSAttributedString( string: "title-title-title", attributes: NSDictionary( object: NSFont(name: "Arial", size: 12.0), forKey: NSFontAttributeName))
let newsString: NSMutableAttributedString = NSMutableAttributedString(string: "Tap here to read the latest Football News.") newsString.addAttributes([NSUnderlineStyleAttributeName: NSUnderlineStyle.StyleDouble.rawValue], range: NSMakeRange(4, 4)) sampleLabel.attributedText = newsString.copy() as? NSAttributedString
let stringAttributes = [ NSFontAttributeName : UIFont(name: "Helvetica Neue", size: 17.0)!, NSUnderlineStyleAttributeName : 1, NSForegroundColorAttributeName : UIColor.orangeColor(), NSTextEffectAttributeName : NSTextEffectLetterpressStyle, NSStrokeWidthAttributeName : 2.0] let atrributedString = NSAttributedString(string: "Sample String: Attributed", attributes: stringAttributes) sampleLabel.attributedText = atrributedString
extension NSAttributedString { func replacing(placeholder:String, with valueString:String) -> NSAttributedString { if let range = self.string.range(of:placeholder) { let nsRange = NSRange(range,in:valueString) let mutableText = NSMutableAttributedString(attributedString: self) mutableText.replaceCharacters(in: nsRange, with: valueString) return mutableText as NSAttributedString } return self } }
label.attributedText = initalAttributedString.replacing(placeholder: "<price>", with: newValue)
let attributes = [ NSFontAttributeName : UIFont(name: "Helvetica Neue", size: 12.0)!, NSUnderlineStyleAttributeName : 1, NSForegroundColorAttributeName : UIColor.darkGrayColor(), NSTextEffectAttributeName : NSTextEffectLetterpressStyle, NSStrokeWidthAttributeName : 3.0] var atriString = NSAttributedString(string: "My Attributed String", attributes: attributes)
func decorateText(sub:String, des:String)->NSAttributedString{ let textAttributesOne = [NSAttributedStringKey.foregroundColor: UIColor.darkText, NSAttributedStringKey.font: UIFont(name: "PTSans-Bold", size: 17.0)!] let textAttributesTwo = [NSAttributedStringKey.foregroundColor: UIColor.black, NSAttributedStringKey.font: UIFont(name: "PTSans-Regular", size: 14.0)!] let textPartOne = NSMutableAttributedString(string: sub, attributes: textAttributesOne) let textPartTwo = NSMutableAttributedString(string: des, attributes: textAttributesTwo) let textCombination = NSMutableAttributedString() textCombination.append(textPartOne) textCombination.append(textPartTwo) return textCombination }
cell.lblFrom.attributedText = decorateText(sub: sender!, des: " - \(convertDateFormatShort3(myDateString: datetime!))")
let attributes = [NSAttributedStringKey.font : UIFont(name: CustomFont.NAME_REGULAR.rawValue, size: CustomFontSize.SURVEY_FORM_LABEL_SIZE.rawValue)!] let attributedString : NSAttributedString = NSAttributedString(string: messageString, attributes: attributes)
let labelFont = UIFont(name: "HelveticaNeue-Bold", size: 18) let attributes :[String:AnyObject] = [NSFontAttributeName : labelFont!] let attrString = NSAttributedString(string:"foo", attributes: attributes) myLabel.attributedText = attrString
extension UILabel{ func setSubTextColor(pSubString : String, pColor : UIColor){ let attributedString: NSMutableAttributedString = self.attributedText != nil ? NSMutableAttributedString(attributedString: self.attributedText!) : NSMutableAttributedString(string: self.text!); let range = attributedString.mutableString.range(of: pSubString, options:NSString.CompareOptions.caseInsensitive) if range.location != NSNotFound { attributedString.addAttribute(NSForegroundColorAttributeName, value: pColor, range: range); } self.attributedText = attributedString } }
let attributes = NSAttributedString(string: "String", attributes: [NSFontAttributeName : UIFont(name: "AvenirNext-Medium", size: 30)!, NSForegroundColorAttributeName : UIColor .white, NSTextEffectAttributeName : NSTextEffectLetterpressStyle])
let attrString = NSAttributedString ( string: "title-title-title", attributes: [NSAttributedStringKey.foregroundColor: UIColor.black])
let calculatedCoffee: Int = 768 let g = Style("g").font(.boldSystemFont(ofSize: 12)).foregroundColor(.red) let all = Style.font(.systemFont(ofSize: 12)) let str = "\(calculatedCoffee)<g>g</g>".style(tags: g) .styleAll(all) .attributedString label.attributedText = str
extension UILabel { func boldSubstring(_ substr: String) { guard substr.isEmpty == false, let text = attributedText, let range = text.string.range(of: substr, options: .caseInsensitive) else { return } let attr = NSMutableAttributedString(attributedString: text) let start = text.string.distance(from: text.string.startIndex, to: range.lowerBound) let length = text.string.distance(from: range.lowerBound, to: range.upperBound) attr.addAttributes([NSAttributedStringKey.font: UIFont.boldSystemFont(ofSize: self.font.pointSize)], range: NSMakeRange(start, length)) attributedText = attr } }
let attr = [NSForegroundColorAttributeName:self.configuration.settingsColor, NSFontAttributeName: self.configuration.settingsFont] let title = NSAttributedString(string: self.configuration.settingsTitle, attributes: attr)
extension String { struct StringAttribute { var fontName = "HelveticaNeue-Bold" var fontSize: CGFloat? var initialIndexOftheText = 0 var lastIndexOftheText: Int? var textColor: UIColor = .black var backGroundColor: UIColor = .clear var underLineStyle: NSUnderlineStyle = .styleNone var textShadow: TextShadow = TextShadow() var fontOfText: UIFont { if let font = UIFont(name: fontName, size: fontSize!) { return font } else { return UIFont(name: "HelveticaNeue-Bold", size: fontSize!)! } } struct TextShadow { var shadowBlurRadius = 0 var shadowOffsetSize = CGSize(width: 0, height: 0) var shadowColor: UIColor = .clear } } func getFontifiedText(partOfTheStringNeedToConvert partTexts: [StringAttribute]) -> NSAttributedString { let fontChangedtext = NSMutableAttributedString(string: self, attributes: [NSFontAttributeName: UIFont(name: "HelveticaNeue-Bold", size: (partTexts.first?.fontSize)!)!]) for eachPartText in partTexts { let lastIndex = eachPartText.lastIndexOftheText ?? self.count let attrs = [NSFontAttributeName : eachPartText.fontOfText, NSForegroundColorAttributeName: eachPartText.textColor, NSBackgroundColorAttributeName: eachPartText.backGroundColor, NSUnderlineStyleAttributeName: eachPartText.underLineStyle, NSShadowAttributeName: eachPartText.textShadow ] as [String : Any] let range = NSRange(location: eachPartText.initialIndexOftheText, length: lastIndex - eachPartText.initialIndexOftheText) fontChangedtext.addAttributes(attrs, range: range) } return fontChangedtext }
let someAttributedText = "Some Text".getFontifiedText(partOfTheStringNeedToConvert: <
dispatchOnMainThread:^{ NSLog(@"Block Executed On %s", dispatch_queue_get_label(dispatch_get_current_queue())); }];
DispatchQueue.global(qos: .background).async { print("This is run on the background queue") DispatchQueue.main.async { print("This is run on the main queue, after the previous code in outer block") } }
let qualityOfServiceClass = QOS_CLASS_BACKGROUND let backgroundQueue = dispatch_get_global_queue(qualityOfServiceClass, 0) dispatch_async(backgroundQueue, { print("This is run on the background queue") dispatch_async(dispatch_get_main_queue(), { () -> Void in print("This is run on the main queue, after the previous code in outer block") }) })
func backgroundThread(_ delay: Double = 0.0, background: (() -> Void)? = nil, completion: (() -> Void)? = nil) { dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)) { background?() let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) dispatch_after(popTime, dispatch_get_main_queue()) { completion?() } } }
extension DispatchQueue { static func background(delay: Double = 0.0, background: (()->Void)? = nil, completion: (() -> Void)? = nil) { DispatchQueue.global(qos: .background).async { background?() if let completion = completion { DispatchQueue.main.asyncAfter(deadline: .now() + delay, execute: { completion() }) } } } }
DispatchQueue.background(delay: 3.0, background: { }, completion: { }) DispatchQueue.background(background: { }, completion:{ }) DispatchQueue.background(delay: 3.0, completion:{ })
let backgroundQueue = DispatchQueue(label: "com.app.queue", qos: .background) backgroundQueue.async { print("Run on background thread") }
DispatchQueue.global(qos: .background).async { print("Run on background thread") DispatchQueue.main.async { print("We finished that.") label.text = "Done." } }
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), { })
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { dispatch_async(dispatch_get_main_queue()) { } }
func background(work: @escaping () -> ()) { DispatchQueue.global(qos: .userInitiated).async { work() } } func main(work: @escaping () -> ()) { DispatchQueue.main.async { work() } }
AsyncTask(backgroundTask: {(p:String)->Void in print(p); }).execute("Hello async");
let task2=AsyncTask(beforeTask: { print("pre execution"); },backgroundTask:{(p:Int)->String in if p>0{ return "positive" } return "negative"; }, afterTask: {(p:String) in print(p); }); task2.execute(1);
DispatchQueue.main DispatchQueue.global(qos: .userInitiated) DispatchQueue.global(qos: .userInteractive) DispatchQueue.global(qos: .background) DispatchQueue.global(qos: .default) DispatchQueue.global(qos: .utility) DispatchQueue.global(qos: .unspecified)
DispatchQueue.global(qos: .background).async { DispatchQueue.main.async { } } DispatchQueue.global(qos: .userInitiated).async { DispatchQueue.main.async { self.tableView.reloadData() } } DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) { } DispatchQueue.main.async(execute: { self.tableView.reloadData() })
func simpleQueues() { let queue = DispatchQueue(label: "com.appcoda.myqueue") queue.sync { for i in 0..<10 { print("üî¥", i) } } for i in 100..<110 { print("‚ìÇÔ∏è", i) } } func simpleQueues() { let queue = DispatchQueue(label: "com.appcoda.myqueue") queue.async { for i in 0..<10 { print("üî¥", i) } } for i in 100..<110 { print("‚ìÇÔ∏è", i) } }
func backgroundThread(delay: Double = 0.0, background: (() -> Void)? = nil, completion: (() -> Void)? = nil) { dispatch_async(dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0)) { background?() if let completion = completion{ let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))) dispatch_after(popTime, dispatch_get_main_queue()) { completion() } } } }
DispatchQueue.main.asyncAfter(deadline: DispatchTime.now()+1) { print("Hello World") } queue.sync { for i in 0..<10 { print("Hello", i) } } for i in 20..<30 { print("Hello", i) }
dispatch_async(dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0), { self.uploadImageString = uploadPhotoDataJPEG.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.EncodingEndLineWithCarriageReturn) })
import Foundation class myThread: Thread { override func main() { while(true) { print("Running in the Thread"); Thread.sleep(forTimeInterval: 4); } } } let t = myThread(); t.start(); while(true) { print("Main Loop"); sleep(5); }
- (BOOL) validEmail:(NSString*) emailString { if([emailString length]==0){ return NO; } NSString *regExPattern = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}"; NSRegularExpression *regEx = [[NSRegularExpression alloc] initWithPattern:regExPattern options:NSRegularExpressionCaseInsensitive error:nil]; NSUInteger regExMatches = [regEx numberOfMatchesInString:emailString options:0 range:NSMakeRange(0, [emailString length])]; NSLog(@"%i", regExMatches); if (regExMatches == 0) { return NO; } else { return YES; } }
func isValidEmail(testStr:String) -> Bool { let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" let emailTest = NSPredicate(format:"SELF MATCHES %@", emailRegEx) return emailTest.evaluate(with: testStr) }
func isValidEmail(testStr:String) -> Bool { let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" let emailTest = NSPredicate(format:"SELF MATCHES %@", emailRegEx) return emailTest.evaluate(with: testStr) }
class func isValidEmail(testStr:String) -> Bool { println("validate calendar: \(testStr)") let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" if let emailTest = NSPredicate(format:"SELF MATCHES %@", emailRegEx) { return emailTest.evaluateWithObject(testStr) } return false }
extension String { func isValidEmail() -> Bool { let regex = try! NSRegularExpression(pattern: "^[a-zA-Z0-9.! return regex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: count)) != nil } }
func validateEmail(enteredEmail:String) -> Bool { let emailFormat = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailFormat) return emailPredicate.evaluate(with: enteredEmail) }
func validateEmail(enteredEmail:String) -> Bool { let emailFormat = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailFormat) return emailPredicate.evaluateWithObject(enteredEmail) }
let email = "test@example.com" let rule = EmailValidationPredicate() let isValidEmail = rule.evaluate(with: email)
let regex = "(?:[\\p{L}0-9! "~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\" + "x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[\\p{L}0-9](?:[a-" + "z0-9-]*[\\p{L}0-9])?\\.)+[\\p{L}0-9](?:[\\p{L}0-9-]*[\\p{L}0-9])?|\\[(?:(?:25[0-5" + "]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-" + "9][0-9]?|[\\p{L}0-9-]*[\\p{L}0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21" + "-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"
extension String { var isEmail: Bool { let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,20}" let emailTest = NSPredicate(format:"SELF MATCHES %@", emailRegEx) return emailTest.evaluateWithObject(self) } }
let __firstpart = "[A-Z0-9a-z]([A-Z0-9a-z._%+-]{0,30}[A-Z0-9a-z])?" let __serverpart = "([A-Z0-9a-z]([A-Z0-9a-z-]{0,30}[A-Z0-9a-z])?\\.){1,5}" let __emailRegex = __firstpart + "@" + __serverpart + "[A-Za-z]{2,8}" let __emailPredicate = NSPredicate(format: "SELF MATCHES %@", __emailRegex) extension String { func isEmail() -> Bool { return __emailPredicate.evaluate(with: self) } } extension UITextField { func isEmail() -> Bool { return self.text.isEmail() } }
var isEmail: Bool { do { let regex = try NSRegularExpression(pattern: "^[a-zA-Z0-9.! return regex.firstMatchInString(self, options: NSMatchingOptions(rawValue: 0), range: NSMakeRange(0, self.characters.count)) != nil } catch { return false } }
extension String { public var isEmail: Bool { let dataDetector = try? NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue) let firstMatch = dataDetector?.firstMatch(in: self, options: NSRegularExpression.MatchingOptions.reportCompletion, range: NSRange(location: 0, length: length)) return (firstMatch?.range.location != NSNotFound && firstMatch?.url?.scheme == "mailto") } public var length: Int { return self.characters.count } }
if "hodor@gameofthrones.com".isEmail { print("Hold the Door") }
class func isValidEmail(testStr:String) -> Bool { let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" let range = testStr.rangeOfString(emailRegEx, options:.RegularExpressionSearch) let result = range != nil ? true : false return result }
extension String { func validateEmail() -> Bool { let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}" return NSPredicate(format: "SELF MATCHES %@", emailRegex).evaluate(with: self) } }
extension String { var isEmailValid: Bool { do { let regex = try NSRegularExpression(pattern: "(?:[a-z0-9! return regex.firstMatchInString(self, options: NSMatchingOptions(rawValue: 0), range: NSMakeRange(0, self.characters.count)) != nil } catch { return false } } }
extension String { func isValidEmail() -> Bool { do { let regex = try NSRegularExpression(pattern: "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}", options: .CaseInsensitive) return regex.firstMatchInString(self, options: NSMatchingOptions(rawValue: 0), range: NSMakeRange(0, self.characters.count)) != nil } catch { return false } } }
let emailTrial = Trial.Email let trial = emailTrial.trial() if(trial(evidence: "test@test.com")) { }
extension NSRegularExpression { convenience init(pattern: String) { try! self.init(pattern: pattern, options: []) } } extension String { var isValidEmail: Bool { return isMatching(expression: NSRegularExpression(pattern: "^[A-Z0-9a-z\\._%+-]+@([A-Za-z0-9-]+\\.)+[A-Za-z]{2,4}$")) } private func isMatching(expression: NSRegularExpression) -> Bool { return expression.numberOfMatches(in: self, range: NSRange(location: 0, length: characters.count)) > 0 } }
let regex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}" func validate(email: String) -> Bool { let matches = email.rangeOfString(regex, options: .RegularExpressionSearch) if let _ = matches { return true } return false }
import Foundation extension String { private static let __firstpart = "[A-Z0-9a-z]([A-Z0-9a-z._%+-]{0,30}[A-Z0-9a-z])?" private static let __serverpart = "([A-Z0-9a-z]([A-Z0-9a-z-]{0,30}[A-Z0-9a-z])?\\.){1,5}" private static let __emailRegex = __firstpart + "@" + __serverpart + "[A-Za-z]{2,6}" public var isEmail: Bool { let predicate = NSPredicate(format: "SELF MATCHES %@", type(of:self).__emailRegex) return predicate.evaluate(with: self) } }
let str = "mail@domain.com" if str.isEmail { print("\(str) is a valid e-mail address") } else { print("\(str) is not a valid e-mail address") }
extension String { func isValidEmail() -> Bool { let regex = try? NSRegularExpression(pattern: "^(((([a-zA-Z]|\\d|[! return regex?.firstMatch(in: self, options: [], range: NSMakeRange(0, self.count)) != nil } func isValidName() -> Bool{ let regex = try? NSRegularExpression(pattern: "^[\\p{L}\\.]{2,30}(?: [\\p{L}\\.]{2,30}){0,2}$", options: .caseInsensitive) return regex?.firstMatch(in: self, options: [], range: NSMakeRange(0, self.count)) != nil } }
extension String { func isEmail() -> Bool { let emailRegEx = "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$" return NSPredicate(format:"SELF MATCHES %@", emailRegEx).evaluateWithObject(self) } }
extension String { func isValidEmail() -> Bool { let regex = try? NSRegularExpression(pattern: "^[a-zA-Z0-9.! return regex?.firstMatchInString(self, options: [], range: NSMakeRange(0, self.characters.count)) != nil } }
func matchesDataDetector(type: NSTextCheckingResult.CheckingType, scheme: String? = nil) -> Bool { let dataDetector = try? NSDataDetector(types: type.rawValue) guard let firstMatch = dataDetector?.firstMatch(in: self, options: NSRegularExpression.MatchingOptions.reportCompletion, range: NSRange(location: 0, length: length)) else { return false } return firstMatch.range.location != NSNotFound && firstMatch.range.location == 0 && firstMatch.range.length == length && (type != .link || scheme == nil || firstMatch.url?.scheme == scheme) } var isEmail: Bool { return matchesDataDetector(type: .link, scheme: "mailto") } var isPhoneNumber: Bool { return matchesDataDetector(type: .phoneNumber) } var length: Int { return self.characters.count }
extension String { func isValidEmail() -> Bool { let regex = try? NSRegularExpression(pattern: "^[a-zA-Z0-9.! return regex?.firstMatch(in: self, options: [], range: NSMakeRange(0, self.characters.count)) != nil } }
func isEmail() -> Bool { let patternNormal = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}" let regex = try? RegularExpression(pattern: patternNormal, options: .caseInsensitive) let regex = try? NSRegularExpression(pattern: patternNormal, options: .caseInsensitive) return regex?.firstMatch(in: self, options: [], range: NSMakeRange(0, self.characters.count)) != nil
extension String { func isValidEmail() -> Bool { let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" return NSPredicate(format: "SELF MATCHES %@", emailRegex).evaluate(with: self) } }
func validateEmail(enterEmail:String) -> Bool{ let emailFormat = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" let emailPredicate = NSPredicate(format:"SELF MATCHES %@",emailFormat) return emailPredicate.evaluate(with:enterEmail) }
extension String { func validateAsEmail() -> Bool { let emailRegEx = "(?:[a-zA-Z0-9! "~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\" + "x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-" + "z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5" + "]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-" + "9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21" + "-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])" let emailTest = NSPredicate(format:"SELF MATCHES[c] %@", emailRegEx) return emailTest.evaluate(with: self) } }
extension String { func isValidateEmail() -> Bool { let emailFormat = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}" let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailFormat) return emailPredicate.evaluate(with: self) } }
if enteredText.contains("..") || enteredText.contains("@@") || enteredText.hasPrefix(".") || enteredText.hasSuffix(".con"){ return false } let emailFormat = "[A-Z0-9a-z.! let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailFormat) return emailPredicate.evaluate(with: enteredText)
func isValidEmail(email: String) -> Bool { let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}" var valid = NSPredicate(format: "SELF MATCHES %@", emailRegex).evaluate(with: email) if valid { valid = !email.contains("Invalid email id") } return valid } let emailTrimmedString = emailTF.text?.trimmingCharacters(in: .whitespaces) if isValidEmail(email: emailTrimmedString!) == false { SharedClass.sharedInstance.alert(view: self, title: "", message: "Please enter valid email") }
import UIKit class SharedClass: NSObject { static let sharedInstance = SharedClass() func isValidEmail(email: String) -> Bool { let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}" var valid = NSPredicate(format: "SELF MATCHES %@", emailRegex).evaluate(with: email) if valid { valid = !email.contains("Invalid email id") } return valid } private override init() { } }
if SharedClass.sharedInstance. isValidEmail(email: emailTrimmedString!) == false { SharedClass.sharedInstance.alert(view: self, title: "", message: "Please enter correct email") } else { }
var usernameValidator : FieldValidator? var emailValidator : FieldValidator? @IBOutlet weak var usernameTf: UITextField! @IBOutlet weak var emailTf: UITextField! @IBAction func didTapButton(sender: AnyObject) { formValidator?.submit() } override func viewDidLoad() { super.viewDidLoad() formValidator = FormValidator() usernameValidator = FieldValidator(inputValue: { () -> AnyObject in return self.usernameTf.text }, rules: [Required(validationError: ValidationError(hint: "Field is required"))], nextValidator: nil, form: formValidator!) usernameValidator!.delegate = self emailValidator = FieldValidator(inputValue: { () -> AnyObject in return self.emailTf.text }, rules: [Email(validationError: ValidationError(hint: "Proper email format"))], nextValidator: usernameValidator!, form: formValidator!) emailValidator!.delegate = self formValidator?.initialValidator = emailValidator! formValidator?.delegate = self } func didEvaluateField(field: FieldValidator, errors: Array<String>, form: FormValidator) { switch field { case usernameValidator!: println("Username field error") break; case emailValidator!: println("Username field error") default: println("Field error") } } func didPassFormValidation(form: FormValidation) { println(__FUNCTION__) } func didFailFormValidation(form: FormValidation) { println(__FUNCTION__) }
if emailTextField.text.isEmailValid() { print("email is valid") }else{ print("wrong email address") }
extension Optional where Wrapped == String { func isEmailValid() -> Bool{ guard let email = self else { return false } let emailPattern = "[A-Za-z-0-9.-_]+@[A-Za-z0-9]+\\.[A-Za-z]{2,3}" do{ let regex = try NSRegularExpression(pattern: emailPattern, options: .caseInsensitive) let foundPatters = regex.numberOfMatches(in: email, options: .anchored, range: NSRange(location: 0, length: email.count)) if foundPatters > 0 { return true } }catch{ } return false } }
<key>CFBundleDevelopmentRegion</key> <string>en</string> <key>CFBundleExecutable</key> - <string>iOS</string> + <string>${EXECUTABLE_NAME}</string> <key>CFBundleIdentifier</key> - <string>com.apple.dt.playground.iOS-18300-13</string> + <string>com.myCompany.${PRODUCT_NAME:rfc1034identifier}</string> <key>CFBundleInfoDictionaryVersion</key> <string>6.0</string> <key>CFBundleName</key> - <string>iOS</string> + <string>${PRODUCT_NAME}</string> <key>CFBundlePackageType</key> - <string>AAPL</string> + <string>APPL</string> <key>CFBundleShortVersionString</key> <string>1.0</string> - <key>CFBundleSupportedPlatforms</key> - <array> - <string>iPhoneSimulator</string> - </array> + <key>CFBundleSignature</key> + <string>????</string> <key>CFBundleVersion</key> <string>1</string> - <key>DTPlatformName</key> - <string>iphonesimulator</string> - <key>DTSDKName</key> - <string>iphonesimulator8.0</string> - <key>LSBackgroundOnly</key> - <true/> <key>LSRequiresIPhoneOS</key> <true/> + <key>UIMainStoryboardFile</key> + <string>Main</string> <key>UIRequiredDeviceCapabilities</key> <array> <string>armv7</string> </array> + <key>UISupportedInterfaceOrientations</key> + <array> + <string>UIInterfaceOrientationPortrait</string> + <string>UIInterfaceOrientationLandscapeLeft</string> + <string>UIInterfaceOrientationLandscapeRight</string> + </array> </dict> </plist>
class Person : Equatable { let ssn: Int let name: String init(ssn: Int, name: String) { self.ssn = ssn self.name = name } static func == (lhs: Person, rhs: Person) -> Bool { return lhs.ssn == rhs.ssn } }
let person1 = Person(ssn: 5, name: "Bob") let person2 = Person(ssn: 5, name: "Bob") if person1 == person2 { print("the two instances are equal!") }
if person1 === person2 { } else { print("the two instances are not identical!") }
if person3 === person1 { print("the two instances are identical!") }
let a = NSObject() let b = NSObject() let c = a a == b a == c
class MyClass: Equatable { let myProperty: String init(s: String) { myProperty = s } } func ==(lhs: MyClass, rhs: MyClass) -> Bool { return lhs.myProperty == rhs.myProperty } let myClass1 = MyClass(s: "Hello") let myClass2 = MyClass(s: "Hello") myClass1 == myClass2 myClass1 != myClass2 myClass1 === myClass2 myClass1 !== myClass2
infix operator <==> { precedence 130 } func <==> (lhs: CGPoint, rhs: CGPoint) -> Bool { return lhs.x == rhs.x && lhs.y == rhs.y } let point1 = CGPoint(x: 1.0, y: 1.0) let point2 = CGPoint(x: 1.0, y: 1.0) point1 <==> point2
class Person {} let person = Person() let person2 = person let person3 = Person() person === person2 person === person3
1 === 2 1 === 1 let one = 1 1 === one 1 === (one as AnyObject)
var st = "123" var ns = (st as NSString) st == ns st === ns ns === (st as NSString) ns === (st as AnyObject) (st as NSString) === (st as NSString) NSString(string:st) === NSString(string:st) var st1 = NSString(string:st) var st2 = st1 st1 === st2 var st3 = (st as NSString) st1 === st3 (st as AnyObject) === (st as AnyObject)
1===2 (1 as AnyObject) === (2 as AnyObject) let two = 2 (2 as AnyObject) === (two as AnyObject) (2 as AnyObject) === (2 as AnyObject)
var st = "123" var ns = (st as NSString) st == ns st == ns as String st === ns ns === (st as NSString) ns === (st as AnyObject) (st as NSString) === (st as NSString) NSString(string:st) === NSString(string:st) var st1 = NSString(string:st) var st2 = st1 st1 === st2 var st3 = (st as NSString) st1 === st3 (st as AnyObject) === (st as AnyObject)
class SomeClass { var a: Int; init(_ a: Int) { self.a = a } } var someClass1 = SomeClass(4) var someClass2 = SomeClass(4) someClass1 === someClass2 someClass2 = someClass1 someClass1 === someClass2
func compareTwoAny(a: Any, b: Any) -> Bool { return ObjectIdentifier(a as AnyObject) == ObjectIdentifier(b as AnyObject) }
func test_inputTextFields_Delegate_is_ViewControllerUnderTest() { let storyboard = UIStoryboard(name: "Main", bundle: nil) viewControllerUnderTest = storyboard.instantiateViewController(withIdentifier: "StoryBoardIdentifier") as! ViewControllerUnderTest let _ = viewControllerUnderTest.view XCTAssertTrue(viewControllerUnderTest.inputTextField.delegate === viewControllerUnderTest) }
class ViewControllerUnderTest: UIViewController, UITextFieldDelegate { @IBOutlet weak var inputTextField: UITextField! override func viewDidLoad() { super.viewDidLoad() inputTextField.delegate = self } }
var str = ‚ÄúHello, playground‚Äù func test(str: String) -> String { return str.substringWithRange( ) } test (str)
return str.substringWithRange(aRange: Range<String.Index>)
let r:Range<String.Index> = Range<String.Index>(start: 0, end: 2) return str.substringWithRange(r)
var str = "Hello, playground" str.substringWithRange(Range<String.Index>(start: str.startIndex, end: str.endIndex))
var str = "Hello, playground" str.substringWithRange(Range<String.Index>(start: str.startIndex.advancedBy(2), end: str.endIndex.advancedBy(-1)))
let myNSString = str as NSString myNSString.substringWithRange(NSRange(location: 0, length: 3))
let str = "My String" let subStr = str[str.startIndex.advancedBy(3)...str.startIndex.advancedBy(7)]
let startIndex = str.index(str.startIndex, offsetBy: 3) let endIndex = str.index(str.startIndex, offsetBy: 7) str[startIndex...endIndex] str.substring(to: startIndex) str.substring(from: startIndex)
String(str[..<startIndex]) String(str[startIndex...]) String(str[startIndex...endIndex])
import Foundation extension String { subscript (r: Range<Int>) -> String { get { let startIndex = self.startIndex.advancedBy(r.startIndex) let endIndex = startIndex.advancedBy(r.endIndex - r.startIndex) return self[Range(start: startIndex, end: endIndex)] } } } var s = "Hello, playground" println(s[0...5]) println(s[0..<5])
func +<T: ForwardIndex>(var index: T, var count: Int) -> T { for (; count > 0; --count) { index = index.succ() } return index } s.substringWithRange(s.startIndex+2 .. s.startIndex+5)
extension String { func substring(from: Int?, to: Int?) -> String { if let start = from { guard start < self.count else { return "" } } if let end = to { guard end >= 0 else { return "" } } if let start = from, let end = to { guard end - start >= 0 else { return "" } } let startIndex: String.Index if let start = from, start >= 0 { startIndex = self.index(self.startIndex, offsetBy: start) } else { startIndex = self.startIndex } let endIndex: String.Index if let end = to, end >= 0, end < self.count { endIndex = self.index(self.startIndex, offsetBy: end + 1) } else { endIndex = self.endIndex } return String(self[startIndex ..< endIndex]) } func substring(from: Int) -> String { return self.substring(from: from, to: nil) } func substring(to: Int) -> String { return self.substring(from: nil, to: to) } func substring(from: Int?, length: Int) -> String { guard length > 0 else { return "" } let end: Int if let start = from, start > 0 { end = start + length - 1 } else { end = length - 1 } return self.substring(from: from, to: end) } func substring(length: Int, to: Int?) -> String { guard let end = to, end > 0, length > 0 else { return "" } let start: Int if let end = to, end - length > 0 { start = end - length + 1 } else { start = 0 } return self.substring(from: start, to: to) } }
let myString = "full text container" let substring = myString[myString.startIndex..<myString.startIndex.advancedBy(3)]
let substring = myString[myString.startIndex..<myString.index(myString.startIndex, offsetBy: 3)]
let substring = myString[myString.startIndex..<myString.index(myString.startIndex, offsetBy: 3)] let newString = String(substring)
let myString = "[ABCDEFGHI]" let startIndex = advance(myString.startIndex, 1) let endIndex = advance(myString.endIndex, -1) let range = startIndex..<endIndex let myNewString = myString.substringWithRange( range )
let mySubString = myString.substringFromIndex(startIndex)
let name = "Joris Kluivers" let start = name.startIndex let end = find(name, " ") if end { let firstName = name[start..end!] } else { }
stateName = stateName.stringByReplacingOccurrencesOfString(" ", withString:"")
let x = (str as NSString).substringWithRange(NSMakeRange(0, 3))
import UIKit var name = "How do you use String.substringWithRange?" let range = name.startIndex.advancedBy(0)..<name.startIndex.advancedBy(10) name.substringWithRange(range)
extension String { subscript (r: Range<Int>) -> String { get { let subStart = advance(self.startIndex, r.startIndex, self.endIndex) let subEnd = advance(subStart, r.endIndex - r.startIndex, self.endIndex) return self.substringWithRange(Range(start: subStart, end: subEnd)) } } func substring(from: Int) -> String { let end = countElements(self) return self[from..<end] } func substring(from: Int, length: Int) -> String { let end = from + length return self[from..<end] } } let mobyDick = "Call me Ishmael." println(mobyDick[8...14]) let dogString = "This üê∂ println(dogString[5..<6]) println(dogString[5...5]) println(dogString.substring(5)) println(dogString.substring(5, length: 1))
let harderString = "1:1Ô∏è‚É£" for character in harderString { println(character) }
extension String { func substringWithRange(start: Int, end: Int) -> String { if (start < 0 || start > self.characters.count) { print("start index \(start) out of bounds") return "" } else if end < 0 || end > self.characters.count { print("end index \(end) out of bounds") return "" } let range = Range(start: self.startIndex.advancedBy(start), end: self.startIndex.advancedBy(end)) return self.substringWithRange(range) } func substringWithRange(start: Int, location: Int) -> String { if (start < 0 || start > self.characters.count) { print("start index \(start) out of bounds") return "" } else if location < 0 || start + location > self.characters.count { print("end index \(start + location) out of bounds") return "" } let range = Range(start: self.startIndex.advancedBy(start), end: self.startIndex.advancedBy(start + location)) return self.substringWithRange(range) } }
extension String { func substring(start: Int, end: Int) -> String { if (start < 0 || start > self.characters.count) { print("start index \(start) out of bounds") return "" } else if end < 0 || end > self.characters.count { print("end index \(end) out of bounds") return "" } let startIndex = self.characters.index(self.startIndex, offsetBy: start) let endIndex = self.characters.index(self.startIndex, offsetBy: end) let range = startIndex..<endIndex return self.substring(with: range) } func substring(start: Int, location: Int) -> String { if (start < 0 || start > self.characters.count) { print("start index \(start) out of bounds") return "" } else if location < 0 || start + location > self.characters.count { print("end index \(start + location) out of bounds") return "" } let startIndex = self.characters.index(self.startIndex, offsetBy: start) let endIndex = self.characters.index(self.startIndex, offsetBy: start + location) let range = startIndex..<endIndex return self.substring(with: range) } }
let str = "Hello, playground" let substring1 = str.substringWithRange(0, end: 5) let substring2 = str.substringWithRange(7, location: 10)
var str = "Swift is very powerful language!" print(str) str = str.substringToIndex(str.startIndex.advancedBy(5)) print(str)
var str = "Swift is very powerful language!" print(str) str = str.substringFromIndex(str.startIndex.advancedBy(6)).substringToIndex(str.startIndex.advancedBy(2)) print(str)
extension String { func subString(start: Int, end: Int) -> String { let startIndex = self.index(self.startIndex, offsetBy: start) let endIndex = self.index(startIndex, offsetBy: end) let finalString = self.substring(from: startIndex) return finalString.substring(to: endIndex) } }
var chuck: String = "Hello Chuck Norris" chuck[6...11]
extension String { /** Subscript to allow for quick String substrings ["Hello"][0...1] = "He" */ subscript (r: Range<Int>) -> String { get { let start = self.startIndex.advancedBy(r.startIndex) let end = self.startIndex.advancedBy(r.endIndex - 1) return self.substringWithRange(start..<end) } } }
var str:String = "Hello, playground" let range = Range(start:advance(str.startIndex,1), end: advance(str.startIndex,8))
var str:String = "Hello, playground" var str2:String = "I let range = Range(start:advance(str.startIndex,1), end: advance(str.startIndex,49))
extension String { subscript (r: Range<Int>) -> String? { get { let stringCount = self.characters.count as Int if (stringCount < r.endIndex) || (stringCount < r.startIndex){ return nil } let startIndex = self.startIndex.advancedBy(r.startIndex) let endIndex = self.startIndex.advancedBy(r.endIndex - r.startIndex) return self[Range(start: startIndex, end: endIndex)] } } }
var str2 = "Hello, World" var str3 = str2[0...5] var str4 = str2[0..<5] var str5 = str2[0..<15]
let name = "Duke James Thomas" let range: Range<String.Index> = name.range(of:"James")! let lastrange: Range<String.Index> = img.range(of:"Thomas")! var middlename = name[range.lowerBound..<lstrange.lowerBound] print (middlename)
subscript (r: Range<Int>) -> String { get { let startIndex = advance(self.startIndex, r.startIndex) let endIndex = advance(self.startIndex, r.endIndex - 1) return self[Range(start: startIndex, end: endIndex)] } } func subString(startIndex: Int, length: Int) -> String { var start = advance(self.startIndex, startIndex) var end = advance(self.startIndex, startIndex + length) return self.substringWithRange(Range<String.Index>(start: start, end: end)) }
var str = "Hello, playground" let startIndex = advance(str.startIndex, 1) let endIndex = advance(startIndex, 8) let range = startIndex..<endIndex let substr = str[range]
extension String { var subString: (Int?) -> (Int?) -> String { return { (start) in { (end) in let startIndex = start ?? 0 < 0 ? self.endIndex.advancedBy(start!) : self.startIndex.advancedBy(start ?? 0) let endIndex = end ?? self.characters.count < 0 ? self.endIndex.advancedBy(end!) : self.startIndex.advancedBy(end ?? self.characters.count) return startIndex > endIndex ? "" : self.substringWithRange(startIndex ..< endIndex) } } } } let dog = "Dog‚Äºüê∂" print(dog.subString(nil)(-1))
public extension String { struct Substring { var start: Int? var string: String public subscript(end: Int?) -> String { let startIndex = start ?? 0 < 0 ? string.endIndex.advancedBy(start!) : string.startIndex.advancedBy(start ?? 0) let endIndex = end ?? string.characters.count < 0 ? string.endIndex.advancedBy(end!) : string.startIndex.advancedBy(end ?? string.characters.count) return startIndex > endIndex ? "" : string.substringWithRange(startIndex ..< endIndex) } } public subscript(start: Int?) -> Substring { return Substring(start: start, string: self) } } let dog = "Dog‚Äºüê∂" print(dog[nil][-1])
let range = fullString.startIndex..<fullString.startIndex.advancedBy(15) let substring = fullString.substringWithRange(range)
let str = "https: var arrSaprate = str.componentsSeparatedByString("v=") let start = arrSaprate[1] let rangeOfID = Range(start: start.startIndex,end:start.startIndex.advancedBy(11)) let substring = start[rangeOfID] print(substring)
let startIndex = text.startIndex var range = startIndex.advancedBy(1) ..< text.endIndex.advancedBy(-4) let substring = text.substringWithRange(range)
var helloworld = "Hello World!" var world = helloworld.bridgeToObjectiveC().substringWithRange(NSMakeRange(6,6)) println("\(world)")
var string = "hello" var sub = string.substringFrom(3) println(sub)
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let newString = (textField.text as NSString).stringByReplacingCharactersInRange(range, withString: string) println("Got new string: ", newString) }
extension String { func substringToIndex(index: Int) -> String { return self[startIndex...startIndex.advancedBy(min(index, characters.count - 1))] } }
extension String { subscript(range: CountableClosedRange<Int>) -> String { return enumerated().filter{$0.offset >= range.first! && $0.offset < range.last!} .reduce(""){$0 + String($1.element)} } }
override func touchesMoved(touches: NSSet!, withEvent event: UIEvent!)
protocol SomeProtocol { ... } class A :NSObject, SomeProtocol { ... } class B : A { ... }
protocol SomeProtocol { ... } class A : NSObject, SomeProtocol { ... } class B : A, SomeProtocol { ... }
var tabBarController : UITabBarController = self.window?.rootViewController as UITabBarController;
var tabBarController : UITabBarController = self.window!.rootViewController as UITabBarController
class var Settings:Settings { get { return classVarWorkAround.settings } }
func someFunc() -> (Int?, Int?, Int?) { var retVal1:Int? = nil var retVal2:Int? = nil var retVal3:Int? = nil return (retVal1, retVal2, retVal3) }
public class DummyClass { public typealias Foo = String }
target use_frameworks! target inherit! :search_paths end target inherit! :search_paths end end
textView.text = "Placeholder" textView.textColor = UIColor.lightGray
func textViewDidBeginEditing(_ textView: UITextView) { if textView.textColor == UIColor.lightGray { textView.text = nil textView.textColor = UIColor.black } }
func textViewDidEndEditing(_ textView: UITextView) { if textView.text.isEmpty { textView.text = "Placeholder" textView.textColor = UIColor.lightGray } }
textView.text = "Placeholder" textView.textColor = UIColor.lightGray textView.becomeFirstResponder() textView.selectedTextRange = textView.textRange(from: textView.beginningOfDocument, to: textView.beginningOfDocument)
func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool { let currentText:String = textView.text let updatedText = (currentText as NSString).replacingCharacters(in: range, with: text) if updatedText.isEmpty { textView.text = "Placeholder" textView.textColor = UIColor.lightGray textView.selectedTextRange = textView.textRange(from: textView.beginningOfDocument, to: textView.beginningOfDocument) } else if textView.textColor == UIColor.lightGray && !text.isEmpty { textView.textColor = UIColor.black textView.text = text } else { return true } return false }
func textViewDidChangeSelection(_ textView: UITextView) { if self.view.window != nil { if textView.textColor == UIColor.lightGray { textView.selectedTextRange = textView.textRange(from: textView.beginningOfDocument, to: textView.beginningOfDocument) } } }
class NotesViewController : UIViewController, UITextViewDelegate { @IBOutlet var textView : UITextView! var placeholderLabel : UILabel! override func viewDidLoad() { super.viewDidLoad() textView.delegate = self placeholderLabel = UILabel() placeholderLabel.text = "Enter some text..." placeholderLabel.font = UIFont.italicSystemFont(ofSize: (textView.font?.pointSize)!) placeholderLabel.sizeToFit() textView.addSubview(placeholderLabel) placeholderLabel.frame.origin = CGPoint(x: 5, y: (textView.font?.pointSize)! / 2) placeholderLabel.textColor = UIColor.lightGray placeholderLabel.isHidden = !textView.text.isEmpty } func textViewDidChange(_ textView: UITextView) { placeholderLabel.isHidden = !textView.text.isEmpty } }
class ViewController: UIViewController, UITextViewDelegate {
override func viewDidLoad() { super.viewDidLoad() yourTextView.delegate = self yourTextView.text = "Placeholder text goes right here..." yourTextView.textColor = UIColor.lightGray
func textViewDidBeginEditing(_ textView: UITextView) { if yourTextView.textColor == UIColor.lightGray { yourTextView.text = "" yourTextView.textColor = UIColor.black } }
func textViewDidEndEditing(_ textView: UITextView) { if yourTextView.text == "" { yourTextView.text = "Placeholder text ..." yourTextView.textColor = UIColor.lightGray } }
func textViewDidChange(descriptionField: UITextView) { if descriptionField.text.isEmpty == false { descriptionPlaceholder.text = "" } else { descriptionPlaceholder.text = descriptionPlaceholderText } }
yourTextView.placeholder = "Placeholder" extension UITextView :UITextViewDelegate { override open var bounds: CGRect { didSet { self.resizePlaceholder() } } public var placeholder: String? { get { var placeholderText: String? if let placeholderLabel = self.viewWithTag(100) as? UILabel { placeholderText = placeholderLabel.text } return placeholderText } set { if let placeholderLabel = self.viewWithTag(100) as! UILabel? { placeholderLabel.text = newValue placeholderLabel.sizeToFit() } else { self.addPlaceholder(newValue!) } } } public func textViewDidChange(_ textView: UITextView) { if let placeholderLabel = self.viewWithTag(100) as? UILabel { placeholderLabel.isHidden = self.text.characters.count > 0 } } private func resizePlaceholder() { if let placeholderLabel = self.viewWithTag(100) as! UILabel? { let labelX = self.textContainer.lineFragmentPadding let labelY = self.textContainerInset.top - 2 let labelWidth = self.frame.width - (labelX * 2) let labelHeight = placeholderLabel.frame.height placeholderLabel.frame = CGRect(x: labelX, y: labelY, width: labelWidth, height: labelHeight) } } private func addPlaceholder(_ placeholderText: String) { let placeholderLabel = UILabel() placeholderLabel.text = placeholderText placeholderLabel.sizeToFit() placeholderLabel.font = self.font placeholderLabel.textColor = UIColor.lightGray placeholderLabel.tag = 100 placeholderLabel.isHidden = self.text.characters.count > 0 self.addSubview(placeholderLabel) self.resizePlaceholder() self.delegate = self } }
txtVw!.autocorrectionType = UITextAutocorrectionType.No txtVw!.text = "Write your Placeholder" txtVw!.textColor = UIColor.lightGrayColor() func textViewDidBeginEditing(textView: UITextView) { if (txtVw?.text == "Write your Placeholder") { txtVw!.text = nil txtVw!.textColor = UIColor.blackColor() } } func textViewDidEndEditing(textView: UITextView) { if txtVw!.text.isEmpty { txtVw!.text = "Write your Placeholder" txtVw!.textColor = UIColor.lightGrayColor() } textView.resignFirstResponder() }
import UIKit protocol PlaceholderTextViewDelegate { func placeholderTextViewDidChangeText(_ text:String) func placeholderTextViewDidEndEditing(_ text:String) } final class PlaceholderTextView: UITextView { var notifier:PlaceholderTextViewDelegate? var placeholder: String? { didSet { placeholderLabel?.text = placeholder } } var placeholderColor = UIColor.lightGray var placeholderFont = UIFont.appMainFontForSize(14.0) { didSet { placeholderLabel?.font = placeholderFont } } fileprivate var placeholderLabel: UILabel? init() { super.init(frame: CGRect.zero, textContainer: nil) awakeFromNib() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } override func awakeFromNib() { super.awakeFromNib() self.delegate = self NotificationCenter.default.addObserver(self, selector: placeholderLabel = UILabel() placeholderLabel?.textColor = placeholderColor placeholderLabel?.text = placeholder placeholderLabel?.textAlignment = .left placeholderLabel?.numberOfLines = 0 } override func layoutSubviews() { super.layoutSubviews() placeholderLabel?.font = placeholderFont var height:CGFloat = placeholderFont.lineHeight if let data = placeholderLabel?.text { let expectedDefaultWidth:CGFloat = bounds.size.width let fontSize:CGFloat = placeholderFont.pointSize let textView = UITextView() textView.text = data textView.font = UIFont.appMainFontForSize(fontSize) let sizeForTextView = textView.sizeThatFits(CGSize(width: expectedDefaultWidth, height: CGFloat.greatestFiniteMagnitude)) let expectedTextViewHeight = sizeForTextView.height if expectedTextViewHeight > height { height = expectedTextViewHeight } } placeholderLabel?.frame = CGRect(x: 5, y: 0, width: bounds.size.width - 16, height: height) if text.isEmpty { addSubview(placeholderLabel!) bringSubview(toFront: placeholderLabel!) } else { placeholderLabel?.removeFromSuperview() } } func textDidChangeHandler(notification: Notification) { layoutSubviews() } } extension PlaceholderTextView : UITextViewDelegate { func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool { if(text == "\n") { textView.resignFirstResponder() return false } return true } func textViewDidChange(_ textView: UITextView) { notifier?.placeholderTextViewDidChangeText(textView.text) } func textViewDidEndEditing(_ textView: UITextView) { notifier?.placeholderTextViewDidEndEditing(textView.text) } }
- (void)customInit { self.contentMode = UIViewContentModeRedraw; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textChanged:) name:UITextViewTextDidChangeNotification object:nil]; } - (void)textChanged:(NSNotification *)notification { if (notification.object == self) { if(self.textStorage.length != 0 || !self.textStorage.length) { [self setNeedsDisplay]; } } } - (void)setPlaceholderText:(NSString *)placeholderText withFont:(UIFont *)font { self.placeholderText = placeholderText; self.placeholderTextFont = font; } - (void)drawRect:(CGRect)rect { [super drawRect:rect]; [[UIColor lightGrayColor] setFill]; if (self.textStorage.length != 0) { return; } CGRect inset = CGRectInset(rect, 8, 8); NSDictionary *attributes = @{NSFontAttributeName: self.placeholderTextFont, NSForegroundColorAttributeName: [UIColor grayColor]}; [self.placeholderText drawInRect:inset withAttributes:attributes]; }`
extension UITextView{ func setPlaceholder() { let placeholderLabel = UILabel() placeholderLabel.text = "Enter some text..." placeholderLabel.font = UIFont.italicSystemFont(ofSize: (self.font?.pointSize)!) placeholderLabel.sizeToFit() placeholderLabel.tag = 222 placeholderLabel.frame.origin = CGPoint(x: 5, y: (self.font?.pointSize)! / 2) placeholderLabel.textColor = UIColor.lightGray placeholderLabel.isHidden = !self.text.isEmpty self.addSubview(placeholderLabel) } func checkPlaceholder() { let placeholderLabel = self.viewWithTag(222) as! UILabel placeholderLabel.isHidden = !self.text.isEmpty } }
override func viewDidLoad() { textView.delegate = self textView.setPlaceholder() } func textViewDidChange(_ textView: UITextView) { textView.checkPlaceholder() }
extension EditProfileVC:UITextViewDelegate{ func textViewDidBeginEditing(_ textView: UITextView) { if textView.textColor == UIColor.lightGray { textView.text = nil textView.textColor = UIColor.black } } func textViewDidEndEditing(_ textView: UITextView) { if textView.text.isEmpty { textView.text = "Placeholder" textView.textColor = UIColor.lightGray } } }
@IBDesignable class UIPlaceholderTextView: UITextView { var placeholderLabel: UILabel? override init(frame: CGRect, textContainer: NSTextContainer?) { super.init(frame: frame, textContainer: textContainer) sharedInit() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) sharedInit() } override func prepareForInterfaceBuilder() { sharedInit() } func sharedInit() { refreshPlaceholder() NotificationCenter.default.addObserver(self, selector: } @IBInspectable var placeholder: String? { didSet { refreshPlaceholder() } } @IBInspectable var placeholderColor: UIColor? = .darkGray { didSet { refreshPlaceholder() } } @IBInspectable var placeholderFontSize: CGFloat = 14 { didSet { refreshPlaceholder() } } func refreshPlaceholder() { if placeholderLabel == nil { placeholderLabel = UILabel() let contentView = self.subviews.first ?? self contentView.addSubview(placeholderLabel!) placeholderLabel?.translatesAutoresizingMaskIntoConstraints = false placeholderLabel?.leftAnchor.constraint(equalTo: contentView.leftAnchor, constant: textContainerInset.left + 4).isActive = true placeholderLabel?.rightAnchor.constraint(equalTo: contentView.rightAnchor, constant: textContainerInset.right + 4).isActive = true placeholderLabel?.topAnchor.constraint(equalTo: contentView.topAnchor, constant: textContainerInset.top).isActive = true placeholderLabel?.bottomAnchor.constraint(lessThanOrEqualTo: contentView.bottomAnchor, constant: textContainerInset.bottom) } placeholderLabel?.text = placeholder placeholderLabel?.textColor = placeholderColor placeholderLabel?.font = UIFont.systemFont(ofSize: placeholderFontSize) } @objc func textChanged() { if self.placeholder?.isEmpty ?? true { return } UIView.animate(withDuration: 0.25) { if self.text.isEmpty { self.placeholderLabel?.alpha = 1.0 } else { self.placeholderLabel?.alpha = 0.0 } } } override var text: String! { didSet { textChanged() } } }
@IBDesignable class PlaceHolderTextView: UITextView { @IBInspectable var placeholder: String = "" { didSet{ updatePlaceHolder() } } @IBInspectable var placeholderColor: UIColor = UIColor.gray { didSet { updatePlaceHolder() } } private var originalTextColor = UIColor.darkText private var originalText: String = "" private func updatePlaceHolder() { if self.text == "" || self.text == placeholder { self.text = placeholder self.textColor = placeholderColor if let color = self.textColor { self.originalTextColor = color } self.originalText = "" } else { self.textColor = self.originalTextColor self.originalText = self.text } } override func becomeFirstResponder() -> Bool { let result = super.becomeFirstResponder() self.text = self.originalText self.textColor = self.originalTextColor return result } override func resignFirstResponder() -> Bool { let result = super.resignFirstResponder() updatePlaceHolder() return result } }
func textViewDidChange(TextView: UITextView) { if txtShortDescription.text == "" { self.lblShortDescription.hidden = false } else { self.lblShortDescription.hidden = true } }
func textViewShouldBeginEditing(textView: UITextView) -> Bool { if textView.textColor == UIColor.lightGrayColor() { textView.selectedTextRange = textView.textRangeFromPosition(textView.beginningOfDocument, toPosition: textView.beginningOfDocument) } return true } func textView(textView: UITextView, shouldChangeTextInRange range: NSRange, replacementText text: String) -> Bool { if textView.textColor == UIColor.lightGrayColor() && text.characters.count > 0 { textView.text = "" textView.textColor = UIColor.blackColor() } if text == "\n" { textView.resignFirstResponder() return false } return true } func textViewDidChange(textView: UITextView) { if textView.text.isEmpty { textView.text = NSLocalizedString("Hint", comment: "hint") textView.textColor = UIColor.lightGrayColor() textView.selectedTextRange = textView.textRangeFromPosition(textView.beginningOfDocument, toPosition: textView.beginningOfDocument) } } func textViewDidChangeSelection(textView: UITextView) { let firstPosition = textView.textRangeFromPosition(textView.beginningOfDocument, toPosition: textView.beginningOfDocument) if textView.textColor == UIColor.lightGrayColor() && textView.selectedTextRange != firstPosition { textView.selectedTextRange = firstPosition } }
import UIKit @IBDesignable class HintedTextView: UITextView { @IBInspectable var hintText: String = "hintText" { didSet{ hintLabel.text = hintText } } private lazy var hintLabel: UILabel = { let label = UILabel() label.font = UIFont.systemFontOfSize(16) label.textColor = UIColor.lightGrayColor() label.translatesAutoresizingMaskIntoConstraints = false return label }() override init(frame: CGRect, textContainer: NSTextContainer?) { super.init(frame: frame, textContainer: textContainer) setupView() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) setupView() } override func prepareForInterfaceBuilder() { super.prepareForInterfaceBuilder() setupView() } private func setupView() { translatesAutoresizingMaskIntoConstraints = false delegate = self font = UIFont.systemFontOfSize(16) addSubview(hintLabel) NSLayoutConstraint.activateConstraints([ hintLabel.leftAnchor.constraintEqualToAnchor(leftAnchor, constant: 4), hintLabel.rightAnchor.constraintEqualToAnchor(rightAnchor, constant: 8), hintLabel.topAnchor.constraintEqualToAnchor(topAnchor, constant: 4), hintLabel.heightAnchor.constraintEqualToConstant(30) ]) } override func layoutSubviews() { super.layoutSubviews() setupView() } }
import Foundation import UIKit extension UITextView { private func add(_ placeholder: UILabel) { for view in self.subviews { if let lbl = view as? UILabel { if lbl.text == placeholder.text { lbl.removeFromSuperview() } } } self.addSubview(placeholder) } func addPlaceholder(_ placeholder: UILabel?) { if let ph = placeholder { ph.numberOfLines = 0 ph.font = UIFont.italicSystemFont(ofSize: (self.font?.pointSize)!) ph.sizeToFit() self.add(ph) ph.frame.origin = CGPoint(x: 5, y: (self.font?.pointSize)! / 2) ph.textColor = UIColor(white: 0, alpha: 0.3) updateVisibility(ph) } } func updateVisibility(_ placeHolder: UILabel?) { if let ph = placeHolder { ph.isHidden = !self.text.isEmpty } } }
class MyViewController: UIViewController, UITextViewDelegate { private var notePlaceholder: UILabel! @IBOutlet weak var txtNote: UITextView! ... override func viewDidLoad() { notePlaceholder = UILabel() notePlaceholder.text = "title\nsubtitle\nmore..." txtNote.addPlaceholder(notePlaceholder) ... } func textViewDidChange(_ textView: UITextView) { txtNote.updateVisbility(notePlaceholder) ... }
txtNote.text = "something in code" txtNote.updateVisibility(self.notePlaceholder)
public class CustomTextView: UITextView { private struct Constants { static let defaultiOSPlaceholderColor = UIColor(red: 0.0, green: 0.0, blue: 0.0980392, alpha: 0.22) } private let placeholderLabel: UILabel = UILabel() private var placeholderLabelConstraints = [NSLayoutConstraint]() @IBInspectable public var placeholder: String = "" { didSet { placeholderLabel.text = placeholder } } @IBInspectable public var placeholderColor: UIColor = CustomTextView.Constants.defaultiOSPlaceholderColor { didSet { placeholderLabel.textColor = placeholderColor } } override public var font: UIFont! { didSet { placeholderLabel.font = font } } override public var textAlignment: NSTextAlignment { didSet { placeholderLabel.textAlignment = textAlignment } } override public var text: String! { didSet { textDidChange() } } override public var attributedText: NSAttributedString! { didSet { textDidChange() } } override public var textContainerInset: UIEdgeInsets { didSet { updateConstraintsForPlaceholderLabel() } } override public init(frame: CGRect, textContainer: NSTextContainer?) { super.init(frame: frame, textContainer: textContainer) commonInit() } required public init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) commonInit() } private func commonInit() { NSNotificationCenter.defaultCenter().addObserver(self, selector: name: UITextViewTextDidChangeNotification, object: nil) placeholderLabel.font = font placeholderLabel.textColor = placeholderColor placeholderLabel.textAlignment = textAlignment placeholderLabel.text = placeholder placeholderLabel.numberOfLines = 0 placeholderLabel.backgroundColor = UIColor.clearColor() placeholderLabel.translatesAutoresizingMaskIntoConstraints = false addSubview(placeholderLabel) updateConstraintsForPlaceholderLabel() } private func updateConstraintsForPlaceholderLabel() { var newConstraints = NSLayoutConstraint.constraintsWithVisualFormat("H:|-(\(textContainerInset.left + textContainer.lineFragmentPadding))-[placeholder]", options: [], metrics: nil, views: ["placeholder": placeholderLabel]) newConstraints += NSLayoutConstraint.constraintsWithVisualFormat("V:|-(\(textContainerInset.top))-[placeholder]", options: [], metrics: nil, views: ["placeholder": placeholderLabel]) newConstraints.append(NSLayoutConstraint( item: placeholderLabel, attribute: .Width, relatedBy: .Equal, toItem: self, attribute: .Width, multiplier: 1.0, constant: -(textContainerInset.left + textContainerInset.right + textContainer.lineFragmentPadding * 2.0) )) removeConstraints(placeholderLabelConstraints) addConstraints(newConstraints) placeholderLabelConstraints = newConstraints } @objc private func textDidChange() { placeholderLabel.hidden = !text.isEmpty } public override func layoutSubviews() { super.layoutSubviews() placeholderLabel.preferredMaxLayoutWidth = textContainer.size.width - textContainer.lineFragmentPadding * 2.0 } deinit { NSNotificationCenter.defaultCenter().removeObserver(self, name: UITextViewTextDidChangeNotification, object: nil) }
private struct Constants { static let defaultiOSPlaceholderColor = UIColor(red: 0.0, green: 0.0, blue: 0.0980392, alpha: 0.22) } private let placeholderLabel: UILabel = UILabel() private var placeholderLabelConstraints = [NSLayoutConstraint]() @IBInspectable public var placeholder: String = "" { didSet { placeholderLabel.text = placeholder } } @IBInspectable public var placeholderColor: UIColor = CustomTextView.Constants.defaultiOSPlaceholderColor { didSet { placeholderLabel.textColor = placeholderColor } } override public var font: UIFont! { didSet { placeholderLabel.font = font } } override public var textAlignment: NSTextAlignment { didSet { placeholderLabel.textAlignment = textAlignment } } override public var text: String! { didSet { textDidChange() } } override public var attributedText: NSAttributedString! { didSet { textDidChange() } } override public var textContainerInset: UIEdgeInsets { didSet { updateConstraintsForPlaceholderLabel() } } override public init(frame: CGRect, textContainer: NSTextContainer?) { super.init(frame: frame, textContainer: textContainer) commonInit() } required public init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) commonInit() } private func commonInit() { NotificationCenter.default.addObserver(self, selector: name: NSNotification.Name.UITextViewTextDidChange, object: nil) placeholderLabel.font = font placeholderLabel.textColor = placeholderColor placeholderLabel.textAlignment = textAlignment placeholderLabel.text = placeholder placeholderLabel.numberOfLines = 0 placeholderLabel.backgroundColor = UIColor.clear placeholderLabel.translatesAutoresizingMaskIntoConstraints = false addSubview(placeholderLabel) updateConstraintsForPlaceholderLabel() } private func updateConstraintsForPlaceholderLabel() { var newConstraints = NSLayoutConstraint.constraints(withVisualFormat: "H:|-(\(textContainerInset.left + textContainer.lineFragmentPadding))-[placeholder]", options: [], metrics: nil, views: ["placeholder": placeholderLabel]) newConstraints += NSLayoutConstraint.constraints(withVisualFormat: "V:|-(\(textContainerInset.top))-[placeholder]", options: [], metrics: nil, views: ["placeholder": placeholderLabel]) newConstraints.append(NSLayoutConstraint( item: placeholderLabel, attribute: .width, relatedBy: .equal, toItem: self, attribute: .width, multiplier: 1.0, constant: -(textContainerInset.left + textContainerInset.right + textContainer.lineFragmentPadding * 2.0) )) removeConstraints(placeholderLabelConstraints) addConstraints(newConstraints) placeholderLabelConstraints = newConstraints } @objc private func textDidChange() { placeholderLabel.isHidden = !text.isEmpty } public override func layoutSubviews() { super.layoutSubviews() placeholderLabel.preferredMaxLayoutWidth = textContainer.size.width - textContainer.lineFragmentPadding * 2.0 } deinit { NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UITextViewTextDidChange, object: nil) }
func textViewDidBeginEditing(_ textView: UITextView) { cell.placeholderLabel.isHidden = !textView.text.isEmpty }
func textViewDidBeginEditing(_ textView: UITextView) { if textView.text == "Description" { textView.text = nil } } func textViewDidEndEditing(_ textView: UITextView) { if textView.text.isEmpty { DispatchQueue.main.async { textView.text = "Description" } } }
extension UITextView { private class PlaceholderLabel: UILabel { } private var placeholderLabel: PlaceholderLabel { if let label = subviews.compactMap( { $0 as? PlaceholderLabel }).first { return label } else { let label = PlaceholderLabel(frame: .zero) label.font = font addSubview(label) return label } } @IBInspectable var placeholder: String { get { return subviews.compactMap( { $0 as? PlaceholderLabel }).first?.text ?? "" } set { let placeholderLabel = self.placeholderLabel placeholderLabel.text = newValue placeholderLabel.numberOfLines = 0 let width = frame.width - textContainer.lineFragmentPadding * 2 let size = placeholderLabel.sizeThatFits(CGSize(width: width, height: .greatestFiniteMagnitude)) placeholderLabel.frame.size.height = size.height placeholderLabel.frame.size.width = width placeholderLabel.frame.origin = CGPoint(x: textContainer.lineFragmentPadding, y: textContainerInset.top) textStorage.delegate = self } } } extension UITextView: NSTextStorageDelegate { public func textStorage(_ textStorage: NSTextStorage, didProcessEditing editedMask: NSTextStorageEditActions, range editedRange: NSRange, changeInLength delta: Int) { if editedMask.contains(.editedCharacters) { placeholderLabel.isHidden = !text.isEmpty } } }
extension UITextViewPlaceholder where Self: UIViewController { func addPlaceholder(text: String, toTextView: UITextView, font: UIFont? = nil) { placeholderLabel = UILabel() placeholderLabel.text = text placeholderLabel.font = font ?? UIFont.italicSystemFont(ofSize: (toTextView.font?.pointSize)!) placeholderLabel.sizeToFit() toTextView.addSubview(placeholderLabel) placeholderLabel.frame.origin = CGPoint(x: 5, y: (toTextView.font?.pointSize)! / 2) placeholderLabel.textColor = UIColor.lightGray placeholderLabel.isHidden = !toTextView.text.isEmpty } func textViewWithPlaceholderDidChange(_ textView: UITextView) { placeholderLabel.isHidden = !textView.text.isEmpty } }
func textViewDidBeginEditing(_ textView: UITextView) { if (commentsTextView.text == "Type Your Comments") { commentsTextView.text = nil commentsTextView.textColor = UIColor.darkGray } } func textViewDidEndEditing(_ textView: UITextView) { if commentsTextView.text.isEmpty { commentsTextView.text = "Type Your Comments" commentsTextView.textColor = UIColor.darkGray } textView.resignFirstResponder() }
import UIKit public protocol PlaceholderTextViewDelegate: class { func placeholderTextViewTextChanged(_ textView: PlaceholderTextView, text: String) } public class PlaceholderTextView: UIView { public weak var delegate: PlaceholderTextViewDelegate? private var heightConstraint: NSLayoutConstraint? public override init(frame: CGRect) { self.allowsNewLines = true super.init(frame: frame) self.heightConstraint = self.heightAnchor.constraint(equalToConstant: 0) self.heightConstraint?.isActive = true self.addSubview(self.placeholderTextView) self.addSubview(self.textView) self.pinToCorners(self.placeholderTextView) self.pinToCorners(self.textView) self.updateHeight() } public override func didMoveToSuperview() { super.didMoveToSuperview() self.updateHeight() } private func pinToCorners(_ view: UIView) { NSLayoutConstraint.activate([ view.leadingAnchor.constraint(equalTo: self.leadingAnchor), view.trailingAnchor.constraint(equalTo: self.trailingAnchor), view.topAnchor.constraint(equalTo: self.topAnchor), view.bottomAnchor.constraint(equalTo: self.bottomAnchor) ]) } public var text: String? { didSet { self.textView.text = text self.textViewDidChange(self.textView) self.updateHeight() } } public var textColor: UIColor? { didSet { self.textView.textColor = textColor self.updateHeight() } } public var font: UIFont? { didSet { self.textView.font = font self.placeholderTextView.font = font self.updateHeight() } } public override var tintColor: UIColor? { didSet { self.textView.tintColor = tintColor self.placeholderTextView.tintColor = tintColor } } public var placeholderText: String? { didSet { self.placeholderTextView.text = placeholderText self.updateHeight() } } public var placeholderTextColor: UIColor? { didSet { self.placeholderTextView.textColor = placeholderTextColor self.updateHeight() } } public var allowsNewLines: Bool public required init?(coder _: NSCoder) { fatalError("init(coder:) has not been implemented") } private lazy var textView: UITextView = self.newTextView() private lazy var placeholderTextView: UITextView = self.newTextView() private func newTextView() -> UITextView { let textView = UITextView() textView.translatesAutoresizingMaskIntoConstraints = false textView.isScrollEnabled = false textView.delegate = self textView.backgroundColor = .clear return textView } private func updateHeight() { let maxSize = CGSize(width: self.frame.size.width, height: .greatestFiniteMagnitude) let textViewSize = self.textView.sizeThatFits(maxSize) let placeholderSize = self.placeholderTextView.sizeThatFits(maxSize) let maxHeight = ceil(CGFloat.maximum(textViewSize.height, placeholderSize.height)) self.heightConstraint?.constant = maxHeight } } extension PlaceholderTextView: UITextViewDelegate { public func textViewDidChangeSelection(_: UITextView) { self.placeholderTextView.alpha = self.textView.text.isEmpty ? 1 : 0 self.updateHeight() } public func textViewDidChange(_: UITextView) { self.delegate?.placeholderTextViewTextChanged(self, text: self.textView.text) } public func textView(_: UITextView, shouldChangeTextIn _: NSRange, replacementText text: String) -> Bool { let containsNewLines = text.rangeOfCharacter(from: .newlines)?.isEmpty == .some(false) guard !containsNewLines || self.allowsNewLines else { return false } return true } }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) txtViewMessage.delegate = self txtViewMessage.text = "Place Holder Name" txtViewMessage.textColor = UIColor.lightGray }
extension ViewController: UITextViewDelegate { func textViewDidBeginEditing(_ textView: UITextView) { if !txtViewMessage.text!.isEmpty && txtViewMessage.text! == "Place Holder Name" { txtViewMessage.text = "" txtViewMessage.textColor = UIColor.black } } func textViewDidEndEditing(_ textView: UITextView) { if txtViewMessage.text.isEmpty { txtViewMessage.text = "Place Holder Name" txtViewMessage.textColor = UIColor.lightGray } } }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) setupKeyboardNotificationListeners(enable: true) } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) setupKeyboardNotificationListeners(enable: false) }
private func setupKeyboardNotificationListeners(enable: Bool) { if enable { NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } else { NotificationCenter.default.removeObserver(self) } }
@objc func keyboardWillShow(notification: NSNotification) { if self.textView.text == self.placeholder { self.textView.text = "" self.textView.textColor = .black } } @objc func keyboardWillHide(notification: NSNotification) { if self.textView.text.isEmpty { self.textView.text = self.placeholder self.textView.textColor = .lightGrey } }
var placeholderLabel : UILabel! textviewDescription.delegate = self placeholderLabel = UILabel() placeholderLabel.text = "Add a description" func textViewDidChange(_ textView: UITextView) { placeholderLabel.isHidden = !textviewDescription.text.isEmpty }
struct Foo { var typeName: String { return String(describing: Foo.self) } var otherTypeName: String { let thisType = type(of: self) return String(describing: thisType) } static var typeName: String { return String(describing: self) } } Foo().typeName Foo().otherTypeName Foo.typeName
extension NSObject { var theClassName: String { return NSStringFromClass(type(of: self)) } }
class Utility{ class func classNameAsString(_ obj: Any) -> String { return String(describing: type(of: obj)) } }
class ClassOne : UIViewController{ class ClassTwo : ClassOne{ class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let dictionary: [String: CGFloat] = [:] let array: [Int] = [] let int = 9 let numFloat: CGFloat = 3.0 let numDouble: Double = 1.0 let classOne = ClassOne() let classTwo: ClassTwo? = ClassTwo() let now = NSDate() let lbl = UILabel() print("diccionary: [String: CGFloat] = [:] -> \(Utility.classNameAsString(dictionary))") print("array: [Int] = [] -> \(Utility.classNameAsString(array))") print("int = 9 -> \(Utility.classNameAsString(int))") print("numFloat: CGFloat = 3.0 -> \(Utility.classNameAsString(numFloat))") print("numDouble: Double = 1.0 -> \(Utility.classNameAsString(numDouble))") print("classOne = ClassOne() -> \((ClassOne).self)") if classTwo != nil { print("classTwo: ClassTwo? = ClassTwo() -> \(Utility.classNameAsString(classTwo!))") } print("now = Date() -> \(Utility.classNameAsString(now))") print("lbl = UILabel() -> \(String(describing: type(of: lbl)))") } }
print("\nInstaciate a class from a String") let aClassName = classOne.theClassName let aClassType = NSClassFromString(aClassName) as! NSObject.Type let instance = aClassType.init() print(String(cString: class_getName(type(of: instance)))) print(instance.self is ClassOne)
protocol NameDescribable { var typeName: String { get } static var typeName: String { get } } extension NameDescribable { var typeName: String { return String(describing: type(of: self)) } static var typeName: String { return String(describing: self) } }
extension NSObject: NameDescribable {} extension Array: NameDescribable {} print(UITabBarController().typeName) print(UINavigationController.typeName) print([Int]().typeName)
func typeName(_ some: Any) -> String { return (some is Any.Type) ? "\(some)" : "\(type(of: some))" } func typeName(some: Any) -> String { return (some is Any.Type) ? "\(some)" : "\(some.dynamicType)" }
import class Foundation.NSObject func typeName(_ some: Any) -> String { return (some is Any.Type) ? "\(some)" : "\(type(of: some))" } class GenericClass<T> { var x: T? = nil } protocol Proto1 { func f(x: Int) -> Int } @objc(ObjCClass1) class Class1: NSObject, Proto1 { func f(x: Int) -> Int { return x } } struct Struct1 { var x: Int } enum Enum1 { case X } print(typeName(GenericClass<Int>.self)) print(typeName(GenericClass<Int>())) print(typeName(Proto1.self)) print(typeName(Class1.self)) print(typeName(Class1())) print(typeName(Class1().f)) print(typeName(Struct1.self)) print(typeName(Struct1(x: 1))) print(typeName(Enum1.self)) print(typeName(Enum1.X))
let className = String(describing: type(of: Foo.self))
import Foundation class SomeClass { class InnerClass { let foo: Int init(foo: Int) { self.foo = foo } } let foo: Int init(foo: Int) { self.foo = foo } } class AnotherClass : NSObject { let foo: Int init(foo: Int) { self.foo = foo super.init() } } struct SomeStruct { let bar: Int init(bar: Int) { self.bar = bar } } let c = SomeClass(foo: 42) let s = SomeStruct(bar: 1337) let i = SomeClass.InnerClass(foo: 2018) let a = AnotherClass(foo: 1<<8)
String(describing: SomeClass.self) String(describing: SomeStruct.self) String(describing: SomeClass.InnerClass.self) String(describing: AnotherClass.self)
String(describing: type(of: c)) String(describing: type(of: s)) String(describing: type(of: i)) String(describing: type(of: a))
let name = _stdlib_getDemangledTypeName(myViewController)
let stringFromType = "\(UIViewController.self)" let stringFromInstance = "\(type(of: UIViewController()))"
let vc = UIViewController() String(Mirror(reflecting: vc).subjectType)
extension NSObject { var className: String { return NSStringFromClass(self as! AnyClass).components(separatedBy: ".").last ?? "" } public class var className: String { return NSStringFromClass(self).components(separatedBy: ".").last ?? "" } }
let state:GKState? print("Class Name: \(String(state.classForCoder)")
class SampleClass { class InnerClass{} } let sampleClassName = reflect(SampleClass.self).summary; let instance = SampleClass(); let instanceClassName = reflect(instance.dynamicType).summary; let innerInstance = SampleClass.InnerClass(); let InnerInstanceClassName = reflect(innerInstance.dynamicType).summary.pathExtension; let tupleArray = [(Int,[String:Int])](); let tupleArrayTypeName = reflect(tupleArray.dynamicType).summary;
func simpleClassName( complexClassName:String ) -> String { var result = complexClassName; var range = result.rangeOfString( "<" ); if ( nil != range ) { result = result.substringToIndex( range!.startIndex ); } range = result.rangeOfString( "." ); if ( nil != range ) { result = result.pathExtension; } return result; }
extension NSObject { static var classNameCleaned : String { let className = self.className() if className.contains(".") { let namesArray = className.components(separatedBy: ".") return namesArray.last ?? className } else { return self.className() } }
NSViewController.classNameCleaned MyCustomClass.classNameCleaned
print(String(describing: type(of: UIButton.self))) print(String(describing: type(of: UIButton()))) UIButton.Type UIButton
import Foundation extension NSObjectProtocol { var className: String { return String(describing: Self.self) } }
@objc(CalendarViewController) class CalendarViewController : UIViewController { }
guard let currentController = UIApplication.topViewController() else { return } currentController.classForCoder.description().componentsSeparatedByString(".").last!
extension UIViewController { func getSimpleClassName() -> String { let describing = String(describing: self) if let dotIndex = describing.index(of: "."), let commaIndex = describing.index(of: ":") { let afterDotIndex = describing.index(after: dotIndex) if(afterDotIndex < commaIndex) { return String(describing[afterDotIndex ..< commaIndex]) } } return describing } }
let str = "Hello, playground" let index = str.index(of: ",")! let newStr = str.substring(to: index)
let newStr = str.substring(to: index) let newStr = String(str[..<index])
let newStr = str.substring(from: index) let newStr = String(str[index...])
let range = firstIndex..<secondIndex let newStr = = str.substring(with: range) let newStr = String(str[range])
let text = "Hello world" text[...3] text[6..<text.count] text[NSRange(location: 6, length: 3)]
import Foundation extension String { subscript(value: NSRange) -> Substring { return self[value.lowerBound..<value.upperBound] } } extension String { subscript(value: CountableClosedRange<Int>) -> Substring { get { return self[index(at: value.lowerBound)...index(at: value.upperBound)] } } subscript(value: CountableRange<Int>) -> Substring { get { return self[index(at: value.lowerBound)..<index(at: value.upperBound)] } } subscript(value: PartialRangeUpTo<Int>) -> Substring { get { return self[..<index(at: value.upperBound)] } } subscript(value: PartialRangeThrough<Int>) -> Substring { get { return self[...index(at: value.upperBound)] } } subscript(value: PartialRangeFrom<Int>) -> Substring { get { return self[index(at: value.lowerBound)...] } } func index(at offset: Int) -> String.Index { return index(startIndex, offsetBy: offset) } }
let str = "Hello, playground" let index = str.index(of: ",")! let substr = str.prefix(upTo: index)
var string = "123456" string = String(string.prefix(3)) string = String(string.suffix(3))
let text = "1234567890" let index = text.index(text.startIndex, offsetBy: 3) text.substring(from: index) String(text[index...])
extension String { public var uppercasedFirstCharacterOld: String { if characters.count > 0 { let splitIndex = index(after: startIndex) let firstCharacter = substring(to: splitIndex).uppercased() let sentence = substring(from: splitIndex) return firstCharacter + sentence } else { return self } } public var uppercasedFirstCharacterNew: String { if characters.count > 0 { let splitIndex = index(after: startIndex) let firstCharacter = self[..<splitIndex].uppercased() let sentence = self[splitIndex...] return firstCharacter + sentence } else { return self } } } let lorem = "lorem".uppercasedFirstCharacterOld print(lorem) let ipsum = "ipsum".uppercasedFirstCharacterNew print(ipsum)
extension String { func substring(from: Int, to: Int) -> String { let start = index(startIndex, offsetBy: from) let end = index(start, offsetBy: to - from) return String(self[start ..< end]) } func substring(range: NSRange) -> String { return substring(from: range.lowerBound, to: range.upperBound) } }
extension String { func subString(startIndex: Int, endIndex: Int) -> String { let end = (endIndex - self.count) + 1 let indexStartOfText = self.index(self.startIndex, offsetBy: startIndex) let indexEndOfText = self.index(self.endIndex, offsetBy: end) let substring = self[indexStartOfText..<indexEndOfText] return String(substring) } }
let str : String = "ilike" for i in 0...str.count { let index = str.index(str.startIndex, offsetBy: i) let prefix = str[..<index] let suffix = str[index...] print("prefix \(prefix), suffix : \(suffix)") }
prefix , suffix : ilike prefix i, suffix : like prefix il, suffix : ike prefix ili, suffix : ke prefix ilik, suffix : e prefix ilike, suffix :
let substring1 = string[startIndex...endIndex] let subString2 = string[startIndex..<endIndex]
extension String { func sliceByCharacter(from: Character, to: Character) -> String? { let fromIndex = self.index(self.index(of: from)!, offsetBy: 1) let toIndex = self.index(self.index(of: to)!, offsetBy: -1) return String(self[fromIndex...toIndex]) } func sliceByString(from:String, to:String) -> String? { var range = self.range(of: from) let subString = String(self[range!.upperBound...]) range = subString.range(of: to) return String(subString[..<range!.lowerBound]) } }
extension String{ func substring(fromIndex : Int,count : Int) -> String{ let startIndex = self.index(self.startIndex, offsetBy: fromIndex) let endIndex = self.index(self.startIndex, offsetBy: fromIndex + count) let range = startIndex..<endIndex return String(self[range]) } }
extension String { func left(_ to: Int) -> String { return "\(self[..<self.index(startIndex, offsetBy: to)])" } func right(_ from: Int) -> String { return "\(self[self.index(startIndex, offsetBy: self.length-from)...])" } func mid(_ from: Int, amount: Int) -> String { let x = "\(self[self.index(startIndex, offsetBy: from)...])" return x.left(amount) } }
extension String { func subString(from: Int, to: Int) -> String { let startIndex = self.index(self.startIndex, offsetBy: from) let endIndex = self.index(self.startIndex, offsetBy: to) return String(self[startIndex...endIndex]) } }
var str = "Hello, playground" print(str.subString(from:1,to:8))
let redStr: String = String(trimmStr[String.Index.init(encodedOffset: 0)..<String.Index.init(encodedOffset: 2)]) let greenStr: String = String(trimmStr[String.Index.init(encodedOffset: 3)..<String.Index.init(encodedOffset: 4)]) let blueStr: String = String(trimmStr[String.Index.init(encodedOffset: 5)..<String.Index.init(encodedOffset: 6)])
var indexStart = string.index(after: string.startIndex ) var strIndexStart = String (string[indexStart...])
var indexEnd = string.index(before: string.endIndex) var strIndexEnd = String (string[..<indexEnd])
var indexWithOffset = string.index(string.startIndex, offsetBy: 4)
extension String { func getSubString(_ char: Character) -> String { var subString = "" for eachChar in self { if eachChar == char { return subString } else { subString += String(eachChar) } } return subString } } let str: String = "Hello, playground" print(str.getSubString(","))
enum Optional<Wrapped> { case none case some(Wrapped) }
var name: String? = "Bob" var peter: Person? = Person() class Car { var modelName: String var internalName: String? }
var name: String? = "Bob" name = nil if name != nil { print("There is a name") } if name == nil { print("Name has no value") }
var name: String? = "Bob" let unwrappedName: String = name! print("Unwrapped name: \(unwrappedName)") name = nil let nilName: String = name!
var mealPreference: String? = "Vegetarian" if mealPreference != nil { let unwrappedMealPreference: String = mealPreference! print("Meal: \(unwrappedMealPreference)") }
var mealPreference: String? = "Vegetarian" if let unwrappedMealPreference: String = mealPreference { print("Meal: \(unwrappedMealPreference)") }
var mealPreference: String? = "Vegetarian" if let mealPreference: String = mealPreference { print("Meal: \(mealPreference)") }
var mealPreference: String? = "Vegetarian" if var mealPreference: String = mealPreference { print("Meal: \(mealPreference)") mealPreference = "Beef" } print("Meal: \(mealPreference)")
let leatherTrim: CarExtras? = nil if leatherTrim { price = price + 1000 }
var religiousAffiliation: String? = "Rastafarian" religiousAffiliation = nil if religiousAffiliation != nil { ... }
var serialNumber:String? = Optional.none serialNumber = Optional.some("1234") print("\(serialNumber.debugDescription)")
class Clint: ExpressibleByNilLiteral { var name: String? required init(nilLiteral: ()) { name = "The Man with No Name" } } let clint: Clint = nil print("\(clint.name)")
var name: Optional<String> = Optional(nilLiteral: ())
var tuxedoRequired: String? = nil let temp: Optional<String> = Optional.none if tuxedoRequired == temp { print("tuxedoRequired is nil") }
let numberToFind: Int = 23 let numberFromString: Int? = Int("23") if numberToFind == numberFromString { print("It }
func doesntEnterNumber(x: Int? = 5) -> Bool { if (x == 5){ return true } else { return false } }
var aString: String? = "Hello, World!" aString = nil
if let myString = aString? { println(myString) } else { println("It }
let aString: String? = "Hello, World!" var anotherString: String = aString! println(anotherString)
enum OptionalValue<T> { case None case Some(T) } var possibleInteger: OptionalValue<Int> = .None possibleInteger = .Some(100)‚Äù
var sampleString: String? sampleString = nil sampleString = "some value" if let value = sampleString{ print(value+value) } sampleString = nil if let value = sampleString{ print(value + value) }
class Person: NSObject { var name : String var companyName : String? init(name:String,company:String?) { self.name = name self.companyName = company } }
var tom:Person = Person.init(name: "Tom", company: "Apple") var bob:Person = Person.init(name: "Bob", company:nil)
var personWithNoName:Person = Person.init(name: nil, company: nil)
print(tom.companyName+" Inc") print(tom.companyName!+" Inc") print(bob.companyName!+" Inc")
if let companyString:String = bob.companyName{ print(companyString+" Inc") }
if let companyString:String = tom.companyName{ print(companyString+" Inc") }
var defaultNil : Int? println(defaultNil) >> nil var canBeNil : Int? = 4 println(canBeNil) >> optional(4) canBeNil = nil println(canBeNil) >> nil println(canBeNil!) >> var canNotBeNil : Int! = 4 print(canNotBeNil) >> 4 var cantBeNil : Int = 4 cantBeNil = nil
let time = dispatch_time(dispatch_time_t(DISPATCH_TIME_NOW), 4 * Int64(NSEC_PER_SEC)) dispatch_after(time, dispatch_get_main_queue()) { }
DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) { }
DispatchQueue.main.asyncAfter(deadline: .now() + 42.0) { }
let timer = Timer.scheduledTimer(withTimeInterval: 42.0, repeats: false) { (timer) in }
func delayWithSeconds(_ seconds: Double, completion: @escaping () -> ()) { DispatchQueue.main.asyncAfter(deadline: .now() + seconds) { completion() } }
func delayForWork() { delay(3.0) { print("delay for 3.0 second") } } delayForWork()
DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { }
public static func runThisAfterDelay(seconds: Double, after: @escaping () -> Void) { runThisAfterDelay(seconds: seconds, queue: DispatchQueue.main, after: after) } public static func runThisAfterDelay(seconds: Double, queue: DispatchQueue, after: @escaping () -> Void) { let time = DispatchTime.now() + Double(Int64(seconds * Double(NSEC_PER_SEC))) / Double(NSEC_PER_SEC) queue.asyncAfter(deadline: time, execute: after) }
Thread.sleep(until: Date(timeIntervalSinceNow: 2.5))
import Foundation for myInt in 1...3 { print(String(format: "%02d", myInt)) }
let hours = 3 let minutes = 15 let seconds = 7 print(String(format: "%02d:%02d:%02d", hours, minutes, seconds))
import Foundation let string0 = String(format: "%02d", 0) let string1 = String(format: "%02d", 1) let string2 = String(format: "%02d", 10) let string3 = String(format: "%02d", 100)
import Foundation let string0 = String(format: "%02d", arguments: [0]) let string1 = String(format: "%02d", arguments: [1]) let string2 = String(format: "%02d", arguments: [10]) let string3 = String(format: "%02d", arguments: [100])
import Foundation let formatter = NumberFormatter() formatter.minimumIntegerDigits = 2 let optionalString0 = formatter.string(from: 0) let optionalString1 = formatter.string(from: 1) let optionalString2 = formatter.string(from: 10) let optionalString3 = formatter.string(from: 100)
extension String { func padLeft (totalWidth: Int, with: String) -> String { let toPad = totalWidth - self.characters.count if toPad < 1 { return self } return "".stringByPaddingToLength(toPad, withString: with, startingAtIndex: 0) + self } }
extension String { func padLeft (totalWidth: Int, with: String) -> String { let toPad = totalWidth - self.characters.count if toPad < 1 { return self } return "".padding(toLength: toPad, withPad: with, startingAt: 0) + self } }
for myInt in 1...3 { print("\(myInt)".padLeft(totalWidth: 2, with: "0")) }
extension String { func leftPadding(toLength: Int, withPad: String = " ") -> String { guard toLength > self.characters.count else { return self } let padding = String(repeating: withPad, count: toLength - self.characters.count) return padding + self } }
let s = String(123) s.leftPadding(toLength: 8, withPad: "0")
let dayMoveRaw = 5 let dayMove = String(format: "%02d", arguments: [dayMoveRaw]) print(dayMove)
let dayMoveRaw = 55 let dayMove = String(format: "%02d", arguments: [dayMoveRaw]) print(dayMove)
let str = "a str" let padAmount = max(10, str.count) String(repeatElement("-", count: padAmount - str.count)) + str
extension Int { func getString(prefix: Int) -> String { return "\(prefix)\(self)" } func getString(prefix: String) -> String { return "\(prefix)\(self)" } } for item in array { print(item.getString(prefix: 0)) } for item in array { print(item.getString(prefix: "0x")) }
for item in array { print(String(repeatElement("0", count: 2)) + "\(item)") }
extension String { func repeate(count: Int, string: String? = nil) -> String { if count > 1 { let repeatedString = string ?? self return repeatedString + repeate(count: count-1, string: repeatedString) } return self } } for item in array { print("0".repeate(count: 3) + "\(item)") }
var escapedString = originalString.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)
NSString *encodedString = (NSString *)CFURLCreateStringByAddingPercentEscapes( NULL, (CFStringRef)unencodedString, NULL, (CFStringRef)@"!* kCFStringEncodingUTF8 );
var originalString = "test/test" var escapedString = originalString.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) print(escapedString!)
var originalString = "test/test" var escapedString = originalString.stringByAddingPercentEncodingWithAllowedCharacters(.URLHostAllowedCharacterSet()) println("escapedString: \(escapedString)")
URLFragmentAllowedCharacterSet " URLHostAllowedCharacterSet " URLPasswordAllowedCharacterSet " URLPathAllowedCharacterSet " URLQueryAllowedCharacterSet " URLUserAllowedCharacterSet "
var originalString = "test/test=42" var customAllowedSet = NSCharacterSet(charactersInString:"=\" var escapedString = originalString.stringByAddingPercentEncodingWithAllowedCharacters(customAllowedSet) println("escapedString: \(escapedString)")
func printCharactersInSet(set: NSCharacterSet) { var characters = "" let iSet = set.invertedSet for i: UInt32 in 32..<127 { let c = Character(UnicodeScalar(i)) if iSet.longCharacterIsMember(i) { characters = characters + String(c) } } print("characters not in set: \ }
let scheme = "https" let host = "www.google.com" let path = "/search" let queryItem = URLQueryItem(name: "q", value: "Formula One") var urlComponents = URLComponents() urlComponents.scheme = scheme urlComponents.host = host urlComponents.path = path urlComponents.queryItems = [queryItem] if let url = urlComponents.url { print(url) }
extension URLComponents { init(scheme: String, host: String, path: String, queryItems: [URLQueryItem]) { self.init() self.scheme = scheme self.host = host self.path = path self.queryItems = queryItems } } if let url = URLComponents(scheme: "https", host: "www.google.com", path: "/search", queryItems: [URLQueryItem(name: "q", value: "Formula One")]).url { print(url) }
let allowedCharacterSet = (CharacterSet(charactersIn: "!* if let escapedString = originalString.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) { }
let escapedString = originalString.addingPercentEncoding(withAllowedCharacters:NSCharacterSet.urlQueryAllowed)
let escapedString = originalString.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)
"http:%2F%2Fwww.ihtc.cc%3Fname=htc&title=iOS%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88"
let encoded = parameter.addingPercentEncoding(withAllowedCharacters: .alphanumerics) let url = "http:
var allowed = CharacterSet.alphanumerics allowed.insert(charactersIn: "-._~") let encoded = parameter.addingPercentEncoding(withAllowedCharacters: allowed) let url = "http:
var str = CFURLCreateStringByAddingPercentEscapes( nil, "test/test", nil, "!* CFStringBuiltInEncodings.UTF8.rawValue )
var allowedQueryParamAndKey = NSCharacterSet.urlQueryAllowed allowedQueryParamAndKey.remove(charactersIn: ";/?:@&=+$, ") paramOrKey.addingPercentEncoding(withAllowedCharacters: allowedQueryParamAndKey)
let allowedQueryParamAndKey = NSCharacterSet.urlQueryAllowed.remove(charactersIn: ";/?:@&=+$, ") paramOrKey.addingPercentEncoding(withAllowedCharacters: allowedQueryParamAndKey)
var allowedQueryParamAndKey = NSCharacterSet(charactersInString: ";/?:@&=+$, ").invertedSet paramOrKey.stringByAddingPercentEncodingWithAllowedCharacters(allowedQueryParamAndKey)
let paramOrKey = "https: paramOrKey.addingPercentEncoding(withAllowedCharacters: allowedQueryParamAndKey) "https%3A%2F%2Fsome.website.com%2Fpath%2Fto%2Fpage.srf%3Fa%3D1%26b%3D2%23top"
var escapedString = originalString.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
encodedParameter = parameter.replacingOccurrences(of: "+", with: "%2B")
extension String { func URLEncodedString() -> String? { var escapedString = self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) return escapedString } static func queryStringFromParameters(parameters: Dictionary<String,String>) -> String? { if (parameters.count == 0) { return nil } var queryString : String? = nil for (key, value) in parameters { if let encodedKey = key.URLEncodedString() { if let encodedValue = value.URLEncodedString() { if queryString == nil { queryString = "?" } else { queryString! += "&" } queryString! += encodedKey + "=" + encodedValue } } } return queryString } }
func stringByAddingPercentEncodingForFormData(plusForSpace: Bool=false) -> String? { let unreserved = "*-._" let allowed = NSMutableCharacterSet.alphanumericCharacterSet() allowed.addCharactersInString(unreserved) if plusForSpace { allowed.addCharactersInString(" ") } var encoded = stringByAddingPercentEncodingWithAllowedCharacters(allowed) if plusForSpace { encoded = encoded?.stringByReplacingOccurrencesOfString(" ", withString: "+") } return encoded }
func encodedUrl(from string: String) -> URL? { guard let decodedString = string.removingPercentEncoding, let percentEncodedString = decodedString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else { return nil } return URL(string: percentEncodedString) } let urlText = "https: let url = encodedUrl(from: urlText)
import UIKit class LoginViewController: UIViewController { @IBOutlet var username : UITextField = UITextField() @IBOutlet var password : UITextField = UITextField() @IBAction func loginButton(sender : AnyObject) { if username .isEqual("") || password.isEqual("")) { println("Sign in failed. Empty character") } }
if([[self.username text] isEqualToString: @""] || [[self.password text] isEqualToString: @""] ) {
let x = "hello" let y = "hello" let isEqual = (x == y)
let quotation = "We let sameQuotation = "We if quotation == sameQuotation { println("These two strings are considered equal") } . . .
extension String { func isEqualToString(find: String) -> Bool { return String(format: self) == find } }
let a = "abc" let b = "abc" if a.isEqualToString(b) { println("Equals") }
if username == "" || password == "" { println("Sign in failed. Empty character") }
let intValue = ("12".toInt()) println("This is a intValue now \(intValue)") let caUpperValue = "ca".uppercaseString println("This is the uppercase of ca \(caUpperValue)")
let curious = ("ca" === "ca") println("This will be false.. and the answer is..\(curious)")
let NotSoCuriousAnyMore = ("ca" == "ca") println("This will be true.. and the answer is..\(NotSoCuriousAnyMore)")
if username.isEmpty || password.isEmpty { println("Sign in failed. Empty character") }
if(txtUsername.text.isEmpty || txtPassword.text.isEmpty) { } else if(txtUsername.text == "****" && txtPassword.text == "****") { }
func exitViewController() { navigationController?.popViewController(animated: true) }
_ = navigationController?.popViewController(animated: true)
import UIKit extension UINavigationController { func pop(animated: Bool) { _ = self.popViewController(animated: animated) } func popToRoot(animated: Bool) { _ = self.popToRootViewController(animated: animated) } }
func exitViewController() { navigationController?.pop(animated: true) } func popToTheRootOfNav() { navigationController?.popToRoot(animated: true) }
let _ = navigationController?.popViewController(animated: true)
Eg. _ = navigationController?.popViewController(animated: true)
@discardableResult mutating func advance(to level: Int) -> Bool { ... return true }
import UIKit extension UINavigationController { @discardableResult func pop(animated: Bool) -> UIViewController? { return self.popViewController(animated: animated) } @discardableResult func popToRoot(animated: Bool) -> [UIViewController]? { return self.popToRootViewController(animated: animated) } }
if let navigationController = navigationController { navigationController.popViewController(animated: true) }
var foo: Int { get { return getFoo() } set { setFoo(newValue) } }
class Foo { var myProperty: Int = 0 { didSet { print("The value of myProperty changed from \(oldValue) to \(myProperty)") } } }
class Foo { var myPropertyValue: Int = 0 var myProperty: Int { get { return myPropertyValue } set { print("The value of myProperty changed from \(myPropertyValue) to \(newValue)") myPropertyValue = newValue } } }
var test : Int { get { return test } set (aNewValue) { if (aNewValue != test) { test = aNewValue } } }
var _test : Int = 0 var test : Int { get { return _test } set (aNewValue) { if (aNewValue != test) { _test = aNewValue } } }
var _test : Int = 0 { willSet { println("Old value is \(_test), new value is \(newValue)") } didSet { println("Old value is \(oldValue), new value is \(_test)") } } var test : Int { get { return _test } set (aNewValue) { if (aNewValue != test) { _test = aNewValue } } }
var _childVC : UIViewController? { willSet { println("Property will set") if (_childVC != nil) { _childVC!.willMoveToParentViewController(nil) self.setOverrideTraitCollection(nil, forChildViewController: _childVC) _childVC!.view.removeFromSuperview() _childVC!.removeFromParentViewController() } if (newValue) { self.addChildViewController(newValue) } } didSet { println("Property did set") if (_childVC) { _childVC!.view.setTranslatesAutoresizingMaskIntoConstraints(false) self.view.addSubview(_childVC!.view) let views = ["view" : _childVC!.view] as NSMutableDictionary let layoutOpts = NSLayoutFormatOptions(0) let lc1 : AnyObject[] = NSLayoutConstraint.constraintsWithVisualFormat("|[view]|", options: layoutOpts, metrics: NSDictionary(), views: views) let lc2 : AnyObject[] = NSLayoutConstraint.constraintsWithVisualFormat("V:|[view]|", options: layoutOpts, metrics: NSDictionary(), views: views) self.view.addConstraints(lc1) self.view.addConstraints(lc2) _childVC!.didMoveToParentViewController(self) } } } var childVC : UIViewController? { get { return _childVC } set(suggestedVC) { if (suggestedVC != _childVC) { _childVC = suggestedVC } } }
let minValue = 1 var value = 1 { didSet { if value < minValue { value = minValue } } } value = -10
protocol CustomUserControlDelegate { func didChangeValue(value: Int) } class CustomUserControl: UIView { private var value = 0 { didSet { delegate?.didChangeValue(value) } } var delegate: CustomUserControlDelegate? required init?(...) { } }
Import UIKit class ViewController: UIViewController, CustomUserControlDelegate { @IBOutlet weak var customUserControl: CustomUserControl! override func viewDidLoad() { super.viewDidLoad() customUserControl = self } func didChangeValue(value: Int) { } }
@IBOutlet weak var loginOrSignupButton: UIButton! { didSet { let title = NSLocalizedString("signup_required_button") loginOrSignupButton.setTitle(title, for: .normal) loginOrSignupButton.setTitle(title, for: .highlighted) }
foo : int { get { return getFoo(); } set { setFoo(newValue); } }
override func viewDidLoad() { super.viewDidLoad() let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 50)) button.backgroundColor = .greenColor() button.setTitle("Test Button", forState: .Normal) button.addTarget(self, action: self.view.addSubview(button) } func buttonAction(sender: UIButton!) { print("Button tapped") }
override func viewDidLoad() { super.viewDidLoad() let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 50)) button.backgroundColor = .green button.setTitle("Test Button", for: .normal) button.addTarget(self, action: self.view.addSubview(button) } func buttonAction(sender: UIButton!) { print("Button tapped") }
override func viewDidLoad() { super.viewDidLoad() let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 50)) button.backgroundColor = .green button.setTitle("Test Button", for: .normal) button.addTarget(self, action: self.view.addSubview(button) } @objc func buttonAction(sender: UIButton!) { print("Button tapped") }
let button = UIButton(type: .System) button.frame = CGRectMake(100, 100, 100, 50) button.backgroundColor = UIColor.greenColor() button.setTitle("Button", forState: UIControlState.Normal) button.addTarget(self, action: "Action:", forControlEvents: UIControlEvents.TouchUpInside) self.view.addSubview(button)
var label: UILabel = UILabel() label.frame = CGRectMake(50, 50, 200, 21) label.backgroundColor = UIColor.blackColor() label.textColor = UIColor.whiteColor() label.textAlignment = NSTextAlignment.Center label.text = "test label" self.view.addSubview(label)
var txtField: UITextField = UITextField() txtField.frame = CGRectMake(50, 70, 200, 30) txtField.backgroundColor = UIColor.grayColor() self.view.addSubview(txtField)
let button = UIButton() button.frame = CGRect(x: self.view.frame.size.width - 60, y: 60, width: 50, height: 50) button.backgroundColor = UIColor.red button.setTitle("Name your Button ", for: .normal) button.addTarget(self, action: self.view.addSubview(button) func buttonAction(sender: UIButton!) { print("Button tapped") }
let button = UIButton() button.frame = CGRect(x: self.view.frame.size.width - 60, y: 60, width: 50, height: 50) button.backgroundColor = UIColor.red button.setTitle("Name your Button ", for: .normal) button.addTarget(self, action: self.view.addSubview(button) @objc func buttonAction(sender: UIButton!) { print("Button tapped") }
let btn = UIButton(type: .custom) as UIButton btn.backgroundColor = .blue btn.setTitle("Button", for: .normal) btn.frame = CGRect(x: 100, y: 100, width: 200, height: 100) btn.addTarget(self, action: self.view.addSubview(btn) func clickMe(sender:UIButton!) { print("Button Clicked") }
func createButton() { let button = UIButton(type: .system) button.frame = CGRect(x: 100.0, y: 100.0, width: 100.0, height: 100.0) button.setTitle(NSLocalizedString("Button", comment: "Button"), for: .normal) button.backgroundColor = .green button.addTarget(self, action: view.addSubview(button) } @objc func buttonAction(sender: UIButton) { print("Button pushed") }
var sampleButton:UIButton? override func viewDidLoad() { super.viewDidLoad() } override func viewDidAppear(animated: Bool) { sampleButton = UIButton(type: .RoundedRect) sampleButton!.setTitle("Sample \n UI Button", forState: .Normal) sampleButton!.titleLabel?.lineBreakMode = .ByWordWrapping sampleButton!.titleLabel?.textAlignment = .Center sampleButton!.setTitleColor(UIColor.whiteColor(), forState: .Normal) sampleButton!.layer.cornerRadius = 6 sampleButton!.backgroundColor = UIColor.redColor().colorWithAlphaComponent(0.6) sampleButton?.tintColor = UIColor.brownColor() sampleButton!.titleEdgeInsets = UIEdgeInsetsMake(-10,-10,-10,-10) sampleButton!.contentEdgeInsets = UIEdgeInsetsMake(5,5,5,5) sampleButton!.addTarget(self, action: "sampleButtonClicked", forControlEvents: .TouchUpInside) self.view.addSubview(sampleButton!) sampleButton!.translatesAutoresizingMaskIntoConstraints = false let bottomButtonConstraint = sampleButton!.bottomAnchor.constraintEqualToAnchor(bottomLayoutGuide.topAnchor, constant: -20) let margins = view.layoutMarginsGuide let leadingButtonConstraint = sampleButton!.leadingAnchor.constraintEqualToAnchor(margins.leadingAnchor) bottomButtonConstraint.active = true leadingButtonConstraint.active = true } func sampleButtonClicked(){ print("sample Button Clicked") }
var button = UIButton(frame: CGRectMake(0, 0, 50, 50)) self.view.addSubview(button)
var button=UIButton(frame: CGRectMake(150, 240, 75, 30)) button.setTitle("Next", forState: UIControlState.Normal) button.addTarget(self, action: "buttonTapAction:", forControlEvents: UIControlEvents.TouchUpInside) button.backgroundColor = UIColor.greenColor() self.view.addSubview(button)
func buttonTapAction(sender:UIButton!) { println("Button is working") }
var button: UIButton = UIButton(type: UIButtonType.Custom) as UIButton self.button.frame = CGRectMake(130, 70, 60, 20) self.button.setTitle("custom button", forState: UIControlState.Normal) self.button.addTarget(self, action:"buttonActionFuncName", forControlEvents: UIControlEvents.TouchUpInside) self.button.setTitleColor(UIColor.blackColor(), forState: .Normal) self.button.layer.borderColor = UIColor.blackColor().CGColor self.button.titleLabel?.font = UIFont(name: "Helvetica-Bold", size: 13) self.view.addSubview(self.button)
import UIKit let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 50, height: 50)) init(nibName nibNameOrNil: String!, bundle nibBundleOrNil: NSBundle!) { super.init(nibName: nibName, bundle: nibBundle) myButton.targetForAction("tappedButton:", withSender: self) } func tappedButton(sender: UIButton!) { println("tapped button") }
var button: UIButton = UIButton(frame: CGRectMake(0, 0, 100, 100))
@IBAction func buttonActionFromStoryboard(sender: UIButton) { println("Button Action From Storyboard") }
let uiButton = UIButton.buttonWithType(UIButtonType.System) as UIButton uiButton.frame = CGRectMake(16, 116, 288, 30) uiButton.setTitle("Second", forState: UIControlState.Normal); uiButton.addTarget(self, action: "buttonActionFromCode:", forControlEvents: UIControlEvents.TouchUpInside) self.view.addSubview(uiButton)
@IBAction func buttonActionFromCode(sender:UIButton) { println("Button Action From Code") }
let myFirstButton = UIButton() myFirstButton.setTitle("Software Button", forState: .Normal) myFirstButton.setTitleColor(UIColor.redColor(), forState: .Normal) myFirstButton.frame = CGRectMake(100, 300, 150, 50) myFirstButton.backgroundColor = UIColor.purpleColor() myFirstButton.layer.cornerRadius = 14 myFirstButton.addTarget(self, action: "pressed:", forControlEvents: .TouchUpInside) self.view.addSubview(myFirstButton) myFirstButton.hidden=true nameText.delegate = self func pressed(sender: UIButton!) { var alertView = UIAlertView() alertView.addButtonWithTitle("Ok") alertView.title = "title" alertView.message = "message" alertView.show(); }
let buttonPuzzle:UIButton = UIButton(frame: CGRectMake(100, 400, 100, 50)) buttonPuzzle.backgroundColor = UIColor.greenColor() buttonPuzzle.setTitle("Puzzle", forState: UIControlState.Normal) buttonPuzzle.addTarget(self, action: "buttonAction:", forControlEvents: UIControlEvents.TouchUpInside) buttonPuzzle.tag = 22; self.view.addSubview(buttonPuzzle)
func buttonAction(sender:UIButton!) { var btnsendtag:UIButton = sender if btnsendtag.tag == 22 { } }
let label = UILabel() label.frame = CGRectMake(35, 100, 250, 30) label.textColor = UIColor.blackColor() label.textAlignment = NSTextAlignment.Center label.text = "Hello World" self.view.addSubview(label) let btn: UIButton = UIButton(type: UIButtonType.Custom) as UIButton btn.frame = CGRectMake(130, 70, 60, 20) btn.setTitle("Click", forState: UIControlState.Normal) btn.setTitleColor(UIColor.blackColor(), forState: .Normal) btn.addTarget(self, action:Selector("clickAction"), forControlEvents: UIControlEvents.TouchUpInside) view.addSubview(btn) @IBAction func clickAction(sender:AnyObject) { print("Click Action") }
func setupButtonMap(){ let mapButton = UIButton(type: .system) mapButton.setImage( mapButton.frame = CGRect(x: 0, y: 0, width: 34, height: 34) mapButton.contentMode = .scaleAspectFit mapButton.backgroundColor = UIColor.clear mapButton.addTarget(self, action: navigationItem.leftBarButtonItem = UIBarButtonItem(customView: mapButton) } @IBAction func btnOpenMap(_ sender: Any?) { print("Successful") }
let myButton = UIButton() myButton.titleLabel!.frame = CGRectMake(15, 54, 300, 500) myButton.titleLabel!.text = "Button Label" myButton.titleLabel!.textColor = UIColor.redColor() myButton.titleLabel!.textAlignment = .Center self.view.addSubview(myButton)
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let btn = UIButton(type: UIButtonType.System) as UIButton btn.backgroundColor = UIColor.blueColor() btn.setTitle("CALL TPT AGENT", forState: UIControlState.Normal) btn.frame = CGRectMake(100, 100, 200, 100) btn.addTarget(self, action: "clickMe:", forControlEvents: UIControlEvents.TouchUpInside) self.view.addSubview(btn) } func clickMe(sender:UIButton!) { print("CALL") } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
func viewDidLoad(){ saveActionButton = UIButton(frame: CGRect(x: self.view.frame.size.width - 60, y: 0, width: 50, height: 50)) self.saveActionButton.backgroundColor = UIColor(red: 76/255, green: 217/255, blue: 100/255, alpha: 0.7) saveActionButton.addTarget(self, action: self.saveActionButton.setTitle("Done", for: .normal) self.saveActionButton.layer.cornerRadius = self.saveActionButton.frame.size.width / 2 self.saveActionButton.layer.borderColor = UIColor.darkGray.cgColor self.saveActionButton.layer.borderWidth = 1 self.saveActionButton.center.y = self.view.frame.size.height - 80 self.view.addSubview(saveActionButton) } func doneAction(){ print("Write your own logic") }
override func viewDidLoad() { super.viewDidLoad() let myButton = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 50)) myButton.backgroundColor = .green myButton.setTitle("Hello UIButton", for: .normal) myButton.addTarget(self, action: self.view.addSubview(myButton) } @objc func myButtonAction(sender: UIButton!) { print("My Button tapped") }
Uilabel code var label: UILabel = UILabel() label.frame = CGRectMake(50, 50, 200, 21) label.backgroundColor = UIColor.blackColor() label.textColor = UIColor.whiteColor() label.textAlignment = NSTextAlignment.Center label.text = "test label" self.view.addSubview(label)
override func viewDidLoad() { super.viewDidLoad() var imageView = UIImageView(frame: CGRectMake(100, 150, 150, 150)); var image = UIImage(named: "BattleMapSplashScreen.png"); imageView.image = image; self.view.addSubview(imageView); }
import Cocoa class DataImporter { var fileName = "data.txt" } class DataManager { @lazy var importer = DataImporter() var data = String[]() } let manager = DataManager() manager.data += "Some data" manager.data += "Some more data" println(manager.importer.fileName) var str = "Hello World in Swift Language."
let file = "file.txt" let text = "some text" if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first { let fileURL = dir.appendingPathComponent(file) do { try text.write(to: fileURL, atomically: false, encoding: .utf8) } catch { } do { let text2 = try String(contentsOf: fileURL, encoding: .utf8) } catch { } }
let file = "file.txt" let text = "some text" if let dir = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.AllDomainsMask, true).first { let path = NSURL(fileURLWithPath: dir).URLByAppendingPathComponent(file) do { try text.writeToURL(path, atomically: false, encoding: NSUTF8StringEncoding) } catch { } do { let text2 = try NSString(contentsOfURL: path, encoding: NSUTF8StringEncoding) } catch { } }
let file = "file.txt" if let dirs : [String] = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.AllDomainsMask, true) as? [String] { let dir = dirs[0] let path = dir.stringByAppendingPathComponent(file); let text = "some text" text.writeToFile(path, atomically: false, encoding: NSUTF8StringEncoding, error: nil); let text2 = String(contentsOfFile: path, encoding: NSUTF8StringEncoding, error: nil) }
let bundle = NSBundle.mainBundle() let path = bundle.pathForResource("data", ofType: "txt") let content = NSString.stringWithContentsOfFile(path) as String println(content)
let path = NSBundle.mainBundle().pathForResource("FileName", ofType: "txt") var text = String(contentsOfFile: path!, encoding: NSUTF8StringEncoding, error: nil)! println(text)
let path = Bundle.main.path(forResource: "data", ofType: "txt") var text = String(contentsOfFile: path!, encoding: NSUTF8StringEncoding, error: nil)!
do { if let documentDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first { let fileURL = documentDirectory.appendingPathComponent("file.txt") let text = "Hello World !!!" try text.write(to: fileURL, atomically: false, encoding: .utf8) print("saving was successful") let savedText = try String(contentsOf: fileURL) print("savedText:", savedText) } } catch { print("error:", error) }
import Foundation let fileName = "Test" let dir = try? FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true) if let fileURL = dir?.appendingPathComponent(fileName).appendingPathExtension("txt") { let outString = "Write this text to the file" do { try outString.write(to: fileURL, atomically: true, encoding: .utf8) } catch { print("Failed writing to URL: \(fileURL), Error: " + error.localizedDescription) } var inString = "" do { inString = try String(contentsOf: fileURL) } catch { print("Failed reading from URL: \(fileURL), Error: " + error.localizedDescription) } print("Read from the file: \(inString)") }
if let path = Bundle.main.path(forResource: filename, ofType: nil) { do { let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8) print(text) } catch { printError("Failed to read text from \(filename)") } } else { printError("Failed to load file from app bundle \(filename)") }
public extension String { func contentsOrBlank()->String { if let path = Bundle.main.path(forResource:self , ofType: nil) { do { let text = try String(contentsOfFile:path, encoding: String.Encoding.utf8) return text } catch { print("Failed to read text from bundle file \(self)") } } else { print("Failed to load file from bundle \(self)") } return "" } }
let r:[String] = "yourFile.txt" .contentsOrBlank() .characters .split(separator: "\n", omittingEmptySubsequences:ignore) .map(String.init)
let s = try String(contentsOfFile: Bundle.main.path(forResource: "myFile", ofType: "txt")!)
let s = try! String(contentsOfFile: NSBundle.mainBundle().pathForResource("myFile", ofType: "txt")!)
let file = "file.txt" let dirs: [String]? = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.AllDomainsMask, true) as? [String] if (dirs != nil) { let directories:[String] = dirs! let dirs = directories[0]; let path = dirs.stringByAppendingPathComponent(file); let text = "some text" text.writeToFile(path, atomically: false, encoding: NSUTF8StringEncoding, error: nil); var error:NSError? let text2 = String(contentsOfFile: path, encoding:NSUTF8StringEncoding, error: &error) if let theError = error { print("\(theError.localizedDescription)") } }
import StreamScanner if let input = NSFileHandle(forReadingAtPath: "/file/path") { let scanner = StreamScanner(source: input, delimiters: NSCharacterSet(charactersInString: ":\n")) while let field: String = scanner.read() { } }
let path = NSBundle.mainBundle().pathForResource("Output_5", ofType: "xml") let text = try? NSString(contentsOfFile: path! as String, encoding: NSUTF8StringEncoding) print(text)
public func writeToURL(url: NSURL, atomically useAuxiliaryFile: Bool, encoding enc: UInt) throws public func writeToFile(path: String, atomically useAuxiliaryFile: Bool, encoding enc: UInt) throws public convenience init(contentsOfURL url: NSURL, encoding enc: UInt) throws public convenience init(contentsOfFile path: String, encoding enc: UInt) throws
func writeToDocumentsFile(fileName:String,value:String) { let documentsPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as NSString! let path = documentsPath.stringByAppendingPathComponent(fileName) do { try value.writeToFile(path, atomically: true, encoding: NSUTF8StringEncoding) } catch let error as NSError { print("ERROR : writing to file \(path) : \(error.localizedDescription)") } } func readFromDocumentsFile(fileName:String) -> String { let documentsPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as NSString let path = documentsPath.stringByAppendingPathComponent(fileName) var readText : String = "" do { try readText = NSString(contentsOfFile: path, encoding: NSUTF8StringEncoding) as String } catch let error as NSError { print("ERROR : reading from file \(fileName) : \(error.localizedDescription)") } return readText }
let myFileURL = NSBundle.mainBundle().URLForResource("listacomuni", withExtension: "txt")! let myText = try! String(contentsOfURL: myFileURL, encoding: NSISOLatin1StringEncoding) print(String(myText))
func writeToDocumentsFile(fileName:String,value:String) { let documentsPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as! NSString let path = documentsPath.stringByAppendingPathComponent(fileName) var error:NSError? value.writeToFile(path, atomically: true, encoding: NSUTF8StringEncoding, error: &error) } func readFromDocumentsFile(fileName:String) -> String { let documentsPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as! NSString let path = documentsPath.stringByAppendingPathComponent(fileName) var checkValidation = NSFileManager.defaultManager() var error:NSError? var file:String if checkValidation.fileExistsAtPath(path) { file = NSString(contentsOfFile: path, encoding: NSUTF8StringEncoding, error: nil) as! String } else { file = "*ERROR* \(fileName) does not exist." } return file }
writeToDocumentsFile("MyText.txt","Hello world!") let value = readFromDocumentsFile("MyText.txt") println(value) let otherValue = readFromDocumentsFile("SomeText.txt") println(otherValue)
{ "NumberOfSlices": "8", "NrScenes": "5", "Scenes": [{ "dataType": "label1", "image":"http: "value": "Hello", "color": "(UIColor.red)" }, { "dataType": "label2", "image":"http: "value": "Hi There", "color": "(UIColor.blue)" }, { "dataType": "label3", "image":"http: "value": "hi how r u ", "color": "(UIColor.green)" }, { "dataType": "label4", "image":"http: "value": "what are u doing ", "color": "(UIColor.purple)" }, { "dataType": "label5", "image":"http: "value": "how many times ", "color": "(UIColor.white)" }, { "dataType": "label6", "image":"http: "value": "hi how r u ", "color": "(UIColor.blue)" }, { "dataType": "label7", "image":"http: "value": "hi how r u ", "color": "(UIColor.gry)" }, { "dataType": "label8", "image":"http: "value": "hi how r u ", "color": "(UIColor.brown)" }]
let filePath = Bundle.main.path(forResource: "nameoftheyourjsonTextfile", ofType: "json") let contentData = FileManager.default.contents(atPath: filePath!) let content = NSString(data: contentData!, encoding: String.Encoding.utf8.rawValue) as? String print(content) let json = try! JSONSerialization.jsonObject(with: contentData!) as! NSDictionary print(json) let app = json.object(forKey: "Scenes") as! NSArray! let _ : NSDictionary for dict in app! { let colorNam = (dict as AnyObject).object(forKey: "color") as! String print("colors are \(colorNam)") let value = (dict as AnyObject).object(forKey: "value") as! String print("the values are \(value)") valuesArray.append(value) let images = (dict as AnyObject).object(forKey: "image") as! String let url = URL(string: images as String) let data = try? Data(contentsOf: url!) print(data) let image1 = UIImage(data: data!)! as UIImage imagesArray.append(image1) print(image1) }
let path = Bundle.main.path(forResource: "data", ofType: "txt") do { var text = try String(contentsOfFile: path!) } catch(_){print("error")} }
var error: NSError? var paths = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, NSSearchPathDomainMask.UserDomainMask, true) var documentsDirectory = paths.first as String var dataPath = documentsDirectory.stringByAppendingPathComponent("MyFolder") if !NSFileManager.defaultManager().fileExistsAtPath(dataPath) { NSFileManager.defaultManager().createDirectoryAtPath(dataPath, withIntermediateDirectories: false, attributes: nil, error: &error) } else { println("not creted or exist") } func listDocumentDirectoryfiles() -> [String] { if let documentDirectory = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true).first as? String { let myFilePath = documentDirectory.stringByAppendingPathComponent("MyFolder") return NSFileManager.defaultManager().contentsOfDirectoryAtPath(myFilePath, error: nil) as [String] } return [] }
import Foundation let s = try! String(contentsOfFile: "yo", encoding: .utf8)
func writeToDocumentsFile(fileName:String,value:String) { let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] as NSString let path = documentsPath.appendingPathComponent(fileName) do{ try value.write(toFile: path, atomically: true, encoding: String.Encoding.utf8) }catch{ } } func readFromDocumentsFile(fileName:String) -> String { let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] as NSString let path = documentsPath.appendingPathComponent(fileName) let checkValidation = FileManager.default var file:String if checkValidation.fileExists(atPath: path) { do{ try file = NSString(contentsOfFile: path, encoding: String.Encoding.utf8.rawValue) as String }catch{ file = "" } } else { file = "" } return file }
let documentsDirectoryPathString = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first! let documentsDirectoryPath = NSURL(string: documentsDirectoryPathString)! let jsonFilePath = documentsDirectoryPath.appendingPathComponent("Filename.json") let fileManager = FileManager.default var isDirectory: ObjCBool = false if fileManager.fileExists(atPath: (jsonFilePath?.absoluteString)!, isDirectory: &isDirectory) { let finalDataDict = NSKeyedUnarchiver.unarchiveObject(withFile: (jsonFilePath?.absoluteString)!) as! [String: Any] } else{ print("File does not exists") }
NSKeyedArchiver.archiveRootObject(finalDataDict, toFile:(jsonFilePath?.absoluteString)!)
var timer = NSTimer() timer(timeInterval: 0.01, target: self, selector: update, userInfo: nil, repeats: false)
override func viewDidLoad() { super.viewDidLoad() let timer = Timer(timeInterval: 0.4, repeats: true) { _ in print("Done!") } let timer = Timer.scheduledTimer(timeInterval: 0.4, target: self, selector: let timer = NSTimer.scheduledTimerWithTimeInterval(0.4, target: self, selector: let timer = NSTimer.scheduledTimerWithTimeInterval(0.4, target: self, selector: "update", userInfo: nil, repeats: true) } @objc func update() { }
import UIKit class ViewController: UIViewController { var counter = 0 var timer = Timer() @IBOutlet weak var label: UILabel! @IBAction func startTimerButtonTapped(sender: UIButton) { timer.invalidate() timer = Timer.scheduledTimer(timeInterval: 0.5, target: self, selector: } @IBAction func cancelTimerButtonTapped(sender: UIButton) { timer.invalidate() } func timerAction() { counter += 1 label.text = "\(counter)" } }
timer = Timer.scheduledTimer(timeInterval: 2.0, target: self, selector:
class TimerSample { var timer: Timer? func startTimer() { timer = Timer.scheduledTimer(timeInterval: 5.0, target: self, selector: userInfo: [ "foo" : "bar" ], repeats: true) } @objc func eventWith(timer: Timer!) { let info = timer.userInfo as Any print(info) } }
_ = Timer.scheduledTimer(withTimeInterval: 5, repeats: false) { timer in label.isHidden = true }
func schedule() { DispatchQueue.main.async { self.timer = Timer.scheduledTimer(timeInterval: 20, target: self, selector: } } @objc private func timerDidFire(timer: Timer) { print(timer) }
DispatchQueue.main.async { self.timer = Timer.scheduledTimer(withTimeInterval: 20, repeats: false) { timer in print(timer) } }
var timer = NSTimer.scheduledTimerWithTimeInterval(0.01, target: self, selector: Selector("update"), userInfo: nil, repeats: true);
Timer.scheduledTimer(timeInterval: 1, target: self, selector: userInfo: nil, repeats: true) @objc func update() { }
self.timer = Timer(fireAt: fire, interval: deltaT, target: self, selector: userInfo: ["custom":"data"], repeats: true) RunLoop.main.add(self.timer!, forMode: RunLoopMode.commonModes) self.timer!.fire() } func timerCallBack(timer: Timer!){ let info = timer.userInfo print(info) }
SimpleTimer(interval: 3,repeats: true){print("tick")}.start()
class SimpleTimer { typealias Tick = ()->Void var timer:Timer? var interval:TimeInterval var repeats:Bool var tick:Tick init( interval:TimeInterval, repeats:Bool = false, onTick:@escaping Tick){ self.interval = interval self.repeats = repeats self.tick = onTick } func start(){ timer = Timer.scheduledTimer(timeInterval: interval, target: self, selector: } func stop(){ if(timer != nil){timer!.invalidate()} } /** * This method must be in the public or scope */ @objc func update() { tick() } }
func startTimerForResendingCode() { let timerIntervalForResendingCode = TimeInterval(60) Timer.scheduledTimer(timeInterval: timerIntervalForResendingCode, target: self, selector: userInfo: nil, repeats: false) } @objc func timerEndedUp() { output?.timerHasFinishedAndCodeMayBeResended() }
timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector:
let timer = Timer(timeInterval: 3, target: self, selector: func update(_ timer : Timer) { }
RunLoop.main.add(timer!, forMode: .defaultRunLoopMode)
Timer.scheduledTimer(timeInterval: seconds, target: self, selector:
let timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector:
import Foundation struct Platform { static var isSimulator: Bool { return TARGET_OS_SIMULATOR != 0 } }
if Platform.isSimulator { print("Running on Simulator") }
extension UIDevice { var isSimulator: Bool { return true return false } }
extension UIDevice { static var isSimulator: Bool { return NSProcessInfo.processInfo().environment["SIMULATOR_DEVICE_NAME"] != nil } }
extension UIDevice { static var isSimulator: Bool { return ProcessInfo.processInfo.environment["SIMULATOR_DEVICE_NAME"] != nil } }
extension UIDevice { static var isSimulator: Bool { return UIDevice.currentDevice().model == "iPhone Simulator" } }
@interface UIDevice (Additions) - (BOOL)isSimulator; @end @implementation UIDevice (Additions) - (BOOL)isSimulator { if([[NSProcessInfo processInfo] isOperatingSystemAtLeastVersion:(NSOperatingSystemVersion){9, 0, 0}]) { return [NSProcessInfo processInfo].environment[@"SIMULATOR_DEVICE_NAME"] != nil; } else { return [[self model] isEqualToString:@"iPhone Simulator"]; } } @end
if let simModelCode = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] { print("yes is a simulator :\(simModelCode)") }
extension UIDevice { static var isSimulator: Bool = { var isSimulator = false isSimulator = true return isSimulator }() }
if UIDevice.isSimulator { print("running on simulator") }
class MyClass { var count = 0 } let mc = MyClass() mc.dynamicType === MyClass.self
class MyClass { var count = 0 required init() { } } let myClass2 = MyClass.self let mc2 = MyClass2()
let stringObject:String = "testing" let stringArrayObject:[String] = ["one", "two"] let viewObject = UIView() let anyObject:Any = "testing" let stringMirror = Mirror(reflecting: stringObject) let stringArrayMirror = Mirror(reflecting: stringArrayObject) let viewMirror = Mirror(reflecting: viewObject) let anyMirror = Mirror(reflecting: anyObject)
print(stringMirror.subjectType) print(stringArrayMirror.subjectType) print(viewMirror.subjectType) print(anyMirror.subjectType)
if anyMirror.subjectType == String.self { print("anyObject is a string!") } else { print("anyObject is not a string!") }
class Shape { class func className() -> String { return "Shape" } } class Square: Shape { override class func className() -> String { return "Square" } } class Circle: Shape { override class func className() -> String { return "Circle" } } func getShape() -> Shape { return Square() } let newShape: Shape = getShape() newShape is Square newShape is Circle newShape.dynamicType.className() newShape.dynamicType.className() == Square.className()
class MyObj: NSObject { init() { super.init() println("My class is \(self.className)") } } MyObj()
class MyClass { var count = 0 } let mc = MyClass() mc.dynamicType === MyClass.self
import Foundation class MyClass { } class SubClass: MyClass { } let mc = MyClass() let m2 = SubClass() String.fromCString(class_getName(m2.dynamicType)) String.fromCString(object_getClassName(m2)) String.fromCString(object_getClassName(mc))
var unknownTypeVariable = ‚Ä¶ if unknownTypeVariable is <ClassName> { } else { }
var unknownTypeVariable = ‚Ä¶ if let myClass = unknownTypeVariable as? <ClassName or ProtocolName> { } else { }
class Shape { } class Square: Shape { } class Circle: Shape { } var aShape = Shape() aShape = Square() if let thisShape = aShape as? Square { println("Its a square") } else { println("Its not a square") } if aShape.isKindOfClass(Square) { println("Its a square") } else { println("Its not a square") }
let dd2 = ["x" : 9, "y" : "home9"] let dds = dd2.filter { let eIndex = "x" let eValue:Any = 9 var r = false switch eValue { case let testString as String: r = $1 == testString case let testUInt as UInt: r = $1 == testUInt case let testInt as Int: r = $1 == testInt default: r = false } return r && $0 == eIndex }
import UIKit class A { class func a() { print("yeah") } func getInnerValue() { self.dynamicType.a() } } class B: A { override class func a() { print("yeah yeah") } } B.a() A.a() B().getInnerValue() A().getInnerValue()
override func viewDidLoad() { super.viewDidLoad() NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillShow:"), name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillHide:"), name: UIKeyboardWillHideNotification, object: nil) } func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { self.view.frame.origin.y -= keyboardSize.height } } func keyboardWillHide(notification: NSNotification) { self.view.frame.origin.y = 0 }
func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { if view.frame.origin.y == 0 { self.view.frame.origin.y -= keyboardSize.height } } } func keyboardWillHide(notification: NSNotification) { if view.frame.origin.y != 0 { self.view.frame.origin.y = 0 } }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y == 0 { self.view.frame.origin.y -= keyboardSize.height } } } @objc func keyboardWillHide(notification: NSNotification) { if self.view.frame.origin.y != 0 { self.view.frame.origin.y = 0 } }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y == 0 { self.view.frame.origin.y -= keyboardSize.height } } } @objc func keyboardWillHide(notification: NSNotification) { if self.view.frame.origin.y != 0 { self.view.frame.origin.y = 0 } }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y == 0 { self.view.frame.origin.y -= keyboardSize.height } } } @objc func keyboardWillHide(notification: NSNotification) { if self.view.frame.origin.y != 0 { self.view.frame.origin.y = 0 } }
func keyboardWillShow(sender: NSNotification) { self.view.frame.origin.y -= 150 } func keyboardWillHide(sender: NSNotification) { self.view.frame.origin.y += 150 }
@IBOutlet weak var messageField: UITextField! override func viewDidLoad() { super.viewDidLoad() NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillShow:"), name:UIKeyboardWillShowNotification, object: self.view.window) NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillHide:"), name:UIKeyboardWillHideNotification, object: self.view.window) } func keyboardWillHide(sender: NSNotification) { let userInfo: [NSObject : AnyObject] = sender.userInfo! let keyboardSize: CGSize = userInfo[UIKeyboardFrameBeginUserInfoKey]!.CGRectValue.size self.view.frame.origin.y += keyboardSize.height }
func keyboardWillShow(sender: NSNotification) { let userInfo: [NSObject : AnyObject] = sender.userInfo! let keyboardSize: CGSize = userInfo[UIKeyboardFrameBeginUserInfoKey]!.CGRectValue.size let offset: CGSize = userInfo[UIKeyboardFrameEndUserInfoKey]!.CGRectValue.size if keyboardSize.height == offset.height { UIView.animateWithDuration(0.1, animations: { () -> Void in self.view.frame.origin.y -= keyboardSize.height }) } else { UIView.animateWithDuration(0.1, animations: { () -> Void in self.view.frame.origin.y += keyboardSize.height - offset.height }) } }
override func viewWillDisappear(animated: Bool) { NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillShowNotification, object: self.view.window) NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillHideNotification, object: self.view.window) }
func keyboardWillShow(sender: NSNotification) { let userInfo: [NSObject : AnyObject] = sender.userInfo! let keyboardSize: CGSize = userInfo[UIKeyboardFrameBeginUserInfoKey]!.CGRectValue.size let offset: CGSize = userInfo[UIKeyboardFrameEndUserInfoKey]!.CGRectValue.size if keyboardSize.height == offset.height { if self.view.frame.origin.y == 0 { UIView.animateWithDuration(0.1, animations: { () -> Void in self.view.frame.origin.y -= keyboardSize.height }) } } else { UIView.animateWithDuration(0.1, animations: { () -> Void in self.view.frame.origin.y += keyboardSize.height - offset.height }) } print(self.view.frame.origin.y) }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWillShow(sender: NSNotification) { self.view.frame.origin.y -= 150 } @objc func keyboardWillHide(sender: NSNotification) { self.view.frame.origin.y += 150 }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } func keyboardWillHide() { self.view.frame.origin.y = 0 } func keyboardWillChange(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { if YOURTEXTVIEW.isFirstResponder { self.view.frame.origin.y = -keyboardSize.height } } }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillChangeFrameNotification, object: nil) NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillHideNotification, object: nil) }
@IBOutlet weak var bottomConstraint: NSLayoutConstraint! override func viewDidLoad() { super.viewDidLoad() NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillShow:"), name:UIKeyboardWillShowNotification, object: nil); NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillHide:"), name:UIKeyboardWillHideNotification, object: nil); } func keyboardWillShow(notification: NSNotification) { bottomConstraint.constant = 260 UIView.animateWithDuration(0.3) { self.view.layoutIfNeeded() } } func keyboardWillHide(notification: NSNotification) { bottomConstraint.constant = 175 UIView.animateWithDuration(0.3) { self.view.layoutIfNeeded() } }
var isKeyboardAppear = false override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWillShow(notification: NSNotification) { if !isKeyboardAppear { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y == 0{ self.view.frame.origin.y -= keyboardSize.height } } isKeyboardAppear = true } } @objc func keyboardWillHide(notification: NSNotification) { if isKeyboardAppear { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y != 0{ self.view.frame.origin.y += keyboardSize.height } } isKeyboardAppear = false } }
NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: @objc func keyboardWillShow(_ notification:Notification) { if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { self.view.frame.origin.y -= keyboardSize.height } } @objc func keyboardWillHide(_ notification:Notification) { if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { self.view.frame.origin.y += keyboardSize.height } }
func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { self.view.setTranslatesAutoresizingMaskIntoConstraints(true) self.view.frame = CGRectMake(self.view.frame.origin.x, self.view.frame.origin.y, self.view.frame.size.width, self.view.frame.height - keyboardSize.height) } } func keyboardWillHide(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { self.collectionView.setTranslatesAutoresizingMaskIntoConstraints(false) self.view.frame = CGRectMake(self.view.frame.origin.x, self.view.frame.origin.y, self.view.frame.size.width, self.view.frame.height + keyboardSize.height) } }
class SomeClassVC: UIViewController { override func viewDidLoad() { super.viewDidLoad() addKeyboardObservers() } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) removeKeyboardObservers() } override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { view.endEditing(true) } func addKeyboardObservers() { NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } func removeKeyboardObservers() { NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillShow, object: self.view.window) NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillHide, object: self.view.window) } func keyboardWillShow(notification: NSNotification) { let keyboardHeight = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.height UIView.animate(withDuration: 0.1, animations: { () -> Void in self.view.window?.frame.origin.y = -1 * keyboardHeight! self.view.layoutIfNeeded() }) } func keyboardWillHide(notification: NSNotification) { UIView.animate(withDuration: 0.1, animations: { () -> Void in self.view.window?.frame.origin.y = 0 self.view.layoutIfNeeded() }) } func resignTextFieldFirstResponders() { for textField in self.view.subviews where textField is UITextField { textField.resignFirstResponder() } } func resignAllFirstResponders() { view.endEditing(true) } }
class ViewController: UIViewController, UITextFieldDelegate { var textFieldRealYPosition: CGFloat = 0.0 override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { let distanceBetweenTextfielAndKeyboard = self.view.frame.height - textFieldRealYPosition - keyboardSize.height if distanceBetweenTextfielAndKeyboard < 0 { UIView.animate(withDuration: 0.4) { self.view.transform = CGAffineTransform(translationX: 0.0, y: distanceBetweenTextfielAndKeyboard) } } } } @objc func keyboardWillHide(notification: NSNotification) { UIView.animate(withDuration: 0.4) { self.view.transform = .identity } } func textFieldDidBeginEditing(_ textField: UITextField) { textFieldRealYPosition = textField.frame.origin.y + textField.frame.height }
func textFieldDidBeginEditing(_ textField: UITextField) { let myScreenRect: CGRect = UIScreen.main.bounds let keyboardHeight : CGFloat = 216 UIView.beginAnimations( "animateView", context: nil) var movementDuration:TimeInterval = 0.35 var needToMove: CGFloat = 0 var frame : CGRect = self.view.frame if (textField.frame.origin.y + textField.frame.size.height + UIApplication.shared.statusBarFrame.size.height > (myScreenRect.size.height - keyboardHeight - 30)) { needToMove = (textField.frame.origin.y + textField.frame.size.height + UIApplication.shared.statusBarFrame.size.height) - (myScreenRect.size.height - keyboardHeight - 30); } frame.origin.y = -needToMove self.view.frame = frame UIView.commitAnimations() } func textFieldDidEndEditing(_ textField: UITextField) { UIView.beginAnimations( "animateView", context: nil) var movementDuration:TimeInterval = 0.35 var frame : CGRect = self.view.frame frame.origin.y = 0 self.view.frame = frame UIView.commitAnimations() }
class MyViewController: UIViewController, UITextFieldDelegate { @IBOutlet weak var firstTextField: UITextField! @IBOutlet weak var secondTextField: UITextField! var activeTextField: UITextField! var viewWasMoved: Bool = false override func viewDidLoad() { super.viewDidLoad() NSNotificationCenter.defaultCenter().addObserver(self, selector: NSNotificationCenter.defaultCenter().addObserver(self, selector: } override func viewDidDisappear(animated: Bool) { super.viewWillDisappear(animated) NSNotificationCenter.defaultCenter().removeObserver(self) } func textFieldDidBeginEditing(textField: UITextField) { self.activeTextField = textField } func textFieldDidEndEditing(textField: UITextField) { self.activeTextField = nil } func textFieldShouldReturn(textField: UITextField) -> Bool { textField.resignFirstResponder() return true } func keyboardWillShow(notification: NSNotification) { let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() var aRect: CGRect = self.view.frame aRect.size.height -= keyboardSize!.height let activeTextFieldRect: CGRect? = activeTextField?.frame let activeTextFieldOrigin: CGPoint? = activeTextFieldRect?.origin if (!CGRectContainsPoint(aRect, activeTextFieldOrigin!)) { self.viewWasMoved = true self.view.frame.origin.y -= keyboardSize!.height } else { self.viewWasMoved = false } } func keyboardWillHide(notification: NSNotification) { if (self.viewWasMoved) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { self.view.frame.origin.y += keyboardSize.height } } }
NotificationCenter.default.addObserver(forName: .UIKeyboardWillShow, object: nil, queue: nil) { notification in self.keyboardWillShow(notification) } NotificationCenter.default.addObserver(forName: .UIKeyboardWillHide, object: nil, queue: nil) { notification in self.keyboardWillHide(notification) } NotificationCenter.default.addObserver(forName: .UIKeyboardDidShow, object: nil, queue: nil) { _ in self.enableUserInteraction() } NotificationCenter.default.addObserver(forName: .UIKeyboardDidHide, object: nil, queue: nil) { _ in self.enableUserInteraction() }
NotificationCenter.default.removeObserver(self, name: .UIKeyboardWillShow, object: nil) NotificationCenter.default.removeObserver(self, name: .UIKeyboardWillHide, object: nil) NotificationCenter.default.removeObserver(self, name: .UIKeyboardDidShow, object: nil) NotificationCenter.default.removeObserver(self, name: .UIKeyboardDidHide, object: nil)
func keyboardWillShow(notification: Notification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { UIApplication.shared.beginIgnoringInteractionEvents() self.view.frame.origin.y -= keyboardSize.height self.timelineCollectionView.contentInset.top += keyboardSize.height } } func keyboardWillHide(notification: Notification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { UIApplication.shared.beginIgnoringInteractionEvents() self.view.frame.origin.y += keyboardSize.height self.timelineCollectionView.contentInset.top -= keyboardSize.height } }
func enableUserInteraction() { UIApplication.shared.endIgnoringInteractionEvents() }
override func viewDidLoad() { super.viewDidLoad() NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillShow:"), name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillHide:"), name: UIKeyboardWillHideNotification, object: nil) } func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { self.view.frame.origin.y -= keyboardSize.height } } func keyboardWillHide(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { self.view.frame.origin.y += keyboardSize.height } }
func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { if view.frame.origin.y == 0{ self.view.frame.origin.y -= keyboardSize.height } } } func keyboardWillHide(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { if view.frame.origin.y != 0 { self.view.frame.origin.y += keyboardSize.height } } }
override func viewDidLoad() { super.viewDidLoad() self.hideKeyboardWhenTappedAround() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y == 0{ self.view.frame.origin.y -= keyboardSize.height } } } @objc func keyboardWillHide(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y != 0{ self.view.frame.origin.y = 0 } } }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } func keyboardWillShow(notification: NSNotification) { if ((notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue) != nil { var userInfo = notification.userInfo! var keyboardFrame:CGRect = (userInfo[UIKeyboardFrameEndUserInfoKey] as! NSValue).cgRectValue keyboardFrame = self.view.convert(keyboardFrame, from: nil) var contentInset:UIEdgeInsets = self.tbl.contentInset contentInset.bottom = keyboardFrame.size.height self.tbl.contentInset = contentInset } } func keyboardWillHide(notification: NSNotification) { if ((notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue) != nil { let contentInset:UIEdgeInsets = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0) self.tbl.contentInset = contentInset } }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector:
@objc func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y == 0{ self.view.frame.origin.y -= keyboardSize.height } }}
@objc func keyboardWillHide(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { if self.view.frame.origin.y != 0{ self.view.frame.origin.y = 0 } } }
class ViewController: UIViewController, UITextFieldDelegate {
@IBOutlet var stateAddress: UITextField! @IBOutlet var zipAddress: UITextField! @IBOutlet var phoneNumber: UITextField! @IBOutlet var vetEmailAddress: UITextField! @IBOutlet weak var scrollView: UIScrollView!
func textFieldShouldReturn(textField: UITextField) -> Bool { textField.resignFirstResponder() return true } func textFieldDidBeginEditing(textField: UITextField) { if (textField == self.stateAddress) { scrollView.setContentOffset(CGPointMake(0, 25), animated: true) } else if (textField == self.zipAddress) { scrollView.setContentOffset(CGPointMake(0, 57), animated: true) } else if (textField == self.phoneNumber) { scrollView.setContentOffset(CGPointMake(0, 112), animated: true) } else if (textField == self.vetEmailAddress) { scrollView.setContentOffset(CGPointMake(0, 142), animated: true) } } func textFieldDidEndEditing(textField: UITextField) { scrollView.setContentOffset(CGPointMake(0, 0), animated: true) }
import UIKit class NamVcc: UIViewController, UITextFieldDelegate { @IBOutlet weak var NamTxtBoxVid: UITextField! var VydTxtBoxVar: UITextField! var ChkKeyPadDspVar: Bool = false var KeyPadHytVal: CGFloat! override func viewDidLoad() { super.viewDidLoad() NamTxtBoxVid.delegate = self } override func viewWillAppear(animated: Bool) { NSNotificationCenter.defaultCenter().addObserver(self, selector: name:UIKeyboardWillShowNotification, object: nil); NSNotificationCenter.defaultCenter().addObserver(self, selector: name:UIKeyboardWillHideNotification, object: nil); } func textFieldDidBeginEditing(TxtBoxPsgVar: UITextField) { self.VydTxtBoxVar = TxtBoxPsgVar } func textFieldDidEndEditing(TxtBoxPsgVar: UITextField) { self.VydTxtBoxVar = nil } func textFieldShouldReturn(TxtBoxPsgVar: UITextField) -> Bool { self.VydTxtBoxVar.resignFirstResponder() return true } override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { view.endEditing(true) super.touchesBegan(touches, withEvent: event) } func TdoWenKeyPadVyd(NfnPsgVar: NSNotification) { if(!self.ChkKeyPadDspVar) { self.KeyPadHytVal = (NfnPsgVar.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue().height var NonKeyPadAraVar: CGRect = self.view.frame NonKeyPadAraVar.size.height -= self.KeyPadHytVal let VydTxtBoxCenVal: CGPoint? = VydTxtBoxVar?.frame.origin if (!CGRectContainsPoint(NonKeyPadAraVar, VydTxtBoxCenVal!)) { self.ChkKeyPadDspVar = true UIView.animateWithDuration(1.0, animations: { self.view.frame.origin.y -= (self.KeyPadHytVal)}, completion: nil) } else { self.ChkKeyPadDspVar = false } } } func TdoWenKeyPadHyd(NfnPsgVar: NSNotification) { if (self.ChkKeyPadDspVar) { self.ChkKeyPadDspVar = false UIView.animateWithDuration(1.0, animations: { self.view.frame.origin.y += (self.KeyPadHytVal)}, completion: nil) } } override func viewDidDisappear(animated: Bool) { super.viewWillDisappear(animated) NSNotificationCenter.defaultCenter().removeObserver(self) view.endEditing(true) ChkKeyPadDspVar = false } }
NonKeyPadAraVar.size.height -= self.KeyPadHytVal + 150 { self.view.frame.origin.y -= self.KeyPadHytVal - 150}, completion: nil) { self.view.frame.origin.y += self.KeyPadHytVal - 150}, completion: nil)
func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { self.view.frame.origin.y = self.view.frame.height - (self.view.frame.height + keyboardSize.height) } } func keyboardWillHide(notification: NSNotification) { self.view.frame.origin.y = 0 }
override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) NSNotificationCenter.defaultCenter().addObserver(self, selector: "keyboardWillShow:", name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: "keyboardWillHide:", name: UIKeyboardWillHideNotification, object: nil) } func keyboardWillShow(notification: NSNotification) { if let userInfo = notification.userInfo { if let keyboardSize = (userInfo[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { let contentInsets = self.tblView.contentInset as UIEdgeInsets self.tblView.contentInset = UIEdgeInsets(top: contentInsets.top, left: contentInsets.left, bottom: keyboardSize.height, right:contentInsets.right) } else { } } else { } } func keyboardWillHide(notification: NSNotification) { let contentInsets = self.tblView.contentInset as UIEdgeInsets self.tblView.contentInset = UIEdgeInsets(top: contentInsets.top, left: contentInsets.left, bottom: 0, right:contentInsets.right) }
func textFieldDidBeginEditing(textField: UITextField) { ViewUpanimateMoving(true, upValue: 100) } func textFieldDidEndEditing(textField: UITextField) { ViewUpanimateMoving(false, upValue: 100) } func ViewUpanimateMoving (up:Bool, upValue :CGFloat){ var durationMovement:NSTimeInterval = 0.3 var movement:CGFloat = ( up ? -upValue : upValue) UIView.beginAnimations( "animateView", context: nil) UIView.setAnimationBeginsFromCurrentState(true) UIView.setAnimationDuration(durationMovement) self.view.frame = CGRectOffset(self.view.frame, 0, movement) UIView.commitAnimations() }
func registerForKeyboardNotifications() { NSNotificationCenter.defaultCenter().addObserver(self, selector: NSNotificationCenter.defaultCenter().addObserver(self, selector: } func deregisterFromKeyboardNotifications(){ NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillHideNotification, object: nil) } func keyboardWasShown(notification: NSNotification){ let userInfo: NSDictionary = notification.userInfo! let keyboardInfoFrame = userInfo.objectForKey(UIKeyboardFrameEndUserInfoKey)?.CGRectValue() let windowFrame:CGRect = (UIApplication.sharedApplication().keyWindow!.convertRect(self.view.frame, fromView:self.view)) let keyboardFrame = CGRectIntersection(windowFrame, keyboardInfoFrame!) let coveredFrame = UIApplication.sharedApplication().keyWindow!.convertRect(keyboardFrame, toView:self.view) let contentInsets = UIEdgeInsetsMake(0, 0, (coveredFrame.size.height), 0.0) self.scrollViewInAddCase .contentInset = contentInsets; self.scrollViewInAddCase.scrollIndicatorInsets = contentInsets; self.scrollViewInAddCase.contentSize = CGSizeMake((self.scrollViewInAddCase.contentSize.width), (self.scrollViewInAddCase.contentSize.height)) } /** this method will fire when keyboard was hidden - parameter notification: contains keyboard details */ func keyboardWillBeHidden (notification: NSNotification) { self.scrollViewInAddCase.contentInset = UIEdgeInsetsZero self.scrollViewInAddCase.scrollIndicatorInsets = UIEdgeInsetsZero }
view.addConstraintWithFormat(format: "H:|[v0]|", views:Your_messageInputConteinerView) view.addConstraintWithFormat(format: "V:[v0(48)]", views:Your_messageInputConteinerView)
bottomConstraint = NSLayoutConstraint(item: Your_messageInputConteinerView, attribute: .bottom, relatedBy: .equal, toItem: view, attribute: .bottom, multiplier: 1, constant: 0) view.addConstraint(bottomConstraint!)
if let userInfo = notification.userInfo { if let keyBoardFrame = (userInfo[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue{ print(keyBoardFrame) if bottomConstraint?.constant != CGFloat(0) { bottomConstraint?.constant = 0 return } bottomConstraint?.constant = -keyBoardFrame.height or self.view.frame.origin.y = -keyBoardFrame.height } }
var activeField: UITextField? override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } func textFieldDidBeginEditing(_ textField: UITextField){ activeField = textField } func textFieldDidEndEditing(_ textField: UITextField){ activeField = nil } func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { if (self.activeField?.frame.origin.y)! >= keyboardSize.height { self.view.frame.origin.y = keyboardSize.height - (self.activeField?.frame.origin.y)! } else { self.view.frame.origin.y = 0 } } } func keyboardWillHide(notification: NSNotification) { self.view.frame.origin.y = 0 }
class ViewController: UIViewController, UITextFieldDelegate { @IBOutlet weak var titleField: UITextField! @IBOutlet weak var priceField: UITextField! @IBOutlet weak var detailsField: UTtextField! override func viewDidLoad() { super.viewDidLoad() priceField.delegate = self titleField.delegate = self detailsField.delegate = self NotificationCenter.default.addObserver(self, selector: name: NSNotification.Name.UIKeyboardWillShow, object: nil) NotificationCenter.default.addObserver(self, selector: name: NSNotification.Name.UIKeyboardWillHide, object: nil) } func textFieldShouldReturn(_ textField: UITextField) -> Bool { self.view.endEditing(true) return false } func keyboardWillShow(notification: NSNotification) { var translation:CGFloat = 0 if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { if detailsField.isEditing{ translation = CGFloat(-keyboardSize.height) }else if priceField.isEditing{ translation = CGFloat(-keyboardSize.height / 3.8) } } UIView.animate(withDuration: 0.2) { self.view.transform = CGAffineTransform(translationX: 0, y: translation) } } func keyboardWillHide(notification: NSNotification) { UIView.animate(withDuration: 0.2) { self.view.transform = CGAffineTransform(translationX: 0, y: 0) } } }
func textField(textField: UITextField!, shouldChangeCharactersInRange range: NSRange, replacementString string: String!) -> Bool { textField.text.stringByReplacingCharactersInRange(???, withString: string)
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let nsString = textField.text as NSString? let newString = nsString?.replacingCharacters(in: range, with: string) }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let nsString = textField.text as NSString? let newString = nsString?.stringByReplacingCharactersInRange(range, withString: string) }
let str = "aüëøbüá©üá™c" let r1 = str.range(of: "üá©üá™")! let n1 = NSRange(r1, in: str) print((str as NSString).substring(with: n1)) let r2 = Range(n1, in: str)! print(str[r2])
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { if let oldString = textField.text { let newString = oldString.replacingCharacters(in: Range(range, in: oldString)!, with: string) } }
init?(_ utf16Index: UTF16Index, within characters: String)
extension String { func rangeFromNSRange(nsRange : NSRange) -> Range<String.Index>? { let from16 = advance(utf16.startIndex, nsRange.location, utf16.endIndex) let to16 = advance(from16, nsRange.length, utf16.endIndex) if let from = String.Index(from16, within: self), let to = String.Index(to16, within: self) { return from ..< to } return nil } }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { if let swRange = textField.text.rangeFromNSRange(range) { let newString = textField.text.stringByReplacingCharactersInRange(swRange, withString: string) } return true }
extension String { func NSRangeFromRange(range : Range<String.Index>) -> NSRange { let utf16view = self.utf16 let from = String.UTF16View.Index(range.startIndex, within: utf16view) let to = String.UTF16View.Index(range.endIndex, within: utf16view) return NSMakeRange(from - utf16view.startIndex, to - from) } }
let str = "aüëøbüá©üá™c" let r1 = str.rangeOfString("üá©üá™")! let n1 = str.NSRangeFromRange(r1) println((str as NSString).substringWithRange(n1)) let r2 = str.rangeFromNSRange(n1)! println(str.substringWithRange(r2))
extension String { func rangeFromNSRange(nsRange : NSRange) -> Range<String.Index>? { let from16 = utf16.startIndex.advancedBy(nsRange.location, limit: utf16.endIndex) let to16 = from16.advancedBy(nsRange.length, limit: utf16.endIndex) if let from = String.Index(from16, within: self), let to = String.Index(to16, within: self) { return from ..< to } return nil } }
extension String { func NSRangeFromRange(range : Range<String.Index>) -> NSRange { let utf16view = self.utf16 let from = String.UTF16View.Index(range.startIndex, within: utf16view) let to = String.UTF16View.Index(range.endIndex, within: utf16view) return NSMakeRange(utf16view.startIndex.distanceTo(from), from.distanceTo(to)) } }
extension String { func nsRange(from range: Range<String.Index>) -> NSRange { let from = range.lowerBound.samePosition(in: utf16) let to = range.upperBound.samePosition(in: utf16) return NSRange(location: utf16.distance(from: utf16.startIndex, to: from), length: utf16.distance(from: from, to: to)) } } extension String { func range(from nsRange: NSRange) -> Range<String.Index>? { guard let from16 = utf16.index(utf16.startIndex, offsetBy: nsRange.location, limitedBy: utf16.endIndex), let to16 = utf16.index(utf16.startIndex, offsetBy: nsRange.location + nsRange.length, limitedBy: utf16.endIndex), let from = from16.samePosition(in: self), let to = to16.samePosition(in: self) else { return nil } return from ..< to } }
let str = "aüëøbüá©üá™c" let r1 = str.range(of: "üá©üá™")! let n1 = str.nsRange(from: r1) print((str as NSString).substring(with: n1)) let r2 = str.range(from: n1)! print(str.substring(with: r2))
var start = textField.text.startIndex var end = advance(textField.text.startIndex, 2) var range: Range<String.Index> = Range<String.Index>(start: start,end: end) textField.text.stringByReplacingCharactersInRange(range, withString: string)
extension String { func rangeFromNSRange(nsRange : NSRange) -> Range<String.Index>? { let from16 = utf16.startIndex.advancedBy(nsRange.location, limit: utf16.endIndex) let to16 = from16.advancedBy(nsRange.length, limit: utf16.endIndex) if let from = String.Index(from16, within: self), let to = String.Index(to16, within: self) { return from ..< to } return nil } }
extension String { func rangeFromNSRange(nsRange : NSRange) -> Range<String.Index>? { if let from16 = utf16.index(utf16.startIndex, offsetBy: nsRange.location, limitedBy: utf16.endIndex), let to16 = utf16.index(from16, offsetBy: nsRange.length, limitedBy: utf16.endIndex), let from = String.Index(from16, within: self), let to = String.Index(to16, within: self) { return from ..< to } return nil } }
extension String { func rangeFromNSRange(nsRange : NSRange) -> Range<String.Index>? { return Range(nsRange, in: self) } }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let start = advance(textField.text.startIndex, range.location) let end = advance(start, range.length) let swiftRange = Range<String.Index>(start: start, end: end) ... }
var original = "üá™üá∏üòÇThis is a test" var replacement = "!" var startIndex = advance(original.startIndex, 1) var endIndex = advance(startIndex, 2) var range = Range(start:startIndex, end:endIndex) var final = original.stringByReplacingCharactersInRange(range, withString:replacement) println("start index: \(startIndex)") println("end index: \(endIndex)") println("range: \(range)") println("original: \(original)") println("final: \(final)")
start index: 4 end index: 7 range: 4..<7 original: üá™üá∏üòÇThis is a test final: üá™üá∏!his is a test
func replaceString( var startIndex = advance(original.startIndex, start) var endIndex = advance(startIndex, length) var range = Range(start:startIndex, end:endIndex) var final = original.stringByReplacingCharactersInRange(range, withString: replacement) return final } var newString = replaceString(string:original, with:replacement, start:1, length:2) println("newString:\(newString)")
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let strString = ((textField.text)! as NSString).stringByReplacingCharactersInRange(range, withString: string) }
var oldString = textfield.text! let newRange = oldString.startIndex.advancedBy(range.location)..<oldString.startIndex.advancedBy(range.location + range.length) let newString = oldString.stringByReplacingCharactersInRange(newRange, withString: string)
extension String { public func convertRangeFromNSRange(r:NSRange) -> Range<String.Index> { let a = (self as NSString).substringToIndex(r.location) let b = (self as NSString).substringWithRange(r) let n1 = distance(a.startIndex, a.endIndex) let n2 = distance(b.startIndex, b.endIndex) let i1 = advance(startIndex, n1) let i2 = advance(i1, n2) return Range<String.Index>(start: i1, end: i2) } } let s = "üá™üá∏üòÇ" println(s[s.convertRangeFromNSRange(NSRange(location: 4, length: 2))]) println(s[s.convertRangeFromNSRange(NSRange(location: 0, length: 4))]) println(s[s.convertRangeFromNSRange(NSRange(location: 0, length: 2))]) println(s[s.convertRangeFromNSRange(NSRange(location: 0, length: 1))])
extension String { public func convertRangeToNSRange(r:Range<String.Index>) -> NSRange { let a = substringToIndex(r.startIndex) let b = substringWithRange(r) return NSRange(location: a.utf16Count, length: b.utf16Count) } } println(convertRangeToNSRange(s.startIndex..<s.endIndex)) println(convertRangeToNSRange(s.startIndex.successor()..<s.endIndex))
extension NSRange { func stringRangeForText(string: String) -> Range<String.Index> { let start = string.startIndex.advancedBy(self.location) let end = start.advancedBy(self.length) return Range<String.Index>(start: start, end: end) } }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let range = range.stringRangeForText(textField.text) let output = textField.text.stringByReplacingCharactersInRange(range, withString: string) return true }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let value = textField.text else {return false} let valueAfterChange = (value as NSString).replacingCharacters(in: range, with: string) return true }
extension StringProtocol where Index == String.Index { func nsRange(of string: String) -> NSRange? { guard let range = self.range(of: string) else { return nil } return NSRange(range, in: self) } }
func doNothing(int: Int, bool: Bool = false) throws -> String { if unlucky { throw Error.BadLuck } return "Totally contrived." }
$ [sudo] gem install jazzy $ jazzy Running xcodebuild Parsing ... building site jam out ‚ô™‚ô´ to your fresh new docs in `docs`
class Foo { func doThing(name : String) -> String { return "Did the \(name) thing"; } }
var a = [1, 2, 3] var b = a b.unshare() a[1] = 42 a b
var e = [1, 2, 3] var f = e e[0..2] = [4, 5] e f var e1 = [1, 2, 3] var f1 = e1 e1[0] = 4 e1[1] = 5 e1 f1
let date = Date() let calendar = Calendar.current let hour = calendar.component(.hour, from: date) let minutes = calendar.component(.minute, from: date)
let date = NSDate() let calendar = NSCalendar.currentCalendar() let components = calendar.components(.CalendarUnitHour | .CalendarUnitMinute, fromDate: date) let hour = components.hour let minutes = components.minute
let someOtherDateTime = Date(timeIntervalSinceReferenceDate: -123456789.0)
var dateComponents = DateComponents() dateComponents.year = 1980 dateComponents.month = 7 dateComponents.day = 11 dateComponents.timeZone = TimeZone(abbreviation: "JST") dateComponents.hour = 8 dateComponents.minute = 34 let userCalendar = Calendar.current let someDateTime = userCalendar.date(from: dateComponents)
let formatter = DateFormatter() formatter.dateFormat = "yyyy/MM/dd HH:mm" let someDateTime = formatter.date(from: "2016/10/08 22:31")
let currentDateTime = Date() let userCalendar = Calendar.current let requestedComponents: Set<Calendar.Component> = [ .year, .month, .day, .hour, .minute, .second ] let dateTimeComponents = userCalendar.dateComponents(requestedComponents, from: currentDateTime) dateTimeComponents.year dateTimeComponents.month dateTimeComponents.day dateTimeComponents.hour dateTimeComponents.minute dateTimeComponents.second
let currentDateTime = Date() let formatter = DateFormatter() formatter.timeStyle = .medium formatter.dateStyle = .long formatter.string(from: currentDateTime)
formatter.timeStyle = .short formatter.dateStyle = .short formatter.string(from: currentDateTime) formatter.timeStyle = .medium formatter.dateStyle = .medium formatter.string(from: currentDateTime) formatter.timeStyle = .long formatter.dateStyle = .long formatter.string(from: currentDateTime) formatter.timeStyle = .none formatter.dateStyle = .long formatter.string(from: currentDateTime) formatter.timeStyle = .medium formatter.dateStyle = .none formatter.string(from: currentDateTime)
func printTimestamp() { let timestamp = NSDateFormatter.localizedStringFromDate(NSDate(), dateStyle: .MediumStyle, timeStyle: .ShortStyle) print(timestamp) } printTimestamp()
extension NSDate { func hour() -> Int { let calendar = NSCalendar.currentCalendar() let components = calendar.components(.Hour, fromDate: self) let hour = components.hour return hour } func minute() -> Int { let calendar = NSCalendar.currentCalendar() let components = calendar.components(.Minute, fromDate: self) let minute = components.minute return minute } func toShortTimeString() -> String { let formatter = NSDateFormatter() formatter.timeStyle = .ShortStyle let timeString = formatter.stringFromDate(self) return timeString } }
let currentDate = NSDate() NSLog("(Current Hour = \(currentDate.hour())) (Current Minute = \(currentDate.minute())) (Current Short Time String = \(currentDate.toShortTimeString()))")
let date = NSDate() let calendar = NSCalendar.currentCalendar() let components = calendar.components([.Hour, .Minute], fromDate: date) let hour = components.hour let minutes = components.minute
let dateFormatter : DateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MMM-dd HH:mm:ss" let date = Date() let dateString = dateFormatter.string(from: date) let interval = date.timeIntervalSince1970
static func currentTime() -> String { let date = Date() let calendar = Calendar.current let hour = calendar.component(.hour, from: date) let minutes = calendar.component(.minute, from: date) return "\(hour):\(minutes)" }
let calendar = NSCalendar.currentCalendar() var hour = calendar.component(.Hour,fromDate: NSDate())
func dateComponents(_ components: Set<Calendar.Component>, from date: Date) -> DateComponents
import Foundation let date = Date() let dateComponents = Calendar.current.dateComponents([.hour], from: date) let hour = dateComponents.hour print(String(describing: hour))
func component(_ component: Calendar.Component, from date: Date) -> Int
import Foundation let date = Date() let hour = Calendar.current.component(.hour, from: date) print(hour)
import Foundation let date = Date() let dateFormatter = DateFormatter() dateFormatter.dateFormat = "HH" let hour = dateFormatter.string(from: date) print(hour)
func setLocalizedDateFormatFromTemplate(_ dateFormatTemplate: String)
import Foundation let date = Date() let dateFormatter = DateFormatter() dateFormatter.setLocalizedDateFormatFromTemplate("HH") let hour = dateFormatter.string(from: date) print(hour)
let date = Date() let calendar = Calendar.current() let hour = calendar.component(.hour, from: date)
let dateFormatter = DateFormatter() dateFormatter.dateStyle = .medium let dateString = "Current date is: \(dateFormatter.string(from: Date() as Date))" labelfordate.text = String(dateString) let timeFormatter = DateFormatter() timeFormatter.timeStyle = .medium let timeString = "Current time is: \(timeFormatter.string(from: Date() as Date))" labelfortime.text = String(timeString)
override func viewDidLoad() { super.viewDidLoad() timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: } func action() { let dateFormatter = DateFormatter() dateFormatter.dateStyle = .medium let dateString = "Current date is: \(dateFormatter.string(from: Date() as Date))" labelfordate.text = String(dateString) let timeFormatter = DateFormatter() timeFormatter.timeStyle = .medium let timeString = "Current time is: \(timeFormatter.string(from: Date() as Date))" labelfortime.text = String(timeString) }
extension String { init(epoch: Double) { let date = Date(timeIntervalSince1970: epoch) let dateFormatter = DateFormatter() dateFormatter.dateFormat = "dd/MM/yyyy HH:mm:ssZZZ" self = dateFormatter.string(from: date) } }
func getTime() -> (hour:Int, min:Int, sec:Int) { let currentDateTime = NSDate() let calendar = NSCalendar.currentCalendar() let components = calendar.components([.Hour,.Minute,.Second], fromDate: currentDateTime) let hour = components.hour let min = components.minute let sec = components.second return (hour,min,sec) }
let currentTime = self.getTime() print("Hour: \(currentTime.hour) Min: \(currentTime.min) Sec: \(currentTime.sec))")
let dateFormatter1 = NSDateFormatter() dateFormatter1.dateStyle = .MediumStyle dateFormatter1.timeStyle = .NoStyle dateFormatter1.dateFormat = "dd-MM-yyyy" let date = dateFormatter1.stringFromDate(NSDate())
extension Date { var hour: Int { return Calendar.autoupdatingCurrent.component(.hour, from: self) } }
extension Date { var formatter: DateFormatter? { let formatter = DateFormatter() formatter.dateStyle = .short formatter.timeStyle = .short formatter.doesRelativeDateFormatting = true return formatter } }
let dateFormatter = DateFormatter() dateFormatter.dateFormat = "dd/MM/yyyy" let dateString = dateFormatter.string(from:Date()) print(dateString)
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) { let image = self.loadOrGenerateAnImage() dispatch_async(dispatch_get_main_queue()) { self.imageView.image = image } }
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(0.5 * Double(NSEC_PER_SEC))), dispatch_get_main_queue()) { print("test") }
DispatchQueue.global(qos: .userInitiated).async { let image = self.loadOrGenerateAnImage() DispatchQueue.main.async { self.imageView.image = image } }
class Foo { let queue = DispatchQueue(label: "com.example.my-serial-queue", attributes: [.serial, .qosUtility]) func doStuff() { queue.async { print("Hello World") } } }
DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { print("Are we there yet?") }
DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { print("Are we there yet?") }
DispatchQueue.main.async { print("Async1") } DispatchQueue.main.async( execute: { print("Async2") })
DispatchQueue.global(qos: .background).async { DispatchQueue.main.async { } }
DispatchQueue.global(qos: .userInitiated).async { }
let main = DispatchQueue.main let background = DispatchQueue.global() let helper = DispatchQueue(label: "another_thread")
class Threads { static let concurrentQueue = DispatchQueue(label: "AppNameConcurrentQueue", attributes: .concurrent) static let serialQueue = DispatchQueue(label: "AppNameSerialQueue") class func performTaskInMainQueue(task: @escaping ()->()) { DispatchQueue.main.async { task() } } class func performTaskInBackground(task:@escaping () throws -> ()) { DispatchQueue.global(qos: .background).async { do { try task() } catch let error as NSError { print("error in background thread:\(error.localizedDescription)") } } } class func perfromTaskInConcurrentQueue(task:@escaping () throws -> ()) { concurrentQueue.async { do { try task() } catch let error as NSError { print("error in Concurrent Queue:\(error.localizedDescription)") } } } class func perfromTaskInSerialQueue(task:@escaping () throws -> ()) { serialQueue.async { do { try task() } catch let error as NSError { print("error in Serial Queue:\(error.localizedDescription)") } } } class func performTaskAfterDealy(_ timeInteval: TimeInterval, _ task:@escaping () -> ()) { DispatchQueue.main.asyncAfter(deadline: (.now() + timeInteval)) { task() } } }
override func viewDidLoad() { super.viewDidLoad() Threads.performTaskInMainQueue { self.tblViewSignUP.reloadData() } }
class Person { let name: String init(name: String) { self.name = name } var apartment: Apartment? } class Apartment { let number: Int init(number: Int) { self.number = number } weak var tenant: Person? }
Person ===(strong)==> Apartment Person <==(weak)===== Apartment
class Customer { let name: String var card: CreditCard? init(name: String) { self.name = name } } class CreditCard { let number: UInt64 unowned let customer: Customer init(number: UInt64, customer: Customer) { self.number = number; self.customer = customer } }
Customer ===(strong)==> CreditCard Customer <==(unowned)== CreditCard
class Customer { var card: CreditCard? } class CreditCard { unowned let customer: Customer }
class Person { var card: CreditCard? } class CreditCard { unowned let holder: Person init (holder: Person) { self.holder = holder } }
class MyViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let myButton = MyButton { [unowned self] in print("At this point, self can NEVER be nil. You are safe to use unowned.") print("This is because myButton can not be referenced without/outside this instance (myViewController)") } } } class MyButton: UIButton { var clicked: (() -> ()) init(clicked: (() -> ())) { self.clicked = clicked super.init(frame: .zero) addTarget(self, action: } @objc private func sendClosure() { clicked() } }
class MyViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() NetworkManager.sharedInstance.receivedData = { [weak self] (data) in print("Can you guarentee that self is always available when the network manager received data?") print("Nope, you can print("You should use weak self here, since you are not sure if this instance is still alive for every") print("future callback of network manager") } } } class NetworkManager { static let sharedInstance = NetworkManager() var receivedData: ((Data) -> ())? private func process(_ data: Data) { receivedData?(data) } }
var text:String = "This is some text over multiple lines"
var text = "This is some text\n" + "over multiple lines\n"
extension String { init(sep:String, _ lines:String...){ self = "" for (idx, item) in lines.enumerated() { self += "\(item)" if idx < lines.count-1 { self += sep } } } init(_ lines:String...){ self = "" for (idx, item) in lines.enumerated() { self += "\(item)" if idx < lines.count-1 { self += "\n" } } } } print( String( "Hello", "World!" ) ) "Hello World!" print( String(sep:", ", "Hello", "World!" ) ) "Hello, World!"
const char* text = "This is some text\n" "over multiple lines";
var text:String = "This is some text \n" + "over multiple lines"
var text = ["This is some text ", "over multiple lines"].reduce("", +)
var text = "".join(["This is some text ", "over multiple lines"])
let longString = """ When you write a string that spans multiple lines make sure you start its content on a line all of its own, and end it with three quotes also on a line of their own. Multi-line strings also let you write "quote marks" freely inside your strings, which is great! """
let multiLineStringLiteral = print(multiLineStringLiteral)
var text:String = "This is some text \n" + "over multiple lines"
. . . return String(format:"\n" + (" part1: %d\n" + " part2: %d\n" + " part3: \"%@\"\n" + " part4: \"%@\"\n" + " part5: \"%@\"\n" + " part6: \"%@\"\n") + (" part7: \"%@\"\n" + " part8: \"%@\"\n" + " part9: \"%@\"\n" + " part10: \"%@\"\n" + " part12: \"%@\"\n") + " part13: %f\n" + " part14: %f\n\n", part1, part2, part3, part4, part5, part6, part7, part8, part9, part10, part11, part12, part13, part14) . . .
var textFieldData:String = "John" myTextField.text = NSString(format: "Hello User, \n %@",textFieldData) as String myTextField.numberOfLines = 0
var yourString = "first line \n second line \n third line"
var text:String = "This is some text<br />over multiple lines" label.attributedText = text
import UIKit import PlaygroundSupport class MyViewController : UIViewController { override func loadView() { let str = String(charsPerLine: 5, "Hello World!") print(str) } } extension String { init(charsPerLine:Int, _ str:String){ self = "" var idx = 0 for char in str { self += "\(char)" idx = idx + 1 if idx == charsPerLine { self += "\n" idx = 0 } } } }
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [super touchesBegan:touches withEvent:event]; UITouch *touch = [touches anyObject]; if ([touch.view isKindOfClass: UIPickerView.class]) { } }
override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { ??? if ??? { } }
override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { super.touchesBegan(touches, withEvent: event) let touch : UITouch = touches.anyObject() as UITouch if touch.view.isKindOfClass(UIPickerView) { } }
let touch = object.anyObject() as UITouch if let picker = touch.view as? UIPickerView { ... }
override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { super.touchesBegan(touches, withEvent: event) let touch : UITouch = touches.anyObject() as UITouch if let touchView = touch.view as? UIPickerView { } }
guard let touch = object.AnyObject() as? UITouch, let picker = touch.view as? UIPickerView else { return }
let items : [Any] = ["Hello", "World"] for obj in items { if let str = obj as? String { } else { } }
class Shape {} class Circle : Shape {} class Rectangle : Shape {} func area (shape: Shape) -> Double { if shape is Circle { ... } else if shape is Rectangle { ... } }
21> func test (obj:Any) -> String { 22. if obj is Int { return "Int" } 23. else if obj is String { return "String" } 24. else { return "Any" } 25. } ... 30> test (1) $R16: String = "Int" 31> test ("abc") $R17: String = "String" 32> test (nil) $R18: String = "Any"
let filteredArray = originalArray.filter({ $0 is Array })
class Shape { } class Square: Shape { } class Circle: Shape { } var aShape = Shape() aShape = Square() if let thisShape = aShape as? Square { println("Its a square") } else { println("Its not a square") } if aShape.isKindOfClass(Square) { println("Its a square") } else { println("Its not a square") }
let myShape = Shape() if myShape is Shape { print("yes it is") }
let myArray: [Any] = ["easy", "as", "that"] let type = type(of: myArray) Result: "Array<Any>"
var string = "Hello" as NSString var obj1:AnyObject = string var obj2:NSObject = string print(obj1 is NSString) print(obj2 is NSString) print(obj1 is String) print(obj2 is String)
myObject.isKind(of: MyClass.self)) myObject.isMember(of: MyClass.self))
if (yourObject as? ClassToCompareWith) != nil { } else { }
fileprivate enum types { case typeString case typeInt case typeDouble case typeUnknown } fileprivate func typeOfAny(variable: Any) -> types { if variable is String {return types.typeString} if variable is Int {return types.typeInt} if variable is Double {return types.typeDouble} return types.typeUnknown }
class Shape {} class Circle : Shape {} class Rectangle : Shape {} if aShape.isKind(of: Circle.self) { }
{ "registeration_method": "email", "is_stucked": true, "individual": { "id": 24099, "first_name": "ahmad", "last_name": "zozoz", "email": null, "mobile_number": null, "confirmed": false, "avatar": "http: "doctor_request_status": 0 }, "max_number_of_confirmation_trials": 4, "max_number_of_invalid_confirmation_trials": 12 }
if let isStucked = response["is_stucked"] as? Bool{ if isStucked{ print("is Stucked") } else{ print("Not Stucked") } }
if let _ = dict[key] { return true } else { return false } for (_, value) in dict { return value }
extension Dictionary { func keyedOrFirstValue(key: Key) -> Value? { return self[key] ?? first(self.values) } } let d = ["one":"red", "two":"blue"] d.keyedOrFirstValue("one") d.keyedOrFirstValue("two") d.keyedOrFirstValue("three")
public static var attributedMessageTextCache = [String: NSAttributedString?]() if attributedMessageTextCache.index(forKey: "key") != nil { if let attributedMessageText = TextChatCache.attributedMessageTextCache["key"] { return attributedMessageText } return nil } TextChatCache.attributedMessageTextCache["key"] = .some(.none) return nil
let serialQueue = DispatchQueue(label: "com.test.mySerialQueue") serialQueue.sync { }
func synced(_ lock: Any, closure: () -> ()) { objc_sync_enter(lock) closure() objc_sync_exit(lock) }
synced(self) { println("This is a synchronized closure") }
Bitcast requires both operands to be pointer or neither %26 = bitcast i64 %25 to %objc_object*, !dbg !378 LLVM ERROR: Broken function found, compilation aborted!
{ objc_sync_enter(lock) defer { objc_sync_exit(lock) } // // }
objc_sync_enter(self) ... synchronized code ... objc_sync_exit(self)
func synchronized<T>(_ lock: AnyObject, _ body: () throws -> T) rethrows -> T { objc_sync_enter(lock) defer { objc_sync_exit(lock) } return try body() }
func synchronized<T>(lock: AnyObject, @noescape _ body: () throws -> T) rethrows -> T { objc_sync_enter(lock) defer { objc_sync_exit(lock) } return try body() }
class MyObject { private var internalState: Int = 0 private let internalQueue: DispatchQueue = DispatchQueue(label:"LockingQueue") var state: Int { get { return internalQueue.sync { internalState } } set (newState) { internalQueue.sync { internalState = newState } } } }
func synchronized( lock:AnyObject, block:() throws -> Void ) rethrows { objc_sync_enter(lock) defer { objc_sync_exit(lock) } try block() }
func synchronize<T>(lockObj: AnyObject!, closure: ()->T) -> T { objc_sync_enter(lockObj) var retVal: T = closure() objc_sync_exit(lockObj) return retVal }
func importantMethod(...) -> Bool { return synchronize(self) { if(feelLikeReturningTrue) { return true } if(feelLikeReturningTrueNow) { return true } return whatIFeelLike ? true : false } }
let internalQueue = DispatchQueue(label: "serialQueue") let semaphore = DispatchSemaphore(value: 1) internalQueue.async { self.semaphore.wait() someAsyncFunc() { self.semaphore.signal() } }
let lock = NSLock() lock.lock() if isRunning == true { print("Service IS running ==> please wait") return } else { print("Service not running") } isRunning = true lock.unlock()
class ImageCache { private let queue = DispatchQueue(label: "com.company.name.cache") private var storage: [String: UIImage] = [:] public subscript(key: String) -> UIImage? { get { return queue.sync { return storage[key] } } set { queue.sync { storage[key] = newValue } } } }
extension NSObject { func synchronized<T>(lockObj: AnyObject!, closure: () throws -> T) rethrows -> T { objc_sync_enter(lockObj) defer { objc_sync_exit(lockObj) } return try closure() } }
class Foo: NSObject { func test() { print("1") objc_sync_enter(self) defer { objc_sync_exit(self) print("3") } print("2") } } class Foo2: Foo { override func test() { super.test() print("11") objc_sync_enter(self) defer { print("33") objc_sync_exit(self) } print("22") } } let test = Foo2() test.test()
class AsyncObject<T>:CustomStringConvertible { private var _value: T public private(set) var dispatchQueueName: String let dispatchQueue: DispatchQueue init (value: T, dispatchQueueName: String) { _value = value self.dispatchQueueName = dispatchQueueName dispatchQueue = DispatchQueue(label: dispatchQueueName) } func setValue(with closure: @escaping (_ currentValue: T)->(T) ) { dispatchQueue.sync { [weak self] in if let _self = self { _self._value = closure(_self._value) } } } func getValue(with closure: @escaping (_ currentValue: T)->() ) { dispatchQueue.sync { [weak self] in if let _self = self { closure(_self._value) } } } var value: T { get { return dispatchQueue.sync { _value } } set (newValue) { dispatchQueue.sync { _value = newValue } } } var description: String { return "\(_value)" } }
print("Single read/write action") let obj = AsyncObject<Int>(value: 0, dispatchQueueName: "Dispatch0") obj.value = 100 let x = obj.value print(x) print("Write action in block") obj.setValue{ (current) -> (Int) in let newValue = current*2 print("previous: \(current), new: \(newValue)") return newValue }
extension DispatchGroup { class func loop(repeatNumber: Int, action: @escaping (_ index: Int)->(), completion: @escaping ()->()) { let group = DispatchGroup() for index in 0...repeatNumber { group.enter() DispatchQueue.global(qos: .utility).async { action(index) group.leave() } } group.notify(queue: DispatchQueue.global(qos: .userInitiated)) { completion() } } }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() sample2() } func sample1() { print("=================================================\nsample with variable") let obj = AsyncObject<Int>(value: 0, dispatchQueueName: "Dispatch1") DispatchGroup.loop(repeatNumber: 5, action: { index in obj.value = index }) { print("\(obj.value)") } } func sample2() { print("\n=================================================\nsample with array") let arr = AsyncObject<[Int]>(value: [], dispatchQueueName: "Dispatch2") DispatchGroup.loop(repeatNumber: 15, action: { index in arr.setValue{ (current) -> ([Int]) in var array = current array.append(index*index) print("index: \(index), value \(array[array.count-1])") return array } }) { print("\(arr.value)") } } }
class Lockable { let lockableQ:dispatch_queue_t init() { lockableQ = dispatch_queue_create("com.blah.blah.\(self.dynamicType)", DISPATCH_QUEUE_SERIAL) } func lock(closure: () -> ()) { dispatch_sync(lockableQ, closure) } } class Foo: Lockable { func boo() { lock { ....... do something } }
import Foundation import SystemConfiguration public class Reachability { class func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(sizeofValue(zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) let defaultRouteReachability = withUnsafePointer(&zeroAddress) { SCNetworkReachabilityCreateWithAddress(nil, UnsafePointer($0)) } var flags: SCNetworkReachabilityFlags = 0 if SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) == 0 { return false } let isReachable = (flags & UInt32(kSCNetworkFlagsReachable)) != 0 let needsConnection = (flags & UInt32(kSCNetworkFlagsConnectionRequired)) != 0 return (isReachable && !needsConnection) ? true : false } }
import Foundation import SystemConfiguration class Reachability { var hostname: String? var isRunning = false var isReachableOnWWAN: Bool var reachability: SCNetworkReachability? var reachabilityFlags = SCNetworkReachabilityFlags() let reachabilitySerialQueue = DispatchQueue(label: "ReachabilityQueue") init?(hostname: String) throws { guard let reachability = SCNetworkReachabilityCreateWithName(nil, hostname) else { throw Network.Error.failedToCreateWith(hostname) } self.reachability = reachability self.hostname = hostname isReachableOnWWAN = true } init?() throws { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(MemoryLayout<sockaddr_in>.size) zeroAddress.sin_family = sa_family_t(AF_INET) guard let reachability = withUnsafePointer(to: &zeroAddress, { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) { SCNetworkReachabilityCreateWithAddress(nil, $0) }}) else { throw Network.Error.failedToInitializeWith(zeroAddress) } self.reachability = reachability isReachableOnWWAN = true } var status: Network.Status { return !isConnectedToNetwork ? .unreachable : isReachableViaWiFi ? .wifi : isRunningOnDevice ? .wwan : .unreachable } var isRunningOnDevice: Bool = { return false return true }() deinit { stop() } } extension Reachability { func start() throws { guard let reachability = reachability, !isRunning else { return } var context = SCNetworkReachabilityContext(version: 0, info: nil, retain: nil, release: nil, copyDescription: nil) context.info = Unmanaged<Reachability>.passUnretained(self).toOpaque() guard SCNetworkReachabilitySetCallback(reachability, callout, &context) else { stop() throw Network.Error.failedToSetCallout } guard SCNetworkReachabilitySetDispatchQueue(reachability, reachabilitySerialQueue) else { stop() throw Network.Error.failedToSetDispatchQueue } reachabilitySerialQueue.async { self.flagsChanged() } isRunning = true } func stop() { defer { isRunning = false } guard let reachability = reachability else { return } SCNetworkReachabilitySetCallback(reachability, nil, nil) SCNetworkReachabilitySetDispatchQueue(reachability, nil) self.reachability = nil } var isConnectedToNetwork: Bool { return isReachable && !isConnectionRequiredAndTransientConnection && !(isRunningOnDevice && isWWAN && !isReachableOnWWAN) } var isReachableViaWiFi: Bool { return isReachable && isRunningOnDevice && !isWWAN } var flags: SCNetworkReachabilityFlags? { guard let reachability = reachability else { return nil } var flags = SCNetworkReachabilityFlags() return withUnsafeMutablePointer(to: &flags) { SCNetworkReachabilityGetFlags(reachability, UnsafeMutablePointer($0)) } ? flags : nil } func flagsChanged() { guard let flags = flags, flags != reachabilityFlags else { return } reachabilityFlags = flags NotificationCenter.default.post(name: .flagsChanged, object: self) } var transientConnection: Bool { return flags?.contains(.transientConnection) == true } var isReachable: Bool { return flags?.contains(.reachable) == true } var connectionRequired: Bool { return flags?.contains(.connectionRequired) == true } var connectionOnTraffic: Bool { return flags?.contains(.connectionOnTraffic) == true } var interventionRequired: Bool { return flags?.contains(.interventionRequired) == true } var connectionOnDemand: Bool { return flags?.contains(.connectionOnDemand) == true } var isLocalAddress: Bool { return flags?.contains(.isLocalAddress) == true } var isDirect: Bool { return flags?.contains(.isDirect) == true } var isWWAN: Bool { return flags?.contains(.isWWAN) == true } var isConnectionRequiredAndTransientConnection: Bool { return (flags?.intersection([.connectionRequired, .transientConnection]) == [.connectionRequired, .transientConnection]) == true } } func callout(reachability: SCNetworkReachability, flags: SCNetworkReachabilityFlags, info: UnsafeMutableRawPointer?) { guard let info = info else { return } DispatchQueue.main.async { Unmanaged<Reachability>.fromOpaque(info).takeUnretainedValue().flagsChanged() } } extension Notification.Name { static let flagsChanged = Notification.Name("FlagsChanged") } struct Network { static var reachability: Reachability? enum Status: String, CustomStringConvertible { case unreachable, wifi, wwan var description: String { return rawValue } } enum Error: Swift.Error { case failedToSetCallout case failedToSetDispatchQueue case failedToCreateWith(String) case failedToInitializeWith(sockaddr_in) } }
do { Network.reachability = try Reachability(hostname: "www.google.com") do { try Network.reachability?.start() } catch let error as Network.Error { print(error) } catch { print(error) } } catch { print(error) }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: updateUserInterface() } func updateUserInterface() { guard let status = Network.reachability?.status else { return } switch status { case .unreachable: view.backgroundColor = .red case .wifi: view.backgroundColor = .green case .wwan: view.backgroundColor = .yellow } print("Reachability Summary") print("Status:", status) print("HostName:", Network.reachability?.hostname ?? "nil") print("Reachable:", Network.reachability?.isReachable ?? "nil") print("Wifi:", Network.reachability?.isReachableViaWiFi ?? "nil") } func statusManager(_ notification: Notification) { updateUserInterface() } }
import SystemConfiguration public class Reachability { class func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in(sin_len: 0, sin_family: 0, sin_port: 0, sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0)) zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) let defaultRouteReachability = withUnsafePointer(to: &zeroAddress) { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {zeroSockAddress in SCNetworkReachabilityCreateWithAddress(nil, zeroSockAddress) } } var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags(rawValue: 0) if SCNetworkReachabilityGetFlags(defaultRouteReachability!, &flags) == false { return false } let isReachable = (flags.rawValue & UInt32(kSCNetworkFlagsReachable)) != 0 let needsConnection = (flags.rawValue & UInt32(kSCNetworkFlagsConnectionRequired)) != 0 let ret = (isReachable && !needsConnection) return ret } }
if Reachability.isConnectedToNetwork(){ print("Internet Connection Available!") }else{ print("Internet Connection not Available!") }
import Foundation import SystemConfiguration public class Reachability { class func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in(sin_len: 0, sin_family: 0, sin_port: 0, sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0)) zeroAddress.sin_len = UInt8(sizeofValue(zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) let defaultRouteReachability = withUnsafePointer(&zeroAddress) { SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, UnsafePointer($0)) } var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags(rawValue: 0) if SCNetworkReachabilityGetFlags(defaultRouteReachability!, &flags) == false { return false } let isReachable = flags == .Reachable let needsConnection = flags == .ConnectionRequired return isReachable && !needsConnection } }
if Reachability.isConnectedToNetwork() == true { println("Internet connection OK") } else { println("Internet connection FAILED") }
if Reachability.isConnectedToNetwork() == true { println("Internet connection OK") } else { println("Internet connection FAILED") var alert = UIAlertView(title: "No Internet Connection", message: "Make sure your device is connected to the internet.", delegate: nil, cancelButtonTitle: "OK") alert.show() }
struct Connectivity { static let sharedInstance = NetworkReachabilityManager()! static var isConnectedToInternet:Bool { return self.sharedInstance.isReachable } }
if Connectivity.isConnectedToInternet { print("Connected") } else { print("No Internet") }
import UIKit import Foundation class AppManager: NSObject{ var delegate:AppManagerDelegate? = nil private var _useClosures:Bool = false private var reachability: Reachability? private var _isReachability:Bool = false private var _reachabiltyNetworkType :String? var isReachability:Bool { get {return _isReachability} } var reachabiltyNetworkType:String { get {return _reachabiltyNetworkType! } } final class var sharedInstance : AppManager { struct Static { static var instance : AppManager? } if !(Static.instance != nil) { Static.instance = AppManager() } return Static.instance! } func initRechabilityMonitor() { print("initialize rechability...") do { let reachability = try Reachability.reachabilityForInternetConnection() self.reachability = reachability } catch ReachabilityError.FailedToCreateWithAddress(let address) { print("Unable to create\nReachability with address:\n\(address)") return } catch {} if (_useClosures) { reachability?.whenReachable = { reachability in self.notifyReachability(reachability) } reachability?.whenUnreachable = { reachability in self.notifyReachability(reachability) } } else { self.notifyReachability(reachability!) } do { try reachability?.startNotifier() } catch { print("unable to start notifier") return } } private func notifyReachability(reachability:Reachability) { if reachability.isReachable() { self._isReachability = true if reachability.isReachableViaWiFi() { self._reachabiltyNetworkType = CONNECTION_NETWORK_TYPE.WIFI_NETWORK.rawValue } else { self._reachabiltyNetworkType = CONNECTION_NETWORK_TYPE.WWAN_NETWORK.rawValue } } else { self._isReachability = false self._reachabiltyNetworkType = CONNECTION_NETWORK_TYPE.OTHER.rawValue } NSNotificationCenter.defaultCenter().addObserver(self, selector: "reachabilityChanged:", name: ReachabilityChangedNotification, object: reachability) } func reachabilityChanged(note: NSNotification) { let reachability = note.object as! Reachability dispatch_async(dispatch_get_main_queue()) { if (self._useClosures) { self.reachability?.whenReachable = { reachability in self.notifyReachability(reachability) } self.reachability?.whenUnreachable = { reachability in self.notifyReachability(reachability) } } else { self.notifyReachability(reachability) } self.delegate?.reachabilityStatusChangeHandler(reachability) } } deinit { reachability?.stopNotifier() if (!_useClosures) { NSNotificationCenter.defaultCenter().removeObserver(self, name: ReachabilityChangedNotification, object: nil) } } }
import Foundation @objc protocol AppManagerDelegate:NSObjectProtocol { func reachabilityStatusChangeHandler(reachability:Reachability) }
import UIKit class UIappViewController: UIViewController,AppManagerDelegate { var manager:AppManager = AppManager.sharedInstance override func viewDidLoad() { super.viewDidLoad() manager.delegate = self } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func reachabilityStatusChangeHandler(reachability: Reachability) { if reachability.isReachable() { print("isReachable") } else { print("notReachable") } } }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { AppManager.sharedInstance.initRechabilityMonitor() return true }
import Foundation enum CONNECTION_NETWORK_TYPE : String { case WIFI_NETWORK = "Wifi" case WWAN_NETWORK = "Cellular" case OTHER = "Other" }
import UIKit class ViewController: UIappViewController { var reachability:Reachability? override func viewDidLoad() { super.viewDidLoad() manager.delegate = self if(AppManager.sharedInstance.isReachability) { print("net available") } else { dispatch_async(dispatch_get_main_queue()) { print("net not available") } } if(AppManager.sharedInstance.reachabiltyNetworkType == "Wifi") { print(".Wifi") } else if (AppManager.sharedInstance.reachabiltyNetworkType == "Cellular") { print(".Cellular") } else { dispatch_async(dispatch_get_main_queue()) { print("Network not reachable") } } } override func viewWillAppear(animated: Bool) { } override func didReceiveMemoryWarning() { } }
func hasConnectivity() -> Bool { do { let reachability: Reachability = try Reachability.reachabilityForInternetConnection() let networkStatus: Int = reachability.currentReachabilityStatus.hashValue return (networkStatus != 0) } catch { return false } }
Copyright (c) 2014, Ashley Mills All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ import SystemConfiguration import Foundation public enum ReachabilityError: ErrorType { case FailedToCreateWithAddress(sockaddr_in) case FailedToCreateWithHostname(String) case UnableToSetCallback case UnableToSetDispatchQueue } public let ReachabilityChangedNotification = "ReachabilityChangedNotification" func callback(reachability:SCNetworkReachability, flags: SCNetworkReachabilityFlags, info: UnsafeMutablePointer<Void>) { let reachability = Unmanaged<Reachability>.fromOpaque(COpaquePointer(info)).takeUnretainedValue() dispatch_async(dispatch_get_main_queue()) { reachability.reachabilityChanged(flags) } } public class Reachability: NSObject { public typealias NetworkReachable = (Reachability) -> () public typealias NetworkUnreachable = (Reachability) -> () public enum NetworkStatus: CustomStringConvertible { case NotReachable, ReachableViaWiFi, ReachableViaWWAN public var description: String { switch self { case .ReachableViaWWAN: return "Cellular" case .ReachableViaWiFi: return "WiFi" case .NotReachable: return "No Connection" } } } public var whenReachable: NetworkReachable? public var whenUnreachable: NetworkUnreachable? public var reachableOnWWAN: Bool public var notificationCenter = NSNotificationCenter.defaultCenter() public var currentReachabilityStatus: NetworkStatus { if isReachable() { if isReachableViaWiFi() { return .ReachableViaWiFi } if isRunningOnDevice { return .ReachableViaWWAN } } return .NotReachable } public var currentReachabilityString: String { return "\(currentReachabilityStatus)" } private var previousFlags: SCNetworkReachabilityFlags? required public init(reachabilityRef: SCNetworkReachability) { reachableOnWWAN = true self.reachabilityRef = reachabilityRef } public convenience init(hostname: String) throws { let nodename = (hostname as NSString).UTF8String guard let ref = SCNetworkReachabilityCreateWithName(nil, nodename) else { throw ReachabilityError.FailedToCreateWithHostname(hostname) } self.init(reachabilityRef: ref) } public class func reachabilityForInternetConnection() throws -> Reachability { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(sizeofValue(zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) guard let ref = withUnsafePointer(&zeroAddress, { SCNetworkReachabilityCreateWithAddress(nil, UnsafePointer($0)) }) else { throw ReachabilityError.FailedToCreateWithAddress(zeroAddress) } return Reachability(reachabilityRef: ref) } public class func reachabilityForLocalWiFi() throws -> Reachability { var localWifiAddress: sockaddr_in = sockaddr_in(sin_len: __uint8_t(0), sin_family: sa_family_t(0), sin_port: in_port_t(0), sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0)) localWifiAddress.sin_len = UInt8(sizeofValue(localWifiAddress)) localWifiAddress.sin_family = sa_family_t(AF_INET) let address: UInt32 = 0xA9FE0000 localWifiAddress.sin_addr.s_addr = in_addr_t(address.bigEndian) guard let ref = withUnsafePointer(&localWifiAddress, { SCNetworkReachabilityCreateWithAddress(nil, UnsafePointer($0)) }) else { throw ReachabilityError.FailedToCreateWithAddress(localWifiAddress) } return Reachability(reachabilityRef: ref) } public func startNotifier() throws { guard !notifierRunning else { return } var context = SCNetworkReachabilityContext(version: 0, info: nil, retain: nil, release: nil, copyDescription: nil) context.info = UnsafeMutablePointer(Unmanaged.passUnretained(self).toOpaque()) if !SCNetworkReachabilitySetCallback(reachabilityRef!, callback, &context) { stopNotifier() throw ReachabilityError.UnableToSetCallback } if !SCNetworkReachabilitySetDispatchQueue(reachabilityRef!, reachabilitySerialQueue) { stopNotifier() throw ReachabilityError.UnableToSetDispatchQueue } dispatch_async(reachabilitySerialQueue) { () -> Void in let flags = self.reachabilityFlags self.reachabilityChanged(flags) } notifierRunning = true } public func stopNotifier() { defer { notifierRunning = false } guard let reachabilityRef = reachabilityRef else { return } SCNetworkReachabilitySetCallback(reachabilityRef, nil, nil) SCNetworkReachabilitySetDispatchQueue(reachabilityRef, nil) } public func isReachable() -> Bool { let flags = reachabilityFlags return isReachableWithFlags(flags) } public func isReachableViaWWAN() -> Bool { let flags = reachabilityFlags return isRunningOnDevice && isReachable(flags) && isOnWWAN(flags) } public func isReachableViaWiFi() -> Bool { let flags = reachabilityFlags if !isReachable(flags) { return false } if !isRunningOnDevice { return true } return !isOnWWAN(flags) } private var isRunningOnDevice: Bool = { return false return true }() private var notifierRunning = false private var reachabilityRef: SCNetworkReachability? private let reachabilitySerialQueue = dispatch_queue_create("uk.co.ashleymills.reachability", DISPATCH_QUEUE_SERIAL) private func reachabilityChanged(flags: SCNetworkReachabilityFlags) { guard previousFlags != flags else { return } if isReachableWithFlags(flags) { if let block = whenReachable { block(self) } } else { if let block = whenUnreachable { block(self) } } notificationCenter.postNotificationName(ReachabilityChangedNotification, object:self) previousFlags = flags } private func isReachableWithFlags(flags: SCNetworkReachabilityFlags) -> Bool { if !isReachable(flags) { return false } if isConnectionRequiredOrTransient(flags) { return false } if isRunningOnDevice { if isOnWWAN(flags) && !reachableOnWWAN { return false } } return true } private func isConnectionRequired() -> Bool { return connectionRequired() } private func connectionRequired() -> Bool { let flags = reachabilityFlags return isConnectionRequired(flags) } private func isConnectionOnDemand() -> Bool { let flags = reachabilityFlags return isConnectionRequired(flags) && isConnectionOnTrafficOrDemand(flags) } private func isInterventionRequired() -> Bool { let flags = reachabilityFlags return isConnectionRequired(flags) && isInterventionRequired(flags) } private func isOnWWAN(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.IsWWAN) return false } private func isReachable(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.Reachable) } private func isConnectionRequired(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.ConnectionRequired) } private func isInterventionRequired(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.InterventionRequired) } private func isConnectionOnTraffic(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.ConnectionOnTraffic) } private func isConnectionOnDemand(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.ConnectionOnDemand) } func isConnectionOnTrafficOrDemand(flags: SCNetworkReachabilityFlags) -> Bool { return !flags.intersect([.ConnectionOnTraffic, .ConnectionOnDemand]).isEmpty } private func isTransientConnection(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.TransientConnection) } private func isLocalAddress(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.IsLocalAddress) } private func isDirect(flags: SCNetworkReachabilityFlags) -> Bool { return flags.contains(.IsDirect) } private func isConnectionRequiredOrTransient(flags: SCNetworkReachabilityFlags) -> Bool { let testcase:SCNetworkReachabilityFlags = [.ConnectionRequired, .TransientConnection] return flags.intersect(testcase) == testcase } private var reachabilityFlags: SCNetworkReachabilityFlags { guard let reachabilityRef = reachabilityRef else { return SCNetworkReachabilityFlags() } var flags = SCNetworkReachabilityFlags() let gotFlags = withUnsafeMutablePointer(&flags) { SCNetworkReachabilityGetFlags(reachabilityRef, UnsafeMutablePointer($0)) } if gotFlags { return flags } else { return SCNetworkReachabilityFlags() } } override public var description: String { var W: String if isRunningOnDevice { W = isOnWWAN(reachabilityFlags) ? "W" : "-" } else { W = "X" } let R = isReachable(reachabilityFlags) ? "R" : "-" let c = isConnectionRequired(reachabilityFlags) ? "c" : "-" let t = isTransientConnection(reachabilityFlags) ? "t" : "-" let i = isInterventionRequired(reachabilityFlags) ? "i" : "-" let C = isConnectionOnTraffic(reachabilityFlags) ? "C" : "-" let D = isConnectionOnDemand(reachabilityFlags) ? "D" : "-" let l = isLocalAddress(reachabilityFlags) ? "l" : "-" let d = isDirect(reachabilityFlags) ? "d" : "-" return "\(W)\(R) \(c)\(t)\(i)\(C)\(D)\(l)\(d)" } deinit { stopNotifier() reachabilityRef = nil whenReachable = nil whenUnreachable = nil } }
import Alamofire public class ConnectionHelper: NSObject { var request: Alamofire.Request? func isInternetConnected(completionHandler: Bool -> Void) { NSTimer.scheduledTimerWithTimeInterval(5.0, target: self, selector: "requestTimeout", userInfo: nil, repeats: false) request = Alamofire .request( Method.HEAD, "http: ) .response { response in if response.3?.code == -999 { completionHandler( false ) } else { completionHandler( true ) } } } func requestTimeout() { request!.cancel() } }
ConnectionHelper().isInternetConnected() { internetConnected in if internetConnected { } else { } }
let configuration = NSURLSessionConfiguration.defaultSessionConfiguration() configuration.timeoutIntervalForRequest = 15 configuration.timeoutIntervalForResource = 15 let alamoFireManager = Alamofire.Manager(configuration:configuration) alamoFireManager?.request(.GET, "https: .validate() .responseJSON { response in if let error = response.result.error { switch error.code{ case -1001: print("Slow connection") return case -1009: print("No Connection!") return default: break } }
import Foundation import ReachabilitySwift enum ReachabilityManagerType { case Wifi case Cellular case None } class ReachabilityManager { static let sharedInstance = ReachabilityManager() private var reachability: Reachability! private var reachabilityManagerType: ReachabilityManagerType = .None private init() { do { self.reachability = try Reachability.reachabilityForInternetConnection() } catch { print("Unable to create Reachability") return } NSNotificationCenter.defaultCenter().addObserver(self, selector: do{ try self.reachability.startNotifier() }catch{ print("could not start reachability notifier") } } @objc private func reachabilityChanged(note: NSNotification) { let reachability = note.object as! Reachability if reachability.isReachable() { if reachability.isReachableViaWiFi() { self.reachabilityManagerType = .Wifi } else { self.reachabilityManagerType = .Cellular } } else { self.reachabilityManagerType = .None } } } extension ReachabilityManager { func isConnectedToNetwork() -> Bool { return reachabilityManagerType != .None } }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { ReachabilityManager.sharedInstance }
if ReachabilityManager.sharedInstance.isConnectedToNetwork() { } else { }
import UIKit import Foundation import SystemConfiguration class NetworkConnection: UIViewController { class func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in(sin_len: 0, sin_family: 0, sin_port: 0, sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0)) zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) guard let defaultRouteReachability = withUnsafePointer(to: &zeroAddress, { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) { SCNetworkReachabilityCreateWithAddress(nil, $0) } }) else { return false } var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags(rawValue: 0) if SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) == false { return false } let isReachable = (flags.rawValue & UInt32(kSCNetworkFlagsReachable)) != 0 let needsConnection = (flags.rawValue & UInt32(kSCNetworkFlagsConnectionRequired)) != 0 return (isReachable && !needsConnection) } class func checkConnection(sender:UIViewController){ if NetworkConnection.isConnectedToNetwork() == true { print("Connected to the internet") } else { print("No internet connection") let alertController = UIAlertController(title: "No Internet Available", message: "", preferredStyle: UIAlertControllerStyle.alert) let okAction = UIAlertAction(title: "Ok", style: UIAlertActionStyle.default){(result:UIAlertAction) -> Void in return } alertController.addAction(okAction) sender.present(alertController, animated: true, completion: nil) } } }
import Foundation import SystemConfiguration public class Reachability { class func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in(sin_len: 0, sin_family: 0, sin_port: 0, sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0)) zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) let defaultRouteReachability = withUnsafePointer(to: &zeroAddress) { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {zeroSockAddress in SCNetworkReachabilityCreateWithAddress(nil, zeroSockAddress) } } var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags(rawValue: 0) if SCNetworkReachabilityGetFlags(defaultRouteReachability!, &flags) == false { return false } let isReachable = (flags.rawValue & UInt32(kSCNetworkFlagsReachable)) != 0 let needsConnection = (flags.rawValue & UInt32(kSCNetworkFlagsConnectionRequired)) != 0 let ret = (isReachable && !needsConnection) return ret } class func isInternetAvailable(webSiteToPing: String?, completionHandler: @escaping (Bool) -> Void) { guard isConnectedToNetwork() else { completionHandler(false) return } var webAddress = "https: if let _ = webSiteToPing { webAddress = webSiteToPing! } guard let url = URL(string: webAddress) else { completionHandler(false) print("could not create url from: \(webAddress)") return } let urlRequest = URLRequest(url: url) let session = URLSession.shared let task = session.dataTask(with: urlRequest, completionHandler: { (data, response, error) in if error != nil || response == nil { completionHandler(false) } else { completionHandler(true) } }) task.resume() } }
Reachability.isInternetAvailable(webSiteToPing: nil) { (isInternetAvailable) in guard isInternetAvailable else { return } }
import UIKit import SystemConfiguration extension UIDevice { open class var isConnectedToNetwork: Bool { get { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) guard let defaultRouteReachability: SCNetworkReachability = withUnsafePointer(to: &zeroAddress, { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) { SCNetworkReachabilityCreateWithAddress(nil, $0) } }), var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags() as SCNetworkReachabilityFlags?, SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) else { return false } return flags.contains(.reachable) && !flags.contains(.connectionRequired) } } } print("Network status availability: " + ( UIDevice.isConnectedToNetwork ? "true" : "false" ))
NSString *string = NSLocalizedString(@"key", @"comment");
func NSLocalizedString( key: String, tableName: String? = default, bundle: NSBundle = default, value: String = default,
extension String { var localized: String { return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: "") } }
extension String { func localized(withComment:String) -> String { return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: withComment) } }
myLabel.text = "Hi".localized(withComment: "with !!!")
func NSLocalizedString( key: String, tableName: String? = default, bundle: NSBundle = default, value: String = default,
extension String { func localized(withComment comment: String? = nil) -> String { return NSLocalizedString(self, comment: comment ?? "") } }
"Goodbye".localized() "Hello".localized(withComment: "Simple greeting")
genstrings MyCoolApp/Views/SomeView.swift -s localize -o .
import UIKit extension String { public static func localize(key: String, comment: String) -> String { return NSLocalizedString(key, comment: comment) } }
String.localize("foo.bar", comment: "Foo Bar Comment :)")
public func NSLocalizedString(key: String) -> String { return NSLocalizedString(key, comment: "") }
import Foundation extension String { var localized: String { return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: "") } }
fileprivate func NSLocalizedString(_ key: String) -> String { return NSLocalizedString(key, comment: "") }
import Foundation extension String { static let Hello = NSLocalizedString("Hello") static let ThisApplicationIsCreated = NSLocalizedString("This application is created by the swifting.io team") static let OpsNoFeature = NSLocalizedString("Ops! It looks like this feature haven }
let message: String = .ThisApplicationIsCreated print(message)
NSLocalisedString("Text to translate", comment: "Comment to comment")
let value = NSLocalizedString("key", tableName: nil, bundle: Bundle(for: type(of: self)), value: "", comment: "")
extension String { var localized: String { return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: "") } }
let bundleURLOfSDK = Bundle(for: type(of: self)).bundleURL let mainBundleURL = Bundle.main.bundleURL
let bundle = Bundle(url: Bundle.main.bundleURL.appendingPathComponent("Frameworks").appendingPathComponent("YourLocalizeDemoSDK.framework")) ?? Bundle.main
extension String { var localized: String { let bundle = Bundle(url: Bundle.main.bundleURL.appendingPathComponent("Frameworks").appendingPathComponent("YourLocalizeDemoSDK.framework")) ?? Bundle.main return NSLocalizedString(self, tableName: nil, bundle: bundle, value: "", comment: "") } }
extension String { func localizedWith(comment:String) -> String { return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: comment) } }
struct Constants { struct ErrorMessages { static let unKnownError = NSLocalizedString("Unknown Error", comment: "Unknown Error Occured") static let downloadError = NSLocalizedString("Error in Download", comment: "Error in Download") } } let error = Constants.ErrorMessages.unKnownError
find ./ -name \*.swift -print0 | xargs -0 genstrings -o .en.lproj
public func NSLocalizedString(key: String, referenceClass: AnyClass, comment: String = "") -> String { let bundle = NSBundle(forClass: referenceClass) return NSLocalizedString(key, tableName:nil, bundle: bundle, comment: comment) }
NSLocalizedString("YOUR-KEY", referenceClass: self)
NSLocalizedString("YOUR-KEY", referenceClass: self, comment: "usage description")
extension String { func localized() -> String { let defaultLanguage = "en" let path = Bundle.main.path(forResource: defaultLanguage, ofType: "lproj") let bundle = Bundle(path: path!) return NSLocalizedString(self, tableName: nil, bundle: bundle!, value: "", comment: "") } }
NSLocalizedString("previousWasFeminine", value: "previous was", comment: "previousWasFeminine") NSLocalizedString("previousWasMasculine", value: "previous was", comment: "previousWasMasculine")
var str = ["Apple", "Banana", "Coconut"] str[0] str[3]
let theIndex = 3 if let nonexistent = str[theIndex] { print(nonexistent) ...do other things with nonexistent... }
let theIndex = 3 if (theIndex < str.count) { let nonexistent = str[theIndex] print(nonexistent) ...do other things with nonexistent... }
extension Array { subscript(var index: Int) -> AnyObject? { if index >= self.count { NSLog("Womp!") return nil } return ... } }
extension Collection { subscript (safe index: Index) -> Element? { return indices.contains(index) ? self[index] : nil } }
extension Collection where Indices.Iterator.Element == Index { subscript (safe index: Index) -> Generator.Element? { return indices.contains(index) ? self[index] : nil } }
extension CollectionType { subscript (safe index: Index) -> Generator.Element? { return indices.contains(index) ? self[index] : nil } }
let array = [1, 2, 3] for index in -20...20 { if let item = array[safe: index] { print(item) } }
var fruits: [String] = ["Apple", "Banana", "Coconut"] var str: String = "I ate a \( fruits[0] )"
var fruits: [String] = ["Apple", "Banana", "Coconut"] var str: String = "I ate a \( fruits[0]! )"
extension Array { func get(index: Int) -> T? { if 0 <= index && index < count { return self[index] } else { return nil } } } var fruits: [String] = ["Apple", "Banana", "Coconut"] if let fruit = fruits.get(1) { print("I ate a \( fruit )") } if let fruit = fruits.get(3) { print("I ate a \( fruit )") }
extension Indexable { public subscript(safe safeIndex: Index) -> _Element? { return safeIndex.distanceTo(endIndex) > 0 ? self[safeIndex] : nil } }
extension Array { @warn_unused_result public func checkIndexForSafety(index: Int) -> SafeIndex? { if indices.contains(index) { return SafeIndex(indexNumber: index) } else { return nil } } subscript(index:SafeIndex) -> Element { get { return self[index.indexNumber] } set { self[index.indexNumber] = newValue } } subscript(safeIndex index:SafeIndex) -> Element { get { return self[index.indexNumber] } set { self[index.indexNumber] = newValue } } } public class SafeIndex { var indexNumber:Int init(indexNumber:Int){ self.indexNumber = indexNumber } }
extension Array { subscript (safe index: Index) -> Element? { return 0 <= index && index < count ? self[index] : nil } }
let itms: [Int?] = [0, nil] let a = itms[safe: 0] a ?? 5 let b = itms[safe: 1] b ?? 5 let c = itms[safe: 2] c ?? 5
extension Collection { subscript(safe index: Index) -> Element? { return indices.contains(index) ? self[ index] : nil } } extension MutableCollection { subscript(safe index: Index) -> Element? { get { return indices.contains(index) ? self[ index] : nil } set(newValue) { if let newValue = newValue, indices.contains(index) { self[ index] = newValue } } } }
extension Array where Element: Equatable { func item(at index: Int) -> Element? { return indices.contains(index) ? self[index] : nil } }
/** Safe array get, set, insert and delete. All action that would cause an error are ignored. */ extension Array { /** Removes element at index. Action that would cause an error are ignored. */ mutating func remove(safeAt index: Index) { guard index >= 0 && index < count else { print("Index out of bounds while deleting item at index \(index) in \(self). This action is ignored.") return } remove(at: index) } /** Inserts element at index. Action that would cause an error are ignored. */ mutating func insert(_ element: Element, safeAt index: Index) { guard index >= 0 && index <= count else { print("Index out of bounds while inserting item at index \(index) in \(self). This action is ignored") return } insert(element, at: index) } /** Safe get set subscript. Action that would cause an error are ignored. */ subscript (safe index: Index) -> Element? { get { return indices.contains(index) ? self[index] : nil } set { remove(safeAt: index) if let element = newValue { insert(element, safeAt: index) } } } }
import XCTest class SafeArrayTest: XCTestCase { func testRemove_Successful() { var array = [1, 2, 3] array.remove(safeAt: 1) XCTAssert(array == [1, 3]) } func testRemove_Failure() { var array = [1, 2, 3] array.remove(safeAt: 3) XCTAssert(array == [1, 2, 3]) } func testInsert_Successful() { var array = [1, 2, 3] array.insert(4, safeAt: 1) XCTAssert(array == [1, 4, 2, 3]) } func testInsert_Successful_AtEnd() { var array = [1, 2, 3] array.insert(4, safeAt: 3) XCTAssert(array == [1, 2, 3, 4]) } func testInsert_Failure() { var array = [1, 2, 3] array.insert(4, safeAt: 5) XCTAssert(array == [1, 2, 3]) } func testGet_Successful() { var array = [1, 2, 3] let element = array[safe: 1] XCTAssert(element == 2) } func testGet_Failure() { var array = [1, 2, 3] let element = array[safe: 4] XCTAssert(element == nil) } func testSet_Successful() { var array = [1, 2, 3] array[safe: 1] = 4 XCTAssert(array == [1, 4, 3]) } func testSet_Successful_AtEnd() { var array = [1, 2, 3] array[safe: 3] = 4 XCTAssert(array == [1, 2, 3, 4]) } func testSet_Failure() { var array = [1, 2, 3] array[safe: 4] = 4 XCTAssert(array == [1, 2, 3]) } }
let components = [1, 2] var nilComponents = components.map { $0 as Int? } nilComponents += [nil, nil, nil] switch (nilComponents[0], nilComponents[1], nilComponents[2]) { case (_, _, .Some(5)): default: break }
if theIndex < str.count && let existing = str[theIndex]
func ifInBounds(array: [AnyObject], idx: Int) -> AnyObject? { return idx < array.count ? array[idx] : nil } if let x: AnyObject = ifInBounds(swiftarray, 3) { println(x) } else { println("Out of bounds") }
extension Array { subscript (safe index: UInt) -> Element? { return Int(index) < count ? self[Int(index)] : nil } }
let fruits = ["apple","banana"] print("result-\(fruits[safe : 2])")
var expression = "45+22" expression = expression.substringToIndex(countElements(expression) - 1)
var str = "Hello, World" str.dropLast() str String(str.dropLast()) str.remove(at: str.index(before: str.endIndex)) str
var name: String = "Dolphin" var truncated = name.substring(to: name.index(before: name.endIndex)) print(name) print(truncated)
var name: String = "Dolphin" name.remove(at: name.index(before: name.endIndex)) print(name)
var name: String = "Dolphin" var truncated = name.substringToIndex(name.endIndex.predecessor()) print(name) print(truncated)
var name: String = "Dolphin" name.removeAtIndex(name.endIndex.predecessor()) print(name)
var name: String = "Dolphin" var truncated = String(name.characters.dropLast()) print(name) print(truncated)
let name: String = "Dolphin" let stringLength = count(name) let substringIndex = stringLength - 1 name.substringToIndex(advance(name.startIndex, substringIndex))
let name: String = "Dolphin" name.substringToIndex(name.endIndex.predecessor())
let name: String = "Dolphin" name.substringToIndex(countElements(name) - 1)
var expression = "45+22" expression = dropLast(expression) expression = String(expression.characters.dropLast())
let choppedString = String(theString.characters.dropLast())
extension String { func removeCharsFromEnd(count_:Int) -> String { let stringLength = count(self) let substringIndex = (stringLength < count_) ? 0 : stringLength - count_ return self.substringToIndex(advance(self.startIndex, substringIndex)) } }
var str_1 = "Maxim" println("output: \(str_1.removeCharsFromEnd(1))") println("output: \(str_1.removeCharsFromEnd(3))") println("output: \(str_1.removeCharsFromEnd(8))")
var s = "abc" s.removeAtIndex(s.endIndex.predecessor())
title = title[title.startIndex ..< title.endIndex.advancedBy(-1)]
var welcome = "Hello World!" welcome = String(welcome[..<welcome.index(before:welcome.endIndex)])
welcome.remove(at: welcome.index(before: welcome.endIndex))
let str = "abc" let substr = str.substringToIndex(str.endIndex.predecessor())
var str = "Hello, playground" extension String { var stringByDeletingLastCharacter: String { return dropLast(self) } } println(str.stringByDeletingLastCharacter)
var howToBeHappy = "Practice compassion, attention and gratitude. And smile!!" howToBeHappy.removeAtIndex(howToBeHappy.endIndex.predecessor()) println(howToBeHappy)
var before: String = "Hello world!" var lastCharIndex: Int = before.endIndex var after:String = String(before[..<lastCharIndex]) print(after)
var before: String = "Hello world!" after = String(before[..<before.endIndex]) print(after)
var str = "45+22" str = str.substringToIndex(advance(str.startIndex, countElements(str) - 1))
extension String { mutating func removeCharsFromEnd(removeCount:Int) { let stringLength = count(self) let substringIndex = max(0, stringLength - removeCount) self = self.substringToIndex(advance(self.startIndex, substringIndex)) } }
var myString = "abcd" myString.removeCharsFromEnd(2) println(myString)
var myStr = "Hello World!" myStr = (myStr as NSString).substringToIndex((myStr as NSString).length-XX)
let range = expression.index(expression.endIndex, offsetBy: -numberOfCharactersToRemove)..<expression.endIndex expression.removeSubrange(range)
var mac = peripheral.identifier.description let range = mac.startIndex..<mac.endIndex.advancedBy(-50) mac.removeRange(range) let txPower = peripheral.advertisements.txPower?.description
var expression = "45+22" expression = expression.dropLast()
func replaceSuffix(_ suffix: String, replacement: String) -> String { if hasSuffix(suffix) { let sufsize = suffix.count < count ? -suffix.count : 0 let toIndex = index(endIndex, offsetBy: sufsize) return substring(to: toIndex) + replacement } else { return self } }
@IBOutlet weak var labelText: UILabel! @IBAction func whenXButtonPress(_ sender: UIButton) { labelText.text = String((labelText.text?.dropLast())!) }
var componentArray: [String] let dict = NSDictionary(contentsOfFile: NSBundle.mainBundle().pathForResource("Components", ofType: "plist")!) componentArray = dict.allKeys
componentArray = Array(dict.keys) componentArray = dict.allKeys
var keys: LazyMapCollection<Dictionary<Key, Value>, Key> { get }
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { let string = Bundle.main.path(forResource: "Components", ofType: "plist")! if let dict = NSDictionary(contentsOfFile: string) as? [String : Int] { let lazyMapCollection = dict.keys let componentArray = Array(lazyMapCollection) print(componentArray) } return true }
let dictionary = ["Gabrielle": 49, "Bree": 32, "Susan": 12, "Lynette": 7] let lazyMapCollection = dictionary.keys let stringArray = Array(lazyMapCollection) print(stringArray)
let dictionary = [49: "Gabrielle", 32: "Bree", 12: "Susan", 7: "Lynette"] let lazyMapCollection = dictionary.keys let stringArray = Array(lazyMapCollection.map { String($0) }) print(stringArray)
extension Array { public func toDictionary<Key: Hashable>(with selectKey: (Element) -> Key) -> [Key:Element] { var dict = [Key:Element]() for element in self { dict[selectKey(element)] = element } return dict } }
let objesctNSDictionary = NSDictionary.init(dictionary: ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]) let objectArrayOfAllKeys:Array = objesctNSDictionary.allKeys let objectArrayOfAllValues:Array = objesctNSDictionary.allValues print(objectArrayOfAllKeys) print(objectArrayOfAllValues)
let objectDictionary:Dictionary = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"] let objectArrayOfAllKeys:Array = Array(objectDictionary.keys) let objectArrayOfAllValues:Array = Array(objectDictionary.values) print(objectArrayOfAllKeys) print(objectArrayOfAllValues)
let dict: [String: Int] = ["hey": 1, "yo": 2, "sup": 3, "hello": 4, "whassup": 5]
extension Dictionary { func allKeys() -> [String] { guard self.keys.first is String else { debugPrint("This function will not return other hashable types. (Only strings)") return [] } return self.flatMap { (anEntry) -> String? in guard let temp = anEntry.key as? String else { return nil } return temp } } }
import UIKit class BugViewController: UIViewController { func perform(operation: (Double) -> Double) { } func perform(operation: (Double, Double) -> Double) { } }
import UIKit class BugViewController { func perform(operation: (Double) -> Double) { } func perform(operation: (Double, Double) -> Double) { } }
func performOperation(op: NSOperation) { } func performOperation(fn: () -> Void) { self.performOperation(NSBlockOperation(block: fn)) }
private func performOperation(operation: Double -> Double) { if operandStack.count >= 1 { displayValue = operation(operandStack.removeLast()) enter() } }
func methodOne(par1, par2) {...} @objc(methodTwo:) func methodOne(par1) {...}
func methodOne() {...} @nonobjc func methodOne() {...}
static func prepareForUpSyncing(obj : NSManagedObject!) -> Bool static func prepareForUpSyncing(objs : [NSManagedObject]!) -> Bool
static func prepareForUpSyncing(objs objs : [NSManagedObject]!) -> Bool {
label.font = UIFont(name: label.font.fontName, size: 20)
label.font = UIFont.systemFont(ofSize: 20.0) label.font = UIFont.boldSystemFont(ofSize: 20.0) label.font = UIFont.italicSystemFont(ofSize: 20.0)
label.font = UIFont(name: "Avenir-Light", size: 15.0) label.font = UIFont.boldSystemFontOfSize(15) label.font = UIFont.italicSystemFontOfSize(15) label.font = UIFont.systemFontOfSize(17)
extension UILabel { func setSizeFont (sizeFont: Double) { self.font = UIFont(name: self.font.fontName, size: sizeFont)! self.sizeToFit() } } myLabel.setSizeFont(60)
labelName.font = UIFont(name: "systemFont", size: 30)
import UIKit extension UILabel { func sizeFont(_ size: CGFloat) { self.font = self.font.withSize(size) } }
label = UIFont.systemFont(ofSize: UIFont.smallSystemFontSize)
import UIKit extension UILabel { var fontSize: CGFloat { get { return self.font.pointSize } set { self.font = UIFont(name: self.font.fontName, size: newValue)! self.sizeToFit() } } }
label.font = UIFont.systemFont(ofSize: 20.0) label.font = UIFont.boldSystemFont(ofSize: 20.0) label.font = UIFont.italicSystemFont(ofSize: 20.0) label.font = UIFont(name:"Helvetica Neue", size: 20.0)
post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[ end end end
post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[ end end end
$ xcrun swift -version Apple Swift version 3.0.2 (swiftlang-800.0.63 clang-800.0.42.1) Target: x86_64-apple-macosx10.9
Here are the steps. 1=> select your target from Xcode 2=> go to build setting 3=> search for "Swift Language Version" 4=> change it to swift 3. (or accordingly.)
ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES And Swift Compiler - Version = Swift 3
func textFieldDidBeginEditing(textField: UITextField) { if self.status.text == "" && self.username.text == "" { self.topRightButton.enabled = false } else { self.topRightButton.enabled = true } }
textField.addTarget(self, action: "textFieldDidChange:", forControlEvents: UIControlEvents.EditingChanged)
func textFieldDidChange(textField: UITextField) { }
func textFieldDidChange(textField: UITextField) { }
func textFieldDidChange(_ textField: UITextField) { }
@objc func textFieldDidChange(_ textField: UITextField) { }
[textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged];
-(void)textFieldDidChange :(UITextField *) textField{ }
func textFieldDidChange(textField: UITextField) { }
textField.addTarget(self, action: for: UIControlEvents.editingChanged)
@objc func textFieldDidChange(_ textField: UITextField) { }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let updatedString = (textField.text as NSString?)?.stringByReplacingCharactersInRange(range, withString: string) return true }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let updatedString = (textField.text as NSString?)?.replacingCharacters(in: range, with: string) return true }
textField.addTarget(self, action: for: UIControlEvents.editingChanged) func textFieldDidChange(_ textField: UITextField) { }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let updatedString = (textField.text as NSString?)?.replacingCharacters(in: range, with: string) return true }
(Objective C) textField:shouldChangeCharactersInRange:replacementString: (Swift) textField(_:shouldChangeCharactersInRange:replacementString:)
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { var statusText = self.status.text var usernameText = self.username.text switch textField{ case self.status: statusText = string case self.username: usernameText = string default: break } if statusText == "" && usernameText == "" { self.topRightButton.enabled = false } else { self.topRightButton.enabled = true } return true }
let observable: Observable<String?> = textField.rx.text.asObservable() observable.subscribe( onNext: {(string: String?) in print(string!) })
textField.addTarget(self, action: @objc func textIsChanging(_ textField:UITextField) { print ("TextField is changing") }
textField.addTarget(self, action: @objc func textDidChange(_ textField:UITextField) { print ("TextField did changed") }
txf_Subject.addTarget(self, action: @objc func didChangeText(textField:UITextField) { let str = textField.text if(str?.contains(" "))!{ let newstr = str?.replacingOccurrences(of: " ", with: "") textField.text = newstr } } @objc func didChangeFirstText(textField:UITextField) { if(textField.text == " "){ textField.text = "" } }
import UIKit class ViewController: UIViewController, UITextFieldDelegate { @IBOutlet var yourTextFiled : UITextField! override func viewDidLoad() { super.viewDidLoad() yourTextFiled.delegate = self } func textFieldDidEndEditing(_ textField: UITextField) { } func textFieldShouldReturn(_ textField: UITextField) -> Bool { } . . . }
override func viewDidLoad() { super.viewDidLoad() textField.delegate = self textField.addTarget(self, action: }
func textFieldShouldEndEditing(_ textField: UITextField) -> Bool { return true }
let toolbar = UIView(frame: CGRect(x: 0, y: view.frame.size.height+44, width: view.frame.size.width, height: 44)) toolbar.backgroundColor = UIColor.clear let doneButt = UIButton(frame: CGRect(x: toolbar.frame.size.width - 60, y: 0, width: 44, height: 44)) doneButt.setTitle("Done", for: .normal) doneButt.setTitleColor(MAIN_COLOR, for: .normal) doneButt.titleLabel?.font = UIFont(name: "Titillium-Semibold", size: 13) doneButt.addTarget(self, action: toolbar.addSubview(doneButt) USDTextField.inputAccessoryView = toolbar
@objc func dismissKeyboard() { view.endEditing(true) }
class FileA: NSObject { var foo:String? } class FileB: NSObject { var bar:FileA? } class FileC: NSObject { var baz:FileB? }
var dic = super.json().mutableCopy() as NSMutableDictionary dic.addEntriesFromDictionary([ "url" : self.url?.absoluteString ?? "", "title" : self.title ?? "" ]) return dic.copy() as NSDictionary
var dic = super.json().mutableCopy() as NSMutableDictionary dic.addEntriesFromDictionary([ "url" : self.url?.absoluteString ?? "", "title" : NSString(string: self.title ?? "") ]) return dic.copy() as NSDictionary
... ‚úì Compile EntityObserver.swift (1623 ms) ‚úì Compile Session.swift (1526 ms) ‚úì Compile SearchComposer.swift (1556 ms) ...
let pipeResult = seq |> filter~~ { $0 % 2 == 0 } |> sorted~~ { $1 < $0 } |> map~~ { $0.description } |> joinedWithCommas
return CGSize(width: size.width + (rightView?.bounds.width ?? 0) + (leftView?.bounds.width ?? 0) + 22, height: bounds.height)
var padding: CGFloat = 22 if let rightView = rightView { padding += rightView.bounds.width } if let leftView = leftView { padding += leftView.bounds.width } return CGSizeMake(size.width + padding, bounds.height)
["title" : "someTitle", "textFile" : "someTextFile"], ["title" : "someTitle", "textFile" : "someTextFile"], ["title" : "someTitle", "textFile" : "someTextFile"], ["title" : "someTitle", "textFile" : "someTextFile"], .....
["title" : "someTitle", "textFile" : "someTextFile"] as [String : String], ["title" : "someTitle", "textFile" : "someTextFile"] as [String : String], ["title" : "someTitle", "textFile" : "someTextFile"] as [String : String], ....
xcodebuild -workspace App.xcworkspace -scheme App clean build OTHER_SWIFT_FLAGS="-Xfrontend -debug-time-function-bodies" | grep [1-9].[0-9]ms | sort -nr > culprits.txt
var a = ["a": "b", "c": "d", "e": "f", "g": "h", "i": "j", "k": "l", "m": "n", "o": "p", "q": "r", "s": "t", "u": "v", "x": "z"]
var a = NSMutableDictionary() a["a"] = "b" a["c"] = "d" ... and so on
let sum = [1,2,3].map({String($0)}).flatMap({Float($0)}).reduce(0, combine: +)
let numbers: [Int] = [1,2,3] let strings: [String] = sum.map({String($0)}) let floats: [Float] = strings.flatMap({Float($0)}) let sum: Float = floats.reduce(0, combine: +)
abs((some_optional_variable ?? 0) as VARIABLE_TYPE)
let lessPrecisePI = Float("3.14") let morePrecisePI = Double("3.1415926536") let invalidNumber = Float("alphabet")
if let cost = Double(textField.text!) { print("The user entered a value price of \(cost)") } else { print("Not a valid number: \(textField.text!)") }
let formatter = NumberFormatter() formatter.locale = Locale.current formatter.numberStyle = .decimal let number = formatter.number(from: "9,999.99")
let usLocale = Locale(identifier: "en_US") let frenchLocale = Locale(identifier: "fr_FR") let germanLocale = Locale(identifier: "de_DE") let englishUKLocale = Locale(identifier: "en_GB") formatter.numberStyle = .currency formatter.locale = usLocale let usCurrency = formatter.number(from: "$9,999.99") formatter.locale = frenchLocale let frenchCurrency = formatter.number(from: "9999,99‚Ç¨") formatter.locale = germanLocale let germanCurrency = formatter.number(from: "9999,99‚Ç¨") formatter.locale = englishUKLocale let englishUKCurrency = formatter.number(from: "¬£9,999.99")
let double = NSNumberFormatter().numberFromString(myString)?.doubleValue
extension String { func toDouble() -> Double? { return NSNumberFormatter().numberFromString(self)?.doubleValue } }
var myString = "4.2" var myDouble = myString.toDouble()
if let myDouble = myDouble { println("The value is \(myDouble)") }
let formatter = NSNumberFormatter() formatter.locale = NSLocale(localeIdentifier: "fr_FR") let double = formatter.numberFromString("100,25")
let string = NSString(string: mySwiftString) string.doubleValue
println("543.29".doubleValue()) println("543".doubleValue()) println(".29".doubleValue()) println("0.29".doubleValue()) println("-543.29".doubleValue()) println("-543".doubleValue()) println("-.29".doubleValue()) println("-0.29".doubleValue()) 543.29 543.0 0.29 0.29 -543.29 -543.0 -0.29 -0.29
extension String { func doubleValue() -> Double { let minusAscii: UInt8 = 45 let dotAscii: UInt8 = 46 let zeroAscii: UInt8 = 48 var res = 0.0 let ascii = self.utf8 var whole = [Double]() var current = ascii.startIndex let negative = current != ascii.endIndex && ascii[current] == minusAscii if (negative) { current = current.successor() } while current != ascii.endIndex && ascii[current] != dotAscii { whole.append(Double(ascii[current] - zeroAscii)) current = current.successor() } var factor: Double = 1 for var i = countElements(whole) - 1; i >= 0; i-- { res += Double(whole[i]) * factor factor *= 10 } if current != ascii.endIndex { factor = 0.1 current = current.successor() while current != ascii.endIndex { res += Double(ascii[current] - zeroAscii) * factor factor *= 0.1 current = current.successor() } } if (negative) { res *= -1; } return res } }
import Foundation let str = "123.4567" let num = atof(str) atof("123.4567fubar")
atof("0xffp-2") atof("12.3456e+2") atof("nan") atof("inf")
let str = "0xff" atof(str) strtod(str, nil) CFStringGetDoubleValue(str) (str as NSString).doubleValue
var myDouble = myString.bridgeToObjectiveC().doubleValue println(myDouble)
if let myDouble = NumberFormatter().number(from: yourString)?.doubleValue { print("My double: \(myDouble)") }
return NSNumberFormatter().numberFromString(self)?.doubleValue
let numberFormatter = NSNumberFormatter() numberFormatter.locale = NSLocale(localeIdentifier: "en_US_POSIX") return numberFormatter.numberFromString(self)?.doubleValue
extension String { func toDouble() -> Double? { let numberFormatter = NSNumberFormatter() numberFormatter.locale = NSLocale(localeIdentifier: "en_US_POSIX") return numberFormatter.numberFromString(self)?.doubleValue } }
if let myDouble = myDouble { println("The value is \(myDouble)") }
extension String { var toDouble: Double { return Double(self) ?? 0.0 } }
extension String { func toDouble() -> Double? { let numberFormatter = NumberFormatter() numberFormatter.locale = Locale(identifier: "en_US_POSIX") return numberFormatter.number(from: self)?.doubleValue } }
let sString = "236.86" var dNumber = NSNumberFormatter().numberFromString(sString) var nDouble = dNumber! var eNumber = Double(nDouble) * 3.7
let strswift = "12" let double = (strswift as NSString).doubleValue
var strswift= "10.6" var double : Double = NSString(string: strswift).doubleValue
extension String { var doubleValue: Double { return (self as NSString).doubleValue } }
extension String { func toDouble(locale: NSLocale? = nil) -> Double? { let formatter = NSNumberFormatter() if let locale = locale { formatter.locale = locale } return formatter.numberFromString(self)?.doubleValue } }
extension String { func toDouble(_ locale: Locale) -> Double { let formatter = NumberFormatter() formatter.numberStyle = .decimal formatter.locale = locale formatter.usesGroupingSeparator = true if let result = formatter.number(from: self)?.doubleValue { return result } else { return 0 } } }
let str:String = "111.11" let tempString = (str as NSString).doubleValue print("String:-",tempString)
var myDouble = Double((mySwiftString.text as NSString).doubleValue)
import StringEx let str = "123.45678" if let num = str.toDouble() { println("Number: \(num)") } else { println("Invalid string") }
let strNumber = "314" let intFromString = Int(strNumber) let dobleFromInt = Double(intFromString!) print(dobleFromInt)
let strNumber = "314" let NSstringFromString = NSString(string: strNumber as! NSString) let doubleFromNSString = NSstringFromString.doubleValue print(doubleFromNSString)
extension String { func toDouble() -> Double { let nsString = self as NSString return nsString.doubleValue } }
var scanned: Double() let scanner = NSScanner(string: "String to Scan") scanner.scanDouble(&scanned)
extension String { var doubleValue: Double { return (self as NSString).doubleValue } }
extension String { var doubleValue: Double { return Double((self.replacingOccurrences(of: ",", with: ".") as NSString).doubleValue) } }
var stringValue = "55" var convertToDouble = Double((stringValue as NSString).doubleValue)
DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(4), execute: { })
let time = dispatch_time(dispatch_time_t(DISPATCH_TIME_NOW), 4 * Int64(NSEC_PER_SEC)) dispatch_after(time, dispatch_get_main_queue()) { }
DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(4), execute: { print("done") })
Timer.scheduledTimer(timeInterval: 4, target: self, selector: func callback() { print("done") }}
public func delay(bySeconds seconds: Double, dispatchLevel: DispatchLevel = .main, closure: @escaping () -> Void) { let dispatchTime = DispatchTime.now() + seconds dispatchLevel.dispatchQueue.asyncAfter(deadline: dispatchTime, execute: closure) } public enum DispatchLevel { case main, userInteractive, userInitiated, utility, background var dispatchQueue: DispatchQueue { switch self { case .main: return DispatchQueue.main case .userInteractive: return DispatchQueue.global(qos: .userInteractive) case .userInitiated: return DispatchQueue.global(qos: .userInitiated) case .utility: return DispatchQueue.global(qos: .utility) case .background: return DispatchQueue.global(qos: .background) } } }
delay(bySeconds: 1.5, dispatchLevel: .background) { }
override func viewDidLoad() { super.viewDidLoad() self.perform( } @objc func performAction() { print("Delayed") }
let delay = 0.5 NSTimer.scheduledTimerWithTimeInterval(delay, target: self, selector:
import UIKit class ViewController: UIViewController { var timer = NSTimer() let delay = 0.5 @IBAction func startTimerButtonTapped(sender: UIButton) { timer.invalidate() timer = NSTimer.scheduledTimerWithTimeInterval(delay, target: self, selector: } func delayedAction() { print("action has started") } }
func delayWithSeconds(_ seconds: Double, completion: @escaping () -> ()) { DispatchQueue.main.asyncAfter(deadline: .now() + seconds) { completion() } }
DispatchQueue.global(qos: .background).async { sleep(4) print("Active after 4 sec, and doesn DispatchQueue.main.async{ } }
import Darwin print("This is one.") sleep(1) print("This is two.") usleep(400000) print("This is three.")
DispatchQueue.main.asyncAfter(deadline: .now() + 0.5, execute: { })
delay(0.3, closure: { button.removeFromSuperview() })
UIApplication.sharedApplication().registerUserNotificationSettings(UIUserNotificationSettings(forTypes: UIUserNotificationType.Alert | UIUserNotificationType.Badge, categories: nil))
let settings = UIUserNotificationSettings(forTypes: [.Alert, .Badge], categories: nil) UIApplication.sharedApplication().registerUserNotificationSettings(settings)
let settings = UIUserNotificationSettings(forTypes: [.Alert, .Badge], categories: nil) if settings.types.contains(.Alert) { }
let settings = UIUserNotificationSettings(types: [.alert, .badge], categories: nil) UIApplication.shared.registerUserNotificationSettings(settings)
let settings = UIUserNotificationSettings(types: [.alert, .badge], categories: nil) if settings.types.contains(.alert) { }
let settings = UIUserNotificationType.Alert.union(UIUserNotificationType.Badge)
var settings = UIUserNotificationSettings(forTypes: UIUserNotificationType([.Alert, .Badge, .Sound]), categories: nil)
let settings = UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil) UIApplication.shared.registerUserNotificationSettings(settings)
UIView.animateWithDuration(10.5, animations: { self.nameInputConstraint.constant = 8 }, completion: { (value: Bool) in println(">>> move const") })
self.nameInputConstraint.constant = 8 UIView.animateWithDuration(0.5) { self.view.layoutIfNeeded() }
UIView.animate(withDuration: 0.5) { self.view.layoutIfNeeded() }
self.mConstraint.constant = 100.0 UIView.animate(withDuration: 0.3) { self.view.layoutIfNeeded() }
self.mConstraint.constant = 100 UIView.animate(withDuration: 0.3, animations: { self.view.layoutIfNeeded() }, completion: {res in })
class func animate(withDuration duration: TimeInterval, animations: @escaping () -> Void)
import UIKit import PlaygroundSupport class ViewController: UIViewController { let textView = UITextView() lazy var heightConstraint = textView.heightAnchor.constraint(equalToConstant: 50) override func viewDidLoad() { view.backgroundColor = .white view.addSubview(textView) textView.backgroundColor = .orange textView.isEditable = false textView.text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum." textView.translatesAutoresizingMaskIntoConstraints = false textView.topAnchor.constraintEqualToSystemSpacingBelow(view.layoutMarginsGuide.topAnchor, multiplier: 1).isActive = true textView.leadingAnchor.constraint(equalTo: view.layoutMarginsGuide.leadingAnchor).isActive = true textView.trailingAnchor.constraint(equalTo: view.layoutMarginsGuide.trailingAnchor).isActive = true heightConstraint.isActive = true let tapGesture = UITapGestureRecognizer(target: self, action: textView.addGestureRecognizer(tapGesture) } @objc func doIt(_ sender: UITapGestureRecognizer) { heightConstraint.constant = heightConstraint.constant == 50 ? 150 : 50 UIView.animate(withDuration: 2) { self.view.layoutIfNeeded() } } } PlaygroundPage.current.liveView = ViewController()
convenience init(duration: TimeInterval, curve: UIViewAnimationCurve, animations: (() -> Void)? = nil)
import UIKit import PlaygroundSupport class ViewController: UIViewController { let textView = UITextView() lazy var heightConstraint = textView.heightAnchor.constraint(equalToConstant: 50) override func viewDidLoad() { view.backgroundColor = .white view.addSubview(textView) textView.backgroundColor = .orange textView.isEditable = false textView.text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum." textView.translatesAutoresizingMaskIntoConstraints = false textView.topAnchor.constraintEqualToSystemSpacingBelow(view.layoutMarginsGuide.topAnchor, multiplier: 1).isActive = true textView.leadingAnchor.constraint(equalTo: view.layoutMarginsGuide.leadingAnchor).isActive = true textView.trailingAnchor.constraint(equalTo: view.layoutMarginsGuide.trailingAnchor).isActive = true heightConstraint.isActive = true let tapGesture = UITapGestureRecognizer(target: self, action: textView.addGestureRecognizer(tapGesture) } @objc func doIt(_ sender: UITapGestureRecognizer) { heightConstraint.constant = heightConstraint.constant == 50 ? 150 : 50 let animator = UIViewPropertyAnimator(duration: 2, curve: .linear, animations: { self.view.layoutIfNeeded() }) animator.startAnimation() } } PlaygroundPage.current.liveView = ViewController()
class func runningPropertyAnimator(withDuration duration: TimeInterval, delay: TimeInterval, options: UIViewAnimationOptions = [], animations: @escaping () -> Void, completion: ((UIViewAnimatingPosition) -> Void)? = nil) -> Self
import UIKit import PlaygroundSupport class ViewController: UIViewController { let textView = UITextView() lazy var heightConstraint = textView.heightAnchor.constraint(equalToConstant: 50) override func viewDidLoad() { view.backgroundColor = .white view.addSubview(textView) textView.backgroundColor = .orange textView.isEditable = false textView.text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum." textView.translatesAutoresizingMaskIntoConstraints = false textView.topAnchor.constraintEqualToSystemSpacingBelow(view.layoutMarginsGuide.topAnchor, multiplier: 1).isActive = true textView.leadingAnchor.constraint(equalTo: view.layoutMarginsGuide.leadingAnchor).isActive = true textView.trailingAnchor.constraint(equalTo: view.layoutMarginsGuide.trailingAnchor).isActive = true heightConstraint.isActive = true let tapGesture = UITapGestureRecognizer(target: self, action: textView.addGestureRecognizer(tapGesture) } @objc func doIt(_ sender: UITapGestureRecognizer) { heightConstraint.constant = heightConstraint.constant == 50 ? 150 : 50 UIViewPropertyAnimator.runningPropertyAnimator(withDuration: 2, delay: 0, options: [], animations: { self.view.layoutIfNeeded() }) } } PlaygroundPage.current.liveView = ViewController()
customView.layoutIfNeeded() UIView.animate(withDuration: 0.5) { customViewConstraint.constant = 100.0 customView.layoutIfNeeded() }
topConstraint.constant = heightShift UIView.animate(withDuration: 0.3) { self.view.superview?.layoutIfNeeded() }
class MyClass { let container = UIView() let view = UIView() var topConstraint = NSLayoutConstraint() func createUI() { container.addSubview(view) topConstraint = view.topAnchor.constraint(equalTo: container.topAnchor, constant: 0) view.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ topConstraint, ]) } func updateConstraint(heightShift: CGFloat) { topConstraint.constant = heightShift UIView.animate(withDuration: 0.3) { self.view.superview?.layoutIfNeeded() } } }
let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = /* find out and place date format from * http: */ let date = dateFormatter.dateFromString( )
let dateFormatter = DateFormatter() dateFormatter.dateFormat = /* date_format_you_want_in_string from * http: */ guard let date = dateFormatter.date(from: ) else { fatalError("ERROR: Date conversion failed due to mismatched format.") }
import Foundation let dateString = "2014-07-15" var dateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd" let date = dateFormatter.date(from: dateString) println(date)
import Foundation var dateString = "2014-07-15" var dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd" var date = dateFormatter.dateFromString(dateString) println(date)
func convertDateFormatter(date: String) -> String { let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd dateFormatter.timeZone = NSTimeZone(name: "UTC") let date = dateFormatter.dateFromString(date) dateFormatter.dateFormat = "yyyy MMM EEEE HH:mm" dateFormatter.timeZone = NSTimeZone(name: "UTC") let timeStamp = dateFormatter.stringFromDate(date!) return timeStamp }
func convertDateFormatter(date: String) -> String { let dateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd dateFormatter.timeZone = NSTimeZone(name: "UTC") as TimeZone! let date = dateFormatter.date(from: date) dateFormatter.dateFormat = "yyyy MMM EEEE HH:mm" dateFormatter.timeZone = NSTimeZone(name: "UTC") as TimeZone! let timeStamp = dateFormatter.string(from: date!) return timeStamp }
extension String { func toDateTime() -> NSDate { let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd hh:mm:ss.SSSSxxx" let dateFromString : NSDate = dateFormatter.dateFromString(self)! return dateFromString } }
import Foundation extension DateFormatter { convenience init (format: String) { self.init() dateFormat = format locale = Locale.current } } extension String { func toDate (format: String) -> Date? { return DateFormatter(format: format).date(from: self) } func toDateString (inputFormat: String, outputFormat:String) -> String? { if let date = toDate(format: inputFormat) { return DateFormatter(format: outputFormat).string(from: date) } return nil } } extension Date { func toString (format:String) -> String? { return DateFormatter(format: format).string(from: self) } }
var dateString = "14.01.2017T14:54:00" let format = "dd.MM.yyyy let date = Date() print("original String with date: \(dateString)") print("date String() to Date(): \(dateString.toDate(format: format)!)") print("date String() to formated date String(): \(dateString.toDateString(inputFormat: format, outputFormat: "dd MMMM")!)") print("format Date(): \(date.toString(format: "dd MMM HH:mm")!)")
func stringToDate(_ str: String)->Date{ let formatter = DateFormatter() formatter.dateFormat="yyyy-MM-dd hh:mm:ss Z" return formatter.date(from: str)! } func dateToString(_ str: Date)->String{ var dateFormatter = DateFormatter() dateFormatter.timeStyle=DateFormatter.Style.short return dateFormatter.string(from: str) }
let df : DateFormatter = { let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd" return formatter }()
extension NSDate { convenience init(dateString:String) { let dateStringFormatter = NSDateFormatter() dateStringFormatter.dateFormat = "yyyyMMdd" dateStringFormatter.locale = NSLocale(localeIdentifier: "fr_CH_POSIX") let d = dateStringFormatter.dateFromString(dateString)! self.init(timeInterval:0, sinceDate:d) } }
let myDateObject = NSDate(dateString:"2010-12-15 06:00:00")
let dateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd /* date format string rules * http: */ let date = dateFormatter.date(from: dateString)
let date = Date() let dateFormatter = DateFormatter() dateFormatter.dateFormat = "dd.MM.yyyy" let todaysDateInUKFormat = dateFormatter.string(from: date)
let someDateInString = "23.06.2017" var getDateFromString = dateFormatter.date(from: someDateInString)
func convertDateStringToDate(longDate: String) -> String{ /* INPUT: longDate = "2017-01-27T05:00:00.000Z" * OUTPUT: "1/26/17" * date_format_you_want_in_string from * http: */ let dateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd let date = dateFormatter.date(from: longDate) if date != nil { let formatter = DateFormatter() formatter.dateStyle = .short let dateShort = formatter.string(from: date!) return dateShort } else { return longDate } }
var dataFormatter:NSDateFormatter = NSDateFormatter() dataFormatter.dateFormat = "dd-MMMM cell.timeStamplbl.text = dataFormatter.stringFromDate(object.createdAt)
import Foundation import UIKit private func parseDate(_ dateStr: String) -> String { let simpleDateFormat = DateFormatter() simpleDateFormat.dateFormat = "dd/MM/yyyy" let dateFormat = DateFormatter() dateFormat.dateFormat = "dd let date = simpleDateFormat.date(from: dateStr) return dateFormat.string(from: date!) }
Swift: iOS if we have string, convert it to NSDate, var dataString = profileValue["dob"] as String var dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "MM-dd-yyyy" let dateValue:NSDate? = dateFormatter.dateFromString(dataString) if you have and date picker parse date like this if let isDate = dateValue { self.datePicker.date = isDate }
let dateFormatter = DateFormatter() dateFormatter.dateFormat = "dd/MM/yyyy" dateFormatter.timeZone = TimeZone(abbreviation: "GMT+0:00") let convertedDateObject = dateFormatter.date(from: strDate)
import Foundation let now : String = "2014-07-16 03:03:34 PDT" var date : NSDate var dateFormatter : NSDateFormatter date = dateFormatter.dateFromString(now) date
class FirstViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet var refresh: UIScreenEdgePanGestureRecognizer @IBOutlet var newsCollect: UITableView var activityIndicator:UIActivityIndicatorView? = nil override func viewDidLoad() { super.viewDidLoad() self.newsCollect.scrollEnabled = true if nCollect.news.count <= 2{ self.collectNews() } else{ self.removeActivityIndicator() } view.addGestureRecognizer(refresh) } @IBAction func reload(sender: UIScreenEdgePanGestureRecognizer) { nCollect.news = News[]() return newsCollect.reloadData() }
var refreshControl = UIRefreshControl() override func viewDidLoad() { super.viewDidLoad() refreshControl.attributedTitle = NSAttributedString(string: "Pull to refresh") refreshControl.addTarget(self, action: tableView.addSubview(refreshControl) } @objc func refresh(sender:AnyObject) { }
self.refreshControl?.addTarget(self, action: "refresh:", forControlEvents: UIControlEvents.ValueChanged)
func refresh(sender:AnyObject) { self.tableView.reloadData() self.refreshControl?.endRefreshing() }
@IBOutlet weak var collectionView: UICollectionView! override func viewDidLoad() { super.viewDidLoad() let refreshControl = UIRefreshControl() refreshControl.addTarget(self, action: collectionView.refreshControl = refreshControl } func doSomething(refreshControl: UIRefreshControl) { print("Hello World!") refreshControl.endRefreshing() }
if collectionView.refreshControl = refreshControl } else { collectionView.addSubview(refreshControl) }
var refreshControl: UIRefreshControl! override func viewDidLoad() { super.viewDidLoad() refreshControl = UIRefreshControl() refreshControl.attributedTitle = NSAttributedString(string: "Pull to refresh") refreshControl.addTarget(self, action: tableView.addSubview(refreshControl) } @objc func refresh(_ sender: Any) { }
override func viewDidLoad() { super.viewDidLoad() addPullToRefreshToWebView() } func addPullToRefreshToWebView(){ var refreshController:UIRefreshControl = UIRefreshControl() refreshController.bounds = CGRectMake(0, 50, refreshController.bounds.size.width, refreshController.bounds.size.height) refreshController.addTarget(self, action: Selector("refreshWebView:"), forControlEvents: UIControlEvents.ValueChanged) refreshController.attributedTitle = NSAttributedString(string: "Pull down to refresh...") YourWebView.scrollView.addSubview(refreshController) } func refreshWebView(refresh:UIRefreshControl){ YourWebView.reload() refresh.endRefreshing() }
private let tableViewController = UITableViewController() self.addChildViewController(self.tableViewController) self.tableViewController.tableView = self.tableView self.refreshControl.addTarget(self, action: "refreshData:", forControlEvents: .ValueChanged) self.tableViewController.refreshControl = self.refreshControl
import Foundation import UIKit var tableRefreshControl:UIRefreshControl = UIRefreshControl() public extension UIViewController { func makePullToRefreshToTableView(tableName: UITableView,triggerToMethodName: String){ tableRefreshControl.attributedTitle = NSAttributedString(string: "TEST: Pull to refresh") tableRefreshControl.backgroundColor = UIColor.whiteColor() tableRefreshControl.addTarget(self, action: Selector(triggerToMethodName), forControlEvents: UIControlEvents.ValueChanged) tableName.addSubview(tableRefreshControl) } func makePullToRefreshEndRefreshing (tableName: String) { tableRefreshControl.endRefreshing() } }
override func viewWillAppear(animated: Bool) { self.makePullToRefreshToTableView(bidderListTable, triggerToMethodName: "pullToRefreshBidderTable") }
func pullToRefreshBidderTable() { self.makePullToRefreshEndRefreshing("bidderListTable") } OR self.makePullToRefreshEndRefreshing("bidderListTable")
import UIKit protocol PullToRefreshTableViewDelegate : class { func tableViewDidStartRefreshing(tableView: PullToRefreshTableView) } class PullToRefreshTableView: UITableView { @IBOutlet weak var pullToRefreshDelegate: AnyObject? private var refreshControl: UIRefreshControl! private var isFirstLoad = true override func willMoveToSuperview(newSuperview: UIView?) { super.willMoveToSuperview(newSuperview) if (isFirstLoad) { addRefreshControl() isFirstLoad = false } } private func addRefreshControl() { refreshControl = UIRefreshControl() refreshControl.attributedTitle = NSAttributedString(string: "Pull to refresh") refreshControl.addTarget(self, action: "refresh", forControlEvents: .ValueChanged) self.addSubview(refreshControl) } @objc private func refresh() { (pullToRefreshDelegate as? PullToRefreshTableViewDelegate)?.tableViewDidStartRefreshing(self) } func endRefreshing() { refreshControl.endRefreshing() } }
refreshControl = UIRefreshControl() refreshControl!.addTarget(self, action: "configureMessages", forControlEvents: .ValueChanged) refreshControl!.beginRefreshing() configureMessages() func configureMessages() { self.refreshControl!.endRefreshing() }
func Refresher() { let loadingView = DGElasticPullToRefreshLoadingViewCircle() loadingView.tintColor = UIColor(red: 255.0/255.0, green: 255.0/255.0, blue: 255.0/255.0, alpha: 1.0) self.table.dg_addPullToRefreshWithActionHandler({ [weak self] () -> Void in print("Stack Overflow") self?.table.dg_stopLoading() }, loadingView: loadingView) self.table.dg_setPullToRefreshFillColor(UIColor(red: 255.0/255.0, green: 57.0/255.0, blue: 66.0/255.0, alpha: 1)) self.table.dg_setPullToRefreshBackgroundColor(self.table.backgroundColor!) }
override func viewDidDisappear(_ animated: Bool) { table.dg_removePullToRefresh() }
let refresh = UIRefreshControl() refresh.addTarget(self, action: refresh.tintColor = UIColor.appBlack self.tblAddressBook.addSubview(refresh) } @objc func handleTopRefresh(_ sender:UIRefreshControl){ self.callAddressBookListApi(isLoaderRequired: false) sender.endRefreshing() }
override func viewDidLoad() { super.viewDidLoad() self.refreshControl?.addTarget(self, action: "handleRefresh:", forControlEvents: UIControlEvents.ValueChanged) }
button.backgroundColor = .clear button.layer.cornerRadius = 5 button.layer.borderWidth = 1 button.layer.borderColor = UIColor.black.cgColor
@IBDesignable extension UIButton { @IBInspectable var borderWidth: CGFloat { set { layer.borderWidth = newValue } get { return layer.borderWidth } } @IBInspectable var cornerRadius: CGFloat { set { layer.cornerRadius = newValue } get { return layer.cornerRadius } } @IBInspectable var borderColor: UIColor? { set { guard let uiColor = newValue else { return } layer.borderColor = uiColor.cgColor } get { guard let color = layer.borderColor else { return nil } return UIColor(cgColor: color) } } }
class BorderedButton: UIButton { required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) layer.borderWidth = 1.0 layer.borderColor = tintColor.CGColor layer.cornerRadius = 5.0 clipsToBounds = true contentEdgeInsets = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8) setTitleColor(tintColor, forState: .Normal) setTitleColor(UIColor.whiteColor(), forState: .Highlighted) setBackgroundImage(UIImage(color: tintColor), forState: .Highlighted) } }
// // import UIKit @IBDesignable class RoundedButton:UIButton { @IBInspectable var borderWidth: CGFloat = 0 { didSet { layer.borderWidth = borderWidth } } @IBInspectable var normalBorderColor: UIColor? { didSet { layer.borderColor = normalBorderColor?.CGColor } } @IBInspectable var normalBackgroundColor: UIColor? { didSet { setBgColorForState(normalBackgroundColor, forState: .Normal) } } @IBInspectable var highlightedBorderColor: UIColor? @IBInspectable var highlightedBackgroundColor: UIColor? { didSet { setBgColorForState(highlightedBackgroundColor, forState: .Highlighted) } } private func setBgColorForState(color: UIColor?, forState: UIControlState){ if color != nil { setBackgroundImage(UIImage.imageWithColor(color!), forState: forState) } else { setBackgroundImage(nil, forState: forState) } } override func layoutSubviews() { super.layoutSubviews() layer.cornerRadius = layer.frame.height / 2 clipsToBounds = true if borderWidth > 0 { if state == .Normal && !CGColorEqualToColor(layer.borderColor, normalBorderColor?.CGColor) { layer.borderColor = normalBorderColor?.CGColor } else if state == .Highlighted && highlightedBorderColor != nil{ layer.borderColor = highlightedBorderColor!.CGColor } } } } extension UIImage { class func imageWithColor(color: UIColor) -> UIImage { let rect: CGRect = CGRectMake(0, 0, 1, 1) UIGraphicsBeginImageContextWithOptions(CGSizeMake(1, 1), false, 1.0) color.setFill() UIRectFill(rect) let image: UIImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }
class RoundedRectButton: UIButton { var selectedState: Bool = false override func awakeFromNib() { super.awakeFromNib() layer.borderWidth = 2 / UIScreen.main.nativeScale layer.borderColor = UIColor.white.cgColor contentEdgeInsets = UIEdgeInsets(top: 0, left: 5, bottom: 0, right: 5) } override func layoutSubviews(){ super.layoutSubviews() layer.cornerRadius = frame.height / 2 backgroundColor = selectedState ? UIColor.white : UIColor.clear self.titleLabel?.textColor = selectedState ? UIColor.green : UIColor.white } override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { selectedState = !selectedState self.layoutSubviews() } }
@IBOutlet weak var yourButton: UIButton! { didSet{ yourButton.backgroundColor = .clear yourButton.layer.cornerRadius = 10 yourButton.layer.borderWidth = 2 yourButton.layer.borderColor = UIColor.white.cgColor } }
protocol Traceable { var cornerRadius: CGFloat { get set } var borderColor: UIColor? { get set } var borderWidth: CGFloat { get set } } extension UIView: Traceable { @IBInspectable var cornerRadius: CGFloat { get { return layer.cornerRadius } set { layer.masksToBounds = true layer.cornerRadius = newValue } } @IBInspectable var borderColor: UIColor? { get { guard let cgColor = layer.borderColor else { return nil } return UIColor(cgColor: cgColor) } set { layer.borderColor = newValue?.cgColor } } @IBInspectable var borderWidth: CGFloat { get { return layer.borderWidth } set { layer.borderWidth = newValue } } }
@IBDesignable class BHButton: UIButton { /* override func draw(_ rect: CGRect) { } */ @IBInspectable lazy var isRoundRectButton : Bool = false @IBInspectable public var cornerRadius : CGFloat = 0.0 { didSet{ setUpView() } } @IBInspectable public var borderColor : UIColor = UIColor.clear { didSet { self.layer.borderColor = borderColor.cgColor } } @IBInspectable public var borderWidth : CGFloat = 0.0 { didSet { self.layer.borderWidth = borderWidth } } override func awakeFromNib() { super.awakeFromNib() setUpView() } override func prepareForInterfaceBuilder() { super.prepareForInterfaceBuilder() setUpView() } func setUpView() { if isRoundRectButton { self.layer.cornerRadius = self.bounds.height/2; self.clipsToBounds = true } else{ self.layer.cornerRadius = self.cornerRadius; self.clipsToBounds = true } } }
NSString* str = @"abcdefghi"; [str rangeOfString:@"c"].location;
var str = "abcdefghi" str.rangeOfString("c").startIndex
let text = "abc" let index2 = text.index(text.startIndex, offsetBy: 2) let lastChar: Character = text[index2] let characterIndex2 = text.index(text.startIndex, offsetBy: 2) let lastChar2 = text[characterIndex2] let range: Range<String.Index> = text.range(of: "b")! let index: Int = text.distance(from: text.startIndex, to: range.lowerBound)
let text = "abc" let index2 = text.index(text.startIndex, offsetBy: 2) let lastChar: Character = text[index2] let characterIndex2 = text.characters.index(text.characters.startIndex, offsetBy: 2) let lastChar2 = text.characters[characterIndex2] let range: Range<String.Index> = text.range(of: "b")! let index: Int = text.distance(from: text.startIndex, to: range.lowerBound)
let text = "abc" let index2 = text.startIndex.advancedBy(2) let lastChar: Character = text[index2] let lastChar2 = text.characters[index2] let range: Range<String.Index> = text.rangeOfString("b")! let index: Int = text.startIndex.distanceTo(range.startIndex)
let text = "abc" let index2 = advance(text.startIndex, 2) let lastChar: Character = text[index2] let range = text.rangeOfString("b") let index: Int = distance(text.startIndex, range.startIndex)
let text: String = "abc" let text2: String = "üéæüèáüèà" let range = text.rangeOfString("b")! let substring: String = text2[range] let intIndex: Int = text.startIndex.distanceTo(range.startIndex) let startIndex2 = text2.startIndex.advancedBy(intIndex) let range2 = startIndex2...startIndex2 let substring: String = text2[range2]
let text: String = "abc" let text2: String = "üéæüèáüèà" let range = text.rangeOfString("b") let substring: String = text2[range] let intIndex: Int = distance(text.startIndex, range.startIndex) let startIndex2 = advance(text2.startIndex, intIndex) let range2 = startIndex2...startIndex2 let substring: String = text2[range2]
let string = "Hello.World" let needle: Character = "." if let idx = string.characters.index(of: needle) { let pos = string.characters.distance(from: string.startIndex, to: idx) print("Found \(needle) at position \(pos)") } else { print("Not found") }
extension String { public func index(of char: Character) -> Int? { if let idx = characters.index(of: char) { return characters.distance(from: startIndex, to: idx) } return nil } }
let string = "Hello.World" let needle: Character = "." if let idx = string.characters.indexOf(needle) { let pos = string.startIndex.distanceTo(idx) print("Found \(needle) at position \(pos)") } else { print("Not found") }
extension String { public func indexOfCharacter(char: Character) -> Int? { if let idx = self.characters.indexOf(char) { return self.startIndex.distanceTo(idx) } return nil } }
let string = "Hello.World" let needle: Character = "." if let idx = find(string, needle) { let pos = distance(string.startIndex, idx) println("Found \(needle) at position \(pos)") } else { println("Not found") }
extension String { public func indexOfCharacter(char: Character) -> Int? { if let idx = find(self, char) { return distance(self.startIndex, idx) } return nil } }
extension String { func substringToIndex(index:Int) -> String { return self.substringToIndex(advance(self.startIndex, index)) } func substringFromIndex(index:Int) -> String { return self.substringFromIndex(advance(self.startIndex, index)) } func substringWithRange(range:Range<Int>) -> String { let start = advance(self.startIndex, range.startIndex) let end = advance(self.startIndex, range.endIndex) return self.substringWithRange(start..<end) } subscript(index:Int) -> Character{ return self[advance(self.startIndex, index)] } subscript(range:Range<Int>) -> String { let start = advance(self.startIndex, range.startIndex) let end = advance(self.startIndex, range.endIndex) return self[start..<end] } func replaceCharactersInRange(range:Range<Int>, withString: String!) -> String { var result:NSMutableString = NSMutableString(string: self) result.replaceCharactersInRange(NSRange(range), withString: withString) return result } }
var str = "abcdefghi" let indexForCharacterInString = str.characters.indexOf("c")
"abcdefghi".bridgeToObjectiveC().rangeOfString("c").location
extension String { var length:Int { return self.characters.count } func indexOf(target: String) -> Int? { let range = (self as NSString).range(of: target) guard range.toRange() != nil else { return nil } return range.location } func lastIndexOf(target: String) -> Int? { let range = (self as NSString).range(of: target, options: NSString.CompareOptions.backwards) guard range.toRange() != nil else { return nil } return self.length - range.location - 1 } func contains(s: String) -> Bool { return (self.range(of: s) != nil) ? true : false } }
extension String { var length:Int { return self.characters.count } func indexOf(target: String) -> Int? { let range = (self as NSString).rangeOfString(target) guard range.toRange() != nil else { return nil } return range.location } func lastIndexOf(target: String) -> Int? { let range = (self as NSString).rangeOfString(target, options: NSStringCompareOptions.BackwardsSearch) guard range.toRange() != nil else { return nil } return self.length - range.location - 1 } func contains(s: String) -> Bool { return (self.rangeOfString(s) != nil) ? true : false } }
var someString: NSString = "abcdefghi" var someRange: NSRange = someString.rangeOfString("c")
var str : String = "abcdefghi" let characterToFind: Character = "c" let characterIndex = find(str, characterToFind)
func indexInt(of char: Character) -> Int? { return index(of: char)?.encodedOffset }
extension String { func indexes(of character: String) -> [Int] { precondition(character.count == 1, "Must be single character") return self.enumerated().reduce([]) { partial, element in if String(element.element) == character { return partial + [element.offset] } return partial } } }
"apple".indexes(of: "p") "element".indexes(of: "e") "swift".indexes(of: "j")
var loc = "abcdefghi".rangeOfString("c").location NSLog("%d", loc);
var myRange: NSRange = "abcdefghi".rangeOfString("c") var loc = myRange.location NSLog("%d", loc);
let myString = "hello" let rangeOfE = myString.rangeOfString("e") if let rangeOfE = rangeOfE { myString.substringWithRange(rangeOfE) myString[rangeOfE] let index = rangeOfE.startIndex myString.substringWithRange(Range<String.Index>(start: index, end: advance(index, 1))) let numericIndex = distance(index, advance(index, 1)) }
var textViewString:String = "HelloWorld2016" guard let index = textViewString.characters.index(of: "W") else { return } let mentionPosition = textViewString.distance(from: index, to: textViewString.endIndex) print(mentionPosition)
var str = "abcdefghi" as NSString str.rangeOfString("c").locationx
var letters = "abcdefg" let index = letters.characters.indexOf("c")! range = letters.characters.indexOf("c")!...letters.characters.indexOf("c")! letters.removeRange(range) letters
extension String { public func firstIndexOfCharacter(aCharacter: Character) -> String.CharacterView.Index? { for index in self.characters.indices { if self[index] == aCharacter { return index } } return nil } public func returnCountOfThisCharacterInString(aCharacter: Character) -> Int? { var count = 0 for letters in self.characters{ if aCharacter == letters{ count++ } } return count } public func rangeToCharacterFromStart(aCharacter: Character) -> Range<Index>? { for index in self.characters.indices { if self[index] == aCharacter { let range = self.startIndex...index return range } } return nil } } var MyLittleString = "MyVery:important String" var theIndex = MyLittleString.firstIndexOfCharacter(":") var countOfColons = MyLittleString.returnCountOfThisCharacterInString(":") var theCharacterAtIndex:Character = MyLittleString[theIndex!] var theRange = MyLittleString.rangeToCharacterFromStart(":") MyLittleString.removeRange(theRange!)
let a = "01234" print(a[0]) print(a[0...4]) print(a[...]) print(a[..<2]) print(a[...2]) print(a[2...]) print(a[2...3]) print(a[2...2]) if let number = a.index(of: "1") { print(number) print(a[number...]) } if let number = a.index(where: { $0 > "1" }) { print(number) }
let text = "abc" if let range = text.rangeOfString("b") { var index: Int = text.startIndex.distanceTo(range.startIndex) ... }
var stringMe="Something In this.World" var needle="." if let idx = stringMe.characters.indexOf(needle) { let pos=stringMe.substringFromIndex(idx) print("Found \(needle) at position \(pos)") } else { print("Not found") }
let mystring:String = "indeep"; let findCharacter:Character = "d"; if (mystring.characters.contains(findCharacter)) { let position = mystring.characters.indexOf(findCharacter); NSLog("Position of c is \(mystring.startIndex.distanceTo(position!))") } else { NSLog("Position of c is not found"); }
extension String { func allCharactes() -> [Character] { var result: [Character] = [] for c in self.characters { result.append(c) } return } }
let index = string.characters.index(of: ".") let intIndex = string.distance(from: string.startIndex, to: index)
public extension Int { init(_ index: String.Index, in string: String) { self.init(string.distance(from: string.startIndex, to: index)) } }
var testString = "abcdefg" Int(testString.range(of: "c")!.lowerBound, in: testString) testString = "üá®üá¶üá∫üá∏üá©üá™üë©‚Äçüë©‚Äçüëß‚Äçüë¶\u{1112}\u{1161}\u{11AB}" Int(testString.range(of: "üá®üá¶üá∫üá∏üá©üá™")!.lowerBound, in: testString) Int(testString.range(of: "üë©‚Äçüë©‚Äçüëß‚Äçüë¶")!.lowerBound, in: testString) Int(testString.range(of: "·Ñí·Ö°·Ü´")!.lowerBound, in: testString)
func substring(before sub: String) -> String { if let range = self.rangeOfString(sub), let index: Int = self.startIndex.distanceTo(range.startIndex) { return sub_range(0, index) } return "" }
func index(of target: String) -> Int? { if let range = self.range(of: target) { return characters.distance(from: startIndex, to: range.lowerBound) } else { return nil } } func lastIndex(of target: String) -> Int? { if let range = self.range(of: target, options: .backwards) { return characters.distance(from: startIndex, to: range.lowerBound) } else { return nil } }
extension String { func substring(from:String) -> String { let searchingString = from let rangeOfSearchingString = self.range(of: searchingString)! let indexOfSearchingString: Int = self.distance(from: self.startIndex, to: rangeOfSearchingString.upperBound ) let trimmedString = self.substring(start: indexOfSearchingString , end: self.count) return trimmedString } }
let strx = "0123456789ABCDEF" let si = strx.index(of: "A") let i = si?.encodedOffset if i != nil { print("i = ",i) print("i = ",i!) let ii = i! print("ii = ",ii) }
do { let dragon = try summonDefaultDragon() } catch DragonError.dragonIsMissing { } catch DragonError.notEnoughMana(let manaRequired) { } catch { }
func fulfill(quest: Quest) throws { let dragon = try summonDefaultDragon() quest.ride(dragon) }
guard let dragon = try? summonDefaultDragon() else { ... }
enum DragonError: ErrorType { case dragonIsMissing case notEnoughMana(requiredMana: Int) ... }
var sessionManager = AFHTTPSessionManager(baseURL: NSURL(string: "yavin4.yavin.planets")) sessionManager.HEAD("/api/destoryDeathStar", parameters: xwingSquad, success: { (NSURLSessionDataTask) -> Void in println("Success") }, failure:{ (NSURLSessionDataTask, NSError) -> Void in println("Failure") })
NSException(name: "SomeName", reason: "SomeReason", userInfo: nil).raise()
NSFileManager *fileManager = [NSFileManager defaultManager]; NSURL *URL = [NSURL fileURLWithPath:@"/path/to/file"]; NSError *error = nil; BOOL success = [fileManager removeItemAtURL:URL error:&error]; if (!success && error){ NSLog(@"Error: %@", error.domain); }
let fileManager = NSFileManager.defaultManager() let URL = NSURL.fileURLWithPath("path/to/file") do { try fileManager.removeItemAtURL(URL) } catch let error as NSError { print ("Error: \(error.domain)") }
*errorPtr = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorCannotOpenFile userInfo: nil]
throw NSError(domain: NSURLErrorDomain, code: NSURLErrorCannotOpenFile, userInfo: nil)
enum ServerResponse { case Result(String, String) case Error(String) } let success = ServerResponse.Result("6:00 am", "8:09 pm") let failure = ServerResponse.Error("Out of cheese.") switch success { case let .Result(sunrise, sunset): let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)." case let .Error(error): let serverResponse = "Failure... \(error)" }
let myLength = myObject.length? let myChar = myObject.characterAtIndex?(5) if let fifthCharacter = myObject.characterAtIndex(5) { println("Found \(fifthCharacter) at index 5") }
var writeError : NSError? let written = myString.writeToFile(path, atomically: false, encoding: NSUTF8StringEncoding, error: &writeError) if !written { if let error = writeError { println("write failure: \(error.localizedDescription)") } }
var error: NSError? var contents = NSFileManager.defaultManager().contentsOfDirectoryAtPath("/Users/leandros", error: &error) if let error = error { println("An error occurred \(error)") } else { println("Contents: \(contents)") }
func write(path: String)( return "Hello!".writeToFile(path, atomically: false, encoding: NSUTF8StringEncoding, error: error) } var writeError: NSError? let written = write("~/Error1")(error: &writeError) if !written { println("write failure 1: \(writeError!.localizedDescription)") }
TryBool { write("~/Error2")(error: $0) }.catch { println("write failure 2: \($0!.localizedDescription)") }
TryBool { write("~/Error3")(error: $0) }.retry { println("write failure 3 on try \($1 + 1): \($0!.localizedDescription)") return write("~/Error3r") }.catch { println("write failure 3 catch: \($0!.localizedDescription)") }
class TryBool { typealias Tryee = NSErrorPointer -> Bool typealias Catchee = NSError? -> () typealias Retryee = (NSError?, UInt) -> Tryee private var tryee: Tryee private var retries: UInt = 0 private var retryee: Retryee? init(tryee: Tryee) { self.tryee = tryee } func retry(retries: UInt, retryee: Retryee) -> Self { self.retries = retries self.retryee = retryee return self } func retry(retryee: Retryee) -> Self { return self.retry(1, retryee) } func retry(retries: UInt) -> Self { self.retries = retries retryee = nil return self } func retry() -> Self { return retry(1) } func catch(catchee: Catchee) { var error: NSError? for numRetries in 0...retries { error = nil let result = tryee(&error) if result { return } else if numRetries != retries { if let r = retryee { tryee = r(error, numRetries) } } } catchee(error) } }
class TryOptional<T> { typealias Tryee = NSErrorPointer -> T? typealias Catchee = NSError? -> T typealias Retryee = (NSError?, UInt) -> Tryee private var tryee: Tryee private var retries: UInt = 0 private var retryee: Retryee? init(tryee: Tryee) { self.tryee = tryee } func retry(retries: UInt, retryee: Retryee) -> Self { self.retries = retries self.retryee = retryee return self } func retry(retryee: Retryee) -> Self { return retry(1, retryee) } func retry(retries: UInt) -> Self { self.retries = retries retryee = nil return self } func retry() -> Self { return retry(1) } func catch(catchee: Catchee) -> T { var error: NSError? for numRetries in 0...retries { error = nil let result = tryee(&error) if let r = result { return r } else if numRetries != retries { if let r = retryee { tryee = r(error, numRetries) } } } return catchee(error) } }
struct FailableInitializer { init?(_ id: Int, error: NSErrorPointer) { if error != nil { error.memory = NSError(domain: "", code: id, userInfo: [:]) } return nil } private init() { } static let fallback = FailableInitializer() } func failableInitializer(id: Int)( return FailableInitializer(id, error: error) } var failError: NSError? var failure1Temp = failableInitializer(1)(error: &failError) if failure1Temp == nil { println("failableInitializer failure code: \(failError!.code)") failure1Temp = FailableInitializer.fallback } let failure1 = failure1Temp!
let failure2 = TryOptional { failableInitializer(2)(error: $0) }.catch { println("failableInitializer failure code: \($0!.code)") return FailableInitializer.fallback } let failure3 = TryOptional { failableInitializer(3)(error: $0) }.retry { println("failableInitializer failure, on try \($1 + 1), code: \($0!.code)") return failableInitializer(31) }.catch { println("failableInitializer failure code: \($0!.code)") return FailableInitializer.fallback }
var fooError : NSError ? = nil let someObject = foo(aParam, error:&fooError) if !someObject { if let error = fooError { NSLog("This happened: \(error.localizedDescription)") } } else { }`
func foo(param:ParamObject, error: NSErrorPointer) -> SomeObject { if somethingBadHasHappened { if error { error.memory = NSError(domain: domain, code: code, userInfo: [:]) } return nil } }
SwiftTryCatch.try({ () -> Void in }, catch: { (error) -> Void in }, finally: { () -> Void in })
func loadData() throws { } func test() { do { try loadData() } catch { print(error) }}
do { let fetchedResults = try managedContext.executeFetchRequest(fetchRequest) as? [NSManagedObject] if let results = fetchedResults{ people = results } } catch { print("Could not fetch") }
typealias LoadDataResult = () throws -> NSData func loadData(someID: String, completionHandler: LoadDataResult -> Void) { completionHandler() }
self.loadData("someString", completionHandler: { result: LoadDataResult in do { let data = try result() } catch { } })
try { println(" try") }.catch { e in println(" catch") }.finally { println(" finally") }
button.setTitle("Button Title", forState: UIControlState.Normal)
button.setTitle("myTitle", forState: UIControlState.Normal)
my_btn.setTitle("Button Title", for: .normal) my_btn.setTitle("Button Title2", for: .highlighted)
for state: UIControlState in [.normal, .highlighted, .disabled, .selected, .focused, .application, .reserved] { button.setTitle(NSLocalizedString("Title", comment: ""), for: state) }
my_btn.setAttributedTitle(NSAttributedString(string: my_title), for: my_state)
@IBAction func btnAction(_ sender: UIButton) { sender.setTitle("string goes here", for: .normal) }
let button: UIButton = UIButton() button.frame = CGRect.init(x: view.frame.width/2, y: view.frame.height/2, width: 100, height: 100) button.setTitle(‚ÄúTitle Button‚Äù, for: .normal)
func setTitle(_ title : String?, for state : UIControl.State) { }
extension String { func capitalizingFirstLetter() -> String { let first = String(characters.prefix(1)).capitalized let other = String(characters.dropFirst()) return first + other } mutating func capitalizeFirstLetter() { self = self.capitalizingFirstLetter() } }
extension String { func capitalizingFirstLetter() -> String { return prefix(1).uppercased() + self.lowercased().dropFirst() } mutating func capitalizeFirstLetter() { self = self.capitalizingFirstLetter() } }
extension StringProtocol { var firstUppercased: String { guard let first = first else { return "" } return String(first).uppercased() + dropFirst() } var firstCapitalized: String { guard let first = first else { return "" } return String(first).capitalized + dropFirst() } }
"Swift".first "Swift".last "hello world!!!".firstUppercased "«Ñ".firstCapitalized "«Ö".firstCapitalized "«Ü".firstCapitalized
extension String { func firstCharacterUpperCase() -> String { let lowercaseString = self.lowercaseString return lowercaseString.stringByReplacingCharactersInRange(lowercaseString.startIndex...lowercaseString.startIndex, withString: String(lowercaseString[lowercaseString.startIndex]).uppercaseString) } } let x = "heLLo" let m = x.firstCharacterUpperCase()
String(nameOfString.characters.prefix(1)).uppercaseString + String(nameOfString.characters.dropFirst())
var s: String = "hello world" s = prefix(s, 1).capitalizedString + suffix(s, countElements(s) - 1)
extension String { var capitalizeFirst: String { if self.characters.count == 0 { return self return String(self[self.startIndex]).capitalized + String(self.characters.dropFirst()) } }
let str = "your string" let capStr = str.capitalized
let str = "your string" let upStr = str.uppercased()
var str = "your string" let capStr = String(str.characters.prefix(1)).uppercased() + String(str.characters.dropFirst())
import Foundation extension String { var toProper:String { var result = lowercaseString result.replaceRange(startIndex...startIndex, with: String(self[startIndex]).capitalizedString) return result } }
func firstCharacterUppercaseString(string: String) -> String { var str = string as NSString let firstUppercaseCharacter = str.substringToIndex(1).uppercaseString let firstUppercaseCharacterString = str.stringByReplacingCharactersInRange(NSMakeRange(0, 1), withString: firstUppercaseCharacter) return firstUppercaseCharacterString }
extension String { var wordCaps:String { let listOfWords:[String] = self.componentsSeparatedByString(" ") var returnString: String = "" for word in listOfWords { if word != "" { var capWord = word.lowercaseString as String capWord.replaceRange(startIndex...startIndex, with: String(capWord[capWord.startIndex]).uppercaseString) returnString = returnString + capWord + " " } } if returnString.hasSuffix(" ") { returnString.removeAtIndex(returnString.endIndex.predecessor()) } return returnString } }
extension String { func firstCharacterUpperCase() -> String { if let firstCharacter = characters.first { return replacingCharacters(in: startIndex..<index(after: startIndex), with: String(firstCharacter).uppercased()) } return "" } }
func firstCharacterUpperCase() -> String { if self.count == 0 { return self } return prefix(1).uppercased() + dropFirst().lowercased() }
func capitalizedPhrase(phrase:String) -> String { let firstCharIndex = advance(phrase.startIndex, 1) let firstChar = phrase.substringToIndex(firstCharIndex).uppercaseString let firstCharRange = phrase.startIndex..<firstCharIndex return phrase.stringByReplacingCharactersInRange(firstCharRange, withString: firstChar) }
func helperCapitalizeFirstLetter(stringToBeCapd:String)->String{ let capString = stringToBeCapd.substringFromIndex(stringToBeCapd.startIndex).capitalizedString return capString }
nameOfString.replaceSubrange(nameOfString.startIndex...nameOfString.startIndex, with: String(nameOfString[nameOfString.startIndex]).capitalized)
extension String { var capitalizedFirst: String { let characters = self.characters if let first = characters.first { return String(first).uppercased() + String(characters.dropFirst()) } return self } }
extension String { var capEachWord: String { return self.split(separator: " ").map { word in return String([word.startIndex]).uppercased() + word.lowercased().dropFirst() }.joined(separator: " ") } }
labelTitle.text = remarks?.lowercased().firstUppercased
extension StringProtocol { var firstUppercased: String { guard let first = first else { return "" } return String(first).uppercased() + dropFirst() } }
extension String { var lowercased:String { var result = Array<Character>(self.characters); if let first = result.first { result[0] = Character(String(first).uppercaseString) } return String(result) } }
extension String { var wordUppercased: String { var aryOfWord = self.split(separator: " ") aryOfWord = aryOfWord.map({String($0.first!).uppercased() + $0.dropFirst()}) return aryOfWord.joined(separator: " ") } }
let interestingNumbers = [ "Prime": [2, 3, 5, 7, 11, 13], "Fibonacci": [1, 1, 2, 3, 5, 8], "Square": [1, 4, 9, 16, 25] ] var largest = 0 for (kind, numbers) in interestingNumbers { for number in numbers { if number > largest { largest = number } } } largest
let interestingNumbers = [ "Prime": [2, 3, 5, 7, 11, 13], "Fibonacci": [1, 1, 2, 3, 5, 8], "Square": [1, 4, 9, 16, 25] ] var largest = 0 for (kind, numbers) in interestingNumbers { println("kind: \(kind)") for number in numbers { if number > largest { largest = number } } } largest
let dict : [String : Any] = ["FirstName" : "Maninder" , "LastName" : "Singh" , "Address" : "Chandigarh"] dict.forEach { print($0) }
let interestingNumbers = [ "Prime": [2, 3, 5, 7, 11, 13], "Fibonacci": [1, 1, 2, 3, 5, 8], "Square": [1, 4, 9, 16, 25], ] var largest = 0 var whichKind: String? = nil for (kind, numbers) in interestingNumbers { for number in numbers { if number > largest { whichKind = kind largest = number } } } print(whichKind) print(largest) OUTPUT: Optional("Square") 25
func findDic(dict: [String: String]){ for (key, value) in dict{ print("\(key) : \(value)") } } findDic(dict: ["Animal":"Lion", "Bird":"Sparrow"]) Bird : Sparrow
NSData *imageData = UIImagePNGRepresentation(viewImage); NSString *b64EncStr = [self encode: imageData]; NSString *base64String = [self encodeBase64:imageData];
let image : UIImage = UIImage(named:"imageNameHere")! let imageData:NSData = UIImagePNGRepresentation(image)! let url:NSURL = NSURL(string : "urlHere")! let imageData:NSData = NSData.init(contentsOfURL: url)!
let strBase64:String = imageData.base64EncodedStringWithOptions(.Encoding64CharacterLineLength)
let dataDecoded:NSData = NSData(base64EncodedString: strBase64, options: NSDataBase64DecodingOptions.IgnoreUnknownCharacters)!
let dataDecoded : Data = Data(base64Encoded: strBase64, options: .ignoreUnknownCharacters)!
let strBase64 = imageData.base64EncodedString(options: .lineLength64Characters) print(strBase64)
let dataDecoded:NSData = NSData(base64EncodedString: strBase64, options: NSDataBase64DecodingOptions(rawValue: 0))! let decodedimage:UIImage = UIImage(data: dataDecoded)! print(decodedimage) yourImageView.image = decodedimage
let dataDecoded : Data = Data(base64Encoded: strBase64, options: .ignoreUnknownCharacters)! let decodedimage = UIImage(data: dataDecoded) yourImageView.image = decodedimage
- (NSString *)encodeToBase64String:(UIImage *)image { return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; }
- (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData { NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [UIImage imageWithData:data]; }
NSData* data = UIImageJPEGRepresentation(yourImage, 1.0f); NSString *strEncoded = [Base64 encode:data];
NSData* data = [Base64 decode:strEncoded ];; image.image = [UIImage imageWithData:data];
let url:NSURL = NSURL(string : "http: let imageData : NSData = NSData.init(contentsOf: url as URL)! let str64 = imageData.base64EncodedData(options: .lineLength64Characters) let data: NSData = NSData(base64Encoded: str64 , options: .ignoreUnknownCharacters)! let dataImage = UIImage(data: data as Data) testImage.image = dataImage
extension UIImage { func toBase64() -> String? { guard let imageData = self.pngData() else { return nil } return imageData.base64EncodedString(options: Data.Base64EncodingOptions.lineLength64Characters) } }
// // class func convertImageToBase64(image: UIImage) -> String { let imageData = UIImagePNGRepresentation(image)! return imageData.base64EncodedString(options: Data.Base64EncodingOptions.lineLength64Characters) } // // class func convertBase64ToImage(imageString: String) -> UIImage { let imageData = Data(base64Encoded: imageString, options: Data.Base64DecodingOptions.ignoreUnknownCharacters)! return UIImage(data: imageData)! }
func convertImageToBase64(image: UIImage) -> String { var imageData = UIImagePNGRepresentation(image) let base64String = imageData.base64EncodedStringWithOptions(.allZeros) return base64String } func convertBase64ToImage(base64String: String) -> UIImage { let decodedData = NSData(base64EncodedString: base64String, options: NSDataBase64DecodingOptions(rawValue: 0) ) var decodedimage = UIImage(data: decodedData!) return decodedimage! }
@implementation UIImage (Extended) - (NSString *)base64String { NSData * data = [UIImagePNGRepresentation(self) base64EncodedDataWithOptions:NSDataBase64Encoding64CharacterLineLength]; return [NSString stringWithUTF8String:[data bytes]]; } @end
var logo = UIImage(named: "image_logo") let imageData:Data = UIImagePNGRepresentation(logo) let base64String = imageData.base64EncodedString() print(base64String)
extension UIImage{ func toBase64() -> String{ let imageData = UIImagePNGRepresentation(self)! return imageData.base64EncodedStringWithOptions(.Encoding64CharacterLineLength) } }
extension UIImage{ func toBase64() -> String{ var imageData = UIImagePNGRepresentation(self) return imageData.base64EncodedStringWithOptions(.allZeros) } }
let userImage:UIImage = UIImage(named: "Your-Image_name")! let imageData:NSData = UIImagePNGRepresentation(userImage)! as NSData let dataImage = imageData.base64EncodedString(options: .lineLength64Characters)
let imageData = dataImage let dataDecode:NSData = NSData(base64Encoded: imageData!, options:.ignoreUnknownCharacters)! let avatarImage:UIImage = UIImage(data: dataDecode as Data)! yourImageView.image = avatarImage
func ConvertImageToBase64String (img: UIImage) -> String { let imageData:NSData = UIImageJPEGRepresentation(img, 0.50)! as NSData let imgString = imageData.base64EncodedString(options: .init(rawValue: 0)) return imgString }
func ConvertBase64StringToImage (imageBase64String:String) -> UIImage { let imageData = Data.init(base64Encoded: imageBase64String, options: .init(rawValue: 0)) let image = UIImage(data: imageData!) return image }
See my class - AppExtension.swift public enum ImageFormat { case PNG case JPEG(CGFloat) } extension UIImage { public func base64(format: ImageFormat) -> String { var imageData: NSData switch format { case .PNG: imageData = UIImagePNGRepresentation(self) case .JPEG(let compression): imageData = UIImageJPEGRepresentation(self, compression) } return imageData.base64EncodedStringWithOptions(.allZeros) } }
extension UIImage { func toBase64() -> String? { let imageData = UIImagePNGRepresentation(self) return imageData?.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.Encoding64CharacterLineLength) } }
func decodeBase64(toImage strEncodeData: String) -> UIImage { let dataDecoded = NSData(base64Encoded: strEncodeData, options: NSData.Base64DecodingOptions.ignoreUnknownCharacters)! let image = UIImage(data: dataDecoded as Data) return image! }
extension UIImage { public var base64: String { return self.jpegData(compressionQuality: 1.0)!.base64EncodedString() } }
enum ImageFormat { case png case jpeg(CGFloat) } extension UIImage { func base64(format: ImageFormat) -> String? { var imageData: Data? switch format { case .png: imageData = UIImagePNGRepresentation(self) case .jpeg(let compression): imageData = UIImageJPEGRepresentation(self, compression) } return imageData?.base64EncodedString() } } extension String { func imageFromBase64() -> UIImage? { guard let data = Data(base64Encoded: self) else { return nil } return UIImage(data: data) } }
NSURL *url = [NSURL URLWithString:self.groove.thumbnailURL]; UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:url]]; NSString *base64String = [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];
let imageData = UIImageJPEGRepresentation(imageView.image!, 1) let base64String = (imageData! as Data).base64EncodedString(options: NSData.Base64EncodingOptions(rawValue: 0)) print(base64String)
let temp = base64String.components(separatedBy: ",") let dataDecoded : Data = Data(base64Encoded: temp[1], options: .ignoreUnknownCharacters)! let decodedimage = UIImage(data: dataDecoded) yourImage.image = decodedimage
navigationController?.navigationBar.barTintColor = UIColor.green
navigationController?.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.orange]
tabBarController?.tabBar.barTintColor = UIColor.brown
tabBarController?.tabBar.tintColor = UIColor.yellow
UINavigationBar.appearance().backgroundColor = UIColor.greenColor() UIBarButtonItem.appearance().tintColor = UIColor.magentaColor() UINavigationBar.appearance().titleTextAttributes = [UITextAttributeTextColor: UIColor.blueColor()] UITabBar.appearance().backgroundColor = UIColor.yellowColor();
UINavigationBar.appearance().barTintColor = UIColor(red: 46.0/255.0, green: 14.0/255.0, blue: 74.0/255.0, alpha: 1.0) UINavigationBar.appearance().tintColor = UIColor.whiteColor() UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName : UIColor.whiteColor()]
UINavigationBar.appearance().barTintColor = .black UINavigationBar.appearance().tintColor = .white UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName: UIColor.white] UINavigationBar.appearance().isTranslucent = false
UINavigationBar.appearance().barTintColor = .black UINavigationBar.appearance().tintColor = .white UINavigationBar.appearance().titleTextAttributes = [NSAttributedStringKey.foregroundColor: UIColor.white] UINavigationBar.appearance().isTranslucent = false
UINavigationBar.appearance().barTintColor = .black UINavigationBar.appearance().tintColor = .white UINavigationBar.appearance().titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white] UINavigationBar.appearance().isTranslucent = false
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { UINavigationBar.appearance().setBackgroundImage(UIImage(), forBarPosition: UIBarPosition.Any, barMetrics: UIBarMetrics.Default) UINavigationBar.appearance().shadowImage = UIImage() UINavigationBar.appearance().tintColor = UIColor.whiteColor() UINavigationBar.appearance().barTintColor = Style.SELECTED_COLOR UINavigationBar.appearance().translucent = false UINavigationBar.appearance().clipsToBounds = false UINavigationBar.appearance().backgroundColor = Style.SELECTED_COLOR UINavigationBar.appearance().titleTextAttributes = [NSFontAttributeName : (UIFont(name: "FONT NAME", size: 18))!, NSForegroundColorAttributeName: UIColor.whiteColor()] }
import Foundation import UIKit struct Style { static let availableThemes = ["Theme 1","Theme 2","Theme 3"] static func loadTheme(){ let defaults = NSUserDefaults.standardUserDefaults() if let name = defaults.stringForKey("Theme"){ if name == availableThemes[0] { theme1() } if name == availableThemes[1] { theme2() } if name == availableThemes[2] { theme3() } }else{ defaults.setObject(availableThemes[0], forKey: "Theme") theme1() } } static func theme1(){ static var SELECTED_COLOR = UIColor(red:70/255, green: 38/255, blue: 92/255, alpha: 1) } static func theme2(){ static var SELECTED_COLOR = UIColor(red:255/255, green: 255/255, blue: 255/255, alpha: 1) } static func theme3(){ static var SELECTED_COLOR = UIColor(red:90/255, green: 50/255, blue: 120/255, alpha: 1) } ...
@IBDesignable extension UINavigationController { @IBInspectable var barTintColor: UIColor? { set { guard let uiColor = newValue else { return } navigationBar.barTintColor = uiColor } get { guard let color = navigationBar.barTintColor else { return nil } return color } } }
@IBInspectable var barTextColor: UIColor? { set { guard let uiColor = newValue else {return} navigationBar.titleTextAttributes = [NSAttributedStringKey.foregroundColor: uiColor] } get { guard let textAttributes = navigationBar.titleTextAttributes else { return nil } return textAttributes[NSAttributedStringKey.foregroundColor] as? UIColor } }
var navBarColor = navigationController!.navigationBar navBarColor.barTintColor = UIColor(red: 255/255.0, green: 0/255.0, blue: 0/255.0, alpha: 100.0/100.0) navBarColor.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.whiteColor()]
var imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 70, height: 70)) imageView.contentMode = .ScaleAspectFit var image = UIImage(named: "logo") imageView.image = image navigationItem.titleView = imageView
override func willMove(toParentViewController parent: UIViewController?) { navigationController?.navigationBar.barTintColor = .white navigationController?.navigationBar.tintColor = Constants.AppColor }
UINavigationBar.appearance().barTintColor = UIColor.greenColor()
self.navigationController?.navigationBar.barTintColor = UIColor.white
self.navigationController?.navigationBar.titleTextAttributes = [NSAttributedStringKey.foregroundColor: UIColor.purple]
self.navigationController?.navigationBar.largeTitleTextAttributes = [NSAttributedStringKey.foregroundColor: UIColor.purple]
UINavigationBar.appearance().barTintColor = .init(red: 23.0/255, green: 197.0/255, blue: 157.0/255, alpha: 1.0) UINavigationBar.appearance().tintColor = .white UINavigationBar.appearance().titleTextAttributes = [.foregroundColor : UIColor.white, .font : UIFont.init(name: "AvenirNext-DemiBold", size: 22.0)!] UINavigationBar.appearance().isTranslucent = false
let font: UIFont = UIFont(name: "fontName", size: 17) let color = UIColor.backColor() self.navigationController?.navigationBar.topItem?.backBarButtonItem?.setTitleTextAttributes([NSFontAttributeName: font,NSForegroundColorAttributeName: color], forState: .Normal)
navigationController.navigationBar.barTintColor = UIColor.green
navigationController.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.orange]
navigationController?.navigationBar.barTintColor = UIColor.red
navigationController?.navigationBar.barTintColor = UIColor.whiteColor()
navigationController?.navigationBar.tintColor = UIColor.blueColor()
navigationController!.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.blueColor()]
UINavigationBar.appearance().barTintColor = UIColor(colorLiteralRed: 51/255, green: 90/255, blue: 149/255, alpha: 1)
import UIKit class NabigationBar: UINavigationBar { required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) commonFeatures() } func commonFeatures() { self.backgroundColor = UIColor.white; UINavigationBar.appearance().titleTextAttributes = [NSAttributedStringKey.foregroundColor:ColorConstants.orangeTextColor] } }
neraida.navigation.background.color.hexColor("54ad00", isTranslucent: false, viewController: self) neraida.navigation.foreground.color.uiColor(UIColor.white, viewController: self) neraida.navigation.foreground.backButtonTitle("Custom Title", ViewController: self) neraida.navigation.background.image("background", edge: (0,0,0,0), barMetrics: .default, isTranslucent: false, viewController: self)
self.navigationController?.navigationBar.barTintColor = UIColor.red self.navigationController?.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.white]
UINavigationBar.appearance().tintColor = UIColor.whiteColor() UINavigationBar.appearance().barStyle = .Black UINavigationBar.appearance().backgroundColor = UIColor.blueColor()
@IBOutlet var NavigationBar: UINavigationBar! NavigationBar.isTranslucent = false NavigationBar.barTintColor = UIColor (red: 117/255, green: 23/255, blue: 49/255, alpha: 1.0)
TAGS="TODO:|FIXME:" echo "searching ${SRCROOT} for ${TAGS}" find "${SRCROOT}" \( -name "*.swift" \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/"
if [ "${CONFIGURATION}" = "Debug" ]; then TAGS="TODO:|FIXME:" echo "searching ${SRCROOT} for ${TAGS}" find "${SRCROOT}" \( -name "*.swift" \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/" fi
@availability(iOS, deprecated=1.0, message="I func FIXME() { }
override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { FIXME() return 0 }
TAGS="TODO:|FIXME:" ERRORTAG="ERROR:" find "${SRCROOT}" \( -name "*.h" -or -name "*.m" -or -name "*.swift" \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$|($ERRORTAG).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/" | perl -p -e "s/($ERRORTAG)/ error: \$1/"
TAGS="TODO:|FIXME:" echo "searching ${SRCROOT} for ${TAGS}" find "${SRCROOT}" \( -name "*.swift" \) -type f -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/"
brew tap doubleencore/tap brew install xcodeissuegenerator
XcodeIssueGenerator -b DEBUG -w "WARNING, SERIOUS, TODO" -x "Vendor/, Third Party/"
1) install Alcatraz (Nice package manager for Xcode Plug-ins) by entering this line in terminal: curl -fsSL https: 2) Then restart Xcode and on it launch agree to install all bundles not included in Xcode 3) In Xcode select menu item -> Window -> Package manager -> type in search panel XTodo and press install 4) Relaunch Xcode and again agree to install additional bundles 5) From now press Ctrl + T and you will see all Tags in nice window
if [ "${CONFIGURATION}" = "DEBUG" ]; then TAGS="TODO:|FIXME:|WARNING:|warning:" find "." \( -name "*.swift" \) -not -path "./Pods/*" -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/" fi
override func viewDidLoad() { super.viewDidLoad() self.navigationController?.isNavigationBarHidden = true }
override func viewWillAppear(animated: Bool) { self.navigationController?.isNavigationBarHidden = true }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) self.navigationController?.setNavigationBarHidden(true, animated: animated) } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) self.navigationController?.setNavigationBarHidden(false, animated: animated) }
override func viewWillDisappear(animated: Bool) { super.viewWillDisappear(animated) self.navigationController?.isNavigationBarHidden = false }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) self.navigationController?.setNavigationBarHidden(false, animated: animated) }
import UIKit extension UIViewController { func hideNavigationBar(){ self.navigationController?.setNavigationBarHidden(true, animated: true) } func showNavigationBar() { self.navigationController?.setNavigationBarHidden(false, animated: true) } }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) hideNavigationBar() } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) showNavigationBar() }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) self.navigationController?.isNavigationBarHidden = true; } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) self.navigationController?.isNavigationBarHidden = false; }
self.navigationController?.setNavigationBarHidden(false, animated: true) self.navigationController?.navigationBar.isHidden = false self.navigationController?.isNavigationBarHidden = false
self.navigationController?.setNavigationBarHidden(true, animated: true) self.navigationController?.navigationBar.isHidden = true self.navigationController?.isNavigationBarHidden = true
class WindowController: NSWindowController { override func windowDidLoad() { super.windowDidLoad() window?.titleVisibility = .hidden } }
extension Date { func years(from date: Date) -> Int { return Calendar.current.dateComponents([.year], from: date, to: self).year ?? 0 } func months(from date: Date) -> Int { return Calendar.current.dateComponents([.month], from: date, to: self).month ?? 0 } func weeks(from date: Date) -> Int { return Calendar.current.dateComponents([.weekOfMonth], from: date, to: self).weekOfMonth ?? 0 } func days(from date: Date) -> Int { return Calendar.current.dateComponents([.day], from: date, to: self).day ?? 0 } func hours(from date: Date) -> Int { return Calendar.current.dateComponents([.hour], from: date, to: self).hour ?? 0 } func minutes(from date: Date) -> Int { return Calendar.current.dateComponents([.minute], from: date, to: self).minute ?? 0 } func seconds(from date: Date) -> Int { return Calendar.current.dateComponents([.second], from: date, to: self).second ?? 0 } func offset(from date: Date) -> String { if years(from: date) > 0 { return "\(years(from: date))y" } if months(from: date) > 0 { return "\(months(from: date))M" } if weeks(from: date) > 0 { return "\(weeks(from: date))w" } if days(from: date) > 0 { return "\(days(from: date))d" } if hours(from: date) > 0 { return "\(hours(from: date))h" } if minutes(from: date) > 0 { return "\(minutes(from: date))m" } if seconds(from: date) > 0 { return "\(seconds(from: date))s" } return "" } }
let dateComponentsFormatter = DateComponentsFormatter() dateComponentsFormatter.allowedUnits = [.year,.month,.weekOfMonth,.day,.hour,.minute,.second] dateComponentsFormatter.maximumUnitCount = 1 dateComponentsFormatter.unitsStyle = .full dateComponentsFormatter.string(from: Date(), to: Date(timeIntervalSinceNow: 4000000))
let date1 = DateComponents(calendar: .current, year: 2014, month: 11, day: 28, hour: 5, minute: 9).date! let date2 = DateComponents(calendar: .current, year: 2015, month: 8, day: 28, hour: 5, minute: 9).date! let years = date2.years(from: date1) let months = date2.months(from: date1) let weeks = date2.weeks(from: date1) let days = date2.days(from: date1) let hours = date2.hours(from: date1) let minutes = date2.minutes(from: date1) let seconds = date2.seconds(from: date1) let timeOffset = date2.offset(from: date1) let date3 = DateComponents(calendar: .current, year: 2014, month: 11, day: 28, hour: 5, minute: 9).date! let date4 = DateComponents(calendar: .current, year: 2015, month: 11, day: 28, hour: 5, minute: 9).date! let timeOffset2 = date4.offset(from: date3) let date5 = DateComponents(calendar: .current, year: 2017, month: 4, day: 28).date! let now = Date() let timeOffset3 = now.offset(from: date5)
extension NSDate { func offsetFrom(date : NSDate) -> String { let dayHourMinuteSecond: NSCalendarUnit = [.Day, .Hour, .Minute, .Second] let difference = NSCalendar.currentCalendar().components(dayHourMinuteSecond, fromDate: date, toDate: self, options: []) let seconds = "\(difference.second)s" let minutes = "\(difference.minute)m" + " " + seconds let hours = "\(difference.hour)h" + " " + minutes let days = "\(difference.day)d" + " " + hours if difference.day > 0 { return days } if difference.hour > 0 { return hours } if difference.minute > 0 { return minutes } if difference.second > 0 { return seconds } return "" } }
extension Date { func offsetFrom(date : Date) -> String { let dayHourMinuteSecond: Set<Calendar.Component> = [.day, .hour, .minute, .second] let difference = NSCalendar.current.dateComponents(dayHourMinuteSecond, from: date, to: self); let seconds = "\(difference.second ?? 0)s" let minutes = "\(difference.minute ?? 0)m" + " " + seconds let hours = "\(difference.hour ?? 0)h" + " " + minutes let days = "\(difference.day ?? 0)d" + " " + hours if let day = difference.day, day > 0 { return days } if let hour = difference.hour, hour > 0 { return hours } if let minute = difference.minute, minute > 0 { return minutes } if let second = difference.second, second > 0 { return seconds } return "" } }
let previousDate = ... let now = Date() let formatter = DateComponentsFormatter() formatter.unitsStyle = .full formatter.allowedUnits = [.month, .day, .hour, .minute, .second] formatter.maximumUnitCount = 2 let string = formatter.string(from: previousDate, to: now)
let previousDate = ... let now = NSDate() let formatter = NSDateComponentsFormatter() formatter.unitsStyle = .Full formatter.allowedUnits = [.Month, .Day, .Hour, .Minute, .Second] formatter.maximumUnitCount = 2 let string = formatter.stringFromDate(previousDate, toDate: now)
let components = Calendar.current.dateComponents([.month, .day, .hour, .minute, .second], from: previousDate, to: now)
let components = NSCalendar.currentCalendar().components([.Month, .Day, .Hour, .Minute, .Second], fromDate: previousDate, toDate: now, options: [])
func dateDiff(dateStr:String) -> String { var f:NSDateFormatter = NSDateFormatter() f.timeZone = NSTimeZone.localTimeZone() f.dateFormat = "yyyy-M-dd var now = f.stringFromDate(NSDate()) var startDate = f.dateFromString(dateStr) var endDate = f.dateFromString(now) var calendar: NSCalendar = NSCalendar.currentCalendar() let calendarUnits = NSCalendarUnit.CalendarUnitWeekOfMonth | NSCalendarUnit.CalendarUnitDay | NSCalendarUnit.CalendarUnitHour | NSCalendarUnit.CalendarUnitMinute | NSCalendarUnit.CalendarUnitSecond let dateComponents = calendar.components(calendarUnits, fromDate: startDate!, toDate: endDate!, options: nil) let weeks = abs(dateComponents.weekOfMonth) let days = abs(dateComponents.day) let hours = abs(dateComponents.hour) let min = abs(dateComponents.minute) let sec = abs(dateComponents.second) var timeAgo = "" if (sec > 0){ if (sec > 1) { timeAgo = "\(sec) Seconds Ago" } else { timeAgo = "\(sec) Second Ago" } } if (min > 0){ if (min > 1) { timeAgo = "\(min) Minutes Ago" } else { timeAgo = "\(min) Minute Ago" } } if(hours > 0){ if (hours > 1) { timeAgo = "\(hours) Hours Ago" } else { timeAgo = "\(hours) Hour Ago" } } if (days > 0) { if (days > 1) { timeAgo = "\(days) Days Ago" } else { timeAgo = "\(days) Day Ago" } } if(weeks > 0){ if (weeks > 1) { timeAgo = "\(weeks) Weeks Ago" } else { timeAgo = "\(weeks) Week Ago" } } print("timeAgo is===> \(timeAgo)") return timeAgo; }
extension DateComponentsFormatter { func difference(from fromDate: Date, to toDate: Date) -> String? { self.allowedUnits = [.year,.month,.weekOfMonth,.day] self.maximumUnitCount = 1 self.unitsStyle = .full return self.string(from: fromDate, to: toDate) } } let dateComponentsFormatter = DateComponentsFormatter() dateComponentsFormatter.difference(from: Date(), to: Date(timeIntervalSinceNow: 4000000))
extension Date { func years(from date: Date) -> Int { return Calendar.current.dateComponents([.year], from: date, to: self).year ?? 0 } func months(from date: Date) -> Int { return Calendar.current.dateComponents([.month], from: date, to: self).month ?? 0 } func weeks(from date: Date) -> Int { return Calendar.current.dateComponents([.weekOfYear], from: date, to: self).weekOfYear ?? 0 } func days(from date: Date) -> Int { return Calendar.current.dateComponents([.day], from: date, to: self).day ?? 0 } func hours(from date: Date) -> Int { return Calendar.current.dateComponents([.hour], from: date, to: self).hour ?? 0 } func minutes(from date: Date) -> Int { return Calendar.current.dateComponents([.minute], from: date, to: self).minute ?? 0 } func seconds(from date: Date) -> Int { return Calendar.current.dateComponents([.second], from: date, to: self).second ?? 0 } func offset(from date: Date) -> String { if years(from: date) > 0 { return "\(years(from: date))y" } if months(from: date) > 0 { return "\(months(from: date))M" } if weeks(from: date) > 0 { return "\(weeks(from: date))w" } if days(from: date) > 0 { return "\(days(from: date))d" } if hours(from: date) > 0 { return "\(hours(from: date))h" } if minutes(from: date) > 0 { return "\(minutes(from: date))m" } if seconds(from: date) > 0 { return "\(seconds(from: date))s" } return "" } func offsetLong(from date: Date) -> String { if years(from: date) > 0 { return years(from: date) > 1 ? "\(years(from: date)) years ago" : "\(years(from: date)) year ago" } if months(from: date) > 0 { return months(from: date) > 1 ? "\(months(from: date)) months ago" : "\(months(from: date)) month ago" } if weeks(from: date) > 0 { return weeks(from: date) > 1 ? "\(weeks(from: date)) weeks ago" : "\(weeks(from: date)) week ago" } if days(from: date) > 0 { return days(from: date) > 1 ? "\(days(from: date)) days ago" : "\(days(from: date)) day ago" } if hours(from: date) > 0 { return hours(from: date) > 1 ? "\(hours(from: date)) hours ago" : "\(hours(from: date)) hour ago" } if minutes(from: date) > 0 { return minutes(from: date) > 1 ? "\(minutes(from: date)) minutes ago" : "\(minutes(from: date)) minute ago" } if seconds(from: date) > 0 { return seconds(from: date) > 1 ? "\(seconds(from: date)) seconds ago" : "\(seconds(from: date)) second ago" } return "" } }
let calendar = NSCalendar.current as NSCalendar let date1 = calendar.startOfDay(for: startDateTime) let date2 = calendar.startOfDay(for: endDateTime) let flags = NSCalendar.Unit.day let components = calendar.components(flags, from: date1, to: date2, options: []) return components.day!
import Foundation let oldDate = Date(timeIntervalSinceReferenceDate: -16200) let newDate = Date(timeIntervalSinceReferenceDate: 0) let dateComponentsFormatter = DateComponentsFormatter() dateComponentsFormatter.allowedUnits = [NSCalendar.Unit.year, .month, .day, .hour, .minute] dateComponentsFormatter.maximumUnitCount = 1 dateComponentsFormatter.unitsStyle = DateComponentsFormatter.UnitsStyle.full let timeDifference = dateComponentsFormatter.string(from: oldDate, to: newDate) print(String(reflecting: timeDifference))
import Foundation struct Formatters { static let dateComponentsFormatter: DateComponentsFormatter = { let dateComponentsFormatter = DateComponentsFormatter() dateComponentsFormatter.allowedUnits = [NSCalendar.Unit.year, .month, .day, .hour, .minute] dateComponentsFormatter.maximumUnitCount = 1 dateComponentsFormatter.unitsStyle = DateComponentsFormatter.UnitsStyle.full return dateComponentsFormatter }() } extension Date { func offset(from: Date) -> String? { return Formatters.dateComponentsFormatter.string(from: oldDate, to: self) } } let oldDate = Date(timeIntervalSinceReferenceDate: -16200) let newDate = Date(timeIntervalSinceReferenceDate: 0) let timeDifference = newDate.offset(from: oldDate) print(String(reflecting: timeDifference))
func dateComponents(_ components: Set<Calendar.Component>, from start: Date, to end: Date) -> DateComponents
import Foundation let oldDate = Date(timeIntervalSinceReferenceDate: -16200) let newDate = Date(timeIntervalSinceReferenceDate: 0) let descendingOrderedComponents = [Calendar.Component.year, .month, .day, .hour, .minute] let dateComponents = Calendar.current.dateComponents(Set(descendingOrderedComponents), from: oldDate, to: newDate) let arrayOfTuples = descendingOrderedComponents.map { ($0, dateComponents.value(for: $0)) } for (component, value) in arrayOfTuples { if let value = value, value > 0 { print(component, value) break } }
import Foundation extension Date { func offset(from: Date) -> (Calendar.Component, Int)? { let descendingOrderedComponents = [Calendar.Component.year, .month, .day, .hour, .minute] let dateComponents = Calendar.current.dateComponents(Set(descendingOrderedComponents), from: from, to: self) let arrayOfTuples = descendingOrderedComponents.map { ($0, dateComponents.value(for: $0)) } for (component, value) in arrayOfTuples { if let value = value, value > 0 { return (component, value) } } return nil } } let oldDate = Date(timeIntervalSinceReferenceDate: -16200) let newDate = Date(timeIntervalSinceReferenceDate: 0) if let (component, value) = newDate.offset(from: oldDate) { print(component, value) }
func years(fromdate: NSDate) -> Int { return NSCalendar.currentCalendar().components([.Year], fromDate: fromdate, toDate: NSDate(), options: []).year ?? 0 } func months(fromdate: NSDate) -> Int { return NSCalendar.currentCalendar().components([.Month], fromDate: fromdate, toDate: NSDate(), options: []).month ?? 0 } func weeks(fromdate: NSDate) -> Int { return NSCalendar.currentCalendar().components([.WeekOfYear], fromDate: fromdate, toDate: NSDate(), options: []).weekOfYear ?? 0 } func days(fromdate: NSDate) -> Int { return NSCalendar.currentCalendar().components([.Day], fromDate: fromdate, toDate: NSDate(), options: []).day ?? 0 } func hours(fromdate: NSDate) -> Int { return NSCalendar.currentCalendar().components([.Hour], fromDate: fromdate, toDate: NSDate(), options: []).hour ?? 0 } func minutes(fromdate: NSDate) -> Int { return NSCalendar.currentCalendar().components([.Minute], fromDate: fromdate, toDate: NSDate(), options: []).minute ?? 0 } func seconds(fromdate: NSDate) -> Int { return NSCalendar.currentCalendar().components(.Second, fromDate: fromdate, toDate: NSDate(), options: []).second ?? 0 }
let calendar = NSCalendar.current as NSCalendar let currentDate = Date() let date1 = calendar.startOfDay(for: buyDate!) let date2 = calendar.startOfDay(for: currentDate) let flags = NSCalendar.Unit.day let components = calendar.components(flags, from: date1, to: date2) NSLog(" day= \(components.day)")
extension Date { func years(from date: Date) -> Int { return Calendar.current.dateComponents([.year], from: date, to: self).year ?? 0 } func months(from date: Date) -> Int { return Calendar.current.dateComponents([.month], from: date, to: self).month ?? 0 } func weeks(from date: Date) -> Int { return Calendar.current.dateComponents([.weekOfMonth], from: date, to: self).weekOfMonth ?? 0 } func days(from date: Date) -> Int { return Calendar.current.dateComponents([.day], from: date, to: self).day ?? 0 } func hours(from date: Date) -> Int { return Calendar.current.dateComponents([.hour], from: date, to: self).hour ?? 0 } func minutes(from date: Date) -> Int { return Calendar.current.dateComponents([.minute], from: date, to: self).minute ?? 0 } func seconds(from date: Date) -> Int { return Calendar.current.dateComponents([.second], from: date, to: self).second ?? 0 } func offset(from date: Date) -> String { if years(from: date) == 1 { return "\(years(from: date)) year" } else if years(from: date) > 1 { return "\(years(from: date)) years" } if months(from: date) == 1 { return "\(months(from: date)) month" } else if months(from: date) > 1 { return "\(months(from: date)) month" } if weeks(from: date) == 1 { return "\(weeks(from: date)) week" } else if weeks(from: date) > 1 { return "\(weeks(from: date)) weeks" } if days(from: date) == 1 { return "\(days(from: date)) day" } else if days(from: date) > 1 { return "\(days(from: date)) days" } if hours(from: date) == 1 { return "\(hours(from: date)) hour" } else if hours(from: date) > 1 { return "\(hours(from: date)) hours" } if minutes(from: date) == 1 { return "\(minutes(from: date)) minute" } else if minutes(from: date) > 1 { return "\(minutes(from: date)) minutes" } return "" } }
func timeGapBetweenDates(previousDate : String,currentDate : String) { let dateString1 = previousDate let dateString2 = currentDate let Dateformatter = DateFormatter() Dateformatter.dateFormat = "yyyy-MM-dd HH:mm:ss" let date1 = Dateformatter.date(from: dateString1) let date2 = Dateformatter.date(from: dateString2) let distanceBetweenDates: TimeInterval? = date2?.timeIntervalSince(date1!) let secondsInAnHour: Double = 3600 let minsInAnHour: Double = 60 let secondsInDays: Double = 86400 let secondsInWeek: Double = 604800 let secondsInMonths : Double = 2592000 let secondsInYears : Double = 31104000 let minBetweenDates = Int((distanceBetweenDates! / minsInAnHour)) let hoursBetweenDates = Int((distanceBetweenDates! / secondsInAnHour)) let daysBetweenDates = Int((distanceBetweenDates! / secondsInDays)) let weekBetweenDates = Int((distanceBetweenDates! / secondsInWeek)) let monthsbetweenDates = Int((distanceBetweenDates! / secondsInMonths)) let yearbetweenDates = Int((distanceBetweenDates! / secondsInYears)) let secbetweenDates = Int(distanceBetweenDates!) if yearbetweenDates > 0 { print(yearbetweenDates,"years") } else if monthsbetweenDates > 0 { print(monthsbetweenDates,"months") } else if weekBetweenDates > 0 { print(weekBetweenDates,"weeks") } else if daysBetweenDates > 0 { print(daysBetweenDates,"days") } else if hoursBetweenDates > 0 { print(hoursBetweenDates,"hours") } else if minBetweenDates > 0 { print(minBetweenDates,"minutes") } else if secbetweenDates > 0 { print(secbetweenDates,"seconds") } }
var calendar: NSCalendar = NSCalendar.currentCalendar() let date1 = calendar.startOfDayForDate(firstDate) let date2 = calendar.startOfDayForDate(secondDate) let flags = NSCalendarUnit.DayCalendarUnit let components = calendar.components(flags, fromDate: date1, toDate: date2, options: nil) components.day
static func updateTimeStampPost(postTimeStamp: Date?, _ completion: (_ finalString: String?) -> Void) { let date = Date() let dateComponentFormatter = DateComponentsFormatter() dateComponentFormatter.unitsStyle = .abbreviated dateComponentFormatter.allowedUnits = [.second, .minute, .hour, .day, .weekOfMonth] dateComponentFormatter.maximumUnitCount = 1 completion(dateComponentFormatter.string(from: postTimeStamp!, to: date)) }
let dateFormatter = DateFormatter() dateFormatter.dateStyle = .medium dateFormatter.timeStyle = .short var beginDate = "2017-08-24 12:00:00" var endDate = "2017-09-07 12:00:00" let startDateTime = dateFormatter.date(from: beginDate) print(startDateTime ?? "") let endDateTime = dateFormatter.date(from: endDate) print(endDateTime ?? "") let dateComponentsFormatter = DateComponentsFormatter() dateComponentsFormatter.allowedUnits = [NSCalendar.Unit.minute,NSCalendar.Unit.hour,NSCalendar.Unit.day] let interval = endDateTime!.timeIntervalSince(startDateTime!) var diff = dateComponentsFormatter.string(from: interval)! print(diff) var day_i = 0 var hour_i = 0 var min_i = 0 if (diff.contains("d")) { let day = diff.substring(to: (diff.range(of: "d")?.lowerBound)!) day_i = Int(day)! print ("day --> \(day_i)") diff = diff.substring(from:(diff.range(of : " ")?.upperBound )!) print(diff) } let hour = diff.substring(to: (diff.range(of : ":")?.lowerBound )!) hour_i = Int(hour)! print ("hour --> \(hour_i)") let min = diff.substring(from: (diff.range(of : ":")?.upperBound )!) min_i = Int(min)! print ("min --> \(min_i)")
func getDateTimeDiff(dateStr:String) -> String { let formatter : DateFormatter = DateFormatter() formatter.timeZone = NSTimeZone.local formatter.dateFormat = "yyyy-MM-dd HH:mm:ss" let now = formatter.string(from: NSDate() as Date) let startDate = formatter.date(from: dateStr) let endDate = formatter.date(from: now) var calendar = NSCalendar.current print(calendar.dateComponents([.year, .month, .day, .hour, .minute, .second], from: startDate!)) let unitFlags = Set<Calendar.Component>([.year, .month, .day, .hour, .minute, .second]) calendar.timeZone = TimeZone(identifier: "UTC")! let dateComponents = calendar.dateComponents(unitFlags, from: startDate!, to: endDate!) let years = dateComponents.year! let months = dateComponents.month! let days = dateComponents.day! let hours = dateComponents.hour! let minutes = dateComponents.minute! let seconds = dateComponents.second! var timeAgo = "" if (seconds > 0){ if seconds < 2 { timeAgo = "Second Ago" } else{ timeAgo = "\(seconds) Second Ago" } } if (minutes > 0){ if minutes < 2 { timeAgo = "Minute Ago" } else{ timeAgo = "\(minutes) Minutes Ago" } } if(hours > 0){ if minutes < 2 { timeAgo = "Hour Ago" } else{ timeAgo = "\(hours) Hours Ago" } } if (days > 0) { if minutes < 2 { timeAgo = "Day Ago" } else{ timeAgo = "\(days) Days Ago" } } if(months > 0){ if minutes < 2 { timeAgo = "Month Ago" } else{ timeAgo = "\(months) Months Ago" } } if(years > 0){ if minutes < 2 { timeAgo = "Year Ago" } else{ timeAgo = "\(years) Years Ago" } } DLog("timeAgo is ===> \(timeAgo)") return timeAgo; }
let registrationDateString = "2008-10-06 00:00:00" let dateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd hh:mm:ss" if let registrationDate = dateFormatter.date(from: registrationDateString) { let currentDate = Date() let dateDifference = Calendar.current.dateComponents([.day, .month, .year], from: registrationDate, to: currentDate) print("--------------------- Result: \(dateDifference.year ?? 0) years \(dateDifference.month ?? 0) months and \(dateDifference.day ?? 0) days") } else { print("--------------------- No result") }
var float: Float = 2.2 var integer: Int = float as Float
var myIntValue:Int = Int(myFloatValue) println "My value is \(myIntValue)"
let float = Float(Int.max) + 1 let int = Int(float)
fatal error: floating point value can not be converted to Int because it is greater than Int.max
extension Double { func toInt() -> Int? { if self > Double(Int.min) && self < Double(Int.max) { return Int(self) } else { return nil } } } extension Float { func toInt() -> Int? { if self > Float(Int.min) && self < Float(Int.max) { return Int(self) } else { return nil } } }
let f: Float = 2.2 let i = Int(f.rounded(.toNearestOrEven))
let f: Float = 2.5 let i = Int(roundf(f)) let j = Int(f.rounded(.toNearestOrEven))
var float:Float = 2.2 var integer:Int = Int(float) var anotherFloat: Float = Float(integer)
var floatValue:Float = 5.4 var integerValue:Int = Int(floatValue) println("IntegerValue = \(integerValue)")
var floatValue = 10.23 var intValue = Int(floatValue)
func uniq<S : SequenceType, T : Hashable where S.Generator.Element == T>(source: S) -> [T] { var buffer = [T]() var added = Set<T>() for elem in source { if !added.contains(elem) { buffer.append(elem) added.insert(elem) } } return buffer } let vals = [1, 4, 2, 2, 6, 24, 15, 2, 60, 15, 6] let uniqueVals = uniq(vals)
func uniq<S : Sequence, T : Hashable>(source: S) -> [T] where S.Iterator.Element == T { var buffer = [T]() var added = Set<T>() for elem in source { if !added.contains(elem) { buffer.append(elem) added.insert(elem) } } return buffer }
extension Array where Element:Equatable { func removeDuplicates() -> [Element] { var result = [Element]() for value in self { if result.contains(value) == false { result.append(value) } } return result } }
let arrayOfInts = [2, 2, 4, 4] print(arrayOfInts.removeDuplicates())
extension Array { func filterDuplicates(@noescape includeElement: (lhs:Element, rhs:Element) -> Bool) -> [Element]{ var results = [Element]() forEach { (element) in let existingElements = results.filter { return includeElement(lhs: element, rhs: $0) } if existingElements.count == 0 { results.append(element) } } return results } }
let filteredElements = myElements.filterDuplicates { $0.PropertyOne == $1.PropertyOne && $0.PropertyTwo == $1.PropertyTwo }
public extension Sequence where Element: Equatable { var uniqueElements: [Element] { return self.reduce(into: []) { uniqueElements, element in if !uniqueElements.contains(element) { uniqueElements.append(element) } } } }
public extension Sequence where Iterator.Element: Hashable { var uniqueElements: [Iterator.Element] { return Array( Set(self) ) } } public extension Sequence where Iterator.Element: Equatable { var uniqueElements: [Iterator.Element] { return self.reduce([]){ uniqueElements, element in uniqueElements.contains(element) ? uniqueElements : uniqueElements + [element] } } }
public extension SequenceType where Generator.Element: Hashable { var uniqueElements: [Generator.Element] { return Array( Set(self) ) } } public extension SequenceType where Generator.Element: Equatable { var uniqueElements: [Generator.Element] { return self.reduce([]){uniqueElements, element in uniqueElements.contains(element) ? uniqueElements : uniqueElements + [element] } } }
let uniqueUnordered = Array(Set(array)) let uniqueOrdered = Array(NSOrderedSet(array: array))
extension Collection where Element: Equatable { var orderedSet: [Element] { var array: [Element] = [] return compactMap { if array.contains($0) { return nil } else { array.append($0) return $0 } } } }
extension Collection where Element: Hashable { var orderedSet: [Element] { var set = Set<Element>() return compactMap { set.insert($0).inserted ? $0 : nil } } }
extension Collection where Element: Hashable { var orderedSet: [Element] { var set = Set<Element>() return filter { set.insert($0).inserted } } }
extension Array where Element: Hashable { var orderedSet: Array { return NSOrderedSet(array: self).array as? Array ?? [] } }
extension Collection where Element: Hashable { var orderedSet: [Element] { var set: Set<Element> = [] return reduce(into: []) { set.insert($1).inserted ? $0.append($1) : () } } }
let integers = [1, 4, 2, 2, 6, 24, 15, 2, 60, 15, 6] let integersOrderedSet = integers.orderedSet
extension RangeReplaceableCollection where Element: Hashable { var orderedSet: Self { var set = Set<Element>() return filter { set.insert($0).inserted } } mutating func removeDuplicates() { var set = Set<Element>() removeAll { !set.insert($0).inserted } } }
"abcdefabcghi".orderedSet var string = "abcdefabcghi" string.removeDuplicates() string
extension Array where Element: Equatable { func removingDuplicates() -> Array { return reduce(into: []) { result, element in if !result.contains(element) { result.append(element) } } } }
public extension Array where Element: Hashable { func uniqued() -> [Element] { var seen = Set<Element>() return filter{ seen.insert($0).inserted } } }
func deleteDuplicates<S: ExtensibleCollectionType where S.Generator.Element: Equatable>(seq:S)-> S { let s = reduce(seq, S()){ ac, x in contains(ac,x) ? ac : ac + [x] } return s }
func uniq<S: SequenceType, E: Hashable where E==S.Generator.Element>(source: S) -> [E] { var seen: [E:Bool] = [:] return source.filter({ (v) -> Bool in return seen.updateValue(true, forKey: v) == nil }) }
var test = [1,2,3,4,5,6,7,8,9,9,9,9,9,9] print(uniq(test))
public extension Array where Element: Hashable { public func uniqued() -> [Element] { var seen = Set<Element>() return self.filter { seen.insert($0).inserted } } }
public extension Sequence where Iterator.Element: Equatable { public func uniqued() -> [Iterator.Element] { var buffer: [Iterator.Element] = [] for element in self { guard !buffer.contains(element) else { continue } buffer.append(element) } return buffer } }
let numberArray = [10, 1, 2, 3, 2, 1, 15, 4, 5, 6, 7, 3, 2, 12, 2, 5, 5, 6, 10, 7, 8, 3, 3, 45, 5, 15, 6, 7, 8, 7]
func orderedSet<T: Hashable>(array: Array<T>) -> Array<T> { var unique = Set<T>() return array.filter { element in return unique.insert(element).inserted } } orderedSet(array: numberArray)
extension Array where Element:Hashable { var orderedSet: Array { var unique = Set<Element>() return filter { element in return unique.insert(element).inserted } } } numberArray.orderedSet
var myArray = [1, 4, 2, 2, 6, 24, 15, 2, 60, 15, 6] var mySet = Set<Int>(myArray) myArray = Array(mySet)
extension Sequence where Iterator.Element: Hashable { func unique() -> [Iterator.Element] { return Array(Set<Iterator.Element>(self)) } func uniqueOrdered() -> [Iterator.Element] { return reduce([Iterator.Element]()) { $0.contains($1) ? $0 : $0 + [$1] } } }
["Ljubljana", "London", "Los Angeles", "Ljubljana"].unique()
["Ljubljana", "London", "Los Angeles", "Ljubljana"].uniqueOrdered()
extension Sequence where Iterator.Element: Hashable { func unique() -> [Iterator.Element] { var seen: [Iterator.Element: Bool] = [:] return self.filter { seen.updateValue(true, forKey: $0) == nil } } }
func uniq<S: SequenceType, E: Hashable where E == S.Generator.Element>(source: S) -> [E] { var seen = [E: Bool]() return source.filter { seen.updateValue(true, forKey: $0) == nil } }
func ==(lhs: SomeCustomType, rhs: SomeCustomType) -> Bool { return lhs.id == rhs.id } struct SomeCustomType { let id: Int } extension SomeCustomType: Hashable { var hashValue: Int { return id } }
var someCustomTypes = [SomeCustomType(id: 1), SomeCustomType(id: 2), SomeCustomType(id: 3), SomeCustomType(id: 1)] print(someCustomTypes.count) someCustomTypes = uniq(someCustomTypes) print(someCustomTypes.count)
var arrayOfDates: NSArray = ["15/04/01","15/04/01","15/04/02","15/04/02","15/04/03","15/04/03","15/04/03"] var datesOnlyDict = NSMutableDictionary() var x = Int() for (x=0;x<(arrayOfDates.count);x++) { let date = arrayOfDates[x] as String datesOnlyDict.setValue("foo", forKey: date) } let uniqueDatesArray: NSArray = datesOnlyDict.allKeys println(uniqueDatesArray.count)
var sortedArray = sorted(datesOnlyArray) { (obj1, obj2) in let p1 = obj1 as String let p2 = obj2 as String return p1 < p2 } println(sortedArray)
struct DistinctWrapper <T>: Hashable { var underlyingObject: T var distinctAttribute: String var hashValue: Int { return distinctAttribute.hashValue } } func distinct<S : SequenceType, T where S.Generator.Element == T>(source: S, distinctAttribute: (T) -> String, resolution: (T, T) -> T) -> [T] { let wrappers: [DistinctWrapper<T>] = source.map({ return DistinctWrapper(underlyingObject: $0, distinctAttribute: distinctAttribute($0)) }) var added = Set<DistinctWrapper<T>>() for wrapper in wrappers { if let indexOfExisting = added.indexOf(wrapper) { let old = added[indexOfExisting] let winner = resolution(old.underlyingObject, wrapper.underlyingObject) added.insert(DistinctWrapper(underlyingObject: winner, distinctAttribute: distinctAttribute(winner))) } else { added.insert(wrapper) } } return Array(added).map( { return $0.underlyingObject } ) } func == <T>(lhs: DistinctWrapper<T>, rhs: DistinctWrapper<T>) -> Bool { return lhs.hashValue == rhs.hashValue } class Person { var name: String var phoneNumber: String init(_ name: String, _ phoneNumber: String) { self.name = name self.phoneNumber = phoneNumber } } let persons: [Person] = [Person("Irma Burgess", "11-22-33"), Person("Lester Davidson", "44-66-22"), Person("Irma", "11-22-33")] let distinctPersons = distinct(persons, distinctAttribute: { (person: Person) -> String in return person.phoneNumber }, resolution: { (p1, p2) -> Person in return p1.name.characters.count > p2.name.characters.count ? p1 : p2 } )
extension Array where Element: Hashable { func unique() -> [Element] { var seen: [Element:Bool] = [:] return self.filter({ seen.updateValue(true, forKey: $0) == nil }) } func subtract(takeAway: [Element]) -> [Element] { let set = Set(takeAway) return self.filter({ !set.contains($0) }) } func intersect(with: [Element]) -> [Element] { let set = Set(with) return self.filter({ set.contains($0) }) } }
struct CustomStruct : Equatable { let name: String let lastName : String } func ==(lhs: CustomStruct, rhs: CustomStruct) -> Bool { return (lhs.name == rhs.name && lhs.lastName == rhs.lastName) } let categories = [CustomStruct(name: "name1", lastName: "lastName1"), CustomStruct(name: "name2", lastName: "lastName1"), CustomStruct(name: "name1", lastName: "lastName1")] print(categories.count) let uniq1 : [CustomStruct] = categories.reduce([]) { $0.contains($1) ? $0 : $0 + [$1] } print(uniq1.count)
let uniq2 : [CustomStruct] = categories.reduce([]) { (result, category) in var newResult = result if (newResult.contains(category)) {} else { newResult.append(category) } return newResult } uniq2.count
extension Array { func filterDuplicate<T>(_ keyValue:(Element)->T) -> [Element] { var uniqueKeys = Set<String>() return filter{uniqueKeys.insert("\(keyValue($0))").inserted} } } peopleArray = peopleArray.filterDuplicate{ ($0.name, $0.age, $0.sex) }
func removeDublicate (ab: [Int]) -> [Int] { var answer1:[Int] = [] for i in ab { if !answer1.contains(i) { answer1.append(i) }} return answer1 }
extension Array where Element: Equatable { public func uniq() -> [Element] { var arrayCopy = self arrayCopy.uniqInPlace() return arrayCopy } mutating public func uniqInPlace() { var seen = [Element]() var index = 0 for element in self { if seen.contains(element) { removeAtIndex(index) } else { seen.append(element) index++ } } } }
var numbers = [1, 6, 2, 2, 4, 1, 5] numbers.uniqInPlace() let strings = ["Y", "Z", "A", "Y", "B", "Y", "Z"] let uniqStrings = strings.uniq()
extension Array where Element:Hashable { var unique: [Element] { var set = Set<Element>() var arrayOrdered = [Element]() for value in self { if !set.contains(value) { set.insert(value) arrayOrdered.append(value) } } return arrayOrdered } }
extension Array where Element: Equatable { var unique: [Element] { var result: [Element] = [] for element in self { if !result.contains(element) { result.append(element) } } return result } }
extension Array where Element: Equatable { func containsHowMany(_ elem: Element) -> Int { return reduce(0) { $1 == elem ? $0 + 1 : $0 } } func duplicatesRemoved() -> Array { return self.filter { self.containsHowMany($0) == 1 } } mutating func removeDuplicates() { self = self.duplicatesRemoved(() } }
let arr = [1, 1, 1, 2, 2, 3, 4, 5, 6, 6, 6, 6, 6, 7, 8] let noDuplicates = arr.duplicatesRemoved() print(arr) print(noDuplicates) arr.removeDuplicates() print(arr)
let keyarray:NSMutableArray = NSMutableArray() for object in dataArr { if !keysArray.contains(object){ keysArray.add(object) } } print(keysArray)
var top3score: [Int] = [] outerLoop: for i in 0..<top10score.count { dlog(message: String(top10score[i])) if top3score.count == 3 { break } for aTop3score in top3score { if aTop3score == top10score[i] { continue outerLoop } } top3score.append(top10score[i]) } print("top10score is \(top10score)") print("top3score is \(top3score)")
extension Sequence where Iterator.Element: Hashable { func unique(matching: (Iterator.Element, Iterator.Element) -> Bool) -> [Iterator.Element] { var uniqueArray: [Iterator.Element] = [] forEach { element in let isUnique = uniqueArray.reduce(true, { (result, item) -> Bool in return result && matching(element, item) }) if isUnique { uniqueArray.append(element) } } return uniqueArray } }
var animals = ["cats", "dogs", "chimps", "moose"] animals.remove(at: 2)
func delete(element: String) { list = list.filter() { $0 !== element } }
if let index = animals.index(of: "chimps") { animals.remove(at: index) } print(animals)
var animals = ["cats", "dogs", "chimps", "moose", "chimps"] animals = animals.filter(){$0 != "chimps"} print(animals)
animals.index(of: "chimps").map { animals.remove(at: $0) }
extension Array where Element: Equatable { mutating func remove(object: Element) { if let index = index(of: object) { remove(at: index) } } }
var myArray = ["cat", "barbecue", "pancake", "frog"] let objectToRemove = "cat" myArray.remove(object: objectToRemove)
var animals = ["Dog", "Cat", "Mouse", "Dog"] let animalToRemove = "Dog" for object in animals { if object == animalToRemove{ animals.removeAtIndex(animals.indexOf(animalToRemove)!) } }
animals.removeAtIndex(animals.indexOf(animalToRemove)!)
var array = [12, 23, "Dog", 78, 23] let numberToRemove = 23 let animalToRemove = "Dog" for object in array { if object is Int { if object == numberToRemove { array.removeAtIndex(array.indexOf(numberToRemove)!) } } if object is String { if object == animalToRemove { array.removeAtIndex(array.indexOf(animalToRemove)!) } } }
var string = "Concate Two object of Array \(stringArray[1]) + \(stringArray[2])"
let animals = ["cats", "dogs", "chimps", "moose", "squarrel", "cow"] let indexAnimals = [0, 3, 4] let arrayRemainingAnimals = animals .enumerated() .filter { !indexAnimals.contains($0.offset) } .map { $0.element } print(arrayRemainingAnimals)
var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] let indexesToRemove = [3, 5, 8, 12] numbers = numbers .enumerated() .filter { !indexesToRemove.contains($0.offset) } .map { $0.element } print(numbers)
let arrayResult = numbers.filter { element in return !indexesToRemove.contains(element) } print(arrayResult)
let arrayLetters = ["a", "b", "c", "d", "e", "f", "g", "h", "i"] let arrayRemoveLetters = ["a", "e", "g", "h"] let arrayRemainingLetters = arrayLetters.filter { !arrayRemoveLetters.contains($0) } print(arrayRemainingLetters)
var phrase = "The rain in Spain stays mainly in the plain." let vowels: Set<Character> = ["a", "e", "i", "o", "u"] phrase.removeAll(where: { vowels.contains($0) })
var animals = ["cats", "dogs", "chimps", "moose"] animals.removeAll(where: { $0 == "chimps" } )
if let validIndex = (carsArray.indexOf{$0.color == UIColor.redColor()}) { carsArray.removeAtIndex(validIndex) }
extension Array where Element: Equatable { mutating func removeEqualItems(item: Element) { self = self.filter { (currentItem: Element) -> Bool in return currentItem != item } } mutating func removeFirstEqualItem(item: Element) { guard var currentItem = self.first else { return } var index = 0 while currentItem != item { index += 1 currentItem = self[index] } self.removeAtIndex(index) } }
var test1 = [1, 2, 1, 2] test1.removeEqualItems(2) var test2 = [1, 2, 1, 2] test2.removeFirstEqualItem(2)
if let index = doctorsInArea.indexOf({$0.id == doctor.id}){ doctorsInArea.removeAtIndex(index) }
if let index = doctorsInArea.indexOf({$0.name == doctor.name}){ doctorsInArea.removeAtIndex(index) }
extension Array { mutating func delete(element: String) { self = self.filter() { $0 as! String != element } } }
extension Array where Element: Equatable { mutating func delete(element: Iterator.Element) { self = self.filter{$0 != element } } }
var indexForDelete = 0 let yourArray = [String]() let newArray = [String]() for obj in yourArray { if conduction == true{ newArray.append(obj) }else{ } }
@IBAction func cancel(sender: AnyObject) { self.dismissViewControllerAnimated(false, completion: nil) println("cancel") } @IBAction func done(sender: AnyObject) { self.dismissViewControllerAnimated(false, completion: nil) println("done") }
navigationController.popViewControllerAnimated(true)
navigationController?.popViewController(animated: true) dismiss(animated: true, completion: nil)
self.navigationController?.popViewController(animated: true)
@IBAction func cancel(sender: AnyObject) { if(self.presentingViewController){ self.dismissViewControllerAnimated(false, completion: nil) println("cancel") } } @IBAction func done(sender: AnyObject) { if(self.presentingViewController){ self.dismissViewControllerAnimated(false, completion: nil) println("done") } }
self.dismissViewControllerAnimated(true, completion: nil)
self.navigationController?.popViewController(animated: true)
self.navigationController.dismissViewControllerAnimated(true, completion: nil)
self.presentingViewController?.dismiss(animated: true, completion: nil)
extension UIViewController { func dismissMe(animated: Bool, completion: (()->())?) { var count = 0 if let c = self.navigationController?.viewControllers.count { count = c } if count > 1 { self.navigationController?.popViewController(animated: animated) if let handler = completion { handler() } } else { dismiss(animated: animated, completion: completion) } } }
class MyViewController: UIViewController { ... @IBAction func cancel(sender: AnyObject) { dismissMe(animated: true, completion: nil) } ... }
@IBAction func cancel(sender: AnyObject) { dismiss(animated: false, completion: nil) }
self.navigationController?.popViewController(animated: false)
presentingViewController?.dismiss(animated: true, completion: nil)
@IBAction func cancel(sender: AnyObject) { dismiss(animated: true, completion: nil) }
MODULEMAP_FILE[sdk=iphoneos*] = \ $(SRCROOT)/CommonCrypto/iphoneos.modulemap MODULEMAP_FILE[sdk=iphonesimulator*] = \ $(SRCROOT)/CommonCrypto/iphonesimulator.modulemap MODULEMAP_FILE[sdk=macosx*] = \ $(SRCROOT)/CommonCrypto/macosx.modulemap
module CommonCrypto [system] { header "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/CommonCrypto/CommonCrypto.h" export * }
module CommonCrypto [system] { header "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/include/CommonCrypto/CommonCrypto.h" export * }
module CommonCrypto [system] { header "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include/CommonCrypto/CommonCrypto.h" export * }
module CommonCrypto [system] { header "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.0.sdk/usr/include/CommonCrypto/CommonCrypto.h" link "CommonCrypto" export * }
import CommonCrypto extension String { func hnk_MD5String() -> String { if let data = self.dataUsingEncoding(NSUTF8StringEncoding) { let result = NSMutableData(length: Int(CC_MD5_DIGEST_LENGTH)) let resultBytes = UnsafeMutablePointer<CUnsignedChar>(result.mutableBytes) CC_MD5(data.bytes, CC_LONG(data.length), resultBytes) let resultEnumerator = UnsafeBufferPointer<CUnsignedChar>(start: resultBytes, length: result.length) let MD5 = NSMutableString() for c in resultEnumerator { MD5.appendFormat("%02x", c) } return MD5 } return "" } }
module CCommonCrypto { header "/usr/include/CommonCrypto/CommonCrypto.h" export * }
FRAMEWORK_DIR="${BUILT_PRODUCTS_DIR}/CommonCrypto.framework" if [ -d "${FRAMEWORK_DIR}" ]; then echo "${FRAMEWORK_DIR} already exists, so skipping the rest of the script." exit 0 fi mkdir -p "${FRAMEWORK_DIR}/Modules" cat <<EOF > "${FRAMEWORK_DIR}/Modules/module.modulemap" module CommonCrypto [system] { header "${SDKROOT}/usr/include/CommonCrypto/CommonCrypto.h" export * } EOF ln -sf "${SDKROOT}/usr/include/CommonCrypto" "${FRAMEWORK_DIR}/Headers"
@implementation NSData (NSDataEncryptionExtension) - (NSData *)AES256EncryptWithKey:(NSString *)key { } - (NSData *)AES256DecryptWithKey:(NSString *)key { }
public extension String { func encryp(withKey key:String) -> String? { if let data = self.data(using: .utf8), let encrypedData = NSData(data: data).aes256Encrypt(withKey: key) { return encrypedData.base64EncodedString() } return nil } func decryp(withKey key:String) -> String? { if let data = NSData(base64Encoded: self, options: []), let decrypedData = data.aes256Decrypt(withKey: key) { return decrypedData.UTF8String } return nil } }
FRAMEWORK_DIR="${BUILT_PRODUCTS_DIR}/CommonCrypto.framework" if [ -d "${FRAMEWORK_DIR}" ]; then echo "${FRAMEWORK_DIR} already exists, so skipping the rest of the script." exit 0 fi mkdir -p "${FRAMEWORK_DIR}/Modules" echo "module CommonCrypto [system] { header "${SDKROOT}/usr/include/CommonCrypto/CommonCrypto.h" export * }" >> "${FRAMEWORK_DIR}/Modules/module.modulemap" ln -sf "${SDKROOT}/usr/include/CommonCrypto" "${FRAMEWORK_DIR}/Headers"
BOOL const DEBUG_BUILD = YES; BOOL const DEBUG_BUILD = NO;
if DEBUG_BUILD { println("debug") } else { println("release") }
func textFieldShouldReturn(textField: UITextField!) -> Bool { return true; }
func textFieldShouldReturn(_ textField: UITextField) -> Bool { self.view.endEditing(true) return false }
// // // import UIKit class ViewController: UIViewController, UITextFieldDelegate { @IBOutlet var myTextField : UITextField override func viewDidLoad() { super.viewDidLoad() self.myTextField.delegate = self } func textFieldShouldReturn(_ textField: UITextField) -> Bool { self.view.endEditing(true) return false } }
func textFieldShouldReturn(_ textField: UITextField) -> Bool { textField.resignFirstResponder() return true }
class ViewController: UIViewController, UITextFieldDelegate
override func viewDidLoad() { super.viewDidLoad() self.userText.delegate = self }
func textFieldShouldReturn(userText: UITextField!) -> Bool { userText.resignFirstResponder() return true; }
@IBAction func textField(_ sender: AnyObject) { self.view.endEditing(true); }
textField.addTarget(nil, action:"firstResponderAction:", forControlEvents:.EditingDidEndOnExit)
@IBAction func resignKeyboard(sender: AnyObject) { sender.resignFirstResponder() }
@IBAction func textFieldDoneEditing(sender: UITextField) { sender.resignFirstResponder()}
import Foundation import UIKit class ViewController: UIViewController, UITextFieldDelegate { required init(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } @IBOutlet var myTextField : UITextField? override func viewDidLoad() { super.viewDidLoad() self.myTextField.delegate = self; } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func textFieldShouldReturn(textField: UITextField!) -> Bool { self.view.endEditing(true); return false; }
textField.addTarget(nil, action:Selector(("firstResponderAction:")), for:.editingDidEndOnExit)
func textFieldShouldReturn(_ textField: UITextField) -> Bool { self.view.endEditing(true); return false; }
func textFieldShouldReturn(_ textField: UITextField) -> Bool { return textField.endEditing(false) }
@IBOutlet weak var emailLabel: UITextField! @IBOutlet weak var passwordLabel: UITextField! override func viewDidLoad() { super.viewDidLoad() self.emailLabel.delegate = self self.passwordLabel.delegate = self } func textFieldShouldReturn(_ textField: UITextField) -> Bool { textField.resignFirstResponder() return true } override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { self.view.endEditing(true); }
func TextFieldEndEditing(text fiend name: UITextField!) -> Bool { return (false) }
@IBAction func done(_ sender: UITextField) { sender.resignFirstResponder() }
func application (application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { application.statusBarHidden = true return true }
func application (application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { self.window = UIWindow(frame: UIScreen.mainScreen().bounds) var controller = UIViewController() application.statusBarHidden = true controller.setNeedsStatusBarAppearanceUpdate() var view = UIView(frame: CGRectMake(0, 0, 320, 568)) view.backgroundColor = UIColor.redColor() controller.view = view var label = UILabel(frame: CGRectMake(0, 0, 200, 21)) label.center = CGPointMake(160, 284) label.textAlignment = NSTextAlignment.Center label.text = "Hello World" controller.view.addSubview(label) self.window!.rootViewController = controller self.window!.makeKeyAndVisible() return true }
override func prefersStatusBarHidden() -> Bool { return true }
override var prefersStatusBarHidden: Bool { return true }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject:AnyObject]?) -> Bool { application.statusBarHidden = true return true }
UIApplication.shared.keyWindow?.windowLevel = UIWindowLevelStatusBar
UIApplication.shared.keyWindow?.windowLevel = UIWindowLevelNormal
override var prefersStatusBarHidden: Bool { return true }
override func viewWillAppear(animated: Bool) { super.viewWillAppear(true); navigationController?.navigationBar.hidden = true UIApplication.sharedApplication().statusBarHidden=true; }
override func viewWillAppear(_ animated: Bool) { UIApplication.shared.isStatusBarHidden = true }
extension UIViewController { func prefersStatusBarHidden() -> Bool { return true } }
UIApplication.sharedApplication().setStatusBarHidden(true, withAnimation: UIStatusBarAnimation.None)
override func prefersStatusBarHidden() -> Bool { return true }
var showStatusBar = true override func prefersStatusBarHidden() -> Bool { if showStatusBar { return false } return true } private func showStatusBar(enabled: Bool) { showStatusBar = enabled prefersStatusBarHidden() }
var showStatusBar = true override var prefersStatusBarHidden: Bool { if showStatusBar == true { print("does not prefer status bar hidden") return false } else { print("does prefer status bar hidden") return true } } showStatusBar = false setNeedsStatusBarAppearanceUpdate()
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { application.isStatusBarHidden = true return true }
open override var prefersStatusBarHidden: Bool { return true }
import UIKit class ViewController: UIViewController { private var hideStatusBar: Bool = false override var prefersStatusBarHidden: Bool { return hideStatusBar } override var preferredStatusBarUpdateAnimation: UIStatusBarAnimation { return UIStatusBarAnimation.slide } override func viewDidLoad() { super.viewDidLoad() view.backgroundcolor = .white hideStatusBar = true UIView.animate(withDuration: 0.3) { self.setNeedsStatusBarAppearanceUpdate() } }
UIApplication.shared.isStatusBarHidden = true UIApplication.shared.isStatusBarHidden = false
override var prefersStatusBarHidden: Bool { return true }
NSString(data data: NSData!, encoding encoding: UInt)
let data = string.dataUsingEncoding(NSUTF8StringEncoding)
let data = (string as NSString).dataUsingEncoding(NSUTF8StringEncoding)
let data = string.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)
var urlString: NSString = NSString(data: jsonData, encoding: NSUTF8StringEncoding) var stringData: NSString = NSString(string: "jsonRequest=\(urlString)") var requestBodyData: NSData = stringData.dataUsingEncoding(NSUTF8StringEncoding)!
let data = myStringVariable.data(using: String.Encoding.utf8.rawValue)
let data = yourString.data(using: .utf8, allowLossyConversion: true)
class Point { var x: Int { set { x = newValue * 2 } get { return x / 2 } } }
class Point { private var _x: Int = 0 var x: Int { set { _x = 2 * newValue } get { return _x / 2 } } }
15> var pt = Point() pt: Point = { _x = 0 } 16> pt.x = 10 17> pt $R3: Point = { _x = 20 } 18> pt.x $R4: Int = 10
var x:Int var xTimesTwo:Int { set { x = newValue / 2 } get { return x * 2 } }
class Point { var x:Int { didSet { x = x * 2 } } ...
class Point { var doubleX: Int { get { return x / 2 } } ...
var x:Int { set { x = newValue * 2 } get { return x / 2 } }
struct Point { var x = 0.0, y = 0.0 } struct Size { var width = 0.0, height = 0.0 } struct AlternativeRect { var origin = Point() var size = Size() var center: Point { get { let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) } set { origin.x = newValue.x - (size.width / 2) origin.y = newValue.y - (size.height / 2) } } }
var temX : Int? var x: Int?{ set(newX){ temX = newX } get{ return temX } }
struct Person{ var name: String{ get{ print(name) return "as" } set{ } } } let p1 = Person()
class Triangle: { var sideLength: Double = 0.0 init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 3 } var perimeter: Double { get { return 3.0 * sideLength } set { sideLength = newValue / 4.0 } }
var triangle = Triangle(sideLength: 3.9, name: "a triangle")
var x:Int! var xTimesTwo:Int { get { return x * 2 } set { x = newValue / 2 } }
import Foundation import UIKit class HomeTable: UITableViewController, UITableViewDataSource, UITableViewDelegate { @IBOutlet var tableViex: UITableView! var items: [(String, String, String)] = [ ("Test", "123", "1.jpeg"), ("Test2", "236", "2.jpeg"), ("Test3", "678", "3.jpeg") ] override func viewDidLoad() { super.viewDidLoad() var nib = UINib(nibName: "HomeCell", bundle: nil) tableView.registerNib(nib, forCellReuseIdentifier: "bookCell") } override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return self.items.count } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { var cell:UITableViewCell = self.tableView.dequeueReusableCellWithIdentifier("bookCell") as UITableViewCell return cell } override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { } } class HomeCell : UITableViewCell { @IBOutlet var imgBook: UIImageView @IBOutlet var titleBook: UILabel @IBOutlet var pageBook: UILabel func loadItem( titleBook.text = title pageBook.text = page imgBook.image = UIImage(named: image) } }
@IBOutlet var imgBook: UIImageView! @IBOutlet var titleBook: UILabel! @IBOutlet var pageBook: UILabel!
class Actor { let agent : String? init (agent: String?){ self.agent = agent } }
class Actor { let agent : String? = nil let company: String? = "Universal" }
class Actor { let agent : String? init (agent: String?){ self.agent = agent } }
class Actor { let agent : String? = nil let company: String? = "Universal" }
extension T[] : ArrayType { init() var count: Int { get } var capacity: Int { get } var isEmpty: Bool { get } func copy() -> T[] }
extension T[] : ArrayType { func foo(){} } extension T[] { func foo(){} }
extension Array { func each(fn: (Any) -> ()) { for i in self { fn(i) } } }
extension Array { func find<T>(fn: (T) -> Bool) -> T[] { var to = T[]() for x in self { let t = x as T if fn(t) { to += t } } return to } }
["A","B","C"].find { ($0 as String).compare("A") > 0 }
class HighScoreEntry { let score:Int } extension Array where Element:HighScoreEntry { func sort() -> [HighScoreEntry] { return sort { $0.score < $1.score } } }
typealias HighScoreEntry = (Int) extension SequenceType where Generator.Element == HighScoreEntry { func sort() -> [HighScoreEntry] { return sort { $0 < $1 } } }
extension Sequence where Iterator.Element == HighScoreEntry { }
extension Array { func find(fn: (T) -> Bool) -> [T] { var to = [T]() for x in self { let t = x as T; if fn(t) { to += t } } return to } }
extension Array { mutating func swap(x:[Element]) { self.removeAll() self.appendContentsOf(x) } }
extension Array where Element: Hashable { /** * Remove duplicate elements from an array * * - returns: A new array without duplicates */ func removeDuplicates() -> [Element] { var result: [Element] = [] for value in self { if !result.contains(value) { result.append(value) } } return result } /** * Remove duplicate elements from an array */ mutating func removeDuplicatesInPlace() { var result: [Element] = [] for value in self { if !result.contains(value) { result.append(value) } } self = result } }
var dupes = ["one", "two", "two", "three"] let deDuped = dupes.removeDuplicates() dupes.removeDuplicatesInPlace()
extension CollectionType { func filter(@noescape includeElement: (Self.Generator.Element) -> Bool) -> [Self.Generator.Element] }
extension CollectionType { func mapfilter<T>(@noescape transform: (Self.Generator.Element) -> T?) -> [T] { var result: [T] = [] for x in self { if let t = transform (x) { result.append (t) } } return result } }
extension Array { func at(indexes: Int...) -> [Element] { ... } }
import Foundation extension Array { var randomItem: Element? { let idx = Int(arc4random_uniform(UInt32(self.count))) return self.isEmpty ? nil : self[idx] } }
protocol MyTypes { var intValue: Int { get } init(_ value: Int) func *(lhs: Self, rhs: Self) -> Self func +=(inout lhs: Self, rhs: Self) } extension Int : MyTypes { var intValue: Int { return self } } extension Double : MyTypes { var intValue: Int { return Int(self) } } struct MyCustomType : MyTypes { var myInt : Int? = 0 var intValue: Int { return myInt ?? 0 } init(_ value: Int) { myInt = value } } func *(lhs: MyCustomType, rhs: MyCustomType) -> MyCustomType { return MyCustomType(lhs.intValue * rhs.intValue) } func +=(inout lhs: MyCustomType, rhs: MyCustomType) { lhs.myInt = (lhs.myInt ?? 0) + (rhs.myInt ?? 0) }
protocol MyFunctionalUtils { func foo<T: MyTypes>(a: [T]) -> Int? } extension Array : MyFunctionalUtils { func foo<T: MyTypes>(a: [T]) -> Int? { if let b = self.first { if b is T && self.count == a.count { var myMultSum: T = T(0) for (i, sElem) in self.enumerate() { myMultSum += (sElem as! T) * a[i] } return myMultSum.intValue } } return nil } }
let arr1d : [Double] = [1.0, 2.0, 3.0] let arr2d : [Double] = [-3.0, -2.0, 1.0] let arr1my : [MyCustomType] = [MyCustomType(1), MyCustomType(2), MyCustomType(3)] let arr2my : [MyCustomType] = [MyCustomType(-3), MyCustomType(-2), MyCustomType(1)] func bar1<U: MyTypes> (arr1: [U], _ arr2: [U]) -> Int? { return arr1.foo(arr2) } let myInt1d = bar1(arr1d, arr2d) let myInt1my = bar1(arr1my, arr2my) func bar2<T: MyTypes, U: protocol<MyFunctionalUtils, _ArrayType> where U.Generator.Element == T> (arr1: U, _ arr2: U) -> Int? { var a = arr1 var b = arr2 a.append(T(2)) b.append(T(7)) return a.foo(Array(b)) } let myInt2d = bar2(arr1d, arr2d) let myInt2my = bar2(arr1my, arr2my)
import Foundation extension Array { func calculateMean() -> Double { if self.first is Double { let doubleArray = self.map { $0 as! Double } let total = doubleArray.reduce(0.0, combine: {$0 + $1}) let meanAvg = total / Double(self.count) return meanAvg } else { return Double.NaN } } func calculateMedian() -> Double { if self.first is Double { var doubleArray = self.map { $0 as! Double } doubleArray.sort( {$0 < $1} ) var medianAvg : Double if doubleArray.count % 2 == 0 { var halfway = doubleArray.count / 2 medianAvg = (doubleArray[halfway] + doubleArray[halfway - 1]) / 2 } else { medianAvg = doubleArray[doubleArray.count / 2 ] } return medianAvg } else { return Double.NaN } } }
NSString *filePath = [[NSBundle mainBundle] pathForResource:@"Config" ofType:@"plist"]; NSDictionary *dict = [[NSDictionary alloc] initWithContentsOfFile:filePath];
let path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist")
var nsDictionary: NSDictionary? if let path = Bundle.main.path(forResource: "Config", ofType: "plist") { nsDictionary = NSDictionary(contentsOfFile: path) }
if let path = Bundle.main.path(forResource: "Config", ofType: "plist"), let myDict = NSDictionary(contentsOfFile: path){ }
var myDict: NSDictionary? if let path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist") { myDict = NSDictionary(contentsOfFile: path) } if let dict = myDict { }
if let path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist") { if let dict = NSDictionary(contentsOfFile: path) as? Dictionary<String, AnyObject> { } }
if let path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist"), dict = NSDictionary(contentsOfFile: path) as? [String: AnyObject] { }
if let path = Bundle.main.path(forResource: "Config", ofType: "plist"), let dict = NSDictionary(contentsOfFile: path) as? [String: AnyObject] { }
func readPropertyList() { var propertyListForamt = PropertyListSerialization.PropertyListFormat.xml var plistData: [String: AnyObject] = [:] let plistPath: String? = Bundle.main.path(forResource: "data", ofType: "plist")! let plistXML = FileManager.default.contents(atPath: plistPath!)! do { plistData = try PropertyListSerialization.propertyList(from: plistXML, options: .mutableContainersAndLeaves, format: &propertyListForamt) as! [String:AnyObject] } catch { print("Error reading plist: \(error), format: \(propertyListForamt)") } }
struct Config: Decodable { private enum CodingKeys: String, CodingKey { case name, age, single } let name: String let age: Int let single: Bool }
func parseConfig() -> Config { let url = Bundle.main.url(forResource: "Config", withExtension: "plist")! let data = try! Data(contentsOf: url) let decoder = PropertyListDecoder() return try! decoder.decode(Config.self, from: data) }
let config = parseConfig() print(config.name) print(config.age) print(config.single)
guard let plistPath = Bundle.main.path(forResource: "level1", ofType: "plist") else { return } guard let plistData = FileManager.default.contents(atPath: plistPath) else { return } var format = PropertyListSerialization.PropertyListFormat.xml guard let plistDict = try! PropertyListSerialization.propertyList(from: plistData, options: .mutableContainersAndLeaves, format: &format) as? [String : AnyObject] else { return } if let value = plistDict["aKey"] as? String { print(value) } var myValue = plistDict["aKey"] ?? ""
let path = Bundle.main().pathForResource("DefaultSiteList", ofType: "plist")! let url = URL(fileURLWithPath: path) let data = try! Data(contentsOf: url) let plist = try! PropertyListSerialization.propertyList(from: data, options: .mutableContainers, format: nil)
var path = NSBundle.mainBundle().pathForResource("Config", ofType: "plist") var dict = NSDictionary(contentsOfFile: path)
override func viewDidLoad() { super.viewDidLoad() let fileManager = (NSFileManager .defaultManager()) let directorys : [String]? = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory,NSSearchPathDomainMask.AllDomainsMask, true) as? [String] if (directorys != nil){ let directories:[String] = directorys!; let dictionary = directories[0]; let plistfile = "myPlist.plist" var myDictionary: NSMutableDictionary = ["Content": "This is a sample Plist file ........."] let plistpath = dictionary.stringByAppendingPathComponent(plistfile); if !fileManager .fileExistsAtPath(plistpath){ myDictionary.writeToFile(plistpath, atomically: false) } else{ println("Plist file found") let resultDictionary = NSMutableDictionary(contentsOfFile: plistpath) println(resultDictionary?.description) } let textfile = "myText.txt" let sampleText = "This is a sample text file ......... " let textpath = dictionary.stringByAppendingPathComponent(textfile); if !fileManager .fileExistsAtPath(textpath){ sampleText.writeToFile(textpath, atomically: false, encoding: NSUTF8StringEncoding, error: nil); } else{ let reulttext = String(contentsOfFile: textpath, encoding: NSUTF8StringEncoding, error: nil) println(reulttext) } } else { println("directory is empty") } }
let path = NSBundle.mainBundle().pathForResource("Info", ofType: "plist")! let dict = NSDictionary(contentsOfFile: path) as! [String: AnyObject] if let CoachMarksDict = dict["CoachMarksDictionary"] { print("Info.plist : \(CoachMarksDict)") var dashC = CoachMarksDict["DashBoardCompleted"] as! Bool print("DashBoardCompleted state :\(dashC) ") }
func writeToCoachMarksPlist(status:String?,keyName:String?) { let path1 = NSBundle.mainBundle().pathForResource("CoachMarks", ofType: "plist") let coachMarksDICT = NSMutableDictionary(contentsOfFile: path1!)! as NSMutableDictionary var coachMarksMine = coachMarksDICT.objectForKey(keyName!) coachMarksMine = status coachMarksDICT.setValue(status, forKey: keyName!) coachMarksDICT.writeToFile(path1!, atomically: true) }
self.writeToCoachMarksPlist(" true - means user has checked the marks",keyName: "the key in the CoachMarks dictionary").
var dict = NSDictionary(contentsOfFile: NSBundle.mainBundle().pathForResource("Config", ofType: "plist"))
let path = NSBundle.mainBundle().pathForResource("PriceList", ofType: "plist") let dict = NSDictionary(contentsOfFile: path)
let value: AnyObject = dict.objectForKey("index2").objectForKey("date")
<plist version="1.0"> <dict> <key>index2</key> <dict> <key>date</key> <string>20140610</string> <key>amount</key> <string>110</string> </dict> <key>index1</key> <dict> <key>amount</key> <string>125</string> <key>date</key> <string>20140212</string> </dict> </dict> </plist>
extension Dictionary { static func contentsOf(path: URL) -> Dictionary<String, AnyObject> { let data = try! Data(contentsOf: path) let plist = try! PropertyListSerialization.propertyList(from: data, options: .mutableContainers, format: nil) return plist as! [String: AnyObject] } }
let path = Bundle.main.path(forResource: "plistName", ofType: "plist")! let url = URL(fileURLWithPath: path) let dict = Dictionary<String, AnyObject>.contentsOf(path: url)
extension Dictionary { /** Load a Plist file from the app bundle into a new dictionary :param: File name :return: Dictionary<String, AnyObject>? */ static func loadPlistFromProject(filename: String) -> Dictionary<String, AnyObject>? { if let path = NSBundle.mainBundle().pathForResource("GameParam", ofType: "plist") { return NSDictionary(contentsOfFile: path) as? Dictionary<String, AnyObject> } println("Could not find file: \(filename)") return nil } }
/** Example function for load Files Plist :param: Name File Plist */ func loadPlist(filename: String) -> ExampleClass? { if let dictionary = Dictionary<String, AnyObject>.loadPlistFromProject(filename) { let stringValue = (dictionary["name"] as NSString) let intergerValue = (dictionary["score"] as NSString).integerValue let doubleValue = (dictionary["transition"] as NSString).doubleValue return ExampleClass(stringValue: stringValue, intergerValue: intergerValue, doubleValue: doubleValue) } return nil }
if let dict = NSBundle.mainBundle().objectForInfoDictionaryKey("appSettings") { if let configAppToken = dict["myKeyInsideAppSettings"] as? String { } }
guard let path = Bundle.main.path(forResource: "GoogleService-Info", ofType: "plist"), let myDict = NSDictionary(contentsOfFile: path) else { return nil } let value = dict.value(forKey: "CLIENT_ID") as! String?
if let path = Bundle.main.path(forResource: "config", ofType: "plist") { let dict = NSDictionary(contentsOfFile: path) }
extension Dictionary where Key == String, Value == Any { public init?(contentsOfFile path: String) { let url = URL(fileURLWithPath: path) self.init(contentsOfURL: url) } public init?(contentsOfURL url: URL) { guard let data = try? Data(contentsOf: url), let dictionary = (try? PropertyListSerialization.propertyList(from: data, options: [], format: nil) as? [String: Any]) ?? nil else { return nil } self = dictionary } }
let filePath = Bundle.main.path(forResource: "Preferences", ofType: "plist")! let preferences = Dictionary(contentsOfFile: filePath)! UserDefaults.standard.register(defaults: preferences)
extension Bundle { func parsePlist(ofName name: String) -> [String: AnyObject]? { guard let plistURL = Bundle.main.url(forResource: name, withExtension: "plist"), let data = try? Data(contentsOf: plistURL) else { return nil } guard let plistDictionary = try? PropertyListSerialization.propertyList(from: data, options: [], format: nil) as? [String: AnyObject] else { return nil } return plistDictionary } }
let levelBlocks = NSDictionary(contentsOfFile: NSBundle.mainBundle().pathForResource("LevelBlocks", ofType: "plist")) let test: AnyObject = levelBlocks.objectForKey("Level1") println(test)
let value = levelBlocks.objectForKey("Level1").objectForKey("amount") as Int println(toString(value))
func writePlist(fileName:String, myDict:Dictionary<String, AnyObject>){ let docsDir:String = dirPaths[0] as String let docPath = docsDir + "/" + fileName let thisDict = myDict as NSDictionary if(thisDict.writeToFile(docPath, atomically: true)){ NSLog("success") } else { NSLog("failure") } } func getPlist(fileName:String)->Dictionary<String, AnyObject>{ let docsDir:String = dirPaths[0] as String let docPath = docsDir + "/" + fileName let thisDict = NSDictionary(contentsOfFile: docPath) return thisDict! as! Dictionary<String, AnyObject> }
let info = Plist(NSBundle.mainBundle().infoDictionary) let identifier = info["CFBundleIndentifier"].string!
import Plist let info = Plist(dict) let name = info["name"].string ?? "" let age = info["age"].int ?? 0 let info = Plist(array) let itemAtIndex0 = info[0].value let info = Plist(path: "path_to_plist_file") if let complicatedAccessOfSomeStringValueOfInterest = info["dictKey"][10]["anotherKey"].string { } else { } let info = Plist(...) let firstSection = info["Sections"][0]["SectionData"] let sectionKey = firstSection["key"].string! let sectionSecret = firstSection["secret"].int!
// // import Foundation public enum Plist { case dictionary(NSDictionary) case Array(NSArray) case Value(Any) case none public init(_ dict: NSDictionary) { self = .dictionary(dict) } public init(_ array: NSArray) { self = .Array(array) } public init(_ value: Any?) { self = Plist.wrap(value) } } extension Plist { public init(path: String) { if let dict = NSDictionary(contentsOfFile: path) { self = .dictionary(dict) } else if let array = NSArray(contentsOfFile: path) { self = .Array(array) } else { self = .none } } } extension Plist { fileprivate static func wrap(_ object: Any?) -> Plist { if let dict = object as? NSDictionary { return .dictionary(dict) } if let array = object as? NSArray { return .Array(array) } if let value = object { return .Value(value) } return .none } fileprivate func cast<T>() -> T? { switch self { case let .Value(value): return value as? T default: return nil } } } extension Plist { public subscript(key: String) -> Plist { switch self { case let .dictionary(dict): let v = dict.object(forKey: key) return Plist.wrap(v) default: return .none } } public subscript(index: Int) -> Plist { switch self { case let .Array(array): if index >= 0 && index < array.count { return Plist.wrap(array[index]) } return .none default: return .none } } } extension Plist { public var string: String? { return cast() } public var int: Int? { return cast() } public var double: Double? { return cast() } public var float: Float? { return cast() } public var date: Date? { return cast() } public var data: Data? { return cast() } public var number: NSNumber? { return cast() } public var bool: Bool? { return cast() } public var value: Any? { switch self { case let .Value(value): return value case let .dictionary(dict): return dict case let .Array(array): return array case .none: return nil } } public var array: NSArray? { switch self { case let .Array(array): return array default: return nil } } public var dict: NSDictionary? { switch self { case let .dictionary(dict): return dict default: return nil } } } extension Plist : CustomStringConvertible { public var description:String { switch self { case let .Array(array): return "(array \(array))" case let .dictionary(dict): return "(dict \(dict))" case let .Value(value): return "(value \(value))" case .none: return "(none)" } } }
if let path = Bundle.main.path(forResource: "Info", ofType: "plist") { if let dimension1 = NSDictionary(contentsOfFile: path) { if let dimension2 = dimension1["key"] as? [String] { destination_array = dimension2 } } }
<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE plist PUBLIC "- <plist version="1.0"> <array> <dict> <key>identity</key> <string>blah-1</string> <key>major</key> <string>1</string> <key>minor</key> <string>1</string> <key>uuid</key> <string>f45321</string> <key>web</key> <string>http: </dict> <dict> <key>identity</key> <string></string> <key>major</key> <string></string> <key>minor</key> <string></string> <key>uuid</key> <string></string> <key>web</key> <string></string> </dict> </array> </plist> do { let plistXML = try Data(contentsOf: url) var plistData: [[String: AnyObject]] = [[:]] var propertyListForamt = PropertyListSerialization.PropertyListFormat.xml do { plistData = try PropertyListSerialization.propertyList(from: plistXML, options: .mutableContainersAndLeaves, format: &propertyListForamt) as! [[String:AnyObject]] } catch { print("Error reading plist: \(error), format: \(propertyListForamt)") } } catch { print("error no upload") }
struct Configuration { static let path = NSBundle.mainBundle().pathForResource("Info", ofType: "plist")! static let dict = NSDictionary(contentsOfFile: path) as! [String: AnyObject] static let someValue = dict["someKey"] as! String }
NSString *string = @"Swift"; NSString *resultStr = [string stringByAppendingString:@" is new Programming Language"];
NSString *resultStr=[NSString stringWithFormat:@"%@ is new Programming Language",string];
let a = "Hello" let b = "World" let first = a + ", " + b let second = "\(a), \(b)"
var language = "Swift" var resultStr = "\(language) is new Programming Language"
var string = "swift" var resultStr = string + " is a new Programming Language"
var first = "Hi" var combineStr = "\(first) Start develop app for swift"
var first = "Hi" var combineStr = "+(first) Start develop app for swift"
let the_string = "Swift" let resultString = "\(the_string) is a new Programming Language"
let StringA = "Hello" let StringB = "World" let ResultString = "\(StringA)\(StringB)" println("Concatenated result = \(ResultString)")
var string = "Swift" var resultString = string.stringByAppendingString(" is new Programming Language")
extension String { mutating func addString(str: String) { self = self + str } }
var str1: String? var str1 = "hi" var str2 = " my name is" str1.addString(str2) println(str1)
var str1: String? var str1 = "hi" var str2 = " my name is" str1! += str2
let price = 3 let staringValue = "The price of \(price) mangoes is equal to \(price*price) "
let string1 = "anil" let string2 = "gupta" let fullName = string1 + string2 or let fullName = "\(string1)\(string2)"
var finalString : NSString = NSString(string: "Hello") finalString = finalString.stringByAppendingFormat("%@", " World") print(finalString) finalString = finalString.stringByAppendingFormat("%@", " Of People") print(finalString)
"".join(["string1", "string2", "string3"]) " ".join(["hello", "world"])
let allWords = String(format:"%@ %@ %@",message.body!, message.subject!, message.senderName!)
extension Array where Element == String? { func compactConcate(separator: String) -> String { return self.compactMap { $0 }.filter { !$0.isEmpty }.joined(separator: separator) } }
label.text = [m.firstName, m.lastName].compactConcate(separator: " ")
class Shape { var numberOfSides = 0 var name: String init(name:String) { self.name = name } func simpleDescription() -> String { return "A shape with \(numberOfSides) sides." } } class Square: Shape { var sideLength: Double init(sideLength:Double, name:String) { super.init(name:name) self.sideLength = sideLength numberOfSides = 4 } func area () -> Double { return sideLength * sideLength } }
class B: A { var y: Int init(x: Int, y: Int) { self.y = y super.init(x: x) } }
class Square: Shape { var sideLength: Double init(sideLength:Double, name:String) { self.sideLength = sideLength numberOfSides = 4 super.init(name:name) } func area () -> Double { return sideLength * sideLength } }
class Shape { var name: String var sides : Int init(sides:Int, named: String) { self.sides = sides self.name = named } } class Triangle: Shape { var hypotenuse: Int init(hypotenuse:Int) { super.init(sides: 3, named: "Triangle") self.hypotenuse = hypotenuse } }
class Shape { var name: String var sides : Int init(sides:Int, named: String) { self.sides = sides self.name = named printShapeDescription() } func printShapeDescription() { print("Shape Name :\(self.name)") print("Sides :\(self.sides)") } } class Triangle: Shape { var hypotenuse: Int init(hypotenuse:Int) { self.hypotenuse = hypotenuse super.init(sides: 3, named: "Triangle") } override func printShapeDescription() { super.printShapeDescription() print("Hypotenuse :\(self.hypotenuse)") } } let triangle = Triangle(hypotenuse: 12)
class Square: Shape { var sideLength: Double? init(sideLength:Double, name:String) { super.init(name:name) self.sideLength = sideLength numberOfSides = 4 } func area () -> Double { return sideLength * sideLength } }
class Square: Shape { var sideLength: Double=Double() init(sideLength:Double, name:String) { super.init(name:name) self.sideLength = sideLength numberOfSides = 4 } func area () -> Double { return sideLength * sideLength } }
class Square: Shape { var sideLength: Double init(sideLength:Double, name:String) { self.sideLength = sideLength super.init(name:name) numberOfSides = 4 } func area () -> Double { return sideLength * sideLength } }
var playerShip:PlayerShip! var deltaPoint = CGPointZero init(size: CGSize) { super.init(size: size) playerLayerNode.addChild(playerShip) }
var someProtocol:SomeProtocol? = nil override init(frame: CGRect) super.init(frame: frame) ...
class Shape2 { var numberOfSides = 0 var name: String init(name:String) { self.name = name } func simpleDescription() -> String { return "A shape with \(numberOfSides) sides." } } class Square2: Shape2 { var sideLength: Double init(sideLength:Double, name:String) { self.sideLength = sideLength super.init(name:name) numberOfSides = 4 } func area () -> Double { return sideLength * sideLength } }
. . . var playerShip:PlayerShip var deltaPoint = CGPointZero init(size: CGSize) { super.init(size: size) playerShip = PlayerShip(pos: CGPointMake(self.size.width / 2.0, 100)) playerLayerNode.addChild(playerShip) } . . .
. . . var playerShip:PlayerShip = PlayerShip(pos: CGPointMake(self.size.width / 2.0, 100)) var deltaPoint = CGPointZero init(size: CGSize) { super.init(size: size) playerLayerNode.addChild(playerShip) } . . .
let multiples = [...] sum = multiples.reduce(0, combine: +)
var totalSum = scaleData.map({$0.points}).reduce(0, +)
let arr = [1,2,3,4,5,6,7,8,9,10] var sumedArr = arr.reduce(0, combine: {$0 + $1}) print(sumedArr)
class Employee { var salary: Int = 0 init (_ salary: Int){ self.salary = salary } } let employees = [Employee(100),Employee(300),Employee(600)] var sumSalary = employees.reduce(0, {$0 + $1.salary})
for (var i = 0; i < n; i++) { sum = sum + Int(multiples[i])! }
class A: NSObject { var value = 0 init(value: Int) { self.value = value } } let array = [A(value: 2), A(value: 4)] let sum = array.reduce(0, { $0 + $1.value }) print(sum)
let array = [A(value: 2), A(value: 4)] var sum = 0 array.forEach({ sum += $0.value}) for element in array { sum += element.value }
protocol Number { func +(l: Self, r: Self) -> Self func -(l: Self, r: Self) -> Self func >(l: Self, r: Self) -> Bool func <(l: Self, r: Self) -> Bool } extension Double : Number {} extension Float : Number {} extension Int : Number {} infix operator += {} func += <T:Number> (inout left: T, right: T) { left = left + right } prefix operator +/ {} prefix func +/ <T:Number>(ar:[T]?) -> T? { switch true { case ar == nil: return nil case ar!.isEmpty: return nil default: var result = ar![0] for n in 1..<ar!.count { result += ar![n] } return result } }
let nmbrs = [ 12.4, 35.6, 456.65, 43.45 ] let intarr = [1, 34, 23, 54, 56, -67, 0, 44] +/nmbrs +/intarr
let numbers = [1, 2, 3, 4] let addTwo: (Int, Int) -> Int = { x, y in x + y } let numberSum = numbers.reduce(0, addTwo)
let numberSum = self.list.map({$0.number_here}).reduce(0, { x, y in x + y })
extension Collection where Element: Numeric { func sum() -> Element { return reduce(0, +) } }
let numbers = [1,2,3] numbers.sum() let doubles = [1.5, 2.7, 3.0] doubles.sum()
@IBOutlet var valueSource: [MultipleIntBoundSource]! private var allFieldsCount: Int { var sum = 0 valueSource.forEach { sum += $0.count } return sum }
let arr = [6,1,2,3,4,10,11] var sumedArr = arr.reduce(0, { ($0 + $1)}) print(sumedArr)
var array = [1, 2, 3, 4, 5, 6, 7, 9, 0] var n = 0 for i in array { n += i } print("My sum of elements is: \(n)")
self.rankDataModelArray.flatMap{$0.count}.reduce(0, +)
var i = 0 var sum = 0 let example = 0 for elements in multiples{ i = i + 1 sum = multiples[ (i- 1)] example = sum + example }
class SomeClass { var someProperty: AnyObject { didSet { doStuff() } } init(someProperty: AnyObject) { self.someProperty = someProperty doStuff() } func doStuff() { } }
class SomeClass { var someProperty: AnyObject! { didSet { } } init(someProperty: AnyObject) { setSomeProperty(someProperty) } func setSomeProperty(newValue:AnyObject) { self.someProperty = newValue } }
public class MyNewType: NSObject { public var myRequiredField:Int public var myOptionalField:Float? { willSet { if let newValue = newValue { print("I } } didSet { if let myOptionalField = self.myOptionalField { print("Now I } } } override public init() { self.myRequiredField = 1 super.init() self.myOptionalField = 6.28 defer { self.myOptionalField = 3.14 } } }
class Classy { var foo: Int! { didSet { doStuff() } } init( foo: Int ) { ({ self.foo = foo })() } }
class SomeClass { var someProperty: AnyObject { didSet { doStuff() } } init(someProperty: AnyObject) { defer { self.someProperty = someProperty } } func doStuff() { } }
class Base { var someProperty: AnyObject { didSet { doStuff() } } required init() { someProperty = "hello" } func doStuff() { print(someProperty) } } class SomeClass: Base { required init() { super.init() someProperty = "hello" } } let a = Base() let b = SomeClass()
class SomeClass { var someProperty: AnyObject { didSet { } } class func createInstance(someProperty: AnyObject) -> SomeClass { let instance = SomeClass() instance.someProperty = someProperty return instance } }
override init(frame: CGRect) { super.init(frame: frame) someProperty = super.someProperty }
class SomeClass { private var _someProperty: AnyObject! var someProperty: AnyObject{ get{ return _someProperty } set{ _someProperty = newValue doStuff() } } init(someProperty: AnyObject) { self.someProperty = someProperty doStuff() } func doStuff() { } }
CGFloat screenWidth = screenSize.width; CGFloat screenHeight = screenSize.height;
let screenSize = UIScreen.main.bounds let screenWidth = screenSize.width let screenHeight = screenSize.height
let screenSize: CGRect = UIScreen.mainScreen().bounds
let screenWidth = screenSize.width let screenHeight = screenSize.height
public var screenWidth: CGFloat { return UIScreen.main.bounds.width } public var screenHeight: CGFloat { return UIScreen.main.bounds.height }
class SomeClass { var name: String init(name: String) { self.name = name } } var aClass = SomeClass(name: "Bob") var bClass = aClass bClass.name = "Sue" println(aClass.name) println(bClass.name)
struct SomeStruct { var name: String init(name: String) { self.name = name } } var aStruct = SomeStruct(name: "Bob") var bStruct = aStruct bStruct.name = "Sue" println(aStruct.name) println(bStruct.name)
struct Resolution { var width = 2 var height = 3 } let hd = Resolution(width: 1920, height: 1080) var cinema = hd println("Width of cinema instance is \(cinema.width)") println("Width of hd instance is \(hd.width)") cinema.width = 2048 println("Width of cinema instance is \(cinema.width)") println("Width of hd instance is \(hd.width)")
struct SomeStruct { var a : Int; init(_ a : Int) { self.a = a } } class SomeClass { var a: Int; init(_ a: Int) { self.a = a } } var x = 11 var someStruct1 = SomeStruct(x) var someClass1 = SomeClass(x) var someStruct2 = someStruct1 var someClass2 = someClass1 someClass1.a = 12 someClass2.a someStruct1.a = 14 someStruct2.a
class MyClass { var myName: String init(myName: String){ self.myName = myName; } } var myClassExistingName = MyClass(myName: "DILIP") var myClassNewName = myClassExistingName myClassNewName.myName = "John" print("Current Name: ",myClassExistingName.myName) print("Modified Name", myClassNewName.myName) print("*************************") struct myStruct { var programmeType: String init(programmeType: String){ self.programmeType = programmeType } } var myStructExistingValue = myStruct(programmeType: "Animation") var myStructNewValue = myStructExistingValue myStructNewValue.programmeType = "Thriller" print("myStructExistingValue: ", myStructExistingValue.programmeType) print("myStructNewValue: ", myStructNewValue.programmeType)
Current Name: John Modified Name John ************************* myStructExistingValue: Animation myStructNewValue: Thriller
class PointClass: Equatable { var x: Double var y: Double init(x: Double, y: Double) { self.x = x self.y = y } static func == (lhs: PointClass, rhs: PointClass) -> Bool { return lhs.x == rhs.x && lhs.y == rhs.y } } var pointClassInstanceA = PointClass(x: 0, y: 0) var pointClassInstanceB = pointClassInstanceA assert(pointClassInstanceA==pointClassInstanceB) pointClassInstanceB.x = 10 print(pointClassInstanceA.x)
struct PointStruct: Equatable { var x: Double var y: Double init(x: Double, y: Double) { self.x = x self.y = y } static func == (lhs: PointStruct, rhs: PointStruct) -> Bool { return lhs.x == rhs.x && lhs.y == rhs.y } } var pointStructInstanceA = PointStruct(x: 0, y: 0) var pointStructInstanceB = pointStructInstanceA assert(pointStructInstanceA==pointStructInstanceB) pointStructInstanceB.x = 100 print(pointStructInstanceA.x)
struct Radio1{ var name:String } struct Car1{ var radio:Radio1? var model:String } var i1 = Car1(radio: Radio1(name:"murphy"),model:"sedan") var i2 = i1 i2.radio?.name i2.radio = Radio1(name: "alpha") i2.radio?.name i1.radio?.name class Radio2{ var name:String init(name:String) { self.name = name } } struct Car2{ var radio:Radio2? var model:String } var i3 = Car2(radio: Radio2(name:"murphy"),model:"sedan") var i4 = i3 i4.radio?.name i4.radio?.name="alpha" i4.radio?.name i3.radio?.name //
1.structure is value type. = > when we assign structure variable to other variable or pass as parameter to function, it creates separate/new copy => so that changes made on one variable does not reflect on another.[We can say like **call by value** concept] Example : struct DemoStruct { var value: String init(inValue: String) { self.value = inValue } } var aStruct = DemoStruct(inValue: "original") var bStruct = aStruct bStruct.value = "modified" print(aStruct.value) print(bStruct.value) 2.class is reference type. = > when we assign structure variable to other variable or pass as parameter to function, it **does not** creates separate/new copy => so that changes made on one variable does not reflect on another.[We can say like **call by reference** concept] Example: class DemoClass { var value: String init(inValue: String) { self.value = inValue } } var aClass = DemoClass(inName: "original") var bClass = aClass bClass.value = "modified" print(aClass.value) print(bClass.value)
sesh.dataTaskWithRequest(req, completionHandler: {(data, response, error)
func displayQRCode(receiveAddr, withAmountInBTC:amountBTC)
let time = dispatch_time(DISPATCH_TIME_NOW, Int64(0.0 * Double(NSEC_PER_MSEC))) dispatch_after(time, dispatch_get_main_queue(), { let returned = UIApplication.sharedApplication().sendAction("displayQRCode:", to: self.delegate, from: self, forEvent: nil) })
dispatch_async(dispatch_get_main_queue(), { let delegateObj = UIApplication.sharedApplication().delegate as YourAppDelegateClass delegateObj.addUIImage("yourstring") })
DispatchQueue.main.async { let delegateObj = UIApplication.sharedApplication().delegate as YourAppDelegateClass delegateObj.addUIImage("yourstring") }
DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { }
dispatch_async(dispatch_get_main_queue()) { self.tableView.reloadData() }
NSOperationQueue.mainQueue().addOperationWithBlock({ })
dispatch_async(dispatch_get_main_queue(), { (self.delegate as TBGQRCodeViewController).displayQRCode(receiveAddr, withAmountInBTC:amountBTC) })
func dispatch_on_main(block: dispatch_block_t) { dispatch_async(dispatch_get_main_queue(), block) }
dispatch_async(dispatch_get_main_queue(),{ [weak self] () -> () in if let strongSelf = self { self?.doSomething() } })
DispatchQueue.main.async { self.collectionView.reloadData() }
DispatchQueue.global(qos: .userInitiated).async { DispatchQueue.main.async { self.tableView.reloadData() } } DispatchQueue.main.asyncAfter(deadline: .now() + 5.0) { } DispatchQueue.main.async(execute: { self.tableView.reloadData() })
_ = navigationController?.popViewController(animated: true)
_ = navigationController?.popToRootViewController(animated: true)
if movetoroot { navigationController?.popToRootViewController(animated: true) } else { navigationController?.popViewController(animated: true) }
override func viewDidLoad() { super.viewDidLoad() navigationItem.leftBarButtonItem = UIBarButtonItem(title: "< Back", style: .plain, target: self, action: } func backAction(){ dismiss(animated: true, completion: nil) }
_ = navigationController?.popViewController(animated: true)
navigationController?.popViewController(animated: true)
navigationController?.popToRootViewController(animated: true)
navigationController?.popToRootViewController(animated: true) navigationController?.popViewController(animated: true)
_ = self.navigationController?.popViewController(animated: true)
let array = ["Frodo", "Sam", "Wise", "Gamgee"] print(array.randomElement()!)
if let randomElement = array.randomElement() { print(randomElement) }
let array = ["Frodo", "sam", "wise", "gamgee"] let randomIndex = Int(arc4random_uniform(UInt32(array.count))) print(array[randomIndex])
extension Array { func randomItem() -> Element? { if isEmpty { return nil } let index = Int(arc4random_uniform(UInt32(self.count))) return self[index] } }
let myArray = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16] let myItem = myArray.randomItem()
extension Collection where Index == Int { /** Picks a random element of the collection. - returns: A random element of the collection. */ func randomElement() -> Iterator.Element? { return isEmpty ? nil : self[Int(arc4random_uniform(UInt32(endIndex)))] } }
UInt.random UInt8.random UInt16.random UInt32.random UInt64.random UIntMax.random (-3...3).random (Int.min...Int.max).random (1..<4).sample [1,2,3].sample "abc".characters.sample ["a": 1, "b": 2, "c": 3].sample
import Darwin func sizeof <T> (_: () -> T) -> Int { return sizeof(T.self) } let ARC4Foot: Int = sizeof(arc4random) extension UnsignedIntegerType { static var max: Self { return ~0 } static var random: Self { let foot = sizeof(Self) guard foot > ARC4Foot else { return numericCast(arc4random() & numericCast(max)) } var r = UIntMax(arc4random()) for i in 1..<(foot / ARC4Foot) { r |= UIntMax(arc4random()) << UIntMax(8 * ARC4Foot * i) } return numericCast(r) } }
extension ClosedInterval where Bound : UnsignedIntegerType { var random: Bound { guard start > 0 || end < Bound.max else { return Bound.random } return start + (Bound.random % (end - start + 1)) } }
extension ClosedInterval where Bound : SignedIntegerType { var random: Bound { let foot = sizeof(Bound) let distance = start.unsignedDistanceTo(end) guard foot > 4 else { let off: UInt32 if distance < numericCast(UInt32.max) { off = UInt32.random % numericCast(distance + 1) } else { off = UInt32.random } return numericCast(start.toIntMax() + numericCast(off)) } guard distance < UIntMax.max else { return numericCast(IntMax(bitPattern: UIntMax.random)) } let off = UIntMax.random % (distance + 1) let x = (off + start.unsignedDistanceFromMin).plusMinIntMax return numericCast(x) } }
extension SignedIntegerType { func unsignedDistanceTo(other: Self) -> UIntMax { let _self = self.toIntMax() let other = other.toIntMax() let (start, end) = _self < other ? (_self, other) : (other, _self) if start == IntMax.min && end == IntMax.max { return UIntMax.max } if start < 0 && end >= 0 { let s = start == IntMax.min ? UIntMax(Int.max) + 1 : UIntMax(-start) return s + UIntMax(end) } return UIntMax(end - start) } var unsignedDistanceFromMin: UIntMax { return IntMax.min.unsignedDistanceTo(self.toIntMax()) } } extension UIntMax { var plusMinIntMax: IntMax { if self > UIntMax(IntMax.max) { return IntMax(self - UIntMax(IntMax.max) - 1) } else { return IntMax.min + IntMax(self) } } }
extension CollectionType where Index.Distance == Int { var sample: Generator.Element? { if isEmpty { return nil } let end = UInt(count) - 1 let add = (0...end).random let idx = startIndex.advancedBy(Int(add)) return self[idx] } }
extension Range where Element : SignedIntegerType { var sample: Element? { guard startIndex < endIndex else { return nil } let i: ClosedInterval = startIndex...endIndex.predecessor() return i.random } } extension Range where Element : UnsignedIntegerType { var sample: Element? { guard startIndex < endIndex else { return nil } let i: ClosedInterval = startIndex...endIndex.predecessor() return i.random } }
extension Array { func sample() -> Element { let randomIndex = Int(rand()) % count return self[randomIndex] } } let array = [1, 2, 3, 4] array.sample() array.sample() array.sample() array.sample() array.sample() array.sample() array.sample() array.sample()
private extension Array { var randomElement: Element { let index = Int(arc4random_uniform(UInt32(count))) return self[index] } }
extension Array { func sample() -> T { let index = Int(arc4random_uniform(UInt32(self.count))) return self[index] } }
extension Array { func sample() -> Element { let index = Int(arc4random_uniform(UInt32(self.count))) return self[index] } }
let arr = [2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31] let randomSample = arr.sample()
func randomArrayItem<T>(array: [T]) -> T? { if array.isEmpty { return nil } let randomIndex = Int(arc4random_uniform(UInt32(array.count))) return array[randomIndex] } randomArrayItem([1,2,3])
extension Array { func sample() -> Element? { if self.isEmpty { return nil } let randomInt = Int(arc4random_uniform(UInt32(self.count))) return self[randomInt] } }
import HandySwift let digits = Array(0...9) digits.sample()
func getRandomMessage() -> String { let messages = ["one", "two", "three"] let randomNumber = GKRandomSource.sharedRandom().nextInt(upperBound: messages.count) return messages[randomNumber].description }
var arrayOfColors = [UIColor.red, UIColor.yellow, UIColor.orange, UIColor.green]
let randomColor = arc4random() % UInt32(arrayOfColors.count)
let array = ["one","two","three","four","five"] let randomNumber = arc4random() % UInt32(array.count) let labelNode = SKLabelNode(text: array[Int(randomNumber)])
import GameplayKit let array = ["one", "two", "three", "four"] let shuffled = GKMersenneTwisterRandomSource.sharedRandom().arrayByShufflingObjects(in: array) let firstRandom = shuffled[0] let secondRandom = shuffled[1]
import GameKit let array = ["random1", "random2", "random3"] func getRandomIndex() -> Int { let randomNumber = GKRandomSource.sharedRandom().nextIntWithUpperBound(array.count) return randomNumber
let imagesArray = ["image1.png","image2.png","image3.png","image4.png"] var randomNum: UInt32 = 0 randomNum = arc4random_uniform(UInt32(imagesArray.count)) wheelBackgroundImageView.image = UIImage(named: imagesArray[Int(randomNum)])
import Foundation class FBManager { class func fbSessionStateChane(fbSession:FBSession!, fbSessionState:FBSessionState, error:NSError?){ FBRequestConnection.startForMeWithCompletionHandler { (conn: FBRequestConnection!, result: AnyObject!, error: NSError!) -> Void in println("Logged in user: \n\(result)"); let storyboard = UIStoryboard(name: "Main", bundle: NSBundle.mainBundle()) let loggedInView: UserViewController = storyboard.instantiateViewControllerWithIdentifier("loggedInView") as UserViewController loggedInView.result = result; } } }
performSegue(withIdentifier: "mySegueID", sender: nil)
performSegueWithIdentifier("mySegueID", sender: nil)
presentViewController(nextViewController, animated: true, completion: nil)
self.navigationController?.pushViewController(nextViewController, animated: true)
NSNotificationCenter.defaultCenter().postNotificationName("NotificationIdentifier", object: nil)
NSNotificationCenter.defaultCenter().addObserver(self, selector: "methodOFReceivedNotication:", name:"NotificationIdentifier", object: nil)
func methodOFReceivedNotication(notification: NSNotification){ self.performSegueWithIdentifier("yourIdentifierInStoryboard", sender: self) }
func goToDifferentView() { self.performSegue(withIdentifier: "segue", sender: self) }
NotificationCenter.default.addObserver(self, selector:
NotificationCenter.default.addObserver(self, selector:
NotificationCenter.default.post(name: "segue" as NSNotification.Name, object: nil)
NotificationCenter.default.post(NSNotification(name: NSNotification.Name(rawValue: "segue"), object: nil) as Notification)
self.performSegueWithIdentifier("push", sender: self) override func prepareForSegue(segue: UIStoryboardSegue!, sender: AnyObject!) { if segue.identifier == "push" { } }
self.performSegueWithIdentifier("yourIdentifierInStoryboard", sender: self)
let viewController = YourViewController(nibName: "YourViewController", bundle: nil) self.navigationController?.pushViewController(viewController, animated: true)
func localFunc() { println("we asked you to do it") performSegueWithIdentifier("doIt", sender: self) }
public class UtilClass { var yourFunction : () -> () init (someFunction: () -> ()) { self.yourFunction = someFunction println("initialized UtilClass") } public convenience init() { func dummyLog () -> () { println("no action passed") } self.init(dummyLog) } public func doThatThing() -> () { println("now execute passed function") self.yourFunction() println("did that thing") } }
func performSegueWithIdentifier(identifier: String, sender: AnyObject?)
performSegueWithIdentifier("homeScreenVC", sender: nil)
let viewController: UIViewController = UIStoryboard( name: "Main", bundle: nil ).instantiateViewControllerWithIdentifier("ViewController") as UIViewController self.presentViewController(viewController, animated: false, completion: nil)
for thing in things { switch thing { case 0 as Int: println("zero as an Int") case 0 as Double: println("zero as a Double") case let someInt as Int: println("an integer value of \(someInt)") case let someDouble as Double where someDouble > 0: println("a positive double value of \(someDouble)") case is Double: println("some other double value that I don case let someString as String: println("a string value of \"\(someString)\"") case let (x, y) as (Double, Double): println("an (x, y) point at \(x), \(y)") case let movie as Movie: println("a movie called default: println("something else") } }
switch value{ case is Int, is String: if value is Int{ print("Integer::\(value)") }else{ print("String::\(value)") } default: print("\(value)") }
func testIsString(aClass: AnyClass) { switch aClass { case is NSString.Type: print(true) default: print(false) } } testIsString(NSString.self) let value: NSString = "some string value" testIsString(value.dynamicType)
switch thing { case _ as Int: print("thing is Int") case _ as Double: print("thing is Double") }
switch thing { case let myInt as Int: print("\(myInt) is Int") case _ as Double: print("thing is Double") }
self.locationManager.requestAlwaysAuthorization() self.locationManager.requestWhenInUseAuthorization() if CLLocationManager.locationServicesEnabled() { locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager.startUpdatingLocation() }
func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { guard let locValue: CLLocationCoordinate2D = manager.location?.coordinate else { return } print("locations = \(locValue.latitude) \(locValue.longitude)") }
locationManager = CLLocationManager() locationManager.delegate = self; locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.requestAlwaysAuthorization() locationManager.startUpdatingLocation()
func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { let locValue:CLLocationCoordinate2D = manager.location!.coordinate print("locations = \(locValue.latitude) \(locValue.longitude)") }
import Foundation import CoreLocation import MapKit class DiscoverViewController : UIViewController, CLLocationManagerDelegate { @IBOutlet weak var map: MKMapView! var locationManager: CLLocationManager! override func viewDidLoad() { super.viewDidLoad() if (CLLocationManager.locationServicesEnabled()) { locationManager = CLLocationManager() locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.requestAlwaysAuthorization() locationManager.startUpdatingLocation() } } func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { let location = locations.last! as CLLocation let center = CLLocationCoordinate2D(latitude: location.coordinate.latitude, longitude: location.coordinate.longitude) let region = MKCoordinateRegion(center: center, span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)) self.map.setRegion(region, animated: true) } }
class ViewController: UIViewController, CLLocationManagerDelegate
func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
let userLocation:CLLocation = locations[0] as CLLocation
let coordinations = CLLocationCoordinate2D(latitude: userLocation.coordinate.latitude,longitude: userLocation.coordinate.longitude)
let region = MKCoordinateRegion(center: coordinations, span: span)
locationManager.desiredAccuracy = kCLLocationAccuracyBest
import UIKit import MapKit import CoreLocation class ViewController: UIViewController, CLLocationManagerDelegate { @IBOutlet weak var mapView: MKMapView! var locationManager = CLLocationManager() override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } @IBAction func locateMe(sender: UIBarButtonItem) { locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.requestWhenInUseAuthorization() locationManager.startUpdatingLocation() mapView.showsUserLocation = true } func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { let userLocation:CLLocation = locations[0] as CLLocation manager.stopUpdatingLocation() let coordinations = CLLocationCoordinate2D(latitude: userLocation.coordinate.latitude,longitude: userLocation.coordinate.longitude) let span = MKCoordinateSpanMake(0.2,0.2) let region = MKCoordinateRegion(center: coordinations, span: span) mapView.setRegion(region, animated: true) } }
class MyVc: UIViewController, CLLocationManagerDelegate { let locationManager = CLLocationManager() override func viewDidLoad() { super.viewDidLoad() isAuthorizedtoGetUserLocation() if CLLocationManager.locationServicesEnabled() { locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters } } func isAuthorizedtoGetUserLocation() { if CLLocationManager.authorizationStatus() != .authorizedWhenInUse { locationManager.requestWhenInUseAuthorization() } } func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) { if status == .authorizedWhenInUse { print("User allowed us to access location") } } func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { print("Did location updates is called") } func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) { print("Did location updates is called but failed getting location \(error)") } }
if CLLocationManager.locationServicesEnabled() { locationManager.requestLocation(); }
geoFire?.setLocation(locations.first, forKey: uid) where uid is the user id who logged in to the app. I think you will know how to get UID based on your app sign in implementation.
locationManager = CLLocationManager() locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.requestAlwaysAuthorization() if CLLocationManager.locationServicesEnabled(){ locationManager.startUpdatingLocation() }
func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { let userLocation :CLLocation = locations[0] as CLLocation print("user latitude = \(userLocation.coordinate.latitude)") print("user longitude = \(userLocation.coordinate.longitude)") self.labelLat.text = "\(userLocation.coordinate.latitude)" self.labelLongi.text = "\(userLocation.coordinate.longitude)" let geocoder = CLGeocoder() geocoder.reverseGeocodeLocation(userLocation) { (placemarks, error) in if (error != nil){ print("error in reverseGeocode") } let placemark = placemarks! as [CLPlacemark] if placemark.count>0{ let placemark = placemarks![0] print(placemark.locality!) print(placemark.administrativeArea!) print(placemark.country!) self.labelAdd.text = "\(placemark.locality!), \(placemark.administrativeArea!), \(placemark.country!)" } } } func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) { print("Error \(error)") }
<key>NSLocationAlwaysUsageDescription</key> <string>Will you allow this app to always know your location?</string> <key>NSLocationWhenInUseUsageDescription</key> <string>Do you allow this app to know your current location?</string> <key>NSLocationAlwaysAndWhenInUseUsageDescription</key> <string>Do you allow this app to know your current location?</string>
var manager:CLLocationManager! var myLocations: [CLLocation] = []
manager = CLLocationManager() manager.desiredAccuracy = kCLLocationAccuracyBest manager.requestAlwaysAuthorization() manager.startUpdatingLocation() mapobj.showsUserLocation = true
1: NSLocationWhenInUseUsageDescription 2: NSLocationAlwaysUsageDescription
override func viewDidLoad() { super.viewDidLoad() locationManager.requestWhenInUseAuthorization(); if CLLocationManager.locationServicesEnabled() { locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager.startUpdatingLocation() } else{ print("Location service disabled"); } }
func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) { var locValue : CLLocationCoordinate2D = manager.location.coordinate; let span2 = MKCoordinateSpanMake(1, 1) let long = locValue.longitude; let lat = locValue.latitude; print(long); print(lat); let loadlocation = CLLocationCoordinate2D( latitude: lat, longitude: long ) mapView.centerCoordinate = loadlocation; locationManager.stopUpdatingLocation(); }
import CoreLocation import UIKit class ViewController: UIViewController, CLLocationManagerDelegate { var locationManager: CLLocationManager! override func viewDidLoad() { super.viewDidLoad() locationManager = CLLocationManager() locationManager.delegate = self locationManager.requestWhenInUseAuthorization() } func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) { if status != .authorizedWhenInUse {return} locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.startUpdatingLocation() let locValue: CLLocationCoordinate2D = manager.location!.coordinate print("locations = \(locValue.latitude) \(locValue.longitude)") } }
@IBOutlet weak var mapView: MKMapView! let cooridinate = CLLocationCoordinate2D(latitude: 12.9767415 , longitude: 77.6903967) let spanDegree = MKCoordinateSpan(latitudeDelta: 0.2,longitudeDelta: 0.2) let region = MKCoordinateRegion(center: cooridinate , span: spanDegree) mapView.setRegion(region, animated: true)
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { GMSServices.provideAPIKey("ApiKey") return true }
@IBOutlet weak var mapview: UIView! let locationManager = CLLocationManager() override func viewDidLoad() { super.viewDidLoad() locationManagerSetting() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func locationManagerSetting() { self.locationManager.delegate = self self.locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters self.locationManager.requestWhenInUseAuthorization() self.locationManager.startUpdatingLocation() } func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { self.showCurrentLocationonMap() self.locationManager.stopUpdatingLocation() } func showCurrentLocationonMap() { let cameraposition = GMSCameraPosition.camera(withLatitude: (self.locationManager.location?.coordinate.latitude)! , longitude: (self.locationManager.location?.coordinate.longitude)!, zoom: 18) let mapviewposition = GMSMapView.map(withFrame: CGRect(x: 0, y: 0, width: self.mapview.frame.size.width, height: self.mapview.frame.size.height), camera: cameraposition) mapviewposition.settings.myLocationButton = true mapviewposition.isMyLocationEnabled = true let marker = GMSMarker() marker.position = cameraposition.target marker.snippet = "Macczeb Technologies" marker.appearAnimation = GMSMarkerAnimation.pop marker.map = mapviewposition self.mapview.addSubview(mapviewposition) }
func abs<T>(_ x: T) -> T where T : Comparable, T : SignedNumeric
var c = -12.09 print(fabs(c)) c = -6 print(fabs(c))
var myTextField = UITextField(frame: CGRect(x: 0, y: 0, width: 200, height: 30)) myTextField.backgroundColor = .blue myTextField.attributedPlaceholder = NSAttributedString(string: "placeholder text", attributes: [NSForegroundColorAttributeName: UIColor.yellow])
myTextField.attributedPlaceholder = NSAttributedString(string: "placeholder text", attributes: [NSAttributedStringKey.foregroundColor: UIColor.white])
myTextField.attributedPlaceholder = NSAttributedString(string: "placeholder text", attributes: [NSAttributedString.Key.foregroundColor: UIColor.white])
extension UITextField{ @IBInspectable var placeHolderColor: UIColor? { get { return self.placeHolderColor } set { self.attributedPlaceholder = NSAttributedString(string:self.placeholder != nil ? self.placeholder! : "", attributes:[NSAttributedString.Key.foregroundColor: newValue!]) } } }
yourTextFieldName .setValue(UIColor.init(colorLiteralRed: 80/255, green: 80/255, blue: 80/255, alpha: 1.0), forKeyPath: "_placeholderLabel.textColor")
let color = UIColor.lightText textField.attributedPlaceholder = NSAttributedString(string: textField.placeholder, attributes: [NSForegroundColorAttributeName : color])
UILabel.appearanceWhenContainedInInstancesOfClasses([UITextField.self]).textColor = UIColor.redColor()
extension UITextField{ @IBInspectable var placeHolderColor: UIColor? { get { return self.placeHolderColor } set { self.attributedPlaceholder = NSAttributedString(string:self.placeholder != nil ? self.placeholder! : "", attributes:[NSAttributedStringKey.foregroundColor: newValue!]) } } }
passField.attributedPlaceholder = NSAttributedString(string: "password", attributes: [NSForegroundColorAttributeName: UIColor.white])
textField.attributedPlaceholder = NSAttributedString(string: "Placeholder Text", attributes: [NSAttributedStringKey.foregroundColor : UIColor.white])
override var placeholder: String? { didSet { guard let tmpText = placeholder else { self.attributedPlaceholder = NSAttributedString(string: "") return } let textRange = NSMakeRange(0, tmpText.characters.count) let attributedText = NSMutableAttributedString(string: tmpText) attributedText.addAttribute(NSForegroundColorAttributeName , value:UIColor(white:147.0/255.0, alpha:1.0), range: textRange) self.attributedPlaceholder = attributedText } }
extension UITextField { func placeholderColor(_ color: UIColor){ var placeholderText = "" if self.placeholder != nil{ placeholderText = self.placeholder! } self.attributedPlaceholder = NSAttributedString(string: placeholderText, attributes: [NSAttributedStringKey.foregroundColor : color]) } }
streetTextField?.placeholderColor(AppColor.blueColor)
extension UITextField{ func setPlaceHolderColor(){ self.attributedPlaceholder = NSAttributedString(string: self.placeholder!, attributes: [NSForegroundColorAttributeName : UIColor.white]) } }
extension UITextField{ @IBInspectable var placeHolderColor: UIColor? { get { return self.placeHolderColor } set { self.attributedPlaceholder = NSAttributedString(string:self.placeholder != nil ? self.placeholder! : "", attributes:[NSAttributedString.Key.foregroundColor : newValue!]) } } }
extension UITextField{ @IBInspectable var placeholderColor: UIColor { get { return self.attributedPlaceholder?.attribute(.foregroundColor, at: 0, effectiveRange: nil) as? UIColor ?? .lightText } set { self.attributedPlaceholder = NSAttributedString(string: self.placeholder ?? "", attributes: [.foregroundColor: newValue]) } } }
func setPlaceholderColor(textField: UITextField, placeholderText: String) { textField.attributedPlaceholder = NSAttributedString(string: placeholderText, attributes: [NSForegroundColorAttributeName: UIColor.pelorBlack]) }
self.setPlaceholderColor(textField: self.emailTextField, placeholderText: "E-Mail/Username")
import UIKit extension UITextField { func setBottomLine(borderColor: UIColor, fontColor: UIColor, placeHolderColor:UIColor, placeHolder: String) { self.borderStyle = UITextBorderStyle.none self.backgroundColor = UIColor.clear let borderLine = UIView() let height = 1.0 borderLine.frame = CGRect(x: 0, y: Double(self.frame.height) - height, width: Double(self.frame.width), height: height) self.textColor = fontColor borderLine.backgroundColor = borderColor self.addSubview(borderLine) self.attributedPlaceholder = NSAttributedString( string: placeHolder, attributes: [NSAttributedStringKey.foregroundColor: placeHolderColor] ) } }
self.textField.setBottomLine(borderColor: lineColor, fontColor: fontColor, placeHolderColor: placeHolderColor, placeHolder: placeHolder)
textField.attributedPlaceholder = NSAttributedString(string: "Placeholder Text", attributes: [NSAttributedString.Key.foregroundColor: UIColor.white])
extension UITextField { @IBInspectable var placeHolderColor: UIColor? { get { if let color = self.attributedPlaceholder?.attribute(.foregroundColor, at: 0, effectiveRange: nil) as? UIColor { return color } return nil } set (setOptionalColor) { if let setColor = setOptionalColor { let string = self.placeholder ?? "" self.attributedPlaceholder = NSAttributedString(string: string , attributes:[NSAttributedString.Key.foregroundColor: setColor]) } } } }
txtControl.attributedPlaceholder = NSAttributedString(string: "Placeholder String...",attributes: [NSAttributedStringKey.foregroundColor: UIColor.gray])
let attributes : [String : Any] = [ NSForegroundColorAttributeName: UIColor.lightGray, NSFontAttributeName : UIFont(name: "Helvetica Neue Light Italic", size: 12.0)! ] x_textfield.attributedPlaceholder = NSAttributedString(string: "Placeholder Text", attributes:attributes)
txtField1.attributedPlaceholder = NSAttributedString(string: "-", attributes: [NSAttributedStringKey.foregroundColor: UIColor.white])
yourTextfield.attributedPlaceholder = NSAttributedString(string: "your placeholder text",attributes: [NSForegroundColorAttributeName: UIColor.white])
enum SimpleToken { case Name(String) case Number(Int) } let t1 = SimpleToken.Number(123) let t2 = SimpleToken.Number(123) XCTAssert(t1 == t2)
error: could not find an overload for XCTAssert(t1 == t2) ^~~~~~~~~~~~~~~~~~~
enum SimpleToken: Equatable { case Name(String) case Number(Int) } public func ==(lhs: SimpleToken, rhs: SimpleToken) -> Bool { switch (lhs, rhs) { case let (.Name(a), .Name(b)), let (.Number(a), .Number(b)): return a == b default: return false } }
if case .NotRecognized = error { } else { XCTFail("wrong error") }
if case .Unauthorized401(_, let response, _) = networkError { XCTAssertEqual(response.statusCode, 401) } else { XCTFail("Unauthorized401 was expected") }
@infix func ==(a:SimpleToken, b:SimpleToken) -> Bool { switch(a) { case let .Name(sa): switch(b) { case let .Name(sb): return sa == sb default: return false } case let .Number(na): switch(b) { case let .Number(nb): return na == nb default: return false } } }
enum SimpleToken: Equatable { case Name(String) case Number(Int) } extension SimpleToken { func isEqual(st: SimpleToken)->Bool { switch self { case .Name(let v1): if case .Name(let v2) = st where v1 == v2 { return true } case .Number(let i1): if case .Number(let i2) = st where i1 == i2 { return true } } return false } } func ==(lhs: SimpleToken, rhs: SimpleToken)->Bool { return lhs.isEqual(rhs) } let t1 = SimpleToken.Number(1) let t2 = SimpleToken.Number(2) let t3 = SimpleToken.Name("a") let t4 = SimpleToken.Name("b") t1 == t1 t1 == t2 t3 == t3 t3 == t4 t1 == t3
enum MyEnum { case None case Simple(text: String) case Advanced(x: Int, y: Int) } func ==(lhs: MyEnum, rhs: MyEnum) -> Bool { switch (lhs, rhs) { case (.None, .None): return true case let (.Simple(v0), .Simple(v1)): return v0 == v1 case let (.Advanced(x0, y0), .Advanced(x1, y1)): return x0 == x1 && y0 == y1 default: return false } }
extension SimpleToken: Equatable {} func ==(lhs: SimpleToken, rhs: SimpleToken) -> Bool { return String(stringInterpolationSegment: lhs) == String(stringInterpolationSegment: rhs) }
let t1 = SimpleToken.Number(123) let t2 = SimpleToken.Number(123) let t3 = SimpleToken.Name("bob") String(t1) == String(t2) String(t1) == String(t3)
enum { case kindOne(String) case kindTwo(NSManagedObjectID) case kindThree(Int) static func ==(lhs: MyEnumType, rhs: MyEnumType) -> Bool { if case .kindOne(let l) = lhs, case .kindOne(let r) = rhs { return l == r } if case .kindTwo(let l) = lhs, case .kindTwo(let r) = rhs { return l == r } if case .kindThree(let l) = lhs, case .kindThree(let r) = rhs { return l == r } return false } }
switch t1 { case let .Number(numValue): println("Number: \(numValue)") case let .Name(strValue): println("Name: \(strValue)") }
enum SimpleToken: Equatable { case Name(String) case Number(Int) } extension SimpleToken { func isEqual(st: SimpleToken)->Bool { switch self { case .Name(let v1): switch st { case .Name(let v2): return v1 == v2 default: return false } case .Number(let i1): switch st { case .Number(let i2): return i1 == i2 default: return false } } } } func ==(lhs: SimpleToken, rhs: SimpleToken)->Bool { return lhs.isEqual(rhs) } let t1 = SimpleToken.Number(1) let t2 = SimpleToken.Number(2) let t3 = SimpleToken.Name("a") let t4 = SimpleToken.Name("b") t1 == t1 t1 == t2 t3 == t3 t3 == t4 t1 == t3
if case .yourEnumCase(associatedValueIfNeeded) = yourEnumVariable { }
if someOtherCondition, case .yourEnumCase = yourEnumVariable { }
enum SimpleToken { case Name(String) case Number(Int) } let t1 = SimpleToken.Number(123) let t2 = SimpleToken.Number(123) switch(t1) { case let .Number(a): switch(t2) { case let . Number(b): if a == b { println("Equal") } default: println("Not equal") } default: println("No Match") }
var dict = [ 1 : "abc", 2 : "cde"] dict.updateValue("efg", forKey: 3) print(dict)
var dictionary = [Int:String]() dictionary.updateValue(value: "Hola", forKey: 1) dictionary.updateValue(value: "Hello", forKey: 2) dictionary.updateValue(value: "Aloha", forKey: 3)
var dict = Dictionary<String, Array<Int>>() dict["key"]! += [1] dict["key"]!.append(1) dict["key"]?.append(1)
var myDictionary: NSMutableDictionary = [:] let newValue = 1 myDictionary["newKey"] = newValue print(myDictionary)
var dic1 = ["a": 1, "c": 2] var dic2 = ["e": 3, "f": 4]
var caseStatusParams: [String: AnyObject] = ["userId" : UserDefault.userID ] caseStatusParams.updateValue("Hello" as AnyObject, forKey: "otherNotes")
‚ñø : 2 elements - key : "userId" - value : 866 ‚ñø : 2 elements - key : "otherNotes" - value : "Hello"
var dict = ["name": "Samira", "surname": "Sami"] dict["email"] = "sample@email.com" print(dict)
newDictionary = oldDictionary.reduce(*newDictionary*) { r, e in var r = r; r[e.0] = e.1; return r }
newDictionary = dict.reduce([3 : "efg"]) { r, e in var r = r; r[e.0] = e.1; return r }
let newdictionary = NSDictionary as NSMutableDictionary
newdictionary.setValue(value: AnyObject?, forKey: String)
class MyObject { private var token: NSKeyValueObservation var objectToObserve = Foo() init() { token = objectToObserve.observe(\.bar) { [weak self] object, change in print("bar property is now \(object.bar)") } } }
class MyObject: NSObject { private var observerContext = 0 var objectToObserve = Foo() override init() { super.init() objectToObserve.addObserver(self, forKeyPath: } deinit { objectToObserve.removeObserver(self, forKeyPath: } override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { guard context == &observerContext else { super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context) return } print("\(keyPath): \(change?[.newKey])") } }
class MyObjectToObserve: NSObject { dynamic var myDate = NSDate() func updateDate() { myDate = NSDate() } }
class MyObserver: NSObject { var objectToObserve = MyObjectToObserve() override init() { super.init() objectToObserve.addObserver(self, forKeyPath: "myDate", options: .New, context: &myContext) } override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer<Void>) { if context == &myContext { if let newValue = change?[NSKeyValueChangeNewKey] { print("Date changed: \(newValue)") } } else { super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context) } } deinit { objectToObserve.removeObserver(self, forKeyPath: "myDate", context: &myContext) } }
let options = NSKeyValueObservingOptions([.New, .Old, .Initial, .Prior]) model.addObserver(self, forKeyPath: "name", options: options, context: nil) model.addObserver(self, forKeyPath: "state", options: options, context: nil)
override func observeValueForKeyPath(keyPath: String!, ofObject object: AnyObject!, change: NSDictionary!, context: CMutableVoidPointer) { println("CHANGE OBSERVED: \(change)") }
class MyObjectToObserve: NSObject { var myDate = NSDate() func updateDate() { setValue(NSDate(), forKey: "myDate") } }
class MyObjectToObserve: NSObject { var myDate = NSDate() func updateDate() { willChangeValueForKey("myDate") myDate = NSDate() didChangeValueForKey("myDate") } }
class MyObjectToObserve: NSObject { dynamic var myDate = NSDate() func updateDate() { myDate = NSDate() } }
class MyObjectToObserve: NSObject { var backing: NSDate = NSDate() dynamic var myDate: NSDate { set { print("setter is called") backing = newValue } get { print("getter is called") return backing } } }
override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [NSObject : AnyObject]?, context: UnsafeMutablePointer<Void>)
var observedPaths: [String] = [] func observeKVO(keyPath: String) { observedPaths.append(keyPath) addObserver(self, forKeyPath: keyPath, options: [.old, .new], context: nil) } func unObserveKVO(keyPath: String) { if let index = observedPaths.index(of: keyPath) { observedPaths.remove(at: index) } removeObserver(self, forKeyPath: keyPath) } func unObserveAllKVO() { for keyPath in observedPaths { removeObserver(self, forKeyPath: keyPath) } } override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { if let keyPath = keyPath { switch keyPath { case slider.value = camera.iso default: break } } }
class Theme : NSObject{ dynamic var min_images : Int = 0 dynamic var moreTextSize : CGFloat = 0.0 func myMethod(){ self.setValue(value, forKey: "\(min_images)") } }
var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] var combinedDict = ... (some way of combining dict1 & dict2 without looping)
func += <K, V> (left: inout [K:V], right: [K:V]) { for (k, v) in right { left[k] = v } }
var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] extension Dictionary { mutating func update(other:Dictionary) { for (key,value) in other { self.updateValue(value, forKey:key) } } } dict1.update(dict2)
let dictA = ["x" : 1, "y": 2, "z": 3] let dictB = ["x" : 11, "y": 22, "w": 0] let resultA = dictA.merging(dictB, uniquingKeysWith: { (first, _) in first }) let resultB = dictA.merging(dictB, uniquingKeysWith: { (_, last) in last }) print(resultA) print(resultB)
func + <K,V>(left: Dictionary<K,V>, right: Dictionary<K,V>) -> Dictionary<K,V> { var map = Dictionary<K,V>() for (k, v) in left { map[k] = v } for (k, v) in right { map[k] = v } return map }
var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] var dict3 = dict1 + dict2
extension Dictionary { mutating func merge(with dictionary: Dictionary) { dictionary.forEach { updateValue($1, forKey: $0) } } func merged(with dictionary: Dictionary) -> Dictionary { var dict = self dict.merge(with: dictionary) return dict } } let a = ["a":"b"] let b = ["1":"2"] let c = a.merged(with: b) print(c)
extension Dictionary { mutating func unionInPlace(dictionary: Dictionary) { dictionary.forEach { self.updateValue($1, forKey: $0) } } func union(var dictionary: Dictionary) -> Dictionary { dictionary.unionInPlace(self) return dictionary } }
func + <K,V> (left: Dictionary<K,V>, right: Dictionary<K,V>?) -> Dictionary<K,V> { guard let right = right else { return left } return left.reduce(right) { var new = $0 as [K:V] new.updateValue($1.1, forKey: $1.0) return new } } let moreAttributes: [String:AnyObject] = ["Function":"authenticate"] let attributes: [String:AnyObject] = ["File":"Auth.swift"] attributes + moreAttributes + nil attributes + moreAttributes attributes + nil
func += <K,V> (inout left: Dictionary<K,V>, right: Dictionary<K,V>?) { guard let right = right else { return } right.forEach { key, value in left.updateValue(value, forKey: key) } } let moreAttributes: [String:AnyObject] = ["Function":"authenticate"] var attributes: [String:AnyObject] = ["File":"Auth.swift"] attributes += nil attributes += moreAttributes
var oldDictionary = ["a": 1, "b": 2] var newDictionary = ["a": 10000, "b": 10000, "c": 4] oldDictionary.merge(newDictionary) { (oldValue, newValue) -> Int in return newValue } print(oldDictionary)
var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] var temp = NSMutableDictionary(dictionary: dict1); temp .addEntriesFromDictionary(dict2)
extension Dictionary { func merge(dict: Dictionary<Key,Value>) -> Dictionary<Key,Value> { var mutableCopy = self for (key, value) in dict { mutableCopy[key] = value } return mutableCopy } }
let d1 = ["a":"foo","b":"bar"] let d2 = ["c":"car","d":"door"] let d3 = d1.reduce(d2) { (var d, p) in d[p.0] = p.1 return d }
public extension Dictionary { public static func +=(lhs: inout [Key: Value], rhs: [Key: Value]) { rhs.forEach({ lhs[$0] = $1}) } }
dictionaryTwo.forEach { dictionaryOne.updateValue($1, forKey: $0) }
let sourceDict1 = [1: "one", 2: "two"] let sourceDict2 = [3: "three", 4: "four"] let result = sourceDict1.reduce(sourceDict2) { (partialResult , pair) in var partialResult = partialResult partialResult[pair.0] = pair.1 return partialResult }
extension Dictionary { func mergedWith(otherDictionary: [Key: Value]) -> [Key: Value] { var mergedDict: [Key: Value] = [:] [self, otherDictionary].forEach { dict in for (key, value) in dict { mergedDict[key] = value } } return mergedDict } }
var dict1 = ["a" : "foo"] var dict2 = ["b" : "bar"] var combinedDict = dict1.mergedWith(dict2)
public extension Dictionary { public static func +=(lhs: inout Dictionary, rhs: Dictionary) { for (k, v) in rhs { lhs[k] = v } } }
var dict1 = ["a":"Foo"] var dict2 = ["b":"Boo"] var combinedDict = dict1.bridgeToObjectiveC() var mutiDict1 : NSMutableDictionary! = combinedDict.mutableCopy() as NSMutableDictionary var combineDict2 = dict2.bridgeToObjectiveC() var combine = mutiDict1.addEntriesFromDictionary(combineDict2)
import Foundation let x = ["a":1] let y = ["b":2] let out = NSMutableDictionary(dictionary: x) out.addEntriesFromDictionary(y)
let x = ["a":1] let y = ["b":2] var out = x for (k, v) in y { out[k] = v }
let finalDictionnary : NSMutableDictionary = self.getBasicDict() let secondDictionnary : [NSObject : AnyObject] = self.getOtherDict() as [NSObject : AnyObject] finalDictionnary.addEntriesFromDictionary(secondDictionnary)
let dict: Dictionary<String, Int> = ["Dog": 1, "Cat": 2] let dict2: Dictionary<String, Int> = ["Cow": 3] let dict3: Dictionary<String, Int> = ["Sheep": 4] $.merge(dict, dict2, dict3) => ["Dog": 1, "Cat": 2, "Cow": 3, "Sheep": 4]
merging: ["b": [1, 2], "s": Set([5, 6]), "a": 1, "d": ["x": 2]] with ["b": [3, 4], "s": Set([6, 7]), "a": 2, "d": ["y": 4]] yields: ["b": [1, 2, 3, 4], "s": Set([5, 6, 7]), "a": 2, "d": ["y": 4, "x": 2]]
import UIKit private protocol Mergable { func mergeWithSame<T>(right: T) -> T? } public extension Dictionary { /** Merge Dictionaries - Parameter left: Dictionary to update - Parameter right: Source dictionary with values to be merged - Returns: Merged dictionay */ func merge(right:Dictionary) -> Dictionary { var merged = self for (k, rv) in right { if let lv = self[k] { if let lv = lv as? Mergable where lv.dynamicType == rv.dynamicType { let m = lv.mergeWithSame(rv) merged[k] = m } else if lv is Mergable { assert(false, "Expected common type for matching keys!") } else if !(lv is Mergable), let _ = lv as? NSArray { assert(false, "Dictionary literals use incompatible Foundation Types") } else if !(lv is Mergable), let _ = lv as? NSDictionary { assert(false, "Dictionary literals use incompatible Foundation Types") } else { merged[k] = rv } } else { merged[k] = rv } } return merged } } extension Array: Mergable { func mergeWithSame<T>(right: T) -> T? { if let right = right as? Array { return (self + right) as? T } assert(false) return nil } } extension Dictionary: Mergable { func mergeWithSame<T>(right: T) -> T? { if let right = right as? Dictionary { return self.merge(right) as? T } assert(false) return nil } } extension Set: Mergable { func mergeWithSame<T>(right: T) -> T? { if let right = right as? Set { return self.union(right) as? T } assert(false) return nil } } var dsa12 = Dictionary<String, Any>() dsa12["a"] = 1 dsa12["b"] = [1, 2] dsa12["s"] = Set([5, 6]) dsa12["d"] = ["c":5, "x": 2] var dsa34 = Dictionary<String, Any>() dsa34["a"] = 2 dsa34["b"] = [3, 4] dsa34["s"] = Set([6, 7]) dsa34["d"] = ["c":-5, "y": 4] let mdsa3 = dsa12.merge(dsa34) print("merging:\n\t\(dsa12)\nwith\n\t\(dsa34) \nyields: \n\t\(mdsa3)")
func + <K,V>(left: [K : V], right: [K : V]) -> [K : V] { var result = [K:V]() for (key,value) in left { result[key] = value } for (key,value) in right { result[key] = value } return result }
extension Dictionary { static func += (lhs: inout [Key:Value], rhs: [Key:Value]) { lhs.merge(rhs){$1} } static func + (lhs: [Key:Value], rhs: [Key:Value]) -> [Key:Value] { return lhs.merging(rhs){$1} } }
class InfoBar: SKSpriteNode { let team: Team let healthBar: SKSpriteNode init(team: Team, size: CGSize) { self.team = team if self.team == Team.TeamGood { healthBar = SKSpriteNode(color: UIColor.greenColor(), size:size) } else { healthBar = SKSpriteNode(color: UIColor.redColor(), size:size) } super.init(texture:nil, color: UIColor.darkGrayColor(), size: size) self.addChild(healthBar) } }
required init(coder: NSCoder) { fatalError("NSCoding not supported") }
convenience required init(coder: NSCoder) { self.init(stringParam: "", intParam: 5) }
required init(coder aDecoder: NSCoder!) { foo = "some string" bar = 9001 super.init(coder: aDecoder) }
class Foo { var foo: String init(foo: String) { self.foo = foo } } class Bar: Foo { var bar: String init(foo: String, bar: String) { self.bar = bar super.init(foo: foo) } } let x = Bar(foo: "Foo")
protocol InitProtocol { init(foo: Int) } class ConformingClass: InitProtocol { var foo: Int init(foo: Int) { self.foo = foo } }
class Box { var size: CGSize init(size: CGSize) { self.size = size } class func factory() -> Self { return self.init(size: CGSizeZero) } }
class Foo { init(a: Int, b: Int, c: Int) { } } class Bar: Foo { init(string: String) { super.init(a: 0, b: 1, c: 2) } } let f = Foo(a: 0, b: 1, c: 2) let b = Bar(a: 0, b: 1, c: 2)
- (instancetype) initWithCollection: (MPMediaItemCollection*) coll;
required init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder) }
let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square") let sideLength = optionalSquare?.sideLength
let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square") let sideLength = optionalSquare!.sideLength
let optionalSquare: Square! = Square(sideLength: 2.5, name: "optional square") let sideLength = optionalSquare.sideLength
if let sideLength = optionalSquare?.sideLength { println("sideLength is not nil") } else { println("sidelength is nil") }
typealias presentType = [Int:Any?] func wrap(i:Int, gift:Any?) -> presentType? { if(i != 0) { let box : presentType = [i:wrap(i-1,gift:gift)] return box } else { let box = [i:gift] return box } } func getGift() -> String? { return "foobar" } let f00 = wrap(10,gift:getGift()) var b4r = (((((((((((f00![10]! as! [Int:Any?])[9]! as! [Int:Any?])[8]! as! [Int:Any?])[7]! as! [Int:Any?])[6]! as! [Int:Any?])[5]! as! [Int:Any?])[4]! as! [Int:Any?])[3]! as! [Int:Any?])[2]! as! [Int:Any?])[1]! as! [Int:Any?])[0]) let asdf : String = b4r!! as! String print(asdf)
if let myString = myString { print(myString) } else { print("No value") }
var myString: String? myString = "foobar" print(myString!)
if let thing = something as? Int { print(thing) } let thing = something as? Int print(thing) let thing = something as! Int print(thing)
var populatedDictionary = ["key1": "value1", "key2": "value2"]
var emptyDict = [String: String]() var emptyDict = Dictionary<String, String>() var emptyDict: [String: String] = [:] var emptyDict: [String: String] = [String: String]() var emptyDict: [String: String] = Dictionary<String, String>() var emptyDict: Dictionary = [String: String]() var emptyDict: Dictionary = Dictionary<String, String>() var emptyDict: Dictionary<String, String> = [:] var emptyDict: Dictionary<String, String> = [String: String]() var emptyDict: Dictionary<String, String> = Dictionary<String, String>()
namesOfIntegers[16] = "sixteen" namesOfIntegers = [:]
var emptyDictionary = Dictionary<String, Float>() var flexDictionary = [:] emptyDictionary["brian"] = 4.5 flexDictionary["key"] = "value"
var emptyDictionary = Dictionary<String, Any>() emptyDictionary["brian"] = 4.5 emptyDictionary["mike"] = "hello"
let dicc = NSDictionary() let dic = ["":""] let dic2 = ["":"", "":"", "":""] let dic3 = ["name":"Shakeel Ahmed", "imageurl":"https: let dic4 = ["name": variablename, "city": variablecity, "zip": variablezip] var dic5a = [String: String]() var dic5a = ["key1": "value", "key2":"value2", "key3":"value3"] var dic5b = [String:AnyObject]() dic5b = ["name": fullname, "imageurl": imgurl, "language": imgurl] as [String : AnyObject] or let dic5 = ["name": fullname, "imageurl": imgurl, "language": imgurl] as [String : AnyObject] let dic6a = NSDictionary() let dic6b = NSMutalbeDictionary()
var dictionary:[String:String] = [:] dictionary.removeAll()
var d1 = Dictionary<Int, Int>() var d2 = [Int: Int]() var d3: Dictionary<Int, Int> = [Int : Int]() var d4: [Int : Int] = [:]
var stringDict: [String: String] = [String: String]()
var stringDict: Dictionary<String, String> = Dictionary<String, String>()
var stringDict: Dictionary<String, Int> = Dictionary<String, Int>()
var stringDict: [String: AnyObject] = [String: AnyObject]()
var stringDict: Dictionary<String, AnyObject> = Dictionary<String, AnyObject>()
var stringDict: [String: [String]] = [String: [String]]()
var stringDict: Dictionary<String, Array<String>> = Dictionary<String, Array<String>>()
var stringDict: [[String: String]] = [[String: String]]()
var stringDict: Array<Dictionary<String, String>> = Array<Dictionary<String, String>>()
public func preferredStatusBarStyle() -> UIStatusBarStyle
public var preferredStatusBarStyle: UIStatusBarStyle { get }
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
UIApplication.shared.statusBarStyle = .lightContent
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { application.statusBarStyle = .lightContent return true }
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { if let statusBar = UIApplication.shared.value(forKey: "statusBar") as? UIView { statusBar.backgroundColor = UIColor.blue } return true }
extension UIViewController { func setStatusBarStyle(_ style: UIStatusBarStyle) { if let statusBar = UIApplication.shared.value(forKey: "statusBar") as? UIView { statusBar.backgroundColor = style == .lightContent ? UIColor.black : .white statusBar.setValue(style == .lightContent ? UIColor.white : .black, forKey: "foregroundColor") } } }
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
UIApplication.shared.statusBarStyle = .lightContent
let statusBar: UIView = UIApplication.shared.value(forKey: "statusBar") as! UIView if statusBar.responds(to: statusBar.backgroundColor = UIColor.red } UIApplication.shared.statusBarStyle = .lightContent
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { UINavigationBar.appearance().barStyle = .blackOpaque return true }
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
var viewIsDark = Bool() func makeViewDark() { viewIsDark = true setNeedsStatusBarAppearanceUpdate() } func makeViewLight() { viewIsDark = false setNeedsStatusBarAppearanceUpdate() } override var preferredStatusBarStyle: UIStatusBarStyle { if viewIsDark { return .lightContent } else { return .default } }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) UIApplication.shared.statusBarStyle = .lightContent } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) UIApplication.shared.statusBarStyle = .default }
class YourViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() UIApplication.shared.statusBarStyle = .lightContent setNeedsStatusBarAppearanceUpdate() } }
override func viewWillAppear(_ animated: Bool) { let nav = self.navigationController?.navigationBar nav?.barTintColor = .red nav?.tintColor = .white nav?.titleTextAttributes = [NSAttributedStringKey.foregroundColor: UIColor.white] setNeedsStatusBarAppearanceUpdate() }
UIApplication.shared.statusBarStyle = .lightContent let statusBar: UIView = UIApplication.shared.value(forKey: "statusBar") as! UIView if statusBar.responds(to: statusBar.backgroundColor = UIColor.black }
[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:YES];
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { application.statusBarStyle = .lightContent return true }
- (void)viewDidLoad { [super viewDidLoad]; [self setNeedsStatusBarAppearanceUpdate]; } - (UIStatusBarStyle)preferredStatusBarStyle { return UIStatusBarStyleLightContent; }
override func viewDidLoad() { super.viewDidLoad() self.setNeedsStatusBarAppearanceUpdate() } override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
UIApplication.shared.setStatusBarStyle(UIStatusBarStyle.lightContent, animated: true)
extension UINavigationController { override open var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent } }
extension UIViewController { override open var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent } }
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
override var preferredStatusBarStyle : UIStatusBarStyle { return .lightContent }
navigationController.navigationBar.barStyle = .blackTranslucent
var shouldStatusBarDark = false { didSet { setNeedsStatusBarAppearanceUpdate() } } override var preferredStatusBarStyle: UIStatusBarStyle { return shouldStatusBarDark ? .default : .lightContent } func scrollViewDidScroll(_ scrollView: UIScrollView) { let offSetY = scrollView.contentOffset.y if offSetY > 50 { UIView.animate(withDuration: 0.4, animations: { self.navView.alpha = 1 self.shouldStatusBarDark = true }) } else { UIView.animate(withDuration: 0.4, animations: { self.navView.alpha = 0 self.shouldStatusBarDark = false }) } }
<key>UIStatusBarStyle</key> <string>UIStatusBarStyleLightContent</string>
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { UINavigationBar.appearance().barStyle = .black return true }
class LightNavigationController: UINavigationController { open override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent } }
extension UINavigationController { open override var preferredStatusBarStyle: UIStatusBarStyle { guard let index = tabBarController?.selectedIndex else { return .default } switch index { case 0, 1, 2: return .lightContent default: return .default } } }
override public var preferredStatusBarStyle: UIStatusBarStyle { get { return .lightContent } }
UIApplication.sharedApplication.statusBarStyle = UIStatusBarStyleLightContent;
import UIKit import WebKit class ViewController: UIViewController, WKNavigationDelegate, WKUIDelegate { @IBOutlet weak var webView: WKWebView! var hideStatusBar = true override func loadView() { let webConfiguration = WKWebViewConfiguration() webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.uiDelegate = self view = webView } override func viewDidLoad() { super.viewDidLoad() self.setNeedsStatusBarAppearanceUpdate() let myURL = URL(string: "https: let myRequest = URLRequest(url: myURL!) UIApplication.shared.statusBarView?.backgroundColor = UIColor.red webView.load(myRequest) } } extension UIApplication { var statusBarView: UIView? { return value(forKey: "statusBar") as? UIView } }
UIApplication.shared.statusBarStyle = .lightContent UIApplication.shared.statusBarStyle = .default
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { setupNavigationBarAppearence() return true } private func setupNavigationBarAppearence(){ let navigationBarAppearace = UINavigationBar.appearance() navigationBarAppearace.isTranslucent = false navigationBarAppearace.barTintColor = UIColor.primaryColor() navigationBarAppearace.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.white] navigationBarAppearace.barStyle = .black }
override func viewDidLoad() { super.viewDidLoad() let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: imageView.isUserInteractionEnabled = true imageView.addGestureRecognizer(tapGestureRecognizer) } func imageTapped(tapGestureRecognizer: UITapGestureRecognizer) { let tappedImage = tapGestureRecognizer.view as! UIImageView }
let tap = UITapGestureRecognizer(target: self, action: imageView.addGestureRecognizer(tap) imageView.isUserInteractionEnabled = true
@objc func tappedMe() { println("Tapped on Image") }
@IBOutlet weak var imageView: UIImageView! override func viewDidLoad() { super.viewDidLoad() let tap = UITapGestureRecognizer(target: self, action: imageView.addGestureRecognizer(tap) imageView.userInteractionEnabled = true } func tappedMe() { print("Tapped on Image") }
myButton.setImage(myUIImage, forState: UIControlState.Normal)
override func viewDidLoad(){ super.viewDidLoad() var myUIImage: UIImage myButton.setImage(myUIImage, forState: UIControlState.Normal) } @IBOutlet var myButton: UIButton! @IBAction func buttonTap(sender: UIButton!){ }
myButton.setTitle("Loading Image...", forState: UIControlState.Normal)
import UIKit extension UIView { fileprivate struct AssociatedObjectKeys { static var tapGestureRecognizer = "MediaViewerAssociatedObjectKey_mediaViewer" } fileprivate typealias Action = (() -> Void)? fileprivate var tapGestureRecognizerAction: Action? { set { if let newValue = newValue { objc_setAssociatedObject(self, &AssociatedObjectKeys.tapGestureRecognizer, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN) } } get { let tapGestureRecognizerActionInstance = objc_getAssociatedObject(self, &AssociatedObjectKeys.tapGestureRecognizer) as? Action return tapGestureRecognizerActionInstance } } public func addTapGestureRecognizer(action: (() -> Void)?) { self.isUserInteractionEnabled = true self.tapGestureRecognizerAction = action let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: self.addGestureRecognizer(tapGestureRecognizer) } @objc fileprivate func handleTapGesture(sender: UITapGestureRecognizer) { if let action = self.tapGestureRecognizerAction { action?() } else { print("no action") } } }
profile_ImageView.addTapGestureRecognizer { print("image tapped") }
let pictureTap = UITapGestureRecognizer(target: self, action: userImageView.addGestureRecognizer(pictureTap) userImageView.isUserInteractionEnabled = true
@objc func imageTapped() { let imageView = userImageView let newImageView = UIImageView(image: imageView?.image) newImageView.frame = UIScreen.main.bounds newImageView.backgroundColor = UIColor.black newImageView.contentMode = .scaleAspectFit newImageView.isUserInteractionEnabled = true let tap = UITapGestureRecognizer(target: self, action: newImageView.addGestureRecognizer(tap) self.view.addSubview(newImageView) self.navigationController?.isNavigationBarHidden = true self.tabBarController?.tabBar.isHidden = true }
ERROR: While executing gem ... (Gem::FilePermissionError) You don
Successfully installed cocoapods-x.x.x Parsing documentation for cocoapods-x.x.x Installing ri documentation for cocoapods-x.x.x Done installing documentation for cocoapods after 4 seconds 1 gem installed
First check cocoapods version like pod --version then update like sudo gem install cocoapods --pre after update you can also check cocoapods version.
enum Stuff: CaseIterable { case first case second case third case forth }
enum Reindeer: Int { case Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen case Rudolph static let count: Int = { var max: Int = 0 while let _ = Reindeer(rawValue: max) { max += 1 } return max }() }
enum Test { case ONE case TWO case THREE case FOUR static var count: Int { return Test.FOUR.hashValue + 1} }
protocol CaseCountable { static var caseCount: Int { get } } extension CaseCountable where Self: RawRepresentable, Self.RawValue == Int { internal static var caseCount: Int { var count = 0 while let _ = Self(rawValue: count) { count += 1 } return count } }
enum Planet : Int, CaseCountable { case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune } print(Planet.caseCount)
enum ProductCategory : String { case Washers = "washers", Dryers = "dryers", Toasters = "toasters" static let allValues = [Washers, Dryers, Toasters] } ... let count = ProductCategory.allValues.count
enum TableViewSections : Int { case Watchlist case AddButton case Count }
func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { let currentSection: TableViewSections = TableViewSections.init(rawValue:section)! switch(currentSection) { case .Watchlist: return watchlist.count case .AddButton: return 1 case .Count: assert(false, "Invalid table view section!") } }
func enumCount<T: Hashable>(_: T.Type) -> Int { var i = 1 while (withUnsafePointer(&i) { UnsafePointer<T>($0).memory }).hashValue != 0 { i += 1 } return i }
func enumCount<T: Hashable>(_: T.Type) -> Int { var i = 1 while (withUnsafePointer(to: &i, { return $0.withMemoryRebound(to: T.self, capacity: 1, { return $0.pointee }) }).hashValue != 0) { i += 1 } return i }
enum eEventTabType : String { case Search = "SEARCH" case Inbox = "INBOX" case Accepted = "ACCEPTED" case Saved = "SAVED" case Declined = "DECLINED" case Organized = "ORGANIZED" static let allValues = [Search, Inbox, Accepted, Saved, Declined, Organized] var index : Int { return eEventTabType.allValues.indexOf(self)! } }
func testEnumCountIsEqualToNumberOfItemsInEnum() { var max: Int = 0 while let _ = Test(rawValue: max) { max += 1 } XCTAssert(max == Test.count) }
enum Test { case one case two case three case four static var count: Int { return Test.four.hashValue + 1} }
func enumCaseCount<T:Hashable>(t:T.Type) -> Int { switch sizeof(t) { case 0: return 1 case 1: for i in 2..<256 { if unsafeBitCast(UInt8(i), t).hashValue == 0 { return i } } return 256 case 2: for i in 257..<65536 { if unsafeBitCast(UInt16(i), t).hashValue == 0 { return i } } return 65536 default: fatalError("too many") } }
enum Foo:String { case C000 = "foo" case C001 = "bar" case C002 = "baz" } enumCaseCount(Foo)
extension RawRepresentable where RawValue: IntegerType { static var count: Int { var i: RawValue = 0 while let _ = Self(rawValue: i) { i = i.successor() } return Int(i.toIntMax()) } }
protocol CaseCountable: RawRepresentable {} extension CaseCountable where RawValue: IntegerType { static var count: Int { var i: RawValue = 0 while let _ = Self(rawValue: i) { i = i.successor() } return Int(i.toIntMax()) } }
static func enumCount<T: Hashable>(_ t: T.Type) -> Int { var i = 1 while (withUnsafePointer(to: &i) { $0.withMemoryRebound(to:t.self, capacity:1) { $0.pointee.hashValue != 0 } }) { i += 1 } return i } static var allKeys: [YourEnumTypeHere] { var enumSize = enumCount(YourEnumTypeHere.self) let keys: Set<YourEnumTypeHere> = [.all, .your, .cases, .here] guard keys.count == enumSize else { fatalError("Missmatch between allKeys(\(keys.count)) and actual keys(\(enumSize)) in enum.") } return Array(keys) }
enum EnumNameType: Int { case first case second case third static var count: Int { return EnumNameType.third.rawValue + 1 } } print(EnumNameType.count)
enum EnumNameType: Int { case first case second case third case count } print(EnumNameType.count.rawValue)
enum EnumNameType: CaseIterable { case first case second case third } print(EnumNameType.allCases.count)
func getNumberOfItems() -> Int { var i:Int = 0 var exit:Bool = false while !exit { if let menuIndex = MenuIndex(rawValue: i) { i++ }else{ exit = true } } return i }
protocol CaseCountable: RawRepresentable {} extension CaseCountable where RawValue == Int { static var count: RawValue { var i: RawValue = 0 while let _ = Self(rawValue: i) { i += 1 } return i } }
extension RawRepresentable where Self: Hashable { static var elementsCount: Int { var i = 1 while (withUnsafePointer(to: &i, { return $0.withMemoryRebound(to: self, capacity: 1, { return $0.pointee }) }).hashValue != 0) { i += 1 } return i }
enum Animals:Int, EnumIntArray { case Cat=1, Dog, Rabbit, Chicken, Cow static var all = enumIntArray(Animals.Cat) }
enum Animals:Int, EnumIntArray { case Cat = 1, Dog, case Rabbit = 10, Chicken, Cow static var all = enumIntArray(Animals.Cat, Animals.Cow) }
protocol EnumIntArray { init?(rawValue:Int) var rawValue:Int { get } } func enumIntArray<T:EnumIntArray>(firstValue:T, _ lastValue:T? = nil) -> [T] { var result:[T] = [] var rawValue = firstValue.rawValue while true { if let enumValue = T(rawValue:rawValue++) { result.append(enumValue) } else if lastValue == nil { break } if lastValue != nil && rawValue > lastValue!.rawValue { break } } return result }
let _count: Int = { var max: Int = 0 while let _ = EnumName(rawValue: max) { max += 1 } return max }() enum EnumName: Int { case val0 = 0 case val1 static let count = _count }
public protocol EnumCollection: Hashable { static func cases() -> AnySequence<Self> static var allValues: [Self] { get } } public extension EnumCollection { public static func cases() -> AnySequence<Self> { return AnySequence { () -> AnyIterator<Self> in var raw = 0 return AnyIterator { let current: Self = withUnsafePointer(to: &raw) { $0.withMemoryRebound(to: self, capacity: 1) { $0.pointee } } guard current.hashValue == raw else { return nil } raw += 1 return current } } } public static var allValues: [Self] { return Array(self.cases()) } }
enum Weekdays: String, EnumCollection { case sunday, monday, tuesday, wednesday, thursday, friday, saturday }
struct HashableSequence<T: Hashable>: SequenceType { func generate() -> AnyGenerator<T> { var i = 0 return AnyGenerator { let next = withUnsafePointer(&i) { UnsafePointer<T>($0).memory } if next.hashValue == i { i += 1 return next } return nil } } } extension Hashable { static func enumCases() -> Array<Self> { return Array(HashableSequence()) } static var enumCount: Int { return enumCases().enumCount } } enum E { case A case B case C } E.enumCases() E.enumCount
struct HashableSequence<T: Hashable>: SequenceType { func generate() -> AnyGenerator<T> { var i = 0 return AnyGenerator { guard sizeof(T) == 1 else { return nil } let next = withUnsafePointer(&i) { UnsafePointer<T>($0).memory } if next.hashValue == i { i += 1 return next } return nil } } } extension Hashable { static func enumCases() -> Array<Self> { return Array(HashableSequence()) } static var enumCount: Int { return enumCases().count } } enum E { case A case B case C } Bool.enumCases() Bool.enumCount String.enumCases() String.enumCount Int.enumCases() Int.enumCount E.enumCases() E.enumCount
enum Color : Int { case Red, Orange, Yellow, Green, Cyan, Blue, Purple static let count: Int = Color.Purple.rawValue + 1 func toUIColor() -> UIColor{ switch self { case .Red: return UIColor.redColor() case .Orange: return UIColor.orangeColor() case .Yellow: return UIColor.yellowColor() case .Green: return UIColor.greenColor() case .Cyan: return UIColor.cyanColor() case .Blue: return UIColor.blueColor() case .Purple: return UIColor.redColor() } } }
enum Test : Int { case ONE = 1 case TWO case THREE case FOUR case COUNT static var count: Int { return Test.COUNT.rawValue } }
func randomStringWithLength (len : Int) -> NSString { let letters : NSString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" var randomString : NSMutableString = NSMutableString(capacity: len) for (var i=0; i < len; i++){ var length = UInt32 (letters.length) var rand = arc4random_uniform(length) randomString.appendFormat("%C", letters.characterAtIndex(Int(rand))) } return randomString }
func randomString(length: Int) -> String { let letters : NSString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" let len = UInt32(letters.length) var randomString = "" for _ in 0 ..< length { let rand = arc4random_uniform(len) var nextChar = letters.character(at: Int(rand)) randomString += NSString(characters: &nextChar, length: 1) as String } return randomString }
func randomString(length: Int) -> String { let letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" return String((0...length-1).map{ _ in letters.randomElement()! }) }
func randomAlphaNumericString(length: Int) -> String { let allowedChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" let allowedCharsCount = UInt32(allowedChars.characters.count) var randomString = "" for _ in 0..<length { let randomNum = Int(arc4random_uniform(allowedCharsCount)) let randomIndex = allowedChars.index(allowedChars.startIndex, offsetBy: randomNum) let newCharacter = allowedChars[randomIndex] randomString += String(newCharacter) } return randomString }
String(randomWithLength: 8, allowedCharactersType: .alphaNumeric)
extension String { static func random(length: Int = 20) -> String { let base = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" var randomString: String = "" for _ in 0..<length { let randomValue = arc4random_uniform(UInt32(base.characters.count)) randomString += "\(base[base.startIndex.advancedBy(Int(randomValue))])" } return randomString } }
extension String { static func random(length: Int = 20) -> String { let base = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" var randomString: String = "" for _ in 0..<length { let randomValue = arc4random_uniform(UInt32(base.characters.count)) randomString += "\(base[base.index(base.startIndex, offsetBy: Int(randomValue))])" } return randomString } }
extension String { static func random(length: Int = 20) -> String { let base = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" var randomString: String = "" for _ in 0..<length { let randomValue = arc4random_uniform(UInt32(base.count)) randomString += "\(base[base.index(base.startIndex, offsetBy: Int(randomValue))])" } return randomString } }
let length = 32 let characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" let randomCharacters = (0..<length).map{_ in characters.randomElement()!} let randomString = String(randomCharacters)
func randomString(length: Int) -> String { let charactersString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" let charactersArray : [Character] = Array(charactersString.characters) var string = "" for _ in 0..<length { string.append(charactersArray[Int(arc4random()) % charactersArray.count]) } return string }
let randomString = UUID().uuidString print(randomString.replacingOccurrences(of: "-", with: ""))
func randomString(_ length: Int) -> String { let letters : NSString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" let len = UInt32(letters.length) var randomString = "" for _ in 0 ..< length { let rand = arc4random_uniform(len) var nextChar = letters.character(at: Int(rand)) randomString += NSString(characters: &nextChar, length: 1) as String } return randomString }
func randomString(length: Int) -> String { let letters = "abcABC012‰Ω†Â•ΩÂêóüòÄüê±üí•‚àÜùöπ‚àå‚åò" let n = UInt32(letters.characters.count) var out = "" for _ in 0..<length { let index = letters.startIndex.advancedBy(Int(arc4random_uniform(n))) out.append(letters[index]) } return out }
func randomAlphanumericString(length: Int) -> String { let letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".characters let lettersLength = UInt32(letters.count) let randomCharacters = (0..<length).map { i -> String in let offset = Int(arc4random_uniform(lettersLength)) let c = letters[letters.startIndex.advancedBy(offset)] return String(c) } return randomCharacters.joinWithSeparator("") }
func randomNameString(length: Int = 7)->String{ enum s { static let c = Array("abcdefghjklmnpqrstuvwxyz12345789".characters) static let k = UInt32(c.count) } var result = [Character](repeating: "a", count: length) for i in 0..<length { let r = Int(arc4random_uniform(s.k)) result[i] = s.c[r] } return String(result) }
func randomVowelsString(length: Int = 20)->String{ enum s { static let c = Array("AEIOU".characters) ...
import EntropyString let random = Random() let bits = Entropy.bits(for: 5.0e6, risk: 1.0e12) random.string(bits: bits)
import EntropyString let random = Random(.charSet16) let bits = Entropy.bits(for: 5.0e6, risk: 1.0e12) random.string(bits: bits)
import Foundation import Security private static func createAlphaNumericRandomString(length: Int) -> String? { let randomNumberModulo: UInt8 = 64 let symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" var alphaNumericRandomString = "" let maximumIndex = symbols.count - 1 while alphaNumericRandomString.count != length { let bytesCount = 1 var randomByte: UInt8 = 0 guard errSecSuccess == SecRandomCopyBytes(kSecRandomDefault, bytesCount, &randomByte) else { return nil } let randomIndex = randomByte % randomNumberModulo guard randomIndex <= maximumIndex else { continue } let symbolIndex = symbols.index(symbols.startIndex, offsetBy: Int(randomIndex)) alphaNumericRandomString.append(symbols[symbolIndex]) } return alphaNumericRandomString }
func generateRandom(size: UInt) -> String { let prefixSize = Int(min(size, 43)) let uuidString = UUID().uuidString.replacingOccurrences(of: "-", with: "") return String(Data(uuidString.utf8) .base64EncodedString() .replacingOccurrences(of: "=", with: "") .prefix(prefixSize)) }
for _ in 0...10 { print(generateRandom(size: 32)) }
Nzk3NjgzMTdBQ0FBNDFCNzk2MDRENzZF MUI5RURDQzE1RTdCNDA3RDg2MTI4QkQx M0I3MjJBRjVFRTYyNDFCNkI5OUM1RUVC RDA1RDZGQ0IzQjI1NDdGREI3NDgxM0Mx NjcyNUQyOThCNzhCNEVFQTk1RTQ3NTIy MDkwRTQ0RjFENUFGNEFDOTgyQTUxODI0 RDU2OTNBOUJGMDE4NDhEODlCNEQ1NjZG RjM2MTUxRjM4RkY3NDU2OUFDOTI0Nzkz QzUwOTE1N0U1RDVENDE4OEE5NTM2Rjcy Nzk4QkMxNUJEMjYwNDJDQjhBQkY5QkY5 ODhFNjU0MDVEMUI2NEI5QUIyNjNCNkVF
extension CharacterSet { public func characters() -> [Character] { return codePoints().compactMap { UnicodeScalar($0) }.map { Character($0) } } public func codePoints() -> [Int] { var result: [Int] = [] var plane = 0 for (i, w) in bitmapRepresentation.enumerated() { let k = i % 8193 if k == 8192 { plane = Int(w) << 13 continue } let base = (plane + k) << 3 for j in 0 ..< 8 where w & 1 << j != 0 { result.append(base + j) } } return result } public func randomString(length: Int) -> String { let charArray = characters() let charArrayCount = UInt32(charArray.count) var randomString = "" for _ in 0 ..< length { randomString += String(charArray[Int(arc4random_uniform(charArrayCount))]) } return randomString } }
extension String { static func random(length: Int) -> String { let letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" let randomLength = UInt32(letters.characters.count) let randomString: String = (0 ..< length).reduce(String()) { accum, _ in let randomOffset = arc4random_uniform(randomLength) let randomIndex = letters.index(letters.startIndex, offsetBy: Int(randomOffset)) return accum.appending(String(letters[randomIndex])) } return randomString } }
func randomString(_ length: Int) -> String { let master = Array("abcdefghijklmnopqrstuvwxyz-ABCDEFGHIJKLMNOPQRSTUVWXYZ_123456789".characters) var randomString = "" for _ in 1...length{ let random = arc4random_uniform(UInt32(master.count)) randomString.append(String(master[Int(random)])) } return randomString }
extension String { static var chars: [Character] = { return "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".map({$0}) }() static func random(length: Int) -> String { var partial: [Character] = [] for _ in 0..<length { let rand = Int(arc4random_uniform(UInt32(chars.count))) partial.append(chars[rand]) } return String(partial) } } String.random(length: 10)
func randomUIDString(_ wlength: Int) -> String { let letters : NSString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" var randomString = "" for _ in 0 ..< wlength { let length = UInt32 (letters.length) let rand = arc4random_uniform(length) randomString = randomString.appendingFormat("%C", letters.character(at: Int(rand))); } return randomString }
var documentsPath = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory:0,NSSearchPathDomainMask:0,true)
func NSSearchPathForDirectoriesInDomains( directory: NSSearchPathDirectory, domainMask: NSSearchPathDomainMask, expandTilde: Bool) -> AnyObject[]!
let documentsPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0]
let documentsPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0]
func databaseURL() -> NSURL? { let fileManager = NSFileManager.defaultManager() let urls = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) if let documentDirectory: NSURL = urls.first as? NSURL { let finalDatabaseURL = documentDirectory.URLByAppendingPathComponent("items.db") if finalDatabaseURL.checkResourceIsReachableAndReturnError(nil) { return finalDatabaseURL } else { if let bundleURL = NSBundle.mainBundle().URLForResource("items", withExtension: "db") { let success = fileManager.copyItemAtURL(bundleURL, toURL: finalDatabaseURL, error: nil) if success { return finalDatabaseURL } else { println("Couldn } } else { println("Couldn } } } else { println("Couldn } return nil }
if let documentsPathString = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first { } if let documentsPathURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first { }
let documentDirectoryURL = try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true)
let documentDirectoryURL = try! NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: true)
extension FileManager { class func documentsDir() -> String { var paths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true) as [String] return paths[0] } class func cachesDir() -> String { var paths = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true) as [String] return paths[0] } }
extension NSFileManager { class func documentsDir() -> String { var paths = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true) as [String] return paths[0] } class func cachesDir() -> String { var paths = NSSearchPathForDirectoriesInDomains(.CachesDirectory, .UserDomainMask, true) as [String] return paths[0] } }
func databaseURL() -> NSURL? { let fileManager = NSFileManager.defaultManager() let urls = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) if let documentDirectory:NSURL = urls.first { let finalDatabaseURL = documentDirectory.URLByAppendingPathComponent("OurFile.plist") if finalDatabaseURL.checkResourceIsReachableAndReturnError(nil) { return finalDatabaseURL } else { if let bundleURL = NSBundle.mainBundle().URLForResource("OurFile", withExtension: "plist") { do { try fileManager.copyItemAtURL(bundleURL, toURL: finalDatabaseURL) } catch let error as NSError { print("Couldn } } else { print("Couldn } } } else { print("Couldn } return nil }
func databaseURL() -> NSURL? { let fileManager = NSFileManager.defaultManager() let urls = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) guard urls.count != 0 else { return nil } let finalDatabaseURL = urls.first!.URLByAppendingPathComponent("OurFile.plist") guard finalDatabaseURL.checkResourceIsReachableAndReturnError(nil) else { if let bundleURL = NSBundle.mainBundle().URLForResource("OurFile", withExtension: "plist") { do { try fileManager.copyItemAtURL(bundleURL, toURL: finalDatabaseURL) } catch let error as NSError { print("File copy failed! Error:\(error.localizedDescription)") } } else { print("Our file not exist in bundle folder") return nil } return finalDatabaseURL } return finalDatabaseURL }
let documentsUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
let paths = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.documentDirectory, FileManager.SearchPathDomainMask.userDomainMask, true)
let fileManager = FileManager.default if let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first { let databasePath = documentsURL.appendingPathComponent("db.sqlite3").path print("directory path:", documentsURL.path) print("database path:", databasePath) if !fileManager.fileExists(atPath: databasePath) { fileManager.createFile(atPath: databasePath, contents: nil, attributes: nil) } }
import UIKit import Foundation @IBDesignable class PlaceholderTextView: UITextView, UITextViewDelegate { @IBInspectable var placeholder: String = "" { didSet { setPlaceholderText() } } private let placeholderColor: UIColor = UIColor.lightGrayColor() private var textColorCache: UIColor! override init(frame: CGRect) { super.init(frame: frame) self.delegate = self } required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) self.delegate = self } func textViewDidBeginEditing(textView: UITextView) { if textView.text == placeholder { textView.text = "" textView.textColor = textColorCache } } func textViewDidEndEditing(textView: UITextView) { if textView.text == "" && placeholder != "" { setPlaceholderText() } } func setPlaceholderText() { if placeholder != "" { if textColorCache == nil { textColorCache = self.textColor } self.textColor = placeholderColor self.text = placeholder } } }
className = NSStringFromClass([self class]); self.view = [[[NSBundle mainBundle] loadNibNamed:className owner:self options:nil] firstObject];
bundle = [NSBundle bundleForClass:[self class]]; className = NSStringFromClass([self class]); self.view = [[bundle loadNibNamed:className owner:self options:nil] firstObject];
@IBInspectable var repeatImage:UIImage = UIImage(named:"myImage")!{ didSet{ } }
@IBInspectable var repeatImage:UIImage = RepeatImageView.getDefaultImage(){ didSet{ } } class func getDefaultImage()->UIImage{ if let defaultImage = UIImage(named: "myImage"){ return defaultImage }else{ return UIImage() } }
self.backgroundImage.image = UIImage(named: "rectangleCenter")
required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } override init(frame: CGRect) { super.init(frame: frame) }
post_install do |installer| installer.pods_project.build_configurations.each do |config| config.build_settings.delete( config.build_settings.delete( end end
post_install do |installer| installer.pods_project.build_configurations.each do |config| config.build_settings.delete( config.build_settings.delete( end end
private func setUp() { if let icon = UIImage(named: "IconImageName") { iconImageView.image = icon iconImageView.frame.size = icon.size } if let font = UIFont(name: "Calibri-Light", size: size) { nameLabel.font = font } else { nameLabel.font = UIFont.systemFont(ofSize: size) } }
enum ThrowableError : ErrorType { case BadError } func doSomething() throws -> String { if everythingIsFine { return "Everything is ok" } else { throw ThrowableError.BadError } }
func doSomeOtherThing() throws -> Void { let result = try doSomething() }
extension NSDate { func isGreaterThanDate(dateToCompare: NSDate) -> Bool { var isGreater = false if self.compare(dateToCompare) == NSComparisonResult.OrderedDescending { isGreater = true } return isGreater } func isLessThanDate(dateToCompare: NSDate) -> Bool { var isLess = false if self.compare(dateToCompare) == NSComparisonResult.OrderedAscending { isLess = true } return isLess } func equalToDate(dateToCompare: NSDate) -> Bool { var isEqualTo = false if self.compare(dateToCompare) == NSComparisonResult.OrderedSame { isEqualTo = true } return isEqualTo } func addDays(daysToAdd: Int) -> NSDate { let secondsInDays: NSTimeInterval = Double(daysToAdd) * 60 * 60 * 24 let dateWithDaysAdded: NSDate = self.dateByAddingTimeInterval(secondsInDays) return dateWithDaysAdded } func addHours(hoursToAdd: Int) -> NSDate { let secondsInHours: NSTimeInterval = Double(hoursToAdd) * 60 * 60 let dateWithHoursAdded: NSDate = self.dateByAddingTimeInterval(secondsInHours) return dateWithHoursAdded } }
var currentDateTime = NSDate() var reminderDate = dueDate.addDays(-7) if(reminderDate.isGreaterThanDate(currentDateTime)) { }
public func ==(lhs: NSDate, rhs: NSDate) -> Bool { return lhs === rhs || lhs.compare(rhs) == .OrderedSame } public func <(lhs: NSDate, rhs: NSDate) -> Bool { return lhs.compare(rhs) == .OrderedAscending } extension NSDate: Comparable { }
if date1.compare(date2) == NSComparisonResult.OrderedDescending { NSLog("date1 after date2"); } else if date1.compare(date2) == NSComparisonResult.OrderedAscending { NSLog("date1 before date2"); } else { NSLog("dates are equal"); }
let dueDate=... let calendar = NSCalendar.currentCalendar() let comps = NSDateComponents() comps.day = 7 let date2 = calendar.dateByAddingComponents(comps, toDate: NSDate(), options: NSCalendarOptions.allZeros) if dueDate.compare(date2!) == NSComparisonResult.OrderedDescending { NSLog("not due within a week"); } else if dueDate.compare(date2!) == NSComparisonResult.OrderedAscending { NSLog("due within a week"); } else { NSLog("due in exactly a week (to the second, this will rarely happen in practice)"); }
let greater = date1.timeIntervalSince1970 < date2.timeIntervalSince1970
/** `Date` represents a single point in time. A `Date` is independent of a particular calendar or time zone. To represent a `Date` to a user, you must interpret it in the context of a `Calendar`. */ public struct Date : ReferenceConvertible, Comparable, Equatable { /** Returns the interval between the receiver and another given date. - Parameter another: The date with which to compare the receiver. - Returns: The interval between the receiver and the `another` parameter. If the receiver is earlier than `anotherDate`, the return value is negative. If `anotherDate` is `nil`, the results are undefined. - SeeAlso: `timeIntervalSince1970` - SeeAlso: `timeIntervalSinceNow` - SeeAlso: `timeIntervalSinceReferenceDate` */ public func timeIntervalSince(_ date: Date) -> TimeInterval public static func ==(lhs: Date, rhs: Date) -> Bool public static func <(lhs: Date, rhs: Date) -> Bool public static func >(lhs: Date, rhs: Date) -> Bool public static func +(lhs: Date, rhs: TimeInterval) -> Date public static func -(lhs: Date, rhs: TimeInterval) -> Date }
extension NSDate { func isGreaterThanDate(dateToCompare: NSDate) -> Bool { return self.compare(dateToCompare) == NSComparisonResult.OrderedDescending } func isLessThanDate(dateToCompare: NSDate) -> Bool { return self.compare(dateToCompare) == NSComparisonResult.OrderedAscending } func equalToDate(dateToCompare: NSDate) -> Bool { return self.compare(dateToCompare) == NSComparisonResult.OrderedSame } }
func compareDate(date1:NSDate, date2:NSDate, toUnitGranularity: NSCalendar.Unit) -> Bool { let order = NSCalendar.current.compare(date1 as Date, to: date2 as Date, toGranularity: .day) switch order { case .orderedSame: return true default: return false } }
public static func ==(lhs: Date, rhs: Date) -> Bool public static func <(lhs: Date, rhs: Date) -> Bool public static func >(lhs: Date, rhs: Date) -> Bool public static func +(lhs: Date, rhs: TimeInterval) -> Date public static func -(lhs: Date, rhs: TimeInterval) -> Date public static func +=(lhs: inout Date, rhs: TimeInterval) public static func -=(lhs: inout Date, rhs: TimeInterval)
let date1 = Date() let date2 = Date() let isGreater = date1 > date2 print(isGreater) let isEqual = date1 == date2 print(isEqual)
let result = date1.compare(date2) switch result { case .OrderedAscending : print("date 1 is earlier than date 2") case .OrderedDescending : print("date 1 is later than date 2") case .OrderedSame : print("two dates are the same") }
extension Date { fun isGreater(than date: Date) -> Bool { return self > date } func isSmaller(than date: Date) -> Bool { return self < date } func isEqual(to date: Date) -> Bool { return self == date } }
if startDate.compare(endDate as Date) == ComparisonResult.orderedDescending
let documentsPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as NSString let files = NSFileManager.defaultManager().contentsOfDirectoryAtPath(documentsPath, error: nil) let filesAndProperties = NSMutableArray() for file in files! { let filePath = documentsPath.stringByAppendingString(file as NSString) let properties = NSFileManager.defaultManager().attributesOfItemAtPath(filePath, error: nil) let modDate = properties![NSFileModificationDate] as NSDate filesAndProperties.addObject(NSDictionary(objectsAndKeys: file, "path", modDate, "lastModDate")) } let sortedFiles = filesAndProperties.sortedArrayUsingComparator({ (path1, path2) -> NSComparisonResult in var comp = (path1.objectForKey("lastModDate") as NSDate).compare(path2.objectForKey("lastModDate") as NSDate) if comp == .OrderedDescending { comp = .OrderedAscending } else if comp == .OrderedAscending { comp = .OrderedDescending } return comp })
var dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd" let dateData: String = dateFormatter.stringFromDate(date1) let testDate: String = dateFormatter.stringFromDate(date2) print(dateData == testDate)
NSDate * now = [NSDate date]; NSDateFormatter *outputFormatter = [[NSDateFormatter alloc] init]; [outputFormatter setDateFormat:@"HH:mm:ss"]; NSString *currentTimeString = [outputFormatter stringFromDate:now]; NSDate *dateCurrent = [outputFormatter dateFromString:currentTimeString]; NSString *timeStart = @"09:00:00"; NSString *timeEnd = @"22:00:00"; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@"HH:mm:ss"]; NSDate *dateStart= [formatter timeStart]; NSDate *dateEnd = [formatter timeEnd]; NSComparisonResult result = [dateCurrent compare:dateStart]; NSComparisonResult resultSecond = [date2 compare:dateEnd]; if(result == NSOrderedDescending && resultSecond == NSOrderedDescending) { NSLog(@"current time lies in starting and end time"); }else { NSLog(@"current time doesn }
func compareDate(dateInitial:Date, dateFinal:Date) -> Bool { let order = Calendar.current.compare(dateInitial, to: dateFinal, toGranularity: .day) switch order { case .orderedSame: return true default: return false } }
extension Date { func compareTo(date: Date, toGranularity: Calendar.Component ) -> ComparisonResult { var cal = Calendar.current cal.timeZone = TimeZone(identifier: "Europe/Paris")! return cal.compare(self, to: date, toGranularity: toGranularity) } }
if thisDate.compareTo(date: Date(), toGranularity: .day) == .orderedDescending { }
let formatter = DateFormatter() formatter.timeZone = TimeZone(identifier: "Europe/Paris") formatter.dateFormat = "yyyy/MM/dd HH:mm:ss" let findThisDay = formatter.date(from: "2018/11/05 08:11:08")! _ = [ formatter.date(from: "2018/12/05 08:08:08")!, formatter.date(from: "2018/11/05 08:11:08")!, formatter.date(from: "2018/11/05 11:08:22")!, formatter.date(from: "2018/11/05 22:08:22")!, formatter.date(from: "2018/11/05 08:08:22")!, formatter.date(from: "2018/11/07 08:08:22")!, ] .filter{ findThisDay.compareTo(date: $0 , toGranularity: .day) == .orderedSame } .map { print(formatter.string(from: $0)) }
someArray.sort({($0.dateAdded?.timeIntervalSinceReferenceDate)! < ($1.dateAdded?.timeIntervalSinceReferenceDate)!})
override func preferredStatusBarStyle() -> UIStatusBarStyle { return UIStatusBarStyle.LightContent; }
UIApplication.sharedApplication().statusBarStyle = .LightContent
UIApplication.sharedApplication().statusBarStyle = .LightContent
UIApplication.shared.statusBarStyle = .lightContent
UIApplication.sharedApplication().statusBarStyle = .LightContent
UIApplication.shared.statusBarStyle = .lightContent
override func viewWillDisappear(animated: Bool) { super.viewWillDisappear(animated) UIApplication.sharedApplication().statusBarStyle = UIStatusBarStyle.Default }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) UIApplication.shared.statusBarStyle = UIStatusBarStyle.default }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) self.setNeedsStatusBarAppearanceUpdate() } override var preferredStatusBarStyle : UIStatusBarStyle { return .lightContent }
UIApplication.sharedApplication().setStatusBarStyle(UIStatusBarStyle.LightContent, animated: true)
override func viewWillAppear(animated: Bool) { self.navigationController?.navigationBarHidden = true UIApplication.sharedApplication().statusBarHidden = false UIApplication.sharedApplication().statusBarStyle = .LightContent let statusBar: UIView = UIApplication.sharedApplication().valueForKey("statusBar") as! UIView if statusBar.respondsToSelector("setBackgroundColor:") { statusBar.backgroundColor = UIColor.redColor() } }
extension UIApplication { class var statusBarBackgroundColor: UIColor? { get { return (shared.value(forKey: "statusBar") as? UIView)?.backgroundColor } set { (shared.value(forKey: "statusBar") as? UIView)?.backgroundColor = newValue } } }
let statusBar: UIView = UIApplication.sharedApplication().valueForKey("statusBar") as! UIView if statusBar.respondsToSelector(Selector("setBackgroundColor:")) { statusBar.backgroundColor = .redColor() }
let statusBar: UIView = UIApplication.shared.value(forKey: "statusBar") as! UIView if statusBar.responds(to: statusBar.backgroundColor = UIColor.black }
UIApplication.sharedApplication().statusBarHidden = false UIApplication.sharedApplication().statusBarStyle = .LightContent
override func preferredStatusBarStyle() -> UIStatusBarStyle { return .LightContent }
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { UIApplication.shared.isStatusBarHidden = false UIApplication.shared.statusBarStyle = .lightContent let statusBar: UIView = UIApplication.shared.value(forKey: "statusBar") as! UIView statusBar.backgroundColor = UIColor.gray return true }
var addStatusBar = UIView() addStatusBar.frame = CGRectMake(0, 0, UIScreen.mainScreen().bounds.width, 20); addStatusBar.backgroundColor = global().UIColorFromRGB(0x65b4d9) self.window?.rootViewController?.view .addSubview(addStatusBar)
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
UINavigationBar.appearance().barStyle = .black UINavigationBar.appearance().barTintColor = UIColor(red: 230, green: 32, blue: 31, alpha: 1.0)
// // // import UIKit class LoginController: UIViewController { override func viewDidLoad() { super.viewDidLoad() setNeedsStatusBarAppearanceUpdate() view.backgroundColor = UIColor(red: 61/255, green: 91/255, blue: 151/255, alpha: 1) } override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent } }
override var preferredStatusBarStyle : UIStatusBarStyle { return .lightContent }
override var preferredStatusBarStyle : UIStatusBarStyle { return .lightContent }
class NavigationController : UINavigationController { override var preferredStatusBarStyle : UIStatusBarStyle { if let topVC = viewControllers.last { return topVC.preferredStatusBarStyle } return .default }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { . . . UIApplication.sharedApplication().statusBarHidden = false UIApplication.sharedApplication().statusBarStyle = .LightContent let statusBar: UIView = UIApplication.sharedApplication().valueForKey("statusBar") as! UIView if statusBar.respondsToSelector(Selector("setBackgroundColor:")) { statusBar.backgroundColor = UIColor.init(red: 0.1, green: 0.27, blue: 0.60, alpha: 1.0) } . . . }
[self setNeedsStatusBarAppearanceUpdate]; -(UIStatusBarStyle)preferredStatusBarStyle { return UIStatusBarStyleLightContent; }
setNeedsStatusBarAppearanceUpdate() var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
override var preferredStatusBarStyle: UIStatusBarStyle { if let topViewController = viewControllers.last { return topViewController.preferredStatusBarStyle } return .default }
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { UIApplication.shared.statusBarStyle = .lightContent return true }
func application(application: UIApplication!, didFinishLaunchingWithOptions launchOptions: NSDictionary!) -> Bool { UIApplication.sharedApplication().setStatusBarStyle(UIStatusBarStyle.LightContent, animated: true) return true }
class UIViewControllerWithLightStatusBar: UIViewController { override var preferredStatusBarStyle: UIStatusBarStyle { return UIStatusBarStyle.lightContent } }
class YourViewController: UIViewControllerWithLightStatusBar { ... }
let statusBar: UIView = application.value(forKey: "statusBar") as! UIView statusBar.backgroundColor = .red
UIApplication.shared.statusBarStyle = .lightContent let statusBar: UIView = UIApplication.shared.value(forKey: "statusBar") as! UIView if statusBar.responds(to:
txt_Password = new UITextField { Frame = new RectangleF (20,40,180,31), BorderStyle = UITextBorderStyle.Bezel, TextColor = UIColor.Black, SecureTextEntry = true, Font = UIFont.SystemFontOfSize (17f), Placeholder = "Enter Password", BackgroundColor = UIColor.White, AutocorrectionType = UITextAutocorrectionType.No, KeyboardType = UIKeyboardType.Default, ReturnKeyType = UIReturnKeyType.Done, ClearButtonMode = UITextFieldViewMode.WhileEditing, };
override func viewDidLoad() { super.viewDidLoad() self.navigationController?.navigationBar.barTintColor = UIColor.blackColor() self.navigationController?.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.orangeColor()] }
UINavigationBar.appearance().barTintColor = UIColor(red: 234.0/255.0, green: 46.0/255.0, blue: 73.0/255.0, alpha: 1.0) UINavigationBar.appearance().tintColor = UIColor.white UINavigationBar.appearance().titleTextAttributes = [NSAttributedStringKey.foregroundColor : UIColor.white]
viewWillAppear() override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) var nav = self.navigationController?.navigationBar nav?.barStyle = UIBarStyle.Black nav?.tintColor = UIColor.white nav?.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.orange] }
class NavigationController: UINavigationController, UIViewControllerTransitioningDelegate { override func viewDidLoad() { super.viewDidLoad() self.navigationBar.barStyle = UIBarStyle.Black self.navigationBar.tintColor = UIColor.whiteColor() } }
self.navigationController?.navigationBar.titleTextAttributes = [NSAttributedStringKey.foregroundColor: UIColor.white]
[self.navigationController.navigationBar setBarTintColor:[UIColor whiteColor]]; [self.navigationController.navigationBar setTranslucent:NO];
self.navigationController?.navigationBar.barTintColor = UIColor.redColor()
self.navigationController?.navigationBar.barTintColor = UIColor.red
@IBDesignable extension UINavigationController { @IBInspectable var barTintColor: UIColor? { set { navigationBar.barTintColor = newValue } get { guard let color = navigationBar.barTintColor else { return nil } return color } } @IBInspectable var tintColor: UIColor? { set { navigationBar.tintColor = newValue } get { guard let color = navigationBar.tintColor else { return nil } return color } } @IBInspectable var titleColor: UIColor? { set { guard let color = newValue else { return } navigationBar.titleTextAttributes = [NSForegroundColorAttributeName: color] } get { return navigationBar.titleTextAttributes?["NSForegroundColorAttributeName"] as? UIColor } } }
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { var navigationBarAppearace = UINavigationBar.appearance() navigationBarAppearace.tintColor = UIColor(red:1.00, green:1.00, blue:1.00, alpha:1.0) navigationBarAppearace.barTintColor = UIColor(red:0.76, green:0.40, blue:0.40, alpha:1.0) navigationBarAppearace.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.white] return true `
override func viewDidLoad() { super.viewDidLoad() self.navigationController?.navigationBar.tintColor = UIColor.blue self.navigationController?.navigationBar.barStyle = UIBarStyle.black }
self.navigationItem.title = "your name" let textAttributes = [NSAttributedStringKey.foregroundColor:UIColor.white] navigationController?.navigationBar.titleTextAttributes = textAttributes
override func viewDidLoad() { super.viewDidLoad() navigationController?.navigationBar.barTintColor = UIColor.orange navigationController?.navigationBar.tintColor = UIColor.white navigationController?.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.white] }
override func viewDidLoad() { super.viewDidLoad() setup() }
func setup() { navigationController?.navigationBar.prefersLargeTitles = true navigationController?.navigationBar.barStyle = .blackOpaque navigationItem.title = "YOUR_TITLE_HERE" navigationController?.navigationBar.barTintColor = .black let attributes = [NSAttributedStringKey.foregroundColor: UIColor.white] navigationController?.navigationBar.largeTitleTextAttributes = attributes }
UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName : UIColor.white]
navigationController?.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName :UIColor.white]
navigationController?.navigationBar.barTintColor = UIColor.white navigationController?.navigationBar.titleTextAttributes = [NSAttributedStringKey.foregroundColor: UIColor.blue]
var nav = self.navigationController?.navigationBar nav?.barStyle = UIBarStyle.Black nav?.tintColor = UIColor.white nav?.titleTextAttributes = [NSForegroundColorAttributeName: UIColor.orange]
UINavigationBar.appearance().barTintColor = UIColor(red: 234.0/255.0, green: 46.0/255.0, blue: 73.0/255.0, alpha: 1.0) UINavigationBar.appearance().tintColor = UIColor.white UINavigationBar.appearance().titleTextAttributes = [.foregroundColor : UIColor.white]
import UIKit class TestViewController: UIViewController { init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) { super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) } override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } /* override func prepareForSegue(segue: UIStoryboardSegue?, sender: AnyObject?) { } */ }
required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) }
init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) { super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) }
init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder) }
required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) }
`required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") }`
override init(frame: CGRect) { super.init(frame: frame) }
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/Library/Frameworks
DEBUG_INFORMATION_FORMAT = dwarf; ONLY_ACTIVE_ARCH = YES; VALIDATE_PRODUCT = NO;
s.source_files = ["Classes/**/*.{swift}", "Classes/**/*.{xib}"] s.exclude_files = ["Classes/Exclude", "Classes/MyPodProjTests/"]
s.source_files = ["Classes/MyPodProj/**/*.{swift}", "Classes/**/*.{xib}"]
import UIKit class ViewController: UIViewController { @IBOutlet weak var username: UITextField! @IBAction func signIn(sender: AnyObject) { PFUser.logInWithUsernameInBackground(username.text, password:"mypass") { (user: PFUser!, error: NSError!) -> Void in if user != nil { println("Logged In") } else { func myMethod() { var user = PFUser() user.username = username.text user.password = " " user.signUpInBackgroundWithBlock { (succeeded: Bool!, error: NSError!) -> Void in if error == nil { } else { println("Signed Up") } } } println(error) } } } override func viewDidLoad() { super.viewDidLoad() Parse.setApplicationId("key here") } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
CompileSwift normal arm64 /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat/ViewController.swift cd /Users/Alec/Desktop/Re-Chat/Re-Chat /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat/ViewController.swift /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat/AppDelegate.swift -target arm64-apple-ios8.0 -Xllvm -aarch64-use-tbi -target-cpu cyclone -target-abi darwinpcs -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk -I /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Products/Debug-iphoneos -F /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Products/Debug-iphoneos -F /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat -g -import-objc-header /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat/Re-Chat-Bridging-Header.h -module-cache-path /Users/Alec/Library/Developer/Xcode/DerivedData/ModuleCache -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Re-Chat-generated-files.hmap -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Re-Chat-own-target-headers.hmap -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Re-Chat-all-target-headers.hmap -Xcc -iquote -Xcc /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Re-Chat-project-headers.hmap -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Products/Debug-iphoneos/include -Xcc -I/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/DerivedSources/arm64 -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/DerivedSources -Xcc -DDEBUG=1 -emit-module-doc-path /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController~partial.swiftdoc -Onone -module-name Re_Chat -emit-module-path /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController~partial.swiftmodule -serialize-diagnostics-path /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController.dia -emit-dependencies-path /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController.d -o /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController.o 0 swift 0x0000000108145a68 llvm::sys::PrintStackTrace(__sFILE*) + 40 1 swift 0x0000000108145f54 SignalHandler(int) + 452 2 libsystem_platform.dylib 0x00007fff86631f1a _sigtramp + 26 3 libsystem_platform.dylib 0x00007fd0ac1eb010 _sigtramp + 633049360 4 swift 0x00000001075d4517 swift::Lowering::SILGenFunction::emitClosureValue(swift::SILLocation, swift::SILDeclRef, llvm::ArrayRef<swift::Substitution>, swift::AnyFunctionRef) + 1303 5 swift 0x00000001075c599e swift::Lowering::SILGenFunction::visitFuncDecl(swift::FuncDecl*) + 190 6 swift 0x000000010760987c swift::Lowering::SILGenFunction::visitBraceStmt(swift::BraceStmt*) + 380 7 swift 0x000000010760c8e8 swift::ASTVisitor<swift::Lowering::SILGenFunction, void, void, void, void, void, void>::visit(swift::Stmt*) + 152 8 swift 0x000000010760a0a5 swift::Lowering::SILGenFunction::visitIfStmt(swift::IfStmt*) + 757 9 swift 0x000000010760c8f6 swift::ASTVisitor<swift::Lowering::SILGenFunction, void, void, void, void, void, void>::visit(swift::Stmt*) + 166 10 swift 0x00000001076097e8 swift::Lowering::SILGenFunction::visitBraceStmt(swift::BraceStmt*) + 232 11 swift 0x000000010760c8e8 swift::ASTVisitor<swift::Lowering::SILGenFunction, void, void, void, void, void, void>::visit(swift::Stmt*) + 152 12 swift 0x00000001075d52dd swift::Lowering::SILGenFunction::emitClosure(swift::AbstractClosureExpr*) + 205 13 swift 0x00000001075b4234 swift::Lowering::SILGenModule::emitClosure(swift::AbstractClosureExpr*) + 196 14 swift 0x00000001075eef71 (anonymous namespace)::RValueEmitter::visitAbstractClosureExpr(swift::AbstractClosureExpr*, swift::Lowering::SGFContext) + 97 15 swift 0x00000001075e1866 swift::ASTVisitor<(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext>::visit(swift::Expr*, swift::Lowering::SGFContext) + 2870 16 swift 0x00000001075e24da swift::ASTVisitor<(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext>::visit(swift::Expr*, swift::Lowering::SGFContext) + 6058 17 swift 0x00000001075cfa0b swift::Lowering::SILGenFunction::emitExprInto(swift::Expr*, swift::Lowering::Initialization*) + 235 18 swift 0x00000001075ae824 swift::Lowering::RValueSource::materialize(swift::Lowering::SILGenFunction&) && + 196 19 swift 0x0000000107604a69 swift::Lowering::RValueSource::materialize(swift::Lowering::SILGenFunction&, swift::Lowering::AbstractionPattern, swift::SILType) && + 233 20 swift 0x00000001075f371c swift::Lowering::SILGenFunction::emitInjectOptionalValueInto(swift::SILLocation, swift::Lowering::RValueSource&&, swift::SILValue, swift::Lowering::TypeLowering const&) + 268 21 swift 0x00000001075e9b8d swift::ASTVisitor<(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext>::visit(swift::Expr*, swift::Lowering::SGFContext) + 36445 22 swift 0x00000001075e3e2b swift::ASTVisitor<(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext>::visit(swift::Expr*, swift::Lowering::SGFContext) + 12539 23 swift 0x00000001075e202b swift::ASTVisitor<(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext>::visit(swift::Expr*, swift::Lowering::SGFContext) + 4859 24 swift 0x00000001075cfab6 swift::Lowering::SILGenFunction::emitRValue(swift::Expr*, swift::Lowering::SGFContext) + 22 25 swift 0x00000001075bffc4 (anonymous namespace)::ArgEmitter::emitExpanded(swift::Lowering::RValueSource&&, swift::Lowering::AbstractionPattern) + 836 26 swift 0x00000001075bf582 (anonymous namespace)::ArgEmitter::emit(swift::Lowering::RValueSource&&, swift::Lowering::AbstractionPattern) + 98 27 swift 0x00000001075b7ff8 (anonymous namespace)::CallEmission::apply(swift::Lowering::SGFContext) + 1128 28 swift 0x00000001075b751a swift::Lowering::SILGenFunction::emitApplyExpr(swift::ApplyExpr*, swift::Lowering::SGFContext) + 58 29 swift 0x00000001075e0d81 swift::ASTVisitor<(anonymous namespace)::RValueEmitter, swift::Lowering::RValue, void, void, void, void, void, swift::Lowering::SGFContext>::visit(swift::Expr*, swift::Lowering::SGFContext) + 81 30 swift 0x00000001075ea00d swift::Lowering::SILGenFunction::emitIgnoredExpr(swift::Expr*) + 237 31 swift 0x0000000107609829 swift::Lowering::SILGenFunction::visitBraceStmt(swift::BraceStmt*) + 297 32 swift 0x000000010760c8e8 swift::ASTVisitor<swift::Lowering::SILGenFunction, void, void, void, void, void, void>::visit(swift::Stmt*) + 152 33 swift 0x00000001075d4ee0 swift::Lowering::SILGenFunction::emitFunction(swift::FuncDecl*) + 256 34 swift 0x00000001075b3659 swift::Lowering::SILGenModule::emitFunction(swift::FuncDecl*) + 233 35 swift 0x00000001075cea93 swift::ASTVisitor<SILGenType, void, void, void, void, void, void>::visit(swift::Decl*) + 355 36 swift 0x00000001075cd7eb SILGenType::emitType() + 203 37 swift 0x00000001075c85ae swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30 38 swift 0x00000001075b555b swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 395 39 swift 0x00000001075b581a swift::SILModule::constructSIL(swift::Module*, swift::SourceFile*, swift::Optional<unsigned int>) + 314 40 swift 0x00000001075b5968 swift::performSILGeneration(swift::SourceFile&, swift::Optional<unsigned int>) + 72 41 swift 0x000000010748be18 frontend_main(llvm::ArrayRef<char const*>, char const*, void*) + 3432 42 swift 0x000000010748996d main + 1677 43 libdyld.dylib 0x00007fff8aa4c5c9 start + 1 Stack dump: 0. Program arguments: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -c -primary-file /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat/ViewController.swift /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat/AppDelegate.swift -target arm64-apple-ios8.0 -Xllvm -aarch64-use-tbi -target-cpu cyclone -target-abi darwinpcs -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk -I /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Products/Debug-iphoneos -F /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Products/Debug-iphoneos -F /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat -g -import-objc-header /Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat/Re-Chat-Bridging-Header.h -module-cache-path /Users/Alec/Library/Developer/Xcode/DerivedData/ModuleCache -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Re-Chat-generated-files.hmap -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Re-Chat-own-target-headers.hmap -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Re-Chat-all-target-headers.hmap -Xcc -iquote -Xcc /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Re-Chat-project-headers.hmap -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Products/Debug-iphoneos/include -Xcc -I/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/DerivedSources/arm64 -Xcc -I/Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/DerivedSources -Xcc -DDEBUG=1 -emit-module-doc-path /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController~partial.swiftdoc -Onone -module-name Re_Chat -emit-module-path /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController~partial.swiftmodule -serialize-diagnostics-path /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController.dia -emit-dependencies-path /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController.d -o /Users/Alec/Library/Developer/Xcode/DerivedData/Re-Chat-awwdkmqavitiqkcdsphwnhzhzzfb/Build/Intermediates/Re-Chat.build/Debug-iphoneos/Re-Chat.build/Objects-normal/arm64/ViewController.o 1. While emitting SIL for 2. While silgen closureexpr SIL function @_TFFC7Re_Chat14ViewController6signInFS0_FPSs9AnyObject_T_U_FTGSQCSo6PFUser_GSQCSo7NSError__T_ for expression at [/Users/Alec/Desktop/Re-Chat/Re-Chat/Re-Chat/ViewController.swift:16:80 - line:45:9] RangeText="{ (user: PFUser!, error: NSError!) -> Void in if user != nil { println("Logged In") } else { func myMethod() { var user = PFUser() user.username = username.text user.password = "" user.signUpInBackgroundWithBlock { (succeeded: Bool!, error: NSError!) -> Void in if error == nil { } else { println("Signed Up") } } } println("error") } }"
myPFQuery.findObjectsInBackgroundWithBlock({ (queryResults: [AnyObject]?, error: NSError?) -> Void in })
myPFQuery.findObjectsInBackgroundWithBlock { (queryResults: [PFObject]?, error: NSError?) -> Void in }
func numberAndTitleFromDirectoryName(dirName: String) -> (Int, String)? { let components = dirName.characters.split(maxSplit: 1, allowEmptySlices: false) { $0 == " " }.map { String($0) }.map { String($0) } if let number = components.first?.toInt() { if let title = components.last { return (number, title) } } return nil; }
function getInt(value: Int) -> Int { return _a? ?? _b?.count ?? 0 }
let firstTask = DispatchWorkItem{ } let secondTask = DispatchWorkItem{ } DispatchQueue.main.asyncAfter(deadline: .now() + 10){firstTask} DispatchQueue.main.asyncAfter(deadline: .now() + 20){secondTask}
DispatchQueue.main.asyncAfter(deadline: .now() + 10, execute: firstTask) DispatchQueue.main.asyncAfter(deadline: .now() + 20, execute: secondTask)
required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) stuff... }
func post(a : Int, b : String) { NSNotificationCenter.defaultCenter().postNotification("notification", object: nil, userInfo: ["a" : a, "b" : b]) } func observe(block : (a : Int, b : String) -> ()) -> NSObjectProtocol { return NSNotificationCenter.defaultCenter().addObserverForName("notification", object: nil, queue: nil) { (n : NSNotification!) -> () in if let a = n.userInfo?["a"] as? Int, let b = n.userInfo?["b"] as? String { block(a, b) } } }
extension classOrig { class classChild { class classGrandChild { static let aVariable : String = "SomeValue"; } } }
self.mainScrollView.documentView!.subviews.reverse() as! [MainSubView]
(self.mainScrollView.documentView!.subviews as! [MainSubView]).reverse()
func getSlider() throws -> UISlider { ... return UISlider() }
func anotherMethod() -> Float { return try! getSlider().value }
func anotherMethod() -> Float { return (try! getSlider()).value }
func addSubview(subview subview: UIView, constrain: NSLayoutAttribute...)
someUIView.addSubview(subview: someOtherView, constrain: [.Leading, .Top, .Bottom, .Trailing])
someUIView.addSubview(subview: someOtherView, constrain: .Leading, .Top, .Bottom, .Trailing)
public let isIpad = UIDevice.currentDevice().userInterfaceIdiom == .Pad
0 swift 0x000000010f93d76b llvm::sys::PrintStackTrace(llvm::raw_ostream&) + 43 1 swift 0x000000010f93ca56 llvm::sys::RunSignalHandlers() + 70 2 swift 0x000000010f93ddbf SignalHandler(int) + 287 3 libsystem_platform.dylib 0x00007fffb24aabba _sigtramp + 26 4 libsystem_platform.dylib 0x00007fbbfff49ae0 _sigtramp + 1302982464 5 swift 0x000000010db79996 (anonymous namespace)::Traversal::visit(swift::Expr*) + 118 6 swift 0x000000010db7b880 (anonymous namespace)::Traversal::visitApplyExpr(swift::ApplyExpr*) + 128 7 swift 0x000000010db799eb (anonymous namespace)::Traversal::visit(swift::Expr*) + 203 8 swift 0x000000010db78f45 swift::Expr::walk(swift::ASTWalker&) + 53 9 swift 0x000000010d6d2c87 walkForProfiling(swift::AbstractFunctionDecl*, swift::ASTWalker&) + 231 10 swift 0x000000010d6d2719 swift::Lowering::SILGenProfiling::assignRegionCounters(swift::AbstractFunctionDecl*) + 553 11 swift 0x000000010d6de348 (anonymous namespace)::SILGenType::emitType() + 952 12 swift 0x000000010d6ddf1e swift::Lowering::SILGenModule::visitNominalTypeDecl(swift::NominalTypeDecl*) + 30 13 swift 0x000000010d6625eb swift::Lowering::SILGenModule::emitSourceFile(swift::SourceFile*, unsigned int) + 731 14 swift 0x000000010d663139 swift::SILModule::constructSIL(swift::ModuleDecl*, swift::SILOptions&, swift::FileUnit*, llvm::Optional<unsigned int>, bool, bool) + 793 15 swift 0x000000010d6635a3 swift::performSILGeneration(swift::FileUnit&, swift::SILOptions&, llvm::Optional<unsigned int>, bool) + 115 16 swift 0x000000010d491c18 performCompile(swift::CompilerInstance&, swift::CompilerInvocation&, llvm::ArrayRef<char const*>, int&) + 12536 17 swift 0x000000010d48dc79 frontend_main(llvm::ArrayRef<char const*>, char const*, void*) + 2777 18 swift 0x000000010d489765 main + 1957 19 libdyld.dylib 0x00007fffb229e255 start + 1
let statusCode = 204 if statusCode in 200 ..< 299 { NSLog("Success") }
switch statusCode { case 200 ... 299: print("success") default: print("failure") }
if case 200 ... 299 = statusCode { print("success") }
if (200 ... 299).contains(statusCode) { print("Success") }
let i = 401 if 400..<500 ~= i, i != 401 { print("yes") } else { print("NO") }
var now = NSDate() var formatter = NSDateFormatter() formatter.dateFormat = "yyyy-MM-dd formatter.timeZone = NSTimeZone(forSecondsFromGMT: 0) println(formatter.stringFromDate(now))
extension ISO8601DateFormatter { convenience init(_ formatOptions: Options, timeZone: TimeZone? = nil) { self.init() self.formatOptions = formatOptions self.timeZone = timeZone ?? TimeZone(secondsFromGMT: 0) } }
extension Formatter { struct Date { static let iso8601 = ISO8601DateFormatter([.withInternetDateTime, .withFractionalSeconds]) } }
extension Formatter { struct Date { static let iso8601: DateFormatter = { let formatter = DateFormatter() formatter.calendar = Calendar(identifier: .iso8601) formatter.locale = Locale(identifier: "en_US_POSIX") formatter.timeZone = TimeZone(secondsFromGMT: 0) formatter.dateFormat = "yyyy-MM-dd return formatter }() } }
extension Date { var iso8601: String { return Formatter.Date.iso8601.string(from: self) } } extension String { var iso8601: Date? { return Formatter.Date.iso8601.date(from: self) } }
let dateString = Date().iso8601 if let date = dateString.iso8601 { print(date.iso8601) }
let date = Date() let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd formatter.timeZone = TimeZone(secondsFromGMT: 0) formatter.locale = Locale(identifier: "en_US_POSIX") print(formatter.string(from: date))
let date = Date() let formatter = ISO8601DateFormatter() formatter.formatOptions.insert(.withFractionalSeconds) print(formatter.string(from: date))
extension Date { init(dateString:String) { self = Date.iso8601Formatter.date(from: dateString)! } static let iso8601Formatter: ISO8601DateFormatter = { let formatter = ISO8601DateFormatter() formatter.formatOptions = [.withFullDate, .withTime, .withDashSeparatorInDate, .withColonSeparatorInTime] return formatter }() }
extension Date { struct Formatter { static let iso8601: DateFormatter = { let formatter = DateFormatter() formatter.calendar = Calendar(identifier: .iso8601) formatter.locale = Locale(identifier: "en_US_POSIX") formatter.timeZone = TimeZone(identifier: "UTC") formatter.dateFormat = "yyyy-MM-dd return formatter }() } var iso8601: String { var formatted = DateFormatter.iso8601.string(from: self) if let fractionStart = formatted.range(of: "."), let fractionEnd = formatted.index(fractionStart.lowerBound, offsetBy: 7, limitedBy: formatted.endIndex) { let fractionRange = fractionStart.lowerBound..<fractionEnd let microseconds = self.timeIntervalSince1970 - floor(self.timeIntervalSince1970) var microsecondsStr = String(format: "%.06f", microseconds) microsecondsStr.remove(at: microsecondsStr.startIndex) formatted.replaceSubrange(fractionRange, with: microsecondsStr) } return formatted } } extension String { var dateFromISO8601: Date? { guard let parsedDate = Date.Formatter.iso8601.date(from: self) else { return nil } var preliminaryDate = Date(timeIntervalSinceReferenceDate: floor(parsedDate.timeIntervalSinceReferenceDate)) if let fractionStart = self.range(of: "."), let fractionEnd = self.index(fractionStart.lowerBound, offsetBy: 7, limitedBy: self.endIndex) { let fractionRange = fractionStart.lowerBound..<fractionEnd let fractionStr = self.substring(with: fractionRange) if var fraction = Double(fractionStr) { fraction = Double(floor(1000000*fraction)/1000000) preliminaryDate.addTimeInterval(fraction) } } return preliminaryDate } }
class AppDelegate: UIResponder, UIApplicationDelegate { internal static let rfc3339DateFormat = "yyyy-MM-dd internal static let localeEnUsPosix = "en_US_POSIX" } import Foundation protocol DateFormatProtocol { func format(date: NSDate) -> String func parse(date: String) -> NSDate? } import Foundation class DateFormat: DateFormatProtocol { func format(date: NSDate) -> String { return date.rfc3339 } func parse(date: String) -> NSDate? { return date.rfc3339 } } extension NSDate { struct Formatter { static let rfc3339: NSDateFormatter = { let formatter = NSDateFormatter() formatter.calendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierISO8601) formatter.locale = NSLocale(localeIdentifier: AppDelegate.localeEnUsPosix) formatter.timeZone = NSTimeZone(forSecondsFromGMT: 0) formatter.dateFormat = rfc3339DateFormat return formatter }() } var rfc3339: String { return Formatter.rfc3339.stringFromDate(self) } } extension String { var rfc3339: NSDate? { return NSDate.Formatter.rfc3339.dateFromString(self) } } class DependencyService: DependencyServiceProtocol { private var dateFormat: DateFormatProtocol? func setDateFormat(dateFormat: DateFormatProtocol) { self.dateFormat = dateFormat } func getDateFormat() -> DateFormatProtocol { if let dateFormatObject = dateFormat { return dateFormatObject } else { let dateFormatObject = DateFormat() dateFormat = dateFormatObject return dateFormatObject } } }
extension Date { var iso8601: String { if return ISO8601DateFormatter.string(from: self, timeZone: TimeZone.current, formatOptions: .withInternetDateTime) } else { var buffer = [CChar](repeating: 0, count: 25) var time = time_t(self.timeIntervalSince1970) strftime_l(&buffer, buffer.count, "%FT%T%z", localtime(&time), nil) return String(cString: buffer) } } }
if let lastUpdated : String = userObject.lastUpdated { let epocTime = NSTimeInterval(lastUpdated)! / 1000 let unixTimestamp = NSDate(timeIntervalSince1970: epocTime) let dateFormatter = NSDateFormatter() dateFormatter.timeZone = NSTimeZone() dateFormatter.locale = NSLocale.currentLocale() dateFormatter.dateFormat = "yyyy-MM-dd dateFormatter.dateFromString(String(unixTimestamp)) let updatedTimeStamp = unixTimestamp print(updatedTimeStamp) }
protocol DateFormatterProtocol { func string(from date: Date) -> String func date(from string: String) -> Date? } extension DateFormatter: DateFormatterProtocol {} @available(iOS 10.0, *) extension ISO8601DateFormatter: DateFormatterProtocol {} struct DateFormatterShared { static let iso8601: DateFormatterProtocol = { if return ISO8601DateFormatter() } else { let formatter = DateFormatter() formatter.calendar = Calendar(identifier: .iso8601) formatter.locale = Locale(identifier: "en_US_POSIX") formatter.timeZone = TimeZone(secondsFromGMT: 0) formatter.dateFormat = "yyyy-MM-dd return formatter } }() }
extension Date { struct Formatter { static let iso8601: DateFormatter = { let formatter = DateFormatter() formatter.calendar = Calendar(identifier: .iso8601) formatter.locale = Locale(identifier: "en_US_POSIX") formatter.timeZone = TimeZone(secondsFromGMT: 0) formatter.dateFormat = "yyyy-MM-dd return formatter }() } var iso8601: String { return Formatter.iso8601.string(from: self) } } extension String { var dateFromISO8601: Date? { var data = self if self.range(of: ".") == nil { data = data.replacingOccurrences(of: "Z", with: ".000000Z") } return Date.Formatter.iso8601.date(from: data) } } extension NSString { var dateFromISO8601: Date? { return (self as String).dateFromISO8601 } }
import Foundation struct DateISO: Codable { var date: Date } extension Date{ var isoString: String { let encoder = JSONEncoder() encoder.dateEncodingStrategy = .iso8601 guard let data = try? encoder.encode(DateISO(date: self)), let json = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: String] else { return "" } return json?.first?.value ?? "" } } let dateString = Date().isoString
func deleteAccountDetail(){ let entityDescription = NSEntityDescription.entityForName("AccountDetail", inManagedObjectContext: Context!) let request = NSFetchRequest() request.entity = entityDescription let fetchedEntities = self.Context!.executeFetchRequest(request) as! [AccountDetail] for entity in fetchedEntities { self.Context!.deleteObject(entity) } do { try self.Context!.save() } catch _ { } }
func deleteAccountDetail() { let entityDescription = NSEntityDescription.entityForName("AccountDetail", inManagedObjectContext: Context!) let request = NSFetchRequest() request.entity = entityDescription do { let fetchedEntities = try self.Context!.executeFetchRequest(request) as! [AccountDetail] for entity in fetchedEntities { self.Context!.deleteObject(entity) } try self.Context!.save() } catch { print(error) } }
func deleteAccountDetail() throws { let entityDescription = NSEntityDescription.entityForName("AccountDetail", inManagedObjectContext: Context!) let request = NSFetchRequest() request.entity = entityDescription let fetchedEntities = try Context.executeFetchRequest(request) as! [AccountDetail] for entity in fetchedEntities { self.Context!.deleteObject(entity) } try self.Context!.save() }
func willOnlyThrowIfTrue(value: Bool) throws { if value { throw someError } }
func foo(value: Bool) throws { try willOnlyThrowIfTrue(value) }
func baz(value: Bool) throws { var filePath = NSBundle.mainBundle().pathForResource("theFile", ofType:"txt") var data = NSData(contentsOfFile:filePath) try willOnlyThrowIfTrue(value) }
func qux(value: Bool) throws { defer { print("this code runs when the function exits, even when it exits by an exception") } try willOnlyThrowIfTrue(value) }
func quux(value: Bool) { do { try willOnlyThrowIfTrue(value) } catch { } }
do { try someFunctionThatThowsDifferentExceptions() } catch MyErrorType.errorA { } catch MyErrorType.errorB { } catch { }
for index in stride(from: 5, to: 1, by: -1) { print(index) } for index in stride(from: 5, through: 1, by: -1) { print(index) }
var count = 0 for i in lazy(1...1_000_000_000_000).reverse() { if ++count > 5 { break } println(i) }
var count = 0 for i in (1...1_000_000_000_000).reverse() { count += 1 if count > 5 { break } print(i) }
let animals = ["horse", "cow", "camel", "sheep", "goat"]
let animals = ["horse", "cow", "camel", "sheep", "goat"]
for (index, animal) in animals.enumerated() { print("\(index), \(animal)") }
for (index, animal) in animals.enumerated().reversed() { print("\(index), \(animal)") }
startIndex.stride(to: endIndex, by: incrementSize) startIndex.stride(through: endIndex, by: incrementSize)
for index in stride(from: 0, to: 5, by: 1) { print(index) }
for index in stride(from: 4, through: 0, by: -1) { print(index) }
let animals = ["horse", "cow", "camel", "sheep", "goat"]
for index in stride(from: 0, to: 5, by: 2) { print("\(index), \(animals[index])") }
for index in stride(from: 4, through: 0, by: -1) { print("\(index), \(animals[index])") }
for i in stride(from: 5, to: 0, by: -1) { print(i) } for i in stride(from: 5, through: 0, by: -1) { print(i) }
func reversed() -> ReversedRandomAccessCollection<CountableClosedRange<Bound>>
let reversedRandomAccessCollection = (0 ... 5).reversed() for index in reversedRandomAccessCollection { print(index) }
func reversed() -> ReversedRandomAccessCollection<CountableRange<Bound>>
let reversedRandomAccessCollection = (0 ..< 6).reversed() for index in reversedRandomAccessCollection { print(index) }
func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>
let unfoldSequence = sequence(first: 5, next: { $0 > 0 ? $0 - 1 : nil }) for index in unfoldSequence { print(index) }
func stride<T>(from start: T, through end: T, by stride: T.Stride) -> StrideThrough<T> where T : Strideable
let sequence = stride(from: 5, through: 0, by: -1) for index in sequence { print(index) }
func stride<T>(from start: T, to end: T, by stride: T.Stride) -> StrideTo<T> where T : Strideable
let sequence = stride(from: 5, to: -1, by: -1) for index in sequence { print(index) }
init<I>(_ base: I) where I : IteratorProtocol, I.Element == Element
var index = 5 guard index >= 0 else { fatalError("index must be positive or equal to zero") } let iterator = AnyIterator<Int>({ defer { index = index - 1 } return index >= 0 ? index : nil }) for index in iterator { print(index) }
var index = 5 guard index >= 0 else { fatalError("index must be positive or equal to zero") } let iterator = AnyIterator({ () -> Int? in defer { index = index - 1 } return index >= 0 ? index : nil }) for index in iterator { print(index) }
extension Int { func iterateDownTo(_ endIndex: Int) -> AnyIterator<Int> { var index = self guard index >= endIndex else { fatalError("self must be greater than or equal to endIndex") } let iterator = AnyIterator { () -> Int? in defer { index = index - 1 } return index >= endIndex ? index : nil } return iterator } } let iterator = 5.iterateDownTo(0) for index in iterator { print(index) }
let count = 50 for i in (1...count).reversed() { print(i) }
for i in stride(from: 5, to: 0, by: -1) { print(i) }
for i in stride(from: 5, through: 0, by: -1) { print(i) }
for (index,number) in (0...10).enumerate() { print("index \(index) , number \(number)") } for (index,number) in (0...10).reverse().enumerate() { print("index \(index) , number \(number)") }
index 0 , number 0 index 1 , number 1 index 2 , number 2 index 3 , number 3 index 4 , number 4 index 5 , number 5 index 6 , number 6 index 7 , number 7 index 8 , number 8 index 9 , number 9 index 10 , number 10 index 0 , number 10 index 1 , number 9 index 2 , number 8 index 3 , number 7 index 4 , number 6 index 5 , number 5 index 6 , number 4 index 7 , number 3 index 8 , number 2 index 9 , number 1 index 10 , number 0
var sum1 = 0 for i in 0...100{ sum1 += i } print (sum1) for i in (10...100).reverse(){ sum1 /= i } print(sum1)
UIApplication.sharedApplication().keyWindow?.rootViewController?.presentViewController(vc, animated: true, completion: nil)
if var topController = UIApplication.sharedApplication().keyWindow?.rootViewController { while let presentedViewController = topController.presentedViewController { topController = presentedViewController } }
if var topController = UIApplication.shared.keyWindow?.rootViewController { while let presentedViewController = topController.presentedViewController { topController = presentedViewController } }
extension UIApplication { class func topViewController(controller: UIViewController? = UIApplication.sharedApplication().keyWindow?.rootViewController) -> UIViewController? { if let navigationController = controller as? UINavigationController { return topViewController(navigationController.visibleViewController) } if let tabController = controller as? UITabBarController { if let selected = tabController.selectedViewController { return topViewController(selected) } } if let presented = controller?.presentedViewController { return topViewController(presented) } return controller } }
extension UIApplication { class func topViewController(controller: UIViewController? = UIApplication.shared.keyWindow?.rootViewController) -> UIViewController? { if let navigationController = controller as? UINavigationController { return topViewController(controller: navigationController.visibleViewController) } if let tabController = controller as? UITabBarController { if let selected = tabController.selectedViewController { return topViewController(controller: selected) } } if let presented = controller?.presentedViewController { return topViewController(controller: presented) } return controller } }
if let topController = UIApplication.topViewController() { }
extension UIWindow { func visibleViewController() -> UIViewController? { if let rootViewController: UIViewController = self.rootViewController { return UIWindow.getVisibleViewControllerFrom(vc: rootViewController) } return nil } static func getVisibleViewControllerFrom(vc:UIViewController) -> UIViewController { if let navigationController = vc as? UINavigationController, let visibleController = navigationController.visibleViewController { return UIWindow.getVisibleViewControllerFrom( vc: visibleController ) } else if let tabBarController = vc as? UITabBarController, let selectedTabController = tabBarController.selectedViewController { return UIWindow.getVisibleViewControllerFrom(vc: selectedTabController ) } else { if let presentedViewController = vc.presentedViewController { return UIWindow.getVisibleViewControllerFrom(vc: presentedViewController) } else { return vc } } } }
if let topController = window.visibleViewController() { println(topController) }
extension UIApplication { class func getTopMostViewController(base: UIViewController? = UIApplication.shared.keyWindow?.rootViewController) -> UIViewController? { if let nav = base as? UINavigationController { return getTopMostViewController(base: nav.visibleViewController) } if let tab = base as? UITabBarController { if let selected = tab.selectedViewController { return getTopMostViewController(base: selected) } } if let presented = base?.presentedViewController { return getTopMostViewController(base: presented) } return base } }
if let topVC = UIApplication.getTopMostViewController() { topVC.view.addSubview(forgotPwdView) }
- (UIViewController *) topViewController { UIViewController *baseVC = UIApplication.sharedApplication.keyWindow.rootViewController; if ([baseVC isKindOfClass:[UINavigationController class]]) { return ((UINavigationController *)baseVC).visibleViewController; } if ([baseVC isKindOfClass:[UITabBarController class]]) { UIViewController *selectedTVC = ((UITabBarController*)baseVC).selectedViewController; if (selectedTVC) { return selectedTVC; } } if (baseVC.presentedViewController) { return baseVC.presentedViewController; } return baseVC; }
extension UIViewController { func topMostViewController() -> UIViewController { if let presented = self.presentedViewController { return presented.topMostViewController() } if let navigation = self as? UINavigationController { return navigation.visibleViewController?.topMostViewController() ?? navigation } if let tab = self as? UITabBarController { return tab.selectedViewController?.topMostViewController() ?? tab } return self } } extension UIApplication { func topMostViewController() -> UIViewController? { return self.keyWindow?.rootViewController?.topMostViewController() } }
extension UIApplication { class func topViewController(base: UIViewController? = UIApplication.shared.keyWindow?.rootViewController) -> UIViewController? { if let nav = base as? UINavigationController { return topViewController(base: nav.visibleViewController) } if let tab = base as? UITabBarController { if let selected = tab.selectedViewController { return topViewController(base: selected) } } if let presented = base?.presentedViewController { return topViewController(base: presented) } return base } }
if let topController = UIApplication.topViewController() { print("The view controller you }
func getTopViewController() -> UIViewController? { var topController: UIViewController? = UIApplication.shared.keyWindow?.rootViewController while topController?.presentedViewController != nil { topController = topController?.presentedViewController } return topController }
override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) let appDel = UIApplication.sharedApplication().delegate as! AppDelegate appDel.currentVC = self }
extension UIWindow { func visibleViewController() -> UIViewController? { if let rootViewController: UIViewController = self.rootViewController { return UIWindow.getVisibleViewControllerFrom(vc: rootViewController) } return nil } class func getVisibleViewControllerFrom(vc:UIViewController) -> UIViewController { if vc.isKind(of: UINavigationController.self) { let navigationController = vc as! UINavigationController return UIWindow.getVisibleViewControllerFrom( vc: navigationController.visibleViewController!) } else if vc.isKind(of: UITabBarController.self) { let tabBarController = vc as! UITabBarController return UIWindow.getVisibleViewControllerFrom(vc: tabBarController.selectedViewController!) } else { if let presentedViewController = vc.presentedViewController { return UIWindow.getVisibleViewControllerFrom(vc: presentedViewController) } else { return vc; } } } }
extension UIViewController { var topMostViewController : UIViewController { if let presented = self.presentedViewController { return presented.topMostViewController } if let navigation = self as? UINavigationController { return navigation.visibleViewController?.topMostViewController ?? navigation } if let tab = self as? UITabBarController { return tab.selectedViewController?.topMostViewController ?? tab } return self } } extension UIApplication { var topMostViewController : UIViewController? { return self.keyWindow?.rootViewController?.topMostViewController } }
If let topViewControler = UIApplication.shared.topMostViewController { ... do stuff }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
if let viewControllers = window?.rootViewController?.childViewControllers { let prefs = UserDefaults.standard if viewControllers[viewControllers.count - 1] is ABCController{ print("[ABCController] is visible") } }
import UIKit class MyCollectionViewCell: UICollectionViewCell { @IBOutlet weak var myLabel: UILabel! }
import UIKit class ViewController: UIViewController, UICollectionViewDataSource, UICollectionViewDelegate { let reuseIdentifier = "cell" var items = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48"] func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { return self.items.count } func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell { let cell = collectionView.dequeueReusableCell(withReuseIdentifier: reuseIdentifier, for: indexPath as IndexPath) as! MyCollectionViewCell cell.myLabel.text = self.items[indexPath.item] cell.backgroundColor = UIColor.cyan return cell } func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) { print("You selected cell } }
cell.layer.borderColor = UIColor.black.cgColor cell.layer.borderWidth = 1 cell.layer.cornerRadius = 8
func collectionView(_ collectionView: UICollectionView, didHighlightItemAt indexPath: IndexPath) { let cell = collectionView.cellForItem(at: indexPath) cell?.backgroundColor = UIColor.red } func collectionView(_ collectionView: UICollectionView, didUnhighlightItemAt indexPath: IndexPath) { let cell = collectionView.cellForItem(at: indexPath) cell?.backgroundColor = UIColor.cyan }
override func numberOfSectionsInCollectionView(collectionView: UICollectionView) -> Int { return 1 } override func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { return 10 } override func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -> UICollectionViewCell { let cell = collectionView.dequeueReusableCellWithReuseIdentifier("collectionCell", forIndexPath: indexPath) configureCell(cell, forItemAtIndexPath: indexPath) return cell } func configureCell(cell: UICollectionViewCell, forItemAtIndexPath: NSIndexPath) { cell.backgroundColor = UIColor.blackColor() } override func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -> UICollectionReusableView { let view = collectionView.dequeueReusableSupplementaryViewOfKind(UICollectionElementKindSectionHeader, withReuseIdentifier: "collectionCell", forIndexPath: indexPath) as UICollectionReusableView return view } override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) { } override func collectionView(collectionView: UICollectionView, didDeselectItemAtIndexPath indexPath: NSIndexPath) { }
func numberOfSectionsInCollectionView(collectionView: UICollectionView) -> Int { return 1 } func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { return 10 } func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -> UICollectionViewCell { let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "collectionCell", for: indexPath as IndexPath) configureCell(cell: cell, forItemAtIndexPath: indexPath) return cell } func configureCell(cell: UICollectionViewCell, forItemAtIndexPath: NSIndexPath) { cell.backgroundColor = UIColor.black } func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -> UICollectionReusableView { let view = collectionView.dequeueReusableSupplementaryView(ofKind: UICollectionElementKindSectionHeader, withReuseIdentifier: "collectionCell", for: indexPath as IndexPath) as UICollectionReusableView return view } func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) { } func collectionView(collectionView: UICollectionView, didDeselectItemAtIndexPath indexPath: NSIndexPath) { }
extension ViewController : UICollectionViewDataSource { func numberOfSections(in collectionView: UICollectionView) -> Int { return 2 } func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { return nameArr.count } func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell { let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "DummyCollectionCell", for: indexPath) as! DummyCollectionCell cell.titleLabel.text = nameArr[indexPath.row] cell.userImageView.backgroundColor = .blue return cell } } extension ViewController : UICollectionViewDelegate { func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) { let alert = UIAlertController(title: "Hi", message: "\(nameArr[indexPath.row])", preferredStyle: .alert) let action = UIAlertAction(title: "OK", style: .default, handler: nil) alert.addAction(action) self.present(alert, animated: true, completion: nil) } }
let mySet = Set(["a", "b", "a"]) let myArray = Array(mySet) print(myArray)
init<S>(_ s: S) where S : Sequence, Element == S.Iterator.Element
let stringSet = Set(arrayLiteral: "car", "boat", "car", "bike", "toy") let stringArray = Array(stringSet) print(stringArray)
let stringSet = Set(["car", "boat", "bike", "toy"]) let stringArray = stringSet.sorted() print(stringArray)
let stringSet = Set(arrayLiteral: "car", "boat", "car", "bike", "toy") let stringArray = stringSet.filter { $0.characters.first != "b" } print(stringArray)
let intSet = Set([1, 3, 5, 2]) let stringArray = intSet.flatMap { String($0) } print(stringArray)
let intSet = Set([1, 3, 5, 2]) let intArray = intSet.map { $0 } print(intArray)
var example:Set = ["a","b","c"] let makeExampleArray = [example.sorted()] makeExampleArray
["a","b","c"] or ["b","c","a",] or ["c","a","b"] or ["a","c","b"] or ["b","a","c"] or ["c","b","a"]
extension Set { var array: [Element] { return Array(self) } }
var itemsArray : [MyObjectType] = [] if let typedSet = myItemSet as? Set<MyObjectType> { itemsArray = typedSet.map { $0 } }
func getArrayFromSet(set:NSSet)-> NSArray { return set.map ({ String($0) }) }
var letters:Set = Set<String>(arrayLiteral: "test","test") print(self.getArrayFromSet(letters))
- (void) viewDidLoad { [super viewDidLoad]; self.navigationItem.hidesBackButton = YES; UIBarButtonItem *newBackButton = [[UIBarButtonItem alloc] initWithTitle:@"Back" style:UIBarButtonItemStyleBordered target:self action:@selector(back:)]; self.navigationItem.leftBarButtonItem = newBackButton; } - (void) back:(UIBarButtonItem *)sender { [self.navigationController popViewControllerAnimated:YES]; }
override func viewDidLoad { super.viewDidLoad() self.navigationItem.hidesBackButton = true let newBackButton = UIBarButtonItem(title: "Back", style: UIBarButtonItemStyle.Bordered, target: self, action: "back:") self.navigationItem.leftBarButtonItem = newBackButton } func back(sender: UIBarButtonItem) { self.navigationController?.popViewControllerAnimated(true) }
override func viewDidLoad { super.viewDidLoad() self.navigationItem.hidesBackButton = true let newBackButton = UIBarButtonItem(title: "Back", style: UIBarButtonItemStyle.plain, target: self, action: self.navigationItem.leftBarButtonItem = newBackButton } func back(sender: UIBarButtonItem) { _ = navigationController?.popViewController(animated: true) }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) if self.isMovingFromParentViewController { } }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) if self.isMovingFromParent { } }
override func willMove(toParentViewController parent: UIViewController?) { super.willMove(toParentViewController: parent) if parent == nil { print("This VC is } }
weak var weakSelf = self navigationItem.leftBarButtonItems = CustomBackButton.createWithText("YourBackButtonTitle", color: UIColor.yourColor(), target: weakSelf, action: navigationItem.leftBarButtonItems = CustomBackButton.createWithImage(UIImage(named: "yourImageName")!, color: UIColor.yourColor(), target: weakSelf, action: func tappedBackButton() { self.navigationController!.popViewControllerAnimated(true) }
class CustomBackButton: NSObject { class func createWithText(text: String, color: UIColor, target: AnyObject?, action: Selector) -> [UIBarButtonItem] { let negativeSpacer = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.FixedSpace, target: nil, action: nil) negativeSpacer.width = -8 let backArrowImage = imageOfBackArrow(color: color) let backArrowButton = UIBarButtonItem(image: backArrowImage, style: UIBarButtonItemStyle.Plain, target: target, action: action) let backTextButton = UIBarButtonItem(title: text, style: UIBarButtonItemStyle.Plain , target: target, action: action) backTextButton.setTitlePositionAdjustment(UIOffset(horizontal: -12.0, vertical: 0.0), forBarMetrics: UIBarMetrics.Default) return [negativeSpacer, backArrowButton, backTextButton] } class func createWithImage(image: UIImage, color: UIColor, target: AnyObject?, action: Selector) -> [UIBarButtonItem] { let negativeSpacer = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.FixedSpace, target: nil, action: nil) negativeSpacer.width = -8 let backArrowImageView = UIImageView(image: imageOfBackArrow(color: color)) let backImageView = UIImageView(image: image) let customBarButton = UIButton(frame: CGRectMake(0,0,22 + backImageView.frame.width,22)) backImageView.frame = CGRectMake(22, 0, backImageView.frame.width, backImageView.frame.height) customBarButton.addSubview(backArrowImageView) customBarButton.addSubview(backImageView) customBarButton.addTarget(target, action: action, forControlEvents: .TouchUpInside) return [negativeSpacer, UIBarButtonItem(customView: customBarButton)] } private class func drawBackArrow(frame frame: CGRect = CGRect(x: 0, y: 0, width: 14, height: 22), color: UIColor = UIColor(hue: 0.59, saturation: 0.674, brightness: 0.886, alpha: 1), resizing: ResizingBehavior = .AspectFit) { let context = UIGraphicsGetCurrentContext()! CGContextSaveGState(context) let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 14, height: 22), target: frame) CGContextTranslateCTM(context, resizedFrame.minX, resizedFrame.minY) let resizedScale = CGSize(width: resizedFrame.width / 14, height: resizedFrame.height / 22) CGContextScaleCTM(context, resizedScale.width, resizedScale.height) let line = UIBezierPath() line.moveToPoint(CGPoint(x: 9, y: 9)) line.addLineToPoint(CGPoint.zero) CGContextSaveGState(context) CGContextTranslateCTM(context, 3, 11) line.lineCapStyle = .Square line.lineWidth = 3 color.setStroke() line.stroke() CGContextRestoreGState(context) let lineCopy = UIBezierPath() lineCopy.moveToPoint(CGPoint(x: 9, y: 0)) lineCopy.addLineToPoint(CGPoint(x: 0, y: 9)) CGContextSaveGState(context) CGContextTranslateCTM(context, 3, 2) lineCopy.lineCapStyle = .Square lineCopy.lineWidth = 3 color.setStroke() lineCopy.stroke() CGContextRestoreGState(context) CGContextRestoreGState(context) } private class func imageOfBackArrow(size size: CGSize = CGSize(width: 14, height: 22), color: UIColor = UIColor(hue: 0.59, saturation: 0.674, brightness: 0.886, alpha: 1), resizing: ResizingBehavior = .AspectFit) -> UIImage { var image: UIImage UIGraphicsBeginImageContextWithOptions(size, false, 0) drawBackArrow(frame: CGRect(origin: CGPoint.zero, size: size), color: color, resizing: resizing) image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } private enum ResizingBehavior { case AspectFit case AspectFill case Stretch case Center func apply(rect rect: CGRect, target: CGRect) -> CGRect { if rect == target || target == CGRect.zero { return rect } var scales = CGSize.zero scales.width = abs(target.width / rect.width) scales.height = abs(target.height / rect.height) switch self { case .AspectFit: scales.width = min(scales.width, scales.height) scales.height = scales.width case .AspectFill: scales.width = max(scales.width, scales.height) scales.height = scales.width case .Stretch: break case .Center: scales.width = 1 scales.height = 1 } var result = rect.standardized result.size.width *= scales.width result.size.height *= scales.height result.origin.x = target.minX + (target.width - result.width) / 2 result.origin.y = target.minY + (target.height - result.height) / 2 return result } } }
class CustomBackButton: NSObject { class func createWithText(text: String, color: UIColor, target: AnyObject?, action: Selector) -> [UIBarButtonItem] { let negativeSpacer = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.fixedSpace, target: nil, action: nil) negativeSpacer.width = -8 let backArrowImage = imageOfBackArrow(color: color) let backArrowButton = UIBarButtonItem(image: backArrowImage, style: UIBarButtonItemStyle.plain, target: target, action: action) let backTextButton = UIBarButtonItem(title: text, style: UIBarButtonItemStyle.plain , target: target, action: action) backTextButton.setTitlePositionAdjustment(UIOffset(horizontal: -12.0, vertical: 0.0), for: UIBarMetrics.default) return [negativeSpacer, backArrowButton, backTextButton] } class func createWithImage(image: UIImage, color: UIColor, target: AnyObject?, action: Selector) -> [UIBarButtonItem] { let negativeSpacer = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.fixedSpace, target: nil, action: nil) negativeSpacer.width = -8 let backArrowImageView = UIImageView(image: imageOfBackArrow(color: color)) let backImageView = UIImageView(image: image) let customBarButton = UIButton(frame: CGRect(x: 0, y: 0, width: 22 + backImageView.frame.width, height: 22)) backImageView.frame = CGRect(x: 22, y: 0, width: backImageView.frame.width, height: backImageView.frame.height) customBarButton.addSubview(backArrowImageView) customBarButton.addSubview(backImageView) customBarButton.addTarget(target, action: action, for: .touchUpInside) return [negativeSpacer, UIBarButtonItem(customView: customBarButton)] } private class func drawBackArrow(_ frame: CGRect = CGRect(x: 0, y: 0, width: 14, height: 22), color: UIColor = UIColor(hue: 0.59, saturation: 0.674, brightness: 0.886, alpha: 1), resizing: ResizingBehavior = .AspectFit) { let context = UIGraphicsGetCurrentContext()! context.saveGState() let resizedFrame = resizing.apply(CGRect(x: 0, y: 0, width: 14, height: 22), target: frame) context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY) let resizedScale = CGSize(width: resizedFrame.width / 14, height: resizedFrame.height / 22) context.scaleBy(x: resizedScale.width, y: resizedScale.height) let line = UIBezierPath() line.move(to: CGPoint(x: 9, y: 9)) line.addLine(to: CGPoint.zero) context.saveGState() context.translateBy(x: 3, y: 11) line.lineCapStyle = .square line.lineWidth = 3 color.setStroke() line.stroke() context.restoreGState() let lineCopy = UIBezierPath() lineCopy.move(to: CGPoint(x: 9, y: 0)) lineCopy.addLine(to: CGPoint(x: 0, y: 9)) context.saveGState() context.translateBy(x: 3, y: 2) lineCopy.lineCapStyle = .square lineCopy.lineWidth = 3 color.setStroke() lineCopy.stroke() context.restoreGState() context.restoreGState() } private class func imageOfBackArrow(_ size: CGSize = CGSize(width: 14, height: 22), color: UIColor = UIColor(hue: 0.59, saturation: 0.674, brightness: 0.886, alpha: 1), resizing: ResizingBehavior = .AspectFit) -> UIImage { var image: UIImage UIGraphicsBeginImageContextWithOptions(size, false, 0) drawBackArrow(CGRect(origin: CGPoint.zero, size: size), color: color, resizing: resizing) image = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() return image } private enum ResizingBehavior { case AspectFit case AspectFill case Stretch case Center func apply(_ rect: CGRect, target: CGRect) -> CGRect { if rect == target || target == CGRect.zero { return rect } var scales = CGSize.zero scales.width = abs(target.width / rect.width) scales.height = abs(target.height / rect.height) switch self { case .AspectFit: scales.width = min(scales.width, scales.height) scales.height = scales.width case .AspectFill: scales.width = max(scales.width, scales.height) scales.height = scales.width case .Stretch: break case .Center: scales.width = 1 scales.height = 1 } var result = rect.standardized result.size.width *= scales.width result.size.height *= scales.height result.origin.x = target.minX + (target.width - result.width) / 2 result.origin.y = target.minY + (target.height - result.height) / 2 return result } } }
override func didMoveToParentViewController(parent: UIViewController?) { super.didMoveToParentViewController(parent) if parent == nil { println("Back Button pressed.") delegate?.goingBack() } }
override func didMove(toParent parent: UIViewController?) { super.didMove(toParent: parent) if parent == nil { debugPrint("Back Button pressed.") } }
override func viewDidLoad() { super.viewDidLoad() let customBackButton = UIBarButtonItem(image: UIImage(named: "backArrow") , style: .plain, target: self, action: customBackButton.imageInsets = UIEdgeInsets(top: 2, left: -8, bottom: 0, right: 0) navigationItem.leftBarButtonItem = customBackButton } func backAction(sender: UIBarButtonItem) { navigationController?.popViewController(animated: true) }
class ViewController:UINavigationControllerDelegate { func navigationController(navigationController: UINavigationController, willShowViewController viewController: UIViewController, animated: Bool) { if viewController === self { } } }
class MyViewController: UIViewController, UINavigationControllerDelegate {
class MyViewController: UIViewController, UINavigationControllerDelegate { var previousViewController:UIViewController
override func viewDidLoad() { super.viewDidLoad() self.navigationController?.delegate = self }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == "YourSegueID" { if let nextViewController = segue.destination as? MyViewController { nextViewController.previousViewController = self } } }
func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) { if viewController == self.previousViewController { } }
override func viewDidLoad() { super.viewDidLoad() let imageView = UIImageView() imageView.backgroundColor = UIColor.clear imageView.frame = CGRect(x:0,y:0,width:2*(self.navigationController?.navigationBar.bounds.height)!,height:(self.navigationController?.navigationBar.bounds.height)!) let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: imageView.isUserInteractionEnabled = true imageView.addGestureRecognizer(tapGestureRecognizer) imageView.tag = 1 self.navigationController?.navigationBar.addSubview(imageView) }
func back(sender: UIBarButtonItem) { _ = self.navigationController?.popViewController(animated: true) }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) for view in (self.navigationController?.navigationBar.subviews)!{ if view.tag == 1 { view.removeFromSuperview() } }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) if isMovingFromParentViewController { if let viewControllers = self.navigationController?.viewControllers { if (viewControllers.count >= 1) { let previousViewController = viewControllers[viewControllers.count-1] as! NameOfDestinationViewController previousViewController.callOrModifySomething() } } } }
override func didMove(toParentViewController parent: UIViewController?) { super.didMove(toParentViewController: parent) if parent == nil{ print("Back button was clicked") } }
self.navigationItem.leftBarButtonItem?.target = "methodname" func methodname ( ) { }
let settingArray = NSMutableArray() @IBAction func Back(sender: AnyObject) { self. settingArray.removeAllObjects() self.dismissViewControllerAnimated(true, completion: nil) }
override public func viewDidLoad() { super.viewDidLoad() self.navigationController?.navigationBar.topItem?.title = GlobalVariables.selectedMainIconName let image = UIImage(named: "back-btn") image = image?.imageWithRenderingMode(UIImageRenderingMode.AlwaysOriginal) self.navigationItem.leftBarButtonItem = UIBarButtonItem(image: image, style: UIBarButtonItemStyle.Plain, target: self, action: } func back() { self.navigationController?.popToViewController( self.navigationController!.viewControllers[ self.navigationController!.viewControllers.count - 2 ], animated: true) }
override func viewWillDisappear(animated: Bool) { super.viewWillDisappear(animated) let stack = self.navigationController?.viewControllers.count if stack >= 2 { if let lastitem = self.navigationController?.viewControllers[stack! - 1] as? theViewControllerYoureTryingToAccess { lastitem.emptyArray() lastitem.value = 5 } } }
@IBAction func done(sender: AnyObject) { if((self.presentingViewController) != nil){ self.dismiss(animated: false, completion: nil) print("done") } }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) if self.isMovingFromParent { } }
NSString *str = [NSString stringWithFormat:@"%d , %f, %ld, %@", INT_VALUE, FLOAT_VALUE, DOUBLE_VALUE, STRING_VALUE];
let timeNow = time(nil) let aStr = String(format: "%@%x", "timeNow in hex: ", timeNow) print(aStr)
let str = NSString(format:"%d , %f, %ld, %@", INT_VALUE, FLOAT_VALUE, LONG_VALUE, STRING_VALUE)
let str = "\(INT_VALUE), \(FLOAT_VALUE), \(DOUBLE_VALUE), \(STRING_VALUE)"
String(format: "Value: %3.2f\tResult: %3.2f", arguments: [2.7, 99.8])
String(format:"Value: %3.2f\tResult: %3.2f", 2.7, 99.8)
let str = String(format:"%d, %f, %ld", INT_VALUE, FLOAT_VALUE, DOUBLE_VALUE)
let str = "\(INT_VALUE), \(FLOAT_VALUE), \(DOUBLE_VALUE)"
var str = "\(INT_VALUE) , \(FLOAT_VALUE) , \(DOUBLE_VALUE), \(STRING_VALUE)"
var str = "\(INT_VALUE) , \(FLOAT_VALUE) , \(DOUBLE_VALUE), \(STRING_VALUE)" println(str)
let INT_VALUE=80 let FLOAT_VALUE:Double= 80.9999 let doubleValue=65.0 let DOUBLE_VALUE:Double= 65.56 let STRING_VALUE="Hello" let str = NSString(format:"%d , %f, %ld, %@", INT_VALUE, FLOAT_VALUE, DOUBLE_VALUE, STRING_VALUE); println(str);
public struct StringMaskFormatter { public var pattern : String = "" public var replecementChar : Character = "*" public var allowNumbers : Bool = true public var allowText : Bool = false public init(pattern:String, replecementChar:Character="*", allowNumbers:Bool=true, allowText:Bool=true) { self.pattern = pattern self.replecementChar = replecementChar self.allowNumbers = allowNumbers self.allowText = allowText } private func prepareString(string:String) -> String { var charSet : NSCharacterSet! if allowText && allowNumbers { charSet = NSCharacterSet.alphanumericCharacterSet().invertedSet } else if allowText { charSet = NSCharacterSet.letterCharacterSet().invertedSet } else if allowNumbers { charSet = NSCharacterSet.decimalDigitCharacterSet().invertedSet } let result = string.componentsSeparatedByCharactersInSet(charSet) return result.joinWithSeparator("") } public func createFormattedStringFrom(text:String) -> String { var resultString = "" if text.characters.count > 0 && pattern.characters.count > 0 { var finalText = "" var stop = false let tempString = prepareString(text) var formatIndex = pattern.startIndex var tempIndex = tempString.startIndex while !stop { let formattingPatternRange = formatIndex ..< formatIndex.advancedBy(1) if pattern.substringWithRange(formattingPatternRange) != String(replecementChar) { finalText = finalText.stringByAppendingString(pattern.substringWithRange(formattingPatternRange)) } else if tempString.characters.count > 0 { let pureStringRange = tempIndex ..< tempIndex.advancedBy(1) finalText = finalText.stringByAppendingString(tempString.substringWithRange(pureStringRange)) tempIndex = tempIndex.advancedBy(1) } formatIndex = formatIndex.advancedBy(1) if formatIndex >= pattern.endIndex || tempIndex >= tempString.endIndex { stop = true } resultString = finalText } } return resultString } }
let intVal=56 let floatval:Double=56.897898 let doubleValue=89.0 let explicitDaouble:Double=89.56 let stringValue:"Hello" let stringValue="String:\(stringValue) Integer:\(intVal) Float:\(floatval) Double:\(doubleValue) ExplicitDouble:\(explicitDaouble) "
var number = 31.726354765 var intNumber = Int(number * 1000.0) var roundedNumber = Double(intNumber) / 1000.0
var letters:NSString = "abcdefghijkl" var strRendom = NSMutableString.stringWithCapacity(strlength) for var i=0; i<strlength; i++ { let rndString = Int(arc4random() % 12) let strlk = NSString(format: "%c", letters.characterAtIndex(rndString)) strRendom.appendString(String(strlk)) }
@implementation MyClass - (NSString *)description { return [NSString stringWithFormat:@"<%@: %p, foo = %@>", [self class], foo _foo]; } @end
1> class MyClass { let foo = 42 } 2> 3> let x = MyClass() x: MyClass = { foo = 42 }
4> println("x = \(x)") x = C11lldb_expr_07MyClass (has 1 child)
protocol Printable { var description: String { get } }
1> class MyClass: Printable { 2. let foo = 42 3. var description: String { get { return "MyClass, foo = \(foo)" } } 4. } 5> 6> let x = MyClass() x: MyClass = { foo = 42 } 7> println("x = \(x)") x = C11lldb_expr_07MyClass (has 1 child)
8> println("x = \(x.description)") x = MyClass, foo = 42
class MyClass: CustomStringConvertible { let foo = 42 var description: String { return "<\(type(of: self)): foo = \(foo)>" } } print(MyClass())
import UIKit class PageContentViewController: UIViewController { var pageIndex : Int = 0 override var description : String { return "**** PageContentViewController\npageIndex equals \(pageIndex) ****\n" } override var debugDescription : String { return "---- PageContentViewController\npageIndex equals \(pageIndex) ----\n" } ... }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let myPageContentViewController = self.storyboard!.instantiateViewControllerWithIdentifier("A") as! PageContentViewController print(myPageContentViewController) print(myPageContentViewController.description) print(myPageContentViewController.debugDescription) } ... }
**** PageContentViewController pageIndex equals 0 **** **** PageContentViewController pageIndex equals 0 **** ---- PageContentViewController pageIndex equals 0 ----
class MyClass: CustomStringConvertible { var string: String? var description: String { return "\(self.dynamicType)" } } var myClass = MyClass() print("\(myClass)") var description: String { return "\(type(of: self))" }
class foo { var bar = "Humbug!" } extension foo: CustomStringConvertible { var description: String { return bar } } let xmas = foo() print(xmas)
class SomeBaseClass: CustomStringConvertible { var description: String { return "\(self.dynamicType)" } var description: String { return "\(type(of: self))" } } class SomeSubClass: SomeBaseClass { } var mySomeBaseClass = SomeBaseClass() var mySomeSubClass = SomeSubClass() var myOtherBaseClass = SomeSubClass()
struct WorldPeace: CustomStringConvertible { let yearStart: Int let yearStop: Int var description: String { return "\(yearStart)-\(yearStop)" } } let wp = WorldPeace(yearStart: 2020, yearStop: 2040) print("world peace: \(wp)")
extension CustomStringConvertible { var description : String { var description: String = "\(type(of: self)){ " let selfMirror = Mirror(reflecting: self) for child in selfMirror.children { if let propertyName = child.label { description += "\(propertyName): \(child.value), " } } description = String(description.dropLast(2)) description += " }" return description } }
let trimmedString = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())
let trimmedString = string.trimmingCharacters(in: .whitespaces)
extension String { var stringByRemovingWhitespaces: String { let components = componentsSeparatedByCharactersInSet(.whitespaceCharacterSet()) return components.joinWithSeparator("") } }
extension String { func removingWhitespaces() -> String { return components(separatedBy: .whitespaces).joined() } }
extension String { func removingLeadingSpaces() -> String { guard let index = firstIndex(where: { !CharacterSet(charactersIn: String($0)).isSubset(of: .whitespaces) }) else { return self } return String(self[index...]) } }
extension String { func replace(string:String, replacement:String) -> String { return self.replacingOccurrences(of: string, with: replacement, options: NSString.CompareOptions.literal, range: nil) } func removeWhitespace() -> String { return self.replace(string: " ", replacement: "") } }
let string = "The quick brown dog jumps over the foxy lady." let result = string.removeWhitespace()
let myString = " Hello World ! " let formattedString = myString.replacingOccurrences(of: " ", with: "")
let trimmedString = myString.stringByReplacingOccurrencesOfString("\\s", withString: "", options: NSStringCompareOptions.RegularExpressionSearch, range: nil)
myString.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())
myString.stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString: "<>"))
myString.stringByReplacingOccurrencesOfString(" ", withString: "")
myString.stringByReplacingOccurrencesOfString(" ", withString: "").stringByReplacingOccurrencesOfString(",", withString: "")
("\(myNSDataBlob)").stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString: "<>")).stringByReplacingOccurrencesOfString(" ", withString: "")
import Foundation var str = " Hear me calling" extension String { var stringByRemovingWhitespaces: String { return components(separatedBy: .whitespaces).joined() } } str.stringByRemovingWhitespaces
extension String { func filter(pred: Character -> Bool) -> String { var res = String() for c in self.characters { if pred(c) { res.append(c) } } return res } } "this is a String".filter { $0 != Character(" ") }
let dirtyString = " First Word " let cleanString = dirtyString.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())
" this is wrong contained teee xt" .replacingOccurrences(of: "^\\s|\\s+|\\s$", with: "", options: .regularExpression)
let updatedString = searchedText?.stringByReplacingOccurrencesOfString(" ", withString: "-")
func trim() -> String { return self.trimmingCharacters(in: CharacterSet.whitespaces) } func trimWhiteSpaceAndNewLine() -> String { return self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) }
extension String { func whiteSpacesRemoved() -> String { return self.filter { $0 != Character(" ") } } }
extension String { var removingWhitespaceAndNewLines: String { return removing(.whitespacesAndNewlines) } func removing(_ forbiddenCharacters: CharacterSet) -> String { return String(unicodeScalars.filter({ !forbiddenCharacters.contains($0) })) } }
func removeSpace(_ string: String) -> String{ var str: String = String(string[string.startIndex]) for (index,value) in string.enumerated(){ if index > 0{ let indexBefore = string.index(before: String.Index.init(encodedOffset: index)) if value == " " && string[indexBefore] == " "{ }else{ str.append(value) } } } return str }
"This is the demo text remove extra space between the words."
let strFirstName = txtFirstName.text?.trimmingCharacters(in: CharacterSet.whitespaces)
extension String { func replace(_ string:String, replacement:String) -> String { return self.replacingOccurrences(of: string, with: replacement, options: NSString.CompareOptions.literal, range: nil) } func removeWhitespace() -> String { return self.replace(" ", replacement: "") } }
let space_removed_string = (yourstring?.components(separatedBy: " ").joined(separator: ""))!
let url = URL(string: "http: var request = URLRequest(url: url) request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type") request.httpMethod = "POST" let postString = "id=13&name=Jack" request.httpBody = postString.data(using: .utf8) let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, error == nil else { print("error=\(error)") return } if let httpStatus = response as? HTTPURLResponse, httpStatus.statusCode != 200 { print("statusCode should be 200, but is \(httpStatus.statusCode)") print("response = \(response)") } let responseString = String(data: data, encoding: .utf8) print("responseString = \(responseString)") } task.resume()
@IBAction func submitAction(sender: UIButton) { let parameters = ["id": 13, "name": "jack"] let url = URL(string: "www.thisismylink.com/postName.php")! let session = URLSession.shared var request = URLRequest(url: url) request.httpMethod = "POST" do { request.httpBody = try JSONSerialization.data(withJSONObject: parameters, options: .prettyPrinted) } catch let error { print(error.localizedDescription) } request.addValue("application/json", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") let task = session.dataTask(with: request as URLRequest, completionHandler: { data, response, error in guard error == nil else { return } guard let data = data else { return } do { if let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any] { print(json) } } catch let error { print(error.localizedDescription) } }) task.resume() }
var url = NSURL(string: urlstring) var request = NSMutableURLRequest(URL: url!) request.HTTPMethod = "POST" request.setValue("application/x-www-form-urlencoded; charset=utf-8", forHTTPHeaderField: "Content-Type") request.HTTPBody = postData.dataUsingEncoding(NSUTF8StringEncoding) var connection = NSURLConnection(request: request, delegate: nil, startImmediately: true)
@IBAction func btn_LogIn(sender: AnyObject) { let request = NSMutableURLRequest(URL: NSURL(string: "http: request.HTTPMethod = "POST" let postString = "email: test@test.com & password: testtest" request.HTTPBody = postString.dataUsingEncoding(NSUTF8StringEncoding) let task = NSURLSession.sharedSession().dataTaskWithRequest(request){data, response, error in guard error == nil && data != nil else{ print("error") return } if let httpStatus = response as? NSHTTPURLResponse where httpStatus.statusCode != 200{ print("statusCode should be 200, but is \(httpStatus.statusCode)") print("response = \(response)") } let responseString = String(data: data!, encoding: NSUTF8StringEncoding) print("responseString = \(responseString)") } task.resume() }
let session = URLSession.shared let url = "http: let request = NSMutableURLRequest(url: NSURL(string: url)! as URL) request.httpMethod = "POST" request.addValue("application/json", forHTTPHeaderField: "Content-Type") var params :[String: Any]? params = ["Some_ID" : "111", "REQUEST" : "SOME_API_NAME"] do{ request.httpBody = try JSONSerialization.data(withJSONObject: params, options: JSONSerialization.WritingOptions()) let task = session.dataTask(with: request as URLRequest as URLRequest, completionHandler: {(data, response, error) in if let response = response { let nsHTTPResponse = response as! HTTPURLResponse let statusCode = nsHTTPResponse.statusCode print ("status code = \(statusCode)") } if let error = error { print ("\(error)") } if let data = data { do{ let jsonResponse = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions()) print ("data = \(jsonResponse)") }catch _ { print ("OOps not good JSON formatted response") } } }) task.resume() }catch _ { print ("Oops something happened buddy") }
import XCTest import PrimeNumberModel class PrimeNumberModelTests: XCTestCase { let testObject = PrimeNumberModel() }
import XCTest @testable import MyProject class PrimeNumberModelTests: XCTestCase { let testObject = PrimeNumberModel() }
import Foundation class PrimeNumberModel { init() { } }
import XCTest import MyProject class PrimeNumberModelTests: XCTestCase { let testObject = PrimeNumberModel() }
import Foundation public class PrimeNumberModel { public init() { } }
class SomeClass : NSObject { } class OtherClass : NSObject { let object = SomeClass() }
import XCTest class HHASettings_Tests: XCTestCase { override func setUp() { let x : SettingsTableViewController = SettingsTableViewController() super.setUp() } override func tearDown() { super.tearDown() } func testExample() { XCTAssert(true, "Pass") } func testPerformanceExample() { self.measureBlock() { } } }
xcrun -sdk macosx swiftc -emit-executable -o PrimeNumberMain PrimeNumberModel.swift PrimeNumberModelTests.swift main.swift
myButton.titleLabel?.font = UIFont(name: YourfontName, size: 20)
button.titleLabel?.font = UIFont.boldSystemFont(ofSize: 16)
myButton.titleLabel!.font = UIFont(name: YourfontName, size: 20)
myButton.titleLabel!.font = UIFont(name: "...", 10)
btn.titleLabel?.font = UIFont(name:"Times New Roman", size: 20)
let attributedText = NSAttributedString(string: "Hello", attributes: [NSAttributedStringKey.font: UIFont(name: "Calibri", size: 19)]) okayButton.setAttributedTitle(attributedText, for: .normal)
button.titleLabel?.font = button.titleLabel?.font.withSize(12)
myButton.titleLabel?.font = UIFont.boldSystemFont(ofSize: 17) myButton.titleLabel?.font = UIFont.italicSystemFont(ofSize:UIFont.smallSystemFontSize) myButton.titleLabel?.font = UIFont.boldSystemFont(ofSize: UIFont.buttonFontSize)
myButton.titleLabel?.font = UIFont(name: "Helvetica", size:12)
btn.titleLabel?.font = UIFont(name: "Helvetica", size:12)
btn.titleLabel?.font = UIFont.init(name: "Helvetica", size:12)
enum SandwichError: ErrorType { case NotMe case DoItYourself }
func makeMeSandwich(names: [String: String]) throws -> String { guard let sandwich = names["sandwich"] else { throw SandwichError.NotMe } return sandwich }
let kitchen = ["sandwich": "ready", "breakfeast": "not ready"] do { let sandwich = try makeMeSandwich(kitchen) print("i eat it \(sandwich)") } catch SandwichError.NotMe { print("Not me error") } catch SandwichError.DoItYourself { print("do it error") }
do { let sandwich = try makeMeSandwich(kitchen) print("i eat it \(sandwich)") } catch SandwichError.NotMe { print("Not me error") } catch SandwichError.DoItYourself { print("do it error") } catch let error { print(error.localizedDescription) }
extension SandwichError: CustomStringConvertible { var description: String { switch self { case NotMe: return "Not me error" case DoItYourself: return "Try sudo" } } }
do { let sandwich = try makeMeSandwich(kitchen) print("i eat it \(sandwich)") } catch let error as SandwichError { print(error.description) } catch { print("i dunno") }
func myFunction() throws -> Int func myFunction() throws CustomError -> Int func myFunction() throws CustomErrorOne, CustomErrorTwo -> Int
do { let sandwich = try makeMeSandwich(kitchen) print("i eat it \(sandwich)") } catch SandwichError.NotMe { print("Not me error") } catch SandwichError.DoItYourself { print("do it error") } catch Default { print("Another Error") }
enum MyError: ErrorType { case ErrorA, ErrorB } func myFunctionThatThrows() throws MyError { ...throw .ErrorA...throw .ErrorB... } do { try myFunctionThatThrows() } case .ErrorA { ... } case .ErrorB { ... }
enum MyError: ErrorType { case ErrorA, ErrorB, ErrorC }
enum spendingError : Error{ case minus case limit }
func calculateSpending(morningSpending:Double,eveningSpending:Double) throws ->Double{ if morningSpending < 0 || eveningSpending < 0{ throw spendingError.minus } if (morningSpending + eveningSpending) > 100{ throw spendingError.limit } return morningSpending + eveningSpending }
do{ try calculateSpending(morningSpending: 60, eveningSpending: 50) } catch spendingError.minus{ print("This is not possible...") } catch spendingError.limit{ print("Limit reached...") }
<navigationBar key="navigationBar" opaque="NO" contentMode="scaleToFill" misplaced="YES" translucent="NO" id="Os1-Xh-7XN">
class EditSubjectPopoverController : NSObject { @IBOutlet internal var subjectColorDotView : ColoredDotView! ... }
class EditTaskPopoverController : NSObject { @IBOutlet internal var lowPriorityDotView : ColoredDotView! @IBOutlet internal var medPriorityDotView : ColoredDotView! @IBOutlet internal var highPriorityDotView : ColoredDotView! ... }
func CustomTableView(tableView: CustomTableView, dataForRow row: Int) -> NSData {...}
func dataForRow(row: Int, tableView: CustomTableView) -> NSData {...}
class func didRecieveData(BlockItems: [BlockItems])
var binGlow: pipGlow = pipGlow(style: "Bin") var pipGlow: PipGlowSprite = PipGlowSprite()
var binGlow: pipGlow = pipGlow(style: "Bin") var pipGlowSprite: PipGlowSprite = PipGlowSprite()
assert({() -> Bool in return false}(), "No user has been set", file: __FILE__, line: __LINE__)
assert(false, "No user has been set", file: __FILE__, line: __LINE__)
func f(pred: () -> Bool) { if pred() { print("It } }
func f(pred: @autoclosure () -> Bool) { if pred() { print("It } } f(pred: 2 > 1)
func print(_ item: @autoclosure () -> Any, separator: String = " ", terminator: String = "\n") { Swift.print(item(), separator:separator, terminator: terminator) }
func simpleAssert(condition: @auto_closure () -> Bool, message: String) { if !condition() { println(message) } } let testNumber = 5 simpleAssert(testNumber % 2 == 0, "testNumber isn
func until<L: LogicValue>(pred: @auto_closure ()->L, block: ()->()) { while !pred() { block() } } until(condition) { doSomething() }
let nonAutoClosure = { (arg1: () -> Bool) -> Void in } let non = nonAutoClosure( { 2 > 1} ) let autoClosure = { (arg1: @autoclosure () -> Bool) -> Void in } var auto = autoClosure( 2 > 1 )
navigationItem.leftBarButtonItem?.tintColor = UIColor.whiteColor() navigationItem.backBarButtonItem?.tintColor = UIColor.whiteColor()
self.navigationController.navigationBar.tintColor = UIColor.whiteColor();
self.navigationBar.barStyle = UIBarStyle.Black self.navigationBar.tintColor = UIColor.whiteColor()
navigationController?.navigationBar.barTintColor = .purple navigationController?.navigationBar.tintColor = .white
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { UINavigationBar.appearance().translucent = false UINavigationBar.appearance().barTintColor = UIColor(rgba: " UINavigationBar.appearance().tintColor = UIColor.whiteColor() UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName:UIColor.whiteColor()] return true }
let navStyles = UINavigationBar.appearance() navStyles.tintColor = .white navStyles.barTintColor = .black
override func viewDidLoad() { super.viewDidLoad() self.navigationController?.navigationBar.tintColor = UIColor.white }
self.navigationController?.navigationBar.tintColor = UIColor.red
self.navigationController?.navigationBar.tintColor = UIColor.white
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { UINavigationBar.appearance().tintColor = .white }
self.navigationController?.navigationBar.tintColor = UIColor.redColor()
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { UINavigationBar.appearance().tintColor = .white return true }
let navController = UINavigationController.init(rootViewController: yourViewController) navController.navigationBar.tintColor = .red present(navController, animated: true, completion: nil)
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { let navigationBarAppearace = UINavigationBar.appearance() navigationBarAppearace.tintColor = UIColor.whiteColor() navigationBarAppearace.barTintColor = UIColor.purpleColor() navigationBarAppearace.titleTextAttributes = [NSForegroundColorAttributeName:UIColor.whiteColor()] self.window?.backgroundColor = UIColor.whiteColor() return true }
self.navigationController!.navigationBar.tintColor = UIColor.whiteColor();
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == "YourPaymentInformationSegue" { self.navigationItem.backBarButtonItem?.tintColor = UIColor.gray } }
var navigationBarAppearace = UINavigationBar.appearance() navigationBarAppearace.tintColor = uicolorFromHex(0xffffff) navigationBarAppearace.barTintColor = uicolorFromHex(0x034517) navigationBarAppearace.titleTextAttributes =[NSForegroundColorAttributeName:UIColor.whiteColor()]
UINavigationBar.appearance().isTranslucent = false UINavigationBar.appearance().barTintColor = .purple UINavigationBar.appearance().titleTextAttributes = [NSAttributedStringKey.foregroundColor: UIColor.white] UIBarButtonItem.appearance().tintColor = .white
self.navigationController.navigationBar.tintColor = [UIColor whiteColor];
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { UINavigationBar.appearance().barTintColor = UIColor(red: 42/255.0, green: 140/255.0, blue: 166/255.0, alpha: 0.5) UINavigationBar.appearance().barStyle = UIBarStyle.Default UINavigationBar.appearance().tintColor = UIColor(red: 204/255.0, green: 255/255.0, blue: 204/255.0, alpha: 1) UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName: UIColor(red: 204/255.0, green: 255/255.0, blue: 204/255.0, alpha: 1), NSFontAttributeName: UIFont(name: "OpenSans-Bold", size: 25)!] UIApplication.sharedApplication().statusBarStyle = UIStatusBarStyle.LightContent return true }
self.navigationItem.setHidesBackButton(true, animated: true) let backbtn = UIBarButtonItem(title: "Back", style:UIBarButtonItemStyle.Plain, target: self, action: "backTapped:") self.navigationItem.leftBarButtonItem = backbtn self.navigationItem.leftBarButtonItem?.tintColor = UIColor.grayColor()
self.navigationItem.backBarButtonItem.tintColor = UIColor.whiteColor;
declare navigation bar as navagationbar here button stuff { navigationbar.text = "title" }
override func viewDidLoad() { super.viewDidLoad() self.title = "some title" }
override func viewDidLoad() { super.viewDidLoad() self.navigationItem.title = "Your Title" }
func setNavBarToTheView() { let navBar: UINavigationBar = UINavigationBar(frame: CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 64.0)) self.view.addSubview(navBar); let navItem = UINavigationItem(title: "Camera"); let doneItem = UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.cancel, target: self, action: navItem.leftBarButtonItem = doneItem; navBar.setItems([navItem], animated: true); }
override func viewDidLoad() { super.viewDidLoad() self.navigationItem.title = "Your Text" }
override func viewDidLoad() { super.viewDidLoad() self.title = "Your title" }
{ "person":[ { "name": "Bob", "age": "16", "employed": "No" }, { "name": "Vinny", "age": "56", "employed": "Yes" } ] }
let file = "test.json" let dirs : String[] = NSSearchPathForDirectoriesInDomains( NSSearchpathDirectory.DocumentDirectory, NSSearchPathDomainMask.AllDomainMask, true) as String[] if (dirs != nil) { let directories: String[] = dirs let dir = directories[0] let path = dir.stringByAppendingPathComponent(file) } var jsonData = NSData(contentsOfFile:path, options: nil, error: nil) println("jsonData \(jsonData)" var jsonDict = NSJSONSerialization.JSONObjectWithData(jsonData, options: nil, error: nil) as? NSDictionary println("jsonDict \(jsonDict)") - This prints nil.....
if let path = NSBundle.mainBundle().pathForResource("test", ofType: "json") { if let jsonData = NSData(contentsOfFile: path, options: .DataReadingMappedIfSafe, error: nil) { if let jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions.MutableContainers, error: nil) as? NSDictionary { if let persons : NSArray = jsonResult["person"] as? NSArray { } } } }
if let path = Bundle.main.path(forResource: "test", ofType: "json") { do { let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .mappedIfSafe) let jsonResult = try JSONSerialization.jsonObject(with: data, options: .mutableLeaves) if let jsonResult = jsonResult as? Dictionary<String, AnyObject>, let person = jsonResult["person"] as? [Any] { } } catch { } }
if let path = Bundle.main.path(forResource: "assets/test", ofType: "json") { do { let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped) let jsonObj = try JSON(data: data) print("jsonData:\(jsonObj)") } catch let error { print("parse error: \(error.localizedDescription)") } } else { print("Invalid filename/path.") }
struct ResponseData: Decodable { var person: [Person] } struct Person : Decodable { var name: String var age: String var employed: String } func loadJson(filename fileName: String) -> [Person]? { if let url = Bundle.main.url(forResource: fileName, withExtension: "json") { do { let data = try Data(contentsOf: url) let decoder = JSONDecoder() let jsonData = try decoder.decode(ResponseData.self, from: data) return jsonData.person } catch { print("error:\(error)") } } return nil }
func loadJson(filename fileName: String) -> [String: AnyObject]? { if let url = Bundle.main.url(forResource: fileName, withExtension: "json") { do { let data = try Data(contentsOf: url) let object = try JSONSerialization.jsonObject(with: data, options: .allowFragments) if let dictionary = object as? [String: AnyObject] { return dictionary } } catch { print("Error!! Unable to parse \(fileName).json") } } return nil }
if let path = Bundle.main.path(forResource: "userDatabseFakeData", ofType: "json") { do { let jsonData = try NSData(contentsOfFile: path, options: NSData.ReadingOptions.mappedIfSafe) do { let jsonResult: NSDictionary = try JSONSerialization.jsonObject(with: jsonData as Data, options: JSONSerialization.ReadingOptions.mutableContainers) as! NSDictionary if let people : [NSDictionary] = jsonResult["person"] as? [NSDictionary] { for person: NSDictionary in people { for (name,value) in person { print("\(name) , \(value)") } } } } catch {} } catch {} }
func loadJson(forFilename fileName: String) -> NSDictionary? { if let url = Bundle.main.url(forResource: fileName, withExtension: "json") { if let data = NSData(contentsOf: url) { do { let dictionary = try JSONSerialization.jsonObject(with: data as Data, options: .allowFragments) as? NSDictionary return dictionary } catch { print("Error!! Unable to parse \(fileName).json") } } print("Error!! Unable to load \(fileName).json") } return nil }
if let path = NSBundle.mainBundle().pathForResource("test", ofType: "json") { do { let jsonData = try NSData(contentsOfFile: path, options: NSDataReadingOptions.DataReadingMappedIfSafe) do { let jsonResult: NSDictionary = try NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions.MutableContainers) as! NSDictionary if let people : [NSDictionary] = jsonResult["person"] as? [NSDictionary] { for person: NSDictionary in people { for (name,value) in person { print("\(name) , \(value)") } } } } catch {} } catch {} }
if let path = Bundle.main.url(forResource: "person", withExtension: "json") { do { let jsonData = try Data(contentsOf: path, options: .mappedIfSafe) do { if let jsonResult = try JSONSerialization.jsonObject(with: jsonData, options: JSONSerialization.ReadingOptions(rawValue: 0)) as? NSDictionary { if let personArray = jsonResult.value(forKey: "person") as? NSArray { for (_, element) in personArray.enumerated() { if let element = element as? NSDictionary { let name = element.value(forKey: "name") as! String let age = element.value(forKey: "age") as! String let employed = element.value(forKey: "employed") as! String print("Name: \(name), age: \(age), employed: \(employed)") } } } } } catch let error as NSError { print("Error: \(error)") } } catch let error as NSError { print("Error: \(error)") } }
Name: Bob, age: 16, employed: No Name: Vinny, age: 56, employed: Yes
func readjson(fileName: String) -> NSData{ let path = NSBundle.mainBundle().pathForResource(fileName, ofType: "json") let jsonData = NSData(contentsOfMappedFile: path!) return jsonData! }
fileprivate class BundleTargetingClass {} func loadJSON<T>(name: String) -> T? { guard let filePath = Bundle(for: BundleTargetingClass.self).url(forResource: name, withExtension: "json") else { return nil } guard let jsonData = try? Data(contentsOf: filePath, options: .mappedIfSafe) else { return nil } guard let json = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) else { return nil } return json as? T }
if let path : String = NSBundle.mainBundle().pathForResource("filename", ofType: "json") { if let data = NSData(contentsOfFile: path) { let json = JSON(data: data) } }
func testCanReadTestJSONFile() { let path = NSBundle(forClass: ForecastIOAdapterTests.self).pathForResource("ForecastIOSample", ofType: "json") if let jsonData = NSData(contentsOfFile:path!) { let json = JSON(data: jsonData) if let currentTemperature = json["currently"]["temperature"].double { println("json: \(json)") XCTAssertGreaterThan(currentTemperature, 0) } } }
func loadJson(filename fileName: String) -> [String: AnyObject]? { if let url = Bundle.main.url(forResource: fileName, withExtension: "json") { if let data = NSData(contentsOf: url) { do { let object = try JSONSerialization.jsonObject(with: data as Data, options: .allowFragments) if let dictionary = object as? [String: AnyObject] { return dictionary } } catch { print("Error!! Unable to parse \(fileName).json") } } print("Error!! Unable to load \(fileName).json") } return nil }
private func readLocalJsonFile() { if let urlPath = Bundle.main.url(forResource: "test", withExtension: "json") { do { let jsonData = try Data(contentsOf: urlPath, options: .mappedIfSafe) if let jsonDict = try JSONSerialization.jsonObject(with: jsonData, options: .mutableContainers) as? [String: AnyObject] { if let personArray = jsonDict["person"] as? [[String: AnyObject]] { for personDict in personArray { for (key, value) in personDict { print(key, value) } print("\n") } } } } catch let jsonError { print(jsonError) } } }
let masterDataUrl: NSURL = NSBundle.mainBundle().URLForResource("masterdata", withExtension: "json")! let jsonData: NSData = NSData(contentsOfURL: masterDataUrl)! let jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(jsonData, options: nil, error: nil) as! NSDictionary var persons : NSArray = jsonResult["person"] as! NSArray
func fetchPersons(){ if let pathURL = Bundle.main.url(forResource: "Person", withExtension: "json"){ do { let jsonData = try Data(contentsOf: pathURL, options: .mappedIfSafe) let jsonResult = try JSONSerialization.jsonObject(with: jsonData, options: .mutableContainers) as! [String: Any] if let persons = jsonResult["person"] as? [Any]{ print(persons) } }catch(let error){ print (error.localizedDescription) } } }
if let filePath = Bundle.main.path(forResource: "fileName", ofType: "json"), let data = NSData(contentsOfFile: filePath) { do { let json = try JSONSerialization.jsonObject(with: data as Data, options: JSONSerialization.ReadingOptions.allowFragments) } catch { } }
func fetchJSONContent() { if let path = NSBundle.mainBundle().pathForResource("FAQ-data", ofType: "json") { if let jsonData = NSData(contentsOfFile: path) { do { if let jsonResult: NSDictionary = try NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions.MutableContainers) as? NSDictionary { if let responseParameter : NSDictionary = jsonResult["responseParameter"] as? NSDictionary { if let response : NSArray = responseParameter["FAQ"] as? NSArray { responseFAQ = response print("response FAQ : \(response)") } } } } catch { print("Error while parsing: \(error)") } } } } override func viewWillAppear(animated: Bool) { fetchFAQContent() }
{ "status": "00", "msg": "FAQ List ", "responseParameter": { "FAQ": [ { "question": ‚ÄúQuestion No.1 here‚Äù, "answer": ‚ÄúAnswer goes here‚Äù, "id": 1 }, { "question": ‚ÄúQuestion No.2 here‚Äù, "answer": ‚ÄúAnswer goes here‚Äù, "id": 2 } . . . ] } }
NSArray *json = [NSJSONSerialization JSONObjectWithData:JSONData options:kNilOptions error:nil]; NSString *age = json[0][@"person"][@"age"]; NSLog(@"Dani
var json: Array! do { json = try NSJSONSerialization.JSONObjectWithData(JSONData, options: NSJSONReadingOptions()) as? Array } catch { print(error) } guard let item = json[0] as? [String: AnyObject], let person = item["person"] as? [String: AnyObject], let age = person["age"] as? Int else { return; } print("Dani
func loadJson(fileName: String) -> JSON { var dataPath:JSON! if let path : String = Bundle.main.path(forResource: fileName, ofType: "json") { if let data = NSData(contentsOfFile: path) { dataPath = JSON(data: data as Data) } } return dataPath }
struct JuzgadosList : Codable { var CP : Int var TEL : String var LOCAL : String var ORGANO : String var DIR : String }
func getJsonFromDirectory() { if let path = Bundle.main.path(forResource: "juzgados", ofType: "json") { do { let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped) let jList = try JSONDecoder().decode([JuzgadosList].self, from: data) self.jzdosList = jList DispatchQueue.main.async() { () -> Void in self.tableView.reloadData() } } catch let error { print("parse error: \(error.localizedDescription)") } } else { print("Invalid filename/path.") } }
func getJsonFromUrl(){ self.jzdosList.removeAll(keepingCapacity: false) print("Internet Connection Available!") guard let url = URL(string: "yourURL") else { return } let request = URLRequest(url: url, cachePolicy: URLRequest.CachePolicy.reloadIgnoringLocalCacheData, timeoutInterval: 60.0) URLSession.shared.dataTask(with: request) { (data, response, err) in guard let data = data else { return } do { let jList = try JSONDecoder().decode([JuzgadosList].self, from: data) self.jzdosList = jList DispatchQueue.main.async() { () -> Void in self.tableView.reloadData() } } catch let jsonErr { print("Error serializing json:", jsonErr) } }.resume() }
{ "person":[ { "name": "Bob", "age": "16", "employed": "No" }, { "name": "Vinny", "age": "56", "employed": "Yes" } ] }
import Foundation struct RequestCodable:Codable { let person:[PersonCodable] }
import Foundation struct PersonCodable:Codable { let name:String let age:String let employed:String }
import Foundation extension Decodable { static func fromJSON<T:Decodable>(_ fileName: String, fileExtension:String="json") -> T? { let url = Bundle.main.url(forResource: fileName, withExtension: fileExtension)! do { let data = try Data(contentsOf: url) return try JSONDecoder().decode(T.self, from: data) } catch { print(error.localizedDescription) return nil } }
let result = RequestCodable.fromJSON("test") as RequestCodable? result?.person.compactMap({ print($0) }) /* PersonCodable(name: "Bob", age: "16", employed: "No") PersonCodable(name: "Vinny", age: "56", employed: "Yes") */
extension Array { func removeObject<T where T : Equatable>(object: T) { var index = find(self, object) self.removeAtIndex(index) } }
extension RangeReplaceableCollectionType where Generator.Element : Equatable { mutating func removeObject(object : Generator.Element) { if let index = self.indexOf(object) { self.removeAtIndex(index) } } }
extension Array where Element: Equatable { mutating func remove(object: Element) { if let index = index(of: object) { remove(at: index) } } }
func removeObject<T : Equatable>(object: T, inout fromArray array: [T]) { }
func arrayRemovingObject<T : Equatable>(object: T, fromArray array: [T]) -> [T] { }
extension Array { mutating func removeObject<U: Equatable>(object: U) { var index: Int? for (idx, objectToCompare) in enumerate(self) { if let to = objectToCompare as? U { if object == to { index = idx } } } if(index != nil) { self.removeAtIndex(index!) } } } var list = [1,2,3] list.removeObject(2) list.removeObject("3") list
extension Array { mutating func removeObject<U: Equatable>(object: U) -> Bool { for (idx, objectToCompare) in self.enumerate() { if let to = objectToCompare as? U { if object == to { self.removeAtIndex(idx) return true } } } return false } } var list = [1,2,3,2] list.removeObject(2) list list.removeObject(2) list
func removeObject<T : Equatable>(object: T, inout fromArray array: [T]) { var index = find(array, object) array.removeAtIndex(index!) }
func arrayRemovingObject<U: Equatable>(object: U, return fromArray.filter { return $0 != object } }
var myArray = ["Dog", "Cat", "Ant", "Fish", "Cat"] myArray = arrayRemovingObject("Cat", fromArray:myArray )
extension Array where Element: Equatable { func arrayRemovingObject(object: Element) -> [Element] { return filter { $0 != object } } }
var myArray = ["Dog", "Cat", "Ant", "Fish", "Cat"] myArray = myArray.arrayRemovingObject("Cat" )
extension Array where Element:Equatable { public mutating func remove(_ item:Element ) { var index = 0 while index < self.count { if self[index] == item { self.remove(at: index) } else { index += 1 } } } public func array( removing item:Element ) -> [Element] { var result = self result.remove( item ) return result } }
var array1 = ["Cat", "Dog", "Turtle", "Cat", "Fish", "Cat"] array1.remove("Cat") print(array1) let array2 = ["Cat", "Dog", "Turtle", "Cat", "Fish", "Cat"] let array3 = array2.array(removing:"Cat") print(array3)
extension Array where Element: Equatable { mutating func remove(object: Element) { if let index = indexOf({ $0 == object }) { removeAtIndex(index) } } }
extension Array where Element: AnyObject { mutating func remove(object: Element) { if let index = indexOf({ $0 === object }) { removeAtIndex(index) } } }
extension Array where Element: AnyObject { mutating func remove(object: Element) { if let index = index(where: { $0 === object }) { remove(at: index) } } }
extension _ArrayType where Generator.Element : Equatable{ mutating func removeObject(object : Self.Generator.Element) { while let index = self.indexOf(object){ self.removeAtIndex(index) } } }
import Foundation extension Array { mutating func removeObject<T where T : Equatable>(obj: T) { self = self.filter({$0 as? T != obj}) } }
mutating func removeFirst(element: Element, equality: (Element, Element) -> Bool) -> Bool { for (index, item) in enumerate(self) { if equality(item, element) { self.removeAtIndex(index) return true } } return false }
var array = ["Apple", "Banana", "Strawberry"] array.removeFirst("Banana") { $0 == $1 }
let date1 = NSDate() let date2 = NSDate() var array = [date1, date2] array.removeFirst(NSDate()) { $0 === $1 } array.removeFirst(date1) { $0 === $1 }
extension Array where Element: Equatable { mutating func removeElement(element: Element) -> Element? { if let index = indexOf(element) { return removeAtIndex(index) } return nil } mutating func removeAllOccurrencesOfElement(element: Element) -> Int { var occurrences = 0 while true { if let index = indexOf(element) { removeAtIndex(index) occurrences++ } else { return occurrences } } } }
extension Array where Element: Equatable { mutating func remove<Element: Equatable>(item: Element) -> Array { self = self.filter { $0 as? Element != item } return self } }
let additionValue = productHarvestChoices[trueIndex]["name"] as! String var count = 0 for productHarvestChoice in productHarvestChoices { if productHarvestChoice["name"] as! String == additionValue { productHarvestChoices.removeAtIndex(count) } count = count + 1 }
import Foundation extension Array where Element: Equatable { mutating func removeObject(object: Element) { if let index = self.firstIndex(of: object) { self.remove(at: index) } } } var testArray = [1,2,3,4,5,6,7,8,9,0] testArray.removeObject(object: 6) let newArray = testArray var testArray2 = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"] testArray2.removeObject(object: "6") let newArray2 = testArray2
extension Array { mutating func removeObject<T: Equatable>(object: T) -> Bool { var index: Int? for (idx, objectToCompare) in self.enumerate() { if let toCompare = objectToCompare as? T { if toCompare == object { index = idx break } } } if(index != nil) { self.removeAtIndex(index!) return true } else { return false } } }
extension Array { mutating func removeObject<T: Equatable>(object: T) { var index: Int? for (idx, objectToCompare) in enumerate(self) { let to = objectToCompare as T if object == to { index = idx } } if(index) { self.removeAtIndex(index!) } } }
func tableName() -> String { return("users"); } func createTableStatement(schema: [String]) -> String { var schema = schema; schema.append("id string"); schema.append("created integer"); schema.append("updated integer"); schema.append("model blob"); var columns: String = ",".join(schema); var statement = "create table if not exists " + self.tableName() + "(" + columns + ");"; return(statement); }
var statement = "create table if not exists " + self.tableName(); statement += "(" + columns + ");";
return "\(year) \(month) \(dayString) \(hour) \(min) \(weekDay)"
expression was too complex to be solved in reasonable time; consider breaking up the expression into distinct sub-expressions
let media = entities.filter { (entity: Entity) -> Bool in
func sumOf(numbers: [Int]) -> Int { var total = 0 for i in numbers { total += i } return total }
func sumOf(numbers: Int...) -> Int { return sumOf(numbers) }
var variadicSum = sumOf(1, 2, 3, 4, 5) var arraySum = sumOf([1, 2, 3, 4, 5])
typealias Function = [Int] -> Int let sumOfArray = unsafeBitCast(sumOf, Function.self) sumOfArray([1, 2, 3])
func sumOf (numbers : [Int]) -> Int { return numbers.reduce(0, combine: +) } func sumOf (numbers : Int...) -> Int { return sumArray (numbers) }
func sumOf(numbers: Array<Int>) -> Int { var sum = 0 for number in numbers { sum += number } return sum } var someNums = [8,7,2,9,12] sumOf(someNums) sumOf([10, 15, 20])
func addBarButtonItems(types: REWEBarButtonItemType...) { addBarButtonItems(types: types.map { $0 }) } func addBarButtonItems(types: [REWEBarButtonItemType]) { }
UIDevice.currentDevice().identifierForVendor!.UUIDString
let UUIDValue = UIDevice.currentDevice().identifierForVendor!.UUIDString print("UUID: \(UUIDValue)")
let deviceID = UIDevice.current.identifierForVendor!.uuidString print(deviceID)
func sendEphemeralToken() { DCDevice.current.generateToken { (data, error) in guard let data = data else { return } let token = data.base64EncodedString() } }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { let userDefaults = NSUserDefaults.standardUserDefaults() if userDefaults.objectForKey("ApplicationIdentifier") == nil { let UUID = NSUUID().UUIDString userDefaults.setObject(UUID, forKey: "ApplicationIdentifier") userDefaults.synchronize() } return true } print(NSUserDefaults.standardUserDefaults().valueForKey("ApplicationIdentifier")!)
let UUID = UIDevice.currentDevice().identifierForVendor?.UUIDString
import FrameworkA import FrameworkB FrameworkA.foo()
var n1 = PackageOne.Class(name: "Package 1 class") var n2 = PackageTwo.Class(name: "Package 2 class") println("Name 1: \(n1.name)") println("Name 2: \(n2.name)")
extension PackageOne { class Class { var name: String init(name:String) { self.name = name } } }
extension PackageTwo { class Class { var name: String init(name:String) { self.name = name } } }
import Foundation extension PackageOne { struct SubPackage { } }
extension PackageOne.SubPackage { class Class { var name: String init(name:String) { self.name = name } } }
public struct Package { public struct SubPackage { public struct SubPackageOne { } public struct SubPackageTwo { } } }
class MAUICollectionViewController: UICollectionViewController {}
var customController = UICollectionViewController() var uikitController = UIKit.UICollectionViewController()
var customController = MyApp.UICollectionViewController() var uikitController = UIKit.UICollectionViewController()
struct Profiles { struct Views {} struct ViewControllers {} }
extension Profiles.ViewControllers { class Edit: UIViewController {} } extension Profiles.ViewControllers.Edit { override func viewDidLoad() { } }
extension Profiles.Views { class Edit: UIView {} } extension Profiles.Views.Edit { override func drawRect(rect: CGRect) { } }
class MyClass { func doSomethingWith(viewController: Profiles.ViewControllers.Edit) { } }
2014-10-18 12:07:34.400 soundtest[17081:818922] *** Terminating app due to uncaught exception *** First throw call stack: ( 0 CoreFoundation 0x00000001067813f5 __exceptionPreprocess + 165 1 libobjc.A.dylib 0x00000001082afbb7 objc_exception_throw + 45 2 CoreFoundation 0x0000000106781039 -[NSException raise] + 9 3 Foundation 0x0000000106b984d3 -[NSObject(NSKeyValueCoding) setValue:forKey:] + 259 4 CoreFoundation 0x00000001066cb400 -[NSArray makeObjectsPerformSelector:] + 224 5 UIKit 0x00000001072ce97d -[UINib instantiateWithOwner:options:] + 1506 6 UIKit 0x000000010712f698 -[UIViewController _loadViewFromNibNamed:bundle:] + 242 7 UIKit 0x000000010712fc88 -[UIViewController loadView] + 109 8 UIKit 0x000000010712fef9 -[UIViewController loadViewIfRequired] + 75 9 UIKit 0x000000010713038e -[UIViewController view] + 27 10 UIKit 0x00000001076cd83f -[_UIFullscreenPresentationController _setPresentedViewController:] + 65 11 UIKit 0x000000010710bc49 -[UIPresentationController initWithPresentedViewController:presentingViewController:] + 105 12 UIKit 0x000000010713c121 -[UIViewController _presentViewController:withAnimationController:completion:] + 1746 13 UIKit 0x000000010713e461 __62-[UIViewController presentViewController:animated:completion:]_block_invoke + 132 14 UIKit 0x000000010713e385 -[UIViewController presentViewController:animated:completion:] + 229 15 UIKit 0x00000001073bb9d6 _UIGestureRecognizerSendActions + 262 16 UIKit 0x00000001073ba679 -[UIGestureRecognizer _updateGestureWithEvent:buttonEvent:] + 532 17 UIKit 0x00000001073bf296 ___UIGestureRecognizerUpdate_block_invoke662 + 51 18 UIKit 0x00000001073bf192 _UIGestureRecognizerRemoveObjectsFromArrayAndApplyBlocks + 254 19 UIKit 0x00000001073b520d _UIGestureRecognizerUpdate + 2796 20 UIKit 0x00000001070520a6 -[UIWindow _sendGesturesForEvent:] + 1041 21 UIKit 0x0000000107052cd3 -[UIWindow sendEvent:] + 667 22 UIKit 0x000000010701fae1 -[UIApplication sendEvent:] + 246 23 UIKit 0x000000010702cbad _UIApplicationHandleEventFromQueueEvent + 17370 24 UIKit 0x0000000107008233 _UIApplicationHandleEventQueue + 1961 25 CoreFoundation 0x00000001066b6ad1 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17 26 CoreFoundation 0x00000001066ac99d __CFRunLoopDoSources0 + 269 27 CoreFoundation 0x00000001066abfd4 __CFRunLoopRun + 868 28 CoreFoundation 0x00000001066aba06 CFRunLoopRunSpecific + 470 29 GraphicsServices 0x000000010a1699f0 GSEventRunModal + 161 30 UIKit 0x000000010700b550 UIApplicationMain + 1282 31 soundtest 0x000000010624503e top_level_code + 78 32 soundtest 0x000000010624507a main + 42 33 libdyld.dylib 0x000000010ae4a145 start + 1 34 ??? 0x0000000000000001 0x0 + 1 ) libc++abi.dylib: terminating with uncaught exception of type NSException (lldb)
@IBAction func editPictureTapped(sender: UIButton) { print("Tapped") }
@IBAction func editPictureTapped(_: UIButton) { print("Tapped") }
performSegueWithIdentifier("wrongSegueName", sender: self)
dispatch_async(dispatch_get_main_queue(), ^{ [self performSegueWithIdentifier:@"SegueName" sender:self]; });
DispatchQueue.main.async { [weak self] in self?.performSegue(withIdentifier: "SegueName", sender: self) }
UIView *bottomView = [[UIView alloc] initWithFrame:CGRectZero]; [self.view addSubview:bottomView]; bottomConstraint = [NSLayoutConstraint constraintWithItem:bottomView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1 constant:0]; bottomConstraint.active = YES;
func matchesForRegexInText(regex: String!, text: String!) -> [String] { ??? }
func matchesForRegexInText(regex: String!, text: String!) -> [String] { var regex = NSRegularExpression(pattern: regex, options: nil, error: nil) var results = regex.matchesInString(text, options: nil, range: NSMakeRange(0, countElements(text))) as Array<NSTextCheckingResult> return ... }
func matches(for regex: String, in text: String) -> [String] { do { let regex = try NSRegularExpression(pattern: regex) let results = regex.matches(in: text, range: NSRange(text.startIndex..., in: text)) return results.map { String(text[Range($0.range, in: text)!]) } } catch let error { print("invalid regex: \(error.localizedDescription)") return [] } }
let string = "üá©üá™‚Ç¨4‚Ç¨9" let matched = matches(for: "[0-9]", in: string) print(matched)
return results.flatMap { Range($0.range, in: text).map { String(text[$0]) } }
func matchesForRegexInText(regex: String, text: String) -> [String] { do { let regex = try NSRegularExpression(pattern: regex, options: []) let nsString = text as NSString let results = regex.matchesInString(text, options: [], range: NSMakeRange(0, nsString.length)) return results.map { nsString.substringWithRange($0.range)} } catch let error as NSError { print("invalid regex: \(error.localizedDescription)") return [] } }
let string = "üá©üá™‚Ç¨4‚Ç¨9" let matches = matchesForRegexInText("[0-9]", text: string) print(matches)
func matches(for regex: String, in text: String) -> [String] { do { let regex = try NSRegularExpression(pattern: regex) let nsString = text as NSString let results = regex.matches(in: text, range: NSRange(location: 0, length: nsString.length)) return results.map { nsString.substring(with: $0.range)} } catch let error { print("invalid regex: \(error.localizedDescription)") return [] } }
let string = "üá©üá™‚Ç¨4‚Ç¨9" let matched = matches(for: "[0-9]", in: string) print(matched)
import Foundation extension String { func matchingStrings(regex: String) -> [[String]] { guard let regex = try? NSRegularExpression(pattern: regex, options: []) else { return [] } let nsString = self as NSString let results = regex.matches(in: self, options: [], range: NSMakeRange(0, nsString.length)) return results.map { result in (0..<result.numberOfRanges).map { result.range(at: $0).location != NSNotFound ? nsString.substring(with: result.range(at: $0)) : "" } } } } "prefix12 aaa3 prefix45".matchingStrings(regex: "fix([0-9])([0-9])") "prefix12".matchingStrings(regex: "(?:prefix)?([0-9]+)") "12".matchingStrings(regex: "(?:prefix)?([0-9]+)") let number = "prefix12suffix".matchingStrings(regex: "fix([0-9]+)su").first?[1]
import Foundation extension String { func matchingStrings(regex: String) -> [[String]] { guard let regex = try? NSRegularExpression(pattern: regex, options: []) else { return [] } let nsString = self as NSString let results = regex.matches(in: self, options: [], range: NSMakeRange(0, nsString.length)) return results.map { result in (0..<result.numberOfRanges).map { result.rangeAt($0).location != NSNotFound ? nsString.substring(with: result.rangeAt($0)) : "" } } } } "prefix12 aaa3 prefix45".matchingStrings(regex: "fix([0-9])([0-9])") "prefix12".matchingStrings(regex: "(?:prefix)?([0-9]+)") "12".matchingStrings(regex: "(?:prefix)?([0-9]+)") let number = "prefix12suffix".matchingStrings(regex: "fix([0-9]+)su").first?[1]
extension String { func matchingStrings(regex: String) -> [[String]] { guard let regex = try? NSRegularExpression(pattern: regex, options: []) else { return [] } let nsString = self as NSString let results = regex.matchesInString(self, options: [], range: NSMakeRange(0, nsString.length)) return results.map { result in (0..<result.numberOfRanges).map { result.rangeAtIndex($0).location != NSNotFound ? nsString.substringWithRange(result.rangeAtIndex($0)) : "" } } } }
extension String { func regex (pattern: String) -> [String] { do { let regex = try NSRegularExpression(pattern: pattern, options: NSRegularExpressionOptions(rawValue: 0)) let nsstr = self as NSString let all = NSRange(location: 0, length: nsstr.length) var matches : [String] = [String]() regex.enumerateMatchesInString(self, options: NSMatchingOptions(rawValue: 0), range: all) { (result : NSTextCheckingResult?, _, _) in if let r = result { let result = nsstr.substringWithRange(r.range) as String matches.append(result) } } return matches } catch { return [String]() } } }
import Foundation func matches(for regex: String, in text: String) -> [String] { do { let regex = try RegularExpression(pattern: regex, options: []) let nsString = NSString(string: text) let results = regex.matches(in: text, options: [], range: NSRange(location: 0, length: nsString.length)) return results.map { nsString.substring(with: $0.range) } } catch let error { print("invalid regex: \(error.localizedDescription)") return [] } }
func matches(for regex: String!, in text: String!) -> [String] { do { let regex = try NSRegularExpression(pattern: regex, options: []) let nsString = text as NSString let results = regex.matchesInString(text, options: [], range: NSMakeRange(0, nsString.length)) var match = [String]() for result in results { for i in 0..<result.numberOfRanges { match.append(nsString.substringWithRange( result.rangeAtIndex(i) )) } } return match } catch let error as NSError { print("invalid regex: \(error.localizedDescription)") return [] } }
print ( matches(for: "^(.+)\\s(\\d{4})" , in: "Finding Dory 2016"))
public extension String { public func capturedGroups(withRegex pattern: String) -> [String] { var results = [String]() var regex: NSRegularExpression do { regex = try NSRegularExpression(pattern: pattern, options: []) } catch { return results } let matches = regex.matches(in: self, options: [], range: NSRange(location:0, length: self.count)) guard let match = matches.first else { return results } let lastRangeIndex = match.numberOfRanges - 1 guard lastRangeIndex >= 1 else { return results } for i in 1...lastRangeIndex { let capturedGroupIndex = match.range(at: i) let matchedString = (self as NSString).substring(with: capturedGroupIndex) results.append(matchedString) } return results } }
internal func stringsMatching(regularExpressionPattern: String, options: NSRegularExpression.Options = []) -> [String] { guard let regex = try? NSRegularExpression(pattern: regularExpressionPattern, options: options) else { return [] } let nsString = self as NSString let results = regex.matches(in: self, options: [], range: NSMakeRange(0, nsString.length)) return results.map { nsString.substring(with: $0.range) } }
var sample = "this is an [hello] amazing [world]" var regex = NSRegularExpression(pattern: "\\[.+?\\]" , options: NSRegularExpressionOptions.CaseInsensitive , error: nil) var matches = regex?.matchesInString(sample, options: nil , range: NSMakeRange(0, countElements(sample))) as Array<NSTextCheckingResult> for match in matches { let r = (sample as NSString).substringWithRange(match.range) println("found= \(r)") }
extension String { func matchingStrings(regex: String) -> [[String]] { do { let regex = try NSRegularExpression(pattern: regex) let nsString = self as NSString let results = regex.matches(in: self, options: [], range: NSMakeRange(0, nsString.length)) return results.map { result in (0..<result.numberOfRanges).map { result.range(at: $0).location != NSNotFound ? nsString.substring(with: result.range(at: $0)) : "" } } } catch let error { print("invalid regex: \(error.localizedDescription)") return [] } } }
@IBDesignable class DesignableUITextField: UITextField { let border = CALayer() @IBInspectable var borderColor: UIColor? { didSet { setup() } } @IBInspectable var borderWidth: CGFloat = 0.5 { didSet { setup() } } func setup() { border.borderColor = self.borderColor?.cgColor border.borderWidth = borderWidth self.layer.addSublayer(border) self.layer.masksToBounds = true } override func layoutSubviews() { super.layoutSubviews() border.frame = CGRect(x: 0, y: self.frame.size.height - borderWidth, width: self.frame.size.width, height: self.frame.size.height) } }
let theSubviews : Array = container_view.subviews for (view : NSView) in theSubviews { view.removeFromSuperview(container_view) }
for view in containerView.subviews{ view.removeFromSuperview() }
view.subviews.forEach({ $0.removeFromSuperview() }) view.subviews.map({ $0.removeFromSuperview() })
let funTimes = ["Awesome","Crazy","WTF"] extension String { func readIt() { print(self) } } funTimes.forEach({ $0.readIt() })
for view in self.view.subviews { view.removeFromSuperview() }
for view:CustomViewClass! in self.view.subviews { if view.isKindOfClass(CustomViewClass) { view.doClassThing() } }
for v in view.subviews{ if v is UILabel{ v.removeFromSuperview() } }
let container_view: NSView = ... container_view.subviews = []
let subViews: Array = self.subviews.copy() for (var subview: NSView!) in subViews { subview.removeFromSuperview() }
let theSubviews: Array = container_view.subviews.copy() for (var view: NSView!) in theSubviews { view.removeFromSuperview() }
for view in container_view.subviews { view.removeFromSuperview() }
import Foundation import UIKit extension UIView { func removeAllSubViews() { self.subviews.forEach({ $0.removeFromSuperview() }) } }
var subViews = parentView.subviews as Array<UIView> for someView in subViews { someView.removeFromSuperview() }
extension UIView { func removeAllSubViews() { for subView :AnyObject in self.subviews { subView.removeFromSuperview() } } }
var subViews = self.parentView.subviews for subview in subViews as [UIView] { subview.removeFromSuperview() }
extension UIView { func lf_removeAllSubviews() { for view in self.subviews { view.removeFromSuperview() } } }
let theSubviews : Array<NSView> = container_view.subviews as Array<NSView> for view in theSubviews { view.removeFromSuperview() }
func clearAllScrollSubView () { let theSubviews = itemsScrollView.subviews for (var view) in theSubviews { if view is UIView { view.removeFromSuperview() } } }
for v in (view?.subviews)! { if v.tag == 321 { v.removeFromSuperview() } }
for subView in nameofmysuperview.subviews { if subView.isKindOfClass(UIButton) { subView.removeFromSuperview() } }
while(view.subviews.count > 0) {(view.subviews[0] as NSView).removeFromSuperview()}
for k in 0..<buttons.count { buttons[k].removeFromSuperview() } buttons.removeAll()
let theSubviews = container_view.subviews for subview in theSubviews { subview.removeFromSuperview() }
extension UIView { public func removeAllSubViews() { self.subviews.forEach({ $0.removeFromSuperview() }) }
for o : AnyObject in self.subviews { if let v = o as? NSView { v.removeFromSuperview() } }
if emptyString.isEmpty { print("Nothing to see here") }
var myString: String? = nil if (myString ?? "").isEmpty { print("String is nil or empty") }
let myString: String = "" if myString.isEmpty { print("String is empty.") return } print(myString)
let myOptionalString: String? = nil guard let myString = myOptionalString, !myString.isEmpty else { print("String is nil or empty.") return } print(myString)
let lang = "Swift 4" if lang.isEmpty { print("Empty string") }
struct MyString { static func blank(text: String) -> Bool { let trimmed = text.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) return trimmed.isEmpty } }
extension String { var isBlank: Bool { return self.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty } } extension Optional where Wrapped == String { var isBlank: Bool { if let unwrapped = self { return unwrapped.isBlank } else { return true } } }
let optionalString: String? = nil if optionalString?.isEmpty == true { optionalString = "Lorem ipsum dolor sit amet" }
if let string = string where !string.isEmpty { print(string) }
extension String { var isBlank:Bool { return self.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).isEmpty } }
if let notEmptyString = optionalString where !notEmptyString.isEmpty { NSLog("Non-empty string is %@", notEmptyString) } else { NSLog("Empty or nil string") }
func checkValidityOfData(_ data: Any?, withStringCheck mode: Bool) -> Bool { if ((data != nil) && !(data is NSNull)) { if (mode == true) { let dataCheck = (data as! String).trimmingCharacters(in: CharacterSet.whitespacesAndNewlines) if (dataCheck.count > 0) { if ((data as! String) == "<null>") { return false } else { return true } } else { return false } } else { return true } } else { return false } }
override func viewDidLoad() { super.viewDidLoad() self.collectionView.registerClass(LeftMenuCollectionViewCell.self, forCellWithReuseIdentifier: "ls") } override func collectionView(collectionView: UICollectionView!, cellForItemAtIndexPath indexPath: NSIndexPath!) -> UICollectionViewCell! { var cell: LeftMenuCollectionViewCell cell = collectionView.dequeueReusableCellWithReuseIdentifier("ls", forIndexPath: indexPath) as LeftMenuCollectionViewCell println(cell.label) cell.label.text = "asd" return cell }
class LeftMenuCollectionViewCell: UICollectionViewCell { @IBOutlet weak var imageView: UIImageView! @IBOutlet weak var label: UILabel! @IBOutlet weak var activityIndicatorView: UIActivityIndicatorView! }
self.collectionView.registerClass(LeftMenuCollectionViewCell.self, forCellWithReuseIdentifier: "ls")
[self.collectionView registerNib:[UINib nibWithNibName:@"MyCell" bundle:nil] forCellWithReuseIdentifier:@"MyCellIdentifier"];
collectionView.register(UINib(nibName:"MyCell", bundle: nil), forCellWithReuseIdentifier:"MyCellIdentifier")
collectionView.register(UINib(nibName: "CustomCell", bundle: nil), forCellWithReuseIdentifier: "CustomCellId")
var testVar = "hello" var result = 0 switch(testVal) { case "one": result = 1 case "two": result = 1 default: result = 3 }
var testVal = "hello" var result = 0 switch testVal { case "one", "two": result = 1 default: result = 3 }
var testVal = "hello" var result = 0 switch testVal { case "one": fallthrough case "two": result = 1 default: result = 3 }
var testVar = "hello" switch(testVar) { case "hello": println("hello match number 1") fallthrough case "two": println("two in not hello however the above fallthrough automatically always picks the case following whether there is a match or not! To me this is wrong") default: println("Default") }
let value = 0 switch value { case 0: print(0) fallthrough case 1: print(1) case 2: print(2) default: print("default") }
class Colors { let colorTop = UIColor(red: 192.0/255.0, green: 38.0/255.0, blue: 42.0/255.0, alpha: 1.0) let colorBottom = UIColor(red: 35.0/255.0, green: 2.0/255.0, blue: 2.0/255.0, alpha: 1.0) let gl: CAGradientLayer init() { gl = CAGradientLayer() gl.colors = [ colorTop, colorBottom] gl.locations = [ 0.0, 1.0] } }
let colors = Colors() func refresh() { view.backgroundColor = UIColor.clearColor() var backgroundLayer = colors.gl backgroundLayer.frame = view.frame view.layer.insertSublayer(backgroundLayer, atIndex: 0) } } }
class Colors { var gl:CAGradientLayer! init() { let colorTop = UIColor(red: 192.0 / 255.0, green: 38.0 / 255.0, blue: 42.0 / 255.0, alpha: 1.0).cgColor let colorBottom = UIColor(red: 35.0 / 255.0, green: 2.0 / 255.0, blue: 2.0 / 255.0, alpha: 1.0).cgColor self.gl = CAGradientLayer() self.gl.colors = [colorTop, colorBottom] self.gl.locations = [0.0, 1.0] } }
@IBDesignable class GradientView: UIView { @IBInspectable var startColor: UIColor = .black { didSet { updateColors() }} @IBInspectable var endColor: UIColor = .white { didSet { updateColors() }} @IBInspectable var startLocation: Double = 0.05 { didSet { updateLocations() }} @IBInspectable var endLocation: Double = 0.95 { didSet { updateLocations() }} @IBInspectable var horizontalMode: Bool = false { didSet { updatePoints() }} @IBInspectable var diagonalMode: Bool = false { didSet { updatePoints() }} override class var layerClass: AnyClass { return CAGradientLayer.self } var gradientLayer: CAGradientLayer { return layer as! CAGradientLayer } func updatePoints() { if horizontalMode { gradientLayer.startPoint = diagonalMode ? CGPoint(x: 1, y: 0) : CGPoint(x: 0, y: 0.5) gradientLayer.endPoint = diagonalMode ? CGPoint(x: 0, y: 1) : CGPoint(x: 1, y: 0.5) } else { gradientLayer.startPoint = diagonalMode ? CGPoint(x: 0, y: 0) : CGPoint(x: 0.5, y: 0) gradientLayer.endPoint = diagonalMode ? CGPoint(x: 1, y: 1) : CGPoint(x: 0.5, y: 1) } } func updateLocations() { gradientLayer.locations = [startLocation as NSNumber, endLocation as NSNumber] } func updateColors() { gradientLayer.colors = [startColor.cgColor, endColor.cgColor] } override func layoutSubviews() { super.layoutSubviews() updatePoints() updateLocations() updateColors() } }
let gradient: CAGradientLayer = CAGradientLayer() gradient.colors = [UIColor.blue.cgColor, UIColor.red.cgColor] gradient.locations = [0.0 , 1.0] gradient.startPoint = CGPoint(x: 0.0, y: 1.0) gradient.endPoint = CGPoint(x: 1.0, y: 1.0) gradient.frame = CGRect(x: 0.0, y: 0.0, width: self.view.frame.size.width, height: self.view.frame.size.height) self.view.layer.insertSublayer(gradient, atIndex: 0)
func setGradientBackground() { let colorTop = UIColor(red: 255.0/255.0, green: 149.0/255.0, blue: 0.0/255.0, alpha: 1.0).CGColor let colorBottom = UIColor(red: 255.0/255.0, green: 94.0/255.0, blue: 58.0/255.0, alpha: 1.0).CGColor let gradientLayer = CAGradientLayer() gradientLayer.colors = [colorTop, colorBottom] gradientLayer.locations = [0.0, 1.0] gradientLayer.frame = self.view.bounds self.view.layer.insertSublayer(gradientLayer) }
func addGradient(){ let gradient:CAGradientLayer = CAGradientLayer() gradient.frame.size = self.viewThatHoldsGradient.frame.size gradient.colors = [UIColor.white.cgColor,UIColor.white.withAlphaComponent(0).cgColor] self.viewThatHoldsGradient.layer.addSublayer(gradient) }
extension UIView { func layerGradient() { let layer : CAGradientLayer = CAGradientLayer() layer.frame.size = self.frame.size layer.frame.origin = CGPointMake(0.0,0.0) layer.cornerRadius = CGFloat(frame.width / 20) let color0 = UIColor(red:250.0/255, green:250.0/255, blue:250.0/255, alpha:0.5).CGColor let color1 = UIColor(red:200.0/255, green:200.0/255, blue: 200.0/255, alpha:0.1).CGColor let color2 = UIColor(red:150.0/255, green:150.0/255, blue: 150.0/255, alpha:0.1).CGColor let color3 = UIColor(red:100.0/255, green:100.0/255, blue: 100.0/255, alpha:0.1).CGColor let color4 = UIColor(red:50.0/255, green:50.0/255, blue:50.0/255, alpha:0.1).CGColor let color5 = UIColor(red:0.0/255, green:0.0/255, blue:0.0/255, alpha:0.1).CGColor let color6 = UIColor(red:150.0/255, green:150.0/255, blue:150.0/255, alpha:0.1).CGColor layer.colors = [color0,color1,color2,color3,color4,color5,color6] self.layer.insertSublayer(layer, atIndex: 0) } }
@IBDesignable class GradientView: UIView { @IBInspectable var firstColor: UIColor = UIColor.red @IBInspectable var secondColor: UIColor = UIColor.green @IBInspectable var vertical: Bool = true lazy var gradientLayer: CAGradientLayer = { let layer = CAGradientLayer() layer.colors = [firstColor.cgColor, secondColor.cgColor] layer.startPoint = CGPoint.zero return layer }() required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) applyGradient() } override init(frame: CGRect) { super.init(frame: frame) applyGradient() } override func prepareForInterfaceBuilder() { super.prepareForInterfaceBuilder() applyGradient() } override func layoutSubviews() { super.layoutSubviews() updateGradientFrame() } func applyGradient() { updateGradientDirection() layer.sublayers = [gradientLayer] } func updateGradientFrame() { gradientLayer.frame = bounds } func updateGradientDirection() { gradientLayer.endPoint = vertical ? CGPoint(x: 0, y: 1) : CGPoint(x: 1, y: 0) } } @IBDesignable class ThreeColorsGradientView: UIView { @IBInspectable var firstColor: UIColor = UIColor.red @IBInspectable var secondColor: UIColor = UIColor.green @IBInspectable var thirdColor: UIColor = UIColor.blue @IBInspectable var vertical: Bool = true { didSet { updateGradientDirection() } } lazy var gradientLayer: CAGradientLayer = { let layer = CAGradientLayer() layer.colors = [firstColor.cgColor, secondColor.cgColor, thirdColor.cgColor] layer.startPoint = CGPoint.zero return layer }() required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) applyGradient() } override init(frame: CGRect) { super.init(frame: frame) applyGradient() } override func prepareForInterfaceBuilder() { super.prepareForInterfaceBuilder() applyGradient() } override func layoutSubviews() { super.layoutSubviews() updateGradientFrame() } func applyGradient() { updateGradientDirection() layer.sublayers = [gradientLayer] } func updateGradientFrame() { gradientLayer.frame = bounds } func updateGradientDirection() { gradientLayer.endPoint = vertical ? CGPoint(x: 0, y: 1) : CGPoint(x: 1, y: 0) } } @IBDesignable class RadialGradientView: UIView { @IBInspectable var outsideColor: UIColor = UIColor.red @IBInspectable var insideColor: UIColor = UIColor.green override func awakeFromNib() { super.awakeFromNib() applyGradient() } func applyGradient() { let colors = [insideColor.cgColor, outsideColor.cgColor] as CFArray let endRadius = sqrt(pow(frame.width/2, 2) + pow(frame.height/2, 2)) let center = CGPoint(x: bounds.size.width / 2, y: bounds.size.height / 2) let gradient = CGGradient(colorsSpace: nil, colors: colors, locations: nil) let context = UIGraphicsGetCurrentContext() context?.drawRadialGradient(gradient!, startCenter: center, startRadius: 0.0, endCenter: center, endRadius: endRadius, options: CGGradientDrawingOptions.drawsBeforeStartLocation) } override func draw(_ rect: CGRect) { super.draw(rect) applyGradient() } }
var gradientView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 35)) let gradientLayer:CAGradientLayer = CAGradientLayer() gradientLayer.frame.size = self.gradientView.frame.size gradientLayer.colors = [UIColor.white.cgColor,UIColor.red.withAlphaComponent(1).cgColor] gradientView.layer.addSublayer(gradientLayer)
gradientLayer.startPoint = CGPoint(x: 0.0, y: 1.0) gradientLayer.endPoint = CGPoint(x: 1.0, y: 1.0)
import UIKit class GradientView: UIView { var colors:[UIColor] = [UIColor.redColor(), UIColor.blueColor()] override func drawRect(rect: CGRect) { setGradient(colors[0], color2: colors[1]) } func setGradient(color1: UIColor, color2: UIColor) { let context = UIGraphicsGetCurrentContext() let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [color1.CGColor, color2.CGColor], [0, 1])! let path = UIBezierPath(rect: CGRectMake(0, 0, frame.width, frame.height)) CGContextSaveGState(context) path.addClip() CGContextDrawLinearGradient(context, gradient, CGPointMake(frame.width / 2, 0), CGPointMake(frame.width / 2, frame.height), CGGradientDrawingOptions()) CGContextRestoreGState(context) } override func layoutSubviews() { backgroundColor = UIColor.clearColor() } }
class GradientView: UIView { override open class var layerClass: AnyClass { get{ return CAGradientLayer.classForCoder() } } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) let gradientLayer = self.layer as! CAGradientLayer let color1 = UIColor.white.withAlphaComponent(0.1).cgColor as CGColor let color2 = UIColor.white.withAlphaComponent(0.9).cgColor as CGColor gradientLayer.locations = [0.60, 1.0] gradientLayer.colors = [color2, color1] } }
import UIKit extension UIColor { convenience init(rgba: String) { var red: CGFloat = 0.0 var green: CGFloat = 0.0 var blue: CGFloat = 0.0 var alpha: CGFloat = 1.0 if rgba.hasPrefix(" let index = advance(rgba.startIndex, 1) let hex = rgba.substringFromIndex(index) let scanner = NSScanner(string: hex) var hexValue: CUnsignedLongLong = 0 if scanner.scanHexLongLong(&hexValue) { switch (count(hex)) { case 3: red = CGFloat((hexValue & 0xF00) >> 8) / 15.0 green = CGFloat((hexValue & 0x0F0) >> 4) / 15.0 blue = CGFloat(hexValue & 0x00F) / 15.0 case 4: red = CGFloat((hexValue & 0xF000) >> 12) / 15.0 green = CGFloat((hexValue & 0x0F00) >> 8) / 15.0 blue = CGFloat((hexValue & 0x00F0) >> 4) / 15.0 alpha = CGFloat(hexValue & 0x000F) / 15.0 case 6: red = CGFloat((hexValue & 0xFF0000) >> 16) / 255.0 green = CGFloat((hexValue & 0x00FF00) >> 8) / 255.0 blue = CGFloat(hexValue & 0x0000FF) / 255.0 case 8: red = CGFloat((hexValue & 0xFF000000) >> 24) / 255.0 green = CGFloat((hexValue & 0x00FF0000) >> 16) / 255.0 blue = CGFloat((hexValue & 0x0000FF00) >> 8) / 255.0 alpha = CGFloat(hexValue & 0x000000FF) / 255.0 default: print("Invalid RGB string, number of characters after } } else { println("Scan hex error") } } else { print("Invalid RGB string, missing } self.init(red:red, green:green, blue:blue, alpha:alpha) } }
class Colors { let colorTop = UIColor(rgba: " let colorBottom = UIColor(rgba: " let gl: CAGradientLayer init() { gl = CAGradientLayer() gl.colors = [ colorTop, colorBottom] gl.locations = [ 0.0, 1.0] } }
func refresh() { view.backgroundColor = UIColor.clearColor() var backgroundLayer = colors.gl backgroundLayer.frame = view.frame view.layer.insertSublayer(backgroundLayer, atIndex: 0) }
import Foundation import SpriteKit class GradientSpriteNode : SKSpriteNode { convenience init(size: CGSize, colors: [UIColor], locations: [CGFloat]) { let texture = GradientSpriteNode.texture(size: size, colors: colors, locations: locations) self.init(texture: texture, color:SKColor.clear, size: texture.size()) } private override init(texture: SKTexture!, color: SKColor, size: CGSize) { super.init(texture: texture, color: color, size: size) } required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } private static func texture(size: CGSize, colors: [UIColor], locations: [CGFloat]) -> SKTexture { UIGraphicsBeginImageContext(size) let context = UIGraphicsGetCurrentContext()! let gradient = CGGradient(colorsSpace: CGColorSpaceCreateDeviceRGB(), colors: colors.map{$0.cgColor} as CFArray, locations: locations)! context.drawLinearGradient(gradient, start: CGPoint(x: size.width / 2, y: 0), end: CGPoint(x: size.width / 2, y: size.height), options: CGGradientDrawingOptions()) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return SKTexture(image: image!) } }
let gradient = GradientSpriteNode( size: CGSize(width: 100, height: 100), colors: [UIColor.red, UIColor.blue], locations: [0.0, 1.0]) addChild(gradient)
func setGradient() { let gradient: CAGradientLayer = CAGradientLayer() gradient.colors = [UIColor.red.cgColor, UIColor.blue.cgColor] gradient.locations = [0.0 , 1.0] gradient.startPoint = CGPoint(x: 0.0, y: 1.0) gradient.endPoint = CGPoint(x: 1.0, y: 1.0) gradient.frame = gradientView.layer.frame gradientView.layer.insertSublayer(gradient, at: 0) }
func makeGradientColor(`for` object : AnyObject , startPoint : CGPoint , endPoint : CGPoint) -> CAGradientLayer { let gradient: CAGradientLayer = CAGradientLayer() gradient.colors = [(UIColor(red: 59.0/255.0, green: 187.0/255.0, blue: 182.0/255.0, alpha: 1.00).cgColor), (UIColor(red: 57.0/255.0, green: 174.0/255.0, blue: 236.0/255.0, alpha: 1.00).cgColor)] gradient.locations = [0.0 , 1.0] gradient.startPoint = startPoint gradient.endPoint = endPoint gradient.frame = CGRect(x: 0.0, y: 0.0, width: object.frame.size.width, height: object.frame.size.height) return gradient }
let start : CGPoint = CGPoint(x: 0.0, y: 1.0) let end : CGPoint = CGPoint(x: 1.0, y: 1.0) let gradient: CAGradientLayer = self.makeGradientColor(for: vwTop, startPoint: start, endPoint: end) vwTop.layer.insertSublayer(gradient, at: 0) let start1 : CGPoint = CGPoint(x: 1.0, y: 1.0) let end1 : CGPoint = CGPoint(x: 1.0, y: 0.0) let gradient1: CAGradientLayer = self.makeGradientColor(for: vwTop, startPoint: start1, endPoint: end1) vwBottom.layer.insertSublayer(gradient1, at: 0)
extension UIView { /** Given an Array of CGColor, it will: - Remove all sublayers of type CAGradientLayer. - Create and insert a new CAGradientLayer. - Parameters: - colors: An Array of CGColor with the colors for the gradient fill - Returns: The newly created gradient CAGradientLayer */ func layerGradient(colors c:[CGColor])->CAGradientLayer { self.layer.sublayers = self.layer.sublayers?.filter(){!($0 is CAGradientLayer)} let layer : CAGradientLayer = CAGradientLayer() layer.frame.size = self.frame.size layer.frame.origin = CGPointZero layer.colors = c self.layer.insertSublayer(layer, atIndex: 0) return layer } }
let firstColor = UIColor(red: 69/255, green: 90/255, blue: 195/255, alpha: 1.0).CGColor let secondColor = UIColor(red: 230/255, green: 44/255, blue: 75/255, alpha: 1.0).CGColor let gradientLayer = CAGradientLayer() gradientLayer.colors = [ firstColor, secondColor] gradientLayer.locations = [ 0.0, 1.0] gradientLayer.frame = CGRectMake(0, 0, 375, 64) self.view.layer.addSublayer(gradientLayer)
class GradientLayer { let gradientLayer: CAGradientLayer let colorTop: CGColor let colorBottom: CGColor init(colorTop: UIColor, colorBottom: UIColor) { self.colorTop = colorTop.CGColor self.colorBottom = colorBottom.CGColor gradientLayer = CAGradientLayer() gradientLayer.colors = [colorTop, colorBottom] gradientLayer.locations = [0.0, 1.0] } }
import Foundation import UIKit class UI_Util { static func setGradientGreenBlue(uiView: UIView) { let colorTop = UIColor(red: 15.0/255.0, green: 118.0/255.0, blue: 128.0/255.0, alpha: 1.0).cgColor let colorBottom = UIColor(red: 84.0/255.0, green: 187.0/255.0, blue: 187.0/255.0, alpha: 1.0).cgColor let gradientLayer = CAGradientLayer() gradientLayer.colors = [ colorTop, colorBottom] gradientLayer.locations = [ 0.0, 1.0] gradientLayer.frame = uiView.bounds uiView.layer.insertSublayer(gradientLayer, at: 0) } }
class AbcViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() UI_Util.setGradientGreen(uiView: self.view) }
extension CALayer { func addGradienBorder(colors:[UIColor] = [UIColor.red,UIColor.blue], width:CGFloat = 1) { let gradientLayer = CAGradientLayer() gradientLayer.frame = CGRect(origin: .zero, size: self.bounds.size) gradientLayer.startPoint = CGPoint(x:0.0, y:0.5) gradientLayer.endPoint = CGPoint(x:1.0, y:0.5) gradientLayer.colors = colors.map({$0.cgColor}) let shapeLayer = CAShapeLayer() shapeLayer.lineWidth = width shapeLayer.path = UIBezierPath(rect: self.bounds).cgPath shapeLayer.fillColor = nil shapeLayer.strokeColor = UIColor.black.cgColor gradientLayer.mask = shapeLayer self.addSublayer(gradientLayer) } }
yourView.addGradienBorder(color: UIColor.black, opacity: 0.1, offset: CGSize(width:2 , height: 5), radius: 3, viewCornerRadius: 3.0)
func setGradientBackground() { let v:UIView for v in viewgradian { let layer:CALayer var arr = [AnyObject]() for layer in v.layer.sublayers! { arr.append(layer) } let colorTop = UIColor(red: 216.0/255.0, green: 240.0/255.0, blue: 244.0/255.0, alpha: 1.0).cgColor let colorBottom = UIColor(red: 255.0/255.0, green: 255.0/255.0, blue: 255.0/255.0, alpha: 1.0).cgColor let gradientLayer = CAGradientLayer() gradientLayer.colors = [ colorBottom, colorTop] gradientLayer.startPoint = CGPoint(x: 1.0, y: 0.0) gradientLayer.endPoint = CGPoint(x: 0.0, y: 1.0) gradientLayer.frame = v.bounds v.layer.insertSublayer(gradientLayer, at: 0) } }
class GradientView: UIView { private let gradient: CAGradientLayer = { let layer = CAGradientLayer() let topColor: UIColor = UIColor(red:0.98, green:0.96, blue:0.93, alpha:0.5) let bottomColor: UIColor = UIColor.white layer.colors = [topColor.cgColor, bottomColor.cgColor] layer.locations = [0,1] return layer }() init() { super.init(frame: .zero) gradient.frame = frame layer.insertSublayer(gradient, at: 0) } required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } override func layoutSubviews() { super.layoutSubviews() gradient.frame = bounds } }
extension UIView { func setGradient(from color1: UIColor, to color2: UIColor) { let gradient: CAGradientLayer = CAGradientLayer() gradient.colors = [color1.cgColor, color2.cgColor] gradient.startPoint = CGPoint(x: 0.0, y: 0.0) gradient.endPoint = CGPoint(x: 1, y: 1) gradient.frame = self.layer.frame self.layer.insertSublayer(gradient, at: 0) }
deinit { print("deinit") removeObserver(self, forKeyPath: kSelectedViewControllerKey, context: nil) removeObserver(self, forKeyPath: kSelectedIndexKey, context: nil) }
// // import UIKit class TextViewTableViewCell: UITableViewCell, UITextViewDelegate { @IBOutlet var textView : UITextView var onTextViewEditClosure : ((text : String) -> Void)? func configure( onTextViewEditClosure = onTextEdit textView.delegate = self textView.text = text } func textViewDidEndEditing(textView: UITextView!) { if onTextViewEditClosure { onTextViewEditClosure!(text: textView.text) } } }
let myCell = tableView.dequeueReusableCellWithIdentifier(textViewCellIdenfitier) as TextViewTableViewCell myCell.configure(text: body, onTextEdit: {(text: String) in self.body = text }) cell = bodyCell
let myCell = tableView.dequeueReusableCellWithIdentifier(textViewCellIdenfitier) as TextViewTableViewCell myCell.configure(text: body, onTextEdit: {[weak self] (text: String) in if let strongSelf = self { strongSelf.body = text } }) cell = myCell
lazy var someClosure: (Int, String) -> String = { [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in }
lazy var someClosure: Void -> String = { [unowned self, weak delegate = self.delegate!] in }
guard let `self` = self else { return } self.doSomething()
input.action = { [weak self] value in guard let this = self else { return } this.someCall(value) }
input.action = { [weak self] value in self?.someCall(value) }
input.action = { [weak self] in self?.someCall($0) }
_ = { [weak self] value in guard let strongSelf = self else { return } print(strongSelf) }()
func prepareForResuse() { onTextViewEditClosure = nil textView.delegate = nil }
protocol Employee { var annualSalary: Int {get} } extension Employee { var biweeklySalary: Int { return self.annualSalary / 26 } func logSalary() { print("$\(self.annualSalary) per year or $\(self.biweeklySalary) biweekly") } } struct SoftwareEngineer: Employee { var annualSalary: Int func logSalary() { print("overridden") } } let sarah = SoftwareEngineer(annualSalary: 100000) sarah.logSalary() (sarah as Employee).logSalary()
extension Drivable { func accelerate(by: Float) { speed += by } }
struct Car: Drivable { var speed: Float = 0.0 init() {} } let c = Car() c.accelerate(10)
public class AbstractClass: NSObject { internal override init(){} public func getFoodToEat()->String { if(self._iAmHungry()) { return self._myFavoriteFood(); }else{ return ""; } } private func _myFavoriteFood()->String { return "Sandwich"; } internal func _iAmHungry()->Bool { fatalError(__FUNCTION__ + "Must be overridden"); return false; } } public class ConcreteClass: AbstractClass, IConcreteClass { private var _hungry: Bool = false; public override init() { super.init(); } public func starve()->Void { self._hungry = true; } public override func _iAmHungry()->Bool { return self._hungry; } } public protocol IConcreteClass { func _iAmHungry()->Bool; } class ConcreteClassTest: XCTestCase { func testExample() { var concreteClass: ConcreteClass = ConcreteClass(); XCTAssertEqual("", concreteClass.getFoodToEat()); concreteClass.starve(); XCTAssertEqual("Sandwich", concreteClass.getFoodToEat()); } }
import UIKit public class GoldenSpoonChild { private var delegate: IStomach!; internal init(){} internal func setup(delegate: IStomach) { self.delegate = delegate; } public func getFoodToEat()->String { if(self.delegate.iAmHungry()) { return self._myFavoriteFood(); }else{ return ""; } } private func _myFavoriteFood()->String { return "Sandwich"; } } public class Mother: GoldenSpoonChild, IStomach { private var _hungry: Bool = false; public override init() { super.init(); super.setup(self); } public func makeFamilyHungry()->Void { self._hungry = true; } public func iAmHungry()->Bool { return self._hungry; } } protocol IStomach { func iAmHungry()->Bool; } class DelegateTest: XCTestCase { func testGetFood() { var concreteClass: Mother = Mother(); XCTAssertEqual("", concreteClass.getFoodToEat()); concreteClass.makeFamilyHungry(); XCTAssertEqual("Sandwich", concreteClass.getFoodToEat()); } }
protocol MyInterface { func myMethod() -> String } extension MyInterface { func myMethod() -> String { fatalError("Not Implemented") } } class MyConcreteClass: MyInterface { func myMethod() -> String { return "The output" } } MyConcreteClass().myMethod()
protocol MyProtocol { func doIt() } class BaseClass { var myDelegate: MyProtocol! init() { ... } func myFunc() { ... self.myDelegate.doIt() ... } } class ChildClass: BaseClass, MyProtocol { override init(){ super.init() self.myDelegate = self } func doIt() { } }
class Element:CALayer { override init(){ super.init() if self.dynamicType === Element.self { fatalError("Element is abstract class, do not try to create instance of this class") } } }
required init?(coder aDecoder: NSCoder) { guard type(of: self) != Weather.self else { fatalError("<Weather> This is an abstract class. Use a subclass of `Weather`.") } }
protocol Commom:class{ var tableView:UITableView {get}; func update(); } class Base{ var total:Int = 0; } extension Common where Self:Base{ func update(){ total += 1; tableView.reloadData(); } } class Derived:Base,Common{ var tableView:UITableView{ return owner.tableView; } }
import Foundation protocol foo { static var instance: foo? { get } func prt() } extension foo { func prt() { if Thread.callStackSymbols.count > 30 { print("super") } else { Self.instance?.prt() } } } class foo1 : foo { static var instance : foo? = nil init() { foo1.instance = self } func prt() { print("foo1") } } class foo2 : foo { static var instance : foo? = nil init() { foo2.instance = self } func prt() { print("foo2") } } class foo3 : foo { static var instance : foo? = nil init() { foo3.instance = self } } var f1 : foo = foo1() f1.prt() var f2 : foo = foo2() f2.prt() var f3 : foo = foo3() f3.prt()
enum City: Int { case Melbourne = 1, Chelyabinsk, Bursa } let city = City.Melbourne
println("Your city is \(city.magicFunction)") > Your city is Melbourne
enum City: Int { case Melbourne = 1, Chelyabinsk, Bursa } let city = City.Melbourne print(city) let cityName = "\(city)"
debugPrint(city) let cityDebugName = String(reflecting: city)
extension City: CustomStringConvertible { var description: String { return "City \(rawValue)" } } print(city) extension City: CustomDebugStringConvertible { var debugDescription: String { return "City (rawValue: \(rawValue))" } } debugPrint(city)
extension String { public init<T>(_ instance: T) public init<T>(reflecting subject: T) }
enum City : String, Printable { case Melbourne = "Melbourne" case Chelyabinsk = "Chelyabinsk" case Bursa = "Bursa" var description : String { get { return self.rawValue } } }
enum City : Int, Printable { case Melbourne = 1, Chelyabinsk, Bursa var description : String { get { switch(self) { case Melbourne: return "Melbourne" case Chelyabinsk: return "Chelyabinsk" case Bursa: return "Bursa" } } } }
/** * The name of the enumeration (as written in case). */ var name: String { get { return String(describing: self) } } /** * The full name of the enumeration * (the name of the enum plus dot plus the name as written in case). */ var description: String { get { return String(reflecting: self) } }
enum City: Int { case Melbourne = 1, Chelyabinsk, Bursa var name: String { get { return String(describing: self) } } var description: String { get { return String(reflecting: self) } } } let city = City.Melbourne print(city.name) print(city.description)
/** * Extend all enums with a simple method to derive their names. */ extension RawRepresentable where RawValue: Any { /** * The name of the enumeration (as written in case). */ var name: String { get { return String(describing: self) } } /** * The full name of the enumeration * (the name of the enum plus dot plus the name as written in case). */ var description: String { get { return String(reflecting: self) } } }
extension UIDeviceBatteryState: CustomStringConvertible { public var description: String { switch self { case Unknown: return "Unknown" case Unplugged: return "Unplugged" case Charging: return "Charging" case Full: return "Full" } } }
enum ViewType : Int, Printable { case Title case Buttons case View static let all = [Title, Buttons, View] static let strings = ["Title", "Buttons", "View"] func string() -> String { return ViewType.strings[self.rawValue] } var description:String { get { return string() } } }
let elementType = ViewType.Title let column = Column.Collections let row = 0 println("fetching element \(elementType), column: \(column.string()), row: \(row)")
fetching element Title, column: Collections, row: 0
enum City { case Melbourne(String) case Chelyabinsk case Bursa var label:String? { let mirror = Mirror(reflecting: self) return mirror.children.first?.label } } print(City.Melbourne("Foobar").label)
enum ViewType : Int { case Title case Buttons case View } func printEnumValue(enum: ViewType) { switch enum { case .Title: println("ViewType.Title") case .Buttons: println("ViewType.Buttons") case .View: println("ViewType.View") } }
enum City: String { case Melbourne, Chelyabinsk, Bursa } let city = City.Melbourne.rawValue
let entity = NSEntityDescription.entityForName("User", inManagedObjectContext: appDelegate.managedObjectContext) let user = User(entity: entity, insertIntoManagedObjectContext: appDelegate.managedObjectContext)
lazy var managedObjectModel: NSManagedObjectModel = { let modelURL = NSBundle.mainBundle().URLForResource("Streak", withExtension: "momd")! let managedObjectModel = NSManagedObjectModel(contentsOfURL: modelURL)! let environment = NSProcessInfo.processInfo().environment as [String : AnyObject] let isTest = (environment["XCInjectBundle"] as? String)?.pathExtension == "xctest" let moduleName = (isTest) ? "StreakTests" : "Streak" var newEntities = [] as [NSEntityDescription] for (_, entity) in enumerate(managedObjectModel.entities) { let newEntity = entity.copy() as NSEntityDescription newEntity.managedObjectClassName = "\(moduleName).\(entity.name)" newEntities.append(newEntity) } let newManagedObjectModel = NSManagedObjectModel() newManagedObjectModel.entities = newEntities return newManagedObjectModel }()
public enum MyError: Error { case customError var localizedDescription: String { switch self { case .customError: return NSLocalizedString("A user-friendly description of the error.", comment: "My error") } } } let error: Error = MyError.customError error.localizedDescription
public enum MyError: Error { case customError } extension MyError: LocalizedError { public var errorDescription: String? { switch self { case .customError: return NSLocalizedString("A user-friendly description of the error.", comment: "My error") } } } let error: Error = MyError.customError print(error.localizedDescription)
extension MyError : LocalizedError { public var errorDescription: String? { switch self { case .customError: return NSLocalizedString("I failed.", comment: "") } } public var failureReason: String? { switch self { case .customError: return NSLocalizedString("I don } } public var recoverySuggestion: String? { switch self { case .customError: return NSLocalizedString("Switch it off and on again.", comment: "") } } } let error = MyError.customError as NSError print(error.localizedDescription) print(error.localizedFailureReason) print(error.localizedRecoverySuggestion)
extension MyError: CustomNSError { public static var errorDomain: String { return "myDomain" } public var errorCode: Int { switch self { case .customError: return 999 } } public var errorUserInfo: [String : Any] { switch self { case .customError: return [ "line": 13] } } } let error = MyError.customError as NSError if let line = error.userInfo["line"] as? Int { print("Error in line", line) } print(error.code) print(error.domain)
enum NetworkError: LocalizedError { case responseStatusError(status: Int, message: String) }
extension NetworkError { var errorDescription: String { switch self { case .responseStatusError(status: let status, message: let message): return "Error with status \(status) and message \(message) was thrown" } }
extension NetworkError { var errorDescription: String { switch self { case let .responseStatusError(status, message): return "Error with status \(status) and message \(message) was thrown" } }
enum MyBetterError : CustomNSError, LocalizedError { case oops static var errorDomain : String { return "MyDomain" } var errorCode : Int { return -666 } var errorUserInfo: [String : Any] { return ["Hey":"Ho"] }; var errorDescription: String? { return "This sucks" } var failureReason: String? { return "Because it sucks" } var recoverySuggestion: String? { return "Give up" } }
enum ApiError: String, LocalizedError { case invalidCredentials = "Invalid credentials" case noConnection = "No connection" var localizedDescription: String { return NSLocalizedString(self.rawValue, comment: "") } }
import Foundation struct MyError: LocalizedError, Equatable { private var description: String! init(description: String) { self.description = description } var errorDescription: String? { return description } public static func ==(lhs: MyError, rhs: MyError) -> Bool { return lhs.description == rhs.description } } extension MyError { static let noConnection = MyError(description: NSLocalizedString("No internet connection",comment: "")) static let requestFailed = MyError(description: NSLocalizedString("Request failed",comment: "")) } func throwNoConnectionError() throws { throw MyError.noConnection } do { try throwNoConnectionError() } catch let myError as MyError { switch myError { case .noConnection: print("noConnection: \(myError.localizedDescription)") case .requestFailed: print("requestFailed: \(myError.localizedDescription)") default: print("default: \(myError.localizedDescription)") } }
var postJSON = [ids[0]:answersArray[0], ids[1]:answersArray[1], ids[2]:answersArray[2]] as Dictionary
let dic = ["2": "B", "1": "A", "3": "C"] do { let jsonData = try JSONSerialization.data(withJSONObject: dic, options: .prettyPrinted) let decoded = try JSONSerialization.jsonObject(with: jsonData, options: []) if let dictFromJSON = decoded as? [String:String] { } } catch { print(error.localizedDescription) }
do { let jsonData = try NSJSONSerialization.dataWithJSONObject(dic, options: NSJSONWritingOptions.PrettyPrinted) let decoded = try NSJSONSerialization.JSONObjectWithData(jsonData, options: []) if let dictFromJSON = decoded as? [String:String] { } } catch let error as NSError { print(error) }
var error: NSError? if let jsonData = NSJSONSerialization.dataWithJSONObject(dic, options: NSJSONWritingOptions.PrettyPrinted, error: &error) { if error != nil { println(error) } else { } } if let decoded = NSJSONSerialization.JSONObjectWithData(jsonData, options: nil, error: &error) as? [String:String] { if error != nil { println(error) } else { } }
import Foundation let dictionary = ["aKey": "aValue", "anotherKey": "anotherValue"] if let theJSONData = try? JSONSerialization.data( withJSONObject: dictionary, options: []) { let theJSONText = String(data: theJSONData, encoding: .ascii) print("JSON string = \(theJSONText!)") }
import Foundation let dictionary = ["aKey": "aValue", "anotherKey": "anotherValue"] let theJSONData = NSJSONSerialization.dataWithJSONObject( dictionary , options: NSJSONWritingOptions(0), error: nil) let theJSONText = NSString(data: theJSONData!, encoding: NSASCIIStringEncoding) println("JSON string = \(theJSONText!)")
"JSON string = {"anotherKey":"anotherValue","aKey":"aValue"}"
{ "anotherKey" : "anotherValue", "aKey" : "aValue" }
let dictionary = ["aKey": "aValue", "anotherKey": "anotherValue"] if let theJSONData = try? JSONSerialization.data( withJSONObject: dictionary, options: .prettyPrinted ), let theJSONText = String(data: theJSONData, encoding: String.Encoding.ascii) { print("JSON string = \n\(theJSONText)") } }
let dict = ["0": "ArrayObjectOne", "1": "ArrayObjecttwo", "2": "ArrayObjectThree"] var error : NSError? let jsonData = try! NSJSONSerialization.dataWithJSONObject(dict, options: NSJSONWritingOptions.PrettyPrinted) let jsonString = NSString(data: jsonData, encoding: NSUTF8StringEncoding)! as String print(jsonString)
{ "0" : "ArrayObjectOne", "1" : "ArrayObjecttwo", "2" : "ArrayObjectThree" }
extension Dictionary { var json: String { let invalidJson = "Not a valid JSON" do { let jsonData = try JSONSerialization.data(withJSONObject: self, options: .prettyPrinted) return String(bytes: jsonData, encoding: String.Encoding.utf8) ?? invalidJson } catch { return invalidJson } } func printJson() { print(json) } }
(lldb) po dictionary.printJson() { "InviteId" : 2, "EventId" : 13591, "Messages" : [ { "SenderUserId" : 9514, "MessageText" : "test", "RecipientUserId" : 9470 }, { "SenderUserId" : 9514, "MessageText" : "test", "RecipientUserId" : 9470 } ], "TargetUserId" : 9470, "InvitedUsers" : [ 9470 ], "InvitingUserId" : 9514, "WillGo" : true, "DateCreated" : "2016-08-24 14:01:08 +00:00" }
let dic = ["2": "B", "1": "A", "3": "C"] let encoder = JSONEncoder() if let jsonData = try? encoder.encode(dic) { if let jsonString = String(data: jsonData, encoding: .utf8) { print(jsonString) } }
let jsonData = try? JSONSerialization.data(withJSONObject: dict, options: []) let jsonString = String(data: jsonData!, encoding: .utf8)! print(jsonString)
do { if let postData : NSData = try NSJSONSerialization.dataWithJSONObject(dictDataToBeConverted, options: NSJSONWritingOptions.PrettyPrinted){ let json = NSString(data: postData, encoding: NSUTF8StringEncoding)! as String print(json)} } catch { print(error) }
extension Dictionary { func jsonString() -> NSString? { let jsonData = try? JSONSerialization.data(withJSONObject: self, options: []) guard jsonData != nil else {return nil} let jsonString = String(data: jsonData!, encoding: .utf8) guard jsonString != nil else {return nil} return jsonString! as NSString } }
extension Dictionary { var jsonStringRepresentaiton: String? { guard let theJSONData = try? JSONSerialization.data(withJSONObject: self, options: [.prettyPrinted]) else { return nil } return String(data: theJSONData, encoding: .ascii) } }
private func convertDictToJson(dict : NSDictionary) -> NSDictionary? { var jsonDict : NSDictionary! do { let jsonData = try JSONSerialization.data(withJSONObject:dict, options:[]) let jsonDataString = String(data: jsonData, encoding: String.Encoding.utf8)! print("Post Request Params : \(jsonDataString)") jsonDict = [ParameterKey : jsonDataString] return jsonDict } catch { print("JSON serialization failed: \(error)") jsonDict = nil } return jsonDict }
let text = "Long paragraph saying something goes here!" let textRange = text.startIndex..<text.endIndex let attributedString = NSMutableAttributedString(string: text) text.enumerateSubstringsInRange(textRange, options: NSStringEnumerationOptions.ByWords, { (substring, substringRange, enclosingRange, stop) -> () in if (substring == "saying") { attributedString.addAttribute(NSForegroundColorAttributeName, value: NSColor.redColor(), range: substringRange) } })
let text = "üòÑüòÑüòÑLong paragraph saying!" let textRange = text.startIndex..<text.endIndex let attributedString = NSMutableAttributedString(string: text) text.enumerateSubstringsInRange(textRange, options: NSStringEnumerationOptions.ByWords, { (substring, substringRange, enclosingRange, stop) -> () in let start = distance(text.startIndex, substringRange.startIndex) let length = distance(substringRange.startIndex, substringRange.endIndex) let range = NSMakeRange(start, length) if (substring == "saying") { attributedString.addAttribute(NSForegroundColorAttributeName, value: NSColor.redColor(), range: range) } }) println(attributedString)
let text = "üòÑüòÑüòÑLong paragraph saying!" let nsText = text as NSString let textRange = NSMakeRange(0, nsText.length) let attributedString = NSMutableAttributedString(string: nsText) nsText.enumerateSubstringsInRange(textRange, options: NSStringEnumerationOptions.ByWords, { (substring, substringRange, enclosingRange, stop) -> () in if (substring == "saying") { attributedString.addAttribute(NSForegroundColorAttributeName, value: NSColor.redColor(), range: substringRange) } }) println(attributedString)
let text = "üòÑüòÑüòÑLong paragraph saying!" let nsText = text as NSString let textRange = NSMakeRange(0, nsText.length) let attributedString = NSMutableAttributedString(string: text) nsText.enumerateSubstringsInRange(textRange, options: .ByWords, usingBlock: { (substring, substringRange, _, _) in if (substring == "saying") { attributedString.addAttribute(NSForegroundColorAttributeName, value: NSColor.redColor(), range: substringRange) } }) print(attributedString)
let text = "üòÑüòÑüòÑLong paragraph saying!" let nsText = text as NSString let textRange = NSMakeRange(0, nsText.length) let attributedString = NSMutableAttributedString(string: text) nsText.enumerateSubstrings(in: textRange, options: .byWords, using: { (substring, substringRange, _, _) in if (substring == "saying") { attributedString.addAttribute(NSForegroundColorAttributeName, value: NSColor.red, range: substringRange) } }) print(attributedString)
let text = "üòÑüòÑüòÑLong paragraph saying!" let attributedString = NSMutableAttributedString(string: text) text.enumerateSubstrings(in: text.startIndex..<text.endIndex, options: .byWords) { (substring, substringRange, _, _) in if substring == "saying" { attributedString.addAttribute(.foregroundColor, value: NSColor.red, range: NSRange(substringRange, in: text)) } } print(attributedString)
let attributedString = NSMutableAttributedString(string: "follow the yellow brick road") let text = "follow the yellow brick road" let str = NSString(string: text) let theRange = str.rangeOfString("yellow") attributedString.addAttribute(NSForegroundColorAttributeName, value: UIColor.yellowColor(), range: theRange)
let text = "Long paragraph saying something goes here!" let textRange = text.startIndex..<text.endIndex let attributedString = NSMutableAttributedString(string: text) text.enumerateSubstringsInRange(textRange, options: NSStringEnumerationOptions.ByWords, { (substring, substringRange, enclosingRange, stop) -> () in let start = distance(text.startIndex, substringRange.startIndex) let length = distance(substringRange.startIndex, substringRange.endIndex) let range = NSMakeRange(start, length) if (substring == "saying") { attributedString.addAttribute(NSForegroundColorAttributeName, value: NSColor.redColor(), range: range) } })
let text = "Test string" let substring = "string" let substringRange = text.range(of: substring)! let nsRange = NSRange(substringRange, in: text)
public init<R, S>(_ region: R, in target: S) where R : RangeExpression, S : StringProtocol, R.Bound == String.Index, S.Index == String.Index
let string = "Many animals here: üê∂ü¶áüê± !!!" if let range = string.range(of: "üê∂ü¶áüê±"){ print((string as NSString).substring(with: NSRange(range, in: string))) }
extension NSRange { public init(_ range:Range<String.Index>) { self.init(location: range.lowerBound.encodedOffset, length: range.upperBound.encodedOffset - range.lowerBound.encodedOffset) } }
extension Range where Bound == String.Index { var nsRange:NSRange { return NSRange(location: self.lowerBound.encodedOffset, length: self.upperBound.encodedOffset - self.lowerBound.encodedOffset) } }
let string = "Many animals here: üê∂ü¶áüê± !!!" if let range = string.range(of: "üê∂ü¶áüê±"){ print((string as NSString).substring(with: NSRange(range))) }
if let nsrange = string.range(of: "üê∂ü¶áüê±")?.nsRange{ print((string as NSString).substring(with: nsrange)) }
let font = UIFont.systemFont(ofSize: 12, weight: .medium) let text = "text" let attString = NSMutableAttributedString(string: "exemple text :)") attString.addAttributes([.font: font], range:(attString.string as NSString).range(of: text)) label.attributedText = attString
extension UILabel { func setLineHeight(lineHeight: CGFloat) { guard self.text != nil && self.attributedText != nil else { return } var attributedString = NSMutableAttributedString() if let attributedText = self.attributedText { attributedString = NSMutableAttributedString(attributedString: attributedText) } else if let text = self.text { attributedString = NSMutableAttributedString(string: text) } let style = NSMutableParagraphStyle() style.lineSpacing = lineHeight style.alignment = self.textAlignment let str = NSString(string: attributedString.string) attributedString.addAttribute(NSParagraphStyleAttributeName, value: style, range: str.range(of: str as String)) self.attributedText = attributedString } }
func formatAttributedStringWithHighlights(text: String, highlightedSubString: String?, formattingAttributes: [String: AnyObject]) -> NSAttributedString { let mutableString = NSMutableAttributedString(string: text) let text = text as NSString if let highlightedSubString = highlightedSubString { let highlightedSubStringRange = text.rangeOfString(highlightedSubString) if highlightedSubStringRange.length > 0 { mutableString.setAttributes(formattingAttributes, range: highlightedSubStringRange) } } return mutableString }
extension String { func getRanges(of string: String) -> [NSRange] { var ranges:[NSRange] = [] if contains(string) { let words = self.components(separatedBy: " ") var position:Int = 0 for word in words { if word.lowercased() == string.lowercased() { let startIndex = position let endIndex = word.characters.count let range = NSMakeRange(startIndex, endIndex) ranges.append(range) } position += (word.characters.count + 1) } } return ranges } func highlight(_ words: [String], this color: UIColor) -> NSMutableAttributedString { let attributedString = NSMutableAttributedString(string: self) for word in words { let ranges = getRanges(of: word) for range in ranges { attributedString.addAttributes([NSForegroundColorAttributeName: color], range: range) } } return attributedString } }
let string = "The dog ran after the cat" let words = ["the", "ran"] let attributedString = string.highlight(words, this: .yellow) label.attributedText = attributedString
let attributedString = NSMutableAttributedString(string: "Sample Text 12345", attributes: [.font : UIFont.systemFont(ofSize: 15.0)]) if let range = attributedString.string.range(of: "Sample") { attributedString.addAttribute(.foregroundColor, value: UIColor.orange, range: NSRange(range, in: attributedString.string)) } if let range = attributedString.string.range(of: "12345") { attributedString.addAttribute(.foregroundColor, value: UIColor.green, range: NSRange(location: range.lowerBound.encodedOffset, length: range.upperBound.encodedOffset - range.lowerBound.encodedOffset)) }
let text:String = "Hello Friend" let searchRange:NSRange = NSRange(location:0,length: text.characters.count) let range:Range`<Int`> = Range`<Int`>.init(start: searchRange.location, end: searchRange.length)
for var index = 0; index < 3; index += 1 { print("index is \(index)") }
prefix operator ++ {} postfix operator ++ {} prefix operator -- {} postfix operator -- {} prefix func ++(inout x: Int) -> Int { x += 1 return x } postfix func ++(inout x: Int) -> Int { x += 1 return (x - 1) } prefix func ++(inout x: UInt) -> UInt { x += 1 return x } postfix func ++(inout x: UInt) -> UInt { x += 1 return (x - 1) } prefix func ++(inout x: Int8) -> Int8 { x += 1 return x } postfix func ++(inout x: Int8) -> Int8 { x += 1 return (x - 1) } prefix func ++(inout x: UInt8) -> UInt8 { x += 1 return x } postfix func ++(inout x: UInt8) -> UInt8 { x += 1 return (x - 1) } prefix func ++(inout x: Int16) -> Int16 { x += 1 return x } postfix func ++(inout x: Int16) -> Int16 { x += 1 return (x - 1) } prefix func ++(inout x: UInt16) -> UInt16 { x += 1 return x } postfix func ++(inout x: UInt16) -> UInt16 { x += 1 return (x - 1) } prefix func ++(inout x: Int32) -> Int32 { x += 1 return x } postfix func ++(inout x: Int32) -> Int32 { x += 1 return (x - 1) } prefix func ++(inout x: UInt32) -> UInt32 { x += 1 return x } postfix func ++(inout x: UInt32) -> UInt32 { x += 1 return (x - 1) } prefix func ++(inout x: Int64) -> Int64 { x += 1 return x } postfix func ++(inout x: Int64) -> Int64 { x += 1 return (x - 1) } prefix func ++(inout x: UInt64) -> UInt64 { x += 1 return x } postfix func ++(inout x: UInt64) -> UInt64 { x += 1 return (x - 1) } prefix func ++(inout x: Double) -> Double { x += 1 return x } postfix func ++(inout x: Double) -> Double { x += 1 return (x - 1) } prefix func ++(inout x: Float) -> Float { x += 1 return x } postfix func ++(inout x: Float) -> Float { x += 1 return (x - 1) } prefix func ++(inout x: Float80) -> Float80 { x += 1 return x } postfix func ++(inout x: Float80) -> Float80 { x += 1 return (x - 1) } prefix func ++<T : _Incrementable>(inout i: T) -> T { i = i.successor() return i } postfix func ++<T : _Incrementable>(inout i: T) -> T { let y = i i = i.successor() return y } prefix func --(inout x: Int) -> Int { x -= 1 return x } postfix func --(inout x: Int) -> Int { x -= 1 return (x + 1) } prefix func --(inout x: UInt) -> UInt { x -= 1 return x } postfix func --(inout x: UInt) -> UInt { x -= 1 return (x + 1) } prefix func --(inout x: Int8) -> Int8 { x -= 1 return x } postfix func --(inout x: Int8) -> Int8 { x -= 1 return (x + 1) } prefix func --(inout x: UInt8) -> UInt8 { x -= 1 return x } postfix func --(inout x: UInt8) -> UInt8 { x -= 1 return (x + 1) } prefix func --(inout x: Int16) -> Int16 { x -= 1 return x } postfix func --(inout x: Int16) -> Int16 { x -= 1 return (x + 1) } prefix func --(inout x: UInt16) -> UInt16 { x -= 1 return x } postfix func --(inout x: UInt16) -> UInt16 { x -= 1 return (x + 1) } prefix func --(inout x: Int32) -> Int32 { x -= 1 return x } postfix func --(inout x: Int32) -> Int32 { x -= 1 return (x + 1) } prefix func --(inout x: UInt32) -> UInt32 { x -= 1 return x } postfix func --(inout x: UInt32) -> UInt32 { x -= 1 return (x + 1) } prefix func --(inout x: Int64) -> Int64 { x -= 1 return x } postfix func --(inout x: Int64) -> Int64 { x -= 1 return (x + 1) } prefix func --(inout x: UInt64) -> UInt64 { x -= 1 return x } postfix func --(inout x: UInt64) -> UInt64 { x -= 1 return (x + 1) } prefix func --(inout x: Double) -> Double { x -= 1 return x } postfix func --(inout x: Double) -> Double { x -= 1 return (x + 1) } prefix func --(inout x: Float) -> Float { x -= 1 return x } postfix func --(inout x: Float) -> Float { x -= 1 return (x + 1) } prefix func --(inout x: Float80) -> Float80 { x -= 1 return x } postfix func --(inout x: Float80) -> Float80 { x -= 1 return (x + 1) } prefix func --<T : BidirectionalIndexType>(inout i: T) -> T { i = i.predecessor() return i } postfix func --<T : BidirectionalIndexType>(inout i: T) -> T { let y = i i = i.predecessor() return y }
for var index = 0; index < 3; index ++ { print("index is \(index)") }
for index in 0..<3 { print("index is \(index)") } for index in 0..<someArray.count { print("index is \(index)") } for index in 0...(someArray.count - 1) { print("index is \(index)") }
for var index = 3; index >= 0; --index { print(index) }
for index in 3.stride(to: 1, by: -1) { print(index) } for index in 3.stride(through: 1, by: -1) { print(index) } for index in (0 ..< 3).reverse() { print(index) } for index in (0 ... 3).reverse() { print(index) }
extension Int{ static prefix func ++(x: inout Int) -> Int { x += 1 return x } static postfix func ++(x: inout Int) -> Int { defer {x += 1} return x } static prefix func --(x: inout Int) -> Int { x -= 1 return x } static postfix func --(x: inout Int) -> Int { defer {x -= 1} return x } }
prefix operator ++ prefix operator -- prefix func ++<T: Numeric> (_ val: inout T) -> T { val += 1 return val } prefix func --<T: Numeric> (_ val: inout T) -> T { val -= 1 return val } postfix operator ++ postfix operator -- postfix func ++<T: Numeric> (_ val: inout T) -> T { defer { val += 1 } return val } postfix func --<T: Numeric> (_ val: inout T) -> T { defer { val -= 1 } return val }
var value : Int = 1 func theOldElegantWay() -> Int{ return value++ } func theNewFashionWay() -> Int{ let temp = value value += 1 return temp }
prefix operator ++ postfix operator ++ extension Int{ static prefix func ++(x: inout Int)->Int{ x += 1 return x } static postfix func ++(x: inout Int)->Int{ x += 1 return x-1 } } var t = 5 var s = t++ print("\(t) \(s)")
override func viewDidLoad() { super.viewDidLoad() let videoURLWithPath = "http: let videoURL = NSURL(string: videoURLWithPath) playerViewController = AVPlayerViewController() dispatch_async(dispatch_get_main_queue()) { self.playerViewController?.player = AVPlayer.playerWithURL(videoURL) as AVPlayer } }
let videoURL = URL(string: "https: let player = AVPlayer(url: videoURL!) let playerViewController = AVPlayerViewController() playerViewController.player = player self.present(playerViewController, animated: true) { playerViewController.player!.play() }
let videoURL = URL(string: "https: let player = AVPlayer(url: videoURL!) let playerLayer = AVPlayerLayer(player: player) playerLayer.frame = self.view.bounds self.view.layer.addSublayer(playerLayer) player.play()
NSURL *videoURL = [NSURL URLWithString:@"https: AVPlayer *player = [AVPlayer playerWithURL:videoURL]; AVPlayerViewController *playerViewController = [AVPlayerViewController new]; playerViewController.player = player; [self presentViewController:playerViewController animated:YES completion:nil];
NSURL *videoURL = [NSURL URLWithString:@"https: AVPlayer *player = [AVPlayer playerWithURL:videoURL]; AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player]; playerLayer.frame = self.view.bounds; [self.view.layer addSublayer:playerLayer]; [player play];
let player = AVPlayer(URL: url) let playerController = AVPlayerViewController() playerController.player = player self.addChildViewController(playerController) self.view.addSubview(playerController.view) playerController.view.frame = self.view.frame player.play()
var player:AVPlayer! var avPlayerLayer:AVPlayerLayer = AVPlayerLayer(player: player) avPlayerLayer.frame = CGRectMake(your frame) self.view.layer .addSublayer(avPlayerLayer) var steamingURL:NSURL = NSURL(string:playerURL) player = AVPlayer(URL: steamingURL) player.play()
import UIKit import AVKit import AVFoundation class ViewController: UIViewController,AVPlayerViewControllerDelegate { var playerController = AVPlayerViewController() @IBAction func Play(_ sender: Any) { let path = Bundle.main.path(forResource: "video", ofType: "mp4") let url = NSURL(fileURLWithPath: path!) let player = AVPlayer(url:url as URL) playerController = AVPlayerViewController() NotificationCenter.default.addObserver(self, selector: playerController.player = player playerController.allowsPictureInPicturePlayback = true playerController.delegate = self playerController.player?.play() self.present(playerController,animated:true,completion:nil) } func didfinishplaying(note : NSNotification) { playerController.dismiss(animated: true,completion: nil) let alertview = UIAlertController(title:"finished",message:"video finished",preferredStyle: .alert) alertview.addAction(UIAlertAction(title:"Ok",style: .default, handler: nil)) self.present(alertview,animated:true,completion: nil) } func playerViewController(_ playerViewController: AVPlayerViewController, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler completionHandler: @escaping (Bool) -> Void) { let currentviewController = navigationController?.visibleViewController if currentviewController != playerViewController { currentviewController?.present(playerViewController,animated: true,completion:nil) } } }
NSURL *url=[[NSBundle mainBundle]URLForResource:@"arreg" withExtension:@"mp4"]; AVPlayer *video=[AVPlayer playerWithURL:url]; AVPlayerViewController *controller=[[AVPlayerViewController alloc]init]; controller.player=video; [self.view addSubview:controller.view]; controller.view.frame=self.view.frame; [self addChildViewController:controller]; [video play];
if let url = URL(string: "http: let playerItem = AVPlayerItem(url: url) let player = AVPlayer(playerItem: playerItem) let playerLayer = AVPlayerLayer(player: player) playerLayer.frame=CGRect(x: 10, y: 10, width: 300, height: 300) self.view.layer.addSublayer(playerLayer) }
if let url = URL(string: "http: let player = AVPlayer(url: url) let controller=AVPlayerViewController() controller.player=player controller.view.frame = self.view.frame self.view.addSubview(controller.view) self.addChildViewController(controller) player.play() }
import UIKit import MediaPlayer class ViewController: UIViewController { var streamPlayer : MPMoviePlayerController = MPMoviePlayerController(contentURL: NSURL(string:"video url here")) override func viewDidLoad() { super.viewDidLoad() streamPlayer.view.frame = self.view.bounds self.view.addSubview(streamPlayer.view) streamPlayer.fullscreen = true streamPlayer.play() } }
import AVFoundation var playerItem:AVPlayerItem? var player:AVPlayer? override func viewDidLoad() { super.viewDidLoad() let url = NSURL(string: "url of the audio or video") playerItem = AVPlayerItem(URL: url!) player=AVPlayer(playerItem: playerItem!) let playerLayer=AVPlayerLayer(player: player!) playerLayer.frame=CGRectMake(0, 0, 300, 50) self.view.layer.addSublayer(playerLayer) }
playButton.addTarget(self, action: "playButtonTapped:", forControlEvents: .TouchUpInside) func playButtonTapped(sender: AnyObject) { if player?.rate == 0 { player!.play() playButton.setImage(UIImage(named: "player_control_pause_50px.png"), forState: UIControlState.Normal) } else { player!.pause() playButton.setImage(UIImage(named: "player_control_play_50px.png"), forState: UIControlState.Normal) } }
override func viewWillAppear(animated: Bool) { NSNotificationCenter.defaultCenter().addObserver(self, selector: "finishedPlaying:", name: AVPlayerItemDidPlayToEndTimeNotification, object: playerItem) } override func viewWillDisappear(animated: Bool) { NSNotificationCenter.defaultCenter().removeObserver(self) }
func finishedPlaying(myNotification:NSNotification) { playButton.setImage(UIImage(named: "player_control_play_50px.png"), forState: UIControlState.Normal) let stopedPlayerItem: AVPlayerItem = myNotification.object as! AVPlayerItem stopedPlayerItem.seekToTime(kCMTimeZero) }
import UIKit import AVKit import AVFoundation class ViewController: UIViewController { @IBOutlet weak var viewPlay: UIView! var player : AVPlayer? override func viewDidLoad() { super.viewDidLoad() let url : URL = URL(string: "http: player = AVPlayer(url: url) let playerLayer = AVPlayerLayer(player: player) playerLayer.frame = self.viewPlay.bounds self.viewPlay.layer.addSublayer(playerLayer) } @IBAction func play(_ sender: Any) { player?.play() } @IBAction func stop(_ sender: Any) { player?.pause() } }
override func viewDidLoad() { super.viewDidLoad() NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillShow:"), name:UIKeyboardWillShowNotification, object: nil); NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillHide:"), name:UIKeyboardWillHideNotification, object: nil); } func keyboardWillShow(sender: NSNotification) { self.view.frame.origin.y -= 150 } func keyboardWillHide(sender: NSNotification) { self.view.frame.origin.y += 150 }
func registerForKeyboardNotifications() { NSNotificationCenter.defaultCenter().addObserver(self, selector: "keyboardWasShown:", name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: "keyboardWillBeHidden:", name: UIKeyboardWillHideNotification, object: nil) } func deregisterFromKeyboardNotifications() { NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillHideNotification, object: nil) } func keyboardWasShown(notification: NSNotification) { self.scrollView.scrollEnabled = true var info : NSDictionary = notification.userInfo! var keyboardSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue().size var contentInsets : UIEdgeInsets = UIEdgeInsetsMake(0.0, 0.0, keyboardSize!.height, 0.0) self.scrollView.contentInset = contentInsets self.scrollView.scrollIndicatorInsets = contentInsets var aRect : CGRect = self.view.frame aRect.size.height -= keyboardSize!.height if let activeFieldPresent = activeField { if (!CGRectContainsPoint(aRect, activeField!.frame.origin)) { self.scrollView.scrollRectToVisible(activeField!.frame, animated: true) } } } func keyboardWillBeHidden(notification: NSNotification) { var info : NSDictionary = notification.userInfo! var keyboardSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue().size var contentInsets : UIEdgeInsets = UIEdgeInsetsMake(0.0, 0.0, -keyboardSize!.height, 0.0) self.scrollView.contentInset = contentInsets self.scrollView.scrollIndicatorInsets = contentInsets self.view.endEditing(true) self.scrollView.scrollEnabled = false } func textFieldDidBeginEditing(textField: UITextField!) { activeField = textField } func textFieldDidEndEditing(textField: UITextField!) { activeField = nil }
func registerForKeyboardNotifications(){ NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } func deregisterFromKeyboardNotifications(){ NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillShow, object: nil) NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillHide, object: nil) } func keyboardWasShown(notification: NSNotification){ self.scrollView.isScrollEnabled = true var info = notification.userInfo! let keyboardSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size let contentInsets : UIEdgeInsets = UIEdgeInsetsMake(0.0, 0.0, keyboardSize!.height, 0.0) self.scrollView.contentInset = contentInsets self.scrollView.scrollIndicatorInsets = contentInsets var aRect : CGRect = self.view.frame aRect.size.height -= keyboardSize!.height if let activeField = self.activeField { if (!aRect.contains(activeField.frame.origin)){ self.scrollView.scrollRectToVisible(activeField.frame, animated: true) } } } func keyboardWillBeHidden(notification: NSNotification){ var info = notification.userInfo! let keyboardSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size let contentInsets : UIEdgeInsets = UIEdgeInsetsMake(0.0, 0.0, -keyboardSize!.height, 0.0) self.scrollView.contentInset = contentInsets self.scrollView.scrollIndicatorInsets = contentInsets self.view.endEditing(true) self.scrollView.isScrollEnabled = false } func textFieldDidBeginEditing(_ textField: UITextField){ activeField = textField } func textFieldDidEndEditing(_ textField: UITextField){ activeField = nil }
import IQKeyboardManagerSwift @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { IQKeyboardManager.sharedManager().enable = true return true } }
func textFieldDidBeginEditing(textField: UITextField) { if textField == email || textField == password { animateViewMoving(true, moveValue: 100) } } func textFieldDidEndEditing(textField: UITextField) { if textField == email || textField == password { animateViewMoving(false, moveValue: 100) } } func animateViewMoving (up:Bool, moveValue :CGFloat){ let movementDuration:NSTimeInterval = 0.3 let movement:CGFloat = ( up ? -moveValue : moveValue) UIView.beginAnimations("animateView", context: nil) UIView.setAnimationBeginsFromCurrentState(true) UIView.setAnimationDuration(movementDuration) self.view.frame = CGRectOffset(self.view.frame, 0, movement) UIView.commitAnimations() }
func keyboardWillShow(notification: NSNotification) { if bottomText.editing{ self.view.window?.frame.origin.y = -1 * getKeyboardHeight(notification) } } func keyboardWillHide(notification: NSNotification) { if self.view.window?.frame.origin.y != 0 { self.view.window?.frame.origin.y += getKeyboardHeight(notification) } }
extension UIView { func bindToKeyboard(){ NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWillChange(_ notification: NSNotification){ let duration = notification.userInfo![UIKeyboardAnimationDurationUserInfoKey] as! Double let curve = notification.userInfo![UIKeyboardAnimationCurveUserInfoKey] as! UInt let beginningFrame = (notification.userInfo![UIKeyboardFrameBeginUserInfoKey] as! NSValue).cgRectValue let endFrame = (notification.userInfo![UIKeyboardFrameEndUserInfoKey] as! NSValue).cgRectValue let deltaY = endFrame.origin.y - beginningFrame.origin.y UIView.animateKeyframes(withDuration: duration, delay: 0.0, options: UIViewKeyframeAnimationOptions(rawValue: curve), animations: { self.frame.origin.y += deltaY }, completion: nil) } }
self.containerDependOnKeyboardBottomConstrain = containerBtmConstrain self.watchForKeyboard()
import UIKit private var xoAssociationKeyForBottomConstrainInVC: UInt8 = 0 extension UIViewController { var containerDependOnKeyboardBottomConstrain :NSLayoutConstraint! { get { return objc_getAssociatedObject(self, &xoAssociationKeyForBottomConstrainInVC) as? NSLayoutConstraint } set(newValue) { objc_setAssociatedObject(self, &xoAssociationKeyForBottomConstrainInVC, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN) } } func watchForKeyboard () { NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } @objc func keyboardWasShown(notification: NSNotification) { let info = notification.userInfo! let keyboardFrame: CGRect = (info[UIResponder.keyboardFrameEndUserInfoKey] as! NSValue).cgRectValue UIView.animate(withDuration: 0.3, animations: { () -> Void in self.containerDependOnKeyboardBottomConstrain.constant = -keyboardFrame.height self.view.layoutIfNeeded() }) } @objc func keyboardWillHide(notification: NSNotification) { UIView.animate(withDuration: 0.3, animations: { () -> Void in self.containerDependOnKeyboardBottomConstrain.constant = 0 self.view.layoutIfNeeded() }) } }
if (!CGRectContainsPoint(aRect, activeField!.frame.origin))
func registerForKeyboardNotifications() { NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } func deregisterFromKeyboardNotifications() { NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillShow, object: nil) NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillHide, object: nil) } func keyboardWasShown(notification: NSNotification) { scrollView?.isScrollEnabled = true var info = notification.userInfo! if let keyboardSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size { let contentInsets: UIEdgeInsets = UIEdgeInsets(top: 0.0, left: 0.0, bottom: keyboardSize.height, right: 0.0) scrollView?.contentInset = contentInsets scrollView?.scrollIndicatorInsets = contentInsets var aRect: CGRect = self.view.frame aRect.size.height -= keyboardSize.height if let activeField = self.activeField { if !aRect.contains(activeField.frame.origin) { self.scrollView.scrollRectToVisible(activeField.frame, animated: true) } } } } func keyboardWillBeHidden(notification: NSNotification) { var info = notification.userInfo! if let keyboardSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size { let contentInsets: UIEdgeInsets = UIEdgeInsets(top: 0.0, left: 0.0, bottom: -keyboardSize.height, right: 0.0) scrollView?.contentInset = contentInsets scrollView?.scrollIndicatorInsets = contentInsets } view.endEditing(true) scrollView?.isScrollEnabled = false } func textFieldDidBeginEditing(_ textField: UITextField) { activeField = textField } func textFieldDidEndEditing(_ textField: UITextField) { activeField = nil }
let aRect : CGRect = scrollView.convertRect(activeFieldRect!, toView: nil) if (CGRectContainsPoint(keyboardRect!, CGPointMake(aRect.origin.x, aRect.maxY))) { }
for view in self.view.subviews { if view is UITextView { let tv = view as! UITextView tv.delegate = self } else if view is UITextField { let tf = view as! UITextField tf.delegate = self } }
import UIKit class ScrollingFormViewController: UIViewController, UITextViewDelegate, UITextFieldDelegate { var activeFieldRect: CGRect? var keyboardRect: CGRect? var scrollView: UIScrollView! override func viewDidLoad() { self.automaticallyAdjustsScrollViewInsets = false super.viewDidLoad() self.registerForKeyboardNotifications() for view in self.view.subviews { if view is UITextView { let tv = view as! UITextView tv.delegate = self } else if view is UITextField { let tf = view as! UITextField tf.delegate = self } } scrollView = UIScrollView(frame: self.view.frame) scrollView.scrollEnabled = false scrollView.showsVerticalScrollIndicator = false scrollView.showsHorizontalScrollIndicator = false scrollView.addSubview(self.view) self.view = scrollView } override func viewDidLayoutSubviews() { scrollView.sizeToFit() scrollView.contentSize = scrollView.frame.size super.viewDidLayoutSubviews() } deinit { self.deregisterFromKeyboardNotifications() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func registerForKeyboardNotifications() { NSNotificationCenter.defaultCenter().addObserver(self, selector: NSNotificationCenter.defaultCenter().addObserver(self, selector: } func deregisterFromKeyboardNotifications() { NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillHideNotification, object: nil) } func keyboardWasShown(notification: NSNotification) { let info : NSDictionary = notification.userInfo! keyboardRect = (info[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.CGRectValue() adjustForKeyboard() } func keyboardWillBeHidden(notification: NSNotification) { keyboardRect = nil adjustForKeyboard() } func adjustForKeyboard() { if keyboardRect != nil && activeFieldRect != nil { let aRect : CGRect = scrollView.convertRect(activeFieldRect!, toView: nil) if (CGRectContainsPoint(keyboardRect!, CGPointMake(aRect.origin.x, aRect.maxY))) { scrollView.scrollEnabled = true let contentInsets : UIEdgeInsets = UIEdgeInsetsMake(0.0, 0.0, keyboardRect!.size.height, 0.0) scrollView.contentInset = contentInsets scrollView.scrollIndicatorInsets = contentInsets scrollView.scrollRectToVisible(activeFieldRect!, animated: true) } } else { let contentInsets : UIEdgeInsets = UIEdgeInsetsZero scrollView.contentInset = contentInsets scrollView.scrollIndicatorInsets = contentInsets scrollView.scrollEnabled = false } } func textViewDidBeginEditing(textView: UITextView) { activeFieldRect = textView.frame adjustForKeyboard() } func textViewDidEndEditing(textView: UITextView) { activeFieldRect = nil adjustForKeyboard() } func textFieldDidBeginEditing(textField: UITextField) { activeFieldRect = textField.frame adjustForKeyboard() } func textFieldDidEndEditing(textField: UITextField) { activeFieldRect = nil adjustForKeyboard() } }
class ViewController: UIViewController, UITextFieldDelegate { @IBOutlet weak var txtFirstName: UITextField! @IBOutlet weak var txtLastName: UITextField! @IBOutlet weak var txtCity: UITextField! var keyboardActive = false override func viewDidLoad() { super.viewDidLoad() self.txtFirstName.delegate = self self.txtLastName.delegate = self self.txtCity.delegate = self } func textFieldDidBeginEditing(textField: UITextField) { if textField != self.txtFirstName && keyboardActive == false { self.view.frame.origin.y -= 165 self.keyboardActive = true } } func textFieldShouldEndEditing(textField: UITextField) -> Bool { if textField != self.txtFirstName && keyboardActive == true { self.view.frame.origin.y += 165 self.keyboardActive = false } return true } func textFieldShouldReturn(textField: UITextField) -> Bool { self.view.endEditing(true) return false } }
func registerForKeyboardNotifications() { NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: }
@IBOutlet weak var loginViewTopConstraint: NSLayoutConstraint!
func keyboardWasShown(_ notification: Notification) { let keyboardInfo = notification.userInfo as NSDictionary? let keyboardFrameEnd: NSValue? = (keyboardInfo?.value(forKey: UIKeyboardFrameEndUserInfoKey) as? NSValue) let keyboardFrameEndRect: CGRect? = keyboardFrameEnd?.cgRectValue if activeTextField.frame.origin.y + activeTextField.frame.size.height + 10 > (keyboardFrameEndRect?.origin.y)! { UIView.animate(withDuration: 0.3, delay: 0, options: .transitionFlipFromTop, animations: {() -> Void in self.loginViewTopConstraint.constant = -(self.activeTextField.frame.origin.y + self.activeTextField.frame.size.height - (keyboardFrameEndRect?.origin.y)!) - 30.0 self.view.layoutIfNeeded() }, completion: {(_ finished: Bool) -> Void in }) } } func keyboardWillBeHidden(_ notification: Notification) { UIView.animate(withDuration: 0.3, animations: {() -> Void in self.loginViewTopConstraint.constant = self.view.frame.origin.y self.view.layoutIfNeeded() }) } func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool { activeTextField = textField return true } func textFieldShouldReturn(_ textField: UITextField) -> Bool { switch textField { case YOUR_TEXTFIELD_ONE: YOUR_TEXTFIELD_TWO.becomeFirstResponder() break case YOUR_TEXTFIELD_TWO: YOUR_TEXTFIELD_THREE.becomeFirstResponder() break default: textField.resignFirstResponder() break } return true }
override func viewWillDisappear(_ animated: Bool) { NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardDidShow, object: nil) NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillHide, object: nil) }
func textFieldDidBeginEditing(_ textField: UITextField) { animateViewMoving(up: true, moveValue: 100) } func textFieldDidEndEditing(_ textField: UITextField) { animateViewMoving(up: false, moveValue: 100) } func animateViewMoving (up:Bool, moveValue :CGFloat){ textFieldDidEndEditing(_ textField: UITextField) { let movementDuration:TimeInterval = 0.5 let movement:CGFloat = ( up ? -moveValue : moveValue) UIView.beginAnimations("animateView", context: nil) UIView.setAnimationBeginsFromCurrentState(true) UIView.setAnimationDuration(movementDuration) self.view.frame = self.view.frame.offsetBy(dx: 0, dy: movement) UIView.commitAnimations() }
func textFieldDidBeginEditing(textField: UITextField!) { if textField == txtOne { println("TextOne") } if textField == txtTwo { println("TextTwo") } }
var moveValue: CGFloat! var moved: Bool = false var activeTextField = UITextField() func textFieldDidBeginEditing(_ textField: UITextField) { self.activeTextField = textField } func textFieldDidEndEditing(_ textField: UITextField) { if moved == true{ self.animateViewMoving(up: false, moveValue: moveValue ) moved = false } } func animateViewMoving (up:Bool, moveValue :CGFloat){ let movementDuration:TimeInterval = 0.3 let movement:CGFloat = ( up ? -moveValue : moveValue) UIView.beginAnimations("animateView", context: nil) UIView.setAnimationBeginsFromCurrentState(true) UIView.setAnimationDuration(movementDuration) self.view.frame = self.view.frame.offsetBy(dx: 0, dy: movement) UIView.commitAnimations() }
NotificationCenter.default.addObserver(self, selector:
func keyboardWillShow(notification: Notification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { let keyboardHeight = keyboardSize.height if (view.frame.size.height-self.activeTextField.frame.origin.y) - self.activeTextField.frame.size.height < keyboardHeight{ moveValue = keyboardHeight - ((view.frame.size.height-self.activeTextField.frame.origin.y) - self.activeTextField.frame.size.height) self.animateViewMoving(up: true, moveValue: moveValue ) moved = true } } }
@IBOutlet var scrollView: UIScrollView! @IBOutlet var edtEmail: UITextField! @IBOutlet var bottomTextfieldConstrain: NSLayoutConstraint! @IBAction func edtEmailEditingDidBegin(_ sender: Any) { self.bottomTextfieldConstrain.constant = 200 let point = CGPoint(x: 0, y: 200) scrollView.contentOffset = point } @IBAction func edtEmailEditingDidEnd(_ sender: Any) { self.bottomTextfieldConstrain.constant = 50 }
var aRect : CGRect = self.view.frame aRect.size.height -= keyboardSize!.height if let activeField = self.activeField { var point = activeField.frame.origin point.y += activeField.frame.size.height if (!aRect.contains(point)){ self.scrollView.scrollRectToVisible(activeField.frame, animated: true) } }
NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector:
func keyboardWillShow(_ notification: NSNotification) { self.scrollView.isScrollEnabled = true var info = notification.userInfo! let keyboardSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size let contentInsets : UIEdgeInsets = UIEdgeInsetsMake(0.0, 0.0, keyboardSize!.height, 0.0) self.scrollView.contentInset = contentInsets self.scrollView.scrollIndicatorInsets = contentInsets var aRect : CGRect = self.view.frame aRect.size.height -= keyboardSize!.height if let activeField = self.activeField { if (!aRect.contains(activeField.frame.origin)){ self.scrollView.scrollRectToVisible(activeField.frame, animated: true) } } } func keyboardWillHide(_ notification: NSNotification) { let contentInsets : UIEdgeInsets = UIEdgeInsetsMake(0.0, 0.0, 0.0, 0.0) self.scrollView.contentInset = contentInsets self.scrollView.scrollIndicatorInsets = contentInsets self.view.endEditing(true) self.scrollView.isScrollEnabled = true } func textFieldDidBeginEditing(_ textField: UITextField){ activeField = textField } func textFieldDidEndEditing(_ textField: UITextField){ activeField = nil }
import Foundation import UIKit class PhoneController: UIViewController, UITextFieldDelegate{ var phoneLayoutYConstraint: NSLayoutConstraint? override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: phoneField.delegate = self view.addSubview(phoneField) NSLayoutConstraint.activate([phoneField.heightAnchor.constraint(equalToConstant: 50), phoneField.centerXAnchor.constraint(equalTo: view.centerXAnchor), phoneField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20), phoneField.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20)]) phoneLayoutYConstraint = NSLayoutConstraint(item: phoneField, attribute: .bottom, relatedBy: .equal, toItem: view, attribute: .bottom, multiplier: 1, constant: 0) phoneLayoutYConstraint?.isActive = true } let phoneField: UITextField = { let text = UITextField() text.translatesAutoresizingMaskIntoConstraints = false text.keyboardType = .numberPad text.font = UIFont.systemFont(ofSize: 30) text.layer.cornerRadius = 5.0 text.layer.masksToBounds = true text.layer.borderColor = UIColor.darkGray.cgColor text.layer.borderWidth = 2.0 return text }() override func viewDidDisappear(_ animated: Bool) { super.viewWillDisappear(animated) NotificationCenter.default.removeObserver(self) } func textFieldDidBeginEditing(_ textField: UITextField) { } func textFieldDidEndEditing(_ textField: UITextField) { } func textFieldShouldReturn(_ textField: UITextField) -> Bool { textField.resignFirstResponder() return true } @objc func handleKeyBoardNotification(_ notification: NSNotification) { if let info = notification.userInfo { let keyboardSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size let isKeyBoardShowing = notification.name == NSNotification.Name.UIKeyboardWillShow var aRect : CGRect = self.phoneField.frame aRect.size.height -= keyboardSize!.height phoneLayoutYConstraint?.constant = isKeyBoardShowing ? -keyboardSize!.height : 0 UIView.animate(withDuration: 0, delay: 0, options: .curveEaseOut, animations: { self.view.layoutIfNeeded() }, completion: { (boo) in }) } } }
import UIKit class ViewController: UIViewController { @IBOutlet var textField: UITextField! override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: } override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { textField.resignFirstResponder() } @objc func keyboardWillChange(notification: NSNotification) { let duration = notification.userInfo![UIKeyboardAnimationDurationUserInfoKey] as! Double let curve = notification.userInfo![UIKeyboardAnimationCurveUserInfoKey] as! UInt let curFrame = (notification.userInfo![UIKeyboardFrameBeginUserInfoKey] as! NSValue).cgRectValue let targetFrame = (notification.userInfo![UIKeyboardFrameEndUserInfoKey] as! NSValue).cgRectValue let deltaY = targetFrame.origin.y - curFrame.origin.y UIView.animateKeyframes(withDuration: duration, delay: 0.0, options: UIViewKeyframeAnimationOptions(rawValue: curve), animations: { self.textField.frame.origin.y+=deltaY },completion: nil) }
import UIKit class UIViewWithKeyboard: UIView { @IBInspectable var offsetMultiplier: CGFloat = 0.75 private var keyboardHeight = 0 as CGFloat private weak var activeTextField: UITextField? override func awakeFromNib() { super.awakeFromNib() NotificationCenter.default.addObserver(self, selector: name: UITextField.textDidBeginEditingNotification, object: nil) NotificationCenter.default.addObserver(self, selector: name: UIResponder.keyboardWillShowNotification, object: nil) NotificationCenter.default.addObserver(self, selector: name: UIResponder.keyboardWillHideNotification, object: nil) } @objc func textDidBeginEditing(_ notification: NSNotification) { self.activeTextField = notification.object as? UITextField } @objc func keyboardWillShow(_ notification: Notification) { if let frameValue = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue { keyboardHeight = frameValue.cgRectValue.size.height if let textField = self.activeTextField { let offset = textField.frame.maxY < frame.maxY - keyboardHeight ? 0 : textField.frame.maxY - (frame.maxY - keyboardHeight) * offsetMultiplier self.setView(offset: offset) } } } @objc func keyboardWillHide(_ notification: NSNotification) { self.setView(offset: 0) } func setView(offset: CGFloat) { UIView.animate(withDuration: 0.25) { self.bounds.origin.y = offset } } }
NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector:
func textFieldDidBeginEditing(_ textField: UITextField) { clickedTextField = textField }
@objc func keyboardWillShow(sender: NSNotification,_ textField : UITextField) { if let keyboardSize = (sender.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { if clickedTextField.frame.origin.y > keyboardSize.origin.y { self.view.frame.origin.y = keyboardSize.origin.y - clickedTextField.center.y - 20 } } } @objc func keyboardWillHide(sender: NSNotification) { self.view.frame.origin.y = 0 }
func textFieldShouldReturn(_ textField: UITextField) -> Bool { textField.resignFirstResponder() return true }
NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector:
func registerForKeyboardNotifications(){ NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } func deregisterFromKeyboardNotifications(){ NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillShowNotification, object: nil) NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillHideNotification, object: nil) } @objc func keyboardWasShown(notification: NSNotification){ self.scrollView.isScrollEnabled = true var info = notification.userInfo! let keyboardSize = (info[UIResponder.keyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size let contentInsets : UIEdgeInsets = UIEdgeInsets(top: 0.0, left: 0.0, bottom: keyboardSize!.height, right: 0.0) self.scrollView.contentInset = contentInsets self.scrollView.scrollIndicatorInsets = contentInsets var aRect : CGRect = self.view.frame aRect.size.height -= keyboardSize!.height if let activeField = self.activeField { if (!aRect.contains(activeField.frame.origin)){ self.scrollView.scrollRectToVisible(activeField.frame, animated: true) } } } @objc func keyboardWillBeHidden(notification: NSNotification){ var info = notification.userInfo! let keyboardSize = (info[UIResponder.keyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size let contentInsets : UIEdgeInsets = UIEdgeInsets(top: 0.0, left: 0.0, bottom: -keyboardSize!.height, right: 0.0) self.scrollView.contentInset = contentInsets self.scrollView.scrollIndicatorInsets = contentInsets self.view.endEditing(true) self.scrollView.isScrollEnabled = false } func textFieldDidBeginEditing(_ textField: UITextField){ activeField = textField } func textFieldDidEndEditing(_ textField: UITextField){ activeField = nil }
import React, { Component } from import KeyboardSpacer from import { View, Text, TextInput } from export default class Sample extends Component{ render(){ return( <View style={{flex: 1}}> <TextInput placeholderTextColor="¬£000000" underlineColorAndroid="transparent" keyboardType="default" maxLength={30} placeholder={ <TextInput placeholder={"another text field"} /> <TextInput placeholder={"another text field"} /> { } <KeyboardSpacer/> </View> ); } }
Note: It will work both IOS and Android React Native apps. Hope It is helpful to others.
@interface UIView (MyCategory) - (void)alignToView:(UIView *)view alignment:(UIViewRelativeAlignment)alignment; - (UIView *)clone; @property (strong) PFObject *xo; @property (nonatomic) BOOL isAnimating; @end
import Foundation import QuartzCore import ObjectiveC extension CALayer { var shapeLayer: CAShapeLayer? { get { return objc_getAssociatedObject(self, "shapeLayer") as? CAShapeLayer } set(newValue) { objc_setAssociatedObject(self, "shapeLayer", newValue, UInt(OBJC_ASSOCIATION_RETAIN)) } } var initialPath: CGPathRef! { get { return objc_getAssociatedObject(self, "initialPath") as CGPathRef } set { objc_setAssociatedObject(self, "initialPath", newValue, UInt(OBJC_ASSOCIATION_RETAIN)) } } }
class UIBubble : UIView { required init(coder aDecoder: NSCoder) { ... self.layer.shapeLayer = CAShapeLayer() ... } }
public final class ObjectAssociation<T: AnyObject> { private let policy: objc_AssociationPolicy public init(policy: objc_AssociationPolicy = .OBJC_ASSOCIATION_RETAIN_NONATOMIC) { self.policy = policy } public subscript(index: AnyObject) -> T? { get { return objc_getAssociatedObject(index, Unmanaged.passUnretained(self).toOpaque()) as! T? } set { objc_setAssociatedObject(index, Unmanaged.passUnretained(self).toOpaque(), newValue, policy) } } }
extension SomeType { private static let association = ObjectAssociation<NSObject>() var simulatedProperty: NSObject? { get { return SomeType.association[self] } set { SomeType.association[self] = newValue } } }
import ObjectiveC private var xoAssociationKey: UInt8 = 0 extension UIView { var xo: PFObject! { get { return objc_getAssociatedObject(self, &xoAssociationKey) as? PFObject } set(newValue) { objc_setAssociatedObject(self, &xoAssociationKey, newValue, objc_AssociationPolicy(OBJC_ASSOCIATION_RETAIN)) } } }
import ObjectiveC private var xoAssociationKey: UInt8 = 0 extension UIView { var xo: PFObject! { get { return objc_getAssociatedObject(self, &xoAssociationKey) as? PFObject } set(newValue) { objc_setAssociatedObject(self, &xoAssociationKey, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN) } } }
extension UIViewController { struct Holder { static var _myComputedProperty:Bool = false } var myComputedProperty:Bool { get { return Holder._myComputedProperty } set(newValue) { Holder._myComputedProperty = newValue } } }
extension UIViewController { private struct AssociatedKeys { static var DescriptiveName = "nsh_DescriptiveName" } var descriptiveName: String? { get { return objc_getAssociatedObject(self, &AssociatedKeys.DescriptiveName) as? String } set { if let newValue = newValue { objc_setAssociatedObject( self, &AssociatedKeys.DescriptiveName, newValue as NSString?, UInt(OBJC_ASSOCIATION_RETAIN_NONATOMIC) ) } } } }
private struct AssociatedKeys { static var displayed = "displayed" } var displayed : Bool { get { guard let number = objc_getAssociatedObject(self, &AssociatedKeys.displayed) as? NSNumber else { return true } return number.boolValue } set(value) { objc_setAssociatedObject(self,&AssociatedKeys.displayed,NSNumber(bool: value),objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) } }
import ObjectiveC final class Lifted<T> { let value: T init(_ x: T) { value = x } } private func lift<T>(x: T) -> Lifted<T> { return Lifted(x) } func setAssociatedObject<T>(object: AnyObject, value: T, associativeKey: UnsafePointer<Void>, policy: objc_AssociationPolicy) { if let v: AnyObject = value as? AnyObject { objc_setAssociatedObject(object, associativeKey, v, policy) } else { objc_setAssociatedObject(object, associativeKey, lift(value), policy) } } func getAssociatedObject<T>(object: AnyObject, associativeKey: UnsafePointer<Void>) -> T? { if let v = objc_getAssociatedObject(object, associativeKey) as? T { return v } else if let v = objc_getAssociatedObject(object, associativeKey) as? Lifted<T> { return v.value } else { return nil } }
extension UIView { private struct AssociatedKey { static var viewExtension = "viewExtension" } var referenceTransform: CGAffineTransform? { get { return getAssociatedObject(self, associativeKey: &AssociatedKey.viewExtension) } set { if let value = newValue { setAssociatedObject(self, value: value, associativeKey: &AssociatedKey.viewExtension, policy: objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } }
struct Crate { var name: String } class Box { var name: String init(name: String) { self.name = name } } extension UIViewController { private struct AssociatedKey { static var displayed: UInt8 = 0 static var box: UInt8 = 0 static var crate: UInt8 = 0 } var displayed: Bool? { get { return getAssociatedObject(self, associativeKey: &AssociatedKey.displayed) } set { if let value = newValue { setAssociatedObject(self, value: value, associativeKey: &AssociatedKey.displayed, policy: objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } var box: Box { get { if let result:Box = getAssociatedObject(self, associativeKey: &AssociatedKey.box) { return result } else { let result = Box(name: "") self.box = result return result } } set { setAssociatedObject(self, value: newValue, associativeKey: &AssociatedKey.box, policy: objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } var crate: Crate { get { if let result:Crate = getAssociatedObject(self, associativeKey: &AssociatedKey.crate) { return result } else { let result = Crate(name: "") self.crate = result return result } } set { setAssociatedObject(self, value: newValue, associativeKey: &AssociatedKey.crate, policy: objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } }
extension String { public var Foo : String { get { return "Foo" } set { } } }
extension CALayer { private struct AssociatedKeys { static var shapeLayer:CAShapeLayer? } var shapeLayer: CAShapeLayer? { get { return objc_getAssociatedObject(self, &AssociatedKeys.shapeLayer) as? CAShapeLayer } set { if let newValue = newValue { objc_setAssociatedObject(self, &AssociatedKeys.shapeLayer, newValue as CAShapeLayer?, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } }
import UIKit var extensionPropertyStorage: [NSObject: [String: Any]] = [:] var didSetFrame_ = "didSetFrame" extension UILabel { override public var frame: CGRect { get { return didSetFrame ?? CGRectNull } set { didSetFrame = newValue } } var didSetFrame: CGRect? { get { return extensionPropertyStorage[self]?[didSetFrame_] as? CGRect } set { var selfDictionary = extensionPropertyStorage[self] ?? [String: Any]() selfDictionary[didSetFrame_] = newValue extensionPropertyStorage[self] = selfDictionary } } func willDeinit() { extensionPropertyStorage[self] = nil } }
extension UIViewController { private static var _myComputedProperty = [String:Bool]() var myComputedProperty:Bool { get { let tmpAddress = String(format: "%p", unsafeBitCast(self, to: Int.self)) return UIViewController._myComputedProperty[tmpAddress] ?? false } set(newValue) { let tmpAddress = String(format: "%p", unsafeBitCast(self, to: Int.self)) UIViewController._myComputedProperty[tmpAddress] = newValue } } }
class MyClass { var a = 1 init(a: Int) { self.a = a } } extension UIView { static var extraData = [UIView: MyClass]() var myClassData: MyClass? { get { return UIView.extraData[self] } set(value) { UIView.extraData[self] = value } } } var view1 = UIView() var view2 = UIView() view1.myClassData = MyClass(a: 1) view2.myClassData = MyClass(a: 2) print(view1.myClassData?.a) print(view2.myClassData?.a)
import ObjectiveC final class Lifted<T> { let value: T init(_ x: T) { value = x } } private func lift<T>(_ x: T) -> Lifted<T> { return Lifted(x) } func associated<T>(to base: AnyObject, key: UnsafePointer<UInt8>, policy: objc_AssociationPolicy = .OBJC_ASSOCIATION_RETAIN, initialiser: () -> T) -> T { if let v = objc_getAssociatedObject(base, key) as? T { return v } if let v = objc_getAssociatedObject(base, key) as? Lifted<T> { return v.value } let lifted = Lifted(initialiser()) objc_setAssociatedObject(base, key, lifted, policy) return lifted.value } func associate<T>(to base: AnyObject, key: UnsafePointer<UInt8>, value: T, policy: objc_AssociationPolicy = .OBJC_ASSOCIATION_RETAIN) { if let v: AnyObject = value as AnyObject? { objc_setAssociatedObject(base, key, v, policy) } else { objc_setAssociatedObject(base, key, lift(value), policy) } }
extension UIButton { struct Keys { static fileprivate var color: UInt8 = 0 static fileprivate var index: UInt8 = 0 } var color: UIColor { get { return associated(to: self, key: &Keys.color) { .green } } set { associate(to: self, key: &Keys.color, value: newValue) } } var index: Int { get { return associated(to: self, key: &Keys.index) { -1 } } set { associate(to: self, key: &Keys.index, value: newValue) } } }
let button = UIButton() print(button.color) button.color = .black print(button.color) print(button.index) button.index = 3 print(button.index)
import CoreLocation extension CLLocation { private struct AssociatedKeys { static var originAddress = "originAddress" static var destinationAddress = "destinationAddress" } var originAddress: String? { get { return objc_getAssociatedObject(self, &AssociatedKeys.originAddress) as? String } set { if let newValue = newValue { objc_setAssociatedObject( self, &AssociatedKeys.originAddress, newValue as NSString?, .OBJC_ASSOCIATION_RETAIN_NONATOMIC ) } } } var destinationAddress: String? { get { return objc_getAssociatedObject(self, &AssociatedKeys.destinationAddress) as? String } set { if let newValue = newValue { objc_setAssociatedObject( self, &AssociatedKeys.destinationAddress, newValue as NSString?, .OBJC_ASSOCIATION_RETAIN_NONATOMIC ) } } } }
private var _min: Int? private var _max: Int? extension UITextField { @IBInspectable var minLength: Int { get { return _min ?? 0 } set { _min = newValue } } @IBInspectable var maxLength: Int { get { return _max ?? 1000 } set { _max = newValue } } func validation() -> (valid: Bool, error: String) { var valid: Bool = true var error: String = "" guard let text = self.text else { return (true, "") } if text.characters.count < minLength { valid = false error = "Textfield should contain at least \(minLength) characters" } if text.characters.count > maxLength { valid = false error = "Textfield should not contain more then \(maxLength) characters" } if (text.characters.count < minLength) && (text.characters.count > maxLength) { valid = false error = "Textfield should contain at least \(minLength) characters\n" error = "Textfield should not contain more then \(maxLength) characters" } return (valid, error) } }
public final class Storage : AnyObject { var object:Any? public init(_ object:Any) { self.object = object } } extension Date { private static let associationMap = NSMapTable<NSString, AnyObject>() private struct Keys { static var Locale:NSString = "locale" } public var locale:Locale? { get { if let storage = Date.associationMap.object(forKey: Keys.Locale) { return (storage as! Storage).object as? Locale } return nil } set { if newValue != nil { Date.associationMap.setObject(Storage(newValue), forKey: Keys.Locale) } } } } var date = Date() date.locale = Locale(identifier: "pt_BR") print( date.locale )
extension UIColor { static let graySpace = UIColor.init(red: 50/255, green: 50/255, blue: 50/255, alpha: 1.0) static let redBlood = UIColor.init(red: 102/255, green: 0/255, blue: 0/255, alpha: 1.0) static let redOrange = UIColor.init(red: 204/255, green: 17/255, blue: 0/255, alpha: 1.0) func alpha(value : CGFloat) -> UIColor { var r = CGFloat(0), g = CGFloat(0), b = CGFloat(0), a = CGFloat(0) self.getRed(&r, green: &g, blue: &b, alpha: &a) return UIColor(red: r, green: g, blue: b, alpha: value) } }
class gameController: UIViewController { @IBOutlet var game: gameClass! override func viewDidLoad() { self.view.backgroundColor = UIColor.graySpace } }
[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], nil] setTitleTextAttributes:textDictionary forState:UIControlStateNormal];
static func appearanceWhenContainedInInstancesOfClasses(containerTypes: [AnyObject.Type]) -> Self
UITextField.appearanceWhenContainedInInstancesOfClasses([MyViewController.self]).keyboardAppearance = .Light
NS_ASSUME_NONNULL_BEGIN @interface UIView (UIViewAppearance_Swift) + (instancetype)my_appearanceWhenContainedIn:(Class<UIAppearanceContainer>)containerClass; @end NS_ASSUME_NONNULL_END
@implementation UIView (UIViewAppearance_Swift) + (instancetype)my_appearanceWhenContainedIn:(Class<UIAppearanceContainer>)containerClass { return [self appearanceWhenContainedIn:containerClass, nil]; } @end
UITextField.my_appearanceWhenContainedIn(MyViewController.self).keyboardAppearance = .Light UITextField.my_appearanceWhenContained(in: MyViewController.self).keyboardAppearance = .light
UIBarButtonItem.appearance(whenContainedInInstancesOf: [UISearchBar.self]).title = "Kapat"
@interface UIView (UIAppearance_Swift) + (instancetype)appearanceWhenContainedWithin: (NSArray *)containers; @end
@implementation UIView (UIAppearance_Swift) + (instancetype)appearanceWhenContainedWithin: (NSArray *)containers { NSUInteger count = containers.count; NSAssert(count <= 10, @"The count of containers greater than 10 is not supported."); return [self appearanceWhenContainedIn: count > 0 ? containers[0] : nil, count > 1 ? containers[1] : nil, count > 2 ? containers[2] : nil, count > 3 ? containers[3] : nil, count > 4 ? containers[4] : nil, count > 5 ? containers[5] : nil, count > 6 ? containers[6] : nil, count > 7 ? containers[7] : nil, count > 8 ? containers[8] : nil, count > 9 ? containers[9] : nil, nil]; } @end
TextField.appearanceWhenContainedWithin([MyViewController.self, TableViewController.self]).keyboardAppearance = .Light
+ (void)setAppearance { [[UIView appearanceWhenContainedIn:[UITableViewHeaderFooterView class], nil] setBackgroundColor:[UIColor whiteColor]]; }
-(id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil
[[UITextField appearanceWhenContainedIn:[UISearchBar class], nil] setDefaultTextAttributes:@{NSFontAttributeName: [UIFont fontWithName:@"Avenir-Light" size:16.0f]}];
var work : WorkaroundViewController = WorkaroundViewController()
@interface NSObject (UIAppearance_Swift) + (instancetype)appearanceWhenContainedWithin:(Class<UIAppearanceContainer>)containerClass; @end
@implementation NSObject (UIAppearance_Swift) + (instancetype)appearanceWhenContainedWithin:(Class<UIAppearanceContainer>)containerClass { if ([self conformsToProtocol:@protocol(UIAppearance)]) { return [(id<UIAppearance>)self appearanceWhenContainedIn:containerClass, nil]; } return nil; } @end
import UIViewAppearanceSwift func layout() { UINavigationBar.appearanceWhenContainedWithin(MFMailComposeViewController.self).barStyle = .Black UIBarButtonItem.appearanceWhenContainedWithin(UISearchBar.self).setTitleTextAttributes([NSFontAttributeName: UIFont.systemFontOfSize(15)], forState: UIControlState.Normal) }
UIProgressView.appearance(whenContainedInInstancesOf: [LNPopupBar.self]).tintColor = .red
UIBarButtonItem.appearance().setTitleTextAttributes(textDictionary, forState: UIControlState.Normal)
func appearanceWhenContainedIn(containerClass : <UIAppearanceContainer>) func setTitleTextAttributes(_ attributes: NSDictionary!, forState state: UIControlState)
UIBarButtonItem.appearanceWhenContainedIn(UINavigationBar).setTitleTextAttributes(textDictionary, forState: UIControlStateNormal)
class func invokeService<T>(service: String, withParams params: Dictionary<String, String>, returningClass: AnyClass, completionHandler handler: ((T) -> ())) { }
public <T> T invokeService(final String serviceURLSuffix, final Map<String, String> params, final Class<T> classTypeToReturn) { }
CastDAO.invokeService("test", withParams: ["test" : "test"], returningClass: CityInfo.self) { cityInfo in }
class CityInfo : NSObject { var cityName: String? var regionCode: String? var regionName: String? }
class A {} class B: A {} class C {} let object: A = B() let type: A.Type = B.self let type2: A.Type = C.self
class func invokeService<T>(service: String, withParams params: Dictionary<String, String>, returningClass: T.Type, completionHandler handler: ((T) -> ())) { handler(returningClass()) }
protocol Initable { init() } class CityInfo : NSObject, Initable { var cityName: String? var regionCode: String? var regionName: String? }
let service = "test" let params = ["test" : "test"] let returningClass = CityInfo.self CastDAO.invokeService(service, withParams: params, returningClass: returningClass) { cityInfo in }
CastDAO.invokeService("test", withParams: ["test" : "test"], returningClass: obj-getclass(self)) { cityInfo in }
NotificationCenter.default.addObserver(self, selector:
func rotated() { if UIDeviceOrientationIsLandscape(UIDevice.current.orientation) { print("Landscape") } if UIDeviceOrientationIsPortrait(UIDevice.current.orientation) { print("Portrait") } }
override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { if UIDevice.current.orientation.isLandscape { print("Landscape") } else { print("Portrait") } }
var didRotate: (Notification) -> Void = { notification in switch UIDevice.current.orientation { case .landscapeLeft, .landscapeRight: print("landscape") case .portrait, .portraitUpsideDown: print("Portrait") default: print("other") } }
NotificationCenter.default.addObserver(forName: UIDevice.orientationDidChangeNotification, object: nil, queue: .main, using: didRotate)
NotificationCenter.default.removeObserver(self, name: UIDevice.orientationDidChangeNotification, object: nil)
var didRotate: (Notification) -> Void = { notification in switch UIDevice.current.orientation { case .landscapeLeft, .landscapeRight: print("landscape") case .portrait, .portraitUpsideDown: print("Portrait") default: print("other") } }
NotificationCenter.default.addObserver(forName: .UIDeviceOrientationDidChange, object: nil, queue: .main, using: didRotate)
NotificationCenter.default.removeObserver(self, name: .UIDeviceOrientationDidChange, object: nil)
func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) { let orientation = orientationFromTransform(coordinator.targetTransform()) let oldOrientation = UIApplication.sharedApplication().statusBarOrientation myWillRotateToInterfaceOrientation(orientation,duration: duration) coordinator.animateAlongsideTransition({ (ctx) in self.myWillAnimateRotationToInterfaceOrientation(orientation, duration:duration) }) { (ctx) in self.myDidAnimateFromInterfaceOrientation(oldOrientation) } }
override func didRotateFromInterfaceOrientation(fromInterfaceOrientation: UIInterfaceOrientation) { getScreenSize() } var screenWidth:CGFloat=0 var screenHeight:CGFloat=0 func getScreenSize(){ screenWidth=UIScreen.mainScreen().bounds.width screenHeight=UIScreen.mainScreen().bounds.height print("SCREEN RESOLUTION: "+screenWidth.description+" x "+screenHeight.description) }
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(rotated:) name:UIDeviceOrientationDidChangeNotification object:nil]; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIDeviceOrientationDidChangeNotification object:nil]; - (void)rotated:(NSNotification *)notification { }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver( self, selector: name: .UIDeviceOrientationDidChange, object: nil ) } func deviceDidRotate() { print("deviceDidRotate") }
var previousDeviceOrientation: UIDeviceOrientation = UIDevice.current.orientation override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver( self, selector: name: .UIDeviceOrientationDidChange, object: nil ) } func deviceDidRotate() { if UIDevice.current.orientation == previousDeviceOrientation { return } previousDeviceOrientation = UIDevice.current.orientation print("deviceDidRotate") }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver( self, selector: name: .UIApplicationDidChangeStatusBarOrientation, object: nil ) } func deviceDidRotate() { print("deviceDidRotate") }
-(void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id<UIViewControllerTransitionCoordinator>)coordinator
func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator)
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: } deinit { NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIDeviceOrientationDidChange, object: nil) } func deviceOrientationDidChange() { switch UIDevice.current.orientation { case .faceDown: print("Face down") case .faceUp: print("Face up") case .unknown: print("Unknown") case .landscapeLeft: print("Landscape left") case .landscapeRight: print("Landscape right") case .portrait: print("Portrait") case .portraitUpsideDown: print("Portrait upside down") } } }
override func didRotate(from fromInterfaceOrientation: UIInterfaceOrientation) { getScreenSize() } func getScreenSize(){ let screenWidth = UIScreen.main.bounds.width let screenHeight = UIScreen.main.bounds.height print("SCREEN RESOLUTION: \(screenWidth.description) x \(screenHeight.description)") }
override func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) { super.viewWillTransitionToSize(size, withTransitionCoordinator: coordinator) coordinator.animateAlongsideTransition(nil) { (UIViewControllerTransitionCoordinatorContext) in print("Transition finished") } if size.height < size.width { print("Landscape") } else { print("Portrait") } }
override func willRotate(to toInterfaceOrientation: UIInterfaceOrientation, duration: TimeInterval) { handleViewRotaion(orientation: toInterfaceOrientation) } func handleViewRotaion(orientation:UIInterfaceOrientation) -> Void { switch orientation { case .portrait : print("portrait view") break case .portraitUpsideDown : print("portraitUpsideDown view") break case .landscapeLeft : print("landscapeLeft view") break case .landscapeRight : print("landscapeRight view") break case .unknown : break } }
UIDevice.currentDevice().beginGeneratingDeviceOrientationNotifications() NSNotificationCenter.defaultCenter().addObserver( self, selector: name: UIDeviceOrientationDidChangeNotification, object: nil)
func orientationChanged(notification : NSNotification) { }
override func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) { super.viewWillTransitionToSize(size, withTransitionCoordinator: coordinator) coordinator.animateAlongsideTransition({ (context) in if size.height < size.width { self.calendar.setScope(.Week, animated: true) self.calendar.appearance.cellShape = .Rectangle } else { self.calendar.appearance.cellShape = .Circle self.calendar.setScope(.Month, animated: true) } }, completion: nil) }
coordinator.animateAlongsideTransition({ (context) in if size.height < size.width { self.calendar.scope = .Week self.calendar.appearance.cellShape = .Rectangle } }) { (context) in if size.height > size.width { self.calendar.scope = .Month self.calendar.appearance.cellShape = .Circle } }
override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { if UIDevice.current.orientation.isLandscape { } else { } }
override func willTransition(to newCollection: UITraitCollection, with coordinator: UIViewControllerTransitionCoordinator) { let isiPadLandscapePortrait = newCollection.horizontalSizeClass == .regular && newCollection.verticalSizeClass == .regular let isiPhonePlustLandscape = newCollection.horizontalSizeClass == .regular && newCollection.verticalSizeClass == .compact let isiPhonePortrait = newCollection.horizontalSizeClass == .compact && newCollection.verticalSizeClass == .regular let isiPhoneLandscape = newCollection.horizontalSizeClass == .compact && newCollection.verticalSizeClass == .compact if isiPhonePortrait { } }
public override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { super.viewWillTransition(to: size, with: coordinator) coordinator.animate(alongsideTransition: nil) { (_) in self.tableView.reloadData() } }
override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { super.viewWillTransition(to: size, with: coordinator) coordinator.animate(alongsideTransition: { context in }, completion: { context in }) }
- (void)viewDidLoad { [super viewDidLoad]; [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(OrientationDidChange:) name:UIDeviceOrientationDidChangeNotification object:nil]; } -(void)OrientationDidChange:(NSNotification*)notification { UIDeviceOrientation Orientation=[[UIDevice currentDevice]orientation]; if(Orientation==UIDeviceOrientationLandscapeLeft || Orientation==UIDeviceOrientationLandscapeRight) { NSLog(@"Landscape"); } else if(Orientation==UIDeviceOrientationPortrait) { NSLog(@"Potrait Mode"); } }
func userNotificationCenter(center: NSUserNotificationCenter, didDeliverNotification notification: NSUserNotification) { } func userNotificationCenter(center: NSUserNotificationCenter, didActivateNotification notification: NSUserNotification) { } func userNotificationCenter(center: NSUserNotificationCenter, shouldPresentNotification notification: NSUserNotification) -> Bool { return true }
NSUserNotificationCenter.defaultUserNotificationCenter().delegate = self;
protocol FooTwoViewControllerDelegate:class { func myVCDidFinish(_ controller: FooTwoViewController, text: String) }
class FooTwoViewController: UIViewController { weak var delegate: FooTwoViewControllerDelegate? [snip...] }
@IBAction func saveColor(_ sender: UIBarButtonItem) { delegate?.myVCDidFinish(self, text: colorLabel.text) }
class ViewController: UIViewController, FooTwoViewControllerDelegate {
func myVCDidFinish(_ controller: FooTwoViewController, text: String) { colorLabel.text = "The Color is " + text controller.navigationController.popViewController(animated: true) }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == "mySegue" { let vc = segue.destination as! FooTwoViewController vc.colorString = colorLabel.text vc.delegate = self } }
protocol OlderSiblingDelegate: class { func getYourNiceOlderSiblingAGlassOfWater() } class BossyBigBrother { weak var delegate: OlderSiblingDelegate? func tellSomebodyToGetMeSomeWater() { delegate?.getYourNiceOlderSiblingAGlassOfWater() } } class PoorLittleSister: OlderSiblingDelegate { func getYourNiceOlderSiblingAGlassOfWater() { print("Go get it yourself!") } } let bigBro = BossyBigBrother() let sally = PoorLittleSister() bigBro.delegate = sally bigBro.tellSomebodyToGetMeSomeWater()
protocol ProtocolDelegate: class { func myMethod(controller:ViewController, text:String) }
class ViewController: UIViewController { weak var delegate: ProtocolDelegate? }
if ([self.delegate respondsToSelector:@selector(myMethod:text:)]) { [self.delegate myMethod:self text:@"you Text"]; }
protocol YelpRequestDelegate { func getYelpData() -> AnyObject func processYelpData(data: NSData) -> NSData } class YelpAPI { var delegate: YelpRequestDelegate? func getData() { println("data being retrieved...") let data: AnyObject? = delegate?.getYelpData() } func processYelpData(data: NSData) { println("data being processed...") let data = delegate?.processYelpData(data) } } class Controller: YelpRequestDelegate { init() { var yelpAPI = YelpAPI() yelpAPI.delegate = self yelpAPI.getData() } func getYelpData() -> AnyObject { println("getYelpData called") return NSData() } func processYelpData(data: NSData) -> NSData { println("processYelpData called") return NSData() } } var controller = Controller()
protocol getDataDelegate { func getDataFromAnotherVC(temp: String) } import UIKit class SecondVC: UIViewController { var delegateCustom : getDataDelegate? override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } @IBAction func backToMainVC(sender: AnyObject) { self.delegateCustom?.getDataFromAnotherVC("I am sending data from second controller to first view controller.Its my first delegate example. I am done with custom delegates.") self.navigationController?.popViewControllerAnimated(true) } }
class ViewController: UIViewController, getDataDelegate
func getDataFromAnotherVC(temp : String) { lblForData.text = dataString }
let objectPush = SecondVC() objectPush.delegateCustom = self self.navigationController.pushViewController(objectPush, animated: true)
protocol NetworkServiceDelegate: class { func didCompleteRequest(result: String) } class NetworkService: NSObject { weak var delegate: NetworkServiceDelegate? func fetchDataFromURL(url : String) { delegate?.didCompleteRequest(url) } }
class ViewController: UIViewController, NetworkServiceDelegate { let network = NetworkService() override func viewDidLoad() { super.viewDidLoad() network.delegate = self network.fetchDataFromURL("Success!") } func didCompleteRequest(result: String) { print(result) } }
func updateProcessStatus(isCompleted : Bool){ if isCompleted{ self.labelStatus.text = "Process is completed" }else{ self.labelStatus.text = "Process is in progress" } }
@IBAction func buttonAction(_ sender: Any) { let secondViewController = self.storyboard?.instantiateViewController(withIdentifier: "secondViewController") as! secondViewController secondViewController.delegate = self self.navigationController?.pushViewController(secondViewController, animated: true) }
protocol ProcessStatusDelegate:NSObjectProtocol{ func updateProcessStatus(isCompleted : Bool) }
@IBAction func buttonActionBack(_ sender: Any) { delegate?.updateProcessStatus(isCompleted: true) self.navigationController?.popViewController(animated: true) } @IBAction func buttonProgress(_ sender: Any) { delegate?.updateProcessStatus(isCompleted: false) self.navigationController?.popViewController(animated: true) }
protocol Work: class { func doSomething() } class Manager { weak var delegate: Work? func passAlong() { delegate?.doSomething() } } class Employee: Work { func doSomething() { print("Working on it") } } let manager = Manager() let developer = Employee() manager.delegate = developer manager.passAlong()
@noreturn public func notImplemented(){ fatalError("not implemented yet") } public protocol DataChangedProtocol: class{ typealias DataType func onChange(t:DataType) } class AbstractDataChangedWrapper<DataType> : DataChangedProtocol{ func onChange(t: DataType) { notImplemented() } } class AnyDataChangedWrapper<T: DataChangedProtocol> : AbstractDataChangedWrapper<T.DataType>{ var base: T init(_ base: T ){ self.base = base } override func onChange(t: T.DataType) { base.onChange(t) } } class AnyDataChangedProtocol<DataType> : DataChangedProtocol{ var base: AbstractDataChangedWrapper<DataType> init<S: DataChangedProtocol where S.DataType == DataType>(_ s: S){ self.base = AnyDataChangedWrapper(s) } func onChange(t: DataType) { base.onChange(t) } } class Source : DataChangedProtocol { func onChange(data: String) { print( "got new value \(data)" ) } } class Target { var delegate: AnyDataChangedProtocol<String>? func reportChange(data:String ){ delegate?.onChange(data) } } var source = Source() var target = Target() target.delegate = AnyDataChangedProtocol(source) target.reportChange("newValue")
protocol GetGameStatus { var score: score { get } func getPlayerDetails() }
class SnakesAndLadders: GetGameStatus { func getPlayerDetails() { } }
public override init(){ super.init() } public init(annotations: [MKAnnotation]){ super.init() addAnnotations(annotations: annotations) } public func setAnnotations(annotations:[MKAnnotation]){ tree = nil addAnnotations(annotations: annotations) } public func addAnnotations(annotations:[MKAnnotation]){ if tree == nil { tree = AKQuadTree() } lock.lock() for annotation in annotations { tree!.insertAnnotation(annotation: annotation) } lock.unlock() }
func insertAnnotation(annotation:MKAnnotation) -> Bool { return insertAnnotation(annotation: annotation, toNode:rootNode!) } func insertAnnotation(annotation:MKAnnotation, toNode node:AKQuadTreeNode) -> Bool { if !AKQuadTreeNode.AKBoundingBoxContainsCoordinate(box: node.boundingBox!, coordinate: annotation.coordinate) { return false } if node.count < nodeCapacity { node.annotations.append(annotation) node.count += 1 return true } if node.isLeaf() { node.subdivide() } if insertAnnotation(annotation: annotation, toNode:node.northEast!) { return true } if insertAnnotation(annotation: annotation, toNode:node.northWest!) { return true } if insertAnnotation(annotation: annotation, toNode:node.southEast!) { return true } if insertAnnotation(annotation: annotation, toNode:node.southWest!) { return true } return false }
class A { private func foo() {} fileprivate func bar() {} func baz() { foo() bar() } } extension A { func test() { foo() bar() } } let a = A() a.foo() a.bar()
class ViewController: UIViewController { @IBOutlet var tableView: UITableView! private var titleText = "Demo" fileprivate var list = [String]() override func viewDidLoad() { navigationItem.title = titleText } } extension ViewController: UITableViewDataSource { func numberOfSections(in tableView: UITableView) -> Int { return list.count } }
fileprivate func fact(_ n: Int) -> Int { if (n == 0) { return 1 } else { return n * fact(n - 1) } } private func gauss(_ n: Int) -> Int { if (n == 0) { return 0 } else { return n + gauss(n - 1) } } print(fact(0)) print(fact(5)) print(fact(3)) print(gauss(10)) print(gauss(9))
class Privacy { fileprivate(set) var pu:Int { get { return self.pr } set { self.pr = newValue } } private var pr:Int = 0 fileprivate var fp:Int = 0 func ex() { print("\(self.pu) == \(self.pr) and not \(self.fp)") } } extension Privacy { func ex2() { self.pu = 5 self.ex() } }
func convertStringToDictionary (text:String) -> Dictionary<String,String> { var data :NSData = text.dataUsingEncoding(NSUTF8StringEncoding)! var json :Dictionary = NSJSONSerialization.JSONObjectWithData(data, options:0, error: nil) return json }
- (NSDictionary*)convertStringToDictionary:(NSString*)string { NSError* error; NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; id json = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error]; return json; }
func convertToDictionary(text: String) -> [String: Any]? { if let data = text.data(using: .utf8) { do { return try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] } catch { print(error.localizedDescription) } } return nil } let str = "{\"name\":\"James\"}" let dict = convertToDictionary(text: str)
func convertStringToDictionary(text: String) -> [String:AnyObject]? { if let data = text.dataUsingEncoding(NSUTF8StringEncoding) { do { return try NSJSONSerialization.JSONObjectWithData(data, options: []) as? [String:AnyObject] } catch let error as NSError { print(error) } } return nil } let str = "{\"name\":\"James\"}" let result = convertStringToDictionary(str)
func convertStringToDictionary(text: String) -> [String:String]? { if let data = text.dataUsingEncoding(NSUTF8StringEncoding) { var error: NSError? let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.allZeros, error: &error) as? [String:String] if error != nil { println(error) } return json } return nil } let str = "{\"name\":\"James\"}" let result = convertStringToDictionary(str) if let name = result?["name"] { println(name) }
let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.allZeros, error: &error) as? [String:AnyObject]
func convertStringToDictionary(text: String) -> [String:AnyObject]? { ... }
func convertStringToDictionary(text: String) -> [String:AnyObject]? { if let data = text.dataUsingEncoding(NSUTF8StringEncoding) { do { let json = try NSJSONSerialization.JSONObjectWithData(data, options: .MutableContainers) as? [String:AnyObject] return json } catch { print("Something went wrong") } } return nil }
if let data = text.data(using: String.Encoding.utf8) { do { let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String:Any] print(json) } catch { print("Something went wrong") } }
class func jsonObject(with data: Data, options opt: JSONSerialization.ReadingOptions = []) throws -> Any
import Foundation func convertToDictionary(from text: String) throws -> [String: String] { guard let data = text.data(using: .utf8) else { return [:] } let anyResult: Any = try JSONSerialization.jsonObject(with: data, options: []) return anyResult as? [String: String] ?? [:] }
let string1 = "{\"City\":\"Paris\"}" do { let dictionary = try convertToDictionary(from: string1) print(dictionary) } catch { print(error) }
let string2 = "{\"Quantity\":100}" do { let dictionary = try convertToDictionary(from: string2) print(dictionary) } catch { print(error) }
let string3 = "{\"Object\"}" do { let dictionary = try convertToDictionary(from: string3) print(dictionary) } catch { print(error) }
import Foundation func convertToDictionary(from text: String) throws -> [String: String]? { guard let data = text.data(using: .utf8) else { return [:] } let anyResult: Any = try JSONSerialization.jsonObject(with: data, options: []) return anyResult as? [String: String] }
let string1 = "{\"City\":\"Paris\"}" do { let dictionary = try convertToDictionary(from: string1) print(String(describing: dictionary)) } catch { print(error) }
let string2 = "{\"Quantity\":100}" do { let dictionary = try convertToDictionary(from: string2) print(String(describing: dictionary)) } catch { print(error) }
let string3 = "{\"Object\"}" do { let dictionary = try convertToDictionary(from: string3) print(String(describing: dictionary)) } catch { print(error) }
import Foundation func convertToDictionary(from text: String) -> [String: String] { guard let data = text.data(using: .utf8) else { return [:] } let anyResult: Any? = try? JSONSerialization.jsonObject(with: data, options: []) return anyResult as? [String: String] ?? [:] }
let string1 = "{\"City\":\"Paris\"}" let dictionary1 = convertToDictionary(from: string1) print(dictionary1)
let string2 = "{\"Quantity\":100}" let dictionary2 = convertToDictionary(from: string2) print(dictionary2)
let string3 = "{\"Object\"}" let dictionary3 = convertToDictionary(from: string3) print(dictionary3)
import Foundation func convertToDictionary(from text: String) -> [String: String]? { guard let data = text.data(using: .utf8) else { return nil } let anyResult = try? JSONSerialization.jsonObject(with: data, options: []) return anyResult as? [String: String] }
let string1 = "{\"City\":\"Paris\"}" let dictionary1 = convertToDictionary(from: string1) print(String(describing: dictionary1))
let string2 = "{\"Quantity\":100}" let dictionary2 = convertToDictionary(from: string2) print(String(describing: dictionary2))
let string3 = "{\"Object\"}" let dictionary3 = convertToDictionary(from: string3) print(String(describing: dictionary3))
extension String { func convertToDictionary() -> [String: Any]? { if let data = self.data(using: .utf8) { do { return try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] } catch { print(error.localizedDescription) } } return nil } }
let jsonData = (convertedJsonString as! String).parseJSONString
extension String { var parseJSONString: AnyObject? { let data = self.data(using: String.Encoding.utf8, allowLossyConversion: false) if let jsonData = data { do { let message = try JSONSerialization.jsonObject(with: jsonData, options:.mutableContainers) if let jsonResult = message as? NSMutableArray { return jsonResult } else if let jsonResult = message as? NSMutableDictionary { return jsonResult } else { return nil } } catch let error as NSError { print("An error occurred: \(error)") return nil } } else { return nil } }
let firstUsers = 10.0 let growth = 0.1 var users = firstUsers var week = 0 while users < 14 { println("week \(week) has \(users) users") users += users * growth week += 1 }
var firstUsers = 10.0 let growth = 0.1 var users:Int = Int(firstUsers) var week = 0 while users <= 14 { println("week \(week) has \(users) users") firstUsers += firstUsers * growth users = Int(firstUsers) week += 1 }
let numberOfPlaces = 2.0 let multiplier = pow(10.0, numberOfPlaces) let num = 10.12345 let rounded = round(num * multiplier) / multiplier print(rounded)
func rounded(_ rule: FloatingPointRoundingRule) -> Self
3.000.rounded(.awayFromZero) 3.001.rounded(.awayFromZero) 3.999.rounded(.awayFromZero) (-3.000).rounded(.awayFromZero) (-3.001).rounded(.awayFromZero) (-3.999).rounded(.awayFromZero)
3.000.rounded(.down) 3.001.rounded(.down) 3.999.rounded(.down) (-3.000).rounded(.down) (-3.001).rounded(.down) (-3.999).rounded(.down)
3.000.rounded(.toNearestOrAwayFromZero) 3.001.rounded(.toNearestOrAwayFromZero) 3.499.rounded(.toNearestOrAwayFromZero) 3.500.rounded(.toNearestOrAwayFromZero) 3.999.rounded(.toNearestOrAwayFromZero) (-3.000).rounded(.toNearestOrAwayFromZero) (-3.001).rounded(.toNearestOrAwayFromZero) (-3.499).rounded(.toNearestOrAwayFromZero) (-3.500).rounded(.toNearestOrAwayFromZero) (-3.999).rounded(.toNearestOrAwayFromZero)
3.499.rounded(.toNearestOrEven) 3.500.rounded(.toNearestOrEven) 3.501.rounded(.toNearestOrEven) 4.499.rounded(.toNearestOrEven) 4.500.rounded(.toNearestOrEven) 4.501.rounded(.toNearestOrEven)
3.000.rounded(.towardZero) 3.001.rounded(.towardZero) 3.999.rounded(.towardZero) (-3.000).rounded(.towardZero) (-3.001).rounded(.towardZero) (-3.999).rounded(.towardZero)
Int(3.000) Int(3.001) Int(3.999) Int(-3.000) Int(-3.001) Int(-3.999)
3.000.rounded(.up) 3.001.rounded(.up) 3.999.rounded(.up) (-3.000).rounded(.up) (-3.001).rounded(.up) (-3.999).rounded(.up)
public func rounded(_ rule: FloatingPointRoundingRule) -> Self { var lhs = self lhs.round(rule) return lhs }
public mutating func round(_ rule: FloatingPointRoundingRule) { switch rule { case .toNearestOrAwayFromZero: _value = Builtin.int_round_FPIEEE${bits}(_value) case .toNearestOrEven: _value = Builtin.int_rint_FPIEEE${bits}(_value) case .towardZero: _value = Builtin.int_trunc_FPIEEE${bits}(_value) case .awayFromZero: if sign == .minus { _value = Builtin.int_floor_FPIEEE${bits}(_value) } else { _value = Builtin.int_ceil_FPIEEE${bits}(_value) } case .up: _value = Builtin.int_ceil_FPIEEE${bits}(_value) case .down: _value = Builtin.int_floor_FPIEEE${bits}(_value) } }
let value:Float = 5.678434 let roundedValue = roundf(value * 100) / 100 print(roundedValue)
extension FloatingPoint { func rounded(to n: Int) -> Self { return (self / Self(n)).rounded() * Self(n) } } 324.0.rounded(to: 5)
**In Swift** var a = 14.123456789 var b = 14.123456789 var c = 14.123456789 var d = 14.123456789 var e = 14.123456789 var f = 14.123456789 a.rounded(.up) b.rounded(.down) c.rounded(.awayFromZero) d.rounded(.towardZero) e.rounded(.toNearestOrAwayFromZero) f.rounded(.toNearestOrEven)
self.rangeOfString(find, options: NSStringCompareOptions.CaseInsensitiveSearch) != nil
var city = "San Antonio" var searchString = "san " if(city.rangeOfString(searchString, options: NSStringCompareOptions.CaseInsensitiveSearch) != nil){ print("San Antonio starts with san "); } var myString = "Just a string with san within it" if(myString.rangeOfString(searchString, options: NSStringCompareOptions.CaseInsensitiveSearch) != nil){ print("I don }
"hello dolly".hasPrefix("hello") "hello dolly".hasPrefix("abc")
extension String { func startsWith(string: String) -> Bool { guard let range = rangeOfString(string, options:[.AnchoredSearch, .CaseInsensitiveSearch]) else { return false } return range.startIndex == startIndex } }
var str = "Hello, playground" let matches = str.startsWith("hello") let no_matches = str.startsWith("playground")
let a = 1...3 let b = 1...10 print(b.starts(with: a))
extension String { func caseInsensitiveHasPrefix(_ prefix: String) -> Bool { return lowercased().hasPrefix(prefix.lowercased()) } }
extension String { func caseInsensitiveHasPrefix(_ prefix: String) -> Bool { return lowercased().starts(with: prefix.lowercased()) } }
extension String { func caseInsensitiveHasPrefix(_ prefix: String) -> Bool { return range(of: prefix, options: [.anchored, .caseInsensitive]) != nil } }
extension String { func caseInsensitiveHasPrefix(_ prefix: String) -> Bool { guard let expression = try? NSRegularExpression(pattern: "\(prefix)", options: [.caseInsensitive, .ignoreMetacharacters]) else { return false } return expression.firstMatch(in: self, options: .anchored, range: NSRange(location: 0, length: characters.count)) != nil } }
import Foundation var city = "San Antonio" var searchString = "san " let range = city.range(of: searchString, options:.caseInsensitive) if let range = range { print("San Antonio starts with san at \(range.startIndex)"); }
let range = city.range(of: searchString, options:[.caseInsensitive, .backwards])
func startsWith(string: String) -> Bool { guard let range = range(of: string, options:[.caseInsensitive]) else { return false } return range.lowerBound == startIndex }
import Foundation extension String { func hasPrefixCheck(prefix: String, isCaseSensitive: Bool) -> Bool { if isCaseSensitive == true { return self.hasPrefix(prefix) } else { var thePrefix: String = prefix, theString: String = self while thePrefix.count != 0 { if theString.count == 0 { return false } if theString.lowercased().first != thePrefix.lowercased().first { return false } theString = String(theString.dropFirst()) thePrefix = String(thePrefix.dropFirst()) }; return true } } func hasSuffixCheck(suffix: String, isCaseSensitive: Bool) -> Bool { if isCaseSensitive == true { return self.hasSuffix(suffix) } else { var theSuffix: String = suffix, theString: String = self while theSuffix.count != 0 { if theString.count == 0 { return false } if theString.lowercased().last != theSuffix.lowercased().last { return false } theString = String(theString.dropLast()) theSuffix = String(theSuffix.dropLast()) }; return true } } func containsSubString(theSubString: String, isCaseSensitive: Bool) -> Bool { if isCaseSensitive == true { return self.range(of: theSubString) != nil } else { return self.range(of: theSubString, options: .caseInsensitive) != nil } } }
"testString123".hasPrefixCheck(prefix: "TEST", isCaseSensitive: true) "testString123".hasPrefixCheck(prefix: "TEST", isCaseSensitive: false)
"testString123".hasPrefixCheck(prefix: "test", isCaseSensitive: true) "testString123".hasPrefixCheck(prefix: "test", isCaseSensitive: false)
"testString123".hasSuffixCheck(suffix: "G123", isCaseSensitive: true) "testString123".hasSuffixCheck(suffix: "G123", isCaseSensitive: false)
"testString123".hasSuffixCheck(suffix: "g123", isCaseSensitive: true) "testString123".hasSuffixCheck(suffix: "g123", isCaseSensitive: false)
"testString123".containsSubString(theSubString: "RING12", isCaseSensitive: true) "testString123".containsSubString(theSubString: "RING12", isCaseSensitive: false)
"testString123".containsSubString(theSubString: "ring12", isCaseSensitive: true) "testString123".containsSubString(theSubString: "ring12", isCaseSensitive: false)
import Foundation class AAA: NSObject { func test2() { self.dynamicType } } extension AAA { static let value = 111 }
import Foundation class AAA: NSObject {} extension AAA { @nonobjc static let value = 111 }
static var value: Int { return cache } private let cache = getTheNumber()
static var value: Int { struct Local { static let cache = getTheNumber() } return Local.cache }
extension NotificationsViewController: UITableViewDataSource , UITableViewDelegate { static var timeIntervalFormatter = NSDateComponentsFormatter() }
import UIKit extension UIViewController { var test: Int { return 0 } } final class TestController: UIViewController { override var test: Int { return 1 } }
extension NSOperationQueue { static var parsingQueue : NSOperationQueue = { let queue = NSOperationQueue() queue.maxConcurrentOperationCount = 1 return queue }() }
extension NSOperationQueue { struct Shared { static var parsingQueue : NSOperationQueue = { let queue = NSOperationQueue() queue.maxConcurrentOperationCount = 1 return queue }() } }
extension AAA { private static let value = 111 public func getDatValue() -> Int { return AAA.value } }
self.myTextField.keyboardType = UIKeyboardType.DecimalPad
Can iPhone-Portrait-DecimalPad; using 2617181025_Portrait_iPhone-Simple-Pad_Default
UIBarButtonItem *doneBarButton = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:self action:@selector(doneBarButtonTapped:)]; enhancedNumpadToolbar = [[UIToolbar alloc]init]; [self.enhancedNumpadToolbar setItems:@[doneBarButton]]; self.myNumberTextField.inputAccessoryView = self.enhancedNumpadToolbar;
var latitude : AnyObject! = imageDictionary["latitude"] var longitude : AnyObject! = imageDictionary["longitude"] if let latitudeDouble = latitude as? Double { if let longitudeDouble = longitude as? Double { } }
if let latitudeDouble = latitude as? Double, longitudeDouble = longitude as? Double { }
if let latitudeDouble = latitude as? Double, let longitudeDouble = longitude as? Double { }
if let latitudeDouble = latitude as? Double, importantThing == true { }
if let latitudeDouble = latitude as? Double, longitudeDouble = longitude as? Double { }
var latitude: Any! = imageDictionary["latitude"] var longitude: Any! = imageDictionary["longitude"] switch (latitude, longitude) { case let (lat as Double, long as Double): println("lat: \(lat), long: \(long)") default: println("Couldn }
if let latitudeDouble = latitude as? Double, let longitudeDouble = longitude as? Double { }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] if let latitude = latitude as? Double, let longitude = longitude as? Double { print(latitude, longitude) }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] switch (latitude, longitude) { case let (Optional.some(latitude as Double), Optional.some(longitude as Double)): print(latitude, longitude) default: break }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] switch (latitude, longitude) { case let (latitude as Double, longitude as Double): print(latitude, longitude) default: break }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] switch (latitude as? Double, longitude as? Double) { case let (.some(latitude), .some(longitude)): print(latitude, longitude) default: break }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] switch (latitude as? Double, longitude as? Double) { case let (latitude?, longitude?): print(latitude, longitude) default: break }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] if case let (.some(latitude as Double), .some(longitude as Double)) = (latitude, longitude) { print(latitude, longitude) }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] if case let (latitude as Double, longitude as Double) = (latitude, longitude) { print(latitude, longitude) }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] if case let (.some(latitude), .some(longitude)) = (latitude as? Double, longitude as? Double) { print(latitude, longitude) }
let dict = ["latitude": 2.0 as AnyObject?, "longitude": 10.0 as AnyObject?] let latitude = dict["latitude"] let longitude = dict["longitude"] if case let (latitude?, longitude?) = (latitude as? Double, longitude as? Double) { print(latitude, longitude) }
import Foundation var dice1: UInt32 = 0 var dice2: UInt32 = 0 var i = 0 var snakeeyes = 0 var `double` = 0 while i < 100{
dice1 = arc4random_uniform(1..7) dice2 = arc4random_uniform(1..7)
if dice1 == 1 && dice2 == 1 { snakeeyes = snakeeyes + 1 } if dice1 == dice2{ `double` = `double` + 1 } i = i + 1 } println("You got Snake Eyes \(snakeeyes) times.") println("You got Doubles, \(`double`) times.")
extension Int { static func random(range: Range<Int> ) -> Int { var offset = 0 if range.startIndex < 0 { offset = abs(range.startIndex) } let mini = UInt32(range.startIndex + offset) let maxi = UInt32(range.endIndex + offset) return Int(mini + arc4random_uniform(maxi - mini)) - offset } }
extension Range { var randomInt: Int { get { var offset = 0 if (startIndex as Int) < 0 { offset = abs(startIndex as Int) } let mini = UInt32(startIndex as Int + offset) let maxi = UInt32(endIndex as Int + offset) return Int(mini + arc4random_uniform(maxi - mini)) - offset } } } let nr = (-1000 ... 1100).randomInt
func randomNumber(range: Range<Int> = 1...6) -> Int { let min = range.startIndex let max = range.endIndex return Int(arc4random_uniform(UInt32(max - min))) + min }
func randomNumber<T : SignedInteger>(inRange range: ClosedRange<T> = 1...6) -> T { let length = (range.upperBound - range.lowerBound + 1).toIntMax() let value = arc4random().toIntMax() % length + range.lowerBound.toIntMax() return T(value) }
public func randomNumber<T : SignedInteger>(inRange range: ClosedRange<T> = 1...6) -> T { let length = Int64(range.upperBound - range.lowerBound + 1) let value = Int64(arc4random()) % length + Int64(range.lowerBound) return T(value) }
extension Collection { func randomItem() -> Self.Iterator.Element { let count = distance(from: startIndex, to: endIndex) let roll = randomNumber(inRange: 0...count-1) return self[index(startIndex, offsetBy: roll)] } }
/** Arc Random for Double and Float */ public func arc4random <T: IntegerLiteralConvertible> (type: T.Type) -> T { var r: T = 0 arc4random_buf(&r, UInt(sizeof(T))) return r } public extension Int { /** Create a random num Int :param: lower number Int :param: upper number Int :return: random number Int By DaRkDOG */ public static func random ( return lower + Int(arc4random_uniform(upper - lower + 1)) } } public extension Double { /** Create a random num Double :param: lower number Double :param: upper number Double :return: random number Double By DaRkDOG */ public static func random( let r = Double(arc4random(UInt64)) / Double(UInt64.max) return (r * (upper - lower)) + lower } } public extension Float { /** Create a random num Float :param: lower number Float :param: upper number Float :return: random number Float By DaRkDOG */ public static func random( let r = Float(arc4random(UInt32)) / Float(UInt32.max) return (r * (upper - lower)) + lower } }
let randomNumDouble = Double.random(lower: 0.00, upper: 23.50) let randomNumInt = Int.random(lower: 56, upper: 992) let randomNumInt =Float.random(lower: 6.98, upper: 923.09)
func randomNumber(range: ClosedRange<Int> = 1...6) -> Int { let min = range.lowerBound let max = range.upperBound return Int(arc4random_uniform(UInt32(1 + max - min))) + min }
let randomDouble = Double.random(in: -7.9...12.8) let randomIntFrom0To10 = Int.random(in: 0 ..< 10)
/** Arc Random for Double and Float */ public func arc4random <T: IntegerLiteralConvertible> (type: T.Type) -> T { var r: T = 0 arc4random_buf(&r, sizeof(T)) return r } public extension Int { /** Create a random num Int :param: lower number Int :param: upper number Int :return: random number Int By DaRkDOG */ public static func random (lower: Int , upper: Int) -> Int { return lower + Int(arc4random_uniform(UInt32(upper - lower + 1))) } } public extension Double { /** Create a random num Double :param: lower number Double :param: upper number Double :return: random number Double By DaRkDOG */ public static func random(lower: Double, upper: Double) -> Double { let r = Double(arc4random(UInt64)) / Double(UInt64.max) return (r * (upper - lower)) + lower } } public extension Float { /** Create a random num Float :param: lower number Float :param: upper number Float :return: random number Float By DaRkDOG */ public static func random(lower: Float, upper: Float) -> Float { let r = Float(arc4random(UInt32)) / Float(UInt32.max) return (r * (upper - lower)) + lower } }
func random(min: Int, _ max: Int) -> Int { guard min < max else {return min} return Int(arc4random_uniform(UInt32(1 + max - min))) + min }
let randomNumber = arc4random_uniform(8999) + 1000 let randomNumber = arc4random_uniform(899999999) + 100000000 let randomNumber = arc4random_uniform(89) + 10 let randomNumber = arc4random_uniform(899) + 100
func generateRandomNumber(numDigits: Int) -> Int{ var place = 1 var finalNumber = 0; var finanum = 0; for var i in 0 ..< numDigits { place *= 10 let randomNumber = arc4random_uniform(10) finalNumber += Int(randomNumber) * place finanum = finalNumber / 10 i += 1 } return finanum }
public extension Range where Bound == Int { var random: Int { return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound))) } } public extension ClosedRange where Bound == Int { var random: Int { return lowerBound + Int(arc4random_uniform(UInt32(upperBound - lowerBound + 1))) } }
extension Int { static func random(range: Range<Int> ) -> Int { var offset = 0 if range.lowerBound < 0 { offset = Swift.abs(range.lowerBound) } let mini = UInt32(range.lowerBound + offset) let maxi = UInt32(range.upperBound + offset) return Int(mini + arc4random_uniform(maxi - mini)) - offset } }
var randomNumber = Int(arc4random_uniform(6)) print(randomNumber)
extension CountableClosedRange where Bound == Int { var randomFromRange: Bound { get { var offset = 0 if lowerBound < 0 { offset = abs(lowerBound) } let mini = UInt32(lowerBound + offset) let maxi = UInt32(upperBound + offset) return Int(mini + arc4random_uniform(maxi - mini)) - offset } } } let n = (-1000 ... 1000).randomFromRange print(n)
extension CountableRange where Bound == Int { var randomFromRange: Bound { return uniformRandom(from: lowerBound, to: upperBound) } } extension CountableClosedRange where Bound == Int { var randomFromRange: Bound { return uniformRandom(from: lowerBound, to: upperBound - 1) } } func uniformRandom(from: Int, to: Int) -> Int { var offset = 0 if from < 0 { offset = abs(from) } let mini = UInt32(from + offset) let maxi = UInt32(to + offset) return Int(mini + arc4random_uniform(maxi - mini)) - offset }
Int { public static func random(in range: ClosedRange<Int>) -> Int public static func random(in range: Range<Int>) -> Int }
class func getSomeObject() -> [SomeObject]? { let objects = Realm().objects(SomeObject) return objects.count > 0 ? objects : nil }
extension Results { func toArray<T>(ofType: T.Type) -> [T] { var array = [T]() for i in 0 ..< count { if let result = self[i] as? T { array.append(result) } } return array } }
class func getSomeObject() -> [SomeObject]? { let objects = Realm().objects(SomeObject).toArray(SomeObject) as [SomeObject] return objects.count > 0 ? objects : nil }
extension Results { func toArray<T>(ofType: T.Type) -> [T] { var array = [T]() for i in 0 ..< count { if let result = self[i] as? T { array.append(result) } } return array } }
class func getSomeObject() -> [SomeObject]? { let defaultRealm = try! Realm() let objects = defaultRealm.objects(SomeObject.self).toArray(ofType : SomeObject.self) as [SomeObject] return objects.count > 0 ? objects : nil }
class func getSomeObject() -> [T]? { let objects = Realm().objects(T.self as! Object.Type).toArray(ofType : T.self) as [T] return objects.count > 0 ? objects : nil }
class func getSomeObject() -> [SomeObject]? { var someObjects: [SomeObject] = [] let objects = Realm().objects(SomeObject) for object in objects{ someObjects += [object] } return objects.count > 0 ? someObjects : nil }
func toArray<T>(ofType: T.Type) -> [T] { return flatMap { $0 as? T } }
var refrenceBook:[RefrenceProtocol] = [] let faceTypes = Array(realm.objects(FaceType)) refrenceBook = faceTypes.map({$0 as FaceType})
extension Results { var array: [Element]? { return self.count > 0 ? self.map { $0 } : nil } }
Realm().objects(SomeClass.self).filter("someKey ENDSWITH %@", "sth").array
extension Results { func toArray<T>(ofType: T.Type) -> [T] { let array = Array(self) as! [T] return array } }
let array = Realm().objects(SomeClass).toArray(ofType: SomeClass.self)
extension Results { func toArray() -> [T] { return self.map { $0 } } }
extension Results { func toArray<T>(type: T.Type) -> [T] { return flatMap { $0 as? T } } }
extension Results { func toArray<T>(type: T.Type) -> [T] { return compactMap { $0 as? T } } }
func collectionView(collectionView: UICollectionView!, numberOfItemsInSection section: Int) -> Int { return 5 } func collectionView(collectionView: UICollectionView!, cellForItemAtIndexPath indexPath: NSIndexPath!) -> UICollectionViewCell! { var cell = collectionView.dequeueReusableCellWithReuseIdentifier("title", forIndexPath: indexPath) as TitleCollectionViewCell cell.labelTitle.text = "This is a title" return cell }
func dequeueReusableCellWithIdentifier(identifier: String!) -> AnyObject!
fatal error: unexpectedly found nil while unwrapping an Optional value
if let label = cell.labelTitle{ label.text = "This is a title" }
override func viewDidLoad() { super.viewDidLoad() let nib = UINib(nibName: "<WhateverYourNibName>", bundle: nil) self.collectionView.registerNib(nib, forCellReuseIdentifier: "title") }
rowName = rowName != nil ?rowName!.stringFromCamelCase():""
override func viewDidAppear(_ animated: Bool) { let alertController = UIAlertController (title: "Title", message: "Go to Settings?", preferredStyle: .alert) let settingsAction = UIAlertAction(title: "Settings", style: .default) { (_) -> Void in guard let settingsUrl = URL(string: UIApplication.openSettingsURLString) else { return } if UIApplication.shared.canOpenURL(settingsUrl) { UIApplication.shared.open(settingsUrl, completionHandler: { (success) in print("Settings opened: \(success)") }) } } alertController.addAction(settingsAction) let cancelAction = UIAlertAction(title: "Cancel", style: .default, handler: nil) alertController.addAction(cancelAction) present(alertController, animated: true, completion: nil) }
override func viewDidAppear(animated: Bool) { var alertController = UIAlertController (title: "Title", message: "Go to Settings?", preferredStyle: .Alert) var settingsAction = UIAlertAction(title: "Settings", style: .Default) { (_) -> Void in let settingsUrl = NSURL(string: UIApplicationOpenSettingsURLString) if let url = settingsUrl { UIApplication.sharedApplication().openURL(url) } } var cancelAction = UIAlertAction(title: "Cancel", style: .Default, handler: nil) alertController.addAction(settingsAction) alertController.addAction(cancelAction) presentViewController(alertController, animated: true, completion: nil) }
UIApplication.shared.open(URL.init(string: UIApplicationOpenSettingsURLString)!, options: [:], completionHandler: nil)
UIApplication.shared.open(URL(string:"App-Prefs:root=General")!, options: [:], completionHandler: nil)
UIApplication.sharedApplication().openURL(NSURL(string:"prefs:root=General")!)
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"prefs:root=General"]];
func buttonClicked(sender:UIButton) { UIApplication.sharedApplication().openURL(NSURL(string: UIApplicationOpenSettingsURLString)) }
let settingsUrl = URL(string: UIApplicationOpenSettingsURLString)! UIApplication.shared.open(settingsUrl)
import Foundation import UIKit public enum PreferenceType: String { case about = "General&path=About" case accessibility = "General&path=ACCESSIBILITY" case airplaneMode = "AIRPLANE_MODE" case autolock = "General&path=AUTOLOCK" case cellularUsage = "General&path=USAGE/CELLULAR_USAGE" case brightness = "Brightness" case bluetooth = "Bluetooth" case dateAndTime = "General&path=DATE_AND_TIME" case facetime = "FACETIME" case general = "General" case keyboard = "General&path=Keyboard" case castle = "CASTLE" case storageAndBackup = "CASTLE&path=STORAGE_AND_BACKUP" case international = "General&path=INTERNATIONAL" case locationServices = "LOCATION_SERVICES" case accountSettings = "ACCOUNT_SETTINGS" case music = "MUSIC" case equalizer = "MUSIC&path=EQ" case volumeLimit = "MUSIC&path=VolumeLimit" case network = "General&path=Network" case nikePlusIPod = "NIKE_PLUS_IPOD" case notes = "NOTES" case notificationsId = "NOTIFICATIONS_ID" case phone = "Phone" case photos = "Photos" case managedConfigurationList = "General&path=ManagedConfigurationList" case reset = "General&path=Reset" case ringtone = "Sounds&path=Ringtone" case safari = "Safari" case assistant = "General&path=Assistant" case sounds = "Sounds" case softwareUpdateLink = "General&path=SOFTWARE_UPDATE_LINK" case store = "STORE" case twitter = "TWITTER" case facebook = "FACEBOOK" case usage = "General&path=USAGE" case video = "VIDEO" case vpn = "General&path=Network/VPN" case wallpaper = "Wallpaper" case wifi = "WIFI" case tethering = "INTERNET_TETHERING" case blocked = "Phone&path=Blocked" case doNotDisturb = "DO_NOT_DISTURB" }
enum PreferenceExplorerError: Error { case notFound(String) } open class PreferencesExplorer { static private let preferencePath = "App-Prefs:root" static func open(_ preferenceType: PreferenceType) throws { let appPath = "\(PreferencesExplorer.preferencePath)=\(preferenceType.rawValue)" if let url = URL(string: appPath) { if UIApplication.shared.open(url, options: [:], completionHandler: nil) } else { UIApplication.shared.openURL(url) } } else { throw PreferenceExplorerError.notFound(appPath) } } }
if let appSettings = URL(string: UIApplicationOpenSettingsURLString + Bundle.main.bundleIdentifier!) { if UIApplication.shared.canOpenURL(appSettings) { UIApplication.shared.open(appSettings) } }
UIApplication.shared.openURL(URL(string:UIApplicationOpenSettingsURLString)!)
UIApplication.shared.openURL(URL(string:"prefs:root=General")!)
UIApplication.sharedApplication() .openURL(NSURL(string:"prefs:root=General")!)
UIApplication.sharedApplication().openURL(NSURL(string:"App-Prefs:root=General")!)
UIApplication.shared.openURL(URL(string:"prefs:root=General")!)
UIApplication.shared.openURL(URL(string:"App-Prefs:root=General")!)
@objc func openAppSpecificSettings() { guard let url = URL(string: UIApplication.openSettingsURLString), UIApplication.shared.canOpenURL(url) else { return } let optionsKeyDictionary = [UIApplication.OpenExternalURLOptionsKey(rawValue: "universalLinksOnly"): NSNumber(value: true)] UIApplication.shared.open(url, options: optionsKeyDictionary, completionHandler: nil) }
static func open(_ preferenceType: PreferenceType) throws { var preferencePath: String if preferencePath = UIApplicationOpenSettingsURLString } else { preferencePath = "\(PreferencesExplorer.preferencePath)=\(preferenceType.rawValue)" } if let url = URL(string: preferencePath) { if UIApplication.shared.open(url, options: [:], completionHandler: nil) } else { UIApplication.shared.openURL(url) } } else { throw PreferenceExplorerError.notFound(preferencePath) } }
UIApplication.shared.openURL(URL(string: UIApplicationOpenSettingsURLString)!)
let str = "A String" println(" str value \(str) has address: ?")
var str = "A String" withUnsafePointer(to: &str) { print(" str value \(str) has address: \($0)") }
print(Unmanaged.passUnretained(someVar).toOpaque())
print(Unmanaged<AnyObject>.passUnretained(someVar as AnyObject).toOpaque())
println(" str value \(str) has address: \(unsafeAddressOf(str))")
var aString : String = "THIS IS A STRING" NSLog("%p", aString.core._baseAddress)
var aString : String = "THIS IS A STRING" + "This is another String" NSLog("%p", aString.core._baseAddress)
void takesInt(int *intptr) { printf("%p", intptr); }
var aString : NSString = "This is a string" var anUnmanaged = Unmanaged<NSString>.passUnretained(aString) var opaque : COpaquePointer = anUnmanaged.toOpaque() var mut : CMutablePointer = &opaque printptr(mut)
func playWithPointer (stringa :AutoreleasingUnsafePointer<NSString>) { stringa.memory = "String Updated"; } var testString : NSString = "test string" println(testString) playWithPointer(&testString) println(testString)
+ (void)writeString:(void **)var { NSMutableString *aString = [[NSMutableString alloc] initWithFormat:@"pippo %@", @"pluto"]; *var = (void *)CFBridgingRetain(aString); } var opaque = COpaquePointer.null() TestClass.writeString(&opaque) var string = Unmanaged<NSString>.fromOpaque(opaque).takeRetainedValue() println(string)
func address<T: AnyObject>(o: T) -> Int { return unsafeBitCast(o, Int.self) } class Test {} var o = Test() println(NSString(format: "%p", address(o)))
func address(o: UnsafePointer<Void>) -> Int { return unsafeBitCast(o, Int.self) } println(NSString(format: "%p", address(&o))) var s = "A String" println(NSString(format: "%p", address(&s))) var i = 55 println(NSString(format: "%p", address(&i)))
(lldb) x/g 0x7fff5fbfe658 0x7fff5fbfe658: 0x00006100000011d0
struct MemoryAddress<T>: CustomStringConvertible { let intValue: Int var description: String { let length = 2 + 2 * MemoryLayout<UnsafeRawPointer>.size return String(format: "%0\(length)p", intValue) } init(of structPointer: UnsafePointer<T>) { intValue = Int(bitPattern: structPointer) } } extension MemoryAddress where T: AnyObject { init(of classInstance: T) { intValue = unsafeBitCast(classInstance, to: Int.self) } } class MyClass { let foo = 42 } var classInstance = MyClass() let classInstanceAddress = MemoryAddress(of: classInstance) print(String(format: "%018p", classInstanceAddress.intValue)) print(classInstanceAddress) struct MyStruct { let foo = 1 } var structInstance = MyStruct() let structInstanceAddress = MemoryAddress(of: &structInstance) print(String(format: "%018p", structInstanceAddress.intValue)) print(structInstanceAddress)
(lldb) frame variable -L n 0x00000001005e2e08: (Int) n = 42 (lldb) memory read -c 8 0x00000001005e2e08 0x1005e2e08: 2a 00 00 00 00 00 00 00
(lldb) frame variable c (testmem.C) c = 0x0000000101a08f90 (foo = 42, bar = 84) (lldb) memory read 0x0000000101a08f90 0x101a08f90: e0 65 5b 00 01 00 00 00 02 00 00 00 00 00 00 00 0x101a08fa0: 2a 00 00 00 00 00 00 00 54 00 00 00 00 00 00 00
(lldb) frame variable referencePointer (UnsafeMutablePointer<testmem.C>) referencePointer = 0x00000001005e2e00 (lldb) memory read -c 8 0x00000001005e2e00 0x1005e2e00: 20 ec 92 01 01 00 00 00 (lldb) frame variable c (testmem.C) c = 0x000000010192ec20 (foo = 42, bar = 84)
(lldb) frame variable addressY -f hex (Int) addressY = 0x0000000101b2fd20 (lldb) frame variable c (testmem.C) c = 0x0000000101b2fd20 (foo = 42, bar = 84)
let addressY1 = Int(bitPattern: Unmanaged.passUnretained(c).toOpaque()) let addressY2 = withUnsafeMutableBytes(of: &c) { $0.load(as: Int.self) }
class C {} let c1 = C() let c2 = c1 print("c1 address: \(Unmanaged.passUnretained(c1).toOpaque())") let o1 = ObjectIdentifier(c1) let o2 = ObjectIdentifier(c2) print("o1 -> c1 = \(o1)") print("o2 -> c2 = \(o2)") if o1 == o2 { print("c1 = c2") } else { print("c1 != c2") }
extension String { static func pointer(_ object: AnyObject?) -> String { guard let object = object else { return "nil" } let opaque: UnsafeMutableRawPointer = Unmanaged.passUnretained(object).toOpaque() return String(describing: opaque) } }
print("FileManager.default: \(String.pointer(FileManager.default))") print("nil: \(String.pointer(nil))")
public extension NSObject { public var pointerString: String { return String(format: "%p", self) } }
let ptr = unsafeAddressOf(obj) let nullPtr = UnsafePointer<Void>(bitPattern: 0) let address = nullPtr.distanceTo(ptr)
func address(o: UnsafePointer<Void>) { let addr = unsafeBitCast(o, Int.self) print(NSString(format: "%p", addr)) } func address<T: AnyObject>(o: T) -> String{ let addr = unsafeBitCast(o, Int.self) return NSString(format: "%p", addr) as String }
let objPtr = Unmanaged.passUnretained(Thread.current).toOpaque() let onePtr = UnsafeMutableRawPointer(bitPattern: 1)! let rawAddress : Int64 = onePtr.distance(to: objPtr) + 1 let address = rawAddress % (256 * 1024 * 1024 * 1024)
extension MyClass: CustomStringConvertible { var description: String { return "<\(type(of: self)): 0x\(String(unsafeBitCast(self, to: Int.self), radix: 16, uppercase: false))>" } }
let array1 = [1,2,3] let array2 = array1 array1.withUnsafeBufferPointer { (point) in print(point) } array2.withUnsafeBufferPointer { (point) in print(point) }
public extension NSObject { public var memoryAddress : String? { let str = "\(self.self)".components(separatedBy: ": ") guard str.count > 1 else { return nil } return str[1].replacingOccurrences(of: ">", with: "") } } let foo : String! = "hello" Swift.print(foo.memoryAddress)
var d = ["foo" : 1, "bar" : 2] d.map() { $0.1 += 1 }
let newDict = Dictionary(uniqueKeysWithValues: oldDict.map { key, value in (key.uppercased(), value.lowercased()) })
func map<T>(_ transform: (Iterator.Element) throws -> T) rethrows -> [T]
result = dict.map { (key, value) in (key, value.uppercaseString) }
extension Dictionary { init(_ pairs: [Element]) { self.init() for (k, v) in pairs { self[k] = v } } } result = Dictionary(dict.map { (key, value) in (key, value.uppercaseString) })
extension Dictionary { func mapPairs<OutKey: Hashable, OutValue>(_ transform: (Element) throws -> (OutKey, OutValue)) rethrows -> [OutKey: OutValue] { return Dictionary<OutKey, OutValue>(try map(transform)) } func filterPairs(_ includeElement: (Element) throws -> Bool) rethrows -> [Key: Value] { return Dictionary(try filter(includeElement)) } }
result = dict.mapPairs { (key, value) in (key, value.uppercaseString) }
extension Dictionary { func map<OutValue>(_ transform: (Value) throws -> OutValue) rethrows -> [Key: OutValue] { return Dictionary<Key, OutValue>(try map { (k, v) in (k, try transform(v)) }) } }
let dictionary = ["foo": 1, "bar": 2, "baz": 5] let newDictionary = dictionary.mapValues { value in return value + 1 } print(newDictionary)
let dictionary = ["foo": 1, "bar": 2, "baz": 5] let tupleArray = dictionary.map { (key: String, value: Int) in return (key, value + 1) } let newDictionary = Dictionary(uniqueKeysWithValues: tupleArray) print(newDictionary)
let dictionary = ["foo": 1, "bar": 2, "baz": 5] let newDictionary = dictionary.reduce([:]) { (partialResult: [String: Int], tuple: (key: String, value: Int)) in var result = partialResult result[tuple.key] = tuple.value + 1 return result } print(newDictionary)
let dictionary = ["foo": 1, "bar": 2, "baz": 5] var newDictionary = [String: Int]() for (key, value) in dictionary { newDictionary[key, default: value] += 1 } print(newDictionary)
let dictionary = ["foo": 1, "bar": 2, "baz": 5] var newDictionary = [String: Int]() for (key, value) in dictionary { newDictionary[key] = value + 1 } print(newDictionary)
extension Dictionary { init<S: SequenceType where S.Generator.Element == Element> (_ seq: S) { self.init() for (k,v) in seq { self[k] = v } } func mapValues<T>(transform: Value->T) -> Dictionary<Key,T> { return Dictionary<Key,T>(zip(self.keys, self.values.map(transform))) } }
extension Dictionary { mutating func map(transform: (key:KeyType, value:ValueType) -> (newValue:ValueType)) { for key in self.keys { var newValue = transform(key: key, value: self[key]!) self.updateValue(newValue, forKey: key) } } }
var dic = ["a": 50, "b": 60, "c": 70] dic.map { $0.1 + 1 } println(dic) dic.map { (key, value) in if key == "a" { return value } else { return value * 2 } } println(dic)
let oldDict = ["old1": 1, "old2":2] let newDict = reduce(oldDict, [String:Int]()) { dict, pair in var d = dict d["new\(pair.1)"] = pair.1 return d } println(newDict)
var dictionary = ["foo" : 1, "bar" : 2] Array(dictionary.keys).map() { dictionary.updateValue(dictionary[$0]! + 1, forKey: $0) } dictionary
var d = ["foo" : 1, "bar" : 2] for (name, key) in d { d[name] = d[name]! + 1 }
extension Dictionary { func mapKeys<U> (transform: Key -> U) -> Array<U> { var results: Array<U> = [] for k in self.keys { results.append(transform(k)) } return results } func mapValues<U> (transform: Value -> U) -> Array<U> { var results: Array<U> = [] for v in self.values { results.append(transform(v)) } return results } func map<U> (transform: Value -> U) -> Array<U> { return self.mapValues(transform) } func map<U> (transform: (Key, Value) -> U) -> Array<U> { var results: Array<U> = [] for k in self.keys { results.append(transform(k as Key, self[ k ]! as Value)) } return results } func map<K: Hashable, V> (transform: (Key, Value) -> (K, V)) -> Dictionary<K, V> { var results: Dictionary<K, V> = [:] for k in self.keys { if let value = self[ k ] { let (u, w) = transform(k, value) results.updateValue(w, forKey: u) } } return results } }
self.values = values.map({ (key:String, value:NSNumber) -> VDLFilterValue in return VDLFilterValue(name: key, amount: value) })
let oldDict = ["key0": "val0", "key1": nil, "key1": "val2","key2": nil] var newDict = [String: String]() oldDict.forEach { (source: (key: String, value: String?)) in if let value = source.value{ newDict[source.key] = value } }
func mapValues<K,V1,V2>(d1:[K:V1], closure:(V1)->V2) -> [K:V2] { var d2 = [K:V2]() for (key,value) in zip(d1.keys, d1.values.map(closure)) { d2.updateValue(value, forKey: key) } return d2 }
let d : [String:Int] = ["one":1, "two":2] let result = mapValues(d) { (i : Int) -> String in String(i) }
let bob = ["a": "AAA", "b": "BBB", "c": "CCC"] bob.mapDictionary { ($1, $0) }
extension Dictionary { func mapDictionary(transform: (Key, Value) -> (Key, Value)?) -> Dictionary<Key, Value> { var dict = [Key: Value]() for key in keys { guard let value = self[key], let keyValue = transform(key, value) else { continue } dict[keyValue.0] = keyValue.1 } return dict } }
let dictionary = ["a": 1, "b": 2, "c": 3] func keyTransform(key: String) -> Int { return Int(key.unicodeScalars.first!.value) } func valueTransform(value: Int) -> String { return String(value) } dictionary.map { (key, value) in [keyTransform(key): valueTransform(value)] }.reduce([Int:String]()) { memo, element in var m = memo for (k, v) in element { m.updateValue(v, forKey: k) } return m }
extension Dictionary { func valuesMapped<T>(_ transform: (Value) -> T) -> [Key: T] { var newDict = [Key: T]() for (key, value) in self { newDict[key] = transform(value) } return newDict } }
let stringsDict = intsDict.valuesMapped { String($0 * 2) }
let complexStringsDict = intsDict.valuesMapped { (value: Int) -> String in let calculationResult = (value * 3 + 7) % 5 return String("Complex number }
func mapDict(dict:[String:Any])->[String:String]{ var updatedDict:[String:String] = [:] for key in dict.keys{ if let value = dict[key]{ updatedDict[key] = String(describing: value) } } return updatedDict }
let dict:[String:Any] = ["MyKey":1] let mappedDict:[String:String] = mapDict(dict: dict)
struct MyOptions : OptionSet { let rawValue: Int static let firstOption = MyOptions(rawValue: 1 << 0) static let secondOption = MyOptions(rawValue: 1 << 1) static let thirdOption = MyOptions(rawValue: 1 << 2) }
let singleOption = MyOptions.firstOption let multipleOptions: MyOptions = [.firstOption, .secondOption] if multipleOptions.contains(.secondOption) { print("multipleOptions has SecondOption") } let allOptions = MyOptions(rawValue: 7) if allOptions.contains(.thirdOption) { print("allOptions has ThirdOption") }
struct MyOptions : OptionSetType { let rawValue: Int static let None = MyOptions(rawValue: 0) static let FirstOption = MyOptions(rawValue: 1 << 0) static let SecondOption = MyOptions(rawValue: 1 << 1) static let ThirdOption = MyOptions(rawValue: 1 << 2) }
let singleOption = MyOptions.FirstOption let multipleOptions: MyOptions = [.FirstOption, .SecondOption] if multipleOptions.contains(.SecondOption) { print("multipleOptions has SecondOption") } let allOptions = MyOptions(rawValue: 7) if allOptions.contains(.ThirdOption) { print("allOptions has ThirdOption") }
struct MyOptions : RawOptionSetType { typealias RawValue = UInt private var value: UInt = 0 init(_ value: UInt) { self.value = value } init(rawValue value: UInt) { self.value = value } init(nilLiteral: ()) { self.value = 0 } static var allZeros: MyOptions { return self(0) } static func fromMask(raw: UInt) -> MyOptions { return self(raw) } var rawValue: UInt { return self.value } static var None: MyOptions { return self(0) } static var FirstOption: MyOptions { return self(1 << 0) } static var SecondOption: MyOptions { return self(1 << 1) } static var ThirdOption: MyOptions { return self(1 << 2) } }
let opt1 = MyOptions.FirstOption let opt2: MyOptions = .SecondOption let opt3 = MyOptions(4)
let singleOption = MyOptions.FirstOption let multipleOptions: MyOptions = singleOption | .SecondOption if multipleOptions & .SecondOption != nil { println("multipleOptions has SecondOption") } let allOptions = MyOptions.fromMask(7) if allOptions & .ThirdOption != nil { println("allOptions has ThirdOption") }
struct MyOptions : RawOptionSetType, BooleanType { private var value: UInt init(_ rawValue: UInt) { self.value = rawValue } init(rawValue: UInt) { self.value = rawValue } init(nilLiteral: ()) { self.value = 0} var rawValue: UInt { return self.value } var boolValue: Bool { return self.value != 0 } static var allZeros: MyOptions { return self(0) } static var None: MyOptions { return self(0) } static var FirstOption: MyOptions { return self(1 << 0) } static var SecondOption: MyOptions { return self(1 << 1) } static var ThirdOption: MyOptions { return self(1 << 2) } static var All: MyOptions { return self(0b111) } }
let opt1 = MyOptions.FirstOption let opt2:MyOptions = .SecondOption let opt3 = MyOptions(4)
let singleOption = MyOptions.FirstOption let multipleOptions: MyOptions = singleOption | .SecondOption if multipleOptions & .SecondOption { println("multipleOptions has SecondOption") } let allOptions = MyOptions.All if allOptions & .ThirdOption { println("allOptions has ThirdOption") }
struct PackagingOptions : OptionSetType { let rawValue: Int init(rawValue: Int) { self.rawValue = rawValue } static let Box = PackagingOptions(rawValue: 1) static let Carton = PackagingOptions(rawValue: 2) static let Bag = PackagingOptions(rawValue: 4) static let Satchel = PackagingOptions(rawValue: 8) static let BoxOrBag: PackagingOptions = [Box, Bag] static let BoxOrCartonOrBag: PackagingOptions = [Box, Carton, Bag] }
struct Direction : OptionSetType { let rawValue: Int static let None = Direction(rawValue: 0) static let Top = Direction(rawValue: 1 << 0) static let Bottom = Direction(rawValue: 1 << 1) static let Left = Direction(rawValue: 1 << 2) static let Right = Direction(rawValue: 1 << 3) } var direction: Direction = Direction.None direction.insert(Direction.Right) if direction.contains(.Right) { }
enum Animal: BitwiseOptionsType { case Chicken case Cow case Goat static let allOptions = [.Chicken, .Cow, .Goat] } var animals = Animal.Chicken | Animal.Goat animals ^= .Goat if animals & .Chicken == .Chicken { println("Chick-Fil-A!") }
protocol OptionsProtocol { var value: UInt { get } init (_ value: UInt) } func | <T: OptionsProtocol>(left: T, right: T) -> T { return T(left.value | right.value) } func & <T: OptionsProtocol>(left: T, right: T) -> Bool { if right.value == 0 { return left.value == 0 } else { return left.value & right.value == right.value } }
struct MyOptions: OptionsProtocol { private(set) var value: UInt init (_ val: UInt) {value = val} static var None: MyOptions { return self(0) } static var One: MyOptions { return self(1 << 0) } static var Two: MyOptions { return self(1 << 1) } static var Three: MyOptions { return self(1 << 2) } }
func myMethod( if options & .One { } } myMethod(options: .One | .Three)
struct CoffeeManipulators : OptionSetType { let rawValue: Int static let Milk = CoffeeManipulators(rawValue: 1) static let Sugar = CoffeeManipulators(rawValue: 2) static let MilkAndSugar = [Milk, Sugar] }
struct Coffee { let manipulators:[CoffeeManipulators] func hasMilk() -> Bool { return manipulators.contains(.Milk) } func hasManipulators() -> Bool { return manipulators.count != 0 } }
struct State: OptionSetType { let rawValue: Int static let A = State(rawValue: 1 << 0) static let B = State(rawValue: 1 << 1) static let X = State(rawValue: 1 << 2) static let AB:State = [.A, .B] static let ABX:State = [.AB, .X] } let state: State = .ABX state.contains(.A) state.contains(.AB)
enum Toppings : String { case Tomato = "tomato" case Salami = "salami" case Cheese = "cheese" case Chicken = "chicken" case Beef = "beef" case Anchovies = "anchovies" static let AllOptions: Set<Toppings> = [.Tomato, .Salami, .Cheese, .Chicken, .Anchovies, .Beef] } func checkPizza(toppings: Set<Toppings>) { if toppings.contains(.Cheese) { print("Possible dairy allergies?") } let meats: Set<Toppings> = [.Beef, .Chicken, .Salami] if toppings.isDisjointWith(meats) { print("Vego-safe!") } if toppings.intersect(meats).count > 1 { print("Limit one meat, or 50¬¢ extra charge!") } if toppings == [Toppings.Cheese] { print("A bit boring?") } } checkPizza([.Tomato, .Cheese, .Chicken, .Beef]) checkPizza([.Cheese])
enum Options : UInt { case firstOption case secondOption case thirdOption } struct MyOptions : OptionSet { let rawValue: UInt static let firstOption = MyOptions(rawValue: 1 << Options.firstOption.rawValue) static let secondOption = MyOptions(rawValue: 1 << Options.secondOption.rawValue) static let thirdOption = MyOptions(rawValue: 1 << Options.thirdOption.rawValue) }
enum MyEnum: Int { case one case two case four case eight var value: UInt8 { return UInt8(1 << self.rawValue) } } let flags: UInt8 = MyEnum.one.value ^ MyEnum.eight.value (flags & MyEnum.eight.value) > 0 (flags & MyEnum.four.value) > 0 (flags & MyEnum.two.value) > 0 (flags & MyEnum.one.value) > 0 MyEnum.eight.rawValue MyEnum.four.rawValue
enum MyEnum: Int { case one case two case four case eight var value: UInt8 { return UInt8(1 << self.rawValue) } var string: String { switch self { case .one: return "one" case .two: return "two" case .four: return "four" case .eight: return "eight" } } }
let options:NSURL.BookmarkCreationOptions = [.withSecurityScope,.securityScopeAllowOnlyReadAccess] let temp = try link.bookmarkData(options: options, includingResourceValuesForKeys: nil, relativeTo: nil)
struct MyOptions : OptionSetType { let rawValue: Int static let None = Element(rawValue: 0) static let FirstOption = Element(rawValue: 1 << 0) static let SecondOption = Element(rawValue: 1 << 1) static let ThirdOption = Element(rawValue: 1 << 2) }
struct ShippingOptions: OptionSet { let rawValue: Int static let nextDay = ShippingOptions(rawValue: 1 << 0) static let secondDay = ShippingOptions(rawValue: 1 << 1) static let priority = ShippingOptions(rawValue: 1 << 2) static let standard = ShippingOptions(rawValue: 1 << 3) static let express: ShippingOptions = [.nextDay, .secondDay] static let all: ShippingOptions = [.express, .priority, .standard] }
let writePath = NSTemporaryDirectory().stringByAppendingPathComponent("instagram.igo")
let writePath = NSURL(fileURLWithPath: NSTemporaryDirectory()).URLByAppendingPathComponent("instagram.igo")
let writePath = NSURL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("instagram.igo")
extension String { func stringByAppendingPathComponent(path: String) -> String { let nsSt = self as NSString return nsSt.stringByAppendingPathComponent(path) } }
let writePath = NSTemporaryDirectory().stringByAppendingPathComponent("instagram.igo")
extension String { var lastPathComponent: String { return (self as NSString).lastPathComponent } var pathExtension: String { return (self as NSString).pathExtension } var stringByDeletingLastPathComponent: String { return (self as NSString).stringByDeletingLastPathComponent } var stringByDeletingPathExtension: String { return (self as NSString).stringByDeletingPathExtension } var pathComponents: [String] { return (self as NSString).pathComponents } func stringByAppendingPathComponent(path: String) -> String { let nsSt = self as NSString return nsSt.stringByAppendingPathComponent(path) } func stringByAppendingPathExtension(ext: String) -> String? { let nsSt = self as NSString return nsSt.stringByAppendingPathExtension(ext) } }
extension String { func stringByAppendingPathComponent1(path: String) -> String { let nsSt = self as NSString return nsSt.appendingPathComponent(path) } } let writePath = NSTemporaryDirectory().stringByAppendingPathComponent(path: "instagram.igo") extension String { var lastPathComponent: String { return (self as NSString).lastPathComponent } var pathExtension: String { return (self as NSString).pathExtension } var stringByDeletingLastPathComponent: String { return (self as NSString).deletingLastPathComponent } var stringByDeletingPathExtension: String { return (self as NSString).deletingPathExtension } var pathComponents: [String] { return (self as NSString).pathComponents } func stringByAppendingPathComponent(path: String) -> String { let nsSt = self as NSString return nsSt.appendingPathComponent(path) } func stringByAppendingPathExtension(ext: String) -> String? { let nsSt = self as NSString return nsSt.appendingPathExtension(ext) } }
let writePath = (NSTemporaryDirectory() as NSString).stringByAppendingPathComponent("instagram.igo")
let writePath = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(directoryname).path
extension String { func appendingPathComponent(_ string: String) -> String { return URL(fileURLWithPath: self).appendingPathComponent(string).path } }
let writePath = NSTemporaryDirectory().appendingPathComponent(directoryname)
func getDocumentsDirectory() -> URL { let paths = FileManager.default.urls(for: .documentDirectory, in:.userDomainMask) let documentsDirectory = paths[0] return documentsDirectory }
getDocumentsDirectory.appendingPathComponent("google.com")
func documentsDirectory() -> String { let documentsFolderPath = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.UserDomainMask, true)[0] return documentsFolderPath } func fileInDocumentsDirectory(filename: String) -> String { let writePath = (documentsDirectory() as NSString).stringByAppendingPathComponent("Mobile") if (!NSFileManager.defaultManager().fileExistsAtPath(writePath)) { do { try NSFileManager.defaultManager().createDirectoryAtPath(writePath, withIntermediateDirectories: false, attributes: nil) } catch let error as NSError { print(error.localizedDescription); } } return (writePath as NSString).stringByAppendingPathComponent(filename) } func saveImage (image: UIImage, path: String ) -> Bool{ let pngImageData = UIImagePNGRepresentation(image) let result = pngImageData!.writeToFile(path, atomically: true) print("\(result)") print("\(path)") return result }
let uniqueFileName = NSUUID().UUIDString let documentsDirectory = getDocumentsDirectoryURL() if let path = documentsDirectory?.URLByAppendingPathComponent(uniqueFileName) { var pathString = path.absoluteString pathString = imagePathString.stringByTrimmingCharactersInSet(NSCharacterSet(charactersInString: "file: } func getDocumentsDirectoryURL() -> NSURL? { let fileManager = NSFileManager() if let docsDirectory = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask).first { return docsDirectory } return nil }
(("\(fileName)" as NSString).lastPathComponent as NSString).stringByDeletingPathExtension
extension String { var lastPathComponent: String { return (self as NSString).lastPathComponent } var pathExtension: String { return (self as NSString).pathExtension } var stringByDeletingLastPathComponent: String { return (self as NSString).deletingLastPathComponent } var stringByDeletingPathExtension: String { return (self as NSString).deletingPathExtension } var pathComponents: [String] { return (self as NSString).pathComponents } func stringByAppendingPathComponent(path: String) -> String { let nsSt = self as NSString return nsSt.appendingPathComponent(path) } func stringByAppendingPathExtension(ext: String) -> String? { let nsSt = self as NSString return nsSt.appendingPathExtension(ext) } }
guard let url = URL(string: "http: return } if UIApplication.shared.open(url, options: [:], completionHandler: nil) } else { UIApplication.shared.openURL(url) }
let url = URL(string: "http: if UIApplication.shared.canOpenURL(url) { UIApplication.shared.open(url, options: [:], completionHandler: nil) UIApplication.shared.open(url, options: [:], completionHandler: { (success) in print("Open url : \(success)") }) }
import UIKit import SafariServices let url = URL(string: "https: let vc = SFSafariViewController(url: url!) present(vc, animated: true, completion: nil)
import UIKit protocol PhoneCalling { func call(phoneNumber: String) } extension PhoneCalling { func call(phoneNumber: String) { let cleanNumber = phoneNumber.replacingOccurrences(of: " ", with: "").replacingOccurrences(of: "-", with: "") guard let number = URL(string: "telprompt: UIApplication.shared.open(number, options: [:], completionHandler: nil) } }
// // // import UIKit import WebKit class ViewController: UIViewController { @IBOutlet weak var webView: UIWebView! override func viewDidLoad() { super.viewDidLoad() let url = URL(string: "https: if UIApplication.shared.canOpenURL(url!) { UIApplication.shared.open(url!, options: [:], completionHandler: nil) UIApplication.shared.open(url!, options: [:], completionHandler: { (success) in print("Open url : \(success)") }) } } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } };
var datesArray = [String: AnyObject]() for key in locationsArray { let ref = Firebase(url: "http: ref.observeSingleEventOfType(.Value, withBlock: { snapshot in datesArray["\(key.0)"] = snapshot.value }) }
override func viewDidLoad() { super.viewDidLoad() let myGroup = DispatchGroup() for i in 0 ..< 5 { myGroup.enter() Alamofire.request("https: print("Finished request \(i)") myGroup.leave() } } myGroup.notify(queue: .main) { print("Finished all requests.") } }
Finished request 1 Finished request 0 Finished request 2 Finished request 3 Finished request 4 Finished all requests.
override func viewDidLoad() { super.viewDidLoad() let myGroup = dispatch_group_create() for i in 0 ..< 5 { dispatch_group_enter(myGroup) Alamofire.request(.GET, "https: print("Finished request \(i)") dispatch_group_leave(self.myGroup) } } dispatch_group_notify(myGroup, dispatch_get_main_queue(), { print("Finished all requests.") }) }
let myGroup = DispatchGroup() override func viewDidLoad() { super.viewDidLoad() for i in 0 ..< 5 { myGroup.enter() Alamofire.request(.GET, "https: print("Finished request \(i)") myGroup.leave() } } myGroup.notify(queue: DispatchQueue.main, execute: { print("Finished all requests.") }) }
let dispatchGroup = DispatchGroup() let dispatchQueue = DispatchQueue(label: "any-label-name") let dispatchSemaphore = DispatchSemaphore(value: 0) dispatchQueue.async { for c in self.categories { if let id = c.categoryId { dispatchGroup.enter() self.downloadProductsByCategory(categoryId: id) { success, data in if success, let products = data { self.products.append(products) } dispatchSemaphore.signal() dispatchGroup.leave() } dispatchSemaphore.wait() } } } dispatchGroup.notify(queue: dispatchQueue) { DispatchQueue.main.async { self.refreshOrderTable { _ in self.productCollectionView.reloadData() } } }
class AsyncOperation { typealias NumberOfPendingActions = Int typealias DispatchQueueOfReturningValue = DispatchQueue typealias CompleteClosure = ()->() private let dispatchQueue: DispatchQueue private var semaphore: DispatchSemaphore private var numberOfPendingActionsQueue: DispatchQueue public private(set) var numberOfPendingActions = 0 var whenCompleteAll: (()->())? init(numberOfSimultaneousActions: Int, dispatchQueueLabel: String) { dispatchQueue = DispatchQueue(label: dispatchQueueLabel) semaphore = DispatchSemaphore(value: numberOfSimultaneousActions) numberOfPendingActionsQueue = DispatchQueue(label: dispatchQueueLabel + "_numberOfPendingActionsQueue") } func run(closure: @escaping (@escaping CompleteClosure)->()) { self.numberOfPendingActionsQueue.sync { self.numberOfPendingActions += 1 } dispatchQueue.async { self.semaphore.wait() closure { self.numberOfPendingActionsQueue.sync { self.numberOfPendingActions -= 1 if self.numberOfPendingActions == 0 { self.whenCompleteAll?() } } self.semaphore.signal() } } } }
let asyncOperation = AsyncOperation(numberOfSimultaneousActions: 1, dispatchQueueLabel: "AnyString") asyncOperation.whenCompleteAll = { print("All Done") } for i in 0...5 { print("\(i)") asyncOperation.run{ completeClosure in completeClosure() } }
import UIKit class ViewController: UIViewController { let asyncOperation = AsyncOperation(numberOfSimultaneousActions: 3, dispatchQueueLabel: "AnyString") let button = UIButton(frame: CGRect(x: 50, y: 80, width: 100, height: 40)) let label = UILabel(frame: CGRect(x: 180, y: 50, width: 150, height: 100)) var counter = 1 var labelCounter = 0 override func viewDidLoad() { super.viewDidLoad() button.setTitle("Button", for: .normal) button.setTitleColor(.blue, for: .normal) button.addTarget(self, action: label.text = "\(labelCounter)" label.numberOfLines = 2 label.textAlignment = .natural view.addSubview(button) view.addSubview(label) } @objc func buttonTapped() { sample2() } func sample1() { print("Sample 1") labelCounter += 1 label.text = "button tapped \(labelCounter) times" print("Button tapped at: \(Date())") asyncOperation.whenCompleteAll = { print("All Done") } asyncOperation.run{ completeClosure in let counter = self.counter print(" - Loading action \(counter) strat at \(Date())") self.counter += 1 DispatchQueue.global(qos: .background).async { sleep(1) print(" - Loading action \(counter) end at \(Date())") completeClosure() } } } func sample2() { print("Sample 2") label.text = "" asyncOperation.whenCompleteAll = { print("All Done") } for i in 0...5 { asyncOperation.run{ completeClosure in let counter = self.counter print(" - Loading action \(counter) strat at \(Date())") self.counter += 1 DispatchQueue.global(qos: .background).async { sleep(UInt32(i+i)) print(" - Loading action \(counter) end at \(Date())") completeClosure() } } } } }
let semaphore = dispatch_semaphore_create(locationsArray.count) for key in locationsArray { let ref = Firebase(url: "http: ref.observeSingleEventOfType(.Value, withBlock: { snapshot in datesArray["\(key.0)"] = snapshot.value dispatch_semaphore_signal(semaphore) }) } let timeoutLengthInNanoSeconds: Int64 = 10000000000 let timeout = dispatch_time(DISPATCH_TIME_NOW, timeoutLengthInNanoSeconds) dispatch_semaphore_wait(semaphore, timeout)
let persons = persistentContainer.viewContext.persons print("How many persons on database: \(persons.count())") let numberOfPersons = persons.count() for eachPerson in persons{ queuePersonDetail.async { self.getPersonDetailAndSave(personId: eachPerson.personId){person2, error in print("Person detail: \(person2?.fullName)") semaphorePersonDetailAndSave.signal() } } } for i in 0..<numberOfPersons{ semaphorePersonDetailAndSave.wait() NSLog("\(i + 1)/\(persons.count()) completed") }
Finished request 1 Finished request 0 Finished request 2
public class RequestItem: NSObject { public var urlToCall: String = "" public var method: HTTPMethod = .get public var params: [String: String] = [:] public var headers: [String: String] = [:] } public func trySendRequestsNotSent (trySendRequestsNotSentCompletionHandler: @escaping ([Error]) -> () = { _ in }) { if !requestItemsToSend.isEmpty { let requestItemsToSendCopy = requestItemsToSend NSLog("Send list started") launchRequestsInOrder(requestItemsToSendCopy, 0, [], launchRequestsInOrderCompletionBlock: { index, errors in trySendRequestsNotSentCompletionHandler(errors) }) } else { trySendRequestsNotSentCompletionHandler([]) } } private func launchRequestsInOrder (_ requestItemsToSend: [RequestItem], _ index: Int, _ errors: [Error], launchRequestsInOrderCompletionBlock: @escaping (_ index: Int, _ errors: [Error] ) -> Void) { executeRequest(requestItemsToSend, index, errors, executeRequestCompletionBlock: { currentIndex, errors in if currentIndex < requestItemsToSend.count { self.launchRequestsInOrder(requestItemsToSend, currentIndex, errors, launchRequestsInOrderCompletionBlock: { index, errors in launchRequestsInOrderCompletionBlock(currentIndex, errors) }) } else { NSLog("Send list finished") launchRequestsInOrderCompletionBlock(currentIndex, errors) } }) } private func executeRequest (_ requestItemsToSend: [RequestItem], _ index: Int, _ errors: [Error], executeRequestCompletionBlock: @escaping (_ index: Int, _ errors: [Error]) -> Void) { NSLog("Send request %d", index) Alamofire.request(requestItemsToSend[index].urlToCall, method: requestItemsToSend[index].method, parameters: requestItemsToSend[index].params, headers: requestItemsToSend[index].headers).responseJSON { response in var errors: [Error] = errors switch response.result { case .success: self.requestItemsToSend.remove(at: index) break case .failure: errors.append(response.result.error!) break } NSLog("Receive request %d", index) executeRequestCompletionBlock(index+1, errors) } }
Send list started Send request 0 Receive request 0 Send request 1 Receive request 1 Send request 2 Receive request 2 ... Send list finished
var stringNumb: NSString = "1357" var someNumb: CInt = stringNumb.intValue
var stringNumb: String = "1357" var someNumb: Int = Int(stringNumb)
var stringNumber = "1234" var numberFromString = Int(stringNumber)
var stringNumber = "1234" var numberFromString = stringNumber.toInt() println(numberFromString)
let stringNumb:NSString = "1357" let someNumb = Int(stringNumb as String)
let stringNumb = "1357" let someNumb = Int(stringNumb)
let stringNumb = "13.57" if let stringToFloat = Float(stringNumb){ let someNumb = Int(stringToFloat) }else{ }
let stringNumber = "1234" let numberFromString = stringNumber.toInt() let notANumber = "Uh oh" let wontBeANumber = notANumber.toInt()
var x = "400.0" as NSString x.floatValue x.doubleValue x.boolValue x.integerValue x.intValue
let myString = "700.00" let myInt = (myString as NSString).integerValue
let formatter = NSNumberFormatter() formatter.numberStyle = .CurrencyStyle formatter.maximumFractionDigits = 0 let priceValue = formatter.stringFromNumber(myInt!)!
var myint: Int = Int(stringNumb.bridgeToObjectiveC().intValue)
extension String { func toTypeSafeInt() -> Int { if let safeInt = self.toInt() { return safeInt } else { return 0 } } }
extension String { var toFloat:Float { return Float(self.bridgeToObjectiveC().floatValue) } var toDouble:Double { .... } .... }
var str:NSString = Data as! NSString var cont:Int = str.integerValue
var stringNumb: String = "1357" var someNumb = Int(stringNumb)
var stringNumb: String = "1357" var someNumb:Int? = Int(stringNumb)
if let intValue = "42".toInt() { let number1 = NSNumber(integer:intValue) } let number2 = Int(stringNumber) let number3 = NSNumber(float:("42.42" as NSString).floatValue)
extension String { var numberValue:NSNumber? { let formatter = NSNumberFormatter() formatter.numberStyle = .DecimalStyle return formatter.numberFromString(self) } }
let someFloat = "42.42".numberValue let someInt = "42".numberValue
private func setupView() { greenView.translatesAutoresizingMaskIntoConstraints = false greenView.backgroundColor = .green view.addSubview(greenView) }
let margins = view.layoutMarginsGuide NSLayoutConstraint.activate([ greenView.leadingAnchor.constraint(equalTo: margins.leadingAnchor), greenView.trailingAnchor.constraint(equalTo: margins.trailingAnchor) ])
if let guide = view.safeAreaLayoutGuide NSLayoutConstraint.activate([ greenView.topAnchor.constraintEqualToSystemSpacingBelow(guide.topAnchor, multiplier: 1.0), guide.bottomAnchor.constraintEqualToSystemSpacingBelow(greenView.bottomAnchor, multiplier: 1.0) ]) } else { let standardSpacing: CGFloat = 8.0 NSLayoutConstraint.activate([ greenView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor, constant: standardSpacing), bottomLayoutGuide.topAnchor.constraint(equalTo: greenView.bottomAnchor, constant: standardSpacing) ]) }
extension UIView { var safeAreaTopAnchor: NSLayoutYAxisAnchor { if return self.safeAreaLayoutGuide.topAnchor } else { return self.topAnchor } } var safeAreaBottomAnchor: NSLayoutYAxisAnchor { if return self.safeAreaLayoutGuide.bottomAnchor } else { return self.bottomAnchor } } var safeAreaLeftAnchor: NSLayoutXAxisAnchor { if return self.safeAreaLayoutGuide.leftAnchor } else { return self.leftAnchor } } var safeAreaRightAnchor: NSLayoutXAxisAnchor { if return self.safeAreaLayoutGuide.rightAnchor } else { return self.rightAnchor } } }
self.demoView.translatesAutoresizingMaskIntoConstraints = NO; UILayoutGuide * guide = self.view.safeAreaLayoutGuide; [self.demoView.leadingAnchor constraintEqualToAnchor:guide.leadingAnchor].active = YES; [self.demoView.trailingAnchor constraintEqualToAnchor:guide.trailingAnchor].active = YES; [self.demoView.topAnchor constraintEqualToAnchor:guide.topAnchor].active = YES; [self.demoView.bottomAnchor constraintEqualToAnchor:guide.bottomAnchor].active = YES;
demoView.translatesAutoresizingMaskIntoConstraints = false if let guide = self.view.safeAreaLayoutGuide demoView.trailingAnchor.constraint(equalTo: guide.trailingAnchor).isActive = true demoView.leadingAnchor.constraint(equalTo: guide.leadingAnchor).isActive = true demoView.bottomAnchor.constraint(equalTo: guide.bottomAnchor).isActive = true demoView.topAnchor.constraint(equalTo: guide.topAnchor).isActive = true } else { NSLayoutConstraint(item: demoView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leading, multiplier: 1.0, constant: 0).isActive = true NSLayoutConstraint(item: demoView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailing, multiplier: 1.0, constant: 0).isActive = true NSLayoutConstraint(item: demoView, attribute: .bottom, relatedBy: .equal, toItem: view, attribute: .bottom, multiplier: 1.0, constant: 0).isActive = true NSLayoutConstraint(item: demoView, attribute: .top, relatedBy: .equal, toItem: view, attribute: .top, multiplier: 1.0, constant: 0).isActive = true }
typedef enum : int { MyTimeFilter1Hour = 1, MyTimeFilter1Day = 2, MyTimeFilter7Day = 3, MyTimeFilter1Month = 4, } MyTimeFilter; ... - (void)selectFilter:(id)sender { self.timeFilterSelected = (MyTimeFilter)((UIButton *)sender).tag; [self closeAnimated:YES]; }
enum MyTimeFilter : Int { case OneHour = 1 case OneDay = 2 case SevenDays = 3 case OneMonth = 4 } ... @IBAction func selectFilter(sender: AnyObject) { self.timeFilterSelected = (sender as UIButton).tag as MyTimeFilter self.close(true) }
self.timeFilterSelected = MyTimeFilter(rawValue: (sender as UIButton).tag)!
enum LoanType: Int { case FHA , VA, CONS, CASH } var loanType = LoanType.FHA
protocol SomeProtocol: Equatable { func bla() } class SomeClass { var protocols = [SomeProtocol]() func addElement(element: SomeProtocol) { self.protocols.append(element) } func removeElement(element: SomeProtocol) { if let index = find(self.protocols, element) { self.protocols.removeAtIndex(index) } } }
class SomeClass<T: SomeProtocol> { typealias ElementType = T var protocols = [ElementType]() func addElement(element: ElementType) { self.protocols.append(element) } func removeElement(element: ElementType) { if let index = find(self.protocols, element) { self.protocols.removeAtIndex(index) } } }
protocol X: Equatable { var x: Int { get } } func ==<T: X>(a: T, b: T) -> Bool { return a.x == b.x } struct AnyX { private let _x: () -> Int var x: Int { return _x() } init<T: X>(_ some: T) { _x = { some.x } } } struct XY: X { var x: Int var y: Int } struct XZ: X { var x: Int var z: Int } let xy = XY(x: 1, y: 2) let xz = XZ(x: 3, z: 4) let xs = [AnyX(xy), AnyX(xz)] xs.forEach { print($0.x) }
protocol SomeProtocol: class { func bla() } class SomeClass { var protocols = [SomeProtocol]() func addElement(element: SomeProtocol) { self.protocols.append(element) } func removeElement(element: SomeProtocol) { for i in 0...protocols.count { if protocols[i] === element { protocols.removeAtIndex(i) return } } } }
protocol SomeProtocol { func bla() } class SomeClass { init() {} var protocols = [SomeProtocol]() func addElement<T: SomeProtocol where T: Equatable>(element: T) { protocols.append(element) } func removeElement<T: SomeProtocol where T: Equatable>(element: T) { protocols = protocols.filter { if let e = $0 as? T where e == element { return false } return true } } }
protocol SomeProtocol { var name:String? {get set} func bla() } class SomeClass { /* static func compareProtocols(one:SomeProtocol, toTheOther:SomeProtocol)->Bool { if (one.name == nil) {return false} if(toTheOther.name == nil) {return false} if(one.name == toTheOther.name!) {return true} return false } */ var protocols = [String:SomeProtocol]() func addElement(element: SomeProtocol) -> Bool { if let index = element.name { protocols[index] = element return true } return false } func removeElement(element: SomeProtocol) { if let index = element.name { protocols.removeValueForKey(index) } } func getElements() -> [SomeProtocol] { return Array(protocols.values) } }
protocol SomeProtocol: NSObjectProtocol { } func find(protocols: [SomeProtocol], element: SomeProtocol) -> Int? { for (index, object) in protocols.enumerated() { if (object.isEqual(element)) { return index } } return nil }
func addBottomSheetView() { let bottomSheetVC = BottomSheetViewController() self.addChildViewController(bottomSheetVC) self.view.addSubview(bottomSheetVC.view) bottomSheetVC.didMoveToParentViewController(self) let height = view.frame.height let width = view.frame.width bottomSheetVC.view.frame = CGRectMake(0, self.view.frame.maxY, width, height) }
override func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) addBottomSheetView() }
func prepareBackgroundView(){ let blurEffect = UIBlurEffect.init(style: .Dark) let visualEffect = UIVisualEffectView.init(effect: blurEffect) let bluredView = UIVisualEffectView.init(effect: blurEffect) bluredView.contentView.addSubview(visualEffect) visualEffect.frame = UIScreen.mainScreen().bounds bluredView.frame = UIScreen.mainScreen().bounds view.insertSubview(bluredView, atIndex: 0) }
override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) prepareBackgroundView() }
override func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) UIView.animateWithDuration(0.3) { [weak self] in let frame = self?.view.frame let yComponent = UIScreen.mainScreen().bounds.height - 200 self?.view.frame = CGRectMake(0, yComponent, frame!.width, frame!.height) } }
override func viewDidLoad() { super.viewDidLoad() let gesture = UIPanGestureRecognizer.init(target: self, action: view.addGestureRecognizer(gesture) }
func panGesture(recognizer: UIPanGestureRecognizer) { let translation = recognizer.translationInView(self.view) let y = self.view.frame.minY self.view.frame = CGRectMake(0, y + translation.y, view.frame.width, view.frame.height) recognizer.setTranslation(CGPointZero, inView: self.view) }
func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool { let gesture = (gestureRecognizer as! UIPanGestureRecognizer) let direction = gesture.velocity(in: view).y let y = view.frame.minY if (y == fullView && tableView.contentOffset.y == 0 && direction > 0) || (y == partialView) { tableView.isScrollEnabled = false } else { tableView.isScrollEnabled = true } return false }
class BackgroundViewController: UIViewController { override func loadView() { view = MKMapView() } }
class OverlayViewController: UIViewController, UITableViewDataSource, UITableViewDelegate { lazy var tableView = UITableView() override func loadView() { view = tableView tableView.dataSource = self tableView.delegate = self } [...] }
enum OverlayPosition { case maximum, minimum } class OverlayContainerViewController: UIViewController { let overlayViewController: OverlayViewController var translatedViewHeightContraint = ... override func loadView() { view = UIView() } func moveOverlay(to position: OverlayPosition) { [...] } }
class StackViewController: UIViewController { private var viewControllers: [UIViewController] override func viewDidLoad() { super.viewDidLoad() viewControllers.forEach { gz_addChild($0, in: view) } } }
let overlay = OverlayViewController() let containerViewController = OverlayContainerViewController(overlayViewController: overlay) let backgroundViewController = BackgroundViewController() window?.rootViewController = StackViewController(viewControllers: [backgroundViewController, containerViewController])
func panGestureAction(_ recognizer: UIPanGestureRecognizer) { if isTranslating { tableView.contentOffset = .zero } }
protocol OverlayViewControllerDelegate: class { func scrollViewDidScroll(_ scrollView: UIScrollView) func scrollViewDidStopScrolling(_ scrollView: UIScrollView) } class OverlayViewController: UIViewController { [...] func scrollViewDidScroll(_ scrollView: UIScrollView) { delegate?.scrollViewDidScroll(scrollView) } func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) { delegate?.scrollViewDidStopScrolling(scrollView) } }
enum OverlayInFlightPosition { case minimum case maximum case progressing }
private var overlayInFlightPosition: OverlayInFlightPosition { let height = translatedViewHeightContraint.constant if height == maximumHeight { return .maximum } else if height == minimumHeight { return .minimum } else { return .progressing } }
private func shouldTranslateView(following scrollView: UIScrollView) -> Bool { guard scrollView.isTracking else { return false } let offset = scrollView.contentOffset.y switch overlayInFlightPosition { case .maximum: return offset < 0 case .minimum: return offset > 0 case .progressing: return true } }
private func translateView(following scrollView: UIScrollView) { scrollView.contentOffset = .zero let translation = translatedViewTargetHeight - scrollView.panGestureRecognizer.translation(in: view).y translatedViewHeightContraint.constant = max( Constant.minimumHeight, min(translation, Constant.maximumHeight) ) }
private func animateTranslationEnd() { let position: OverlayPosition = moveOverlay(to: position) }
class OverlayContainerViewController: UIViewController { func scrollViewDidScroll(_ scrollView: UIScrollView) { guard shouldTranslateView(following: scrollView) else { return } translateView(following: scrollView) } func scrollViewDidStopScrolling(_ scrollView: UIScrollView) { scrollView.isEnabled = false scrollView.isEnabled = true animateTranslationEnd() } }
class PassThroughView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? { let view = super.hitTest(point, with: event) if view == self { return nil } return view } }
override func loadView() { view = PassThroughView() }
func scrollView(_ scrollView: UIScrollView, willEndScrollingWithVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) { switch overlayInFlightPosition { case .maximum: break case .minimum, .progressing: targetContentOffset.pointee = .zero } animateTranslationEnd(following: scrollView) }
func moveOverlay(to position: OverlayPosition, duration: TimeInterval, velocity: CGPoint) { overlayPosition = position translatedViewHeightContraint.constant = translatedViewTargetHeight UIView.animate( withDuration: duration, delay: 0, usingSpringWithDamping: velocity.y == 0 ? 1 : 0.6, initialSpringVelocity: abs(velocity.y), options: [.allowUserInteraction], animations: { self.view.layoutIfNeeded() }, completion: nil) }
import UIKit import FloatingPanel class ViewController: UIViewController { var fpc: FloatingPanelController! override func viewDidLoad() { super.viewDidLoad() fpc = FloatingPanelController() fpc.add(toParent: self) let contentVC = ContentViewController() fpc.set(contentViewController: contentVC) fpc.track(scrollView: contentVC.tableView) } ... }
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { if (indexPath.section == 0 && indexPath.row == 2) { if (editingStartTime) { return 219; } else { return 0; } } else { return self.tableView.rowHeight; } }
-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { if (indexPath.section == 0 && indexPath.row == 1) { editingStartTime = !editingStartTime; [UIView animateWithDuration:.4 animations:^{ [self.tableView reloadRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:2 inSection:0]] withRowAnimation:UITableViewRowAnimationFade]; [self.tableView reloadData]; }]; } }
@interface StaticTableViewController: UITableViewController @property (weak, nonatomic) IBOutlet UITableViewCell *dateTitleCell; @property (nonatomic, assign, getter = isDateOpen) BOOL dateOpen; @end @implementation StaticTableViewController -(CGFloat) tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{ if (indexPath.section == 1 && indexPath.row == 1 && !self.isDateOpen){ return 0; } return [super tableView:tableView heightForRowAtIndexPath:indexPath]; } -(void) tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{ UITableViewCell* cell = [tableView cellForRowAtIndexPath:indexPath]; [tableView beginUpdates]; if (cell == self.dateTitleCell){ self.dateOpen = !self.isDateOpen; } [tableView reloadData]; [self.tableView endUpdates]; }
public override float GetHeightForRow (UITableView tableView, NSIndexPath indexPath) { if (indexPath.Row == 4) { return (datePickerIsShowing) ? 206f : 0.0f; } return base.GetHeightForRow(tableView,indexPath); }
private void showDatePickerCell(){ datePickerIsShowing = true; this.TableView.BeginUpdates (); this.TableView.EndUpdates (); this.datePicker.Hidden = false; this.datePicker.Alpha = 0.0f; UIView.Animate (0.25, animation: () => { this.datePicker.Alpha = 1.0f; } ); }
private void hideDatePickerCell(){ datePickerIsShowing = false; this.TableView.BeginUpdates (); this.TableView.EndUpdates (); UIView.Animate (0.25, animation: () => { this.datePicker.Alpha = 0.0f; }, completion: () => { this.datePicker.Hidden = true; } ); }
public override void RowSelected (UITableView tableView, NSIndexPath indexPath) { if (indexPath.Row == 3) { if (datePickerIsShowing) { hideDatePickerCell (); } else { showDatePickerCell (); } } this.TableView.DeselectRow (indexPath, true); }
NSArray *itemsArray = [self.dataArray objectAtIndex:indexPath.section]; NSDictionary *itemData = nil; if(![indexPath isEqual:self.datePickerIndexPath]) itemData = [itemsArray objectAtIndex:modelRow];
if (indexPath.section == 1 && indexPath.row == 0) { editingStartTime = !editingStartTime; [UIView animateWithDuration:.4 animations:^{ int height = 0; if (editingStartTime) { height = 162; } UITableViewCell* temp = [tableView cellForRowAtIndexPath:[NSIndexPath indexPathForRow:1 inSection:1]]; [temp setFrame:CGRectMake(temp.frame.origin.x, temp.frame.origin.y, temp.frame.size.width, height)]; for (int x = 2; x < [tableView numberOfSections]; x++) { for (int y = 0; y < [tableView numberOfRowsInSection:x]; y++) { UITableViewCell* temp = [tableView cellForRowAtIndexPath:[NSIndexPath indexPathForRow:y inSection:x]]; int y_coord = temp.frame.origin.y-162; if (editingStartTime) { y_coord = temp.frame.origin.y+162; } [temp setFrame:CGRectMake(temp.frame.origin.x, y_coord, temp.frame.size.width, temp.frame.size.height)]; } } }completion:^(BOOL finished){ [self.tableView reloadData]; }]; }
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { if (indexPath.section == 0 && indexPath.row == 1) { if (self.isPickerOpened) { return 162; } else { return 0; } } else { return [super tableView:tableView heightForRowAtIndexPath:indexPath]; } } - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { if (indexPath.section == 0 && indexPath.row == 0) { [tableView beginUpdates]; self.isPickerOpened = ! self.isPickerOpened; [super tableView:tableView heightForRowAtIndexPath:indexPath]; [self.tableView endUpdates]; } }
[super tableView:tableView heightForRowAtIndexPath:indexPath];
- (void)initialiseDatePickers { self.isEditingStartTime = NO; self.startTimePickerCell.clipsToBounds = YES; UIDatePicker *startTimePicker = [[UIDatePicker alloc] init]; [startTimePicker addTarget:self action:@selector(startTimePickerChanged:) forControlEvents:UIControlEventValueChanged]; [self.startTimePickerCell addSubview:startTimePicker]; }
- (IBAction)startTimePickerChanged:(id)sender { NSLog(@"start time picker changed"); }
-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { if (indexPath.section == 0 && indexPath.row == 1) { editingStartTime = !editingStartTime; } }
import UIKit class TableViewController: UITableViewController { var editingCell: Bool = false @IBOutlet weak var myCell: UITableViewCell! override func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { if (indexPath.section == 0 && indexPath.row == 2 && !editingCell) { return 0 } else { return self.tableView.rowHeight } } override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { self.tableView.deselectRowAtIndexPath(indexPath, animated: false); var cell = tableView.cellForRowAtIndexPath(indexPath) self.tableView.beginUpdates() if (cell == self.myCell) { editingType = !editingType; } self.tableView.endUpdates() } }
// // // @class CPTableViewCell; @protocol CPTableViewCellDelegate <NSObject> @required - (void)tableViewCellDidChangeValue:(CPTableViewCell *)cell; @optional - (void)tableViewCellDidBecomeFirstResponder:(CPTableViewCell *)cell; - (void)tableViewCellResignedFirstResponder:(CPTableViewCell *)cell; @end @interface CPTableViewCell : UITableViewCell @property (nonatomic, weak) IBOutlet UITableView *tableView; @property (nonatomic, weak) IBOutlet CPTableViewCell *nextCell; @property (nonatomic, weak) IBOutlet id<CPTableViewCellDelegate> delegate; @property (nonatomic, copy) IBInspectable NSString *dataBindKey; @property (nonatomic) IBInspectable CGFloat height; @property (nonatomic, readonly) BOOL isFirstResponder; @property (nonatomic) BOOL isEnabled; - (void)commonInit; - (id)value; - (void)setValue:(id)value; @end // // // @interface CPTableViewCell () @end @implementation CPTableViewCell - (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (!self) return nil; [self commonInit]; return self; } - (instancetype)initWithCoder:(NSCoder *)aDecoder { self = [super initWithCoder:aDecoder]; if (!self) return nil; [self commonInit]; return self; } - (void)commonInit { _isFirstResponder = NO; _isEnabled = YES; } - (BOOL)canBecomeFirstResponder { return _isEnabled; } - (BOOL)becomeFirstResponder { if ([_delegate respondsToSelector:@selector(tableViewCellDidBecomeFirstResponder:)]) [_delegate tableViewCellDidBecomeFirstResponder:self]; return _isFirstResponder = YES; } - (BOOL)resignFirstResponder { if (_isFirstResponder) { if ([_delegate respondsToSelector:@selector(tableViewCellResignedFirstResponder:)]) [_delegate tableViewCellResignedFirstResponder:self]; _isFirstResponder = NO; } return _isFirstResponder; } - (id)value { [self doesNotRecognizeSelector:_cmd]; return nil; } - (void)setValue:(id)value { [self doesNotRecognizeSelector:_cmd]; } @end
// // // @interface CPDatePickerTableViewCell : CPTableViewCell @property (nonatomic, copy) IBInspectable NSString *dateFormat; @property (nonatomic, weak) IBOutlet UILabel *titleLabel; @property (nonatomic, weak) IBOutlet UILabel *dateLabel; @property (nonatomic, weak) IBOutlet UIDatePicker *datePicker; @end // // // @interface CPDatePickerTableViewCell () <UITextFieldDelegate, UIPickerViewDelegate> { NSDateFormatter *_dateFormatter; BOOL _isOpen; } @end @implementation CPDatePickerTableViewCell - (void)awakeFromNib { [super awakeFromNib]; _dateFormatter = [NSDateFormatter new]; [_dateFormatter setDateFormat:_dateFormat]; self.selectionStyle = UITableViewCellSelectionStyleNone; _dateLabel.text = [_dateFormatter stringFromDate:_datePicker.date]; _datePicker.alpha = 0.f; _isOpen = NO; } - (BOOL)becomeFirstResponder { if (_isOpen == NO) { self.height += kCPDatePickerTableViewCellPickerHeight; } else { self.height -= kCPDatePickerTableViewCellPickerHeight; } [UIView animateWithDuration:kUIAnimationDuration animations:^{ _datePicker.alpha = _isOpen ? 0.0f : 1.0f; }]; [self.tableView beginUpdates]; [self.tableView endUpdates]; _isOpen = !_isOpen; [self.tableView endEditing:YES]; return [super becomeFirstResponder]; } - (BOOL)resignFirstResponder { if (_isOpen == YES) { self.height -= kCPDatePickerTableViewCellPickerHeight; [UIView animateWithDuration:kUIAnimationDuration animations:^{ _datePicker.alpha = 0.0f; }]; [self.tableView beginUpdates]; [self.tableView endUpdates]; _isOpen = NO; } return [super resignFirstResponder]; } - (id)value { return _datePicker.date; } - (void)setValue:(NSDate *)value { _datePicker.date = value; _dateLabel.text = [_dateFormatter stringFromDate:_datePicker.date]; } - (IBAction)datePickerValueChanged:(UIDatePicker *)sender { [_dateLabel setText:[_dateFormatter stringFromDate:_datePicker.date]]; [self.delegate tableViewCellDidChangeValue:self]; } @end
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { CPTableViewCell *cell = (CPTableViewCell *)[super tableView:tableView cellForRowAtIndexPath:indexPath]; return [cell height]; } - (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath { CPTableViewCell *cell = (CPTableViewCell *)[tableView cellForRowAtIndexPath:indexPath]; if ([cell canBecomeFirstResponder]) { [cell becomeFirstResponder]; } if (cell != _selectedCell) { [_selectedCell resignFirstResponder]; } _selectedCell = cell; return YES; }
// // // @interface CPTextFieldTableViewCell : CPTableViewCell @property (nonatomic, weak) IBOutlet UITextField *inputTextField; @end // // // @interface CPTextFieldTableViewCell () <UITextFieldDelegate> @end @implementation CPTextFieldTableViewCell - (void)awakeFromNib { [super awakeFromNib]; self.selectionStyle = UITableViewCellSelectionStyleNone; _inputTextField.userInteractionEnabled = NO; _inputTextField.delegate = self; } - (BOOL)becomeFirstResponder { _inputTextField.userInteractionEnabled = YES; [_inputTextField becomeFirstResponder]; return [super becomeFirstResponder]; } - (BOOL)resignFirstResponder { _inputTextField.userInteractionEnabled = NO; return [super resignFirstResponder]; } - (void)setIsEnabled:(BOOL)isEnabled { [super setIsEnabled:isEnabled]; _inputTextField.enabled = isEnabled; } - (id)value { return _inputTextField.text; } - (void)setValue:(NSString *)value { _inputTextField.text = value; } - (void)textFieldDidEndEditing:(UITextField *)textField { [self.delegate tableViewCellDidChangeValue:self]; } @end
// // // @interface CPTextViewTableViewCell : CPTableViewCell @property (nonatomic, weak) IBOutlet UITextView *inputTextView; @end // // // @interface CPTextViewTableViewCell () <UITextViewDelegate> { UITextView *_heightTextView; } @end @implementation CPTextViewTableViewCell @synthesize height = _height; - (void)awakeFromNib { [super awakeFromNib]; self.selectionStyle = UITableViewCellSelectionStyleNone; _inputTextView.userInteractionEnabled = NO; _inputTextView.delegate = self; _inputTextView.contentInset = UIEdgeInsetsZero; _inputTextView.scrollEnabled = NO; } - (CGFloat)height { if (!_heightTextView) { CGRect frame = (CGRect) { .origin = CGPointMake(0.f, 0.f), .size = CGSizeMake(_inputTextView.textInputView.frame.size.width, 0.f) }; _heightTextView = [[UITextView alloc] initWithFrame:frame]; _heightTextView.font = [UIFont systemFontOfSize:_inputTextView.font.pointSize]; _heightTextView.textColor = UIColor.whiteColor; _heightTextView.contentInset = UIEdgeInsetsZero; } _heightTextView.text = _inputTextView.text; CGSize size = [_heightTextView sizeThatFits:CGSizeMake(_inputTextView.textInputView.frame.size.width, FLT_MAX)]; return size.height > _height ? size.height + _inputTextView.font.pointSize : _height; } - (BOOL)becomeFirstResponder { _inputTextView.userInteractionEnabled = YES; [_inputTextView becomeFirstResponder]; return [super becomeFirstResponder]; } - (BOOL)resignFirstResponder { _inputTextView.userInteractionEnabled = NO; return [super resignFirstResponder]; } - (void)setIsEnabled:(BOOL)isEnabled { [super setIsEnabled:isEnabled]; _inputTextView.editable = isEnabled; } - (id)value { return _inputTextView.text; } - (void)setValue:(NSString *)value { _inputTextView.text = value; [_inputTextView setNeedsLayout]; [_inputTextView layoutIfNeeded]; } - (void)textViewDidChange:(UITextView *)textView { [self.delegate tableViewCellDidChangeValue:self]; [self.tableView beginUpdates]; [self.tableView endUpdates]; } @end
post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| if config.name == config.build_settings[ end end end end
var sysData:CMutablePointer<utsname> = nil let retVal:CInt = uname(sysData)
var systemVersion = NSProcessInfo.processInfo().operatingSystemVersion
if (self.respondsToSelector(Selector("showViewController"))) { self.showViewController(vc, sender: self) } else { }
let floatVersion = (UIDevice.current.systemVersion as NSString).floatValue
let iOS8 = floor(NSFoundationVersionNumber) > floor(NSFoundationVersionNumber_iOS_7_1) let iOS7 = floor(NSFoundationVersionNumber) <= floor(NSFoundationVersionNumber_iOS_7_1)
func SYSTEM_VERSION_EQUAL_TO(version: String) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version, options: NSStringCompareOptions.NumericSearch) == NSComparisonResult.OrderedSame } func SYSTEM_VERSION_GREATER_THAN(version: String) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version, options: NSStringCompareOptions.NumericSearch) == NSComparisonResult.OrderedDescending } func SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(version: String) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version, options: NSStringCompareOptions.NumericSearch) != NSComparisonResult.OrderedAscending } func SYSTEM_VERSION_LESS_THAN(version: String) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version, options: NSStringCompareOptions.NumericSearch) == NSComparisonResult.OrderedAscending } func SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(version: String) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version, options: NSStringCompareOptions.NumericSearch) != NSComparisonResult.OrderedDescending }
let os = ProcessInfo().operatingSystemVersion switch (os.majorVersion, os.minorVersion, os.patchVersion) { case (8, 0, _): print("iOS >= 8.0.0, < 8.1.0") case (8, _, _): print("iOS >= 8.1.0, < 9.0") case (9, _, _): print("iOS >= 9.0.0") default: println("iOS >= 10.0.0") }
import UIKit public class IOSVersion { class func SYSTEM_VERSION_EQUAL_TO(version: NSString) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version, options: NSStringCompareOptions.NumericSearch) == NSComparisonResult.OrderedSame } class func SYSTEM_VERSION_GREATER_THAN(version: NSString) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version as String, options: NSStringCompareOptions.NumericSearch) == NSComparisonResult.OrderedDescending } class func SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(version: NSString) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version as String, options: NSStringCompareOptions.NumericSearch) != NSComparisonResult.OrderedAscending } class func SYSTEM_VERSION_LESS_THAN(version: NSString) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version as String, options: NSStringCompareOptions.NumericSearch) == NSComparisonResult.OrderedAscending } class func SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(version: NSString) -> Bool { return UIDevice.currentDevice().systemVersion.compare(version as String, options: NSStringCompareOptions.NumericSearch) != NSComparisonResult.OrderedDescending } }
IOSVersion.SYSTEM_VERSION_EQUAL_TO("8.0") IOSVersion.SYSTEM_VERSION_LESS_THAN("8.0")
func run() { let version = OperatingSystemVersion(majorVersion: 11, minorVersion: 0, patchVersion: 0) if ProcessInfo.processInfo.isOperatingSystemAtLeast(version) { runNewCode() } else { runLegacyCode() } } func runNewCode() { guard fatalError() } } func runLegacyCode() { }
func SYSTEM_VERSION_EQUAL_TO(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: .numeric) == ComparisonResult.orderedSame } func SYSTEM_VERSION_GREATER_THAN(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: .numeric) == ComparisonResult.orderedDescending } func SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: .numeric) != ComparisonResult.orderedAscending } func SYSTEM_VERSION_LESS_THAN(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: .numeric) == ComparisonResult.orderedAscending } func SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: .numeric) != ComparisonResult.orderedDescending }
let Device = UIDevice.currentDevice() let iosVersion = NSString(string: Device.systemVersion).doubleValue let iOS8 = iosVersion >= 8 let iOS7 = iosVersion >= 7 && iosVersion < 8
iOS iOSApplicationExtension macOS macOSApplicationExtension watchOS watchOSApplicationExtension tvOS tvOSApplicationExtension swift
switch UIDevice.currentDevice().systemVersion.compare("8.0.0", options: NSStringCompareOptions.NumericSearch) { case .OrderedSame, .OrderedDescending: println("iOS >= 8.0") case .OrderedAscending: println("iOS < 8.0") }
extension UIDevice { var iOS: Double? { if UIDevice.current.systemName == "iOS" { if let iosVersion = UIDevice.current.systemVersion.toDouble { return iosVersion } } return nil } } extension String { var toDouble: Double? { if let iosVersion = Double(self) { return iosVersion } var arr = components(separatedBy: ".") if arr.count >= 1 { var integerPart = 0 var floatPart = 0 if let _integerPart = Int(arr[0]), !arr[0].isEmpty{ integerPart = _integerPart } if let _floatPart = Int(arr[1]), !arr[1].isEmpty{ floatPart = _floatPart } return Double("\(integerPart).\(floatPart)") } return nil } }
var stringVersion = "10.1.1" print(stringVersion.toDouble!) stringVersion = ".5.35" print(stringVersion.toDouble!) stringVersion = "..35" print(stringVersion.toDouble!)
if let iosVersion = UIDevice.current.iOS { if iosVersion >= 8.0 { print("current version: \(iosVersion)") } }
extension ProcessInfo { var OS: Double? { let result = "\(ProcessInfo.processInfo.operatingSystemVersion.majorVersion).\(ProcessInfo.processInfo.operatingSystemVersion.minorVersion)" return Double(result) } }
if let systemVersion = ProcessInfo.processInfo.OS { if systemVersion >= 10.1 { print("current version: \(systemVersion)") } }
func iOS_VERSION_EQUAL_TO(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: NSString.CompareOptions.numeric) == ComparisonResult.orderedSame } func iOS_VERSION_GREATER_THAN(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: NSString.CompareOptions.numeric) == ComparisonResult.orderedDescending } func iOS_VERSION_GREATER_THAN_OR_EQUAL_TO(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: NSString.CompareOptions.numeric) != ComparisonResult.orderedAscending } func iOS_VERSION_LESS_THAN(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: NSString.CompareOptions.numeric) == ComparisonResult.orderedAscending } func iOS_VERSION_LESS_THAN_OR_EQUAL_TO(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: NSString.CompareOptions.numeric) != ComparisonResult.orderedDescending }
if iOS_VERSION_GREATER_THAN_OR_EQUAL_TO(version: "11.0") { }
var majorVersion: Int { return NSProcessInfo.processInfo().operatingSystemVersion.majorVersion } var minorVersion: Int { return NSProcessInfo.processInfo().operatingSystemVersion.minorVersion } var patchVersion: Int { return NSProcessInfo.processInfo().operatingSystemVersion.patchVersion } var myOSVersion: String { return NSProcessInfo.processInfo().operatingSystemVersionString }
+ (BOOL) isAtLeastOSVersion:(NSString *)osVersion { switch ([[UIDevice currentDevice].systemVersion compare:osVersion options:NSNumericSearch]) { case NSOrderedSame: case NSOrderedDescending: return YES; default: return NO; } }
@interface ANFakeCurrDevice : NSObject @property (nonatomic, strong) NSString *systemVersion; @end @implementation ANFakeCurrDevice @end @implementation MyHelperClassUnitTests - (void)setUp { [super setUp]; } - (void)tearDown { [super tearDown]; } - (void)test_isAtLeastOSVersion { id deviceMock = [OCMockObject niceMockForClass:[UIDevice class]]; ANFakeCurrDevice *fakeCurrDevice = [ANFakeCurrDevice new]; fakeCurrDevice.systemVersion = @"99.9.9"; [[[deviceMock stub] andReturn:fakeCurrDevice] currentDevice]; XCTAssertTrue([[UIDevice currentDevice].systemVersion isEqualToString:@"99.9.9"]); fakeCurrDevice.systemVersion = @"1.0.1"; XCTAssertTrue([ANConstants isAtLeastOSVersion:@"1"]); XCTAssertTrue([ANConstants isAtLeastOSVersion:@"1.0"]); XCTAssertTrue([ANConstants isAtLeastOSVersion:@"1.0.1"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"1.0.2"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"1.1.0"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"2"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"2.0"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"2.0.0"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"2.0.1"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"2.1.0"]); fakeCurrDevice.systemVersion = @"8.4.0"; XCTAssertTrue([ANConstants isAtLeastOSVersion:@"7.0.1"]); XCTAssertTrue([ANConstants isAtLeastOSVersion:@"8"]); XCTAssertTrue([ANConstants isAtLeastOSVersion:@"8.4"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"8.4.1"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"8.4.2"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"9.0"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"9.0.1"]); XCTAssertFalse([ANConstants isAtLeastOSVersion:@"9.0.2"]); XCTAssertTrue([ANConstants isAtLeastOSVersion:@"8.4"] && ![ANConstants isAtLeastOSVersion:@"9.0"]); fakeCurrDevice.systemVersion = @"8.4.1"; XCTAssertTrue([ANConstants isAtLeastOSVersion:@"8.4"] && ![ANConstants isAtLeastOSVersion:@"9.0"]); } @end
let watchOSVersion = WKInterfaceDevice.currentDevice().systemVersion print("WatchOS version: \(watchOSVersion)")
NSString *watchOSVersion = [[WKInterfaceDevice currentDevice] systemVersion]; NSLog(@"WatchOS version: %@", watchOSVersion);
let osVersion = NSProcessInfo.processInfo().operatingSystemVersion let versionString = osVersion.majorVersion.description + "." + osVersion.minorVersion.description + "." + osVersion.patchVersion.description print(versionString)
let sys_version = UIDevice.current.systemVersion let all_version = sys_version.components(separatedBy: ".") print("Major version : \(all_version[0])") print("Minor version : \(all_version[1])")
func SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(version: String) -> Bool { return UIDevice.current.systemVersion.compare(version, options: .numeric) != ComparisonResult.orderedAscending }
XCTAssertTrue(UIDevice.current.systemVersion.isVersion(lessThan: "99.0.0")) XCTAssertTrue(UIDevice.current.systemVersion.isVersion(equalTo: UIDevice.current.systemVersion)) XCTAssertTrue(UIDevice.current.systemVersion.isVersion(greaterThan: "3.5.99")) XCTAssertTrue(UIDevice.current.systemVersion.isVersion(lessThanOrEqualTo: "10.3.0.0.0.0.0.0")) XCTAssertTrue(UIDevice.current.systemVersion.isVersion(greaterThanOrEqualTo: "10.3"))
class ViewController: UIViewController { var delegate : AppDelegate override func viewDidLoad() { super.viewDidLoad() } @IBAction func getData(sender : AnyObject) { } @IBAction func LogOut(sender : AnyObject) { } }
class ViewController: UIViewController { var delegate : AppDelegate? override func viewDidLoad() { super.viewDidLoad() } @IBAction func getData(sender : AnyObject) { } @IBAction func LogOut(sender : AnyObject) { } }
class myClass { var delegate: AppDelegate init() { delegate = UIApplication.sharedApplication().delegate as AppDelegate } }
class myClass { var delegate = UIApplication.sharedApplication().delegate as AppDelegate init() { println("Hello") } }
class myClass { var delegate : AppDelegate! init() { println("Hello") } func myMethod() { delegate = UIApplication.sharedApplication().delegate as AppDelegate } }
class myClass { var delegate : AppDelegate init() { println("Hello") } func myMethod() { delegate = UIApplication.sharedApplication().delegate as AppDelegate } }
class ViewController: UIViewController { var x: Double var y: String let z: Int }
class ViewController: UIViewCOntroller { var x: Double = 0 var y: String? let z: Int = 2 }
import UIKit class MemeDetailViewController : UIViewController { @IBOutlet weak var memeImage: UIImageView! var meme:Meme! override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) self.memeImage!.image = meme.memedImage } override func viewDidDisappear(animated: Bool) { super.viewDidDisappear(animated) } }
var time: NSTimer! override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } override func viewWillAppear(animated: Bool) { time = NSTimer.scheduledTimerWithTimeInterval(5.0, target: self, selector: } func movetoHome(){ performSegueWithIdentifier("MoveToHome", sender: self) }
let array = [ .... ] if let found = find(array.map({ $0.name }), "Foo") { let obj = array[found] }
if let found = find(lazy(array).map({ $0.name }), "Foo") { let obj = array[found] }
if let found = find(lazy(array).map({ $0.name == "Foo" }), true) { let obj = array[found] }
if array.contains(where: {$0.name == "foo"}) { } else { }
if let foo = array.first(where: {$0.name == "foo"}) { } else { }
if let foo = array.enumerated().first(where: {$0.element.name == "foo"}) { } else { }
if let fooOffset = array.index(where: {$0.name == "foo"}) { } else { }
func index(where predicate: (Element) throws -> Bool) rethrows -> Int?
if let i = array.index(where: { $0.name == Foo }) { return array[i] }
if let i = array.indexOf({ $0.name == Foo }) { return array[i] }
for myObj in myObjList where myObj.name == "foo" { }
extension Array { func findFirstMatching<L : BooleanType>(predicate: T -> L) -> T? { for item in self { if predicate(item) { return item } } return nil } }
struct T { var name : String } let array = [T(name: "bar"), T(name: "baz"), T(name: "foo")] if let item = array.findFirstMatching( { $0.name == "foo" } ) { } else { }
if let item = array.first(where: { $0.name == "foo" }) { } else { }
func index(where predicate: @noescape Element throws -> Bool) rethrows -> Int?
if let i = theArray.index(where: {$0.name == "Foo"}) { return theArray[i] }
if let object = elements.filter({ $0.title == "title" }).first { print("found") } else { print("not found") }
if yourArray.contains(item) { } else{ yourArray.append(item) }
let array = [T(name: "foo"), T(name: "Foo"), T(name: "FOO")] let foundValue = array.indexOf { $0.name == "Foo" }.map { array[$0] } print(foundValue)
var yourItem:YourType! if contains(yourArray, item){ yourItem = item }
class Person : Equatable { let name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } static func == (lhs: Person, rhs: Person) -> Bool { return (lhs.name == rhs.name) } }
let p1 = Person(name: "Paul", age: 20) let p2 = Person(name: "Mike", age: 22) let p3 = Person(name: "Jane", age: 33) var people = [Person]([p1,p2,p3]) let index = people.index(of: p2)! people.remove(at: index)
import Dollar let found = $.find(array) { $0.name == "Foo" }
var address:string address = "American Tourister, Abids Road, Bogulkunta, Hyderabad, Andhra Pradesh, India" let urlpath = NSString(format: "http:
var escapedAddress = address.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())
var address = "American Tourister, Abids Road, Bogulkunta, Hyderabad, Andhra Pradesh, India" var escapedAddress = address.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding) let urlpath = NSString(format: "http:
var address = "American Tourister, Abids Road, Bogulkunta, Hyderabad, Andhra Pradesh, India" let escapedAddress = address.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) let urlpath = String(format: "http:
var address = "American Tourister, Abids Road, Bogulkunta, Hyderabad, Andhra Pradesh, India" var components = URLComponents(string: "http: components.queryItems = [URLQueryItem(name: "address", value: address)] let url = components.url!
components.percentEncodedQuery = components.percentEncodedQuery?.replacingOccurrences(of: "+", with: "%2B") let url = components.url!
let escapedString = originalString.addingPercentEncoding(withAllowedCharacters:NSCharacterSet.urlQueryAllowed)
let needsLove = "string needin some URL love" let safeURL = needsLove.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.URLQueryAllowedCharacterSet())!
extension String { var URLEncoded:String { let unreservedChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~" let unreservedCharset = NSCharacterSet(charactersInString: unreservedChars) let encodedString = self.stringByAddingPercentEncodingWithAllowedCharacters(unreservedCharset) return encodedString ?? self } }
func createURLWithComponents() -> URL? { var urlComponents = URLComponents() urlComponents.scheme = "http" urlComponents.host = "maps.googleapis.com" urlComponents.path = "/maps/api/geocode/json" let addressQuery = URLQueryItem(name: "address", value: "American Tourister, Abids Road, Bogulkunta, Hyderabad, Andhra Pradesh, India") urlComponents.queryItems = [addressQuery] return urlComponents.url }
guard let url = createURLWithComponents() else { print("invalid URL") return nil } print(url)
var address = "American Tourister, Abids Road, Bogulkunta, Hyderabad, Andhra Pradesh, India" var queryCharSet = NSCharacterSet.urlQueryAllowed queryCharSet.remove(charactersIn: "+&") let escapedAddress = address.addingPercentEncoding(withAllowedCharacters: queryCharSet)! let urlpath = String(format: "http:
var escapedAddress = address.addingPercentEncoding( withAllowedCharacters: CharacterSet.urlQueryAllowed)
let address = "American Tourister, Abids Road, Bogulkunta, Hyderabad, Andhra Pradesh, India" let components = NSURLComponents(string: "http: let queryItem = NSURLQueryItem(name: "address", value: address) components.queryItems = [queryItem] let urlpath = components.string! print(urlpath)
extension String { var RFC3986UnreservedEncoded:String { let unreservedChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~" let unreservedCharsSet: CharacterSet = CharacterSet(charactersIn: unreservedChars) let encodedString: String = self.addingPercentEncoding(withAllowedCharacters: unreservedCharsSet)! return encodedString } }
extension String { func urlPercentEncoded(withAllowedCharacters allowedCharacters: CharacterSet, encoding: String.Encoding) -> String { var returnStr = "" for char in self { let charStr = String(char) let charScalar = charStr.unicodeScalars[charStr.unicodeScalars.startIndex] if allowedCharacters.contains(charScalar) == false, let bytesOfChar = charStr.data(using: encoding) { for byte in bytesOfChar { returnStr += "%" + String(format: "%02hhX", byte as CVarArg) } } else { returnStr += charStr } } return returnStr } }
"aou√§√∂√º!".urlPercentEncoded(withAllowedCharacters: .urlQueryAllowed, encoding: .isoLatin1)
extension String { func encodeUTF8() -> String? { if let _ = NSURL(string: self) { return self } let optionalLastComponent = self.characters.split { $0 == "/" }.last if let lastComponent = optionalLastComponent { let lastComponentAsString = lastComponent.map { String($0) }.reduce("", combine: +) if let rangeOfLastComponent = self.rangeOfString(lastComponentAsString) { let stringWithoutLastComponent = self.substringToIndex(rangeOfLastComponent.startIndex) if let lastComponentEncoded = lastComponentAsString.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.alphanumericCharacterSet()) { let encodedString = stringWithoutLastComponent + lastComponentEncoded return encodedString } } } return nil; } }
var streetAdress = "123 fake street, new york, ny" var escapedStreetAddress = streetAddress.stringByAddingPercentEncodingWithAllowedCharacters(.URLHostAllowedCharacterSet()) let url = "\(self.baseUrl)&address=\(escapedAddress!)"
import UIKit class ViewController: UIViewController, UITextFieldDelegate, UITableViewDelegate, UITableViewDataSource { var tableView: UITableView! var textField: UITextField! var tableViewData:Array<String> = [] let lightColor: UIColor = UIColor(red: 0.996, green: 0.467, blue: 0.224, alpha: 1) let medColor: UIColor = UIColor(red: 0.973, green: 0.388, blue: 0.173, alpha: 1) let darkColor: UIColor = UIColor(red: 0.800, green: 0.263, blue: 0.106, alpha: 1) let greenColor: UIColor = UIColor(red: 0.251, green: 0.831, blue: 0.494, alpha: 1) init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) { super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) } override func viewDidLoad() { super.viewDidLoad() self.tableView = UITableView(frame: CGRectMake(0, 100, self.view.bounds.size.width, self.view.bounds.size.height-100), style: UITableViewStyle.Plain) self.tableView.registerClass(MyTableViewCell.self, forCellReuseIdentifier: "myCell") self.tableView.backgroundColor = darkColor self.tableView.delegate = self self.tableView.dataSource = self self.view.addSubview(self.tableView) self.textField = UITextField(frame: CGRectMake(0, 0, self.view.bounds.size.width, 100)) self.textField.backgroundColor = lightColor self.textField.font = UIFont(name: "AvenirNext-Bold", size: 26) self.textField.delegate = self self.view.addSubview(self.textField) } func tableView(tableView: UITableView!, numberOfRowsInSection section: Int) -> Int { return tableViewData.count } func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { var myNewCell: MyTableViewCell = tableView.dequeueReusableCellWithIdentifier("myCell", forIndexPath: indexPath) as MyTableViewCell myNewCell.text = self.tableViewData[indexPath.row] return myNewCell } func tableView(tableView: UITableView!, didSelectRowAtIndexPath indexPath: NSIndexPath!) { let mySelectedCell:UITableViewCell = tableView.cellForRowAtIndexPath(indexPath) mySelectedCell.detailTextLabel.textColor = UIColor.whiteColor() mySelectedCell.tintColor = UIColor.whiteColor() let myDate:NSDate = NSDate() var myDateFormatter:NSDateFormatter = NSDateFormatter() myDateFormatter.dateStyle = NSDateFormatterStyle.MediumStyle mySelectedCell.detailTextLabel.text = myDateFormatter.stringFromDate(myDate) mySelectedCell.accessoryType = UITableViewCellAccessoryType.Checkmark mySelectedCell.backgroundColor = greenColor } override func prefersStatusBarHidden() -> Bool { return true } func textFieldShouldReturn(textField: UITextField!) -> Bool { tableViewData.append(textField.text) textField.text = "" self.tableView.reloadData() textField.resignFirstResponder() return true } }
import UIKit class MyTableViewCell: UITableViewCell { let medColor: UIColor = UIColor(red: 0.973, green: 0.388, blue: 0.173, alpha: 1) init(style: UITableViewCellStyle, reuseIdentifier: String) { super.init(style: UITableViewCellStyle.Subtitle, reuseIdentifier: reuseIdentifier) self.textColor = UIColor.whiteColor() self.backgroundColor = medColor self.selectionStyle = UITableViewCellSelectionStyle.None } override func awakeFromNib() { super.awakeFromNib() } override func setSelected(selected: Bool, animated: Bool) { super.setSelected(selected, animated: animated) } }
func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -> Bool { return true } func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if (editingStyle == UITableViewCellEditingStyle.Delete) { } }
override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { if (editingStyle == UITableViewCellEditingStyle.delete) { } }
func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) { if (editingStyle == .delete) { } }
func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -> Bool { return true } func tableView(tableView: (UITableView!), commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: (NSIndexPath!)) { } func tableView(tableView: UITableView, editActionsForRowAtIndexPath indexPath: NSIndexPath) -> [AnyObject]? { var deleteAction = UITableViewRowAction(style: .Default, title: "Delete") {action in } var editAction = UITableViewRowAction(style: .Normal, title: "Edit") {action in } return [deleteAction, editAction] }
func tableView(tableView: UITableView!, canEditRowAtIndexPath indexPath: NSIndexPath!) -> Bool { return true } func tableView(tableView: UITableView!, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath!) { if (editingStyle == UITableViewCellEditingStyle.Delete) { NamesTable.beginUpdates() Names.removeAtIndex(indexPath!.row) NamesTable.deleteRowsAtIndexPaths([indexPath], withRowAnimation: nil) NamesTable.endUpdates() } }
import UIKit class ViewController: UIViewController ,UITableViewDelegate,UITableViewDataSource { var items: String[] = ["We", "Heart", "Swift","omnamay shivay","om namay bhagwate vasudeva nama"] var cell : UITableViewCell } @IBOutlet var tableview:UITableView override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func tableView(tableView: UITableView!, numberOfRowsInSection section: Int) -> Int { return self.items.count; } func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { var cell = tableView.dequeueReusableCellWithIdentifier("CELL") as? UITableViewCell if !cell { cell = UITableViewCell(style: UITableViewCellStyle.Value1, reuseIdentifier: "CELL")} cell!.textLabel.text = self.items[indexPath.row] return cell } func tableView(tableView: UITableView!, canEditRowAtIndexPath indexPath: NSIndexPath!) -> Bool { return true } func tableView(tableView: UITableView!, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath!) { if (editingStyle == UITableViewCellEditingStyle.Delete) { if let tv=tableView { items.removeAtIndex(indexPath!.row) tv.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) } } } }
func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if editingStyle == UITableViewCellEditingStyle.Delete { langData.removeAtIndex(indexPath.row) tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Automatic) } }
@available(iOS 11.0, *) override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? { let delete = UIContextualAction(style: .destructive, title: "Delete") { (action, sourceView, completionHandler) in print("index path of delete: \(indexPath)") completionHandler(true) } let rename = UIContextualAction(style: .normal, title: "Edit") { (action, sourceView, completionHandler) in print("index path of edit: \(indexPath)") completionHandler(true) } let swipeActionConfig = UISwipeActionsConfiguration(actions: [rename, delete]) swipeActionConfig.performsFirstActionWithFullSwipe = false return swipeActionConfig }
func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } func tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -> String? { return "Cancel" } func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { if (editingStyle == UITableViewCellEditingStyle.delete) { tableView.deleteRows(at: indexPath, with: .automatic) } }
override func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -> Bool { return true } override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if (editingStyle == UITableViewCellEditingStyle.Delete) { } }
override func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -> Bool { return true } override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { } override func tableView(tableView: UITableView, editActionsForRowAtIndexPath indexPath: NSIndexPath) -> [UITableViewRowAction]? { let block = UITableViewRowAction(style: .Normal, title: "Block") { action, index in print("Block") self.removeObjectAtIndexPath(indexPath, animated: true) } let delete = UITableViewRowAction(style: .Default, title: "Delete") { action, index in print("Delete") self.removeObjectAtIndexPath(indexPath, animated: true) } return [delete, block] }
func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { if (editingStyle == UITableViewCellEditingStyle.delete) { dataList.remove(at: indexPath.row) tableView.deleteRows(at: [indexPath], with: .fade) } }
func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? { let delete = UITableViewRowAction(style: .destructive, title: "delete") { (action, indexPath) in } return [delete] }
func tableView(tableView: UITableView, editActionsForRowAtIndexPath indexPath: NSIndexPath) -> [UITableViewRowAction]? { let delete = UITableViewRowAction(style: UITableViewRowActionStyle.Default, title: "DELETE"){(UITableViewRowAction,NSIndexPath) -> Void in print("What u want while Pressed delete") } let edit = UITableViewRowAction(style: UITableViewRowActionStyle.Normal, title: "EDIT"){(UITableViewRowAction,NSIndexPath) -> Void in print("What u want while Pressed Edit") } edit.backgroundColor = UIColor.blackColor() return [delete,edit] }
@available(iOS 11.0, *) func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? { let action = UIContextualAction(style: .normal, title: "", handler: { (action,view,completionHandler ) in completionHandler(true) let data:NSDictionary = self.conversations[indexPath.row] as! NSDictionary print(data) let alert:UIAlertController = UIAlertController(title: "", message: "are you sure want to delete ?", preferredStyle: .alert) alert.addAction(UIAlertAction(title: "CANCEL", style: UIAlertActionStyle.cancel, handler: { (action) in })) self.present(alert, animated: true, completion: nil) }) action.image = UIImage(named: "") action.backgroundColor = UIColor(red: 0/255, green: 148/255, blue: 204/255, alpha: 1.0) let confrigation = UISwipeActionsConfiguration(actions: [action]) return confrigation }
func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? { let edit = UIContextualAction(style: .normal, title: "") { (action, view, nil) in let refreshAlert = UIAlertController(title: "Deletion", message: "Are you sure you want to remove this item from cart? ", preferredStyle: .alert) refreshAlert.addAction(UIAlertAction(title: "Yes", style: .default, handler: { (action: UIAlertAction!) in })) refreshAlert.addAction(UIAlertAction(title: "No", style: .default, handler: { (action: UIAlertAction!) in refreshAlert .dismiss(animated: true, completion: nil) })) self.present(refreshAlert, animated: true, completion: nil) } edit.backgroundColor = edit.image = let config = UISwipeActionsConfiguration(actions: [edit]) config.performsFirstActionWithFullSwipe = false return config }
func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? { let delete = UITableViewRowAction(style: UITableViewRowActionStyle.destructive, title: "Delete") { (action, indexPath) in self.arrayFruit.remove(at: indexPath.row) self.tblList.reloadData() } let edit = UITableViewRowAction(style: UITableViewRowActionStyle.normal, title: "Edit") { (action, indexpath) in let alert = UIAlertController(title: "FruitApp", message: "Enter Fuit Name", preferredStyle: UIAlertControllerStyle.alert) alert.addTextField(configurationHandler: { (textField) in textField.placeholder = "Enter new fruit name" }) alert.addAction(UIAlertAction(title: "Update", style: UIAlertActionStyle.default, handler: { [weak alert](_) in let textField = alert?.textFields![0] self.arrayFruit[indexPath.row] = (textField?.text!)! self.tblList.reloadData() })) self.present(alert, animated: true, completion: nil) } edit.backgroundColor = UIColor.blue return [delete,edit] }
func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { if (editingStyle == UITableViewCellEditingStyle.delete) { print("delete tableview cell") } }
func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { if (editingStyle == UITableViewCellEditingStyle.delete) { arrayCityName.remove(at: indexPath.row) self.tableCityName.reloadData() } }
func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { if (editingStyle == UITableViewCellEditingStyle.delete) { if let tv=table { data.remove(at: indexPath.row) tv.deleteRows(at: [indexPath], with: .fade) } } }
@available(iOS 11.0, *) func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? { let editAction = UIContextualAction.init(style: UIContextualAction.Style.normal, title: "Edit", handler: { (action, view, completion) in completion(true) self.popUpViewPresent(index:indexPath.row) }) let deleteAction = UIContextualAction.init(style: UIContextualAction.Style.destructive, title: "Delete", handler: { (action, view, completion) in completion(true) self.deleteTagAction(senderTag:indexPath.row) }) editAction.image = UIImage(named: "Edit-white") deleteAction.image = UIImage(named: "Delete-white") editAction.backgroundColor = UIColor.gray deleteAction.backgroundColor = UIColor.red let config = UISwipeActionsConfiguration(actions: [deleteAction, editAction]) config.performsFirstActionWithFullSwipe = false return config }
func tableView(_ tableView: UITableView, editActionsForRowAt: IndexPath) -> [UITableViewRowAction]? { let share = UITableViewRowAction(style: .normal, title: "Share") { action, index in print("share button tapped") } share.backgroundColor = .lightGray let delete = UITableViewRowAction(style: .normal, title: "Delete") { action, index in self.nameArray.remove(at: editActionsForRowAt.row) self.swipeTable.beginUpdates() self.swipeTable.deleteRows(at: [editActionsForRowAt], with: .right) self.swipeTable.endUpdates() print("delete button tapped") } delete.backgroundColor = .orange return [share,delete] } func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true }
var colorsForColorScheme: [ColorScheme : UIColor] = ...
let colors: [UIColor] = colorsForColorSchemes.values ~~~~~~~~~~~~~~~~~~~~~^~~~~~~
public extension LazyMapCollection { func toArray() -> [Element]{ return Array(self) } }
override func viewDidLoad() { super.viewDidLoad() var swipeRight = UISwipeGestureRecognizer(target: self, action: "respondToSwipeGesture:") swipeRight.direction = UISwipeGestureRecognizerDirection.Right self.view.addGestureRecognizer(swipeRight) var swipeDown = UISwipeGestureRecognizer(target: self, action: "respondToSwipeGesture:") swipeDown.direction = UISwipeGestureRecognizerDirection.Down self.view.addGestureRecognizer(swipeDown) } func respondToSwipeGesture(gesture: UIGestureRecognizer) { if let swipeGesture = gesture as? UISwipeGestureRecognizer { switch swipeGesture.direction { case UISwipeGestureRecognizerDirection.Right: print("Swiped right") case UISwipeGestureRecognizerDirection.Down: print("Swiped down") case UISwipeGestureRecognizerDirection.Left: print("Swiped left") case UISwipeGestureRecognizerDirection.Up: print("Swiped up") default: break } } }
override func viewDidLoad() { super.viewDidLoad() let swipeRight = UISwipeGestureRecognizer(target: self, action: swipeRight.direction = UISwipeGestureRecognizerDirection.right self.view.addGestureRecognizer(swipeRight) let swipeDown = UISwipeGestureRecognizer(target: self, action: swipeDown.direction = UISwipeGestureRecognizerDirection.down self.view.addGestureRecognizer(swipeDown) } func respondToSwipeGesture(gesture: UIGestureRecognizer) { if let swipeGesture = gesture as? UISwipeGestureRecognizer { switch swipeGesture.direction { case UISwipeGestureRecognizerDirection.right: print("Swiped right") case UISwipeGestureRecognizerDirection.down: print("Swiped down") case UISwipeGestureRecognizerDirection.left: print("Swiped left") case UISwipeGestureRecognizerDirection.up: print("Swiped up") default: break } } }
func addSwipe() { let directions: [UISwipeGestureRecognizerDirection] = [.Right, .Left, .Up, .Down] for direction in directions { let gesture = UISwipeGestureRecognizer(target: self, action: Selector("handleSwipe:")) gesture.direction = direction self.addGestureRecognizer(gesture) } } func handleSwipe(sender: UISwipeGestureRecognizer) { print(sender.direction) }
@IBAction func rightGesture(sender: UISwipeGestureRecognizer) { print ("Right") } @IBAction func leftGesture(sender: UISwipeGestureRecognizer) { print ("Left") } @IBAction func upGesture(sender: UISwipeGestureRecognizer) { print = ("Up") } @IBAction func downGesture(sender: UISwipeGestureRecognizer) { print ("Down") }
override func viewDidLoad() { super.viewDidLoad() let swipeGesture = UISwipeGestureRecognizer(target: self, action: "handleSwipe:") swipeGesture.direction = [.Down, .Up] self.view.addGestureRecognizer(swipeGesture) } func handleSwipe(sender: UISwipeGestureRecognizer) { print(sender.direction) }
let swipeGesture = UISwipeGestureRecognizer() { print("Gesture recognized !") } swipeGesture.direction = [.Down, .Up] self.view.addGestureRecognizer(swipeGesture)
let directions: [UISwipeGestureRecognizerDirection] = [.up, .down, .right, .left] for direction in directions { let gesture = UISwipeGestureRecognizer(target: self, action: gesture.direction = direction self.view?.addGestureRecognizer(gesture) } func handleSwipe(gesture: UISwipeGestureRecognizer) { print(gesture.direction) switch gesture.direction { case UISwipeGestureRecognizerDirection.down: print("down swipe") case UISwipeGestureRecognizerDirection.up: print("up swipe") case UISwipeGestureRecognizerDirection.left: print("left swipe") case UISwipeGestureRecognizerDirection.right: print("right swipe") default: print("other swipe") } }
let swipeFromRight = UISwipeGestureRecognizer(target: self, action: swipeFromRight.direction = UISwipeGestureRecognizerDirection.left menuTransparentView.addGestureRecognizer(swipeFromRight) let swipeFromLeft = UISwipeGestureRecognizer(target: self, action: swipeFromLeft.direction = UISwipeGestureRecognizerDirection.right menuTransparentView.addGestureRecognizer(swipeFromLeft) @objc func didSwipeLeft(gesture: UIGestureRecognizer) { DispatchQueue.main.async(execute: { let animation = CATransition() animation.type = kCATransitionReveal animation.subtype = kCATransitionFromRight animation.duration = 0.5 animation.delegate = self animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) }) } @objc func didSwipeRight(gesture: UIGestureRecognizer) { DispatchQueue.main.async(execute: { let animation = CATransition() animation.type = kCATransitionReveal animation.subtype = kCATransitionFromLeft animation.duration = 0.5 animation.delegate = self animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) }) }
let gesture = UISwipeGestureRecognizer(target: self, action: gesture.direction = [.right, .left, .up, .down] self.addGestureRecognizer(gesture)
import UIKit import PlaygroundSupport class SwipeableView: UIView { convenience init() { self.init(frame: CGRect(x: 100, y: 100, width: 100, height: 100)) backgroundColor = .red [UISwipeGestureRecognizerDirection.right, .left, .up, .down].map({ let gesture = UISwipeGestureRecognizer(target: self, action: gesture.direction = $0 self.addGestureRecognizer(gesture) }) } func gestureHandler(sender: UISwipeGestureRecognizer) { switch sender.direction { case [.left]: frame.origin.x -= 10 case [.right]: frame.origin.x += 10 case [.up]: frame.origin.y -= 10 case [.down]: frame.origin.y += 10 default: break } } } class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white view.addSubview(SwipeableView()) } } let controller = ViewController() PlaygroundPage.current.liveView = controller
[UISwipeGestureRecognizerDirection.right, UISwipeGestureRecognizerDirection.left, UISwipeGestureRecognizerDirection.up, UISwipeGestureRecognizerDirection.down].forEach({ direction in let swipe = UISwipeGestureRecognizer(target: self, action: swipe.direction = direction self.view.addGestureRecognizer(swipe) })
class BaseViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let swipeRight = UISwipeGestureRecognizer(target: self, action: swipeRight.direction = UISwipeGestureRecognizerDirection.right self.view.addGestureRecognizer(swipeRight) let swipeLeft = UISwipeGestureRecognizer(target: self, action: swipeLeft.direction = UISwipeGestureRecognizerDirection.left self.view.addGestureRecognizer(swipeLeft) } @objc func swiped(_ gesture: UISwipeGestureRecognizer) { if gesture.direction == .left { if (self.tabBarController?.selectedIndex)! < 5 { self.tabBarController?.selectedIndex += 1 } } else if gesture.direction == .right { if (self.tabBarController?.selectedIndex)! > 0 { self.tabBarController?.selectedIndex -= 1 } } } }
let swipeGestureRight = UISwipeGestureRecognizer(target: self, action: swipeGestureRight.direction = UISwipeGestureRecognizerDirection.right self.view .addGestureRecognizer(swipeGestureRight) let swipeGestureLeft = UISwipeGestureRecognizer(target: self, action: swipeGestureLeft.direction = UISwipeGestureRecognizerDirection.left self.view.addGestureRecognizer(swipeGestureLeft) let swipeGestureUp = UISwipeGestureRecognizer(target: self, action: swipeGestureUp.direction = UISwipeGestureRecognizerDirection.up self.view.addGestureRecognizer(swipeGestureUp) let swipeGestureDown = UISwipeGestureRecognizer(target: self, action: swipeGestureDown.direction = UISwipeGestureRecognizerDirection.down self.view.addGestureRecognizer(swipeGestureDown)
func respondToSwipeGesture(_ sender: UIGestureRecognizer) { if let swipeGesture = sender as? UISwipeGestureRecognizer { switch swipeGesture.direction { case UISwipeGestureRecognizerDirection.right: print("right swipe") case UISwipeGestureRecognizerDirection.left: print("leftSwipe") case UISwipeGestureRecognizerDirection.up: print("upSwipe") case UISwipeGestureRecognizerDirection.down: print("downSwipe") default: break } } }
func SwipeGestureMethodUsing () { [UISwipeGestureRecognizerDirection.right, UISwipeGestureRecognizerDirection.left, UISwipeGestureRecognizerDirection.up, UISwipeGestureRecognizerDirection.down].forEach({ direction in let swipe = UISwipeGestureRecognizer(target: self, action: swipe.direction = direction window?.addGestureRecognizer(swipe) }) } func respondToSwipeGesture(gesture: UIGestureRecognizer) { if let swipeGesture = gesture as? UISwipeGestureRecognizer { switch swipeGesture.direction { case UISwipeGestureRecognizerDirection.right: print("Swiped right") case UISwipeGestureRecognizerDirection.down: print("Swiped down") case UISwipeGestureRecognizerDirection.left: print("Swiped left") case UISwipeGestureRecognizerDirection.up: print("Swiped up") default: break } } }
UISwipeGestureRecognizer.Direction.init( rawValue: UISwipeGestureRecognizer.Direction.left.rawValue | UISwipeGestureRecognizer.Direction.right.rawValue | UISwipeGestureRecognizer.Direction.up.rawValue | UISwipeGestureRecognizer.Direction.down.rawValue )
var unwrappedValue if let value = optionalValue { unwrappedValue = value } else { unwrappedValue = defaultValue }
val myValue = optionalValue.getOrElse(defaultValue)
var unwrappedValue = optionalValue ? optionalValue! : defaultValue
extension Optional { func or(defaultValue: T) -> T { switch(self) { case .None: return defaultValue case .Some(let value): return value } } }
infix operator ??? { associativity left precedence 140 } func ???<T>(optLeft:T?, right:T!) -> T! { if let left = optLeft { return left } else { return right} }
extension Optional { func getOrElse<T>(defaultValue: T) -> T { if let value = self? { return value as T } else { return defaultValue } } }
let x: Int? let y = x.getOrElse(1.414) let a: Int? = 5 let b: Double = a.getOrElse(3.14)
class ViewController: UIViewController { @IBOutlet weak var button: UIButton! override func viewDidLoad() { super.viewDidLoad() button.addTarget(self, action: } @objc func foo() { } }
@objc extension ViewController { func foo() {} func bar() {} }
@objcMembers class ViewController: UIViewController { }
let tap = UITapGestureRecognizer(target: self, action: @IBAction func cancel() { self.dismiss(animated: true, completion: nil) }
typedef void (^APLCalibrationProgressHandler)(float percentComplete); typedef void (^APLCalibrationCompletionHandler)(NSInteger measuredPower, NSError *error); @property (strong) APLCalibrationProgressHandler progressHandler; @property (strong) APLCalibrationCompletionHandler completionHandler; - (id)initWithRegion:(CLBeaconRegion *)region completionHandler:(APLCalibrationCompletionHandler)handler { self = [super init]; if(self) { ... _completionHandler = [handler copy]; .. } return self; } - (void)performCalibrationWithProgressHandler:(APLCalibrationProgressHandler)handler { ... self.progressHandler = [handler copy]; ... dispatch_async(dispatch_get_main_queue(), ^{ _completionHandler(0, error); }); ... }
var completionHandler:(Float)->Void={} init() { locationManager = CLLocationManager() region = CLBeaconRegion() timer = NSTimer() } convenience init(region: CLBeaconRegion, handler:((Float)->Void)) { self.init() locationManager.delegate = self self.region = region completionHandler = handler rangedBeacons = NSMutableArray() }
var completionHandler: (Float)->Void = { (arg: Float) -> Void in }
if let handler = completionHandler { handler(result) }
@interface PopupView : UIView @property (nonatomic, copy) void (^onHideComplete)(); @end @interface PopupView () ... - (IBAction)hideButtonDidTouch:(id sender) { ... if (onHideComplete) onHideComplete (); } @end PopupView * popupView = [[PopupView alloc] init] popupView.onHideComplete = ^() { ... }
class PopupView: UIView { var onHideComplete: (() -> Void)? @IBAction func hideButtonDidTouch(sender: AnyObject) { .... if let callback = self.onHideComplete { callback () } } } var popupView = PopupView () popupView.onHideComplete = { () -> Void in ... }
var completionHandler: (value: Float) -> (); func printFloat(value: Float) { println(value) } completionHandler = printFloat completionHandler(value: 5)
var completionHandler:([String:Any], Bool)->Void = { dict, success in if sucess { print(dict) } }
self.completionHandler(["name":"Gurjinder singh"],true)
func xyz(with param1: String, completion: Completion) { }
var exeBlk = { () -> Void in } exeBlk = { } exeBlk = {}
class MyClass { } let MyClassRef = MyClass.self let my_obj = MyClassRef()
Y().me() ^ <REPL>:3:7: note: selected implicit initializer with type class X { ^
class X { func me() { println("asdf") } required init () { } } let Y = X.self Y().me()
@objc(Zilk) class Zilk : NSObject { override var description : String {return "I am a Zilk"} } @objc(Zork) class Zork : Zilk { override var description : String {return "I am a Zork"} }
let aClass = NSClassFromString("Zork") as NSObject.Type let anObject = aClass() println(anObject)
let typeOfObject = aGivenObject.dynamicType var freshInstance = typeOfObject()
let someType = "Fooo".dynamicType let emptyString = someType() let threeString = someType("Three")
protocol Decoratable{} class A:Decoratable{} class B:Decoratable{} let object:AnyObject = A() object.dynamicType is A.Type object.dynamicType is B.Type object.dynamicType is Decoratable.Type
import Foundation var classMap = Dictionary<String, AnyObject>() func mapClass(name: String, constructor: AnyObject) -> () { classMap[name] = constructor; } class Factory { class func create(className: String) -> AnyObject? { var something : AnyObject? var template : FactoryObject? = classMap[className] as? FactoryObject if (template) { let somethingElse : FactoryObject = template!.dynamicType() return somethingElse } return nil } } import ObjectiveC class FactoryObject : NSObject { @required init() {} } class Foo : FactoryObject { class override func initialize() { mapClass("LocalData", LocalData()) } init () { super.init() } } var makeFoo : AnyObject? = Factory.create("Foo")
class NamedItem : NSObject { func display() { println("display") } required override init() { super.init() println("base") } } class File : NamedItem { required init() { super.init() println("folder") } } class Folder : NamedItem { required init() { super.init() println("file") } } let y = Folder.self y().display() let z = File.self z().display()
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { GMSServices.provideAPIKey("AIza....") return true }
Objective-C Bridging Header Debug (had the value) Release (had the value) Any architecture | Any SDK (this was blank - problem here!)
import UIKit class CustomOneCell: UITableViewCell { @IBOutlet weak var middleLabel: UILabel! @IBOutlet weak var leftLabel: UILabel! @IBOutlet weak var rightLabel: UILabel! required init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder) } override init(style: UITableViewCellStyle, reuseIdentifier: String!) { super.init(style: style, reuseIdentifier: reuseIdentifier) } override func awakeFromNib() { super.awakeFromNib() } override func setSelected(selected: Bool, animated: Bool) { super.setSelected(selected, animated: animated) } }
import UIKit class ViewController: UITableViewController, UITableViewDataSource, UITableViewDelegate { var items = ["Item 1", "Item2", "Item3", "Item4"] override func viewDidLoad() { super.viewDidLoad() } override func tableView(tableView: UITableView!, numberOfRowsInSection section: Int) -> Int { return items.count } override func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { let identifier = "Cell" var cell: CustomOneCell! = tableView.dequeueReusableCellWithIdentifier(identifier) as? CustomOneCell if cell == nil { tableView.registerNib(UINib(nibName: "CustomCellOne", bundle: nil), forCellReuseIdentifier: identifier) cell = tableView.dequeueReusableCellWithIdentifier(identifier) as? CustomOneCell } return cell } }
override func tableView(tableView: UITableView!, willDisplayCell cell: CustomOneCell!, forRowAtIndexPath indexPath: NSIndexPath!) { cell.middleLabel.text = items[indexPath.row] cell.leftLabel.text = items[indexPath.row] cell.rightLabel.text = items[indexPath.row] }
import UIKit class CustomOneCell: UITableViewCell { @IBOutlet weak var middleLabel: UILabel! @IBOutlet weak var leftLabel: UILabel! @IBOutlet weak var rightLabel: UILabel! }
import UIKit class TableViewController: UITableViewController { let items = ["Item 1", "Item2", "Item3", "Item4"] override func viewDidLoad() { super.viewDidLoad() tableView.register(UINib(nibName: "CustomOneCell", bundle: nil), forCellReuseIdentifier: "CustomCellOne") } override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return items.count } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier("CustomCellOne", forIndexPath: indexPath) as! CustomOneCell cell.middleLabel.text = items[indexPath.row] cell.leftLabel.text = items[indexPath.row] cell.rightLabel.text = items[indexPath.row] return cell } }
class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var tableView: UITableView! ... override func viewDidLoad() { super.viewDidLoad() self.tableView.delegate = self self.tableView.dataSource = self ...
class TableCell: UITableViewCell { @IBOutlet weak var nameLabel: UILabel! }
override func viewDidLoad() { super.viewDidLoad() let bundle = NSBundle(forClass: self.dynamicType) let tableNib = UINib(nibName: "TableNib", bundle: bundle) let tableNibView = tableNib.instantiateWithOwner(self, options: nil)[0] as! UIView self.tableView.delegate = self self.tableView.dataSource = self self.tableView.frame = self.view.bounds self.tableView.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] let cellNib = UINib(nibName: "TableCellNib", bundle: bundle) self.tableView.registerNib(cellNib, forCellReuseIdentifier: self.tableCellId) self.view.addSubview(tableNibView) }
tblMissions.register(UINib(nibName: "MissionCell", bundle: nil), forCellReuseIdentifier: "MissionCell")
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: "MissionCell", for: indexPath) as? MissionCell else { return UITableViewCell() } return cell }
override func viewDidLoad() { super.viewDidLoad() tableView.registerClass(UICustomTableViewCell.self, forCellReuseIdentifier: "UICustomTableViewCellIdentifier") }
override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier("UICustomTableViewCellIdentifier", forIndexPath: indexPath) as! UICustomTableViewCell return cell }
override func tableView(tableView: (UITableView!), cellForRowAtIndexPath indexPath: (NSIndexPath!)) -> UITableViewCell {...}
tableView.registerNib(UINib(nibName: "CustomCell", bundle: nil), forCellReuseIdentifier: "CustomCell")
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return self.arrayFruit.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { var cell:simpleTableViewCell? = tableView.dequeueReusableCell(withIdentifier:"simpleTableViewCell") as? simpleTableViewCell if cell == nil{ tableView.register(UINib.init(nibName: "simpleTableViewCell", bundle: nil), forCellReuseIdentifier: "simpleTableViewCell") let arrNib:Array = Bundle.main.loadNibNamed("simpleTableViewCell",owner: self, options: nil)! cell = arrNib.first as? simpleTableViewCell } cell?.labelName.text = self.arrayFruit[indexPath.row] cell?.imageViewFruit.image = UIImage (named: "fruit_img") return cell! } func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat { return 100.0 }
import UIKit class ImageCell2: UITableViewCell { @IBOutlet weak var imgBookLogo: UIImageView! @IBOutlet weak var lblTitle: UILabel! @IBOutlet weak var lblPublisher: UILabel! override func awakeFromNib() { super.awakeFromNib() } override func setSelected(_ selected: Bool, animated: Bool) { super.setSelected(selected, animated: animated) } } step 2 . According Viewcontroller class
@IBOutlet weak var tblMainVC: UITableView! var arrBook : [BookItem] = [BookItem]() override func viewDidLoad() { super.viewDidLoad() self.tblMainVC.register(UINib.init(nibName: "ImageCell2", bundle: nil), forCellReuseIdentifier: "ImageCell2") APIManagerData._APIManagerInstance.getAPIBook { (itemInstance) in self.arrBook = itemInstance.arrItem! self.tblMainVC.reloadData() } } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return self.arrBook.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
let xml = GDataXMLDocument( XMLString: responseBody, options: 0, error: &xmlError); if (xmlError != nil)
guard let abc = abc else { return } guard let xyz = xyz else { return }
func f(x: String?) -> String { return x == nil ? "empty" : "non-empty" }
extension Optional { func ifValue(_ valueHandler: (Wrapped) -> Void) { switch self { case .some(let wrapped): valueHandler(wrapped) default: break } } }
var helloString: String? = "Hello, World!" helloString.ifValue { print($0) } helloString = nil helloString.ifValue { print($0) }
var xyz : NSDictionary? xyz = ["1":"one"] xyz = NSDictionary() if xyz { NSLog("xyz is not nil.") } else { NSLog("xyz is nil.") }
let someDateTime = Date(timeIntervalSinceReferenceDate: -123456789.0)
var dateComponents = DateComponents() dateComponents.year = 1980 dateComponents.month = 7 dateComponents.day = 11 dateComponents.timeZone = TimeZone(abbreviation: "JST") dateComponents.hour = 8 dateComponents.minute = 34 let userCalendar = Calendar.current let someDateTime = userCalendar.date(from: dateComponents)
let formatter = DateFormatter() formatter.dateFormat = "yyyy/MM/dd HH:mm" let someDateTime = formatter.date(from: "2016/10/08 22:31")
extension NSDate { convenience init(dateString:String) { let dateStringFormatter = NSDateFormatter() dateStringFormatter.dateFormat = "yyyy-MM-dd" dateStringFormatter.locale = NSLocale(localeIdentifier: "en_US_POSIX") let d = dateStringFormatter.dateFromString(dateString)! self.init(timeInterval:0, sinceDate:d) } }
class Date { class func from(year: Int, month: Int, day: Int) -> Date { let gregorianCalendar = NSCalendar(calendarIdentifier: .gregorian)! var dateComponents = DateComponents() dateComponents.year = year dateComponents.month = month dateComponents.day = day let date = gregorianCalendar.date(from: dateComponents)! return date } class func parse(_ string: String, format: String = "yyyy-MM-dd") -> Date { let dateFormatter = DateFormatter() dateFormatter.timeZone = NSTimeZone.default dateFormatter.dateFormat = format let date = dateFormatter.date(from: string)! return date } }
var date = Date.parse("2014-05-20") var date = Date.from(year: 2014, month: 05, day: 20)
var myObject = NSDate() let futureDate = myObject.dateByAddingTimeInterval(10) let timeSinceNow = myObject.timeIntervalSinceNow
extension Date { init(dateString:String) { let dateStringFormatter = DateFormatter() dateStringFormatter.dateFormat = "yyyy-MM-dd" dateStringFormatter.locale = Locale(identifier: "en_US_POSIX") let d = dateStringFormatter.date(from: dateString)! self(timeInterval:0, since:d) } }
extension Date { static func from(year: Int, month: Int, day: Int) -> Date? { let calendar = Calendar(identifier: .gregorian) var dateComponents = DateComponents() dateComponents.year = year dateComponents.month = month dateComponents.day = day return calendar.date(from: dateComponents) ?? nil } }
let marsOpportunityLaunchDate = Date.from(year: 2003, month: 07, day: 07)
extension Date { init?(dateString: String) { let dateStringFormatter = DateFormatter() dateStringFormatter.dateFormat = "yyyy-MM-dd" if let d = dateStringFormatter.date(from: dateString) { self.init(timeInterval: 0, since: d) } else { return nil } } }
extension Date { static func from(_ year: Int, _ month: Int, _ day: Int) -> Date? { let gregorianCalendar = Calendar(identifier: .gregorian) let dateComponents = DateComponents(calendar: gregorianCalendar, year: year, month: month, day: day) return gregorianCalendar.date(from: dateComponents) } }
let startDateTimeComponents = NSDateComponents() startDateTimeComponents.year = NSCalendar.currentCalendar().components(NSCalendarUnit.Year, fromDate: date).year startDateTimeComponents.month = NSCalendar.currentCalendar().components(NSCalendarUnit.Month, fromDate: date).month startDateTimeComponents.day = NSCalendar.currentCalendar().components(NSCalendarUnit.Day, fromDate: date).day startDateTimeComponents.hour = NSCalendar.currentCalendar().components(NSCalendarUnit.Hour, fromDate: time).hour startDateTimeComponents.minute = NSCalendar.currentCalendar().components(NSCalendarUnit.Minute, fromDate: time).minute let startDateCalendar = NSCalendar(identifier: NSCalendarIdentifierGregorian) combinedDateTime = startDateCalendar!.dateFromComponents(startDateTimeComponents)!
var url = NSURL(fileURLWithPath:NSBundle.mainBundle().pathForResource("car", ofType:"html")) webView = WKWebView(frame:view.frame) webView!.loadRequest(NSURLRequest(URL:url)) view.addSubview(webView)
func fileURLForBuggyWKWebView8(fileURL: URL) throws -> URL { if !fileURL.isFileURL { throw NSError( domain: "BuggyWKWebViewDomain", code: 1001, userInfo: [NSLocalizedDescriptionKey: NSLocalizedString("URL must be a file URL.", comment:"")]) } try! fileURL.checkResourceIsReachable() let fm = FileManager.default let tmpDirURL = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("www") try! fm.createDirectory(at: tmpDirURL, withIntermediateDirectories: true, attributes: nil) let dstURL = tmpDirURL.appendingPathComponent(fileURL.lastPathComponent) let _ = try? fm.removeItem(at: dstURL) try! fm.copyItem(at: fileURL, to: dstURL) return dstURL }
override func viewDidLoad() { super.viewDidLoad() var fileURL = URL(fileURLWithPath: Bundle.main.path(forResource:"file", ofType: "pdf")!) if webView.loadFileURL(fileURL, allowingReadAccessTo: fileURL) } else { do { fileURL = try fileURLForBuggyWKWebView8(fileURL: fileURL) webView.load(URLRequest(url: fileURL)) } catch let error as NSError { print("Error: " + error.debugDescription) } } }
if let filePath = NSBundle.mainBundle().resourcePath?.stringByAppendingString("/WebApp/index.html"){ let url = NSURL(fileURLWithPath: filePath) if let webAppPath = NSBundle.mainBundle().resourcePath?.stringByAppendingString("/WebApp") { let webAppUrl = NSURL(fileURLWithPath: webAppPath, isDirectory: true) webView.loadFileURL(url, allowingReadAccessToURL: webAppUrl) } }
<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
<link href="/bootstrap/css/bootstrap.min.css" rel="stylesheet">
NSString *docRoot = [[NSBundle mainBundle] pathForResource:@"index" ofType:@"html" inDirectory:@"www"].stringByDeletingLastPathComponent;
_webServer = [[GCDWebServer alloc] init]; [_webServer addGETHandlerForBasePath:@"/" directoryPath:docRoot indexFilename:@"index.html" cacheAge:3600 allowRangeRequests:YES]; [_webServer startWithPort:port bonjourName:nil];
[configuration.preferences setValue:@"TRUE" forKey:@"allowFileAccessFromFileURLs"];
NSString* FILE_PATH = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"htmlapp/FILE"]; [self.webView loadFileURL: [NSURL fileURLWithPath:productURL] allowingReadAccessToURL: [NSURL fileURLWithPath:FILE_PATH] ];
- (NSString *)pathForWKWebViewSandboxBugWithOriginalPath:(NSString *)filePath { NSFileManager *manager = [NSFileManager defaultManager]; NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"www"]; NSError *error = nil; if (![manager createDirectoryAtPath:tempPath withIntermediateDirectories:YES attributes:nil error:&error]) { NSLog(@"Could not create www directory. Error: %@", error); return nil; } NSString *destPath = [tempPath stringByAppendingPathComponent:filePath.lastPathComponent]; if (![manager fileExistsAtPath:destPath]) { if (![manager copyItemAtPath:filePath toPath:destPath error:&error]) { NSLog(@"Couldn return nil; } } return destPath; }
import UIKit import WebKit class ViewController: UIViewController, WKScriptMessageHandler { var theWebView: WKWebView? override func viewDidLoad() { super.viewDidLoad() var path = NSBundle.mainBundle().pathForResource("index", ofType: "html", inDirectory:"www" ) var url = NSURL(fileURLWithPath:path) var request = NSURLRequest(URL:url) var theConfiguration = WKWebViewConfiguration() theConfiguration.userContentController.addScriptMessageHandler(self, name: "interOp") theWebView = WKWebView(frame:self.view.frame, configuration: theConfiguration) let text2 = String.stringWithContentsOfFile(path, encoding: NSUTF8StringEncoding, error: nil) theWebView!.loadHTMLString(text2, baseURL: nil) self.view.addSubview(theWebView) } func appWillEnterForeground() { } func appDidEnterBackground() { } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func userContentController(userContentController: WKUserContentController!, didReceiveScriptMessage message: WKScriptMessage!){ println("got message: \(message.body)") } }
let pathURL = NSURL.fileURLWithPath(attachmentFilePath) guard let path = pathURL.path else { return } guard let data = NSFileManager.defaultManager().contentsAtPath(path) else { return } let image = UIImage.init(data: data) let base64String = data.base64EncodedStringWithOptions(.Encoding64CharacterLineLength) result += "data:image/" + attachmentType + "base64," + base64String var widthHeightString = "\"" if let image = image { widthHeightString += " width=\"\(image.size.width)\" height=\"\(image.size.height)\"" } result += widthHeightString
NSURL *pathURL = [NSURL fileURLWithPath:attachmentFilePath]; NSString *path = [pathURL path]; NSData *data = [[NSFileManager defaultManager] contentsAtPath:path]; UIImage *image = [UIImage imageWithData:data]; NSString *base64String = [data base64EncodedStringWithOptions:0]; [result appendString:@"data:image/"]; [result appendString:attachmentType]; [result appendString:@";base64,"]; [result appendString:base64String]; NSString *widthHeightString = @"\""; if (image) { widthHeightString = [NSString stringWithFormat:@"\" width=\"%f\" height=\"%f\"", image.size.width, image.size.height]; } [result appendString:widthHeightString];
let portNumber = 8080 let task = NSTask() task.launchPath = "/usr/bin/php" task.arguments = ["-S", "localhost:\(portNumber)", "-t", directoryURL.path!] task.standardOutput = NSPipe() task.standardError = NSPipe() task.launch()
override func viewDidLoad() { super.viewDidLoad() let path = NSBundle.mainBundle().resourcePath! + "/www"; var fileURL = NSURL(fileURLWithPath: path) if let path = NSBundle.mainBundle().pathForResource("index", ofType: "html", inDirectory: "www") let url = NSURL(fileURLWithPath: path!) self.webView!.loadRequest(NSURLRequest(URL: url)) } else { do { fileURL = try fileURLForBuggyWKWebView8(fileURL) let url = NSURL(fileURLWithPath: fileURL.path! + "/index.html") self.webView!.loadRequest( NSURLRequest(URL: url)) } catch let error as NSError { print("Error: \(error.debugDescription)") } } }
func fileURLForBuggyWKWebView8(fileURL: NSURL) throws -> NSURL { var error:NSError? = nil; if (!fileURL.fileURL || !fileURL.checkResourceIsReachableAndReturnError(&error)) { throw error ?? NSError( domain: "BuggyWKWebViewDomain", code: 1001, userInfo: [NSLocalizedDescriptionKey: NSLocalizedString("URL must be a file URL.", comment:"")]) } let fm = NSFileManager.defaultManager() let tmpDirURL = NSURL.fileURLWithPath(NSTemporaryDirectory()) try! fm.createDirectoryAtURL(tmpDirURL, withIntermediateDirectories: true, attributes: nil) let dstURL = tmpDirURL.URLByAppendingPathComponent(fileURL.lastPathComponent!) let _ = try? fm.removeItemAtURL(dstURL) try! fm.copyItemAtURL(fileURL, toURL: dstURL) return dstURL }
[webView loadHTMLString:htmlFileContent baseURL:baseURL];
let tap = UITapGestureRecognizer(target: self, action: Selector("handleTap:")) tap.delegate = self myView.addGesture(tap)
let tap = UITapGestureRecognizer(target: self, action: tap.delegate = self myView.addGestureRecognizer(tap)
@objc func handleTap(sender: UITapGestureRecognizer? = nil) { }
let tap = UITapGestureRecognizer(target: self, action: view.addGestureRecognizer(tap) view.isUserInteractionEnabled = true self.view.addSubview(view) func handleTap(_ sender: UITapGestureRecognizer) { print("Hello World") }
let tap = UITapGestureRecognizer(target: self, action: view.addGestureRecognizer(tap) self.view.addSubview(view)
let tap = UITapGestureRecognizer(target: self, action: view.addGestureRecognizer(tap) view.isUserInteractionEnabled = true self.view.addSubview(view) @objc func handleTap(_ sender: UITapGestureRecognizer) { print("Hello World") }
override func viewDidLoad() { super.viewDidLoad() tapGesture = UITapGestureRecognizer(target: self, action: tapGesture.numberOfTapsRequired = 1 tapGesture.numberOfTouchesRequired = 1 viewTap.addGestureRecognizer(tapGesture) viewTap.isUserInteractionEnabled = true }
func myviewTapped(_ sender: UITapGestureRecognizer) { if self.viewTap.backgroundColor == UIColor.yellow { self.viewTap.backgroundColor = UIColor.green }else{ self.viewTap.backgroundColor = UIColor.yellow } }
let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: "touchHappen") view.userInteractionEnabled = true view.addGestureRecognizer(tap)
let tap = UITapGestureRecognizer(target: self, action: view.addGestureRecognizer(tap) view.userInteractionEnabled = true func touchHappen(_ sender: UITapGestureRecognizer) { print("Hello Museer") }
@IBOutlet var myView: UIView! override func viewDidLoad() { super.viewDidLoad() let tap = UITapGestureRecognizer(target: self, action: myView.addGestureRecognizer(tap) } func handleTap() { print("tapped") }
let tap = UITapGestureRecognizer(target: self, action: self.view.addGestureRecognizer(tap) @objc func touchTapped(_ sender: UITapGestureRecognizer) { }
var view1: UIView! func assignTapToView1() { let tap = UITapGestureRecognizer(target: self, action: Selector("handleTap")) view1.addGestureRecognizer(tap) self.view .addSubview(view1) ... } func handleTap() { print("tap working") view1.removeFromSuperview() }
let tap = UITapGestureRecognizer(target: self, action: "handleTap:") tap.delegate = self myView.addGestureRecognizer(tap)
UITapGestureRecognizer *gesRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTap:)]; gesRecognizer.delegate = self; [yourView addGestureRecognizer:gesRecognizer]; - (void)handleTap:(UITapGestureRecognizer *)gestureRecognizer{ NSLog(@"Tapped"); }
import UIKit class ViewController: UIViewController { @IBOutlet weak var myView: UIView! override func viewDidLoad() { super.viewDidLoad() let tapGesture = UITapGestureRecognizer(target: self, action: Selector("handleTap:")) myView.addGestureRecognizer(tapGesture) } func handleTap(sender: UITapGestureRecognizer) { print("tap") } }
let tap = UITapGestureRecognizer(target: self, action: Selector("handleFrontTap:")) frontView.addGestureRecognizer(tap) func handleFrontTap(gestureRecognizer: UITapGestureRecognizer) { print("tap working") }
override func viewDidLoad() { super.viewDidLoad() tapGesture = UITapGestureRecognizer(target: self, action: infosView.isUserInteractionEnabled = true infosView.addGestureRecognizer(tapGesture) view.addSubview(infosView) }
@objc func myviewTapped(_ recognizer: UIGestureRecognizer) { print("button is tapped") }
func addTapGesture() { let tap = UITapGestureRecognizer(target: self, action: tap.numberOfTapsRequired = 1 self.myView.addGestureRecognizer(tap) } func handleTap() { }
import UIKit class KEUITapGesture150427 : UIViewController { var _myTap: UITapGestureRecognizer? var _myView: UIView? override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = UIColor.whiteColor(); _myTap = UITapGestureRecognizer(target: self , action: Selector("_myHandleTap:")) _myTap!.numberOfTapsRequired = 1 _myView = UIView(frame: CGRectMake(100, 200, 100, 100)) _myView!.backgroundColor=UIColor.blueColor() _myView!.layer.cornerRadius = 20 _myView!.layer.borderWidth = 1 _myView!.addGestureRecognizer(_myTap!) view.addSubview(_myView!) } func _myHandleTap(sender: UITapGestureRecognizer) { if sender.state == .Ended { println("_myHandleTap(sender.state == .Ended)") sender.view!.backgroundColor = UIColor(red: CGFloat(drand48()), green: CGFloat(drand48()), blue: CGFloat(drand48()), alpha: 1.0); } } }
import UIKit class MyTapTarget : UIResponder { func _myHandleTap2(sender: UITapGestureRecognizer) { if sender.state == .Ended { println("_myHandleTap2(sender.state == .Ended)") sender.view!.backgroundColor = UIColor(red: CGFloat(drand48()), green: CGFloat(drand48()), blue: CGFloat(drand48()), alpha: 1.0); } } } class KEUITapGesture150427b : UIViewController { var _myTap: UITapGestureRecognizer? var _myView: UIView? var _myTapTarget: MyTapTarget? override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = UIColor.whiteColor(); _myTapTarget = MyTapTarget() _myTap = UITapGestureRecognizer(target: _myTapTarget! , action: Selector("_myHandleTap2:")) _myTap!.numberOfTapsRequired = 1 _myView = UIView(frame: CGRectMake(100, 200, 100, 100)) _myView!.backgroundColor=UIColor.blueColor() _myView!.layer.cornerRadius = 20 _myView!.layer.borderWidth = 1 _myView!.addGestureRecognizer(_myTap!) view.addSubview(_myView!) } }
class BaseVC: UIViewController, UIGestureRecognizerDelegate { @IBOutlet weak var iView: UIView! override func viewDidLoad() { super.viewDidLoad() let clickUITapGestureRecognizer = UITapGestureRecognizer(target: self, action: clickUITapGestureRecognizer.delegate = self iView?.addGestureRecognizer(tap) } func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool { return true } @IBAction func onSelect(_ sender: Any) { } }
extension UIView { func addTapGesture(action : @escaping ()->Void ){ let tap = MyTapGestureRecognizer(target: self , action: tap.action = action tap.numberOfTapsRequired = 1 self.addGestureRecognizer(tap) self.isUserInteractionEnabled = true } @objc func handleTap(_ sender: MyTapGestureRecognizer) { sender.action!() } } class MyTapGestureRecognizer: UITapGestureRecognizer { var action : (()->Void)? = nil }
import Cocoa import XCPlayground let url = NSURL(string: "http: let request = NSURLRequest(URL: url) NSURLConnection.sendAsynchronousRequest(request, queue:NSOperationQueue.currentQueue() { response, maybeData, error in if let data = maybeData { let contents = NSString(data:data, encoding:NSUTF8StringEncoding) println(contents) } else { println(error.localizedDescription) } }
import UIKit import PlaygroundSupport let url = URL(string: "http: URLSession.shared.dataTask(with: url) { data, response, error in guard let data = data, error == nil else { print(error ?? "Unknown error") return } let contents = String(data: data, encoding: .utf8) print(contents!) }.resume() PlaygroundPage.current.needsIndefiniteExecution = true
import UIKit import XCPlayground let url = NSURL(string: "http: let request = NSURLRequest(URL: url!) NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.currentQueue()) { response, maybeData, error in if let data = maybeData { let contents = NSString(data:data, encoding:NSUTF8StringEncoding) println(contents) } else { println(error.localizedDescription) } } XCPlaygroundPage.currentPage.needsIndefiniteExecution = true
import PlaygroundSupport PlaygroundPage.current.needsIndefiniteExecution = true
import XCPlayground XCPlaygroundPage.currentPage.needsIndefiniteExecution = true
import Foundation import XCPlayground XCPlaygroundPage.currentPage.needsIndefiniteExecution = true NSURLSession.sharedSession().dataTaskWithURL(NSURL(string: "http: result in print("Got result: \(result)") XCPlaygroundPage.currentPage.finishExecution() }.resume()
import Cocoa import XCPlayground let url = NSURL(string: "http: let request = NSURLRequest(URL: url) var waiting = true NSURLConnection.sendAsynchronousRequest(request, queue:NSOperationQueue.currentQueue() { response, maybeData, error in waiting = false if let data = maybeData { let contents = NSString(data:data, encoding:NSUTF8StringEncoding) println(contents) } else { println(error.localizedDescription) } } while(waiting) { NSRunLoop.currentRunLoop().runMode(NSDefaultRunLoopMode, beforeDate: NSDate()) usleep(10) }
import PlaygroundSupport PlaygroundPage.current.needsIndefiniteExecution = true PlaygroundPage.current.finishExecution()
import Foundation import PlaygroundSupport PlaygroundPage.current.needsIndefiniteExecution = true let url = URL(string: "https: let task = URLSession.shared.dataTask(with: url) { (data, response, error) in guard error == nil else { print(error?.localizedDescription ?? "") return } if let data = data, let contents = String(data: data, encoding: String.Encoding.utf8) { print(contents) } } task.resume()
import UIKit import Foundation import PlaygroundSupport URLCache.shared = URLCache(memoryCapacity: 0, diskCapacity: 0, diskPath: nil) PlaygroundPage.current.needsIndefiniteExecution = true func completeExecution() { PlaygroundPage.current.finishExecution() } let url = URL(string: "http: let task = URLSession.shared.dataTask(with: url!) { (data, response, error) in var image = UIImage(data: data!) completeExecution() } task.resume()
NSURLConnection.sendAsynchronousRequest(...) NSRunLoop.currentRunLoop().run()
local basename basename="$(basename "$1" | sed -E s/\\..+ local swift_runtime_libs swift_runtime_libs=$(xcrun otool -LX "${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}/${basename}.framework/${basename}" | grep --color=never @rpath/libswift | sed -E s/@rpath\\/\(.+dylib\).*/\\1/g | uniq -u && exit ${PIPESTATUS[0]}) for lib in $swift_runtime_libs; do echo "rsync -auv \"${SWIFT_STDLIB_PATH}/${lib}\" \"${destination}\"" rsync -auv "${SWIFT_STDLIB_PATH}/${lib}" "${destination}" code_sign_if_enabled "${destination}/${lib}" done
gym( scheme: "CoCadre", configuration: "Production Release", clean: true, use_legacy_build_api: false, toolchain: "com.apple.dt.toolchain.Swift_2_3" )
local basename basename="$(basename "$1" | sed -E s/\\..+ local swift_runtime_libs swift_runtime_libs=$(xcrun otool -LX "${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}/${basename}.framework/${basename}" | grep --color=never @rpath/libswift | sed -E s/@rpath\\/\(.+dylib\).*/\\1/g | uniq -u && exit ${PIPESTATUS[0]}) for lib in $swift_runtime_libs; do echo "rsync -auv \"${SWIFT_STDLIB_PATH}/${lib}\" \"${destination}\"" rsync -auv "${SWIFT_STDLIB_PATH}/${lib}" "${destination}" code_sign_if_enabled "${destination}/${lib}" done
if [ "${XCODE_VERSION_MAJOR}" -lt 7 ]; then local swift_runtime_libs swift_runtime_libs=$(xcrun otool -LX "$binary" | grep --color=never @rpath/libswift | sed -E s/@rpath\\/\(.+dylib\).*/\\1/g | uniq -u && exit ${PIPESTATUS[0]}) for lib in $swift_runtime_libs; do echo "rsync -auv \"${SWIFT_STDLIB_PATH}/${lib}\" \"${destination}\"" rsync -auv "${SWIFT_STDLIB_PATH}/${lib}" "${destination}" code_sign_if_enabled "${destination}/${lib}" done fi
-(id)init{ NSArray *subviewArray = [[NSBundle mainBundle] loadNibNamed:@"myXib" owner:self options:nil]; return [subviewArray objectAtIndex:0]; }
class SomeView: UIView { required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) NSBundle.mainBundle().loadNibNamed("SomeView", owner: self, options: nil) self.addSubview(self.view); } ... }
extension UIView { @discardableResult func fromNib<T : UIView>() -> T? { guard let contentView = Bundle(for: type(of: self)).loadNibNamed(String(describing: type(of: self)), owner: self, options: nil)?.first as? T else { return nil } self.addSubview(contentView) contentView.translatesAutoresizingMaskIntoConstraints = false contentView.layoutAttachAll(to: self) return contentView } }
final class SomeView: UIView { required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) fromNib() } init() { super.init(frame: CGRect.zero) fromNib() } }
extension UIView { class func fromNib<T: UIView>() -> T { return Bundle.main.loadNibNamed(String(describing: T.self), owner: nil, options: nil)![0] as! T } }
public extension UIView { public class func fromNib(nibNameOrNil: String? = nil) -> Self { return fromNib(nibNameOrNil, type: self) } public class func fromNib<T : UIView>(nibNameOrNil: String? = nil, type: T.Type) -> T { let v: T? = fromNib(nibNameOrNil, type: T.self) return v! } public class func fromNib<T : UIView>(nibNameOrNil: String? = nil, type: T.Type) -> T? { var view: T? let name: String if let nibName = nibNameOrNil { name = nibName } else { name = nibName } let nibViews = NSBundle.mainBundle().loadNibNamed(name, owner: nil, options: nil) for v in nibViews { if let tog = v as? T { view = tog } } return view } public class var nibName: String { let name = "\(self)".componentsSeparatedByString(".").first ?? "" return name } public class var nib: UINib? { if let _ = NSBundle.mainBundle().pathForResource(nibName, ofType: "nib") { return UINib(nibName: nibName, bundle: nil) } else { return nil } } }
let myCustomView = CustomView.fromNib() let myCustomView: CustomView? = CustomView.fromNib()
let myCustomView = MyCustomView.fromNib("non-conventional-name")
var uiview :UIView? self.uiview = NSBundle.mainBundle().loadNibNamed("myXib", owner: self, options: nil)[0] as? UIView
import UIKit class TestObject: NSObject { var uiview:UIView? init() { super.init() self.uiview = NSBundle.mainBundle().loadNibNamed("myXib", owner: self, options: nil)[0] as? UIView } }
class Dialog: UIView { @IBOutlet var view:UIView! override init(frame: CGRect) { super.init(frame: frame) self.frame = UIScreen.mainScreen().bounds NSBundle.mainBundle().loadNibNamed("Dialog", owner: self, options: nil) self.view.frame = UIScreen.mainScreen().bounds self.addSubview(self.view) } required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } }
import UIKit @IBDesignable class SimpleCustomView:UIView { var view:UIView!; @IBOutlet weak var lblTitle: UILabel! @IBInspectable var lblTitleText : String? { get{ return lblTitle.text; } set(lblTitleText) { lblTitle.text = lblTitleText!; } } override init(frame: CGRect) { super.init(frame: frame) loadViewFromNib () } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) loadViewFromNib () } func loadViewFromNib() { let bundle = NSBundle(forClass: self.dynamicType) let nib = UINib(nibName: "SimpleCustomView", bundle: bundle) let view = nib.instantiateWithOwner(self, options: nil)[0] as! UIView view.frame = bounds view.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] self.addSubview(view); } }
self.customView = SimpleCustomView(frame: CGRectMake(100, 100, 200, 200)) self.view.addSubview(self.customView!);
class UIViewFromNib: UIView { var contentView: UIView! var nibName: String { return String(self.dynamicType) } override init(frame: CGRect) { super.init(frame: frame) loadViewFromNib() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) loadViewFromNib() } private func loadViewFromNib() { contentView = NSBundle.mainBundle().loadNibNamed(nibName, owner: self, options: nil)[0] as! UIView contentView.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] contentView.frame = bounds addSubview(contentView) } }
class UIViewFromNib: UIView { var contentView: UIView! var nibName: String { return String(describing: type(of: self)) } override init(frame: CGRect) { super.init(frame: frame) loadViewFromNib() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) loadViewFromNib() } func loadViewFromNib() { contentView = Bundle.main.loadNibNamed(nibName, owner: self, options: nil)?[0] as! UIView contentView.autoresizingMask = [.flexibleWidth, .flexibleHeight] contentView.frame = bounds addSubview(contentView) } }
extension UIView { public class func fromNib() -> Self { return fromNib(nil) } public class func fromNib(nibName: String?) -> Self { func fromNibHelper<T where T : UIView>(nibName: String?) -> T { let bundle = NSBundle(forClass: T.self) let name = nibName ?? String(T.self) return bundle.loadNibNamed(name, owner: nil, options: nil)?.first as? T ?? T() } return fromNibHelper(nibName) } }
extension UIView { public class func fromNib() -> Self { return fromNib(nibName: nil) } public class func fromNib(nibName: String?) -> Self { func fromNibHelper<T>(nibName: String?) -> T where T : UIView { let bundle = Bundle(for: T.self) let name = nibName ?? String(describing: T.self) return bundle.loadNibNamed(name, owner: nil, options: nil)?.first as? T ?? T() } return fromNibHelper(nibName: nibName) } }
let someView = SomeView.fromNib("SomeOtherNibFileName")
enum Views: String { case view1 = "View1" case view2 = "View2" func getView() -> UIView { return NSBundle.mainBundle().loadNibNamed(self.rawValue, owner: nil, options: nil)[0] as! UIView } }
let subviewArray = NSBundle.mainBundle().loadNibNamed("myXib", owner: self, options: nil) return subviewArray[0]
class SomeView: UIView { override init(frame: CGRect) { super.init(frame: frame) NSBundle.mainBundle().loadNibNamed("SomeObject", owner: self, options: nil) self.addSubview(self.view); } required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) NSBundle.mainBundle().loadNibNamed("SomeObject", owner: self, options: nil) self.addSubview(self.view); } ... }
extension UIView { public class func fromNib(nibName: String? = nil) -> Self { return fromNib(nibName: nibName, type: self) } public class func fromNib<T: UIView>(nibName: String? = nil, type: T.Type) -> T { return fromNib(nibName: nibName, type: T.self)! } public class func fromNib<T: UIView>(nibName: String? = nil, type: T.Type) -> T? { var view: T? let name: String if let nibName = nibName { name = nibName } else { name = self.nibName } if let nibViews = Bundle.main.loadNibNamed(name, owner: nil, options: nil) { for nibView in nibViews { if let tog = nibView as? T { view = tog } } } return view } public class var nibName: String { return "\(self)".components(separatedBy: ".").first ?? "" } public class var nib: UINib? { if let _ = Bundle.main.path(forResource: nibName, ofType: "nib") { return UINib(nibName: nibName, bundle: nil) } else { return nil } } }
class className: UIView { @IBOutlet var view: UIView! override init(frame: CGRect) { super.init(frame: frame) setup() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder)! } func setup() { UINib(nibName: "nib", bundle: nil).instantiateWithOwner(self, options: nil) addSubview(view) view.frame = self.bounds } }
protocol XibLoadable { associatedtype CustomViewType static func loadFromXib() -> CustomViewType } extension XibLoadable where Self: UIView { static func loadFromXib() -> Self { let nib = UINib(nibName: "\(self)", bundle: Bundle(for: self)) guard let customView = nib.instantiate(withOwner: self, options: nil).first as? Self else { preconditionFailure("Couldn } return customView } }
final class MyView: UIView, XibLoadable { ... } let viewInstance = MyView.loadFromXib()
public protocol NibInstantiatable { static func nibName() -> String } extension NibInstantiatable { static func nibName() -> String { return String(describing: self) } } extension NibInstantiatable where Self: UIView { static func fromNib() -> Self { let bundle = Bundle(for: self) let nib = bundle.loadNibNamed(nibName(), owner: self, options: nil) return nib!.first as! Self } }
extension UIView { class func fromNib<A: UIView> (nibName name: String, bundle: Bundle? = nil) -> A? { let bundle = bundle ?? Bundle.main let nibViews = bundle.loadNibNamed(name, owner: self, options: nil) return nibViews?.first as? A } class func fromNib<T: UIView>() -> T? { return fromNib(nibName: String(describing: T.self), bundle: nil) } }
if let myView = UINib.init(nibName: "MyView", bundle: nil).instantiate(withOwner: self)[0] as? MyView { }
BaseView.h @interface BaseView : UIView @end BaseView.m @implementation BaseView - (instancetype)initWithCoder:(NSCoder *)coder { self = [super initWithCoder:coder]; if (self) { [self prepareView]; } return self; } - (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { [self prepareView]; } return self; } - (void)prepareView { NSArray *nibsArray = [[NSBundle mainBundle] loadNibNamed:NSStringFromClass([self class]) owner:self options:nil]; UIView *view = [nibsArray firstObject]; view.translatesAutoresizingMaskIntoConstraints = NO; [self addSubview:view]; [self addConstraintsForView:view]; } - (void)addConstraintsForView:(UIView *)view { [self addConstraints:@[[NSLayoutConstraint constraintWithItem:view attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeBottom multiplier:1.0 constant:0], [NSLayoutConstraint constraintWithItem:view attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeTop multiplier:1.0 constant:0], [NSLayoutConstraint constraintWithItem:view attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeLeft multiplier:1.0 constant:0], [NSLayoutConstraint constraintWithItem:view attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeRight multiplier:1.0 constant:0] ]]; } @end
import UIKit class BaseView : UIView { required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) prepareView() } override init(frame: CGRect) { super.init(frame: frame) prepareView() } internal class func xibName() -> String { return String(describing: self) } fileprivate func prepareView() { let nameForXib = BaseView.xibName() let nibs = Bundle.main.loadNibNamed(nameForXib, owner: self, options: nil) if let view = nibs?.first as? UIView { view.backgroundColor = UIColor.clear view.translatesAutoresizingMaskIntoConstraints = false addSubviewWithConstraints(view, offset: false) } } } UIView+Subview public extension UIView { public func addSubviewWithConstraints(_ subview:UIView, offset:Bool = true) { subview.translatesAutoresizingMaskIntoConstraints = false let views = [ "subview" : subview ] addSubview(subview) var constraints = NSLayoutConstraint.constraints(withVisualFormat: offset ? "H:|-[subview]-|" : "H:|[subview]|", options: [.alignAllLeading, .alignAllTrailing], metrics: nil, views: views) constraints.append(contentsOf: NSLayoutConstraint.constraints(withVisualFormat: offset ? "V:|-[subview]-|" : "V:|[subview]|", options: [.alignAllTop, .alignAllBottom], metrics: nil, views: views)) NSLayoutConstraint.activate(constraints) } }
class func loadFromNib<T: UIView>() -> T { let nibName = String(describing: self) return Bundle.main.loadNibNamed(nibName, owner: nil, options: nil)![0] as! T }
extension UIView { public class func fromNib(nibName: String? = nil) -> Self { return fromNib(nibName: nibName, type: self) } public class func fromNib<T: UIView>(nibName: String? = nil, type: T.Type) -> T { return fromNib(nibName: nibName, type: T.self)! } public class func fromNib<T: UIView>(nibName: String? = nil, type: T.Type) -> T? { var view: T? let name: String if let nibName = nibName { name = nibName } else { name = self.nibName } if let nibViews = nibBundle.loadNibNamed(name, owner: nil, options: nil) { if nibViews.indices.contains(nibIndex), let tog = nibViews[nibIndex] as? T { view = tog } } return view } public class var nibName: String { return "\(self)".components(separatedBy: ".").first ?? "" } public class var nibIndex: Int { return 0 } public class var nibBundle: Bundle { return Bundle.main } }
class BaseView: UIView { override class var nibName: String { return "BaseView" } weak var delegate: StandardStateViewDelegate? } class ChildView: BaseView { override class var nibIndex: Int { return 1 } }
extension UIView { class var viewId: String { return String(describing: self) } static func instance(from bundle: Bundle? = nil, nibName: String? = nil, owner: Any? = nil, options: [AnyHashable : Any]? = nil) -> Self? { return instancePrivate(from: bundle ?? Bundle.main, nibName: nibName ?? viewId, owner: owner, options: options) } private static func instancePrivate<T: UIView>(from bundle: Bundle, nibName: String, owner: Any?, options: [AnyHashable : Any]?) -> T? { guard let views = bundle.loadNibNamed(nibName, owner: owner, options: options), let view = views.first(where: { $0 is T }) as? T else { return nil } return view } }
guard let customView = CustomView.instance() else { return } print(customView is CustomView)
public class CustomView: UIView { @IBOutlet weak var nameLabel: UILabel! @IBOutlet weak var valueLabel: UILabel! public convenience init() { self.init(frame: CGRect.zero) } public override convenience init(frame: CGRect) { self.init(internal: nil) self.frame = frame } public required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) commonInit() } fileprivate func commonInit() { } } fileprivate protocol _CustomView { } extension CustomView: _CustomView { } fileprivate extension _CustomView { init(internal: Int?) { self = Bundle.main.loadNibNamed("CustomView", owner:nil, options:nil)![0] as! Self; } }
if let customView = Bundle.main.loadNibNamed("myXib", owner: self, options: nil)?.first as? CustomView { self.view.addSubview(customView) }
extension UIView { class func fromNib<T: UIView>() -> T { return Bundle.main.loadNibNamed(String(describing: T.self), owner: nil, options: nil)![0] as! T } }
struct defaultsKeys { static let keyOne = "firstStringKey" static let keyTwo = "secondStringKey" }
let defaults = NSUserDefaults.standardUserDefaults() defaults.setObject("Some String Value", forKey: defaultsKeys.keyOne) defaults.setObject("Another String Value", forKey: defaultsKeys.keyTwo) let defaults = NSUserDefaults.standardUserDefaults() if let stringOne = defaults.stringForKey(defaultsKeys.keyOne) { print(stringOne) } if let stringTwo = defaults.stringForKey(defaultsKeys.keyTwo) { print(stringTwo) }
let defaults = UserDefaults.standard defaults.set("Some String Value", forKey: defaultsKeys.keyOne) defaults.set("Another String Value", forKey: defaultsKeys.keyTwo) let defaults = UserDefaults.standard if let stringOne = defaults.string(forKey: defaultsKeys.keyOne) { print(stringOne) } if let stringTwo = defaults.string(forKey: defaultsKeys.keyTwo) { print(stringTwo) }
let defaults = NSUserDefaults.standardUserDefaults() defaults.setObject("theGreatestName", forKey: "username") if let name = defaults.stringForKey("username") { print(name) }
UserDefaults.standard.setValue(token, forKey: "user_auth_token") print("\(UserDefaults.standard.value(forKey: "user_auth_token")!)")
let authtoken = "12345" let defaults = UserDefaults.standard defaults.set(authtoken, forKey: "authtoken") defaults.synchronize()
if UserDefaults.standard.string(forKey: "authtoken") != nil {
let mutableData: NSMutableData = NSMutableData() let archiver: NSKeyedArchiver = NSKeyedArchiver(forWritingWith: mutableData) archiver.encode(object, forKey: key) archiver.finishEncoding() return mutableData.write(toFile: path, atomically: true) if let data = try? Data(contentsOf: URL(fileURLWithPath: path)) { let unarchiver = NSKeyedUnarchiver(forReadingWith: data) let object = unarchiver.decodeObject(forKey: key) }
let defaults = UserDefaults.standard defaults.set(passwordTextField.text, forKey: "Password") let myPassword = defaults.string(forKey: "Password")
tell application "Terminal" do script "rm -frd ~/Library/Developer/Xcode/DerivedData/*" do script "rm -frd ~/Library/Caches/com.apple.dt.Xcode/*" end tell
alias xcodeclean="rm -frd ~/Library/Developer/Xcode/DerivedData/* && rm -frd ~/Library/Caches/com.apple.dt.Xcode/*"
var str = "This" + String(myArray.count) + " is " + String(someVar)
let fullPath = "\(NSHomeDirectory())/Library/Preferences/com.apple.spaces.plist" let spacesData = NSDictionary(contentsOfFile: fullPath )! let spaces : AnyObject = spacesData["SpacesDisplayConfiguration"]!["Management Data"]!!["Monitors"]!![0]["Spaces"]!! println ( spaces )
func getSpacesDataFromPlist() -> Array<Dictionary<String, AnyObject>> { let fullPath = "\(NSHomeDirectory())/Library/Preferences/com.apple.spaces.plist" let spacesData = NSDictionary(contentsOfFile: fullPath )! as Dictionary<String, AnyObject> let sdconfig = spacesData["SpacesDisplayConfiguration"] as Dictionary<String, AnyObject> let mandata = sdconfig["Management Data"] as Dictionary<String, AnyObject> let monitors = mandata["Monitors"] as Array<Dictionary<String, AnyObject>> let monitor = monitors[0] as Dictionary<String, AnyObject> let spaces = monitor["Spaces"] as Array<Dictionary<String, AnyObject>> return spaces } func awakeFromNib() { .... ... typing here ... let spaces = self.getSpacesDataFromPlist() println( spaces) }
let r1 = a <&&> b let r2 = r1 <&&> c let r3 = r2 <||> d
if someVar < 0 { } else if someVar == 0 { } else if someVar > 0 { }
var someVar = 3 switch someVar { case let x where x < 0: print("x is \(x)") case let x where x == 0: print("x is \(x)") case let x where x > 0: print("x is \(x)") default: print("this is impossible") }
switch someVar { case _ where someVar < 0: print("someVar is \(someVar)") case 0: print("someVar is 0") case _ where someVar > 0: print("someVar is \(someVar)") default: print("this is impossible") }
switch someVar { case Int.min..<0: print("someVar is \(someVar)") case 0: print("someVar is 0") default: print("someVar is \(someVar)") }
let value = 1 switch value { case 1...: print("greater than zero") case 0: print("zero") case ..<0: print("less than zero") default: fatalError() }
let value = 1 switch value { case 1 ... Int.max: print("greater than zero") case Int.min ..< 0: print("less than zero") case 0: print("zero") default: fatalError() }
let value = 1 switch value { case let val where val > 0: print("\(val) is greater than zero") case let val where val == 0: print("\(val) is zero") case let val where val < 0: print("\(val) is less than zero") default: fatalError() }
let value = 1 switch value { case _ where value > 0: print("greater than zero") case _ where value == 0: print("zero") case _ where value < 0: print("less than zero") default: fatalError() }
let value = 1 switch true { case 1... ~= value: print("greater than zero") case ..<0 ~= value: print("less than zero") default: print("zero") }
let value = 1 switch true { case value > 0: print("greater than zero") case value < 0: print("less than zero") case 0 ~= value: print("zero") default: fatalError() }
let value = 1 switch true { case (1...).contains(value): print("greater than zero") case (..<0).contains(value): print("less than zero") default: print("zero") }
let x = 2 switch x { case 1: print(1) case 2: print(2) case 3..<5: print(3..<5) default: break }
if 1 ~= x { print(1) } else if 2 ~= x { print(2) } else if 3..<5 ~= x { print(3..<5) } else { }
func ~= <T> (lhs: T -> Bool, rhs: T) -> Bool { return lhs(rhs) }
func isEven(n: Int) -> Bool { return n % 2 == 0 } switch 2 { case isEven: print("Even!") default: print("Odd!") }
switch someVar { case isNegative: ... case 0: ... case isPositive: ... }
postfix operator < {} postfix func < <T : Comparable>(lhs: T)(_ rhs: T) -> Bool { return lhs < rhs }
let isGreaterThanFive = 5< isGreaterThanFive(6) isGreaterThanFive(5)
switch someVar { case 0< : print("Bigger than 0") case 0 : print("0") default : print("Less than 0") }
switch x { case lessThan(someNumber): case someNumber: case greaterThan(someNumber): }
switch true { case someVar < 0: print("less than zero") case someVar == 0: print("eq 0") default: print("otherwise") }
switch someVar{ case Int.min...0: case 0: default: }
switch average { case 0..<40: return "T" case 40..<55: return "D" case 55..<70: return "P" case 70..<80: return "A" case 80..<90: return "E" case 90...100: return "O" default: return "Z" }
switch someVar { case 0: case 0 ..< .greatestFiniteMagnitude: default: }
switch translation.x { case 0..<200: print(translation.x, slideLimit) case -200..<0: print(translation.x, slideLimit) default: break }
class Movie { let name: String var date: Int? init(_ name: String) { self.name = name } } var movieA = Movie("A") var movieB = Movie("B") var movieC = Movie("C") let movies = [movieB, movieC, movieA] let sortedMovies = movies.sorted { $0.name < $1.name } sortedMovies
import Foundation class Movie: CustomStringConvertible { let name: String var date: Date var description: String { return name } init(name: String, date: Date = Date()) { self.name = name self.date = date } }
let avatarMovie = Movie(name: "Avatar") let titanicMovie = Movie(name: "Titanic") let piranhaMovie = Movie(name: "Piranha II: The Spawning") let movies = [avatarMovie, titanicMovie, piranhaMovie] let sortedMovies = movies.sorted(by: { $0.name < $1.name }) print(sortedMovies)
import Foundation class Movie: CustomStringConvertible, Comparable { let name: String var date: Date var description: String { return name } init(name: String, date: Date = Date()) { self.name = name self.date = date } static func ==(lhs: Movie, rhs: Movie) -> Bool { return lhs.name == rhs.name } static func <(lhs: Movie, rhs: Movie) -> Bool { return lhs.name < rhs.name } }
let avatarMovie = Movie(name: "Avatar") let titanicMovie = Movie(name: "Titanic") let piranhaMovie = Movie(name: "Piranha II: The Spawning") let movies = [avatarMovie, titanicMovie, piranhaMovie] let sortedMovies = movies.sorted(by: { $0 < $1 }) print(sortedMovies)
import Foundation class Movie: CustomStringConvertible, Comparable { let name: String var date: Date var description: String { return name } init(name: String, date: Date = Date()) { self.name = name self.date = date } static func ==(lhs: Movie, rhs: Movie) -> Bool { return lhs.name == rhs.name } static func <(lhs: Movie, rhs: Movie) -> Bool { return lhs.name < rhs.name } }
let avatarMovie = Movie(name: "Avatar") let titanicMovie = Movie(name: "Titanic") let piranhaMovie = Movie(name: "Piranha II: The Spawning") let movies = [avatarMovie, titanicMovie, piranhaMovie] let sortedMovies = movies.sorted() print(sortedMovies)
let sortArray = array.sorted(by: { $0.name.lowercased() < $1.name.lowercased() })
class Fruit { var name="Apple" } reflect(Fruit()).count reflect(Fruit())[0].0 reflect(Fruit())[0].1.summary
var clazz = TestObject.self var instance: TestObject = clazz() var type = instance.dynamicType println("Type: \(type)")
var clazz: NSObject.Type = TestObject.self var instance : NSObject = clazz() if let testObject = instance as? TestObject { println("yes!") }
import Foundation class PureSwiftClass { } var myvar0 = NSString() var myvar1 = PureSwiftClass() var myvar2 = 42 var myvar3 = "Hans" println( "TypeName0 = \(_stdlib_getTypeName(myvar0))") println( "TypeName1 = \(_stdlib_getTypeName(myvar1))") println( "TypeName2 = \(_stdlib_getTypeName(myvar2))") println( "TypeName3 = \(_stdlib_getTypeName(myvar3))")
TypeName0 = NSString TypeName1 = _TtC13__lldb_expr_014PureSwiftClass TypeName2 = _TtSi TypeName3 = _TtSS
let someString = "You can also pass a string variable, like this!" yourArray.append(someString)
let lineCutter = "I let positionToInsertAt = 0 yourArray.insert(lineCutter, atIndex: positionToInsertAt)
var yourOtherArray = ["MonkeysRule", "RemoveMe", "SwiftRules"] yourOtherArray.removeAtIndex(1)
if let indexValue = yourOtherArray.indexOf("RemoveMe") { yourOtherArray.removeAtIndex(indexValue) }
var myDoubles = [Double](count: 5, repeatedValue: 2.0)
let emptyArray = [String]() let emptyDouble: [Double] = [] let preLoadArray = Array(repeating: 0, count: 10) let arrayMix = [1, "two", 3] as [Any] var arrayNum = [1, 2, 3] var array = ["1", "two", "3"] array[1] = "2" array.append("4") array += ["5", "6"] array.insert("0", at: 0) array[0] = "Zero" array.insert(contentsOf: ["-3", "-2", "-1"], at: 0) array.remove(at: 0) array.removeLast() array = ["Replaces all indexes with this"] array.removeAll() for item in arrayMix { print(item) } for (index, element) in array.enumerated() { print(index) print(element) } for (index, _) in arrayNum.enumerated().reversed() { arrayNum.remove(at: index) } let words = "these words will be objects in an array".components(separatedBy: " ") print(words[1]) var names = ["Jemima", "Peter", "David", "Kelly", "Isabella", "Adam"] names.sort() let nums = [1, 1234, 12, 123, 0, 999] print(nums.sorted())
if groceryList.isEmpty { print("The groceryList list is empty.") } else { print("The groceryList is not empty.") }
groceryList += ["Chocolate Spread", "Cheese", "Peanut Butter"]
var array = [String]() print(array) array.append("MY NAME") print(array) array.removeFirst() print(array) array.append("MY NAME") array.removeLast() array.append("MY NAME1") array.append("MY NAME2") print(array) array.removeAll() print(array)
var myArray: Array<String> = Array() var myArray = [String]() var myArray: [String] = [] var myArray = Array<String>() var myArray:Array<String> = []
var myArray: Array<AnyObject> = Array() var myArray = [AnyObject]() var myArray: [AnyObject] = [] var myArray = Array<AnyObject>() var myArray:Array<AnyObject> = []
var myArray: Array<Int> = Array() var myArray = [Int]() var myArray: [Int] = [] var myArray = Array<Int>() var myArray:Array<Int> = []
protocol SomeProtocol { } protocol SomeOtherProtocol { }
func bothFunc<T: SomeProtocol | SomeOtherProtocol>(arg: T) { }
<T: SomeProtocol | SomeOtherProtocol> <T: SomeProtocol , SomeOtherProtocol> <T: SomeProtocol : SomeOtherProtocol>
func someFunc<T where T:SomeProtocol, T:SomeOtherProtocol>(arg: T) { }
func someFunc<T: SomeProtocol & SomeOtherProtocol>(arg: T) { }
func someFunc<T>(arg: T) where T:SomeProtocol, T:SomeOtherProtocol{ }
func someFunc<T where T : SomeProtocol, T : SomeOtherProtocol>(arg: T) { }
func someFunc<T : protocol<SomeProtocol, SomeOtherProtocol>>(arg: T) { }
func someFunc<T>(arg: T) where T:SomeProtocol, T:SomeOtherProtocol { }
func someFunc<T:SomeProtocol & SomeOtherProtocol>(arg: T) { }
protocol SomeProtocol { } protocol SomeOtherProtocol { }
func someFunc<T: SomeProtocol & SomeOtherProtocol>(arg: T) { }
func someFunc<T>(arg: T) where T: SomeProtocol, T: SomeOtherProtocol { }
func someFunc<T>(arg: T) where T: SomeProtocol & SomeOtherProtocol { }
typealias RequiredProtocols = SomeProtocol & SomeOtherProtocol func someFunc<T: RequiredProtocols>(arg: T) { }
func getTime() -> Int { let date = NSDate() let calendar = NSCalendar.currentCalendar() let components = calendar.components(.CalendarUnitHour | .CalendarUnitMinute | .CalendarUnitSecond, fromDate: date) let hour = components.hour let minute = components.minute let second = components.second let times:String = ("\(hour):\(minute):\(second)") return hour, minute, second }
func getTime() -> (Int, Int, Int) { ... return ( hour, minute, second) }
func getTime() -> (hour: Int, minute: Int,second: Int) { let hour = 1 let minute = 2 let second = 3 return ( hour, minute, second) }
let time = getTime() print("hour: \(time.hour), minute: \(time.minute), second: \(time.second)")
let time = getTime() print("hour: \(time.0), minute: \(time.1), second: \(time.2)")
func getTime()-> (hour:Int,min:Int,sec:Int){ return (hour,min,sec) }
print("hour:\(getTime.hour) min:\(getTime.min) sec:\(getTime.sec)")
func getTime() -> (hour: Int, minute: Int,second: Int) { let hour = 1 let minute = 20 let second = 55 return (hour, minute, second) }
let(hour, min,sec) = self.getTime() print(hour,min,sec)
struct ValidateOTP { var code: String var isValid: Bool } func validateTheOTP() -> ValidateOTP { let otpCode = String(format: "%@%@", txtOtpField1.text!, txtOtpField2.text!) if otpCode.length < 2 { return ValidateOTP(code: otpCode, isValid: false) } else { return ValidateOTP(code: otpCode, isValid: true) } }
let isValidOTP = validateTheOTP() if isValidOTP.isValid { print(" valid OTP") } else { self.alert(msg: "Please fill the valid OTP", buttons: ["Ok"], handler: nil) }
import UIKit func weather_diff(country1:String,temp1:Double,country2:String,temp2:Double)->(c1:String,c2:String,diff:Double) { let c1 = country1 let c2 = country2 let diff = temp1 - temp2 return(c1,c2,diff) } let result = weather_diff(country1: "India", temp1: 45.5, country2: "Canada", temp2: 18.5) print("Weather difference between \(result.c1) and \(result.c2) is \(result.diff)")
sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift
GoldCoast:~ macmark$ swift Welcome to Swift! Type :help for assistance. 1> println("Hello, world") Hello, world 2> var myVariable = 42 myVariable: Int = 42 3> myVariable = 50 4> let myConstant = 42 myConstant: Int = 42 5> println(myVariable) 50 6> let label = "The width is " label: String = "The width is " 7> let width = 94 width: Int = 94 8> let widthLabel = label + String(width) widthLabel: String = "The width is 94" 9> :exit GoldCoast:~ macmark$
let variable: String = "string" print("Test \(variable)")
sudo xcode-select -s /Applications/Xcode7.app/ xcrun --sdk macosx swift
set xcode6Path to "xcode-select -switch /Applications/Xcode6-Beta.app/Contents/Developer" set xcodeDefaultPath to "xcode-select -switch /Applications/Xcode.app/Contents/Developer" display dialog "set xcode sdk path to " buttons {"xcode 6", "default"} default button 1 copy result as list to {buttonPressed} if buttonPressed is "default" then try do shell script xcodeDefaultPath with administrator privileges end try else try do shell script xcode6Path with administrator privileges end try end if
/usr/bin/env DEVELOPER_DIR=/Applications/Xcode6-Beta.app/Contents/Developer xcrun swift
alias swift="/usr/bin/env DEVELOPER_DIR=/Applications/Xcode6-Beta.app/Contents/Developer xcrun swift"
sudo xcode-select -s /Applications Contents/Developer xcrun swift
$ sudo xcode-select -s /Applications/Xcode.app/Contents/Developer/ $ xcrun swift
xcrun swift -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk
class BaseClass { func abstractFunction() { } } class SubClass : BaseClass { override func abstractFunction() { } }
class BaseClass { func abstractFunction() { preconditionFailure("This method must be overridden") } } class SubClass : BaseClass { override func abstractFunction() { } }
protocol MyProtocol { func abstractFunction() } class MyClass : MyProtocol { func abstractFunction() { } }
class MyClass : BaseClass, MyProtocol { func abstractFunction() { } }
protocol Thing { func sharedFunction() func abstractFunction() } class BaseThing { func sharedFunction() { println("All classes share this implementation") } }
class DerivedThing : BaseThing, Thing { func abstractFunction() { println("Derived classes implement this"); } }
class BaseThing { func sharedFunction(thing: Thing) { println("All classes share this implementation") thing.abstractFunction() } } class DerivedThing : BaseThing, Thing { func sharedFunction() { super.sharedFunction(self) } func abstractFunction() { println("Derived classes implement this"); } }
protocol AbstractMethodsForClassX { func abstractMethod() -> String }
class BaseClassX { var delegate: AbstractMethodsForClassX! func doSomethingWithAbstractMethod() -> String { return delegate.abstractMethod() + " - And I believe it" } }
class ClassX: BaseClassX, AbstractMethodsForClassX { override init() { super.init() delegate = self } func abstractMethod() -> String {return "Yes, this works!"} }
class BaseClass { var abstractClosure?:(()->())? func someFunc() { if let abstractClosure=abstractClosure { abstractClosure() } } } class SubClass : BaseClass { init() { super.init() abstractClosure={ ..... } } }
class SubClass : BaseProtocol { func abstractFunction() { println("Override") } }
class SubClass: SuperClass, ProtocolOne, ProtocolTwo {}
protocol BaseAbstraction { func abstractFunction() { } } extension BaseAbstraction { func definedFunction() { print("Hello") } class SubClass : BaseAbstraction { func abstractFunction() { } }
class Abstract { func doWork() { assert(false, "This method must be overriden by the subclass") } } class Concrete : Abstract { override func doWork() { println("Did some work!") } } let abstract = Abstract() let concrete = Concrete() abstract.doWork() concrete.doWork()
class AbstractMethodException : NSException { init() { super.init( name: "Called an abstract method", reason: "All abstract methods must be overriden by subclasses", userInfo: nil ); } }
class BaseClass { func abstractFunction() { AbstractMethodException.raise(); } }
import SpriteKit public protocol InheritedAnimal { func walkSpriteNames() -> [String] func runSpriteNames() -> [String] } public class Animal: SKNode { private let inheritedAnimal: InheritedAnimal public init(inheritedAnimal: InheritedAnimal) { self.inheritedAnimal = inheritedAnimal super.init() } public required init?(coder aDecoder: NSCoder) { fatalError("NSCoding not supported") } public func walk() { let sprites = inheritedAnimal.walkSpriteNames() } public func run() { let sprites = inheritedAnimal.runSpriteNames() } } public class SheepAnimal: Animal { public required init?(coder aDecoder: NSCoder) { fatalError("NSCoding not supported") } public required init() { super.init(inheritedAnimal: InheritedAnimalImpl()) } private class InheritedAnimalImpl: InheritedAnimal { init() {} func walkSpriteNames() -> [String] { return ["sheep_step_01", "sheep_step_02", "sheep_step_03", "sheep_step_04"] } func runSpriteNames() -> [String] { return ["sheep_run_01", "sheep_run_02"] } } }
var popover: UIPopoverController? = nil func addCategory() { var newCategory = storyboard.instantiateViewControllerWithIdentifier("NewCategory") as UIViewController var nav = UINavigationController(rootViewController: newCategory) popover = UIPopoverController(contentViewController: nav) popover!.setPopoverContentSize(CGSizeMake(550, 600), animated: true) popover!.delegate = self popover!.presentPopoverFromBarButtonItem(self.navigationItem.rightBarButtonItem, permittedArrowDirections: UIPopoverArrowDirection.Any, animated: true) }
func addCategory() { var popoverContent = self.storyboard.instantiateViewControllerWithIdentifier("NewCategory") as UIViewController var nav = UINavigationController(rootViewController: popoverContent) nav.modalPresentationStyle = UIModalPresentationStyle.Popover var popover = nav.popoverPresentationController as UIPopoverPresentationController popover.delegate = self popover.popoverContentSize = CGSizeMake(1000, 300) popover.sourceView = self.view popover.sourceRect = CGRectMake(100,100,0,0) self.presentViewController(nav, animated: true, completion: nil) }
func addCategory() { var popoverContent = self.storyboard?.instantiateViewControllerWithIdentifier("NewCategory") as UIViewController var nav = UINavigationController(rootViewController: popoverContent) nav.modalPresentationStyle = UIModalPresentationStyle.Popover var popover = nav.popoverPresentationController popoverContent.preferredContentSize = CGSizeMake(500,600) popover.delegate = self popover.sourceView = self.view popover.sourceRect = CGRectMake(100,100,0,0) self.presentViewController(nav, animated: true, completion: nil) }
func popoverPresentationControllerDidDismissPopover(popoverPresentationController: UIPopoverPresentationController) { }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == "yourSegueIdentifierForPopOver" { if let controller = segue.destinationViewController as? UIViewController { controller.popoverPresentationController!.delegate = self controller.preferredContentSize = CGSize(width: 320, height: 186) } } }
func adaptivePresentationStyle(for controller: UIPresentationController) -> UIModalPresentationStyle { return UIModalPresentationStyle.none }
func adaptivePresentationStyleForPresentationController(PC: UIPresentationController!) -> UIModalPresentationStyle { return .None }
nav.popoverPresentationController!.delegate = implOfUIAPCDelegate
import UIKit class PopOverViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() self.preferredContentSize = CGSizeMake(200, 200) self.navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Done, target: self, action: "dismiss:") } func dismiss(sender: AnyObject) { self.dismissViewControllerAnimated(true, completion: nil) } }
import UIKit class ViewController: UIViewController, UIPopoverPresentationControllerDelegate { func showPopover(base: UIView) { if let viewController = self.storyboard?.instantiateViewControllerWithIdentifier("popover") as? PopOverViewController { let navController = UINavigationController(rootViewController: viewController) navController.modalPresentationStyle = .Popover if let pctrl = navController.popoverPresentationController { pctrl.delegate = self pctrl.sourceView = base pctrl.sourceRect = base.bounds self.presentViewController(navController, animated: true, completion: nil) } } } override func viewDidLoad(){ super.viewDidLoad() } @IBAction func onShow(sender: UIButton) { self.showPopover(sender) } func adaptivePresentationStyleForPresentationController(controller: UIPresentationController) -> UIModalPresentationStyle { return .None } }
- (IBAction)onclickPopover:(id)sender { UIStoryboard *sb = [UIStoryboard storyboardWithName:@"Main" bundle:[NSBundle mainBundle]]; UIViewController *viewController = [sb instantiateViewControllerWithIdentifier:@"popover"]; viewController.modalPresentationStyle = UIModalPresentationPopover; viewController.popoverPresentationController.sourceView = self.popOverBtn; viewController.popoverPresentationController.sourceRect = self.popOverBtn.bounds; viewController.popoverPresentationController.permittedArrowDirections = UIPopoverArrowDirectionAny; [self presentViewController:viewController animated:YES completion:nil]; }
-(void) popoverstart { ViewController *controller = [self.storyboard instantiateViewControllerWithIdentifier:@"PopoverView"]; UINavigationController *nav = [[UINavigationController alloc]initWithRootViewController:controller]; nav.modalPresentationStyle = UIModalPresentationPopover; UIPopoverPresentationController *popover = nav.popoverPresentationController; controller.preferredContentSize = CGSizeMake(300, 200); popover.delegate = self; popover.sourceView = self.view; popover.sourceRect = CGRectMake(100, 100, 0, 0); popover.permittedArrowDirections = UIPopoverArrowDirectionAny; [self presentViewController:nav animated:YES completion:nil]; } -(UIModalPresentationStyle) adaptivePresentationStyleForPresentationController: (UIPresentationController * ) controller { return UIModalPresentationNone; }
-(void) presentPopover { YourViewController* popoverContent = [[YourViewController alloc] init]; UINavigationController* nav = [[UINavigationController alloc] initWithRootViewController:popoverContent]; nav.modalPresentationStyle = UIModalPresentationPopover; UIPopoverPresentationController* popover = nav.popoverPresentationController; popoverContent.preferredContentSize = CGSizeMake(500,600); popover.delegate = self; popover.sourceRect = CGRectMake(100,100,0,0); [self presentViewController:nav animated:YES completion:nil]; }
func adaptivePresentationStyle(for controller: UIPresentationController, traitCollection: UITraitCollection) -> UIModalPresentationStyle{ return .none }
class ViewController: UIViewController, UIPopoverPresentationControllerDelegate { override func viewDidLoad(){ super.viewDidLoad() let when = DispatchTime.now() + 0.5 DispatchQueue.main.asyncAfter(deadline: when, execute: { () -> Void in self.showPopover(base: self.view) }) } func showPopover(base: UIView) { if let viewController = self.storyboard?.instantiateViewController(withIdentifier: "popover") as? PopOverViewController { let navController = UINavigationController(rootViewController: viewController) navController.modalPresentationStyle = .popover if let pctrl = navController.popoverPresentationController { pctrl.delegate = self pctrl.sourceView = base pctrl.sourceRect = base.bounds self.present(navController, animated: true, completion: nil) } } } @IBAction func onShow(sender: UIButton){ self.showPopover(base: sender) } func adaptivePresentationStyle(for controller: UIPresentationController, traitCollection: UITraitCollection) -> UIModalPresentationStyle{ return .none }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if let tvc = segue.destination as? TextViewController { if let ppc = tvc.popoverPresentationController { ppc.delegate = self } let returnStatsStr: NSMutableAttributedString = createStats() let myCreatedAttributedMutableString = NSMutableAttributedString.init() myCreatedAttributedMutableString.append(returnStatsStr) tvc.operations = myCreatedAttributedMutableString tvc.preferredContentSize = CGSizeFromString(String(describing: myCreatedAttributedMutableString)) } }
public func getQuestionList(var language: String) -> NSArray { if self.data.count > 0 { if (language.isEmpty) { language = "NL" } return self.data.objectForKey("questionList" + language) as! NSArray } return NSArray() }
public func getQuestionList(language: String) -> NSArray { var lang = language if self.data.count > 0 { if (lang.isEmpty) { lang = "NL" } return self.data.objectForKey("questionList" + lang) as! NSArray } return NSArray() }
public func getQuestionList(language: String) -> NSArray { var language = language if self.data.count > 0 { if (language.isEmpty) { language = "NL" } return self.data.objectForKey("questionList" + language) as! NSArray } return NSArray() }
public func getQuestionList(language language: String = "NL") -> NSArray { if data.count > 0 { return data.objectForKey("questionList" + language) as! NSArray } else { return NSArray() } }
public func getQuestionList(language: inout String) -> NSArray { if self.data.count > 0 { if (language.isEmpty) { language = "NL" } return self.data.objectForKey("questionList" + language) as! NSArray } return NSArray()
public func getQuestionList(language: String) -> NSArray { if self.data.count > 0 { return self.data.objectForKey("questionList" + (language.isEmpty ? "NL" : language)) as! NSArray } return NSArray() }
func swapTwoInts(_ a: inout Int, _ b: inout Int) { let temporaryA = a a = b b = temporaryA }
var someInt = 3 var anotherInt = 107 swapTwoInts(&someInt, &anotherInt) print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
private class StringBuilder { var buffer: [String] = [] func append(_ str: String) { buffer.append(str) } func toString() -> String { return buffer.joined() } }
private func writeMap(map: LevelMap, url: URL) -> Bool { let buffer = StringBuilder() if !writeHeader(map: map, buffer: buffer) { return false } if !writeFloors(map: map, buffer: buffer) { return false } let content = buffer.toString() do { try content.write(to: url, atomically: true, encoding: .utf8) return true } catch {} return false } private func writeHeader(map: LevelMap, buffer: StringBuilder) -> Bool { buffer.append("something here ...\n") return true }
public func getQuestionList(language: inout String) -> NSArray { if self.data.count > 0 { if (language.isEmpty) { language = "NL" } return self.data.objectForKey("questionList" + language) as! NSArray } return NSArray() } getQuestionList(language: &someString)
class Person { var name:String init(name: String) { self.name = name } init() { self.name = "John" } }
class Person { var name:String init(name: String) { self.name = name } convenience init() { self.init(name: "John") } }
class Foo { var a: Int init(a: Int) { self.a = a } }
class Bar: Foo { var b: Int init(a: Int, b: Int) { self.b = b super.init(a: a) } }
class Base { let a: Int let b: Int init(a: Int, b: Int) { self.a = a self.b = b } convenience init() { self.init(a: 0, b: 0) } convenience init(a: Int) { self.init(a: a, b: 0) } convenience init(b: Int) { self.init(a: 0, b: b) } }
class NonInheritor: Base { let c: Int init(a: Int, b: Int, c: Int) { self.c = c super.init(a: a, b: b) } }
class Inheritor: Base { let c: Int init(a: Int, b: Int, c: Int) { self.c = c super.init(a: a, b: b) } convenience override init(a: Int, b: Int) { self.init(a: a, b: b, c: 0) } }
convenience init(maleWithName: String) { self.init(name: name) gender = .Male } convenience init(femaleWithName: String) { self.init(name: name) gender = .Female }
class Person{ var name: String init(name: String){ self.name = name } convenience init(){ self.init(name: "Unknown") } } class Employee: Person{ var salary: Double init(name:String, salary:Double){ self.salary = salary super.init(name: name) } override convenience init(name: String) { self.init(name:name, salary: 0) } } let employee1 = Employee() let john = Employee(name: "John") let jane = Employee(name: "Jane", salary: 700)
let imageData: NSData = UIImagePNGRepresentation(myImage)
let profileImage = UIImage(named:"profile")! let imageData = profileImage.pngData()
let image = UIImagePNGRepresentation(imageView.image!) as NSData?
if let img = UIImage(named: "TestImage.png") { if let data:Data = UIImagePNGRepresentation(img) { } }
if let img = UIImage(named: "TestImage.png") { if let data:Data = UIImagePNGRepresentation(img) { handleOperationWithData(data: data) } else if let data:Data = UIImageJPEGRepresentation(img, 1.0) { handleOperationWithData(data: data) } } ******* func handleOperationWithData(data: Data) { if let image = UIImage(data: data) { } }
extension UIImage { var pngRepresentationData: Data? { return UIImagePNGRepresentation(self) } var jpegRepresentationData: Data? { return UIImageJPEGRepresentation(self, 1.0) } } ******* if let img = UIImage(named: "TestImage.png") { if let data = img.pngRepresentationData { handleOperationWithData(data: data) } else if let data = img.jpegRepresentationData { handleOperationWithData(data: data) } } ******* func handleOperationWithData(data: Data) { if let image = UIImage(data: data) { } }
if let img = UIImage(named: "xxx.png") { let pngdata = img.pngData() } if let img = UIImage(named: "xxx.jpeg") { let jpegdata = img.jpegData(compressionQuality: 1) }
import Cocoa let url = "https: if let url = NSURL(string: url) { if let data = try? Data(contentsOf: url as URL) { do { let parsedData = try JSONSerialization.jsonObject(with: data as Data, options: .allowFragments) let dict = parsedData as? NSDictionary let currentConditions = "\(dict!["currently"]!)" let currentTemperatureF = ("\(dict!["currently"]!["temperature"]!!)" as NSString).doubleValue print(currentConditions) print(currentTemperatureF) } catch let error as NSError { print("Details of JSON parsing error:\n \(error)") } } }
["icon": partly-cloudy-night, "precipProbability": 0, "pressure": 1015.39, "humidity": 0.75, "precipIntensity": 0, "windSpeed": 6.04, "summary": Partly Cloudy, "ozone": 321.13, "temperature": 49.45, "dewPoint": 41.75, "apparentTemperature": 47, "windBearing": 332, "cloudCover": 0.28, "time": 1480846460]
let urlString = "https: let url = URL(string: urlString) URLSession.shared.dataTask(with:url!) { (data, response, error) in if error != nil { print(error) } else { do { let parsedData = try JSONSerialization.jsonObject(with: data!) as! [String:Any] let currentConditions = parsedData["currently"] as! [String:Any] print(currentConditions) let currentTemperatureF = currentConditions["temperature"] as! Double print(currentTemperatureF) } catch let error as NSError { print(error) } } }.resume()
let currentConditions = parsedData["currently"] as! [String:Any] for (key, value) in currentConditions { print("\(key) - \(value) ") }
if let parsedData = try JSONSerialization.jsonObject(with: data!) as? [String:Any] { ...
if let foo = parsedData["foo"] as? OneOfSupportedJSONTypes { print(foo) }
if let parsedData = try JSONSerialization.jsonObject(with: data!) as? [[String:Any]] { ...
if let parsedData = try JSONSerialization.jsonObject(with: data!) as? [[String:Any]], parsedData.count > 2, let item = parsedData[2] as? OneOfSupportedJSONTypes { print(item) } }
if let parsedData = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) as? String { ...
let currentConditionsDictionary: [String: AnyObject] = dict!["currently"]! as! [String: AnyObject]
let currentTemperatureF = currentConditionsDictionary["temperature"] as! Double
let currentTemperatureF = (dict!["currently"]! as! [String: AnyObject])["temperature"]! as! Double
let parsedData = try JSONSerialization.jsonObject(with: data as Data, options: .allowFragments) as! Dictionary<String, AnyObject>
let str = "{\"names\": [\"Bob\", \"Tim\", \"Tina\"]}" let data = str.data(using: String.Encoding.utf8, allowLossyConversion: false)! do { let json = try JSONSerialization.jsonObject(with: data, options: []) as! [String: AnyObject] if let names = json["names"] as? [String] { print(names) } } catch let error as NSError { print("Failed to load: \(error.localizedDescription)") }
struct Forecast { let hourly: Hourly let daily: Daily let currently: Currently let flags: Flags let longitude: Double let latitude: Double let offset: Int let timezone: String } struct Hourly { let icon: String let data: [Currently] let summary: String } struct Daily { let icon: String let data: [Datum] let summary: String } struct Datum { let precipIntensityMax: Double let apparentTemperatureMinTime: Int let apparentTemperatureLowTime: Int let apparentTemperatureHighTime: Int let apparentTemperatureHigh: Double let apparentTemperatureLow: Double let apparentTemperatureMaxTime: Int let apparentTemperatureMax: Double let apparentTemperatureMin: Double let icon: String let dewPoint: Double let cloudCover: Double let humidity: Double let ozone: Double let moonPhase: Double let precipIntensity: Double let temperatureHigh: Double let pressure: Double let precipProbability: Double let precipIntensityMaxTime: Int let precipType: String? let sunriseTime: Int let summary: String let sunsetTime: Int let temperatureMax: Double let time: Int let temperatureLow: Double let temperatureHighTime: Int let temperatureLowTime: Int let temperatureMin: Double let temperatureMaxTime: Int let temperatureMinTime: Int let uvIndexTime: Int let windGust: Double let uvIndex: Int let windBearing: Int let windGustTime: Int let windSpeed: Double } struct Currently { let precipProbability: Double let humidity: Double let cloudCover: Double let apparentTemperature: Double let dewPoint: Double let ozone: Double let icon: String let precipIntensity: Double let temperature: Double let pressure: Double let precipType: String? let summary: String let uvIndex: Int let windGust: Double let time: Int let windBearing: Int let windSpeed: Double } struct Flags { let sources: [String] let isdStations: [String] let units: String }
let forecast = Forecast.from(json: jsonString)! print(forecast.daily.data[0].windGustTime)
import SystemConfiguration func loadingJSON(_ link:String, postString:String, completionHandler: @escaping (_ JSONObject: AnyObject) -> ()) { if(isConnectedToNetwork() == false){ completionHandler("-1" as AnyObject) return } let request = NSMutableURLRequest(url: URL(string: link)!) request.httpMethod = "POST" request.httpBody = postString.data(using: String.Encoding.utf8) let task = URLSession.shared.dataTask(with: request as URLRequest) { data, response, error in guard error == nil && data != nil else { print("error=\(error)") return } if let httpStatus = response as? HTTPURLResponse , httpStatus.statusCode != 200 { print("statusCode should be 200, but is \(httpStatus.statusCode)") print("response = \(response)") } do { let parseJSON = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) DispatchQueue.main.async(execute: { completionHandler(parseJSON as AnyObject) }); } catch let error as NSError { print("Failed to load: \(error.localizedDescription)") } } task.resume() } func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in(sin_len: 0, sin_family: 0, sin_port: 0, sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0)) zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) let defaultRouteReachability = withUnsafePointer(to: &zeroAddress) { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {zeroSockAddress in SCNetworkReachabilityCreateWithAddress(nil, zeroSockAddress) } } var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags(rawValue: 0) if SCNetworkReachabilityGetFlags(defaultRouteReachability!, &flags) == false { return false } let isReachable = (flags.rawValue & UInt32(kSCNetworkFlagsReachable)) != 0 let needsConnection = (flags.rawValue & UInt32(kSCNetworkFlagsConnectionRequired)) != 0 let ret = (isReachable && !needsConnection) return ret }
loadingJSON("yourDomain.com/login.php", postString:"email=\(userEmail!)&password=\(password!)") { parseJSON in if(String(describing: parseJSON) == "-1"){ print("No Internet") } else { if let loginSuccessfull = parseJSON["loginSuccessfull"] as? Bool { } }
let urlString = "https: let url = URL.init(string: urlString) URLSession.shared.dataTask(with:url!) { (data, response, error) in guard error == nil else { print(error) } do { let Data = try JSONSerialization.jsonObject(with: data!) as! [String:Any] let currentConditions = Data["currently"] as! [String:Any] print(currentConditions) let currentTemperatureF = currentConditions["temperature"] as! Double print(currentTemperatureF) } catch let error as NSError { print(error) } }.resume()
let json: Dictionary<String, Any>? = ["current": ["temperature": 10]]
public func curry<A, B, C>(_ f: @escaping (A, B) -> C) -> (A) -> (B) -> C { return { a in { f(a, $0) } } } public func extract<Key, Value>(_ key: Key, _ json: Dictionary<Key, Any>?) -> Value? { return json.flatMap { cast($0[key]) } } public func extract<Key, Value>(_ key: Key) -> (Dictionary<Key, Any>?) -> Value? { return curry(extract)(key) } precedencegroup RightApplyPrecedence { associativity: right higherThan: AssignmentPrecedence lowerThan: TernaryPrecedence } infix operator ¬ß : RightApplyPrecedence public func ¬ß<A, B>(_ f: (A) -> B, _ a: A) -> B { return f(a) } public func cast<A, B>(_ a: A) -> B? { return a as? B }
let temperature = (extract("temperature") ¬ß extract("current") ¬ß json) ?? NSNotFound
public struct CollectionTO { var index: Order var title: String var description: String }
var collection1 = CollectionTO(index: 1, title: "New Releases", description: "All the new releases")
public struct CollectionTO { var index: Order var title: String var description: String public init(index: Order, title: String, description: String) { self.index = index; self.title = title; self.description = description; } }
protocol Observing: Hashable { } var observers = HashSet<Observing>()
class GenericClass<T: Observing> { var observers = HashSet<T>() }
let someArray = [1, 2, 3, 4, 5, 6, 7] let first5 = someArray.prefix(5)
var wholeArray = [1, 2, 3, 4, 5, 6] var n = 5 var firstFive = wholeArray[0..<n]
let array = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"] let arraySlice = array[..<5] let newArray = Array(arraySlice) print(newArray)
let array = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"] let arraySlice = array.prefix(5) let newArray = Array(arraySlice) print(newArray)
let array = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"] let arraySlice = array.prefix(upTo: 5) let newArray = Array(arraySlice) print(newArray)
let array = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"] let arraySlice = array.prefix(through: 4) let newArray = Array(arraySlice) print(newArray)
var array = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"] array.removeSubrange(5...) print(array)
let array = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"] let distance = array.distance(from: 5, to: array.endIndex) let arraySlice = array.dropLast(distance) let newArray = Array(arraySlice) print(newArray)
let a: [Int] = [0, 0, 1, 1, 2, 2, 3, 3, 4] let b: [Int] = Array(a.prefix(5))
extension Array { func takeElements(var elementCount: Int) -> Array { if (elementCount > count) { elementCount = count } return Array(self[0..<elementCount]) } }
[0,1,2,3,4,5].enumerated().compactMap{ $0.offset < 3 ? $0.element : nil }
[0,1,2,3,4,5].enumerated().compactMap{ $0.offset < 1000 ? $0.element : nil }
[0,1,2,3,4,5].prefix(upTo: 1000) [0,1,2,3,4,5].prefix(1000)
extension Array { func takeElements(elementCount: Int) -> Array { if (elementCount > count) { return Array(self[0..<count]) } return Array(self[0..<elementCount]) } }
[0,1,2,3,4,5].enumerated().compactMap{ $0 < 10000 ? $1 : nil }
[0,1,2,3,4,5].enumerated().flatMap{ $0 < 10000 ? $1 : nil }
extension Array { func take(_ elementsCount: Int) -> [Element] { let min = Swift.min(elementsCount, count) return Array(self[0..<min]) } }
class MyClass: UIView { class func instanceFromNib() -> UIView { return UINib(nibName: "nib file name", bundle: nil).instantiateWithOwner(nil, options: nil)[0] as UIView } }
var view = MyClass.instanceFromNib() self.view.addSubview(view)
var view = MyClass.instanceFromNib self.view.addSubview(view())
class func instanceFromNib() -> UIView { return UINib(nibName: "nib file name", bundle: nil).instantiate(withOwner: nil, options: nil)[0] as! UIView }
import UIKit protocol UIViewLoading {} extension UIView : UIViewLoading {} extension UIViewLoading where Self : UIView { static func loadFromNib() -> Self { let nibName = "\(self)".characters.split{$0 == "."}.map(String.init).last! let nib = UINib(nibName: nibName, bundle: nil) return nib.instantiateWithOwner(self, options: nil).first as! Self } }
import UIKit @IBDesignable class NibLoadingView: UIView { @IBOutlet weak var view: UIView! override init(frame: CGRect) { super.init(frame: frame) nibSetup() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) nibSetup() } private func nibSetup() { backgroundColor = .clearColor() view = loadViewFromNib() view.frame = bounds view.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] view.translatesAutoresizingMaskIntoConstraints = true addSubview(view) } private func loadViewFromNib() -> UIView { let bundle = NSBundle(forClass: self.dynamicType) let nib = UINib(nibName: String(self.dynamicType), bundle: bundle) let nibView = nib.instantiateWithOwner(self, options: nil).first as! UIView return nibView } }
@IBDesignable class NibLoadingView: UIView { @IBOutlet weak var view: UIView! override init(frame: CGRect) { super.init(frame: frame) nibSetup() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) nibSetup() } private func nibSetup() { backgroundColor = .clear view = loadViewFromNib() view.frame = bounds view.autoresizingMask = [.flexibleWidth, .flexibleHeight] view.translatesAutoresizingMaskIntoConstraints = true addSubview(view) } private func loadViewFromNib() -> UIView { let bundle = Bundle(for: type(of: self)) let nib = UINib(nibName: String(describing: type(of: self)), bundle: bundle) let nibView = nib.instantiate(withOwner: self, options: nil).first as! UIView return nibView } }
let myView = Bundle.loadView(fromNib: "MyView", withType: MyView.self)
extension Bundle { static func loadView<T>(fromNib name: String, withType type: T.Type) -> T { if let view = Bundle.main.loadNibNamed(name, owner: nil, options: nil)?.first as? T { return view } fatalError("Could not load view with type " + String(describing: type)) } }
class MyClassView: UIView { @IBOutlet weak var myLabel: UILabel! class func createMyClassView() -> MyClass { let myClassNib = UINib(nibName: "MyClass", bundle: nil) return myClassNib.instantiate(withOwner: nil, options: nil)[0] as! MyClassView } }
let myClassView = MyClassView.createMyClassView() myClassView.myLabel.text = "Hello World!"
extension UIView { class func initFromNib<T: UIView>() -> T { return Bundle.main.loadNibNamed(String(describing: self), owner: nil, options: nil)?[0] as! T } }
class MyCustomView: UIView { @IBOutlet weak var messageLabel: UILabel! static func instantiate(message: String) -> MyCustomView { let view: MyCustomView = initFromNib() view.messageLabel.text = message return view } }
let view = MyCustomView.instantiate(message: "Hello World.")
override func draw(_ rect: CGRect) { AlertView.layer.cornerRadius = 4 AlertView.clipsToBounds = true btnOk.layer.cornerRadius = 4 btnOk.clipsToBounds = true } class func instanceFromNib() -> LAAlertView { return UINib(nibName: "LAAlertView", bundle: nil).instantiate(withOwner: nil, options: nil)[0] as! LAAlertView } @IBAction func okBtnDidClicked(_ sender: Any) { removeAlertViewFromWindow() UIView.animate(withDuration: 0.4, delay: 0.0, options: .allowAnimatedContent, animations: {() -> Void in self.AlertView.transform = CGAffineTransform(scaleX: 0.1, y: 0.1) }, completion: {(finished: Bool) -> Void in self.AlertView.transform = CGAffineTransform.identity self.AlertView.transform = CGAffineTransform(scaleX: 0.0, y: 0.0) self.AlertView.isHidden = true self.AlertView.alpha = 0.0 self.alpha = 0.5 }) } func removeAlertViewFromWindow() { for subview in (appDel.window?.subviews)! { if subview.tag == 500500{ subview.removeFromSuperview() } } } public func openAlertView(title:String , string : String ){ lblTital.text = title txtView.text = string self.frame = CGRect(x: 0, y: 0, width: screenWidth, height: screenHeight) appDel.window!.addSubview(self) AlertView.alpha = 1.0 AlertView.isHidden = false UIView.animate(withDuration: 0.2, animations: {() -> Void in self.alpha = 1.0 }) AlertView.transform = CGAffineTransform(scaleX: 0.0, y: 0.0) UIView.animate(withDuration: 0.3, delay: 0.2, options: .allowAnimatedContent, animations: {() -> Void in self.AlertView.transform = CGAffineTransform(scaleX: 1.1, y: 1.1) }, completion: {(finished: Bool) -> Void in UIView.animate(withDuration: 0.2, animations: {() -> Void in self.AlertView.transform = CGAffineTransform(scaleX: 1.0, y: 1.0) }) }) }
for i in 1..C_ARGC { let index = Int(i); let arg = String.fromCString(C_ARGV[index]) switch arg { case "this": println("this yo"); case "that": println("that yo") default: println("dunno bro") } }
for argument in CommandLine.arguments { switch argument { case "arg1": print("first argument") case "arg2": print("second argument") default: print("an argument") } }
var aFlag = 0 var bFlag = 0 var cValue = String() let pattern = "abc:" var buffer = Array(pattern.utf8).map { Int8($0) } while true { let option = Int(getopt(C_ARGC, C_ARGV, buffer)) if option == -1 { break } switch "\(UnicodeScalar(option))" { case "a": aFlag = 1 println("Option -a") case "b": bFlag = 1 println("Option -b") case "c": cValue = String.fromCString(optarg)! println("Option -c \(cValue)") case "?": let charOption = "\(UnicodeScalar(Int(optopt)))" if charOption == "c" { println("Option } else { println("Unknown option } exit(1) default: abort() } } println("aflag = for index in optind..<C_ARGC { println("Non-option argument }
override func viewDidLoad() { super.viewDidLoad() let myFirstLabel = UILabel() let myFirstButton = UIButton() myFirstLabel.text = "I made a label on the screen myFirstLabel.font = UIFont(name: "MarkerFelt-Thin", size: 45) myFirstLabel.textColor = UIColor.redColor() myFirstLabel.textAlignment = .Center myFirstLabel.numberOfLines = 5 myFirstLabel.frame = CGRectMake(15, 54, 300, 500) myFirstButton.setTitle("‚ú∏", forState: .Normal) myFirstButton.setTitleColor(UIColor.blueColor(), forState: .Normal) myFirstButton.frame = CGRectMake(15, -50, 300, 500) myFirstButton.addTarget(self, action: "pressed", forControlEvents: .TouchUpInside) self.view.addSubview(myFirstLabel) self.view.addSubview(myFirstButton) } func pressed(sender: UIButton!) { var alertView = UIAlertView(); alertView.addButtonWithTitle("Ok"); alertView.title = "title"; alertView.message = "message"; alertView.show(); }
override func viewDidLoad() { super.viewDidLoad() let myFirstLabel = UILabel() let myFirstButton = UIButton() myFirstLabel.text = "I made a label on the screen myFirstLabel.font = UIFont(name: "MarkerFelt-Thin", size: 45) myFirstLabel.textColor = UIColor.redColor() myFirstLabel.textAlignment = .Center myFirstLabel.numberOfLines = 5 myFirstLabel.frame = CGRectMake(15, 54, 300, 500) myFirstButton.setTitle("‚ú∏", forState: .Normal) myFirstButton.setTitleColor(UIColor.blueColor(), forState: .Normal) myFirstButton.frame = CGRectMake(15, -50, 300, 500) myFirstButton.addTarget(self, action: self.view.addSubview(myFirstLabel) self.view.addSubview(myFirstButton) } @objc func pressed(sender: UIButton!) { var alertView = UIAlertView() alertView.addButtonWithTitle("Ok") alertView.title = "title" alertView.message = "message" alertView.show() }
let button:UIButton = UIButton(frame: CGRectMake(100, 400, 100, 50)) button.backgroundColor = UIColor.blackColor() button.setTitle("Button", forState: UIControlState.Normal) button.addTarget(self, action: self.view.addSubview(button) func buttonClicked() { print("Button Clicked") }
let button:UIButton = UIButton(frame: CGRect(x: 100, y: 400, width: 100, height: 50)) button.backgroundColor = .black button.setTitle("Button", for: .normal) button.addTarget(self, action: self.view.addSubview(button) func buttonClicked() { print("Button Clicked") }
let button:UIButton = UIButton(frame: CGRect(x: 100, y: 400, width: 100, height: 50)) button.backgroundColor = .black button.setTitle("Button", for: .normal) button.addTarget(self, action: self.view.addSubview(button) @objc func buttonClicked() { print("Button Clicked") }
private func createButton { let sayButtonT = UIButton(type: .custom) sayButtonT.addTarget(self, action: } @objc private func sayAction(_ sender: UIButton?) { }
let buttonPuzzle:UIButton = UIButton(frame: CGRectMake(100, 400, 100, 50)) buttonPuzzle.backgroundColor = UIColor.greenColor() buttonPuzzle.setTitle("Puzzle", forState: UIControlState.Normal) buttonPuzzle.addTarget(self, action: "buttonAction:", forControlEvents: UIControlEvents.TouchUpInside) buttonPuzzle.tag = 22; self.view.addSubview(buttonPuzzle)
func buttonAction(sender:UIButton!) { var btnsendtag:UIButton = sender if btnsendtag.tag == 22 { } }
let button = UIButton(frame: CGRect(x: 20, y: 20, width: 200, height: 60)) button.setTitle("Email", for: .normal) button.backgroundColor = .white button.setTitleColor(UIColor.black, for: .normal) button.addTarget(self, action: myView.addSubview(button) func buttonTapped(sender : UIButton) { }
let myFirstButton = UIButton() myFirstButton.titleLabel!.text = "I made a label on the screen myFirstButton.titleLabel!.font = UIFont(name: "MarkerFelt-Thin", size: 45) myFirstButton.titleLabel!.textColor = UIColor.red myFirstButton.titleLabel!.textAlignment = .center myFirstButton.titleLabel!.numberOfLines = 5 myFirstButton.titleLabel!.frame = CGRect(x: 15, y: 54, width: 300, height: 500)
override func viewDidLoad() { super.viewDidLoad() let btn = UIButton() btn.frame = CGRectMake(10, 10, 50, 50) btn.setTitle("btn", forState: .Normal) btn.setTitleColor(UIColor.redColor(), forState: .Normal) btn.backgroundColor = UIColor.greenColor() btn.tag = 1 btn.addTarget(self, action: "btnclicked:", forControlEvents: .TouchUpInside) self.view.addSubview(btn) }
let button = UIButton() button.translatesAutoresizingMaskIntoConstraints = false button.target(forAction: view.addSubview(button) func buttonAction() { }
let button: UIButton = { let b = UIButton() b.translatesAutoresizingMaskIntoConstraints = false return b }()
func setupButtonView() { view.addSubview(button) button.widthAnchor.constraint(equalToConstant: 40).isActive = true button.heightAnchor.constraint(equalToConstant: 40).isActive = true }
let myButton = UIButton() myButton.titleLabel!.frame = CGRectMake(15, 54, 300, 500) myButton.titleLabel!.text = "Button Label" myButton.titleLabel!.textColor = UIColor.redColor() myButton.titleLabel!.textAlignment = .Center
var button: UIButton = UIButton(type: .Custom) button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0) button.addTarget(self, action: button.tag=2 button.setTitle("Hallo World", forState: .Normal) view.addSubview(button) func aMethod(sender: AnyObject) { print("you clicked on button \(sender.tag)") }
let button = UIButton(frame: CGRect(x: 0, y: 0, width: container.width, height: container.height)) button.addTarget(self, action: func barItemTapped(sender : UIButton) { }
extension UILabel { // func make(x: CGFloat, y: CGFloat, w: CGFloat, h: CGFloat, txt: String, align: NSTextAlignment, fnt: UIFont, fntColor: UIColor)-> UILabel { frame = CGRect(x: x, y: y, width: w, height: h) adjustsFontSizeToFitWidth = true textAlignment = align text = txt textColor = fntColor font = fnt return self } } extension UIButton { func make( x: CGFloat,y: CGFloat, w: CGFloat,h: CGFloat, title: String, backColor: UIColor, target: UIView, touchDown: Selector, touchUp: Selector ) -> UIButton { frame = CGRect(x: x, y: y, width: w, height: h) backgroundColor = backColor setTitle(title, for: .normal) addTarget(target, action: touchDown, for: .touchDown) addTarget(target, action: touchUp , for: .touchUpInside) addTarget(target, action: touchUp , for: .touchUpOutside) return self } }
import UIKit import MapKit class MapViewController: UIViewController { override func loadView() { mapView = MKMapView() view = mapView myButton = UIButton(type: .RoundedRect) myButton.setTitle("Current\nLocation", forState: .Normal) myButton.titleLabel?.lineBreakMode = .ByWordWrapping myButton.titleLabel?.textAlignment = .Center myButton.setTitleColor(UIColor.whiteColor(), forState: .Normal) myButton.layer.cornerRadius = 6 myButton.backgroundColor = UIColor.redColor().colorWithAlphaComponent(0.5) myButton.contentEdgeInsets = UIEdgeInsetsMake(5,5,5,5) myButton.addTarget(self, action: "getCurrentLocation:", forControlEvents: .TouchUpInside) mapView.addSubview(myButton) myButton.translatesAutoresizingMaskIntoConstraints = false let bottomButtonConstraint = myButton.bottomAnchor.constraintEqualToAnchor(bottomLayoutGuide.topAnchor, constant: -20) let margins = view.layoutMarginsGuide let leadingButtonConstraint = myButton.leadingAnchor.constraintEqualToAnchor(margins.leadingAnchor) bottomButtonConstraint.active = true leadingButtonConstraint.active = true } func getCurrentLocation(sender: UIButton) { print("Current Location button clicked!") }
import UIKit class ViewController: UIViewController { private let firstbutton:UIButton = UIButton() override func viewDidLoad() { super.viewDidLoad() self.firstbutton = UIButton.buttonWithType(UIButtonType.Custom) as? UIButton self.firstbutton!.frame = CGRectMake(100, 200, 100, 100) self.firstbutton!.backgroundColor = UIColor.redColor() self.firstbutton!.setTitle("My Button", forState: UIControlState.Normal) self.firstbutton!.addTarget(self, action: self.view.addSubview(firstbutton!) } func firstButtonClicked(){ print("First Button Clicked") }
UIButton *testButton = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [testButton setTitle:@"Go to here" forState:UIControlStateNormal]; testButton.frame = CGRectMake(20, 20, 150, 150); [self.view addSubview:testButton];
let testButton = UIButton(type: UIButtonType.system) as UIButton testButton.frame = CGRectMake(160, 160, 80, 20) testButton.backgroundColor = UIColor.green testButton.setTitle("Button testing:- ", forState: UIControlState.normal) self.view.addSubview(testButton)
let button = UIButton(type: .system) button.frame = CGRect(x: 100, y: 250, width: 100, height: 50) button.setTitle("Button", for: .normal) button.setTitleColor(.white, for: .normal) button.titleLabel?.font = UIFont.boldSystemFont(ofSize: 13.0) button.titleLabel?.textAlignment = .center button.titleLabel?.numberOfLines = 0 button.titleLabel?.lineBreakMode = .byWordWrapping button.tag = 1 button.btnProperties() button.addTarget(self, action: self.view.addSubview(button) let button2 = UIButton(type: .custom) button2.frame = CGRect(x: 100, y: 400, width: 100, height: 50) button2.setImage(UIImage.init(named: "img.png"), for: .normal) button2.tag = 2 button2.btnProperties() button2.addTarget(self, action: self.view.addSubview(button2) @objc func buttonClicked(sender:UIButton) { print("Button \(sender.tag) clicked") } extension UIButton { func btnProperties() { layer.cornerRadius = 10 clipsToBounds = true backgroundColor = .blue } }
let button: UIButton = { let button = UIButton(type: .system) button.titleLabel?.font = UIFont.systemFont(ofSize: 20) ... return button }()
let bundle = NSBundle(forClass:object_getClass(self))
let bundle = NSBundle(forClass: self.dynamicType) let nib = UINib(nibName: "CellForAlert", bundle: bundle) let view = nib.instantiateWithOwner(self, options: nil).first as! UIView view.frame = bounds view.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] self.addSubview(view);
func kZWGetBundle() -> Bundle{ return Bundle(for: AnyClass.self as! AnyClass) }
Alamofire.request(.POST, "MY URL", parameters:parameters, encoding: .JSON) .responseJSON { (request, response, JSON, error) in println(JSON?) }
Alamofire.request(.POST, url, parameters: parameters, encoding:.JSON).responseJSON { response in switch response.result { case .Success(let JSON): print("Success with JSON: \(JSON)") let response = JSON as! NSDictionary let userId = response.objectForKey("id")! case .Failure(let error): print("Request failed with error: \(error)") } }
Alamofire.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default) .responseJSON { response in print(response) if let status = response.response?.statusCode { switch(status){ case 201: print("example success") default: print("error with response status: \(status)") } } if let result = response.result.value { let JSON = result as! NSDictionary print(JSON) } }
Alamofire.request(.POST, "MY URL", parameters:parameters, encoding: .JSON) .responseJSON { (request, response, data, error) in var json = JSON(data: data!) println(json) println(json["productList"][1]) }
{ "productList" :[ {"productName" : "PIZZA","id" : "1","productRate" : "120.00","productDescription" : "PIZZA AT 120Rs","productImage" : "uploads\/pizza.jpeg"}, {"productName" : "BURGER","id" : "2","productRate" : "100.00","productDescription" : "BURGER AT Rs 100","productImage" : "uploads/Burgers.jpg"} ] }
{ "productName" : "BURGER", "id" : "2", "productRate" : "100.00", "productDescription" : "BURGER AT Rs 100", "productImage" : "uploads/Burgers.jpg" }
Alamofire.request(.GET, URLString, parameters: ["foo": "bar"]) .responseJSON { request, response, result in switch result { case .Success(let JSON): print("Success with JSON: \(JSON)") case .Failure(let data, let error): print("Request failed with error: \(error)") if let data = data { print("Response data: \(NSString(data: data, encoding: NSUTF8StringEncoding)!)") } } }
Alamofire.request(url, method: .get) .responseJSON { response in if response.data != nil { let json = JSON(data: response.data!) let name = json["people"][0]["name"].string if name != nil { print(name!) } } }
func getServerCourseVersion(){ Alamofire.request(.GET,"\(PUBLIC_URL)/vtcver.php") .responseJSON { (_,_, JSON, _) in if let jsonResult = JSON as? Array<Dictionary<String,String>> { let courseName = jsonResult[0]["courseName"] let courseVersion = jsonResult[0]["courseVersion"] let courseZipFile = jsonResult[0]["courseZipFile"] println("JSON: courseName: \(courseName)") println("JSON: courseVersion: \(courseVersion)") println("JSON: courseZipFile: \(courseZipFile)") } } }
[{"courseName": "Training Title","courseVersion": "1.01","courseZipFile": "101/files.zip"}]
pod pod File json format: { "codeAd": { "dateExpire": "2017/12/11", "codeRemoveAd":"1231243134" } } import Alamofire import SwiftyJSON private func downloadJson() { Alamofire.request("https: debugPrint(response) if let json = response.data { let data = JSON(data: json) print("data\(data["codeAd"]["dateExpire"])") print("data\(data["codeAd"]["codeRemoveAd"])") } } }
{"ABDC":[{"AB":"qwerty","CD":"uiop"}],[{"AB":"12334","CD":"asdf"}]}
Struct Struct_Name: Decodable { let IJ: String? let KL: String? init?(json: JSON){ self.IJ = "AB" <~~ json self.KL = "CD" <~~ json } }
Alamofire.request(url, method: .get, paramters: parametersURL).validate(contentType: ["application/json"]).responseJSON{ response in switch response.result{ case .success (let data): guard let value = data as? JSON, let eventsArrayJSON = value["ABDC"] as? [JSON] else { fatalError() } let struct_name = [Struct_Name].from(jsonArray: eventsArrayJSON) for i in 0 ..< Int((struct_name?.count)!) { print((struct_name?[i].IJ!)!) print((struct_name?[i].KL!)!) } break case .failure(let error): print("Error: \(error)") break } }
Alamofire.request(.POST, requestString, parameters: parameters, encoding: .JSON, headers: headers).validate(statusCode: 200..<303) .validate(contentType: ["application/json"]) .responseJSON { (response) in NSLog("response = \(response)") switch response.result { case .Success: guard let resultValue = response.result.value else { NSLog("Result value in response is nil") completionHandler(response: nil) return } let responseJSON = JSON(resultValue) break case .Failure(let error): NSLog("Error result: \(error)") return }
pod pod pod import UIKit import Alamofire import SwiftyJSON import SystemConfiguration class WebServiceHelper: NSObject { typealias SuccessHandler = (JSON) -> Void typealias FailureHandler = (Error) -> Void class func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(MemoryLayout<sockaddr_in>.size) zeroAddress.sin_family = sa_family_t(AF_INET) guard let defaultRouteReachability = withUnsafePointer(to: &zeroAddress, { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) { SCNetworkReachabilityCreateWithAddress(nil, $0) } }) else { return false } var flags: SCNetworkReachabilityFlags = [] if !SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) { return false } let isReachable = flags.contains(.reachable) let needsConnection = flags.contains(.connectionRequired) return (isReachable && !needsConnection) } class func getWebServiceCall(_ strURL : String, isShowLoader : Bool, success : @escaping SuccessHandler, failure : @escaping FailureHandler) { if isConnectedToNetwork() { print(strURL) if isShowLoader == true { AppDelegate.getDelegate().showLoader() } Alamofire.request(strURL).responseJSON { (resObj) -> Void in print(resObj) if resObj.result.isSuccess { let resJson = JSON(resObj.result.value!) if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } debugPrint(resJson) success(resJson) } if resObj.result.isFailure { let error : Error = resObj.result.error! if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } debugPrint(error) failure(error) } } }else { CommonMethods.showAlertWithError("", strMessage: Messages.NO_NETWORK, withTarget: (AppDelegate.getDelegate().window!.rootViewController)!) } } class func getWebServiceCall(_ strURL : String, params : [String : AnyObject]?, isShowLoader : Bool, success : @escaping SuccessHandler, failure :@escaping FailureHandler){ if isConnectedToNetwork() { if isShowLoader == true { AppDelegate.getDelegate().showLoader() } Alamofire.request(strURL, method: .get, parameters: params, encoding: JSONEncoding.default, headers: nil).responseJSON(completionHandler: {(resObj) -> Void in print(resObj) if resObj.result.isSuccess { let resJson = JSON(resObj.result.value!) if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } success(resJson) } if resObj.result.isFailure { let error : Error = resObj.result.error! if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } failure(error) } }) } else { CommonMethods.showAlertWithError("", strMessage: Messages.NO_NETWORK, withTarget: (AppDelegate.getDelegate().window!.rootViewController)!) } } class func postWebServiceCall(_ strURL : String, params : [String : AnyObject]?, isShowLoader : Bool, success : @escaping SuccessHandler, failure :@escaping FailureHandler) { if isConnectedToNetwork() { if isShowLoader == true { AppDelegate.getDelegate().showLoader() } Alamofire.request(strURL, method: .post, parameters: params, encoding: JSONEncoding.default, headers: nil).responseJSON(completionHandler: {(resObj) -> Void in print(resObj) if resObj.result.isSuccess { let resJson = JSON(resObj.result.value!) if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } success(resJson) } if resObj.result.isFailure { let error : Error = resObj.result.error! if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } failure(error) } }) }else { CommonMethods.showAlertWithError("", strMessage: Messages.NO_NETWORK, withTarget: (AppDelegate.getDelegate().window!.rootViewController)!) } } class func postWebServiceCallWithImage(_ strURL : String, image : UIImage!, strImageParam : String, params : [String : AnyObject]?, isShowLoader : Bool, success : @escaping SuccessHandler, failure : @escaping FailureHandler) { if isConnectedToNetwork() { if isShowLoader == true { AppDelegate.getDelegate().showLoader() } Alamofire.upload( multipartFormData: { multipartFormData in if let imageData = UIImageJPEGRepresentation(image, 0.5) { multipartFormData.append(imageData, withName: "Image.jpg") } for (key, value) in params! { let data = value as! String multipartFormData.append(data.data(using: String.Encoding.utf8)!, withName: key) print(multipartFormData) } }, to: strURL, encodingCompletion: { encodingResult in switch encodingResult { case .success(let upload, _, _): upload.responseJSON { response in debugPrint(response) } case .failure(let encodingError): print(encodingError) if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } let error : NSError = encodingError as NSError failure(error) } switch encodingResult { case .success(let upload, _, _): upload.responseJSON { (response) -> Void in if response.result.isSuccess { let resJson = JSON(response.result.value!) if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } success(resJson) } if response.result.isFailure { let error : Error = response.result.error! as Error if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } failure(error) } } case .failure(let encodingError): if isShowLoader == true { AppDelegate.getDelegate().dismissLoader() } let error : NSError = encodingError as NSError failure(error) } } ) } else { CommonMethods.showAlertWithError("", strMessage: Messages.NO_NETWORK, withTarget: (AppDelegate.getDelegate().window!.rootViewController)!) } } } ================================== Call Method let aParams : [String : String] = [ "ReqCode" : Constants.kRequestCodeLogin, ] WebServiceHelper.postWebServiceCall(Constants.BaseURL, params: aParams as [String : AnyObject]?, isShowLoader: true, success: { (responceObj) in if "\(responceObj["RespCode"])" != "1" { let alert = UIAlertController(title: Constants.kAppName, message: "\(responceObj["RespMsg"])", preferredStyle: UIAlertControllerStyle.alert) let OKAction = UIAlertAction(title: "OK", style: .default) { (action:UIAlertAction!) in } alert.addAction(OKAction) self.present(alert, animated: true, completion: nil) } else { let aParams : [String : String] = [ "Password" : self.dictAddLogin[AddLoginConstants.kPassword]!, ] CommonMethods.saveCustomObject(aParams as AnyObject?, key: Constants.kLoginData) } }, failure: { (error) in CommonMethods.showAlertWithError(Constants.kALERT_TITLE_Error, strMessage: error.localizedDescription,withTarget: (AppDelegate.getDelegate().window!.rootViewController)!) }) }
class Chassis {} class RacingChassis : Chassis {} class Car { let chassis = Chassis() } class RaceCar: Car { override let chassis = RacingChassis() }
class Chassis {} class RacingChassis : Chassis {} class Car { var chassis = Chassis() } class RaceCar: Car { var racingChassis = RacingChassis() override var chassis: Chassis { get { return racingChassis } set { if newValue is RacingChassis { racingChassis = newValue as RacingChassis } else { println("incorrect chassis type for racecar") } } } }
class Chassis { func description() -> String { return "Chassis" } } class RacingChassis : Chassis { override func description() -> String { return "Racing Chassis" } func racingChassisMethod() -> String { return "Wrooom" } } class Car { let chassis = Chassis() } class RaceCar: Car { override var chassis: RacingChassis { get { return self.chassis } set { self.chassis = newValue } } } var car = Car() car.chassis.description() var raceCar = RaceCar() raceCar.chassis.description() raceCar.chassis.racingChassisMethod()
class Chassis{ var chassis{ return "chassis" } } class RacingChassis:Chassis{ var racing{ return "racing" } } class Car<Type:Chassis> { let chassis: Type init(chassis:Type){ self.chassis = chassis } } class RaceCar: Car<RacingChassis> { var description{ return self.chassis.racing } }
let racingChassis = RacingChassis() let raceCar = RaceCar(chassis:racingChassis) print(raceCar.description)
class Chassis {} class RacingChassis : Chassis {} class Car { var chassis:Chassis? = Chassis() } class RaceCar: Car { override var chassis: RacingChassis? { get { return super.chassis as? RacingChassis } set { super.chassis = newValue } } }
class ViewController { var view: UIView! { return _view } private var _view: UIView! } class ScrollView : UIView {} class ScrollViewController : ViewController { override var view: ScrollView! { return super.view as ScrollView! } } class HomeView : ScrollView {} class HomeViewController : ScrollViewController { override var view: HomeView! { return super.view as HomeView! } }
class Chassis {} class RacingChassis: Chassis {} protocol Automobile { func chassis() -> Chassis } class Car: Automobile { private var _chassis: Chassis init () { _chassis = Chassis() } func chassis() -> Chassis { return _chassis } } class RaceCar: Car { private var _racingChassis: RacingChassis override init () { _racingChassis = RacingChassis() super.init() } override func chassis() -> Chassis { return _racingChassis } }
protocol Adaptable { var mode: Int { get set } func adapt() } class AdaptableViewController: UIViewController { } extension AdaptableViewController: Adaptable { var mode = 0 func adapt() { } }
protocol Adaptable { func mode() -> Int func adapt() } class AdaptableViewController: UIViewController { } extension AdaptableViewController: Adaptable { func mode() -> Int { return 0 } func adapt() { } }
class Chassis {} class RacingChassis : Chassis {} class SuperChassis : RacingChassis {} class Car { private var chassis: Chassis? = nil func getChassis() -> Chassis? { return chassis } func setChassis(chassis: Chassis) { self.chassis = chassis } } class RaceCar: Car { private var chassis: RacingChassis { get { return getChassis() as! RacingChassis } set { setChassis(chassis: newValue) } } override init() { super.init() chassis = RacingChassis() } } class SuperCar: RaceCar { private var chassis: SuperChassis { get { return getChassis() as! SuperChassis } set { setChassis(chassis: newValue) } } override init() { super.init() chassis = SuperChassis() } }
class Descriptor { let var1 = "a" } class OtherDescriptor: Descriptor { let var2 = "b" } class Asset<D: Descriptor> { let descriptor: D init(withDescriptor descriptor: D) { self.descriptor = descriptor } func printInfo() { print(descriptor.var1) } } class OtherAsset<D: OtherDescriptor>: Asset<D> { override func printInfo() { print(descriptor.var1, descriptor.var2) } } let asset = Asset(withDescriptor: Descriptor()) asset.printInfo() let otherAsset = OtherAsset(withDescriptor: OtherDescriptor()) otherAsset.printInfo()
class Chassis {} class RacingChassis : Chassis {} class Car { fileprivate let theChassis: Chassis var chassis: Chassis { get { return theChassis } } fileprivate init(_ chassis: Chassis) { theChassis = chassis } convenience init() { self.init(Chassis()) } } class RaceCar: Car { override var chassis: RacingChassis { get { return theChassis as! RacingChassis } } init() { super.init(RacingChassis()) } }
class Car { var chassis:Chassis? func inspect() { chassis?.checkForRust() } } class RaceCar: Car { var racingChassis: RacingChassis? { get { return chassis as? RacingChassis } } override func inspect() { super.inspect() racingChassis?.tuneSuspension() } }
class Chassis {} class RacingChassis : Chassis {} class Car { let chassis: Chassis init(){ chassis = Chassis() }} class RaceCar: Car { let raceChassis: RacingChassis init(){ raceChassis = RacingChassis() }}
class ViewController: UIViewController, UICollectionViewDelegateFlowLayout, UICollectionViewDataSource { var collectionView: UICollectionView? var screenSize: CGRect! var screenWidth: CGFloat! var screenHeight: CGFloat! override func viewDidLoad() { super.viewDidLoad() screenSize = UIScreen.mainScreen().bounds screenWidth = screenSize.width screenHeight = screenSize.height let layout: UICollectionViewFlowLayout = UICollectionViewFlowLayout() layout.sectionInset = UIEdgeInsets(top: 20, left: 0, bottom: 10, right: 0) layout.itemSize = CGSize(width: screenWidth / 3, height: screenWidth / 3) collectionView = UICollectionView(frame: self.view.frame, collectionViewLayout: layout) collectionView!.dataSource = self collectionView!.delegate = self collectionView!.registerClass(CollectionViewCell.self, forCellWithReuseIdentifier: "CollectionViewCell") collectionView!.backgroundColor = UIColor.greenColor() self.view.addSubview(collectionView!) } func numberOfSectionsInCollectionView(collectionView: UICollectionView) -> Int { return 1 } func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { return 20 } func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -> UICollectionViewCell { let cell = collectionView.dequeueReusableCellWithReuseIdentifier("CollectionViewCell", forIndexPath: indexPath) as CollectionViewCell cell.backgroundColor = UIColor.whiteColor() cell.layer.borderColor = UIColor.blackColor().CGColor cell.layer.borderWidth = 0.5 cell.frame.size.width = screenWidth / 3 cell.frame.size.height = screenWidth / 3 cell.textLabel?.text = "\(indexPath.section):\(indexPath.row)" return cell } }
layout.minimumInteritemSpacing = 0 layout.minimumLineSpacing = 0
let layout: UICollectionViewFlowLayout = UICollectionViewFlowLayout() layout.sectionInset = UIEdgeInsets(top: 20, left: 0, bottom: 10, right: 0) layout.itemSize = CGSize(width: screenWidth/3, height: screenWidth/3) layout.minimumInteritemSpacing = 0 layout.minimumLineSpacing = 0 collectionView!.collectionViewLayout = layout
func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -> CGSize { if indexPath.row == 0 { return CGSize(width: screenWidth, height: screenWidth/3) } return CGSize(width: screenWidth/3, height: screenWidth/3); }
{ let layout: UICollectionViewFlowLayout = UICollectionViewFlowLayout() let width = UIScreen.main.bounds.width layout.sectionInset = UIEdgeInsets(top: 0, left: 5, bottom: 0, right: 5) layout.itemSize = CGSize(width: width / 2, height: width / 2) layout.minimumInteritemSpacing = 0 layout.minimumLineSpacing = 0 collectionView!.collectionViewLayout = layout }
extension YourViewController : UICollectionViewDelegateFlowLayout{ func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { return UIEdgeInsets(top: 20, left: 0, bottom: 10, right: 0) } func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize { let collectionViewWidth = collectionView.bounds.width return CGSize(width: collectionViewWidth/3, height: collectionViewWidth/3) } func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat { return 0 } func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat { return 20 } }
func viewDidLoad() { let layout: UICollectionViewFlowLayout = UICollectionViewFlowLayout() let width = UIScreen.main.bounds.width layout.sectionInset = UIEdgeInsets(top: 0, left: 5, bottom: 0, right: 5) layout.itemSize = CGSize(width: width / 2, height: width / 2) layout.minimumInteritemSpacing = 0 layout.minimumLineSpacing = 0 collectionView!.collectionViewLayout = layout }
let collectionViewLayout = collectionView.collectionViewLayout as? UICollectionViewFlowLayout collectionViewLayout?.sectionInset = UIEdgeInsetsMake(0, 20, 0, 40) collectionViewLayout?.invalidateLayout()
let layout = myCollectionView.collectionViewLayout as? UICollectionViewFlowLayout layout?.minimumLineSpacing = 8
viewDidLoad() { let layout: UICollectionViewFlowLayout = UICollectionViewFlowLayout() var width = UIScreen.main.bounds.width layout.sectionInset = UIEdgeInsets(top: 0, left: 5, bottom: 0, right: 5) width = width - 10 layout.itemSize = CGSize(width: width / 2, height: width / 2) layout.minimumInteritemSpacing = 0 layout.minimumLineSpacing = 0 collectionView!.collectionViewLayout = layout }
""fbauth2:/" The operation couldn‚Äôt be completed. (OSStatus error -10814.)"
Optional(Error Domain=com.facebook.sdk.login Code=308 "(null)")
import FBSDKCoreKit import FBSDKLoginKit func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { return FBSDKApplicationDelegate.sharedInstance().application(application, didFinishLaunchingWithOptions: launchOptions) } func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool { return FBSDKApplicationDelegate.sharedInstance().application(app, open: url, options: options) }
canOpenURL: failed for URL: "fbauth2:/" - error: "The operation couldn‚Äôt be completed. (OSStatus error -10814.)
func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool { if let fbSDKAppId = FBSDKSettings.appID(), url.scheme!.hasPrefix("fb\(fbSDKAppId)"), url.host == "authorize" { let shouldOpen: Bool = FBSDKApplicationDelegate.sharedInstance().application(app, open: url, sourceApplication: options[UIApplicationOpenURLOptionsKey.sourceApplication] as! String!, annotation: options[UIApplicationOpenURLOptionsKey.annotation]) return shouldOpen } handlerOtherUrls(url: url) return true }
class ReportView: NSView { var categoriesPerPage = [[Int]]() var numPages: Int = { return categoriesPerPage.count } }
var numPages: Int { get{ return categoriesPerPage.count } }
var numPages: Int { return categoriesPerPage.count }
var numPages: Int { get{ return categoriesPerPage.count } set(v){ self.categoriesPerPage = v; } }
@obc class Album: NSObject { let name:String let singer:Singer let artwork:URL let playingSong:Song class func getCurrentlyPlayingSongLyric(duration: Int = 0) -> String { return playingSong.lyric } }
func getCurrentlyPlayingSongLyric(duration: Int = 0) -> String { return playingSong.lyric }
UserNotificationCenterWrapper.delegate = self public static var delegate: UNUserNotificationCenterDelegate? { get { return UNUserNotificationCenter.current().delegate } set { UNUserNotificationCenter.current().delegate = newValue } }
class ReportView: NSView { var categoriesPerPage = [[Int]]() var numPages: Int = { return categoriesPerPage.count } }
class ReportView: NSView { var categoriesPerPage = [[Int]]() var numPages: Int = { return categoriesPerPage.count }() }
class ReportView: NSView { var categoriesPerPage = [[Int]]() lazy var numPages: Int = { return categoriesPerPage.count }() }
var categoriesPerPage = [[Int]]() var numPagesClosure: ()->Int { return { return self.categoriesPerPage.count } }
var arr = [1, 2, 3] func addItem(inout localArr: [Int]) { localArr.append(4) } addItem(&arr) println(arr)
class BoxedArray<T> : MutableCollection, Reflectable, ... { var array : Array<T> subscript (index: Int) -> T { get { return array[index] } set(newValue) { array[index] = newValue } } }
var arr = [1, 2, 3] func addItem(_ localArr: inout [Int]) { localArr.append(4) } addItem(&arr) print(arr)
var a : Int[] = [] func test(inout b : Int[]) { b += [1,2,3,4,5] } test(&a) println(a)
class Account { var chats : [String]! var chatsViewController : ChatsViewController! func InitViewController() { chatsViewController.getChats = { return self.chats } } } class ChatsViewController { var getChats: (() -> ([String]))! func doSomethingWithChats() { let chats = getChats() } }
func doSomething(to arr: [Int]) -> [Int] { var arr = arr arr.append(3) return arr } var ids = [1, 2] ids = doSomething(to: ids) print(ids)
var myArray = [1, 2, 3] for (index, value) in myArray.enumerated() { myArray[index].append(4) }
class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow var testNavigationController: UINavigationController func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { testNavigationController = UINavigationController() var testViewController: UIViewController = UIViewController() self.testNavigationController.pushViewController(testViewController, animated: false) self.window = UIWindow(frame: UIScreen.mainScreen().bounds) self.window.rootViewController = testNavigationController self.window.backgroundColor = UIColor.whiteColor() self.window.makeKeyAndVisible() return true } }
var window : UIWindow? var testNavigationController : UINavigationController?
self.window!.backgroundColor = UIColor.whiteColor();
import UIKit @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -> Bool { window = UIWindow(frame: UIScreen.main.bounds) if let window = window { window.backgroundColor = UIColor.white window.rootViewController = ViewController() window.makeKeyAndVisible() } return true } }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = UIColor.blue } }
var window: UIWindow? var navController:UINavigationController? var viewController:ViewController? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { window = UIWindow(frame: UIScreen.mainScreen().bounds) viewController = ViewController(nibName: "ViewController", bundle: nil); navController = UINavigationController(rootViewController: viewController!); window?.rootViewController = navController; window?.makeKeyAndVisible() return true }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { self.window = UIWindow(frame: UIScreen.mainScreen().bounds) self.window!.backgroundColor = UIColor.whiteColor() let nav = UINavigationController() let vc = NextViewController ( nibName:"NextViewController", bundle: nil) nav.pushViewController(vc, animated: false) self.window!.rootViewController = nav self.window!.makeKeyAndVisible() return true }
class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? var testNavigationController: UINavigationController? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { self.testNavigationController = UINavigationController() var testViewController: UIViewController? = UIViewController() testViewController!.view.backgroundColor = UIColor.redColor() self.testNavigationController!.pushViewController(testViewController, animated: false) self.window = UIWindow(frame: UIScreen.mainScreen().bounds) self.window!.rootViewController = testNavigationController self.window!.backgroundColor = UIColor.whiteColor() self.window!.makeKeyAndVisible() return true } }
class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? var IndexNavigationController: UINavigationController? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { var IndexViewContoller : IndexViewController? = IndexViewController() self.IndexNavigationController = UINavigationController(rootViewController:IndexViewContoller) self.window = UIWindow(frame: UIScreen.mainScreen().bounds) self.window!.rootViewController = self.IndexNavigationController self.window!.backgroundColor = UIColor.whiteColor() self.window!.makeKeyAndVisible() return true } }
.... var controller: MyViewController = MyViewController(nibName:"MyViewController",bundle:nil) self.window!.rootViewController = controller return true
window = UIWindow() window?.rootViewController = ViewController() window?.makeKeyAndVisible()
import UIKit @UIApplicationMain class KSZAppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? var testNavigationController: UINavigationController? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { window = UIWindow(frame: UIScreen.mainScreen().bounds) if let win = window { win.opaque = true var testViewController: UIViewController = UIViewController() testNavigationController = UINavigationController(rootViewController: testViewController) win.rootViewController = testNavigationController win.backgroundColor = UIColor.whiteColor() win.makeKeyAndVisible() } return true } }
// // import UIKit class TestViewController: UIViewController { @IBOutlet var testBtn : UIButton init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) { super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) } @IBAction func testActionOnBtn(sender : UIButton) { let cancelButtonTitle = NSLocalizedString("OK", comment: "") let alertController = UIAlertController(title: "Title", message: "Message", preferredStyle: .Alert) let cancelAction = UIAlertAction(title: cancelButtonTitle, style: .Cancel) { action in NSLog("The simple alert } alertController.addAction(cancelAction) presentViewController(alertController, animated: true, completion: nil) } override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
// // import UIKit @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? var navigationController: UINavigationController? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: NSDictionary?) -> Bool { self.window = UIWindow(frame: UIScreen.mainScreen().bounds) self.window!.backgroundColor = UIColor.whiteColor() self.window!.makeKeyAndVisible() var testController: TestViewController? = TestViewController(nibName: "TestViewController", bundle: nil) self.navigationController = UINavigationController(rootViewController: testController) self.window!.rootViewController = self.navigationController return true } func applicationWillResignActive(application: UIApplication) { } func applicationDidEnterBackground(application: UIApplication) { } func applicationWillEnterForeground(application: UIApplication) { } func applicationDidBecomeActive(application: UIApplication) { } func applicationWillTerminate(application: UIApplication) { } }
class Student { var name: String var age: Int? init(name: String) { self.name = name } func description() -> String { return age != nil ? "\(name) is \(age) years old." : "\(name) hides his age." } } var me = Student(name: "Daniel") println(me.description()) me.age = 18 println(me.description())
Daniel hides his age. Daniel is Optional(18) years old.
func description() -> String { return age != nil ? "\(name) is \(age!) years old." : "\(name) hides his age." }
fileprivate protocol _Optional { func unwrappedString() -> String } extension Optional: _Optional { fileprivate func unwrappedString() -> String { switch self { case .some(let wrapped as _Optional): return wrapped.unwrappedString() case .some(let wrapped): return String(describing: wrapped) case .none: return String(describing: self) } } } postfix operator ~? { } public postfix func ~? <X> (x: X?) -> String { return x.unwrappedString }
var d: Double? = 12.34 print(d) print(d~?) d = nil print(d~?)
var obj:ViewController? = ViewController(nibName: "ViewController", bundle: nil) print("The Value of String is \(obj!.testString)")
for student in class { guard let age = student.age else { continue } }
let description = workout.listOfStrings.first! cell.textLabel?.text = description
if stringA? != nil { if !stringA!.isEmpty { ...blah blah } }
protocol OptionalString {} extension String: OptionalString {} extension Optional where Wrapped: OptionalString { var isNilOrEmpty: Bool { return ((self as? String) ?? "").isEmpty } }
func testNilOrEmpty() { let nilString:String? = nil XCTAssertTrue(nilString.isNilOrEmpty) let emptyString:String? = "" XCTAssertTrue(emptyString.isNilOrEmpty) let someText:String? = "lorem" XCTAssertFalse(someText.isNilOrEmpty) }
let myOptionalString: String? = nil guard let myString = myOptionalString, !myString.isEmpty else { print("String is nil or empty.") return } print(myString)
var str: String? = nil if str?.isEmpty ?? true { print("str is nil or empty") } str = "" if str?.isEmpty ?? true { print("str is nil or empty") }
extension Optional where Wrapped == String { var isNilOrEmpty: Bool { return self?.trimmingCharacters(in: .whitespaces).isEmpty ?? true } }
var isValidInput: Bool { return !isNilOrEmpty && self!.trimmingCharacters(in: .whitespaces).characters.count >= MIN_CHARS }
if stringA.map(isEmpty) == false { println("blah blah") }
if stringA == nil || stringA?.isEmpty == true { ...blah blah }
func isBlank (optionalString :String?) -> Bool { if let string = optionalString { return string.isEmpty } else { return true } } var optionalString :String? = nil if isBlank(optionalString) { println("here") } else { println("there") }
extension Optional where Wrapped == String { public var isNilOrEmpty: Bool { if let text = self, !text.isEmpty { return false } return true } }
extension String { static func isNilOrEmpty(_ string:String?) -> Bool { if string == nil { return true } return string!.isEmpty } }
return string!.trimmingCharacters(in: CharacterSet.whitespaces).isEmpty
if String.isNilOrEmpty("hello world") == true { print("it }
extension String { func isEmptyAndContainsNoWhitespace() -> Bool { guard self.isEmpty, self.trimmingCharacters(in: .whitespaces).isEmpty else { return false } return true } }
let myString = "My String" myString.isEmptyAndContainsNoWhitespace() let myString = "" myString.isEmptyAndContainsNoWhitespace() let myString = " " myString.isEmptyAndContainsNoWhitespace()
func str(_ string: String?) -> String { return (string != nil ? string! : "") }
let myDictionary: [String: String] = ["title": (dbObject?.title != nil ? dbObject?.title! : "")]
let myDictionary: [String: String] = ["title": str(dbObject.title)]
@IBAction func getStringFrom_myTextField(_ sender: Any) { guard let string = myTextField.text, !(myTextField.text?.isEmpty)! else { return } }
class func stringIsNilOrEmpty(aString: String) -> Bool { return (aString).isEmpty }
var rank: Int = 0 { didSet { if rank >= 1000 { rank = 999 } } }
var totalSteps: Int = 0 { willSet(newTotalSteps) { println("About to set totalSteps to \(newTotalSteps)") } didSet { if totalSteps > oldValue { println("Added \(totalSteps - oldValue) steps") } } }
private var _foo:Int = 0 var foo:Int { get { return _foo } set { if(newValue > 999) { _foo = 999 } else { _foo = newValue } } }
private var _foo:Int = 0 var foo:Int { get { return _foo } set { guard newValue <= 999 else { _foo = 999 return } _foo = newValue } }
class Shape { var sideLength: Double { get { return self.sideLength } set { self.sideLength = newValue } } }
class EquilateralTriangle: NamedShape { var sideLength: Double = 0.0 init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 3 } var perimeter: Double { get { return 3.0 * sideLength } set { sideLength = newValue / 3.0 } } override func simpleDescription() -> String { return "An equilateral triagle with sides of length \(sideLength)." } } var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle") triangle.perimeter triangle.perimeter = 9.9 triangle.sideLength‚Äù
[UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16))/255.0 green:((float)((rgbValue & 0xFF00) >> 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0] view.backgroundColor=UIColorFromRGB(0x209624);
func UIColorFromRGB(rgbValue: UInt) -> UIColor { return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) } view.backgroundColor = UIColorFromRGB(0x209624)
cell.backgroundColor = UIColor.colorWithRed(125/255.0, green: 125/255.0, blue: 125/255.0, alpha: 1.0)
cell.backgroundColor = UIColor(red: 0.5, green: 0.5, blue: 0.5, alpha: 1.0)
import Foundation import UIKit extension UIColor { convenience init(rgb: UInt) { self.init( red: CGFloat((rgb & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgb & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgb & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) } }
myLabel.backgroundColor = UIColor(red: 50.0/255, green: 150.0/255, blue: 65.0/255, alpha: 1.0)
func hexStringToUIColor (hex:String) -> UIColor { var cString:String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if (cString.hasPrefix(" cString.remove(at: cString.startIndex) } if ((cString.count) != 6) { return UIColor.gray } var rgbValue:UInt32 = 0 Scanner(string: cString).scanHexInt32(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }
func hexStringToUIColor (hex:String) -> UIColor { var cString:String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if (cString.hasPrefix(" cString.remove(at: cString.startIndex) } if ((cString.characters.count) != 6) { return UIColor.gray } var rgbValue:UInt32 = 0 Scanner(string: cString).scanHexInt32(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }
func hexStringToUIColor (hex:String) -> UIColor { var cString:String = hex.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet() as NSCharacterSet).uppercaseString if (cString.hasPrefix(" cString = cString.substringFromIndex(cString.startIndex.advancedBy(1)) } if ((cString.characters.count) != 6) { return UIColor.grayColor() } var rgbValue:UInt32 = 0 NSScanner(string: cString).scanHexInt(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }
shareBtn.backgroundColor = UIColor( red: CGFloat(92/255.0), green: CGFloat(203/255.0), blue: CGFloat(207/255.0), alpha: CGFloat(1.0) )
let appRedColor = UIColor(red: 200.0/255.0, green: 16.0/255.0, blue: 46.0/255.0, alpha: 1.0) let appSilverColor = UIColor(red: 236.0/255.0, green: 236.0/255.0, blue: 236.0/255.0, alpha: 1.0) let appWhiteColor = UIColor(red: 255.0/255.0, green: 255.0/255.0, blue: 255.0/255.0, alpha: 1.0) let appNavyColor = UIColor(red: 19.0/255.0, green: 41.0/255.0, blue: 75.0/255.0, alpha: 1.0)
bottomBorder.borderColor = UIColor (red: 255.0/255.0, green: 215.0/255.0, blue: 60/255.0, alpha: 1.0).CGColor
import UIKit extension UIColor { convenience init(argb: UInt) { self.init( red: CGFloat((argb & 0xFF0000) >> 16) / 255.0, green: CGFloat((argb & 0x00FF00) >> 8) / 255.0, blue: CGFloat(argb & 0x0000FF) / 255.0, alpha: CGFloat((argb & 0xFF000000) >> 24) / 255.0 ) } }
var clearColor: UIColor = UIColor.init(argb: 0x00000000) var redColor: UIColor = UIColor.init(argb: 0xFFFF0000)
cell.layer.borderColor = UIColor (red: 192.0/255.0, green: 192.0/255.0, blue: 197/255.0, alpha: 1.0).cgColor
let newColor = UIColor(red: CGFloat(0x85)/255 ,green: CGFloat(0xCC)/255 ,blue: CGFloat(0x4B)/255 ,alpha: 1.0)
button.layer.backgroundColor = UIColor(red: 112.0/255, green: 86.0/255, blue: 164.0/255, alpha: 1.0).cgColor
func getUIColorFromRGBThreeIntegers(red: Int, green: Int, blue: Int) -> UIColor { return UIColor(red: CGFloat(Float(red) / 255.0), green: CGFloat(Float(green) / 255.0), blue: CGFloat(Float(blue) / 255.0), alpha: CGFloat(1.0)) } func getUIColorFromRGBHexValue(value: Int) -> UIColor { return getUIColorFromRGBThreeIntegers(red: (value & 0xFF0000) >> 16, green: (value & 0x00FF00) >> 8, blue: value & 0x0000FF) } func getUIColorFromRGBString(value: String) -> UIColor { let str = value.lowercased().replacingOccurrences(of: " replacingOccurrences(of: "0x", with: ""); return getUIColorFromRGBHexValue(value: Int(str, radix: 16)!); }
let myColor1 = getUIColorFromRGBHexValue(value: 0xd5a637) let myColor2 = getUIColorFromRGBString(value: " let myColor3 = getUIColorFromRGBThreeIntegers(red: 213, green: 166, blue: 55)
import UIKit let requiredColor = UIColor(red: CGFloat((rgbValue & 0xFF0000) >> 16)/255, green: CGFloat((rgbValue & 0x00FF00) >> 8)/255, blue: CGFloat(rgbValue & 0x0000FF)/255, alpha :1)
@IBAction func blueBackground(_ sender: Any) { let blueColor = UIColor(red: CGFloat(160/255), green: CGFloat(183.0/255), blue: CGFloat(227.0/255), alpha: 1) view.backgroundColor = blueColor
public extension UIImage { public convenience init?(color: UIColor, size: CGSize = CGSize(width: 1, height: 1)) { let rect = CGRect(origin: .zero, size: size) UIGraphicsBeginImageContextWithOptions(rect.size, false, 0.0) color.setFill() UIRectFill(rect) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() guard let cgImage = image?.CGImage else { return nil } self.init(CGImage: cgImage) } }
let redImage200x200 = UIImage(color: .redColor(), size: CGSize(width: 200, height: 200))
public extension UIImage { public convenience init?(color: UIColor, size: CGSize = CGSize(width: 1, height: 1)) { let rect = CGRect(origin: .zero, size: size) UIGraphicsBeginImageContextWithOptions(rect.size, false, 0.0) color.setFill() UIRectFill(rect) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() guard let cgImage = image?.cgImage else { return nil } self.init(cgImage: cgImage) } }
func getImageWithColor(color: UIColor, size: CGSize) -> UIImage { let rect = CGRectMake(0, 0, size.width, size.height) UIGraphicsBeginImageContextWithOptions(size, false, 0) color.setFill() UIRectFill(rect) let image: UIImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image }
func getImageWithColor(color: UIColor, size: CGSize) -> UIImage { let rect = CGRect(x: 0, y: 0, width: size.width, height: size.height) UIGraphicsBeginImageContextWithOptions(size, false, 0) color.setFill() UIRectFill(rect) let image: UIImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() return image }
extension UIColor { func image(_ size: CGSize = CGSize(width: 1, height: 1)) -> UIImage { return UIGraphicsImageRenderer(size: size).image { rendererContext in self.setFill() rendererContext.fill(CGRect(origin: .zero, size: size)) } } }
let image0 = UIColor.orange.image(CGSize(width: 128, height: 128)) let image1 = UIColor.yellow.image()
import UIKit extension UIImage { class func imageWithColor(color: UIColor) -> UIImage { let rect: CGRect = CGRectMake(0, 0, 1, 1) UIGraphicsBeginImageContextWithOptions(CGSizeMake(1, 1), false, 0) color.setFill() UIRectFill(rect) let image: UIImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }
class ViewController: UIViewController { @IBOutlet weak var imageView: UIImageView! override func viewDidLoad() { super.viewDidLoad() imageView.backgroundColor = UIColor.redColor() } }
class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() var frame = CGRectMake(100,100,100,100) var imageView2 = UIImageView(frame: frame) imageView2.backgroundColor = UIColor.redColor() self.view.addSubview(imageView2) } }
class ViewController: UIViewController { func getImageWithColor(color: UIColor, size: CGSize) -> UIImage { UIGraphicsBeginImageContextWithOptions(size, false, 0) color.setFill() UIRectFill(CGRectMake(0, 0, 100, 100)) var image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } override func viewDidLoad() { super.viewDidLoad() var imageView = UIImageView(frame: CGRectMake(100,100,100,100)) let screenImage = getImageWithColor(UIColor.redColor(), size: CGSize(width: 100, height: 100)) imageView.image = screenImage self.view.addSubview(imageView) } }
extension UIColor { func getImage(size: CGSize) -> UIImage { let renderer = UIGraphicsImageRenderer(size: size) return renderer.image(actions: { rendererContext in self.setFill() rendererContext.fill(CGRect(x: 0, y: 0, width: size.width, height: size.height)) }) }}
extension UIColor { var imageRepresentation : UIImage { let rect = CGRect(x: 0.0, y: 0.0, width: 1.0, height: 1.0) UIGraphicsBeginImageContext(rect.size) let context = UIGraphicsGetCurrentContext() context?.setFillColor(self.cgColor) context?.fill(rect) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image! } }
class func getImageWithColor(color: UIColor, size: CGSize) -> UIImage { let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: CGSize(width: size.width, height: size.height)) UIGraphicsBeginImageContextWithOptions(size, false, 0) color.setFill() UIRectFill(rect) let image: UIImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() return image }
extension UIColor { func imageWithColor(width: Int, height: Int) -> UIImage { let size = CGSize(width: width, height: height) return UIGraphicsImageRenderer(size: size).image { rendererContext in self.setFill() rendererContext.fill(CGRect(origin: .zero, size: size)) } } }
let path = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] as String let url = NSURL(fileURLWithPath: path) if let pathComponent = url.appendingPathComponent("nameOfFileHere") { let filePath = pathComponent.path let fileManager = FileManager.default if fileManager.fileExists(atPath: filePath) { print("FILE AVAILABLE") } else { print("FILE NOT AVAILABLE") } } else { print("FILE PATH NOT AVAILABLE") }
let path = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] as String let url = URL(fileURLWithPath: path) let filePath = url.appendingPathComponent("nameOfFileHere").path let fileManager = FileManager.default if fileManager.fileExists(atPath: filePath) { print("FILE AVAILABLE") } else { print("FILE NOT AVAILABLE") }
let path = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as String let url = NSURL(fileURLWithPath: path) let filePath = url.URLByAppendingPathComponent("nameOfFileHere").path! let fileManager = NSFileManager.defaultManager() if fileManager.fileExistsAtPath(filePath) { print("FILE AVAILABLE") } else { print("FILE NOT AVAILABLE") }
let paths = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as String let getImagePath = paths.stringByAppendingPathComponent("SavedFile.jpg") let checkValidation = NSFileManager.defaultManager() if (checkValidation.fileExistsAtPath(getImagePath)) { println("FILE AVAILABLE"); } else { println("FILE NOT AVAILABLE"); }
let paths = NSURL(fileURLWithPath: NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0]) let getImagePath = paths.URLByAppendingPathComponent("SavedFile.jpg") let checkValidation = NSFileManager.defaultManager() if (checkValidation.fileExistsAtPath("\(getImagePath)")) { print("FILE AVAILABLE"); } else { print("FILE NOT AVAILABLE"); }
let documentDirectoryURL = try! NSFileManager.defaultManager().URLForDirectory(.DocumentDirectory, inDomain: .UserDomainMask, appropriateForURL: nil, create: true)
let databaseURL = documentDirectoryURL.URLByAppendingPathComponent("MyDataBase.sqlite")
let fileExists = databaseURL.checkResourceIsReachableAndReturnError(nil)
var error : NSError? let fileExists = databaseURL.checkResourceIsReachableAndReturnError(&error) if !fileExists { print(error) }
do { let fileExists = try databaseURL.checkResourceIsReachable() } catch let error as NSError { print(error) }
let fileExists = (try? databaseURL.checkResourceIsReachable()) ?? false
let paths = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true) let documentDirectory = paths[0] as! String let myFilePath = documentDirectory.stringByAppendingPathComponent("nameOfMyFile") let manager = NSFileManager.defaultManager() if (manager.fileExistsAtPath(myFilePath)) { }
func verifyIfSqliteDBExists(){ let docsDir : URL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first! let dbPath : URL = docsDir.appendingPathComponent("database.sqlite") do{ let sqliteExists : Bool = try dbPath.checkResourceIsReachable() print("An sqlite database exists at this path :: \(dbPath.path)") }catch{ print("SQLite NOT Found at :: \(strDBPath)") } }
func findIfSqliteDBExists(){ let docsDir : URL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first! let dbPath : URL = docsDir.appendingPathComponent("database.sqlite") let strDBPath : String = dbPath.path let fileManager : FileManager = FileManager.default if fileManager.fileExists(atPath:strDBPath){ print("An sqlite database exists at this path :: \(strDBPath)") }else{ print("SQLite NOT Found at :: \(strDBPath)") } }
let fileManager = FileManager.default var isDir: ObjCBool = false if fileManager.fileExists(atPath: yourURLPath.path, isDirectory: &isDir) { if isDir.boolValue { }else{ } }
var filePath: String { let manager = FileManager.default let url = manager.urls(for: .documentDirectory, in: .userDomainMask).first return(url!.appendingPathComponent("Data").path) }
override func viewDidLoad() { super.viewDidLoad() loadData() }
func loadData() { let manager = FileManager.default if manager.fileExists(atPath: filePath) { print("The file exists!") ourData = NSKeyedUnarchiver.unarchiveObject(withFile: filePath) as! Array<DataObject> } else { print("The file DOES NOT exist! Mournful trumpets sound...") } }
var test = [ [ "a": false, "b": "c" ], [ "a": false, "b": "c" ], [ "a": false, "b": "c" ], [ "a": false, "b": "c" ], [ "a": false, "b": "c" ], [ "a": false, "b": "c" ] ] var test = [ [ "a": false, "b": "c" ] ] test.append([ "a": false, "b": "c" ]) test.append([ "a": false, "b": "c" ]) test.append([ "a": false, "b": "c" ]) test.append([ "a": false, "b": "c" ]) test.append([ "a": false, "b": "c" ])
let keys = [keyQ, keyW, keyE, keyR, keyT, keyY, ... keyM] var keys = [KeyboardKey]() keys.append(keyQ) keys.append(keyW) ... keys.append(keyM) var keys = [KeyboardKey]() keys.appendContentsOf([keyQ, keyW, keyE, keyR, keyT, keyY, ... keyM])
var a = "Hello" var b = " " var c = "World" var d = "!" var partA = a + b var partB = c + d var result = partA + partB
if let date = function1() ?? function2() ?? function3() ?? function4() ?? function5() ?? function6() ?? function7() ?? function8() ?? function9() ?? function10() { return date }
var mainArray = arrayOne + arrayTwo + arrayThree + arrayFour + arrayFive
var mainArray = arrayOne mainArray += arrayTwo mainArray += arrayThree mainArray += arrayFour mainArray += arrayFive
let hangsInsteadOfError = { l, r in return l.nameFirst < r.nameFirst || l.nameFirst == r.nameFirst && l.nameLast < r.nameLast } let fixingErrorAvoidsHang = { (l:User, r:User) -> Bool in return l.nameFirst < r.nameFirst || l.nameFirst == r.nameFirst && l.nameLast < r.nameLast }
var sectionTuples: [(section: String, rows: [(name: String, subtitle: String)])] = [] let subtitle1: String = "" let subtitle2: String = "" sectionTuples = [( section: "Section 1", rows: [ (name: "name1", subtitle: subtitle1), (name: "name2", subtitle: subtitle2) ])]
var parameter = [String : AnyObject]() var finalArray = [parameter] for item in listArray { parameter = ["A": item.a as AnyObject, "B": item.b as AnyObject, "C": item.c as AnyObject, ... , "Z": item.z as AnyObject] finalArray.append(parameter) }
var parameter = [String : AnyObject]() var finalArray = [parameter] for item in listArray { parameter["A"] = listArray.a as AnyObject parameter["B"] = listArray.b as AnyObject parameter["C"] = listArray.c as AnyObject parameter["D"] = listArray.d as AnyObject . . . parameter["Z"] = listArray.z as AnyObject finalArray.append(parameter) }
enum Audience { case Public case Friends case Private }
enum Audience : String { case public case friends case private } let audience = Audience.public.rawValue
enum CompassPoint : String { case north, south, east, west }
enum Foo : CustomStringConvertible { case Bing case Bang case Boom var description : String { switch self { case .Bing: return "Bing" case .Bang: return "Bang" case .Boom: return "Boom" } } }
> let foo = Foo.Bing foo: Foo = Bing > println ("String for String for
enum Audience: String { case Public = "Public" case Friends = "Friends" case Private = "Private" }
enum Audience: String, Printable { case Public = "Public" case Friends = "Friends" case Private = "Private" var description: String { return self.rawValue } }
println("The value of Public is \(Audience.Public)")
var enumValue = Customer.Physics var str = String(describing: enumValue)
enum Rank:Int { case Ace = 1, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King } let r = Rank.Ace print(r) print("Rank: \(r)!")
enum Audience { case Public case Friends case Private } let audience: Audience = .Public print(audience)
enum Rank: Int { case Ace = 1 case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King func simpleDescription() -> String { switch self { case .Ace, .Jack, .Queen, .King: return String(self).lowercaseString default: return String(self.rawValue) } } }
struct Audience { static let Public = "Public" static let Friends = "Friends" static let Private = "Private" }
enum Audience{ ... func toString()->String{ var a:String switch self{ case .Public: a="Public" case .Friends: a="Friends" ... } return a }
enum Audience:String{ case Public="Public" case Friends="Friends" case Private="Private" }
public enum ECategory : Int{ case Attraction=0, FP, Food, Restroom, Popcorn, Shop, Service, None; var description: String { return String(describing: self) } } let category = ECategory.Attraction let categoryName = category.description
UIView.animateWithDuration(0.07) { self.someButton.alpha = 1 }
UIView.animateWithDuration(0.2, animations: { self.someButton.alpha = 1 })
UIView.animateWithDuration(0.2, animations: { self.blurBg.alpha = 1 }, completion: { self.blurBg.hidden = true })
UIView.animate(withDuration: 0.2) { < } UIView.animate(withDuration: 0.2, animations: { < }, completion: { _ in < })
UIView.animateWithDuration(0.2, animations: { self.blurBg.alpha = 1 }, completion: { (value: Bool) in self.blurBg.hidden = true })
UIView.animateWithDuration(0.2, animations: { self.blurBg.alpha = 1 }, completion: { finished in self.blurBg.hidden = true })
UIView.animateWithDuration(0.2, animations: { self.blurBg.alpha = 1 }, completion: { _ in self.blurBg.hidden = true })
func animateOut(view:UIView) { UIView.animateWithDuration (0.25, delay: 0.0, options: UIViewAnimationOptions.CurveLinear ,animations: { view.layer.opacity = 0.1 }, completion: { _ in view.hidden = true }) }
UIView.animateWithDuration(0.3, animations: { self.blurBg.alpha = 1 }, completion: {(_) -> Void in self.blurBg.hidden = true })
alpha = 1 UIView.animate(withDuration: 0.5, animations: { self.alpha = 0 }) { (ok) in print("Ended \(ok)") self.removeFromSuperview() }
import Foundation import SystemConfiguration public class Reachability { class func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in(sin_len: 0, sin_family: 0, sin_port: 0, sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0)) zeroAddress.sin_len = UInt8(sizeofValue(zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) let defaultRouteReachability = withUnsafePointer(&zeroAddress) { SCNetworkReachabilityCreateWithAddress(nil, UnsafePointer($0)).takeRetainedValue() } var flags: SCNetworkReachabilityFlags = 0 if SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) == 0 { return false } let isReachable = (flags & UInt32(kSCNetworkFlagsReachable)) != 0 let needsConnection = (flags & UInt32(kSCNetworkFlagsConnectionRequired)) != 0 return isReachable && !needsConnection } }
public class Reachability { public func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(MemoryLayout<sockaddr_in>.size) zeroAddress.sin_family = sa_family_t(AF_INET) guard let defaultRouteReachability = withUnsafePointer(to: &zeroAddress, { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) { SCNetworkReachabilityCreateWithAddress(nil, $0) } }) else { return false } var flags: SCNetworkReachabilityFlags = [] if !SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) { return false } if flags.isEmpty { return false } let isReachable = flags.contains(.reachable) let needsConnection = flags.contains(.connectionRequired) return (isReachable && !needsConnection) } }
import Foundation public class Reachability { class func isConnectedToNetwork()->Bool{ var Status:Bool = false let url = NSURL(string: "http: let request = NSMutableURLRequest(URL: url!) request.HTTPMethod = "HEAD" request.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringLocalAndRemoteCacheData request.timeoutInterval = 10.0 var response: NSURLResponse? var data = NSURLConnection.sendSynchronousRequest(request, returningResponse: &response, error: nil) as NSData? if let httpResponse = response as? NSHTTPURLResponse { if httpResponse.statusCode == 200 { Status = true } } return Status } }
if Reachability.isConnectedToNetwork() == true { println("Internet connection OK") } else { println("Internet connection FAILED") }
func checkWiFi() -> Bool { let networkStatus = Reachability().connectionStatus() switch networkStatus { case .Unknown, .Offline: return false case .Online(.WWAN): print("Connected via WWAN") return true case .Online(.WiFi): print("Connected via WiFi") return true } }
import Foundation import SystemConfiguration import UIKit import SystemConfiguration.CaptiveNetwork public let ReachabilityStatusChangedNotification = "ReachabilityStatusChangedNotification" public enum ReachabilityType: CustomStringConvertible { case WWAN case WiFi public var description: String { switch self { case .WWAN: return "WWAN" case .WiFi: return "WiFi" } } } public enum ReachabilityStatus: CustomStringConvertible { case Offline case Online(ReachabilityType) case Unknown public var description: String { switch self { case .Offline: return "Offline" case .Online(let type): return "Online (\(type))" case .Unknown: return "Unknown" } } } public class Reachability { func connectionStatus() -> ReachabilityStatus { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) guard let defaultRouteReachability = (withUnsafePointer(to: &zeroAddress) { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) { zeroSockAddress in SCNetworkReachabilityCreateWithAddress(nil, zeroSockAddress) } }) else { return .Unknown } var flags : SCNetworkReachabilityFlags = [] if !SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) { return .Unknown } return ReachabilityStatus(reachabilityFlags: flags) } func monitorReachabilityChanges() { let host = "google.com" var context = SCNetworkReachabilityContext(version: 0, info: nil, retain: nil, release: nil, copyDescription: nil) let reachability = SCNetworkReachabilityCreateWithName(nil, host)! SCNetworkReachabilitySetCallback(reachability, { (_, flags, _) in let status = ReachabilityStatus(reachabilityFlags: flags) NotificationCenter.default.post(name: NSNotification.Name(rawValue: ReachabilityStatusChangedNotification), object: nil, userInfo: ["Status": status.description])}, &context) SCNetworkReachabilityScheduleWithRunLoop(reachability, CFRunLoopGetMain(), CFRunLoopMode.commonModes.rawValue) } } extension ReachabilityStatus { public init(reachabilityFlags flags: SCNetworkReachabilityFlags) { let connectionRequired = flags.contains(.connectionRequired) let isReachable = flags.contains(.reachable) let isWWAN = flags.contains(.isWWAN) if !connectionRequired && isReachable { if isWWAN { self = .Online(.WWAN) } else { self = .Online(.WiFi) } } else { self = .Offline } } }
import Foundation public class Reachability { class func isConnectedToNetwork()->Bool{ var Status:Bool = false let url = NSURL(string: "http: let request = NSMutableURLRequest(URL: url!) request.HTTPMethod = "HEAD" request.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringLocalAndRemoteCacheData request.timeoutInterval = 10.0 let session = NSURLSession.sharedSession() session.dataTaskWithRequest(request, completionHandler: {(data, response, error) in print("data \(data)") print("response \(response)") print("error \(error)") if let httpResponse = response as? NSHTTPURLResponse { print("httpResponse.statusCode \(httpResponse.statusCode)") if httpResponse.statusCode == 200 { Status = true } } }).resume() return Status } }
func checkInternet(flag:Bool, completionHandler:(internet:Bool) -> Void) { UIApplication.sharedApplication().networkActivityIndicatorVisible = true let url = NSURL(string: "http: let request = NSMutableURLRequest(URL: url!) request.HTTPMethod = "HEAD" request.cachePolicy = NSURLRequestCachePolicy.ReloadIgnoringLocalAndRemoteCacheData request.timeoutInterval = 10.0 NSURLConnection.sendAsynchronousRequest(request, queue:NSOperationQueue.mainQueue(), completionHandler: {(response: NSURLResponse!, data: NSData!, error: NSError!) -> Void in UIApplication.sharedApplication().networkActivityIndicatorVisible = false let rsp = response as NSHTTPURLResponse? completionHandler(internet:rsp?.statusCode == 200) }) } func yourMethod() { self.checkInternet(false, completionHandler: {(internet:Bool) -> Void in if (internet) { } else { } }) }
import Foundation import SystemConfiguration public class Reachability { public func isConnectedToNetwork() -> Bool { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(MemoryLayout<sockaddr_in>.size) zeroAddress.sin_family = sa_family_t(AF_INET) guard let defaultRouteReachability = withUnsafePointer(to: &zeroAddress, { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) { SCNetworkReachabilityCreateWithAddress(nil, $0) } }) else { return false } var flags: SCNetworkReachabilityFlags = [] if !SCNetworkReachabilityGetFlags(defaultRouteReachability, &flags) { return false } let isReachable = flags.contains(.reachable) let needsConnection = flags.contains(.connectionRequired) return (isReachable && !needsConnection) } }
if Reachability.isConnectedToNetwork() == true { print("Connected to the internet") } else { print("No internet connection") }
DispatchQueue.main.async { let url = URL(string: "https: let request = URLRequest(url: url) let task = URLSession.shared.dataTask(with: request) {data, response, error in if error != nil { print("Internet Connection not Available!") } else if let httpResponse = response as? HTTPURLResponse { if httpResponse.statusCode == 200 { print("Internet Connection OK") } print("statusCode: \(httpResponse.statusCode)") } } task.resume() }
if isInternetAvailable() { print("if called Internet Connectivity success \(isInternetAvailable())"); }else{ print("else called Internet Connectivity success \(isInternetAvailable())"); } func isInternetAvailable() -> Bool { var zeroAddress = sockaddr_in() zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress)) zeroAddress.sin_family = sa_family_t(AF_INET) let defaultRouteReachability = withUnsafePointer(to: &zeroAddress) { $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {zeroSockAddress in SCNetworkReachabilityCreateWithAddress(nil, zeroSockAddress) } } var flags = SCNetworkReachabilityFlags() if !SCNetworkReachabilityGetFlags(defaultRouteReachability!, &flags) { return false } let isReachable = flags.contains(.reachable) let needsConnection = flags.contains(.connectionRequired) return (isReachable && !needsConnection) }
func lunhCheck(number : String) -> Bool { var odd = true; return reverse(number).map { String($0).toInt()! }.reduce(0) { odd = !odd return $0 + (odd ? ($1 == 9 ? 9 : ($1 * 2) % 9) : $1) } % 10 == 0 } lunhCheck("49927398716") lunhCheck("49927398717")
let numbers = [7, 8, 9, 10] let indexAndNum: [String] = numbers.enumerate().map { (index, element) in return "\(index): \(element)" } print(indexAndNum)
let actualIndexAndNum: [String] = zip(numbers.indices, numbers).map { "\($0): \($1)" } print(actualIndexAndNum)
let summedProducts = numbers.enumerate().reduce(0) { (accumulate, current) in return accumulate + current.0 * current.1 } print(summedProducts)
let numbers = [7, 8, 9, 10] let array: [(Int, Int)] = numbers.enumerated().map { ($0, $1) }
extension Array { public func mapWithIndex<T> (f: (Int, Element) -> T) -> [T] { return zip((self.startIndex ..< self.endIndex), self).map(f) } }
let numbers = [7, 8, 9, 10] let numbersWithIndex: [String] = numbers.mapWithIndex { (index, number) -> String in return "\(index): \(number)" } print("Numbers: \(numbersWithIndex)")
let array = [1, 18, 32, 7] let enumerateSequence = array.enumerated() let newArray = Array(enumerateSequence) print(newArray)
let reverseRandomAccessCollection = [1, 18, 32, 7].reversed() let enumerateSequence = reverseRandomAccessCollection.enumerated() let newArray = Array(enumerateSequence) print(newArray)
let reverseCollection = "8763".characters.reversed() let enumerateSequence = reverseCollection.enumerated() let newArray = enumerateSequence.map { ($0.0 + 1, String($0.1) + "A") } print(newArray)
let array = [8, 7, 6, 3] let reversedArray = array.reversed() let enumerateSequence = reversedArray.enumerated() let luhnClosure = { (sum: Int, tuple: (index: Int, value: Int)) -> Int in let indexIsOdd = tuple.index % 2 == 1 guard indexIsOdd else { return sum + tuple.value } let newValue = tuple.value == 9 ? 9 : tuple.value * 2 % 9 return sum + newValue } let sum = enumerateSequence.reduce(0, luhnClosure) let bool = sum % 10 == 0 print(bool)
let characterView = "8763".characters let mappedArray = characterView.flatMap { Int(String($0)) } let reversedArray = mappedArray.reversed() let enumerateSequence = reversedArray.enumerated() let luhnClosure = { (sum: Int, tuple: (index: Int, value: Int)) -> Int in let indexIsOdd = tuple.index % 2 == 1 guard indexIsOdd else { return sum + tuple.value } let newValue = tuple.value == 9 ? 9 : tuple.value * 2 % 9 return sum + newValue } let sum = enumerateSequence.reduce(0, luhnClosure) let bool = sum % 10 == 0 print(bool)
extension String { func luhnCheck() -> Bool { let characterView = self.characters let mappedArray = characterView.flatMap { Int(String($0)) } let reversedArray = mappedArray.reversed() let enumerateSequence = reversedArray.enumerated() let luhnClosure = { (sum: Int, tuple: (index: Int, value: Int)) -> Int in let indexIsOdd = tuple.index % 2 == 1 guard indexIsOdd else { return sum + tuple.value } let newValue = tuple.value == 9 ? 9 : tuple.value * 2 % 9 return sum + newValue } let sum = enumerateSequence.reduce(0, luhnClosure) return sum % 10 == 0 } } let string = "8763" let luhnBool = string.luhnCheck() print(luhnBool)
extension String { func luhnCheck() -> Bool { let sum = characters .flatMap { Int(String($0)) } .reversed() .enumerated() .reduce(0) { let indexIsOdd = $1.0 % 2 == 1 guard indexIsOdd else { return $0 + $1.1 } return $0 + ($1.1 == 9 ? 9 : $1.1 * 2 % 9) } return sum % 10 == 0 } } let string = "8763" let luhnBool = string.luhnCheck() print(luhnBool)
let numbers = [1,2,3,4,5] let indexedNumbers = reduce(numbers, [:]) { (memo, enumerated) -> [Int: Int] in return memo[enumerated.index] = enumerated.element }
extension CollectionType { func map<T>(@noescape transform: (Self.Index, Self.Generator.Element) throws -> T) rethrows -> [T] { return try zip((self.startIndex ..< self.endIndex), self).map(transform) } }
func luhn(string: String) -> Bool { var sum = 0 for (idx, value) in string.characters.reverse().map( { Int(String($0))! }).enumerate() { sum += ((idx % 2 == 1) ? (value == 9 ? 9 : (value * 2) % 9) : value) } return sum > 0 ? sum % 10 == 0 : false }
var string1 = "www.stackoverflow.com" var index1 = advance(string1.endIndex, -4) var substring1 = string1.substringToIndex(index1)
var string2 = "www.stackoverflow.com" var index2 = string2.rangeOfString(".", options: .BackwardsSearch)?.startIndex var substring2 = string2.substringToIndex(index2!)
var string1 = "www.stackoverflow.com" var index1 = string1.endIndex.advancedBy(-4) var substring1 = string1.substringToIndex(index1)
var string1 = "www.stackoverflow.com" var index1 = string1.index(string1.endIndex, offsetBy: -4) var substring1 = string1.substring(to: index1)
var string2 = "www.stackoverflow.com" var index2 = string2.range(of: ".", options: .backwards)?.lowerBound var substring2 = string2.substring(to: index2!)
var substring3 = index2.map(string2.substring(to:))
let string1 = "www.stackoverflow.com" let index1 = string1.index(string1.endIndex, offsetBy: -4) let substring1 = string1[..<index1]
let string2 = "www.stackoverflow.com" let index2 = string2.range(of: ".", options: .backwards)?.lowerBound let substring3 = index2.map(string2.substring(to:))
func lastIndexOfCharacter(_ c: Character) -> Int? { return range(of: String(c), options: .backwards)?.lowerBound.encodedOffset }
public extension String { func between(_ left: String, _ right: String) -> String? { guard let leftRange = range(of: left), let rightRange = range(of: right, options: .backwards) , leftRange.upperBound <= rightRange.lowerBound else { return nil } let sub = self.substring(from: leftRange.upperBound) let closestToLeftRange = sub.range(of: right)! return sub.substring(to: closestToLeftRange.lowerBound) } var length: Int { get { return self.characters.count } } func substring(to : Int) -> String { let toIndex = self.index(self.startIndex, offsetBy: to) return self.substring(to: toIndex) } func substring(from : Int) -> String { let fromIndex = self.index(self.startIndex, offsetBy: from) return self.substring(from: fromIndex) } func substring(_ r: Range<Int>) -> String { let fromIndex = self.index(self.startIndex, offsetBy: r.lowerBound) let toIndex = self.index(self.startIndex, offsetBy: r.upperBound) return self.substring(with: Range<String.Index>(uncheckedBounds: (lower: fromIndex, upper: toIndex))) } func character(_ at: Int) -> Character { return self[self.index(self.startIndex, offsetBy: at)] } func lastIndexOfCharacter(_ c: Character) -> Int? { return range(of: String(c), options: .backwards)?.lowerBound.encodedOffset } }
public extension String { func between(_ left: String, _ right: String) -> String? { guard let leftRange = range(of: left), let rightRange = range(of: right, options: .backwards) , leftRange.upperBound <= rightRange.lowerBound else { return nil } let sub = self[leftRange.upperBound...] let closestToLeftRange = sub.range(of: right)! return String(sub[..<closestToLeftRange.lowerBound]) } var length: Int { get { return self.count } } func substring(to : Int) -> String { let toIndex = self.index(self.startIndex, offsetBy: to) return String(self[...toIndex]) } func substring(from : Int) -> String { let fromIndex = self.index(self.startIndex, offsetBy: from) return String(self[fromIndex...]) } func substring(_ r: Range<Int>) -> String { let fromIndex = self.index(self.startIndex, offsetBy: r.lowerBound) let toIndex = self.index(self.startIndex, offsetBy: r.upperBound) let indexRange = Range<String.Index>(uncheckedBounds: (lower: fromIndex, upper: toIndex)) return String(self[indexRange]) } func character(_ at: Int) -> Character { return self[self.index(self.startIndex, offsetBy: at)] } func lastIndexOfCharacter(_ c: Character) -> Int? { return range(of: String(c), options: .backwards)?.lowerBound.encodedOffset } }
let text = "www.stackoverflow.com" let at = text.character(3) let range = text.substring(0..<3) let from = text.substring(from: 4) let to = text.substring(to: 16) let between = text.between(".", ".") let substringToLastIndexOfChar = text.lastIndexOfCharacter(".")
let s = "www.stackoverflow.com" let start = s.startIndex let end = s.endIndex.advancedBy(-4) let substring = s[start..<end]
let s = "www.stackoverflow.com" let start = s.startIndex let end = s.index(s.endIndex, offsetBy: -4) let substring = s[start..<end]
let myString = "www.stackoverflow.com".stringByDeletingPathExtension
extension String { var nsValue: NSString { return self } } let myString = "www.stackoverflow.com".nsValue.stringByDeletingPathExtension
let s = "www.stackoverflow.com" s.substringWithRange(0..<s.lastIndexOf("."))
import Foundation extension String { var length: Int { get { return countElements(self) } } func indexOf(target: String) -> Int { var range = self.rangeOfString(target) if let range = range { return distance(self.startIndex, range.startIndex) } else { return -1 } } func indexOf(target: String, startIndex: Int) -> Int { var startRange = advance(self.startIndex, startIndex) var range = self.rangeOfString(target, options: NSStringCompareOptions.LiteralSearch, range: Range<String.Index>(start: startRange, end: self.endIndex)) if let range = range { return distance(self.startIndex, range.startIndex) } else { return -1 } } func lastIndexOf(target: String) -> Int { var index = -1 var stepIndex = self.indexOf(target) while stepIndex > -1 { index = stepIndex if stepIndex + target.length < self.length { stepIndex = indexOf(target, startIndex: stepIndex + target.length) } else { stepIndex = -1 } } return index } func substringWithRange(range:Range<Int>) -> String { let start = advance(self.startIndex, range.startIndex) let end = advance(self.startIndex, range.endIndex) return self.substringWithRange(start..<end) } }
extension String : Sliceable { subscript (subRange: Range<String.Index>) -> String { get } }
var str = "www.stackexchange.com" str[str.startIndex ..< find(str, ".")!]
func findLast<C: CollectionType where C.Generator.Element: Equatable>(domain: C, value: C.Generator.Element) -> C.Index? { var last:C.Index? = nil for i in domain.startIndex..<domain.endIndex { if domain[i] == value { last = i } } return last } let str = "www.stackexchange.com" let substring = map(findLast(str, ".")) { str[str.startIndex ..< $0] }
func findLast<C: CollectionType where C.Generator.Element: Equatable, C.Index: BidirectionalIndexType>(domain: C, value: C.Generator.Element) -> C.Index? { for i in lazy(domain.startIndex ..< domain.endIndex).reverse() { if domain[i] == value { return i } } return nil }
extension String { func substringFromIndex(index: Int) -> String { if (index < 0 || index > self.characters.count) { print("index \(index) out of bounds") return "" } return self.substringFromIndex(self.startIndex.advancedBy(index)) } func substringToIndex(index: Int) -> String { if (index < 0 || index > self.characters.count) { print("index \(index) out of bounds") return "" } return self.substringToIndex(self.startIndex.advancedBy(index)) } func substringWithRange(start: Int, end: Int) -> String { if (start < 0 || start > self.characters.count) { print("start index \(start) out of bounds") return "" } else if end < 0 || end > self.characters.count { print("end index \(end) out of bounds") return "" } let range = Range(start: self.startIndex.advancedBy(start), end: self.startIndex.advancedBy(end)) return self.substringWithRange(range) } func substringWithRange(start: Int, location: Int) -> String { if (start < 0 || start > self.characters.count) { print("start index \(start) out of bounds") return "" } else if location < 0 || start + location > self.characters.count { print("end index \(start + location) out of bounds") return "" } let range = Range(start: self.startIndex.advancedBy(start), end: self.startIndex.advancedBy(start + location)) return self.substringWithRange(range) } }
extension String { func substring(from index: Int) -> String { if (index < 0 || index > self.characters.count) { print("index \(index) out of bounds") return "" } return self.substring(from: self.characters.index(self.startIndex, offsetBy: index)) } func substring(to index: Int) -> String { if (index < 0 || index > self.characters.count) { print("index \(index) out of bounds") return "" } return self.substring(to: self.characters.index(self.startIndex, offsetBy: index)) } func substring(start: Int, end: Int) -> String { if (start < 0 || start > self.characters.count) { print("start index \(start) out of bounds") return "" } else if end < 0 || end > self.characters.count { print("end index \(end) out of bounds") return "" } let startIndex = self.characters.index(self.startIndex, offsetBy: start) let endIndex = self.characters.index(self.startIndex, offsetBy: end) let range = startIndex..<endIndex return self.substring(with: range) } func substring(start: Int, location: Int) -> String { if (start < 0 || start > self.characters.count) { print("start index \(start) out of bounds") return "" } else if location < 0 || start + location > self.characters.count { print("end index \(start + location) out of bounds") return "" } let startIndex = self.characters.index(self.startIndex, offsetBy: start) let endIndex = self.characters.index(self.startIndex, offsetBy: start + location) let range = startIndex..<endIndex return self.substring(with: range) } }
let string = "www.stackoverflow.com" let substring = string.substringToIndex(string.characters.count-4)
import Foundation let string = "www.stackoverflow.com" if let rangeOfIndex = string.rangeOfCharacterFromSet(NSCharacterSet(charactersInString: "."), options: .BackwardsSearch) { print(string.substringToIndex(rangeOfIndex.endIndex)) }
import Foundation let string = "www.stackoverflow.com" if let rangeOfIndex = string.rangeOfCharacterFromSet(NSCharacterSet(charactersInString: "."), options: .BackwardsSearch) { print(string.substringToIndex(rangeOfIndex.startIndex)) }
import Foundation extension String { func substringWithLastInstanceOf(character: Character) -> String? { if let rangeOfIndex = rangeOfCharacterFromSet(NSCharacterSet(charactersInString: String(character)), options: .BackwardsSearch) { return self.substringToIndex(rangeOfIndex.endIndex) } return nil } func substringWithoutLastInstanceOf(character: Character) -> String? { if let rangeOfIndex = rangeOfCharacterFromSet(NSCharacterSet(charactersInString: String(character)), options: .BackwardsSearch) { return self.substringToIndex(rangeOfIndex.startIndex) } return nil } } print("www.stackoverflow.com".substringWithLastInstanceOf(".")) print("www.stackoverflow.com".substringWithoutLastInstanceOf(".")) /* prints: Optional("www.stackoverflow.") Optional("www.stackoverflow") */
let string = "www.stackoverflow.com" if let reverseIndex = string.characters.reverse().indexOf(".") { print(string[string.startIndex ..< reverseIndex.base]) }
let string = "www.stackoverflow.com" if let reverseIndex = string.characters.reverse().indexOf(".") { print(string[string.startIndex ..< reverseIndex.base.advancedBy(-1)]) }
extension String { func substringWithLastInstanceOf(character: Character) -> String? { if let reverseIndex = characters.reverse().indexOf(".") { return self[self.startIndex ..< reverseIndex.base] } return nil } func substringWithoutLastInstanceOf(character: Character) -> String? { if let reverseIndex = characters.reverse().indexOf(".") { return self[self.startIndex ..< reverseIndex.base.advancedBy(-1)] } return nil } } print("www.stackoverflow.com".substringWithLastInstanceOf(".")) print("www.stackoverflow.com".substringWithoutLastInstanceOf(".")) /* prints: Optional("www.stackoverflow.") Optional("www.stackoverflow") */
let s = "www.stackoverflow.com" let result = String(s.characters.prefix(17))
let s = "short" let result = String(s.characters.prefix(17))
extension String { var length: Int { return self.characters.count } public func substring(index: Int, length: Int) -> String { if self.length <= index { return "" } let leftIndex = self.index(self.startIndex, offsetBy: index) if self.length <= index + length { return self.substring(from: leftIndex) } let rightIndex = self.index(self.endIndex, offsetBy: -(self.length - index - length)) return self.substring(with: leftIndex..<rightIndex) } public func substring(left: Int, right: Int) -> String { if length <= left { return "" } let leftIndex = self.index(self.startIndex, offsetBy: left) if length <= right { return self.substring(from: leftIndex) } else { let rightIndex = self.index(self.endIndex, offsetBy: -self.length + right + 1) return self.substring(with: leftIndex..<rightIndex) } } }
print("test: " + String("ABCDE".substring(index: 2, length: 3) == "CDE")) print("test: " + String("ABCDE".substring(index: 0, length: 3) == "ABC")) print("test: " + String("ABCDE".substring(index: 2, length: 1000) == "CDE")) print("test: " + String("ABCDE".substring(left: 0, right: 2) == "ABC")) print("test: " + String("ABCDE".substring(left: 1, right: 3) == "BCD")) print("test: " + String("ABCDE".substring(left: 3, right: 1000) == "DE"))
func substr(myString: String, start: Int, clen: Int)->String { var index2 = string1.startIndex.advancedBy(start) var substring2 = string1.substringFromIndex(index2) var index1 = substring2.startIndex.advancedBy(clen) var substring1 = substring2.substringToIndex(index1) return substring1 } substr(string1, start: 3, clen: 5)
let string = "www.stackoverflow.com" let first3Characters = String(string.characters.prefix(3)) let lastCharacters = string.characters.dropFirst(4) let indexOfFouthCharacter = olNumber.index(olNumber.startIndex, offsetBy: 4) let first3Characters = olNumber.substring(to: indexOfFouthCharacter) let lastCharacters = olNumber.substring(from: indexOfFouthCharacter)
var bcd = "abcdef".substring(1,to:3) var cde = "abcdef".substring(2,to:-2) var cde = "abcdef".substring(2,length:3) extension String { public func substring(from:Int = 0, var to:Int = -1) -> String { if to < 0 { to = self.length + to } return self.substringWithRange(Range<String.Index>( start:self.startIndex.advancedBy(from), end:self.startIndex.advancedBy(to+1))) } public func substring(from:Int = 0, length:Int) -> String { return self.substringWithRange(Range<String.Index>( start:self.startIndex.advancedBy(from), end:self.startIndex.advancedBy(from+length))) } }
extension String { func index(at: Int) -> String.Index { return self.index(self.startIndex, offsetBy: at) } }
let string = "abcde" let to = string[..<string.index(at: 3)] let from = string[string.index(at: 3)...]
var string1 = "www.stackoverflow.com" var index1 = string1.endIndex.advancedBy(-4) var substring1 = string1.substringToIndex(index1)
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() var mainText = "http: var range = Range(start: mainText.startIndex.advancedBy(7), end: mainText.startIndex.advancedBy(24)) var subText = mainText.substringWithRange(range) range = Range(start: mainText.startIndex.advancedBy(7), end: mainText.endIndex) subText = mainText.substringWithRange(range) } }
extension String { func length() -> Int { return self.lengthOfBytesUsingEncoding(NSUTF16StringEncoding) } func substring(from:Int = 0, to:Int = -1) -> String { var nto=to if nto < 0 { nto = self.length() + nto } return self.substringWithRange(Range<String.Index>( start:self.startIndex.advancedBy(from), end:self.startIndex.advancedBy(nto+1))) } func substring(from:Int = 0, length:Int) -> String { return self.substringWithRange(Range<String.Index>( start:self.startIndex.advancedBy(from), end:self.startIndex.advancedBy(from+length))) } }
extension String { func subStr(s: Int, l: Int) -> String { let r = Range(NSRange(location: s, length: l))! let fromIndex = self.index(self.startIndex, offsetBy: r.lowerBound) let toIndex = self.index(self.startIndex, offsetBy: r.upperBound) let indexRange = Range<String.Index>(uncheckedBounds: (lower: fromIndex, upper: toIndex)) return String(self[indexRange]) } }
import UIKit var str = "Hello, playground" var res = NSString(string: str) print(res.substring(from: 4)) print(res.substring(to: 10))
func divmod(_ a: Int, _ b:Int) -> (Int, Int) { return (a / b, a % b) } print(divmod(7, 3)) print(divmod(5, 2)) print(divmod(12,4))
func divmod(a: Int, b:Int) -> (Int, Int) { return (a / b, a % b) } print(divmod(a: 7, b: 3)) print(divmod(a: 5, b: 2)) print(divmod(a: 12,b: 4))
PHPhotoLibrary.performChanges( { }, completionHandler: { success, _ in if success { print("yay") } })
class MyView: NSView { override func mouseDown(with _: NSEvent) { } override func draw(_ _: NSRect) { } }
switch somePoint { case (0, 0): print("(0, 0) is at the origin") case (_, 0): print("(\(somePoint.0), 0) is on the x-axis") case (0, _): print("(0, \(somePoint.1)) is on the y-axis") default: print("(\(somePoint.0), \(somePoint.1)) isn }
func divmod(_ a: Int, _ b:Int) -> (Int, Int) { return (a / b, a % b) } func divmod(a: Int, b:Int) -> (Int, Int) { return (a / b, a % b) }
let byteMap = [ ["ECG" : (0,12)], ["PPG" : (12,3)], ["ECG" : (15,12)], ["PPG" : (27,3)], ["ECG" : (30,12)]
let byteMap : [String: (Int, Int)] = [ ["ECG" : (0,12)], ["PPG" : (12,3)], ["ECG" : (15,12)], ["PPG" : (27,3)], ["ECG" : (30,12)],
return String(format: "%d,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f", samples.count,sum1.x,sum1.y,sum1.z,sum1.rx,sum1.ry,sum1.rz,sum2.x,sum2.y,sum2.z,sum2.rx,sum2.ry,sum2.rz,sum3.x,sum3.y,sum3.z,sum3.rx,sum3.ry,sum3.rz)
var output: String = "" output += String(format: "%d,", samples.count) output += String(format: "%.3f,%.3f,%.3f,", sum1.x, sum1.y, sum1.z) output += String(format: "%.3f,%.3f,%.3f,", sum1.rx, sum1.ry, sum1.rz) output += String(format: "%.3f,%.3f,%.3f,", sum2.x, sum2.y, sum2.z) output += String(format: "%.3f,%.3f,%.3f,", sum2.rx, sum2.ry, sum2.rz) output += String(format: "%.3f,%.3f,%.3f,", sum3.x, sum3.y, sum3.z) output += String(format: "%.3f,%.3f,%.3f", sum3.rx, sum3.ry, sum3.rz) return output
var initDictionary:[String:AnyObject] = [ "details" : "", "duration" : serviceDuration, "name" : serviceName, "price" : servicePrice, "typeId" : typeID, "typeName" : typeName, "url" : "", "serviceId" : serviceID, "imageName" : "" ]
var initDictionary= [ "details" : "", "duration" : serviceDuration, "name" : serviceName, "price" : servicePrice, "typeId" : typeID, "typeName" : typeName, "url" : "", "serviceId" : serviceID, "imageName: "" ]
if let elem = obj.property, let elem2 = obj.prop2, etc { }
let serviceImages = images.filter { $0.serviceId == service.id } let sorted = serviceImages.sort { $0.sort > $1.sort }
let serviceImages = images.filter { $0.serviceId == service.id }. sort { $0.sort > $1.sort }
let firstLevel = [ [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0] ] let secondLevel = [ [0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] let thirdLevel = [ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] let map = [firstLevel, secondLevel, thirdLevel]
import UIKit import AVFoundation import Photos import CoreMotion import Foundation class TestViewController: UIViewController { let movieFileOutput = AVCaptureMovieFileOutput() var anz_total_frames = 0, anz_total_miss = 0 @IBOutlet weak var tfStatistics: UITextView! func showVideoStatistics() { let statisticText:String = "frames: \(self.anz_total_frames)" + String.newLine + "frames/s: \(self.anz_total_frames / self.movieFileOutput.recordedDuration.seconds)" + String.newLine + "miss: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine + "nicht erkannt: " + formatText4FramesPercent(self.anz_total_miss) + String.newLine self.tfStatistics.text = statisticText } func formatText4FramesPercent(_ anz:Int) -> String { let perc = Double(anz)*100.0/Double(anz_total_frames) return String(perc.format(".1") + "%") } }
extension String { var localized: String { return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: "") } static var newLine: String { return "\r\n" } } extension Int { func format(_ f: String) -> String { return String(format: "%\(f)d", self) } } extension Double { func format(_ f: String) -> String { return String(format: "%\(f)f", self) } }
"frames/s: \(self.anz_total_frames / self.movieFileOutput.recordedDuration.seconds)" + String.newLine +
var myArray: [(String, Bool?)]? myArray = [("someString", someBool), ("someString", someBool), ("someString", someBool), ("someString", someBool), ("someString", someBool) . . ("someString", someBool)]
var myArray = [(String, Bool?)]() myArray.append(("someString", someBool)) myArray.append(("someString", someBool)) myArray.append(("someString", someBool)) myArray.append(("someString", someBool)) myArray.append(("someString", someBool)) . . .
let debugString1 = (placeMark.locality ?? "") let debugString1 = (placeMark.locality ?? "") + ", " + (placeMark.administrativeArea ?? "") let debugString1 = (placeMark.locality ?? "") + ", " + (placeMark.administrativeArea ?? "") + (placeMark.postalCode ?? "") var debugString1 = placeMark.locality ?? "" debugString1 = debugString1 + ", " + (placeMark.administrativeArea ?? "") debugString1 = debugString1 + " " + (placeMark.postalCode ?? "")
var color: [UIColor] { return [ UIColor(...), UIColor(...), ... ] }
func color() -> [UIColor] { return [ UIColor(...), UIColor(...), ... ] }
killall Xcode rm -rf ~/Library/Developer/Xcode/DerivedData/ModuleCache open /Applications/Xcode.app
private lazy var emojiFace:[String] = ["?", "?", "?", "?"]
struct MyVariables { static var yourVariable = "someString" }
let string = MyVariables.yourVariable println("Global variable:\(string)") MyVariables.yourVariable = "anotherString"
import UIKit private let changeSegueId = "MasterToChange" private let bookSegueId = "MasterToBook"
var myMax = 0 for i in 0..myArray.count { if (myArray[i] > myMax){myMax = myArray[i]} }
let nums = [1, 6, 3, 9, 4, 6]; let numMax = nums.reduce(Int.min, { max($0, $1) })
let intMax = [12, 15, 6].max() let stringMax = ["bike", "car", "boat"].max() print(String(describing: intMax)) print(String(describing: stringMax))
class Route: Comparable, CustomStringConvertible { let distance: Int var description: String { return "Route with distance: \(distance)" } init(distance: Int) { self.distance = distance } static func ==(lhs: Route, rhs: Route) -> Bool { return lhs.distance == rhs.distance } static func <(lhs: Route, rhs: Route) -> Bool { return lhs.distance < rhs.distance } } let routes = [ Route(distance: 20), Route(distance: 30), Route(distance: 10) ] let maxRoute = routes.max() print(String(describing: maxRoute))
@warn_unqualified_access func max(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element?
let dictionary = ["Boat" : 15, "Car" : 20, "Bike" : 40] let keyMaxElement = dictionary.max(by: { (a, b) -> Bool in return a.key < b.key }) let valueMaxElement = dictionary.max(by: { (a, b) -> Bool in return a.value < b.value }) print(String(describing: keyMaxElement)) print(String(describing: valueMaxElement))
class Route: CustomStringConvertible { let distance: Int var description: String { return "Route with distance: \(distance)" } init(distance: Int) { self.distance = distance } } let routes = [ Route(distance: 20), Route(distance: 30), Route(distance: 10) ] let maxRoute = routes.max(by: { (a, b) -> Bool in return a.distance < b.distance }) print(String(describing: maxRoute))
var list = [1, 2, 3, 4] var max: Int = (list as AnyObject).valueForKeyPath("@max.self") as Int
var avg: Double = (list as AnyObject).valueForKeyPath("@avg.self") as Double
let randomNumbers = [4, 7, 1, 9, 6, 5, 6, 9] let maxNumber = randomNumbers.reduce(randomNumbers[0]) { $0 > $1 ? $0 : $1 }
let nums = [1, 6, 3, 9, 4, 6]; let numMax = nums.reduce(Int.min, combine: { max($0, $1) })
let nums = [1.3, 6.2, 3.6, 9.7, 4.9, 6.3]; let numMax = nums.reduce(-Double.infinity, combine: { max($0, $1) })
let a = [1, 2, 3] print(a.maxElement()) print(a.minElement())
var numbers = [1, 2, 7, 5]; var val = sort(numbers){$0 > $1}[0];
func getSmallAndGreatestNumber() -> Void { let numbers = [145, 206, 116, 809, 540, 176] var i = 0 var largest = numbers[0] var small = numbers[0] while i < numbers.count{ if (numbers[i] > largest) { largest = numbers[i] } if (numbers[i] < small) { small = numbers[i] } i = i + 1 } print("Maximum Number ====================\(largest)") print("Minimum Number ====================\(small)") }
var num = [11, 2, 7, 5, 21] var result = num.sorted(){ $0 > $1 } print("max from result: \(result[0])")
let triggerTime = (Int64(NSEC_PER_SEC) * 10) dispatch_after(dispatch_time(DISPATCH_TIME_NOW, triggerTime), dispatch_get_main_queue(), { () -> Void in self.functionToCall() })
DispatchQueue.main.asyncAfter(deadline: .now() + 10.0, execute: { self.functionToCall() })
unowned let unownedSelf = self let deadlineTime = DispatchTime.now() + .seconds(10) DispatchQueue.main.asyncAfter(deadline: deadlineTime, execute: { unownedSelf.functionToCall() })
NSTimer.scheduledTimerWithTimeInterval(NSTimeInterval(3), target: self, selector: "functionHere", userInfo: nil, repeats: false)
let arg : Int = 42 let infoDict : [String : AnyObject] = ["argumentInt", arg] NSTimer.scheduledTimerWithTimeInterval(NSTimeInterval(3), target: self, selector: "functionHereWithArgument:", userInfo: infoDict, repeats: false)
func functionHereWithArgument (timer : NSTimer) { if let userInfo = timer.userInfo as? Dictionary<String, AnyObject> { let argumentInt : Int = (userInfo[argumentInt] as! Int) } }
@IBAction func renameClassButton(sender: AnyObject) { classTopButton.text = "\(classTopTextField)" }
let button = (sender as AnyObject) button.setTitle("Your text", for: .normal)
(sender as AnyObject).setTitle("Your text", for: .normal)
@IBAction func TickToeButtonClick(sender: AnyObject) { sender.setTitle("my text here", forState: .normal) }
@IBOutlet weak var classToButton: NSButton! . . . classToButton.title = "Some Text"
@IBAction func myButton(sender: AnyObject) { sender.setTitle("This is example text one", for:[]) sender.setTitle("This is example text two", for: .normal) }
0 swift 0x00000001061e5608 llvm::sys::PrintStackTrace(__sFILE*) + 40 1 swift 0x00000001061e5af4 SignalHandler(int) + 452 2 libsystem_platform.dylib 0x00007fff894da5aa _sigtramp + 26 3 libsystem_platform.dylib 0xb03939841e997c88 _sigtramp + 2504775416 4 swift 0x00000001064c8bb9 swift::NominalTypeDecl::getMembers(bool) const + 41 5 swift 0x00000001055efab9 swift::irgen::ClassMetadataLayout<(anonymous namespace)::FindClassMethodIndex>::addClassMembers(swift::ClassDecl*) + 329 6 swift 0x00000001055e97b2 swift::irgen::emitVirtualMethodValue(swift::irgen::IRGenFunction&, llvm::Value*, swift::SILType, swift::SILDeclRef, swift::CanTypeWrapper<swift::SILFunctionType>, swift::ResilienceExpansion) + 434 7 swift 0x00000001056550d3 swift::SILVisitor<(anonymous namespace)::IRGenSILFunction, void>::visit(swift::ValueBase*) + 42611 8 swift 0x000000010564a266 swift::irgen::IRGenModule::emitSILFunction(swift::SILFunction*) + 8678 9 swift 0x00000001055cb6f8 swift::irgen::IRGenModule::emitGlobalTopLevel() + 184 10 swift 0x00000001056376e3 performIRGeneration(swift::IRGenOptions&, swift::Module*, swift::SILModule*, llvm::StringRef, llvm::LLVMContext&, swift::SourceFile*, unsigned int) + 1859 11 swift 0x0000000105638033 swift::performIRGeneration(swift::IRGenOptions&, swift::SourceFile&, swift::SILModule*, llvm::StringRef, llvm::LLVMContext&, unsigned int) + 51 12 swift 0x00000001055aa65a frontend_main(llvm::ArrayRef<char const*>, char const*, void*) + 4842 13 swift 0x00000001055a935d main + 1533 14 libdyld.dylib 0x00007fff8a82e5fd start + 1
1. While emitting IR SIL function @_TFCSo6UIViewg6heightSd for <unknown>:0: error: unable to execute command: Segmentation fault: 11 <unknown>:0: error: swift frontend command failed due to signal (use -v to see invocation) Command /Applications/Xcode6-Beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift failed with exit code 254
protocol SomeProtocolName: class { var someProtocolVariable: String { get set } func someProtocolFunction(someProtocolVariable: String) } extension SomeProtocolName { func someProtocolFunction(someProtocolVariable: String?) { self.someProtocolVariable = someProtocolVariable } }
weak var stripeViewDelegate : StripeViewDelegate? = nil
override weak var stripeViewDelegate : StripeViewDelegate? = nil { didSet { self.stripeView.delegate = stripeViewDelegate }
class func createByAny(instance: Any?) -> ApiCollectionResponse { ... }
class func createByAny(instance: Any) -> ApiCollectionResponse { ... }
func ==<T>(lhs: Foo, rhs: Foo) -> Bool { return lhs.bar == rhs.bar }
import Foundation protocol NamedSegues { func executeSegueWithId(id: String) -> Void static func getDefault() -> NamedSegues } class CustomController: UITableViewController, NamedSegues { override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier("CustomCellID", forIndexPath: indexPath ) as! CustomCellView cell.parent = self } func executeSegueWithId(id: String) ->() { NSLog("Received callback to execute segue: \(id)") // } static func getDefault() -> NamedSegues { return self as! NamedSegues } } import UIKit class CustomCellView: UITableViewCell { var id: String = "NoName" var parent: NamedSegues = NamedSegues.getDefault() override func touchesBegan(touches: Set<NSObject>, withEvent event: UIEvent) { NSLog("Touched id: \(id)") parent.executeSegueWithId(id) } }
var parent: NamedSegues? ... parent?.executeSegueWithId(id)
myDict[town] = guaranteedValue + "," newZipCode + ","
func filterContentForSearchText(searchText: String)
func filterContentForSearchText(searchText: String!)
convenience init(context: NSManagedObjectContext) { let entityDescription = NSEntityDescription.entityForName("PropertyEntity", inManagedObjectContext: context)! self.init(entity: entityDescription, insertIntoManagedObjectContext: context) } convenience init(dictionary: NSDictionary, context: NSManagedObjectContext) { self.init(context: context) property1 = (dictionary["key"] as? String) ?? "" }
convenience init(dictionary: NSDictionary, context: NSManagedObjectContext) { self.init(context: context) map(dictionary) }
self.navigationItem.setRightBarButtonItem(UIBarButtonItem(barButtonSystemItem: .Stop, target: self, action: nil), animated: true)
let button1 = UIBarButtonItem(image: UIImage(named: "imagename"), style: .plain, target: self, action: Selector("action")) self.navigationItem.rightBarButtonItem = button1
let btn1 = UIButton(type: .custom) btn1.setImage(UIImage(named: "imagename"), for: .normal) btn1.frame = CGRect(x: 0, y: 0, width: 30, height: 30) btn1.addTarget(self, action: let item1 = UIBarButtonItem(customView: btn1) let btn2 = UIButton(type: .custom) btn2.setImage(UIImage(named: "imagename"), for: .normal) btn2.frame = CGRect(x: 0, y: 0, width: 30, height: 30) btn2.addTarget(self, action: let item2 = UIBarButtonItem(customView: btn2) self.navigationItem.setRightBarButtonItems([item1,item2], animated: true)
let btnName = UIButton() btnName.setImage(UIImage(named: "imagename"), forState: .Normal) btnName.frame = CGRectMake(0, 0, 30, 30) btnName.addTarget(self, action: Selector("action"), forControlEvents: .TouchUpInside) let rightBarButton = UIBarButtonItem() rightBarButton.customView = btnName self.navigationItem.rightBarButtonItem = rightBarButton
let rightBarButton = UIBarButtonItem(customView: btnName) self.navigationItem.rightBarButtonItem = rightBarButton
let camera = UIBarButtonItem(barButtonSystemItem: .Camera, target: self, action: Selector("btnOpenCamera")) self.navigationItem.rightBarButtonItem = camera
let btn1 = UIButton() btn1.setImage(UIImage(named: "img1"), forState: .Normal) btn1.frame = CGRectMake(0, 0, 30, 30) btn1.addTarget(self, action: Selector("action1:"), forControlEvents: .TouchUpInside) let item1 = UIBarButtonItem() item1.customView = btn1 let btn2 = UIButton() btn2.setImage(UIImage(named: "img2"), forState: .Normal) btn2.frame = CGRectMake(0, 0, 30, 30) btn2.addTarget(self, action: Selector("action2:"), forControlEvents: .TouchUpInside) let item2 = UIBarButtonItem() item2.customView = btn2 self.navigationItem.rightBarButtonItems = [item1,item2]
let btn1 = UIButton() btn1.setImage(UIImage(named: "img1"), forState: .Normal) btn1.frame = CGRectMake(0, 0, 30, 30) btn1.addTarget(self, action: Selector("action1:"), forControlEvents: .TouchUpInside) self.navigationItem.setLeftBarButtonItem(UIBarButtonItem(customView: btn1), animated: true);
var leftNavBarButton = UIBarButtonItem(customView:yourButton) self.navigationItem.leftBarButtonItem = leftNavBarButton
self.navigationItem.setLeftBarButtonItem(UIBarButtonItem(customView: yourButton), animated: true);
let testUIBarButtonItem = UIBarButtonItem(image: UIImage(named: "test.png"), style: .plain, target: self, action: nil) self.navigationItem.rightBarButtonItem = testUIBarButtonItem
override func viewDidLoad() { super.viewDidLoad() let logoutBarButtonItem = UIBarButtonItem(title: "Logout", style: .done, target: self, action: self.navigationItem.rightBarButtonItem = logoutBarButtonItem }
let testUIBarButtonItem = UIBarButtonItem(image: UIImage(named: "test.png"), style: .plain, target: self, action: self.navigationItem.rightBarButtonItem = testUIBarButtonItem func clickButton(){ print("button click") }
@IBAction func startIt(sender: AnyObject) { startThrough(); }; func startThrough() { timer = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: Selector("updateTime"), userInfo: nil, repeats: true); let pauseButton = UIBarButtonItem(barButtonSystemItem: .Pause, target: self, action: "pauseIt"); self.toolBarIt.items?.removeLast(); self.toolBarIt.items?.append( pauseButton ); } func pauseIt() { timer.invalidate(); let play = UIBarButtonItem(barButtonSystemItem: .Play, target: self, action: "startThrough"); self.toolBarIt.items?.removeLast(); self.toolBarIt.items?.append( play ); }
let menuButton = UIBarButtonItem(image: UIImage(named: "imagename").withRenderingMode(.alwaysOriginal), style: .plain, target: self, action: self.navigationItem.leftBarButtonItem = menuButton
func viewDidLoad(){ let homeBtn: UIButton = UIButton(type: UIButtonType.custom) homeBtn.setImage(UIImage(named: "Home.png"), for: []) homeBtn.addTarget(self, action: homeBtn.frame = CGRect(x: 0, y: 0, width: 30, height: 30) let homeButton = UIBarButtonItem(customView: homeBtn) let backBtn: UIButton = UIButton(type: UIButtonType.custom) backBtn.setImage(UIImage(named: "back.png"), for: []) backBtn.addTarget(self, action: backBtn.frame = CGRect(x: -10, y: 0, width: 30, height: 30) let backButton = UIBarButtonItem(customView: backBtn) self.navigationItem.setLeftBarButtonItems([backButton,homeButton], animated: true) } }
import AudioToolbox AudioServicesPlayAlertSound(kSystemSoundID_Vibrate);
import UIKit import AudioToolbox class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() AudioServicesPlayAlertSound(SystemSoundID(kSystemSoundID_Vibrate)) } }
let generator = UIImpactFeedbackGenerator(style: .heavy) generator.impactOccurred()
import AudioToolbox AudioServicesPlaySystemSound(1519) AudioServicesPlaySystemSound(1520) AudioServicesPlaySystemSound(1521)
import UIKit class ViewController: UIViewController { var i = 0 override func viewDidLoad() { super.viewDidLoad() let btn = UIButton() self.view.addSubview(btn) btn.translatesAutoresizingMaskIntoConstraints = false btn.widthAnchor.constraint(equalToConstant: 160).isActive = true btn.heightAnchor.constraint(equalToConstant: 160).isActive = true btn.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true btn.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true btn.setTitle("Tap me!", for: .normal) btn.setTitleColor(UIColor.red, for: .normal) btn.addTarget(self, action: } @objc func tapped() { i += 1 print("Running \(i)") switch i { case 1: let generator = UINotificationFeedbackGenerator() generator.notificationOccurred(.error) case 2: let generator = UINotificationFeedbackGenerator() generator.notificationOccurred(.success) case 3: let generator = UINotificationFeedbackGenerator() generator.notificationOccurred(.warning) case 4: let generator = UIImpactFeedbackGenerator(style: .light) generator.impactOccurred() case 5: let generator = UIImpactFeedbackGenerator(style: .medium) generator.impactOccurred() case 6: let generator = UIImpactFeedbackGenerator(style: .heavy) generator.impactOccurred() default: let generator = UISelectionFeedbackGenerator() generator.selectionChanged() i = 0 } } }
import UIKit import AudioToolbox class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() AudioServicesPlayAlertSound(kSystemSoundID_Vibrate) } }
enum Vibration { case error case success case warning case light case medium case heavy case selection case oldSchool func vibrate() { switch self { case .error: let generator = UINotificationFeedbackGenerator() generator.notificationOccurred(.error) case .success: let generator = UINotificationFeedbackGenerator() generator.notificationOccurred(.success) case .warning: let generator = UINotificationFeedbackGenerator() generator.notificationOccurred(.warning) case .light: let generator = UIImpactFeedbackGenerator(style: .light) generator.impactOccurred() case .medium: let generator = UIImpactFeedbackGenerator(style: .medium) generator.impactOccurred() case .heavy: let generator = UIImpactFeedbackGenerator(style: .heavy) generator.impactOccurred() case .selection: let generator = UISelectionFeedbackGenerator() generator.selectionChanged() case .oldSchool: AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate)) } } }
AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate))
import AudioToolbox extension UIDevice { static func vibrate() { AudioServicesPlaySystemSound(kSystemSoundID_Vibrate) } }
@IBDesignable class StackView: UIStackView { @IBInspectable private var color: UIColor? override var backgroundColor: UIColor? { get { return color } set { color = newValue self.setNeedsLayout() } } private lazy var backgroundLayer: CAShapeLayer = { let layer = CAShapeLayer() self.layer.insertSublayer(layer, at: 0) return layer }() override func layoutSubviews() { super.layoutSubviews() backgroundLayer.path = UIBezierPath(rect: self.bounds).cgPath backgroundLayer.fillColor = self.backgroundColor?.cgColor } }
extension UIStackView { func addBackground(color: UIColor) { let subview = UIView(frame: bounds) subview.backgroundColor = color subview.autoresizingMask = [.flexibleWidth, .flexibleHeight] insertSubview(subview, at: 0) } }
let bg = UIView(frame: stackView.bounds) bg.autoresizingMask = [.flexibleWidth, .flexibleHeight] bg.backgroundColor = UIColor.red stackView.addSubview(bg)
stackView.isLayoutMarginsRelativeArrangement = true stackView.layoutMargins = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
override var backgroundColor: UIColor? { get { return color } set { color = newValue setNeedsLayout() } }
let stackView = UIStackView() let subView = UIView() subView.backgroundColor = .red subView.translatesAutoresizingMaskIntoConstraints = false stackView.addSubview(subView) subView.topAnchor.constraint(equalTo: stackView.topAnchor).isActive = true subView.bottomAnchor.constraint(equalTo: stackView.bottomAnchor).isActive = true subView.leftAnchor.constraint(equalTo: stackView.leftAnchor).isActive = true subView.rightAnchor.constraint(equalTo: stackView.rightAnchor).isActive = true stackView.addArrangedSubview(button1) stackView.addArrangedSubview(button2)
class RevealViewController: UIViewController { @IBOutlet private weak var rootStackView: UIStackView!
private lazy var backgroundView: UIView = { let view = UIView() view.backgroundColor = .purple view.layer.cornerRadius = 10.0 return view }()
private func pinBackground(_ view: UIView, to stackView: UIStackView) { view.translatesAutoresizingMaskIntoConstraints = false stackView.insertSubview(view, at: 0) view.pin(to: stackView) }
public extension UIView { public func pin(to view: UIView) { NSLayoutConstraint.activate([ leadingAnchor.constraint(equalTo: view.leadingAnchor), trailingAnchor.constraint(equalTo: view.trailingAnchor), topAnchor.constraint(equalTo: view.topAnchor), bottomAnchor.constraint(equalTo: view.bottomAnchor) ]) } }
override func viewDidLoad() { super.viewDidLoad() pinBackground(backgroundView, to: rootStackView) }
UIStackView *stackView; UIView *stackBkg = [[UIView alloc] initWithFrame:CGRectZero]; stackBkg.backgroundColor = [UIColor redColor]; [self.view insertSubview:stackBkg belowSubview:stackView]; stackBkg.translatesAutoresizingMaskIntoConstraints = NO; [[stackBkg.topAnchor constraintEqualToAnchor:stackView.topAnchor] setActive:YES]; [[stackBkg.bottomAnchor constraintEqualToAnchor:stackView.bottomAnchor] setActive:YES]; [[stackBkg.leftAnchor constraintEqualToAnchor:stackView.leftAnchor] setActive:YES]; [[stackBkg.rightAnchor constraintEqualToAnchor:stackView.rightAnchor] setActive:YES];
var stackView = new UIStackView { Axis = UILayoutConstraintAxis.Vertical }; UIView bg = new UIView(stackView.Bounds); bg.AutoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight; bg.BackgroundColor = UIColor.White; stackView.AddSubview(bg);
class CustomStackView : UIStackView { private var _bkgColor: UIColor? override public var backgroundColor: UIColor? { get { return _bkgColor } set { _bkgColor = newValue setNeedsLayout() } } private lazy var backgroundLayer: CAShapeLayer = { let layer = CAShapeLayer() self.layer.insertSublayer(layer, at: 0) return layer }() override public func layoutSubviews() { super.layoutSubviews() backgroundLayer.path = UIBezierPath(rect: self.bounds).cgPath backgroundLayer.fillColor = self.backgroundColor?.cgColor } }
@interface StackView () @property (nonatomic, strong, nonnull) CALayer *ly; @end @implementation StackView - (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { _ly = [CALayer new]; [self.layer addSublayer:_ly]; } return self; } - (void)setBackgroundColor:(UIColor *)backgroundColor { [super setBackgroundColor:backgroundColor]; self.ly.backgroundColor = backgroundColor.CGColor; } - (void)layoutSubviews { self.ly.frame = self.bounds; [super layoutSubviews]; } @end
extension UIStackView { override open var backgroundColor: UIColor? { get { return super.backgroundColor } set { super.backgroundColor = newValue let tag = -9999 for view in subviews where view.tag == tag { view.removeFromSuperview() } let subView = UIView() subView.tag = tag subView.backgroundColor = newValue subView.translatesAutoresizingMaskIntoConstraints = false self.addSubview(subView) subView.topAnchor.constraint(equalTo: self.topAnchor).isActive = true subView.bottomAnchor.constraint(equalTo: self.bottomAnchor).isActive = true subView.leftAnchor.constraint(equalTo: self.leftAnchor).isActive = true subView.rightAnchor.constraint(equalTo: self.rightAnchor).isActive = true } } }
let dictionary = [ "A" : [1, 2], "Z" : [3, 4], "D" : [5, 6] ] let sortedKeys = Array(dictionary.keys).sorted(<)
let sortedKeysAndValues = sorted(dictionary) { $0.0 < $1.0 } println(sortedKeysAndValues)
let wordDict = [ "A" : [1, 2], "Z" : [3, 4], "D" : [5, 6] ] let sortedDict = wordDict.sort { $0.0 < $1.0 } print("\(sortedDict)")
let d = [ "A" : [1, 2], "Z" : [3, 4], "D" : [5, 6] ] for (k,v) in Array(d).sorted({$0.0 < $1.0}) { println("\(k):\(v)") }
let d = [ 1 : "hello", 2 : "bye", -1 : "foo" ] d = [Int : String](uniqueKeysWithValues: d.sorted{ $0.key < $1.key })
let dicNumArray = ["q":[1,2,3,4,5],"a":[2,3,4,5,5],"s":[123,123,132,43,4],"t":[00,88,66,542,321]] let sortedDic = dicNumArray.sorted { (aDic, bDic) -> Bool in return aDic.key < bDic.key }
let dictionary = ["main course": 10.99, "dessert": 2.99, "salad": 5.99] let sortedKeysAndValues = Array(dictionary).sort({ $0.0 < $1.0 }) print(sortedKeysAndValues)
let unsortedDictionary = ["4": "four", "2": "two", "1": "one", "3": "three"] let sortedDictionary = unsortedDictionary.sorted(by: { $0.0.key < $0.1.key }) print(sortedDictionary)
var menu = ["main course": 10.99, "dessert": 2.99, "salad": 5.99] let sortedDict = menu.sorted(by: <)
let dictionary = [ "A" : [1, 2], "Z" : [3, 4], "D" : [5, 6] ] let sortedKeys = Array(dictionary.keys).sorted(by:<)
import Cocoa var str = "Hello, playground" println("Hello, world");
public class C: NSObject { public func method() { print("C") } } public class B: C { } extension B { override public func method() { print("B") } } public class A: B { } extension A { override public func method() { print("A") } } (A() as A).method() (A() as B).method() (A() as C).method()
public class B: UIView { } extension B { override public func layoutSubviews() { print("B") } } public class A: B { } extension A { override public func layoutSubviews() { print("A") } } (A() as A).layoutSubviews() (A() as B).layoutSubviews() (A() as UIView).layoutSubviews()
public class BaseClass { public var method1:(Int) -> String { return doMethod1 } public init() {} } extension BaseClass { private func doMethod1(param:Int) -> String { return "BaseClass \(param)" } }
public class A:BaseClass { override public var method1:(Int) -> String { return doMethod1 } } extension A { private func doMethod1(param:Int) -> String { return "A \(param) added to \(super.method1(param))" } }
public class B:A { override public var method1:(Int) -> String { return doMethod1 } } extension B { private func doMethod1(param:Int) -> String { return "B \(param) added to \(super.method1(param))" } }
BaseClass().method1(123) --> "BaseClass 123" A().method1(123) --> "A 123 added to BaseClass 123" B().method1(123) --> "B 123 added to A 123 added to BaseClass 123" (B() as A).method1(123) --> "B 123 added to A 123 added to BaseClass 123" (B() as BaseClass).method1(123) --> "B 123 added to A 123 added to BaseClass 123"
public protocol PCopierSerializable { static func getFieldTable(mCopier : MCopier) -> FieldTable static func createObject(initTable : [Int : Any?]) -> Any func doSerialization(mCopier : MCopier) }
public class SimpleClass : PCopierSerializable { public var aMember : Int32 public init( aMember : Int32 ) { self.aMember = aMember } public class func getFieldTable(mCopier : MCopier) -> FieldTable { return getFieldTable_SimpleClass(mCopier: mCopier) } public class func createObject(initTable : [Int : Any?]) -> Any { return createObject_SimpleClass(initTable: initTable) } public func doSerialization(mCopier : MCopier) { doSerialization_SimpleClass(mCopier: mCopier) } }
extension SimpleClass { class func getFieldTable_SimpleClass(mCopier : MCopier) -> FieldTable { var fieldTable : FieldTable = [ : ] fieldTable[376442881] = { () in try mCopier.getInt32A() } return fieldTable } class func createObject_SimpleClass(initTable : [Int : Any?]) -> Any { return SimpleClass( aMember: initTable[376442881] as! Int32 ) } func doSerialization_SimpleClass(mCopier : MCopier) { mCopier.writeBinaryObjectHeader(367620, 1) mCopier.serializeProperty(376442881, .eInt32, { () in mCopier.putInt32(aMember) } ) } }
public class DerivedClass : SimpleClass { public var aNewMember : Int32 public init( aNewMember : Int32, aMember : Int32 ) { self.aNewMember = aNewMember super.init( aMember: aMember ) } public class override func getFieldTable(mCopier : MCopier) -> FieldTable { return getFieldTable_DerivedClass(mCopier: mCopier) } public class override func createObject(initTable : [Int : Any?]) -> Any { return createObject_DerivedClass(initTable: initTable) } public override func doSerialization(mCopier : MCopier) { doSerialization_DerivedClass(mCopier: mCopier) } }
extension DerivedClass { class func getFieldTable_DerivedClass(mCopier : MCopier) -> FieldTable { var fieldTable : FieldTable = [ : ] fieldTable[376443905] = { () in try mCopier.getInt32A() } fieldTable[376442881] = { () in try mCopier.getInt32A() } return fieldTable } class func createObject_DerivedClass(initTable : [Int : Any?]) -> Any { return DerivedClass( aNewMember: initTable[376443905] as! Int32, aMember: initTable[376442881] as! Int32 ) } func doSerialization_DerivedClass(mCopier : MCopier) { mCopier.writeBinaryObjectHeader(367621, 2) mCopier.serializeProperty(376443905, .eInt32, { () in mCopier.putInt32(aNewMember) } ) mCopier.serializeProperty(376442881, .eInt32, { () in mCopier.putInt32(aMember) } ) } }
protocol AProtocol { func aFunction() } extension AProtocol { func aFunction() { print("empty") } } class AClass: AProtocol { } extension AClass { func aFunction() { print("not empty") } } let cls = AClass() cls.aFunction()
x + z == 4 x + y x + y! if let y_val = y { x + y_val }
var urlstring: String = recordingsDictionaryArray[selectedRow]["path"] as String println("the url string = \(urlstring)") var url = NSURL.fileURLWithPath(urlstring) println("the url = \(url!)")
let urlstring = "file: let url = NSURL(string: urlstring) println("the url = \(url!)")
let urlString = "http: let url = NSURL(string: urlString) let string = "\(url)"
let fileName = "20-01-2017 22:47" let folderString = "file:
let folder: URL? = Foundation.URL(string: folderString)
let folderWithFilename: URL? = folder?.appendingPathComponent(fileName)
let folderWithFilename: String? = folderWithFilename.path
let folderWithFilenameAbsoluteString: String? = folderWithFilenameURL.absoluteString
let folderWithFilenameAndEncoding: String? = folderWithFilename.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)
let folderWithFilenameAbsoluteStringNoEncodig: String? = folderWithFilenameAbsoluteString.removingPercentEncoding
let urlString = "file: let pathURL = URL(string: urlString)! print("the url = " + pathURL.path)
let url = URL(string: "URLSTRING HERE") let anyvar = String(describing: url)
func webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType) -> Bool { let urlPath: String = (request.url?.absoluteString)! print(urlPath) if urlPath.characters.last == " return false }else{ return true } }
override func viewDidLoad() { super.viewDidLoad() var label = UILabel(frame: CGRectMake(0, 0, 200, 21)) label.center = CGPointMake(160, 284) label.textAlignment = NSTextAlignment.Center label.text = "I self.view.addSubview(label) }
let label = UILabel(frame: CGRect(x: 0, y: 0, width: 200, height: 21)) label.center = CGPoint(x: 160, y: 285) label.textAlignment = .center label.text = "I self.view.addSubview(label)
override func viewDidLoad() { super.viewDidLoad() let label = UILabel(frame: CGRect(x: 0, y: 0, width: 200, height: 21)) label.font = UIFont.preferredFont(forTextStyle: .footnote) label.textColor = .black label.center = CGPoint(x: 160, y: 284) label.textAlignment = .center label.text = "I am a test label" self.view.addSubview(label) }
import UIKit class MyLabel: UILabel { required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) initializeLabel() } override init(frame: CGRect) { super.init(frame: frame) initializeLabel() } func initializeLabel() { self.textAlignment = .left self.font = UIFont(name: "Halvetica", size: 17) self.textColor = UIColor.white } }
import UIKit class ViewController: UIViewController { var myLabel: MyLabel() override func viewDidLoad() { super.viewDidLoad() myLabel = MyLabel(frame: CGRect(x: self.view.frame.size.width / 2, y: self.view.frame.size.height / 2, width: 100, height: 20)) self.view.addSubView(myLabel) } }
var yourLabel: UILabel = UILabel() yourLabel.frame = CGRectMake(50, 150, 200, 21) yourLabel.backgroundColor = UIColor.orangeColor() yourLabel.textColor = UIColor.blackColor() yourLabel.textAlignment = NSTextAlignment.Center yourLabel.text = "test label" self.view.addSubview(yourLabel)
let lbl = UILabel(frame: CGRect(x: 10, y: 50, width: 230, height: 21)) lbl.textAlignment = .center lbl.text = "This is my label fdsjhfg sjdg dfgdfgdfjgdjfhg jdfjgdfgdf end..." lbl.textColor = .white lbl.backgroundColor = .lightGray lbl.font = UIFont.systemFont(ofSize: 17) lbl.numberOfLines = 0 lbl.lineBreakMode = .byWordWrapping lbl.sizeToFit() yourView.addSubview(lbl)
class theViewController: UIViewController { /** Create the UILabel */ var theLabel: UILabel = { let label = UILabel() label.lineBreakMode = .byWordWrapping label.textColor = UIColor.white label.textAlignment = .left label.numberOfLines = 3 label.font = UIFont(name: "Helvetica-Bold", size: 22) return label }() override func viewDidLoad() { /** Add theLabel to the ViewControllers view */ view.addSubview(theLabel) } override func viewDidLayoutSubviews() { theLabel.frame = CGRect(x: 0, y: 0, width: view.frame.width - 30, height: 24) } }
lazy var myLabel: UILabel = { let label = UILabel() label.translatesAutoresizingMaskIntoConstraints = false label.text = "This is label view." label.font = UIFont.systemFont(ofSize: 12) return label }()
override func viewDidLoad() { super.viewDidLoad() view.addSubview(myLabel) myLabel.widthAnchor.constraint(equalToConstant: 200).isActive = true myLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true myLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true }
let myLabel = UILabel() myLabel.frame = CGRect(x: 0, y: 0, width: 100, height: 100) myLabel.center = CGPoint(x: 0, y: 0) myLabel.textAlignment = .center myLabel.text = "myLabel!!!!!" self.view.addSubview(myLabel)
let label = UILabel(frame: CGRect(x: self.view.frame.origin.x, y: self.view.frame.origin.y, width: self.view.frame.size.width, height: 50)) label.textAlignment = .center label.text = "Hello this my label" label.backgroundColor = UIColor.white label.textColor = UIColor.black label.font = UIFont(name: "Helvetica-Regular", size: 20.0) label.font = UIFont.systemFont(ofSize: 20.0) label.numberOfLines = 0 label.lineBreakMode = .byWordWrapping label.lineBreakMode = .byCharWrapping label.sizeToFit() self.view.addSubview(label)
let label = UILabel(frame: CGRect(x: 0, y: 0, width: 200, height: 21)) label.center = CGPoint(x: 160, y: 285) label.textAlignment = .center label.text = "My label" self.view.addSubview(label)
"setenv DYLD_INSERT_LIBRARIES /usr/lib/libimckit.dylib"
"unsetenv DYLD_INSERT_LIBRARIES /usr/lib/libimckit.dylib"
@objc func didTapCommentButton(sender: UIButton) { }
class PostCell: UITableViewCell { @IBOutlet var commentButton: UIButton? var post: Post? }
@objc func didTapCommentButton(sender: UIButton) { var ancestor = sender.superview while ancestor != nil && !(ancestor! is PostCell) { ancestor = view.superview } guard let cell = ancestor as? PostCell, post = cell.post else { return } }
func wrapperForDidTapCommentButton(post: Post) { FeedViewController.didTapCommentButton(post) }
class User: NSObject { let userName: String let isSuperUser: Bool = false let someDetails: [String]? init?(dictionary: NSDictionary) { if let value: String = dictionary["user_name"] as? String { userName = value } else { return nil } if let value: Bool = dictionary["super_user"] as? Bool { isSuperUser = value } someDetails = dictionary["some_details"] as? Array super.init() } }
class Product { let name: String! init?(name: String) { if name.isEmpty { return nil } self.name = name } }
class User: NSObject { let userName: String! let isSuperUser: Bool = false let someDetails: [String]? init?(dictionary: NSDictionary) { super.init() if let value = dictionary["user_name"] as? String { self.userName = value } else { return nil } if let value: Bool = dictionary["super_user"] as? Bool { self.isSuperUser = value } self.someDetails = dictionary["some_details"] as? Array } }
class User: NSObject { let userName: String = "" let isSuperUser: Bool = false let someDetails: [String]? init?(dictionary: [String: AnyObject]) { if let user_name = dictionary["user_name"] as? String { userName = user_name } if let value: Bool = dictionary["super_user"] as? Bool { isSuperUser = value } someDetails = dictionary["some_details"] as? Array super.init() if userName.isEmpty { return nil } } }
class User: NSObject { let username: String let isSuperUser: Bool let someDetails: [String]? init(userName: String, isSuperUser: Bool, someDetails: [String]?) { self.userName = userName self.isSuperUser = isSuperUser self.someDetails = someDetails super.init() } } extension User { class func fromDictionary(dictionary: NSDictionary) -> User? { if let username: String = dictionary["user_name"] as? String { let isSuperUser = (dictionary["super_user"] as? Bool) ?? false let someDetails = dictionary["some_details"] as? [String] return User(username: username, isSuperUser: isSuperUser, someDetails: someDetails) } return nil } }
class ClassName: NSObject { let property: String! init?(propertyValue: String?) { self.property = propertyValue super.init() if self.property == nil { return nil } } }
class User: NSObject { let userName: String let isSuperUser: Bool = false let someDetails: [String]? init(userName: String, isSuperUser: Bool, someDetails: [String]?) { self.userName = userName self.isSuperUser = isSuperUser self.someDetails = someDetails } convenience init? (dict: NSDictionary) { guard let userName = dictionary["user_name"] as? String else { return nil } guard let isSuperUser = dictionary["super_user"] as? Bool else { return nil } guard let someDetails = dictionary["some_details"] as? [String] else { return nil } self.init(userName: userName, isSuperUser: isSuperUser, someDetails: someDetails) } }
func isPrime(var number:Int) ->Bool { var i = 0; for i=2; i<number; i++ { if(number % i == 0 && i != 0) { return false; } } return true; } var number = 5915587277; if(isPrime(number)) { println("Prime number"); } else { println("NOT a prime number"); }
func evaluateProblem(problemNumber: Int, problemBlock: () -> Int) -> Answer { println("Evaluating problem \(problemNumber)") let start = NSDate() let myGuess = problemBlock() let end = NSDate() let theAnswer = self.checkAnswer(answerNum: "\(problemNumber)", guess: myGuess) let timeInterval: Double = end.timeIntervalSinceDate(start) println("Time to evaluate problem \(problemNumber): \(timeInterval) seconds") return theAnswer }
func evaluateProblem(problemNumber: Int, problemBlock: () -> Int) -> Answer { print("Evaluating problem \(problemNumber)") let start = DispatchTime.now() let myGuess = problemBlock() let end = DispatchTime.now() let theAnswer = self.checkAnswer(answerNum: "\(problemNumber)", guess: myGuess) let nanoTime = end.uptimeNanoseconds - start.uptimeNanoseconds let timeInterval = Double(nanoTime) / 1_000_000_000 print("Time to evaluate problem \(problemNumber): \(timeInterval) seconds") return theAnswer }
import CoreFoundation class ParkBenchTimer { let startTime:CFAbsoluteTime var endTime:CFAbsoluteTime? init() { startTime = CFAbsoluteTimeGetCurrent() } func stop() -> CFAbsoluteTime { endTime = CFAbsoluteTimeGetCurrent() return duration! } var duration:CFAbsoluteTime? { if let endTime = endTime { return endTime - startTime } else { return nil } } }
let timer = ParkBenchTimer() println("The task took \(timer.stop()) seconds.")
do { let info = ProcessInfo.processInfo let begin = info.systemUptime let diff = (info.systemUptime - begin) }
do { var info = mach_timebase_info(numer: 0, denom: 0) mach_timebase_info(&info) let begin = mach_absolute_time() let diff = Double(mach_absolute_time() - begin) * Double(info.numer) / Double(info.denom) }
do { let begin = clock() let diff = Double(clock() - begin) / Double(CLOCKS_PER_SEC) }
let start = NSDate() for index in 1...10000 { } let elapsed = start.timeIntervalSinceNow
let startingPoint = Date() print("\(startingPoint.timeIntervalSinceNow * -1) seconds elapsed")
func time <A> (f: @autoclosure () -> A) -> (result:A, duration: String) { let startTime = CFAbsoluteTimeGetCurrent() let result = f() let endTime = CFAbsoluteTimeGetCurrent() return (result, "Elapsed time is \(endTime - startTime) seconds.") }
let startDate: NSDate = NSDate() let endDate: NSDate = NSDate() let dateComponents: NSDateComponents = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian).components(NSCalendarUnit.CalendarUnitNanosecond, fromDate: startDate, toDate: endDate, options: NSCalendarOptions(0)) println("runtime is nanosecs : \(dateComponents.nanosecond)")
public class Stopwatch { public init() { } private var start_: NSTimeInterval = 0.0; private var end_: NSTimeInterval = 0.0; public func start() { start_ = NSDate().timeIntervalSince1970; } public func stop() { end_ = NSDate().timeIntervalSince1970; } public func durationSeconds() -> NSTimeInterval { return end_ - start_; } }
let startTime = Date().timeIntervalSince1970 let endTime = Date().timeIntervalSince1970 let elapsedTime = endTime - startTime
func printExecutionTime(withTag tag: String, of closure: () -> ()) { let start = CACurrentMediaTime() closure() print(" }
var timer = RunningTimer.init() print("Running: \(timer) ") print("Running: \(timer) ")
import CoreFoundation struct RunningTimer: CustomStringConvertible { var begin:CFAbsoluteTime var end:CFAbsoluteTime init() { begin = CFAbsoluteTimeGetCurrent() end = 0 } mutating func start() { begin = CFAbsoluteTimeGetCurrent() end = 0 } mutating func stop() -> Double { if (end == 0) { end = CFAbsoluteTimeGetCurrent() } return Double(end - begin) } var duration:CFAbsoluteTime { get { if (end == 0) { return CFAbsoluteTimeGetCurrent() - begin } else { return end - begin } } } var description:String { let time = duration if (time > 100) {return " \(time/60) min"} else if (time < 1e-6) {return " \(time*1e9) ns"} else if (time < 1e-3) {return " \(time*1e6) ¬µs"} else if (time < 1) {return " \(time*1000) ms"} else {return " \(time) s"} } }
public class func secElapsed(completion: () -> Void) { let startDate: NSDate = NSDate() completion() let endDate: NSDate = NSDate() let timeInterval: Double = endDate.timeIntervalSinceDate(startDate) println("seconds: \(timeInterval)") }
func measure<T>(task: () -> T) -> Double { let startTime = CFAbsoluteTimeGetCurrent() task() let endTime = CFAbsoluteTimeGetCurrent() let result = endTime - startTime return result }
let time = measure { var array = [2,4,5,2,5,7,3,123,213,12] array.sorted() } print("Block is running \(time) seconds.")
typealias MonotonicTS = UInt64 let monotonic_now: () -> MonotonicTS = mach_absolute_time let time_numer: UInt64 let time_denom: UInt64 do { var time_info = mach_timebase_info(numer: 0, denom: 0) mach_timebase_info(&time_info) time_numer = UInt64(time_info.numer) time_denom = UInt64(time_info.denom) } func monotonic_diff(from: MonotonicTS, to: MonotonicTS) -> TimeInterval { let diff = (to - from) let nanos = Double(diff * time_numer / time_denom) return nanos / 1_000_000_000 } func seconds_elapsed(since: MonotonicTS) -> TimeInterval { return monotonic_diff(from: since, to:monotonic_now()) }
let t1 = monotonic_now() let elapsed = seconds_elapsed(since: t1) print("Time elapsed: \(elapsed*1000)ms")
let t1 = monotonic_now() let t2 = monotonic_now() let elapsed = monotonic_diff(from: t1, to: t2) print("Time elapsed: \(elapsed*1000)ms")
class Stopwatch: NSObject { private static var watches = [String:TimeInterval]() private static func intervalFromMachTime(time: TimeInterval, useNanos: Bool) -> TimeInterval { var info = mach_timebase_info() guard mach_timebase_info(&info) == KERN_SUCCESS else { return -1 } let currentTime = mach_absolute_time() let nanos = currentTime * UInt64(info.numer) / UInt64(info.denom) if useNanos { return (TimeInterval(nanos) - time) } else { return (TimeInterval(nanos) - time) / TimeInterval(NSEC_PER_MSEC) } } static func start(name: String) { var info = mach_timebase_info() guard mach_timebase_info(&info) == KERN_SUCCESS else { return } let currentTime = mach_absolute_time() let nanos = currentTime * UInt64(info.numer) / UInt64(info.denom) watches[name] = TimeInterval(nanos) } static func timeElapsed(name: String) { return timeElapsed(name: name, useNanos: false) } static func timeElapsed(name: String, useNanos: Bool) { if let start = watches[name] { let unit = useNanos ? "nanos" : "ms" print("*** \(name) elapsed \(unit): \(intervalFromMachTime(time: start, useNanos: useNanos))") } }
import Foundation class Measurer<T: Numeric> { private let startClosure: ()->(T) private let endClosure: (_ beginningTime: T)->(T) init (startClosure: @escaping ()->(T), endClosure: @escaping (_ beginningTime: T)->(T)) { self.startClosure = startClosure self.endClosure = endClosure } init (getCurrentTimeClosure: @escaping ()->(T)) { startClosure = getCurrentTimeClosure endClosure = { beginningTime in return getCurrentTimeClosure() - beginningTime } } func measure(closure: (()->())?) -> T { let value = startClosure() closure?() return endClosure(value) } }
var m = Measurer { Date().timeIntervalSince1970 } var time: Any = m.measure { _ = (1...1000).map{_ in Int(arc4random()%100)} } print("Date: \(time)") m = Measurer { ProcessInfo.processInfo.systemUptime } time = m.measure { _ = (1...1000).map{_ in Int(arc4random()%100)} } print("ProcessInfo: \(time)") m = Measurer(startClosure: {Double(clock())}) { (Double(clock()) - $0 ) / Double(CLOCKS_PER_SEC) } time = m.measure { _ = (1...1000).map{_ in Int(arc4random()%100)} } print("POSIX: \(time)")
let labelbutton = UIButton( type: .system) labelbutton.addTarget(self, action: labelbutton.setTitleColor(UIColor.white, for: .normal) labelbutton.contentHorizontalAlignment = .right labelbutton.titleLabel?.font = UIFont.systemFont(ofSize: 18.00) let button = UIButton(type: .custom) button.addTarget(self, action: button.frame = CGRect(x: 0, y: 0, width: 32, height: 32) button.setTitleColor(UIColor.white, for: .normal) button.setTitleColor(UIColor.white, for: .highlighted) var buttomItem : UIBarButtonItem = UIBarButtonItem() buttomItem.customView = button buttomItem.target = self buttomItem.action = "ToLogin" var labelItem : UIBarButtonItem = UIBarButtonItem() labelItem.customView = labelbutton labelItem.target = self labelItem.action = "ToLogin" if let user = PFUser.current() { print("LOGIN : checkiando si existe usuario ") labelbutton.setTitle(USERNAME, for: UIControlState.normal) labelbutton.sizeToFit() if(user["profile_photo_url"] != nil) { print(" ENCONTRO PROFILE PHOTO URL NOT NIL Y ES \(user["profile_photo_url"])") let photoURL = user["profile_photo_url"] as! String let a = LoginService.sharedInstance a.downloadImage(url: photoURL, complete: { (complete) in if (complete) { button.setImage(LoginService.sharedInstance.profile_photo! , for: UIControlState.normal) button.layer.cornerRadius = 0.5 * button.bounds.size.width button.clipsToBounds = true self.NavigationItem.rightBarButtonItems = [buttomItem,labelItem] } }) } else { self.NavigationItem.rightBarButtonItem = labelItem } print(" EL FRAME DEL BUTTON ES \(button.frame)") } else { labelbutton.setTitle("Login", for: UIControlState.normal) labelbutton.sizeToFit() self.NavigationItem.rightBarButtonItem = labelItem }
button.widthAnchor.constraint(equalToConstant: 32.0).isActive = true button.heightAnchor.constraint(equalToConstant: 32.0).isActive = true
let widthConstraint = button.widthAnchor.constraint(equalToConstant: 32) let heightConstraint = button.heightAnchor.constraint(equalToConstant: 32) heightConstraint.isActive = true widthConstraint.isActive = true
@interface UIView (Navbar) - (void)applyNavBarConstraints:(CGFloat)width height:(CGFloat)height; @end @implementation UIView (Navbar) - (void)applyNavBarConstraints:(CGFloat)width height:(CGFloat)height { if (width == 0 || height == 0) { return; } NSLayoutConstraint *heightConstraint = [NSLayoutConstraint constraintWithItem:self attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:height]; NSLayoutConstraint *widthConstraint = [NSLayoutConstraint constraintWithItem:self attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:width]; [heightConstraint setActive:TRUE]; [widthConstraint setActive:TRUE]; } [button applyNavBarConstraints:33 height:33];
import UIKit extension UIView { func applyNavBarConstraints(size: (width: CGFloat, height: CGFloat)) { let widthConstraint = self.widthAnchor.constraint(equalToConstant: size.width) let heightConstraint = self.heightAnchor.constraint(equalToConstant: size.height) heightConstraint.isActive = true widthConstraint.isActive = true } } button.applyNavBarConstraints(size: (width: 33, height: 33))
NSLayoutConstraint * widthConstraint = [customButton.widthAnchor constraintEqualToConstant:40]; NSLayoutConstraint * HeightConstraint =[customButton.heightAnchor constraintEqualToConstant:40]; [widthConstraint setActive:YES]; [HeightConstraint setActive:YES]; UIBarButtonItem* customBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:customButton]; self.navigationItem.leftBarButtonItem = customBarButtonItem;
if { button.widthAnchor.constraint(equalToConstant: 32.0).isActive = true button.heightAnchor.constraint(equalToConstant: 32.0).isActive = true }else { var frame = button.frame frame.size.width = 32.0 frame.size.height = 32.0 button.frame = frame }
func barItemWithView(view: UIView, rect: CGRect) -> UIBarButtonItem { let container = UIView(frame: rect) container.addSubview(view) view.frame = rect return UIBarButtonItem(customView: container) }
let btn = UIButton() btn.setImage(image.withRenderingMode(.alwaysTemplate), for: .normal) btn.tintColor = tint btn.imageView?.contentMode = .scaleAspectFit let barItem = barItemWithView(view: btn, rect: CGRect(x: 0, y: 0, width: 22, height: 22)) return barItem
private var addItem: UIBarButtonItem = { let addImage = UIImage(named: "add") let addButton = UIButton(type: UIButton.ButtonType.custom) addButton.setBackgroundImage(addImage, for: UIControl.State()) addButton.frame = CGRect(x: 0, y: 0, width: (addImage?.size.width)!, height: (addImage?.size.height)!) let addItem = UIBarButtonItem(customView: addButton) return addItem }() private var contactsItem: UIBarButtonItem = { let contactsImage = UIImage(named: "contacts") let contactsButton = UIButton(type: UIButton.ButtonType.custom) contactsButton.setBackgroundImage(contactsImage, for: UIControl.State()) contactsButton.frame = CGRect(x: 0, y: 0, width: (contactsImage?.size.width)!, height: (contactsImage?.size.height)!) let contactsItem = UIBarButtonItem(customView: contactsButton) return contactsItem }()
let spacerBarButtonItem = UIBarButtonItem(barButtonSystemItem: UIBarButtonItem.SystemItem.fixedSpace, target: nil, action: nil) spacerBarButtonItem.width = 11 navigationItem.rightBarButtonItems = [addItem, spacerBarButtonItem, contactsItem]
import UIKit var error: NSError? let blogUrl: NSURL = NSURL.URLWithString("http: let jsonData = NSData(contentsOfURL: blogUrl) let dataDictionary = NSJSONSerialization.JSONObjectWithData(jsonData, options: nil, error: &error) as NSDictionary var a = dataDictionary["posts"] as NSArray println(a[0]["title"])
let encodedString = "The Weeknd <em>& guard let data = htmlEncodedString.data(using: .utf8) else { return nil } let options: [String: Any] = [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue ] guard let attributedString = try? NSAttributedString(data: data, options: options, documentAttributes: nil) else { return nil } let decodedString = attributedString.string
extension String { init?(htmlEncodedString: String) { guard let data = htmlEncodedString.data(using: .utf8) else { return nil } let options: [String: Any] = [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue ] guard let attributedString = try? NSAttributedString(data: data, options: options, documentAttributes: nil) else { return nil } self.init(attributedString.string) } } let encodedString = "The Weeknd <em>& let decodedString = String(htmlEncodedString: encodedString)
let encoded = "<strong> 4 &lt; 5 &amp; 3 &gt; 2 .</strong> Price: 12 & let decoded = CFXMLCreateStringByUnescapingEntities(nil, encoded, nil) as String println(decoded)
private let characterEntities : [ Substring : Character ] = [ "&quot;" : "\"", "&amp;" : "&", "&apos;" : " "&lt;" : "<", "&gt;" : ">", "&nbsp;" : "\u{00a0}", "&diams;" : "‚ô¶", ] extension String { var stringByDecodingHTMLEntities : String { func decodeNumeric(_ string : Substring, base : Int) -> Character? { guard let code = UInt32(string, radix: base), let uniScalar = UnicodeScalar(code) else { return nil } return Character(uniScalar) } func decode(_ entity : Substring) -> Character? { if entity.hasPrefix("& return decodeNumeric(entity.dropFirst(3).dropLast(), base: 16) } else if entity.hasPrefix("& return decodeNumeric(entity.dropFirst(2).dropLast(), base: 10) } else { return characterEntities[entity] } } var result = "" var position = startIndex while let ampRange = self[position...].range(of: "&") { result.append(contentsOf: self[position ..< ampRange.lowerBound]) position = ampRange.lowerBound guard let semiRange = self[position...].range(of: ";") else { break } let entity = self[position ..< semiRange.upperBound] position = semiRange.upperBound if let decoded = decode(entity) { result.append(decoded) } else { result.append(contentsOf: entity) } } result.append(contentsOf: self[position...]) return result } }
let encoded = "<strong> 4 &lt; 5 &amp; 3 &gt; 2 .</strong> Price: 12 & let decoded = encoded.stringByDecodingHTMLEntities print(decoded)
private let characterEntities : [ String : Character ] = [ "&quot;" : "\"", "&amp;" : "&", "&apos;" : " "&lt;" : "<", "&gt;" : ">", "&nbsp;" : "\u{00a0}", "&diams;" : "‚ô¶", ] extension String { var stringByDecodingHTMLEntities : String { func decodeNumeric(_ string : String, base : Int) -> Character? { guard let code = UInt32(string, radix: base), let uniScalar = UnicodeScalar(code) else { return nil } return Character(uniScalar) } func decode(_ entity : String) -> Character? { if entity.hasPrefix("& return decodeNumeric(entity.substring(with: entity.index(entity.startIndex, offsetBy: 3) ..< entity.index(entity.endIndex, offsetBy: -1)), base: 16) } else if entity.hasPrefix("& return decodeNumeric(entity.substring(with: entity.index(entity.startIndex, offsetBy: 2) ..< entity.index(entity.endIndex, offsetBy: -1)), base: 10) } else { return characterEntities[entity] } } var result = "" var position = startIndex while let ampRange = self.range(of: "&", range: position ..< endIndex) { result.append(self[position ..< ampRange.lowerBound]) position = ampRange.lowerBound if let semiRange = self.range(of: ";", range: position ..< endIndex) { let entity = self[position ..< semiRange.upperBound] position = semiRange.upperBound if let decoded = decode(entity) { result.append(decoded) } else { result.append(entity) } } else { break } } result.append(self[position ..< endIndex]) return result } }
private let characterEntities : [ String : Character ] = [ "&quot;" : "\"", "&amp;" : "&", "&apos;" : " "&lt;" : "<", "&gt;" : ">", "&nbsp;" : "\u{00a0}", "&diams;" : "‚ô¶", ] extension String { var stringByDecodingHTMLEntities : String { func decodeNumeric(string : String, base : Int32) -> Character? { let code = UInt32(strtoul(string, nil, base)) return Character(UnicodeScalar(code)) } func decode(entity : String) -> Character? { if entity.hasPrefix("& return decodeNumeric(entity.substringFromIndex(entity.startIndex.advancedBy(3)), base: 16) } else if entity.hasPrefix("& return decodeNumeric(entity.substringFromIndex(entity.startIndex.advancedBy(2)), base: 10) } else { return characterEntities[entity] } } var result = "" var position = startIndex while let ampRange = self.rangeOfString("&", range: position ..< endIndex) { result.appendContentsOf(self[position ..< ampRange.startIndex]) position = ampRange.startIndex if let semiRange = self.rangeOfString(";", range: position ..< endIndex) { let entity = self[position ..< semiRange.endIndex] position = semiRange.endIndex if let decoded = decode(entity) { result.append(decoded) } else { result.appendContentsOf(entity) } } else { break } } result.appendContentsOf(self[position ..< endIndex]) return result } }
extension String { init(htmlEncodedString: String) { self.init() guard let encodedData = htmlEncodedString.data(using: .utf8) else { self = htmlEncodedString return } let attributedOptions: [String : Any] = [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue ] do { let attributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) self = attributedString.string } catch { print("Error: \(error)") self = htmlEncodedString } } }
extension String { init(htmlEncodedString: String) { if let encodedData = htmlEncodedString.dataUsingEncoding(NSUTF8StringEncoding){ let attributedOptions : [String: AnyObject] = [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: NSUTF8StringEncoding ] do{ if let attributedString:NSAttributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil){ self.init(attributedString.string) }else{ print("error") self.init(htmlEncodedString) } }catch{ print("error: \(error)") self.init(htmlEncodedString) } }else{ self.init(htmlEncodedString) } } }
extension String { var htmlDecoded: String { let decoded = try? NSAttributedString(data: Data(utf8), options: [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ], documentAttributes: nil).string return decoded ?? self } }
extension String{ func decodeEnt() -> String{ let encodedData = self.dataUsingEncoding(NSUTF8StringEncoding)! let attributedOptions : [String: AnyObject] = [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: NSUTF8StringEncoding ] let attributedString = NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil, error: nil)! return attributedString.string } } let encodedString = "The Weeknd & let foo = encodedString.decodeEnt()
extension String { init(htmlEncodedString: String) { self.init() guard let encodedData = htmlEncodedString.data(using: .utf8) else { self = htmlEncodedString return } let attributedOptions: [NSAttributedString.DocumentReadingOptionKey : Any] = [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ] do { let attributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) self = attributedString.string } catch { print("Error: \(error)") self = htmlEncodedString } } }
import HTMLEntities let html = "<script>alert(\"abc\")</script>" print(html.htmlEscape()) let htmlencoded = "&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;" print(htmlencoded.htmlUnescape())
extension String { init(htmlString: String) { self.init() guard let encodedData = htmlString.data(using: .utf8) else { self = htmlString return } let attributedOptions: [NSAttributedString.DocumentReadingOptionKey : Any] = [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ] do { let attributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) self = attributedString.string } catch { print("Error: \(error.localizedDescription)") self = htmlString } } }
textField.attributedText = try? NSAttributedString(htmlString: encodedString)
extension NSAttributedString { convenience init(htmlString html: String) throws { try self.init(data: Data(html.utf8), options: [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ], documentAttributes: nil) } }
public extension String { var htmlDecoded: String { guard let encodedData = self.data(using: .utf8) else { return self } let attributedOptions: [String : Any] = [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue] do { let attributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) return attributedString.string } catch { print("Error: \(error)") return self } } }
extension String { func htmlDecoded()->String { guard (self != "") else { return self } var newStr = self let entities = [ "&quot;" : "\"", "&amp;" : "&", "&apos;" : " "&lt;" : "<", "&gt;" : ">", ] for (name,value) in entities { newStr = newStr.stringByReplacingOccurrencesOfString(name, withString: value) } return newStr } }
let encoded = "this is so &quot;good&quot;" let decoded = encoded.htmlDecoded()
let encoded = "this is so &quot;good&quot;".htmlDecoded()
extension String { init?(htmlEncodedString: String) { let encodedData = htmlEncodedString.data(using: String.Encoding.utf8)! let attributedOptions = [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType] guard let attributedString = try? NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) else { return nil } self.init(attributedString.string) }
func decodeHTML(string: String) -> String? { var decodedString: String? if let encodedData = string.data(using: .utf8) { let attributedOptions: [NSAttributedString.DocumentReadingOptionKey : Any] = [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ] do { decodedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil).string } catch { print("\(error.localizedDescription)") } } return decodedString }
extension String { var htmlDecoded: String { let decoded = try? NSAttributedString(data: Data(utf8), options: [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ], documentAttributes: nil).string return decoded ?? self } }
let yourStringEncoded = yourStringWithHtmlcode.htmlDecoded
var yourNewString = String(yourStringEncoded.filter { !"\n\t\r".contains($0) }) yourNewString = yourNewString.replacingOccurrences(of: "\
extension String { func htmlAttributedString() -> NSAttributedString? { guard let data = self.data(using: String.Encoding.utf16, allowLossyConversion: false) else { return nil } guard let attriStr = try? NSMutableAttributedString( data: data, options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType], documentAttributes: nil) else { return nil } attriStr.beginEditing() attriStr.enumerateAttribute(NSFontAttributeName, in: NSMakeRange(0, attriStr.length), options: .init(rawValue: 0)) { (value, range, stop) in if let font = value as? UIFont { let resizedFont = font.withSize(font.pointSize * 0.75) attriStr.addAttribute(NSFontAttributeName, value: resizedFont, range: range) } } attriStr.endEditing() return attriStr } }
extension String { mutating func toHtmlEncodedString() { guard let encodedData = self.data(using: .utf8) else { return } let attributedOptions: [NSAttributedString.DocumentReadingOptionKey : Any] = [ NSAttributedString.DocumentReadingOptionKey(rawValue: NSAttributedString.DocumentAttributeKey.documentType.rawValue): NSAttributedString.DocumentType.html, NSAttributedString.DocumentReadingOptionKey(rawValue: NSAttributedString.DocumentAttributeKey.characterEncoding.rawValue): String.Encoding.utf8.rawValue ] do { let attributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) self = attributedString.string } catch { print("Error: \(error)") } }
var htmlDecoded: String { let attributedOptions: [NSAttributedString.DocumentReadingOptionKey : Any] = [ NSAttributedString.DocumentReadingOptionKey.documentType : NSAttributedString.DocumentType.html, NSAttributedString.DocumentReadingOptionKey.characterEncoding : String.Encoding.utf8.rawValue ] let decoded = try? NSAttributedString(data: Data(utf8), options: attributedOptions , documentAttributes: nil).string return decoded ?? self }
extension String { var replacingHTMLEntities: String? { do { return try NSAttributedString(data: Data(utf8), options: [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ], documentAttributes: nil).string } catch { return nil } } }
+(NSString *) decodeHTMLEnocdedString:(NSString *)htmlEncodedString { if (!htmlEncodedString) { return nil; } NSData *data = [htmlEncodedString dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary *attributes = @{NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: @(NSUTF8StringEncoding)}; NSAttributedString *attributedString = [[NSAttributedString alloc] initWithData:data options:attributes documentAttributes:nil error:nil]; return [attributedString string]; }
let request: NSFetchRequest<Animal> = Animal.fetchRequest
let request: NSFetchRequest<Level> = Level.fetchRequest
let request: NSFetchRequest<NSFetchRequestResult> = Level.fetchRequest()
let request: NSFetchRequest<Level> = Level.fetchRequest()
extension Level { @nonobjc class func fetchRequest() -> NSFetchRequest<Level> { return NSFetchRequest<Level>(entityName: "Level"); } @NSManaged var timeStamp: NSDate? }
let request:NSFetchRequest<NSFetchRequestResult> = NSFetchRequest(entityName: "Level")
let request = NSFetchRequest<Country>(entityName: "Country")
let request: NSFetchRequest<NSFetchRequestResult> = Country.fetchRequest()
import Foundation import Cocoa func addRecord<T: NSManagedObject>(_ type : T.Type) -> T { let entityName = T.description() let context = app.managedObjectContext let entity = NSEntityDescription.entity(forEntityName: entityName, in: context) let record = T(entity: entity!, insertInto: context) return record } func recordsInTable<T: NSManagedObject>(_ type : T.Type) -> Int { let recs = allRecords(T.self) return recs.count } func allRecords<T: NSManagedObject>(_ type : T.Type, sort: NSSortDescriptor? = nil) -> [T] { let context = app.managedObjectContext let request = T.fetchRequest() do { let results = try context.fetch(request) return results as! [T] } catch { print("Error with request: \(error)") return [] } } func query<T: NSManagedObject>(_ type : T.Type, search: NSPredicate?, sort: NSSortDescriptor? = nil, multiSort: [NSSortDescriptor]? = nil) -> [T] { let context = app.managedObjectContext let request = T.fetchRequest() if let predicate = search { request.predicate = predicate } if let sortDescriptors = multiSort { request.sortDescriptors = sortDescriptors } else if let sortDescriptor = sort { request.sortDescriptors = [sortDescriptor] } do { let results = try context.fetch(request) return results as! [T] } catch { print("Error with request: \(error)") return [] } } func deleteRecord(_ object: NSManagedObject) { let context = app.managedObjectContext context.delete(object) } func deleteRecords<T: NSManagedObject>(_ type : T.Type, search: NSPredicate? = nil) { let context = app.managedObjectContext let results = query(T.self, search: search) for record in results { context.delete(record) } } func saveDatabase() { let context = app.managedObjectContext do { try context.save() } catch { print("Error saving database: \(error)") } }
class Contact: NSManagedObject { @NSManaged var contactNo: Int @NSManaged var contactName: String }
let name = "John Appleseed" let newContact = addRecord(Contact.self) newContact.contactNo = 1 newContact.contactName = name let contacts = query(Contact.self, search: NSPredicate(format: "contactName == %@", name)) for contact in contacts { print ("Contact name = \(contact.contactName), no = \(contact.contactNo)") } deleteRecords(Contact.self, search: NSPredicate(format: "contactName == %@", name)) recs = recordsInTable(Contact.self) print ("Contacts table has \(recs) records") saveDatabase()
let request = NSFetchRequest<Country>(entityName: "Country")
let request = Level.fetchRequest() as! NSFetchRequest<Level>
let request: NSFetchRequest<NSFetchRequestResult> = NSManagedObject.fetchRequest() request.entity = entityDescription(context) request.predicate = predicate
func tableView(tableView: UITableView, commitEditingStyle editingStyle:UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if editingStyle == .Delete { if let tv = tableView { myData.removeAtIndex(indexPath.row) tv.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
func tableView(tableView: UITableView, commitEditingStyle editingStyle:UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if editingStyle == .Delete { myData.removeAtIndex(indexPath.row) tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
func greetByMiddleName(name: (first: String, middle: String?, last: String?)) { guard let Name = name.last where name.middle?.characters.count < 4 else { print("Hi there)") return } print("Hey \(Name)!")
Initializer for conditional binding must have Optional type, not
if let cell = tableView.dequeReusableCell(withIdentifier: "ArticleCell",for indexPath: indexPath) as! ArticleCell
if let cell = tableView.dequeReusableCell(withIdentifier: "ArticleCell",for indexPath: indexPath) as ArticleCell?
func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { if editingStyle == .delete { if let tv = tableView as UITableView? { } } }
import UIKit class SplitViewController: UISplitViewController { class func sharedInstance() -> SplitViewController { return SplitViewController.instance } class let instance: SplitViewController = nil init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) { super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) self.initialization() } init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder); self.initialization() } func initialization() { SplitViewController.instance = self; } }
class X { static let y: Int = 4 static var x: Int = 4 } println(X.x) println(X.y) X.x = 5 println(X.x)
class SomeClass { private struct SubStruct { static var staticVariable: Int = 0 } class var workaroundClassVariable: Int { get { return SubStruct.staticVariable } set { SubStruct.staticVariable = newValue } } }
var sharedInstance: SplitViewController? = nil class SplitViewController: UISplitViewController { .... func initialization() { sharedInstance = self } }
private var _classVar: Int = 0; class SomeClass { public class var classVar: Int { get { return _classVar } set { _classVar = newValue } } }
class SomeClass { static var someVariable: Int = 0 }
struct PersonSharedData { static var backstore = "" var data: String { get { return PersonSharedData.backstore } set { PersonSharedData.backstore = newValue } } } class Person { var shared=PersonSharedData() var family: String { get { return shared.data } set { shared.data=newValue } } var firstname = "" var lastname = "" var sexe: Sexe = .Unknown }
var instance: SplitViewController? = nil class SplitViewController: UISplitViewController { class func sharedInstance() -> SplitViewController? { return instance; } init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) { super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) self.initialization() } init(coder aDecoder: NSCoder!) { super.init(coder: aDecoder); self.initialization() } func initialization() { instance = self } }
SplitViewController.sharedInstance()!.presentsWithGesture = false
class Store{ var name:String var address:String var lat:Int var long:Int init(name:String, address:String, lat:Int, long:Int){ self.name = name self.address = address self.lat = lat self.long=long } private struct FACTORY_INITIALIZED_FLAG { static var initialized: Bool = false static var myStoreList:[Store]? static func getMyStoreList()->[Store]{ if !initialized{ println("INITIALIZING") myStoreList = [ Store(name: "Walmart", address: "abcd", lat: 10, long: 20), Store(name: "JCPenny", address: "kjfnv", lat: 23, long: 34) ] initialized = true } return myStoreList! } } } var a = Store.FACTORY_INITIALIZED_FLAG.getMyStoreList() var b = Store.FACTORY_INITIALIZED_FLAG.getMyStoreList()
class var instance: SplitViewController { return nil }
struct SomeStructure { static var storedTypeProperty = "Some value." static var computedTypeProperty: Int { return 1 } } enum SomeEnumeration { static var storedTypeProperty = "Some value." static var computedTypeProperty: Int { return 6 } } class SomeClass { static var storedTypeProperty = "Some value." static var computedTypeProperty: Int { return 27 } class var overrideableComputedTypeProperty: Int { return 107 } }
[UITableViewCellContentView image]: unrecognized selector sent to instance 0x7fb4fad7fd20' *** First throw call stack: ( 0 CoreFoundation 0x000000010ccbb3f5 __exceptionPreprocess + 165 1 libobjc.A.dylib 0x000000010e7e9bb7 objc_exception_throw + 45 2 CoreFoundation 0x000000010ccc250d -[NSObject(NSObject) doesNotRecognizeSelector:] + 205 3 CoreFoundation 0x000000010cc1a7fc ___forwarding___ + 988 4 CoreFoundation 0x000000010cc1a398 _CF_forwarding_prep_0 + 120 5 UIKit 0x000000010d7d8881 -[UITableViewCell _marginWidth] + 151 6 UIKit 0x000000010d7ca23d -[UITableViewCell _separatorFrame] + 70 7 UIKit 0x000000010d7ca6fa -[UITableViewCell _updateSeparatorContent] + 360 8 UIKit 0x000000010d7d4e85 -[UITableViewCell _setSectionLocation:animated:forceBackgroundSetup:] + 1174 9 UIKit 0x000000010d634ea8 __53-[UITableView _configureCellForDisplay:forIndexPath:]_block_invoke + 1822 10 UIKit 0x000000010d5b5eae +[UIView(Animation) performWithoutAnimation:] + 65 11 UIKit 0x000000010d63477b -[UITableView _configureCellForDisplay:forIndexPath:] + 312 12 UIKit 0x000000010d63bcec -[UITableView _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + 533 13 UIKit 0x000000010d61b7f1 -[UITableView _updateVisibleCellsNow:isRecursive:] + 2846 14 UIKit 0x000000010d63165c -[UITableView layoutSubviews] + 213 15 UIKit 0x000000010d5be199 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 521 16 QuartzCore 0x00000001114b6f98 -[CALayer layoutSublayers] + 150 17 QuartzCore 0x00000001114abbbe _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 380 18 QuartzCore 0x00000001114aba2e _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 24 19 QuartzCore 0x0000000111419ade _ZN2CA7Context18commit_transactionEPNS_11TransactionE + 242 20 QuartzCore 0x000000011141abea _ZN2CA11Transaction6commitEv + 390 21 QuartzCore 0x000000011141b255 _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv + 89 22 CoreFoundation 0x000000010cbf0347 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 23 CoreFoundation 0x000000010cbf02a0 __CFRunLoopDoObservers + 368 24 CoreFoundation 0x000000010cbe60d3 __CFRunLoopRun + 1123 25 CoreFoundation 0x000000010cbe5a06 CFRunLoopRunSpecific + 470 26 GraphicsServices 0x0000000110daa9f0 GSEventRunModal + 161 27 UIKit 0x000000010d545550 UIApplicationMain + 1282 28 TestWork 0x000000010caa432e top_level_code + 78 29 TestWork 0x000000010caa436a main + 42 30 libdyld.dylib 0x000000010efc3145 start + 1 31 ??? 0x0000000000000001 0x0 + 1 )
override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell = self.tableView.dequeueReusableCellWithIdentifier(kCellIdentifier) as ItemTableViewCell <---------------
[UITableViewCellContentView image]: unrecognized selector sent to instance
NSArray* myArray = [myDictionary objectForKey:@"values"]; NSString* myString = [myArray objectAtIndex:5];
[__NSDictionaryI objectAtIndex:] unrecognized selector sent to instance
let noteListTableViewCellobject = "NoteListTableViewCell";` ` func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { var cell:NoteListTableViewCell? = tableView.dequeueReusableCellWithIdentifier(noteListTableViewCellobject) as? NoteListTableViewCell if (cell == nil) { let nib:Array = NSBundle.mainBundle().loadNibNamed("NoteListTableViewCell", owner: self, options: nil) cell = nib[0] as? NoteListTableViewCell } }
- (BOOL)isEqual:(id)other { if (![other isMemberOfClass:[SKScene class]]) { return false; } return [super isEqual:other]; }
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier("cell", forIndexPath: indexPath) return cell }
let canWork = yourObject.respondsToSelector(Selector("image"))
guard let url = URL(string: "https: UIApplication.shared.open(url)
guard let url = URL(string: "https: UIApplication.shared.openURL(url)
guard let url = URL(string: "https: UIApplication.sharedApplication().openURL(url)
let svc = SFSafariViewController(url: url) present(svc, animated: true, completion: nil)
if let requestUrl = NSURL(string: "http: UIApplication.shared.openURL(requestUrl as URL) }
guard let requestUrl = NSURL(string: "http: return } UIApplication.shared.openURL(requestUrl as URL)
if let requestUrl = NSURL(string: "http: UIApplication.sharedApplication().openURL(requestUrl) }
guard let url = URL(string: linkUrlString) else { return } if UIApplication.shared.open(url, options: [:], completionHandler: nil) } else { UIApplication.shared.openURL(url) }
@IBAction func openLink { let pth = "http: if let url = NSURL(string: pth){ UIApplication.sharedApplication().openURL(url) }
UIApplication.sharedApplication().openURL(NSURL(string: "http:
let webView = WKWebView() override func viewDidLoad() { super.viewDidLoad() guard let url = URL(string: "https: webView.frame = view.bounds webView.navigationDelegate = self webView.load(URLRequest(url: url)) webView.autoresizingMask = [.flexibleWidth,.flexibleHeight] view.addSubview(webView) } func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) { if navigationAction.navigationType == .linkActivated { if let url = navigationAction.request.url, let host = url.host, !host.hasPrefix("www.google.com"), UIApplication.shared.canOpenURL(url) { UIApplication.shared.open(url) print(url) print("Redirected to browser. No need to open it locally") decisionHandler(.cancel) } else { print("Open it locally") decisionHandler(.allow) } } else { print("not a user click") decisionHandler(.allow) } }
‚ûú swift Welcome to Swift version 4.2.1 (swift-4.2.1-RELEASE). Type :help for assistance. 1> sqrt(9) error: repl.swift:1:1: error: use of unresolved identifier sqrt(9) ^~~~ 1> import Foundation 2> sqrt(9) $R0: Double = 3 3> floor(9.3) $R1: Double = 9 4> ceil(9.3) $R2: Double = 10
var square = 9.4 var floored = floor(square) var root = sqrt(floored) println("Starting with \(square), we rounded down to \(floored), then took the square root to end up with \(root)")
... func pow(_: CDouble, _: CDouble) -> CDouble func sqrtf(_: CFloat) -> CFloat func sqrt(_: CDouble) -> CDouble func erff(_: CFloat) -> CFloat ... var M_LN10: CDouble { get } /* loge(10) */ var M_PI: CDouble { get } var M_PI_2: CDouble { get } /* pi/2 */ var M_SQRT2: CDouble { get } /* sqrt(2) */ ...
let x = 6.5 print(x.rounded(.toNearestOrAwayFromZero)) print(x.rounded(.towardZero)) print(x.rounded(.up)) print(x.rounded(.down))
import Darwin import Glibc let x = 1.571 print(sin(x))
-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{ if(application.applicationState == UIApplicationStateActive) { }else if(application.applicationState == UIApplicationStateBackground){ }else if(application.applicationState == UIApplicationStateInactive){ }
if ([UIApplication sharedApplication].applicationState == UIApplicationStateInactive) { } else { }
switch application.applicationState { case .active: break case .inactive: break case .background: break default: break }
-(void)userNotificationCenter:(UNUserNotificationCenter *)center **didReceiveNotificationResponse**:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler.
func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) { }
fatal error: array cannot be bridged from Objective-C
destinationViewController.options = options.map({$0 as Option})
protocol Option { var name : String {get} } class ViewController : UIViewController { var options : [Option] = [] } enum Thing : Option { var name : String { get { return "hi" } } case Thing } let vc = ViewController() let options : [Option] = [Thing.Thing] vc.options = options
destinationViewController.options = options.map{$0}
$ unzip -lv Roger\ Release.ipa | sort -k +3nr | head 41802768 Defl:N 16887199 60% 09-14-15 23:47 dc24cdc1 Payload/Roger.app/Frameworks/libswiftCore.dylib 41802400 Defl:N 16886076 60% 09-06-15 18:33 f939ea6a SwiftSupport/iphoneos/libswiftCore.dylib 11184032 Defl:N 5915625 47% 09-14-15 23:48 6ceac4a2 Payload/Roger.app/Roger 6399584 Defl:N 2670275 58% 09-14-15 23:47 0ac52d3f Payload/Roger.app/Frameworks/libPhoneNumber_iOS.framework/libPhoneNumber_iOS 5410384 Defl:N 2334189 57% 09-14-15 23:47 7a8cb03f Payload/Roger.app/Frameworks/Alamofire.framework/Alamofire 4521904 Defl:N 2292789 49% 09-14-15 23:47 95da0882 Payload/Roger.app/Frameworks/FBSDKCoreKit.framework/FBSDKCoreKit 4731552 Defl:N 1926357 59% 09-14-15 23:48 e05337de Payload/Roger.app/Frameworks/libswiftFoundation.dylib 4731168 Defl:N 1925355 59% 09-06-15 18:33 19a5c3c4 SwiftSupport/iphoneos/libswiftFoundation.dylib 2659232 Defl:N 1232897 54% 09-14-15 23:47 1a53a401 Payload/Roger.app/Frameworks/AFNetworking.framework/AFNetworking 1196624 Defl:N 545343 54% 09-14-15 23:47 19a063cb Payload/Roger.app/Frameworks/Bolts.framework/Bolts
protocol NotificationName { var name: Notification.Name { get } } extension RawRepresentable where RawValue == String, Self: NotificationName { var name: Notification.Name { get { return Notification.Name(self.rawValue) } } }
class MyClass { enum Notifications: String, NotificationName { case myNotification } }
NotificationCenter.default.post(name: Notifications.myNotification.name, object: nil)
extension Notification.Name { static let onSelectedSkin = Notification.Name("on-selected-skin") }
NotificationCenter.default.post(name: .onSelectedSkin, object: selectedSkin)
public func post(name aName: NSNotification.Name, object anObject: AnyObject?)
public struct Name : RawRepresentable, Equatable, Hashable, Comparable { public init(_ rawValue: String) public init(rawValue: String) }
public class MyClass { static let myNotification = Notification.Name("myNotification") }
NotificationCenter.default().post(name: MyClass.myNotification, object: self)
let name:NSNotification.Name = NSNotification.Name("notificationName") NotificationCenter.default.post(name: name, object: nil)
extension NSNotification.Name { enum Notifications: String { case foo, bar } init(_ value: Notifications) { self = NSNotification.Name(value.rawValue) } }
NotificationCenter.default.post(name: Notification.Name(.foo), object: nil)
NSNotification.Name(rawValue: "myNotificationName")
public extension Notification { public class MyApp { public static let Something = Notification.Name("Notification.MyApp.Something") } } class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: name: Notification.MyApp.Something, object: nil) } deinit { NotificationCenter.default.removeObserver(self) } @IBAction func btnTapped(_ sender: UIButton) { NotificationCenter.default.post(name: Notification.MyApp.Something, object: self, userInfo: [Notification.MyApp.Something:"foo"]) } func onSomethingChange(notification:NSNotification) { print("notification received") let userInfo = notification.userInfo! let key = Notification.MyApp.Something let something = userInfo[key]! as! String print(something) } }
extension Notification.Name { static var notificationName: Notification.Name { return .init("notificationName") } }
NotificationCenter.default.post(Notification(name: .notificationName))
NotificationCenter.default.addObserver(self, selector: name: MyClass.myNotification, object: nil) let userInfo = ["foo": 1, "bar": "baz"] as [String: Any] NotificationCenter.default.post(name: MyClass.myNotification, object: nil, userInfo: userInfo)
enum MyNotification: String { case somethingHappened case somethingElseHappened case anotherNotification case oneMore } extension NotificationCenter { func add(observer: Any, selector: Selector, notification: MyNotification, object: Any? = nil) { addObserver(observer, selector: selector, name: Notification.Name(notification.rawValue), object: object) } func post(notification: MyNotification, object: Any? = nil, userInfo: [AnyHashable: Any]? = nil) { post(name: NSNotification.Name(rawValue: notification.rawValue), object: object, userInfo: userInfo) } }
NotificationCenter.default.post(.somethingHappened)
enum StoryboardSegue: String { case toHere case toThere case unwindToX } extension UIViewController { func perform(segue: StoryboardSegue) { performSegue(withIdentifier: segue.rawValue, sender: self) } }
extension String { var notificationName : Notification.Name{ return Notification.Name.init(self) } }
extension Notification.Name { typealias Name = Notification.Name static let onSelectedSkin = Name("on-selected-skin") static let onFoo = Name("on-foo") }
[build_path]/unextended-module.modulemap:2:19: error: umbrella header umbrella header "bugtest.h" ^ <unknown>:0: error: could not build Objective-C module
post_install do |installer| installer.pods_project.targets.each do |target| phase_name = target.build_phases.each do |phase| if (phase.display_name.include? phase_name) target.build_phases.unshift(phase).uniq! unless target.build_phases.first == phase end end end
sudo gem uninstall cocoapods -v 0.39 sudo gem install cocoapods -v 0.38.2
let date = Date() let calendar = Calendar.current let components = calendar.dateComponents([.year, .month, .day], from: date) let year = components.year let month = components.month let day = components.day print(year) print(month) print(day)
let array: [Any] = [1, 1.2, "Hello", true, [1, 2, 3], "World!"] for case let str as String in array { print(str) }
if let subviews = view.subviews as? [AClass] { for button in subviews { } }
for button in view.subviews where button is UIButton { ... }
let myRange: ClosedRange = 1...3 let myArray = ["a", "b", "c", "d", "e"] myArray[myRange]
let myRange: CountableClosedRange = 1...3 let myArray = ["a", "b", "c", "d", "e"] myArray[myRange] for index in myRange { print(myArray[index]) }
let myRange: Range = 1..<3 let myArray = ["a", "b", "c", "d", "e"] myArray[myRange]
let myRange: CountableRange = 1..<3 let myArray = ["a", "b", "c", "d", "e"] myArray[myRange] for index in myRange { print(myArray[index]) }
let myRange = CountableRange<Int>(uncheckedBounds: (lower: 1, upper: 3))
let myNSRange = NSRange(location: 1, length: 3) let myNSString: NSString = "abcde" myNSString.substring(with: myNSRange) let myNSString2: NSString = "aüòÄcde" myNSString2.substring(with: myNSRange)
var myString = "abcde" let start = myString.index(myString.startIndex, offsetBy: 1) let end = myString.index(myString.startIndex, offsetBy: 4) let myRange = start..<end myString[myRange] myString = "aüòÄcde" let start2 = myString.index(myString.startIndex, offsetBy: 1) let end2 = myString.index(myString.startIndex, offsetBy: 4) let myRange2 = start2..<end2 myString[myRange2]
for name in names[2...] { print(name) } for name in names[...2] { print(name) } for name in names[..<2] { print(name) } let range = ...5 range.contains(7) range.contains(4) range.contains(-1) let range = 5...
var str = "Hello, playground" let index = str.index(str.startIndex, offsetBy: 5) let myRange = ..<index
var str = "Hello, playground" let index = str.index(str.endIndex, offsetBy: -10) let myRange = index...
let myString = "Hello World" let myRange = myString.startIndex..<myString.index(myString.startIndex, offsetBy: 5) let mySubString = myString.substring(with: myRange)
let myString = "Hello World" let myRange = Range<String.Index>(start: myString.startIndex, end: myString.startIndex.advancedBy(5)) let mySubString = myString.substringWithRange(myRange)
let myString = "Hello World" let myRange = myString.startIndex..<myString.startIndex.advancedBy(5) let mySubString = myString.substringWithRange(myRange)
var start = str.startIndex var end = advance(str.startIndex, 5) var range: Range<String.Index> = Range<String.Index>(start: start,end: end) let firstFiveDigit = str.substringWithRange(range) print(firstFiveDigit)
func range(_ start:Int, _ length:Int) -> Range<String.Index> { let i = self.index(start >= 0 ? self.startIndex : self.endIndex, offsetBy: start) let j = self.index(i, offsetBy: length) return i..<j }
extension String { func nsRange(_ start:Int, _ length:Int) -> NSRange { return NSRange(self.range(start,length), in:self) } }
let range: NSRange = NSRange.init(location: 0, length: 5)
extension String { func substring(from from:Int, to:Int) -> String? { if from<to && from>=0 && to<self.characters.count { let rng = self.startIndex.advancedBy(from)..<self.startIndex.advancedBy(to) return self.substringWithRange(rng) } else { return nil } } }
print("abcde".substring(from: 1, to: 10)) print("abcde".substring(from: 2, to: 4)) print("abcde".substring(from: 1, to: 0)) print("abcde".substring(from: 1, to: 1)) print("abcde".substring(from: -1, to: 1))
func replace(input: String, start: Int,lenght: Int, newChar: Character) -> String { var chars = Array(input.characters) for i in start...lenght { guard i < input.characters.count else{ break } chars[i] = newChar } return String(chars)
let nsRange = NSRange(location: someInt, length: someInt)
let myNSString = bigTOTPCode as NSString let firstDigit = myNSString.substringWithRange(NSRange(location: 0, length: 1)) let secondDigit = myNSString.substringWithRange(NSRange(location: 1, length: 1)) let thirdDigit = myNSString.substringWithRange(NSRange(location: 2, length: 4))
Alamofire.request(.GET, "https: .responseString { (req, res, data, error) in if error != nil { println("STRING Error:: error:\(error)") println(" req:\(req)") println(" res:\(res)") println(" data:\(data)") return } println("SUCCESS for String") } .responseJSON { (req, res, data, error) in if error != nil { println("JSON Error:: error:\(error)") println(" req:\(req)") println(" res:\(res)") println(" data:\(data)") return } println("SUCCESS for JSON") }
STRING Error:: error:Optional(Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo=0x7f9beb8efce0 {NSErrorFailingURLKey=https: req:<NSMutableURLRequest: 0x7f9beb89d5e0> { URL: https: res:nil data:Optional("") JSON Error:: error:Optional(Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo=0x7f9beb8efce0 {NSErrorFailingURLKey=https: req:<NSMutableURLRequest: 0x7f9beb89d5e0> { URL: https: res:nil data:nil
Alamofire.request(urlString) .responseString { response in print("Success: \(response.result.isSuccess)") print("Response String: \(response.result.value)") var statusCode = response.response?.statusCode if let error = response.result.error as? AFError { statusCode = error._code switch error { case .invalidURL(let url): print("Invalid URL: \(url) - \(error.localizedDescription)") case .parameterEncodingFailed(let reason): print("Parameter encoding failed: \(error.localizedDescription)") print("Failure Reason: \(reason)") case .multipartEncodingFailed(let reason): print("Multipart encoding failed: \(error.localizedDescription)") print("Failure Reason: \(reason)") case .responseValidationFailed(let reason): print("Response validation failed: \(error.localizedDescription)") print("Failure Reason: \(reason)") switch reason { case .dataFileNil, .dataFileReadFailed: print("Downloaded file could not be read") case .missingContentType(let acceptableContentTypes): print("Content Type Missing: \(acceptableContentTypes)") case .unacceptableContentType(let acceptableContentTypes, let responseContentType): print("Response content type: \(responseContentType) was unacceptable: \(acceptableContentTypes)") case .unacceptableStatusCode(let code): print("Response status code was unacceptable: \(code)") statusCode = code } case .responseSerializationFailed(let reason): print("Response serialization failed: \(error.localizedDescription)") print("Failure Reason: \(reason)") } print("Underlying error: \(error.underlyingError)") } else if let error = response.result.error as? URLError { print("URLError occurred: \(error)") } else { print("Unknown error: \(response.result.error)") } print(statusCode) }
Alamofire.request(.GET, urlString) .responseString { response in print("Success: \(response.result.isSuccess)") print("Response String: \(response.result.value)") if let alamoError = response.result.error { let alamoCode = alamoError.code let statusCode = (response.response?.statusCode)! } else { let statusCode = (response.response?.statusCode)! } }
Alamofire.request(.POST, urlString, parameters: parameters) .responseJSON(completionHandler: {response in switch(response.result) { case .Success(let JSON): case .Failure(let error): let message : String if let httpStatusCode = response.response?.statusCode { switch(httpStatusCode) { case 400: message = "Username or password not provided." case 401: message = "Incorrect password for user ... } } else { message = error.localizedDescription } }
Alamofire .request(.GET, "REQUEST_URL", parameters: parms, headers: headers) .validate(statusCode: 200..<300) .responseJSON{ response in switch response.result{ case .Success: if let JSON = response.result.value { } case .Failure(let error): }
if let response = res { var statusCode = response.statusCode }
.responseJson { (req, res, json, error) in } .responseString { (_, _, body, _) in }
if let error = response.result.error as? AFError { if case .responseValidationFailed(.unacceptableStatusCode(let code)) = error { print(code) } }
let request = URLRequest(url: URL(string:"url string")!) Alamofire.request(request).validate(statusCode: 200..<300).responseJSON { (response) in switch response.result { case .success(let data as [String:Any]): completion(true,data) case .failure(let err): print(err.localizedDescription) completion(false,err) default: completion(false,nil) } }
Alamofire.request(.GET, url) .responseString { _, response, result in if response?.statusCode == 200{ } }
func max<T : Comparable>(x: T, y: T, rest: T...) -> T func min<T : Comparable>(x: T, y: T, rest: T...) -> T
let numbers = [ 1, 42, 5, 21 ] var maxNumber = Int() for number in numbers { maxNumber = max(maxNumber, number as Int) } print("the max number is \(maxNumber)")
func max<T : Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T
let maxInt = max(12.0, 18.5, 21, 15, 26, 32.9, 19.1)
class Route: Comparable, CustomStringConvertible { let distance: Int var description: String { return "Route with distance: \(distance)" } init(distance: Int) { self.distance = distance } } func ==(lhs: Route, rhs: Route) -> Bool { return lhs.distance == rhs.distance } func <(lhs: Route, rhs: Route) -> Bool { return lhs.distance < rhs.distance } let route1 = Route(distance: 4) let route2 = Route(distance: 8) let maxRoute = max(route1, route2) print(maxRoute)
public func max<T>(_ x: T, _ y: T) -> T where T : Comparable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable
public func max<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Comparable public func min<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Comparable
let min = 0 let max = 100 let value = -1000 let currentValue = Swift.min(Swift.max(min, value), max)
let numbers = [2, 3, 10, 9, 14, 6] print("Max = \(numbers.maxElement()) Min = \(numbers.minElement())")
class Vehicle { var numberOfWheels = 0 var description: String { return "\(numberOfWheels) wheels" } } let vehicle = Vehicle() println(vehicle.description)
class Vehicle { var numberOfWheels = 0 func description() -> String { return "\(numberOfWheels) wheels" } } let vehicle = Vehicle() println(vehicle.description())
func fflat<A, R>(f: (A) -> () -> (R)) -> (A) -> (R) { return { f($0)() } } func fnot<A>(f: (A) -> Bool) -> (A) -> (Bool) { return { !f($0) } } extension String { func isEmptyAsFunc() -> Bool { return isEmpty } } let strings = ["Hello", "", "world"] strings.filter(fnot(fflat(String.isEmptyAsFunc)))
struct Vector { let x, y: Double func length() -> Double { return sqrt(x*x + y*y) } }
struct VectorWithLengthAsProperty { let x, y: Double var length: Double { return sqrt(x*x + y*y) } }
class Person{ let firstName: String let lastName: String init(firstName: String, lastName: String){ self.firstName = firstName self.lastName = lastName } var fullName :String{ return firstName+" "+lastName } } let william = Person(firstName: "William", lastName: "Kinaan") william.fullName
import Foundation class MyClass { var prop: Int { return 88 } func foo() -> Int { return 88 } } func test(times: u_long) { func testProp(times: u_long) -> TimeInterval { let myClass = MyClass() let starting = Date() for _ in 0...times { _ = myClass.prop } let ending = Date() return ending.timeIntervalSince(starting) } func testFunc(times: u_long) -> TimeInterval { let myClass = MyClass() let starting = Date() for _ in 0...times { _ = myClass.prop } let ending = Date() return ending.timeIntervalSince(starting) } print("prop: \(testProp(times: times))") print("func: \(testFunc(times: times))") } test(times: 100000) test(times: 1000000) test(times: 10000000) test(times: 100000000)
class DetailViewController: UIViewController { @IBOutlet weak var tripDetails: UILabel! override func viewDidLoad() { super.viewDidLoad() ... let tap = UITapGestureRecognizer(target: self, action: Selector("tapFunction:")) tripDetails.addGestureRecognizer(tap) } func tapFunction(sender:UITapGestureRecognizer) { print("tap working") } }
class DetailViewController: UIViewController { @IBOutlet weak var tripDetails: UILabel! override func viewDidLoad() { super.viewDidLoad() ... let tap = UITapGestureRecognizer(target: self, action: tripDetails.isUserInteractionEnabled = true tripDetails.addGestureRecognizer(tap) } @objc func tapFunction(sender:UITapGestureRecognizer) { print("tap working") } }
@IBOutlet weak var tripDetails: UILabel! override func viewDidLoad() { super.viewDidLoad() let tap = UITapGestureRecognizer(target: self, action: tripDetails.isUserInteractionEnabled = true tripDetails.addGestureRecognizer(tap) } @objc func tapFunction(sender:UITapGestureRecognizer) { print("tap working") }
label.isUserInteractionEnabled = true let longPress:UILongPressGestureRecognizer = UILongPressGestureRecognizer.init(target: self, action: longPress.minimumPressDuration = 0.2 label.addGestureRecognizer(longPress)
@IBOutlet weak var label: LabelButton! override func viewDidLoad() { super.viewDidLoad() self.label.onClick = { } }
@IBDesignable class LabelButton: UILabel { var onClick: () -> Void = {} override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) { onClick() } }
yourlabel.isUserInteractionEnabled = true yourlabel.addGestureRecognizer(UITapGestureRecognizer(){ })
var url:NSURL = NSURL.URLWithString("http: var err: NSError? var imageData :NSData = NSData.dataWithContentsOfURL(url,options: NSDataReadingOptions.DataReadingMappedIfSafe, error: &err) Alamofire.upload(.POST, "http: .progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in println(totalBytesWritten) } .responseJSON { (request, response, JSON, error) in println(request) println(response) println(JSON) }
var manager = Manager.sharedInstance manager.session.configuration.HTTPAdditionalHeaders = ["Content-Type": "application/octet-stream"] let imageData: NSMutableData = NSMutableData.dataWithData(UIImageJPEGRepresentation(imageTest.image, 30)); Alamofire.upload(.POST, "http: .progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in println(totalBytesWritten) } .responseString { (request, response, JSON, error) in println(request) println(response) println(JSON) }
func urlRequestWithComponents(urlString:String, parameters:Dictionary<String, String>, imageData:NSData) -> (URLRequestConvertible, NSData) { var mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: urlString)!) mutableURLRequest.HTTPMethod = Alamofire.Method.POST.rawValue let boundaryConstant = "myRandomBoundary12345"; let contentType = "multipart/form-data;boundary="+boundaryConstant mutableURLRequest.setValue(contentType, forHTTPHeaderField: "Content-Type") let uploadData = NSMutableData() uploadData.appendData("\r\n--\(boundaryConstant)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) uploadData.appendData("Content-Disposition: form-data; name=\"file\"; filename=\"file.png\"\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) uploadData.appendData("Content-Type: image/png\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) uploadData.appendData(imageData) for (key, value) in parameters { uploadData.appendData("\r\n--\(boundaryConstant)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) uploadData.appendData("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n\(value)".dataUsingEncoding(NSUTF8StringEncoding)!) } uploadData.appendData("\r\n--\(boundaryConstant)--\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) return (Alamofire.ParameterEncoding.URL.encode(mutableURLRequest, parameters: nil).0, uploadData) }
var parameters = [ "task": "task", "variable1": "var" ] parameters["userId"] = "27" parameters["body"] = "This is the body text." let image = UIImage(named: "177143.jpg") let imageData = UIImagePNGRepresentation(image) let urlRequest = urlRequestWithComponents("http: Alamofire.upload(urlRequest.0, urlRequest.1) .progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in println("\(totalBytesWritten) / \(totalBytesExpectedToWrite)") } .responseJSON { (request, response, JSON, error) in println("REQUEST \(request)") println("RESPONSE \(response)") println("JSON \(JSON)") println("ERROR \(error)") }
$file = $_FILES[ $fileName = $_FILES[ $fileType = $_FILES[ $allowedExts = array("jpg", "jpeg", "png"); $rootName = reset(explode(".", $fileName)); $extension = end(explode(".", $fileName)); $time = time(); $newName = $rootName.$time. $moved = move_uploaded_file($_FILES["file"]["tmp_name"], "uploads/".$newName ); if ($moved) $path = "uploads/".$newName; $body = $_POST[ $userId = $_POST[ $time = time(); if ($moved) { $fullUrl = "http: $arrayToSend = array( } else { $arrayToSend = array( } header( echo json_encode($arrayToSend);
func uploadWithAlamofire() { let image = UIImage(named: "bodrum")! let parameters = [ "hometown": "yalikavak", "living": "istanbul" ] Alamofire.upload(multipartFormData: { multipartFormData in if let imageData = UIImageJPEGRepresentation(image, 1) { multipartFormData.append(imageData, withName: "file", fileName: "file.png", mimeType: "image/png") } for (key, value) in parameters { multipartFormData.append((value?.data(using: .utf8))!, withName: key) }}, to: "upload_url", method: .post, headers: ["Authorization": "auth_token"], encodingCompletion: { encodingResult in switch encodingResult { case .success(let upload, _, _): upload.response { [weak self] response in guard let strongSelf = self else { return } debugPrint(response) } case .failure(let encodingError): print("error:\(encodingError)") } }) }
func uploadWithAlamofire() { let image = UIImage(named: "myImage")! let parameters = [ "hometown": "yalikavak", "living": "istanbul" ] Alamofire.upload(.POST, "upload_url", headers: ["Authorization": "auth_token"], multipartFormData: { multipartFormData in if let imageData = UIImageJPEGRepresentation(image, 1) { multipartFormData.appendBodyPart(data: imageData, name: "file", fileName: "myImage.png", mimeType: "image/png") } for (key, value) in parameters { multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding)!, name: key) } }, encodingMemoryThreshold: Manager.MultipartFormDataEncodingMemoryThreshold, encodingCompletion: { encodingResult in switch encodingResult { case .Success(let upload, _, _): upload.responseJSON { response in debugPrint(response) } case .Failure(let encodingError): print(encodingError) } }) }
let parameters = [ "par1": "value", "par2": "value2"] let URL = "YOUR_URL.php" let image = UIImage(named: "image.png") Alamofire.upload(.POST, URL, multipartFormData: { multipartFormData in if let _image = image { if let imageData = UIImageJPEGRepresentation(_image, 0.5) { multipartFormData.appendBodyPart(data: imageData, name: "file", fileName: "file.png", mimeType: "image/png") } } for (key, value) in parameters { multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding)!, name: key) } }, encodingCompletion: { encodingResult in switch encodingResult { case .Success(let upload, _, _): upload.responseObject { (response: Response<UploadData, NSError>) -> Void in switch response.result { case .Success: completionHandler?(success: true) case .Failure(let error): completionHandler?(success: false) } } case .Failure(let encodingError): print(encodingError) } })
Alamofire.upload(.POST, urlString, multipartFormData: { multipartFormData in if let _image = self.profilePic.image { if let imageData = UIImagePNGRepresentation(_image) { multipartFormData.appendBodyPart(data: imageData, name: "user_image", fileName: "file.png", mimeType: "image/png") } } for (key, value) in userInfo { multipartFormData.appendBodyPart(data: value.dataUsingEncoding(NSUTF8StringEncoding)!, name: key) } }, encodingCompletion: { encodingResult in switch encodingResult { case .Success(let upload, _, _): upload.responseJSON { response in debugPrint(response) } case .Failure(let encodingError): print(encodingError) } } )
import Foundation import Alamofire private struct FileUploadInfo { var name:String var mimeType:String var fileName:String var url:NSURL? var data:NSData? init( name: String, withFileURL url: NSURL, withMimeType mimeType: String? = nil ) { self.name = name self.url = url self.fileName = name self.mimeType = "application/octet-stream" if mimeType != nil { self.mimeType = mimeType! } if let _name = url.lastPathComponent { fileName = _name } if mimeType == nil, let _extension = url.pathExtension { switch _extension.lowercaseString { case "jpeg", "jpg": self.mimeType = "image/jpeg" case "png": self.mimeType = "image/png" default: self.mimeType = "application/octet-stream" } } } init( name: String, withData data: NSData, withMimeType mimeType: String ) { self.name = name self.data = data self.fileName = name self.mimeType = mimeType } } class FileUploader { private var parameters = [String:String]() private var files = [FileUploadInfo]() private var headers = [String:String]() func setValue( value: String, forParameter parameter: String ) { parameters[parameter] = value } func setValue( value: String, forHeader header: String ) { headers[header] = value } func addParametersFrom( for (key,value) in map { parameters[key] = value } } func addHeadersFrom( for (key,value) in map { headers[key] = value } } func addFileURL( url: NSURL, withName name: String, withMimeType mimeType:String? = nil ) { files.append( FileUploadInfo( name: name, withFileURL: url, withMimeType: mimeType ) ) } func addFileData( data: NSData, withName name: String, withMimeType mimeType:String = "application/octet-stream" ) { files.append( FileUploadInfo( name: name, withData: data, withMimeType: mimeType ) ) } func uploadFile( request sourceRequest: NSURLRequest ) -> Request? { var request = sourceRequest.mutableCopy() as! NSMutableURLRequest let boundary = "FileUploader-boundary-\(arc4random())-\(arc4random())" request.setValue( "multipart/form-data;boundary=\(boundary)", forHTTPHeaderField: "Content-Type") let data = NSMutableData() for (name, value) in headers { request.setValue(value, forHTTPHeaderField: name) } for (key, value) in parameters { data.appendData("\r\n--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) data.appendData("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n\(value)".dataUsingEncoding(NSUTF8StringEncoding)!) } for fileUploadInfo in files { data.appendData( "\r\n--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)! ) data.appendData( "Content-Disposition: form-data; name=\"\(fileUploadInfo.name)\"; filename=\"\(fileUploadInfo.fileName)\"\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) data.appendData( "Content-Type: \(fileUploadInfo.mimeType)\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) if fileUploadInfo.data != nil { data.appendData( fileUploadInfo.data! ) } else if fileUploadInfo.url != nil, let fileData = NSData(contentsOfURL: fileUploadInfo.url!) { data.appendData( fileData ) } else { return nil } } data.appendData("\r\n--\(boundary)--\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) return Alamofire.upload( request, data ) } }
let fileURL = NSBundle.mainBundle().URLForResource("example", withExtension: "png") let fileUploader = FileUploader() fileUploader.addFileURL(fileURL!, withName: "myFile") let data = UIImage(named: "sample") fileUploader.addFileData( UIImageJPEGRepresentation(data,0.8), withName: "mySecondFile", withMimeType: "image/jpeg" ) fileUploader.setValue( "sample", forParameter: "folderName" ) var request = NSMutableURLRequest( URL: NSURL(string: "http: request.HTTPMethod = "POST" fileUploader.uploadFile(request: request)
func urlRequestWithComponents(urlString:String, parameters:NSDictionary) -> (URLRequestConvertible, NSData) { var mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: urlString)!) mutableURLRequest.HTTPMethod = Alamofire.Method.POST.rawValue let boundaryConstant = "NET-POST-boundary-\(arc4random())-\(arc4random())" let contentType = "multipart/form-data;boundary="+boundaryConstant mutableURLRequest.setValue(contentType, forHTTPHeaderField: "Content-Type") let uploadData = NSMutableData() for (key, value) in parameters { uploadData.appendData("\r\n--\(boundaryConstant)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) if value is NetData { var postData = value as NetData var filenameClause = " filename=\"\(postData.filename)\"" let contentDispositionString = "Content-Disposition: form-data; name=\"\(key)\";\(filenameClause)\r\n" let contentDispositionData = contentDispositionString.dataUsingEncoding(NSUTF8StringEncoding) uploadData.appendData(contentDispositionData!) let contentTypeString = "Content-Type: \(postData.mimeType.getString())\r\n\r\n" let contentTypeData = contentTypeString.dataUsingEncoding(NSUTF8StringEncoding) uploadData.appendData(contentTypeData!) uploadData.appendData(postData.data) }else{ uploadData.appendData("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n\(value)".dataUsingEncoding(NSUTF8StringEncoding)!) } } uploadData.appendData("\r\n--\(boundaryConstant)--\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) return (Alamofire.ParameterEncoding.URL.encode(mutableURLRequest, parameters: nil).0, uploadData) }
let docDir:AnyObject = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] let imagePath = docDir + "/myPic.jpg" var imageData = NSData(contentsOfFile: imagePath, options: NSDataReadingOptions.DataReadingMappedIfSafe, error: nil) var parameters = [ "pic" :NetData(nsData: imageData!, filename: "customName.jpg"), "otherParm" :"Value" ] let urlRequest = self.urlRequestWithComponents("http:
<?php $uploaddir = $uploadfile = $uploaddir . basename($_FILES[ if (move_uploaded_file($_FILES[ $array = array ("code" => "1", "message" => "successfully"); } else { $array = array ("code" => "0", "message" => "Possible file upload attack!".$_FILES[ } echo json_encode ( $array ); ?>
class Photo { class func upload(image: UIImage, filename: String) -> Request { let route = Router.CreatePhoto() var request = route.URLRequest.mutableCopy() as NSMutableURLRequest let boundary = "NET-POST-boundary-\(arc4random())-\(arc4random())" request.setValue("multipart/form-data;boundary="+boundary, forHTTPHeaderField: "Content-Type") let parameters = NSMutableData() for s in ["\r\n--\(boundary)\r\n", "Content-Disposition: form-data; name=\"photos[photo]\";" + " filename=\"\(filename)\"\r\n", "Content-Type: image/png\r\n\r\n"] { parameters.appendData(s.dataUsingEncoding(NSUTF8StringEncoding)!) } parameters.appendData(UIImageJPEGRepresentation(image, 1)) parameters.appendData("\r\n--\(boundary)--\r\n" .dataUsingEncoding(NSUTF8StringEncoding)!) return Alamofire.upload(request, parameters) } }
let rep = (asset as ALAsset).defaultRepresentation() let ref = rep.fullResolutionImage().takeUnretainedValue() Photo.upload(UIImage(CGImage: ref)!, filename: rep.filename()) .progress { (bytesWritten, totalBytesWritten, totalBytesExpectedToWrite) in println(totalBytesWritten) } .responseJSON { (request, response, JSON, error) in println(JSON) }
let data = UIImagePNGRepresentation(image) let manager = AFHTTPSessionManager() manager.POST(uploadURLString, parameters: nil, constructingBodyWithBlock: { formData in formData.appendPartWithFileData(data, name: "image", fileName: "test.png", mimeType: "image/png") }, success: { operation, responseObject in println(responseObject) }) { operation, error in println(error) }
import UIKit import Alamofire class ViewController: UIViewController { @IBOutlet var imageView: UIImageView! @IBOutlet var btnUpload: UIButton! override func viewDidLoad() { super.viewDidLoad() } func successDataHandler(responseData:String){ print ("IMAGE UPLOAD SUCCESSFUL !!!") } func failureDataHandler(errorData:String){ print (" !!! IMAGE UPLOAD FAILURE !!! ") } @IBAction func actionUpload(sender: AnyObject) { let URL = "http: let postDataProlife:[String:AnyObject] = ["CardId":(dataCardDetail?.userId)!,"ImageType":1,"ImageData":imageView.image!] uplaodImageData(URL, postData: postDataProlife, successHandler: successDataHandler, failureHandler: failureDataHandler) } func uplaodImageData(RequestURL: String,postData:[String:AnyObject]?,successHandler: (String) -> (),failureHandler: (String) -> ()) -> () { let headerData:[String : String] = ["Content-Type":"application/json"] Alamofire.request(.POST,RequestURL, parameters: postData, encoding: .URLEncodedInURL, headers: headerData).responseString{ response in switch response.result { case .Success: print(response.response?.statusCode) successHandler(response.result.value!) case .Failure(let error): failureHandler("\(error)") } } } }
class func upload(jsonObject: AnyObject , files : Array<Any>? = nil , completionHandler : CompletionBlock? = nil ,failureHandler : FailureBlock? = nil ) { Alamofire.upload(multipartFormData: { (multipartFormData) in if let filesO = files { for i in (filesO.enumerated()) { let image = UIImage(named: "\(i.element)") let data = UIImageJPEGRepresentation(image!, 1)! multipartFormData.append(data, withName: "imgFiles[]" , fileName: "\( NSUUID().uuidString).jpeg" , mimeType: "image/jpeg") } } for (key, value) in jsonObject as! [String : String] { multipartFormData.append(value.data(using: String.Encoding.utf8)!, withName: key) }} }, to:baseURL)
if (isset($_FILES[ foreach ($_FILES[ $file_name = $key . $_FILES[ $file_size = $_FILES[ $file_tmp = $_FILES[ $file_type = $_FILES[ if (is_dir("$desired_dir/" . $file_name) == false) { move_uploaded_file($file_tmp, $desired_dir . "/" . $file_name); } else { $new_dir = $desired_dir . "/" . $file_name . time(); rename($file_tmp, $new_dir); }
let imageData = UIImagePNGRepresentation(myImageView.image) uploadImage("http: { (req, res, str, err) -> Void in }
func uploadImage(urlToPHPFile: String, imageData: NSData, subdir: String, filename: String, completionHandler:(request:NSURLRequest, response:NSURLResponse?, responseString:String?, error: NSError?) -> ()) { func urlRequestWithComponents(urlString:String, parameters:Dictionary<String, String>, imageData:NSData) -> (URLRequestConvertible, NSData) { var mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: urlString)!) mutableURLRequest.HTTPMethod = Method.POST.rawValue let boundaryConstant = "myRandomBoundary12345"; let contentType = "multipart/form-data;boundary="+boundaryConstant mutableURLRequest.setValue(contentType, forHTTPHeaderField: "Content-Type") let uploadData = NSMutableData() uploadData.appendData("\r\n--\(boundaryConstant)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) uploadData.appendData("Content-Disposition: form-data; name=\"file\"; filename=\"file.png\"\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) uploadData.appendData("Content-Type: image/png\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) uploadData.appendData(imageData) for (key, value) in parameters { uploadData.appendData("\r\n--\(boundaryConstant)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) uploadData.appendData("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n\(value)".dataUsingEncoding(NSUTF8StringEncoding)!) } uploadData.appendData("\r\n--\(boundaryConstant)--\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) return (ParameterEncoding.URL.encode(mutableURLRequest, parameters: nil).0, uploadData) } let parameters = [ "subdir" : subdir, "filename": filename ] let urlRequest = urlRequestWithComponents(urlToPHPFile, parameters, imageData) AlamoFire.upload(urlRequest.0, urlRequest.1) .responseString(completionHandler: { [weak self] (req, res, str, err) -> Void in if let strongSelf = self { completionHandler(request: req, response: res, responseString: str, error: err) } } ) }
$subdir = $_POST[ $filename = $_POST["filename"]; $targetPath = $subdir. $moved = move_uploaded_file($_FILES["file"]["tmp_name"], $targetPath ); if ($moved) { echo "OK"; } else { echo "Error: file not uploaded"; }
func aFunction(numbers: Array<Int>, position: Int) -> Array<Int> { var newNumbers = numbers[0...position] return newNumbers }
var test = [1, 2, 3] var n = 2 var test2 = test[0..<n]
func aFunction(numbers: Array<Int>, position: Int) -> Array<Int> { var newNumbers = Array(numbers[0..<position]) return newNumbers } aFunction([1, 2, 3], 2)
let array = Array(10...14) let arraySlice = array[..<3] let newArray = Array(arraySlice) print(newArray)
func prefix(_ maxLength: Int) -> ArraySlice<Element>
let array = Array(10...14) let arraySlice = array.prefix(3) let newArray = Array(arraySlice) print(newArray)
func aFunction(numbers: Array<Int>, position: Int) -> Array<Int> { let newNumbers = numbers[0 ..< position] return Array(newNumbers) } let array = Array(10...14) let newArray = aFunction(numbers: array, position: 3) print(newArray)
extension Array { func getFirstElements(upTo position: Int) -> Array<Element> { let arraySlice = self[0 ..< position] return Array(arraySlice) } } let array = Array(10...14) let newArray = array.getFirstElements(upTo: 3) print(newArray)
func subArray<T>(array: [T], range: NSRange) -> [T] { if range.location > array.count { return [] } return Array(array[range.location..<min(range.length, array.count)]) }
@interface MyClass : NSObject + (void)aClassMethod; - (void)anInstanceMethod; @end
class Foo { var name: String? static var all = [Foo]() class var comp: Int { return 42 } class func alert() { print("There are \(all.count) foos") } } Foo.alert() let f = Foo() Foo.all.append(f) Foo.alert()
class SomeClass { class func someTypeMethod() { } }
class MyClass : { class func aClassMethod() { ... } func anInstanceMethod() { ... } }
private var fooPropertyKey: Int = 0 class YourClass: SomeSubclassOfNSObject { class var foo: FooType? { get { return objc_getAssociatedObject(self, &fooPropertyKey) as FooType? } set { objc_setAssociatedObject(self, &fooPropertyKey, newValue, objc_AssociationPolicy(OBJC_ASSOCIATION_RETAIN_NONATOMIC)) } } .... }
class MyClass { class func aClassMethod() { ... } static func anInstanceMethod() { ... } static var myArray : [String] = [] }
NSMutableArray *characters = [[NSMutableArray alloc] initWithCapacity:[myString length]]; for (int i=0; i < [myString length]; i++) { NSString *ichar = [NSString stringWithFormat:@"%c", [myString characterAtIndex:i]]; [characters addObject:ichar]; }
let string : String = "Hello üê∂üêÆ üá©üá™" let characters = Array(string) println(characters)
let string = "Hello üê∂üêÆ üá©üá™" let characters = Array(string.characters) print(characters)
let string = "Hello üê∂üêÆ üá©üá™" let characters = Array(string) print(characters)
"ABC".map { String($0) } print(letters) print(type(of: letters))
let letters = "ABC".characters.map { String($0) } print(letters)
$ swift Welcome to Swift! Type :help for assistance. 1> Array("ABC") $R0: [Character] = 3 values { [0] = "A" [1] = "B" [2] = "C" }
let str = "ABC" let arr = map(str) { s -> String in String(s) }
let string = "1;2;3" let array = string.components(separatedBy: ";") print(array)
let string = "hell0" let ar = Array(string.characters) print(ar)
let characters = "Hello" var charactersArray: [Character] = [] for (index, character) in enumerate(characters) { charactersArray.append(character) } println(charactersArray)
let charArr1 = [Character](myString) let charArr2 = Array(myString) for char in myString { }
let charArr1 = [Character](myString.characters) let charArr2 = Array(myString.characters) for char in myString.characters { }
extension String { func letterize() -> [Character] { return Array(self.characters) } }
let array1 = Array("hello") let array2 = Array("hello").map({ "\($0)" }) let array3 = "hello".map(String.init)
var strArray = "Hello, playground".Letterize() extension String { func Letterize() -> [String] { return map(self) { String($0) } } }
func letterize() -> [Character] { return Array(self.characters) }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let text = textField.text else { return true } let count = text.count + string.count - range.length return count <= 10 }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let text = textField.text else { return true } let count = text.utf8.count + string.utf8.count - range.length return count <= 10 }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let text = textField.text else { return true } let count = text.utf16.count + string.utf16.count - range.length return count <= 10 }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let text = textField.text else { return true } let count = text.unicodeScalars.count + string.unicodeScalars.count - range.length return count <= 10 }
import UIKit class ViewController: UIViewController, UITextFieldDelegate { @IBOutlet var textField: UITextField! override func viewDidLoad() { super.viewDidLoad() textField.delegate = self } func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let text = textField.text else { return true } let count = text.count + string.count - range.length return count <= 10 } }
func checkMaxLength(textField: UITextField!, maxLength: Int) { if (countElements(textField.text!) > maxLength) { textField.deleteBackward() } }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let text = textField.text else { return true } let newLength = text.count + string.count - range.length return newLength <= 10 }
@IBAction func mobileTFChanged(sender: AnyObject) { checkMaxLength(sender as! UITextField, maxLength: 10) } @IBAction func citizenTFChanged(sender: AnyObject) { checkMaxLength(sender as! UITextField, maxLength: 13) } func checkMaxLength(textField: UITextField!, maxLength: Int) { if (textField.text!.characters.count > maxLength) { textField.deleteBackward() } }
func checkMaxLength(textField: UITextField!, maxLength: Int) { if (textField.text!.characters.count > maxLength) { textField.deleteBackward() } }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let nsString = NSString(string: textField.text!) let newText = nsString.replacingCharacters(in: range, with: string) return newText.characters.count <= limitCount }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { if textField == userNameFTF{ let char = string.cString(using: String.Encoding.utf8) let isBackSpace = strcmp(char, "\\b") if isBackSpace == -92 { return true } return textField.text!.count <= 9 } return true }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { if range.location > 9 { textField.text?.removeLast() } return true }
if(range.length + range.location > count(textField.text)) { return false; }
Here is my version of code. Hope it helps! func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let invalidCharacters = NSCharacterSet(charactersInString: "0123456789").invertedSet if let range = string.rangeOfCharacterFromSet(invalidCharacters, options: nil, range:Range<String.Index>(start: string.startIndex, end: string.endIndex)) { return false } if (count(textField.text) > 10 && range.length == 0) { self.view.makeToast(message: "Amount entry is limited to ten digits", duration: 0.5, position: HRToastPositionCenter) return false } else { } return true }
protocol TextEntryCharacterLimited{ var characterLimit:Int { get } } extension TextEntryCharacterLimited{ func charactersInTextField(textField:UITextField, willNotExceedCharacterLimitWithReplacementString string:String, range:NSRange) -> Bool{ let startingLength = textField.text?.characters.count ?? 0 let lengthToAdd = string.characters.count let lengthToReplace = range.length let newLength = startingLength + lengthToAdd - lengthToReplace return newLength <= characterLimit } func stringIsBackspaceWith(string:String, inRange range:NSRange) -> Bool{ if range.length == 1 && string.characters.count == 0 { return true } return false } }
required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder)! setup() } required override init(frame: CGRect) { super.init(frame: frame) setup() } func setup() { setMaxLength() } let maxLength = 10 private func setMaxLength() { addTarget(self, action: } @objc private func textfieldChanged(_ textField: UITextField) { guard let text = text else { return } let trimmed = text.characters.prefix(maxLength) self.text = String(trimmed) }
func textField(textField: UITextField!,shouldChangeCharactersInRange range: NSRange, replacementString string: String!) -> Bool { NSUInteger newLength = textField.text.length + string.length - range.length; return !(newLength > 10) }
var helloWorldTimer = NSTimer.scheduledTimerWithTimeInterval(60.0, target: self, selector: Selector("sayHello"), userInfo: nil, repeats: true) func sayHello() { NSLog("hello World") }
var helloWorldTimer = Timer.scheduledTimer(timeInterval: 60.0, target: self, selector: @objc func sayHello() { NSLog("hello World") }
weak var timer: Timer? func startTimer() { timer?.invalidate() timer = Timer.scheduledTimer(withTimeInterval: 60.0, repeats: true) { [weak self] _ in } } func stopTimer() { timer?.invalidate() } deinit { stopTimer() }
weak var timer: NSTimer? func startTimer() { timer?.invalidate() timer = NSTimer.scheduledTimerWithTimeInterval(60.0, target: self, selector: } func handleTimer(timer: NSTimer) { } func stopTimer() { timer?.invalidate() } override func viewDidDisappear(animated: Bool) { super.viewDidDisappear(animated) stopTimer() }
var timer: DispatchSourceTimer? func startTimer() { let queue = DispatchQueue(label: "com.domain.app.timer") timer = DispatchSource.makeTimerSource(queue: queue) timer!.scheduleRepeating(deadline: .now(), interval: .seconds(60)) timer!.setEventHandler { [weak self] in } timer!.resume() } func stopTimer() { timer?.cancel() timer = nil } deinit { self.stopTimer() }
var timer: dispatch_source_t? func startTimer() { let queue = dispatch_queue_create("com.domain.app.timer", nil) timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue) dispatch_source_set_timer(timer!, DISPATCH_TIME_NOW, 60 * NSEC_PER_SEC, 1 * NSEC_PER_SEC) dispatch_source_set_event_handler(timer!) { [weak self] in } dispatch_resume(timer!) } func stopTimer() { if let timer = timer { dispatch_source_cancel(timer) self.timer = nil } } deinit { self.stopTimer() }
var timer = Timer.scheduledTimer(withTimeInterval: 60, repeats: true) { (_) in print("Hello world") }
var timer = NSTimer.scheduledTimerWithTimeInterval(60, target: self, selector: Selector("function"), userInfo: nil, repeats: true)
let timer : DispatchSourceTimer = DispatchSource.makeTimerSource(flags: [], queue: DispatchQueue.main) timer.scheduleRepeating(deadline: .now(), interval: .seconds(60)) timer.setEventHandler { NSLog("Hello World") } timer.resume()
private func executeRepeatedly() { DispatchQueue.main.asyncAfter(deadline: .now() + 60.0) { [weak self] in self?.executeRepeatedly() } }
@IBAction func pushedRefresh(sender: AnyObject) { var refreshAlert = UIAlertView() refreshAlert.title = "Refresh?" refreshAlert.message = "All data will be lost." refreshAlert.addButtonWithTitle("Cancel") refreshAlert.addButtonWithTitle("OK") refreshAlert.show() }
var refreshAlert = UIAlertController(title: "Refresh", message: "All data will be lost.", preferredStyle: UIAlertControllerStyle.Alert) refreshAlert.addAction(UIAlertAction(title: "Ok", style: .Default, handler: { (action: UIAlertAction!) in print("Handle Ok logic here") })) refreshAlert.addAction(UIAlertAction(title: "Cancel", style: .Cancel, handler: { (action: UIAlertAction!) in print("Handle Cancel Logic here") })) presentViewController(refreshAlert, animated: true, completion: nil)
let refreshAlert = UIAlertController(title: "Refresh", message: "All data will be lost.", preferredStyle: UIAlertControllerStyle.alert) refreshAlert.addAction(UIAlertAction(title: "Ok", style: .default, handler: { (action: UIAlertAction!) in print("Handle Ok logic here") })) refreshAlert.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: { (action: UIAlertAction!) in print("Handle Cancel Logic here") })) present(refreshAlert, animated: true, completion: nil)
var refreshAlert = UIAlertController(title: "Log Out", message: "Are You Sure to Log Out ? ", preferredStyle: UIAlertControllerStyle.Alert) refreshAlert.addAction(UIAlertAction(title: "Confirm", style: .Default, handler: { (action: UIAlertAction!) in self.navigationController?.popToRootViewControllerAnimated(true) })) refreshAlert.addAction(UIAlertAction(title: "Cancel", style: .Default, handler: { (action: UIAlertAction!) in refreshAlert .dismissViewControllerAnimated(true, completion: nil) })) presentViewController(refreshAlert, animated: true, completion: nil)
let alertController = UIAlertController( title: "Your title", message: "Your message", preferredStyle: .alert) let defaultAction = UIAlertAction( title: "Close Alert", style: .default, handler: nil) alertController.addAction(defaultAction) present(alertController, animated: true, completion: nil)
@IBAction func showAlertDialog(_ sender: UIButton) { let dialogMessage = UIAlertController(title: "Confirm", message: "Are you sure you want to Logout?", preferredStyle: .alert) let ok = UIAlertAction(title: "OK", style: .default, handler: { (action) -> Void in print("Ok button click...") self.logoutFun() }) let cancel = UIAlertAction(title: "Cancel", style: .cancel) { (action) -> Void in print("Cancel button click...") } dialogMessage.addAction(ok) dialogMessage.addAction(cancel) self.present(dialogMessage, animated: true, completion: nil) }
func logoutFun() { print("Logout Successfully...!") }
func listFilesFromDocumentsFolder() -> [NSString]?{ var theError = NSErrorPointer() let dirs = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.AllDomainsMask, true) as? [String] if dirs != nil { let dir = dirs![0] as NSString let fileList = NSFileManager.defaultManager().contentsOfDirectoryAtPath(dir, error: theError) as [NSString] return fileList }else{ return nil } }
let fileManager = FileManager.default let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0] do { let fileURLs = try fileManager.contentsOfDirectory(at: documentsURL, includingPropertiesForKeys: nil) } catch { print("Error while enumerating files \(documentsURL.path): \(error.localizedDescription)") }
let documentsUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first! do { let directoryContents = try FileManager.default.contentsOfDirectory(at: documentsUrl, includingPropertiesForKeys: nil, options: []) print(directoryContents) let mp3Files = directoryContents.filter{ $0.pathExtension == "mp3" } print("mp3 urls:",mp3Files) let mp3FileNames = mp3Files.map{ $0.deletingPathExtension().lastPathComponent } print("mp3 list:", mp3FileNames) } catch { print(error.localizedDescription) }
func listFilesFromDocumentsFolder() -> [String]? { let fileMngr = FileManager.default; let docs = fileMngr.urls(for: .documentDirectory, in: .userDomainMask)[0].path return try? fileMngr.contentsOfDirectory(atPath:docs) }
override func viewDidLoad() { print(listFilesFromDocumentsFolder()) }
func contentsOfDirectory(at url: URL, includingPropertiesForKeys keys: [URLResourceKey]?, options mask: FileManager.DirectoryEnumerationOptions = []) throws -> [URL]
guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return } do { let directoryContents = try FileManager.default.contentsOfDirectory(at: documentsDirectory, includingPropertiesForKeys: nil, options: []) print(directoryContents) } catch { print("Could not search for urls of files in documents directory: \(error)") }
import UIKit class ViewController: UIViewController { @IBAction func copyFile(_ sender: UIButton) { guard let bundleFileUrl = Bundle.main.url(forResource: "Movie", withExtension: "mov") else { return } guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return } let documentDirectoryFileUrl = documentsDirectory.appendingPathComponent("Movie.mov") if !FileManager.default.fileExists(atPath: documentDirectoryFileUrl.path) { do { try FileManager.default.copyItem(at: bundleFileUrl, to: documentDirectoryFileUrl) } catch { print("Could not copy file: \(error)") } } } @IBAction func displayUrls(_ sender: UIButton) { guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return } do { let directoryContents = try FileManager.default.contentsOfDirectory(at: documentsDirectory, includingPropertiesForKeys: nil, options: []) print(directoryContents) } catch { print("Could not search for urls of files in documents directory: \(error)") } } }
func listWithFilter () { let fileManager = NSFileManager.defaultManager() let documentsUrl = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0] as NSURL do { if let directoryUrls = try? NSFileManager.defaultManager().contentsOfDirectoryAtURL(documentsUrl, includingPropertiesForKeys: nil, options: NSDirectoryEnumerationOptions.SkipsSubdirectoryDescendants) { print(directoryUrls) ........ } } }
func listFiles() -> [String] { var theError = NSErrorPointer() let dirs = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.AllDomainsMask, true) as? [String] if dirs != nil { let dir = dirs![0] do { let fileList = try NSFileManager.defaultManager().contentsOfDirectoryAtPath(dir) return fileList as [String] }catch { } }else{ let fileList = [""] return fileList } let fileList = [""] return fileList }
func listFilesFromDocumentsFolder() -> [String] { var theError = NSErrorPointer() let dirs = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NSSearchPathDomainMask.AllDomainsMask, true) as? [String] if dirs != nil { let dir = dirs![0] let fileList = NSFileManager.defaultManager().contentsOfDirectoryAtPath(dir, error: theError) return fileList as! [String] }else{ let fileList = [""] return fileList } }
let fileManager:NSFileManager = NSFileManager.defaultManager() var fileList = listFilesFromDocumentsFolder() let count = fileList.count var isDir:Bool = true; for var i:Int = 0; i < count; i++ { if fileManager.fileExistsAtPath(fileList[i]) != true { println("File is \(fileList[i])") } }
throw new RuntimeException("A custom message here")
enum MyError: ErrorType { case runtimeError(String) }
func someFunction() throws { throw MyError.runtimeError("some message") } do { try someFunction() } catch MyError.runtimeError(let errorMessage) { print(errorMessage) }
extension String: LocalizedError { public var errorDescription: String? { return self } }
struct RuntimeError: Error { let message: String init(_ message: String) { self.message = message } public var localizedDescription: String { return message } }
enum UserValidationError: String, Error { case noFirstNameProvided = "Please insert your first name." case noLastNameProvided = "Please insert your last name." case noAgeProvided = "Please insert your age." case noEmailProvided = "Please insert your email." }
do { try User.define(firstName, lastName: lastName, age: age, email: email, gender: gender, location: location, phone: phone) } catch let error as User.UserValidationError { print(error.rawValue) return }
import Foundation do { throw NSError(domain: "my error description", code: 42, userInfo: ["ui1":12, "ui2":"val2"] ) } catch let error as NSError { print("Caught NSError: \(error.localizedDescription), \(error.domain), \(error.code)") let uis = error.userInfo print("\tUser info:") for (key,value) in uis { print("\t\tkey=\(key), value=\(value)") } }
Caught NSError: The operation could not be completed, my error description, 42 User info: key=ui1, value=12 key=ui2, value=val2
extension String: Error {} extension String: LocalizedError { public var errorDescription: String? { return self } } func test(color:NSColor) throws{ if color == .red { throw "I don }else if color == .green { throw "I }else { throw "I like all other colors" } } do { try test(color:.green) } catch let error where error.localizedDescription == "I don Swift.print ("Error: \(error)") }catch let error { Swift.print ("Other cases: Error: \(error.localizedDescription)") }
NSException(name:NSExceptionName(rawValue: "name"), reason:"reason", userInfo:nil).raise()
struct RuntimeError: LocalizedError { let message: String init(_ message: String) { self.message = message } public var errorDescription: String? { return message } }
class MyClass { func myFunc() { let testStr = "test" let testStrLen = countElements(testStr) } }
class MyClass { let testStr = "test" let testStrLen = countElements(testStr) func myFunc() { } }
class MyClass { let testStr = "test" let testStrLen = countElements("test") func myFunc() { } }
struct MyClassConstants{ static let testStr = "test" static let testStrLength = countElements(testStr) static let arrayOfTests: [String] = ["foo", "bar", testStr] }
struct Constants { struct MixpanelConstants { static let activeScreen = "Active Screen"; } struct CrashlyticsConstants { static let userType = "User Type"; } }
import Swift class MyClass { static let testStr = "test" static let testStrLen = count(testStr) init() { println("There are \(MyClass.testStrLen) characters in \(MyClass.testStr)") } } let a = MyClass()
let testStr = "test" let testStrLen = countElements(testStr) class MyClass { func myFunc() { } }
class MyClass { let testStr: String = "test" lazy var testStrLen: Int = countElements(self.testStr) func myFunc() { } }
class MyClass { class var myConstant: String { return "What is Love? Baby don } MyClass.myConstant
class MyClass { struct Constants { static let testStr = "test" static let testStrLen = testStr.characters.count private static let testInt = 1 } func ownFunction() { var newInt = Constants.testInt + 1 print("Print testStr=\(Constants.testStr)") } }
class MyClass2 { func accessOtherConstants() { print("MyClass } }
class MyClass { struct Constants { static let testStr = "test" static let testStrLen = testStr.characters.count private static let testInt = 1 static func singletonFunction() { print("Print singletonFunction testInt=\(testInt)") var newInt = testStrLen newInt = newInt + 1 print("Print singletonFunction testStr=\(testStr)") } } func ownFunction() { var newInt2 = Constants.testStrLen newInt2 = newInt2 + 1 print("Print ownFunction testStr=\(Constants.testStr)") print("Print ownFunction newInt2=\(newInt2)") } } let newInt = MyClass.Constants.testStrLen print("Print testStr=\(MyClass.Constants.testStr)") print("Print testInt=\(newInt)") let myClass = MyClass() myClass.ownFunction() MyClass.Constants.singletonFunction()
var myDict : Dictionary<String,MyClass> = Dictionary<String,MyClass>()
let intIndex = 1 let index = myDictionary.startIndex.advancedBy(intIndex) myDictionary.keys[index]
extension Dictionary { subscript(i: Int) -> (key: Key, value: Value) { return self[index(startIndex, offsetBy: i)] } }
let dict = ["c": 123, "d": 045, "a": 456] for (index, entry) in enumerate(dict) { println(index) println(entry) }
var sortedKeysArray = sorted(dict) { $0.0 < $1.0 } println(sortedKeysArray) var sortedValuesArray = sorted(dict) { $0.1 < $1.1 } println(sortedValuesArray)
for (index, entry) in enumerate(sortedKeysArray) { println(index) println(entry.0) println(entry.1) }
let airportCodes = [String](airports.keys) let airportNames = [String](airports.values)
let wordByLanguage = ["English": 5, "Spanish": 4, "Polish": 3, "Arabic": 2] if let firstLang = wordByLanguage.first?.key { print(firstLang) }
extension Dictionary { subscript(i:Int) -> (key:Key,value:Value) { get { return self[index(startIndex, offsetBy: i)]; } } }
var person = ["name":"Sean", "gender":"male"] person.keys.array[1] person.values.array[1]
var array_has_dictionary = [ [ "name" : "xxxx", "age" : "xxxx", "last_name":"xxx" ], [ "name" : "yyy", "age" : "yyy", "last_name":"yyy" ], ] cell.textLabel?.text = Array(array_has_dictionary[1])[1].key
import UIKit class CircleView: UIView { override init(frame: CGRect) { super.init(frame: frame) self.backgroundColor = UIColor.clearColor() } required init(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } override func drawRect(rect: CGRect) { var context = UIGraphicsGetCurrentContext(); CGContextSetLineWidth(context, 5.0); UIColor.redColor().set() CGContextAddArc(context, (frame.size.width)/2, frame.size.height/2, (frame.size.width - 10)/2, 0.0, CGFloat(M_PI * 2.0), 1) CGContextStrokePath(context); } }
func addCircleView() { let diceRoll = CGFloat(Int(arc4random_uniform(7))*50) var circleWidth = CGFloat(200) var circleHeight = circleWidth var circleView = CircleView(frame: CGRectMake(diceRoll, 0, circleWidth, circleHeight)) view.addSubview(circleView) }
let circleLayer: CAShapeLayer! override init(frame: CGRect) { super.init(frame: frame) self.backgroundColor = UIColor.clearColor() let circlePath = UIBezierPath(arcCenter: CGPoint(x: frame.size.width / 2.0, y: frame.size.height / 2.0), radius: (frame.size.width - 10)/2, startAngle: 0.0, endAngle: CGFloat(M_PI * 2.0), clockwise: true) circleLayer = CAShapeLayer() circleLayer.path = circlePath.CGPath circleLayer.fillColor = UIColor.clearColor().CGColor circleLayer.strokeColor = UIColor.redColor().CGColor circleLayer.lineWidth = 5.0; circleLayer.strokeEnd = 0.0 layer.addSublayer(circleLayer) }
func animateCircle(duration: NSTimeInterval) { let animation = CABasicAnimation(keyPath: "strokeEnd") animation.duration = duration animation.fromValue = 0 animation.toValue = 1 animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear) circleLayer.strokeEnd = 1.0 circleLayer.addAnimation(animation, forKey: "animateCircle") }
func addCircleView() { let diceRoll = CGFloat(Int(arc4random_uniform(7))*50) var circleWidth = CGFloat(200) var circleHeight = circleWidth var circleView = CircleView(frame: CGRectMake(diceRoll, 0, circleWidth, circleHeight)) view.addSubview(circleView) circleView.animateCircle(1.0) }
var circleLayer: CAShapeLayer! override init(frame: CGRect) { super.init(frame: frame) self.backgroundColor = UIColor.clear let circlePath = UIBezierPath(arcCenter: CGPoint(x: frame.size.width / 2.0, y: frame.size.height / 2.0), radius: (frame.size.width - 10)/2, startAngle: 0.0, endAngle: CGFloat(M_PI * 2.0), clockwise: true) circleLayer = CAShapeLayer() circleLayer.path = circlePath.cgPath circleLayer.fillColor = UIColor.clear.cgColor circleLayer.strokeColor = UIColor.red.cgColor circleLayer.lineWidth = 5.0; circleLayer.strokeEnd = 0.0 layer.addSublayer(circleLayer) } required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } func animateCircle(duration: TimeInterval) { let animation = CABasicAnimation(keyPath: "strokeEnd") animation.duration = duration animation.fromValue = 0 animation.toValue = 1 animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear) circleLayer.strokeEnd = 1.0 circleLayer.add(animation, forKey: "animateCircle") }
func addCircleView() { let diceRoll = CGFloat(Int(arc4random_uniform(7))*50) var circleWidth = CGFloat(200) var circleHeight = circleWidth let circleView = CircleView(frame: CGRect(x: diceRoll, y: 0, width: circleWidth, height: circleHeight)) view.addSubview(circleView) circleView.animateCircle(duration: 1.0) }
let centerX:CGFloat = 55 let centerY:CGFloat = 55 let radius:CGFloat = 50 var currentAngle:Float = -90 let minAngle:Float = -90 let maxAngle:Float = 270
override func drawRect(rect: CGRect) { let context = UIGraphicsGetCurrentContext() let path = CGPathCreateMutable() CGPathAddArc(path, nil, centerX, centerY, radius, CGFloat(GLKMathDegreesToRadians(minAngle)), CGFloat(GLKMathDegreesToRadians(currentAngle)), false) CGContextAddPath(context, path) CGContextSetStrokeColorWithColor(context, UIColor.blueColor().CGColor) CGContextSetLineWidth(context, 3) CGContextStrokePath(context) }
NSTimer.scheduledTimerWithTimeInterval(timeBetweenDraw, target: self, selector:
func updateTimer() { if currentAngle < maxAngle { currentAngle += 1 } }
func updateTimer() { if currentAngle < maxAngle { currentAngle += 1 setNeedsDisplay() } }
import UIKit import GLKit class CircleClosing: UIView { let centerX:CGFloat = 55 let centerY:CGFloat = 55 let radius:CGFloat = 50 var currentAngle:Float = -90 let timeBetweenDraw:CFTimeInterval = 0.01 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) setup() } override init(frame: CGRect) { super.init(frame: frame) setup() } func setup() { self.backgroundColor = UIColor.clearColor() NSTimer.scheduledTimerWithTimeInterval(timeBetweenDraw, target: self, selector: } func updateTimer() { if currentAngle < 270 { currentAngle += 1 setNeedsDisplay() } } override func drawRect(rect: CGRect) { let context = UIGraphicsGetCurrentContext() let path = CGPathCreateMutable() CGPathAddArc(path, nil, centerX, centerY, radius, -CGFloat(M_PI/2), CGFloat(GLKMathDegreesToRadians(currentAngle)), false) CGContextAddPath(context, path) CGContextSetStrokeColorWithColor(context, UIColor.blueColor().CGColor) CGContextSetLineWidth(context, 3) CGContextStrokePath(context) } }
func animateCircleFull(duration: TimeInterval) { CATransaction.begin() let animation = CABasicAnimation(keyPath: "strokeEnd") animation.duration = duration animation.fromValue = 0 animation.toValue = 1 animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) circleLayer.strokeEnd = 1.0 CATransaction.setCompletionBlock { print("animation complete") } circleLayer.add(animation, forKey: "animateCircle") CATransaction.commit() }
func animate(duration: TimeInterval){ self.isAnimating = true self.animateCircleFull(duration: 1) } func endAnimate(){ self.isAnimating = false } func animateCircleFull(duration: TimeInterval) { if self.isAnimating{ CATransaction.begin() let animation = CABasicAnimation(keyPath: "strokeEnd") animation.duration = duration animation.fromValue = 0 animation.toValue = 1 animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) circleLayer.strokeEnd = 1.0 CATransaction.setCompletionBlock { self.animateCircleEmpty(duration: duration) } circleLayer.add(animation, forKey: "animateCircle") CATransaction.commit() } } func animateCircleEmpty(duration: TimeInterval){ if self.isAnimating{ CATransaction.begin() let animation = CABasicAnimation(keyPath: "strokeEnd") animation.duration = duration animation.fromValue = 1 animation.toValue = 0 animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) circleLayer.strokeEnd = 0 CATransaction.setCompletionBlock { self.animateCircleFull(duration: duration) } circleLayer.add(animation, forKey: "animateCircle") CATransaction.commit() } }
func setCircleClockwise(){ let circlePath = UIBezierPath(arcCenter: CGPoint(x: frame.size.width / 2.0, y: frame.size.height / 2.0), radius: (frame.size.width - 10)/2, startAngle: 0.0, endAngle: CGFloat(M_PI * 2.0), clockwise: true) self.circleLayer.removeFromSuperlayer() self.circleLayer = formatCirle(circlePath: circlePath) self.layer.addSublayer(self.circleLayer) } func setCircleCounterClockwise(){ let circlePath = UIBezierPath(arcCenter: CGPoint(x: frame.size.width / 2.0, y: frame.size.height / 2.0), radius: (frame.size.width - 10)/2, startAngle: 0.0, endAngle: CGFloat(M_PI * 2.0), clockwise: false) self.circleLayer.removeFromSuperlayer() self.circleLayer = formatCirle(circlePath: circlePath) self.layer.addSublayer(self.circleLayer) } func formatCirle(circlePath: UIBezierPath) -> CAShapeLayer{ let circleShape = CAShapeLayer() circleShape.path = circlePath.cgPath circleShape.fillColor = UIColor.clear.cgColor circleShape.strokeColor = UIColor.red.cgColor circleShape.lineWidth = 10.0; circleShape.strokeEnd = 0.0 return circleShape } func animate(duration: TimeInterval){ self.isAnimating = true self.animateCircleFull(duration: 1) } func endAnimate(){ self.isAnimating = false } func animateCircleFull(duration: TimeInterval) { if self.isAnimating{ CATransaction.begin() let animation = CABasicAnimation(keyPath: "strokeEnd") animation.duration = duration animation.fromValue = 0 animation.toValue = 1 animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) circleLayer.strokeEnd = 1.0 CATransaction.setCompletionBlock { self.setCircleCounterClockwise() self.animateCircleEmpty(duration: duration) } circleLayer.add(animation, forKey: "animateCircle") CATransaction.commit() } } func animateCircleEmpty(duration: TimeInterval){ if self.isAnimating{ CATransaction.begin() let animation = CABasicAnimation(keyPath: "strokeEnd") animation.duration = duration animation.fromValue = 1 animation.toValue = 0 animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) circleLayer.strokeEnd = 0 CATransaction.setCompletionBlock { self.setCircleClockwise() self.animateCircleFull(duration: duration) } circleLayer.add(animation, forKey: "animateCircle") CATransaction.commit() } }
import UIKit @IBDesignable class TIFAttributedLabel: UILabel { @IBInspectable var fontSize: CGFloat = 13.0 @IBInspectable var fontFamily: String = "DIN Light" override func awakeFromNib() { var attrString = NSMutableAttributedString(attributedString: self.attributedText) attrString.addAttribute(NSFontAttributeName, value: UIFont(name: self.fontFamily, size: self.fontSize)!, range: NSMakeRange(0, attrString.length)) self.attributedText = attrString } }
private let fontMapping = [ "HelveticaNeue-Medium": "ITCAvantGardePro-Md", "HelveticaNeue": "ITCAvantGardePro-Bk", "HelveticaNeue-Bold": "ITCAvantGardePro-Demi", ] func switchFontFamily(string: NSAttributedString) -> NSAttributedString { var result = NSMutableAttributedString(attributedString: string) string.enumerateAttribute(NSFontAttributeName, inRange: NSRange(location: 0, length: string.length), options: nil) { (font, range, _) in if let font = font as? UIFont { result.removeAttribute(NSFontAttributeName, range: range) result.addAttribute(NSFontAttributeName, value: UIFont(name: fontMapping[font.fontName]!, size: font.pointSize)!, range: range) } } return result }
NSMutableAttributedString* ApplyCustomFont(NSAttributedString *attributedText, UIFont* boldFont, UIFont* italicFont, UIFont* boldItalicFont, UIFont* regularFont) { NSMutableAttributedString *attrib = [[NSMutableAttributedString alloc] initWithAttributedString:attributedText]; [attrib beginEditing]; [attrib enumerateAttribute:NSFontAttributeName inRange:NSMakeRange(0, attrib.length) options:0 usingBlock:^(id value, NSRange range, BOOL *stop) { if (value) { UIFont *oldFont = (UIFont *)value; NSLog(@"%@",oldFont.fontName); [attrib removeAttribute:NSFontAttributeName range:range]; if([oldFont.fontName rangeOfString:@"BoldItalic"].location != NSNotFound && boldItalicFont != nil) [attrib addAttribute:NSFontAttributeName value:boldItalicFont range:range]; else if([oldFont.fontName rangeOfString:@"Italic"].location != NSNotFound && italicFont != nil) [attrib addAttribute:NSFontAttributeName value:italicFont range:range]; else if([oldFont.fontName rangeOfString:@"Bold"].location != NSNotFound && boldFont != nil) [attrib addAttribute:NSFontAttributeName value:boldFont range:range]; else if(regularFont != nil) [attrib addAttribute:NSFontAttributeName value:regularFont range:range]; } }]; [attrib endEditing]; return attrib; }
extension String { func toMarkerFelt() -> NSAttributedString { var style = NSMutableParagraphStyle() style.paragraphSpacing = 5.0 let markerFontAttributes : [NSObject : AnyObject]? = [ NSFontAttributeName : UIFont(name: "Marker Felt", size: 14.0)!, NSParagraphStyleAttributeName: style, NSForegroundColorAttributeName : UIColor.blackColor() ] let s = NSAttributedString(string: self, attributes: markerFontAttributes) return s } }
class MarkerFeltCell: UITableViewCell { @IBOutlet weak var myLabel: UILabel! func configureCellWithString(inputString : String) { myLabel.attributedText = inputString.toMarkerFelt() }}
let cellName = "MarkerFeltCell" tableView.registerNib(UINib(nibName: cellName, bundle: nil), forCellReuseIdentifier: cellName)
override func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { if xib == "MarkerFeltCell" { if prototypeCell == nil { prototypeCell = tableView.dequeueReusableCellWithIdentifier(xib) as? MarkerFeltCell } let width : CGFloat = tableView.bounds.width let height : CGFloat = prototypeCell!.bounds.height prototypeCell?.bounds = CGRect(x: 0, y: 0, width: width, height: height) configureCell(prototypeCell!, atIndexPath: indexPath) prototypeSummaryCell?.layoutIfNeeded() let size = prototypeSummaryCell!.contentView.systemLayoutSizeFittingSize(UILayoutFittingCompressedSize) let nextHeight : CGFloat = ceil(size.height + 1.0) return nextHeight } else {
func configureCell(cell :UITableViewCell, atIndexPath indexPath: NSIndexPath) { if let realCell = cell as? MarkerFeltCell { realCell.configureCellWithString("Multi-line string.\nLine 2.\nLine 3.") } }
UITextView.appearance().font = UIFont(name: "IranSans", size: 17)
UILabel.appearance().font = UIFont(name: "IranSans", size: 17)
display.text = display.text!.substringFromIndex(advance(display.text!.startIndex, 1))
var myString = "Hello, World" myString.remove(at: myString.startIndex) myString
let original = "Hello" let sliced = dropFirst(original)
let original = "Hello" let sliced = String(original.characters.dropFirst())
let original = "Hello" let sliced = String(suffix(original.utf16, original.utf16.count - 1))
var original = "Hello" let removedChar = original.removeAtIndex(original.startIndex) original
let original = "Hello" let substring = original.substringFromIndex(advance(original.startIndex, 1))
let original = "Hello" let newStartIndex = advance(original.startIndex, 1) let newEndIndex = advance(original.endIndex, -1) let substring = original.substringWithRange(newStartIndex..<newEndIndex)
let substring = original[newStartIndex..<newEndIndex]
let str = "hello" let result1 = String(str.dropFirst()) let result2 = String(str.dropLast())
let result3 = String(str.dropLast(3)) let result4 = String(str.dropFirst(4))
extension String { func chopPrefix(_ count: Int = 1) -> String { return substring(from: index(startIndex, offsetBy: count)) } func chopSuffix(_ count: Int = 1) -> String { return substring(to: index(endIndex, offsetBy: -count)) } } "hello".chopPrefix() "hello".chopPrefix(3) "hello".chopSuffix() "hello".chopSuffix(3)
extension String { func chopPrefix(count: Int = 1) -> String { return self.substringFromIndex(advance(self.startIndex, count)) } func chopSuffix(count: Int = 1) -> String { return self.substringToIndex(advance(self.endIndex, -count)) } } "hello".chopPrefix() "hello".chopPrefix(3) "hello".chopSuffix() "hello".chopSuffix(3)
extension String { func chopPrefix(_ count: Int = 1) -> String { return self.substringFromIndex(advance(self.startIndex, count)) } func chopSuffix(_ count: Int = 1) -> String { return self.substringToIndex(advance(self.endIndex, -count)) } }
func chopPrefix(count: Int = 1) -> String { return self.substringFromIndex(self.startIndex.advancedBy(count)) } func chopSuffix(count: Int = 1) -> String { return self.substringFromIndex(self.endIndex.advancedBy(count)) }
func chopPrefix(_ count: Int = 1) -> String { return self.substring(from: self.characters.index(self.startIndex, offsetBy: count)) } func chopSuffix(_ count: Int = 1) -> String { return self.substring(to: self.characters.index(self.endIndex, offsetBy: -count)) }
@available(swift, deprecated: 3.2, message: "Please use String or Substring directly") public var characters: String.CharacterView
func chopPrefix(_ count: Int = 1) -> String { if count >= 0 && count <= self.count { return self.substring(from: String.Index(encodedOffset: count)) } return "" } func chopSuffix(_ count: Int = 1) -> String { if count >= 0 && count <= self.count { return self.substring(to: String.Index(encodedOffset: self.count - count)) } return "" }
extension String { func chopPrefix(_ count: Int = 1) -> String { if count >= 0 && count <= self.count { let indexStartOfText = self.index(self.startIndex, offsetBy: count) return String(self[indexStartOfText...]) } return "" } func chopSuffix(_ count: Int = 1) -> String { if count >= 0 && count <= self.count { let indexEndOfText = self.index(self.endIndex, offsetBy: -count) return String(self[..<indexEndOfText]) } return "" } }
let cleanedString = String(theString.characters.dropFirst())
let str = "hello" let strSlice = str.dropFirst() let str2 = String(strSlice)
var line: String = "This is a string..." var char: Character? = nil char = line.removeFirst() print("char = \(char)") print("line = \(line)")
public prefix func ++ <I: ForwardIndexType>(index: I) -> I { return advance(index, 1) }
extension String { func substringFromIndex(index: Int) -> String { if (index < 0 || index > self.characters.count) { print("index \(index) out of bounds") return "" } return self.substringFromIndex(self.startIndex.advancedBy(index)) } } display.text = display.text!.substringFromIndex(1)
extension String { func chopPrefix(count: Int = 1) -> String { return self.substringFromIndex(self.startIndex.advancedBy(count)) } func chopSuffix(count: Int = 1) -> String { return self.substringToIndex(self.endIndex.advancedBy(-count)) } }
let choppedString = String(txtField.text!.characters.dropFirst())
extension String { func chopPrefix(_ count: Int = 1) -> String { return count>self.count ? self : String(self[index(self.startIndex, offsetBy: count)...]) } }
extension String { func chopPrefix(_ count: UInt = 1) -> String { return substring(from: characters.index(startIndex, offsetBy: Int(count))) } func chopSuffix(_ count: UInt = 1) -> String { return substring(to: characters.index(endIndex, offsetBy: -Int(count))) } } class StringChopTests: XCTestCase { func testPrefix() { XCTAssertEqual("original".chopPrefix(0), "original") XCTAssertEqual("Xfile".chopPrefix(), "file") XCTAssertEqual("filename.jpg".chopPrefix(4), "name.jpg") } func testSuffix() { XCTAssertEqual("original".chopSuffix(0), "original") XCTAssertEqual("fileX".chopSuffix(), "file") XCTAssertEqual("filename.jpg".chopSuffix(4), "filename") } }
for i in stride(from:5,through:1,by:-1) { print(i) }
for i in 0.stride(to: -8, by: -2) { print(i) } for i in 0.stride(through: -8, by: -2) { print(i) }
for i in 0.5.stride(to:-0.1, by: -0.1) { print(i) }
for x in stride(from: 0, through: -8, by: -2) { println(x) } for x in stride(from: 6, to: -2, by: -4) { println(x) }
infix operator >>> { associativity none precedence 135 } func >>> <Pos : ForwardIndexType where Pos : Comparable>(end:Pos, start:Pos) -> ReverseRandomAccessCollection<(Range<Pos>)> { return (start..<end).reverse() }
infix operator >>> : RangeFormationPrecedence func >>><Bound>(maximum: Bound, minimum: Bound) -> ReversedRandomAccessCollection<CountableRange<Bound>> where Bound : Comparable, Bound.Stride : Integer { return (minimum..<maximum).reversed() }
infix operator >>> : RangeFormationPrecedence func >>><Bound>(maximum: Bound, minimum: Bound) -> ReversedRandomAccessCollection<CountableRange<Bound>> where Bound : Comparable & Strideable { return (minimum..<maximum).reversed() }
infix operator >>> : RangeFormationPrecedence func >>><Bound>(maximum: Bound, minimum: Bound) -> ReversedRandomAccessCollection<Range<Bound>> where Bound : Strideable { return (minimum..<maximum).reversed() }
for x in reverse(0 ... 4) { println(x) } for x in reverse(0 ..< 4) { println(x) }
for x in stride(from: 0, through: -8, by: -2) { println(x) } for x in stride(from: 6, to: -2, by: -4) { println(x) }
for i in sequence(first: 10, next: {$0 - 1}) { guard i >= 0 else { break } print(i) }
internal enum MyEnum: Int { case Zero = 0, One, Two } extension MyEnum { init?(string: String) { switch string.lowercaseString { case "zero": self = .Zero case "one": self = .One case "two": self = .Two default: return nil } } }
internal class MyClass { let foo = MyEnum(rawValue: 0) let fooStr = MyEnum(string: "zero") func testFunc() { let bar = MyEnum(rawValue: 1) let barStr = MyEnum(string: "one") } }
extension TemplateSlotType { init?(rawString: String) { if rawString.rangeOfString("carrousel") != nil { self.init(rawValue:"carrousel") } else { self.init(rawValue:rawString) } } }
extension MyEnum { init?(string: String) { switch string.lowercaseString { case "zero": self.init(rawValue:0) case "one": self.init(rawValue:1) case "two": self.init(rawValue:2) default: return nil } } }
enum VehicleType: Int, CustomStringConvertible { case car = 4 case moped = 2 case truck = 16 case unknown = -1 public var description: String { switch self { case .car: return "Car" case .truck: return "Truck" case .moped: return "Moped" case .unknown: return "unknown" } } static let all: [VehicleType] = [car, moped, truck] init?(rawDescription: String) { guard let type = VehicleType.all.first(where: { description == rawDescription }) else { return nil } self = type } }
func enumFromString(string:String) -> MyEnum? { switch string { case "One" : MyEnum(rawValue:1) case "Two" : MyEnum(rawValue:2) case "Three" : MyEnum(rawValue:3) default : return nil } }
enum Word: Int, EnumSequenceElement, CustomStringConvertible { case apple, cat, fun var description: String { switch self { case .apple: return "Apple" case .cat: return "Cat" case .fun: return "Fun" } } } let Words: [String: Word] = [ "A": .apple, "C": .cat, "F": .fun ] extension Word { var letter: String? { return Words.first(where: { (_, word) -> Bool in word == self })?.key } init?(_ letter: String) { if let word = Words[letter] { self = word } else { return nil } } } for word in EnumSequence<Word>() { if let letter = word.letter, let lhs = Word(letter), let rhs = Word(letter), lhs == rhs { print("\(letter) for \(word)") } }
extension MyEnum { init?(rawValue: Int) { switch rawValue { case 0: self = .Zero case 1: self = .One case 2: self = .Two default: return nil } } }
(lldb) po managedObject error: Error in auto-import: failed to get module
error: Error in auto-import: failed to get module <module-includes>:1:9: note: in file included from <module-includes>:1: ^ /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include/libxml2/libxml/tree.h:17:10: error: ^ could not build Objective-C module
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { print(deviceToken) print(String(data: deviceToken , encoding: .utf8)) }
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { print(deviceToken) print(String(data: deviceToken , encoding: .utf8)) let d = NSData(data: deviceToken) print(d) }
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { let token = deviceToken.map { String(format: "%02.2hhx", $0) }.joined() print(token) }
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { var token = "" for i in 0..<deviceToken.count { token = token + String(format: "%02.2hhx", arguments: [deviceToken[i]]) } print(token) }
extension Data { var hexString: String { return map { String(format: "%02.2hhx", arguments: [$0]) }.joined() } }
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { let token = String(data: deviceToken.base64EncodedData(), encoding: .utf8)?.trimmingCharacters(in: CharacterSet.whitespaces).trimmingCharacters(in: CharacterSet(charactersIn: "<>")) }
if let deviceTokenString = deviceToken.reduce("", {$0 + String(format: "%02X", $1)}) }
let tokenData = deviceToken as NSData let token = tokenData.description token = token.replacingOccurrences(of: " ", with: "") token = token.replacingOccurrences(of: "<", with: "" token = token.replacingOccurrences(of: ">", with: "")
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { let token = deviceToken.map({ String(format: "%02.2hhx", $0)}).joined() print("TOKEN: " + token) }
let token = String(format:"%@",deviceToken as CVarArg).components(separatedBy: CharacterSet.alphanumerics.inverted).joined(separator: "")
let token = deviceToken.map { String(format: "%02.2hhx", $0) }.joined()
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { var formattedToken = "" for i in 0..<deviceToken.count { formattedToken = formattedToken + String(format: "%02.2hhx", arguments: [deviceToken[i]]) } print(formattedToken) }
func heightForView(text:String, font:UIFont, width:CGFloat) -> CGFloat{ let label:UILabel = UILabel(frame: CGRectMake(0, 0, width, CGFloat.max)) label.numberOfLines = 0 label.lineBreakMode = NSLineBreakMode.ByWordWrapping label.font = font label.text = text label.sizeToFit() return label.frame.height }
import UIKit func heightForView(text:String, font:UIFont, width:CGFloat) -> CGFloat{ let label:UILabel = UILabel(frame: CGRectMake(0, 0, width, CGFloat.greatestFiniteMagnitude)) label.numberOfLines = 0 label.lineBreakMode = NSLineBreakMode.byWordWrapping label.font = font label.text = text label.sizeToFit() return label.frame.height } let font = UIFont(name: "Helvetica", size: 20.0) var height = heightForView("This is just a load of text", font: font, width: 100.0)
func heightForView(text:String, font:UIFont, width:CGFloat) -> CGFloat{ let label:UILabel = UILabel(frame: CGRect(x: 0, y: 0, width: width, height: CGFloat.greatestFiniteMagnitude)) label.numberOfLines = 0 label.lineBreakMode = NSLineBreakMode.byWordWrapping label.font = font label.text = text label.sizeToFit() return label.frame.height }
extension UILabel { func setSizeFont (sizeFont: CGFloat) { self.font = UIFont(name: self.font.fontName, size: sizeFont)! self.sizeToFit() } }
_title.frame = CGRect(x: 0, y: 0, width: bounds.width, height: 0) _title.sizeToFit() _title.frame.size = _title.bounds.size
_title.lineBreakMode = .ByWordWrapping _title.numberOfLines = 0
func heightForView(text:String, font:UIFont, width:CGFloat) -> CGFloat{ var currHeight:CGFloat! let label:UILabel = UILabel(frame: CGRectMake(0, 0, width, CGFloat.max)) label.numberOfLines = 0 label.lineBreakMode = NSLineBreakMode.ByWordWrapping label.font = font label.text = text label.sizeToFit() currHeight = label.frame.height label.removeFromSuperview() return currHeight }
extension UILabel { var optimalHeight : CGFloat { get { let label = UILabel(frame: CGRectMake(0, 0, self.frame.width, CGFloat.max)) label.numberOfLines = 0 label.lineBreakMode = self.lineBreakMode label.font = self.font label.text = self.text label.sizeToFit() return label.frame.height } } }
self.brandModelLabel.frame.size.height = self.brandModelLabel.optimalHeight)
extension String { func heightForWithFont(font: UIFont, width: CGFloat, insets: UIEdgeInsets) -> CGFloat { let label:UILabel = UILabel(frame: CGRectMake(0, 0, width + insets.left + insets.right, CGFloat.max)) label.numberOfLines = 0 label.lineBreakMode = NSLineBreakMode.ByWordWrapping label.font = font label.text = self label.sizeToFit() return label.frame.height + insets.top + insets.bottom } }
let font = UIFont(name: "HelveticaNeue", size: 25)! let text = "This is some really long text just to test how it works for calculating heights in swift of string sizes. What if I add a couple lines of text?" let textString = text as NSString let textAttributes = [NSFontAttributeName: font] let textRect = textString.boundingRectWithSize(CGSizeMake(320, 2000), options: .UsesLineFragmentOrigin, attributes: textAttributes, context: nil)
func heightForView(text:String, font:UIFont, width:CGFloat) -> CGFloat { let label:UILabel = UILabel(frame: CGRect(x: 0, y: 0, width: width, height: CGFloat.greatestFiniteMagnitude)) label.numberOfLines = 0 label.lineBreakMode = NSLineBreakMode.byWordWrapping label.font = font label.text = text label.sizeToFit() return label.frame.height }
let height = heightForView(text: "This is your text", font: UIFont.systemFont(ofSize: 17), width: 300) print(height)
let proNameLbl = UILabel(frame: CGRect(x: 0, y: 20, width: 300, height: height)) proNameLbl.text = "This is your text" proNameLbl.font = UIFont.systemFont(ofSize: 17) proNameLbl.numberOfLines = 0 proNameLbl.lineBreakMode = .byWordWrapping infoView.addSubview(proNameLbl)
func getHeightforController(view: AnyObject) -> CGFloat { let tempView: UILabel = view as! UILabel var context: NSStringDrawingContext = NSStringDrawingContext() context.minimumScaleFactor = 0.8 var width: CGFloat = tempView.frame.size.width width = ((UIScreen.mainScreen().bounds.width)/320)*width let size: CGSize = tempView.text!.boundingRectWithSize(CGSizeMake(width, 2000), options:NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: [NSFontAttributeName: tempView.font], context: context).size as CGSize return size.height }
messageLabel.text = message messageLabel.lineBreakMode = .byWordWrapping messageLabel.numberOfLines = 0 messageLabel.textAlignment = .center messageLabel.textColor = UIColor.white messageLabel.font = messageLabel.font.withSize(12) messageLabel.sizeToFit()
let myLabel = UILabel(frame: CGRect(x: 0, y: 0, width: *somewidth*, height: *placeholder, e.g. 20*)) myLabel.numberOfLines = 0 myLabel.lineBreakMode = .byWordWrapping ...
var myLabelText: String = "" { didSet { myLabel.text = myLabelText myLabel.sizeToFit() } }
extension UILabel { func heightForLabel(text:String, font:UIFont, width:CGFloat) -> CGFloat { let label:UILabel = UILabel(frame: CGRect(x: 0, y: 0, width: width, height: CGFloat.greatestFiniteMagnitude)) label.numberOfLines = 0 label.lineBreakMode = NSLineBreakMode.byWordWrapping label.font = font label.text = text label.sizeToFit() return label.frame.height } }
@IBOutlet weak var myImageView: UIImageView! @IBOutlet weak var myLabel: UILabel!
import UIKit class SecondCustomTableViewCell: UITableViewCell { @IBOutlet weak var myLabel_1: UILabel! @IBOutlet weak var myLabel_2: UILabel! override func awakeFromNib() { super.awakeFromNib() } override func setSelected(selected: Bool, animated: Bool) { super.setSelected(selected, animated: animated) } }
import UIKit class ThirdCustomTableViewCell: UITableViewCell { @IBOutlet weak var dayPicker: UIDatePicker! override func awakeFromNib() { super.awakeFromNib() } override func setSelected(selected: Bool, animated: Bool) { super.setSelected(selected, animated: animated) } }
class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
import UIKit class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var tableView: UITableView! override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
import UIKit class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var tableView: UITableView! override func viewDidLoad() { super.viewDidLoad() } func numberOfSectionsInTableView(tableView: UITableView) -> Int { return 1 } func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return 3 } func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { if indexPath.row == 0 { let cell: UITableViewCell = UITableViewCell(style: UITableViewCellStyle.Default, reuseIdentifier: "firstCustomCell") return cell } else if indexPath.row == 1 { let cell: UITableViewCell = UITableViewCell(style: UITableViewCellStyle.Default, reuseIdentifier: "secondCustomCell") return cell } else { let cell: UITableViewCell = UITableViewCell(style: UITableViewCellStyle.Default, reuseIdentifier: "thirdCustomCell") return cell } } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
class FirstTableCell: UITableViewCell { } class SecondTableCell: UITableViewCell { } class ThirdTableCell: UITableViewCell { }
class YourViewController: UIViewController, UITableViewDataSource, UITableViewDelegate
override func viewDidLoad() { super.viewDidLoad() self.tableView.dataSource = self self.tableView.delegate = self }
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return 3 } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { if indexPath.row == 0 { let cell = tableView.dequeueReusableCell(withIdentifier: "firstTableCell") as! FirstTableCell return cell } else if indexPath.row == 1 { let cell = tableView.dequeueReusableCell(withIdentifier: "secondTableCell") as! SecondTableCell return cell } else { let cell = tableView.dequeueReusableCell(withIdentifier: "thirdTableCell") as! ThirdTableCell return cell } }
let viewControllerB = SubViewController() viewControllerB.passedData = diseases[indexPath.row].name navigationController?.pushViewController(viewControllerB, animated: true)
let storyBoard : UIStoryboard = UIStoryboard(name: "Main", bundle:nil) let nextViewController = storyBoard.instantiateViewController(withIdentifier: "SubViewStoryboardController") as! SubViewController nextViewController.passedData = diseases[indexPath.row].name self.present(nextViewController, animated:true, completion:nil)
func reduceToZero(x:Int) -> Int { while (x != 0) { x = x-1 } return x }
func reduceToZero(_ x: inout Int) { while (x != 0) { x = x-1 } } var a = 3 reduceToZero(&a) print(a)
func reduceToZero(var x:Int) -> Int { while (x != 0) { x = x-1 } return x }
func reduceToZero(x:Int) -> Int { var x = x while (x != 0) { x = x-1 } return x }
func foo(array: inout Array<Int>) { array.append(1) }
func reduceToZero(var x:Int) -> Int { while (x != 0) { x = x-1 } return x }
func reduceToZeroFP(x:Int) -> Int { while (x > 0) { return reduceToZeroFP(x: x-1) } return x }
class Person { var timer = NSTimer() func startTimer() { timer = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: Selector("timerTick"), userInfo: nil, repeats: true) } func timerTick() { angerLevel++ println("Angry! \(angerLevel)") } ... ... }
2014-06-25 13:57:14.956 ThisProgram[3842:148856] *** NSForwarding: warning: object 0x113760048 of class
dynamic func timerTick() { self.angerLevel++ print("Angry! \(self.angerLevel)") }
class Person: NSObject { var timer = NSTimer() var angerLevel = 0 func startTimer() { print("starting timer") timer = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: "timerTick", userInfo: nil, repeats: true) } func timerTick() { self.angerLevel++ print("Angry! \(self.angerLevel)") } override init() { super.init() self.startTimer() } }
class Person: NSObject, NSCoding { init() { super.init() } func encodeWithCoder(_aCoder: NSCoder) { } }
let array1 = ["a", "b", "c"] let array2 = ["a", "b", "d"] let set1:Set<String> = Set(array1) let set2:Set<String> = Set(array2)
firstSet.union(secondSet) firstSet.intersection(secondSet) firstSet.symmetricDifference(secondSet)
set1.union(array2) set1.intersect(array2) set1.subtract(array2) set1.exclusiveOr(array2)
set1.union(set2) set1.intersect(set2) set1.subtract(set2) set1.exclusiveOr(set2)
var list = ["hello", "world"] var slice: Array<String> = [] + list[0..list.count]
var list = ["hello", "world"] var slice: Array<String> = list[0..list.count]
var list = ["hello", "world"] var slice: Array<String> = Array(list[0..<list.count])
var arr = ["hello", "world", "goodbye"] let slice = arr[0..2] arr[0] = "bonjour" println(slice)
println(slice[1]) arr[1] = "le monde" println(slice[1])
arr.removeAtIndex(0) println(slice) arr[0] = "hola" println(slice)
[from..upToButNotIncluding] -> [from..<upToButNotIncluding]
var arr = ["hello", "world", "goodbye"] var arrCopy = arr let slice = arr[0..<2] arr[0] = "bonjour" arr arrCopy slice
class NameNumber { var name:String = "" var number:Int = 0 init (name:String, number:Int) { self.name = name self.number = number } } var number = 1 let names = ["Alan", "Bob", "Cory", "David"] let foo = names[0..<2].map { n in NameNumber(name:n, number:number++) } foo
import UIKit class ViewController: UIViewController,UIImagePickerControllerDelegate,UINavigationControllerDelegate{ @IBOutlet weak var pic: UIImageView! @IBOutlet weak var text: UILabel! var chosenImage : UIImage! override func viewDidLoad() { super.viewDidLoad() pic.isUserInteractionEnabled = true; } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [AnyHashable: Any]) { var chosenImage = info[UIImagePickerControllerEditedImage] self.pic!.image = chosenImage as! UIImage picker.dismiss(animated: true, completion: nil) } func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { picker.dismiss(animated: true, completion: nil) } @IBAction func tap(_ sender: Any) { self.text.text = "Kreason" let imagePicker = UIImagePickerController() imagePicker.delegate = self imagePicker.sourceType = UIImagePickerControllerSourceType.photoLibrary imagePicker.allowsEditing = false self.present(imagePicker, animated: true, completion: nil) } }
@objc func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { let chosenImage = info[UIImagePickerControllerOriginalImage] as! UIImage image = chosenImage self.performSegue(withIdentifier: "ShowEditView", sender: self) dismiss(animated: true, completion: nil) }
[PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) { switch (status) { case PHAuthorizationStatusAuthorized: NSLog(@"PHAuthorizationStatusAuthorized"); break; case PHAuthorizationStatusDenied: NSLog(@"PHAuthorizationStatusDenied"); break; case PHAuthorizationStatusNotDetermined: NSLog(@"PHAuthorizationStatusNotDetermined"); break; case PHAuthorizationStatusRestricted: NSLog(@"PHAuthorizationStatusRestricted"); break; } }];
func checkPermission() { let photoAuthorizationStatus = PHPhotoLibrary.authorizationStatus() switch photoAuthorizationStatus { case .authorized: print("Access is granted by user") case .notDetermined: PHPhotoLibrary.requestAuthorization({ (newStatus) in print("status is \(newStatus)") if newStatus == PHAuthorizationStatus.authorized { / do stuff here */ print("success") } }) case .restricted: / print("User do not have access to photo album.") case .denied: / print("User has denied the permission.") } }
private func imagePickerController( picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { }
@objc func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { }
class ViewController:UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate { .... }.
class ViewController:UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate { let imagePickerController = UIImagePickerController() override func viewDidLoad() { super.viewDidLoad() imagePickerController.delegate = self } ... }
func checkPermission() { let photoAuthorizationStatus = PHPhotoLibrary.authorizationStatus() switch photoAuthorizationStatus { case .authorized: print("Access is granted by user") case .notDetermined: PHPhotoLibrary.requestAuthorization({ (newStatus) in print("status is \(newStatus)") if newStatus == PHAuthorizationStatus.authorized { print("success") } }) print("It is not determined until now") case .restricted: print("User do not have access to photo album.") case .denied: print("User has denied the permission.") } }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) { if let pickedImage = info[UIImagePickerController.InfoKey.originalImage] as? UIImage { self.imgView.contentMode = .scaleAspectFit self.imgView.image = pickedImage } dismiss(animated: true, completion: nil) }
internal func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage { userPhoto.image = pickedImage } self.dismiss(animated: true, completion: nil) }
let picker = UIImagePickerController() picker.allowsEditing = true picker.sourceType = .photoLibrary picker.delegate = self self.present(picker, animated: true, completion: nil)
@objc func imagePickerController(_ picker: UIImagePickerController, didFinishPickingImage image: UIImage!, editingInfo: [NSObject : AnyObject]!) { ... }
func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) {}
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) {} Swift 4.2 update: func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]){}
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage addPhotoBtn.setImage(pickedImage, for: .normal) dismiss(animated: true, completion: nil) } func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { dismiss(animated: true, completion: nil) }
func authorizeToAlbum(completion:@escaping (Bool)->Void) { if PHPhotoLibrary.authorizationStatus() != .authorized { NSLog("Will request authorization") PHPhotoLibrary.requestAuthorization({ (status) in if status == .authorized { DispatchQueue.main.async(execute: { completion(true) }) } else { DispatchQueue.main.async(execute: { completion(false) }) } }) } else { DispatchQueue.main.async(execute: { completion(true) }) } }
self.authorizeToAlbum { (authorized) in if authorized == true { let picker = UIImagePickerController() picker.delegate = self picker.allowsEditing = false picker.sourceType = .photoLibrary self.present(picker, animated: true, completion: nil) } }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage { self.pickedImage = pickedImage if let finalImage = handleImage(originalImage: self.pickedImage!, maskImage: self.maskImage!) { self.imageView.image = finalImage } } dismiss(animated: true, completion: nil) }
if PHPhotoLibrary.authorizationStatus() != PHAuthorizationStatus.authorized { PHPhotoLibrary.requestAuthorization({ (status: PHAuthorizationStatus) in }) }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { picker.dismiss(animated: true) { if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage { let cropController:CropViewController = CropViewController(croppingStyle: .circular, image: pickedImage) cropController.delegate = self self.present(cropController, animated: true, completion: nil) } } }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any])
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { if isImagePickerAllowEditing { sourceImage = info[UIImagePickerControllerEditedImage] as? UIImage } else { sourceImage = info[UIImagePickerControllerOriginalImage] as? UIImage } .... }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { if let image = info[UIImagePickerControllerOriginalImage] as? UIImage { picker.dismiss(animated: false, completion: nil) DispatchQueue.main.asyncAfter(deadline: .now() + 1.0, execute: { self.discussionImage.image = image }) } }
@objc func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { print("Image picked") picker.dismiss(animated: true, completion: nil) dismiss(animated: true) { print("dismissed") self.delegate?.presentEditor(img: (info[UIImagePickerControllerOriginalImage] as? UIImage)!, id: self.id!) } }
@objc func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { print(" picker.dismiss(animated: true, completion: nil) let img = (info[UIImagePickerControllerOriginalImage] as? UIImage)! self.profileImage.image = img } }
@IBOutlet weak var myImageView: UIImageView! var imagePicker = UIImagePickerController() @IBAction func selectImage(_ sender: Any) { let myPickerController = UIImagePickerController() myPickerController.delegate = self; myPickerController.sourceType = UIImagePickerControllerSourceType.photoLibrary self.present(myPickerController, animated: true, completion: nil) } func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { print(info) var selectedImageFromPicker: UIImage? if let editedImage = info["UIImagePickerControllerEditedImage"] as? UIImage { selectedImageFromPicker = editedImage as! UIImage }else if let originalImage = info["UIImagePickerControllerOriginalImage"] as? UIImage{ selectedImageFromPicker = originalImage as! UIImage } dismiss(animated: true, completion: nil) if var selectedImage = selectedImageFromPicker { myImageView.image = selectedImage } } func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { picker.dismiss(animated: true, completion: nil) }
let imagePicker = UIImagePickerController() @IBOutlet weak var userImage: UIImageView! override func viewDidLoad() { super.viewDidLoad() imagePicker.delegate = self let tap = UITapGestureRecognizer(target: self, action: userImage.addGestureRecognizer(tap) userImage.isUserInteractionEnabled = true } @objc func click() { imagePicker.allowsEditing = false imagePicker.sourceType = .photoLibrary present(imagePicker, animated: true, completion: nil) } @objc func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { if let chosenImage = info[UIImagePickerControllerOriginalImage] as? UIImage{ userImage.contentMode = .scaleAspectFit userImage.image = chosenImage } dismiss(animated: true, completion: nil) } func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { dismiss(animated: true, completion: nil) }
var aofa = [[1,2,3],[4],[5,6,7,8,9]] aofa.flatten()
var flattened = aofa.reduce(Int[]()){ a,i in var b : Int[] = a b.extend(i) return b }
let numbers = [[1,2,3],[4],[5,6,7,8,9]] let reduced = numbers.reduce([], +)
let numbers = [[1,2,3],[4],[5,6,7,8,9]] let flattened = numbers.flatMap { $0 }
let numbers = [[1,2,3],[4],[5,6,7,8,9]] let joined = Array(numbers.joined())
let numbers = [[1,2,3],[4],[5,6,7,8,9]] let flattened = Array(numbers.joined())
array.compactMap({$0}) [1, 2, [[3, 4], [5, 6, [7]]], 8]
func flattenedArray(array:[Any]) -> [Int] { var myArray = [Int]() for element in array { if let element = element as? Int { myArray.append(element) } if let element = element as? [Any] { let result = flattenedArray(array: element) for i in result { myArray.append(i) } } } return myArray }
let numbers = [[1, 2, 3], [4, 5, 6]] let flattenNumbers = numbers.reduce([], combine: +)
let numbers = [[1,2,3],[4],[5,6,7,8,9]] let reduced = reduce(numbers,[],+)
func reduce<S : SequenceType, U>(sequence: S, initial: U, combine: (U, S.Generator.Element) -> U) -> U
var aofa = [[1,2,3],[4],[5,6,7,8,9]] aofa.flatMap { $0 }
func convert(){ let arr = [[1,2,3],[4],[5,6,7,8,9]] print("Old Arr = ",arr) var newArr = [Int]() for i in arr{ for j in i{ newArr.append(j) } } print("New Arr = ",newArr) }
lazy var managedObjectContext: NSManagedObjectContext? = { let coordinator = self.persistentStoreCoordinator if coordinator == nil { return nil } var managedObjectContext = NSManagedObjectContext(concurrencyType: NSManagedObjectContextConcurrencyType.MainQueueConcurrencyType) managedObjectContext.persistentStoreCoordinator = coordinator return managedObjectContext }()
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), { () -> Void in var context = NSManagedObjectContext(concurrencyType: NSManagedObjectContextConcurrencyType.PrivateQueueConcurrencyType) context.parentContext = self.managedObjectContext! ...rest of core data saving code here... })
var newShow = NSEntityDescription.insertNewObjectForEntityForName("Show", inManagedObjectContext: context) as Show
import UIKit import CoreData class Family: NSManagedObject { @NSManaged var member : AnyObject }
let myEntity = NSEntityDescription.entityForName("Fruit", inManagedObjectContext: managedContext) let fruit = NSManagedObject(entity: myEntity!, insertIntoManagedObjectContext:managedContext) as! Food.Fruit
convenience init(<properties to init>) { let entityDescr = NSEntityDescription.entityForName("<entity class name>", inManagedObjectContext: <managed context>) self.init(entity: entityDescr!, insertIntoManagedObjectContext: <managed context>)}
@IBOutlet var wage: UITextField @IBOutlet var hour: UITextField
var wageConversion:Int = 0 wageConversion = wage.text.toInt()!
var WageConversion = (Wage.text as NSString).floatValue
extension String { var floatValue: Float { return (self as NSString).floatValue } }
let numberFormatter = NSNumberFormatter() numberFormatter.numberStyle = NSNumberFormatterStyle.DecimalStyle let number = numberFormatter.numberFromString(self.stringByTrimmingCharactersInSet(Wage.text))
let numberFormatter = NSNumberFormatter() let number = numberFormatter.numberFromString("15.5") let numberFloatValue = number.floatValue println("number is \(numberFloatValue)")
wageConversion = NSNumberFormatter().numberFromString(wage.text!)!.floatValue
var wageValue: Float { get { return NSNumberFormatter().numberFromString(wage.text!)!.floatValue } set { wage.text = "\(newValue)" } }
var WageConversion = (Wage.text as NSString).doubleValue
import Foundation "-23.67".floatValue let s = "-23.67" as NSString s.floatValue
var wageFloat:Float = 0.0 if let wageText = wage.text { if let wageNumber = NumberFormatter().number(from: wageText) { wageFloat = wageNumber.floatValue } }
extension String { func floatValue() -> Float? { if let floatval = Float(self) { return floatval } return nil } }
var string_1 : String = "100" var double_1 : Double = (string_1 as NSString).doubleValue + 99.0 var string_2 : NSString = "100" var number_2 : Double = string_2.doubleValue;
if let wageInt = Wage.text?.toInt() { var wageConversionDouble = Double(wageInt) }
if let wageText = Wage.text { var wageFloat = Double(wageText.toInt()!) }
extension String { func toDouble() -> Double? { var comps = self.componentsSeparatedByString(".") if comps.count == 0 { return nil } else if comps.count > 2 { return nil } else if comps[0] == "" || comps[1] == "" { return nil } var whole = 0.0 if let w = comps[0].toInt() { whole = Double(w) } else { return nil } if comps.count == 1 { return whole } var fractional = 0.0 if let f = comps[1].toInt() { var toThePower = Double(countElements(comps[1])) fractional = Double(f) / pow(10.0, toThePower) } else { return nil } return whole + fractional } func toFloat() -> Float? { if let val = self.toDouble() { return Float(val) } else { return nil } } } var str = "78.001" if let val = str.toFloat() { println("Str in float: \(val)") } else { println("Unable to convert Str to float") } if let val = str.toDouble() { println("Str in double: \(val)") } else { println("Unable to convert Str to double") }
extension UITextField { func floatValue(locale : Locale = Locale.current) -> Float { let numberFormatter = NumberFormatter() numberFormatter.numberStyle = .decimal numberFormatter.locale = locale let nsNumber = numberFormatter.number(from: text!) return nsNumber == nil ? 0.0 : nsNumber!.floatValue } }
var tempString:String? var myFloat:Float? @IBAction func ButtonWasClicked(_ sender: Any) { tempString = myUITextField.text myFloat = Float(tempString!)! }
let a:Double = firstText.text.bridgeToObjectiveC().doubleValue let b:Double = secondText.text.bridgeToObjectiveC().doubleValue if (a != 0.0) && (b != 0.0) { var ans = a + b answerLabel.text = "Answer is \(ans)" } else { answerLabel.text = "Input values are not numberic" }
let a:Int? = firstText.text.toInt() let b:Int? = secondText.text.toInt() if a && b { var ans = a! + b! answerLabel.text = "Answer is \(ans)" } else { answerLabel.text = "Input values are not numberic" }
@IBOutlet private var annotationOptionsView: UIView! @IBOutlet private var arrivingLeavingSwitch: UISegmentedControl!
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) { if (segue.identifier == "identifier") { let controller = segue.destinationViewController as! YourController let _ = controller.view controller.your_IBOutlet_property = xxx ... controller.delegate = self } }
class XYZViewController: UINavigationController { }
@IBOutlet private var containerView: UIView! override open func loadView() { containerView.addSubview(anotherView) }
@IBOutlet private var containerView: UIView! override open func loadView() { super.loadView() containerView.addSubview(anotherView) }
let initialVC = self.storyboard?.instantiateViewController(withIdentifier: "InitialVC") as! InitialVC
let newVC = MYCustomViewController(nibName: "MYCustomViewController", bundle: .main)
let bundle = Bundle(for: type(of: controller)) bundle.loadNibNamed("CustomViewControllerView", owner: controller, options: nil)
controller.labelOutlet.text = "title" controller.imageOutlet.image = UIImage(named: "image1")
let passwordSecureTextField = app.secureTextFields["password"] passwordSecureTextField.tap() passwordSecureTextField.typeText("wrong_password")
defaults write com.apple.iphonesimulator ConnectHardwareKeyboard 0
extension XCTestCase { func tapElementAndWaitForKeyboardToAppear(element: XCUIElement) { let keyboard = XCUIApplication().keyboards.element while (true) { element.tap() if keyboard.exists { break; } NSRunLoop.currentRunLoop().runUntilDate(NSDate(timeIntervalSinceNow: 0.5)) } } }
UIPasteboard.generalPasteboard().string = "Their password" let passwordSecureTextField = app.secureTextFields["password"] passwordSecureTextField.pressForDuration(1.1) app.menuItems["Paste"].tap()
func pasteTextFieldText(app:XCUIApplication, element:XCUIElement, value:String, clearText:Bool) { UIPasteboard.generalPasteboard().string = value element.tap() if clearText { element.buttons["Clear text"].tap() } element.doubleTap() app.menuItems["Paste"].tap() }
[app.textFields[@"theTitle"] tap]; [app.textFields[@"theTitle"] typeText:@"kk"];
app.otherElements["My Identifier"].tap() app.otherElements["My Identifier"].typeText("sample text")
let enterPasswordSecureTextField = app.secureTextFields["Enter Password"] enterPasswordSecureTextField.tap() enterPasswordSecureTextField.typeText("12345678")
func == (lhs: Cookie, rhs: Cookie) -> Bool { return lhs.column == rhs.column && lhs.row == rhs.row }
Consecutive declarations on a line must be separated by Expected declaration operators are only allowed at global scope
class Cookie: Printable, Hashable { var column: Int var row: Int let cookieType: CookieType let sprite: SKSpriteNode? init(column: Int, row: Int, cookieType: CookieType) { self.column = column self.row = row self.cookieType = cookieType } var description: String { return "type:\(cookieType) square:(\(column),\(row))" } var hashValue: Int { return row * 10 + column } func ==(lhs: Cookie, rhs: Cookie) -> Bool { return lhs.column == rhs.column && lhs.row == rhs.row } }
func == (lhs: Cookie, rhs: Cookie) -> Bool { return lhs.column == rhs.column && lhs.row == rhs.row }
class Cookie:NSObject{ var column: Int var row: Int override func isEqual(object: AnyObject?) -> Bool { guard let rhs = object as? Cookie else { return false } let lhs = self return lhs.column == rhs.column } }
override func isEqual(_ object: AnyObject?) -> Bool { guard let rhs = object as? Cookie else { return false } let lhs = self return lhs.column == rhs.column }
var optionalString: String? let dict = NSDictionary()
optionalString = dict.objectForKey("SomeKey") as? String
optionalString = dict.objectForKey("SomeKey") as! String?
if let string = dict["SomeKey"] as? String { print(string) }
import UIKit let str_value: Any = String("abc")! let strOpt_value: Any? = String("abc")! let strOpt_nil: Any? = (nil as String?) let int_value: Any = Int(1) let intOpt_value: Any? = Int(1) let intOpt_nil: Any? = (nil as Int?) str_value as? String strOpt_value as? String strOpt_nil as? String int_value as? String intOpt_value as? String intOpt_nil as? String str_value as! String strOpt_value as! String strOpt_value as? String? strOpt_nil as? String? intOpt_value as? String? intOpt_nil as? String? strOpt_value as! String? strOpt_nil as! String? intOpt_nil as! String? if let _ = str_value as? String { true } if let _ = strOpt_value as? String { true } if let _ = strOpt_nil as? String { true } if let _ = int_value as? String { true } if let _ = intOpt_value as? String { true } if let _ = intOpt_nil as? String { true } if let _ = strOpt_value as? String? { true } if let _ = strOpt_nil as? String? { true } if let _ = intOpt_value as? String? { true } if let _ = intOpt_nil as? String? { true } if let _ = strOpt_value as! String? { true } if let _ = strOpt_nil as! String? { true } if let _ = intOpt_nil as! String? { true }
import UIKit let str: AnyObject = String("abc") let strOpt: AnyObject? = String("abc") let strNil: AnyObject? = (nil as String?) let int: AnyObject = Int(1) let intOpt: AnyObject? = Int(1) let intNil: AnyObject? = (nil as Int?) str as? String strOpt as? String strNil as? String int as? String intOpt as? String intNil as? String str as! String? strOpt as! String? strNil as! String? int as! String? intOpt as! String? intNil as! String?
let cell = tableView.dequeueReusableCellWithIdentifier("Cell") as? UITableViewCell
if let cell = tableView.dequeueReusableCellWithIdentifier("Cell") as? UITableViewCell { } else { }
let cell = tableView.dequeueReusableCellWithIdentifier("Cell") as! UITableViewCell.
let rawString: AnyObject = "I love swift" let optionalString: AnyObject? = "we love swift" let nilString: AnyObject? = (nil as String?) let rawInt: AnyObject = Int(3) let optionalInt: AnyObject? = Int(3) let nilInt: AnyObject? = (nil as Int?)
var navigationController: UINavigationController? { get }
controller.navigationController!.pushViewController(myViewController, animated: true)
controller.navigationController?.pushViewController(myViewController, animated: true)
var dict = [Int:Any]() dict[1] = 15 let x = dict[1] as? String print(x) dict[2] = "Yo" let z = dict[2] as! String? print(z) let zz = dict[1] as! String let m = dict[3] as! String? print(m)
class Optional { var lName:AnyObject! = "1" var lastName:String! } let obj = Optional() print(obj.lName) print(obj.lName!) obj.lastName = obj.lName as? String print(obj.lastName)
class Jedi { var lightSaberColor = "Blue" } class Sith: Jedi { override var lightSaberColor = "Red" }
class Jedi { let lightSaberColor = "Blue" } class Sith: Jedi { override var lightSaberColor : String{return "Red"} }
class Jedi { let lightSaberColor : String init(_ lsc : String = "Blue") { lightSaberColor = lsc; } } class Sith : Jedi { init() { super.init("Red") } } let j1 = Jedi() let j2 = Sith() println(j1.lightSaberColor) println(j2.lightSaberColor)
class Jedi { let lightsaberColor = "Blue" } class Sith: Jedi { override var lightsaberColor : String { return "Red" } }
class Jedi { var lightsaberColor = "Blue" } class Sith: Jedi { override var lightsaberColor : String { get { return "Red" } set { } } }
class Jedi { var lightSaberColor = "Blue" } class Sith: Jedi { override init() { super.init() self.lightSaberColor = "Red" } }
class SomeClass { var hello = "hello" } class ChildClass: SomeClass { override var hello: String { set { super.hello = newValue } get { return super.hello } } }
class Jedi { private(set) var lightsaberColor = "Blue" } class Sith: Jedi { override var lightsaberColor : String { get { return "Red" } } }
override func viewDidLoad() { super.viewDidLoad() if shouldDoSmth() { } } public func shouldDoSmth() -> Bool { return true }
public func shouldDoSmth() -> Bool { return false }
[playButton setImage:[UIImage imageNamed:@"play.png"] forState:UIControlStateNormal];
let playButton = UIButton(type: .Custom) if let image = UIImage(named: "play.png") { playButton.setImage(image, forState: .Normal) }
playButton.setImage(UIImage(named: "play.png"), forState: UIControlState.Normal)
let playButton = UIButton(type: .custom) playButton.setImage(UIImage(named: "play.png"), for: .normal)
btn_refresh.setImage(UIImage(named: "xxx.png"), forState: UIControlState.Normal) btn_refresh.setImage(UIImage(named: "yyy.png"), forState: UIControlState.Highlighted) btn_refresh.setImage(UIImage(named: "zzzz.png"), forState: UIControlState.Selected)
@IBAction func button_refresh_touchup_inside(sender: UIButton) { sender.setImage(UIImage(named: "newimage.png"), forState: UIControlState.Normal) youranotherbuttonName.setImage(UIImage(named: "newimage.png"), forState: UIControlState.Normal) }
let buttonDone = UIButton(type: .Custom) if let image = UIImage(named: "Done") { self.buttonDone.setImage(image, for: .normal) }
override func viewDidLoad { ... playButton = UIButton(type: .Custom) imagePlay = UIImage(named:"play.png") playButton.setImage(imagePlay, forState: .Normal) }
var bRec:Bool = true @IBOutlet weak var btnRec: UIButton! @IBAction func btnRec(_ sender: Any) { bRec = !bRec if bRec { btnRec.setImage(UIImage(named: "MicOn.png"), for: .normal) } else { btnRec.setImage(UIImage(named: "MicOff.png"), for: .normal) } }
class ViewController: UIViewController { @IBOutlet var btnImage: UIButton! var flag = false override func viewDidLoad() { super.viewDidLoad() setButtonImage() } @IBAction func btnClick(_ sender: Any) { flag = !flag setButtonImage() } func setButtonImage(){ let imgName = flag ? "share" : "image" let image1 = UIImage(named: "\(imgName).png")! self.btnImage.setImage(image1, for: .normal) } }
@IBOutlet weak var selectionButton: UIButton! selectionButton.setImage(UIImage.addBlueIcon, for: .selected)
let imageName = "yourImage.png" yourview.backgroundColor = UIColor.colorWithPatternImage(UIImage(named:imageName))
let imageName = "yourImage.png" let image = UIImage(named: imageName) let imageView = UIImageView(image: image!)
imageView.frame = CGRect(x: 0, y: 0, width: 100, height: 200) view.addSubview(imageView)
var imageView : UIImageView imageView = UIImageView(frame:CGRectMake(10, 50, 100, 300)); imageView.image = UIImage(named:"image.jpg") self.view.addSubview(imageView)
Class ViewController: UIViewController { let someImageView: UIImageView = { let theImageView = UIImageView() theImageView.image = UIImage(named: "yourImage.png") theImageView.translatesAutoresizingMaskIntoConstraints = false return theImageView }() override func viewDidLoad() { super.viewDidLoad() view.addSubview(someImageView) someImageViewConstraints() } func someImageViewConstraints() { someImageView.widthAnchor.constraint(equalToConstant: 180).isActive = true someImageView.heightAnchor.constraint(equalToConstant: 180).isActive = true someImageView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true someImageView.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 28).isActive = true } }
let imageView = UIImageView(image: UIImage(named: "yourImage.png")!)
var imageView : UIImageView imageView = UIImageView(frame:CGRect(x:10, y:50, width:100, height:300)); imageView.image = UIImage(named:"Test.jpeg") self.view.addSubview(imageView)
let someImageView: UIImageView = { let theImageView = UIImageView() theImageView.image = UIImage(named: "yourImage.png") theImageView.translatesAutoresizingMaskIntoConstraints = false return theImageView }()
func getChatMessage(){ SocketIOManager.sharedInstance.getChatMessage { (messageInfo) -> Void in dispatch_async(dispatch_get_main_queue(), { () -> Void in }) } }
NSNotificationCenter.defaultCenter().addObserver(self, selector:
func showSpinningWheel(notification: NSNotification) { }
NSNotificationCenter.defaultCenter().postNotificationName(hideSpinner, object: self)
let imageDataDict:[String: UIImage] = ["image": image] NSNotificationCenter.defaultCenter().postNotificationName(notificationName, object: nil, userInfo: imageDataDict) NSNotificationCenter.defaultCenter().addObserver(self, selector: func showSpinningWheel(notification: NSNotification) { if let image = notification.userInfo?["image"] as? UIImage { } }
let imageDataDict:[String: UIImage] = ["image": image] NotificationCenter.default.post(name: NSNotification.Name(rawValue: "notificationName"), object: nil, userInfo: imageDataDict) NotificationCenter.default.addObserver(self, selector: func showSpinningWheel(_ notification: NSNotification) { if let image = notification.userInfo?["image"] as? UIImage { } }
extension Notification.Name { static let myNotification = Notification.Name("myNotification") } NotificationCenter.default.post(name: .myNotification, object: nil)
let imageDataDict:[String: UIImage] = ["image": image] NotificationCenter.default.post(name: NSNotification.Name(rawValue: "notificationName"), object: nil, userInfo: imageDataDict) NotificationCenter.default.addObserver(self, selector: func showSpinningWheel(_ notification: NSNotification) { print(notification.userInfo ?? "") if let dict = notification.userInfo as NSDictionary? { if let id = dict["image"] as? UIImage{ } } }
let imageDataDict:[String: UIImage] = ["image": image] NotificationCenter.default.post(name: NSNotification.Name(rawValue: "notificationName"), object: nil, userInfo: imageDataDict) NotificationCenter.default.addObserver(self, selector: func showSpinningWheel(_ notification: NSNotification) { print(notification.userInfo ?? "") if let dict = notification.userInfo as NSDictionary? { if let id = dict["image"] as? UIImage{ } } }
let imageDataDict:[String: UIImage] = ["image": image] NotificationCenter.default.post(name: NSNotification.Name(rawValue: "notificationName"), object: nil, userInfo: imageDataDict) NotificationCenter.default.addObserver(self, selector: @objc func showSpinningWheel(_ notification: NSNotification) { print(notification.userInfo ?? "") if let dict = notification.userInfo as NSDictionary? { if let id = dict["image"] as? UIImage{ } } }
var secondsFromGMT: Int { return TimeZone.current.secondsFromGMT() } secondsFromGMT
var localTimeZoneAbbreviation: String { return TimeZone.current.abbreviation() ?? "" } localTimeZoneAbbreviation
var localTimeZoneName: String { return TimeZone.current.identifier } localTimeZoneName
var timeZoneAbbreviations: [String:String] { return TimeZone.abbreviationDictionary } timeZoneAbbreviations
var timeZoneIdentifiers: [String] { return TimeZone.knownTimeZoneIdentifiers } timeZoneIdentifiers
var isDaylightSavingTime: Bool { return TimeZone.current.isDaylightSavingTime(for: Date()) } print(isDaylightSavingTime) var daylightSavingTimeOffset: TimeInterval { return TimeZone.current.daylightSavingTimeOffset() } print(daylightSavingTimeOffset) var nextDaylightSavingTimeTransition: Date? { return TimeZone.current.nextDaylightSavingTimeTransition } print(nextDaylightSavingTimeTransition?.description(with: .current) ?? "none") nextDaylightSavingTimeTransition var nextDaylightSavingTimeTransitionAfterNext: Date? { guard let nextDaylightSavingTimeTransition = nextDaylightSavingTimeTransition else { return nil } return TimeZone.current.nextDaylightSavingTimeTransition(after: nextDaylightSavingTimeTransition) } nextDaylightSavingTimeTransitionAfterNext
Locale.availableIdentifiers Locale.isoRegionCodes Locale.isoCurrencyCodes Locale.isoLanguageCodes Locale.commonISOCurrencyCodes Locale.current.regionCode Locale.current.languageCode Locale.current.currencyCode Locale.current.currencySymbol Locale.current.groupingSeparator Locale.current.decimalSeparator Locale.current.usesMetricSystem Locale.windowsLocaleCode(fromIdentifier: "pt_BR") Locale.identifier(fromWindowsLocaleCode: 1046) ?? "" Locale.windowsLocaleCode(fromIdentifier: Locale.current.identifier) Locale.windowsLocaleCode(fromIdentifier: "en_US") Locale.identifier(fromWindowsLocaleCode: 1033) ?? "" Locale(identifier: "en_US_POSIX").localizedString(forLanguageCode: "pt") Locale(identifier: "en_US_POSIX").localizedString(forRegionCode: "br") Locale(identifier: "en_US_POSIX").localizedString(forIdentifier: "pt_BR") TimeZone.current.localizedName(for: .standard, locale: .current) ?? "" TimeZone.current.localizedName(for: .shortStandard, locale: .current) ?? "" TimeZone.current.localizedName(for: .daylightSaving, locale: .current) ?? "" TimeZone.current.localizedName(for: .shortDaylightSaving, locale: .current) ?? "" TimeZone.current.localizedName(for: .generic, locale: .current) ?? "" TimeZone.current.localizedName(for: .shortGeneric, locale: .current) ?? "" var timeZone: String { return TimeZone.current.localizedName(for: TimeZone.current.isDaylightSavingTime() ? .daylightSaving : .standard, locale: .current) ?? "" } timeZone
func getCurrentTimeZone() -> String{ return String (TimeZone.current.identifier) } let currentTimeZone = getCurrentTimeZone() print(currentTimeZone)
NSTimeZone *timeZone = [NSTimeZone localTimeZone]; NSString *tzName = [timeZone name];
<Error>: CGContextSaveGState: invalid context 0x0. If you want to see the backtrace, please set CG_CONTEXT_SHOW_BACKTRACE environmental variable.
Aug 7 14:27:00 <Error>: CGContextSaveGState: invalid context 0x0. Backtrace: <-[UIStatusBarItemView updateContentsAndWidth]+33> <-[UIStatusBarItemView initWithItem:data:actions:style:]+477> <+[UIStatusBarItemView createViewForItem:withData:actions:foregroundStyle:]+134> <-[UIStatusBarLayoutManager _createViewForItem:withData:actions:]+163> <-[UIStatusBarLayoutManager _prepareEnabledItemType:withEnabledItems:withData:actions:itemAppearing:itemDisappearing:]+36 <-[UIStatusBarLayoutManager prepareEnabledItems:withData:actions:]+92> <-[UIStatusBarForegroundView _setStatusBarData:actions:animated:]+797> <-[UIStatusBarForegroundView setStatusBarData:actions:animated:]+332> <__51-[UIStatusBar _prepareToSetStyle:animation:forced:]_block_invoke+360> <+[UIView(Animation) performWithoutAnimation:]+65> <-[UIStatusBar _prepareToSetStyle:animation:forced:]+866> <-[UIStatusBar _requestStyleAttributes:animationParameters:forced:]+391> <-[UIStatusBar requestStyle:animationParameters:forced:]+437> <-[UIStatusBar requestStyle:animated:forced:]+90> <-[UIStatusBar _evaluateServerRegistration]+250> <__45-[UIView(Hierarchy) _postMovedFromSuperview:]_block_invoke+590> <-[UIView(Hierarchy) _postMovedFromSuperview:]+544> <-[UIView(Internal) _addSubview:positioned:relativeTo:]+1967> <-[UIStatusBarWindow setStatusBar:]+288> <-[UIApplication _createStatusBarWithRequestedStyle:orientation:hidden:]+340> <-[UIApplication _runWithMainScene:transitionContext:completion:]+950> <-[UIApplication workspaceDidEndTransaction:]+188> <-[FBSSerialQueue _performNext]+192> <-[FBSSerialQueue _performNextFromRunLoopSource]+45> <__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__+17> <__CFRunLoopDoSources0+556> <__CFRunLoopRun+867> <CFRunLoopRunSpecific+488> <-[UIApplication _run]+402> <UIApplicationMain+171> <main+117> Aug 7 14:27:00 <Error>: CGContextTranslateCTM: invalid context 0x0. Backtrace: <-[UIStatusBarItemView updateContentsAndWidth]+33> <-[UIStatusBarItemView initWithItem:data:actions:style:]+477> <+[UIStatusBarItemView createViewForItem:withData:actions:foregroundStyle:]+134> <-[UIStatusBarLayoutManager _createViewForItem:withData:actions:]+163> <-[UIStatusBarLayoutManager _prepareEnabledItemType:withEnabledItems:withData:actions:itemAppearing:itemDisappearing:]+36 <-[UIStatusBarLayoutManager prepareEnabledItems:withData:actions:]+92> <-[UIStatusBarForegroundView _setStatusBarData:actions:animated:]+797> <-[UIStatusBarForegroundView setStatusBarData:actions:animated:]+332> <__51-[UIStatusBar _prepareToSetStyle:animation:forced:]_block_invoke+360> <+[UIView(Animation) performWithoutAnimation:]+65> <-[UIStatusBar _prepareToSetStyle:animation:forced:]+866> <-[UIStatusBar _requestStyleAttributes:animationParameters:forced:]+391> <-[UIStatusBar requestStyle:animationParameters:forced:]+437> <-[UIStatusBar requestStyle:animated:forced:]+90> <-[UIStatusBar _evaluateServerRegistration]+250> <__45-[UIView(Hierarchy) _postMovedFromSuperview:]_block_invoke+590> <-[UIView(Hierarchy) _postMovedFromSuperview:]+544> <-[UIView(Internal) _addSubview:positioned:relativeTo:]+1967> <-[UIStatusBarWindow setStatusBar:]+288> <-[UIApplication _createStatusBarWithRequestedStyle:orientation:hidden:]+340> <-[UIApplication _runWithMainScene:transitionContext:completion:]+950> <-[UIApplication workspaceDidEndTransaction:]+188> <-[FBSSerialQueue _performNext]+192> <-[FBSSerialQueue _performNextFromRunLoopSource]+45> <__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__+17> <__CFRunLoopDoSources0+556> <__CFRunLoopRun+867> <CFRunLoopRunSpecific+488> <-[UIApplication _run]+402> <UIApplicationMain+171> <main+117> Aug 7 14:27:00 <Error>: CGContextRestoreGState: invalid context 0x0. Backtrace: <-[UIStatusBarItemView updateContentsAndWidth]+33> <-[UIStatusBarItemView initWithItem:data:actions:style:]+477> <+[UIStatusBarItemView createViewForItem:withData:actions:foregroundStyle:]+134> <-[UIStatusBarLayoutManager _createViewForItem:withData:actions:]+163> <-[UIStatusBarLayoutManager _prepareEnabledItemType:withEnabledItems:withData:actions:itemAppearing:itemDisappearing:]+36 <-[UIStatusBarLayoutManager prepareEnabledItems:withData:actions:]+92> <-[UIStatusBarForegroundView _setStatusBarData:actions:animated:]+797> <-[UIStatusBarForegroundView setStatusBarData:actions:animated:]+332> <__51-[UIStatusBar _prepareToSetStyle:animation:forced:]_block_invoke+360> <+[UIView(Animation) performWithoutAnimation:]+65> <-[UIStatusBar _prepareToSetStyle:animation:forced:]+866> <-[UIStatusBar _requestStyleAttributes:animationParameters:forced:]+391> <-[UIStatusBar requestStyle:animationParameters:forced:]+437> <-[UIStatusBar requestStyle:animated:forced:]+90> <-[UIStatusBar _evaluateServerRegistration]+250> <__45-[UIView(Hierarchy) _postMovedFromSuperview:]_block_invoke+590> <-[UIView(Hierarchy) _postMovedFromSuperview:]+544> <-[UIView(Internal) _addSubview:positioned:relativeTo:]+1967> <-[UIStatusBarWindow setStatusBar:]+288> <-[UIApplication _createStatusBarWithRequestedStyle:orientation:hidden:]+340> <-[UIApplication _runWithMainScene:transitionContext:completion:]+950> <-[UIApplication workspaceDidEndTransaction:]+188> <-[FBSSerialQueue _performNext]+192> <-[FBSSerialQueue _performNextFromRunLoopSource]+45> <__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__+17> <__CFRunLoopDoSources0+556> <__CFRunLoopRun+867> <CFRunLoopRunSpecific+488> <-[UIApplication _run]+402> <UIApplicationMain+171> <main+117>
public func print<Target>(_ items: Any..., separator: String = default, terminator: String = default, to output: inout Target) where Target : TextOutputStream
print("Swift is awesome.") print("Swift", "is", "awesome", separator:" ") print("Swift", "is", "awesome", separator:" ", terminator:".")
Swift is awesome. Swift is awesome Swift is awesome.
print("This is wild", terminator: " ") print("world")
struct Address { let city: String } class Person { let name = "Jack" let addresses = [ Address(city: "Helsinki"), Address(city: "Tampere") ] } extension Person: CustomStringConvertible { var description: String { let objectAddress = unsafeBitCast(self, to: Int.self) return String(format: "<name: \(name) %p>", objectAddress) } } let jack = Person() print(jack)
extension Person: CustomDebugStringConvertible { var debugDescription: String { let objectAddress = unsafeBitCast(self, to: Int.self) let addressString = addresses.map { $0.city }.joined(separator: ",") return String(format: "<name: \(name), addresses: \(addressString) %p>",objectAddress) } }
<name: Jack, addresses: Helsinki,Tampere 0x60c000044860>
struct MyStreamer: TextOutputStream { lazy var fileHandle: FileHandle? = { let fileHandle = FileHandle(forWritingAtPath: self.logPath) return fileHandle }() var logPath: String = "My file path" mutating func write(_ string: String) { fileHandle?.seekToEndOfFile() fileHandle?.write(string.data(using:.utf8)!) } }
print("First of all", to: &myStream ) print("Then after", to: &myStream) print("And, finally", to: &myStream)
extension Person: CustomReflectable { var customMirror: Mirror { return Mirror(self, children: ["name": name, "address1": addresses[0], "address2": addresses[1]]) } }
‚ñø <name: Jack, addresses: Tampere Helsinki 0x7feb82f26e80> - name : "Jack" ‚ñø address1 : Address - city : "Helsinki" ‚ñø address2 : Address - city : "Tampere"
print("Hello World", terminator:"") result "Hello World"
print("Hello", "World", separator:" ") result "Hello World\n"
print("Hello", "World", separator:" ", terminator:"") result "Hello World"
var helloworld = "Hello World" print(helloworld) result "Hello World\n"
var hello = "Hello" var world = "World" print (hello, world) result "Hello World\n"
for i in 1...4 { print("", i, separator: " ", terminator:"") } print()
self.presentingViewController.providesPresentationContextTransitionStyle = YES; self.presentingViewController.definesPresentationContext = YES; modal.modalPresentationStyle = UIModalPresentationOverCurrentContext;
func showModal() { let modalViewController = ModalViewController() modalViewController.modalPresentationStyle = .overCurrentContext presentViewController(modalViewController, animated: true, completion: nil) }
class ModalViewController: UIViewController { override func viewDidLoad() { view.backgroundColor = UIColor.clearColor() view.opaque = false } }
override init() { super.init() println("Default init") } override init(frame: CGRect) { super.init(frame: frame) println("Frame init") } required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) println("Coder init") }
class MyView: UIView { override init(frame: CGRect) { super.init(frame: frame) addBehavior() } convenience init() { self.init(frame: CGRect.zero) } required init(coder aDecoder: NSCoder) { fatalError("This class does not support NSCoding") } func addBehavior() { print("Add all the behavior here") } } let u = MyView(frame: CGRect.zero) let v = MyView()
override init (frame : CGRect) { super.init(frame : frame) } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) }
class BaseView: UIView { init() { super.init(frame: CGRect.zero) } @available(*, unavailable) required init?(coder aDecoder: NSCoder) { fatalError("NSCoding not supported") } }
class CustomView: BaseView { let textField = UITextField() override init() { super.init() textField.placeholder = "placeholder text" textField.font = UIFont.systemFont(ofSize: 12) addSubview(textField) } override func layoutSubviews() { super.layoutSubviews() textField.frame.size = CGSize(width: frame.width - 20, height: 30) textField.frame.origin = CGPoint(x: 10, y: 10) } }
required init?(coder aDecoder: NSCoder) { fatalError("NSCoding not supported") }
class CustomView: UIView { override init (frame: CGRect) { super.init(frame: frame) initCommon() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) initCommon() } func initCommon() { } }
class RedView: UIView { override init (frame: CGRect) { super.init(frame: frame) setup() } required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder)! setup() } func setup () { backgroundColor = .red } }
import UIKit class CustomCalloutView: UIView { @IBOutlet var viewCallout: UIView! @IBOutlet weak var btnCall: UIButton! @IBOutlet weak var btnDirection: UIButton! @IBOutlet weak var btnFavourite: UIButton! override init(frame: CGRect) { super.init(frame: frame) nibSetup() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) nibSetup() } func nibSetup() { Bundle.main.loadNibNamed(String(describing: CustomCalloutView.self), owner: self, options: nil) guard let contentView = viewCallout else { return } contentView.frame = self.bounds self.addSubview(contentView) } }
let viewCustom = CustomCalloutView.init(frame: CGRect.init(x: 120, y: 120, 50, height: 50)) self.view.addSubview(viewCustom)
class SomeView: UIView { var leading: NSLayoutConstraint! var trailing: NSLayoutConstraint! var bottom: NSLayoutConstraint! var height: NSLayoutConstraint! var someButton: UIButton = { var btn: UIButton = UIButton(type: UIButtonType.system) btn.setImage(UIImage(named: "someImage"), for: .normal) btn.translatesAutoresizingMaskIntoConstraints = false return btn }() var btnLeading: NSLayoutConstraint! var btnBottom: NSLayoutConstraint! var btnTop: NSLayoutConstraint! var btnWidth: NSLayoutConstraint! var textfield: UITextField = { var tf: UITextField = UITextField() tf.adjustsFontSizeToFitWidth = true tf.placeholder = "Cool placeholder" tf.translatesAutoresizingMaskIntoConstraints = false tf.backgroundColor = UIColor.white tf.textColor = UIColor.black return tf }() var txtfieldLeading: NSLayoutConstraint! var txtfieldTrailing: NSLayoutConstraint! var txtfieldCenterY: NSLayoutConstraint! override init(frame: CGRect){ super.init(frame: frame) self.translatesAutoresizingMaskIntoConstraints = false } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } /* override func draw(_ rect: CGRect) { } */ func activateConstraints(){ NSLayoutConstraint.activate([self.btnLeading, self.btnBottom, self.btnTop, self.btnWidth]) NSLayoutConstraint.activate([self.txtfieldCenterY, self.txtfieldLeading, self.txtfieldTrailing]) } func addContentToView(){ self.addSubview(self.userLocationBtn) self.btnLeading = NSLayoutConstraint( item: someButton, attribute: .leading, relatedBy: .equal, toItem: self, attribute: .leading, multiplier: 1.0, constant: 5.0) self.btnBottom = NSLayoutConstraint( item: someButton, attribute: .bottom, relatedBy: .equal, toItem: self, attribute: .bottom, multiplier: 1.0, constant: 0.0) self.btnTop = NSLayoutConstraint( item: someButton, attribute: .top, relatedBy: .equal, toItem: self, attribute: .top, multiplier: 1.0, constant: 0.0) self.btnWidth = NSLayoutConstraint( item: someButton, attribute: .width, relatedBy: .equal, toItem: self, attribute: .height, multiplier: 1.0, constant: 0.0) self.addSubview(self.textfield) self.txtfieldLeading = NSLayoutConstraint( item: self.textfield, attribute: .leading, relatedBy: .equal, toItem: someButton, attribute: .trailing, multiplier: 1.0, constant: 5) self.txtfieldTrailing = NSLayoutConstraint( item: self.textfield, attribute: .trailing, relatedBy: .equal, toItem: self.doneButton, attribute: .leading, multiplier: 1.0, constant: -5) self.txtfieldCenterY = NSLayoutConstraint( item: self.textfield, attribute: .centerY, relatedBy: .equal, toItem: self, attribute: .centerY, multiplier: 1.0, constant: 0.0) } }
let arr: [String] = ["foo", "bar"] let str: String? = arr[1] if let str2 = arr[2] as String? { println(str2) } else { }
extension Collection { subscript(optional i: Index) -> Iterator.Element? { return self.indices.contains(i) ? self[i] : nil } }
let arr = ["foo", "bar"] let str1 = arr[optional: 1] if let str2 = arr[optional: 2] { print(str2) } else { print("No string found at that index") }
extension Collection { subscript(safe index: Index) -> Iterator.Element? { guard indices.contains(index) else { return nil } return self[index] } } if let item = ["a","b","c","d"][safe:3] {print(item)} guard let anotherItem = ["a","b","c","d"][safe:3] else {return} print(anotherItem)
if let str2 = (arr.count > 2 ? arr[2] : nil) as String?
extension Collection { func get(at index: Index) -> Iterator.Element? { return self.indices.contains(index) ? self[index] : nil } }
let arr = [1,2,3] if let fourthItem = (3 < arr.count ? arr[3] : nil ) { Swift.print("fourthItem: \(fourthItem)") }else if let thirdItem = (2 < arr.count ? arr[2] : nil) { Swift.print("thirdItem: \(thirdItem)") }
for index 1...myArray.count { myArray.removeAtIndex(index) }
for index 0..<myArray.count { myArray.removeAtIndex(index) }
for index in reverse(0..<myArray.count) { myArray.removeAtIndex(index) }
for index in 1...myArray.count { myArray.removeAtIndex(index) }
var firstElement = myArray.first! myArray.removeAll() myArray.append(firstElement)
for index in stride(from: myArray.count - 1, through: 0, by: -1) { myArray.removeAtIndex(index) }
myArray = filter(myArray, { (obj) -> Bool in return false })
myArray = myArray.filter{ (obj) -> Bool in return false }
Syntax : public func removeAllObjects() Eg.: mainArray.removeAllObjects
Syntax : public func removeObjectAtIndex(index: Int) Eg.: mainArray.removeObjectAtIndex(5)
Syntax : public func removeLastObject() Eg.: mainArray.removeLastObject()
Syntax : public func removeObject(anObject: AnyObject, inRange range: NSRange)
Syntax : public func removeObject(anObject: AnyObject)
isbeauty = UIButton() isbeauty.setTitle("Buy", forState: UIControlState.Normal) isbeauty.titleLabel?.textColor = UIColorFromRGB("F21B3F") isbeauty.titleLabel!.font = UIFont(name: "AppleSDGothicNeo-Thin" , size: 25) isbeauty.backgroundColor = UIColor.clearColor() isbeauty.layer.cornerRadius = 5 isbeauty.layer.borderWidth = 1 isbeauty.layer.borderColor = UIColorFromRGB("F21B3F").CGColor isbeauty.frame = CGRectMake(300, 134, 55, 26) isbeauty.addTarget(self,action: "first:", forControlEvents: UIControlEvents.TouchUpInside) self.view.addSubview(isbeauty)
isbeauty.setTitleColor(UIColorFromRGB("F21B3F"), forState: .Normal)
[[UIApplication sharedApplication] setIdleTimerDisabled: YES];
UIApplication.sharedApplication().idleTimerDisabled = true
import UIKit import XCTest import MyProject class MySwiftClassTests: XCTestCase { override func setUp() { super.setUp() } override func tearDown() { super.tearDown() } func testExample() { XCTAssert(true, "Pass") } func testPerformanceExample() { self.measureBlock() { } } }
"$(CONFIGURATION_TEMP_DIR)/Product Name With Spaces.build/DerivedSources"
"$(CONFIGURATION_TEMP_DIR)/$(PROJECT_NAME).build/DerivedSources"
@interface Bar: NSObject - (instancetype)initWithFoo:(Foo *)foo; @end
@class Foo; @interface Bar: NSObject - (instancetype)initWithFoo:(Foo *)foo; @end
struct Point { var x = 0, y = 0 mutating func moveToX(x: Int, andY y:Int) { self.x = x self.y = y } } var p = Point(x: 1, y: 2) p.x = 3 p.moveToX(5, andY: 5)
var petNames: [String] = ["Ruff", "Garfield", "Nemo"] petNames.append("Harvey") let planetNames: [String] = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"] planetNames.append("Pluto")
let p = Point(x: 1, y: 2) p.x = 3 p.moveToX(5, andY: 5)
stackView.centerYAnchor.constraintEqualToAnchor(selectedContactsScrollView.centerYAnchor).active = true stackView.leadingAnchor.constraintEqualToAnchor(selectedContactsScrollView.leadingAnchor).active = true
stackView.layoutMargins = UIEdgeInsets(top: 0, left: 20, bottom: 0, right: 20) stackView.isLayoutMarginsRelativeArrangement = true
let spacerView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 10)) stackView.addArrangedSubview(spacerView) stackView.addArrangedSubview(viewThatNeedsSpaceBeforeIt) stackView.addArrangedSubview(NextView)...
firstView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 200).isActive = true
stackView.leadingAnchor.constraintEqualToAnchor(selectedContactsScrollView.leadingAnchor).active = true
stackView.leadingAnchor.constraintEqualToAnchor(selectedContactsScrollView.leadingAnchor, constant: 15).active = true
func icon() -> UIImage { guard let image = UIImage(named: "Photo") else { return UIImage(named: "Default")! } return image }
guard‚Äã ‚Äãlet‚Äã image = ‚ÄãUIImage‚Äã(named: selectedImageName) else { assertionFailure(‚Äã"Missing ‚Äã‚Äã\(‚ÄãselectedImageName‚Äã)‚Äã‚Äã asset"‚Äã) return } guard‚Äã ‚Äãlet‚Äã image = ‚ÄãUIImage‚Äã(named: selectedImageName) else { ‚Äã ‚Äãreturn }
func someFunc(blog: String?) { guard let blogName = blog else { print("some ErrorMessage") print(blogName) return } print(blogName) guard let blogName = blog else { print(" Some errorMessage") return } print(blogName) }
func someFunc(blog: String?) { if let blogName1 = blog { print(blogName1) } if let blogName1 = blog { print(blogName1) } }
var str : String? guard let blogName1 = str else { print("some error") return } print (blogName1)
var str : String? if let blogName1 = str { print(blogName1) }
func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { if let array = optionalArray { return array.count } return 0 }
func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { guard let array = optionalArray else { return 0 } return array.count }
func validateFieldsAndContinueRegistration() { if let firstNameString = firstName.text where firstNameString.characters.count > 0{ if let lastNameString = lastName.text where lastNameString.characters.count > 0{ if let emailString = email.text where emailString.characters.count > 3 && emailString.containsString("@") && emailString.containsString(".") { if let passwordString = password.text where passwordString.characters.count > 7{ let accountModel = AccountModel() accountModel.firstName = firstNameString accountModel.lastName = lastNameString accountModel.email = emailString accountModel.password = passwordString APIHandler.sharedInstance.registerUser(accountModel) } else { password.becomeFirstResponder() } } else { email.becomeFirstResponder() } } else { lastName.becomeFirstResponder() } } else { firstName.becomeFirstResponder() } }
func validateFieldsAndContinueRegistration() { guard let firstNameString = firstName.text where firstNameString.characters.count > 0 else { firstName.becomeFirstResponder() return } guard let lastNameString = lastName.text where lastNameString.characters.count > 0 else { lastName.becomeFirstResponder() return } guard let emailString = email.text where emailString.characters.count > 3 && emailString.containsString("@") && emailString.containsString(".") else { email.becomeFirstResponder() return } guard let passwordString = password.text where passwordString.characters.count > 7 else { password.becomeFirstResponder() return } let accountModel = AccountModel() accountModel.firstName = firstNameString accountModel.lastName = lastNameString accountModel.email = emailString accountModel.password = passwordString APIHandler.sharedInstance.registerUser(accountModel) }
if let roomCount = optionalValue { print("roomCount available") } else { print("roomCount is nil") }
func checkDrinkingAge() { let canDrink = true if canDrink { print("You may enter") } else { print("Let me take you to the jail") } }
func checkDrinkProgram() { let iCanDrink = true guard iCanDrink else { print("Let return } print("You may drink") }
var publicName: String? = "Bob Lee" var publicPhoto: String? = "Bob var publicAge: Int? = nil
func unwrapOneByOne() { if let name = publicName { if let photo = publicPhoto { if let age = publicAge { print("Bob: \(name), \(photo), \(age)") } else { print("age is mising") } } else { print("photo is missing") } } else { print("name is missing") } }
func unwrapBetter() { if let name = publicName { print("Yes name") } else { print("No name") return } if let photo = publicPhoto { print("Yes photo") } else { print("No photo") return } if let age = publicAge { print("Yes age") } else { print("No age") return } }
func unwrapOneByOneWithGuard() { guard let name = publicName else { print("Name missing") return } guard let photo = publicPhoto else { print("Photo missing") return } guard let age = publicAge else { print("Age missing") return } print(name) print(photo) print(age) }
func unwrap() { if let name = publicName, let photo = publicPhoto, let age = publicAge { print("Your name is \(name). I see your face right here, \(photo), you are \(age)") } else { print("Something is missing") } }
func unwrapWithGuard() { guard let name = publicName, let photo = publicPhoto, let age = publicAge else { print("Something is missing") return } print("Your name is \(name). I see your, \(photo). You are \(age).") }
button.addTarget(self, action: "buttonClicked:", forControlEvents: UIControlEvents.TouchUpInside)
func buttonClicked(sender:UIButton) { println("hello") }
button.tag = 5 button.addTarget(self, action: "buttonClicked:", forControlEvents: UIControlEvents.TouchUpInside)
button.tag = 5 button.addTarget(self,action: forControlEvents:.TouchUpInside)
@objc func buttonClicked(sender:UIButton) { if(sender.tag == 5){ var abc = "argOne" } print("hello") }
class subclassedUIButton: UIButton { var indexPath: Int? var urlString: String? }
import UIKit class PassableUIButton: UIButton{ var params: Dictionary<String, Any> override init(frame: CGRect) { self.params = [:] super.init(frame: frame) } required init?(coder aDecoder: NSCoder) { self.params = [:] super.init(coder: aDecoder) } }
let webButton = PassableUIButton(frame: CGRect(x:310, y:40, width:40, height:40)) webButton.setTitle("Visit",for: .normal) webButton.addTarget(self, action: webButton.params["myvalue"] = "bob"
@IBAction func webButtonTouched(_ sender: PassableUIButton) { print(sender.params["myvalue"] ?? "") }
button.addTarget(self, action: func YourMethodName(_ sender : UIButton) { print(sender.tag) }
func multipleParamSelector(_ sender: AnyObject, secondParams: AnyObject) { }
let deleteButton = UIButton(type: .roundedRect) deleteButton.setTitle("Delete", for: []) deleteButton.addTarget(self, action: MyController.deleteAction(sender:)), for: .touchUpInside)
var buttonTags:[Int:String]? let myArray = [0:"a",1:"b"] for (index,value) in myArray { let button = buttonTags?[index] = myArray[index] button.tag = index button.addTarget(self, action: } @objc func buttonAction(_ sender:UIButton) { let myString = buttonTags[sender.tag] }
testButton.on(.touchUpInside) { (sender, event) in print("user did press test button") }
import UIKit fileprivate var bindedEvents: [UIButton:EventBinder] = [:] fileprivate class EventBinder { let event: UIControl.Event let button: UIButton let handler: UIButton.EventHandler let selector: Selector required init( _ event: UIControl.Event, on button: UIButton, withHandler handler: @escaping UIButton.EventHandler ) { self.event = event self.button = button self.handler = handler self.selector = button.addTarget(self, action: self.selector, for: event) } deinit { button.removeTarget(self, action: selector, for: event) if let index = bindedEvents.index(forKey: button) { bindedEvents.remove(at: index) } } } private extension EventBinder { @objc func performEvent(on sender: UIButton, ofType event: UIControl.Event) { handler(sender, event) } } extension UIButton { typealias EventHandler = (UIButton, UIControl.Event) -> Void func on(_ event: UIControl.Event, handler: @escaping EventHandler) { bindedEvents[self] = EventBinder(event, on: self, withHandler: handler) } }
button.addTarget(self,action: forControlEvents:.TouchUpInside)
self.timer = Timer.scheduledTimer(timeInterval: timeInterval, target: self, selector: func fetchAutocompletePlaces(timer : Timer) { let keyword = timer.userInfo }
import UIKit extension UIImage { func cropToCircleWithBorderColor(color: UIColor, lineWidth: CGFloat) -> UIImage { return newImage } }
import UIKit class ViewController: UIViewController { @IBOutlet var imageView : UIImageView = nil override func viewDidLoad() { super.viewDidLoad() let img = imageView.image imageView.image = img.cropToCircleWithBorderColor(UIColor(red:0.91, green:0.34, blue:0.16, alpha:1.00), lineWidth: 20) } }
debug release release function -Onone -O -Ounchecked assert() YES NO NO assertionFailure() YES NO NO** precondition() YES YES NO preconditionFailure() YES YES YES** fatalError()* YES YES YES
func precondition(condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = default, line: UWord = default)
func assert(condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = default, line: UWord = default)
int foo() { static int timesCalled = 0; ++timesCalled; return timesCalled; }
- (NSInteger)foo { static NSInteger timesCalled = 0; ++timesCalled; return timesCalled; }
static var timesCalledA = 0 var static timesCalledB = 0 var timesCalledC: static Int = 0 var timesCalledD: Int static = 0
func foo() -> Int { struct Holder { static var timesCalled = 0 } Holder.timesCalled += 1 return Holder.timesCalled } 7> foo() $R0: Int = 1 8> foo() $R1: Int = 2 9> foo() $R2: Int = 3
func makeIncrementerClosure() -> () -> Int { var timesCalled = 0 func incrementer() -> Int { timesCalled += 1 return timesCalled } return incrementer } let foo = makeIncrementerClosure() foo() foo()
class StaticThing { static var timesCalled = 0 class func doSomething() { timesCalled++ println(timesCalled) } } StaticThing.doSomething() StaticThing.doSomething() StaticThing.doSomething()
var perimeter: Double { get { return 3.0 * sideLength } set { sideLength = newValue / 3.0 } }
@property (nonatomic) double perimeter; - (double)perimeter { return self.sideLength * 3.0; } - (void)setPerimeter:(double)perimeter { self.perimeter = perimeter; self.sideLength = perimeter / 3.0; }
class family { var _members:Int = 2 var members:Int { get { return _members } set (newVal) { if newVal >= 2 { _members = newVal } else { println( } } } }
var A:Int = 0 var B:Int = 0 var C:Int { get {return 1} set {print("Recived new value", newValue, " and stored into B = newValue } } A = C A C = 2 B
UIApplication.sharedApplication().statusBarStyle = .LightContent
enum UIStatusBarStyle : Int { case Default case LightContent case BlackOpaque }
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
override func preferredStatusBarStyle() -> UIStatusBarStyle { return UIStatusBarStyle.LightContent }
UIApplication.shared.statusBarStyle = .lightContent
UIApplication.sharedApplication().statusBarStyle = .LightContent
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { UINavigationBar.appearance().barStyle = .Black }
override var preferredStatusBarStyle: UIStatusBarStyle { return .lightContent }
UIApplication.sharedApplication().setStatusBarStyle(UIStatusBarStyle.LightContent, animated: true)
<key>UIStatusBarStyle</key> <string>UIStatusBarStyleLightContent</string> <key>UIViewControllerBasedStatusBarAppearance</key> <false/>
self.navigationController?.navigationBar.barStyle = .black;
extension UINavigationController { override open var preferredStatusBarStyle: UIStatusBarStyle { if let lastVC = self.viewControllers.last { return lastVC.preferredStatusBarStyle } return .default } }
extension UINavigationController { override open var preferredStatusBarStyle: UIStatusBarStyle { get { return .lightContent } } }
override var preferredStatusBarStyle: UIStatusBarStyle { get { return .lightContent } }
override func preferredStatusBarStyle() -> UIStatusBarStyle { return UIStatusBarStyle.LightContent }
UIApplication.shared.statusBarStyle = .lightContent setNeedsStatusBarAppearanceUpdate()
typealias CompletionHandler = (success:Bool) -> Void func downloadFileFromURL(url: NSURL,completionHandler: CompletionHandler) { let flag = true completionHandler(success: flag) } downloadFileFromURL(NSURL(string: "url_str")!, { (success) -> Void in if success { } else { } })
func method(arg: Bool, completion: (Bool) -> ()) { print("First line of code executed") completion(arg) }
method(arg: true, completion: { (success) -> Void in print("Second line of code executed") if success { print("true") } else { print("false") } })
func yourFunctionName(finished: () -> Void) { print("Doing something!") finished() }
override func viewDidLoad() { yourFunctionName { print("Tada!!!!") } }
func loadHealthCareList(completionClosure: (indexes: NSMutableArray)-> ()) { completionClosure(indexes: list) }
healthIndexManager.loadHealthCareList { (indexes) -> () in print(indexes) }
typealias CompletionHandler = (success:Bool) -> Void func downloadFileFromURL(url: NSURL,completionHandler: CompletionHandler) { let flag = true completionHandler(success: flag) }
downloadFileFromURL(NSURL(string: "url_str")!) { (success) -> Void in if success { } else { } }
let randomIntFrom0To10 = Int.random(in: 1..<10) let randomFloat = Float.random(in: 0..<1) let greetings = ["hey", "hi", "hello", "hola"] greetings.randomElement()
arc4random() arc4random() arc4random() arc4random() arc4random() drand48() drand48() drand48() drand48() drand48() arc4random_uniform(3) arc4random_uniform(3) arc4random_uniform(3) arc4random_uniform(3) arc4random_uniform(3)
func randomNumber(MIN: Int, MAX: Int)-> Int{ return Int(arc4random_uniform(UInt32(MAX-MIN)) + UInt32(MIN)); }
import Foundation struct Math { private static var seeded = false static func randomFractional() -> CGFloat { if !Math.seeded { let time = Int(NSDate().timeIntervalSinceReferenceDate) srand48(time) Math.seeded = true } return CGFloat(drand48()) } }
func xorshift128plus(seed0 : UInt64, _ seed1 : UInt64) -> () -> UInt64 { var state0 : UInt64 = seed0 var state1 : UInt64 = seed1 if state0 == 0 && state1 == 0 { state0 = 1 } func rand() -> UInt64 { var s1 : UInt64 = state0 let s0 : UInt64 = state1 state0 = s0 s1 ^= s1 << 23 s1 ^= s1 >> 17 s1 ^= s0 s1 ^= s0 >> 26 state1 = s1 return UInt64.addWithOverflow(state0, state1).0 } return rand }
let rand = xorshift128plus(urand64(), urand64()) for _ in 1...10 { print(rand()) }
let randomInt = Int.random(in: 1..<5) let randomFloat = Float.random(in: 1..<10) let randomDouble = Double.random(in: 1...100) let randomCGFloat = CGFloat.random(in: 1...1000)
let MAX : UInt32 = 9 let MIN : UInt32 = 1 func randomNumber() { var random_number = Int(arc4random_uniform(MAX) + MIN) print ("random = ", random_number); }
let limit : UInt32 = 6 print("Random Number : \(arc4random_uniform(limit))")
public extension Int { static func random(from: Int, to: Int) -> Int { guard to > from else { assertionFailure("Can not generate negative random numbers") return 0 } return Int(arc4random_uniform(UInt32(to - from)) + UInt32(from)) } }
let die = [1, 2, 3, 4, 5, 6] let firstRoll = die[Int(arc4random_uniform(UInt32(die.count)))] let secondRoll = die[Int(arc4random_uniform(UInt32(die.count)))]
let quotes: NSArray = ["R", "A", "N", "D", "O", "M"] let randomNumber = arc4random_uniform(UInt32(quotes.count)) let quoteString = quotes[Int(randomNumber)] print(quoteString)
func getRandomNumbers(totalQuestions:Int) -> NSMutableArray { var arrayOfRandomQuestions: [Int] = [] print("arraySizeRequired = 40") print("totalQuestions = \(totalQuestions)") while arrayOfRandomQuestions.count < 40 { let limit: UInt32 = UInt32(totalQuestions) let theRandomNumber = (Int(arc4random_uniform(limit))) if arrayOfRandomQuestions.contains(theRandomNumber) { print("ping") } else { arrayOfRandomQuestions.append(theRandomNumber) } } print("Random Number set = \(arrayOfRandomQuestions)") print("arrayOutputCount = \(arrayOfRandomQuestions.count)") return arrayOfRandomQuestions as! NSMutableArray }
func randomNumber(MIN: Int, MAX: Int)-> Int{ var list : [Int] = [] for i in MIN...MAX { list.append(i) } return list[Int(arc4random_uniform(UInt32(list.count)))] }
print("My Random Number is: \(randomNumber(MIN:-10,MAX:10))")
import GameKit let minValue = 0 let maxValue = 100 var randomDistribution: GKRandomDistribution? let randomSource = GKMersenneTwisterRandomSource() randomDistribution = GKRandomDistribution(randomSource: randomSource, lowestValue: minValue, highestValue: maxValue) let number = randomDistribution?.nextInt() ?? 0 print(number)
var RNumber = Int(arc4random_uniform(9)+1) func GetCase(){ your code }
func GetCase() { let RNumber = Int(arc4random_uniform(9)+1) if categoria == 1 { } }
func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAtIndex section: Int) -> UIEdgeInsets { let totalCellWidth = CellWidth * CellCount let totalSpacingWidth = CellSpacing * (CellCount - 1) let leftInset = (collectionViewWidth - CGFloat(totalCellWidth + totalSpacingWidth)) / 2 let rightInset = leftInset return UIEdgeInsetsMake(0, leftInset, 0, rightInset) }
func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAtIndex section: Int) -> UIEdgeInsets { let totalCellWidth = 80 * collectionView.numberOfItems(inSection: 0) let totalSpacingWidth = 10 * (collectionView.numberOfItems(inSection: 0) - 1) let leftInset = (collectionView.layer.frame.size.width - CGFloat(totalCellWidth + totalSpacingWidth)) / 2 let rightInset = leftInset return UIEdgeInsetsMake(0, leftInset, 0, rightInset) }
func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { let cellWidth : CGFloat = 165.0 let numberOfCells = floor(self.view.frame.size.width / cellWidth) let edgeInsets = (self.view.frame.size.width - (numberOfCells * cellWidth)) / (numberOfCells + 1) return UIEdgeInsetsMake(15, edgeInsets, 0, edgeInsets) }
- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(nonnull UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section { CGFloat totalCellWidth = kItemWidth * self.dataArray.count; CGFloat totalSpacingWidth = kSpacing * (((float)self.dataArray.count - 1) < 0 ? 0 :self.dataArray.count - 1); CGFloat leftInset = (self.bounds.size.width - (totalCellWidth + totalSpacingWidth)) / 2; CGFloat rightInset = leftInset; UIEdgeInsets sectionInset = UIEdgeInsetsMake(0, leftInset, 0, rightInset); return sectionInset; }
func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { let totalCellWidth = Int(collectionView.layer.frame.size.width) / 3 * collectionView.numberOfItems(inSection: 0) let totalSpacingWidth = (collectionView.numberOfItems(inSection: 0) - 1) let leftInset = (collectionView.layer.frame.size.width - CGFloat(totalCellWidth + totalSpacingWidth)) / 2 let rightInset = leftInset return UIEdgeInsetsMake(0, leftInset, 0, rightInset) }
public extension UICollectionView { func centerContentHorizontalyByInsetIfNeeded(minimumInset: UIEdgeInsets) { guard let layout = collectionViewLayout as? UICollectionViewFlowLayout, layout.scrollDirection == .horizontal else { assertionFailure("\( return } if layout.collectionViewContentSize.width > frame.size.width { contentInset = minimumInset } else { contentInset = UIEdgeInsets(top: minimumInset.top, left: (frame.size.width - layout.collectionViewContentSize.width) / 2, bottom: minimumInset.bottom, right: 0) } } } final class Foo: UIViewController { override func viewDidLayoutSubviews() { super.viewDidLayoutSubviews() collectionView.centerContentHorizontalyByInsetIfNeeded(minimumInset: yourDefaultInset) } }
extension ViewController: UICollectionViewDelegateFlowLayout { func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { let cellWidth: CGFloat = 170.0 let numberOfCells = floor(view.frame.size.width / cellWidth) let edgeInsets = (view.frame.size.width - (numberOfCells * cellWidth)) / (numberOfCells + 1) return UIEdgeInsetsMake(0, edgeInsets, 0, edgeInsets) } }
func refreshCollectionView(_ count: Int) { let collectionViewHeight = collectionView.bounds.height let collectionViewWidth = collectionView.bounds.width let numberOfItemsThatCanInCollectionView = Int(collectionViewWidth / collectionViewHeight) if numberOfItemsThatCanInCollectionView > count { let totalCellWidth = collectionViewHeight * CGFloat(count) let totalSpacingWidth: CGFloat = CGFloat(count) * (CGFloat(count) - 1) leftInset = (collectionViewWidth - CGFloat(totalCellWidth + totalSpacingWidth)) / 2; rightInset = -leftInset } else { leftInset = 0.0 rightInset = -collectionViewHeight } collectionView.reloadData() } func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { return UIEdgeInsetsMake(0, leftInset, 0, rightInset) }
if (leftInset > 0) { return UIEdgeInsetsMake(0, leftInset, 0, rightInset) } else { return UIEdgeInsetsMake(0, 10, 0, 10) }
func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { return UIEdgeInsetsMake(0, 40, 0, 40) }
private lazy var contentView: UICollectionView = { let layoutView: UICollectionViewFlowLayout = UICollectionViewFlowLayout() layoutView.scrollDirection = .horizontal layoutView.minimumInteritemSpacing = 0 layoutView.minimumLineSpacing = 5 let collectionView: UICollectionView = UICollectionView(frame: .zero, collectionViewLayout: layoutView) collectionView.dataSource = self collectionView.delegate = self collectionView.showsHorizontalScrollIndicator = false collectionView.isPagingEnabled = true collectionView.registerCell(Cell.self) collectionView.backgroundColor = .clear collectionView.translatesAutoresizingMaskIntoConstraints = false return collectionView }()
extension CustomCollectionView: UICollectionViewDelegateFlowLayout { func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize { return CGSize(width: collectionView.frame.width*4/5, height: collectionView.frame.height) } func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { let cellWidth : CGFloat = collectionView.frame.width*4/5 let numberOfCells = floor(collectionView.frame.width / cellWidth) let edgeInsets = (collectionView.frame.width - (numberOfCells * cellWidth)) / (numberOfCells + 1) return UIEdgeInsets(top: 0, left: edgeInsets, bottom: 0, right: edgeInsets) } }
func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { let flowLayout = collectionViewLayout as! UICollectionViewFlowLayout let cellWidth: CGFloat = flowLayout.itemSize.width let cellHieght: CGFloat = flowLayout.itemSize.height let cellSpacing: CGFloat = flowLayout.minimumInteritemSpacing let cellCount = CGFloat(collectionView.numberOfItems(inSection: section)) var collectionWidth = collectionView.frame.size.width var collectionHeight = collectionView.frame.size.height if collectionWidth -= collectionView.safeAreaInsets.left + collectionView.safeAreaInsets.right collectionHeight -= collectionView.safeAreaInsets.top + collectionView.safeAreaInsets.bottom } let totalWidth = cellWidth * cellCount + cellSpacing * (cellCount - 1) let totalHieght = cellHieght * cellCount + cellSpacing * (cellCount - 1) if totalWidth <= collectionWidth { let edgeInsetWidth = (collectionWidth - totalWidth) / 2 print(edgeInsetWidth, edgeInsetWidth) return UIEdgeInsets(top: 5, left: edgeInsetWidth, bottom: flowLayout.sectionInset.top, right: edgeInsetWidth) } else { let edgeInsetHieght = (collectionHeight - totalHieght) / 2 print(edgeInsetHieght, edgeInsetHieght) return UIEdgeInsets(top: edgeInsetHieght, left: flowLayout.sectionInset.top, bottom: edgeInsetHieght, right: flowLayout.sectionInset.top) } }
func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets { let flowLayout = collectionViewLayout as! UICollectionViewFlowLayout let cellWidth: CGFloat = flowLayout.itemSize.width let cellSpacing: CGFloat = flowLayout.minimumInteritemSpacing let cellCount = CGFloat(collectionView.numberOfItems(inSection: section)) var collectionWidth = collectionView.frame.size.width if collectionWidth -= collectionView.safeAreaInsets.left + collectionView.safeAreaInsets.right } let totalWidth = cellWidth * cellCount + cellSpacing * (cellCount - 1) if totalWidth <= collectionWidth { let edgeInset = (collectionWidth - totalWidth) / 2 return UIEdgeInsetsMake(flowLayout.sectionInset.top, edgeInset, flowLayout.sectionInset.bottom, edgeInset) } else { return flowLayout.sectionInset } }
var blurEffectView = UIVisualEffectView() blurEffectView = UIVisualEffectView(effect: UIBlurEffect(style: .dark))
blurEffectView.hidden = false UIView.animate(withDuration: 1, delay: 0, options: .curveEaseOut) { self.blurEffectView.alpha = 1 }
let overlay = UIVisualEffectView() UIView.animate(withDuration: 0.5) { overlay.effect = UIBlurEffect(style: .light) }
UIView.animateWithDuration(1.0, animations: { self.blurEffectView.effect = UIBlurEffect(nil) self.blurEffectView.alpha = 0 }, completion: { (finished: Bool) -> Void in self.blurEffectView.removeFromSuperview() } )
extension UIVisualEffectView { func fadeInEffect(_ style:UIBlurEffectStyle = .light, withDuration duration: TimeInterval = 1.0) { if let animator = UIViewPropertyAnimator(duration: duration, curve: .easeIn) { self.effect = UIBlurEffect(style: style) } animator.startAnimation() }else { UIView.animate(withDuration: duration) { self.effect = UIBlurEffect(style: style) } } } func fadeOutEffect(withDuration duration: TimeInterval = 1.0) { if let animator = UIViewPropertyAnimator(duration: duration, curve: .linear) { self.effect = nil } animator.startAnimation() animator.fractionComplete = 1 }else { UIView.animate(withDuration: duration) { self.effect = nil } } } }
func addBlur() { guard let blurEffectView = blurEffectView else { return } let snapShot = self.view.snapshotViewAfterScreenUpdates(false) view.addSubview(blurEffectView) view.addSubview(snapShot) UIView.animateWithDuration(0.25, animations: { snapShot.alpha = 0.0 }, completion: { (finished: Bool) -> Void in snapShot.removeFromSuperview() } ) } func removeBlur() { guard let blurEffectView = blurEffectView else { return } let snapShot = self.view.snapshotViewAfterScreenUpdates(false) snapShot.alpha = 0.0 view.addSubview(snapShot) UIView.animateWithDuration(0.25, animations: { snapShot.alpha = 1.0 }, completion: { (finished: Bool) -> Void in blurEffectView.removeFromSuperview() snapShot.removeFromSuperview() } ) }
UIVisualEffectView *blurEffectView = [[UIVisualEffectView alloc] initWithEffect:nil]; blurEffectView.frame = self.view.frame; blurEffectView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; UIView *blackUIView = [[UIView alloc]initWithFrame:self.view.frame]; [bacgroundImageView addSubview:blackUIView]; [blackUIView addSubview:blurEffectView]; UIViewPropertyAnimator *animator = [[UIViewPropertyAnimator alloc] initWithDuration:4.f curve:UIViewAnimationCurveLinear animations:^{ [blurEffectView setEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]]; }];
let blurEffectView = UIVisualEffectView() UIView.animateWithDuration(1) { self.blurEffectView.effect = UIBlurEffect(style: .Light) } UIView.animateWithDuration(1) { self.blurEffectView.viewWithTag(1)?.alpha = 1 } UIView.animateWithDuration(1) { self.blurEffectView.effect = nil } UIView.animateWithDuration(1) { self.blurEffectView.viewWithTag(1)?.alpha = 0 }
<UIVisualEffectView 0x7ff7bb54b490> is being asked to animate its opacity. This will cause the effect to appear broken until opacity returns to 1.
extension UIViewController { func blur() { let blurView = UIVisualEffectView(frame: self.view.frame) self.view.addSubview(blurView) UIView.animate(withDuration:0.25) { blurView.effect = UIBlurEffect(style: .light) } } func unblur() { for childView in view.subviews { guard let effectView = childView as? UIVisualEffectView else { continue } UIView.animate(withDuration: 0.25, animations: { effectView.effect = nil }) { didFinish in effectView.removeFromSuperview() } } } }
extension UIView { func blur(duration inSeconds: Double, effect tone: UIBlurEffectStyle) { let blurView = UIVisualEffectView(frame: self.bounds) self.addSubview(blurView) UIView.animate(withDuration: inSeconds) { blurView.effect = UIBlurEffect(style: tone) } } func unblur(duration inSeconds: Double) { for childView in subviews { guard let effectView = childView as? UIVisualEffectView else { continue } UIView.animate(withDuration: inSeconds, animations: { effectView.effect = nil }){ didFinish in effectView.removeFromSuperview() } } } }
func goToMap(){ var lat1 : NSString = self.venueLat var lng1 : NSString = self.venueLng var latitude:CLLocationDegrees = lat1.doubleValue var longitude:CLLocationDegrees = lng1.doubleValue var coordinate = CLLocationCoordinate2DMake(latitude, longitude) var placemark : MKPlacemark = MKPlacemark(coordinate: coordinate, addressDictionary:nil) var mapItem:MKMapItem = MKMapItem(placemark: placemark) mapItem.name = "Target location" let launchOptions:NSDictionary = NSDictionary(object: MKLaunchOptionsDirectionsModeDriving, forKey: MKLaunchOptionsDirectionsModeKey) var currentLocationMapItem:MKMapItem = MKMapItem.mapItemForCurrentLocation() MKMapItem.openMapsWithItems([currentLocationMapItem, mapItem], launchOptions: launchOptions) }
func openMapForPlace() { let lat1 : NSString = self.venueLat let lng1 : NSString = self.venueLng let latitude:CLLocationDegrees = lat1.doubleValue let longitude:CLLocationDegrees = lng1.doubleValue let regionDistance:CLLocationDistance = 10000 let coordinates = CLLocationCoordinate2DMake(latitude, longitude) let regionSpan = MKCoordinateRegionMakeWithDistance(coordinates, regionDistance, regionDistance) let options = [ MKLaunchOptionsMapCenterKey: NSValue(MKCoordinate: regionSpan.center), MKLaunchOptionsMapSpanKey: NSValue(MKCoordinateSpan: regionSpan.span) ] let placemark = MKPlacemark(coordinate: coordinates, addressDictionary: nil) let mapItem = MKMapItem(placemark: placemark) mapItem.name = "\(self.venueName)" mapItem.openInMapsWithLaunchOptions(options) }
import UIKit import MapKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() openMapForPlace() } func openMapForPlace() { let latitude: CLLocationDegrees = 37.2 let longitude: CLLocationDegrees = 22.9 let regionDistance:CLLocationDistance = 10000 let coordinates = CLLocationCoordinate2DMake(latitude, longitude) let regionSpan = MKCoordinateRegionMakeWithDistance(coordinates, regionDistance, regionDistance) let options = [ MKLaunchOptionsMapCenterKey: NSValue(mkCoordinate: regionSpan.center), MKLaunchOptionsMapSpanKey: NSValue(mkCoordinateSpan: regionSpan.span) ] let placemark = MKPlacemark(coordinate: coordinates, addressDictionary: nil) let mapItem = MKMapItem(placemark: placemark) mapItem.name = "Place Name" mapItem.openInMaps(launchOptions: options) } }
let coordinate = CLLocationCoordinate2DMake(theLatitude,theLongitude) let mapItem = MKMapItem(placemark: MKPlacemark(coordinate: coordinate, addressDictionary:nil)) mapItem.name = "Target location" mapItem.openInMaps(launchOptions: [MKLaunchOptionsDirectionsModeKey : MKLaunchOptionsDirectionsModeDriving])
let url = "http: UIApplication.shared.openURL(URL(string:url)!) let url = "http: UIApplication.shared.openURL(URL(string:url)!)
let source = MKMapItem(placemark: MKPlacemark(coordinate: CLLocationCoordinate2D(latitude: lat, longitude: lng))) source.name = "Source" let destination = MKMapItem(placemark: MKPlacemark(coordinate: CLLocationCoordinate2D(latitude: lat, longitude: lng))) destination.name = "Destination" MKMapItem.openMaps(with: [source, destination], launchOptions: [MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving])
let coordinate = CLLocationCoordinate2DMake(theLatitude, theLongitude) let region = MKCoordinateRegionMake(coordinate, MKCoordinateSpanMake(0.01, 0.02)) let placemark = MKPlacemark(coordinate: coordinate, addressDictionary: nil) let mapItem = MKMapItem(placemark: placemark) let options = [ MKLaunchOptionsMapCenterKey: NSValue(mkCoordinate: region.center), MKLaunchOptionsMapSpanKey: NSValue(mkCoordinateSpan: region.span)] mapItem.name = theLocationName mapItem.openInMaps(launchOptions: options)
let coordinates = CLLocationCoordinate2DMake(-37.848854,144.990295) let regionSpan = MKCoordinateRegionMakeWithDistance(coordinates, 1000, 1000) let placemark = MKPlacemark(coordinate: coordinates, addressDictionary: nil) let mapItem = MKMapItem(placemark: placemark) mapItem.name = ‚ÄúDesired place‚Äù mapItem.openInMaps(launchOptions:[ MKLaunchOptionsMapCenterKey: NSValue(mkCoordinate: regionSpan.center) ] as [String : Any])
let cgFloat: CGFloat = 3.14159 let someFloat = Float(cgFloat)
extension Int { var f: CGFloat { return CGFloat(self) } } extension Float { var f: CGFloat { return CGFloat(self) } } extension Double { var f: CGFloat { return CGFloat(self) } } extension CGFloat { var swf: Float { return Float(self) } }
var someCGFloatFromFloat = 1.3.f var someCGFloatFromInt = 2.f var someFloatFromCGFloat = someCGFloatFromFloat.swf
class A { } class B : A { } var a: A = B() var b: B = a as B
var d: Double = 2.0 var f: Float = Float(d) var i: Int = Int(d)
class Promise { func then(onFulfilled: ()->(), onReject: ()->()?){ if let callableRjector = onReject { } } }
func then(onFulfilled: ()->(), onReject: (()->())?){ if let callableRjector = onReject { } }
func then(onFulfilled: ()->(), onReject: (()->())? = nil) { onReject?() }
func then(onFulfilled: ()->(), onReject: ()->() = {}){ onFulfilled() onReject() }
typealias SimpleCallBack = () -> () class Promise { func then(onFulfilled: SimpleCallBack, onReject: SimpleCallBack?){ if let callableRjector = onReject { } } }
CGFloat dashes[] = {4, 2}; [path setLineDash:dashes count:2 phase:0]; [path stroke];
@IBDesignable class DottedVertical: UIView { @IBInspectable var dotColor: UIColor = UIColor.etc @IBInspectable var lowerHalfOnly: Bool = false override func draw(_ rect: CGRect) { let totalCount = 8 + 8 - 1 let fullHeight = bounds.size.height let width = bounds.size.width let itemLength = fullHeight / CGFloat(totalCount) let path = UIBezierPath() let beginFromTop = CGFloat(0.0) let top = CGPoint(x: width/2, y: beginFromTop) let bottom = CGPoint(x: width/2, y: fullHeight) path.move(to: top) path.addLine(to: bottom) path.lineWidth = width let dashes: [CGFloat] = [itemLength, itemLength] path.setLineDash(dashes, count: dashes.count, phase: 0) dotColor.setStroke() path.stroke() } }
import UIKit import PlaygroundSupport let path = UIBezierPath() path.move(to: CGPoint(x:10,y:10)) path.addLine(to: CGPoint(x:290,y:10)) path.lineWidth = 8 let dashes: [CGFloat] = [0.001, path.lineWidth * 2] path.setLineDash(dashes, count: dashes.count, phase: 0) path.lineCapStyle = CGLineCap.round UIGraphicsBeginImageContextWithOptions(CGSize(width:300, height:20), false, 2) UIColor.white.setFill() UIGraphicsGetCurrentContext()!.fill(.infinite) UIColor.black.setStroke() path.stroke() let image = UIGraphicsGetImageFromCurrentImageContext() let view = UIImageView(image: image) PlaygroundPage.current.liveView = view UIGraphicsEndImageContext()
UIBezierPath * path = [[UIBezierPath alloc] init]; [path moveToPoint:CGPointMake(10.0, 10.0)]; [path addLineToPoint:CGPointMake(290.0, 10.0)]; [path setLineWidth:8.0]; CGFloat dashes[] = { path.lineWidth, path.lineWidth * 2 }; [path setLineDash:dashes count:2 phase:0]; [path setLineCapStyle:kCGLineCapRound]; UIGraphicsBeginImageContextWithOptions(CGSizeMake(300, 20), false, 2); [path stroke]; UIImage * image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();
extension UIView { func addDashedBorder(strokeColor: UIColor, lineWidth: CGFloat) { self.layoutIfNeeded() let strokeColor = strokeColor.cgColor let shapeLayer:CAShapeLayer = CAShapeLayer() let frameSize = self.frame.size let shapeRect = CGRect(x: 0, y: 0, width: frameSize.width, height: frameSize.height) shapeLayer.bounds = shapeRect shapeLayer.position = CGPoint(x: frameSize.width/2, y: frameSize.height/2) shapeLayer.fillColor = UIColor.clear.cgColor shapeLayer.strokeColor = strokeColor shapeLayer.lineWidth = lineWidth shapeLayer.lineJoin = kCALineJoinRound shapeLayer.lineDashPattern = [5,5] shapeLayer.path = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: shapeRect.width, height: shapeRect.height), cornerRadius: self.layer.cornerRadius).cgPath self.layer.addSublayer(shapeLayer) } }
class ViewController: UIViewController { var someView: UIView! override func viewDidLoad() { super.viewDidLoad() someView = UIView() someView.layer.cornerRadius = 5.0 view.addSubview(someView) someView.translatesAutoresizingMaskIntoConstraints = false someView.widthAnchor.constraint(equalToConstant: 200).isActive = true someView.heightAnchor.constraint(equalToConstant: 200).isActive = true someView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true someView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true } override func viewDidLayoutSubviews() { someView.addDashedBorder(strokeColor: UIColor.red, lineWidth: 1.0) } }
extension UIImage { class func dottedLine(radius radius: CGFloat, space: CGFloat, numberOfPattern: CGFloat) -> UIImage { let path = UIBezierPath() path.moveToPoint(CGPointMake(radius/2, radius/2)) path.addLineToPoint(CGPointMake((numberOfPattern)*(space+1)*radius, radius/2)) path.lineWidth = radius let dashes: [CGFloat] = [path.lineWidth * 0, path.lineWidth * (space+1)] path.setLineDash(dashes, count: dashes.count, phase: 0) path.lineCapStyle = CGLineCap.Round UIGraphicsBeginImageContextWithOptions(CGSizeMake((numberOfPattern)*(space+1)*radius, radius), false, 1) UIColor.whiteColor().setStroke() path.stroke() let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }
UIImage.dottedLine(radius: 100, space: 2, numberOfPattern: 1)
extension UIImage { static func drawDottedImage(width: CGFloat, height: CGFloat, color: UIColor) -> UIImage { let path = UIBezierPath() path.move(to: CGPoint(x: 1.0, y: 1.0)) path.addLine(to: CGPoint(x: width, y: 1)) path.lineWidth = 1.5 let dashes: [CGFloat] = [path.lineWidth, path.lineWidth * 5] path.setLineDash(dashes, count: 2, phase: 0) path.lineCapStyle = .butt UIGraphicsBeginImageContextWithOptions(CGSize(width: width, height: height), false, 2) color.setStroke() path.stroke() let image: UIImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() return image } }
let dashes: [CGFloat] = [0.001, path.lineWidth * 2]
public enum CGLineCap : Int32 { case butt case round case square }
layer.path = linePath.cgPath layer.lineWidth = 3 layer.lineDashPattern = [1,layer.lineWidth*2] as [NSNumber] layer.lineCap = "round"
CAShapeLayer *shapelayer = [CAShapeLayer layer]; UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(0.0, titileLabel.frame.size.height-2)]; [path addLineToPoint:CGPointMake(SCREEN_WIDTH, titileLabel.frame.size.height-2)]; UIColor *fill = [UIColor colorWithRed:0.80f green:0.80f blue:0.80f alpha:1.00f]; shapelayer.strokeStart = 0.0; shapelayer.strokeColor = fill.CGColor; shapelayer.lineWidth = 2.0; shapelayer.lineJoin = kCALineJoinRound; shapelayer.lineDashPattern = [NSArray arrayWithObjects:[NSNumber numberWithInt:2],[NSNumber numberWithInt:3 ], nil]; shapelayer.path = path.CGPath; [titileLabel.layer addSublayer:shapelayer];
class A { var x: Int init(x: Int) { self.x = x } convenience init() { self.init(x: 0) } } class B: A { init() { super.init() } }
class A { var a: Int var b: Int init (a: Int, b: Int) { print("Entering A.init(a,b)") self.a = a; self.b = b } convenience init(a: Int) { print("Entering A.init(a)") self.init(a: a, b: 0) } convenience init() { print("Entering A.init()") self.init(a:0) } } class B : A { var c: Int override init(a: Int, b: Int) { print("Entering B.init(a,b)") self.c = 0; super.init(a: a, b: b) } } var b = B()
Entering A.init() Entering A.init(a:) Entering B.init(a:,b:) Entering A.init(a:,b:)
class SuperClass { init() { } convenience init(value: Int) { self.init() } } class SubClass : SuperClass { override init() { super.init(value: 10) } }
class A { var x: Int init(x: Int) { self.x = x } convenience init() { self.init(x: 0) } } class B: A { init() { let intermediate = A() super.init(x: intermediate.x) } }
class Dragon { var legs: Int var isFlying: Bool init(legs: Int, isFlying: Bool) { self.legs = legs self.isFlying = isFlying } convenience initWyvern() { self.init(legs: 2, isFlying: true) } }
class Wyrm: Dragon { init() { super.init(legs: 0, isFlying: false) } }
class A { var x: Int init(x: Int) { self.x = x } init() { self.x = 0 } } class B: A { override init() { super.init() } } let s = B() s.x
self.view.backgroundColor = UIColor(patternImage: UIImage(named: "testBg")!)
var darkBlur = UIBlurEffect(style: UIBlurEffectStyle.Dark) var blurView = UIVisualEffectView(effect: darkBlur) blurView.frame = imageView.bounds imageView.addSubview(blurView)
let blurEffect = UIBlurEffect(style: UIBlurEffectStyle.Dark) let blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.frame = view.bounds blurEffectView.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] view.addSubview(blurEffectView)
let blurEffect = UIBlurEffect(style: UIBlurEffectStyle.dark) let blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.frame = view.bounds blurEffectView.autoresizingMask = [.flexibleWidth, .flexibleHeight] view.addSubview(blurEffectView)
import Foundation import UIKit extension UIImageView { func makeBlurImage(targetImageView:UIImageView?) { let blurEffect = UIBlurEffect(style: UIBlurEffectStyle.Dark) let blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.frame = targetImageView!.bounds blurEffectView.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] targetImageView?.addSubview(blurEffectView) } }
override func viewDidLoad() { super.viewDidLoad() let sampleImageView = UIImageView(frame: CGRectMake(0, 200, 300, 325)) let sampleImage:UIImage = UIImage(named: "ic_120x120")! sampleImageView.image = sampleImage sampleImageView.makeBlurImage(sampleImageView) self.view.addSubview(sampleImageView) }
import Foundation import UIKit extension UIImageView { func addBlurEffect() { let blurEffect = UIBlurEffect(style: UIBlurEffectStyle.light) let blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.frame = self.bounds blurEffectView.autoresizingMask = [.flexibleWidth, .flexibleHeight] self.addSubview(blurEffectView) } }
extension UIView { func removeBlurEffect() { let blurredEffectViews = self.subviews.filter{$0 is UIVisualEffectView} blurredEffectViews.forEach{ blurView in blurView.removeFromSuperview() } } }
extension UIImageView{ func blurImage() { let blurEffect = UIBlurEffect(style: UIBlurEffectStyle.Dark) let blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.frame = self.bounds blurEffectView.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] self.addSubview(blurEffectView) } }
blurredBackground.frame = self.view.bounds blurredBackground.blurImage() self.view.addSubview(self.blurredBackground)
var darkBlur:UIBlurEffect = UIBlurEffect() if darkBlur = UIBlurEffect(style: UIBlurEffectStyle.prominent) } else { darkBlur = UIBlurEffect(style: UIBlurEffectStyle.dark) } let blurView = UIVisualEffectView(effect: darkBlur) blurView.frame = self.view.frame blurView.autoresizingMask = [.flexibleWidth, .flexibleHeight] view.addSubview(blurView)
func snapShotImage() -> UIImage { UIGraphicsBeginImageContext(self.frame.size) if let context = UIGraphicsGetCurrentContext() { self.layer.renderInContext(context) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } return UIImage() }
private func bluredImage(view:UIView, radius:CGFloat = 1) -> UIImage { let image = view.snapShotImage() if let source = image.CGImage { let context = CIContext(options: nil) let inputImage = CIImage(CGImage: source) let clampFilter = CIFilter(name: "CIAffineClamp") clampFilter?.setDefaults() clampFilter?.setValue(inputImage, forKey: kCIInputImageKey) if let clampedImage = clampFilter?.valueForKey(kCIOutputImageKey) as? CIImage { let explosureFilter = CIFilter(name: "CIExposureAdjust") explosureFilter?.setValue(clampedImage, forKey: kCIInputImageKey) explosureFilter?.setValue(-1.0, forKey: kCIInputEVKey) if let explosureImage = explosureFilter?.valueForKey(kCIOutputImageKey) as? CIImage { let filter = CIFilter(name: "CIGaussianBlur") filter?.setValue(explosureImage, forKey: kCIInputImageKey) filter?.setValue("\(radius)", forKey:kCIInputRadiusKey) if let result = filter?.valueForKey(kCIOutputImageKey) as? CIImage { let bounds = UIScreen.mainScreen().bounds let cgImage = context.createCGImage(result, fromRect: bounds) let returnImage = UIImage(CGImage: cgImage) return returnImage } } } } return UIImage() }
UIImage *effectImage = [image applyExtraLightEffect]; self.imageView.image = effectImage;
public extension UIView { @discardableResult public func addBlur(style: UIBlurEffectStyle = .extraLight) -> UIVisualEffectView { let blurEffect = UIBlurEffect(style: style) let blurBackground = UIVisualEffectView(effect: blurEffect) addSubview(blurBackground) blurBackground.translatesAutoresizingMaskIntoConstraints = false blurBackground.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = true blurBackground.topAnchor.constraint(equalTo: topAnchor).isActive = true blurBackground.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true blurBackground.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true return blurBackground } }
let blurEffect = UIBlurEffect(style: .ExtraLight) let blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.frame = self.view.frame self.view.insertSubview(blurEffectView, atIndex: 0)
let alert = UIAlertController(title: "Some Title", message: "Enter a text", preferredStyle: .alert) alert.addTextField { (textField) in textField.text = "Some default text" } alert.addAction(UIAlertAction(title: "OK", style: .default, handler: { [weak alert] (_) in let textField = alert.textFields![0] print("Text field: \(textField.text)") })) self.present(alert, animated: true, completion: nil)
var alert = UIAlertController(title: "Some Title", message: "Enter a text", preferredStyle: .Alert) alert.addTextFieldWithConfigurationHandler({ (textField) -> Void in textField.text = "Some default text." }) alert.addAction(UIAlertAction(title: "OK", style: .Default, handler: { [weak alert] (action) -> Void in let textField = alert.textFields![0] as UITextField println("Text field: \(textField.text)") })) self.presentViewController(alert, animated: true, completion: nil)
showInputDialog(title: "Add number", subtitle: "Please enter the new number below.", actionTitle: "Add", cancelTitle: "Cancel", inputPlaceholder: "New number", inputKeyboardType: .numberPad) { (input:String?) in print("The new number is \(input ?? "")") }
extension UIViewController { func showInputDialog(title:String? = nil, subtitle:String? = nil, actionTitle:String? = "Add", cancelTitle:String? = "Cancel", inputPlaceholder:String? = nil, inputKeyboardType:UIKeyboardType = UIKeyboardType.default, cancelHandler: ((UIAlertAction) -> Swift.Void)? = nil, actionHandler: ((_ text: String?) -> Void)? = nil) { let alert = UIAlertController(title: title, message: subtitle, preferredStyle: .alert) alert.addTextField { (textField:UITextField) in textField.placeholder = inputPlaceholder textField.keyboardType = inputKeyboardType } alert.addAction(UIAlertAction(title: actionTitle, style: .destructive, handler: { (action:UIAlertAction) in guard let textField = alert.textFields?.first else { actionHandler?(nil) return } actionHandler?(textField.text) })) alert.addAction(UIAlertAction(title: cancelTitle, style: .cancel, handler: cancelHandler)) self.present(alert, animated: true, completion: nil) } }
NSLayoutConstraint.deactivateConstraints(constraintsA) NSLayoutConstraint.activateConstraints(constraintsB)
-(void)viewWillLayoutSubviews{ [super viewWillLayoutSubviews]; self.myLittleConstraint.active = NO; }
override func viewDidLoad() { super.viewDidLoad() let url:NSURL = NSBundle.mainBundle().URLForResource("soundName", withExtension: "mp3")! do { player = try AVAudioPlayer(contentsOfURL: url, fileTypeHint: nil) } catch _{ return } bgMusic.numberOfLoops = 1 bgMusic.prepareToPlay() if (Data.backgroundMenuPlayed == 0){ player.play() Data.backgroundMenuPlayed = 1 } }
import AVFoundation var player: AVAudioPlayer? func playSound() { let url = NSBundle.mainBundle().URLForResource("soundName", withExtension: "mp3")! do { player = try AVAudioPlayer(contentsOfURL: url) guard let player = player else { return } player.prepareToPlay() player.play() } catch let error as NSError { print(error.description) } }
import AVFoundation var player: AVAudioPlayer? func playSound() { guard let url = Bundle.main.url(forResource: "soundName", withExtension: "mp3") else { return } do { try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback) try AVAudioSession.sharedInstance().setActive(true) let player = try AVAudioPlayer(contentsOf: url) player.play() } catch let error { print(error.localizedDescription) } }
import AVFoundation var player: AVAudioPlayer? func playSound() { guard let url = Bundle.main.url(forResource: "soundName", withExtension: "mp3") else { return } do { try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default) try AVAudioSession.sharedInstance().setActive(true) player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileType.mp3.rawValue) /* iOS 10 and earlier require the following line: player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileTypeMPEGLayer3) */ guard let player = player else { return } player.play() } catch let error { print(error.localizedDescription) } }
import AVFoundation var player: AVAudioPlayer? func playSound() { guard let url = Bundle.main.url(forResource: "soundName", withExtension: "mp3") else { print("url not found") return } do { try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback) try AVAudioSession.sharedInstance().setActive(true) player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileTypeMPEGLayer3) player!.play() } catch let error as NSError { print("error: \(error.localizedDescription)") } }
func playSound() { guard let url = Bundle.main.url(forResource: "soundName", withExtension: "mp3") else { print("url not found") return } do { try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback) try AVAudioSession.sharedInstance().setActive(true) player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileType.mp3.rawValue) player!.play() } catch let error as NSError { print("error: \(error.localizedDescription)") } }
import AVFoundation var player = AVAudioPlayer() @IBAction func notePressed(_ sender: UIButton) { print(sender.tag) let path = Bundle.main.path(forResource: "note\(sender.tag)", ofType : "wav")! let url = URL(fileURLWithPath : path) do { player = try AVAudioPlayer(contentsOf: url) player.play() } catch { print ("There is an issue with this code!") } }
import AVFoundation var myAudio: AVAudioPlayer! let path = Bundle.main.path(forResource: "example", ofType: "mp3")! let url = URL(fileURLWithPath: path) do { let sound = try AVAudioPlayer(contentsOf: url) myAudio = sound sound.play() } catch { } if myAudio != nil { myAudio.stop() myAudio = nil }
var player: AVAudioPlayer? let path = Bundle.main.path(forResource: "note\(sender.tag)", ofType: "wav") let url = URL(fileURLWithPath: path ?? "") do { player = try AVAudioPlayer(contentsOf: url) player?.play() } catch let error { print(error.localizedDescription) }
func playSound(_ buttonTag : Int){ let path = Bundle.main.path(forResource: "note\(buttonTag)", ofType : "wav")! let url = URL(fileURLWithPath : path) do{ soundEffect = try AVAudioPlayer(contentsOf: url) soundEffect?.play() }catch{ print ("file could not be loaded or other error!") } }
guard let url = Bundle.main.url(forResource: "ring", withExtension: "mp3") else { return } do { try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback) try AVAudioSession.sharedInstance().setActive(true) player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileType.mp3.rawValue) guard let player = player else { return } player.play() }catch let error{ print(error.localizedDescription) }
var player: AVAudioPlayer? override func viewDidLoad() { super.viewDidLoad() } @IBAction func notePressed(_ sender: UIButton) { guard let url = Bundle.main.url(forResource: "note1", withExtension: "wav") else { return } do { try AVAudioSession.sharedInstance().setCategory((AVAudioSession.Category.playback), mode: .default, options: []) try AVAudioSession.sharedInstance().setActive(true) player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileType.wav.rawValue) /* iOS 10 and earlier require the following line: player = try AVAudioPlayer(contentsOf: url, fileTypeHint: AVFileTypeMPEGLayer3) *// guard let player = player else { return } player.play() } catch let error { print(error.localizedDescription) } }
let alert = UIAlertController(title: "Title", message: "Message", preferredStyle: UIAlertControllerStyle.Alert) alert.addAction(UIAlertAction(title: "Okay", style: UIAlertActionStyle.Default, handler: {self in println("Foo")})
alert.addAction(UIAlertAction(title: "Okay", style: UIAlertActionStyle.Default, handler: {(alert: UIAlertAction!) in println("Foo")}))
func someHandler(alert: UIAlertAction!) { } alert.addAction(UIAlertAction(title: "Okay", style: UIAlertActionStyle.Default, handler: someHandler))
let alertController = UIAlertController(title: "iOScreator", message: "Hello, world!", preferredStyle: UIAlertControllerStyle.Alert) alertController.addAction(UIAlertAction(title: "Dismiss", style: UIAlertActionStyle.Destructive,handler: { action in self.pressed() })) func pressed() { print("you pressed") }
let alertController = UIAlertController(title: "iOScreator", message: "Hello, world!", preferredStyle: UIAlertControllerStyle.Alert) alertController.addAction(UIAlertAction(title: "Dismiss", style: UIAlertActionStyle.Destructive,handler: { action in print("pressed") }))
let actionSheetController = UIAlertController (title: "My Action Title", message: "", preferredStyle: UIAlertControllerStyle.ActionSheet) actionSheetController.addAction(UIAlertAction(title: "Cancel", style: UIAlertActionStyle.Cancel, handler: nil)) actionSheetController.addAction(UIAlertAction(title: "Save", style: UIAlertActionStyle.Default, handler: { (actionSheetController) -> Void in print("handle Save action...") })) actionSheetController.addAction(UIAlertAction(title: "Discard", style: UIAlertActionStyle.Default, handler: { (actionSheetController) -> Void in print("handle Discard action ...") })) presentViewController(actionSheetController, animated: true, completion: nil)
alert.addAction(UIAlertAction(title: "Okay", style: .default, handler: { _ in print("Foo") } ))
let sayinghi = UIAlertAction(title: "More", style: UIAlertActionStyle.Default, handler: { action in self.sayhi()})
@IBAction func sayhi(sender: AnyObject) { let myAlert = UIAlertController(title: "Alert", message:"sup", preferredStyle: UIAlertControllerStyle.Alert); let okAction = UIAlertAction(title: "OK", style: UIAlertActionStyle.Default, handler:nil) let sayhi = UIAlertAction(title: "say hi", style: UIAlertActionStyle.Default, handler: { action in self.sayhi()}) myAlert.addAction(okAction); myAlert.addAction(sayhi); self.presentViewController(myAlert, animated: true, completion: nil) } func sayhi(){ print("hello") }
let alert = UIAlertController(title: "title", message: "message", preferredStyle: UIAlertControllerStyle.alert) alert.addAction(UIAlertAction(title: "Ok", style: UIAlertActionStyle.default, handler: self.finishAlert)) self.present(alert, animated: true, completion: nil)
let alert=UIAlertController(title:"someAlert", message: "someMessage", preferredStyle:UIAlertControllerStyle.alert ) alert.addAction(UIAlertAction(title: "ok", style: UIAlertActionStyle.default, handler: { _ in print("FOO ") })) present(alert, animated: true, completion: nil)
let alertController = UIAlertController(title:"Title", message: "Message", preferredStyle:.alert) let Action = UIAlertAction.init(title: "Ok", style: .default) { (UIAlertAction) in } alertController.addAction(Action) self.present(alertController, animated: true, completion: nil)
UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"Title" message:@"Message" preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *OK = [UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) { }]; [alertController addAction:OK]; [self presentViewController:alertController animated:YES completion:nil];
target pod ... pod ... pod ... end target pod ... end
source platform :ios, ‚Äò9.0‚Äô use_frameworks! inhibit_all_warnings! target pod end target pod end
protocol ExampleProtocol { var simpleDescription: String { get set } mutating func adjust() } class SimpleClass: ExampleProtocol { var simpleDescription: String = "A very simple class." var anotherProperty: Int = 69105 func adjust() { simpleDescription += " Now 100% adjusted." } } var a = SimpleClass() a.adjust() let aDescription = a.simpleDescription struct SimpleStructure: ExampleProtocol { var simpleDescription: String = "A simple structure" mutating func adjust() { simpleDescription += " (adjusted)" } } var b = SimpleStructure() b.adjust() let bDescription = b.simpleDescription enum SimpleEnum: ExampleProtocol { case Base var simpleDescription: String { get { return "A Simple Enum" } set { newValue } } mutating func adjust() { self.simpleDescription += ", adjusted" } } var c = SimpleEnum.Base c.adjust() let cDescription = c.simpleDescription
protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } enum ExampleEnum : ExampleProtocol { case Base, Adjusted var simpleDescription: String { return self.getDescription() } func getDescription() -> String { switch self { case .Base: return "A simple description of enum" case .Adjusted: return "Adjusted description of enum" } } mutating func adjust() { self = ExampleEnum.Adjusted } } var c = ExampleEnum.Base c.adjust() let cDescription = c.simpleDescription
enum SimpleEnumeration: ExampleProtocol { case Basic, Adjusted var description: String { switch self { case .Basic: return "A simple Enumeration" case .Adjusted: return "A simple Enumeration [adjusted]" } } mutating func adjust() { self = .Adjusted } } var c = SimpleEnumeration.Basic c.description c.adjust() c.description
enum SimpleEnumeration: String, ExampleProtocol { case Basic = "A simple enumeration", Adjusted = "A simple enumeration (adjusted)" var simpleDescription: String { get { return self.toRaw() } } mutating func adjust() { self = .Adjusted } } var c = SimpleEnumeration.Basic c.adjust() let cDescription = c.simpleDescription
mutating func adjust() { switch self { case .Basic: self = .Adjusted default: self = .Basic } }
enum ProtoEnumeration : ExampleProtocol { case One(String) case Two(String) var simpleDescription: String { get { switch self { case let .One(desc): return desc case let .Two(desc): return desc } } } mutating func adjust() { switch self { case let .One(desc): self = .One(desc + ", adjusted 1") case let .Two(desc): self = .Two(desc + ", adjusted 2") } } } var p = ProtoEnumeration.One("test") p.simpleDescription p.adjust() p.simpleDescription
enum ProtocolEnum: ExampleProtocol { case on, off var simpleDescription: String { switch self { case .on: return "Switch is ON" case .off: return "Switch is OFF" } } mutating func adjust() { switch self { case .on: self = off case .off: self = on } } } var c = ProtocolEnum.on c.simpleDescription c.adjust() let cDescription = c.simpleDescription
enum SimpleEnum: ExampleProtocol { case Foo, Bar var simpleDescription: String { get { let value = self == .Foo ? "Foo" : "Bar" return "A simple \(value) enum." } } mutating func adjust() { self = self == .Foo ? .Bar : .Foo } }
protocol ICanWalk { var description: String { get } mutating func stepIt() } enum TwoStepsForwardThreeStepsBack: Int, ICanWalk { case Base = 0, Step1, Step2 var description: String { return "Step \(self.rawValue)" } mutating func stepIt() { if let nextStep = TwoStepsForwardThreeStepsBack( rawValue: self.rawValue + 1 ) { self = nextStep } else { self = TwoStepsForwardThreeStepsBack.Base } } }
protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } enum Seat: ExampleProtocol { case WindowSeat, MiddleSeat, AisleSeat var simpleDescription : String { switch self { case .WindowSeat: return "Window Seat" case .MiddleSeat: return "Middle Seat" case .AisleSeat: return "Aisle Seat" } } mutating func adjust() { switch self { case .WindowSeat: self = .MiddleSeat case .MiddleSeat: self = . AisleSeat case .AisleSeat: self = .WindowSeat } } } var seat = Seat.MiddleSeat print(seat.simpleDescription) seat.adjust() print(seat.simpleDescription)
enum SimpleEnum: ExampleProtocol { case Base, Adjusted var simpleDescription: String { get { var description = "A simple enum." switch self { case .Base: return description case .Adjusted: return description + " - [adjusted]" } } } mutating func adjust() { self = SimpleEnum.Adjusted } } var simpleEnum = SimpleEnum.Base simpleEnum.adjust() simpleEnum.simpleDescription
enum SimpleEnum: ExampleProtocol { case Basic(String), Adjusted(String) init() { self = SimpleEnum.Basic("A simple Enum") } var simpleDescription: String { get { switch self { case let .Basic(string): return string case let .Adjusted(string): return string } } } mutating func adjust() { self = SimpleEnum.Adjusted("full adjusted") } } var c = SimpleEnum() c.adjust() let cDescription = c.simpleDescription
protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } enum SimpleEnum: ExampleProtocol { case Simple case Adjusted var simpleDescription: String { switch self { case .Simple: return "A simple enumeration" case .Adjusted: return "A simple enumeration somewhat changed." } } mutating func adjust() { self = .Adjusted } mutating func restore() { self = .Simple } } var d: SimpleEnum = .Simple d.simpleDescription d.adjust() d.simpleDescription d.restore() d.simpleDescription
enum SimpleEnum: ExampleProtocol { case Default, Adjusted init() { self = .Default } var simpleDescription: String { get { return "\(self) Value" }} mutating func adjust() { self = .Adjusted } } var simpleEnum = SimpleEnum() simpleEnum.adjust() let adjustedSimple = simpleEnum.simpleDescript
protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } indirect enum EnumWithDescription: ExampleProtocol { case option1(EnumWithDescription?) case option2(EnumWithDescription?) var simpleDescription: String { return "Selected " + getDescription() } internal func getDescription() -> String { var currentValue: String let previousValue : EnumWithDescription? switch self { case .option1(let previous): currentValue = "1" previousValue = previous case .option2(let previous): currentValue = "2" previousValue = previous } if let adjustedFrom = previousValue?.getDescription() { return "\(currentValue) adjusted from \(adjustedFrom)" } else { return "\(currentValue)" } } mutating func adjust() { switch self { case .option1: self = .option2(self) case .option2: self = .option1(self) } } } var d = EnumWithDescription.option1(nil) d.simpleDescription d.adjust() d.adjust() d.simpleDescription
enum SimpleEnum : ExampleProtocol { case Desc(String) init() { self = Desc("a simple enum") } var simpleDescription:String { get { return (Mirror(reflecting: self).children.first!.value as? String)! } } mutating func adjust() { self = SimpleEnum.Desc(self.desc + " adjusted") } } var e = SimpleEnum() e.simpleDescription e.adjust() e.simpleDescription
var threeDoubles = [Double](count: 3, repeatedValue: 0.0)
var threeDoubles = [Double](repeating: 0.0, count: 3)
var threeDoubles = [Double]( repeating: 0.0, count: 3 )
extension CMTime { var durationText:String { let totalSeconds = CMTimeGetSeconds(self) let hours:Int = Int(totalSeconds / 3600) let minutes:Int = Int(totalSeconds % 3600 / 60) let seconds:Int = Int(totalSeconds % 60) if hours > 0 { return String(format: "%i:%02i:%02i", hours, minutes, seconds) } else { return String(format: "%02i:%02i", minutes, seconds) } } }
let rem = 2.5.truncatingRemainder(dividingBy: 1.1) print(rem)
let totalSeconds = CMTimeGetSeconds(self) let hours = Int(totalSeconds / 3600) let minutes = Int((totalSeconds.truncatingRemainder(dividingBy: 3600)) / 60) let seconds = Int(totalSeconds.truncatingRemainder(dividingBy: 60))
let totalSeconds = Int(CMTimeGetSeconds(self)) let totalSeconds = lrint(CMTimeGetSeconds(self))
let hours = totalSeconds / 3600 let minutes = (totalSeconds % 3600) / 60 let seconds = totalSeconds % 60
infix operator %% /** * Brings back simple modulo syntax (was removed in swift 3) * Calculates the remainder of expression1 divided by expression2 * The sign of the modulo result matches the sign of the dividend (the first number). For example, -4 % 3 and -4 % -3 both evaluate to -1 * EXAMPLE: * print(12 %% 5) * print(4.3 %% 2.1) * print(4 %% 4) * NOTE: The first print returns 2, rather than 12/5 or 2.4, because the modulo (%) operator returns only the remainder. The second trace returns 0.0999999999999996 instead of the expected 0.1 because of the limitations of floating-point accuracy in binary computing. * NOTE: Int * NOTE: there is also .remainder which supports returning negatives as oppose to truncatingRemainder (aka the old %) which returns only positive. */ public func %% (left:CGFloat, right:CGFloat) -> CGFloat { return left.truncatingRemainder(dividingBy: right) }
let minutes = Int(floor(totalSeconds / 60)) let seconds = Int(totalSeconds) % 60
import Foundation var error: NSError? let jsonData: NSData = let jsonDict = NSJSONSerialization.JSONObjectWithData(jsonData, options: nil, error: &error) as NSDictionary
var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: false)
func connection(didReceiveResponse: NSURLConnection!, didReceiveResponse response: NSURLResponse!) { self.data = NSMutableData() }
func connection(connection: NSURLConnection!, didReceiveData data: NSData!) { self.data.appendData(data) }
func connectionDidFinishLoading(connection: NSURLConnection!) { var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary if jsonResult.count>0 && jsonResult["results"].count>0 { var results: NSArray = jsonResult["results"] as NSArray self.tableData = results self.appsTableView.reloadData() } }
let obj:[String:AnyObject] = [ "array": [JSON.null, false, 0, "",[],[:]], "object":[ "null": JSON.null, "bool": true, "int": 42, "double": 3.141592653589793, "string": "a Œ±\tÂºæ\n™ö≤", "array": [], "object": [:] ], "url":"http: ] let json = JSON(obj) json.toString()
json["object"]["null"].asNull json["object"]["string"].asString json["array"][0].asNull json["array"][1].asBool
if let b = json["noexistent"][1234567890]["entry"].asBool { } else { let e = json["noexistent"][1234567890]["entry"].asError println(e) }
class MyJSON : JSON { init(_ obj:AnyObject){ super.init(obj) } init(_ json:JSON) { super.init(json) } var null :NSNull? { return self["null"].asNull } var bool :Bool? { return self["bool"].asBool } var int :Int? { return self["int"].asInt } var double:Double? { return self["double"].asDouble } var string:String? { return self["string"].asString } }
let myjson = MyJSON(obj) myjson.object.null myjson.object.bool myjson.object.int myjson.object.double myjson.object.string
func nsdataToJSON(data: NSData) -> AnyObject? { do { return try NSJSONSerialization.JSONObjectWithData(data, options: .MutableContainers) } catch let myJSONError { print(myJSONError) } return nil } func jsonToNSData(json: AnyObject) -> NSData?{ do { return try NSJSONSerialization.dataWithJSONObject(json, options: NSJSONWritingOptions.PrettyPrinted) } catch let myJSONError { print(myJSONError) } return nil; }
{ "employees": [ { "firstName": "John", "lastName": "Doe", "age": 26 }, { "firstName": "Anna", "lastName": "Smith", "age": 30 }, { "firstName": "Peter", "lastName": "Jones", "age": 45 }] }
class Employee : ROJSONObject { required init() { super.init(); } required init(jsonData:AnyObject) { super.init(jsonData: jsonData) } var firstname:String { return Value<String>.get(self, key: "firstName") } var lastname:String { return Value<String>.get(self, key: "lastName") } var age:Int { return Value<Int>.get(self, key: "age") } }
class EmployeeContainer : ROJSONObject { required init() { super.init(); } required init(jsonData:AnyObject) { super.init(jsonData: jsonData) } lazy var employees:[Employee] = { return Value<[Employee]>.getArray(self, key: "employees") as [Employee] }() }
var baseWebservice:BaseWebservice = BaseWebservice(); var urlToJSON = "http: var callbackJSON = {(status:Int, employeeContainer:EmployeeContainer) -> () in for employee in employeeContainer.employees { println("Firstname: \(employee.firstname) Lastname: \(employee.lastname) age: \(employee.age)") } } baseWebservice.get(urlToJSON, callback:callbackJSON)
Firstname: John Lastname: Doe age: 26 Firstname: Anna Lastname: Smith age: 30 Firstname: Peter Lastname: Jones age: 45
let parser = JSONParser(jsonData) if let handle = parser.getString("other.nicknames[0]") { }
let fileUrl: NSURL = NSBundle.mainBundle().URLForResource("JsonFile", withExtension: "json")! let jsonData: NSData = NSData(contentsOfURL: fileUrl)!
var mURL = NSURL(string: "http: if mURL == nil{ println("You are stupid") return } var request = NSURLRequest(URL: mURL!) NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue(), completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -> Void in if data != nil { var mJSON = JSON(data: data!) if let current_conditions = mJSON["weather"][0]["description"].string{ println("Current conditions: " + current_conditions) } else { println("MORON!") } if let current_temperature = mJSON["main"]["temp"].double{ println("Temperature: "+ String(format:"%.f", current_temperature) + "¬∞C" } else { println("MORON!") } } })
if let path = Bundle(for: BPPView.self).path(forResource: jsonFileName, ofType: "json") { do { let data = try Data(contentsOf: URL(fileURLWithPath: path), options: NSData.ReadingOptions.mappedIfSafe) let json = try JSONSerialization.jsonObject(with: data, options: .allowFragments) self.levels = Mapper<Level>().mapArray(JSONArray: (json as! [[String : Any]]))! print(levels.count) } catch let error as NSError { print(error.localizedDescription) } } else { print("Invalid filename/path.") }
import UIKit import ObjectMapper class Level: Mappable { var levelName = "" var levelItems = [LevelItem]() required init?(map: Map) { } func mapping(map: Map) { levelName <- map["levelName"] levelItems <- map["levelItems"] } }
import UIKit import ObjectMapper class LevelItem: Mappable { var frontBackSide = BPPFrontBack.Undefined var fullImageName = "" var fullImageSelectedName = "" var bodyParts = [BodyPart]() required init?(map: Map) { } func mapping(map: Map) { frontBackSide <- map["frontBackSide"] fullImageName <- map["fullImageName"] fullImageSelectedName <- map["fullImageSelectedName"] bodyParts <- map["bodyParts"] }}
let parsedResult: [String: AnyObject] do { parsedResult = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as! [String:AnyObject] } catch { }
@IBOutlet weak var imagecollectionview: UICollectionView! lazy var data = NSMutableData() var dictdata : NSMutableDictionary = NSMutableDictionary() override func viewDidLoad() { super.viewDidLoad() startConnection() startNewConnection() } func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { return dictdata.count } func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -> UICollectionViewCell { let cell = collectionView.dequeueReusableCellWithReuseIdentifier("CustomcellCollectionViewCell", forIndexPath: indexPath) as! CustomcellCollectionViewCell cell.name.text = dictdata.valueForKey("Data")?.valueForKey("location") as? String let url = NSURL(string: (dictdata.valueForKey("Data")?.valueForKey("avatar_url") as? String)! ) LazyImage.showForImageView(cell.image, url:"URL return cell } func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -> CGSize { let kWhateverHeightYouWant = 100 return CGSizeMake(self.view.bounds.size.width/2, CGFloat(kWhateverHeightYouWant)) } func startNewConnection() { let url: URL = URL(string: "YOUR URL" as String)! let session = URLSession.shared let request = NSMutableURLRequest(url: url as URL) request.httpMethod = "GET" request.cachePolicy = NSURLRequest.CachePolicy.reloadIgnoringCacheData let task = session.dataTask(with: request as URLRequest) { ( data, response, error) in guard let _:NSData = data as NSData?, let _:URLResponse = response, error == nil else { print("error") return } let jsonString = NSString(data: data!, encoding:String.Encoding.utf8.rawValue) as! String } task.resume() } func startConnection(){ let urlPath: String = "your URL" let url: NSURL = NSURL(string: urlPath)! var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: false)! connection.start() } func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ self.data.appendData(data) } func buttonAction(sender: UIButton!){ startConnection() } func connectionDidFinishLoading(connection: NSURLConnection!) { do { let JSON = try NSJSONSerialization.JSONObjectWithData(self.data, options:NSJSONReadingOptions(rawValue: 0)) guard let JSONDictionary :NSDictionary = JSON as? NSDictionary else { print("Not a Dictionary") return } print("JSONDictionary! \(JSONDictionary)") dictdata.setObject(JSONDictionary, forKey: "Data") imagecollectionview.reloadData() } catch let JSONError as NSError { print("\(JSONError)") } }
struct Person { let name: String? let age: Int? } let mapper = JsonSwiftson(json: "{ \"name\": \"Peter\", \"age\": 41 }") let person: Person? = Person( name: mapper["name"].map(), age: mapper["age"].map() )
let miadata = NSData(contentsOfURL: NSURL(string: "https: do{ let MyData = try NSJSONSerialization.JSONObjectWithData(miadata!, options: NSJSONReadingOptions.MutableContainers) as? NSArray print(".........\(MyData)") } catch let error as NSError{ print(error.description) }
import UIKit let jsonString = "{\"name\": \"John Doe\", \"phone\":123456}" let data = jsonString.data(using: .utf8) var jsonObject: Any do { jsonObject = try JSONSerialization.jsonObject(with: data!) as Any if let obj = jsonObject as? NSDictionary { print(obj["name"]) } } catch { print("error") }
struct Post: Codable { let userId: Int let id: Int let title: String let body: String }
URLSession.shared.dataTask(with: URL(string: "https: guard let response = response as? HTTPURLResponse else { print("HTTPURLResponse error") return } guard 200 ... 299 ~= response.statusCode else { print("Status Code error \(response.statusCode)") return } guard let data = data else { print("No Data") return } let posts = try! JSONDecoder().decode([Post].self, from: data) print(posts) }.resume()
import UIKit class ViewController3: UIViewController,UITableViewDelegate,UITableViewDataSource { @IBOutlet var tableView: UITableView! var displayDatasssss = [displyDataClass]() override func viewDidLoad() { super.viewDidLoad() } func numberOfSections(in tableView: UITableView) -> Int { return 1 } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return displayDatasssss.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "TableViewCell1") as! TableViewCell1 cell.label1.text = displayDatasssss[indexPath.row].email return cell } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } @IBAction func gettt(_ sender: Any) { let url = "http: var request = URLRequest(url: URL(string: url)!) request.httpMethod = "GET" let configuration = URLSessionConfiguration.default let session = URLSession(configuration: configuration, delegate: nil, delegateQueue: OperationQueue.main) let task = session.dataTask(with: request){(data, response,error)in if (error != nil){ print("Error") } else{ do{ let fetchData = try JSONSerialization.jsonObject(with: data!, options: .mutableLeaves) as! NSArray for eachData in fetchData { let eachdataitem = eachData as! [String : Any] let name = eachdataitem["name"]as! String let username = eachdataitem["username"]as! String let email = eachdataitem["email"]as! String self.displayDatasssss.append(displyDataClass(name: name, username: username,email : email)) } self.tableView.reloadData() } catch{ print("Error 2") } } } task.resume() } } class displyDataClass { var name : String var username : String var email : String init(name : String,username : String,email :String) { self.name = name self.username = username self.email = email } }
import UIKit class ViewController3: UIViewController,UITableViewDelegate,UITableViewDataSource { @IBOutlet var tableView: UITableView! var displayDatasssss = [displyDataClass]() override func viewDidLoad() { super.viewDidLoad() } func numberOfSections(in tableView: UITableView) -> Int { return 1 } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return displayDatasssss.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "TableViewCell1") as! TableViewCell1 cell.label1.text = displayDatasssss[indexPath.row].email return cell } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } @IBAction func gettt(_ sender: Any) { let url = "http: var request = URLRequest(url: URL(string: url)!) request.httpMethod = "GET" let configuration = URLSessionConfiguration.default let session = URLSession(configuration: configuration, delegate: nil, delegateQueue: OperationQueue.main) let task = session.dataTask(with: request){(data, response,error)in if (error != nil){ print("Error") } else{ do{ let fetchData = try JSONSerialization.jsonObject(with: data!, options: .mutableLeaves) as! [String: AnyObject] let name = fetchData["name"]as! String let username = fetchData["username"]as! String let email = fetchData["email"]as! String self.displayDatasssss.append(displyDataClass(name: name, username: username,email : email)) self.tableView.reloadData() } catch{ print("Error 2") } } } task.resume() } } class displyDataClass { var name : String var username : String var email : String init(name : String,username : String,email :String) { self.name = name self.username = username self.email = email } }
struct Point : Printable { var x = 0 var y = 0 var description : String { return "(\(x), \(y))" } func toString() -> String { return description } }
var p = Point(x: 10, y: 20) println(p) println("\(p)") println(p.description) println("\(p.description)")
var description: String { return "description here" }
struct Animal : CustomStringConvertible { let type : String var description: String { return type } } struct Farm : CustomStringConvertible { let name : String let animals : [Animal] var description: String { return "\(name) is a \(self.dynamicType) with \(animals.count) animal(s)." } }
let oldMajor = Animal(type: "Pig") let boxer = Animal(type: "Horse") let muriel = Animal(type: "Goat") let orwellsFarm = Farm(name: "Animal Farm", animals: [oldMajor, boxer, muriel])
struct MyType: Printable { var name = "Untitled" var description: String { return "MyType: \(name)" } } let value = MyType() println("Created a \(value)")
struct MyType: CustomStringConvertible { var name = "Untitled" var description: String { return "MyType: \(name)" } } let value = MyType() println("Created a \(value)")
typedef void (^CompletionBlock) (NSString* completionReason);
func completionFunction(NSString* completionReason){ } typealias CompletionBlock = completionFunction
typealias CompletionBlock = ( completionName : NSString, flag : Int) -> ()
typealias CompletionBlock = (NSString?) -> Void typealias CompletionBlock = (result: NSData?, error: NSError?) -> Void
var completion: CompletionBlock = { reason in print(reason) } var completion: CompletionBlock = { result, error in print(error) }
typealias closureType = (inputTypes) -> (outputType)
let calendar = NSCalendar.currentCalendar() let date1 = calendar.startOfDayForDate(firstDate) let date2 = calendar.startOfDayForDate(secondDate) let flags = NSCalendarUnit.Day let components = calendar.components(flags, fromDate: date1, toDate: date2, options: []) components.day
let calendar = Calendar.current let date1 = calendar.startOfDay(for: firstDate) let date2 = calendar.startOfDay(for: secondDate) let components = calendar.dateComponents([.day], from: date1, to: date2)
func daysBetweenDates(startDate: NSDate, endDate: NSDate) -> Int { let calendar = NSCalendar.currentCalendar() let components = calendar.components([.Day], fromDate: startDate, toDate: endDate, options: []) return components.day }
public static func daysBetween(start: Date, end: Date) -> Int { return Calendar.current.dateComponents([.day], from: start, to: end).day! }
let start = "2010-09-01" let end = "2010-09-05" let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd" let startDate:NSDate = dateFormatter.dateFromString(start) let endDate:NSDate = dateFormatter.dateFromString(end) let cal = NSCalendar.currentCalendar() let unit:NSCalendarUnit = .Day let components = cal.components(unit, fromDate: startDate, toDate: endDate, options: nil) println(components)
func daysBetweenDates(startDate: Date, endDate: Date) -> Int { let calendar = Calendar.current let components = calendar.dateComponents([Calendar.Component.day], from: startDate, to: endDate) return components.day! }
extension Date { func years(sinceDate: Date) -> Int? { return Calendar.current.dateComponents([.year], from: sinceDate, to: self).year } func months(sinceDate: Date) -> Int? { return Calendar.current.dateComponents([.month], from: sinceDate, to: self).month } func days(sinceDate: Date) -> Int? { return Calendar.current.dateComponents([.day], from: sinceDate, to: self).day } func hours(sinceDate: Date) -> Int? { return Calendar.current.dateComponents([.hour], from: sinceDate, to: self).hour } func minutes(sinceDate: Date) -> Int? { return Calendar.current.dateComponents([.minute], from: sinceDate, to: self).minute } func seconds(sinceDate: Date) -> Int? { return Calendar.current.dateComponents([.second], from: sinceDate, to: self).second } }
func daysBetweenDates(startDate: Date, endDate: Date) -> Int { let calendar = Calendar.current let components = calendar.components([.day], from: startDate, to: endDate, options: []) return components.day! }
let pickedDate: Date = sender.date let NumOfDays: Int = daysBetweenDates(startDate: pickedDate, endDate: Date()) print("Num of Days: \(NumOfDays)")
extension Date { func daysBetween(date: Date) -> Int { return Date.daysBetween(start: self, end: date) } static func daysBetween(start: Date, end: Date) -> Int { let calendar = Calendar.current let date1 = calendar.startOfDay(for: start) let date2 = calendar.startOfDay(for: end) let a = calendar.dateComponents([.day], from: date1, to: date2) return a.value(for: .day)! } }
let dateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd" let start = dateFormatter.date(from: "2017-01-01")! let end = dateFormatter.date(from: "2018-01-01")! let diff = Date.daysBetween(start: start, end: end)
let now = NSDate() let seventies = NSDate(timeIntervalSince1970: 0) let days = NSCalendar.currentCalendar().components(.CalendarUnitDay, fromDate: seventies, toDate: now, options: nil).day func -(lhs:NSDate, rhs:NSDate) -> DateRange { return DateRange(startDate: rhs, endDate: lhs) } class DateRange { let startDate:NSDate let endDate:NSDate var calendar = NSCalendar.currentCalendar() var days: Int { return calendar.components(.CalendarUnitDay, fromDate: startDate, toDate: endDate, options: nil).day } var months: Int { return calendar.components(.CalendarUnitMonth, fromDate: startDate, toDate: endDate, options: nil).month } init(startDate:NSDate, endDate:NSDate) { self.startDate = startDate self.endDate = endDate } } (now - seventies).months (now - seventies).days
func daysBetweenDates(startDate: NSDate, endDate: NSDate, inTimeZone timeZone: TimeZone? = nil) -> Int { var calendar = Calendar.current if let timeZone = timeZone { calendar.timeZone = timeZone } let dateComponents = calendar.dateComponents([.day], from: startDate.startOfDay, to: endDate.startOfDay) return dateComponents.day! }
var name = txtName.stringValue var dateComponents = NSDateComponents() dateComponents.day = txtDOBDay.integerValue dateComponents.month = txtDOBMonth.integerValue dateComponents.year = txtDOBYear.integerValue let calendar = NSCalendar(identifier: NSCalendarIdentifierGregorian) var birthdate = calendar?.dateFromComponents(dateComponents) let currentDate = NSDate() var durationDateComponents = calendar?.components(NSCalendarUnit.CalendarUnitDay, fromDate: birthdate!, toDate: currentDate, options: nil) let numberOfDaysAlive = durationDateComponents?.day println("\(numberOfDaysAlive!)") txtGreeting.stringValue = "Hello \(name), You have been alive for \(numberOfDaysAlive!) days."
func daysBetweenDates( endDate: Date) -> Int let calendar: Calendar = Calendar.current let date1 = calendar.startOfDay(for: Date()) let date2 = calendar.startOfDay(for: secondDate) return calendar.dateComponents([.day], from: date1, to: date2).day! }
func getFractionalDaysBetweenDates(date1: Date, date2: Date) -> Double { let components = Calendar.current.dateComponents([.day, .hour], from: date1, to: date2) var decimalDays = Double(components.day!) decimalDays += Double(components.hour!) / 24.0 return decimalDays }
func daysUntilDate(endDateComponents: DateComponents) -> Int { let cal = Calendar.current var components = cal.dateComponents([.era, .year, .month, .day], from: NSDate() as Date) let today = cal.date(from: components) let otherDate = cal.date(from: endDateComponents) components = cal.dateComponents([Calendar.Component.day], from: (today! as Date), to: otherDate!) return components.day! }
var examnDate = DateComponents() examnDate.year = 2016 examnDate.month = 12 examnDate.day = 15 let daysCount = daysUntilDate(endDateComponents: examnDate)
public extension Date { public var currentCalendar: Calendar { return Calendar.autoupdatingCurrent } public func daysBetween(_ date: Date) -> Int { let components = currentCalendar.dateComponents([.day], from: self, to: date) return components.day! } }
extension DateComponentsFormatter { func difference(from fromDate: Date, to toDate: Date) -> String? { self.allowedUnits = [.year,.month,.weekOfMonth,.day] self.maximumUnitCount = 1 self.unitsStyle = .full return self.string(from: fromDate, to: toDate) } }
func completeOffset(from date:Date) -> String? { let formatter = DateComponentsFormatter() formatter.unitsStyle = .brief return formatter.string(from: Calendar.current.dateComponents([.year,.month,.day,.hour,.minute,.second], from: date, to: self)) }
extension Date { var daysFromNow: Int { return Calendar.current.dateComponents([.day], from: Date(), to: self).day! } }
extension Date { func daysFromToday() -> Int { return abs(Calendar.current.dateComponents([.day], from: self, to: Date()).day!) } }
func getDateHeader(indexPath: Int) -> String { let formatter2 = DateFormatter() formatter2.dateFormat = "MM-dd-yyyy" var dateDeadline : Date? dateDeadline = formatter2.date(from: arrCompletedDate[indexPath] as! String) let currentTime = dateDeadline?.unixTimestamp let calendar = NSCalendar.current let date = NSDate(timeIntervalSince1970: Double(currentTime!)) if calendar.isDateInYesterday(date as Date) { return "Yesterday" } else if calendar.isDateInToday(date as Date) { return "Today" } else if calendar.isDateInTomorrow(date as Date) { return "Tomorrow" } else { let startOfNow = calendar.startOfDay(for: NSDate() as Date) let startOfTimeStamp = calendar.startOfDay(for: date as Date) let components = calendar.dateComponents([.day], from: startOfNow, to: startOfTimeStamp) let day = components.day! if day < 1 { return "\(abs(day)) days ago" } else { return "In \(day) days" } } }
let calendar = NSCalendar.currentCalendar(); let component1 = calendar.component(.Day, fromDate: fromDate) let component2 = calendar.component(.Day, fromDate: toDate) let difference = component1 - component2
func simpleIndex(ofDate: Date) -> Int { let c = Calendar.current let todayRightNow = Date() let d = c.date(bySetting: .hour, value: 13, of: ofDate) let t = c.date(bySetting: .hour, value: 13, of: todayRightNow) if d == nil || today == nil { print("weird problem simpleIndex return 0 } let r = c.dateComponents([.day], from: today!, to: d!) if let o = r.value(for: .day) { return o } else { print("another weird problem simpleIndex return 0 } }
activityIndicator = [[UIActivityIndicatorView alloc] initWithFrame: CGRectMake(142.00, 212.00, 80.0, 80.0)]; [[self view] addSubview:activityIndicator]; [activityIndicator sizeToFit]; activityIndicator.autoresizingMask = (UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleRightMargin | UIViewAutoresizingFlexibleTopMargin | UIViewAutoresizingFlexibleBottomMargin); activityIndicator.hidesWhenStopped = YES; activityIndicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyleWhiteLarge;
... UIActivityIndicatorView *activityIndicator = [[[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleGray] autorelease]; activityIndicator.transform = CGAffineTransformMakeScale(0.75, 0.75); [self addSubview:activityIndicator];
CGAffineTransform transform = CGAffineTransformMakeScale(1.5f, 1.5f); activityIndicator.transform = transform;
self.activityIndi.transform = CGAffineTransform(scaleX: 3, y: 3)
var activityIndicator = UIActivityIndicatorView() activityIndicator = UIActivityIndicatorView(activityIndicatorStyle: UIActivityIndicatorViewStyle.gray) activityIndicator.frame = CGRect(x: 0, y: 0, width: 50, height: 50) let transform: CGAffineTransform = CGAffineTransform(scaleX: 1.5, y: 1.5) activityIndicator.transform = transform activityIndicator.center = self.view.center activityIndicator.startAnimating() self.view.addSubview(activityIndicator)
extension UIActivityIndicatorView { func scale(factor: CGFloat) { guard factor > 0.0 else { return } transform = CGAffineTransform(scaleX: factor, y: factor) } }
let a:Double = 1.5 let b:String = String(format:"%f", a) print("b: \(b)")
let c:String = String(format:"%.1f", a) print("c: \(c)")
let myDouble = 1.5 let myString = myDouble.description
let myDouble = 1.5 let myDoubleString = String(myDouble)
extension FloatingPoint { func fixedFraction(digits: Int) -> String { return String(format: "%.\(digits)f", self as! CVarArg) } }
extension Formatter { static let number = NumberFormatter() } extension FloatingPoint { func fractionDigits(min: Int = 2, max: Int = 2, roundingMode: NumberFormatter.RoundingMode = .halfEven) -> String { Formatter.number.minimumFractionDigits = min Formatter.number.maximumFractionDigits = max Formatter.number.roundingMode = roundingMode Formatter.number.numberStyle = .decimal return Formatter.number.string(for: self) ?? "" } } 2.12345.fractionDigits() 2.12345.fractionDigits(min: 3, max: 3, roundingMode: .up)
extension Double { func toString() -> String { return String(format: "%.1f",self) } }
var a:Double = 1.5 println("output: \(a.toString())")
let num: Double = 1.5 let str = String(format: "%.2f", num)
let number = 2.4 let string = String(format: "%.2f", number)
func doubleToString(number:Double, numberOfDecimalPlaces:Int) -> String { return String(format:"%."+numberOfDecimalPlaces.description+"f", number) }
let numberString = doubleToStringDecimalPlacesWithDouble(number: x, numberOfDecimalPlaces: 2)
extension Double { func roundToInt() -> Int{ return Int(Darwin.round(self)) }
currentTemp.text = "\(weatherData.tempCelsius.roundToInt())"
self.resultSearchController = ({ let controller = UISearchController(searchResultsController: nil) controller.searchResultsUpdater = self controller.searchBar.delegate = self controller.dimsBackgroundDuringPresentation = false controller.searchBar.sizeToFit() controller.hidesNavigationBarDuringPresentation = false controller.searchBar.placeholder = "Search for song" self.myTableView.tableHeaderView = controller.searchBar return controller })()
Attempting to load the view of a view controller while it is deallocating is not allowed and may result in undefined behavior (<UISearchController: 0x154d39700>)
-(void)dealloc { [searchController.view removeFromSuperview]; }
deinit { self.searchController.view.removeFromSuperview() }
class ViewController: UITableViewController, UISearchResultsUpdating, UISearchBarDelegate { var resultSearchController = UISearchController()
class ViewController: UITableViewController, UISearchResultsUpdating, UISearchBarDelegate { var resultSearchController: UISearchController!
deinit{ if let superView = resultSearchController.view.superview { superView.removeFromSuperview() } }
class SampleClass: UITableViewController, UISearchBarDelegate { private let searchController = UISearchController(searchResultsController: nil) override func viewDidLoad() { super.viewDidLoad() searchController.loadViewIfNeeded() } }
override func viewDidLoad() { super.viewDidLoad() self.navigationItem.rightBarButtonItem = self.editButtonItem() if self.resultSearchController.loadViewIfNeeded() } else { let _ = self.resultSearchController.view } self.resultSearchController = ({ let controller = UISearchController(searchResultsController: nil) controller.searchResultsUpdater = self controller.dimsBackgroundDuringPresentation = false controller.searchBar.sizeToFit() self.tableView.tableHeaderView = controller.searchBar return controller })() self.tableView.reloadData() }
let alertController = UIAlertController(title: "Oops", message:"bla.", preferredStyle: UIAlertControllerStyle.Alert) alertController.addAction(UIAlertAction(title: "Ok", style: UIAlertActionStyle.Default,handler: nil)) self.presentViewController(alertController, animated: true, completion: nil)
deinit { self.searchController?.view.removeFromSuperview() }
func initSearchControl(){ searchController = UISearchController(searchResultsController: nil) if searchController.loadViewIfNeeded() } else { let _ = self.searchController.view } searchController.searchResultsUpdater = self searchController.dimsBackgroundDuringPresentation = false definesPresentationContext = true tableView.tableHeaderView = searchController.searchBar searchController.searchBar.sizeToFit() }
override func viewDidLoad() { super.viewDidLoad() let searchController = UISearchController(searchResultsController: nil) navigationItem.titleView = searchController.searchBar searchController.searchBar.sizeToFit() }
var searchController: UISearchController! override func viewDidLoad() { super.viewDidLoad() searchController = UISearchController(searchResultsController: nil) navigationItem.titleView = searchController.searchBar searchController.searchBar.sizeToFit() }
var resultSearchController: UISearchController! override func viewDidLoad() { super.viewDidLoad() self.resultSearchController = ({ let searchController = UISearchController(searchResultsController: nil) searchController.searchResultsUpdater = self searchController.dimsBackgroundDuringPresentation = false searchController.searchBar.sizeToFit() return searchController })() self.tableView.tableHeaderView = self.resultSearchController.searchBar self.tableView.reloadData() }
var tags = ["this", "is", "cool"] tags[1..<3] var someTags: [String] = tags[1..<3]
var tags = ["this", "is", "cool"] tags[1..<3] var someTags: Slice<String> = tags[1..<3] var someTagsArray: [String] = Array(someTags)
var tags = ["this", "is", "cool"] var someTags: [String] = Array(tags[1..<3]) println("someTags: \(someTags)")
let tags = ["this", "is", "cool"] let someTags: [String] = tags[1..<3].map { $0 }
var tags = ["this", "is", "cool"] var someTags = [String]() someTags += tags[1..<3] println(someTags[0])
var preferredLanguages : NSLocale! let pre = preferredLanguages.displayNameForKey(NSLocaleIdentifier, value: preferredLanguages)
NSLocale.currentLocale().objectForKey(NSLocaleLanguageCode)!
let prefferedLanguage = Locale.preferredLanguages[0] as String print (prefferedLanguage) let arr = prefferedLanguage.components(separatedBy: "-") let deviceLanguage = arr.first print (deviceLanguage)
var preferredLanguage : String = Bundle.main.preferredLocalizations.first!
enum Language: String { case none = "" case en = "English" case fr = "French" case it = "Italian" }
extension Locale { static var enLocale: Locale { return Locale(identifier: "en-EN") } static var currentLanguage: Language? { guard let code = preferredLanguages.first?.components(separatedBy: "-").last else { print("could not detect language code") return nil } guard let rawValue = enLocale.localizedString(forLanguageCode: code) else { print("could not localize language code") return nil } guard let language = Language(rawValue: rawValue) else { print("could not init language from raw value") return nil } print("language: \(code)-\(rawValue)") return language } }
if let currentLanguage = Locale.currentLanguage { print(currentLanguage.rawValue) }
var str = "iOS Developer Tips encoded in Base64" println("Original: \(str)") let utf8str = str.dataUsingEncoding(NSUTF8StringEncoding) let base64Encoded = utf8str.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.fromRaw(0)!) println("Encoded: \(base64Encoded)") let data = NSData(base64EncodedString: base64Encoded, options: NSDataBase64DecodingOptions.fromRaw(0)!) let base64Decoded = NSString(data: data, encoding: NSUTF8StringEncoding) println("Decoded: \(base64Decoded)")
import Foundation let str = "iOS Developer Tips encoded in Base64" println("Original: \(str)") let utf8str = str.dataUsingEncoding(NSUTF8StringEncoding) if let base64Encoded = utf8str?.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0)) { println("Encoded: \(base64Encoded)") if let base64Decoded = NSData(base64EncodedString: base64Encoded, options: NSDataBase64DecodingOptions(rawValue: 0)) .map({ NSString(data: $0, encoding: NSUTF8StringEncoding) }) { println("Decoded: \(base64Decoded)") } }
import UIKit extension String { func fromBase64() -> String? { guard let data = Data(base64Encoded: self) else { return nil } return String(data: data, encoding: .utf8) } func toBase64() -> String { return Data(self.utf8).base64EncodedString() } }
import UIKit extension String { func fromBase64() -> String? { guard let data = NSData(base64EncodedString: self, options: NSDataBase64DecodingOptions(rawValue: 0)) else { return nil } return String(data: data, encoding: NSUTF8StringEncoding) } func toBase64() -> String? { guard let data = self.dataUsingEncoding(NSUTF8StringEncoding) else { return nil } return data.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0)) } }
import UIKit extension String { /** Encode a String to Base64 :returns: */ func toBase64()->String{ let data = self.dataUsingEncoding(NSUTF8StringEncoding) return data!.base64EncodedStringWithOptions(NSDataBase64EncodingOptions(rawValue: 0)) } }
import UIKit extension String { func fromBase64() -> String? { guard let data = Data(base64Encoded: self, options: Data.Base64DecodingOptions(rawValue: 0)) else { return nil } return String(data: data as Data, encoding: String.Encoding.utf8) } func toBase64() -> String? { guard let data = self.data(using: String.Encoding.utf8) else { return nil } return data.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)) } }
let plainData = (plainString as NSString).dataUsingEncoding(NSUTF8StringEncoding) let base64String =plainData.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.fromRaw(0)!) println(base64String)
let decodedData = NSData(base64EncodedString: base64String, options:NSDataBase64DecodingOptions.fromRaw(0)!) let decodedString = NSString(data: decodedData, encoding: NSUTF8StringEncoding) println(decodedString)
extension String { var data: Data { return Data(utf8) } var base64Encoded: Data { return data.base64EncodedData() } var base64Decoded: Data? { return Data(base64Encoded: self) } } extension Data { var string: String? { return String(data: self, encoding: .utf8) } }
let original = "iOS Developer Tips encoded in Base64" let utf8Data = original.data let base64EncodedString = utf8Data.base64EncodedString() let base64EncodedData = utf8Data.base64EncodedData() print("base64EncodedData:", original.base64Encoded) print("base64EncodedString:", original.base64Encoded.string ?? "") print("base64DecodedData:", original.base64Encoded.string?.base64Decoded ?? "") print("base64DecodedString:", original.base64Encoded.string?.base64Decoded?.string ?? "")
extension String { func toBase64() -> String { return Data(self.utf8).base64EncodedString() } func fromBase64() -> String? { guard let data = Data(base64Encoded: self) else { return nil } return String(data: data, encoding: .utf8) } }
let testString = "A test string." let encoded = testString.toBase64() guard let decoded = encoded.fromBase64() else { return }
let base64Encoded = Data("original string".utf8).base64EncodedString()
"abcd1234".data(using: .utf8)?.base64EncodedString()
func conversion(str:NSString) { if let decodedData = NSData(base64EncodedString: str as String, options:NSDataBase64DecodingOptions(rawValue: 0)), let decodedString = NSString(data: decodedData, encoding: NSUTF8StringEncoding) { print(decodedString)
self .convertStringToDictionary(decodedString as String) } }
func convertStringToDictionary(text: String) -> [String:AnyObject]? { if let data = text.dataUsingEncoding(NSUTF8StringEncoding) { do { let json = try NSJSONSerialization.JSONObjectWithData(data, options: []) as? [String:AnyObject] print(json) if let stack = json!["cid"] { customerID = stack as! String print(customerID) } } catch let error as NSError { print(error) } } return nil }
let str = "iOS Developer Tips encoded in Base64" print("Original: \(str)") let utf8str = str.data(using: String.Encoding.utf8) if let base64Encoded = utf8str?.base64EncodedString(options: NSData.Base64EncodingOptions(rawValue: 0)) { print("Encoded: \(base64Encoded)") if let base64Decoded = NSData(base64Encoded: base64Encoded, options: NSData.Base64DecodingOptions(rawValue: 0)) .map({ NSString(data: $0 as Data, encoding: String.Encoding.utf8.rawValue) }) { print("Decoded: \(base64Decoded)!") } }
let bytesToEncode : [UInt8] = [1,2,3] let base64EncodedString = SwiftyBase64.EncodeString(bytesToEncode)
let bytesToEncode : [UInt8] = [1,2,3] let base64EncodedString = SwiftyBase64.EncodeString(bytesToEncode, alphabet:.URLAndFilenameSafe)
let str = "iOS Developer Tips encoded in Base64" print("Original: \(str)") let base64Encoded = str.dataUsingEncoding(NSUTF8StringEncoding)!.base64EncodedStringWithOptions([]) print("Encoded: \(base64Encoded)") let base64DecodedData = NSData(base64EncodedString: base64Encoded, options: [])! var base64DecodedString = String(data: base64DecodedData, encoding: NSUTF8StringEncoding)! print("Decoded: \(base64DecodedString)")
class Employee { var id: Int var firstName: String var lastName: String var dateOfBirth: NSDate? init(id: Int, firstName: String, lastName: String) { self.id = id self.firstName = firstName self.lastName = lastName } }
var array = [Employee]() array.append(Employee(id: 4, firstName: "", lastName: "")) array.append(Employee(id: 2, firstName: "", lastName: "")) let ids = array.map { $0.id }
class Employee { let id: Int, firstName: String, lastName: String init(id: Int, firstName: String, lastName: String) { self.id = id self.firstName = firstName self.lastName = lastName } } let employeeArray = [ Employee(id: 1, firstName: "Jon", lastName: "Skeet"), Employee(id: 2, firstName: "Darin", lastName: "Dimitrov"), Employee(id: 4, firstName: "Hans", lastName: "Passant") ] let idArray = employeeArray.map({ (employee: Employee) -> Int in employee.id }) print(idArray)
class Employee { let id: Int, firstName: String, lastName: String init(id: Int, firstName: String, lastName: String) { self.id = id self.firstName = firstName self.lastName = lastName } } let employeeArray = [ Employee(id: 1, firstName: "Jon", lastName: "Skeet"), Employee(id: 2, firstName: "Darin", lastName: "Dimitrov"), Employee(id: 4, firstName: "Hans", lastName: "Passant") ] var idArray = [Int]() for employee in employeeArray { idArray.append(employee.id) } print(idArray)
class Employee { let id: Int, firstName: String, lastName: String init(id: Int, firstName: String, lastName: String) { self.id = id self.firstName = firstName self.lastName = lastName } } let employeeArray = [ Employee(id: 1, firstName: "Jon", lastName: "Skeet"), Employee(id: 2, firstName: "Darin", lastName: "Dimitrov"), Employee(id: 4, firstName: "Hans", lastName: "Passant") ] var idArray = [Int]() var iterator = employeeArray.makeIterator() while let employee = iterator.next() { idArray.append(employee.id) } print(idArray)
class Employee { let id: Int, firstName: String, lastName: String init(id: Int, firstName: String, lastName: String) { self.id = id self.firstName = firstName self.lastName = lastName } } struct EmployeeSequence: Sequence, IteratorProtocol { let employeeArray: [Employee] private var index = 0 init(employeeArray: [Employee]) { self.employeeArray = employeeArray } mutating func next() -> Int? { guard index < employeeArray.count else { return nil } defer { index += 1 } return employeeArray[index].id } } let employeeArray = [ Employee(id: 1, firstName: "Jon", lastName: "Skeet"), Employee(id: 2, firstName: "Darin", lastName: "Dimitrov"), Employee(id: 4, firstName: "Hans", lastName: "Passant") ] let employeeSequence = EmployeeSequence(employeeArray: employeeArray) let idArray = Array(employeeSequence) print(idArray)
class Employee { let id: Int, firstName: String, lastName: String init(id: Int, firstName: String, lastName: String) { self.id = id self.firstName = firstName self.lastName = lastName } } extension Collection where Iterator.Element: Employee { func getIDs() -> Array<Int> { var index = startIndex let iterator: AnyIterator<Int> = AnyIterator { defer { index = self.index(index, offsetBy: 1) } return index != self.endIndex ? self[index].id : nil } return Array(iterator) } } let employeeArray = [ Employee(id: 1, firstName: "Jon", lastName: "Skeet"), Employee(id: 2, firstName: "Darin", lastName: "Dimitrov"), Employee(id: 4, firstName: "Hans", lastName: "Passant") ] let idArray = employeeArray.getIDs() print(idArray)
import Foundation class Employee: NSObject { let id: Int, firstName: String, lastName: String init(id: Int, firstName: String, lastName: String) { self.id = id self.firstName = firstName self.lastName = lastName } } let employeeArray = [ Employee(id: 1, firstName: "Jon", lastName: "Skeet"), Employee(id: 2, firstName: "Darin", lastName: "Dimitrov"), Employee(id: 4, firstName: "Hans", lastName: "Passant") ] let employeeNSArray = employeeArray as NSArray if let idArray = employeeNSArray.value(forKeyPath: print(idArray) }
BridgingHeader.h:5:9: error: ^ <unknown>:0: error: failed to import bridging header
var sprites = [SKSpriteNode?](repeating: nil, count: 64)
if var sprites = [SKSpriteNode?](repeating: nil, count: 64){ sprites[0] = pawnSprite }
var sprites = [SKSpriteNode?](count: 64, repeatedValue: nil)
var sprites = [SKSpriteNode?](repeating: nil, count: 64)
var sprites = [SKSpriteNode](count: 64, repeatedValue: SKSpriteNode())
typealias buffer = ( SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode, SKSpriteNode)
var array = [SKSpriteNode]() array.reserveCapacity(64) for _ in 0..<64 { array.append(SKSpriteNode()) }
var sprites = [SKSpriteNode](repeatElement(SKSpriteNode(texture: nil), count: 64))
var optionalSprites = [SKSpriteNode?](repeatElement(nil, count: 64))
var tasks = [0:[forTasks](),1:[forTasks](),2:[forTasks](),3:[forTasks](),4:[forTasks](),5:[forTasks](),6:[forTasks]()]
let str = string.stringByReplacingOccurrencesOfString("<[^>]+>", withString: "", options: .RegularExpressionSearch, range: nil) print(str)
var string = "<!DOCTYPE html> <html> <body> <h1>My First Heading</h1> <p>My first paragraph.</p> </body> </html>" let str = string.stringByReplacingOccurrencesOfString("<[^>]+>", withString: "", options: .RegularExpressionSearch, range: nil) print(str)
let htmlString = "LCD Soundsystem was the musical project of producer <a href= let htmlStringData = htmlString.dataUsingEncoding(NSUTF8StringEncoding)! let options: [String: AnyObject] = [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: NSUTF8StringEncoding] let attributedHTMLString = try! NSAttributedString(data: htmlStringData, options: options, documentAttributes: nil) let string = attributedHTMLString.string
let attributed = try NSAttributedString(data: htmlString.data(using: .unicode)!, options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType], documentAttributes: nil) print(attributed.string)
extension String { func deleteHTMLTag(tag:String) -> String { return self.stringByReplacingOccurrencesOfString("(?i)</?\(tag)\\b[^<]*>", withString: "", options: .RegularExpressionSearch, range: nil) } func deleteHTMLTags(tags:[String]) -> String { var mutableString = self for tag in tags { mutableString = mutableString.deleteHTMLTag(tag) } return mutableString } }
let string = "my html <a href="">link text</a>" let withoutHTMLString = string.deleteHTMLTag("a")
extension String { func deleteHTMLTag(tag:String) -> String { return self.replacingOccurrences(of: "(?i)</?\(tag)\\b[^<]*>", with: "", options: .regularExpression, range: nil) } func deleteHTMLTags(tags:[String]) -> String { var mutableString = self for tag in tags { mutableString = mutableString.deleteHTMLTag(tag: tag) } return mutableString } }
protocol ApiMapperProtocol { func MapFromSource(T) -> U } class UserMapper: NSObject, ApiMapperProtocol { func MapFromSource(data: NSDictionary) -> UserModel { var user = UserModel() as UserModel var accountsData:NSArray = data["Accounts"] as NSArray return user } }
protocol ApiMapperProtocol { associatedtype T associatedtype U func MapFromSource(_:T) -> U } class UserMapper: NSObject, ApiMapperProtocol { typealias T = NSDictionary typealias U = UserModel func MapFromSource(_ data:NSDictionary) -> UserModel { var user = UserModel() var accountsData:NSArray = data["Accounts"] as NSArray return user } }
protocol ApiMapperProtocol { associatedtype T associatedtype U func mapFromSource(T) -> U } class UserMapper: NSObject, ApiMapperProtocol { typealias T = NSDictionary typealias U = UserModel func mapFromSource(data: NSDictionary) -> UserModel { var user = UserModel() var accountsData: NSArray = data["Accounts"] as NSArray return user } } class UsesApiMapperProtocol { func usesApiMapperProtocol< SourceType, MappedType, ApiMapperProtocolType: ApiMapperProtocol where ApiMapperProtocolType.T == SourceType, ApiMapperProtocolType.U == MappedType>( apiMapperProtocol: ApiMapperProtocolType, source: SourceType) -> MappedType { return apiMapperProtocol.mapFromSource(source) } }
let dictionary: NSDictionary = ... let uses = UsesApiMapperProtocol() let userModel: UserModel = uses.usesApiMapperProtocol(UserMapper() source: dictionary)
protocol HeavyDelegate : class { func heavy<P, R>(heavy: Heavy<P, R>, shouldReturn: P) -> R } class Heavy<P, R> { typealias Param = P typealias Return = R weak var delegate : HeavyDelegate? func inject(p : P) -> R? { if delegate != nil { return delegate?.heavy(self, shouldReturn: p) } return nil } func callMe(r : Return) { } } class Delegate : HeavyDelegate { typealias H = Heavy<(Int, String), String> func heavy<P, R>(heavy: Heavy<P, R>, shouldReturn: P) -> R { let h = heavy as! H h.callMe("Hello") print("Invoked") return "Hello" as! R } } let heavy = Heavy<(Int, String), String>() let delegate = Delegate() heavy.delegate = delegate heavy.inject((5, "alive"))
public protocol Printable { typealias T func Print(val:T) }
class Printer<T> : Printable { func Print(val: T) { println(val) } }
**EDIT :** Adding similar code that works in C# public interface IPrintable<T> { void Print(T val); } public class Printer<T> : IPrintable<T> { public void Print(T val) { Console.WriteLine(val); } } ..... IPrintable<int> p = new Printer<int>(); p.Print(67)
protocol Printable { func Print() } protocol CollectionType<T where T:Printable> : SequenceType { ..... ..... } public class Collection<T where T:Printable> : CollectionType<T> { ...... } let col:CollectionType<Int> = SomeFunctiionThatReturnsIntCollection() for item in col { item.Print() }
protocol StoringType { typealias Stored init(_ value: Stored) func getStored() -> Stored } struct IntStorer: StoringType { typealias Stored = Int private let _stored: Int init(_ value: Int) { _stored = value } func getStored() -> Int { return _stored } } struct StringStorer: StoringType { typealias Stored = String private let _stored: String init(_ value: String) { _stored = value } func getStored() -> String { return _stored } } let intStorer = IntStorer(5) intStorer.getStored() let stringStorer = StringStorer("five") stringStorer.getStored()
var someStorer: StoringType = arc4random()%2 == 0 ? intStorer : stringStorer let x = someStorer.getStored()
func printStoredValue<S: StoringType>(storer: S) { let x = storer.getStored() println(x) } printStoredValue(intStorer) printStoredValue(stringStorer)
import Foundation public protocol Printer { typealias T func print(val:T) } struct AnyPrinter<U>: Printer { typealias T = U private let _print: U -> () init<Base: Printer where Base.T == U>(base : Base) { _print = base.print } func print(val: T) { _print(val) } } struct NSLogger<U>: Printer { typealias T = U func print(val: T) { NSLog("\(val)") } } let nsLogger = NSLogger<Int>() let printer = AnyPrinter(base: nsLogger) printer.print(5)
extension AnyPrinter { convenience init() { let nsLogger = NSLogger<T>() self.init(base: nsLogger) } } let printer = AnyPrinter<Int>() printer.print(10)
protocol PrintableGeneratorType: GeneratorType { typealias Element: Printable } protocol PrintableCollectionType: CollectionType { typealias Generator: PrintableGenerator }
struct MyPrintableCollection<T: Printable>: PrintableCollectionType { typealias Generator = IndexingGenerator<T> }
func printCollection <C: CollectionType where C.Generator.Element: Printable> (source: C) { for x in source { x.print() } }
typealias Ftype = @objc_block (s:String) -> () let f : Ftype = { ss in println(ss) } let ff : Ftype = { sss in println(sss) } let obj1 = unsafeBitCast(f, AnyObject.self) let obj2 = unsafeBitCast(ff, AnyObject.self) let obj3 = unsafeBitCast(f, AnyObject.self) println(obj1 === obj2) println(obj1 === obj3)
func peekFunc<A,R>(f:A->R)->(fp:Int, ctx:Int) { typealias IntInt = (Int, Int) let (hi, lo) = unsafeBitCast(f, IntInt.self) let offset = sizeof(Int) == 8 ? 16 : 12 let ptr = UnsafePointer<Int>(lo+offset) return (ptr.memory, ptr.successor().memory) } @infix func === <A,R>(lhs:A->R,rhs:A->R)->Bool { let (tl, tr) = (peekFunc(lhs), peekFunc(rhs)) return tl.0 == tr.0 && tl.1 == tr.1 }
func genericId<T>(t:T)->T { return t } func incr(i:Int)->Int { return i + 1 } var f:Int->Int = genericId var g = f; println("(f === g) == \(f === g)") f = genericId; println("(f === g) == \(f === g)") f = g; println("(f === g) == \(f === g)") func mkcounter()->()->Int { var count = 0; return { count++ } } var c0 = mkcounter() var c1 = mkcounter() var c2 = c0 println("peekFunc(c0) == \(peekFunc(c0))") println("peekFunc(c1) == \(peekFunc(c1))") println("peekFunc(c2) == \(peekFunc(c2))") println("(c0() == c1()) == \(c0() == c1())") println("(c0() == c2()) == \(c0() == c2())") println("(c0 === c1) == \(c0 === c1)") println("(c0 === c2) == \(c0 === c2)")
var handler:Handler = Handler(callback: { (message:String) in }))
typealias SwfBlock = () -> () typealias ObjBlock = @convention(block) () -> () func testSwfBlock(a: SwfBlock, _ b: SwfBlock) -> String { let objA = unsafeBitCast(a as ObjBlock, AnyObject.self) let objB = unsafeBitCast(b as ObjBlock, AnyObject.self) return "a is ObjBlock: \(a is ObjBlock), b is ObjBlock: \(b is ObjBlock), objA === objB: \(objA === objB)" } func testObjBlock(a: ObjBlock, _ b: ObjBlock) -> String { let objA = unsafeBitCast(a, AnyObject.self) let objB = unsafeBitCast(b, AnyObject.self) return "a is ObjBlock: \(a is ObjBlock), b is ObjBlock: \(b is ObjBlock), objA === objB: \(objA === objB)" } func testAnyBlock(a: Any?, _ b: Any?) -> String { if !(a is ObjBlock) || !(b is ObjBlock) { return "a nor b are ObjBlock, they are not equal" } let objA = unsafeBitCast(a as! ObjBlock, AnyObject.self) let objB = unsafeBitCast(b as! ObjBlock, AnyObject.self) return "a is ObjBlock: \(a is ObjBlock), b is ObjBlock: \(b is ObjBlock), objA === objB: \(objA === objB)" } class Foo { lazy var swfBlock: ObjBlock = self.swf func swf() { print("swf") } @objc func obj() { print("obj") } } let swfBlock: SwfBlock = { print("swf") } let objBlock: ObjBlock = { print("obj") } let foo: Foo = Foo() print(testSwfBlock(swfBlock, swfBlock)) print(testSwfBlock(objBlock, objBlock)) print(testObjBlock(swfBlock, swfBlock)) print(testObjBlock(objBlock, objBlock)) print(testAnyBlock(swfBlock, swfBlock)) print(testAnyBlock(objBlock, objBlock)) print(testObjBlock(foo.swf, foo.swf)) print(testSwfBlock(foo.obj, foo.obj)) print(testAnyBlock(foo.swf, foo.swf)) print(testAnyBlock(foo.swfBlock, foo.swfBlock))
typealias Callback = (Any...)->Void class Command { init(_ fn: @escaping Callback) { self.fn_ = fn } var exec : (_ args: Any...)->Void { get { return fn_ } } var fn_ :Callback } let cmd1 = Command { _ in print("hello")} let cmd2 = cmd1 let cmd3 = Command { (_ args: Any...) in print(args.count) } cmd1.exec() cmd2.exec() cmd3.exec(1, 2, "str") cmd1 === cmd2 cmd1 === cmd3
interface Command { void exec(Object... args); } Command cmd1 = new Command() { public void exec(Object... args) [ } } Command cmd2 = cmd1; Command cmd3 = new Command() { public void exec(Object... args) { } } cmd1 == cmd2 cmd1 == cmd3
class OfflineManager { var networkChangedListeners = [String:((Bool) -> Void)]() func registerOnNetworkAvailabilityChangedListener(_ listener: @escaping ((Bool) -> Void)) -> String{ let listenerId = UUID().uuidString; networkChangedListeners[listenerId] = listener; return listenerId; } func unregisterOnNetworkAvailabilityChangedListener(_ listenerId: String){ networkChangedListeners.removeValue(forKey: listenerId); } }
func ComputeSomeValues(_ value1: inout String, _ value2: inout Int){ value1 = "my great computation 1"; value2 = 123456; }
var val1: String = ""; var val2: Int = -1; ComputeSomeValues(&val1, &val2);
let vegetable = "red pepper" var vegetableComment: String = "Nothing" switch vegetable { case "cucumber", "watercress": break case let x where x.hasSuffix("pepper"): vegetableComment = "Is it a spicy \(x)?" default: vegetableComment = "Everything tastes good in soup." }
protocol P { } struct S: P { } let arr:[P] = [ S() ] extension Array where Element : P { func test<T>() -> [T] { return [] } } let result : [S] = arr.test()
protocol P { } struct S: P { } struct AnyPArray { var array: [P] init(_ array:[P]) { self.array = array } } extension AnyPArray { func test<T>() -> [T] { return [] } } let arr = AnyPArray([S()]) let result: [S] = arr.test()
protocol P { init() } struct S : P {} struct S1 : P {} extension Array where Element : P { mutating func appendNew() { append(Element()) } } var arr: [P] = [S(), S1()] arr.appendNew()
protocol P { static func foo() static var bar: Int { get } } struct SomeGeneric<T : P> { func baz() { print(T.bar) T.foo() } } SomeGeneric<P>().baz()
import Foundation @objc protocol P { func foo() } class C : P { func foo() { print("C } } func baz<T : P>(_ t: T) { t.foo() } let c: P = C() baz(c)
import Foundation @objc protocol P { static func bar() func foo() } class C : P { static func bar() { print("C } func foo() { print("C } } func baz<T : P>(_ t: T) { t.foo() } let c: P = C() baz(c)
@objc protocol P {} class C: P {} func process<T: P>(item: T) -> T { return item } func f(image: P) { let processed: P = process(item:image) }
extension Array where Element == P { func test<T>() -> [T] { return [] } } let arr: [P] = [S()] let result: [S] = arr.test()
extension Array where Element : P { func test<T>() -> [T] { return (self as [P]).test() } } let arr = [S()] let result: [S] = arr.test()
protocol P { var bar: Int { get set } func foo(str: String) } struct S : P { var bar: Int func foo(str: String) { } } func takesConcreteP<T : P>(_ t: T) { } let p: P = S(bar: 5) takesConcreteP(p)
extension P { func callTakesConcreteP ( ) { takesConcreteP(self) } }
struct Q : P { var bar: Int func foo(str: String) {} } func takesConcreteArrayOfP<T : P>(_ t: [T]) {} let array: [P] = [S(bar: 1), Q(bar: 2)] takesConcreteArrayOfP(array)
struct AnyP : P { private var base: P init(_ base: P) { self.base = base } var bar: Int { get { return base.bar } set { base.bar = newValue } } func foo(str: String) { base.foo(str: str) } }
let p = AnyP(S(bar: 5)) takesConcreteP(p) let array = [AnyP(S(bar: 1)), AnyP(Q(bar: 2))] takesConcreteArrayOfP(array)
protocol P { } struct S: P { } let arr:[P] = [ S() ] extension CollectionType where Generator.Element == P { func test<T>() -> [T] { return [] } } let result : [S] = arr.test()
platform :ios, "8.0" use_frameworks! target pod end target end
override func viewWillAppear(animated: Bool) { NSNotificationCenter.defaultCenter().addObserver(self, selector: "keyboardWillShow:", name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: "keyboardWillHide:", name: UIKeyboardWillHideNotification, object: nil) } override func viewWillDisappear(animated: Bool) { NSNotificationCenter.defaultCenter().removeObserver(self) } func keyboardWillShow(notification: NSNotification) { var keyboardSize = notification.userInfo(valueForKey(UIKeyboardFrameBeginUserInfoKey)) UIEdgeInsets(top: 0, left: 0, bottom: keyboardSize.height, right: 0) let frame = self.budgetEntryView.frame frame.origin.y = frame.origin.y - keyboardSize self.budgetEntryView.frame = frame } func keyboardWillHide(notification: NSNotification) { // }
var keyboardSize = notification.userInfo(valueForKey(UIKeyboardFrameBeginUserInfoKey))
var keyboardSize = notification.userInfo(valueForKey(UIKeyboardFrameBeginUserInfoKey))
if let userInfo = notification.userInfo { if let keyboardSize = (userInfo[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { let contentInsets = UIEdgeInsets(top: 0, left: 0, bottom: keyboardSize.height, right: 0) } else { } } else { }
if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() { let contentInsets = UIEdgeInsets(top: 0, left: 0, bottom: keyboardSize.height, right: 0) }
if let userInfo = notification.userInfo { if let keyboardSize = userInfo[UIKeyboardFrameBeginUserInfoKey] as? CGRect { let contentInsets = UIEdgeInsets(top: 0, left: 0, bottom: keyboardSize.height, right: 0) } else { } } else { }
if let keyboardSize = notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? CGRect { let contentInsets = UIEdgeInsets(top: 0, left: 0, bottom: keyboardSize.height, right: 0) }
func keyboardWillShow(sender: NSNotification) { if let userInfo = sender.userInfo { if let keyboardHeight = userInfo[UIKeyboardFrameEndUserInfoKey]?.CGRectValue().size.height { tableViewBottomConstraint.constant = keyboardHeight UIView.animateWithDuration(0.25, animations: { () -> Void in self.view.layoutIfNeeded() }) } } }
func keyboardWillHide(sender: NSNotification) { if let userInfo = sender.userInfo { if let keyboardHeight = userInfo[UIKeyboardFrameEndUserInfoKey]?.CGRectValue().size.height { tableViewBottomConstraint.constant = 0.0 UIView.animateWithDuration(0.25, animations: { () -> Void in self.view.layoutIfNeeded() }) } } }
override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillShow:"), name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillHide:"), name: UIKeyboardWillHideNotification, object: nil) }
override func viewWillDisappear(animated: Bool) { super.viewWillDisappear(animated) NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillShowNotification, object: self.view.window) NSNotificationCenter.defaultCenter().removeObserver(self, name: UIKeyboardWillHideNotification, object: self.view.window) }
func keyboardWillShow(notification: NSNotification) { guard let keyboardHeight = (notification.userInfo! as NSDictionary).objectForKey(UIKeyboardFrameBeginUserInfoKey)?.CGRectValue.size.height else { return } nameOfOutlet.constant = keyboardHeight view.layoutIfNeeded() } func keyboardWillHide(notification: NSNotification) { nameOfOutlet.constant = 0.0 view.layoutIfNeeded() }
func keyboardWasShown(notification:NSNotification) { guard let info:[NSObject:AnyObject] = notification.userInfo, let keyboardSize:CGSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue().size else { return } let insets:UIEdgeInsets = UIEdgeInsetsMake(self.scrollView.contentInset.top, 0.0, keyboardSize.height, 0.0) self.scrollView.contentInset = insets self.scrollView.scrollIndicatorInsets = insets }
func keyboardWasShown(notification:NSNotification) { guard let info:[AnyHashable:Any] = notification.userInfo, let keyboardSize:CGSize = (info[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue.size else { return } let insets:UIEdgeInsets = UIEdgeInsets(top: self.scrollView.contentInset.top, left: 0.0, bottom: keyboardSize.height, right: 0.0) self.scrollView.contentInset = insets self.scrollView.scrollIndicatorInsets = insets }
let userInfo = notification.userInfo! let animationDuration: NSTimeInterval = (userInfo[UIKeyboardAnimationDurationUserInfoKey] as NSNumber).doubleValue let keyboardScreenBeginFrame = (userInfo[UIKeyboardFrameBeginUserInfoKey] as NSValue).CGRectValue() let keyboardScreenEndFrame = (userInfo[UIKeyboardFrameEndUserInfoKey] as NSValue).CGRectValue()
var keyboardSize:CGSize = userInfo.objectForKey(UIKeyboardFrameBeginUserInfoKey)!.CGRectValue().size
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillShow, object: self.view.window) NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillHide, object: self.view.window) }
@IBOutlet weak var myViewsBottomSpaceConstraint: NSLayoutConstraint!
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillShow, object: self.view.window) NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillHide, object: self.view.window) } func keyboardWillShow(notification: NSNotification) { let userInfo = notification.userInfo as! [String: NSObject] as NSDictionary let keyboardFrame = userInfo.value(forKey: UIKeyboardFrameEndUserInfoKey) as! CGRect let keyboardHeight = keyboardFrame.height myViewsBottomSpaceConstraint.constant = keyboardHeight view.layoutIfNeeded() } func keyboardWillHide(notification: NSNotification) { myViewsBottomSpaceConstraint.constant = 0.0 view.layoutIfNeeded() }
import Foundation class KeyboardNotifications { fileprivate var _isEnabled: Bool fileprivate var notifications: [KeyboardNotificationsType] fileprivate var delegate: KeyboardNotificationsDelegate init(notifications: [KeyboardNotificationsType], delegate: KeyboardNotificationsDelegate) { _isEnabled = false self.notifications = notifications self.delegate = delegate } deinit { if isEnabled { isEnabled = false } } } extension KeyboardNotifications { enum KeyboardNotificationsType { case willShow, willHide, didShow, didHide var selector: Selector { switch self { case .willShow: return case .willHide: return case .didShow: return case .didHide: return } } var notificationName: NSNotification.Name { switch self { case .willShow: return .UIKeyboardWillShow case .willHide: return .UIKeyboardWillHide case .didShow: return .UIKeyboardDidShow case .didHide: return .UIKeyboardDidHide } } } } extension KeyboardNotifications { private func addObserver(type: KeyboardNotificationsType) { NotificationCenter.default.addObserver(self, selector: type.selector, name: type.notificationName, object: nil) print("\(type.notificationName.rawValue) inited") } var isEnabled: Bool { set { if newValue { for notificaton in notifications { addObserver(type: notificaton) } } else { NotificationCenter.default.removeObserver(self) print("Keyboard notifications deinited") } _isEnabled = newValue } get { return _isEnabled } } } extension KeyboardNotifications { @objc func keyboardWillShow(notification: NSNotification) { delegate.keyboardWillShow?(notification: notification) } @objc func keyboardWillHide(notification: NSNotification) { delegate.keyboardWillHide?(notification: notification) } @objc func keyboardDidShow(notification: NSNotification) { delegate.keyboardDidShow?(notification: notification) } @objc func keyboardDidHide(notification: NSNotification) { delegate.keyboardDidHide?(notification: notification) } }
import Foundation @objc protocol KeyboardNotificationsDelegate { @objc optional func keyboardWillShow(notification: NSNotification) @objc optional func keyboardWillHide(notification: NSNotification) @objc optional func keyboardDidShow(notification: NSNotification) @objc optional func keyboardDidHide(notification: NSNotification) }
class ViewController: UIViewController { private var keyboardNotifications: KeyboardNotifications! override func viewDidLoad() { super.viewDidLoad() ... keyboardNotifications = KeyboardNotifications(notifications: [.willShow, .willHide, .didShow, .didHide], delegate: self) } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) keyboardNotifications.isEnabled = true } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) keyboardNotifications.isEnabled = false } } extension ViewController: KeyboardNotificationsDelegate { func keyboardWillShow(notification: NSNotification) { ... } func keyboardWillHide(notification: NSNotification) { ... } func keyboardDidShow(notification: NSNotification) { ... } func keyboardDidHide(notification: NSNotification) { ... } }
import UIKit class ViewController: UIViewController { private var keyboardNotifications: KeyboardNotifications! private var textField = UITextField(frame: CGRect(x: 40, y: 40, width: 200, height: 30)) override func viewDidLoad() { super.viewDidLoad() view.addSubview(textField) view.disableKeybordWhenTapped = true keyboardNotifications = KeyboardNotifications(notifications: [.willShow, .willHide, .didShow, .didHide], delegate: self) } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) keyboardNotifications.isEnabled = true } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) keyboardNotifications.isEnabled = false } } extension ViewController: KeyboardNotificationsDelegate { func keyboardWillShow(notification: NSNotification) { print("keyboardWillShow") let userInfo = notification.userInfo as! [String: NSObject] let keyboardFrame = userInfo[UIKeyboardFrameEndUserInfoKey] as! CGRect print("keyboardFrame: \(keyboardFrame)") } func keyboardWillHide(notification: NSNotification) { print("keyboardWillHide") } func keyboardDidShow(notification: NSNotification) { print("keyboardDidShow") } func keyboardDidHide(notification: NSNotification) { print("keyboardDidHide") } }
private void KeyboardWillChangeFrame(NSNotification notification) { var keyboardSize = notification.UserInfo.ValueForKey(UIKeyboard.FrameEndUserInfoKey) as NSValue; if (keyboardSize != null) { var rect= keyboardSize.CGRectValue; } }
private void KeyboardWillChangeFrame(NSNotification notification) { if (!(notification.UserInfo.ValueForKey(UIKeyboard.FrameEndUserInfoKey) is NSValue keyboardSize)) return; var rect= keyboardSize.CGRectValue; }
if let tabBarController = window!.rootViewController as? UITabBarController { if tabBarController.viewControllers.count > 0 { println("do stuff") } }
if let tabBarController = window!.rootViewController as? UITabBarController && tabBarController.viewControllers.count > 0 { println("do stuff") } }
if let tabBarController = window!.rootViewController as? UITabBarController && true { println("do stuff") }
if let tabBarController = window!.rootViewController as? UITabBarController where tabBarController.viewControllers.count > 0 { println("do stuff") }
if let w = width as? Int where w < 500 { println("success!") }
if let w = width as? Int, w < 500 { println("success!") }
if let tabBarController = window!.rootViewController as? UITabBarController, tabBarController.viewControllers.count > 0 { println("do stuff") }
let i = navigationController?.viewControllers.index(of: self) if let index = i, index > 0, let parent = navigationController?.viewControllers[index-1] { }
if ((window!.rootViewController as? UITabBarController)?.viewControllers.count ?? 0) > 0 { println("do stuff") }
func imagePickerController(picker: UIImagePickerController, didFinishPickingImage image: UIImage, editingInfo: [String : AnyObject]?) { imagePost.image = image self.dismiss(animated: true, completion: nil) }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) { if let image = info[UIImagePickerControllerOriginalImage] as? UIImage { imagePost.image = image } else{ print("Something went wrong") } self.dismiss(animated: true, completion: nil) }
let picker = UIImagePickerController() picker.delegate = self
public func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]){ if let image = info[UIImagePickerControllerEditedImage] as? UIImage { imageView.image = image } else if let image = info[UIImagePickerControllerOriginalImage] as? UIImage { imageView.image = image } else{ print("Something went wrong") } self.dismiss(animated: true, completion: nil) }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject]) { picker.dismissViewControllerAnimated(true, completion: nil) if let image = info[UIImagePickerControllerEditedImage] as? UIImage { imagePost.image = image } else if let image = info[UIImagePickerControllerOriginalImage] as? UIImage { imagePost.image = image } else { imagePost.image = nil } }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { let selectedImage = info[UIImagePickerControllerOriginalImage] as! UIImage photoImageView.image = selectedImage dismiss(animated: true, completion: nil) }
func imagePickerController(picker: UIImagePickerController ...
func imagePickerController(_ picker: UIImagePickerController ...
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { if let image = info[UIImagePickerControllerOriginalImage] as? UIImage { imageView.image = image self.dismiss(animated: true, completion: nil) } }
imageView.layer.cornerRadius = self.imageView.frame.size.width / 2
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { let image = info[UIImagePickerControllerOriginalImage] as? UIImage self.dismiss(animated: true, completion: nil) self.imageTook.image = image }
func imagePickerController(picker: UIImagePickerController, didFinishPickingImage image: UIImage, editingInfo: [String : AnyObject]?) { imagePost.image = image self.dismiss(animated: true, completion: nil) }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { imagePost.image = info[UIImagePickerControllerOriginalImage] as? UIImage picker.dismiss(animated: true, completion: nil) }
class ViewController:UIViewController,UIImagePickerControllerDelegate,UINavigationControllerDelegate
func viwImagePick(){ let alert = UIAlertController(title: nil, message: "Choose your source", preferredStyle: UIAlertControllerStyle.alert) alert.addAction(UIAlertAction(title: "Camera", style: UIAlertActionStyle.default) { (result : UIAlertAction) -> Void in print("Camera selected") self.openCamera() }) alert.addAction(UIAlertAction(title: "Photo library", style: UIAlertActionStyle.default) { (result : UIAlertAction) -> Void in print("Photo selected") self.openGallary() }) self.present(alert, animated: true, completion: nil) } func openCamera() { imagePicker.sourceType = UIImagePickerControllerSourceType.camera if UIDevice.current.userInterfaceIdiom == .phone { self.present(imagePicker, animated: true, completion: nil) } else { let popover = UIPopoverController(contentViewController: imagePicker) popover.present(from: profileImgViw.frame, in: self.view, permittedArrowDirections: UIPopoverArrowDirection.any, animated: true) } } func openGallary() { imagePicker.sourceType = UIImagePickerControllerSourceType.savedPhotosAlbum if UIDevice.current.userInterfaceIdiom == .phone { self.present(imagePicker, animated: true, completion: nil) } else { let popover = UIPopoverController(contentViewController: imagePicker) popover.present(from: profileImgViw.frame, in: self.view, permittedArrowDirections: UIPopoverArrowDirection.any, animated: true) } }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { if let image = info[UIImagePickerControllerOriginalImage] as? UIImage { imgViewPhoto.image = image } else{ print("Something went wrong") } picker.dismiss(animated: true, completion: nil) }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { print("image selected"); let selectedImage = info[UIImagePickerControllerOriginalImage] as! UIImag self.dismiss(animated: true, completion: nil) UIImg.image = selectedImage }
func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { let selectedImage = info[UIImagePickerControllerOriginalImage] as! UIImage photoImageView.image = selectedImage dismiss(animated: true, completion: nil) }
func prepareImageForSaving(image:UIImage) { guard let imageData = UIImageJPEGRepresentation(image, 1) else { print("jpg error") return } self.saveImage(imageData: imageData as NSData) } func saveImage(imageData: NSData) { imageDatas = imageData }
@IBOutlet var img: UIImageView! @IBOutlet weak var collview: UICollectionView! var image = NSMutableArray() let imgpkr = UIImagePickerController() override func viewDidLoad() { super.viewDidLoad() imgpkr.delegate = self } @IBAction func btnselect(_ sender: UIButton) { imgpkr.allowsEditing = true imgpkr.sourceType = .photoLibrary imgpkr.mediaTypes = UIImagePickerController.availableMediaTypes(for: .photoLibrary)! present(imgpkr, animated: true, completion: nil) } func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) { let choose = info[UIImagePickerControllerOriginalImage]as!UIImage let edit = info[UIImagePickerControllerEditedImage]as!UIImage img.contentMode = .scaleAspectFit img.image = edit image.add(edit) collview.reloadData() dismiss(animated: true, completion: nil) } func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { dismiss(animated: true, completion: nil) } func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { return image.count } func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell { let cell = collview.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)as! CollectionViewCell1 cell.img1.image = image.object(at: indexPath.item)as! UIImage return cell }
override func viewDidLoad() { super.viewDidLoad() tableView.dataSource = self tableView.delegate = self tableView.tableFooterView = UIView() }
tableView.tableFooterView = UIView.init(frame: CGRect.zero)
@IBOutlet weak var tableView: UITableView! { didSet { tableView.tableFooterView = UIView(frame: .zero) } }
let separator : UIView = { let view = UIView(frame: .zero) view.backgroundColor = .white return view }() override init(style: UITableViewCellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) self.addSubview(separator) separator.bottomAnchor.constraint(equalTo: self.bottomAnchor).isActive = true separator.leadingAnchor.constraint(equalTo: self.leadingAnchor).isActive = true separator.trailingAnchor.constraint(equalTo: self.trailingAnchor).isActive = true separator.heightAnchor.constraint(equalToConstant: 0.5).isActive = true }
extension UITableView { override open func didMoveToSuperview() { super.didMoveToSuperview() self.tableFooterView = UIView() }
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return yourArrayClass.count - 1 }
self.yourView.layer.borderWidth = 1 self.yourView.layer.borderColor = UIColor(red:222/255, green:225/255, blue:227/255, alpha: 1).cgColor
self.yourView.layer.borderWidth = 1 self.yourView.layer.borderColor = UIColor(red:222/255, green:225/255, blue:227/255, alpha: 1).cgColor
yourView.layer.borderWidth = 1 yourView.layer.borderColor = UIColor.red.cgColor
@IBDesignable class CustomView: UIView{ @IBInspectable var borderWidth: CGFloat = 0.0{ didSet{ self.layer.borderWidth = borderWidth } } @IBInspectable var borderColor: UIColor = UIColor.clear { didSet { self.layer.borderColor = borderColor.cgColor } } override func prepareForInterfaceBuilder() { super.prepareForInterfaceBuilder() } }
extension UIView{ func setBorder(radius:CGFloat, color:UIColor = UIColor.clearColor()) -> UIView{ var roundView:UIView = self roundView.layer.cornerRadius = CGFloat(radius) roundView.layer.borderWidth = 1 roundView.layer.borderColor = color.CGColor roundView.clipsToBounds = true return roundView } }
btnLogin.setBorder(7, color: UIColor.lightGrayColor()) imgViewUserPick.setBorder(10)
func borderColor(){ self.viewMenuItems.layer.cornerRadius = 13 self.viewMenuItems.layer.borderWidth = 1 self.viewMenuItems.layer.borderColor = UIColor.white.cgColor }
func anyColor() -> UIColor { return UIColor(red: 0.0/255.0, green: 0.0/255.0, blue: 0.0/255.0, alpha: 1.0) }
self.uiTextView.layer.borderWidth = 0.5 self.txtItemShortDes.layer.borderColor = UIColor(red:205.0/255.0, green:205.0/255.0, blue:205.0/255.0, alpha: 1.0).cgColor
public func createBorderForView(color: UIColor, radius: CGFloat, width: CGFloat = 0.7) { self.layer.borderWidth = width self.layer.cornerRadius = radius self.layer.shouldRasterize = false self.layer.rasterizationScale = 2 self.clipsToBounds = true self.layer.masksToBounds = true let cgColor: CGColor = color.cgColor self.layer.borderColor = cgColor }
groundTrump.layer.borderColor = UIColor.red.cgColor
import UIKit class ViewController: UIViewController { @IBAction func shareTextButton(_ sender: UIButton) { let text = "This is some text that I want to share." let textToShare = [ text ] let activityViewController = UIActivityViewController(activityItems: textToShare, applicationActivities: nil) activityViewController.popoverPresentationController?.sourceView = self.view activityViewController.excludedActivityTypes = [ UIActivityType.airDrop, UIActivityType.postToFacebook ] self.present(activityViewController, animated: true, completion: nil) } @IBAction func shareImageButton(_ sender: UIButton) { let image = UIImage(named: "Image") let imageToShare = [ image! ] let activityViewController = UIActivityViewController(activityItems: imageToShare, applicationActivities: nil) activityViewController.popoverPresentationController?.sourceView = self.view activityViewController.excludedActivityTypes = [ UIActivityType.airDrop, UIActivityType.postToFacebook ] self.present(activityViewController, animated: true, completion: nil) } }
@IBAction func shareOnlyText(_ sender: UIButton) { let text = "This is the text....." let textShare = [ text ] let activityViewController = UIActivityViewController(activityItems: textShare , applicationActivities: nil) activityViewController.popoverPresentationController?.sourceView = self.view self.present(activityViewController, animated: true, completion: nil) } }
@IBAction func shareOnlyImage(_ sender: UIButton) { let image = UIImage(named: "Product") let imageShare = [ image! ] let activityViewController = UIActivityViewController(activityItems: imageShare , applicationActivities: nil) activityViewController.popoverPresentationController?.sourceView = self.view self.present(activityViewController, animated: true, completion: nil) }
@IBAction func shareAll(_ sender: UIButton) { let text = "This is the text...." let image = UIImage(named: "Product") let myWebsite = NSURL(string:"https: let shareAll= [text , image! , myWebsite] let activityViewController = UIActivityViewController(activityItems: shareAll, applicationActivities: nil) activityViewController.popoverPresentationController?.sourceView = self.view self.present(activityViewController, animated: true, completion: nil) }
@IBAction func shareButton(_ sender: Any) { let bounds = UIScreen.main.bounds UIGraphicsBeginImageContextWithOptions(bounds.size, true, 0.0) self.view.drawHierarchy(in: bounds, afterScreenUpdates: false) let img = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() let activityViewController = UIActivityViewController(activityItems: [img!], applicationActivities: nil) activityViewController.popoverPresentationController?.sourceView = self.view self.present(activityViewController, animated: true, completion: nil) }
activityViewController.popoverPresentationController?.sourceView = sender
showShareActivity(msg:"message", image: nil, url: nil, sourceRect: nil)
func topViewController()-> UIViewController{ var topViewController:UIViewController = UIApplication.shared.keyWindow!.rootViewController! while ((topViewController.presentedViewController) != nil) { topViewController = topViewController.presentedViewController!; } return topViewController } func showShareActivity(msg:String?, image:UIImage?, url:String?, sourceRect:CGRect?){ var objectsToShare = [AnyObject]() if let url = url { objectsToShare = [url as AnyObject] } if let image = image { objectsToShare = [image as AnyObject] } if let msg = msg { objectsToShare = [msg as AnyObject] } let activityVC = UIActivityViewController(activityItems: objectsToShare, applicationActivities: nil) activityVC.modalPresentationStyle = .popover activityVC.popoverPresentationController?.sourceView = topViewController().view if let sourceRect = sourceRect { activityVC.popoverPresentationController?.sourceRect = sourceRect } topViewController().present(activityVC, animated: true, completion: nil) }
class test { var my2Darr = Int[][]() init() { for(var i:Int=0;i<10;i++) { for(var j:Int=0;j<10;j++) { my2Darr[i][j]=18 } } } }
class test { var my2Darr = Int[][]() init() { .... } func edit(number:Int,index:Int){ my2Darr[index][index] = number if (my2Darr[i][j] == nil) { ... } */ } }
var arr = Array(count: 3, repeatedValue: Array(count: 2, repeatedValue: 0)) var arr = Array(repeating: Array(repeating: 0, count: 2), count: 3)
let a = 0 let b = 1 if arr.count > a && arr[a].count > b { println(arr[a][b]) }
var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
private var matrix: [[MyClass]] = MyClass.newMatrix() private static func newMatrix() -> [[MyClass]] { var matrix: [[MyClass]] = [] for i in 0...23 { matrix.append( [] ) for _ in 0...79 { matrix[i].append( MyClass() ) } } return matrix }
struct Matrix { let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) { self.rows = rows self.columns = columns grid = Array(repeating: 0.0, count: rows * columns) } func indexIsValid(row: Int, column: Int) -> Bool { return row >= 0 && row < rows && column >= 0 && column < columns } subscript(row: Int, column: Int) -> Double { get { assert(indexIsValid(row: row, column: column), "Index out of range") return grid[(row * columns) + column] } set { assert(indexIsValid(row: row, column: column), "Index out of range") grid[(row * columns) + column] = newValue } }
var arr = Array(repeating: Array(repeating: 0, count: 2), count: 3)
struct Matrix<T> { let rows: Int, columns: Int var grid: [T] init(rows: Int, columns: Int,defaultValue: T) { self.rows = rows self.columns = columns grid = Array(repeating: defaultValue, count: rows * columns) as! [T] } func indexIsValid(row: Int, column: Int) -> Bool { return row >= 0 && row < rows && column >= 0 && column < columns } subscript(row: Int, column: Int) -> T { get { assert(indexIsValid(row: row, column: column), "Index out of range") return grid[(row * columns) + column] } set { assert(indexIsValid(row: row, column: column), "Index out of range") grid[(row * columns) + column] = newValue } } } var matrix:Matrix<Bool> = Matrix(rows: 1000, columns: 1000,defaultValue:false) matrix[0,10] = true print(matrix[0,10])
var entry1 = Response(IdQuestion: 6510,IdProposition: 10,Time: 30) var entry2 = Response(IdQuestion: 8284,IdProposition: 10,Time: 30) Responses.append(entry1) Responses.append(entry2) let list = Responses.map { $0.asDictionary } let json = ["List":list,"IdSurvey":"102","IdUser":"iOSclient","UserInformation":"iOSClient"] let data : NSData = NSKeyedArchiver.archivedDataWithRootObject(json) NSJSONSerialization.isValidJSONObject(json) let myURL = NSURL(string: "http: let request = NSMutableURLRequest(URL: myURL) request.HTTPMethod = "POST" request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type") request.setValue("application/json", forHTTPHeaderField: "Accept") request.HTTPBody = data let task = NSURLSession.sharedSession().dataTaskWithRequest(request) { data, response, error in println(response) } task.resume()
let json: [String: Any] = ["title": "ABC", "dict": ["1":"First", "2":"Second"]] let jsonData = try? JSONSerialization.data(withJSONObject: json) let url = URL(string: "http: var request = URLRequest(url: url) request.httpMethod = "POST" request.httpBody = jsonData let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, error == nil else { print(error?.localizedDescription ?? "No data") return } let responseJSON = try? JSONSerialization.jsonObject(with: data, options: []) if let responseJSON = responseJSON as? [String: Any] { print(responseJSON) } } task.resume()
let json = [ Activity.KEY_IDSUBJECT : activity.idSubject, Activity.KEY_RECORDMODE : "3", Activity.KEY_LOCATION_LONGITUDE : "0",Activity.KEY_LOCATION_LATITUDE : "0", Activity.KEY_CHECKIN : String(activity.dateCheckIn), Activity.KEY_CHECKOUT : String(activity.dateCheckOut) ] do { let jsonData = try NSJSONSerialization.dataWithJSONObject(json, options: .PrettyPrinted) let url = NSURL(string: "https: let request = NSMutableURLRequest(URL: url) request.HTTPMethod = "POST" request.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type") request.HTTPBody = jsonData let task = NSURLSession.sharedSession().dataTaskWithRequest(request){ data, response, error in if error != nil{ print("Error -> \(error)") return } do { let result = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? [String:AnyObject] print("Result -> \(result)") } catch { print("Error -> \(error)") } } task.resume() return task } catch { print(error) }
func postRequest(username: String, password: String, completion: @escaping ([String: Any]?, Error?) -> Void) { let parameters = ["name": username, "password": password] let url = URL(string: "https: let session = URLSession.shared var request = URLRequest(url: url) request.httpMethod = "POST" do { request.httpBody = try JSONSerialization.data(withJSONObject: parameters, options: .prettyPrinted) } catch let error { print(error.localizedDescription) completion(nil, error) } request.addValue("application/json", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") let task = session.dataTask(with: request, completionHandler: { data, response, error in guard error == nil else { completion(nil, error) return } guard let data = data else { completion(nil, NSError(domain: "dataNilError", code: -100001, userInfo: nil)) return } do { guard let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any] else { completion(nil, NSError(domain: "invalidJSONTypeError", code: -100009, userInfo: nil)) return } print(json) completion(json, nil) } catch let error { print(error.localizedDescription) completion(nil, error) } }) task.resume() } @objc func submitAction(_ sender: UIButton) { postRequest(username: "username", password: "password") { (result, error) in if let result = result { print("success: \(result)") } else if let error = error { print("error: \(error.localizedDescription)") } }
let parameters = ["name": "username", "password": "password123"] Alamofire.request("https:
func HTTPPostJSON(url: String, data: NSData, callback: (String, String?) -> Void) { var request = NSMutableURLRequest(URL: NSURL(string: url)!) request.HTTPMethod = "POST" request.addValue("application/json",forHTTPHeaderField: "Content-Type") request.addValue("application/json",forHTTPHeaderField: "Accept") request.HTTPBody = data HTTPsendRequest(request, callback: callback) } func HTTPsendRequest(request: NSMutableURLRequest, callback: (String, String?) -> Void) { let task = NSURLSession.sharedSession() .dataTaskWithRequest(request) { (data, response, error) -> Void in if (error != nil) { callback("", error.localizedDescription) } else { callback(NSString(data: data, encoding: NSUTF8StringEncoding)! as String, nil) } } task.resume() } var data :Dictionary<String, AnyObject> = yourDictionaryData<-- var requestNSData:NSData = NSJSONSerialization.dataWithJSONObject(request, options:NSJSONWritingOptions(0), error: &err)! HTTPPostJSON("http: if error != nil{ return; } println(response); }
import UIKit import PlaygroundSupport PlaygroundPage.current.needsIndefiniteExecution = true let url = URL(string: "http: let jsonDict = ["firstName": "Jane", "lastName": "Doe"] let jsonData = try! JSONSerialization.data(withJSONObject: jsonDict, options: []) var request = URLRequest(url: url) request.httpMethod = "post" request.setValue("application/json", forHTTPHeaderField: "Content-Type") request.httpBody = jsonData let task = URLSession.shared.dataTask(with: request) { (data, response, error) in if let error = error { print("error:", error) return } do { guard let data = data else { return } guard let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: AnyObject] else { return } print("json:", json) } catch { print("error:", error) } } task.resume()
let url = URL(string: "url")! var request = URLRequest(url: url) request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type") request.setValue("application/json", forHTTPHeaderField: "Accept") request.httpMethod = "POST" let postString = "ChangeAccordingtoyourdata=\(paramOne)&ChangeAccordingtoyourdata2=\(paramTwo)" request.httpBody = postString.data(using: .utf8) let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, error == nil else { print("error=\(error)") return } if let httpStatus = response as? HTTPURLResponse, httpStatus.statusCode != 200 { print("statusCode should be 200, but is \(httpStatus.statusCode)") print("response = \(response)") SVProgressHUD.showError(withStatus: "Request has not submitted successfully.\nPlease try after some time") } let responseString = String(data: data, encoding: .utf8) print("responseString = \(responseString)") SVProgressHUD.showSuccess(withStatus: "Request has submitted successfully.\nPlease wait for a while") DispatchQueue.main.async { } } task.resume()
var request = URLRequest(url: URL(string: "http: request.httpMethod = "POST" let postString = "email=testname@gmail.com&password=1234567" request.httpBody = postString.data(using: .utf8) let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, error == nil else { print("error=(error)") return } if let httpStatus = response as? HTTPURLResponse, httpStatus.statusCode != 200 { print("statusCode should be 200, but is \(httpStatus.statusCode)") print("response = \(response)") } let responseString = String(data: data, encoding: .utf8) print("responseString = \(responseString)") } task.resume() }
let userlogin = User(username: username, password: password, deviceid:UIDevice.current.identifierForVendor!.uuidString) guard let uploadData = try? JSONEncoder().encode(userlogin) else { print("Error UploadData: ") return } let urlUser = URL(string: APPURL.apiURL)! var request = URLRequest(url: urlUser) request.httpMethod = "POST" request.setValue("application/json", forHTTPHeaderField: "Content-Type") var responseStatus = 0 let task = URLSession.shared.uploadTask(with: request, from: uploadData) { data, response, error in if let error = error { let code = (error as NSError).code print("Error:\(code) : \(error.localizedDescription)") completion(code) return } guard let response = response as? HTTPURLResponse else { print("Invalid response") return }
let json = [ "title":"ABC" , "dict": mapDict ] as [String : Any] let jsonData : NSData = NSKeyedArchiver.archivedData(withRootObject: json) as NSData let url = NSURL(string: "http: let request = NSMutableURLRequest(url: url as URL) request.httpMethod = "POST" request.httpBody = jsonData as Data let task = URLSession.shared.dataTask(with: request as URLRequest){ data,response,error in if error != nil{ return } do { let result = try JSONSerialization.jsonObject(with: data!, options: []) as? [String:AnyObject] print("Result",result!) } catch { print("Error -> \(error)") } } task.resume()
var request = URLRequest(url: URL(string: "your URL")!) request.httpMethod = "POST" let postString = String(format: "email=%@&lang=%@", arguments: [txt_emailVirify.text!, language!]) print(postString) emailString = txt_emailVirify.text! request.httpBody = postString.data(using: .utf8) request.addValue("delta141forceSEAL8PARA9MARCOSBRAHMOS", forHTTPHeaderField: "Authorization") request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, error == nil else { print("error=\(String(describing: error))") return } do { let dictionary = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as! NSDictionary print(dictionary) let status = dictionary.value(forKey: "status") as! String let sts = Int(status) DispatchQueue.main.async() { if sts == 200 { print(dictionary) } else { self.alertMessageOk(title: self.Alert!, message: dictionary.value(forKey: "message") as! String) } } } catch { print(error) } } task.resume()
var parameters = [String:String]() let apiToken = "Bearer \(ApiUtillity.sharedInstance.getUserData(key: "vAuthToken"))" let headers = ["Vauthtoken":apiToken] parameters = ["firstname":name,"lastname":last_name,"mobile":mobile_number,"email":emails_Address] Alamofire.request(ApiUtillity.sharedInstance.API(Join: "user/edit_profile"), method: .post, parameters: parameters, encoding: URLEncoding.default,headers:headers).responseJSON { response in debugPrint(response) if let json = response.result.value { let dict:NSDictionary = (json as? NSDictionary)! print(dict) let StatusCode = dict.value(forKey: "status") as! Int if StatusCode==200 { ApiUtillity.sharedInstance.dismissSVProgressHUDWithSuccess(success: "Success") let UserData = dict.value(forKey: "data") as! NSDictionary print(UserData) } else if StatusCode==401 { let ErrorDic:NSDictionary = dict.value(forKey: "message") as! NSDictionary let ErrorMessage = ErrorDic.value(forKey: "error") as! String } else { let ErrorDic:NSDictionary = dict.value(forKey: "message") as! NSDictionary let ErrorMessage = ErrorDic.value(forKey: "error") as! String } } else { ApiUtillity.sharedInstance.dismissSVProgressHUDWithError(error: "Something went wrong") } }
var a : String = "Cash" var b : String = "cash" if(a.caseInsensitiveCompare(b) == NSComparisonResult.OrderedSame){ println("voila") }
var a : String = "Cash" var b : String = "cash" if(a.caseInsensitiveCompare(b) == .orderedSame){ print("voila") }
let a = "Cash" let b = "cash" let c = a.caseInsensitiveCompare(b) == .orderedSame print(c)
var a = "Cash" var b = "cash" let result: NSComparisonResult = a.compare(b, options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil, locale: nil)
enum NSComparisonResult : Int { case OrderedAscending case OrderedSame case OrderedDescending }
if result == .OrderedSame { println("equal") } else { println("not equal") }
func equalIgnoringCase(a:String, b:String) -> Bool { return a.lowercaseString == b.lowercaseString }
let a: String = "Cash" let b: String = "cash" if a.caseInsensitiveCompare(b) == .orderedSame { }
var a = ‚ÄúCash‚Äù var b = ‚ÄúCASh‚Äù if a.uppercaseString == b.uppercaseString{ }
extension String{ func equalsIgnoreCase(string:String) -> Bool{ return self.uppercaseString == string.uppercaseString } } if "Something ELSE".equalsIgnoreCase("something Else"){ print("TRUE") }
var selectPhone = [String]() if selectPhone.index(where: {$0.caseInsensitiveCompare(contactsList[indexPath.row].phone!) == .orderedSame}) != nil { print("Same value") } else { print("Not the same") }
extension String { func equalIgnoreCase(_ compare:String) -> Bool { return self.uppercased() == compare.uppercased() } }
print("lala".equalIgnoreCase("LALA")) print("l4la".equalIgnoreCase("LALA")) print("laLa".equalIgnoreCase("LALA")) print("LALa".equalIgnoreCase("LALA"))
import UIKit extension String { func caseInsensitiveEquals<T>(_ otherString: T?) -> Bool where T : StringProtocol { guard let otherString = otherString else { return false } return self.caseInsensitiveCompare(otherString) == ComparisonResult.orderedSame } } "string 1".caseInsensitiveEquals("string 2") "thingy".caseInsensitiveEquals("thingy") let nilString1: String? = nil "woohoo".caseInsensitiveEquals(nilString1)
infix operator ~= func ~=(lhs: String, rhs: String) -> Bool { return lhs.caseInsensitiveCompare(rhs) == .orderedSame }
let low = "hej" let up = "Hej" func test() { if low ~= up { print("same") } else { print("not same") } } test()
var a = "cash" var b = "Cash" if a.localizedCaseInsensitiveContains(b) { print("Identical") } else { print("Non Identical") }
public class Stuff { public enum logLevel: Int { case info = 1 case debug = 2 case warn = 3 case error = 4 case fatal = 5 case none = 6 public func description() -> String { switch self { case .info: return "‚ùì" case .debug: return "‚ú≥Ô∏è" case .warn: return "‚ö†Ô∏è" case .error: return "üö´" case .fatal: return "üÜò" case .none: return "" } } } public static var minimumLogLevel: logLevel = .info public static func print<T>(_ object: T, _ level: logLevel = .debug, filename: String = if level.rawValue >= Stuff.minimumLogLevel.rawValue { let dateFormatter = DateFormatter() dateFormatter.dateFormat = "MM/dd/yyyy HH:mm:ss:SSS" let process = ProcessInfo.processInfo let threadId = "?" let file = URL(string: filename)?.lastPathComponent ?? "" Swift.print("\n\(level.description()) .\(level) ‚è± \(dateFormatter.string(from: Foundation.Date())) üì± \(process.processName) [\(process.processIdentifier):\(threadId)] üìÇ \(file)(\(line)) ‚öôÔ∏è \(funcname) ‚û°Ô∏è\r\t\(object)") } } }
Stuff.print("Just as the standard print but now with detailed information") Stuff.print("Now it Stuff.print("Or even an error", .error) Stuff.minimumLogLevel = .error Stuff.print("Now you won Stuff.print("Only errors are shown", .error) Stuff.minimumLogLevel = .none Stuff.print("Or if it
‚ú≥Ô∏è .debug ‚è± 02/13/2017 09:52:51:852 üì± xctest [18960:?] üìÇ PrintStuffTests.swift(15) ‚öôÔ∏è testExample() ‚û°Ô∏è Just as the standard print but now with detailed information ‚ö†Ô∏è .warn ‚è± 02/13/2017 09:52:51:855 üì± xctest [18960:?] üìÇ PrintStuffTests.swift(16) ‚öôÔ∏è testExample() ‚û°Ô∏è Now it üö´ .error ‚è± 02/13/2017 09:52:51:855 üì± xctest [18960:?] üìÇ PrintStuffTests.swift(17) ‚öôÔ∏è testExample() ‚û°Ô∏è Or even an error üö´ .error ‚è± 02/13/2017 09:52:51:855 üì± xctest [18960:?] üìÇ PrintStuffTests.swift(21) ‚öôÔ∏è testExample() ‚û°Ô∏è Only errors are shown
func pretty_function(_ file: String = let fileString: NSString = NSString(string: file) if Thread.isMainThread { print("file:\(fileString.lastPathComponent) function:\(function) line:\(line) [M]") } else { print("file:\(fileString.lastPathComponent) function:\(function) line:\(line) [T]") } }
NSLog("[%@ %@]", reflect(self).summary, __FUNCTION__)
2014-08-24 08:46:26.606 SwiftLessons[427:16981938] [C12SwiftLessons24HelloWorldViewController (has 2 children) goodbyeActiongoodbyeAction]
func intFromString(str: String) -> Int { var result = 0; for chr in str.unicodeScalars { if (chr.isDigit()) { let value = chr - "0"; result *= 10; result += value; } else { break; } } return result; } @IBAction func flowAction(AnyObject) { let cname = _stdlib_getTypeName(self) var parse = cname.substringFromIndex(1) var count = self.intFromString(parse) var countStr = String(format: "%d", count) parse = parse.substringFromIndex(countStr.lengthOfBytesUsingEncoding(NSUTF8StringEncoding)) let appName = parse.substringToIndex(count) parse = parse.substringFromIndex(count); count = self.intFromString(parse) countStr = String(format: "%d", count) parse = parse.substringFromIndex(countStr.lengthOfBytesUsingEncoding(NSUTF8StringEncoding)) let className = parse.substringToIndex(count) NSLog("app: %@ class: %@ func: %@", appName, className, __FUNCTION__) }
2014-08-24 09:52:12.159 SwiftLessons[1397:17145716] app: SwiftLessons class: ViewController func: flowAction
func ZYLog(_ object: Any?, filename: String = print("****\(Date()) \(filename)(\(line)) \(funcname):\r\(object ?? "nil")\n") }
func ZYLog<T>(_ object: T?, filename: String = print("****\(Date()) \(filename)(\(line)) \(funcname):\r\(object)\n") }
func ZYLog<T>(object: T, filename: String = __FILE__, line: Int = __LINE__, funcname: String = __FUNCTION__) { println("****\(filename.lastPathComponent)(\(line)) \(funcname):\r\(object)\n") }
****ZYHttpSessionManager.swift(78) POST(_:parameters:success:failure:): [POST] user/login, { "auth_key" = xxx; "auth_type" = 0; pwd = xxx; user = "xxx"; } ****PointViewController.swift(162) loadData(): review/list [limit: 30, skip: 0] ****ZYHttpSessionManager.swift(66) GET(_:parameters:success:failure:): [GET] review/list, { "auth_key" = xxx; uuid = "xxx"; }
func LogW(msg:String, function: String = __FUNCTION__, file: String = __FILE__, line: Int = __LINE__){ print("[WARNING]\(makeTag(function, file: file, line: line)) : \(msg)") } private func makeTag(function: String, file: String, line: Int) -> String{ let url = NSURL(fileURLWithPath: file) let className:String! = url.lastPathComponent == nil ? file: url.lastPathComponent! return "\(className) \(function)[\(line)]" }
func logFunctionName(file:String = __FILE__, fnc:String = __FUNCTION__, line:(Int)=__LINE__) { var className = file.lastPathComponent.componentsSeparatedByString(".") println("\(className[0]):\(fnc):\(line)")
import UIKit func logFunctionName(file:NSString = __FILE__, fnc:String = __FUNCTION__){ println("\(file.lastPathComponent):\(fnc)") }
public func LogFunction<T>(object: T, filename: String = let dateFormatter = DateFormatter() dateFormatter.dateFormat = "MM/dd/yyyy HH:mm:ss:SSS" let process = ProcessInfo.processInfo() let threadId = "?" print("\(dateFormatter.string(from:Date())) \(process.processName) [\(process.processIdentifier):\(threadId)] \(filename)(\(line)) \(funcname)::: \(object)") }
func trace(fileName:String = print("filename: \(fileName.components(separatedBy: "/").last!) function: \(functionName) line: } filename: ViewController.swift function: viewDidLoad() line:
func doIt(code: @noescape () -> ()) { code() doItMore(code) doItMore { code() } /* what we CANNOT do ***** dispatch_async(dispatch_get_main_queue(), code) let _code:() -> () = code let __code = { code() } */ } func doItMore(code: @noescape () -> ()) {}
func doIt(code: @noescape () -> ()) { code() } class Bar { var i = 0 func some() { doIt { println(i) } } } let bar = Bar() bar.some()
- (void)foo:(UIViewController<UITableViewDataSource> *)vc;
func foo<T: UIViewController & UITableViewDataSource>(vc: T) { ..... }
func foo<T: UIViewController>(vc:T) where T:UITableViewDataSource { .... }
func foo<T: UIViewController where T: UITableViewDataSource>(vc: T) { let view = vc.view let sections = vc.numberOfSectionsInTableView?(tableView) }
func someFunction<C1: SomeClass where C1:SomeProtocol>(inParam: C1) {}
func itemsMatch<C1: SomeProtocol, C2: SomeProtocol where C1.ItemType == C2.ItemType, C1.ItemType: SomeOtherProtocol>(foo: C1, bar: C2) -> Bool { return true }
func foo(_ dataSource: UITableViewDataSource) { self.tableView.dataSource = dataSource } func foo(_ delegateAndDataSource: UITableViewDelegate & UITableViewDataSource) { }
@property(nonatomic, readonly) NSObject<UITextDocumentProxy> *textDocumentProxy;
protocol MyProtocol { func getTableViewDataSource() -> UITableViewDataSource func getViewController() -> UIViewController } class MyVC : UIViewController, UITableViewDataSource, MyProtocol { func getTableViewDataSource() -> UITableViewDataSource { return self } func getViewController() -> UIViewController { return self } } func foo(_ vc:MyProtocol) { vc.getTableViewDataSource() vc.getViewController() }
[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; self.navigationController.navigationBar.shadowImage = [UIImage new]; self.navigationController.navigationBar.translucent = YES; self.navigationController.view.backgroundColor = [UIColor clearColor];
self.navigationController?.navigationBar.setBackgroundImage(UIImage(), for: .default) self.navigationController?.navigationBar.shadowImage = UIImage() self.navigationController?.navigationBar.isTranslucent = true self.navigationController?.view.backgroundColor = .clear
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { UINavigationBar.appearance().setBackgroundImage(UIImage(), for: .default) UINavigationBar.appearance().shadowImage = UIImage() UINavigationBar.appearance().backgroundColor = .clear UINavigationBar.appearance().isTranslucent = true return true }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { UINavigationBar.appearance().setBackgroundImage(UIImage(), forBarMetrics: .Default) UINavigationBar.appearance().shadowImage = UIImage() UINavigationBar.appearance().backgroundColor = UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.0) UINavigationBar.appearance().translucent = true return true }
extension UINavigationBar { func transparentNavigationBar() { self.setBackgroundImage(UIImage(), for: .default) self.shadowImage = UIImage() self.isTranslucent = true } }
let navBarAppearance = UINavigationBar.appearance() let colorImage = UIImage.imageFromColor(UIColor.morselPink(), frame: CGRectMake(0, 0, 340, 64)) navBarAppearance.setBackgroundImage(colorImage, forBarMetrics: .Default)
imageFromColor(color: UIColor, frame: CGRect) -> UIImage { UIGraphicsBeginImageContextWithOptions(frame.size, false, 0) color.setFill() UIRectFill(frame) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image }
let bar:UINavigationBar! = self.navigationController?.navigationBar self.title = "Whatever..." bar.setBackgroundImage(UIImage(), forBarMetrics: UIBarMetrics.Default) bar.shadowImage = UIImage() bar.alpha = 0.0
navigationController?.navigationBar.backgroundColor = UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 0.5)
override func viewDidLoad() { super.viewDidLoad() self.navigationController?.navigationBar.setBackgroundImage(UIImage(), for: UIBarMetrics.default) self.navigationController?.navigationBar.shadowImage = UIImage() self.navigationController?.navigationBar.isTranslucent = true }
override func viewDidLoad() { super.viewDidLoad() navBar.setBackgroundImage(UIImage(), for: UIBarMetrics.default) navBar.shadowImage = UIImage() navBar.navigationBar.isTranslucent = true }
[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; self.navigationController.navigationBar.shadowImage = [UIImage new]; self.navigationController.navigationBar.translucent = YES; self.navigationController.view.backgroundColor = [UIColor clearColor]; UIToolbar* blurredView = [[UIToolbar alloc] initWithFrame:self.navigationController.navigationBar.bounds]; [blurredView setBarStyle:UIBarStyleBlack]; [blurredView setBarTintColor:[UIColor redColor]]; [self.navigationController.navigationBar insertSubview:blurredView atIndex:0];
+ (void)setNavigationBarColor:(UINavigationController *)navigationController color:(UIColor*) color { [navigationController setNavigationBarHidden:false animated:false]; [navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; [navigationController.navigationBar setShadowImage:[UIImage new]]; [navigationController.navigationBar setTranslucent:true]; [navigationController.view setBackgroundColor:color]; [navigationController.navigationBar setBackgroundColor:color]; }
class func setNavigationBarColor(navigationController : UINavigationController?, color : UIColor) { navigationController?.setNavigationBarHidden(false, animated: false) navigationController?.navigationBar .setBackgroundImage(UIImage(), forBarMetrics: UIBarMetrics.Default) navigationController?.navigationBar.shadowImage = UIImage() navigationController?.navigationBar.translucent = true navigationController?.view.backgroundColor = color navigationController?.navigationBar.backgroundColor = color }
if change { navigationController?.navigationBar.isTranslucent = false self.navigationController?.navigationBar.backgroundColor = UIColor(displayP3Red: 255/255, green: 206/255, blue: 24/255, alpha: 1) navigationController?.navigationBar.barTintColor = UIColor(displayP3Red: 255/255, green: 206/255, blue: 24/255, alpha: 1) } else { navigationController?.navigationBar.isTranslucent = true navigationController?.navigationBar.setBackgroundImage(backgroundImage, for: .default) navigationController?.navigationBar.backgroundColor = .clear navigationController?.navigationBar.barTintColor = .clear }
NSMutableDictionary *cellHeightsDictionary; cellHeightsDictionary = @{}.mutableCopy; tableView.rowHeight = UITableViewAutomaticDimension; - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath { [cellHeightsDictionary setObject:@(cell.frame.size.height) forKey:indexPath]; } - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { NSNumber *height = [cellHeightsDictionary objectForKey:indexPath]; if (height) return height.doubleValue; return UITableViewAutomaticDimension; }
var cellHeights: [IndexPath : CGFloat] = [:] func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { cellHeights[indexPath] = cell.frame.size.height } func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat { return cellHeights[indexPath] ?? 70.0 }
func viewDidLoad() { super.viewDidLoad() tableView.estimatedRowHeight = 100 }
func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { return 100 }
var cellHeightsDictionary: [IndexPath: CGFloat] = [:]
func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { self.cellHeightsDictionary[indexPath] = cell.frame.size.height } func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat { if let height = self.cellHeightsDictionary[indexPath] { return height } return UITableViewAutomaticDimension }
tableView.reloadRowsAtIndexPaths(indexPathArray, withRowAnimation: UITableViewRowAnimation.None)
let lastContentOffset = tableView.contentOffset tableView.beginUpdates() tableView.endUpdates() tableView.layer.removeAllAnimations() tableView.setContentOffset(lastContentOffset, animated: false)
extension UITableView { func reloadWithoutAnimation() { let lastScrollOffset = contentOffset beginUpdates() endUpdates() layer.removeAllAnimations() setContentOffset(lastScrollOffset, animated: false) } }
func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat { return self.cellHeightsDictionary[indexPath] ?? UITableViewAutomaticDimension }
func reloadTableOnMain(with offset: CGPoint = CGPoint.zero){ DispatchQueue.main.async { [weak self] () in self?.tableView.reloadData() self?.tableView.layoutIfNeeded() self?.tableView.contentOffset = offset } }
someFunctionThatMakesChangesToYourDatasource() let offset = tableview.contentOffset reloadTableOnMain(with: offset)
extension UITableView { func reloadWithoutAnimation() { let lastScrollOffset = contentOffset reloadData() layoutIfNeeded() setContentOffset(lastScrollOffset, animated: false) } }
tableView.rowHeight = UITableView.automaticDimension
tableView.register(UINib(nibName: "YourTableViewCell", bundle: nil), forCellReuseIdentifier: "YourTableViewCell") tableView.register(UINib(nibName: "YourSecondTableViewCell", bundle: nil), forCellReuseIdentifier: "YourSecondTableViewCell") tableView.register(UINib(nibName: "YourThirdTableViewCell", bundle: nil), forCellReuseIdentifier: "YourThirdTableViewCell")
func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat { if indexPath.row == 0 { let cell = Bundle.main.loadNibNamed("YourTableViewCell", owner: self, options: nil)?.first as! YourTableViewCell return cell.layer.frame.height } else if indexPath.row == 1 { let cell = Bundle.main.loadNibNamed("YourSecondTableViewCell", owner: self, options: nil)?.first as! YourSecondTableViewCell return cell.layer.frame.height } else { let cell = Bundle.main.loadNibNamed("YourThirdTableViewCell", owner: self, options: nil)?.first as! YourThirdTableViewCell return cell.layer.frame.height } }
func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat { if indexPath.row == 0 { return 400 } else if indexPath.row == 1 { return 231 } else { return 216 } }
func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat { let cellHeight = CGFloat(checkIsCleanResultSection(index: indexPath.row) ? 130 : 160) return Helper.makeDeviceSpecificCommonSize(cellHeight) }
func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat { let cellHeight = CGFloat(checkIsCleanResultSection(index: indexPath.row) ? 130 : 160) return Helper.makeDeviceSpecificCommonSize(cellHeight) }
override func viewDidLoad() { super.viewDidLoad() loginButton.backgroundColor = UIColor.orangeColor() var request = NSFetchRequest(entityName: "UserData") request.returnsObjectsAsFaults = false var appDel:AppDelegate = (UIApplication.sharedApplication().delegate as AppDelegate) var context:NSManagedObjectContext = appDel.managedObjectContext! var results:NSArray = context.executeFetchRequest(request, error: nil)! if(results.count <= 0){ print("Inga resultat") } else { print("SWITCH VIEW PLOX") let internVC = self.storyboard?.instantiateViewControllerWithIdentifier("internVC") as internViewController self.presentViewController(internVC, animated: true, completion: nil) } }
- (UIViewController*) topMostController { UIViewController *topController = [UIApplication sharedApplication].keyWindow.rootViewController; while (topController.presentedViewController) { topController = topController.presentedViewController; } return topController; }
let storyboard = UIStoryboard(name: "Main", bundle: nil) let vc = storyboard?.instantiateViewController(withIdentifier: "MainAppStoryboard") as! TabbarController present(vc, animated: false, completion: nil)
let storyboard = UIStoryboard(name: "Main", bundle: nil) let view = storyboard.instantiateViewController(withIdentifier: "MainAppStoryboard") as UIViewController let appDelegate = UIApplication.shared.delegate as! AppDelegate appDelegate.window?.rootViewController = view
override func viewDidLoad() { super.viewDidLoad() perform( } @objc private func presentExampleController() { let exampleStoryboard = UIStoryboard(named: "example", bundle: nil) let exampleVC = storyboard.instantiateViewController(withIdentifier: "ExampleVC") as! ExampleVC present(exampleVC, animated: true) }
func topMostController() -> UIViewController { var topController: UIViewController = UIApplication.shared.keyWindow!.rootViewController! while (topController.presentedViewController != nil) { topController = topController.presentedViewController! } return topController }
let topVC = topMostController() let vcToPresent = self.storyboard!.instantiateViewController(withIdentifier: "YourVCStoryboardID") as! YourViewController topVC.present(vcToPresent, animated: true, completion: nil)
func topMostController() -> UIViewController { var topController: UIViewController = UIApplication.sharedApplication().keyWindow!.rootViewController! while (topController.presentedViewController != nil) { topController = topController.presentedViewController! } return topController }
func topMostController() -> UIViewController { var topController: UIViewController = UIApplication.shared.keyWindow!.rootViewController! while (topController.presentedViewController != nil) { topController = topController.presentedViewController! } return topController }
public static func getTopViewController() -> UIViewController?{ if var topController = UIApplication.shared.keyWindow?.rootViewController { while (topController.presentedViewController != nil) { topController = topController.presentedViewController! } return topController } return nil}
let storyboard = UIStoryboard(name: "test", bundle: nil) let vc = storyboard.instantiateViewController(withIdentifier: "teststoryboard") as UIViewController UIApplication.shared.keyWindow?.rootViewController?.present(vc, animated: true, completion: nil)
if var topController = UIApplication.shared.keyWindow?.rootViewController { while (topController.presentedViewController != nil) { topController = topController.presentedViewController! } }
protocol TopUIViewController { func topUIViewController() -> UIViewController? } extension UIWindow : TopUIViewController { func topUIViewController() -> UIViewController? { if let rootViewController = self.rootViewController { return self.recursiveTopUIViewController(from: rootViewController) } return nil } private func recursiveTopUIViewController(from: UIViewController?) -> UIViewController? { if let topVC = from?.topUIViewController() { return recursiveTopUIViewController(from: topVC) ?? from } return from } } extension UIViewController : TopUIViewController { @objc open func topUIViewController() -> UIViewController? { return self.presentedViewController } } extension UINavigationController { override open func topUIViewController() -> UIViewController? { return self.visibleViewController } } extension UITabBarController { override open func topUIViewController() -> UIViewController? { return self.selectedViewController ?? presentedViewController } }
viewController.modalPresentationStyle = UIModalPresentationStyle.currentContext
[UIApplication sharedApplication].statusBarFrame.size.height.
UIApplication.sharedApplication().statusBarFrame.size.height
let app = UIApplication.sharedApplication() let height = app.statusBarFrame.size.height
var screenStatusBarHeight: CGFloat { return UIApplication.sharedApplication().statusBarFrame.height }
struct Screen { static var width: CGFloat { return UIScreen.main.bounds.width } static var height: CGFloat { return UIScreen.main.bounds.height } static var statusBarHeight: CGFloat { return UIApplication.shared.statusBarFrame.size.height } }
- (void)useALoadOfNumbers { for (int j = 0; j < 10000; ++j) { @autoreleasepool { for (int i = 0; i < 10000; ++i) { NSNumber *number = [NSNumber numberWithInt:(i+j)]; NSLog(@"number = %p", number); } } } }
func useManyImages() { let filename = pathForResourceInBundle for _ in 0 ..< 5 { autoreleasepool { for _ in 0 ..< 1000 { let image = NSImage(contentsOfFile: filename) } } } }
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if segue.identifier == "MySegueID" { if let destination = segue.destinationViewController as? SecondController { destination.myInformation = self.myInformation } } }
func showNextController() { let destination = SecondController(nibName: "SecondController", bundle: NSBundle.mainBundle()) destination.myInformation = self.myInformation self.showViewController(destination, sender: self) }
class MyCustomTabController: UITabBarController { var myInformation: [String: AnyObject]? }
if let tbc = self.tabBarController as? MyCustomTabController { }
if let nc = self.navigationController as? MyCustomNavController { }
var someString: String? var someOtherString: String? var someInt: Int?
let theInt = DataContainerSingleton.sharedDataContainer.someInt
DataContainerSingleton.sharedDataContainer.someInt = 3
goToBackgroundObserver = NSNotificationCenter.defaultCenter().addObserverForName( UIApplicationDidEnterBackgroundNotification, object: nil, queue: nil) { (note: NSNotification!) -> Void in let defaults = NSUserDefaults.standardUserDefaults() defaults.setObject( self.someString, forKey: DefaultsKeys.someString) defaults.setObject( self.someOtherString, forKey: DefaultsKeys.someOtherString) defaults.setObject( self.someInt, forKey: DefaultsKeys.someInt) defaults.synchronize() }
let defaults = NSUserDefaults.standardUserDefaults() someString = defaults.objectForKey(DefaultsKeys.someString) as! String? someOtherString = defaults.objectForKey(DefaultsKeys.someOtherString) as! String? someInt = defaults.objectForKey(DefaultsKeys.someInt) as! Int?
struct DefaultsKeys { static let someString = "someString" static let someOtherString = "someOtherString" static let someInt = "someInt" }
override func viewWillAppear(animated: Bool) { let value = DataContainerSingleton.sharedDataContainer.someInt ?? 0 textField.text = "\(value)" }
func textFieldShouldEndEditing(textField: UITextField) -> Bool { DataContainerSingleton.sharedDataContainer.someInt = textField.text!.toInt() return true }
@IBAction func unWindSeague (_ sender : UIStoryboardSegue) { if sender.source is ViewControllerB { if let _ = sender.source as? ViewControllerB { self.textLabel.text = "Came from B = B->A , B exited" } } } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.destination is ViewControllerB { if let vc = segue.destination as? ViewControllerB { vc.dataStr = "Comming from A View Controller" } } }
protocol SendDataFromDelegate { func sendData(data : String) } import UIKit class ViewControllerD: UIViewController { @IBOutlet weak var textLabelD: UILabel! var delegate : SendDataFromDelegate? override func viewDidLoad() { super.viewDidLoad() textLabelD.text = "Child View Controller" } @IBAction func btnDismissTapped (_ sender : UIButton) { textLabelD.text = "Data Sent Successfully to View Controller C using Delegate Approach" self.delegate?.sendData(data:textLabelD.text! ) _ = self.dismiss(animated: true, completion:nil) } }
import UIKit class ViewControllerC: UIViewController , SendDataFromDelegate { @IBOutlet weak var textLabelC: UILabel! override func viewDidLoad() { super.viewDidLoad() } @IBAction func btnPushToViewControllerDTapped( _ sender : UIButton) { if let vcD = self.storyboard?.instantiateViewController(withIdentifier: "ViewControllerD") as? ViewControllerD { vcD.delegate = self self.present(vcD, animated: true, completion: nil) } } func sendData(data: String) { self.textLabelC.text = data } }
func prepare(for segue: UIStoryboardSegue, sender: Any?)
func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool)
class MyNavigationController: UINavigationController, UINavigationControllerDelegate { override func viewDidLoad() { self.delegate = self } func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) { } }
protocol DataController { var someInt : Int {get set} var someString : String {get set} }
class SpecificDataController : DataController { var someInt : Int = 5 var someString : String = "Hello data" }
class ViewController : UIViewController { var dataController : DataController? ... }
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { if let viewController = self.window?.rootViewController as? ViewController { viewController.dataController = SpecificDataController() } return true }
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { ... }
class AppSession: NSObject { static let shared = SessionManager() var username = "Duncan" } class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() print(AppSession.shared.username) } }
extension Notification.Name { static let loggedOut = Notification.Name("loggedOut") } @IBAction func logoutAction(_ sender: Any) { NotificationCenter.default.post(name: .loggedOut, object: nil) } NotificationCenter.default.addObserver(forName: .loggedOut, object: nil, queue: OperationQueue.main) { (notify) in print("User logged out") }
public func highlightValues(highs: [ChartHighlight]?) { _indicesToHightlight = highs ?? [ChartHighlight](); setNeedsDisplay(); }
func secondsToHoursMinutesSeconds (seconds : Int) -> (Int, Int, Int) { return (seconds / 3600, (seconds % 3600) / 60, (seconds % 3600) % 60) }
func printSecondsToHoursMinutesSeconds (seconds:Int) -> () { let (h, m, s) = secondsToHoursMinutesSeconds (seconds) print ("\(h) Hours, \(m) Minutes, \(s) Seconds") }
func secondsToHoursMinutesSeconds (seconds : Double) -> (Double, Double, Double) { let (hr, minf) = modf (seconds / 3600) let (min, secf) = modf (60 * minf) return (hr, min, 60 * secf) }
let interval = 27005 let formatter = DateComponentsFormatter() formatter.allowedUnits = [.hour, .minute, .second] formatter.unitsStyle = .full let formattedString = formatter.string(from: TimeInterval(interval))! print(formattedString)
func hmsFrom(seconds: Int, completion: @escaping (_ hours: Int, _ minutes: Int, _ seconds: Int)->()) { completion(seconds / 3600, (seconds % 3600) / 60, (seconds % 3600) % 60) } func getStringFrom(seconds: Int) -> String { return seconds < 10 ? "0\(seconds)" : "\(seconds)" }
var seconds: Int = 100 hmsFrom(seconds: seconds) { hours, minutes, seconds in let hours = getStringFrom(seconds: hours) let minutes = getStringFrom(seconds: minutes) let seconds = getStringFrom(seconds: seconds) print("\(hours):\(minutes):\(seconds)") }
extension Double { func asString(style: DateComponentsFormatter.UnitsStyle) -> String { let formatter = DateComponentsFormatter() formatter.allowedUnits = [.hour, .minute, .second, .nanosecond] formatter.unitsStyle = style guard let formattedString = formatter.string(from: self) else { return "" } return formattedString } }
10000.asString(style: .positional) 10000.asString(style: .abbreviated) 10000.asString(style: .short) 10000.asString(style: .full) 10000.asString(style: .spellOut) 10000.asString(style: .brief)
struct StopWatch { var totalSeconds: Int var years: Int { return totalSeconds / 31536000 } var days: Int { return (totalSeconds % 31536000) / 86400 } var hours: Int { return (totalSeconds % 86400) / 3600 } var minutes: Int { return (totalSeconds % 3600) / 60 } var seconds: Int { return totalSeconds % 60 } var hoursMinutesAndSeconds: (hours: Int, minutes: Int, seconds: Int) { return (hours, minutes, seconds) } } let watch = StopWatch(totalSeconds: 27005 + 31536000 + 86400) print(watch.years) print(watch.days) print(watch.hours) print(watch.minutes) print(watch.seconds) print(watch.hoursMinutesAndSeconds)
extension StopWatch { var simpleTimeString: String { let hoursText = timeText(from: hours) let minutesText = timeText(from: minutes) let secondsText = timeText(from: seconds) return "\(hoursText):\(minutesText):\(secondsText)" } private func timeText(from number: Int) -> String { return number < 10 ? "0\(number)" : "\(number)" } } print(watch.simpleTimeString)
func seconds2Timestamp(intSeconds:Int)->String { let mins:Int = intSeconds/60 let hours:Int = mins/60 let secs:Int = intSeconds%60 let strTimestamp:String = ((hours<10) ? "0" : "") + String(hours) + ":" + ((mins<10) ? "0" : "") + String(mins) + ":" + ((secs<10) ? "0" : "") + String(secs) return strTimestamp }
extension CMTime { var durationText:String { let totalSeconds = CMTimeGetSeconds(self) let hours:Int = Int(totalSeconds.truncatingRemainder(dividingBy: 86400) / 3600) let minutes:Int = Int(totalSeconds.truncatingRemainder(dividingBy: 3600) / 60) let seconds:Int = Int(totalSeconds.truncatingRemainder(dividingBy: 60)) if hours > 0 { return String(format: "%i:%02i:%02i", hours, minutes, seconds) } else { return String(format: "%02i:%02i", minutes, seconds) } } }
let dTotalSeconds = self.player.currentTime() playingCurrentTime = dTotalSeconds.durationText
func formatSecondsToString(_ seconds: TimeInterval) -> String { if seconds.isNaN { return "00:00" } let Min = Int(seconds / 60) let Sec = Int(seconds.truncatingRemainder(dividingBy: 60)) return String(format: "%02d:%02d", Min, Sec) }
func convert<MeasurementType: BinaryInteger>(measurementValue: MeasurementType, unitDuration: UnitDuration) -> (MeasurementType, MeasurementType) { let measurementSeconds = Measurement<UnitDuration>(value: Double(measurementValue), unit: .seconds) let secondsCount = MeasurementType(measurementSeconds.converted(to: unitDuration).value) let measurementCurrentUnit = Measurement(value: Double(secondsCount), unit: unitDuration) let currentUnitCount = MeasurementType(measurementCurrentUnit.converted(to: .seconds).value) return (secondsCount, measurementValue - currentUnitCount) }
func convertSecondsToHoursMinutesSeconds<MeasurementType: BinaryInteger>(seconds: MeasurementType) -> (MeasurementType, MeasurementType, MeasurementType) { let hoursAndRestSeconds = convert(measurementValue: seconds, unitDuration: .hours) let minutesAndRestSeconds = convert(measurementValue: hoursAndRestSeconds.1, unitDuration: .minutes) return (hoursAndRestSeconds.0, minutesAndRestSeconds.0, minutesAndRestSeconds.1) }
let result = convertSecondsToHoursMinutesSeconds(seconds: 27005) print("\(result.0) Hours \(result.1) Minutes \(result.2) Seconds")
extension Double { func secondsToHoursMinutesSeconds () -> (Int?, Int?, Int?) { let hrs = self / 3600 let mins = (self.truncatingRemainder(dividingBy: 3600)) / 60 let seconds = (self.truncatingRemainder(dividingBy:3600)).truncatingRemainder(dividingBy:60) return (Int(hrs) > 0 ? Int(hrs) : nil , Int(mins) > 0 ? Int(mins) : nil, Int(seconds) > 0 ? Int(seconds) : nil) } func printSecondsToHoursMinutesSeconds () -> String { let time = self.secondsToHoursMinutesSeconds() switch time { case (nil, let x? , let y?): return "\(x) min \(y) sec" case (nil, let x?, nil): return "\(x) min" case (let x?, nil, nil): return "\(x) hr" case (nil, nil, let x?): return "\(x) sec" case (let x?, nil, let z?): return "\(x) hr \(z) sec" case (let x?, let y?, nil): return "\(x) hr \(y) min" case (let x?, let y?, let z?): return "\(x) hr \(y) min \(z) sec" default: return "n/a" } } } let tmp = 3213123.printSecondsToHoursMinutesSeconds()
let hours = time / 3600 let minutes = (time / 60) % 60 let seconds = time % 60 return String(format: "%0.2d:%0.2d:%0.2d", hours, minutes, seconds)
extension Double { var formattedTime: String { var formattedTime = "0:00" if self > 0 { let hours = Int(self / 3600) let minutes = Int(truncatingRemainder(dividingBy: 3600) / 60) formattedTime = String(hours) + ":" + (minutes < 10 ? "0" + String(minutes) : String(minutes)) } return formattedTime } }
let (m, s) = { (secs: Int) -> (Int, Int) in return ((secs % 3600) / 60, (secs % 3600) % 60) }(299)
extension Double { func stringFromInterval() -> String { let timeInterval = Int(self) let millisecondsInt = Int((self.truncatingRemainder(dividingBy: 1)) * 1000) let secondsInt = timeInterval % 60 let minutesInt = (timeInterval / 60) % 60 let hoursInt = (timeInterval / 3600) % 24 let daysInt = timeInterval / 86400 let milliseconds = "\(millisecondsInt)ms" let seconds = "\(secondsInt)s" + " " + milliseconds let minutes = "\(minutesInt)m" + " " + seconds let hours = "\(hoursInt)h" + " " + minutes let days = "\(daysInt)d" + " " + hours if daysInt > 0 { return days } if hoursInt > 0 { return hours } if minutesInt > 0 { return minutes } if secondsInt > 0 { return seconds } if millisecondsInt > 0 { return milliseconds } return "" } }
extension Int { var toAudioString: String { let h = self / 3600 let m = (self % 3600) / 60 let s = (self % 3600) % 60 return h > 0 ? String(format: "%1d:%02d:%02d", h, m, s) : String(format: "%1d:%02d", m, s) } }
func seconds2Timestamp(intSeconds:Int)->String { let mins:Int = (intSeconds/60)%60 let hours:Int = intSeconds/3600 let secs:Int = intSeconds%60 let strTimestamp:String = ((hours<10) ? "0" : "") + String(hours) + ":" + ((mins<10) ? "0" : "") + String(mins) + ":" + ((secs<10) ? "0" : "") + String(secs) return strTimestamp }
self.navigationController?.navigationBar.barTintColor = UIColor(rgba: " self.navigationController?.navigationBar.setBackgroundImage(UIImage(named: ""), forBarMetrics: UIBarMetrics.Default) self.navigationController?.navigationBar.shadowImage = UIImage(named: "")
self.navigationController?.navigationBar.setBackgroundImage(UIImage(named: ""), forBarMetrics: UIBarMetrics.Default) self.navigationController?.navigationBar.shadowImage = UIImage(named: "")
self.navigationController?.navigationBar.setBackgroundImage(UIImage(), for: UIBarMetrics.default) self.navigationController?.navigationBar.shadowImage = UIImage()
for parent in self.navigationController!.navigationBar.subviews { for childView in parent.subviews { if(childView is UIImageView) { childView.removeFromSuperview() } } }
UINavigationBar.appearance().shadowImage = UIImage() UINavigationBar.appearance().setBackgroundImage(UIImage(), forBarMetrics: .Default)
UINavigationBar.appearance().shadowImage = UIImage() UINavigationBar.appearance().setBackgroundImage(UIImage(), for: .default)
extension UINavigationBar { func shouldRemoveShadow(_ value: Bool) -> Void { if value { self.setValue(true, forKey: "hidesShadow") } else { self.setValue(false, forKey: "hidesShadow") } } }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(true) self.navigationController?.navigationBar.shouldRemoveShadow(true) }
self.navigationController?.navigationBar.translucent = false self.navigationController?.navigationBar.barStyle = .Black self.navigationController?.navigationBar.barTintColor = UIColor.blueColor()
self.navigationController?.navigationBar.setBackgroundImage(UIImage(), for:.default) self.navigationController?.navigationBar.shadowImage = UIImage() self.navigationController?.navigationBar.layoutIfNeeded()
self.navigationController?.navigationBar.setBackgroundImage(nil, for:.default) self.navigationController?.navigationBar.shadowImage = nil self.navigationController?.navigationBar.layoutIfNeeded()
for parent in navigationController!.view.subviews { for child in parent.subviews { for view in child.subviews { if view is UIImageView && view.frame.height == 0.5 { view.alpha = 0 } } } }
UINavigationBar.appearance().shadowImage = UIImage() UINavigationBar.appearance().setBackgroundImage(UIImage(), for: .default) UINavigationBar.appearance().isTranslucent = false
navigationController?.navigationBar.setBackgroundImage(UIImage(), for: .default) navigationController?.navigationBar.shadowImage = UIImage()
navigationBar.shadowImage = UIImage() navigationBar.backIndicatorImage = UIImage()
func hideBottomBorder() { for view in navigationBar.subviews.filter({ NSStringFromClass($0.dynamicType) == "_UINavigationBarBackground" }) as [UIView] { if let imageView = view.subviews.filter({ $0 is UIImageView }).first as? UIImageView { imageView.removeFromSuperview() } } }
self.navigationController?.navigationBar.shadowImage = UIImage()
self.navigationController?.navigationBar.setBackgroundImage(UIImage(), for: UIBarMetrics.default) self.navigationController?.navigationBar.shadowImage = UIImage()
for parent in self.navigationController!.navigationBar.subviews { for childView in parent.subviews { if childView.frame.height == 0.5 { childView.removeFromSuperview() } } }
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { UINavigationBar.appearance().setBackgroundImage(UIImage(), forBarPosition: UIBarPosition.Any, barMetrics: UIBarMetrics.Default) UINavigationBar.appearance().shadowImage = UIImage() UINavigationBar.appearance().tintColor = UIColor.whiteColor() UINavigationBar.appearance().barTintColor = UIColor.redColor() UINavigationBar.appearance().translucent = false UINavigationBar.appearance().clipsToBounds = false UINavigationBar.appearance().titleTextAttributes = [NSFontAttributeName : (UIFont(name: "FONT NAME", size: 18))!, NSForegroundColorAttributeName: UIColor.whiteColor()] }
self.navigationController?.navigationBar.setBackgroundImage(UIImage(), for: UIBarMetrics.default) self.navigationController?.navigationBar.shadowImage = UIImage()
extension UINavigationBar { func hideShadow(_ value: Bool = true) { setValue(value, forKey: "hidesShadow") } }
class SuperClass { func someFunc() { fatalError("Must Override") } } class Subclass : SuperClass { override func someFunc() { } }
protocol SomeProtocol { func someMethod() } class SomeClass: SomeProtocol { func someMethod() {} }
class MyVirtual { let fooImpl: (() -> String) func foo() -> String { return fooImpl() } init(fooImpl: (() -> String)) { self.fooImpl = fooImpl } } class MyImpl: MyVirtual { func myFoo() -> String { return "I am foo" } init() { super.init(myFoo) } }
protocol ViewControllerProtocol { func setupViews() func setupConstraints() } typealias ViewController = ViewControllerClass & ViewControllerProtocol class ViewControllerClass : UIViewController { override func viewDidLoad() { self.setup() } func setup() { guard let controller = self as? ViewController else { return } controller.setupViews() controller.setupConstraints() } } class SubClass : ViewController { func setupViews() { ... } func setupConstraints() { ... } }
protocol ThingsToDo { func doThingOne() } extension ThingsToDo { func doThingTwo() { } } class Person: ThingsToDo { func doThingOne() { doThingTwo() } }
class APIProxy: NSObject { var data: NSMutableData = NSMutableData() func connectToWebApi() { var urlPath = "http: NSLog("connection string \(urlPath)") var url: NSURL = NSURL(string: urlPath) var request = NSMutableURLRequest(URL: url) let username = "hs" let password = "1" let loginString = NSString(format: "%@:%@", username, password) let loginData: NSData = loginString.dataUsingEncoding(NSUTF8StringEncoding) let base64LoginString = loginData.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.fromMask(0)) request.setValue(base64LoginString, forHTTPHeaderField: "Authorization") var connection: NSURLConnection = NSURLConnection(request: request, delegate: self) connection.start() } func connection(connection: NSURLConnection!, didFailWithError error: NSError!) { println("Failed with error:\(error.localizedDescription)") } func connection(didReceiveResponse: NSURLConnection!, didReceiveResponse response: NSURLResponse!) { self.data = NSMutableData() } func connection(connection: NSURLConnection!, didReceiveData data: NSData!) { self.data.appendData(data) } func connectionDidFinishLoading(connection: NSURLConnection!) { NSLog("connectionDidFinishLoading"); }
let username = "user" let password = "pass" let loginString = String(format: "%@:%@", username, password) let loginData = loginString.data(using: String.Encoding.utf8)! let base64LoginString = loginData.base64EncodedString() let url = URL(string: "http: var request = URLRequest(url: url) request.httpMethod = "POST" request.setValue("Basic \(base64LoginString)", forHTTPHeaderField: "Authorization") let urlConnection = NSURLConnection(request: request, delegate: self)
let username = "user" let password = "pass" let loginString = NSString(format: "%@:%@", username, password) let loginData: NSData = loginString.dataUsingEncoding(NSUTF8StringEncoding)! let base64LoginString = loginData.base64EncodedStringWithOptions([]) let url = NSURL(string: "http: let request = NSMutableURLRequest(URL: url) request.HTTPMethod = "POST" request.setValue("Basic \(base64LoginString)", forHTTPHeaderField: "Authorization") let urlConnection = NSURLConnection(request: request, delegate: self)
let PasswordString = "\(txtUserName.text):\(txtPassword.text)" let PasswordData = PasswordString.dataUsingEncoding(NSUTF8StringEncoding) let base64EncodedCredential = PasswordData!.base64EncodedStringWithOptions(NSDataBase64EncodingOptions.Encoding64CharacterLineLength)
let urlPath: String = "http: var url: NSURL = NSURL(string: urlPath)
var request: NSMutableURLRequest = NSMutableURLRequest(URL: url) request.setValue("Basic \(base64EncodedCredential)", forHTTPHeaderField: "Authorization") request.HTTPMethod = "GET"
let queue:NSOperationQueue = NSOperationQueue() let urlConnection = NSURLConnection(request: request, delegate: self) urlConnection.start()
NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) {(response, data, error) in println(NSString(data: data, encoding: NSUTF8StringEncoding)) }
NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue(), completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -> Void in var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println("\(jsonResult)") })
var response: AutoreleasingUnsafePointer<NSURLResponse?>=nil var dataVal: NSData = NSURLConnection.sendSynchronousRequest(request, returningResponse: response, error:nil) var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(dataVal, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println("\(jsonResult)")
let config = NSURLSessionConfiguration.defaultSessionConfiguration() let authString = "Basic \(base64EncodedCredential)" config.HTTPAdditionalHeaders = ["Authorization" : authString] let session = NSURLSession(configuration: config) session.dataTaskWithURL(url) { (let data, let response, let error) in if let httpResponse = response as? NSHTTPURLResponse { let dataString = NSString(data: data, encoding: NSUTF8StringEncoding) println(dataString) } }.resume()
extension NSMutableURLRequest { func setAuthorizationHeader(username username: String, password: String) -> Bool { guard let data = "\(username):\(password)".dataUsingEncoding(NSUTF8StringEncoding) else { return false } let base64 = data.base64EncodedStringWithOptions([]) setValue("Basic \(base64)", forHTTPHeaderField: "Authorization") return true } }
func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) { let credential = URLCredential(user: "test", password: "test", persistence: .none) completionHandler(.useCredential, credential) }
let username = "username" let password = "password" let loginString = "\(username):\(password)" guard let loginData = loginString.data(using: String.Encoding.utf8) else { return } let base64LoginString = loginData.base64EncodedString() request.httpMethod = "GET" request.setValue("Basic \(base64LoginString)", forHTTPHeaderField: "Authorization")
import UIKit class LoginViewController: UIViewController, NSURLConnectionDataDelegate { @IBOutlet var usernameTextField: UITextField @IBOutlet var passwordTextField: UITextField @IBAction func login(sender: AnyObject) { var url = NSURL(string: "YOUR_URL") var request = NSURLRequest(URL: url) var connection = NSURLConnection(request: request, delegate: self, startImmediately: true) } func connection(connection:NSURLConnection!, willSendRequestForAuthenticationChallenge challenge:NSURLAuthenticationChallenge!) { if challenge.previousFailureCount > 1 { } else { let creds = NSURLCredential(user: usernameTextField.text, password: passwordTextField.text, persistence: NSURLCredentialPersistence.None) challenge.sender.useCredential(creds, forAuthenticationChallenge: challenge) } } func connection(connection:NSURLConnection!, didReceiveResponse response: NSURLResponse) { let status = (response as NSHTTPURLResponse).statusCode println("status code is \(status)") } override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
@IBAction func loginClicked(sender : AnyObject){ var request = NSMutableURLRequest(URL: NSURL(string: kLoginURL)) var session = NSURLSession.sharedSession() request.HTTPMethod = "POST" var err: NSError? request.HTTPBody = NSJSONSerialization.dataWithJSONObject(self.criteriaDic(), options: nil, error: &err) request.addValue("application/json", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") var task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -> Void in var strData = NSString(data: data, encoding: NSUTF8StringEncoding) println("Body: \(strData)") var err1: NSError? var json2 = NSJSONSerialization.JSONObjectWithData(strData.dataUsingEncoding(NSUTF8StringEncoding), options: .MutableLeaves, error:&err1 ) as NSDictionary println("json2 :\(json2)") if(err) { println(err!.localizedDescription) } else { var success = json2["success"] as? Int println("Succes: \(success)") } }) task.resume() }
var params = ["format":"json", "MobileType":"IOS","MIN":"f8d16d98ad12acdbbe1de647414495ec","UserName":emailTxtField.text,"PWD":passwordTxtField.text,"SigninVia":"SH"]as NSDictionary return params }
var keys: NSDictionary? if let path = NSBundle.mainBundle().pathForResource("Keys", ofType: "plist") { keys = NSDictionary(contentsOfFile: path) } if let dict = keys { let mailgunAPIPath = dict["mailgunAPIPath"] as? String let emailRecipient = "bar@foo.com" let emailMessage = "Testing%20email%20sender%20variables" let session = NSURLSession.sharedSession() let request = NSMutableURLRequest(URL: NSURL(string: mailgunAPIPath! + "from=FBOGo%20Reservation%20%3Cscheduler@<my domain>.com%3E&to=reservations@<my domain>.com&to=\(emailRecipient)&subject=A%20New%20Reservation%21&text=\(emailMessage)")!) request.HTTPMethod = "POST" let task = session.dataTaskWithRequest(request, completionHandler: {(data, response, error) in if let error = error { print(error) } if let response = response { print("url = \(response.URL!)") print("response = \(response)") let httpResponse = response as! NSHTTPURLResponse print("response code = \(httpResponse.statusCode)") } }) task.resume() }
Alamofire.request(.GET, "http: .responseJSON(options: .MutableContainers) { (_, _, JSON, error) -> Void in dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), { () -> Void in if let err = error{ println("Error:\(error)") return; } if let jsonArray = JSON as? [NSArray]{ let importer = CDImporter(incomingArray: jsonArray entity: "Artist", map: artistEntityMap); } }); }
let queue = dispatch_queue_create("com.cnoon.manager-response-queue", DISPATCH_QUEUE_CONCURRENT) let request = Alamofire.request(.GET, "http: request.response( queue: queue, serializer: Request.JSONResponseSerializer(options: .AllowFragments), completionHandler: { _, _, JSON, _ in println("Parsing JSON on thread: \(NSThread.currentThread()) is main thread: \(NSThread.isMainThread())") println(JSON) dispatch_async(dispatch_get_main_queue()) { println("Am I back on the main thread: \(NSThread.isMainThread())") } } )
let queue = dispatch_queue_create("com.cnoon.manager-response-queue", DISPATCH_QUEUE_CONCURRENT) let request = Alamofire.request(.GET, "http: request.response( queue: queue, responseSerializer: Request.JSONResponseSerializer(options: .AllowFragments), completionHandler: { response in print("Parsing JSON on thread: \(NSThread.currentThread()) is main thread: \(NSThread.isMainThread())") print(response.result.value) dispatch_async(dispatch_get_main_queue()) { print("Am I back on the main thread: \(NSThread.isMainThread())") } } )
let queue = DispatchQueue(label: "com.cnoon.response-queue", qos: .utility, attributes: [.concurrent]) Alamofire.request("http: .response( queue: queue, responseSerializer: DataRequest.jsonResponseSerializer(), completionHandler: { response in print("Parsing JSON on thread: \(Thread.current) is main thread: \(Thread.isMainThread)") print(response.result.value) DispatchQueue.main.async { print("Am I back on the main thread: \(Thread.isMainThread)") } } )
let queue = DispatchQueue(label: "com.cnoon.manager-response-queue", qos: .userInitiated, attributes:.concurrent) Alamofire?.request(SERVER_URL, method: .post, parameters: ["foo": "bar"], encoding: JSONEncoding.default, headers: ["Content-Type":"application/json; charset=UTF-8"]) .validate(statusCode: 200..<300). responseJSON(queue: queue, options: .allowFragments, completionHandler: { (response:DataResponse<Any>) in switch(response.result) { case .success(_): break case .failure(_): print(response.result.error) if response.result.error?._code == NSURLErrorTimedOut{ } break } })
extension Request { public func responseObject<T: ResponseObjectSerializable>(completionHandler: Response<T, NSError> -> Void) -> Self { let responseSerializer = ResponseSerializer<T, NSError> { request, response, data, error in guard error == nil else { return .Failure(error!) } let JSONResponseSerializer = Request.JSONResponseSerializer(options: .AllowFragments) let result = JSONResponseSerializer.serializeResponse(request, response, data, error) switch result { case .Success(let value): if let response = response, responseObject = T(response: response, representation: value) { return .Success(responseObject) } else { let failureReason = "JSON could not be serialized into response object: \(value)" let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason) return .Failure(error) } case .Failure(let error): return .Failure(error) } } let queue = dispatch_queue_create("my.queue", DISPATCH_QUEUE_CONCURRENT) return response(queue: queue, responseSerializer: responseSerializer) { response in dispatch_async(dispatch_get_main_queue()) { completionHandler(response) } } } }
let someValue = 5 let someOptional: Int? = nil switch someValue { case someOptional: default: }
enum Optional<T> : Reflectable, NilLiteralConvertible { case None case Some(T) }
let someValue = 5 let someOptional: Int? = nil switch someOptional { case .Some(someValue): println("the value is \(someValue)") case .Some(let val): println("the value is \(val)") default: println("nil") }
switch someValue { case let val where val == someOptional: println(someValue) default: break }
switch someValue { case let val where val == someOptional: print("matched") default: print("didn }
switch someOptional { case someValue?: print("the value is \(someValue)") case let val?: print("the value is \(val)") default: print("nil") }
let myOptional: MyEnum? = MyEnum.normal switch smyOptional { case .some(.normal): break case .none: break default: break }
let myOptional: MyEnum? = nil switch smyOptional { case .some(.normal): break case .none: break default: break }
let myOptional: MyEnum? = MyEnum.cool switch smyOptional { case .some(.normal): break case .none: break default: break }
func loadNext(i: Int) { let ideaPostsRef = Firebase(url: "https: ideaPostsRef.childByAppendingPath(i.description).observeSingleEventOfType(.Value, withBlock: { (snapshot) in if i % 29 == 0 && i != 0 && !self.hitNull { return } if !(snapshot.value is NSNull) { let postJSON = snapshot.value as! [String: AnyObject] print("GOT VALID \(postJSON)") let post = IdeaPost(message: postJSON["message"] as! String, byUser: postJSON["user"] as! String, withId: i.description) post.upvotes = postJSON["upvotes"] as! Int self.ideaPostDataSource.append(post) self.loadNext(i + 1) } else { print("GOT NULL RETURNING AT \(i)") self.doneLoading = true self.hitNull = true return } } }
"ideaPosts" : [ { "id" : 0, "message" : "Test", "upvotes" : 1, "user" : "Anonymous" }, { "id" : 1, "message" : "Test2", "upvotes" : 1, "user" : "Anonymous" } ]
Your app Firebase Database -- request item 1 --> S L e o r a v d e i <- return item 1 -- r n g -- request item 2 --> S L e o r a v d e i r n <- return item 2 -- g -- request item 3 --> . . . -- request item 30--> S L e o r a v d e i r n g <- return item 30 --
Your app Firebase Database -- request item 1 --> -- request item 2 --> S L -- request item 3 --> e o . r a . v d . e i -- request item 30--> r n g <- return item 1 -- <- return item 2 -- <- return item 3 -- . . . <- return item 30 --
function loadVideosSequential(videoIds) { if (videoIds.length > 0) { db.child( if (videoIds.length > 1) { loadVideosSequential(videoIds.splice(1), callback) } }); } } function loadVideosParallel(videoIds) { Promise.all( videoIds.map(id => db.child( ); }
<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <playground version= <sections> <code source-file-name= <code source-file-name= </sections> <timeline fileName= </playground>
cd /path/to/project/MyPlayground.playground/Sources ln -s ../../*.swift .
import UIKit import Foundation import Parse import CoreData var signedIn = true class ViewController: UIViewController {
import UIKit class NewClass: UIViewController { override func viewDidLoad() { super.viewDidLoad() signedIn = false }
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { var DestViewController : ViewController = segue.destinationViewController as ViewController DestViewController.signedIn = false }
@IBAction func downloadSheet(sender: AnyObject) { let optionMenu = UIAlertController(title: nil, message: "Choose Option", preferredStyle: .ActionSheet) let saveAction = UIAlertAction(title: "Save", style: .Default, handler: { (alert: UIAlertAction!) -> Void in println("Saved") }) let deleteAction = UIAlertAction(title: "Delete", style: .Default, handler: { (alert: UIAlertAction!) -> Void in println("Deleted") }) let cancelAction = UIAlertAction(title: "Cancel", style: .Cancel, handler: { (alert: UIAlertAction!) -> Void in println("Cancelled") }) optionMenu.addAction(deleteAction) optionMenu.addAction(saveAction) optionMenu.addAction(cancelAction) self.presentViewController(optionMenu, animated: true, completion: nil) }
class ViewController: UIViewController ,UIActionSheetDelegate
@IBAction func downloadSheet(sender: AnyObject) { let actionSheet = UIActionSheet(title: "Choose Option", delegate: self, cancelButtonTitle: "Cancel", destructiveButtonTitle: nil, otherButtonTitles: "Save", "Delete") actionSheet.showInView(self.view) }
func actionSheet(actionSheet: UIActionSheet, clickedButtonAtIndex buttonIndex: Int) { println("\(buttonIndex)") switch (buttonIndex){ case 0: println("Cancel") case 1: println("Save") case 2: println("Delete") default: println("Default") } }
let actionSheetControllerIOS8: UIAlertController = UIAlertController(title: "Please select", message: "Option to select", preferredStyle: .ActionSheet) let cancelActionButton = UIAlertAction(title: "Cancel", style: .cancel) { _ in print("Cancel") } actionSheetControllerIOS8.addAction(cancelActionButton) let saveActionButton = UIAlertAction(title: "Save", style: .default) { _ in print("Save") } actionSheetControllerIOS8.addAction(saveActionButton) let deleteActionButton = UIAlertAction(title: "Delete", style: .default) { _ in print("Delete") } actionSheetControllerIOS8.addAction(deleteActionButton) self.present(actionSheetControllerIOS8, animated: true, completion: nil)
@IBAction func showAlert(sender: AnyObject) { let alert = UIAlertController(title: "Title", message: "Please Select an Option", preferredStyle: .actionSheet) alert.addAction(UIAlertAction(title: "Approve", style: .default , handler:{ (UIAlertAction)in print("User click Approve button") })) alert.addAction(UIAlertAction(title: "Edit", style: .default , handler:{ (UIAlertAction)in print("User click Edit button") })) alert.addAction(UIAlertAction(title: "Delete", style: .destructive , handler:{ (UIAlertAction)in print("User click Delete button") })) alert.addAction(UIAlertAction(title: "Dismiss", style: .cancel, handler:{ (UIAlertAction)in print("User click Dismiss button") })) self.present(alert, animated: true, completion: { print("completion block") }) }
let actionSheetController = UIAlertController(title: "Please select", message: "How you would like to utilize the app?", preferredStyle: .ActionSheet) let cancelAction = UIAlertAction(title: "Cancel", style: .Cancel) { action -> Void in } actionSheetController.addAction(cancelAction) let takePictureAction = UIAlertAction(title: "Consumer", style: .Default) { action -> Void in self.performSegueWithIdentifier("segue_setup_customer", sender: self) } actionSheetController.addAction(takePictureAction) let choosePictureAction = UIAlertAction(title: "Service provider", style: .Default) { action -> Void in self.performSegueWithIdentifier("segue_setup_provider", sender: self) } actionSheetController.addAction(choosePictureAction) actionSheetController.popoverPresentationController?.sourceView = sender as UIView self.presentViewController(actionSheetController, animated: true, completion: nil)
let actionSheetController = UIAlertController(title: "Please select", message: "Option to select", preferredStyle: .actionSheet) let cancelActionButton = UIAlertAction(title: "Cancel", style: .cancel) { action -> Void in print("Cancel") } actionSheetController.addAction(cancelActionButton) let saveActionButton = UIAlertAction(title: "Save", style: .default) { action -> Void in print("Save") } actionSheetController.addAction(saveActionButton) let deleteActionButton = UIAlertAction(title: "Delete", style: .default) { action -> Void in print("Delete") } actionSheetController.addAction(deleteActionButton) self.present(actionSheetController, animated: true, completion: nil)
let actionSheetController: UIAlertController = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet) let firstAction: UIAlertAction = UIAlertAction(title: "First Action", style: .default) { action -> Void in print("First Action pressed") } let secondAction: UIAlertAction = UIAlertAction(title: "Second Action", style: .default) { action -> Void in print("Second Action pressed") } let cancelAction: UIAlertAction = UIAlertAction(title: "Cancel", style: .cancel) { action -> Void in } actionSheetController.addAction(firstAction) actionSheetController.addAction(secondAction) actionSheetController.addAction(cancelAction) present(actionSheetController, animated: true, completion: nil)
class Alerts { static func showActionsheet(viewController: UIViewController, title: String, message: String, actions: [(String, UIAlertActionStyle)], completion: @escaping (_ index: Int) -> Void) { let alertViewController = UIAlertController(title: title, message: message, preferredStyle: .actionSheet) for (index, (title, style)) in actions.enumerated() { let alertAction = UIAlertAction(title: title, style: style) { (_) in completion(index) } alertViewController.addAction(alertAction) } viewController.present(alertViewController, animated: true, completion: nil) } }
var actions: [(String, UIAlertActionStyle)] = [] actions.append(("Action 1", UIAlertActionStyle.default)) actions.append(("Action 2", UIAlertActionStyle.destructive)) actions.append(("Action 3", UIAlertActionStyle.cancel)) Alerts.showActionsheet(viewController: self, title: "D_My ActionTitle", message: "General Message in Action Sheet", actions: actions) { (index) in print("call action \(index)") }
let actionSheet = UIActionSheet(title: "Takes the appearance of the bottom bar if specified; otherwise, same as UIActionSheetStyleDefault.", delegate: self, cancelButtonTitle: "Cancel", destructiveButtonTitle: "Destroy", otherButtonTitles: "OK") actionSheet.actionSheetStyle = .Default actionSheet.showInView(self.view) func actionSheet(actionSheet: UIActionSheet, clickedButtonAtIndex buttonIndex: Int) { switch buttonIndex { ... } }
let alertController = UIAlertController(title: nil, message: "Takes the appearance of the bottom bar if specified; otherwise, same as UIActionSheetStyleDefault.", preferredStyle: .ActionSheet) let cancelAction = UIAlertAction(title: "Cancel", style: .Cancel) { (action) in } alertController.addAction(cancelAction) let OKAction = UIAlertAction(title: "OK", style: .Default) { (action) in } alertController.addAction(OKAction) let destroyAction = UIAlertAction(title: "Destroy", style: .Destructive) { (action) in println(action) } alertController.addAction(destroyAction) self.presentViewController(alertController, animated: true) { }
guard let viewRect = sender as? UIView else { return } let cameraSettingsAlert = UIAlertController(title: NSLocalizedString("Please choose a course", comment: ""), message: NSLocalizedString("", comment: ""), preferredStyle: .ActionSheet) cameraSettingsAlert.modalPresentationStyle = .Popover let photoResolutionAction = UIAlertAction(title: NSLocalizedString("Photo Resolution", comment: ""), style: .Default) { action in } let cameraOrientationAction = UIAlertAction(title: NSLocalizedString("Camera Orientation", comment: ""), style: .Default) { action in } let flashModeAction = UIAlertAction(title: NSLocalizedString("Flash Mode", comment: ""), style: .Default) { action in } let timeStampOnPhotoAction = UIAlertAction(title: NSLocalizedString("Time Stamp on Photo", comment: ""), style: .Default) { action in } let cancel = UIAlertAction(title: NSLocalizedString("Cancel", comment: ""), style: .Cancel) { action in } cameraSettingsAlert.addAction(cancel) cameraSettingsAlert.addAction(cameraOrientationAction) cameraSettingsAlert.addAction(flashModeAction) cameraSettingsAlert.addAction(timeStampOnPhotoAction) cameraSettingsAlert.addAction(photoResolutionAction) if let presenter = cameraSettingsAlert.popoverPresentationController { presenter.sourceView = viewRect; presenter.sourceRect = viewRect.bounds; } presentViewController(cameraSettingsAlert, animated: true, completion: nil)
@IBAction func ShowActionSheet(_ sender: UIButton) { let optionMenuController = UIAlertController(title: nil, message: "Choose Option from Action Sheet", preferredStyle: .actionSheet) let addAction = UIAlertAction(title: "Add", style: .default, handler: { (alert: UIAlertAction!) -> Void in print("File has been Add") }) let saveAction = UIAlertAction(title: "Edit", style: .default, handler: { (alert: UIAlertAction!) -> Void in print("File has been Edit") }) let deleteAction = UIAlertAction(title: "Delete", style: .default, handler: { (alert: UIAlertAction!) -> Void in print("File has been Delete") }) let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: { (alert: UIAlertAction!) -> Void in print("Cancel") }) optionMenuController.addAction(addAction) optionMenuController.addAction(saveAction) optionMenuController.addAction(deleteAction) optionMenuController.addAction(cancelAction) self.present(optionMenuController, animated: true, completion: nil) }
let alert = UIAlertController(title: "Title", message: "Please Select an Option", preferredStyle: .actionSheet) alert.addAction(UIAlertAction(title: "Approve", style: .default , handler:{ (UIAlertAction)in print("User click Approve button") })) alert.addAction(UIAlertAction(title: "Edit", style: .default , handler:{ (UIAlertAction)in print("User click Edit button") })) alert.addAction(UIAlertAction(title: "Delete", style: .destructive , handler:{ (UIAlertAction)in print("User click Delete button") })) alert.addAction(UIAlertAction(title: "Dismiss", style: UIAlertActionStyle.cancel, handler:{ (UIAlertAction)in print("User click Dismiss button") })) if let presenter = alert.popoverPresentationController { presenter.barButtonItem = sender } self.present(alert, animated: true, completion: { print("completion block") })
let alertController = UIAlertController(title: "Select Photo", message: "Select atleast one photo", preferredStyle: .actionSheet) let action1 = UIAlertAction(title: "From Photo", style: .default) { (action) in print("Default is pressed.....") } let action2 = UIAlertAction(title: "Cancel", style: .cancel) { (action) in print("Cancel is pressed......") } let action3 = UIAlertAction(title: "Click new", style: .default) { (action) in print("Destructive is pressed....") } alertController.addAction(action1) alertController.addAction(action2) alertController.addAction(action3) self.present(alertController, animated: true, completion: nil) }
let alert = UIAlertController() let width: Int = Int(UIScreen.main.bounds.width - 100) let viewAction = UIAlertAction(title: "View", style: .default , handler:{ (UIAlertAction)in let storyboard = UIStoryboard(name: "Main", bundle: nil) let orderDetailVC = storyboard.instantiateViewController(withIdentifier: "orderDetail") as! OrderDetailTableViewController orderDetailVC.orderId = self.myDraftOrders[indexPath.row]["id"].intValue self.navigationController?.pushViewController(orderDetailVC, animated: true) }) viewAction.setValue(appGreenColor, forKey: "titleTextColor") alert.addAction(viewAction) let modifyAction = UIAlertAction(title: "Modify", style: .default, handler:{ (UIAlertAction)in showAlert("Coming soon...") }) modifyAction.setValue(appCyanColor, forKey: "titleTextColor") alert.addAction(modifyAction) let copyAction = UIAlertAction(title: "Copy", style: .default, handler:{ (UIAlertAction)in self.copyOrder(orderId: self.myDraftOrders[indexPath.row]["id"].intValue) }) copyAction.setValue(appBlueColor, forKey: "titleTextColor") alert.addAction(copyAction) alert.addAction(UIAlertAction(title: "Delete", style: .destructive , handler:{ (UIAlertAction)in self.deleteOrder(orderId: self.myDraftOrders[indexPath.row]["id"].intValue, indexPath: indexPath) })) alert.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler:{ (UIAlertAction)in print("User click Dismiss button") })) let popover = alert.popoverPresentationController popover?.delegate = self let cellT = tableView.cellForRow(at: indexPath) popover?.sourceView = cellT popover?.sourceRect = CGRect(x: width, y: 25, width: 100, height: 50) present(alert, animated: true)
let alert = UIAlertController(title: enter your title, message: "Enter your messgage. ", preferredStyle: UIAlertControllerStyle.Alert) alert.addTextFieldWithConfigurationHandler(configurationTextField) alert.addAction(UIAlertAction(title: "Close", style: UIAlertActionStyle.Cancel, handler:{ (UIAlertAction)in print("User click Cancel button") })) alert.addAction(UIAlertAction(title: "Ok", style: UIAlertActionStyle.Default, handler:{ (UIAlertAction)in print("User click Ok button") })) self.presentViewController(alert, animated: true, completion: { print("completion block") })
var token: dispatch_once_t = 0 func test() { dispatch_once(&token) { } }
let myGlobal = { ‚Ä¶ global contains initialization in a call to a closure ‚Ä¶ }() _ = myGlobal
public extension DispatchQueue { private static var _onceTracker = [String]() /** Executes a block of code, associated with a unique token, only once. The code is thread safe and will only execute the code once even in the presence of multithreaded calls. - parameter token: A unique reverse DNS style name such as com.vectorform.<name> or a GUID - parameter block: Block to execute once */ public class func once(token: String, block:@noescape(Void)->Void) { objc_sync_enter(self); defer { objc_sync_exit(self) } if _onceTracker.contains(token) { return } _onceTracker.append(token) block() } }
DispatchQueue.once(token: "com.vectorform.test") { print( "Do This Once!" ) }
private let _onceToken = NSUUID().uuidString DispatchQueue.once(token: _onceToken) { print( "Do This Once!" ) }
public class Dispatch { private static var _onceTokenTracker = [String]() /** Executes a block of code, associated with a unique token, only once. The code is thread safe and will only execute the code once even in the presence of multithreaded calls. - parameter token: A unique reverse DNS style name such as com.vectorform.<name> or a GUID - parameter block: Block to execute once */ public class func once(token token: String, @noescape block:dispatch_block_t) { objc_sync_enter(self); defer { objc_sync_exit(self) } if _onceTokenTracker.contains(token) { return } _onceTokenTracker.append(token) block() } }
public extension DispatchQueue { private static var _onceTracker = [String]() public class func once(file: String = function: String = line: Int = block: () -> Void) { let token = "\(file):\(function):\(line)" once(token: token, block: block) } /** Executes a block of code, associated with a unique token, only once. The code is thread safe and will only execute the code once even in the presence of multithreaded calls. - parameter token: A unique reverse DNS style name such as com.vectorform.<name> or a GUID - parameter block: Block to execute once */ public class func once(token: String, block: () -> Void) { objc_sync_enter(self) defer { objc_sync_exit(self) } guard !_onceTracker.contains(token) else { return } _onceTracker.append(token) block() } }
DispatchQueue.once(token: "com.hostname.project") { setupUI() }
lazy var dispatchOnce : Void = { self.title = "Hello Lazy Guy" return }()
override func viewDidLayoutSubviews() { super.viewDidLayoutSubviews() _ = dispatchOnce }
typedef dispatch_once_t mxcl_dispatch_once_t; void mxcl_dispatch_once(mxcl_dispatch_once_t *predicate, dispatch_block_t block);
void mxcl_dispatch_once(mxcl_dispatch_once_t *predicate, dispatch_block_t block) { dispatch_once(predicate, block); }
public final class DispatchOnce { private var lock: OSSpinLock = OS_SPINLOCK_INIT private var isInitialized = false public func perform(block: (Void) -> Void) { OSSpinLockLock(&lock) if !isInitialized { block() isInitialized = true } OSSpinLockUnlock(&lock) } }
class MyViewController: UIViewController { private let setUpOnce = DispatchOnce() override func viewWillAppear() { super.viewWillAppear() setUpOnce.perform { } } }
public final class DispatchOnce { private var lock = os_unfair_lock() private var isInitialized = false public func perform(block: (Void) -> Void) { os_unfair_lock_lock(&lock) if !isInitialized { block() isInitialized = true } os_unfair_lock_unlock(&lock) } }
static let sharedInstance = SingletonA() init() { println("AAA"); }
class var sharedInstance: SingletonB { struct Static { static let instance: SingletonB = SingletonB() } return Static.instance }
class var sharedInstance: SingletonC { struct Static { static var onceToken: dispatch_once_t = 0 static var instance: SingletonC? = nil } dispatch_once(&Static.onceToken) { Static.instance = SingletonC() } return Static.instance! }
I have created below function func executeOnce(code: @escaping () -> Void) { if UserDefaults.standard.value(forKey: "3333 { code() UserDefaults.standard.setValue("vv", forKey: "3333 UserDefaults.standard.synchronize() } }
override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { if let touch = touches.anyObject() as? UITouch { if nameTF.isFirstResponder() && touch.view != nameTF { nameTF.resignFirstResponder(); } } super.touchesBegan(touches , withEvent:event) }
override func touchesBegan(touches: NSSet, withEvent event: UIEvent) or override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent)
override func touchesBegan(touches: Set<AnyObject>, withEvent event: UIEvent)
override func touchesBegan(touches: Set<NSObject>, withEvent event: UIEvent)
override func touchesBegan(touches: NSSet<AnyObject>, withEvent event: UIEvent) -> () or override func touchesBegan(touches: NSSet<NSObject>, withEvent event: UIEvent)
func touchesBegan(touches: Set<NSObject>, withEvent event: UIEvent)
override func touchesBegan(touches: Set<NSObject>, withEvent event: UIEvent) { if let touch = touches.first as? UITouch { } super.touchesBegan(touches , withEvent:event) }
override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first { } super.touchesBegan(touches, withEvent:event) }
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { if let touch = touches.first { } super.touchesBegan(touches, with: event) }
override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first{ print("\(touch)") } super.touchesBegan(touches, withEvent: event) } override func touchesEnded(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first{ print("\(touch)") } super.touchesEnded(touches, withEvent: event) } override func touchesMoved(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first{ print("\(touch)") } super.touchesMoved(touches, withEvent: event) }
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { } override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) { } override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) { } override func touchesCancelled(_ touches: Set<UITouch>?, with event: UIEvent?) { }
override func touchesBegan(touches: Set<NSObject>, withEvent event: UIEvent) { if let touch = touches.first as? UITouch { } }
override func touchesMoved(touches: Set<UITouch>, withEvent event: UIEvent?) { for touch: AnyObject! in touches { let touchLocation = touch.locationInNode(self) } }
override func touchesBegan(touches: Set<NSObject>, withEvent event: UIEvent) { if let touch = touches.first as? UITouch { } super.touchesBegan(touches , withEvent:event!) }
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { }
var originalArray = [1, 2, 3, 4] var duplicateArray = originalArray.copy()
let x = [NSMutableArray(), NSMutableArray(), NSMutableArray()] let y = x let z = x.map { $0.copy() } x[0] === y[0] x[0] === z[0]
var originalArray = [1, 2, 3, 4] as NSArray var duplicateArray = NSArray(array:originalArray, copyItems: true)
protocol Copying { init(original: Self) } extension Copying { func copy() -> Self { return Self.init(original: self) } }
extension Array where Element: Copying { func clone() -> Array { var copiedArray = Array<Element>() for element in self { copiedArray.append(element.copy()) } return copiedArray } }
var str = "Hello, playground" str.startsWith("Hello") str.endsWith("ground")
let str = "Hello, playground" if str.hasPrefix("Hello") { print("Prefix exists") } if str.hasSuffix("ground") { print("Suffix exists") }
let prefix = String(str.prefix(5)) let suffix = String(str.suffix(6))
let prefix = String(str.prefix(225)) let suffix = String(str.suffix(623))
let prefixIndex = str.index(str.startIndex, offsetBy: 5) let prefix = String(str.prefix(upTo: prefixIndex)) let suffixIndex = str.index(str.endIndex, offsetBy: -6) let suffix = String(str.suffix(from: suffixIndex))
let prefixIndex = str.index(str.startIndex, offsetBy: 5) let prefix = String(str[..<prefixIndex]) let suffixIndex = str.index(str.endIndex, offsetBy: -6) let suffix = String(str[suffixIndex...])
do { try vend(itemNamed: "Candy Bar") } catch VendingMachineError.InvalidSelection { print("Invalid Selection.") } catch VendingMachineError.OutOfStock { print("Out of Stock.") } catch VendingMachineError.InsufficientFunds(let amountRequired) { print("Insufficient funds. Please insert an additional $\(amountRequired).") } catch { }
do { try vend(itemNamed: "Candy Bar") ... } catch { print("Error info: \(error)") }
do { } catch let myError { print("caught: \(myError)") }
var continousDigitsRange:Range<Int> = Range<Int>(start: 0, end: 0)
let theString = "Hello, how are you" let range = theString.startIndex.advancedBy(start) ..< theString.startIndex.advancedBy(end) theString.substringWithRange(range)
var continousDigitsRange:Range<Int> = Range<Int>(start: 0, end: 0) --to-- var continousDigitsRange:Range<Int> = 0..<0
let theString = "Hello, how are you today my friend" let start = 3 let end = 15 let range = theString.startIndex.advancedBy(start) ..< theString.startIndex.advancedBy(end) let p = theString.substringWithRange(range) print("this is the middle bit>\(p)<")
let range = Range(uncheckedBounds: (range1.lowerBound,range1.upperBound))
let str = "Hello, how are you" let substringRange = str.characters.indices
let length = substringRange.distance(from: substringRange.startIndex, to: substringRange.endIndex)
let length2 = str.distance(from: substringRange.startIndex, to: substringRange.endIndex)
func getSubStringRange(fullString: String, fromIndex: Int, subStringSize: Int) -> Range<String.Index> { let startIndex = fullString.characters.index(fullString.startIndex, offsetBy: fromIndex) let endIndex = fullString.characters.index(startIndex, offsetBy: subStringSize) let subStringRange = startIndex..<endIndex return subStringRange }
let greeting = "Hi, my name is Nathaniel" let getName = greeting[getSubStringRange(fullString: greeting, fromIndex: 15, subStringSize: 9)] print("Name: \(getName)")
let tabBarItem = UITabBarItem(title: nil, image: UIImage(named: "more") tabBarItem.imageInsets = UIEdgeInsets(top: 9, left: 0, bottom: -9, right: 0)
for(UITabBarItem * tabBarItem in self.tabBar.items){ tabBarItem.title = @""; tabBarItem.imageInsets = UIEdgeInsetsMake(6, 0, -6, 0); }
for tabBarItem in tabBar.items! { tabBarItem.title = "" tabBarItem.imageInsets = UIEdgeInsetsMake(6, 0, -6, 0) }
func removeTabbarItemsText() { var offset: CGFloat = 6.0 if offset = 0.0 } if let items = tabBar.items { for item in items { item.title = "" item.imageInsets = UIEdgeInsetsMake(offset, 0, -offset, 0); } } }
class MainTabBar: UITabBar { override func layoutSubviews() { super.layoutSubviews() var verticalOffset: CGFloat = 6.0 if verticalOffset = 0.0 } let imageInset = UIEdgeInsets( top: verticalOffset, left: 0.0, bottom: -verticalOffset, right: 0.0 ) for tabBarItem in items ?? [] { tabBarItem.title = "" tabBarItem.imageInsets = imageInset } } }
let tabBar = self.tabBar; tabBar.backgroundColor = UIColor.whiteColor() tabBar.clipsToBounds = true let tabBarItems = tabBar.items?.count ?? 0 for i in 0 ..< tabBarItems { let tabBarItem = tabBar.items?[i] as UITabBarItem tabBarItem.imageInsets = UIEdgeInsetsMake(5, 0, -6, 0); var imageName = "" switch (i) { case 0: imageName = "tab_item_feature_1" case 1: imageName = "tab_item_feature_2" case 2: imageName = "tab_item_feature_3" case 3: imageName = "tab_item_feature_4" case 4: imageName = "tab_item_feature_5" default: break } tabBarItem.image = UIImage(named:imageName)!.imageWithRenderingMode(.AlwaysOriginal) tabBarItem.selectedImage = UIImage(named:imageName + "_selected")!.imageWithRenderingMode(.AlwaysOriginal) }
func formatTabBarItem(tabBarItem: UITabBarItem){ tabBarItem.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0) tabBarItem.setTitleTextAttributes([NSAttributedStringKey.foregroundColor:UIColor.clear], for: .selected) tabBarItem.setTitleTextAttributes([NSAttributedStringKey.foregroundColor:UIColor.clear], for: .normal) }
extension UITabBarController { func removeTabbarItemsText() { tabBar.items?.forEach { $0.title = "" $0.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0) } } }
[[UITabBarItem appearance] setTitleTextAttributes:@{NSForegroundColorAttributeName: [UIColor clearColor]} forState:UIControlStateNormal]; [[UITabBarItem appearance] setTitleTextAttributes:@{NSForegroundColorAttributeName: [UIColor clearColor]} forState:UIControlStateHighlighted];
extension UITabBarController { func cleanTitles() { guard let items = self.tabBar.items else { return } for item in items { item.title = "" item.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0) } } }
private func removeText() { if let items = yourTabBarVC?.tabBar.items { for item in items { item.title = "" } } }
class TabBar: UITabBar { override func layoutSubviews() { super.layoutSubviews() subviews.forEach { subview in if subview is UIControl { subview.subviews.forEach { if $0 is UILabel { $0.isHidden = true subview.frame.origin.y = $0.frame.height / 2.0 } } } } } }
extension UITabBarItem { func setTitleColorFor(normalState: UIColor, selectedState: UIColor) { self.setTitleTextAttributes([NSAttributedString.Key.foregroundColor: normalState], for: .normal) self.setTitleTextAttributes([NSAttributedString.Key.foregroundColor: selectedState], for: .selected) } } extension UITabBarController { func hideItemsTitle() { guard let items = self.tabBar.items else { return } for item in items { item.setTitleColorFor(normalState: UIColor(white: 0, alpha: 0), selectedState: UIColor(white: 0, alpha: 0)) item.imageInsets = UIEdgeInsets(top: 6, left: 0, bottom: -6, right: 0) } } func showItemsTitle() { guard let items = self.tabBar.items else { return } for item in items { item.setTitleColorFor(normalState: .black, selectedState: .yellow) item.imageInsets = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0) } } }
if let text = Bundle.main.infoDictionary?["CFBundleVersion"] as? String { print(text) }
func version() -> String { let dictionary = Bundle.main.infoDictionary! let version = dictionary["CFBundleShortVersionString"] as! String let build = dictionary["CFBundleVersion"] as! String return "\(version) build \(build)" }
func version() -> String { let dictionary = NSBundle.mainBundle().infoDictionary! let version = dictionary["CFBundleShortVersionString"] as String let build = dictionary["CFBundleVersion"] as String return "\(version) build \(build)" }
NSBundle.mainBundle().infoDictionary?["CFBundleVersion"] as? String
if let dict = NSBundle.mainBundle().infoDictionary { if let version = dict["CFBundleShortVersionString"] as? String, let bundleVersion = dict["CFBundleVersion"] as? String, let appName = dict["CFBundleName"] as? String { return "You } }
extension UIApplication { func applicationVersion() -> String { return NSBundle.mainBundle().objectForInfoDictionaryKey("CFBundleShortVersionString") as! String } func applicationBuild() -> String { return NSBundle.mainBundle().objectForInfoDictionaryKey(kCFBundleVersionKey as String) as! String } func versionBuild() -> String { let version = self.applicationVersion() let build = self.applicationBuild() return "v\(version)(\(build))" } }
let version = UIApplication.sharedApplication.applicationVersion() let build = UIApplication.sharedApplication.applicationBuild() let both = UIApplication.sharedApplication.versionBuild()
public static var appVersion: String? { return Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String }
public static var appBuild: String? { return Bundle.main.object(forInfoDictionaryKey: kCFBundleVersionKey as String) as? String }
if let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String { print(version) } if let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String { print(build) }
NSString *build = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleVersion"]; NSString * currentVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"];
let version = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") ?? "0" let build = Bundle.main.object(forInfoDictionaryKey: "CFBundleVersion") ?? "0"
(NSBundle.mainBundle().infoDictionary?["CFBundleVersion"] as? String)!
var applicationVersion:String { return NSBundle.mainBundle().objectForInfoDictionaryKey("CFBundleShortVersionString") as! String } var applicationBuild:String { return NSBundle.mainBundle().objectForInfoDictionaryKey(kCFBundleVersionKey as String) as! String } var versionBuild:String { let version = self.applicationVersion let build = self.applicationBuild return "version:\(version) build:(\(build))" }
let AppVersion = Bundle.main.infoDictionary!["CFBundleVersion"] as! String
let textVersion = Bundle.main.infoDictionary?["CFBundleVersion"] as? String
if let infoPath = Bundle.main.path(forResource: "Info.plist", ofType: nil), let infoAttr = try? FileManager.default.attributesOfItem(atPath: infoPath), let infoDate = infoAttr[.creationDate] as? Date { return infoDate } return Date()
override func tableView(_ tableView: UITableView, editActionsForRowAt: IndexPath) -> [UITableViewRowAction]? { let more = UITableViewRowAction(style: .normal, title: "More") { action, index in print("more button tapped") } more.backgroundColor = .lightGray let favorite = UITableViewRowAction(style: .normal, title: "Favorite") { action, index in print("favorite button tapped") } favorite.backgroundColor = .orange let share = UITableViewRowAction(style: .normal, title: "Share") { action, index in print("share button tapped") } share.backgroundColor = .blue return [share, favorite, more] }
override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true }
func tableView(tableView: UITableView, editActionsForRowAtIndexPath indexPath: NSIndexPath) -> [UITableViewRowAction]? { let more = UITableViewRowAction(style: .Normal, title: "More") { action, index in print("more button tapped") } more.backgroundColor = UIColor.lightGrayColor() let favorite = UITableViewRowAction(style: .Normal, title: "Favorite") { action, index in print("favorite button tapped") } favorite.backgroundColor = UIColor.orangeColor() let share = UITableViewRowAction(style: .Normal, title: "Share") { action, index in print("share button tapped") } share.backgroundColor = UIColor.blueColor() return [share, favorite, more] } func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -> Bool { return true }
- (NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewRowAction *modifyAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@"Modify" handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) { }]; modifyAction.backgroundColor = [UIColor blueColor]; return @[modifyAction]; }
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { }
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let reuseIdentifier = "programmaticCell" var cell = self.table.dequeueReusableCellWithIdentifier(reuseIdentifier) as! MGSwipeTableCell! if cell == nil { cell = MGSwipeTableCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: reuseIdentifier) } cell.textLabel!.text = "Title" cell.detailTextLabel!.text = "Detail text" cell.delegate = self cell.leftButtons = [MGSwipeButton(title: "", icon: UIImage(named:"check.png"), backgroundColor: UIColor.greenColor()) ,MGSwipeButton(title: "", icon: UIImage(named:"fav.png"), backgroundColor: UIColor.blueColor())] cell.leftSwipeSettings.transition = MGSwipeTransition.Rotate3D cell.rightButtons = [MGSwipeButton(title: "Delete", backgroundColor: UIColor.redColor()) ,MGSwipeButton(title: "More",backgroundColor: UIColor.lightGrayColor())] cell.rightSwipeSettings.transition = MGSwipeTransition.Rotate3D return cell }
func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? { let TrashAction = UIContextualAction(style: .normal, title: "Trash", handler: { (ac:UIContextualAction, view:UIView, success:(Bool) -> Void) in print("Update action ...") success(true) }) TrashAction.backgroundColor = .red let FlagAction = UIContextualAction(style: .normal, title: "Flag", handler: { (ac:UIContextualAction, view:UIView, success:(Bool) -> Void) in print("Update action ...") success(true) }) FlagAction.backgroundColor = .orange let MoreAction = UIContextualAction(style: .normal, title: "More", handler: { (ac:UIContextualAction, view:UIView, success:(Bool) -> Void) in print("Update action ...") success(true) }) MoreAction.backgroundColor = .gray return UISwipeActionsConfiguration(actions: [TrashAction,FlagAction,MoreAction]) }
func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? { let closeAction = UIContextualAction(style: .normal, title: "Mark as Read", handler: { (ac:UIContextualAction, view:UIView, success:(Bool) -> Void) in print("CloseAction ...") success(true) }) closeAction.backgroundColor = .blue return UISwipeActionsConfiguration(actions: [closeAction]) }
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return arrPerson.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath) let personName = arrPerson[indexPath.row] cell.textLabel?.text = personName.personName return cell }
override func viewDidLoad() { super.viewDidLoad() tblView.delegate = self tblView.dataSource = self let person1 = personData(personName: "Jonny", personAge: 30) let person2 = personData(personName: "Chandan", personAge: 20) let person3 = personData(personName: "Gopal", personAge: 28) arrPerson.append(person1) arrPerson.append(person2) arrPerson.append(person3) }
import UIKit class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var tableView: UITableView! override func viewDidLoad() { super.viewDidLoad() tableView.tableFooterView = UIView(frame: CGRect.zero) tableView.separatorInset = UIEdgeInsets.zero tableView.dataSource = self tableView.delegate = self } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return 4 } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell: UITableViewCell = tableView.dequeueReusableCell(withIdentifier: "tableCell", for: indexPath) return cell } func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool { return true } func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) { } func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? { let more = UITableViewRowAction(style: .normal, title: "More") { action, index in print("more button tapped") } more.backgroundColor = UIColor.lightGray let favorite = UITableViewRowAction(style: .normal, title: "Favorite") { action, index in print("favorite button tapped") } favorite.backgroundColor = UIColor.orange let share = UITableViewRowAction(style: .normal, title: "Share") { action, index in print("share button tapped") } share.backgroundColor = UIColor.blue return [share, favorite, more] } }
var b = UIBarButtonItem(title: "Continue", style: .Plain, target: self, action:nil) self.navigationItem.rightBarButtonItem = b
var b = UIBarButtonItem(title: "Continue", style: .Plain, target: self, action:sayHello:)
var b = UIBarButtonItem(title: "Continue", style: .Plain, target: self, action:@selector(sayHello:))
var b = UIBarButtonItem(title: "Continue", style: .Plain, target: self, action:@selector(self.sayHello:))
var b = UIBarButtonItem(title: "Continue", style: .Plain, target: self, action:"sayHello")
var b = UIBarButtonItem( title: "Continue", style: .plain, target: self, action: ) func sayHello(sender: UIBarButtonItem) { }
var b = UIBarButtonItem( title: "Continue", style: .Plain, target: self, action: ) func sayHello(sender: UIBarButtonItem) { }
button.action = @objc func buttonClicked(sender: UIBarButtonItem) { }
self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Select", target: self, action: @objc func selectAction(_ sender:UIBarButtonItem) -> Void { print("Select Clicked") }
required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) }
encodeWithCoder(_ aCoder: NSCoder) { } init(coder aDecoder: NSCoder) { }
func resizeImage(image: UIImage, newWidth: CGFloat) -> UIImage { let scale = newWidth / image.size.width let newHeight = image.size.height * scale UIGraphicsBeginImageContext(CGSizeMake(newWidth, newHeight)) image.drawInRect(CGRectMake(0, 0, newWidth, newHeight)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage } @IBAction func chooseImage(sender: AnyObject) { var myPickerController = UIImagePickerController() myPickerController.sourceType = UIImagePickerControllerSourceType.PhotoLibrary myPickerController.delegate = self; self.presentViewController(myPickerController, animated: true, completion: nil) } func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]) { var imagenow = info[UIImagePickerControllerOriginalImage] as? UIImage imageImage.image = resizeImage(imagenow!, newWidth: 200) pimg2 = imageImage.image! cidnew2 = textFieldCID!.text! pname2 = textFieldName!.text pmanu2 = textFieldMan!.text pnick2 = textFieldNick!.text podate2 = textFieldPODate!.text pno2 = textFieldArtNo!.text self.dismissViewControllerAnimated(true, completion: nil) }
func resizeImage(image: UIImage, newWidth: CGFloat) -> UIImage? { let scale = newWidth / image.size.width let newHeight = image.size.height * scale UIGraphicsBeginImageContext(CGSize(width: newWidth, height: newHeight)) image.draw(in: CGRect(x: 0, y: 0, width: newWidth, height: newHeight)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage }
extension UIImage { func scaleImage(toSize newSize: CGSize) -> UIImage? { var newImage: UIImage? let newRect = CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height).integral UIGraphicsBeginImageContextWithOptions(newSize, false, 0) if let context = UIGraphicsGetCurrentContext(), let cgImage = self.cgImage { context.interpolationQuality = .high let flipVertical = CGAffineTransform(a: 1, b: 0, c: 0, d: -1, tx: 0, ty: newSize.height) context.concatenate(flipVertical) context.draw(cgImage, in: newRect) if let img = context.makeImage() { newImage = UIImage(cgImage: img) } UIGraphicsEndImageContext() } return newImage } }
extension UIImage { func resizeImage(newWidth: CGFloat) -> UIImage { let scale = newWidth / self.size.width let newHeight = self.size.height * scale UIGraphicsBeginImageContext(CGSize(width: newWidth, height: newHeight)) self.draw(in: CGRect(x: 0, y: 0, width: newWidth, height: newHeight)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } }
func resizeImageWith(image: UIImage, newSize: CGSize) -> UIImage { let horizontalRatio = newSize.width / image.size.width let verticalRatio = newSize.height / image.size.height let ratio = max(horizontalRatio, verticalRatio) let newSize = CGSize(width: image.size.width * ratio, height: image.size.height * ratio) var newImage: UIImage if let renderFormat = UIGraphicsImageRendererFormat.default() renderFormat.opaque = false let renderer = UIGraphicsImageRenderer(size: CGSize(width: newSize.width, height: newSize.height), format: renderFormat) newImage = renderer.image { (context) in image.draw(in: CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height)) } } else { UIGraphicsBeginImageContextWithOptions(CGSize(width: newSize.width, height: newSize.height), isOpaque, 0) image.draw(in: CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height)) newImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() } return newImage }
func scaleImage(image: UIImage, maximumWidth: CGFloat) -> UIImage { let rect: CGRect = CGRectMake(0, 0, image.size.width, image.size.height) let cgImage: CGImageRef = CGImageCreateWithImageInRect(image.CGImage!, rect)! return UIImage(CGImage: cgImage, scale: image.size.width / maximumWidth, orientation: image.imageOrientation) }
func scaledImage(_ image: UIImage, maximumWidth: CGFloat) -> UIImage { let rect: CGRect = CGRect(x: 0, y: 0, width: image.size.width, height: image.size.height) let cgImage: CGImage = image.cgImage!.cropping(to: rect)! return UIImage(cgImage: cgImage, scale: image.size.width / maximumWidth, orientation: image.imageOrientation) }
extension UIImage { func renderResizedImage (newWidth: CGFloat) -> UIImage { let scale = newWidth / self.size.width let newHeight = self.size.height * scale let newSize = CGSize(width: newWidth, height: newHeight) let renderer = UIGraphicsImageRenderer(size: newSize) let image = renderer.image { (context) in self.draw(in: CGRect(origin: CGPoint(x: 0, y: 0), size: newSize)) } return image } }
let imageUrl = URL(string: "your image url") let size = CGSize(width: 60, height: 60) let processImage = ResizingImageProcessor(targetSize: size, contentMode: .aspectFit) cell.courseTitleImage.kf.setImage(with: imageUrl! , placeholder: UIImage(named: "placeholder"), options: [.transition(ImageTransition.fade(1)), .processor(processImage)], progressBlock: nil, completionHandler: nil)
func getScaledDimension(width: CGFloat, height: CGFloat,new_width: CGFloat, new_height: CGFloat)->CGPoint { let widthAspect = (width / new_width) let heightAspect = (height / new_height) if widthAspect == 0 || heightAspect == 0 { return CGPoint(x: width, y: height) } var width1 : CGFloat = 0 var height1 : CGFloat = 0 if widthAspect > heightAspect { width1 = (width) / heightAspect height1 = (height) / heightAspect } else { width1 = (width) / widthAspect height1 = (height) / widthAspect } return CGPoint(x: width1, y: height1 ) } func ResizeImage(image: UIImage, targetSize: CGSize) -> UIImage { let rect = CGRectMake(0, 0, targetSize.width, targetSize.height) UIGraphicsBeginImageContextWithOptions(targetSize, false, 1.0) image.drawInRect(rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage } let imagesize = getScaledDimension(image.size.width, height: image.size.height , new_width: Width, new_height: Hieght) print("Image Size Scaled Dimension -> H:\(imagesize.x) W:\(imagesize.y)") let newImage = ResizeImage(image, targetSize: CGSizeMake(imagesize.x,imagesize.y)) print("Resize Image Size -> H\(newImage.size.height) W\(newImage.size.width) ")
if image.size.height >= 1024 && image.size.width >= 1024 { UIGraphicsBeginImageContext(CGSize(width:1024, height:1024)) image.draw(in: CGRect(x:0, y:0, width:1024, height:1024)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } else if image.size.height >= 1024 && image.size.width < 1024 { UIGraphicsBeginImageContext(CGSize(width:image.size.width, height:1024)) image.draw(in: CGRect(x:0, y:0, width:image.size.width, height:1024)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } else if image.size.width >= 1024 && image.size.height < 1024 { UIGraphicsBeginImageContext(CGSize(width:1024, height:image.size.height)) image.draw(in: CGRect(x:0, y:0, width:1024, height:image.size.height)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } else { return image } }
{ "IdQuiz" : 102, "IdUser" : "iosclient", "User" : "iosclient", "List":[ { "IdQuestion" : 5, "IdProposition": 2, "Time" : 32 }, { "IdQuestion" : 4, "IdProposition": 3, "Time" : 9 } ] }
[[Time: 30, IdQuestion: 6510, idProposition: 10], [Time: 30, IdQuestion: 8284, idProposition: 10]]
Alamofire.request(.POST, "http: .response { request, response, data, error in let dataString = NSString(data: data!, encoding:NSUTF8StringEncoding) println(dataString) }
let json = ["List":list,"IdQuiz":"102","IdUser":"iOSclient","UserInformation":"iOSClient"] let data = NSJSONSerialization.dataWithJSONObject(json, options: NSJSONWritingOptions.PrettyPrinted,error:nil) let jsons = NSString(data: data!, encoding: NSUTF8StringEncoding) Alamofire.request(.POST, "http: (convertible, params) in var mutableRequest = convertible.URLRequest.copy() as! NSMutableURLRequest mutableRequest.HTTPBody = jsons!.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) return (mutableRequest, nil) })) .response { request, response, data, error in let dataString = NSString(data: data!, encoding:NSUTF8StringEncoding) println(dataString) }
let parameters: [String: AnyObject] = [ "IdQuiz" : 102, "IdUser" : "iosclient", "User" : "iosclient", "List": [ [ "IdQuestion" : 5, "IdProposition": 2, "Time" : 32 ], [ "IdQuestion" : 4, "IdProposition": 3, "Time" : 9 ] ] ] Alamofire.request(.POST, "http: .responseJSON { request, response, JSON, error in print(response) print(JSON) print(error) }
let parameters: [String: Any] = [ "IdQuiz" : 102, "IdUser" : "iosclient", "User" : "iosclient", "List": [ [ "IdQuestion" : 5, "IdProposition": 2, "Time" : 32 ], [ "IdQuestion" : 4, "IdProposition": 3, "Time" : 9 ] ] ] Alamofire.request("http: .responseJSON { response in print(response) }
let urlString = "https: let json = "{\"What\":\"Ever\"}" let url = URL(string: urlString)! let jsonData = json.data(using: .utf8, allowLossyConversion: false)! var request = URLRequest(url: url) request.httpMethod = HTTPMethod.post.rawValue request.setValue("application/json; charset=UTF-8", forHTTPHeaderField: "Content-Type") request.httpBody = jsonData Alamofire.request(request).responseJSON { (response) in print(response) }
let params:NSMutableDictionary? = [ "IdQuiz" : 102, "IdUser" : "iosclient", "User" : "iosclient", "List": [ [ "IdQuestion" : 5, "IdProposition": 2, "Time" : 32 ], [ "IdQuestion" : 4, "IdProposition": 3, "Time" : 9 ] ] ]; let ulr = NSURL(string:"http: let request = NSMutableURLRequest(url: ulr! as URL) request.httpMethod = "POST" request.setValue("application/json", forHTTPHeaderField: "Content-Type") let data = try! JSONSerialization.data(withJSONObject: params!, options: JSONSerialization.WritingOptions.prettyPrinted) let json = NSString(data: data, encoding: String.Encoding.utf8.rawValue) if let json = json { print(json) } request.httpBody = json!.data(using: String.Encoding.utf8.rawValue); Alamofire.request(request as! URLRequestConvertible) .responseJSON { response in print(response.request) print(response.response) print(response.data) print(response.result) }
let urlstring = "Add URL String here" let parameters: [String: AnyObject] = [ "IdQuiz" : 102, "IdUser" : "iosclient", "User" : "iosclient", "List": [ [ "IdQuestion" : 5, "IdProposition": 2, "Time" : 32 ], [ "IdQuestion" : 4, "IdProposition": 3, "Time" : 9 ] ] ] Alamofire.request(.POST, urlstring, parameters: parameters, encoding: .JSON).responseJSON { response in print(response.request) print(response.response) print(response.data) print(response.result) if let JSON = response.result.value { print("JSON: \(JSON)") } response.result.error }
let body: NSMutableDictionary? = [ "name": "\(nameLabel.text!)", "phone": "\(phoneLabel.text!))"] let url = NSURL(string: "http: var request = URLRequest(url: url! as URL) request.httpMethod = "POST" request.setValue("application/json", forHTTPHeaderField: "Content-Type") let data = try! JSONSerialization.data(withJSONObject: body!, options: JSONSerialization.WritingOptions.prettyPrinted) let json = NSString(data: data, encoding: String.Encoding.utf8.rawValue) if let json = json { print(json) } request.httpBody = json!.data(using: String.Encoding.utf8.rawValue) let alamoRequest = Alamofire.request(request as URLRequestConvertible) alamoRequest.validate(statusCode: 200..<300) alamoRequest.responseString { response in switch response.result { case .success: ... case .failure(let error): ... } }
let parameters: Parameters = [ "username" : email.text!, "password" : password.text! ] let urlString = "https: let url = URL.init(string: urlString) Alamofire.request(url!, method: .put, parameters: , encoding: JSONEncoding.default, headers: nil).responseJSON { response in switch response.result { case .success(let json): let jsonData = json as! Any print(jsonData) case .failure(let error): self.errorFailer(error: error) } }
func postRequest(url:String, params:Parameters?, headers:HTTPHeaders?, completion:@escaping (_ responseData:Result<Any>?, _ error:Error?)->Void){ Alamofire.request(url, method: .post, parameters: params, encoding: JSONEncoding.default, headers: headers).responseJSON { response in guard response.result.isSuccess, (response.result.value != nil) else { debugPrint("Error while fetching data: \(String(describing: response.result.error))") completion(nil,response.result.error) return } completion(response.result,nil) } }
func requestAccountOperation(completion: @escaping ( (_ result:Any?, _ error:Error?) -> Void)){ BKCApiClient.shared.postRequest(url: BKCConstants().bkcUrl, params: self.parametrs(), headers: self.headers()) { (result, error) in if(error != nil){ } completion(result, error) } } func parametrs()->Parameters{ return ["userid‚Äù:‚Äùxnmtyrdx‚Äù,‚Äùbcode":"HDF"] as Parameters } func headers()->HTTPHeaders{ return ["Authorization": "Basic bXl1c2VyOm15cGFzcw", "Content-Type": "application/json"] as HTTPHeaders }
func callToAPIOperation(){ let accOperation: AccountRequestOperation = AccountRequestOperation() accOperation.requestAccountOperation{(result, error) in }}
func get_Contact_list() { ApiUtillity.sharedInstance.showSVProgressHUD(text: "Loading..") let cont_nunber = contact_array as NSArray print(cont_nunber) let token = UserDefaults.standard.string(forKey: "vAuthToken")! let apiToken = "Bearer \(token)" let headers = [ "Vauthtoken": apiToken, "content-type": "application/json" ] let myArray: [Any] = cont_nunber as! [Any] let jsonData: Data? = try? JSONSerialization.data(withJSONObject: myArray, options: .prettyPrinted) var jsonString = String() if let aData = jsonData { jsonString = String(data: aData, encoding: .utf8)! } let url1 = "URL" var request = URLRequest(url: URL(string: url1)!) request.httpMethod = "POST" request.allHTTPHeaderFields = headers request.httpBody = jsonData as! Data let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, error == nil else { print("error=\(String(describing: error))") ApiUtillity.sharedInstance.dismissSVProgressHUD() return } print("response = \(String(describing: response))") let responseString = String(data: data, encoding: .utf8) print("responseString = \(String(describing: responseString))") let json = self.convertStringToDictionary(text: responseString!)! as NSDictionary print(json) let status = json.value(forKey: "status") as! Int if status == 200 { let array = (json.value(forKey: "data") as! NSArray).mutableCopy() as! NSMutableArray } else if status == 401 { ApiUtillity.sharedInstance.dismissSVProgressHUD() } else { ApiUtillity.sharedInstance.dismissSVProgressHUD() } } task.resume() } func convertStringToDictionary(text: String) -> [String:AnyObject]? { if let data = text.data(using: String.Encoding.utf8) { do { let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String:AnyObject] return json } catch { print("Something went wrong") } } return nil }
if Reachability.isConnectedToNetwork() == true { let hud = MBProgressHUD.showAdded(to: self.view, animated: true) hud.mode = .indeterminate hud.label.text = "Loading" hud.animationType = .fade var request = URLRequest(url: URL(string: "http: request.httpMethod = "POST" let postString = String(format: "email=%@&lang=%@", arguments: [txt_emailVirify.text!, language!]) print(postString) emailString = txt_emailVirify.text! request.httpBody = postString.data(using: .utf8) request.addValue("delta141forceSEAL8PARA9MARCOSBRAHMOS", forHTTPHeaderField: "Authorization") request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") Alamofire.request(request).responseJSON { response in print(response.value) if response.response?.statusCode == 200 { let dictionary = (response.value) as! AnyObject let status = dictionary.value(forKey: "status") as! String let sts = Int(status) DispatchQueue.main.async() { if sts == 200 { } } } else { } } } else { } }
UIViewController *viewController = [[self storyboard] instantiateViewControllerWithIdentifier:@"Identifier"]; UINavigationController *navi = [[UINavigationController alloc] initWithRootViewController:viewController]; [self.navigationController pushViewController:navi animated:YES];
let secondViewController = self.storyboard.instantiateViewControllerWithIdentifier("SecondViewController") as SecondViewController self.navigationController.pushViewController(secondViewController, animated: true)
let mapViewControllerObj = self.storyboard?.instantiateViewControllerWithIdentifier("MapViewControllerIdentifier") as? MapViewController self.navigationController?.pushViewController(mapViewControllerObj!, animated: true)
let vc = UIStoryboard.init(name: "Main", bundle: Bundle.main).instantiateViewController(withIdentifier: "IKDetailVC") as? IKDetailVC self.navigationController?.pushViewController(vc!, animated: true)
let next = self.storyboard?.instantiateViewControllerWithIdentifier("DashboardController") as! DashboardController self.presentViewController(next, animated: true, completion: nil)
let vc = self.storyboard?.instantiateViewControllerWithIdentifier("YourViewController") as! YourViewController let navigationController = UINavigationController(rootViewController: vc) self.presentViewController(navigationController, animated: true, completion: nil)
let secondViewController = self.storyboard?.instantiateViewController(withIdentifier: "Conversation_VC") as! Conversation_VC self.navigationController?.pushViewController(secondViewController, animated: true)
var viewController: UIViewController? = storyboard().instantiateViewController(withIdentifier: "Identifier") var navi = UINavigationController(rootViewController: viewController!) navigationController?.pushViewController(navi, animated: true)
let secondviewController:UIViewController = self.storyboard?.instantiateViewController(withIdentifier: "StoryboardIdOfsecondviewController") as? SecondViewController self.navigationController?.pushViewController(secondviewController, animated: true)
let nextVC = self.storyboard?.instantiateViewController(withIdentifier: "NextViewController") as! NextViewController self.navigationController?.pushViewController(nextVC, animated: true)
let objViewController = self.storyboard?.instantiateViewController(withIdentifier: "ViewController") as! ViewController self.navigationController?.pushViewController(objViewController, animated: true)
let next = self.storyboard?.instantiateViewController(withIdentifier: "AFVC") as! AddFileViewController self.present(next, animated: true, completion: nil) let dashboard = self.storyboard?.instantiateViewController(withIdentifier: "DBVC") as! DashboardViewController self.navigationController?.pushViewController(dashboard, animated: true)
let vc = self.storyboard?.instantiateViewController(withIdentifier: "YourStoryboardID") as! swiftClassName self.navigationController?.pushViewController(vc, animated: true)
NavigationController.PushViewController(new HomePage(), true);
navigationController?.pushViewController(HomePage(), animated: true);
layer.masksToBounds Boolean YES layer.cornerRadius Number {View
extension UIView { @IBDesignable public var cornerRadiusRatio: CGFloat { get { return layer.cornerRadius / frame.width } set { let normalizedRatio = max(0.0, min(1.0, newValue)) layer.cornerRadius = frame.width * normalizedRatio } } }
extension UIView { @IBInspectable var cornerRadiusV: CGFloat { get { return layer.cornerRadius } set { layer.cornerRadius = newValue layer.masksToBounds = newValue > 0 } } @IBInspectable var borderWidthV: CGFloat { get { return layer.borderWidth } set { layer.borderWidth = newValue } } @IBInspectable var borderColorV: UIColor? { get { return UIColor(cgColor: layer.borderColor!) } set { layer.borderColor = newValue?.cgColor } } }
var point = Int() func buttonPressed(sender: AnyObject) { let pointInTable: CGPoint = sender.convertPoint(sender.bounds.origin, toView: self.tableView) let cellIndexPath = self.tableView.indexPathForRowAtPoint(pointInTable) println(cellIndexPath) point = cellIndexPath!.row println(point) }
guard let cell = sender.superview?.superview as? YourCellClassHere else { return } let indexPath = itemTable.indexPath(for: cell)
class MyCell: UITableViewCell { var button: UIButton! var buttonAction: ((Any) -> Void)? @objc func buttonPressed(sender: Any) { self.buttonAction?(sender) } }
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier("Cell") as! MyCell cell.buttonAction = { sender in } cell.buttonAction = buttonPressed(closure: buttonAction, indexPath: indexPath) }
protocol CellSubclassDelegate: class { func buttonTapped(cell: CellSubclass) } class CellSubclass: UITableViewCell { @IBOutlet var someButton: UIButton! var delegate: CellSubclassDelegate? override func prepareForReuse() { super.prepareForReuse() self.delegate = nil } @IBAction func someButtonTapped(sender: UIButton) { self.delegate?.buttonTapped(self) }
class MyViewController: UIViewController, CellSubclassDelegate { @IBOutlet var tableview: UITableView! func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as! CellSubclass cell.delegate = self } func buttonTapped(cell: CellSubclass) { guard let indexPath = self.tableView.indexPathForCell(cell) else { return } print("Button tapped on row \(indexPath.row)") } }
func buttonTapped(_ sender:AnyObject) { let buttonPosition:CGPoint = sender.convert(CGPoint.zero, to:self.tableView) let indexPath = self.tableView.indexPathForRow(at: buttonPosition) }
let buttonPosition:CGPoint = sender.convert(CGPoint.init(x: 5.0, y: 5.0), to:self.tableView)
button.tag = indexPath.row button.addTarget(self, action: "buttonClicked:", forControlEvents: UIControlEvents.TouchUpInside)
func buttonClicked(sender:UIButton) { let buttonRow = sender.tag }
let point = tableView.convertPoint(CGPoint.zero, fromView: sender) guard let indexPath = tableView.indexPathForRowAtPoint(point) else { fatalError("can }
// // import UIKit public extension UITableView { /** This method returns the indexPath of the cell that contains the specified view - Parameter view: The view to find. - Returns: The indexPath of the cell containing the view, or nil if it can */ func indexPathForView(_ view: UIView) -> IndexPath? { let center = view.center let viewCenter = self.convert(center, from: view.superview) let indexPath = self.indexPathForRow(at: viewCenter) return indexPath } }
func buttonTapped(_ button: UIButton) { if let indexPath = self.tableView.indexPathForView(button) { print("Button tapped at indexPath \(indexPath)") } else { print("Button indexPath not found") } }
func buttonTapped(_ sender: UIButton) { let buttonPostion = sender.convert(sender.bounds.origin, to: tableView) if let indexPath = tableView.indexPathForRow(at: buttonPostion) { let rowIndex = indexPath.row } }
class Cell: UITableViewCell { @IBOutlet var button: UIButton! var buttonAction: ((sender: AnyObject) -> Void)? @IBAction func buttonPressed(sender: AnyObject) { self.buttonAction?(sender) } }
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier("Cell") as! Cell cell.buttonAction = { (sender) in } cell.buttonAction = buttonPressed }
@IBAction func newsButtonAction(sender: UIButton) { let buttonPosition = sender.convertPoint(CGPointZero, toView: self.newsTableView) let indexPath = self.newsTableView.indexPathForRowAtPoint(buttonPosition) if indexPath != nil { if indexPath?.row == 1{ self.performSegueWithIdentifier("alertViewController", sender: self); } } }
func buttonTapped(sender: UIButton) { guard let cellInAction = sender.superview as? UITableViewCell else { return } guard let indexPath = tableView?.indexPath(for: cellInAction) else { return } print(indexPath) }
func getCellForView(view:UIView) -> UITableViewCell? { var superView = view.superview while superView != nil { if superView is UITableViewCell { return superView as? UITableViewCell } else { superView = superView?.superview } } return nil }
@IBAction func tapButton(_ sender: UIButton) { let cell = getCellForView(view: sender) let indexPath = myTabelView.indexPath(for: cell) }
cell.editButton.tag = indexPath.row cell.editButton.addTarget(self, action:
func editButtonPressed(_ sender: UIButton) { print(sender.tag) }
@IBOutlet var imgProfileImage: UIImageView! @IBOutlet var btnCheck: UIButton! @IBOutlet var lblName: UILabel! @IBOutlet var lblEmail: UILabel! }
@IBOutlet var inviteTableView: UITableView! @IBOutlet var btnInvite: UIButton! var checkArray : NSMutableArray = NSMutableArray() var userName : NSMutableArray = NSMutableArray() override func viewDidLoad() { super.viewDidLoad() btnInvite.layer.borderWidth = 1.5 btnInvite.layer.cornerRadius = btnInvite.frame.height / 2 btnInvite.layer.borderColor = hexColor(hex: " var userName1 =["Olivia","Amelia","Emily","Isla","Ava","Lily","Sophia","Ella","Jessica","Mia","Grace","Evie","Sophie","Poppy","Isabella","Charlotte","Freya","Ruby","Daisy","Alice"] self.userName.removeAllObjects() for items in userName1 { print(items) let model = RNCheckedModel() model.user_name = items model.is_check = false self.userName.add(model) } } @IBAction func btnInviteClick(_ sender: Any) { } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return userName.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell: InviteCell = inviteTableView.dequeueReusableCell(withIdentifier: "InviteCell", for: indexPath) as! InviteCell let image = UIImage(named: "ic_unchecked") cell.imgProfileImage.layer.borderWidth = 1.0 cell.imgProfileImage.layer.masksToBounds = false cell.imgProfileImage.layer.borderColor = UIColor.white.cgColor cell.imgProfileImage.layer.cornerRadius = cell.imgProfileImage.frame.size.width / 2 cell.imgProfileImage.clipsToBounds = true let model = self.userName[indexPath.row] as! RNCheckedModel cell.lblName.text = model.user_name if (model.is_check) { cell.btnCheck.setImage(UIImage(named: "ic_checked"), for: UIControlState.normal) } else { cell.btnCheck.setImage(UIImage(named: "ic_unchecked"), for: UIControlState.normal) } cell.btnCheck.tag = indexPath.row cell.btnCheck.addTarget(self, action: cell.btnCheck.isUserInteractionEnabled = true return cell } func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat { return 80 } @objc func btnCheck(_ sender: UIButton) { let tag = sender.tag let indexPath = IndexPath(row: tag, section: 0) let cell: InviteCell = inviteTableView.dequeueReusableCell(withIdentifier: "InviteCell", for: indexPath) as! InviteCell let model = self.userName[indexPath.row] as! RNCheckedModel if (model.is_check) { model.is_check = false cell.btnCheck.setImage(UIImage(named: "ic_unchecked"), for: UIControlState.normal) checkArray.remove(model.user_name) if checkArray.count > 0 { btnInvite.setTitle("Invite (\(checkArray.count))", for: .normal) print(checkArray.count) UIView.performWithoutAnimation { self.view.layoutIfNeeded() } } else { btnInvite.setTitle("Invite", for: .normal) UIView.performWithoutAnimation { self.view.layoutIfNeeded() } } }else { model.is_check = true cell.btnCheck.setImage(UIImage(named: "ic_checked"), for: UIControlState.normal) checkArray.add(model.user_name) if checkArray.count > 0 { btnInvite.setTitle("Invite (\(checkArray.count))", for: .normal) UIView.performWithoutAnimation { self.view.layoutIfNeeded() } } else { btnInvite.setTitle("Invite", for: .normal) } } self.inviteTableView.reloadData() } func hexColor(hex:String) -> UIColor { var cString:String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if (cString.hasPrefix(" cString.remove(at: cString.startIndex) } if ((cString.count) != 6) { return UIColor.gray } var rgbValue:UInt32 = 0 Scanner(string: cString).scanHexInt32(&rgbValue) return UIColor( red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0, green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0, blue: CGFloat(rgbValue & 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
let string = "A \(stringOne) with \(stringTwo)" var attributedString = NSMutableAttributedString(string: string) textView.attributedText = attributedString
let string = "A \(stringOne) and \(stringTwo)" var attributedString = NSMutableAttributedString(string:string) let stringOneRegex = NSRegularExpression(pattern: nameString, options: nil, error: nil) let stringOneMatches = stringOneRegex.matchesInString(longString, options: nil, range: NSMakeRange(0, attributedString.length)) for stringOneMatch in stringOneMatches { let wordRange = stringOneMatch.rangeAtIndex(0) attributedString.addAttribute(NSForegroundColorAttributeName, value: UIColor.nameColor(), range: wordRange) } textView.attributedText = attributedString
var main_string = "Hello World" var string_to_color = "World" var range = (main_string as NSString).rangeOfString(string_to_color)
var attributedString = NSMutableAttributedString(string:main_string) attributedString.addAttribute(NSForegroundColorAttributeName, value: UIColor.redColor() , range: range)
let txtfield1 :UITextField! let main_string = "Hello World" let string_to_color = "World" let range = (main_string as NSString).range(of: string_to_color) let attribute = NSMutableAttributedString.init(string: main_string) attribute.addAttribute(NSAttributedStringKey.foregroundColor, value: UIColor.red , range: range) txtfield1 = UITextField.init(frame:CGRect(x:10 , y:20 ,width:100 , height:100)) txtfield1.attributedText = attribute
let text = "We tried to make this app as most intuitive as possible for you. If you have any questions don let linkTextWithColor = "click here" let range = (text as NSString).rangeOfString(linkTextWithColor) let attributedString = NSMutableAttributedString(string:text) attributedString.addAttribute(NSForegroundColorAttributeName, value: UIColor.redColor() , range: range) self.helpText.attributedText = attributedString
var myMutableString = NSMutableAttributedString() myMutableString = NSMutableAttributedString(string: "Your full label textString") myMutableString.setAttributes([NSFontAttributeName : UIFont(name: "HelveticaNeue-Light", size: CGFloat(17.0))! , NSForegroundColorAttributeName : UIColor(red: 232 / 255.0, green: 117 / 255.0, blue: 40 / 255.0, alpha: 1.0)], range: NSRange(location:12,length:8)) yourLabel.attributedText = myMutableString
static func createAttributedString(fullString: String, fullStringColor: UIColor, subString: String, subStringColor: UIColor) -> NSMutableAttributedString { let range = (fullString as NSString).rangeOfString(subString) let attributedString = NSMutableAttributedString(string:fullString) attributedString.addAttribute(NSForegroundColorAttributeName, value: fullStringColor, range: NSRange(location: 0, length: fullString.characters.count)) attributedString.addAttribute(NSForegroundColorAttributeName, value: subStringColor, range: range) return attributedString }
self.navigationController?.navigationBar.titleTextAttributes = [ NSAttributedStringKey.font: UIFont.systemFont(ofSize: 22), NSAttributedStringKey.foregroundColor: UIColor.white]
var myMutableString = NSMutableAttributedString() myMutableString = NSMutableAttributedString(string: "1234567890", attributes: [NSFontAttributeName:UIFont(name: kDefaultFontName, size: 14.0)!]) myMutableString.addAttribute(NSForegroundColorAttributeName, value: UIColor(red: 0.0/255.0, green: 125.0/255.0, blue: 179.0/255.0, alpha: 1.0), range: NSRange(location:0,length:5)) self.lblPhone.attributedText = myMutableString
import Foundation import UIKit extension NSMutableAttributedString { convenience init (fullString: String, fullStringColor: UIColor, subString: String, subStringColor: UIColor) { let rangeOfSubString = (fullString as NSString).range(of: subString) let rangeOfFullString = NSRange(location: 0, length: fullString.count) let attributedString = NSMutableAttributedString(string:fullString) attributedString.addAttribute(NSAttributedStringKey.foregroundColor, value: fullStringColor, range: rangeOfFullString) attributedString.addAttribute(NSAttributedStringKey.foregroundColor, value: subStringColor, range: rangeOfSubString) self.init(attributedString: attributedString) } }
extension String { func highlightWordsIn(highlightedWords: String, attributes: [[NSAttributedStringKey: Any]]) -> NSMutableAttributedString { let range = (self as NSString).range(of: highlightedWords) let result = NSMutableAttributedString(string: self) for attribute in attributes { result.addAttributes(attribute, range: range) } return result } }
let attributes = [[NSAttributedStringKey.foregroundColor:UIColor.red], [NSAttributedStringKey.font: UIFont.boldSystemFont(ofSize: 17)]] myLabel.attributedText = "This is a text".highlightWordsIn(highlightedWords: "is a text", attributes: attributes)
let str = "Welcome " let welcomeAttribute = [ NSForegroundColorAttributeName: UIColor.blue()] let welcomeAttrString = NSMutableAttributedString(string: str, attributes: welcomeAttribute)
let str = "Welcome " let welcomeAttribute = [ NSAttributedStringKey.foregroundColor: UIColor.blue()] let welcomeAttrString = NSMutableAttributedString(string: str, attributes: welcomeAttribute)
let str = "Welcome " let welcomeAttribute = [ NSAttributedStringKey(rawValue: NSForegroundColorAttributeName): UIColor.blue()] let welcomeAttrString = NSMutableAttributedString(string: str, attributes: welcomeAttribute)
func highlight(matchingText: String, in text: String) { let attributedString = NSMutableAttributedString(string: text) if let regularExpression = try? NSRegularExpression(pattern: "\(matchingText)", options: .caseInsensitive) { let matchedResults = regularExpression.matches(in: text, options: [], range: NSRange(location: 0, length: attributedString.length)) for matched in matchedResults { attributedString.addAttributes([NSAttributedStringKey.backgroundColor : UIColor.yellow], range: matched.range) } yourLabel.attributedText = attributedString } }
let textString = "Hello world" let range = (textString as NSString).range(of: "world") let attributedString = NSMutableAttributedString(string: textString) attributedString.addAttribute(NSAttributedStringKey.foregroundColor, value: UIColor.red, range: range) self.textUIlable.attributedText = attributedString
let textView = UITextView() textView.attributedString = attributedString textView.tintColor = UIColor.red
let text = "This is a colorful attributed string" let attributedText = NSMutableAttributedString.getAttributedString(fromString: text) attributedText.apply(color: .red, subString: "This") attributedText.apply(color: .yellow, onRange: NSMakeRange(5, 4))
func attributedString(with highlightString: String, normalString: String, highlightColor: UIColor) -> NSMutableAttributedString { let attributes = [NSAttributedString.Key.foregroundColor: highlightColor] let attributedString = NSMutableAttributedString(string: highlightString, attributes: attributes) attributedString.append(NSAttributedString(string: normalString)) return attributedString }
let main_string = " User not found,Want to review ? Click here" let string_to_color = "Click here" let range = (main_string as NSString).range(of: string_to_color) let attribute = NSMutableAttributedString.init(string: main_string) attribute.addAttribute(NSAttributedStringKey.foregroundColor, value: UIColor.blue , range: range) lblClickHere.attributedText = attribute
func md5(string string: String) -> String { var digest = [UInt8](count: Int(CC_MD5_DIGEST_LENGTH), repeatedValue: 0) if let data = string.dataUsingEncoding(NSUTF8StringEncoding) { CC_MD5(data.bytes, CC_LONG(data.length), &digest) } var digestHex = "" for index in 0..<Int(CC_MD5_DIGEST_LENGTH) { digestHex += String(format: "%02x", digest[index]) } return digestHex } let digest = md5(string:"Hello") print("digest: \(digest)")
func MD5(string: String) -> Data { let messageData = string.data(using:.utf8)! var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH)) _ = digestData.withUnsafeMutableBytes {digestBytes in messageData.withUnsafeBytes {messageBytes in CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes) } } return digestData } let md5Data = MD5(string:"Hello") let md5Hex = md5Data.map { String(format: "%02hhx", $0) }.joined() print("md5Hex: \(md5Hex)") let md5Base64 = md5Data.base64EncodedString() print("md5Base64: \(md5Base64)")
func hash(name:String, string:String) -> Data? { let data = string.data(using:.utf8)! return hash(name:name, data:data) }
let clearString = "clearData0123456" let clearData = clearString.data(using:.utf8)! print("clearString: \(clearString)") print("clearData: \(clearData as NSData)") let hashSHA256 = hash(name:"SHA256", string:clearString) print("hashSHA256: \(hashSHA256! as NSData)") let hashMD5 = hash(name:"MD5", data:clearData) print("hashMD5: \(hashMD5! as NSData)")
clearString: clearData0123456 clearData: <636c6561 72446174 61303132 33343536> hashSHA256: <aabc766b 6b357564 e41f4f91 2d494bcc bfa16924 b574abbd ba9e3e9d a0c8920a> hashMD5: <4df665f7 b94aea69 695b0e7b baf9e9d6>
func md5(_ string: String) -> String { let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity: 1) var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH)) CC_MD5_Init(context) CC_MD5_Update(context, string, CC_LONG(string.lengthOfBytes(using: String.Encoding.utf8))) CC_MD5_Final(&digest, context) context.deallocate(capacity: 1) var hexString = "" for byte in digest { hexString += String(format:"%02x", byte) } return hexString }
let input = "The quick brown fox jumps over the lazy dog" let digest = input.utf8.md5 print("md5: \(digest)")
import Foundation import CommonCrypto public enum HashOutputType { case hex case base64 } public enum HashType { case md5 case sha1 case sha224 case sha256 case sha384 case sha512 var length: Int32 { switch self { case .md5: return CC_MD5_DIGEST_LENGTH case .sha1: return CC_SHA1_DIGEST_LENGTH case .sha224: return CC_SHA224_DIGEST_LENGTH case .sha256: return CC_SHA256_DIGEST_LENGTH case .sha384: return CC_SHA384_DIGEST_LENGTH case .sha512: return CC_SHA512_DIGEST_LENGTH } } } public extension String { public func hashed(_ type: HashType, output: HashOutputType = .hex) -> String? { guard let message = data(using: .utf8) else { return nil } return message.hashed(type, output: output) }
import Foundation import CommonCrypto extension Data { public func hashWithRSA2048Asn1Header(_ type: HashType, output: HashOutputType = .hex) -> String? { let rsa2048Asn1Header:[UInt8] = [ 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00 ] var headerData = Data(bytes: rsa2048Asn1Header) headerData.append(self) return hashed(type, output: output) } public func hashed(_ type: HashType, output: HashOutputType = .hex) -> String? { var digest = Data(count: Int(type.length)) _ = digest.withUnsafeMutableBytes { (digestBytes: UnsafeMutablePointer<UInt8>) in self.withUnsafeBytes { (messageBytes: UnsafePointer<UInt8>) in let length = CC_LONG(self.count) switch type { case .md5: CC_MD5(messageBytes, length, digestBytes) case .sha1: CC_SHA1(messageBytes, length, digestBytes) case .sha224: CC_SHA224(messageBytes, length, digestBytes) case .sha256: CC_SHA256(messageBytes, length, digestBytes) case .sha384: CC_SHA384(messageBytes, length, digestBytes) case .sha512: CC_SHA512(messageBytes, length, digestBytes) } } } switch output { case .hex: return digest.map { String(format: "%02hhx", $0) }.joined() case .base64: return digest.base64EncodedString() } } }
let data: Data = SecCertificateCopyData(serverCertificate) as Data guard let serverHash = data.hashWithRSA2048Asn1Header(.sha256, output: .base64), serverHash == storedHash else { print("SSL PINNING: Server certificate hash does not match specified hash value.") return false }
let value = "This is my string" if let md5 = value.hashed(.md5) { print("md5: \(md5)") } if let sha1 = value.hashed(.sha1) { print("sha1: \(sha1)") } if let sha224 = value.hashed(.sha224) { print("sha224: \(sha224)") } if let sha256 = value.hashed(.sha256) { print("sha256: \(sha256)") } if let sha384 = value.hashed(.sha384) { print("sha384: \(sha384)") } if let sha512 = value.hashed(.sha512) { print("sha512: \(sha512)") }
md5: c2a9ce57e8df081b4baad80d81868bbb sha1: 37fb219bf98bee51d2fdc3ba6d866c97f06c8223 sha224: f88e2f20aa89fb4dffb6bdc62d7bd75e1ba02574fae4a437c3bf49c7 sha256: 9da6c02379110815278b615f015f0b254fd3d5a691c9d8abf8141655982c046b sha384: d9d7fc8aefe7f8f0a969b132a59070836397147338e454acc6e65ca616099d03a61fcf9cc8c4d45a2623145ebd398450 sha512: 349cc35836ba85915ace9d7f895b712fe018452bb4b20ff257257e12adeb1e83ad780c6568a12d03f5b2cb1e3da23b8b7ced9012a188ef3855e0a8f3db211883
struct MD5Digester { static func digest(string: String) -> String? { guard let data = string.dataUsingEncoding(NSUTF8StringEncoding) else { return nil } var digest = [UInt8](count: Int(CC_MD5_DIGEST_LENGTH), repeatedValue: 0) CC_MD5(data.bytes, CC_LONG(data.length), &digest) return (0..<Int(CC_MD5_DIGEST_LENGTH)).reduce("") { $0 + String(format: "%02x", digest[$1]) } } }
func MD5(_ string: String) -> String? { let length = Int(CC_MD5_DIGEST_LENGTH) var digest = [UInt8](repeating: 0, count: length) if let d = string.data(using: String.Encoding.utf8) { _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>) in CC_MD5(body, CC_LONG(d.count), &digest) } } return (0..<length).reduce("") { $0 + String(format: "%02x", digest[$1]) } }
extension String{ var MD5:String { get{ let messageData = self.data(using:.utf8)! var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH)) _ = digestData.withUnsafeMutableBytes {digestBytes in messageData.withUnsafeBytes {messageBytes in CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes) } } return digestData.map { String(format: "%02hhx", $0) }.joined() } } }
let str = "Hello, playground" let prefixRange = str.startIndex..<str.startIndex.advancedBy(5)
str.index(after: String.Index) str.index(before: String.Index) str.index(String.Index, offsetBy: String.IndexDistance) str.index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index)
str[str.startIndex] str[str.endIndex] let range = str.startIndex..<str.endIndex str[range]
let range = str.startIndex... let range = ..<str.endIndex
let index = str.index(after: str.startIndex) str[index] let range = str.index(after: str.startIndex)..<str.endIndex str[range]
let index = str.index(before: str.endIndex) str[index] let range = str.startIndex..<str.index(before: str.endIndex) str[range]
let index = str.index(str.startIndex, offsetBy: 7) str[index] let start = str.index(str.startIndex, offsetBy: 7) let end = str.index(str.endIndex, offsetBy: -6) let range = start..<end str[range]
if let index = str.index(str.startIndex, offsetBy: 7, limitedBy: str.endIndex) { str[index] }
func textViewDidChange(_ textView: UITextView) { tableView.beginUpdates() if textView.text.contains("\n"){ textView.text.remove(at: textView.text.index(before: textView.text.endIndex)) textView.resignFirstResponder() } tableView.endUpdates() }
@objc protocol P1 : UIAdaptivePresentationControllerDelegate { } extension P1 where Self : UIViewController { func presentationController(_ controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle) -> UIViewController? { return UIViewController() } } class A : UIViewController, P1 { }
enum Router: URLRequestConvertible { static let baseURLString = "http: static let perPage = 50 case Search(query: String, page: Int) var URLRequest: NSURLRequest { let (path: String, parameters: [String: AnyObject]?) = { switch self { case .Search(let query, let page) where page > 1: return ("/search", ["q": query, "offset": Router.perPage * page]) case .Search(let query, _): return ("/search", ["q": query]) } }() let URL = NSURL(string: Router.baseURLString)! let URLRequest = NSURLRequest(URL: URL.URLByAppendingPathComponent(path)) let encoding = Alamofire.ParameterEncoding.URL return encoding.encode(URLRequest, parameters: parameters).0 } }
case CreateUser([String: AnyObject]) case ReadUser(String) case UpdateUser(String, [String: AnyObject]) case DestroyUser(String)
case CreateUser(String, String, String, String) case ReadUser(String) case UpdateUser(String, String, String, String, String) case DestroyUser(String)
let URLRequest: NSURLRequest = Router.ReadUser("cnoon")
enum Router: URLRequestConvertible { static let baseURLString = "http: case CreateUser([String: AnyObject]) case ReadUser(String) case UpdateUser(String, [String: AnyObject]) case DestroyUser(String) var method: Alamofire.HTTPMethod { switch self { case .CreateUser: return .post case .ReadUser: return .get case .UpdateUser: return .put case .DestroyUser: return .delete } } var path: String { switch self { case .CreateUser: return "/users" case .ReadUser(let username): return "/users/\(username)" case .UpdateUser(let username, _): return "/users/\(username)" case .DestroyUser(let username): return "/users/\(username)" } } }
let createUserMethod = Router.CreateUser.method let updateUserMethod = Router.UpdateUser.method
let updateUserPath = Router.UpdateUser.path let destroyUserPath = Router.DestroyUser.path
struct Router: URLRequestConvertible { static let baseURLString = "http: static var method: Method { } static func methodForEndpoint(endpoint: String) -> Method { } static var path: String { } static func pathForEndpoint(endpoint: String) -> String { } static var pathForCreateUser: String { return "/create/user/path" } static var pathForUpdateUser: String { return "/update/user/path" } }
case CreateUser(username: String, firstName: String, lastName: String, email: String) case ReadUser(username: String) case UpdateUser(username: String, firstName: String, lastName: String, email: String) case DestroyUser(username: String)
static var method: String { switch self { case let CreateUser(username: username, firstName: firstName, lastName: lastName, email: email): return "POST" default: return "GET" } }
struct Api: EndpointType { enum Environment: EnvironmentType { case localhost case test case production var value: URL.Environment { switch self { case .localhost: return .localhost(8080) case .test: return .init(IP(126, 251, 20, 32)) case .production: return .init(.https, "myproductionserver.com", 3000) } } } enum Route: RouteType { case auth, me case posts(for: Date) var route: URL.Route { switch self { case .me: return .init(at: "me") case .auth: return .init(at: "auth") case let .posts(for: date): return URL.Route(at: "posts").query(("date", date), ("userId", "someId")) } } } static let current: Environment = .localhost }
Alamofire.request(Router<Api>(at: .me)) Alamofire.request(Router<Api>(.test, at: .auth)) Alamofire.request(Router<Api>(.production, at: .posts(for: Date())))
class request{ func login(user: String, password: String){ /*use Router.login(params)*/ } enum Router: URLRequestConvertible { static let baseURLString = "http: static let OAuthToken: String? case Login([String: AnyObject]) var method: Alamofire.Method { switch self { case .Login: return .POST } var path: String { switch self { case .Login: return "/login" } } var URLRequest: NSURLRequest { switch self { case .Login(let parameters): return Alamofire.ParameterEncoding.URL.encode(mutableURLRequest, parameters: parameters).0 default: return mutableURLRequest } } } }
class requestContacts: api{ func getUser(id: String){ /*use Router.getUser(id)*/ } enum Router: URLRequestConvertible { case getUser(id: String) case setUser([String: AnyObject]) var method: Alamofire.Method { switch self { case .getUser: return .GET case .setUser: return .POST } } var path: String { switch self { case .getUser(id: String): return "/user\(id)/" case .setUser(id: String): return "/user/" } } var URLRequest: NSURLRequest { let URL = NSURL(string: Router.baseURLString)! let mutableURLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path)) mutableURLRequest.HTTPMethod = method.rawValue if let token = Router.OAuthToken { mutableURLRequest.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization") } switch self { case .setUser(let parameters): return Alamofire.ParameterEncoding.URL.encode(mutableURLRequest, parameters: parameters).0 default: return mutableURLRequest } } } }
import Alamofire enum Router: URLRequestConvertible { case createUser(parameters: Parameters) case readUser(username: String) case updateUser(username: String, parameters: Parameters) case destroyUser(username: String) static let baseURLString = "https: var method: HTTPMethod { switch self { case .createUser: return .post case .readUser: return .get case .updateUser: return .put case .destroyUser: return .delete } } var path: String { switch self { case .createUser: return "/users" case .readUser(let username): return "/users/\(username)" case .updateUser(let username, _): return "/users/\(username)" case .destroyUser(let username): return "/users/\(username)" } } func asURLRequest() throws -> URLRequest { let url = try Router.baseURLString.asURL() var urlRequest = URLRequest(url: url.appendingPathComponent(path)) urlRequest.httpMethod = method.rawValue switch self { case .createUser(let parameters): urlRequest = try URLEncoding.default.encode(urlRequest, with: parameters) case .updateUser(_, let parameters): urlRequest = try URLEncoding.default.encode(urlRequest, with: parameters) default: break } return urlRequest } }
public enum ImaggaRouter : URLRequestConvertible{ static let baseURL = "http: static let authenticationToken = "XAFDSADGDFSG DAFGDSFGL" case Content, Tags(String), Colors(String) public var URLRequest: NSMutableURLRequest { let result: (path: String, method: Alamofire.Method, parameters: [String: AnyObject]) = { switch self { case .Content: return ("/content", .POST, [String: AnyObject]()) case .Tags(let contentID): let params = [ "content" : contentID ] return ("/tagging", .GET, params) case .Colors(let contentID): let params = [ "content" : contentID, "extract_object_colors" : NSNumber(int: 0) ] return ("/colors", .GET, params) } }() let URL = NSURL(string: ImaggaRouter.baseURL)! let URLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(result.path)) URLRequest.HTTPMethod = result.method.rawValue URLRequest.setValue(ImaggaRouter.authenticationToken, forHTTPHeaderField: "Authorization") URLRequest.timeoutInterval = NSTimeInterval(10 * 1000) let encoding = Alamofire.ParameterEncoding.URL return encoding.encode(URLRequest, parameters: result.parameters).0 } }
Alamofire.request(ImaggaRouter.Tags(contentID)) .responseJSON{ response in
var optionalString: String? = "Hello" optionalString == nil var optionalName: String? = "John Appleseed" var greeting = "Hello!" if let name = optionalName { greeting = "Hello, \(name)" }
let possibleNumber = "123" let convertedNumber = possibleNumber.toInt()
let email = "foo@bar.com" if let url = URL(string: "mailto:\(email)") { if UIApplication.shared.open(url) } else { UIApplication.shared.openURL(url) } }
import UIKit import MessageUI class ViewController: UIViewController, MFMailComposeViewControllerDelegate { @IBAction func launchEmail(sender: AnyObject) { var emailTitle = "Feedback" var messageBody = "Feature request or bug report?" var toRecipents = ["friend@stackoverflow.com"] var mc: MFMailComposeViewController = MFMailComposeViewController() mc.mailComposeDelegate = self mc.setSubject(emailTitle) mc.setMessageBody(messageBody, isHTML: false) mc.setToRecipients(toRecipents) self.presentViewController(mc, animated: true, completion: nil) } func mailComposeController(controller:MFMailComposeViewController, didFinishWithResult result:MFMailComposeResult, error:NSError) { switch result { case MFMailComposeResultCancelled: print("Mail cancelled") case MFMailComposeResultSaved: print("Mail saved") case MFMailComposeResultSent: print("Mail sent") case MFMailComposeResultFailed: print("Mail sent failure: \(error?.localizedDescription)") default: break } self.dismissViewControllerAnimated(true, completion: nil) } }
func sendEmail() { if MFMailComposeViewController.canSendMail() { let mail = MFMailComposeViewController() mail.mailComposeDelegate = self mail.setToRecipients(["ved.ios@yopmail.com"]) mail.setMessageBody("<p>You present(mail, animated: true) } else { } }
func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) { controller.dismiss(animated: true) }
import MessageUI if MFMailComposeViewController.canSendMail() { let mail = MFMailComposeViewController() mail.mailComposeDelegate = self mail.setToRecipients(["test@test.test"]) mail.setSubject("Bla") mail.setMessageBody("<b>Blabla</b>", isHTML: true) presentViewController(mail, animated: true, completion: nil) } else { print("Cannot send mail") } func mailComposeController(controller: MFMailComposeViewController, didFinishWithResult result: MFMailComposeResult, error: NSError?) { switch result.rawValue { case MFMailComposeResultCancelled.rawValue: print("Cancelled") case MFMailComposeResultSaved.rawValue: print("Saved") case MFMailComposeResultSent.rawValue: print("Sent") case MFMailComposeResultFailed.rawValue: print("Error: \(error?.localizedDescription)") default: break } controller.dismissViewControllerAnimated(true, completion: nil) }
let email = "email@email.com" let url = URL(string: "mailto:\(email)") UIApplication.shared.openURL(url!)
import MessageUI if MFMailComposeViewController.canSendMail() { let mail = MFMailComposeViewController() mail.mailComposeDelegate = self mail.setToRecipients(["test@test.test"]) mail.setSubject("Bla") mail.setMessageBody("<b>Blabla</b>", isHTML: true) present(mail, animated: true, completion: nil) } else { print("Cannot send mail") } func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) { switch result.rawValue { case MFMailComposeResult.cancelled.rawValue: print("Cancelled") case MFMailComposeResult.saved.rawValue: print("Saved") case MFMailComposeResult.sent.rawValue: print("Sent") case MFMailComposeResult.failed.rawValue: print("Error: \(String(describing: error?.localizedDescription))") default: break } controller.dismiss(animated: true, completion: nil) }
func sendEmail() { if MFMailComposeViewController.canSendMail() { let mail = MFMailComposeViewController() mail.mailComposeDelegate = self mail.setToRecipients(["support@mail.com"]) mail.setSubject("Support App") mail.setMessageBody("<p>Send us your issue!</p>", isHTML: true) presentViewController(mail, animated: true, completion: nil) } else { } } func mailComposeController(controller: MFMailComposeViewController, didFinishWithResult result: MFMailComposeResult, error: NSError?) { controller.dismissViewControllerAnimated(true, completion: nil) }
let email = "foo@bar.com" if let url = URL(string: "mailto:\(email)") { UIApplication.shared.open(url, options: [:], completionHandler: nil) }
let appURL = URL(string: "mailto:BLAH@BLAH.COM")! if UIApplication.shared.open(appURL as URL, options: [:], completionHandler: nil) } else { UIApplication.shared.openURL(appURL as URL) }
@IBAction func launchEmail(sender: AnyObject) { if if MFMailComposeViewController.canSendMail() { var emailTitle = "Feedback" var messageBody = "Feature request or bug report?" var toRecipents = ["friend@stackoverflow.com"] var mc: MFMailComposeViewController = MFMailComposeViewController() mc.mailComposeDelegate = self mc.setSubject(emailTitle) mc.setMessageBody(messageBody, isHTML: false) mc.setToRecipients(toRecipents) self.present(mc, animated: true, completion: nil) } else { } } func mailComposeController(controller:MFMailComposeViewController, didFinishWithResult result:MFMailComposeResult, error:NSError) { switch result { case .cancelled: print("Mail cancelled") case .saved: print("Mail saved") case .sent: print("Mail sent") case .failed: print("Mail sent failure: \(error?.localizedDescription)") default: break } self.dismiss(animated: true, completion: nil) }
let email = "foo@bar.com" if let url = NSURL(string: "mailto:\(email)") { UIApplication.sharedApplication().openURL(url) }
let startPosition: UITextPosition = textField.beginningOfDocument
let endPosition: UITextPosition = textField.endOfDocument
let selectedRange: UITextRange? = textField.selectedTextRange
if let selectedRange = textField.selectedTextRange { let cursorPosition = textField.offset(from: textField.beginningOfDocument, to: selectedRange.start) print("\(cursorPosition)") }
let newPosition = textField.beginningOfDocument textField.selectedTextRange = textField.textRange(from: newPosition, to: newPosition)
let newPosition = textField.endOfDocument textField.selectedTextRange = textField.textRange(from: newPosition, to: newPosition)
if let selectedRange = textField.selectedTextRange { if let newPosition = textField.position(from: selectedRange.start, offset: -1) { textField.selectedTextRange = textField.textRange(from: newPosition, to: newPosition) } }
let arbitraryValue: Int = 5 if let newPosition = textField.position(from: textField.beginningOfDocument, offset: arbitraryValue) { textField.selectedTextRange = textField.textRange(from: newPosition, to: newPosition) }
textField.selectedTextRange = textField.textRange(from: textField.beginningOfDocument, to: textField.endOfDocument)
let startPosition = textField.position(from: textField.beginningOfDocument, offset: 3) let endPosition = textField.position(from: textField.beginningOfDocument, offset: 7) if startPosition != nil && endPosition != nil { textField.selectedTextRange = textField.textRange(from: startPosition!, to: endPosition!) }
func textViewDidBeginEditing(_ textView: UITextView) { DispatchQueue.main.async{ textField.selectedTextRange = ... } }
func println(object: Any) { Swift.println(object) }
func println(object: Any) { Swift.println(object) }
func print(items: Any..., separator: String = " ", terminator: String = "\n") { Swift.print(items[0], separator:separator, terminator: terminator) }
func print(_ items: Any..., separator: String = " ", terminator: String = "\n") { Swift.print(items[0], separator:separator, terminator: terminator) }
func print(items: Any..., separator: String = " ", terminator: String = "\n") { var idx = items.startIndex let endIdx = items.endIndex repeat { Swift.print(items[idx], separator: separator, terminator: idx == (endIdx - 1) ? terminator : separator) idx += 1 } while idx < endIdx }
func print(_ item: @autoclosure () -> Any, separator: String = " ", terminator: String = "\n") { Swift.print(item(), separator: separator, terminator: terminator) }
class Log { var intFor : Int init() { intFor = 42 } func DLog(message: String, function: String = __FUNCTION__) { println("\(function): \(message)") } }
// // // // // // func log(message: String = "", filePath: String = var threadName = "" threadName = NSThread.currentThread().isMainThread ? "MAIN THREAD" : (NSThread.currentThread().name ?? "UNKNOWN THREAD") threadName = "[" + threadName + "] " let fileName = NSURL(fileURLWithPath: filePath).URLByDeletingPathExtension?.lastPathComponent ?? "???" var msg = "" if message != "" { msg = " - \(message)" } NSLog("-- " + threadName + fileName + "(\(line))" + " -> " + function + msg) NSLog(message) }
2016-01-13 23:48:38.026 FoodTracker[48735:4147607] -- [MAIN THREAD] ViewController(19) -> viewDidLoad() - hello
override func viewDidLoad() { log("hello") super.viewDidLoad() nameTextField.delegate = self }
func gLog<T>( _ object: @autoclosure() -> T, _ file: String = { let value = object() let stringRepresentation: String if let value = value as? CustomDebugStringConvertible { stringRepresentation = value.debugDescription } else if let value = value as? CustomStringConvertible { stringRepresentation = value.description } else { fatalError("gLog only works for values that conform to CustomDebugStringConvertible or CustomStringConvertible") } let fileURL = NSURL(string: file)?.lastPathComponent ?? "Unknown file" let queue = Thread.isMainThread ? "UI" : "BG" let gFormatter = DateFormatter() gFormatter.dateFormat = "HH:mm:ss:SSS" let timestamp = gFormatter.string(from: Date()) print("‚úÖ \(timestamp) {\(queue)} \(fileURL) > \(function)[\(line)]: " + stringRepresentation + "\n") }
func println(object: Any) {} func print(object: Any){}
func print(_ items: Any..., separator separator: String = default, terminator terminator: String = default)
func dPrint(_ message: @autoclosure () -> Any) { print(message()) }
func print(_ items: Any...) { items.forEach { item in Swift.print(item) } }
public func debugPrint(items: Any..., separator: String = " ", terminator: String = "\n") { } public func print(_ items: Any..., separator: String = " ", terminator: String = "\n") { } class AppDelegate: UIResponder, UIApplicationDelegate { }
import UIKit class DLog: NSObject { init(title:String, log:Any) { print(title, log) } }
import UIKit class NotesListViewController: UITableViewController { @IBOutlet weak var menuButton: UIBarButtonItem! override func viewDidLoad() { super.viewDidLoad() NSNotificationCenter.defaultCenter().addObserver(self, selector: "preferredContentSizeChanged:", name: UIContentSizeCategoryDidChangeNotification, object: nil) if self.revealViewController() != nil { menuButton.target = self.revealViewController() menuButton.action = "revealToggle:" self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer()) } } override func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) tableView.reloadData() } func preferredContentSizeChanged(notification: NSNotification) { tableView.reloadData() } override func numberOfSectionsInTableView(tableView: UITableView) -> Int { return 1 } override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return notes.count } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as UITableViewCell let note = notes[indexPath.row] let font = UIFont.preferredFontForTextStyle(UIFontTextStyleHeadline) let textColor = UIColor(red: 0.175, green: 0.458, blue: 0.831, alpha: 1) let attributes = [ NSForegroundColorAttributeName : textColor, NSFontAttributeName : font, NSTextEffectAttributeName : NSTextEffectLetterpressStyle ] let attributedString = NSAttributedString(string: note.title, attributes: attributes) cell.textLabel?.font = UIFont.preferredFontForTextStyle(UIFontTextStyleHeadline) cell.textLabel?.attributedText = attributedString return cell } let label: UILabel = { let temporaryLabel = UILabel(frame: CGRect(x: 0, y: 0, width: Int.max, height: Int.max)) temporaryLabel.text = "test" return temporaryLabel }() override func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { label.font = UIFont.preferredFontForTextStyle(UIFontTextStyleHeadline) label.sizeToFit() return label.frame.height * 1.7 } override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if editingStyle == .Delete { notes.removeAtIndex(indexPath.row) tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) } } override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) { if let editorVC = segue.destinationViewController as? NoteEditorViewController { if "CellSelected" == segue.identifier { if let path = tableView.indexPathForSelectedRow() { editorVC.note = notes[path.row] } } else if "AddNewNote" == segue.identifier { let note = Note(text: " ") editorVC.note = note notes.append(note) } } } }
self.tableView.register(UITableViewCell.self, forCellReuseIdentifier: "cell")
self.tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: "cell")
let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath) as UITableViewCell
self.tableView.register(UITableViewCell.self, forCellWithReuseIdentifier: "cell")
self.tableView.register(UITableViewCell.classForKeyedArchiver(), forCellReuseIdentifier: "Cell")
self.tableView.registerClass(UITableViewCell.classForKeyedArchiver(), forCellReuseIdentifier: "Cell")
tableView.register(UINib(nibName: "YourCellXibName", bundle: nil), forCellReuseIdentifier: "Cell")
storyboard?.instantiateViewController(withIdentifier: "some_identifier")
editButton.userInteractionEnabled = false editButton.isUserInteractionEnabled = false
@IBAction func pressButton(sender: AnyObject) { var disableMyButton = sender as? UIButton disableMyButton.enabled = false }
@IBAction func yourButtonMethodname(sender: AnyObject) { yourButton.isEnabled = false }
myButton.isEnabled = false myButton.isUserInteractionEnabled = false
let input = 42.13 let bytes = input.data let roundtrip = bytes.to(Double)
let value = 42.13 let data = withUnsafeBytes(of: value) { Data($0) } print(data as NSData)
let value = 42.13 var mutableValue = value let data = withUnsafeBytes(of: &mutableValue) { Data.init($0) }
let data = Data(bytes: [0x71, 0x3d, 0x0a, 0xd7, 0xa3, 0x10, 0x45, 0x40]) let value = data.withUnsafeBytes { (ptr: UnsafePointer<Double>) -> Double in return ptr.pointee } print(value)
let data = Data(bytes: [0x71, 0x3d, 0x0a, 0xd7, 0xa3, 0x10, 0x45, 0x40]) let value: Double = data.withUnsafeBytes { $0.pointee } print(value)
extension Data { init<T>(from value: T) { self = Swift.withUnsafeBytes(of: value) { Data($0) } } func to<T>(type: T.Type) -> T { return self.withUnsafeBytes { $0.pointee } } }
let value = 42.13 let data = Data(from: value) print(data as NSData) let roundtrip = data.to(type: Double.self) print(roundtrip)
extension Data { init<T>(fromArray values: [T]) { self = values.withUnsafeBytes { Data($0) } } func toArray<T>(type: T.Type) -> [T] { return self.withUnsafeBytes { [T](UnsafeBufferPointer(start: $0, count: self.count/MemoryLayout<T>.stride)) } } }
let value: [Int16] = [1, Int16.max, Int16.min] let data = Data(fromArray: value) print(data as NSData) let roundtrip = data.toArray(type: Int16.self) print(roundtrip)
protocol DataConvertible { init?(data: Data) var data: Data { get } }
extension DataConvertible { init?(data: Data) { guard data.count == MemoryLayout<Self>.size else { return nil } self = data.withUnsafeBytes { $0.pointee } } var data: Data { return withUnsafeBytes(of: self) { Data($0) } } }
extension Int : DataConvertible { } extension Float : DataConvertible { } extension Double : DataConvertible { }
let value = 42.13 let data = value.data print(data as NSData) if let roundtrip = Double(data: data) { print(roundtrip) }
extension String: DataConvertible { init?(data: Data) { self.init(data: data, encoding: .utf8) } var data: Data { return self.data(using: .utf8)! } }
let value = 1000 let data = value.bigEndian.data print(data as NSData) if let roundtrip = Int(data: data) { print(Int(bigEndian: roundtrip)) }
extension UInt16 : DataConvertible { init?(data: Data) { guard data.count == MemoryLayout<UInt16>.size else { return nil } self = data.withUnsafeBytes { $0.pointee } } var data: Data { var value = CFSwapInt16HostToBig(self) return Data(buffer: UnsafeBufferPointer(start: &value, count: 1)) } }
[!] The X target overrides the `EMBEDDED_CONTENT_CONTAINS_SWIFT` build setting defined in `X‚Äô. This can lead to problems with the CocoaPods installation - Use the `$(inherited)` flag, or - Remove the build settings from the target. [!] The `X` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `X - Use the `$(inherited)` flag, or - Remove the build settings from the target.
post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[ end end end
[!] The `X` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `X - Use the `$(inherited)` flag, or - Remove the build settings from the target.
pod deintegrate || rm -rf Pods pod install --verbose rm -rf ~/Library/Developer/Xcode/DerivedData
Feed TableView PostCell Comments (TableView) CommentCell PostCell Comments (TableView) CommentCell CommentCell CommentCell CommentCell CommentCell
func animateAddOrDeleteComments(startRow: Int, endRow: Int, operation: CellOperation) { let table = self.superview?.superview as UITableView table.beginUpdates() self.comments.beginUpdates() var indexPaths = [NSIndexPath]() for var index = startRow; index <= endRow; index++ { indexPaths.append(NSIndexPath(forRow: index, inSection: 0)) } switch operation { case .INSERT: self.comments.insertRowsAtIndexPaths(indexPaths, withRowAnimation: UITableViewRowAnimation.None) case .DELETE: self.comments.deleteRowsAtIndexPaths(indexPaths, withRowAnimation: UITableViewRowAnimation.None) case .RELOAD: self.comments.reloadRowsAtIndexPaths(indexPaths, withRowAnimation: UITableViewRowAnimation.None) } self.comments.endUpdates() table.endUpdates() self.setNeedsUpdateConstraints() } override func updateConstraints() { super.updateConstraints() self.commentsHeight.constant = self.comments.sizeThatFits(UILayoutFittingCompressedSize).height }
self.tableView.rowHeight = UITableViewAutomaticDimension self.tableView.estimatedRowHeight = 560
- (void)viewDidLoad { [super viewDidLoad]; self.heightAtIndexPath = [NSMutableDictionary new]; self.tableView.rowHeight = UITableViewAutomaticDimension; } - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { NSNumber *height = [self.heightAtIndexPath objectForKey:indexPath]; if(height) { return height.floatValue; } else { return UITableViewAutomaticDimension; } } - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath { NSNumber *height = @(cell.frame.size.height); [self.heightAtIndexPath setObject:height forKey:indexPath]; }
@IBOutlet var tableView : UITableView? var heightAtIndexPath = NSMutableDictionary() override func viewDidLoad() { super.viewDidLoad() tableView?.rowHeight = UITableViewAutomaticDimension } func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat { if let height = heightAtIndexPath.object(forKey: indexPath) as? NSNumber { return CGFloat(height.floatValue) } else { return UITableViewAutomaticDimension } } func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { let height = NSNumber(value: Float(cell.frame.size.height)) heightAtIndexPath.setObject(height, forKey: indexPath as NSCopying) }
- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { NSString *cellType = [self reuseIdentifierForIndexPath:indexPath]; if ([cellType isEqualToString:kFirstCellIdentifier]) return kFirstCellHeight; else if ([cellType isEqualToString:kSecondCellIdentifier]) return kSecondCellHeight; else if ([cellType isEqualToString:kThirdCellIdentifier]) return kThirdCellHeight; else { return UITableViewAutomaticDimension; } }
func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { let cellType = reuseIdentifierForIndexPath(indexPath) if cellType == kFirstCellIdentifier return kFirstCellHeight else if cellType == kSecondCellIdentifier return kSecondCellHeight else if cellType == kThirdCellIdentifier return kThirdCellHeight else return UITableViewAutomaticDimension }
func viewDidLoad() { .... your code self.tableView.rowHeight = UITableViewAutomaticDimension }
override func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { let height = self.heightAtIndexPath.objectForKey(indexPath) if ((height) != nil) { return CGFloat(height!.floatValue) } else { return UITableViewAutomaticDimension } } override func tableView(tableView: UITableView, willDisplayCell cell: UITableViewCell, forRowAtIndexPath indexPath: NSIndexPath) { let height = cell.frame.size.height self.heightAtIndexPath.setObject(height, forKey: indexPath) }
var heightAtIndexPath = [IndexPath: CGFloat]() func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat { return self.heightAtIndexPath[indexPath] ?? UITableViewAutomaticDimension } func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { self.heightAtIndexPath[indexPath] = cell.frame.size.height }
cell.setNeedsUpdateConstraints() cell.updateConstraintsIfNeeded()
var heightAtIndexPath = [NSIndexPath : NSNumber]() .... tableView.rowHeight = UITableViewAutomaticDimension tableView.estimatedRowHeight = UITableViewAutomaticDimension .... extension TableViewViewController: UITableViewDelegate { func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat { let height = heightAtIndexPath[indexPath] if let height = height { return CGFloat(height) } else { return UITableViewAutomaticDimension } } func tableView(tableView: UITableView, willDisplayCell cell: UITableViewCell, forRowAtIndexPath indexPath: NSIndexPath) { let height: NSNumber = CGRectGetHeight(cell.frame) heightAtIndexPath[indexPath] = height } func tableView(tableView: UITableView, didEndDisplayingCell cell: UITableViewCell, forRowAtIndexPath indexPath: NSIndexPath) { let height: NSNumber = CGRectGetHeight(cell.frame) heightAtIndexPath[indexPath] = height } }
@IBOutlet var tableView : UITableView! var heightAtIndexPath = NSMutableDictionary() override func viewDidLoad() { super.viewDidLoad() tableView?.rowHeight = UITableViewAutomaticDimension } func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat { if let height = heightAtIndexPath.object(forKey: indexPath) as? NSNumber { return CGFloat(height.floatValue) } else { return UITableViewAutomaticDimension } } func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { let height = NSNumber(value: Float(cell.frame.size.height)) heightAtIndexPath.setObject(height, forKey: indexPath as NSCopying) }
tableView.reloadData() self.tableView.layoutIfNeeded() self.tableView.setContentOffset(CGPoint.zero, animated: true)
let msg = "*** Error \(options["taskDescription"]): cannot load \(sUrl) \(error)"
let msg = "*** Error \(String(describing: options["taskDescription"])): cannot load \(sUrl) \(error)"
var i: Int? = 5 var d: Double? = nil print("description of i: \(i as Int?)") print("description of d: \(d as Double?)")
print("description of i: \(i as Optional)") print("description of d: \(d as Optional)")
print("description of i: \(i.debugDescription)") print("description of d: \(d.debugDescription)")
var someValue: Int? = 5 if let newValue = someValue { print(newValue) }
var optionalString : String? = nil var optionalInt : Int? = nil var description_ = "" description_ = description_ + "optionalString: \(String(describing: optionalString))\r" description_ = description_ + " optionalInt: \(String(describing: optionalInt))\r" print(description_)
extension Optional { var orNil : String { if self == nil { return "nil" } if "\(Wrapped.self)" == "String" { return "\"\(self!)\"" } return "\(self!)" } }
var s : String? var i : Int? var d : Double? var mixed = "s = \(s.orNil) i = \(i.orNil) d = \(d.orNil)" d = 3 i = 5 s = "" mixed = "s = \(s.orNil) i = \(i.orNil) d = \(d.orNil)" s = "Test" d = nil mixed = "s = \(s.orNil) i = \(i.orNil) d = \(d.orNil)"
var someValue: Int? = 5 print("The value is \(someValue ??? "unknown")") someValue = nil print("The value is \(someValue ??? "unknown")")
import ObjectiveC private var AssociatedObjectHandle: UInt8 = 0 extension MyClass { var stringProperty:String { get { return objc_getAssociatedObject(self, &AssociatedObjectHandle) as! String } set { objc_setAssociatedObject(self, &AssociatedObjectHandle, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } }
get { return objc_getAssociatedObject(self, &AssociatedObjectHandle) as? String ?? "" }
import ObjectiveC final class Lifted<T> { let value: T init(_ x: T) { value = x } } private func lift<T>(x: T) -> Lifted<T> { return Lifted(x) } func setAssociatedObject<T>(object: AnyObject, value: T, associativeKey: UnsafePointer<Void>, policy: objc_AssociationPolicy) { if let v: AnyObject = value as? AnyObject { objc_setAssociatedObject(object, associativeKey, v, policy) } else { objc_setAssociatedObject(object, associativeKey, lift(value), policy) } } func getAssociatedObject<T>(object: AnyObject, associativeKey: UnsafePointer<Void>) -> T? { if let v = objc_getAssociatedObject(object, associativeKey) as? T { return v } else if let v = objc_getAssociatedObject(object, associativeKey) as? Lifted<T> { return v.value } else { return nil } }
extension UIView { private struct AssociatedKey { static var viewExtension = "viewExtension" } var referenceTransform: CGAffineTransform? { get { return getAssociatedObject(self, associativeKey: &AssociatedKey.viewExtension) } set { if let value = newValue { setAssociatedObject(self, value: value, associativeKey: &AssociatedKey.viewExtension, policy: objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } }
import ObjectiveC var kSomeKey = "s" ‚Ä¶ func someFunc() { objc_setAssociatedObject(target, &kSomeKey, value, UInt(OBJC_ASSOCIATION_RETAIN)) let value : AnyObject! = objc_getAssociatedObject(target, &kSomeKey) }
import Foundation import UIKit import ObjectiveC var AssociatedObjectHandle: UInt8 = 0 extension UITextField { var nextTextField:UITextField { get { return objc_getAssociatedObject(self, &AssociatedObjectHandle) as! UITextField } set { objc_setAssociatedObject(self, &AssociatedObjectHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } }
import ObjectiveC let value = NSUUID().UUIDString var associationKey: UInt8 = 0 objc_setAssociatedObject(parentObject, &associationKey, value, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) let fetchedValue = objc_getAssociatedObject(parentObject, &associationKey) as! String
import UIKit public extension UICollectionView { typealias XYRearrangeNewDataBlock = (_ newData: [Any]) -> Void typealias XYRearrangeOriginaDataBlock = () -> [Any] private struct xy_associatedKeys { static var originalDataBlockKey = "xy_originalDataBlockKey" static var newDataBlockKey = "xy_newDataBlockKey" } private class BlockContainer { var rearrangeNewDataBlock: XYRearrangeNewDataBlock? var rearrangeOriginaDataBlock: XYRearrangeOriginaDataBlock? } private var newDataBlock: BlockContainer? { get { if let newDataBlock = objc_getAssociatedObject(self, &xy_associatedKeys.newDataBlockKey) as? BlockContainer { return newDataBlock } return nil } set(newValue) { objc_setAssociatedObject(self, xy_associatedKeys.newDataBlockKey, newValue, .OBJC_ASSOCIATION_COPY_NONATOMIC) } } convenience init(collectionVewFlowLayout : UICollectionViewFlowLayout, originalDataBlock: @escaping XYRearrangeOriginaDataBlock, newDataBlock: @escaping XYRearrangeNewDataBlock) { self.init() let blockContainer: BlockContainer = BlockContainer() blockContainer.rearrangeNewDataBlock = newDataBlock blockContainer.rearrangeOriginaDataBlock = originalDataBlock self.newDataBlock = blockContainer }
import UIKit import AVFoundation class ViewController: UIViewController { var audioPlayer = AVAudioPlayer() override func viewDidLoad() { super.viewDidLoad() var alertSound = NSURL(fileURLWithPath: NSBundle.mainBundle().pathForResource("button-09", ofType: "wav")) println(alertSound) var error:NSError? audioPlayer = AVAudioPlayer(contentsOfURL: alertSound, error: &error) audioPlayer.prepareToPlay() audioPlayer.play() } }
import UIKit import AVFoundation class ViewController: UIViewController { var audioPlayer = AVAudioPlayer() override func viewDidLoad() { super.viewDidLoad() var alertSound = NSURL(fileURLWithPath: NSBundle.mainBundle().pathForResource("button-09", ofType: "wav")) println(alertSound) AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback, error: nil) AVAudioSession.sharedInstance().setActive(true, error: nil) var error:NSError? audioPlayer = AVAudioPlayer(contentsOfURL: alertSound, error: &error) audioPlayer.prepareToPlay() audioPlayer.play() } }
import UIKit import AVFoundation class ViewController: UIViewController { private var audioPlayer: AVAudioPlayer? override func viewDidLoad() { super.viewDidLoad() let alertSound = URL(fileURLWithPath: Bundle.main.path(forResource: "button-09", ofType: "wav")!) print(alertSound) try! AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback) try! AVAudioSession.sharedInstance().setActive(true) try! audioPlayer = AVAudioPlayer(contentsOf: alertSound) audioPlayer!.prepareToPlay() audioPlayer!.play() } }
var audioPlayer : AVAudioPlayer! func playSound(soundName: String) { let coinSound = NSURL(fileURLWithPath: NSBundle.mainBundle().pathForResource(soundName, ofType: "m4a")!) do{ audioPlayer = try AVAudioPlayer(contentsOfURL:coinSound) audioPlayer.prepareToPlay() audioPlayer.play() }catch { print("Error getting the audio file") } }
import UIKit import AVFoundation class ViewController: UIViewController { var player:AVAudioPlayer = AVAudioPlayer() override func viewDidLoad() { super.viewDidLoad() let audioPath = NSBundle.mainBundle().pathForResource("ARRehman", ofType: "mp3") var error:NSError? = nil do { player = try AVAudioPlayer(contentsOfURL: NSURL(fileURLWithPath: audioPath!)) } catch { print("Something bad happened. Try catching specific errors to narrow things down") } } @IBAction func play(sender: UIBarButtonItem) { player.play() } @IBAction func stop(sender: UIBarButtonItem) { player.stop() print(player.currentTime) player.currentTime = 0 } @IBAction func pause(sender: UIBarButtonItem) { player.pause() } @IBOutlet weak var sliderval: UISlider! @IBAction func slidermov(sender: UISlider) { player.volume = sliderval.value print(player.volume) } }
import UIKit import AVFoundation class ViewController: UIViewController { var ding:AVAudioPlayer = AVAudioPlayer() override func viewDidLoad() { super.viewDidLoad() prepareAudios() ding.play() } func prepareAudios() { var path = NSBundle.mainBundle().pathForResource("ding", ofType: "mp3") ding = AVAudioPlayer(contentsOfURL: NSURL(fileURLWithPath: path!), error: nil) ding.prepareToPlay() } }
import SpriteKit import AVFoundation func playEffectSound(filename: String){ runAction(SKAction.playSoundFileNamed("\(filename)", waitForCompletion: false)) } playEffectSound("Sound File Name With Extension")
import UIKit import AVFoundation class ViewController: UIViewController { var audioPlayer: AVAudioPlayer? override func viewDidLoad() { super.viewDidLoad() play(for: "button-09", type: "wav") } func play(for resource: String, type: String) { guard let path = Bundle.main.path(forResource: resource, ofType: type) else { return } let sound = URL(fileURLWithPath: path) do { audioPlayer = try AVAudioPlayer(contentsOf: sound) audioPlayer?.prepareToPlay() audioPlayer?.play() } catch { assert(false, error.localizedDescription) } } }
import UIKit import AVFoundation class ViewController: UIViewController { var audioPlayer: AVAudioPlayer? override func viewDidLoad() { super.viewDidLoad() prepareAudioSession() } func prepareAudioSession() -> Void { do { try AVAudioSession.sharedInstance().setCategory(AVAudioSession.Category.playback, mode: AVAudioSession.Mode.default, options: AVAudioSession.CategoryOptions.defaultToSpeaker) try AVAudioSession.sharedInstance().setActive(true) prepareAudioPlayer() } catch { print("Issue with Audio Session") } } func prepareAudioPlayer() -> Void { let audioFileName = "test" let audioFileExtension = "mp3" guard let filePath = Bundle.main.path(forResource: audioFileName, ofType: audioFileExtension) else { print("Audio file not found at specified path") return } let alertSound = URL(fileURLWithPath: filePath) try? audioPlayer = AVAudioPlayer(contentsOf: alertSound) audioPlayer?.prepareToPlay() } func playAudioPlayer() -> Void { audioPlayer?.play() } func pauseAudioPlayer() -> Void { if audioPlayer?.isPlaying ?? false { audioPlayer?.pause() } } func stopAudioPlayer() -> Void { if audioPlayer?.isPlaying ?? false { audioPlayer?.stop() } } func resetAudioPlayer() -> Void { stopAudioPlayer() audioPlayer?.currentTime = 0 playAudioPlayer() } }
func doStuff(completion: (foo: Int, bar: String) -> Void) { ... completion(foo: 0, bar: "") }
func doStuff(completion: ((foo: Int, bar: String)) -> Void) { ... completion((foo: 0, bar: "")) }
struct LineNoteCellState { var lineNoteText: String? var printOnInvoice = false var printOnLabel = false }
cell.configure(editCallback: { (_ state: LineNoteCellState) in self.lineNoteText = state.lineNoteText self.printOnInvoice = state.printOnInvoice self.printOnLabel = state.printOnLabel })
Alamofire.request(.GET, "url").authenticate(user: "", password: "").responseJSON() { (request, response, json, error) in println(error) println(json) }
Optional(Error Domain=NSCocoaErrorDomain Code=3840 "The operation couldn‚Äôt be completed. (Cocoa error 3840.)" (Invalid value around character 0.) UserInfo=0x78e74b80 {NSDebugDescription=Invalid value around character 0.})
multipartFormData.appendBodyPart(data: image1Data, name: "file")
multipartFormData.appendBodyPart(data: image1Data, name: "file", fileName: "myImage.png", mimeType: "image/png")
Alamofire.request(.GET, "YOUR_URL") .validate() .responseString { response in print("Success: \(response.result.isSuccess)") print("Response String: \(response.result.value)") }
Alamofire.request(.GET, "url") .validate(contentType: ["application/json"]) .authenticate(user: "", password: "") .responseJSON() { response in switch response.result { case .Success: print("It worked!") print(response.result.value) case .Failure(let error): print(error) } }
public func fetchDataFromServerUsingXWWWFormUrlencoded(parameter:NSDictionary, completionHandler: @escaping (_ result:NSDictionary) -> Void) -> Void { let headers = ["Content-Type": "application/x-www-form-urlencoded"] let completeURL = "http: Alamofire.request(completeURL, method: .post, parameters: (parameter as! Parameters), encoding: URLEncoding.default, headers: headers).responseJSON { response in if let JSON = response.result.value { print("JSON: \(JSON)") completionHandler(JSON as! NSDictionary) } else { print(response.result.error!) } } }
responseSerializationFailed(Alamofire.AFError.ResponseSerializationFailureReason.jsonSerializationFailed(Error Domain=NSCocoaErrorDomain Code=3840 "Invalid value around character 0." UserInfo={NSDebugDescription=Invalid value around character 0.}))
let headers: HTTPHeaders = [ "Authorization": "Info XXX", "Accept": "application/json", "Content-Type" :"application/json" ] let parameters:Parameters = [ "items": [ "item1" : value, "item2": value, "item3" : value ] ] Alamofire.request("URL",method: .post, parameters: parameters,encoding:URLEncoding.queryString, headers: headers).responseJSON { response in debugPrint(response) }
let header = [ "Content-Type" : "application/json; charset=utf-8" ] let body: [String: Any] = [ "email": lowerCasedEmail, "password": password ] Alamofire.request(LOGIN_USER, method: .post, parameters: body, encoding: JSONEncoding.default, headers: header).responseJSON { (response) in if response.result.error == nil { if let data = response.result.value as? Dictionary<String, AnyObject> { if let email = data["user"] as? String { self.userEmail = email print(self.userEmail) } if let token = data["token"] as? String { self.token_Key = token print(self.token_Key) }
let HOME_URL = "http: let BASE_URL = "http: let UPLOAD_URL = "http:
let Auth_header: [String:String] = ["Accept":"application/json", "Content-Type" : "application/json", "Authorization":"Bearer MyToken"]
let params = [kService: service, kUserPath: companyModal.directory_path, kCompanyDomain: UserDefaults.companyDomain, kImageObject: imageString, kEntryArray: jsonString, kUserToken: UserDefaults.authToken] as [String : Any]
let params = [kService: kGetSingleEntry, kUserPath: companyModal.directory_path ?? "", kCompanyDomain: UserDefaults.companyDomain, kUserToken: UserDefaults.authToken, kEntryId: id, ] as [String: Any]
Alamofire.request(urlString, method: .post, parameters: parameters,encoding: JSONEncoding.default, headers: nil).responseJSON { response in switch response.result { case .success: print(response) break case .failure(let error): print(error) } }
UserDefaults.standard.set(true, forKey: "Key") UserDefaults.standard.set(1, forKey: "Key") UserDefaults.standard.set("TEST", forKey: "Key")
UserDefaults.standard.bool(forKey: "Key") UserDefaults.standard.integer(forKey: "Key") UserDefaults.standard.string(forKey: "Key")
if let appDomain = Bundle.main.bundleIdentifier { UserDefaults.standard.removePersistentDomain(forName: appDomain) }
NSUserDefaults.standardUserDefaults().setObject(newValue, forKey: "yourkey") NSUserDefaults.standardUserDefaults().synchronize()
var returnValue: [NSString]? = NSUserDefaults.standardUserDefaults().objectForKey("yourkey") as? [NSString]
NSUserDefaults.standardUserDefaults().removeObjectForKey("yourkey")
extension UserDefaults{ func setLoggedIn(value: Bool) { set(value, forKey: UserDefaultsKeys.isLoggedIn.rawValue) } func isLoggedIn()-> Bool { return bool(forKey: UserDefaultsKeys.isLoggedIn.rawValue) } func setUserID(value: Int){ set(value, forKey: UserDefaultsKeys.userID.rawValue) } func getUserID() -> Int{ return integer(forKey: UserDefaultsKeys.userID.rawValue) } }
enum UserDefaultsKeys : String { case isLoggedIn case userID }
UserDefaults.standard.setLoggedIn(value: true) UserDefaults.standard.setUserID(value: result.User.id!)
print("ID : \(UserDefaults.standard.getUserID())") UserDefaults.standard.getUserID()
UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.userID)
UserDefaults.standard.set(object/value, forKey: "key_name")
var returnValue: [datatype]? = UserDefaults.standard.object(forKey: "key_name") as? [datatype]
UserDefaults.standard.removeObject(forKey:"key_name")
@IBAction func writeButton(sender: UIButton) { let defaults = NSUserDefaults.standardUserDefaults() defaults.setObject("defaultvalue", forKey: "userNameKey") } @IBAction func readButton(sender: UIButton) { let defaults = NSUserDefaults.standardUserDefaults() let name = defaults.stringForKey("userNameKey") println(name) }
NSUserDefaults.standardUserDefaults().setObject("yourString", forKey: "YourStringKey") let yourStr : AnyObject? = NSUserDefaults.standardUserDefaults().objectForKey("YourStringKey")
dictForaddress = placemark.addressDictionary! as NSDictionary let userDefaults = UserDefaults.standard userDefaults.set(dictForaddress, forKey:Constants.kAddressOfUser)
let userDefaults = UserDefaults.standard let dictAddress = userDefaults.object(forKey: Constants.kAddressOfUser) as! NSDictionary
let text = "hai" UserDefaults.standard.setValue(text, forKey: "textValue")
var valueOfText = UserDefaults.value(forKey: "textValue")
class UserDefaults_WorstPresidentName { static let key = "appname.worstPresidentName" static var value: String? { get { return UserDefaults.standard.string(forKey: key) } set { if newValue != nil { UserDefaults.standard.set(newValue, forKey: key) } else { UserDefaults.standard.removeObject(forKey: key) } } } }
enum UserDefaultsConstant : String { case AuthToken, FcmToken static let defaults = UserDefaults.standard func setValue(value : Any) { switch self { case .AuthToken,.FcmToken: if let _ = value as? String { UserDefaults.standard.set(value, forKey: self.rawValue) } break } UserDefaults.standard.synchronize() } func getValue() -> Any? { switch self { case .AuthToken: if(UserDefaults.standard.value(forKey: UserDefaultsConstant.AuthToken.rawValue) != nil) { return "Bearer "+(UserDefaults.standard.value(forKey: UserDefaultsConstant.AuthToken.rawValue) as! String) } else { return "" } case .FcmToken: if(UserDefaults.standard.value(forKey: UserDefaultsConstant.FcmToken.rawValue) != nil) { print(UserDefaults.standard.value(forKey: UserDefaultsConstant.FcmToken.rawValue)) return (UserDefaults.standard.value(forKey: UserDefaultsConstant.FcmToken.rawValue) as! String) } else { return "" } } } func removeValue() { UserDefaults.standard.removeObject(forKey: self.rawValue) UserDefaults.standard.synchronize() } }
if let authToken = resp.data?.token { UserDefaultsConstant.AuthToken.setValue(value: authToken) }
(UserDefaultsConstant.AuthToken.getValue() as! String)
let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "MM-dd-yyyy" dateFormatter.timeZone = NSTimeZone(name: "UTC") let date: NSDate? = dateFormatter.dateFromString("2016-02-29 12:24:26") print(date)
let dateFormatterGet = NSDateFormatter() dateFormatterGet.dateFormat = "yyyy-MM-dd HH:mm:ss" let dateFormatterPrint = NSDateFormatter() dateFormatterPrint.dateFormat = "MMM dd,yyyy" let date: NSDate? = dateFormatterGet.dateFromString("2016-02-29 12:24:26") print(dateFormatterPrint.stringFromDate(date!))
let dateFormatterGet = DateFormatter() dateFormatterGet.dateFormat = "yyyy-MM-dd HH:mm:ss" let dateFormatterPrint = DateFormatter() dateFormatterPrint.dateFormat = "MMM dd,yyyy" if let date = dateFormatterGet.date(from: "2016-02-29 12:24:26") { print(dateFormatterPrint.string(from: date)) } else { print("There was an error decoding the string") }
let dateFormatterGet = DateFormatter() dateFormatterGet.dateFormat = "yyyy-MM-dd HH:mm:ss" let dateFormatter = DateFormatter() dateFormatter.dateFormat = "MMM dd,yyyy" let date: Date? = dateFormatterGet.date(from: "2017-02-14 17:24:26") print(dateFormatter.string(from: date!))
let dateFormatter = DateFormatter() dateFormatter.dateStyle = .medium dateFormatter.timeStyle = .none dateFormatter.locale = Locale(identifier: "en_US") print(dateFormatter.string(from: date))
extension Date { static func getFormattedDate(string: String) -> String{ let dateFormatter = DateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss +zzzz" let formateDate = dateFormatter.date(from:"2018-02-02 06:50:16 +0000")! dateFormatter.dateFormat = "dd-MM-yyyy" print ("Print :\(dateFormatter.string(from: formateDate))") return dateFormatter.string(from: formateDate) } }
extension Date { static func getFormattedDate(string: String , formatter:String) -> String{ let dateFormatterGet = DateFormatter() dateFormatterGet.dateFormat = "yyyy-MM-dd let dateFormatterPrint = DateFormatter() dateFormatterPrint.dateFormat = "MMM dd,yyyy" let date: Date? = dateFormatterGet.date(from: "2018-02-01T19:10:04+00:00") print("Date",dateFormatterPrint.string(from: date!)) return dateFormatterPrint.string(from: date!); } }
Wednesday, Sep 12, 2018 --> EEEE, MMM d, yyyy 09/12/2018 --> MM/dd/yyyy 09-12-2018 14:11 --> MM-dd-yyyy HH:mm Sep 12, 2:11 PM --> MMM d, h:mm a September 2018 --> MMMM yyyy Sep 12, 2018 --> MMM d, yyyy Wed, 12 Sep 2018 14:11:54 +0000 --> E, d MMM yyyy HH:mm:ss Z 2018-09-12T14:11:54+0000 --> yyyy-MM-dd 12.09.18 --> dd.MM.yy 10:41:02.112 --> HH:mm:ss.SSS
let date : Date = Date() let dateFormatter = DateFormatter() dateFormatter.dateFormat = "MMM dd, yyyy" let todaysDate = dateFormatter.string(from: date)
extension Date { func string(with format: String) -> String { let dateFormatter = DateFormatter() dateFormatter.dateFormat = format return dateFormatter.string(from: self) } }
let date = Date() date.string(with: "MMM dd, yyyy")
let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "yyyy-MM-dd hh:mm:ss"
let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "MMM dd, yyyy"
let dateFormat1 = DateFormatter() dateFormat1.dateFormat = "EEEE" let stringDay = dateFormat1.string(from: Date()) let dateFormat2 = DateFormatter() dateFormat2.dateFormat = "MMMM" let stringMonth = dateFormat2.string(from: Date()) let dateFormat3 = DateFormatter() dateFormat3.dateFormat = "dd" let numDay = dateFormat3.string(from: Date()) let stringDate = String(format: "%@\n%@ %@", stringDay.uppercased(), stringMonth.uppercased(), numDay)
let dateFormat = DateFormatter() dateFormat.dateFormat = "EEEE\nMMMM dd" let stringDate = dateFormat.string(from: Date()).uppercased()
func dataFormat(dataJ: Double) -> String { let dateFormatter = DateFormatter() dateFormatter.dateStyle = .long dateFormatter.timeStyle = .none let date = Date(timeIntervalSince1970: dataJ) return (dataJ != nil) ? "Today, \(dateFormatter.string(from: date))" : "Date Invalid" }
func formatDate(date: String) -> String { let dateFormatterGet = DateFormatter() dateFormatterGet.dateFormat = "yyyy-MM-dd let dateFormatter = DateFormatter() dateFormatter.dateStyle = .medium dateFormatter.timeStyle = .none let dateObj: Date? = dateFormatterGet.date(from: date) return dateFormatter.string(from: dateObj!) }
func setupLayer(){ view.layer.cornerRadius = 2 view.layer.shadowColor = Colors.Shadow.CGColor view.layer.shadowOffset = CGSize(width: 0, height: 1) view.layer.shadowOpacity = 0.9 view.layer.shadowRadius = 5 }
extension CALayer { func applySketchShadow( color: UIColor = .black, alpha: Float = 0.5, x: CGFloat = 0, y: CGFloat = 2, blur: CGFloat = 4, spread: CGFloat = 0) { shadowColor = color.cgColor shadowOpacity = alpha shadowOffset = CGSize(width: x, height: y) shadowRadius = blur / 2.0 if spread == 0 { shadowPath = nil } else { let dx = -spread let rect = bounds.insetBy(dx: dx, dy: dx) shadowPath = UIBezierPath(rect: rect).cgPath } } }
myView.layer.applySketchShadow( color: .black, alpha: 0.5, x: 0, y: 0, blur: 4, spread: 0)
let radius: CGFloat = demoView.frame.width / 2.0 let shadowPath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 2.1 * radius, height: demoView.frame.height)) demoView.layer.cornerRadius = 2 demoView.layer.shadowColor = UIColor.blackColor().CGColor demoView.layer.shadowOffset = CGSize(width: 0.5, height: 0.4) demoView.layer.shadowOpacity = 0.5 demoView.layer.shadowRadius = 5.0 demoView.layer.masksToBounds = false demoView.layer.shadowPath = shadowPath.CGPath
let radius: CGFloat = demoView.frame.width / 2.0 let shadowPath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 2.1 * radius, height: demoView.frame.height)) demoView.layer.cornerRadius = 2 demoView.layer.shadowColor = UIColor.black.cgColor demoView.layer.shadowOffset = CGSize(width: 0.5, height: 0.4) demoView.layer.shadowOpacity = 0.5 demoView.layer.shadowRadius = 5.0 demoView.layer.masksToBounds = false demoView.layer.shadowPath = shadowPath.cgPath
demoView.layer.cornerRadius = 2 demoView.layer.shadowColor = UIColor.blackColor().CGColor demoView.layer.shadowOffset = CGSizeMake(0.5, 4.0); demoView.layer.shadowOpacity = 0.5 demoView.layer.shadowRadius = 5.0
yourView.layer.shadowOpacity = 0.2 yourView.layer.shadowColor = UIColor.black.cgColor yourView.layer.shadowRadius = 2 yourView.layer.shadowOffset = CGSize(width: 0, height: 2) yourView.layer.masksToBounds = false
let shadowPath = UIBezierPath(rect: CGRect(x: -1, y: -2, width: target.frame.width + 2, height: target.frame.height + 2)) target.layer.shadowColor = UIColor(hexString: shadowColor).cgColor target.layer.shadowOffset = CGSize(width: CGFloat(shadowOffsetX), height: CGFloat(shadowOffsetY)) target.layer.masksToBounds = false target.layer.shadowOpacity = Float(shadowOpacity) target.layer.shadowPath = shadowPath.cgPath
var a = [1,5,7,9,22] a.count a[a.count - 1] a[a.endIndex - 1]
extension Array { var last: T { return self[self.endIndex - 1] } }
var array = [1, 2, 3] let removed = array.removeLast()
extension Array { var last: Element { return self[self.endIndex - 1] } }
var booleanValue : Bool? = false if let booleanValue = booleanValue, booleanValue { print("bound booleanValue: }
var booleanValue : Bool? = false if let booleanValue = booleanValue where booleanValue { print("bound booleanValue: }
var booleanValue : Bool? = false if booleanValue ?? false { print("optional booleanValue: }
var booleanValue : Bool? = false if !(booleanValue ?? false) { print("optional booleanValue: }
var booleanValue : Bool? = false if booleanValue != nil && booleanValue! { print("optional booleanValue: }
public func < <T: Comparable> (left: T?, right: T) -> Bool { if let left = left { return left < right } return false }
var timeAtPress = NSDate() @IBAction func pressed(sender: AnyObject) { println("pressed") timeAtPress = NSDate() } @IBAction func released(sender: AnyObject) { println("released") var elapsedTime = NSDate.timeIntervalSinceDate(timeAtPress) duration = ??? }
let elapsed = Date().timeIntervalSince(timeAtPress)
let startDate = NSDate() let endDate = NSDate() let calendar = NSCalendar.currentCalendar() let dateComponents = calendar.components(NSCalendarUnit.CalendarUnitSecond, fromDate: startDate, toDate: endDate, options: nil) let seconds = dateComponents.second println("Seconds: \(seconds)")
let start = Date() let enddt = Date(timeIntervalSince1970: 100) let calendar = Calendar.current let unitFlags = Set<Calendar.Component>([ .second]) let datecomponenets = calendar.dateComponents(unitFlags, from: start, to: enddt) let seconds = datecomponenets.second print("Seconds: \(seconds)")
let calendar = NSCalendar.current var compos:Set<Calendar.Component> = Set<Calendar.Component>() compos.insert(.second) compos.insert(.minute) let difference = calendar.dateComponents(compos, from: fromDate, to: toDate) print("diff in minute=\(difference.minute!)") print("diff in seconds=\(difference.second!)")
func secondsIn(_ str: String)->Int{ var strArr = str.characters.split{$0 == ":"}.map(String.init) var sec = Int(strArr[0])! * 3600 var sec1 = Int(strArr[1])! * 36 print("sec") print(sec+sec1) return sec+sec1 }
var sec1 = secondsIn(shuttleTime) var sec2 = secondsIn(dateToString(Date())) print(sec1-sec2)
import Swift extension Double { func celsiusToFahrenheit() -> Double { return self * 9 / 5 + 32 } func fahrenheitToCelsius() -> Double { return (self - 32) * 5 / 9 } }
let boilingPointCelsius = 100.0 let boilingPointFarenheit = boilingPointCelsius.celsiusToFahrenheit() print(boilingPointFarenheit)
import Swift extension String { func replace(target: String, withString: String) -> String { return self.replacingOccurrences(of: target, with: withString) } }
let newString = "the old bike".replace(target: "old", withString: "new") print(newString)
import UIKit extension UIColor { class var customGreen: UIColor { let darkGreen = 0x008110 return UIColor.rgb(fromHex: darkGreen) } class func rgb(fromHex: Int) -> UIColor { let red = CGFloat((fromHex & 0xFF0000) >> 16) / 0xFF let green = CGFloat((fromHex & 0x00FF00) >> 8) / 0xFF let blue = CGFloat(fromHex & 0x0000FF) / 0xFF let alpha = CGFloat(1.0) return UIColor(red: red, green: green, blue: blue, alpha: alpha) } }
extension UITextField { func useUnderline() { let border = CALayer() let borderWidth = CGFloat(1.0) border.borderColor = UIColor.lightGray.cgColor border.frame = CGRect(origin: CGPoint(x: 0,y :self.frame.size.height - borderWidth), size: CGSize(width: self.frame.size.width, height: self.frame.size.height)) border.borderWidth = borderWidth self.layer.addSublayer(border) self.layer.masksToBounds = true } }
extension UIColor{ class func RGB(_ red:CGFloat , andGreenColor green:CGFloat, andBlueColor blue:CGFloat, withAlpha alpha:CGFloat) -> UIColor { let color = UIColor(red: red/255.0, green: green/255.0, blue: blue/255.0, alpha: alpha) return color } } convenience init(rgbString :String, alpha:CGFloat = 1.0){ let arrColor = rgbString.components(separatedBy: ",") let red:CGFloat = CGFloat(NumberFormatter().number(from: arrColor[0])!) let green:CGFloat = CGFloat(NumberFormatter().number(from: arrColor[1])!) let blue:CGFloat = CGFloat(NumberFormatter().number(from: arrColor[2])!) self.init(red: red/255.0, green: green/255.0, blue: blue/255.0, alpha: alpha) } convenience init(rgbHexaValue: Int, alpha: CGFloat = 1.0) { self.init(red: CGFloat((rgbHexaValue >> 16) & 0xFF), green: CGFloat((rgbHexaValue >> 8) & 0xFF), blue: CGFloat(rgbHexaValue & 0xFF), alpha: alpha) } }
extension UITextField{ func cornerRadius(){ self.layoutIfNeeded() self.layer.cornerRadius = self.frame.height / 2 self.clipsToBounds = true } func borderColor(){ self.layer.borderColor = TEXTFIELD_BORDER_COLOR.cgColor self.layer.borderWidth = 1.0 } func borderWidth(size:CGFloat){ self.layer.borderWidth = size } func blank() -> Bool{ let strTrimmed = self.text!.trim() if(strTrimmed.characters.count == 0) { return true } return false } func setLeftPadding(paddingValue:CGFloat) { let paddingView = UIView(frame: CGRect(x: 0, y: 0, width: paddingValue, height: self.frame.size.height)) self.leftViewMode = .always self.leftView = paddingView } func setRightPadding(paddingValue:CGFloat){ let paddingView = UIView(frame: CGRect(x: (self.frame.size.width - paddingValue), y: 0, width: paddingValue, height: self.frame.size.height)) self.rightViewMode = .always self.rightView = paddingView } }
extension UIFont{ func scaled(scaleFactor: CGFloat) -> UIFont { let newDescriptor = fontDescriptor.withSize(fontDescriptor.pointSize * scaleFactor) return UIFont(descriptor: newDescriptor, size: 0) } }
public enum ImageFormat { case PNG case JPEG(CGFloat) } extension UIImage { func toBase64() -> String { var imageData: NSData switch format { case .PNG: imageData = UIImagePNGRepresentation(self)! as NSData case .JPEG(let compression): imageData = UIImageJPEGRepresentation(self, compression)! as NSData } return imageData.base64EncodedString(options: .lineLength64Characters) } class func base64ToImage(toImage strEncodeData: String) -> UIImage { let dataDecoded = NSData(base64Encoded: strEncodeData, options: NSData.Base64DecodingOptions.ignoreUnknownCharacters)! let image = UIImage(data: dataDecoded as Data) return image! } func storedFileIntoLocal(strImageName:String) -> String{ var strPath = "" let documentDirectory1 = NSString.init(string: String.documentDirectory()) let imageName:String = strImageName + ".png" let imagePath = documentDirectory1.appendingPathComponent(imageName) strPath = imagePath let fileManager = FileManager.default let isExist = fileManager.fileExists(atPath: String.init(imagePath)) if(isExist == true) { do { try fileManager.removeItem(atPath: imagePath as String) } catch { print(error) } } let imageData:Data = UIImageJPEGRepresentation(self, 0.5)! do { try imageData.write(to: URL(fileURLWithPath: imagePath as String), options: .atomic) } catch { print(error) strPath = "Failed to cache image data to disk" return strPath } return strPath } func resizeImage(targetSize: CGSize) -> UIImage { let size = self.size let widthRatio = targetSize.width / self.size.width let heightRatio = targetSize.height / self.size.height var newSize: CGSize if(widthRatio > heightRatio) { newSize = CGSize(width: size.width * heightRatio, height: size.height * heightRatio) } else { newSize = CGSize(width: size.width * widthRatio, height: size.height * widthRatio) } let rect = CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height) UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0) self.draw(in: rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } }
let YYYY_MM_DD_HH_MM_SS_zzzz = "yyyy-MM-dd HH:mm:ss +zzzz" let YYYY_MM_DD_HH_MM_SS = "yyyy-MM-dd HH:mm:ss" let DD_MM_YYYY = "dd-MM-yyyy" let MM_DD_YYYY = "MM-dd-yyyy" let YYYY_DD_MM = "yyyy-dd-MM" let YYYY_MM_DD_T_HH_MM_SS = "yyyy-MM-dd extension Date{ static func convertStringToDate(strDate:String, dateFormate strFormate:String) -> Date{ let dateFormate = DateFormatter() dateFormate.dateFormat = strFormate dateFormate.timeZone = TimeZone.init(abbreviation: "UTC") let dateResult:Date = dateFormate.date(from: strDate)! return dateResult } static func convertDateUTCToLocal(strDate:String, oldFormate strOldFormate:String, newFormate strNewFormate:String) -> String{ let dateFormatterUTC:DateFormatter = DateFormatter() dateFormatterUTC.timeZone = NSTimeZone(abbreviation: "UTC") as TimeZone! dateFormatterUTC.dateFormat = strOldFormate if let oldDate:Date = dateFormatterUTC.date(from: strDate) as Date? { dateFormatterUTC.timeZone = NSTimeZone.local dateFormatterUTC.dateFormat = strNewFormate if let strNewDate:String = dateFormatterUTC.string(from: oldDate as Date) as String? { return strNewDate } return strDate } return strDate } static func convertDateToLocal(strDate:String, oldFormate strOldFormate:String, newFormate strNewFormate:String) -> String{ let dateFormatterUTC:DateFormatter = DateFormatter() dateFormatterUTC.dateFormat = strOldFormate if let oldDate:Date = dateFormatterUTC.date(from: strDate) as Date? { dateFormatterUTC.timeZone = NSTimeZone.local dateFormatterUTC.dateFormat = strNewFormate if let strNewDate = dateFormatterUTC.string(from: oldDate as Date) as String? { return strNewDate } return strDate } return strDate } func convertDateToString(strDateFormate:String) -> String{ let dateFormatter = DateFormatter() dateFormatter.dateFormat = strDateFormate let strDate = dateFormatter.string(from: self) return strDate } static func convertLocalToUTC(strDate:String, oldFormate strOldFormate:String, newFormate strNewFormate:String) -> String{ let dateFormatterUTC:DateFormatter = DateFormatter() dateFormatterUTC.timeZone = NSTimeZone.local as TimeZone! dateFormatterUTC.dateFormat = strOldFormate if let oldDate:Date = dateFormatterUTC.date(from: strDate) as Date? { dateFormatterUTC.timeZone = NSTimeZone.init(abbreviation: "UTC")! as TimeZone dateFormatterUTC.dateFormat = strNewFormate if let strNewDate:String = dateFormatterUTC.string(from: oldDate as Date) as String? { return strNewDate } return strDate } return strDate } static func compare(date:Date, compareDate:Date) -> String{ var strDateMessage:String = "" let result:ComparisonResult = date.compare(compareDate) switch result { case .orderedAscending: strDateMessage = "Future Date" break case .orderedDescending: strDateMessage = "Past Date" break case .orderedSame: strDateMessage = "Same Date" break default: strDateMessage = "Error Date" break } return strDateMessage } }
let color1 = UIColor.RGB(100.0, andGreenColor: 200.0, andBlueColor: 300.0, withAlpha: 1.0) let color2 = UIColor.init(rgbHexaValue: 800000, alpha: 1.0) let color3 = UIColor.init(rgbString: ("100.0,200.0,300.0", alpha: 1.0) self.txtOutlet.cornerRadius() self.txtOutlet.borderColor() self.txtOutlet.setLeftPadding(paddingValue: 20.0) self.txtOutlet.setRightPadding(paddingValue: 20.0) let yourScaledFont = self.dependentView.font.scaled(scaleFactor: n as! CGFloat) let base64String = (image?.toBase64(format: ImageFormat.PNG))! let resultImage = UIImage.base64ToImage(toImage: base64String) let path = yourImage.storedFileIntoLocal(strImageName: "imagename")
import UIKit extension UIColor{ class func getCustomBlueColor() -> UIColor { return UIColor(red:0.043, green:0.576 ,blue:0.588 , alpha:1.00) } func getNameofColour() ->String { return "myOrange" } }
NSLog("\(UIColor.getCustomBlueColor())") let color=UIColor(red:0.043, green:0.576 ,blue:0.588 , alpha:1.00); NSLog(color.getNameofColour())
extension UITextField { func underlined(_ size:Double){ let border = CALayer() let width = CGFloat(size) border.borderColor = UIColor.red.cgColor border.frame = CGRect(x: 0, y: self.frame.size.height - width, width: self.frame.size.width, height: self.frame.size.height) border.borderWidth = width self.layer.addSublayer(border) self.layer.masksToBounds = true } } }
extension UIActivityIndicatorView { convenience init(activityIndicatorStyle: UIActivityIndicatorViewStyle, color: UIColor, placeInTheCenterOf parentView: UIView) { self.init(activityIndicatorStyle: activityIndicatorStyle) center = parentView.center self.color = color parentView.addSubview(self) } }
let activityIndicator = UIActivityIndicatorView(activityIndicatorStyle: .whiteLarge, color: .gray, placeInTheCenterOf: view)
extension UIColor { func withTint(tint: CGFloat)->UIColor { var tint = max(tint, 0) tint = min(tint, 1) var r : CGFloat = 0 var g : CGFloat = 0 var b : CGFloat = 0 var a : CGFloat = 0 self.getRed(&r, green: &g, blue: &b, alpha: &a) r = r+(1-r)*(1-tint) g = g+(1-g)*(1-tint) b = b+(1-b)*(1-tint) a = 1 return UIColor.init(red: r, green: g, blue: b, alpha: a) } }
enum StringEnum: String { case one = "one" case two = "two" case three = "three" } let anEnum = StringEnum(rawValue: "one")! print("anEnum = \"\(anEnum.rawValue)\"")
enum StringEnum: String { case one case two case three } let anEnum = StringEnum.one print("anEnum = \"\(anEnum)\"")
enum StringEnum: String { case one = "value one" case two = "value two" case three = "value three" }
enum Foo: String { case a, b, c, d } let a = Foo(rawValue: "a") assert(a == Foo.a) let üí© = Foo(rawValue: "üí©") assert(üí© == nil)
enum MenuItem: Int { case One = 0, Two, Three, Four, Five static func enumFromString(string:String) -> MenuItem? { var i = 0 while let item = MenuItem(rawValue: i) { if String(item) == string { return item } i += 1 } return nil } }
let string = "Two" if let item = MenuItem.enumFromString(string) { }
enum MyCode : String, CaseIterable { case one = "uno" case two = "dos" case three = "tres" static func withLabel(_ label: String) -> MyCode? { return self.allCases.first{ "\($0)" == label } } }
print(MyCode.withLabel("one")) print(MyCode(rawValue: "uno"))
extension StringEnum: StringLiteralConvertible { init(stringLiteral value: String){ self.init(rawValue: value)! } init(extendedGraphemeClusterLiteral value: String) { self.init(stringLiteral: value) } init(unicodeScalarLiteral value: String) { self.init(stringLiteral: value) } }
public enum PaymentPlatform: String, CaseIterable { case visa = "Visa card" case masterCard = "Master card" case cod = "Cod" var nameEnum: String { return Mirror(reflecting: self).children.first?.label ?? String(describing: self) } func byName(name: String) -> PaymentPlatform { return PaymentPlatform.allCases.first(where: {$0.nameEnum.elementsEqual(name)}) ?? .cod } }
<Error>: Error Domain=LaunchServicesError Code=0 "(null)" UserInfo={Error=ExecutableTwiddleFailed...
let price = 123.436 as NSNumber let formatter = NumberFormatter() formatter.numberStyle = .currency formatter.string(from: price) formatter.locale = Locale(identifier: "es_CL") formatter.string(from: price) formatter.locale = Locale(identifier: "es_ES") formatter.string(from: price)
let price = 123.436 let formatter = NSNumberFormatter() formatter.numberStyle = .CurrencyStyle formatter.stringFromNumber(price) formatter.locale = NSLocale(localeIdentifier: "es_CL") formatter.stringFromNumber(price) formatter.locale = NSLocale(localeIdentifier: "es_ES") formatter.stringFromNumber(price)
// extension Float { var asLocaleCurrency:String { var formatter = NSNumberFormatter() formatter.numberStyle = .CurrencyStyle formatter.locale = NSLocale.currentLocale() return formatter.stringFromNumber(self)! } }
let amount = 100.07 let amountString = amount.asLocaleCurrency print(amount.asLocaleCurrency())
extension Float { var asLocaleCurrency:String { var formatter = NumberFormatter() formatter.numberStyle = .currency formatter.locale = Locale.current return formatter.string(from: self)! } }
func cleanDollars(_ value: String?) -> String { guard value != nil else { return "$0.00" } let doubleValue = Double(value!) ?? 0.0 let formatter = NumberFormatter() formatter.currencyCode = "USD" formatter.currencySymbol = "$" formatter.minimumFractionDigits = (value!.contains(".00")) ? 0 : 2 formatter.maximumFractionDigits = 2 formatter.numberStyle = .currencyAccounting return formatter.string(from: NSNumber(value: doubleValue)) ?? "$\(doubleValue)" }
extension Locale { static let br = Locale(identifier: "pt_BR") static let us = Locale(identifier: "en_US") static let uk = Locale(identifier: "en_UK") }
extension NumberFormatter { convenience init(style: Style, locale: Locale = .current) { self.init() self.locale = locale numberStyle = style } }
extension Formatter { static let currency = NumberFormatter(style: .currency) static let currencyUS = NumberFormatter(style: .currency, locale: .us) static let currencyBR = NumberFormatter(style: .currency, locale: .br) }
extension Numeric { var currency: String { return Formatter.currency.string(for: self) ?? "" } var currencyUS: String { return Formatter.currencyUS.string(for: self) ?? "" } var currencyBR: String { return Formatter.currencyBR.string(for: self) ?? "" } }
let price = 1.99 print(Formatter.currency.locale) print(price.currency) Formatter.currency.locale = .br print(price.currency) Formatter.currency.locale = .uk print(price.currency) print(price.currencyBR) print(price.currencyUS)
import Foundation extension String { var toLocale: Locale { return Locale(identifier: self) } } extension Numeric { func currency(numberStyle: NumberFormatter.Style = NumberFormatter.Style.currency, locale: String, groupingSeparator: String? = nil, decimalSeparator: String? = nil) -> String? { return currency(numberStyle: numberStyle, locale: locale.toLocale, groupingSeparator: groupingSeparator, decimalSeparator: decimalSeparator) } func currency(numberStyle: NumberFormatter.Style = NumberFormatter.Style.currency, locale: Locale = Locale.current, groupingSeparator: String? = nil, decimalSeparator: String? = nil) -> String? { if let num = self as? NSNumber { let formater = NumberFormatter() formater.locale = locale formater.numberStyle = numberStyle var formatedSting = formater.string(from: num) if let separator = groupingSeparator, let localeValue = locale.groupingSeparator { formatedSting = formatedSting?.replacingOccurrences(of: localeValue, with: separator) } if let separator = decimalSeparator, let localeValue = locale.decimalSeparator { formatedSting = formatedSting?.replacingOccurrences(of: localeValue, with: separator) } return formatedSting } return nil } }
let price = 12423.42 print(price.currency() ?? "nil") print(price.currency(numberStyle: .currencyISOCode) ?? "nil") print(price.currency(locale: "es_ES") ?? "nil") print(price.currency(locale: "es_ES", groupingSeparator: "_", decimalSeparator: ".") ?? "nil")
import Foundation extension String { var toLocale: Locale { return Locale(identifier: self) } } class NumFormatter { static var shared = NumFormatter() public private(set) var formater = NumberFormatter() public private(set) var groupingSeparator: String? = nil public private(set) var decimalSeparator: String? = nil public var locale: Locale { return formater.locale } class func locale(string: String) -> NumFormatter.Type { NumFormatter.shared.formater.locale = string.toLocale return NumFormatter.self } class func number(style: NumberFormatter.Style = NumberFormatter.Style.currency) -> NumFormatter.Type { NumFormatter.shared.formater.numberStyle = style return NumFormatter.self } class func number(groupingSeparator: String?) -> NumFormatter.Type { NumFormatter.shared.groupingSeparator = groupingSeparator return NumFormatter.self } class func number(decimalSeparator: String?) -> NumFormatter.Type { NumFormatter.shared.decimalSeparator = decimalSeparator return NumFormatter.self } } extension Numeric { func currency() -> String? { if let num = self as? NSNumber { let formater = NumFormatter.shared.formater var formatedSting = formater.string(from: num) if let separator = NumFormatter.shared.groupingSeparator, let localeValue = formater.locale.groupingSeparator { formatedSting = formatedSting?.replacingOccurrences(of: localeValue, with: separator) } if let separator = NumFormatter.shared.decimalSeparator, let localeValue = formater.locale.decimalSeparator { formatedSting = formatedSting?.replacingOccurrences(of: localeValue, with: separator) } return formatedSting } return nil } }
let price = 12423.42 print(price.currency() ?? "nil") NumFormatter.number(style: .currencyISOCode) print(price.currency() ?? "nil") NumFormatter.locale(string: "es_ES") print(price.currency() ?? "nil") NumFormatter.number(groupingSeparator: "_").number(decimalSeparator: ".") print(price.currency() ?? "nil")
formatter.locale = Locale.init(identifier: "id-ID")
let formatter = NumberFormatter() formatter.numberStyle = .currency if let formattedTipAmount = formatter.string(from: Int(newString)! as NSNumber) { yourtextfield.text = formattedTipAmount }
func addSeparateMarkForNumber(int: Int) -> String { var string = "" let formatter = NumberFormatter() formatter.locale = Locale.current formatter.numberStyle = .decimal if let formattedTipAmount = formatter.string(from: int as NSNumber) { string = formattedTipAmount } return string }
let giaTri = value as! Int myGuessTotalCorrect = addSeparateMarkForNumber(int: giaTri)
extension Float { var convertAsLocaleCurrency :String { var formatter = NumberFormatter() formatter.numberStyle = .currency formatter.locale = Locale.current return formatter.string(from: self as NSNumber)! } }
var myString:NSString = "I AM KIRIT MODI" var myMutableString = NSMutableAttributedString()
override func viewDidLoad() { myMutableString = NSMutableAttributedString(string: myString, attributes: [NSFontAttributeName:UIFont(name: "Georgia", size: 18.0)!]) myMutableString.addAttribute(NSForegroundColorAttributeName, value: UIColor.redColor(), range: NSRange(location:2,length:4)) labName.attributedText = myMutableString super.viewDidLoad() }
myMutableString.addAttribute(NSForegroundColorAttributeName, value: UIColor.greenColor(), range: NSRange(location:10,length:5))
let attrs1 = [NSFontAttributeName : UIFont.boldSystemFontOfSize(18), NSForegroundColorAttributeName : UIColor.greenColor()] let attrs2 = [NSFontAttributeName : UIFont.boldSystemFontOfSize(18), NSForegroundColorAttributeName : UIColor.whiteColor()] let attributedString1 = NSMutableAttributedString(string:"Drive", attributes:attrs1) let attributedString2 = NSMutableAttributedString(string:"safe", attributes:attrs2) attributedString1.appendAttributedString(attributedString2) self.lblText.attributedText = attributedString1
let attrs1 = [NSAttributedStringKey.font : UIFont.boldSystemFont(ofSize: 18), NSAttributedStringKey.foregroundColor : UIColor.green] let attrs2 = [NSAttributedStringKey.font : UIFont.boldSystemFont(ofSize: 18), NSAttributedStringKey.foregroundColor : UIColor.white] let attributedString1 = NSMutableAttributedString(string:"Drive", attributes:attrs1) let attributedString2 = NSMutableAttributedString(string:"safe", attributes:attrs2) attributedString1.append(attributedString2) self.lblText.attributedText = attributedString1
let htmlString = "<font color=\"red\">This is </font> <font color=\"blue\"> some text!</font>" let encodedData = htmlString.data(using: String.Encoding.utf8)! let attributedOptions = [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType] do { let attributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) label.attributedText = attributedString } catch _ { print("Cannot create attributed String") }
let htmlString = "<font color=\"red\">This is </font> <font color=\"blue\"> some text!</font>" let encodedData = htmlString.dataUsingEncoding(NSUTF8StringEncoding)! let attributedOptions = [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType] do { let attributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) label.attributedText = attributedString } catch _ { print("Cannot create attributed String") }
extension NSMutableAttributedString { func setColorForText(textForAttribute: String, withColor color: UIColor) { let range: NSRange = self.mutableString.range(of: textForAttribute, options: .caseInsensitive) self.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range) self.addAttribute(NSAttributedStringKey.foregroundColor, value: color, range: range) } }
let label = UILabel() label.frame = CGRect(x: 60, y: 100, width: 260, height: 50) let stringValue = "stackoverflow" let attributedString: NSMutableAttributedString = NSMutableAttributedString(string: stringValue) attributedString.setColorForText(textForAttribute: "stack", withColor: UIColor.black) attributedString.setColorForText(textForAttribute: "over", withColor: UIColor.orange) attributedString.setColorForText(textForAttribute: "flow", withColor: UIColor.red) label.font = UIFont.boldSystemFont(ofSize: 40) label.attributedText = attributedString self.view.addSubview(label)
import UIKit import Foundation extension String { var attributedStringFromHtml: NSAttributedString? { do { return try NSAttributedString(data: self.dataUsingEncoding(NSUTF8StringEncoding)!, options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType], documentAttributes: nil) } catch _ { print("Cannot create attributed String") } return nil } }
let htmlString = "<font color=\"red\">This is </font> <font color=\"blue\"> some text!</font>" label.attributedText = htmlString.attributedStringFromHtml
label.attributedText = "<font color=\"red\">This is </font> <font color=\"blue\"> some text!</font>".attributedStringFromHtml
myMutableString.addAttribute(NSForegroundColorAttributeName, value: UIColor.redColor(), range: NSRange(location:2,length:4))
let myMutableString = NSMutableAttributedString( string: "your desired text", attributes: [:]) myMutableString.addAttribute( NSForegroundColorAttributeName, value: UIColor.blue, range: NSRange( location:6, length:7))
let yourAttributes = [NSForegroundColorAttributeName: UIColor.black, NSFontAttributeName: UIFont.systemFontOfSize(15)] let yourOtherAttributes = [NSForegroundColorAttributeName: UIColor.red, NSFontAttributeName: UIFont.systemFontOfSize(25)] let partOne = NSMutableAttributedString(string: "This is an example ", attributes: yourAttributes) let partTwo = NSMutableAttributedString(string: "for the combination of Attributed String!", attributes: yourOtherAttributes) let combination = NSMutableAttributedString() combination.appendAttributedString(partOne) combination.appendAttributedString(partTwo)
import UIKit import Foundation extension UILabel { func setDifferentColor(string: String, location: Int, length: Int){ let attText = NSMutableAttributedString(string: string) attText.addAttribute(NSForegroundColorAttributeName, value: UIColor.blueApp, range: NSRange(location:5,length:4)) attributedText = attText } }
override func viewDidLoad() { super.viewDidLoad() titleLabel.setDifferentColor(string: titleLabel.text!, location: 5, length: 4) }
let encodedData = htmlString.data(using: String.Encoding.utf8)! let attributedOptions = [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType] do { let attributedString = try NSAttributedString(data: encodedData, options: attributedOptions, documentAttributes: nil) label.attributedText = attributedString } catch _ { print("Cannot create attributed String") }
public class Helper { static func GetAttributedText(inputText:String, location:Int,length:Int) -> NSMutableAttributedString { let attributedText = NSMutableAttributedString(string: inputText, attributes: [NSFontAttributeName:UIFont(name: "Merriweather", size: 15.0)!]) attributedText.addAttribute(NSForegroundColorAttributeName, value: UIColor(red: 0.401107, green: 0.352791, blue: 0.503067, alpha: 1.0) , range: NSRange(location:location,length:length)) return attributedText } }
self.dateLabel?.attributedText = Helper.GetAttributedText(inputText: "Date : " + (self.myModel?.eventDate)!, location:0, length: 6)
func MultiStringColor(first:String,second:String) -> NSAttributedString { let MyString1 = [NSFontAttributeName : FontSet.MonsRegular(size: 14), NSForegroundColorAttributeName : FoodConstant.PUREBLACK] let MyString2 = [NSFontAttributeName : FontSet.MonsRegular(size: 14), NSForegroundColorAttributeName : FoodConstant.GREENCOLOR] let attributedString1 = NSMutableAttributedString(string:first, attributes:MyString1) let attributedString2 = NSMutableAttributedString(string:second, attributes:MyString2) MyString1.append(MyString2) return MyString1 }
func highlightWords(phrases: [String], withColor: UIColor?, withFont: UIFont?) { let attributedString: NSMutableAttributedString = NSMutableAttributedString(string: self.text!) for phrase in phrases { if withColor != nil { attributedString.setColorForText(textForAttribute: phrase, withColor: withColor!) } if withFont != nil { attributedString.setFontForText(textForAttribute: phrase, withFont: withFont!) } } self.attributedText = attributedString }
yourLabel.highlightWords(phrases: ["hello"], withColor: UIColor.blue, withFont: nil) yourLabel.highlightWords(phrases: ["how are you"], withColor: UIColor.green, withFont: nil)
@IBOutlet weak var bgImage: UIImageView! var image : UIImage = UIImage(named:"afternoon")! bgImage = UIImageView(image: image) bgImage.frame = CGRect(x: 0, y: 0, width: 100, height: 200) view.addSubview(bgImage)
@IBOutlet weak var bgImage: UIImageView! @IBOutlet weak var dateLabel: UILabel! @IBOutlet weak var timeLabel: UILabel! override func viewDidLoad() { super.viewDidLoad() updateTime() var timer = NSTimer() let aSelector : Selector = "updateTime" timer = NSTimer.scheduledTimerWithTimeInterval(0.01, target: self, selector: aSelector, userInfo: nil, repeats: true) var image : UIImage = UIImage(named:"afternoon")! bgImage = UIImageView(image: image) }
class ViewController: UIViewController { var bgImage: UIImageView? override func viewDidLoad() { super.viewDidLoad() var image: UIImage = UIImage(named: "afternoon")! bgImage = UIImageView(image: image) bgImage!.frame = CGRectMake(0,0,100,200) self.view.addSubview(bgImage!) } }
var imageViewObject :UIImageView imageViewObject = UIImageView(frame:CGRectMake(0, 0, 600, 600)) imageViewObject.image = UIImage(named:"afternoon") self.view.addSubview(imageViewObject) self.view.sendSubviewToBack(imageViewObject)
var image : UIImage = UIImage(named:"afternoon")! bgImage = UIImageView(image: image) bgImage.frame = CGRect(x: 0, y: 0, width: 100, height: 200) view.addSubview(bgImage)
let leftImageView = UIImageView() leftImageView.image = UIImage(named: "email") let leftView = UIView() leftView.addSubview(leftImageView) leftView.frame = CGRect(x: 0, y: 0, width: 40, height: 40) leftImageView.frame = CGRect(x: 10, y: 10, width: 20, height: 20) userNameTextField.leftViewMode = .always userNameTextField.leftView = leftView
class YourClass: UIViewController{ @IBOutlet weak var tableView: UITableView! let placeholderImage : UIImageView = { let placeholderImage = UIImageView(image: UIImage(named: "nophoto")) placeholderImage.contentMode = .scaleAspectFill return placeholderImage }() var someVariable: String! var someOtherVariable: Int! func someMethod(){ } }
alertController.addTextFieldWithConfigurationHandler { (textField) -> Void in }
let alertController: UIAlertController = UIAlertController(title: "Find image", message: "Search for image", preferredStyle: .Alert) let cancelAction: UIAlertAction = UIAlertAction(title: "Cancel", style: .Cancel) { action -> Void in } alertController.addAction(cancelAction) let nextAction: UIAlertAction = UIAlertAction(title: "Search", style: .Default) { action -> Void in let text = (alertController.textFields?.first as! UITextField).text println("You entered \(text)") } alertController.addAction(nextAction) alertController.addTextFieldWithConfigurationHandler { (textField) -> Void in textField.textColor = UIColor.greenColor() } presentViewController(alertController, animated: true, completion: nil)
alert.addTextField(configurationHandler: { (textField) in textField.placeholder = "Enter First Name" })
@IBAction func addButtonClicked(sender : AnyObject){ let alertController = UIAlertController(title: "Add New Name", message: "", preferredStyle: UIAlertControllerStyle.Alert) alertController.addTextFieldWithConfigurationHandler { (textField : UITextField!) -> Void in textField.placeholder = "Enter Second Name" } let saveAction = UIAlertAction(title: "Save", style: UIAlertActionStyle.Default, handler: { alert -> Void in let firstTextField = alertController.textFields![0] as UITextField let secondTextField = alertController.textFields![1] as UITextField }) let cancelAction = UIAlertAction(title: "Cancel", style: UIAlertActionStyle.Default, handler: { (action : UIAlertAction!) -> Void in }) alertController.addTextFieldWithConfigurationHandler { (textField : UITextField!) -> Void in textField.placeholder = "Enter First Name" } alertController.addAction(saveAction) alertController.addAction(cancelAction) self.presentViewController(alertController, animated: true, completion: nil) }
@IBAction func addButtonClicked(_ sender: UIButton){ let alertController = UIAlertController(title: "Add New Name", message: "", preferredStyle: .alert) alertController.addTextField { (textField : UITextField!) -> Void in textField.placeholder = "Enter Second Name" } let saveAction = UIAlertAction(title: "Save", style: .default, handler: { alert -> Void in let firstTextField = alertController.textFields![0] as UITextField let secondTextField = alertController.textFields![1] as UITextField print("firstName \(firstTextField.text), secondName \(secondTextField.text)") }) let cancelAction = UIAlertAction(title: "Cancel", style: .default, handler: { (action : UIAlertAction!) -> Void in }) alertController.addTextField { (textField : UITextField!) -> Void in textField.placeholder = "Enter First Name" } alertController.addAction(saveAction) alertController.addAction(cancelAction) self.present(alertController, animated: true, completion: nil) }
let alertController = UIAlertController(title: "Title", message: "", preferredStyle: .alert) alertController.addAction(UIAlertAction(title: "Save", style: .default, handler: { alert -> Void in let textField = alertController.textFields![0] as UITextField })) alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil)) alertController.addTextField(configurationHandler: {(textField : UITextField!) -> Void in textField.placeholder = "Search" }) self.present(alertController, animated: true, completion: nil)
alertController.addTextFieldWithConfigurationHandler { (textField) -> Void in searchTextField = textField searchTextField?.delegate = self searchTextField?.placeholder = "Enter your search terms" }
var nameField: UITextField? let alertController = UIAlertController(title: "Add Number", message: nil, preferredStyle: .alert) alertController.addTextField { (textField) in nameField = textField }
let alertController = UIAlertController(title: "Add New Name", message: "", preferredStyle: .alert) alertController.addTextField { (textField : UITextField!) -> Void in textField.placeholder = "Enter Second Name" } let saveAction = UIAlertAction(title: "Save", style: .default, handler: { alert -> Void in let firstTextField = alertController.textFields![0] as UITextField let secondTextField = alertController.textFields![1] as UITextField }) let cancelAction = UIAlertAction(title: "Cancel", style: .default, handler: { (action : UIAlertAction!) -> Void in }) alertController.addTextField { (textField : UITextField!) -> Void in textField.placeholder = "Enter First Name" } alertController.addAction(saveAction) alertController.addAction(cancelAction) self.present(alertController, animated: true, completion: nil)
func addRow (row: Int, bodin: String, flag: Int) { let alertController = UIAlertController(title: bodin, message: "", preferredStyle: .alert) alertController.addAction(UIAlertAction(title: "Save", style: .default, handler: { alert -> Void in _ = alertController.textFields![0] as UITextField })) alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil)) alertController.addTextField(configurationHandler: {(textField : UITextField!) -> Void in switch flag { case 0: textField.keyboardType = UIKeyboardType.phonePad textField.placeholder = "Enter Number" case 1: textField.keyboardType = UIKeyboardType.emailAddress textField.placeholder = "Enter Email" default: break } })
let alert = UIAlertController(title: "Alert", message: "", preferredStyle: .alert) alert.addTextField { (textField) in textField.placeholder = "First Name" } alert.addAction(UIAlertAction(title: "OK", style: .default, handler: { [weak alert] (_) in let textField = alert?.textFields![0] self.label.text = textField?.text })) self.present(alert, animated: true, completion: nil)
@IBAction func withdrawTapped(_ sender: UIButton) { let alertController = UIAlertController(title: "Token withdraw", message: "", preferredStyle: .alert) let withdrawAction = UIAlertAction(title: "Withdraw", style: .default) { (aciton) in let text = alertController.textFields!.first!.text! if !text.isEmpty { self.presentAlert( title: "Succesful", message: "You made request for withdraw \(textField.text) tokens") } } let cancelAction = UIAlertAction(title: "Cancel", style: .cancel) { (action) in } alertController.addTextField { (textField) in textField.placeholder = "999" textField.keyboardType = .decimalPad } alertController.addAction(withdrawAction) alertController.addAction(cancelAction) self.present(alertController, animated: true, completion: nil) }
func generic1<T>(name : String){ } func generic2<T>(name : String){ generic1<T>(name) }
extension UIViewController { func navigate<ControllerType: UIViewController>(_ dump: ControllerType.Type, id: String, before: ((ControllerType) -> Void)?){ let controller = self.storyboard?.instantiateViewController(withIdentifier: id) as! ControllerType before?(controller) self.navigationController?.pushViewController(controller, animated: true) } }
self.navigate(UserDetailsViewController.self, id: "UserDetailsViewController", before: { controller in controller.user = self.notification.sender })
extension UIViewController { class func doSomething<T: UIView>() -> T { return T() } class func doSomethingElse<T: UIView>(value: T) { } class func doLastThing<T: UIView>(value: T.Type) { } }
let result = UIViewController.doSomething() as UIImageView let result: UILabel = UIViewController.doSomething() UIViewController.doSomethingElse(value: UIButton()) UIViewController.doLastThing(value: UITextView.self)
func fetchObjectOrCreate<T: NSManagedObject>(type: T.Type) -> T { if let existing = fetchExisting(type) { return existing } else { return createNew(type) } } func fetchExisting<T: NSManagedObject>(type: T.Type) -> T { let entityName = NSStringFromClass(type) } func createNew<T: NSManagedObject>(type: T.Type) -> T { let entityName = NSStringFromClass(type) }
class Foo<T> { func doStuff(text: String) -> T { return doOtherStuff(text) } func doOtherStuff(text: String) -> T { } } let foo = Foo<Int>() foo.doStuff("text")
func generic1<T>(parameter: T) { println("OK") } func generic2<T>(parameter: T) { generic1(parameter) }
protocol Example { func handle() -> String } extension String: Example { func handle() -> String { return "OK" } } func generic1<T: Example>(parameter: T) { println(parameter.handle()) } func generic2<T: Example>(parameter: T) { generic1(parameter) }
class UploadResult: Parsable{ ... } func upload<T:Parsable>(type: T.Type, image: UIImage, success:@escaping (_ error:ApiError?, _ result:T?)->Void ) {...} UploadApi.upload(type: UploadResult.self, image: imageForUpload.image!) {...}
@IBAction func dialog(sender: AnyObject) { let optionMenu = UIAlertController(title: nil, message: "Choose Option", preferredStyle: .ActionSheet) let deleteAction = UIAlertAction(title: "Delete", style: .Default, handler: { (alert: UIAlertAction!) -> Void in println("Filtre Deleted") }) let cancelAction = UIAlertAction(title: "Cancel", style: .Cancel, handler: { (alert: UIAlertAction!) -> Void in println("Cancelled") }) optionMenu.addAction(deleteAction) optionMenu.addAction(cancelAction) self.presentViewController(optionMenu, animated: true, completion: nil) }
optionMenu.popoverPresentationController?.barButtonItem = self.navigationItem.rightBarButtonItem self.presentViewController(optionMenu, animated: true, completion: nil)
optionMenu.popoverPresentationController?.sourceView = yourView self.presentViewController(optionMenu, animated: true, completion: nil)
let optionMenu = UIAlertController(title: nil, message: "Choose an option", preferredStyle: .actionSheet) let deleteAction = UIAlertAction(title: "Option 1", style: .default, handler: { (alert: UIAlertAction!) -> Void in print("option 1 pressed") }) let saveAction = UIAlertAction(title: "Option 2", style: .default, handler: { (alert: UIAlertAction!) -> Void in print("option 2 pressed") }) // let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: { (alert: UIAlertAction!) -> Void in print("Cancelled") }) optionMenu.addAction(deleteAction) optionMenu.addAction(saveAction) optionMenu.addAction(cancelAction) optionMenu.popoverPresentationController?.barButtonItem = self.navigationItem.rightBarButtonItem self.present(optionMenu, animated: true) { print("option menu presented") }
... sheet.popoverPresentationController?.sourceView = self.view sheet.popoverPresentationController?.permittedArrowDirections = UIPopoverArrowDirection() sheet.popoverPresentationController?.sourceRect = CGRect(x: self.view.bounds.midX, y: self.view.bounds.midY, width: 0, height: 0) self.present(sheet, animated: true, completion: nil)
@IBAction func dialog(sender: AnyObject) { ... optionMenu.popoverPresentationController.sourceView = self.view; optionMenu.popoverPresentationController.sourceRect = CGRectMake(0,0,1.0,1.0); self.presentViewController(optionMenu, animated: true, completion: nil) }
if let popoverController = optionMenu.popoverPresentationController { popoverController.sourceView = self.view popoverController.sourceRect = CGRect(x: self.view.bounds.midX, y: self.view.bounds.midY, width: 0, height: 0) popoverController.permittedArrowDirections = [] } self.present(optionMenu, animated: true, completion: nil)
let searchBar = UISearchBar() ..... navigationItem.titleView = searchBar
if searchBar.heightAnchor.constraint(equalToConstant: 44).isActive = true }
if (@available(iOS 11.0, *)) { [searchBar.heightAnchor constraintEqualToConstant:44].active = YES; }
class SearchBarContainerView: UIView { let searchBar: UISearchBar init(customSearchBar: UISearchBar) { searchBar = customSearchBar super.init(frame: CGRect.zero) addSubview(searchBar) } override convenience init(frame: CGRect) { self.init(customSearchBar: UISearchBar()) self.frame = frame } required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } override func layoutSubviews() { super.layoutSubviews() searchBar.frame = bounds } } class MyViewController: UIViewController { func setupNavigationBar() { let searchBar = UISearchBar() let searchBarContainer = SearchBarContainerView(customSearchBar: searchBar) searchBarContainer.frame = CGRect(x: 0, y: 0, width: view.frame.width, height: 44) navigationItem.titleView = searchBarContainer } }
-(void)viewWillDisappear:(BOOL)animated{ [super viewWillDisappear:animated]; [self.navigationController.view setNeedsLayout]; [self.navigationController.view layoutIfNeeded]; }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) navigationController?.view.setNeedsLayout() navigationController?.view.layoutIfNeeded() }
if (@available(iOS 11.0, *)) { [self.searchBar.heightAnchor constraintLessThanOrEqualToConstant: 44].active = YES; }
UIBarButtonItem *cancelButton; if (@available(iOS 11.0, *)) { self.navBarCustomButton = [UIButton buttonWithType:UIButtonTypeCustom]; [self.navBarCustomButton setTitle:@"Cancel"]; [self.navBarCustomButton addTarget:self action:@selector(cancelButtonTapped) forControlEvents:UIControlEventTouchUpInside]; cancelButton = [[UIBarButtonItem alloc] initWithCustomView:self.navBarCustomButton]; } else { cancelButton = [[UIBarButtonItem alloc] initWithTitle:MagicLocalizedString(@"button.cancel", @"Cancel") style:UIBarButtonItemStylePlain target:self action:@selector(cancelButtonTapped)]; }
if (@available(iOS 11.0, *)) { UIView *buttonsStackView = [navigationController.navigationBar subviewOfClass:[UIStackView class]]; if (buttonsStackView ) { [buttonsStackView.centerYAnchor constraintEqualToAnchor:navigationController.navigationBar.centerYAnchor].active = YES; [self.navBarCustomButton.heightAnchor constraintEqualToAnchor:buttonsStackView.heightAnchor]; } }
- (__kindof UIView *)subviewOfClass:(Class)targetClass { if ([self isKindOfClass:targetClass]) { return self; } for (UIView *subview in self.subviews) { UIView *dfsResult = [subview subviewOfClass:targetClass]; if (dfsResult) { return dfsResult; } } return nil; }
override func viewDidLoad() { super.viewDidLoad() self.extendedLayoutIncludesOpaqueBars = true }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) navigationController?.view.setNeedsLayout() navigationController?.view.layoutIfNeeded() }
- (void)iOS11FixNavigationItemsVerticalAlignment { [self.navigationController.navigationBar layoutIfNeeded]; NSString * currSysVer = [[UIDevice currentDevice] systemVersion]; if ([currSysVer compare:@"11" options:NSNumericSearch] != NSOrderedAscending) { UIView * navigationBarContentView; for (UIView * subview in [self.navigationController.navigationBar subviews]) { if ([subview isKindOfClass:NSClassFromString(@"_UINavigationBarContentView")]) { navigationBarContentView = subview; break; } } if (navigationBarContentView) { for (UIView * subview in [navigationBarContentView subviews]) { if (![subview isKindOfClass:NSClassFromString(@"_UIButtonBarStackView")]) continue; NSLayoutConstraint * topSpaceConstraint; NSLayoutConstraint * bottomSpaceConstraint; CGFloat topConstraintMultiplier = 1.0f; CGFloat bottomConstraintMultiplier = 1.0f; for (NSLayoutConstraint * constraint in navigationBarContentView.constraints) { if (constraint.firstItem == subview && constraint.firstAttribute == NSLayoutAttributeTop) { topSpaceConstraint = constraint; break; } if (constraint.secondItem == subview && constraint.secondAttribute == NSLayoutAttributeTop) { topConstraintMultiplier = -1.0f; topSpaceConstraint = constraint; break; } } for (NSLayoutConstraint * constraint in navigationBarContentView.constraints) { if (constraint.firstItem == subview && constraint.firstAttribute == NSLayoutAttributeBottom) { bottomSpaceConstraint = constraint; break; } if (constraint.secondItem == subview && constraint.secondAttribute == NSLayoutAttributeBottom) { bottomConstraintMultiplier = -1.0f; bottomSpaceConstraint = constraint; break; } } CGFloat contentViewHeight = navigationBarContentView.frame.size.height; CGFloat subviewHeight = subview.frame.size.height; topSpaceConstraint.constant = topConstraintMultiplier * (contentViewHeight - subviewHeight) / 2.0f; bottomSpaceConstraint.constant = bottomConstraintMultiplier * (contentViewHeight - subviewHeight) / 2.0f; } } } }
let barFrame = searchController.searchBar.frame searchController.searchBar.frame = CGRect(x: 0, y: 0, width: barFrame.width, height: 44)
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) self.navigationItem.titleView = UIView() }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) self.navigationItem.titleView = UISearchBar() }
@interface SearchBarWrapper : UIView @property (nonatomic, strong) UISearchBar *searchBar; - (instancetype)initWithSearchBar:(UISearchBar *)searchBar; @end @implementation SearchBarWrapper - (instancetype)initWithSearchBar:(UISearchBar *)searchBar { self = [super initWithFrame:CGRectMake(0, 0, 4000, 44)]; if (self) { self.searchBar = searchBar; [self addSubview:searchBar]; } return self; } - (void)layoutSubviews { [super layoutSubviews]; self.searchBar.frame = self.bounds; } - (CGSize)sizeThatFits:(CGSize)size { return size; } @end @implementation MyViewController - (void)viewDidLoad { [super viewDidLoad]; self.navigationItem.titleView = [[SearchBarWrapper alloc] initWithSearchBar:self.searchController.searchBar]; } @end
let systemMajorVersion = ProcessInfo.processInfo.operatingSystemVersion.majorVersion if systemMajorVersion < 12 { self.navigationItem.titleView = self.searchController.searchBar } if systemMajorVersion >= 11 { self.extendedLayoutIncludesOpaqueBars = true UIView.animate(withDuration: 0.3) { self.navigationController?.navigationBar.setNeedsLayout() self.navigationController?.navigationBar.layoutIfNeeded() } self.tableView.contentInset = UIEdgeInsets(top: -40, left: 0, bottom: 0, right: 0) if self.viewHadAppeared { self.tableView.contentInset = .zero } } self.viewHadAppeared = true }
lazy var searchController: UISearchController = { let searchController = UISearchController(searchResultsController: nil) searchController.hidesNavigationBarDuringPresentation = false searchController.dimsBackgroundDuringPresentation = false searchController.searchBar.textField?.backgroundColor = .lalaDarkWhiteColor searchController.searchBar.textField?.tintColor = .lalaDarkGray searchController.searchBar.backgroundColor = .white return searchController }()
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) navigationController?.view.setNeedsLayout() navigationController?.view.layoutIfNeeded() }
let textField = searchBar.value(forKey: "searchField") as? UITextField textField?.font = UIFont.systemFont(ofSize: 14.0, weight: .regular) textField?.textColor = textField?.textAlignment = .left if let radius: CGFloat = 5.0 let magnifyIconWidth: CGFloat = 16.0 let inset = UIEdgeInsets(top: 4.0, left: 0, bottom: 4.0, right: 0) let path = CGMutablePath() path.addArc(center: CGPoint(x: searchBar.bounds.size.width - radius - inset.right - magnifyIconWidth, y: inset.top + radius), radius: radius, startAngle: .pi * 3.0/2.0, endAngle: .pi*2.0, clockwise: false) path.addArc(center: CGPoint(x: searchBar.bounds.size.width - radius - inset.right - magnifyIconWidth, y: searchBar.bounds.size.height - radius - inset.bottom), radius: radius, startAngle: 0, endAngle: .pi/2.0, clockwise: false) path.addArc(center: CGPoint(x: inset.left + radius, y: searchBar.bounds.size.height - radius - inset.bottom), radius: radius, startAngle: .pi/2.0, endAngle: .pi, clockwise: false) path.addArc(center: CGPoint(x: inset.left + radius, y: inset.top + radius), radius: radius, startAngle: .pi, endAngle: .pi * 3.0/2.0, clockwise: false) let maskLayer = CAShapeLayer() maskLayer.path = path maskLayer.fillRule = kCAFillRuleEvenOdd textField?.layer.mask = maskLayer }
public override func viewDidAppear(_ animated: Bool) { if resultSearchController?.searchBar.heightAnchor.constraint(equalToConstant: 44).isActive = true } }
@implementation CJSearchBar -(CGSize)intrinsicContentSize{ CGSize s = [super intrinsicContentSize]; s.height = 44; return s; } @end
// // import Foundation import UIKit class CustomSearchBarView: UISearchBar { final let SearchBarHeight: CGFloat = 44 final let SearchBarPaddingTop: CGFloat = 8 override open func awakeFromNib() { super.awakeFromNib() self.setupUI() } override init(frame: CGRect) { super.init(frame: frame) self.setupUI() } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } func findTextfield()-> UITextField?{ for view in self.subviews { if view is UITextField { return view as? UITextField } else { for textfield in view.subviews { if textfield is UITextField { return textfield as? UITextField } } } } return nil; } func setupUI(){ if self.translatesAutoresizingMaskIntoConstraints = false self.heightAnchor.constraint(equalToConstant: SearchBarHeight).isActive = true } } override func layoutSubviews() { super.layoutSubviews() if if let textfield = self.findTextfield() { textfield.frame = CGRect(x: textfield.frame.origin.x, y: SearchBarPaddingTop, width: textfield.frame.width, height: SearchBarHeight - SearchBarPaddingTop * 2)`enter code here` return } } } }
infix operator ^^ { associativity left precedence 160 } func ^^ (radix: Int, power: Int) -> Int { return Int(pow(Double(radix), Double(power))) } let i = 2 ^^ 3 println("2¬≥ = \(2 ^^ 3)")
precedencegroup PowerPrecedence { higherThan: MultiplicationPrecedence } infix operator ^^ : PowerPrecedence func ^^ (radix: Int, power: Int) -> Int { return Int(pow(Double(radix), Double(power))) } let i2 = 2 ^^ 3 print("2¬≥ = \(2 ^^ 3)")
import Darwin let a: Int = 3 let b: Int = 3 let x: Int = Int(pow(Double(a),Double(b)))
func pow(_ base: Int, _ power: Int) -> Int { func expBySq(_ y: Int, _ x: Int, _ n: Int) -> Int { precondition(n >= 0) if n == 0 { return y } else if n == 1 { return y * x } else if n % 2 == 0 { return expBySq(y, x * x, n / 2) } else { return expBySq(y * x, x * x, (n - 1) / 2) } } return expBySq(1, base, power) }
infix operator ^^ { associativity left precedence 160 } func ^^ (radix: Int, power: Int) -> Int { return Int(pow(CGFloat(radix), CGFloat(power))) }
let pwrInt:(Int,Int)->Int = { a,b in return Int(pow(Double(a),Double(b))) } pwrInt(3,4)
infix operator ** { associativity left precedence 160 } func ** (radix: Double, power: Double) -> Double { return pow(radix, power) } func ** (radix: Int, power: Int ) -> Double { return pow(Double(radix), Double(power)) } func ** (radix: Float, power: Float ) -> Double { return pow(Double(radix), Double(power)) }
2 ** -3 = 0.125 2 ** 0.5 = 1.4142135623731 2 ** 3 = 8
func expo(_ base: Int, _ power: Int) -> Int { var result = 1 while (power != 0){ if (power%2 == 1){ result *= base } power /= 2 base *= base } return result }
func expo<T:IntegerType>(_ base: T, _ power: T) -> T { var result : T = 1
func pow (base:Int, power:UInt) -> Int { var answer : Int = 1 for _ in 0..power { answer *= base } return answer } > pow (2, 4) $R3: Int = 16 > pow (2, 8) $R4: Int = 256 > pow (3,3) $R5: Int = 27
var a:Int = 3 var b:Int = 3 println(pow(Double(a),Double(b)))
typealias Dbl = Double infix operator ** {associativity left precedence 160} func ** (lhs: NSNumber, rhs: NSNumber) -> Dbl {return pow(Dbl(lhs), Dbl(rhs))}
func ** (lhs: NSNumber, rhs: NSNumber) -> Dbl { if (Dbl(lhs) ?? Dbl.NaN) != Dbl.NaN && (Dbl(rhs) ?? Dbl.NaN) != Dbl.NaN { return pow(Dbl(lhs), Dbl(rhs)) } else { return Double.NaN } }
precedencegroup ExponentiationPrecedence { associativity: right higherThan: MultiplicationPrecedence } infix operator ^^: ExponentiationPrecedence public func ^^ (radix: Float, power: Float) -> Float { return pow((radix), (power)) } public func ^^ (radix: Double, power: Double) -> Double { return pow((radix), (power)) } public func ^^ (radix: Int, power: Int) -> Int { return NSDecimalNumber(decimal: pow(Decimal(radix), power)).intValue }
func ^ (left:NSNumber, right: NSNumber) -> NSNumber { return pow(left.doubleValue,right.doubleValue) } var a:NSNumber = 3 var b:NSNumber = 3 println( a^b )
func calc (base:Int, number:Int) -> Int { var answer : Int = base for _ in 2...number {answer *= base } return answer } calc (2,2)
func say(name:String, msg:String) { println("\(name) say \(msg)") } say("Henry","Hi,Swift") <---- error because missing argument label
func funFunction(someArg: Int, someOtherArg: Int) { println("funFunction: \(someArg) : \(someOtherArg)") } funFunction(1, 4) func externalParamFunction(externalOne internalOne: Int, externalTwo internalTwo: Int) { println("externalParamFunction: \(internalOne) : \(internalTwo)") } externalParamFunction(externalOne: 1, externalTwo: 4) func externalInternalShared( println("externalInternalShared: \(paramOne) : \(paramTwo)") } func externalInternalShared(paramOne paramOne: Int, print("externalInternalShared: \(paramOne) : \(paramTwo)") } externalInternalShared(paramOne: 1, paramTwo: 4)
class SomeClass { func someClassFunctionWithParamOne(paramOne: Int, paramTwo: Int) { println("someClassFunction: \(paramOne) : \(paramTwo)") } } var someInstance = SomeClass() someInstance.someClassFunctionWithParamOne(1, paramTwo: 4)
func say(name:String, msg:String) { print("\(name) say \(msg)") }
func say(somethingBy name:String, whoIsActuallySaying msg:String) { print("\(name) say \(msg)") }
self.say(somethingBy: "Henry",whoIsActuallySaying: "Hi,Swift")
let url = "http: let queryItems = URLComponents(string: url)?.queryItems let param1 = queryItems?.filter({$0.name == "param1"}).first print(param1?.value)
func randomCGFloat() -> CGFloat { return CGFloat(arc4random()) / UINT32_MAX }
import Foundation import CoreGraphics public extension Int { public static var random: Int { return Int.random(n: Int.max) } public static func random(n: Int) -> Int { return Int(arc4random_uniform(UInt32(n))) } public static func random(min: Int, max: Int) -> Int { return Int.random(n: max - min + 1) + min } } public extension Double { public static var random: Double { return Double(arc4random()) / 0xFFFFFFFF } public static func random(min: Double, max: Double) -> Double { return Double.random * (max - min) + min } } public extension Float { public static var random: Float { return Float(arc4random()) / 0xFFFFFFFF } public static func random(min: Float, max: Float) -> Float { return Float.random * (max - min) + min } } public extension CGFloat { public static var randomSign: CGFloat { return (arc4random_uniform(2) == 0) ? 1.0 : -1.0 } public static var random: CGFloat { return CGFloat(Float.random) } public static func random(min: CGFloat, max: CGFloat) -> CGFloat { return CGFloat.random * (max - min) + min } }
let randomNumDouble = Double.random(min: 0.00, max: 23.50) let randomNumInt = Int.random(min: 56, max: 992) let randomNumFloat = Float.random(min: 6.98, max: 923.09) let randomNumCGFloat = CGFloat.random(min: 6.98, max: 923.09)
extension ClosedRange where Bound : FloatingPoint { public func random() -> Bound { let range = self.upperBound - self.lowerBound let randomValue = (Bound(arc4random_uniform(UINT32_MAX)) / Bound(UINT32_MAX)) * range + self.lowerBound return randomValue } }
extension ClosedRange where Bound : FloatingPoint { public func random() -> Bound { let max = UInt32.max return Bound(arc4random_uniform(max)) / Bound(max) * (upperBound - lowerBound) + lowerBound } }
public extension Int { public static func random(lower: Int = 0, _ upper: Int = 100) -> Int { return lower + Int(arc4random_uniform(UInt32(upper - lower + 1))) } } public extension Double { public static func random(lower: Double = 0, _ upper: Double = 100) -> Double { return (Double(arc4random()) / 0xFFFFFFFF) * (upper - lower) + lower } } public extension Float { public static func random(lower: Float = 0, _ upper: Float = 100) -> Float { return (Float(arc4random()) / 0xFFFFFFFF) * (upper - lower) + lower } } public extension CGFloat { public static func random(lower: CGFloat = 0, _ upper: CGFloat = 1) -> CGFloat { return CGFloat(Float(arc4random()) / Float(UINT32_MAX)) * (upper - lower) + lower } }
extension IntervalType { public func random() -> Bound { let range = (self.end as! Double) - (self.start as! Double) let randomValue = (Double(arc4random_uniform(UINT32_MAX)) / Double(UINT32_MAX)) * range + (self.start as! Double) return randomValue as! Bound } }
extension CollectionType { public func random() -> Self._Element { if let startIndex = self.startIndex as? Int { let start = UInt32(startIndex) let end = UInt32(self.endIndex as! Int) return self[Int(arc4random_uniform(end - start) + start) as! Self.Index] } var generator = self.generate() var count = arc4random_uniform(UInt32(self.count as! Int)) while count > 0 { generator.next() count = count - 1 } return generator.next() as! Self._Element } }
(0...10).random() ["A", "B", "C"].random() ["X":1, "Y":2, "Z":3].random()
func randomCGFloat() -> Float { return Float(arc4random()) / Float(UInt32.max) }
let three = 3 let pointOneFourOneFiveNine = 0.14159 let pi = Double(three) + pointOneFourOneFiveNine
extension BinaryInteger { static func rand(_ min: Self, _ max: Self) -> Self { let _min = min let difference = max+1 - _min return Self(arc4random_uniform(UInt32(difference))) + _min } } extension BinaryFloatingPoint { private func toInt() -> Int { if let value = self as? CGFloat { return Int(value) } return Int(self) } static func rand(_ min: Self, _ max: Self, precision: Int) -> Self { if precision == 0 { let min = min.rounded(.down).toInt() let max = max.rounded(.down).toInt() return Self(Int.rand(min, max)) } let delta = max - min let maxFloatPart = Self(pow(10.0, Double(precision))) let maxIntegerPart = (delta * maxFloatPart).rounded(.down).toInt() let randomValue = Int.rand(0, maxIntegerPart) let result = min + Self(randomValue)/maxFloatPart return Self((result*maxFloatPart).toInt())/maxFloatPart } }
print("\(Int.rand(1, 20))") print("\(Float.rand(5.231233, 44.5, precision: 3))") print("\(Double.rand(5.231233, 44.5, precision: 4))") print("\(CGFloat.rand(5.231233, 44.5, precision: 6))")
import Foundation import CoreGraphics func run() { let min = 2.38945 let max = 2.39865 for _ in 0...100 { let precision = Int.rand(0, 5) print("Precision: \(precision)") floatSample(min: Float(min), max: Float(max), precision: precision) floatSample(min: Double(min), max: Double(max), precision: precision) floatSample(min: CGFloat(min), max: CGFloat(max), precision: precision) intSample(min: Int(1), max: Int(10000)) print("") } } private func printResult<T: Comparable>(min: T, max: T, random: T) { let result = "\(T.self) rand[\(min), \(max)] = \(random)" print(result) } func floatSample<T: BinaryFloatingPoint>(min: T, max: T, precision: Int) { printResult(min: min, max: max, random: T.rand(min, max, precision: precision)) } func intSample<T: BinaryInteger>(min: T, max: T) { printResult(min: min, max: max, random: T.rand(min, max)) }
extension BinaryFloatingPoint { public static var random: Self { return Self(arc4random()) / 0xFFFFFFFF } public static func random(min: Self, max: Self) -> Self { return Self.random * (max - min) + min } }
dyld: Library not loaded: @rpath/libswiftCore.dylib Referenced from: /private/var/mobile/Containers/Bundle/Application/10DB2FE8-EF09-4857-B4AC-0DB2E4419D6F/App-Name.app/App-Name Reason: image not found (lldb)
override func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) btnTwoLine?.titleLabel?.lineBreakMode = NSLineBreakMode.ByWordWrapping; }
@IBOutlet weak var btnTwoLine: UIButton? override func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) btnTwoLine?.titleLabel?.lineBreakMode = NSLineBreakMode.ByWordWrapping; var buttonText: NSString = "hello\nthere" var newlineRange: NSRange = buttonText.rangeOfString("\n") var substring1: NSString = "" var substring2: NSString = "" if(newlineRange.location != NSNotFound) { substring1 = buttonText.substringToIndex(newlineRange.location) substring2 = buttonText.substringFromIndex(newlineRange.location) } let font:UIFont? = UIFont(name: "Arial", size: 17.0) let attrString = NSMutableAttributedString( string: substring1 as String, attributes: NSDictionary( object: font!, forKey: NSFontAttributeName) as [NSObject : AnyObject]) let font1:UIFont? = UIFont(name: "Arial", size: 11.0) let attrString1 = NSMutableAttributedString( string: substring2 as String, attributes: NSDictionary( object: font1!, forKey: NSFontAttributeName) as [NSObject : AnyObject]) attrString.appendAttributedString(attrString1) btnTwoLine?.setAttributedTitle(attrString, forState: UIControlState.Normal) }
let button = UIButton() button.titleLabel?.numberOfLines = 0 button.titleLabel?.lineBreakMode = .byWordWrapping button.setTitle("Foo\nBar", for: .normal) button.titleLabel?.textAlignment = .center button.sizeToFit() button.addTarget(self, action: navigationItem.rightBarButtonItem = UIBarButtonItem(customView: button)
let str = NSMutableAttributedString(string: "First line\nSecond Line") str.addAttribute(NSFontAttributeName, value: UIFont.systemFont(ofSize: 17), range: NSMakeRange(0, 10)) str.addAttribute(NSFontAttributeName, value: UIFont.systemFont(ofSize: 12), range: NSMakeRange(11, 11)) button.setAttributedTitle(str, for: .normal)
override func viewDidLoad() { super.viewDidLoad() var str = NSMutableAttributedString(string: "First line\nSecond Line") str.addAttribute(NSFontAttributeName, value: UIFont.systemFontOfSize(17), range: NSMakeRange(0, 10)) str.addAttribute(NSFontAttributeName, value: UIFont.systemFontOfSize(12), range: NSMakeRange(11, 11)) button.setAttributedTitle(str, forState: .Normal) }
let firstLabel = UILabel() firstLabel.backgroundColor = UIColor.lightGrayColor() firstLabel.text = "Hi" firstLabel.textColor = UIColor.blueColor() firstLabel.textAlignment = NSTextAlignment.Center firstLabel.frame = CGRectMake(0, testButton.frame.height * 0.25, testButton.frame.width, testButton.frame.height * 0.2) testButton.addSubview(firstLabel) let secondLabel = UILabel() secondLabel.backgroundColor = UIColor.lightGrayColor() secondLabel.textColor = UIColor.blueColor() secondLabel.font = UIFont(name: "Arial", size: 12) secondLabel.text = "There" secondLabel.textAlignment = NSTextAlignment.Center secondLabel.frame = CGRectMake(0, testButton.frame.height * 0.5, testButton.frame.width, testButton.frame.height * 0.2) testButton.addSubview(secondLabel)
let theFileName = (string as NSString).lastPathComponent
var file_name = NSURL(fileURLWithPath: path_to_file).lastPathComponent!
let filename: String = "your file name" let pathExtention = filename.pathExtension let pathPrefix = filename.stringByDeletingPathExtension
let filename = (self.pdfURL as NSString).lastPathComponent let fileExtention = (filename as NSString).pathExtension let pathPrefix = (filename as NSString).deletingPathExtension self.lblFileName.text = pathPrefix
func createFileNameFromURL (colorUrl: URL) -> String { var arrayFolders = colorUrl.pathComponents let indx = arrayFolders.count - 3 var fileName = "" switch indx{ case 0...: fileName = arrayFolders[indx] + arrayFolders[indx+1] + arrayFolders[indx+2] case -1: fileName = arrayFolders[indx+1] + arrayFolders[indx+2] case -2: fileName = arrayFolders[indx+2] default: break } return fileName
let button = UIButton.buttonWithType(UIButtonType.System) as UIButton button.frame = CGRectMake(100, 100, 100, 100) button.setImage(IMAGE, forState: UIControlState.Normal) button.addTarget(self, action: "btnTouched:", forControlEvents: UIControlEvents.TouchUpInside) self.view.addSubview(button)
let image = UIImage(named: "name") as UIImage? let button = UIButton(type: UIButtonType.Custom) as UIButton button.frame = CGRectMake(100, 100, 100, 100) button.setImage(image, forState: .Normal) button.addTarget(self, action: "btnTouched:", forControlEvents:.TouchUpInside) self.view.addSubview(button)
let image = UIImage(named: "ImageName.png") as UIImage var button = UIButton.buttonWithType(UIButtonType.System) as UIButton button.frame = CGRectMake(100, 100, 100, 100) button .setBackgroundImage(image, forState: UIControlState.Normal) button.addTarget(self, action: "Action:", forControlEvents:UIControlEvents.TouchUpInside) menuView.addSubview(button)
let image = UIImage(named: "name") as UIImage? let button = UIButton(type: UIButtonType.custom) as UIButton button.frame = CGRect(x: 100, y: 100, width: 100, height: 100) button.setImage(image, for: .normal) button.addTarget(self, action: Selector("btnTouched:"), for:.touchUpInside) self.view.addSubview(button)
let button = UIButton.buttonWithType(UIButtonType.System) as UIButton button.frame = CGRectMake(100, 100, 100, 100) if let image = UIImage(named: "imagename.png") { button.setImage(image, forState: .Normal) } button.addTarget(self, action: "btnTouched:", forControlEvents:.TouchUpInside) self.view.addSubview(button)
let btnRight=UIButton.buttonWithType(UIButtonType.Custom) as UIButton btnRight.frame=CGRectMake(0, 0, 35, 35) btnRight.setBackgroundImage(UIImage(named: "menu.png"), forState: UIControlState.Normal) btnRight.setTitle("Right", forState: UIControlState.Normal) btnRight.tintColor=UIColor.blackColor()
let img = UIImage(named: "imgname") let myButton = UIButton(type: UIButtonType.custom) myButton.frame = CGRect.init(x: 10, y: 10, width: 100, height: 45) myButton.setImage(img, for: .normal) myButton.addTarget(self, action: self.view.addSubview(myButton)
loginButton = UIButton(frame: CGRectMake(self.view.bounds.origin.x + (self.view.bounds.width * 0.325), self.view.bounds.origin.y + (self.view.bounds.height * 0.8), self.view.bounds.origin.x + (self.view.bounds.width * 0.35), self.view.bounds.origin.y + (self.view.bounds.height * 0.05))) loginButton.layer.cornerRadius = 18.0 loginButton.layer.borderWidth = 2.0 loginButton.backgroundColor = UIColor.whiteColor() loginButton.layer.borderColor = UIColor.whiteColor().CGColor loginButton.setTitle("Login", forState: UIControlState.Normal) loginButton.setTitleColor(UIColor(red: 24.0/100, green: 116.0/255, blue: 205.0/205, alpha: 1.0), forState: UIControlState.Normal)
let image = UIImage(named: "name") let button = UIButton(type: .custom) button.frame = CGRect(x: 100, y: 100, width: 100, height: 100) button.setImage(image, for: .normal) button.addTarget(self, action: self.view.addSubview(button)
let myButton = UIButton() myButton.titleLabel!.frame = CGRectMake(15, 54, 300, 500) myButton.titleLabel!.text = "Button Label" myButton.titleLabel!.textColor = UIColor.redColor() myButton.titleLabel!.textAlignment = .Center myButton.addTarget(self,action:"Action:",forControlEvents:UIControlEvent.TouchUpInside) self.view.addSubview(myButton)
let zoomInImage = UIImage(named: "Icon - plus") as UIImage? let zoomInButton = UIButton(frame: CGRect(x: 10), y: 10, width: 45, height: 45)) zoomInButton.setBackgroundImage(zoomInImage, for: UIControlState.normal) zoomInButton.addTarget(self, action: self.view.addSubview(zoomInButton)
var possList: NSString? = NSString.stringWithContentsOfURL(filePath.URL) as? NSString if var list = possList { list = list.componentsSeparatedByString("\n") as NSString[] return list } else { }
var aStreamReader = new StreamReader(from_file_or_url) while aStreamReader.hasNextLine == true { currentline = aStreamReader.nextLine() list.addItem(currentline) }
class StreamReader { let encoding : UInt let chunkSize : Int var fileHandle : NSFileHandle! let buffer : NSMutableData! let delimData : NSData! var atEof : Bool = false init?(path: String, delimiter: String = "\n", encoding : UInt = NSUTF8StringEncoding, chunkSize : Int = 4096) { self.chunkSize = chunkSize self.encoding = encoding if let fileHandle = NSFileHandle(forReadingAtPath: path), delimData = delimiter.dataUsingEncoding(encoding), buffer = NSMutableData(capacity: chunkSize) { self.fileHandle = fileHandle self.delimData = delimData self.buffer = buffer } else { self.fileHandle = nil self.delimData = nil self.buffer = nil return nil } } deinit { self.close() } func nextLine() -> String? { precondition(fileHandle != nil, "Attempt to read from closed file") if atEof { return nil } var range = buffer.rangeOfData(delimData, options: [], range: NSMakeRange(0, buffer.length)) while range.location == NSNotFound { let tmpData = fileHandle.readDataOfLength(chunkSize) if tmpData.length == 0 { atEof = true if buffer.length > 0 { let line = NSString(data: buffer, encoding: encoding) buffer.length = 0 return line as String? } return nil } buffer.appendData(tmpData) range = buffer.rangeOfData(delimData, options: [], range: NSMakeRange(0, buffer.length)) } let line = NSString(data: buffer.subdataWithRange(NSMakeRange(0, range.location)), encoding: encoding) buffer.replaceBytesInRange(NSMakeRange(0, range.location + range.length), withBytes: nil, length: 0) return line as String? } func rewind() -> Void { fileHandle.seekToFileOffset(0) buffer.length = 0 atEof = false } func close() -> Void { fileHandle?.closeFile() fileHandle = nil } }
if let aStreamReader = StreamReader(path: "/path/to/file") { defer { aStreamReader.close() } while let line = aStreamReader.nextLine() { print(line) } }
extension StreamReader : SequenceType { func generate() -> AnyGenerator<String> { return AnyGenerator { return self.nextLine() } } }
class StreamReader { let encoding : String.Encoding let chunkSize : Int var fileHandle : FileHandle! let delimData : Data var buffer : Data var atEof : Bool init?(path: String, delimiter: String = "\n", encoding: String.Encoding = .utf8, chunkSize: Int = 4096) { guard let fileHandle = FileHandle(forReadingAtPath: path), let delimData = delimiter.data(using: encoding) else { return nil } self.encoding = encoding self.chunkSize = chunkSize self.fileHandle = fileHandle self.delimData = delimData self.buffer = Data(capacity: chunkSize) self.atEof = false } deinit { self.close() } func nextLine() -> String? { precondition(fileHandle != nil, "Attempt to read from closed file") while !atEof { if let range = buffer.range(of: delimData) { let line = String(data: buffer.subdata(in: 0..<range.lowerBound), encoding: encoding) buffer.removeSubrange(0..<range.upperBound) return line } let tmpData = fileHandle.readData(ofLength: chunkSize) if tmpData.count > 0 { buffer.append(tmpData) } else { atEof = true if buffer.count > 0 { let line = String(data: buffer as Data, encoding: encoding) buffer.count = 0 return line } } } return nil } func rewind() -> Void { fileHandle.seek(toFileOffset: 0) buffer.count = 0 atEof = false } func close() -> Void { fileHandle?.closeFile() fileHandle = nil } } extension StreamReader : Sequence { func makeIterator() -> AnyIterator<String> { return AnyIterator { return self.nextLine() } } }
import Foundation public class LineReader { public let path: String fileprivate let file: UnsafeMutablePointer<FILE>! init?(path: String) { self.path = path file = fopen(path, "r") guard file != nil else { return nil } } public var nextLine: String? { var line:UnsafeMutablePointer<CChar>? = nil var linecap:Int = 0 defer { free(line) } return getline(&line, &linecap, file) > 0 ? String(cString: line!) : nil } deinit { fclose(file) } } extension LineReader: Sequence { public func makeIterator() -> AnyIterator<String> { return AnyIterator<String> { return self.nextLine } } }
guard let reader = LineReader(path: "/Path/to/file.txt") else { return; } for line in reader { print(">" + line.trimmingCharacters(in: .whitespacesAndNewlines)) }
let readLine = ReadLine(somePath) while let line = readLine.readLine() { } class ReadLine { private var buf = UnsafeMutablePointer<Int8>.alloc(1024) private var n: Int = 1024 let path: String let mode: String = "r" private lazy var filepointer: UnsafeMutablePointer<FILE> = { let csmode = self.mode.withCString { cs in return cs } let cspath = self.path.withCString { cs in return cs } return fopen(cspath, csmode) }() init(path: String) { self.path = path } func readline() -> String? { if getline(&buf, &n, filepointer) > 0 { return String.fromCString(UnsafePointer<CChar>(buf)) } return nil } deinit { buf.dealloc(n) fclose(filepointer) } }
import Darwin let bufsize = 4096 var buf = UnsafePointer<Int8>.alloc(bufsize) while fgets(buf, Int32(bufsize-1), stdin) { print(String.fromCString(CString(buf))) } buf.destroy()
func lineGenerator(file:UnsafeMutablePointer<FILE>) -> AnyGenerator<String> { return AnyGenerator { () -> String? in var line:UnsafeMutablePointer<CChar> = nil var linecap:Int = 0 defer { free(line) } return getline(&line, &linecap, file) > 0 ? String.fromCString(line) : nil } }
let path = NSBundle.mainBundle().pathForResource("foo", ofType: nil)! let file = fopen(path,"r") for line in lineGenerator(file) { print(line, separator: "", terminator: "") } fclose(file)
class StreamReader { var eofReached = false let fileHandle: UnsafePointer<FILE> init (path: String) { self.fileHandle = fopen(path.bridgeToObjectiveC().UTF8String, "rb".bridgeToObjectiveC().UTF8String) } deinit { fclose(self.fileHandle) } func nextLine() -> String { var nextChar: UInt8 = 0 var stringSoFar = "" var eolReached = false while (self.eofReached == false) && (eolReached == false) { if fread(&nextChar, 1, 1, self.fileHandle) == 1 { switch nextChar & 0xFF { case 13, 10 : eolReached = true case 0...127 : stringSoFar += NSString(bytes:&nextChar, length:1, encoding: NSASCIIStringEncoding) default : stringSoFar += "<\(nextChar)>" } } else { self.eofReached = true } } return stringSoFar } } var aStreamReader = StreamReader(path: "~/Desktop/Test.text".stringByStandardizingPath) while aStreamReader.eofReached == false { let currentline = aStreamReader.nextLine() println(currentline) }
struct DataInternetLineIterator: IteratorProtocol { typealias LineLocation = (offset: Int, length: Int, terminatorLength: Int) static let cr: UInt8 = 13 static let crData = Data(repeating: cr, count: 1) static let lf: UInt8 = 10 static let lfData = Data(repeating: lf, count: 1) let data: Data private var lineStartOffset: Int = 0 init(data: Data) { self.data = data } mutating func next() -> LineLocation? { guard self.data.count - self.lineStartOffset > 0 else { return nil } let nextCR = self.data.range(of: DataInternetLineIterator.crData, options: [], in: lineStartOffset..<self.data.count)?.lowerBound let nextLF = self.data.range(of: DataInternetLineIterator.lfData, options: [], in: lineStartOffset..<self.data.count)?.lowerBound var location: LineLocation = (self.lineStartOffset, -self.lineStartOffset, 0) let lineEndOffset: Int switch (nextCR, nextLF) { case (nil, nil): lineEndOffset = self.data.count case (nil, let offsetLf): lineEndOffset = offsetLf! location.terminatorLength = 1 case (let offsetCr, nil): lineEndOffset = offsetCr! location.terminatorLength = 1 default: lineEndOffset = min(nextLF!, nextCR!) if nextLF! < nextCR! { location.terminatorLength = 1 } else { switch nextLF! - nextCR! { case 2 where self.data[nextCR! + 1] == DataInternetLineIterator.cr: location.terminatorLength += 1 fallthrough case 1: location.terminatorLength += 1 fallthrough default: location.terminatorLength += 1 } } } self.lineStartOffset = lineEndOffset + location.terminatorLength location.length += self.lineStartOffset return location } }
struct DataBlockIterator: IteratorProtocol { let data: Data private(set) var blockOffset = 0 private(set) var bytesRemaining: Int let blockSize: Int init(data: Data, blockSize: Int) { precondition(blockSize > 0) self.data = data self.bytesRemaining = data.count self.blockSize = blockSize } mutating func next() -> Data? { guard bytesRemaining > 0 else { return nil } defer { blockOffset += blockSize ; bytesRemaining -= blockSize } return data.subdata(in: blockOffset..<(blockOffset + min(bytesRemaining, blockSize))) } }
class LineReader { let path: String init?(path: String) { self.path = path guard let file = fopen(path, "r") else { return nil } self.file = file } deinit { fclose(file) } var nextLine: String? { var line: UnsafeMutablePointer<CChar>? var linecap = 0 defer { free(line) } let status = getline(&line, &linecap, file) guard status > 0, let unwrappedLine = line else { return nil } return String(cString: unwrappedLine) } private let file: UnsafeMutablePointer<FILE> } extension LineReader: Sequence { func makeIterator() -> AnyIterator<String> { return AnyIterator<String> { return self.nextLine } } }
guard let reader = LineReader(path: "/Path/to/file.txt") else { return } reader.forEach { line in print(line.trimmingCharacters(in: .whitespacesAndNewlines)) }
let stdinByLine = GeneratorOf({ () -> String? in var input = UnsafeMutablePointer<Int8>(), lim = 0 return getline(&input, &lim, stdin) > 0 ? String.fromCString(input) : nil })
let byLine = { (file:UnsafeMutablePointer<FILE>) in GeneratorOf({ () -> String? in var input = UnsafeMutablePointer<Int8>(), lim = 0 return getline(&input, &lim, file) > 0 ? String.fromCString(input) : nil }) }
import Foundation class LineStream { let path: String let handle: NSFileHandle! let delim: NSData! let encoding: NSStringEncoding var buffer = NSData() var buffSize: Int var buffIndex = 0 var buffEndIndex = 0 init?(path: String, buffSize: Int = 4096, delim: String = "\n", encoding: NSStringEncoding = NSUTF8StringEncoding) { self.handle = NSFileHandle(forReadingAtPath: path) self.path = path self.buffSize = buffSize < 1 ? 1 : buffSize self.encoding = encoding self.delim = delim.dataUsingEncoding(encoding) if handle == nil || self.delim == nil { print("ERROR initializing LineStream") return nil } } private func fillBuffer() -> Int { buffer = handle.readDataOfLength(buffSize) buffIndex = 0 buffEndIndex = buffer.length return buffEndIndex } private func delimLocation() -> Int? { let searchRange = NSMakeRange(buffIndex, buffEndIndex - buffIndex) let rangeToDelim = buffer.rangeOfData(delim, options: [], range: searchRange) return rangeToDelim.location == NSNotFound ? nil : rangeToDelim.location } private func dataStrValue(data: NSData) -> String? { if let strVal = NSString(data: data, encoding: encoding) as? String { return strVal } else { return "" } } func readLine() -> String? { guard let line = NSMutableData(capacity: buffSize) else { print("ERROR setting line") exit(EXIT_FAILURE) } var delimFound = false while !delimFound { if buffIndex == buffEndIndex { if fillBuffer() == 0 { return nil } } var lengthToDelim: Int let startIndex = buffIndex if let delim = delimLocation() { delimFound = true lengthToDelim = delim - buffIndex buffIndex = delim + 1 } else { lengthToDelim = buffEndIndex - buffIndex buffIndex = buffEndIndex } line.appendData(buffer.subdataWithRange( NSMakeRange(startIndex, lengthToDelim))) } return dataStrValue(line) } }
guard let myStream = LineStream(path: "/path/to/file.txt") else { exit(EXIT_FAILURE) } while let s = myStream.readLine() { print(s) }
[self.navigationItem setHidesBackButton:YES animated:YES];
self.navigationItem.setHidesBackButton(true, animated:true);
override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) self.tabBarController?.navigationItem.hidesBackButton = true }
self.navigationItem.leftBarButtonItems = [] self.navigationItem.hidesBackButton = true
override func viewDidAppear(_ animated: Bool) { self.navigationController?.isNavigationBarHidden = true }
@IBAction func timePickerClicked(sender: UIDatePicker) { var dateFormatter = NSDateFormatter() dateFormatter.timeStyle = NSDateFormatterStyle.ShortStyle var dateStr = dateFormatter.stringFromDate(startTime.date) let sttime = dateStr startTimeDisplay.text = dateStr }
let calendar = Calendar.current let date = calendar.date(byAdding: .minute, value: 5, to: startDate)
let calendar = NSCalendar.currentCalendar() let date = calendar.dateByAddingUnit(.Minute, value: 5, toDate: startDate, options: [])
let date = startDate.addingTimeInterval(5.0 * 60.0)
let date = startDate.dateByAddingTimeInterval(5.0 * 60.0)
func date(byAdding component: Calendar.Component, value: Int, to date: Date, wrappingComponents: Bool = default) -> Date?
extension Date { func adding(minutes: Int) -> Date { return Calendar.current.date(byAdding: .minute, value: minutes, to: self)! } }
let section1 = sender.date.adding(minutes: 5) let section2 = sender.date.adding(minutes: 10)
let date = startDate.addingTimeInterval(TimeInterval(5.0 * 60.0))
let date = startDate.addingTimeInterval(TimeInterval(-5.0 * 60.0))
extension Int { var seconds: Int { return self } var minutes: Int { return self.seconds * 60 } var hours: Int { return self.minutes * 60 } var days: Int { return self.hours * 24 } var weeks: Int { return self.days * 7 } var months: Int { return self.weeks * 4 } var years: Int { return self.months * 12 } }
let threeDaysLater = TimeInterval(3.days) date.addingTimeInterval(threeDaysLater)
import Foundation let comps = NSDateComponents() comps.minute = 5 let cal = NSCalendar.currentCalendar() let r = cal.dateByAddingComponents(comps, toDate: NSDate(), options: nil)
let minutes: TimeInterval = 1 * 60 let nowPlusOne = Date() + minutes
let dateAfterMin = NSDate.init(timeIntervalSinceNow: (minutes * 60.0))
let now : Date = Date() let currentCalendar : NSCalendar = Calendar.current as NSCalendar let nowPlusAddTime : Date = currentCalendar.date(byAdding: .second, value: accessTime, to: now, options: .matchNextTime)! let unixTime = nowPlusAddTime.timeIntervalSince1970
NSNotificationCenter.defaultCenter().addObserver(self, selector: "keyboardWillShow:", name: UIKeyboardWillShowNotification, object: nil)
NotificationCenter.default.addObserver( self, selector: name: NSNotification.Name.UIKeyboardWillShow, object: nil )
NotificationCenter.default.addObserver( self, selector: name: UIResponder.keyboardWillShowNotification, object: nil )
func keyboardWillShow(notification: NSNotification) { let userInfo: NSDictionary = notification.userInfo! let keyboardFrame: NSValue = userInfo.valueForKey(UIKeyboardFrameEndUserInfoKey) as! NSValue let keyboardRectangle = keyboardFrame.CGRectValue() let keyboardHeight = keyboardRectangle.height }
@objc func keyboardWillShow(_ notification: Notification) { if let keyboardFrame: NSValue = notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue { let keyboardRectangle = keyboardFrame.cgRectValue let keyboardHeight = keyboardRectangle.height } }
@objc func keyboardWillShow(_ notification: Notification) { if let keyboardFrame: NSValue = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue { let keyboardRectangle = keyboardFrame.cgRectValue let keyboardHeight = keyboardRectangle.height }
NotificationCenter.default.addObserver(self, selector:
@objc func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { let keyboardHeight = keyboardSize.height print(keyboardHeight) } }
@IBOutlet weak var tableViewBottomLayoutConstraint: NSLayoutConstraint! override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) NotificationCenter.default.removeObserver(self, name: .UIKeyboardWillShow , object: nil) NotificationCenter.default.removeObserver(self, name: .UIKeyboardWillHide , object: nil) } @objc func keyboardWillAppear(notification: NSNotification?) { guard let keyboardFrame = notification?.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue else { return } let keyboardHeight: CGFloat if keyboardHeight = keyboardFrame.cgRectValue.height - self.view.safeAreaInsets.bottom } else { keyboardHeight = keyboardFrame.cgRectValue.height } tableViewBottomLayoutConstraint.constant = keyboardHeight } @objc func keyboardWillDisappear(notification: NSNotification?) { tableViewBottomLayoutConstraint.constant = 0.0 }
private func setUpObserver() { NotificationCenter.default.addObserver(self, selector: .keyboardWillShow, name: UIResponder.keyboardWillShowNotification, object: nil) }
@objc fileprivate func keyboardWillShow(notification:NSNotification) { if let keyboardRectValue = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { let keyboardHeight = keyboardRectValue.height } }
private extension Selector { static let keyboardWillShow = }
private func setUpObserver() { NotificationCenter.default.addObserver(self, selector: .keyboardWillShow, name: .UIKeyboardWillShow, object: nil) }
@objc fileprivate func keyboardWillShow(notification:NSNotification) { if let keyboardRectValue = (notification.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue { let keyboardHeight = keyboardRectValue.height } }
private extension Selector { static let keyboardWillShow = }
private func setUpObserver() { NSNotificationCenter.defaultCenter().addObserver(self, selector: .keyboardWillShow, name: UIKeyboardWillShowNotification, object: nil) }
@objc private func keyboardWillShow(notification:NSNotification) { let userInfo:NSDictionary = notification.userInfo! let keyboardFrame:NSValue = userInfo.valueForKey(UIKeyboardFrameEndUserInfoKey) as! NSValue let keyboardRectangle = keyboardFrame.CGRectValue() let keyboardHeight = keyboardRectangle.height editorBottomCT.constant = keyboardHeight }
private extension Selector { static let keyboardWillShow = }
func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { let keyboardHeight = keyboardSize.height } }
override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver(self, selector: } func keyboardWillShow(notification: NSNotification) { if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue { let keyboardHeight : Int = Int(keyboardSize.height) print("keyboardHeight",keyboardHeight) } }
ViewDidLoad() { self.yourtextfield.becomefirstresponder() NotificationCenter.default.addObserver(self, selector: NotificationCenter.default.addObserver(self, selector: }
func keyboardWillShow(notification:NSNotification) { let userInfo:NSDictionary = notification.userInfo! as NSDictionary let keyboardFrame:NSValue = userInfo.value(forKey: UIKeyboardFrameEndUserInfoKey) as! NSValue let keyboardRectangle = keyboardFrame.cgRectValue let keyboardHeight = keyboardRectangle.height tblViewListData.frame.size.height = fltTblHeight-keyboardHeight } func keyboardWillHide(notification:NSNotification) { tblViewListData.frame.size.height = fltTblHeight }
var myStringArray: String[] = [] myStringArray += "a" myStringArray += "b" -> ["a", "b"]
var myIntArray: Int[] = [] myIntArray += 1 myIntArray += 2 -> [1, 2]
let path = "/Library/Application Support/Apple/iChat Icons/Flags/" let image1 = NSImage(byReferencingFile: path + "Brazil.png") let image2 = NSImage(byReferencingFile: path + "Chile.png") var myImageArray: NSImage[] = [] myImageArray += image1 myImageArray += image2 -> [<NSImage 0x7fe371c199f0 ...>, <NSImage 0x7fe371f39ea0 ...>]
let myDict1 = ["someKey":"someValue"] let myDict2 = ["anotherKey":"anotherValue"] var myDictArray = [myDict1] myDictArray += myDict2 -> [["someKey": "someValue"], ["anotherKey": "anotherValue"]]
var dictArray1: Dictionary<String, String>[] = Dictionary<String, String>[]() var dictArray2: Dictionary<String, String>[] = [] var dictArray3 = Dictionary<String, String>[]()
class Image {} Image i1 Image i2 var x = [Image]() x += i1 x += [i1] x += [i1, i2]
let path = "/Library/Application Support/Apple/iChat Icons/Flags/" let image1 = UIImage(contentsOfFile: readPath + "Brazil.png") let image2 = UIImage(contentsOfFile: readPath + "Chile.png") var myImageArray = [UIImage]() myImageArray.append(image1) myImageArray.append(image2)
self.tableView.reloadRowsAtIndexPaths(paths, withRowAnimation: UITableViewRowAnimation.none)
let indexPath = NSIndexPath(forRow: rowNumber, inSection: 0) tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Top)
let indexPath = IndexPath(item: rowNumber, section: 0) tableView.reloadRows(at: [indexPath], with: .top)
let indexPath = IndexPath(item: row, section: 0) tableView.reloadRows(at: [indexPath], with: .fade)
let indexPath = NSIndexPath(forRow: row, inSection: 0) tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
let indexPath = IndexPath(item: row, section: 0) if let visibleIndexPaths = tableView.indexPathsForVisibleRows?.index(of: indexPath as IndexPath) { if visibleIndexPaths != NSNotFound { tableView.reloadRows(at: [indexPath], with: .fade) } }
let indexPath = NSIndexPath(forRow: row, inSection: 0) if let visibleIndexPaths = tableView.indexPathsForVisibleRows?.indexOf(indexPath) { if visibleIndexPaths != NSNotFound { tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) } }
let rowNumber: Int = 2 let sectionNumber: Int = 0 let indexPath = IndexPath(item: rowNumber, section: sectionNumber) self.tableView.reloadRows(at: [indexPath], with: .automatic)
let indexPathRow:Int = 0 let indexPosition = IndexPath(row: indexPathRow, section: 0) tableView.reloadRows(at: [indexPosition], with: .none)
let indexPathRow:Int = 0 let indexPosition = IndexPath(row: indexPathRow, section: 0) tableView.reloadRows(at: [indexPosition], with: .none)
self.tableView.reloadRowsAtIndexPaths([NSIndexPath(rowNumber)], withRowAnimation: UITableViewRowAnimation.Top)
yourTableView.reloadSections(IndexSet, with: UITableViewRowAnimation)
self.tableView.beginUpdates() self.yourArray.remove(at: self.selectedTag) print(self.allGroups) let indexPath = NSIndexPath.init(row: self.selectedTag, section: 0) self.tableView.deleteRows(at: [indexPath as IndexPath], with: .automatic) self.tableView.endUpdates() self.tableView.reloadRows(at: self.tableView.indexPathsForVisibleRows!, with: .automatic)
var indexPath = NSIndexPath.FromRowSection(rowIndex, 0); tableView.ReloadRows(new NSIndexPath[] { indexPath }, UITableViewRowAnimation.Top);
UIDevice.currentDevice().identifierForVendor.UUIDString.substringToIndex(8)
let s: String = "Stack Overflow" let ss1: String = (s as NSString).substringToIndex(5) let index: String.Index = advance(s.startIndex, 5) let ss2:String = s.substringToIndex(index)
extension String : Collection { struct Index : BidirectionalIndex, Reflectable { func successor() -> String.Index func predecessor() -> String.Index func getMirror() -> Mirror } var startIndex: String.Index { get } var endIndex: String.Index { get } subscript (i: String.Index) -> Character { get } func generate() -> IndexingGenerator<String> }
let s: String = "Stack Overflow" let ss1: String = (s as NSString).substringToIndex(5) let index: String.Index = s.startIndex.advancedBy(5) let ss2:String = s.substringToIndex(index)
let s: String = "Stack Overflow" let ss1: String = (s as NSString).substring(to: 5) let index: String.Index = s.index(s.startIndex, offsetBy: 5) var ss2: String = s.substring(to: index)
let s: String = "Stack Overflow" let ss1: String = (s as NSString).substring(to: 5) let index: String.Index = s.index(s.startIndex, offsetBy: 5) var ss3: Substring = s[...index] var ss4: String = String(s[...index])
var name: String? = null name?.let { nameUnwrapp -> println(nameUnwrapp) } name = "Alex" name?.let { nameUnwrapp -> println(nameUnwrapp) }
if (val name = nullableName, val age = nullableAge) { doSomething(name, age) }
if let a = b.val { print("Good news!") } else { print("Equal to }
val a = b.val if (a != null) { println("Good news!") } else { println("Equal to }
func testIt() { guard let a = b.val else { print("Equal to return } } testIt()
fun testIt() { val a = b.val if (a == null) { println("Equal to return } else { println("Good news!") } } testIt()
let struct = Foo(a: 1, b: 2) let dict = something(struct)
extension Encodable { func asDictionary() throws -> [String: Any] { let data = try JSONEncoder().encode(self) guard let dictionary = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: Any] else { throw NSError() } return dictionary } }
extension Encodable { var dictionary: [String: Any]? { guard let data = try? JSONEncoder().encode(self) else { return nil } return (try? JSONSerialization.jsonObject(with: data, options: .allowFragments)).flatMap { $0 as? [String: Any] } } }
let struct = Foo(a: 1, b: 2) let dict = try struct.asDictionary() let optionalDict = struct.dictionary
import CodableFirebase let model = Foo(a: 1, b: 2) let dict = try! FirebaseEncoder().encode(model)
struct Foo: Codable { var a: Int var b: Int init(a: Int, b: Int) { self.a = a self.b = b } } let foo = Foo(a: 1, b: 2) let dict = try JSONDecoder().decode([String: Int].self, from: JSONEncoder().encode(foo)) print(dict)
class DictionaryEncoder { private let encoder = JSONEncoder() var dateEncodingStrategy: JSONEncoder.DateEncodingStrategy { set { encoder.dateEncodingStrategy = newValue } get { return encoder.dateEncodingStrategy } } var dataEncodingStrategy: JSONEncoder.DataEncodingStrategy { set { encoder.dataEncodingStrategy = newValue } get { return encoder.dataEncodingStrategy } } var nonConformingFloatEncodingStrategy: JSONEncoder.NonConformingFloatEncodingStrategy { set { encoder.nonConformingFloatEncodingStrategy = newValue } get { return encoder.nonConformingFloatEncodingStrategy } } var keyEncodingStrategy: JSONEncoder.KeyEncodingStrategy { set { encoder.keyEncodingStrategy = newValue } get { return encoder.keyEncodingStrategy } } func encode<T>(_ value: T) throws -> [String: Any] where T : Encodable { let data = try encoder.encode(value) return try JSONSerialization.jsonObject(with: data, options: .allowFragments) as! [String: Any] } } class DictionaryDecoder { private let decoder = JSONDecoder() var dateDecodingStrategy: JSONDecoder.DateDecodingStrategy { set { decoder.dateDecodingStrategy = newValue } get { return decoder.dateDecodingStrategy } } var dataDecodingStrategy: JSONDecoder.DataDecodingStrategy { set { decoder.dataDecodingStrategy = newValue } get { return decoder.dataDecodingStrategy } } var nonConformingFloatDecodingStrategy: JSONDecoder.NonConformingFloatDecodingStrategy { set { decoder.nonConformingFloatDecodingStrategy = newValue } get { return decoder.nonConformingFloatDecodingStrategy } } var keyDecodingStrategy: JSONDecoder.KeyDecodingStrategy { set { decoder.keyDecodingStrategy = newValue } get { return decoder.keyDecodingStrategy } } func decode<T>(_ type: T.Type, from dictionary: [String: Any]) throws -> T where T : Decodable { let data = try JSONSerialization.data(withJSONObject: dictionary, options: []) return try decoder.decode(type, from: data) } }
let dictionary = try DictionaryEncoder().encode(object)
let object = try DictionaryDecoder().decode(Object.self, from: dictionary)
do { let employeeDictionary: [String: Any] = try DictionaryEncoder().encode(employee) } catch let error { }
let dict = Dictionary(uniqueKeysWithValues: Mirror(reflecting: foo).children.map{ ($0.label!, $0.value) })
class DictionaryEncoder { private let jsonEncoder = JSONEncoder() func encode<T>(_ value: T) throws -> Any where T: Encodable { let jsonData = try jsonEncoder.encode(value) return try JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) } } class DictionaryDecoder { private let jsonDecoder = JSONDecoder() func decode<T>(_ type: T.Type, from json: Any) throws -> T where T: Decodable { let jsonData = try JSONSerialization.data(withJSONObject: json, options: []) return try jsonDecoder.decode(type, from: jsonData) } }
struct Computer: Codable { var owner: String? var cpuCores: Int var ram: Double } let computer = Computer(owner: "5keeve", cpuCores: 8, ram: 4) let dictionary = try! DictionaryEncoder().encode(computer) let decodedComputer = try! DictionaryDecoder().decode(Computer.self, from: dictionary)
class DictionaryEncoder { var result: [String: Any] init() { result = [:] } func encode(_ encodable: DictionaryEncodable) -> [String: Any] { encodable.encode(self) return result } func encode<T, K>(_ value: T, key: K) where K: RawRepresentable, K.RawValue == String { result[key.rawValue] = value } } protocol DictionaryEncodable { func encode(_ encoder: DictionaryEncoder) }
typealias EventDict = [String:Int] struct Favorite { var all:EventDict init(all: EventDict = [:]) { self.all = all } } extension Favorite: Encodable { struct FavoriteKey: CodingKey { var stringValue: String init?(stringValue: String) { self.stringValue = stringValue } var intValue: Int? { return nil } init?(intValue: Int) { return nil } } func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: FavoriteKey.self) for eventId in all { let nameKey = FavoriteKey(stringValue: eventId.key)! try container.encode(eventId.value, forKey: nameKey) } } } extension Favorite: Decodable { public init(from decoder: Decoder) throws { var events = EventDict() let container = try decoder.container(keyedBy: FavoriteKey.self) for key in container.allKeys { let fav = try container.decode(Int.self, forKey: key) events[key.stringValue] = fav } self.init(all: events) } }
let payload = [1, 2, 3] let encoded = try JSONEncoder().encode(payload)
var companies = ["AAPL" : "Apple Inc", "GOOG" : "Google Inc", "AMZN" : "Amazon.com, Inc", "FB" : "Facebook Inc"] for (name) in companies.key { println(companies.objectForKey("AAPL")) }
var companies = ["AAPL" : "Apple Inc", "GOOG" : "Google Inc", "AMZN" : "Amazon.com, Inc", "FB" : "Facebook Inc"] for (key, value) in companies { print("\(key) -> \(value)") }
for value in companies.values.array { print("\(value)") }
if let airportName = airports["DUB"] { print("The name of the airport is \(airportName).") } else { print("That airport is not in the airports dictionary.") }
var url : String = "http: var request : NSMutableURLRequest = NSMutableURLRequest() request.URL = NSURL(string: url) request.HTTPMethod = "GET" NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue(), completionHandler:{ (response:NSURLResponse!, data: NSData!, error: NSError!) -> Void in var error: AutoreleasingUnsafeMutablePointer<NSError?> = nil let jsonResult: NSDictionary! = NSJSONSerialization.JSONObjectWithData(data, options:NSJSONReadingOptions.MutableContainers, error: error) as? NSDictionary if (jsonResult != nil) { } else { } })
let url = "YOUR_URL" NSURLSession.sharedSession().dataTaskWithURL(NSURL(string: url)) { data, response, error in }.resume()
For GET Request let configuration = NSURLSessionConfiguration .defaultSessionConfiguration() let session = NSURLSession(configuration: configuration) let urlString = NSString(format: "your URL here") print("get wallet balance url string is \(urlString)") let request : NSMutableURLRequest = NSMutableURLRequest() request.URL = NSURL(string: NSString(format: "%@", urlString) as String) request.HTTPMethod = "GET" request.timeoutInterval = 30 request.addValue("application/json", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") let dataTask = session.dataTaskWithRequest(request) { (let data: NSData?, let response: NSURLResponse?, let error: NSError?) -> Void in guard let httpResponse = response as? NSHTTPURLResponse, receivedData = data else { print("error: not a valid http response") return } switch (httpResponse.statusCode) { case 200: let response = NSString (data: receivedData, encoding: NSUTF8StringEncoding) print("response is \(response)") do { let getResponse = try NSJSONSerialization.JSONObjectWithData(receivedData, options: .AllowFragments) EZLoadingActivity .hide() } catch { print("error serializing JSON: \(error)") } break case 400: break default: print("wallet GET request got response \(httpResponse.statusCode)") } } dataTask.resume()
let configuration = NSURLSessionConfiguration .defaultSessionConfiguration() let session = NSURLSession(configuration: configuration) let params = ["username":bindings .objectForKey("username"), "provider":"walkingcoin", "securityQuestion":securityQuestionField.text!, "securityAnswer":securityAnswerField.text!] as Dictionary<String, AnyObject> let urlString = NSString(format: ‚Äúyour URL‚Äù); print("url string is \(urlString)") let request : NSMutableURLRequest = NSMutableURLRequest() request.URL = NSURL(string: NSString(format: "%@", urlString)as String) request.HTTPMethod = "POST" request.timeoutInterval = 30 request.addValue("application/json", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") request.HTTPBody = try! NSJSONSerialization.dataWithJSONObject(params, options: []) let dataTask = session.dataTaskWithRequest(request) { (let data: NSData?, let response: NSURLResponse?, let error: NSError?) -> Void in guard let httpResponse = response as? NSHTTPURLResponse, receivedData = data else { print("error: not a valid http response") return } switch (httpResponse.statusCode) { case 200: let response = NSString (data: receivedData, encoding: NSUTF8StringEncoding) if response == "SUCCESS" { } default: print("save profile POST request got response \(httpResponse.statusCode)") } } dataTask.resume()
let url = NSURL(string: "http: let task = NSURLSession.sharedSession().dataTaskWithURL(url!) {(data, response, error) in print(NSString(data: data!, encoding: NSUTF8StringEncoding)) } task.resume()
let params = ["username":"john", "password":"123456"] as Dictionary<String, String> var request = URLRequest(url: URL(string: "http: request.httpMethod = "POST" request.httpBody = try? JSONSerialization.data(withJSONObject: params, options: []) request.addValue("application/json", forHTTPHeaderField: "Content-Type") let session = URLSession.shared let task = session.dataTask(with: request, completionHandler: { data, response, error -> Void in print(response!) do { let json = try JSONSerialization.jsonObject(with: data!) as! Dictionary<String, AnyObject> print(json) } catch { print("error") } }) task.resume()
var request = URLRequest(url: URL(string: "http: request.httpMethod = "GET" URLSession.shared.dataTask(with: request, completionHandler: { data, response, error -> Void in do { let jsonDecoder = JSONDecoder() let responseModel = try jsonDecoder.decode(CustomDtoClass.self, from: data!) print(responseModel) } catch { print("JSON Serialization error") } }).resume()
let request = NSMutableURLRequest(url: NSURL(string: "http: let session = URLSession.shared request.httpMethod = "GET" request.addValue("application/json", forHTTPHeaderField: "Content-Type") request.addValue("application/json", forHTTPHeaderField: "Accept") let task = session.dataTask(with: request as URLRequest, completionHandler: {data, response, error -> Void in if error != nil { print("Error: \(String(describing: error))") } else { print("Response: \(String(describing: response))") } }) task.resume()
import UIKit class ViewController: UIViewController { @IBOutlet var usernameTextField: UITextField! @IBOutlet var passwordTextField: UITextField! var usertypeStr :String = "-----------" var loginDictionary : NSDictionary? override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } @IBAction func loginButtonClicked(_ sender: Any) { WebServices.userLogin(userName: usernameTextField.text!, password: passwordTextField.text!,userType: usertypeStr) {(result, message, status )in if status { let loginDetails = result as? WebServices self.loginDictionary = loginDetails?.loginData if self.loginDictionary?["status"] as? String == "error" { self.alertMessage(alerttitle: "Login Error", (self.loginDictionary?["message"] as? String)!) } else if self.loginDictionary?["status"] as? String == "ok" { self.alertMessage(alerttitle: "", "Success") }else { self.alertMessage(alerttitle: "", (self.loginDictionary?["message"] as? String)!) } } else { self.alertMessage(alerttitle: "", "Sorry") } } } func alertMessage(alerttitle:String,_ message : String){ let alertViewController = UIAlertController(title:alerttitle, message:message, preferredStyle: .alert) alertViewController.addAction(UIAlertAction(title: "OK", style: .default, handler: nil)) present(alertViewController, animated: true, completion: nil) } }
import Foundation import Alamofire class WebServices: NSObject { enum WebServiceNames: String { case baseUrl = "https: case UserLogin = "------------" } var loginData : NSDictionary? class func userLogin(userName: String,password : String,userType : String, completion : @escaping (_ response : AnyObject?, _ message: String?, _ success : Bool)-> ()) { let url = WebServiceNames.baseUrl.rawValue + WebServiceNames.UserLogin.rawValue let params = ["USER": userName,"PASS":password,"API_Key" : userType] WebServices.postWebService(urlString: url, params: params as [String : AnyObject]) { (response, message, status) in print(response ?? "Error") let result = WebServices() if let data = response as? NSDictionary { print(data) result.loginData = data completion(result, "Success", true) }else { completion("" as AnyObject?, "Failed", false) } } } class func postWebService(urlString: String, params: [String : AnyObject], completion : @escaping (_ response : AnyObject?, _ message: String?, _ success : Bool)-> Void) { alamofireFunction(urlString: urlString, method: .post, paramters: params) { (response, message, success) in if response != nil { completion(response as AnyObject?, "", true) }else{ completion(nil, "", false) } } } class func alamofireFunction(urlString : String, method : Alamofire.HTTPMethod, paramters : [String : AnyObject], completion : @escaping (_ response : AnyObject?, _ message: String?, _ success : Bool)-> Void){ if method == Alamofire.HTTPMethod.post { Alamofire.request(urlString, method: .post, parameters: paramters, encoding: URLEncoding.default, headers: nil).responseJSON { (response:DataResponse<Any>) in print(urlString) if response.result.isSuccess{ completion(response.result.value as AnyObject?, "", true) }else{ completion(nil, "", false) } } }else { Alamofire.request(urlString).responseJSON { (response) in if response.result.isSuccess{ completion(response.result.value as AnyObject?, "", true) }else{ completion(nil, "", false) } } } } class func cancelAllRequests() { Alamofire.SessionManager.default.session.getTasksWithCompletionHandler { dataTasks, uploadTasks, downloadTasks in dataTasks.forEach { $0.cancel() } uploadTasks.forEach { $0.cancel() } downloadTasks.forEach { $0.cancel() } } } }
let todoEndpoint: String = "https: guard let url = URL(string: todoEndpoint) else { print("Error: cannot create URL") return } let urlRequest = URLRequest(url: url) let task = session.dataTask(with: urlRequest) { (data, response, error) in guard error == nil else { print("error calling GET on /todos/1") print(error!) return } guard let responseData = data else { print("Error: did not receive data") return } do { guard let todo = try JSONSerialization.jsonObject(with: responseData, options: []) as? [String: Any] else { print("error trying to convert data to JSON") return } print("The todo is: " + todo.description) guard let todoTitle = todo["title"] as? String else { print("Could not get todo title from JSON") return } print("The title is: " + todoTitle) } catch { print("error trying to convert data to JSON") return } } task.resume()
import Foundation import Alamofire typealias JSON = [String:Any] class networkingService{ static let shared = networkingService() private init() {} func getPeople(success successblock: @escaping (GetPeopleResponse) -> Void) { Alamofire.request("https: guard let json = response.result.value as? JSON else {return} do { let getPeopleResponse = try GetPeopleResponse(json: json) successblock(getPeopleResponse) }catch{} } } func getHomeWorld(homeWorldLink:String,completion: @escaping(String) ->Void){ Alamofire.request(homeWorldLink).responseJSON {(response) in guard let json = response.result.value as? JSON, let name = json["name"] as? String else{return} completion(name) } } }
import Foundation enum networkingError : Error{ case badNetworkigStuff }
import Foundation struct Person { private let homeWorldLink : String let birthyear : String let gender : String let haircolor : String let eyecolor : String let height : String let mass : String let name : String let skincolor : String init?(json : JSON) { guard let birthyear = json["birth_year"] as? String, let eyecolor = json["eye_color"] as? String, let gender = json["gender"] as? String, let haircolor = json["hair_color"] as? String, let height = json["height"] as? String, let homeWorldLink = json["homeworld"] as? String, let mass = json["mass"] as? String, let name = json["name"] as? String, let skincolor = json["skin_color"] as? String else { return nil } self.homeWorldLink = homeWorldLink self.birthyear = birthyear self.gender = gender self.haircolor = haircolor self.eyecolor = eyecolor self.height = height self.mass = mass self.name = name self.skincolor = skincolor } func homeWorld(_ completion: @escaping (String) -> Void) { networkingService.shared.getHomeWorld(homeWorldLink: homeWorldLink){ (homeWorld) in completion(homeWorld) } } }
import UIKit class DetailVC: UIViewController { var person :Person! @IBOutlet var name: UILabel! @IBOutlet var birthyear: UILabel! @IBOutlet var homeworld: UILabel! @IBOutlet var eyeColor: UILabel! @IBOutlet var skinColor: UILabel! @IBOutlet var gender: UILabel! @IBOutlet var hairColor: UILabel! @IBOutlet var mass: UILabel! @IBOutlet var height: UILabel! override func viewDidLoad() { super.viewDidLoad() print(person) name.text = person.name birthyear.text = person.birthyear eyeColor.text = person.eyecolor gender.text = person.gender hairColor.text = person.haircolor mass.text = person.mass height.text = person.height skinColor.text = person.skincolor person.homeWorld{(homeWorld) in self.homeworld.text = homeWorld } } }
import Foundation struct GetPeopleResponse { let people : [Person] init(json :JSON) throws { guard let results = json["results"] as? [JSON] else { throw networkingError.badNetworkigStuff} let people = results.map{Person(json: $0)}.flatMap{ $0 } self.people = people } }
import UIKit class ViewController: UIViewController { @IBOutlet var tableVieww: UITableView! var people = [Person]() @IBAction func getAction(_ sender: Any) { print("GET") networkingService.shared.getPeople{ response in self.people = response.people self.tableVieww.reloadData() } } override func prepare(for segue: UIStoryboardSegue, sender: Any?) { guard segue.identifier == "peopleToDetails", let detailVC = segue.destination as? DetailVC, let person = sender as AnyObject as? Person else {return} detailVC.person = person } } extension ViewController:UITableViewDataSource{ func numberOfSections(in tableView: UITableView) -> Int { return 1 } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return people.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell = UITableViewCell() cell.textLabel?.text = people[indexPath.row].name return cell } } extension ViewController:UITableViewDelegate{ func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { performSegue(withIdentifier: "peopleToDetails", sender: people[indexPath.row]) } }
let urlString = "http: let url = URL(string: urlString) var request = URLRequest(url: url!) request.httpMethod = "GET" URLSession.shared.dataTask(with:request) { (data, response, error) in if error != nil { print(error) } else { do { let parsedDictionaryArray = try JSONSerialization.jsonObject(with: data!) as! [String:AnyObject] print(parsedDictionaryArray) if let arry = parsedDictionaryArray["data"] as? [[String:AnyObject]] { for dic in arry { let name = dic["name"] let descriptionData = dic["description"] self.modelReference.append(model(name: name as! String, descriptionStr: descriptionData as! String)) print(name!) } } } catch let error as NSError { print(error) } } }.resume()
import Foundation class model : NSObject{ var name : String var descriptionStr: String init(name : String, descriptionStr: String) { self.name = name self.descriptionStr = descriptionStr }
let cell = tableView.dequeueReusableCell(withIdentifier: "TableViewCellID")as! TableViewCell cell.listName.text = modelReference[indexPath.row].name
import UIKit struct RequestType { static let POST = "POST" static let GET = "GET" } enum HtttpType: String { case POST = "POST" case GET = "GET" } class APIManager: NSObject { static let sharedInstance: APIManager = { let instance = APIManager() return instance }() public func requestApiWithDictParam(dictParam: Dictionary<String,Any>, apiName: String,requestType: String, isAddCookie: Bool, completionHendler:@escaping (_ response:Dictionary<String,AnyObject>?, _ error: NSError?, _ success: Bool)-> Void) { var apiUrl = ‚Äú‚Äù apiUrl = apiUrl.appendingFormat("%@", apiName) let config = URLSessionConfiguration.default let session = URLSession(configuration: config) let url = URL(string: apiUrl)! let HTTPHeaderField_ContentType = "Content-Type" let ContentType_ApplicationJson = "application/json" var request = URLRequest.init(url: url) request.timeoutInterval = 60.0 request.cachePolicy = URLRequest.CachePolicy.reloadIgnoringLocalCacheData request.addValue(ContentType_ApplicationJson, forHTTPHeaderField: HTTPHeaderField_ContentType) request.httpMethod = requestType print(apiUrl) print(dictParam) let dataTask = session.dataTask(with: request) { (data, response, error) in if error != nil { completionHendler(nil, error as NSError?, false) } do { let resultJson = try JSONSerialization.jsonObject(with: data!, options: []) as? [String:AnyObject] print("Request API = ", apiUrl) print("API Response = ",resultJson ?? "") completionHendler(resultJson, nil, true) } catch { completionHendler(nil, error as NSError?, false) } } dataTask.resume() } public func requestApiWithUrlString(param: String, apiName: String,requestType: String, isAddCookie: Bool, completionHendler:@escaping (_ response:Dictionary<String,AnyObject>?, _ error: NSError?, _ success: Bool)-> Void ) { var apiUrl = "" let config = URLSessionConfiguration.default let session = URLSession(configuration: config) var request: URLRequest? if requestType == "GET" { apiUrl = String(format: "%@%@&%@", YourAppBaseUrl,apiName,param) apiUrl = apiUrl.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)! print("URL=",apiUrl) let url = URL(string: apiUrl)! request = URLRequest.init(url: url) request?.httpMethod = "GET" } else { apiUrl = String(format: "%@%@", YourAppBaseUrl,apiName) apiUrl = apiUrl.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)! print("URL=",apiUrl) let bodyParameterData = param.data(using: .utf8) let url = URL(string: apiUrl)! request = URLRequest(url: url) request?.httpBody = bodyParameterData request?.httpMethod = "POST" } request?.timeoutInterval = 60.0 request?.cachePolicy = URLRequest.CachePolicy.reloadIgnoringLocalCacheData request?.httpShouldHandleCookies = true let dataTask = session.dataTask(with: request!) { (data, response, error) in if error != nil { completionHendler(nil, error as NSError?, false) } do { if data != nil { let resultJson = try JSONSerialization.jsonObject(with: data!, options: []) as? [String:AnyObject] print("Request API = ", apiUrl) print("API Response = ",resultJson ?? "") completionHendler(resultJson, nil, true) } else { completionHendler(nil, error as NSError?, false) } } catch { completionHendler(nil, error as NSError?, false) } } dataTask.resume() } } let bodyParameters = String(format: "appid=%@&appversion=%@","1","1") APIManager.sharedInstance.requestApiWithUrlString(param: bodyParameters, apiName: "PASS_API_NAME", requestType: HtttpType.POST.rawValue, isAddCookie: false) { (dictResponse, error, success) in if success { if let dictMessage = dictResponse?["message"] as? Dictionary<String, AnyObject> { } } else { print("Something went wrong...") } } } func dataRequest() { let urlToRequest = "" let url = URL(string: urlToRequest)! let session4 = URLSession.shared let request = NSMutableURLRequest(url: url) request.httpMethod = "POST" request.cachePolicy = NSURLRequest.CachePolicy.reloadIgnoringCacheData let paramString = "data=Hello" request.httpBody = paramString.data(using: String.Encoding.utf8) let task = session4.dataTask(with: request as URLRequest) { (data, response, error) in guard let _: Data = data, let _: URLResponse = response, error == nil else { print("*****error") return } if let dataString = NSString(data: data!, encoding: String.Encoding.utf8.rawValue) { print("****Data: \(dataString)") } } task.resume() }
let headers = [ "cache-control": "no-cache", "postman-token": "6f8a-12c6-87a1-ac0f25d6385a" ] let request = NSMutableURLRequest(url: NSURL(string: "Your url string")! as URL, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 10.0) request.httpMethod = "GET" request.allHTTPHeaderFields = headers let session = URLSession.shared let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in if error == nil && data != nil { do { let json = try JSONSerialization.jsonObject(with: data!, options: JSONSerialization.ReadingOptions.mutableContainers) as! [String:AnyObject] print(json) } catch { } } else if error != nil { } }).resume() }
func multiply(factor1:Int, factor2:Int) -> Int{ return factor1 * factor2 }
var multResult = calculator.multiply(9834, factor2: 2321)
func multiply1(f1: Double, f2: Double) -> Double { return f1 * f2 }
func multiply2(f1param f1: Double, return f1 * f2 }
class Calc { func multiply1(f1: Double, f2: Double) -> Double { return f1 * f2 } func multiply2(f1param f1: Double, f2: Double) -> Double { return f1 * f2 } func multiply3(f1: Double, _ f2: Double) -> Double { return f1 * f2 } }
@interface Calc - (double)multiply1:(double)f1 f2:(double)f2; - (double)multiply2WithF1param:(double)f1 f2:(double)f2; - (double)multiply3:(double)f1 :(double)f2; @end
class Calc { init(start: Int) {} init(_ start: String) {} } let c1 = Calc(start: 6) let c2 = Calc("6")
@interface Calc - (instancetype)initWithStart:(NSInteger)start __attribute__((objc_designated_initializer)); - (instancetype)init:(NSString *)start __attribute__((objc_designated_initializer)); @end
typealias FancyFunction = (f1: Double, f2: Double) -> Double
fund doSomethingInteresting(withFunction: FancyFunction) { withFunction(f1: 1.0, f2: 3.0) }
class Calculator { func multiply(factor1:Int, factor2:Int) -> Int{ return factor1 * factor2 } func multiply(factor1:Int, factor2:Int, factor3:Int) -> Int{ return factor1 * factor2 * factor3 } }
func refresh(obj:Obj, _ method: (Obj)->Void = setValue) { method(element) } func setValue(obj:Obj){ obj.value = "someValue" } refresh(someObj,setValue)
Timestamped Event Matching Error: Failed to find matching element
extension XCUIElement { func forceTapElement() { if self.hittable { self.tap() } else { let coordinate: XCUICoordinate = self.coordinateWithNormalizedOffset(CGVectorMake(0.0, 0.0)) coordinate.tap() } } } func testSomethingWithCells() { let app = XCUIApplication() let cells = app.tables.cells sleep(1) cells.elementBoundByIndex(0).forceTapElement() }
XCUIApplication().tables.cells["Camera Roll"].buttons["Camera Roll"].tap()
var label = UILabel(frame:theFrame) label.text = "Foo"
label.font = UIFont(name:"HelveticaNeue-Bold", size: 16.0)
let labelFont = UIFont(name: "HelveticaNeue-Bold", size: 18) let attributes :Dictionary = [NSFontAttributeName : labelFont] var attrString = NSAttributedString(string: "Foo", attributes:attributes) label.attributedText = attrString
for (index, aString: String) in enumerate(array) { array.removeAtIndex(index) }
var a = [1,2,3,4,5,6] for (i,num) in a.enumerate().reverse() { a.removeAtIndex(i) } print(a)
var theStrings = ["foo", "bar", "zxy"] theStrings = theStrings.filter { $0.hasPrefix("b") }
var a = [1,2,3,4,5,6] for (i,num) in a.enumerated().reversed() { a.remove(at: i) } print(a)
var b = ["a", "b", "c", "d", "e", "f"] for (i,str) in b.enumerated().reversed() { if str == "c" { b.remove(at: i) } } print(b)
var c = ["a", "b", "c", "d", "e", "f"] c.removeAll(where: {$0 == "c"}) print(c)
for var index = array.count - 1; index >= 0; --index { if condition { array.removeAtIndex(index) } }
Alamofire.request(.POST, "http: (convertible, params) in var mutableRequest = convertible.URLRequest.copy() as NSMutableURLRequest mutableRequest.HTTPBody = "myBodyString".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) return (mutableRequest, nil) }))
extension String: ParameterEncoding { public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest { var request = try urlRequest.asURLRequest() request.httpBody = data(using: .utf8, allowLossyConversion: false) return request } } Alamofire.request("http:
var request = URLRequest(url: URL(string: url)!) request.httpMethod = HTTPMethod.post.rawValue request.setValue("application/json", forHTTPHeaderField: "Content-Type") let pjson = attendences.toJSONString(prettyPrint: false) let data = (pjson?.data(using: .utf8))! as Data request.httpBody = data Alamofire.request(request).responseJSON { (response) in print(response) }
var url = "http: let _headers : HTTPHeaders = ["Content-Type":"application/x-www-form-urlencoded"] let params : Parameters = ["grant_type":"password","username":"mail","password":"pass"] let url = NSURL(string:"url" as String) request(url, method: .post, parameters: params, encoding: URLEncoding.httpBody , headers: _headers).responseJSON(completionHandler: { response in response let jsonResponse = response.result.value as! NSDictionary if jsonResponse["access_token"] != nil { access_token = String(describing: jsonResponse["accesstoken"]!) } })
extension Alamofire.Manager { public class func request( method: Alamofire.Method, _ URLString: URLStringConvertible, bodyObject: EVObject) -> Request { return Manager.sharedInstance.request( method, URLString, parameters: [:], encoding: .Custom({ (convertible, params) in let mutableRequest = convertible.URLRequest.copy() as! NSMutableURLRequest mutableRequest.HTTPBody = bodyObject.toJsonString().dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) return (mutableRequest, nil) }) ) } }
Alamofire.Manager.request(.POST, endpointUrlString, bodyObject: myObjectToPost)
return Alamofire.request(.POST, "http: (convertible, params) in let mutableRequest = convertible.URLRequest.copy() as! NSMutableURLRequest let data = ("myBodyString" as NSString).dataUsingEncoding(NSUTF8StringEncoding) mutableRequest.HTTPBody = data return (mutableRequest, nil) }))
func paramsFromJSON(json: String) -> [String : AnyObject]? { let objectData: NSData = (json.dataUsingEncoding(NSUTF8StringEncoding))! var jsonDict: [ String : AnyObject]! do { jsonDict = try NSJSONSerialization.JSONObjectWithData(objectData, options: .MutableContainers) as! [ String : AnyObject] return jsonDict } catch { print("JSON serialization failed: \(error)") return nil } } let json = Mapper().toJSONString(loginJSON, prettyPrint: false) Alamofire.request(.POST, url + "/login", parameters: paramsFromJSON(json!), encoding: .JSON)
struct JSONStringArrayEncoding: ParameterEncoding { private let myString: String init(string: String) { self.myString = string } func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest { var urlRequest = urlRequest.urlRequest let data = myString.data(using: .utf8)! if urlRequest?.value(forHTTPHeaderField: "Content-Type") == nil { urlRequest?.setValue("application/json", forHTTPHeaderField: "Content-Type") } urlRequest?.httpBody = data return urlRequest! }}
Alamofire.request("your url string", method: .post, parameters: [:], encoding: JSONStringArrayEncoding.init(string: "My string for body"), headers: [:])
func defineOriginalLanguage(ofText: String) { let text = ofText let stringURL = basicURL + "identify?version=2018-05-01" let url = URL(string: stringURL) var request = URLRequest(url: url!) request.httpMethod = HTTPMethod.post.rawValue request.setValue("text/plain", forHTTPHeaderField: "Content-Type") request.httpBody = text.data(using: .utf8) Alamofire.request(request) .responseJSON { response in print(response) } }
let params:NSMutableDictionary? = ["foo": "bar"]; let ulr = NSURL(string:"http: let request = NSMutableURLRequest(url: ulr! as URL) request.httpMethod = "POST" request.setValue("application/json", forHTTPHeaderField: "Content-Type") let data = try! JSONSerialization.data(withJSONObject: params!, options: JSONSerialization.WritingOptions.prettyPrinted) let json = NSString(data: data, encoding: String.Encoding.utf8.rawValue) if let json = json { print(json) } request.httpBody = json!.data(using: String.Encoding.utf8.rawValue); Alamofire.request(request as! URLRequestConvertible) .responseJSON { response in print(response.request) print(response.response) print(response.data) print(response.result) }
func GetAllBusiness() { Alamofire.request(.GET, "http: println(string) } }
struct Business { var Id : Int = 0 var Name = "" var Latitude = "" var Longitude = "" var Address = "" }
[ { "Id": 1, "Name": "A", "Latitude": "-35.243256", "Longitude": "149.110701", "Address": null }, { "Id": 2, "Name": "B", "Latitude": "-35.240592", "Longitude": "149.104843", "Address": null } ... ]
var list:Array<Business> = [] struct Business { var id : Int = 0 var name = "" } var jsonStringAsArray = "[\n" + "{\n" + "\"id\":72,\n" + "\"name\":\"Batata Cremosa\",\n" + "},\n" + "{\n" + "\"id\":183,\n" + "\"name\":\"Caldeirada de Peixes\",\n" + "},\n" + "{\n" + "\"id\":76,\n" + "\"name\":\"Batata com Cebola e Ervas\",\n" + "},\n" + "{\n" + "\"id\":56,\n" + "\"name\":\"Arroz de forma\",\n" + "}]" var data: NSData = jsonStringAsArray.dataUsingEncoding(NSUTF8StringEncoding)! var error: NSError? let anyObj: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(0), error: &error) println("Error: \(error)") list = self.parseJson(anyObj!) func parseJson(anyObj:AnyObject) -> Array<Business>{ var list:Array<Business> = [] if anyObj is Array<AnyObject> { var b:Business = Business() for json in anyObj as Array<AnyObject>{ b.name = (json["name"] as AnyObject? as? String) ?? "" b.id = (json["id"] as AnyObject? as? Int) ?? 0 list.append(b) } } return list }
b.name = (json["name"] as AnyObject? as? String) ?? "" b.id = (json["id"] as AnyObject? as? Int) ?? 0
extension String { func toJSON() -> Any? { guard let data = self.data(using: .utf8, allowLossyConversion: false) else { return nil } return try? JSONSerialization.jsonObject(with: data, options: .mutableContainers) } }
let dict = myString.toJSON() as? [String:AnyObject]
extension String { var parseJSONString: AnyObject? { let data = self.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) if let jsonData = data { return NSJSONSerialization.JSONObjectWithData(jsonData, options: NSJSONReadingOptions.MutableContainers, error: nil) } else { return nil } } }
var jsonString = "[\n" + "{\n" + "\"id\":72,\n" + "\"name\":\"Batata Cremosa\",\n" + "},\n" + "{\n" + "\"id\":183,\n" + "\"name\":\"Caldeirada de Peixes\",\n" + "},\n" + "{\n" + "\"id\":76,\n" + "\"name\":\"Batata com Cebola e Ervas\",\n" + "},\n" + "{\n" + "\"id\":56,\n" + "\"name\":\"Arroz de forma\",\n" + "}]" let json: AnyObject? = jsonString.parseJSONString println("Parsed JSON: \(json!)") println("json[3]: \(json![3])") /* Output: Parsed JSON: ( { id = 72; name = "Batata Cremosa"; }, { id = 183; name = "Caldeirada de Peixes"; }, { id = 76; name = "Batata com Cebola e Ervas"; }, { id = 56; name = "Arroz de forma"; } ) json[3]: { id = 56; name = "Arroz de forma"; } */
class Business: Deserializable { var id: Int? var name = "N/A" required init(data: [String: AnyObject]) { id <-- data["id"] name <-- data["name"] } } var businesses: [Business]() Alamofire.request(.GET, "http: businesses <-- string }
func getAllBusinesses() { Alamofire.request(.GET, "http: var businesses: [Business]? businesses <-- data if businesses == nil { } else { } } }
class Business: Deserializable { var id: Int? var name = "N/A" required init(data: [String: AnyObject]) { id <-- data["id"] name <-- data["name"] } }
import UIKit extension String { var parseJSONString: AnyObject? { let data = self.data(using: String.Encoding.utf8, allowLossyConversion: false) if let jsonData = data { do { let message = try JSONSerialization.jsonObject(with: jsonData, options:.mutableContainers) if let jsonResult = message as? NSMutableArray { print(jsonResult) return jsonResult } else { return nil } } catch let error as NSError { print("An error occurred: \(error)") return nil } } else { return nil } } }
var jsonString = "[\n" + "{\n" + "\"id\":72,\n" + "\"name\":\"Batata Cremosa\",\n" + "},\n" + "{\n" + "\"id\":183,\n" + "\"name\":\"Caldeirada de Peixes\",\n" + "},\n" + "{\n" + "\"id\":76,\n" + "\"name\":\"Batata com Cebola e Ervas\",\n" + "},\n" + "{\n" + "\"id\":56,\n" + "\"name\":\"Arroz de forma\",\n" + "}]" let json: AnyObject? = jsonString.parseJSONString print("Parsed JSON: \(json!)") print("json[2]: \(json![2])")
struct Business: Codable { let id: Int let name: String }
let parsedData = decoder.decode([Business].self, from: data)
import Foundation struct Business: Codable { let id: Int let name: String } let originalObjects = [Business(id: 0, name: "A"), Business(id: 1, name: "B")] let encoder = JSONEncoder() let data = try! encoder.encode(originalObjects) let decoder = JSONDecoder() let parsedData = try! decoder.decode([Business].self, from: data)
Alamofire.request("http: if let data = response.data { if let categories = [Category].from(data: response.data) { self.categories = categories self.categoryCollectionView.reloadData() } else { print("Casting error") } } else { print("Data is null") } }
import Gloss struct Category: Decodable { let categoryId: Int? let name: String? let image: String? init?(json: JSON) { self.categoryId = "categoryId" <~~ json self.name = "name" <~~ json self.image = "image" <~~ json } }
let jsonString = "{\"id\":123,\"Name\":\"Munish\"}"
var data: NSData =jsonString.dataUsingEncoding(NSUTF8StringEncoding)! var error: NSError?
var jsonObject: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.allZeros, error: &error) println("Error: \\(error)") let id = (jsonObject as! NSDictionary)["id"] as! Int let name = (jsonObject as! NSDictionary)["name"] as! String println("Id: \\(id)") println("Name: \\(name)")
extension String { var parseJSONString: AnyObject? { let data = self.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) if let jsonData = data { do { let message = try NSJSONSerialization.JSONObjectWithData(jsonData, options:.MutableContainers) if let jsonResult = message as? NSMutableArray { return jsonResult } else if let jsonResult = message as? NSMutableDictionary { return jsonResult } else { return nil } } catch let error as NSError { print("An error occurred: \(error)") return nil } } else { return nil } }
struct Business: Codable { var id: Int var name: String } extension String { func parse<D>(to type: D.Type) -> D? where D: Decodable { let data: Data = self.data(using: .utf8)! let decoder = JSONDecoder() do { let _object = try decoder.decode(type, from: data) return _object } catch { return nil } } } var jsonString = "[\n" + "{\n" + "\"id\":72,\n" + "\"name\":\"Batata Cremosa\",\n" + "},\n" + "{\n" + "\"id\":183,\n" + "\"name\":\"Caldeirada de Peixes\",\n" + "},\n" + "{\n" + "\"id\":76,\n" + "\"name\":\"Batata com Cebola e Ervas\",\n" + "},\n" + "{\n" + "\"id\":56,\n" + "\"name\":\"Arroz de forma\",\n" + "}]" let businesses = jsonString.parse(to: [Business].self)
import Foundation typealias Sample = OtherSample struct OtherSample: Codable { let message: String } extension OtherSample { static func from(json: String, using encoding: String.Encoding = .utf8) -> OtherSample? { guard let data = json.data(using: encoding) else { return nil } return OtherSample.from(data: data) } static func from(data: Data) -> OtherSample? { let decoder = JSONDecoder() return try? decoder.decode(OtherSample.self, from: data) } var jsonData: Data? { let encoder = JSONEncoder() return try? encoder.encode(self) } var jsonString: String? { guard let data = self.jsonData else { return nil } return String(data: data, encoding: .utf8) } } extension OtherSample { enum CodingKeys: String, CodingKey { case message } }
if let path : String = Bundle.main.path(forResource: "tiles", ofType: "json") { if let data = NSData(contentsOfFile: path) { let optData = try? JSON(data: data as Data) guard let json = optData else { return } for (_, object) in json { let name = object["name"].stringValue print(name) } } }
typealias CustomType = String var customString:CustomType = "Test String"
typealias voidInputVoidReturnBlock = () -> Void var blockVariable :voidInputVoidReturnBlock = { println(" this is a block that has no input param and with void return") }
typealias completionBlockType = (NSString, NSError!) ->Void var test:completionBlockType = {(string:NSString, error:NSError!) ->Void in println("\(string)") } test("helloooooooo test",nil);
import UIKit class ViewController: UIViewController, UINavigationControllerDelegate, UIImagePickerControllerDelegate { @IBOutlet weak var imageView: UIImageView! @IBOutlet weak var filterButton: UIButton! @IBOutlet weak var saveButton: UIButton! let destinationUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first! .appendingPathComponent("filteredImage.png") let imagePicker = UIImagePickerController() let messageFrame = UIView() var activityIndicator = UIActivityIndicatorView() var strLabel = UILabel() let effectView = UIVisualEffectView(effect: UIBlurEffect(style: .dark)) func activityIndicator(_ title: String) { strLabel.removeFromSuperview() activityIndicator.removeFromSuperview() effectView.removeFromSuperview() strLabel = UILabel(frame: CGRect(x: 50, y: 0, width: 160, height: 46)) strLabel.text = title strLabel.font = .systemFont(ofSize: 14, weight: UIFontWeightMedium) strLabel.textColor = UIColor(white: 0.9, alpha: 0.7) effectView.frame = CGRect(x: view.frame.midX - strLabel.frame.width/2, y: view.frame.midY - strLabel.frame.height/2 , width: 160, height: 46) effectView.layer.cornerRadius = 15 effectView.layer.masksToBounds = true activityIndicator = UIActivityIndicatorView(activityIndicatorStyle: .white) activityIndicator.frame = CGRect(x: 0, y: 0, width: 46, height: 46) activityIndicator.startAnimating() effectView.addSubview(activityIndicator) effectView.addSubview(strLabel) view.addSubview(effectView) } func saveImage() { do { try imageView.image?.data?.write(to: destinationUrl, options: .atomic) print("file saved") } catch { print(error) } } func applyFilterToImage() { imageView.image = imageView.image?.applying(contrast: 1.5) } override func viewDidLoad() { super.viewDidLoad() guard let url = URL(string: "https: view.backgroundColor = UIColor(white: 0, alpha: 1) imageView.image = image } @IBAction func startSavingImage(_ sender: AnyObject) { saveButton.isEnabled = false filterButton.isEnabled = false activityIndicator("Saving Image") DispatchQueue.main.async { self.saveImage() DispatchQueue.main.async { self.effectView.removeFromSuperview() self.saveButton.isEnabled = true self.filterButton.isEnabled = true } } } @IBAction func filterAction(_ sender: AnyObject) { filterButton.isEnabled = false saveButton.isEnabled = false activityIndicator("Applying Filter") DispatchQueue.main.async { self.applyFilterToImage() DispatchQueue.main.async { self.effectView.removeFromSuperview() self.filterButton.isEnabled = true self.saveButton.isEnabled = true } } } @IBAction func cameraAction(_ sender: AnyObject) { if UIImagePickerController.isSourceTypeAvailable(.camera) { imagePicker.delegate = self imagePicker.sourceType = .camera present(imagePicker, animated: true) } } func imagePickerController(_ picker: UIImagePickerController, didFinishPickingImage image: UIImage!, editingInfo: [AnyHashable: Any]!) { dismiss(animated: true, completion: nil) imageView.image = image } } extension Data { var image: UIImage? { return UIImage(data: self) } } extension UIImage { var data: Data? { return UIImagePNGRepresentation(self) } func applying(contrast value: NSNumber) -> UIImage? { guard let ciImage = CIImage(image: self)?.applyingFilter("CIColorControls", withInputParameters: [kCIInputContrastKey: value]) else { return nil } UIGraphicsBeginImageContextWithOptions(size, false, scale) defer { UIGraphicsEndImageContext() } UIImage(ciImage: ciImage).draw(in: CGRect(origin: .zero, size: size)) return UIGraphicsGetImageFromCurrentImageContext() } }
func activityIndicator(_ title: String) { strLabel.removeFromSuperview() activityIndicator.removeFromSuperview() effectView.removeFromSuperview() strLabel = UILabel(frame: CGRect(x: 50, y: 0, width: 160, height: 46)) strLabel.text = title strLabel.font = .systemFont(ofSize: 14, weight: .medium) strLabel.textColor = UIColor(white: 0.9, alpha: 0.7) effectView.frame = CGRect(x: view.frame.midX - strLabel.frame.width/2, y: view.frame.midY - strLabel.frame.height/2 , width: 160, height: 46) effectView.layer.cornerRadius = 15 effectView.layer.masksToBounds = true activityIndicator = UIActivityIndicatorView(activityIndicatorStyle: .white) activityIndicator.frame = CGRect(x: 0, y: 0, width: 46, height: 46) activityIndicator.startAnimating() effectView.contentView.addSubview(activityIndicator) effectView.contentView.addSubview(strLabel) view.addSubview(effectView) }
func viewDidLoad() { super.viewDidLoad() let progressHUD = ProgressHUD(text: "Saving Photo") self.view.addSubview(progressHUD) self.view.backgroundColor = UIColor.black }
import UIKit class ProgressHUD: UIVisualEffectView { var text: String? { didSet { label.text = text } } let activityIndictor: UIActivityIndicatorView = UIActivityIndicatorView(activityIndicatorStyle: UIActivityIndicatorViewStyle.gray) let label: UILabel = UILabel() let blurEffect = UIBlurEffect(style: .light) let vibrancyView: UIVisualEffectView init(text: String) { self.text = text self.vibrancyView = UIVisualEffectView(effect: UIVibrancyEffect(blurEffect: blurEffect)) super.init(effect: blurEffect) self.setup() } required init?(coder aDecoder: NSCoder) { self.text = "" self.vibrancyView = UIVisualEffectView(effect: UIVibrancyEffect(blurEffect: blurEffect)) super.init(coder: aDecoder) self.setup() } func setup() { contentView.addSubview(vibrancyView) contentView.addSubview(activityIndictor) contentView.addSubview(label) activityIndictor.startAnimating() } override func didMoveToSuperview() { super.didMoveToSuperview() if let superview = self.superview { let width = superview.frame.size.width / 2.3 let height: CGFloat = 50.0 self.frame = CGRect(x: superview.frame.size.width / 2 - width / 2, y: superview.frame.height / 2 - height / 2, width: width, height: height) vibrancyView.frame = self.bounds let activityIndicatorSize: CGFloat = 40 activityIndictor.frame = CGRect(x: 5, y: height / 2 - activityIndicatorSize / 2, width: activityIndicatorSize, height: activityIndicatorSize) layer.cornerRadius = 8.0 layer.masksToBounds = true label.text = text label.textAlignment = NSTextAlignment.center label.frame = CGRect(x: activityIndicatorSize + 5, y: 0, width: width - activityIndicatorSize - 15, height: height) label.textColor = UIColor.gray label.font = UIFont.boldSystemFont(ofSize: 16) } } func show() { self.isHidden = false } func hide() { self.isHidden = true } }
override func viewDidLoad() { super.viewDidLoad() let progressHUD = ProgressHUD(text: "Saving Photo") self.view.addSubview(progressHUD) self.view.backgroundColor = UIColor.blackColor() }
import UIKit class ProgressHUD: UIVisualEffectView { var text: String? { didSet { label.text = text } } let activityIndictor: UIActivityIndicatorView = UIActivityIndicatorView(activityIndicatorStyle: UIActivityIndicatorViewStyle.White) let label: UILabel = UILabel() let blurEffect = UIBlurEffect(style: .Light) let vibrancyView: UIVisualEffectView init(text: String) { self.text = text self.vibrancyView = UIVisualEffectView(effect: UIVibrancyEffect(forBlurEffect: blurEffect)) super.init(effect: blurEffect) self.setup() } required init(coder aDecoder: NSCoder) { self.text = "" self.vibrancyView = UIVisualEffectView(effect: UIVibrancyEffect(forBlurEffect: blurEffect)) super.init(coder: aDecoder) self.setup() } func setup() { contentView.addSubview(vibrancyView) vibrancyView.contentView.addSubview(activityIndictor) vibrancyView.contentView.addSubview(label) activityIndictor.startAnimating() } override func didMoveToSuperview() { super.didMoveToSuperview() if let superview = self.superview { let width = superview.frame.size.width / 2.3 let height: CGFloat = 50.0 self.frame = CGRectMake(superview.frame.size.width / 2 - width / 2, superview.frame.height / 2 - height / 2, width, height) vibrancyView.frame = self.bounds let activityIndicatorSize: CGFloat = 40 activityIndictor.frame = CGRectMake(5, height / 2 - activityIndicatorSize / 2, activityIndicatorSize, activityIndicatorSize) layer.cornerRadius = 8.0 layer.masksToBounds = true label.text = text label.textAlignment = NSTextAlignment.Center label.frame = CGRectMake(activityIndicatorSize + 5, 0, width - activityIndicatorSize - 15, height) label.textColor = UIColor.grayColor() label.font = UIFont.boldSystemFontOfSize(16) } } func show() { self.hidden = false } func hide() { self.hidden = true } }
var boxView = UIView() override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = UIColor.blackColor() addSavingPhotoView() var button = UIButton(frame: CGRect(x: 20, y: 20, width: 20, height: 20)) button.backgroundColor = UIColor.redColor() button.addTarget(self, action: "buttonAction:", forControlEvents: UIControlEvents.TouchUpInside) view.addSubview(button) } func addSavingPhotoView() { boxView = UIView(frame: CGRect(x: view.frame.midX - 90, y: view.frame.midY - 25, width: 180, height: 50)) boxView.backgroundColor = UIColor.whiteColor() boxView.alpha = 0.8 boxView.layer.cornerRadius = 10 var activityView = UIActivityIndicatorView(activityIndicatorStyle: UIActivityIndicatorViewStyle.Gray) activityView.frame = CGRect(x: 0, y: 0, width: 50, height: 50) activityView.startAnimating() var textLabel = UILabel(frame: CGRect(x: 60, y: 0, width: 200, height: 50)) textLabel.textColor = UIColor.grayColor() textLabel.text = "Saving Photo" boxView.addSubview(activityView) boxView.addSubview(textLabel) view.addSubview(boxView) } func buttonAction(sender:UIButton!) { boxView.removeFromSuperview() }
import UIKit import Foundation class ActivityIndicatorView { var view: UIView! var activityIndicator: UIActivityIndicatorView! var title: String! init(title: String, center: CGPoint, width: CGFloat = 200.0, height: CGFloat = 50.0) { self.title = title let x = center.x - width/2.0 let y = center.y - height/2.0 self.view = UIView(frame: CGRect(x: x, y: y, width: width, height: height)) self.view.backgroundColor = UIColor(red: 255.0/255.0, green: 204.0/255.0, blue: 51.0/255.0, alpha: 0.5) self.view.layer.cornerRadius = 10 self.activityIndicator = UIActivityIndicatorView(frame: CGRect(x: 0, y: 0, width: 50, height: 50)) self.activityIndicator.color = UIColor.blackColor() self.activityIndicator.hidesWhenStopped = false let titleLabel = UILabel(frame: CGRect(x: 60, y: 0, width: 200, height: 50)) titleLabel.text = title titleLabel.textColor = UIColor.blackColor() self.view.addSubview(self.activityIndicator) self.view.addSubview(titleLabel) } func getViewActivityIndicator() -> UIView { return self.view } func startAnimating() { self.activityIndicator.startAnimating() UIApplication.sharedApplication().beginIgnoringInteractionEvents() } func stopAnimating() { self.activityIndicator.stopAnimating() UIApplication.sharedApplication().endIgnoringInteractionEvents() self.view.removeFromSuperview() } }
var activityIndicatorView: ActivityIndicatorView! override func viewDidLoad() { super.viewDidLoad() self.activityIndicatorView = ActivityIndicatorView(title: "Processing...", center: self.view.center) self.view.addSubview(self.activityIndicatorView.getViewActivityIndicator()) } func doSomething() { self.activityIndicatorView.startAnimating() UIApplication.sharedApplication().beginIgnoringInteractionEvents() self.activityIndicatorView.stopAnimating() }
import UIKit import Foundation class ProgressIndicator: UIView { var indicatorColor:UIColor var loadingViewColor:UIColor var loadingMessage:String var messageFrame = UIView() var activityIndicator = UIActivityIndicatorView() init(inview:UIView,loadingViewColor:UIColor,indicatorColor:UIColor,msg:String){ self.indicatorColor = indicatorColor self.loadingViewColor = loadingViewColor self.loadingMessage = msg super.init(frame: CGRectMake(inview.frame.midX - 150, inview.frame.midY - 25 , 300, 50)) initalizeCustomIndicator() } convenience init(inview:UIView) { self.init(inview: inview,loadingViewColor: UIColor.brownColor(),indicatorColor:UIColor.blackColor(), msg: "Loading..") } convenience init(inview:UIView,messsage:String) { self.init(inview: inview,loadingViewColor: UIColor.brownColor(),indicatorColor:UIColor.blackColor(), msg: messsage) } required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } func initalizeCustomIndicator(){ messageFrame.frame = self.bounds activityIndicator = UIActivityIndicatorView(activityIndicatorStyle: UIActivityIndicatorViewStyle.White) activityIndicator.tintColor = indicatorColor activityIndicator.hidesWhenStopped = true activityIndicator.frame = CGRect(x: self.bounds.origin.x + 6, y: 0, width: 20, height: 50) print(activityIndicator.frame) let strLabel = UILabel(frame:CGRect(x: self.bounds.origin.x + 30, y: 0, width: self.bounds.width - (self.bounds.origin.x + 30) , height: 50)) strLabel.text = loadingMessage strLabel.adjustsFontSizeToFitWidth = true strLabel.textColor = UIColor.whiteColor() messageFrame.layer.cornerRadius = 15 messageFrame.backgroundColor = loadingViewColor messageFrame.alpha = 0.8 messageFrame.addSubview(activityIndicator) messageFrame.addSubview(strLabel) } func start(){ if !self.subviews.contains(messageFrame){ activityIndicator.startAnimating() self.addSubview(messageFrame) } } func stop(){ if self.subviews.contains(messageFrame){ activityIndicator.stopAnimating() messageFrame.removeFromSuperview() } } }
var indicator:ProgressIndicator? override func viewDidLoad() { super.viewDidLoad() indicator = ProgressIndicator(inview:self.view,loadingViewColor: UIColor.grayColor(), indicatorColor: UIColor.blackColor(), msg: "Landing within minutes,Please hold tight..") self.view.addSubview(indicator!) } @IBAction func startBtn(sender: AnyObject) { indicator!.start() } @IBAction func stopBtn(sender: AnyObject) { indicator!.stop() }
var view = UIView(frame: CGRect(x: 0, y: 0, width: 300, height: 50)) view.backgroundColor = UIColor.whiteColor() view.layer.cornerRadius = 10
var wait = UIActivityIndicatorView(frame: CGRect(x: 0, y: 0, width: 50, height: 50)) wait.color = UIColor.blackColor() wait.hidesWhenStopped = false var text = UILabel(frame: CGRect(x: 60, y: 0, width: 200, height: 50)) text.text = "Processing..." view.addSubview(wait) view.addSubview(text)
class LoginTVC: UITableViewController { var loadingView : LoadingView! override func viewDidLoad() { super.viewDidLoad() loadingView = LoadingView(uiView: view, message: "Sending you verification code") } @IBAction func showLoadingView(_ sender: UIButton) { if let loaderView = loadingView{ if loaderView.isHidden() { loaderView.show() } } else{ loadingView = LoadingView(uiView: view, message: "Sending you verification code") } } } @IBAction func hideLoadingView(_ sender: UIButton) { if let loaderView = loadingView{ self.loadingView.hide() } } }
class LoadingView { let uiView : UIView let message : String let messageLabel = UILabel() let loadingSV = UIStackView() let loadingView = UIView() let activityIndicator: UIActivityIndicatorView = UIActivityIndicatorView(activityIndicatorStyle: UIActivityIndicatorViewStyle.gray) init(uiView: UIView, message: String) { self.uiView = uiView self.message = message self.setup() } func setup(){ let viewWidth = uiView.bounds.width let viewHeight = uiView.bounds.height messageLabel.text = message messageLabel.textColor = UIColor.darkGray messageLabel.textAlignment = .center messageLabel.numberOfLines = 3 messageLabel.lineBreakMode = .byWordWrapping loadingSV.axis = .vertical loadingSV.distribution = .equalSpacing loadingSV.alignment = .center loadingSV.addArrangedSubview(activityIndicator) loadingSV.addArrangedSubview(messageLabel) loadingView.frame = uiView.frame loadingView.center = uiView.center loadingView.backgroundColor = UIColor.darkGray.withAlphaComponent(0.3) loadingView.clipsToBounds = true loadingSV.translatesAutoresizingMaskIntoConstraints = false loadingView.addSubview(loadingSV) uiView.addSubview(loadingView) activityIndicator.startAnimating() let views = [ "loadingSV": loadingSV ] uiView.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "H:|-[loadingSV(300)]-|", options: [], metrics: nil, views: views)) uiView.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "V:|-\(viewHeight / 3)-[loadingSV(50)]-|", options: [], metrics: nil, views: views)) } func show() { loadingView.isHidden = false } func hide(){ loadingView.isHidden = true } func isHidden() -> Bool{ if loadingView.isHidden == false{ return false } else{ return true } } }
var activityIndicator: UIActivityIndicatorView! var viewActivityIndicator: UIView! override func viewDidLoad() { super.viewDidLoad() let width: CGFloat = 200.0 let height: CGFloat = 50.0 let x = self.view.frame.width/2.0 - width/2.0 let y = self.view.frame.height/2.0 - height/2.0 self.viewActivityIndicator = UIView(frame: CGRect(x: x, y: y, width: width, height: height)) self.viewActivityIndicator.backgroundColor = UIColor(red: 255.0/255.0, green: 204.0/255.0, blue: 51.0/255.0, alpha: 0.5) self.viewActivityIndicator.layer.cornerRadius = 10 self.activityIndicator = UIActivityIndicatorView(frame: CGRect(x: 0, y: 0, width: 50, height: 50)) self.activityIndicator.color = UIColor.blackColor() self.activityIndicator.hidesWhenStopped = false let titleLabel = UILabel(frame: CGRect(x: 60, y: 0, width: 200, height: 50)) titleLabel.text = "Processing..." self.viewActivityIndicator.addSubview(self.activityIndicator) self.viewActivityIndicator.addSubview(titleLabel) self.view.addSubview(self.viewActivityIndicator) } func doSometing() { self.activityIndicator.startAnimating() UIApplication.sharedApplication().beginIgnoringInteractionEvents() self.activityIndicator.stopAnimating() UIApplication.sharedApplication().endIgnoringInteractionEvents() self.viewActivityIndicator.removeFromSuperview() }
class ActivityIndicator: UIVisualEffectView { let activityIndictor: UIActivityIndicatorView = UIActivityIndicatorView(activityIndicatorStyle: UIActivityIndicatorViewStyle.WhiteLarge) let label: UILabel = UILabel() let blurEffect = UIBlurEffect(style: .Dark) let vibrancyView: UIVisualEffectView init() { self.vibrancyView = UIVisualEffectView(effect: UIVibrancyEffect(forBlurEffect: blurEffect)) super.init(effect: blurEffect) self.setup() } required init?(coder aDecoder: NSCoder) { self.vibrancyView = UIVisualEffectView(effect: UIVibrancyEffect(forBlurEffect: blurEffect)) super.init(coder: aDecoder) self.setup() } func setup() { contentView.addSubview(vibrancyView) vibrancyView.contentView.addSubview(activityIndictor) activityIndictor.startAnimating() } override func didMoveToSuperview() { super.didMoveToSuperview() if let superview = self.superview { let width: CGFloat = 75.0 let height: CGFloat = 75.0 self.frame = CGRectMake(superview.frame.size.width / 2 - width / 2, superview.frame.height / 2 - height / 2, width, height) vibrancyView.frame = self.bounds let activityIndicatorSize: CGFloat = 40 activityIndictor.frame = CGRectMake(18, height / 2 - activityIndicatorSize / 2, activityIndicatorSize, activityIndicatorSize) layer.cornerRadius = 8.0 layer.masksToBounds = true } } func show() { self.hidden = false } func hide() { self.hidden = true }}
let activityIndicator = ActivityIndicator() self.view.addSubview(activityIndicator)
let actInd: UIActivityIndicatorView = UIActivityIndicatorView()
actInd.center = ImageView.center actInd.activityIndicatorViewStyle = UIActivityIndicatorViewStyle.WhiteLarge view.addSubview(actInd) actInd.startAnimating()
var activityIndicator = UIActivityIndicatorView() let loadingView = UIView() let loadingLabel = UILabel()
func setLoadingScreen(myMsg : String) { let width: CGFloat = 120 let height: CGFloat = 30 let x = (self.view.frame.width / 2) - (width / 2) let y = (169 / 2) - (height / 2) + 60 loadingView.frame = CGRect(x: x, y: y, width: width, height: height) self.loadingLabel.textColor = UIColor.white self.loadingLabel.textAlignment = NSTextAlignment.center self.loadingLabel.text = myMsg self.loadingLabel.frame = CGRect(x: 0, y: 0, width: 160, height: 30) self.loadingLabel.isHidden = false self.activityIndicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyle.white self.activityIndicator.frame = CGRect(x: 0, y: 0, width: 30, height: 30) self.activityIndicator.startAnimating() loadingView.addSubview(self.spinner) loadingView.addSubview(self.loadingLabel) self.view.addSubview(loadingView) }
@IBAction func start_animation(_ sender: Any) { setLoadingScreen(myMsg: "Loading...") }
@IBAction func stop_animation(_ sender: Any) { self.spinner.stopAnimating() UIApplication.shared.endIgnoringInteractionEvents() self.loadingLabel.isHidden = true }
echo "Start fixing xCode" echo "Closing xCode" osascript -e sleep 2 echo "Clearing DerivedData..." rm -rf "$HOME/Library/Developer/Xcode/DerivedData" sleep 2 echo "Launch xCode again" osascript -e echo "Finish fixing xCode"
let storyboard: UIStoryboard = UIStoryboard(name: "myTabBarName", bundle: nil) let vc: UIViewController = storyboard.instantiateViewControllerWithIdentifier("myVCID") as UIViewController self.presentViewController(vc, animated: true, completion: nil)
let vc = ViewController() self.presentViewController(vc, animated: true, completion: nil)
let vc = self.storyboard?.instantiateViewController(withIdentifier: myVCID) as! myVCName self.present(vc, animated: true, completion: nil)
self.present(viewControllerToPresent, animated: true, completion: nil)
let imagePicker = UIImagePickerController() imagePicker.delegate = self imagePicker.sourceType = UIImagePickerControllerSourceType.camera imagePicker.allowsEditing = false self.present(imagePicker, animated: true, completion: nil)
let vc = self.storyboard?.instantiateViewController(withIdentifier: "idMyViewControllerName") as! MyViewControllerName self.present(vc, animated: true, completion: nil)
var vc = self.storyboard?.instantiateViewControllerWithIdentifier("WelcomeViewController") as! WelcomeViewController var navigationController = UINavigationController(rootViewController: vc) self.presentViewController(navigationController, animated: true, completion: nil)
let secondVC = self.storyboard?.instantiateViewController(withIdentifier: "VC-ID" as! yourViewController let navigationVC = UINavigationController(rootViewController: secondVC) self.present(navigationVC, animated: true, completion: nil)
let vc = self.storyboard?.instantiateViewControllerWithIdentifier("settingsVC") as! SettingsViewController self.presentViewController(vc, animated: true, completion: nil)
self.presentViewController(vc, animated: true, completion: nil)
let vc = ViewController() var navigationController = UINavigationController(rootViewController: vc) self.presentViewController(navigationController, animated: true, completion: nil
var vc = self.storyboard?.instantiateViewControllerWithIdentifier("YourViewController") as! YourViewController; vc.mode_Player = 1 self.presentViewController(vc, animated: true, completion: nil)
if let vc = self.storyboard?.instantiateViewController(withIdentifier: "secondViewController") as? secondViewController { let appDelegate = UIApplication.shared.delegate as! AppDelegate appDelegate.window?.rootViewController = vc }
override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) let yourVC = YourViewController() self.present(yourVC, animated: true, completion: nil) }
myLabel.textColor= [UIColor colorWithRed:160 green:97 blue:5 alpha:1] ;
myLabel.textColor= [UIColor colorWithRed:(160/255.0) green:(97/255.0) blue:(5/255.0) alpha:1] ;
myLabel.textColor = UIColor(red: (160/255.0), green: (97/255.0), blue: (5/255.0), alpha: 1.0)
extension UIColor { convenience init(_ r: Double,_ g: Double,_ b: Double,_ a: Double) { self.init(red: r/255, green: g/255, blue: b/255, alpha: a) } }
myLabel.textColor = [UIColor colorWithRGBA:0xA06105FF];
@interface UIColor (Helper) + (UIColor *)colorWithRGBA:(NSUInteger)color; @end
@implementation UIColor (Helper) + (UIColor *)colorWithRGBA:(NSUInteger)color { return [UIColor colorWithRed:((color >> 24) & 0xFF) / 255.0f green:((color >> 16) & 0xFF) / 255.0f blue:((color >> 8) & 0xFF) / 255.0f alpha:((color) & 0xFF) / 255.0f]; } @end
UIColor *color = [UIColor colorWithRed:(160/255.0) green:(97/255.0) blue:(5/255.0) alpha:1.0];
NSLocalizedString(" - \(count) Notifica", comment: "sottotitolo prescrizione per le notifiche al singolare")
NSLocalizedString("Notifica per \(medicina!) della prescrizione \(prescription!)\nMemo: \(memoTextView.text)", comment: "Messaggio della Local Notification")
let myString = String(format: NSLocalizedString(" - %d Notifica", comment: "sottotitolo prescrizione per le notifiche al singolare"), count)
String.localizedStringWithFormat( NSLocalizedString(" - %d Notifica", comment: "sottotitolo prescrizione per le notifiche al singolare"), count)
extension String { var localized: String { return NSLocalizedString(self, comment:"") } }
self.descriptionView.text = "Description".localized
self.entryTimeLabel.text = "\("Doors-open-at".localized) \(event.eventStartTime)"
extension String:{ func localizeWithFormat(arguments: CVarArg...) -> String{ return String(format: self.localized, arguments: arguments) } var localized: String{ return Bundle.main.localizedString(forKey: self, value: nil, table: "StandardLocalizations") } }
let siriCalendarText = "AnyCalendar" let localizedText = "LTo use Siri with my app, please set %@ as the default list on your device reminders settings".localizeWithFormat(arguments: siriCalendarTitle)
extension String { var localized: String { return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: "") } }
let myValue = 10 let anotherValue = "another value" let localizedStr = "This string is localized: \(myValue) \(anotherValue)".localized print(localizedStr)
enum PostType: Decodable { init(from decoder: Decoder) throws { } case Image enum CodingKeys: String, CodingKey { case image } }
let jsonData = """ { "count": 4 } """.data(using: .utf8)! do { let decoder = JSONDecoder() let response = try decoder.decode(PostType.self, from: jsonData) print(response) } catch { print(error) } } } enum PostType: Int, Codable { case count = 4 }
enum PostType: Decodable { case count(number: Int) }
enum PostType: String, Codable { case image, blob }
enum PostType : Int, Codable { case count = 4 } struct Post : Codable { var type : PostType } let jsonString = "{\"type\": 4}" let jsonData = Data(jsonString.utf8) do { let decoded = try JSONDecoder().decode(Post.self, from: jsonData) print("decoded:", decoded.type) } catch { print(error) }
enum PostType: Codable { case count(number: Int) case title(String) } extension PostType { private enum CodingKeys: String, CodingKey { case count case title } enum PostTypeCodingError: Error { case decoding(String) } init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) if let value = try? values.decode(Int.self, forKey: .count) { self = .count(number: value) return } if let value = try? values.decode(String.self, forKey: .title) { self = .title(value) return } throw PostTypeCodingError.decoding("Whoops! \(dump(values))") } func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: CodingKeys.self) switch self { case .count(let number): try container.encode(number, forKey: .count) case .title(let value): try container.encode(value, forKey: .title) } } }
import Foundation let encoder = JSONEncoder() encoder.outputFormatting = .prettyPrinted let decoder = JSONDecoder() let count = PostType.count(number: 42) let countData = try encoder.encode(count) let countJSON = String.init(data: countData, encoding: .utf8)! print(countJSON) let decodedCount = try decoder.decode(PostType.self, from: countData) let title = PostType.title("Hello, World!") let titleData = try encoder.encode(title) let titleJSON = String.init(data: titleData, encoding: .utf8)! print(titleJSON) let decodedTitle = try decoder.decode(PostType.self, from: titleData)
enum MediaType: Decodable { case audio case multipleChoice case other init(from decoder: Decoder) throws { let label = try decoder.singleValueContainer().decode(String.self) switch label { case "AUDIO": self = .audio case "MULTIPLE_CHOICES": self = .multipleChoice default: self = .other } } }
struct Question { [...] let type: MediaType enum CodingKeys: String, CodingKey { [...] case type = "type" } extension Question: Decodable { init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) [...] type = try container.decode(MediaType.self, forKey: .type) } }
enum MediaType: String, Decodable { case audio = "AUDIO" case multipleChoice = "MULTIPLE_CHOICES" case other init(from decoder: Decoder) throws { let label = try decoder.singleValueContainer().decode(String.self) self = MediaType(rawValue: label) ?? .other } }
protocol EnumDecodable: RawRepresentable, Decodable { static var defaultDecoderValue: Self { get } } extension EnumDecodable where RawValue: Decodable { init(from decoder: Decoder) throws { let value = try decoder.singleValueContainer().decode(RawValue.self) self = Self(rawValue: value) ?? Self.defaultDecoderValue } } enum MediaType: String, EnumDecodable { static let defaultDecoderValue: MediaType = .other case audio = "AUDIO" case multipleChoices = "MULTIPLE_CHOICES" case other }
import Foundation enum PostType: Codable { case count(number: Int) case comment(text: String) init(from decoder: Decoder) throws { self = try PostTypeCodableForm(from: decoder).enumForm() } func encode(to encoder: Encoder) throws { try PostTypeCodableForm(self).encode(to: encoder) } } struct PostTypeCodableForm: Codable { var countNumber: Int? var commentText: String? init(_ enumForm: PostType) { switch enumForm { case .count(let number): countNumber = number case .comment(let text): commentText = text } } func enumForm() throws -> PostType { if let number = countNumber { guard commentText == nil else { throw DecodeError.moreThanOneEnumCase } return .count(number: number) } if let text = commentText { guard countNumber == nil else { throw DecodeError.moreThanOneEnumCase } return .comment(text: text) } throw DecodeError.noRecognizedContent } enum DecodeError: Error { case noRecognizedContent case moreThanOneEnumCase } } let test = PostType.count(number: 3) let data = try JSONEncoder().encode(test) let string = String(data: data, encoding: .utf8)! print(string) let result = try JSONDecoder().decode(PostType.self, from: data) print(result)
enum Direction: String, Decodable { case north, south, east, west } struct DirectionList { let directions: [Direction] } extension DirectionList: Decodable { public init(from decoder: Decoder) throws { var container = try decoder.unkeyedContainer() var directions: [Direction] = [] while !container.isAtEnd { let rawValue = try container.decode(String.self) guard let direction = Direction(rawValue: rawValue) else { continue } directions.append(direction) } self.directions = directions } }
struct DirectionList { typealias ArrayType = [Direction] private let directions: ArrayType } extension DirectionList: Collection { typealias Index = ArrayType.Index typealias Element = ArrayType.Element var startIndex: Index { return directions.startIndex } var endIndex: Index { return directions.endIndex } subscript(index: Index) -> Element { get { return directions[index] } } func index(after i: Index) -> Index { return directions.index(after: i) } }
public init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) guard let key = values.allKeys.first else { throw err("No valid keys in: \(values)") } func dec<T: Decodable>() throws -> T { return try values.decode(T.self, forKey: key) } switch key { case .count: self = try .count(dec()) case .title: self = try .title(dec()) } } func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: CodingKeys.self) switch self { case .count(let x): try container.encode(x, forKey: .count) case .title(let x): try container.encode(x, forKey: .title) } }
let paths = NSSearchPathForDirectoriesInDomains( .DocumentDirectory, .UserDomainMask, true) let documentsDirectory = paths[0] as String var filePath:String? = nil var fileNamePostfix = 0 do { filePath = "\(documentsDirectory)/\(dateTimePrefix)-\(fileNamePostfix++).mp4" } while (NSFileManager.defaultManager().fileExistsAtPath(filePath))
import UIKit @IBDesignable class RandjeUIButton: UIButton { required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) self.backgroundColor = UIColor.blackColor() } }
override init(frame: CGRect) { super.init(frame: frame) }
Bundle.main.path(forResource: "Foo", ofType: "plist")
(lldb) po Bundle.main NSBundle </Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Overlays> (loaded)
let myImage = UIImage(named: String, in: Bundle, compatibleWith: UITraitCollection)
let appBundle = Bundle(for: type(of: self)) let myImage = UIImage(named: "myImage", in: bundle, compatibleWith: self.traitCollection))
import Foundation import WatchConnectivity class BatteryLevel: WCSessionDelegate { var session: WCSession? { didSet { if let session = session { session.delegate = self session.activate() } } } var batteryStatus = 0.0; func getBatteryLevel(){ if WCSession.isSupported() { session = WCSession.default() session!.sendMessage(["getBatteryLevel": ""], replyHandler: { (response) -> Void in if (response["batteryLevel"] as? String) != nil { self.batteryStatus = (response["batteryLevel"] as? Double)! * 100 } }, errorHandler: { (error) -> Void in print(error) }) }} func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) { } func session(_ session: WCSession, didReceiveMessage message: [String : Any]) { } }
while someCondition { if someOtherCondition { switch (someValue) { case 0: case 1: case 2...5: default: break } } else { someCondition = false } }
outerLoop: while someCondition { if someOtherCondition { switch (someValue) { case 0: case 1: break outerLoop case 2...5: default: break } } else { someCondition = false } }
var x = CGFloat(0.5) var test = ceil(x) var test = ceilf(x)
var f: CGFloat = 2.5 var roundedF = CGFloat(ceil(Double(f)))
func rounded(_ rule: FloatingPointRoundingRule) -> Self
import CoreGraphics let value1: CGFloat = -0.4 let value2: CGFloat = -0.5 let value3: CGFloat = -1 let value4: CGFloat = 0.4 let value5: CGFloat = 0.5 let value6: CGFloat = 1 let roundedValue1 = value1.rounded(.up) let roundedValue2 = value2.rounded(.up) let roundedValue3 = value3.rounded(.up) let roundedValue4 = value4.rounded(.up) let roundedValue5 = value5.rounded(.up) let roundedValue6 = value6.rounded(.up) print(roundedValue1) print(roundedValue2) print(roundedValue3) print(roundedValue4) print(roundedValue5) print(roundedValue6)
import CoreGraphics let value1: CGFloat = -0.4 let value2: CGFloat = -0.5 let value3: CGFloat = -1 let value4: CGFloat = 0.4 let value5: CGFloat = 0.5 let value6: CGFloat = 1 let roundedValue1 = ceil(value1) let roundedValue2 = ceil(value2) let roundedValue3 = ceil(value3) let roundedValue4 = ceil(value4) let roundedValue5 = ceil(value5) let roundedValue6 = ceil(value6) print(roundedValue1) print(roundedValue2) print(roundedValue3) print(roundedValue4) print(roundedValue5) print(roundedValue6)
import Foundation import CoreGraphics let value1: CGFloat = -0.4 let value2: CGFloat = -0.5 let value3: CGFloat = -1 let value4: CGFloat = 0.4 let value5: CGFloat = 0.5 let value6: CGFloat = 1 let scale: Int16 = 0 let behavior = NSDecimalNumberHandler(roundingMode: NSDecimalNumber.RoundingMode.up, scale: scale, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow: false, raiseOnDivideByZero: true) let roundedValue1 = NSDecimalNumber(value: Double(value1)).rounding(accordingToBehavior: behavior) let roundedValue2 = NSDecimalNumber(value: Double(value2)).rounding(accordingToBehavior: behavior) let roundedValue3 = NSDecimalNumber(value: Double(value3)).rounding(accordingToBehavior: behavior) let roundedValue4 = NSDecimalNumber(value: Double(value4)).rounding(accordingToBehavior: behavior) let roundedValue5 = NSDecimalNumber(value: Double(value5)).rounding(accordingToBehavior: behavior) let roundedValue6 = NSDecimalNumber(value: Double(value6)).rounding(accordingToBehavior: behavior) print(roundedValue1) print(roundedValue2) print(roundedValue3) print(roundedValue4) print(roundedValue5) print(roundedValue6)
import Foundation import CoreGraphics let value1: CGFloat = -0.4 let value2: CGFloat = -0.5 let value3: CGFloat = -1 let value4: CGFloat = 0.4 let value5: CGFloat = 0.5 let value6: CGFloat = 1 let formatter = NumberFormatter() formatter.numberStyle = NumberFormatter.Style.decimal formatter.roundingMode = NumberFormatter.RoundingMode.ceiling formatter.maximumFractionDigits = 0 let roundedValue1 = formatter.string(for: value1) let roundedValue2 = formatter.string(for: value2) let roundedValue3 = formatter.string(for: value3) let roundedValue4 = formatter.string(for: value4) let roundedValue5 = formatter.string(for: value5) let roundedValue6 = formatter.string(for: value6) print(String(describing: roundedValue1)) print(String(describing: roundedValue2)) print(String(describing: roundedValue3)) print(String(describing: roundedValue4)) print(String(describing: roundedValue5)) print(String(describing: roundedValue6))
func accurateRound(value: Double) -> Int { var d : Double = value - Double(Int(value)) if d < 0.5 { return Int(value) } else { return Int(value) + 1 } }
extension Float { func roundToInt() -> Int{ var value = Int(self) var f = self - Float(value) if f < 0.5{ return value } else { return value + 1 } } }
... import UIKit import CoreData @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { ...
import Foundation class FLApplication: UIApplication { override func sendEvent(event: UIEvent!) { println("Entry Point") } }
import Foundation class Blog : NSObject, NSCoding { var blogName: String? override init() {} required init(coder aDecoder: NSCoder) { if let blogName = aDecoder.decodeObjectForKey("blogName") as? String { self.blogName = blogName } } func encodeWithCoder(aCoder: NSCoder) { if let blogName = self.blogName { aCoder.encodeObject(blogName, forKey: "blogName") } } } var blog = Blog() blog.blogName = "My Blog" let ud = NSUserDefaults.standardUserDefaults() ud.setObject(blog, forKey: "blog")
ud.setObject(NSKeyedArchiver.archivedDataWithRootObject(blog), forKey: "blog")
if let data = ud.objectForKey("blog") as? NSData { let unarc = NSKeyedUnarchiver(forReadingWithData: data) unarc.setClass(Blog.self, forClassName: "Blog") let blog = unarc.decodeObjectForKey("root") }
if let data = ud.objectForKey("blog") as? NSData { let blog = NSKeyedUnarchiver.unarchiveObjectWithData(data) }
import Foundation class Blog : NSObject, NSCoding { var blogName: String? override init() {} required init(coder aDecoder: NSCoder) { if let blogName = aDecoder.decodeObjectForKey("blogName") as? String { self.blogName = blogName } } func encodeWithCoder(aCoder: NSCoder) { if let blogName = self.blogName { aCoder.encodeObject(blogName, forKey: "blogName") } } } let ud = NSUserDefaults.standardUserDefaults() var blog = Blog() blog.blogName = "My Blog" ud.setObject(NSKeyedArchiver.archivedDataWithRootObject(blog), forKey: "blog") if let data = ud.objectForKey("blog") as? NSData { let unarc = NSKeyedUnarchiver(forReadingWithData: data) let newBlog = unarc.decodeObjectForKey("root") as Blog }
struct Blog : NSObject, Codable { var blogName: String? }
if let encoded = try? JSONEncoder().encode(blog) { UserDefaults.standard.set(encoded, forKey: "blog") }
if let blogData = UserDefaults.standard.data(forKey: "blog"), let blog = try? JSONDecoder().decode(Blog.self, from: blogData) { }
class Blog : NSObject, NSCoding { var blogName: String // // init(blogName: String) { self.blogName = blogName super.init() } func encodeWithCoder(aCoder: NSCoder) { aCoder.encodeObject(blogName, forKey: "blogName") } required convenience init?(coder aDecoder: NSCoder) { guard let unarchivedBlogName = aDecoder.decodeObjectForKey("blogName") as? String else { self.init(blogName: "unnamed") return } self.init(blogName: unarchivedBlogName) } }
let blog = Blog(blogName: "My Blog") let ud = NSUserDefaults.standardUserDefaults() ud.setObject(NSKeyedArchiver.archivedDataWithRootObject(blog), forKey: "blog") ud.synchronize() guard let decodedNSData = ud.objectForKey("blog") as? NSData, let someBlog = NSKeyedUnarchiver.unarchiveObjectWithData(decodedNSData) as? Blog else { print("Failed") return } print("loaded blog with name : \(someBlog.blogName)")
struct CustomStruct: Codable { let name: String let isActive: Bool }
class CustomClass: NSObject, NSCoding { let name: String let isActive: Bool init(name: String, isActive: Bool) { self.name = name self.isActive = isActive } required convenience init?(coder decoder: NSCoder) { guard let name = decoder.decodeObject(forKey: "name") as? String, let isActive = decoder.decodeObject(forKey: "isActive") as? Bool else { return nil } self.init(name: name, isActive: isActive) } func encode(with coder: NSCoder) { coder.encode(self.name, forKey: "name") coder.encode(self.isActive, forKey: "isActive") } }
struct UserDefaults { private static let kUserInfo = "kUserInformation" var UserInformation: DataUserInformation? { get { guard let user = NSUserDefaults.standardUserDefaults().objectForKey(UserDefaults.kUserInfo) as? DataUserInformation else { return nil } return user } set { NSUserDefaults.standardUserDefaults().setObject(newValue, forKey: UserDefaults.kUserInfo) } } }
class MyObject: NSObject, Codable { var name:String! var lastName:String! enum CodingKeys: String, CodingKey { case name case lastName = "last_name" } } self.myStoredPref = Pref<MyObject>(prefs:UserDefaults.standard,key:"MyObjectKey") let myObject = MyObject() self.myStoredPref.set(myObject)
let myStoredValue: MyObject = self.myStoredPref.get()
override init() { } required public init(coder decoder: NSCoder) { func decode(obj:AnyObject) -> AnyObject? { return decoder.decodeObjectForKey(String(obj)) } self.login = decode(login) as! String self.password = decode(password) as! String self.firstname = decode(firstname) as! String self.surname = decode(surname) as! String self.icon = decode(icon) as! UIImage } public func encodeWithCoder(coder: NSCoder) { func encode(obj:AnyObject) { coder.encodeObject(obj, forKey:String(obj)) } encode(login) encode(password) encode(firstname) encode(surname) encode(icon) }
@objc func test() {} @objc func test(_ sender:AnyObject?) {}
@objc func test(_ sender:AnyObject?) {} func makeSelector() { let selector = }
func test() {} func test(_ sender:AnyObject?) {} func makeSelector() { let selector = }
@objc func test(_ integer:Int) {} @nonobjc func test(_ string:String) {} func makeSelector() { let selector1 = let selector2 = }
let pause = UIBarButtonItem(barButtonSystemItem: .pause, target: self.mp, action:
class ClassA : NSObject { @objc func test() {} } class ClassB { func makeSelector() { let selector = } }
protocol Foo { func testPrint() } extension Foo { func testPrint() { print("Protocol extension call") } } struct Bar: Foo { func testPrint() { self.testPrint() print("Call from struct") } } let sth = Bar() sth.testPrint()
protocol Foo { } extension Foo { func testPrint() { print("Protocol extension call") } } struct Bar: Foo { func testPrint() { print("Call from struct") (self as Foo).testPrint() } } Bar().testPrint()
struct Bar: Foo { func testPrint() { struct Dummy : Foo {} let dummy = Dummy() dummy.testPrint() print("Call from struct") } }
import UIKit protocol MyProc { } protocol MyFuncProc { func myFunc() } extension MyProc { func myFunc() { print("Extension Version") } } struct MyStruct: MyProc, MyFuncProc { func myFunc() { print("Structure Version") (self as MyProc).myFunc() } } (MyStruct() as MyFuncProc).myFunc()
protocol Foo { associatedType Bar } extension Foo { func testPrint() { defaultTestPrint() } } fileprivate extension Foo { func defaultTestPrint() { } } struct Bar: Foo { func testPrint() { defaultTestPrint() } }
protocol Foo { func testPrint() } extension Foo { func testPrint() { defaultTestPrint() } func defaultTestPrint() { print("Protocol extension call") } } struct Bar: Foo { func testPrint() { defaultTestPrint() print("Call from struct") } } let sth = Bar() sth.testPrint()
func saveStuff(thingToUpdate: Object?) { if let thingToUpdate = thingToUpdate, let realm = thingToUpdate.realm { realm.write { thingToUpdate.name = "lionpants" } } }
C3DSourceAccessorGetMutableValuePtrAtIndex C3DSkinPrepareMeshForGPUIfNeeded C3DSkinnerMakeCurrentMesh C3DSkinnerUpdateCurrentMesh __CFSetApplyFunction_block_invoke CFBasicHashApply CFSetApplyFunction C3DAppleEngineRenderScene ...
let scene = SCNScene() let modelNode = SCNNode() modelNode.name = "ModelNode" scene.rootNode.addChildNode(modelNode) let modelScene = SCNScene(named: "model.dae") if modelScene != nil { if let childNodes = modelScene?.rootNode.childNodes { for childNode in childNodes { modelNode.addChildNode(childNode as SCNNode) } } } let modelNode = scnView.scene!.rootNode.childNodeWithName("ModelNode", recursively: true) let modelMesh = modelNode?.childNodeWithName("MeshName", recursively: true) let verts = modelMesh?.geometry!.geometrySourcesForSemantic(SCNGeometrySourceSemanticVertex) let normals = modelMesh?.geometry!.geometrySourcesForSemantic(SCNGeometrySourceSemanticNormal) let texcoords = modelMesh?.geometry!.geometrySourcesForSemantic(SCNGeometrySourceSemanticTexcoord) let boneWeights = modelMesh?.geometry!.geometrySourcesForSemantic(SCNGeometrySourceSemanticBoneWeights) let boneIndices = modelMesh?.geometry!.geometrySourcesForSemantic(SCNGeometrySourceSemanticBoneIndices) let geometry = modelMesh?.geometry!.geometryElementAtIndex(0) let vertsData = NSData(data: verts![0].data) let texcoordsData = NSData(data: texcoords![0].data) let boneWeightsData = NSData(data: boneWeights![0].data) let boneIndicesData = NSData(data: boneIndices![0].data) let geometryData = NSData(data: geometry!.data!) let newVerts = SCNGeometrySource(data: vertsData, semantic: SCNGeometrySourceSemanticVertex, vectorCount: verts![0].vectorCount, floatComponents: verts![0].floatComponents, componentsPerVector: verts![0].componentsPerVector, bytesPerComponent: verts![0].bytesPerComponent, dataOffset: verts![0].dataOffset, dataStride: verts![0].dataStride) let newNormals = SCNGeometrySource(data: vertsData, semantic: SCNGeometrySourceSemanticNormal, vectorCount: normals![0].vectorCount, floatComponents: normals![0].floatComponents, componentsPerVector: normals![0].componentsPerVector, bytesPerComponent: normals![0].bytesPerComponent, dataOffset: normals![0].dataOffset, dataStride: normals![0].dataStride) let newTexcoords = SCNGeometrySource(data: texcoordsData, semantic: SCNGeometrySourceSemanticTexcoord, vectorCount: texcoords![0].vectorCount, floatComponents: texcoords![0].floatComponents, componentsPerVector: texcoords![0].componentsPerVector, bytesPerComponent: texcoords![0].bytesPerComponent, dataOffset: texcoords![0].dataOffset, dataStride: texcoords![0].dataStride) let newBoneWeights = SCNGeometrySource(data: boneWeightsData, semantic: SCNGeometrySourceSemanticBoneWeights, vectorCount: boneWeights![0].vectorCount, floatComponents: boneWeights![0].floatComponents, componentsPerVector: boneWeights![0].componentsPerVector, bytesPerComponent: boneWeights![0].bytesPerComponent, dataOffset: boneWeights![0].dataOffset, dataStride: boneWeights![0].dataStride) let newBoneIndices = SCNGeometrySource(data: boneIndicesData, semantic: SCNGeometrySourceSemanticBoneIndices, vectorCount: boneIndices![0].vectorCount, floatComponents: boneIndices![0].floatComponents, componentsPerVector: boneIndices![0].componentsPerVector, bytesPerComponent: boneIndices![0].bytesPerComponent, dataOffset: boneIndices![0].dataOffset, dataStride: boneIndices![0].dataStride) let newGeometry = SCNGeometryElement(data: geometryData, primitiveType: geometry!.primitiveType, primitiveCount: geometry!.primitiveCount, bytesPerIndex: geometry!.bytesPerIndex) let newMeshGeometry = SCNGeometry(sources: [newVerts, newNormals, newTexcoords, newBoneWeights, newBoneIndices], elements: [newGeometry]) newMeshGeometry.firstMaterial = modelMesh?.geometry!.firstMaterial let newModelMesh = SCNNode(geometry: newMeshGeometry) let bones = modelMesh?.skinner?.bones let boneInverseBindTransforms = modelMesh?.skinner?.boneInverseBindTransforms let skeleton = modelMesh!.skinner!.skeleton! let baseGeometryBindTransform = modelMesh!.skinner!.baseGeometryBindTransform newModelMesh.skinner = SCNSkinner(baseGeometry: newMeshGeometry, bones: bones, boneInverseBindTransforms: boneInverseBindTransforms, boneWeights: newBoneWeights, boneIndices: newBoneIndices) newModelMesh.skinner?.baseGeometryBindTransform = baseGeometryBindTransform newModelMesh.skinner?.skeleton = skeleton modelMesh?.removeFromParentNode() newModelMesh.name = "MeshName" let meshParentNode = modelNode?.childNodeWithName("MeshParentNode", recursively: true) meshParentNode?.addChildNode(newModelMesh)
SCNNode *hero = [SCNScene sceneNamed:@"Hero"].rootNode; SCNNode *hat = [SCNScene sceneNamed:@"FancyFedora"].rootNode; hat.skinner.skeleton = hero.skinner.skeleton;
[Export ("initWithFrame:")] public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty) { var initWithFrame = new Selector ("initWithFrame:").Handle; if (IsDirectBinding) Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame); else Handle = ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame); }
protocol PenguinDelegate: NSObjectProtocol { func userDidTapThePenguin() } class MyViewController: UIViewController { weak var delegate: PenguinDelegate? }
protocol PenguinDelegate: class { func userDidTapThePenguin() } class MyViewController: UIViewController { weak var delegate: PenguinDelegate? }
protocol PenguinDelegate: class { func userDidTapThePenguin() } class MyViewController: UIViewController { weak var delegate = PenguinDelegate? }
protocol PenguinDelegate: class { func userDidTapThePenguin() } class MyViewController: UIViewController { weak var delegate: PenguinDelegate? }
class MyVC: UIViewController { var myText: UITextView = { [weak self] let text = UITextView() return text }() }
class MyVC: UIViewController { lasy var myText: UITextView = { [weak self] let text = UITextView() return text }() }
var imageView = UIImageView(); var image = UIImage(named: "email.png"); imageView.image = image; emailField.leftView = imageView;
emailField.leftViewMode = UITextFieldViewMode.always emailField.leftViewMode = .always
import UIKit @IBDesignable class DesignableUITextField: UITextField { override func leftViewRect(forBounds bounds: CGRect) -> CGRect { var textRect = super.leftViewRect(forBounds: bounds) textRect.origin.x += leftPadding return textRect } @IBInspectable var leftImage: UIImage? { didSet { updateView() } } @IBInspectable var leftPadding: CGFloat = 0 @IBInspectable var color: UIColor = UIColor.lightGray { didSet { updateView() } } func updateView() { if let image = leftImage { leftViewMode = UITextFieldViewMode.always let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 20, height: 20)) imageView.contentMode = .scaleAspectFit imageView.image = image imageView.tintColor = color leftView = imageView } else { leftViewMode = UITextFieldViewMode.never leftView = nil } attributedPlaceholder = NSAttributedString(string: placeholder != nil ? placeholder! : "", attributes:[NSAttributedStringKey.foregroundColor: color]) } }
textField.leftViewMode = UITextFieldViewMode.Always let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 20, height: 20)) let image = UIImage(named: imageName) imageView.image = image textField.leftView = imageView
textField.rightViewMode = UITextFieldViewMode.Always let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 20, height: 20)) let image = UIImage(named: imageName) imageView.image = image textField.rightView = imageView
extension UITextField { enum Direction { case Left case Right } func withImage(direction: Direction, image: UIImage, colorSeparator: UIColor, colorBorder: UIColor){ let mainView = UIView(frame: CGRect(x: 0, y: 0, width: 50, height: 45)) mainView.layer.cornerRadius = 5 let view = UIView(frame: CGRect(x: 0, y: 0, width: 50, height: 45)) view.backgroundColor = .white view.clipsToBounds = true view.layer.cornerRadius = 5 view.layer.borderWidth = CGFloat(0.5) view.layer.borderColor = colorBorder.cgColor mainView.addSubview(view) let imageView = UIImageView(image: image) imageView.contentMode = .scaleAspectFit imageView.frame = CGRect(x: 12.0, y: 10.0, width: 24.0, height: 24.0) view.addSubview(imageView) let seperatorView = UIView() seperatorView.backgroundColor = colorSeparator mainView.addSubview(seperatorView) if(Direction.Left == direction){ seperatorView.frame = CGRect(x: 45, y: 0, width: 5, height: 45) self.leftViewMode = .always self.leftView = mainView } else { seperatorView.frame = CGRect(x: 0, y: 0, width: 5, height: 45) self.rightViewMode = .always self.rightView = mainView } self.layer.borderColor = colorBorder.cgColor self.layer.borderWidth = CGFloat(0.5) self.layer.cornerRadius = 5 } }
if let myImage = UIImage(named: "my_image"){ textfield.withImage(direction: .Left, image: myImage, colorSeparator: UIColor.orange, colorBorder: UIColor.black) }
textField.leftView = UIImageView(image: "small-calendar")) textField.leftView?.frame = CGRect(x: 0, y: 5, width: 20 , height:20) textField.leftViewMode = .always
import UIKit @IBDesignable class RoundTextField : UITextField { @IBInspectable var cornerRadius : CGFloat = 0{ didSet{ layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius > 0 } } @IBInspectable var borderWidth : CGFloat = 0 { didSet{ layer.borderWidth = borderWidth } } @IBInspectable var borderColor : UIColor? { didSet { layer.borderColor = borderColor?.cgColor } } @IBInspectable var bgColor : UIColor? { didSet { backgroundColor = bgColor } } @IBInspectable var leftImage : UIImage? { didSet { if let image = leftImage{ leftViewMode = .always let imageView = UIImageView(frame: CGRect(x: 20, y: 0, width: 20, height: 20)) imageView.image = image imageView.tintColor = tintColor let view = UIView(frame : CGRect(x: 0, y: 0, width: 25, height: 20)) view.addSubview(imageView) leftView = view }else { leftViewMode = .never } } } @IBInspectable var placeholderColor : UIColor? { didSet { let rawString = attributedPlaceholder?.string != nil ? attributedPlaceholder!.string : "" let str = NSAttributedString(string: rawString, attributes: [NSForegroundColorAttributeName : placeholderColor!]) attributedPlaceholder = str } } override func textRect(forBounds bounds: CGRect) -> CGRect { return bounds.insetBy(dx: 50, dy: 5) } override func editingRect(forBounds bounds: CGRect) -> CGRect { return bounds.insetBy(dx: 50, dy: 5) } }
extension UITextField { enum Direction { case Left case Right } func AddImage(direction:Direction,imageName:String,Frame:CGRect,backgroundColor:UIColor) { let View = UIView(frame: Frame) View.backgroundColor = backgroundColor let imageView = UIImageView(frame: Frame) imageView.image = UIImage(named: imageName) View.addSubview(imageView) if Direction.Left == direction { self.leftViewMode = .always self.leftView = View } else { self.rightViewMode = .always self.rightView = View } } }
let userIcon = UIImage(named: "ImageName") setPaddingWithImage(image: userIcon, textField: txtUsername) func setPaddingWithImage(image: UIImage, textField: UITextField){ let imageView = UIImageView(image: image) imageView.contentMode = .scaleAspectFit let view = UIView(frame: CGRect(x: 0, y: 0, width: 60, height: 50)) imageView.frame = CGRect(x: 13.0, y: 13.0, width: 24.0, height: 24.0) let seperatorView = UIView(frame: CGRect(x: 50, y: 0, width: 10, height: 50)) seperatorview.backgroundColor = UIColor(red: 80/255, green: 89/255, blue: 94/255, alpha: 1) view.addSubview(seperatorView) textField.leftViewMode = .always view.addSubview(imageView) view.backgroundColor = .darkGray textField.leftViewMode = UITextFieldViewMode.always textField.leftView = view }
myTextField.setLeftViewFAIcon(icon: .FAPlus, leftViewMode: .always, textColor: .red, backgroundColor: .clear, size: nil)
func SetLeftSIDEImage(TextField: UITextField, ImageName: String){ let leftImageView = UIImageView() leftImageView.contentMode = .scaleAspectFit let leftView = UIView() leftView.frame = CGRect(x: 20, y: 0, width: 30, height: 20) leftImageView.frame = CGRect(x: 13, y: 0, width: 15, height: 20) TextField.leftViewMode = .always TextField.leftView = leftView let image = UIImage(named: ImageName)?.withRenderingMode(.alwaysTemplate) leftImageView.image = image leftImageView.tintColor = UIColor(red: 106/255, green: 79/255, blue: 131/255, alpha: 1.0) leftImageView.tintColorDidChange() leftView.addSubview(leftImageView) } SetLeftSIDEImage(TextField: Your_textField, ImageName: ‚ÄúYourImageName‚Äù)
import UIKit @IBDesignable class TextFieldWithImage: UITextField { override func leftViewRect(forBounds bounds: CGRect) -> CGRect { return super.leftViewRect(forBounds: bounds) } @IBInspectable var leftImage: UIImage? { didSet { updateView() } } @IBInspectable var leftPadding: CGFloat = 0 { didSet { updateView() } } @IBInspectable var rightPadding: CGFloat = 0 { didSet { updateView() } } @IBInspectable var imageMaxHeight: CGFloat = 0 { didSet { updateView() } } @IBInspectable var color: UIColor = UIColor.lightGray { didSet { updateView() } } func updateView() { if let image = leftImage { leftViewMode = UITextField.ViewMode.always let containerSize = calculateContainerViewSize(for: image) let containerView = UIView(frame: CGRect(x: 0, y: 0, width: containerSize.width, height: containerSize.height)) let imageView = UIImageView(frame: .zero) containerView.addSubview(imageView) setImageViewConstraints(imageView, in: containerView) setImageViewProperties(imageView, image: image) leftView = containerView } else { leftViewMode = UITextField.ViewMode.never leftView = nil } attributedPlaceholder = NSAttributedString(string: placeholder != nil ? placeholder! : "", attributes: [NSAttributedString.Key.foregroundColor: color]) } private func calculateContainerViewSize(for image: UIImage) -> CGSize { let imageRatio = image.size.height / image.size.width let adjustedImageMaxHeight = imageMaxHeight > self.frame.height ? self.frame.height : imageMaxHeight var imageSize = CGSize() if image.size.height > adjustedImageMaxHeight { imageSize.height = adjustedImageMaxHeight imageSize.width = imageSize.height / imageRatio } let paddingWidth = leftPadding + rightPadding let containerSize = CGSize(width: imageSize.width + paddingWidth, height: imageSize.height) return containerSize } private func setImageViewConstraints(_ imageView: UIImageView, in containerView: UIView) { imageView.translatesAutoresizingMaskIntoConstraints = false imageView.topAnchor.constraint(equalTo: containerView.topAnchor).isActive = true imageView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor).isActive = true imageView.trailingAnchor.constraint(equalTo: containerView.trailingAnchor, constant: -rightPadding).isActive = true imageView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: leftPadding).isActive = true } private func setImageViewProperties(_ imageView: UIImageView, image: UIImage) { imageView.contentMode = .scaleAspectFit imageView.image = image imageView.tintColor = color } }
let min = 50 let max = 100 let intArray:[Int] = (min...max)
let min = 50 let max = 100 let intArray = (min...max).map{$0}
let range: Range<Int> = 1...10 let array: [Int] = Array(range)
let array: [Int] = Array(range.lowerBound...range.upperBound)
let range: CountableRange<Int> = -10..<10 let array = Array(range) print(array)
NSTimer.scheduledTimerWithTimeInterval(0.2, target: self, selector: "someSelector:", userInfo: "someData", repeats: true)
class Foo { class func Bar() -> String { return "Bar" } }
class Foo { class func Bar() -> String { return "Bar" } } struct Foo2 { static func Bar2() -> String { return "Bar2" } }
class MyClass { class func myString() -> String { return "Welcome" } }
extension _ArrayType where Generator.Element == Float { func quickSum() -> Float { var result: Float = 0 if var x = self as? [Float] { vDSP_sve(&x, 1, &result, vDSP_Length(x.count)) } return result } } extension _ArrayType where Generator.Element == Double { func quickSum() -> Double { var result: Double = 0 if var x = self as? [Double] { vDSP_sveD(&x, 1, &result, vDSP_Length(x.count)) } return result } }
extension _ArrayType where Generator.Element == Int { func doSomething() { ... } }
extension Array where Element: Equatable { func doSomething() { ... } }
extension Array where Element == Int { func doSomething() { ... } }
extension Collection where Iterator.Element == Int { }
extension CollectionType where Generator.Element == Double { }
protocol ArithmeticType { func +(lhs: Self, rhs: Self) -> Self func -(lhs: Self, rhs: Self) -> Self func *(lhs: Self, rhs: Self) -> Self func /(lhs: Self, rhs: Self) -> Self } extension Double : ArithmeticType {} extension Float : ArithmeticType {} extension SequenceType where Generator.Element : protocol<FloatLiteralConvertible, ArithmeticType> { var sum : Generator.Element { return reduce(0.0, combine: +) } var product : Generator.Element { return reduce(1.0, combine: *) } } stride(from: 1.0, through: 10.0, by: 1.0).sum [1.5, 2.0, 3.5, 4.0, 5.5].product
public extension SequenceType where Self.Generator.Element: FloatingPointType { public func splitAt(separator: Generator.Element) -> [[Generator.Element]] { var ret: [[Generator.Element]] = [] var thisPart: [Generator.Element] = [] for element in self { if element == separator { ret.append(thisPart) thisPart = [] } else { thisPart.append(element) } } ret.append(thisPart) return ret } } [Float(1), Float(2), Float(3), Float(4)].splitAt(Float(2)) [Double(1), Double(2), Double(3), Double(4)].splitAt(Double(3))
let someString = "1, 2, 3, 4, 5, 6, 7, 8" extension String { func toArrayOfElements() -> [String] { return self.components(separatedBy: ", ") } } extension Sequence where Iterator.Element == String { func toInt() -> [Int] { return self.map { Int($0)! } } } let arrayOfStrings = someString.toArrayOfElements() print(arrayOfStrings) let arrayOfInts = arrayOfStrings.toInt() print(arrayOfInts)
protocol DoubleValue { var value: Double { get } } extension Double: DoubleValue { var value: Double { return self } } extension Array where Element: DoubleValue { } protocol FloatValue { var value: Float { get } } extension Float: FloatValue { var value: Float { return self } } extension Array where Element: FloatValue { }
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {}
let str = String.init(data: deviceToken, encoding: .utf8)
var testString = "This is a test string" var somedata = testString.data(using: String.Encoding.utf8) var backToString = String(data: somedata!, encoding: String.Encoding.utf8) as String!
import Foundation extension Data { func toString() -> String? { return String(data: self, encoding: .utf8) } }
let str = deviceToken.map { String(format: "%02hhx", $0) }.joined()
let characterSet = CharacterSet(charactersIn: "<>") let nsdataStr = NSData.init(data: deviceToken) let deviceStr = nsdataStr.description.trimmingCharacters(in: characterSet).replacingOccurrences(of: " ", with: "") print(deviceStr)
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { let token = deviceToken.reduce("") { $0 + String(format: "%02x", $1) } DispatchQueue.global(qos: .background).async { let url = URL(string: "https: var request = URLRequest(url: url) request.addValue("application/json", forHTTPHeaderField: "Content-Type") request.httpMethod = "POST" request.httpBody = try! JSONSerialization.data(withJSONObject: [ "token" : token, "ios" : UIDevice.current.systemVersion, "languages" : Locale.preferredLanguages.joined(separator: ", ") ]) URLSession.shared.dataTask(with: request).resume() } }
extension Data { func hexString() -> String { let nsdataStr = NSData.init(data: self) return nsdataStr.description.trimmingCharacters(in: CharacterSet(charactersIn: "<>")).replacingOccurrences(of: " ", with: "") } }
let testString = "This is a test string" let somedata = testString.data(using: String.Encoding.utf8) let backToString = String(data: somedata!, encoding: String.Encoding.utf8)
if ( dataObj != nil ) { let encryptedDataText = dataObj!.base64EncodedString(options: NSData.Base64EncodingOptions()) NSLog("Encrypted with pubkey: %@", encryptedDataText) }
@available(iOS, deprecated: 9.0) func addressBookStatus() -> ABAuthorizationStatus { return ABAddressBookGetAuthorizationStatus() }
@available(iOS, deprecated: 9.0) func getLatestImage() -> UIImage? { ... }
private protocol GetLatestImage { func getLatestImage() -> UIImage? } extension Foo: GetLatestImage {}
let userDefaults = UserDefaults.standard var settingsValue = userDefaults.string(forKey: "user_preference") if settingsValue == nil { settingsValue = "1" } if (settingsValue?.isEqual("1"))! { } else { }
var identityToken: NSObjectProtocol & NSCopying & NSCoding
var array: [NSObjectProtocol & NSCopying & NSCoding]
func foo(param: NSObjectProtocol & NSCopying & NSCoding) { }
var identityToken: (NSObjectProtocol, NSCopying, NSCoding)
var idToken: NSObjectProtocol & NSCopying & NSCoding func foo(_ delegateAndDataSource: UICollectionViewDelegate & UICollectionViewDataSource) { ... }
internal protocol MyOtherProtocol : NSObjectProtocol, NSCopying, NSCoding { func someOtherNecessaryMethod() }
func setCollectionViewDataSourceDelegate<D: UICollectionViewDataSource & UICollectionViewDelegate>
uploadFileToUrl(foti√±o:UIImage){ var foto = UIImage(data: UIImageJPEGRepresentation(foti√±o, 0.2)) var request = NSMutableURLRequest(URL:NSURL(string: "URL")) request.HTTPMethod = "POST" var bodyData = "id_user="PARAMETERS&ETC"" request.HTTPBody = bodyData.dataUsingEncoding(NSUTF8StringEncoding); request.HTTPBody = NSData.dataWithData(UIImagePNGRepresentation(foto)) println("miraqui \(request.debugDescription)") var response: AutoreleasingUnsafeMutablePointer<NSURLResponse?>=nil var HTTPError: NSError? = nil var JSONError: NSError? = nil var dataVal: NSData? = NSURLConnection.sendSynchronousRequest(request, returningResponse: response, error: &HTTPError) if ((dataVal != nil) && (HTTPError == nil)) { var jsonResult = NSJSONSerialization.JSONObjectWithData(dataVal!, options: NSJSONReadingOptions.MutableContainers, error: &JSONError) if (JSONError != nil) { println("Bad JSON") } else { println("Synchronous\(jsonResult)") } } else if (HTTPError != nil) { println("Request failed") } else { println("No Data returned") } }
func createRequest ( let param = [ "id_user" : userid, "name_discoteca" : disco, "id_discoteca" : id_disco, "ispublic" : pub] let boundary = generateBoundaryString() let url = NSURL(string: "http....") let request = NSMutableURLRequest(URL: url) request.HTTPMethod = "POST" request.timeoutInterval = 60 request.HTTPShouldHandleCookies = false request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type") var imagesaver = ImageSaver() var image = foto let documentsPath = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0] as String let destinationPath = documentsPath.stringByAppendingPathComponent("VipKing.jpg") UIImageJPEGRepresentation(image,1.0).writeToFile(destinationPath, atomically: true) self.saveImage(foto, withFileName: "asdasd22.jpg") var path = self.documentsPathForFileName("asdasd22.jpg") self.ViewImage.image = self.loadImageWithFileName("asdasd22.jpg") ** println(param.debugDescription) println(path.debugDescription) println(boundary.debugDescription) request.HTTPBody = createBodyWithParameters(param, filePathKey: "asdasd22.jpg", paths: [path], boundary: boundary) println(request.debugDescription) return request }
func createRequest(userid: String, password: String, email: String) throws -> URLRequest { let parameters = [ "user_id" : userid, "email" : email, "password" : password] let boundary = generateBoundaryString() let url = URL(string: "https: var request = URLRequest(url: url) request.httpMethod = "POST" request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type") let path1 = Bundle.main.path(forResource: "image1", ofType: "png")! request.httpBody = try createBody(with: parameters, filePathKey: "file", paths: [path1], boundary: boundary) return request } private func createBody(with parameters: [String: String]?, filePathKey: String, paths: [String], boundary: String) throws -> Data { var body = Data() if parameters != nil { for (key, value) in parameters! { body.append("--\(boundary)\r\n") body.append("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n") body.append("\(value)\r\n") } } for path in paths { let url = URL(fileURLWithPath: path) let filename = url.lastPathComponent let data = try Data(contentsOf: url) let mimetype = mimeType(for: path) body.append("--\(boundary)\r\n") body.append("Content-Disposition: form-data; name=\"\(filePathKey)\"; filename=\"\(filename)\"\r\n") body.append("Content-Type: \(mimetype)\r\n\r\n") body.append(data) body.append("\r\n") } body.append("--\(boundary)--\r\n") return body } private func generateBoundaryString() -> String { return "Boundary-\(UUID().uuidString)" } private func mimeType(for path: String) -> String { let url = URL(fileURLWithPath: path) let pathExtension = url.pathExtension if let uti = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension as NSString, nil)?.takeRetainedValue() { if let mimetype = UTTypeCopyPreferredTagWithClass(uti, kUTTagClassMIMEType)?.takeRetainedValue() { return mimetype as String } } return "application/octet-stream" }
extension Data { mutating func append(_ string: String, using encoding: String.Encoding = .utf8) { if let data = string.data(using: encoding) { append(data) } } }
func createRequest (userid userid: String, password: String, email: String) -> NSURLRequest { let param = [ "user_id" : userid, "email" : email, "password" : password] let boundary = generateBoundaryString() let url = NSURL(string: "https: let request = NSMutableURLRequest(URL: url) request.HTTPMethod = "POST" request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type") let path1 = NSBundle.mainBundle().pathForResource("image1", ofType: "png") as String! request.HTTPBody = createBodyWithParameters(param, filePathKey: "file", paths: [path1], boundary: boundary) return request } func createBodyWithParameters(parameters: [String: String]?, filePathKey: String?, paths: [String]?, boundary: String) -> NSData { let body = NSMutableData() if parameters != nil { for (key, value) in parameters! { body.appendString("--\(boundary)\r\n") body.appendString("Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n") body.appendString("\(value)\r\n") } } if paths != nil { for path in paths! { let url = NSURL(fileURLWithPath: path) let filename = url.lastPathComponent let data = NSData(contentsOfURL: url)! let mimetype = mimeTypeForPath(path) body.appendString("--\(boundary)\r\n") body.appendString("Content-Disposition: form-data; name=\"\(filePathKey!)\"; filename=\"\(filename!)\"\r\n") body.appendString("Content-Type: \(mimetype)\r\n\r\n") body.appendData(data) body.appendString("\r\n") } } body.appendString("--\(boundary)--\r\n") return body } func generateBoundaryString() -> String { return "Boundary-\(NSUUID().UUIDString)" } func mimeTypeForPath(path: String) -> String { let url = NSURL(fileURLWithPath: path) let pathExtension = url.pathExtension if let uti = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension! as NSString, nil)?.takeRetainedValue() { if let mimetype = UTTypeCopyPreferredTagWithClass(uti, kUTTagClassMIMEType)?.takeRetainedValue() { return mimetype as String } } return "application/octet-stream"; }
extension NSMutableData { func appendString(string: String) { let data = string.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true) appendData(data!) } }
let request: URLRequest do { request = try createRequest(userid: userid, password: password, email: email) } catch { print(error) return } let task = URLSession.shared.dataTask(with: request) { data, response, error in guard error == nil else { print(error!) return } do { let responseDictionary = try JSONSerialization.jsonObject(with: data!) print("success == \(responseDictionary)") // } catch { print(error) let responseString = String(data: data!, encoding: .utf8) print("responseString = \(responseString)") } } task.resume()
let request = createRequest(userid: userid, password: password, email: email) let task = NSURLSession.sharedSession().dataTaskWithRequest(request) { data, response, error in if error != nil { print(error) return } do { if let responseDictionary = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? NSDictionary { print("success == \(responseDictionary)") // } } catch { print(error) let responseString = NSString(data: data!, encoding: NSUTF8StringEncoding) print("responseString = \(responseString)") } } task.resume()
func createMultipart(image: UIImage, callback: Bool -> Void){ var parameterJSON = JSON([ "id_user": "test" ]) let parameterString = parameterJSON.rawString(encoding: NSUTF8StringEncoding, options: nil) let jsonParameterData = parameterString!.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true) let imageData = UIImageJPEGRepresentation(image, 0.7) upload( .POST, URLString: "http: multipartFormData: { multipartFormData in multipartFormData.appendBodyPart(fileData: jsonParameterData!, name: "goesIntoFile", fileName: "json.txt", mimeType: "application/json") multipartFormData.appendBodyPart(fileData: imageData, name: "file", fileName: "iosFile.jpg", mimeType: "image/jpg") multipartFormData.appendBodyPart(data: jsonParameterData!, name: "goesIntoForm") }, encodingCompletion: { encodingResult in switch encodingResult { case .Success(let upload, _, _): upload.responseJSON { request, response, data, error in let json = JSON(data!) println("json:: \(json)") callback(true) } case .Failure(let encodingError): callback(false) } } ) } let fotoImage = UIImage(named: "foto") createMultipart(fotoImage!, callback: { success in if success { } })
let filename = (path.lastPathComponent as NSString).lowercaseString
func test(firstThing: Int? = nil) { if firstThing != nil { print(firstThing!) } print("done") } test()
func test(firstThing: Int?) { if firstThing != nil { print(firstThing!) } print("done") }
func test(firstThing: Int? = nil) { if let firstThing = firstThing { print(firstThing) } print("done") } test()
func someFunc(param1: String?, param2: String = "default value", param3: String? = "also has default value") { print("param1 = \(param1)") print("param2 = \(param2)") print("param3 = \(param3)") }
someFunc(param1: nil, param2: "specific value", param3: "also specific value") param1 = nil param2 = specific value param3 = Optional("also specific value") someFunc(param1: "has a value") param1 = Optional("has a value") param2 = default value param3 = Optional("also has default value") someFunc(param1: nil, param3: nil) param1 = nil param2 = default value param3 = nil
let configuration = NSURLSessionConfiguration.defaultSessionConfiguration() configuration.HTTPMaximumConnectionsPerHost = 2 configuration.timeoutIntervalForRequest = 30 let manager = Alamofire.Manager(configuration: configuration)
class NetworkOperation: AsynchronousOperation { // private let urlString: String private var networkOperationCompletionHandler: ((_ responseObject: Any?, _ error: Error?) -> Void)? weak var request: Alamofire.Request? init(urlString: String, networkOperationCompletionHandler: ((_ responseObject: Any?, _ error: Error?) -> Void)? = nil) { self.urlString = urlString self.networkOperationCompletionHandler = networkOperationCompletionHandler super.init() } override func main() { request = Alamofire.request(urlString, method: .get, parameters: ["foo" : "bar"]) .responseJSON { response in self.networkOperationCompletionHandler?(response.result.value, response.result.error) self.networkOperationCompletionHandler = nil self.completeOperation() } } override func cancel() { request?.cancel() super.cancel() } }
let queue = OperationQueue() queue.maxConcurrentOperationCount = 2 for i in 0 ..< 50 { let operation = NetworkOperation(urlString: "http: guard let responseObject = responseObject else { print("failed: \(error?.localizedDescription ?? "Unknown error")") return } print("responseObject=\(responseObject)") } queue.addOperation(operation) }
// // // import Foundation public class AsynchronousOperation : Operation { private let stateLock = NSLock() private var _executing: Bool = false override private(set) public var isExecuting: Bool { get { return stateLock.withCriticalScope { _executing } } set { willChangeValue(forKey: "isExecuting") stateLock.withCriticalScope { _executing = newValue } didChangeValue(forKey: "isExecuting") } } private var _finished: Bool = false override private(set) public var isFinished: Bool { get { return stateLock.withCriticalScope { _finished } } set { willChangeValue(forKey: "isFinished") stateLock.withCriticalScope { _finished = newValue } didChangeValue(forKey: "isFinished") } } public func completeOperation() { if isExecuting { isExecuting = false } if !isFinished { isFinished = true } } override public func start() { if isCancelled { isFinished = true return } isExecuting = true main() } override public func main() { fatalError("subclasses must override `main`") } } /* Copyright (C) 2015 Apple Inc. All Rights Reserved. See LICENSE.txt for this sample‚Äôs licensing information Abstract: An extension to `NSLock` to simplify executing critical code. From Advanced NSOperations sample code in WWDC 2015 https: From https: */ import Foundation extension NSLock { func withCriticalScope<T>( block: (Void) -> T) -> T { lock() let value = block() unlock() return value } }
class MyView : UIView { override class func initialize () { } }
private var once = dispatch_once_t() class MyObject { init () { dispatch_once(&once) { } } }
class FirstClass { class var someProperty = { return SomeType }() }
class FirstClass { static let someProperty = { () -> [Bool] in var temporaryBoard = [Bool]() var isBlack = false for i in 1...8 { for j in 1...8 { temporaryBoard.append(isBlack) isBlack = !isBlack } isBlack = !isBlack } print("setting default property value with a closure") return temporaryBoard }() } print("start") FirstClass.someProperty
import Foundation public class MyView: UIView { @objc public static func swiftyInitialize() { Swift.print("Rock } } @implementation MyView (private) + (void)initialize { [self swiftyInitialize]; } @end
import Foundation public class MyClass { public static func load() { Swift.print("Rock } } public class MyClassObjC: NSObject { @objc public static func swiftyLoad() { MyClass.load() } } @implementation MyClassObjC (private) + (void)load { [self swiftyLoad]; } @end
static NSArray *array; + (void)initialize { array = @[1,2,3]; }
+ (void)initialize { swizzle_methodImplementation() }
enum StatusShape:Int { case Rectangle = 0 case Triangle = 1 case Circle = 2 } @IBInspectable var shape:StatusShape = .Rectangle
@IBInspectable var shapeAdapter:Int { get { return self.shape.rawValue } set( shapeIndex) { self.shape = StatusShape(rawValue: shapeIndex) ?? .Rectangle } }
@IBDesignable class ViewController: UIViewController { enum StatusShape:Int { case Rectangle case Triangle case Circle } var shape:StatusShape = .Rectangle @IBInspectable var shapeAdapter:Int { get { return self.shape.rawValue } set( shapeIndex) { self.shape = StatusShape(rawValue: shapeIndex) ?? .Rectangle } } }
enum Shape: String { case Rectangle = "rectangle" case Triangle = "triangle" case Circle = "circle" } var shape = Shape.Rectangle @available(*, unavailable, message: "This property is reserved for Interface Builder. Use @IBInspectable var shapeName: String? { willSet { if let newShape = Shape(rawValue: newValue?.lowercased() ?? "") { shape = newShape } } }
@objc enum Shape: Int { case None case Rectangle case Triangle case Circle init(named shapeName: String) { switch shapeName.lowercased() { case "rectangle": self = .Rectangle case "triangle": self = .Triangle case "circle": self = .Circle default: self = .None } } } var shape = Shape.Rectangle @available(*, unavailable, message: "This property is reserved for Interface Builder. Use @IBInspectable var shapeName: String? { willSet { if let newShape = Shape(rawValue: newValue?.lowercased() ?? "") { shape = newShape } } }
@property (nonatomic) IBInspectable NSInteger shape; @property (nonatomic) StatusShape shape;
enum StatusShape: Int { case Rectangle = 0 case Triangle = 1 case Circle = 2 } var _shape:StatusShape = .Rectangle @IBInspectable var shape: Int { get { return _shape.rawValue } set { if _shape.rawValue != newValue { _shape.rawValue = newValue } } } var shape: StatusShape { get { return _shape } set { if _shape != newValue { _shape = newValue } } }
enum StatusShape: Int { case rectangle, triangle, circle } var statusShape: StatusShape = .rectangle @IBInspectable var statusShapeIB: Int { get { return statusShape.rawValue } set { guard let statusShape = StatusShape(rawValue: newValue) else { return } self.statusShape = statusShape } }
override func viewDidLoad() { super.viewDidLoad() let formatter = NSNumberFormatter() formatter.numberStyle = .CurrencyStyle totalLabel.text = formatter.stringFromNumber(0) coinsLabel.text = formatter.stringFromNumber(0) formatter.maximumFractionDigits = 0 billsLabel.text = formatter.stringFromNumber(0) } func widgetMarginInsetsForProposedMarginInsets(defaultMarginInsets: UIEdgeInsets) -> UIEdgeInsets { return UIEdgeInsetsMake(8.0, 16.0, 8.0, 16.0) } func widgetPerformUpdateWithCompletionHandler(completionHandler: ((NCUpdateResult) -> Void)!) { completionHandler(NCUpdateResult.NewData) }
var str: String! str = "Hello" print("The following should not be printed as an optional: \(str)")
The following should not be printed as an optional: Optional("Hello")
var str: String! str = "Hello" print("The following should not be printed as an optional: \(str)")
var str: String! str = "Hello" print("The following should not be printed as an optional: \(str!)")
print("The following should not be printed as an optional: \(str as String)")
var corX = 0 var corY = 0 var runter: UIButton = UIButton.buttonWithType(UIButtonType.System) as UIButton var image = UIImage(named: "panzerBlau.jpg"); var panzer = UIImageView(frame: CGRectMake(corX, corY, 30, 40)); // override func viewDidLoad() { super.viewDidLoad() panzer.image = image; // self.view.addSubview(panzer); // runter.frame = CGRectMake(100, 30, 10 , 10) runter.backgroundColor = UIColor.redColor() view.addSubview(runter) runter.addTarget(self, action: "fahren", forControlEvents:UIControlEvents.TouchUpInside) }
func fahren(){ corY += 1 panzer.frame = CGRectMake(corX, corY, 30, 40) // self.view.addSubview(panzer); }
import UIKit class ViewController: UIViewController { var corX = 0 var corY = 0 var runter: UIButton = UIButton.buttonWithType(UIButtonType.System) as UIButton var image = UIImage(named: "panzerBlau.jpg"); var panzer = UIImageView(frame: CGRectMake(corX, corY, 30, 40)); override func viewDidLoad() { super.viewDidLoad() panzer.image = image; self.view.addSubview(panzer); runter.frame = CGRectMake(100, 30, 10 , 10) runter.backgroundColor = UIColor.redColor() view.addSubview(runter) runter.addTarget(self, action: "fahren", forControlEvents:UIControlEvents.TouchUpInside) } func fahren(){ corY += 100 panzer.frame = CGRectMake(corX, corY, 30, 40) self.view.addSubview(panzer); } }
var corX = 0 var corY = 0 var panzer = UIImageView(frame: CGRectMake(corX, corY, 30, 40))
class ViewController: UIViewController { var corX : CGFloat = 0 var corY : CGFloat = 0 lazy var panzer : UIImageView = UIImageView(frame: CGRectMake(self.corX, self.corY, 30, 40)) }
let original = "foo" lazy var depend: String = self.original var noLazy: String = self.original lazy var noType = self.original lazy var noSelf: String = original
// // // import UIKit class ViewController: UIViewController { var corX = 0 var corY = 0 var runter: UIButton = UIButton() var image = UIImage(named: "panzerBlau.jpg") var panzer = UIImageView() override func viewDidLoad() { super.viewDidLoad() panzer.image = image; self.view.addSubview(panzer); panzer.frame = CGRect(x: CGFloat(corX), y: CGFloat(corY), width: 30, height: 40) runter.backgroundColor = UIColor.red view.addSubview(runter) view.addSubview(panzer) runter.addTarget(self, action: Selector(("fahren")), for:UIControlEvents.touchUpInside) } private func fahren(){ corY += 100 } private func updatePanzerFrame(){ panzer.frame = CGRect(x: CGFloat(corX), y: CGFloat(corY), width: 30, height: 40) } } Note: Do not add panzer imageView every time when user tap only add it on viewDidLoad()
extension NSMutableAttributedString { @discardableResult func bold(_ text:String) -> NSMutableAttributedString { let attrs:[String:AnyObject] = [NSFontAttributeName: UIFont(name: "AvenirNext-Medium", size: 12)!] let boldString = NSMutableAttributedString(string: text, attributes:attrs) self.append(boldString) return self } @discardableResult func normal(_ text:String)->NSMutableAttributedString { let normal = NSAttributedString(string: text) self.append(normal) return self } }
extension NSMutableAttributedString { @discardableResult func bold(_ text: String) -> NSMutableAttributedString { let attrs: [NSAttributedStringKey: Any] = [.font: UIFont(name: "AvenirNext-Medium", size: 12)!] let boldString = NSMutableAttributedString(string:text, attributes: attrs) append(boldString) return self } @discardableResult func normal(_ text: String) -> NSMutableAttributedString { let normal = NSAttributedString(string: text) append(normal) return self } }
let formattedString = NSMutableAttributedString() formattedString .bold("Bold Text") .normal(" Normal Text ") .bold("Bold Text") let lbl = UILabel() lbl.attributedText = formattedString
var normalText = "Hi am normal" var boldText = "And I am BOLD!" var attributedString = NSMutableAttributedString(string:normalText) var attrs = [NSFontAttributeName : UIFont.boldSystemFont(ofSize: 15)] var boldString = NSMutableAttributedString(string: boldText, attributes:attrs) attributedString.append(boldString)
extension String { var html2AttStr: NSAttributedString? { return try? NSAttributedString(data: Data(utf8), options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue], documentAttributes: nil) } } "<style type=\"text/css\">
let searchQuery = "\"\(text)\"" let message = "Query \(searchQuery). does not match any items" let range = (message as NSString).rangeOfString(searchQuery) let attributedString = NSMutableAttributedString(string: message) attributedString.addAttribute(NSFontAttributeName, value: UIFont.boldSystemFontOfSize(label.font.pointSize), range: range) label.attributedText = attributedString
import Foundation import UIKit func addBoldText(fullString: NSString, boldPartOfString: NSString, font: UIFont!, boldFont: UIFont!) -> NSAttributedString { let nonBoldFontAttribute = [NSFontAttributeName:font!] let boldFontAttribute = [NSFontAttributeName:boldFont!] let boldString = NSMutableAttributedString(string: fullString as String, attributes:nonBoldFontAttribute) boldString.addAttributes(boldFontAttribute, range: fullString.rangeOfString(boldPartOfString as String)) return boldString }
self.UILabel.attributedText = addBoldText("Check again in 30 DAYS to find more friends", boldPartOfString: "30 DAYS", font: normalFont!, boldFont: boldSearchFont!) let normalFont = UIFont(name: "INSERT FONT NAME", size: 15) let boldFont = UIFont(name: "INSERT BOLD FONT", size: 15)
func addBoldText(fullString: NSString, boldPartsOfString: Array<NSString>, font: UIFont!, boldFont: UIFont!) -> NSAttributedString { let nonBoldFontAttribute = [NSFontAttributeName:font!] let boldFontAttribute = [NSFontAttributeName:boldFont!] let boldString = NSMutableAttributedString(string: fullString as String, attributes:nonBoldFontAttribute) for i in 0 ..< boldPartsOfString.count { boldString.addAttributes(boldFontAttribute, range: fullString.rangeOfString(boldPartsOfString[i] as String)) } return boldString }
let normalFont = UIFont(name: "Dosis-Medium", size: 18) let boldSearchFont = UIFont(name: "Dosis-Bold", size: 18) self.UILabel.attributedText = addBoldText("Check again in 30 days to find more friends", boldPartsOfString: ["Check", "30 days", "find", "friends"], font: normalFont!, boldFont: boldSearchFont!)
extension String { func withBoldText(boldPartsOfString: Array<NSString>, font: UIFont!, boldFont: UIFont!) -> NSAttributedString { let nonBoldFontAttribute = [NSFontAttributeName:font!] let boldFontAttribute = [NSFontAttributeName:boldFont!] let boldString = NSMutableAttributedString(string: self as String, attributes:nonBoldFontAttribute) for i in 0 ..< boldPartsOfString.count { boldString.addAttributes(boldFontAttribute, range: (self as NSString).range(of: boldPartsOfString[i] as String)) } return boldString } }
let label = UILabel() let font = UIFont(name: "AvenirNext-Italic", size: 24)! let boldFont = UIFont(name: "AvenirNext-BoldItalic", size: 24)! label.attributedText = "Make sure your face is\nbrightly and evenly lit".withBoldText( boldPartsOfString: ["brightly", "evenly"], font: font, boldFont: boldFont)
class func createAttributedStringFrom (string1 : String ,strin2 : String, attributes1 : Dictionary<String, NSObject>, attributes2 : Dictionary<String, NSObject>) -> NSAttributedString{ let fullStringNormal = (string1 + strin2) as NSString let attributedFullString = NSMutableAttributedString(string: fullStringNormal as String) attributedFullString.addAttributes(attributes1, range: fullStringNormal.rangeOfString(string1)) attributedFullString.addAttributes(attributes2, range: fullStringNormal.rangeOfString(strin2)) return attributedFullString }
extension NSMutableAttributedString { @discardableResult func normal(_ text: String) -> NSMutableAttributedString { let normal = NSAttributedString(string: text) append(normal) return self } @discardableResult func bold(_ text: String, withLabel label: UILabel) -> NSMutableAttributedString { var font: UIFont = UIFont(name: label.font.fontName , size: label.font.pointSize)! font = UIFont(descriptor: font.fontDescriptor.withSymbolicTraits(.traitBold) ?? font.fontDescriptor, size: font.pointSize) let attrs: [NSAttributedStringKey: Any] = [NSAttributedStringKey.font: font] let boldString = NSMutableAttributedString(string:text, attributes: attrs) append(boldString) return self } }
let text = "This string is having multiple font" let attributedText = NSMutableAttributedString.getAttributedString(fromString: text) attributedText.apply(font: UIFont.boldSystemFont(ofSize: 24), subString: "This") attributedText.apply(font: UIFont.boldSystemFont(ofSize: 24), onRange: NSMakeRange(5, 6))
do { let str = try NSAttributedString(data: ("I myLabel.attributedText = str myLabel.font = MONTSERRAT_BOLD(23) myLabel.textAlignment = NSTextAlignment.left } catch { print(error) }
func MONTSERRAT_BOLD(_ size: CGFloat) -> UIFont { return UIFont(name: "MONTSERRAT-BOLD", size: size)! }
let attrString = NSMutableAttributedString() .appendWith(weight: .semibold, "almost bold") .appendWith(color: .white, weight: .bold " white and bold") .appendWith(color: .black, ofSize: 18.0, " big black")
extension NSMutableAttributedString { @discardableResult func appendWith(color: UIColor = UIColor.darkText, weight: UIFont.Weight = .regular, ofSize: CGFloat = 12.0, _ text: String) -> NSMutableAttributedString{ let attrText = NSAttributedString.makeWith(color: color, weight: weight, ofSize:ofSize, text) self.append(attrText) return self } } extension NSAttributedString { public static func makeWith(color: UIColor = UIColor.darkText, weight: UIFont.Weight = .regular, ofSize: CGFloat = 12.0, _ text: String) -> NSMutableAttributedString { let attrs = [NSAttributedStringKey.font: UIFont.systemFont(ofSize: ofSize, weight: weight), NSAttributedStringKey.foregroundColor: color] return NSMutableAttributedString(string: text, attributes:attrs) } }
extension NSMutableAttributedString { func systemFontWith(text: String, size: CGFloat, weight: CGFloat) -> NSMutableAttributedString { let attributes: [String: AnyObject] = [NSFontAttributeName: UIFont.systemFont(ofSize: size, weight: weight)] let string = NSMutableAttributedString(string: text, attributes: attributes) self.append(string) return self } }
let font = UIFont(name: "Your-Font-Name", size: 10.0)! let attributedText = NSMutableAttributedString(attributedString: noteLabel.attributedText!) let boldedRange = NSRange(attributedText.string.range(of: "Note:")!, in: attributedText.string) attributedText.addAttributes([NSAttributedString.Key.font : font], range: boldedRange) noteLabel.attributedText = attributedText
UIToolbar *toolBar=[[UIToolbar alloc]initWithFrame:CGRectMake(0,400, 320, 60)]; [self.view addSubview:toolBar]; UITextField *txtView=[[UITextField alloc]initWithFrame:CGRectMake(0, 400, 260, 30)]; txtView.backgroundColor =[UIColor grayColor]; txtView.placeholder=@"Address"; UIBarButtonItem *txtfieldItem=[[UIBarButtonItem alloc]initWithCustomView:txtView]; toolBar.items =[NSArray arrayWithObject:txtfieldItem];
UIToolbar* numberToolbar = [[UIToolbar alloc]initWithFrame:CGRectMake(0, 0, [[UIScreen mainScreen] bounds].size.width, 50)]; numberToolbar.barStyle = UIBarStyleBlackTranslucent; numberToolbar.items = [NSArray arrayWithObjects: [[UIBarButtonItem alloc]initWithTitle:@"Cancel" style:UIBarButtonItemStyleBordered target:self action:@selector(cancelNumberPad)], [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil], [[UIBarButtonItem alloc]initWithTitle:@"Done" style:UIBarButtonItemStyleDone target:self action:@selector(doneWithNumberPad)], nil]; [numberToolbar sizeToFit]; phonenumberTextField.inputAccessoryView = numberToolbar;
[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];
let numberToolbar = UIToolbar(frame: CGRectMake(0, 0, UIScreen.mainScreen().bounds.width, 50)) numberToolbar.barStyle = UIBarStyle.Default numberToolbar.items = [ UIBarButtonItem(title: "Cancel", style: UIBarButtonItemStyle.Plain, target: self, action: "cancelNumberPad"), UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.FlexibleSpace, target: nil, action: nil), UIBarButtonItem(title: "Done", style: UIBarButtonItemStyle.Plain, target: self, action: "doneWithNumberPad")] numberToolbar.sizeToFit() phonenumberTextField.inputAccessoryView = numberToolbar
let numberToolbar = UIToolbar(frame:CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 50)) numberToolbar.barStyle = .default numberToolbar.items = [ UIBarButtonItem(title: "Cancel", style: .plain, target: self, action: UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil), UIBarButtonItem(title: "Done", style: .plain, target: self, action: numberToolbar.sizeToFit() phonenumberTextField.inputAccessoryView = numberToolbar ... @objc func cancelNumberPad() { } @objc func doneWithNumberPad() { }
@IBOutlet private var toolbarView: UIView! @IBOutlet private var textView: UITextView!
override func viewDidLoad() { super.viewDidLoad() textView.inputAccessoryView = toolbarView }
let numberToolbar = UIToolbar(frame: CGRectMake(0, 0, self.view.frame.size.width, 50)) numberToolbar.barStyle = UIBarStyle.Default numberToolbar.items = [ UIBarButtonItem(title: "Cancel", style: UIBarButtonItemStyle.Plain, target: self, action: "keyboardCancelButtonTapped:"), UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.FlexibleSpace, target: nil, action: nil), UIBarButtonItem(title: "Done", style: UIBarButtonItemStyle.Plain, target: self, action: "keyboardDoneButtonTapped:")] numberToolbar.sizeToFit() yourTextView.inputAccessoryView = numberToolbar
-(void)viewdidload { UIToolbar* keyboardDoneButtonView = [[UIToolbar alloc] init]; [keyboardDoneButtonView sizeToFit]; UIBarButtonItem* doneButton = [[UIBarButtonItem alloc] initWithTitle:@"Done" style:UIBarButtonItemStyleBordered target:self action:@selector(doneClicked:)]; [keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]]; textField.inputAccessoryView = keyboardDoneButtonView; } -(void)doneClicked:(id)sender { NSLog(@"Done Clicked."); [self.view endEditing:YES]; }
let toolBar = UIToolbar(frame: CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 50)) toolBar.barStyle = UIBarStyle.default toolBar.items = [ UIBarButtonItem(title: "Button1", style: UIBarButtonItemStyle.plain, target: self, action: UIBarButtonItem(barButtonSystemItem: UIBarButtonSystemItem.flexibleSpace, target: nil, action: nil), UIBarButtonItem(title: "Button2", style: UIBarButtonItemStyle.plain, target: self, action: toolBar.sizeToFit() myTextField.inputAccessoryView = toolBar
textField.inputAccessoryView=[weakSelf addToolBar]; [textField setKeyboardType:UIKeyboardTypeNumberPad];
-(UIToolbar *)addToolBar { UIBarButtonItem *done=[[UIBarButtonItem alloc]initWithTitle:@"DONE" style:UIBarButtonItemStyleDone target:self action:@selector(done:)]; UIToolbar *toolBar=[[UIToolbar alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 30)]; NSArray* toolBarItems=[[NSArray alloc]initWithObjects:done, nil]; [toolBar setItems:toolBarItems]; return toolBar; }
let toolBar = UIToolbar() toolBar.barStyle = UIBarStyle.default toolBar.isTranslucent = true toolBar.isUserInteractionEnabled = true toolBar.sizeToFit() toolBar.items = [ UIBarButtonItem(title: "Done", style: UIBarButtonItemStyle.plain, target: self, action: tfPhone.inputAccessoryView = toolBar
final class C : P { func copy() -> C { return C() } }
protocol Copyable { init(copy: Self) } class C : Copyable { required init(copy: C) { } }
protocol Copyable { func copy() -> Self init(copy: Self) } class C : Copyable { func copy() -> Self { return self.dynamicType(copy: self) } required init(copy: C) { } }
protocol Copyable { init(copy:Self) } extension Copyable { func copy() -> Self { return Self.init(copy: self) } }
func autocast<T>(some: Any) -> T? { return some as? T } protocol Foo { static func foo() -> Self } class Vehicle: Foo { class func foo() -> Self { return autocast(Vehicle())! } } class Tractor: Vehicle { override class func foo() -> Self { return autocast(Tractor())! } } func typeName(some: Any) -> String { return (some is Any.Type) ? "\(some)" : "\(some.dynamicType)" } let vehicle = Vehicle.foo() let tractor = Tractor.foo() print(typeName(vehicle)) print(typeName(tractor))
public protocol Creatable { associatedtype ObjectType = Self static func create() -> ObjectType } class MyClass { } extension MyClass: Creatable { static func create() -> MyClass { return MyClass() } } let obj = MyClass.create()
protocol Copyable, NSCopying { typealias Prototype init(copy: Prototype) init(deepCopy: Prototype) } class C : Copyable { typealias Prototype = C required init(copy: Prototype) { } required init(deepCopy: Prototype) { } @objc func copyWithZone(zone: NSZone) -> AnyObject { return Prototype(copy: self) } }
protocol P { func copy() -> P } class C:P { func doCopy() -> C { return C() } func copy() -> C { return doCopy() } func copy() -> P { return doCopy() } }
var aC:C = C() var aP:P = aC var bC:C var bP:P bC = aC.copy() bP = aC.copy() bP = (aC as P).copy() bC = aP.copy() bP = aP.copy()
protocol P { func copyAsP() -> P } class C:P { func copy() -> C { return C() } func copyAsP() -> P { return copy() } }
protocol Mappable{ static func map() -> Self? } extension SomeSpecificClass : Mappable{ static func map() -> Self? { ... } }
protocol Mappable{ associatedtype ExplicitSelf = Self static func map() -> ExplicitSelf? } extension SomeSpecificClass : Mappable{ static func map() -> SomeSpecificClass? { ... } }
protocol Initializable { init() } protocol Creatable: Initializable { associatedtype Object: Initializable = Self static func newInstance() -> Object } extension Creatable { static func newInstance() -> Object { return Object() } } class MyClass: Creatable { required init() {} } class MyOtherClass: Creatable { required init() {} } let instance1 = MyClass.newInstance() let instance2 = MyOtherClass.newInstance()
let myString = "I love \"unnecessary\" quotation marks" let myString = "I love \u{22}unnecessary\u{22} quotation marks"
let string = "A string with \"double quotes\" in it." print(string)
let string = "A string with \u{22}double quotes\u{22} in it." print(string)
let string = """ A string with "double quotes" in it. """ print(string)
collectionView.registerClass(NSClassFromString("MyCoolViewCell"), forCellWithReuseIdentifier: "MyCoolViewCell")
collectionView.registerClass(MyCoolViewCell.self, forCellWithReuseIdentifier: "MyCoolViewCell")
let nib = UINib(nibName: "MyCoolViewCell", bundle: nil) collectionView?.register(nib, forCellWithReuseIdentifier: "MyCoolViewCellIdentifier")
self.collectionView.register(CustomCollectionViewCell.self, forCellWithReuseIdentifier: "CustomCollectionViewCellReuseIdentifier")
import UIKit let lbl = UILabel(frame: CGRectMake(0, 0, 300, 100)) lbl.text = "Hello StackOverflow!"
import XCPlayground import UIKit XCPlaygroundPage.currentPage.needsIndefiniteExecution = true func delay(delay:Double, closure:()->()) { dispatch_after( dispatch_time( DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC)) ), dispatch_get_main_queue(), closure) } let color = UIColor(red: 1, green: 1, blue: 0, alpha: 1) let leftMargin = 20 let view = UIView(frame: CGRect(x: 0, y: 0, width: 375, height: 667)) view.backgroundColor = UIColor.grayColor() let label = UILabel(frame: CGRect(x: leftMargin, y: 5, width: 300, height: 44)) label.text = "Hello, playground" label.textColor = UIColor.whiteColor() view.addSubview(label) let textField = UITextField(frame: CGRect(x: leftMargin, y: 60, width: 300, height: 44)) textField.placeholder = "Edit me‚Ä¶" textField.backgroundColor = UIColor(white: 1, alpha: 0.5) textField.textColor = UIColor.whiteColor() textField.userInteractionEnabled = true view.addSubview(textField) XCPlaygroundPage.currentPage.liveView = view delay(1.0) { () -> () in textField.text = "New text!" }
import PlaygroundSupport PlaygroundPage.current.liveView = view
NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
let bundleID = NSBundle.mainBundle().bundleIdentifier
let bundleIdentifier = Bundle.main.bundleIdentifier
NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
let bundleIdentifier = Bundle.main.bundleIdentifier
func webViewDidStartLoad(webView: UIWebView){} func webViewDidFinishLoad(webView: UIWebView){}
func webView(webView: UIWebView, shouldStartLoadWithRequest request: NSURLRequest, navigationType: UIWebViewNavigationType) -> Bool { print("webview asking for permission to start loading") if navigationType == .LinkActivated && !(request.URL?.absoluteString.hasPrefix("http: UIApplication.sharedApplication().openURL(request.URL!) print(request.URL?.absoluteString) return false } print(request.URL?.absoluteString) lastUrl = (request.URL?.absoluteString)! return true } func webView(webView: UIWebView, didFailLoadWithError error: NSError?) { print("webview did fail load with error: \(error)") let testHTML = NSBundle.mainBundle().pathForResource("back-error-bottom", ofType: "jpg") let baseUrl = NSURL(fileURLWithPath: testHTML!) let htmlString:String! = "myErrorinHTML" self.webView.loadHTMLString(htmlString, baseURL: baseUrl) }
didFailLoadWithError => didFailNavigation webViewDidFinishLoad => didFinishNavigation webViewDidStartLoad => didStartProvisionalNavigation shouldStartLoadWithRequest => decidePolicyForNavigationAction
func webView(webView: WKWebView, decidePolicyForNavigationAction navigationAction: WKNavigationAction, decisionHandler: ((WKNavigationActionPolicy) -> Void)) { print("webView:\(webView) decidePolicyForNavigationAction:\(navigationAction) decisionHandler:\(decisionHandler)") switch navigationAction.navigationType { case .LinkActivated: if navigationAction.targetFrame == nil { self.webView?.loadRequest(navigationAction.request) } if let url = navigationAction.request.URL where !url.absoluteString.hasPrefix("http: UIApplication.sharedApplication().openURL(url) print(url.absoluteString) decisionHandler(.Cancel) return } default: break } if let url = navigationAction.request.URL { print(url.absoluteString) } decisionHandler(.Allow) }
func webView(webView: WKWebView, didFailNavigation navigation: WKNavigation, withError error: NSError) { print("webView:\(webView) didFailNavigation:\(navigation) withError:\(error)") let testHTML = NSBundle.mainBundle().pathForResource("back-error-bottom", ofType: "jpg") let baseUrl = NSURL(fileURLWithPath: testHTML!) let htmlString:String! = "myErrorinHTML" self.webView.loadHTMLString(htmlString, baseURL: baseUrl) }
func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) { var action: WKNavigationActionPolicy? defer { decisionHandler(action ?? .allow) } guard let url = navigationAction.request.url else { return } print(url) if navigationAction.navigationType == .linkActivated, url.absoluteString.hasPrefix("http: action = .cancel UIApplication.shared.openURL(url) } }
func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) { print(String(describing: webView.url)) }
func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) { let nserror = error as NSError if nserror.code != NSURLErrorCancelled { webView.loadHTMLString("404 - Page Not Found", baseURL: URL(string: "http: } }
func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) { print(String(describing: webView.url)) }
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler { if (navigationAction.navigationType == UIWebViewNavigationTypeLinkClicked) { } NSString *url = [navigationAction.request.URL query]; decisionHandler(WKNavigationActionPolicyAllow); }
- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation { }
- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation { }
- (void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error { }
required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) }
class ViewController: UIViewController { var imageURL: NSURL? convenience init() { self.init(imageURL: nil) } init(imageURL: NSURL?) { self.imageURL = imageURL super.init(nibName: nil, bundle: nil) } /* Xcode 6 required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } */ required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } }
import UIKit struct Player { let name: String let age: Int } class VC: UIViewController { @IBOutlet weak var playerName: UILabel! let player: Player init(player: Player) { self.player = player super.init(nibName: "VC", bundle: Bundle.main) if let view = view, view.isHidden {} } override func viewDidLoad() { super.viewDidLoad() configure() } func configure() { playerName.text = player.name + "\(player.age)" } } func showPlayerVC() { let foo = Player(name: "bar", age: 666) let vc = VC(player: foo) present(vc, animated: true, completion: nil) }
enum CardRank { case Number(Int) case Jack case Queen case King case Ace } func ==(a: CardRank, b: CardRank) -> Bool { switch (a, b) { case (.Number(let a), .Number(let b)) where a == b: return true case (.Jack, .Jack): return true case (.Queen, .Queen): return true case (.King, .King): return true case (.Ace, .Ace): return true default: return false } }
let card: CardRank = CardRank.Jack if card == CardRank.Jack { print("You played a jack!") } else if card == CardRank.Number(2) { print("A two cannot be played at this time.") }
let number = CardRank.Number(5) if number == CardRank.Number { print("You must play a face card!") }
switch number { case .Number: print("You must play a face card!") default: break }
let number = CardRank.Number(5) if case .Number(_) = number { } else { }
if case .Number = number { } if case .Number(let x) = number { }
enum CardRank: Equatable { case Number(Int) case Jack case Queen case King case Ace }
enum CardRank { case Two case Three case Four case Five case Six case Seven case Eight case Nine case Ten case Jack case Queen case King case Ace var isFaceCard: Bool { return (self == Jack) || (self == Queen) || (self == King) } }
let card = CardRank.Jack if card == CardRank.Jack { print("You played a jack") } else if !card.isFaceCard { print("You must play a face card!") }
struct Customer { let id: String let email: String let metadata: [String: Any] }
{ "object": "customer", "id": "4yq6txdpfadhbaqnwp3", "email": "john.doe@example.com", "metadata": { "link_id": "linked-id", "buy_count": 4 } }
let dictionary: [String: Any] = try container.decode([String: Any].self, forKey: key)
let array: [Any] = try container.decode([Any].self, forKey: key)
let items: [[String: Any]] = try container.decode(Array<Any>.self, forKey: .items) as! [[String: Any]]
guard let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] else { return }
struct JSONCodingKeys: CodingKey { var stringValue: String init?(stringValue: String) { self.stringValue = stringValue } var intValue: Int? init?(intValue: Int) { self.init(stringValue: "\(intValue)") self.intValue = intValue } } extension KeyedDecodingContainer { func decode(_ type: Dictionary<String, Any>.Type, forKey key: K) throws -> Dictionary<String, Any> { let container = try self.nestedContainer(keyedBy: JSONCodingKeys.self, forKey: key) return try container.decode(type) } func decodeIfPresent(_ type: Dictionary<String, Any>.Type, forKey key: K) throws -> Dictionary<String, Any>? { guard contains(key) else { return nil } guard try decodeNil(forKey: key) == false else { return nil } return try decode(type, forKey: key) } func decode(_ type: Array<Any>.Type, forKey key: K) throws -> Array<Any> { var container = try self.nestedUnkeyedContainer(forKey: key) return try container.decode(type) } func decodeIfPresent(_ type: Array<Any>.Type, forKey key: K) throws -> Array<Any>? { guard contains(key) else { return nil } guard try decodeNil(forKey: key) == false else { return nil } return try decode(type, forKey: key) } func decode(_ type: Dictionary<String, Any>.Type) throws -> Dictionary<String, Any> { var dictionary = Dictionary<String, Any>() for key in allKeys { if let boolValue = try? decode(Bool.self, forKey: key) { dictionary[key.stringValue] = boolValue } else if let stringValue = try? decode(String.self, forKey: key) { dictionary[key.stringValue] = stringValue } else if let intValue = try? decode(Int.self, forKey: key) { dictionary[key.stringValue] = intValue } else if let doubleValue = try? decode(Double.self, forKey: key) { dictionary[key.stringValue] = doubleValue } else if let nestedDictionary = try? decode(Dictionary<String, Any>.self, forKey: key) { dictionary[key.stringValue] = nestedDictionary } else if let nestedArray = try? decode(Array<Any>.self, forKey: key) { dictionary[key.stringValue] = nestedArray } } return dictionary } } extension UnkeyedDecodingContainer { mutating func decode(_ type: Array<Any>.Type) throws -> Array<Any> { var array: [Any] = [] while isAtEnd == false { if try decodeNil() { continue } else if let value = try? decode(Bool.self) { array.append(value) } else if let value = try? decode(Double.self) { array.append(value) } else if let value = try? decode(String.self) { array.append(value) } else if let nestedDictionary = try? decode(Dictionary<String, Any>.self) { array.append(nestedDictionary) } else if let nestedArray = try? decode(Array<Any>.self) { array.append(nestedArray) } } return array } mutating func decode(_ type: Dictionary<String, Any>.Type) throws -> Dictionary<String, Any> { let nestedContainer = try self.nestedContainer(keyedBy: JSONCodingKeys.self) return try nestedContainer.decode(type) } }
public enum JSON { case string(String) case number(Float) case object([String:JSON]) case array([JSON]) case bool(Bool) case null }
public protocol JSONType: Decodable { var jsonValue: Any { get } } extension Int: JSONType { public var jsonValue: Any { return self } } extension String: JSONType { public var jsonValue: Any { return self } } extension Double: JSONType { public var jsonValue: Any { return self } } extension Bool: JSONType { public var jsonValue: Any { return self } } public struct AnyJSONType: JSONType { public let jsonValue: Any public init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() if let intValue = try? container.decode(Int.self) { jsonValue = intValue } else if let stringValue = try? container.decode(String.self) { jsonValue = stringValue } else if let boolValue = try? container.decode(Bool.self) { jsonValue = boolValue } else if let doubleValue = try? container.decode(Double.self) { jsonValue = doubleValue } else if let doubleValue = try? container.decode(Array<AnyJSONType>.self) { jsonValue = doubleValue } else if let doubleValue = try? container.decode(Dictionary<String, AnyJSONType>.self) { jsonValue = doubleValue } else { throw DecodingError.typeMismatch(JSONType.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Unsupported JSON tyep")) } } }
metadata = try container.decode ([String: AnyJSONValue].self, forKey: .metadata)
metadata = try container.decode ([String: Any].self, forKey: .metadata)
var json = """ { "id": 12345, "name": "Giuseppe", "last_name": "Lanza", "age": 31, "happy": true, "rate": 1.5, "classes": ["maths", "phisics"], "dogs": [ { "name": "Gala", "age": 1 }, { "name": "Aria", "age": 3 } ] } """
public struct AnyDecodable: Decodable { public var value: Any private struct CodingKeys: CodingKey { var stringValue: String var intValue: Int? init?(intValue: Int) { self.stringValue = "\(intValue)" self.intValue = intValue } init?(stringValue: String) { self.stringValue = stringValue } } public init(from decoder: Decoder) throws { if let container = try? decoder.container(keyedBy: CodingKeys.self) { var result = [String: Any]() try container.allKeys.forEach { (key) throws in result[key.stringValue] = try container.decode(AnyDecodable.self, forKey: key).value } value = result } else if var container = try? decoder.unkeyedContainer() { var result = [Any]() while !container.isAtEnd { result.append(try container.decode(AnyDecodable.self).value) } value = result } else if let container = try? decoder.singleValueContainer() { if let intVal = try? container.decode(Int.self) { value = intVal } else if let doubleVal = try? container.decode(Double.self) { value = doubleVal } else if let boolVal = try? container.decode(Bool.self) { value = boolVal } else if let stringVal = try? container.decode(String.self) { value = stringVal } else { throw DecodingError.dataCorruptedError(in: container, debugDescription: "the container contains nothing serialisable") } } else { throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Could not serialise")) } } }
let stud = try! JSONDecoder().decode(AnyDecodable.self, from: jsonData).value as! [String: Any] print(stud)
let json: [String: Any] = [ "object": "customer", "id": "4yq6txdpfadhbaqnwp3", "email": "john.doe@example.com", "metadata": [ "link_id": "linked-id", "buy_count": 4 ] ] struct Customer: Codable { let object: String let id: String let email: String let metadata: Metadata } struct Metadata: Codable { let link_id: String let buy_count: Int } let data = try JSONSerialization.data(withJSONObject: json, options: .prettyPrinted) let decoder = JSONDecoder() do { let customer = try decoder.decode(Customer.self, from: data) print(customer) } catch { print(error.localizedDescription) }
import BeyovaJSON struct Customer: Codable { let id: String let email: String let metadata: JToken } customer.metadata = ["link_id": "linked-id","buy_count": 4] let encoder = JSONEncoder() encoder.outputFormatting = .prettyPrinted print(String(bytes: try! encoder.encode(customer), encoding: .utf8)!)
struct Metadata: Codable { var link_id: String? var buy_count: Int? } struct Customer: Codable { var object: String? var id: String? var email: String? var metadata: Metadata? } struct CustomerParser { var customer: Customer? } extension CustomerParser: Decodable { enum CustomerKeys: String, CodingKey { case object = "object" case id = "id" case email = "email" case metadata = "metadata" } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CustomerKeys.self) let object: String = try container.decode(String.self, forKey: .object) let id: String = try container.decode(String.self, forKey: .id) let email: String = try container.decode(String.self, forKey: .email) let metadata: Metadata = try container.decode(Metadata.self, forKey: .metadata) self.init(customer: Customer(object: object, id: id, email: email, metadata: metadata)) } }
if let url = Bundle.main.url(forResource: "customer-json-file", withExtension: "json") { do { let jsonData: Data = try Data(contentsOf: url) let parser: CustomerParser = try JSONDecoder().decode(CustomerParser.self, from: jsonData) print(parser.customer ?? "null") } catch { } }
extension Customer: Decodable { public init(from decoder: Decoder) throws { let selfContainer = try decoder.container(keyedBy: CodingKeys.self) id = try selfContainer.decode(.id) email = try selfContainer.decode(.email) let metadataContainer: JsonContainer = try selfContainer.decode(.metadata) guard let metadata = metadataContainer.value as? [String: Any] else { let context = DecodingError.Context(codingPath: [CodingKeys.metadata], debugDescription: "Expected throw DecodingError.typeMismatch([String: Any].self, context) } self.metadata = metadata } private enum CodingKeys: String, CodingKey { case id, email, metadata } }
struct JsonContainer { let value: Any } extension JsonContainer: Decodable { public init(from decoder: Decoder) throws { if let keyedContainer = try? decoder.container(keyedBy: Key.self) { var dictionary = [String: Any]() for key in keyedContainer.allKeys { if let value = try? keyedContainer.decode(Bool.self, forKey: key) { dictionary[key.stringValue] = NSNumber(value: value) } else if let value = try? keyedContainer.decode(Int64.self, forKey: key) { dictionary[key.stringValue] = NSNumber(value: value) } else if let value = try? keyedContainer.decode(Double.self, forKey: key) { dictionary[key.stringValue] = NSNumber(value: value) } else if let value = try? keyedContainer.decode(String.self, forKey: key) { dictionary[key.stringValue] = value } else if (try? keyedContainer.decodeNil(forKey: key)) ?? false { } else if let value = try? keyedContainer.decode(JsonContainer.self, forKey: key) { dictionary[key.stringValue] = value.value } else { throw DecodingError.dataCorruptedError(forKey: key, in: keyedContainer, debugDescription: "Unexpected value for \(key.stringValue) key") } } value = dictionary } else if var unkeyedContainer = try? decoder.unkeyedContainer() { var array = [Any]() while !unkeyedContainer.isAtEnd { let container = try unkeyedContainer.decode(JsonContainer.self) array.append(container.value) } value = array } else if let singleValueContainer = try? decoder.singleValueContainer() { if let value = try? singleValueContainer.decode(Bool.self) { self.value = NSNumber(value: value) } else if let value = try? singleValueContainer.decode(Int64.self) { self.value = NSNumber(value: value) } else if let value = try? singleValueContainer.decode(Double.self) { self.value = NSNumber(value: value) } else if let value = try? singleValueContainer.decode(String.self) { self.value = value } else if singleValueContainer.decodeNil() { value = NSNull() } else { throw DecodingError.dataCorruptedError(in: singleValueContainer, debugDescription: "Unexpected value") } } else { let context = DecodingError.Context(codingPath: [], debugDescription: "Invalid data format for JSON") throw DecodingError.dataCorrupted(context) } } private struct Key: CodingKey { var stringValue: String init?(stringValue: String) { self.stringValue = stringValue } var intValue: Int? init?(intValue: Int) { self.init(stringValue: "\(intValue)") self.intValue = intValue } } }
import SwiftyJSON struct Customer { let id: String let email: String let metadata: JSON }
struct Customer: Decodable { struct Metadata: Decodable { var linkId: String? var buyCount: Int? var somethingElse: Int? private enum CodingKeys: String, CodingKey { case linkId = "link_id" case buyCount = "buy_count" case somethingElse = "something_else" } } var object: String var id: String var email: String var metadata: Metadata } let customer = try! JSONDecoder().decode(Customer.self, from: jsonData) print(customer.metadata)
struct Customer { private struct RawCustomer: Decodable { var object: String var id: String var email: String } var object: String var id: String var email: String var metadata: [String: AnyObject] init(jsonData: Data) throws { let rawCustomer = try JSONDecoder().decode(RawCustomer.self, from: jsonData) object = rawCustomer.object id = rawCustomer.id email = rawCustomer.email let jsonObject = try JSONSerialization.jsonObject(with: jsonData) if let dict = jsonObject as? [String: AnyObject], let metadata = dict["metadata"] as? [String: AnyObject] { self.metadata = metadata } else { self.metadata = [String: AnyObject]() } } } let customer = try! Customer(jsonData: jsonData) print(customer.metadata)
struct UserDetails{ var userName:String var userID:String var userAge:String func userDescription()->String{ return "name " + userName + "age " + userID } }
for a in 1...1000{ var user:UserDetails = UserDetails(userName: "name", userID: String(a), userAge: "22") arrayOfUsers.append(user) }
let filteredArray = arrayOfUsers.filter() { $0.userID == "1" }
var filteredArray = arrayOfUsers.filter( { (user: UserDetails) -> Bool in return user.userID == "1" })
var customerNameDict = ["firstName":"karthi","LastName":"alagu","MiddleName":"prabhu"]; var clientNameDict = ["firstName":"Selva","LastName":"kumar","MiddleName":"m"]; var employeeNameDict = ["firstName":"karthi","LastName":"prabhu","MiddleName":"kp"]; var attributeValue = "karthi"; var arrNames:Array = [customerNameDict,clientNameDict,employeeNameDict]; var namePredicate = NSPredicate(format: "firstName like %@",attributeValue); let filteredArray = arrNames.filter { namePredicate.evaluateWithObject($0) }; println("names = ,\(filteredArray)");
struct myStruct { var userid:String; var details:String; init() { userid = "default value"; details = "default"; } }; var f1 = myStruct(); f1.userid = "1"; f1.details = "Good boy"; var f2 = myStruct(); f2.userid = "2"; f2.details = "Bad boy"; var arrNames1:Array = [f1,f2]; let filteredArrayStruct = arrNames1.filter( { (user: myStruct) -> Bool in return user.userid == "1" }) println("filter array count = \(filteredArrayStruct.count)"); for filteredValues in filteredArrayStruct { println("filteredArrayStruct = ,\(filteredValues.details)"); }
var visitors = [["age" : 22], ["age" : 41], ["age" : 23], ["age" : 30]] var filteredVisitors = visitors.filter({ $0["age"] < 30 }) println(filteredVisitors)
struct Person { var age : Int? init(age: Int) { self.age = age } } var eventAttendees = [Person(age: 22), Person(age: 41), Person(age: 23), Person(age: 30)] var filteredAttendees = eventAttendees.filter({ $0.age < 30 })
let pred : NSPredicate = NSPredicate(format: "points_status = %@", "0") let approvalRequestArray = approvalRequestOriginalArray.filtered(using: pred) as NSArray let provincesStartingWithM = NSPredicate(format: "name contains [cd] provinces.filtered(using: provincesStartingWithM)
var foundArray = tempArray.filter{ String(describing:$0.id) .contains(searchText) || $0.name .contains(searchText) || $0.summary! .contains(searchText) || String(describing: $0.airDate).contains(searchText) || String(describing: $0.airTime).contains(searchText) || String(describing: $0.runTime).contains(searchText)}
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if (segue.identifier == "getImage") { var svc = segue.destinationViewController as! ClothesDetail svc.imagePassed = imageView.image } }
let imageData = UIImagePNGRepresentation(imagePassed) let imageFile = PFFile(name: "\(picName).png", data: imageData) var userpic = PFObject(className:"UserPic") userpic["picImage"] = imageFile`
extension UIImage { enum JPEGQuality: CGFloat { case lowest = 0 case low = 0.25 case medium = 0.5 case high = 0.75 case highest = 1 } func jpeg(_ quality: JPEGQuality) -> Data? { return UIImageJPEGRepresentation(self, quality.rawValue) } }
extension UIImage { enum JPEGQuality: CGFloat { case lowest = 0 case low = 0.25 case medium = 0.5 case high = 0.75 case highest = 1 } func jpeg(_ jpegQuality: JPEGQuality) -> Data? { return jpegData(compressionQuality: jpegQuality.rawValue) } }
if let imageData = image.jpeg(.lowest) { print(imageData.count) }
import UIKit extension UIImage { func compressTo(_ expectedSizeInMb:Int) -> UIImage? { let sizeInBytes = expectedSizeInMb * 1024 * 1024 var needCompress:Bool = true var imgData:Data? var compressingValue:CGFloat = 1.0 while (needCompress && compressingValue > 0.0) { if let data:Data = UIImageJPEGRepresentation(self, compressingValue) { if data.count < sizeInBytes { needCompress = false imgData = data } else { compressingValue -= 0.1 } } } if let data = imgData { if (data.count < sizeInBytes) { return UIImage(data: data) } } return nil } }
extension UIImage { var highestQualityJPEGNSData: NSData { return UIImageJPEGRepresentation(self, 1.0)! } var highQualityJPEGNSData: NSData { return UIImageJPEGRepresentation(self, 0.75)!} var mediumQualityJPEGNSData: NSData { return UIImageJPEGRepresentation(self, 0.5)! } var lowQualityJPEGNSData: NSData { return UIImageJPEGRepresentation(self, 0.25)!} var lowestQualityJPEGNSData: NSData { return UIImageJPEGRepresentation(self, 0.0)! } }
let imageData = imagePassed.lowestQualityJPEGNSData
func resizeImage(image: UIImage) -> UIImage { var actualHeight: Float = Float(image.size.height) var actualWidth: Float = Float(image.size.width) let maxHeight: Float = 300.0 let maxWidth: Float = 400.0 var imgRatio: Float = actualWidth / actualHeight let maxRatio: Float = maxWidth / maxHeight let compressionQuality: Float = 0.5 if actualHeight > maxHeight || actualWidth > maxWidth { if imgRatio < maxRatio { imgRatio = maxHeight / actualHeight actualWidth = imgRatio * actualWidth actualHeight = maxHeight } else if imgRatio > maxRatio { imgRatio = maxWidth / actualWidth actualHeight = imgRatio * actualHeight actualWidth = maxWidth } else { actualHeight = maxHeight actualWidth = maxWidth } } let rect = CGRectMake(0.0, 0.0, CGFloat(actualWidth), CGFloat(actualHeight)) UIGraphicsBeginImageContext(rect.size) image.drawInRect(rect) let img = UIGraphicsGetImageFromCurrentImageContext() let imageData = UIImageJPEGRepresentation(img!,CGFloat(compressionQuality)) UIGraphicsEndImageContext() return UIImage(data: imageData!)! }
extension UIImage { func resizeByByte(maxByte: Int, completion: @escaping (Data) -> Void) { var compressQuality: CGFloat = 1 var imageData = Data() var imageByte = UIImageJPEGRepresentation(self, 1)?.count while imageByte! > maxByte { imageData = UIImageJPEGRepresentation(self, compressQuality)! imageByte = UIImageJPEGRepresentation(self, compressQuality)?.count compressQuality -= 0.1 } if maxByte > imageByte! { completion(imageData) } else { completion(UIImageJPEGRepresentation(self, 1)!) } }
image.resizeByByte(maxByte: 300000) { (resizedData) in print("image size: \(resizedData.count)") }
extension UIImage { enum CompressImageErrors: Error { case invalidExSize case sizeImpossibleToReach } func compressImage(_ expectedSizeKb: Int, completion : (UIImage,CGFloat) -> Void ) throws { let minimalCompressRate :CGFloat = 0.4 if expectedSizeKb == 0 { throw CompressImageErrors.invalidExSize } let expectedSizeBytes = expectedSizeKb * 1024 let imageToBeHandled: UIImage = self var actualHeight : CGFloat = self.size.height var actualWidth : CGFloat = self.size.width var maxHeight : CGFloat = 841 var maxWidth : CGFloat = 594 var imgRatio : CGFloat = actualWidth/actualHeight let maxRatio : CGFloat = maxWidth/maxHeight var compressionQuality : CGFloat = 1 var imageData:Data = UIImageJPEGRepresentation(imageToBeHandled, compressionQuality)! while imageData.count > expectedSizeBytes { if (actualHeight > maxHeight || actualWidth > maxWidth){ if(imgRatio < maxRatio){ imgRatio = maxHeight / actualHeight; actualWidth = imgRatio * actualWidth; actualHeight = maxHeight; } else if(imgRatio > maxRatio){ imgRatio = maxWidth / actualWidth; actualHeight = imgRatio * actualHeight; actualWidth = maxWidth; } else{ actualHeight = maxHeight; actualWidth = maxWidth; compressionQuality = 1; } } let rect = CGRect(x: 0.0, y: 0.0, width: actualWidth, height: actualHeight) UIGraphicsBeginImageContext(rect.size); imageToBeHandled.draw(in: rect) let img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); if let imgData = UIImageJPEGRepresentation(img!, compressionQuality) { if imgData.count > expectedSizeBytes { if compressionQuality > minimalCompressRate { compressionQuality -= 0.1 } else { maxHeight = maxHeight * 0.9 maxWidth = maxWidth * 0.9 } } imageData = imgData } } completion(UIImage(data: imageData)!, compressionQuality) } }
do { try UiImageView.image?.compressImage(100, completion: { (image, compressRatio) in print(image.size) imageData = UIImageJPEGRepresentation(image, compressRatio) base64data = imageData?.base64EncodedString() }) } catch { print("Error") }
extension UIImage { func resizeToApprox(sizeInMB: Double, deltaInMB: Double = 0.2) -> Data { let allowedSizeInBytes = Int(sizeInMB * 1024 * 1024) let deltaInBytes = Int(deltaInMB * 1024 * 1024) let fullResImage = UIImageJPEGRepresentation(self, 1.0) if (fullResImage?.count)! < Int(deltaInBytes + allowedSizeInBytes) { return fullResImage! } var i = 0 var left:CGFloat = 0.0, right: CGFloat = 1.0 var mid = (left + right) / 2.0 var newResImage = UIImageJPEGRepresentation(self, mid) while (true) { i += 1 if (i > 13) { print("Compression ran too many times ") break } print("mid = \(mid)") if ((newResImage?.count)! < (allowedSizeInBytes - deltaInBytes)) { left = mid } else if ((newResImage?.count)! > (allowedSizeInBytes + deltaInBytes)) { right = mid } else { print("loop ran \(i) times") return newResImage! } mid = (left + right) / 2.0 newResImage = UIImageJPEGRepresentation(self, mid) } return UIImageJPEGRepresentation(self, 0.5)! } }
extension UIImage { var uncompressedPNGData: Data? { return UIImagePNGRepresentation(self) } var highestQualityJPEGNSData: Data? { return UIImageJPEGRepresentation(self, 1.0) } var highQualityJPEGNSData: Data? { return UIImageJPEGRepresentation(self, 0.75) } var mediumQualityJPEGNSData: Data? { return UIImageJPEGRepresentation(self, 0.5) } var lowQualityJPEGNSData: Data? { return UIImageJPEGRepresentation(self, 0.25) } var lowestQualityJPEGNSData:Data? { return UIImageJPEGRepresentation(self, 0.0) } }
func ResizeImageOriginalSize(targetSize: CGSize) -> UIImage { var actualHeight: Float = Float(self.size.height) var actualWidth: Float = Float(self.size.width) let maxHeight: Float = Float(targetSize.height) let maxWidth: Float = Float(targetSize.width) var imgRatio: Float = actualWidth / actualHeight let maxRatio: Float = maxWidth / maxHeight var compressionQuality: Float = 0.5 if actualHeight > maxHeight || actualWidth > maxWidth { if imgRatio < maxRatio { imgRatio = maxHeight / actualHeight actualWidth = imgRatio * actualWidth actualHeight = maxHeight } else if imgRatio > maxRatio { imgRatio = maxWidth / actualWidth actualHeight = imgRatio * actualHeight actualWidth = maxWidth } else { actualHeight = maxHeight actualWidth = maxWidth compressionQuality = 1.0 } } let rect = CGRect(x: 0.0, y: 0.0, width: CGFloat(actualWidth), height: CGFloat(actualHeight)) UIGraphicsBeginImageContextWithOptions(rect.size, false, CGFloat(compressionQuality)) self.draw(in: rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! }
import Foundation private var nextNonce = 1000 class Command: NSCoding { let nonce: Int let string: String! init(string: String) { self.nonce = nextNonce++ self.string = string } required init(coder aDecoder: NSCoder) { nonce = aDecoder.decodeIntegerForKey("nonce") string = aDecoder.decodeObjectForKey("string") as String } func encodeWithCoder(aCoder: NSCoder) { aCoder.encodeInteger(nonce, forKey: "nonce") aCoder.encodeObject(string, forKey: "string") } }
2014-09-12 16:30:00.463 MyApp[30078:60b] *** NSForwarding: warning: object 0x7a04ac70 of class Unrecognized selector -[MyApp.Command replacementObjectForKeyedArchiver:]
func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { var cell : UITableViewCell = tableView.dequeueReusableCellWithIdentifier("Cell") as UITableViewCell if (cell == nil) { cell = UITableViewCell(style: UITableViewCellStyle.Value1, reuseIdentifier: "Cell") } cell.textLabel.text = "TEXT" cell.detailTextLabel.text = "DETAIL TEXT" return cell }
var cell = tableView.dequeueReusableCellWithIdentifier("CELL") as? UITableViewCell if cell == nil { cell = UITableViewCell(style: UITableViewCellStyle.Value1, reuseIdentifier: "CELL") } cell!.textLabel.text = "Baking Soda" cell!.detailTextLabel.text = "1/2 cup" cell!.textLabel.text = "Hello World" return cell
override func viewDidLoad() { super.viewDidLoad() self.tableView.registerClass(MyCell.self, forCellReuseIdentifier: "Cell") } override func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { let cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath:indexPath) as MyCell cell.textLabel.text = return cell }
func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { var cell = tableView.dequeueReusableCellWithIdentifier("CELL") as UITableViewCell! if !cell { cell = UITableViewCell(style:.Default, reuseIdentifier: "CELL") } cell.textLabel.text = "Swift" return cell }
func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { let cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as UITableViewCell cell.textLabel.text = "\(indexPath.row)" return cell }
tableView.delegate = self tableView.dataSource = self tableView.registerClass(UITableViewCell.classForCoder(), forCellReuseIdentifier: "Cell")
self.tableView.registerClass(MyTableViewCell.self, forCellReuseIdentifier: "Cell")
func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { var cell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as MyTableViewCell cell.textLabel.text = "Cell Text" cell.detailTextLabel.text = "Cell Detail Text in Value 1 Style" return cell }
class MyTableViewCell : UITableViewCell { init(style: UITableViewCellStyle, reuseIdentifier: String!) { super.init(style: UITableViewCellStyle.Value1, reuseIdentifier: reuseIdentifier) } }
var cell:UITableViewCell if let c = tableView.dequeueReusableCellWithIdentifier("cell") as? UITableViewCell { cell = c } else { cell = UITableViewCell() }
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let identifier = "cell" let cell = tableView.dequeueReusableCellWithIdentifier(identifier) ?? UITableViewCell.init(style: UITableViewCellStyle.Default, reuseIdentifier: identifier) cell.textLabel!.text = "my text" return cell }
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let identifier = "cell" let cell = tableView.dequeueReusableCell(withIdentifier: identifier) ?? UITableViewCell(style: .default, reuseIdentifier: identifier) cell.textLabel!.text = "my text" return cell }
class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var mTableView: UITableView! var items: [String] = ["Item 1","Item 2","Item 3", "Item 4", "Item 5"] override func viewDidLoad() { super.viewDidLoad() self.mTableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: "cell") } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return self.items.count; } func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { var cell:UITableViewCell = self.mTableView.dequeueReusableCellWithIdentifier("cell") as! UITableViewCell cell.textLabel?.text = self.items[indexPath.row] println(self.items[indexPath.row]) return cell } func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { println("You have selected cell } }
var identifer: String = "myCell" var cell = tableView.dequeueReusableCellWithIdentifier(identifer) as UITableViewCell cell.textLabel.text = a[indexPath.row].name cell.detailTextLabel.text = "detail"
var cell : UITableViewCell = tableView.dequeueReusableCellWithIdentifier("Component") as UITableViewCell
var cell = tableView.dequeueReusableCellWithIdentifier("Component") as? UITableViewCell
func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { if let cell: UITableViewCell = theTableView.dequeueReusableCellWithIdentifier("myCell", forIndexPath: indexPath) as? UITableViewCell { }else{ } }
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let CellIdentifier: String = "cell" var cell = tableView.dequeueReusableCellWithIdentifier(CellIdentifier) as? UITableViewCell if cell == nil { cell = UITableViewCell(style: UITableViewCellStyle.Value1, reuseIdentifier: CellIdentifier) } let dataRecord = self.paymentData[indexPath.row] as! NSDictionary let receiverName = dataRecord["receiver_name"] as! String let profession = dataRecord["profession"] as! String let dateCreated = dataRecord["date_created"] as! String let payAmount = dataRecord["pay_amount"] as! String println("payment \(payAmount)") cell!.textLabel?.text = "\(receiverName)\n\(profession)\n\(dateCreated)" cell!.detailTextLabel?.text = "$\(payAmount)" cell!.textLabel?.numberOfLines = 4 return cell! }
import UIKit import PlaygroundSupport class TableviewDemoDelegate:NSObject,UITableViewDataSource,UITableViewDelegate { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return 100 } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { var cell:UITableViewCell? = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath as IndexPath) if cell == nil { cell = UITableViewCell(style: .default, reuseIdentifier: "cell") } cell?.textLabel?.text = "Item \(indexPath.row+1)" return cell! } func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { print("You have selected cell } } var tableView = UITableView(frame:CGRect(x: 0, y: 0, width: 320, height: 568), style: .plain) tableView.register(UITableViewCell.self, forCellReuseIdentifier: "cell") let delegate = TableviewDemoDelegate() tableView.delegate = delegate tableView.dataSource = delegate PlaygroundPage.current.liveView = tableView
var cell : UITableViewCell = tableView.dequeueReusableCellWithIdentifier("Cell") as UITableViewCell
var cell : UITableViewCell = tableView.dequeueReusableCellWithIdentifier("Cell")
var cell:CustomTableViewCell = tableView.dequeueReusableCellWithIdentifier("CustomTableViewCell") as CustomTableViewCell cell.cellTitle.text="vijay"
let center = UNUserNotificationCenter.current() center.delegate = self center.requestAuthorization(options: [.sound, .alert, .badge]) { (granted, error) in if error == nil{ UIApplication.shared.registerForRemoteNotifications() } }
DispatchQueue.main.async(execute: { UIApplication.shared.registerForRemoteNotifications() })
dispatch_async(dispatch_get_main_queue(), ^{ [[UIApplication sharedApplication] registerForRemoteNotifications]; });
DispatchQueue.main.async { UIApplication.shared.registerForRemoteNotifications() }
center.requestAuthorization(options: [.sound, .alert, .badge]) { (granted, error) in if granted { DispatchQueue.main.async { UIApplication.shared.registerForRemoteNotifications() } } else { print(error!) } }
UNUserNotificationCenter.current().delegate = self UNUserNotificationCenter.current().requestAuthorization(options: [.alert,.sound,.badge], completionHandler: {(granted,error) in if granted{ DispatchQueue.main.async { application.registerForRemoteNotifications() } } })
DispatchQueue.main.async(execute: { UIApplication.shared.registerForRemoteNotifications() })
class PBOStatistics: NSManagedObject, Equatable { @NSManaged var date: NSDate @NSManaged var average: NSNumber @NSManaged var historicAverage: NSNumber @NSManaged var total: NSNumber @NSManaged var historicTotal: NSNumber @NSManaged var ordersCount: NSNumber @NSManaged var historicOrdersCount: NSNumber @NSManaged var values: [Double] @NSManaged var location: PBOLocation }
let statistics = (PBOStatistics.MR_createInContext(context) as! PBOStatistics) statistics.values = [8, 17.7, 18, 21, 0, 0, 34]
let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate let managedContext = appDelegate.managedObjectContext let entity = NSEntityDescription.entityForName("Device", inManagedObjectContext:managedContext) let device = NSManagedObject(entity: entity!, insertIntoManagedObjectContext: managedContext) let data = NSKeyedArchiver.archivedDataWithRootObject(Array) device.setValue(data, forKey: "dataOfArray") do { try managedContext.save() devices.append(device) } catch let error as NSError { print("Could not save \(error), \(error.userInfo)") }
let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate let managedContext = appDelegate.managedObjectContext let fetchRequest = NSFetchRequest(entityName: "Device") do { let results = try managedContext.executeFetchRequest(fetchRequest) if results.count != 0 { for result in results { let data = result.valueForKey("dataOfArray") as! NSData let unarchiveObject = NSKeyedUnarchiver.unarchiveObjectWithData(data) let arrayObject = unarchiveObject as AnyObject! as! [[String: String]] Array = arrayObject } } } catch let error as NSError { print("Could not fetch \(error), \(error.userInfo)") }
let array: [String] = ["red", "green", "blue"] let arrayAsString: String = array.description let stringAsData = arrayAsString.data(using: String.Encoding.utf16) let arrayBack: [String] = try! JSONDecoder().decode([String].self, from: stringAsData!)
let set: Set<Double> = [1, 2.0, 3] let setAsString: String = set.description let setStringAsData = setAsString.data(using: String.Encoding.utf16) let setBack: Set<Double> = try! JSONDecoder().decode(Set<Double>.self, from: setStringAsData!)
NSData *arrayData = [NSKeyedArchiver archivedDataWithRootObject:TheArray]; myEntity.arrayProperty = arrayData; [self saveContext];
NSMutableArray *array = [NSKeyedUnarchiver unarchiveObjectWithData:anEntity.arrayProperty];
let label = UILabel(frame: CGRect( x: 50, y: 50, width: 100, height: 50))
import Foundation print("Content-Type: text/html") print("Content:") print("") print("1. Process.argument(s):<br />") for s in Process.arguments { print(s + "<br />") } print("<br />") let env: Dictionary = NSProcessInfo().environment if let requestMethod = env["REQUEST_METHOD"] { print("2. Request method is: \(requestMethod)<br /><br />") } print("3. Number of environment variables: \(env.count)<br /><br />") print("4. List environment:<br />") for key in env.keys { print("\(key) == \(env[key]!)<br />") }
var optionalName: String? = "John Appleseed" var greeting = "Hello!" if let name = optionalName { greeting = "Hello, \(name)" }
let agent = movie.leadActor?.agent let agent = movie.leadActor!.agent
if let supportingActor = movie.supportingActor{ print(" The supporting actor is \(supportingActor)}
if let agent = movie.leadActor?.agent { ContactInfo = agent.phoneNumber }
var middleName :String? = "some thing" if let isExistsMiddleName = middleName { } else { }
var completionHandlers: [()->Void] = [] func someFunctionWithEscapingClosure(completionHandler: @escaping ()->Void){ completionHandlers.append(completionHandler) } func someFunctionWithNoneescapingClosure(closure: ()->Void){ closure() } class SomeClass{ var x:Int = 10 func doSomething(){ someFunctionWithEscapingClosure { self.x = 100 } someFunctionWithNoneescapingClosure { x = 200 } } } let instance = SomeClass() instance.doSomething() print(instance.x) completionHandlers.first?() print(instance.x)
class EscapingExamples: NSObject { var closure: (() -> Void)? func storageExample(with completion: (() -> Void)) { closure = completion } func asyncExample(with completion: (() -> Void)) { DispatchQueue.global().async { completion() } } func asyncExample2(with completion: (() -> Void)) { runAsyncTask { completion() } } func runAsyncTask(completion: @escaping (() -> Void)) { DispatchQueue.global().async { completion() } } }
class ShortlistCountResponse : Decodable { var response : String? var data : ShortlistcountData? } class ShortlistcountData : Decodable { var totalpropFavcount : Int? var totalprojFavcount : Int? }
static func fetchGenericData<T: Decodable>(urlString: String,params : [String:Any], completion: @escaping (T) -> ()) { let url = urlString let headers = ["Content-Type": "application/x-www-form-urlencoded", "Accept":"application/json"] Alamofire.request(url, method: .post, parameters:params, encoding: URLEncoding.default, headers: headers).responseJSON { response in print(response.request?.urlRequest ?? "") print(params) print(response.data ?? "") print(response.value ?? "") switch(response.result) { case .success(_): if let data = response.data{ do { let gotData = try JSONDecoder().decode(T.self, from: data) completion(gotData) } catch let jsonErr { print("Error serializing json:", jsonErr) ActivityIndicator.dismissActivityView() } DispatchQueue.main.async { ActivityIndicator.dismissActivityView() } } break case .failure(_): print(response.result.error ?? "") ActivityIndicator.dismissActivityView() break } } }
override func viewDidLoad() { super.viewDidLoad() let userID = "" let languageID = "" let params = ["userID":userID,"languageID":languageID] var appDelegate: AppDelegate? Service.fetchGenericData(urlString: "your url...", params: params) { (shortlistCountResponse : ShortlistCountResponse) in print(shortListCountResponse.data.totalprojFavcount ?? 0) } }
func dictionaryOfNames(arr:UIView...) -> Dictionary<String,UIView> { var d = Dictionary<String,UIView>() for (ix,v) in arr.enumerate(){ d["v\(ix+1)"] = v } return d }
let d = dictionaryOfNames(myView, myOtherView, myFantasicView) myView.addConstraints( NSLayoutConstraint.constraintsWithVisualFormat( "H:|[v2]|", options: nil, metrics: nil, views: d) )
func DictionaryOfInstanceVariables(container:AnyObject, objects: String ...) -> [String:AnyObject] { var views = [String:AnyObject]() for objectName in objects { guard let object = object_getIvar(container, class_getInstanceVariable(container.dynamicType, objectName)) else { assertionFailure("\(objectName) is not an ivar of: \(container)"); continue } views[objectName] = object } return views }
class ViewController: UIViewController { var childA: UIView = { let view = UIView() view.translatesAutoresizingMaskIntoConstraints = false view.backgroundColor = UIColor.redColor() return view }() var childB: UIButton = { let view = UIButton() view.setTitle("asdf", forState: .Normal) view.translatesAutoresizingMaskIntoConstraints = false view.backgroundColor = UIColor.blueColor() return view }() override func viewDidLoad() { super.viewDidLoad() self.view.addSubview(childA) self.view.addSubview(childB) let views = DictionaryOfInstanceVariables(self, objects: "childA", "childB") self.view.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat("H:|[childA]|", options: [], metrics: nil, views: views)) self.view.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat("H:|[childB]|", options: [], metrics: nil, views: views)) self.view.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat("V:|[childA][childB(==childA)]|", options: [], metrics: nil, views: views)) } }
extension ViewController { func views() -> Dictionary<String, AnyObject> { var views = dictionaryOfProperties() views.forEach { if !($1 is UIView) { views[$0] = nil } } return views } } extension NSObject { func dictionaryOfProperties() -> Dictionary<String, AnyObject> { var result = Dictionary<String, AnyObject>() let mirror = Mirror(reflecting: self) for case let(label?, value) in mirror.children { result[label] = value as? AnyObject } return result } }
let scale = 2.0 let r = self.view.bounds var r2 = CGRect() r2.size.width = r.size.width * scale
let kSEP : Float = 2.0 let intercellSpacing = CGSizeMake(kSEP, kSEP);
let scale: CGFloat = 2.0 let r = self.view.bounds var r2 = CGRect() r2.size.width = r.width * scale
extension Double { var CGFloatValue: CGFloat { get { return CGFloat(self) } } } extension Int { var CGFloatValue: CGFloat { get { return CGFloat(self) } } }
func callSellerPressed (sender: UIButton!){ UIApplication.sharedApplication().openURL(NSURL(scheme: NSString(), host: "tel: }
if let url = NSURL(string: "tel: UIApplication.sharedApplication().openURL(url) }
if let url = URL(string: "tel: if UIApplication.shared.open(url) } else { UIApplication.shared.openURL(url) } }
private func callNumber(phoneNumber:String) { if let phoneCallURL = URL(string: "tel: let application:UIApplication = UIApplication.shared if (application.canOpenURL(phoneCallURL)) { application.open(phoneCallURL, options: [:], completionHandler: nil) } } }
func phone(phoneNum: String) { if let url = URL(string: "tel: if UIApplication.shared.open(url, options: [:], completionHandler: nil) } else { UIApplication.shared.openURL(url as URL) } } }
func callSellerPressed (sender: UIButton!){ var newPhone = "" for (var i = 0; i < countElements(busPhone); i++){ var current:Int = i switch (busPhone[i]){ case "0","1","2","3","4","5","6","7","8","9" : newPhone = newPhone + String(busPhone[i]) default : println("Removed invalid character.") } } if (busPhone.utf16Count > 1){ UIApplication.sharedApplication().openURL(NSURL(string: "tel: } else{ let alert = UIAlertView() alert.title = "Sorry!" alert.message = "Phone number is not available for this business" alert.addButtonWithTitle("Ok") alert.show() } }
var url:NSURL = NSURL(string: "telprompt: UIApplication.sharedApplication().openURL(url)
func makeCall(phone: String) { let formatedNumber = phone.componentsSeparatedByCharactersInSet(NSCharacterSet.decimalDigitCharacterSet().invertedSet).joinWithSeparator("") let phoneUrl = "tel: let url:NSURL = NSURL(string: phoneUrl)! UIApplication.sharedApplication().openURL(url) }
func call(phoneNumber:String) { let cleanPhoneNumber = phoneNumber.components(separatedBy: CharacterSet.decimalDigits.inverted).joined(separator: "") let urlString:String = "tel: if let phoneCallURL = URL(string: urlString) { if (UIApplication.shared.canOpenURL(phoneCallURL)) { UIApplication.shared.open(phoneCallURL, options: [:], completionHandler: nil) } } }
private func callNumber(phoneNumber:String) { if let phoneCallURL = URL(string: "telprompt: let application:UIApplication = UIApplication.shared if (application.canOpenURL(phoneCallURL)) { if application.open(phoneCallURL, options: [:], completionHandler: nil) } else { application.openURL(phoneCallURL as URL) } } } }
if let url = URL(string:"tel: UIApplication.shared.openURL(url) }
class CallComposer: NSObject { var editedPhoneNumber = "" func call(phoneNumber: String) -> Bool { if phoneNumber != "" { for i in number.characters { switch (i){ case "0","1","2","3","4","5","6","7","8","9" : editedPhoneNumber = editedPhoneNumber + String(i) default : print("Removed invalid character.") } } let phone = "tel: let url = NSURL(string: phone) if let url = url { UIApplication.sharedApplication().openURL(url) } else { print("There was an error") } } else { return false } return true } }
var validPhoneNumber = "" phoneNumber.characters.forEach {(character) in switch character { case "0"..."9": validPhoneNumber.characters.append(character) default: break } } if UIApplication.shared.canOpenURL(URL(string: "tel: UIApplication.shared.openURL(URL(string: "tel: }
if let url = URL(string: "tel: UIApplication.shared.open(url, options: [:], completionHandler: nil) }
if let url = URL(string: "tel: if UIApplication.shared.open(url) } else { UIApplication.shared.openURL(url) } } else { print("Your device doesn }
let formatedNumber = phone.components(separatedBy: NSCharacterSet.decimalDigits.inverted).joined(separator: "") print("calling \(formatedNumber)") let phoneUrl = "tel: let url:URL = URL(string: phoneUrl)! UIApplication.shared.openURL(url)
let number = "+123 456-7890" let scanner = Scanner(string: number) let validCharacters = CharacterSet.decimalDigits let startCharacters = validCharacters.union(CharacterSet(charactersIn: "+ var digits: NSString? var validNumber = "" while !scanner.isAtEnd { if scanner.scanLocation == 0 { scanner.scanCharacters(from: startCharacters, into: &digits) } else { scanner.scanCharacters(from: validCharacters, into: &digits) } scanner.scanUpToCharacters(from: validCharacters, into: nil) if let digits = digits as? String { validNumber.append(digits) } } print(validNumber)
@IBAction func phoneNumberButtonTouched(_ sender: Any) { if let number = place?.phoneNumber { makeCall(phoneNumber: number) } } func makeCall(phoneNumber: String) { let formattedNumber = phoneNumber.components(separatedBy: NSCharacterSet.decimalDigits.inverted).joined(separator: "") let phoneUrl = "tel: let url:NSURL = NSURL(string: phoneUrl)! if UIApplication.shared.open(url as URL, options: [:], completionHandler: nil) } else { UIApplication.shared.openURL(url as URL) } }
let numbersOnly = busPhone.replacingOccurrences(of: " ", with: "") if let url = URL(string: "tel: if UIApplication.shared.open(url) } else { UIApplication.shared.openURL(url) } }
[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60) forBarMetrics:UIBarMetricsDefault];
let BarButtonItemAppearance = UIBarButtonItem.appearance() BarButtonItemAppearance.setTitleTextAttributes([NSForegroundColorAttributeName: UIColor.clear], for: .normal)
self.navigationItem.backBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"" style:UIBarButtonItemStylePlain target:nil action:nil];
self.navigationItem.backBarButtonItem = UIBarButtonItem(title:"", style:.plain, target:nil, action:nil)
let BarButtonItemAppearance = UIBarButtonItem.appearance() let attributes: [NSAttributedStringKey: Any] = [ BarButtonItemAppearance.setTitleTextAttributes([NSForegroundColorAttributeName: UIColor.clear], for: .normal) NSAttributedStringKey.font: UIFont.systemFont(ofSize: 0.1), NSAttributedStringKey.foregroundColor: UIColor.clear] BarButtonItemAppearance.setTitleTextAttributes(attributes, for: .normal) BarButtonItemAppearance.setTitleTextAttributes(attributes, for: .highlighted)
let attributes = [NSAttributedStringKey.font: UIFont(name: "Helvetica-Bold", size: 0.1)!, NSAttributedStringKey.foregroundColor: UIColor.clear] BarButtonItemAppearance.setTitleTextAttributes(attributes, for: .normal) BarButtonItemAppearance.setTitleTextAttributes(attributes, for: .highlighted)
UIBarButtonItem.appearance().setBackButtonTitlePositionAdjustment(UIOffsetMake(-1000, 0), for:UIBarMetrics.default)
self.navigationController?.navigationBar.topItem?.title = " "
let barAppearace = UIBarButtonItem.appearance() barAppearace.setBackButtonTitlePositionAdjustment(UIOffsetMake(0, -60), forBarMetrics:UIBarMetrics.Default)
UIBarButtonItem.appearance().setBackButtonTitlePositionAdjustment(UIOffsetMake(0, -60), for:UIBarMetrics.default)
UIBarButtonItem.appearance().setTitleTextAttributes([NSAttributedStringKey.foregroundColor: UIColor.clear], for: .normal) UIBarButtonItem.appearance().setTitleTextAttributes([NSAttributedStringKey.foregroundColor: UIColor.clear], for: UIControlState.highlighted)
self.navigationController?.navigationBar.backItem?.title = " "
override func viewWillDisappear(animated: Bool) { super.viewWillDisappear(true) navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .Plain, target: nil, action: nil)}
let barAppearace = UIBarButtonItem.appearance() barAppearace.setBackButtonTitlePositionAdjustment(UIOffsetMake(0, -60), for:UIBarMetrics.default)
override func viewDidLoad() { super.viewDidLoad() self.navigationItem.backBarButtonItem = UIBarButtonItem( title: "", style: .plain, target: nil, action: nil) }
class CustomNavigationController: UINavigationController { convenience init() { self.init(navigationBarClass: CustomNavigationBar.self, toolbarClass: nil) } }
class CustomNavigationBar: UINavigationBar { override func layoutSubviews() { backItem?.title = "" super.layoutSubviews() } }
let leftButton = UIBarButtonItem(title: "Back", style: UIBarButtonItemStyle.Plain, target: self, action: "closeView:") self.navigationItem.leftBarButtonItem = leftButton
self.navigationItem.leftBarButtonItem.title = "Back"
self.navigationItem.backBarButtonItem = UIBarButtonItem(title:"", style:.plain, target:nil, action:nil)
extension UIViewController { func setBackButton() { navigationController?.navigationBar.backIndicatorImage = R.image.backArrow() navigationController?.navigationBar.backIndicatorTransitionMaskImage = R.image.backArrow() navigationItem.backBarButtonItem = UIBarButtonItem(title: " ", style: .plain, target: nil, action: nil) }
override func viewWillDisappear(_ animated: Bool) { self.navigationItem.title = "" } override func viewWillAppear(_ animated: Bool) { self.navigationItem.title = "Title" }
UIBarButtonItem.appearance().setTitleTextAttributes([.foregroundColor: UIColor.clear], for: .normal)
func removeBackButton(vc:UIViewController) { let button = UIButton.init(type: .custom) button.setImage(UIImage.init(named:""), for: .normal) let leftBarButton = UIBarButtonItem.init(customView: button) vc.navigationItem.leftBarButtonItem = leftBarButton }
override func viewDidLoad() { super.viewDidLoad() removeBackButton(vc:self) }
extension UIViewController { func updateBackButton(){ if self.navigationController != nil { self.navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .done, target: self, action: nil) } }}
UIBarButtonItem.appearance().setBackButtonTitlePositionAdjustment(UIOffsetMake(-1000.0, 0.0), for: .default)
class CustomNavigationBar: UINavigationBar { override func awakeFromNib() { super.awakeFromNib() guard let topItem = topItem else { return } removeBackButtonTitle(for: topItem) } override func pushItem(_ item: UINavigationItem, animated: Bool) { removeBackButtonTitle(for: item) super.pushItem(item, animated: animated) } func removeBackButtonTitle(for item: UINavigationItem) { item.backBarButtonItem = UIBarButtonItem() } }
UIBarButtonItem.appearance().setTitleTextAttributes([NSFontAttributeName: barbuttonFont, NSForegroundColorAttributeName:UIColor.clearColor()], forState: UIControlState.Normal) UIBarButtonItem.appearance().setTitleTextAttributes([NSFontAttributeName: barbuttonFont, NSForegroundColorAttributeName:UIColor.clearColor()], forState: UIControlState.Highlighted)
[self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName : [UIColor whiteColor]}];
let titleDict: NSDictionary = ["NSForegroundColorAttributeName": UIColor.whiteColor()] self.navigationController.navigationBartitleTextAttributes = titleDict
let titleDict: NSDictionary = [NSForegroundColorAttributeName: UIColor.whiteColor()] self.navigationController.navigationBar.titleTextAttributes = titleDict
var navigationBarAppearace = UINavigationBar.appearance() navigationBarAppearace.tintColor = UIColor.YourNavigationButtonsColor() navigationBarAppearace.barTintColor = UIColor.YourBackgroundColor() navigationBarAppearace.titleTextAttributes = [NSForegroundColorAttributeName:UIColor.YourTitleColor()]
self.navigationController?.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName : UIColor.white]
self.navigationController?.navigationBar.titleTextAttributes = [NSAttributedStringKey.foregroundColor : UIColor.white]
self.navigationController!.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName : UIColor.whiteColor()]
self.title = "WORK ORDER" self.navigationController!.navigationBar.titleTextAttributes = [NSForegroundColorAttributeName : UIColor.whiteColor()]
UITabBarItem.appearance().setTitleTextAttributes([NSForegroundColorAttributeName : UIColor.white], for: .selected) UITabBarItem.appearance().setTitleTextAttributes([NSForegroundColorAttributeName : UIColor.black], for: .normal)
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { let navigationBarAppearace = UINavigationBar.appearance() navigationBarAppearace.titleTextAttributes = [NSForegroundColorAttributeName : UIColor.whiteColor()] return true }
UINavigationBar.appearance().titleTextAttributes = [NSAttributedStringKey.foregroundColor: UIColor.white]
let titleDict = [NSForegroundColorAttributeName: UIColor.white] self.navigationController?.navigationBar.titleTextAttributes = titleDict
self.navigationController?.navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]
if CLLocationManager.locationServicesEnabled() { switch CLLocationManager.authorizationStatus() { case .NotDetermined, .Restricted, .Denied: print("No access") case .AuthorizedAlways, .AuthorizedWhenInUse: print("Access") } } else { print("Location services are not enabled") }
if CLLocationManager.locationServicesEnabled() { switch CLLocationManager.authorizationStatus() { case .notDetermined, .restricted, .denied: print("No access") case .authorizedAlways, .authorizedWhenInUse: print("Access") } } else { print("Location services are not enabled") }
-(void)askEnableLocationService { BOOL showAlertSetting = false; BOOL showInitLocation = false; if ([CLLocationManager locationServicesEnabled]) { switch ([CLLocationManager authorizationStatus]) { case kCLAuthorizationStatusDenied: showAlertSetting = true; NSLog(@"HH: kCLAuthorizationStatusDenied"); break; case kCLAuthorizationStatusRestricted: showAlertSetting = true; NSLog(@"HH: kCLAuthorizationStatusRestricted"); break; case kCLAuthorizationStatusAuthorizedAlways: showInitLocation = true; NSLog(@"HH: kCLAuthorizationStatusAuthorizedAlways"); break; case kCLAuthorizationStatusAuthorizedWhenInUse: showInitLocation = true; NSLog(@"HH: kCLAuthorizationStatusAuthorizedWhenInUse"); break; case kCLAuthorizationStatusNotDetermined: showInitLocation = true; NSLog(@"HH: kCLAuthorizationStatusNotDetermined"); break; default: break; } } else { showAlertSetting = true; NSLog(@"HH: locationServicesDisabled"); } if (showAlertSetting) { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:nil message:@"Please enable location service for this app in ALLOW LOCATION ACCESS: Always, Go to Setting?" delegate:self cancelButtonTitle:@"No" otherButtonTitles:@"Open Setting", nil]; alertView.tag = 199; [alertView show]; } if (showInitLocation) { [self initLocationManager]; } }
-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { if (alertView.tag == 199) { if (buttonIndex == 1) { [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]]; } return; } }
-(void)initLocationManager{ self.locationManager = [[CLLocationManager alloc] init]; if([self.locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) { [self.locationManager requestAlwaysAuthorization]; } }
import CoreLocation open class Reachability { class func isLocationServiceEnabled() -> Bool { if CLLocationManager.locationServicesEnabled() { switch(CLLocationManager.authorizationStatus()) { case .notDetermined, .restricted, .denied: return false case .authorizedAlways, .authorizedWhenInUse: return true default: print("Something wrong with Location services") return false } } else { print("Location services are not enabled") return false } } }
if Reachability.isLocationServiceEnabled() == true { } else { let alertController = UIAlertController(title: "Location Services Disabled", message: "Please enable location services for this app.", preferredStyle: .alert) let OKAction = UIAlertAction(title: "OK", style: .default, handler: nil) alertController.addAction(OKAction) OperationQueue.main.addOperation { self.present(alertController, animated: true, completion:nil) } }
import CoreLocation static func isLocationPermissionGranted() -> Bool { guard CLLocationManager.locationServicesEnabled() else { return false } return [.authorizedAlways, .authorizedWhenInUse].contains(CLLocationManager.authorizationStatus()) }
if (CLLocationManager.locationServicesEnabled()) { locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyBest if ((UIDevice.current.systemVersion as NSString).floatValue >= 8) { locationManager.requestWhenInUseAuthorization() } locationManager.startUpdatingLocation() } else { println("Location services are not enabled"); }
yourSharedLocationManager.requestWhenInUseAuthorization()
extension CLLocationManager { static func authorizedToRequestLocation() -> Bool { return CLLocationManager.locationServicesEnabled() && (CLLocationManager.authorizationStatus() == .authorizedAlways || CLLocationManager.authorizationStatus() == .authorizedWhenInUse) }
private func requestUserLocation() { locationManager.requestWhenInUseAuthorization() if CLLocationManager.authorizedToRequestLocation() { locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation locationManager.requestLocation() } else { showAlertNoLocation(locationError: .invalidPermissions) } }
func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) { if !CLLocationManager.authorizedToRequestLocation() { showAlertNoLocation(locationError: .invalidPermissions) } }
switch CLLocationManager.authorizationStatus() { case .notDetermined: break case .restricted, .denied: break case .authorizedWhenInUse, .authorizedAlways: break } }
import CoreLocation let locationManager = CLLocationManager() class SettingsTableViewController:CLLocationManagerDelegate{ func checkUsersLocationServicesAuthorization(){ if CLLocationManager.locationServicesEnabled() { switch CLLocationManager.authorizationStatus() { case .notDetermined: self.locationManager.delegate = self locationManager.requestWhenInUseAuthorization() break case .restricted, .denied: switchAutoTaxDetection.isOn = false let alert = UIAlertController(title: "Allow Location Access", message: ‚ÄúMyApp needs access to your location. Turn on Location Services in your device settings.", preferredStyle: UIAlertController.Style.alert) alert.addAction(UIAlertAction(title: "Settings", style: UIAlertAction.Style.default, handler: { action in guard let settingsUrl = URL(string: UIApplication.openSettingsURLString) else { return } if UIApplication.shared.canOpenURL(settingsUrl) { UIApplication.shared.open(settingsUrl, completionHandler: { (success) in print("Settings opened: \(success)") }) } })) alert.addAction(UIAlertAction(title: "Ok", style: UIAlertAction.Style.default, handler: nil)) self.present(alert, animated: true, completion: nil) break case .authorizedWhenInUse, .authorizedAlways: print("Full Access") break } } } }
let block = UIView(frame: CGRectMake(cellWidth-25, cellHeight/2-8, 16, 16)) block.backgroundColor = UIColor(netHex: 0xff3b30) block.layer.cornerRadius = 9 block.clipsToBounds = true
let circlePath = UIBezierPath(arcCenter: CGPoint(x: 100,y: 100), radius: CGFloat(20), startAngle: CGFloat(0), endAngle:CGFloat(M_PI * 2), clockwise: true) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.CGPath shapeLayer.fillColor = UIColor.clearColor().CGColor shapeLayer.strokeColor = UIColor.redColor().CGColor shapeLayer.lineWidth = 3.0 view.layer.addSublayer(shapeLayer)
let circlePath = UIBezierPath(arcCenter: CGPoint(x: 100,y: 100), radius: CGFloat(20), startAngle: CGFloat(0), endAngle:CGFloat(Double.pi * 2), clockwise: true) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.cgPath shapeLayer.fillColor = UIColor.clear.cgColor shapeLayer.strokeColor = UIColor.red.cgColor shapeLayer.lineWidth = 3.0 view.layer.addSublayer(shapeLayer)
import UIKit class Ring:UIView { override func drawRect(rect: CGRect) { drawRingFittingInsideView() } internal func drawRingFittingInsideView()->() { let halfSize:CGFloat = min( bounds.size.width/2, bounds.size.height/2) let desiredLineWidth:CGFloat = 1 let circlePath = UIBezierPath( arcCenter: CGPoint(x:halfSize,y:halfSize), radius: CGFloat( halfSize - (desiredLineWidth/2) ), startAngle: CGFloat(0), endAngle:CGFloat(M_PI * 2), clockwise: true) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.CGPath shapeLayer.fillColor = UIColor.clearColor().CGColor shapeLayer.strokeColor = UIColor.redColor().CGColor shapeLayer.lineWidth = desiredLineWidth layer.addSublayer(shapeLayer) } }
internal func drawRingFittingInsideView(rect: CGRect)->() { let desiredLineWidth:CGFloat = 4 let hw:CGFloat = desiredLineWidth/2 let circlePath = UIBezierPath(ovalInRect: CGRectInset(rect,hw,hw) ) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.CGPath shapeLayer.fillColor = UIColor.clearColor().CGColor shapeLayer.strokeColor = UIColor.redColor().CGColor shapeLayer.lineWidth = desiredLineWidth layer.addSublayer(shapeLayer) }
import UIKit @IBDesignable class Dot:UIView { @IBInspectable var mainColor: UIColor = UIColor.blueColor() { didSet { print("mainColor was set here") } } @IBInspectable var ringColor: UIColor = UIColor.orangeColor() { didSet { print("bColor was set here") } } @IBInspectable var ringThickness: CGFloat = 4 { didSet { print("ringThickness was set here") } } @IBInspectable var isSelected: Bool = true override func drawRect(rect: CGRect) { let dotPath = UIBezierPath(ovalInRect:rect) let shapeLayer = CAShapeLayer() shapeLayer.path = dotPath.CGPath shapeLayer.fillColor = mainColor.CGColor layer.addSublayer(shapeLayer) if (isSelected) { drawRingFittingInsideView(rect) } } internal func drawRingFittingInsideView(rect: CGRect)->() { let hw:CGFloat = ringThickness/2 let circlePath = UIBezierPath(ovalInRect: CGRectInset(rect,hw,hw) ) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.CGPath shapeLayer.fillColor = UIColor.clearColor().CGColor shapeLayer.strokeColor = ringColor.CGColor shapeLayer.lineWidth = ringThickness layer.addSublayer(shapeLayer) } }
import UIKit class Dot:UIView { override func layoutSubviews() { layer.cornerRadius = bounds.size.width/2; } }
CGContextRef ctx= UIGraphicsGetCurrentContext(); CGRect bounds = [self bounds]; CGPoint center; center.x = bounds.origin.x + bounds.size.width / 2.0; center.y = bounds.origin.y + bounds.size.height / 2.0; CGContextSaveGState(ctx); CGContextSetLineWidth(ctx,5); CGContextSetRGBStrokeColor(ctx,0.8,0.8,0.8,1.0); CGContextAddArc(ctx,locationOfTouch.x,locationOfTouch.y,30,0.0,M_PI*2,YES); CGContextStrokePath(ctx);
import UIKit @IBDesignable class Dot:UIView { @IBInspectable var mainColor: UIColor = UIColor.clear { didSet { print("mainColor was set here") } } @IBInspectable var ringColor: UIColor = UIColor.clear { didSet { print("bColor was set here") } } @IBInspectable var ringThickness: CGFloat = 4 { didSet { print("ringThickness was set here") } } @IBInspectable var isSelected: Bool = true override func draw(_ rect: CGRect) { let dotPath = UIBezierPath(ovalIn: rect) let shapeLayer = CAShapeLayer() shapeLayer.path = dotPath.cgPath shapeLayer.fillColor = mainColor.cgColor layer.addSublayer(shapeLayer) if (isSelected) { drawRingFittingInsideView(rect: rect) } } internal func drawRingFittingInsideView(rect: CGRect)->() { let hw:CGFloat = ringThickness/2 let circlePath = UIBezierPath(ovalIn: rect.insetBy(dx: hw,dy: hw) ) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.cgPath shapeLayer.fillColor = UIColor.clear.cgColor shapeLayer.strokeColor = ringColor.cgColor shapeLayer.lineWidth = ringThickness layer.addSublayer(shapeLayer) } }
import UIKit @IBDesignable class Dot:UIView { @IBInspectable var mainColor: UIColor = UIColor.clear { didSet { print("mainColor was set here") } } @IBInspectable var ringColor: UIColor = UIColor.clear { didSet { print("bColor was set here") } } @IBInspectable var ringThickness: CGFloat = 4 { didSet { print("ringThickness was set here") } } @IBInspectable var isSelected: Bool = true override func draw(_ rect: CGRect) { let dotPath = UIBezierPath(ovalIn: rect) let shapeLayer = CAShapeLayer() shapeLayer.path = dotPath.cgPath shapeLayer.fillColor = mainColor.cgColor layer.addSublayer(shapeLayer) if (isSelected) { drawRingFittingInsideView(rect: rect) } } internal func drawRingFittingInsideView(rect: CGRect)->() { let halfSize:CGFloat = min( bounds.size.width/2, bounds.size.height/2) let desiredLineWidth:CGFloat = ringThickness let circlePath = UIBezierPath( arcCenter: CGPoint(x: halfSize, y: halfSize), radius: CGFloat( halfSize - (desiredLineWidth/2) ), startAngle: CGFloat(0), endAngle:CGFloat(Double.pi), clockwise: true) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.cgPath shapeLayer.fillColor = UIColor.clear.cgColor shapeLayer.strokeColor = ringColor.cgColor shapeLayer.lineWidth = ringThickness layer.addSublayer(shapeLayer) } }
import UIKit @IBDesignable class DRAW: UIView { override func draw(_ rect: CGRect) { var path = UIBezierPath() path = UIBezierPath(ovalIn: CGRect(x: 50, y: 50, width: 100, height: 100)) UIColor.yellow.setStroke() UIColor.red.setFill() path.lineWidth = 5 path.stroke() path.fill() } }
@IBDesignable class CircledDotView: UIView { @IBInspectable var mainColor: UIColor = .white { didSet { print("mainColor was set here") } } @IBInspectable var ringColor: UIColor = .black { didSet { print("bColor was set here") } } @IBInspectable var ringThickness: CGFloat = 4 { didSet { print("ringThickness was set here") } } @IBInspectable var isSelected: Bool = true override func draw(_ rect: CGRect) { let dotPath = UIBezierPath(ovalIn: rect) let shapeLayer = CAShapeLayer() shapeLayer.path = dotPath.cgPath shapeLayer.fillColor = mainColor.cgColor layer.addSublayer(shapeLayer) if (isSelected) { drawRingFittingInsideView(rect: rect) } } internal func drawRingFittingInsideView(rect: CGRect) { let hw: CGFloat = ringThickness / 2 let circlePath = UIBezierPath(ovalIn: rect.insetBy(dx: hw, dy: hw)) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.cgPath shapeLayer.fillColor = UIColor.clear.cgColor shapeLayer.strokeColor = ringColor.cgColor shapeLayer.lineWidth = ringThickness layer.addSublayer(shapeLayer) } }
if let cgcontext = UIGraphicsGetCurrentContext() { cgcontext.strokeEllipse(in: CGRect(x: center.x-diameter/2, y: center.y-diameter/2, width: diameter, height: diameter)) }
var CircleLayer = CAShapeLayer() let center = CGPoint (x: myCircleView.frame.size.width / 2, y: myCircleView.frame.size.height / 2) let circleRadius = myCircleView.frame.size.width / 2 let circlePath = UIBezierPath(arcCenter: center, radius: circleRadius, startAngle: CGFloat(M_PI), endAngle: CGFloat(M_PI * 4), clockwise: true) CircleLayer.path = circlePath.cgPath CircleLayer.strokeColor = UIColor.red.cgColor CircleLayer.fillColor = UIColor.blue.cgColor CircleLayer.lineWidth = 8 CircleLayer.strokeStart = 0 CircleLayer.strokeEnd = 1 Self.View.layer.addSublayer(CircleLayer)
func drawCircle(withMultiplicator coefficient: CGFloat) { let radius = self.view.frame.width / 2 * coefficient let circlePath = UIBezierPath(arcCenter: self.view.center, radius: radius, startAngle: CGFloat(0), endAngle:CGFloat(Double.pi * 2), clockwise: true) let shapeLayer = CAShapeLayer() shapeLayer.path = circlePath.cgPath shapeLayer.fillColor = UIColor.clear.cgColor shapeLayer.strokeColor = UIColor.darkGray.cgColor shapeLayer.lineWidth = 2.0 view.layer.addSublayer(shapeLayer) }
let origImage = UIImage(named: "imageName") let tintedImage = origImage?.imageWithRenderingMode(UIImage.RenderingMode.AlwaysTemplate) btn.setImage(tintedImage, forState: .Normal) btn.tintColor = UIColor.redColor()
let origImage = UIImage(named: "imageName") let tintedImage = origImage?.withRenderingMode(.alwaysTemplate) btn.setImage(tintedImage, forState: .normal) btn.tintColor = .redColor
let origImage = UIImage(named: "imageName"); let tintedImage = origImage?.withRenderingMode(UIImageRenderingMode.alwaysTemplate) btn.setImage(tintedImage, for: .normal) btn.tintColor = UIColor.red
UIImage *originalImage = [UIImage imageNamed:@"image.png"]; UIImage *tintedImage = [originalImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; UIImageView *imageView = [[UIImageView alloc] initWithImage:tintedImage]; imageView.tintColor = [UIColor grayColor]; [self.view addSubview:imageView];
public extension UIImage { /** Tint, Colorize image with given tint color<br><br> This is similar to Photoshop This is perfect for non-greyscale source images, and images that have both highlights and shadows that should be preserved<br><br> white will stay white and black will stay black as the lightness of the image is preserved<br><br> <img src="http: **To** <img src="http: - parameter tintColor: UIColor - returns: UIImage */ public func tintPhoto(tintColor: UIColor) -> UIImage { return modifiedImage { context, rect in CGContextSetBlendMode(context, .Normal) UIColor.blackColor().setFill() CGContextFillRect(context, rect) CGContextSetBlendMode(context, .Normal) CGContextDrawImage(context, rect, self.CGImage) CGContextSetBlendMode(context, .Color) tintColor.setFill() CGContextFillRect(context, rect) CGContextSetBlendMode(context, .DestinationIn) CGContextDrawImage(context, rect, self.CGImage) } } /** Tint Picto to color - parameter fillColor: UIColor - returns: UIImage */ public func tintPicto(fillColor: UIColor) -> UIImage { return modifiedImage { context, rect in CGContextSetBlendMode(context, .Normal) fillColor.setFill() CGContextFillRect(context, rect) CGContextSetBlendMode(context, .DestinationIn) CGContextDrawImage(context, rect, self.CGImage) } } /** Modified Image Context, apply modification on image - parameter draw: (CGContext, CGRect) -> ()) - returns: UIImage */ private func modifiedImage(@noescape draw: (CGContext, CGRect) -> ()) -> UIImage { UIGraphicsBeginImageContextWithOptions(size, false, scale) let context: CGContext! = UIGraphicsGetCurrentContext() assert(context != nil) CGContextTranslateCTM(context, 0, size.height); CGContextScaleCTM(context, 1.0, -1.0); let rect = CGRectMake(0.0, 0.0, size.width, size.height) draw(context, rect) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }
extension UIImage { /** Tint, Colorize image with given tint color<br><br> This is similar to Photoshop This is perfect for non-greyscale source images, and images that have both highlights and shadows that should be preserved<br><br> white will stay white and black will stay black as the lightness of the image is preserved<br><br> <img src="http: **To** <img src="http: - parameter tintColor: UIColor - returns: UIImage */ func tintPhoto(_ tintColor: UIColor) -> UIImage { return modifiedImage { context, rect in context.setBlendMode(.normal) UIColor.black.setFill() context.fill(rect) context.setBlendMode(.normal) context.draw(cgImage!, in: rect) context.setBlendMode(.color) tintColor.setFill() context.fill(rect) context.setBlendMode(.destinationIn) context.draw(context.makeImage()!, in: rect) } } /** Tint Picto to color - parameter fillColor: UIColor - returns: UIImage */ func tintPicto(_ fillColor: UIColor) -> UIImage { return modifiedImage { context, rect in context.setBlendMode(.normal) fillColor.setFill() context.fill(rect) context.setBlendMode(.destinationIn) context.draw(cgImage!, in: rect) } } /** Modified Image Context, apply modification on image - parameter draw: (CGContext, CGRect) -> ()) - returns: UIImage */ fileprivate func modifiedImage(_ draw: (CGContext, CGRect) -> ()) -> UIImage { UIGraphicsBeginImageContextWithOptions(size, false, scale) let context: CGContext! = UIGraphicsGetCurrentContext() assert(context != nil) context.translateBy(x: 0, y: size.height) context.scaleBy(x: 1.0, y: -1.0) let rect = CGRect(x: 0.0, y: 0.0, width: size.width, height: size.height) draw(context, rect) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image! } }
extension UIImage { func mask(with color: UIColor) -> UIImage { UIGraphicsBeginImageContextWithOptions(self.size, false, self.scale) defer { UIGraphicsEndImageContext() } guard let context = UIGraphicsGetCurrentContext() else { return self } context.translateBy(x: 0, y: self.size.height) context.scaleBy(x: 1.0, y: -1.0) context.setBlendMode(.normal) let rect = CGRect(x: 0, y: 0, width: self.size.width, height: self.size.height) guard let mask = self.cgImage else { return self } context.clip(to: rect, mask: mask) color.setFill() context.fill(rect) guard let newImage = UIGraphicsGetImageFromCurrentImageContext() else { return self } return newImage } }
let origImage = UIImage(named: "check") let tintedImage = origImage?.withRenderingMode(.alwaysTemplate) buttons[0].setImage(tintedImage, for: .normal) buttons[0].tintColor = .red
NSString *st = [NSString stringWithFormat:@"%2X", n];
let n = 14 var st = String(format:"%02X", n) st += " is the hexadecimal representation of \(n)" print(st)
let n = UInt64.max print(String(format: "%llX is hexadecimal for \(n)", n))
FFFFFFFFFFFFFFFF is hexadecimal for 18446744073709551615
let n = 123 var st = NSString(format:"%2X", n) as String st += " is the hexadecimal representation of \(n)"
let hex = String(0xF, radix: 16, uppercase: false) println("hex=\(hex)")
init<T>(_ value: T, radix: Int = default, uppercase: Bool = default) where T : _SignedInteger
let string1 = String(2, radix: 16) print(string1) let string2 = String(211, radix: 16) print(string2) let string3 = String(211, radix: 16, uppercase: true) print(string3)
import Foundation let string1 = String(format:"%X", 2) print(string1) let string2 = String(format:"%02X", 1) print(string2) let string3 = String(format:"%02X", 211) print(string3) let string4 = String(format: "%02X, %02X, %02X", 12, 121, 255) print(string4)
import Foundation let string1 = String(format:"%X", arguments: [2]) print(string1) let string2 = String(format:"%02X", arguments: [1]) print(string2) let string3 = String(format:"%02X", arguments: [211]) print(string3) let string4 = String(format: "%02X, %02X, %02X", arguments: [12, 121, 255]) print(string4)
let string2 = String(format:"%02X", 1) print(string2)
let hexString = String(format:"%llX", decimalValue)
Test Host - Debug Build/Debug-iphoneos/OldProjectName.app/OldProjectName - Release Build/Release-iphoneos/OldProjectName.app/OldProjectName Test Host - Debug Build/Debug-iphoneos/NewProjectName.app/NewProjectName - Release Build/Release-iphoneos/NewProjectName.app/NewProjectName
(someboolexpression ? "Return value 1" : "Return value 2")
println(" some string \(some expression ? "Return value 1" : "Return value 2")"
let exists = "exists" let doesnotexist= "does not exist" println(" something \(fileExists ? exists : doesnotexist)")
let fileExists = false println("something " + (fileExists ? "exists" : "does not exist"))
var firstBool = true var secondBool: Bool firstBool == true ? (secondBool = true) : (secondBool = false)
self.automaticOption = (automaticOptionOfCar ? "Automatic" : "Manual")
let a = true let b = 1 let c = 2 println("\(a ? 1: 2)")
var firstBool = true var secondBool: Bool secondBool = firstBool ? true : false
var firstBool = true var secondBool: Bool if (firstBool == true) { secondBool = true } else { secondBool = false }
var retunString = (state == "OFF") ? "securityOn" : "securityOff"
var b:CMutablePointer<ObjCBool>? if (fileManager.fileExistsAtPath(fullPath, isDirectory:b! )){ fileManager.createDirectoryAtURL(dirURL, withIntermediateDirectories: false, attributes: nil, error: nil) }
var isDir : ObjCBool = false if fileManager.fileExistsAtPath(fullPath, isDirectory:&isDir) { if isDir { } else { } } else { }
let fileManager = FileManager.default var isDir : ObjCBool = false if fileManager.fileExists(atPath: fullPath, isDirectory:&isDir) { if isDir.boolValue { } else { } } else { }
extension URL { enum Filestatus { case isFile case isDir case isNot } var filestatus: Filestatus { get { let filestatus: Filestatus var isDir: ObjCBool = false if FileManager.default.fileExists(atPath: self.path, isDirectory: &isDir) { if isDir.boolValue { filestatus = .isDir } else { filestatus = .isFile } } else { filestatus = .isNot } return filestatus } } }
let myString: String = "256" let myInt: Int? = myString.toInt()
let myString: String = "256" let myInt: Int? = Int(myString)
let myString: NSString = "123" let myStringToInt: Int = Int(myString.intValue)
let expMonth = UInt(expirationDate[0].toInt()!) let expYear = UInt(expirationDate[1].toInt()!)
let expMonth = Int(expirationDate[0]) let expYear = Int(expirationDate[1])
extension String { func toInt() -> Int? { return Int(self) } }
let myString: String = dataEntered.text! var myInt: Int? = Int(myString) myInt = myInt! * 2 finalOutput.text! = "\(myInt)"
class Foo { init(one: Int, two: String) { } } let foo = Foo(42, "Hello world")
extension Foo { func run(one: String, two: [Int]) { } } foo.run(one: "Goodbye", two: [])
func addChildViewController(_ childController: UIViewController)
var view = NSView(frame: NSRect(x: 10, y: 10, width: 50, height: 50)) class Foo { init(one: Int, two: String) { } } let foo = Foo(one: 42, two: "Hello world")
extension Foo { func run(one: String, two: [Int]) { } } foo.run("Goodbye", two: [])
extension Foo{ class func baz(one: Int, two: String){} class func other(exOne one: Int, exTwo two: String){} } Foo.baz(10, two:"str") Foo.other(exOne: 20, exTwo:"str")
func printAnimal(animal: String, legCount: Int) { let legNoun = legCount == 1 ? "leg" : "legs" print("\(animal) has \(legCount) \(legNoun)") } struct Player { let name: String let lives: Int init(name: String, lives: Int) { self.name = name self.lives = lives } func printCurrentScore(currentScore: Int, highScore: Int) { print("\(name) } } printAnimal(animal: "Dog", legCount: 4) let p = Player(name: "Riley", lives: 3) p.printCurrentScore(currentScore: 50, highScore: 110) printAnimal("Dog", legCount: 4) let p = Player(name: "Riley", lives: 3) p.printCurrentScore(50, highScore: 110) printAnimal(animal: "Dog", legCount: 4) let q = Player("Riley", lives: 3) p.printCurrentScore(50, 110)
func printAnimal(theAnimal animal: String, legCount: Int) { let legNoun = legCount == 1 ? "leg" : "legs" print("\(animal) has \(legCount) \(legNoun)") } printAnimal(theAnimal: "Dog", legCount: 4)
func printAnimal(animal: String, _ legCount: Int) { let legNoun = legCount == 1 ? "leg" : "legs" print("\(animal) has \(legCount) \(legNoun)") } printAnimal(theAnimal: "Dog", 4) printAnimal("Dog", 4)
func addLocation(latitude : Double, longitude : Double) { } addLocation(125.0, -34.1)
func addLocation( addLocation(latitude: 125.0, longitude: -34.1)
@interface Counter : NSObject @property int count; - (void)incrementBy:(int)amount numberOfTimes:(int)numberOfTimes; @end
class Counter { var count: Int = 0 func incrementBy(amount: Int, numberOfTimes: Int) { count += amount * numberOfTimes } }
cavejohnson xcodeGUITricks --archive-path my.xcarchive --new-ipa-path myapp.ipa
<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE plist PUBLIC "- <plist version="1.0"> <dict> <key>teamID</key> <string>MYTEAMID123</string> <key>method</key> <string>app-store</string> <key>uploadSymbols</key> <true/> </dict> </plist>
xcodebuild -scheme MyApp -archivePath builds/MyApp.xcarchive archive
xcrun xcodebuild -exportArchive -exportOptionsPlist exportPlist.plist -archivePath builds/MyApp.xcarchive -exportPath builds
identifier = "de.xxx.yyy" config = "Release" ad_hoc = false scheme = "Schema" gym(verbose: false, scheme: scheme, codesigning_identity: "iPhone Distribution: YTB)", configuration: config)
func sum(n: Int, acc: Int) -> Int { if n == 0 { return acc } else { return sum(n - 1, acc + n) } }
func isOdd(n: Int) -> Bool { if n == 0 { return false; } else { return isEven(n - 1) } } func isEven(n: Int) -> Bool { if n == 0 { return true } else { return isOdd(n - 1) } }
.globl __TF3tco3sumFTSiSi_Si .align 4, 0x90 __TF3tco3sumFTSiSi_Si: pushq %rbp movq %rsp, %rbp testq %rdi, %rdi je LBB0_4 .align 4, 0x90 LBB0_1: movq %rdi, %rax decq %rax jo LBB0_5 addq %rdi, %rsi jo LBB0_5 testq %rax, %rax movq %rax, %rdi jne LBB0_1 LBB0_4: movq %rsi, %rax popq %rbp retq LBB0_5: ud2 .globl __TF3tco5isOddFSiSb .align 4, 0x90 __TF3tco5isOddFSiSb: pushq %rbp movq %rsp, %rbp testq %rdi, %rdi je LBB1_1 decq %rdi jo LBB1_9 movb $1, %al LBB1_5: testq %rdi, %rdi je LBB1_2 decq %rdi jo LBB1_9 testq %rdi, %rdi je LBB1_1 decq %rdi jno LBB1_5 LBB1_9: ud2 LBB1_1: xorl %eax, %eax LBB1_2: popq %rbp retq .globl __TF3tco6isEvenFSiSb .align 4, 0x90 __TF3tco6isEvenFSiSb: pushq %rbp movq %rsp, %rbp movb $1, %al LBB2_1: testq %rdi, %rdi je LBB2_5 decq %rdi jo LBB2_7 testq %rdi, %rdi je LBB2_4 decq %rdi jno LBB2_1 LBB2_7: ud2 LBB2_4: xorl %eax, %eax LBB2_5: popq %rbp retq
func sum(n: Int, acc: Int) -> Int { if n == 0 { return acc } else { return sum(n - 1, acc: acc + 1) } }
func sum(n: Int, acc: Int, s: String?) -> Int { if n == 0 { return acc } else { return sum(n - 1, acc + 1, s) } }
let memoryCapacity = 500 * 1024 * 1024; let diskCapacity = 500 * 1024 * 1024; let cache = NSURLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: "shared_cache") let configuration = NSURLSessionConfiguration.defaultSessionConfiguration() var defaultHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders configuration.HTTPAdditionalHeaders = defaultHeaders configuration.requestCachePolicy = .UseProtocolCachePolicy configuration.URLCache = cache let manager = Alamofire.Manager(configuration: configuration) manager.request(.GET, "http: .response { (request, response, data, error) in println(request) println(response) println(error) }
let URL = NSURL(string: "/whereever/your/local/cache/lives")! let downloadRequest = Alamofire.download(.GET, "http: return URL } downloadRequest.response { request, response, _, error in }
Alamofire.request(.GET, "http: .responseSwiftyJSON { (request, response, json, error) in println(json) println(error) }
let data = NSData(contentsOfFile: URL.path)! let json = JSON(data: data)
func getPlaces(){ let request = NSMutableURLRequest(URL: NSURL(string: baseUrl + "/places")!, cachePolicy: .ReturnCacheDataElseLoad, timeoutInterval: 20) Alamofire.request(request) .responseJSON { (response) in let cachedURLResponse = NSCachedURLResponse(response: response.response!, data: (response.data! as NSData), userInfo: nil, storagePolicy: .Allowed) NSURLCache.sharedURLCache().storeCachedResponse(cachedURLResponse, forRequest: response.request!) guard response.result.error == nil else { print("error calling GET on /places") print(response.result.error!) return } let swiftyJsonVar = JSON(data: cachedURLResponse.data) if let resData = swiftyJsonVar["places"].arrayObject { self.places = resData } if self.places.count > 0 { self.tableView.reloadData() } } }
func getData(){ let query_url = "http: let urlAddressEscaped = query_url.addingPercentEncoding(withAllowedCharacters:NSCharacterSet.urlQueryAllowed) let request = URLRequest(url: URL(string: urlAddressEscaped!)!, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: 20) Alamofire.request(request) .responseJSON { (response) in let cachedURLResponse = CachedURLResponse(response: response.response!, data: (response.data! as NSData) as Data, userInfo: nil, storagePolicy: .allowed) URLCache.shared.storeCachedResponse(cachedURLResponse, for: response.request!) guard response.result.error == nil else { print("error fetching data from url") print(response.result.error!) return } let json = JSON(data: cachedURLResponse.data) print(json) } }
func attachDropDownArrow() -> NSMutableAttributedString { let image:UIImage = UIImage(named: "arrowWhite.png")! let attachment = NSTextAttachment() attachment.image = image attachment.bounds = CGRectMake(2.25, 2, attachment.image!.size.width - 2.25, attachment.image!.size.height - 2.25) let attachmentString = NSAttributedString(attachment: attachment) let myString = NSMutableAttributedString(string: NSString(format: "%@", self.privacyOptions[selectedPickerRow]) as String) myString.appendAttributedString(attachmentString) return myString }
extension UIImageView { func setImageColor(color: UIColor) { let templateImage = self.image?.withRenderingMode(UIImage.RenderingMode.alwaysTemplate) self.image = templateImage self.tintColor = color } }
let imageView = UIImageView(image: UIImage(named: "your_image_name")) imageView.setImageColor(color: UIColor.purple)
extension UIImage { func maskWithColor(color: UIColor) -> UIImage? { let maskImage = cgImage! let width = size.width let height = size.height let bounds = CGRect(x: 0, y: 0, width: width, height: height) let colorSpace = CGColorSpaceCreateDeviceRGB() let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue) let context = CGContext(data: nil, width: Int(width), height: Int(height), bitsPerComponent: 8, bytesPerRow: 0, space: colorSpace, bitmapInfo: bitmapInfo.rawValue)! context.clip(to: bounds, mask: maskImage) context.setFillColor(color.cgColor) context.fill(bounds) if let cgImage = context.makeImage() { let coloredImage = UIImage(cgImage: cgImage) return coloredImage } else { return nil } } }
extension UIImage { func maskWithColor(color: UIColor) -> UIImage? { let maskImage = self.CGImage let width = self.size.width let height = self.size.height let bounds = CGRectMake(0, 0, width, height) let colorSpace = CGColorSpaceCreateDeviceRGB() let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.PremultipliedLast.rawValue) let bitmapContext = CGBitmapContextCreate(nil, Int(width), Int(height), 8, 0, colorSpace, bitmapInfo.rawValue) CGContextClipToMask(bitmapContext, bounds, maskImage) CGContextSetFillColorWithColor(bitmapContext, color.CGColor) CGContextFillRect(bitmapContext, bounds) if let cImage = CGBitmapContextCreateImage(bitmapContext) { let coloredImage = UIImage(CGImage: cImage) return coloredImage } else { return nil } } }
let image = UIImage(named: "your_image_name") testImage.image = image?.maskWithColor(color: UIColor.blue)
let templateImage = originalImage.imageWithRenderingMode(UIImageRenderingModeAlwaysTemplate) myImageView.image = templateImage myImageView.tintColor = UIColor.orangeColor()
func overlayImage(color: UIColor) -> UIImage { UIGraphicsBeginImageContextWithOptions(self.size, false, UIScreen.main.scale) let context = UIGraphicsGetCurrentContext() color.setFill() context!.translateBy(x: 0, y: self.size.height) context!.scaleBy(x: 1.0, y: -1.0) context!.setBlendMode(CGBlendMode.colorBurn) let rect = CGRect(x: 0, y: 0, width: self.size.width, height: self.size.height) context!.draw(self.cgImage!, in: rect) context!.setBlendMode(CGBlendMode.sourceIn) context!.addRect(rect) context!.drawPath(using: CGPathDrawingMode.fill) let coloredImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return coloredImage }
extension UIImage { public func maskWithColor(color: UIColor) -> UIImage { UIGraphicsBeginImageContextWithOptions(self.size, false, self.scale) let context = UIGraphicsGetCurrentContext()! let rect = CGRect(origin: CGPoint.zero, size: size) color.setFill() self.draw(in: rect) context.setBlendMode(.sourceIn) context.fill(rect) let resultImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() return resultImage } }
extension UIImage { func maskWithColor(color: UIColor) -> UIImage { var maskImage = self.CGImage let width = self.size.width let height = self.size.height let bounds = CGRectMake(0, 0, width, height) let colorSpace = CGColorSpaceCreateDeviceRGB() let bitmapInfo = CGBitmapInfo(CGImageAlphaInfo.PremultipliedLast.rawValue) let bitmapContext = CGBitmapContextCreate(nil, Int(width), Int(height), 8, 0, colorSpace, bitmapInfo) CGContextClipToMask(bitmapContext, bounds, maskImage) CGContextSetFillColorWithColor(bitmapContext, color.CGColor) CGContextFillRect(bitmapContext, bounds) let cImage = CGBitmapContextCreateImage(bitmapContext) let coloredImage = UIImage(CGImage: cImage) return coloredImage! } }
extension UIImage { func maskWithColor( color:UIColor) -> UIImage { UIGraphicsBeginImageContextWithOptions(self.size, false, UIScreen.main.scale) let context = UIGraphicsGetCurrentContext()! color.setFill() context.translateBy(x: 0, y: self.size.height) context.scaleBy(x: 1.0, y: -1.0) let rect = CGRect(x: 0.0, y: 0.0, width: self.size.width, height: self.size.height) context.draw(self.cgImage!, in: rect) context.setBlendMode(CGBlendMode.sourceIn) context.addRect(rect) context.drawPath(using: CGPathDrawingMode.fill) let coloredImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return coloredImage! } }
extension UIImageView { func maskWith(color: UIColor) { guard let tempImage = image?.withRenderingMode(.alwaysTemplate) else { return } image = tempImage tintColor = color } }
let image: UIImage? = topLogo.image = image topLogo.tintColor = UIColor.white
func overlayImage(color: UIColor) -> UIImage? { UIGraphicsBeginImageContextWithOptions(self.size, false, UIScreen.main.scale) let context = UIGraphicsGetCurrentContext() color.setFill() context!.translateBy(x: 0, y: self.size.height) context!.scaleBy(x: 1.0, y: -1.0) context!.setBlendMode(CGBlendMode.colorBurn) let rect = CGRect(x: 0, y: 0, width: self.size.width, height: self.size.height) context!.draw(self.cgImage!, in: rect) context!.setBlendMode(CGBlendMode.sourceIn) context!.addRect(rect) context!.drawPath(using: CGPathDrawingMode.fill) let coloredImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return coloredImage }
import Foundation extension UIImage { func maskWithColor(color: UIColor) -> UIImage? { let maskLayer = CALayer() maskLayer.bounds = CGRect(x: 0, y: 0, width: size.width, height: size.height) maskLayer.backgroundColor = color.cgColor maskLayer.doMask(by: self) let maskImage = maskLayer.toImage() return maskImage } } extension CALayer { func doMask(by imageMask: UIImage) { let maskLayer = CAShapeLayer() maskLayer.bounds = CGRect(x: 0, y: 0, width: imageMask.size.width, height: imageMask.size.height) bounds = maskLayer.bounds maskLayer.contents = imageMask.cgImage maskLayer.frame = CGRect(x: 0, y: 0, width: frame.size.width, height: frame.size.height) mask = maskLayer } func toImage() -> UIImage? { UIGraphicsBeginImageContextWithOptions(bounds.size, isOpaque, UIScreen.main.scale) guard let context = UIGraphicsGetCurrentContext() else { UIGraphicsEndImageContext() return nil } render(in: context) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }
extension UIImage { func mask(_ color: UIColor) -> UIImage? { let maskImage = cgImage! let width = (cgImage?.width)! let height = (cgImage?.height)! let bounds = CGRect(x: 0, y: 0, width: width, height: height) let colorSpace = CGColorSpaceCreateDeviceRGB() let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue) let context = CGContext(data: nil, width: Int(width), height: Int(height), bitsPerComponent: 8, bytesPerRow: 0, space: colorSpace, bitmapInfo: bitmapInfo.rawValue)! context.clip(to: bounds, mask: maskImage) context.setFillColor(color.cgColor) context.fill(bounds) if let cgImage = context.makeImage() { let coloredImage = UIImage.init(cgImage: cgImage, scale: scale, orientation: imageOrientation) return coloredImage } else { return nil } } }
extension UIImage { public func coloredImage(color: UIColor) -> UIImage? { return coloredImage(color: color, size: CGSize(width: 1, height: 1)) } public func coloredImage(color: UIColor, size: CGSize) -> UIImage? { UIGraphicsBeginImageContextWithOptions(size, false, 0) color.setFill() UIRectFill(CGRect(origin: CGPoint(), size: size)) guard let image = UIGraphicsGetImageFromCurrentImageContext() else { return nil } UIGraphicsEndImageContext() return image } }
extension UIImage { func maskWithColor(color: UIColor) -> UIImage { var maskImage = self.CGImage let width = self.size.width let height = self.size.height let bounds = CGRect(x: 0, y: 0, width: width, height: height) let colorSpace = CGColorSpaceCreateDeviceRGB() let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue) let bitmapContext = CGContext(data: nil, width: Int(width), height: Int(height), bitsPerComponent: 8, bytesPerRow: 0, space: colorSpace, bitmapInfo: bitmapInfo.rawValue) bitmapContext!.clip(to: bounds, mask: maskImage!) bitmapContext!.setFillColor(color.cgColor) bitmapContext!.fill(bounds) let cImage = bitmapContext!.makeImage() let coloredImage = UIImage(CGImage: cImage) return coloredImage! } }
func tint(with color: UIColor) -> UIImage { UIGraphicsBeginImageContext(self.size) guard let context = UIGraphicsGetCurrentContext() else { return self } context.scaleBy(x: 1.0, y: -1.0) context.translateBy(x: 0.0, y: -self.size.height) context.setBlendMode(.multiply) let rect = CGRect(x: 0, y: 0, width: self.size.width, height: self.size.height) context.clip(to: rect, mask: self.cgImage!) color.setFill() context.fill(rect) guard let newImage = UIGraphicsGetImageFromCurrentImageContext() else { return self } UIGraphicsEndImageContext() return newImage }
func getDayOfWeek(today:String)->Int{ var formatter:NSDateFormatter = NSDateFormatter() formatter.dateFormat = "YYYY-MM-DD" var todayDate:NSDate = formatter.dateFromString(today)! var myCalendar:NSCalendar = NSCalendar(calendarIdentifier: NSGregorianCalendar) var myComponents = myCalendar.components(NSCalendarUnit.WeekdayOrdinalCalendarUnit, fromDate: todayDate) var weekDay = myComponents.weekdayOrdinal return weekDay }
static var EraCalendarUnit: NSCalendarUnit { get } static var YearCalendarUnit: NSCalendarUnit { get } static var MonthCalendarUnit: NSCalendarUnit { get } static var DayCalendarUnit: NSCalendarUnit { get } static var HourCalendarUnit: NSCalendarUnit { get } static var MinuteCalendarUnit: NSCalendarUnit { get } static var SecondCalendarUnit: NSCalendarUnit { get } static var WeekCalendarUnit: NSCalendarUnit { get } static var WeekdayCalendarUnit: NSCalendarUnit { get } static var WeekdayOrdinalCalendarUnit: NSCalendarUnit { get } static var QuarterCalendarUnit: NSCalendarUnit { get } static var WeekOfMonthCalendarUnit: NSCalendarUnit { get } static var WeekOfYearCalendarUnit: NSCalendarUnit { get } static var YearForWeekOfYearCalendarUnit: NSCalendarUnit { get } static var CalendarCalendarUnit: NSCalendarUnit { get } static var TimeZoneCalendarUnit: NSCalendarUnit { get }
func getDayOfWeek(_ today:String) -> Int? { let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd" guard let todayDate = formatter.date(from: today) else { return nil } let myCalendar = Calendar(identifier: .gregorian) let weekDay = myCalendar.component(.weekday, from: todayDate) return weekDay }
if let weekday = getDayOfWeek("2014-08-27") { print(weekday) } else { print("bad input") }
func getDayOfWeek(today:String)->Int? { let formatter = NSDateFormatter() formatter.dateFormat = "yyyy-MM-dd" if let todayDate = formatter.dateFromString(today) { let myCalendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)! let myComponents = myCalendar.components(.Weekday, fromDate: todayDate) let weekDay = myComponents.weekday return weekDay } else { return nil } }
extension Date { func dayNumberOfWeek() -> Int? { return Calendar.current.dateComponents([.weekday], from: self).weekday } } print(Date().dayNumberOfWeek()!)
extension Date { func dayOfWeek() -> String? { let dateFormatter = DateFormatter() dateFormatter.dateFormat = "EEEE" return dateFormatter.string(from: self).capitalized } } print(Date().dayOfWeek()!)
extension NSDate { func dayOfTheWeek() -> String? { let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "EEEE" return dateFormatter.stringFromDate(self) } }
extension NSDate { func dayOfTheWeek() -> String? { let weekdays = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ] let calendar: NSCalendar = NSCalendar.currentCalendar() let components: NSDateComponents = calendar.components(.Weekday, fromDate: self) return weekdays[components.weekday - 1] } }
func getDayNameBy(stringDate: String) -> String { let df = NSDateFormatter() df.dateFormat = "YYYY-MM-dd" let date = df.dateFromString(stringDate)! df.dateFormat = "EEEE" return df.stringFromDate(date); }
func getDayOfWeekString(today:String)->String? { let formatter = NSDateFormatter() formatter.dateFormat = "yyyy-MM-dd" if let todayDate = formatter.dateFromString(today) { let myCalendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)! let myComponents = myCalendar.components(.Weekday, fromDate: todayDate) let weekDay = myComponents.weekday switch weekDay { case 1: return "Sun" case 2: return "Mon" case 3: return "Tue" case 4: return "Wed" case 5: return "Thu" case 6: return "Fri" case 7: return "Sat" default: print("Error fetching days") return "Day" } } else { return nil } }
extension Date { var weekdayOrdinal: Int { return Calendar.current.component(.weekday, from: self) } }
func getDayOfWeek(today: String) -> Int{ let formatter:NSDateFormatter = NSDateFormatter() formatter.dateFormat = "yyyy-MM-dd" let todayDate = formatter.dateFromString(today) formatter.dateFormat = "e" let weekDay = formatter.stringFromDate(todayDate!) return Int(weekDay)! } getDayOfWeek("2015-12-18")
extension Date { var weekdayName: String { let formatter = DateFormatter(); formatter.dateFormat = "E" return formatter.string(from: self as Date) } var weekdayNameFull: String { let formatter = DateFormatter(); formatter.dateFormat = "EEEE" return formatter.string(from: self as Date) } var monthName: String { let formatter = DateFormatter(); formatter.dateFormat = "MMM" return formatter.string(from: self as Date) } var OnlyYear: String { let formatter = DateFormatter(); formatter.dateFormat = "YYYY" return formatter.string(from: self as Date) } var period: String { let formatter = DateFormatter(); formatter.dateFormat = "a" return formatter.string(from: self as Date) } var timeOnly: String { let formatter = DateFormatter(); formatter.dateFormat = "hh : mm" return formatter.string(from: self as Date) } var timeWithPeriod: String { let formatter = DateFormatter(); formatter.dateFormat = "hh : mm a" return formatter.string(from: self as Date) } var DatewithMonth: String { let formatter = DateFormatter(); formatter.dateStyle = .medium ; return formatter.string(from: self as Date) } }
let trivialDayStringsORDINAL = ["", "SUN","MON","TUE","WED","THU","FRI","SAT"]
let dow = Calendar.current.component(.weekday, from: someDate) print( trivialDayStringsORDINAL[dow] )
func getDayOfWeek(today:String)->String? { let formatter = NSDateFormatter() formatter.dateFormat = "yyyy-MM-dd" if let todayDate = formatter.dateFromString(today) { let myCalendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)! let myComponents = myCalendar.components(.Weekday, fromDate: todayDate) let weekDay = myComponents.weekday switch weekDay { case 1: return "Sun" case 2: return "Mon" case 3: return "Tue" case 4: return "Wed" case 5: return "Thu" case 6: return "Fri" case 7: return "Sat" default: print("Error fetching days") return "Day" } } else { return nil } } func getDateOfMonth(today:String)->String? { let formatter = NSDateFormatter() formatter.dateFormat = "yyyy-MM-dd" if let todayDate = formatter.dateFromString(today) { let myCalendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)! let myComponents = myCalendar.components(.Day, fromDate: todayDate) let weekDay = myComponents.day switch weekDay { case 1: return "1st" case 2: return "2nd" case 3: return "3rd" case 4: return "4th" case 5: return "5th" case 6: return "6th" case 7: return "7th" case 8: return "8th" case 9: return "9th" case 10: return "10th" case 11: return "11th" case 12: return "12th" case 13: return "13th" case 14: return "14th" case 15: return "15th" case 16: return "16th" case 17: return "17th" case 18: return "18th" case 19: return "19th" case 20: return "20th" case 21: return "21st" case 22: return "22nd" case 23: return "23rd" case 24: return "24th" case 25: return "25th" case 26: return "26th" case 27: return "27th" case 28: return "28th" case 29: return "29th" case 30: return "30th" case 31: return "31st" default: print("Error fetching Date Of Month") return "Day" } } else { return nil } } func getMonthOfYear(today:String)->String? { let formatter = NSDateFormatter() formatter.dateFormat = "yyyy-MM-dd" if let todayDate = formatter.dateFromString(today) { let myCalendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)! let myComponents = myCalendar.components(.Month, fromDate: todayDate) let month = myComponents.month switch month { case 1: return "Jan" case 2: return "Feb" case 3: return "Mar" case 4: return "Apr" case 5: return "May" case 6: return "Jun" case 7: return "Jul" case 8: return "Aug" case 9: return "Sep" case 10: return "Oct" case 11: return "Nov" case 12: return "Dec" default: print("Error fetching months") return "Month" } } else { return nil } }
let calendar = NSCalendar.currentCalendar() let dayInt: Int! var weekDate: [String] = [] var i = 2 print("Dates corresponding to days are") while((dayInt - dayInt) + i < 9) { let weekFirstDate = calendar.dateByAddingUnit(.Day, value: (-dayInt+i), toDate: NSDate(), options: []) let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "EEEE dd MMMM" let dayOfWeekString = dateFormatter.stringFromDate(weekFirstDate!) weekDate.append(dayOfWeekString) i++ } for i in weekDate { print(i) } } func getDayOfWeek(today:String)->Int { let formatter = NSDateFormatter() formatter.dateFormat = "MMM-dd-yyyy" let todayDate = formatter.dateFromString(today)! let myCalendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)! let myComponents = myCalendar.components(.Weekday, fromDate: todayDate) let weekDay = myComponents.weekday return weekDay } @IBAction func DateTitle(sender: AnyObject) { let currentDate = NSDate() let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "MMM-dd-yyyy" let dayOfWeekStrings = dateFormatter.stringFromDate(currentDate) dayInt = getDayOfWeek(dayOfWeekStrings) }
var i = 2 var weekday: [String] = [] var weekdate: [String] = [] var weekmonth: [String] = [] @IBAction func buttonaction(sender: AnyObject) { let currentDate = NSDate() let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "MMM-dd-yyyy" let dayOfWeekStrings = dateFormatter.stringFromDate(currentDate) let weekdays = getDayOfWeek(dayOfWeekStrings) let calendar = NSCalendar.currentCalendar() while((weekdays - weekdays) + i < 9) { let weekFirstDate = calendar.dateByAddingUnit(.Day, value: (-weekdays+i), toDate: NSDate(), options: []) let dayFormatter = NSDateFormatter() dayFormatter.dateFormat = "EEEE" let dayOfWeekString = dayFormatter.stringFromDate(weekFirstDate!) weekday.append(dayOfWeekString) let dateFormatter = NSDateFormatter() dateFormatter.dateFormat = "dd" let dateOfWeekString = dateFormatter.stringFromDate(weekFirstDate!) weekdate.append(dateOfWeekString) let monthFormatter = NSDateFormatter() monthFormatter.dateFormat = "MMMM" let monthOfWeekString = monthFormatter.stringFromDate(weekFirstDate!) weekmonth.append(monthOfWeekString) i++ } for(var j = 0; j<7 ; j++) { let day = weekday[j] let date = weekdate[j] let month = weekmonth[j] var wholeweek = date + "-" + month + "(" + day + ")" print(wholeweek) } } func getDayOfWeek(today:String)->Int { let formatter = NSDateFormatter() formatter.dateFormat = "MMM-dd-yyyy" let todayDate = formatter.dateFromString(today)! let myCalendar = NSCalendar(calendarIdentifier: NSCalendarIdentifierGregorian)! let myComponents = myCalendar.components(.Weekday, fromDate: todayDate) let daynumber = myComponents.weekday return daynumber }
func getDayOfWeek(fromDate date: Date) -> String? { let cal = Calendar(identifier: .gregorian) let dayOfWeek = cal.component(.weekday, from: date) switch dayOfWeek { case 1: return "Sunday" case 2: return "Monday" case 3: return "Tuesday" case 4: return "Wednesday" case 5: return "Thursday" case 6: return "Friday" case 7: return "Saturday" default: return nil } }
extension Date { var dayOfWeek: String { let calendar = Calendar.autoupdatingCurrent return calendar.weekdaySymbols[calendar.component(.weekday, from: self) - 1] } }
extension DateFormatter { static var standardDate: DateFormatter { let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd" return formatter } }
DateFormatter.standardDate.date(from: "2018-09-18")!.dayOfWeek
func getDayOfWeek(today:String)->Int { let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd" let todayDate = formatter.date(from: today)! let myCalendar = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)! let myComponents = myCalendar.components(NSCalendar.Unit.weekday, from: todayDate) let weekDay = myComponents.weekday return weekDay! } let weekday = getDayOfWeek(today: "2018-10-10") print(weekday)
let underlineAttribute = [NSUnderlineStyleAttributeName: NSUnderlineStyle.StyleSingle.rawValue] let underlineAttributedString = NSAttributedString(string: "StringWithUnderLine", attributes: underlineAttribute) myLabel.attributedText = underlineAttributedString
class UnderlinedLabel: UILabel { override var text: String? { didSet { guard let text = text else { return } let textRange = NSMakeRange(0, text.characters.count) let attributedText = NSMutableAttributedString(string: text) attributedText.addAttribute(NSUnderlineStyleAttributeName , value: NSUnderlineStyle.styleSingle.rawValue, range: textRange) self.attributedText = attributedText } } }
@IBOutlet weak var label: UnderlinedLabel! override func viewDidLoad() { super.viewDidLoad() label.text = "StringWithUnderLine" }
class UnderlinedLabel: UILabel { override var text: String? { didSet { guard let text = text else { return } let textRange = NSMakeRange(0, text.characters.count) let attributedText = NSMutableAttributedString(string: text) attributedText.addAttribute(NSUnderlineStyleAttributeName, value:NSUnderlineStyle.StyleSingle.rawValue, range: textRange) self.attributedText = attributedText } } }
class UnderlinedLabel: UILabel { override var text: String! { didSet { let textRange = NSMakeRange(0, count(text)) let attributedText = NSMutableAttributedString(string: text) attributedText.addAttribute(NSUnderlineStyleAttributeName, value:NSUnderlineStyle.StyleSingle.rawValue, range: textRange) self.attributedText = attributedText } } }
label.attributedText = NSAttributedString(string: "Text", attributes: [.underlineStyle: NSUnderlineStyle.styleSingle.rawValue])
label.attributedText = NSAttributedString(string: "Text", attributes: [NSUnderlineStyleAttributeName: NSUnderlineStyle.styleSingle.rawValue])
extension UILabel { func underline() { if let textString = self.text { let attributedString = NSMutableAttributedString(string: textString) attributedString.addAttribute(NSUnderlineStyleAttributeName, value: NSUnderlineStyle.styleSingle.rawValue, range: NSRange(location: 0, length: attributedString.length - 1)) attributedText = attributedString } } } extension UIButton { func underline() { let attributedString = NSMutableAttributedString(string: (self.titleLabel?.text!)!) attributedString.addAttribute(NSUnderlineStyleAttributeName, value: NSUnderlineStyle.styleSingle.rawValue, range: NSRange(location: 0, length: (self.titleLabel?.text!.characters.count)!)) self.setAttributedTitle(attributedString, for: .normal) } }
extension UILabel { func underline() { if let textString = self.text { let attributedString = NSMutableAttributedString(string: textString) attributedString.addAttribute(NSAttributedStringKey.underlineStyle, value: NSUnderlineStyle.styleSingle.rawValue, range: NSRange(location: 0, length: attributedString.length - 1)) attributedText = attributedString } } } extension UIButton { func underline() { let attributedString = NSMutableAttributedString(string: (self.titleLabel?.text!)!) attributedString.addAttribute(NSAttributedStringKey.underlineStyle, value: NSUnderlineStyle.styleSingle.rawValue, range: NSRange(location: 0, length: (self.titleLabel?.text!.count)!)) self.setAttributedTitle(attributedString, for: .normal) } }
import UIKit extension String { func getUnderLineAttributedText() -> NSAttributedString { return NSMutableAttributedString(string: self, attributes: [.underlineStyle: NSUnderlineStyle.styleSingle.rawValue]) } }
if let title = button.titleLabel?.text{ button.setAttributedTitle(title.getUnderLineAttributedText(), for: .normal) }
if let title = label.text{ label.attributedText = title.getUnderLineAttributedText() }
let textRange = NSMakeRange(0, attributedString.length) let underlinedMessage = NSMutableAttributedString(attributedString: attributedString) underlinedMessage.addAttribute(NSAttributedStringKey.underlineStyle, value:NSUnderlineStyle.styleSingle.rawValue, range: textRange) label.attributedText = underlinedMessage
attributedText.addAttribute(NSUnderlineStyleAttributeName, value: NSUnderlineStyle.styleSingle.rawValue, range: textRange)
attributedText.addAttribute(NSAttributedStringKey.underlineStyle, value: NSUnderlineStyle.styleSingle.rawValue, range: textRange)
let attributedString = NSMutableAttributedString(string: "Your Text Here", attributes: [NSAttributedStringKey.underlineStyle : true]) self.yourlabel.attributedText = attributedString
extension UIButton { func underline() { let attributedString = NSMutableAttributedString(string: (self.titleLabel?.text!)!) attributedString.addAttribute(NSUnderlineStyleAttributeName, value: NSUnderlineStyle.StyleSingle.rawValue, range: NSRange(location: 0, length: (self.titleLabel?.text!.characters.count)!)) self.setAttributedTitle(attributedString, forState: .Normal) } }
extension UILabel { func underline() { if let textString = self.text { let attributedString = NSMutableAttributedString(string: textString) attributedString.addAttribute(NSAttributedString.Key.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: NSRange(location: 0, length: textString.count)) self.attributedText = attributedString } } }
extension UIButton { func underline() { if let textString = self.titleLabel?.text { let attributedString = NSMutableAttributedString(string: textString) attributedString.addAttribute(NSAttributedString.Key.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: NSRange(location: 0, length: textString.count)) self.setAttributedTitle(attributedString, for: .normal) } } }
override func shouldAutorotate() -> Bool { return false } override func supportedInterfaceOrientations() -> UIInterfaceOrientationMask { return UIInterfaceOrientationMask.Portrait }
override func shouldAutorotate() -> Bool { return true } override func supportedInterfaceOrientations() -> UIInterfaceOrientationMask { return [UIInterfaceOrientationMask.LandscapeLeft,UIInterfaceOrientationMask.LandscapeRight] }
override func shouldAutorotate() -> Bool { if (UIDevice.currentDevice().orientation == UIDeviceOrientation.LandscapeLeft || UIDevice.currentDevice().orientation == UIDeviceOrientation.LandscapeRight || UIDevice.currentDevice().orientation == UIDeviceOrientation.Unknown) { return false } else { return true } } override func supportedInterfaceOrientations() -> UIInterfaceOrientationMask { return [UIInterfaceOrientationMask.Portrait ,UIInterfaceOrientationMask.PortraitUpsideDown] }
extension UINavigationController { public override func shouldAutorotate() -> Bool { if visibleViewController is MyViewController { return true } else { return false } } public override func supportedInterfaceOrientations() -> UIInterfaceOrientationMask { return (visibleViewController?.supportedInterfaceOrientations())! } }
extension UINavigationController { override open var shouldAutorotate: Bool { get { if let visibleVC = visibleViewController { return visibleVC.shouldAutorotate } return super.shouldAutorotate } } override open var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation{ get { if let visibleVC = visibleViewController { return visibleVC.preferredInterfaceOrientationForPresentation } return super.preferredInterfaceOrientationForPresentation } } override open var supportedInterfaceOrientations: UIInterfaceOrientationMask{ get { if let visibleVC = visibleViewController { return visibleVC.supportedInterfaceOrientations } return super.supportedInterfaceOrientations } }}
extension UITabBarController { override open var shouldAutorotate: Bool { get { if let selectedVC = selectedViewController{ return selectedVC.shouldAutorotate } return super.shouldAutorotate } } override open var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation{ get { if let selectedVC = selectedViewController{ return selectedVC.preferredInterfaceOrientationForPresentation } return super.preferredInterfaceOrientationForPresentation } } override open var supportedInterfaceOrientations: UIInterfaceOrientationMask{ get { if let selectedVC = selectedViewController{ return selectedVC.supportedInterfaceOrientations } return super.supportedInterfaceOrientations } }}
class YourViewController: UIViewController { open override var supportedInterfaceOrientations: UIInterfaceOrientationMask{ get { return .portrait } }}
class YourViewController: UIViewController { open override var shouldAutorotate: Bool { get { return false } }}
class YourViewController: UIViewController { open override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation{ get { return .portrait } }}
extension UINavigationController { public override func shouldAutorotate() -> Bool { return visibleViewController.shouldAutorotate() } public override func supportedInterfaceOrientations() -> UIInterfaceOrientationMask { return (visibleViewController?.supportedInterfaceOrientations())! } }
class ViewController: UIViewController { override func shouldAutorotate() -> Bool { if (UIDevice.currentDevice().orientation == UIDeviceOrientation.Portrait || UIDevice.currentDevice().orientation == UIDeviceOrientation.PortraitUpsideDown || UIDevice.currentDevice().orientation == UIDeviceOrientation.Unknown) { return true } else { return false } } override func supportedInterfaceOrientations() -> Int { return Int(UIInterfaceOrientationMask.Portrait.rawValue) | Int(UIInterfaceOrientationMask.PortraitUpsideDown.rawValue) } }
override func shouldAutorotate() -> Bool { return false; }
override func shouldAutorotate() -> Bool { if (UIDevice.currentDevice().orientation == UIDeviceOrientation.LandscapeLeft || UIDevice.currentDevice().orientation == UIDeviceOrientation.LandscapeRight || UIDevice.currentDevice().orientation == UIDeviceOrientation.Unknown) { return false; } else { return true; } }
override func supportedInterfaceOrientations() -> UIInterfaceOrientationMask { return UIInterfaceOrientationMask.Portrait.toRaw().hashValue | UIInterfaceOrientationMask.PortraitUpsideDown.toRaw().hashValue }
let value = UIInterfaceOrientation.LandscapeRight.rawValue UIDevice.currentDevice().setValue(value, forKey: "orientation")
Go to your pList and add or remove the following as per your requirement: "Supported Interface Orientations" - Array "Portrait (bottom home button)" - String "Portrait (top home button)" - String "Supported Interface Orientations (iPad)" - Array "Portrait (bottom home button)" - String "Portrait (top home button)" - String "Landscape (left home button)" - String "Landscape (right home button)" - String
import UIKit class UIappViewController: UIViewController { super.viewDidLoad() } override func supportedInterfaceOrientations() -> UIInterfaceOrientationMask { return UIInterfaceOrientationMask.Portrait } override func shouldAutorotate() -> Bool { return false } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
import UIKit import Foundation class LoginViewController: UIappViewController{ override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() }
override open var shouldAutorotate: Bool { return false } override open var supportedInterfaceOrientations: UIInterfaceOrientationMask { return .portrait } override open var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation { return .portrait }
override func shouldAutorotate() -> Bool { return true } override func supportedInterfaceOrientations() -> Int { return Int(UIInterfaceOrientationMask.LandscapeLeft.rawValue) | Int(UIInterfaceOrientationMask.LandscapeRight.rawValue) }
override func shouldAutorotate() -> Bool { switch UIDevice.currentDevice().orientation { case .Portrait, .PortraitUpsideDown, .Unknown: return true default: return false } } override func supportedInterfaceOrientations() -> Int { return Int(UIInterfaceOrientationMask.Portrait.rawValue) | Int(UIInterfaceOrientationMask.PortraitUpsideDown.rawValue) }
extension UINavigationController { public override func shouldAutorotate() -> Bool { return visibleViewController.shouldAutorotate() } }
override func supportedInterfaceOrientations() -> UIInterfaceOrientationMask { let orientation: UIInterfaceOrientationMask = [UIInterfaceOrientationMask.Portrait, UIInterfaceOrientationMask.PortraitUpsideDown] return orientation }
extension UINavigationController { public override func shouldAutorotate() -> Bool { var shouldAutorotate = false if visibleViewController != nil { shouldAutorotate = visibleViewController.shouldAutorotate() } return shouldAutorotate } public override func supportedInterfaceOrientations() -> Int { return visibleViewController.supportedInterfaceOrientations() } }
override func shouldAutorotate() -> Bool { if (UIDevice.currentDevice().orientation == UIDeviceOrientation.Portrait || UIDevice.currentDevice().orientation == UIDeviceOrientation.Unknown) { return true } else { return false }
override func supportedInterfaceOrientations() -> Int { return Int(UIInterfaceOrientationMask.Portrait.rawValue) }
func application(application: UIApplication, supportedInterfaceOrientationsForWindow window: UIWindow?) -> UIInterfaceOrientationMask { if self.window?.rootViewController?.presentedViewController is SignatureLandscapeViewController { let secondController = self.window!.rootViewController!.presentedViewController as! SignatureLandscapeViewController if secondController.isPresented { return UIInterfaceOrientationMask.LandscapeLeft; } else { return UIInterfaceOrientationMask.Portrait; } } else { return UIInterfaceOrientationMask.Portrait; } }
func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask { if let rootViewController = self.topViewControllerWithRootViewController(rootViewController: window?.rootViewController) { if (rootViewController.responds(to: Selector(("canRotate")))) { return .allButUpsideDown; } } return .portrait; } private func topViewControllerWithRootViewController(rootViewController: UIViewController!) -> UIViewController? { if (rootViewController == nil) { return nil } if (rootViewController.isKind(of: (UITabBarController).self)) { return topViewControllerWithRootViewController(rootViewController: (rootViewController as! UITabBarController).selectedViewController) } else if (rootViewController.isKind(of:(UINavigationController).self)) { return topViewControllerWithRootViewController(rootViewController: (rootViewController as! UINavigationController).visibleViewController) } else if (rootViewController.presentedViewController != nil) { return topViewControllerWithRootViewController(rootViewController: rootViewController.presentedViewController) } return rootViewController }
private var orientations = UIInterfaceOrientationMask.landscapeLeft override var supportedInterfaceOrientations : UIInterfaceOrientationMask { get { return self.orientations } set { self.orientations = newValue } }
extension myViewController { override open var supportedInterfaceOrientations: UIInterfaceOrientationMask { return .portrait } }
[UIView transitionWithView:collectionView duration:.5 options:UIViewAnimationOptionTransitionCurlUp animations:^{ cell.frame = CGRectMake(3, 14, 100, 100); } completion:^(BOOL finished) { }];
[self.collectionView.collectionViewLayout invalidateLayout]; UICollectionViewCell *__weak cell = [self.collectionView cellForItemAtIndexPath:indexPath]; void (^animateChangeWidth)() = ^() { CGRect frame = cell.frame; frame.size = cell.intrinsicContentSize; cell.frame = frame; }; [UIView transitionWithView:cellToChangeSize duration:0.1f options: UIViewAnimationOptionCurveLinear animations:animateChangeWidth completion:nil];
- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath { [collectionView performBatchUpdates:^{ } completion:^(BOOL finished) { }]; }
[collectionView setCollectionViewLayout:[[UICollectionViewFlowLayout alloc] init] animated:YES];
[collectionView performBatchUpdates:^{ } completion:^(BOOL finished) { }];
class CollectionViewCell: UICollectionViewCell { override var isHighlighted: Bool { didSet { if isHighlighted { UIView.animate(withDuration: 0.2, delay: 0, options: .curveEaseOut, animations: { self.transform = CGAffineTransform(scaleX: 0.95, y: 0.95) }, completion: nil) } else { UIView.animate(withDuration: 0.2, delay: 0, options: .curveEaseOut, animations: { self.transform = CGAffineTransform(scaleX: 1, y: 1) }, completion: nil) } } } }
collectionView.collectionViewLayout.invalidateLayout() UIView.animate( withDuration: 0.4, delay: 0.0, usingSpringWithDamping: 1.0, initialSpringVelocity: 0.0, options: UIViewAnimationOptions(), animations: { self.collectionView.layoutIfNeeded() }, completion: nil )
collectionView.performBatchUpdates({ () -> Void in let ctx = UICollectionViewFlowLayoutInvalidationContext() ctx.invalidateFlowLayoutDelegateMetrics = true self.collectionView!.collectionViewLayout.invalidateLayoutWithContext(ctx) }) { (_: Bool) -> Void in }
UIApplication.sharedApplication().openURL(NSURL(string: object.url))
import Cocoa if let url = URL(string: "https: NSWorkspace.shared.open(url) { print("default browser was successfully opened") }
let url = URL(string: "https: NSWorkspace.sharedWorkspace().openURL(url))
let url = NSURL(string: "https: UIApplication.sharedApplication().openURL(url)
NSWorkspace.sharedWorkspace().openURL(NSURL(string: "https:
UIApplication.sharedApplication().openURL(NSURL(string: "https:
if let checkURL = NSURL(string: "https: if NSWorkspace.shared().open(checkURL as URL) { print("URL Successfully Opened") } } else { print("Invalid URL") }
func open(url: URL, appId: String? = nil) -> Bool { return NSWorkspace.shared().open( [url], withAppBundleIdentifier: appId, options: NSWorkspaceLaunchOptions.default, additionalEventParamDescriptor: nil, launchIdentifiers: nil ) }
let url = URL(string: "https: UIApplication.shared.open(url, options: [:], completionHandler: nil)
if NSProcessInfo.processInfo().environment["XCTestConfigurationFilePath"] != nil { }
if NSProcessInfo.processInfo().environment["XCTestConfigurationFilePath"] != nil { }
if ProcessInfo.processInfo.environment["XCTestConfigurationFilePath"] != nil { }
if let _ = NSClassFromString("XCTest") { return true }
static NSNumber *__isRunningTests; + (BOOL)isRunningTests; { if (!__isRunningTests) { NSDictionary *environment = [[NSProcessInfo processInfo] environment]; NSString *isRunningTestsValue = environment[@"APPS_IS_RUNNING_TEST"]; __isRunningTests = @([isRunningTestsValue isEqualToString:@"YES"]); } return [__isRunningTests boolValue]; }
BOOL test = [[NSUserDefaults standardUserDefaults] boolForKey:@"isTest"];
var isRunningTests: Bool { return ProcessInfo.processInfo.environment["XCTestConfigurationFilePath"] != nil }
if isRunningTests { return "lena.bmp" } return "facebook_profile_photo.bmp"
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { if let _ = NSClassFromString("XCTest") { let viewController = UIViewController() let label = UILabel() label.text = "Running tests..." label.frame = viewController.view.frame label.textAlignment = .center label.textColor = .white viewController.view.addSubview(label) self.window!.rootViewController = viewController return true }
XCUIApplication *testApp = [[XCUIApplication alloc] init]; NSDictionary *customEnv = [[NSMutableDictionary alloc] init]; [customEnv setValue:@"YES" forKey:@"APPS_IS_RUNNING_TEST"]; testApp.launchEnvironment = customEnv; [testApp launch];
BOOL testing = false; ... if (! testing) { NSDictionary *environment = [[NSProcessInfo processInfo] environment]; NSString *isRunningTestsValue = environment[@"APPS_IS_RUNNING_TEST"]; testing = [isRunningTestsValue isEqualToString:@"YES"]; }
{ "id": 1, "user": { "user_name": "Tester", "real_info": { "full_name":"Jon Doe" } }, "reviews_count": [ { "count": 4 } ] }
struct ServerResponse: Decodable { var id: String var username: String var fullName: String var reviewCount: Int enum CodingKeys: String, CodingKey { case id, } }
fileprivate struct RawServerResponse: Decodable { struct User: Decodable { var user_name: String var real_info: UserRealInfo } struct UserRealInfo: Decodable { var full_name: String } struct Review: Decodable { var count: Int } var id: Int var user: User var reviews_count: [Review] } struct ServerResponse: Decodable { var id: String var username: String var fullName: String var reviewCount: Int init(from decoder: Decoder) throws { let rawResponse = try RawServerResponse(from: decoder) id = String(rawResponse.id) username = rawResponse.user.user_name fullName = rawResponse.user.real_info.full_name reviewCount = rawResponse.reviews_count.first!.count } }
import Foundation struct RawServerResponse { enum RootKeys: String, CodingKey { case id, user, reviewCount = "reviews_count" } enum UserKeys: String, CodingKey { case userName = "user_name", realInfo = "real_info" } enum RealInfoKeys: String, CodingKey { case fullName = "full_name" } enum ReviewCountKeys: String, CodingKey { case count } let id: Int let userName: String let fullName: String let reviewCount: Int }
extension RawServerResponse: Decodable { init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: RootKeys.self) id = try container.decode(Int.self, forKey: .id) } }
extension RawServerResponse: Decodable { init(from decoder: Decoder) throws { let userContainer = try container.nestedContainer(keyedBy: UserKeys.self, forKey: .user) userName = try userContainer.decode(String.self, forKey: .userName) } }
extension RawServerResponse: Decodable { init(from decoder: Decoder) throws { let realInfoKeysContainer = try userContainer.nestedContainer(keyedBy: RealInfoKeys.self, forKey: .realInfo) fullName = try realInfoKeysContainer.decode(String.self, forKey: .fullName) } }
extension RawServerResponse: Decodable { init(from decoder: Decoder) throws { var reviewUnkeyedContainer = try container.nestedUnkeyedContainer(forKey: .reviewCount) var reviewCountArray = [Int]() while !reviewUnkeyedContainer.isAtEnd { let reviewCountContainer = try reviewUnkeyedContainer.nestedContainer(keyedBy: ReviewCountKeys.self) reviewCountArray.append(try reviewCountContainer.decode(Int.self, forKey: .count)) } guard let reviewCount = reviewCountArray.first else { throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: container.codingPath + [RootKeys.reviewCount], debugDescription: "reviews_count cannot be empty")) } self.reviewCount = reviewCount } }
import Foundation struct RawServerResponse { enum RootKeys: String, CodingKey { case id, user, reviewCount = "reviews_count" } enum UserKeys: String, CodingKey { case userName = "user_name", realInfo = "real_info" } enum RealInfoKeys: String, CodingKey { case fullName = "full_name" } enum ReviewCountKeys: String, CodingKey { case count } let id: Int let userName: String let fullName: String let reviewCount: Int }
extension RawServerResponse: Decodable { init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: RootKeys.self) id = try container.decode(Int.self, forKey: .id) let userContainer = try container.nestedContainer(keyedBy: UserKeys.self, forKey: .user) userName = try userContainer.decode(String.self, forKey: .userName) let realInfoKeysContainer = try userContainer.nestedContainer(keyedBy: RealInfoKeys.self, forKey: .realInfo) fullName = try realInfoKeysContainer.decode(String.self, forKey: .fullName) var reviewUnkeyedContainer = try container.nestedUnkeyedContainer(forKey: .reviewCount) var reviewCountArray = [Int]() while !reviewUnkeyedContainer.isAtEnd { let reviewCountContainer = try reviewUnkeyedContainer.nestedContainer(keyedBy: ReviewCountKeys.self) reviewCountArray.append(try reviewCountContainer.decode(Int.self, forKey: .count)) } guard let reviewCount = reviewCountArray.first else { throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: container.codingPath + [RootKeys.reviewCount], debugDescription: "reviews_count cannot be empty")) } self.reviewCount = reviewCount } }
let jsonString = """ { "id": 1, "user": { "user_name": "Tester", "real_info": { "full_name":"Jon Doe" } }, "reviews_count": [ { "count": 4 } ] } """ let jsonData = jsonString.data(using: .utf8)! let decoder = JSONDecoder() let serverResponse = try! decoder.decode(RawServerResponse.self, from: jsonData) dump(serverResponse)
private enum CodingKeys : String, CodingKey { case id, user, reviewsCount = "reviews_count" enum User : String, CodingKey { case username = "user_name", realInfo = "real_info" enum RealInfo : String, CodingKey { case fullName = "full_name" } } enum ReviewsCount : String, CodingKey { case count } }
struct ServerResponse : Decodable { var id: Int, username: String, fullName: String, reviewCount: Int private enum CodingKeys : String, CodingKey { } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) self.id = try container.decode(Int.self, forKey: .id) let userContainer = try container.nestedContainer(keyedBy: CodingKeys.User.self, forKey: .user) self.username = try userContainer.decode(String.self, forKey: .username) let realInfoContainer = try userContainer.nestedContainer(keyedBy: CodingKeys.User.RealInfo.self, forKey: .realInfo) self.fullName = try realInfoContainer.decode(String.self, forKey: .fullName) var reviewCountContainer = try container.nestedUnkeyedContainer(forKey: .reviewsCount) let firstReviewCountContainer = try reviewCountContainer.nestedContainer(keyedBy: CodingKeys.ReviewsCount.self) self.reviewCount = try firstReviewCountContainer.decode(Int.self, forKey: .count) } }
let jsonData = """ { "id": 1, "user": { "user_name": "Tester", "real_info": { "full_name":"Jon Doe" } }, "reviews_count": [ { "count": 4 } ] } """.data(using: .utf8)! do { let response = try JSONDecoder().decode(ServerResponse.self, from: jsonData) print(response) } catch { print(error) }
"reviews_count": [ { "count": 4 }, { "count": 5 } ]
struct ServerResponse : Decodable { var id: Int var username: String var fullName: String var reviewCounts = [Int]() init(from decoder: Decoder) throws { var reviewCountContainer = try container.nestedUnkeyedContainer(forKey: .reviewsCount) if let count = reviewCountContainer.count { self.reviewCounts.reserveCapacity(count) } while !reviewCountContainer.isAtEnd { let nestedReviewCountContainer = try reviewCountContainer.nestedContainer( keyedBy: CodingKeys.ReviewsCount.self) self.reviewCounts.append( try nestedReviewCountContainer.decode(Int.self, forKey: .count) ) } } }
struct ServerResponse: Decodable, Keyedable { var id: String! var username: String! var fullName: String! var reviewCount: Int! private struct ReviewsCount: Codable { var count: Int } mutating func map(map: KeyMap) throws { var id: Int! try id <<- map["id"] self.id = String(id) try username <<- map["user.user_name"] try fullName <<- map["user.real_info.full_name"] var reviewCount: [ReviewsCount]! try reviewCount <<- map["reviews_count"] self.reviewCount = reviewCount[0].count } init(from decoder: Decoder) throws { try KeyedDecoder(with: decoder).decode(to: &self) } }
self.myFirstLabel.alpha = 0 self.myFirstButton.alpha = 0 self.mySecondButton.alpha = 0
self.view.addSubview(myFirstLabel) self.view.addSubview(myFirstButton) self.view.addSubview(mySecondButton)
UIView.animateWithDuration(1.5, animations: { self.myFirstLabel.alpha = 1.0 self.myFirstButton.alpha = 1.0 self.mySecondButton.alpha = 1.0 })
override func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) UIView.animateWithDuration(1.5, animations: { self.myFirstLabel.alpha = 1.0 self.myFirstButton.alpha = 1.0 self.mySecondButton.alpha = 1.0 }) }
public extension UIView { /** Fade in a view with a duration - parameter duration: custom animation duration */ func fadeIn(duration duration: NSTimeInterval = 1.0) { UIView.animateWithDuration(duration, animations: { self.alpha = 1.0 }) } /** Fade out a view with a duration - parameter duration: custom animation duration */ func fadeOut(duration duration: NSTimeInterval = 1.0) { UIView.animateWithDuration(duration, animations: { self.alpha = 0.0 }) } }
func fadeIn(withDuration duration: TimeInterval = 1.0) { UIView.animate(withDuration: duration, animations: { self.alpha = 1.0 }) } func fadeOut(withDuration duration: TimeInterval = 1.0) { UIView.animate(withDuration: duration, animations: { self.alpha = 0.0 }) }
let newImage = UIImage(named: "") newImage.alpha = 0 self.view.addSubview(newImage) ... newImage.fadeIn()
extension UIView { func fadeTo(_ alpha: CGFloat, duration: TimeInterval? = 0.3) { DispatchQueue.main.async { UIView.animate(withDuration: duration != nil ? duration! : 0.3) { self.alpha = alpha } } } func fadeIn(_ duration: TimeInterval? = 0.3) { fadeTo(1.0, duration: duration) } func fadeOut(_ duration: TimeInterval? = 0.3) { fadeTo(0.0, duration: duration) } }
yourView.fadeIn() yourView.fadeIn(1.0) yourView.fadeOut() yourView.fadeOut(1.0) yourView.fadeTo(0.5) yourView.fadeTo(0.5, duration: 1.0)
extension UIView { enum AnimationKeyPath: String { case opacity = "opacity" } func flash(animation: AnimationKeyPath ,withDuration duration: TimeInterval = 0.5, repeatCount: Float = 5){ let flash = CABasicAnimation(keyPath: AnimationKeyPath.opacity.rawValue) flash.duration = duration flash.fromValue = 1 flash.toValue = 0 flash.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) flash.autoreverses = true flash.repeatCount = repeatCount layer.add(flash, forKey: nil) } }
imageView.flash(animation: .opacity, withDuration: 1, repeatCount: 5) titleLabel.flash(animation: .opacity, withDuration: 1, repeatCount: 5)
class PrivacyController: UIViewController { @IBOutlet weak var webView:UIWebView! override func viewDidLoad() { let url = NSURL(fileURLWithPath: "privacy.html") let request = NSURLRequest(URL: url!) webView.loadRequest(request) } }
let url = NSBundle.mainBundle().URLForResource("privacy", withExtension:"html")
let url = Bundle.main.url(forResource: "privacy", withExtension: "html")
@IBOutlet weak var webView: UIWebView! override func viewDidLoad() { super.viewDidLoad() do { guard let filePath = Bundle.main.path(forResource: "myFile", ofType: "html") else { print ("File reading error") return } let contents = try String(contentsOfFile: filePath, encoding: .utf8) let baseUrl = URL(fileURLWithPath: filePath) webView.loadHTMLString(contents as String, baseURL: baseUrl) } catch { print ("File HTML error") } }
@IBOutlet weak var webView: UIWebView! override func viewDidLoad() { super.viewDidLoad() var testHTML = NSBundle.mainBundle().pathForResource("privacy", ofType: "html") var contents = NSString(contentsOfFile: testHTML!, encoding: NSUTF8StringEncoding, error: nil) var baseUrl = NSURL(fileURLWithPath: testHTML!) webView.loadHTMLString(contents, baseURL: baseUrl) }
if let url = Bundle.main.url(forResource: "privacy", withExtension: "html") { webview.loadRequest(URLRequest(url: url)) }
override func viewDidLoad() { super.viewDidLoad() let localfilePath = NSBundle.mainBundle().URLForResource("home", withExtension: "html"); let myRequest = NSURLRequest(URL: localfilePath!); myWebView.loadRequest(myRequest); self.view.addSubview(myWebView) }
let path = NSBundle.mainBundle().pathForResource("policy", ofType: "html") do { let fileHtml = try NSString(contentsOfFile: path!, encoding: NSUTF8StringEncoding) webView.loadHTMLString(fileHtml as String, baseURL: nil) } catch { }
@IBOutlet weak var mWebView: UIWebView! override func viewDidLoad() { super.viewDidLoad() mWebView.loadRequest(NSURLRequest(URL: NSURL(fileURLWithPath: NSBundle.mainBundle().pathForResource("fineName", ofType: "html")!))) }
mWebView.loadRequest(URLRequest(url: URL(fileURLWithPath: Bundle.main.path(forResource: "test/index", ofType: "html")!)))
func loadHtmlCode() { let htmlCode = "<html><head><title>Wonderful web</title></head> <body><p>wonderful web. loading html code in <strong>UIWebView</strong></></body>" webView.loadHTMLString(htmlCode, baseURL: nil) }
func loadHtmlFile() { let url = NSBundle.mainBundle().URLForResource("contactus", withExtension:"html") let request = NSURLRequest(URL: url!) webView.loadRequest(request) }
do { let testHTML = Bundle.main.path(forResource: "about", ofType: "html") let contents = try NSString(contentsOfFile: testHTML!, encoding: String.Encoding.utf8.rawValue) let baseUrl = NSURL(fileURLWithPath: testHTML!) mWebView.loadHTMLString(contents as String, baseURL: baseUrl as URL) } catch { }
override func viewDidLoad() { super.viewDidLoad() let localfilePath = Bundle.main.url(forResource: "homeInfo", withExtension: "html"); let myRequest = NSURLRequest(url: localfilePath!); webViewer.loadRequest(myRequest as URLRequest); self.view.addSubview(webViewer) }
infix operator ** { associativity left precedence 170 } func ** (num: Double, power: Double) -> Double{ return pow(num, power) } 2.0**2.0
precedencegroup ExponentiationPrecedence { associativity: right higherThan: MultiplicationPrecedence } infix operator ** : ExponentiationPrecedence func ** (_ base: Double, _ exp: Double) -> Double { return pow(base, exp) } func ** (_ base: Float, _ exp: Float) -> Float { return pow(base, exp) } 2.0 ** 3.0 ** 2.0 (2.0 ** 3.0) ** 2.0
operator infix ** { associativity left precedence 200 } func ** (base: Double, power: Double) -> Double { return exp(log(base) * power) }
let pow = { Array(repeating: $0, count: $1).reduce(1, *) }
func pow(_ x: Int, _ y: Int) -> Int { var result = 1 for i in 0..<y { result *= x } return result }
let mathExpression = NSExpression(format:"2.5**2.5") let answer = mathExpression.expressionValue(with: nil, context: nil) as? Double
let mathExpression = NSExpression(format:"2**3") let answer = mathExpression.expressionValue(with: nil, context: nil) as? Int
struct Usage { var totalData: Double var remainingTotalData: Double init(jsonData: NSData) { var jsonDict = [String: AnyObject]() do { jsonDict = try NSJSONSerialization.JSONObjectWithData(jsonData, options: []) as! [String: AnyObject] } catch { print("Error occurred parsing data: \(error)") } totalData = jsonDict["totalfup"] as! Double remainingTotalData = jsonDict["totalrem"] as! Double } }
totalData = (jsonDict["totalfup"] as! NSString).doubleValue
if let totalfup = (dict["totalfup"] as? NSString)?.doubleValue { }
totalData = Double(jsonDict["totalfup"] as! String)!
struct Usage { var totalData = 0.0 var remainingTotalData = 0.0 init(jsonData: NSData) { do { let jsonDict = try NSJSONSerialization.JSONObjectWithData(jsonData, options: []) as! [String: String] totalData = Double(jsonDict["totalfup"]!) remainingTotalData = Double(jsonDict["totalrem"]!) } catch { print("Error occurred parsing data: \(error)") } } }
import Foundation struct Usage { var totalData: Double = 0 var remainingTotalData: Double = 0 init(jsonData: NSData) { do { if let jsonDict = try NSJSONSerialization.JSONObjectWithData(jsonData, options: []) as? [String:Double] { totalData = jsonDict["totalfup"] ?? 0 remainingTotalData = jsonDict["totalrem"] ?? 0 } } catch { print("Error occurred parsing data: \(error)") } } } if let data = "{\"totalfup\":96.340899,\"totalrem\":3548710948}".dataUsingEncoding(NSUTF8StringEncoding) { let usage = Usage(jsonData: data) dump(usage) }
let strStatus:String = dictProperty.value(forKey: "StatusType") as! String let myStatus = Double.init(strStatus)
extension String { func toDouble() -> Double? { let numberFormatter = NumberFormatter() numberFormatter.locale = Locale(identifier: "en_US_POSIX") return numberFormatter.number(from: self)?.doubleValue } func toInt() -> Int? { let numberFormatter = NumberFormatter() numberFormatter.locale = Locale(identifier: "en_US_POSIX") return numberFormatter.number(from: self)?.intValue } func toFloat() -> Float? { let numberFormatter = NumberFormatter() numberFormatter.locale = Locale(identifier: "en_US_POSIX") return numberFormatter.number(from: self)?.floatValue } func toBool() -> Bool? { let numberFormatter = NumberFormatter() numberFormatter.locale = Locale(identifier: "en_US_POSIX") return numberFormatter.number(from: self)?.boolValue } }
enum Stage : String { case DisplayAll = "Display All" case HideQuarter = "Hide Quarter" case HideHalf = "Hide Half" case HideTwoThirds = "Hide Two Thirds" case HideAll = "Hide All" } class AppState : NSCoding, NSObject { var idx = 0 var stage = Stage.DisplayAll override init() {} required init(coder aDecoder: NSCoder) { self.idx = aDecoder.decodeIntegerForKey( "idx" ) self.stage = aDecoder.decodeObjectForKey( "stage" ) as String } func encodeWithCoder(aCoder: NSCoder) { aCoder.encodeInteger( self.idx, forKey:"idx" ) aCoder.encodeObject( self.stage as String, forKey:"stage" ) } }
class AppState : NSObject, NSCoding { var idx = 0 var stage = Stage.DisplayAll override init() {} required init(coder aDecoder: NSCoder) { self.idx = aDecoder.decodeIntegerForKey( "idx" ) self.stage = Stage(rawValue: (aDecoder.decodeObjectForKey( "stage" ) as! String)) ?? .DisplayAll } func encodeWithCoder(aCoder: NSCoder) { aCoder.encodeInteger( self.idx, forKey:"idx" ) aCoder.encodeObject( self.stage.rawValue, forKey:"stage" ) } }
self.stage = Stage(rawValue: (aDecoder.decodeObjectForKey( "stage" ) as String)) ?? .DisplayAll
self.stage = Stage.fromRaw(aDecoder.decodeObjectForKey( "stage" ) as String) ?? .DisplayAll aCoder.encodeObject( self.stage.toRaw(), forKey:"stage" )
self.stage = Stage(rawValue: aDecoder.decodeObjectForKey("stage") as! String) ?? .DisplayAll
enum Stage: String { case DisplayAll = "Display All" case HideQuarter = "Hide Quarter" case HideHalf = "Hide Half" case HideTwoThirds = "Hide Two Thirds" case HideAll = "Hide All" } class AppState: NSCoding, NSObject { var idx = 0 var stage = Stage.DisplayAll override init() {} required init(coder aDecoder: NSCoder) { self.idx = aDecoder.decodeInteger(forKey: "idx") self.stage = Stage(rawValue: aDecoder.decodeObject(forKey: "stage") as String) } func encodeWithCoder(aCoder: NSCoder) { aCoder.encode(self.idx, forKey:"idx") aCoder.encode(self.stage.rawValue, forKey:"stage") } }
var defaults = NSUserDefaults.standardUserDefaults()
var defaults = NSUserDefaults(suiteName: kDefaultsPackage)
NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@"group.yougroup"]; [shared setObject:object forKey:@"yourkey"]; [shared synchronize];
let defaults = UserDefaults(suiteName: "group.yourgroup") defaults?.set(5.9, forKey: "yourKey")
NSUserDefaults *shared = [[NSUserDefaults alloc] initWithSuiteName:@"group.yougroup"]; id value = [shared valueForKey:@"yourkey"]; NSLog(@"%@",value);
let defaults = UserDefaults(suiteName: "group.yourgroup") let x = defaults?.double(forKey: "yourKey") print(x)
var defaults = NSUserDefaults(suiteName: "group.com.seligmanventures.LightAlarmFree") defaults?.setObject("It worked!", forKey: "alarmTime") defaults?.synchronize()
var defaults = NSUserDefaults(suiteName: "group.com.seligmanventures.LightAlarmFree") defaults?.synchronize() if let restoredValue = defaults!.stringForKey("alarmTime") { myLabel.setText(restoredValue) } else { myLabel.setText("Cannot find value") }
var defaults = NSUserDefaults(suiteName: "yourappgroup")
var defaults = NSUserDefaults(suiteName: "group.yourappgroup.example")
override func viewDidLoad() { super.viewDidLoad() defaults?.synchronize() }
@IBAction func btnSend(sender: UIButton) { var aNumber : Int = 0; aNumber = aNumber + 1 defaults?.setObject("\(aNumber)", forKey: "userKey") defaults?.synchronize() }
var defaults = NSUserDefaults(suiteName: "group.yourappgroup.example")
defaults?.synchronize() var tempVar = defaults!.stringForKey("userKey")!; lblNumber.setText(tempVar);
defaults?.setObject("sending sample text", forKey: "sampleKey") defaults?.synchronize()
let shared = NSUserDefaults(suiteName: "nameOfCreatedGroup") shared("Saved String 1", forKey: "Key1") shared("Saved String 2", forKey: "Key2")
let shared = NSUserDefaults(suiteName: "nameOfCreatedGroup")! valueToRead1 = shared("Key1") as? String valueToRead2 = shared("Key2") as? String println(valueToRead1) println(valueToRead2)
NSUserDefaults *sharedUserDefault = [[NSUserDefaults alloc] initWithSuiteName:@"group.yougroup"]; [sharedUserDefault setObject:object forKey:@"yourkey"]; [sharedUserDefault synchronize]; NSUserDefaults *sharedUserDefault = [[NSUserDefaults alloc] initWithSuiteName:@"group.yougroup"]; sharedUserDefault value = [sharedUserDefault valueForKey:@"yourkey"];
var letters = "abcdefg" let index = letters.characters.indexOf("c")! let intValue = Int(index)
let intValue = letters.startIndex.distanceTo(index)
extension String { func indexDistanceOfFirst(character character: Character) -> Int? { guard let index = characters.indexOf(character) else { return nil } return startIndex.distanceTo(index) } } let letters = "abcdefg" let char: Character = "c" if let index = letters.indexDistanceOfFirst(character: char) { print("character \(char) was found at position } else { print("character \(char) was not found") }
let letters = "abcdefg" if let index = letters.characters.index(of: "c") { let distance = letters.distance(from: letters.startIndex, to: index) print("distance:", distance) }
extension String { func indexDistance(of character: Character) -> Int? { guard let index = characters.index(of: character) else { return nil } return distance(from: startIndex, to: index) } }
let letters = "abcdefg" let char: Character = "c" if let index = letters.indexDistance(of: char) { print("character \(char) was found at position } else { print("character \(char) was not found") }
let letters = "abcdefg" if let index = letters.index(of: "c") { let distance = letters.distance(from: letters.startIndex, to: index) print("distance:", distance) }
extension Collection where Element: Equatable { func indexDistance(of element: Element) -> Int? { guard let index = index(of: element) else { return nil } return distance(from: startIndex, to: index) } }
extension StringProtocol where Index == String.Index { func encodedOffset(of element: Element) -> Int? { return index(of: element)?.encodedOffset } func encodedOffset(of string: Self) -> Int? { return range(of: string)?.lowerBound.encodedOffset } }
let letters = "abcdefg" let char: Character = "c" if let index = letters.encodedOffset(of: char) { print("character \(char) was found at position } else { print("character \(char) was not found") }
var str = "abcdefg" let index = str.index(of: "c")?.encodedOffset
var str = "abcdefgc" let index = str.index(of: "c")?.encodedOffset
[self.tableView setSeparatorStyle:UITableViewCellSeparatorStyleNone];
self.tableView.separatorStyle = UITableViewCellSeparatorStyle.None
tableView.separatorStyle = UITableViewCellSeparatorStyle.none
let vc = LoginViewController(nibName: "LoginViewController", bundle: nil) self.navigationController?.pushViewController(vc, animated: true)
2014-12-09 16:51:08.219 XXXXX[1351:60b] *** Terminating app due to uncaught exception *** First throw call stack: (0x2efcaf0b 0x39761ce7 0x2efcae4d 0x31b693f9 0x31ac1eaf 0x3191e365 0x317fe895 0x318a930d 0x318a9223 0x318a8801 0x318a8529 0x318a8299 0x318a8231 0x317fa305 0x3147631b 0x31471b3f 0x314719d1 0x314713e5 0x314711f7 0x3146af1d 0x2ef96039 0x2ef939c7 0x2ef93d13 0x2eefe769 0x2eefe54b 0x33e6b6d3 0x3185d891 0x4ccc8 0x4cd04 0x39c5fab7) libc++abi.dylib: terminating with uncaught exception of type NSException (lldb)
let storyBoard : UIStoryboard = UIStoryboard(name: "Main", bundle:nil) let nextViewController = storyBoard.instantiateViewController(withIdentifier: "nextView") as! NextViewController self.present(nextViewController, animated:true, completion:nil)
let storyBoard : UIStoryboard = UIStoryboard(name: "Main", bundle:nil) let nextViewController = storyBoard.instantiateViewControllerWithIdentifier("nextView") as NextViewController self.presentViewController(nextViewController, animated:true, completion:nil)
let secondViewController = self.storyboard?.instantiateViewControllerWithIdentifier("LoginViewController") as LoginViewController self.navigationController?.pushViewController(secondViewController, animated: true)
let loginVC = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "LoginViewController") as! LoginViewController self.present(loginVC, animated: true, completion: nil)
let loginVC = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "LoginViewController") as! LoginViewController self.navigationController?.pushViewController(loginVC, animated: true)
func actioncall () { let loginPageView = self.storyboard?.instantiateViewControllerWithIdentifier("LoginPageID") as! ViewController self.navigationController?.pushViewController(loginPageView, animated: true) }
let storyBoard : UIStoryboard = UIStoryboard(name: "Main", bundle:nil) let objSomeViewController = storyBoard.instantiateViewControllerWithIdentifier(‚ÄústoryboardID‚Äù) as! SomeViewController self.navigationController?.pushViewController(objSomeViewController, animated: true) self.presentViewController(objSomeViewController, animated:true, completion:nil)
let newViewController = NewViewController() self.navigationController?.pushViewController(newViewController, animated: true)
let storyBoard: UIStoryboard = UIStoryboard(name: "Main", bundle: nil) let newViewController = storyBoard.instantiateViewController(withIdentifier: "newViewController") as! NewViewController self.present(newViewController, animated: true, completion: nil)
let storyboard = UIStoryboard(name: "Main", bundle: nil) let vc = storyboard.instantiateViewController("LoginViewController) as UIViewController self.navigationController?.pushViewController(vc, animated: true)
let VC1 = self.storyboard!.instantiateViewController(withIdentifier: "MyCustomViewController") as! ViewController let navController = UINavigationController(rootViewController: VC1) self.present(navController, animated:true, completion: nil)
class PresentationViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() var playButton = UIButton.buttonWithType(UIButtonType.System) as UIButton let image = UIImage(named: "YourPlayButton") as UIImage? playButton.frame = CGRectMake(0, 0, 100, 100) playButton.center = CGPointMake(self.view.frame.width/2, self.view.frame.height/2) playButton.addTarget(self, action: "transition:", forControlEvents: UIControlEvents.TouchUpInside) playButton.setBackgroundImage(image, forState: UIControlState.Normal) self.view.addSubview(playButton) } func transition(sender:UIButton!) { println("transition") let secondViewController = self.storyboard?.instantiateViewControllerWithIdentifier("YourSecondViewController") as UIViewController let window = UIApplication.sharedApplication().windows[0] as UIWindow UIView.transitionFromView( window.rootViewController!.view, toView: secondViewController.view, duration: 0.65, options: .TransitionCrossDissolve, completion: { finished in window.rootViewController = secondViewController }) } }
let signUpVC = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "SignUp") self.navigationController?.pushViewController(signUpVC, animated: true)
class DemoNavigationClass :UIViewController{ override func viewDidLoad(){ let lbl_Hello = UILabel(frame: CGRect(x:self.view.frame.width/3, y:self.view.frame.height/2, 200, 30)); lbl_Hello.text = "You are on Next Page" lbl_Hello.textColor = UIColor.white self.view.addSubview(lbl_Hello) } }
let button = UIButton() button.frame = (frame: CGRect(x: self.view.frame.width/3, y: self.view.frame.height/1.5, width: 200, height: 50)) button.backgroundColor = UIColor.red button.setTitle("Go to Next ", for: .normal) button.addTarget(self, action: self.view.addSubview(button)
func buttonAction(sender: UIButton!) { let obj : DemoNavigationClass = DemoNavigationClass(); self.navigationController?.pushViewController(obj, animated: true) }
let signUpVC = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "SignUp") self.navigationController?.pushViewController(signUpVC, animated: true)
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { window = UIWindow() window?.makeKeyAndVisible() window?.rootViewController = UINavigationController(rootViewController: LoginViewController()) return true }
@IBAction func registerNewUserButtonTapped(_ sender: Any) { print("---------------------------registerNewUserButtonTapped --------------------------- "); let storyBoard : UIStoryboard = UIStoryboard(name: "Main", bundle:nil) let nextViewController = storyBoard.instantiateViewController(withIdentifier: "RegisterNewUserViewController") as! RegisterNewUserViewController self.present(nextViewController, animated:true, completion:nil) }
let storyBoard : UIStoryboard = UIStoryboard(name: "Main", bundle:nil) let nextViewController = storyBoard.instantiateViewController(withIdentifier: "NextViewController") as! NextViewController self.navigationController?.pushViewController(nextViewController, animated:true)
let VC:NextViewController = storyboard?.instantiateViewController(withIdentifier: "NextViewController") as! NextViewController self.navigationController?.pushViewController(VC, animated: true)
NavigationController.PushViewController(new HomePage(), true);
text2 = text2.stringByReplacingOccurrencesOfString("Optional(", withString: "", options: NSStringCompareOptions.LiteralSearch, range: nil)
text2 = text2.replacingOccurrences(of: "\\", with: "", options: NSString.CompareOptions.literal, range: nil)
text2 = text2.textureName.replacingOccurrences(of: "\"", with: "", options: NSString.CompareOptions.literal, range:nil)
var editedText = myLabel.text?.replacingOccurrences(of: "\", with: "")
Null Character (\0) Backslash (\\) Horizontal Tab (\t) Line Feed (\n) Carriage Return (\r) Double Quote (\") Single Quote (\ Unicode scalar (\u{n})
var otherstring = "lat\" : 40.7127837,\n" var new = otherstring.stringByTrimmingCharactersInSet(NSCharacterSet.init(charactersInString: "la t, \n \" count(new) println(new)
if let realString = yourOriginalString { text2 = realString } else { text2 = "" }
string = string.replacingOccurrences(of: "potatoes", with: "tomatoes", options: NSString.CompareOptions.literal, range: nil)
string = string.replacingOccurrences(of: "potatoes", with: "", options: NSString.CompareOptions.literal, range: nil)
string = string.replacingOccurrences(of: "potatoes", with: "dog\
someString = someString.replacingOccurrences(of: "[abc]", with: "", options: [.regularExpression, .caseInsensitive])
static NSString *const API_KEY = @"KEY_A"; static NSString *const API_KEY = @"KEY_B";
let accessToken = "DebugAccessToken" let accessToken = "ProductionAccessToken"
private func setupView() { greenView.translatesAutoresizingMaskIntoConstraints = false greenView.backgroundColor = .green view.addSubview(greenView) }
let margins = view.layoutMarginsGuide NSLayoutConstraint.activate([ greenView.leadingAnchor.constraint(equalTo: margins.leadingAnchor), greenView.trailingAnchor.constraint(equalTo: margins.trailingAnchor) ])
if let guide = view.safeAreaLayoutGuide NSLayoutConstraint.activate([ greenView.topAnchor.constraintEqualToSystemSpacingBelow(guide.topAnchor, multiplier: 1.0), guide.bottomAnchor.constraintEqualToSystemSpacingBelow(greenView.bottomAnchor, multiplier: 1.0) ]) } else { let standardSpacing: CGFloat = 8.0 NSLayoutConstraint.activate([ greenView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor, constant: standardSpacing), bottomLayoutGuide.topAnchor.constraint(equalTo: greenView.bottomAnchor, constant: standardSpacing) ]) }
extension UIView { var safeTopAnchor: NSLayoutYAxisAnchor { if return self.safeAreaLayoutGuide.topAnchor } else { return self.topAnchor } } var safeLeftAnchor: NSLayoutXAxisAnchor { if return self.safeAreaLayoutGuide.leftAnchor }else { return self.leftAnchor } } var safeRightAnchor: NSLayoutXAxisAnchor { if return self.safeAreaLayoutGuide.rightAnchor }else { return self.rightAnchor } } var safeBottomAnchor: NSLayoutYAxisAnchor { if return self.safeAreaLayoutGuide.bottomAnchor } else { return self.bottomAnchor } } }
UILayoutGuide *safe = self.view.safeAreaLayoutGuide; yourView.translatesAutoresizingMaskIntoConstraints = NO; [NSLayoutConstraint activateConstraints:@[ [safe.trailingAnchor constraintEqualToAnchor:yourView.trailingAnchor], [yourView.leadingAnchor constraintEqualToAnchor:safe.leadingAnchor], [yourView.topAnchor constraintEqualToAnchor:safe.topAnchor], [safe.bottomAnchor constraintEqualToAnchor:yourView.bottomAnchor] ]];
yourView.snp.makeConstraints { (make) in if make.bottom.equalTo(view.safeAreaLayoutGuide.snp.bottomMargin) make.top.equalTo(view.safeAreaLayoutGuide.snp.topMargin) make.leading.equalTo(view.safeAreaLayoutGuide.snp.leadingMargin) make.trailing.equalTo(view.safeAreaLayoutGuide.snp.trailingMargin) } else { make.edges.equalToSuperview() } }
self.edgesForExtendedLayout = [] let newView = UIView() newView.backgroundColor = .red self.view.addSubview(newView) newView.translatesAutoresizingMaskIntoConstraints = false if let guide = self.view.safeAreaLayoutGuide newView.trailingAnchor.constraint(equalTo: guide.trailingAnchor).isActive = true newView.leadingAnchor.constraint(equalTo: guide.leadingAnchor).isActive = true newView.topAnchor.constraint(equalTo: guide.topAnchor).isActive = true newView.heightAnchor.constraint(equalToConstant: 100).isActive = true } else { NSLayoutConstraint(item: newView, attribute: .top, relatedBy: .equal, toItem: view, attribute: .top, multiplier: 1.0, constant: 0).isActive = true NSLayoutConstraint(item: newView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leading, multiplier: 1.0, constant: 0).isActive = true NSLayoutConstraint(item: newView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailing, multiplier: 1.0, constant: 0).isActive = true newView.heightAnchor.constraint(equalToConstant: 100).isActive = true }
let window = UIApplication.shared.keyWindow! let viewWidth = window.frame.size.width let viewHeight = window.frame.size.height - window.safeAreaInsets.bottom let viewFrame = CGRect(x: 0, y: 0, width: viewWidth, height: viewHeight) let aView = UIView(frame: viewFrame) aView.backgroundColor = .red view.addSubview(aView) aView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
@implementation UIView (SafeArea) - (NSLayoutAnchor *)safeTopAnchor{ if (@available(iOS 11.0, *)){ return self.safeAreaLayoutGuide.topAnchor; } else { return self.topAnchor; } } - (NSLayoutAnchor *)safeBottomAnchor{ if (@available(iOS 11.0, *)) { return self.safeAreaLayoutGuide.bottomAnchor; } else { return self.bottomAnchor; } } @end
class ViewController: UIViewController { var greenView = UIView() override func viewDidLoad() { super.viewDidLoad() greenView.backgroundColor = .green view.addSubview(greenView) } override func viewWillLayoutSubviews() { super.viewWillLayoutSubviews() greenView.translatesAutoresizingMaskIntoConstraints = false let views : [String:Any] = ["greenView":greenView] view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "H:|-[greenView]-|", options: [], metrics: nil, views: views)) view.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: "V:|-[greenView]-|", options: [], metrics: nil, views: views)) } }
override func viewSafeAreaInsetsDidChange() { super.viewSafeAreaInsetsDidChange() if !allConstraints.isEmpty { NSLayoutConstraint.deactivate(allConstraints) allConstraints.removeAll() } let newInsets = view.safeAreaInsets let leftMargin = newInsets.left > 0 ? newInsets.left : Metrics.padding let rightMargin = newInsets.right > 0 ? newInsets.right : Metrics.padding let topMargin = newInsets.top > 0 ? newInsets.top : Metrics.padding let bottomMargin = newInsets.bottom > 0 ? newInsets.bottom : Metrics.padding let metrics = [ "horizontalPadding": Metrics.padding, "iconImageViewWidth": Metrics.iconImageViewWidth, "topMargin": topMargin, "bottomMargin": bottomMargin, "leftMargin": leftMargin, "rightMargin": rightMargin] } let views: [String: Any] = [ "iconImageView": iconImageView, "appNameLabel": appNameLabel, "skipButton": skipButton, "appImageView": appImageView, "welcomeLabel": welcomeLabel, "summaryLabel": summaryLabel, "pageControl": pageControl] let iconVerticalConstraints = NSLayoutConstraint.constraints( withVisualFormat: "V:|-topMargin-[iconImageView(30)]", metrics: metrics, views: views) allConstraints += iconVerticalConstraints let topRowHorizontalFormat = """ H:|-leftMargin-[iconImageView(iconImageViewWidth)]-[appNameLabel]-[skipButton]-rightMargin-| """ ...
UIWebView.loadRequest(NSURLRequest(URL: NSURL(string: "google.ca")))
webviewInstance.loadRequest(NSURLRequest(URL: NSURL(string: "google.ca")!))
UIWebView.loadRequest(webviewInstance)(NSURLRequest(URL: NSURL(string: "google.ca")!))
@IBOutlet weak var webView: UIWebView! override func viewDidLoad() { super.viewDidLoad() let url = URL (string: "url here") let requestObj = URLRequest(url: url!) webView.loadRequest(requestObj) }
@IBOutlet weak var webView: UIWebView! override func viewDidLoad() { super.viewDidLoad() let url = URL(string: "https: let requestObj = URLRequest(url: url! as URL) webView.load(requestObj) }
let url = URL(string: "your_url_here") yourWebView.loadRequest(URLRequest(url: url!))
@IBOutlet weak var webview: UIWebView! override func viewDidLoad() { super.viewDidLoad() let url = URL (string: "http: let request = URLRequest(url: url!) webview.loadRequest(request) }
@IBOutlet weak var myWebView: UIWebView! override func viewDidLoad() { super.viewDidLoad() let url = URL (string: "https: let requestObj = URLRequest(url: url!) myWebView.loadRequest(requestObj) }
@IBOutlet weak var webview: UIWebView! webview.loadRequest(URLRequest(url: URL(string: "https:
let url = NSURL (string: "https: let request = NSURLRequest(URL: url!); webView.loadRequest(request);
let url = URL(string: "http: webview.loadRequest(URLRequest(url: url!))
override func viewDidLoad() { super.viewDidLoad() let url = NSURL (string: "http: let requestObj = NSURLRequest(URL: url!); myWebView.loadRequest(requestObj); self.view.addSubview(myWebView) }
let url = NSURL (string: "Your Url") let requestObj = NSURLRequest(url: url as! URL); YourWebViewName.loadRequest(requestObj as URLRequest)
class ViewController: UIViewController , WKNavigationDelegate{
let myBlog = "https: let url = NSURL(string: myBlog) let request = NSURLRequest(URL: url!) webView = WKWebView(frame: self.view.frame) webView.navigationDelegate = self webView.loadRequest(request) self.view.addSubview(webView) self.view.sendSubviewToBack(webView)
func webView(webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: NSError) { print(error.localizedDescription) } func webView(webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) { print("Strat to load") } func webView(webView: WKWebView, didFinishNavigation navigation: WKNavigation!) { print("finish to load") }
import UIKit import WebKit class ViewController: UIViewController, WKUIDelegate { var webView: WKWebView! override func loadView() { let webConfiguration = WKWebViewConfiguration() webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.uiDelegate = self view = webView } override func viewDidLoad() { super.viewDidLoad() let myURL = URL(string: "https: let myRequest = URLRequest(url: myURL!) webView.load(myRequest) }}
import UIKit class ViewController: UIViewController{ @IBOutlet weak var webView: UIWebView! override func viewDidLoad() { super.viewDidLoad() loadUrl() } func loadUrl(){ let url = URL(string: "Url which you want to load(www.google.com)") let requestObj = URLRequest(url: url! as URL) webView.load(requestObj) } }
let url = NSURL (string: "http: myWebView.loadRequest(NSURLRequest(URL: url!));
class SomeClass { class func someTypeMethod() { } } SomeClass.typeMethod()
class ClassA { class func staticMethod() -> String { return "STATIC" } func dynamicMethod() -> String { return "DYNAMIC" } func callBoth() -> ( dynamicRet:String, staticRet:String ) { var dynamicRet:String = self.dynamicMethod() var staticRet:String = "" return ( dynamicRet:dynamicRet, staticRet:staticRet ) } } let instance:ClassA = ClassA() let test:( dynamicRet:String, staticRet:String ) = instance.callBoth()
var staticRet:String = self.dynamicType.staticMethod()
var staticRet:String = type(of:self).staticMethod()
struct Address:Codable { var street:String var zip:String var city:String var state:String }
let address = Address(street: "Apple Bay Street", zip: "94608", city: "Emeryville", state: "California") if let encoded = try? encoder.encode(address) { if let json = String(data: encoded, encoding: .utf8) { print(json) { "state":"California", "street":"Apple Bay Street", "zip":"94608", "city":"Emeryville" } } }
let newAddress: Address = try decoder.decode(Address.self, from: encoded)
{ "state":"California", "street":"Apple Bay Street", "zip_code":"94608", "city":"Emeryville" }
struct Address : Codable { var street: String var zip: String var city: String var state: String private enum CodingKeys : String, CodingKey { case street, zip = "zip_code", city, state } }
import Foundation let address = Address(street: "Apple Bay Street", zip: "94608", city: "Emeryville", state: "California") do { let encoded = try JSONEncoder().encode(address) print(String(decoding: encoded, as: UTF8.self)) } catch { print(error) }
let jsonString = """ {"state":"California","street":"Apple Bay Street","zip_code":"94608","city":"Emeryville"} """ do { let decoded = try JSONDecoder().decode(Address.self, from: Data(jsonString.utf8)) print(decoded) } catch { print(error) }
import Foundation struct Address : Codable { var street: String var zipCode: String var city: String var state: String } let address = Address(street: "Apple Bay Street", zipCode: "94608", city: "Emeryville", state: "California") do { let encoder = JSONEncoder() encoder.keyEncodingStrategy = .convertToSnakeCase let encoded = try encoder.encode(address) print(String(decoding: encoded, as: UTF8.self)) } catch { print(error) }
let jsonString = """ {"state":"California","street":"Apple Bay Street","zip_code":"94608","city":"Emeryville"} """ do { let decoder = JSONDecoder() decoder.keyDecodingStrategy = .convertFromSnakeCase let decoded = try decoder.decode(Address.self, from: Data(jsonString.utf8)) print(decoded) } catch { print(error) }
struct S : Codable { private enum CodingKeys : String, CodingKey { case someURL = "someUrl", someOtherProperty } var someURL: String var someOtherProperty: String }
import Foundation struct AnyCodingKey : CodingKey { var stringValue: String var intValue: Int? init(_ base: CodingKey) { self.init(stringValue: base.stringValue, intValue: base.intValue) } init(stringValue: String) { self.stringValue = stringValue } init(intValue: Int) { self.stringValue = "\(intValue)" self.intValue = intValue } init(stringValue: String, intValue: Int?) { self.stringValue = stringValue self.intValue = intValue } }
extension JSONEncoder.KeyEncodingStrategy { static var convertToUpperCamelCase: JSONEncoder.KeyEncodingStrategy { return .custom { codingKeys in var key = AnyCodingKey(codingKeys.last!) if let firstChar = key.stringValue.first { let i = key.stringValue.startIndex key.stringValue.replaceSubrange( i ... i, with: String(firstChar).uppercased() ) } return key } } }
extension JSONDecoder.KeyDecodingStrategy { static var convertFromUpperCamelCase: JSONDecoder.KeyDecodingStrategy { return .custom { codingKeys in var key = AnyCodingKey(codingKeys.last!) if let firstChar = key.stringValue.first { let i = key.stringValue.startIndex key.stringValue.replaceSubrange( i ... i, with: String(firstChar).lowercased() ) } return key } } }
let address = Address(street: "Apple Bay Street", zipCode: "94608", city: "Emeryville", state: "California") do { let encoder = JSONEncoder() encoder.keyEncodingStrategy = .convertToUpperCamelCase let encoded = try encoder.encode(address) print(String(decoding: encoded, as: UTF8.self)) } catch { print(error) }
let jsonString = """ {"Street":"Apple Bay Street","City":"Emeryville","State":"California","ZipCode":"94608"} """ do { let decoder = JSONDecoder() decoder.keyDecodingStrategy = .convertFromUpperCamelCase let decoded = try decoder.decode(Address.self, from: Data(jsonString.utf8)) print(decoded) } catch { print(error) }
struct Address: Codable { var street: String var zip: String var city: String var state: String }
struct Address: Codable { var street: String var zip: String var city: String var state: String private enum CodingKeys: String, CodingKey { case street case zip case city case state } }
import Foundation struct Address: Codable { var street: String var zip: String var city: String var state: String private enum CodingKeys: String, CodingKey { case street case zip = "zip_code" case city case state } }
let address = Address(street: "Apple Bay Street", zip: "94608", city: "Emeryville", state: "California") let encoder = JSONEncoder() if let jsonData = try? encoder.encode(address), let jsonString = String(data: jsonData, encoding: .utf8) { print(jsonString) }
let jsonString = """ {"state":"California","street":"Apple Bay Street","zip_code":"94608","city":"Emeryville"} """ let decoder = JSONDecoder() if let jsonData = jsonString.data(using: .utf8), let address = try? decoder.decode(Address.self, from: jsonData) { print(address) } /* prints: Address(street: "Apple Bay Street", zip: "94608", city: "Emeryville", state: "California") */
import Foundation struct Address: Codable { var street: String var zipCode: String var cityName: String var state: String }
let address = Address(street: "Apple Bay Street", zipCode: "94608", cityName: "Emeryville", state: "California") let encoder = JSONEncoder() encoder.keyEncodingStrategy = .convertToSnakeCase if let jsonData = try? encoder.encode(address), let jsonString = String(data: jsonData, encoding: .utf8) { print(jsonString) }
let jsonString = """ {"state":"California","street":"Apple Bay Street","zip_code":"94608","city_name":"Emeryville"} """ let decoder = JSONDecoder() decoder.keyDecodingStrategy = .convertFromSnakeCase if let jsonData = jsonString.data(using: .utf8), let address = try? decoder.decode(Address.self, from: jsonData) { print(address) } /* prints: Address(street: "Apple Bay Street", zipCode: "94608", cityName: "Emeryville", state: "California") */
import Foundation struct Address: Codable { var street: String var zip: String var city: String var state: String } struct AnyKey: CodingKey { var stringValue: String var intValue: Int? init?(stringValue: String) { self.stringValue = stringValue } init?(intValue: Int) { self.stringValue = String(intValue) self.intValue = intValue } }
let address = Address(street: "Apple Bay Street", zip: "94608", city: "Emeryville", state: "California") let encoder = JSONEncoder() encoder.keyEncodingStrategy = .custom({ (keys) -> CodingKey in let lastKey = keys.last! guard lastKey.intValue == nil else { return lastKey } let stringValue = lastKey.stringValue.prefix(1).uppercased() + lastKey.stringValue.dropFirst() return AnyKey(stringValue: stringValue)! }) if let jsonData = try? encoder.encode(address), let jsonString = String(data: jsonData, encoding: .utf8) { print(jsonString) }
let jsonString = """ {"State":"California","Street":"Apple Bay Street","Zip":"94608","City":"Emeryville"} """ let decoder = JSONDecoder() decoder.keyDecodingStrategy = .custom({ (keys) -> CodingKey in let lastKey = keys.last! guard lastKey.intValue == nil else { return lastKey } let stringValue = lastKey.stringValue.prefix(1).lowercased() + lastKey.stringValue.dropFirst() return AnyKey(stringValue: stringValue)! }) if let jsonData = jsonString.data(using: .utf8), let address = try? decoder.decode(Address.self, from: jsonData) { print(address) } /* prints: Address(street: "Apple Bay Street", zip: "94608", city: "Emeryville", state: "California") */
struct Track { let id : Int let contributingArtistNames:String let name : String let albumName :String let copyrightP:String let copyrightC:String let playlistCount:Int let trackPopularity:Int let playlistFollowerCount:Int let artistFollowerCount : Int let label : String }
extension Track: Decodable { enum TrackCodingKeys: String, CodingKey { case id = "id" case contributingArtistNames = "primaryArtistsNames" case spotifyId = "spotifyId" case name = "name" case albumName = "albumName" case albumImageUrl = "albumImageUrl" case copyrightP = "copyrightP" case copyrightC = "copyrightC" case playlistCount = "playlistCount" case trackPopularity = "trackPopularity" case playlistFollowerCount = "playlistFollowerCount" case artistFollowerCount = "artistFollowers" case label = "label" } init(from decoder: Decoder) throws { let trackContainer = try decoder.container(keyedBy: TrackCodingKeys.self) if trackContainer.contains(.id){ id = try trackContainer.decode(Int.self, forKey: .id) }else{ id = 0 } if trackContainer.contains(.contributingArtistNames){ contributingArtistNames = try trackContainer.decode(String.self, forKey: .contributingArtistNames) }else{ contributingArtistNames = "" } if trackContainer.contains(.spotifyId){ spotifyId = try trackContainer.decode(String.self, forKey: .spotifyId) }else{ spotifyId = "" } if trackContainer.contains(.name){ name = try trackContainer.decode(String.self, forKey: .name) }else{ name = "" } if trackContainer.contains(.albumName){ albumName = try trackContainer.decode(String.self, forKey: .albumName) }else{ albumName = "" } if trackContainer.contains(.albumImageUrl){ albumImageUrl = try trackContainer.decode(String.self, forKey: .albumImageUrl) }else{ albumImageUrl = "" } if trackContainer.contains(.copyrightP){ copyrightP = try trackContainer.decode(String.self, forKey: .copyrightP) }else{ copyrightP = "" } if trackContainer.contains(.copyrightC){ copyrightC = try trackContainer.decode(String.self, forKey: .copyrightC) }else{ copyrightC = "" } if trackContainer.contains(.playlistCount){ playlistCount = try trackContainer.decode(Int.self, forKey: .playlistCount) }else{ playlistCount = 0 } if trackContainer.contains(.trackPopularity){ trackPopularity = try trackContainer.decode(Int.self, forKey: .trackPopularity) }else{ trackPopularity = 0 } if trackContainer.contains(.playlistFollowerCount){ playlistFollowerCount = try trackContainer.decode(Int.self, forKey: .playlistFollowerCount) }else{ playlistFollowerCount = 0 } if trackContainer.contains(.artistFollowerCount){ artistFollowerCount = try trackContainer.decode(Int.self, forKey: .artistFollowerCount) }else{ artistFollowerCount = 0 } if trackContainer.contains(.label){ label = try trackContainer.decode(String.self, forKey: .label) }else{ label = "" } } }
tableView.estimatedRowHeight = 100 tableView.rowHeight = UITableViewAutomaticDimension
cell.nameLabel.preferredMaxLayoutWidth = CGRectGetWidth(cell.nameLabel.frame) cell.idLabel.preferredMaxLayoutWidth = CGRectGetWidth(cell.idLabel.frame) cell.actionsLabel.preferredMaxLayoutWidth = CGRectGetWidth(cell.actionsLabel.frame)
cell.bounds = CGRect(x: 0, y: 0, width: CGRectGetWidth(tableView.bounds), height: 99999) cell.contentView.bounds = cell.bounds cell.layoutIfNeeded() cell.nameLabel.preferredMaxLayoutWidth = CGRectGetWidth(cell.nameLabel.frame) cell.idLabel.preferredMaxLayoutWidth = CGRectGetWidth(cell.idLabel.frame) cell.actionsLabel.preferredMaxLayoutWidth = CGRectGetWidth(cell.actionsLabel.frame)
let cellWidth = CGRectGetWidth(tableView.bounds) - kTableViewSectionIndexWidth cell.bounds = CGRect(x: 0, y: 0, width: cellWidth, height: 99999)
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { [cell layoutIfNeeded]; return cell; }
-(void)fixWidth:(UILabel *)label forCell:(UITableViewCell *)cell { float offset = 0; switch ([cell accessoryType]) { case UITableViewCellAccessoryCheckmark: offset = 39.0; break; case UITableViewCellAccessoryDetailButton: offset = 47.0; break; case UITableViewCellAccessoryDetailDisclosureButton: offset = 67.0; break; case UITableViewCellAccessoryDisclosureIndicator: offset = 33.0; break; case UITableViewCellAccessoryNone: offset = 0; break; } [label setPreferredMaxLayoutWidth:CGRectGetWidth([[self tableView]frame]) - offset - 8]; }
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { ... [self fixWidth:[cell label] forCell:cell]; return cell; }
Cell: "V:|-(10)-[nameLabel]-(8)-[pnrLabel]-(2)-[actionsLabel]"
Cell: "V:|-(10)-[nameLabel(>=21)]-(8)-[pnrLabel(>=21)]-(2)-[actionsLabel(>=21)]-(10)-|"
cell.setNeedsLayout() cell.layoutIfNeeded() return cell
package com.company.appname; import android.app.Activity; import android.telephony.SmsManager; public class MainActivity extends Activity { protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); public static final mPhoneNumber = "1111111111"; public static final mMessage = "hello phone"; SmsManager.getDefault().sendTextMessage(mPhoneNumber, null, mMessage, null, null); } }
import UIKit import MessageUI class ViewController: UIViewController, MFMessageComposeViewControllerDelegate { @IBOutlet weak var phoneNumber: UITextField! override func viewDidLoad() { super.viewDidLoad() } @IBAction func sendText(sender: UIButton) { if (MFMessageComposeViewController.canSendText()) { let controller = MFMessageComposeViewController() controller.body = "Message Body" controller.recipients = [phoneNumber.text] controller.messageComposeDelegate = self self.presentViewController(controller, animated: true, completion: nil) } } func messageComposeViewController(controller: MFMessageComposeViewController!, didFinishWithResult result: MessageComposeResult) { self.dismissViewControllerAnimated(true, completion: nil) } override func viewWillDisappear(animated: Bool) { self.navigationController?.navigationBarHidden = false } }
func sendSMSText(phoneNumber: String) { if (MFMessageComposeViewController.canSendText()) { let controller = MFMessageComposeViewController() controller.body = "" controller.recipients = [phoneNumber] controller.messageComposeDelegate = self self.present(controller, animated: true, completion: nil) } } func messageComposeViewController(_ controller: MFMessageComposeViewController, didFinishWith result: MessageComposeResult) { self.dismiss(animated: true, completion: nil) } override func viewWillDisappear(_ animated: Bool) { self.navigationController?.isNavigationBarHidden = false }
import UIKit import MessageUI class ECMMessageComposerBuilder: NSObject { private dynamic var customWindow: UIWindow? private var body: String? private var phoneNumber: String? fileprivate var messageController: MFMessageComposeViewController? var canCompose: Bool { return MFMessageComposeViewController.canSendText() } func body(_ body: String?) -> ECMMessageComposerBuilder { self.body = body return self } func phoneNumber(_ phone: String?) -> ECMMessageComposerBuilder { self.phoneNumber = phone return self } func build() -> UIViewController? { guard canCompose else { return nil } messageController = MFMessageComposeViewController() messageController?.body = body if let phone = phoneNumber { messageController?.recipients = [phone] } messageController?.messageComposeDelegate = self return messageController } func show() { customWindow = UIWindow(frame: UIScreen.main.bounds) customWindow?.rootViewController = MNViewController() let topWindow = UIApplication.shared.windows.last customWindow?.windowLevel = (topWindow?.windowLevel ?? 0) + 1 customWindow?.makeKeyAndVisible() if let messageController = build() { customWindow?.rootViewController?.present(messageController, animated: true, completion: nil) } } func hide(animated: Bool = true) { messageController?.dismiss(animated: animated, completion: nil) messageController = nil customWindow?.isHidden = true customWindow = nil } } extension ECMMessageComposerBuilder: MFMessageComposeViewControllerDelegate { func messageComposeViewController(_ controller: MFMessageComposeViewController, didFinishWith result: MessageComposeResult) { controller.dismiss(animated: true, completion: nil) hide() } }
let phoneNumber = "987654321" let composer = MNMessageComposerBuilder() composer.phoneNumber(phoneNumber).show()
let phoneNumber = "987654321" private lazy var messageComposer: MNMessageComposerBuilder = { let composer = MNMessageComposerBuilder() return composer }() messageComposer.phoneNumber(phoneNumber).show()
@IBAction func sendSmsClick(_ sender: AnyObject) { let messageVC = MFMessageComposeViewController() messageVC.body = "Enter a message"; messageVC.recipients = ["Enter tel-nr"] messageVC.messageComposeDelegate = self; self.present(messageVC, animated: false, completion: nil) } func messageComposeViewController(_ controller: MFMessageComposeViewController, didFinishWith result: MessageComposeResult) { switch (result.rawValue) { case MessageComposeResult.cancelled.rawValue: print("Message was cancelled") self.dismiss(animated: true, completion: nil) case MessageComposeResult.failed.rawValue: print("Message failed") self.dismiss(animated: true, completion: nil) case MessageComposeResult.sent.rawValue: print("Message was sent") self.dismiss(animated: true, completion: nil) default: break; } }
@IBAction func sendMessageBtnClicked(sender: AnyObject) { var messageVC = MFMessageComposeViewController() messageVC.body = "Enter a message"; messageVC.recipients = ["Enter tel-nr"] messageVC.messageComposeDelegate = self; self.presentViewController(messageVC, animated: false, completion: nil) } func messageComposeViewController(controller: MFMessageComposeViewController!, didFinishWithResult result: MessageComposeResult) { switch (result.value) { case MessageComposeResultCancelled.value: println("Message was cancelled") self.dismissViewControllerAnimated(true, completion: nil) case MessageComposeResultFailed.value: println("Message failed") self.dismissViewControllerAnimated(true, completion: nil) case MessageComposeResultSent.value: println("Message was sent") self.dismissViewControllerAnimated(true, completion: nil) default: break; } }
import UIKit class Remote: NSObject { var host = "http: var query = String() var data: NSMutableData = NSMutableData() func connect(query:NSString) { self.query = query var url = self.document() var conn = NSURLConnection(request: url, delegate: self, startImmediately: true) } func endpoint() -> NSURL { var query = self.host + self.query return NSURL(string: query) } func document() -> NSURLRequest { return NSURLRequest( URL: self.endpoint() ) } func connection(didReceiveResponse: NSURLConnection!, didReceiveResponse response: NSURLResponse!) { self.data = NSMutableData() } func connection(connection: NSURLConnection!, didReceiveData conData: NSData!) { self.data.appendData(conData) } func connectionDidFinishLoading(connection: NSURLConnection!) { var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(self.data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println(jsonResult.count) } } var remote = Remote() remote.connect("/apis")
let urlPath: String = "YOUR_URL_HERE" var url: NSURL = NSURL(string: urlPath)! var request1: NSURLRequest = NSURLRequest(URL: url) var response: AutoreleasingUnsafeMutablePointer<NSURLResponse?>=nil var dataVal: NSData = NSURLConnection.sendSynchronousRequest(request1, returningResponse: response, error:nil)! var err: NSError println(response) var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(dataVal, options: NSJSONReadingOptions.MutableContainers, error: &err) as? NSDictionary println("Synchronous\(jsonResult)")
let urlPath: String = "YOUR_URL_HERE" let url: NSURL = NSURL(string: urlPath)! let request1: NSURLRequest = NSURLRequest(URL: url) let response: AutoreleasingUnsafeMutablePointer<NSURLResponse?>=nil do{ let dataVal = try NSURLConnection.sendSynchronousRequest(request1, returningResponse: response) print(response) do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(dataVal, options: []) as? NSDictionary { print("Synchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } }catch let error as NSError { print(error.localizedDescription) }
let urlPath: String = "YOUR_URL_HERE" var url: NSURL = NSURL(string: urlPath)! var request1: NSURLRequest = NSURLRequest(URL: url) let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -> Void in var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println("Asynchronous\(jsonResult)") })
let urlPath: String = "YOUR_URL_HERE" let url: NSURL = NSURL(string: urlPath)! let request1: NSURLRequest = NSURLRequest(URL: url) let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse?, data: NSData?, error: NSError?) -> Void in do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? NSDictionary { print("ASynchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } })
var dataVal = NSMutableData() let urlPath: String = "YOUR URL HERE" var url: NSURL = NSURL(string: urlPath)! var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: true)! connection.start()
func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ self.dataVal?.appendData(data) } func connectionDidFinishLoading(connection: NSURLConnection!) { var error: NSErrorPointer=nil var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(dataVal!, options: NSJSONReadingOptions.MutableContainers, error: error) as NSDictionary println(jsonResult) }
var dataVal = NSMutableData() let urlPath: String = "YOUR URL HERE" var url: NSURL = NSURL(string: urlPath)! var request: NSURLRequest = NSURLRequest(URL: url) var connection: NSURLConnection = NSURLConnection(request: request, delegate: self, startImmediately: true)! connection.start()
func connection(connection: NSURLConnection!, didReceiveData data: NSData!){ dataVal.appendData(data) } func connectionDidFinishLoading(connection: NSURLConnection!) { do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(dataVal, options: []) as? NSDictionary { print(jsonResult) } } catch let error as NSError { print(error.localizedDescription) } }
let urlPath: String = "YOUR URL HERE" var url: NSURL = NSURL(string: urlPath)! var request1: NSMutableURLRequest = NSMutableURLRequest(URL: url) request1.HTTPMethod = "POST" var stringPost="deviceToken=123456" let data = stringPost.dataUsingEncoding(NSUTF8StringEncoding) request1.timeoutInterval = 60 request1.HTTPBody=data request1.HTTPShouldHandleCookies=false let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -> Void in var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println("AsSynchronous\(jsonResult)") })
let urlPath: String = "YOUR URL HERE" let url: NSURL = NSURL(string: urlPath)! let request1: NSMutableURLRequest = NSMutableURLRequest(URL: url) request1.HTTPMethod = "POST" let stringPost="deviceToken=123456" let data = stringPost.dataUsingEncoding(NSUTF8StringEncoding) request1.timeoutInterval = 60 request1.HTTPBody=data request1.HTTPShouldHandleCookies=false let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse?, data: NSData?, error: NSError?) -> Void in do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? NSDictionary { print("ASynchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } })
let urlPath: String = "YOUR URL HERE" var url: NSURL = NSURL(string: urlPath)! var request1: NSMutableURLRequest = NSMutableURLRequest(URL: url) request1.HTTPMethod = "GET" request1.timeoutInterval = 60 let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -> Void in var err: NSError var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println("AsSynchronous\(jsonResult)") })
let urlPath: String = "YOUR URL HERE" let url: NSURL = NSURL(string: urlPath)! let request1: NSMutableURLRequest = NSMutableURLRequest(URL: url) request1.HTTPMethod = "GET" let queue:NSOperationQueue = NSOperationQueue() NSURLConnection.sendAsynchronousRequest(request1, queue: queue, completionHandler:{ (response: NSURLResponse?, data: NSData?, error: NSError?) -> Void in do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? NSDictionary { print("ASynchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } })
let mainURL = "YOUR_URL_HERE" let url = NSURL(string: mainURL) let request = NSMutableURLRequest(URL: url!) let boundary = "78876565564454554547676" request.addValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type") request.HTTPMethod = "POST" let session = NSURLSession(configuration:NSURLSessionConfiguration.defaultSessionConfiguration(), delegate: nil, delegateQueue: nil) let imageData = UIImageJPEGRepresentation(UIImage(named: "Test.jpeg")!, 1) var body = NSMutableData() body.appendData("--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("Content-Disposition: form-data; name=\"name\"\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("PREMKUMAR\r\n".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!) body.appendData("--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("Content-Disposition: form-data; name=\"description\"\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("IOS_DEVELOPER\r\n".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: true)!) body.appendData("--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) var imageNameval = "HELLO.jpg" body.appendData("--\(boundary)\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("Content-Disposition: form-data; name=\"profile_photo\"; filename=\"\(imageNameval)\"\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("Content-Type: image/jpeg\r\n\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData(imageData!) body.appendData("\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) body.appendData("--\(boundary)--\r\n".dataUsingEncoding(NSUTF8StringEncoding)!) request.HTTPBody = body let dataTask = session.dataTaskWithRequest(request) { (data, response, error) -> Void in if error != nil { } else { let outputString : NSString = NSString(data:data!, encoding:NSUTF8StringEncoding)! print("Response:\(outputString)") } } dataTask.resume()
let request = NSMutableURLRequest(url: URL(string: "YOUR_URL_HERE" ,param: param))!, cachePolicy: .useProtocolCachePolicy, timeoutInterval:60) request.httpMethod = "POST" let session = URLSession.shared let dataTask = session.dataTask(with: request as URLRequest) {data,response,error in do { if let jsonResult = try NSJSONSerialization.JSONObjectWithData(data!, options: []) as? NSDictionary { print("ASynchronous\(jsonResult)") } } catch let error as NSError { print(error.localizedDescription) } } dataTask.resume()
class Remote: NSObject { var data = NSMutableData() func connect(query:NSString) { var url = NSURL.URLWithString("http: var request = NSURLRequest(URL: url) var conn = NSURLConnection(request: request, delegate: self, startImmediately: true) } func connection(didReceiveResponse: NSURLConnection!, didReceiveResponse response: NSURLResponse!) { println("didReceiveResponse") } func connection(connection: NSURLConnection!, didReceiveData conData: NSData!) { self.data.appendData(conData) } func connectionDidFinishLoading(connection: NSURLConnection!) { println(self.data) } deinit { println("deiniting") } }
class ViewController: UIViewController { var remote = Remote() @IBAction func downloadTest(sender : UIButton) { remote.connect("/apis") } }
let urlString = "http: var request = URLRequest(url: URL(string: urlString)!) let session = URLSession.shared session.dataTask(with: request) {data, response, error in if error != nil { print(error!.localizedDescription) return } do { let jsonResult: NSDictionary? = try JSONSerialization.jsonObject(with: data!, options: JSONSerialization.ReadingOptions.mutableContainers) as? NSDictionary print("Synchronous\(jsonResult)") } catch { print(error.localizedDescription) } }.resume()
Undefined symbol for architecture x86_64: __TFSs26_forceBridgeFromObjectiveCU__FTPSs9AnyObject_MQ__Q_", referenced from: __TFC8RayTrace14RayTracingPlot15drawFocalPointfS0_FT_T_ in RayTracingPlot.o ld: symbol(s) not found for architecture x86_64
private func drawFocalPoint() { var attributes = Dictionary<String, AnyObject>() let FString: String = "F" let distance: CGFloat = focalDistance let centerX = CGRectGetMidX(bounds) let centerY = CGRectGetMidY(bounds) let circleRadius: CGFloat = 4.0 let focalPointFrame = CGRectMake(0, 0, circleRadius * 2.0, circleRadius * 2.0) var path = UIBezierPath(ovalInRect: focalPointFrame) let color = UIColor.blackColor() let currentContext = UIGraphicsGetCurrentContext() CGContextSaveGState(currentContext) let shadowColor = UIColor(white:0, alpha:0.75).CGColor CGContextSetShadowWithColor(currentContext, CGSizeMake(0, 4), CGFloat(8), shadowColor) var imageFPath = UIBezierPath(CGPath: path.CGPath) let imageFTransform = CGAffineTransformMakeTranslation((centerX - distance - circleRadius), (centerY - circleRadius)) imageFPath.applyTransform(imageFTransform) color.set() imageFPath.fill() FString.drawAtPoint(CGPointMake(centerX - distance - circleRadius, centerY + 5), withAttributes:attributes) CGContextSetShadowWithColor(currentContext, CGSizeMake(0.0, 0.0), CGFloat(0.0), nil) CGContextRestoreGState(currentContext) }
class ClassA { enum ExampleEnum { case Option1 } } class ClassB { var example: ClassA.ExampleEnum = .Option1 }
class ClassA { enum ExampleEnum { case Option1 case Option2 } } class ClassB { var example: ClassA.ExampleEnum = .Option1 }
switch (indexPath.section, indexPath.row) { case (0, 1...5): println("in range") default: println("not at all") }
switch indexPath.section { case 0: switch indexPath.row { case 1...5, 8...10, 30...33: println("in range") default: println("not at all") } default: println("wrong section \(indexPath.section)") }
switch (indexPath.section, indexPath.row) { case (0, 1...5), (0, 8...10), (0, 30...33): println("in range") case (0, _): println("not at all") default: println("wrong section \(indexPath.section)") }
var myModel = MyModel() myModel.name = "My name" myModel.dobString = "11 March,2013" println ("my model values: Name: \myModel.name and dob: \myModel.dobString")
struct PhysicalConstants { static let speedOfLight = 299_792_458 }
enum PhysicalConstants { static let speedOfLight = 299_792_458 }
struct StaticVars { static let someString = "someString" } switch "someString" { case StaticVars.someString: print("Matched StaticVars.someString") default: print("Didn }
enum StaticVars { static let someString = "someString" } switch "someString" { case StaticVars.someString: print("Matched StaticVars.someString") default: print("Didn }
enum StaticVars { static let someString = { return "someString" } } switch "someString" { case StaticVars.someString(): print("Matched StaticVars.someString") default: print("Didn }
struct StaticVars { static let someString = "someString" private init() {} }
func setCity(item : Cities, index : Int) { citiesArray!.removeObjectAtIndex(index) citiesArray!.insertObject(item, atIndex: index) }
class Foo { func name(a:Int, b: Int) -> String { return "" } } class Bar : Foo { init() { super.init() Foo.name(1, b: 2) } }
class Bar : Foo { init() { super.init() let foo = Foo() foo.name(1, b: 2) } }
class Cat { var color: String var age: Int init (color: String, age: Int) { self.color = color self.age = age } convenience init (color: String) { self.init(color: color, age: 1){ } } } var RedCat = Cat(color: "red") print("RedCat is \(RedCat.color) and \(RedCat.age) year(s) old!")
convenience init (color: String) { self.init(color: color, age: 1) }
import Foundation class Bookshop { class func getGenres() -> NSArray { println("Hello inside getGenres") let urlPath = "http: println(urlPath) let url: NSURL = NSURL(string: urlPath) let session = NSURLSession.sharedSession() var resultsArray:NSArray! let task = session.dataTaskWithURL(url, completionHandler: {data, response, error -> Void in println("Task completed") if(error) { println(error.localizedDescription) } var err: NSError? var options:NSJSONReadingOptions = NSJSONReadingOptions.MutableContainers var jsonResult = NSJSONSerialization.JSONObjectWithData(data, options: options, error: &err) as NSDictionary if(err != nil) { println("JSON Error \(err!.localizedDescription)") } let results: NSArray = jsonResult["genres"] as NSArray NSLog("jsonResults %@", results) resultsArray = results return resultsArray }) task.resume() } }
class func getGenres(completionHandler: (genres: NSArray) -> ()) { ... let task = session.dataTaskWithURL(url) { data, response, error in ... resultsArray = results completionHandler(genres: resultsArray) } ... task.resume() }
override func viewDidLoad() { Bookshop.getGenres { genres in println("View Controller: \(genres)") } }
class func fetchGenres() -> Future<Result<[Book]>> {
func getGenres(_ completion: @escaping (NSArray) -> ()) { let urlPath = "http: print(urlPath) guard let url = URL(string: urlPath) else { return } let task = URLSession.shared.dataTask(with: url) { (data, response, error) in guard let data = data else { return } do { if let jsonResult = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions.mutableContainers) as? NSDictionary { let results = jsonResult["genres"] as! NSArray print(results) completion(results) } } catch { } } task.resume() }
class func getGenres(completionHandler: @escaping (genres: NSArray) -> ()) { ... let task = session.dataTask(with:url) { data, response, error in ... resultsArray = results completionHandler(genres: resultsArray) } ... task.resume() }
self.urlSession.dataTask(with: request, completionHandler: { (data, response, error) in self.endNetworkActivity() var responseError: Error? = error if let httpResponse = response as? HTTPURLResponse { if httpResponse.statusCode > 299 , httpResponse.statusCode != 422 { responseError = NSError.errorForHTTPStatus(httpResponse.statusCode) } } var apiResponse: Response if let _ = responseError { apiResponse = Response(request, response as? HTTPURLResponse, responseError!) self.logError(apiResponse.error!, request: request) if let nsError: NSError = responseError as NSError? , nsError.code == 401 { DispatchQueue.main.async { apiResponse = Response(request, response as? HTTPURLResponse, data!) let message = apiResponse.message() return } } else if let nsError: NSError = responseError as NSError? , nsError.code == 503 { DispatchQueue.main.async { apiResponse = Response(request, response as? HTTPURLResponse, data!) let message = apiResponse.message() return } } } else { apiResponse = Response(request, response as? HTTPURLResponse, data!) self.logResponse(data!, forRequest: request) } self.removeRequestedURL(request.url!) DispatchQueue.main.async(execute: { () -> Void in completionHandler(apiResponse) }) }).resume()
extension protocolName where Self: UIView { func someFunction() { self.layer.shadowColor = UIColor.red.cgColor } }
class MyClass: CustomStringConvertible { let text: String required init(text: String) { self.text = text } class func create() -> Self { return self.init(text: "Created") } func modify() -> Self { return type(of: self).init(text: "modifid: " + text) } var description: String { return text } } class MySubclass: MyClass { required init(text: String) { super.init(text: "MySubclass " + text) } } let myClass = MyClass.create() let myClassModified = myClass.modify() let mySubclass = MySubclass.create() let mySubclassModified = mySubclass.modify() print(myClass) print(myClassModified) print(mySubclass) print(mySubclassModified)
extension <Protocol-Name> where Self:<Class-Name> { static func foo(_ param:Type)-> Self{ guard let abc = method() as? Self else{ return xyz } }}
if let email = self.emailField?.text && let password = self.passwordField?.text { }
if let email = emailField?.text, password = passwordField?.text { }
var email: String? = "baz@bar.com" var name: String? = "foo" if let n = name, e = email where contains(e, "@") { println("name and email exist, email has @") }
if let email = emailField?.text, let password = passwordField?.text { }
switch (self.emailField?.text, self.passwordField?.text) { case let (.Some(email), .Some(password)): default: break }
func unwrap<T1, T2>(optional1: T1?, optional2: T2?) -> (T1, T2)? { switch (optional1, optional2) { case let (.Some(value1), .Some(value2)): return (value1, value2) default: return nil } }
if let (email, password) = unwrap(self.emailField?.text, self.passwordField?.text) { }
if let email = self.emailField?.text { if let password = self.passwordField?.text { } }
if let suggestions = suggestions, let suggestions1 = suggestions1 { XCTAssert((suggestions.count > suggestions1.count), "TEST CASE FAILED: suggestion is nil. delete sucessful"); }
func unwrap<T, U>(a:T?, b:U?, handler:((T, U) -> ())?) -> Bool { switch (a, b) { case let (.Some(a), .Some(b)): if handler != nil { handler!(a, b) } return true default: return false } }
var orientationLock = UIInterfaceOrientationMask.all func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask { return self.orientationLock }
struct AppUtility { static func lockOrientation(_ orientation: UIInterfaceOrientationMask) { if let delegate = UIApplication.shared.delegate as? AppDelegate { delegate.orientationLock = orientation } } static func lockOrientation(_ orientation: UIInterfaceOrientationMask, andRotateTo rotateOrientation:UIInterfaceOrientation) { self.lockOrientation(orientation) UIDevice.current.setValue(rotateOrientation.rawValue, forKey: "orientation") UINavigationController.attemptRotationToDeviceOrientation() } }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) AppUtility.lockOrientation(.portrait) } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) AppUtility.lockOrientation(.all) }
var orientationLock = UIInterfaceOrientationMask.all func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask { return self.orientationLock } struct AppUtility { static func lockOrientation(_ orientation: UIInterfaceOrientationMask) { if let delegate = UIApplication.shared.delegate as? AppDelegate { delegate.orientationLock = orientation } } static func lockOrientation(_ orientation: UIInterfaceOrientationMask, andRotateTo rotateOrientation:UIInterfaceOrientation) { self.lockOrientation(orientation) UIDevice.current.setValue(rotateOrientation.rawValue, forKey: "orientation") } }
override func viewWillAppear(_ animated: Bool) { AppDelegate.AppUtility.lockOrientation(UIInterfaceOrientationMask.portrait, andRotateTo: UIInterfaceOrientation.portrait) }
override func viewWillDisappear(_ animated: Bool) { AppDelegate.AppUtility.lockOrientation(UIInterfaceOrientationMask.all) }
override func viewDidLoad() { super.viewDidLoad() UIDevice.currentDevice().setValue(UIInterfaceOrientation.Portrait.rawValue, forKey: "orientation") } override func shouldAutorotate() -> Bool { return false } override func supportedInterfaceOrientations() -> Int { return Int(UIInterfaceOrientationMask.Portrait.rawValue) } override func preferredInterfaceOrientationForPresentation() -> UIInterfaceOrientation { return UIInterfaceOrientation.Portrait }
func application(application: UIApplication, supportedInterfaceOrientationsForWindow window: UIWindow?) -> UIInterfaceOrientationMask { return UIInterfaceOrientationMask.All }
import UIKit struct OrientationLock { static func lock(to orientation: UIInterfaceOrientationMask) { if let delegate = UIApplication.shared.delegate as? AppDelegate { delegate.orientationLock = orientation } } static func lock(to orientation: UIInterfaceOrientationMask, andRotateTo rotateOrientation: UIInterfaceOrientation) { self.lock(to: orientation) UIDevice.current.setValue(rotateOrientation.rawValue, forKey: "orientation") } }
import UIKit class TabBarController: UITabBarController, UITabBarControllerDelegate { required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) self.delegate = self } func tabBarControllerSupportedInterfaceOrientations(_ tabBarController: UITabBarController) -> UIInterfaceOrientationMask { if tabBarController.selectedViewController is MyViewControllerNotInANavigationControllerThatShouldRotate { return .allButUpsideDown } else if let navController = tabBarController.selectedViewController as? UINavigationController, navController.topViewController is MyViewControllerInANavControllerThatShouldRotate { return .allButUpsideDown } else { return .portrait } } func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool { if viewController is MyViewControllerNotInANavigationControllerThatShouldRotate { OrientationLock.lock(to: .allButUpsideDown) } else if let navController = viewController as? UINavigationController, navController.topViewController is MyViewControllerInANavigationControllerThatShouldRotate { OrientationLock.lock(to: .allButUpsideDown) } else { OrientationLock.lock(to: .portrait, andRotateTo: .portrait) } return true } }
/**This method returns top view controller in application */ class func topViewController() -> UIViewController? { let helper = UIHelper() return helper.topViewControllerWithRootViewController(rootViewController: UIApplication.shared.keyWindow?.rootViewController) } /**This is a recursive method to select the top View Controller in a app, either with TabBarController or not */ private func topViewControllerWithRootViewController(rootViewController:UIViewController?) -> UIViewController? { if(rootViewController != nil) { if let tabBarController = rootViewController as? UITabBarController, let selectedViewController = tabBarController.selectedViewController { return self.topViewControllerWithRootViewController(rootViewController: selectedViewController) } if let navigationController = rootViewController as? UINavigationController ,let visibleViewController = navigationController.visibleViewController { return self.topViewControllerWithRootViewController(rootViewController: visibleViewController) } if ((rootViewController!.presentedViewController) != nil) { let presentedViewController = rootViewController!.presentedViewController; return self.topViewControllerWithRootViewController(rootViewController: presentedViewController!); }else { return rootViewController } } return nil }
class Any_ViewController: UIViewController,orientationIsOnlyPortrait { .... }
func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask { let presentedViewController = UIHelper.topViewController() if presentedViewController is orientationIsOnlyPortrait { return .portrait } return .all }
NSNotificationCenter.defaultCenter().addObserver(self, selector: "adaptOrientationAction:", name:"adaptOrientationAction", object: nil)
func application(application: UIApplication, supportedInterfaceOrientationsForWindow window: UIWindow?) -> Int { return checkOrientation(self.window?.rootViewController) } func checkOrientation(viewController:UIViewController?)-> Int{ if (adaptOrientation == false){ return Int(UIInterfaceOrientationMask.Landscape.rawValue) }else { return Int(UIInterfaceOrientationMask.All.rawValue) } } func adaptOrientationAction(notification: NSNotification){ if adaptOrientation == false { adaptOrientation = true }else { adaptOrientation = false } }
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) { if (segue.identifier == "YOURSEGUE") { NSNotificationCenter.defaultCenter().postNotificationName("adaptOrientationAction", object: nil) } } override func viewWillAppear(animated: Bool) { if adaptOrientation == true { NSNotificationCenter.defaultCenter().postNotificationName("adaptOrientationAction", object: nil) } }
class Helper{ struct AppUtility { static func lockOrientation(_ orientation: UIInterfaceOrientationMask) { if let delegate = UIApplication.shared.delegate as? AppDelegate { delegate.orientationLock = orientation } } static func lockOrientation(_ orientation: UIInterfaceOrientationMask, andRotateTo rotateOrientation:UIInterfaceOrientation) { self.lockOrientation(orientation) UIDevice.current.setValue(rotateOrientation.rawValue, forKey: "orientation") } } }
func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask { var vc = window?.rootViewController while (vc is UITabBarController) || (vc is UINavigationController) { if let c = vc as? UINavigationController { vc = c.topViewController } else if let c = vc as? UITabBarController { vc = c.selectedViewController } } while (vc?.presentedViewController) != nil { vc = vc!.presentedViewController } print("vc = " + (vc != nil ? String(describing: type(of: vc!)) : "nil")) if (vc is TargetViewController) && !(vc!.isBeingDismissed) { return [.portrait] } return [.all] }
import UIKit extension UINavigationController { override open var supportedInterfaceOrientations: UIInterfaceOrientationMask { return .portrait } } extension UITabBarController { override open var supportedInterfaceOrientations: UIInterfaceOrientationMask { return .portrait } }
public UIInterfaceOrientationMask OrientationLock = UIInterfaceOrientationMask.All; public override UIInterfaceOrientationMask GetSupportedInterfaceOrientations(UIApplication application, UIWindow forWindow) { return this.OrientationLock; }
public static class OrientationUtility { public static void LockOrientation(UIInterfaceOrientationMask orientation) { var appdelegate = (AppDelegate) UIApplication.SharedApplication.Delegate; if(appdelegate != null) { appdelegate.OrientationLock = orientation; } } public static void LockOrientation(UIInterfaceOrientationMask orientation, UIInterfaceOrientation RotateToOrientation) { LockOrientation(orientation); UIDevice.CurrentDevice.SetValueForKey(new NSNumber((int)RotateToOrientation), new NSString("orientation")); } }
public override void ViewDidAppear(bool animated) { base.ViewWillAppear(animated); OrientationUtility.LockOrientation(UIInterfaceOrientationMask.Portrait, UIInterfaceOrientation.Portrait); } public override void ViewWillDisappear(bool animated) { base.ViewWillDisappear(animated); OrientationUtility.LockOrientation(UIInterfaceOrientationMask.All); }
var orientationLock = UIInterfaceOrientationMask.all func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -> UIInterfaceOrientationMask { return self.orientationLock } struct AppUtility { static func lockOrientation(_ orientation: UIInterfaceOrientationMask) { if let delegate = UIApplication.shared.delegate as? AppDelegate { delegate.orientationLock = orientation } } static func lockOrientation(_ orientation: UIInterfaceOrientationMask, andRotateTo rotateOrientation:UIInterfaceOrientation) { self.lockOrientation(orientation) UIDevice.current.setValue(rotateOrientation.rawValue, forKey: "orientation") } }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) AppDelegate.AppUtility.lockOrientation(UIInterfaceOrientationMask.portrait, andRotateTo: UIInterfaceOrientation.portrait) }
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) AppDelegate.AppUtility.lockOrientation(UIInterfaceOrientationMask.landscape, andRotateTo: UIInterfaceOrientation.landscape) }
func failedTransaction(_ transaction: SKPaymentTransaction) { if let transactionError = transaction.error { if transactionError.code != SKErrorCode.paymentCancelled.rawValue { } } ... }
guard let error = transaction.error as? SKError else {return} switch error.code { case .unknown: break case .paymentCancelled: break case .clientInvalid: break case .paymentInvalid: break case .paymentNotAllowed: break case .cloudServiceNetworkConnectionFailed: break case .cloudServicePermissionDenied: break case .storeProductNotAvailable: break }
extension Error { var code: Int { return (self as NSError).code } var domain: String { return (self as NSError).domain } }
if error._code == SKError.code.paymentCancelled.rawValue { ... }
let code = (error as NSError).code if code == SKError.code.paymentCancelled.rawValue { ... }
var myView = UIView(frame: CGRectMake(100, 100, 100, 100)) self.view.addSubview(myView) let gesture = UITapGestureRecognizer(target: self, action: "someAction:") let gestureSwift2AndHigher = UITapGestureRecognizer(target: self, action: self.myView.addGestureRecognizer(gesture) func someAction(sender:UITapGestureRecognizer){ } func someAction(_ sender:UITapGestureRecognizer){ } @objc func someAction(_ sender:UITapGestureRecognizer){ }
let gesture = UITapGestureRecognizer(target: self, action: self.myView.addGestureRecognizer(gesture) @objc func checkAction(sender : UITapGestureRecognizer) { }
let gesture = UITapGestureRecognizer(target: self, action: self.myView.addGestureRecognizer(gesture) func checkAction(sender : UITapGestureRecognizer) { }
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.location(in: self) } } override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.location(in: self) } } override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.location(in: self) } }
override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.locationInView(self) } } override func touchesMoved(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.locationInView(self) } } override func touchesEnded(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.locationInView(self) } }
class YourView: UIView { override func touchesBegan(touches: Set<NSObject>, withEvent event: UIEvent) { if let touch = touches.first as? UITouch { let currentPoint = touch.locationInView(self) } } override func touchesMoved(touches: Set<NSObject>, withEvent event: UIEvent) { if let touch = touches.first as? UITouch { let currentPoint = touch.locationInView(self) } } override func touchesEnded(touches: Set<NSObject>, withEvent event: UIEvent) { if let touch = touches.first as? UITouch { let currentPoint = touch.locationInView(self) } } }
@IBOutlet weak var someView: UIView! let gesture = UITapGestureRecognizer(target: self, action: self.someView.addGestureRecognizer(gesture) @objc func someAction(_ sender:UITapGestureRecognizer){ print("view was clicked") }
class ClickableUIView: UIView { override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.locationInView(self) } self.backgroundColor = UIColor.magentaColor() } override func touchesMoved(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.locationInView(self) } self.backgroundColor = UIColor.magentaColor() } override func touchesEnded(touches: Set<UITouch>, withEvent event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.locationInView(self) } self.backgroundColor = UIColor.whiteColor() }
@IBOutlet weak var panVerificationUIView:ClickableUIView!
@IBOutlet weak var viewLabel1: UIView! @IBOutlet weak var viewLabel2: UIView! override func viewDidLoad() { super.viewDidLoad() let myView = UITapGestureRecognizer(target: self, action: self.viewLabel1.addGestureRecognizer(myView) } @objc func someAction(_ sender:UITapGestureRecognizer){ viewLabel2.isHidden = true }
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.location(in: self.view) } } override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.location(in: self.view) } } override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) { if let touch = touches.first { let currentPoint = touch.location(in: self.view) } }
extension UIView { func addTapGesture(action : @escaping ()->Void ){ let tap = MyTapGestureRecognizer(target: self , action: tap.action = action tap.numberOfTapsRequired = 1 self.addGestureRecognizer(tap) self.isUserInteractionEnabled = true } @objc func handleTap(_ sender: MyTapGestureRecognizer) { sender.action!() } } class MyTapGestureRecognizer: UITapGestureRecognizer { var action : (()->Void)? = nil }
@IBOutlet weak var testView: UIView! testView.addTapGesture{ }
-(id)init{ self = [[[NSBundle mainBundle] loadNibNamed:@"ViewBtnWishList" owner:0 options:nil] objectAtIndex:0]; return self; }
init(frame: CGRect) { self = NSBundle.mainBundle().loadNibNamed("ViewDetailMenu", owner: 0, options: nil)[0] as? UIView }
extension UIView { class func loadFromNibNamed(nibNamed: String, bundle: Bundle? = nil) -> UIView? { return UINib( nibName: nibNamed, bundle: bundle ).instantiate(withOwner: nil, options: nil)[0] as? UIView } }
extension UIView { class func loadFromNibNamed(nibNamed: String, bundle: NSBundle? = nil) -> UIView? { return UINib( nibName: nibNamed, bundle: bundle ).instantiateWithOwner(nil, options: nil)[0] as? UIView } }
import UIKit @IBDesignable class SimpleCustomView:UIView { var view:UIView!; @IBOutlet weak var lblTitle: UILabel! @IBInspectable var lblTitleText : String? { get{ return lblTitle.text; } set(lblTitleText) { lblTitle.text = lblTitleText!; } } override init(frame: CGRect) { super.init(frame: frame) loadViewFromNib () } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) loadViewFromNib () } func loadViewFromNib() { let bundle = NSBundle(forClass: self.dynamicType) let nib = UINib(nibName: "SimpleCustomView", bundle: bundle) let view = nib.instantiateWithOwner(self, options: nil)[0] as! UIView view.frame = bounds view.autoresizingMask = [.FlexibleWidth, .FlexibleHeight] self.addSubview(view); } }
self.customView = SimpleCustomView(frame: CGRectMake(100, 100, 200, 200)) self.view.addSubview(self.customView!);
override func awakeAfterUsingCoder(aDecoder: NSCoder) -> AnyObject? { if self.subviews.count == 0 { return loadNib() } return self } private func loadNib() -> YourCustomView { return NSBundle.mainBundle().loadNibNamed("YourCustomViewNibName", owner: nil, options: nil)[0] as YourCustomView }
class func instanceFromNib() -> UIView { return UINib(nibName: "<<NibFileName>>", bundle: nil).instantiate(withOwner: nil, options: nil)[0] as! UIView }
class func instanceFromNib() -> UIView { return UINib(nibName: "<<NibFileName>>", bundle: nil).instantiateWithOwner(nil, options: nil)[0] as UIView }
import UIKit class CustomView: UIView { class func instanceFromNib() -> UIView { return UINib(nibName: "CustomView", bundle: nil).instantiateWithOwner(nil, options: nil)[0] as! UIView } } let customView = CustomView.instanceFromNib() as! CustomView
protocol XibInitializable { static var name: String { get } static var bundle: Bundle? { get } static func fromXib() -> Self }
extension XibInitializable where Self : UIView { static var name: String { return String(describing: Self.self) } static var bundle: Bundle? { return nil } static func fromXib() -> Self { return UINib(nibName: name, bundle: bundle).instantiate(withOwner: nil, options: nil)[0] as! Self } }
import UIKit protocol UIViewLoading {} extension UIView : UIViewLoading {} extension UIViewLoading where Self : UIView { static func loadFromNib() -> Self { let nibName = "\(self)".characters.split{$0 == "."}.map(String.init).last! let nib = UINib(nibName: nibName, bundle: nil) return nib.instantiateWithOwner(self, options: nil).first as! Self } }
extension UINib { static func instantiateViewAndEmbedWithConstraints <T: UIView> (viewType viewType: T.Type, embedInto containerView: UIView) -> T { let view = UINib(nibName: String(viewType), bundle: nil).instantiateWithOwner(nil, options: nil).first as! T containerView.addSubview(view) view.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint(item: view, attribute: .Leading, relatedBy: .Equal, toItem: containerView, attribute: .Leading, multiplier: 1, constant: 0).active = true NSLayoutConstraint(item: view, attribute: .Trailing, relatedBy: .Equal, toItem: containerView, attribute: .Trailing, multiplier: 1, constant: 0).active = true NSLayoutConstraint(item: view, attribute: .Top, relatedBy: .Equal, toItem: containerView, attribute: .Top, multiplier: 1, constant: 0).active = true NSLayoutConstraint(item: view, attribute: .Bottom, relatedBy: .Equal, toItem: containerView, attribute: .Bottom, multiplier: 1, constant: 0).active = true return view } }
...outlets... @IBOutlet var containerView: UIView! var customView: CustomView! ...viewDidLoad... customView = UINib.instantiateViewAndEmbedWithConstraints(viewType: CustomView.self, embedInto: containerView)
func sendRequest(url:String,params:NSDictionary){ let urls: NSURL! = NSURL(string:url) var request = NSMutableURLRequest(URL:urls) request.HTTPMethod = "GET" var data:NSData! = NSKeyedArchiver.archivedDataWithRootObject(params) request.HTTPBody = data println(request) var session = NSURLSession.sharedSession() var task = session.dataTaskWithRequest(request, completionHandler:loadedData) task.resume() } } func loadedData(data:NSData!,response:NSURLResponse!,err:NSError!){ if(err != nil){ println(err?.description) }else{ var jsonResult: NSDictionary = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary println(jsonResult) } }
var url = URLComponents(string: "https: url.queryItems = [ URLQueryItem(name: "q", value: "War & Peace") ]
var url = URLComponents(string: "https: url.queryItems = [ URLQueryItem(name: "i", value: "1+2") ] url.percentEncodedQuery = url.percentEncodedQuery?.replacingOccurrences(of: "+", with: "%2B")
func sendRequest(_ url: String, parameters: [String: String], completion: @escaping ([String: Any]?, Error?) -> Void) { var components = URLComponents(string: url)! components.queryItems = parameters.map { (key, value) in URLQueryItem(name: key, value: value) } components.percentEncodedQuery = components.percentEncodedQuery?.replacingOccurrences(of: "+", with: "%2B") let request = URLRequest(url: components.url!) let task = URLSession.shared.dataTask(with: request) { data, response, error in guard let data = data, let response = response as? HTTPURLResponse, (200 ..< 300) ~= response.statusCode, error == nil else { completion(nil, error) return } let responseObject = (try? JSONSerialization.jsonObject(with: data)) as? [String: Any] completion(responseObject, nil) } task.resume() }
sendRequest("someurl", parameters: ["foo": "bar"]) { responseObject, error in guard let responseObject = responseObject, error == nil else { print(error ?? "Unknown error") return } }
var urlComponents = NSURLComponents(string: "https: urlComponents.queryItems = [ NSURLQueryItem(name: "q", value: String(51.500833)+","+String(-0.141944)), NSURLQueryItem(name: "z", value: String(6)) ] urlComponents.URL
struct Constants { struct APIDetails { static let APIScheme = "https" static let APIHost = "restcountries.eu" static let APIPath = "/rest/v1/alpha/" } } private func createURLFromParameters(parameters: [String:Any], pathparam: String?) -> URL { var components = URLComponents() components.scheme = Constants.APIDetails.APIScheme components.host = Constants.APIDetails.APIHost components.path = Constants.APIDetails.APIPath if let paramPath = pathparam { components.path = Constants.APIDetails.APIPath + "\(paramPath)" } if !parameters.isEmpty { components.queryItems = [URLQueryItem]() for (key, value) in parameters { let queryItem = URLQueryItem(name: key, value: "\(value)") components.queryItems!.append(queryItem) } } return components.url! } let url = createURLFromParameters(parameters: ["fullText" : "true"], pathparam: "IN")
extension URL { func getQueryItemValueForKey(key: String) -> String? { guard let components = NSURLComponents(url: self, resolvingAgainstBaseURL: false) else { return nil } guard let queryItems = components.queryItems else { return nil } return queryItems.filter { $0.name.lowercased() == key.lowercased() }.first?.value } }
var originalFilename = "" if let url = info[UIImagePickerControllerReferenceURL] as? URL, let imageIdentifier = url.getQueryItemValueForKey(key: "id") { originalFilename = imageIdentifier + ".png" print("file name : \(originalFilename)") }
extension Dictionary { func stringFromHttpParameters() -> String { var parametersString = "" for (key, value) in self { if let key = key as? String, let value = value as? String { parametersString = parametersString + key + "=" + value + "&" } } parametersString = parametersString.substring(to: parametersString.index(before: parametersString.endIndex)) return parametersString.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)! } }
extension Dictionary where Key : CustomStringConvertible, Value : CustomStringConvertible { func stringFromHttpParameters() -> String { var parametersString = "" for (key, value) in self { parametersString += key.description + "=" + value.description + "&" } return parametersString } }
let dictionary = ["method":"login_user", "cel":mobile.text! "password":password.text!] as Dictionary<String,String> for (key, value) in dictionary { data=data+"&"+key+"="+value } request.HTTPBody = data.dataUsingEncoding(NSUTF8StringEncoding);
[[UIApplication sharedApplication] statusBarOrientation]
override func didRotateFromInterfaceOrientation(fromInterfaceOrientation: UIInterfaceOrientation) { var text="" switch UIDevice.currentDevice().orientation{ case .Portrait: text="Portrait" case .PortraitUpsideDown: text="PortraitUpsideDown" case .LandscapeLeft: text="LandscapeLeft" case .LandscapeRight: text="LandscapeRight" default: text="Another" } NSLog("You have moved: \(text)") }
override func didRotate(from fromInterfaceOrientation: UIInterfaceOrientation) { var text="" switch UIDevice.current.orientation{ case .portrait: text="Portrait" case .portraitUpsideDown: text="PortraitUpsideDown" case .landscapeLeft: text="LandscapeLeft" case .landscapeRight: text="LandscapeRight" default: text="Another" } NSLog("You have moved: \(text)") }
override func willRotateToInterfaceOrientation(toInterfaceOrientation: UIInterfaceOrientation, duration: NSTimeInterval) { }
UIApplication.sharedApplication().statusBarOrientation
override func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) { if UIDevice.currentDevice().orientation.isLandscape.boolValue { print("landscape") } else { print("portrait") } }
struct DeviceInfo { struct Orientation { static var isLandscape: Bool { get { return UIDevice.current.orientation.isValidInterfaceOrientation ? UIDevice.current.orientation.isLandscape : UIApplication.shared.statusBarOrientation.isLandscape } } static var isPortrait: Bool { get { return UIDevice.current.orientation.isValidInterfaceOrientation ? UIDevice.current.orientation.isPortrait : UIApplication.shared.statusBarOrientation.isPortrait } } }}
override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { if UIDevice.current.orientation.isLandscape { print("landscape") } else { print("portrait") } }
if UIScreen.mainScreen().bounds.height > UIScreen.mainScreen().bounds.width { } else { }
override func viewWillAppear(animated: Bool) { let size: CGSize = UIScreen.mainScreen().bounds.size if size.width / size.height > 1 { print("landscape") } else { print("portrait") } } override func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) { if size.width / size.height > 1 { print("landscape") } else { print("portrait") } }
override func willRotateToInterfaceOrientation(toInterfaceOrientation: UIInterfaceOrientation, duration: NSTimeInterval) { if (toInterfaceOrientation.isLandscape) { NSLog("Landscape"); } else { NSLog("Portrait"); } }
override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { if (size.width / size.height > 1) { print("landscape") } else { print("portrait") } }
NotificationCenter.default.addObserver(self, selector: @objc func didOrientationChange(_ notification: Notification) { print("other") switch UIDevice.current.orientation { case .landscapeLeft, .landscapeRight: print("landscape") case .portrait, .portraitUpsideDown: print("portrait") default: print("other") } }
if (UIInterfaceOrientationIsLandscape([UIApplication sharedApplication].statusBarOrientation))
if UIApplication.shared.statusBarOrientation.isLandscape
func textToImage(drawText: NSString, inImage: UIImage, atPoint: CGPoint) -> UIImage{ var textColor = UIColor.whiteColor() var textFont = UIFont(name: "Helvetica Bold", size: 12)! let scale = UIScreen.mainScreen().scale UIGraphicsBeginImageContextWithOptions(inImage.size, false, scale) let textFontAttributes = [ NSFontAttributeName: textFont, NSForegroundColorAttributeName: textColor, ] inImage.drawInRect(CGRectMake(0, 0, inImage.size.width, inImage.size.height)) var rect = CGRectMake(atPoint.x, atPoint.y, inImage.size.width, inImage.size.height) drawText.drawInRect(rect, withAttributes: textFontAttributes) var newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage }
textToImage("000", inImage: UIImage(named:"thisImage.png")!, atPoint: CGPointMake(20, 20))
func textToImage(drawText text: NSString, inImage image: UIImage, atPoint point: CGPoint) -> UIImage { let textColor = UIColor.white let textFont = UIFont(name: "Helvetica Bold", size: 12)! let scale = UIScreen.main.scale UIGraphicsBeginImageContextWithOptions(image.size, false, scale) let textFontAttributes = [ NSFontAttributeName: textFont, NSForegroundColorAttributeName: textColor, ] as [String : Any] image.draw(in: CGRect(origin: CGPoint.zero, size: image.size)) let rect = CGRect(origin: point, size: image.size) text.draw(in: rect, withAttributes: textFontAttributes) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! }
func textToImage(drawText text: String, inImage image: UIImage, atPoint point: CGPoint) -> UIImage { let textColor = UIColor.white let textFont = UIFont(name: "Helvetica Bold", size: 12)! let scale = UIScreen.main.scale UIGraphicsBeginImageContextWithOptions(image.size, false, scale) let textFontAttributes = [ NSAttributedStringKey.font: textFont, NSAttributedStringKey.foregroundColor: textColor, ] as [NSAttributedStringKey : Any] image.draw(in: CGRect(origin: CGPoint.zero, size: image.size)) let rect = CGRect(origin: point, size: image.size) text.draw(in: rect, withAttributes: textFontAttributes) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! }
func generateImageWithText(text: String) -> UIImage { let image = UIImage(named: "imageWithoutText")! let imageView = UIImageView(image: image) imageView.backgroundColor = UIColor.clearColor() imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height) let label = UILabel(frame: CGRectMake(0, 0, image.size.width, image.size.height)) label.backgroundColor = UIColor.clearColor() label.textAlignment = .Center label.textColor = UIColor.whiteColor() label.text = text UIGraphicsBeginImageContextWithOptions(label.bounds.size, false, 0); imageView.layer.renderInContext(UIGraphicsGetCurrentContext()!) label.layer.renderInContext(UIGraphicsGetCurrentContext()!) let imageWithText = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext(); return imageWithText }
let textLayer = CATextLayer() textLayer.frame = someView.bounds var string = "" for _ in 1...20 { string += "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce auctor arcu quis velit congue dictum. " } textLayer.string = string let fontName: CFStringRef = "Noteworthy-Light" textLayer.font = CTFontCreateWithName(fontName, fontSize, nil) textLayer.foregroundColor = UIColor.darkGrayColor().CGColor textLayer.wrapped = true textLayer.alignmentMode = kCAAlignmentLeft textLayer.contentsScale = UIScreen.mainScreen().scale someView.layer.addSublayer(textLayer)
import Foundation import UIKit extension UIImage { class func createImageWithLabelOverlay(label: UILabel,imageSize: CGSize, image: UIImage) -> UIImage { UIGraphicsBeginImageContextWithOptions(CGSize(width: imageSize.width, height: imageSize.height), false, 2.0) let currentView = UIView.init(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height)) let currentImage = UIImageView.init(image: image) currentImage.frame = CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height) currentView.addSubview(currentImage) currentView.addSubview(label) currentView.layer.render(in: UIGraphicsGetCurrentContext()!) let img = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return img! } }
let newImageWithOverlay = UIImage.createImageWithLabelOverlay(label: labelToAdd, imageSize: size, image: editedImage)
func textToImage(drawText text: NSString, inImage image: UIImage, atPoint point: CGPoint) -> UIImage { let scale = UIScreen.main.scale UIGraphicsBeginImageContextWithOptions(image.size, false, scale) image.draw(in: CGRect(origin: CGPoint.zero, size: image.size)) let rect = CGRect(origin: point, size: image.size) let paragraphStyle = NSMutableParagraphStyle() paragraphStyle.alignment = .center let attrs = [NSAttributedStringKey.font: UIFont(name: "Helvetica Bold", size: 12)!,NSAttributedStringKey.foregroundColor : UIColor.white , NSAttributedStringKey.paragraphStyle: paragraphStyle] text.draw(with: rect, options: .usesLineFragmentOrigin, attributes: attrs, context: nil) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! }
(lldb) expr -l Swift -- import UIKit (lldb) expr -l Swift -- let $pin = unsafeBitCast(0x7df67c50, to: MKPinAnnotationView.self) (lldb) expr -l Swift -- print($pin.alpha)
(lldb) e let $pin = unsafeBitCast(0x7df67c50, MKPinAnnotationView.self) (lldb) po $pin
(lldb) expr -l Swift -- import UIKit (lldb) expr -l Swift -- let $view = unsafeBitCast(0x7fb75d8349c0, UIView.self)
(lldb) expr -l Swift -- import UIKit (lldb) expr -l Swift -- let $nav = unsafeBitCast(0x1030ff000, to: UINavigationController.self)
(lldb) p tabView.controlTint (NSControlTint) $R10 = defaultControlTint (lldb) p self (LearningStoryboard.NSTabViewController) $R11 = 0x00006080000e2280 { .....
(lldb) p unsafeBitCast(0x00006080000e2280, to: NSTabViewController.self).tabView.controlTint (NSControlTint) $R20 = graphiteControlTint (lldb) p $R11.tabView.controlTint (NSControlTint) $R21 = graphiteControlTint
(lldb) p unsafeBitCast(0x00006080000e2280, to: NSTabViewController.self).tabView.controlTint error: use of undeclared identifier (lldb) p $R11.tabView.controlTint error: use of undeclared identifier
expr -l Swift -- import MyTestProject expr -l Swift -- let $vc = unsafeBitCast(0x7fad22c066d0, ViewController.self) expr -l Swift -- print($vc.view)
expr unsafeBitCast(0x7df67c50, to: MKPinAnnotationView.self)
command regex po s/(0x[[:xdigit:]]+)/expression -l objc -O -- %1/ s/(.+)/expression -O -- %1/
(lldb) settings set interpreter.expand-regex-aliases true
protocol AddsMoreCommands: class { } extension AddsMoreCommands where Self: UIViewController { }
protocol AddsMoreCommands: class where Self: UIViewController { }
protocol AddsMoreCommands where Self: UIViewController { }
protocol AddsMoreCommands where Self : UIViewController { }
override func prepareForSegue(segue: UIStoryboardSegue!, sender: AnyObject!){ let navVC = segue.destinationViewController as UINavigationController let tableVC = navVC.viewControllers.first as YourTableViewControllerClass tableVC.yourTableViewArray = localArrayValue }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let navVC = segue.destination as? UINavigationController let tableVC = navVC?.viewControllers.first as! YourTableViewControllerClass tableVC.yourTableViewArray = localArrayValue }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == "yourSegueIdentifier" { if let navController = segue.destination as? UINavigationController { if let chidVC = navController.topViewController as? YourViewController { } } } }
if let controller = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "yourNavigationControllerID") as? UINavigationController, let yourViewController = controller.viewControllers.first as? YourViewController { yourViewController.yourVariableName = "value" self.window?.rootViewController = controller }
func functionToPassAsAction() { var controller: UINavigationController controller = self.storyboard?.instantiateViewControllerWithIdentifier("NavigationVCIdentifierFromStoryboard") as! UINavigationController controller.yourTableViewArray = localArrayValue self.presentViewController(controller, animated: true, completion: nil) }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let navigationContoller = segue.destination as! UINavigationController let receiverViewController = navigationContoller?.topViewController as ReceiverViewController receiverViewController.reveivedObject = sentObject }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let navVC = segue.destination as! UINavigationController let tableVC = navVC.viewControllers.first as! YourTableViewControllerClass tableVC.yourTableViewArray = localArrayValue }
error: cannot downcast from let conforms = T.self is MyProtocol ~~~~~~ ^ ~~~~~~~~~~
if let currentVC = myViewController as? MyCustomProtocol { }
protocol MyProtocol { } struct MyStruct <T> { let val: T } func myFunc<T: MyProtocol>(s: MyStruct<T>) -> T? { return s.val } func myFunc<T>(s: MyStruct<T>) -> T? { return nil } struct S1: MyProtocol { } struct S2 { } let m1 = MyStruct(val: S1()) let m2 = MyStruct(val: S2()) myFunc(m1) myFunc(m2)
let o: Any = S1() let m3 = MyStruct(val: o) myFunc(m3)
func myFunc<T>(s: MyStruct<T>) -> T? { switch s { case let sType as MyProtocol: default: ... } }
let alert = UIAlertController(title: "Error", message: message, preferredStyle: .Alert) let cancelAction = UIAlertAction(title: "OK", style: .Cancel, handler: nil) alert.addAction(cancelAction) presentViewController(alert, animated: true, completion: nil)
if objc_getClass("UIAlertController") != nil { println("UIAlertController can be instantiated") } else { println("UIAlertController can NOT be instantiated") }
if ([UIAlertController class]) { UIAlertController *alert= [UIAlertController alertControllerWithTitle:@"Enter Folder Name" message:@"Keep it short and sweet" preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction* ok = [UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * action){ UITextField *textField = alert.textFields[0]; NSLog(@"text was %@", textField.text); }]; UIAlertAction* cancel = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleDefault handler:^(UIAlertAction * action) { NSLog(@"cancel btn"); [alert dismissViewControllerAnimated:YES completion:nil]; }]; [alert addAction:ok]; [alert addAction:cancel]; [alert addTextFieldWithConfigurationHandler:^(UITextField *textField) { textField.placeholder = @"folder name"; textField.keyboardType = UIKeyboardTypeDefault; }]; [self presentViewController:alert animated:YES completion:nil]; } else { UIAlertView* dialog = [[UIAlertView alloc] initWithTitle:@"Enter Folder Name" message:@"Keep it short and sweet" delegate:self cancelButtonTitle:@"Cancel" otherButtonTitles:@"OK", nil]; dialog.alertViewStyle = UIAlertViewStylePlainTextInput; dialog.tag = 400; [dialog show]; }
var device : UIDevice = UIDevice.currentDevice()!; var systemVersion = device.systemVersion; var iosVerion : Float = systemVersion.bridgeToObjectiveC().floatValue; if(iosVerion < 8.0) { let alert = UIAlertView() alert.title = "Noop" alert.message = "Nothing to verify" alert.addButtonWithTitle("Click") alert.show() }else{ var alert : UIAlertController = UIAlertController(title: "Noop", message: "Nothing to verify", preferredStyle: UIAlertControllerStyle.Alert) alert.addAction(UIAlertAction(title: "Click", style:.Default, handler: nil)) self.presentViewController(alert, animated: true, completion: nil) }
@implementation UIView( AlertCompatibility ) +( void )showSimpleAlertWithTitle:( NSString * )title message:( NSString * )message cancelButtonTitle:( NSString * )cancelButtonTitle { if( [[UIDevice currentDevice] isSystemVersionLowerThan: @"8"] ) { UIAlertView *alert = [[UIAlertView alloc] initWithTitle: title message: message delegate: nil cancelButtonTitle: cancelButtonTitle otherButtonTitles: nil]; [alert show]; } else { UIAlertController *alert = [UIAlertController alertControllerWithTitle: title == nil ? @"": title message: message preferredStyle: UIAlertControllerStyleAlert]; UIAlertAction *defaultAction = [UIAlertAction actionWithTitle: cancelButtonTitle style: UIAlertActionStyleDefault handler: nil]; [alert addAction: defaultAction]; UIViewController *rootViewController = [UIApplication sharedApplication].keyWindow.rootViewController; [rootViewController presentViewController: alert animated: YES completion: nil]; } } @end @implementation UIDevice( SystemVersion ) -( BOOL )isSystemVersionLowerThan:( NSString * )versionToCompareWith { if( versionToCompareWith.length == 0 ) return NO; NSString *deviceSystemVersion = [self systemVersion]; NSArray *systemVersionComponents = [deviceSystemVersion componentsSeparatedByString: @"."]; uint16_t deviceMajor = 0; uint16_t deviceMinor = 0; uint16_t deviceBugfix = 0; NSUInteger nDeviceComponents = systemVersionComponents.count; if( nDeviceComponents > 0 ) deviceMajor = [( NSString * )systemVersionComponents[0] intValue]; if( nDeviceComponents > 1 ) deviceMinor = [( NSString * )systemVersionComponents[1] intValue]; if( nDeviceComponents > 2 ) deviceBugfix = [( NSString * )systemVersionComponents[2] intValue]; NSArray *versionToCompareWithComponents = [versionToCompareWith componentsSeparatedByString: @"."]; uint16_t versionToCompareWithMajor = 0; uint16_t versionToCompareWithMinor = 0; uint16_t versionToCompareWithBugfix = 0; NSUInteger nVersionToCompareWithComponents = versionToCompareWithComponents.count; if( nVersionToCompareWithComponents > 0 ) versionToCompareWithMajor = [( NSString * )versionToCompareWithComponents[0] intValue]; if( nVersionToCompareWithComponents > 1 ) versionToCompareWithMinor = [( NSString * )versionToCompareWithComponents[1] intValue]; if( nVersionToCompareWithComponents > 2 ) versionToCompareWithBugfix = [( NSString * )versionToCompareWithComponents[2] intValue]; return ( deviceMajor < versionToCompareWithMajor ) || (( deviceMajor == versionToCompareWithMajor ) && ( deviceMinor < versionToCompareWithMinor )) || (( deviceMajor == versionToCompareWithMajor ) && ( deviceMinor == versionToCompareWithMinor ) && ( deviceBugfix < versionToCompareWithBugfix )); } @end
[UIView showSimpleAlertWithTitle: @"Error" message: message cancelButtonTitle: @"OK"];
BOOL lowerThaniOS8 = NSClassFromString( @"UIAlertController" ) == nil;
if ([UIAlertController class]) { MyController * __weak mySelf = self; UIAlertController *alertController = [UIAlertController alertControllerWithTitle:alertTitle message:alertMessage preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:alertCancel style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) { [mySelf alertView:nil didDismissWithButtonIndex:0]; } ]; ...
if let alert = UIAlertController(title: "Alert", message: "Alert after 8.0", preferredStyle: .Alert) let cancelAction = UIAlertAction(title: "OK", style: .Cancel, handler: nil) alert.addAction(cancelAction) presentViewController(alert, animated: true, completion: nil) } else { UIAlertView(title: "Alert", message: "Alert below iOS V 8.0", delegate: nil, cancelButtonTitle: "OK").show() }
if objc_getClass("UIAlertController") != nil { let alert = UIAlertController(title: "Alert", message: "Alert after 8.0", preferredStyle: .Alert) let cancelAction = UIAlertAction(title: "OK", style: .Cancel, handler: nil) alert.addAction(cancelAction) presentViewController(alert, animated: true, completion: nil) } else { UIAlertView(title: "Alert", message: "Alert below iOS V 8.0", delegate: nil, cancelButtonTitle: "OK").show() }
func CozAlert(title: String, message: String, action: String, sender: UIViewController){ if respondsToSelector("UIAlertController"){ var alert = UIAlertController(title: title, message: message, preferredStyle: UIAlertControllerStyle.Alert) alert.addAction(UIAlertAction(title: action, style: UIAlertActionStyle.Default, handler:nil)) sender.presentViewController(alert, animated: true, completion: nil) } else { var alert = UIAlertView(title: title, message: message, delegate: sender, cancelButtonTitle:action) alert.show() } }
CozAlert("reportTitle", message: "reportText", action: "reportButton", sender: self)
if (IS_OS_8_OR_LATER) { UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:title message:msg preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) { }]; [alertVC addAction:cancelAction]; [[[[[UIApplication sharedApplication] windows] objectAtIndex:0] rootViewController] presentViewController:alertVC animated:YES completion:^{ }]; } else{ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:title message:msg delegate:self cancelButtonTitle:@"Ok" otherButtonTitles:nil, nil]; [alert show]; }
**UIAlertView** *alert=[[**UIAlertView** alloc]initWithTitle:@"FreeWare" message:@"Welcome to Common class" delegate:self cancelButtonTitle:@"Cancel" otherButtonTitles:@"Ok", nil]; **MyAlertView** *alert=[[**MyAlertView** alloc]initWithTitle:@"FreeWare" message:@"Welcome to Common class" delegate:self cancelButtonTitle:@"Cancel" otherButtonTitles:@"Ok", nil];
var postDict = Dictionary<String,AnyObject> postDict[pass]=123 postDict[name]="ali" postDict[surname]=nil
var postDict = Dictionary<String,AnyObject>() postDict["pass"]=123 postDict["name"]="ali" postDict["surname"]=NSNull() let jsonData = NSJSONSerialization.dataWithJSONObject(postDict, options: NSJSONWritingOptions.allZeros, error: nil)! let jsonString = NSString(data: jsonData, encoding: NSUTF8StringEncoding)!
var postDict = ["pass": 123, "name": "ali", "surname": Optional()]
class Person { let name: String weak var spouse: Person? init(name: String, spouse: Person?) { self.name = name self.spouse = spouse } }
let p1 = Person(name: "John", spouse: nil) let p2 = Person(name: "Doe", spouse: p1) p1.spouse = p2 var people = [p1.name: p1.spouse]
people.updateValue(nil, forKey: p1.name) people[p1.name]
var dict = [Int:Int?]() dict[0] = (Int?).none dict[0] = nil dict[0] = .none switch dict[0] { case .none: Swift.print("Value does not exist") case .some(let value): if let value = value { Swift.print("Value exists and is", value) } else { Swift.print("Value exists and is nil") } }
func application(app: UIApplication, openURL url: NSURL, options: [String : AnyObject]) -> Bool { print(" print(url) print(" print(app) print(options["UIApplicationOpenURLOptionsSourceApplicationKey"]) return FBSDKApplicationDelegate.sharedInstance().application(app, openURL: url, sourceApplication: options["UIApplicationOpenURLOptionsSourceApplicationKey"] as! String, annotation: nil) }
<key>LSApplicationQueriesSchemes</key> <array> <string>fbapi</string> <string>fb-messenger-api</string> <string>fbauth2</string> <string>fbshareextension</string> </array>
print("SDK version \(FBSDKSettings .sdkVersion())")
import FBSDKCoreKit . import FBSDKLoginKit func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { return FBSDKApplicationDelegate.sharedInstance().application(application, didFinishLaunchingWithOptions: launchOptions) } func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool { return FBSDKApplicationDelegate.sharedInstance().application(app, open: url, options: options) }
- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString*, id> *)options { return [[FBSDKApplicationDelegate sharedInstance] application:app openURL:url sourceApplication:options[UIApplicationOpenURLOptionsSourceApplicationKey] annotation:options[UIApplicationOpenURLOptionsAnnotationKey]];
@available(iOS 9.0, *) func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool { return SDKApplicationDelegate.shared.application(app, open: url, sourceApplication: options[UIApplicationOpenURLOptionsKey.sourceApplication] as? String, annotation: options[UIApplicationOpenURLOptionsKey.annotation] as Any) }
@objc func loginButtonClicked() { self.login = FBSDKLoginManager() self.login.logIn(withReadPermissions: ["public_profile"], from: self, handler: {(result, error) -> Void in if error != nil { print("Process error") } else if (result?.isCancelled)! { print("Cancelled") } else { print("Logged in") DispatchQueue.main.async(execute: { let viewController:UIViewController = self.storyboard?.instantiateViewController(withIdentifier: "UITabBarController") as! UITabBarController self.present(viewController, animated: true, completion: nil) }) } }) }
tableView.scrollToRowAtIndexPath(NSIndexPath(forRow: model.dataArray.count - 1, inSection: 0), atScrollPosition: .Bottom, animated: true)
tableView.setContentOffset(CGPointMake(0, tableView.contentSize.height - tableView.frame.size.height), animated: true)
let delay = 0.1 * Double(NSEC_PER_SEC) let time = dispatch_time(DISPATCH_TIME_NOW, Int64(delay)) dispatch_after(time, dispatch_get_main_queue(), { tableView.scrollToRowAtIndexPath(NSIndexPath(forRow: model.dataArray.count - 1, inSection: 0), atScrollPosition: .Bottom, animated: true) })
if array.count > 0 { let indexPath: NSIndexPath = NSIndexPath(forRow: array.count - 1, inSection: 0) self.tblView.scrollToRowAtIndexPath(indexPath, atScrollPosition: .Bottom, animated: true) let delay = 0.1 * Double(NSEC_PER_SEC) let time = dispatch_time(DISPATCH_TIME_NOW, Int64(delay)) dispatch_after(time, dispatch_get_main_queue(), { self.tblView.scrollToRowAtIndexPath(indexPath, atScrollPosition: .Bottom, animated: true) }) }
- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { NSString *text = [self findTextForIndexPath:indexPath]; UIFont *font = [UIFont fontWithName:@"HelveticaNeue" size:13]; CGRect estimatedHeight = [text boundingRectWithSize:CGSizeMake(215, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName: font} context:nil]; return TOP_PADDING + CGRectGetHeight(estimatedHeight) + BOTTOM_PADDING; }
- (void)scrollToLastestSeenMessageAnimated:(BOOL)animated { NSInteger count = [self tableView:self.tableView numberOfRowsInSection:0]; if (count > 0) { NSInteger lastPos = MAX(0, count-1); [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForItem:lastPos inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:animated]; } }
- (CGFloat) tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath
- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { return UITableViewAutomaticDimension;
- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { MyMessageType messageType = [self messageTypeForRowAtIndexPath:indexPath]; switch (messageType) { case MyMessageTypeText: return 45; break; case MyMessageTypeMaybeWithSomeMediaOrSomethingBiggerThanJustText: return 96; break; default: break; } }
-(void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; [self.tableView reloadData]; }
- (void)scrollToBottomForPreiOS9 { CGFloat originalY, scrolledY; do { [self.tableView layoutSubviews]; originalY = self.tableView.contentOffset.y; [self scrollToBottom]; scrolledY = self.tableView.contentOffset.y; } while (scrolledY > originalY); }
let lastSectionIndex = self.tableView.numberOfSections - 1 let lastRowIndex = self.tableView.numberOfRowsInSection(lastSectionIndex) - 1 let pathToLastRow = NSIndexPath(forRow: lastRowIndex, inSection: lastSectionIndex) self.tableView.scrollToRowAtIndexPath(pathToLastRow, atScrollPosition: UITableViewScrollPosition.None, animated: true)
var rows:NSInteger=self.tableName.numberOfRowsInSection(0) if(rows > 0) { let indexPath = NSIndexPath(forRow: rows-1, inSection: 0) tableName.scrollToRowAtIndexPath(indexPath , atScrollPosition: UITableViewScrollPosition.Bottom, animated: true) } }
import UIKit import Foundation class FriendsViewController : UIViewController{ @IBOutlet weak var profilPicture: UIImageView! override func viewDidLoad() { super.viewDidLoad() profilPicture = UIImageView(frame: CGRectMake(0, 0, 100, 100)) } }
import UIKit class ViewController: UIViewController { @IBOutlet weak var image: UIImageView! override func viewDidLoad() { super.viewDidLoad() image.layer.borderWidth = 1 image.layer.masksToBounds = false image.layer.borderColor = UIColor.black.cgColor image.layer.cornerRadius = image.frame.height/2 image.clipsToBounds = true }
import UIKit extension UIImageView { func setRounded() { let radius = CGRectGetWidth(self.frame) / 2 self.layer.cornerRadius = radius self.layer.masksToBounds = true } }
import UIKit extension UIImageView { func setRounded() { self.layer.cornerRadius = (self.frame.width / 2) self.layer.masksToBounds = true } }
imageView.layer.cornerRadius = imageView.frame.height / 2 imageView.clipsToBounds = true
profileImage2.layer.cornerRadius = profileImage2.frame.size.width/2 profileImage2.clipsToBounds = true
import UIKit extension UIImageView { func makeRounded() { let radius = self.frame.width/2.0 self.layer.cornerRadius = radius self.layer.masksToBounds = true } }
var imageCircle = UIImageView(frame: CGRectMake(0, 0, 100, 100))
imageCircle.layer.cornerRadius = imageCircle.frame.size.height/2 imageCircle.layer.borderWidth = 1 imageCircle.layer.borderColor = UIColor.blueColor().CGColor imageCircle.clipsToBounds = true self.view.addSubview(imageCircle)
class NameTableViewCell:UITableViewCell,UITextFieldDelegate { ... override func awakeFromNib() { self.layoutIfNeeded() profileImageView.layoutIfNeeded() profileImageView.isUserInteractionEnabled = true let square = profileImageView.frame.size.width < profileImageView.frame.height ? CGSize(width: profileImageView.frame.size.width, height: profileImageView.frame.size.width) : CGSize(width: profileImageView.frame.size.height, height: profileImageView.frame.size.height) profileImageView.addGestureRecognizer(tapGesture) profileImageView.layer.cornerRadius = square.width/2 profileImageView.clipsToBounds = true; }
let radius = yourImageView.frame.width / 2 yourImageView.layer.cornerRadius = radius yourImageView.layer.masksToBounds = true
class RoundedImageView: UIImageView { override init(frame: CGRect) { super.init(frame: frame) clipsToBounds = true } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) clipsToBounds = true } override func layoutSubviews() { super.layoutSubviews() assert(bounds.height == bounds.width, "The aspect ratio isn layer.cornerRadius = bounds.height / 2 } }
let url_1 = NSURL.fileURLWithPath(outputFilePath_1) let asset_1 = AVAsset.assetWithURL(url_1) as? AVAsset let playerItem_1 = AVPlayerItem(asset: asset_1) let player_1 = AVPlayer(playerItem: self.playerItem_1) let playerLayer_1 = AVPlayerLayer(player: self.player_1) playerLayer_1!.frame = self.view.frame self.view.layer.addSublayer(self.playerLayer_1) player_1!.play()
var player: AVPlayer! ... NotificationCenter.default.addObserver(forName: .AVPlayerItemDidPlayToEndTime, object: self.player.currentItem, queue: .main) { [weak self] _ in self?.player?.seek(to: CMTime.zero) self?.player?.play() }
NotificationCenter.default.addObserver(forName: .AVPlayerItemDidPlayToEndTime, object: self.player.currentItem, queue: .main) { [weak self] _ in self?.player?.seek(to: kCMTimeZero) self?.player?.play() }
var player: AVPlayer! ... NSNotificationCenter.defaultCenter().addObserver(self, selector: "playerItemDidReachEnd:", name: AVPlayerItemDidPlayToEndTimeNotification, object: self.player.currentItem) ... func playerItemDidReachEnd(notification: NSNotification) { self.player.seekToTime(kCMTimeZero) self.player.play() }
func loopVideo(videoPlayer: AVPlayer) { NSNotificationCenter.defaultCenter().addObserverForName(AVPlayerItemDidPlayToEndTimeNotification, object: nil, queue: nil) { notification in videoPlayer.seekToTime(kCMTimeZero) videoPlayer.play() } }
player_1?.actionAtItemEnd = .None NSNotificationCenter.defaultCenter().addObserver(self, selector: "restartVideoFromBeginning", name: AVPlayerItemDidPlayToEndTimeNotification, object: player_1?.currentItem) func restartVideoFromBeginning() { let seconds : Int64 = 0 let preferredTimeScale : Int32 = 1 let seekTime : CMTime = CMTimeMake(seconds, preferredTimeScale) player_1!.seekToTime(seekTime) player_1!.play() }
func loopVideo(videoPlayer: AVPlayer) { NotificationCenter.default.addObserver(forName: NSNotification.Name.AVPlayerItemDidPlayToEndTime, object: nil, queue: nil) { notification in videoPlayer.seek(to: CMTime.zero) videoPlayer.play() } }
let asset = AVAsset(url: videoURL) let item = AVPlayerItem(asset: asset) let player = AVQueuePlayer(playerItem: item) videoLooper = AVPlayerLooper(player: player, templateItem: item)
var player : AVQueuePlayer! internal func selectVideoWithLoop(url : URL) { let asset = AVAsset(url: url) player.pause() let playerItem1 = AVPlayerItem(asset: asset) let playerItem2 = AVPlayerItem(asset: asset) player.removeAllItems() player.replaceCurrentItem(with: playerItem1) player.insert(playerItem2, after: playerItem1) player.actionAtItemEnd = AVPlayerActionAtItemEnd.advance player.play() let selector = let name = NSNotification.Name.AVPlayerItemDidPlayToEndTime NotificationCenter.default.removeObserver(self, name: name, object: nil) NotificationCenter.default.addObserver(self, selector: selector, name: name, object: nil) } func playerItemDidReachEnd(notification: Notification) { let item = player.currentItem! player.remove(item) item.seek(to: kCMTimeZero) player.insert(item, after: nil) }
NotificationCenter.default.addObserver(self, selector: func videoDidReachEnd() { let duration : Int64 = 0 (can be Int32 also) let preferredTimeScale : Int32 = 1 let seekTime : CMTime = CMTimeMake(duration, preferredTimeScale) player!.seek(to: seekTime) player!.play() }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let aSet = NSCharacterSet(charactersInString:"0123456789").invertedSet let compSepByCharInSet = string.componentsSeparatedByCharactersInSet(aSet) let numberFiltered = compSepByCharInSet.joinWithSeparator("") return string == numberFiltered }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let aSet = NSCharacterSet(charactersIn:"0123456789").inverted let compSepByCharInSet = string.components(separatedBy: aSet) let numberFiltered = compSepByCharInSet.joined(separator: "") return string == numberFiltered }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let allowedCharacters = CharacterSet.decimalDigits let characterSet = CharacterSet(charactersIn: string) return allowedCharacters.isSuperset(of: characterSet) }
func textField(textField: UITextField,shouldChangeCharactersInRange range: NSRange,replacementString string: String) -> Bool { let newCharacters = NSCharacterSet(charactersInString: string) let boolIsNumber = NSCharacterSet.decimalDigitCharacterSet().isSupersetOfSet(newCharacters) if boolIsNumber == true { return true } else { if string == "." { let countdots = textField.text!.componentsSeparatedByString(".").count - 1 if countdots == 0 { return true } else { if countdots > 0 && string == "." { return false } else { return true } } } else { return false } } }
class YourViewController: UIViewController, UITextFieldDelegate
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { if textField == mobileNoTF { let allowedCharacters = CharacterSet(charactersIn:"+0123456789 ") let characterSet = CharacterSet(charactersIn: string) return allowedCharacters.isSuperset(of: characterSet) } return true }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let inverseSet = NSCharacterSet(charactersIn:"0123456789").inverted let components = string.components(separatedBy: inverseSet) let filtered = components.joined(separator: "") if filtered == string { return true } else { if string == "." { let countdots = textField.text!.components(separatedBy:".").count - 1 if countdots == 0 { return true }else{ if countdots > 0 && string == "." { return false } else { return true } } }else{ return false } } }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let digits = NSCharacterSet.decimalDigitCharacterSet() for c in string { if !digits.characterIsMember(c) { return false } } return true }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let s = NSString(string: textField.text ?? "").replacingCharacters(in: range, with: string) guard !s.isEmpty else { return true } let numberFormatter = NumberFormatter() numberFormatter.numberStyle = .none return numberFormatter.number(from: s)?.intValue != nil }
@IBAction func valueChanged(_ sender: UITextField) { if let last = sender.text?.last { let zero: Character = "0" let num: Int = Int(UnicodeScalar(String(last))!.value - UnicodeScalar(String(zero))!.value) if (num < 0 || num > 9) { sender.text?.removeLast() } } }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let newCharacters = NSCharacterSet(charactersInString: string) return NSCharacterSet.decimalDigitCharacterSet().isSupersetOfSet(newCharacters) }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let decimalCharacter = NSNumberFormatter().decimalSeparator let characterSet = NSMutableCharacterSet.decimalDigitCharacterSet() characterSet.addCharactersInString(decimalCharacter) return replacementString.rangeOfCharacterFromSet(characterSet.invertedSet) == nil }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { if let numRange = string.rangeOfCharacterFromSet(NSCharacterSet.letterCharacterSet()) { return false } else { return true } }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let numberOnly = NSCharacterSet.init(charactersIn: "0123456789") let stringFromTextField = NSCharacterSet.init(charactersIn: string) let strValid = numberOnly.isSuperset(of: stringFromTextField as CharacterSet) return strValid }
class MyViewController: UIViewController, UITextFieldDelegate
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let isNumber = CharacterSet.decimalDigits.isSuperset(of: CharacterSet(charactersIn: string)) let withDecimal = ( string == NumberFormatter().decimalSeparator && textField.text?.contains(string) == false ) return isNumber || withDecimal }
@IBOutlet weak var textFieldKeyboardType: UITextField!{ didSet{ textFieldKeyboardType.keyboardType = UIKeyboardType.NumberPad } } var keyboardType: UIKeyboardType { get{ return textFieldKeyboardType.keyboardType } set{ if newValue != UIKeyboardType.NumberPad{ self.keyboardType = UIKeyboardType.NumberPad } } }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { if string.isEmpty {return true} let decimalSeparator = NSNumberFormatter().decimalSeparator ?? "." let validChars = NSMutableCharacterSet(charactersInString: decimalSeparator) validChars.formUnionWithCharacterSet(NSCharacterSet.decimalDigitCharacterSet()) if validChars.isSupersetOfSet(NSCharacterSet(charactersInString: string)){ switch string.componentsSeparatedByString(decimalSeparator).count-1 { case 0: return true case 1: if let existingText = textField.text{ return existingText.componentsSeparatedByString(decimalSeparator).count <= 1 } else {return true} default: return false } } return false }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let isNumber = NSCharacterSet.decimalDigitCharacterSet().isSupersetOfSet(NSCharacterSet(charactersInString: string)) return isNumber || (string == NSNumberFormatter().decimalSeparator && textField.text?.containsString(string) == false) }
func textField(_ shouldChangeCharactersIntextField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let inverseSet = NSCharacterSet(charactersIn:"0123456789").inverted let components = string.components(separatedBy: inverseSet) let filtered = components.joined(separator: "") return string == filtered }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let inverseSet = CharacterSet(charactersIn:"0123456789").inverted let components = string.components(separatedBy: inverseSet) let filtered = components.joined(separator: "") if filtered == string { return true } else { if string == "." || string == "," { let countDots = textField.text!.components(separatedBy:".").count - 1 let countCommas = textField.text!.components(separatedBy:",").count - 1 if countDots == 0 && countCommas == 0 { return true } else { return false } } else { return false } } }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { let textString = (textField.text! as NSString).replacingCharacters(in: range, with: string) if textField == self.phoneTextField && string.characters.count > 0{ let numberOnly = NSCharacterSet.decimalDigits let strValid = numberOnly.contains(UnicodeScalar.init(string)!) return strValid && textString.characters.count <= 10 } return true }
class ViewController: UIViewController, UITextFieldDelegate {
override func viewDidLoad() { super.viewDidLoad() firstName.delegate = self } func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { if textField == firstName { let allowedCharacters = "1234567890" let allowedCharacterSet = CharacterSet(charactersIn: allowedCharacters) let typedCharacterSet = CharacterSet(charactersIn: string) let alphabet = allowedCharacterSet.isSuperset(of: typedCharacterSet) return alphabet } }
Swift 2.0 func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let inverseSet = NSCharacterSet(charactersInString:"0123456789").invertedSet let components = string.componentsSeparatedByCharactersInSet(inverseSet) let filtered = components.joinWithSeparator("") return string == filtered }
func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let existingTextHasDecimal = textField.text?.rangeOfString(".") let replacementTextHasDecimal = string.rangeOfString(".") let replacementTextAllCharacters = NSCharacterSet(charactersInString: string) let replacementTextOnlyDigits = NSCharacterSet.decimalDigitCharacterSet().isSupersetOfSet(replacementTextAllCharacters) if replacementTextHasDecimal != nil && existingTextHasDecimal != nil { return false }else{ if replacementTextOnlyDigits == true { return true }else if replacementTextHasDecimal != nil{ return true }else{ return false } } }
func isValidNumber(str:String) -> Bool{ if str.isEmpty { return false } let newChar = NSCharacterSet(charactersInString: str) let boolValid = NSCharacterSet.decimalDigitCharacterSet().isSupersetOfSet(newChar) if boolValid{ return true }else{ let lst = str.componentsSeparatedByString(".") let newStr = lst.joinWithSeparator("") let currentChar = NSCharacterSet(charactersInString: newStr) if lst.count == 2 && !lst.contains("") && NSCharacterSet.decimalDigitCharacterSet().isSupersetOfSet(currentChar){ return true } return false } }
extension String { var isNumber : Bool { get{ return !self.isEmpty && self.stringWithoutWhitespaces.rangeOfCharacter(from: CharacterSet.decimalDigits.inverted) == nil } } var stringWithoutWhitespaces: String { return self.replacingOccurrences(of: " ", with: "") } } func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -> Bool { let isValid = string.stringWithoutWhitespaces.isNumber return valid }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let currentString = textField.text as NSString? else { return false } let newString = currentString.replacingCharacters(in: range, with: string) return Double(newString) != nil }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { guard let text = textField.text else { return true } let replaced = (text as NSString).replacingCharacters(in: range, with: string) let decimalSeparator = NSLocale.current.decimalSeparator ?? "" if replaced == "" || replaced == "-" || replaced == "-0" { textField.text = "0" return false } if replaced != "0" + decimalSeparator && replaced.hasPrefix("0") && text.underestimatedCount == 1 { textField.text = replaced.substring(from: replaced.index(after: replaced.startIndex)) return false } if text.hasPrefix("-") && text.substring(from: text.index(after: text.startIndex)) == replaced { return false } if replaced.hasPrefix(decimalSeparator) || replaced.hasPrefix("-" + decimalSeparator) { return false } let testReplaced = replaced.hasPrefix("-") ? replaced.substring(from: replaced.index(after: replaced.startIndex)) : replaced if testReplaced.count >= 2 && testReplaced.hasPrefix("0") && !testReplaced.hasPrefix("0" + decimalSeparator) { return false } let allowDecimal = self.allowFloat ? (decimalSeparator == "." ? "\\.?" : decimalSeparator + "?") : "" let allowSign = self.allowSigned ? "-?" : "" let pattern = "\(allowSign)[0-9]+\(allowDecimal)([0-9]+)?" do { let regexRange = (replaced as NSString).range(of: replaced) let regex = try NSRegularExpression(pattern: pattern, options: []) let matches = regex.matches(in: replaced, options: [], range: regexRange) return matches.count == 1 && matches.first!.range == regexRange } catch {} return false }
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool { if textField==yourTextFieldOutlet { if(CharacterSet.decimalDigits.isSuperset(of: CharacterSet(charactersIn: yourTextFieldOutlet.text!))){ } else{ showAlert(title: "Error",message: "Enter Number only",type: "failure") } } return true }
func CheckAddress(string:String) -> Bool { let numberOnly = NSCharacterSet.init(charactersIn: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-@,& let stringFromTextField = NSCharacterSet.init(charactersIn: string) return numberOnly.isSuperset(of: stringFromTextField as CharacterSet) } print("\(CheckAddress(string: "123"))") print("\(CheckAddress(string: "asdf-"))") print("\(CheckAddress(string: "asd123$"))")
guard CharacterSet(charactersIn: "123456789").isSuperset(of: CharacterSet(charactersIn: string)) else { return false } return true
searchController.dismissViewControllerAnimated() searchController.active = false
searchController.active = false searchController.isActive = false
- (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar{ dispatch_async(dispatch_get_main_queue(), ^{ [self.searchController setActive:NO]; self.navigationController.navigationBar.topItem.title = @"MYTITLE".uppercaseString; self.navigationItem.titleView = nil; }); }
let urlwithPercentEscapes = myurlstring.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)
let urlwithPercentEscapes = myurlstring.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)
let urlwithPercentEscapes = myurlstring.stringByAddingPercentEscapesUsingEncoding(NSUTF8StringEncoding)
let urlwithPercentEscapes = myurlstring.stringByAddingPercentEncodingWithAllowedCharacters( NSCharacterSet.URLQueryAllowedCharacterSet())
let urlwithPercentEscapes = myurlstring.addingPercentEncoding( withAllowedCharacters: .urlQueryAllowed)
let myFileString = "My File.txt" if let urlwithPercentEscapes = myFileString.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) { print(urlwithPercentEscapes) }
let myUrlString = "http: let urlSet = CharacterSet.urlFragmentAllowed .union(.urlHostAllowed) .union(.urlPasswordAllowed) .union(.urlQueryAllowed) .union(.urlUserAllowed)
extension CharacterSet { static let urlAllowed = CharacterSet.urlFragmentAllowed .union(.urlHostAllowed) .union(.urlPasswordAllowed) .union(.urlQueryAllowed) .union(.urlUserAllowed) }
if let urlwithPercentEscapes = myUrlString.addingPercentEncoding(withAllowedCharacters: .urlAllowed) { print(urlwithPercentEscapes) }
func createURLWithComponents() -> URL? { var urlComponents = URLComponents() urlComponents.scheme = "http" urlComponents.host = "www.mapquestapi.com" urlComponents.path = "/geocoding/v1/batch" let key = URLQueryItem(name: "key", value: "YOUR_KEY_HERE") let callback = URLQueryItem(name: "callback", value: "renderBatch") let locationA = URLQueryItem(name: "location", value: "Pottsville,PA") let locationB = URLQueryItem(name: "location", value: "Red Lion") let locationC = URLQueryItem(name: "location", value: "19036") let locationD = URLQueryItem(name: "location", value: "1090 N Charlotte St, Lancaster, PA") urlComponents.queryItems = [key, callback, locationA, locationB, locationC, locationD] return urlComponents.url }
guard let url = createURLWithComponents() else { print("invalid URL") return nil } print(url)
let query = "param1=value1&param2=" + valueToEncode.addingPercentEncoding(withAllowedCharacters: .alphanumeric)
extension String { func encodeUTF8() -> String? { if let _ = NSURL(string: self) { return self } let optionalLastComponent = self.characters.split { $0 == "/" }.last if let lastComponent = optionalLastComponent { let lastComponentAsString = lastComponent.map { String($0) }.reduce("", combine: +) if let rangeOfLastComponent = self.rangeOfString(lastComponentAsString) { let stringWithoutLastComponent = self.substringToIndex(rangeOfLastComponent.startIndex) if let lastComponentEncoded = lastComponentAsString.stringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet.alphanumericCharacterSet()) { let encodedString = stringWithoutLastComponent + lastComponentEncoded return encodedString } } } return nil; } }
let encodedData = myUrlString.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlHostAllowed)
if ([segue.identifier isEqualToString:@"Load View"]) { }
override func prepareForSegue(segue: UIStoryboardSegue!, sender: AnyObject!) { if (segue.identifier == "Load View") { } }
override func prepareForSegue(segue: UIStoryboardSegue?, sender: AnyObject?) { if segue!.identifier == "Details" { let viewController:ViewController = segue!.destinationViewController as ViewController let indexPath = self.tableView.indexPathForSelectedRow() viewController.pinCode = self.exams[indexPath.row] } }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == "MySegueId" { if let nextViewController = segue.destination as? NextViewController { nextViewController.valueOfxyz = "XYZ" nextViewController.valueOf123 = 123 } } }
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) { if (segue.identifier == "ShowDeal") { if let viewController: DealLandingViewController = segue.destinationViewController as? DealLandingViewController { viewController.dealEntry = deal } } }
self.performSegue(withIdentifier: "uiView", sender: self)
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if segue.identifier == "uiView"{ let destView = segue.destination as! WebViewController let indexpath = self.newsTableView.indexPathForSelectedRow let indexurl = tableDatalist[(indexpath?.row)!].link destView.UrlRec = indexurl } }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { let something = segue.destination as! someViewController something.aVariable = anotherVariable }
override func prepare(for segue: NSStoryboardSegue, sender: Any?) { if let myViewController = segue.destinationController as? MyViewController { } }
override func prepareForSegue(segue: UIStoryboardSegue?, sender: AnyObject?) { if(segue!.identifier){ var name = segue!.identifier; if (name.compare("Load View") == 0){ } } }
task = NSTask() task.launchPath = "/SomeWrongPath" task.launch()
do { try ObjC.catchException { } } catch { print("An error ocurred: \(error)") }
@interface ObjC : NSObject + (BOOL)catchException:(void(^)())tryBlock error:(__autoreleasing NSError **)error; @end
@implementation ObjC + (BOOL)catchException:(void(^)())tryBlock error:(__autoreleasing NSError **)error { @try { tryBlock(); return YES; } @catch (NSException *exception) { *error = [[NSError alloc] initWithDomain:exception.name code:0 userInfo:exception.userInfo]; return NO; } } @end
NSError *tryCatch(void(^tryBlock)(), NSError *(^convertNSException)(NSException *)) { NSError *error = nil; @try { tryBlock(); } @catch (NSException *exception) { error = convertNSException(exception); } @finally { return error; } }
if let error = tryCatch(task.launch, myConvertFunction) { print("An exception happened!", error.localizedDescription) }
import Foundation import SwiftTryCatch class SafeArchiver { class func unarchiveObjectWithFile(filename: String) -> AnyObject? { var data : AnyObject? = nil if NSFileManager.defaultManager().fileExistsAtPath(filename) { SwiftTryCatch.tryBlock({ data = NSKeyedUnarchiver.unarchiveObjectWithFile(filename) }, catchBlock: { (error) in Logger.logException("SafeArchiver.unarchiveObjectWithFile") }, finallyBlock: { }) } return data } class func archiveRootObject(data: AnyObject, toFile : String) -> Bool { var result: Bool = false SwiftTryCatch.tryBlock({ result = NSKeyedArchiver.archiveRootObject(data, toFile: toFile) }, catchBlock: { (error) in Logger.logException("SafeArchiver.archiveRootObject") }, finallyBlock: { }) return result } }
var error: NSError = NSError() var results = context.executeFetchRequest(request, error: error) if(error != nil) { println("Error executing request for entity \(entity)") }
var error: NSError? var results = context.executeFetchRequest(request, error: &error) if error != nil { println("Error executing request for entity \(entity)") }
var maybeError: NSError? if let results = context.executeFetchRequest(request, error: &maybeError) { } else if let error = maybeError { }
[ { "name": "Banana", "points": 200, "description": "A banana grown in Ecuador." }, { "name": "Orange" } ]
struct GroceryProduct: Codable { var name: String var points: Int var description: String? }
let decoder = JSONDecoder() let products = try decoder.decode([GroceryProduct].self, from: json)
struct FailableDecodable<Base : Decodable> : Decodable { let base: Base? init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() self.base = try? container.decode(Base.self) } }
import Foundation let json = """ [ { "name": "Banana", "points": 200, "description": "A banana grown in Ecuador." }, { "name": "Orange" } ] """.data(using: .utf8)! struct GroceryProduct : Codable { var name: String var points: Int var description: String? } let products = try JSONDecoder() .decode([FailableDecodable<GroceryProduct>].self, from: json) .compactMap { $0.base } print(products)
struct FailableCodableArray<Element : Codable> : Codable { var elements: [Element] init(from decoder: Decoder) throws { var container = try decoder.unkeyedContainer() var elements = [Element]() if let count = container.count { elements.reserveCapacity(count) } while !container.isAtEnd { if let element = try container .decode(FailableDecodable<Element>.self).base { elements.append(element) } } self.elements = elements } func encode(to encoder: Encoder) throws { var container = encoder.singleValueContainer() try container.encode(elements) } }
let products = try JSONDecoder() .decode(FailableCodableArray<GroceryProduct>.self, from: json) .elements print(products)
struct GroceryProduct: Codable { var name: String var points : Int? var description: String? }
struct GroceryProduct: Codable { var name: String var points : Int var description: String init(from decoder: Decoder) throws { let values = try decoder.container(keyedBy: CodingKeys.self) name = try values.decode(String.self, forKey: .name) points = try values.decodeIfPresent(Int.self, forKey: .points) ?? 0 description = try values.decodeIfPresent(String.self, forKey: .description) ?? "" } }
import Foundation let json = """ [ { "name": "Banana", "points": 200, "description": "A banana grown in Ecuador." }, { "name": "Orange" } ] """.data(using: .utf8)! private struct DummyCodable: Codable {} struct Groceries: Codable { var groceries: [GroceryProduct] init(from decoder: Decoder) throws { var groceries = [GroceryProduct]() var container = try decoder.unkeyedContainer() while !container.isAtEnd { if let route = try? container.decode(GroceryProduct.self) { groceries.append(route) } else { _ = try? container.decode(DummyCodable.self) } } self.groceries = groceries } } struct GroceryProduct: Codable { var name: String var points: Int var description: String? } let products = try JSONDecoder().decode(Groceries.self, from: json) print(products)
fileprivate struct DummyCodable: Codable {} extension UnkeyedDecodingContainer { public mutating func decodeArray<T>(_ type: T.Type) throws -> [T] where T : Decodable { var array = [T]() while !self.isAtEnd { do { let item = try self.decode(T.self) array.append(item) } catch let error { print("error: \(error)") _ = try self.decode(DummyCodable.self) } } return array } } extension KeyedDecodingContainerProtocol { public func decodeArray<T>(_ type: T.Type, forKey key: Self.Key) throws -> [T] where T : Decodable { var unkeyedContainer = try self.nestedUnkeyedContainer(forKey: key) return try unkeyedContainer.decodeArray(type) } }
init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) self.items = try container.decodeArray(ItemType.self, forKey: . items) }
let json = """ [ { "name": "Banana", "points": 200, "description": "A banana grown in Ecuador." }, { "name": "Orange" } ] """.data(using: .utf8)! struct Groceries: Codable { var groceries: [GroceryProduct] init(from decoder: Decoder) throws { var container = try decoder.unkeyedContainer() groceries = try container.decodeArray(GroceryProduct.self) } } struct GroceryProduct: Codable { var name: String var points: Int var description: String? } let products = try JSONDecoder().decode(Groceries.self, from: json) print(products)
enum Throwable<T: Decodable>: Decodable { case success(T) case failure(Error) init(from decoder: Decoder) throws { do { let decoded = try T(from: decoder) self = .success(decoded) } catch let error { self = .failure(error) } } }
let decoder = JSONDecoder() let throwables = try decoder.decode([Throwable<GroceryProduct>].self, from: json) let products = throwables.compactMap { $0.value }
extension Throwable { var value: T? { switch self { case .failure(_): return nil case .success(let value): return value } } }
struct GroceryProduct: Codable { let name: String let points: Int? let description: String private enum CodingKeys: String, CodingKey { case name, points, description } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) name = try container.decode(String.self, forKey: .name) points = try? container.decode(Int.self, forKey: .points) description = (try? container.decode(String.self, forKey: .description)) ?? "No description" } } let dict = [["name": "Banana", "points": 100], ["name": "Nut", "description": "Woof"]] if let data = try? JSONSerialization.data(withJSONObject: dict, options: []) { let decoder = JSONDecoder() let result = try? decoder.decode([GroceryProduct].self, from: data) print("rawResult: \(result)") let clearedResult = result?.filter { $0.points != nil } print("clearedResult: \(clearedResult)") }
extension KeyedDecodingContainer { private struct EmptyDecodable: Decodable {} func safelyDecodeArray<T: Decodable>(of type: T.Type, forKey key: KeyedDecodingContainer.Key) -> [T] { guard var container = try? nestedUnkeyedContainer(forKey: key) else { return [] } var elements = [T]() elements.reserveCapacity(container.count ?? 0) while !container.isAtEnd { /* Note: When decoding an element fails, the decoder does not move on the next element upon failure, so that we can retry the same element again by other means. However, this behavior potentially keeps `while !container.isAtEnd` looping forever, and Apple does not offer a `.skipFailable` decoder option yet. As a result, `catch` needs to manually skip the failed element by decoding it into an `EmptyDecodable` that always succeed. See the Swift ticket https: */ do { elements.append(try container.decode(T.self)) } catch { if let decodingError = error as? DecodingError { Logger.error("\( } else { Logger.error("\( } _ = try? container.decode(EmptyDecodable.self) } } return elements } }
struct FailableCodableArray<Element : Codable> : Codable { var elements: [Element] init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() let elements = try container.decode([FailableDecodable<Element>].self) self.elements = elements.compactMap { $0.wrapped } } func encode(to encoder: Encoder) throws { var container = encoder.singleValueContainer() try container.encode(elements) } }
public struct OfferResponse { public private(set) var offers: [Offer] public init(data: Data) throws { let json = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: [Any]] guard let offersDataArray = json?["Offers"] else { throw NSError(domain: "unexpected JSON structure for \(type(of: self))", code: 36, userInfo: nil) } guard let firstOfferData = offersDataArray.first else { throw NSError(domain: "emptyArray in JSON structure for \(type(of: self))", code: 36, userInfo: nil) } let decoder = JSONDecoder() offers = try decoder.decode([Offer].self, from: JSONSerialization.data(withJSONObject: firstOfferData, options: .prettyPrinted)) }
offers = [] for offerData in offersDataArray { if let offer = try? decoder.decode(Offer.self, from: JSONSerialization.data(withJSONObject: offerData, options: .prettyPrinted)) { offers.append(offer) }
enum LifeError: ErrorType { case BeBorn case LostJob(job: String) case GetCaughtByWife(wife: String) ... }
do { try haveAffairWith(otherPerson) } catch LifeError.GetCaughtByWife(let wife) { ... }
println("\(LifeError.GetCaughtByWife("Name") as NSError)")
enum LifeError: CustomNSError { case beBorn case lostJob(job: String) case getCaughtByWife(wife: String) static var errorDomain: String { return "LifeError" } var errorCode: Int { switch self { case .beBorn: return 0 case .lostJob(_): return 1 case .getCaughtByWife(_): return 2 } } var errorUserInfo: [String : AnyObject] { switch self { case .beBorn: return [:] case .lostJob(let job): return ["Job": job] case .getCaughtByWife(let wife): return ["Wife": wife] } } }
do { try haveAffairWith(otherPerson) } catch LifeError.GetCaughtByWife(let wife) { throw NSError(domain:LifeErrorDomain code:-1 userInfo: [NSLocalizedDescriptionKey:"You cheated on \(wife)") }
protocol CustomErrorConvertible { func userInfo() -> Dictionary<String,String>? func errorDomain() -> String func errorCode() -> Int }
extension CustomErrorConvertible { func error() -> NSError { return NSError(domain: self.errorDomain(), code: self.errorCode(), userInfo: self.userInfo()) } }
enum LifeError: ErrorType, CustomErrorConvertible { case BeBorn case LostJob(job: String) case GetCaughtByPolice(police: String) func errorDomain() -> String { return "LifeErrorDomain" } func userInfo() -> Dictionary<String,String>? { var userInfo:Dictionary<String,String>? if let errorString = errorDescription() { userInfo = [NSLocalizedDescriptionKey: errorString] } return userInfo } func errorDescription() -> String? { var errorString:String? switch self { case .LostJob(let job): errorString = "fired as " + job case .GetCaughtByPolice(let cops): errorString = "arrested by " + cops default: break; } return errorString } func errorCode() -> Int { switch self { case .BeBorn: return 1 case .LostJob(_): return -9000 case .GetCaughtByPolice(_): return 50 } } }
func lifeErrorThrow() throws { throw LifeError.LostJob(job: "L33tHax0r") } do { try lifeErrorThrow() } catch LifeError.BeBorn { print("vala morgulis") } catch let myerr as LifeError { let error = myerr.error() print(error) }
enum AppError: Int, ErrorType { case UserNotLoggedIn case InternetUnavailable }
extension AppError: CustomStringConvertible, CustomErrorConvertible protocol CustomErrorConvertible { var error: NSError { get } }
Description: switch self { case .UserNotLoggedIn: return NSLocalizedString("ErrorUserNotLoggedIn", comment: "User not logged into cloud account.") case .InternetUnavailable: return NSLocalizedString("ErrorInternetUnavailable", comment: "Internet connection not available.") } Error: switch self { case .UserNotLoggedIn: errorCode = UserNotLoggedIn.rawValue; errorDescription = UserNotLoggedIn.description case .InternetUnavailable: errorCode = InternetUnavailable.rawValue; errorDescription = InternetUnavailable.description }
return NSError(domain:NSBundle.mainBundle().bundleIdentifier!, code:errorCode, userInfo:[NSLocalizedDescriptionKey: errorDescription])
import Foundation import PromiseKit import XCPlayground let error = NSError(domain: "a", code: 1, userInfo: ["hello":"hello"]) let castedError = error as ErrorType let stillHaveUserInfo = castedError as NSError func convert(error: ErrorType) -> Promise<Int> { return Promise<Int> { (fulfill, reject) in reject(error) } } let promiseA = convert(error) promiseA.report { (promiseError) -> Void in let lostUserInfo = promiseError as NSError } protocol CastingNSErrorHelper { var userInfo: [NSObject : AnyObject] { get } } extension NSError : CastingNSErrorHelper {} promiseA.report { (promiseError) -> Void in let castingNSErrorHelper = promiseError as! CastingNSErrorHelper let recoveredErrorWithUserInfo = castingNSErrorHelper as! NSError } XCPSetExecutionShouldContinueIndefinitely()
+ (NSDictionary*)getUserInfo:(NSObject *)error { NSError *nsError = (NSError *)error; if (nsError != nil) { return [nsError userInfo]; } else { return nil; } }
static func myErrorHandler(error: ErrorType) { if let userInfo: [NSObject: AnyObject]? = MyErrorUtils.getUserInfo(error as? NSObject) { let myUserInfo = userInfo["myCustomUserInfo"] } }
let error: MyErrorType = ... let objcError = error as NSError
init(meme: Meme?) { self.meme = meme super.init(nibName: nil, bundle: nil) }
required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) }
class MemeDetailVC : UIViewController { var meme : Meme! @IBOutlet weak var editedImage: UIImageView! init(meme: Meme?) { self.meme = meme super.init(nibName: nil, bundle: nil) } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } override func viewDidLoad() { title = "Detail Meme" super.viewDidLoad() } override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) editedImage = UIImageView(image: meme.editedImage) } }
class MemeDetailVC : UIViewController { var meme : Meme! static func makeMemeDetailVC(meme: Meme) -> MemeDetailVC { let newViewController = UIStoryboard(name: "Main", bundle: nil).instantiateViewControllerWithIdentifier("IdentifierOfYouViewController") as! MemeDetailVC newViewController.meme = meme return newViewController } }
override func prepare(for segue: UIStoryboardSegue, sender: AnyObject?) { if segue.identifier == "identifier" { if let controller = segue.destinationViewController as? MemeDetailVC { controller.meme = "Meme" } } }
class MemeDetailVC : UIViewController { convenience init(meme: Meme) { self.init() self.meme = meme } }
class func `init`(meme: Meme) -> MemeDetailVC { let storyboard = UIStoryboard(name: "Main", bundle: nil) let vc = storyboard.instantiateViewController(withIdentifier: "MemeDetailVC") as? MemeDetailVC vc.meme = meme return vc }
public protocol NSCoding { public func encode(with aCoder: NSCoder) public init?(coder aDecoder: NSCoder) }
class TempCache{ static let sharedInstance = TempCache() var meme: Meme? } TempCache.sharedInstance.meme = meme required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder); self.meme = TempCache.sharedInstance.meme }
Project file -> Test target -> Build Settings -> Runpath Search Paths
[UIWindow endDisablingInterfaceAutorotationAnimated:] called on UITextEffectsWindow: ...without matching -beginDisablingInterfaceAutorotation. Ignoring.
func scrollViewWillBeginDragging(scrollView: UIScrollView) { textView.resignFirstResponder() }
dispatch_async(dispatch_get_main_queue(), { () -> Void in if !(weakSelf!.saved) { weakSelf?.completeNotes(nil) } })
transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
button.transform = CGAffineTransformMakeScale(-1, 1) UIView.animateWithDuration(0.5, animations: { () -> Void in button.transform = CGAffineTransformMakeScale(1,1) })
UIView.animate(withDuration: 0.6, animations: { self.button.transform = CGAffineTransform(scaleX: 0.6, y: 0.6) }, completion: { _ in UIView.animate(withDuration: 0.6) { self.button.transform = CGAffineTransform.identity } })
@IBOutlet weak var button: UIButton! @IBAction func animateButton(sender: UIButton) { sender.transform = CGAffineTransform(scaleX: 0.6, y: 0.6) UIView.animate(withDuration: 2.0, delay: 0, usingSpringWithDamping: CGFloat(0.20), initialSpringVelocity: CGFloat(6.0), options: UIViewAnimationOptions.allowUserInteraction, animations: { sender.transform = CGAffineTransform.identity }, completion: { Void in() } ) }
extension UIView { /** Simply zooming in of a view: set view scale to 0 and zoom to Identity on - parameter duration: animation duration */ func zoomIn(duration duration: NSTimeInterval = 0.2) { self.transform = CGAffineTransformMakeScale(0.0, 0.0) UIView.animateWithDuration(duration, delay: 0.0, options: [.CurveLinear], animations: { () -> Void in self.transform = CGAffineTransformIdentity }) { (animationCompleted: Bool) -> Void in } } /** Simply zooming out of a view: set view scale to Identity and zoom out to 0 on - parameter duration: animation duration */ func zoomOut(duration duration: NSTimeInterval = 0.2) { self.transform = CGAffineTransformIdentity UIView.animateWithDuration(duration, delay: 0.0, options: [.CurveLinear], animations: { () -> Void in self.transform = CGAffineTransformMakeScale(0.0, 0.0) }) { (animationCompleted: Bool) -> Void in } } /** Zoom in any view with specified offset magnification. - parameter duration: animation duration. - parameter easingOffset: easing offset. */ func zoomInWithEasing(duration duration: NSTimeInterval = 0.2, easingOffset: CGFloat = 0.2) { let easeScale = 1.0 + easingOffset let easingDuration = NSTimeInterval(easingOffset) * duration / NSTimeInterval(easeScale) let scalingDuration = duration - easingDuration UIView.animateWithDuration(scalingDuration, delay: 0.0, options: .CurveEaseIn, animations: { () -> Void in self.transform = CGAffineTransformMakeScale(easeScale, easeScale) }, completion: { (completed: Bool) -> Void in UIView.animateWithDuration(easingDuration, delay: 0.0, options: .CurveEaseOut, animations: { () -> Void in self.transform = CGAffineTransformIdentity }, completion: { (completed: Bool) -> Void in }) }) } /** Zoom out any view with specified offset magnification. - parameter duration: animation duration. - parameter easingOffset: easing offset. */ func zoomOutWithEasing(duration duration: NSTimeInterval = 0.2, easingOffset: CGFloat = 0.2) { let easeScale = 1.0 + easingOffset let easingDuration = NSTimeInterval(easingOffset) * duration / NSTimeInterval(easeScale) let scalingDuration = duration - easingDuration UIView.animateWithDuration(easingDuration, delay: 0.0, options: .CurveEaseOut, animations: { () -> Void in self.transform = CGAffineTransformMakeScale(easeScale, easeScale) }, completion: { (completed: Bool) -> Void in UIView.animateWithDuration(scalingDuration, delay: 0.0, options: .CurveEaseOut, animations: { () -> Void in self.transform = CGAffineTransformMakeScale(0.0, 0.0) }, completion: { (completed: Bool) -> Void in }) }) } }
let button = UIButton(frame: frame) button.zoomIn()
extension UIView { /** Simply zooming in of a view: set view scale to 0 and zoom to Identity on - parameter duration: animation duration */ func zoomIn(duration: TimeInterval = 0.2) { self.transform = CGAffineTransform(scaleX: 0.0, y: 0.0) UIView.animate(withDuration: duration, delay: 0.0, options: [.curveLinear], animations: { () -> Void in self.transform = CGAffineTransform.identity }) { (animationCompleted: Bool) -> Void in } } /** Simply zooming out of a view: set view scale to Identity and zoom out to 0 on - parameter duration: animation duration */ func zoomOut(duration: TimeInterval = 0.2) { self.transform = CGAffineTransform.identity UIView.animate(withDuration: duration, delay: 0.0, options: [.curveLinear], animations: { () -> Void in self.transform = CGAffineTransform(scaleX: 0.0, y: 0.0) }) { (animationCompleted: Bool) -> Void in } } /** Zoom in any view with specified offset magnification. - parameter duration: animation duration. - parameter easingOffset: easing offset. */ func zoomInWithEasing(duration: TimeInterval = 0.2, easingOffset: CGFloat = 0.2) { let easeScale = 1.0 + easingOffset let easingDuration = TimeInterval(easingOffset) * duration / TimeInterval(easeScale) let scalingDuration = duration - easingDuration UIView.animate(withDuration: scalingDuration, delay: 0.0, options: .curveEaseIn, animations: { () -> Void in self.transform = CGAffineTransform(scaleX: easeScale, y: easeScale) }, completion: { (completed: Bool) -> Void in UIView.animate(withDuration: easingDuration, delay: 0.0, options: .curveEaseOut, animations: { () -> Void in self.transform = CGAffineTransform.identity }, completion: { (completed: Bool) -> Void in }) }) } /** Zoom out any view with specified offset magnification. - parameter duration: animation duration. - parameter easingOffset: easing offset. */ func zoomOutWithEasing(duration: TimeInterval = 0.2, easingOffset: CGFloat = 0.2) { let easeScale = 1.0 + easingOffset let easingDuration = TimeInterval(easingOffset) * duration / TimeInterval(easeScale) let scalingDuration = duration - easingDuration UIView.animate(withDuration: easingDuration, delay: 0.0, options: .curveEaseOut, animations: { () -> Void in self.transform = CGAffineTransform(scaleX: easeScale, y: easeScale) }, completion: { (completed: Bool) -> Void in UIView.animate(withDuration: scalingDuration, delay: 0.0, options: .curveEaseOut, animations: { () -> Void in self.transform = CGAffineTransform(scaleX: 0.0, y: 0.0) }, completion: { (completed: Bool) -> Void in }) }) }
UIView.animate(withDuration: 0.6, animations: { button.transform = CGAffineTransform.identity.scaledBy(x: 0.6, y: 0.6) }, completion: { (finish) in UIView.animate(withDuration: 0.6, animations: { button.transform = CGAffineTransform.identity }) })
extension UIButton { func pulsate() { let pulse = CASpringAnimation(keyPath: "transform.scale") pulse.duration = 0.2 pulse.fromValue = 0.95 pulse.toValue = 1.0 pulse.autoreverses = true pulse.repeatCount = 2 pulse.initialVelocity = 0.5 pulse.damping = 1.0 layer.add(pulse, forKey: "pulse") } func flash() { let flash = CABasicAnimation(keyPath: "opacity") flash.duration = 0.2 flash.fromValue = 1 flash.toValue = 0.1 flash.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) flash.autoreverses = true flash.repeatCount = 3 layer.add(flash, forKey: nil) } func shake() { let shake = CABasicAnimation(keyPath: "position") shake.duration = 0.05 shake.repeatCount = 2 shake.autoreverses = true let fromPoint = CGPoint(x: center.x - 5, y: center.y) let fromValue = NSValue(cgPoint: fromPoint) let toPoint = CGPoint(x: center.x + 5, y: center.y) let toValue = NSValue(cgPoint: toPoint) shake.fromValue = fromValue shake.toValue = toValue layer.add(shake, forKey: "position") } }
button.transform = CGAffineTransformMakeScale(0.6, 0.6) UIView.animateWithDuration(0.3, animations: { () -> Void in button.transform = CGAffineTransformMakeScale(1,1) })
extension UIView { func animateButtonDown() { UIView.animate(withDuration: 0.1, delay: 0.0, options: [.allowUserInteraction, .curveEaseIn], animations: { self.transform = CGAffineTransform(scaleX: 0.9, y: 0.9) }, completion: nil) } func animateButtonUp() { UIView.animate(withDuration: 0.1, delay: 0.0, options: [.allowUserInteraction, .curveEaseOut], animations: { self.transform = CGAffineTransform.identity }, completion: nil) }
@IBAction func buttonTouchDown(_ sender: UIButton) { sender.animateButtonDown() } @IBAction func buttonTouchUpOutside(_ sender: UIButton) { sender.animateButtonUp() } @IBAction func buttonTouchUpInside(_ sender: UIButton) { sender.animateButtonUp() }
extension UIButton { func press(completion:@escaping ((Bool) -> Void)) { UIView.animate(withDuration: 0.05, animations: { self.transform = CGAffineTransform(scaleX: 0.8, y: 0.8) }, completion: { (finish: Bool) in UIView.animate(withDuration: 0.1, animations: { self.transform = CGAffineTransform.identity completion(finish) }) }) } }
@IBAction func playPauseBtnTap(_ sender: Any) { let playPauseBtn = sender as! UIButton playPauseBtn.press(completion:{ finish in if finish { print("animation ended") } } }
[UIView animateWithDuration:0.5 delay:0 usingSpringWithDamping:0.4 initialSpringVelocity:0.3 options:0 animations:^{ button.transform = CGAffineTransformIdentity; CGAffineTransformMakeScale(0.6, 0.6) } completion:^(BOOL finished) { [UIView.animateWithDuration(0.5){ button.transform = CGAffineTransformIdentity }]; }];
[UIView animateWithDuration:0.5f animations:^{ self.sendButton.transform = CGAffineTransformMakeScale(1.5, 1.5); } completion:^(BOOL finished){}]; [UIView animateWithDuration:0.5f animations:^{ self.sendButton.transform = CGAffineTransformMakeScale(1, 1); }completion:^(BOOL finished){}];
@IBAction func TouchUpInsideEvent(sender: UIButton) { UIView.animateWithDuration(2.0, delay: 0, usingSpringWithDamping: CGFloat(0.20), initialSpringVelocity: CGFloat(6.0), options: UIViewAnimationOptions.AllowUserInteraction, animations: { sender.transform = CGAffineTransformIdentity }, completion: { Void in() } ) } @IBAction func touchDownEvent(sender: UIButton) { UIView.animateWithDuration(0.15, animations: { sender.transform = CGAffineTransformMakeScale(0.6, 0.6) }) }
viewToAnimate.transform = CGAffineTransform(scaleX: 0.1, y: 0.1) UIView.animate(withDuration: 0.7, delay: 0, usingSpringWithDamping: 0.2, initialSpringVelocity: 6.0, animations: { _ in viewToAnimate.transform = .identity }, completion: { _ in })
UIView.animate(withDuration: 0.2, animations: { self.cartShowHideBtnView.transform = CGAffineTransform(scaleX: 1.3, y: 1.3) }, completion: { (finish: Bool) in UIView.animate(withDuration: 0.2, animations: { self.cartShowHideBtnView.transform = CGAffineTransform.identity }, completion:{(finish: Bool) in UIView.animate(withDuration: 0.2, animations: { self.cartShowHideBtnView.transform = CGAffineTransform(scaleX: 1.3, y: 1.3) }, completion: { (finish: Bool) in UIView.animate(withDuration: 0.2, animations: { self.cartShowHideBtnView.transform = CGAffineTransform.identity }, completion:{(finish: Bool) in UIView.animate(withDuration: 0.2, animations: { self.cartShowHideBtnView.transform = CGAffineTransform(scaleX: 1.3, y: 1.3) }, completion: { (finish: Bool) in UIView.animate(withDuration: 0.2, animations: { self.cartShowHideBtnView.transform = CGAffineTransform.identity }) }) }) }) }) })
import Foundation import UIKit protocol Showable where Self: UIView {} extension Showable { func show(_ view: UIView? = nil) { if let view = view { self.animate(view) } else { self.animate(self) } } private func animate(_ view: UIView) { view.transform = CGAffineTransform(scaleX: 0.0, y: 0.0) UIView.animate(withDuration: 2.0, delay: 0, usingSpringWithDamping: CGFloat(0.20), initialSpringVelocity: CGFloat(6.0), options: [.allowUserInteraction], animations: { view.transform = CGAffineTransform.identity }) } }
extension UIButton{ func flash() { let flash = CABasicAnimation(keyPath: "opacity") flash.duration = 0.5 flash.fromValue = 1 flash.toValue = 0.1 flash.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) flash.autoreverses = true flash.repeatCount = 3 layer.add(flash, forKey: nil) } } @IBAction func taptosave(_ sender: UIButton) { sender.flash() }
UIImage *resizedImage = [anImage resizedImageWithContentMode:UIViewContentModeScaleAspectFit bounds:CGSizeMake(560.0f, 560.0f) interpolationQuality:kCGInterpolationHigh]; UIImage *thumbnailImage = [anImage thumbnailImage:86.0f transparentBorder:0.0f cornerRadius:10.0f interpolationQuality:kCGInterpolationDefault];
func resizeImage(image: UIImage, targetSize: CGSize) -> UIImage { let size = image.size let widthRatio = targetSize.width / size.width let heightRatio = targetSize.height / size.height var newSize: CGSize if(widthRatio > heightRatio) { newSize = CGSizeMake(size.width * heightRatio, size.height * heightRatio) } else { newSize = CGSizeMake(size.width * widthRatio, size.height * widthRatio) } let rect = CGRectMake(0, 0, newSize.width, newSize.height) UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0) image.drawInRect(rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage }
self.resizeImage(UIImage(named: "yourImageName")!, targetSize: CGSizeMake(200.0, 200.0))
func resizeImage(image: UIImage, targetSize: CGSize) -> UIImage { let size = image.size let widthRatio = targetSize.width / size.width let heightRatio = targetSize.height / size.height var newSize: CGSize if(widthRatio > heightRatio) { newSize = CGSize(width: size.width * heightRatio, height: size.height * heightRatio) } else { newSize = CGSize(width: size.width * widthRatio, height: size.height * widthRatio) } let rect = CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height) UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0) image.draw(in: rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! }
func resizeImage(image: UIImage, targetSize: CGSize) -> UIImage { let size = image.size let widthRatio = targetSize.width / image.size.width let heightRatio = targetSize.height / image.size.height var newSize: CGSize if(widthRatio > heightRatio) { newSize = CGSize(width: size.width * heightRatio, height: size.height * heightRatio) } else { newSize = CGSize(width: size.width * widthRatio, height: size.height * widthRatio) } let rect = CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height) UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0) image.draw(in: rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! }
extension UIImage { func resizeImage(_ dimension: CGFloat, opaque: Bool, contentMode: UIViewContentMode = .scaleAspectFit) -> UIImage { var width: CGFloat var height: CGFloat var newImage: UIImage let size = self.size let aspectRatio = size.width/size.height switch contentMode { case .scaleAspectFit: if aspectRatio > 1 { width = dimension height = dimension / aspectRatio } else { height = dimension width = dimension * aspectRatio } default: fatalError("UIIMage.resizeToFit(): FATAL: Unimplemented ContentMode") } if let renderFormat = UIGraphicsImageRendererFormat.default() renderFormat.opaque = opaque let renderer = UIGraphicsImageRenderer(size: CGSize(width: width, height: height), format: renderFormat) newImage = renderer.image { (context) in self.draw(in: CGRect(x: 0, y: 0, width: width, height: height)) } } else { UIGraphicsBeginImageContextWithOptions(CGSize(width: width, height: height), opaque, 0) self.draw(in: CGRect(x: 0, y: 0, width: width, height: height)) newImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() } return newImage } }
let size = CGSize(width: 30.0, height: 30.0) let aspectScaledToFitImage = image.af_imageAspectScaled(toFit: size)
import UIKit extension UIImage { func resizeImage(targetSize: CGSize) -> UIImage { let size = self.size let widthRatio = targetSize.width / size.width let heightRatio = targetSize.height / size.height let newSize = widthRatio > heightRatio ? CGSize(width: size.width * heightRatio, height: size.height * heightRatio) : CGSize(width: size.width * widthRatio, height: size.height * widthRatio) let rect = CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height) UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0) self.draw(in: rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } }
extension UIImage { func resizeImage(targetSize: CGSize) -> UIImage { let size = self.size let widthRatio = targetSize.width / size.width let heightRatio = targetSize.height / size.height var newSize: CGSize if(widthRatio > heightRatio) { newSize = CGSize(width: size.width * heightRatio, height: size.height * heightRatio) } else { newSize = CGSize(width: size.width * widthRatio, height: size.height * widthRatio) } let rect = CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height) UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0) self.draw(in: rect) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } }
extension UIImage { func resizeImage(_ newSize: CGSize) -> UIImage? { func isSameSize(_ newSize: CGSize) -> Bool { return size == newSize } func scaleImage(_ newSize: CGSize) -> UIImage? { func getScaledRect(_ newSize: CGSize) -> CGRect { let ratio = max(newSize.width / size.width, newSize.height / size.height) let width = size.width * ratio let height = size.height * ratio return CGRect(x: 0, y: 0, width: width, height: height) } func _scaleImage(_ scaledRect: CGRect) -> UIImage? { UIGraphicsBeginImageContextWithOptions(scaledRect.size, false, 0.0); draw(in: scaledRect) let image = UIGraphicsGetImageFromCurrentImageContext() ?? UIImage() UIGraphicsEndImageContext() return image } return _scaleImage(getScaledRect(newSize)) } return isSameSize(newSize) ? self : scaleImage(newSize)! } }
let image1 = resizeimage(image: myimage.image!, withSize: CGSize(width:200, height: 200))
func resizeimage(image:UIImage,withSize:CGSize) -> UIImage { var actualHeight:CGFloat = image.size.height var actualWidth:CGFloat = image.size.width let maxHeight:CGFloat = withSize.height let maxWidth:CGFloat = withSize.width var imgRatio:CGFloat = actualWidth/actualHeight let maxRatio:CGFloat = maxWidth/maxHeight let compressionQuality = 0.5 if (actualHeight>maxHeight||actualWidth>maxWidth) { if (imgRatio<maxRatio){ imgRatio = maxHeight/actualHeight actualWidth = imgRatio * actualWidth actualHeight = maxHeight }else if(imgRatio>maxRatio){ imgRatio = maxWidth/actualWidth actualHeight = imgRatio * actualHeight actualWidth = maxWidth }else{ actualHeight = maxHeight actualWidth = maxWidth } } let rec:CGRect = CGRect(x:0.0,y:0.0,width:actualWidth,height:actualHeight) UIGraphicsBeginImageContext(rec.size) image.draw(in: rec) let image:UIImage = UIGraphicsGetImageFromCurrentImageContext()! let imageData = UIImageJPEGRepresentation(image, CGFloat(compressionQuality)) UIGraphicsEndImageContext() let resizedimage = UIImage(data: imageData!) return resizedimage! }
func image(with image: UIImage, scaledTo newSize: CGSize) -> UIImage { UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0) image.draw(in: CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() drawingImageView.image = newImage return newImage ?? UIImage() }
image(with: predictionImage, scaledTo: CGSize(width: 28.0, height: 28.0)
extension UIImage { func resizedImage(newSize: CGSize) -> UIImage { guard self.size != newSize else { return self } UIGraphicsBeginImageContextWithOptions(newSize, false, 0.0); self.draw(in: CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height)) let newImage: UIImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() return newImage } func resizedImageWithinRect(rectSize: CGSize) -> UIImage { let widthFactor = size.width / rectSize.width let heightFactor = size.height / rectSize.height var resizeFactor = widthFactor if size.height > size.width { resizeFactor = heightFactor } let newSize = CGSize(width: size.width/resizeFactor, height: size.height/resizeFactor) let resized = resizedImage(newSize: newSize) return resized } }
let resizedImage = image.resizedImageWithinRect(rectSize: CGSize(width: 1900, height: 1900))
extension UIImage { func scaled(with scale: CGFloat) -> UIImage? { let size = CGSize(width: floor(self.size.width * scale), height: floor(self.size.height * scale)) UIGraphicsBeginImageContext(size) draw(in: CGRect(x: 0, y: 0, width: size.width, height: size.height)) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image }
func scaledWithMaxWidthOrHeightValue(value: CGFloat) -> UIImage? { let width = self.size.width let height = self.size.height let ratio = width/height var newWidth = value var newHeight = value if ratio > 1 { newWidth = width * (newHeight/height) } else { newHeight = height * (newWidth/width) } UIGraphicsBeginImageContextWithOptions(CGSize(width: newWidth, height: newHeight), false, 0) draw(in: CGRect(x: 0, y: 0, width: newWidth, height: newHeight)) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } func scaled(withScale scale: CGFloat) -> UIImage? { let size = CGSize(width: self.size.width * scale, height: self.size.height * scale) UIGraphicsBeginImageContextWithOptions(size, false, 0) draw(in: CGRect(x: 0, y: 0, width: size.width, height: size.height)) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image }
if image.size.height >= 1024 && image.size.width >= 1024 { UIGraphicsBeginImageContext(CGSize(width:1024, height:1024)) image.draw(in: CGRect(x:0, y:0, width:1024, height:1024)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } else if image.size.height >= 1024 && image.size.width < 1024 { UIGraphicsBeginImageContext(CGSize(width:image.size.width, height:1024)) image.draw(in: CGRect(x:0, y:0, width:image.size.width, height:1024)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } else if image.size.width >= 1024 && image.size.height < 1024 { UIGraphicsBeginImageContext(CGSize(width:1024, height:image.size.height)) image.draw(in: CGRect(x:0, y:0, width:1024, height:image.size.height)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! } else { return image } }
var sillyString = "This is a string!" let yellyString = sillyString.uppercaseString let silentString = sillyString.lowercaseString
import Foundation var sillyString = "This is a string!" let yellyString = sillyString.uppercaseString let silentString = sillyString.lowercaseString
import Foundation var sillyString = "This is a string!" let yellyString = sillyString.uppercased() let silentString = sillyString.lowercased()
import Foundation let title = "Castration: The Advantages and the Disadvantages" title.uppercased() title.lowercased() title.capitalized
NSString(string: "abcd").uppercased NSString(string: "ABCD").lowercased NSString(string: "abCd").capitalized
let turkishI = "\u{0130} is not I" turkishI.uppercased() turkishI.uppercased(with: Locale(identifier: "en")) turkishI.uppercased(with: Locale(identifier: "tr")) turkishI.lowercased() turkishI.capitalized turkishI.lowercased(with: Locale(identifier: "en")) turkishI.lowercased(with: Locale(identifier: "tr"))
turkishI.uppercased(with: Locale(localeIdentifier: "en"))
var a = "StackOverFlow" var last4 = a.lastFour print(last4)
let a = "StackOverFlow" let last4 = a.substringFromIndex(a.endIndex.advancedBy(-4))
let last4 = a.substring(from:a.index(a.endIndex, offsetBy: -4))
let a = "1234567890" let last4 = String(a.characters.suffix(4)) print(last4)
let color = colorChoiceSegmentedControl.titleForSegmentAtIndex(colorChoiceSegmentedControl.selectedSegmentIndex) println(color) let imageURLString = "http: println(imageURLString)
var temp : String? temp = "I am a programer" print(temp) var temp1 : String! temp1 = "I am a programer" print(temp1)
if let color = colorChoiceSegmentedControl.titleForSegmentAtIndex(colorChoiceSegmentedControl.selectedSegmentIndex) { println(color) let imageURLString = "http: println(imageURLString) }
let color = colorChoiceSegmentedControl.titleForSegmentAtIndex(colorChoiceSegmentedControl.selectedSegmentIndex) println(color) if color != nil { println(color!) let imageURLString = "http: println(imageURLString) }
import NoOptionalInterpolation let a: String? = "string" "\(a)" "\(a*)"
var check:String?="optional String" print(check!) print(check)
let dashboardWorkout = DashboardWorkoutViewController() presentViewController(dashboardWorkout, animated: true, completion: nil)
let transition = CATransition() transition.duration = 0.5 transition.type = CATransitionType.push transition.subtype = CATransitionSubtype.fromRight transition.timingFunction = CAMediaTimingFunction(name:CAMediaTimingFunctionName.easeInEaseOut) view.window!.layer.add(transition, forKey: kCATransition) present(dashboardWorkout, animated: false, completion: nil)
CATransition *transition = [[CATransition alloc] init]; transition.duration = 0.5; transition.type = kCATransitionPush; transition.subtype = kCATransitionFromRight; [transition setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]]; [self.view.window.layer addAnimation:transition forKey:kCATransition]; [self presentViewController:dashboardWorkout animated:false completion:nil];
let transition = CATransition() transition.duration = 0.5 transition.type = kCATransitionPush transition.subtype = kCATransitionFromRight transition.timingFunction = CAMediaTimingFunction(name:kCAMediaTimingFunctionEaseInEaseOut) view.window!.layer.addAnimation(transition, forKey: kCATransition) presentViewController(dashboardWorkout, animated: false, completion: nil)
extension UIViewController { func presentDetail(_ viewControllerToPresent: UIViewController) { let transition = CATransition() transition.duration = 0.25 transition.type = kCATransitionPush transition.subtype = kCATransitionFromRight self.view.window!.layer.add(transition, forKey: kCATransition) present(viewControllerToPresent, animated: false) } func dismissDetail() { let transition = CATransition() transition.duration = 0.25 transition.type = kCATransitionPush transition.subtype = kCATransitionFromLeft self.view.window!.layer.add(transition, forKey: kCATransition) dismiss(animated: false) } }
class SegueFromRight: UIStoryboardSegue { override func perform() { let src = self.source let dst = self.destination src.view.superview?.insertSubview(dst.view, aboveSubview: src.view) dst.view.transform = CGAffineTransform(translationX: src.view.frame.size.width, y: 0) UIView.animate(withDuration: 0.25, delay: 0.0, options: UIViewAnimationOptions.curveEaseInOut, animations: { dst.view.transform = CGAffineTransform(translationX: 0, y: 0) }, completion: { finished in src.present(dst, animated: false, completion: nil) } ) } }
var presentTransition: UIViewControllerAnimatedTransitioning? var dismissTransition: UIViewControllerAnimatedTransitioning? func showSettings(animated: Bool) { let vc = ... create new vc to present presentTransition = RightToLeftTransition() dismissTransition = LeftToRightTransition() vc.modalPresentationStyle = .custom vc.transitioningDelegate = self present(vc, animated: true, completion: { [weak self] in self?.presentTransition = nil }) }
extension ViewController: UIViewControllerTransitioningDelegate { func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? { return presentTransition } func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? { return dismissTransition } }
class RightToLeftTransition: NSObject, UIViewControllerAnimatedTransitioning { let duration: TimeInterval = 0.25 func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval { return duration } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { let container = transitionContext.containerView let toView = transitionContext.view(forKey: .to)! container.addSubview(toView) toView.frame.origin = CGPoint(x: toView.frame.width, y: 0) UIView.animate(withDuration: duration, delay: 0, options: .curveEaseOut, animations: { toView.frame.origin = CGPoint(x: 0, y: 0) }, completion: { _ in transitionContext.completeTransition(true) }) } } class LeftToRightTransition: NSObject, UIViewControllerAnimatedTransitioning { let duration: TimeInterval = 0.25 func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval { return duration } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { let container = transitionContext.containerView let fromView = transitionContext.view(forKey: .from)! container.addSubview(fromView) fromView.frame.origin = .zero UIView.animate(withDuration: duration, delay: 0, options: .curveEaseIn, animations: { fromView.frame.origin = CGPoint(x: fromView.frame.width, y: 0) }, completion: { _ in fromView.removeFromSuperview() transitionContext.completeTransition(true) }) } }
let animation = CATransition() animation.duration = 0.5 animation.type = kCATransitionPush animation.subtype = kCATransitionFromRight animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) vc.view.layer.addAnimation(animation, forKey: "SwitchToView") self.presentViewController(vc, animated: false, completion: nil)
class AA: UIViewController func goToBB { let bb = .. instantiateViewcontroller, storyboard etc .. as! AlreadyOnboardLogin let tr = CATransition() tr.duration = 0.25 tr.type = kCATransitionMoveIn tr.subtype = kCATransitionFromRight view.window!.layer.add(tr, forKey: kCATransition) present(bb, animated: false) bb.delegate, etc = set any other needed values }
func dismissingBB() { let tr = CATransition() tr.duration = 0.25 tr.type = kCATransitionReveal tr.subtype = kCATransitionFromLeft view.window!.layer.add(tr, forKey: kCATransition) dismiss(self) .. or dismiss(bb), or whatever }
let nextScreen = instantiateViewController etc as! NextScreen navigationController? .pushViewController(nextScreen, animated: true)
let transition: CATransition = CATransition() transition.duration = 0.3 transition.type = kCATransitionReveal transition.subtype = kCATransitionFromLeft self.view.window!.layer.addAnimation(transition, forKey: nil) self.dismissViewControllerAnimated(false, completion: nil)
func FrkTransition() { let transition = CATransition() transition.duration = 2 transition.type = kCATransitionPush transitioningLayer.add(transition,forKey: "transition") transitioningLayer.backgroundColor = UIColor.blue.cgColor transitioningLayer.string = "Blue" }
self.navigationController?.pushViewController(controller, animated: true)
func requestFacebook() { let graphRequest : FBSDKGraphRequest = FBSDKGraphRequest(graphPath: "me", parameters: nil) graphRequest.startWithCompletionHandler({ (connection, result, error) -> Void in if ((error) != nil) { println("Error: \(error)") } else if error == nil { let birthday : NSString = (result.valueForKey("birthday") as? NSString)! var currentDate = NSDate() var birthdayFormatter = NSDateFormatter() let userCalendar = NSCalendar.currentCalendar() birthdayFormatter.dateFormat = "MM/DD/YYYY" var birthdayNSDate = birthdayFormatter.dateFromString(birthday as String) var userAge = self.calculateAge(birthdayNSDate!) PFUser.currentUser()!["age"] = userAge var facebookID: NSString = (result.valueForKey("id") as? NSString)! var pictureURL = "https: var URLRequest = NSURL(string: pictureURL) var URLRequestNeeded = NSURLRequest(URL: URLRequest!) NSURLConnection.sendAsynchronousRequest(URLRequestNeeded, queue: NSOperationQueue.mainQueue(), completionHandler: {(response: NSURLResponse!,data: NSData!, error: NSError!) -> Void in if error == nil { var picture = PFFile(data: data) PFUser.currentUser()!["picture"] = picture PFUser.currentUser()!.saveInBackgroundWithBlock({ (success, error) -> Void in if error == nil { var userPicture:PFFile = PFUser.currentUser()!.valueForKey("picture") as! PFFile userPicture.getDataInBackgroundWithBlock { (imageData, error) -> Void in if error == nil { self.meProfileImageView.image = UIImage(data: imageData!) var userName:String = PFUser.currentUser()!.valueForKey("username") as! String var userAge:Int = PFUser.currentUser()!.valueForKey("age") as! Int self.meLabel.text = "\(userName), \(userAge)" self.findFriends() } } } else { println(error) } }) } else { println("Error: \(error.localizedDescription)") } }) } }) }
let birthday : NSString = (result.valueForKey("birthday") as? NSString)!
let graphRequest : FBSDKGraphRequest = FBSDKGraphRequest(graphPath: "me", parameters: nil)
Register for mobile Confirm their account via SMS Enter a valid credit card
NSArray *permissionsArray = @[ @"email", @"public_profile"];
FBSDKGraphRequest *request = [[FBSDKGraphRequest alloc] initWithGraphPath:[NSString stringWithFormat:@"me/picture"] parameters:@{@"fields": @""} HTTPMethod:@"GET"]; [request startWithCompletionHandler:^(FBSDKGraphRequestConnection *connection, id result, NSError *error) { if (!error) { } else { }} ];
let graphRequest: FBSDKGraphRequest = FBSDKGraphRequest(graphPath: "me", parameters: ["fields": "email, first_name, last_name, gender, picture"])
func screenShotMethod() { UIGraphicsBeginImageContext(view.frame.size) view.layer.renderInContext(UIGraphicsGetCurrentContext()) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil) }
view.layer.renderInContext(UIGraphicsGetCurrentContext())
let image = UIGraphicsGetImageFromCurrentImageContext()
open func takeScreenshot(_ shouldSave: Bool = true) -> UIImage? { var screenshotImage :UIImage? let layer = UIApplication.shared.keyWindow!.layer let scale = UIScreen.main.scale UIGraphicsBeginImageContextWithOptions(layer.frame.size, false, scale); guard let context = UIGraphicsGetCurrentContext() else {return nil} layer.render(in:context) screenshotImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() if let image = screenshotImage, shouldSave { UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil) } return screenshotImage }
func screenShotMethod() { let layer = UIApplication.sharedApplication().keyWindow!.layer let scale = UIScreen.mainScreen().scale UIGraphicsBeginImageContextWithOptions(layer.frame.size, false, scale); layer.renderInContext(UIGraphicsGetCurrentContext()!) let screenshot = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() UIImageWriteToSavedPhotosAlbum(screenshot, nil, nil, nil) }
func captureScreen() -> UIImage? { guard let context = UIGraphicsGetCurrentContext() else { return .none } UIGraphicsBeginImageContextWithOptions(view.bounds.size, false, UIScreen.main.scale) view.layer.render(in: context) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image }
import UIKit extension UIApplication { var screenShot: UIImage? { return keyWindow?.layer.screenShot } } extension CALayer { var screenShot: UIImage? { let scale = UIScreen.main.scale UIGraphicsBeginImageContextWithOptions(frame.size, false, scale) if let context = UIGraphicsGetCurrentContext() { render(in: context) let screenshot = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return screenshot } return nil } }
import UIKit extension UIApplication { var screenShot: UIImage? { if let layer = keyWindow?.layer { let scale = UIScreen.main.scale UIGraphicsBeginImageContextWithOptions(layer.frame.size, false, scale); if let context = UIGraphicsGetCurrentContext() { layer.render(in: context) let screenshot = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return screenshot } } return nil } }
import UIKit extension UIApplication { var screenShot: UIImage? { if let rootViewController = keyWindow?.rootViewController { let scale = UIScreen.main.scale let bounds = rootViewController.view.bounds UIGraphicsBeginImageContextWithOptions(bounds.size, false, scale); if let _ = UIGraphicsGetCurrentContext() { rootViewController.view.drawHierarchy(in: bounds, afterScreenUpdates: true) let screenshot = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return screenshot } } return nil } }
import UIKit public extension UIWindow { func capture() -> UIImage { UIGraphicsBeginImageContextWithOptions(self.frame.size, self.opaque, UIScreen.mainScreen().scale) self.layer.renderInContext(UIGraphicsGetCurrentContext()!) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }
let window: UIWindow! = UIApplication.sharedApplication().keyWindow let windowImage = window.capture()
extension UIView { func capture() -> UIImage? { var image: UIImage? if let format = UIGraphicsImageRendererFormat() format.opaque = isOpaque let renderer = UIGraphicsImageRenderer(size: frame.size, format: format) image = renderer.image { context in drawHierarchy(in: frame, afterScreenUpdates: true) } } else { UIGraphicsBeginImageContextWithOptions(frame.size, isOpaque, UIScreen.main.scale) drawHierarchy(in: frame, afterScreenUpdates: true) image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() } return image } }
func captureScreen() -> UIImage { var window: UIWindow? = UIApplication.sharedApplication().keyWindow window = UIApplication.sharedApplication().windows[0] as? UIWindow UIGraphicsBeginImageContextWithOptions(window!.frame.size, window!.opaque, 0.0) window!.layer.renderInContext(UIGraphicsGetCurrentContext()) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image; }
func screenShot() -> UIImage { UIGraphicsBeginImageContext(CGSizeMake(frame.size.width, frame.size.height)) var context:CGContextRef = UIGraphicsGetCurrentContext() self.view?.drawViewHierarchyInRect(frame, afterScreenUpdates: true) var screenShot = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext(); return screenShot }
public extension UIWindow { func capture() -> UIImage? { UIGraphicsBeginImageContextWithOptions(self.frame.size, self.isOpaque, UIScreen.main.scale) self.layer.render(in: UIGraphicsGetCurrentContext()!) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }]
extension UIApplication { var screenshot: UIImage? { UIGraphicsBeginImageContextWithOptions(UIScreen.main.bounds.size, false, 0) guard let context = UIGraphicsGetCurrentContext() else { return nil } for window in windows { window.layer.render(in: context) } let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }
let array = ["one", "one", "two", "two", "three", "three"] let unique = Array(Set(array))
extension Array where Element : Equatable { var unique: [Element] { var uniqueValues: [Element] = [] forEach { item in if !uniqueValues.contains(item) { uniqueValues += [item] } } return uniqueValues } }
extension Array where Element : Hashable { var unique: [Element] { return Array(Set(self)) } }
extension Sequence where Iterator.Element: Hashable { func unique() -> [Iterator.Element] { var seen: [Iterator.Element: Bool] = [:] return self.filter { seen.updateValue(true, forKey: $0) == nil } } } let a = ["four","one", "two", "one", "three","four", "four"] a.unique
func distinct<S: SequenceType, E: Equatable where E==S.Generator.Element>(source: S) -> [E] { var unique = [E]() for item in source { if !contains(unique, item) { unique.append(item) } } return unique }
[ "06786984572365", "06644857247565", "06649998782227" ]
var request = URLRequest(url: url) request.httpMethod = "POST" request.setValue("application/json", forHTTPHeaderField: "Content-Type") let values = ["06786984572365", "06644857247565", "06649998782227"] request.httpBody = try! JSONSerialization.data(withJSONObject: values) Alamofire.request(request) .responseJSON { response in switch response.result { case .failure(let error): print(error) if let data = response.data, let responseString = String(data: data, encoding: .utf8) { print(responseString) } case .success(let responseObject): print(responseObject) } }
import Foundation import Alamofire private let arrayParametersKey = "arrayParametersKey" extension Array { func asParameters() -> Parameters { return [arrayParametersKey: self] } } public struct ArrayEncoding: ParameterEncoding { public let options: JSONSerialization.WritingOptions public init(options: JSONSerialization.WritingOptions = []) { self.options = options } public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest { var urlRequest = try urlRequest.asURLRequest() guard let parameters = parameters, let array = parameters[arrayParametersKey] else { return urlRequest } do { let data = try JSONSerialization.data(withJSONObject: array, options: options) if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil { urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type") } urlRequest.httpBody = data } catch { throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error)) } return urlRequest } }
let values = ["06786984572365", "06644857247565", "06649998782227"] Alamofire.request(url, method: .post, parameters: values.asParameters(), encoding: ArrayEncoding())
import Foundation import Alamofire import Orga class Thing { ... } enum Router: URLRequestConvertible { static let baseURLString = "http: case UploadThings([Thing]) private var method: Alamofire.Method { switch self { case .UploadThings: return .POST } } private var path: String { switch self { case .UploadThings: return "upload/things" } } var URLRequest: NSMutableURLRequest { let r = NSMutableURLRequest(URL: NSURL(string: Router.baseURLString)!.URLByAppendingPathComponent(path)) r.HTTPMethod = method.rawValue switch self { case .UploadThings(let things): let custom: (URLRequestConvertible, [String:AnyObject]?) -> (NSMutableURLRequest, NSError?) = { (convertible, parameters) in var mutableRequest = convertible.URLRequest.copy() as! NSMutableURLRequest do { let jsonObject = things.encode().JSONObject() let data = try NSJSONSerialization.dataWithJSONObject(jsonObject, options: NSJSONWritingOptions.PrettyPrinted) mutableRequest.setValue("application/json", forHTTPHeaderField: "Content-Type") mutableRequest.HTTPBody = data return (mutableRequest, nil) } catch let error as NSError { return (mutableRequest, error) } } return ParameterEncoding.Custom(custom).encode(r, parameters: nil).0 default: return r } } }
func POST(RequestURL: String,postData:[AnyObject]?,successHandler: (String) -> (),failureHandler: (String) -> ()) -> () { print("POST : \(RequestURL)") let request = NSMutableURLRequest(URL: NSURL(string:RequestURL)!) request.HTTPMethod = "POST" request.setValue("application/json", forHTTPHeaderField: "Content-Type") var error: NSError? do { request.HTTPBody = try NSJSONSerialization.dataWithJSONObject(postData!, options:[]) } catch { print("JSON serialization failed: \(error)") } Alamofire.request(request) .responseString{ response in switch response.result { case .Success: print(response.response?.statusCode) print(response.description) if response.response?.statusCode == 200 { successHandler(response.result.value!) }else{ failureHandler("\(response.description)") } case .Failure(let error): failureHandler("\(error)") } } }
struct JSONDocumentArrayEncoding: ParameterEncoding { private let array: [Any] init(array:[Any]) { self.array = array } func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest { var urlRequest = urlRequest.urlRequest let data = try JSONSerialization.data(withJSONObject: array, options: []) if urlRequest!.value(forHTTPHeaderField: "Content-Type") == nil { urlRequest!.setValue("application/json", forHTTPHeaderField: "Content-Type") } urlRequest!.httpBody = data return urlRequest! } }
let headers = getHeaders() var urlRequest = URLRequest(url: URL(string: (ServerURL + Api))!) urlRequest.httpMethod = "post" urlRequest.allHTTPHeaderFields = headers let jsonArrayencoding = JSONDocumentArrayEncoding(array: documents) let jsonAryEncodedRequest = try? jsonArrayencoding.encode(urlRequest, with: nil) request = customAlamofireManager.request(jsonAryEncodedRequest!) request?.validate{request, response, data in return .success } .responseJSON { (response) -> Void in ... }
d["completionDetail"] = "[{"YearOfCompletion":"14/03/2017","Completed":true}]"
d["YearOfCompletion[0]"] = "1998" d["YearOfCompletion[1]"] = "1997" d["YearOfCompletion[2]"] = "1996" d["Completed[0]"] = "true" d["Completed[1]"] = "false" d["Completed[2]"] = "true"
func wsDataRequest(url:String, parameters:Dictionary<String, Any>) { debugPrint("Request:", url, parameters as NSDictionary, separator: "\n") if Rechability.connectedToNetwork() == false {SVProgressHUD.showError(withStatus: NSLocalizedString("No Network available! Please check your connection and try again later.", comment: "")); return} // self.request = Alamofire.request(url, method: .post, parameters: parameters) if let request = self.request as? DataRequest { request.responseString { response in var serializedData : Any? = nil var message = NSLocalizedString("Success!", comment: "") if response.result.isSuccess == true { do { serializedData = try JSONSerialization.jsonObject(with: response.data!, options: JSONSerialization.ReadingOptions.allowFragments) }catch{ message = NSLocalizedString("Webservice Response error!", comment: "") var string = String.init(data: response.data!, encoding: .utf8) as String! do { if let index = string?.characters.index(of: "{") { if let s = string?.substring(from: index) { if let data = s.data(using: String.Encoding.utf8) { serializedData = try JSONSerialization.jsonObject(with: data, options: JSONSerialization.ReadingOptions.allowFragments) debugPrint(message, "Courtesy SUME:", serializedData ?? "Data could not be serialized", separator: "\n") } } } }catch{debugPrint(message, error.localizedDescription, "Respone String:", string ?? "No respone value.", separator: "\n")} debugPrint(message, error.localizedDescription, "Respone String:", string ?? "No respone value.", separator: "\n") } self.delegate?.finished(succes: response.result.isSuccess, and: serializedData, message: message) }else{ if self.retryCounter < 1 { self.wsDataRequest(url: url, parameters: parameters) }else{ message = response.error?.localizedDescription ?? (NSLocalizedString("No network", comment: "")+"!") SVProgressHUD.showError(withStatus: message); debugPrint(message) self.delay(2.0, closure: {self.delegate?.finished(succes: response.result.isSuccess, and: serializedData, message:message)}) } self.retryCounter += 1 } } } }
let url = try Router.baseURL.asURL() var urlRequest = URLRequest(url: url.appendingPathComponent(path)) urlRequest.httpMethod = "post" urlRequest = try! JSONEncoding.default.encode(urlRequest, withJSONObject: dictArray)
let values = ["06786984572365", "06644857247565", "06649998782227"] Alamofire.request(.POST, url, parameters: values, encoding:.JSON) .authenticate(user: userid, password: password) .responseJSON { (request, response, responseObject, error) in if responseObject == nil { println(error) } else { println(responseObject) } }
var stringArray:[String] = ["value1", "value2", "value3", "value4"]
let joiner = ":" let elements = ["one", "two", "three"] let joinedStrings = elements.joined(separator: joiner) print("joinedStrings: \(joinedStrings)")
var joiner = ":" var elements = ["one", "two", "three"] var joinedStrings = elements.joinWithSeparator(joiner) print("joinedStrings: \(joinedStrings)")
var joiner = ":" var elements = ["one", "two", "three"] var joinedStrings = joiner.join(elements) println("joinedStrings: \(joinedStrings)")
NSString *joiner = @":"; NSArray *elements = @[@"one", @"two", @"three"]; NSString *joinedStrings = [elements componentsJoinedByString:joiner]; NSLog(@"joinedStrings: %@", joinedStrings);
if (array.count > 0) { NSLog(@"There are objects!"); } else { NSLog(@"There are no objects..."); }
if array != nil && array!.count > 0 { println("There are objects") } else { println("No objects") }
if let unbindArray = array { if (unbindArray.count > 0) { println("There are objects!") } else { println("There are no objects...") } } else { println("There are no objects...") }
if (array?.count ?? 0) > 0 { println("There are objects") } else { println("No objects") }
if array?.count > 0 { println("There are objects") } else { println("No objects") }
if array?.count == 0 { println("There are no objects") }
if array?.isEmpty == true { println("There are no objects") }
if array?.isEmpty == false { print("There are objects!") }
if array?.count ?? 0 > 0 { print("There are objects!") } if !(array?.isEmpty ?? true) { print("There are objects!") } if array != nil && !array!.isEmpty { print("There are objects!") } if array != nil && array!.count > 0 { print("There are objects!") } if !(array ?? []).isEmpty { print("There are objects!") } if (array ?? []).count > 0 { print("There are objects!") } if let array = array, array.count > 0 { print("There are objects!") } if let array = array, !array.isEmpty { print("There are objects!") }
if !(array?.isEmpty == false) { print("There are no objects") }
if array == nil || array!.count == 0 { print("There are no objects") }
if array == nil || array!.isEmpty { print("There are no objects") }
if (array ?? []).isEmpty { print("There are no objects") }
if array?.isEmpty ?? true { print("There are no objects") }
if (array?.count ?? 0) == 0 { print("There are no objects") }
if array?.count > 0 { print("There are objects") } else { print("No objects") }
if array?.isEmpty == false { print("There are objects") } else { print("No objects") }
if !(array?.count > 0) { print("There are no objects") }
if !(array?.isEmpty == false) { print("There are no objects") }
if array == nil || array!.count == 0 { print("There are no objects") }
if array == nil || array!.isEmpty { print("There are no objects") }
if (array ?? []).isEmpty { print("There are no objects") }
if array?.isEmpty ?? true { print("There are no objects") }
if (array?.count ?? 0) == 0 { print("There are no objects") }
extension Optional where Wrapped: Collection { var isNilOrEmpty: Bool { switch self { case .some(let collection): return collection.isEmpty case .none: return true } } }
if array.isNilOrEmpty { print("The array is nil or empty") }
if (array ?? []).isEmpty { print("The array is nil or empty") }
if array == nil || array!.isEmpty { print("The array is nil or empty") }
if !(array?.isEmpty == false) { print("The array is nil or empty") } if array?.isEmpty ?? true { print("There are no objects") }
guard let myArray = array where !myArray.isEmpty else { return }
extension Optional where Wrapped: Collection { var nilIfEmpty: Optional { switch self { case .some(let collection): return collection.isEmpty ? nil : collection default: return nil } } var isNilOrEmpty: Bool { switch self { case .some(let collection): return collection.isEmpty case .none: return true } }
guard let array = myObject?.array.nilIfEmpty else { return }
var array : [Int]? array.map {$0.isEmpty} array = [] array.map {$0.isEmpty} array?.append(1) array.map {$0.isEmpty}
func userAlreadyExist() -> Bool { var userDefaults : NSUserDefaults = NSUserDefaults.standardUserDefaults() if userDefaults.objectForKey(kUSERID) { return true } return false }
func isKeyPresentInUserDefaults(key: String) -> Bool { return UserDefaults.standard.object(forKey: key) != nil }
func userAlreadyExist(kUsernameKey: String) -> Bool { return NSUserDefaults.standardUserDefaults().objectForKey(kUsernameKey) != nil }
extension UserDefaults { func contains(key: String) -> Bool { return UserDefaults.standard.object(forKey: key) != nil } }
let userdefaults = UserDefaults.standard if let savedValue = userdefaults.string(forKey: "key"){ print("Here you will get saved value") } else { print("No value in Userdefault,Either you can save value here or perform other operation") userdefaults.set("Here you can save value", forKey: "key") }
func userAlreadyExist(kUsernameKey: String) -> Bool { return UserDefaults.standard.object(forKey: kUsernameKey) != nil }
let joinedString = ["1", "2", "3", "4", "5"].joined(separator: ", ")
let joinedString = ["1", "2", "3", "4", "5"].joinWithSeparator(", ")
let joinedString = ", ".join(["1", "2", "3", "4", "5"])
let joinedString = join(", ", ["1", "2", "3", "4", "5"])
var nsarr = ["a", "b", "c"] as NSArray var str = nsarr.componentsJoinedByString(",")
func myFunc(param1 param1:String, param2:String, param3:String) {}
func myFunc2(param1:String, _ param2:String, _ param3:String) {}
func myFunc(name:String, _ age:String){ } myFunc(‚ÄúMilo", "I
var myLazyString = ResettableLazy<String?>() { print("Initializer side-effect") return nil } print(myLazyString.value) print(myLazyString.value) myLazyString.value = "Overwritten" print(myLazyString.value) myLazyString.clear() print(myLazyString.value)
struct ClearableLazy<T> { private var t: T! private var constructor: () -> T init(_ constructor: () -> T) { self.constructor = constructor } mutating func get() -> T { if t == nil { t = constructor() } return t } mutating func clear() { t = nil } }
platform :ios, use_frameworks! target pod pod pod end
framework module MODULE_NAME_HERE { umbrella header "MODULE_NAME_HERE.h" export * module * { export * } link framework LINKED_FRAMEWORKS_AND_LIBRARIES_THE_POD_NEEDS_HERE link framework "AdSupport" link "c++" link "z" }
@objc private func doubleTapGestureRecognized(recognizer: UITapGestureRecognizer)
DistributedNotificationCenter.default.addObserver(self, selector: name: someNotification, object: nil)
@objc private dynamic var originalProperty: String @objc private static let keyPathsForValuesAffectingDependentProperty: Set<String> = [ ] @objc public var dependentProperty: String { return changeItSomehow(self.originalProperty) }
if let url = NSURL(string: "https: let task = NSURLSession.sharedSession().dataTaskWithURL(url) { (data, response, error) in var jsonError: NSError? let jsonDict = NSJSONSerialization.JSONObjectWithData(data, options: nil, error: &jsonError) as [String: AnyObject] if jsonError != nil { return } } task.resume() }
extension NSURLSession { func synchronousDataTaskWithURL(url: NSURL) -> (NSData?, NSURLResponse?, NSError?) { var data: NSData?, response: NSURLResponse?, error: NSError? let semaphore = dispatch_semaphore_create(0) dataTaskWithURL(url) { data = $0; response = $1; error = $2 dispatch_semaphore_signal(semaphore) }.resume() dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) return (data, response, error) } }
extension URLSession { func synchronousDataTask(with url: URL) -> (Data?, URLResponse?, Error?) { var data: Data? var response: URLResponse? var error: Error? let semaphore = DispatchSemaphore(value: 0) let dataTask = self.dataTask(with: url) { data = $0 response = $1 error = $2 semaphore.signal() } dataTask.resume() _ = semaphore.wait(timeout: .distantFuture) return (data, response, error) } }
+ (NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(__autoreleasing NSURLResponse **)responsePtr error:(__autoreleasing NSError **)errorPtr { dispatch_semaphore_t sem; __block NSData * result; result = nil; sem = dispatch_semaphore_create(0); [[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { if (errorPtr != NULL) { *errorPtr = error; } if (responsePtr != NULL) { *responsePtr = response; } if (error == nil) { result = data; } dispatch_semaphore_signal(sem); }] resume]; dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); return result; }
extension URLSession { func synchronousDataTask(urlrequest: URLRequest) -> (data: Data?, response: URLResponse?, error: Error?) { var data: Data? var response: URLResponse? var error: Error? let semaphore = DispatchSemaphore(value: 0) let dataTask = self.dataTask(with: urlrequest) { data = $0 response = $1 error = $2 semaphore.signal() } dataTask.resume() _ = semaphore.wait(timeout: .distantFuture) return (data, response, error) } }
var request = URLRequest(url: url1) request.httpBody = body request.httpMethod = "PUT" let (_, _, error) = URLSession.shared.synchronousDataTask(urlrequest: request) if let error = error { print("Synchronous task ended with error: \(error)") } else { print("Synchronous task ended without errors.") }
func synchronousRequest() -> NSDictionary { let url: NSURL! = NSURL(string: "exampledomain/...") var request = NSMutableURLRequest(URL: url) request.HTTPMethod = "GET" request.addValue("application/json", forHTTPHeaderField: "Content-Type") var error: NSError? var response: NSURLResponse? let urlData = NSURLConnection.sendSynchronousRequest(request, returningResponse: &response, error: &error) error = nil let resultDictionary: NSDictionary = NSJSONSerialization.JSONObjectWithData(urlData!, options: NSJSONReadingOptions.MutableContainers, error: &error) as! NSDictionary return resultDictionary }
class MyClass: CustomStringConvertible { var val = 17 public var description: String { return "MyClass: \(val)" } } let myobj = MyClass() myobj.val = 12 print(myobj)
public override var description: String { return "\n{\n index: \(self.index),\n" + " country: \(self.name),\n" + " isoCountryCode: \(self.isoCountryCode),\n" + " localeId: \(self.localeId),\n" + " flagImageName: \(self.flagImageName!)\n}" }
public class MyClass: NSObject { public var memberAttribute = "I public override var description: String { return "My Class member: \(self.memberAttribute)" } }
class ImplementProtocolA <P : ProtocolA> { let currentProtocol : P init(currentProtocol : P) { self.currentProtocol = currentProtocol } }
class ImplementProtocolB : ImplementProtocolA<ProtocolB> { }
protocol View { } protocol GetUserView : View { func showProgress() func hideProgress() func showError(message:String) func showUser(userDemo:UserDemo) }
protocol Presenter { typealias V : View } class UserDemoPresenter : Presenter { typealias V = GetUserView }
class UserDemoPresenter : Presenter { typealias V = View }
private var presenter : UserDemoPresenter<GetUserView>
func isEmpty(xs: Array) -> Bool { return xs.count == 0 }
func isEmpty<T>(xs: [T]) -> Bool { return xs.count == 0 }
class ImplementProtocolB : ImplementProtocolA<ProtocolB>
class ImplementProtocolB<T: ProtocolB> : ImplementProtocolA<T> {}
class UserDemoPresenter<T: GetUserView> : Presenter { typealias V = T }
private var presenter : UserDemoPresenter<GetUserView>
final class Something<T: GetUserView> { private var presenter: UserDemoPresenter<T> }
source use_frameworks! target pod "FBSDKCoreKit" pod pod end target end
platform :ios, target use_frameworks! pod pod pod pod pod target inherit! :search_paths end target inherit! :search_paths end target inherit! :search_paths end target inherit! :search_paths end end
Key : Privacy - Camera Usage Description Value : $(PRODUCT_NAME) camera use
Key : Privacy - Photo Library Usage Description Value : $(PRODUCT_NAME) photo use
AVCaptureDevice.requestAccess(for: AVMediaType.video) { response in if response { } else { } } let photos = PHPhotoLibrary.authorizationStatus() if photos == .notDetermined { PHPhotoLibrary.requestAuthorization({status in if status == .authorized{ ... } else {} }) }
<key>NSCameraUsageDescription</key> <string>You can take photos to document your job.</string>
<key>NSPhotoLibraryUsageDescription</key> <string>You can select photos to attach to reports.</string>
<key>NSCameraUsageDescription</key> <string>camera description.</string>
<key>NSPhotoLibraryUsageDescription</key> <string> photos description.</string>
<key>NSPhotoLibraryAddUsageDescription</key> <string> photos add description.</string>
<key> NSLocationWhenInUseUsageDescription</key> <string> location description.</string>
<key>NSAppleMusicUsageDescription</key> <string>My description about why I need this capability</string>
<key>NSCalendarsUsageDescription</key> <string>My description about why I need this capability</string>
<key>NSSiriUsageDescription</key> <string>My description about why I need this capability</string>
func proceedWithCameraAccess(identifier: String){ AVCaptureDevice.requestAccess(for: .video) { success in if success { DispatchQueue.main.async { self.performSegue(withIdentifier: identifier, sender: nil) } } else { let alert = UIAlertController(title: "Camera", message: "Camera access is absolutely necessary to use this app", preferredStyle: .alert) alert.addAction(UIAlertAction(title: "OK", style: .default, handler: { action in UIApplication.shared.open(URL(string: UIApplicationOpenSettingsURLString)!) })) self.present(alert, animated: true) } } }
PHPhotoLibrary.requestAuthorization({ (newStatus) in if newStatus == PHAuthorizationStatus.authorized { } })
NSDictionary *dictionary = @{@"A" : @"alfa", @"B" : @"bravo", @"C" : @"charlie", @"D" : @"delta", @"E" : @"echo", @"F" : @"foxtrot"}; NSLog(@"%@", dictionary.description);
{ A = alfa; B = bravo; C = charlie; D = delta; E = echo; F = foxtrot; }
let dictionary: [String : String] = ["A" : "alfa", "B" : "bravo", "C" : "charlie", "D" : "delta", "E" : "echo", "F" : "foxtrot"]; print(dictionary)
["B": "bravo", "A": "alfa", "F": "foxtrot", "C": "charlie", "D": "delta", "E": "echo"]
let dictionary: [String : String] = ["A" : "alfa", "B" : "bravo", "C" : "charlie", "D" : "delta", "E" : "echo", "F" : "foxtrot"] dump(dictionary)
let names = ["Joe", "Jane", "Jim", "Joyce"] dump(names)
let attributes = ["foo": 10, "bar": 33, "baz": 42] dump(attributes)
let dictionary = ["a":"b", "c":"d", "e":"f"] print("This is the console output: \(dictionary as AnyObject)")
B: bravo A: alfa F: foxtrot C: charlie D: delta E: echo
public extension Collection { func json() -> String { do { let jsonData = try JSONSerialization.data(withJSONObject: self, options: [.prettyPrinted]) guard let jsonString = String(data: jsonData, encoding: String.Encoding.utf8) else { print("Can return "{}" } return jsonString } catch let parseError { print("json serialization error: \(parseError)") return "{}" } } }
print("\nHTTP request: \(URL)\nParams: \(params.json())\n")
HTTP request: https: Params: { "lon" : 10.8663676, "radius" : 111131.8046875, "lat" : 23.8063882, "index_start" : 0, "uid" : 1 }
let jsonData = try! JSONSerialization.data(withJSONObject: parameters, options: .prettyPrinted) if let jsonString = String(data: jsonData, encoding: .utf8) { print(jsonString) }
{ "jsonData": [ "Some String" ], "moreJSONData": "Another String", "evenMoreJSONData": { "A final String": "awd" } }
for (key,value) in dictionary { print("\(key) = \(value)") }
extension Dictionary where Key: CustomDebugStringConvertible, Value:CustomDebugStringConvertible { var prettyprint : String { for (key,value) in self { print("\(key) = \(value)") } return self.description } }
extension Dictionary where Key: CustomDebugStringConvertible, Value:CustomDebugStringConvertible { func prettyPrint(){ for (key,value) in self { print("\(key) = \(value)") } } }
A = alfa B = bravo C = charlie D = delta E = echo F = foxtrot
extension Dictionary where Key: ExpressibleByStringLiteral, Value: Any { var prettyPrint: String { return String(describing: self as AnyObject) } }
import Foundation extension Dictionary { var myDesc: String { get { var v = "" for (key, value) in self { v += ("\(key) = \(value)\n") } return v } } } print(dictionary.myDesc)
extension String { var conslePrintString: String { guard let data = "\"" .appending( replacingOccurrences(of: "\\u", with: "\\U") .replacingOccurrences(of: "\"", with: "\\\"") ) .appending("\"") .data(using: .utf8) else { return self } guard let propertyList = try? PropertyListSerialization.propertyList(from: data, options: [], format: nil) else { return self } guard let string = propertyList as? String else { return self } return string.replacingOccurrences(of: "\\r\\n", with: "\n") } } let code in extension String and it works fine let string = "\(jsonDictionary)".conslePrintString
cell.textLabel?.text = item.title?.uppercaseString cell.detailTextLabel?.text = item.itemDescription
extension Data { var html2AttributedString: NSAttributedString? { do { return try NSAttributedString(data: self, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil) } catch { print("error:", error) return nil } } var html2String: String { return html2AttributedString?.string ?? "" } } extension String { var html2AttributedString: NSAttributedString? { return Data(utf8).html2AttributedString } var html2String: String { return html2AttributedString?.string ?? "" } }
extension String { var html2AttributedString: NSAttributedString? { do { return try NSAttributedString(data: Data(utf8), options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue], documentAttributes: nil) } catch { print("error:", error) return nil } } var html2String: String { return html2AttributedString?.string ?? "" } }
cell.detailTextLabel?.text = item.itemDescription.html2String
func decodeString(encodedString:String) -> NSAttributedString? { let encodedData = encodedString.dataUsingEncoding(NSUTF8StringEncoding)! do { return try NSAttributedString(data: encodedData, options: [NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType,NSCharacterEncodingDocumentAttribute:NSUTF8StringEncoding], documentAttributes: nil) } catch let error as NSError { print(error.localizedDescription) return nil } }
let attributedString = self.decodeString(encodedString) let message = attributedString.string
extension String { var utfData: Data { return Data(utf8) } var attributedHtmlString: NSAttributedString? { do { return try NSAttributedString(data: utfData, options: [ .documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue ], documentAttributes: nil) } catch { print("Error:", error) return nil } } } extension UILabel { func setAttributedHtmlText(_ html: String) { if let attributedText = html.attributedHtmlString { self.attributedText = attributedText } } }
var attrStr = NSAttributedString( data: item.itemDescription.dataUsingEncoding(NSUnicodeStringEncoding, allowLossyConversion: true), options: [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType], documentAttributes: nil, error: nil) cell.detailTextLabel?.text = attrStr
extension String{ func convertHtml() -> NSAttributedString{ guard let data = data(using: .utf8) else { return NSAttributedString() } do{ return try NSAttributedString(data: data, options: [NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue], documentAttributes: nil) }catch{ return NSAttributedString() } } }
self.lblValDesc.attributedText = str_postdescription.convertHtml()
static func htmlToText(encodedString:String) -> String? { let encodedData = encodedString.dataUsingEncoding(NSUTF8StringEncoding)! do { return try NSAttributedString(data: encodedData, options: [NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType,NSCharacterEncodingDocumentAttribute:NSUTF8StringEncoding], documentAttributes: nil).string } catch let error as NSError { print(error.localizedDescription) return nil } }
let content = givenString let attrStr = try! NSAttributedString(data: content.data(using: String.Encoding.unicode, allowLossyConversion: true)!,options: [ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType],documentAttributes: nil) self.labelName.attributedText = attrStr
import Darwin let fmax = FLT_MAX let dmax = DBL_MAX
let d = DBL_MAX let e = d - 1.0 let diff = d - e diff == 0.0 let maxPlusOne = DBL_MAX + 1 maxPlusOne == d let inf = DBL_MAX * 2 inf == Double.infinity
CGFloat.greatestFiniteMagnitude Double.greatestFiniteMagnitude Float.greatestFiniteMagnitude
extension Double { static var MIN = -DBL_MAX static var MAX_NEG = -DBL_MIN static var MIN_POS = DBL_MIN static var MAX = DBL_MAX }
UIApplication.sharedApplication().applicationIconBadgeNumber = 0
UIApplication.shared.applicationIconBadgeNumber = 0
tblname.beginUpdates() tblname.insertRowsAtIndexPaths([ NSIndexPath(forRow: Yourarray.count-1, inSection: 0)], withRowAnimation: .Automatic) tblname.endUpdates()
tableView.beginUpdates() tableView.insertRows(at: [IndexPath(row: yourArray.count-1, section: 0)], with: .automatic) tableView.endUpdates()
[self.tblname beginUpdates]; NSArray *arr = [NSArray arrayWithObject:[NSIndexPath indexPathForRow:Yourarray.count-1 inSection:0]]; [self.tblname insertRowsAtIndexPaths:arr withRowAnimation:UITableViewRowAnimationAutomatic]; [self.tblname endUpdates];
import UIKit class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { @IBOutlet weak var table1Text: UITextField! @IBOutlet weak var table2Text: UITextField! @IBOutlet weak var table1: UITableView! @IBOutlet weak var table2: UITableView! var table1Data = ["a"] var table2Data = ["1"] override func viewDidLoad() { super.viewDidLoad() } @IBAction func addData(sender: AnyObject) { table1Data.append(table1Text.text) table2Data.append(table2Text.text) dispatch_async(dispatch_get_main_queue(), { () -> Void in self.table1.reloadData() self.table2.reloadData() }) table1Text.resignFirstResponder() table2Text.resignFirstResponder() } func numberOfSectionsInTableView(tableView: UITableView) -> Int { return 1 } func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { if tableView == table1 { return table1Data.count }else if tableView == table2 { return table2Data.count } return Int() } func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { if tableView == table1 { let cell = table1.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as! UITableViewCell let row = indexPath.row cell.textLabel?.text = table1Data[row] return cell }else if tableView == table2 { let cell = table2.dequeueReusableCellWithIdentifier("Cell1", forIndexPath: indexPath) as! UITableViewCell let row = indexPath.row cell.textLabel?.text = table2Data[row] return cell } return UITableViewCell() } }
self.yourArray.append(msg) self.tblView.beginUpdates() self.tblView.insertRows(at: [IndexPath.init(row: self.yourArray.count-1, section: 0)], with: .automatic) self.tblView.endUpdates()
self.yourArray.insert(msg, at: 0) self.tblView.beginUpdates() self.tblView.insertRows(at: [IndexPath.init(row: 0, section: 0)], with: .automatic) self.tblView.endUpdates()
var testVC: ViewControllerB = ViewControllerB(); override func viewDidLoad() { super.viewDidLoad() self.testVC.view.frame = CGRectMake(0, 0, 350, 450); self.view.addSubview(testVC.view); }
@IBOutlet weak var test: UILabel! override func viewDidLoad() { super.viewDidLoad() test.text = "Success" }
let controller = storyboard!.instantiateViewController(withIdentifier: "scene storyboard id")
let controller = storyboard.instantiateViewController(withIdentifier: "scene storyboard id") addChildViewController(controller) controller.view.frame = ... view.addSubview(controller.view) controller.didMove(toParentViewController: self)
let controller:MyView = self.storyboard!.instantiateViewControllerWithIdentifier("MyView") as! MyView controller.ANYPROPERTY=THEVALUE controller.view.frame = self.view.bounds; controller.willMoveToParentViewController(self) self.view.addSubview(controller.view) self.addChildViewController(controller) controller.didMoveToParentViewController(self)
self.willMoveToParentViewController(nil) self.view.removeFromSuperview() self.removeFromParentViewController()
if(!isOpen) { isOpen = true let menuVC : MenuViewController = self.storyboard!.instantiateViewController(withIdentifier: "menu") as! MenuViewController self.view.addSubview(menuVC.view) self.addChildViewController(menuVC) menuVC.view.layoutIfNeeded() menuVC.view.frame=CGRect(x: 0 - UIScreen.main.bounds.size.width, y: 0, width: UIScreen.main.bounds.size.width-90, height: UIScreen.main.bounds.size.height); UIView.animate(withDuration: 0.3, animations: { () -> Void in menuVC.view.frame=CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width-90, height: UIScreen.main.bounds.size.height); }, completion:nil) }else if(isOpen) { isOpen = false let viewMenuBack : UIView = view.subviews.last! UIView.animate(withDuration: 0.3, animations: { () -> Void in var frameMenu : CGRect = viewMenuBack.frame frameMenu.origin.x = -1 * UIScreen.main.bounds.size.width viewMenuBack.frame = frameMenu viewMenuBack.layoutIfNeeded() viewMenuBack.backgroundColor = UIColor.clear }, completion: { (finished) -> Void in viewMenuBack.removeFromSuperview() }) }
let controller:WalletView = self.storyboard!.instantiateViewController(withIdentifier: "MyView") as! WalletView controller.view.frame = self.view.bounds; controller.willMove(toParent: self) self.view.addSubview(controller.view) self.addChild(controller) controller.didMove(toParent: self)
func cycleFromViewController(oldVC: UIViewController, newVC: UIViewController) { oldVC.willMove(toParentViewController: nil) addChildViewController(newVC) newVC.view.frame = view.frame.offsetBy(dx: view.frame.width, dy: 0) let endFrame = view.frame.offsetBy(dx: -view.frame.width, dy: 0) self.transition(from: oldVC, to: newVC, duration: 0.25, animations: { newVC.view.frame = oldVC.view.frame oldVC.view.frame = endFrame }) { (_: Bool) in oldVC.removeFromParentViewController() newVC.didMove(toParentViewController: self) } }
extension String { func toBool() -> Bool? { switch self { case "True", "true", "yes", "1": return true case "False", "false", "no", "0": return false default: return nil } } }
var aString = NSString(string: "tRue") var b = aString.boolValue
dispatch_async(dispatch_queue_create("com.haduyenhoa.test", nil), { self.test1() self.test2() }) func test1() { let testTrue: String = "TRue" let testFalse: String = "faLse" let testNil: String = "whoops!" let begin : NSDate = NSDate() NSLog("BEGIN native") var testTrueObjC: NSString var testFalseObjC : NSString var testNilObjC:NSString for index in 1...100000 { testTrueObjC = NSString(string:testTrue) testFalseObjC = NSString(string:testFalse) testNilObjC = NSString(string:testNil) var b1 = testTrueObjC.boolValue var b2 = testFalseObjC.boolValue var b3 = testNilObjC.boolValue } let end : NSDate = NSDate() let interval = end.timeIntervalSinceDate(begin) NSLog("DURATION native: \(interval)") } func test2() { let testTrue: String = "TRue" let testFalse: String = "faLse" let testNil: String = "whoops!" let begin : NSDate = NSDate() NSLog("BEGIN extension") for index in 1...100000 { var b1 = testTrue.boolValue() var b2 = testFalse.boolValue() var b3 = testNil.boolValue() } let end : NSDate = NSDate() let interval = end.timeIntervalSinceDate(begin) NSLog("DURATION extension: \(interval)") }
2015-03-12 14:16:23.238 testSwift3[2343:298787] BEGIN native 2015-03-12 14:16:23.543 testSwift3[2343:298787] DURATION native: 0.305041968822479 2015-03-12 14:16:23.543 testSwift3[2343:298787] BEGIN extension 2015-03-12 14:16:35.360 testSwift3[2343:298787] DURATION extension: 11.8166469931602
extension String { var boolValue: Bool { return NSString(string: self).boolValue }}
self.boolType = NSString(string:stringType!).boolValue
extension String { func boolValue() -> Bool? { let trueValues = ["true", "yes", "1"] let falseValues = ["false", "no", "0"] let lowerSelf = self.lowercaseString if contains(trueValues, lowerSelf) { return true } else if contains(falseValues, lowerSelf) { return false } else { return nil } } } let testTrue: String = "TRue" testTrue.boolValue() let testFalse: String = "faLse" testFalse.boolValue() let testNil: String = "whoops!" testNil.boolValue()
let nsString = NSString(string: "tFalse") nsString.boolValue
var st = "false" extension String { func toBool() -> Bool{ if self == "false" { return false }else{ return true } } } if st.toBool() == false { println("its ok") }
extension String { func boolValueFromString() -> Bool { return NSString(string: self).boolValue } }
if (dictCardData.value(forKey: "isadmin") as! String).boolValueFromString() { }
extension String { var bool: Bool? { let lowercaseSelf = self.lowercased() switch lowercaseSelf { case "true", "yes", "1": return true case "false", "no", "0": return false default: return nil } } }
let trueBoolString = "TRUE" print(trueBoolString.bool)
extension Bool { init(_ string: String?) { guard let string = string else { self = false; return } switch string.lowercased() { case "true", "yes", "1": self = true default: self = false } } }
let value:String? = "put some string or even just nil here" let trueOrFalse = NSString(string: value ?? "").boolValue
extension Bool { init?(string: String) { switch string { case "True", "true", "yes", "1": self = true case "False", "false", "no", "0": self = false default: return nil } } } let one = Bool(string: "SDASD") let two = Bool(string: "0") let three = Bool(string: "true") let four = Bool(string: "null")
let str:String = "1" var boo:Bool = str == "1" || str == "true" || str == "True" || str == "yes"
extension String { var boolValue: Bool { return (self as NSString).boolValue } }
NSNumberFormatter *f = [[NSNumberFormatter alloc] init]; f.numberStyle = NSNumberFormatterDecimalStyle; NSNumber *myNumber = [f numberFromString:@"42222222222"];
let someString = "42222222222" if let myInteger = Int(someString) { let myNumber = NSNumber(value:myInteger) }
let someString = "42222222222" if let myInteger = Int(someString) { let myNumber = NSNumber(integer:myInteger) print(myNumber) } else { print(" }
let someString = "42222222222" if let myInteger = someString.toInt() { let myNumber = NSNumber(integer:myInteger) println(myNumber) } else { println(" }
NSNumberFormatter().numberFromString("55")!.decimalValue
let formatter = NSNumberFormatter() formatter.numberStyle = NSNumberFormatterStyle.DecimalStyle; if let number = formatter.numberFromString("42") { println(number) }
extension String { var numberValue: NSNumber? { if let value = Int(self) { return NSNumber(value: value) } return nil } }
if let _ = stringVariable, let intValue = Int(stringVariable!) { doSomething(NSNumber.init(value: intValue)) }
let myString = "123" let myInt = (myString as NSString).integerValue
func myFunction() { var a: Int? DispatchQueue.main.async { var b: Int = 3 a = b } print(a) }
func myFunction() { var a: Int? let group = DispatchGroup() group.enter() DispatchQueue.main.async { a = 1 group.leave() } group.notify(queue: .main) { print(a) } }
func myFunction() -> Int? { var a: Int? let group = DispatchGroup() group.enter() DispatchQueue.global(attributes: .qosDefault).async { a = 1 group.leave() } group.wait() return a }
var a: Int? let queue = DispatchQueue(label: "com.app.queue") queue.sync { for i in 0..<10 { print("‚ìÇÔ∏è" , i) a = i } } print("After Queue \(a)")
let myGroup = DispatchGroup() myGroup.enter() myGroup.leave() myGroup.notify(queue: DispatchQueue.main) { }
let workItem = DispatchWorkItem { } let queue = DispatchQueue.global() queue.async { workItem.perform() } workItem.notify(queue: DispatchQueue.main) { }
dispatchGroup.enter() FirstOperation(completion: { _ in dispatchGroup.leave() }) dispatchGroup.enter() SecondOperation(completion: { _ in dispatchGroup.leave() }) dispatchGroup.wait()
var a: Int? @objc func myFunction(completion:@escaping (Bool) -> () ) { DispatchQueue.main.async { let b: Int = 3 a = b completion(true) } } override func viewDidLoad() { super.viewDidLoad() myFunction { (status) in if status { print(self.a!) } } }
struct Program { let category : String let name : String } var programy = [Program]() self.programy = [Program(category: "Slovensk√©", name: "Mark√≠za"), Program(category: "Slovensk√©", name: "TV JOJ")]
class PlayerTableViewController: UITableViewController { var programVar : Program?
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) { var newProgramVar = Program(category: "Some", name: "Text") let destinationVC = segue.destinationViewController as PlayerTableViewController destinationVC.programVar = newProgramVar } }
override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { let selectedProgram = programy[indexPath.row] let destinationVC = PlayerTableViewController() destinationVC.programVar = selectedProgram destinationVC.performSegueWithIdentifier("playerSegue", sender: self) }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if (segue.identifier == "MainToTimer") { let vc = segue.destination as! YourViewController vc.var_name = "Your Data" } }
if let geocodingError = error as? NSError where geocodingError.code == 2
if let str = textField.text as String!, !str.isEmpty { params[key] = str TextFieldHelper.setup(textField: textField) } else { TextFieldHelper.error(textField: textField) }
let request = NSMutableURLRequest(URL: url) request.setValue(authorizationToken, forHTTPHeaderField:"Authorization")
enum Router: URLRequestConvertible { static let baseUrlString = "some url string" case Get(query: String) var URLRequest: NSMutableURLRequest { let (path: String, parameters: [String: AnyObject]?) = { switch self { case .Get(let query): return ("/get", ["q": query]) } }() let URL = NSURL(string: Router.baseUrlString)! let URLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path)) URLRequest.setValue("a", forHTTPHeaderField: "Authorization") let encoding = Alamofire.ParameterEncoding.URL return encoding.encode(URLRequest, parameters: parameters).0 } }
Manager.sharedInstance.request(Router.Get(query: "test"))
Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders = ["Authorization": authorizationToken]
let headers = [ "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==", "Content-Type": "application/x-www-form-urlencoded" ] Alamofire.request(.GET, "https: .responseJSON { response in debugPrint(response) }
let headers: HTTPHeaders = [ "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==", "Accept": "application/json" ] Alamofire.request("https: debugPrint(response) }
import Alamofire public class Service: NSObject { private class func request(method: Alamofire.Method, URLString: URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding = .URL, headers: [String: String]? = nil) -> Request { let (request, error) = encoding.encode(NSURLRequest(URL: NSURL(string: URLString.URLString)!), parameters: parameters) let mutableURLRequest = request as! NSMutableURLRequest mutableURLRequest.HTTPMethod = method.rawValue if let heads = headers { for (field, value) in heads { mutableURLRequest.setValue(value, forHTTPHeaderField: field) } } return Alamofire.request(mutableURLRequest) } }
Alamofire.Manager.sharedInstance.defaultHeaders.updateValue(authorizationToken, forKey: "Authorization")
Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders = headers
let URL = NSURL(string: request.url!) var mutableURLRequest = NSMutableURLRequest(URL: URL!) mutableURLRequest.HTTPMethod = Alamofire.Method.GET.rawValue var defaultHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:] let configuration = NSURLSessionConfiguration.defaultSessionConfiguration() configuration.HTTPAdditionalHeaders = defaultHeaders let manager = Alamofire.Manager(configuration: configuration) let urlReq = ParameterEncoding.URL.encode(mutableURLRequest, parameters: request.params).0 aReq = manager.request(urlReq) aReq!.responseJSON { (req, response, JSON, error) in }
let request = NSMutableURLRequest(URL: url) request.setValue(authorizationToken, forHTTPHeaderField:"Authorization") Alamofire.request(request) .responseJSON { (_, _, JSON, error) in }
import Foundation import Alamofire class APIManager { class func headers() -> HTTPHeaders { var headers: HTTPHeaders = [ "Content-Type": "application/json", "Accept": "application/json" ] if let authToken = UserDefaults.standard.string(forKey: "auth_token") { headers["Authorization"] = "Token" + " " + authToken } return headers } }
Alamofire.request(urlString, method: .get, headers:APIManager.headers())
let aManager = Manager.sharedInstance aManager.session.configuration.HTTPAdditionalHeaders = [ "Authorization": "Some authentication Token here" ] let URL = "some url string" request(.GET, URL, encoding: .JSON) .responseJSON { (request, response, data, error) -> Void in if(error != nil) { if let delegate = self.delegate { delegate.connectionDidFinishedErrorResponceForAction!(1, andWithResponse: nil) } println("\(error!.localizedDescription)") } else { if let delegate = self.delegate { delegate.connectionDidFinishedForAction!(1, andWithResponse: nil) } println("req:\(request) \n res:\(response) \n json:\(data!) \n \(error) ") } }
let url = "http:\your.url.string\" let parameter = ["Username":"name", "Password":"123"] let headers = ["Content-Type" : "application/json"] Alamofire.request(url, method : .post, parameters : parameter, encoding : JSONEncoding.default , headers : headers).responseData { dataResponse in print(dataResponse.request as Any) print(dataResponse.response as Any) }
import UIKit import QuartzCore @IBDesignable class Button : UIButton { @IBInspectable var masksToBounds: Bool = false {didSet{updateLayerProperties()}} @IBInspectable var cornerRadius : CGFloat = 0 {didSet{updateLayerProperties()}} @IBInspectable var borderWidth : CGFloat = 0 {didSet{updateLayerProperties()}} @IBInspectable var borderColor : UIColor = UIColor.clearColor() {didSet{updateLayerProperties()}} @IBInspectable var shadowColor : UIColor = UIColor.clearColor() {didSet{updateLayerProperties()}} @IBInspectable var shadowOpacity: CGFloat = 0 {didSet{updateLayerProperties()}} @IBInspectable var shadowRadius : CGFloat = 0 {didSet{updateLayerProperties()}} @IBInspectable var shadowOffset : CGSize = CGSizeMake(0, 0) {didSet{updateLayerProperties()}} override func drawRect(rect: CGRect) { updateLayerProperties() } func updateLayerProperties() { self.layer.masksToBounds = masksToBounds self.layer.cornerRadius = cornerRadius self.layer.borderWidth = borderWidth self.layer.borderColor = borderColor.CGColor self.layer.shadowColor = shadowColor.CGColor self.layer.shadowOpacity = CFloat(shadowOpacity) self.layer.shadowRadius = shadowRadius self.layer.shadowOffset = shadowOffset } }
import UIKit class CustomButton: UIButton { var shadowLayer: CAShapeLayer! override func layoutSubviews() { super.layoutSubviews() if shadowLayer == nil { shadowLayer = CAShapeLayer() shadowLayer.path = UIBezierPath(roundedRect: bounds, cornerRadius: 12).cgPath shadowLayer.fillColor = UIColor.white.cgColor shadowLayer.shadowColor = UIColor.darkGray.cgColor shadowLayer.shadowPath = shadowLayer.path shadowLayer.shadowOffset = CGSize(width: 2.0, height: 2.0) shadowLayer.shadowOpacity = 0.8 shadowLayer.shadowRadius = 2 layer.insertSublayer(shadowLayer, at: 0) } } }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let button = CustomButton(type: .system) button.setTitle("Button", for: .normal) view.addSubview(button) button.translatesAutoresizingMaskIntoConstraints = false let horizontalConstraint = button.centerXAnchor.constraint(equalTo: view.centerXAnchor) let verticalConstraint = button.centerYAnchor.constraint(equalTo: view.centerYAnchor) let widthConstraint = button.widthAnchor.constraint(equalToConstant: 100) let heightConstraint = button.heightAnchor.constraint(equalToConstant: 100) NSLayoutConstraint.activate([horizontalConstraint, verticalConstraint, widthConstraint, heightConstraint]) } }
@IBDesignable class CustomButton: UIButton { var shadowAdded: Bool = false @IBInspectable var cornerRadius: CGFloat = 0 { didSet { layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius > 0 } } override func drawRect(rect: CGRect) { super.drawRect(rect) if shadowAdded { return } shadowAdded = true let shadowLayer = UIView(frame: self.frame) shadowLayer.backgroundColor = UIColor.clearColor() shadowLayer.layer.shadowColor = UIColor.darkGrayColor().CGColor shadowLayer.layer.shadowPath = UIBezierPath(roundedRect: bounds, cornerRadius: self.cornerRadius).CGPath shadowLayer.layer.shadowOffset = CGSize(width: 1.0, height: 1.0) shadowLayer.layer.shadowOpacity = 0.5 shadowLayer.layer.shadowRadius = 1 shadowLayer.layer.masksToBounds = true shadowLayer.clipsToBounds = false self.superview?.addSubview(shadowLayer) self.superview?.bringSubviewToFront(self) } }
func getImageWithColor(color: UIColor, size: CGSize, cornerRadius:CGFloat) -> UIImage { let rect = CGRectMake(0, 0, size.width, size.height) UIGraphicsBeginImageContextWithOptions(size, false, 1) UIBezierPath( roundedRect: rect, cornerRadius: cornerRadius ).addClip() color.setFill() UIRectFill(rect) let image: UIImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } let button = UIButton(type: .Custom) button.frame = CGRectMake(20, 20, 200, 50) button.setTitle("My Button", forState: UIControlState.Normal) button.setTitleColor(UIColor.blackColor(), forState: UIControlState.Normal) self.addSubview(button) let image = getImageWithColor(UIColor.whiteColor(), size: button.frame.size, cornerRadius: 5) button.setBackgroundImage(image, forState: UIControlState.Normal) button.layer.shadowRadius = 5 button.layer.shadowColor = UIColor.blackColor().CGColor button.layer.shadowOpacity = 0.5 button.layer.shadowOffset = CGSizeMake(0, 1) button.layer.masksToBounds = false
func getImageWithColor(_ color: UIColor, size: CGSize, cornerRadius:CGFloat) -> UIImage? { let rect = CGRect(x: 0, y: 0, width: size.width, height: size.height) UIGraphicsBeginImageContextWithOptions(size, false, 0) color.setFill() UIBezierPath(roundedRect: rect, cornerRadius: cornerRadius).addClip() color.setFill() UIRectFill(rect) let image: UIImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() return image } let button = UIButton(type: .custom) button.frame = CGRect(x:20, y:20, width:200, height:50) button.setTitle("My Button", for: .normal) button.setTitleColor(UIColor.black, for: .normal) self.addSubview(button) if let image = getImageWithColor(UIColor.white, size: button.frame.size, cornerRadius: 5) { button.setBackgroundImage(image, for: .normal) } button.layer.shadowRadius = 5 button.layer.shadowColor = UIColor.black.cgColor button.layer.shadowOpacity = 0.5 button.layer.shadowOffset = CGSize(width:0, height:1) button.layer.masksToBounds = false
class RoundedButtonWithShadow: UIButton { override func awakeFromNib() { super.awakeFromNib() self.layer.masksToBounds = false self.layer.cornerRadius = self.frame.height/2 self.layer.shadowColor = UIColor.black.cgColor self.layer.shadowPath = UIBezierPath(roundedRect: self.bounds, cornerRadius: self.layer.cornerRadius).cgPath self.layer.shadowOffset = CGSize(width: 0.0, height: 3.0) self.layer.shadowOpacity = 0.5 self.layer.shadowRadius = 1.0 } }
override func viewDidLoad() { super.viewDidLoad() myButton.layer.masksToBounds = false myButton.layer.cornerRadius = myButton.frame.height/2 myButton.clipsToBounds = true } override func viewDidLayoutSubviews() { addShadowForRoundedButton(view: self.view, button: myButton, opacity: 0.5) } func addShadowForRoundedButton(view: UIView, button: UIButton, opacity: Float = 1) { let shadowView = UIView() shadowView.backgroundColor = UIColor.black shadowView.layer.opacity = opacity shadowView.layer.shadowRadius = 5 shadowView.layer.shadowOpacity = 0.35 shadowView.layer.shadowOffset = CGSize(width: 0, height: 0) shadowView.layer.cornerRadius = button.bounds.size.width / 2 shadowView.frame = CGRect(origin: CGPoint(x: button.frame.origin.x, y: button.frame.origin.y), size: CGSize(width: button.bounds.width, height: button.bounds.height)) self.view.addSubview(shadowView) view.bringSubview(toFront: button) }
func addShadowForRoundedButton(view: UIView, button: UIButton, shadowColor: UIColor, shadowOffset: CGSize, opacity: Float = 1) { let shadowView = UIView() shadowView.backgroundColor = shadowColor shadowView.layer.opacity = opacity shadowView.layer.cornerRadius = button.bounds.size.width / 2 shadowView.frame = CGRect(origin: CGPoint(x: button.frame.origin.x + shadowOffset.width, y: button.frame.origin.y + shadowOffset.height), size: CGSize(width: button.bouds.width, height: button.bounds.height)) self.view.addSubview(shadowView) view.bringSubview(toFront: button) }
override func viewDidLayoutSubviews() { addShadowForRoundedButton(view: self.view, button: button, shadowColor: .black, shadowOffset: CGSize(width: 2, height: 2), opacity: 0.5) }
class ViewWithRoundedcornersAndShadow: UIView { private var theShadowLayer: CAShapeLayer? override func layoutSubviews() { super.layoutSubviews() if self.theShadowLayer == nil { let rounding = CGFloat.init(22.0) let shadowLayer = CAShapeLayer.init() self.theShadowLayer = shadowLayer shadowLayer.path = UIBezierPath.init(roundedRect: bounds, cornerRadius: rounding).cgPath shadowLayer.fillColor = UIColor.clear.cgColor shadowLayer.shadowPath = shadowLayer.path shadowLayer.shadowColor = UIColor.black.cgColor shadowLayer.shadowRadius = CGFloat.init(3.0) shadowLayer.shadowOpacity = Float.init(0.2) shadowLayer.shadowOffset = CGSize.init(width: 0.0, height: 4.0) self.layer.insertSublayer(shadowLayer, at: 0) } } }
func shadowOnviewWithcornerRadius(YourView:UIView) { YourView.layer.shadowColor = UIColor.black.cgColor; YourView.layer.shadowOpacity = 0.5; YourView.layer.shadowRadius = 5; YourView.layer.shadowOffset = CGSize(width :0, height :0) YourView.layer.masksToBounds = false; YourView.layer.cornerRadius = 2.0; YourView.layer.borderWidth = 0.5; YourView.backgroundColor = UIColor.white; }
func hello_swift(_ name: String) { print("Hello \(name) in Swift") }
hello_c("World".cStringUsingEncoding(NSUTF8StringEncoding)) CPP_Wrapper().hello_cpp_wrapped("World") Objective_C().hello_objectiveC("World") Objective_CPP().hello_objectiveCpp("World") Swift().hello_swift("World")
var set = Set([1, 2, 3, 2, 1]) set.insert(4) set.insert(3) set.unionInPlace([ 4, 5, 6 ]) set.remove(2) set.subtractInPlace([ 6, 7 ]) print(set) if set.contains(5) { print("yes") }
var mySet: Dictionary<String, Boolean> = [:] mySet["something"]= 1
extension Array where Element: Hashable { var setValue: Set<Element> { return Set<Element>(self) } } let numbers = [1,2,3,4,5,6,7,8,9,0,0,9,8,7] let uniqueNumbers = numbers.setValue let names = ["John","Mary","Steve","Mary"] let uniqueNames = names.setValue
struct Set<T : Hashable> { var _items : Dictionary<T, Bool> = [:] mutating func add(newItem : T) { _items[newItem] = true } mutating func remove(newItem : T) { _items[newItem] = nil } func contains(item: T) -> Bool { if _items.indexForKey(item) != nil { return true } else { return false } } var items : [T] { get { return [T](_items.keys) } } var count : Int { get { return _items.count } } }
class Set<T : Equatable> { var items : T[] = [] func add(item : T) { if !contains(items, {$0 == item}) { items += item } } }
@assignment @infix func += <T : Equatable> (inout set : Set<T>, items : T[]) -> Set<T> { for item in items { set.add(item) } return set }
class Set<T: Equatable> { var items = Array<T>() func hasItem (that: T) { for this: T in items { if (this == that) { return true } } return false } func insert (that: T) { if (!hasItem (that)) items.append (that) } }
public func removeDuplicates<C: ExtensibleCollectionType where C.Generator.Element : Equatable>(aCollection: C) -> C { var container = C() for element in aCollection { if !contains(container, element) { container.append(element) } } return container }
@IBOutlet weak var passwordTextField: UITextField! let userIdTextField = UITextField() override func viewDidLoad() { super.viewDidLoad() self.passwordTextField.keyboardType = .NumberPad if getCurrentUserId() == nil { self.view.addSubview(userIdTextField) userIdTextField.setTranslatesAutoresizingMaskIntoConstraints(false) self.view.addConstraints([userIdTextField.al_leading == passwordTextField.al_leading, userIdTextField.al_trailing == passwordTextField.al_trailing, userIdTextField.al_top == passwordTextField.al_bottom + 8]) userIdTextField.placeholder = "Enter User Id..." } }
if passwordTextField.textContentType = .oneTimeCode } else { emailTextField.textContentType = .init(rawValue: "") passwordTextField.textContentType = .init(rawValue: "") }
extension UITextContentType { public static let unspecified = UITextContentType("unspecified") }
usernametextfield.textContentType = UITextContentType("") passwordtextfield.textContentType = UITextContentType("")
if passwordText.textContentType = UITextContentType("") emailText.textContentType = UITextContentType("") }
@objc func textFieldDidChange(_ textField: UITextField) { if textField.text!.count > 1 { if passwordValue.count == 0 { passwordValue = String(textField.text!) } else { passwordValue += textField.text!.substring(from: passwordValue.count) } } else { if textField.text!.count > passwordValue.count { passwordValue += String(textField.text!.last!) } else if textField.text!.count < passwordValue.count { passwordValue = String(passwordValue.dropLast()) } } self.passwordText.text = String(repeating: "‚Ä¢", count: self.passwordText.text!.count) }
if (@available(iOS 10, *)){ self.tfEmail.textContentType = @""; self.tfPassword.textContentType = @""; }
if self.textField.textContentType = UITextContentType("") } else { }
if (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@"10.0")) { self.passwordTextField.textContentType = @""; self.confirmPasswordTextField.textContentType = @""; }
passwordFormField.textContentType = UITextContentType("dummy")
self.passwordTextField.textContentType = UITextContentTypeName;
if (@available(iOS 10, *)) { passwordTextField.textContentType = UITextContentTypeStreetAddressLine2; } if (@available(iOS 12, *)) { passwordTextField.textContentType = UITextContentTypeOneTimeCode; }
import Foundation import UIKit import LayerKit import Atlas < red line import Foundation import UIKit import Atlas import LayerKit
let objCreateEventVC = CreateEventVC() objCreateEventVC.hidesBottomBarWhenPushed = true self.navigationController?.pushViewController(objCreateEventVC, animated: false)
let backButton = UIBarButtonItem(title: "", style: UIBarButtonItemStyle.Plain, target: navigationController, action: nil) navigationItem.leftBarButtonItem = backButton
navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: nil, action: nil)
- (void)viewWillDisappear:(BOOL)animated [super viewWillDisappear:animated]; self.navigationItem.backBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"" style:self.navigationItem.backBarButtonItem.style target:nil action:nil]; }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: nil, action: nil) }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(true) self.navigationItem.title = " " } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) self.navigationItem.title = "My Title" }
let BarButtonItemAppearance = UIBarButtonItem.appearance() BarButtonItemAppearance.setTitleTextAttributes([.foregroundColor: UIColor.clear], for: .normal)
let imgBack = UIImage(named: "ic_back") navigationController?.navigationBar.backIndicatorImage = imgBack navigationController?.navigationBar.backIndicatorTransitionMaskImage = imgBack navigationItem.leftItemsSupplementBackButton = true navigationController?.navigationBar.topItem?.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: self, action: nil)
UIBarButtonItem.appearance().setBackButtonBackgroundImage(
let BarButtonItemAppearance = UIBarButtonItem.appearance() BarButtonItemAppearance.setTitleTextAttributes([NSAttributedStringKey.foregroundColor: UIColor.clear], for: .normal) BarButtonItemAppearance.setBackButtonTitlePositionAdjustment(UIOffsetMake(-200, 0), for:UIBarMetrics.default)
let backItem = UIBarButtonItem() backItem.title = " " navigationItem.backBarButtonItem = backItem let controllerB = ViewControllerB() navigationController?.pushViewController(controllerB, animated: true)
self.navigationController?.navigationBar.topItem?.title = ""
let button: UIButton = UIButton (type: UIButtonType.Custom) button.setImage(UIImage(named: "imageName"), forState: UIControlState.Normal) button.addTarget(self, action: "backButtonPressed:", forControlEvents: UIControlEvents.TouchUpInside) button.frame = CGRectMake(0, 0, 30, 30) let barButton = UIBarButtonItem(customView: button) self.navigationItem.leftBarButtonItem = barButton func backButtonPressed(btn : UIButton) { }
override func show(_ vc: UIViewController, sender: Any?) { setEmptyBackButton(vc) super.show(vc, sender: sender) } override func pushViewController(_ viewController: UIViewController, animated: Bool) { setEmptyBackButton(viewController) super.pushViewController(viewController, animated: animated) } func setEmptyBackButton(_ viewController: UIViewController) { viewController.navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: nil, action: nil) }
let barButtonItemAppearance = UIBarButtonItem.appearance() barButtonItemAppearance.setTitleTextAttributes([NSAttributedStringKey.foregroundColor: UIColor.clear], for: .normal) barButtonItemAppearance.setBackButtonTitlePositionAdjustment(UIOffsetMake(-200, 0), for:UIBarMetrics.default)
navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: nil, action: nil)
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(true) self.navigationItem.title = " " } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) self.navigationItem.title = "my amazing title" navigationItem.backBarButtonItem = UIBarButtonItem(title: " ", style: .plain, target: nil, action: nil) }
if UIBarButtonItem.appearance().setTitleTextAttributes([NSAttributedStringKey.foregroundColor: UIColor.clear], for: .normal) UIBarButtonItem.appearance().setTitleTextAttributes([NSAttributedStringKey.foregroundColor: UIColor.clear], for: .highlighted) } else { UIBarButtonItem.appearance().setBackButtonTitlePositionAdjustment(UIOffsetMake(0, -60), for:UIBarMetrics.default) }
override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(true) navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: nil, action: nil) }
navigationController?.navigationBar.items?.last?.backBarButtonItem?.title = String() navigationController?.navigationBar.items?.last?.backBarButtonItem?.title = nil
override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) originalBackButtonTitle = navigationController?.navigationBar.items?.last?.backBarButtonItem?.title }
override func viewWillDisappear(_ animated: Bool) { navigationController?.navigationBar.items?.last?.backBarButtonItem?.title = originalBackButtonTitle super.viewWillDisappear(animated) }
extension UIViewController { open override func awakeFromNib() { navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: nil, action: nil) }}
yourHeightConstraintOutlet.constant = someValue yourView.layoutIfNeeded()
for constraint in self.view.constraints { if constraint.identifier == "myConstraint" { constraint.constant = 50 } } myView.layoutIfNeeded()
extension UIView { var heightConstaint: NSLayoutConstraint? { get { return constraints.filter { if $0.firstAttribute == .height, $0.relation == .equal { return true } return false }.first } set{ setNeedsLayout() } } var widthConstaint: NSLayoutConstraint? { get { return constraints.filter { if $0.firstAttribute == .width, $0.relation == .equal { return true } return false }.first } set{ setNeedsLayout() } } }
@IBOutlet myConstraint : NSLayoutConstraint! @IBOutlet myView : UIView! func updateConstraints() { DispatchQueue.main.async { myConstraint.constant = 10 myView.layoutIfNeeded() } }
@IBOutlet weak var select_dateHeight: NSLayoutConstraint!
@IBAction func Feedback_button(_ sender: Any) { self.select_dateHeight.constant = 0 }
Create an IBOutlet of NSLayoutConstraint of yourView and update the constant value accordingly the condition specifies. @IBOutlet viewHeight: NSLayoutConstraint! @IBOutlet view: UIView! private func updateViewHeight(height:Int){ guard let aView = view, aViewHeight = viewHeight else{ return } aViewHeight.constant = height aView.layoutIfNeeded() }
heightOrWidthConstraint.constant = 100 UIView.animate(withDuration: animateTime, animations:{ self.view.layoutIfNeeded() })
myConstraint.constant = newValue myView.layoutIfNeeded()
let logo = UIImage(named: "logo.png") self.navigationItem.titleView = logo;
let logo = UIImage(named: "logo.png") let imageView = UIImageView(image:logo) self.navigationItem.titleView = imageView
override func viewDidLoad() { super.viewDidLoad() let image = UIImage(named: "YOURIMAGE") navigationItem.titleView = UIImageView(image: image) }
override func viewDidLoad() { super.viewDidLoad() let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 38, height: 38)) imageView.contentMode = .ScaleAspectFit let image = UIImage(named: "YOURIMAGE") imageView.image = image navigationItem.titleView = imageView }
let logoContainer = UIView(frame: CGRect(x: 0, y: 0, width: 270, height: 30)) let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 270, height: 30)) imageView.contentMode = .scaleAspectFit let image = UIImage(named: "your_image") imageView.image = image logoContainer.addSubview(imageView) navigationItem.titleView = logoContainer
class FixedImageNavigationItem: UINavigationItem { private let fixedImage : UIImage = UIImage(named: "your-header-logo.png")! private let imageView : UIImageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 50, height: 37.5)) required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) imageView.contentMode = .scaleAspectFit imageView.image = fixedImage self.titleView = imageView } }
func addNavBarImage() { let navController = navigationController! let image = UIImage(named: "logo-signIn6.png") let imageView = UIImageView(image: image) let bannerWidth = navController.navigationBar.frame.size.width let bannerHeight = navController.navigationBar.frame.size.height let bannerX = bannerWidth / 2 - (image?.size.width)! / 2 let bannerY = bannerHeight / 2 - (image?.size.height)! / 2 imageView.frame = CGRect(x: bannerX, y: bannerY, width: bannerWidth, height: bannerHeight) imageView.contentMode = .scaleAspectFit navigationItem.titleView = imageView }
var nav = self.navigationController?.navigationBar nav?.barStyle = UIBarStyle.Black nav?.tintColor = UIColor.yellowColor() let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 40, height: 40)) imageView.contentMode = .ScaleAspectFit let image = UIImage(named: "logo.png") imageView.image = image navigationItem.titleView = imageView
let image = UIImage(named: "Navbar_bg.png") navigationItem.titleView = UIImageView(image: image) let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 40, height: 40)) imageView.contentMode = .ScaleAspectFit
class CustomTitleNavigationController: UINavigationController { override func viewDidLoad() { super.viewDidLoad() let logo = UIImage(named: "MyHeaderImage") let imageView = UIImageView(image:logo) imageView.contentMode = .scaleAspectFit imageView.translatesAutoresizingMaskIntoConstraints = false navigationBar.addSubview(imageView) navigationBar.addConstraint (navigationBar.leftAnchor.constraint(equalTo: imageView.leftAnchor, constant: 0)) navigationBar.addConstraint (navigationBar.rightAnchor.constraint(equalTo: imageView.rightAnchor, constant: 0)) navigationBar.addConstraint (navigationBar.topAnchor.constraint(equalTo: imageView.topAnchor, constant: 0)) navigationBar.addConstraint (navigationBar.bottomAnchor.constraint(equalTo: imageView.bottomAnchor, constant: 0)) }
extension UINavigationBar { func setupNavigationBar() { let titleImageWidth = frame.size.width * 0.32 let titleImageHeight = frame.size.height * 0.64 var navigationBarIconimageView = UIImageView() if navigationBarIconimageView.widthAnchor.constraint(equalToConstant: titleImageWidth).isActive = true navigationBarIconimageView.heightAnchor.constraint(equalToConstant: titleImageHeight).isActive = true } else { navigationBarIconimageView = UIImageView(frame: CGRect(x: 0, y: 0, width: titleImageWidth, height: titleImageHeight)) } navigationBarIconimageView.contentMode = .scaleAspectFit navigationBarIconimageView.image = UIImage(named: "image") topItem?.titleView = navigationBarIconimageView } }
let imageView = UIImageView() imageView.frame.size.width = 40 imageView.frame.size.height = 40 imageView.contentMode = .scaleAspectFit let image = UIImage(named: "YOUR_IMAGE_NAME") imageView.image = image navigationItem.titleView = imageView
let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 50, height: 100.5))) imageView.contentMode = .scaleAspectFit let image = UIImage(named: "YOUR_IMAGE_NAME") imageView.image = image navigationItem.titleView = imageView
let image : UIImage = UIImage(named: "LogoName") let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 25, height: 25)) imageView.contentMode = .scaleAspectFit imageView.image = image navigationItem.titleView = imageView
override func viewDidLoad() { super.viewDidLoad() self.resultSearchController = ({ let controller = UISearchController(searchResultsController: nil) controller.searchResultsUpdater = self controller.dimsBackgroundDuringPresentation = false controller.searchBar.sizeToFit() controller.searchBar.delegate = self self.tableView.tableHeaderView = controller.searchBar return controller })() self.tableView.estimatedRowHeight = 130 self.tableView.rowHeight = UITableViewAutomaticDimension self.definesPresentationContext = true self.tableView.tableFooterView = UIView.init(frame: CGRectZero) }
self.searchController.hidesNavigationBarDuringPresentation = NO; self.definesPresentationContext = NO;
- (void)willPresentSearchController:(UISearchController *)searchController { self.navigationController.navigationBar.translucent = YES; } -(void)willDismissSearchController:(UISearchController *)searchController { self.navigationController.navigationBar.translucent = NO; }
self.aNavigationController?.extendedLayoutIncludesOpaqueBars = true
- (void)willPresentSearchController:(UISearchController *)searchController { self.navigationController.navigationBar.translucent = YES; } -(void)willDismissSearchController:(UISearchController *)searchController { self.navigationController.navigationBar.translucent = NO; }
- (void)layoutSubviews { [[[self searchController] searchBar] sizeToFit]; }
override func viewDidLoad() { super.viewDidLoad() self.resultSearchController = ({ let controller = UISearchController(searchResultsController: nil) controller.searchResultsUpdater = self controller.dimsBackgroundDuringPresentation = false controller.definesPresentationContext = false controller.searchBar.sizeToFit() controller.searchBar.delegate = self self.tableView.tableHeaderView = controller.searchBar return controller })() self.tableView.estimatedRowHeight = 130 self.tableView.rowHeight = UITableViewAutomaticDimension self.definesPresentationContext = true self.tableView.tableFooterView = UIView.init(frame: CGRectZero) }
override func viewDidLoad() { super.viewDidLoad() self.extendedLayoutIncludesOpaqueBars = !self.navigationController!.navigationBar.translucent }
navigationController?.navigationBar.translucent = true
lazy var searchController:UISearchController = { let sc = UISearchController(searchResultsController: nil) sc.searchResultsUpdater = self sc.obscuresBackgroundDuringPresentation = false sc.searchBar.placeholder = "Search" sc.hidesNavigationBarDuringPresentation = false return sc }()
func position(for bar: UIBarPositioning) -> UIBarPosition { if UIDevice.current.userInterfaceIdiom == .pad { return .top } else { if iOSVersion <= 9 { return .top } return .topAttached } }
var radioButtonController = SSRadioButtonsController() radioButtonController.setButtonsArray([button1!,button2!,button3!])
import UIKit class CheckBox: UIButton { let checkedImage = UIImage(named: "ic_check_box")! as UIImage let uncheckedImage = UIImage(named: "ic_check_box_outline_blank")! as UIImage var isChecked: Bool = false { didSet{ if isChecked == true { self.setImage(checkedImage, for: UIControlState.normal) } else { self.setImage(uncheckedImage, for: UIControlState.normal) } } } override func awakeFromNib() { self.addTarget(self, action: self.isChecked = false } func buttonClicked(sender: UIButton) { if sender == self { isChecked = !isChecked } } }
import UIKit class RadioButton: UIButton { var alternateButton:Array<RadioButton>? override func awakeFromNib() { self.layer.cornerRadius = 5 self.layer.borderWidth = 2.0 self.layer.masksToBounds = true } func unselectAlternateButtons(){ if alternateButton != nil { self.isSelected = true for aButton:RadioButton in alternateButton! { aButton.isSelected = false } }else{ toggleButton() } } override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { unselectAlternateButtons() super.touchesBegan(touches, with: event) } func toggleButton(){ self.isSelected = !isSelected } override var isSelected: Bool { didSet { if isSelected { self.layer.borderColor = Color.turquoise.cgColor } else { self.layer.borderColor = Color.grey_99.cgColor } } } }
override func awakeFromNib() { self.view.layoutIfNeeded() womanRadioButton.selected = true manRadioButton.selected = false } override func viewDidLoad() { womanRadioButton?.alternateButton = [manRadioButton!] manRadioButton?.alternateButton = [womanRadioButton!] }
BEMCheckBox *myCheckBox = [[BEMCheckBox alloc] initWithFrame:CGRectMake(0, 0, 50, 50)]; [self.view addSubview:myCheckBox];
@IBAction func btn_box(sender: UIButton) { if (btn_box.selected == true) { btn_box.setBackgroundImage(UIImage(named: "box"), forState: UIControlState.Normal) btn_box.selected = false; } else { btn_box.setBackgroundImage(UIImage(named: "checkBox"), forState: UIControlState.Normal) btn_box.selected = true; } }
@IBAction func btnSelectedTapped(sender: AnyObject) { btnTag = 1 if btnTag == 1 { btnSelected.setImage(UIImage(named: "icon_radioSelected"), forState: .Normal) btnUnSelected.setImage(UIImage(named: "icon_radioUnSelected"), forState: .Normal) btnTag = 0 } }
@IBAction func btnUnSelectedTapped(sender: AnyObject) { btnTag = 1 if btnTag == 1 { btnUnSelected.setImage(UIImage(named: "icon_radioSelected"), forState: .Normal) btnSelected.setImage(UIImage(named: "icon_radioUnSelected"), forState: .Normal) btnTag = 0 } }
@IBAction func checkBoxBtnTapped(_ sender: UIButton) { if checkBoxBtn.isSelected { checkBoxBtn.setBackgroundImage( } else { checkBoxBtn.setBackgroundImage( } checkBoxBtn.isSelected = !checkBoxBtn.isSelected }
checkbox = UIButton.init(type: .custom) checkbox.setImage(UIImage.init(named: "iconCheckboxOutlined"), for: .normal) checkbox.setImage(UIImage.init(named: "iconCheckboxFilled"), for: .selected) checkbox.addTarget(self, action:
@objc func toggleCheckboxSelection() { checkbox.isSelected = !checkbox.isSelected }
import UIKit @IBDesignable class SPRadioButton: UIButton { @IBInspectable var gap:CGFloat = 8 { didSet { self.setNeedsDisplay() } } @IBInspectable var btnColor: UIColor = UIColor.green{ didSet{ self.setNeedsDisplay() } } @IBInspectable var isOn: Bool = true{ didSet{ self.setNeedsDisplay() } } override func draw(_ rect: CGRect) { self.contentMode = .scaleAspectFill drawCircles(rect: rect) } func drawCircles(rect: CGRect){ var path = UIBezierPath() path = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: rect.width, height: rect.height)) let circleLayer = CAShapeLayer() circleLayer.path = path.cgPath circleLayer.lineWidth = 3 circleLayer.strokeColor = btnColor.cgColor circleLayer.fillColor = UIColor.white.cgColor layer.addSublayer(circleLayer) if isOn { let innerCircleLayer = CAShapeLayer() let rectForInnerCircle = CGRect(x: gap, y: gap, width: rect.width - 2 * gap, height: rect.height - 2 * gap) innerCircleLayer.path = UIBezierPath(ovalIn: rectForInnerCircle).cgPath innerCircleLayer.fillColor = btnColor.cgColor layer.addSublayer(innerCircleLayer) } self.layer.shouldRasterize = true self.layer.rasterizationScale = UIScreen.main.nativeScale } /* override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { isOn = !isOn self.setNeedsDisplay() } */ override func awakeFromNib() { super.awakeFromNib() addTarget(self, action: isOn = false } @objc func buttonClicked(sender: UIButton) { if sender == self { isOn = !isOn setNeedsDisplay() } } }
import UIKit extension ViewController : UIActionSheetDelegate { func actionSheet(actionSheet: UIActionSheet, didDismissWithButtonIndex buttonIndex: Int) { if actionSheet.tag == 0 { if buttonIndex == 1 { } else if (buttonIndex == 2) { } } } } class ViewController: UIViewController, UIActionSheetDelegate { @IBAction func test(sender: AnyObject) { let systemVersion: NSInteger = (UIDevice.currentDevice().systemVersion as NSString).integerValue if systemVersion < 8 { let action:UIActionSheet = UIActionSheet(title: "Change Map Type", delegate: self, cancelButtonTitle: "Back", destructiveButtonTitle: nil, otherButtonTitles: "Product Page", "Video") action.tag = 0 action.showInView(self.view) } else { let alertController: UIAlertController = UIAlertController(title: "Change Map Type", message: nil, preferredStyle: UIAlertControllerStyle.ActionSheet) let cancelAction: UIAlertAction = UIAlertAction(title: "Back", style: UIAlertActionStyle.Cancel, handler: nil) let button1action: UIAlertAction = UIAlertAction(title: "Product Page", style: UIAlertActionStyle.Default, handler: { (action: UIAlertAction!) -> () in }) let button2action: UIAlertAction = UIAlertAction(title: "Video", style: UIAlertActionStyle.Default, handler: { (action: UIAlertAction!) -> () in }) alertController.addAction(cancelAction) alertController.addAction(button1action) alertController.addAction(button2action) self.presentViewController(alertController, animated: true, completion: nil) } } override func viewDidLoad() { super.viewDidLoad() } }
if let popoverController = alertController.popoverPresentationController { popoverController.barButtonItem = sender } self.presentViewController(alertController, animated: true, completion: nil)
if let popoverController = alertController.popoverPresentationController { popoverController.sourceView = sender popoverController.sourceRect = sender.bounds } self.presentViewController(alertController, animated: true, completion: nil)
alertController.popoverPresentationController?.sourceView = self.view
if ( UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiom.pad ){ if let currentPopoverpresentioncontroller = alertController.popoverPresentationController{ currentPopoverpresentioncontroller.barButtonItem = sender as! UIBarButtonItem currentPopoverpresentioncontroller.permittedArrowDirections = UIPopoverArrowDirection.down; self.present(alertController, animated: true, completion: nil) } }else{ self.present(alertController, animated: true, completion: nil) }
if ( UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiom.pad ){ actionSheet = UIAlertController(title: "Please Select Camera or Photo Library", message: "", preferredStyle: .alert) } actionSheet.addAction(UIAlertAction(title: "Upload a Photo", style: .default, handler: { (UIAlertAction) in self.openPhotoLibrary() })) actionSheet.addAction(UIAlertAction(title: "Take a Photo", style: .default, handler: { (UIAlertAction) in self.openCamera() })) actionSheet.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil)) self.present(actionSheet, animated: true, completion: nil)
if let popoverController = alertController.popoverPresentationController { popoverController.sourceView = self.view popoverController.sourceRect = CGRect(x: self.view.bounds.midX, y: self.view.bounds.midY, width: 0, height: 0) popoverController.permittedArrowDirections = [] } self.present(alertController, animated: true, completion: nil)
let destinationNavigationController = segue.destination as! UINavigationController let targetController = destinationNavigationController.topViewController
let destinationNavigationController = segue.destinationViewController as UINavigationController let targetController = destinationNavigationController.topViewController
override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if segue.identifier == "segueShowNavigation"{ var DestViewController = segue.destinationViewController as! UINavigationController let targetController = DestViewController.topViewController as! ReceiveViewController targetController.data = "hello from ReceiveVC !" }}
var data : String = "" override func viewDidLoad() { super.viewDidLoad() println("data from ReceiveViewController is \(data)") }
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if let navigationVC = segue.destination as? UINavigationController, let myViewController = navigationVC.topViewController as? MyViewControllerClass { myViewController.yourProperty = myProperty } }
let svc = segue.destination as? UINavigationController let controller: MyController = svc?.topViewController as! MyController controller.myProperty = "Hi there"
override func prepare(for segue: UIStoryboardSegue, sender: Any?) { if let vc = segue.destination.childViewControllers[0] as? FooController { vc.variable = localvariable } }
import XCTest class Springboard { static let springboard = XCUIApplication(privateWithPath: nil, bundleID: "com.apple.springboard") /** Terminate and delete the app via springboard */ class func deleteMyApp() { XCUIApplication().terminate() springboard.resolve() let icon = springboard.icons["MyAppName"] if icon.exists { let iconFrame = icon.frame let springboardFrame = springboard.frame icon.pressForDuration(1.3) springboard.coordinateWithNormalizedOffset(CGVectorMake((iconFrame.minX + 3) / springboardFrame.maxX, (iconFrame.minY + 3) / springboardFrame.maxY)).tap() springboard.alerts.buttons["Delete"].tap() } } }
override func tearDown() { Springboard.deleteMyApp() super.tearDown() }
class AppResetUITests: XCTestCase { override func setUp() { let app = XCUIApplication() app.launchArguments = ["MY_UI_TEST_MODE"] app.launch()
class AppDelegate: UIResponder, UIApplicationDelegate { func application( ‚Ä¶didFinishLaunchingWithOptions‚Ä¶ ) -> Bool { let args = NSProcessInfo.processInfo().arguments if args.contains("MY_UI_TEST_MODE") { myResetApplication() }
let args = NSProcessInfo.processInfo().arguments if args.contains("MY_UI_TEST_MODE") { myResetApplication() }
class AppResetUnitTests: XCTestCase { override func setUp() { myResetApplication()
@interface XCUIApplication (Private) - (id)initPrivateWithPath:(NSString *)path bundleID:(NSString *)bundleID; - (void)resolve; @end
class Springboard { static let springboard = XCUIApplication(privateWithPath: nil, bundleID: "com.apple.springboard")! static let settings = XCUIApplication(privateWithPath: nil, bundleID: "com.apple.Preferences")! /** Terminate and delete the app via springboard */ class func deleteMyApp() { XCUIApplication().terminate() springboard.resolve() let icon = springboard.icons["{MyAppName}"] if icon.exists { let iconFrame = icon.frame let springboardFrame = springboard.frame icon.press(forDuration: 1.3) springboard.coordinate(withNormalizedOffset: CGVector(dx: (iconFrame.minX + 3) / springboardFrame.maxX, dy: (iconFrame.minY + 3) / springboardFrame.maxY)).tap() springboard.alerts.buttons["Delete"].tap() XCUIDevice.shared().press(.home) XCUIDevice.shared().press(.home) Thread.sleep(forTimeInterval: 0.5) let settingsIcon = springboard.icons["Settings"] if settingsIcon.exists { settingsIcon.tap() settings.tables.staticTexts["General"].tap() settings.tables.staticTexts["Reset"].tap() settings.tables.staticTexts["Reset Location & Privacy"].tap() settings.buttons["Reset Warnings"].tap() settings.terminate() } } } }
import XCTest import Foundation class Springboard { let springboard = XCUIApplication(bundleIdentifier: "com.apple.springboard") let settings = XCUIApplication(bundleIdentifier: "com.apple.Preferences") /** Terminate and delete the app via springboard */ func deleteMyApp() { XCUIApplication().terminate() springboard.activate() XCUIDevice.shared.orientation = UIDeviceOrientation.portrait sleep(2) let icon = springboard.otherElements["Home screen icons"].scrollViews.otherElements.icons["YourAppName"] if icon.exists { let iconFrame = icon.frame let springboardFrame = springboard.frame icon.press(forDuration: 2.5) springboard.coordinate(withNormalizedOffset: CGVector(dx: ((iconFrame.minX + 3) / springboardFrame.maxX), dy:((iconFrame.minY + 3) / springboardFrame.maxY))).tap() Thread.sleep(forTimeInterval: 0.5) springboard.buttons["Delete"].firstMatch.tap() XCUIDevice.shared.press(.home) XCUIDevice.shared.press(.home) Thread.sleep(forTimeInterval: 0.5) let settingsIcon = springboard.otherElements["Home screen icons"].scrollViews.otherElements.icons["Settings"] if settingsIcon.exists { settingsIcon.tap() settings.tables.staticTexts["General"].tap() settings.tables.staticTexts["Reset"].tap() settings.tables.staticTexts["Reset Location & Privacy"].tap() if UIDevice.current.userInterfaceIdiom == .pad { settings.buttons["Reset"].tap() } else { settings.buttons["Reset Warnings"].tap() } settings.terminate() } } } }
import XCTest class Springboard { static let springboard = XCUIApplication(privateWithPath: nil, bundleID: "com.apple.springboard") static let settings = XCUIApplication(privateWithPath: nil, bundleID: "com.apple.Preferences") /** Terminate and delete the app via springboard */ class func deleteMyApp() { XCUIApplication().terminate() springboard.resolve() let icon = springboard.icons["MyAppName"] if icon.exists { let iconFrame = icon.frame let springboardFrame = springboard.frame icon.pressForDuration(1.3) springboard.coordinateWithNormalizedOffset(CGVectorMake((iconFrame.minX + 3) / springboardFrame.maxX, (iconFrame.minY + 3) / springboardFrame.maxY)).tap() springboard.alerts.buttons["Delete"].tap() XCUIDevice.sharedDevice().pressButton(.Home) XCUIDevice.sharedDevice().pressButton(.Home) NSThread.sleepForTimeInterval(0.5) let settingsIcon = springboard.icons["Settings"] if settingsIcon.exists { settingsIcon.tap() settings.tables.staticTexts["General"].tap() settings.tables.staticTexts["Reset"].tap() settings.tables.staticTexts["Reset Location & Privacy"].tap() settings.buttons["Reset Warnings"].tap() settings.terminate() } } } }
import XCTest class Springboard { static let springboard = XCUIApplication(privateWithPath: nil, bundleID: "com.apple.springboard") class func deleteMyApp() { XCUIApplication().terminate() springboard!.resolve() let icon = springboard!.icons["My Test App"] if icon.exists { let iconFrame = icon.frame let springboardFrame = springboard!.frame icon.press(forDuration: 1.3) springboard!.coordinate(withNormalizedOffset: CGVector(dx: (iconFrame.minX + 3 * UIScreen.main.scale) / springboardFrame.maxX, dy: (iconFrame.minY + 3 * UIScreen.main.scale) / springboardFrame.maxY)).tap() springboard!.alerts.buttons["Delete"].tap() } } }
import XCTest class Springboard { static let springboard = XCUIApplication(bundleIdentifier: "com.apple.springboard") static let settings = XCUIApplication(bundleIdentifier: "com.apple.Preferences") static let isiPad = UIScreen.main.traitCollection.userInterfaceIdiom == .pad class func deleteApp(name: String) { XCUIApplication().terminate() if !springboard.icons[name].firstMatch.exists { return } settings.launch() goToRootSetting(settings) settings.tables.staticTexts["General"].tap() settings.tables.staticTexts[(isiPad ? "iPad" : "iPhone") + " Storage"].tap() while settings.tables.activityIndicators["In progress"].exists { sleep(1) } let appTableCellElementQuery = settings.tables.staticTexts.matching(identifier: name) appTableCellElementQuery.element(boundBy: appTableCellElementQuery.count - 1).tap() settings.tables.staticTexts["Delete App"].tap() isiPad ? settings.alerts.buttons["Delete App"].tap() : settings.buttons["Delete App"].tap() settings.terminate() } /** You may not want to do this cuz it makes you re-trust your computer and device. **/ class func resetLocationAndPrivacySetting(passcode: String?) { settings.launch() goToRootSetting(settings) settings.tables.staticTexts["General"].tap() settings.tables.staticTexts["Reset"].tap() settings.tables.staticTexts["Reset Location & Privacy"].tap() passcode?.forEach({ char in settings.keys[String(char)].tap() }) isiPad ? settings.alerts.buttons["Reset"].tap() : settings.buttons["Reset Settings"].tap() } class func goToRootSetting(_ settings: XCUIApplication) { let navBackButton = settings.navigationBars.buttons.element(boundBy: 0) while navBackButton.exists { navBackButton.tap() } } }
Springboard.deleteApp(name: "AppName") Springboard.resetLocationAndPrivacySetting()
static let springboard = XCUIApplication(bundleIdentifier: "com.apple.springboard") class func deleteMyApp(name: String) { let icon = springboard.icons[name] if icon.exists { let iconFrame = icon.frame let springboardFrame = springboard.frame icon.press(forDuration: 2.0) var portaitOffset = 0.0 as CGFloat if XCUIDevice.shared.orientation != .portrait { portaitOffset = iconFrame.size.width - 2 * 3 * UIScreen.main.scale } let coord = springboard.coordinate(withNormalizedOffset: CGVector(dx: (iconFrame.minX + portaitOffset + 3 * UIScreen.main.scale) / springboardFrame.maxX, dy: (iconFrame.minY + 3 * UIScreen.main.scale) / springboardFrame.maxY)) coord.tap() let _ = springboard.alerts.buttons["Delete"].waitForExistence(timeout: 5) springboard.alerts.buttons["Delete"].tap() XCUIDevice.shared.press(.home) } }
import UIKit var num1: Int = 1 var char1: Character = "a" func changeNumber(var num: Int) { num = 2 print(num) print(num1) } changeNumber(num1) func changeChar(inout char: Character) { char = "b" print(char) print(char1) } changeChar(&char1)
struct MyStruct { private var myInt: Int = 1 mutating func increaseMyInt() { myInt += 1 } } /* call to function _copies_ argument to function property function property is mutated function returns a copy of mutated property to caller (copy 2) */ func myFunc(var myHugeStruct: MyStruct) -> MyStruct { myHugeStruct.increaseMyInt() return myHugeStruct } func myFuncWithLessCopyOverhead(inout myHugeStruct: MyStruct) { myHugeStruct.increaseMyInt() } var a = MyStruct() a = myFunc(a) myFuncWithLessCopyOverhead(&a)
struct MyStruct { var myStructsIntProperty: Int = 1 mutating func myNotVeryThoughtThroughInoutFunction (inout myInt: Int) { myStructsIntProperty += 1 /* What happens here? function by argument of the MyStruct structure. Hence, we value of the inout argument. Since the swift docs describe inout as a "call by reference" type as well as a "copy-in-copy-out" method, this behaviour is somewhat undefined (at least avoidable). After the function has been called: will the value of myStructsIntProperty have been increased by 1 or 2? (answer: 1) */ myInt += 1 } func myInoutFunction (inout myInt: Int) { myInt += 1 } } var a = MyStruct() print(a.myStructsIntProperty) a.myInoutFunction(&a.myStructsIntProperty) print(a.myStructsIntProperty) a.myNotVeryThoughtThroughInoutFunction(&a.myStructsIntProperty) print(a.myStructsIntProperty)
func + (left: CGPoint, right: CGPoint) -> CGPoint { return CGPoint(x: left.x + right.x, y: left.y + right.y) } func += (left: inout CGPoint, right: CGPoint) { left = left + right }
struct LoginConstants { static let maxAttempts = 10 }
let maximumNumberOfLoginAttempts = 10 let MAXIMUM_NUMBER_OF_LOGIN_ATTEMPTS = 10
protocol someProtocol { var someProperty: String { get } }
protocol SomeProtocol { var someProperty: String { get } } class SomeClass : SomeProtocol { var someProperty: String = "" func cla () { someProperty = "asd" } } let someInstance = SomeClass() print(someInstance.someProperty) someInstance.cla() print(someInstance.someProperty)
protocol MyProtocol { var someProperty: String { get } } struct MyStruct: MyProtocol { let someProperty: String } struct OtherStruct: MyProtocol { let i: Int var someProperty: String { return "\(i)" } }
Log.trace(nil, function: __FUNCTION__, file: __FILE__, line: __LINE__)
func log(message: String, function: String = file: String = line: Int = print("Message \"\(message)\" (File: \(file), Function: \(function), Line: \(line))") } log("Some message")
func log(message: String, function: String = __FUNCTION__, file: String = __FILE__, line: Int = __LINE__) { print("Message \"\(message)\" (File: \(file.lastPathComponent), Function: \(function), Line: \(line))") } log("Some message")
func log(message: String, function: String = __FUNCTION__, file: String = __FILE__, line: Int = __LINE__) { let url = NSURL(fileURLWithPath: file) print("Message \"\(message)\" (File: \(url.lastPathComponent ?? "?"), Function: \(function), Line: \(line))") } log("some message")
func LogW(msg:String, function: String = print("[WARNING]\(makeTag(function, file: file, line: line)) : \(msg)") } private func makeTag(function: String, file: String, line: Int) -> String{ let url = NSURL(fileURLWithPath: file) let className = url.lastPathComponent ?? file return "\(className) \(function)[\(line)]" }
extension RegionEntity: Hashable { public var hashValue: Int { return id } } public func ==(first: RegionEntity, second: RegionEntity) -> Bool { return first.id == second.id }
protocol Indexable { var id: Int! { get } } extension Indexable { var hashValue: Int { return id } } func ==(first: Indexable, second: Indexable) -> Bool { return first.id == second.id }
struct RegionEntity: Indexable, Hashable { var id: Int! }
var textFieldInsideSearchBar = yourSearchbar.valueForKey("searchField") as? UITextField textFieldInsideSearchBar?.textColor = yourcolor
let textFieldInsideSearchBar = yourSearchbar.value(forKey: "searchField") as? UITextField textFieldInsideSearchBar?.textColor = yourcolor
public extension UISearchBar { public func setTextColor(color: UIColor) { let svs = subviews.flatMap { $0.subviews } guard let tf = (svs.filter { $0 is UITextField }).first as? UITextField else { return } tf.textColor = color } }
UITextField.appearance(whenContainedInInstancesOf: [UISearchBar.self]).defaultTextAttributes = [NSAttributedStringKey.foregroundColor.rawValue: UIColor.white]
UITextField.appearance(whenContainedInInstancesOf: [UISearchBar.self]).defaultTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]
extension UISearchBar { var textColor:UIColor? { get { if let textField = self.value(forKey: "searchField") as? UITextField { return textField.textColor } else { return nil } } set (newValue) { if let textField = self.value(forKey: "searchField") as? UITextField { textField.textColor = newValue } } } }
extension UISearchBar { var textColor:UIColor? { get { if let textField = self.valueForKey("searchField") as? UITextField { return textField.textColor } else { return nil } } set (newValue) { if let textField = self.valueForKey("searchField") as? UITextField { textField.textColor = newValue } } } }
UITextField.appearance(whenContainedInInstancesOf: [UISearchBar.self]).textColor = UIColor.blue
extension UISearchBar { var textField: UITextField? { let subViews = subviews.flatMap { $0.subviews } guard let textField = (subViews.filter { $0 is UITextField }).first as? UITextField else { return nil } return textField } }
id appearance = [UITextField appearanceWhenContainedInInstancesOfClasses:@[UISearchBar.class, BCRSidebarController.class]]; [appearance setTextColor:[UIColor.whiteColor colorWithAlphaComponent:0.56]];
extension UISearchBar { var textField: UITextField? { return subviews.first?.subviews.compactMap { $0 as? UITextField }.first } }
let searchBar = UISearchBar() searchBar.textField?.textColor = UIColor.white
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/lib/libsqlite3.dylib /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/libsqlite3.dylib
override func viewDidLoad() { super.viewDidLoad() self.textField.delegate = self; } override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { self.view.endEditing(true) }
extension UIViewController { func hideKeyboard() { let tap: UITapGestureRecognizer = UITapGestureRecognizer( target: self, action: tap.cancelsTouchesInView = false view.addGestureRecognizer(tap) } @objc func dismissKeyboard() { view.endEditing(true) } }
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { self.view.endEditing(true) }
override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent) { self.view.endEditing(true) }
class ViewController: UIViewController { @IBOutlet weak var textField: UITextField! @IBOutlet weak var scrollView: UIScrollView! override func viewDidLoad() { super.viewDidLoad() let tapGesture = UITapGestureRecognizer(target: self, action: "tap:") view.addGestureRecognizer(tapGesture) } func tap(gesture: UITapGestureRecognizer) { textField.resignFirstResponder() } }
class ViewController: UIViewController { @IBOutlet weak var textField: UITextField! @IBOutlet weak var scrollView: UIScrollView! override func viewDidLoad() { super.viewDidLoad() let tapGesture = UITapGestureRecognizer(target: self, action: self.view.addGestureRecognizer(tapGesture) } func tap(gesture: UITapGestureRecognizer) { textField.resignFirstResponder() } }
override func viewDidLoad() { super.viewDidLoad() self.view.addGestureRecognizer(UITapGestureRecognizer(target: self.view, action: }
import UIKit class TapGestureRecognizer: UITapGestureRecognizer { let identifier: String private override init(target: Any?, action: Selector?) { self.identifier = "" super.init(target: target, action: action) } init(target: Any?, action: Selector?, identifier: String) { self.identifier = identifier super.init(target: target, action: action) } static func == (left: TapGestureRecognizer, right: TapGestureRecognizer) -> Bool { return left.identifier == right.identifier } }
import UIKit extension UIView { private var disableKeybordWhenTappedGestureRecognizerIdentifier:String { return "disableKeybordWhenTapped" } private var disableKeybordWhenTappedGestureRecognizer: TapGestureRecognizer? { let hideKeyboardGesture = TapGestureRecognizer(target: self, action: if let gestureRecognizers = self.gestureRecognizers { for gestureRecognizer in gestureRecognizers { if let tapGestureRecognizer = gestureRecognizer as? TapGestureRecognizer, tapGestureRecognizer == hideKeyboardGesture, tapGestureRecognizer == hideKeyboardGesture { return tapGestureRecognizer } } } return nil } @objc private func hideKeyboard() { endEditing(true) } var disableKeybordWhenTapped: Bool { set { let hideKeyboardGesture = TapGestureRecognizer(target: self, action: if let disableKeybordWhenTappedGestureRecognizer = self.disableKeybordWhenTappedGestureRecognizer { removeGestureRecognizer(disableKeybordWhenTappedGestureRecognizer) if gestureRecognizers?.count == 0 { gestureRecognizers = nil } } if newValue { addGestureRecognizer(hideKeyboardGesture) } } get { return disableKeybordWhenTappedGestureRecognizer == nil ? false : true } } }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let textField = UITextField(frame: CGRect(x: 50, y: 50, width: 200, height: 30)) textField.borderStyle = .roundedRect textField.placeholder = "Enter text" view.addSubview(textField) view.disableKeybordWhenTapped = true } }
override func viewDidLoad() { var tapGesture = UITapGestureRecognizer(target: self, action: self.view.userInteractionEnabled = true self.view.addGestureRecognizer(tapGesture) }
func handleTap(sender: UITapGestureRecognizer) { self.view.endEditing(true) }
override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) { self.view.endEditing(true) }
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) { self.view.endEditing(true) }
@IBAction func DismissKeyboard(sender: UITapGestureRecognizer) { self.view.endEditing(true) }
override func viewDidLoad() { super.viewDidLoad() self.view.addGestureRecognizer(tapGesture) }
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { UITouch *touch = [touches anyObject]; if(![touch.view isMemberOfClass:[UITextField class]]) { [touch.view endEditing:YES]; } }
func findAndResignFirstResponder(_ stView: UIView) -> Bool { if stView.isFirstResponder { stView.resignFirstResponder() return true } for subView: UIView in stView.subviews { if findAndResignFirstResponder(subView) { return true } } return false }
+ (void)hideKeyboard { UIWindow *window = [UIApplication sharedApplication].keyWindow; [self resignResponderForView:window]; } + (void)resignResponderForView:(UIView *)view { [view resignFirstResponder]; if (view.subviews.count == 0) return; for (UIView *subview in view.subviews) { [self resignResponderForView:subview]; } }
override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { tableView.deselectRowAtIndexPath(indexPath, animated: true) let team = self.teamArray[indexPath.row] as Team var removed = false for (index, value) in enumerate(self.teamSelected) { if (value == team) { self.teamSelected.removeAtIndex(index) removed = true } } if (!removed) { self.teamSelected.append(team) } var userDefaults = NSUserDefaults.standardUserDefaults() userDefaults.setValue(self.teamSelected, forKey: "teams") userDefaults.synchronize() tableView.reloadData() }
class Team: NSObject{ var id: Int! var name: NSString! var shortname: NSString! init(id: Int, name:NSString, shortname: NSString) { self.id = id self.name = name self.shortname = shortname } }
let teams = [Team(id: 1, name: "team1", shortname: "t1"), Team(id: 2, name: "team2", shortname: "t2")] var userDefaults = UserDefaults.standard let encodedData: Data = NSKeyedArchiver.archivedData(withRootObject: teams) userDefaults.set(encodedData, forKey: "teams") userDefaults.synchronize()
let decoded = userDefaults.object(forKey: "teams") as! Data let decodedTeams = NSKeyedUnarchiver.unarchiveObject(with: decoded) as! [Team]
.Team encodeWithCoder:]: unrecognized selector sent to instance
class Team: NSObject, NSCoding { var id: Int var name: String var shortname: String init(id: Int, name: String, shortname: String) { self.id = id self.name = name self.shortname = shortname } required convenience init(coder aDecoder: NSCoder) { let id = aDecoder.decodeInteger(forKey: "id") let name = aDecoder.decodeObject(forKey: "name") as! String let shortname = aDecoder.decodeObject(forKey: "shortname") as! String self.init(id: id, name: name, shortname: shortname) } func encode(with aCoder: NSCoder) { aCoder.encode(id, forKey: "id") aCoder.encode(name, forKey: "name") aCoder.encode(shortname, forKey: "shortname") } }
NSData *colorData = [NSKeyedArchiver archivedDataWithRootObject:color]; [[NSUserDefaults standardUserDefaults] setObject:colorData forKey:@"myColor"];
NSData *colorData = [[NSUserDefaults standardUserDefaults] objectForKey:@"myColor"]; UIColor *color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];
[myButton setTitleEdgeInsets:UIEdgeInsetsMake(0.0, 5.0, 0.0, 0.0)];
myButton.titleEdgeInsets = UIEdgeInsets(top: 0.0, left: 5.0, bottom: 0.0, right: 0.0)
myButton.titleEdgeInsets.top = 0 myButton.titleEdgeInsets.left = 5 myButton.titleEdgeInsets.bottom = 0 myButton.titleEdgeInsets.right = 0
CGFloat padding = 10.0f; [myButton setTitleEdgeInsets:UIEdgeInsetsMake(0, padding, 0, -padding)]; [myButton setContentEdgeInsets:UIEdgeInsetsMake(0, 0, 0, padding)]; let padding: CGFloat = 10.0 myButton.titleEdgeInsets = UIEdgeInsets(top: 0.0, left: padding, bottom: 0.0, right: -padding) myButton.contentEdgeInsets = UIEdgeInsets(top: 0.0, left: 0.0, bottom: 0.0, right: padding)
[self.myButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; float padding_button = 6.0f; UIEdgeInsets titleInsets = UIEdgeInsetsMake(0.0f, padding_button, 0.0f, -padding_button); UIEdgeInsets contentInsets = UIEdgeInsetsMake(padding_button, 0.0f, padding_button, 0.0f); CGFloat extraWidthRequiredForTitle = titleInsets.left - titleInsets.right; contentInsets.right += extraWidthRequiredForTitle; [self.myButton setTitleEdgeInsets:titleInsets]; [self.myButton setContentEdgeInsets:contentInsets]; [self.myButton sizeToFit];
[self.myButton setImage:[UIImage imageNamed:@"YourImage.png"] forState:UIControlStateNormal];
_myButton.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft; _myButton.contentEdgeInsets = UIEdgeInsetsMake(0, 10, 0, 0);
let data = Data(base64Encoded: "aGVsbG8gd29ybGQ=")! print(data.hexString)
extension Data { struct HexEncodingOptions: OptionSet { let rawValue: Int static let upperCase = HexEncodingOptions(rawValue: 1 << 0) } func hexEncodedString(options: HexEncodingOptions = []) -> String { let format = options.contains(.upperCase) ? "%02hhX" : "%02hhx" return map { String(format: format, $0) }.joined() } }
let data = Data(bytes: [0, 1, 127, 128, 255]) print(data.hexEncodedString()) print(data.hexEncodedString(options: .upperCase))
extension Data { struct HexEncodingOptions: OptionSet { let rawValue: Int static let upperCase = HexEncodingOptions(rawValue: 1 << 0) } func hexEncodedString(options: HexEncodingOptions = []) -> String { let hexDigits = Array((options.contains(.upperCase) ? "0123456789ABCDEF" : "0123456789abcdef").utf16) var chars: [unichar] = [] chars.reserveCapacity(2 * count) for byte in self { chars.append(hexDigits[Int(byte / 16)]) chars.append(hexDigits[Int(byte % 16)]) } return String(utf16CodeUnits: chars, count: chars.count) } }
extension Data { private static let hexAlphabet = "0123456789abcdef".unicodeScalars.map { $0 } public func hexEncodedString() -> String { return String(self.reduce(into: "".unicodeScalars, { (result, value) in result.append(Data.hexAlphabet[Int(value/16)]) result.append(Data.hexAlphabet[Int(value%16)]) })) } }
extension Data { var hexDescription: String { return reduce("") {$0 + String(format: "%02x", $1)} } }
public class StringMisc { private static let CHexLookup : [Character] = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F" ] public static func byteArrayToHexString(_ byteArray : [UInt8]) -> String { var stringToReturn = "" for oneByte in byteArray { let asInt = Int(oneByte) stringToReturn.append(StringMisc.CHexLookup[asInt >> 4]) stringToReturn.append(StringMisc.CHexLookup[asInt & 0x0f]) } return stringToReturn } }
let byteArray : [UInt8] = [ 0x25, 0x99, 0xf3 ] assert(StringMisc.byteArrayToHexString(byteArray) == "2599F3")
extension Data { func hexEncodedString() -> String { let hexDigits = Array("0123456789abcdef".utf16) var hexChars = [UTF16.CodeUnit]() hexChars.reserveCapacity(count * 2) for byte in self { let (index1, index2) = Int(byte).quotientAndRemainder(dividingBy: 16) hexChars.append(hexDigits[index1]) hexChars.append(hexDigits[index2]) } return String(utf16CodeUnits: hexChars, count: hexChars.count) } }
extension String { func hexDecodedData() -> Data { let chars = Array(utf8) var bytes = [UInt8]() bytes.reserveCapacity(count / 2) let map: [UInt8] = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ] for i in stride(from: 0, to: count, by: 2) { let index1 = Int(chars[i] & 0x1F ^ 0x10) let index2 = Int(chars[i + 1] & 0x1F ^ 0x10) bytes.append(map[index1] << 4 | map[index2]) } return Data(bytes) } }
yourLabelName.transform = CGAffineTransform(rotationAngle: CGFloat.pi / 2)
yourLabelName.transform = CGAffineTransform(rotationAngle: CGFloat.pi)
yourLabelName.transform = CGAffineTransform(rotationAngle: -CGFloat.pi / 2)
yourButtonName.transform = CGAffineTransform(rotationAngle: CGFloat.pi / 2)
var rotateLabel: UILabel = UILabel(frame: CGRectMake(100, 0, 28, 159)) rotateLabel.textAlignment = .Right rotateLabel.text = "Hello!" self.view.addSubview(rotateLabel) rotateLabel.transform = CGAffineTransformMakeRotation(CGFloat(M_PI_2)) rotateLabel.frame = CGRectMake(100, 0, 28, 159)
var rotateLabel: UILabel = UILabel(frame: CGRectMake(100, 0, 28, 159)) rotateLabel.textAlignment = .Right rotateLabel.text = "Hello!" self.view.addSubview(rotateLabel) rotateLabel.transform = CGAffineTransformMakeRotation(CGFloat(-M_PI_2)) rotateLabel.frame = CGRectMake(100, 0, 28, 159)
func rotate(degrees: Int , clockwise: Bool) { let x = 180 / degrees if (clockwise) { self.transform = CGAffineTransform(rotationAngle: CGFloat.pi / CGFloat(x)) } else { self.transform = CGAffineTransform(rotationAngle: -CGFloat.pi / CGFloat(x)) } }
extension UIView { func rotate(degrees: CGFloat) { rotate(radians: CGFloat.pi * degrees / 180.0) } func rotate(radians: CGFloat) { self.transform = CGAffineTransform(rotationAngle: radians) } }
let rotateLabel: UILabel = UILabel(frame: CGRect(x:15, y:66, width:28, height:159)) rotateLabel.textAlignment = .right rotateLabel.text = "TEXT" self.view.addSubview(rotateLabel) rotateLabel.transform = CGAffineTransform(rotationAngle: CGFloat(-(Double.pi / 2.0))) rotateLabel.frame = CGRect(x:15, y:66, width:28, height:159)
let data = "foo".data(using: .utf8)! let array = [UInt8](data) let array = data.withUnsafeBytes { [UInt8](UnsafeBufferPointer(start: $0, count: data.count)) }
Array(UnsafeBufferPointer(start: UnsafePointer<UInt8>(data.bytes), count: data.length))
if let nsData = NSData(base64Encoded: "VGVzdFN0cmluZw==", options: .ignoreUnknownCharacters) { let bytes = [UInt8](nsData as Data) print(bytes, String(bytes: bytes, encoding: .utf8))
var string = "Hello World" let data : NSData! = string.dataUsingEncoding(NSUTF8StringEncoding) let count = data.length / sizeof(UInt8) var array = [UInt8](count: count, repeatedValue: 0) data.getBytes(&array, length:count * sizeof(UInt8)) println(array)
let count = data.length / MemoryLayout<UInt8>.size var byteArray = [UInt8](repeating: 0, count: count) data.getBytes(&byteArray, length:count)
extension Data { var bytes : [UInt8]{ return [UInt8](self) } }
extension Array where Element == UInt8 { var data : Data{ return Data(bytes:(self)) } }
let data = Data(bytes: [0x01, 0x02, 0x03]) let byteArray: [UInt8] = data.map { $0 }
let def = NSUserDefaults.standardUserDefaults() var key = "keySave" var element: AnyObject! var array1: [AnyObject!] = [] array1.append(["key1": "val1", "key2": "val2"]) array1.append(["key1": "val1", "key2": "val2"]) var savestring : [AnyObject!] savestring = array1 var defaults = NSUserDefaults.standardUserDefaults() defaults.setObject(savestring, forKey: key) defaults.synchronize() var obj: [AnyObject!] = [] if(obj != nil){ print("size: ") print(obj.count) element = obj[0] print(element.objectForKey("key1")) }
let array = ["horse", "cow", "camel", "sheep", "goat"] let defaults = UserDefaults.standard defaults.set(array, forKey: "SavedStringArray")
let defaults = UserDefaults.standard let myarray = defaults.stringArray(forKey: "SavedStringArray") ?? [String]()
let array = [15, 33, 36, 723, 77, 4] let defaults = UserDefaults.standard defaults.set(array, forKey: "SavedIntArray")
let defaults = UserDefaults.standard let array = defaults.array(forKey: "SavedIntArray") as? [Int] ?? [Int]()
let array = [true, true, false, true, false] let defaults = UserDefaults.standard defaults.set(array, forKey: "SavedBoolArray")
let defaults = UserDefaults.standard let array = defaults.array(forKey: "SavedBoolArray") as? [Bool] ?? [Bool]()
let array = [Date(), Date(), Date(), Date()] let defaults = UserDefaults.standard defaults.set(array, forKey: "SavedDateArray")
let defaults = UserDefaults.standard let array = defaults.array(forKey: "SavedDateArray") as? [Date] ?? [Date]()
var key = "keySave" var array1: [NSString] = [NSString]() array1.append("value 1") array1.append("value 2") var defaults = NSUserDefaults.standardUserDefaults() defaults.setObject(array1, forKey: key) defaults.synchronize() if let testArray : AnyObject? = defaults.objectForKey(key) { var readArray : [NSString] = testArray! as [NSString] }
import Foundation class DWWatchlistController { private let kNSUserDefaultsWatchlistKey: String = "dw_watchlist_key" private let userDefaults: NSUserDefaults private(set) var watchlist:[SNStock] { get { if let watchlistData : AnyObject = userDefaults.objectForKey(kNSUserDefaultsWatchlistKey) { if let watchlist : AnyObject = NSKeyedUnarchiver.unarchiveObjectWithData(watchlistData as! NSData) { return watchlist as! [SNStock] } } return [] } set(watchlist) { let watchlistData = NSKeyedArchiver.archivedDataWithRootObject(watchlist) userDefaults.setObject(watchlistData, forKey: kNSUserDefaultsWatchlistKey) userDefaults.synchronize() } } init() { userDefaults = NSUserDefaults.standardUserDefaults() } func addStock(stock: SNStock) { var watchlist = self.watchlist watchlist.append(stock) self.watchlist = watchlist } func removeStock(stock: SNStock) { var watchlist = self.watchlist if let index = find(watchlist, stock) { watchlist.removeAtIndex(index) self.watchlist = watchlist } } }
import Foundation class SNStock: NSObject, NSCoding { let ticker: NSString let name: NSString init(ticker: NSString, name: NSString) { self.ticker = ticker self.name = name } required init(coder aDecoder: NSCoder) { self.ticker = aDecoder.decodeObjectForKey("ticker") as! NSString self.name = aDecoder.decodeObjectForKey("name") as! NSString } func encodeWithCoder(aCoder: NSCoder) { aCoder.encodeObject(ticker, forKey: "ticker") aCoder.encodeObject(name, forKey: "name") } override func isEqual(object: AnyObject?) -> Bool { if let object = object as? SNStock { return self.ticker == object.ticker && self.name == object.name } else { return false } } override var hash: Int { return ticker.hashValue } }
let arrayFruit = ["Apple","Banana","Orange","Grapes","Watermelon"] UserDefaults.standard.set(arrayFruit, forKey: "arrayFruit")
if let arr = UserDefaults.standard.array(forKey: "arrayFruit") as? [String]{ print(arr) }
var defaults = NSUserDefaults.standardUserDefaults() var dict : NSDictionary = ["key":"value"] var array1: NSArray = dict.allValues defaults.setObject(array1, forkey : "MyKey") var myarray : NSArray = defaults.objectForKey("MyKey") as NSArray println(myarray)
@IBAction func unwindToList(segue: UIStoryboardSegue) { }
@IBAction func test(sender: AnyObject) { NSLog("Test") }
@interface MyViewController (Workaround) - (IBAction)unwindToMyViewController: (UIStoryboardSegue *)segue; @end
@IBAction func unwindToSegue (segue : UIStoryboardSegue) {}
@interface ListTableViewController - (IBAction)unwindToList: (UIStoryboardSegue *)segue; @end
import UIKit @objc(ListTableViewController) class ListTableViewController: UITableViewController { @IBAction func unwindToList(s:UIStoryboardSegue) { println("hello world"); } }
@IBAction func unwindToThisView(withUnwindSegue unwindSegue: UIStoryboardSegue) { ... }
@IBAction func unwindToList(segue: UIStoryboardSegue) { }
self.navigationController?.popViewControllerAnimated(true)
@IBAction func unwindToParent(sender: UIStoryboardSegue) { dismissViewControllerAnimated(true, completion: nil) }
override func canPerformUnwindSegueAction(action: Selector, fromViewController: UIViewController, withSender sender: AnyObject) -> Bool { return action == Selector("unwindToParent:") }
self.window.rootViewController.class == myViewController
if self.window.rootViewController is MyViewController { }
if let wd = UIApplication.shared.delegate?.window { var vc = wd!.rootViewController if(vc is UINavigationController){ vc = (vc as! UINavigationController).visibleViewController } if(vc is LogInViewController){ } }
if let viewControllers = navigationController?.viewControllers { for viewController in viewControllers { if viewController.isKindOfClass(MenuViewController) { println("yes it is") } } }
var window:UIWindow? if let viewControllers = window?.rootViewController?.childViewControllers { for viewController in viewControllers { if viewController.isKindOfClass(MyViewControllerClass) { println("Found it!!!") } } }
if let wd = self.view.window { var vc = wd.rootViewController! if(vc is UINavigationController){ vc = (vc as! UINavigationController).visibleViewController } if(vc is customViewController){ var viewController : customViewController = vc as! customViewController
if let window = UIApplication.shared.delegate?.window { if var viewController = window?.rootViewController { if(viewController is UINavigationController){ viewController = (viewController as! UINavigationController).visibleViewController! } print(viewController) } }
let vcOnTop = self.embeddedNav.viewControllers[self.embeddedNav.viewControllers.count-1] if vcOnTop.isKindOfClass(VcShowDirections){ return }
class MyViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() NotificationCenter.default.addObserver( self, selector: name: .UIApplicationDidChangeStatusBarOrientation, object: nil ) } func deviceDidRotate() { guard let window = self.view.window else { return } if window.rootViewController == self { print("vc is self") } if window.rootViewController is MyViewController { print("vc is MyViewController") } } }
let viewControllers = navController?.viewControllers for aViewController in viewControllers! { if aViewController .isKind(of: (MyClass?.classForCoder)!) { _ = navController?.popToViewController(aViewController, animated: true) } }
if let index = self.navigationController?.viewControllers.index(where: { $0 is MyViewController }) { let vc = self.navigationController?.viewControllers[vcIndex] as! MyViewController self.navigationController?.popToViewController(vc, animated: true) } else { self.navigationController?.popToRootViewController(animated: true) }
enum ErrorCode: (Int, String) { case Generic_Error = (0, "Unknown") case DB_Error = (909, "Database") }
struct Trouble { static let Generic_Error = (0, "Unknown") static let DB_Error = (909, "Database") }
enum ErrorCode: Int, CustomStringConvertible { case Generic = 0 case DB = 909 var description: String { switch self { case .Generic: return "Unknown" case .DB: return "Database" } } }
enum Error { case Generic(Int, String) case DB(Int, String) }
enum ErrorCode: RawRepresentable { case Generic_Error case DB_Error var rawValue: (Int, String) { switch self { case .Generic_Error: return (0, "Unknown") case .DB_Error: return (909, "Database") } } init?(rawValue: (Int, String)) { switch rawValue { case (0, "Unknown"): self = .Generic_Error case (909, "Database"): self = .DB_Error default: return nil } } }
enum ErrorCode { case Generic_Error case DB_Error func values() -> (code: Int!, description: String?)! { switch self { case .Generic_Error: return (0, "Unknown") case .DB_Error: return (909, "Database") } } }
let errorCode: ErrorCode = ErrorCode.Generic_Error; if (errorCode.values().code == 0) { }
enum SomeType { case type1 case type2 case type3 var typeNameAndDescription: (name: String, description: String) { switch self { case .type1: return ("type1 name", "type1 description") case .type2: return ("type2 name", "type2 description") case .type3: return ("type3 name", "type3 description") } } }
let myType = SomeType.type1 let typeName = myType.typeNameAndDescription.name let typeDescription = myType.typeNameAndDescription.description
enum ErrorCode { case Generic_Error case DB_Error public var code:Int{ switch self { case .Generic_Error: return 0 case .DB_Error: return 909 } } public var name:String{ switch self { case .Generic_Error: return "Unknown" case .DB_Error: return "Database" } } }
let err:ErrorCode = .Generic_Error print(err.code) print(err.name)
enum State { case FullOpen case HalfOpen case Closed }
var stateForConversionView: State! ... var previousState: State! if true { previousState = stateForConversionView! switch previousState { case .FullOpen: stateForConversionView = .HalfOpen case .HalfOpen: stateForConversionView = .FullOpen case .Closed: stateForConversionView = .HalfOpen default: break } }
if true { previousState = stateForConversionView switch previousState! { case .FullOpen: stateForConversionView = .HalfOpen case .HalfOpen: stateForConversionView = .FullOpen case .Closed: stateForConversionView = .HalfOpen default: break } }
var previousState:String previousState = stateForConversionView switch previousState { case State.FullOpen.rawValue: stateForConversionView = .HalfOpen case State.HalfOpen.rawValue: stateForConversionView = .FullOpen case State.Closed.rawValue: stateForConversionView = .HalfOpen default:break }
if true { switch stateForConversionView! { case .FullOpen: stateForConversionView = .HalfOpen case .HalfOpen: stateForConversionView = .FullOpen case .Closed: stateForConversionView = .HalfOpen default: break } }
let lbl = UILabel(frame: CGRectMake(0, 0, 300, 200)) lbl.text = "yourString" lbl.textAlignment = NSTextAlignment.Right lbl.textAlignment = .Right lbl.textColor = UIColor.red lbl.shadowColor = UIColor.black lbl.font = UIFont(name: "HelveticaNeue", size: CGFloat(22)) self.view.addSubview(lbl)
label.textColor = UIColor(red: 0.0, green: 0.004, blue: 0.502, alpha: 1.0)
@IBOutlet var label1: UILabel! @IBOutlet var label2: UILabel! override func viewDidLoad() { super.viewDidLoad() label1.textColor = UIColor.redColor() label2.textColor = label1.textColor }
let titleLabel = UILabel(frame: CGRect(x: 0, y: 0, width: 40, height: 40)) titleLabel.text = "change to red color" titleLabel.textAlignment = .center titleLabel.textColor = UIColor.red
label1.textColor = UIColor.red label2.textColor = UIColor.black
func textViewDidBeginEditing(_ textView: UITextView) { if (commentsTextView.textColor == UIColor.darkGray) { commentsTextView.text = "" commentsTextView.textColor = UIColor.black } }
error: type var dict = Dictionary<Any, Int>() ^ <REPL>:5:12: error: cannot convert the expression var dict = Dictionary<Any, Int>() ^~~~~~~~~~~~~~~~~~~~~~
error: type var dict = Dictionary<Hashable, Int>() ^ Swift.Equatable:2:8: note: func ==(lhs: Self, rhs: Self) -> Bool ^ Swift.Hashable:1:10: note: type protocol Hashable : Equatable ^ <REPL>:5:12: error: cannot convert the expression var dict = Dictionary<Hashable, Int>() ^~~~~~~~~~~~~~~~~~~~~~~~~~~
typealias KeyType = protocol<Hashable, Equatable> var dict = Dictionary<KeyType, Int>()
error: type var dict = Dictionary<KeyType, Int>() ^ Swift.Equatable:2:8: note: func ==(lhs: Self, rhs: Self) -> Bool ^ Swift.Hashable:1:10: note: type protocol Hashable : Equatable ^ <REPL>:6:12: error: cannot convert the expression var dict = Dictionary<KeyType, Int>() ^~~~~~~~~~~~~~~~~~~~~~~~~~
var dict = Dictionary<Any, Int>() dict[1] = 2 dict["key"] = 3 dict[SomeEnum.SomeValue] = 4
struct AnyKey: Hashable { private let underlying: Any private let hashValueFunc: () -> Int private let equalityFunc: (Any) -> Bool init<T: Hashable>(_ key: T) { underlying = key hashValueFunc = { key.hashValue } equalityFunc = { if let other = $0 as? T { return key == other } return false } } var hashValue: Int { return hashValueFunc() } } func ==(x: AnyKey, y: AnyKey) -> Bool { return x.equalityFunc(y.underlying) }
func makeDict<T: Hashable>(arr: T[]) { let x = Dictionary<T, Int>() }
var description : String { return "<TypeName>[\(<Field1>), \(<Field2>), ...]" }
public var classTypeToClassNumber = [Any.Type : Int]()
public class ClassNumberVsClassType { public var classTypeToClassNumber = [String : Int]() public init() { classTypeToClassNumber[String(describing: ClassWithStringKey.self)] = 367622 classTypeToClassNumber[String(describing: ClassBasedOnKeyedItemList3.self)] = 367629 classTypeToClassNumber[String(describing: ClassBasedOnKeyedItemList2.self)] = 367626 classTypeToClassNumber[String(describing: ClassWithGuidKey.self)] = 367623 classTypeToClassNumber[String(describing: SimpleStruct.self)] = 367619 classTypeToClassNumber[String(describing: TestData.self)] = 367627 classTypeToClassNumber[String(describing: ETestEnum.self)] = 367617 classTypeToClassNumber[String(describing: ClassBasedOnKeyedItemList0.self)] = 367624 classTypeToClassNumber[String(describing: ClassBasedOnKeyedItemList1.self)] = 367625 classTypeToClassNumber[String(describing: SimpleClass.self)] = 367620 classTypeToClassNumber[String(describing: DerivedClass.self)] = 367621 } public func findClassNumber(_ theType : Any.Type) -> Int { var s = String(describing: theType) if s.hasSuffix(".Type") { s = s.substring(to: s.index(s.endIndex, offsetBy: -5)) } let classNumber = _classTypeToClassNumber[s] return classNumber != nil ? classNumber! : -1 } }
var dict = [String: Int] dict[object_getClassName("key")] = 3
class func buildWordDefinition (word:String, language:Language, root:TBXMLElement) -> WordDefinition { let word = WordDefinition(word: word, language: language)
class WordDefinition { let word: String let language: Language init(word: String, language:Language) { self.word = word self.language = language } }
class func buildWordDefinition (word:String, language:Language, root:TBXMLElement) -> WordDefinition { let word = WordDefinition(word: word, language: language)
var str: String? = "Question mark?" println(str!) str = nil
var str: String! = "Exclamation mark!" println(str) str = nil
class A { let instanceOfB: B! init() { self.instanceOfB = B(instanceOfA: self) } } class B { unowned let instanceOfA: A init(instanceOfA: A) { self.instanceOfA = instanceOfA } }
var defaultNil : String? println(defaultNil) >> nil var canBeNil : String? = "test" println(canBeNil) >> optional(test) canBeNil = nil println(canBeNil) >> nil println(canBeNil!) >> var canNotBeNil : String! = "test" print(canNotBeNil) >> "test" var cantBeNil : String = "test" cantBeNil = nil
class Person { var residence: Residence? } class Residence { var numberOfRooms = 1 }
if let roomCount = john.residence?.numberOfRooms { println("John } else { println("Unable to retrieve the number of rooms.") }
if case let myFirstInt? = firstInt where myFirstInt > 1 { print("Valid") } else { print("Invalid") }
libMobileGestalt.dylib MGCopyAnswer(@"5MSZn7w3nnJp22VbpqaxLQ"); MGCopyAnswer(@"7mV26K/1a+wTtqiunvHMUQ"); MGCopyAnswer(@"BasebandAPTimeSync"); MGCopyAnswer(@"BasebandPostponementStatus"); MGCopyAnswer(@"BasebandPostponementStatusBlob"); MGCopyAnswer(@"BasebandSecurityInfoBlob"); MGCopyAnswer(@"BasebandStatus"); MGCopyAnswer(@"BuildVersion"); MGCopyAnswer(@"CoreRoutineCapability"); MGCopyAnswer(@"DeviceClass"); MGCopyAnswer(@"DeviceClassNumber"); MGCopyAnswer(@"DeviceName"); MGCopyAnswer(@"DeviceSupports1080p"); MGCopyAnswer(@"DeviceSupports720p"); MGCopyAnswer(@"DiskUsage"); MGCopyAnswer(@"GSDeviceName"); MGCopyAnswer(@"HWModelStr"); MGCopyAnswer(@"HasBaseband"); MGCopyAnswer(@"InternalBuild"); MGCopyAnswer(@"InverseDeviceID"); MGCopyAnswer(@"IsSimulator"); MGCopyAnswer(@"MLBSerialNumber"); MGCopyAnswer(@"MaxH264PlaybackLevel"); MGCopyAnswer(@"MinimumSupportediTunesVersion"); MGCopyAnswer(@"PasswordConfigured"); MGCopyAnswer(@"PasswordProtected"); MGCopyAnswer(@"ProductType"); MGCopyAnswer(@"ProductVersion"); MGCopyAnswer(@"RegionCode"); MGCopyAnswer(@"RegionalBehaviorNTSC"); MGCopyAnswer(@"RegionalBehaviorNoPasscodeLocationTiles"); MGCopyAnswer(@"ReleaseType"); MGCopyAnswer(@"SIMStatus");
var overView = UIView(frame: CGRectMake(0, 0, self.view.frame.width/1.3, self.view.frame.height/1.3)) overView.center = CGPointMake(CGRectGetMidX(self.view.bounds), CGRectGetMidY(self.view.bounds)-self.view.frame.height/16); overView.backgroundColor = UIColor.whiteColor() self.view.addSubview(overView) self.view.bringSubviewToFront(overView)
extension UIView { func asImage() -> UIImage { let renderer = UIGraphicsImageRenderer(bounds: bounds) return renderer.image { rendererContext in layer.render(in: rendererContext.cgContext) } } }
extension UIView { func asImage() -> UIImage { if let renderer = UIGraphicsImageRenderer(bounds: bounds) return renderer.image { rendererContext in layer.render(in: rendererContext.cgContext) } } else { UIGraphicsBeginImageContext(self.frame.size) self.layer.render(in:UIGraphicsGetCurrentContext()!) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return UIImage(cgImage: image!.cgImage!) } } }
extension UIImage { convenience init(view: UIView) { UIGraphicsBeginImageContext(view.frame.size) view.layer.render(in:UIGraphicsGetCurrentContext()!) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() self.init(cgImage: image!.cgImage!) } }
extension UIImage { convenience init(view: UIView) { UIGraphicsBeginImageContext(view.frame.size) view.layer.render(in:UIGraphicsGetCurrentContext()!) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() self.init(cgImage: image!.cgImage!) } }
UIGraphicsBeginImageContextWithOptions(myView.bounds.size, myView.opaque, 0.0f); [myView drawViewHierarchyInRect:myView.bounds afterScreenUpdates:NO]; UIImage *snapshotImageFromMyView = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); myImageView.image = snapshotImageFromMyView;
UIImageWriteToSavedPhotosAlbum(snapshotImageFromMyView, nil,nil, nil);
UIGraphicsBeginImageContextWithOptions(myView.bounds.size, myView.isOpaque, 0.0) myView.drawHierarchy(in: myView.bounds, afterScreenUpdates: false) let snapshotImageFromMyView = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() print(snapshotImageFromMyView) myImageView.image = snapshotImageFromMyView
extension UIImage{ convenience init(view: UIView) { UIGraphicsBeginImageContextWithOptions(view.bounds.size, view.isOpaque, 0.0) view.drawHierarchy(in: view.bounds, afterScreenUpdates: false) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() self.init(cgImage: (image?.cgImage)!) } } Use : imgVV.image = UIImage.init(view: myView) let img = UIImage.init(view: myView)
extension UIImage { convenience init(view: UIView) { UIGraphicsBeginImageContext(view.frame.size) view.layer.render(in: UIGraphicsGetCurrentContext()!) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() self.init(cgImage: (image?.cgImage)!) } }
UIGraphicsBeginImageContext(self.view.bounds.size); self.view.layer.renderInContext(UIGraphicsGetCurrentContext()) var screenShot = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();
UIGraphicsBeginImageContextWithOptions(CGSizeMake(100, 100), false, 0); self.view.drawViewHierarchyInRect(CGRectMake(-50,-5-,view.bounds.size.width,view.bounds.size.height), afterScreenUpdates: true) var image:UIImage = UIGraphicsGetImageFromCurrentImageContext();
extension UIView { func asImage() -> UIImage? { if let renderer = UIGraphicsImageRenderer(bounds: bounds) return renderer.image { rendererContext in layer.render(in: rendererContext.cgContext) } } else { UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.isOpaque, 0.0) defer { UIGraphicsEndImageContext() } guard let currentContext = UIGraphicsGetCurrentContext() else { return nil } self.layer.render(in: currentContext) return UIGraphicsGetImageFromCurrentImageContext() } } }
extension UIView { var snapshot: UIImage? { UIGraphicsBeginImageContext(self.frame.size) guard let context = UIGraphicsGetCurrentContext() else { return nil } layer.render(in: context) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return image } }
var snapshot = overView.snapshotViewAfterScreenUpdates(false)
UIView* snapshot = [overView snapshotViewAfterScreenUpdates:NO];
extension UIView { var image: UIImage? { let renderer = UIGraphicsImageRenderer(bounds: bounds) return renderer.image { rendererContext in layer.render(in: rendererContext.cgContext) } } }
let view = UIView(frame: CGRect(x: 0, y: 0, width: 100, height: 100)) view.backgroundColor = .blue let view2 = UIView(frame: CGRect(x: 10, y: 10, width: 20, height: 20)) view2.backgroundColor = .red view.addSubview(view2) let imageView = UIImageView(image: view.image)
let viewSnapshot = myView.snapshot let screenSnapshot = UIApplication.shared.snapshot UIImage(view: self.view)
extension UIImage { convenience init(view: UIView) { if let cgImage = view.snapshot?.cgImage { self.init(cgImage: cgImage) } else { self.init() } } }
extension UIView { var snapshot: UIImage? { UIGraphicsBeginImageContextWithOptions(bounds.size, isOpaque, 0.0) if UIGraphicsGetCurrentContext() != nil { drawHierarchy(in: bounds, afterScreenUpdates: true) let screenshot = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return screenshot } return nil } }
extension UIApplication { var snapshot: UIImage? { return keyWindow?.rootViewController?.view.snapshot } }
if let renderer = UIGraphicsImageRenderer(size: view!.bounds.size) let capturedImage = renderer.image { (ctx) in view!.drawHierarchy(in: view!.bounds, afterScreenUpdates: true) } return capturedImage } else { UIGraphicsBeginImageContextWithOptions((view!.bounds.size), view!.isOpaque, 0.0) view!.drawHierarchy(in: view!.bounds, afterScreenUpdates: false) let capturedImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return capturedImage! }
fileprivate func captureUIImageFromUIView(_ view:UIView?) -> UIImage { guard (view != nil) else{ let errorImage = UIImage(named: "Error Image") return errorImage } if let renderer = UIGraphicsImageRenderer(size: view!.bounds.size) let capturedImage = renderer.image { (ctx) in view!.drawHierarchy(in: view!.bounds, afterScreenUpdates: true) } return capturedImage } else { UIGraphicsBeginImageContextWithOptions((view!.bounds.size), view!.isOpaque, 0.0) view!.drawHierarchy(in: view!.bounds, afterScreenUpdates: false) let capturedImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return capturedImage! } }
@IBOutlet weak fileprivate var myCustomView: UIView! var myPic: UIImage? let myImageView = UIImageView() @IBAction fileprivate func saveImageButtonTapped(_ sender: UIButton) { myPic = captureUIImageFromUIView(myCustomView) myImageView.image = myPic! }
extension UIView { func asImage() -> UIImage { let renderer = UIGraphicsImageRenderer(size: self.bounds.size) return renderer.image { _ in self.drawHierarchy(in: CGRect(x: 0, y: 0, width: bounds.size.width, height: bounds.size.height), afterScreenUpdates: false) } } }
extension UIImage { convenience init(_ view: UIView) { UIGraphicsBeginImageContext(view.frame.size) view.layer.render(in: UIGraphicsGetCurrentContext()!) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() self.init(cgImage: (image?.cgImage)!) } }
yourView.layer.render(in:UIGraphicsGetCurrentContext()!)
- If you had used `autoLayout` or `Masonry` in `yourView` (that you want to convert) . - If you did not add `yourView` to another view which means that `yourView` was not used as a subview but just an object.
[yourView setNeedsLayout]; [yourView layoutIfNeeded];
extension UIView { func asImage() -> UIImage { let renderer = UIGraphicsImageRenderer(bounds: bounds) return renderer.image { rendererContext in layer.render(in: rendererContext.cgContext) } } }
let screen = self.superview!.bounds let width = screen.width / 4 let height = width let frame = CGRect(x: 0, y: 0, width: width, height: height) let x = (screen.size.width - frame.size.width) * 0.5 let y = (screen.size.height - frame.size.height) * 0.5 let mainFrame = CGRect(x: x, y: y, width: frame.size.width, height: frame.size.height) let yourView = YourView() yourView.frame = mainFrame yourView.setNeedsDisplay() let characterViewImage = yourView.asImage()
extension UIImage{ convenience init(view: UIView) { let renderer = UIGraphicsImageRenderer(size: self.bounds.size) let canvas = CGRect(x: 0, y: 0, width: bounds.size.width, height: bounds.size.height) let image = renderer.image { _ in self.drawHierarchy(in: canvas, afterScreenUpdates: false) } self.init(cgImage: (image?.cgImage)!) } }
extension UIView { func toImage() -> UIImage { UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.isOpaque, 0.0) self.drawHierarchy(in: self.bounds, afterScreenUpdates: false) let snapshotImageFromMyView = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return snapshotImageFromMyView! } }
please try below code. -(UIImage *)getMainImageFromContext { UIGraphicsBeginImageContextWithOptions(viewBG.bounds.size, viewBG.opaque, 0.0); [viewBG.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage * img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return img; }
class CVSTButton : UIButton { var cvstPosition: Double required init(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") super.init(coder: aDecoder) } }
class CVSTButton : UIButton { var cvstPosition: Double { get { return self.cvstPosition } set { self.cvstPosition = newValue } } required init(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") super.init(coder: aDecoder) } }
import UIKit class CustomButton: UIButton { var myValue: Int required init(value: Int = 0) { self.myValue = value super.init(frame: .zero) backgroundColor = .red } required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let button = CustomButton(value: 0) button.setTitle("Hello", for: .normal) button.translatesAutoresizingMaskIntoConstraints = false view.addSubview(button) button.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true button.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true print(button.myValue) } }
import UIKit class CustomButton: UIButton { var myValue: Int convenience init(squareOf value: Int) { self.init(value: value * value) } required init(value: Int = 0) { self.myValue = value super.init(frame: .zero) backgroundColor = .red } required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let button = CustomButton(squareOf: 10) button.setTitle("Hello", for: .normal) button.translatesAutoresizingMaskIntoConstraints = false view.addSubview(button) button.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true button.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true print(button.myValue) } }
import UIKit class CustomButton: UIButton { var myValue: Int override init(frame: CGRect) { self.myValue = 0 super.init(frame: frame) backgroundColor = .red } required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") } }
import UIKit class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() let button = CustomButton(frame: .zero) button.setTitle("Hello", for: .normal) button.translatesAutoresizingMaskIntoConstraints = false view.addSubview(button) button.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true button.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true print(button.myValue) } }
import UIKit class CustomButton: UIButton { var myValue: Int required init?(coder aDecoder: NSCoder) { self.myValue = 0 super.init(coder: aDecoder) backgroundColor = .red } }
import UIKit class ViewController: UIViewController { @IBOutlet weak var button: CustomButton! override func viewDidLoad() { super.viewDidLoad() print(button.myValue) } }
import UIKit class CustomButton: UIButton { var myValue: Int override init(frame: CGRect) { self.myValue = 0 super.init(frame: frame) backgroundColor = .red } required init?(coder aDecoder: NSCoder) { self.myValue = 0 super.init(coder: aDecoder) backgroundColor = .red } }
import UIKit class CustomButton: UIButton { var myValue: Int = 0 override init(frame: CGRect) { super.init(frame: frame) backgroundColor = .red } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) backgroundColor = .red } }
import UIKit class CustomButton: UIButton { var myValue: Int? = nil override init(frame: CGRect) { super.init(frame: frame) backgroundColor = .red } required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) backgroundColor = .red } }
class CVSTButton : UIButton { var cvstPosition: Double = 0 }
class CVSTButton : UIButton { var cvstPosition: Double required init(coder aDecoder: NSCoder) { cvstPosition = 0 super.init(coder: aDecoder) } }
convenience init(type buttonType: UIButtonType) { super.init(frame: CGRectZero) }
override class func buttonWithType(buttonType: UIButtonType) -> AnyObject { let button = super.buttonWithType(buttonType) as! UIButton return button }
class CVSTButton: UIButton { var cvstPosition: Double static func button(withCVSTPosition cvstPosition: Double) -> CVSTButton { let button = CVSTButton(type: .detailDisclosure) button.cvstPosition = cvstPosition return button } }
let cvstButton = CVSTButton.button(withCVSTPosition: 2.0)
var VC1 = self.storyboard.instantiateViewControllerWithIdentifier("MyViewController") as ViewController self.presentViewController(VC1, animated:true, completion: nil)
let VC1 = self.storyboard!.instantiateViewControllerWithIdentifier("MyViewController") as! ViewController self.navigationController!.pushViewController(VC1, animated: true)
let VC1 = self.storyboard!.instantiateViewControllerWithIdentifier("MyViewController") as! ViewController let navController = UINavigationController(rootViewController: VC1) self.present(navController, animated:true, completion: nil)
let VC1 = self.storyboard!.instantiateViewController(withIdentifier: "MyViewController") as! MyViewController let navController = UINavigationController(rootViewController: VC1) self.present(navController, animated:true, completion: nil)
let viewController = self.storyboard?.instantiateViewControllerWithIdentifier("Dashboard") as! Dashboard let navController = UINavigationController(rootViewController: viewController) self.presentViewController(navController, animated:true, completion: nil)
struct PresentedFromFavourites { static var comingFromFav = false}
extension UIViewController { func returnToFavourites() { let storyBoard : UIStoryboard = UIStoryboard(name: "Main", bundle:nil) let mainNavigationController = storyBoard.instantiateViewController(withIdentifier: "HomeNav") as! UINavigationController let favViewController = storyBoard.instantiateViewController(withIdentifier: "Favourites") self.present(mainNavigationController, animated: false, completion: { mainNavigationController.pushViewController(favViewController, animated: false) }) } func addBackToFavouritesButton() { if PresentedFromFavourites.comingFromFav { let buttonHeight = (self.navigationController?.navigationBar.frame.size.height)! - 15 let rect = CGRect(x: 2, y: 8, width: buttonHeight, height: buttonHeight) let aButton = UIButton(frame: rect) aButton.setImage( aButton.backgroundColor = UIColor.clear aButton.addTarget(self, action: self.navigationController?.navigationBar.addSubview(aButton) PresentedFromFavourites.comingFromFav = false } }}
self.navigationController?.interactivePopGestureRecognizer.enabled = false
self.navigationController.interactivePopGestureRecognizer.delegate = self func gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer!) -> Bool { return false }
self.navigationController?.navigationItem.backBarButtonItem?.isEnabled = false;
navigationController?.interactivePopGestureRecognizer?.isEnabled = false
navigationController?.interactivePopGestureRecognizer?.isEnabled = true
navigationController?.navigationController?.interactivePopGe‚Äå‚ÄãstureRecognizer?.isE‚Äå‚Äãnabled = false
navigationController?.interactivePopGestureRecognizer?.enabled
self.navigationController.interactivePopGestureRecognizer.enabled
class ViewController2: UIViewController, UIGestureRecognizerDelegate { ... override func viewDidLoad() { super.viewDidLoad() self.navigationController?.interactivePopGestureRecognizer.delegate = self } func gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer) -> Bool { return false }
if navigationController!.respondsToSelector(Selector("interactivePopGestureRecognizer")) { navigationController!.view.removeGestureRecognizer(navigationController!.interactivePopGestureRecognizer) }
popGesture = navigationController!.interactivePopGestureRecognizer
If popGesture != nil { navigationController!.view.addGestureRecognizer(popGesture!) }
-(void)viewWillAppear:(BOOL)animated{ [super viewWillAppear:true]; self.navigationController.interactivePopGestureRecognizer.enabled = NO; }
navigationController?.interactivePopGestureRecognizer?.isEnabled = false navigationItem.hidesBackButton = true
private var popGesture: UIGestureRecognizer? override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) if navigationController!.responds(to: self.popGesture = navigationController!.interactivePopGestureRecognizer self.navigationController!.view.removeGestureRecognizer(navigationController!.interactivePopGestureRecognizer!) } } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) if let gesture = self.popGesture { self.navigationController!.view.addGestureRecognizer(gesture) } }
let largeNumber = 31908551587 let numberFormatter = NumberFormatter() numberFormatter.numberStyle = NumberFormatter.Style.decimal let formattedNumber = numberFormatter.string(from: NSNumber(value:largeNumber))
let largeNumber = 31908551587 let numberFormatter = NSNumberFormatter() numberFormatter.numberStyle = NSNumberFormatterStyle.DecimalStyle let formattedNumber = numberFormatter.stringFromNumber(largeNumber)
extension Int { func withCommas() -> String { let numberFormatter = NumberFormatter() numberFormatter.numberStyle = NumberFormatter.Style.decimal return numberFormatter.string(from: NSNumber(value:self))! } }
extension Int { private static var commaFormatter: NumberFormatter = { let formatter = NumberFormatter() formatter.numberStyle = .decimal return formatter }() internal var commaRepresentation: String { return Int.commaFormatter.string(from: NSNumber(value: self)) ?? "" } }
extension Int { private static var numberFormatter: NumberFormatter = { let numberFormatter = NumberFormatter() numberFormatter.numberStyle = .decimal return numberFormatter }() var delimiter: String { return Int.numberFormatter.string(from: NSNumber(value: self)) ?? "" } }
let numberFormatter = NumberFormatter() numberFormatter.numberStyle = .decimal numberFormatter.groupingSize = 3 numberFormatter.secondaryGroupingSize = 2 numberFormatter.string(from: 10000000)
class AmountField: UITextField { private var isFirstDecimal : Bool = true override func willMove(toSuperview newSuperview: UIView?) { addTarget(self, action: keyboardType = .decimalPad textAlignment = .left placeholder = "0.0" editingChanged() } override func deleteBackward() { var currentText = self.text ?? "" currentText = String(currentText.dropLast()) self.text = currentText editingChanged(self) } @objc func editingChanged(_ textField: UITextField? = nil) { var doubleStr = textField?.text ?? "00" let decimalCount = doubleStr.components(separatedBy: ".") if decimalCount.count > 2 { var currentText = self.text ?? "" currentText = String(currentText.dropLast()) self.text = currentText return } if doubleStr.contains(".") && isFirstDecimal == true { self.text = doubleStr isFirstDecimal = false return } else if !(doubleStr.contains(".")) { isFirstDecimal = true } let doubleStrTemp = doubleStr.replacingOccurrences(of: ",", with: "") if doubleStrTemp != "" { if let n = Decimal(string: doubleStrTemp )?.significantFractionalDecimalDigits { if n > 2 { var currentText = self.text ?? "" currentText = String(currentText.dropLast()) self.text = currentText return } } } doubleStr = doubleStr.replacingOccurrences(of: ",", with: "") let doube = Double(doubleStr) let numberFormatter = NumberFormatter() numberFormatter.numberStyle = NumberFormatter.Style.decimal if doube != nil { let formattedNumber = numberFormatter.string(from: NSNumber(value:doube!)) self.text = formattedNumber } }} extension Decimal { var significantFractionalDecimalDigits: Int { return max(-exponent, 0) }}
1. Launch the iOS Simulator and go to iOS Simulator --> Reset Content and Settings... 2. Close all the applications and restart your mac 3. Open Xcode6.0.1 or 6.0 and test the iOS Simulator
var testView: UIView = UIView(frame: CGRectMake(0, 0, 320, 568)) testView.backgroundColor = UIColor.blueColor() testView.alpha = 0.5 testView.tag = 100 super.view.userInteractionEnabled = false self.view.userInteractionEnabled = true self.view.addSubview(testView)
override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { let touch = touches.anyObject() as UITouch let point = touch.locationInView(self.view) if(testView.tag==100){ println("Tag 100") testView.removeFromSuperview() } else{ println("tag not found") } }
override func touchesBegan(touches: NSSet, withEvent event: UIEvent) { let touch = touches.anyObject() as UITouch let point = touch.locationInView(self.view) if let viewWithTag = self.view.viewWithTag(100) { println("Tag 100") viewWithTag.removeFromSuperview() } else { println("tag not found") } }
@IBAction func infoView(sender: UIButton) { var testView: UIView = UIView(frame: CGRectMake(0, 0, 320, 568)) testView.backgroundColor = UIColor.blueColor() testView.alpha = 0.5 testView.tag = 100 testView.userInteractionEnabled = true self.view.addSubview(testView) let aSelector : Selector = "removeSubview" let tapGesture = UITapGestureRecognizer(target:self, action: aSelector) testView.addGestureRecognizer(tapGesture) } func removeSubview(){ println("Start remove sibview") if let viewWithTag = self.view.viewWithTag(100) { viewWithTag.removeFromSuperview() }else{ println("No!") } }
@IBAction func infoView(sender: UIButton) { let testView: UIView = UIView(frame: CGRect(x: 0, y: 0, width: 320, height: 568)) testView.backgroundColor = .blue testView.alpha = 0.5 testView.tag = 100 testView.isUserInteractionEnabled = true self.view.addSubview(testView) let aSelector : Selector = let tapGesture = UITapGestureRecognizer(target:self, action: aSelector) testView.addGestureRecognizer(tapGesture) } func removeSubview(){ print("Start remove sibview") if let viewWithTag = self.view.viewWithTag(100) { viewWithTag.removeFromSuperview() }else{ print("No!") } }
class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate { @IBOutlet weak var table: UITableView! override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } } func numberOfSectionsInTableView(tableView: UITableView!) -> Int { return 20 } func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { let cell:UITableViewCell=UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: "mycell") cell.textLabel.text="row cell.detailTextLabel.text="subtitle return cell }
class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate { @IBOutlet weak var table: UITableView! override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } func tableView(tableView:UITableView!, numberOfRowsInSection section:Int) -> Int { return 20 } func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -> UITableViewCell! { let cell:UITableViewCell=UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: "mycell") cell.textLabel.text="row cell.detailTextLabel.text="subtitle return cell } }
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { let cell:UITableViewCell=UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: "mycell") cell.textLabel.text="row cell.detailTextLabel.text="subtitle return cell }
func tableView(tableView:UITableView!, numberOfRowsInSection section:Int) -> Int { }
import UIKit class ViewController : UIViewController,UITableViewDelegate,UITableViewDataSource { override func viewDidLoad() { super.viewDidLoad() } func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int{ return 25 } func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell{ var cell:UITableViewCell=UITableViewCell(style: UITableViewCellStyle.Subtitle, reuseIdentifier: "mycell") cell.textLabel?.text = "row cell.detailTextLabel?.text = "subtitle return cell } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() } }
func numberOfSectionsInTableView(tableView: UITableView) -> Int{} func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int{} func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {}
override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { }
override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { }
class ViewController: UIViewController { } extension ViewController: UITableDataSource { func tableView(tableView:UITableView!, numberOfRowsInSection section:Int) -> Int { return 20 } } extension ViewController: UITableViewDelegate { ... }
extension ViewController: UITableViewDataSource { internal func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int { } internal func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell { } }
override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { } override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { }
class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int { return 1 } public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell = UITableViewCell(style: < } override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() }
class MenuViewController: UIViewController, UITableViewDataSource, UITableViewDelegate { override func viewDidLoad() { super.viewDidLoad() } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int{ return 25 } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell{ var cell:UITableViewCell=UITableViewCell(style: UITableViewCellStyle.subtitle, reuseIdentifier: "mycell") cell.textLabel?.text = "row cell.detailTextLabel?.text = "subtitle return cell } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() }
self.tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: "cell")
self.tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: "DefaultCell")
self.tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: "DefaultCell")
self.tableView.registerNib(UINib(nibName: "CustomCellName", bundle: nil), forCellReuseIdentifier: "CustomCellIdentifer")
self.tableView.registerNib(UINib(nibName: "CustomCellName", bundle: nil), forCellReuseIdentifier: "CustomCellName")
self.tableView.register(UITableViewCell.self, forCellReuseIdentifier: "Cell")
override func viewDidLoad() { super.viewDidLoad() self.tblView.register(CellProfileOther.self) } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { let cell: CellProfileOther = tableView.dequeueReusableCell(forIndexPath: indexPath) return cell } extension UITableView { func register<T:UITableViewCell>(_: T.Type) where T: ReusableView, T: NibLoadableView { let bundle = Bundle(for: T.self) let nib = UINib(nibName: T.nibName, bundle: bundle) self.register(nib, forCellReuseIdentifier: T.defaultReuseIdentifier) } func dequeueReusableCell<T:UITableViewCell>(forIndexPath indexPath: IndexPath) -> T where T: ReusableView { guard let cell = self.dequeueReusableCell(withIdentifier: T.defaultReuseIdentifier, for: indexPath) as? T else { fatalError("Could not dequeue cell with identifier: \(T.defaultReuseIdentifier)") } return cell } } protocol ReusableView: class { static var defaultReuseIdentifier: String { get } } protocol NibLoadableView: class { static var nibName: String { get } } extension ReusableView where Self: UIView { static var defaultReuseIdentifier: String { return String(describing: Self.self) } } extension NibLoadableView where Self: UIView { static var nibName: String { return String(describing: Self.self) } } class CellProfileOther: UITableViewCell, ReusableView, NibLoadableView { }
{ "name": "myUser", "email": "user@example.com", "password": "passwordHash" }
class Person : NSObject { var name : String = "" var email : String = "" var password : String = "" init(JSONString: String) { super.init() var error : NSError? let JSONData = JSONString.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) let JSONDictionary: Dictionary = NSJSONSerialization.JSONObjectWithData(JSONData, options: nil, error: &error) as NSDictionary for (key, value) in JSONDictionary { let keyName = key as String let keyValue: String = value as String if (self.respondsToSelector(NSSelectorFromString(keyName))) { self.setValue(keyValue, forKey: keyName) } } } }
override func viewDidLoad() { super.viewDidLoad() let jsonString = "{ \"name\":\"myUser\", \"email\":\"user@example.com\", \"password\":\"passwordHash\" }" var aPerson : Person = Person(JSONString: jsonString) println(aPerson.name) }
let userObject = UserClass(userDictionary) print(userObject!.name)
extension NSObject{ convenience init(jsonStr:String) { self.init() if let jsonData = jsonStr.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false) { do { let json = try NSJSONSerialization.JSONObjectWithData(jsonData, options: []) as! [String: AnyObject] for (key, value) in json { let keyName = key as String let keyValue: String = value as! String if (self.respondsToSelector(NSSelectorFromString(keyName))) { self.setValue(keyValue, forKey: keyName) } } } catch let error as NSError { print("Failed to load: \(error.localizedDescription)") } } else { print("json is of wrong format!") } } }
class Person : NSObject { var name : String? var email : String? var password : String? } class Address : NSObject { var city : String? var zip : String? }
var jsonString = "{ \"name\":\"myUser\", \"email\":\"user@example.com\", \"password\":\"passwordHash\" }" let aPerson = Person(jsonStr: jsonString) print(aPerson.name!) jsonString = "{ \"city\":\"Berlin\", \"zip\":\"12345\" }" let aAddress = Address(jsonStr: jsonString) print(aAddress.city!)
let obj:[String:AnyObject] = [ "array": [JSON.null, false, 0, "", [], [:]], "object":[ "null": JSON.null, "bool": true, "int": 42, "double": 3.141592653589793, "string": "a Œ±\tÂºæ\n™ö≤", "array": [], "object": [:] ], "url":"http: ] let json = JSON(obj) json.toString() json["object"]["null"].asNull json["object"]["bool"].asBool json["object"]["int"].asInt json["object"]["double"].asDouble json["object"]["string"].asString json["array"][0].asNull json["array"][1].asBool json["array"][2].asInt json["array"][3].asString
class MyJSON : JSON { override init(_ obj:AnyObject){ super.init(obj) } override init(_ json:JSON) { super.init(json) } var null :NSNull? { return self["null"].asNull } var bool :Bool? { return self["bool"].asBool } var int :Int? { return self["int"].asInt } var double:Double? { return self["double"].asDouble } var string:String? { return self["string"].asString } var url: String? { return self["url"].asString } var array :MyJSON { return MyJSON(self["array"]) } var object:MyJSON { return MyJSON(self["object"]) } } let myjson = MyJSON(obj) myjson.object.null myjson.object.bool myjson.object.int myjson.object.double myjson.object.string myjson.url
init?(attributes: [String : AnyObject]) { guard let name = attributes["name"] as? String, let coordinates = attributes["coordinates"] as? [String: Double], let latitude = coordinates["lat"], let longitude = coordinates["lng"], else { return nil } self.name = name self.coordinates = CLLocationCoordinate2D(latitude: latitude, longitude: longitude) }
struct SomeObjectType: Deserializable { var someProperty: Int? var someOtherProperty: AnotherObjectType? var yetAnotherProperty: [YetAnotherObjectType]? init(data: [String: AnyObject]) { someProperty <-- data["some_key"] someOtherProperty <-- data["some_other_key"] yetAnotherProperty <-- data["yet_another_key"] } }
struct Person: Deserializable { var name: String? var email: String? var password: String? init(data: [String: AnyObject]) { name <-- data["name"] email <-- data["email"] password <-- data["password"] } }
var parsedObjects = [ParsedObject]() do { let json = try NSJSONSerialization.JSONObjectWithData(jsonData, options: []) as [Dictionary<String, AnyObject>] for dict in json { let parsedObject = ParsedObject() for (key, value) in json { if (parsedObject.respondsToSelector(NSSelectorFromString(keyName))) { parsedObject.setValue(keyValue, forKey: keyName) } } parsedObjects.append(parsedObject) } } catch let error as NSError { print("Failed to load: \(error.localizedDescription)") }
import Foundation struct User: Codable { let name: String let email: String let password: String } extension User { static func from(json: String, using encoding: String.Encoding = .utf8) -> OtherUser? { guard let data = json.data(using: encoding) else { return nil } return OtherUser.from(data: data) } static func from(data: Data) -> OtherUser? { let decoder = JSONDecoder() return try? decoder.decode(OtherUser.self, from: data) } var jsonData: Data? { let encoder = JSONEncoder() return try? encoder.encode(self) } var jsonString: String? { guard let data = self.jsonData else { return nil } return String(data: data, encoding: .utf8) } }
let user = User.from(json: """{ "name": "myUser", "email": "user@example.com", "password": "passwordHash" }""")!
let urlS = "http: func getUser(username: Strung) -> User { var user = User() let url = NSURL(string: "\(urlS)\(username)") if let data = NSData(contentsOfURL: url!) { setKeysAndValues(user, dictionary: parseData(data)) } return user } func setKeysAndValues (object : AnyObject, dictionary : NSDictionary) -> AnyObject { for (key, value) in dictionary { if let key = key as? String, let value = value as? String { if (object.respondsToSelector(NSSelectorFromString(key))) { object.setValue(value, forKey: key) } } } return object } func parseData (data : NSData) -> NSDictionary { var error: NSError? return NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &error) as! NSDictionary }
if let data = data, json = try NSJSONSerialization.JSONObjectWithData(data, options: []) as? [String: AnyObject] { } else { print("No Data :/") }
let email = json["email"] as? String let name = json["name"] as? String let password = json["password"] as? String
print("Found User iname: \(name) with email: \(email) and pass \(password)")
var response = Dictionary<String, Any>() response["user"] = ["Login": "Power Ranger", "Password": "Mighty Morfin response["status"] = 200
enum PListNode { case PLN_String(String) case PLN_Integer(Int) case PLN_Float(Double) case PLN_Bool(Bool) case PLN_Date(CFDate) case PLN_Data(CFData) }
enum PListValue { case PLV_Node(PListNode) case PLV_Array(PListNode[]) case PLV_Dictionary(Dictionary<String, Box<PListValue>>) } typealias PList = Dictionary<String, Box<PListValue>>
let myPlist: PList = [ "Year Of Birth": Box(PLV_Node(PLN_Integer(1965))) , "Pets Names": Box(PLV_Array([])) , "Picture": Box(PLV_Node(PLN_Data(...))) , "City of Birth": Box(PLV_Node(PLN_String("Springfield"))) , "Name": Box(PLV_Node(PLN_String("John Doe"))) , "Kids Names": Box( PLV_Array([PLN_String("John"), PLN_String("Kyra")]) ) ]
switch myPlist["Year Of Birth"] { case Box(.PLV_Node(let plvNodeValue)): ... case Box(.PLV_Array(let plvArrayValue)): ... case Box(.PLV_Dictionary(let plvDictionaryValue)): ... }
var d:Dictionary<String,NSObject> = [:] d["key1"] = "ddd" d["key2"] = 111 NSLog("%@", d) var d2:Dictionary = Dictionary<String,Any>() d2["key1"] = "ddd" d2["key2"] = 111 NSLog("%@", d2)
var dictInfo : NSMutableDictionary = [ "lang_key": "1"] dictInfo["food_type"] = lbl_TypeOfFood.text dictInfo["search_text"] = txt_Search.text dictInfo["date"] = lbl_Date.text dictInfo["opening_hours"] = lbl_OpeningHours.text
var dict: Dictionary<String, AnyObject> = [ "number": 1, "string": "Hello", ]
let nsMutableDictionary = NSMutableDictionary() nsMutableDictionary[NSFontAttributeName] = UIFont(name: "HelveticaNeue", size: 12.0)! nsMutableDictionary[NSForegroundColorAttributeName] = UIColor.redColor() let dictionary: Dictionary<NSObject, AnyObject> = nsMutableDictionary self.attributedPlaceholder = NSAttributedString(string: textParam, attributes: dictionary)
let dictionary : Dictionary = [ "key": "value", "key2": 2, "key3": NSString(), 2: "test", ]
let dictionary : Dictionary<String, String> = [ "key": "value", "key2": 2, ]
