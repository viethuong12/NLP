int main() { const unsigned arraySize = 32768; int data[arraySize]; for (unsigned c = 0; c < arraySize; ++c) data[c] = std::rand() % 256; std::sort(data, data + arraySize); clock_t start = clock(); long long sum = 0; for (unsigned i = 0; i < 100000; ++i) { for (unsigned c = 0; c < arraySize; ++c) { if (data[c] >= 128) sum += data[c]; } } double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC; std::cout << elapsedTime << std::endl; std::cout << "sum = " << sum << std::endl; }
int main() { int x = 10; while (x --> 0) { printf("%d ", x); } }
int x = 10; while( 0 <---- x ) { printf("%d ", x); }
int x = 100; while( 0 <-------------------- x ) { printf("%d ", x); }
int main(void){ int x = 10; while( x-- > 0 ){ printf("%d ", x); } return 0; }
int main(int argc, char* argv[]) { int n = atoi(argv[1]); do printf("n is %d\n", n) as ( n --> 0); return 0; }
token 1: x token 2: -- token 3: > token 4: 0 conclude: x-- > 0
token 1: a token 2: -- token 3: -- token 4: - token 5: b conclude: (a--)-- - b
int main(void) { int x = 10; while( --x> 0 ) { printf("%d ", x); } return 0; }
int main() { int x = 10; while( x --> 0 ) { std::cout << x; } }
int main() { int x = 10; while (x-- > 0) printf("%d ",x); return 0; }
int main() { int x = 10; while (x > 0) { printf("%d ", x); x = x-1; } }
int x = 5; int y = 6; int *p; p = &x; p = &y; *p = 10; assert(x == 5); assert(y == 10);
int x = 0; int &r = x; int *p = &x; int *p2 = &r; assert(p == p2);
int x = 0; int y = 0; int *p = &x; int *q = &y; int **pp = &p; pp = &q; **pp = 4; assert(y == 4); assert(x == 0);
int *p = nullptr; int &r = nullptr; <--- compiling error int &r = *p; <--- likely no compiling error, especially if the nullptr is hidden behind a function call, yet it refers to a non-existent int at address 0
std::string s1 = "123"; std::string s2 = "456"; std::string s3_copy = s1 + s2; const std::string& s3_reference = s1 + s2;
class MyClass { ... virtual void DoSomething(int,int,int,int,int); }; void Foo(const MyClass & bar) { ... bar.DoSomething(i1,i2,i3,i4,i5); } MyClass * GetInstance() { if (somecondition) return NULL; ... } MyClass * p = GetInstance(); Foo(*p);
template<typename T> T& deref(T* p) { if (p == NULL) throw std::invalid_argument(std::string("NULL reference")); return *p; } MyClass * p = GetInstance(); Foo(deref(p));
void increment(int& n) { n = n + 1; } int a; increment(a);
void maybeModify(int& x); void hurtTheCompilersOptimizer(short size, int array[]) { for (int i = 2; i < (int)size; i++) { maybeModify(array[0]); array[i] += array[1]; } }
void hurtTheCompilersOptimizer(short size, int array[]) { register int a0 = a[0]; register int a1 = a[1]; for (int i = 2; i < (int)size; i++) { maybeModify(a0); array[i] += a1; } a[0] = a0; }
void maybeModify(int* x); void hurtTheCompilersOptimizer(short size, int array[]) { for (int i = 2; i < (int)size; i++) { maybeModify(&(array[0])); array[i] += array[1]; } }
F createF(int argument); void extending() { const F& ref = createF(5); std::cout << ref.getArgument() << std::endl; };
int ival = 1024, ival2 = 2048; int *pi = &ival, *pi2 = &ival2; pi = pi2;
class scope_test { public: ~scope_test() { printf("scope_test done!\n"); } }; ... { const scope_test &test= scope_test(); printf("in scope\n"); }
>>> The address that locates a variable within memory is what we call a reference to that variable. (5th paragraph at page 63) >>> The variable that stores the reference to another variable is what we call a pointer. (3rd paragraph at page 64)
>>> reference stands for memory location >>> pointer is a reference container (Maybe because we will use it for several times, it is better to remember that reference.)
using namespace std; void swap(char * &str1, char * &str2) { char *temp = str1; str1 = str2; str2 = temp; } int main() { char *str1 = "Hi"; char *str2 = "Hello"; swap(str1, str2); cout<<"str1 is "<<str1<<endl; cout<<"str2 is "<<str2<<endl; return 0; }
void swap1(char **str1_ptr, char **str2_ptr) { char *temp = *str1_ptr; *str1_ptr = *str2_ptr; *str2_ptr = temp; } int main() { char *str1 = "Hi"; char *str2 = "Hello"; swap1(&str1, &str2); printf("str1 is %s, str2 is %s", str1, str2); return 0; }
using namespace std; int main() { int x = 10; int *ptr = &x; int &*ptr1 = ptr; }
int main(int argc, char** argv) { std::string *str_ptr = new std::string("THIS IS A STRING"); std::string &str_ref = *str_ptr; std::cout << str_ref << std::endl; std::cout << str_ptr << " : " << &str_ref << std::endl; delete str_ptr; }
int main(int argc, char** argv) { std::string &str_ref = *(new std::string("THIS IS A STRING")); std::cout << str_ref; delete &str_ref; /*And, it works, because we are taking the memory address that the reference is storing, and deleting it, which is all a pointer is doing, just we have to specify the address with calling delete &(*str_ptr); (which also compiles and runs fine).*/ }
void increment(int *ptrint) { (*ptrint)++; } void increment(int &refint) { refint++; } void incptrtest() { int testptr=0; increment(&testptr); } void increftest() { int testref=0; increment(testref); }
using namespace std; int main() { int *ptr=0, x=9; ptr=&x; int & j=x; cout << "x=" << x << endl; cout << "&x=" << &x << endl; cout << "j=" << j << endl; cout << "&j=" << &j << endl; cout << "*ptr=" << *ptr << endl; cout << "ptr=" << ptr << endl; cout << "&ptr=" << &ptr << endl; getch(); }
class UDT { public: UDT() : val_d(33) {}; UDT(int val) : val_d(val) {}; virtual ~UDT() {}; private: int val_d; }; class UDT_Derived : public UDT { public: UDT_Derived() : UDT() {}; virtual ~UDT_Derived() {}; }; class Behavior { public: Behavior( const UDT &udt = UDT() ) {}; }; int main() { Behavior b; UDT u(88); Behavior c(u); UDT_Derived ud; Behavior d(ud); return 1; }
void fn1(std::string s); void fn2(const std::string& s); void fn3(std::string& s); void fn4(std::string* s); void bar() { std::string x; fn1(x); fn2(x); fn3(x); fn4(&x); }
Int a = 6, b = 5; Int& rf = a; Cout << rf << endl; rf = b; cout << a << endl;
public void my_function(int& a,int* b,int c){ int d = 1; int &e = d; int *f = e; int *g = f; g = &d; }
using namespace std; int main() { string s = "Somewhere down the road"; istringstream iss(s); do { string subs; iss >> subs; cout << "Substring: " << subs << endl; } while (iss); }
int main() { using namespace std; string sentence = "And I feel fine..."; istringstream iss(sentence); copy(istream_iterator<string>(iss), istream_iterator<string>(), ostream_iterator<string>(cout, "\n")); }
vector<string> tokens; copy(istream_iterator<string>(iss), istream_iterator<string>(), back_inserter(tokens));
vector<string> tokens{istream_iterator<string>{iss}, istream_iterator<string>{}};
std::vector<std::string> strs; boost::split(strs, "string to split", boost::is_any_of("\t "));
int main() { std::string str("Split me by whitespaces"); std::string buf; std::stringstream ss(str); std::vector<std::string> tokens; while (ss >> buf) tokens.push_back(buf); return 0; }
template < class ContainerT > void tokenize(const std::string& str, ContainerT& tokens, const std::string& delimiters = " ", bool trimEmpty = false) { std::string::size_type pos, lastPos = 0, length = str.length(); using value_type = typename ContainerT::value_type; using size_type = typename ContainerT::size_type; while(lastPos < length + 1) { pos = str.find_first_of(delimiters, lastPos); if(pos == std::string::npos) { pos = length; } if(pos != lastPos || !trimEmpty) tokens.push_back(value_type(str.data()+lastPos, (size_type)pos-lastPos )); lastPos = pos + 1; } }
std::vector<std::string> split(const std::string &text, char sep) { std::vector<std::string> tokens; std::size_t start = 0, end = 0; while ((end = text.find(sep, start)) != std::string::npos) { tokens.push_back(text.substr(start, end - start)); start = end + 1; } tokens.push_back(text.substr(start)); return tokens; }
std::vector<std::string> split(const std::string &text, char sep) { std::vector<std::string> tokens; std::size_t start = 0, end = 0; while ((end = text.find(sep, start)) != std::string::npos) { if (end != start) { tokens.push_back(text.substr(start, end - start)); } start = end + 1; } if (end != start) { tokens.push_back(text.substr(start)); } return tokens; }
std::vector<std::string> split(const std::string& text, const std::string& delims) { std::vector<std::string> tokens; std::size_t start = text.find_first_not_of(delims), end = 0; while((end = text.find_first_of(delims, start)) != std::string::npos) { tokens.push_back(text.substr(start, end - start)); start = text.find_first_not_of(delims, end); } if(start != std::string::npos) tokens.push_back(text.substr(start)); return tokens; }
string line = "a line of text to iterate through"; string word; istringstream iss(line, istringstream::in); while( iss >> word ) { }
using namespace std; using namespace boost; int main(int argc, char** argv) { string text = "token test\tstring"; char_separator<char> sep(" \t"); tokenizer<char_separator<char>> tokens(text, sep); for (const string& t : tokens) { cout << t << "." << endl; } }
using namespace std; vector<string> split(const string& s, const string& delim, const bool keep_empty = true) { vector<string> result; if (delim.empty()) { result.push_back(s); return result; } string::const_iterator substart = s.begin(), subend; while (true) { subend = search(substart, s.end(), delim.begin(), delim.end()); string temp(substart, subend); if (keep_empty || !temp.empty()) { result.push_back(temp); } if (subend == s.end()) { break; } substart = subend + delim.size(); } return result; } int main() { const vector<string> words = split("So close no matter how far", " "); copy(words.begin(), words.end(), ostream_iterator<string>(cout, "\n")); }
void Tokenize(const string& str, vector<string>& tokens, const string& delimiters = " ") { string::size_type lastPos = str.find_first_not_of(delimiters, 0); string::size_type pos = str.find_first_of(delimiters, lastPos); while (string::npos != pos || string::npos != lastPos) { tokens.push_back(str.substr(lastPos, pos - lastPos)); lastPos = str.find_first_not_of(delimiters, pos); pos = str.find_first_of(delimiters, lastPos); } }
template<typename T> vector<T> split(const T & str, const T & delimiters) { vector<T> v; typename T::size_type start = 0; auto pos = str.find_first_of(delimiters, start); while(pos != T::npos) { if(pos != start) v.emplace_back(str, start, pos - start); start = pos + 1; pos = str.find_first_of(delimiters, start); } if(start < str.length()) v.emplace_back(str, start, str.length() - start); return v; }
vector<string> v = split<string>("Hello, there; World", ";,"); vector<wstring> v = split<wstring>(L"Hello, there; World", L";,");
char sep = std::string s="1 This is an example"; for(size_t p=0, q=0; p!=s.npos; p=q) std::cout << s.substr(p+(p!=0), (q=s.find(sep, p+1))-p-(p!=0)) << std::endl;
template<typename Operator> void tokenize(Operator& op, const char* input, const char* delimiters) { const char* s = input; const char* e = s; while (*e != 0) { e = s; while (*e != 0 && strchr(delimiters, *e) == 0) ++e; if (e - s > 0) { op(s, e - s); } s = e + 1; } }
template<class ContainerType> class Appender { public: Appender(ContainerType& container) : container_(container) {;} void operator() (const char* s, unsigned length) { container_.push_back(std::string(s,length)); } private: ContainerType& container_; }; std::vector<std::string> strVector; Appender v(strVector); tokenize(v, "A number of words to be tokenized", " \t");
class WordCounter { public: WordCounter() : noOfWords(0) {} void operator() (const char*, unsigned) { ++noOfWords; } unsigned noOfWords; }; WordCounter wc; tokenize(wc, "A number of words to be counted", " \t"); ASSERT( wc.noOfWords == 7 );
std::vector<string> Tokenize( const string str, const std::regex regex ) { using namespace std; std::vector<string> result; sregex_token_iterator it( str.begin(), str.end(), regex, -1 ); sregex_token_iterator reg_end; for ( ; it != reg_end; ++it ) { if ( !it->str().empty() ) result.emplace_back( it->str() ); } return result; }
std::vector<string> TokenizeDefault( const string str ) { using namespace std; regex re( "[\\s,]+" ); return Tokenize( str, re ); }
template<typename _OutputIterator> inline void split( const std::string& str, const std::string& delim, _OutputIterator result) { using namespace boost::algorithm; typedef split_iterator<std::string::const_iterator> It; for(It iter=make_split_iterator(str, first_finder(delim, is_equal())); iter!=It(); ++iter) { *(result++) = boost::copy_range<std::string>(*iter); } } int main(int argc, char* argv[]) { using namespace std; vector<string> splitted; split("HelloFOOworldFOO!", "FOO", back_inserter(splitted)); split("HelloFOOworldFOO!", "FOO", ostream_iterator<string>(cout, "\n")); return 0; }
int main() { std::string s("Somewhere down the road"); std::string::size_type prev_pos = 0, pos = 0; while( (pos = s.find( { std::string substring( s.substr(prev_pos, pos-prev_pos) ); std::cout << substring << prev_pos = ++pos; } std::string substring( s.substr(prev_pos, pos-prev_pos) ); std::cout << substring << return 0; }
using namespace std; vector<string> split(char* str,const char* delim) { char* saveptr; char* token = strtok_r(str,delim,&saveptr); vector<string> result; while(token != NULL) { result.push_back(token); token = strtok_r(NULL,delim,&saveptr); } return result; }
using namespace std; vector<string> split(string s){ regex r ("\\w+"); regex_iterator<string::iterator> rit ( s.begin(), s.end(), r ); regex_iterator<string::iterator> rend; vector<string> result<regex_iterator>(rit, rend); return result; }
string s = "Name:JAck; Spouse:Susan; ..."; string dummy, name, spouse; istringstream iss(s); getline(iss, dummy, getline(iss, name, getline(iss, dummy, getline(iss, spouse,
static void Split(std::vector<std::string>& lst, const std::string& input, const std::string& separators, bool remove_empty = true) { std::ostringstream word; for (size_t n = 0; n < input.size(); ++n) { if (std::string::npos == separators.find(input[n])) word << input[n]; else { if (!word.str().empty() || !remove_empty) lst.push_back(word.str()); word.str(""); } } if (!word.str().empty() || !remove_empty) lst.push_back(word.str()); }
using namespace std; vector<string> split(string data, string token) { vector<string> output; size_t pos = string::npos; do { pos = data.find(token); output.push_back(data.substr(0, pos)); if (string::npos != pos) data = data.substr(pos + token.size()); } while (string::npos != pos); return output; }
const char *whitespace = " \t\r\n\f"; const char *whitespace_and_punctuation = " \t\r\n\f;,="; int main() { { std::string s("Somewhere down the road"); std::vector<std::string> result; if( strtk::parse( s, whitespace, result ) ) { for(size_t i = 0; i < result.size(); ++i ) std::cout << result[i] << std::endl; } } { std::string s("3.0, 3.14; 4.0"); std::vector<float> values; if( strtk::parse( s, whitespace_and_punctuation, values ) ) { for(size_t i = 0; i < values.size(); ++i ) std::cout << values[i] << std::endl; } } { std::string s("angle = 45; radius = 9.9"); std::string w1, w2; float v1, v2; if( strtk::parse( s, whitespace_and_punctuation, w1, v1, w2, v2) ) { std::cout << "word " << w1 << ", value " << v1 << std::endl; std::cout << "word " << w2 << ", value " << v2 << std::endl; } } return 0; }
using namespace std; class StringSplit { private: void copy_fragment(char*, char*, char*); void copy_fragment(char*, char*, char); bool match_fragment(char*, char*, int); int untilnextdelim(char*, char); int untilnextdelim(char*, char*); void assimilate(char*, char); void assimilate(char*, char*); bool string_contains(char*, char*); long calc_string_size(char*); void copy_string(char*, char*); public: vector<char*> split_cstr(char); vector<char*> split_cstr(char*); vector<string> split_string(char); vector<string> split_string(char*); char* String; bool do_string; bool keep_empty; vector<char*> Container; vector<string> ContainerS; StringSplit(char * in) { String = in; } StringSplit(string in) { size_t len = calc_string_size((char*)in.c_str()); String = new char[len + 1]; memset(String, 0, len + 1); copy_string(String, (char*)in.c_str()); do_string = true; } ~StringSplit() { for (int i = 0; i < Container.size(); i++) { if (Container[i] != NULL) { delete[] Container[i]; } } if (do_string) { delete[] String; } } };
using namespace std; void StringSplit::assimilate(char*src, char delim) { int until = untilnextdelim(src, delim); if (until > 0) { char * temp = new char[until + 1]; memset(temp, 0, until + 1); copy_fragment(temp, src, delim); if (keep_empty || *temp != 0) { if (!do_string) { Container.push_back(temp); } else { string x = temp; ContainerS.push_back(x); } } else { delete[] temp; } } } void StringSplit::assimilate(char*src, char* delim) { int until = untilnextdelim(src, delim); if (until > 0) { char * temp = new char[until + 1]; memset(temp, 0, until + 1); copy_fragment(temp, src, delim); if (keep_empty || *temp != 0) { if (!do_string) { Container.push_back(temp); } else { string x = temp; ContainerS.push_back(x); } } else { delete[] temp; } } } long StringSplit::calc_string_size(char* _in) { long i = 0; while (*_in++) { i++; } return i; } bool StringSplit::string_contains(char* haystack, char* needle) { size_t len = calc_string_size(needle); size_t lenh = calc_string_size(haystack); while (lenh--) { if (match_fragment(haystack + lenh, needle, len)) { return true; } } return false; } bool StringSplit::match_fragment(char* _src, char* cmp, int len) { while (len--) { if (*(_src + len) != *(cmp + len)) { return false; } } return true; } int StringSplit::untilnextdelim(char* _in, char delim) { size_t len = calc_string_size(_in); if (*_in == delim) { _in += 1; return len - 1; } int c = 0; while (*(_in + c) != delim && c < len) { c++; } return c; } int StringSplit::untilnextdelim(char* _in, char* delim) { int s = calc_string_size(delim); int c = 1 + s; if (!string_contains(_in, delim)) { return calc_string_size(_in); } else if (match_fragment(_in, delim, s)) { _in += s; return calc_string_size(_in); } while (!match_fragment(_in + c, delim, s)) { c++; } return c; } void StringSplit::copy_fragment(char* dest, char* src, char delim) { if (*src == delim) { src++; } int c = 0; while (*(src + c) != delim && *(src + c)) { *(dest + c) = *(src + c); c++; } *(dest + c) = 0; } void StringSplit::copy_string(char* dest, char* src) { int i = 0; while (*(src + i)) { *(dest + i) = *(src + i); i++; } } void StringSplit::copy_fragment(char* dest, char* src, char* delim) { size_t len = calc_string_size(delim); size_t lens = calc_string_size(src); if (match_fragment(src, delim, len)) { src += len; lens -= len; } int c = 0; while (!match_fragment(src + c, delim, len) && (c < lens)) { *(dest + c) = *(src + c); c++; } *(dest + c) = 0; } vector<char*> StringSplit::split_cstr(char Delimiter) { int i = 0; while (*String) { if (*String != Delimiter && i == 0) { assimilate(String, Delimiter); } if (*String == Delimiter) { assimilate(String, Delimiter); } i++; String++; } String -= i; delete[] String; return Container; } vector<string> StringSplit::split_string(char Delimiter) { do_string = true; int i = 0; while (*String) { if (*String != Delimiter && i == 0) { assimilate(String, Delimiter); } if (*String == Delimiter) { assimilate(String, Delimiter); } i++; String++; } String -= i; delete[] String; return ContainerS; } vector<char*> StringSplit::split_cstr(char* Delimiter) { int i = 0; size_t LenDelim = calc_string_size(Delimiter); while(*String) { if (!match_fragment(String, Delimiter, LenDelim) && i == 0) { assimilate(String, Delimiter); } if (match_fragment(String, Delimiter, LenDelim)) { assimilate(String,Delimiter); } i++; String++; } String -= i; delete[] String; return Container; } vector<string> StringSplit::split_string(char* Delimiter) { do_string = true; int i = 0; size_t LenDelim = calc_string_size(Delimiter); while (*String) { if (!match_fragment(String, Delimiter, LenDelim) && i == 0) { assimilate(String, Delimiter); } if (match_fragment(String, Delimiter, LenDelim)) { assimilate(String, Delimiter); } i++; String++; } String -= i; delete[] String; return ContainerS; }
int main(int argc, char*argv[]) { StringSplit ss = "This:CUT:is:CUT:an:CUT:example:CUT:cstring"; vector<char*> Split = ss.split_cstr(":CUT:"); for (int i = 0; i < Split.size(); i++) { cout << Split[i] << endl; } return 0; }
int main(int argc, char*argv[]) { StringSplit ss = "This:is:an:example:cstring"; vector<char*> Split = ss.split_cstr( for (int i = 0; i < Split.size(); i++) { cout << Split[i] << endl; } return 0; } int main(int argc, char*argv[]) { string mystring = "This[SPLIT]is[SPLIT]an[SPLIT]example[SPLIT]string"; StringSplit ss = mystring; vector<string> Split = ss.split_string("[SPLIT]"); for (int i = 0; i < Split.size(); i++) { cout << Split[i] << endl; } return 0; } int main(int argc, char*argv[]) { string mystring = "This|is|an|example|string"; StringSplit ss = mystring; vector<string> Split = ss.split_string( for (int i = 0; i < Split.size(); i++) { cout << Split[i] << endl; } return 0; }
StringSplit ss = mystring; ss.keep_empty = true; vector<string> Split = ss.split_string(":DELIM:");
String[] Split = "Hey:cut:what foreach(String X in Split) { Console.Write(X); }
using namespace std; vector<string> split(string str, const char delim) { vector<string> v; string tmp; for(string::const_iterator i; i = str.begin(); i <= str.end(); ++i) { if(*i != delim && i != str.end()) { tmp += *i; } else { v.push_back(tmp); tmp = ""; } } return v; }
void split_string(string text,vector<string>& words) { int i=0; char ch; string word; while(ch=text[i++]) { if (isspace(ch)) { if (!word.empty()) { words.push_back(word); } word = ""; } else { word += ch; } } if (!word.empty()) { words.push_back(word); } }
int main() { std::string line("A:::line::to:split"); const boost::regex re(":+"); boost::sregex_token_iterator tokens(line.begin(),line.end(),re,-1); boost::sregex_token_iterator end; for (; tokens != end; ++tokens) std::cout << *tokens << std::endl; }
template<class String> const std::list<String> split_camel_case_string(const String &s) { std::list<String> R; String w; for (String::const_iterator i = s.begin(); i < s.end(); ++i) { { if (std::isupper(*i)) { if (w.length()) { R.push_back(w); w.clear(); } } w += *i; } if (w.length()) R.push_back(w); return R; }
using namespace std; vector<string> split(const string &s, char delim) { vector<string> elems; stringstream ss(s); string item; while (getline(ss, item, delim)) { elems.push_back(item); } return elems; } int main() { vector<string> x = split("thi is an sample test", unsigned int i; for(i=0;i<x.size();i++) cout<<i<<":"<<x[i]<<endl; return 0; }
std::vector<std::string> strs; boost::split(strs, "string to split", boost::is_any_of("\t "));
using namespace std; using namespace boost; int main(int argc, char**argv) { typedef vector < string > list_type; list_type list; string line; line = "Somewhere down the road"; split(list, line, is_any_of(" ")); for(int i = 0; i < list.size(); i++) { cout << list[i] << endl; } return 0; }
class Foo { public: Foo (int foo) : m_foo (foo) { } int GetFoo () { return m_foo; } private: int m_foo; };
class String { public: String(int n); String(const char *p); };
class String { public: explicit String (int n); String(const char *p); };
class Foo { public: Foo(int x) : m_x(x) { } private: int m_x; };
struct Z { }; struct X { explicit X(int a); explicit operator Z (); }; struct Y{ Y(int a); operator Z (); }; void foo(X x) { } void bar(Y y) { } void baz(Z z) { }
foo(2); foo(X(2)); foo(static_cast<X>(2)); bar(2); bar(Y(2)); bar(static_cast<Y>(2));
X x2 = 2; X x3(2); X x4 = X(2); X x5 = static_cast<X>(2); Y y2 = 2; Y y3(2); Y y4 = Y(2); Y y5 = static_cast<Y>(2);
baz(x1); baz(Z(x1)); baz(static_cast<Z>(x1)); baz(y1); baz(Z(y1)); baz(static_cast<Z>(y1));
Z z1 = x1; Z z2(x1); Z z3 = Z(x1); Z z4 = static_cast<Z>(x1); Z z1 = y1; Z z2(y1); Z z3 = Z(y1); Z z4 = static_cast<Z>(y1);
struct V { operator bool() const { return true; } }; struct U { U(V) { } }; void f(U) { } void f(bool) { }
void print_intvector(std::vector<int> const &v) { for (int x : v) std::cout << x <<
class C{ public: explicit C(void) = default; }; int main(void){ C c(); return 0; }
class C{ public: explicit inline operator bool(void) const{ return true; } }; int main(void){ C c; bool b = static_cast<bool>(c); return 0; }
struct A { A(int) { } A(int, int) { } operator bool() const { return true; } }; struct B { explicit B(int) { } explicit B(int, int) { } explicit operator bool() const { return true; } }; int main() { A a1 = 1; A a2(2); A a3 {4, 5}; A a4 = {4, 5}; A a5 = (A)1; if (a1) cout << "true" << endl; bool na1 = a1; bool na2 = static_cast<bool>(a1); B b2(2); B b3 {4, 5}; B b5 = (B)1; if (b5) cout << "true" << endl; bool nb2 = static_cast<bool>(b2); }
class A { public: A(); A(int); A(const char*, int = 0); };
class A { public: explicit A(); explicit A(int); explicit A(const char*, int = 0); };
A a1; A a2 = A(1); A a3(1); A a4 = A("Venditti"); A* p = new A(1); A a5 = (A)1; A a6 = static_cast<A>(1);
template <typename FloatType> inline FloatType compute_something(FloatType x) { using namespace std; return exp(x) * (sin(x) - cos(x * 2) + sin(x * 3) - cos(x * 4)); }
class Thing { int value_; Child child_; public: friend void swap(Thing &a, Thing &b); }; void swap(Thing &a, Thing &b) { using namespace std; swap(a.value_, b.value_); swap(a.child_, b.child_); }
namespace My_lib { using namespace His_lib; using namespace Her_lib; using His_lib::String; using Her_lib::Vector; }
namespace Mylib{ template<class T> class Stack{ }; / / ... } namespace Yourlib{ class Stack{ }; / / ... } void f(int max) { Mylib: :Stack<int> s1(max) ; / / use my stack Yourlib: :Stack s2(max) ; / / use your stack / / ... }
void f(int max) { using namespace Mylib; / / make names from Mylib accessible Stack<int> s1(max) ; / / use my stack Yourlib: :Stack s2(max) ; / / use your stack / / ... }
namespace foo { void a(float) { } } namespace bar { ... }
using namespace foo; using namespace bar; void main() { a(42); }
using namespace foo; using namespace bar; void main() { a(42); }
class File { typedef std::vector<std::string> Lines; Lines ReadLines(); }
Lines File::ReadLines() { Lines lines; return lines; }
vector<string> File::ReadLines() { vector<string> lines; return lines; }
std::vector<std::string> File::ReadLines() { std::vector<std::string> lines; return lines; }
using namespace std; int count = 1; int main() { cout<<count<<endl; }
namespace std { using boost::regex; using boost::regex_error; using boost::regex_replace; using boost::regex_search; using boost::regex_match; using boost::smatch; namespace regex_constants = boost::regex_constants; }
OnEventData(void* pData) { ...... EventData *evtdata = static_cast<EventData*>(pData); ..... }
void DebugLog::OnMessage(Message *msg) { static DebugMsgData *debug; static XYZMsgData *xyz; if(debug = dynamic_cast<DebugMsgData*>(msg->pdata)){ } else if(xyz = dynamic_cast<XYZMsgData*>(msg->pdata)){ } else/* if( ... )*/{ } }
const unsigned char *Passwd const_cast<unsigned char*>(Passwd)
typedef unsigned short uint16; bool ByteBuffer::ReadUInt16(uint16& val) { return ReadBytes(reinterpret_cast<char*>(&val), 2); }
..... INetFwPolicy2* pNetFwPolicy2 = nullptr; HRESULT hr = CoCreateInstance(__uuidof(NetFwPolicy2), nullptr, CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2), reinterpret_cast<void**>(&pNetFwPolicy2) );
..... INetFwPolicy2* pNetFwPolicy2 = nullptr; void* tmp = nullptr; HRESULT hr = CoCreateInstance(__uuidof(NetFwPolicy2), nullptr, CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2), &tmp ); pNetFwPolicy2 = static_cast<INetFwPolicy2*>(tmp);
int a=rand(); int* pa1=reinterpret_cast<int*>(a); int* pa2=static_cast<int*>(a); int* pa3=dynamic_cast<int*>(a); int* pa4=(int*) a; *pa4=5;
struct Foo{}; struct Bar{}; int main(int argc, char** argv) { Foo* f = new Foo; Bar* b1 = f; Bar* b2 = static_cast<Bar*>(f); Bar* b3 = dynamic_cast<Bar*>(f); Bar* b4 = reinterpret_cast<Bar*>(f); Bar* b5 = const_cast<Bar*>(f); return 0; }
X& X::operator=(X rhs) { swap(rhs); return *this; }
std::ostream& operator<<(std::ostream& os, const T& obj) { return os; } std::istream& operator>>(std::istream& is, T& obj) { if( ) is.setstate(std::ios::failbit); return is; }
class foo { public: int operator()(const std::string& y) { } };
inline bool operator==(const X& lhs, const X& rhs){ } inline bool operator!=(const X& lhs, const X& rhs){return !operator==(lhs,rhs);} inline bool operator< (const X& lhs, const X& rhs){ } inline bool operator> (const X& lhs, const X& rhs){return operator< (rhs,lhs);} inline bool operator<=(const X& lhs, const X& rhs){return !operator> (lhs,rhs);} inline bool operator>=(const X& lhs, const X& rhs){return !operator< (lhs,rhs);}
bool operator<(const X& rhs) const { /* do actual comparison with *this */ }
class X { X& operator++() { return *this; } X operator++(int) { X tmp(*this); operator++(); return tmp; } };
class X { X& operator+=(const X& rhs) { return *this; } }; inline X operator+(X lhs, const X& rhs) { lhs += rhs; return lhs; }
class X { value_type& operator[](index_type idx); const value_type& operator[](index_type idx) const; };
class my_ptr { value_type& operator*(); const value_type& operator*() const; value_type* operator->(); const value_type* operator->() const; };
class my_string { public: operator const char*() const {return data_;} private: const char* data_; };
void f(my_string&); void f(const char*); f(my_string());
class my_string { public: explicit operator const char*() const {return data_;} private: const char* data_; };
void* operator new(std::size_t) throw(std::bad_alloc); void operator delete(void*) throw(); void* operator new[](std::size_t) throw(std::bad_alloc); void operator delete[](void*) throw();
class X { }; char buffer[ sizeof(X) ]; void f() { X* p = new(buffer) X( ); p->~X(); }
void* operator new(std::size_t,void* p) throw(std::bad_alloc); void operator delete(void* p,void*) throw(); void* operator new[](std::size_t,void* p) throw(std::bad_alloc); void operator delete[](void* p,void*) throw();
class my_class { public: void* operator new(); void operator delete(void*,std::size_t); void* operator new[](size_t); void operator delete[](void*,std::size_t); };
struct Foo { int a; double b; std::ostream& operator<<(std::ostream& out) const { return out << a << " " << b; } };
struct Foo { int a; double b; }; std::ostream& operator<<(std::ostream& out, Foo const& f) { return out << f.a << " " << f.b; }
class person { std::string name; int age; public: person(const std::string& name, int age) : name(name), age(age) { } }; int main() { person a("Bjarne Stroustrup", 60); person b(a); b = a; }
person(const person& that) : name(that.name), age(that.age) { } person& operator=(const person& that) { name = that.name; age = that.age; return *this; } ~person() { }
class person { char* name; int age; public: person(const char* the_name, int the_age) { name = new char[strlen(the_name) + 1]; strcpy(name, the_name); age = the_age; } ~person() { delete[] name; } };
person(const person& that) { name = new char[strlen(that.name) + 1]; strcpy(name, that.name); age = that.age; } person& operator=(const person& that) { if (this != &that) { delete[] name; name = new char[strlen(that.name) + 1]; strcpy(name, that.name); age = that.age; } return *this; }
person& operator=(const person& that) { char* local_name = new char[strlen(that.name) + 1]; strcpy(local_name, that.name); delete[] name; name = local_name; age = that.age; return *this; }
private: person(const person& that); person& operator=(const person& that);
person(const person& that) = delete; person& operator=(const person& that) = delete;
class person { std::string name; int age; public: person(const std::string& name, int age); person(const person &) = default; person(person &&) noexcept = default; person& operator=(const person &) = default; person& operator=(person &&) noexcept = default; ~person() noexcept = default; };
class Car { private String sPrintColor; private String sModel; private String sMake; public changePaint(String newColor) { this.sPrintColor = newColor; } public Car(String model, String make, String color) { this.sPrintColor = color; this.sModel = model; this.sMake = make; } public ~Car() { } public Car(const Car &other) { this.sPrintColor = other.sPrintColor; this.sModel = other.sModel; this.sMake = other.sMake; } public Car &operator =(const Car &other) { if(this != &other) { this.sPrintColor = other.sPrintColor; this.sModel = other.sModel; this.sMake = other.sMake; } return *this; } }
Car car1 = new Car("mustang", "ford", "red"); Car car2 = car1; car2.changePaint("green");
Car car1 = new Car("ford", "mustang", "red"); Car car2 = car1; car2.changePaint("green"); delete car2; car1.changePaint("red");
class MemoryBlock { public: private: MemoryBlock(const MemoryBlock& other) { cout<<"copy constructor"<<endl; } MemoryBlock& operator=(const MemoryBlock& other) { return *this; } }; int main() { MemoryBlock a; MemoryBlock b(a); }
class MemoryBlock { public: MemoryBlock(const MemoryBlock& other) = delete MemoryBlock& operator=(const MemoryBlock& other) =delete }; int main() { MemoryBlock a; MemoryBlock b(a); }
class dumb_array { public: dumb_array(std::size_t size = 0) : mSize(size), mArray(mSize ? new int[mSize]() : nullptr) { } dumb_array(const dumb_array& other) : mSize(other.mSize), mArray(mSize ? new int[mSize] : nullptr), { std::copy(other.mArray, other.mArray + mSize, mArray); } ~dumb_array() { delete [] mArray; } private: std::size_t mSize; int* mArray; };
dumb_array& operator=(const dumb_array& other) { if (this != &other) { delete [] mArray; mArray = nullptr; mSize = other.mSize; mArray = mSize ? new int[mSize] : nullptr; std::copy(other.mArray, other.mArray + mSize, mArray); } return *this; }
dumb_array& operator=(const dumb_array& other) { if (this != &other) { std::size_t newSize = other.mSize; int* newArray = newSize ? new int[newSize]() : nullptr; std::copy(other.mArray, other.mArray + newSize, newArray); delete [] mArray; mSize = newSize; mArray = newArray; } return *this; }
class dumb_array { public: friend void swap(dumb_array& first, dumb_array& second) { using std::swap; swap(first.mSize, second.mSize); swap(first.mArray, second.mArray); } };
dumb_array& operator=(dumb_array other) { swap(*this, other); return *this; }
dumb_array& operator=(const dumb_array& other) { dumb_array temp(other); swap(*this, temp); return *this; }
class dumb_array { public: dumb_array(dumb_array&& other) : dumb_array() { swap(*this, other); } };
T& operator=(T tmp) { this->swap(tmp); return *this; }
struct X { T* p_; size_t size_; X& operator=(const X& rhs) { delete[] p_; p_ = new T[size_ = rhs.size_]; std::copy(p_, rhs.p_, rhs.p_ + rhs.size_); } ... };
struct Client { IP_Address ip_address_; int socket_; X(const X& rhs) : ip_address_(rhs.ip_address_), socket_(connect(rhs.ip_address_)) { } };
friend void swap(A& first, A& second) { std::swap(first.size, second.size); std::swap(first.arr, second.arr); }
void swap(A& other) { std::swap(size, other.size); std::swap(arr, other.arr); }
void fs(std::vector<T, A> & a, std::vector<T, A> & b) { a.swap(b); b.clear(); } void fm(std::vector<T, A> & a, std::vector<T, A> & b) { a = std::move(b); }
Global int x, y; Thread 1 Thread 2 x = 17; cout << y << " "; y = 37; cout << x << endl;
Global atomic<int> x, y; Thread 1 Thread 2 x.store(17); cout << y.load() << " "; y.store(37); cout << x.load() << endl;
Global atomic<int> x, y; Thread 1 Thread 2 x.store(17,memory_order_relaxed); cout << y.load(memory_order_relaxed) << " "; y.store(37,memory_order_relaxed); cout << x.load(memory_order_relaxed) << endl;
Global atomic<int> x, y; Thread 1 Thread 2 x.store(17,memory_order_release); cout << y.load(memory_order_acquire) << " "; y.store(37,memory_order_release); cout << x.load(memory_order_acquire) << endl;
$ $ mkdir Family $ mkdir Family/Son $ mkdir Family/Son/Daughter $ mkdir Family/Son/Father $ mkdir Family/Son/Daughter/Father $ ln -s Family/Son/Daughter/Father Family/Son/Father $ mkdir Family/Son/Daughter/Wife $ tree Family Family └── Son ├── Daughter │ ├── Father │ └── Wife └── Father -> Family/Son/Daughter/Father 4 directories, 1 file
Prior P(f=x) x P(o=2/2|f=x) P(o=2/2&&f=x) P(o=2/2&&f >= x) P(f >= x) 0.1 1 1 0.1 0.1 0.25974026 0.1 0.9 0.81 0.081 0.181 0.47012987 0.1 0.8 0.64 0.064 0.245 0.636363636 0.1 0.7 0.49 0.049 0.294 0.763636364 0.1 0.6 0.36 0.036 0.33 0.857142857 0.1 0.5 0.25 0.025 0.355 0.922077922 0.1 0.4 0.16 0.016 0.371 0.963636364 0.1 0.3 0.09 0.009 0.38 0.987012987 0.1 0.2 0.04 0.004 0.384 0.997402597 0.1 0.1 0.01 0.001 0.385 1 P(o=2/2) 0.385
Prior P(f=x) x P(o=2/2|f=x) P(o=2/2&& f=x) P(o=2/2&&f >= x) P(f >= x) 0.001 1 1 0.001 0.001 0.072727273 0.001 0.9 0.81 0.00081 0.00181 0.131636364 0.001 0.8 0.64 0.00064 0.00245 0.178181818 0.001 0.7 0.49 0.00049 0.00294 0.213818182 0.001 0.6 0.36 0.00036 0.0033 0.24 0.001 0.5 0.25 0.00025 0.00355 0.258181818 0.001 0.4 0.16 0.00016 0.00371 0.269818182 0.001 0.3 0.09 0.00009 0.0038 0.276363636 0.001 0.2 0.04 0.00004 0.00384 0.279272727 0.991 0.1 0.01 0.00991 0.01375 1 P(o=2/2) 0.01375
valgrind --tool=callgrind --dump-instr=yes -v --instr-atstart=no ./binary > tmp
MyClass *m = (MyClass *)ptr; MyClass *m = static_cast<MyClass *>(ptr); MyClass *m = dynamic_cast<MyClass *>(ptr);
void func(void *data) { MyClass *c = static_cast<MyClass*>(data); ... } int main() { MyClass c; start_thread(&func, &c) .join(); }
if (JumpStm *j = dynamic_cast<JumpStm*>(&stm)) { ... } else if (ExprStm *e = dynamic_cast<ExprStm*>(&stm)) { ... }
struct Base { }; struct Derived : Base { }; int main() { Derived d; Base *b = &d; dynamic_cast<Derived*>(b); }
class MyBase { public: virtual void test() {} }; class MyChild : public MyBase {}; int main() { MyChild *child = new MyChild(); MyBase *base = dynamic_cast<MyBase*>(child); }
MyBase *base = new MyBase(); MyChild *child = dynamic_cast<MyChild*>(base); if (child == 0) std::cout << "Null pointer returned";
try { MyChild &child = dynamic_cast<MyChild&>(*base); } catch(std::bad_cast &e) { std::cout << e.what(); }
MyChild *child = static_cast<MyChild*>(base); (*child);
const int myConst = 5; int *nonConst = const_cast<int*>(&myConst);
MyObject* ptr = new MyObject(); ptr->DoSomething(); delete ptr;
SomeSmartPtr<MyObject> ptr(new MyObject()); ptr->DoSomething();
void f() { { boost::scoped_ptr<MyObject> ptr(new MyObject()); ptr->DoSomethingUseful(); } }
void f() { typedef std::shared_ptr<MyObject> MyObjectPtr; MyObjectPtr p1; { MyObjectPtr p2(new MyObject()); p1 = p2; } }
struct Owner { boost::shared_ptr<Owner> other; }; boost::shared_ptr<Owner> p1 (new Owner()); boost::shared_ptr<Owner> p2 (new Owner()); p1->other = p2; p2->other = p1;
std::auto_ptr<MyObject> p1 (new MyObject()); std::auto_ptr<MyObject> p2 = p1; p2->DoSomething(); p1->DoSomething();
template <class X> class smart_pointer { public: smart_pointer(); smart_pointer(const X& x) X& operator *( ); const X& operator*( ) const; X* operator->() const; smart_pointer(const smart_pointer <X> &); const smart_pointer <X> & operator =(const smart_pointer<X>&); ~smart_pointer(); private: };
smart_pointer <employee> p= employee("Harris",1333);
T a ; shared_ptr<T> shptr = make_shared<T>(); std::cout << shptr.use_count() ; things " pointing to it. T * temp = shptr.get(); shptr->memFn(); (*shptr).memFn(); // shptr.reset() ; shptr = nullptr ; shptr = make_shared<T>() ;
T a ; shared_ptr<T> shr = make_shared<T>() ; weak_ptr<T> wk = shr ; wk.lock()->memFn() ; if(!wk.expired()) wk.lock()->memFn() ;
unique_ptr<T> uptr(new T); uptr->memFn(); uptr.reset() ;
unique_ptr<T> uptr1(new T); unique_ptr<T> uptr2(new T); uptr2 = std::move(uptr1);
r-value reference : reference to a temporary object l-value reference : reference to an object whose address can be obtained const reference : reference to a data type which is const and cannot be modified
template<typename T> struct Foo { T bar; void doSomething(T param) { } }; Foo<int> f;
struct FooInt { int bar; void doSomething(int param) { } }
template <typename T> struct Foo { void doSomething(T param); }; template <typename T> void Foo<T>::doSomething(T param) { }
template <typename T> struct Foo { ... }; template class Foo<int>; template class Foo<float>;
template < typename ... > class MyClass { int myMethod() { } };
template <class T> class MyTemplate { public: MyTemplate(const T& rt); void dump(); T t; };
template <class T> MyTemplate<T>::MyTemplate(const T& rt) : t(rt) { } template <class T> void MyTemplate<T>::dump() { cerr << t << endl; }
int main() { MyInstantiatedTemplate m(100); m.dump(); return 0; }
template <typename T> struct Foo { void doSomething(T param); }; template <typename T> void Foo<T>::doSomething(T param) { }
template <class T> class QueueA { int size; ... public: template <class T> T dequeue() { } bool isEmpty(); ... }
template <class T> bool QueueA<T>::isEmpty() { return this->size == 0; } main() { QueueA<char> Q; ... }
class string { char* data; public: string(const char* p) { size_t size = strlen(p) + 1; data = new char[size]; memcpy(data, p, size); }
~string() { delete[] data; } string(const string& that) { size_t size = strlen(that.data) + 1; data = new char[size]; memcpy(data, that.data, size); }
string a(x); string b(x + y); string c(some_function_returning_a_string());
string(string&& that) { data = that.data; that.data = nullptr; }
string& operator=(string that) { std::swap(data, that.data); return *this; } };
class cannot_benefit_from_move_semantics { int a; float b; double c; char d[64]; };
auto_ptr<Shape> a(new Triangle); +---------------+ | triangle data | +---------------+ ^ | | | +-----|---+ | +-|-+ | a | p | | | | | +---+ | +---------+ auto_ptr<Shape> b(a); +---------------+ | triangle data | +---------------+ ^ | +----------------------+ | +---------+ +-----|---+ | +---+ | | +-|-+ | a | p | | | b | p | | | | | +---+ | | +---+ | +---------+ +---------+
auto_ptr(auto_ptr& source) { p = source.p; source.p = 0; }
auto_ptr<Shape> a(new Triangle); auto_ptr<Shape> b(a); double area = a->area();
auto_ptr<Shape> make_triangle() { return auto_ptr<Shape>(new Triangle); } auto_ptr<Shape> c(make_triangle()); double area = make_triangle()->area();
auto_ptr<Shape> variable(expression); double area = expression->area();
auto_ptr<Shape> c(make_triangle()); ^ the moved-from temporary dies right here
lvalue const lvalue rvalue const rvalue --------------------------------------------------------- X& yes const X& yes yes yes yes X&& yes const X&& yes yes
void some_function(std::string&& r); some_function("hello world");
template<typename T> class unique_ptr { T* ptr; public: T* operator->() const { return ptr; } T& operator*() const { return *ptr; }
explicit unique_ptr(T* p = nullptr) { ptr = p; } ~unique_ptr() { delete ptr; }
unique_ptr(unique_ptr&& source) { ptr = source.ptr; source.ptr = nullptr; }
unique_ptr<Shape> a(new Triangle); unique_ptr<Shape> b(a); unique_ptr<Shape> c(make_triangle());
unique_ptr& operator=(unique_ptr&& source) { if (this != &source) { delete ptr; ptr = source.ptr; source.ptr = nullptr; } return *this; } };
unique_ptr& operator=(unique_ptr source) { std::swap(ptr, source.ptr); return *this; } };
unique_ptr<Shape> a(new Triangle); unique_ptr<Shape> b(a); unique_ptr<Shape> c(std::move(a));
expressions / \ / \ / \ glvalues rvalues / \ / \ / \ / \ / \ / \ lvalues xvalues prvalues
unique_ptr<Shape> make_triangle() { return unique_ptr<Shape>(new Triangle); } \-----------------------------/ | | temporary is moved into c | v unique_ptr<Shape> c(make_triangle());
unique_ptr<Shape> make_square() { unique_ptr<Shape> result(new Square); return result; }
unique_ptr<Shape>&& flawed_attempt() { unique_ptr<Shape> very_bad_idea(new Square); return std::move(very_bad_idea); }
class Foo { unique_ptr<Shape> member; public: Foo(unique_ptr<Shape>&& parameter) : member(parameter) {} };
class Foo { unique_ptr<Shape> member; public: Foo(unique_ptr<Shape>&& parameter) : member(std::move(parameter)) {} };
X::X(const X&); X& X::operator=(const X&); X::~X();
X& X::operator=(X source) { swap(source); return *this; }
foo(make_triangle()); unique_ptr<Shape> a(new Triangle); foo(a);
template<typename T> typename std::enable_if<std::is_rvalue_reference<T&&>::value, void>::type foo(T&&);
template<typename T> typename std::remove_reference<T>::type&& move(T&& t) { return static_cast<typename std::remove_reference<T>::type&&>(t); }
class X { public: X(X&& rhs) : data_() { this->swap(std::move(rhs)); } void swap(X&& rhs); }; X f(); X x = f();
class A { int i, *p; public: A(const A& a) : i(a.i), p(new int(*a.p)) {} ~A() { delete p; } };
class A { int i, *p; public: A(const A& a) : i(a.i), p(a.p) { a.p = nullptr; } ~A() { delete p; } };
class A { int i, *p; public: A(const A& a) : i(a.i), p(new int(*a.p)) {} A(A&& a) : i(a.i), p(a.p) { a.p = nullptr; } ~A() { delete p; } };
class Heavy { bool b_moved; public: A(const A& a) { } A(A&& a) : { a.b_moved = true; } ~A() { if (!b_moved) } };
template<typename T> void some_function(T&& a) { other_function(std::forward<T>(a)); }
T::T(T &old) { copy_data(m_a, old.m_a); copy_data(m_b, old.m_b); copy_data(m_c, old.m_c); }
T::T(T &&old) noexcept { m_a = std::move(old.m_a); m_b = std::move(old.m_b); m_c = std::move(old.m_c); }
Comparison Subtraction ---------- ----------- A < B --> A - B < 0 A = B --> A - B = 0 A > B --> A - B > 0
Comparison Subtraction Carry Bit Zero Bit ---------- ----------- --------- -------- A < B --> A - B < 0 0 0 A = B --> A - B = 0 1 1 A > B --> A - B > 0 1 0
;; Implementation of "if (A < B) goto address;" cmp A, B ;; compare A to B bcz address ;; Branch if Carry is Zero to the new address
;; Implementation of "if (A <= B) goto address;" cmp A, B ;; compare A to B bcz address ;; branch if A < B bzs address ;; also, Branch if the Zero bit is Set
if(a < 901) cmpl $900, -4(%rbp) jg .L2 if(a <=901) cmpl $901, -4(%rbp) jg .L3
int b; if(a < b) cmpl -4(%rbp), %eax jge .L2 if(a <=b) cmpl -4(%rbp), %eax jg .L3
int compare_strict(double a, double b) { return a < b; }
int compare_loose(double a, double b) { return a <= b; }
int compare_loose(double a, double b) { return ! (a > b); }
const float x[16] = { 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6}; const float z[16] = {1.123, 1.234, 1.345, 156.467, 1.578, 1.689, 1.790, 1.812, 1.923, 2.034, 2.145, 2.256, 2.367, 2.478, 2.589, 2.690}; float y[16]; for (int i = 0; i < 16; i++) { y[i] = x[i]; } for (int j = 0; j < 9000000; j++) { for (int i = 0; i < 16; i++) { y[i] *= x[i]; y[i] /= z[i]; y[i] = y[i] + 0.1f; y[i] = y[i] - 0.1f; } }
const float x[16] = { 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6}; const float z[16] = {1.123, 1.234, 1.345, 156.467, 1.578, 1.689, 1.790, 1.812, 1.923, 2.034, 2.145, 2.256, 2.367, 2.478, 2.589, 2.690}; float y[16]; for (int i = 0; i < 16; i++) { y[i] = x[i]; } for (int j = 0; j < 9000000; j++) { for (int i = 0; i < 16; i++) { y[i] *= x[i]; y[i] /= z[i]; y[i] = y[i] + 0; y[i] = y[i] - 0; } }
int main() { double start = omp_get_wtime(); const float x[16]={1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6}; const float z[16]={1.123,1.234,1.345,156.467,1.578,1.689,1.790,1.812,1.923,2.034,2.145,2.256,2.367,2.478,2.589,2.690}; float y[16]; for(int i=0;i<16;i++) { y[i]=x[i]; } for(int j=0;j<9000000;j++) { for(int i=0;i<16;i++) { y[i]*=x[i]; y[i]/=z[i]; y[i]=y[i]+0.1f; y[i]=y[i]-0.1f; y[i]=y[i]+0; y[i]=y[i]-0; if (j > 10000) cout << y[i] << " "; } if (j > 10000) cout << endl; } double end = omp_get_wtime(); cout << end - start << endl; system("pause"); return 0; }
1.78814e-007 1.3411e-007 1.04308e-007 0 7.45058e-008 6.70552e-008 6.70552e-008 5.58794e-007 3.05474e-007 2.16067e-007 1.71363e-007 1.49012e-007 1.2666e-007 1.11759e-007 1.04308e-007 1.04308e-007 1.78814e-007 1.3411e-007 1.04308e-007 0 7.45058e-008 6.70552e-008 6.70552e-008 5.58794e-007 3.05474e-007 2.16067e-007 1.71363e-007 1.49012e-007 1.2666e-007 1.11759e-007 1.04308e-007 1.04308e-007 6.30584e-044 3.92364e-044 3.08286e-044 0 1.82169e-044 1.54143e-044 2.10195e-044 2.46842e-029 7.56701e-044 4.06377e-044 3.92364e-044 3.22299e-044 3.08286e-044 2.66247e-044 2.66247e-044 2.24208e-044 6.30584e-044 3.92364e-044 3.08286e-044 0 1.82169e-044 1.54143e-044 2.10195e-044 2.45208e-029 7.56701e-044 4.06377e-044 3.92364e-044 3.22299e-044 3.08286e-044 2.66247e-044 2.66247e-044 2.24208e-044
0.1f: 0.564067 0 : 26.7669 0.1f: 0.587117 0 : 0.341406
73c68,69 < movss LCPI1_0(%rip), %xmm1 --- > movabsq $0, %rcx > cvtsi2ssq %rcx, %xmm1 81d76 < subss %xmm1, %xmm0
0.000000000000000000000000000000000100000004670110: 10111100001101110010000011100000 45 ms 0.000000000000000000000000000000000050000002335055: 10111100001101110010000101100000 43 ms 0.000000000000000000000000000000000025000001167528: 10111100001101110010000001100000 43 ms 0.000000000000000000000000000000000012500000583764: 10111100001101110010000110100000 42 ms 0.000000000000000000000000000000000006250000291882: 10111100001101110010000010100000 48 ms 0.000000000000000000000000000000000003125000145941: 10111100001101110010000100100000 43 ms 0.000000000000000000000000000000000001562500072970: 10111100001101110010000000100000 42 ms 0.000000000000000000000000000000000000781250036485: 10111100001101110010000111000000 42 ms 0.000000000000000000000000000000000000390625018243: 10111100001101110010000011000000 42 ms 0.000000000000000000000000000000000000195312509121: 10111100001101110010000101000000 43 ms 0.000000000000000000000000000000000000097656254561: 10111100001101110010000001000000 42 ms 0.000000000000000000000000000000000000048828127280: 10111100001101110010000110000000 44 ms 0.000000000000000000000000000000000000024414063640: 10111100001101110010000010000000 42 ms 0.000000000000000000000000000000000000012207031820: 10111100001101110010000100000000 42 ms 0.000000000000000000000000000000000000006103515209: 01111000011011100100001000000000 789 ms 0.000000000000000000000000000000000000003051757605: 11110000110111001000010000000000 788 ms 0.000000000000000000000000000000000000001525879503: 00010001101110010000100000000000 788 ms 0.000000000000000000000000000000000000000762939751: 00100011011100100001000000000000 795 ms 0.000000000000000000000000000000000000000381469876: 01000110111001000010000000000000 896 ms 0.000000000000000000000000000000000000000190734938: 10001101110010000100000000000000 813 ms 0.000000000000000000000000000000000000000095366768: 00011011100100001000000000000000 798 ms 0.000000000000000000000000000000000000000047683384: 00110111001000010000000000000000 791 ms 0.000000000000000000000000000000000000000023841692: 01101110010000100000000000000000 802 ms 0.000000000000000000000000000000000000000011920846: 11011100100001000000000000000000 809 ms 0.000000000000000000000000000000000000000005961124: 01111001000010000000000000000000 795 ms 0.000000000000000000000000000000000000000002980562: 11110010000100000000000000000000 835 ms 0.000000000000000000000000000000000000000001490982: 00010100001000000000000000000000 864 ms 0.000000000000000000000000000000000000000000745491: 00101000010000000000000000000000 915 ms 0.000000000000000000000000000000000000000000372745: 01010000100000000000000000000000 918 ms 0.000000000000000000000000000000000000000000186373: 10100001000000000000000000000000 881 ms 0.000000000000000000000000000000000000000000092486: 01000010000000000000000000000000 857 ms 0.000000000000000000000000000000000000000000046243: 10000100000000000000000000000000 861 ms 0.000000000000000000000000000000000000000000022421: 00001000000000000000000000000000 855 ms 0.000000000000000000000000000000000000000000011210: 00010000000000000000000000000000 887 ms 0.000000000000000000000000000000000000000000005605: 00100000000000000000000000000000 799 ms 0.000000000000000000000000000000000000000000002803: 01000000000000000000000000000000 828 ms 0.000000000000000000000000000000000000000000001401: 10000000000000000000000000000000 815 ms 0.000000000000000000000000000000000000000000000000: 00000000000000000000000000000000 42 ms 0.000000000000000000000000000000000000000000000000: 00000000000000000000000000000000 42 ms 0.000000000000000000000000000000000000000000000000: 00000000000000000000000000000000 44 ms
_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON); _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
void enableFtzDaz() { int mxcsr = _mm_getcsr (); if (FTZ) { mxcsr |= (1<<15) | (1<<11); } if (DAZ) { mxcsr |= (1<<6); } _mm_setcsr (mxcsr); }
class Base { ... }; class Derived : public Base { ... }; void fun(Base b) { ... } void gun(Base* b) { ... } void hun(Base& b) { ... } Derived d; fun(d); gun(&d); hun(d);
Object object1 = new Object(); Object object2 = new Object(); object1 = object2;
Object * object1 = new Object(); Object * object2 = new Object(); delete object1; object1 = object2;
int * pointer; std::cout << "How many items do you need?"; std::cin >> n; pointer = new int[n];
int arr[5] = {1, 2, 3, 4, 5}; int arr[] = {1, 2, 3, 4, 5}; arr = { 1, 2, 3, 4, 5 };
std::vector<Base*> vector; vector.push_back(&square); vector.push_back(&triangle); for (auto& e : vector) { auto test = dynamic_cast<Triangle*>(e); if (!test) e.GenericFunction(); else e.TriangleOnlyMagic(); }
struct MyStruct { int* someIntPointer, someInt; MyStruct *somePointer; MyStruct &someReference; }; MyStruct s1; s1.someInt = 1; s1.someIntPointer = &s1.someInt; *s1.someIntPointer = 2; s1.somePointer = &s1; s1.someReference = s1; s1.somePointer->someInt = 3; *(s1.somePointer).someInt = 3; *s1.somePointer->someIntPointer = 4; s1.someReference.someInt = 5; MyStruct s2 = s1; s2.someInt = 0;
std::shared_ptr<std::string> safe_str = make_shared<std::string>("make_shared"); std::unique_ptr<std::string> safe_str = make_unique<std::string>("make_shared");
Class Base1 { }; Class Derived1 : public Base1 { }; Class Base2 { Base *bObj; virtual void createMemerObects() = 0; }; Class Derived2 { virtual void createMemerObects() { bObj = new Derived1(); } };
class Item { public: std::string name; int weight; int price; };
int a = 10; char *intStr = itoa(a); string str = string(intStr);
int a = 10; stringstream ss; ss << a; string str = ss.str();
template < typename... Args > std::string sstr( Args &&... args ) { std::ostringstream sstr; ( sstr << std::dec << ... << args ); return sstr.str(); }
int i = 42; std::string s = sstr( "i is: ", i ); puts( sstr( i ).c_str() ); Foo x( 42 ); throw std::runtime_error( sstr( "Foo is
int i = 42; std::string s = SSTR( "i is: " << i ); puts( SSTR( i ).c_str() ); Foo x( 42 ); throw std::runtime_error( SSTR( "Foo is
template <typename T> std::string NumberToString ( T Number ) { std::ostringstream ss; ss << Number; return ss.str(); }
int num = 4; std::string str = boost::lexical_cast<std::string>(num);
int x=42; string str; ostringstream temp; temp<<x; str=temp.str();
string IntToString (int a) { ostringstream temp; temp<<a; return temp.str(); }
template <typename T> string NumberToString(T pNumber) { ostringstream oOStrStream; oOStrStream << pNumber; return oOStrStream.str(); }
int x = 69; string vStr = NumberToString(x) + " Hello word!."
int main() { int x = 5; std::string x_str = boost::lexical_cast<std::string>(x); return 0; }
int main() { int x = 5; char * x_str = new char[2]; x_str = itoa(x, x_str, 10); return 0; }
int main() { int x = 5; char * x_str = new char[2]; int chars_written = sprintf(x_str, "%d", x); return 0; }
int main() { int x = 5; std::ostringstream stream; stream << x; std::string x_str = stream.str(); return 0; }
struct strmake { std::stringstream s; template <typename T> strmake& operator << (const T& x) { s << x; return *this; } operator std::string() {return s.str();} };
int main() { std::string x = strmake() << "Current time is " << 5+5 << ":" << 5*5 << " GST"; std::cout << x << std::endl; }
namespace std { inline string to_string(int _Val) { char _Buf[2 * _MAX_INT_DIG]; snprintf(_Buf, "%d", _Val); return (string(_Buf)); } }
int myint = 0; long double myLD = 0.0; string myint_str = static_cast<ostringstream*>( &(ostringstream() << myint) )->str(); string myLD_str = static_cast<ostringstream*>( &(ostringstream() << myLD) )->str();
string number_to_string(int x){ if(!x) return "0"; string s,s2; while(x){ s.push_back(x%10 + x/=10; } reverse(s.begin(),s.end()); return s; }
char str[100] ; sprintf(str , "%d" , 101 ) ; string s = str;
std::string intToString(int num); int main() { int integer = 4782151; std::string integerAsStr = intToString(integer); std::cout << "integer = " << integer << std::endl; std::cout << "integerAsStr = " << integerAsStr << std::endl; return 0; } std::string intToString(int num) { std::string numAsStr; while (num) { char toInsert = (num % 10) + 48; numAsStr.insert(0, 1, toInsert); num /= 10; } return numAsStr; }
char * bufSecs = new char[32]; char * bufMs = new char[32]; sprintf(bufSecs,"%d",timeStart.elapsed()/1000); sprintf(bufMs,"%d",timeStart.elapsed()%1000);
string toString(int n) { stringstream ss(n); ss << n; return ss.str(); } int main() { int n; cin>>n; cout<<toString(n)<<endl; return 0; }
*(int32_t*)s = 0x303030 | (n/100) | (n/10%10) << 8 | (n%10) << 16;
*(int64_t*)s = 0x30303030 | (n/1000) | (n/100%10)<<8 | (n/10%10)<<16 | (n%10)<<24;
class Base { }; class Derived : public Base { ~Derived() { } };
using namespace std; class Base { public: Base(){ cout << "Base Constructor Called\n"; } ~Base(){ cout << "Base Destructor called\n"; } }; class Derived1: public Base { public: Derived1(){ cout << "Derived constructor called\n"; } ~Derived1(){ cout << "Derived destructor called\n"; } }; int main() { Base *b = new Derived1(); delete b; }
using namespace std; class Base { public: Base(){ cout << "Base Constructor Called\n"; } virtual ~Base(){ cout << "Base Destructor called\n"; } }; class Derived1: public Base { public: Derived1(){ cout << "Derived constructor called\n"; } ~Derived1(){ cout << "Derived destructor called\n"; } }; int main() { Base *b = new Derived1(); delete b; }
struct Base { virtual void f() {} virtual ~Base() {} }; struct Derived : Base { void f() override {} ~Derived() override {} }; Base* base = new Derived; base->f(); base->~Base();
struct Base { virtual void f() = 0; protected: ~Base() = default; }; void CallsF(Base& base); struct Derived : Base { void f() override { ... } }; int main() { Derived derived; CallsF(derived); }
using namespace std; class B{ public: B(){ cout<<"B()\n"; } virtual ~B(){ cout<<"~B()\n"; } }; class D: public B{ public: D(){ cout<<"D()\n"; } ~D(){ cout<<"~D()\n"; } }; int main(){ B *b = new D(); delete b; return 0; } OUTPUT: B() D() ~D() ~B() ============== If you don B() D() ~B() where destruction of ~D() is not done which leads to leak
Base *myObj = new Derived(); myObj->fun(); delete myObj ;
using namespace std; class convertch { public: virtual char* convertChar() = 0; ~convertch(){}; }; class MakeLower :public convertch { public: MakeLower(char *passLetter) { tolower = true; Letter = new char[30]; strcpy(Letter, passLetter); } virtual ~MakeLower() { cout<< "called ~MakeLower()"<<"\n"; delete[] Letter; } char* convertChar() { size_t len = strlen(Letter); for(int i= 0;i<len;i++) Letter[i] = Letter[i] + 32; return Letter; } private: char *Letter; bool tolower; }; class MakeUpper : public convertch { public: MakeUpper(char *passLetter) { Letter = new char[30]; toupper = true; strcpy(Letter, passLetter); } char* convertChar() { size_t len = strlen(Letter); for(int i= 0;i<len;i++) Letter[i] = Letter[i] - 32; return Letter; } virtual ~MakeUpper() { cout<< "called ~MakeUpper()"<<"\n"; delete Letter; } private: char *Letter; bool toupper; }; int _tmain(int argc, _TCHAR* argv[]) { convertch *makeupper = new MakeUpper("hai"); cout<< "Eneterd : hai = " <<makeupper->convertChar()<<" "; delete makeupper; convertch *makelower = new MakeLower("HAI");; cout<<"Eneterd : HAI = " <<makelower->convertChar()<<" "; delete makelower; return 0; }
using namespace std; class convertch { public: virtual char* convertChar() = 0; virtual ~convertch(){}; }; class MakeLower :public convertch { public: MakeLower(char *passLetter) { tolower = true; Letter = new char[30]; strcpy(Letter, passLetter); } virtual ~MakeLower() { cout<< "called ~MakeLower()"<<"\n"; delete[] Letter; } char* convertChar() { size_t len = strlen(Letter); for(int i= 0;i<len;i++) { Letter[i] = Letter[i] + 32; } return Letter; } private: char *Letter; bool tolower; }; class MakeUpper : public convertch { public: MakeUpper(char *passLetter) { Letter = new char[30]; toupper = true; strcpy(Letter, passLetter); } char* convertChar() { size_t len = strlen(Letter); for(int i= 0;i<len;i++) { Letter[i] = Letter[i] - 32; } return Letter; } virtual ~MakeUpper() { cout<< "called ~MakeUpper()"<<"\n"; delete Letter; } private: char *Letter; bool toupper; }; int _tmain(int argc, _TCHAR* argv[]) { convertch *makeupper = new MakeUpper("hai"); cout<< "Eneterd : hai = " <<makeupper->convertChar()<<" \n"; delete makeupper; convertch *makelower = new MakeLower("HAI");; cout<<"Eneterd : HAI = " <<makelower->convertChar()<<"\n "; delete makelower; return 0; }
using namespace std; struct a { ~a() {} unsigned long long i; }; struct b : a { ~b() {} unsigned long long j; }; struct c : b { ~c() {} virtual void m3() {} unsigned long long k; }; struct d : c { ~d() {} virtual void m4() {} unsigned long long l; }; int main() { cout << "sizeof(a): " << sizeof(a) << endl; cout << "sizeof(b): " << sizeof(b) << endl; cout << "sizeof(c): " << sizeof(c) << endl; cout << "sizeof(d): " << sizeof(d) << endl; a* a1 = new a(); cout << "a1: " << a1 << endl; delete a1; b* b1 = new b(); cout << "b1: " << b1 << endl; cout << "(a*) b1: " << (a*) b1 << endl; delete b1; c* c1 = new c(); cout << "c1: " << c1 << endl; cout << "(b*) c1: " << (b*) c1 << endl; cout << "(a*) c1: " << (a*) c1 << endl; delete c1; d* d1 = new d(); cout << "d1: " << d1 << endl; cout << "(c*) d1: " << (c*) d1 << endl; cout << "(b*) d1: " << (b*) d1 << endl; cout << "(a*) d1: " << (a*) d1 << endl; delete d1; c1 = (c*) new d(); delete c1; d1 = new d(); b1 = (b*) d1; cout << "d1: " << d1 << endl; cout << "b1: " << b1 << endl; delete b1; /* char* buf = new char[32]; cout << "buf: " << (void*) buf << endl; buf += 8; cout << "buf after adding 8: " << (void*) buf << endl; delete buf; */ }
class A { public: A() {} virtual void foo() { cout << "This is A." << endl; } }; class B : public A { public: B() {} void foo() { cout << "This is B." << endl; } }; int main(int argc, char* argv[]) { A *a = new B(); a->foo(); if(a != NULL) delete a; return 0; }
struct X { virtual void foo(); }; struct Y : X { void foo() {} }; struct A { virtual ~A() = 0; }; struct B: A { virtual ~B(){} }; extern int x; void foo(); int main() { x = 0; foo(); Y y; B b; }
/home/AbiSfw/ccvvuHoX.o: In function `main prog.cpp:(.text+0x10): undefined reference to `x' prog.cpp:(.text+0x19): undefined reference to `foo()' prog.cpp:(.text+0x2d): undefined reference to `A::~A()' /home/AbiSfw/ccvvuHoX.o: In function `B::~B() prog.cpp:(.text._ZN1BD1Ev[B::~B()]+0xb): undefined reference to `A::~A()' /home/AbiSfw/ccvvuHoX.o: In function `B::~B() prog.cpp:(.text._ZN1BD0Ev[B::~B()]+0x12): undefined reference to `A::~A()' /home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1Y[typeinfo for Y]+0x8): undefined reference to `typeinfo for X' /home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1B[typeinfo for B]+0x8): undefined reference to `typeinfo for A' collect2: ld returned 1 exit status
1>test2.obj : error LNK2001: unresolved external symbol "void __cdecl foo(void)" (?foo@@YAXXZ) 1>test2.obj : error LNK2001: unresolved external symbol "int x" (?x@@3HA) 1>test2.obj : error LNK2001: unresolved external symbol "public: virtual __thiscall A::~A(void)" (??1A@@UAE@XZ) 1>test2.obj : error LNK2001: unresolved external symbol "public: virtual void __thiscall X::foo(void)" (?foo@X@@UAEXXZ) 1>...\test2.exe : fatal error LNK1120: 4 unresolved externals
struct X { virtual ~X() = 0; }; struct Y : X { ~Y() {} }; int main() { Y y; }
struct X { virtual void foo(); }; struct Y : X { void foo() {} }; int main() { Y y; }
struct A { void foo(); }; void foo() {} int main() { A a; a.foo(); }
struct X { static int x; }; int main() { int x = X::x; }
g++ -o test objectFile1.o objectFile2.o -lLibraryName
void foo(int& x); int main() { int x; foo(x); } void foo(const int& x) {}
struct B { B(int); int x; }; B::B(int xx) : x(xx) {} struct A { A(int x); B b; }; A::A(int x) : b(x) {} int main() { A a(5); return 0; };
$ g++ -c A.cpp $ g++ -c B.cpp $ ar rvs libA.a A.o ar: creating libA.a a - A.o $ ar rvs libB.a B.o ar: creating libB.a a - B.o
$ g++ main.cpp -L. -lB -lA ./libA.a(A.o): In function `A::A(int) A.cpp:(.text+0x1c): undefined reference to `B::B(int)' collect2: error: ld returned 1 exit status $ g++ main.cpp -L. -lA -lB $ ./a.out
void print(); static int local_var_name; int global_var_name = 123; int main() { print(); return 0; }
extern "C" int printf (const char*, ...); extern int global_var_name; void print () { printf("%d\n", global_var_name); }
$ g++ -c src1.cpp -o src1.o $ g++ -c src2.cpp -o src2.o
$ readelf --symbols src1.o Num: Value Size Type Bind Vis Ndx Name 5: 0000000000000000 4 OBJECT LOCAL DEFAULT 4 _ZL14local_var_name 9: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_var_name
[1] - this is our static (local) variable (important - Bind has a type "LOCAL") [2] - this is our global variable
extern "C" int printf (const char*, ...); extern int global_var_name; extern int local_var_name; void print () { printf("%d%d\n", global_var_name, local_var_name); }
$ g++ src1.o src2.o -o prog src2.o: In function `print() src2.cpp:(.text+0x6): undefined reference to `local_var_name' collect2: error: ld returned 1 exit status
$ g++ -S src1.cpp -o src1.s look src1.s .file "src1.cpp" .local _ZL14local_var_name .comm _ZL14local_var_name,4,4 .globl global_var_name .data .align 4 .type global_var_name, @object .size global_var_name, 4 global_var_name: .long 123 .text .globl main .type main, @function main: ; assembler code, not interesting for us .LFE0: .size main, .-main .ident "GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2" .section .note.GNU-stack,"",@progbits
.local _ZL14local_var_name .comm _ZL14local_var_name,4,4
.globl local_var_name .data .align 4 .type local_var_name, @object .size local_var_name, 4 local_var_name: .long 456789
.file "src1.cpp" .globl local_var_name .data .align 4 .type local_var_name, @object .size local_var_name, 4 local_var_name: .long 456789 .globl global_var_name .align 4 .type global_var_name, @object .size global_var_name, 4 global_var_name: .long 123 .text .globl main .type main, @function main: ; ...
$ readelf --symbols src1.o 8: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 local_var_name
template<class T> struct X { void foo(); }; int main() { X<int> x; x.foo(); } template<class T> void X<T>::foo() { }
template <typename T> class Foo { friend std::ostream& operator<< (std::ostream& os, const Foo<T>& a); };
std::ostream& operator<< (std::ostream& os, const Foo<int>& a) { }
template <typename> class Foo; template <typename T> std::ostream& operator<<(std::ostream&, const Foo<T>&); template <typename T> class Foo { friend std::ostream& operator<< <>(std::ostream& os, const Foo<T>& a); }; template <typename T> std::ostream& operator<<(std::ostream&, const Foo<T>&) { }
template <typename T> class Foo { template <typename T1> friend std::ostream& operator<<(std::ostream& os, const Foo<T1>& a); };
template <typename T> class Foo { friend std::ostream& operator<<(std::ostream& os, const Foo& a) { } };
$ gcc -c -o my_lib.o my_lib.c $ ar rcs libmy_lib.a my_lib.o
$ gcc -o eg1 -L. -lmy_lib eg1.o eg1.o: In function `main eg1.c:(.text+0x5): undefined reference to `hw' collect2: error: ld returned 1 exit status
$ gcc -o eg1 -I. -L. -lmy_lib eg1.c /tmp/ccQk1tvs.o: In function `main eg1.c:(.text+0x5): undefined reference to `hw' collect2: error: ld returned 1 exit status
int main() { printf("%s\n",zlibVersion()); return 0; }
$ gcc -o eg2 -lz eg2.o eg2.o: In function `main eg2.c:(.text+0x5): undefined reference to `zlibVersion' collect2: error: ld returned 1 exit status
$ gcc -o eg2 -I. -lz eg2.c /tmp/ccxCiGn7.o: In function `main eg2.c:(.text+0x5): undefined reference to `zlibVersion' collect2: error: ld returned 1 exit status
$ gcc -o eg2 $(pkg-config --libs zlib) eg2.o eg2.o: In function `main eg2.c:(.text+0x5): undefined reference to `zlibVersion'
$ gcc -o eg2 eg2.o $(pkg-config --libs zlib) $ ./eg2 1.2.8
$ gcc -I. -c -o eg1.o eg1.c $ gcc -o eg1 -L. -lmy_lib eg1.o
typedef int Number; void foo(Number); typedef float Number; void foo(Number);
const int test = 5; int test2 = 5; extern const int test; extern int test2; void foo() { int x = test; int y = test2; }
using path_t = std::experimental::filesystem::path; using path_t = std::filesystem::path;
nm XXX.so 00000000000005a7 t HIDDEN_SYMBOL 00000000000005f8 T VISIBLE_SYMBOL
>>> objdump -t XXXX.o | grep hidden 0000000000000000 g F .text 000000000000000b .hidden HIDDEN_SYMBOL1 000000000000000b g F .text 000000000000000b .hidden HIDDEN_SYMBOL2
namespace { struct f { void operator()(int) { } }; } void func(std::vector<int>& v) { f f; std::for_each(v.begin(), v.end(), f); }
void func2(std::vector<int>& v) { struct { void operator()(int) { } } f; std::for_each(v.begin(), v.end(), f); }
void func3(std::vector<int>& v) { std::for_each(v.begin(), v.end(), [](int) { }); }
void func4(std::vector<double>& v) { std::transform(v.begin(), v.end(), v.begin(), [](double d) { return d < 0.00001 ? 0 : d; } ); }
void func4(std::vector<double>& v) { std::transform(v.begin(), v.end(), v.begin(), [](double d) { if (d < 0.0001) { return 0; } else { return d; } }); }
void func4(std::vector<double>& v) { std::transform(v.begin(), v.end(), v.begin(), [](double d) -> double { if (d < 0.0001) { return 0; } else { return d; } }); }
void func5(std::vector<double>& v, const double& epsilon) { std::transform(v.begin(), v.end(), v.begin(), [epsilon](double d) -> double { if (d < epsilon) { return 0; } else { return d; } }); }
int x = 4; auto y = [&r = x, x = x+1]()->int { r += 2; return x+2; }();
auto ptr = std::make_unique<int>(10); auto lambda = [ptr = std::move(ptr)] {return *ptr;};
int a = []( int b ){ int r=1; while (b>0) r*=b--; return r; }(5);
[&]( std::function<void()> algorithm ) { ...your wrapper code... algorithm(); ...your wrapper code... } ([&]() { ...your algorithm code... });
auto algorithm = [&]( double x, double m, double b ) -> double { return m*x+b; }; int a=algorithm(1,2,3), b=algorithm(4,5,6);
auto x = [=](int arg1){printf("%i", arg1); }; void(*f)(int) = x; f(1); x(1);
[=](int arg1)->trailing_return_type{return trailing_return_type();}
auto toFloat = [](int value) { return float(value);}; auto interpolate = [min = toFloat(0), max = toFloat(255)](int value)->float { return (value - min) / (max - min);};
void apply(void (*f)(int)) { f(10); f(20); f(30); }
int col=0; void output() { apply([](int data) { cout << data << ((++col % 10) ? }); }
void output(int n) { int col=0; apply([&col,n](int data) { cout << data << ((++col % 10) ? }); }
void apply(std::function<void(int)> f) { f(10); f(20); f(30); } void output(int width) { int col; apply([width,&col](int data) { cout << data << ((++col % width) ? }); }
void print_modulo(const vector<int>& v, ostream& os, int m) { for_each(begin(v),end(v), [&os,m](int x) { if (x%m==0) os << x << }); }
class Modulo_print { ostream& os; public: Modulo_print(ostream& s, int mm) :os(s), m(mm) {} void operator()(int x) const { if (x%m==0) os << x << } };
void print_modulo(const vector<int>& v, ostream& os, int m) { class Modulo_print { ostream& os; int m; public: Modulo_print (ostream& s, int mm) :os(s), m(mm) {} void operator()(int x) const { if (x%m==0) os << x << } }; for_each(begin(v),end(v),Modulo_print{os,m}); }
void print_modulo(const vector<int>& v, ostream& os, int m) { auto Modulo_print = [&os,m] (int x) { if (x%m==0) os << x << for_each(begin(v),end(v),Modulo_print); }
void TestFunctions::simpleLambda() { bool sensitive = true; std::vector<int> v = std::vector<int>({1,33,3,4,5,6,7}); sort(v.begin(),v.end(), [sensitive](int x, int y) { printf("\n%i\n", x < y); return sensitive ? x < y : abs(x) < abs(y); }); printf("sorted"); for_each(v.begin(), v.end(), [](int x) { printf("x - %i;", x); } ); }
void process_z_vec(vector<int>& vec) { auto print_2d = [](const vector<int>& board, int bsize) { for(int i = 0; i<bsize; i++) { for(int j=0; j<bsize; j++) { cout << board[bsize*i+j] << " "; } cout << "\n"; } }; print_2d(vec,x_size); print_2d(vec,y_size); }
int main(int argc, char* argv[]) { using namespace std; if (argc != 2) { cerr << "usage: array_size in MB" << endl; return -1; } uint64_t size = atol(argv[1])<<20; uint64_t* buffer = new uint64_t[size/8]; char* charbuffer = reinterpret_cast<char*>(buffer); for (unsigned i=0; i<size; ++i) charbuffer[i] = rand()%256; uint64_t count,duration; chrono::time_point<chrono::system_clock> startP,endP; { startP = chrono::system_clock::now(); count = 0; for( unsigned k = 0; k < 10000; k++){ for (unsigned i=0; i<size/8; i+=4) { count += _mm_popcnt_u64(buffer[i]); count += _mm_popcnt_u64(buffer[i+1]); count += _mm_popcnt_u64(buffer[i+2]); count += _mm_popcnt_u64(buffer[i+3]); } } endP = chrono::system_clock::now(); duration = chrono::duration_cast<std::chrono::nanoseconds>(endP-startP).count(); cout << "unsigned\t" << count << << (10000.0*size)/(duration) << " GB/s" << endl; } { startP = chrono::system_clock::now(); count=0; for( unsigned k = 0; k < 10000; k++){ for (uint64_t i=0;i<size/8;i+=4) { count += _mm_popcnt_u64(buffer[i]); count += _mm_popcnt_u64(buffer[i+1]); count += _mm_popcnt_u64(buffer[i+2]); count += _mm_popcnt_u64(buffer[i+3]); } } endP = chrono::system_clock::now(); duration = chrono::duration_cast<std::chrono::nanoseconds>(endP-startP).count(); cout << "uint64_t\t" << count << << (10000.0*size)/(duration) << " GB/s" << endl; } free(charbuffer); }
clang++ -O3 -march=native -std=c++11 teest.cpp -o test
0x400af8: lea 0x1(%rdx),%eax popcnt (%rbx,%rax,8),%r9 lea 0x2(%rdx),%edi popcnt (%rbx,%rcx,8),%rax lea 0x3(%rdx),%esi add %r9,%rax popcnt (%rbx,%rdi,8),%rcx add $0x4,%edx add %rcx,%rax popcnt (%rbx,%rsi,8),%rcx add %rcx,%rax mov %edx,%ecx add %rax,%r14 cmp %rbp,%rcx jb 0x400af8
0x400c00: popcnt 0x8(%rbx,%rdx,8),%rcx popcnt (%rbx,%rdx,8),%rax add %rcx,%rax popcnt 0x10(%rbx,%rdx,8),%rcx add %rcx,%rax popcnt 0x18(%rbx,%rdx,8),%rcx add $0x4,%rdx add %rcx,%rax add %rax,%r12 cmp %rbp,%rdx jb 0x400c00
0x400e50: popcnt (%r15,%rcx,8),%rdx add %rbx,%rdx popcnt 0x8(%r15,%rcx,8),%rsi add %rdx,%rsi popcnt 0x10(%r15,%rcx,8),%rdx add %rsi,%rdx popcnt 0x18(%r15,%rcx,8),%rbx add %rdx,%rbx add $0x4,%rcx cmp %rbp,%rcx jb 0x400e50
0x400a68: popcnt (%rbx,%rdx,1),%rax popcnt 0x8(%rbx,%rdx,1),%rcx add %rax,%rcx popcnt 0x10(%rbx,%rdx,1),%rax add %rax,%rcx popcnt 0x18(%rbx,%rdx,1),%rsi add $0x20,%rdx add %rsi,%rcx add %rcx,%rbp cmp $0x100000,%rdx jne 0x400a68
0x400dd0: popcnt (%r14,%rcx,8),%rdx add %rbx,%rdx popcnt 0x8(%r14,%rcx,8),%rsi add %rdx,%rsi popcnt 0x10(%r14,%rcx,8),%rdx add %rsi,%rdx popcnt 0x18(%r14,%rcx,8),%rbx add %rdx,%rbx add $0x4,%rcx cmp $0x20000,%rcx jb 0x400dd0
.L4: movq (%rbx,%rax,8), %r8 movq 8(%rbx,%rax,8), %r9 movq 16(%rbx,%rax,8), %r10 movq 24(%rbx,%rax,8), %r11 addq $4, %rax popcnt %r8, %r8 add %r8, %rdx popcnt %r9, %r9 add %r9, %rcx popcnt %r10, %r10 add %r10, %rdi popcnt %r11, %r11 add %r11, %rsi cmpq $131072, %rax jne .L4
.L9: movq (%rbx,%rdx,8), %r9 movq 8(%rbx,%rdx,8), %r10 movq 16(%rbx,%rdx,8), %r11 movq 24(%rbx,%rdx,8), %rbp addq $4, %rdx popcnt %r9, %rax add %rax, %rcx popcnt %r10, %rax add %rax, %rsi popcnt %r11, %rax add %rax, %r8 popcnt %rbp, %rax add %rax, %rdi cmpq $131072, %rdx jne .L9
.L14: movq (%rbx,%rdx,8), %r9 movq 8(%rbx,%rdx,8), %r10 movq 16(%rbx,%rdx,8), %r11 movq 24(%rbx,%rdx,8), %rbp addq $4, %rdx xor %rax, %rax popcnt %r9, %rax add %rax, %rcx popcnt %r10, %rax add %rax, %rsi popcnt %r11, %rax add %rax, %r8 popcnt %rbp, %rax add %rax, %rdi cmpq $131072, %rdx jne .L14
int main(int argc, char* argv[]) { using namespace std; uint64_t size=1<<20; uint64_t* buffer = new uint64_t[size/8]; char* charbuffer=reinterpret_cast<char*>(buffer); for (unsigned i=0;i<size;++i) charbuffer[i]=rand()%256; uint64_t count,duration; chrono::time_point<chrono::system_clock> startP,endP; { uint64_t c0 = 0; uint64_t c1 = 0; uint64_t c2 = 0; uint64_t c3 = 0; startP = chrono::system_clock::now(); for( unsigned k = 0; k < 10000; k++){ for (uint64_t i=0;i<size/8;i+=4) { uint64_t r0 = buffer[i + 0]; uint64_t r1 = buffer[i + 1]; uint64_t r2 = buffer[i + 2]; uint64_t r3 = buffer[i + 3]; __asm__( "popcnt %4, %4 \n\t" "add %4, %0 \n\t" "popcnt %5, %5 \n\t" "add %5, %1 \n\t" "popcnt %6, %6 \n\t" "add %6, %2 \n\t" "popcnt %7, %7 \n\t" "add %7, %3 \n\t" : "+r" (c0), "+r" (c1), "+r" (c2), "+r" (c3) : "r" (r0), "r" (r1), "r" (r2), "r" (r3) ); } } count = c0 + c1 + c2 + c3; endP = chrono::system_clock::now(); duration=chrono::duration_cast<std::chrono::nanoseconds>(endP-startP).count(); cout << "No Chain\t" << count << << (10000.0*size)/(duration) << " GB/s" << endl; } { uint64_t c0 = 0; uint64_t c1 = 0; uint64_t c2 = 0; uint64_t c3 = 0; startP = chrono::system_clock::now(); for( unsigned k = 0; k < 10000; k++){ for (uint64_t i=0;i<size/8;i+=4) { uint64_t r0 = buffer[i + 0]; uint64_t r1 = buffer[i + 1]; uint64_t r2 = buffer[i + 2]; uint64_t r3 = buffer[i + 3]; __asm__( "popcnt %4, %%rax \n\t" "add %%rax, %0 \n\t" "popcnt %5, %%rax \n\t" "add %%rax, %1 \n\t" "popcnt %6, %%rax \n\t" "add %%rax, %2 \n\t" "popcnt %7, %%rax \n\t" "add %%rax, %3 \n\t" : "+r" (c0), "+r" (c1), "+r" (c2), "+r" (c3) : "r" (r0), "r" (r1), "r" (r2), "r" (r3) : "rax" ); } } count = c0 + c1 + c2 + c3; endP = chrono::system_clock::now(); duration=chrono::duration_cast<std::chrono::nanoseconds>(endP-startP).count(); cout << "Chain 4 \t" << count << << (10000.0*size)/(duration) << " GB/s" << endl; } { uint64_t c0 = 0; uint64_t c1 = 0; uint64_t c2 = 0; uint64_t c3 = 0; startP = chrono::system_clock::now(); for( unsigned k = 0; k < 10000; k++){ for (uint64_t i=0;i<size/8;i+=4) { uint64_t r0 = buffer[i + 0]; uint64_t r1 = buffer[i + 1]; uint64_t r2 = buffer[i + 2]; uint64_t r3 = buffer[i + 3]; __asm__( "xor %%rax, %%rax \n\t" "popcnt %4, %%rax \n\t" "add %%rax, %0 \n\t" "popcnt %5, %%rax \n\t" "add %%rax, %1 \n\t" "popcnt %6, %%rax \n\t" "add %%rax, %2 \n\t" "popcnt %7, %%rax \n\t" "add %%rax, %3 \n\t" : "+r" (c0), "+r" (c1), "+r" (c2), "+r" (c3) : "r" (r0), "r" (r1), "r" (r2), "r" (r3) : "rax" ); } } count = c0 + c1 + c2 + c3; endP = chrono::system_clock::now(); duration=chrono::duration_cast<std::chrono::nanoseconds>(endP-startP).count(); cout << "Broken Chain\t" << count << << (10000.0*size)/(duration) << " GB/s" << endl; } free(charbuffer); }
False Chain 0: 41959360000 0.57748 sec 18.1578 GB/s False Chain 1: 41959360000 0.585398 sec 17.9122 GB/s False Chain 2: 41959360000 0.645483 sec 16.2448 GB/s False Chain 3: 41959360000 0.929718 sec 11.2784 GB/s False Chain 4: 41959360000 1.23572 sec 8.48557 GB/s
unsigned 41950110000 0.811198 sec 12.9263 GB/s uint64_t 41950110000 0.622884 sec 16.8342 GB/s
unsigned 41950110000 0.623406 sec 16.8201 GB/s uint64_t 41950110000 0.623685 sec 16.8126 GB/s
uint64_t* bfrend = buffer+(size/8); uint64_t* bfrptr; { startP = chrono::system_clock::now(); count = 0; for (unsigned k = 0; k < 10000; k++){ for (bfrptr = buffer; bfrptr < bfrend;){ count += __popcnt64(*bfrptr++); count += __popcnt64(*bfrptr++); count += __popcnt64(*bfrptr++); count += __popcnt64(*bfrptr++); } } endP = chrono::system_clock::now(); duration = chrono::duration_cast<std::chrono::nanoseconds>(endP-startP).count(); cout << "uint64_t\t" << count << << (10000.0*size)/(duration) << " GB/s" << endl; }
$LL5@main: mov r10, rdi cmp rdi, r15 jae SHORT $LN4@main npad 4 $LL2@main: mov rax, QWORD PTR [r10+24] mov rcx, QWORD PTR [r10+16] mov r8, QWORD PTR [r10+8] mov r9, QWORD PTR [r10] popcnt rdx, rax popcnt rax, rcx add rdx, rax popcnt rax, r8 add r10, 32 add rdx, rax popcnt rax, r9 add rsi, rax add rsi, rdx cmp r10, r15 jb SHORT $LL2@main $LN4@main: dec r13 jne SHORT $LL5@main
[1829] /tmp/so_25078285 $ cat /proc/cpuinfo |grep CPU|head -n1 model name : Intel(R) Core(TM) i3-3225 CPU @ 3.30GHz [1829] /tmp/so_25078285 $ g++ --version|head -n1 g++ (Ubuntu/Linaro 4.7.3-1ubuntu1) 4.7.3 [1829] /tmp/so_25078285 $ g++ -O3 -march=native -std=c++11 test.cpp -o test_o3 [1829] /tmp/so_25078285 $ g++ -O3 -march=native -funroll-loops -fprefetch-loop-arrays -std=c++11 test.cpp -o test_o3_unroll_loops__and__prefetch_loop_arrays [1829] /tmp/so_25078285 $ ./test_o3 1 unsigned 41959360000 0.595 sec 17.6231 GB/s uint64_t 41959360000 0.898626 sec 11.6687 GB/s [1829] /tmp/so_25078285 $ ./test_o3_unroll_loops__and__prefetch_loop_arrays 1 unsigned 41959360000 0.618222 sec 16.9612 GB/s uint64_t 41959360000 0.407304 sec 25.7443 GB/s
uint64_t subset_counts[4] = {}; for( unsigned k = 0; k < 10000; k++){ unsigned i=0; while (i < size/8) { subset_counts[0] += _mm_popcnt_u64(buffer[i]); subset_counts[1] += _mm_popcnt_u64(buffer[i+1]); subset_counts[2] += _mm_popcnt_u64(buffer[i+2]); subset_counts[3] += _mm_popcnt_u64(buffer[i+3]); i += 4; } } count = subset_counts[0] + subset_counts[1] + subset_counts[2] + subset_counts[3];
Count: 20318230000 Elapsed: 0.411156 seconds Speed: 25.503118 GB/s
uint64_t builtin_popcnt(const uint64_t* buf, size_t len){ uint64_t cnt = 0; for(size_t i = 0; i < len; ++i){ cnt += __builtin_popcountll(buf[i]); } return cnt; } int main(int argc, char** argv){ if(argc != 2){ printf("Usage: %s <buffer size in MB>\n", argv[0]); return -1; } uint64_t size = atol(argv[1]) << 20; uint64_t* buffer = (uint64_t*)malloc((size/8)*sizeof(*buffer)); for (size_t i = 0; i < (size / 8); i++) { buffer[i] = random(); } uint64_t count = 0; clock_t tic = clock(); for(size_t i = 0; i < 10000; ++i){ count += builtin_popcnt(buffer, size/8); } clock_t toc = clock(); printf("Count: %lu\tElapsed: %f seconds\tSpeed: %f GB/s\n", count, (double)(toc - tic) / CLOCKS_PER_SEC, ((10000.0*size)/(((double)(toc - tic)*1e+9) / CLOCKS_PER_SEC))); return 0; }
gcc --std=gnu99 -mpopcnt -O3 -funroll-loops -march=native bench.c -o bench
processor : 0 vendor_id : GenuineIntel cpu family : 6 model : 70 model name : Intel(R) Core(TM) i7-4870HQ CPU @ 2.50 GHz stepping : 1 microcode : 0xf cpu MHz : 2494.226 cache size : 6144 KB physical id : 0 siblings : 1 core id : 0 cpu cores : 1 apicid : 0 initial apicid : 0 fpu : yes fpu_exception : yes cpuid level : 13 wp : yes flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc nopl xtopology nonstop_tsc eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm arat pln pts dtherm fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid xsaveopt bugs : bogomips : 4988.45 clflush size : 64 cache_alignment : 64 address sizes : 36 bits physical, 48 bits virtual power management:
uint64_t builtin_popcnt1a(const uint64_t* buf, size_t len) { uint64_t cnt0, cnt1, cnt2, cnt3; cnt0 = cnt1 = cnt2 = cnt3 = 0; uint64_t val = buf[0]; __asm__ __volatile__ ( "1:\n\t" "popcnt %2, %1\n\t" "popcnt %2, %1\n\t" "popcnt %2, %1\n\t" "popcnt %2, %1\n\t" "subq $4, %0\n\t" "jnz 1b\n\t" : "+q" (len), "=q" (cnt0) : "q" (val) : ); __asm__ __volatile__ ( "1:\n\t" "popcnt %5, %1\n\t" "popcnt %5, %2\n\t" "popcnt %5, %3\n\t" "popcnt %5, %4\n\t" "subq $4, %0\n\t" "jnz 1b\n\t" : "+q" (len), "=q" (cnt0), "=q" (cnt1), "=q" (cnt2), "=q" (cnt3) : "q" (val) : ); return cnt0; }
______ ______ / X \ / / \ \ | l | x | pr | \ \ / / \______X______/ gl r
SomeType &&Func() { ... } SomeType &&val = Func(); SomeType otherVal{val};
int i=7; const int& f(){ return i; } int main() { std::cout<<&"www"<<std::endl; std::cout<<&"www"<<std::endl; "www"; "www"; i; i; int* p_i=new int(7); *p_i; *p_i; const int& r_I=7; r_I; r_I; f(); i; return 0; }
int&& f(){ return 3; } int main() { f(); return 0; }
int main() { static_cast<int&&>(7); std::move(7); return 0; }
struct As { int i; }; As&& f(){ return As(); } int main() { f().i; return 0; }
struct As { int i; }; As&& f(){ return As(); } int main() { f(); As&& rr_a=As(); rr_a; std::ref(f); return 0; }
struct As { void f(){ this; } }; As f(){ return As(); } int main() { f(); return 0; }
class Animal { public: void eat() { std::cout << "I }; class Cat : public Animal { public: void eat() { std::cout << "I };
Animal *animal = new Animal; Cat *cat = new Cat; animal->eat(); cat->eat();
Animal *animal = new Animal; Cat *cat = new Cat; func(animal); func(cat);
class Animal { public: virtual void eat() { std::cout << "I }; class Cat : public Animal { public: void eat() { std::cout << "I };
class Base { public: void Method1 () { std::cout << "Base::Method1" << std::endl; } virtual void Method2 () { std::cout << "Base::Method2" << std::endl; } }; class Derived : public Base { public: void Method1 () { std::cout << "Derived::Method1" << std::endl; } void Method2 () { std::cout << "Derived::Method2" << std::endl; } }; Base* obj = new Derived (); obj->Method1 (); obj->Method2 ();
class Animal { public: std::string Says() { return "?"; } }; class Dog: public Animal { public: std::string Says() { return "Woof"; } }; void test() { Dog* d = new Dog(); Animal* a = d; cout << d->Says(); cout << a->Says(); }
using namespace std; class Expression { public: auto value() const -> double { return 0.0; } }; class Number : public Expression { private: double number_; public: auto value() const -> double { return number_; } Number( double const number ) : Expression() , number_( number ) {} }; class Sum : public Expression { private: Expression const* a_; Expression const* b_; public: auto value() const -> double { return a_->value() + b_->value(); } Sum( Expression const* const a, Expression const* const b ) : Expression() , a_( a ) , b_( b ) {} }; auto main() -> int { Number const a( 3.14 ); Number const b( 2.72 ); Number const c( 1.0 ); Sum const sum_ab( &a, &b ); Sum const sum( &sum_ab, &c ); cout << sum.value() << endl; }
using namespace std; class Expression { public: virtual auto value() const -> double = 0; }; class Number : public Expression { private: double number_; public: auto value() const -> double override { return number_; } Number( double const number ) : Expression() , number_( number ) {} }; class Sum : public Expression { private: Expression const* a_; Expression const* b_; public: auto value() const -> double override { return a_->value() + b_->value(); } Sum( Expression const* const a, Expression const* const b ) : Expression() , a_( a ) , b_( b ) {} }; auto main() -> int { Number const a( 3.14 ); Number const b( 2.72 ); Number const c( 1.0 ); Sum const sum_ab( &a, &b ); Sum const sum( &sum_ab, &c ); cout << sum.value() << endl; }
using namespace std; class Expression { protected: typedef auto Value_func( Expression const* ) -> double; Value_func* value_func_; public: auto value() const -> double { return value_func_( this ); } Expression(): value_func_( nullptr ) {} }; class Number : public Expression { private: double number_; static auto specific_value_func( Expression const* expr ) -> double { return static_cast<Number const*>( expr )->number_; } public: Number( double const number ) : Expression() , number_( number ) { value_func_ = &Number::specific_value_func; } }; class Sum : public Expression { private: Expression const* a_; Expression const* b_; static auto specific_value_func( Expression const* expr ) -> double { auto const p_self = static_cast<Sum const*>( expr ); return p_self->a_->value() + p_self->b_->value(); } public: Sum( Expression const* const a, Expression const* const b ) : Expression() , a_( a ) , b_( b ) { value_func_ = &Sum::specific_value_func; } }; auto main() -> int { Number const a( 3.14 ); Number const b( 2.72 ); Number const c( 1.0 ); Sum const sum_ab( &a, &b ); Sum const sum( &sum_ab, &c ); cout << sum.value() << endl; }
using namespace std; class A{ public: void show(){ cout << " Hello from Class A"; } }; class B :public A{ public: void show(){ cout << " Hello from Class B"; } }; int main(){ A *a1 = new B; a1->show(); }
using namespace std; class A{ public: virtual void show(){ cout << " Hello from Class A"; } }; class B :public A{ public: virtual void show(){ cout << " Hello from Class B"; } }; int main(){ A *a1 = new B; a1->show(); }
class Animal { public: ~Animal() { cout << "Deleting an Animal" << endl; } }; class Cat:public Animal { public: ~Cat() { cout << "Deleting an Animal name Cat" << endl; } }; int main() { Animal *a = new Cat(); delete a; return 0; }
class Animal { public: virtual ~Animal() { cout << "Deleting an Animal" << endl; } }; class Cat:public Animal { public: ~Cat(){ cout << "Deleting an Animal name Cat" << endl; } }; int main() { Animal *a = new Cat(); delete a; return 0; }
Parent* p1 = &boy; p1 -> task(); Parent* p2 = &girl; p2 -> task();
Boy* p1 = &boy; p1 -> task(); Girl* p2 = &girl; p2 -> task();
Parent* p1 = &boy; p1 -> task(); p1 = &girl; p1 -> task();
double totalMonthBenefit = 0; std::vector<CentralShop*> mainShop = { &shop1, &shop2, &shop3, &shop4, &shop5, &shop6}; for(CentralShop* x : mainShop){ totalMonthBenefit += x -> getMonthBenefit(); }
double totalMonthBenefit=0; Shop1* branch1 = &shop1; Shop2* branch2 = &shop2; Shop3* branch3 = &shop3; Shop4* branch4 = &shop4; Shop5* branch5 = &shop5; Shop6* branch6 = &shop6; totalMonthBenefit += branch1 -> getMonthBenefit(); totalMonthBenefit += branch2 -> getMonthBenefit(); totalMonthBenefit += branch3 -> getMonthBenefit(); totalMonthBenefit += branch4 -> getMonthBenefit(); totalMonthBenefit += branch5 -> getMonthBenefit(); totalMonthBenefit += branch6 -> getMonthBenefit();
Shape *shape = new Triangle(); cout << shape->getName();
using namespace std; class father { public: void get_age() {cout << "Fathers age is 50 years" << endl;} }; class son: public father { public : void get_age() { cout << "son`s age is 26 years" << endl;} }; int main(){ father *p_father = new father; son *p_son = new son; p_father->get_age(); p_father = p_son; p_father->get_age(); p_son->get_age(); return 0; }
Fathers age is 50 years Fathers age is 50 years son`s age is 26 years
using namespace std; class father { public: virtual void get_age() {cout << "Fathers age is 50 years" << endl;} }; class son: public father { public : void get_age() { cout << "son`s age is 26 years" << endl;} }; int main(){ father *p_father = new father; son *p_son = new son; p_father->get_age(); p_father = p_son; p_father->get_age(); p_son->get_age(); return 0; }
Fathers age is 50 years son`s age is 26 years son`s age is 26 years
interface IUnknown { virtual HRESULT QueryInterface (REFIID riid, void **ppvObject) = 0; virtual ULONG AddRef () = 0; virtual ULONG Release () = 0; };
using namespace std; class Basic { public: virtual void Test1() { cout << "Test1 from Basic." << endl; } virtual ~Basic(){}; }; class VariantA : public Basic { public: void Test1() { cout << "Test1 from VariantA." << endl; } }; class VariantB : public Basic { public: void Test1() { cout << "Test1 from VariantB." << endl; } }; int main() { Basic *object; VariantA *vobjectA = new VariantA(); VariantB *vobjectB = new VariantB(); object=(Basic *) vobjectA; object->Test1(); object=(Basic *) vobjectB; object->Test1(); delete vobjectA; delete vobjectB; return 0; }
class Base { virtual void foo(); }; class Derived : Base { void foo(); };
using namespace std; class Animal { public: virtual string says() { return "??"; } string says() { return "??"; } }; class Dog: public Animal { public: string says() { return "woof"; } }; string func(Animal *a) { return a->says(); } int main() { Animal *a = new Animal(); Dog *d = new Dog(); Animal *ad = d; cout << "Animal a says\t\t" << a->says() << endl; cout << "Dog d says\t\t" << d->says() << endl; cout << "Animal dog ad says\t" << ad->says() << endl; cout << "func(a) :\t\t" << func(a) << endl; cout << "func(d) :\t\t" << func(d) << endl; cout << "func(ad):\t\t" << func(ad)<< endl; }
$ g++ virtual.cpp -o virtual $ ./virtual Animal a says ?? Dog d says woof Animal dog ad says ?? func(a) : ?? func(d) : ?? func(ad): ??
$ g++ virtual.cpp -D VIRTUAL -o virtual $ ./virtual Animal a says ?? Dog d says woof Animal dog ad says woof func(a) : ?? func(d) : woof func(ad): woof
class Animal: def says(self): return "??" class Dog(Animal): def says(self): return "woof" def func(a): return a.says() if __name__ == "__main__": a = Animal() d = Dog() ad = d print("Animal a says\t\t{}".format(a.says())) print("Dog d says\t\t{}".format(d.says())) print("Animal dog ad says\t{}".format(ad.says())) print("func(a) :\t\t{}".format(func(a))) print("func(d) :\t\t{}".format(func(d))) print("func(ad):\t\t{}".format(func(ad)))
Animal a says ?? Dog d says woof Animal dog ad says woof func(a) : ?? func(d) : woof func(ad): woof
using namespace std; class Animal { public: virtual void MakeTypicalNoise() = 0; virtual ~Animal(){}; }; class Cat : public Animal { public: virtual void MakeTypicalNoise() { cout << "Meow!" << endl; } }; class Dog : public Animal { public: virtual void MakeTypicalNoise() { cout << "Woof!" << endl; } }; class Doberman : public Dog { public: virtual void MakeTypicalNoise() { cout << "Woo, woo, woow!"; cout << " ... "; Dog::MakeTypicalNoise(); } }; int main() { Animal* apObject[] = { new Cat(), new Dog(), new Doberman() }; const int cnAnimals = sizeof(apObject)/sizeof(Animal*); for ( int i = 0; i < cnAnimals; i++ ) { apObject[i]->MakeTypicalNoise(); } for ( int i = 0; i < cnAnimals; i++ ) { delete apObject[i]; } return 0; }
template <typename T, typename Tail> struct UnionNode : public Tail { template<typename U> struct inUnion { typedef Tail::inUnion<U> dummy; }; template< > struct inUnion<T> { }; }; template <typename T> struct UnionNode<T, void> { template<typename U> struct inUnion { char fail[ -2 + (sizeof(U)%2) ]; }; template< > struct inUnion<T> { }; };
namespace boost { int function = 0; } int main() { int f = 0; boost::function< int() > f; }
template <typename T, typename Tail> struct UnionNode : public Tail { template<typename U> struct inUnion { typedef typename Tail::template inUnion<U> dummy; }; };
template <typename T> struct derive_from_Has_type : SomeBase<T>::type { };
template <typename T> struct derive_from_Has_type : SomeBase<T> { using SomeBase<T>::template type; using typename SomeBase<T>::type; };
template<typename T> struct A { typedef int result_type; void f() { this->g<float>(); g<float>(); A<T>::result_type n1; result_type n2; } template<typename U> void g(); };
struct B { typedef int result_type; }; template<typename T> struct C { }; template<typename T> struct D : B, C<T> { void f() { D::result_type r1; D::questionable_type r2; typename D::questionable_type r3; } };
template<> struct C<int> { typedef bool result_type; typedef int questionable_type; };
struct B { void f(); }; struct A : virtual B { void f(); }; template<typename T> struct C : virtual B, T { void g() { this->f(); } }; int main() { C<A> c; c.g(); }
template<class T> void f_tmpl () { T::foo * x; /* <-- (A) */ }
struct X { typedef int foo; }; /* (C) --> */ f_tmpl<X> (); struct Y { static int const foo = 123; }; /* (D) --> */ f_tmpl<Y> ();
template<class T> void g_tmpl () { SomeTrait<T>::type foo; SomeTrait<T>::NestedTrait<int>::type bar; foo.data<int> (); }
template<class T> void g_tmpl () { typename SomeTrait<T>::type foo; typename SomeTrait<T>::template NestedTrait<int>::type bar; foo.template data<int> (); }
N:: X<int> a; typename N::template X<int> b; typename template X<int> c;
template<class T> struct Derived : typename SomeTrait<T>::type { ... };
struct Base { template<class T> struct type { }; }; struct Derived : Base { using Base::template type; using Base::type; };
template <typename T, typename TypeList> struct Contains; template <typename T, typename Head, typename Tail> struct Contains<T, UnionNode<Head, Tail> > { enum { result = Contains<T, Tail>::result }; }; template <typename T, typename Tail> struct Contains<T, UnionNode<T, Tail> > { enum { result = true }; }; template <typename T> struct Contains<T, void> { enum { result = false }; };
template<typename T> struct test { using type = T; using underlying_type = typename T::type };
template<typename T> struct test { using type = typename std::conditional<true, const T&, T&&>::type; using integer = std::conditional<true, int, float>::type; };
template<typename T> struct test { template<typename U> void get() const { std::cout << "get\n"; } }; template<typename T> void func(const test<T>& t) { t.get<int>(); }
template< typename T > void foo( T& x, std::string str, int count ) { x.size(); T::instance_count ; typename T::iterator i ; std::string::size_type s ; std::string::npos ; str.empty() ; count ; }
i++ * ++i; i = ++i; ++i = 2; i = ++i + 1; ++++++i; i = (i, ++i, ++i);
i = (i, ++i, 1) + 1; i = (++i, i++, i); int j = i; j = (++i, i++, j*i);
int main() { int num = 19 ; num = (num << 3) + (num >> 3); }
struct A { int m; }; struct B { ~B(); int m; }; struct C { C() : m() {}; ~C(); int m; };
struct Thingy { ~Thingy(); virtual WaxOn(); int i; };
int * foo() { int a = 5; return &a; } int main() { int* p = foo(); std::cout << *p; *p = 8; std::cout << *p; }
int * foo(){ int a = 5; return &a; } void boo(){ int a = 7; } int main(){ int * p = foo(); boo(); printf("%d\n",*p); }
int * ref () { int tmp = 100; return &tmp; } int main () { int * a = ref(); cout << *a << endl; }
int *a() { int x = 5; return &x; } void b( int *c ) { int y = 29; *c = 123; cout << "y=" << y << endl; } int main() { b( a() ); return 0; }
char* foo() { char buf[10]; ::strcpy(buf, "TEST”); return buf; } int main() { char* s = foo(); ::printf("%s\n", s); }
class Base { public: int publicMember; protected: int protectedMember; private: int privateMember; };
class A { public: int x; protected: int y; private: int z; }; class B : public A { }; class C : protected A { }; class D : private A { };
struct empty_pair_impl : protected empty_class_1 { non_empty_class_2 second; }; struct pair : private empty_pair_impl { non_empty_class_2 &second() { return this->second; } empty_class_1 &first() { return *this; } };
template<typename StorageModel> struct string : private StorageModel { public: void realloc() { StorageModel::realloc(); } };
class pair { public: First first; Second second; };
class stack { protected: vector<element> c; }; class window { protected: void registerClass(window_descriptor w); };
class Super { public: int p; private: int q; protected: int r; }; class Sub : private Super {}; class Subsub : public Sub {};
class Super { private: int x; protected: int y; public: int z; }; class Sub : protected Super {};
class Super { private: int storage; public: void put(int val) { storage = val; } int get(void) { return storage; } }; int main(void) { Super object; object.put(100); object.put(object.get()); cout << object.get() << endl; return 0; }
class Sub : Super { }; int main(void) { Sub object; object.put(100); object.put(object.get()); cout << object.get() << endl; return 0; }
class Super { protected: int storage; public: void put(int val) { storage = val; } int get(void) { return storage; } }; class Sub : public Super { public: void print(void) {cout << "storage = " << storage;} }; int main(void) { Sub object; object.put(100); object.put(object.get() + 1); object.print(); return 0; }
Private : Inaccessible Private Private Protected : Inaccessible Protected Protected Public : Inaccessible Protected Public
class MyClass { private: int myPrivateMember; protected: int myProtectedMember; };
Accessors | Base Class | Derived Class | World —————————————+————————————+———————————————+——————— public | y | y | y —————————————+————————————+———————————————+——————— protected | y | y | n —————————————+————————————+———————————————+——————— private | | | or | y | n | n no accessor | | | y: accessible n: not accessible
class Base { public: int m_nPublic; private: int m_nPrivate; protected: int m_nProtected; }; class Derived: public Base { public: Derived() { m_nPublic = 1; m_nPrivate = 2; m_nProtected = 3; } }; int main() { Base cBase; cBase.m_nPublic = 1; cBase.m_nPrivate = 2; cBase.m_nProtected = 3; }
switch (val) { case VAL: int newVal = 42; break; case ANOTHER_VAL: ... break; }
switch (val) { case VAL: { int newVal = 42; break; } case ANOTHER_VAL: ... break; }
switch (val) { case VAL: int newVal = 42; break; case ANOTHER_VAL: ... break; }
switch (val) { case VAL:; int newVal = 42; break; case ANOTHER_VAL: ... break; }
switch (val) { case VAL: int newVal; newVal = 42; break; case ANOTHER_VAL: ... break; }
switch (i) { case 0: int j; j = 0; break; case 1: ++j; break; }
class A { public: A (); }; switch (i) { case 0: A j; break; case 1: break; }
switch (val) { case VAL: { int newVal = 42; } break; case ANOTHER_VAL: ... break; }
labeled-statement: identifier : statement case constant-expression : statement default : statement
label can only be a part of statement and declaration is not a statement
case 1: { int x=10; printf(" x is %d", x); } break;
main() { int x; switch(a) { case 1: x=10; break; case 2: x=20; break; } }
switch(a) { printf("This will never print"); case 1: printf(" 1"); break; default: break; }
strcpy(char *to, char *from, size_t count) { int n = (count + 7) / 8; switch (count % 8) { case 0: do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n > 0); } }
switch (...) { case FOO: { MyObject x(...); ... break; } ... }
switch (val) { case VAL: { int newVal = 42; } break; }
switch(val) { case VAL: int newVal = 42; default: int newVal = 23; }
switch (val) { case VAL: { int newVal = 42; break; } case ANOTHER_VAL: ... break; }
switch (val) { /* This *will* work, even in C89 */ int newVal = 42; case VAL: newVal = 1984; break; case ANOTHER_VAL: newVal = 2001; break; }
switch (something) { case 1:; int i = 6; do_stuff_with_i(i); break; case 2: do_something(); break; default: get_a_life(); }
switch (something) { case 1: do_something(); break; case 2: int i = 12; do_something_else(); }
switch (i) { case 0: int j; j = 7; break; case 1: break; }
switch (i) { case 0: int j = 7; break; case 1: break; }
int i; i = 2; switch(i) { case 1: int k; break; case 2: k = 1; cout<<k<<endl; break; }
switch (value) { case 1: int a = 10; break; case 2: int a = 20; break; }
if (value == 1) goto label_1; else if (value == 2) goto label_2; else goto label_end; { label_1: int a = 10; goto label_end; label_2: int a = 20; goto label_end; } label_end:
using namespace std; class X { public: X() { cout << "constructor" << endl; } ~X() { cout << "destructor" << endl; } }; template <class type> void ill_formed() { goto lx; ly: type a; lx: goto ly; } template <class type> void ok() { ly: type a; lx: goto ly; } void test_class() { ok<X>(); ill_formed<X>(); } void test_scalar() { ok<int>(); ill_formed<int>(); } int main(int argc, const char *argv[]) { return 0; }
using namespace std; int test1() { int i = 0; switch(i) { case 1: int r = 1; break; case 2: break; }; } void test2() { int i = 2; switch(i) { case 1: int r; r= 1; break; case 2: cout << "r: " << r << endl; break; }; } int main(int argc, const char *argv[]) { test1(); test2(); return 0; }
struct Foo{}; int main() { int i = 42; switch( i ) { case 42: Foo(); break; default: break; } return EXIT_SUCCESS; }
namespace std { template<typename _Tp> struct is_pod : public integral_constant<bool, __is_pod(_Tp)> { }; }
int main() { // { { { { struct C { C(int) {} }; static_assert(std::is_trivially_copyable<C>(), ""); static_assert(!std::is_trivial<C>(), ""); static_assert(!std::is_pod<C>(), ""); } // { struct C { C() {} }; static_assert(std::is_trivially_copyable<C>(), ""); static_assert(!std::is_trivial<C>(), ""); static_assert(!std::is_pod<C>(), ""); } } { struct C { C(C&) {} }; static_assert(!std::is_trivially_copyable<C>(), ""); static_assert(!std::is_trivial<C>(), ""); static_assert(!std::is_pod<C>(), ""); } } { { { struct C { public: int i; private: int j; }; static_assert(!std::is_standard_layout<C>(), ""); static_assert(!std::is_pod<C>(), ""); } { struct C { private: int i; int j; }; static_assert(std::is_standard_layout<C>(), ""); static_assert(std::is_pod<C>(), ""); struct D { public: int i; int j; }; static_assert(std::is_standard_layout<D>(), ""); static_assert(std::is_pod<D>(), ""); } } { struct C { virtual void f() = 0; }; static_assert(!std::is_standard_layout<C>(), ""); static_assert(!std::is_pod<C>(), ""); } { struct C { int &i; }; static_assert(!std::is_standard_layout<C>(), ""); static_assert(!std::is_pod<C>(), ""); } // { { struct Base1 { int i; }; struct Base2 { int j; }; struct C : Base1, Base2 {}; static_assert(!std::is_standard_layout<C>(), ""); static_assert(!std::is_pod<C>(), ""); } { struct Base1 { int i; }; struct C : Base1 {}; static_assert(std::is_standard_layout<C>(), ""); static_assert(std::is_pod<C>(), ""); } { struct Base1 { int i; }; struct Base2 {}; struct C : Base1, Base2 {}; static_assert(std::is_standard_layout<C>(), ""); static_assert(std::is_pod<C>(), ""); } } { struct C {}; struct D : C { C c; }; }; { // { struct Q {}; struct S : Q { }; struct T : Q { }; struct U : S, T { }; } { struct Base { int i; }; struct Middle : Base {}; struct C : Middle { int j; }; static_assert(!std::is_standard_layout<C>(), ""); static_assert(!std::is_pod<C>(), ""); } // } } } // { { struct C {}; static_assert(std::is_pod<C>(), ""); static_assert(std::is_pod<int>(), ""); } { struct C {}; static_assert(std::is_pod<C>(), ""); static_assert(std::is_pod<C[]>(), ""); } { struct C { private: int i; }; static_assert(std::is_pod<C>(), ""); static_assert(!std::is_pod<C>(), ""); } { static_assert(!std::is_pod<std::vector<int>>(), ""); static_assert(!std::is_trivially_copyable<std::vector<int>>(), ""); static_assert(std::is_pod<std::array<int, 1>>(), ""); } } // // // { struct Pod { uint32_t i; uint64_t j; }; static_assert(std::is_pod<Pod>(), ""); struct NotPod { NotPod(uint32_t i, uint64_t j) : i(i), j(j) {} uint32_t i; uint64_t j; }; static_assert(!std::is_pod<NotPod>(), ""); { struct C { int i; }; struct D : C { int j; }; struct E { D d; } /*__attribute__((packed))*/; static_assert(std::is_pod<C>(), ""); static_assert(!std::is_pod<D>(), ""); static_assert(!std::is_pod<E>(), ""); } } }
for std in 11 14 17; do echo $std; g++-8 -Wall -Werror -Wextra -pedantic -std=c++$std pod.cpp; done
std::string str; char * writable = new char[str.size() + 1]; std::copy(str.begin(), str.end(), writable); writable[str.size()] = delete[] writable;
std::string str; boost::scoped_array<char> writable(new char[str.size() + 1]); std::copy(str.begin(), str.end(), writable.get()); writable[str.size()] =
std::string str; std::vector<char> writable(str.begin(), str.end()); writable.push_back(
const char* p_c_str = x.c_str(); const char* p_data = x.data(); const char* p_x0 = &x[0]; char* p_x0_rw = &x[0];
std::string old_x = x; std::string old_x = x.c_str(); std::vector<char> old_x(x.data(), x.data() + x.size()); std::vector<char> old_x(x.c_str(), x.c_str() + x.size() + 1); char y[N + 1]; strcpy(y, x.c_str()); char y[N + 1]; strncpy(y, x.c_str(), N); y[N] = char* y = alloca(x.size() + 1); strcpy(y, x.c_str()); char y[x.size() + 1]; strcpy(y, x.c_str()); char* y = new char[x.size() + 1]; strcpy(y, x.c_str()); delete[] y; char* y = strdup(x.c_str()); free(y);
std::string const cstr = { "..." }; char const * p = cstr.data();
std::string str = { "..." }; char * p = str.data();
std::string foo{"text"}; std::vector<char> fcv(foo.data(), foo.data()+foo.size()+1u); auto p = fcv.data();
std::string foo{"text"}; std::array<char, 5u> fca; std::copy(foo.data(), foo.data()+foo.size()+1u, fca.begin());
std::string foo{ "text" }; auto p = std::make_unique<char[]>(foo.size()+1u); std::copy(foo.data(), foo.data() + foo.size() + 1u, &p[0]);
std::string foo{ "text" }; char * p = nullptr; try { p = new char[foo.size() + 1u]; std::copy(foo.data(), foo.data() + foo.size() + 1u, p); delete[] p; } catch (...) { if (p) { delete[] p; } throw; }
class DeepString { DeepString(const DeepString& other); DeepString& operator=(const DeepString& other); char* internal_; public: explicit DeepString( const string& toCopy): internal_(new char[toCopy.size()+1]) { strcpy(internal_,toCopy.c_str()); } ~DeepString() { delete[] internal_; } char* str() const { return internal_; } const char* c_str() const { return internal_; } };
void aFunctionAPI(char* input); aFunctionAPI("Foo"); std::string myFoo("Foo"); aFunctionAPI(myFoo.c_str()); aFunctionAPI(const_cast<char*>(myFoo.c_str())); DeepString myDeepFoo(myFoo); aFunctionAPI(myFoo.str());
char* result = strcpy((char*)malloc(str.length()+1), str.c_str());
string str1("stackoverflow"); const char * str2 = str1.c_str();
std::string s(reinterpret_cast<const char *>(Data), Size);
class Foo { public: Foo(char x, int y) {} Foo(int y) : Foo( };
class Foo { public: Foo(char x); Foo(char x, int y); private: void init(char x, int y); }; Foo::Foo(char x) { init(x, int(x) + 7); } Foo::Foo(char x, int y) { init(x, y); } void Foo::init(char x, int y) { }
class SomeType { int number; public: SomeType(int newNumber) : number(newNumber) {} SomeType() : SomeType(42) {} };
class Foo { int d; public: Foo (int i) : d(i) {} Foo () : Foo(42) {} };
class Foo { int d = 5; public: Foo (int i) : d(i) {} };
class Foo() { Foo() { } Foo(Bar myParam) { new (this) Foo(); } };
class Foo() { private: std::vector<int> Stuff; public: Foo() : Stuff(42) { } Foo(Bar myParam) { this->~Foo(); new (this) Foo(); } };
class Vertex { private: int x, y; public: Vertex(int xCoo, int yCoo): x(xCoo), y(yCoo) {} Vertex() { this->Vertex::Vertex(-1, -1); } };
class Test_Base { public Test_Base() { DoSomething(); } }; class Test : public Test_Base { public Test() : Test_Base() { } public Test(int count) : Test_Base() { DoSomethingWithCount(count); } };
public: StreamArrayReader(istream * in_stream); StreamArrayReader(char * filepath);
StreamArrayReader::StreamArrayReader(istream * in_stream){ } StreamArrayReader::StreamArrayReader(char * filepath) { ifstream instream; instream.open(filepath); StreamArrayReader(&instream); instream.close(); }
private: friend void init_stream_array_reader(StreamArrayReader *o, istream * is);
StreamArrayReader::StreamArrayReader(istream * is) { init_stream_array_reader(this, is); }
StreamArrayReader::StreamArrayReader(char * filepath) { ifstream instream; instream.open(filepath); init_stream_array_reader(this, &instream); instream.close(); }
Foo::Foo() { ... } Foo::Foo(char x) { *this = Foo(); ... }
class Foo { public: Foo(char x, int y) {} Foo(int y) : Foo( };
class A { public: A( int a) : m_a(a) { std::cout << "A::Ctor" << std::endl; } ~A() { std::cout << "A::dtor" << std::endl; } public: int m_a; }; class B : public A { public: B( int a, int b) : m_b(b), A(a) {} public: int m_b; }; int main() { B b(9, 6); std::cout << "Test constructor delegation a = " << b.m_a << "; b = " << b.m_b << std::endl; return 0; }
A::Ctor Test constructor delegation a = 9; b = 6 A::dtor
struct Foo { int x; }; class Bar { public: int x; };
std::is_class<Foo>::value std::is_class<Bar>::value
struct Compare { bool operator() { ... } }; std::sort(collection.begin(), collection.end(), Compare());
typedef struct { int messageId; int messageCounter; int messageData; } tMessageType; void processMessage(unsigned char *rawMessage) { tMessageType *messageFields = (tMessageType *)rawMessage; printf("MessageId is %d\n", messageFields->messageId); }
extern "C" { struct foo { ... }; typedef struct foo foo; void bar(foo *fun); }
struct myvec { int x; int y; int z; int length() {return x+y+z;} };
template <typename T> struct type_traits { typedef T type; typedef T::iterator_type iterator_type; ... };
using namespace std; struct student { int age; string name; map<string, int> grades }; class ClassRoom { typedef map<string, student> student_map; public : student getStudentByName(string name) const { student_map::const_iterator m_it = students.find(name); return m_it->second; } private : student_map students; };
struct mycompare : public std::binary_function<int, int, bool> { bool operator()(int first, int second) { return first < second; } }; class mycompare : public std::binary_function<int, int, bool> { public: bool operator()(int first, int second) { return first < second; } };
int main ( int argc, char* argv[] ) { std::string program(argv[0]); }
int main ( int argc, char* argv[] ) { std::string * program = new std::string(argv[0]); delete program; }
class Line { public: Line(); ~Line(); std::string* mString; }; Line::Line() { mString = new std::string("foo_bar"); } Line::~Line() { delete mString; }
class Line { public: Line(); std::string mString; }; Line::Line() { mString = "foo_bar"; }
std::string *someString = new std::string(...); delete someString;
std::string someString(...); std::string otherString; otherString = someString;
someString += "More text."; if(otherString == someString) { }
class File { private: FileImpl * fd; public: File(String fn){ fd = new FileImpl(fn);}
foo(shared_ptr<T1>(new T1()), shared_ptr<T2>(new T2()));
section .data fmt db "%d", 10, 0 global main extern printf section .text main: mov rcx, 1000000 xor rdi, rdi ; max i xor rsi, rsi ; i l1: dec rcx xor r10, r10 ; count mov rax, rcx l2: test rax, 1 jpe even mov rbx, 3 mul rbx inc rax jmp c1 even: mov rbx, 2 xor rdx, rdx div rbx c1: inc r10 cmp rax, 1 jne l2 cmp rdi, r10 cmovl rdi, r10 cmovl rsi, rcx cmp rcx, 2 jne l1 mov rdi, fmt xor rax, rax call printf ret
using namespace std; int sequence(long n) { int count = 1; while (n != 1) { if (n % 2 == 0) n /= 2; else n = n*3 + 1; ++count; } return count; } int main() { int max = 0, maxi; for (int i = 999999; i > 0; --i) { int s = sequence(i); if (s > max) { max = s; maxi = i; } } cout << maxi << endl; }
.L9: lea rcx, [rax+1+rax*2] mov rdi, rax shr rdi test al, 1 mov rax, rcx cmove rax, rdi add edx, 1 cmp rax, 1 jne .L9 cmp/branch to update max and maxi, and then do the next n
.L9: lea rcx, [rax+1+rax*2] shr rax, 1 cmovc rax, rcx inc edx cmp rax, 1 jne .L9
.inner_loop: vpaddq ymm1, ymm0, xmm0 vpaddq ymm1, ymm1, xmm0 vpaddq ymm1, ymm1, set1_epi64(1) vprllq ymm3, ymm0, 63 vpsrlq ymm0, ymm0, 1 vpblendvpd ymm0, ymm0, ymm1, ymm3 vpcmpeqq ymm1, ymm0, set1_epi64(1) vpandn ymm4, ymm1, ymm4 vpaddq ymm5, ymm5, ymm4 vptest ymm4, ymm4 jnz .inner_loop vextracti128 ymm0, ymm5, 1 vpmaxq .... crap this doesn
goto loop_entry; do { n = n*3 + 1; loop_entry: shift = _tzcnt_u64(n); n >>= shift; count += shift; } while(n != 1);
.seq: inc esi ; counter lea edx, [3*eax+1] ; edx = 3*n+1 shr eax, 1 ; eax = n/2 cmovc eax, edx ; if CF eax = edx jnz .seq ; jmp if n<>1
include "%lib%/freshlib.inc" @BinaryType console, compact options.DebugMode = 1 include "%lib%/freshlib.asm" start: InitializeAll mov ecx, 999999 xor edi, edi ; max xor ebx, ebx ; max i .main_loop: xor esi, esi mov eax, ecx .seq: inc esi ; counter lea edx, [3*eax+1] ; edx = 3*n+1 shr eax, 1 ; eax = n/2 cmovc eax, edx ; if CF eax = edx jnz .seq ; jmp if n<>1 cmp edi, esi cmovb edi, esi cmovb ebx, ecx dec ecx jnz .main_loop OutputValue "Max sequence: ", edi, 10, -1 OutputValue "Max index: ", ebx, 10, -1 FinalizeAll stdcall TerminateAll, 0
while (n % 2 == 0) n /= 2; if (n > 1) for (;;) { n = (3*n + 1) / 2; if (n % 2 == 0) { do n /= 2; while (n % 2 == 0); if (n == 1) break; } }
3n+1 -> ???? 0000 0100 / 2 -> ???? ?000 0010 / 2 -> ???? ??00 0001 3n+1 -> ???? ??00 0100 / 2 -> ???? ???0 0010 / 2 -> ???? ???? 0001 3n+1 -> ???? ???? 0100 / 2 -> ???? ???? ?010 / 2 -> ???? ???? ??01 3n+1 -> ???? ???? ??00 / 2 -> ???? ???? ???0 / 2 -> ???? ???? ????
k = n / 256; m = n % 256; switch (m) { case 0: n = 1 * k + 0; break; case 1: n = 81 * k + 1; break; case 2: n = 81 * k + 1; break; ... case 155: n = 729 * k + 425; break; ... }
static const unsigned int multipliers [256] = { ... } static const unsigned int adders [256] = { ... } while (n > 128) { size_t lastBits = n % 256; n = (n >> 8) * multipliers [lastBits] + adders [lastBits]; }
(N << 1) + N + 1: (N >> 1) + N + 1: b10 b1 b1 b + 1 + 1 ---- --- bBb0 bBb
uint64_t sequence(uint64_t size, uint64_t *path) { uint64_t n, i, c, maxi = 0, maxc = 0; for (n = i = (size - 1) | 1; i > 2; n = i -= 2) { c = 2; while ((n = ((n & 3)? (n >> 1) + n + 1 : (n >> 2))) > 2) c += 2; if (n == 2) c++; if (c > maxc) { maxi = i; maxc = c; } } *path = maxc; return maxi; } int main() { uint64_t maxi, maxc; maxi = sequence(1000000, &maxc); printf("%llu, %llu\n", maxi, maxc); return 0; }
MOV RCX, 1000000; DEC RCX; AND RCX, -2; XOR RAX, RAX; MOV RBX, RAX; @main: XOR RSI, RSI; LEA RDI, [RCX + 1]; @loop: ADD RSI, 2; LEA RDX, [RDI + RDI*2 + 2]; SHR RDX, 1; SHRD RDI, RDI, 2; ror rdi,2 would do the same thing CMOVL RDI, RDX; Note that SHRD leaves OF = undefined with count>1, and this doesn CMOVS RDI, RDX; CMP RDI, 2; JA @loop; LEA RDX, [RSI + 1]; CMOVE RSI, RDX; CMP RAX, RSI; CMOVB RAX, RSI; CMOVB RBX, RCX; SUB RCX, 2; JA @main; MOV RDI, RCX; ADD RCX, 10; PUSH RDI; PUSH RCX; @itoa: XOR RDX, RDX; DIV RCX; ADD RDX, PUSH RDX; TEST RAX, RAX; JNE @itoa; PUSH RCX; LEA RAX, [RBX + 1]; TEST RBX, RBX; MOV RBX, RDI; JNE @itoa; POP RCX; INC RDI; MOV RDX, RDI; @outp: MOV RSI, RSP; MOV RAX, RDI; SYSCALL; POP RAX; TEST RAX, RAX; JNE @outp; LEA RAX, [RDI + 59]; DEC RDI; SYSCALL;
import sys inner_loop = 0 def collatz_sequence(N, cache): global inner_loop l = [ ] stop = False n = N tails = [ ] while not stop: inner_loop += 1 tmp = n l.append(n) if n <= 1: stop = True elif n in cache: stop = True elif n % 2: n = 3*n + 1 else: n = n tails.append((tmp, len(l))) for key, offset in tails: if not key in cache: cache[key] = l[offset:] return l def gen_sequence(l, cache): for elem in l: yield elem if elem in cache: yield from gen_sequence(cache[elem], cache) raise StopIteration if __name__ == "__main__": le_cache = {} for n in range(1, 4711, 5): l = collatz_sequence(n, le_cache) print("{}: {}".format(n, len(list(gen_sequence(l, le_cache))))) print("inner_loop = {}".format(inner_loop))
if (n & 1) { n = (n*3 + 1) >> 1; count += 2; } else { n >>= 1; ++count; }
class IDemo { public: virtual ~IDemo() {} virtual void OverrideMe() = 0; }; class Parent { public: virtual ~Parent(); }; class Child : public Parent, public IDemo { public: virtual void OverrideMe() { } };
class IDemo { public: virtual ~IDemo() {} virtual void OverrideMe() = 0; }; class Child : public IDemo { public: virtual void OverrideMe() { } };
class IBase { public: virtual ~IBase() {}; virtual void Describe() = 0; }; class Tester : public IBase { public: Tester(std::string name); virtual ~Tester(); virtual void Describe(); private: std::string privatename; }; Tester::Tester(std::string name) { std::cout << "Tester constructor" << std::endl; this->privatename = name; } Tester::~Tester() { std::cout << "Tester destructor" << std::endl; } void Tester::Describe() { std::cout << "I } void descriptor(IBase * obj) { obj->Describe(); } int main(int argc, char** argv) { std::cout << std::endl << "Tester Testing..." << std::endl; Tester * obj1 = new Tester("Declared with Tester"); descriptor(obj1); delete obj1; std::cout << std::endl << "IBase Testing..." << std::endl; IBase * obj2 = new Tester("Declared with IBase"); descriptor(obj2); delete obj2; std::cout << std::endl << "Tester not defined..." << std::endl; descriptor(new Tester("Not defined")); return 0; }
class IDemo { public: virtual void OverrideMe() = 0; virtual ~IDemo() {} }
class IDemo { public: virtual void OverrideMe() = 0; protected: ~IDemo() {} }
class Child : virtual public IDemo { public: virtual void OverrideMe() { } }
--- header file ---- class foo { public: foo() {;} virtual ~foo() = 0; virtual bool overrideMe() {return false;} }; ---- source ---- foo::~foo() { }
struct Interface { explicit Interface(SomeType& other) : foo([=](){ return other.my_foo(); }), bar([=](){ return other.my_bar(); }), {} explicit Interface(SomeOtherType& other) : foo([=](){ return other.some_foo(); }), bar([=](){ return other.some_bar(); }), {} template<class T> explicit Interface(T& other) : foo([=](){ return other.foo(); }), bar([=](){ return other.bar(); }), {} const std::function<void(std::string)> foo; const std::function<void(std::string)> bar; };
struct MyShape { virtual void my_draw() = 0; }; struct Circle : MyShape { void my_draw() { } };
struct YourShape { virtual void your_draw() = 0; }; struct Square : YourShape { void your_draw() { } };
struct Circle : MyShape, YourShape { void my_draw() { }; void your_draw() { my_draw(); } };
struct __declspec(novtable) IFoo { virtual void Bar() = 0; }; class Child : public IFoo { public: virtual void Bar() override { } }
struct Contract1 : boost::noncopyable { virtual ~Contract1(); void f(Parameters p) { assert(checkFPreconditions(p)&&"Contract1::f, pre-condition failure"); do_f(p); } private: virtual void do_f(Parameters p) = 0; }; ... class Concrete : public Contract1, public Contract2 { private: virtual void do_f(Parameters p); virtual void do_g(Parameters p); };
__interface IMyInterface { HRESULT CommitX(); HRESULT get_X(BSTR* pbstrName); };
struct IButton { void (*click)(); IButton( void (*click_)() ) : click(click_) { } };
class Shape { public: virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; class Rectangle: public Shape { public: int getArea() { return (width * height); } }; class Triangle: public Shape { public: int getArea() { return (width * height)/2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); cout << "Rectangle area: " << Rect.getArea() << endl; Tri.setWidth(5); Tri.setHeight(7); cout << "Triangle area: " << Tri.getArea() << endl; return 0; }
struct add_x { add_x(int x) : x(x) {} int operator()(int y) const { return x + y; } private: int x; }; add_x add42(42); int i = add42(8); assert(i == 50); std::vector<int> in; std::vector<int> out(in.size()); std::transform(in.begin(), in.end(), out.begin(), add_x(1)); assert(out[i] == in[i] + 1);
class Foo { public: void operator () (int i) { printf("Foo %d", i); } }; void Bar(int i) { printf("Bar %d", i); } Foo foo; boost::function<void (int)> f(foo); f(1); boost::function<void (int)> b(&Bar); b(1);
boost::function<void ()> f1 = boost::bind(foo, 2); f1(); boost::function<void ()> b1 = boost::bind(&Bar, 2); b1();
class SomeClass { std::string state_; public: SomeClass(const char* s) : state_(s) {} void method( std::string param ) { std::cout << state_ << param << std::endl; } }; SomeClass *inst = new SomeClass("Hi, i am "); boost::function< void (std::string) > callback; callback = boost::bind(&SomeClass::method, inst, _1); callback("useless");
std::list< boost::function<void (EventArg e)> > events; .... std::for_each( events.begin(), events.end(), boost::bind( boost::apply<void>(), _1, e));
class MyFunctor { public: int operator()(int x) { return x * 2;} } MyFunctor doubler; int x = doubler(5);
class Matcher { int target; public: Matcher(int m) : target(m) {} bool operator()(int x) { return x == target;} } Matcher Is5(5); if (Is5(n)) { ....}
class MultiplyBy { private: int factor; public: MultiplyBy(int x) : factor(x) { } int operator () (int other) const { return factor * other; } };
int array[5] = {1, 2, 3, 4, 5}; std::transform(array, array + 5, array, MultiplyBy(3));
class myFunctor { public: /* myFunctor is the constructor. parameterVar is the parameter passed to the constructor. : is the initializer list operator. myObject is the private member object of the myFunctor class. parameterVar is passed to the () operator which takes it and adds it to myObject in the overloaded () operator function. */ myFunctor (int parameterVar) : myObject( parameterVar ) {} /* the "operator" word is a keyword which indicates this function is an overloaded operator function. The () following this just tells the compiler that () is the operator being overloaded. Following that is the parameter for the overloaded operator. This parameter is actually the argument "parameterVar" passed by the constructor we just wrote. The last part of this statement is the overloaded operators body which adds the parameter passed to the member object. */ int operator() (int myArgument) { return myObject + myArgument; } private: int myObject; };
template<class F, class T, class U=decltype(std::declval<F>()(std::declval<T>()))> std::vector<U> fmap(F f, const std::vector<T>& vec) { std::vector<U> result; std::transform(vec.begin(), vec.end(), std::back_inserter(result), f); return result; }
template<class F, class T, class U=decltype(std::declval<F>()(std::declval<T>()))> std::shared_ptr<U> fmap(F f, const std::shared_ptr<T>& p) { if (p == nullptr) return nullptr; else return std::shared_ptr<U>(new U(f(*p))); }
double to_double(int x) { return x; } std::shared_ptr<int> i(new int(3)); std::shared_ptr<double> d = fmap(to_double, i); std::vector<int> is = { 1, 2, 3 }; std::vector<double> ds = fmap(to_double, is);
struct identity_f { template<class T> T operator()(T x) const { return x; } }; identity_f identity = {}; std::vector<int> is = { 1, 2, 3 }; std::vector<int> is1 = fmap(identity, is); std::vector<int> is2 = identity(is);
double to_double(int x) { return x; } struct foo { double x; }; foo to_foo(double x) { foo r; r.x = x; return r; } std::vector<int> is = { 1, 2, 3 }; std::vector<foo> is1 = fmap(std::bind(to_foo, std::bind(to_double, _1)), is); std::vector<foo> is2 = fmap(to_foo, fmap(to_double, is));
int CTask::ThreeParameterTask(int par1, int par2, int par3)
template<typename _Ret,typename _Class,typename _arg1,typename _arg2,typename _arg3> class mem_fun3_t { public: explicit mem_fun3_t(_Ret (_Class::*_Pm)(_arg1,_arg2,_arg3)) :m_Ptr(_Pm) {} _Ret operator()(_Class *_P, _arg1 arg1, _arg2 arg2, _arg3 arg3) const { return ((_P->*m_Ptr)(arg1,arg2,arg3)); } private: _Ret (_Class::*m_Ptr)(_arg1,_arg2,_arg3); };
template<typename _Ret,typename _Class,typename _arg1,typename _arg2,typename _arg3> mem_fun3_t<_Ret,_Class,_arg1,_arg2,_arg3> mem_fun3 ( _Ret (_Class::*_Pm) (_arg1,_arg2,_arg3) ) { return (mem_fun3_t<_Ret,_Class,_arg1,_arg2,_arg3>(_Pm));
template<typename _Func,typename _Ptr,typename _arg1,typename _arg2,typename _arg3> class binder3 { public: binder3(_Func fn,_Ptr ptr,_arg1 i,_arg2 j,_arg3 k) :m_ptr(ptr),m_fn(fn),m1(i),m2(j),m3(k){} void operator()() const { m_fn(m_ptr,m1,m2,m3); } private: _Ptr m_ptr; _Func m_fn; _arg1 m1; _arg2 m2; _arg3 m3; };
template <typename _Func, typename _P1,typename _arg1,typename _arg2,typename _arg3> binder3<_Func, _P1, _arg1, _arg2, _arg3> bind3(_Func func, _P1 p1,_arg1 i,_arg2 j,_arg3 k) { return binder3<_Func, _P1, _arg1, _arg2, _arg3> (func, p1,i,j,k); }
typedef binder3<mem_fun3_t<int,T,int,int,int> ,T* ,int,int,int> F3; explicit Command(T* pObj,F3* p_method,long timeout,const char* key, long priority = PRIO_NORMAL ): m_objptr(pObj),m_timeout(timeout),m_key(key),m_value(priority),method1(0),method0(0), method(0) { method3 = p_method; }
F3 f3 = PluginThreadPool::bind3( PluginThreadPool::mem_fun3( &CTask::ThreeParameterTask), task1,2122,23 );
class Functor { public: std::string output; Functor(const std::string& out): output(out){} operator()() const { std::cout << output << " "; } }; int main(int argc, char **argv) { std::list<Functor> taskQueue; taskQueue.push_back(Functor("this")); taskQueue.push_back(Functor("is a")); taskQueue.push_back(Functor("very simple")); taskQueue.push_back(Functor("and poorly used")); taskQueue.push_back(Functor("task queue")); for(std::list<Functor>::iterator it = taskQueue.begin(); it != taskQueue.end(); ++it) { *it(); } return 0; } int i; bool should_increment; int doSomeWork() { std::cout << "i = " << i << std::endl; std::cout << "increment? (enter the number 1 to increment, 0 otherwise" << std::endl; std::cin >> should_increment; return 2; } void doSensitiveWork() { ++i; should_increment = false; } class BaseCoroutine { public: BaseCoroutine(int stat): status(stat), waiting(false){} void operator()(){ status = perform(); } int getStatus() const { return status; } protected: int status; bool waiting; virtual int perform() = 0; bool await_status(BaseCoroutine& other, int stat, int change) { if(!waiting) { waiting = true; } if(other.getStatus() == stat) { status = change; waiting = false; } return !waiting; } } class MyCoroutine1: public BaseCoroutine { public: MyCoroutine1(BaseCoroutine& other): BaseCoroutine(1), partner(other){} protected: BaseCoroutine& partner; virtual int perform() { if(getStatus() == 1) return doSomeWork(); if(getStatus() == 2) { if(await_status(partner, 1)) return 1; else if(i == 100) return 0; else return 2; } } }; class MyCoroutine2: public BaseCoroutine { public: MyCoroutine2(bool& work_signal): BaseCoroutine(1), ready(work_signal) {} protected: bool& work_signal; virtual int perform() { if(i == 100) return 0; if(work_signal) { doSensitiveWork(); return 2; } return 1; } }; int main() { std::list<BaseCoroutine* > coroutineList; MyCoroutine2 *incrementer = new MyCoroutine2(should_increment); MyCoroutine1 *printer = new MyCoroutine1(incrementer); while(coroutineList.size()) { for(std::list<BaseCoroutine *>::iterator it = coroutineList.begin(); it != coroutineList.end(); ++it) { *it(); if(*it.getStatus() == 0) { coroutineList.erase(it); } } } delete printer; delete incrementer; return 0; }
template <typename T> T min3(const T& a, const T& b, const T& c) { return std::min(std::min(a, b), c); } class levenshtein_distance { mutable std::vector<std::vector<unsigned int> > matrix_; public: explicit levenshtein_distance(size_t initial_size = 8) : matrix_(initial_size, std::vector<unsigned int>(initial_size)) { } unsigned int operator()(const std::string& s, const std::string& t) const { const size_t m = s.size(); const size_t n = t.size(); if (m == 0) { return n; } if (n == 0) { return m; } if (matrix_.size() < m + 1) { matrix_.resize(m + 1, matrix_[0]); } if (matrix_[0].size() < n + 1) { for (auto& mat : matrix_) { mat.resize(n + 1); } } unsigned int i, j; for (i = 1; i <= m; ++i) { matrix_[i][0] = i; } for (j = 1; j <= n; ++j) { matrix_[0][j] = j; } for (j = 1; j <= n; ++j) { for (i = 1; i <= m; ++i) { unsigned int substitution_cost = s[i - 1] == t[j - 1] ? 0 : 1; matrix_[i][j] = min3(matrix_[i - 1][j] + 1, matrix_[i][j - 1] + 1, matrix_[i - 1][j - 1] + substitution_cost); } } return matrix_[m][n]; } };
template< class T > using MyType = AnotherType< T, MyAllocatorType >;
template <typename T> struct whatever {}; template <typename T> struct rebind { typedef whatever<T> type; }; rebind<int>::type variable; template <typename U> struct bar { typename rebind<U>::type _var_member; }
template <typename T> using my_type = whatever<T>; my_type<int> variable; template <typename U> struct baz { my_type<U> _var_member; }
namespace std { template<typename T> using add_const_t = typename add_const<T>::type; }
typedef struct { int x = 0; } Foo; struct Foo { int x = 0; };
std::string s; s.erase(s.find_last_not_of(" \n\r\t")+1);
static inline void ltrim(std::string &s) { s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) { return !std::isspace(ch); })); } static inline void rtrim(std::string &s) { s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) { return !std::isspace(ch); }).base(), s.end()); } static inline void trim(std::string &s) { ltrim(s); rtrim(s); } static inline std::string ltrim_copy(std::string s) { ltrim(s); return s; } static inline std::string rtrim_copy(std::string s) { rtrim(s); return s; } static inline std::string trim_copy(std::string s) { trim(s); return s; }
static inline std::string &ltrim(std::string &s) { s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace)))); return s; } static inline std::string &rtrim(std::string &s) { s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end()); return s; } static inline std::string &trim(std::string &s) { return ltrim(rtrim(s)); }
static inline void ltrim(std::string &s) { s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace)))); } static inline void rtrim(std::string &s) { s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end()); } static inline void trim(std::string &s) { ltrim(s); rtrim(s); } static inline std::string ltrim_copy(std::string s) { ltrim(s); return s; } static inline std::string rtrim_copy(std::string s) { rtrim(s); return s; } static inline std::string trim_copy(std::string s) { trim(s); return s; }
std::string str("hello world! "); boost::trim_right(str);
size_t endpos = str.find_last_not_of(" \t"); size_t startpos = str.find_first_not_of(" \t"); if( std::string::npos != endpos ) { str = str.substr( 0, endpos+1 ); str = str.substr( startpos ); } else { str.erase(std::remove(std::begin(str), std::end(str), }
size_t startpos = str.find_first_not_of(" \t"); if( string::npos != startpos ) { str = str.substr( startpos ); }
inline std::string trim(const std::string &s) { auto wsfront=std::find_if_not(s.begin(),s.end(),[](int c){return std::isspace(c);}); auto wsback=std::find_if_not(s.rbegin(),s.rend(),[](int c){return std::isspace(c);}).base(); return (wsback<=wsfront ? std::string() : std::string(wsfront,wsback)); }
inline std::string trim(const std::string &s) { auto wsfront=std::find_if_not(s.begin(),s.end(),[](int c){return std::isspace(c);}); return std::string(wsfront,std::find_if_not(s.rbegin(),std::string::const_reverse_iterator(wsfront),[](int c){return std::isspace(c);}).base()); }
const char* ws = " \t\n\r\f\v"; inline std::string& rtrim(std::string& s, const char* t = ws) { s.erase(s.find_last_not_of(t) + 1); return s; } inline std::string& ltrim(std::string& s, const char* t = ws) { s.erase(0, s.find_first_not_of(t)); return s; } inline std::string& trim(std::string& s, const char* t = ws) { return ltrim(rtrim(s, t), t); }
inline std::string trim(std::string& str) { str.erase(0, str.find_first_not_of( str.erase(str.find_last_not_of( return str; }
std::stringstream trimmer; trimmer << str; str.clear(); trimmer >> str;
std::string trim(const std::string &s) { std::string::const_iterator it = s.begin(); while (it != s.end() && isspace(*it)) it++; std::string::const_reverse_iterator rit = s.rbegin(); while (rit.base() != it && isspace(*rit)) rit++; return std::string(it, rit.base()); }
string choppa(const string &t, const string &ws) { string str = t; size_t found; found = str.find_last_not_of(ws); if (found != string::npos) str.erase(found+1); else str.clear(); return str; }
const std::string StringUtils::WHITESPACE = " \n\r\t"; std::string StringUtils::Trim(const std::string& s) { return TrimRight(TrimLeft(s)); } std::string StringUtils::TrimLeft(const std::string& s) { size_t startpos = s.find_first_not_of(StringUtils::WHITESPACE); return (startpos == std::string::npos) ? "" : s.substr(startpos); } std::string StringUtils::TrimRight(const std::string& s) { size_t endpos = s.find_last_not_of(StringUtils::WHITESPACE); return (endpos == std::string::npos) ? "" : s.substr(0, endpos+1); }
/** * @brief Left Trim * * Trims whitespace from the left end of the provided std::string * * @param[out] s The std::string to trim * * @return The modified std::string& */ std::string& ltrim(std::string& s) { s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::ptr_fun<int, int>(std::isgraph))); return s; } /** * @brief Right Trim * * Trims whitespace from the right end of the provided std::string * * @param[out] s The std::string to trim * * @return The modified std::string& */ std::string& rtrim(std::string& s) { s.erase(std::find_if(s.rbegin(), s.rend(), std::ptr_fun<int, int>(std::isgraph)).base(), s.end()); return s; } /** * @brief Trim * * Trims whitespace from both ends of the provided std::string * * @param[out] s The std::string to trim * * @return The modified std::string& */ std::string& trim(std::string& s) { return ltrim(rtrim(s)); }
void trim(string& s) { while(s.compare(0,1," ")==0) s.erase(s.begin()); while(s.size()>0 && s.compare(s.size()-1,1," ")==0) s.erase(s.end()-1); }
void TrimString(std::string & str) { if(str.empty()) return; const auto pStr = str.c_str(); size_t front = 0; while(front < str.length() && std::isspace(int(pStr[front]))) {++front;} size_t back = str.length(); while(back > front && std::isspace(int(pStr[back-1]))) {--back;} if(0 == front) { if(back < str.length()) { str.resize(back - front); } } else if(back <= front) { str.clear(); } else { str = std::move(std::string(str.begin()+front, str.begin()+back)); } }
s.erase(0, s.find_first_not_of(" \n\r\t")); s.erase(s.find_last_not_of(" \n\r\t")+1);
std::string ltrim(const std::string& s) { static const std::regex lws{"^[[:space:]]*", std::regex_constants::extended}; return std::regex_replace(s, lws, ""); } std::string rtrim(const std::string& s) { static const std::regex tws{"[[:space:]]*$", std::regex_constants::extended}; return std::regex_replace(s, tws, ""); } std::string trim(const std::string& s) { return ltrim(rtrim(s)); }
std::string & trim(std::string & str) { return ltrim(rtrim(str)); }
std::string & ltrim(std::string & str) { auto it = std::find_if( str.begin() , str.end() , [](char ch){ return !std::isspace<char>(ch , std::locale::classic() ) ; } ); str.erase( str.begin() , it); return str; } std::string & rtrim(std::string & str) { auto it = std::find_if( str.rbegin() , str.rend() , [](char ch){ return !std::isspace<char>(ch , std::locale::classic() ) ; } ); str.erase( it.base() , str.end() ); return str; }
std::string trim_copy(std::string const & str) { auto s = str; return ltrim(rtrim(s)); }
static void trim(std::string &s) { s.erase(s.begin(), std::find_if_not(s.begin(), s.end(), [](char c){ return std::isspace(c); })); s.erase(std::find_if_not(s.rbegin(), s.rend(), [](char c){ return std::isspace(c); }).base(), s.end()); }
inline const char* trim_start(const char* str) { while (memchr(" \t\n\r", *str, 4)) ++str; return str; } inline const char* trim_end(const char* end) { while (memchr(" \t\n\r", end[-1], 4)) --end; return end; } inline std::string trim(const char* buffer, int len) { return std::string(trim_start(buffer), trim_end(buffer + len)); } inline void trim_inplace(std::string& str) { str.assign(trim_start(str.c_str()), trim_end(str.c_str() + str.length())); } int main() { char str [] = "\t \nhello\r \t \n"; string trimmed = trim(str, strlen(str)); cout << " system("pause"); return 0; }
std::stringstream trimmer; trimmer << str; trimmer >> str;
std::string& trim_left_in_place(std::string& str) { size_t i = 0; while(i < str.size() && isspace(str[i])) { ++i; }; return str.erase(0, i); } std::string& trim_right_in_place(std::string& str) { size_t i = str.size(); while(i > 0 && isspace(str[i - 1])) { --i; }; return str.erase(i, str.size()); } std::string& trim_in_place(std::string& str) { return trim_left_in_place(trim_right_in_place(str)); } std::string trim_right(std::string str) { return trim_right_in_place(str); } std::string trim_left(std::string str) { return trim_left_in_place(str); } std::string trim(std::string str) { return trim_left_in_place(trim_right_in_place(str)); } int main() { std::string s1(" \t\r\n "); std::string s2(" \r\nc"); std::string s3("c \t"); std::string s4(" \rc "); assert(trim(s1) == ""); assert(trim(s2) == "c"); assert(trim(s3) == "c"); assert(trim(s4) == "c"); assert(s1 == " \t\r\n "); assert(s2 == " \r\nc"); assert(s3 == "c \t"); assert(s4 == " \rc "); assert(trim_in_place(s1) == ""); assert(trim_in_place(s2) == "c"); assert(trim_in_place(s3) == "c"); assert(trim_in_place(s4) == "c"); assert(s1 == ""); assert(s2 == "c"); assert(s3 == "c"); assert(s4 == "c"); }
while ( !s.empty() && isspace(s.back()) ) s.pop_back();
size_t beg = s.find_first_not_of(" \r\n"); return (beg == string::npos) ? "" : in.substr(beg, s.find_last_not_of(" \r\n") - beg);
string trim(char const *str) { while(!isalnum(*str)) str++; end = str + strlen(str) - 1; while(end > str && !isalnum(*end)) end--; return string(str, end+1); }
static inline std::string &trimAll(std::string &s) { if(s.size() == 0) { return s; } int val = 0; for (int cur = 0; cur < s.size(); cur++) { if(s[cur] != { s[val] = s[cur]; val++; } } s.resize(val); return s; }
string strip(const string& s, const string& chars=" ") { size_t begin = 0; size_t end = s.size()-1; for(; begin < s.size(); begin++) if(chars.find_first_of(s[begin]) == string::npos) break; for(; end > begin; end--) if(chars.find_first_of(s[end]) == string::npos) break; return s.substr(begin, end-begin+1); }
std::string ltrim( std::string str ) { return std::regex_replace( str, std::regex("^\\s+"), std::string("") ); } std::string rtrim( std::string str ) { return std::regex_replace( str, std::regex("\\s+$"), std::string("") ); } std::string trim( std::string str ) { return ltrim( rtrim( str ) ); } int main() { std::string str = " \t this is a test string \n "; std::cout << "-" << trim( str ) << "-\n"; return 0; }
std::string & trimMe (std::string & str) { while (str.length () > 0 && (str [str.length ()-1] == str.erase (str.length ()-1, 1); while (str.length () > 0 && (str [0] == str.erase (0, 1); return str; }
string trimSpace(const string &str) { if (str.empty()) return str; string::size_type i,j; i=0; while (i<str.size() && isspace(str[i])) ++i; if (i == str.size()) return string(); j = str.size() - 1; while (isspace(str[j])) --j return str.substr(i, j-i+1); }
int main(int argc, char* argv[]) { const char text[] = "olé" ; std::cout << "sizeof(char) : " << sizeof(char) << std::endl ; std::cout << "text : " << text << std::endl ; std::cout << "sizeof(text) : " << sizeof(text) << std::endl ; std::cout << "strlen(text) : " << strlen(text) << std::endl ; std::cout << "text(ordinals) :" ; for(size_t i = 0, iMax = strlen(text); i < iMax; ++i) { std::cout << " " << static_cast<unsigned int>( static_cast<unsigned char>(text[i]) ); } std::cout << std::endl << std::endl ; const wchar_t wtext[] = L"olé" ; std::cout << "sizeof(wchar_t) : " << sizeof(wchar_t) << std::endl ; std::cout << "wtext : UNABLE TO CONVERT NATIVELY." << std::endl ; std::wcout << L"wtext : " << wtext << std::endl; std::cout << "sizeof(wtext) : " << sizeof(wtext) << std::endl ; std::cout << "wcslen(wtext) : " << wcslen(wtext) << std::endl ; std::cout << "wtext(ordinals) :" ; for(size_t i = 0, iMax = wcslen(wtext); i < iMax; ++i) { std::cout << " " << static_cast<unsigned int>( static_cast<unsigned short>(wtext[i]) ); } std::cout << std::endl << std::endl ; return 0; }
UCS2String ConvertToUCS2( const UTF8String &str ); UTF8String ConvertToUTF8( const UCS2String &str );
typedef std::wstring unicodestring; std::string formatForConsole(const unicodestring &str) { std::string result; return result; } typedef std::string unicodestring; std::string formatForConsole(const unicodestring &str) { return str; } int main() { unicodestring fileName(UNI("fileName")); std::ofstream fout; fout.open(fileName); std::cout << formatForConsole(fileName) << std::endl; return 0; }
foo(foo const& other) { this->length = other.length; this->ptr = new int[other.length]; copy(other.ptr, other.ptr + other.length, this->ptr); }
foo(foo&& other) { this->length = other.length; this->ptr = other.ptr; other.length = 0; other.ptr = nullptr; }
template <typename T, typename A1> std::unique_ptr<T> factory(A1& a1) { return std::unique_ptr<T>(new T(a1)); }
template <typename T, typename A1> std::unique_ptr<T> factory(A1&& a1) { return std::unique_ptr<T>(new T(std::forward<A1>(a1))); }
auto p1 = factory<foo>(foo()); auto p2 = factory<foo>(*p1);
std::string s; std::string another(s); std::string more(std::string(s));
std::string s; std::string another(s); std::string more(std::string(s));
std::string s; std::string& ref = s; (std::string&)& anotherref = ref;
(std::string&)&& ref (const std::string&)&& ref (std::string&&)&& ref (const std::string&&)&& ref
template<typename A, typename B> auto min(A&& aref, B&& bref) { if (std::forward<A>(aref) < std::forward<B>(bref)) return std::forward<A>(aref); else return std::forward<B>(bref); }
template<class T> foo(T&& t) { ... } auto&& t = ...; typedef ... T; T&& t = ...; decltype(...)&& t = ...;
void foo(X& x); void foo(X&& x); X x; X foobar(); foo(x); foo(foobar());
class Sample { int *ptr; int size; public: Sample(int sz=0) : ptr{sz != 0 ? new int[sz] : nullptr}, size{sz} {} Sample(const Sample& s) : ptr{s.size != 0 ? new int[s.size] :\ nullptr}, size{s.size} { std::cout << "copy constructor called on lvalue\n"; } Sample(Sample&& s) { ptr = s.ptr; size = s.size; s.ptr = nullptr; s.size = 0; cout << "Move constructor called on rvalue." << std::endl; } Sample& operator=(const Sample& s) { if(this != &s) { delete [] ptr; ptr = new int[s.size]; size = s.size; } cout << "Copy Assignment called on lvalue." << std::endl; return *this; } Sample& operator=(Sample&& lhs) { if(this != &s) { delete [] ptr; ptr = lhs.ptr; size = lhs.size; lhs.ptr = nullptr; lhs.size = 0; } cout << "Move Assignment called on rvalue" << std::endl; return *this; } };
template<class T> class unique_ptr { unique_ptr(unique_ptr&& __u) noexcept; }; std::unique_ptr<int[] pt1{new int[10]}; std::unique_ptr<int[]> ptr2{ptr1}; std::unique_ptr<int[]> ptr2{std::move(ptr1)}; std::unique_ptr<int[]> TakeOwnershipAndAlter(std::unique_ptr<int[]> param,\ int size) { for (auto i = 0; i < size; ++i) { param[i] += 10; } return param; } unique_ptr<int[]> ptr{new int[10]}; unique_ptr<int[]> new_owner = TakeOwnershipAndAlter(\ static_cast<unique_ptr<int[]>&&>(ptr), 10); cout << "output:\n"; for(auto i = 0; i< 10; ++i) { cout << new_owner[i] << ", "; } output: 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
unique_ptr<int[]> new_owner = TakeOwnershipAndAlter(std::move(ptr),0);
std::string data = "Abc"; std::transform(data.begin(), data.end(), data.begin(), ::tolower);
char easytolower(char in) { if(in <= return in - ( return in; } std::transform(data.begin(), data.end(), data.begin(), easytolower);
std::string str = "HELLO, WORLD!"; boost::algorithm::to_lower(str);
const std::string str = "HELLO, WORLD!"; const std::string lower_str = boost::algorithm::to_lower_copy(str);
int main() { char const * someString = "Eidenges\xe4\xdf"; icu::UnicodeString someUString( someString, "ISO-8859-1" ); std::cout << someUString.toLower( "de_DE" ) << "\n"; std::cout << someUString.toUpper( "de_DE" ) << "\n"; return 0; }
int main () { std::locale loc; std::string str="Test String.\n"; for(auto elem : str) std::cout << std::tolower(elem,loc); }
int main (int argc, char* argv[]) { std::string sourceString = "Abc"; std::string destinationString; destinationString.resize(sourceString.size()); std::transform(sourceString.begin(), sourceString.end(), destinationString.begin(), ::tolower); std::cout << sourceString << " -> " << destinationString << std::endl; }
./test Elapsed time: 12365milliseconds Elapsed time: 1640milliseconds ./test Elapsed time: 26978milliseconds Elapsed time: 1646milliseconds ./test Elapsed time: 6957milliseconds Elapsed time: 1634milliseconds ./test Elapsed time: 23177milliseconds Elapsed time: 2421milliseconds ./test Elapsed time: 17342milliseconds Elapsed time: 14132milliseconds ./test Elapsed time: 7355milliseconds Elapsed time: 1645milliseconds
./test Elapsed time: 3769milliseconds Elapsed time: 565milliseconds ./test Elapsed time: 3815milliseconds Elapsed time: 565milliseconds ./test Elapsed time: 3643milliseconds Elapsed time: 566milliseconds ./test Elapsed time: 22018milliseconds Elapsed time: 566milliseconds ./test Elapsed time: 3845milliseconds Elapsed time: 569milliseconds
string str; bench.start(); for(long long i=0;i<1000000;i++) { str="DSFZKMdskfdsjfsdfJDASFNSDJFXCKVdnjsafnjsdfjdnjasnJDNASFDJDSFSDNJjdsanjfsdnfjJNFSDJFSD"; boost::algorithm::to_lower(str); } bench.end(); bench.start(); for(long long i=0;i<1000000;i++) { str="DSFZKMdskfdsjfsdfJDASFNSDJFXCKVdnjsafnjsdfjdnjasnJDNASFDJDSFSDNJjdsanjfsdnfjJNFSDJFSD"; for(unsigned short loop=0;loop < str.size();loop++) { str[loop]=tolower(str[loop]); } } bench.end();
string test = "Hello World"; for(auto& c : test) { c = tolower(c); } cout<<test<<endl;
using namespace std; int main(){ string str; getline(cin,str); transform(str.begin(), str.end(), str.begin(), ::tolower); cout<<str; return 0; }
using namespace std; int main(){ string str; cin>>str; transform(str.begin(), str.end(), str.begin(), ::tolower); cout<<str; return 0; }
int main () { std::locale::global(std::locale("en_US.utf8")); std::wcout.imbue(std::locale()); std::wcout << "In US English UTF-8 locale:\n"; auto& f = std::use_facet<std::ctype<wchar_t>>(std::locale()); std::wstring str = L"HELLo, wORLD!"; std::wcout << "Lowercase form of the string f.tolower(&str[0], &str[0] + str.size()); std::wcout << " }
using namespace Poco; std::string hello("Stack Overflow!"); std::string newString(toUpper(hello)); toLowerInPlace(newString);
static char UtoL[256]; void InitUtoLMap() { for (int i = 0; i < sizeof(UtoL); i++) { if (isupper(i)) { UtoL[i] = (char)(i + 32); } else { UtoL[i] = i; } } } char *LowerStr(char *szMyStr) { char *p = szMyStr; while (*p) { *p = UtoL[*p]; p++; } return szMyStr; } int main() { time_t start; char *Lowered, Upper[128]; InitUtoLMap(); strcpy(Upper, "Every GOOD boy does FINE!"); Lowered = LowerStr(Upper); return 0; }
int main () { std::locale loc; std::string str="Test String.\n"; for (std::string::size_type i=0; i<str.length(); ++i) std::cout << std::tolower(str[i],loc); return 0; }
int main( void ) { char string[100] = "The String to End All Strings!"; char * copy1 = _strdup( string ); char * copy2 = _strdup( string ); _strlwr( copy1 ); _strupr( copy2 ); printf( "Mixed: %s\n", string ); printf( "Lower: %s\n", copy1 ); printf( "Upper: %s\n", copy2 ); free( copy1 ); free( copy2 ); }
using namespace std; int main () { ios::sync_with_stdio(false); string str="String Convert\n"; for(int i=0; i<str.size(); i++) { str[i] = tolower(str[i]); } cout<<str<<endl; return 0; }
fplus::to_lower_case(std::string("ABC")) == std::string("abc");
string test = "Hello World"; for(auto& c : test) { c = tolower(c); }
using namespace std; int main() { std::string _input = "lowercasetouppercase"; char upperA = char lowerA = cout << (int)upperA << endl; cout << (int)lowerA << endl; cout << "Input String = " << _input.c_str() << endl; for (int i = 0; i < _input.length(); ++i) { _input[i] -= 32; _input[i] += 32; } cout << "Output String = " << _input.c_str() << endl; return 0; }
string LowerCase(string s) { int dif= for(int i=0;i<s.length();i++) { if((s[i]>= s[i]+=dif; } return s; } string UpperCase(string s) { int dif= for(int i=0;i<s.length();i++) { if((s[i]>= s[i]-=dif; } return s; }
void _lower_case(std::string& s){ for(unsigned short l = s.size();l;s[--l]|=(1<<5)); }
char : 1 byte short : 2 bytes int : 4 bytes long : 4 bytes float : 4 bytes double: 8 bytes
const int min_int = INT_MIN; const int max_int = INT_MAX;
const int min_int = std::numeric_limits<int>::min(); const int max_int = std::numeric_limits<int>::max();
sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)
sizeof(short int) <= sizeof(int) <= sizeof(long int)
int main() { std::cout << std::numeric_limits<int>::max() << std::endl; }
cout << "size of datatype = " << sizeof(datatype) << endl;
int main ( int argc, char * argv[] ) { std::cout<< "size of char: " << sizeof (char) << std::endl; std::cout<< "size of short: " << sizeof (short) << std::endl; std::cout<< "size of int: " << sizeof (int) << std::endl; std::cout<< "size of long: " << sizeof (long) << std::endl; std::cout<< "size of long long: " << sizeof (long long) << std::endl; std::cout<< "size of float: " << sizeof (float) << std::endl; std::cout<< "size of double: " << sizeof (double) << std::endl; std::cout<< "size of pointer: " << sizeof (int *) << std::endl; } size of char: 1 size of short: 2 size of int: 4 size of long: 8 size of long long: 8 size of float: 4 size of double: 8 size of pointer: 8
namespace stdtype { using namespace std; /* * THIS IS THE CLASS USED TO SEMANTICALLY SPECIFY A NULL TYPE. * YOU CAN USE WHATEVER YOU WANT AND EVEN DRIVE A COMPILE ERROR IF IT IS * DECLARED/USED. * * PLEASE NOTE that C++ std define sizeof of an empty class to be 1. */ class null_type{}; /* * Template for creating lists of types * * T is type to hold * S is the next type_list<T,S> type * * Example: * Creating a list with type int and char: * typedef type_list<int, type_list<char> > test; * test::value * test::next::value */ template <typename T, typename S> struct type_list { typedef T value; typedef S next; }; /* * Declaration of template struct for selecting a type from the list */ template <typename list, int b, int ctl> struct select_type; /* * Find a type with specified "b" bit in list "list" * * */ template <typename list, int b> struct find_type { private: typedef typename list::value cur_type; enum {cur_type_bits = numeric_limits<cur_type>::digits}; public: typedef typename select_type<list, b, cur_type_bits>::type type; }; /* * This is the specialization for empty list, return the null_type * OVVERRIDE this struct to ADD CUSTOM BEHAVIOR for the TYPE NOT FOUND case * (ie search for type with 17 bits on common archs) */ template <int b> struct find_type<null_type, b> { typedef null_type type; }; /* * Primary template for selecting the type at the head of the list if * it matches the requested bits (b == ctl) * * If b == ctl the partial specified templated is evaluated so here we have * b != ctl. We call find_type on the next element of the list */ template <typename list, int b, int ctl> struct select_type { typedef typename find_type<typename list::next, b>::type type; }; /* * This partial specified templated is used to select top type of a list * it is called by find_type with the list of value (consumed at each call) * the bits requested (b) and the current type (top type) length in bits * * We specialice the b == ctl case */ template <typename list, int b> struct select_type<list, b, b> { typedef typename list::value type; }; /* * These are the types list, to avoid possible ambiguity (some weird archs) * we kept signed and unsigned separated */ type_list<unsigned short, \ type_list<unsigned int, \ type_list<unsigned long, \ type_list<unsigned long long, null_type> > > > > type_list<signed short, \ type_list<signed int, \ type_list<signed long, \ type_list<signed long long, null_type> > > > > /* * These are acutally typedef used in programs. * * Nomenclature is [u]intN where u if present means unsigned, N is the * number of bits in the integer * * find_type is used simply by giving first a type_list then the number of * bits to search for. * * NB. Each type in the type list must had specified the template * numeric_limits as it is used to compute the type len in (binary) digit. */ typedef find_type<UNSIGNED_TYPES, 8>::type uint8; typedef find_type<UNSIGNED_TYPES, 16>::type uint16; typedef find_type<UNSIGNED_TYPES, 32>::type uint32; typedef find_type<UNSIGNED_TYPES, 64>::type uint64; typedef find_type<SIGNED_TYPES, 7>::type int8; typedef find_type<SIGNED_TYPES, 15>::type int16; typedef find_type<SIGNED_TYPES, 31>::type int32; typedef find_type<SIGNED_TYPES, 63>::type int64; }
const int min_int = INT_MIN; const int max_int = INT_MAX;
const int min_int = std::numeric_limits<int>::min(); const int max_int = std::numeric_limits<int>::max();
M[0][0] (memory) + M[0][1] (cached) + M[1][0] (memory) + M[1][1] (cached) = 1 + 2 + 3 + 4 --> 2 cache hits, 2 memory accesses
M[0][0] (memory) + M[1][0] (memory) + M[0][1] (memory) + M[1][1] (memory) = 1 + 3 + 2 + 4 --> 0 cache hits, 4 memory accesses
for(unsigned int y=0; y<height; ++y) { for(unsigned int x=0; x<width; ++x) { ... image[y][x] ... } }
for(unsigned int x=0; x<width; ++x) { for(unsigned int y=0; y<height; ++y) { ... image[y][x] ... } }
for(i=0;i<N;i++) { for(j=0;j<N;j++) { dest[i][j] = 0; for( k==;k<N;i++) { dest[i][j] += src1[i][k] * src2[k][j]; } } }
int itemsPerCacheLine = CacheLineSize / sizeof(elemType); for(i=0;i<N;i++) { for(j=0;j<N;j += itemsPerCacheLine ) { for(jj=0;jj<itemsPerCacheLine; jj+) { dest[i][j+jj] = 0; } for( k==;k<N;i++) { for(jj=0;jj<itemsPerCacheLine; jj+) { dest[i][j+jj] += src1[i][k] * src2[k][j+jj]; } } } }
struct Product { int32_t key; char name[56]; int32_t price' } Product* table = new Product[N];
int32_t* key = new int32_t[N]; char* name = new char[56*N]; int32_t* price = new int32_t[N];
int sum = 0; for (int i=0; i<N; i++) sum = sum + table[i].price;
int sum = 0; for (int i=0; i<N; i++) sum = sum + price[i];
class A { int foo; }; class B : public A { int bar; };
class A { public: virtual A& operator= (const A& a) { assign(a); return *this; } protected: void assign(const A& a) { } }; class B : public A { public: virtual B& operator= (const A& a) { if (const B* b = dynamic_cast<const B*>(&a)) assign(*b); else throw bad_assignment(); return *this; } protected: void assign(const B& b) { A::assign(b); } };
void wantAnA(A myA) { } B derived; wantAnA(derived);
using namespace std; class A { public: A() {} A(const A& a) { cout << " } virtual void run() const { cout << "I am an }; class B: public A { public: B():A() {} B(const B& a):A(a) { cout << " } virtual void run() const { cout << "I am a }; void g(const A & a) { a.run(); } void h(const A a) { a.run(); } int main() { cout << "Call by reference" << endl; g(B()); cout << endl << "Call by copy" << endl; h(B()); }
class Pet { public: string name; }; class Dog : public Pet { public: string breed; }; int main() { Dog dog; Pet pet; dog.name = "Tommy"; dog.breed = "Kangal Dog"; pet = dog; cout << pet.breed;
Pet *ptrP; Dog *ptrD; ptrD = new Dog; ptrD->name = "Tommy"; ptrD->breed = "Kangal Dog"; ptrP = ptrD; cout << ((Dog *)ptrP)->breed;
class Base { int x, y; }; class Derived : public Base { int z, w; }; int main() { Derived d; Base b = d; }
class baseclass { ... baseclass & operator =(const baseclass&); baseclass(const baseclass&); } void function( ) { baseclass obj1=m; obj1=m; }
class A { int x; }; class B { B( ) : x(1), c( int x; char c; }; int main( ) { A a; B b; a = b; return 0; }
using namespace std; class Base { public: int a; int b; int c; Base() { a=10; b=20; c=30; } }; class Derived : public Base { public: int d; int e; Derived() { d=40; e=50; } }; int main() { Derived d; cout<<d.a<<"\n"; cout<<d.b<<"\n"; cout<<d.c<<"\n"; cout<<d.d<<"\n"; cout<<d.e<<"\n"; Base b = d; cout<<b.a<<"\n"; cout<<b.b<<"\n"; cout<<b.c<<"\n"; cout<<b.d<<"\n"; cout<<b.e<<"\n"; return 0; }
class Base { int x; }; class Derived : public Base { int z; }; int main() { Derived d; Base b = d; }
class foobar { public: operator int () const; const char* foo() const; };
class MyClass { private: int counter; public: void Foo() { std::cout << "Foo" << std::endl; } void Foo() const { std::cout << "Foo const" << std::endl; } }; int main() { MyClass cc; const MyClass& ccc = cc; cc.Foo(); ccc.Foo(); }
void Foo() { counter++; std::cout << "Foo" << std::endl; } void Foo() const { counter++; std::cout << "Foo const" << std::endl; }
class MyClass { private: mutable int counter; public: MyClass() : counter(0) {} void Foo() { counter++; std::cout << "Foo" << std::endl; } void Foo() const { counter++; std::cout << "Foo const" << std::endl; } int GetInvocations() const { return counter; } }; int main(void) { MyClass cc; const MyClass& ccc = cc; cc.Foo(); ccc.Foo(); std::cout << "The MyClass instance has been invoked " << ccc.GetInvocations() << " times" << endl; }
Foo Foo const The MyClass instance has been invoked 2 times
void func1(const foobar& fb1, foobar& fb2) { const char* v1 = fb1.bar(); const char* v2 = fb2.bar(); }
class A { public: A():member_() { } int hashGetter() const { state_ = 1; return member_; } int goodGetter() const { return member_; } int getter() const { return member_; } int badGetter() { return member_; } private: mutable int state_; int member_; };
int main() { const A a1; a1.badGetter(); a1.goodGetter(); a1.hashGetter(); A a2; a2.badGetter(); a2.goodGetter(); a2.hashGetter(); }
class foobar { public: operator int () const; const char* foo() const; };
class foobar { public: operator int (const foobar * const this) const; const char* foo(const foobar * const this) const; };
class MyClass { static int counter; public: void Foo() {std::cout << "Foo " << counter++ << std::endl;} void Foo() const {std::cout << "Foo const " << counter++ << std::endl;} }; int MyClass::counter = 0; int main() { MyClass a; const MyClass& b = a; a.Foo(); b.Foo(); }
class Singleton { public: static Singleton* getInstance( ); ~Singleton( ); private: Singleton( ); static Singleton* instance; };
class S { public: static S& getInstance() { static S instance; return instance; } private: S() {} S(S const&); void operator=(S const&); public: S(S const&) = delete; void operator=(S const&) = delete; };
class Singleton { private: Singleton(); public: static Singleton& instance() { static Singleton INSTANCE; return INSTANCE; } };
class Singleton { public: Singleton(Singleton const&) = delete; Singleton& operator=(Singleton const&) = delete; static std::shared_ptr<Singleton> instance() { static std::shared_ptr<Singleton> s{new Singleton}; return s; } private: Singleton() {} };
template <class X> X& singleton() { static X x; return x; }
class S { public: static S& getInstance() { if( m_s.get() == 0 ) { m_s.reset( new S() ); } return *m_s; } private: static std::unique_ptr<S> m_s; S(); S(S const&); void operator=(S const&); }; std::unique_ptr<S> S::m_s(0);
using namespace std; class SingletonClass { public: static SingletonClass* getInstance() { return (!m_instanceSingleton) ? m_instanceSingleton = new SingletonClass : m_instanceSingleton; } private: SingletonClass() { cout << "SingletonClass instance created!\n"; } ~SingletonClass() {} SingletonClass(const SingletonClass&); SingletonClass& operator=(const SingletonClass&); static SingletonClass *m_instanceSingleton; }; SingletonClass* SingletonClass::m_instanceSingleton = nullptr; int main(int argc, const char * argv[]) { SingletonClass *singleton; singleton = singleton->getInstance(); cout << singleton << endl; SingletonClass *anotherSingleton; anotherSingleton = anotherSingleton->getInstance(); cout << anotherSingleton << endl; Sleep(5000); return 0; }
Singleton * Singleton::getInstance() { if (!instance) { instance = new Singleton(); }; return instance; };
template<typename HeirT> class Singleton { public: Singleton() = delete; Singleton(const Singleton &) = delete; Singleton &operator=(const Singleton &) = delete; static HeirT &instance() { static HeirT instance; return instance; } };
class CCtrl { private: CCtrl(void); virtual ~CCtrl(void); public: INS(CCtrl);
struct Store{ std::array<Something, 1024> data; size_t get(size_t idx){ } void incr_ref(size_t idx){ } void decr_ref(size_t idx){ } }; template<Store* store_p> struct ItemRef{ size_t idx; auto get(){ return store_p->get(idx); }; ItemRef() { store_p->incr_ref(idx); }; ~ItemRef() { store_p->decr_ref(idx); }; }; Store store1_g; Store store2_g;
auto ref1_a = ItemRef<&store1_g>(101); auto ref2_a = ItemRef<&store2_g>(201);
template <typename Store_t, Store_t* store_p> struct StoreWrapper{ };
class SingletonClass { public: static SingletonClass* Instance() { static SingletonClass* instance = new SingletonClass(); return instance; } void Relocate(int X, int Y, int Z); private: SingletonClass(); ~SingletonClass(); };
class singleton { static singleton *s; static unsigned char *buffer[sizeof(singleton)/4 *4] static singleton* getinstance() { if (s == null) { s = new(buffer) singleton; } return s; } };
class SuperClass { public: SuperClass(int foo) { } }; class SubClass : public SuperClass { public: SubClass(int foo, int bar) : SuperClass(foo) { } };
class Sub : public Base { Sub(int x, int y) : Base(x), member(y) { } Type member; };
class Sub : public Base { Sub(int x, int y) try : Base(x), member(y) { } catch(const ExceptionType &e) { throw kaboom(); } Type member; };
class A : public B { public: A(int a, int b, int c); private: int b_, c_; };
class base { public: base (int arg) { } }; class derived : public base { public: derived () : base (number) { } };
using namespace std; class Base { public: Base(int a=1) : _a(a) {} protected: int _a; }; class Derived : public Base { public: Derived() {} void printit() { cout << _a << endl; } }; int main() { Derived d; d.printit(); return 0; }
std::string name = "John"; int age = 21; std::string result; result = name + boost::lexical_cast<std::string>(age); result = name + std::to_string(age); fastformat::fmt(result, "{0}{1}", name, age); fastformat::write(result, name, age); result = fmt::format("{}{}", name, age); std::stringstream sstm; sstm << name << age; result = sstm.str(); char numstr[21]; result = name + itoa(age, numstr, 10); char numstr[21]; sprintf(numstr, "%d", age); result = name + numstr; char numstr[21]; result = name + stlsoft::integer_to_string(numstr, 21, age); result = name + winstl::int_to_string(age); result = name + Poco::NumberFormatter().format(age);
std::stringstream ss; ss << age; std::cout << name << ss.str() << std::endl;
char buffer[128]; snprintf(buffer, sizeof(buffer), "%s%d", name.c_str(), age); std::cout << buffer << std::endl;
std::ostringstream o; o << name << age; std::cout << o.str();
using namespace std; string itos(int i) { stringstream s; s << i; return s.str(); }
std::string name = "John"; int age = 21; name += std::to_string(age); std::cout << name;
using namespace std; string concatenate(std::string const& name, int i) { stringstream s; s << name << i; return s.str(); }
template <class T> inline std::string to_string (const T& t) { std::stringstream ss; ss << t; return ss.str(); }
std::string szName = "John"; int numAge = 23; szName += to_string<int>(numAge); cout << szName << endl;
template <typename L, typename R> std::string operator+(L left, R right) { std::ostringstream os; os << left << right; return os.str(); }
std::string foo("the answer is "); int i = 42; std::string bar(foo + i); std::cout << bar << std::endl;
CString nameAge = ""; nameAge.Format("%s%d", "John", 21);
static_cast<std::ostringstream&>( \ std::ostringstream().flush() << tokens \ ).str() \ /**/
int main() { int i = 123; std::string message = MAKE_STRING("i = " << i); std::cout << message << std::endl; }
QString string = QString("Some string %1 with an int somewhere").arg(someIntVariable); string.append(someOtherIntVariable);
string name = "John"; int age = 5; char temp = 5 + name = name + temp; cout << name << endl; Output: John5
int main() { using boost::format; int age = 22; std::string str_age = str(format("age is %1%") % age); }
int main() { using namespace boost::spirit; int age = 22; std::string str_age("age is "); std::back_insert_iterator<std::string> sink(str_age); karma::generate(sink, int_, age); return 0; }
char intToChar(int num) { if (num < 10 && num >= 0) { return num + 48; } else { return } } string intToString(int num) { int digits = 0, process, single; string numString; process = num; while (process != 0) { single = process % 10; process = (process - single)/10; digits ++; } process = num; for (int i = 0; i < digits; i++) { numString += } for (int i = digits-1; i >= 0; i--) { single = process % 10; numString[i] = intToChar ( single); process = (process - single) / 10; } return numString; }
template <class Facet> struct erasable_facet : Facet { erasable_facet() : Facet(1) { } ~erasable_facet() { } }; void append_int(std::string& s, int n) { erasable_facet<std::num_put<char, std::back_insert_iterator<std::string>>> facet; std::ios str(nullptr); facet.put(std::back_inserter(s), str, str.fill(), static_cast<unsigned long>(n)); } int main() { std::string str = "ID: "; int id = 123; append_int(str, id); std::cout << str; }
std::ostringstream s; s << "John " << age; std::string query(s.str());
std::string query("John " + boost::lexical_cast<std::string>(age));
using namespace std; int main() { string name = "John"; int age = 21; string answer1 = ""; string s1=to_string(age); answer1 = name + s1; cout << answer1 << endl; ostringstream s2; s2 << age; string s3 = s2.str(); string answer2 = ""; answer2 = name + s3; cout << answer2 << endl; return 0; }
using namespace std; int main() { cout << "John" + std::to_string(21) << endl; string name = "John"; int age = 21; cout << name + to_string(age) << endl; }
const string intToString[10] = {"0","1","2","3","4","5","6","7","8","9"};
string str = intToString[3] + " + " + intToString[4] + " = " + intToString[7];
class CMyClass : public CMyBase {...}; class CMyOtherStuff {...} ; CMyBase *pSomething;
CMyClass *pMyObject; pMyObject = static_cast<CMyClass*>(pSomething); pMyObject = (CMyClass*)(pSomething);
CMyOtherStuff *pOther; pOther = static_cast<CMyOtherStuff*>(pSomething); pOther = (CMyOtherStuff*)(pSomething);
pOther = reinterpret_cast<CMyOtherStuff*>(pSomething);
int i; double d = (double)i; double d2 = static_cast<double>( i );
class A {}; class B : public A {}; A* a = new B; B* b = (B*)a; char* c = (char*)new int( 5 ); char* c1 = static_cast<char*>( new int( 5 ) );
double d = 3.14159265; int i = static_cast<int>(d);
class Foo { X *m; void method() { m->someMethod(); int i = m->someField; } };
struct X; void f1(X* px) {} void f2(X& x) {} X f3(int); void f4(X); void f5(X) {}
template <typename T> class Foo { X<T>* ptr; X<T>& ref; };
template <typename T> void f1(X<T>); template <typename T> X<T> f2();
template <typename T> void f3(X<T>*, X<T>&) {} template <typename T> X<T>& f4(X<T>& in) { return in; } template <typename T> X<T>* f5(X<T>* in) { return in; }
void f3(X<int>*, X<int>&) {} X<int>& f4(X<int>& in) { return in; } X<int>* f5(X<int>* in) { return in; }
template <typename T> class Foo : X<T> {} Foo<int> a1; template <typename T> struct X {}; Foo<int> a2;
template <typename T> class Foo { X<T> m; }; Foo<int> a1; template <typename T> struct X {}; Foo<int> a2;
template <typename T> void f1(X<T> x) {} template <typename T> X<T> f2(){return X<T>(); } void test1() { f1(X<int>()); f2<int>(); } template <typename T> struct X {}; void test2() { f1(X<int>()); f2<int>(); }
void f1(X<int> x) {} X<int> f2() {return X<int>(); }
class Foo { X<int>* m; void method() { m->someMethod(); int i = m->someField; } };
class X; X returnsX(); void XAcceptor(X); XAcepptor( returnsX() );
void f6(X*) {} void f7(X&) {} void f8(X* x_ptr, X& x_ref) { f6(x_ptr); f7(x_ref); }
template <template <typename, typename> class Container, typename Type> class MyContainer: public Container<Type, std::allocator<Type>> { };
template<template<class> typename MyTemplate, class Bar> class Foo { }; template<template<class> class MyTemplate, class Bar> class Foo { };
template <class IntegerType> class smart_integer { public: typedef integer_traits<Integer> traits; IntegerType operator+=(IntegerType value){ typedef typename traits::larger_integer_t larger_t; larger_t interm = larger_t(myValue) + larger_t(value); if(interm > traits::max() || interm < traits::min()) throw overflow(); myValue = IntegerType(interm); } }
template <class T> class Demonstration { public: void method() { T::A *aObj; };
std::vector<int> ints; ints.push_back(10); ints.push_back(20); ints.push_back(30);
static const int arr[] = {16,2,77,29}; vector<int> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
... std::vector<int> v = boost::assign::list_of(1)(2)(3)(4);
using namespace boost::assign; ... std::vector<int> v; v += 1, 2, 3, 4;
int tmp[] = { 10, 20, 30 }; std::vector<int> v( tmp, tmp+3 );
template <typename T, std::size_t N> inline std::size_t size_of_array( T (&)[N] ) { return N; } template <typename T, std::size_t N> char (&sizeof_array( T(&)[N] ))[N];
using std::vector; ... vector<int> vec1 { 10, 20, 30 }; vector<int> vec2 = { 10, 20, 30 };
using std::vector; ... vector<int> vec = boost::assign::list_of(10)(20)(30);
using std::vector; ... vector<int> vec; vec += 10, 20, 30;
using std::vector; ... static const int arr[] = {10,20,30}; vector<int> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
using std::vector; ... static const int arr[] = {10,20,30}; vector<int> vec (arr, ARRAY_END(arr));
using std::vector; ... static const int arr[] = {10,20,30}; vector<int> vec INIT_FROM_ARRAY(arr);
template< typename T, size_t N > std::vector<T> makeVector( const T (&data)[N] ) { return std::vector<T>(data, data+N); }
const double values[] = { 2.0, 1.0, 42.0, -7 }; std::vector<double> array = makeVector(values);
vector<int> v(arr, arr + sizeof(arr)/sizeof(arr[0])); vector<int>v;
const int a[] = {10, 20, 30}; const std::vector<int> ints(a,a+sizeof(a)/sizeof(int));
const std::vector<int> ints = boost::assign::list_of(10)(20)(30);
int array[] = {10,20,30} for(int i=0; i<sizeof(array); i++) v.push_back(array[i]);
template <class T> class vector_inserter{ public: std::vector<T>& v; vector_inserter(std::vector<T>& v):v(v){} vector_inserter& operator,(const T& val){v.push_back(val);return *this;} }; template <class T> vector_inserter<T> operator+=(std::vector<T>& v,const T& x){ return vector_inserter<T>(v),x; }
static const int a[] = {10, 20, 30}; vector<int> vec (begin(a), end(a));
template <typename T> std::vector<T> initVector (int len, ...) { std::vector<T> v; va_list vl; va_start(vl, len); for (int i = 0; i < len; ++i) v.push_back(va_arg(vl, T)); va_end(vl); return v; } int main () { std::vector<int> v = initVector<int> (7,702,422,631,834,892,104,772); for (std::vector<int>::const_iterator it = v.begin() ; it != v.end(); ++it) std::cout << *it << std::endl; return 0; }
// template <typename T> class mkvec { public: typedef mkvec<T> my_type; my_type& operator<< (const T& val) { data_.push_back(val); return *this; } my_type& operator<< (const std::vector<T>& inVector) { this->data_.reserve(this->data_.size() + inVector.size()); this->data_.insert(this->data_.end(), inVector.begin(), inVector.end()); return *this; } operator std::vector<T>() const { return data_; } private: std::vector<T> data_; }; std::vector<int32_t> vec1; std::vector<int32_t> vec2; vec1 = mkvec<int32_t>() << 5 << 8 << 19 << 79; vec2 = mkvec<int32_t>() << 1 << 2 << 3 << vec1 << 10 << 11 << 12;
template<class T> class make_vector { std::vector<T> data; public: make_vector(T const &val) { data.push_back(val); } make_vector<T> &operator,(T const &t) { data.push_back(t); return *this; } operator std::vector<T>() { return data; } }; template<class T> make_vector<T> makeVect(T const &t) { return make_vector<T>(t); }
class MyObject; struct MyObjectList { std::list<MyObject> objects; MyObjectList& operator<<( const MyObject o ) { objects.push_back( o ); return *this; } };
someFunc( MyObjectList() << MyObject(1) << MyObject(2) << MyObject(3) );
int A[] = {10, 20, 30}; unsigned sizeOfA = sizeof(A)/sizeof(A[0]); std::vector<int> vArrayA(sizeOfA); for(unsigned i=0; i<sizeOfA; i++) vArrayA[i] = A[i]; int B[] = {40, 50, 60, 70}; std::vector<int> vArrayB; for (unsigned i=0; i<sizeof(B)/sizeof(B[0]); i++) vArrayB.push_back(B[i]); int C[] = {1, 2, 3, 4}; std::vector<int> vArrayC; vArrayC.resize(sizeof(C)/sizeof(C[0])); for (unsigned i=0; i<sizeof(C)/sizeof(C[0]); i++) vArrayC.at(i) = C[i];
int arr[] = {1, 2, 3}; int len = (sizeof(arr)/sizeof(arr[0])); vector < int > v; std:: v.assign(arr, arr+len);
([](){ \ static const decltype(first) arr[] = { first,__VA_ARGS__ }; \ std::vector<decltype(first)> ret(arr, arr + sizeof(arr) / sizeof(*arr)); \ return ret;})()
template<typename T> void test(std::vector<T>& values) { for(T value : values) std::cout<<value<<std::endl; }
Initializing: std::vector<int> ivec = {10, 20}; Assigning ivec.push_back(30);
template<typename T> class chain { private: std::vector<T> _v; public: chain& pb(T a) { _v.push_back(a); return *this; }; std::vector<T> get() { return _v; }; }; using namespace std; int main(int argc, char const *argv[]) { chain<int> v{}; v.pb(1).pb(2).pb(3); for (auto& i : v.get()) { cout << i << endl; } return 0; }
std::find(vector.begin(), vector.end(), item) != vector.end()
if ( std::find(vector.begin(), vector.end(), item) != vector.end() ) do_this(); else do_that();
using namespace std; int main() { typedef vector<int> IntContainer; typedef IntContainer::iterator IntIterator; IntContainer vw; IntIterator i = find(vw.begin(), vw.end(), 5); if (i != vw.end()) { } else { } return 0; }
if(std::find(vector.begin(), vector.end(), item)!=vector.end()){ }
if(binary_search(vector.begin(), vector.end(), item)){ }
template <typename T> const bool Contains( std::vector<T>& Vec, const T& Element ) { if (std::find(Vec.begin(), Vec.end(), Element) != Vec.end()) return true; return false; } if (Contains(vector,item)) blah else blah
if (any_of(v.begin(), v.end(), bind2nd(equal_to<string>(), item))) do_this(); else do_that();
template <class Container> const bool contains(const Container& container, const typename Container::value_type& element) { return std::find(container.begin(), container.end(), element) != container.end(); }
bool item_present = boost::algorithm::any_of_equal(vector, element);
struct Item { }; typedef std::vector<Item> ItemVector; typedef ItemVector::iterator ItemIterator; ItemVector vtItem; Item itemToFind; ItemIterator itemItr; itemItr = std::find(vtItem.begin(), vtItem.end(), itemToFind); if (itemItr != vtItem.end()) { } else { }
std::find(vector.begin(), vector.end(), item) != vector.end()
struct isEqual { isEqual(const std::string& s): m_s(s) {} bool operator()(OIDV* l) { return l->oid == m_s; } std::string m_s; }; struct OIDV { string oid; }; VecOidv::iterator itFind=find_if(vecOidv.begin(),vecOidv.end(),isEqual(szTmp));
template<typename T> inline static bool operator ==(const std::vector<T>& v, const T& elem) { return (std::find(v.begin(), v.end(), elem) != v.end()); } template<typename T> inline static bool operator !=(const std::vector<T>& v, const T& elem) { return (std::find(v.begin(), v.end(), elem) == v.end()); } enum CODEC_ID { CODEC_ID_AAC, CODEC_ID_AC3, CODEC_ID_H262, CODEC_ID_H263, CODEC_ID_H264, CODEC_ID_H265, CODEC_ID_MAX }; void main() { CODEC_ID codec = CODEC_ID_H264; std::vector<CODEC_ID> codec_list; codec_list.reserve(CODEC_ID_MAX); codec_list.push_back(CODEC_ID_AAC); codec_list.push_back(CODEC_ID_AC3); codec_list.push_back(CODEC_ID_H262); codec_list.push_back(CODEC_ID_H263); codec_list.push_back(CODEC_ID_H264); codec_list.push_back(CODEC_ID_H265); if (codec_list != codec) { throw std::runtime_error("codec not found!"); } if (codec_list == codec) { throw std::logic_error("codec has been found!"); } }
template <typename T> bool IsInVector(T what, std::vector<T> * vec) { if(std::find(vec->begin(),vec->end(),what)!=vec->end()) return true; return false; }
bool exists_linear( INPUT_ITERATOR first, INPUT_ITERATOR last, const T& value ) bool exists_binary( INPUT_ITERATOR first, INPUT_ITERATOR last, const T& value )
include <newton/algorithm/algorithm.hpp> if ( newton::exists_linear(first, last, value) ) do_this(); else do_that();
std::string do_something ( std::string inval ) { std::string return_val; return return_val; }
void B(const std::string &str) { C(str); } void C(const std::string &str) { }
bool foo1( const std::string v ) { return v.empty(); } bool foo2( const std::string & v ) { return v.empty(); }
std::string function(const std::string& aString){ auto vString(aString); vString.clear(); return vString; }
std::string function(std::string aString){ aString.clear(); return aString; }
bool isprint(std::string const &s) { return all_of(begin(s),end(s),(bool(*)(char))isprint); }
struct string { string() {} string(const string&) {std::cout << "string(const string&)\n";} string& operator=(const string&) {std::cout << "string& operator=(const string&)\n";return *this;} string(string&&) {std::cout << "string(string&&)\n";} string& operator=(string&&) {std::cout << "string& operator=(string&&)\n";return *this;} }; string do_something(string inval) { return inval; } string do_something(const string& inval) { string return_val = inval; return return_val; } string do_something(string&& inval) { return std::move(inval); } string source() {return string();} int main() { std::cout << "do_something with lvalue:\n\n"; string x; string t = do_something(x); std::cout << "\ndo_something with xvalue:\n\n"; string u = do_something(std::move(x)); std::cout << "\ndo_something with prvalue:\n\n"; string v = do_something(source()); }
$ clang++ -std=c++11 -stdlib=libc++ -DPROCESS=1 test.cpp $ a.out do_something with lvalue: string(const string&) string(string&&) do_something with xvalue: string(string&&) string(string&&) do_something with prvalue: string(string&&) $ clang++ -std=c++11 -stdlib=libc++ -DPROCESS=2 test.cpp $ a.out do_something with lvalue: string(const string&) do_something with xvalue: string(string&&) do_something with prvalue: string(string&&)
+----+--------+--------+---------+ | | lvalue | xvalue | prvalue | +----+--------+--------+---------+ | p1 | 1/1 | 0/2 | 0/1 | +----+--------+--------+---------+ | p2 | 1/0 | 0/1 | 0/1 | +----+--------+--------+---------+
class WidgetBadRef { public: WidgetBadRef(const std::string& s) : myStrRef(s) {} const std::string& myStrRef; }; class WidgetSafeCopy { public: WidgetSafeCopy(const std::string& s) : myStrCopy(s) {std::cout << "const std::string& constructor\n";} WidgetSafeCopy(const char* cs) : myStrCopy(cs) {std::cout << "const char * constructor\n";} const std::string myStrCopy; }; int main() { WidgetBadRef w1("First string"); WidgetSafeCopy w2("Second string"); WidgetSafeCopy w3(w2.myStrCopy); std::cout << w1.myStrRef << "\n"; std::cout << w2.myStrCopy << "\n"; std::cout << w3.myStrCopy << "\n"; }
const char * constructor const std::string& constructor Second string Second string
std::ifstream t; int length; t.open("file.txt"); t.seekg(0, std::ios::end); length = t.tellg(); t.seekg(0, std::ios::beg); buffer = new char[length]; t.read(buffer, length); t.close();
std::ifstream t; t.open("file.txt"); std::string buffer; std::string line; while(t){ std::getline(t, line); } t.close()
std::ifstream t("file.txt"); std::string str((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());
std::ifstream t("file.txt"); std::string str; t.seekg(0, std::ios::end); str.reserve(t.tellg()); t.seekg(0, std::ios::beg); str.assign((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());
std::ifstream t("file.txt"); std::stringstream buffer; buffer << t.rdbuf();
std::ifstream t("file.txt"); t.seekg(0, std::ios::end); size_t size = t.tellg(); std::string buffer(size, t.seekg(0); t.read(&buffer[0], size);
ifstream inFile; inFile.open(inFileName); stringstream strStream; strStream << inFile.rdbuf(); string str = strStream.str(); cout << str << endl;
ifstream ifs ("filename.txt"); string s; getline (ifs, s, (char) ifs.eof());
string get_file_string(){ std::ifstream ifs("path_to_file"); return string((std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>())); } string get_file_string2(){ ifstream inFile; inFile.open("path_to_file"); stringstream strStream; strStream << inFile.rdbuf(); return strStream.str(); }
std::string readFile() { stringstream str; ifstream stream("Hello_World.txt"); if(stream.is_open()) { while(stream.peek() != EOF) { str << (char) stream.get(); } stream.close(); return str.str(); } }
void readfile(const std::string &filepath,std::string &buffer){ std::ifstream fin(filepath.c_str()); getline(fin, buffer, char(-1)); fin.close(); }
int main() { auto filename = "my-file.txt"; try { std::string contents = Glib::file_get_contents(filename); std::cout << "File data:\n" << contents << std::endl; catch (const Glib::FileError& e) { std::cout << "Oops, an error occurred:\n" << e.what() << std::endl; } return 0; }
while(!inStream.eof()){ int data; inStream >> data; }
while( !(in>>std::ws).eof() ) { int data; in >> data; if ( in.fail() ) ; }
int data; while(in >> data) { } while( !(in >> data).fail() ) { }
while( !in.eof() ) { int data; in >> data; if ( in.fail() ) ; }
while( !in.eof() ) { int data; in >> data >> ws; if ( in.fail() ) ; }
while( !(in>>ws).eof() ) { int data; in >> data; if ( in.fail() ) ; }
1 while (!read.fail()) { 2 cout << ch; 3 read.get(ch); 4 }
template <class T> class ptr { T* p_; public: ptr(T* p) : p_(p) {} template <class U> ptr(U* u) : p_(dynamic_cast<T*>(u)) { } ptr(int null) : p_(NULL) { assert(null == NULL); } };
void func(int n); void func(char *s); func( NULL );
struct B {}; struct A { operator B*() {return 0;} operator bool() {return true;} }; int main() { A a; B* pb = 0; typedef void* null_ptr_t; null_ptr_t null = 0; std::cout << "(a == pb): " << (a == pb) << std::endl; std::cout << "(a == 0): " << (a == 0) << std::endl; std::cout << "(a == NULL): " << (a == NULL) << std::endl; std::cout << "(a == null): " << (a == null) << std::endl; }
(a == pb): 1 (a == 0): 0 (a == NULL): 0 (a == null): 1
>>> None = 5 File "<stdin>", line 1 SyntaxError: assignment to None >>> type(None) <type
void f(int); void f(char*); void g() { f(0); f(NULL); }
std::string line; while (std::getline(infile, line)) { std::istringstream iss(line); int a, b; if (!(iss >> a >> b)) { break; } }
for( std::string line; getline( input, line ); ) { ...for each line in input... }
std::ifstream file(FILENAME); if (file.is_open()) { std::string line; while (getline(file, line)) { printf("%s", line.c_str()); } file.close(); }
namespace io = boost::iostreams; void readLineByLineBoost() { int fdr = open(FILENAME, O_RDONLY); if (fdr >= 0) { io::file_descriptor_source fdDevice(fdr, io::file_descriptor_flags::close_handle); io::stream <io::file_descriptor_source> in(fdDevice); if (fdDevice.is_open()) { std::string line; while (std::getline(in, line)) { printf("%s", line.c_str()); } fdDevice.close(); } } }
FILE* fp = fopen(FILENAME, "r"); if (fp == NULL) exit(EXIT_FAILURE); char* line = NULL; size_t len = 0; while ((getline(&line, &len, fp)) != -1) { printf("%s", line); } fclose(fp); if (line) free(line);
10K lines 100K lines 1000K lines Loop with std::getline() 105ms 894ms 9773ms Boost code 106ms 968ms 9561ms C code 23ms 243ms 2397ms
std::istream& operator>>(std::istream& is, CoordinatePair& coordinates) { is >> coordinates.x >> coordinates.y; return is; }
int main() { char filename[] = "coordinates.txt"; std::vector<CoordinatePair> v; std::ifstream ifs(filename); if (ifs) { std::copy(std::istream_iterator<CoordinatePair>(ifs), std::istream_iterator<CoordinatePair>(), std::back_inserter(v)); } else { std::cerr << "Couldn } }
std::ifstream infile("thefile.txt"); if (infile.is_open()) { int number; std::string str; char c; while (infile >> number >> c >> str && c == std::cout << number << " " << str << "\n"; } infile.close();
ifstream infile(szFilePath); for (string line = ""; getline(infile, line); ) { } if(infile.is_open()) infile.close();
using namespace std; int main (int argc, char *argv[]) { vector<string> list; ifstream in_stream; string line; in_stream.open(argv[1]); while(!in_stream.eof()) { in_stream >> line; list.push_back(line); } in_stream.close(); print(list); sort(list.begin(), list.end()); print(list); }
unsigned int microseconds; ... usleep(microseconds);
std::this_thread::sleep_for(std::chrono::milliseconds(x));
int main() { boost::this_thread::sleep( boost::posix_time::seconds(1) ); boost::this_thread::sleep( boost::posix_time::milliseconds(1000) ); return 0; }
using namespace std; void sleepcp(int milliseconds); void sleepcp(int milliseconds) { clock_t time_end; time_end = clock() + milliseconds * CLOCKS_PER_SEC/1000; while (clock() < time_end) { } } int main() { cout << "Hi! At the count to 3, I sleepcp(3000); cout << "urrrrggghhhh!" << endl; }
using namespace std; void sleepcp(int milliseconds); void sleepcp(int milliseconds) { Sleep(milliseconds); usleep(milliseconds * 1000); } int main() { cout << "Hi! At the count to 3, I sleepcp(3000); cout << "urrrrggghhhh!" << endl; }
using namespace std; int main() { int x = 6000; Sleep(x); cout << "6 seconds have passed" << endl; return 0; }
Second = 1000 milliseconds Minute = 60000 milliseconds Hour = 3600000 milliseconds
void sleep(unsigned long msec) { timeval delay = {msec / 1000, msec % 1000 * 1000}; int rc = ::select(0, NULL, NULL, NULL, &delay); if(-1 == rc) { } }
boost::thread::sleep(boost::get_system_time() + boost::posix_time::millisec(1000));
void Sleep(unsigned int milliseconds) { usleep(milliseconds * 1000); } while (1) { printf("."); Sleep((unsigned int)(1000.0f/20.0f)); }
class left { public: void foo(); }; class right { public: void foo(); }; class bottom : public left, public right { public: void foo() { left::foo(); right::foo(); bottom b; b.left::foo(); b.right::foo(); } };
class Parent { public: void print(int x); } class Child : public Parent { void print(int x) override; } void Parent::print(int x) { } void Child::print(int x) { Parent::print(x); }
void Base::FooBar() { printf("in Base\n"); } void ChildOfBase::FooBar() { Base::FooBar(); }
struct B1 { void mf(int) {} }; struct B2 { void mf(short) {} void mf(char) {} }; struct D : B1, B2 { void mf(short) { __super::mf(1); __super::mf( } };
using namespace std; class Parent { protected: virtual void fun(int i) { cout<<"Parent::fun functionality write here"<<endl; } void fun1(int i) { cout<<"Parent::fun1 functionality write here"<<endl; } void fun2() { cout<<"Parent::fun3 functionality write here"<<endl; } }; class Child:public Parent { public: virtual void fun(int i) { cout<<"Child::fun partial functionality write here"<<endl; Parent::fun(++i); Parent::fun2(); } void fun1(int i) { cout<<"Child::fun1 partial functionality write here"<<endl; Parent::fun1(++i); } }; int main() { Child d1; d1.fun(1); d1.fun1(2); return 0; }
$ g++ base_function_call_from_derived.cpp $ ./a.out Child::fun partial functionality write here Parent::fun functionality write here Parent::fun3 functionality write here Child::fun1 partial functionality write here Parent::fun1 functionality write here
struct a{ int x; struct son{ a* _parent; void test(){ _parent->x=1; } }_son; }_a; int main(){ _a._son._parent=&_a; _a._son.test(); }
class NotAggregate1 { virtual void f() {} }; class NotAggregate2 { int x; }; class NotAggregate3 { public: NotAggregate3(int) {} }; class Aggregate1 { public: NotAggregate1 member1; Aggregate1& operator=(Aggregate1 const & rhs) { } private: void f() {} };
class A { public: A(int) {} }; class B { public: B() {} }; int main() { A a1[3] = {A(2), A(1), A(14)}; A a2[3] = {A(2)}; B b1[3] = {B()}; int Array1[1000] = {0}; int Array2[1000] = {1}; bool Array3[1000] = {}; int Array4[1000]; int array[2] = {1, 2, 3, 4}; }
struct X { int i1; int i2; }; struct Y { char c; X x; int i[2]; float f; protected: static double d; private: void g(){} }; Y y = {
struct POD { int x; char y; void f() {} static std::vector<char> v; }; struct AggregateButNotPOD1 { int x; ~AggregateButNotPOD1() {} }; struct AggregateButNotPOD2 { AggregateButNotPOD1 arrOfNonPod[3]; };
char buf[N]; T obj; memcpy(buf, &obj, N); memcpy(&obj, buf, N);
int f() { struct NonPOD {NonPOD() {}}; goto label; NonPOD x; label: return 0; } int g() { struct POD {int i; char c;}; goto label; POD x; label: return 0; }
struct NotAggregate { int x = 5; std::vector<int> s{1,2,3}; };
struct Trivial1 {}; struct Trivial2 { int x; }; struct Trivial3 : Trivial2 { Trivial3() = default; int y; }; struct Trivial4 { public: int a; private: int b; }; struct Trivial5 { Trivial1 a; Trivial2 b; Trivial3 c; Trivial4 d; }; struct Trivial6 { Trivial2 a[23]; }; struct Trivial7 { Trivial6 c; void f(); }; struct Trivial8 { int x; static NonTrivial1 y; }; struct Trivial9 { Trivial9() = default; Trivial9(int x) : x(x) {}; int x; }; struct NonTrivial1 : Trivial3 { virtual void f(); }; struct NonTrivial2 { NonTrivial2() : z(42) {} int z; }; struct NonTrivial3 { NonTrivial3(); int w; }; NonTrivial3::NonTrivial3() = default; struct NonTrivial5 { virtual ~NonTrivial5(); };
struct StandardLayout1 {}; struct StandardLayout2 { int x; }; struct StandardLayout3 { private: int x; int y; }; struct StandardLayout4 : StandardLayout1 { int x; int y; void f(); }; struct StandardLayout5 : StandardLayout1 { int x; StandardLayout1 y; }; struct StandardLayout6 : StandardLayout1, StandardLayout5 { }; struct StandardLayout7 { int x; int y; StandardLayout7(int x, int y) : x(x), y(y) {} }; struct StandardLayout8 { public: StandardLayout8(int x) : x(x) {} private: int x; }; struct StandardLayout9 { int x; static NonStandardLayout1 y; }; struct NonStandardLayout1 { virtual f(); }; struct NonStandardLayout2 { NonStandardLayout1 X; }; struct NonStandardLayout3 : StandardLayout1 { StandardLayout1 x; }; struct NonStandardLayout4 : StandardLayout3 { int z; }; struct NonStandardLayout5 : NonStandardLayout3 {};
template <typename T> struct std::is_pod; template <typename T> struct std::is_trivial; template <typename T> struct std::is_trivially_copyable; template <typename T> struct std::is_standard_layout;
struct Base {}; struct Derived : Base { Base b; }; Derived d; static_cast<Base*>(&d) == &d.b;
struct B1 { int i1; B1(int a) : i1(a) { } }; struct B2 { int i2; B2() = default; }; struct M { int m; M(int a) : m(a) { } }; struct C : B1, B2 { int j; M m; C() = default; }; C c { { 1 }, { 2 }, 3, { 4 } }; cout << "is C aggregate?: " << (std::is_aggregate::value ? << " i1: " << c.i1 << " i2: " << c.i2 << " j: " << c.j << " m.m: " << c.m.m << endl;
struct D { int i = 0; D() = default; explicit D(D const&) = default; };
struct B1 { int i1; B1() : i1(0) { } }; struct C : B1 { using B1::B1; };
struct B { int i; }; struct C : B { }; struct D : C { }; struct E : D { char : 4; }; struct Q {}; struct S : Q { }; struct T : Q { }; struct U : S, T { };
struct X { int a, b; }; std::vector<X> xs; xs.emplace_back(1, 2);
template <typename T> struct Point { T x, y; }; Point p{1, 2};
class BigClass; class SmallClass { BigClass* m_bigClass; }
class Foo { private: mutable bool done_; public: void doSomething() const { ...; done_ = true; } };
int x = 0; auto f1 = [=]() mutable {x = 42;}; auto f2 = [=]() {x = 42;};
class CIniWrapper { public: CIniWrapper(LPCTSTR szIniFile); void SetValue(LPCTSTR szName, LPCTSTR szValue); LPCTSTR GetValue(LPCTSTR szName, LPCTSTR szDefaultValue) const; private: mutable std::map<string, string> m_mapNameToValue; };
class Logical { mutable int var; public: Logical(): var(0) {} void set(int x) const { var = x; } }; class Bitwise { int var; public: Bitwise(): var(0) {} void set(int x) const { const_cast<Bitwise*>(this)->var = x; } }; const Logical logical; const Bitwise bitwise; int main(void) { logical.set(5); bitwise.set(5); }
class Test { public: Test(): x(1), y(1) {}; mutable int x; int y; }; int main() { const Test object; object.x = 123; /* * The above line if uncommented, will create compilation error. */ cout<< "X:"<< object.x << ", Y:" << object.y; return 0; } Output:- X:123, Y:1
template <class T> swap(T& a, T& b) { T tmp(a); a = b; b = tmp; }
template <class T> swap(T& a, T& b) { T tmp(std::move(a)); a = std::move(b); b = std::move(tmp); }
template <class T> typename remove_reference<T>::type&& std::move(T&& a) { return a; }
foo(3 * 5); int a = 3 * 5; foo(a); foo(std::move(a));
Object Object::operator+ (const Object& rhs) { Object temp (*this); return temp; }
Object& Object::operator+ (Object&& rhs) { return rhs; }
class ResHeavy{ public: ResHeavy(int len=10):_upInt(new int[len]),_len(len){ cout<<"default ctor"<<endl; } ResHeavy(const ResHeavy& rhs):_upInt(new int[rhs._len]),_len(rhs._len){ cout<<"copy ctor"<<endl; } ResHeavy& operator=(const ResHeavy& rhs){ _upInt.reset(new int[rhs._len]); _len = rhs._len; cout<<"operator= ctor"<<endl; } ResHeavy(ResHeavy&& rhs){ _upInt = std::move(rhs._upInt); _len = rhs._len; rhs._len = 0; cout<<"move ctor"<<endl; } bool is_up_valid(){ return _upInt != nullptr; } private: std::unique_ptr<int[]> _upInt; int _len; };
void test_std_move2(){ ResHeavy rh; ResHeavy rh2 = std::move(rh); if(rh.is_up_valid()) cout<<"rh valid"<<endl; else cout<<"rh invalid"<<endl; if(rh2.is_up_valid()) cout<<"rh2 valid"<<endl; else cout<<"rh2 invalid"<<endl; ResHeavy rh3(rh2); if(rh3.is_up_valid()) cout<<"rh3 valid"<<endl; else cout<<"rh3 invalid"<<endl; }
default ctor move ctor rh invalid rh2 valid copy ctor rh3 valid
c:\dev>cl /nologo helloworld.png cl : Command line warning D9024 : unrecognized source file type helloworld.png : fatal error LNK1107: invalid or corrupt file: cannot read at 0x5172
c:\dev>g++ helloworld.png helloworld.png: file not recognized: File format not recognized collect2: ld returned 1 exit status
c:\dev>clang++ helloworld.png helloworld.png: file not recognized: File format not recognized collect2: ld returned 1 exit status clang++: error: linker (via gcc) command failed with exit code 1 (use -v to see invocation)
from pytesser import * image = Image.open( print image_to_string(image)
python script.py > helloworld.cpp; g++ helloworld.cpp
N lml_�e <loJ+_e__} .lnt Mk.,n ( ln+ _rSC Lhc_yh ) h_S_ _l s_l . co__ <, " H llo uo/_d ! TP__rn _ | _|
` ` . `. ` ... +:: ..-.. --.:`:. `-` .....:`../--`.. `- ` ` ```` ` ` `` .` `` .` `. `` . -``- .. .`--`:` :::.-``-. : ``.-`- `-.-`:.-` :-`/.-..` ` `-..`...- : .` ` ` ` .` ````:`` - ` ``-.` ` `- .. `` . ` .`. ` ` `. ` . . ` . ` . . .` .` ` ` `` ` ` `:`.`:` ` -..-`.`- .-`-. /.-/.-`.-. -...-..`- :``` `-`-` :`..`-` ` :`.`:`- ` `` ` ```. `` ```` ` ` ` ` ` ` ` . : -...`.- .` .:/ ` - ` `` . -` `
a) std::cout << "Hello\n"; b) std::cout << "Hello" << std::endl;
int main(int argc, char** argv) { QApplication qapp(argc,argv); QMainWindow mw; mw.show(); std::cout << "Finished Execution !" << endl << "..."; return qapp.exec(); }
namespace { class empty { }; } int main() { std::clock_t start = std::clock(); for (int i = 0; i < 100000; ++i) empty e; std::clock_t duration = std::clock() - start; std::cout << "stack allocation took " << duration << " clock ticks\n"; start = std::clock(); for (int i = 0; i < 100000; ++i) { empty* e = new empty; delete e; }; duration = std::clock() - start; std::cout << "heap allocation took " << duration << " clock ticks\n"; }
namespace { void on_stack() { int i; } void on_heap() { int* i = new int; delete i; } } int main() { auto begin = std::chrono::system_clock::now(); for (int i = 0; i < 1000000000; ++i) on_stack(); auto end = std::chrono::system_clock::now(); std::printf("on_stack took %f seconds\n", std::chrono::duration<double>(end - begin).count()); begin = std::chrono::system_clock::now(); for (int i = 0; i < 1000000000; ++i) on_heap(); end = std::chrono::system_clock::now(); std::printf("on_heap took %f seconds\n", std::chrono::duration<double>(end - begin).count()); return 0; }
on_stack took 2.070003 seconds on_heap took 57.980081 seconds
on_stack took 0.000000 seconds on_heap took 51.608723 seconds
on_stack took 0.000003 seconds on_heap took 0.000002 seconds
class Foo { public: Foo(int a) { } } int func() { int a1, a2; std::cin >> a1; std::cin >> a2; Foo f1(a1); __asm push a1; __asm lea ecx, [this]; __asm call Foo::Foo(int); Foo* f2 = new Foo(a2); __asm push sizeof(Foo); __asm call operator new; __asm push a2; __asm call Foo::Foo(int); delete f2; }
Proc P { pointer x; Proc S { pointer y; y = allocate_some_data(); x = y; } }
__Z1fi: Leh_func_begin1: pushq %rbp Ltmp0: movq %rsp, %rbp Ltmp1: subq $**3880**, %rsp <--- here we have the array allocated, even the if doesn Ltmp2: movl %edi, -4(%rbp) movl -8(%rbp), %eax addq $3880, %rsp popq %rbp ret Leh_func_end1:
std::vector<int> v(10); std::vector<int>::iterator it = v.begin() + 5; std::insert_iterator<std::vector<int> > it_ins(v, it); for (unsigned n = 20; n > 0; --n) *it_ins++ = rand();
bool CompareDoubles1 (double A, double B) { return A == B; }
bool CompareDoubles2 (double A, double B) { diff = A - B; return (diff < EPSILON) && (-diff < EPSILON); }
bool AreSame(double a, double b) { return fabs(a - b) < EPSILON; }
double left = double right = const FloatingPoint<double> lhs(left), rhs(right); if (lhs.AlmostEquals(rhs)) { }
// // // // // // // // // // template <size_t size> class TypeWithSize { public: typedef void UInt; }; template <> class TypeWithSize<4> { public: // typedef int Int; typedef unsigned int UInt; }; template <> class TypeWithSize<8> { public: typedef __int64 Int; typedef unsigned __int64 UInt; typedef long long Int; typedef unsigned long long UInt; }; // // // // // // // // // // template <typename RawType> class FloatingPoint { public: typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits; static const size_t kBitCount = 8*sizeof(RawType); static const size_t kFractionBitCount = std::numeric_limits<RawType>::digits - 1; static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount; static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1); static const Bits kFractionBitMask = ~static_cast<Bits>(0) >> (kExponentBitCount + 1); static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask); // // static const size_t kMaxUlps = 4; // explicit FloatingPoint(const RawType& x) { u_.value_ = x; } // static RawType ReinterpretBits(const Bits bits) { FloatingPoint fp(0); fp.u_.bits_ = bits; return fp.u_.value_; } static RawType Infinity() { return ReinterpretBits(kExponentBitMask); } const Bits &bits() const { return u_.bits_; } Bits exponent_bits() const { return kExponentBitMask & u_.bits_; } Bits fraction_bits() const { return kFractionBitMask & u_.bits_; } Bits sign_bit() const { return kSignBitMask & u_.bits_; } bool is_nan() const { return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0); } // bool AlmostEquals(const FloatingPoint& rhs) const { if (is_nan() || rhs.is_nan()) return false; return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_) <= kMaxUlps; } private: union FloatingPointUnion { RawType value_; Bits bits_; }; // // // static Bits SignAndMagnitudeToBiased(const Bits &sam) { if (kSignBitMask & sam) { return ~sam + 1; } else { return kSignBitMask | sam; } } static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1, const Bits &sam2) { const Bits biased1 = SignAndMagnitudeToBiased(sam1); const Bits biased2 = SignAndMagnitudeToBiased(sam2); return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1); } FloatingPointUnion u_; };
bool approximatelyEqual(float a, float b, float epsilon) { return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon); } bool essentiallyEqual(float a, float b, float epsilon) { return fabs(a - b) <= ( (fabs(a) > fabs(b) ? fabs(b) : fabs(a)) * epsilon); } bool definitelyGreaterThan(float a, float b, float epsilon) { return (a - b) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon); } bool definitelyLessThan(float a, float b, float epsilon) { return (b - a) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon); }
bool AlmostEqual2sComplement(float A, float B, int maxUlps) { assert(maxUlps > 0 && maxUlps < 4 * 1024 * 1024); int aInt = *(int*)&A; if (aInt < 0) aInt = 0x80000000 - aInt; int bInt = *(int*)&B; if (bInt < 0) bInt = 0x80000000 - bInt; int intDiff = abs(aInt - bInt); if (intDiff <= maxUlps) return true; return false; }
bool AreSame(double a, double b) { return std::fabs(a - b) < std::numeric_limits<double>::epsilon(); }
bool absoluteToleranceCompare(double x, double y) { return std::fabs(x - y) <= std::numeric_limits<double>::epsilon() ; }
bool relativeToleranceCompare(double x, double y) { double maxXY = std::max( std::fabs(x) , std::fabs(y) ) ; return std::fabs(x - y) <= std::numeric_limits<double>::epsilon()*maxXY ; }
bool combinedToleranceCompare(double x, double y) { double maxXYOne = std::max( { 1.0, std::fabs(x) , std::fabs(y) } ) ; return std::fabs(x - y) <= std::numeric_limits<double>::epsilon()*maxXYOne ; }
bool AreSame(double a, double b) { double absDiff = fabs(a - b); if (absDiff < VERYSMALL) { return true; } double maxAbs = max(fabs(a) - fabs(b)); return (absDiff/maxAbs) < EPSILON; }
template<typename TReal> static bool isApproximatelyEqual(TReal a, TReal b, TReal tolerance = std::numeric_limits<TReal>::epsilon()) { TReal diff = std::fabs(a - b); if (diff <= tolerance) return true; if (diff < std::fmax(std::fabs(a), std::fabs(b)) * tolerance) return true; return false; } template<typename TReal> static bool isApproximatelyZero(TReal a, TReal tolerance = std::numeric_limits<TReal>::epsilon()) { if (std::fabs(a) <= tolerance) return true; return false; } template<typename TReal> static bool isDefinitelyLessThan(TReal a, TReal b, TReal tolerance = std::numeric_limits<TReal>::epsilon()) { TReal diff = a - b; if (diff < tolerance) return true; if (diff < std::fmax(std::fabs(a), std::fabs(b)) * tolerance) return true; return false; } template<typename TReal> static bool isDefinitelyGreaterThan(TReal a, TReal b, TReal tolerance = std::numeric_limits<TReal>::epsilon()) { TReal diff = a - b; if (diff > tolerance) return true; if (diff > std::fmax(std::fabs(a), std::fabs(b)) * tolerance) return true; return false; } template<typename TReal> static bool isWithinPrecisionInterval(TReal a, TReal b, unsigned int interval_size = 1) { TReal min_a = a - (a - std::nextafter(a, std::numeric_limits<TReal>::lowest())) * interval_size; TReal max_a = a + (std::nextafter(a, std::numeric_limits<TReal>::max()) - a) * interval_size; return min_a <= b && max_a >= b; }
static inline bool qFuzzyCompare(double p1, double p2) { return (qAbs(p1 - p2) <= 0.000000000001 * qMin(qAbs(p1), qAbs(p2))); } static inline bool qFuzzyCompare(float p1, float p2) { return (qAbs(p1 - p2) <= 0.00001f * qMin(qAbs(p1), qAbs(p2))); }
static inline bool qFuzzyIsNull(double d) { return qAbs(d) <= 0.000000000001; } static inline bool qFuzzyIsNull(float f) { return qAbs(f) <= 0.00001f; }
if (fabs(a - b) <= DBL_EPSILON * fmax(fabs(a), fabs(b))) { }
if (fabs(a - b) <= 16 * DBL_EPSILON * fmax(fabs(a), fabs(b))) { }
typedef unsigned int U32; // // class CompareFloat{ public: union{ float m_f32; U32 m_u32; }; static bool CompareFloat::IsClose( float A, float B, U32 unitsDelta = 4 ) { U32 a = CompareFloat::GetBiased( A ); U32 b = CompareFloat::GetBiased( B ); if ( (a > 0xFF000000) || (b > 0xFF000000) ) { return( false ); } return( (static_cast<U32>(abs( a - b ))) < unitsDelta ); } protected: static U32 CompareFloat::GetBiased( float f ) { U32 r = ((CompareFloat*)&f)->m_u32; if ( r & 0x80000000 ) { return( ~r - 0x007FFFFF ); } return( r + 0x7F800000 ); } };
double ItoD (__int64 x) { return *(reinterpret_cast<double*>(&x)); } void test (__int64 ai, __int64 bi) { double a = ItoD(ai), b = ItoD(bi); bool close = std::fabs(a-b) < std::numeric_limits<double>::epsilon(); printf ("%.16f and %.16f %s close.\n", a, b, close ? "are " : "are not"); } int main() { test (0x3fe0000000000000L, 0x3fe0000000000001L); test (0x3ff0000000000000L, 0x3ff0000000000001L); }
0.5000000000000000 and 0.5000000000000001 are close. 1.0000000000000000 and 1.0000000000000002 are not close.
template< typename A, typename B > inline bool close_enough(A const & a, B const & b, typename std::common_type< A, B >::type const & epsilon) { using std::isless; assert(isless(0, epsilon)); assert(isless(epsilon, 1)); using std::abs; auto const delta = abs(a - b); auto const x = abs(a); auto const y = abs(b); return isless(epsilon * y, x) && isless(epsilon * x, y) && isless((delta + delta) / (x + y), epsilon); } int main() { std::cout << std::boolalpha << close_enough(0.9, 1.0, 0.1) << std::endl; std::cout << std::boolalpha << close_enough(1.0, 1.1, 0.1) << std::endl; std::cout << std::boolalpha << close_enough(1.1, 1.2, 0.01) << std::endl; std::cout << std::boolalpha << close_enough(1.0001, 1.0002, 0.01) << std::endl; std::cout << std::boolalpha << close_enough(1.0, 0.01, 0.1) << std::endl; return EXIT_SUCCESS; }
bool AlmostEqual(double v1, double v2) { return (std::fabs(v1 - v2) < std::fabs(std::min(v1, v2)) * std::numeric_limits<double>::epsilon()); }
public static boolean equal(double a, double b) { final long fm = 0xFFFFFFFFFFFFFL; final long sm = 0x8000000000000000L; final long cm = 0x8000000000000L; long c = Double.doubleToLongBits(a), d = Double.doubleToLongBits(b); int ea = (int) (c >> 52 & 2047), eb = (int) (d >> 52 & 2047); if (ea == 2047 && (c & fm) != 0 || eb == 2047 && (d & fm) != 0) return false; if (c == d) return true; if (ea == 0 && eb == 0) return true; if ((c & sm) != (d & sm)) return false; if (abs(ea - eb) > 1) return false; d <<= 12; c <<= 12; if (ea < eb) c = c >> 1 | sm; else if (ea > eb) d = d >> 1 | sm; c -= d; return c < 65536 && c > -65536; } public static boolean zero(double a) { return (Double.doubleToLongBits(a) >> 52 & 2047) < 3; }
bool almost_equal(double x, double y, double epsilon) { double diff = x - y; if (x != 0 && y != 0){ diff = diff/y; } if (diff < epsilon && -1.0*diff < epsilon){ return true; } return false; }
bool IsFlaotEqual(float a, float b, int decimal) { TCHAR form[50] = _T(""); _stprintf(form, _T("%%.%df"), decimal); TCHAR a1[30] = _T(""), a2[30] = _T(""); _stprintf(a1, form, a); _stprintf(a2, form, b); if( _tcscmp(a1, a2) == 0 ) return true; return false; }
bool same(double a, double b) { return std::nextafter(a, std::numeric_limits<double>::lowest()) <= b && std::nextafter(a, std::numeric_limits<double>::max()) >= b; }
template <typename T> bool compareNumber(const T& a, const T& b) { return std::abs(a - b) < std::numeric_limits<T>::epsilon(); }
void bar(); inline int fun() { return 111; } int main() { std::cout << "inline111: fun() = " << fun() << ", &fun = " << (void*) &fun; bar(); }
inline int fun() { return 222; } void bar() { std::cout << "inline222: fun() = " << fun() << ", &fun = " << (void*) &fun; }
inline111: fun() = 111, &fun = 0x4029a0 inline222: fun() = 111, &fun = 0x4029a0
inline111: fun() = 222, &fun = 0x402980 inline222: fun() = 222, &fun = 0x402980
inline111: fun() = 111, &fun = 0x402900 inline222: fun() = 222, &fun = 0x402900
header-name: < h-char-sequence > " q-char-sequence " h-char-sequence: h-char h-char-sequence h-char h-char: any member of the source character set except new-line and > q-char-sequence: q-char q-char-sequence q-char q-char: any member of the source character set except new-line and "
namespace { int cannotAccessOutsideThisFile() { ... } }
template <typename T> int b1 (T const & t) { foo(t); } namespace NS { namespace { struct S { public: operator void * () const; }; void foo (void*); static void foo (S const &); } } void b2() { NS::S s; b1 (s); }
export template <typename T> int b1 (T const & t); template <typename T> int b1 (T const & t) { foo(t); } namespace NS { namespace { struct S { }; void foo (S const & s); } } void b2() { NS::S s; b1 (s); }
namespace { void unreferenced() { std::cout << "Unreferenced"; } void referenced() { std::cout << "Referenced"; } } static void static_unreferenced() { std::cout << "Unreferenced"; } static void static_referenced() { std::cout << "Referenced"; } int main() { referenced(); static_referenced(); return 0; }
class foo { private: static int i; }; int foo::i = 0;
class foo { private: static int i; const static int a = 42; };
class A { static B b; } __declspec(selectany) A::b;
class foo { private: static bar i; }; bar foo::i = VALUE;
class SomeClass { static std::list<string> _list; public: static const std::list<string>& getList() { struct Initializer { Initializer() { _list.push_back("FIRST"); _list.push_back("SECOND"); .... } } static Initializer ListInitializationGuard; return _list; } };
class Foo { public: int GetMyStatic() const { return *MyStatic(); } private: static int* MyStatic() { static int mStatic = 0; return &mStatic; } }
class Foo { public: int GetMyStaticValue () const { return MyStatic(); } int & GetMyStaticVar () { return MyStatic(); } static bool isMyStatic (int & num) { return & num == & MyStatic(); } private: static int & MyStatic () { static int mStatic = 7; return mStatic; } }; int main (int, char **) { Foo obj; printf ("mystatic value %d\n", obj.GetMyStaticValue()); obj.GetMyStaticVar () = 3; printf ("mystatic value %d\n", obj.GetMyStaticValue()); int valMyS = obj.GetMyStaticVar (); int & iPtr1 = obj.GetMyStaticVar (); int & iPtr2 = valMyS; printf ("is my static %d %d\n", Foo::isMyStatic(iPtr1), Foo::isMyStatic(iPtr2)); }
class MyClass { public: static std::vector<int> v, v2; static struct _StaticConstructor { _StaticConstructor() { v.push_back(1); v.push_back(2); v2.push_back(3); v2.push_back(4); } } _staticConstructor; }; std::vector<int> MyClass::v; std::vector<int> MyClass::v2; MyClass::_StaticConstructor MyClass::_staticConstructor; int main() { assert(MyClass::v[0] == 1); assert(MyClass::v[1] == 2); assert(MyClass::v2[0] == 3); assert(MyClass::v2[1] == 4); }
using namespace std; class A { private: static int v; }; int A::v = 10; int main() { A a; return 0; }
class foo { public: static void set_default(int); private: static int i; }; void foo::set_default(int x) { i = x; }
class Foo { static int& getObjectInstance() { static int object; return object; } void func() { int &object = getValueInstance(); object += 5; } };
template<typename T> Type ClassName<T>::dataMemberName = initialValue;
class foo { private: enum {i = 0}; enum: int64_t {HUGE = 1000000000000}; };
struct MyStruct { public: const std::unordered_map<std::string, uint32_t> str_to_int{ { "a", 1 }, { "b", 2 }, ... { "z", 26 } }; const std::unordered_map<int , std::string> int_to_str{ { 1, "a" }, { 2, "b" }, ... { 26, "z" } }; std::string some_string = "justanotherstring"; uint32_t some_int = 42; static MyStruct & Singleton() { static MyStruct instance; return instance; } private: MyStruct() {}; }; int main(){ std::cout<<MyStruct::Singleton().some_string<<std::endl; std::cout<<MyStruct::Singleton().some_int<<std::endl; return 0; }
class Foo { public: int Bar(int random_arg) const { } };
struct { char a; char b; char c; char d; } mystruct; mystruct.a = mystruct.b = mystruct.c = mystruct.d = char* my_pointer; my_pointer = &mystruct.b; cout << my_pointer++; cout << my_pointer = &mystruct.a; cout << my_pointer = my_pointer + 3; cout <<
int** a = new int*[rowCount]; for(int i = 0; i < rowCount; ++i) a[i] = new int[colCount];
int **ary = new int*[sizeY]; for(int i = 0; i < sizeY; ++i) { ary[i] = new int[sizeX]; }
for(int i = 0; i < sizeY; ++i) { delete [] ary[i]; } delete [] ary;
class Matrix { ... size_t index( int x, int y ) const { return x + m_width * y; } };
using namespace std; int main() { const auto M = 2; const auto N = 2; auto array = new double[M][N]; array[0][0] = 2; array[1][0] = 3; array[0][1] = 4; array[1][1] = 5; delete[] array; array = new double[M][N]; for(int r = 0; r < M; r++) { for(int c = 0; c < N; c++) cout << array[r][c] << " "; cout << endl; } cout << endl; delete[] array; array = new double[M][N](); for(int r = 0; r < M; r++) { for(int c = 0; c < N; c++) cout << array[r][c] << " "; cout << endl; } int info; cout << abi::__cxa_demangle(typeid(array).name(),0,0,&info) << endl; return 0; }
using grid = std::array<std::array<int, sizeX>, sizeY>; grid * ary = new grid;
class Grid { size_t _rows; size_t _columns; std::unique_ptr<int[]> data; public: Grid(size_t rows, size_t columns) : _rows{rows}, _columns{columns}, data{std::make_unique<int[]>(rows * columns)} {} size_t rows() const { return _rows; } size_t columns() const { return _columns; } int *operator[](size_t row) { return row * _columns + data.get(); } int &operator()(size_t row, size_t column) { return data[row * _columns + column]; } }
int &operator()(size_t row, size_t column) { return data[row * _columns + column]; }
int rows = 100; int cols = 200; vector< vector<int> > f(rows, vector<int>(cols)); f[rows - 1][cols - 1] = 0;
int main(int argc, char **argv) { typedef double (array5k_t)[5000]; array5k_t *array5k = new array5k_t[5000]; array5k[4999][4999] = 10; printf("array5k[4999][4999] == %f\n", array5k[4999][4999]); return 0; }
int main(int argc, char **argv) { typedef double (*array5k_t)[5000]; array5k_t array5k = calloc(5000, sizeof(double)*5000); array5k[4999][4999] = 10; printf("array5k[4999][4999] == %f\n", array5k[4999][4999]); return 0; }
int** ary = new int*[N]; for(int i = 0; i < N; i++) ary[i] = new int[M];
for(int i = 0; i < N; i++) for(int j = 0; j < M; j++) ary[i][j] = i;
for(int i = 0; i < N; i++) for(int j = 0; j < M; j++) std::cout << ary[i][j] << "\n";
for(int i = 0; i < N; i++) delete [] ary[i]; delete [] ary;
int main(int argc, char** argv) { if (argc != 3) { std::cerr << "You have to specify the two array dimensions" << std::endl; return -1; } int sizeX, sizeY; sizeX = std::stoi(argv[1]); sizeY = std::stoi(argv[2]); if (sizeX <= 0) { std::cerr << "Invalid dimension x" << std::endl; return -1; } if (sizeY <= 0) { std::cerr << "Invalid dimension y" << std::endl; return -1; } /******** Create a two dimensional dynamic array in continuous memory ****** * * - Define the pointer holding the array * - Allocate memory for the array (linear) * - Allocate memory for the pointers inside the array * - Assign the pointers inside the array the corresponding addresses * in the linear array **************************************************************************/ unsigned int** array2d; unsigned int* temp = new unsigned int[sizeX * sizeY]; array2d = new unsigned int*[sizeY]; for (int i = 0; i < sizeY; ++i) { array2d[i] = (temp + i * sizeX); } for (int y = 0; y < sizeY; ++y) { for (int x = 0; x < sizeX; ++x) { array2d[y][x] = x + y * sizeX; } } for (int y = 0; y < sizeY; ++y) { for (int x = 0; x < sizeX; ++x) { std::cout << std::hex << &(array2d[y][x]) << } } std::cout << "\n\n"; for (int y = 0; y < sizeY; ++y) { std::cout << std::hex << &(array2d[y][0]) << std::dec; std::cout << ": "; for (int x = 0; x < sizeX; ++x) { std::cout << array2d[y][x] << } std::cout << std::endl; } delete[] array2d[0]; delete[] array2d; array2d = nullptr; return 0; }
0x603010 0x603014 0x603018 0x60301c 0x603020 0x603024 0x603028 0x60302c 0x603030 0x603034 0x603038 0x60303c 0x603040 0x603044 0x603048 0x60304c 0x603050 0x603054 0x603058 0x60305c 0x603060 0x603064 0x603068 0x60306c 0x603070 0x603074 0x603078 0x60307c 0x603080 0x603084 0x603088 0x60308c 0x603090 0x603094 0x603098 0x60309c 0x6030a0 0x6030a4 0x6030a8 0x6030ac 0x6030b0 0x6030b4 0x6030b8 0x6030bc 0x6030c0 0x6030c4 0x6030c8 0x6030cc 0x6030d0 0x6030d4 0x6030d8 0x6030dc 0x6030e0 0x6030e4 0x6030e8 0x6030ec 0x6030f0 0x6030f4 0x6030f8 0x6030fc 0x603100 0x603104 0x603108 0x60310c 0x603110 0x603114 0x603118 0x60311c 0x603120 0x603124 0x603128 0x60312c 0x603130 0x603134 0x603138 0x60313c 0x603140 0x603144 0x603148 0x60314c 0x603150 0x603154 0x603158 0x60315c 0x603160 0x603164 0x603168 0x60316c 0x603170 0x603174 0x603178 0x60317c 0x603180 0x603184 0x603188 0x60318c 0x603190 0x603194 0x603198 0x60319c 0x6031a0 0x6031a4 0x6031a8 0x6031ac 0x6031b0 0x6031b4 0x6031b8 0x6031bc 0x6031c0 0x6031c4 0x6031c8 0x6031cc 0x6031d0 0x6031d4 0x6031d8 0x6031dc 0x6031e0 0x6031e4 0x6031e8 0x6031ec 0x6031f0 0x6031f4 0x6031f8 0x6031fc 0x603200 0x603204 0x603208 0x60320c 0x603210 0x603214 0x603218 0x60321c 0x603220 0x603224 0x603228 0x60322c 0x603230 0x603234 0x603238 0x60323c 0x603240 0x603244 0x603248 0x60324c 0x603250 0x603254 0x603258 0x60325c 0x603260 0x603264 0x603268 0x60326c 0x603270 0x603274 0x603278 0x60327c 0x603280 0x603284 0x603288 0x60328c 0x603290 0x603294 0x603298 0x60329c 0x6032a0 0x6032a4 0x6032a8 0x6032ac 0x6032b0 0x6032b4 0x6032b8 0x6032bc 0x6032c0 0x6032c4 0x6032c8 0x6032cc 0x6032d0 0x6032d4 0x6032d8 0x6032dc 0x6032e0 0x6032e4 0x6032e8 0x6032ec 0x6032f0 0x6032f4 0x6032f8 0x6032fc 0x603300 0x603304 0x603308 0x60330c 0x603310 0x603314 0x603318 0x60331c 0x603320 0x603324 0x603328 0x60332c 0x603330 0x603334 0x603338 0x60333c 0x603340 0x603344 0x603348 0x60334c 0x603350 0x603354 0x603358 0x60335c 0x603360 0x603364 0x603368 0x60336c 0x603370 0x603374 0x603378 0x60337c 0x603380 0x603384 0x603388 0x60338c 0x603390 0x603394 0x603398 0x60339c 0x6033a0 0x6033a4 0x6033a8 0x6033ac 0x6033b0 0x6033b4 0x6033b8 0x6033bc 0x6033c0 0x6033c4 0x6033c8 0x6033cc 0x6033d0 0x6033d4 0x6033d8 0x6033dc 0x6033e0 0x6033e4 0x6033e8 0x6033ec 0x6033f0 0x6033f4 0x6033f8 0x6033fc 0x603400 0x603404 0x603408 0x60340c 0x603410 0x603414 0x603418 0x60341c 0x603420 0x603424 0x603428 0x60342c 0x603430 0x603434 0x603438 0x60343c 0x603440 0x603444 0x603448 0x60344c 0x603450 0x603454 0x603458 0x60345c 0x603460 0x603464 0x603468 0x60346c 0x603470 0x603474 0x603478 0x60347c 0x603480 0x603484 0x603488 0x60348c 0x603490 0x603494 0x603498 0x60349c 0x6034a0 0x6034a4 0x6034a8 0x6034ac 0x6034b0 0x6034b4 0x6034b8 0x6034bc 0x603010: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0x603060: 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 0x6030b0: 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 0x603100: 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 0x603150: 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 0x6031a0: 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 0x6031f0: 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 0x603240: 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 0x603290: 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 0x6032e0: 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 0x603330: 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 0x603380: 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 0x6033d0: 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 0x603420: 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 0x603470: 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299
int **ary = new int[sizeY]; for (int i = 0; i < sizeY; i++) ary[i] = new int[sizeX];
using namespace std; int main(){ int **arr_01,**arr_02,i,j,rows=4,cols=5; arr_01=new int*[rows]; for(int i=0;i<rows;i++) arr_01[i]=new int[cols]; for(i=0;i<rows;i++){ for(j=0;j<cols;j++) cout << arr_01[i]+j << " " ; cout << endl; } for(int i=0;i<rows;i++) delete[] arr_01[i]; delete[] arr_01; cout << endl; arr_02=new int*[rows]; arr_02[0]=new int[rows*cols]; for(int i=1;i<rows;i++) arr_02[i]=arr_02[0]+cols*i; for(int i=0;i<rows;i++){ for(int j=0;j<cols;j++) cout << arr_02[i]+j << " " ; cout << endl; } delete[] arr_02[0]; delete[] arr_02; return 0; }
array<array<int, 3>, 2> array2d = array<array<int, 3>, 2>();
array<int, sizeX*sizeY> ary = array<int, sizeX*sizeY>(); ary.at(i*sizeY+j);
int** a = new int* [x]; for(int i = 0; i < x; i++) a[i] = new int[y];
int size = 1492; char (*array)[20]; array = new char[size][20]; ... strcpy(array[5], "hola!"); ... delete [] array;
void halla_centros_V000(double CENW[][DIM]) { CENW[i][j]=... ... } int main() { double *CENW_MEM=new double[WORMS*DIM]; double (*CENW)[DIM]; CENW=(double (*)[3]) &CENW_MEM[0]; halla_centros_V000(CENW); delete[] CENW_MEM; }
using namespace std; int main() { int x = 3, y = 3; int **ptr = new int *[x]; for(int i = 0; i<y; i++) { ptr[i] = new int[y]; } srand(time(0)); for(int j = 0; j<x; j++) { for(int k = 0; k<y; k++) { int a = rand()%10; ptr[j][k] = a; cout<<ptr[j][k]<<" "; } cout<<endl; } }
struct Sprite { int x; }; int main () { int num = 50; Sprite **spritearray; spritearray = new Sprite *[num]; for (int n = 0; n < num; n++) { spritearray[n] = new Sprite; spritearray->x = n * 3; } for (int n = 0; n < num; n++) { if (spritearray[n]->x < 0) { delete spritearray[n]; spritearray[n] = NULL; } } for (int n = 0; n < num; n++) { if (spritearray[n] != NULL){ delete spritearray[n]; spritearray[n] = NULL; } } delete []spritearray; spritearray = NULL; return 0; }
int *arrayPointer = new int[4][5][6]; int *arrayPointer = new int[m][5][6]; int *arrayPointer = new int[3][5][]; int *arrayPointer = new int[][5][6];
static_assert(!std::is_same<int[8], float[8]>::value, "distinct element type"); static_assert(!std::is_same<int[8], int[9]>::value, "distinct size");
+---+---+---+---+---+---+---+---+ the_actual_array: | | | | | | | | | int[8] +---+---+---+---+---+---+---+---+ ^ | | | | pointer_to_the_first_element int*
static_assert(!std::is_same<int[8], int*>::value, "an array is not a pointer");
static_assert(!std::is_same<int*, int(*)[8]>::value, "distinct element type");
+-----------------------------------+ | +---+---+---+---+---+---+---+---+ | +---> | | | | | | | | | | | int[8] | | +---+---+---+---+---+---+---+---+ | | +---^-------------------------------+ | | | | | | | | pointer_to_the_first_element int* | | pointer_to_the_entire_array int(*)[8]
std::cout << *(x+3) << ", " << *(x+7) << std::endl;
+---+---+---+---+---+---+---+---+ x: | | | | | | | | | int[8] +---+---+---+---+---+---+---+---+ ^ ^ ^ | | | | | | | | | x+0 | x+3 | x+7 | int*
+---+---+---+---+---+---+---+---+ | | | | | | | | | int[8] +---+---+---+---+---+---+---+---+ ^ ^ ^ | | | | | | +-|-+ | | x: | | | x+3 | x+7 | int* +---+
+---+---+---+---+---+---+---+---+.... x: | | | | | | | | | . int[8] +---+---+---+---+---+---+---+---+.... ^ ^ | | | | | | x+0 | x+8 | int*
std::sort(x + 0, x + n); std::sort(&x[0], &x[0] + n);
int H = read_int(); int W = read_int(); int connect_four[6][7]; int connect_four[H][7]; int connect_four[6][W]; int connect_four[H][W];
+---+---+---+---+---+---+---+ connect_four: | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | +---+---+---+---+---+---+---+
int* p = &connect_four[0][0]; int* q = p + 42; some_int_sequence_algorithm(p, q);
int (*p)[7] = new int[6][7]; int (*p)[7] = new int[H][7]; int (*p)[W] = new int[6][W]; int (*p)[W] = new int[H][W];
+---+---+---+---+---+---+---+ +---> | | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | | | +---+---+---+---+---+---+---+ | | | | | | | | | | +---+---+---+---+---+---+---+ | +-|-+ p: | | | +---+
int* triangle[5]; for (int i = 0; i < 5; ++i) { triangle[i] = new int[5 - i]; } for (int i = 0; i < 5; ++i) { delete[] triangle[i]; }
+---+---+---+---+---+ | | | | | | +---+---+---+---+---+ ^ | +---+---+---+---+ | | | | | | | +---+---+---+---+ | ^ | | +---+---+---+ | | | | | | | | +---+---+---+ | | ^ | | | +---+---+ | | | | | | | | | +---+---+ | | | ^ | | | | +---+ | | | | | | | | | | +---+ | | | | ^ | | | | | | | | | | +-|-+-|-+-|-+-|-+-|-+ triangle: | | | | | | | | | | | +---+---+---+---+---+
int n = calculate_five(); int** p = new int*[n]; for (int i = 0; i < n; ++i) { p[i] = new int[n - i]; } for (int i = 0; i < n; ++i) { delete[] p[i]; } delete[] p;
+---+---+---+---+---+ | | | | | | +---+---+---+---+---+ ^ | +---+---+---+---+ | | | | | | | +---+---+---+---+ | ^ | | +---+---+---+ | | | | | | | | +---+---+---+ | | ^ | | | +---+---+ | | | | | | | | | +---+---+ | | | ^ | | | | +---+ | | | | | | | | | | +---+ | | | | ^ | | | | | | | | | | +-|-+-|-+-|-+-|-+-|-+ | | | | | | | | | | | +---+---+---+---+---+ ^ | | +-|-+ p: | | | +---+
int array_of_arrays[6][7]; int (*pointer_to_array)[7] = array_of_arrays; int* array_of_pointers[6]; int** pointer_to_pointer = array_of_pointers;
int connect_four[6][7]; int** p = new int*[6]; for (int i = 0; i < 6; ++i) { p[i] = connect_four[i]; } delete[] p;
int connect_four[6][7]; int** p = new int*[6]; for (int i = 0; i < 6; ++i) { p[i] = new int[7]; std::copy(connect_four[i], connect_four[i + 1], p[i]); } for (int i = 0; i < 6; ++i) { delete[] p[i]; } delete[] p;
int a[8] = {2, 3, 5, 7, 11, 13, 17, 19}; int b[8]; std::copy(a + 0, a + 8, b);
int sum(const int* p, std::size_t n) { return std::accumulate(p, p + n, 0); } int sum(const int* p, const int* q) { return std::accumulate(p, q, 0); }
int sum(const int p[], std::size_t n) { return std::accumulate(p, p + n, 0); }
int sum(const int* p, std::size_t n) int sum(const int p[], std::size_t n) int sum(const int p[8], std::size_t n)
int sum(const int (&a)[8]) { return std::accumulate(a + 0, a + 8, 0); }
template <std::size_t n> int sum(const int (&a)[n]) { return std::accumulate(a + 0, a + n, 0); }
int global_static_array[8]; void foo() { static int local_static_array[8]; }
class Foo { int primes[8]; public: Foo() { primes[0] = 2; primes[1] = 3; primes[2] = 5; } };
class Foo { int primes[8]; public: Foo() { int local_array[] = {2, 3, 5, 7, 11, 13, 17, 19}; std::copy(local_array + 0, local_array + 8, primes + 0); } };
class Foo { int primes[8]; public: Foo() : primes { 2, 3, 5, 7, 11, 13, 17, 19 } { } };
std::size_t size = compute_size_at_runtime(); int* p = new int[size];
+---+---+---+---+---+---+---+---+ (anonymous) | | | | | | | | | +---+---+---+---+---+---+---+---+ ^ | | +-|-+ p: | | | int* +---+
int* p = new int[8] { 2, 3, 5, 7, 11, 13, 17, 19 };
extern int* numbers; int main() { using namespace std; for( int i = 0; i < 42; ++i ) { cout << (i > 0? ", " : "") << numbers[i]; } cout << endl; }
void display( int const a[7] ) { int const n = N_ITEMS( a ); printf( "%d elements.\n", n ); } int main() { int const moohaha[] = {1, 2, 3, 4, 5, 6, 7}; printf( "%d elements, calling display...\n", N_ITEMS( moohaha ) ); display( moohaha ); }
assert(( \ "N_ITEMS requires an actual array as argument", \ typeid( array ) != typeid( &*array ) \ )), \ sizeof( array )/sizeof( *array ) \ )
typedef ptrdiff_t Size; template< class Type, Size n > Size n_items( Type (&)[n] ) { return n; }
typedef ptrdiff_t Size; template< class Type, Size n > Size n_items( Type (&)[n] ) { return n; }
using Size = ptrdiff_t; template< class Type, Size n > constexpr auto n_items( Type (&)[n] ) -> Size { return n; }
void foo() { int const x[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 4}; constexpr Size n = n_items( x ); int y[n] = {}; }
template< class Collection > void foo( Collection const& c ) { constexpr int n = n_items( c ); } auto main() -> int { int x[42]; foo( x ); }
using Size = ptrdiff_t; template< class Collection > void foo( Collection const& c ) { constexpr Size n = std::extent< decltype( c ) >::value; }
using Size = ptrdiff_t; template< Size n > struct Size_carrier { char sizer[n]; }; template< class Type, Size n > auto static_n_items( Type (&)[n] ) -> Size_carrier<n>; template< class Type, size_t n > auto static_n_items( std::array<Type, n> const& ) -> Size_carrier<n>; static_cast<Size>( sizeof( static_n_items( c ).sizer ) ) template< class Collection > void foo( Collection const& c ) { constexpr Size n = STATIC_N_ITEMS( c ); (void) c; } auto main() -> int { int x[42]; std::array<int, 43> y; foo( x ); foo( y ); }
void doSomething() { doSomethingElse(); } void doSomethingElse() { }
void doSomethingElse() ; void doSomething() { doSomethingElse() ; }
void doSomethingElse() ; void doSomething() { doSomethingElse() ; } void doSomethingElse() { } void doSomethingAgain() { doSomethingElse() ; }
void someFunction(); void someOtherFunction(); void doSomething() { }
class A {..}; class B : public A {...}; class C { include A.cpp; include B.cpp; ..... };
template<int N> class fixed_size_list { }; fixed_size_list<X> mylist; int numbers[X];
int main() { const int N = 3; int numbers[N] = {1, 2, 3}; }
template<int N> class list { }; constexpr int sqr1(int arg) { return arg * arg; } int sqr2(int arg) { return arg * arg; } int main() { const int X = 2; list<sqr1(X)> mylist1; list<sqr2(X)> mylist2; }
static constexpr int N = 3; int main() { constexpr const int *NP = &N; }
constexpr int max() { return INT_MAX; } constexpr long long_max() { return 2147483647; } constexpr bool get_val() { bool res = false; return res; } constexpr int square(int x) { return x * x; } const int res = square(5); int y = getval(); int n = square(y);
struct S { constexpr int two(); private: static constexpr int sz; }; constexpr int S::sz = 256; enum DataPacket { Small = S::two(), Big = 1024 }; constexpr int S::two() { return sz*2; } constexpr S s; int arr[s.two()];
struct complex { constexpr complex(double r, double i) : re(r), im(i) { } constexpr double real() { return re; } constexpr double imag() { return im; } private: double re; double im; }; constexpr complex COMP(0.0, 1.0); double x = 1.0; constexpr complex cx1(x, 0); const complex cx2(x, 1); constexpr double xx = COMP.real(); constexpr double imaglval = COMP.imag(); complex cx3(2, 4.6);
const int dmv = 17; int var = 17; constexpr double max1 = 1.4*square(dmv); constexpr double max2 = 1.4∗square(var); const double max3 = 1.4∗square(var); double sum(const vector<double>&); vector<double> v {1.2, 3.4, 4.5}; const double s1 = sum(v); constexpr double s2 = sum(v);
const int x1=10; constexpr int x2=10; x1=20; x2=20;
int temp=rand(); const int x1=10; const int x2=temp; constexpr int x3=10; constexpr int x4=temp;
const int size1=10; const int size2=temp; constexpr int size3=10; int array3[size1]; int array4[size2]; int array5[size3];
class test { int x; void function1() { x=100; } void function2() const { x=100; } };
constexpr int func_constexpr(int X, int Y) { return(X*Y); } int func(int X, int Y) { return(X*Y); } int array1[func_constexpr(10,20)]; int array2[func(10,20)]; int array3[func_constexpr(10,rand())];
int value1=func_constexpr(10,rand()); constexpr int value2=func_constexpr(10,rand());
class test2 { static constexpr int function(int value) { return(value+1); } void f() { int x[function(10)]; } };
class test3 { public: int value; constexpr int getvalue() const { return(value); } constexpr test3(int Value) : value(Value) { } }; constexpr test3 x(100); int array[x.getvalue()];
cout << "Enter your age: "; int age; cin >> age; const int myAge{age}; constexpr int someAge{age};
int main(int argc, char*argv[]) { const int p = argc; constexpr int r = 2^3; }
int a[7]; std::cout << "Length of array = " << (sizeof(a)/sizeof(*a)) << std::endl;
int *p = new int[7]; std::cout << "Length of array = " << (sizeof(p)/sizeof(*p)) << std::endl;
void func(int *p) { std::cout << "Length of array = " << (sizeof(p)/sizeof(*p)) << std::endl; } int a[7]; func(a);
template<class T, size_t N> constexpr size_t size(T (&)[N]) { return N; }
uint32_t data[] = {10, 20, 30, 40}; auto dataSize = std::size(data);
int main () { using namespace std; int arr[] = {2, 7, 1, 111}; auto array_length = end(arr) - begin(arr); cout << "Length of array: " << array_length << endl; }
template<class T, size_t N> constexpr size_t length(T(&)[N]) { return N; } template<class T, size_t N> constexpr size_t length2(T(&arr)[N]) { return sizeof(arr) / sizeof(*arr); } int main() { int a[5][4][3]{{{1,2,3}, {4,5,6}}, { }, {{7,8,9}}}; constexpr auto l1 = std::extent<decltype(a)>::value; constexpr auto l2 = std::extent<decltype(a), 1>::value; constexpr auto l3 = std::extent<decltype(a), 2>::value; constexpr auto l4 = std::extent<decltype(a), 3>::value; constexpr auto la = length(a); std::remove_extent<decltype(a)>::type pa; constexpr auto lpa = length(pa); std::cout << la << constexpr auto la2 = sizeof(a) / sizeof(*a); constexpr auto lpa2 = sizeof(*a) / sizeof(**a); std::cout << la2 << return 0; }
constexpr auto l = sizeof(a) / sizeof(std::remove_all_extents<decltype(a)>::type);
template<class T> constexpr size_t len(T &a) { return sizeof(a) / sizeof(typename std::remove_all_extents<T>::type); } int main() { int a[5][4][3]{{{1,2,3}, {4,5,6}}, { }, {{7,8,9}}}; constexpr auto ttt = len(a); int i; std::cout << ttt << return 0; }
const std::string s[3] = { "1"s, "2"s, "3"s }; constexpr auto n = std::extent< decltype(s) >::value; constexpr auto n2 = std::extent_v< decltype(s) >; const auto a = std::array{ "1"s, "2"s, "3"s }; constexpr auto size = std::tuple_size_v< decltype(a) >; std::cout << n << " " << n2 << " " << size << "\n";
array<type_of_the_array, number_of_elements_in_the_array> Name_of_Array = {};
int main() { std::array<int,3> arr; std::cout<<arr.size()<<std::endl; auto it=arr.end(); std::cout<<arr.back()<<"\t"<<arr[arr.size()-1]<<"\t"<<*(--it); return 0; }
((sizeof(a) / sizeof(*(a))) / static_cast<size_t>(!(sizeof(a) % sizeof(*(a))))) char* ptr[] = { "you", "are", "here" }; int testarr[] = {1, 2, 3, 4}; cout << GOOGLE_ARRAYSIZE(testarr) << endl; cout << GOOGLE_ARRAYSIZE(ptr) << endl;
string myArray[] = { "Example1", "Example2", "Example3", "Example4" }; int size_of_array=size(myArray);
template <typename T,unsigned S> inline unsigned arraysize(const T (&v)[S]) { return S; }
arr[0] = length; arr++; int len = *(arr-1); free(--arr);
int prime[] = {0}; int primes(int x, int y){ using namespace std; int a = 1; for (int i = x; i <= y; i++){prime[a] = i; a++; } prime[0] = a; return 0; }
class MyObject; struct MyObjectList { std::list<MyObject> objects; MyObjectList& operator<<( const MyObject o ) { objects.push_back( o ); return *this; } };
someFunc( MyObjectList() << MyObject(1) << MyObject(2) << MyObject(3) );
template <class T, size_t N> char (&helper(T (&)[N]))[N]; int main() { int a[10]; std::cout << arraysize(a) << std::endl; return 0; }
int arr[] = {1, 2, 3, 4, 5, 6}; int size = *(&arr + 1) - arr; cout << "Number of elements in arr[] is "<< size; return 0;
{ std::stringstream ss; ss << "what"; } { std::stringstream ss; ss << "the"; } { std::stringstream ss; ss << "heck"; }
sstm.str(""); sstm.clear(); sstm << "crap" << "morecrap";
int main(int argc, char** argv) { std::cout << "Have " << argc << " arguments:" << std::endl; for (int i = 0; i < argc; ++i) { std::cout << argv[i] << std::endl; } }
p = { "myprog", "arg1", "arg2", "arg 3", NULL }; exit(main(4, p));
template<class T> std::string optionalToString(T* obj) { if (FUNCTION_EXISTS(T->toString)) return obj->toString(); else return "toString not defined"; }
struct Hello { int helloworld() { return 0; } }; struct Generic {}; template <typename T> class has_helloworld { typedef char one; typedef long two; template <typename C> static one test( typeof(&C::helloworld) ) ; template <typename C> static two test(...); public: enum { value = sizeof(test<T>(0)) == sizeof(char) }; }; int main(int argc, char *argv[]) { std::cout << has_helloworld<Hello>::value << std::endl; std::cout << has_helloworld<Generic>::value << std::endl; return 0; }
template<class T> auto serialize_imp(std::ostream& os, T const& obj, int) -> decltype(os << obj, void()) { os << obj; } template<class T> auto serialize_imp(std::ostream& os, T const& obj, long) -> decltype(obj.stream(os), void()) { obj.stream(os); } template<class T> auto serialize(std::ostream& os, T const& obj) -> decltype(serialize_imp(os, obj, 0), void()) { serialize_imp(os, obj, 0); }
template<class> struct sfinae_true : std::true_type{}; namespace detail{ template<class T, class A0> static auto test_stream(int) -> sfinae_true<decltype(std::declval<T>().stream(std::declval<A0>()))>; template<class, class A0> static auto test_stream(long) -> std::false_type; } template<class T, class Arg> struct has_stream : decltype(detail::test_stream<T, Arg>(0)){};
template<class T> void serialize_imp(std::ostream& os, T const& obj, int, int(*)[sizeof((os << obj),0)] = 0) { os << obj; }
template<typename T, typename Sign> \ struct name { \ typedef char yes[1]; \ typedef char no [2]; \ template <typename U, U> struct type_check; \ template <typename _1> static yes &chk(type_check<Sign, &_1::func > *); \ template <typename > static no &chk(...); \ static bool const value = sizeof(chk<T>(0)) == sizeof(yes); \ }
HAS_MEM_FUNC(toString, has_to_string); template<typename T> void doSomething() { if(has_to_string<T, std::string(T::*)()>::value) { ... } else { ... } }
template<bool C, typename T = void> struct enable_if { typedef T type; }; template<typename T> struct enable_if<false, T> { }; HAS_MEM_FUNC(toString, has_to_string); template<typename T> typename enable_if<has_to_string<T, std::string(T::*)()>::value, std::string>::type doSomething(T * t) { return t->toString(); } template<typename T> typename enable_if<!has_to_string<T, std::string(T::*)()>::value, std::string>::type doSomething(T * t) { return "T::toString() does not exist."; }
template <class Type> class TypeHasToString { template <typename T, T> struct TypeCheck; typedef char Yes; typedef long No; template <typename T> struct ToString { typedef void (T::*fptr)(); }; template <typename T> static Yes HasToString(TypeCheck< typename ToString<T>::fptr, &T::toString >*); template <typename T> static No HasToString(...); public: static bool const value = (sizeof(HasToString<Type>(0)) == sizeof(Yes)); };
template<typename T> using toString_t = decltype( std::declval<T&>().toString() ); template<typename T> constexpr bool has_toString = std::is_detected_v<toString_t, T>;
template<class T> std::string optionalToString(T* obj) { if constexpr (has_toString<T>) return obj->toString(); else return "toString not defined"; }
BOOST_TTI_HAS_MEMBER_FUNCTION(toString) constexpr bool foo = has_member_function_toString<T, std::string>::value;
template <typename T> struct response_trait { static bool const has_tostring = false; }; template <> struct response_trait<your_type_with_tostring> { static bool const has_tostring = true; }
template<class T> auto optionalToString(T* obj) -> decltype( obj->toString() ) { return obj->toString(); } auto optionalToString(...) -> string { return "toString not defined"; }
template<class T> constexpr auto test_has_toString_method(T* obj) -> decltype( obj->toString() , std::true_type{} ) { return obj->toString(); } constexpr auto test_has_toString_method(...) -> std::false_type { return "toString not defined"; }
template <typename...> using void_t = void; template <typename, template <typename> class, typename = void_t<>> struct detect : std::false_type {}; template <typename T, template <typename> class Op> struct detect<T, Op, void_t<Op<T>>> : std::true_type {};
template <typename T> using toString_t = decltype(std::declval<T>().toString()); template <typename T> using has_toString = detect<T, toString_t>;
template <typename T> using assign_t = decltype(std::declval<T&>() = std::declval<T const &>()) template <typename T> using is_assignable = detect<T, assign_t>;
template <typename...> struct voider { using type = void; }; template <typename...Ts> using void_t = typename voider<Ts...>::type; template <typename...> using void_t = void;
CREATE_MEMBER_CHECK(x); bool has_x = has_member_x<class_to_check_for_x>::value;
CREATE_MEMBER_FUNC_SIG_CHECK(x, void (T::*)(), void__x); bool has_func_sig_void__x = has_member_func_void__x<class_to_check_for_x>::value;
CREATE_MEMBER_VAR_CHECK(x); bool has_var_x = has_member_var_x<class_to_check_for_x>::value;
CREATE_MEMBER_CLASS_CHECK(x); bool has_class_x = has_member_class_x<class_to_check_for_x>::value;
CREATE_MEMBER_UNION_CHECK(x); bool has_union_x = has_member_union_x<class_to_check_for_x>::value;
CREATE_MEMBER_ENUM_CHECK(x); bool has_enum_x = has_member_enum_x<class_to_check_for_x>::value;
CREATE_MEMBER_CHECK(x); CREATE_MEMBER_VAR_CHECK(x); CREATE_MEMBER_CLASS_CHECK(x); CREATE_MEMBER_UNION_CHECK(x); CREATE_MEMBER_ENUM_CHECK(x); CREATE_MEMBER_FUNC_CHECK(x); bool has_any_func_x = has_member_func_x<class_to_check_for_x>::value;
CREATE_MEMBER_CHECKS(x); bool has_any_func_x = has_member_func_x<class_to_check_for_x>::value;
template <typename... Args> struct ambiguate : public Args... {}; template<typename A, typename = void> struct got_type : std::false_type {}; template<typename A> struct got_type<A> : std::true_type { typedef A type; }; template<typename T, T> struct sig_check : std::true_type {}; template<typename Alias, typename AmbiguitySeed> struct has_member { template<typename C> static char ((&f(decltype(&C::value))))[1]; template<typename C> static char ((&f(...)))[2]; static_assert( (sizeof(f<AmbiguitySeed>(0)) == 1) , "Member name specified in AmbiguitySeed is different from member name specified in Alias, or wrong Alias/AmbiguitySeed has been specified." ); static bool const value = sizeof(f<Alias>(0)) == 2; };
\ template<typename T, typename = std::true_type> \ struct Alias_ \ template<typename T> \ struct Alias_ T, std::integral_constant<bool, got_type<decltype(&T::member)>::value> \ > { static const decltype(&T::member) value; }; \ \ struct AmbiguitySeed_ \ template<typename T> \ struct has_member_ static const bool value \ = has_member< \ Alias_ , Alias_ >::value \ ; \ }
\ template<typename T, typename = std::true_type> \ struct has_member_var_ \ template<typename T> \ struct has_member_var_ T \ , std::integral_constant< \ bool \ , !std::is_member_function_pointer<decltype(&T::var_name)>::value \ > \ > : std::true_type {}
\ template<typename T, typename = std::true_type> \ struct has_member_func_ \ template<typename T> \ struct has_member_func_ T, std::integral_constant< \ bool \ , sig_check<func_sig, &T::func_name>::value \ > \ > : std::true_type {}
\ template<typename T, typename = std::true_type> \ struct has_member_class_ \ template<typename T> \ struct has_member_class_ T \ , std::integral_constant< \ bool \ , std::is_class< \ typename got_type<typename T::class_name>::type \ >::value \ > \ > : std::true_type {}
\ template<typename T, typename = std::true_type> \ struct has_member_union_ \ template<typename T> \ struct has_member_union_ T \ , std::integral_constant< \ bool \ , std::is_union< \ typename got_type<typename T::union_name>::type \ >::value \ > \ > : std::true_type {}
\ template<typename T, typename = std::true_type> \ struct has_member_enum_ \ template<typename T> \ struct has_member_enum_ T \ , std::integral_constant< \ bool \ , std::is_enum< \ typename got_type<typename T::enum_name>::type \ >::value \ > \ > : std::true_type {}
template<typename T> \ struct has_member_func_ static const bool value \ = has_member_ && !has_member_var_ && !has_member_class_ && !has_member_union_ && !has_member_enum_ ; \ }
CREATE_MEMBER_CHECK(member); \ CREATE_MEMBER_VAR_CHECK(member); \ CREATE_MEMBER_CLASS_CHECK(member); \ CREATE_MEMBER_UNION_CHECK(member); \ CREATE_MEMBER_ENUM_CHECK(member); \ CREATE_MEMBER_FUNC_CHECK(member)
template<class> struct type_sink { typedef void type; }; template<class T> using type_sink_t = typename type_sink<T>::type; template<class T, class=void> struct has_to_string : std::false_type {}; \ template<class T> struct has_to_string< T, type_sink_t< decltype( std::declval<T>().toString() ) > >: std::true_type {};
namespace details { template<class T> std::string optionalToString_helper(T* obj, std::true_type ) { return obj->toString(); } template<class T> std::string optionalToString_helper(T* obj, std::false_type ) { return "toString not defined"; } } template<class T> std::string optionalToString(T* obj) { return details::optionalToString_helper( obj, has_to_string<T>{} ); }
template<class T, class=void> struct TRAIT_NAME : std::false_type {}; \ template<class T> struct TRAIT_NAME< T, type_sink_t< decltype( __VA_ARGS__ ) > >: std::true_type {};
MAKE_CODE_TRAIT( has_to_string, std::declval<T>().toString() )
template<class T> std::string optionalToString(T* obj) { return compiled_if< has_to_string >(*obj, [&](auto&& obj) { return obj.toString(); }) *compiled_else ([&]{ return "toString not defined"; }); }
template<class T> struct has_const_begin { typedef char (&Yes)[1]; typedef char (&No)[2]; template<class U> static Yes test(U const * data, typename std::enable_if<std::is_same< typename U::const_iterator, decltype(data->begin()) >::value>::type * = 0); static No test(...); static const bool value = sizeof(Yes) == sizeof(has_const_begin::test((typename std::remove_reference<T>::type*)0)); };
template<class T> struct has_foo { typedef char (&Yes)[1]; typedef char (&No)[2]; template<class U> static Yes test(U * data, MyClass* arg1 = 0, typename std::enable_if<std::is_void< decltype(data->foo(*arg1, 1u)) >::value>::type * = 0); static No test(...); static const bool value = sizeof(Yes) == sizeof(has_foo::test((typename std::remove_reference<T>::type*)0)); };
struct Hello { std::string toString() { return "Hello"; } }; struct Generic {}; namespace { std::string toString() { return "toString not defined"; } template <typename T> class optionalToStringImpl : public T { public: std::string doToString() { // // return toString(); } }; } template <typename T> std::string optionalToString(T & obj) { optionalToStringImpl<T>* temp = reinterpret_cast<optionalToStringImpl<T>*>( &obj); return temp->doToString(); } int main(int argc, char *argv[]) { Hello helloObj; Generic genericObj; std::cout << optionalToString( helloObj) << std::endl; std::cout << optionalToString( genericObj) << std::endl; return 0; }
/** * @class : HAS_TYPEDEF * @brief : This macro will be used to check if a class has a particular * typedef or not. * @param typedef_name : Name of Typedef * @param name : Name of struct which is going to be run the test for * the given particular typedef specified in typedef_name */ template <typename T> \ struct name { \ typedef char yes[1]; \ typedef char no[2]; \ template <typename U> \ struct type_check; \ template <typename _1> \ static yes& chk(type_check<typename _1::typedef_name>*); \ template <typename> \ static no& chk(...); \ static bool const value = sizeof(chk<T>(0)) == sizeof(yes); \ }
/** * @class : HAS_MEM_FUNC * @brief : This macro will be used to check if a class has a particular * member function implemented in the public section or not. * @param func : Name of Member Function * @param name : Name of struct which is going to be run the test for * the given particular member function name specified in func * @param return_type: Return type of the member function * @param ellipsis(...) : Since this is macro should provide test case for every * possible member function we use variadic macros to cover all possibilities */ template <typename T> \ struct name { \ typedef return_type (T::*Sign)(__VA_ARGS__); \ typedef char yes[1]; \ typedef char no[2]; \ template <typename U, U> \ struct type_check; \ template <typename _1> \ static yes& chk(type_check<Sign, &_1::func>*); \ template <typename> \ static no& chk(...); \ static bool const value = sizeof(chk<T>(0)) == sizeof(yes); \ }
class A { public: typedef int check; void check_function() {} }; class B { public: void hello(int a, double b) {} void hello() {} }; HAS_MEM_FUNC(check_function, has_check_function, void, void); HAS_MEM_FUNC(hello, hello_check, void, int, double); HAS_MEM_FUNC(hello, hello_void_check, void, void); HAS_TYPEDEF(check, has_typedef_check); int main() { std::cout << "Check Function A:" << has_check_function<A>::value << std::endl; std::cout << "Check Function B:" << has_check_function<B>::value << std::endl; std::cout << "Hello Function A:" << hello_check<A>::value << std::endl; std::cout << "Hello Function B:" << hello_check<B>::value << std::endl; std::cout << "Hello void Function A:" << hello_void_check<A>::value << std::endl; std::cout << "Hello void Function B:" << hello_void_check<B>::value << std::endl; std::cout << "Check Typedef A:" << has_typedef_check<A>::value << std::endl; std::cout << "Check Typedef B:" << has_typedef_check<B>::value << std::endl; }
template <class T> struct has_foo { struct S { void foo(...); }; struct derived : S, T {}; template <typename V, V> struct W {}; template <typename X> char (&test(W<void (X::*)(), &X::foo> *))[1]; template <typename> char (&test(...))[2]; static const bool value = sizeof(test<derived>(0)) == 1; };
template <template <typename> class TypeChecker, typename Type> struct is_supported { struct supported {}; struct not_supported {}; template <typename Type_> static supported chk(typename std::decay<TypeChecker<Type_>>::type *); template <typename Type_> static not_supported chk(...); static constexpr bool value = std::is_same<decltype(chk<Type>(nullptr)),supported>::value; };
template <typename T> using has_foo = decltype(double(std::declval<T>().foo(std::declval<const char*>())));
struct struct1 { double foo(const char*); }; struct struct2 { int foo(const std::string &str); }; struct struct3 { float foo(...); }; struct struct4 { template <typename T> int foo(T t); }; struct struct5 { void foo(const char*); }; struct struct6 { std::string foo(const char*); }; struct struct7 { double foo( int *); }; struct struct8 { double bar(const char*); }; int main() { std::cout << std::boolalpha; std::cout << is_supported<has_foo, int >::value << std::endl; std::cout << is_supported<has_foo, double >::value << std::endl; std::cout << is_supported<has_foo, struct1>::value << std::endl; std::cout << is_supported<has_foo, struct2>::value << std::endl; std::cout << is_supported<has_foo, struct3>::value << std::endl; std::cout << is_supported<has_foo, struct4>::value << std::endl; std::cout << is_supported<has_foo, struct5>::value << std::endl; std::cout << is_supported<has_foo, struct6>::value << std::endl; std::cout << is_supported<has_foo, struct7>::value << std::endl; std::cout << is_supported<has_foo, struct8>::value << std::endl; return 0; }
template<typename T> T declval(void); struct fake_void { }; template<typename T> T &operator,(T &,fake_void); template<typename T> T const &operator,(T const &,fake_void); template<typename T> T volatile &operator,(T volatile &,fake_void); template<typename T> T const volatile &operator,(T const volatile &,fake_void); struct yes { char v[1]; }; struct no { char v[2]; }; template<bool> struct yes_no:yes{}; template<> struct yes_no<false>:no{}; template<typename T> struct has_awesome_member { template<typename U> static yes_no<(sizeof(( declval<U>().awesome_member(),fake_void() ))!=0)> check(int); template<typename> static no check(...); enum{value=sizeof(check<T>(0)) == sizeof(yes)}; }; struct foo { int awesome_member(void); }; struct bar { }; struct foo_void { void awesome_member(void); }; struct wrong_params { void awesome_member(int); }; static_assert(has_awesome_member<foo>::value,""); static_assert(!has_awesome_member<bar>::value,""); static_assert(has_awesome_member<foo_void>::value,""); static_assert(!has_awesome_member<wrong_params>::value,"");
struct A{}; struct B{ int foo(int a, int b);}; struct C{void foo(int a, int b);}; struct D{int foo();}; struct E: public B{}; template<typename...> using void_t = void; template<typename T, typename = void> struct Has_foo: std::false_type{}; template<typename T> struct Has_foo<T, void_t< std::enable_if_t< std::is_same< int, decltype(std::declval<T>().foo((int)0, (int)0)) >::value > >>: std::true_type{}; static_assert(not Has_foo<A>::value, "A does not have a foo"); static_assert(Has_foo<B>::value, "B has a foo"); static_assert(not Has_foo<C>::value, "C has a foo with the wrong return. "); static_assert(not Has_foo<D>::value, "D has a foo with the wrong arguments. "); static_assert(Has_foo<E>::value, "E has a foo since it inherits from B");
template <typename U, typename = void> struct hasToString : std::false_type { }; template <typename U> struct hasToString<U, typename std::enable_if<bool(sizeof(&U::toString))>::type > : std::true_type { };
HAS_MEM(bar) HAS_MEM_FUN_CALL(bar) struct test { void bar(int); void bar(double); void bar(int,double); template < typename T > typename std::enable_if< not std::is_integral<T>::value >::type bar(const T&, int=0){} template < typename T > typename std::enable_if< std::is_integral<T>::value >::type bar(const std::vector<T>&, T*){} template < typename T > int bar(const std::string&, int){} };
int main(int argc, const char * argv[]) { static_assert( has_mem_bar<test>::value , ""); static_assert( has_valid_mem_fun_call_bar<test(char const*,long)>::value , ""); static_assert( has_valid_mem_fun_call_bar<test(std::string&,long)>::value , ""); static_assert( has_valid_mem_fun_call_bar<test(std::vector<int>, int*)>::value , ""); static_assert( has_no_viable_mem_fun_call_bar<test(std::vector<double>, double*)>::value , ""); static_assert( has_valid_mem_fun_call_bar<test(int)>::value , ""); static_assert( std::is_same<void,result_of_mem_fun_call_bar<test(int)>::type>::value , ""); static_assert( has_valid_mem_fun_call_bar<test(int,double)>::value , ""); static_assert( not has_valid_mem_fun_call_bar<test(int,double,int)>::value , ""); static_assert( not has_ambiguous_mem_fun_call_bar<test(double)>::value , ""); static_assert( has_ambiguous_mem_fun_call_bar<test(unsigned)>::value , ""); static_assert( has_viable_mem_fun_call_bar<test(unsigned)>::value , ""); static_assert( has_viable_mem_fun_call_bar<test(int)>::value , ""); static_assert( has_no_viable_mem_fun_call_bar<test(void)>::value , ""); return 0; }
\ template < typename T > \ struct has_mem_ { \ struct yes {}; \ struct no {}; \ \ struct ambiguate_seed { char mem; }; \ template < typename U > struct ambiguate : U, ambiguate_seed {}; \ \ template < typename U, typename = decltype(&U::mem) > static constexpr no test(int); \ template < typename > static constexpr yes test(...); \ \ static bool constexpr value = std::is_same<decltype(test< ambiguate<T> >(0)),yes>::value ; \ typedef std::integral_constant<bool,value> type; \ }; \ template < typename Signature > \ struct has_valid_mem_fun_call_ \ template < typename T, typename... Args > \ struct has_valid_mem_fun_call_ { \ struct yes {}; \ struct no {}; \ \ template < typename U, bool = has_mem_ struct impl \ { \ template < typename V, typename = decltype(std::declval<V>().memfun(std::declval<Args>()...)) > \ struct test_result { using type = yes; }; \ \ template < typename V > static constexpr typename test_result<V>::type test(int); \ template < typename > static constexpr no test(...); \ \ static constexpr bool value = std::is_same<decltype(test<U>(0)),yes>::value; \ using type = std::integral_constant<bool, value>; \ }; \ \ template < typename U > \ struct impl<U,false> : std::false_type {}; \ \ static constexpr bool value = impl<T>::value; \ using type = std::integral_constant<bool, value>; \ }; \ \ template < typename Signature > \ struct has_ambiguous_mem_fun_call_ \ template < typename T, typename... Args > \ struct has_ambiguous_mem_fun_call_ { \ struct ambiguate_seed { void memfun(...); }; \ \ template < class U, bool = has_mem_ struct ambiguate : U, ambiguate_seed \ { \ using ambiguate_seed::memfun; \ using U::memfun; \ }; \ \ template < class U > \ struct ambiguate<U,false> : ambiguate_seed {}; \ \ static constexpr bool value = not has_valid_mem_fun_call_ using type = std::integral_constant<bool, value>; \ }; \ \ template < typename Signature > \ struct has_viable_mem_fun_call_ \ template < typename T, typename... Args > \ struct has_viable_mem_fun_call_ { \ static constexpr bool value = has_valid_mem_fun_call_ or has_ambiguous_mem_fun_call_ using type = std::integral_constant<bool, value>; \ }; \ \ template < typename Signature > \ struct has_no_viable_mem_fun_call_ \ template < typename T, typename... Args > \ struct has_no_viable_mem_fun_call_ { \ static constexpr bool value = not has_viable_mem_fun_call_ using type = std::integral_constant<bool, value>; \ }; \ \ template < typename Signature > \ struct result_of_mem_fun_call_ \ template < typename T, typename... Args > \ struct result_of_mem_fun_call_ { \ using type = decltype(std::declval<T>().memfun(std::declval<Args>()...)); \ };
template<class T> std::string optionalToString(T* x) { return fit::conditional( [](auto* obj) -> decltype(obj->toString()) { return obj->toString(); }, [](auto*) { return "toString not defined"; } )(x); }
FIT_STATIC_LAMBDA_FUNCTION(optionalToString) = fit::conditional( [](auto* obj) -> decltype(obj->toString(), std::string()) { return obj->toString(); }, [](auto*) -> std::string { return "toString not defined"; } );
struct withToString { template<class T> auto operator()(T* obj) const -> decltype(obj->toString(), std::string()) { return obj->toString(); } }; struct withoutToString { template<class T> std::string operator()(T*) const { return "toString not defined"; } }; FIT_STATIC_FUNCTION(optionalToString) = fit::conditional( withToString(), withoutToString() );
template<typename T> using toStringFn = decltype(std::declval<const T>().toString()); template <class T, toStringFn<T>* = nullptr> std::string optionalToString(const T* obj, int) { return obj->toString(); } template <class T> std::string optionalToString(const T* obj, long) { return "toString not defined"; } int main() { A* a; B* b; std::cout << optionalToString(a, 0) << std::endl; std::cout << optionalToString(b, 0) << std::endl; }
template <typename T> constexpr bool toStringExists(long) { return false; } template <typename T, toStringFn<T>* = nullptr> constexpr bool toStringExists(int) { return true; } int main() { A* a; B* b; std::cout << toStringExists<A>(0) << std::endl; std::cout << toStringExists<B>(0) << std::endl; }
struct Generic {}; struct HasMember { HasMember() : _a(1) {}; int _a; }; template <typename T> class S : public T { public: std::string foo (std::string b) { return foo2<T>(b,0); } protected: template <typename T> std::string foo2 (std::string b, decltype (T::_a)) { return b + std::to_string(T::_a); } template <typename T> std::string foo2 (std::string b, ...) { return b + "No"; } }; int main(int argc, char *argv[]) { S<HasMember> d1; S<Generic> d2; std::cout << d1.foo("HasMember: ") << std::endl; std::cout << d2.foo("Generic: ") << std::endl; return 0; }
void some_func() { std::string s = "example string"; std::replace( s.begin(), s.end(), }
std::string in_place = "blah boost::replace_all(in_place, " const std::string input = "blah std::string output = boost::replace_all_copy(input, "
std::string ReplaceAll(std::string str, const std::string& from, const std::string& to) { size_t start_pos = 0; while((start_pos = str.find(from, start_pos)) != std::string::npos) { str.replace(start_pos, from.length(), to); start_pos += to.length(); } return str; }
std::cout << ReplaceAll(string("Number Of Beans"), std::string(" "), std::string("_")) << std::endl; std::cout << ReplaceAll(string("ghghjghugtghty"), std::string("gh"), std::string("X")) << std::endl; std::cout << ReplaceAll(string("ghghjghugtghty"), std::string("gh"), std::string("h")) << std::endl;
static inline void ReplaceAll2(std::string &str, const std::string& from, const std::string& to) { }
void replaceAll(std::string& source, const std::string& from, const std::string& to) { std::string newString; newString.reserve(source.length()); std::string::size_type lastPos = 0; std::string::size_type findPos; while(std::string::npos != (findPos = source.find(from, lastPos))) { newString.append(source, lastPos, findPos - lastPos); newString += to; lastPos = findPos + from.length(); } newString += source.substr(lastPos); source.swap(newString); }
while(sHaystack.find(sNeedle) != std::string::npos) { sHaystack.replace(sHaystack.find(sNeedle),sNeedle.size(),sReplace); }
using namespace std; string replace(string word, string target, string replacement){ int len, loop=0; string nword="", let; len=word.length(); len--; while(loop<=len){ let=word.substr(loop, 1); if(let==target){ nword=nword+replacement; }else{ nword=nword+let; } loop++; } return nword; } int main() { string word; cout<<"Enter Word: "; cin>>word; cout<<replace(word, "x", "y")<<endl; return 0; }
using namespace std; int main() { int count = 0; string holdWord = ""; string holdTemp = ""; string holdLetter = "Big Java 7th Ed,Horstman,978-1118431115,99.85"; for (int j = 0; j < holdLetter.length(); j++) { if (holdLetter[j] == if ( count == 0 ) { holdWord = holdLetter.replace(j, 1, " | "); } else { string holdTemp1 = holdLetter.replace(j, 1, " | "); holdTemp = holdTemp1.replace(0, j-3, holdWord, 0, j-3); holdWord = ""; holdWord = holdTemp; } holdTemp = ""; count++; } } cout << holdWord << endl; return 0; } Big Java 7th Ed | Horstman | 978-1118431115 | 99.85
g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4) Copyright (C) 2015 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
std::string strsub(std::string stringToModify, std::string charsToReplace, std::string replacementChars); int main() { std::string silly_typos = "annoiiyyyng syyyllii tiipos."; std::cout << "Look at these " << silly_typos << std::endl; silly_typos = strsub(silly_typos, "yyy", "i"); std::cout << "After a little elbow-grease, a few less " << silly_typos << std::endl; silly_typos = strsub(silly_typos, "ii", "y"); std::cout << "There, no more " << silly_typos << std::endl; return 0; } std::string strsub(std::string stringToModify, std::string charsToReplace, std::string replacementChars) { std::string this_string = stringToModify; std::size_t this_occurrence = this_string.find(charsToReplace); while (this_occurrence != std::string::npos) { this_string.erase(this_occurrence, charsToReplace.size()); this_string.insert(this_occurrence, replacementChars); this_occurrence = this_string.find(charsToReplace, this_occurrence + replacementChars.size()); } return this_string; }
std::string strsub(const char * stringToModify, const char * charsToReplace, const char * replacementChars, uint64_t sizeOfCharsToReplace, uint64_t sizeOfReplacementChars); int main() { std::string silly_typos = "annoiiyyyng syyyllii tiipos."; std::cout << "Look at these " << silly_typos << std::endl; silly_typos = strsub(silly_typos.c_str(), "yyy", "i", 3, 1); std::cout << "After a little elbow-grease, a few less " << silly_typos << std::endl; silly_typos = strsub(silly_typos.c_str(), "ii", "y", 2, 1); std::cout << "There, no more " << silly_typos << std::endl; return 0; } std::string strsub(const char * stringToModify, const char * charsToReplace, const char * replacementChars, uint64_t sizeOfCharsToReplace, uint64_t sizeOfReplacementChars) { std::string this_string = stringToModify; std::size_t this_occurrence = this_string.find(charsToReplace); while (this_occurrence != std::string::npos) { this_string.erase(this_occurrence, sizeOfCharsToReplace); this_string.insert(this_occurrence, replacementChars); this_occurrence = this_string.find(charsToReplace, this_occurrence + sizeOfReplacementChars); } return this_string; }
for (size_t i = 0; i < some_string.size(); ++i) { if (some_string[i] == some_string.replace(i, 1, "b"); } }
string pth = "H:/recursos/audio/youtube/libre/falta/"; for(int i=0 ;i<=pth.size(); i++) if(pth[i]== pth[i]= cout<<pth;
class foo { public: template <typename T> void do(const T& t); };
template <typename T> void foo::do(const T& t) { } template void foo::do<int>(const int&); template void foo::do<std::string>(const std::string&);
template <class T> void foo<T>::bar(const T &t) { } template class foo<int>;
template <typename T> class foo { public: void bar(const T& t); };
template <typename T> void foo::bar(const T& t) { }
int* p_scalar = new int(5); int* p_array = new int[5];
struct foo { double d[5]; }; int main() { foo *f1 = malloc(1); foo *f2 = static_cast<foo*>(malloc(sizeof(foo))); foo *f3 = static_cast<foo*>(malloc(1)); }
foo *safe_foo_malloc() { static_assert(std::is_pod<foo>::value, "foo must be POD"); return static_cast<foo*>(malloc(sizeof(foo))); }
void my_malloc_failed_handler(); foo *safe_foo_malloc() { static_assert(std::is_pod<foo>::value, "foo must be POD"); foo *mem = static_cast<foo*>(malloc(sizeof(foo))); if (!mem) { my_malloc_failed_handler(); } return mem; }
void my_malloc_failed_handler(); foo *safe_foo_malloc() { void *mem = malloc(sizeof(foo)); if (!mem) { my_malloc_failed_handler(); } return new (mem)foo(); }
void my_malloc_failed_handler(); template <typename T> struct alloc { template <typename ...Args> static T *safe_malloc(Args&&... args) { void *mem = malloc(sizeof(T)); if (!mem) { my_malloc_failed_handler(); } return new (mem)T(std::forward(args)...); } };
void *p = operator new(size); ... operator delete(p);
non_pod_type* p = (non_pod_type*) malloc(sizeof *p);
pod_type* p = (pod_type*) malloc(sizeof *p); std::cout << p->foo;
std::unique_ptr<T> p = std::unique_ptr<T>(new T());
struct test_s { int some_strange_name = 1; int &easy = some_strange_name; }
std::vector<int> *createVector(); std::vector<int> createVector(); auto v = new std::vector<int>(); auto result = calculate( v); auto v = std::vector<int>(); auto result = calculate( &v);
auto instance = std::make_unique<Class>( ); auto instance = std::make_unique<Class>(new Class( )); auto instance = std::make_unique<Class[]>(42); auto instance = std::make_unique<Class[]>(new Class[](42));
auto optInstance = std::optional<Class>{}; if (condition) optInstance = Class{};
auto vector = std::vector<std::unique_ptr<Interface>>{}; auto instance = std::make_unique<Class>(); vector.push_back(std::move(instance));
auto instance = std::make_unique<Class>(); legacyFunction(instance.release()); auto instance = std::unique_ptr<Class>{legacyFunction()};
auto instance = new Class(); delete instance; auto instances = new Class[42](); delete[] instances;
auto instanceBlob = std::malloc(sizeof(Class)); auto instance = new(instanceBlob)Class{}; instance.~Class(); std::free(instanceBlob);
class B { private: B *ptr; int x; public: B(int n) { cout<<"B: ctr"<<endl; ptr = (B *)malloc(sizeof(B)); x = n; ptr->x = n + 10; } ~B() { free(ptr); cout<<"B: dtr"<<endl; } };
class Test { int x; }; int main() { Test t; t.x = 20; getchar(); return 0; } Run on IDE struct Test { int x; }; int main() { Test t; t.x = 20; getchar(); return 0; }
class Base { public: int x; }; class Derived : Base { }; int main() { Derived d; d.x = 20; getchar(); return 0; } Run on IDE class Base { public: int x; }; struct Derived : Base { }; int main() { Derived d; d.x = 20; getchar(); return 0; }
class A{ public: int i; }; class A2:A{ }; struct A3:A{ }; struct abc{ int i; }; struct abc2:abc{ }; class abc3:abc{ }; int _tmain(int argc, _TCHAR* argv[]) { abc2 objabc; objabc.i = 10; A3 ob; ob.i = 10; }
Static Public void Main (string[] arg) { MyClass _myClassObject1 = new MyClass(); _myClassObject1.DataMember = 10; MyClass _myClassObject2 = _myClassObject1; _myClassObject2.DataMember=20; }
Structure MyStructure { Public Int DataMember; } Static Public void Main (string[] arg) { MyStructure _myStructObject1 = new MyStructure(); _myStructObject1.DataMember = 10; MyStructure _myStructObject2 = _myStructObject1; _myStructObject2.DataMember = 20; }
struct Foo { int a; }; class Bar { int a; }; class Tester { Foo m_Foo = Foo(); Bar m_Bar = Bar(); public: Tester() {} }; int main() { auto myTester = Tester(); }
$$:~/static [32]> cat foo.c void foo() { printf("\nhello world\n"); } $$:~/static [33]> cat foo.h void foo(); $$:~/static [34]> cat foo2.c void foo2() { printf("\nworld\n"); } $$:~/static [35]> cat foo2.h void foo2(); $$:~/static [36]> cat hello.c void main() { foo(); foo2(); } $$:~/static [37]> cat makefile hello: hello.o libtest.a cc -o hello hello.o -L. -ltest hello.o: hello.c cc -c hello.c -I`pwd` libtest.a:foo.o foo2.o ar cr libtest.a foo.o foo2.o foo.o:foo.c cc -c foo.c foo2.o:foo.c cc -c foo2.c clean: rm -f foo.o foo2.o libtest.a hello.o $$:~/static [38]>
$$:~/dynamic [44]> cat foo.c void foo() { printf("\nhello world\n"); } $$:~/dynamic [45]> cat foo.h void foo(); $$:~/dynamic [46]> cat foo2.c void foo2() { printf("\nworld\n"); } $$:~/dynamic [47]> cat foo2.h void foo2(); $$:~/dynamic [48]> cat hello.c void main() { foo(); foo2(); } $$:~/dynamic [49]> cat makefile hello:hello.o libtest.sl cc -o hello hello.o -L`pwd` -ltest hello.o: cc -c -b hello.c -I`pwd` libtest.sl:foo.o foo2.o cc -G -b -o libtest.sl foo.o foo2.o foo.o:foo.c cc -c -b foo.c foo2.o:foo.c cc -c -b foo2.c clean: rm -f libtest.sl foo.o foo 2.o hello.o $$:~/dynamic [50]>
class A { private: static const string RECTANGLE = "rectangle"; }
class A { private: static const string RECTANGLE; };
class A { private: static constexpr const char* STRING = "some useful string constant"; };
class A { static const char RECTANGLE[]; }; const char A::RECTANGLE[] = "rectangle";
class foo { public: static const std::string& RECTANGLE(void) { static const std::string str = "rectangle"; return str; } };
class A { private: static inline const std::string my_string = "some useful string constant"; };
static const std::string RECTANGLE() const { return "rectangle"; }
class A{ static string s; public: static string getS(); }; string A::s; namespace{ bool init_A_s(){ A::s = string("foo"); return true; } bool A_s_initialized = init_A_s(); } string A::getS(){ if (!A_s_initialized) A_s_initialized = init_A_s(); return s; }
class A { private: static struct _Shapes { const std::string RECTANGLE {"rectangle"}; const std::string CIRCLE {"circle"}; } shape; };
class File { public: static struct _Extensions { const std::string h{ ".h" }; const std::string hpp{ ".hpp" }; const std::string c{ ".c" }; const std::string cpp{ ".cpp" }; } extension; }; File::_Extensions File::extension; static std::set<std::string> headers{ File::extension.h, File::extension.hpp };
class A { public: static constexpr const char* STRING = "some value"; }; void foo(const std::string& bar); int main() { foo(A::STRING); }
using namespace std::literals; namespace STANDARD { constexpr inline auto compiletime_static_string_view_constant() { auto when_needed_ = "compile time"sv; return when_needed_ ; }
auto return_by_val = []() { auto return_by_val = []() { auto return_by_val = []() { auto return_by_val = []() { return STANDARD::compiletime_static_string_view_constant(); }; return return_by_val(); }; return return_by_val(); }; return return_by_val(); }; _ASSERTE(return_by_val() == "compile time"); static_assert( STANDARD::compiletime_static_string_view_constant() == "compile time" );
void foo(int x) { try { bar(); x = 5; } catch(...) { } baz(x); }
double compute(double x) noexcept; { string s = "Courtney and Anya"; vector<double> tmp(10); }
int* a = new int(); void* b = static_cast<void*>(a); int* c = static_cast<int*>(b);
int* a = new int(); void* b = reinterpret_cast<void*>(a); int* c = reinterpret_cast<int*>(b);
typedef struct _Opaque * VendorGlobalUserData; void VendorSetUserData(VendorGlobalUserData p); VendorGlobalUserData VendorGetUserData();
using namespace std; struct MyUserData { MyUserData() : m(42) {} int m; }; int main() { MyUserData u; VendorGlobalUserData d1; d1 = reinterpret_cast<VendorGlobalUserData>(&u); VendorSetUserData(d1); VendorGlobalUserData d2 = VendorGetUserData(); MyUserData * p = 0; p = reinterpret_cast<MyUserData *>(d2); if (p) { cout << p->m << endl; } return 0; }
static VendorGlobalUserData g = 0; void VendorSetUserData(VendorGlobalUserData p) { g = p; } VendorGlobalUserData VendorGetUserData() { return g; }
constexpr bool is_little_endian() { std::uint16_t x=0x0001; auto p = reinterpret_cast<std::uint8_t*>(&x); return *p != 0; }
float Q_rsqrt( float number ) { long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = * ( long * ) &y; i = 0x5f3759df - ( i >> 1 ); y = * ( float * ) &i; y = y * ( threehalfs - ( x2 * y * y ) ); return y; }
template <class outType, class inType> outType safe_cast(inType pointer) { void* temp = static_cast<void*>(pointer); return static_cast<outType>(temp); }
/* Define _USE_MATH_DEFINES before including math.h to expose these macro * definitions for common math constants. These are placed under an * since these commonly-defined names are not part of the C/C++ standards. */
const double pi = boost::math::constants::pi<double>();
double get_PI() { double pi; __asm { fldpi fstp pi } return pi; } double PI = get_PI();
const double PI =3.141592653589793238463; const float PI_F=3.14159265358979f;
The <math.h> header shall provide for the following constants. The values are of type double and are accurate within the precision of the double type. M_PI Value of pi M_PI_2 Value of pi/2 M_PI_4 Value of pi/4 M_1_PI Value of 1/pi M_2_PI Value of 2/pi M_2_SQRTPI Value of 2/ sqrt pi
template<typename T> T const pi = std::acos(-T(1));
template<typename T> T const pi = std::arg(-std::log(T(2)));
template<typename T> T const pi = static_cast<T>( );
template<typename T> constexpr T pi = T(3.1415926535897932385);
template<typename T> T circular_area(T r) { return pi<T> * r * r; } double darea= circular_area(5.5); float farea= circular_area(5.5f);
template<typename RATIO> constexpr double dpipart() { long double const pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899863; return static_cast<double>(pi * RATIO::num / RATIO::den); } int main() { std::cout << dpipart<std::ratio<-1, 6>>() << std::endl; }
String str = "The quick brown fox"; String[] results = str.split(" ");
using namespace std; using namespace boost; int main(int, char**) { string text = "token, test string"; char_separator<char> sep(", "); tokenizer< char_separator<char> > tokens(text, sep); BOOST_FOREACH (const string& t, tokens) { cout << t << "." << endl; } }
using namespace std; using namespace boost; int main(int, char**) { string text = "token, test string"; char_separator<char> sep(", "); tokenizer<char_separator<char>> tokens(text, sep); for (const auto& t : tokens) { cout << t << "." << endl; } }
using namespace std; vector<string> split(const char *str, char c = { vector<string> result; do { const char *begin = str; while(*str != c && *str) str++; result.push_back(string(begin, str)); } while (0 != *str++); return result; }
char myString[] = "The quick brown fox"; char *p = strtok(myString, " "); while (p) { printf ("Token: %s\n", p); p = strtok(NULL, " "); }
stringstream ss("bla bla"); string s; while (getline(ss, s, cout << s << endl; }
int main() { std::string str = "The quick brown fox"; std::stringstream strstr(str); std::istream_iterator<std::string> it(strstr); std::istream_iterator<std::string> end; std::vector<std::string> results(it, end); std::ostream_iterator<std::string> oit(std::cout); std::copy(results.begin(), results.end(), oit); }
void split( vector<string> & theStringVector, /* Altered/returned value */ const string & theString, const string & theDelimiter) { UASSERT( theDelimiter.size(), >, 0); size_t start = 0, end = 0; while ( end != string::npos) { end = theString.find( theDelimiter, start); theStringVector.push_back( theString.substr( start, (end == string::npos) ? string::npos : end - start)); start = ( ( end > (string::npos - theDelimiter.size()) ) ? string::npos : end + theDelimiter.size()); } }
int main() { vector<string> v; split( v, "A:PEP:909:Inventory Item", ":" ); for (unsigned int i = 0; i < v.size(); i++) SHOW( i, v[i] ); }
int main() { auto s = "a,b, c ,,e,f,"; std::vector<std::string> fields; boost::split(fields, s, boost::is_any_of(",")); for (const auto& field : fields) std::cout << "\"" << field << "\"\n"; return 0; }
using namespace std; int main() { string str("The quick brown fox"); regex reg("\\s+"); sregex_token_iterator iter(str.begin(), str.end(), reg, -1); sregex_token_iterator end; vector<string> vec(iter, end); for (auto a : vec) { cout << a << endl; } }
... QString str = "The quick brown fox"; QStringList results = str.split(" ");
class Tokenizer { public: static const std::string DELIMITERS; Tokenizer(const std::string& str); Tokenizer(const std::string& str, const std::string& delimiters); bool NextToken(); bool NextToken(const std::string& delimiters); const std::string GetToken() const; void Reset(); protected: size_t m_offset; const std::string m_string; std::string m_token; std::string m_delimiters; }; const std::string Tokenizer::DELIMITERS(" \t\n\r"); Tokenizer::Tokenizer(const std::string& s) : m_string(s), m_offset(0), m_delimiters(DELIMITERS) {} Tokenizer::Tokenizer(const std::string& s, const std::string& delimiters) : m_string(s), m_offset(0), m_delimiters(delimiters) {} bool Tokenizer::NextToken() { return NextToken(m_delimiters); } bool Tokenizer::NextToken(const std::string& delimiters) { size_t i = m_string.find_first_not_of(delimiters, m_offset); if (std::string::npos == i) { m_offset = m_string.length(); return false; } size_t j = m_string.find_first_of(delimiters, i); if (std::string::npos == j) { m_token = m_string.substr(i); m_offset = m_string.length(); return true; } m_token = m_string.substr(i, j - i); m_offset = j; return true; }
std::vector <std::string> v; Tokenizer s("split this string", " "); while (s.NextToken()) { v.push_back(s.GetToken()); }
void tokenize(std::string str, std::vector<string> &token_v){ size_t start = str.find_first_not_of(DELIMITER), end=start; while (start != std::string::npos){ end = str.find(DELIMITER, start); token_v.push_back(str.substr(start, end-start)); start = str.find_first_not_of(DELIMITER, end); } }
std::vector<std::string> chunks; pystring::split("this string", chunks); pystring::split("this-string", chunks, "-");
const char *whitespace = " \t\r\n\f"; const char *whitespace_and_punctuation = " \t\r\n\f;,="; int main() { { std::string s("Somewhere down the road"); std::vector<std::string> result; if( strtk::parse( s, whitespace, result ) ) { for(size_t i = 0; i < result.size(); ++i ) std::cout << result[i] << std::endl; } } { std::string t("3.0, 3.14; 4.0"); std::vector<float> values; if( strtk::parse( s, whitespace_and_punctuation, values ) ) { for(size_t i = 0; i < values.size(); ++i ) std::cout << values[i] << std::endl; } } { std::string u("angle = 45; radius = 9.9"); std::string w1, w2; float v1, v2; if( strtk::parse( s, whitespace_and_punctuation, w1, v1, w2, v2) ) { std::cout << "word " << w1 << ", value " << v1 << std::endl; std::cout << "word " << w2 << ", value " << v2 << std::endl; } } return 0; }
using namespace std; int main () { string tmps; istringstream is ("the dellimiter is the space"); while (is.good ()) { is >> tmps; cout << tmps << "\n"; } return 0; }
unsigned TokenizeString(const std::string& i_source, const std::string& i_seperators, bool i_discard_empty_tokens, std::vector<std::string>& o_tokens) { unsigned prev_pos = 0; unsigned pos = 0; unsigned number_of_tokens = 0; o_tokens.clear(); pos = i_source.find_first_of(i_seperators, pos); while (pos != std::string::npos) { std::string token = i_source.substr(prev_pos, pos - prev_pos); if (!i_discard_empty_tokens || token != "") { o_tokens.push_back(i_source.substr(prev_pos, pos - prev_pos)); number_of_tokens++; } pos++; prev_pos = pos; pos = i_source.find_first_of(i_seperators, pos); } if (prev_pos < i_source.length()) { o_tokens.push_back(i_source.substr(prev_pos)); number_of_tokens++; } return number_of_tokens; }
CAtlString str( "%First Second CAtlString resToken; int curPos= 0; resToken= str.Tokenize("% while (resToken != "") { printf("Resulting token: %s\n", resToken); resToken= str.Tokenize("% }; Output Resulting Token: First Resulting Token: Second Resulting Token: Third
using namespace std; string someText = ... string::size_type tokenOff = 0, sepOff = tokenOff; while (sepOff != string::npos) { sepOff = someText.find( string::size_type tokenLen = (sepOff == string::npos) ? sepOff : sepOff++ - tokenOff; string token = someText.substr(tokenOff, tokenLen); if (!token.empty()) ; tokenOff = sepOff; }
auto start = find(cbegin(str), cend(str), vector<string> tokens{ string(cbegin(str), start) }; while (start != cend(str)) { const auto finish = find(++start, cend(str), tokens.push_back(string(start, finish)); start = finish; }
vector<string> tokens; for (auto i = strtok(data(str), " "); i != nullptr; i = strtok(nullptr, " ")) tokens.push_back(i);
istringstream is{ str }; const vector<string> tokens{ istream_iterator<string>(is), istream_iterator<string>() };
const regex re{ "\\s*((?:[^\\\\,]|\\\\.)*?)\\s*(?:,|$)" }; const vector<string> tokens{ sregex_token_iterator(cbegin(str), cend(str), re, 1), sregex_token_iterator() };
std::vector<std::string> split(std::string::const_iterator it, std::string::const_iterator end, std::regex e = std::regex{"\\w+"}){ std::smatch m{}; std::vector<std::string> ret{}; while (std::regex_search (it,end,m,e)) { ret.emplace_back(m.str()); std::advance(it, m.position() + m.length()); } return ret; } std::vector<std::string> split(const std::string &s, std::regex e = std::regex{"\\w+"}){ return split(s.cbegin(), s.cend(), std::move(e)); } int main () { std::string str {"Some people, excluding those present, have been compile time constants - since puberty."}; auto v = split(str); for(const auto&s:v){ std::cout << s << std::endl; } std::cout << "crazy version:" << std::endl; v = split(str, std::regex{"[^e]+"}); for(const auto&s:v){ std::cout << s << std::endl; } return 0; }
template<bool...> struct BoolSequence{}; template<char...> struct CharSequence{}; template<typename T, char C> struct Contains; template<char First, char... Cs, char Match> struct Contains<CharSequence<First, Cs...>,Match> : Contains<CharSequence<Cs...>, Match>{}; template<char First, char... Cs> struct Contains<CharSequence<First, Cs...>,First>: std::true_type {}; template<char Match> struct Contains<CharSequence<>,Match>: std::false_type{}; template<int I, typename T, typename U> struct MakeSequence; template<int I, bool... Bs, typename U> struct MakeSequence<I,BoolSequence<Bs...>, U>: MakeSequence<I-1, BoolSequence<Contains<U,I-1>::value,Bs...>, U>{}; template<bool... Bs, typename U> struct MakeSequence<0,BoolSequence<Bs...>,U>{ using Type = BoolSequence<Bs...>; }; template<typename T> struct BoolASCIITable; template<bool... Bs> struct BoolASCIITable<BoolSequence<Bs...>>{ static bool isDelim(const char c){ static const bool table[256] = {Bs...}; return table[static_cast<int>(c)]; } }; using Delims = CharSequence< using Table = BoolASCIITable<typename MakeSequence<256,BoolSequence<>,Delims>::Type>;
template<typename T_It> std::pair<T_It,T_It> getNextToken(T_It begin,T_It end){ begin = std::find_if(begin,end,std::not1(Table{})); auto second = std::find_if(begin,end,Table{}); return std::make_pair(begin,second); }
int main() { std::string s{"Some people, excluding those present, have been compile time constants - since puberty."}; auto it = std::begin(s); auto end = std::end(s); while(it != std::end(s)){ auto token = getNextToken(it,end); std::cout << std::string(token.first,token.second) << std::endl; it = token.second; } return 0; }
template<typename CH> inline vector< basic_string<CH> > tokenize( const basic_string<CH> &Input, const basic_string<CH> &Delimiter, bool remove_empty_token ) { typedef typename basic_string<CH>::const_iterator string_iterator_t; typedef boost::find_iterator< string_iterator_t > string_find_iterator_t; vector< basic_string<CH> > Result; string_iterator_t it = Input.begin(); string_iterator_t it_end = Input.end(); for(string_find_iterator_t i = boost::make_find_iterator(Input, boost::first_finder(Delimiter, boost::is_equal())); i != string_find_iterator_t(); ++i) { if(remove_empty_token){ if(it != i->begin()) Result.push_back(basic_string<CH>(it,i->begin())); } else Result.push_back(basic_string<CH>(it,i->begin())); it = i->end(); } if(it != it_end) Result.push_back(basic_string<CH>(it,it_end)); return Result; }
vector<string> get_words(string const& text) { vector<string> result; string tmp = text; size_t first_pos = 0; size_t second_pos = tmp.find(" ");; while (second_pos != string::npos) { if (first_pos != second_pos) { string word = tmp.substr(first_pos, second_pos - first_pos); result.push_back(word); } tmp = tmp.substr(second_pos + 1); second_pos = tmp.find(" "); } return result; }
class TextLineSplitter { public: TextLineSplitter( const size_t max_line_len ); ~TextLineSplitter(); void SplitLine( const char *line, const char sep_char = ); inline size_t NumTokens( void ) const { return mNumTokens; } const char * GetToken( const size_t token_idx ) const { assert( token_idx < mNumTokens ); return mTokens[ token_idx ]; } private: const size_t mStorageSize; char *mBuff; char **mTokens; size_t mNumTokens; inline void ResetContent( void ) { memset( mBuff, 0, mStorageSize ); memset( mTokens, 0, mStorageSize * sizeof( char* ) ); mNumTokens = 0L; } };
TextLineSplitter::TextLineSplitter( const size_t max_line_len ): mStorageSize ( max_line_len + 1L ) { mBuff = new char [ mStorageSize ]; mTokens = new char* [ mStorageSize ]; ResetContent(); } TextLineSplitter::~TextLineSplitter() { delete [] mBuff; delete [] mTokens; } void TextLineSplitter::SplitLine( const char *line, const char sep_char , ) { assert( sep_char != ResetContent(); strncpy( mBuff, line, mMaxLineLen ); size_t idx = 0L; do { assert( idx < mStorageSize ); const char chr = line[ idx ]; if( mTokens[ mNumTokens ] == NULL ) { mTokens[ mNumTokens ] = &mBuff[ idx ]; } if( chr == sep_char || chr == { mBuff[ idx ] = mNumTokens ++; } } while( line[ idx++ ] ); }
TextLineSplitter spl( 1000 ); spl.SplitLine( "Item1,,Item2,Item3" ); for( size_t i = 0; i < spl.NumTokens(); i++ ) { printf( "%s\n", spl.GetToken( i ) ); }
using namespace std; using namespace boost; typedef tokenizer<char_separator<wchar_t>, wstring::const_iterator, wstring> Tok; int main() { wstring s; while (getline(wcin, s)) { char_separator<wchar_t> sep(L" "); Tok tok(s, sep); for (Tok::iterator beg = tok.begin(); beg != tok.end(); ++beg) { wcout << *beg << L"\t"; } wcout << L"\n"; } return 0; }
std::vector<std::string> split(const std::string& str, const std::string& delim){ std::vector<std::string> result; if (str.empty()) throw std::runtime_error("Can not tokenize an empty string!"); std::string::const_iterator begin, str_it; begin = str_it = str.begin(); do { while (delim.find(*str_it) == std::string::npos && str_it != str.end()) str_it++; std::string token = std::string(begin, str_it); if (!token.empty()) result.push_back(token); while (delim.find(*str_it) != std::string::npos && str_it != str.end()) str_it++; begin = str_it; } while (str_it != str.end()); return result; } int main() { std::string test_string = ".this is.a.../.simple;;test;;;END"; std::string delim = "; ./"; std::vector<std::string> tokens = split(test_string, delim); for (std::vector<std::string>::const_iterator it = tokens.begin(); it != tokens.end(); it++) std::cout << *it << std::endl; }
char destBuffer[16]; void Serialize(bool boolValue) { const char* whichString = boolValue ? "true" : "false"; const size_t len = strlen(whichString); memcpy(destBuffer, whichString, len); }
struct FStruct { bool uninitializedBool; __attribute__ ((noinline)) FStruct() {}; }; char destBuffer[16]; void Serialize(bool boolValue) { const char* whichString = boolValue ? "true" : "false"; size_t len = strlen(whichString); memcpy(destBuffer, whichString, len); } int main() { FStruct structInstance; Serialize(structInstance.uninitializedBool); return 0; }
const size_t len = strlen(whichString); const size_t len = 5 - boolValue;
const static char *strings[] = {"false", "true"}; const char *whichString = strings[boolValue];
template < template < typename, typename > class Container, typename Type > class Example { Container< Type, std::allocator < Type > > baz; };
template<typename param_t> class Foo { typedef typename param_t::baz sub_t; };
template < template < typename, typename > class Container, typename Type >
template <typename T, U> T calc(const T&, const U&);
template <typename T, class U> calc (const T&, const U&);
using namespace std; using namespace boost::assign; map<int, char> m = map_list_of (1,
using namespace std; map<int,int> create_map() { map<int,int> m; m[1] = 2; m[3] = 4; m[5] = 6; return m; } map<int,int> m = create_map();
template <typename T, typename U> class create_map { private: std::map<T, U> m_map; public: create_map(const T& key, const U& val) { m_map[key] = val; } create_map<T, U>& operator()(const T& key, const U& val) { m_map[key] = val; return *this; } operator std::map<T, U>() { return m_map; } };
template <typename MapType> class map_add_values { private: MapType mMap; public: typedef typename MapType::key_type KeyType; typedef typename MapType::mapped_type MappedType; map_add_values(const KeyType& key, const MappedType& val) { mMap[key] = val; } map_add_values& operator()(const KeyType& key, const MappedType& val) { mMap[key] = val; return *this; } void to (MapType& map) { map.insert(mMap.begin(), mMap.end()); } };
typedef std::map<int, int> Int2IntMap; Int2IntMap testMap; map_add_values<Int2IntMap>(1,2)(3,4)(5,6).to(testMap);
template<typename T, typename U> class map_add_values { private: std::map<T,U>& m_map; public: map_add_values(std::map<T, U>& _map):m_map(_map){} map_add_values& operator()(const T& _key, const U& _val) { m_map[key] = val; return *this; } };
typedef std::map<std::string, int> MyMap; const MyMap::value_type rawData[] = { MyMap::value_type("hello", 42), MyMap::value_type("world", 88), }; const int numElems = sizeof rawData / sizeof rawData[0]; MyMap myMap(rawData, rawData + numElems);
const MyMap myMap = { {"hello", 42}, {"world", 88} };
std::map<std::string, std::string> aka; struct akaInit { akaInit() { aka[ "George" ] = "John"; aka[ "Joe" ] = "Al"; aka[ "Phil" ] = "Sue"; aka[ "Smitty" ] = "Yando"; } } AkaInit;
std::map <int, int> mymap = { std::pair <int, int> (1, 1), std::pair <int, int> (2, 2), std::pair <int, int> (2, 2) };
const std::map<LoggerLevel, const char*> g_logLevelsDescriptions = { { LoggerLevel::llNothing, "Logging disabled" }, { LoggerLevel::llInfo, "Base information" }, { LoggerLevel::llWarn, "Warnings" }, { LoggerLevel::llError, "Errors" }, { LoggerLevel::llDebug, "All information: debug-mode" } };
using namespace std; bool create_map(map<int,int> &m) { m[1] = 2; m[3] = 4; m[5] = 6; return true; } static map<int,int> m; static bool _dummy = create_map (m);
typedef std::pair< int, char > elemPair_t; elemPair_t elemPairs[] = { elemPair_t( 1, elemPair_t( 3, elemPair_t( 5, elemPair_t( 7, }; const std::map< int, char > myMap( &elemPairs[ 0 ], &elemPairs[ sizeof( elemPairs ) / sizeof( elemPairs[ 0 ] ) ] );
template<bool V> struct answer { answer(int) {} bool operator()(){return V;}}; template<bool no, bool yes, int f, int p> struct IsPrimeHelper : IsPrimeHelper<p % f == 0, f * f >= p, f + 2, p> {}; template<bool yes, int f, int p> struct IsPrimeHelper<true, yes, f, p> { using type = answer<false>; }; template<int f, int p> struct IsPrimeHelper<false, true, f, p> { using type = answer<true>; }; template<int I> using IsPrime = typename IsPrimeHelper<!(I&1), false, 3, I>::type; template<int I> struct X { static const int i = I; int a[i]; }; template<typename A> struct foo; template<>struct foo<answer<true>>{ template<int I> using typen = X<I>; }; template<> struct foo<answer<false>>{ static const int typen = 0; }; int main() { auto b = foo<IsPrime<234799>>::typen<1>(); return 0; }
template<bool B> class foo { }; static const int foo = 0; static const int bar = 15;
A variable_decl ::= <type> <identifier> B function_decl ::= <type> <identifier> A ::= [declaration of X as value] B ::= [declaration of X as type]
967 tree nodes in tree. 15 ambiguity nodes in tree. (translation_unit@Cpp~GCC5=2 (declaration_seq@Cpp~GCC5=1021 (pp_declaration_seq@Cpp~GCC5=1022 (declaration@Cpp~GCC5=1036 |(template_declaration@Cpp~GCC5=2079 | (template_parameter_list@Cpp~GCC5=2082 | (template_parameter@Cpp~GCC5=2085 | (parameter_declaration@Cpp~GCC5=1611 | |(basic_decl_specifier_seq@Cpp~GCC5=1070 | | (decl_specifier@Cpp~GCC5=1073 | | (trailing_type_specifier@Cpp~GCC5=1118 | | (simple_type_specifier@Cpp~GCC5=1138 | | )trailing_type_specifier | | )decl_specifier | |)basic_decl_specifier_seq | |(ptr_declarator@Cpp~GCC5=1417 | | (noptr_declarator@Cpp~GCC5=1421 | | (declarator_id@Cpp~GCC5=1487 | | (id_expression@Cpp~GCC5=317 | | |(unqualified_id@Cpp~GCC5=319 | | | (IDENTIFIER@Cpp~GCC5=3368 | | |)unqualified_id | | )id_expression | | )declarator_id | | )noptr_declarator | |)ptr_declarator | )parameter_declaration | )template_parameter | )template_parameter_list | (declaration@Cpp~GCC5=1033 | (block_declaration@Cpp~GCC5=1050 | (simple_declaration@Cpp~GCC5=1060 | |(basic_decl_specifier_seq@Cpp~GCC5=1070 | | (decl_specifier@Cpp~GCC5=1073 | | (type_specifier@Cpp~GCC5=1110 | | (class_specifier@Cpp~GCC5=1761 | | |(class_head@Cpp~GCC5=1763 | | | (class_key@Cpp~GCC5=1791 | | | (IDENTIFIER@Cpp~GCC5=3368 | | | (optional_base_clause@Cpp~GCC5=1872 | | |)class_head | | |(member_specification@Cpp~GCC5=1794 | | | (member_declaration_or_access_specifier@Cpp~GCC5=1806 | | | (member_declaration@Cpp~GCC5=1822 | | | (function_definition@Cpp~GCC5=1632 | | | |(function_head@Cpp~GCC5=1673 | | | | (ptr_declarator@Cpp~GCC5=1417 | | | | (noptr_declarator@Cpp~GCC5=1422 | | | | (noptr_declarator@Cpp~GCC5=1421 | | | | |(declarator_id@Cpp~GCC5=1487 | | | | | (id_expression@Cpp~GCC5=317 | | | | | (unqualified_id@Cpp~GCC5=319 | | | | | (IDENTIFIER@Cpp~GCC5=3368 | | | | | )unqualified_id | | | | | )id_expression | | | | |)declarator_id | | | | )noptr_declarator | | | | (parameter_declaration_clause@Cpp~GCC5=1559 | | | | |(pp_parameter_declaration_list@Cpp~GCC5=1570 | | | | | (pp_parameter_declaration_seq@Cpp~GCC5=1574 | | | | | (parameter_declaration@Cpp~GCC5=1610 | | | | | (basic_decl_specifier_seq@Cpp~GCC5=1070 | | | | | |(decl_specifier@Cpp~GCC5=1073 | | | | | | (trailing_type_specifier@Cpp~GCC5=1118 | | | | | | (simple_type_specifier@Cpp~GCC5=1140 | | | | | | )trailing_type_specifier | | | | | |)decl_specifier | | | | | )basic_decl_specifier_seq | | | | | )parameter_declaration | | | | | )pp_parameter_declaration_seq | | | | |)pp_parameter_declaration_list | | | | )parameter_declaration_clause | | | | (function_qualifiers@Cpp~GCC5=1438 | | | | )noptr_declarator | | | | )ptr_declarator | | | |)function_head | | | |(function_body@Cpp~GCC5=1680 | | | | (compound_statement@Cpp~GCC5=888 | | | |)function_body | | | )function_definition | | | )member_declaration | | | )member_declaration_or_access_specifier | | | (member_declaration_or_access_specifier@Cpp~GCC5=1806 | | | (member_declaration@Cpp~GCC5=1822 | | | (function_definition@Cpp~GCC5=1632 | | | |(function_head@Cpp~GCC5=1674 | | | | (basic_decl_specifier_seq@Cpp~GCC5=1070 | | | | (decl_specifier@Cpp~GCC5=1073 | | | | (trailing_type_specifier@Cpp~GCC5=1118 | | | | |(simple_type_specifier@Cpp~GCC5=1138 | | | | )trailing_type_specifier | | | | )decl_specifier | | | | )basic_decl_specifier_seq | | | | (ptr_declarator@Cpp~GCC5=1417 | | | | (noptr_declarator@Cpp~GCC5=1422 | | | | (noptr_declarator@Cpp~GCC5=1421 | | | | |(declarator_id@Cpp~GCC5=1487 | | | | | (id_expression@Cpp~GCC5=317 | | | | | (unqualified_id@Cpp~GCC5=320 | | | | | (operator_function_id@Cpp~GCC5=2027 | | | | | |(operator@Cpp~GCC5=2070 | | | | | )operator_function_id | | | | | )unqualified_id | | | | | )id_expression | | | | |)declarator_id | | | | )noptr_declarator | | | | (parameter_declaration_clause@Cpp~GCC5=1558 | | | | (function_qualifiers@Cpp~GCC5=1438 | | | | )noptr_declarator | | | | )ptr_declarator | | | |)function_head | | | |(function_body@Cpp~GCC5=1680 | | | | (compound_statement@Cpp~GCC5=889 | | | | (pp_statement_seq@Cpp~GCC5=894 | | | | (statement@Cpp~GCC5=857 | | | | |(jump_statement@Cpp~GCC5=1011 | | | | | (pm_expression@Cpp~GCC5=551 | | | | | (cast_expression@Cpp~GCC5=543 | | | | | (unary_expression@Cpp~GCC5=465 | | | | | |(primary_expression@Cpp~GCC5=307 | | | | | | (id_expression@Cpp~GCC5=317 | | | | | | (unqualified_id@Cpp~GCC5=319 | | | | | | (IDENTIFIER@Cpp~GCC5=3368 | | | | | | )unqualified_id | | | | | | )id_expression | | | | | |)primary_expression | | | | | )unary_expression | | | | | )cast_expression | | | | | )pm_expression | | | | |)jump_statement | | | | )statement | | | | )pp_statement_seq | | | | )compound_statement | | | |)function_body | | | )function_definition | | | )member_declaration | | | )member_declaration_or_access_specifier | | |)member_specification | | )class_specifier | | )type_specifier | | )decl_specifier | |)basic_decl_specifier_seq | )simple_declaration | )block_declaration | )declaration |)template_declaration )declaration )pp_declaration_seq (pp_declaration_seq@Cpp~GCC5=1022 (declaration@Cpp~GCC5=1036 |(template_declaration@Cpp~GCC5=2079 | (template_parameter_list@Cpp~GCC5=2083 | (template_parameter_list@Cpp~GCC5=2083 | (template_parameter_list@Cpp~GCC5=2083 | |(template_parameter_list@Cpp~GCC5=2082 | | (template_parameter@Cpp~GCC5=2085 | | (parameter_declaration@Cpp~GCC5=1611 | | (basic_decl_specifier_seq@Cpp~GCC5=1070 | | |(decl_specifier@Cpp~GCC5=1073 | | | (trailing_type_specifier@Cpp~GCC5=1118 | | | (simple_type_specifier@Cpp~GCC5=1138 | | | )trailing_type_specifier | | |)decl_specifier | | )basic_decl_specifier_seq | | (ptr_declarator@Cpp~GCC5=1417 | | |(noptr_declarator@Cpp~GCC5=1421 | | | (declarator_id@Cpp~GCC5=1487 | | | (id_expression@Cpp~GCC5=317 | | | (unqualified_id@Cpp~GCC5=319 | | | |(IDENTIFIER@Cpp~GCC5=3368 | | | )unqualified_id | | | )id_expression | | | )declarator_id | | |)noptr_declarator | | )ptr_declarator | | )parameter_declaration | | )template_parameter | |)template_parameter_list | |(template_parameter@Cpp~GCC5=2085 | | (parameter_declaration@Cpp~GCC5=1611 | | (basic_decl_specifier_seq@Cpp~GCC5=1070 | | (decl_specifier@Cpp~GCC5=1073 | | |(trailing_type_specifier@Cpp~GCC5=1118 | | | (simple_type_specifier@Cpp~GCC5=1138 | | |)trailing_type_specifier | | )decl_specifier | | )basic_decl_specifier_seq | | (ptr_declarator@Cpp~GCC5=1417 | | (noptr_declarator@Cpp~GCC5=1421 | | |(declarator_id@Cpp~GCC5=1487 | | | (id_expression@Cpp~GCC5=317 | | | (unqualified_id@Cpp~GCC5=319 | | | (IDENTIFIER@Cpp~GCC5=3368 | | | )unqualified_id | | | )id_expression | | |)declarator_id | | )noptr_declarator | | )ptr_declarator | | )parameter_declaration | |)template_parameter | )template_parameter_list | (template_parameter@Cpp~GCC5=2085 | |(parameter_declaration@Cpp~GCC5=1611 | | (basic_decl_specifier_seq@Cpp~GCC5=1070 | | (decl_specifier@Cpp~GCC5=1073 | | (trailing_type_specifier@Cpp~GCC5=1118 | | |(simple_type_specifier@Cpp~GCC5=1140 | | )trailing_type_specifier | | )decl_specifier | | )basic_decl_specifier_seq | | (ptr_declarator@Cpp~GCC5=1417 | | (noptr_declarator@Cpp~GCC5=1421 | | (declarator_id@Cpp~GCC5=1487 | | |(id_expression@Cpp~GCC5=317 | | | (unqualified_id@Cpp~GCC5=319 | | | (IDENTIFIER@Cpp~GCC5=3368 | | | )unqualified_id | | |)id_expression | | )declarator_id | | )noptr_declarator | | )ptr_declarator | |)parameter_declaration | )template_parameter | )template_parameter_list | (template_parameter@Cpp~GCC5=2085 | (parameter_declaration@Cpp~GCC5=1611 | |(basic_decl_specifier_seq@Cpp~GCC5=1070 | | (decl_specifier@Cpp~GCC5=1073 | | (trailing_type_specifier@Cpp~GCC5=1118 | | (simple_type_specifier@Cpp~GCC5=1140 | | )trailing_type_specifier | | )decl_specifier | |)basic_decl_specifier_seq | |(ptr_declarator@Cpp~GCC5=1417 | | (noptr_declarator@Cpp~GCC5=1421 | | (declarator_id@Cpp~GCC5=1487 | | (id_expression@Cpp~GCC5=317 | | |(unqualified_id@Cpp~GCC5=319 | | | (IDENTIFIER@Cpp~GCC5=3368 | | |)unqualified_id | | )id_expression | | )declarator_id | | )noptr_declarator | |)ptr_declarator | )parameter_declaration | )template_parameter | )template_parameter_list
std::string exec(const char* cmd) { std::array<char, 128> buffer; std::string result; std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose); if (!pipe) { throw std::runtime_error("popen() failed!"); } while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) { result += buffer.data(); } return result; }
std::string exec(const char* cmd) { char buffer[128]; std::string result = ""; FILE* pipe = popen(cmd, "r"); if (!pipe) throw std::runtime_error("popen() failed!"); try { while (fgets(buffer, sizeof buffer, pipe) != NULL) { result += buffer; } } catch (...) { pclose(pipe); throw; } pclose(pipe); return result; }
int main() { redi::ipstream proc("./some_command", redi::pstreams::pstdout | redi::pstreams::pstderr); std::string line; while (std::getline(proc.out(), line)) std::cout << "stdout: " << line << while (std::getline(proc.err(), line)) std::cout << "stderr: " << line << }
enum PIPE_FILE_DESCRIPTERS { READ_FD = 0, WRITE_FD = 1 }; enum CONSTANTS { BUFFER_SIZE = 100 }; int main() { int parentToChild[2]; int childToParent[2]; pid_t pid; string dataReadFromChild; char buffer[BUFFER_SIZE + 1]; ssize_t readResult; int status; ASSERT_IS(0, pipe(parentToChild)); ASSERT_IS(0, pipe(childToParent)); switch (pid = fork()) { case -1: FAIL("Fork failed"); exit(-1); case 0: ASSERT_NOT(-1, dup2(parentToChild[READ_FD], STDIN_FILENO)); ASSERT_NOT(-1, dup2(childToParent[WRITE_FD], STDOUT_FILENO)); ASSERT_NOT(-1, dup2(childToParent[WRITE_FD], STDERR_FILENO)); ASSERT_IS(0, close(parentToChild [WRITE_FD])); ASSERT_IS(0, close(childToParent [READ_FD])); execlp("ls", "ls", "-al", "--color"); FAIL("This line should never be reached!!!"); exit(-1); default: cout << "Child " << pid << " process running..." << endl; ASSERT_IS(0, close(parentToChild [READ_FD])); ASSERT_IS(0, close(childToParent [WRITE_FD])); while (true) { switch (readResult = read(childToParent[READ_FD], buffer, BUFFER_SIZE)) { case 0: cout << "End of file reached..." << endl << "Data received was (" << dataReadFromChild.size() << "): " << endl << dataReadFromChild << endl; ASSERT_IS(pid, waitpid(pid, & status, 0)); cout << endl << "Child exit staus is: " << WEXITSTATUS(status) << endl << endl; exit(0); case -1: if ((errno == EINTR) || (errno == EAGAIN)) { errno = 0; break; } else { FAIL("read() failed"); exit(-1); } default: dataReadFromChild . append(buffer, readResult); break; } } /* while (true) */ } /* switch (pid = fork())*/ }
fd_set readfds; struct timeval timeout; timeout.tv_sec = 0; timeout.tv_usec = 1000; FD_ZERO(&readfds); FD_SET(childToParent[READ_FD], &readfds); switch (select (1 + childToParent[READ_FD], &readfds, (fd_set*)NULL, (fd_set*)NULL, & timeout)) { case 0: break; case -1: if ((errno == EINTR) || (errno == EAGAIN)) { errno = 0; break; } else { FAIL("Select() Failed"); exit(-1); } case 1: readResult = read(childToParent[READ_FD], buffer, BUFFER_SIZE); break; default: FAIL("How did we see input on more than one file descriptor?"); exit(-1); }
// // CStringA ExecCmd( const wchar_t* cmd ) { CStringA strResult; HANDLE hPipeRead, hPipeWrite; SECURITY_ATTRIBUTES saAttr = {sizeof(SECURITY_ATTRIBUTES)}; saAttr.bInheritHandle = TRUE; saAttr.lpSecurityDescriptor = NULL; if (!CreatePipe(&hPipeRead, &hPipeWrite, &saAttr, 0)) return strResult; STARTUPINFO si = {sizeof(STARTUPINFO)}; si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; si.hStdOutput = hPipeWrite; si.hStdError = hPipeWrite; si.wShowWindow = SW_HIDE; PROCESS_INFORMATION pi = { 0 }; BOOL fSuccess = CreateProcessW(NULL, (LPWSTR)cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi); if (! fSuccess) { CloseHandle(hPipeWrite); CloseHandle(hPipeRead); return strResult; } bool bProcessEnded = false; for (; !bProcessEnded ;) { bProcessEnded = WaitForSingleObject( pi.hProcess, 50) == WAIT_OBJECT_0; for (;;) { char buf[1024]; DWORD dwRead = 0; DWORD dwAvail = 0; if (!::PeekNamedPipe(hPipeRead, NULL, 0, NULL, &dwAvail, NULL)) break; if (!dwAvail) break; if (!::ReadFile(hPipeRead, buf, min(sizeof(buf) - 1, dwAvail), &dwRead, NULL) || !dwRead) break; buf[dwRead] = 0; strResult += buf; } } CloseHandle(hPipeWrite); CloseHandle(hPipeRead); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return strResult; }
std::string ssystem (const char *command) { char tmpname [L_tmpnam]; std::tmpnam ( tmpname ); std::string scommand = command; std::string cmd = scommand + " >> " + tmpname; std::system(cmd.c_str()); std::ifstream file(tmpname, std::ios::in ); std::string result; if (file) { while (!file.eof()) result.push_back(file.get()) ; file.close(); } remove(tmpname); return result; } int main(int argc, char *argv[]) { std::string bash = "FILETWO=/cygdrive/c/*\nfor f in $FILETWO\ndo\necho \"$f\"\ndone "; std::string in; std::string s = ssystem(bash.c_str()); std::istringstream iss(s); std::string line; while (std::getline(iss, line)) { std::cout << "LINE-> " + line + " length: " << line.length() << std::endl; } std::cin >> in; return 0; }
using namespace std; int SystemCapture( string CmdLine, string CmdRunDir, string& ListStdOut, string& ListStdErr, uint32_t& RetCode) { int Success; SECURITY_ATTRIBUTES security_attributes; HANDLE stdout_rd = INVALID_HANDLE_VALUE; HANDLE stdout_wr = INVALID_HANDLE_VALUE; HANDLE stderr_rd = INVALID_HANDLE_VALUE; HANDLE stderr_wr = INVALID_HANDLE_VALUE; PROCESS_INFORMATION process_info; STARTUPINFO startup_info; thread stdout_thread; thread stderr_thread; security_attributes.nLength = sizeof(SECURITY_ATTRIBUTES); security_attributes.bInheritHandle = TRUE; security_attributes.lpSecurityDescriptor = nullptr; if (!CreatePipe(&stdout_rd, &stdout_wr, &security_attributes, 0) || !SetHandleInformation(stdout_rd, HANDLE_FLAG_INHERIT, 0)) { return -1; } if (!CreatePipe(&stderr_rd, &stderr_wr, &security_attributes, 0) || !SetHandleInformation(stderr_rd, HANDLE_FLAG_INHERIT, 0)) { if (stdout_rd != INVALID_HANDLE_VALUE) CloseHandle(stdout_rd); if (stdout_wr != INVALID_HANDLE_VALUE) CloseHandle(stdout_wr); return -2; } ZeroMemory(&process_info, sizeof(PROCESS_INFORMATION)); ZeroMemory(&startup_info, sizeof(STARTUPINFO)); startup_info.cb = sizeof(STARTUPINFO); startup_info.hStdInput = 0; startup_info.hStdOutput = stdout_wr; startup_info.hStdError = stderr_wr; if(stdout_rd || stderr_rd) startup_info.dwFlags |= STARTF_USESTDHANDLES; char CmdLineStr[MAX_PATH]; strncpy(CmdLineStr, CmdLine.c_str(), MAX_PATH); CmdLineStr[MAX_PATH-1] = 0; Success = CreateProcess( nullptr, CmdLineStr, nullptr, nullptr, TRUE, 0, nullptr, CmdRunDir.c_str(), &startup_info, &process_info ); CloseHandle(stdout_wr); CloseHandle(stderr_wr); if(!Success) { CloseHandle(process_info.hProcess); CloseHandle(process_info.hThread); CloseHandle(stdout_rd); CloseHandle(stderr_rd); return -4; } else { CloseHandle(process_info.hThread); } if(stdout_rd) { stdout_thread=thread([&]() { DWORD n; const size_t bufsize = 1000; char buffer [bufsize]; for(;;) { n = 0; int Success = ReadFile( stdout_rd, buffer, (DWORD)bufsize, &n, nullptr ); printf("STDERR: Success:%d n:%d\n", Success, (int)n); if(!Success || n == 0) break; string s(buffer, n); printf("STDOUT:(%s)\n", s.c_str()); ListStdOut += s; } printf("STDOUT:BREAK!\n"); }); } if(stderr_rd) { stderr_thread=thread([&]() { DWORD n; const size_t bufsize = 1000; char buffer [bufsize]; for(;;) { n = 0; int Success = ReadFile( stderr_rd, buffer, (DWORD)bufsize, &n, nullptr ); printf("STDERR: Success:%d n:%d\n", Success, (int)n); if(!Success || n == 0) break; string s(buffer, n); printf("STDERR:(%s)\n", s.c_str()); ListStdOut += s; } printf("STDERR:BREAK!\n"); }); } WaitForSingleObject(process_info.hProcess, INFINITE); if(!GetExitCodeProcess(process_info.hProcess, (DWORD*) &RetCode)) RetCode = -1; CloseHandle(process_info.hProcess); if(stdout_thread.joinable()) stdout_thread.join(); if(stderr_thread.joinable()) stderr_thread.join(); CloseHandle(stdout_rd); CloseHandle(stderr_rd); return 0; } int main() { int rc; uint32_t RetCode; string ListStdOut; string ListStdErr; cout << "STARTING.\n"; rc = SystemCapture( "C:\\Windows\\System32\\ipconfig.exe", ".", ListStdOut, ListStdErr, RetCode ); if (rc < 0) { cout << "ERROR: SystemCapture\n"; } cout << "STDOUT:\n"; cout << ListStdOut; cout << "STDERR:\n"; cout << ListStdErr; cout << "Finished.\n"; cout << "Press Enter to Continue"; cin.ignore(); return 0; }
std::string qx(const std::vector<std::string>& args) { int stdout_fds[2]; pipe(stdout_fds); int stderr_fds[2]; pipe(stderr_fds); const pid_t pid = fork(); if (!pid) { close(stdout_fds[0]); dup2(stdout_fds[1], 1); close(stdout_fds[1]); close(stderr_fds[0]); dup2(stderr_fds[1], 2); close(stderr_fds[1]); std::vector<char*> vc(args.size() + 1, 0); for (size_t i = 0; i < args.size(); ++i) { vc[i] = const_cast<char*>(args[i].c_str()); } execvp(vc[0], &vc[0]); exit(0); } close(stdout_fds[1]); std::string out; const int buf_size = 4096; char buffer[buf_size]; do { const ssize_t r = read(stdout_fds[0], buffer, buf_size); if (r > 0) { out.append(buffer, r); } } while (errno == EAGAIN || errno == EINTR); close(stdout_fds[0]); close(stderr_fds[1]); close(stderr_fds[0]); int r, status; do { r = waitpid(pid, &status, 0); } while (r == -1 && errno == EINTR); return out; }
std::string str1 = "hello, world!"; std::string str2 = "HELLO, WORLD!"; if (boost::iequals(str1, str2)) { }
struct ci_char_traits : public char_traits<char> { static bool eq(char c1, char c2) { return toupper(c1) == toupper(c2); } static bool ne(char c1, char c2) { return toupper(c1) != toupper(c2); } static bool lt(char c1, char c2) { return toupper(c1) < toupper(c2); } static int compare(const char* s1, const char* s2, size_t n) { while( n-- != 0 ) { if( toupper(*s1) < toupper(*s2) ) return -1; if( toupper(*s1) > toupper(*s2) ) return 1; ++s1; ++s2; } return 0; } static const char* find(const char* s, int n, char a) { while( n-- > 0 && toupper(*s) != toupper(a) ) { ++s; } return s; } }; typedef std::basic_string<char, ci_char_traits> ci_string;
bool iequals(const string& a, const string& b) { unsigned int sz = a.size(); if (b.size() != sz) return false; for (unsigned int i = 0; i < sz; ++i) if (tolower(a[i]) != tolower(b[i])) return false; return true; }
bool iequals(const string& a, const string& b) { return std::equal(a.begin(), a.end(), b.begin(), b.end(), [](char a, char b) { return tolower(a) == tolower(b); }); }
U212B (ANGSTROM SIGN) U0041 (LATIN CAPITAL LETTER A) + U030A (COMBINING RING ABOVE) U00C5 (LATIN CAPITAL LETTER A WITH RING ABOVE).
comparator<char,collator_base::secondary> cmpr; cout << (cmpr(str1, str2) ? "str1 < str2" : "str1 >= str2") << endl;
bool caseInsensitiveStringCompare(const string& str1, const string& str2) { if (str1.size() != str2.size()) { return false; } for (string::const_iterator c1 = str1.begin(), c2 = str2.begin(); c1 != str1.end(); ++c1, ++c2) { if (tolower(*c1) != tolower(*c2)) { return false; } } return true; }
bool caseInsensitiveStringCompare( const std::string& str1, const std::string& str2 ) { std::string str1Cpy( str1 ); std::string str2Cpy( str2 ); std::transform( str1Cpy.begin(), str1Cpy.end(), str1Cpy.begin(), ::tolower ); std::transform( str2Cpy.begin(), str2Cpy.end(), str2Cpy.begin(), ::tolower ); return ( str1Cpy == str2Cpy ); }
bool icasecmp(const string& l, const string& r) { return l.size() == r.size() && equal(l.cbegin(), l.cend(), r.cbegin(), [](string::value_type l1, string::value_type r1) { return toupper(l1) == toupper(r1); }); } bool icasecmp(const wstring& l, const wstring& r) { return l.size() == r.size() && equal(l.cbegin(), l.cend(), r.cbegin(), [](wstring::value_type l1, wstring::value_type r1) { return towupper(l1) == towupper(r1); }); }
std::equal(str1.begin(), str1.end(), str2.begin(), [](auto a, auto b){return std::tolower(a)==std::tolower(b);})
using namespace std; inline bool str_ignoreCase_cmp(std::string const& s1, std::string const& s2) { if(s1.length() != s2.length()) return false; return strcasecmp(s1.c_str(), s2.c_str()) == 0; } struct StringCaseInsensetiveCompare { bool operator()(std::string const& s1, std::string const& s2) { if(s1.length() != s2.length()) return false; return strcasecmp(s1.c_str(), s2.c_str()) == 0; } bool operator()(const char *s1, const char * s2){ return strcasecmp(s1,s2)==0; } }; inline char const* bool2str(bool b){ return b?"true":"false"; } int main() { cout<< bool2str(strcasecmp("asd","AsD")==0) <<endl; cout<< bool2str(strcasecmp(string{"aasd"}.c_str(),string{"AasD"}.c_str())==0) <<endl; StringCaseInsensetiveCompare cmp; cout<< bool2str(cmp("A","a")) <<endl; cout<< bool2str(cmp(string{"Aaaa"},string{"aaaA"})) <<endl; cout<< bool2str(str_ignoreCase_cmp(string{"Aaaa"},string{"aaaA"})) <<endl; return 0; }
bool mycomp (char c1, char c2) { return std::tolower(c1)<std::tolower(c2); } int main () { char foo[] = "Apple"; char bar[] = "apartment"; std::cout << std::boolalpha; std::cout << "Comparing foo and bar lexicographically (foo < bar):\n"; std::cout << "Using default comparison (operator<): "; std::cout << std::lexicographical_compare(foo, foo + 5, bar, bar + 9); std::cout << std::cout << "Using mycomp as comparison object: "; std::cout << std::lexicographical_compare(foo, foo + 5, bar, bar + 9, mycomp); std::cout << return 0; }
std::string a = "Hello, World!"; std::string b = "hello, world!"; assert( a == b );
std::istring a = "Hello, World!"; std::istring b = "hello, world!"; assert( a == b );
template<class C> struct char_traits_nocase : public std::char_traits<C> { static bool eq( const C& c1, const C& c2 ) { return ::toupper(c1) == ::toupper(c2); } static bool lt( const C& c1, const C& c2 ) { return ::toupper(c1) < ::toupper(c2); } static int compare( const C* s1, const C* s2, size_t N ) { return _strnicmp(s1, s2, N); } static const char* find( const C* s, size_t N, const C& a ) { for( size_t i=0 ; i<N ; ++i ) { if( ::toupper(s[i]) == ::toupper(a) ) return s+i ; } return 0 ; } static bool eq_int_type( const int_type& c1, const int_type& c2 ) { return ::toupper(c1) == ::toupper(c2) ; } }; template<> struct char_traits_nocase<wchar_t> : public std::char_traits<wchar_t> { static bool eq( const wchar_t& c1, const wchar_t& c2 ) { return ::towupper(c1) == ::towupper(c2); } static bool lt( const wchar_t& c1, const wchar_t& c2 ) { return ::towupper(c1) < ::towupper(c2); } static int compare( const wchar_t* s1, const wchar_t* s2, size_t N ) { return _wcsnicmp(s1, s2, N); } static const wchar_t* find( const wchar_t* s, size_t N, const wchar_t& a ) { for( size_t i=0 ; i<N ; ++i ) { if( ::towupper(s[i]) == ::towupper(a) ) return s+i ; } return 0 ; } static bool eq_int_type( const int_type& c1, const int_type& c2 ) { return ::towupper(c1) == ::towupper(c2) ; } }; typedef std::basic_string<char, char_traits_nocase<char> > istring; typedef std::basic_string<wchar_t, char_traits_nocase<wchar_t> > iwstring;
std::string str1 ="aBcD"; std::string str2 = "AbCd";; if (strcasecmp(str1.c_str(), str2.c_str()) == 0) { }
int strcmp(const char*,const char*); int strcmpi(const char*,const char*);
string a="apple",b="ApPlE",c="ball"; if(strcmpi(a.c_str(),b.c_str())==0) cout<<a<<" and "<<b<<" are the same"<<"\n"; if(strcmpi(a.c_str(),b.c_str()<0) cout<<a[0]<<" comes before ball "<<b[0]<<", so "<<a<<" comes before "<<b;
auto tolower = std::bind1st( std::mem_fun( &std::ctype<char>::tolower), &std::use_facet<std::ctype<char> >( std::locale()));
std::string left = "fOo"; transform(left.begin(), left.end(), left.begin(), tolower);
using namespace std; string tolow(string a) { for(unsigned int i=0;i<a.length();i++) { a[i]=tolower(a[i]); } return a; } int main() { string str1,str2; cin>>str1>>str2; int temp=tolow(str1).compare(tolow(str2)); if(temp>0) cout<<1; else if(temp==0) cout<<0; else cout<<-1; }
std::sort(std::begin(myvector), std::end(myvector), [](std::string const &a, std::string const &b) { return std::lexicographical_compare(std::begin(a), std::end(a), std::begin(b), std::end(b), [](std::string::value_type a, std::string::value_type b) { return std::tolower(a) < std::tolower(b); }); });
std::wstring first = L"Test"; std::wstring second = L"TEST"; std::wregex pattern(first, std::wregex::icase); bool isEqual = std::regex_match(second, pattern);
std::string s1 = string("Hello"); if ( _stricmp(s1.c_str(), "HELLO") == 0) std::cout << "The string are equals.";
struct iequal { bool operator()(int c1, int c2) const { return std::toupper(c1) == std::toupper(c2); } }; bool iequals(const std::string& str1, const std::string& str2) { return std::equal(str1.begin(), str1.end(), str2.begin(), iequal()); } int main(void) { std::string str_1 = "HELLO"; std::string str_2 = "hello"; if(iequals(str_1,str_2)) { std::cout<<"String are equal"<<std::endl; } else { std::cout<<"String are not equal"<<std::endl; } return 0; }
template <typename T1, typename T2> void outer(T1&& t1, T2&& t2) { inner(std::forward<T1>(t1), std::forward<T2>(t2)); }
template <typename A, typename B, typename C> void f(A& a, B& b, C& c) { E(a, b, c); }
template <typename A, typename B, typename C> void f(const A& a, const B& b, const C& c) { E(a, b, c); }
int i = 1, j = 2, k = 3; void E(int&, int&, int&); f(i, j, k);
template <typename A, typename B, typename C> void f(const A& a, const B& b, const C& c) { E(const_cast<A&>(a), const_cast<B&>(b), const_cast<C&>(c)); }
const int i = 1, j = 2, k = 3; E(int&, int&, int&); f(i, j, k);
template <typename A, typename B, typename C> void f(A& a, B& b, C& c); template <typename A, typename B, typename C> void f(const A& a, B& b, C& c); template <typename A, typename B, typename C> void f(A& a, const B& b, C& c); template <typename A, typename B, typename C> void f(A& a, B& b, const C& c); template <typename A, typename B, typename C> void f(const A& a, const B& b, C& c); template <typename A, typename B, typename C> void f(const A& a, B& b, const C& c); template <typename A, typename B, typename C> void f(A& a, const B& b, const C& c); template <typename A, typename B, typename C> void f(const A& a, const B& b, const C& c);
TR R T& & -> T& T& && -> T& T&& & -> T& T&& && -> T&&
template <typename T> void deduce(T&& x); int i; deduce(i); deduce(1);
void foo(int&); template <typename T> void deduce(T&& x) { foo(x); } deduce(1);
template <typename A> void f(A&& a) { E(static_cast<A&&>(a)); }
void overloaded_function(std::string& param) { std::cout << "std::string& version" << std::endl; } void overloaded_function(std::string&& param) { std::cout << "std::string&& version" << std::endl; } template<typename T> void pass_through(T&& param) { overloaded_function(std::forward<T>(param)); } int main() { std::string pes; pass_through(pes); pass_through(std::move(pes)); }
template <typename T1, typename T2> void outer(T1&& t1, T2&& t2) { inner(std::forward<T1>(t1), std::forward<T2>(t2)); }
void inner(int &, int &); void inner(int &&, int &&);
using namespace std; void g(const int&) { cout << "const int&\n"; } void g(int&) { cout << "int&\n"; } void g(int&&) { cout << "int&&\n"; } template <typename T> void f(T&& a) { g(static_cast<T&&>(a)); } int main() { cout << "f(1)\n"; f(1); int a = 2; cout << "f(a)\n"; f(a); const int b = 3; cout << "f(const b)\n"; f(b); cout << "f(a * b)\n"; f(a * b); }
f(1) int&& f(a) int& f(const b) const int& f(a * b) int&&
std::forward<int>(1); std::forward<std::string>("Hello");
class Foo { public: Foo() {}; Foo(int a) {}; void bar() {}; }; int main() { Foo foo1(1); foo1.bar(); Foo foo2(); foo2.bar(); return 0; }
nonclass.cpp: In function ‘int main(int, const char**)’: nonclass.cpp:17: error: request for member ‘bar’ in ‘foo2’, which is of non-class type ‘Foo ()()’
MyClass* myPointerToClass = new MyClass(); myPointerToClass.aMethodOfThatClass();
class Foo { public: Foo() {}; Foo(int a) {}; void bar() {}; }; int main() { Foo foo1(1); foo1.bar(); Foo foo2; foo2.bar(); return 0; }
enum DataType { DT_INT32, DT_FLOAT }; struct PrimitiveData { union MyData { int32_t i; float f; } data; enum DataType dt; template<typename T> void operator=(T data) { switch(dt) { case DT_INT32: { data.i = data; break; } case DT_FLOAT: { data.f = data; break; } default: { break; } } } }; int main() { struct PrimitiveData pd; pd.dt = DT_FLOAT; pd = 3.4f; return 0; }
std::vector<int> return_vector(void) { std::vector<int> tmp {1,2,3,4,5}; return tmp; } std::vector<int> &&rval_ref = return_vector();
std::vector<int>&& return_vector(void) { std::vector<int> tmp {1,2,3,4,5}; return std::move(tmp); } std::vector<int> &&rval_ref = return_vector();
std::vector<int> return_vector(void) { std::vector<int> tmp {1,2,3,4,5}; return std::move(tmp); } std::vector<int> &&rval_ref = return_vector();
std::vector<int> return_vector(void) { std::vector<int> tmp {1,2,3,4,5}; return tmp; } std::vector<int> &&rval_ref = return_vector();
const std::vector<int>& rval_ref = return_vector();
std::vector<int>&& return_vector(void) { std::vector<int> tmp {1,2,3,4,5}; return std::move(tmp); } std::vector<int> &&rval_ref = return_vector();
std::vector<int> return_vector(void) { std::vector<int> tmp {1,2,3,4,5}; return std::move(tmp); } std::vector<int> &&rval_ref = return_vector();
std::vector<int> return_vector(void) { std::vector<int> tmp {1,2,3,4,5}; return tmp; } std::vector<int> rval_ref = return_vector();
std::vector<int> return_vector() { std::vector<int> tmp {1,2,3,4,5}; return tmp; } std::vector<int> rval_ref = return_vector();
std::vector vec; for(int x=0; x<10; ++x) { vec.push_back(MyCheapType(0.f)); } std::vector vec; for(int x=0; x<10; ++x) { MyExpensiveType temp(1.0, 3.0); temp.initSomeOtherFields(malloc(5000)); vec.push_back(temp); vec.push_back(std::move(temp)); }
TextureHandle CreateTexture(int width, int height, ETextureFormat fmt, string&& friendlyName) { std::unique_ptr<TextureObject> tex = D3DCreateTexture(width, height, fmt); tex->friendlyName = std::move(friendlyName); return tex; }
TextureHandle htex = CreateTexture(128, 128, A8R8G8B8, string("Checkerboard"));
string str("Checkerboard"); TextureHandle htex = CreateTexture(128, 128, A8R8G8B8, std::move(str));
string str("Checkerboard"); TextureHandle htex = CreateTexture(128, 128, A8R8G8B8, string(str));
string str("Checkerboard"); TextureHandle htex = CreateTexture(128, 128, A8R8G8B8, str);
A a(B&&, C&&); B b(); C c(); auto ret = a(b(), c());
auto bRet = b(); auto cRet = c(); auto aRet = a(std::move(b), std::move(c)); bRet.foo(); cRet.bar();
if (s1.find(s2) != std::string::npos) { std::cout << "found!" << }
string str ("There are two needles in this haystack."); string str2 ("needle"); if (str.find(str2) != string::npos) { }
using namespace std; using namespace boost; int main(){ string s("gengjiawen"); string t("geng"); bool b = contains(s, t); cout << b << endl; return 0; }
string s1 = "Hello"; string s2 = "el"; if(strstr(s1.c_str(),s2.c_str())) { cout << " S1 Contains S2"; }
bool CheckSubstring(std::string firstString, std::string secondString){ if(secondString.size() > firstString.size()) return false; for (int i = 0; i < firstString.size(); i++){ int j = 0; if(firstString[i] == secondString[j]){ int k = i; while (firstString[i] == secondString[j] && j < secondString.size()){ j++; i++; } if (j == secondString.size()) return true; else i = k; } } return false; } int main(){ std::string firstString, secondString; std::cout << "Enter first string:"; std::getline(std::cin, firstString); std::cout << "Enter second string:"; std::getline(std::cin, secondString); if(CheckSubstring(firstString, secondString)) std::cout << "Second string is a substring of the frist string.\n"; else std::cout << "Second string is not a substring of the first string.\n"; return 0; }
bool find(string line, string sWord) { bool flag = false; int index = 0, i, helper = 0; for (i = 0; i < line.size(); i++) { if (sWord.at(index) == line.at(i)) { if (flag == false) { flag = true; helper = i; } index++; } else { flag = false; index = 0; } if (index == sWord.size()) { break; } } if ((i+1-helper) == index) { return true; } return false; }
using namespace std; int i; int main() { string a = "abcde"; string b = a.substr(2,2); cout << "substring of a is: " << b << endl; return 0; }
using namespace std; int i; int main() { string a = "abcde"; for (i=0;i<a.length(); i++) { if (a.substr(i,2) == "cd") { cout << "substring of a is: " << a.substr(i,2) << endl; } } return 0; }
using std::search; using std::count; using std::string; int main() { string mystring = "The needle in the haystack"; string str = "needle"; string::const_iterator it; it = search(mystring.begin(), mystring.end(), str.begin(), str.end()) != mystring.end(); if (it != mystring.end()) else return 0; }
int i; float f; double d; std::string str; if(sscanf(str.c_str(), "%d", &i) != 1) if(sscanf(str.c_str(), "%f", &f) != 1) if(sscanf(str.c_str(), "%lf", &d) != 1)
int i; float f; double d; std::string str; try { int i = std::stoi(s); float f = std::stof(s); double d = std::stod(s); } catch (...) { }
int i; float f; double d; std::string str; std::istringstream ( str ) >> i; std::istringstream ( str ) >> f; std::istringstream ( str ) >> d;
std::string str; try { int i = boost::lexical_cast<int>( str.c_str()); float f = boost::lexical_cast<int>( str.c_str()); double d = boost::lexical_cast<int>( str.c_str()); } catch( boost::bad_lexical_cast const& ) { }
bool ok; std::string; int i = QString::fromStdString(str).toInt(&ok); if (!ok) float f = QString::fromStdString(str).toFloat(&ok); if (!ok) double d = QString::fromStdString(str).toDouble(&ok); if (!ok)
int main(int argc, char * argv[]) { using boost::lexical_cast; using boost::bad_lexical_cast; std::vector<short> args; while(*++argv) { try { args.push_back(lexical_cast<short>(*argv)); } catch(bad_lexical_cast &) { args.push_back(0); } } ... }
int main() { int num; std::cin.imbue(std::locale(std::locale(), new numeric_only())); while ( std::cin >> num) std::cout << num << std::endl; return 0; }
the format (-5) or (25) etc... some text.. and then.. 7987...78hjh.hhjg9878
struct numeric_only: std::ctype<char> { numeric_only(): std::ctype<char>(get_table()) {} static std::ctype_base::mask const* get_table() { static std::vector<std::ctype_base::mask> rc(std::ctype<char>::table_size,std::ctype_base::space); std::fill(&rc[ return &rc[0]; } };
const std::wstring hex = L"0x13"; const std::wstring dec = L"19"; int ret; if (StrToIntEx(hex.c_str(), STIF_SUPPORT_HEX, &ret)) { std::cout << ret << "\n"; } if (StrToIntEx(dec.c_str(), STIF_SUPPORT_HEX, &ret)) { std::cout << ret << "\n"; }
using namespace std; template<typename T> T toIntegralType(const string &str) { static_assert(is_integral<T>::value, "Integral type required."); T ret; stringstream ss(str); ss >> ret; if ( to_string(ret) != str) throw invalid_argument("Can return ret; }
string str = "123"; int x = toIntegralType<int>(str); str = "123a"; x = toIntegralType<int>(str); str = "1"; bool y = toIntegralType<bool>(str); str = "0"; y = toIntegralType<bool>(str); str = "00"; y = toIntegralType<bool>(str);
void task1(std::string msg) { std::cout << "task1 says: " << msg; }
using namespace std; void task1(string msg) { cout << "task1 says: " << msg; } int main() { thread t1(task1, "Hello"); t1.join(); }
void task1() { } void task2() { } int main (int argc, char ** argv) { using namespace boost; thread thread_1 = thread(task1); thread thread_2 = thread(task2); thread_2.join(); thread_1.join(); return 0; }
void *task(void *argument){ char* msg; msg = (char*)argument; std::cout<<msg<<std::endl; } int main(){ pthread_t thread1, thread2; int i1,i2; i1 = pthread_create( &thread1, NULL, task, (void*) "thread 1"); i2 = pthread_create( &thread2, NULL, task, (void*) "thread 2"); pthread_join(thread1,NULL); pthread_join(thread2,NULL); return 0; }
using namespace std; void doSomething(int id) { cout << "Thread id = " << id; } /** * Spawns n threads */ void spawnThreads(int n) { thread threads[n]; for (int i = 0; i < n; i++) { threads[i] = thread(doSomething, i + 1); } for (auto& th : threads) { th.join(); } }
class RThread : public wxThread { public: RThread() : wxThread(wxTHREAD_JOINABLE){ } private: RThread(const RThread &copy); public: void *Entry(void){ return 0; } }; wxThread *CreateThread() { wxThread *_hThread = new RThread(); _hThread->Create(); _hThread->Run(); return _hThread; }
class DataManager { public: bool hasData; void getData(); bool dataAvailable(); };
void DataManager::getData() { hasData = true; } bool DataManager::dataAvailable() { if (hasData) { return true; } else { std::thread t(&DataManager::getData, this); t.detach(); } }
int main() { int localVariable = 100; thread th { [=](){ cout<<"The Value of local variable => "<<localVariable<<endl; }} th.join(); return 0; }
using namespace std; bool flag = 1; auto path = "D:\\temp"; void writestatus(int i, int j); CRITICAL_SECTION cs; void workerThread(int j) { int i = 1; ofstream f2; char buff[150] = { 0 }; while (flag) { sprintf_s(buff, 150, "D:\\temp\\MyTemp_%d%03d.txt", j, i++); f2.open(buff); f2 << buff; f2.close(); } EnterCriticalSection(&cs); writestatus(i, j); LeaveCriticalSection(&cs); } void writestatus(int i, int j) { ofstream f1; char buff[150] = { 0 }; f1.open("D:\\temp\\status.txt", ios_base::app); sprintf_s(buff, 150, "%d Writes %d files \n", j, i++); if (f1) { f1 << buff; } else { MessageBeep(1); } f1.close(); } int main() { system("del d:\\temp\\*.txt"); InitializeCriticalSection(&cs); thread t1(workerThread, 1); thread t2(workerThread, 2); thread t3(workerThread, 3); thread t4(workerThread, 4); thread t5(workerThread, 5); Sleep(250); flag = 0; t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0; }
class Foo { public: void DoSomething() { } }; class Bar : public virtual Foo { public: void DoSpecific() { } };
class A { public: void Foo() {} }; class B : public A {}; class C : public A {}; class D : public B, public C {};
class A { public: void Foo() {} }; class B : public virtual A {}; class C : public virtual A {}; class D : public B, public C {};
class A { public: A(){} A(int i) : i(i) {} int i; virtual int f() = 0; virtual int g() = 0; virtual int h() = 0; }; class B : public virtual A { public: B(int j) : j(j) {} int j; virtual int f() { return this->i + this->j; } }; class C : public virtual A { public: C(int k) : k(k) {} int k; virtual int g() { return this->i + this->k; } }; class D : public B, public C { public: D(int i, int j, int k) : A(i), B(j), C(k) {} virtual int h() { return this->i + this->j + this->k; } }; int main() { D d = D(1, 2, 4); assert(d.f() == 3); assert(d.g() == 5); assert(d.h() == 7); }
char *buf = new char[sizeof(string)]; string *p = new (buf) string("hi"); string *q = new string("hi");
class Pool { public: Pool() { }; virtual ~Pool() { }; virtual void *allocate(size_t); virtual void deallocate(void *); static Pool::misc_pool() { return misc_pool_p; } }; class ClusterPool : public Pool { }; class FastPool : public Pool { }; class MapPool : public Pool { }; class MiscPool : public Pool { }; void *pnew_new(size_t size) { return Pool::misc_pool()->allocate(size); } void *pnew_new(size_t size, Pool *pool_p) { if (!pool_p) { return Pool::misc_pool()->allocate(size); } else { return pool_p->allocate(size); } } void pnew_delete(void *p) { Pool *hp = Pool::find_pool(p); if (hp) { hp->deallocate(p); } } class Obj { public: void *operator new(size_t s) { return pnew_new(s); } void *operator new(size_t s, Pool *hp) { return pnew_new(s, hp); } void operator delete(void *dp) { pnew_delete(dp); } void operator delete(void *dp, Pool*) { pnew_delete(dp); } void *operator new[](size_t s) { return pnew_new(s); } void *operator new[](size_t s, Pool* hp) { return pnew_new(s, hp); } void operator delete[](void *dp) { pnew_delete(dp); } void operator delete[](void *dp, Pool*) { pnew_delete(dp); } }; ClusterPool *cp = new ClusterPool(arg1, arg2, ...); Obj *new_obj = new (cp) Obj(arg_a, arg_b, ...);
static Mystruct m; for(...) { new (&m) Mystruct(); }
Foo* foo = new(free_list.allocate()) Foo(...); ... foo->~Foo(); free_list.free(foo);
template <typename T = char> inline T* AlignUp(void* pointer, uintptr_t boundary_byte_count) { uintptr_t value = reinterpret_cast<uintptr_t>(pointer); value += (((~value) + 1) & (boundary_byte_count - 1)); return reinterpret_cast<T*>(value); } struct Foo { Foo () {} }; char buffer[sizeof (Foo) + 64]; Foo* foo = new (AlignUp<Foo> (buffer, 64)) Foo ();
using namespace std; class StudentT { public: int id; string name; public: StudentT(int _id, string _name) : id(_id), name(_name) { } int getId() { return id; } string getName() { return name; } }; inline bool operator< (StudentT s1, StudentT s2) { return s1.getId() < s2.getId(); } int main() { set<StudentT> st; StudentT s1(0, "Tom"); StudentT s2(1, "Tim"); st.insert(s1); st.insert(s2); set<StudentT> :: iterator itr; for (itr = st.begin(); itr != st.end(); itr++) { cout << itr->getId() << " " << itr->getName() << endl; } return 0; }
cout << itr->getId() << " " << itr->getName() << endl;
int getId() const { return id; } string getName() const { return name; }
void f(const StudentT & s) { cout << s.getId(); cout << s.getName(); }
inline bool operator< (const StudentT & s1, const StudentT & s2) { return s1.getId() < s2.getId(); }
int getId() const { return id; } string getName() const { return name; }
typedef typename _Rep_type::const_iterator iterator; typedef typename _Rep_type::const_iterator const_iterator;
iterator Container Iterator used to iterate through a set. const_iterator Container Const iterator used to iterate through a set. (Iterator and const_iterator are the same type.)
struct Count{ uint32_t c; Count(uint32_t i=0):c(i){} uint32_t getCount(){ return c; } uint32_t add(const Count& count){ uint32_t total = c + count.getCount(); return total; } };
int main() { auto start = std::chrono::system_clock::now(); auto end = std::chrono::system_clock::now(); std::chrono::duration<double> elapsed_seconds = end-start; std::time_t end_time = std::chrono::system_clock::to_time_t(end); std::cout << "finished computation at " << std::ctime(&end_time) << "elapsed time: " << elapsed_seconds.count() << "s\n"; }
finished computation at Mon Oct 2 00:59:08 2017 elapsed time: 1.88232s
int main() { std::time_t t = std::time(0); std::tm* now = std::localtime(&t); std::cout << (now->tm_year + 1900) << << (now->tm_mon + 1) << << now->tm_mday << "\n"; }
const std::string currentDateTime() { time_t now = time(0); struct tm tstruct; char buf[80]; tstruct = *localtime(&now); strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct); return buf; } int main() { std::cout << "currentDateTime()=" << currentDateTime() << std::endl; getchar(); }
time_t now = time(0); tm* localtm = localtime(&now); cout << "The local date and time is: " << asctime(localtm) << endl; tm* gmtm = gmtime(&now); if (gmtm != NULL) { cout << "The UTC date and time is: " << asctime(gmtm) << endl; } else { cerr << "Failed to get the UTC date and time" << endl; return EXIT_FAILURE; }
int main() { using namespace date; using namespace std::chrono; std::cout << system_clock::now() << }
int main() { using namespace date; using namespace std::chrono; auto local = make_zoned(current_zone(), system_clock::now()); std::cout << local << }
auto local = make_zoned("Australia/Sydney", system_clock::now());
boost::posix_time::ptime date_time = boost::posix_time::microsec_clock::universal_time();
int main () { time_t rawtime; struct tm * timeinfo; time ( &rawtime ); timeinfo = localtime ( &rawtime ); printf ( "Current local time and date: %s", asctime (timeinfo) ); return 0; }
auto time = std::time(nullptr); std::cout << std::put_time(std::localtime(&time), "%F %T%z");
int main() { auto time = std::time(nullptr); std::cout << std::put_time(std::gmtime(&time), "%F %T%z") << << std::put_time(std::gmtime(&time), "%D"); }
std::cout << std::put_time(std::gmtime(&time), "%c %A %Z") << std::endl; std::cout << std::put_time(std::gmtime(&time), "%Z %c %A") << std::endl;
char output[100]; if (std::strftime(output, sizeof(output), "%F", std::gmtime(&time))) { std::cout << output << }
int main() { auto time = std::time(nullptr); std::cout << "undef: " << std::put_time(std::gmtime(&time), "%c") << std::cout.imbue(std::locale("en_US.utf8")); std::cout << "en_US: " << std::put_time(std::gmtime(&time), "%c") << std::cout.imbue(std::locale("en_GB.utf8")); std::cout << "en_GB: " << std::put_time(std::gmtime(&time), "%c") << std::cout.imbue(std::locale("de_DE.utf8")); std::cout << "de_DE: " << std::put_time(std::gmtime(&time), "%c") << std::cout.imbue(std::locale("ja_JP.utf8")); std::cout << "ja_JP: " << std::put_time(std::gmtime(&time), "%c") << std::cout.imbue(std::locale("ru_RU.utf8")); std::cout << "ru_RU: " << std::put_time(std::gmtime(&time), "%c"); }
class timefmt { public: timefmt(std::string fmt) : format(fmt) { } friend std::ostream& operator <<(std::ostream &, timefmt const &); private: std::string format; }; std::ostream& operator <<(std::ostream& os, timefmt const& mt) { std::ostream::sentry s(os); if (s) { std::time_t t = std::time(0); std::tm const* tm = std::localtime(&t); std::ostreambuf_iterator<char> out(os); std::use_facet<std::time_put<char>>(os.getloc()) .put(out, os, os.fill(), tm, &mt.format[0], &mt.format[0] + mt.format.size()); } os.width(0); return os; } int main() { std::cout << timefmt("%c"); }
using namespace std; int main() { time_t now = chrono::system_clock::to_time_t(chrono::system_clock::now()); cout << put_time(localtime(&now), "%F %T") << endl; return 0; }
using namespace std void printBuildDateTime () { cout << __TIMESTAMP__ << endl; } int main() { printBuildDateTime(); }
int main () { time_t rawtime; struct tm * timeinfo; time ( &rawtime ); printf ( "Current local time and date: %s", ctime (&rawtime) ); return 0; }
using namespace std; /** * This function gets the current date time * @param useLocalTime true if want to use local time, default to false (UTC) * @return current datetime in the format of "YYYYMMDD HHMMSS" */ string getCurrentDateTime(bool useLocalTime) { stringstream currentDateTime; time_t ttNow = time(0); tm * ptmNow; if (useLocalTime) ptmNow = localtime(&ttNow); else ptmNow = gmtime(&ttNow); currentDateTime << 1900 + ptmNow->tm_year; if (ptmNow->tm_mon < 9) currentDateTime << "0" << 1 + ptmNow->tm_mon; else currentDateTime << (1 + ptmNow->tm_mon); if (ptmNow->tm_mday < 10) currentDateTime << "0" << ptmNow->tm_mday << " "; else currentDateTime << ptmNow->tm_mday << " "; if (ptmNow->tm_hour < 10) currentDateTime << "0" << ptmNow->tm_hour; else currentDateTime << ptmNow->tm_hour; if (ptmNow->tm_min < 10) currentDateTime << "0" << ptmNow->tm_min; else currentDateTime << ptmNow->tm_min; if (ptmNow->tm_sec < 10) currentDateTime << "0" << ptmNow->tm_sec; else currentDateTime << ptmNow->tm_sec; return currentDateTime.str(); }
// // // void ReportTimeStamp(string strName, string strUpdate) { try { const time_t tStart = time(0); struct tm tmStart; localtime_s(&tmStart, &tStart); cout << strName << ": " << strUpdate << ": " << (1900 + tmStart.tm_year) << "-" << tmStart.tm_mon << "-" << tmStart.tm_mday << " " << tmStart.tm_hour << ":" << tmStart.tm_min << ":" << tmStart.tm_sec << "\n\n"; const time_t tStart = time(0); struct tm* tmStart; tmStart = localtime(&tStart); cout << strName << ": " << strUpdate << ": " << (1900 + tmStart->tm_year) << "-" << tmStart->tm_mon << "-" << tmStart->tm_mday << " " << tmStart->tm_hour << ":" << tmStart->tm_min << ":" << tmStart->tm_sec << "\n\n"; } catch (exception ex) { cout << "ERROR [ReportTimeStamp] Exception Code: " << ex.what() << "\n"; } return; }
The current time is 11:43:41 am The current date is 6-18-2015 June Wednesday Day of month is 17 and the Month of year is 6, also the day of year is 167 & our Weekday is 3. The current year is 2015.
using namespace std; const std::string currentTime() { time_t now = time(0); struct tm tstruct; char buf[80]; tstruct = *localtime(&now); strftime(buf, sizeof(buf), "%H:%M:%S %P", &tstruct); return buf; } const std::string currentDate() { time_t now = time(0); struct tm tstruct; char buf[80]; tstruct = *localtime(&now); strftime(buf, sizeof(buf), "%B %A ", &tstruct); return buf; } int main() { cout << "\033[2J\033[1;1H"; std:cout << "The current time is " << currentTime() << std::endl; time_t t = time(0); struct tm * now = localtime( & t ); cout << "The current date is " << now->tm_mon + 1 << << (now->tm_mday + 1) << << (now->tm_year + 1900) << " " << currentDate() << endl; cout << "Day of month is " << (now->tm_mday) << " and the Month of year is " << (now->tm_mon)+1 << "," << endl; cout << "also the day of year is " << (now->tm_yday) << " & our Weekday is " << (now->tm_wday) << "." << endl; cout << "The current year is " << (now->tm_year)+1900 << "." << endl; return 0; }
int main () { time_t current_time; struct tm local_time; time ( &current_time ); localtime_s(&local_time, &current_time); int Year = local_time.tm_year + 1900; int Month = local_time.tm_mon + 1; int Day = local_time.tm_mday; int Hour = local_time.tm_hour; int Min = local_time.tm_min; int Sec = local_time.tm_sec; return 0; }
void main() { SYSTEMTIME SystemTime, LocalTime; int loctime = GetLocalTime(&LocalTime); int systime = GetSystemTime(&SystemTime) }
using namespace boost::gregorian; int main() { date d = day_clock::universal_day(); std::cout << d.day() << " " << d.month() << " " << d.year(); }
using namespace std; int main() { time_t now = time(0); string dt = ctime(&now); cout << "The local date and time is: " << dt << endl; return 0; }
template<container C, class T, String delim = ", ", String open = "[", String close = "]"> std::ostream & operator<<(std::ostream & o, const C<T> & x) { o << open; for (auto i = x.begin(); i != x.end(); i++) { if (i != x.begin()) o << delim; o << *i; } o << close; return o; }
namespace std { template<typename T, typename TTraits, typename TAllocator> class set; } namespace pretty_print { template<typename T> struct is_container_helper { private: template<typename C> static char test(typename C::const_iterator*); template<typename C> static int test(...); public: static const bool value = sizeof(test<T>(0)) == sizeof(char); }; template<typename T> struct is_container : public ::std::integral_constant<bool, is_container_helper<T>::value> { }; template<typename TChar> struct delimiters_values { typedef TChar char_type; const TChar * prefix; const TChar * delimiter; const TChar * postfix; }; template<typename T, typename TChar> struct delimiters { typedef delimiters_values<TChar> type; static const type values; }; template<typename T> struct delimiters<T, char> { static const delimiters_values<char> values; }; template<typename T> const delimiters_values<char> delimiters<T, char>::values = { "[", ", ", "]" }; template<typename T> struct delimiters<T, wchar_t> { static const delimiters_values<wchar_t> values; }; template<typename T> const delimiters_values<wchar_t> delimiters<T, wchar_t>::values = { L"[", L", ", L"]" }; template<typename T, typename TTraits, typename TAllocator> struct delimiters< ::std::set<T, TTraits, TAllocator>, char> { static const delimiters_values<char> values; }; template<typename T, typename TTraits, typename TAllocator> const delimiters_values<char> delimiters< ::std::set<T, TTraits, TAllocator>, char>::values = { "{", ", ", "}" }; template<typename T, typename TTraits, typename TAllocator> struct delimiters< ::std::set<T, TTraits, TAllocator>, wchar_t> { static const delimiters_values<wchar_t> values; }; template<typename T, typename TTraits, typename TAllocator> const delimiters_values<wchar_t> delimiters< ::std::set<T, TTraits, TAllocator>, wchar_t>::values = { L"{", L", ", L"}" }; template<typename T1, typename T2> struct delimiters< ::std::pair<T1, T2>, char> { static const delimiters_values<char> values; }; template<typename T1, typename T2> const delimiters_values<char> delimiters< ::std::pair<T1, T2>, char>::values = { "(", ", ", ")" }; template<typename T1, typename T2> struct delimiters< ::std::pair<T1, T2>, wchar_t> { static const delimiters_values<wchar_t> values; }; template<typename T1, typename T2> const delimiters_values<wchar_t> delimiters< ::std::pair<T1, T2>, wchar_t>::values = { L"(", L", ", L")" }; template<typename T, typename TChar = char, typename TCharTraits = ::std::char_traits<TChar>, typename TDelimiters = delimiters<T, TChar>> struct print_container_helper { typedef TChar char_type; typedef TDelimiters delimiters_type; typedef std::basic_ostream<TChar, TCharTraits> & ostream_type; print_container_helper(const T & container) : _container(container) { } inline void operator()(ostream_type & stream) const { if (delimiters_type::values.prefix != NULL) stream << delimiters_type::values.prefix; for (typename T::const_iterator beg = _container.begin(), end = _container.end(), it = beg; it != end; ++it) { if (it != beg && delimiters_type::values.delimiter != NULL) stream << delimiters_type::values.delimiter; stream << *it; } if (delimiters_type::values.postfix != NULL) stream << delimiters_type::values.postfix; } private: const T & _container; }; struct custom_delims_base { virtual ~custom_delims_base() { } virtual ::std::ostream & stream(::std::ostream &) = 0; virtual ::std::wostream & stream(::std::wostream &) = 0; }; template <typename T, typename Delims> struct custom_delims_wrapper : public custom_delims_base { custom_delims_wrapper(const T & t) : t(t) { } ::std::ostream & stream(::std::ostream & stream) { return stream << ::pretty_print::print_container_helper<T, char, ::std::char_traits<char>, Delims>(t); } ::std::wostream & stream(::std::wostream & stream) { return stream << ::pretty_print::print_container_helper<T, wchar_t, ::std::char_traits<wchar_t>, Delims>(t); } private: const T & t; }; template <typename Delims> struct custom_delims { template <typename Container> custom_delims(const Container & c) : base(new custom_delims_wrapper<Container, Delims>(c)) { } ~custom_delims() { delete base; } custom_delims_base * base; }; } template <typename TChar, typename TCharTraits, typename Delims> inline std::basic_ostream<TChar, TCharTraits> & operator<<(std::basic_ostream<TChar, TCharTraits> & stream, const pretty_print::custom_delims<Delims> & p) { return p.base->stream(stream); } // namespace std { template<typename T, typename TChar, typename TCharTraits, typename TDelimiters> inline basic_ostream<TChar, TCharTraits> & operator<<(basic_ostream<TChar, TCharTraits> & stream, const ::pretty_print::print_container_helper<T, TChar, TCharTraits, TDelimiters> & helper) { helper(stream); return stream; } template<typename T, typename TChar, typename TCharTraits> inline typename enable_if< ::pretty_print::is_container<T>::value, basic_ostream<TChar, TCharTraits>&>::type operator<<(basic_ostream<TChar, TCharTraits> & stream, const T & container) { return stream << ::pretty_print::print_container_helper<T, TChar, TCharTraits>(container); } template<typename T1, typename T2, typename TChar, typename TCharTraits> inline basic_ostream<TChar, TCharTraits> & operator<<(basic_ostream<TChar, TCharTraits> & stream, const pair<T1, T2> & value) { if (::pretty_print::delimiters<pair<T1, T2>, TChar>::values.prefix != NULL) stream << ::pretty_print::delimiters<pair<T1, T2>, TChar>::values.prefix; stream << value.first; if (::pretty_print::delimiters<pair<T1, T2>, TChar>::values.delimiter != NULL) stream << ::pretty_print::delimiters<pair<T1, T2>, TChar>::values.delimiter; stream << value.second; if (::pretty_print::delimiters<pair<T1, T2>, TChar>::values.postfix != NULL) stream << ::pretty_print::delimiters<pair<T1, T2>, TChar>::values.postfix; return stream; } } namespace pretty_print { struct tuple_dummy_t { }; typedef std::pair<tuple_dummy_t, tuple_dummy_t> tuple_dummy_pair; template<typename Tuple, size_t N, typename TChar, typename TCharTraits> struct pretty_tuple_helper { static inline void print(::std::basic_ostream<TChar, TCharTraits> & stream, const Tuple & value) { pretty_tuple_helper<Tuple, N - 1, TChar, TCharTraits>::print(stream, value); if (delimiters<tuple_dummy_pair, TChar>::values.delimiter != NULL) stream << delimiters<tuple_dummy_pair, TChar>::values.delimiter; stream << std::get<N - 1>(value); } }; template<typename Tuple, typename TChar, typename TCharTraits> struct pretty_tuple_helper<Tuple, 1, TChar, TCharTraits> { static inline void print(::std::basic_ostream<TChar, TCharTraits> & stream, const Tuple & value) { stream << ::std::get<0>(value); } }; } namespace std { template<typename TChar, typename TCharTraits, typename ...Args> inline basic_ostream<TChar, TCharTraits> & operator<<(basic_ostream<TChar, TCharTraits> & stream, const tuple<Args...> & value) { if (::pretty_print::delimiters< ::pretty_print::tuple_dummy_pair, TChar>::values.prefix != NULL) stream << ::pretty_print::delimiters< ::pretty_print::tuple_dummy_pair, TChar>::values.prefix; ::pretty_print::pretty_tuple_helper<const tuple<Args...> &, sizeof...(Args), TChar, TCharTraits>::print(stream, value); if (::pretty_print::delimiters< ::pretty_print::tuple_dummy_pair, TChar>::values.postfix != NULL) stream << ::pretty_print::delimiters< ::pretty_print::tuple_dummy_pair, TChar>::values.postfix; return stream; } } namespace pretty_print { template <typename T, size_t N> struct array_wrapper { typedef const T * const_iterator; typedef T value_type; array_wrapper(const T (& a)[N]) : _array(a) { } inline const_iterator begin() const { return _array; } inline const_iterator end() const { return _array + N; } private: const T * const _array; }; } template <typename T, size_t N> inline pretty_print::array_wrapper<T, N> pretty_print_array(const T (& a)[N]) { return pretty_print::array_wrapper<T, N>(a); }
template<> const pretty_print::delimiters_values<char> pretty_print::delimiters<std::vector<double>, char>::values = { "|| ", " : ", " ||" }; struct MyDel { static const delimiters_values<char> values; }; const delimiters_values<char> MyDel::values = { "<", "; ", ">" }; int main(int argc, char * argv[]) { std::string cs; std::unordered_map<int, std::string> um; std::map<int, std::string> om; std::set<std::string> ss; std::vector<std::string> v; std::vector<std::vector<std::string>> vv; std::vector<std::pair<int, std::string>> vp; std::vector<double> vd; v.reserve(argc - 1); vv.reserve(argc - 1); vp.reserve(argc - 1); vd.reserve(argc - 1); std::cout << "Printing pairs." << std::endl; while (--argc) { std::string s(argv[argc]); std::pair<int, std::string> p(argc, s); um[argc] = s; om[argc] = s; v.push_back(s); vv.push_back(v); vp.push_back(p); vd.push_back(1./double(i)); ss.insert(s); cs += s; std::cout << " " << p << std::endl; } std::array<char, 5> a{{ std::cout << "Vector: " << v << std::endl << "Incremental vector: " << vv << std::endl << "Another vector: " << vd << std::endl << "Pairs: " << vp << std::endl << "Set: " << ss << std::endl << "OMap: " << om << std::endl << "UMap: " << um << std::endl << "String: " << cs << std::endl << "Array: " << a << std::endl ; std::cout << pretty_print::print_container_helper<std::vector<std::string>, char, std::char_traits<char>, MyDel>(v) << std::endl; std::cout << pretty_print::custom_delims<MyDel>(v) << std::endl; auto a1 = std::make_pair(std::string("Jello"), 9); auto a2 = std::make_tuple(1729); auto a3 = std::make_tuple("Qrgh", a1, 11); auto a4 = std::make_tuple(1729, 2875, std::pair<double, std::string>(1.5, "meow")); int arr[] = { 1, 4, 9, 16 }; std::cout << "C array: " << wrap_array(arr) << std::endl << "Pair: " << a1 << std::endl << "1-tuple: " << a2 << std::endl << "n-tuple: " << a3 << std::endl << "n-tuple: " << a4 << std::endl ; }
struct MyDel { static const pretty_print::delimiters_values<char> values; }; const pretty_print::delimiters_values<char> MyDel::values = { "<", "; ", ">" };
struct wrapper_base { virtual ~wrapper_base() { } virtual std::ostream & stream(std::ostream & o) = 0; }; template <typename T, typename Delims> struct wrapper : public wrapper_base { wrapper(const T & t) : t(t) { } std::ostream & stream(std::ostream & o) { return o << pretty_print::print_container_helper<T, char, std::char_traits<char>, Delims>(t); } private: const T & t; }; template <typename Delims> struct MyPrinter { template <typename Container> MyPrinter(const Container & c) : base(new wrapper<Container, Delims>(c)) { } ~MyPrinter() { delete base; } wrapper_base * base; }; template <typename Delims> std::ostream & operator<<(std::ostream & o, const MyPrinter<Delims> & p) { return p.base->stream(o); }
template<typename T, typename TChar = char, typename TCharTraits = std::char_traits<TChar> > class pretty_ostream_iterator : public std::iterator<std::output_iterator_tag, void, void, void, void> { public: typedef TChar char_type; typedef TCharTraits traits_type; typedef std::basic_ostream<TChar, TCharTraits> ostream_type; pretty_ostream_iterator(ostream_type &stream, const char_type *delim = NULL) : _stream(&stream), _delim(delim), _insertDelim(false) { } pretty_ostream_iterator<T, TChar, TCharTraits>& operator=(const T &value) { if( _delim != NULL ) { if( _insertDelim ) (*_stream) << _delim; else _insertDelim = true; } (*_stream) << value; return *this; } pretty_ostream_iterator<T, TChar, TCharTraits>& operator*() { return *this; } pretty_ostream_iterator<T, TChar, TCharTraits>& operator++() { return *this; } pretty_ostream_iterator<T, TChar, TCharTraits>& operator++(int) { return *this; } private: ostream_type *_stream; const char_type *_delim; bool _insertDelim; }; template<typename T, typename TChar, typename TCharTraits> struct std::_Is_checked_helper<pretty_ostream_iterator<T, TChar, TCharTraits> > : public std::tr1::true_type { }; namespace std { template<typename T, typename TAllocator> class vector; template<typename T, typename TAllocator> class list; template<typename T, typename TTraits, typename TAllocator> class set; template<typename TKey, typename TValue, typename TTraits, typename TAllocator> class map; } template<typename T> struct is_container : public std::false_type { }; template<typename T, typename TAllocator> struct is_container<std::vector<T, TAllocator> > : public std::true_type { }; template<typename T, typename TAllocator> struct is_container<std::list<T, TAllocator> > : public std::true_type { }; template<typename T, typename TTraits, typename TAllocator> struct is_container<std::set<T, TTraits, TAllocator> > : public std::true_type { }; template<typename TKey, typename TValue, typename TTraits, typename TAllocator> struct is_container<std::map<TKey, TValue, TTraits, TAllocator> > : public std::true_type { }; template<typename TChar> struct delimiters_values { typedef TChar char_type; const TChar *prefix; const TChar *delimiter; const TChar *postfix; }; template<typename T, typename TChar> struct delimiters { static const delimiters_values<TChar> values; }; template<typename T> struct delimiters<T, char> { static const delimiters_values<char> values; }; template<typename T> const delimiters_values<char> delimiters<T, char>::values = { "{ ", ", ", " }" }; template<typename T> struct delimiters<T, wchar_t> { static const delimiters_values<wchar_t> values; }; template<typename T> const delimiters_values<wchar_t> delimiters<T, wchar_t>::values = { L"{ ", L", ", L" }" }; template<typename T, typename TTraits, typename TAllocator> struct delimiters<std::set<T, TTraits, TAllocator>, char> { static const delimiters_values<char> values; }; template<typename T, typename TTraits, typename TAllocator> const delimiters_values<char> delimiters<std::set<T, TTraits, TAllocator>, char>::values = { "[ ", ", ", " ]" }; template<typename T, typename TTraits, typename TAllocator> struct delimiters<std::set<T, TTraits, TAllocator>, wchar_t> { static const delimiters_values<wchar_t> values; }; template<typename T, typename TTraits, typename TAllocator> const delimiters_values<wchar_t> delimiters<std::set<T, TTraits, TAllocator>, wchar_t>::values = { L"[ ", L", ", L" ]" }; template<typename T1, typename T2> struct delimiters<std::pair<T1, T2>, char> { static const delimiters_values<char> values; }; template<typename T1, typename T2> const delimiters_values<char> delimiters<std::pair<T1, T2>, char>::values = { "(", ", ", ")" }; template<typename T1, typename T2> struct delimiters<std::pair<T1, T2>, wchar_t> { static const delimiters_values<wchar_t> values; }; template<typename T1, typename T2> const delimiters_values<wchar_t> delimiters<std::pair<T1, T2>, wchar_t>::values = { L"(", L", ", L")" }; template<typename T, typename TChar = char, typename TCharTraits = std::char_traits<TChar>, typename TDelimiters = delimiters<T, TChar> > struct print_container_helper { typedef TChar char_type; typedef TDelimiters delimiters_type; typedef std::basic_ostream<TChar, TCharTraits>& ostream_type; print_container_helper(const T &container) : _container(&container) { } void operator()(ostream_type &stream) const { if( delimiters_type::values.prefix != NULL ) stream << delimiters_type::values.prefix; std::copy(_container->begin(), _container->end(), pretty_ostream_iterator<typename T::value_type, TChar, TCharTraits>(stream, delimiters_type::values.delimiter)); if( delimiters_type::values.postfix != NULL ) stream << delimiters_type::values.postfix; } private: const T *_container; }; template<typename T, typename TChar, typename TCharTraits, typename TDelimiters> std::basic_ostream<TChar, TCharTraits>& operator<<(std::basic_ostream<TChar, TCharTraits> &stream, const print_container_helper<T, TChar, TDelimiters> &helper) { helper(stream); return stream; } template<typename T, typename TChar, typename TCharTraits> typename std::enable_if<is_container<T>::value, std::basic_ostream<TChar, TCharTraits>&>::type operator<<(std::basic_ostream<TChar, TCharTraits> &stream, const T &container) { stream << print_container_helper<T, TChar, TCharTraits>(container); return stream; } template<typename T1, typename T2, typename TChar, typename TCharTraits> std::basic_ostream<TChar, TCharTraits>& operator<<(std::basic_ostream<TChar, TCharTraits> &stream, const std::pair<T1, T2> &value) { if( delimiters<std::pair<T1, T2>, TChar>::values.prefix != NULL ) stream << delimiters<std::pair<T1, T2>, TChar>::values.prefix; stream << value.first; if( delimiters<std::pair<T1, T2>, TChar>::values.delimiter != NULL ) stream << delimiters<std::pair<T1, T2>, TChar>::values.delimiter; stream << value.second; if( delimiters<std::pair<T1, T2>, TChar>::values.postfix != NULL ) stream << delimiters<std::pair<T1, T2>, TChar>::values.postfix; return stream; } struct fibonacci { fibonacci() : f1(0), f2(1) { } int operator()() { int r = f1 + f2; f1 = f2; f2 = r; return f1; } private: int f1; int f2; }; int main() { std::vector<int> v; std::generate_n(std::back_inserter(v), 10, fibonacci()); std::cout << v << std::endl; std::generate_n(pretty_ostream_iterator<int>(std::cout, ";"), 20, fibonacci()); std::cout << std::endl; }
struct DefaultPrinter { template< typename T > std::ostream & operator()( std::ostream& os, const T& t ) const { return os << t; } template< typename K, typename V > std::ostream & operator()( std::ostream & os, std::pair<K,V> const& p) { return os << p.first << } }; template< typename FwdIter, typename Printer > class RangePrinter; template< typename FwdIter, typename Printer > std::ostream & operator<<( std::ostream &, RangePrinter<FwdIter, Printer> const& ); template< typename FwdIter, typename Printer=DefaultPrinter > class RangePrinter { FwdIter begin; FwdIter end; std::string delim; std::string open; std::string close; Printer printer; friend std::ostream& operator<< <>( std::ostream&, RangePrinter<FwdIter,Printer> const& ); public: RangePrinter( FwdIter b, FwdIter e, Printer p, std::string const& d, std::string const & o, std::string const& c ) : begin( b ), end( e ), printer( p ), open( o ), close( c ) { } RangePrinter( FwdIter b, FwdIter e, std::string const& d, std::string const & o, std::string const& c ) : begin( b ), end( e ), open( o ), close( c ) { } }; template<typename FwdIter, typename Printer> std::ostream& operator<<( std::ostream& os, RangePrinter<FwdIter, Printer> const& range ) { const Printer & printer = range.printer; os << range.open; FwdIter begin = range.begin, end = range.end; if (begin == end) { return os << range.close; } printer( os, *begin ); for( ++begin; begin != end; ++begin ) { os << range.delim; printer( os, *begin ); } return os << range.close; }
template<typename Collection> RangePrinter<typename Collection::const_iterator> rangePrinter ( const Collection& coll, const char * delim=",", const char * open="[", const char * close="]") { return RangePrinter< typename Collection::const_iterator > ( coll.begin(), coll.end(), delim, open, close ); }
template <class C> struct Delims { static const char *delim[3]; }; template <class C> const char *Delims<C>::delim[3]={"[", ", ", "]"}; template <typename T> struct Delims< std::set<T> > { static const char *delim[3]; }; template <typename T> const char *Delims< std::set<T> >::delim[3]={"{", ", ", "}"}; template <class C> struct IsContainer { enum { value = false }; }; template <typename T> struct IsContainer< std::vector<T> > { enum { value = true }; }; template <typename T> struct IsContainer< std::set<T> > { enum { value = true }; }; template <class C> typename boost::enable_if<IsContainer<C>, std::ostream&>::type operator<<(std::ostream & o, const C & x) { o << Delims<C>::delim[0]; for (typename C::const_iterator i = x.begin(); i != x.end(); ++i) { if (i != x.begin()) o << Delims<C>::delim[1]; o << *i; } o << Delims<C>::delim[2]; return o; } template <typename T> struct IsChar { enum { value = false }; }; template <> struct IsChar<char> { enum { value = true }; }; template <typename T, int N> typename boost::disable_if<IsChar<T>, std::ostream&>::type operator<<(std::ostream & o, const T (&x)[N]) { o << "["; for (int i = 0; i != N; ++i) { if (i) o << ","; o << x[i]; } o << "]"; return o; } int main() { std::vector<int> i; i.push_back(23); i.push_back(34); std::set<std::string> j; j.insert("hello"); j.insert("world"); double k[] = { 1.1, 2.2, M_PI, -1.0/123.0 }; std::cout << i << "\n" << j << "\n" << k << "\n"; }
int main() { std::cout << std::vector<int>{1,2,3,4,5}; return 0; }
int main() { std::cout << pretty::decoration<std::vector<int>>("(", ",", ")"); std::cout << std::vector<int>{1,2,3,4,5}; return 0; }
PRETTY_DEFAULT_DECORATION(std::vector<int>, "{", ", ", "}") int main() { std::cout << std::vector<int>{1,2,3,4,5}; std::cout << pretty::decoration<std::vector<int>>("(", ",", ")"); std::cout << std::vector<int>{1,2,3,4,5}; return 0; }
namespace pretty { template<class T, std::size_t N> struct defaulted<T[N]> { static decor<T[N]> decoration() { return{ { "(" }, { ":" }, { ")" } }; } }; }
float e[5] = { 3.4f, 4.3f, 5.2f, 1.1f, 22.2f }; std::cout << e <<
namespace pretty { template< __VA_ARGS__ > struct defaulted< TYPE > { static decor< TYPE > decoration() { return { PREFIX, DELIM, POSTFIX }; } }; }
PRETTY_DEFAULT_DECORATION(T[N], "", ";", "", class T, std::size_t N)
PRETTY_DEFAULT_DECORATION(std::vector<int>, "(", ", ", ")")
float e[3] = { 3.4f, 4.3f, 5.2f }; std::stringstream u; u << pretty::decoration<float[3]>("{", "; ", "}"); u << e << std::cout << e;
PRETTY_DEFAULT_DECORATION(float[3], "{{{", ",", "}}}") std::stringstream v; v << e; v << pretty::decoration<float[3]>(":"); v << e; v << pretty::decoration<float[3]>("((", "=", "))"); v << e;
std::vector<std::vector<int>> m{ {1,2,3}, {4,5,6}, {7,8,9} }; std::cout << pretty::decoration<std::vector<std::vector<int>>>("\n"); std::cout << m;
namespace pretty { template< __VA_ARGS__ >\ struct defaulted< TYPE > {\ static decor< TYPE > decoration(){\ return { PREFIX, DELIM, POSTFIX };\ } }; } namespace pretty { template< __VA_ARGS__ >\ struct defaulted< TYPE, wchar_t, std::char_traits<wchar_t> > {\ static decor< TYPE, wchar_t, std::char_traits<wchar_t> > decoration(){\ return { PREFIX, DELIM, POSTFIX };\ } }; } namespace pretty { namespace detail { using std::begin; using std::end; template <int I> using _ol = std::integral_constant<int, I>*; template<class T> class is_range { template <class U, _ol<0> = nullptr> static std::false_type b(...); template <class U, _ol<1> = nullptr> static auto b(U &v) -> decltype(begin(v), std::true_type()); template <class U, _ol<0> = nullptr> static std::false_type e(...); template <class U, _ol<1> = nullptr> static auto e(U &v) -> decltype(end(v), std::true_type()); using b_return = decltype(b<T>(std::declval<T&>())); using e_return = decltype(e<T>(std::declval<T&>())); public: static const bool value = b_return::value && e_return::value; }; } template<class T, class CharT = char, class TraitT = std::char_traits<CharT>> struct decor { static const int xindex; std::basic_string<CharT, TraitT> prefix, delimiter, postfix; decor(std::basic_string<CharT, TraitT> const & pre = "", std::basic_string<CharT, TraitT> const & delim = "", std::basic_string<CharT, TraitT> const & post = "") : prefix(pre), delimiter(delim), postfix(post) {} }; template<class T, class charT, class traits> int const decor<T, charT, traits>::xindex = std::ios_base::xalloc(); namespace detail { template<class T, class CharT, class TraitT> void manage_decor(std::ios_base::event evt, std::ios_base &s, int const idx) { using deco_type = decor<T, CharT, TraitT>; if (evt == std::ios_base::erase_event) { void const * const p = s.pword(idx); if (p) { delete static_cast<deco_type const * const>(p); s.pword(idx) = nullptr; } } else if (evt == std::ios_base::copyfmt_event) { void const * const p = s.pword(idx); if (p) { auto np = new deco_type{ *static_cast<deco_type const * const>(p) }; s.pword(idx) = static_cast<void*>(np); } } } template<class T> struct clearer {}; template<class T, class CharT, class TraitT> std::basic_ostream<CharT, TraitT>& operator<< ( std::basic_ostream<CharT, TraitT> &s, clearer<T> const &) { using deco_type = decor<T, CharT, TraitT>; void const * const p = s.pword(deco_type::xindex); if (p) { delete static_cast<deco_type const *>(p); s.pword(deco_type::xindex) = nullptr; } return s; } template <class CharT> struct default_data { static const CharT * decor[3]; }; template <> const char * default_data<char>::decor[3] = { "", ", ", "" }; template <> const wchar_t * default_data<wchar_t>::decor[3] = { L"", L", ", L"" }; } template<class T> detail::clearer<T> clear() { return{}; } template<class T, class CharT, class TraitT> void clear(std::basic_ostream<CharT, TraitT> &s) { s << detail::clearer<T>{}; } template<class T, class CharT, class TraitT> std::basic_ostream<CharT, TraitT>& operator<<( std::basic_ostream<CharT, TraitT> &s, decor<T, CharT, TraitT> && h) { using deco_type = decor<T, CharT, TraitT>; void const * const p = s.pword(deco_type::xindex); if (p) delete static_cast<deco_type const *>(p); s.pword(deco_type::xindex) = static_cast<void *>(new deco_type{ std::move(h) }); if (s.iword(deco_type::xindex) == 0) { s.register_callback(detail::manage_decor<T, CharT, TraitT>, deco_type::xindex); s.iword(deco_type::xindex) = 1; } return s; } template<class T, class CharT = char, class TraitT = std::char_traits<CharT>> struct defaulted { static inline decor<T, CharT, TraitT> decoration() { return{ detail::default_data<CharT>::decor[0], detail::default_data<CharT>::decor[1], detail::default_data<CharT>::decor[2] }; } }; template<class T, class CharT = char, class TraitT = std::char_traits<CharT>> decor<T, CharT, TraitT> decoration( std::basic_string<CharT, TraitT> const & prefix, std::basic_string<CharT, TraitT> const & delimiter, std::basic_string<CharT, TraitT> const & postfix) { return{ prefix, delimiter, postfix }; } template<class T, class CharT = char, class TraitT = std::char_traits < CharT >> decor<T, CharT, TraitT> decoration( std::basic_string<CharT, TraitT> const & delimiter) { using str_type = std::basic_string<CharT, TraitT>; return{ defaulted<T, CharT, TraitT>::decoration().prefix, delimiter, defaulted<T, CharT, TraitT>::decoration().postfix }; } template<class T, class CharT = char, class TraitT = std::char_traits < CharT >> decor<T, CharT, TraitT> decoration(CharT const * const prefix, CharT const * const delimiter, CharT const * const postfix) { using str_type = std::basic_string<CharT, TraitT>; return{ str_type{ prefix }, str_type{ delimiter }, str_type{ postfix } }; } template<class T, class CharT = char, class TraitT = std::char_traits < CharT >> decor<T, CharT, TraitT> decoration(CharT const * const delimiter) { using str_type = std::basic_string<CharT, TraitT>; return{ defaulted<T, CharT, TraitT>::decoration().prefix, str_type{ delimiter }, defaulted<T, CharT, TraitT>::decoration().postfix }; } template<typename T, std::size_t N, std::size_t L> struct tuple { template<class CharT, class TraitT> static void print(std::basic_ostream<CharT, TraitT>& s, T const & value, std::basic_string<CharT, TraitT> const &delimiter) { s << std::get<N>(value) << delimiter; tuple<T, N + 1, L>::print(s, value, delimiter); } }; template<typename T, std::size_t N> struct tuple<T, N, N> { template<class CharT, class TraitT> static void print(std::basic_ostream<CharT, TraitT>& s, T const & value, std::basic_string<CharT, TraitT> const &) { s << std::get<N>(value); } }; } template<class CharT, class TraitT> std::basic_ostream<CharT, TraitT> & operator<< ( std::basic_ostream<CharT, TraitT> &s, std::tuple<> const & v) { using deco_type = pretty::decor<std::tuple<void*>, CharT, TraitT>; using defaulted_type = pretty::defaulted<std::tuple<void*>, CharT, TraitT>; void const * const p = s.pword(deco_type::xindex); auto const d = static_cast<deco_type const * const>(p); s << (d ? d->prefix : defaulted_type::decoration().prefix); s << (d ? d->postfix : defaulted_type::decoration().postfix); return s; } template<class CharT, class TraitT, class ... T> std::basic_ostream<CharT, TraitT> & operator<< ( std::basic_ostream<CharT, TraitT> &s, std::tuple<T...> const & v) { using deco_type = pretty::decor<std::tuple<void*>, CharT, TraitT>; using defaulted_type = pretty::defaulted<std::tuple<void*>, CharT, TraitT>; using pretty_tuple = pretty::tuple<std::tuple<T...>, 0U, sizeof...(T)-1U>; void const * const p = s.pword(deco_type::xindex); auto const d = static_cast<deco_type const * const>(p); s << (d ? d->prefix : defaulted_type::decoration().prefix); pretty_tuple::print(s, v, d ? d->delimiter : defaulted_type::decoration().delimiter); s << (d ? d->postfix : defaulted_type::decoration().postfix); return s; } template<class T, class U, class CharT, class TraitT> std::basic_ostream<CharT, TraitT> & operator<< ( std::basic_ostream<CharT, TraitT> &s, std::pair<T, U> const & v) { using deco_type = pretty::decor<std::pair<T, U>, CharT, TraitT>; using defaulted_type = pretty::defaulted<std::pair<T, U>, CharT, TraitT>; void const * const p = s.pword(deco_type::xindex); auto const d = static_cast<deco_type const * const>(p); s << (d ? d->prefix : defaulted_type::decoration().prefix); s << v.first; s << (d ? d->delimiter : defaulted_type::decoration().delimiter); s << v.second; s << (d ? d->postfix : defaulted_type::decoration().postfix); return s; } template<class T, class CharT = char, class TraitT = std::char_traits < CharT >> typename std::enable_if < pretty::detail::is_range<T>::value, std::basic_ostream < CharT, TraitT >> ::type & operator<< ( std::basic_ostream<CharT, TraitT> &s, T const & v) { bool first(true); using deco_type = pretty::decor<T, CharT, TraitT>; using default_type = pretty::defaulted<T, CharT, TraitT>; void const * const p = s.pword(deco_type::xindex); auto d = static_cast<pretty::decor<T, CharT, TraitT> const * const>(p); s << (d ? d->prefix : default_type::decoration().prefix); for (auto const & e : v) { if (!first) s << (d ? d->delimiter : default_type::decoration().delimiter); s << e; first = false; } s << (d ? d->postfix : default_type::decoration().postfix); return s; }
namespace details { using std::begin; using std::end; template<class T, class=void> struct is_iterable_test:std::false_type{}; template<class T> struct is_iterable_test<T, decltype((void)( (void)(begin(std::declval<T>())==end(std::declval<T>())) , ((void)(std::next(begin(std::declval<T>())))) , ((void)(*begin(std::declval<T>()))) , 1 )) >:std::true_type{}; template<class T>struct is_tupleoid:std::false_type{}; template<class...Ts>struct is_tupleoid<std::tuple<Ts...>>:std::true_type{}; template<class...Ts>struct is_tupleoid<std::pair<Ts...>>:std::true_type{}; } template<class T>struct is_iterable:details::is_iterable_test<std::decay_t<T>>{}; template<class T, std::size_t N>struct is_iterable<T(&)[N]>:std::true_type{}; template<class T>struct is_tupleoid:details::is_tupleoid<std::decay_t<T>>{}; template<class T>struct is_visitable:std::integral_constant<bool, is_iterable<T>{}||is_tupleoid<T>{}> {};
template<class C, class F> std::enable_if_t<is_iterable<C>{}> visit_first(C&& c, F&& f) { using std::begin; using std::end; auto&& b = begin(c); auto&& e = end(c); if (b==e) return; std::forward<F>(f)(*b); } template<class C, class F> std::enable_if_t<is_iterable<C>{}> visit_all_but_first(C&& c, F&& f) { using std::begin; using std::end; auto it = begin(c); auto&& e = end(c); if (it==e) return; it = std::next(it); for( ; it!=e; it = std::next(it) ) { f(*it); } } namespace details { template<class Tup, class F> void visit_first( std::index_sequence<>, Tup&&, F&& ) {} template<size_t... Is, class Tup, class F> void visit_first( std::index_sequence<0,Is...>, Tup&& tup, F&& f ) { std::forward<F>(f)( std::get<0>( std::forward<Tup>(tup) ) ); } template<class Tup, class F> void visit_all_but_first( std::index_sequence<>, Tup&&, F&& ) {} template<size_t... Is,class Tup, class F> void visit_all_but_first( std::index_sequence<0,Is...>, Tup&& tup, F&& f ) { int unused[] = {0,((void)( f( std::get<Is>(std::forward<Tup>(tup)) ) ),0)...}; (void)(unused); } } template<class Tup, class F> std::enable_if_t<is_tupleoid<Tup>{}> visit_first(Tup&& tup, F&& f) { details::visit_first( std::make_index_sequence< std::tuple_size<std::decay_t<Tup>>{} >{}, std::forward<Tup>(tup), std::forward<F>(f) ); } template<class Tup, class F> std::enable_if_t<is_tupleoid<Tup>{}> visit_all_but_first(Tup&& tup, F&& f) { details::visit_all_but_first( std::make_index_sequence< std::tuple_size<std::decay_t<Tup>>{} >{}, std::forward<Tup>(tup), std::forward<F>(f) ); }
namespace pretty_print { namespace decorator { struct default_tag {}; template<class Old> struct map_magic_tag:Old {}; template<class CharT, class Traits, class...Xs > void pretty_print_before( default_tag, std::basic_ostream<CharT, Traits>& s, std::map<Xs...> const& ) { s << CharT( } template<class CharT, class Traits, class...Xs > void pretty_print_after( default_tag, std::basic_ostream<CharT, Traits>& s, std::map<Xs...> const& ) { s << CharT( } template<class CharT, class Traits, class Tup > std::enable_if_t<is_tupleoid<Tup>{}> pretty_print_before( default_tag, std::basic_ostream<CharT, Traits>& s, Tup const& ) { s << CharT( } template<class CharT, class Traits, class Tup > std::enable_if_t<is_tupleoid<Tup>{}> pretty_print_after( default_tag, std::basic_ostream<CharT, Traits>& s, Tup const& ) { s << CharT( } template<class CharT, class Traits, class...Xs > void pretty_print_before( default_tag, std::basic_ostream<CharT, Traits>& s, std::basic_string<CharT, Xs...> const& ) { s << CharT( } template<class CharT, class Traits, class...Xs > void pretty_print_after( default_tag, std::basic_ostream<CharT, Traits>& s, std::basic_string<CharT, Xs...> const& ) { s << CharT( } template<class CharT, class Traits, class...Xs > void pretty_print_between( default_tag, std::basic_ostream<CharT, Traits>&, std::basic_string<CharT, Xs...> const& ) {} template<class...Xs> map_magic_tag<default_tag> pretty_print_descend( default_tag, std::map<Xs...> const& ) { return {}; } template<class old_tag, class C> old_tag pretty_print_descend( map_magic_tag<old_tag>, C const& ) { return {}; } template<class old_tag, class CharT, class Traits, class...Xs > void pretty_print_between( map_magic_tag<old_tag>, std::basic_ostream<CharT, Traits>& s, std::pair<Xs...> const& ) { s << CharT( } } template<class CharT, class Traits, class Tag, class Container > void pretty_print_before( Tag const&, std::basic_ostream<CharT, Traits>& s, Container const& ) { s << CharT( } template<class CharT, class Traits, class Tag, class Container > void pretty_print_after( Tag const&, std::basic_ostream<CharT, Traits>& s, Container const& ) { s << CharT( } template<class CharT, class Traits, class Tag, class Container > void pretty_print_between( Tag const&, std::basic_ostream<CharT, Traits>& s, Container const& ) { s << CharT( } template<class Tag, class Container> Tag&& pretty_print_descend( Tag&& tag, Container const& ) { return std::forward<Tag>(tag); } template<class Tag=decorator::default_tag, class Scalar, class CharT, class Traits> std::enable_if_t<!is_visitable<Scalar>{}> print( std::basic_ostream<CharT, Traits>& os, Scalar&& scalar, Tag&&=Tag{} ) { os << std::forward<Scalar>(scalar); } template<class Tag=decorator::default_tag, class C, class CharT, class Traits> std::enable_if_t<is_visitable<C>{}> print( std::basic_ostream<CharT, Traits>& os, C&& c, Tag&& tag=Tag{} ) { pretty_print_before( std::forward<Tag>(tag), os, std::forward<C>(c) ); visit_first( c, [&](auto&& elem) { print( os, std::forward<decltype(elem)>(elem), pretty_print_descend( std::forward<Tag>(tag), std::forward<C>(c) ) ); }); visit_all_but_first( c, [&](auto&& elem) { pretty_print_between( std::forward<Tag>(tag), os, std::forward<C>(c) ); print( os, std::forward<decltype(elem)>(elem), pretty_print_descend( std::forward<Tag>(tag), std::forward<C>(c) ) ); }); pretty_print_after( std::forward<Tag>(tag), os, std::forward<C>(c) ); } }
int main() { std::vector<int> x = {1,2,3}; pretty_print::print( std::cout, x ); std::cout << "\n"; std::map< std::string, int > m; m["hello"] = 3; m["world"] = 42; pretty_print::print( std::cout, m ); std::cout << "\n"; }
class Base { public: typedef unique_ptr<Base> UPtr; Base(){} Base(Base::UPtr n):next(std::move(n)){} virtual ~Base(){} void setNext(Base::UPtr n) { next = std::move(n); } protected : Base::UPtr next; };
Base::UPtr b1; Base::UPtr b2(new Base()); b1->setNext(b2);
Base(std::unique_ptr<Base> n) : next(std::move(n)) {}
Base newBase(std::move(nextBase)); Base fromTemp(std::unique_ptr<Base>(new Base(...));
Base(std::unique_ptr<Base> &n) : next(std::move(n)) {}
Base(std::unique_ptr<Base> &&n) : next(std::move(n)) {}
std::unique_ptr<Base> &&temporary = std::move(oldPtr); std::unique_ptr<Base> newPtr(temporary);
struct node; typedef std::unique_ptr<node> list; struct node { int entry; list next; }
size_t length(const node* p) { size_t l=0; for ( ; p!=nullptr; p=p->next.get()) ++l; return l; }
list copy(const node* p) { return list( p==nullptr ? nullptr : new node{p->entry,copy(p->next.get())} ); }
void f(std::shared_ptr<X> x) { container.insert(std::move(x)); } void client() { std::shared_ptr<X> p = std::make_shared<X>(args); f(p); f(std::make_shared<X>(args)); f(std::move(p)); }
void prepend (int x, list& l) { l = list( new node{ x, std::move(l)} ); }
void remove_first(int x, list& l) { list* p = &l; while ((*p).get()!=nullptr and (*p)->entry!=x) p = &(*p)->next; if ((*p).get()!=nullptr) (*p).reset((*p)->next.release()); }
void append (list& a, list&& b) { list* p=&a; while ((*p).get()!=nullptr) p=&(*p)->next; *p = std::move(b); }
list reversed (list&& l) noexcept { list p(l.release()); list result(nullptr); while (p.get()!=nullptr) { result.swap(p->next); result.swap(p); } return result; }
Base(Base::UPtr &&n) : next(::std::move(n)) {} void setNext(Base::UPtr &&n) { next = ::std::move(n); }
Base::UPtr objptr{ new Base; } Base::UPtr objptr2{ new Base; } Base fred(::std::move(objptr)); fred.setNext(::std::move(objptr2));
Base(Base::UPtr&& n):next(std::forward<Base::UPtr>(n)) {}
class Configuration; namespace MyApp { class Configuration; function blah() { Configuration::doStuff(...) ::Configuration::doStuff(...) } }
int count = 0; int main(void) { int count = 0; ::count = 1; count = 2; return 0; }
class A { void DoSomething() { m_counter=0; ... Twist(data); ... Bend(data); ... if(m_counter>0) exit(0); } int m_couner; ... }
void add_one(int& n) { n += 1; } void add_one(int* const n) { *n += 1; } int main() { int a = 0; add_one(a); add_one(&a); }
bool GetFooArray(array &foo); bool GetFooArray(array *foo);
class SimCard { public: explicit SimCard(int id): m_id(id) { } int getId() const { return m_id; } private: int m_id; }; class RefPhone { public: explicit RefPhone(const SimCard & card): m_card(card) { } int getSimId() { return m_card.getId(); } private: const SimCard & m_card; };
PtrPhone nullPhone(0); SimCard * cardPtr = new SimCard(666); delete cardPtr; PtrPhone uninitPhone(cardPtr);
RefPhone tempPhone(SimCard(666)); tempPhone.getSimId();
void fun(int *a) { cout<<a<< cout<<*a<< cout<<a+1<< cout<<*(a+1)<< } void fun(int &a) { cout<<a<< } int a=5; fun(&a); fun(a);
const char *text = "This text is pretty long, but will be " "concatenated into just a single string. " "The disadvantage is that you have to quote " "each part, and newlines must be literal as " "usual.";
const char * vogon_poem = R"V0G0N( O freddled gruntbuggly thy micturations are to me As plured gabbleblochits on a lurgid bee. Groop, I implore thee my foonting turlingdromes. And hooptiously drangle me with crinkly bindlewurdles, Or I will rend thee in the gobberwarts with my blurlecruncheon, see if I don (by Prostetnic Vogon Jeltz; see p. 56/57) )V0G0N";
const char *text = MULTI_LINE_STRING( Using this trick(,) you don Though newlines and multiple white spaces will be replaced by a single whitespace. ); printf("[[%s]]\n",text);
const char *text = "This is my string it is " "very long";
const char *text = "This text is pretty long, but will be\n" "concatenated into just a single string.\n" "The disadvantage is that you have to quote\n" "each part, and newlines must be literal as\n" "usual.";
std::packaged_task<int(double, char, bool)> tsk(foo); auto fut = tsk.get_future();
template <typename> class my_task; template <typename R, typename ...Args> class my_task<R(Args...)> { std::function<R(Args...)> fn; std::promise<R> pr; public: template <typename ...Ts> explicit my_task(Ts &&... ts) : fn(std::forward<Ts>(ts)...) { } template <typename ...Ts> void operator()(Ts &&... ts) { pr.set_value(fn(std::forward<Ts>(ts)...)); } std::future<R> get_future() { return pr.get_future(); } };
int test(); int main() { try { return test(); } catch (std::future_error const & e) { std::cout << "Future error: " << e.what() << " / " << e.code() << std::endl; } catch (std::exception const & e) { std::cout << "Standard exception: " << e.what() << std::endl; } catch (...) { std::cout << "Unknown exception." << std::endl; } }
int test() { std::promise<int> pr; auto fut = pr.get_future(); return 0; }
int test() { std::promise<int> pr; auto fut1 = pr.get_future(); auto fut2 = pr.get_future(); return 0; }
int test() { std::promise<int> pr; auto fut = pr.get_future(); { std::promise<int> pr2(std::move(pr)); pr2.set_value(10); } return fut.get(); }
int test() { std::promise<int> pr; auto fut = pr.get_future(); { std::promise<int> pr2(std::move(pr)); pr2.set_value(10); pr2.set_value(10); } return fut.get(); }
int test() { std::promise<int> pr; auto fut = pr.get_future(); { std::promise<int> pr2(std::move(pr)); pr2.set_exception(std::make_exception_ptr(std::runtime_error("Booboo"))); } return fut.get(); }
int test() { std::promise<int> pr; auto fut = pr.get_future(); { std::promise<int> pr2(std::move(pr)); } return fut.get(); }
promise<int> intPromise; future<int> intFuture = intPromise.get_future(); std::thread t(asyncFun, std::move(intPromise)); int result = intFuture.get();
// static std::atomic<int> kount(1); template<typename Ttype> class Sync_queue { public: void put(const Ttype &val); void get(Ttype &val); private: std::mutex mtx; std::condition_variable cond; std::list <Ttype> q; }; template<typename Ttype> void Sync_queue<Ttype>::put(const Ttype &val) { std::lock_guard <std::mutex> lck(mtx); q.push_back(val); cond.notify_one(); } template<typename Ttype> void Sync_queue<Ttype>::get(Ttype &val) { std::unique_lock<std::mutex> lck(mtx); cond.wait(lck, [this]{return !q.empty(); }); val = q.front(); q.pop_front(); } void func(std::promise<int> &jj) { int myId = std::atomic_fetch_add(&kount, 1); std::future<int> intFuture(jj.get_future()); auto ll = intFuture.get(); std::cout << " func " << myId << " future " << ll << std::endl; } void func2(std::promise<int> &jj, std::promise<int>&pp) { int myId = std::atomic_fetch_add(&kount, 1); std::future<int> intFuture(jj.get_future()); auto ll = intFuture.get(); auto promiseValue = ll * 100; pp.set_value(promiseValue); std::cout << " func2 " << myId << " promised " << promiseValue << " ll was " << ll << std::endl; } void func3(Sync_queue<int> &q, int iBegin, int iEnd, int *pInts) { int myId = std::atomic_fetch_add(&kount, 1); int ll; q.get(ll); while (ll > 0) { std::cout << " func3 " << myId << " start loop base " << ll << " " << iBegin << " to " << iEnd << std::endl; for (int i = iBegin; i < iEnd; i++) { pInts[i] = ll + i; } q.get(ll); } } int _tmain(int argc, _TCHAR* argv[]) { std::chrono::milliseconds myDur(1000); std::cout << "MAIN std::promise<int> intPromiseT1; std::thread t1(func, std::ref(intPromiseT1)); std::promise<int> intPromiseT2; std::promise<int> intPromiseT3; std::thread t2(func2, std::ref(intPromiseT2), std::ref(intPromiseT3)); std::promise<int> intPromiseMain; std::thread t3(func2, std::ref(intPromiseT3), std::ref(intPromiseMain)); std::this_thread::sleep_for(myDur); std::cout << "MAIN intPromiseT1.set_value(22); std::this_thread::sleep_for(myDur); std::cout << "MAIN std::this_thread::sleep_for(myDur); intPromiseT2.set_value(1001); std::this_thread::sleep_for(myDur); std::cout << "MAIN std::future<int> intFutureMain(intPromiseMain.get_future()); auto t3Promised = intFutureMain.get(); std::cout << "MAIN t1.join(); t2.join(); t3.join(); int iArray[100]; Sync_queue<int> q1; Sync_queue<int> q2; std::thread t11(func3, std::ref(q1), 0, 5, iArray); std::this_thread::sleep_for(myDur); std::thread t12(func3, std::ref(q2), 10, 15, iArray); std::this_thread::sleep_for(myDur); for (int i = 0; i < 5; i++) { std::cout << "MAIN std::this_thread::sleep_for(myDur); q1.put(i + 100); std::this_thread::sleep_for(myDur); q2.put(i + 1000); std::this_thread::sleep_for(myDur); } q1.put(-1); q2.put(-1); t11.join(); t12.join(); return 0; }
MAIN MAIN func 1 future 22 MAIN func2 2 promised 100100 ll was 1001 func2 3 promised 10010000 ll was 100100 MAIN MAIN MAIN func3 4 start loop base 100 0 to 5 func3 5 start loop base 1000 10 to 15 MAIN func3 4 start loop base 101 0 to 5 func3 5 start loop base 1001 10 to 15 MAIN func3 4 start loop base 102 0 to 5 func3 5 start loop base 1002 10 to 15 MAIN func3 4 start loop base 103 0 to 5 func3 5 start loop base 1003 10 to 15 MAIN func3 4 start loop base 104 0 to 5 func3 5 start loop base 1004 10 to 15
bool isnan( float arg ); (since C++11) bool isnan( double arg ); (since C++11) bool isnan( long double arg ); (since C++11)
template <class T> bool isfinite(T z); template <class T> bool isinf(T t); template <class T> bool isnan(T t); template <class T> bool isnormal(T t);
void foo( double a, double b ) { assert( a != b ); } int main() { typedef std::numeric_limits<double> Info; double const nan1 = Info::quiet_NaN(); double const nan2 = Info::quiet_NaN(); foo( nan1, nan2 ); }
bool custom_isnan(double var) { volatile double d = var; return d != d; }
using namespace std; int main( ) { cout << "The quiet NaN for type float is: " << numeric_limits<float>::quiet_NaN( ) << endl; float f_nan = numeric_limits<float>::quiet_NaN(); if( isnan(f_nan) ) { cout << "Float was Not a Number: " << f_nan << endl; } return 0; }
float x=0.f ; if( !x ) x = FLT_MIN ; float y = 0.f / x ;
float x=0.f, y=0.f, z; if( !x && !y ) z = FLT_MAX ; else z = y/x ;
inline bool IsNan(float f) { const uint32 u = *(uint32*)&f; return (u&0x7F800000) == 0x7F800000 && (u&0x7FFFFF); } inline bool IsNan(double d) { const uint64 u = *(uint64*)&d; return (u&0x7FF0000000000000ULL) == 0x7FF0000000000000ULL && (u&0xFFFFFFFFFFFFFULL); }
using namespace std; [&](){ \ const auto value = x; \ const bool result = expr; \ ostringstream stream; \ stream << boolalpha << cout \ << setw( 60 ) << stream.str() << " " \ << (result == expected? "Success" : "FAILED") \ << endl; \ }() TEST( v, expression, true ); \ TEST( u, expression, false ); \ TEST( w, expression, false ) using Fp_info = numeric_limits<double>; inline auto is_ieee754_nan( double const x ) -> bool { static constexpr bool is_claimed_ieee754 = Fp_info::is_iec559; static constexpr int n_bits_per_byte = CHAR_BIT; using Byte = unsigned char; static_assert( is_claimed_ieee754, "!" ); static_assert( n_bits_per_byte == 8, "!" ); static_assert( sizeof( x ) == sizeof( uint64_t ), "!" ); uint64_t const bits = reinterpret_cast<uint64_t const&>( x ); Byte bytes[sizeof(x)]; memcpy( bytes, &x, sizeof( x ) ); uint64_t int_value; memcpy( &int_value, bytes, sizeof( x ) ); uint64_t const& bits = int_value; static constexpr uint64_t sign_mask = 0x8000000000000000; static constexpr uint64_t exp_mask = 0x7FF0000000000000; static constexpr uint64_t mantissa_mask = 0x000FFFFFFFFFFFFF; (void) sign_mask; return (bits & exp_mask) == exp_mask and (bits & mantissa_mask) != 0; } auto main() -> int { double const v = Fp_info::quiet_NaN(); double const u = 3.14; double const w = Fp_info::infinity(); cout << boolalpha << left; cout << "Compiler claims IEEE 754 = " << Fp_info::is_iec559 << endl; cout << endl;; TEST_ALL_VARIABLES( std::isnan(value) ); cout << endl; TEST_ALL_VARIABLES( (fpclassify(value) == FP_NAN) ); cout << endl; TEST_ALL_VARIABLES( (value != value) ); cout << endl; TEST_ALL_VARIABLES( (value == Fp_info::quiet_NaN()) ); cout << endl; TEST_ALL_VARIABLES( (ilogb(value) == FP_ILOGBNAN) ); cout << endl; TEST_ALL_VARIABLES( isunordered(1.2345, value) ); cout << endl; TEST_ALL_VARIABLES( is_ieee754_nan( value ) ); }
template<class T> bool isnan( T f ) { T _nan = (T)0.0/(T)0.0; return 0 == memcmp( (void*)&f, (void*)&_nan, sizeof(T) ); }
/* Portable warning-free NaN test: * Does not emit warning with -Wfloat-equal (does not use float comparisons) * Works with -O3 -ffast-math (floating-point optimization) * Only call to standard library is memset and memcmp via <cstring> * Works for IEEE 754 compliant floating-point representations * Also works for extended precision long double */ template <class T> bool isNaN(T x) { T z[4]; memset(z, 0, sizeof(z)); z[1] = -z[0]; z[2] = x; z[3] = z[0] / z[2]; /*Rationale for following test: * x is 0 or -0 --> z[2] = 0, z[3] = NaN * x is a negative or positive number --> z[3] = 0 * x is a negative or positive denormal number --> z[3] = 0 * x is negative or positive infinity --> z[3] = 0 (IEEE 754 guarantees that 0 / inf is zero) * x is a NaN --> z[3] = NaN != 0. */ bool z2IsZero = memcmp(&z[2], &z[0], sizeof(T)) == 0 || memcmp(&z[2], &z[1], sizeof(T)) == 0; bool z3IsZero = memcmp(&z[3], &z[0], sizeof(T)) == 0 || memcmp(&z[3], &z[1], sizeof(T)) == 0; return !z2IsZero && !z3IsZero; } template <class T> void test(bool printNaN) { T v[10] = {-0.0, 0.0, -1.0, 1.0, std::numeric_limits<T>::infinity(), -std::numeric_limits<T>::infinity(), std::numeric_limits<T>::denorm_min(), -std::numeric_limits<T>::denorm_min(), std::numeric_limits<T>::quiet_NaN(), std::numeric_limits<T>::signaling_NaN()}; for(int i = 0; i < 10; i++) { for(int j = 0; j < 10; j++) { if(isNaN(v[i] + v[j]) == printNaN) std::cout << v[i] << "+" << v[j] << " = " << v[i] + v[j] << std::endl; if(isNaN(v[i] - v[j]) == printNaN) std::cout << v[i] << "-" << v[j] << " = " << v[i] - v[j] << std::endl; if(isNaN(v[i] * v[j]) == printNaN) std::cout << v[i] << "*" << v[j] << " = " << v[i] * v[j] << std::endl; if(isNaN(v[i] / v[j]) == printNaN) std::cout << v[i] << "/" << v[j] << " = " << v[i] / v[j] << std::endl; } } } int main() { std::cout << "NaNs:" << std::endl; test<float>(true); test<double>(true); test<long double>(true); std::cout << std::endl << "Not NaNs:" << std::endl; test<float>(false); test<double>(false); test<long double>(false); return 0; }
using namespace std; int main () { char ch= double val = nan(&ch); if(isnan(val)) cout << "isnan" << endl; return 0; }
union NaN { uint64_t bits; double num; }; int main() { double d = 0.0 / 0.0; union NaN n; n.num = d; if((n.bits | 0x800FFFFFFFFFFFFF) == 0xFFFFFFFFFFFFFFFF) { printf("NaN: %f", d); } return 0; }
double x, y = -1.1; x = sqrt(y); if (x >= DBL_MIN && x <= DBL_MAX ) cout << "DETECTOR-2 of errors FAILS" << endl; else cout << "DETECTOR-2 of errors OK" << endl;
bool IsNan(float a) { char s[4]; sprintf(s, "%.3f", a); if (s[0]== else return false; }
class Child { friend class Mother; public: string name( void ); protected: void setName( string newName ); };
namespace utils { class f { private: typedef int int_type; int_type value; public: friend f operator+(f const& a, f const& b) { return f(a.value + b.value); } int getValue() const { return value; } }; } int main() { utils::f a, b; std::cout << (a + b).getValue(); }
template<typename Derived> struct Policy { void doSomething() { some_type const& t = static_cast<Derived*>(this)->getSomething(); } }; template<template<typename> class SomePolicy> struct FlexibleClass : private SomePolicy<FlexibleClass> { friend class SomePolicy<FlexibleClass>; void doStuff() { this->doSomething(); } some_type getSomething(); };
class c1 { public: int x; }; class c2 { public: int foo(); private: int x; }; class c3 { friend int foo(); private: int x; };
class c4 { public: int getx(); void setx(int x); private: int x; };
class Parent; class Object { private: void setParent(Parent&); friend void addChild(Parent& parent, Object& child); }; class Parent : public Object { private: void addChild(Object& child); friend void addChild(Parent& parent, Object& child); }; void addChild(Parent& parent, Object& child) { if( &parent == &child ){ wetPants(); } parent.addChild(child); child.setParent(parent); }
class Fred; class FredBase { private: friend class Fred; FredBase() { } }; class Fred : private virtual FredBase { public: ... };
template<typename T> class FriendIdentity { public: typedef T me; }; /** * A class to get access to protected stuff in unittests. Don * directly, use friendMe() instead. */ template<class ToFriend, typename ParentClass> class Friender: public ParentClass { public: Friender() {} virtual ~Friender() {} private: friend ToFriend; friend class FriendIdentity<ToFriend>::me; }; /** * Gives access to protected variables/functions in unittests. * Usage: <code>friendMe(this, someprotectedobject).someProtectedMethod();</code> */ template<typename Tester, typename ParentClass> Friender<Tester, ParentClass> & friendMe(Tester * me, ParentClass & instance) { return (Friender<Tester, ParentClass> &)(instance); }
friendMe(this, someClassInstance).someProtectedFunction();
class Beer { public: friend bool equal(Beer a, Beer b); private: };
class Birds { public: friend Birds operator +(Birds, Birds); private: int numberInFlock; }; Birds operator +(Birds b1, Birds b2) { Birds temp; temp.numberInFlock = b1.numberInFlock + b2.numberInFlock; return temp; }
class MySingleton { private: MySingleton() {} friend MySingleton& GetMySingleton(); } MySingleton& GetMySingleton(); MySingleton& GetMySingleton() { static MySingleton theInstance; return theInstance; }
friend ostream& operator<<(ostream& output, const Point& p);
class A { public: void need_your_data(B & myBuddy) { myBuddy.take_this_name(name_); } private: string name_; }; class B { public: void print_buddy_name(A & myBuddy) { myBuddy.need_your_data(*this); } void take_this_name(const string & name) { cout << name; } };
using namespace std; class Rectangle { int width, height; public: Rectangle() {} Rectangle (int x, int y) : width(x), height(y) {} int area() {return width * height;} friend Rectangle duplicate (const Rectangle&); }; Rectangle duplicate (const Rectangle& param) { Rectangle res; res.width = param.width*2; res.height = param.height*2; return res; } int main () { Rectangle foo; Rectangle bar (2,3); foo = duplicate (bar); cout << foo.area() << return 0; }
class ClubHouse { public: friend class VIPMember; private: unsigned nonMembers_; unsigned paidMembers_; unsigned vipMembers; std::vector<Member> members_; public: ClubHouse() : nonMembers_(0), paidMembers_(0), vipMembers(0) {} addMember( const Member& member ) { void updateMembership( unsigned memberID, Member::MembershipType type ) { Amenity getAmenity( unsigned memberID ) { protected: void joinVIPEvent( unsigned memberID ) { };
class Member { public: enum MemberShipType { NON_MEMBER_PAID_EVENT, PAID_MEMBERSHIP, VIP_MEMBERSHIP, }; protected: MemberShipType type_; unsigned id_; Amenity amenity_; public: Member( unsigned id, MemberShipType type ) : id_(id), type_(type) {} virtual ~Member(){} unsigned getId() const { return id_; } MemberShipType getType() const { return type_; } virtual void getAmenityFromClubHouse() = 0 }; class NonMember : public Member { public: explicit NonMember( unsigned id ) : Member( id, MemberShipType::NON_MEMBER_PAID_EVENT ) {} void getAmenityFromClubHouse() override { Amenity = ClubHouse::getAmenity( this->id_ ); } }; class PaidMember : public Member { public: explicit PaidMember( unsigned id ) : Member( id, MemberShipType::PAID_MEMBERSHIP ) {} void getAmenityFromClubHouse() override { Amenity = ClubHouse::getAmenity( this->id_ ); } }; class VIPMember : public Member { public: friend class ClubHouse; public: explicit VIPMember( unsigned id ) : Member( id, MemberShipType::VIP_MEMBERSHIP ) {} void getAmenityFromClubHouse() override { Amenity = ClubHouse::getAmenity( this->id_ ); } void attendVIPEvent() { ClubHouse::joinVIPEvent( this->id ); } };
class MyFoo { private: static void callback(void * data, void * clientData); void localCallback(); ... };
class MyFoo { friend void callback(void * data, void * callData); void localCallback(); }
class MyFooPrivate; class MyFoo { friend class MyFooPrivate; public: MyFoo(); private: MyFooPrivate _private; };
class MyFooPrivate { public: MyFoo *owner; }; MyFoo::MyFoo() { this->_private->owner = this; }
void foo() { static string plonk = "When will I die?"; }
struct emitter { string str; emitter(const string& s) : str(s) { cout << "Created " << str << endl; } ~emitter() { cout << "Destroyed " << str << endl; } }; void foo(bool skip_first) { if (!skip_first) static emitter a("in if"); static emitter b("in foo"); } int main(int argc, char*[]) { foo(argc != 2); if (argc == 3) foo(false); }
C:\> sample.exe 1 2 Created in foo Created in if Destroyed in foo Destroyed in if
int foo (const BigStruct &a); int foo (const BigStruct *a);
void mungerum(char * buffer, const char * mask, int count); void mungerum(char * const buffer, const char * const mask, const int count);
void bytecopy(char * SUPERFLUOUS_CONST dest, const char *source, SUPERFLUOUS_CONST int count);
void bytecopy(char * SUPERFLUOUS_CONST dest, const char *source, SUPERFLUOUS_CONST int count) { while(count--) { *dest++=*source++; } } void bytecopy(char * SUPERFLUOUS_CONST dest, const char *source, SUPERFLUOUS_CONST int count) { for(int i=0;i<count;i++) { dest[i]=source[i]; } }
inline void bytecopyWrapped(char * dest, const char *source, int count) { while(count--) { *dest++=*source++; } } void bytecopy(char * SUPERFLUOUS_CONST dest, const char *source,SUPERFLUOUS_CONST int count) { bytecopyWrapped(dest, source, count); }
class foo { void test(int *pi); }; void foo::test(int * const pi) { }
class foo { void test(int * const pi); }; void foo::test(int *pi) { pi++; }
struct llist { llist * next; }; void walkllist(llist *plist) { llist *pnext; while(plist) { pnext=plist->next; walk(plist); plist=pnext; } } void walkllist(llist * SUPERFLUOUS_CONST plist) { llist * pnotconst=plist; llist *pnext; while(pnotconst) { pnext=pnotconst->next; walk(pnotconst); pnotconst=pnext; } }
bool isZero(int number) { if (number = 0) return true; else return false; }
void foo(Bar *p) { if (++(p->*member) > 0) { ... } }
int SomeClass::GetValue() const {return m_internalValue;}
const SomeClass* pSomeClass; pSomeClass->GetValue();
class SharedBuffer { private: int fakeData; int const & Get_(int i) const { std::cout << "Accessing buffer element" << std::endl; return fakeData; } public: int & operator[](int i) { Unique(); return const_cast<int &>(Get_(i)); } int const & operator[](int i) const { return Get_(i); } void Unique() { std::cout << "Making buffer unique (expensive operation)" << std::endl; } }; void NonConstF(SharedBuffer x) { x[0] = 1; } void ConstF(const SharedBuffer x) { int q = x[0]; } int main() { SharedBuffer x; NonConstF(x); std::cout << std::endl; ConstF(x); return 0; }
typedef int (EE_STDCALL *Do_SomethingPtr)( int smfID, const char* cursor_name, const char* sql );
Declare Function Do_Something Lib "SomeOther.DLL" (ByRef smfID As Integer, ByVal cursor_name As String, ByVal sql As String) As Integer
template <int N> class Vector: public Matrix<N,1> { };
template <size_t N> struct Vector { typedef Matrix<N, 1> type; };
integer-literal: decimal-literal integer-suffixopt octal-literal integer-suffixopt hexadecimal-literal integer-suffixopt decimal-literal: nonzero-digit decimal-literal digit octal-literal: 0 <--------------------<Here> octal-literal octal-digit
================================================== attempt to open /usr/x86_64-linux-gnu/lib64/libzlib.so failed attempt to open /usr/x86_64-linux-gnu/lib64/libzlib.a failed attempt to open /usr/local/lib64/libzlib.so failed attempt to open /usr/local/lib64/libzlib.a failed attempt to open /lib64/libzlib.so failed attempt to open /lib64/libzlib.a failed attempt to open /usr/lib64/libzlib.so failed attempt to open /usr/lib64/libzlib.a failed attempt to open /usr/x86_64-linux-gnu/lib/libzlib.so failed attempt to open /usr/x86_64-linux-gnu/lib/libzlib.a failed attempt to open /usr/local/lib/libzlib.so failed attempt to open /usr/local/lib/libzlib.a failed attempt to open /lib/libzlib.so failed attempt to open /lib/libzlib.a failed attempt to open /usr/lib/libzlib.so failed attempt to open /usr/lib/libzlib.a failed /usr/bin/ld.bfd.real: cannot find -lzlib
sudo ln -s /usr/lib/libz.so.1.2.8 /usr/lib/libzlib.so
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/taylor
g++ myprogram.cc -o myprogram -lmylib -L/path/foo/bar
/usr/bin/ld: cannot find -lc /usr/bin/ld: cannot find -lltdl /usr/bin/ld: cannot find -lXtst
$ locate libiconv.so /home/user/anaconda3/lib/libiconv.so /home/user/anaconda3/lib/libiconv.so.2 /home/user/anaconda3/lib/libiconv.so.2.5.1 /home/user/anaconda3/lib/preloadable_libiconv.so /home/user/anaconda3/pkgs/libiconv-1.14-0/lib/libiconv.so /home/user/anaconda3/pkgs/libiconv-1.14-0/lib/libiconv.so.2 /home/user/anaconda3/pkgs/libiconv-1.14-0/lib/libiconv.so.2.5.1 /home/user/anaconda3/pkgs/libiconv-1.14-0/lib/preloadable_libiconv.so
sudo chown yourUserName:yourUserName /path/to/.so/file
output("int a[] = {"); for (int i = 0; i < items.length; i++) { output("%s, ", items[i]); } output("};");
for_each(my_inits.begin(), my_inits.end(), [](const std::string& value) { std::cout << value << ",\n"; });
std::cout << "enum Items {\n"; for(Items::iterator i(items.begin()), j(items.end); i != j; ++i) std::cout << *i << ",\n"; std::cout << "};\n";
print("enum Items {") print(",\n".join(items)) print("}")
int main(void) { puts("Line 1"); puts("Line 2"); puts("Line 3"); return EXIT_SUCCESS }
int main() { std::string messages[] = { "Stack Overflow", "Super User", "Server Fault" }; size_t i; for (i = 0; i < ARRAY_SIZE(messages); i++) { std::cout << messages[i] << std::endl; } }
int main() { std::string messages[] = { "Stack Overflow", "Server Fault" "Super User", }; size_t i; for (i = 0; i < ARRAY_SIZE(messages); i++) { std::cout << messages[i] << std::endl; } }
char *available_resources[] = { "color monitor" , "big disk" , "Cray" "on-line drawing routines", "mouse" , "keyboard" , "power cables" , };
class C { C(const C&) = default; C(C&&) = default; C& operator=(const C&) = default; C& operator=(C&&) = default; virtual ~C() { } };
template<class T> class unique_ptr { T* ptr; public: explicit unique_ptr(T* p=0) : ptr(p) {} ~unique_ptr(); unique_ptr(unique_ptr&&); unique_ptr& operator=(unique_ptr&&); };
template<class T> class scoped_ptr { T* ptr; public: explicit scoped_ptr(T* p=0) : ptr(p) {} ~scoped_ptr(); };
template<class T> class scoped_ptr { T* ptr; public: explicit scoped_ptr(T* p=0) : ptr(p) {} ~scoped_ptr(); scoped_ptr(scoped_ptr const&) = delete; scoped_ptr& operator=(scoped_ptr const&) = delete; };
int global_x; int main() { global_x = 5; print_global_x(); }
void print_global_x() { std::cout << global_x << std::endl; }
extern int global_int; cout << "global_int = " << global_int;
$ ./time_hash_map TR1 UNORDERED_MAP (4 byte objects, 10000000 iterations): map_grow 126.1 ns (27427396 hashes, 40000000 copies) 290.9 MB map_predict/grow 67.4 ns (10000000 hashes, 40000000 copies) 232.8 MB map_replace 22.3 ns (37427396 hashes, 40000000 copies) map_fetch 16.3 ns (37427396 hashes, 40000000 copies) map_fetch_empty 9.8 ns (10000000 hashes, 0 copies) map_remove 49.1 ns (37427396 hashes, 40000000 copies) map_toggle 86.1 ns (20000000 hashes, 40000000 copies) STANDARD MAP (4 byte objects, 10000000 iterations): map_grow 225.3 ns ( 0 hashes, 20000000 copies) 462.4 MB map_predict/grow 225.1 ns ( 0 hashes, 20000000 copies) 462.6 MB map_replace 151.2 ns ( 0 hashes, 20000000 copies) map_fetch 156.0 ns ( 0 hashes, 20000000 copies) map_fetch_empty 1.4 ns ( 0 hashes, 0 copies) map_remove 141.0 ns ( 0 hashes, 20000000 copies) map_toggle 67.3 ns ( 0 hashes, 20000000 copies)
g++ -g -O3 --std=c++0x -c -o stdtests.o stdtests.cpp g++ -o stdtests stdtests.o gmurphy@interloper:HashTests$ ./stdtests ** Integer Keys ** unordered: 137 15 ordered: 168 81 ** Random String Keys ** unordered: 55 50 ordered: 33 31 ** Real Words Keys ** unordered: 278 76 ordered: 516 298
Foo& Foo::operator++() { this->data += 1; return *this; } Foo Foo::operator++(int ignored_dummy_value) { Foo tmp(*this); ++(*this); return tmp; }
struct C { C& operator++(); C operator++(int); private: int i_; }; C& C::operator++() { ++i_; return *this; } C C::operator++(int ignored_dummy_value) { C t(*this); ++(*this); return t; }
class Something { public: Something& operator++(); Something operator++(int); private: std::array<int,PACKET_SIZE> data; }; int main () { Something s; for (int i=0; i<1024*1024*30; ++i) ++s; std::clock_t a = clock(); for (int i=0; i<1024*1024*30; ++i) ++s; a = clock() - a; for (int i=0; i<1024*1024*30; ++i) s++; std::clock_t b = clock(); for (int i=0; i<1024*1024*30; ++i) s++; b = clock() - b; std::cout << "a=" << (a/double(CLOCKS_PER_SEC)) << ", b=" << (b/double(CLOCKS_PER_SEC)) << return 0; }
class Something { public: Something& operator++(); Something operator++(int); private: std::array<int,PACKET_SIZE> data; }; Something& Something::operator++() { for (auto it=data.begin(), end=data.end(); it!=end; ++it) ++*it; return *this; } Something Something::operator++(int) { Something ret = *this; ++*this; return ret; }
Flags (--std=c++0x) ++i i++ -DPACKET_SIZE=50 -O1 1.70 2.39 -DPACKET_SIZE=50 -O3 0.59 1.00 -DPACKET_SIZE=500 -O1 10.51 13.28 -DPACKET_SIZE=500 -O3 4.28 6.82
class Something { public: Something& operator++(); Something operator++(int); private: std::array<int,PACKET_SIZE> data; }; Something& Something::operator++() { return *this; } Something Something::operator++(int) { Something ret = *this; ++*this; return ret; }
Flags (--std=c++0x) ++i i++ -DPACKET_SIZE=50 -O1 0.05 0.74 -DPACKET_SIZE=50 -O3 0.08 0.97 -DPACKET_SIZE=500 -O1 0.05 2.79 -DPACKET_SIZE=500 -O3 0.08 2.18 -DPACKET_SIZE=5000 -O3 0.07 21.90
class Foo { public: Foo() { myData=0; } Foo(const Foo &rhs) { myData=rhs.myData; } const Foo& operator++() { this->myData++; return *this; } const Foo operator++(int) { Foo tmp(*this); this->myData++; return tmp; } int GetData() { return myData; } private: int myData; }; int main(int argc, char* argv[]) { Foo testFoo; int count; printf("Enter loop count: "); scanf("%d", &count); for(int i=0; i<count; i++) { testFoo++; } printf("Value: %d\n", testFoo.GetData()); }
for(int i=0; i<10; i++) { testFoo++; } printf("Value: %d\n", testFoo.GetData());
00401000 push 0Ah 00401002 push offset string "Value: %d\n" (402104h) 00401007 call dword ptr [__imp__printf (4020A0h)]
int int::operator++(int& _Val) { int _Original = _Val; _Val += 1; return _Original; }
int main() { int a = 0; a++; int b = 0; ++b; return 0; }
0x0000000100000f24 <main+0>: push %rbp 0x0000000100000f25 <main+1>: mov %rsp,%rbp 0x0000000100000f28 <main+4>: movl $0x0,-0x4(%rbp) 0x0000000100000f2f <main+11>: incl -0x4(%rbp) 0x0000000100000f32 <main+14>: movl $0x0,-0x8(%rbp) 0x0000000100000f39 <main+21>: incl -0x8(%rbp) 0x0000000100000f3c <main+24>: mov $0x0,%eax 0x0000000100000f41 <main+29>: leaveq 0x0000000100000f42 <main+30>: retq
class Data { private: class DataIncrementer { private: Data& _dref; public: DataIncrementer(Data& d) : _dref(d) {} public: ~DataIncrementer() { ++_dref; } }; private: int _data; public: Data() : _data{0} {} public: Data(int d) : _data{d} {} public: Data(const Data& d) : _data{ d._data } {} public: Data& operator=(const Data& d) { _data = d._data; return *this; } public: ~Data() {} public: Data& operator++() { ++_data; return *this; } public: Data operator++(int) { DataIncrementer t(*this); return *this; } public: operator int() { return _data; } }; int main() { Data d(1); std::cout << d << std::cout << ++d << std::cout << d++ << std::cout << d << return 0; }
int main(){ int a = 0; printf("%d", a++); printf("%d", ++a); return 0; }
using namespace std; int main(){ int a = 0; cout << a++; cout << ++a; return 0; }
auto i = 13; auto printable = QStringLiteral("My magic number is %1. That int i = 13; QString printable = QStringLiteral("My magic number is %1. That int i = 13; QString printable = QString::fromLatin1("My magic number is %1. That
QVariant(3.2).toString(); QVariant("5.2").toFloat();
QPoint point(5,1); QString str; QTextStream(&str) << "Mouse click: (" << point.x() << ", " << point.y() << ").";
int i = 10; double d = 10.75; QString str; str.setNum(i); str.setNum(d);
QString QString::arg ( int a, int fieldWidth = 0, int base = 10, const QChar & fillChar = QLatin1Char(
rapidxml::xml_document<char> doc; doc.parse<0>(xmlData); rapidxml::xml_node<char>* root = doc.first_node(); rapidxml::xml_node<char>* node_account = 0; if (GetNodeByElementName(root, "Account", &node_account) == true) { rapidxml::xml_node<char>* node_default = 0; if (GetNodeByElementName(node_account, "default", &node_default) == true) { swprintf(result, 100, L"%hs", node_default->value()); free(xmlData); return true; } } free(xmlData);
int y; cin >> y; double x = sqrt((double)y); if (x != 0 && x < 1) { doStuff(); }
warnif count > 0 let canMethodBeConsideredAsDeadProc = new Func<IMethod, bool>( m => !m.IsPublic && !m.IsEntryPoint && !m.IsClassConstructor && !m.IsVirtual && !(m.IsConstructor && m.IsProtected) && !m.IsGeneratedByCompiler ) let methodsUnused = from m in JustMyCode.Methods where m.NbMethodsCallingMe == 0 && canMethodBeConsideredAsDeadProc(m) select m let deadMethodsMetric = methodsUnused.FillIterative( methods => from o in new[] { new object() } let hashset = methods.ToHashSet() from m in codeBase.Application.Methods.UsedByAny(methods).Except(methods) where canMethodBeConsideredAsDeadProc(m) && hashset.Intersect(m.MethodsCallingMe).Count() == m.NbMethodsCallingMe select m) from m in JustMyCode.Methods.Intersect(deadMethodsMetric.DefinitionDomain) select new { m, m.MethodsCallingMe, depth = deadMethodsMetric[m] }
Warn whenever a variable is unused aside from its declaration, whenever a function is declared static but never defined, whenever a label is declared but not used, and whenever a statement computes a result that is explicitly not used.
This option is intended to warn when the compiler detects that at least a whole line of source code will never be executed, because some condition is never satisfied or because it is after a procedure that never returns.
using namespace std; class Base { public: void NonVirtual() { cout << "Base NonVirtual called.\n"; } virtual void Virtual() { cout << "Base Virtual called.\n"; } }; class Derived : public Base { public: void NonVirtual() { cout << "Derived NonVirtual called.\n"; } void Virtual() { cout << "Derived Virtual called.\n"; } }; int main() { Base* bBase = new Base(); Base* bDerived = new Derived(); bBase->NonVirtual(); bBase->Virtual(); bDerived->NonVirtual(); bDerived->Virtual(); }
Base NonVirtual called. Base Virtual called. Base NonVirtual called. Derived Virtual called.
class Animal { public: virtual int GetNumberOfLegs() = 0; }; class Duck : public Animal { public: int GetNumberOfLegs() { return 2; } }; class Horse : public Animal { public: int GetNumberOfLegs() { return 4; } }; void SomeFunction(Animal * pAnimal) { cout << pAnimal->GetNumberOfLegs(); }
class Shape { public: Shape(); virtual ~Shape(); std::string getName() { return m_name; } void setName( const std::string& name ) { m_name = name; } protected: virtual void initShape() { setName("Generic Shape"); } private: std::string m_name; };
class Square : public Shape { public: Square(); virtual ~Square(); protected: virtual void initShape() { setName("Square"); } }
class Shape { ... virtual void initShape() = 0; ... };
class A { public: virtual void Hello() = 0; }; void A::Hello() { printf("A::Hello\n"); } class B : public A { public: void Hello() { printf("B::Hello\n"); A::Hello(); } }; int main() { B b; b.Hello(); return 0; }
class A { public: virtual void Hello() = 0; }; int main() { A a; return 0; }
$ g++ -c virt.cpp virt.cpp: In function ‘int main()’: virt.cpp:8: error: cannot declare variable ‘a’ to be of abstract type ‘A’ virt.cpp:1: note: because the following virtual functions are pure within ‘A’: virt.cpp:3: note: virtual void A::Hello()
Class Man { public: virtual void do_work() {} } Class Indian : public Man { public: void do_work() {} }
using namespace std; class aClassWithPureVirtualFunction { public: virtual void sayHellow()=0; }; class anotherClass:aClassWithPureVirtualFunction { public: void sayHellow() { cout<<"hellow World"; } }; int main() { anotherClass object; object.sayHellow(); }
using namespace std; class aClassWithPureVirtualFunction { public: virtual void sayHellow() { cout<<"from base\n"; } }; class anotherClass:public aClassWithPureVirtualFunction { public: void sayHellow() { cout<<"from derived \n"; } }; int main() { aClassWithPureVirtualFunction *baseObject=new aClassWithPureVirtualFunction; baseObject->sayHellow(); baseObject=new anotherClass; baseObject->sayHellow(); }
template<class It, class Compare = std::less<>> void xxx_sort(It first, It last, Compare cmp = Compare{});
template<class It> using value_type_t = typename std::iterator_traits<It>::value_type; template<class It, class Compare = std::less<value_type_t<It>>> void xxx_sort(It first, It last, Compare cmp = Compare{});
template<class It, class Compare> void xxx_sort(It first, It last, Compare cmp); template<class It> void xxx_sort(It first, It last) { xxx_sort(first, last, std::less<typename std::iterator_traits<It>::value_type>()); }
template<class FwdIt, class Compare = std::less<>> void selection_sort(FwdIt first, FwdIt last, Compare cmp = Compare{}) { for (auto it = first; it != last; ++it) { auto const selection = std::min_element(it, last, cmp); std::iter_swap(selection, it); assert(std::is_sorted(first, std::next(it), cmp)); } }
template<class FwdIt, class Compare = std::less<>> void insertion_sort(FwdIt first, FwdIt last, Compare cmp = Compare{}) { for (auto it = first; it != last; ++it) { auto const insertion = std::upper_bound(first, it, *it, cmp); std::rotate(insertion, it, std::next(it)); assert(std::is_sorted(first, std::next(it), cmp)); } }
using RevIt = std::reverse_iterator<BiDirIt>; auto const insertion = std::find_if_not(RevIt(it), RevIt(first), [=](auto const& elem){ return cmp(*it, elem); } ).base();
template<class FwdIt, class Compare = std::less<>> void quick_sort(FwdIt first, FwdIt last, Compare cmp = Compare{}) { auto const N = std::distance(first, last); if (N <= 1) return; auto const pivot = *std::next(first, N / 2); auto const middle1 = std::partition(first, last, [=](auto const& elem){ return cmp(elem, pivot); }); auto const middle2 = std::partition(middle1, last, [=](auto const& elem){ return !cmp(pivot, elem); }); quick_sort(first, middle1, cmp); quick_sort(middle2, last, cmp); }
template<class BiDirIt, class Compare = std::less<>> void merge_sort(BiDirIt first, BiDirIt last, Compare cmp = Compare{}) { auto const N = std::distance(first, last); if (N <= 1) return; auto const middle = std::next(first, N / 2); merge_sort(first, middle, cmp); merge_sort(middle, last, cmp); std::inplace_merge(first, middle, last, cmp); }
template<class RandomIt, class Compare = std::less<>> void heap_sort(RandomIt first, RandomIt last, Compare cmp = Compare{}) { lib::make_heap(first, last, cmp); lib::sort_heap(first, last, cmp); }
namespace lib { template<class RandomIt, class Compare = std::less<>> void make_heap(RandomIt first, RandomIt last, Compare cmp = Compare{}) { for (auto it = first; it != last;) { std::push_heap(first, ++it, cmp); assert(std::is_heap(first, it, cmp)); } } template<class RandomIt, class Compare = std::less<>> void sort_heap(RandomIt first, RandomIt last, Compare cmp = Compare{}) { for (auto it = last; it != first;) { std::pop_heap(first, it--, cmp); assert(std::is_heap(first, it, cmp)); } } }
template<typename ForwardIterator> void counting_sort(ForwardIterator first, ForwardIterator last) { if (first == last || std::next(first) == last) return; auto minmax = std::minmax_element(first, last); auto min = *minmax.first; auto max = *minmax.second; if (min == max) return; using difference_type = typename std::iterator_traits<ForwardIterator>::difference_type; std::vector<difference_type> counts(max - min + 1, 0); for (auto it = first ; it != last ; ++it) { ++counts[*it - min]; } for (auto count: counts) { first = std::fill_n(first, count, min++); } }
double gaussian_box_muller() { double x = 0.0; double y = 0.0; double euclid_sq = 0.0; do { x = 2.0 * rand() / static_cast<double>(RAND_MAX)-1; y = 2.0 * rand() / static_cast<double>(RAND_MAX)-1; euclid_sq = x*x + y*y; } while (euclid_sq >= 1.0); return x*sqrt(-2*log(euclid_sq)/euclid_sq); } double monte_carlo_call_price(const int& num_sims, const double& S, const double& K, const double& r, const double& v, const double& T) { double S_adjust = S * exp(T*(r-0.5*v*v)); double S_cur = 0.0; double payoff_sum = 0.0; for (int i=0; i<num_sims; i++) { double gauss_bm = gaussian_box_muller(); S_cur = S_adjust * exp(sqrt(v*v*T)*gauss_bm); payoff_sum += std::max(S_cur - K, 0.0); } return (payoff_sum / static_cast<double>(num_sims)) * exp(-r*T); } double monte_carlo_put_price(const int& num_sims, const double& S, const double& K, const double& r, const double& v, const double& T) { double S_adjust = S * exp(T*(r-0.5*v*v)); double S_cur = 0.0; double payoff_sum = 0.0; for (int i=0; i<num_sims; i++) { double gauss_bm = gaussian_box_muller(); S_cur = S_adjust * exp(sqrt(v*v*T)*gauss_bm); payoff_sum += std::max(K - S_cur, 0.0); } return (payoff_sum / static_cast<double>(num_sims)) * exp(-r*T); } int main(int argc, char **argv) { int num_sims = 10000000; double S = 100.0; double K = 100.0; double r = 0.05; double v = 0.2; double T = 1.0; double call = monte_carlo_call_price(num_sims, S, K, r, v, T); double put = monte_carlo_put_price(num_sims, S, K, r, v, T); std::cout << "Number of Paths: " << num_sims << std::endl; std::cout << "Underlying: " << S << std::endl; std::cout << "Strike: " << K << std::endl; std::cout << "Risk-Free Rate: " << r << std::endl; std::cout << "Volatility: " << v << std::endl; std::cout << "Maturity: " << T << std::endl; std::cout << "Call Price: " << call << std::endl; std::cout << "Put Price: " << put << std::endl; return 0; }
for (int i=0 ; i<512; i++) for (int j=i ; j<UPPER_BOUND ; j+=512) monte_carlo_step(rng_array[j]);
class B : public A { public: MOCK_METHOD0(SomeMethod, void()); };
int main(void) { int i, j; FILE* fp; for (i = 0; i < 500; i++) { char fname[100]; snprintf(fname, 100, "include%d.h", i); fp = fopen(fname, "w"); fprintf(fp, " fprintf(fp, " for (j = 0; j < i; j++) { fprintf(fp, " } fprintf(fp, "int foo%d(void) { return %d; }\n", i, i); fprintf(fp, " fclose(fp); } fp = fopen("main.c", "w"); for (int i = 0; i < 100; i++) { fprintf(fp, " } fprintf(fp, "int main(void){int n;"); for (int i = 0; i < 100; i++) { fprintf(fp, "n += foo%d();\n", i); } fprintf(fp, "return n;}"); fclose(fp); return 0; }
folio[~/Desktop/pragma] fluffy$ gcc pragma.c -DIFNDEF_GUARD folio[~/Desktop/pragma] fluffy$ ./a.out folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.164s user 0m0.105s sys 0m0.041s folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.140s user 0m0.097s sys 0m0.018s folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.193s user 0m0.143s sys 0m0.024s folio[~/Desktop/pragma] fluffy$ gcc pragma.c -DPRAGMA_ONCE folio[~/Desktop/pragma] fluffy$ ./a.out folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.153s user 0m0.101s sys 0m0.031s folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.170s user 0m0.109s sys 0m0.033s folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.155s user 0m0.105s sys 0m0.027s folio[~/Desktop/pragma] fluffy$ gcc pragma.c -DPRAGMA_ONCE -DIFNDEF_GUARD folio[~/Desktop/pragma] fluffy$ ./a.out folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.153s user 0m0.101s sys 0m0.027s folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.181s user 0m0.133s sys 0m0.020s folio[~/Desktop/pragma] fluffy$ time gcc -E main.c > /dev/null real 0m0.167s user 0m0.119s sys 0m0.021s folio[~/Desktop/pragma] fluffy$ gcc --version Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/usr/include/c++/4.2.1 Apple LLVM version 8.1.0 (clang-802.0.42) Target: x86_64-apple-darwin17.0.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
enum class Color { red, green, blue }; enum Animal { dog, cat, bird, human };
enum Color { red, green, blue }; enum Card { red_card, green_card, yellow_card }; enum class Animal { dog, deer, cat, bird, human }; enum class Mammal { kangaroo, deer, human }; void fun() { Color color = Color::red; Card card = Card::green_card; int num = color; if (color == Card::red_card) cout << "bad" << endl; if (card == Color::green) cout << "bad" << endl; Animal a = Animal::deer; Mammal m = Mammal::deer; int num2 = a; if (m == a) cout << "bad" << endl; if (a == Mammal::deer) cout << "bad" << endl; }
enum E_MY_FAVOURITE_FRUITS { E_APPLE = 0x01, E_WATERMELON = 0x02, E_COCONUT = 0x04, E_STRAWBERRY = 0x08, E_CHERRY = 0x10, E_PINEAPPLE = 0x20, E_BANANA = 0x40, E_MANGO = 0x80, E_MY_FAVOURITE_FRUITS_FORCE8 = 0xFF };
enum class E_MY_FAVOURITE_FRUITS : unsigned char { E_APPLE = 0x01, E_WATERMELON = 0x02, E_COCONUT = 0x04, E_STRAWBERRY = 0x08, E_CHERRY = 0x10, E_PINEAPPLE = 0x20, E_BANANA = 0x40, E_MANGO = 0x80, E_DEVIL_FRUIT = 0x100, };
enum class Color1 { red, green, blue }; enum class Color2 { red, green, blue }; enum Color1 { red, green, blue }; enum Color2 { red, green, blue };
enum Color1 { red, green, blue }; enum Color2 { red, green, blue }; int x = red;
enum class Animal{Dog, Cat, Tiger}; enum class Pets{Dog, Parrot};
enum color { Red, Green, Yellow }; enum class NewColor { Red_1, Green_1, Yellow_1 }; int main() { int i = Red; int j = Red_1; int k = NewColor::Red_1; return 0; }
enum vehicle { Car, Bus, Bike, Autorickshow }; enum FourWheeler { Car, SmallBus }; enum class Editor { vim, eclipes, VisualStudio }; enum class CppEditor { eclipes, VisualStudio, QtCreator };
using namespace std; enum class Port : unsigned char; class MyClass { public: void PrintPort(enum class Port p); }; void MyClass::PrintPort(enum class Port p) { cout << (int)p << endl; }
enum class Port : unsigned char { PORT_1 = 0x01, PORT_2 = 0x02, PORT_3 = 0x04 };
using namespace std; int main() { MyClass m; m.PrintPort(Port::PORT_1); return 0; }
enum MyEnum { Value1, Value2, }; ... if (var == Value1 || Value2)
struct TestStruct { int id; TestStruct() : id(42) { } };
struct Example { unsigned int mTest; Example() { } };
struct blocknode { unsigned int bsize; bool free; unsigned char *bptr; blocknode *next; blocknode *prev; blocknode(unsigned int sz, unsigned char *b, bool f = true, blocknode *p = 0, blocknode *n = 0) : bsize(sz), free(f), bptr(b), prev(p), next(n) {} };
unsigned char *bptr = new unsigned char[1024]; blocknode *fblock = new blocknode(1024, btpr);
struct HaveSome { int fun; HaveSome() { fun = 69; } };
struct MyStruct { int id; double x; double y; } MYSTRUCT;
MYSTRUCT _pointList[] = { { 1, 1.0, 1.0 }, { 2, 1.0, 2.0 }, { 3, 2.0, 1.0 } };
<file and line> : error C2552: be initialized with initializer list.
using namespace std; struct hello { public: hello(); ~hello(); }; hello::hello() { cout<<"calling constructor...!"<<endl; } hello::~hello() { cout<<"calling destructor...!"<<endl; } int main() { hello obj; return 0; }
struct a { int x; a(){x=100;} }; int main() { struct a a1; getch(); }
struct Date { int day; Date(int d) { day = d; } void printDay() { cout << "day " << day << endl; } };
using namespace std; struct Node { int value; Node(int value) { this->value = value; } void print() { cout << this->value << endl; } }; int main() { Node n = Node(10); n.print(); return 0; }
int main() { std::array<int, 3> arr = {2, 3, 5}; ... }
sudo update-alternatives --config gcc There are 2 choices for the alternative gcc (providing /usr/bin/gcc). Selection Path Priority Status ------------------------------------------------------------ 0 /usr/bin/gcc-4.6 60 auto mode 1 /usr/bin/gcc-4.6 60 manual mode * 2 /usr/bin/gcc-4.7 40 manual mode
static JS_NEVER_INLINE void CrashInJS() { /* * We write 123 here so that the machine code for this function is * unique. Otherwise the linker, trying to be smart, might use the * same code for CrashInJS and for some other function. That * messes up the signature in minidumps. */ /* * We used to call DebugBreak() on Windows, but amazingly, it causes * the MSVS 2010 debugger not to be able to recover a call stack. */ *((int *) NULL) = 123; exit(3); /* * On Mac OS X, Breakpad ignores signals. Only real Mach exceptions are * trapped. */ *((int *) NULL) = 123; raise(SIGABRT); raise(SIGABRT); }
class MyClass{ public: ~MyClass() throw(int) { throw 0;} }; int main() { try { MyClass myobj; throw 1; } catch(...) { std::cout<<"Exception catched"<<endl; } return 0; }
void main() { StackOverflow(0); } void StackOverflow(int depth) { char blockdata[10000]; printf("Overflow: %d\n", depth); StackOverflow(depth+1); }
int main(int argc, char *argv[]) { char *buf=NULL;buf[0]=0; return 0; }
volatile int* a = reinterpret_cast<volatile int*>(NULL); *a = 1;
int main(int argv, char* argc) { return main(argv, argc) }
void main() { int *aNumber = (int*) malloc(sizeof(int)); int j = 10; for(int i = 2; i <= j; ++i) { aNumber = (int*) realloc(aNumber, sizeof(int) * i); j += 10; } }
int main() { int *p=3; int s; while(1) { s=*p; p++; } }
class Base; void func(Base*); class Base { public: virtual void f() = 0; Base() { func(this); } }; class Derived : Base { virtual void f() { } }; void func(Base* p) { p->f(); } int main() { Derived d; }
MyChildClass::~MyChildClass() { this->MyBaseClass::~MyBaseClass(); }
class B { public: virtual ~B() { cout<<"B destructor"<<endl; } }; class D : public B { public: virtual ~D() { cout<<"D destructor"<<endl; } };
struct A { virtual ~A() {} }; struct B : public A { virtual ~B() {} }; struct C : public A { ~C() {} };
class base { public: base() { cout << __FUNCTION__ << endl; } ~base() { cout << __FUNCTION__ << endl; } }; class derived : public base { public: derived() { cout << __FUNCTION__ << endl; } ~derived() { cout << __FUNCTION__ << endl; } }; int main() { cout << "case 1, declared as local variable on stack" << endl << endl; { derived d1; } cout << endl << endl; cout << "case 2, created using new, assigned to derive class" << endl << endl; derived * d2 = new derived; delete d2; cout << endl << endl; cout << "case 3, created with new, assigned to base class" << endl << endl; base * d3 = new derived; delete d3; cout << endl; return 0; }
case 1, declared as local variable on stack base::base derived::derived derived::~derived base::~base case 2, created using new, assigned to derive class base::base derived::derived derived::~derived base::~base case 3, created with new, assigned to base class base::base derived::derived base::~base Press any key to continue . . .
class Foo { public: int x; virtual void printStuff() { std::cout << x << std::endl; } }; class Bar : public Foo { public: int y; void printStuff() { std::cout << y << std::endl; } };
class Bar : public Foo { void printStuff() { Foo::printStuff(); } };
class Bar : public Foo { ... void printStuff() { Foo::printStuff(); } };
class Foo { public: virtual void foo() { ... } }; class Baz { public: virtual void foo() { ... } }; class Bar : public Foo, public Baz { public: virtual void foo() { Foo::foo(); Baz::foo(); } };
struct Base { virtual int Foo() { return -1; } }; struct Derived : public Base { virtual int Foo() { return -2; } }; int main(int argc, char* argv[]) { Base *x = new Derived; ASSERT(-2 == x->Foo()); ASSERT(-1 == x->Base::Foo()); return 0; }
class Foo { public: virtual void f1() { } virtual void f2() { } }; class Bar : public Foo { private: typedef Foo super; public: void f1() { super::f1(); } };
using namespace std; class Foo { public: int x; virtual void printStuff() { cout<<"Base Foo printStuff called"<<endl; } }; class Bar : public Foo { public: int y; void printStuff() { cout<<"derived Bar printStuff called"<<endl; Foo::printStuff(); } }; int main() { Bar *b=new Bar; b->printStuff(); }
using namespace std; class Foo { public: int x; virtual void printStuff() { cout<<"Base Foo printStuff called"<<endl; } }; class Bar : public Foo { public: int y; void printStuff() { cout<<"derived Bar printStuff called"<<endl; } }; int main() { Foo *foo=new Foo; foo->printStuff(); foo=new Bar; foo->printStuff(); }
class Base { public: virtual void gogo(int a) { printf(" Base :: gogo (int) \n"); }; virtual void gogo1(int a) { printf(" Base :: gogo1 (int) \n"); }; void gogo2(int a) { printf(" Base :: gogo2 (int) \n"); }; void gogo3(int a) { printf(" Base :: gogo3 (int) \n"); }; }; class Derived : protected Base { public: virtual void gogo(int a) { printf(" Derived :: gogo (int) \n"); }; void gogo1(int a) { printf(" Derived :: gogo1 (int) \n"); }; virtual void gogo2(int a) { printf(" Derived :: gogo2 (int) \n"); }; void gogo3(int a) { printf(" Derived :: gogo3 (int) \n"); }; }; int main() { std::cout << "Derived" << std::endl; auto obj = new Derived ; obj->gogo(7); obj->gogo1(7); obj->gogo2(7); obj->gogo3(7); std::cout << "Base" << std::endl; auto base = (Base*)obj; base->gogo(7); base->gogo1(7); base->gogo2(7); base->gogo3(7); std::string s; std::cout << "press any key to exit" << std::endl; std::cin >> s; return 0; }
Derived Derived :: gogo (int) Derived :: gogo1 (int) Derived :: gogo2 (int) Derived :: gogo3 (int) Base Derived :: gogo (int) Derived :: gogo1 (int) Base :: gogo2 (int) Base :: gogo3 (int) press any key to exit
class child: public parent { void methodName() { parent::methodName(); } };
int& myInt = getInt(); delete &myInt; int oops = getInt(); delete &oops;
std::unique_ptr<int> getInt() { return std::make_unique<int>(0); }
struct immutableint { immutableint(int i) : i_(i) {} const int& get() const { return i_; } private: int i_; };
Class Singleton { public: static Singleton& instance() { static Singleton instance; return instance; }; void printHello() { printf("Hello"); }; }
Singleton& my_sing = Singleton::instance(); my_sing.printHello();
std::vector<int> x = {1, 2, 3}; std::vector<int>::iterator iter = x.begin(); *iter = 2;
Class Container { private: std::vector<int> m_data; public: std::vector<int>& data() { return m_data; } }
Container cont; cont.data().push_back(1); cont.data()[0]
Container* cont = new Container; std::vector<int>& cont_data = cont->data(); cont_data.push_back(1); delete cont; cont_data[0];
const max_tmp=5; Obj& get_tmp() { static int buf=0; static Obj Buf[max_tmp]; if(buf==max_tmp) buf=0; return Buf[buf++]; } Obj& operator+(const Obj& o1, const Obj& o1) { Obj& res=get_tmp(); return res; }
struct immutableint { immutableint(int i) : i_(i) {} const int& get() const { return i_; } private: int i_; };
struct Foo { Foo(int i = 42) : boo_(i) {} immutableint boo() { return boo_; } private: immutableint boo_; };
Class Set { int *ptr; int size; public: Set(){ size =0; } Set(int size) { this->size = size; ptr = new int [size]; } int& getPtr(int i) { return ptr[i]; } };
int& getTheValue() { std::shared_ptr<int> p(new int); return *p->get(); }
void doSomething(T & t) { if(std::numeric_limits<int>::max() > t.integer) t.integer += 1 ; X * x = new X() ; t.list.push_back(x) ; x->doSomethingThatCanThrow() ; }
void doSomething(T & t) { if(std::numeric_limits<int>::max() > t.integer) t.integer += 1 ; std::auto_ptr<X> x(new X()) ; X * px = x.get() ; t.list.push_back(px) ; x.release() ; px->doSomethingThatCanThrow() ; }
void doSomething(T & t) { std::auto_ptr<X> x(new X()) ; X * px = x.get() ; px->doSomethingThatCanThrow() ; T t2(t) ; t2.list.push_back(px) ; x.release() ; if(std::numeric_limits<int>::max() > t2.integer) t2.integer += 1 ; t.swap(t2) ; }
printf("Error %d: %s.\n", id, errors[id]); std::cout << "Error " << id << ": " << errors[id] << "." << std::endl;
printf("0x%04x\n", 0x424); std::cout << "0x" << std::hex << std::setfill(
printf(gettext("Error %d: %s.\n"), id, errors[id]);
main: @ @main @ BB push {lr} ldr r0, .LCPI0_0 ldr r2, .LCPI0_1 mov r1, bl printf mov r0, pop {lr} mov pc, lr .align 2 @ BB
main: @ @main @ BB push {r4, r5, lr} ldr r4, .LCPI0_0 ldr r1, .LCPI0_1 mov r2, mov r3, mov r0, r4 bl _ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l mov r0, r4 mov r1, bl _ZNSolsEi ldr r1, .LCPI0_2 mov r2, mov r3, mov r4, r0 bl _ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l ldr r1, .LCPI0_3 mov r0, r4 mov r2, mov r3, bl _ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l ldr r1, .LCPI0_4 mov r0, r4 mov r2, mov r3, bl _ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l ldr r0, [r4] sub r0, r0, ldr r0, [r0] add r0, r0, r4 ldr r5, [r0, cmp r5, beq .LBB0_5 @ BB ldrb r0, [r5, cmp r0, beq .LBB0_3 @ BB ldrb r0, [r5, b .LBB0_4 .LBB0_3: mov r0, r5 bl _ZNKSt5ctypeIcE13_M_widen_initEv ldr r0, [r5] mov r1, ldr r2, [r0, mov r0, r5 mov lr, pc mov pc, r2 .LBB0_4: @ %_ZNKSt5ctypeIcE5widenEc.exit lsl r0, r0, asr r1, r0, mov r0, r4 bl _ZNSo3putEc bl _ZNSo5flushEv mov r0, pop {r4, r5, lr} mov pc, lr .LBB0_5: bl _ZSt16__throw_bad_castv .align 2 @ BB
$ cat safety.c int main(void) { printf("String: %s\n", 42); return 0; } $ clang safety.c safety.c:4:28: warning: format specifies type printf("String: %s\n", 42); ~~ ^~ %d 1 warning generated. $ gcc -Wall safety.c safety.c: In function ‘main’: safety.c:4:5: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=] printf("String: %s\n", 42); ^
cout with only endl 1461.310252 ms cout with only printf with only cout with string constant and endl 1892.975381 ms cout with string constant and printf with string constant and cout with some stuff and endl 3496.489748 ms cout with some stuff and printf with some stuff and
class TimedSection { char const *d_name; timespec d_start; public: TimedSection(char const *name) : d_name(name) { clock_gettime(CLOCK_REALTIME, &d_start); } ~TimedSection() { timespec end; clock_gettime(CLOCK_REALTIME, &end); double duration = 1e3 * (end.tv_sec - d_start.tv_sec) + 1e-6 * (end.tv_nsec - d_start.tv_nsec); std::cerr << d_name << } }; int main() { const int iters = 10000000; char const *text = "01234567890123456789"; { TimedSection s("cout with only endl"); for (int i = 0; i < iters; ++i) std::cout << std::endl; } { TimedSection s("cout with only for (int i = 0; i < iters; ++i) std::cout << } { TimedSection s("printf with only for (int i = 0; i < iters; ++i) printf("\n"); } { TimedSection s("cout with string constant and endl"); for (int i = 0; i < iters; ++i) std::cout << "01234567890123456789" << std::endl; } { TimedSection s("cout with string constant and for (int i = 0; i < iters; ++i) std::cout << "01234567890123456789\n"; } { TimedSection s("printf with string constant and for (int i = 0; i < iters; ++i) printf("01234567890123456789\n"); } { TimedSection s("cout with some stuff and endl"); for (int i = 0; i < iters; ++i) std::cout << text << "01234567890123456789" << i << std::endl; } { TimedSection s("cout with some stuff and for (int i = 0; i < iters; ++i) std::cout << text << "01234567890123456789" << i << } { TimedSection s("printf with some stuff and for (int i = 0; i < iters; ++i) printf("%s01234567890123456789%i\n", text, i); } }
using namespace std; int main () { cout << "This is sent to prompt" << endl; ofstream file; file.open ("test.txt"); streambuf* sbuf = cout.rdbuf(); cout.rdbuf(file.rdbuf()); cout << "This is sent to file" << endl; cout.rdbuf(sbuf); cout << "This is also sent to prompt" << endl; return 0; }
using namespace std; class Something { public: Something(int x, int y, int z) : a(x), b(y), c(z) { } int a; int b; int c; friend ostream& operator<<(ostream&, const Something&); }; ostream& operator<<(ostream& o, const Something& s) { o << s.a << ", " << s.b << ", " << s.c; return o; } int main(void) { Something s(3, 2, 1); printf("%i, %i, %i\n", s.a, s.b, s.c); cout << s << endl; return 0; }
using namespace std; class Something { public: Something(int x, int y, int z) : a(x), b(y), c(z) { } int a; int b; int c; friend ostream& operator<<(ostream&, const Something&); void print() const { printf("%i, %i, %i\n", a, b, c); } }; ostream& operator<<(ostream& o, const Something& s) { o << s.a << ", " << s.b << ", " << s.c; return o; } int main(void) { Something s(3, 2, 1); s.print(); cout << s << endl; return 0; }
class TimedSection { char const *d_name; clock_t d_start; public: TimedSection(char const *name) : d_name(name) { d_start = clock(); } ~TimedSection() { clock_t end; end = clock(); double duration = /*1e3 * (end.tv_sec - d_start.tv_sec) + 1e-6 * (end.tv_nsec - d_start.tv_nsec); */ (double) (end - d_start) / CLOCKS_PER_SEC; std::cerr << d_name << } }; int main() { const int iters = 1000000; char const *text = "01234567890123456789"; { TimedSection s("cout with only endl"); for (int i = 0; i < iters; ++i) std::cout << std::endl; } { TimedSection s("cout with only for (int i = 0; i < iters; ++i) std::cout << } { TimedSection s("printf with only for (int i = 0; i < iters; ++i) printf("\n"); } { TimedSection s("cout with string constant and endl"); for (int i = 0; i < iters; ++i) std::cout << "01234567890123456789" << std::endl; } { TimedSection s("cout with string constant and for (int i = 0; i < iters; ++i) std::cout << "01234567890123456789\n"; } { TimedSection s("printf with string constant and for (int i = 0; i < iters; ++i) printf("01234567890123456789\n"); } { TimedSection s("cout with some stuff and endl"); for (int i = 0; i < iters; ++i) std::cout << text << "01234567890123456789" << i << std::endl; } { TimedSection s("cout with some stuff and for (int i = 0; i < iters; ++i) std::cout << text << "01234567890123456789" << i << } { TimedSection s("printf with some stuff and for (int i = 0; i < iters; ++i) printf("%s01234567890123456789%i\n", text, i); } { TimedSection s("cout with formatted double (width & precision once)"); std::cout << std::fixed << std::scientific << std::right << std::showpoint; std::cout.width(8); for (int i = 0; i < iters; ++i) std::cout << text << 8.315 << i << } { TimedSection s("cout with formatted double (width & precision on each call)"); std::cout << std::fixed << std::scientific << std::right << std::showpoint; for (int i = 0; i < iters; ++i) { std::cout.width(8); std::cout.precision(3); std::cout << text << 8.315 << i << } } { TimedSection s("printf with formatted double"); for (int i = 0; i < iters; ++i) printf("%8.3f%i\n", 8.315, i); } }
cout with only endl 6453.000000 ms cout with only printf with only cout with string constant and endl 6937.000000 ms cout with string constant and printf with string constant and cout with some stuff and endl 9672.000000 ms cout with some stuff and printf with some stuff and cout with formatted double (width & precision once) 7906.000000 ms cout with formatted double (width & precision on each call) 9141.000000 ms printf with formatted double 3312.000000 ms
using namespace std; void task(int taskNum, string msg) { for (int i = 0; i < 5; ++i) { cout << " } } int main() { thread t1(task, 1, "AAA"); thread t2(task, 2, "BBB"); t1.join(); t2.join(); return 0; }
char coffee[10], sugar[10], milk[10]; unsigned char mac[6]; FILE * f = fopen("a.txt", "wt"); fprintf(f, "coffee=%s\nsugar=%s\nmilk=%s\nmac=%02X:%02X:%02X:%02X:%02X:%02X\n", coffee, sugar, milk, mac[0], mac[1],mac[2],mac[3],mac[4],mac[5]); fclose(f);
std::ofstream f("a.txt", std::ios::out); f << "coffee=" << coffee << "\n"; f << "sugar=" << sugar << "\n"; f << "milk=" << milk << "\n"; f << "mac=" << (int)mac[0] << ":" << (int)mac[1] << ":" << (int)mac[2] << ":" << (int)mac[3] << ":" << (int)mac[4] << ":" << (int)mac[5] << endl; f.close();
void f(void *); void f(...); template<int N> void g() { f(0*N); }
template< unsigned len > unsigned int fun(unsigned int x); typedef unsigned int (*fun_t)(unsigned int); template< fun_t f > unsigned int fon(unsigned int x); void total(void) { unsigned int A = fon< fun< 9 > >(1) >>(2); unsigned int B = fon< fun< 9 >>(1) > >(2); }
struct foo { void *operator new(size_t x){ throw std::exception(); } } try { foo *f = new foo(); } catch (std::bad_alloc &) { } catch (std::exception &) { }
struct A { ~A() { throw "foo"; } }; try { A a; } catch(...) { }
try { std::cin >> variable; } catch(std::runtime_error &) { std::cerr << "C++11\n"; } catch(std::ios_base::failure &) { std::cerr << "Pre-C++11\n"; }
bool const one = true; int const two = 2; int const three = 3; template<int> struct fun { typedef int two; }; template<class T> struct fon { static int const three = ::three; static bool const one = ::one; }; int main(void) { fon< fun< 1 >>::three >::two >::one; }
1 >> ::three = 0 => fon< fun< 0 >::two >::one; fun< 0 >::two = int => fon< int >::one fon< int >::one = true => true
fun< 1 > is a type argument to fon fon< fun<1> >::three = 3 => 3 > ::two > ::one ::two is 2 and ::one is 1 => 3 > 2 > 1 => (3 > 2) > 1 => true > 1 => 1 > 1 => false
int main() { int count = 0 ; int arrInt[2] = { count++, count++ } ; return 0 ; }
warning: multiple unsequenced modifications to int arrInt[2] = { count++, count++ } ; ^ ~~
int main() { int x[std::numeric_limits<unsigned int>::min()+2] ; }
warning: variable length arrays are a C99 feature [-Wvla-extension] int x[std::numeric_limits<unsigned int>::min()+2] ; ^
struct S { ~S() { throw std::runtime_error(""); } }; int main() { try { S s; } catch (...) { std::cerr << "exception occurred"; } std::cout << "success"; }
class Comparators { public: bool operator()(int first, int second) { return first < second; } }; int main() { class ComparatorsInner : public Comparators{}; std::vector<int> compares ; compares.push_back(20) ; compares.push_back(10) ; compares.push_back(30) ; ComparatorsInner comparatorInner; std::sort(compares.begin(), compares.end(), comparatorInner); std::vector<int>::iterator it; for(it = compares.begin(); it != compares.end(); ++it) { std::cout << (*it) << std::endl; } }
template<int I> struct X { static int const c = 2; }; template<> struct X<0> { typedef int c; }; template<typename T> struct Y { static int const c = 3; }; static int const c = 4; int main() { std::cout << (Y<X<1> >::c >::c>::c) << std::cout << (Y<X< 1>>::c >::c>::c) << }
struct T { bool flag; T() : flag(false) {} T(const T&) : flag(true) {} }; int main() { std::vector<T> test(1); bool is_cpp11 = !test[0].flag; std::cout << is_cpp11 << std::endl ; }
struct Widget { boost::shared_ptr<int> p; Widget() : p(new int(42)) {} }; int main() { std::deque<Widget> d(10); for (size_t i = 0; i < d.size(); ++i) std::cout << "d[" << i << "] : " << d[i].p.use_count() << }
container(size_type size, const value_type &prototype = value_type());
container(size_type size); container(size_type size, const value_type &prototype);
template <class T> bool f(T&) {return true; } template <class T> bool f(...){return false;} bool isCpp11() { int v = 1; return f<int&>(v); }
template <class T> bool cpp11(T) {return true;} bool cpp11(...){return false;} bool isCpp0x() { struct local {} var; return cpp11(var); }
template<class T> struct has { typedef char yes; typedef yes (&no)[2]; template<int> struct foo; template<class U> static yes test(foo<U::bar>*); template<class U> static no test(...); static bool const value = sizeof(test<T>(0)) == sizeof(yes); }; enum foo { bar }; int main() { std::cout << (has<foo>::value ? "yes" : "no") << std::endl; }
class B; class A { int _val; B *_b; public: A(int val) :_val(val) { } void SetB(B *b) { _b = b; _b->Print(); } void Print() { cout<<"Type:A val="<<_val<<endl; } };
class B { double _val; A* _a; public: B(double val) :_val(val) { } void SetA(A *a) { _a = a; _a->Print(); } void Print() { cout<<"Type:B val="<<_val<<endl; } };
int main(int argc, char* argv[]) { A a(10); B b(3.14); a.Print(); a.SetB(&b); b.Print(); b.SetA(&a); return 0; }
class A { B _b; }; class B { A _a; }; int main(...) { A a; }
class A { B& _b_ref; B* _b_ptr; }; int main (...) { A a; }
class B; class A { int _val; B* _b; public: A(int val); void SetB(B *b); void Print(); }; class A; class B { double _val; A* _a; public: B(double val); void SetA(A *a); void Print(); }; using namespace std; A::A(int val) :_val(val) { } void A::SetB(B *b) { _b = b; cout<<"Inside SetB()"<<endl; _b->Print(); } void A::Print() { cout<<"Type:A val="<<_val<<endl; } using namespace std; B::B(double val) :_val(val) { } void B::SetA(A *a) { _a = a; cout<<"Inside SetA()"<<endl; _a->Print(); } void B::Print() { cout<<"Type:B val="<<_val<<endl; } int main(int argc, char* argv[]) { A a(10); B b(3.14); a.Print(); a.SetB(&b); b.Print(); b.SetA(&a); return 0; }
class B; class A { int _val; B *_b; public: A(int val); void SetB(B *b); void Print(); }; inline A::A(int val) : _val(val) { } inline void A::SetB(B *b) { _b = b; _b->Print(); } inline void A::Print() { cout<<"Type:A val="<<_val<<endl; }
template <typename T> class Basic_B; typedef Basic_B<char> B;
template <typename T> class Basic_B { ...class definition... }; typedef Basic_B<char> B;
class Printer { public: virtual Print() = 0; } class A: public Printer { int _val; Printer *_b; public: A(int val) :_val(val) { } void SetB(Printer *b) { _b = b; _b->Print(); } void Print() { cout<<"Type:A val="<<_val<<endl; } }; class B: public Printer { double _val; Printer* _a; public: B(double val) :_val(val) { } void SetA(Printer *a) { _a = a; _a->Print(); } void Print() { cout<<"Type:B val="<<_val<<endl; } }; int main(int argc, char* argv[]) { A a(10); B b(3.14); a.Print(); a.SetB(&b); b.Print(); b.SetA(&a); return 0; }
class B; class A { int _val; B *_b; public: A(int val); void SetB(B *b); void Print(); }; class A; class B { double _val; A* _a; public: B(double val); void SetA(A *a); void Print(); };
inline A::A(int val) :_val(val) { } inline void A::SetB(B *b) { _b = b; _b->Print(); } inline void A::Print() { cout<<"Type:A val="<<_val<<endl; } inline B::B(double val) :_val(val) { } inline void B::SetA(A *a) { _a = a; _a->Print(); } inline void B::Print() { cout<<"Type:B val="<<_val<<endl; }
const int ci = 0; std::cout << typeid(ci).name() <<
const int ci = 0; std::cout << type_name<decltype(ci)>() <<
template <class T> std::string type_name() { typedef typename std::remove_reference<T>::type TR; std::unique_ptr<char, void(*)(void*)> own ( abi::__cxa_demangle(typeid(TR).name(), nullptr, nullptr, nullptr), nullptr, std::free ); std::string r = own != nullptr ? own.get() : typeid(TR).name(); if (std::is_const<TR>::value) r += " const"; if (std::is_volatile<TR>::value) r += " volatile"; if (std::is_lvalue_reference<T>::value) r += "&"; else if (std::is_rvalue_reference<T>::value) r += "&&"; return r; }
int& foo_lref(); int&& foo_rref(); int foo_value(); int main() { int i = 0; const int ci = 0; std::cout << "decltype(i) is " << type_name<decltype(i)>() << std::cout << "decltype((i)) is " << type_name<decltype((i))>() << std::cout << "decltype(ci) is " << type_name<decltype(ci)>() << std::cout << "decltype((ci)) is " << type_name<decltype((ci))>() << std::cout << "decltype(static_cast<int&>(i)) is " << type_name<decltype(static_cast<int&>(i))>() << std::cout << "decltype(static_cast<int&&>(i)) is " << type_name<decltype(static_cast<int&&>(i))>() << std::cout << "decltype(static_cast<int>(i)) is " << type_name<decltype(static_cast<int>(i))>() << std::cout << "decltype(foo_lref()) is " << type_name<decltype(foo_lref())>() << std::cout << "decltype(foo_rref()) is " << type_name<decltype(foo_rref())>() << std::cout << "decltype(foo_value()) is " << type_name<decltype(foo_value())>() << }
decltype(i) is int decltype((i)) is int& decltype(ci) is int const decltype((ci)) is int const& decltype(static_cast<int&>(i)) is int& decltype(static_cast<int&&>(i)) is int&& decltype(static_cast<int>(i)) is int decltype(foo_lref()) is int& decltype(foo_rref()) is int&& decltype(foo_value()) is int
decltype(i) is int decltype((i)) is int decltype(ci) is int decltype((ci)) is int decltype(static_cast<int&>(i)) is int decltype(static_cast<int&&>(i)) is int decltype(static_cast<int>(i)) is int decltype(foo_lref()) is int decltype(foo_rref()) is int decltype(foo_value()) is int
class static_string { const char* const p_; const std::size_t sz_; public: typedef const char* const_iterator; template <std::size_t N> CONSTEXPR11_TN static_string(const char(&a)[N]) NOEXCEPT_TN : p_(a) , sz_(N-1) {} CONSTEXPR11_TN static_string(const char* p, std::size_t N) NOEXCEPT_TN : p_(p) , sz_(N) {} CONSTEXPR11_TN const char* data() const NOEXCEPT_TN {return p_;} CONSTEXPR11_TN std::size_t size() const NOEXCEPT_TN {return sz_;} CONSTEXPR11_TN const_iterator begin() const NOEXCEPT_TN {return p_;} CONSTEXPR11_TN const_iterator end() const NOEXCEPT_TN {return p_ + sz_;} CONSTEXPR11_TN char operator[](std::size_t n) const { return n < sz_ ? p_[n] : throw std::out_of_range("static_string"); } }; inline std::ostream& operator<<(std::ostream& os, static_string const& s) { return os.write(s.data(), s.size()); } template <class T> CONSTEXPR14_TN static_string type_name() { static_string p = __PRETTY_FUNCTION__; return static_string(p.data() + 31, p.size() - 31 - 1); static_string p = __PRETTY_FUNCTION__; return static_string(p.data() + 36, p.size() - 36 - 1); return static_string(p.data() + 46, p.size() - 46 - 1); static_string p = __FUNCSIG__; return static_string(p.data() + 38, p.size() - 38 - 7); }
template <class T> constexpr std::string_view type_name() { using namespace std; string_view p = __PRETTY_FUNCTION__; return string_view(p.data() + 34, p.size() - 34 - 1); string_view p = __PRETTY_FUNCTION__; return string_view(p.data() + 36, p.size() - 36 - 1); return string_view(p.data() + 49, p.find( string_view p = __FUNCSIG__; return string_view(p.data() + 84, p.size() - 84 - 7); }
auto testVar = std::make_tuple(1, 1.0, "abc"); decltype(testVar)::foo = 1;
Compilation finished with errors: source.cpp: In function source.cpp:5:19: error:
using namespace std; int main() { int i; cout << typeid(i).name(); return 0; }
MyNamespace::CMyContainer<int, test_MyNamespace::CMyObject>
class MyNamespace::CMyContainer[int,class test_MyNamespace::CMyObject] N8MyNamespace8CMyContainerIiN13test_MyNamespace9CMyObjectEEE
template <typename T> const char* typeof(T&) { return "unknown"; } template<> const char* typeof(int&) { return "int"; } template<> const char* typeof(float&) { return "float"; }
namespace some_namespace { namespace another_namespace { class my_class { }; } } int main() { typedef some_namespace::another_namespace::my_class my_type; std::cout << typeid(my_type).name() << std::endl; int status = 0; char* demangled = abi::__cxa_demangle(typeid(my_type).name(), 0, 0, &status); switch (status) { case -1: { std::cout << "Could not allocate memory" << std::endl; return -1; } break; case -2: { std::cout << "Invalid name" << std::endl; return -1; } break; case -3: { std::cout << "Invalid argument to demangle()" << std::endl; return -1; } break; } std::cout << demangled << std::endl; free(demangled); return 0;
using namespace std; template <typename T> class type_name { public: static const char *name; }; DECLARE_TYPE_NAME(int); int main() { int a = 12; cout << GET_TYPE_NAME(a) << endl; }
using namespace std; using boost::typeindex::type_id_with_cvr; int main() { int i = 0; const int ci = 0; cout << "decltype(i) is " << type_id_with_cvr<decltype(i)>().pretty_name() << cout << "decltype((i)) is " << type_id_with_cvr<decltype((i))>().pretty_name() << cout << "decltype(ci) is " << type_id_with_cvr<decltype(ci)>().pretty_name() << cout << "decltype((ci)) is " << type_id_with_cvr<decltype((ci))>().pretty_name() << cout << "decltype(std::move(i)) is " << type_id_with_cvr<decltype(std::move(i))>().pretty_name() << cout << "decltype(std::static_cast<int&&>(i)) is " << type_id_with_cvr<decltype(static_cast<int&&>(i))>().pretty_name() << return 0; }
template <typename T> struct type_as_string; template <> struct type_as_string<Wibble> { static const char* const value = "Wibble"; };
template <typename T> const char* get_type_as_string(const T&) { return type_as_string<T>::value; }
template<typename T> std::string TypeOf(T){ std::string Type="unknown"; if(std::is_same<T,int>::value) Type="int"; if(std::is_same<T,std::string>::value) Type="String"; if(std::is_same<T,MyClass>::value) Type="MyClass"; return Type;}
class MyClass{}; template<typename T> std::string TypeOf(T){ std::string Type="unknown"; if(std::is_same<T,int>::value) Type="int"; if(std::is_same<T,std::string>::value) Type="String"; if(std::is_same<T,MyClass>::value) Type="MyClass"; return Type;} int main(){; int a=0; std::string s=""; MyClass my; std::cout<<TypeOf(a)<<std::endl; std::cout<<TypeOf(s)<<std::endl; std::cout<<TypeOf(my)<<std::endl; return 0;}
template <typename T> const char* typeof(T&) { return "unknown"; } template<> const char* typeof(int&) { return "int"; } template<> const char* typeof(short&) { return "short"; } template<> const char* typeof(long&) { return "long"; } template<> const char* typeof(unsigned&) { return "unsigned"; } template<> const char* typeof(unsigned short&) { return "unsigned short"; } template<> const char* typeof(unsigned long&) { return "unsigned long"; } template<> const char* typeof(float&) { return "float"; } template<> const char* typeof(double&) { return "double"; } template<> const char* typeof(long double&) { return "long double"; } template<> const char* typeof(std::string&) { return "String"; } template<> const char* typeof(char&) { return "char"; } template<> const char* typeof(signed char&) { return "signed char"; } template<> const char* typeof(unsigned char&) { return "unsigned char"; } template<> const char* typeof(char*&) { return "char*"; } template<> const char* typeof(signed char*&) { return "signed char*"; } template<> const char* typeof(unsigned char*&) { return "unsigned char*"; }
using namespace std; int main() { auto x = 1; string my_type = typeid(x).name(); system(("echo " + my_type + " | c++filt -t").c_str()); return 0; }
using namespace std; system(("echo " + string(typeid(_t).name()) + " | c++filt -t").c_str()) int main() { auto a = {"one", "two", "three"}; cout << "Type of a: " << typeid(a).name() << endl; cout << "Real type of a:\n"; show_type_name(a); for (auto s : a) { if (string(s) == "one") { cout << "Type of s: " << typeid(s).name() << endl; cout << "Real type of s:\n"; show_type_name(s); } cout << s << endl; } int i = 5; cout << "Type of i: " << typeid(i).name() << endl; cout << "Real type of i:\n"; show_type_name(i); return 0; }
Type of a: St16initializer_listIPKcE Real type of a: std::initializer_list<char const*> Type of s: PKc Real type of s: char const* one two three Type of i: i Real type of i: int
TYPE_NAME(int) TYPE_NAME(void) TYPE_NAME(std::string) int main() { std::cout << type_name<void(*)(int)> << std::cout << type_name<void (std::string::*(int[3],const int, void (*)(std::string)))(volatile int*const*)> << std::cout << type_name<std::ostream (*)(int, short)> << }
static constexpr std::size_t max_str_lit_len = 256; template <std::size_t I, std::size_t N> constexpr char sl_at(const char (&str)[N]) { if constexpr(I < N) return str[I]; else return } constexpr std::size_t sl_len(const char *str) { for (std::size_t i = 0; i < max_str_lit_len; i++) if (str[i] == return i; return 0; } template <char ...C> struct str_lit { static constexpr char value[] {C..., static constexpr int size = sl_len(value); template <typename F, typename ...P> struct concat_impl {using type = typename concat_impl<F>::type::template concat_impl<P...>::type;}; template <char ...CC> struct concat_impl<str_lit<CC...>> {using type = str_lit<C..., CC...>;}; template <typename ...P> using concat = typename concat_impl<P...>::type; }; template <typename, const char *> struct trim_str_lit_impl; template <std::size_t ...I, const char *S> struct trim_str_lit_impl<std::index_sequence<I...>, S> { using type = str_lit<S[I]...>; }; template <std::size_t N, const char *S> using trim_str_lit = typename trim_str_lit_impl<std::make_index_sequence<N>, S>::type; template <char ...C> constexpr str_lit<C...> make_str_lit(str_lit<C...>) {return {};} template <std::size_t N> constexpr auto make_str_lit(const char (&str)[N]) { return trim_str_lit<sl_len((const char (&)[N])str), str>{}; } template <std::size_t A, std::size_t B> struct cexpr_pow {static constexpr std::size_t value = A * cexpr_pow<A,B-1>::value;}; template <std::size_t A> struct cexpr_pow<A,0> {static constexpr std::size_t value = 1;}; template <std::size_t N, std::size_t X, typename = std::make_index_sequence<X>> struct num_to_str_lit_impl; template <std::size_t N, std::size_t X, std::size_t ...Seq> struct num_to_str_lit_impl<N, X, std::index_sequence<Seq...>> { static constexpr auto func() { if constexpr (N >= cexpr_pow<10,X>::value) return num_to_str_lit_impl<N, X+1>::func(); else return str_lit<(N / cexpr_pow<10,X-1-Seq>::value % 10 + } }; template <std::size_t N> using num_to_str_lit = decltype(num_to_str_lit_impl<N,1>::func()); using spa = str_lit< using lpa = str_lit< using rpa = str_lit< using lbr = str_lit< using rbr = str_lit< using ast = str_lit< using amp = str_lit< using con = str_lit< using vol = str_lit< using con_vol = con::concat<spa, vol>; using nsp = str_lit< using com = str_lit< using unk = str_lit< using c_cla = str_lit< using c_uni = str_lit< using c_enu = str_lit< template <typename T> inline constexpr bool ptr_or_ref = std::is_pointer_v<T> || std::is_reference_v<T> || std::is_member_pointer_v<T>; template <typename T> inline constexpr bool func_or_arr = std::is_function_v<T> || std::is_array_v<T>; template <typename T> struct primitive_type_name {using value = unk;}; template <typename T, typename = std::enable_if_t<std::is_class_v<T>>> using enable_if_class = T; template <typename T, typename = std::enable_if_t<std::is_union_v<T>>> using enable_if_union = T; template <typename T, typename = std::enable_if_t<std::is_enum_v <T>>> using enable_if_enum = T; template <typename T> struct primitive_type_name<enable_if_class<T>> {using value = c_cla;}; template <typename T> struct primitive_type_name<enable_if_union<T>> {using value = c_uni;}; template <typename T> struct primitive_type_name<enable_if_enum <T>> {using value = c_enu;}; template <typename T> struct type_name_impl; template <typename T> using type_name_lit = std::conditional_t<std::is_same_v<typename primitive_type_name<T>::value::template concat<spa>, typename type_name_impl<T>::l::template concat<typename type_name_impl<T>::r>>, typename primitive_type_name<T>::value, typename type_name_impl<T>::l::template concat<typename type_name_impl<T>::r>>; template <typename T> inline constexpr const char *type_name = type_name_lit<T>::value; template <typename T, typename = std::enable_if_t<!std::is_const_v<T> && !std::is_volatile_v<T>>> using enable_if_no_cv = T; template <typename T> struct type_name_impl { using l = typename primitive_type_name<T>::value::template concat<spa>; using r = str_lit<>; }; template <typename T> struct type_name_impl<const T> { using new_T_l = std::conditional_t<type_name_impl<T>::l::size && !ptr_or_ref<T>, spa::concat<typename type_name_impl<T>::l>, typename type_name_impl<T>::l>; using l = std::conditional_t<ptr_or_ref<T>, typename new_T_l::template concat<con>, con::concat<new_T_l>>; using r = typename type_name_impl<T>::r; }; template <typename T> struct type_name_impl<volatile T> { using new_T_l = std::conditional_t<type_name_impl<T>::l::size && !ptr_or_ref<T>, spa::concat<typename type_name_impl<T>::l>, typename type_name_impl<T>::l>; using l = std::conditional_t<ptr_or_ref<T>, typename new_T_l::template concat<vol>, vol::concat<new_T_l>>; using r = typename type_name_impl<T>::r; }; template <typename T> struct type_name_impl<const volatile T> { using new_T_l = std::conditional_t<type_name_impl<T>::l::size && !ptr_or_ref<T>, spa::concat<typename type_name_impl<T>::l>, typename type_name_impl<T>::l>; using l = std::conditional_t<ptr_or_ref<T>, typename new_T_l::template concat<con_vol>, con_vol::concat<new_T_l>>; using r = typename type_name_impl<T>::r; }; template <typename T> struct type_name_impl<T *> { using l = std::conditional_t<func_or_arr<T>, typename type_name_impl<T>::l::template concat<lpa, ast>, typename type_name_impl<T>::l::template concat< ast>>; using r = std::conditional_t<func_or_arr<T>, rpa::concat<typename type_name_impl<T>::r>, typename type_name_impl<T>::r>; }; template <typename T> struct type_name_impl<T &> { using l = std::conditional_t<func_or_arr<T>, typename type_name_impl<T>::l::template concat<lpa, amp>, typename type_name_impl<T>::l::template concat< amp>>; using r = std::conditional_t<func_or_arr<T>, rpa::concat<typename type_name_impl<T>::r>, typename type_name_impl<T>::r>; }; template <typename T> struct type_name_impl<T &&> { using l = std::conditional_t<func_or_arr<T>, typename type_name_impl<T>::l::template concat<lpa, amp, amp>, typename type_name_impl<T>::l::template concat< amp, amp>>; using r = std::conditional_t<func_or_arr<T>, rpa::concat<typename type_name_impl<T>::r>, typename type_name_impl<T>::r>; }; template <typename T, typename C> struct type_name_impl<T C::*> { using l = std::conditional_t<func_or_arr<T>, typename type_name_impl<T>::l::template concat<lpa, type_name_lit<C>, nsp, ast>, typename type_name_impl<T>::l::template concat< type_name_lit<C>, nsp, ast>>; using r = std::conditional_t<func_or_arr<T>, rpa::concat<typename type_name_impl<T>::r>, typename type_name_impl<T>::r>; }; template <typename T> struct type_name_impl<enable_if_no_cv<T[]>> { using l = typename type_name_impl<T>::l; using r = lbr::concat<rbr, typename type_name_impl<T>::r>; }; template <typename T, std::size_t N> struct type_name_impl<enable_if_no_cv<T[N]>> { using l = typename type_name_impl<T>::l; using r = lbr::concat<num_to_str_lit<N>, rbr, typename type_name_impl<T>::r>; }; template <typename T> struct type_name_impl<T()> { using l = typename type_name_impl<T>::l; using r = lpa::concat<rpa, typename type_name_impl<T>::r>; }; template <typename T, typename P1, typename ...P> struct type_name_impl<T(P1, P...)> { using l = typename type_name_impl<T>::l; using r = lpa::concat<type_name_lit<P1>, com::concat<type_name_lit<P>>..., rpa, typename type_name_impl<T>::r>; };
int i; const int ci; extern const int eci; static int si; int foo(); static int bar();
namespace { int i; class invisible_to_others { }; }
void f(int i); extern const int max = 10; int n = 0; int main() { int a; f(a); f(a); }
using namespace std; extern const int max; extern int n; static float z = 0.0; void f(int i) { static int nCall = 0; int a; nCall++; n++; a = max * z; cout << "f() called " << nCall << " times." << endl; }
namespace std { inline namespace pre_cxx_1997 { template <class T> __vector_impl; template <class T> class vector : __vector_impl<T> { }; } inline namespace cxx_1997 { template <class T, class Alloc=std::allocator<T> > class vector : pre_cxx_1997::__vector_impl<T> { }; template <class Alloc=std::allocator<bool> > class vector<bool> { }; }; }
namespace std { namespace pre_cxx_1997 { } using namespace pre_cxx_1997; namespace cxx_1997 { }; using namespace cxx_1997; }
namespace std { template <> class vector<MyType> : my_special_vector<MyType> { }; template <> class vector<MyOtherType> : my_special_vector<MyOtherType> { }; }
inline namespace V99 { void f(int); void f(double); } namespace V98 { void f(int); } namespace Mine { } using namespace Mine; V98::f(1); V99::f(1); f(1);
const int MeaningOfLife = 42; constexpr int MeaningOfLife () { return 42; }
constexpr int MeaningOfLife ( int a, int b ) { return a * b; } const int meaningOfLife = MeaningOfLife( 6, 7 );
template< typename Type > constexpr Type max( Type a, Type b ) { return a < b ? b : a; }
const float oneeighty = DegreesToRadians( 180.0f );
int func (int n) { static std::map<int, int> _cached; if (_cached.find (n) == _cached.end ()) _cached[n] = n > 0 ? n + func (n-1) : n; return _cached[n]; }
template <typename T, size_t N> constexpr size_t size_of(T (&)[N]) { return N; }
enum { TWO = 2 }; enum { pi = 3.1415f }; static const float pi = 3.1415f; constexpr float pi = 3.1415f; struct A { static const int four = 4; static const int five = 5; constexpr int six = 6; }; int main() { &A::four; &A::six; int i = rand()? A::four: A::five; }
template<int M, int K, int S> struct Unit { enum { m=M, kg=K, s=S }; }; template<typename Unit> struct Value { double val; explicit Value(double d) : val(d) {} }; using Speed = Value<Unit<1,0,-1>>; using Acceleration = Value<Unit<1,0,-2>>; using Second = Unit<0,0,1>; using Second2 = Unit<0,0,2>; constexpr Value<Second> operator"" s(long double d) { return Value<Second> (d); } constexpr Value<Second2> operator"" s2(long double d) { return Value<Second2> (d); } Speed sp1 = 100m/9.8s; Speed sp2 = 100m/9.8s2; Speed sp3 = 100/9.8s; Acceleration acc = sp1/0.5s;
const std::complex<double> meaning_of_imagination(0, 42);
template<unsigned T> struct Fact { enum Enum { VALUE = Fact<T-1>*T; }; }; template<> struct Fact<1u> { enum Enum { VALUE = 1; }; };
int fact(unsigned n) { if (n==1) return 1; return fact(n-1)*n; } int main() { return fact(10); }
int main() { int tab[fact(10)]; int tab2[std::max(20,30)]; }
constexpr size_t GetMaxIPV4StringLength() { return ( sizeof( "255.255.255.255" ) ); } void SomeIPFunction() { char szIPAddress[ GetMaxIPV4StringLength() ]; SomeIPGetFunction( szIPAddress ); }
using namespace std; int main() { constexpr auto parser = R"*( <span > <p color="red" height= </span> )*"_html; spt::tree spt_tree(parser); spt::template_dict dct; dct["name"] = "Mary"; dct["profession"] = "doctor"; dct["city"] = "London"; spt_tree.root.render(cerr, dct); cerr << endl; dct["city"] = "New York"; dct["name"] = "John"; dct["profession"] = "janitor"; spt_tree.root.render(cerr, dct); cerr << endl; }
class MyInterface { public: int GetNumber() const = 0; };
class MyInterface { public: constexpr int GetNumber() const = 0; };
const int MeaningOfLife = 42; constexpr int MeaningOfLife () { return 42; } int some_arr[MeaningOfLife()];
struct Foo { int n; }; bool operator==(const Foo& lhs, const Foo& rhs) { return lhs.n == rhs.n; } bool operator<(const Foo& lhs, const Foo& rhs) { return lhs.n < rhs.n; } int main() { Foo f1 = {1}; Foo f2 = {2}; using namespace std::rel_ops; std::cout << "not equal: : " << (f1 != f2) << std::cout << "greater: : " << (f1 > f2) << std::cout << "less equal: : " << (f1 <= f2) << std::cout << "greater equal: : " << (f1 >= f2) << }
template<typename RhsT> ResultBuilder& operator == ( RhsT const& rhs ) { return captureExpression<Internal::IsEqualTo>( rhs ); } template<typename RhsT> ResultBuilder& operator != ( RhsT const& rhs ) { return captureExpression<Internal::IsNotEqualTo>( rhs ); }
$ ghci GHCi, version 7.10.2: http: λ> :i Eq class Eq a where (==) :: a -> a -> Bool (/=) :: a -> a -> Bool -- Defined in `GHC.Classes'
enum BoolPlus { kFalse = 0, kTrue = 1, kFileNotFound = -1 } BoolPlus operator==(File& other); BoolPlus operator!=(File& other);
int rot_x, rot_y; rot_x = -arrRect1[3]; rot_y = arrRect1[2]; int pnt_x, pnt_y; pnt_x = arrRect1[2]; pnt_y = arrRect1[3]; int tst_x, tst_y; tst_x = arrRect2[0]; tst_y = arrRect2[1]; int value; value = (rot_x * (tst_x - pnt_x)) + (rot_y * (tst_y - pnt_y)); cout << "Value: " << value;
if (RectA.Left < RectB.Right && RectA.Right > RectB.Left && RectA.Top > RectB.Bottom && RectA.Bottom < RectB.Top )
if (RectA.X1 < RectB.X2 && RectA.X2 > RectB.X1 && RectA.Y1 > RectB.Y2 && RectA.Y2 < RectB.Y1)
struct rect { int x; int y; int width; int height; }; bool valueInRange(int value, int min, int max) { return (value >= min) && (value <= max); } bool rectOverlap(rect A, rect B) { bool xOverlap = valueInRange(A.x, B.x, B.x + B.width) || valueInRange(B.x, A.x, A.x + A.width); bool yOverlap = valueInRange(A.y, B.y, B.y + B.height) || valueInRange(B.y, A.y, A.y + A.height); return xOverlap && yOverlap; }
struct Rect { Rect(int x1, int x2, int y1, int y2) : x1(x1), x2(x2), y1(y1), y2(y2) { assert(x1 < x2); assert(y1 < y2); } int x1, x2, y1, y2; }; bool overlap(const Rect &r1, const Rect &r2) { bool noOverlap = r1.x1 > r2.x2 || r2.x1 > r1.x2 || r1.y1 > r2.y2 || r2.y1 > r1.y2; return !noOverlap; }
function checkOverlap(r1, r2) : Boolean { return !(r1.x + r1.width < r2.x || r1.y + r1.height < r2.y || r1.x > r2.x + r2.width || r1.y > r2.y + r2.height); }
class Vector2D { public: Vector2D(int x, int y) : x(x), y(y) {} ~Vector2D(){} int x, y; }; bool DoRectanglesOverlap( const Vector2D & Pos1, const Vector2D & Size1, const Vector2D & Pos2, const Vector2D & Size2) { if ((Pos1.x < Pos2.x + Size2.x) && (Pos1.y < Pos2.y + Size2.y) && (Pos2.x < Pos1.x + Size1.x) && (Pos2.y < Pos1.y + Size1.y)) { return true; } return false; }
DoRectanglesOverlap(Vector2D(3, 7), Vector2D(8, 5), Vector2D(6, 4), Vector2D(9, 4));
if ((Pos1.x < Pos2.x + Size2.x) && (Pos1.y < Pos2.y + Size2.y) && (Pos2.x < Pos1.x + Size1.x) && (Pos2.y < Pos1.y + Size1.y)) ↓ if (( 3 < 6 + 9 ) && ( 7 < 4 + 4 ) && ( 6 < 3 + 8 ) && ( 4 < 7 + 5 ))
struct Rectangle { int x; int y; int width; int height; }; bool is_left_of(Rectangle const & a, Rectangle const & b) { if (a.x + a.width <= b.x) return true; return false; } bool is_right_of(Rectangle const & a, Rectangle const & b) { return is_left_of(b, a); } bool not_intersect( Rectangle const & a, Rectangle const & b) { if (is_left_of(a, b)) return true; if (is_right_of(a, b)) return true; } bool intersect(Rectangle const & a, Rectangle const & b) { return !not_intersect(a, b); }
public boolean intersects(Rectangle r) { int tw = this.width; int th = this.height; int rw = r.width; int rh = r.height; if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) { return false; } int tx = this.x; int ty = this.y; int rx = r.x; int ry = r.y; rw += rx; rh += ry; tw += tx; th += ty; return ((rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry)); }
struct Rect { Rect(int x1, int x2, int y1, int y2) : x1(x1), x2(x2), y1(y1), y2(y2) { assert(x1 < x2); assert(y1 < y2); } int x1, x2, y1, y2; }; bool overlap(const Rect &r1, const Rect &r2) { return r1.x1 < r2.x2 && r2.x1 < r1.x2 && r1.y1 < r2.y2 && r2.x1 < r1.y2; } bool touch(const Rect &r1, const Rect &r2) { return r1.x1 <= r2.x2 && r2.x1 <= r1.x2 && r1.y1 <= r2.y2 && r2.x1 <= r1.y2; }
/** * Check if two rectangles collide * x_1, y_1, width_1, and height_1 define the boundaries of the first rectangle * x_2, y_2, width_2, and height_2 define the boundaries of the second rectangle */ boolean rectangle_collision(float x_1, float y_1, float width_1, float height_1, float x_2, float y_2, float width_2, float height_2) { return !(x_1 > x_2+width_2 || x_1+width_1 < x_2 || y_1 > y_2+height_2 || y_1+height_1 < y_2); }
public bool Intersects ( Rectangle rect ) { float ulx = Math.Max ( x, rect.x ); float uly = Math.Max ( y, rect.y ); float lrx = Math.Min ( x + width, rect.x + rect.width ); float lry = Math.Min ( y + height, rect.y + rect.height ); return ulx <= lrx && uly <= lry; }
bool bOverlap = !((A.Left >= B.Right || B.Left >= A.Right) && (A.Bottom >= B.Top || B.Bottom >= A.Top));
four points of A be (xAleft,yAtop),(xAleft,yAbottom),(xAright,yAtop),(xAright,yAbottom) four points of A be (xBleft,yBtop),(xBleft,yBbottom),(xBright,yBtop),(xBright,yBbottom) A.width = abs(xAleft-xAright); A.height = abs(yAleft-yAright); B.width = abs(xBleft-xBright); B.height = abs(yBleft-yBright); C.width = max(xAleft,xAright,xBleft,xBright)-min(xAleft,xAright,xBleft,xBright); C.height = max(yAtop,yAbottom,yBtop,yBbottom)-min(yAtop,yAbottom,yBtop,yBbottom); A and B does not overlap if (C.width >= A.width + B.width ) OR (C.height >= A.height + B.height)
import java.util.Scanner; public class ProgrammingEx3_28 { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out .print("Enter r1 double x1 = input.nextDouble(); double y1 = input.nextDouble(); double w1 = input.nextDouble(); double h1 = input.nextDouble(); w1 = w1 / 2; h1 = h1 / 2; System.out .print("Enter r2 double x2 = input.nextDouble(); double y2 = input.nextDouble(); double w2 = input.nextDouble(); double h2 = input.nextDouble(); w2 = w2 / 2; h2 = h2 / 2; double x1max = x1 + w1; double y1max = y1 + h1; double x1min = x1 - w1; double y1min = y1 - h1; double x2max = x2 + w2; double y2max = y2 + h2; double x2min = x2 - w2; double y2min = y2 - h2; if (x1max == x2max && x1min == x2min && y1max == y2max && y1min == y2min) { System.out.print("r1 and r2 are indentical"); } else if (x1max <= x2max && x1min >= x2min && y1max <= y2max && y1min >= y2min) { System.out.print("r1 is inside r2"); } else if (x2max <= x1max && x2min >= x1min && y2max <= y1max && y2min >= y1min) { System.out.print("r2 is inside r1"); } else if (x1max < x2min || x1min > x2max || y1max < y2min || y2min > y1max) { System.out.print("r2 does not overlaps r1"); } else { System.out.print("r2 overlaps r1"); } } }
bool Square::IsOverlappig(Square &other) { bool result1 = other.x >= x && other.y >= y && other.x <= (x + width) && other.y <= (y + height); bool result2 = other.x >= x && other.y <= y && other.x <= (x + width) && (other.y + other.height) <= (y + height); bool result3 = other.x <= x && other.y >= y && (other.x + other.width) <= (x + width) && other.y <= (y + height); bool result4 = other.x <= x && other.y <= y && (other.x + other.width) >= x && (other.y + other.height) >= y; return result1 | result2 | result3 | result4; }
struct Rectangle { float centerX, centerY, halfWidth, halfHeight; }; bool isRectangleOverlapping(const Rectangle &a, const Rectangle &b) { return (fabsf(a.centerX - b.centerX) <= (a.halfWidth + b.halfWidth)) && (fabsf(a.centerY - b.centerY) <= (a.halfHeight + b.halfHeight)); }
for (int i = 0;i < n;i++) { for (int j = 0;j < n; j++) { if (i != j) { Rectangle rectangle1 = rectangles.get(i); Rectangle rectangle2 = rectangles.get(j); int l1 = rectangle1.l; int r1 = rectangle1.r; int b1 = rectangle1.b; int t1 = rectangle1.t; int l2 = rectangle2.l; int r2 = rectangle2.r; int b2 = rectangle2.b; int t2 = rectangle2.t; boolean topOnBottom = t2 == b1; boolean bottomOnTop = b2 == t1; boolean topOrBottomContact = topOnBottom || bottomOnTop; boolean rightOnLeft = r2 == l1; boolean leftOnRight = l2 == r1; boolean rightOrLeftContact = leftOnRight || rightOnLeft; boolean leftPoll = l2 <= l1 && r2 >= l1; boolean rightPoll = l2 <= r1 && r2 >= r1; boolean leftRightInside = l2 >= l1 && r2 <= r1; boolean leftRightPossiblePlaces = leftPoll || rightPoll || leftRightInside; boolean bottomPoll = t2 >= b1 && b2 <= b1; boolean topPoll = b2 <= b1 && t2 >= b1; boolean topBottomInside = b2 >= b1 && t2 <= t1; boolean topBottomPossiblePlaces = bottomPoll || topPoll || topBottomInside; boolean topInBetween = t2 > b1 && t2 < t1; boolean bottomInBetween = b2 > b1 && b2 < t1; boolean topBottomInBetween = topInBetween || bottomInBetween; boolean leftInBetween = l2 > l1 && l2 < r1; boolean rightInBetween = r2 > l1 && r2 < r1; boolean leftRightInBetween = leftInBetween || rightInBetween; if ( (topOrBottomContact && leftRightPossiblePlaces) || (rightOrLeftContact && topBottomPossiblePlaces) ) { path[i][j] = true; } } } }
double arr[100]; std::copy(v.begin(), v.end(), arr);
vector<double> thevector; double *thearray = &thevector[0];
using namespace std; int main() { ios::sync_with_stdio(false); vector<int>v = {7, 8, 9, 10, 11}; int *arr = v.data(); for(int i=0; i<v.size(); i++) { cout<<arr[i]<<" "; } return 0; }
template <class T, class Alloc = allocator<T>> class vector{ public: typedef T value_type; typedef T* iterator; typedef T* pointer; private: pointer start_; pointer finish_; pointer end_of_storage_; public: vector():start_(0), finish_(0), end_of_storage_(0){} }
vector <int> id; vector <double> v; if(id.size() > 0) { for(int i = 0; i < id.size(); i++) { for(int j = 0; j < id.size(); j++) { double x = v[i][j]; cout << x << endl; } } }
std::string s = get_string(); std::string t = another_string(); if( !s.compare(t) ) {
template<class charT, class traits, class Allocator> bool operator==(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs) noexcept;
if (str1 == str2) 00D42A34 lea eax,[str2] 00D42A37 push eax 00D42A38 lea ecx,[str1] 00D42A3B push ecx 00D42A3C call std::operator==<char,std::char_traits<char>,std::allocator<char> > (0D23EECh) 00D42A41 add esp,8 00D42A44 movzx edx,al 00D42A47 test edx,edx 00D42A49 je Algorithm::PerformanceTest::stringComparison_usingEqualOperator1+0C4h (0D42A54h)
if (str1.compare(str2) == 0) 00D424D4 lea eax,[str2] 00D424D7 push eax 00D424D8 lea ecx,[str1] 00D424DB call std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare (0D23582h) 00D424E0 test eax,eax 00D424E2 jne Algorithm::PerformanceTest::stringComparison_usingCompare1+0BDh (0D424EDh)
if (str1 == str2) 008533F0 cmp dword ptr [ebp-14h],10h 008533F4 lea eax,[str2] 008533F7 push dword ptr [ebp-18h] 008533FA cmovae eax,dword ptr [str2] 008533FE push eax 008533FF push dword ptr [ebp-30h] 00853402 push ecx 00853403 lea ecx,[str1] 00853406 call std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare (0853B80h)
if (str1.compare(str2) == 0) 00853830 cmp dword ptr [ebp-14h],10h 00853834 lea eax,[str2] 00853837 push dword ptr [ebp-18h] 0085383A cmovae eax,dword ptr [str2] 0085383E push eax 0085383F push dword ptr [ebp-30h] 00853842 push ecx 00853843 lea ecx,[str1] 00853846 call std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare (0853B80h)
/** * @brief Test equivalence of two strings. * @param __lhs First string. * @param __rhs Second string. * @return True if @a __lhs.compare(@a __rhs) == 0. False otherwise. */ template<typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs) { return __lhs.compare(__rhs) == 0; } template<typename _CharT> inline typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator==(const basic_string<_CharT>& __lhs, const basic_string<_CharT>& __rhs) { return (__lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size())); } /** * @brief Test equivalence of C string and string. * @param __lhs C string. * @param __rhs String. * @return True if @a __rhs.compare(@a __lhs) == 0. False otherwise. */ template<typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs) { return __rhs.compare(__lhs) == 0; } /** * @brief Test equivalence of string and C string. * @param __lhs String. * @param __rhs C string. * @return True if @a __lhs.compare(@a __rhs) == 0. False otherwise. */ template<typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs, const _CharT* __rhs) { return __lhs.compare(__rhs) == 0; }
std::vector<int> numbers = { 1, 2, 3, 4, 5, 6, 7 }; for ( auto xyz : numbers ) { std::cout << xyz << std::endl; }
std::map< foo, bar > testing = { }; for ( auto abc : testing ) { std::cout << abc << std::endl; std::cout << abc->first << std::endl; }
for (auto& kv : myMap) { std::cout << kv.first << " has value " << kv.second << std::endl; }
for (auto& [key, value]: myMap) { std::cout << key << " has value " << value << std::endl; }
std::map< foo, bar > testing = { }; for ( const auto& [ k, v ] : testing ) { std::cout << k << "=" << v << "\n"; }
{ typedef decltype(expression) C; auto&& rng(expression); for (auto begin(std::For<C>::begin(rng)), end(std::For<C>::end(rng)); begin != end; ++ begin) { type-speciﬁer-seq simple-declarator(*begin); statement } }
for (const auto& value : myMap | boost::adaptors::map_values) { std::cout << value << std::endl; }
foo f; bar b; BOOST_FOREACH(boost::tie(f,b),testing) { cout << "Foo is " << f << " Bar is " << b; }
foo f;bar b; for(std::tie(f,b) : testing) { cout << "Foo is " << f << " Bar is " << b; }
struct C { C() {} C(const C&) { std::cout << "A copy was made.\n"; } }; C f() { return C(); } int main() { std::cout << "Hello World!\n"; C obj = f(); }
struct C { C() {} C(const C&) { std::cout << "A copy was made.\n"; } }; C f() { return C(); } C g() { C c; return c; } int main() { std::cout << "Hello World!\n"; C obj = f(); }
class Thing { public: Thing(); ~Thing(); Thing(const Thing&); }; Thing f() { Thing t; return t; } Thing t2 = f();
class Thing { public: Thing(); ~Thing(); Thing(const Thing&); }; Thing f() { Thing t; return t; } Thing t2 = f();
class Thing { public: Thing(); ~Thing(); Thing(const Thing&); }; Thing f() { return Thing(); } Thing t2 = f();
class Thing { public: Thing(); ~Thing(); Thing(const Thing&); }; void foo(Thing t); foo(Thing());
struct Thing{ Thing(); Thing(const Thing&); }; void foo() { Thing c; throw c; } int main() { try { foo(); } catch(Thing c) { } }
using namespace std; class ABC { public: const char *a; ABC() { cout<<"Constructor"<<endl; } ABC(const char *ptr) { cout<<"Constructor"<<endl; } ABC(ABC &obj) { cout<<"copy constructor"<<endl;} ABC(ABC&& obj) { cout<<"Move constructor"<<endl; } ~ABC() { cout<<"Destructor"<<endl; } }; ABC fun123() { ABC obj; return obj; } ABC xyz123() { return ABC(); } int main() { ABC abc; ABC obj1(fun123()); ABC obj2(xyz123()); ABC xyz = "Stack Overflow"; return 0; } **Output without -fno-elide-constructors** root@ajay-PC:/home/ajay/c++ Constructor Constructor Constructor Constructor Destructor Destructor Destructor Destructor **Output with -fno-elide-constructors** root@ajay-PC:/home/ajay/c++ root@ajay-PC:/home/ajay/c++ Constructor Constructor Move constructor Destructor Move constructor Destructor Constructor Move constructor Destructor Move constructor Destructor Constructor Move constructor Destructor Destructor Destructor Destructor Destructor
int n = 0; class ABC { public: ABC(int) {} ABC(const ABC& a) { ++n; } }; int main() { ABC c1(21); ABC c2 = ABC(21); std::cout << n << std::endl; return 0; } Output without -fno-elide-constructors root@ajay-PC:/home/ayadav root@ajay-PC:/home/ayadav 0 Output with -fno-elide-constructors root@ajay-PC:/home/ayadav root@ajay-PC:/home/ayadav 1
double d = 3.14159265358979; cout.precision(17); cout << "Pi: " << fixed << d << endl;
typedef std::numeric_limits< double > dbl; double d = 3.14159265358979; cout.precision(dbl::max_digits10); cout << "Pi: " << d << endl;
std::cout << std::setprecision (15) << 3.14159265358979 << std::endl;
std::cout << std::setprecision (std::numeric_limits<double>::digits10 + 1) << 3.14159265358979 << std::endl;
using boost::lexical_cast; using std::string; double d = 3.14159265358979; cout << "Pi: " << lexical_cast<string>(d) << endl;
double d = 100.0000000000005; int precision = std::numeric_limits<double>::max_digits10; std::cout << std::setprecision(precision) << d << std::endl;
double d = 100.0000000000005; int precision = std::numeric_limits<double>::max_digits10; std::cout << std::fixed << std::setprecision(precision) << d << std::endl;
union { double d; uint64_t u64; } x; x.d = 1.1; std::cout << std::hex << x.u64;
using std::numeric_limits; ... cout.precision(numeric_limits<double>::digits10 + 1); cout << d;
cout.precision( numeric_limits<double>::digits10 + 1); cout << M_PI << ", " << M_E << endl;
std::cout.precision(std::numeric_limits<double>::max_digits10 - 1); std::cout << std::scientific << 1.0/7.0 << 1.4285714285714285e-01
std::cout << "hexfloat: " << std::hexfloat << exp (-100) << std::cout << "hexfloat: " << std::hexfloat << exp (+100) << hexfloat: 0x1.a8c1f14e2af5dp-145 hexfloat: 0x1.3494a9b171bf5p+144
std::cout << "std::fixed: " << std::fixed << exp (-100) << std::cout << "std::fixed: " << std::fixed << exp (+100) << std::fixed: 0.000000 std::fixed: 26881171418161356094253400435962903554686976.000000
std::cout << "std::scientific: " << std::scientific << exp (-100) << std::cout << "std::scientific: " << std::scientific << exp (+100) << std::scientific: 3.720076e-44 std::scientific: 2.688117e+43
typedef std::numeric_limits< double > dbl; std::cout.precision(dbl::max_digits10 - 1); std::cout << std::scientific << exp (-100) << std::cout << std::scientific << exp (+100) << 3.7200759760208361e-44 2.6881171418161356e+43
/* * C++ Singleton * Limitation: Single Threaded Design * See: http: * For problems associated with locking in multi threaded applications * * Limitation: * If you use this Singleton (A) within a destructor of another Singleton (B) * This Singleton (A) must be fully constructed before the constructor of (B) * is called. */ class MySingleton { private: MySingleton(); MySingleton(MySingleton const& copy); MySingleton& operator=(MySingleton const& copy); public: static MySingleton& getInstance() { static MySingleton instance; return instance; } };
using namespace std; std::mutex mtx; class MySingleton{ private: static MySingleton * singletonInstance; MySingleton(); ~MySingleton(); public: static MySingleton* GetInstance(); MySingleton(const MySingleton&) = delete; const MySingleton& operator=(const MySingleton&) = delete; MySingleton(MySingleton&& other) noexcept = delete; MySingleton& operator=(MySingleton&& other) noexcept = delete; }; MySingleton* MySingleton::singletonInstance = nullptr; MySingleton::MySingleton(){ }; MySingleton::~MySingleton(){ delete singletonInstance; }; MySingleton* MySingleton::GetInstance(){ if (singletonInstance == NULL){ std::lock_guard<std::mutex> lock(mtx); if (singletonInstance == NULL) singletonInstance = new MySingleton(); } return singletonInstance; }
using System; using System.Collections; using System.Threading; namespace DoFactory.GangOfFour.Singleton.RealWorld { class MainApp { static void Main() { LoadBalancer b1 = LoadBalancer.GetLoadBalancer(); LoadBalancer b2 = LoadBalancer.GetLoadBalancer(); LoadBalancer b3 = LoadBalancer.GetLoadBalancer(); LoadBalancer b4 = LoadBalancer.GetLoadBalancer(); if (b1 == b2 && b2 == b3 && b3 == b4) { Console.WriteLine("Same instance\n"); } for (int i = 0; i < 15; i++) { Console.WriteLine(b1.Server); } Console.Read(); } } class LoadBalancer { private static LoadBalancer instance; private ArrayList servers = new ArrayList(); private Random random = new Random(); private static object syncLock = new object(); protected LoadBalancer() { servers.Add("ServerI"); servers.Add("ServerII"); servers.Add("ServerIII"); servers.Add("ServerIV"); servers.Add("ServerV"); } public static LoadBalancer GetLoadBalancer() { if (instance == null) { lock (syncLock) { if (instance == null) { instance = new LoadBalancer(); } } } return instance; } public string Server { get { int r = random.Next(servers.Count); return servers[r].ToString(); } } } }
using System; using System.Collections; namespace DoFactory.GangOfFour.Singleton.NETOptimized { class MainApp { static void Main() { LoadBalancer b1 = LoadBalancer.GetLoadBalancer(); LoadBalancer b2 = LoadBalancer.GetLoadBalancer(); LoadBalancer b3 = LoadBalancer.GetLoadBalancer(); LoadBalancer b4 = LoadBalancer.GetLoadBalancer(); if (b1 == b2 && b2 == b3 && b3 == b4) { Console.WriteLine("Same instance\n"); } for (int i = 0; i < 15; i++) { Console.WriteLine(b1.Server); } Console.Read(); } } sealed class LoadBalancer { private static readonly LoadBalancer instance = new LoadBalancer(); private ArrayList servers = new ArrayList(); private Random random = new Random(); private LoadBalancer() { servers.Add("ServerI"); servers.Add("ServerII"); servers.Add("ServerIII"); servers.Add("ServerIV"); servers.Add("ServerV"); } public static LoadBalancer GetLoadBalancer() { return instance; } public string Server { get { int r = random.Next(servers.Count); return servers[r].ToString(); } } } }
namespace { T1 * pt1 = NULL; T2 * pt2 = NULL; T3 * pt3 = NULL; T4 * pt4 = NULL; } int main( int argc, char* argv[]) { T1 t1(args1); T2 t2(args2); T3 t3(args3); T4 t4(args4); pt1 = &t1; pt2 = &t2; pt3 = &t3; pt4 = &t4; dostuff(); } T1& getT1() { return *pt1; } T2& getT2() { return *pt2; } T3& getT3() { return *pt3; } T4& getT4() { return *pt4; }
class Singleton { public: static Singleton& Instance() { if (instance_ == NULL) instance_ = new Singleton(); return *instance_; } private: Singleton() {}; static Singleton *instance_; };
class Foo { public: int bar; Foo(int num): bar(num) {}; }; int main(void) { std::cout << Foo(42).bar << std::endl; return 0; }
Cost of Member Initialization = Object Construction Cost of Member Assignment = Object Construction + Assignment
class MyClass { public: int &i; int b; const int k; MyClass(int a, int b, int c):i(a),b(b),k(c) { } }; class MyClass2:public MyClass { public: int p; int q; MyClass2(int x,int y,int z,int l,int m):MyClass(x,y,z),p(l),q(m) { } }; int main() { int x = 10; int y = 20; int z = 30; MyClass obj(x,y,z); int l = 40; int m = 50; MyClass2 obj2(x,y,z,l,m); return 0; }
class Foo { public: string str; Foo(string &p) { str = p; }; };
class Foo { public: string str; Foo(string &p): str(p) {}; };
using namespace std; unique_ptr<int> foo() { unique_ptr<int> p( new int(10) ); return p; } int main() { unique_ptr<int> p = foo(); cout << *p << endl; return 0; }
std::unique_ptr<int> get_unique() { auto ptr = std::unique_ptr<int>{new int{2}}; return ptr; } ... auto int_uptr = get_unique();
void bar(std::unique_ptr<int> p) { } int main() { unique_ptr<int> p = foo(); bar(p); bar(std::move(p)); return 0; }
class Test {int i;}; std::unique_ptr<Test> foo1() { std::unique_ptr<Test> res(new Test); return res; } std::unique_ptr<Test> foo2(std::unique_ptr<Test>&& t) { return std::move(t); } auto test1=foo1(); auto test2=foo2(std::unique_ptr<Test>(new Test));
std::map< std::string, std::map<std::string, std::string> >
m["name1"]["value1"] = "data1"; m["name1"]["value2"] = "data2"; m["name2"]["value1"] = "data1"; m["name2"]["value2"] = "data2"; m["name3"]["value1"] = "data1"; m["name3"]["value2"] = "data2";
std::map<std::string, std::map<std::string, std::string>> mymap; for(auto const &ent1 : mymap) { for(auto const &ent2 : ent1.second) { } }
for(auto const &ent1 : mymap) { auto const &outer_key = ent1.first; auto const &inner_map = ent1.second; for(auto const &ent2 : inner_map) { auto const &inner_key = ent2.first; auto const &inner_value = ent2.second; } }
typedef std::map<std::string, std::map<std::string, std::string>>::iterator it_type; for(it_type iterator = m.begin(); iterator != m.end(); iterator++) { }
for(std::map<std::string, std::map<std::string, std::string> >::iterator outer_iter=map.begin(); outer_iter!=map.end(); ++outer_iter) { for(std::map<std::string, std::string>::iterator inner_iter=outer_iter->second.begin(); inner_iter!=outer_iter->second.end(); ++inner_iter) { std::cout << inner_iter->second << std::endl; } }
for(auto outer_iter=map.begin(); outer_iter!=map.end(); ++outer_iter) { for(auto inner_iter=outer_iter->second.begin(); inner_iter!=outer_iter->second.end(); ++inner_iter) { std::cout << inner_iter->second << std::endl; } }
typedef std::map<std::string, std::string> InnerMap; typedef std::map<std::string, InnerMap> OuterMap; Outermap mm; ... for (OuterMap::iterator i = mm.begin(); i != mm.end(); ++i) { InnerMap &im = i->second; for (InnerMap::iterator ii = im.begin(); ii != im.end(); ++ii) { std::cout << "map[" << i->first << "][" << ii->first << "] =" << ii->second << } }
for (const auto& [name, description] : planet_descriptions) { std::cout << "Planet " << name << ":\n" << description << "\n\n"; }
std::map< std::string, std::map<std::string, std::string> > m; m["name1"]["value1"] = "data1"; m["name1"]["value2"] = "data2"; m["name2"]["value1"] = "data1"; m["name2"]["value2"] = "data2"; m["name3"]["value1"] = "data1"; m["name3"]["value2"] = "data2"; for (auto i : m) for (auto j : i.second) cout << i.first.c_str() << ":" << j.first.c_str() << ":" << j.second.c_str() << endl;
name1:value1:data1 name1:value2:data2 name2:value1:data1 name2:value2:data2 name3:value1:data1 name3:value2:data2
int main() { std::map<std::string, std::map<std::string, std::string>> m { {"name1", {{"value1", "data1"}, {"value2", "data2"}}}, {"name2", {{"value1", "data1"}, {"value2", "data2"}}}, {"name3", {{"value1", "data1"}, {"value2", "data2"}}} }; for (const auto& [k1, v1] : m) for (const auto& [k2, v2] : v1) std::cout << "m[" << k1 << "][" << k2 << "]=" << v2 << std::endl; return 0; }
void foo(int x = 42, int y = 21); void foo(int x , int y ) { ... }
int CI2cHal::SetI2cSlaveAddress( UCHAR addr, bool force = false ) { ... }
/home/.../mystuff/domoproject/lib/i2cdevs/max6956io.cpp: In member function /home/.../mystuff/domoproject/lib/i2cdevs/max6956io.cpp:26:30: error: no matching function for call to /home/.../mystuff/domoproject/lib/i2cdevs/max6956io.cpp:26:30: note: candidate is: In file included from /home/geertvc/mystuff/domoproject/lib/i2cdevs/../../include/i2cdevs/max6956io.h:35:0, from /home/geertvc/mystuff/domoproject/lib/i2cdevs/max6956io.cpp:1: /home/.../mystuff/domoproject/lib/i2cdevs/../../include/i2chal/i2chal.h:65:9: note: int CI2cHal::SetI2cSlaveAddress(unsigned char, bool) /home/.../mystuff/domoproject/lib/i2cdevs/../../include/i2chal/i2chal.h:65:9: note: candidate expects 2 arguments, 1 provided make[2]: *** [lib/i2cdevs/CMakeFiles/i2cdevs.dir/max6956io.cpp.o] Error 1 make[1]: *** [lib/i2cdevs/CMakeFiles/i2cdevs.dir/all] Error 2 make: *** [all] Error 2
void testFunct(int nVal1, int nVal2=500); void testFunct(int nVal1, int nVal2) { using namespace std; cout << nVal1 << << nVal2 << endl; }
struct iface { virtual void test(int a = 0) { std::cout << a; } }; struct impl : public iface { virtual void test(int a = 5) override { std::cout << a; } }; int main() { impl d; d.test(); iface* a = &d; a->test(); }
void function(char const *msg, bool three, bool two, bool one = false); void function(char const *msg, bool three = true, bool two, bool one); void function(char const *msg, bool three, bool two = true, bool one); int main() { function("Using only one Default Argument", false, true); function("Using Two Default Arguments", false); function("Using Three Default Arguments"); return 0; } void function(char const *msg, bool three, bool two, bool one ) { std::cout<<msg<<" "<<three<<" "<<two<<" "<<one<<std::endl; }
std::string str("foo"); std::string * pstr = new std::string("foo"); str.size (); pstr->size ();
int main() { std::vector<int> iVec; iVec.push_back(42); std::vector<int>* iVecPtr = &iVec; int i = (*iVecPtr)[0]; }
MyClass a1 {a}; MyClass a2 = {a}; MyClass a3 = a; MyClass a4(a);
void fun(double val, int val2) { int x2 = val; char c2 = val2; int x3 {val}; char c3 {val2}; char c4 {24}; char c5 {264}; int x4 {2.0}; }
struct Foo { Foo() {} Foo(std::initializer_list<Foo>) { std::cout << "initializer list" << std::endl; } Foo(const Foo&) { std::cout << "copy ctor" << std::endl; } }; int main() { Foo a; Foo b(a); Foo c{a}; }
vector<int> a{10,20}; vector<int> b(10,20); vector<int> c(it1,it2); vector<int> d{};
struct Vec2 { Vec2(float x, float y); Vec2(float angle, float magnitude); };
struct Vec2 { static Vec2 fromLinear(float x, float y); static Vec2 fromPolar(float angle, float magnitude); };
class FooFactory { public Foo createFooInSomeWay() { return new Foo(some, args); } }
class FooFactory { public: Foo* createFooInSomeWay() { return new Foo(some, args); } };
class FooFactory { public: Foo* createFooInSomeWay() { return new Foo(some, args); } Foo createFooInSomeWay() { return Foo(some, args); } };
class FooFactory { public: Foo* createDynamicFooInSomeWay() { return new Foo(some, args); } Foo createFooObjectInSomeWay() { return Foo(some, args); } };
class Foo { public: Foo() { } }; class FooFactory { public: void createFooInSomeWay(Foo& foo, some, args); }; void clientCode() { Foo staticFoo; auto_ptr<Foo> dynamicFoo = new Foo(); FooFactory factory; factory.createFooInSomeWay(&staticFoo); factory.createFooInSomeWay(&dynamicFoo.get()); }
Vec2(float x, float y); Vec2(float angle, float magnitude);
struct Cartesian { inline Cartesian(float x, float y): x(x), y(y) {} float x, y; }; struct Polar { inline Polar(float angle, float magnitude): angle(angle), magnitude(magnitude) {} float angle, magnitude; }; Vec2(const Cartesian &cartesian); Vec2(const Polar &polar);
class Abstract { public: virtual void do() = 0; }; class Factory { public: Abstract *create(); }; Factory f; Abstract *a = f.create(); a->do();
class FactoryReleaseOwnership{ public: std::unique_ptr<Foo> createFooInSomeWay(){ return std::unique_ptr<Foo>(new Foo(some, args)); } }; class FactoryRetainOwnership{ boost::ptr_vector<Foo> myFoo; public: Foo& createFooInSomeWay(){ myFoo.push_back(new Foo(some, args)); return myFoo.back(); } };
struct linear { linear(float x, float y) : x_(x), y_(y){} float x_; float y_; }; struct polar { polar(float angle, float magnitude) : angle_(angle), magnitude_(magnitude) {} float angle_; float magnitude_; }; struct Vec2 { explicit Vec2(const linear &l) { } explicit Vec2(const polar &p) { } };
struct linear_coord_tag linear_coord {}; struct polar_coord_tag polar_coord {}; struct Vec2 { Vec2(float x, float y, const linear_coord_tag &) { } Vec2(float angle, float magnitude, const polar_coord_tag &) { } };
template <typename T> class Factory { public: template <typename TDerived> void registerType(QString name) { static_assert(std::is_base_of<T, TDerived>::value, "Factory::registerType doesn _createFuncs[name] = &createFunc<TDerived>; } T* create(QString name) { typename QMap<QString,PCreateFunc>::const_iterator it = _createFuncs.find(name); if (it != _createFuncs.end()) { return it.value()(); } return nullptr; } private: template <typename TDerived> static T* createFunc() { return new TDerived(); } typedef T* (*PCreateFunc)(); QMap<QString,PCreateFunc> _createFuncs; };
Factory<BaseClass> f; f.registerType<Descendant1>("Descendant1"); f.registerType<Descendant2>("Descendant2"); Descendant1* d1 = static_cast<Descendant1*>(f.create("Descendant1")); Descendant2* d2 = static_cast<Descendant2*>(f.create("Descendant2")); BaseClass *b1 = f.create("Descendant1"); BaseClass *b2 = f.create("Descendant2");
struct sandwich { static sandwich ham(); static sandwich spam(); sandwich(sandwich &&); };
auto lunch = std::make_pair(sandwich::spam(), apple{});
auto ptr = std::make_shared<sandwich>(sandwich::ham());
class Point { public: static Point Cartesian(double x, double y); private: };
template <class base, class... params> class factory { public: factory() {} factory(const factory &) = delete; factory &operator=(const factory &) = delete; auto create(const std::string name, params... args) { auto key = your_hash_func(name.c_str(), name.size()); return std::move(create(key, args...)); } auto create(key_t key, params... args) { std::unique_ptr<base> obj{creators_[key](args...)}; return obj; } void register_creator(const std::string name, std::function<base *(params...)> &&creator) { auto key = your_hash_func(name.c_str(), name.size()); creators_[key] = std::move(creator); } protected: std::unordered_map<key_t, std::function<base *(params...)>> creators_; };
class base { public: base(int val) : val_(val) {} virtual ~base() { std::cout << "base destroyed\n"; } protected: int val_ = 0; }; class foo : public base { public: foo(int val) : base(val) { std::cout << "foo " << val << " \n"; } static foo *create(int val) { return new foo(val); } virtual ~foo() { std::cout << "foo destroyed\n"; } }; class bar : public base { public: bar(int val) : base(val) { std::cout << "bar " << val << "\n"; } static bar *create(int val) { return new bar(val); } virtual ~bar() { std::cout << "bar destroyed\n"; } }; int main() { common::factory<base, int> factory; auto foo_creator = std::bind(&foo::create, std::placeholders::_1); auto bar_creator = std::bind(&bar::create, std::placeholders::_1); factory.register_creator("foo", foo_creator); factory.register_creator("bar", bar_creator); { auto foo_obj = std::move(factory.create("foo", 80)); foo_obj.reset(); } { auto bar_obj = std::move(factory.create("bar", 90)); bar_obj.reset(); } }
for (auto i = c.rbegin(); i != c.rend(); ++i) { ...
int main() { std::list<int> x { 2, 3, 5, 7, 11, 13, 17, 19 }; for (auto i : boost::adaptors::reverse(x)) std::cout << i << for (auto i : x) std::cout << i << }
template <typename T> struct reversion_wrapper { T& iterable; }; template <typename T> auto begin (reversion_wrapper<T> w) { return std::rbegin(w.iterable); } template <typename T> auto end (reversion_wrapper<T> w) { return std::rend(w.iterable); } template <typename T> reversion_wrapper<T> reverse (T&& iterable) { return { iterable }; }
template <typename T> void print_iterable (std::ostream& out, const T& iterable) { for (auto&& element: iterable) out << element << out << } int main (int, char**) { using namespace std; print_iterable(cout, reverse(initializer_list<int> { 1, 2, 3, 4, })); const list<int> ints_list { 1, 2, 3, 4, }; for (auto&& el: reverse(ints_list)) cout << el << cout << vector<int> ints_vec { 0, 0, 0, 0, }; size_t i = 0; for (int& el: reverse(ints_vec)) el += i++; print_iterable(cout, ints_vec); print_iterable(cout, reverse(ints_vec)); return 0; }
template <typename I> reverse_iterator<I> make_reverse_iterator (I i) { return std::reverse_iterator<I> { i }; } template <typename T> auto rbegin (T& iterable) { return make_reverse_iterator(iterable.end()); } template <typename T> auto rend (T& iterable) { return make_reverse_iterator(iterable.begin()); } template <typename T> auto rbegin (const T& iterable) { return make_reverse_iterator(iterable.end()); } template <typename T> auto rend (const T& iterable) { return make_reverse_iterator(iterable.begin()); }
namespace std { template<class T> T begin(std::pair<T, T> p) { return p.first; } template<class T> T end(std::pair<T, T> p) { return p.second; } } template<class Iterator> std::reverse_iterator<Iterator> make_reverse_iterator(Iterator it) { return std::reverse_iterator<Iterator>(it); } template<class Range> std::pair<std::reverse_iterator<decltype(begin(std::declval<Range>()))>, std::reverse_iterator<decltype(begin(std::declval<Range>()))>> make_reverse_range(Range&& r) { return std::make_pair(make_reverse_iterator(begin(r)), make_reverse_iterator(end(r))); } for(auto x: make_reverse_range(r)) { ... }
int main(int argc, char* argv[]){ typedef std::list<int> Nums; typedef Nums::iterator NumIt; typedef boost::range_reverse_iterator<Nums>::type RevNumIt; typedef boost::iterator_range<NumIt> irange_1; typedef boost::iterator_range<RevNumIt> irange_2; Nums n = {1, 2, 3, 4, 5, 6, 7, 8}; irange_1 r1 = boost::make_iterator_range( boost::begin(n), boost::end(n) ); irange_2 r2 = boost::make_iterator_range( boost::end(n), boost::begin(n) ); for(auto e : r1) std::cout << e << std::cout << std::endl; for(auto e : r2) std::cout << e << std::cout << std::endl; return 0; }
template <typename C> struct reverse_wrapper { C & c_; reverse_wrapper(C & c) : c_(c) {} typename C::reverse_iterator begin() {return c_.rbegin();} typename C::reverse_iterator end() {return c_.rend(); } }; template <typename C, size_t N> struct reverse_wrapper< C[N] >{ C (&c_)[N]; reverse_wrapper( C(&c)[N] ) : c_(c) {} typename std::reverse_iterator<const C *> begin() { return std::rbegin(c_); } typename std::reverse_iterator<const C *> end() { return std::rend(c_); } }; template <typename C> reverse_wrapper<C> r_wrap(C & c) { return reverse_wrapper<C>(c); }
int main(int argc, const char * argv[]) { std::vector<int> arr{1, 2, 3, 4, 5}; int arr1[] = {1, 2, 3, 4, 5}; for (auto i : r_wrap(arr)) { printf("%d ", i); } printf("\n"); for (auto i : r_wrap(arr1)) { printf("%d ", i); } printf("\n"); return 0; }
template<typename T> struct Reverse { T& m_T; METHOD(begin()); METHOD(end()); METHOD(begin(), const); METHOD(end(), const); }; template<typename T> Reverse<T> MakeReverse (T& t) { return Reverse<T>{t}; }
int main() { int integers[] = { 0, 1, 2, 3, 4 }; BOOST_REVERSE_FOREACH(auto i, integers) { std::cout << i << std::endl; } return 0; }
enum { kAudioFormatLinearPCM = kAudioFormatAC3 = kAudioFormat60958AC3 = kAudioFormatAppleIMA4 = kAudioFormatMPEG4AAC = kAudioFormatMPEG4CELP = } ;
struct Multibyte { union{ int val ; char vals[4]; }; Multibyte() : val(0) { } Multibyte( int in ) { vals[0] = MASK(in,3); vals[1] = MASK(in,2); vals[2] = MASK(in,1); vals[3] = MASK(in,0); } char operator[]( int i ) { return val >> (3-i)*8 ; } void println() { for( int i = 0 ; i < 4 ; i++ ) putc( vals[i], stdout ) ; puts( "" ) ; } } ; int main(int argc, const char * argv[]) { Multibyte( Multibyte( Multibyte( Multibyte( Multibyte( return 0; }
byte* buffer = ...; if(*(int*)buffer == invoke_get_method(buffer+4);
class MyClass{ std::mutex my_mutex; void member_foo() { std::lock_guard<mutex_type> lock(this->my_mutex); /* block of code which needs mutual exclusion (e.g. open the same file in multiple threads). */ };
void foo(int x, int y, int z) { int values[x][y][z]; }
void foo(int x, int y, int z) { vector< vector< vector<int> > > values( ); }
template<typename T> struct S { ... }; int A[n]; S<decltype(A)> s;
template<typename T> bool myfunc(T& t1, T& t2) { ... }; int A1[n1], A2[n2]; myfunc(A1, A2);
void foo (int n) { int *values = (int *)alloca(sizeof(int) * n); }
void varTest(int iSz) { char *varArray; __asm { sub esp, iSz mov varArray, esp } __asm { add esp, iSz } }
void foo(int n) { int* values = new int[n]; [...] delete [] values; }
using namespace std; int main() { clock_t start, end; start = clock(); char buf[BUFSIZ]; size_t size; FILE* source = fopen("from.ogv", "rb"); FILE* dest = fopen("to.ogv", "wb"); while (size = fread(buf, 1, BUFSIZ, source)) { fwrite(buf, 1, size, dest); } fclose(source); fclose(dest); end = clock(); cout << "CLOCKS_PER_SEC " << CLOCKS_PER_SEC << "\n"; cout << "CPU-TIME START " << start << "\n"; cout << "CPU-TIME END " << end << "\n"; cout << "CPU-TIME END - START " << end - start << "\n"; cout << "TIME(SEC) " << static_cast<double>(end - start) / CLOCKS_PER_SEC << "\n"; return 0; }
using namespace std; int main() { clock_t start, end; start = clock(); char buf[BUFSIZ]; size_t size; int source = open("from.ogv", O_RDONLY, 0); int dest = open("to.ogv", O_WRONLY | O_CREAT /*| O_TRUNC/**/, 0644); while ((size = read(source, buf, BUFSIZ)) > 0) { write(dest, buf, size); } close(source); close(dest); end = clock(); cout << "CLOCKS_PER_SEC " << CLOCKS_PER_SEC << "\n"; cout << "CPU-TIME START " << start << "\n"; cout << "CPU-TIME END " << end << "\n"; cout << "CPU-TIME END - START " << end - start << "\n"; cout << "TIME(SEC) " << static_cast<double>(end - start) / CLOCKS_PER_SEC << "\n"; return 0; }
using namespace std; int main() { clock_t start, end; start = clock(); ifstream source("from.ogv", ios::binary); ofstream dest("to.ogv", ios::binary); dest << source.rdbuf(); source.close(); dest.close(); end = clock(); cout << "CLOCKS_PER_SEC " << CLOCKS_PER_SEC << "\n"; cout << "CPU-TIME START " << start << "\n"; cout << "CPU-TIME END " << end << "\n"; cout << "CPU-TIME END - START " << end - start << "\n"; cout << "TIME(SEC) " << static_cast<double>(end - start) / CLOCKS_PER_SEC << "\n"; return 0; }
using namespace std; int main() { clock_t start, end; start = clock(); ifstream source("from.ogv", ios::binary); ofstream dest("to.ogv", ios::binary); istreambuf_iterator<char> begin_source(source); istreambuf_iterator<char> end_source; ostreambuf_iterator<char> begin_dest(dest); copy(begin_source, end_source, begin_dest); source.close(); dest.close(); end = clock(); cout << "CLOCKS_PER_SEC " << CLOCKS_PER_SEC << "\n"; cout << "CPU-TIME START " << start << "\n"; cout << "CPU-TIME END " << end << "\n"; cout << "CPU-TIME END - START " << end - start << "\n"; cout << "TIME(SEC) " << static_cast<double>(end - start) / CLOCKS_PER_SEC << "\n"; return 0; }
using namespace std; int main() { clock_t start, end; start = clock(); ifstream source("from.ogv", ios::binary); ofstream dest("to.ogv", ios::binary); source.seekg(0, ios::end); ifstream::pos_type size = source.tellg(); source.seekg(0); char* buffer = new char[size]; source.read(buffer, size); dest.write(buffer, size); delete[] buffer; source.close(); dest.close(); end = clock(); cout << "CLOCKS_PER_SEC " << CLOCKS_PER_SEC << "\n"; cout << "CPU-TIME START " << start << "\n"; cout << "CPU-TIME END " << end << "\n"; cout << "CPU-TIME END - START " << end - start << "\n"; cout << "TIME(SEC) " << static_cast<double>(end - start) / CLOCKS_PER_SEC << "\n"; return 0; }
using namespace std; int main() { clock_t start, end; start = clock(); int source = open("from.ogv", O_RDONLY, 0); int dest = open("to.ogv", O_WRONLY | O_CREAT /*| O_TRUNC/**/, 0644); struct stat stat_source; fstat(source, &stat_source); sendfile(dest, source, 0, stat_source.st_size); close(source); close(dest); end = clock(); cout << "CLOCKS_PER_SEC " << CLOCKS_PER_SEC << "\n"; cout << "CPU-TIME START " << start << "\n"; cout << "CPU-TIME END " << end << "\n"; cout << "CPU-TIME END - START " << end - start << "\n"; cout << "TIME(SEC) " << static_cast<double>(end - start) / CLOCKS_PER_SEC << "\n"; return 0; }
1. $ rm from.ogg 2. $ reboot 3. $ (time ./program) &>> report.txt 4. $ sha256sum *.ogv 5. $ rm to.ogg 6. $ (time ./program) &>> report.txt
Program Description UNBUFFERED|BUFFERED ANSI C (fread/frwite) 490,000|260,000 POSIX (K&R, read/write) 450,000|230,000 FSTREAM (KISS, Streambuffer) 500,000|270,000 FSTREAM (Algorithm, copy) 500,000|270,000 FSTREAM (OWN-BUFFER) 500,000|340,000 SENDFILE (native LINUX, sendfile) 410,000|200,000
int main() { std::ifstream src("from.ogv", std::ios::binary); std::ofstream dst("to.ogv", std::ios::binary); dst << src.rdbuf(); }
int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags);
bool copy_file( const std::filesystem::path& from, const std::filesystem::path& to); bool copy_file( const std::filesystem::path& from, const std::filesystem::path& to, std::filesystem::copy_options options);
QFile::copy("originalFile.example","copiedFile.example");
boost::filesystem::path mySourcePath("foo.bar"); boost::filesystem::path myTargetPath("bar.foo"); boost::filsystem::copy_file(mySourcePath, myTargetPath, boost::filesystem::copy_option::overwrite_if_exists); boost::filsystem::copy_file(mySourcePath, myTargetPath, boost::filesystem::copy_option::fail_if_exists);
using namespace std; class ABC{ public: ABC(){ cout<<"Hello"<<endl; } void disp(){ cout<<"Hi\n"; } }; int main(){ ABC* b=(ABC*)malloc(sizeof(ABC)); int* q = new int[20]; ABC *a=new ABC(); b->disp(); cout<<b<<endl; free(b); delete b; b->disp(); ABC(); cout<<b; return 0; }
TEST(MyTestSuitName, MyTestCaseName) { int actual = 1; EXPECT_GT(actual, 0); EXPECT_EQ(1, actual) << "Should be equal to one"; }
BOOST_AUTO_TEST_CASE(MyTestCase) { float x = 9.5f; BOOST_CHECK(x != 0.0f); BOOST_CHECK_EQUAL((int)x, 9); BOOST_CHECK_CLOSE(x, 9.5f, 0.0001f); }
FACT("Foo and Blah should always return the same value") { Check.Equal("0", Foo()) << "Calling Foo() with no parameters should always return \"0\"."; Assert.Equal(Foo(), Blah()); } THEORY("Foo should return the same value it was given, converted to string", (int input, std::string expected), std::make_tuple(0, "0"), std::make_tuple(1, "1"), std::make_tuple(2, "2")) { Assert.Equal(expected, Foo(input)); }
namespace MyAssetTest { using namespace cpunit; CPUNIT_FUNC(MyAssetTest, test_stuff) { int some_value = 42; assert_equals("Wrong value!", 666, some_value); } CPUNIT_SET_UP(MyAssetTest) { } }
void somefunc(void) { SomeType *pst = 0; AnotherType *pat = 0; … pst = new SomeType; … if (…) { pat = new AnotherType[10]; … } if (…) { …code using pat sometimes… } delete[] pat; delete pst; }
uint8_t v; void hey(uint8_t *p) { moo(v=5, (*p)=6); zoo(v); zoo(v); }
reg = 0xFF; reg |= 0xFF00; reg |= 0xFF0000; reg |= 0xFF000000; i = reg;
reg = 0xFF; reg |= 0xFF00; reg |= 0xFF0000; reg = 0xFF; reg |= 0xFF000000; i = reg; reg |= 0xFF00; reg |= 0xFF0000; reg |= 0xFF000000; i = reg;
void f(int l, int r) { return l < -1; } auto b = f(i = -1, i = -2); if (b) { formatDisk(); }
struct A { bool first; A () : first (false) { } const A & operator = (int i) { first = !first; return * this; } }; void f (A a1, A a2) { } A i; f (i = -1, i = -1);
void g(int a, int b, int c, int n) { int i; f(i = 1, i = (ipow(a, n) + ipow(b, n) == ipow(c, n))); }
class foo { public: std::string str_; int n_; }; foo f1; foo f2(f1); foo f3; f3 = f2; if (f3 == f2) { } if (f3 != f2) { }
struct Thing { int a, b, c; std::string d; }; bool operator==(const Thing &, const Thing &)= default; bool operator!=(const Thing &, const Thing &)= default;
class Thing { int a, b; friend bool operator<(Thing, Thing) = default; friend bool operator>(Thing, Thing) = default; friend bool operator<=(Thing, Thing) = default; friend bool operator>=(Thing, Thing) = default; };
struct Thing { int a, b, c; std::string d; default: ==, !=, <, >, <=, >=; };
using namespace std::rel_ops; ... class FooClass { public: bool operator== (const FooClass& other) const { } };
class Point { int x; int y; public: auto operator<=>(const Point&) const = default; }; Point pt1, pt2; if (pt1 == pt2) { } std::set<Point> s; s.insert(pt1); if (pt1 <= pt2) { }
class LocalWeatherRecord { std::string verboseDescription; std::tm date; bool operator==(const LocalWeatherRecord& other){ return date==other.date && verboseDescription==other.verboseDescription; } }
class NonAssignable { private: NonAssignable(const NonAssignable&); NonAssignable& operator=(const NonAssignable&); };
virtual void LoadCube(UtpBipCube<float> &Cube,long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) = 0; virtual void LoadCube(UtpBipCube<short> &Cube, long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) = 0; virtual void LoadCube(UtpBipCube<unsigned short> &Cube, long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) = 0;
template<class T> virtual void LoadCube(UtpBipCube<T> &Cube,long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) = 0;
virtual void LoadCube(UtpBipCube<float> &Cube,long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) = 0; virtual void LoadCube(UtpBipCube<short> &Cube, long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) = 0; virtual void LoadCube(UtpBipCube<unsigned short> &Cube, long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) = 0;
void LoadCube(UtpBipCube<float> &Cube, long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) { LoadAnyCube(Cube,LowerLeftRow,LowerLeftColumn,UpperRightRow,UpperRightColumn,LowerBand,UpperBand); } void LoadCube(UtpBipCube<short> &Cube, long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) { LoadAnyCube(Cube,LowerLeftRow,LowerLeftColumn,UpperRightRow,UpperRightColumn,LowerBand,UpperBand); } void LoadCube(UtpBipCube<unsigned short> &Cube, long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1) { LoadAnyCube(Cube,LowerLeftRow,LowerLeftColumn,UpperRightRow,UpperRightColumn,LowerBand,UpperBand); } template<class T> void LoadAnyCube(UtpBipCube<T> &Cube, long LowerLeftRow=0,long LowerLeftColumn=0, long UpperRightRow=-1,long UpperRightColumn=-1,long LowerBand=0,long UpperBand=-1);
using namespace std; template <typename T> class A{ public: virtual void func1(const T& p) { cout<<"A:"<<p<<endl; } }; template <typename T> class B : public A<T> { public: virtual void func1(const T& p) { cout<<"A<--B:"<<p<<endl; } }; int main(int argc, char** argv) { A<string> a; B<int> b; B<string> c; A<string>* p = &a; p->func1("A<string> a"); p = dynamic_cast<A<string>*>(&c); p->func1("B<string> c"); B<int>* q = &b; q->func1(3); }
class X { public: template <typename T> virtual void func2(const T& p) { cout<<"C:"<<p<<endl; } };
vtempl.cpp:34: error: invalid use of `virtual al void X::func2(const T&)'
template<typename T> class Foo { public: template<typename P> void f(const P& p) { ((T*)this)->f<P>(p); } }; class Bar : public Foo<Bar> { public: template<typename P> void f(const P& p) { std::cout << p << std::endl; } }; int main() { Bar bar; Bar *pbar = &bar; pbar -> f(1); Foo<Bar> *pfoo = &bar; pfoo -> f(1); };
class Base { public: virtual ~Base() { } template <typename T> T Method(T t) { return VMethod(t); } private: virtual int VMethod(int t) = 0; virtual double VMethod(double t) = 0; }; template <class Impl> class Derived : public Impl { public: template <class... TArgs> Derived(TArgs&&... args) : Impl(std::forward<TArgs>(args)...) { } private: int VMethod(int t) final { return Impl::TMethod(t); } double VMethod(double t) final { return Impl::TMethod(t); } }; class AImpl : public Base { protected: AImpl(int p) : i(p) { } template <typename T> T TMethod(T t) { return t - i; } private: int i; }; using A = Derived<AImpl>; class BImpl : public Base { protected: BImpl(int p) : i(p) { } template <typename T> T TMethod(T t) { return t + i; } private: int i; }; using B = Derived<BImpl>; int main(int argc, const char* argv[]) { A a(1); B b(1); Base* base = nullptr; base = &a; std::cout << base->Method(1) << std::endl; std::cout << base->Method(2.0) << std::endl; base = &b; std::cout << base->Method(1) << std::endl; std::cout << base->Method(2.0) << std::endl; }
class first { protected: virtual std::string a1() { return "a1"; } virtual std::string mixt() { return a1(); } }; class last { protected: virtual std::string a2() { return "a2"; } }; template<class T> class mix: first , T { public: virtual std::string mixt() override; }; template<class T> std::string mix<T>::mixt() { return a1()+" before "+T::a2(); } class mix2: public mix<last> { virtual std::string a1() override { return "mix"; } }; int main() { std::cout << mix2().mixt(); return 0; }
class Geometry { public: virtual void getArea(float &area) = 0; virtual void getArea(long double &area) = 0; }; class Square : public Geometry { public: float size {1}; virtual void getArea(float &area) { getAreaT(area); } virtual void getArea(long double &area) { getAreaT(area); } private: template <typename T> void getAreaT(T &area) { area = static_cast<T>(size * size); } }; class Circle : public Geometry { public: float radius {1}; virtual void getArea(float &area) { getAreaT(area); } virtual void getArea(long double &area) { getAreaT(area); } private: template <typename T> void getAreaT(T &area) { area = static_cast<T>(radius * radius * 3.1415926535897932385L); } }; int main() { std::unique_ptr<Geometry> geometry = std::make_unique<Square>(); float areaSquare; geometry->getArea(areaSquare); geometry = std::make_unique<Circle>(); long double areaCircle; geometry->getArea(areaCircle); std::cout << std::setprecision(20) << "Square area is " << areaSquare << ", Circle area is " << areaCircle << std::endl; return 0; }
iterator { iterator(const iterator&); ~iterator(); iterator& operator=(const iterator&); iterator& operator++(); reference operator*() const; friend void swap(iterator& lhs, iterator& rhs); }; input_iterator : public virtual iterator { iterator operator++(int); value_type operator*() const; pointer operator->() const; friend bool operator==(const iterator&, const iterator&); friend bool operator!=(const iterator&, const iterator&); }; output_iterator : public virtual iterator { reference operator*() const; iterator operator++(int); }; forward_iterator : input_iterator, output_iterator { forward_iterator(); }; bidirectional_iterator : forward_iterator { iterator& operator--(); iterator operator--(int); }; random_access_iterator : bidirectional_iterator { friend bool operator<(const iterator&, const iterator&); friend bool operator>(const iterator&, const iterator&); friend bool operator<=(const iterator&, const iterator&); friend bool operator>=(const iterator&, const iterator&); iterator& operator+=(size_type); friend iterator operator+(const iterator&, size_type); friend iterator operator+(size_type, const iterator&); iterator& operator-=(size_type); friend iterator operator-(const iterator&, size_type); friend difference_type operator-(iterator, iterator); reference operator[](size_type) const; }; contiguous_iterator : random_access_iterator { };
struct std::iterator_traits<youriterator> { typedef ???? difference_type; typedef ???? value_type; typedef ???? reference; typedef ???? pointer; typedef ???? iterator_category; };
template<typename T> class ptr_iterator : public std::iterator<std::forward_iterator_tag, T> { typedef ptr_iterator<T> iterator; pointer pos_; public: ptr_iterator() : pos_(nullptr) {} ptr_iterator(T* v) : pos_(v) {} ~ptr_iterator() {} iterator operator++(int) { return pos_++; } iterator& operator++() { ++pos_; return *this; } reference operator* () const { return *pos_; } pointer operator->() const { return pos_; } iterator operator+ (difference_type v) const { return pos_ + v; } bool operator==(const iterator& rhs) const { return pos_ == rhs.pos_; } bool operator!=(const iterator& rhs) const { return pos_ != rhs.pos_; } }; template<typename T> ptr_iterator<T> begin(T *val) { return ptr_iterator<T>(val); } template<typename T, typename Tsize> ptr_iterator<T> end(T *val, Tsize size) { return ptr_iterator<T>(val) + size; }
template<typename T> class ptr_range { T* begin_; T* end_; public: ptr_range(T* ptr, size_t length) : begin_(ptr), end_(ptr + length) { assert(begin_ <= end_); } T* begin() const { return begin_; } T* end() const { return end_; } }; template<typename T> ptr_range<T> range(T* ptr, size_t length) { return ptr_range<T>(ptr, length); }
void DoIteratorTest() { const static size_t size = 10; uint8_t *data = new uint8_t[size]; { uint8_t n = auto first = begin(data); auto last = end(data, size); for (auto it = first; it != last; ++it) { *it = n++; } for (const auto& n : range(data, size)) { std::cout << " char: " << static_cast<char>(n) << std::endl; } } { ptr_iterator<uint8_t> first(data); ptr_iterator<uint8_t> last(first + size); std::vector<uint8_t> v1(first, last); std::vector<uint8_t> v2(data, data + size); } { std::list<std::vector<uint8_t>> queue_; queue_.emplace_back(begin(data), end(data, size)); queue_.emplace_back(data, data + size); } }
typedef struct tagUNINTRAM { WCHAR ParaTransMnemo[MAX_TRANSM_NO][PARA_TRANSMNEMO_LEN]; WCHAR ParaLeadThru[MAX_LEAD_NO][PARA_LEADTHRU_LEN]; WCHAR ParaReportName[MAX_REPO_NO][PARA_REPORTNAME_LEN]; WCHAR ParaSpeMnemo[MAX_SPEM_NO][PARA_SPEMNEMO_LEN]; WCHAR ParaPCIF[MAX_PCIF_SIZE]; WCHAR ParaAdjMnemo[MAX_ADJM_NO][PARA_ADJMNEMO_LEN]; WCHAR ParaPrtModi[MAX_PRTMODI_NO][PARA_PRTMODI_LEN]; WCHAR ParaMajorDEPT[MAX_MDEPT_NO][PARA_MAJORDEPT_LEN]; } UNINIRAM;
const static DWORD_PTR dwId_TransactionMnemonic = 1; const static DWORD_PTR dwId_ReportMnemonic = 2; const static DWORD_PTR dwId_SpecialMnemonic = 3; const static DWORD_PTR dwId_LeadThroughMnemonic = 4;
class MnemonicIteratorDimSizeBase { DWORD_PTR m_Type; public: MnemonicIteratorDimSizeBase(DWORD_PTR x) { } virtual ~MnemonicIteratorDimSizeBase() { } virtual wchar_t *begin() = 0; virtual wchar_t *end() = 0; virtual wchar_t *get(int i) = 0; virtual int ItemSize() = 0; virtual int ItemCount() = 0; virtual DWORD_PTR ItemType() { return m_Type; } }; template <size_t sDimSize> class MnemonicIteratorDimSize : public MnemonicIteratorDimSizeBase { wchar_t (*m_begin)[sDimSize]; wchar_t (*m_end)[sDimSize]; public: MnemonicIteratorDimSize(DWORD_PTR x) : MnemonicIteratorDimSizeBase(x), m_begin(0), m_end(0) { } virtual ~MnemonicIteratorDimSize() { } virtual wchar_t *begin() { return m_begin[0]; } virtual wchar_t *end() { return m_end[0]; } virtual wchar_t *get(int i) { return m_begin[i]; } virtual int ItemSize() { return sDimSize; } virtual int ItemCount() { return m_end - m_begin; } void SetRange(wchar_t (*begin)[sDimSize], wchar_t (*end)[sDimSize]) { m_begin = begin; m_end = end; } };
class MnemonicIterator { private: MnemonicIteratorDimSizeBase *m_p; int m_index; wchar_t *m_item; public: MnemonicIterator(MnemonicIteratorDimSizeBase *p) : m_p(p) { } ~MnemonicIterator() { } MnemonicIterator & begin() { m_item = m_p->get(m_index = 0); return *this; } MnemonicIterator & end() { m_item = m_p->get(m_index = m_p->ItemCount()); return *this; } MnemonicIterator & operator ++ () { m_item = m_p->get(++m_index); return *this; } MnemonicIterator & operator ++ (int i) { m_item = m_p->get(m_index++); return *this; } bool operator != (MnemonicIterator &p) { return **this != *p; } wchar_t * operator *() const { return m_item; } };
CFilePara::MnemonicIteratorDimSizeBase * CFilePara::MakeIterator(DWORD_PTR x) { CFilePara::MnemonicIteratorDimSizeBase *mi = nullptr; switch (x) { case dwId_TransactionMnemonic: { CFilePara::MnemonicIteratorDimSize<PARA_TRANSMNEMO_LEN> *mk = new CFilePara::MnemonicIteratorDimSize<PARA_TRANSMNEMO_LEN>(x); mk->SetRange(&m_Para.ParaTransMnemo[0], &m_Para.ParaTransMnemo[MAX_TRANSM_NO]); mi = mk; } break; case dwId_ReportMnemonic: { CFilePara::MnemonicIteratorDimSize<PARA_REPORTNAME_LEN> *mk = new CFilePara::MnemonicIteratorDimSize<PARA_REPORTNAME_LEN>(x); mk->SetRange(&m_Para.ParaReportName[0], &m_Para.ParaReportName[MAX_REPO_NO]); mi = mk; } break; case dwId_SpecialMnemonic: { CFilePara::MnemonicIteratorDimSize<PARA_SPEMNEMO_LEN> *mk = new CFilePara::MnemonicIteratorDimSize<PARA_SPEMNEMO_LEN>(x); mk->SetRange(&m_Para.ParaSpeMnemo[0], &m_Para.ParaSpeMnemo[MAX_SPEM_NO]); mi = mk; } break; case dwId_LeadThroughMnemonic: { CFilePara::MnemonicIteratorDimSize<PARA_LEADTHRU_LEN> *mk = new CFilePara::MnemonicIteratorDimSize<PARA_LEADTHRU_LEN>(x); mk->SetRange(&m_Para.ParaLeadThru[0], &m_Para.ParaLeadThru[MAX_LEAD_NO]); mi = mk; } break; } return mi; }
std::unique_ptr<CFilePara::MnemonicIteratorDimSizeBase> pObj(pFile->MakeIterator(m_IteratorType)); CFilePara::MnemonicIterator pIter(pObj.get()); int i = 0; for (auto x : pIter) { WCHAR szText[32] = { 0 }; wcsncpy_s(szText, 32, x, pObj->ItemSize()); m_mnemonicList.InsertItem(i, szText); i++; }
for (int i = 0; i < n1; ++i) { [&] { for (int j = 0; j < n2; ++j) { for (int k = 0; k < n3; ++k) { return; } } }(); }
for(unsigned int z = 0; z < z_max; z++) { bool gotoMainLoop = false; for(unsigned int y = 0; y < y_max && !gotoMainLoop; y++) { for(unsigned int x = 0; x < x_max && !gotoMainLoop; x++) { if(condition) gotoMainLoop = true; } } }
for(unsigned int i=0; i < 50; i++) { for(unsigned int j=0; j < 50; j++) { for(unsigned int k=0; k < 50; k++) { if (condition) { j=50; k=50; } } } }
void foo() { for(unsigned int i=0; i < 50; i++) { for(unsigned int j=0; j < 50; j++) { for(unsigned int k=0; k < 50; k++) { return; } } } }
for (i = 0; i < 1000; i++) { for (j = 0; j < 1000; j++) { for (k = 0; k < 1000; k++) { for (l = 0; l < 1000; l++){ .... if (condition) goto break_me_here; .... } } } } break_me_here:
for ( ; ; ) { for ( ; ; ) { if (condition) { goto theEnd; } } } theEnd:
for ( ; ; ) { for ( ; ; ) { if (condition) { i++; goto multiCont; } } multiCont: }
for(unsigned int i=0; i < 50; i++) { for(unsigned int j=0; j < conditionj; j++) { for(unsigned int k=0; k< conditionk ; k++) { j= conditionj; break; } } }
while (i<n) { bool shouldBreakOuter = false; for (int j=i + 1; j<n; ++j) { if (someCondition) { shouldBreakOuter = true; } } if (shouldBreakOuter == true) break; }
try { for(int i=0; i<10; ++i) { for(int j=0; j<10; ++j) { if(i*j == 42) throw 0; } } } catch(int e) {}
foreground background black 30 40 red 31 41 green 32 42 yellow 33 43 blue 34 44 magenta 35 45 cyan 36 46 white 37 47
reset 0 (everything back to normal) bold/bright 1 (often a brighter shade of the same colour) underline 4 inverse 7 (swap foreground and background colours) bold/bright off 21 underline off 24 inverse off 27
using namespace std; int main() { Color::Modifier red(Color::FG_RED); Color::Modifier def(Color::FG_DEFAULT); cout << "This ->" << red << "word" << def << "<- is red." << endl; }
namespace Color { enum Code { FG_RED = 31, FG_GREEN = 32, FG_BLUE = 34, FG_DEFAULT = 39, BG_RED = 41, BG_GREEN = 42, BG_BLUE = 44, BG_DEFAULT = 49 }; class Modifier { Code code; public: Modifier(Code pCode) : code(pCode) {} friend std::ostream& operator<<(std::ostream& os, const Modifier& mod) { return os << "\033[" << mod.code << "m"; } }; }
[ ${Number_Of_colors_Supported} -ge 8 ] && { echo } || { echo }
fg_black="$(tput AF 0)" fg_red="$(tput AF 1)" fg_green="$(tput AF 2)" fg_yellow="$(tput AF 3)" fg_blue="$(tput AF 4)" fg_magenta="$(tput AF 5)" fg_cyan="$(tput AF 6)" fg_white="$(tput AF 7)" reset="$(tput me)"
fg_black="$(tput setaf 0)" fg_red="$(tput setaf 1)" fg_green="$(tput setaf 2)" fg_yellow="$(tput setaf 3)" fg_blue="$(tput setaf 4)" fg_magenta="$(tput setaf 5)" fg_cyan="$(tput setaf 6)" fg_white="$(tput setaf 7)" reset="$(tput sgr0)"
using namespace std; int main() { cout << FBLU("I cout << BOLD(FBLU("I return 0; }
cout << zkr::cc::fore::red << "This is red text. " << zkr::cc::console << "And changing to console default colors, fg, bg." << endl;
black blue red magenta green cyan yellow white lightblack lightblue lightred lightmagenta lightgreen lightcyan lightyellow lightwhite
char *cc::color(int attr, int fg, int bg) { static char command[13]; sprintf(command, "%c[%d;%d;%dm", 0x1B, attr, fg + 30, bg + 40); return command; }
namespace zkr { class cc { public: class fore { public: static const char *black; static const char *blue; static const char *red; static const char *magenta; static const char *green; static const char *cyan; static const char *yellow; static const char *white; static const char *console; static const char *lightblack; static const char *lightblue; static const char *lightred; static const char *lightmagenta; static const char *lightgreen; static const char *lightcyan; static const char *lightyellow; static const char *lightwhite; }; class back { public: static const char *black; static const char *blue; static const char *red; static const char *magenta; static const char *green; static const char *cyan; static const char *yellow; static const char *white; static const char *console; static const char *lightblack; static const char *lightblue; static const char *lightred; static const char *lightmagenta; static const char *lightgreen; static const char *lightcyan; static const char *lightyellow; static const char *lightwhite; }; static char *color(int attr, int fg, int bg); static const char *console; static const char *underline; static const char *bold; }; }
using namespace std; namespace zkr { enum Color { Black, Red, Green, Yellow, Blue, Magenta, Cyan, White, Default = 9 }; enum Attributes { Reset, Bright, Dim, Underline, Blink, Reverse, Hidden }; char *cc::color(int attr, int fg, int bg) { static char command[13]; sprintf(command, "%c[%d;%d;%dm", 0x1B, attr, fg + 30, bg + 40); return command; } const char *cc::console = CC_CONSOLE_COLOR_DEFAULT; const char *cc::underline = CC_ATTR(4); const char *cc::bold = CC_ATTR(1); const char *cc::fore::black = CC_FORECOLOR(30); const char *cc::fore::blue = CC_FORECOLOR(34); const char *cc::fore::red = CC_FORECOLOR(31); const char *cc::fore::magenta = CC_FORECOLOR(35); const char *cc::fore::green = CC_FORECOLOR(92); const char *cc::fore::cyan = CC_FORECOLOR(36); const char *cc::fore::yellow = CC_FORECOLOR(33); const char *cc::fore::white = CC_FORECOLOR(37); const char *cc::fore::console = CC_FORECOLOR(39); const char *cc::fore::lightblack = CC_FORECOLOR(90); const char *cc::fore::lightblue = CC_FORECOLOR(94); const char *cc::fore::lightred = CC_FORECOLOR(91); const char *cc::fore::lightmagenta = CC_FORECOLOR(95); const char *cc::fore::lightgreen = CC_FORECOLOR(92); const char *cc::fore::lightcyan = CC_FORECOLOR(96); const char *cc::fore::lightyellow = CC_FORECOLOR(93); const char *cc::fore::lightwhite = CC_FORECOLOR(97); const char *cc::back::black = CC_BACKCOLOR(40); const char *cc::back::blue = CC_BACKCOLOR(44); const char *cc::back::red = CC_BACKCOLOR(41); const char *cc::back::magenta = CC_BACKCOLOR(45); const char *cc::back::green = CC_BACKCOLOR(42); const char *cc::back::cyan = CC_BACKCOLOR(46); const char *cc::back::yellow = CC_BACKCOLOR(43); const char *cc::back::white = CC_BACKCOLOR(47); const char *cc::back::console = CC_BACKCOLOR(49); const char *cc::back::lightblack = CC_BACKCOLOR(100); const char *cc::back::lightblue = CC_BACKCOLOR(104); const char *cc::back::lightred = CC_BACKCOLOR(101); const char *cc::back::lightmagenta = CC_BACKCOLOR(105); const char *cc::back::lightgreen = CC_BACKCOLOR(102); const char *cc::back::lightcyan = CC_BACKCOLOR(106); const char *cc::back::lightyellow = CC_BACKCOLOR(103); const char *cc::back::lightwhite = CC_BACKCOLOR(107); }
const std::string red("\033[0;31m"); const std::string green("\033[1;32m"); const std::string yellow("\033[1;33m"); const std::string cyan("\033[0;36m"); const std::string magenta("\033[0;35m"); const std::string reset("\033[0m"); std::cout << "Measured runtime: " << yellow << timer.count() << reset << std::endl;
echo \[\033[32m\]Hello, \[\033[36m\]colourful \[\033[33mworld!\033[0m\]
"\033[{FORMAT_ATTRIBUTE};{FORGROUND_COLOR};{BACKGROUND_COLOR}m{TEXT}\033[{RESET_FORMATE_ATTRIBUTE}m"
{ "Default", "0" }, { "Bold", "1" }, { "Dim", "2" }, { "Underlined", "3" }, { "Blink", "5" }, { "Reverse", "7" }, { "Hidden", "8" }
{ "Default", "39" }, { "Black", "30" }, { "Red", "31" }, { "Green", "32" }, { "Yellow", "33" }, { "Blue", "34" }, { "Magenta", "35" }, { "Cyan", "36" }, { "Light Gray", "37" }, { "Dark Gray", "90" }, { "Light Red", "91" }, { "Light Green", "92" }, { "Light Yellow", "93" }, { "Light Blue", "94" }, { "Light Magenta", "95" }, { "Light Cyan", "96" }, { "White", "97" }
{ "Default", "49" }, { "Black", "40" }, { "Red", "41" }, { "Green", "42" }, { "Yellow", "43" }, { "Blue", "44" }, { "Megenta", "45" }, { "Cyan", "46" }, { "Light Gray", "47" }, { "Dark Gray", "100" }, { "Light Red", "101" }, { "Light Green", "102" }, { "Light Yellow", "103" }, { "Light Blue", "104" }, { "Light Magenta", "105" }, { "Light Cyan", "106" }, { "White", "107" }
{ "All", "0" }, { "Bold", "21" }, { "Dim", "22" }, { "Underlined", "24" }, { "Blink", "25" }, { "Reverse", "27" }, { "Hidden", "28" }
auto const& colorized_text = color::rize( "I am a banana!", "Yellow", "Green" ); std::cout << colorized_text << std::endl;
ATTRIBUTES_OFF, BOLD, UNDERSCORE, BLINK, REVERSE_VIDEO, CONCEALED
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE
COLOR_$Foreground_Color$_$Background_Color$ COLOR_$Text_Attribute$_$Foreground_Color$_$Background_Color$ COLOR_NORMAL
COLOR_BLUE_BLACK COLOR_UNDERSCORE_YELLOW_RED COLOR_NORMAL
cout << COLOR_BLUE_BLACK << "TEXT" << COLOR_NORMAL << endl; cout << COLOR_BOLD_YELLOW_CYAN << "TEXT" << COLOR_NORMAL << endl;
enum c_color{BLACK=30,RED=31,GREEN=32,YELLOW=33,BLUE=34,MAGENTA=35,CYAN=36,WHITE=37}; enum c_decoration{NORMAL=0,BOLD=1,FAINT=2,ITALIC=3,UNDERLINE=4,RIVERCED=26,FRAMED=51}; void pr(const string str,c_color color,c_decoration decoration=c_decoration::NORMAL){ cout<<"\033["<<decoration<<";"<<color<<"m"<<str<<"\033[0m"; } void prl(const string str,c_color color,c_decoration decoration=c_decoration::NORMAL){ cout<<"\033["<<decoration<<";"<<color<<"m"<<str<<"\033[0m"<<endl; }
int main() { std::cout << SetBackBLU << SetForeRED << endl; std::cout << "I am red text on a blue background! :) " << endl; return 0; }
$ printf "\e[033;31m red text\n" $ echo "$(tput setaf 1) red text"
std::string str = "string"; const char *cstr = str.c_str();
std::string str = "string"; char *cstr = new char[str.length() + 1]; strcpy(cstr, str.c_str()); delete [] cstr;
std::vector<char> cstr(str.c_str(), str.c_str() + str.size() + 1);
string str = "some string" ; char *cstr = &str[0u];
std::string str = "string"; char* chr = strdup(str.c_str());
std::string str = "string"; std::vector<char> chars(str.c_str(), str.c_str() + str.size() + 1u);
char* ca = new char[str.size()+1]; std::copy(str.begin(), str.end(), ca); ca[str.size()] =
size_t const MAX = 80; char ca[MAX] = {}; std::copy(str.begin(), (str.size() >= MAX ? str.begin() + MAX : str.end()), ca);
vector<char> v(str.begin(), str.end()); char* ca = &v[0];
std::string str = "string"; char* chr = const_cast<char*>(str.c_str());
std::string str = "string"; const char* chr = str.c_str();
std::string str = "string"; const size_t MAX = 80; char chrs[MAX]; str.copy(chrs, MAX);
std::string str = "string"; const size_t MAX = 80; char chrs[MAX]; memset(chrs, str.copy(chrs, MAX-1);
char* string_as_array(string* str) { return str->empty() ? NULL : &*str->begin(); } std::string mystr("you are here"); char* pstr = string_as_array(&mystr); cout << pstr << endl;
char* result = strcpy((char*)malloc(str.length()+1), str.c_str());
string str; vector <char> writable (str.begin (), str.end) ; writable .push_back ( char* cstring = &writable[0]
std::string str = "string"; std::string::iterator p=str.begin(); char* chr = &(*p);
std::string s; std::cout<<"Enter the String"; std::getline(std::cin, s); char *a=new char[s.size()+1]; a[s.size()]=0; memcpy(a,s.c_str(),s.size()); std::cout<<a;
std::string str = "string"; auto cstr = std::make_unique<char[]>(str.length() + 1); strcpy(cstr.get(), str.c_str());
class StringConverter { public: static char * strToChar(std::string str); };
char * StringConverter::strToChar(std::string str) { return (char*)str.c_str(); }
bool str2int (int &i, char const *s) { std::stringstream ss(s); ss >> i; if (ss.fail()) { return false; } return true; }
bool str2int (int &i, char const *s) { char c; std::stringstream ss(s); ss >> i; if (ss.fail() || ss.get(c)) { return false; } return true; }
enum STR2INT_ERROR { SUCCESS, OVERFLOW, UNDERFLOW, INCONVERTIBLE }; STR2INT_ERROR str2int (int &i, char const *s, int base = 0) { char *end; long l; errno = 0; l = strtol(s, &end, base); if ((errno == ERANGE && l == LONG_MAX) || l > INT_MAX) { return OVERFLOW; } if ((errno == ERANGE && l == LONG_MIN) || l < INT_MIN) { return UNDERFLOW; } if (*s == return INCONVERTIBLE; } i = l; return SUCCESS; }
const char* str = "123"; int i; if(sscanf(str, "%d", &i) == EOF ) { }
int str2int (const string &str) { stringstream ss(str); int num; if((ss >> num).fail()) { } return num; }
try { std::string str = "123"; int number = boost::lexical_cast< int >( str ); } catch( const boost::bad_lexical_cast & ) { }
stringstream ss(str); int x; ss >> x; if(ss) { } else { }
int str2int (const string &str) { stringstream ss(str); int num; ss >> num; return num; }
int naive_char_2_int(const char *p) { int x = 0; bool neg = false; if (*p == neg = true; ++p; } while (*p >= x = (x*10) + (*p - ++p; } if (neg) { x = -x; } return x; }
static const std::size_t digit_table_symbol_count = 256; static const unsigned char digit_table[digit_table_symbol_count] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }; template<typename InputIterator, typename T> inline bool string_to_signed_type_converter_impl_itr(InputIterator begin, InputIterator end, T& v) { if (0 == std::distance(begin,end)) return false; v = 0; InputIterator it = begin; bool negative = false; if ( ++it; else if ( { ++it; negative = true; } if (end == it) return false; while(end != it) { const T digit = static_cast<T>(digit_table[static_cast<unsigned int>(*it++)]); if (0xFF == digit) return false; v = (10 * v) + digit; } if (negative) v *= -1; return true; }
int main() { char const * str = "42"; int value = 0; std::from_chars_result result = std::from_chars(std::begin(str), std::end(str), value); if(result.error == std::errc::invalid_argument) { std::cout << "Error, invalid format"; } else if(result.error == std::errc::result_out_of_range) { std::cout << "Error, value too big for int range"; } else { std::cout << "Success: " << result; } }
int to_int(const std::string &s, int base = 0) { char *end; errno = 0; long result = std::strtol(s.c_str(), &end, base); if (errno == ERANGE || result > INT_MAX || result < INT_MIN) throw std::out_of_range("toint: string is out of range"); if (s.length() == 0 || *end != throw std::invalid_argument("toint: invalid string"); return result; }
std::string s1 = "4533"; std::string s2 = "3.010101"; std::string s3 = "31337 with some string"; int myint1 = std::stoi(s1); int myint2 = std::stoi(s2); int myint3 = std::stoi(s3); std::cout << s1 <<"=" << myint1 << std::cout << s2 <<"=" << myint2 << std::cout << s3 <<"=" << myint3 <<
using namespace std; int StringToInteger(string NumberAsString) { int NumberAsInteger; stringstream ss; ss << NumberAsString; ss >> NumberAsInteger; return NumberAsInteger; } int main() { string NumberAsString; cin >> NumberAsString; cout << StringToInteger(NumberAsString) << endl; return 0; }
std::string str4 = "453"; int i = 0, in=0; for ( i = 0; i < str4.length(); i++) { in = str4[i]; cout <<in-48 ; }
if ((errno != 0) || (s == end)) { return INCONVERTIBLE; }
enum STR2INT_ERROR { SUCCESS, OVERFLOW, UNDERFLOW, INCONVERTIBLE }; STR2INT_ERROR str2long (long &l, char const *s, int base = 0) { char *end = (char *)s; errno = 0; l = strtol(s, &end, base); if ((errno == ERANGE) && (l == LONG_MAX)) { return OVERFLOW; } if ((errno == ERANGE) && (l == LONG_MIN)) { return UNDERFLOW; } if ((errno != 0) || (s == end)) { return INCONVERTIBLE; } while (isspace((unsigned char)*end)) { end++; } if (*s == return INCONVERTIBLE; } return SUCCESS; }
int main() { string test = "46", test2 = "56"; int a = toInt(test); int b = toInt(test2); cout<<a+b<<endl; }
static const int DefaultBase = 10; template<typename T> static inline T CstrtoxllWrapper(const char *str, int base = DefaultBase) { while (isspace(*str)) str++; if (*str == if (!std::numeric_limits<T>::is_signed && *str == { throw std::invalid_argument("str; negative"); } errno = 0; char *ePtr; T tmp = std::numeric_limits<T>::is_signed ? strtoll(str, &ePtr, base) : strtoull(str, &ePtr, base); if (errno != 0) { if (errno == ERANGE) { throw std::range_error("str; out of range"); } else if (errno == EINVAL) { throw std::invalid_argument("str; EINVAL"); } else { throw std::invalid_argument("str; unknown errno"); } } if (ePtr != NULL) { while (isspace(*ePtr)) ePtr++; if (*ePtr != } return tmp; } template<typename T> T StringToSigned(const char *str, int base = DefaultBase) { static const long long max = std::numeric_limits<T>::max(); static const long long min = std::numeric_limits<T>::min(); long long tmp = CstrtoxllWrapper<typeof(tmp)>(str, base); if (sizeof(T) == sizeof(tmp)) { return tmp; } if (tmp < min || tmp > max) { std::ostringstream err; err << "str; value " << tmp << " out of " << sizeof(T) * 8 << "-bit signed range ("; if (sizeof(T) != 1) err << min << ".." << max; else err << (int) min << ".." << (int) max; err << ")"; throw std::range_error(err.str()); } return tmp; } template<typename T> T StringToUnsigned(const char *str, int base = DefaultBase) { static const unsigned long long max = std::numeric_limits<T>::max(); unsigned long long tmp = CstrtoxllWrapper<typeof(tmp)>(str, base); if (sizeof(T) == sizeof(tmp)) { return tmp; } if (tmp > max) { std::ostringstream err; err << "str; value " << tmp << " out of " << sizeof(T) * 8 << "-bit unsigned range (0.."; if (sizeof(T) != 1) err << max; else err << (int) max; err << ")"; throw std::range_error(err.str()); } return tmp; } template<typename T> inline T StringToDecimal(const char *str, int base = DefaultBase) { return std::numeric_limits<T>::is_signed ? StringToSigned<T>(str, base) : StringToUnsigned<T>(str, base); } template<typename T> inline T StringToDecimal(T &out_convertedVal, const char *str, int base = DefaultBase) { return out_convertedVal = StringToDecimal<T>(str, base); } static bool _g_anyFailed = false; template<typename T> void TestIt(const char *tName, const char *s, int base, bool successExpected = false, T expectedValue = 0) { T x; std::cout << "converting<" << tName << ">b:" << base << " [" << s << "]"; try { StringToDecimal<T>(x, s, base); if (!successExpected) { FAIL(" -- TEST FAILED; SUCCESS NOT EXPECTED!" << std::endl); } else { std::cout << " -> "; if (sizeof(T) != 1) std::cout << x; else std::cout << (int) x; if (x != expectedValue) { FAIL("; FAILED (expected value:" << expectedValue << ")!"); } std::cout << std::endl; } } catch (std::exception &e) { if (successExpected) { FAIL( " -- TEST FAILED; EXPECTED SUCCESS!" << " (got:" << e.what() << ")" << std::endl); } else { std::cout << "; expected exception encounterd: [" << e.what() << "]" << std::endl; } } } TestIt<t>( int main() { std::cout << "============ variable base tests ============" << std::endl; TEST(int, "-0xF", 0, true, -0xF); TEST(int, "+0xF", 0, true, 0xF); TEST(int, "0xF", 0, true, 0xF); TEST(int, "-010", 0, true, -010); TEST(int, "+010", 0, true, 010); TEST(int, "010", 0, true, 010); TEST(int, "-10", 0, true, -10); TEST(int, "+10", 0, true, 10); TEST(int, "10", 0, true, 10); std::cout << "============ base-10 tests ============" << std::endl; TEST(int, "-010", 10, true, -10); TEST(int, "+010", 10, true, 10); TEST(int, "010", 10, true, 10); TEST(int, "-10", 10, true, -10); TEST(int, "+10", 10, true, 10); TEST(int, "10", 10, true, 10); TEST(int, "00010", 10, true, 10); std::cout << "============ base-8 tests ============" << std::endl; TEST(int, "777", 8, true, 0777); TEST(int, "-0111 ", 8, true, -0111); TEST(int, "+0010 ", 8, true, 010); std::cout << "============ base-16 tests ============" << std::endl; TEST(int, "DEAD", 16, true, 0xDEAD); TEST(int, "-BEEF", 16, true, -0xBEEF); TEST(int, "+C30", 16, true, 0xC30); std::cout << "============ base-2 tests ============" << std::endl; TEST(int, "-10011001", 2, true, -153); TEST(int, "10011001", 2, true, 153); std::cout << "============ irregular base tests ============" << std::endl; TEST(int, "Z", 36, true, 35); TEST(int, "ZZTOP", 36, true, 60457993); TEST(int, "G", 17, true, 16); TEST(int, "H", 17); std::cout << "============ space deliminated tests ============" << std::endl; TEST(int, "1337 ", 10, true, 1337); TEST(int, " FEAD", 16, true, 0xFEAD); TEST(int, " 0711 ", 0, true, 0711); std::cout << "============ bad data tests ============" << std::endl; TEST(int, "FEAD", 10); TEST(int, "1234 asdfklj", 10); TEST(int, "-0xF", 10); TEST(int, "+0xF", 10); TEST(int, "0xF", 10); TEST(int, "-F", 10); TEST(int, "+F", 10); TEST(int, "12.4", 10); TEST(int, "ABG", 16); TEST(int, "10011002", 2); std::cout << "============ int8_t range tests ============" << std::endl; TEST(int8_t, "7F", 16, true, std::numeric_limits<int8_t>::max()); TEST(int8_t, "80", 16); TEST(int8_t, "-80", 16, true, std::numeric_limits<int8_t>::min()); TEST(int8_t, "-81", 16); TEST(int8_t, "FF", 16); TEST(int8_t, "100", 16); std::cout << "============ uint8_t range tests ============" << std::endl; TEST(uint8_t, "7F", 16, true, std::numeric_limits<int8_t>::max()); TEST(uint8_t, "80", 16, true, std::numeric_limits<int8_t>::max()+1); TEST(uint8_t, "-80", 16); TEST(uint8_t, "-81", 16); TEST(uint8_t, "FF", 16, true, std::numeric_limits<uint8_t>::max()); TEST(uint8_t, "100", 16); std::cout << "============ int16_t range tests ============" << std::endl; TEST(int16_t, "7FFF", 16, true, std::numeric_limits<int16_t>::max()); TEST(int16_t, "8000", 16); TEST(int16_t, "-8000", 16, true, std::numeric_limits<int16_t>::min()); TEST(int16_t, "-8001", 16); TEST(int16_t, "FFFF", 16); TEST(int16_t, "10000", 16); std::cout << "============ uint16_t range tests ============" << std::endl; TEST(uint16_t, "7FFF", 16, true, std::numeric_limits<int16_t>::max()); TEST(uint16_t, "8000", 16, true, std::numeric_limits<int16_t>::max()+1); TEST(uint16_t, "-8000", 16); TEST(uint16_t, "-8001", 16); TEST(uint16_t, "FFFF", 16, true, std::numeric_limits<uint16_t>::max()); TEST(uint16_t, "10000", 16); std::cout << "============ int32_t range tests ============" << std::endl; TEST(int32_t, "7FFFFFFF", 16, true, std::numeric_limits<int32_t>::max()); TEST(int32_t, "80000000", 16); TEST(int32_t, "-80000000", 16, true, std::numeric_limits<int32_t>::min()); TEST(int32_t, "-80000001", 16); TEST(int32_t, "FFFFFFFF", 16); TEST(int32_t, "100000000", 16); std::cout << "============ uint32_t range tests ============" << std::endl; TEST(uint32_t, "7FFFFFFF", 16, true, std::numeric_limits<int32_t>::max()); TEST(uint32_t, "80000000", 16, true, std::numeric_limits<int32_t>::max()+1); TEST(uint32_t, "-80000000", 16); TEST(uint32_t, "-80000001", 16); TEST(uint32_t, "FFFFFFFF", 16, true, std::numeric_limits<uint32_t>::max()); TEST(uint32_t, "100000000", 16); std::cout << "============ int64_t range tests ============" << std::endl; TEST(int64_t, "7FFFFFFFFFFFFFFF", 16, true, std::numeric_limits<int64_t>::max()); TEST(int64_t, "8000000000000000", 16); TEST(int64_t, "-8000000000000000", 16, true, std::numeric_limits<int64_t>::min()); TEST(int64_t, "-8000000000000001", 16); TEST(int64_t, "FFFFFFFFFFFFFFFF", 16); TEST(int64_t, "10000000000000000", 16); std::cout << "============ uint64_t range tests ============" << std::endl; TEST(uint64_t, "7FFFFFFFFFFFFFFF", 16, true, std::numeric_limits<int64_t>::max()); TEST(uint64_t, "8000000000000000", 16, true, std::numeric_limits<int64_t>::max()+1); TEST(uint64_t, "-8000000000000000", 16); TEST(uint64_t, "-8000000000000001", 16); TEST(uint64_t, "FFFFFFFFFFFFFFFF", 16, true, std::numeric_limits<uint64_t>::max()); TEST(uint64_t, "10000000000000000", 16); std::cout << std::endl << std::endl << (_g_anyFailed ? "!! SOME TESTS FAILED !!" : "ALL TESTS PASSED") << std::endl; return _g_anyFailed; }
void myFunction(double** myArray){ myArray[x][y] = 5; etc... }
int array[10][10]; void passFunc(int a[][10]) { } passFunc(array);
int *array[10]; for(int i = 0; i < 10; i++) array[i] = new int[10]; void passFunc(int *a[10]) { } passFunc(array);
int **array; array = new int *[10]; for(int i = 0; i <10; i++) array[i] = new int[10]; void passFunc(int **a) { } passFunc(array);
template <size_t rows, size_t cols> void process_2d_array_template(int (&array)[rows][cols]) { std::cout << __func__ << std::endl; for (size_t i = 0; i < rows; ++i) { std::cout << i << ": "; for (size_t j = 0; j < cols; ++j) std::cout << array[i][j] << std::cout << std::endl; } }
void process_2d_array_pointer(int (*array)[5][10]) { std::cout << __func__ << std::endl; for (size_t i = 0; i < 5; ++i) { std::cout << i << ": "; for (size_t j = 0; j < 10; ++j) std::cout << (*array)[i][j] << std::cout << std::endl; } }
void process_2d_array(int (*array)[10], size_t rows) { std::cout << __func__ << std::endl; for (size_t i = 0; i < rows; ++i) { std::cout << i << ": "; for (size_t j = 0; j < 10; ++j) std::cout << array[i][j] << std::cout << std::endl; } }
void process_pointer_2_pointer(int **array, size_t rows, size_t cols) { std::cout << __func__ << std::endl; for (size_t i = 0; i < rows; ++i) { std::cout << i << ": "; for (size_t j = 0; j < cols; ++j) std::cout << array[i][j] << std::cout << std::endl; } }
int main() { int a[5][10] = { { } }; process_2d_array_template(a); process_2d_array_pointer(&a); process_2d_array(a, 5); int *b[5]; for (size_t i = 0; i < 5; ++i) { b[i] = a[i]; } process_pointer_2_pointer(b, 5, 10); }
template <size_t size_x, size_t size_y> void func(double (&arr)[size_x][size_y]) { printf("%p\n", &arr); } int main() { double a1[10][10]; double a2[5][5]; printf("%p\n%p\n\n", &a1, &a2); func(a1); func(a2); return 0; }
template<int R, int C> void myFunction(double (&myArray)[R][C]) { myArray[x][y] = 5; etc... }
void myFunction(double * arr, int R, int C) { arr[x * C + y] = 5; etc... }
template<int C, int R> void myFunction(double (&myArray)[R][C]) { myFunction(*myArray, R, C); }
template <typename TwoD> void myFunction(TwoD& myArray){ myArray[x][y] = 5; etc... } double anArray[10][10]; myFunction(anArray);
using namespace std; void myFunc(double *a,int rows,int cols){ for(int i=0;i<rows;i++){ for(int j=0;j<cols;j++){ *(a+ i*rows + j)+=10.0; } } } void printArray(double *a,int rows,int cols){ cout<<"Printing your array...\n"; for(int i=0;i<rows;i++){ for(int j=0;j<cols;j++){ cout<<*(a+ i*rows + j)<<" "; } cout<<"\n"; } } int main(){ double a[2][2]={{1.5 , 2.5},{3.5 , 4.5}}; myFunc(a[0],2,2); printArray(a[0],2,2); return 0; }
`const int N = 3; `void print(int arr[][N], int m) { int i, j; for (i = 0; i < m; i++) for (j = 0; j < N; j++) printf("%d ", arr[i][j]); }` int main() { int arr[][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; print(arr, 3); return 0; }`
`void print(int *arr, int m, int n) { int i, j; for (i = 0; i < m; i++) for (j = 0; j < n; j++) printf("%d ", *((arr+i*n) + j)); } `int main() { int arr[][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; int m = 3, n = 3; print((int *)arr, m, n); return 0; }`
using namespace std; typedef vector< vector<int> > Matrix; void print(Matrix& m) { int M=m.size(); int N=m[0].size(); for(int i=0; i<M; i++) { for(int j=0; j<N; j++) cout << m[i][j] << " "; cout << endl; } cout << endl; } int main() { Matrix m = { {1,2,3,4}, {5,6,7,8}, {9,1,2,3} }; print(m); Matrix n( 3,vector<int>(4,0)); print(n); return 0; }
template<typename T, size_t col> T process(T a[][col], size_t row) { ... }
int some_mat[3][3], another_mat[4,5]; process(some_mat, 3); process(another_mat, 4);
using namespace std; void func(int *arr, int m, int n) { for (int i=0; i<m; i++) { for (int j=0; j<n; j++) { cout<<*((arr+i*n) + j)<<" "; } cout<<endl; } } int main() { int m = 3, n = 3; int arr[m][n] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; func((int *)arr, m, n); return 0; }
int x; do { x = rand(); } while (x >= (RAND_MAX - RAND_MAX % n)); x %= n;
int x; do { x = rand(); } while (x >= RAND_MAX - (RAND_MAX % n)) x %= n;
/* * Calculate a uniformly distributed random number less than upper_bound * avoiding "modulo bias". * * Uniformity is achieved by generating new random numbers until the one * returned is outside the range [0, 2**32 % upper_bound). This * guarantees the selected random number will be inside * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound) * after reduction modulo upper_bound. */ u_int32_t arc4random_uniform(u_int32_t upper_bound) { u_int32_t r, min; if (upper_bound < 2) return 0; /* 2**32 % x == (2**32 - x) % x */ min = -upper_bound % upper_bound; /* * This could theoretically loop forever but each retry has * p > 0.5 (worst case, usually far better) of selecting a * number inside the range we need, so it should rarely need * to re-roll. */ for (;;) { r = arc4random(); if (r >= min) break; } return r % upper_bound; }
public int nextInt(int n) { if (n <= 0) throw new IllegalArgumentException("n must be positive"); if ((n & -n) == n) return (int)((n * (long)next(31)) >> 31); int bits, val; do { bits = next(31); val = bits % n; } while (bits - val + (n-1) < 0); return val; }
000 = 0, 001 = 1, 010 = 2, 011 = 3 100 = 4, 101 = 5, 110 = 6, 111 = 7
32 % 6 = 2 discarded results; and 2 discarded results / 32 possibilities = 6.25%
volatile uint32_t dummy; uint64_t discardCount; uint32_t uniformRandomUint32(uint32_t upperBound) { assert(RAND_status() == 1); uint64_t discard = (std::numeric_limits<uint64_t>::max() - upperBound) % upperBound; uint64_t randomPool = RAND_bytes((uint8_t*)(&randomPool), sizeof(randomPool)); while(randomPool > (std::numeric_limits<uint64_t>::max() - discard)) { RAND_bytes((uint8_t*)(&randomPool), sizeof(randomPool)); ++discardCount; } return randomPool % upperBound; } int main() { discardCount = 0; const uint32_t MODULUS = (1ul << 31)-1; const uint32_t ROLLS = 10000000; for(uint32_t i = 0; i < ROLLS; ++i) { dummy = uniformRandomUint32(MODULUS); } std::cout << "Discard count = " << discardCount << std::endl; }
int alea(int n){ assert (0 < n && n <= RAND_MAX); int partSize = n == RAND_MAX ? 1 : 1 + (RAND_MAX-n)/(n+1); int maxUsefull = partSize * n + (partSize-1); int draw; do { draw = rand(); } while (draw > maxUsefull); return draw/partSize; }
int x; do { x = rand(); } while (x >= (RAND_MAX - RAND_MAX % n)); x %= n;
EG: Ran Max Value (RM) = 255 Valid Outcome (N) = 4 When X => 252, Discarded values for X are: 252, 253, 254, 255 So, if Random Value Selected (X) = {252, 253, 254, 255} Number of discarded Values (I) = RM % N + 1 == N IE: I = RM % N + 1 I = 255 % 4 + 1 I = 3 + 1 I = 4 X => ( RM - RM % N ) 255 => (255 - 255 % 4) 255 => (255 - 3) 255 => (252) Discard Returns $True
RM=255 , N=2 Then: D = 253, Lost percentage = 0.78125% RM=255 , N=4 Then: D = 251, Lost percentage = 1.5625% RM=255 , N=8 Then: D = 247, Lost percentage = 3.125% RM=255 , N=16 Then: D = 239, Lost percentage = 6.25% RM=255 , N=32 Then: D = 223, Lost percentage = 12.5% RM=255 , N=64 Then: D = 191, Lost percentage = 25% RM=255 , N= 128 Then D = 127, Lost percentage = 50%
int x; do { x = rand(); } while (x > (RAND_MAX - ( ( ( RAND_MAX % n ) + 1 ) % n) ); x %= n;
RAND_MAX = 3, n = 2, Values in RAND_MAX = 0,1,2,3, Valid Sets = 0,1 and 2,3. When X >= (RAND_MAX - ( RAND_MAX % n ) ) When X >= 2 the value will be discarded, even though the set is valid.
RAND_MAX = 3, n = 2, Values in RAND_MAX = 0,1,2,3, Valid Sets = 0,1 and 2,3. When X > (RAND_MAX - ( ( RAND_MAX % n ) + 1 ) % n ) When X > 3 the value would be discarded, but this is not a vlue in the set RAND_MAX so there will be no discard.
int x; if n != 0 { do { x = rand(); } while (x > (RAND_MAX - ( ( ( RAND_MAX % n ) + 1 ) % n) ); x %= n; } else { x = rand(); }
int x; do { x = rand(); } while (x > (RAND_MAX - ( ( ( RAND_MAX % n ) + 1 ) % n) ); x %= n;
int x; if n != 0 { do { x = rand(); } while (x > (RAND_MAX - ( ( ( RAND_MAX % n ) + 1 ) % n) ); x %= n; } else { x = rand(); }
next: n | bitSize r from to | n < 0 ifTrue: [^0 - (self next: 0 - n)]. n = 0 ifTrue: [^nil]. n = 1 ifTrue: [^0]. cache isNil ifTrue: [cache := OrderedCollection new]. cache size < (self randmax highBit) ifTrue: [ Security.DSSRandom default next asByteArray do: [ :byte | (1 to: 8) do: [ :i | cache add: (byte bitAt: i)] ] ]. r := 0. bitSize := n highBit. to := cache size. from := to - bitSize + 1. (from to: to) do: [ :i | r := r bitAt: i - from + 1 put: (cache at: i) ]. cache removeFrom: from to: to. r >= n ifTrue: [^self next: n]. ^r
rand() % 3 output of rand() | rand()%3 0 | 0 1 | 1 2 | 2 3 | 0 4 | 1 5 | 2 6 | 0 7 | 1 8 | 2 9 | 0
int unbiased_random_bit() { int x1, x2, prev; prev = 2; x1 = rand() % 2; x2 = rand() % 2; for (;; x1 = rand() % 2, x2 = rand() % 2) { if (x1 ^ x2) { return x2; } else if (x1 & x2) { if (!prev) return 1; else prev = 1; } else { if (prev == 1) return 0; else prev = 0; } } }
bool XOR(bool a, bool b) { return (a + b) % 2; } int main() { using namespace std; cout << "XOR(true, true):\t" << XOR(true, true) << endl << "XOR(true, false):\t" << XOR(true, false) << endl << "XOR(false, true):\t" << XOR(false, true) << endl << "XOR(false, false):\t" << XOR(false, false) << endl << "XOR(0, 0):\t\t" << XOR(0, 0) << endl << "XOR(1, 0):\t\t" << XOR(1, 0) << endl << "XOR(5, 0):\t\t" << XOR(5, 0) << endl << "XOR(20, 0):\t\t" << XOR(20, 0) << endl << "XOR(6, 6):\t\t" << XOR(5, 5) << endl << "XOR(5, 6):\t\t" << XOR(5, 6) << endl << "XOR(1, 1):\t\t" << XOR(1, 1) << endl; return 0; }
/* From: http: Proposed code left-to-right? sequence point? bool args? bool result? ICE result? Singular -------------- -------------- --------------- ---------- ------------ ----------- ------------- a ^ b no no no no yes yes a != b no no no no yes yes (!a)!=(!b) no no no no yes yes my_xor_func(a,b) no no yes yes no yes a ? !b : b yes yes no no yes no a ? !b : !!b yes yes no no yes no [* see below] yes yes yes yes yes no (( a bool_xor b )) yes yes yes yes yes yes [* = a ? !static_cast<bool>(b) : static_cast<bool>(b)] But what is this funny "(( a bool_xor b ))"? Well, you can create some macros that allow you such a strange syntax. Note that the double-brackets are part of the syntax and cannot be removed! The set of three macros (plus two internal helper macros) also provides bool_and and bool_or. That given, what is it good for? We have && and || already, why do we need such a stupid syntax? Well, && and || can that the arguments are converted to bool and that you get a bool result. Think "operator overloads". Here Note: BOOL_DETAIL_OPEN/CLOSE added to make it work on MSVC 2010 */
XOR TABLE a b XOR --- --- --- T T F T F T F T T F F F a == !b TABLE a b !b a == !b --- --- --- ------- T T F F T F T T F T F T F F T F
|-----|-----|-----------| | A | B | A XOR B | |-----|-----|-----------| | T | T | False | |-----|-----|-----------| | T | F | True | |-----|-----|-----------| | F | T | True | |-----|-----|-----------| | F | F | False | |-----|-----|-----------|
static inline __bool xor(__bool a, __bool b) { return (!a && b) || (a && !b); }
enum Foo { One, Two, Three, Last }; for ( int fooInt = One; fooInt != Last; fooInt++ ) { Foo foo = static_cast<Foo>(fooInt); }
switch ( foo ) { case One: break; case Two: case Three: break; case Four: break; default: assert( ! "Invalid Foo enum value" ); break; }
namespace MyEnum { enum Type { a = 100, b = 220, c = -1 }; static const Type All[] = { a, b, c }; } void fun( const MyEnum::Type e ) { std::cout << e << std::endl; } int main() { for ( const auto e : MyEnum::All ) fun( e ); for ( const auto e : { MyEnum::a, MyEnum::b } ) fun( e ); std::for_each( std::begin( MyEnum::All ), std::end( MyEnum::All ), fun ); return 0; }
enum enumType { A = 0, B, C, enumTypeEnd }; for(int i=0; i<enumTypeEnd; i++) { enumType eCurrent = (enumType) i; }
template < typename C, C beginVal, C endVal> class Iterator { typedef typename std::underlying_type<C>::type val_t; int val; public: Iterator(const C & f) : val(static_cast<val_t>(f)) {} Iterator() : val(static_cast<val_t>(beginVal)) {} Iterator operator++() { ++val; return *this; } C operator*() { return static_cast<C>(val); } Iterator begin() { return *this; } Iterator end() { static const Iterator endIter=++Iterator(endVal); return endIter; } bool operator!=(const Iterator& i) { return val != i.val; } };
typedef Iterator<foo, foo::one, foo::three> fooIterator;
enum NodePosition { Primary = 0, Secondary = 1, Tertiary = 2, Quaternary = 3}; const NodePosition NodePositionVector[] = { Primary, Secondary, Tertiary, Quaternary }; for (NodePosition pos : NodePositionVector) { ... }
for (_type _start = _A1, _finish = _B1; _ok;)\ for (int _step = 2*(((int)_finish)>(int)_start)-1;_ok;)\ for (_type _param = _start; _ok ; \ (_param != _finish ? \ _param = static_cast<_type>(((int)_param)+_step) : _ok = false))
enum Count { zero, one, two, three }; for_range (Count, c, zero, three) { cout << "forward: " << c << endl; }
for_range (unsigned, i, 10,0) { cout << "backwards i: " << i << endl; } for_range (char, c, { cout << c << endl; }
unsigned p[4][5]; for_range (Count, i, zero,three) for_range(unsigned int, j, 4, 0) { p[i][j] = static_cast<unsigned>(i)+j; }
enum class myenumtype { MYENUM_FIRST, MYENUM_OTHER, MYENUM_LAST } for(myenumtype myenum = myenumtype::MYENUM_FIRST; myenum != myenumtype::MYENUM_LAST; myenum = static_cast<myenumtype>(static_cast<int>(myenum) + 1)) { do_whatever(myenum) }
enum EMyEnum { E_First, E_Orange = E_First, E_Green, E_White, E_Blue, E_Last } for (EMyEnum i = E_First; i < E_Last; i = EMyEnum(i + 1)) {}
enum EAnimal { E_First, E_None = E_First, E_CanFly = 0x1, E_CanWalk = 0x2 E_CanSwim = 0x4, E_Last } for (EAnimali = E_First; i < E_Last; i = EAnimal(i << 1)) {}
enum Colour {Red, Green, Blue}; const Colour LastColour = Blue; Colour co(0); while (true) { if (co == LastColour) break; co = Colour(co+1); }
enum enumtype { one, two, three, count}; for(enumtype i = one; i < count; i = inc_enum(i)) { dostuff(i); }
enum Bar { One = 1, Two, Three, End_Bar }; for (Bar foo = One; foo < End_Bar; foo = Bar(foo + 1)) { }
Qt::Key shortcut_key = Qt::Key_0; for (int idx = 0; etc...) { .... if (shortcut_key <= Qt::Key_9) { fileMenu->addAction("abc", this, SLOT(onNewTab()), QKeySequence(Qt::CTRL + shortcut_key)); shortcut_key = (Qt::Key) (shortcut_key + 1); } }
const QMetaObject *metaObject = qt_getQtMetaObject(); QMetaEnum keyEnum = metaObject->enumerator(metaObject->indexOfEnumerator("Key")); for (int i = 0; i < keyEnum.keyCount(); ++i) { qDebug() << keyEnum.key(i); }
int Array[] = {Hay,Grass,Beer,-1}; for (int h = 0; Array[h] != -1; h++){ doStuff( (MyEnumType) Array[h] ); }
void f(int n, int x) { Gadget *p = new Gadget{n}; if(x<100) throw SomeException{}; if(x<200) return; delete p; }
void f(int n, int x) { Gadget p = {n}; if(x<100) throw SomeException{}; if(x<200) return; }
MSVC++ 14.15 _MSC_VER == 1915 (Visual Studio 2017 version 15.8) MSVC++ 14.14 _MSC_VER == 1914 (Visual Studio 2017 version 15.7) MSVC++ 14.13 _MSC_VER == 1913 (Visual Studio 2017 version 15.6) MSVC++ 14.12 _MSC_VER == 1912 (Visual Studio 2017 version 15.5) MSVC++ 14.11 _MSC_VER == 1911 (Visual Studio 2017 version 15.3) MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017 version 15.0) MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015 version 14.0) MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013 version 12.0) MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012 version 11.0) MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010 version 10.0) MSVC++ 9.0 _MSC_FULL_VER == 150030729 (Visual Studio 2008, SP1) MSVC++ 9.0 _MSC_VER == 1500 (Visual Studio 2008 version 9.0) MSVC++ 8.0 _MSC_VER == 1400 (Visual Studio 2005 version 8.0) MSVC++ 7.1 _MSC_VER == 1310 (Visual Studio .NET 2003 version 7.1) MSVC++ 7.0 _MSC_VER == 1300 (Visual Studio .NET 2002 version 7.0) MSVC++ 6.0 _MSC_VER == 1200 (Visual Studio 6.0 version 6.0) MSVC++ 5.0 _MSC_VER == 1100 (Visual Studio 97 version 5.0)
c:\program files (x86)\microsoft visual studio 11.0\vc\bin>cl /? Microsoft (R) C/C++ Optimizing Compiler Version 17.00.50727.1 for x86 .....
inline int aplusb_pow2(int a, int b) { return (a + b)*(a + b) ; } for(int a = 0; a < 900000; ++a) for(int b = 0; b < 900000; ++b) aplusb_pow2(a, b);
inline void afunc() { std::cout << "this is afunc" << std::endl; } void acall() { afunc(); } void acall(); int main() { afunc(); acall(); } this is afunc this is afunc
class Mutex { public: Mutex() { if (pthread_mutex_init(&mutex_, 0) != 0) { throw MutexInitException(); } } ~Mutex() { pthread_mutex_destroy(&mutex_); } void lock() { if (pthread_mutex_lock(&mutex_) != 0) { throw MutexLockException(); } } void unlock() { if (pthread_mutex_unlock(&mutex_) != 0) { throw MutexUnlockException(); } } private: pthread_mutex_t mutex_; };
func::func() : foo() { try {...} catch (...) { ... } }
class bar { public: bar() { std::cout << "bar() called" << std::endl; } ~bar() { std::cout << "~bar() called" << std::endl; } }; class foo { public: foo() : b(new bar()) { std::cout << "foo() called" << std::endl; throw "throw something"; } ~foo() { delete b; std::cout << "~foo() called" << std::endl; } private: bar *b; }; int main(void) { try { std::cout << "heap: new foo" << std::endl; foo *f = new foo(); } catch (const char *e) { std::cout << "heap exception: " << e << std::endl; } try { std::cout << "stack: foo" << std::endl; foo f; } catch (const char *e) { std::cout << "stack exception: " << e << std::endl; } return 0; }
heap: new foo bar() called foo() called heap exception: throw something stack: foo bar() called foo() called stack exception: throw something
class A { public: A () { throw int (); } }; A a; int main () { try { } catch (int) { } }
class Scaler { public: Scaler(double factor) { if (factor == 0) { _state = 0; } else { _state = 1; _factor = factor; } } double ScaleMe(double value) { if (!_state) throw "Invalid object state."; return value / _factor; } int IsValid() { return _status; } private: double _factor; int _state; }
class ScalerFactory { public: Scaler CreateScaler(double factor) { ... } int TryCreateScaler(double factor, Scaler **scaler) { ... }; }
void lock() { int __e = __gthread_mutex_lock(&_M_mutex); if (__e) __throw_system_error(__e); }
void write_to_file (const std::string & message) { static std::mutex mutex; std::lock_guard<std::mutex> lock(mutex); std::ofstream file("example.txt"); if (!file.is_open()) throw std::runtime_error("unable to open file"); file << message << std::endl; }
class Mutex { private: int e; pthread_mutex_t mutex_; public: Mutex(): e(0) { e = pthread_mutex_init(&mutex_); } void lock() { e = pthread_mutex_lock(&mutex_); if( e == EINVAL ) { throw MutexInitException(); } else (e ) { throw MutexLockException(); } } };
using namespace std; class A { public: A(int a) : m_a(a) { cout << "A::A - setting m_a to:" << m_a << endl; } ~A() { cout << "A::~A" << endl; } int m_a; }; class B { public: B(int b) : m_b(b) { cout << "B::B - setting m_b to:" << m_b << endl; } ~B() { cout << "B::~B" << endl; } int m_b; }; class C { public: C(int a, int b, const string& str) : m_a(nullptr) , m_b(nullptr) , m_str(str) { m_a = new A(a); cout << "C::C - setting m_a to a newly A object created on the heap (address):" << m_a << endl; if (b == 0) { throw exception("sample exception to simulate situation where m_b was not fully initialized in class C ctor"); } m_b = new B(b); cout << "C::C - setting m_b to a newly B object created on the heap (address):" << m_b << endl; } ~C() { delete m_a; delete m_b; cout << "C::~C" << endl; } A* m_a; B* m_b; string m_str; }; class D { public: D() : m_a(nullptr) , m_b(nullptr) { cout << "D::D" << endl; } void InitD(int a, int b) { cout << "D::InitD" << endl; m_a = new A(a); throw exception("sample exception to simulate situation where m_b was not fully initialized in class D Init() method"); m_b = new B(b); } ~D() { delete m_a; delete m_b; cout << "D::~D" << endl; } A* m_a; B* m_b; }; void item10Usage() { cout << "item10Usage - start" << endl; { try { C c(1, 0, "str1"); } catch (const exception& e) { cout << "item10Usage - caught an exception when trying to create a C object on the stack:" << e.what() << endl; } } C* pc = 0; try { pc = new C(1, 0, "str2"); } catch (const exception& e) { cout << "item10Usage - caught an exception while trying to create a new C object on the heap:" << e.what() << endl; delete pc; } D* pd = new D(); try { pd->InitD(1,0); } catch (const exception& e) { cout << "item10Usage - caught an exception while trying to init a D object:" << e.what() << endl; delete pd; } cout << "\n \n item10Usage - end" << endl; } int main(int argc, char** argv) { cout << "main - start" << endl; item10Usage(); cout << "\n \n main - end" << endl; return 0; }
unsigned long x = 4; void func1(unsigned long& val) { val = 5; } func1(x);
void func2(unsigned long* val) { *val = 5; } func2(&x);
void PrintOptional(const boost::optional<std::string>& optional_str) { if (optional_str) { cout << *optional_str << std::endl; } else { cout << "(no string)" << std::endl; } } boost::optional<int> ReturnOptional(bool return_nothing) { if (return_nothing) { return boost::optional<int>(); } return boost::optional<int>(42); }
BaseType* ptrBaseType; BaseType objBaseType; ptrBaseType = &objBaseType;
int nVar = 7; int* ptrVar = &nVar; int nVar2 = *ptrVar;
g++ -g tool.o support.o -L/sw/lib/root -lCore -lCint -lRIO -lNet -lHist -lGraf -lGraf3d -lGpad -lTree -lRint \ -lPostscript -lMatrix -lPhysics -lMathCore -lThread -lz -L/sw/lib -lfreetype -lz -Wl,-framework,CoreServices \ -Wl,-framework,ApplicationServices -pthread -Wl,-rpath,/sw/lib/root -lm -ldl
tool: tool.o support.o g++ -g -o tool tool.o support.o -L/sw/lib/root -lCore -lCint -lRIO -lNet -lHist -lGraf -lGraf3d -lGpad -lTree -lRint \ -lPostscript -lMatrix -lPhysics -lMathCore -lThread -lz -L/sw/lib -lfreetype -lz -Wl,-framework,CoreServices \ -Wl,-framework,ApplicationServices -pthread -Wl,-rpath,/sw/lib/root -lm -ldl tool.o: tool.cc support.hh g++ -g -c -pthread -I/sw/include/root tool.cc support.o: support.hh support.cc g++ -g -c -pthread -I/sw/include/root support.cc
CPPFLAGS=-g -pthread -I/sw/include/root LDFLAGS=-g LDLIBS=-L/sw/lib/root -lCore -lCint -lRIO -lNet -lHist -lGraf -lGraf3d -lGpad -lTree -lRint \ -lPostscript -lMatrix -lPhysics -lMathCore -lThread -lz -L/sw/lib -lfreetype -lz \ -Wl,-framework,CoreServices -Wl,-framework,ApplicationServices -pthread -Wl,-rpath,/sw/lib/root \ -lm -ldl tool: tool.o support.o g++ $(LDFLAGS) -o tool tool.o support.o $(LDLIBS) tool.o: tool.cc support.hh g++ $(CPPFLAGS) -c tool.cc support.o: support.hh support.cc g++ $(CPPFLAGS) -c support.cc
CPPFLAGS=-g $(shell root-config --cflags) LDFLAGS=-g $(shell root-config --ldflags) LDLIBS=$(shell root-config --libs) SRCS=tool.cc support.cc OBJS=$(subst .cc,.o,$(SRCS)) tool: $(OBJS) g++ $(LDFLAGS) -o tool tool.o support.o $(LDLIBS) tool.o: tool.cc support.hh g++ $(CPPFLAGS) -c tool.cc support.o: support.hh support.cc g++ $(CPPFLAGS) -c support.cc
CC=gcc CXX=g++ RM=rm -f CPPFLAGS=-g $(shell root-config --cflags) LDFLAGS=-g $(shell root-config --ldflags) LDLIBS=$(shell root-config --libs) SRCS=tool.cc support.cc OBJS=$(subst .cc,.o,$(SRCS)) all: tool tool: $(OBJS) $(CXX) $(LDFLAGS) -o tool $(OBJS) $(LDLIBS) tool.o: tool.cc support.hh support.o: support.hh support.cc clean: $(RM) $(OBJS) distclean: clean $(RM) tool
CC=gcc CXX=g++ RM=rm -f CPPFLAGS=-g $(shell root-config --cflags) LDFLAGS=-g $(shell root-config --ldflags) LDLIBS=$(shell root-config --libs) SRCS=tool.cc support.cc OBJS=$(subst .cc,.o,$(SRCS)) all: tool tool: $(OBJS) $(CXX) $(LDFLAGS) -o tool $(OBJS) $(LDLIBS) depend: .depend .depend: $(SRCS) $(RM) ./.depend $(CXX) $(CPPFLAGS) -MM $^>>./.depend; clean: $(RM) $(OBJS) distclean: clean $(RM) *~ .depend include .depend
a3driver: a3driver.o g++ -o a3driver a3driver.o a3driver.o: a3driver.cpp g++ -c a3driver.cpp
a3driver: a3driver.cpp g++ -o a3driver a3driver.cpp
a3driver: a3driver.o secondFile.o g++ -o a3driver a3driver.o secondFile.o a3driver.o: a3driver.cpp g++ -c a3driver.cpp secondFile.o: secondFile.cpp secondFile.h g++ -c secondFile.cpp
appname := myapp CXX := clang++ CXXFLAGS := -std=c++11 srcfiles := $(shell find . -name "*.C") objects := $(patsubst %.C, %.o, $(srcfiles)) all: $(appname) $(appname): $(objects) $(CXX) $(CXXFLAGS) $(LDFLAGS) -o $(appname) $(objects) $(LDLIBS) depend: .depend .depend: $(srcfiles) rm -f ./.depend $(CXX) $(CXXFLAGS) -MM $^>>./.depend; clean: rm -f $(objects) dist-clean: clean rm -f *~ .depend include .depend
a3a.exe: a3driver.obj link /out:a3a.exe a3driver.obj
main_target : source1 source2 etc command to build main_target from sources source1 : dependents for source1 command to build source1
a3a.exe : a3driver.obj link /out:a3a.exe a3driver.obj a3driver.obj : a3driver.cpp cc a3driver.cpp
appname := myapp CXX := g++ CXXFLAGS := -Wall -g srcfiles := $(shell find . -maxdepth 1 -name "*.cpp") objects := $(patsubst %.cpp, %.o, $(srcfiles)) all: $(appname) $(appname): $(objects) $(CXX) $(CXXFLAGS) $(LDFLAGS) -o $(appname) $(objects) $(LDLIBS) depend: .depend .depend: $(srcfiles) rm -f ./.depend $(CXX) $(CXXFLAGS) -MM $^>>./.depend; clean: rm -f $(objects) dist-clean: clean rm -f *~ .depend include .depend
MyClass* myClass = new MyClass(); myClass->MyField = "Hello world!";
{ using namespace std ; string s ; vector v ; } string ss ; vector vv ;
{ using std::string ; string s ; vector v ; } string ss ; vector vv ;
template<typename T, int decimalPlaces> class MyMath { }; typedef MyMath<double, 4> CAMMath; typedef MyMath<float, 2> PreviewMath;
enum E { FUNCTIONALITY_NORMAL, FUNCTIONALITY_RESTRICTED, FUNCTIONALITY_FOR_PROJECT_X }
enum Enum1; enum Enum2 : unsigned int; enum class Enum3; enum class Enum4: unsigned int; enum Enum2 : unsigned short;
enum E : short; void foo(E e); .... enum E : short { VALUE_1, VALUE_2, .... }
enum Color : char { Red=0, Green=1, Blue=2}; assert(sizeof Color == 1);
enum Econtent { FUNCTIONALITY_NORMAL, FUNCTIONALITY_RESTRICTED, FUNCTIONALITY_FOR_PROJECT_X, FORCE_32BIT = 0xFFFFFFFF };
class AImpl { public: AImpl(A* pThis): m_pThis(pThis) {} ... all private methods here ... private: A* m_pThis; };
struct NAME { \ enum e { VALUES }; \ explicit NAME(TYPE v) : val(v) {} \ NAME(e v) : val(v) {} \ operator e() const { return e(val); } \ private:\ TYPE val; \ }
namespace { const int FUNCTIONALITY_NORMAL = 0 ; const int FUNCTIONALITY_RESTRICTED = 1 ; const int FUNCTIONALITY_FOR_PROJECT_X = 2 ; }
namespace { const int FUNCTIONALITY_begin = 0 ; const int FUNCTIONALITY_NORMAL = 0 ; const int FUNCTIONALITY_RESTRICTED = 1 ; const int FUNCTIONALITY_FOR_PROJECT_X = 2 ; const int FUNCTIONALITY_end = 3 ; bool isFunctionalityCorrect(int i) { return (i >= FUNCTIONALITY_begin) && (i < FUNCTIONALITY_end) ; } }
namespace type { class legacy_type; typedef const legacy_type& type; }
namespace legacy { enum evil { x , y, z }; } namespace type { using legacy::evil; class legacy_type { public: legacy_type(evil e) : e_(e) {} operator evil() const { return e_; } private: evil e_; }; }
void foo::f(type::type t) { switch (t) { case legacy::x: std::cout << "x" << std::endl; break; case legacy::y: std::cout << "y" << std::endl; break; case legacy::z: std::cout << "z" << std::endl; break; default: std::cout << "default" << std::endl; } }
class lock { mutex &m_; public: lock(mutex &m) : m_(m) { m.acquire(); } ~lock() { m_.release(); } }; class foo { mutex mutex_; public: void bar() { lock scopeLock(mutex_); foobar(); } };
namespace detail { template <typename F> struct FinalAction { FinalAction(F f) : clean_{f} {} ~FinalAction() { if(enabled_) clean_(); } void disable() { enabled_ = false; }; private: F clean_; bool enabled_{true}; }; } template <typename F> detail::FinalAction<F> finally(F f) { return detail::FinalAction<F>(f); }
int main() { int* a = new int; auto delete_a = finally([a] { delete a; std::cout << "leaving the block, deleting a!\n"; }); std::cout << "doing something ...\n"; }
[...] auto precision = std::cout.precision(); auto set_precision_back = finally( [precision, &std::cout]() { std::cout << std::setprecision(precision); } ); std::cout << std::setprecision(3);
void copy_to_all(BIGobj const& a) { first_.push_back(a); auto undo_first_push = finally([first_&] { first_.pop_back(); }); second_.push_back(a); auto undo_second_push = finally([second_&] { second_.pop_back(); }); third_.push_back(a); auto undo_third_push = finally([third_&] { third_.pop_back(); }); undo_first_push.disable(); undo_second_push.disable(); undo_third_push.disable(); }
void DoStuff(vector<string> input) { list<Foo*> myList; try { for (int i = 0; i < input.size(); ++i) { Foo* tmp = new Foo(input[i]); if (!tmp) throw; myList.push_back(tmp); } DoSomeStuff(myList); } finally { while (!myList.empty()) { delete myList.back(); myList.pop_back(); } } }
void DoStuff(vector<string> input) { list<Foo*> myList; try { for (int i = 0; i < input.size(); ++i) { Foo* tmp = new Foo(input[i]); if (!tmp) throw; myList.push_back(tmp); } DoSomeStuff(myList); } catch(...) { } while (!myList.empty()) { delete myList.back(); myList.pop_back(); } }
int CMyApp::Run() { __try { int i = CWinApp::Run(); m_Exitok = MAGIC_EXIT_NO; return i; } __finally { if (m_Exitok != MAGIC_EXIT_NO) FaultHandler(); } }
void example() { int handle = get_some_resource(); auto handle_clean = gsl::finally([&handle] { clean_that_resource(handle); }); }
template <typename TCode, typename TFinallyCode> inline void with_finally(const TCode &code, const TFinallyCode &finally_code) { try { code(); } catch (...) { try { finally_code(); } catch (...) { std::terminate(); } throw; } finally_code(); }
with_finally( [&]() { try { } catch (const exception1 &) { } catch (const exception2 &) { } }, [&]() { } );
begin_try { } catch (const some_exception &) { } finally { } end_try;
void function(std::vector<const char*> &vector) { int *arr1 = (int*)malloc(800*sizeof(int)); if (!arr1) { throw "cannot malloc arr1"; } ON_FINALLY({ free(arr1); }); int *arr2 = (int*)malloc(900*sizeof(int)); if (!arr2) { throw "cannot malloc arr2"; } ON_FINALLY({ free(arr2); }); vector.push_back("good"); ON_EXCEPTION({ vector.pop_back(); }); ...
int * array = new int[10000000]; try { throw std::exception(); } catch (...) { delete[] array; throw; } delete[] array;
template <typename Fun> class FinallyHelper { template <typename T> struct TypeWrapper {}; using Return = typename std::result_of<Fun()>::type; public: FinallyHelper(Fun body) { try { execute(TypeWrapper<Return>(), body); } catch(...) { m_promise.set_exception(std::current_exception()); } } Return get() { return m_promise.get_future().get(); } private: template <typename T> void execute(T, Fun body) { m_promise.set_value(body()); } void execute(TypeWrapper<void>, Fun body) { body(); } std::promise<Return> m_promise; }; template <typename Fun> FinallyHelper<Fun> make_finally_helper(Fun body) { return FinallyHelper<Fun>(body); }
true; \ ({return __finally_helper.get();})) \ /***/
void test() { try_with_finally { raise_exception(); } catch(const my_exception1&) { } catch(const my_exception2&) { } finally { clean_it_all_up(); } }
extern Queue downstream, upstream; int Example() { try { while(!ExitRequested()) { X* x = upstream.pop(); if (!x) break; x->doSomething(); downstream.push(x); } } finally { downstream.push(nullptr); } }
class Finally { public: Finally(std::function<void(void)> callback) : callback_(callback) { } ~Finally() { callback_(); } std::function<void(void)> callback_; };
extern Queue downstream, upstream; int Example() { Finally atEnd([](){ downstream.push(nullptr); }); while(!ExitRequested()) { X* x = upstream.pop(); if (!x) break; x->doSomething(); downstream.push(x); } }
using namespace std; class Foo { ... }; void DoStuff(vector<string> input) { list<unique_ptr<Foo> > myList; for (int i = 0; i < input.size(); ++i) { myList.push_back(unique_ptr<Foo>(new Foo(input[i]))); } DoSomeStuff(myList); }
bool generalAppState = false; try{ generalAppState = true; } catch( ... ){ } if( !generalAppState ){ doSomeCleanUpOfDirtyEnd(); } else{ cleanEnd(); }
try { ... goto finally; } catch(...) { ... goto finally; } finally: { ... }
int cConc[3][5]; std::array<std::array<int, 5>, 3> aConc; int **ptrConc; std::vector<std::vector<int>> vConc;
class blub { void test() { } public: std::thread spawn() { return { test }; } };
class bar { public: void foo() { std::cout << "hello from member function" << std::endl; } }; int main() { std::thread t(&bar::foo, bar()); t.join(); }
std::thread spawn() { return std::thread(&blub::test, this); }
class blub { void test() {} public: std::thread spawn() { return std::thread( [this] { this->test(); } ); } };
class Wrapper { public: void member1() { std::cout << "i am member1" << std::endl; } void member2(const char *arg1, unsigned arg2) { std::cout << "i am member2 and my first arg is (" << arg1 << ") and second arg is (" << arg2 << ")" << std::endl; } std::thread member1Thread() { return std::thread([=] { member1(); }); } std::thread member2Thread(const char *arg1, unsigned arg2) { return std::thread([=] { member2(arg1, arg2); }); } }; int main(int argc, char **argv) { Wrapper *w = new Wrapper(); std::thread tw1 = w->member1Thread(); std::thread tw2 = w->member2Thread("hello", 100); tw1.join(); tw2.join(); return 0; }
g++ -Wall -std=c++11 hello.cc -o hello -pthread i am member1 i am member2 and my first arg is (hello) and second arg is (100)
class CFoo { public: int m_i = 0; void bar() { ++m_i; } }; int main() { CFoo foo; std::thread t1(&CFoo::bar, &foo); t1.join(); std::thread t2(&CFoo::bar, &foo); t2.join(); std::cout << foo.m_i << std::endl; return 0; }
class Wrapper { public: void member1() { std::cout << "i am member1" << std::endl; } void member2(const char *arg1, unsigned arg2) { std::cout << "i am member2 and my first arg is (" << arg1 << ") and second arg is (" << arg2 << ")" << std::endl; } std::thread member1Thread() { return std::thread(&Wrapper::member1, this); } std::thread member2Thread(const char *arg1, unsigned arg2) { return std::thread(&Wrapper::member2, this, arg1, arg2); } }; int main() { Wrapper *w = new Wrapper(); std::thread tw1 = w->member1Thread(); tw1.join(); std::thread tw2 = w->member2Thread("hello", 100); tw2.join(); return 0; }
using namespace std; class CB { public: CB() { cout << "this=" << this << endl; } void operator()(); }; void CB::operator()() { cout << "this=" << this << endl; for (int i = 0; i < 5; i++) { cout << "CB()=" << i << endl; Sleep(1000); } } void main() { CB obj; thread t(obj); t.join(); }
void main() { CB obj; thread t(std::ref(obj)); t.join(); }
template<class InputIt, class UnaryFunction> UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f) { for (; first != last; ++first) { f(*first); } return f; }
std::vector<double> v{ 1.0, 2.2, 4.0, 5.5, 7.2 }; double r = 4.0; std::for_each(v.begin(), v.end(), [&](double & v) { v += r; }); std::for_each(v.begin(), v.end(), [](double v) { std::cout << v << " "; });
void player_jump(); void player_crouch(); class game_core { std::array<void(*)(), total_num_keys> actions; void key_pressed(unsigned key_id) { if(actions[key_id]) actions[key_id](); } void update_keybind(unsigned key_id, void(*new_action)()) { actions[key_id] = new_action; } };
game_core_instance.update_keybind(newly_selected_key, &player_jump);
return_type (*)(parameter_type_1, parameter_type_2, parameter_type_3) int (*)(int)
return_type (* name) (parameter_type_1, parameter_type_2, parameter_type_3) typedef int (*f_int_t) (int); int (* foo_p)(int) = &foo; f_int_t foo_p = &foo;
int foobar (int x, int (*moo)(int)); int foobar (int x, f_int_t moo);
int foobar (int x, int (*moo)(int)) { return x + moo(x); } int foobar (int x, f_int_t moo) { return x + moo(x); }
int a = 5; int b = foobar(a, foo); int b = foobar(a, &foo);
void tranform_every_int(int * v, unsigned n, int (*fp)(int)) { for (unsigned i = 0; i < n; ++i) { v[i] = fp(v[i]); } }
int double_int(int x) { return 2*x; } int square_int(int x) { return x*x; }
int a[5] = {1, 2, 3, 4, 5}; tranform_every_int(&a[0], 5, double_int); tranform_every_int(&a[0], 5, square_int);
struct C { int y; int foo(int x) const { return x+y; } };
return_type (T::*)(parameter_type_1, parameter_type_2, parameter_type_3) int (C::*) (int)
return_type (T::* name) (parameter_type_1, parameter_type_2, parameter_type_3) typedef int (C::* f_C_int_t) (int x); int (C::* C_foo_p)(int) = &C::foo; f_C_int_t C_foo_p = &C::foo;
int C_foobar (int x, C const &c, int (C::*moo)(int)); int C_foobar (int x, C const &c, f_C_int_t moo);
int C_foobar (int x, C const &c, int (C::*moo)(int)) { return x + (c.*moo)(x); } int C_foobar (int x, C const &c, f_C_int_t moo) { return x + (c.*moo)(x); }
int C_foobar_2 (int x, C const * c, int (C::*meow)(int)) { if (!c) return x; return x + ((*c).*meow)(x); } int C_foobar_2 (int x, C const * c, int (C::*meow)(int)) { if (!c) return x; return x + (c->*meow)(x); }
C my_c{2}; int a = 5; int b = C_foobar(a, my_c, &C::foo);
std::function<return_type(parameter_type_1, parameter_type_2, parameter_type_3)> std::function<int(int)> stdf_foo = &foo; std::function<int(const C&, int)> stdf_C_foo = &C::foo;
int stdf_foobar (int x, std::function<int(int)> moo) { return x + moo(x); } int stdf_C_foobar (int x, C const &c, std::function<int(C const &, int)> moo) { return x + moo(c, x); }
int a = 2; C my_c{7}; int b = stdf_C_foobar(a, c, &C::foo);
int a = 2; int c = 3; int b = stdf_foobar(a, [c](int x) -> int { return 7+c*x; });
int foo_2 (int x, int y) { return 9*x + y; } using std::placeholders::_1; int a = 2; int b = stdf_foobar(a, std::bind(foo_2, _1, 3)); int c = stdf_foobar(a, std::bind(foo_2, 5, _1));
int a = 2; C const my_c{7}; int b = stdf_foobar(a, std::bind(&C::foo, my_c, _1));
struct Meow { int y = 0; Meow(int y_) : y(y_) {} int operator()(int x) { return y * x; } }; int a = 11; int b = stdf_foobar(a, Meow{8});
void stdf_tranform_every_int(int * v, unsigned n, std::function<int(int)> fp) { for (unsigned i = 0; i < n; ++i) { v[i] = fp(v[i]); } }
int a[5] = {1, 2, 3, 4, 5}; stdf_tranform_every_int(&a[0], 5, double_int); stdf_tranform_every_int(&a[0], 5, [](int x) -> int { return x/2; }); int nine_x_and_y (int x, int y) { return 9*x + y; } using std::placeholders::_1; stdf_tranform_every_int(&a[0], 5, std::bind(nine_x_and_y, _1, 4));
template<class R, class T> void stdf_transform_every_int_templ(int * v, unsigned const n, std::function<R(T)> fp) { for (unsigned i = 0; i < n; ++i) { v[i] = fp(v[i]); } }
template<class F> void transform_every_int_templ(int * v, unsigned const n, F f) { std::cout << "transform_every_int_templ<" << type_name<F>() << ">\n"; for (unsigned i = 0; i < n; ++i) { v[i] = f(v[i]); } }
template<class InputIt, class OutputIt, class UnaryOperation> OutputIt transform(InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op) { while (first1 != last1) { *d_first++ = unary_op(*first1++); } return d_first; }
int foo (int x) { return 2+x; } int muh (int const &x) { return 3+x; } int & woof (int &x) { x *= 4; return x; } int a[5] = {1, 2, 3, 4, 5}; stdf_transform_every_int_templ<int,int>(&a[0], 5, &foo); stdf_transform_every_int_templ<int, int const &>(&a[0], 5, &muh); stdf_transform_every_int_templ<int, int &>(&a[0], 5, &woof);
void print_int(int * p, unsigned const n) { bool f{ true }; for (unsigned i = 0; i < n; ++i) { std::cout << (f ? "" : " ") << p[i]; f = false; } std::cout << "\n"; }
int a[5] = { 1, 2, 3, 4, 5 }; print_int(a, 5); transform_every_int_templ(&a[0], 5, foo); print_int(a, 5); transform_every_int_templ(&a[0], 5, muh); print_int(a, 5); transform_every_int_templ(&a[0], 5, woof); print_int(a, 5); transform_every_int_templ(&a[0], 5, [](int x) -> int { return x + x + x; }); print_int(a, 5); transform_every_int_templ(&a[0], 5, Meow{ 4 }); print_int(a, 5); using std::placeholders::_1; transform_every_int_templ(&a[0], 5, std::bind(foo_2, _1, 3)); print_int(a, 5); transform_every_int_templ(&a[0], 5, std::function<int(int)>{&foo}); print_int(a, 5);
1 2 3 4 5 transform_every_int_templ <int(*)(int)> 3 4 5 6 7 transform_every_int_templ <int(*)(int&)> 6 8 10 12 14 transform_every_int_templ <int& (*)(int&)> 9 11 13 15 17 transform_every_int_templ <main::{lambda(int) 27 33 39 45 51 transform_every_int_templ <Meow> 108 132 156 180 204 transform_every_int_templ <std::_Bind<int(*(std::_Placeholder<1>, int))(int, int)>> 975 1191 1407 1623 1839 transform_every_int_templ <std::function<int(int)>> 977 1193 1409 1625 1841
template <class T> std::string type_name() { typedef typename std::remove_reference<T>::type TR; std::unique_ptr<char, void(*)(void*)> own (abi::__cxa_demangle(typeid(TR).name(), nullptr, nullptr, nullptr), std::free); std::string r = own != nullptr?own.get():typeid(TR).name(); if (std::is_const<TR>::value) r += " const"; if (std::is_volatile<TR>::value) r += " volatile"; if (std::is_lvalue_reference<T>::value) r += " &"; else if (std::is_rvalue_reference<T>::value) r += " &&"; return r; }
typedef int (*CallbackType)(float); void DoWork(CallbackType callback) { float variable = 0.0f; int result = callback(variable); } int SomeCallback(float variable) { int result; return result; } int main(int argc, char ** argv) { DoWork(&SomeCallback); }
typedef int (ClassName::*CallbackType)(float); void DoWorkObject(CallbackType callback) { ClassName objectInstance; int result = (objectInstance.*callback)(1.0f); } void DoWorkPointer(CallbackType callback) { ClassName * pointerInstance; int result = (pointerInstance->*callback)(1.0f); } int main(int argc, char ** argv) { DoWorkObject(&ClassName::Method); DoWorkPointer(&ClassName::Method); }
class GameCharacter; int defaultHealthCalc(const GameCharacter& gc); class GameCharacter { public: typedef std::function<int (const GameCharacter&)> HealthCalcFunc; explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) { } int healthValue() const { return healthFunc(*this); } private: HealthCalcFunc healthFunc; };
void print_hashes(std::function<int (const std::string&)> hash_calculator) { std::string strings_to_hash[] = {"you", "saved", "my", "day"}; for(auto s : strings_to_hash) std::cout << s << ":" << hash_calculator(s) << std::endl; } int main() { print_hashes( [](const std::string& str) { /** lambda expression */ int result = 0; for (int i = 0; i < str.length(); i++) result += pow(31, i) * str.at(i); return result; }); return 0; }
class C1 { public: C1() {}; ~C1() {}; void CALLBACK F1(int i); }; void CALLBACK C1::F1(int i) { } class C1; class C2 { typedef void (CALLBACK C1::* pfnCallBack)(int i); public: C2() {}; ~C2() {}; void Fn(C1 * pThat,pfnCallBack pFn); }; void C2::Fn(C1 * pThat,pfnCallBack pFn) { int i = 1; (pThat->*pFn)(i); }
class Document { public: typedef boost::signals2::signal<void ()> signal_t; public: Document() {} boost::signals2::connection connect(const signal_t::slot_type &subscriber) { return m_sig.connect(subscriber); } void append(const char* s) { m_text += s; m_sig(); } const std::string& getText() const { return m_text; } private: signal_t m_sig; std::string m_text; };
class TextView { public: TextView(Document& doc): m_document(doc) { m_connection = m_document.connect(boost::bind(&TextView::refresh, this)); } ~TextView() { m_connection.disconnect(); } void refresh() const { std::cout << "TextView: " << m_document.getText() << std::endl; } private: Document& m_document; boost::signals2::connection m_connection; };
ent principal(ent argn, ent** argm) { std::cendehors << "Bonjour le monde!\n"; renvoi SORTIE_SUCCÈS; }
principal.cpp:1:6: erreur: prétraitement de la directive invalide ^ principal.cpp:6:8: erreur: renvoi SORTIE_SUCCÈS; ^ principal.cpp:6:8: erreur: principal.cpp:3:5: erreur: «ent» ne désigne pas un type ent principal(ent argn, ent** argm) ^
principal ent(argn ent, argm **ent) { norme::sortiec << « Bonjour à tout le monde !\n » ; retourner SORTIE_SUCCÈS ; }
pour exemple répète 18 [av 5 td 10] td 60 répète 18 [av 5 td 10] fin
ent principal(ent narg, cara** marg) { std::cendehors << "Bonjour le monde !\n" ; renvoyer SORTIE_SUCCÈS ; }
genre::masculins Croissant { nul nourrir(Hommes hommes) { hommes.(ce)manger ; } }
genre::féminin Grenouille { nul nourrir(Hommes hommes) { hommes.(cette)manger; } }
void f(int a, double b, void* c) { std::cout << a << ":" << b << ":" << c << std::endl; } template <typename ...Args> struct save_it_for_later { std::tuple<Args...> params; void (*func)(Args...); void delayed_dispatch() { func(std::get<0>(params), std::get<1>(params), std::get<2>(params)); func(params...); } }; int main() { int a=666; double b = -1.234; void *c = NULL; save_it_for_later<int,double,void*> saved = { std::tuple<int,double,void*>(a,b,c), f}; saved.delayed_dispatch(); }
template<int ...> struct seq { }; template<int N, int ...S> struct gens : gens<N-1, N-1, S...> { }; template<int ...S> struct gens<0, S...> { typedef seq<S...> type; }; void delayed_dispatch() { callFunc(typename gens<sizeof...(Args)>::type()); } template<int ...S> void callFunc(seq<S...>) { func(std::get<S>(params) ...); }
johannes.cc using std::cout; using std::endl; template<int ...> struct seq {}; template<int N, int ...S> struct gens : gens<N-1, N-1, S...> {}; template<int ...S> struct gens<0, S...>{ typedef seq<S...> type; }; double foo(int x, float y, double z) { return x + y + z; } template <typename ...Args> struct save_it_for_later { std::tuple<Args...> params; double (*func)(Args...); double delayed_dispatch() { return callFunc(typename gens<sizeof...(Args)>::type()); } template<int ...S> double callFunc(seq<S...>) { return func(std::get<S>(params) ...); } }; int main(void) { gens<10> g; gens<10>::type s; std::tuple<int, float, double> t = std::make_tuple(1, 1.2, 5); save_it_for_later<int,float, double> saved = {t, foo}; cout << saved.delayed_dispatch() << endl; }
SConstruct env = Environment(CXX="g++-4.7", CXXFLAGS="-Wall -Werror -g -O3 -std=c++11") env.Program(target="johannes", source=["johannes.cc"])
g++-4.7 -o johannes.o -c -Wall -Werror -g -O3 -std=c++11 johannes.cc g++-4.7 -o johannes johannes.o
template <typename ...Args> struct save_it_for_later { std::tuple<Args...> params; void (*func)(Args...); template<std::size_t ...I> void call_func(std::index_sequence<I...>) { func(std::get<I>(params)...); } void delayed_dispatch() { call_func(std::index_sequence_for<Args...>{}); } };
template<typename R, template<typename...> class Params, typename... Args, std::size_t... I> R call_helper(std::function<R(Args...)> const&func, Params<Args...> const&params, std::index_sequence<I...>) { return func(std::get<I>(params)...); } template<typename R, template<typename...> class Params, typename... Args> R call(std::function<R(Args...)> const&func, Params<Args...> const&params) { return call_helper(func,params,std::index_sequence_for<Args...>{}); }
template <typename ...Args> struct save_it_for_later { std::tuple<Args...> params; std::function<void(Args...)> func; void delayed_dispatch() { std::call(func,params); } };
auto f = [](int a, double b, std::string c) { std::cout<<a<<" "<<b<<" "<<c<< std::endl; }; auto params = std::make_tuple(1,2.0,"Hello"); std::apply(f, params);
void f(int a, double b, void* c) { std::cout << a << ":" << b << ":" << c << std::endl; }
template<typename Function, typename Tuple, size_t ... I> auto call(Function f, Tuple t, std::index_sequence<I ...>) { return f(std::get<I>(t) ...); } template<typename Function, typename Tuple> auto call(Function f, Tuple t) { static constexpr auto size = std::tuple_size<Tuple>::value; return call(f, t, std::make_index_sequence<size>{}); }
int main() { std::tuple<int, double, int*> t; call(f, t); }
template<std::size_t...Is> auto index_over(std::index_sequence<Is...>){ return [](auto&&f)->decltype(auto){ return decltype(f)(f)( std::integral_constant<std::size_t, Is>{}... ); }; } template<std::size_t N> auto index_upto(std::integral_constant<std::size_t, N> ={}){ return index_over( std::make_index_sequence<N>{} ); }
void delayed_dispatch() { auto indexer = index_upto<sizeof...(Args)>(); indexer([&](auto...Is){ func(std::get<Is>(params)...); }); }
void delayed_dispatch() { std::apply( func, params ); }
namespace notstd { template<class T> constexpr auto tuple_size_v = std::tuple_size<T>::value; template<class F, class Tuple> decltype(auto) apply( F&& f, Tuple&& tup ) { auto indexer = index_upto< tuple_size_v<std::remove_reference_t<Tuple>> >(); return indexer( [&](auto...Is)->decltype(auto) { return std::forward<F>(f)( std::get<Is>(std::forward<Tuple>(tup))... ); } ); } }
void delayed_dispatch() { notstd::apply( func, params ); }
template <int N, int M, typename D> struct call_or_recurse; template <typename ...Types> struct dispatcher { template <typename F, typename ...Args> static void impl(F f, const std::tuple<Types...>& params, Args... args) { call_or_recurse<sizeof...(Args), sizeof...(Types), dispatcher<Types...> >::call(f, params, args...); } }; template <int N, int M, typename D> struct call_or_recurse { template <typename F, typename T, typename ...Args> static void call(F f, const T& t, Args... args) { D::template impl(f, t, std::get<M-(N+1)>(t), args...); } }; template <int N, typename D> struct call_or_recurse<N,N,D> { template <typename F, typename T, typename ...Args> static void call(F f, const T&, Args... args) { f(args...); } };
void delayed_dispatch() { dispatcher<Args...>::impl(func, params); }
void f(int a, double b, void* c) { std::cout << a << ":" << b << ":" << c << std::endl; } template <typename ...Args> struct save_it_for_later { std::tuple<Args...> params; void (*func)(Args...); template <typename ...Actual> typename std::enable_if<sizeof...(Actual) != sizeof...(Args)>::type delayed_dispatch(Actual&& ...a) { delayed_dispatch(std::forward<Actual>(a)..., std::get<sizeof...(Actual)>(params)); } void delayed_dispatch(Args ...args) { func(args...); } }; int main() { int a=666; double b = -1.234; void *c = NULL; save_it_for_later<int,double,void*> saved = { std::tuple<int,double,void*>(a,b,c), f}; saved.delayed_dispatch(); }
template <typename RetT, typename ...Args> struct save_it_for_later { RetT (*func)(Args...); std::tuple<Args...> params; save_it_for_later(RetT (*f)(Args...), std::tuple<Args...> par) : func { f }, params { par } {} RetT delayed_dispatch() { return callFunc(std::index_sequence_for<Args...>{}); } template<std::size_t... Is> RetT callFunc(std::index_sequence<Is...>) { return func(std::get<Is>(params) ...); } }; double foo(int x, float y, double z) { return x + y + z; } int testTuple(void) { std::tuple<int, float, double> t = std::make_tuple(1, 1.2, 5); save_it_for_later<double, int, float, double> saved (&foo, t); cout << saved.delayed_dispatch() << endl; return 0; }
if (-2147483648 > 0) std::cout << "true"; else std::cout << "false";
if (int(-2147483648) > 0) std::cout << "true"; else std::cout << "false";
const bool b= (-2147483647 > 0) ; const bool i= (-2147483648 > 0) ; const bool c= ( INT_MIN-1 > 0) ; const bool f= ( 2147483647 > 0) ; const bool g= ( 2147483648 > 0) ; const bool d= ( INT_MAX+1 > 0) ; const bool j= ( int(-2147483648)> 0) ; const bool h= ( int(2147483648) > 0) ; const bool m= (-2147483648L > 0) ; const bool o= (-2147483648LL > 0) ;
class Base { private: int MyPrivateInt; protected: int MyProtectedInt; public: int MyPublicInt; } class Derived : Base { public: int foo1() { return MyPrivateInt;} int foo2() { return MyProtectedInt;} int foo3() { return MyPublicInt;} }; class Unrelated { private: Base B; public: int foo1() { return B.MyPrivateInt;} int foo2() { return B.MyProtectedInt;} int foo3() { return B.MyPublicInt;} };
class A { private: int _privInt = 0; int privFunc(){return 0;} virtual int privVirtFunc(){return 0;} protected: int _protInt = 0; int protFunc(){return 0;} public: int _publInt = 0; int publFunc() { return privVirtFunc(); } }; class B : public A { private: virtual int privVirtFunc(){return 1;} public: void func() { _privInt = 1; _protInt = 1; _publInt = 1; privFunc(); privVirtFunc(); protFunc(); publFunc(); } }
class Bad { public: // ~Bad() noexcept(false) { throw 1; } }; class Bad2 { public: ~Bad2() { throw 1; } }; int main(int argc, char* argv[]) { try { Bad bad; } catch(...) { std::cout << "Print This\n"; } try { if (argc > 3) { Bad bad; throw 2; } else { Bad2 bad; } } catch(...) { std::cout << "Never print this\n"; } }
class Object { Object2 obj2; Object3* obj3; virtual ~Object() { delete obj3; } };
class Socket { virtual ~Socket() { try { Close(); } catch (...) { } } };
class TempFile { public: TempFile(); ~TempFile() throw(); void close(); };
class MyType { public: ~MyType() { throw Exception(); } };
if(check()) { ... ... if(check()) { ... ... if(check()) { ... ... } } }
do { if(!check()) break; ... ... if(!check()) break; ... ... if(!check()) break; ... ... } while(0);
void foo(...) { if (!condition) { return; } ... if (!other condition) { return; } ... if (!another condition) { return; } ... if (!yet another condition) { return; } ... }
void func() { setup of lots of stuff ... if (condition) { ... ... if (!other condition) { ... if (another condition) { ... if (yet another condition) { ... if (...) ... } } } .... } finish up. }
void func() { setup of lots of stuff ... if (!condition) { goto finish; } ... ... if (other condition) { goto finish; } ... if (!another condition) { goto finish; } ... if (!yet another condition) { goto finish; } ... .... if (...) ... finish: finish up. }
bool goOn; if ((goOn = check0())) { ... } if (goOn && (goOn = check1())) { ... } if (goOn && (goOn = check2())) { ... } if (goOn && (goOn = check3())) { ... }
error_code_type c_to_refactor(result_type *r) { error_code_type result = error_ok; some_resource r1, r2; if(error_ok != (result = computation1(&r1))) goto cleanup; if(error_ok != (result = computation2(&r2))) goto cleanup; *r = computed_value_n; cleanup: free_resource1(r1); free_resource2(r2); return result; }
result_type cpp_code() { raii_resource1 r1 = computation1(); raii_resource2 r2 = computation2(); return computed_value_n; }
earlier operations ... [&]()->void { if (!check()) return; ... ... if (!check()) return; ... ... if (!check()) return; ... ... }(); later operations
do { if(!check()) break; ... ... if(!check()) break; ... ... if(!check()) break; ... ... } while(0);
switch (0) { case 0: if(!check()) break; ... ... if(!check()) break; ... ... if(!check()) break; ... ... }
BLOC { if(!check()) break; ... ... if(!check()) break; ... ... if(!check()) break; ... ... }
void main() { func(); } void func() { if (!condition) return; ... if (!other condition) return; ... if (!another condition) return; ... if (!yet another condition) return; ... }
BEGIN_TEST if(!condition1) break; if(!condition2) break; if(!condition3) break; if(!condition4) break; if(!condition5) break; END_TEST
{ if(!condition1) goto end_blahblah; if(!condition2) goto end_blahblah; if(!condition3) goto end_blahblah; if(!condition4) goto end_blahblah; if(!condition5) goto end_blahblah; }end_blah_blah:;
BEGIN_TEST if(!condition1) FAILED(NormalizeData); if(!condition2) FAILED(NormalizeData); if(!condition3) FAILED(NormalizeData); if(!condition4) FAILED(NormalizeData); if(!condition5) FAILED(NormalizeData); END_TEST(NormalizeData)
BEGIN_TEST if(!condition1) FAILED(NormalizeData); if(!condition2) FAILED(NormalizeData); BEGIN_TEST if(!conditionAA) FAILED(DecryptBlah); if(!conditionBB) FAILED(NormalizeData); if(!conditionCC) FAILED(DecryptBlah); END_TEST(DecryptBlah) if(!condition3) FAILED(NormalizeData); if(!condition4) FAILED(NormalizeData); BEGIN_TEST if(!conditionA) FAILED(TrimSpaces); if(!conditionB) FAILED(TrimSpaces); if(!conditionC) FAILED(NormalizeData); if(!conditionD) FAILED(TrimSpaces); END_TEST(TrimSpaces) if(!condition5) FAILED(NormalizeData); END_TEST(NormalizeData)
if (check()) { doStuff(); } if (stillOk()) { doMoreStuff(); } if (amIStillReallyOk()) { doEvenMore(); } doThingsAtEndAndReportErrorStatus()
bool goOn = check0(); if (goOn) { ... goOn = check1(); } if (goOn) { ... goOn = check2(); } if (goOn) { ... }
int main () { try { if (!condition) throw std::runtime_error("nope."); ... if (!other condition) throw std::runtime_error("nope again."); ... if (!another condition) throw std::runtime_error("told you."); ... if (!yet another condition) throw std::runtime_error("OK, just forget it..."); } catch (std::runtime_error &e) { std::cout << e.what() << std::endl; } catch (...) { std::cout << "Caught an unknown exception\n"; } return 0; }
boost::optional<EnabledContext> enabled(boost::optional<Context> context); boost::optional<EnergisedContext> energised(boost::optional<EnabledContext> context);
struct Context { std::string coordinates_filename; }; struct EnabledContext { int x; int y; int z; }; boost::optional<EnabledContext> enabled(boost::optional<Context> c) { if (!c) return boost::none; if (!exists((*c).coordinates_filename)) return boost::none; EnabledContext ec; std::ifstream file_in((*c).coordinates_filename.c_str()); file_in >> ec.x >> ec.y >> ec.z; return boost::optional<EnabledContext>(ec); }
Context context("planet_surface.txt", ...); boost::optional<EnergisedContext> result(energised(enabled(context))); if (result) { } else { }
int ConditionCode (void) { if (condition1) return 1; if (condition2) return 2; ... return 0; } void MyFunc (void) { switch (ConditionCode ()) { case 1: ... break; case 2: ... break; ... default: ... break; } }
if (conditionA) { .... if (conditionB) { .... if (conditionC) { myLogic(); } } }
if (conditionA) { .... if (!conditionB) { return; } if (!conditionD) { return; } if (conditionC) { myLogic(); } }
if (conditionA) { isA = true; .... } if (isA && conditionB) { isB = true; ... } if (isB && conditionC) { isC = true; myLogic(); }
typedef bool (*Checker)(); Checker * checkers[]={ &checker0,&checker1,.....，&checkerN,NULL }; bool checker1(){ if(condition){ ..... ..... return true; } return false; } bool checker2(){ if(condition){ ..... ..... return true; } return false; } ...... void doCheck(){ Checker ** checker = checkers; while( *checker && (*checker)()) checker++; }
private ResultCode DoEverything() { ResultCode processResult = ResultCode.FAILURE; if (DoStep1() != ResultCode.SUCCESSFUL) { Step1FailureCleanup(); } else if (DoStep2() != ResultCode.SUCCESSFUL) { Step2FailureCleanup(); processResult = ResultCode.SPECIFIC_FAILURE; } else if (DoStep3() != ResultCode.SUCCESSFUL) { Step3FailureCleanup(); } ... else { processResult = ResultCode.SUCCESSFUL; } return processResult; }
void func() { if (!check()) return; ... ... if (!check()) return; ... ... if (!check()) return; ... ... }
struct Bar { Bar(); }; extern bool check(); void foo() { if (!check()) goto out; Bar x; out: }
bool calc1() { if (!check()) return false; if (!calc2()) { return false; } return true; } bool calc2() { if (!check()) return false; if (!calc3()) { return false; } return true; }
do { if(!check()) break; ... ... if(!check()) break; ... ... if(!check()) break; ... ... } while(0); finishingUpStuff.
finish(params) { ... ... } if(!check()){ finish(params); return; } ... ... if(!check()){ finish(params); return; } ... ... if(!check()){ finish(params); return; } ... ...
if( condition && other_condition && another_condition && yet_another_condition && ... ) { if (final_cond){ } else { } }
if( DoSomething() && DoSomethingElse() && DoAThirdThing() ) { } else { }
long var = 0; if(condition) flag a bit in var if(condition) flag another bit in var if(condition) flag another bit in var ............ if(var == certain number) { Do the required task }
std::string str = "Hello World"; boost::to_upper(str); std::string newstr = boost::to_upper_copy<std::string>("Hello World");
std::string str = "Hello World"; std::transform(str.begin(), str.end(),str.begin(), ::toupper);
struct convert { void operator()(char& c) { c = toupper((unsigned char)c); } }; string uc_str; for_each(uc_str.begin(), uc_str.end(), convert());
string StringToUpper(string strToConvert) { for (std::string::iterator p = strToConvert.begin(); strToConvert.end() != p; ++p) *p = toupper(*p); return p; }
string StringToUpper(string strToConvert) { std::transform(strToConvert.begin(), strToConvert.end(), strToConvert.begin(), ::toupper); return strToConvert; }
32.87% flipcase-clang- libstdc++.so.6.0.21 [.] _ZNK10__cxxabiv121__vmi_class_type_info12__do_dyncastElNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16 21.90% flipcase-clang- libstdc++.so.6.0.21 [.] __dynamic_cast 16.06% flipcase-clang- libc-2.21.so [.] __GI___strcmp_ssse3 8.16% flipcase-clang- libstdc++.so.6.0.21 [.] _ZSt9use_facetISt5ctypeIcEERKT_RKSt6locale 7.84% flipcase-clang- flipcase-clang-boost [.] _Z16strtoupper_boostPcRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE 2.20% flipcase-clang- libstdc++.so.6.0.21 [.] strcmp@plt 2.15% flipcase-clang- libstdc++.so.6.0.21 [.] __dynamic_cast@plt 2.14% flipcase-clang- libstdc++.so.6.0.21 [.] _ZNKSt6locale2id5_M_idEv 2.11% flipcase-clang- libstdc++.so.6.0.21 [.] _ZNKSt6locale2id5_M_idEv@plt 2.08% flipcase-clang- libstdc++.so.6.0.21 [.] _ZNKSt5ctypeIcE10do_toupperEc 2.03% flipcase-clang- flipcase-clang-boost [.] _ZSt9use_facetISt5ctypeIcEERKT_RKSt6locale@plt 0.08% ...
char ascii_toupper_char(char c) { return ( } size_t strtoupper_autovec(char *dst, const char *src) { size_t len = strlen(src); for (size_t i=0 ; i<len ; ++i) { dst[i] = ascii_toupper_char(src[i]); } return len; }
__m128i upcase_si128(__m128i src) { __m128i rangeshift = _mm_sub_epi8(src, _mm_set1_epi8( __m128i nomodify = _mm_cmpgt_epi8(rangeshift, _mm_set1_epi8(-128 + 25)); __m128i flip = _mm_andnot_si128(nomodify, _mm_set1_epi8(0x20)); return _mm_xor_si128(src, flip); }
size_t strtoupper_sse2(char *dst, const char *src_begin) { const char *src = src_begin; while ( (0xf & (uintptr_t)src) && *src ) { *(dst++) = ascii_toupper(*(src++)); } if (!*src) return src - src_begin; int zero_positions; do { __m128i sv = _mm_load_si128( (const __m128i*)src ); __m128i nullcheck = _mm_cmpeq_epi8(_mm_setzero_si128(), sv); zero_positions = _mm_movemask_epi8(nullcheck); if (zero_positions) break; __m128i upcased = upcase_si128(sv); _mm_storeu_si128((__m128i*)dst, upcased); src += 16; dst += 16; } while(1); unsigned int cleanup_bytes = ffs(zero_positions) - 1; const char* last_byte = src + cleanup_bytes; if (cleanup_bytes > 0) { if (last_byte - src_begin >= 16) { __m128i sv = _mm_loadu_si128( (const __m128i*)(last_byte-15) ); _mm_storeu_si128((__m128i*)(dst + cleanup_bytes - 15), upcase_si128(sv)); } else { for (unsigned int i = 0 ; i <= cleanup_bytes ; ++i) { dst[i] = ascii_toupper(src[i]); } for (int i = cleanup_bytes - 1 ; i >= 0 ; --i) { dst[i] = ascii_toupper(src[i]); } } } return last_byte - src_begin; }
std::string s("change my case"); auto to_upper = [] (char_t ch) { return std::use_facet<std::ctype<char_t>>(std::locale()).toupper(ch); }; std::transform(s.begin(), s.end(), s.begin(), to_upper);
void toUpperCase(std::string& str) { std::transform(str.begin(), str.end(), str.begin(), ::toupper); } int main() { std::string str = "hello"; toUpperCase(&str); }
std::string toupper(const std::string & s) { std::string ret(s.size(), char()); for(unsigned int i = 0; i < s.size(); ++i) ret[i] = (s[i] <= return ret; }
void strtoupper(char* str) { while (*str) *(str++) = toupper((unsigned char)*str); }
std::string str = "Hello World!"; auto & f = std::use_facet<std::ctype<char>>(std::locale()); f.toupper(str.data(), str.data() + str.size());
std::use_facet<std::ctype<char> > & f = std::use_facet<std::ctype<char> >(std::locale()); f.toupper(const_cast<char *>(str.data()), str.data() + str.size());
typedef std::string::value_type char_t; char_t up_char( char_t ch ) { return std::use_facet< std::ctype< char_t > >( std::locale() ).toupper( ch ); } std::string toupper( const std::string &src ) { std::string result; std::transform( src.begin(), src.end(), std::back_inserter( result ), up_char ); return result; } const std::string src = "test test TEST"; std::cout << toupper( src );
std::string value; for (std::string::iterator p = value.begin(); value.end() != p; ++p) *p = toupper(*p);
std::string cmd = "Hello World"; for_each(cmd.begin(), cmd.end(), [](char& in){ in = ::toupper(in); });
string StringToUpper(string strToConvert) { for(unsigned int i=0;i<strToConvert.length();i++) { strToConvert[i] = toupper(strToConvert[i]); } return strToConvert; } string StringToLower(string strToConvert) { for(unsigned int i=0;i<strToConvert.length();i++) { strToConvert[i] = tolower(strToConvert[i]); } return strToConvert; }
inline void toupper(char* str) { while (str[i]) { if (islower(str[i])) str[i] &= ~32; i++; } }
RegName = "SomE StRing That you wAnt ConvErTed"; NameLength = RegName.Size(); for (int forLoop = 0; forLoop < NameLength; ++forLoop) { RegName[forLoop] = tolower(RegName[forLoop]); }
std::string YourClass::Uppercase(const std::string & Text) { std::string UppperCaseString; UppperCaseString.reserve(Text.size()); for (std::string::const_iterator it=Text.begin(); it<Text.end(); ++it) { UppperCaseString.push_back(((0x60 < *it) && (*it < 0x7B)) ? (*it - static_cast<char>(0x20)) : *it); } return UppperCaseString; }
template<int ...Is> struct IntVector{ using Type = IntVector<Is...>; }; template<typename T_Vector, int I_New> struct PushFront; template<int ...Is, int I_New> struct PushFront<IntVector<Is...>,I_New> : IntVector<I_New,Is...>{}; template<int I_Size, typename T_Vector = IntVector<>> struct Iota : Iota< I_Size-1, typename PushFront<T_Vector,I_Size-1>::Type> {}; template<typename T_Vector> struct Iota<0,T_Vector> : T_Vector{}; template<char C_In> struct ToUpperTraits { enum { value = (C_In >= }; template<typename T> struct TableToUpper; template<int ...Is> struct TableToUpper<IntVector<Is...>>{ static char at(const char in){ static const char table[] = {ToUpperTraits<Is>::value...}; return table[in]; } }; int tableToUpper(const char c){ using Table = TableToUpper<typename Iota<256>::Type>; return Table::at(c); }
std::transform(in.begin(),in.end(),out.begin(),tableToUpper);
template<size_t size> char* toupper(char (&dst)[size], const char* src) { static char maptable[256]; static bool mapped; if (!mapped) { for (char c = 0; c < 256; c++) { if (c >= maptable[c] = c & 0xdf; else maptable[c] = c; } mapped = true; } for (int i = 0; *src && i < size; i++) { dst[i] = maptable[*(src++)]; } return dst; }
using namespace std; string toUpper (string str){ locale loc; string n; for (string::size_type i=0; i<str.length(); ++i) n += toupper(str[i], loc); return n; }
void to_upper(const std::string str) { std::string::iterator it; int i; for ( i=0;i<str.size();++i ) { ((char *)(void *)str.data())[i]=toupper(((char *)str.data())[i]); } }
string Utils::String::UpperCase(string CaseString) { for (unsigned short i = 0, tamanho = CaseString.length(); i < tamanho; i++) { switch (CaseString[i]) { case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; case CaseString[i] = break; } } return CaseString; }
float r = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
float r2 = static_cast <float> (rand()) / (static_cast <float> (RAND_MAX/X));
float r3 = LO + static_cast <float> (rand()) /( static_cast <float> (RAND_MAX/(HI-LO)));
int main() { std::random_device rd; // // std::mt19937 e2(rd()); // // std::uniform_real_distribution<> dist(0, 10); std::map<int, int> hist; for (int n = 0; n < 10000; ++n) { ++hist[std::floor(dist(e2))]; } for (auto p : hist) { std::cout << std::fixed << std::setprecision(1) << std::setw(2) << p.first << } }
0 **** 1 **** 2 **** 3 **** 4 ***** 5 **** 6 ***** 7 **** 8 ***** 9 ****
-6 -5 -4 -3 -2 ** -1 **** 0 ******* 1 ********* 2 ********* 3 ******* 4 **** 5 ** 6 7 8 9
std::default_random_engine & global_urng( ) { static std::default_random_engine u{}; return u ; } void randomize( ) { static std::random_device rd{}; global_urng().seed( rd() ); } int main( ) { using card = int; std::array<card,52> deck{}; std::iota(deck.begin(), deck.end(), 0); randomize( ) ; std::shuffle(deck.begin(), deck.end(), global_urng()); auto suit = []( card c ) { return "SHDC"[c / 13]; }; auto rank = []( card c ) { return "AKQJT98765432"[c % 13]; }; for( card c : deck ) std::cout << std::cout << std::endl; }
int main() { boost::random::mt19937 gen; boost::random::uniform_real_distribution<> dist(0, 10); std::map<int, int> hist; for (int n = 0; n < 10000; ++n) { ++hist[std::floor(dist(gen))]; } for (auto p : hist) { std::cout << std::fixed << std::setprecision(1) << std::setw(2) << p.first << } }
double randZeroToOne() { return rand() / (RAND_MAX + 1.); }
double randMToN(double M, double N) { return M + (rand() / ( RAND_MAX / (N-M) ) ) ; }
float gen_random_float(float min, float max) { boost::mt19937 rng; boost::uniform_real<float> u(min, max); boost::variate_generator<boost::mt19937&, boost::uniform_real<float> > gen(rng, u); return gen(); }
float rand_FloatRange(float a, float b) { return ((b - a) * ((float)rand() / RAND_MAX)) + a; }
... std::tr1::mt19937 eng; std::tr1::normal_distribution<float> dist; for (int i = 0; i < 10; ++i) std::cout << dist(eng) << std::endl;
float get_random() { static std::default_random_engine e; static std::uniform_real_distribution<> dis(0, 1); return dis(e); }
int main() { std::vector<float> nums; for (int i{}; i != 5; ++i) nums.emplace_back(get_random()); for (const auto& i : nums) std::cout << i << " "; }
float r = (float)((rand() << 15 + rand()) & ((1 << 24) - 1)) / (1 << 24);
float rnd(void){ unsigned int ret = 0x3F000000 | (0x7FFFFF & ((rand() << 8) ^ rand())); unsigned short coinFlips; if( coinFlips & 1 ) break; \ coinFlips >>= 1; \ ret -= 0x800000 for(;;){ coinFlips = rand(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); if( ! (ret & 0x3F800000) ) return 0.0f; RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); RND_INNER_LOOP(); } return *((float *)(&ret)); }
int tmp = rand(); float f = (float)*((float*)&tmp);
int tmp = rand(); float f = *((float*)&tmp); tmp = (unsigned int)f tmp %= max_number; f -= tmp;
/** * Function generates a random float using the upper_bound float to determine * the upper bound for the exponent and for the fractional part. * @param min_exp sets the minimum number (closest to 0) to 1 * e^min_exp (min -127) * @param max_exp sets the maximum number to 2 * e^max_exp (max 126) * @param sign_flag if sign_flag = 0 the random number is always positive, if * sign_flag = 1 then the sign bit is random as well * @return a random float */ float randf(int min_exp, int max_exp, char sign_flag) { assert(min_exp <= max_exp); int min_exp_mod = min_exp + 126; int sign_mod = sign_flag + 1; int frac_mod = (1 << 23); int s = rand() % sign_mod; int e = (rand() % max_exp) + min_exp_mod; int f = rand() % frac_mod; int tmp = (s << 31) | (e << 23) | f; float r = (float)*((float*)(&tmp)); /** uncomment if you want to see the structure of the float. */ return r; }
float rand_float() { uint32_t pattern = 0x3f800000; uint32_t random23 = 0x7fffff & (rand() << 8 ^ rand()); pattern |= random23; assert(sizeof(float) == sizeof(uint32_t)); char buffer[sizeof(float)]; memcpy(buffer, &pattern, sizeof(float)); float f; memcpy(&f, buffer, sizeof(float)); return f - 1.0; }
using namespace std; typedef std::tr1::ranlux64_base_01 Myeng; typedef std::tr1::normal_distribution<double> Mydist; int main() { Myeng eng; eng.seed((unsigned int) time(NULL)); Mydist dist(1,10); dist.reset(); for (int i = 0; i < 10; i++) { std::cout << "a random value == " << (int)dist(eng) << std::endl; } return (0); }
class Type; void swap( Type & a, Type & b ) { Type tmp = a; a = b; b = tmp; } int main() { Type a, b; Type old_a = a, old_b = b; swap( a, b ); assert( a == old_b ); assert( b == old_a ); }
public class C { public static void swap( C a, C b ) { C tmp = a; a = b; b = tmp; } public static void main( String args[] ) { C a = new C(); C b = new C(); C old_a = a; C old_b = b; swap( a, b ); } }
void modifies(T *param=0); void modifies(); void modifies(T &param);
void uses(T const *param=0); void uses(); void uses(T const &param);
void f(int); void f(int const) { } typedef void NC(int); typedef void C(int const); NC *nc = &f; C *c = nc;
void func (string* str, ) { if (str != NULL) { *str = some_value; } }
Class CPlusPlusJavaFunctionality { public: CPlusPlusJavaFunctionality(){ attribute = new int; *attribute = value; } void setValue(int value){ *attribute = value; } void getValue(){ return *attribute; } ~ CPlusPlusJavaFuncitonality(){ delete(attribute); } private: int *attribute; } void changeObjectAttribute(CPlusPlusJavaFunctionality obj, int value){ int* prt = obj.attribute; *ptr = value; } int main(){ CPlusPlusJavaFunctionality obj; obj.setValue(10); cout<< obj.getValue(); changeObjectAttribute(obj, 15); cout<< obj.getValue(); }
class Sample { public: int *ptr; int mVar; Sample(int i) { mVar = 4; ptr = new int(i); } ~Sample() { delete ptr; } void PrintVal() { cout << "The value of the pointer is " << *ptr << endl << "The value of the variable is " << mVar; } }; void SomeFunc(Sample x) { cout << "Say i am in someFunc " << endl; } int main() { Sample s1= 10; SomeFunc(s1); s1.PrintVal(); char ch; cin >> ch; }
void foo(const int &x) { x = 6; } void foo(const int &x) { x = 6; }
class abc { display() { cout<<"Class abc"; } } void show(abc S) { cout<<S.display(); } void show(abc& S) { cout<<S.display(); }
struct MyClass { enum class MyEnum : char { AAA = -8, BBB = CCC = AAA + BBB }; }; const char* magic (MyClass::MyEnum e) { const std::map<MyClass::MyEnum,const char*> MyEnumStrings { { MyClass::MyEnum::AAA, "MyClass::MyEnum::AAA" }, { MyClass::MyEnum::BBB, "MyClass::MyEnum::BBB" }, { MyClass::MyEnum::CCC, "MyClass::MyEnum::CCC" } }; auto it = MyEnumStrings.find(e); return it == MyEnumStrings.end() ? "Out of range" : it->second; } int main() { std::cout << magic(MyClass::MyEnum::AAA) << std::cout << magic(MyClass::MyEnum::BBB) << std::cout << magic(MyClass::MyEnum::CCC) << }
DECLARE_ENUM_WITH_TYPE(TestEnumClass, int32_t, ZERO = 0x00, TWO = 0x02, ONE = 0x01, THREE = 0x03, FOUR);
std::vector<std::string> splitString(std::string str, char sep = std::vector<std::string> vecString; std::string item; std::stringstream stringStream(str); while (std::getline(stringStream, item, sep)) { vecString.push_back(item); } return vecString; } enum class E : T \ { \ __VA_ARGS__ \ }; \ std::map<T, std::string> E std::ostream &operator<<(std::ostream &os, E enumTmp) \ { \ os << E return os; \ } \ size_t operator*(E enumTmp) { (void) enumTmp; return E std::string operator~(E enumTmp) { return E std::string operator+(std::string &&str, E enumTmp) { return str + E std::string operator+(E enumTmp, std::string &&str) { return E std::string &operator+=(std::string &str, E enumTmp) \ { \ str += E return str; \ } \ E operator++(E &enumTmp) \ { \ auto iter = E if (iter == E iter = E else \ { \ ++iter; \ } \ enumTmp = static_cast<E>(iter->first); \ return enumTmp; \ } \ bool valid template <typename T> std::map<T, std::string> generateEnumMap(std::string strMap) { STRING_REMOVE_CHAR(strMap, STRING_REMOVE_CHAR(strMap, std::vector<std::string> enumTokens(splitString(strMap)); std::map<T, std::string> retMap; T inxMap; inxMap = 0; for (auto iter = enumTokens.begin(); iter != enumTokens.end(); ++iter) { std::string enumName; T enumValue; if (iter->find( { enumName = *iter; } else { std::vector<std::string> enumNameValue(splitString(*iter, enumName = enumNameValue[0]; if (std::is_unsigned<T>::value) { inxMap = static_cast<T>(std::stoull(enumNameValue[1], 0, 0)); } else { inxMap = static_cast<T>(std::stoll(enumNameValue[1], 0, 0)); } } retMap[inxMap++] = enumName; } return retMap; }
DECLARE_ENUM_WITH_TYPE(TestEnumClass, int32_t, ZERO = 0x00, TWO = 0x02, ONE = 0x01, THREE = 0x03, FOUR); int main(void) { TestEnumClass first, second; first = TestEnumClass::FOUR; second = TestEnumClass::TWO; std::cout << first << "(" << static_cast<uint32_t>(first) << ")" << std::endl; std::string strOne; strOne = ~first; std::cout << strOne << std::endl; std::string strTwo; strTwo = ("Enum-" + second) + (TestEnumClass::THREE + "-test"); std::cout << strTwo << std::endl; std::string strThree("TestEnumClass: "); strThree += second; std::cout << strThree << std::endl; std::cout << "Enum count=" << *first << std::endl; }
Channel c = Channel::_from_string("Green"); c._to_string(); for (Channel c : Channel::_values()) std::cout << c << std::endl;
struct Channel { enum _enum : char { __VA_ARGS__ }; constexpr static const Channel _values[] = { __VA_ARGS__ }; constexpr static const char * const _names[] = { static const char* _to_string(Channel v) { } constexpr static Channel _from_string(const char *s) { } };
IDENTITY( \ APPLY(CHOOSE_MAP_START, COUNT(__VA_ARGS__)) \ (macro, __VA_ARGS__)) count IDENTITY(EVALUATE_COUNT(__VA_ARGS__, 8, 7, 6, 5, 4, 3, 2, 1)) template <typename U> struct ignore_assign { constexpr explicit ignore_assign(U value) : _value(value) { } constexpr operator U() const { return _value; } constexpr const ignore_assign& operator =(int dummy) const { return *this; } U _value; }; IDENTITY(MAP(IGNORE_ASSIGN_SINGLE, __VA_ARGS__)) constexpr const char terminators[] = " =\t\r\n"; constexpr bool is_terminator(char c, size_t index = 0) { return index >= sizeof(terminators) ? false : c == terminators[index] ? true : is_terminator(c, index + 1); } constexpr bool matches_untrimmed(const char *untrimmed, const char *s, size_t index = 0) { return is_terminator(untrimmed[index]) ? s[index] == s[index] != untrimmed[index] ? false : matches_untrimmed(untrimmed, s, index + 1); } // // // // // namespace data_ using _underlying = Underlying; \ enum { __VA_ARGS__ }; \ \ constexpr const size_t _size = \ IDENTITY(COUNT(__VA_ARGS__)); \ \ constexpr const _underlying _values[] = \ { IDENTITY(IGNORE_ASSIGN(__VA_ARGS__)) }; \ \ constexpr const char * const _raw_names[] = \ { IDENTITY(STRINGIZE(__VA_ARGS__)) }; \ } \ \ struct EnumName { \ using _underlying = Underlying; \ enum _enum : _underlying { __VA_ARGS__ }; \ \ const char * _to_string() const \ { \ for (size_t index = 0; index < data_ ++index) { \ \ if (data_ return _trimmed_names()[index]; \ } \ \ throw std::runtime_error("invalid value"); \ } \ \ constexpr static EnumName _from_string(const char *s, \ size_t index = 0) \ { \ return \ index >= data_ throw std::runtime_error("invalid identifier") : \ matches_untrimmed( \ data_ (EnumName)(_enum)data_ index] : \ _from_string(s, index + 1); \ } \ \ EnumName() = delete; \ constexpr EnumName(_enum value) : _value(value) { } \ constexpr operator _enum() const { return (_enum)_value; } \ \ private: \ _underlying _value; \ \ static const char * const * _trimmed_names() \ { \ static char *the_names[data_ static bool initialized = false; \ \ if (!initialized) { \ for (size_t index = 0; index < data_ ++index) { \ \ size_t length = \ std::strcspn(data_ terminators); \ \ the_names[index] = new char[length + 1]; \ \ std::strncpy(the_names[index], \ data_ length); \ the_names[index][length] = } \ \ initialized = true; \ } \ \ return the_names; \ } \ };
ENUM(Channel, char, Red = 1, Green, Blue) constexpr Channel channel = Channel::_from_string("Red"); int main() { std::cout << channel._to_string() << std::endl; switch (channel) { case Channel::Red: return 0; case Channel::Green: return 1; case Channel::Blue: return 2; } } static_assert(sizeof(Channel) == sizeof(char), "");
meta::get_base_name_v< meta::get_element_m< meta::get_enumerators_m<reflexpr(MyEnum)>, 0> >
enum MyEnum { AAA = 1, BBB, CCC = 99 }; int main() { auto name_of_MyEnum_0 = std::meta::get_base_name_v< std::meta::get_element_m< std::meta::get_enumerators_m<reflexpr(MyEnum)>, 0> >; std::cout << name_of_MyEnum_0 << std::endl; }
enum class EtherType : uint16_t { ARP = 0x0806, IPv4 = 0x0800, VLAN = 0x8100, IPv6 = 0x86DD };
std::ostream& operator<< (std::ostream& os, EtherType ethertype) { switch (ethertype) { case EtherType::ARP : return os << "ARP" ; case EtherType::IPv4: return os << "IPv4"; case EtherType::VLAN: return os << "VLAN"; case EtherType::IPv6: return os << "IPv6"; }; return os << static_cast<std::uint16_t>(ethertype); }
enum class MyEnum : std::uint_fast8_t { AAA, BBB, CCC, }; template<MyEnum> const char MyEnumName[] = "Invalid MyEnum value"; template<> const char MyEnumName<MyEnum::AAA>[] = "AAA"; template<> const char MyEnumName<MyEnum::BBB>[] = "BBB"; template<> const char MyEnumName<MyEnum::CCC>[] = "CCC"; int main() { std::cout << MyEnumName<MyEnum::AAA> << std::cout << MyEnumName<static_cast<MyEnum>(0x12345678)> << return 0; }
template <typename ENUM> using enum_map = std::map<ENUM, const std::string>; template <typename ENUM> enum_map<ENUM> enum_values{};
template <typename ENUM> void initialize() {} template <typename ENUM, typename ... args> void initialize(const ENUM value, const char *name, args ... tail) { enum_values<ENUM>.emplace(value, name); initialize<ENUM>(tail ...); }
initialize ( MyEnum::AAA, "AAA", MyEnum::BBB, "BBB", MyEnum::CCC, "CCC" );
template<typename ENUM, class = typename std::enable_if<std::is_enum<ENUM>::value>::type> std::ostream &operator <<(std::ostream &o, const ENUM value) { static const std::string Unknown{std::string{typeid(ENUM).name()} + " unknown value"}; auto found = enum_values<ENUM>.find(value); return o << (found == enum_values<ENUM>.end() ? Unknown : found->second); }
std::string ToString(MyEnum value) { switch( value ) { } return ""; } MyEnum FromString(std::string const& value) { static std::map<std::string,MyEnum> converter { }; auto it = converter.find(value); if( it != converter.end() ) return it->second; else throw std::runtime_error("Value is missing"); }
enum2str_generate( PATH <path to place the files in> CLASS_NAME <name of the class (also prefix for the files)> FUNC_NAME <name of the (static) member function> NAMESPACE <the class will be inside this namespace> INCLUDES <LIST of files where the enums are defined> ENUMS <LIST of enums to process> BLACKLIST <LIST of constants to ignore> USE_CONSTEXPR <whether to use constexpr or not (default: off)> USE_C_STRINGS <whether to use c strings instead of std::string or not (default: off)> )
enum AAA : char { A1, A2 }; typedef enum { VAL1 = 0, VAL2 = 1, VAL3 = 2, VAL_FIRST = VAL1, VAL_LAST = VAL3, VAL_DUPLICATE = 1, VAL_STRANGE = VAL2 + 1 } BBB;
include_directories( ${PROJECT_SOURCE_DIR}/includes ...) enum2str_generate( PATH "${PROJECT_SOURCE_DIR}" CLASS_NAME "enum2Str" NAMESPACE "abc" FUNC_NAME "toStr" INCLUDES "a.h" ENUMS "AAA" "BBB" BLACKLIST "VAL_STRANGE")
/*! * \file enum2Str.hpp * \warning This is an automatically generated file! */ namespace abc { class enum2Str { public: static std::string toStr( AAA _var ) noexcept; static std::string toStr( BBB _var ) noexcept; }; }
/*! * \file enum2Str.cpp * \warning This is an automatically generated file! */ namespace abc { /*! * \brief Converts the enum AAA to a std::string * \param _var The enum value to convert * \returns _var converted to a std::string */ std::string enum2Str::toStr( AAA _var ) noexcept { switch ( _var ) { case A1: return "A1"; case A2: return "A2"; default: return "<UNKNOWN>"; } } /*! * \brief Converts the enum BBB to a std::string * \param _var The enum value to convert * \returns _var converted to a std::string */ std::string enum2Str::toStr( BBB _var ) noexcept { switch ( _var ) { case VAL1: return "VAL1"; case VAL2: return "VAL2"; case VAL3: return "VAL3"; default: return "<UNKNOWN>"; } } }
namespace xxx { template<class T> struct enum_cast_adl_helper { }; template<class E> E enum_cast( const std::string& s ) { return do_enum_cast(s,enum_cast_adl_helper<E>()); } template<class E> E enum_cast( const char* cs ) { std::string s(cs); return enum_cast<E>(s); } } _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \ _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \ _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \ _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \ _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \ _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \ _61,_62,_63,N,...) N 63,62,61,60, \ 59,58,57,56,55,54,53,52,51,50, \ 49,48,47,46,45,44,43,42,41,40, \ 39,38,37,36,35,34,33,32,31,30, \ 29,28,27,26,25,24,23,22,21,20, \ 19,18,17,16,15,14,13,12,11,10, \ 9,8,7,6,5,4,3,2,1,0 BOOST_PP_APPLY( \ BOOST_PP_TUPLE_ELEM( \ 25, i, ( \ (0), (1), (2), (3), (4), (5), (6), (7), (8), \ (9), (10), (11), (12), (13), (14), (15), (16), \ (17), (18), (19), (20), (21), (22), (23), (24) \ ) ) ) enum TYPE \ { \ XXX_TUPLE_FOR_EACH(XXX_ENUM_ELEMENT,,TUPLE) \ BOOST_PP_CAT(last_enum_,NAME) \ }; \ \ inline \ const char* to_string( NAME en ) \ { \ if(false) \ { \ } \ XXX_TUPLE_FOR_EACH(XXX_ENUM_IFELSE,NAME,TUPLE) \ else if( en == NAME :: BOOST_PP_CAT(last_enum_,NAME) ) \ { \ return XXX_VSTRINGIZE(NAME,::,BOOST_PP_CAT(last_enum_,NAME)); \ } \ else \ { \ return "Invalid enum value specified for " } \ } \ \ inline \ std::ostream& operator<<( std::ostream& os, const NAME& en ) \ { \ os << to_string(en); \ return os; \ } \ \ inline \ NAME do_enum_cast( const std::string& s, const ::xxx::enum_cast_adl_helper<NAME>& ) \ { \ static const std::unordered_map<std::string,NAME> map = \ { \ XXX_TUPLE_FOR_EACH(XXX_ENUM_CASTLIST,NAME,TUPLE) \ XXX_TUPLE_FOR_EACH(XXX_ENUM_QUALIFIED_CASTLIST,NAME,TUPLE) \ }; \ \ auto cit = map.find(s); \ if( cit == map.end() ) \ { \ throw std::runtime_error("Invalid value to cast to enum"); \ } \ return cit->second; \ }
XXX_ENUM(foo,(a,b,(c,42))); int main() { std::cout << "foo::a = " << foo::a << std::cout << "(int)foo::c = " << (int)foo::c << std::cout << "to_string(foo::b) = " << to_string(foo::b) << std::cout << "xxx::enum_cast<foo>(\"b\") = " << xxx::enum_cast<foo>("b") << }
> g++ --version | sed 1q g++ (GCC) 4.9.2 > g++ -std=c++14 -pedantic -Wall -Wextra main.cpp main.cpp:268:31: warning: extra XXX_ENUM(foo,(a,b,(c,42))); ^
foo::a = foo::a (int)foo::c = 42 to_string(foo::b) = foo::b xxx::enum_cast<foo>("b") = foo::b
enum class Hallo { First = 5, Second = 6, Third = 7, Fourth = 8, Fifth = 11 }; std::ostream & operator << (std::ostream &, const Hallo&);
std::ostream & operator << (std::ostream &out, const Hallo&value) { switch(value) { case Hallo::First: out << "First"; break; case Hallo::Second: out << "Second"; break; case Hallo::Third: out << "Third"; break; case Hallo::Fourth: out << "Fourth"; break; case Hallo::Fifth: out << "Fifth"; break; default: out << "<unknown>"; } return out; }
package cppgen; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.nio.charset.Charset; import java.util.LinkedHashMap; import java.util.Map; import java.util.Map.Entry; import java.util.regex.Matcher; import java.util.regex.Pattern; public class EnumGenerator { static void fail(String message) { System.err.println(message); System.exit(1); } static void run(String[] args) throws Exception { Pattern pattern = Pattern.compile("\\s*(\\w+)\\s*(?:=\\s*(\\d+))?\\s*", Pattern.UNICODE_CHARACTER_CLASS); Charset charset = Charset.forName("UTF8"); String tab = " "; if (args.length != 3) { fail("Required arguments: <enum name> <input file> <output dir>"); } String enumName = args[0]; File inputFile = new File(args[1]); if (inputFile.isFile() == false) { fail("Not a file: [" + inputFile.getCanonicalPath() + "]"); } File outputDir = new File(args[2]); if (outputDir.isDirectory() == false) { fail("Not a directory: [" + outputDir.getCanonicalPath() + "]"); } File headerFile = new File(outputDir, enumName + ".h"); File codeFile = new File(outputDir, enumName + ".cpp"); for (File file : new File[] { headerFile, codeFile }) { if (file.exists()) { fail("Will not overwrite file [" + file.getCanonicalPath() + "]"); } } int nextValue = 0; Map<String, Integer> fields = new LinkedHashMap<>(); try ( BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(inputFile), charset)); ) { while (true) { String line = reader.readLine(); if (line == null) { break; } if (line.trim().length() == 0) { continue; } Matcher matcher = pattern.matcher(line); if (matcher.matches() == false) { fail("Syntax error: [" + line + "]"); } String fieldName = matcher.group(1); if (fields.containsKey(fieldName)) { fail("Double fiend name: " + fieldName); } String valueString = matcher.group(2); if (valueString != null) { int value = Integer.parseInt(valueString); if (value < nextValue) { fail("Not a monotonous progression from " + nextValue + " to " + value + " for enum field " + fieldName); } nextValue = value; } fields.put(fieldName, nextValue); ++nextValue; } } try ( PrintWriter headerWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(headerFile), charset)); PrintWriter codeWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(codeFile), charset)); ) { headerWriter.println(); headerWriter.println(" headerWriter.println(); headerWriter.println("enum class " + enumName); headerWriter.println( boolean first = true; for (Entry<String, Integer> entry : fields.entrySet()) { if (first == false) { headerWriter.println(","); } headerWriter.print(tab + entry.getKey() + " = " + entry.getValue()); first = false; } if (first == false) { headerWriter.println(); } headerWriter.println("};"); headerWriter.println(); headerWriter.println("std::ostream & operator << (std::ostream &, const " + enumName + "&);"); headerWriter.println(); codeWriter.println(); codeWriter.println(" codeWriter.println(); codeWriter.println(" codeWriter.println(); codeWriter.println("std::ostream & operator << (std::ostream &out, const " + enumName + "&value)"); codeWriter.println( codeWriter.println(tab + "switch(value)"); codeWriter.println(tab + first = true; for (Entry<String, Integer> entry : fields.entrySet()) { codeWriter.println(tab + "case " + enumName + "::" + entry.getKey() + codeWriter.println(tab + tab + "out << \"" + entry.getKey() + "\";"); codeWriter.println(tab + tab + "break;"); first = false; } codeWriter.println(tab + "default:"); codeWriter.println(tab + tab + "out << \"<unknown>\";"); codeWriter.println(tab + codeWriter.println(); codeWriter.println(tab + "return out;"); codeWriter.println( codeWriter.println(); } } public static void main(String[] args) { try { run(args); } catch(Exception exc) { exc.printStackTrace(); System.exit(1); } } }
import re import collections import sys import io import os def fail(*args): print(*args) exit(1) pattern = re.compile(r tab = " " if len(sys.argv) != 4: n=0 for arg in sys.argv: print("arg", n, ":", arg, " / ", sys.argv[n]) n += 1 fail("Required arguments: <enum name> <input file> <output dir>") enumName = sys.argv[1] inputFile = sys.argv[2] if not os.path.isfile(inputFile): fail("Not a file: [" + os.path.abspath(inputFile) + "]") outputDir = sys.argv[3] if not os.path.isdir(outputDir): fail("Not a directory: [" + os.path.abspath(outputDir) + "]") headerFile = os.path.join(outputDir, enumName + ".h") codeFile = os.path.join(outputDir, enumName + ".cpp") for file in [ headerFile, codeFile ]: if os.path.exists(file): fail("Will not overwrite file [" + os.path.abspath(file) + "]") nextValue = 0 fields = collections.OrderedDict() for line in open(inputFile, line = line.strip() if len(line) == 0: continue match = pattern.match(line) if match == None: fail("Syntax error: [" + line + "]") fieldName = match.group(1) if fieldName in fields: fail("Double field name: " + fieldName) valueString = match.group(2) if valueString != None: value = int(valueString) if value < nextValue: fail("Not a monotonous progression from " + nextValue + " to " + value + " for enum field " + fieldName) nextValue = value fields[fieldName] = nextValue nextValue += 1 headerWriter = open(headerFile, codeWriter = open(codeFile, try: headerWriter.write("\n") headerWriter.write(" headerWriter.write("\n") headerWriter.write("enum class " + enumName + "\n") headerWriter.write("{\n") first = True for fieldName, fieldValue in fields.items(): if not first: headerWriter.write(",\n") headerWriter.write(tab + fieldName + " = " + str(fieldValue)) first = False if not first: headerWriter.write("\n") headerWriter.write("};\n") headerWriter.write("\n") headerWriter.write("std::ostream & operator << (std::ostream &, const " + enumName + "&);\n") headerWriter.write("\n") codeWriter.write("\n") codeWriter.write(" codeWriter.write("\n") codeWriter.write(" codeWriter.write("\n") codeWriter.write("std::ostream & operator << (std::ostream &out, const " + enumName + "&value)\n") codeWriter.write("{\n") codeWriter.write(tab + "switch(value)\n") codeWriter.write(tab + "{\n") for fieldName in fields.keys(): codeWriter.write(tab + "case " + enumName + "::" + fieldName + ":\n") codeWriter.write(tab + tab + "out << \"" + fieldName + "\";\n") codeWriter.write(tab + tab + "break;\n") codeWriter.write(tab + "default:\n") codeWriter.write(tab + tab + "out << \"<unknown>\";\n") codeWriter.write(tab + "}\n") codeWriter.write("\n") codeWriter.write(tab + "return out;\n") codeWriter.write("}\n") codeWriter.write("\n") finally: headerWriter.close() codeWriter.close()
ENUM(Channel, int, Red, Green = 1, Blue) std::out << "My name is " << Channel::Green;
struct EnumSupportBase { static std::vector<std::string> split(const std::string s, char delim) { std::stringstream ss(s); std::string item; std::vector<std::string> tokens; while (std::getline(ss, item, delim)) { auto pos = item.find_first_of ( if (pos != std::string::npos) item.erase (pos); boost::trim (item); tokens.push_back(item); } return tokens; } }; enum class EnumName : Underlying { __VA_ARGS__, _count }; \ struct EnumName static inline std::vector<std::string> _token_names = split( static constexpr const char* get_name(EnumName enum_value) { \ int index = (int)enum_value; \ if (index >= (int)EnumName::_count || index < 0) \ return "???"; \ else \ return _token_names[index].c_str(); \ } \ }; \ inline std::ostream& operator<<(std::ostream& os, const EnumName & es) { \ return os << EnumName }
using namespace std; class static_string { const char* const p_; const std::size_t sz_; public: typedef const char* const_iterator; template <std::size_t N> constexpr static_string(const char(&a)[N]) noexcept : p_(a) , sz_(N - 1) {} constexpr static_string(const char* p, std::size_t N) noexcept : p_(p) , sz_(N) {} constexpr const char* data() const noexcept { return p_; } constexpr std::size_t size() const noexcept { return sz_; } constexpr const_iterator begin() const noexcept { return p_; } constexpr const_iterator end() const noexcept { return p_ + sz_; } constexpr char operator[](std::size_t n) const { return n < sz_ ? p_[n] : throw std::out_of_range("static_string"); } }; inline std::ostream& operator<<(std::ostream& os, static_string const& s) { return os.write(s.data(), s.size()); } template <class T> static_string typeName() { static_string p = __PRETTY_FUNCTION__; return static_string(p.data() + 30, p.size() - 30 - 1); static_string p = __FUNCSIG__; return static_string(p.data() + 37, p.size() - 37 - 7); } namespace details { template <class Enum> struct EnumWrapper { template < Enum enu > static static_string name() { static_string p = __PRETTY_FUNCTION__; static_string enumType = typeName<Enum>(); return static_string(p.data() + 73 + enumType.size(), p.size() - 73 - enumType.size() - 1); static_string p = __FUNCSIG__; static_string enumType = typeName<Enum>(); return static_string(p.data() + 57 + enumType.size(), p.size() - 57 - enumType.size() - 7); } }; } template <typename Enum, Enum enu> static_string enumName() { return details::EnumWrapper<Enum>::template name<enu>(); } enum class Color { Blue = 0, Yellow = 1 }; int main() { std::cout << "_" << typeName<Color>() << "_" << std::endl; std::cout << "_" << enumName<Color, Color::Blue>() << "_" << std::endl; return 0; }
enum MyEnum : int ETRAITS { EDECL(AAA) = -8, EDECL(BBB) = EDECL(CCC) = AAA + BBB };
for (MyEnum value : EnumTraits<MyEnum>::GetValues()) std::cout << EnumTraits<MyEnum>::GetName(value) << std::endl;
template <class ENUM> class EnumTraits { public: static const std::vector<ENUM>& GetValues() { return values; } static ENUM GetValue(const char* name) { auto match = valueMap.find(name); return (match == valueMap.end() ? ENUM() : match->second); } static const char* GetName(ENUM value) { auto match = nameMap.find(value); return (match == nameMap.end() ? nullptr : match->second); } public: EnumTraits() = delete; using vector_type = std::vector<ENUM>; using name_map_type = std::unordered_map<ENUM, const char*>; using value_map_type = std::unordered_map<std::string, ENUM>; private: static const vector_type values; static const name_map_type nameMap; static const value_map_type valueMap; }; struct EnumInitGuard{ constexpr const EnumInitGuard& operator=(int) const { return *this; } }; template <class T> constexpr T& operator<<=(T&& x, const EnumInitGuard&) { return x; }
using EnumType = ENUM_DEFINE; using TraitsType = EnumTraits<EnumType>; using VectorType = typename TraitsType::vector_type; using NameMapType = typename TraitsType::name_map_type; using ValueMapType = typename TraitsType::value_map_type; using NamePairType = typename NameMapType::value_type; using ValuePairType = typename ValueMapType::value_type;
namespace ns { enum MyEnum : int; } enum ns::MyEnum : int ETRAITS { EDECL(AAA) = -8, EDECL(BBB) = EDECL(CCC) = ns::MyEnum::AAA + ns::MyEnum::BBB }
struct X { \ enum Enum {BOOST_PP_SEQ_ENUM(SEQ)}; \ static const std::array<std::string,BOOST_PP_SEQ_SIZE(SEQ)> array_of_strings() { \ return {{BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(STRINGIZE, 0, SEQ))}}; \ } \ static std::string to_string(Enum e) { \ auto a = array_of_strings(); \ return a[static_cast<size_t>(e)]; \ } \ }
struct Color { enum Enum { RED, GREEN, BLUE }; Enum e; Color() {} Color(Enum e) : e(e) {} Color operator=(Enum o) { e = o; return *this; } Color operator=(Color o) { e = o.e; return *this; } bool operator==(Enum o) { return e == o; } bool operator==(Color o) { return e == o.e; } operator Enum() const { return e; } std::string toString() const { switch (e) { case Color::RED: return "red"; case Color::GREEN: return "green"; case Color::BLUE: return "blue"; default: return "unknown"; } } };
Color red; red = Color::RED; Color blue = Color::BLUE; cout << red.toString() << " " << Color::GREEN << " " << blue << endl;
struct Color { enum class Enum { RED, GREEN, BLUE }; static const Enum RED = Enum::RED, GREEN = Enum::GREEN, BLUE = Enum::BLUE; };
class Color { public: enum class Enum { RED, GREEN, BLUE }; static const Enum RED = Enum::RED, GREEN = Enum::GREEN, BLUE = Enum::BLUE; constexpr Color() : e(Enum::RED) {} constexpr Color(Enum e) : e(e) {} constexpr bool operator==(Enum o) const { return e == o; } constexpr bool operator==(Color o) const { return e == o.e; } constexpr operator Enum() const { return e; } Color& operator=(Enum o) { const_cast<Enum>(this->e) = o; return *this; } Color& operator=(Color o) { const_cast<Enum>(this->e) = o.e; return *this; } std::string toString() const { switch (e) { case Enum::RED: return "red"; case Enum::GREEN: return "green"; case Enum::BLUE: return "blue"; default: return "unknown"; } } private: const Enum e; };
template<typename KeyValue, typename ... RestOfKeyValues> struct map { static constexpr typename KeyValue::key_t get(const char* val) noexcept { if constexpr (sizeof...(RestOfKeyValues)==0) return KeyValue::key; else { static_assert(KeyValue::val != nullptr, "Only last element may have null name"); return strcmp(val, KeyValue::val()) ? map<RestOfKeyValues...>::get(val) : KeyValue::key; } } static constexpr const char* get(typename KeyValue::key_t key) noexcept { if constexpr (sizeof...(RestOfKeyValues)==0) return (KeyValue::val != nullptr) && (key == KeyValue::key) ? KeyValue::val() : ""; else return (key == KeyValue::key) ? KeyValue::val() : map<RestOfKeyValues...>::get(key); } }; template<typename Enum, typename ... KeyValues> class names { typedef map<KeyValues...> Map; public: static constexpr Enum get(const char* nam) noexcept { return Map::get(nam); } static constexpr const char* get(Enum key) noexcept { return Map::get(key); } };
enum class fasion { fancy, classic, sporty, emo, __last__ = emo, __unknown__ = -1 }; namespace name { NAME(fancy) NAME(classic) NAME(sporty) NAME(emo) } template<auto K, const char* (*V)()> struct _ { typedef decltype(K) key_t; typedef decltype(V) name_t; static constexpr key_t key = K; static constexpr name_t val = V; }; typedef names<fasion, _<fasion::fancy, name::fancy>, _<fasion::classic, name::classic>, _<fasion::sporty, name::sporty>, _<fasion::emo, name::emo>, _<fasion::__unknown__, nullptr> > fasion_names;
int main () { constexpr auto str = fasion_names::get(fasion::emo); constexpr auto fsn = fasion_names::get(str); return (int) fsn; }
std::vector<std::string> split(const std::string& s, const std::regex& delim = std::regex(",\\s*")) { using namespace std; vector<string> cont; copy(regex_token_iterator<string::const_iterator>(s.begin(), s.end(), delim, -1), regex_token_iterator<string::const_iterator>(), back_inserter(cont)); return cont; } Type EnumStrings(Type, __VA_ARGS__)
template<typename T> class Enum final { const char* m_name; const T m_value; static T m_counter; public: Enum(const char* str, T init = m_counter) : m_name(str), m_value(init) {m_counter = (init + 1);} const T value() const {return m_value;} const char* name() const {return m_name;} }; template<typename T> T Enum<T>::m_counter = 0;
namespace Level { ENUM_TYPE(std::uint8) ENUM(OFF) ENUM(SEVERE) ENUM(WARNING) ENUM(INFO, 10) ENUM(DEBUG) ENUM(ALL) } namespace Example { ENUM_TYPE(long) ENUM(A) ENUM(B) ENUM(C, 20) ENUM(D) ENUM(E) ENUM(F) } int main(int argc, char** argv) { Level::Enum lvl = Level::WARNING; Example::Enum ex = Example::C; std::cout << lvl.value() << std::endl; std::cout << ex.value() << std::endl; }
template<typename T> struct Enum final { const T value; const char* name; constexpr operator const T() const noexcept {return value;} constexpr const char* operator&() const noexcept {return name;} };
namespace Level { ENUM_TYPE(short); ENUM(OFF); ENUM(SEVERE); ENUM(WARNING); ENUM(INFO); ENUM(DEBUG); ENUM(ALL); }; int main(int argc, char** argv) { std::cout << Level::OFF << std::endl; std::cout << &Level::OFF << std::endl; std::cout << Level::INFO << std::endl; std::cout << &Level::INFO << std::endl; switch( ) { case Level::OFF: break; case Level::SEVERE: break; } return 0; }
enum class MyEnum { Zero = 0, One = 1, Two = 2 }; ponder::Enum::declare<MyEnum>() .value("Zero", MyEnum::Zero) .value("One", MyEnum::One) .value("Two", MyEnum::Two); ponder::EnumObject zero(MyEnum::Zero); zero.name();
enum class test1 { ONE, TWO = 13, SIX }; std::string toString(const test1& e) { ... } int main() { test1 x; std::cout << toString(x) << "\n"; std::cout << toString(test1::TWO) << "\n"; std::cout << static_cast<std::underlying_type<test1>::type>(test1::TWO) << "\n"; }
x_enum_def static std::map<x_name,std::string> names = { x_enum_def
DEF_MSG(CODE_OK, "OK!") DEF_MSG(CODE_FAIL, "Fail!")
MSG_CODE foo(void) { return MSG_OK; } MSG_CODE ret = foo(); if (MSG_OK != ret) { printf("%s\n", gm(ret);); }
enum class TYPE {__VA_ARGS__};\ struct Helper_ static const String& toName(TYPE type) {\ int index = static_cast<int>(type);\ return splitStringVec()[index];}\ static const TYPE toType(const String& name){\ static std::unordered_map<String,TYPE> typeNameMap;\ if( typeNameMap.empty() )\ {\ const StringVector& ssVec = splitStringVec();\ for (size_t i = 0; i < ssVec.size(); ++i)\ typeNameMap.insert(std::make_pair(ssVec[i], static_cast<TYPE>(i)));\ }\ return typeNameMap[name];}\ static const StringVector& splitStringVec() {\ static StringVector typeNameVector;\ if(typeNameVector.empty()) \ {\ typeNameVector = StringUtil::split( for (auto& name : typeNameVector)\ {\ name.erase(std::remove(name.begin(), name.end(), name = String( }\ }\ return typeNameVector;\ }\ }; using String = std::string; using StringVector = std::vector<String>; StringVector StringUtil::split( const String& str, const String& delims, unsigned int maxSplits, bool preserveDelims) { StringVector ret; ret.reserve(maxSplits ? maxSplits+1 : 10); unsigned int numSplits = 0; size_t start, pos; start = 0; do { pos = str.find_first_of(delims, start); if (pos == start) { start = pos + 1; } else if (pos == String::npos || (maxSplits && numSplits == maxSplits)) { ret.push_back( str.substr(start) ); break; } else { ret.push_back( str.substr(start, pos - start) ); if(preserveDelims) { size_t delimStart = pos, delimPos; delimPos = str.find_first_not_of(delims, delimStart); if (delimPos == String::npos) { ret.push_back( str.substr(delimStart) ); } else { ret.push_back( str.substr(delimStart, delimPos - delimStart) ); } } start = pos + 1; } start = str.find_first_not_of(delims, start); ++numSplits; } while (pos != String::npos); return ret; }
ENUM_MAKE(MY_TEST, MY_1, MY_2, MY_3) MY_TEST s1 = MY_TEST::MY_1; MY_TEST s2 = MY_TEST::MY_2; MY_TEST s3 = MY_TEST::MY_3; String z1 = Helper_MY_TEST::toName(s1); String z2 = Helper_MY_TEST::toName(s2); String z3 = Helper_MY_TEST::toName(s3); MY_TEST q1 = Helper_MY_TEST::toType(z1); MY_TEST q2 = Helper_MY_TEST::toType(z2); MY_TEST q3 = Helper_MY_TEST::toType(z3);
enum class Language { unknown, Chinese, English, French, German }; class Enumerations { public: static void fnInit(void); static std::unordered_map <std::wstring, Language> m_Language; static std::unordered_map <Language, std::wstring> m_invLanguage; private: static void fnClear(); static void fnSetValues(void); static void fnInvertValues(void); static bool m_init_done; }; std::unordered_map <std::wstring, Language> Enumerations::m_Language = std::unordered_map <std::wstring, Language>(); std::unordered_map <Language, std::wstring> Enumerations::m_invLanguage = std::unordered_map <Language, std::wstring>(); void Enumerations::fnInit() { fnClear(); fnSetValues(); fnInvertValues(); } void Enumerations::fnClear() { m_Language.clear(); m_invLanguage.clear(); } void Enumerations::fnSetValues(void) { m_Language[L"unknown"] = Language::unknown; m_Language[L"Chinese"] = Language::Chinese; m_Language[L"English"] = Language::English; m_Language[L"French"] = Language::French; m_Language[L"German"] = Language::German; } void Enumerations::fnInvertValues(void) { for (auto it = m_Language.begin(); it != m_Language.end(); it++) { m_invLanguage[it->second] = it->first; } }
enum class myenum { one = 0, two, three, }; deque<string> ssplit(const string &_src, boost::regex &_re) { boost::sregex_token_iterator it(_src.begin(), _src.end(), _re, -1); boost::sregex_token_iterator e; deque<string> tokens; while (it != e) tokens.push_back(*it++); return std::move(tokens); } int main() { regex re(","); deque<string> tokens = ssplit("one,two,three", re); for (auto &t : tokens) cout << t << endl; getchar(); return 0; }
int main () { VERB a = VERB::GET; VERB b = VERB::GET; VERB c = VERB::POST; VERB d = VERB::PUT; VERB e = VERB::DELETE; std::cout << a.toString() << std::endl; std::cout << a << std::endl; if ( a == VERB::GET ) { std::cout << "yes" << std::endl; } if ( a == b ) { std::cout << "yes" << std::endl; } if ( a != c ) { std::cout << "no" << std::endl; } }
class VERB { private: enum Verb {GET_=0, POST_, PUT_, DELETE_}; static const std::string theStrings[]; const Verb value; const std::string text; VERB (Verb v) : value(v), text (theStrings[v]) { } public: operator const char * () const { return text.c_str(); } operator const std::string () const { return text; } const std::string toString () const { return text; } bool operator == (const VERB & other) const { return (*this).value == other.value; } bool operator != (const VERB & other) const { return ! ( (*this) == other); } static const VERB GET; static const VERB POST; static const VERB PUT; static const VERB DELETE; }; const std::string VERB::theStrings[] = {"GET", "POST", "PUT", "DELETE"}; const VERB VERB::GET = VERB ( VERB::Verb::GET_ ); const VERB VERB::POST = VERB ( VERB::Verb::POST_ ); const VERB VERB::PUT = VERB ( VERB::Verb::PUT_ ); const VERB VERB::DELETE = VERB ( VERB::Verb::DELETE_ );
enum class MyEnum : std::uint_fast8_t { AAA, BBB, CCC, }; std::ostream& operator<<(std::ostream& str, MyEnum type) { switch(type) { case MyEnum::AAA: str << "AAA"; break; case MyEnum::BBB: str << "BBB"; break; case MyEnum::CCC: str << "CCC"; break; default: break; } return str; } int main() { std::cout << MyEnum::AAA << }
cout << "bit 5 is " << BitParser::getBitAt(buffer, 5) << endl;
class BitParser { public: static bool getBitAt(int buffer, int bitIndex); private: BitParser() {} };
bool BitParser::getBitAt(int buffer, int bitIndex) { bool isBitSet = false; return isBitSet; }
class MyClass { public : static void myMethod() ; } ; void MyClass::myMethod() { }
namespace MyNamespace { void myMethod() ; } namespace MyNamespace { void myMethod() { } }
class Foo { public : void barA() ; private : void barB() ; static std::string myGlobal ; } ;
std::string Foo::myGlobal ; void Foo::barA() { } void Foo::barB() { } void barC() { }
namespace Foo { namespace { std::string myGlobal ; void Foo::barB() { } } void barA() { } } void barC() { }
namespace alpha { void foo() ; void bar() ; } struct Beta { static void foo() ; static void bar() ; }; template <typename T> struct Gamma { void foobar() { T::foo() ; T::bar() ; } }; Gamma<alpha> ga ; Gamma<Beta> gb ; gb.foobar() ;
namespace BitParser { bool getBitAt(int buffer, int bitIndex); }
namespace BitParser { bool getBitAt(int buffer, int bitIndex) { } }
class BitParser { public: ... static ... getBitAt(...) { } };
public ref class BitParser abstract sealed { public: static bool GetBitAt(...) { ... } }
class TheDataToBeHidden { public: static int _var1; static int _var2; }; namespace SharedData { void SetError(const char *Message, const char *Title); void DisplayError(void); }
int TheDataToBeHidden::_var1 = 0; int TheDataToBeHidden::_var2 = 0; namespace SharedData { void SetError(const char *Message, const char *Title) { } void DisplayError(void) { } }
SharedData::SetError("Hello", "World"); SharedData::DisplayError();
class BitParser final { public: BitParser() = delete; static bool GetBitAt(int buffer, int pos); }; bool BitParser::GetBitAt(int buffer, int pos) { }
class Class { public: void foo() { Static::bar(*this); } private: int member{0}; friend class Static; }; class Static { public: template <typename T> static void bar(T& t) { t.member = 1; } };
void inner_mad() { throw std::exception(); } void mad() { std::unique_ptr<int> ptr(new int); inner_mad(); } int main() { std::ofstream os("file.txt"); os << "Content!!!"; int possibility = ; if(possibility == 1) return 0; else if(possibility == 2) throw std::exception(); else if(possibility == 3) mad(); else if(possibility == 4) exit(0); }
int main() { try { } catch(const std::exception&) { return EXIT_FAILURE; } }
int main() { ofstream os("out.txt"); os << "Hello, Can you see me!\n"; return(0); }
int main(int argc, char** argv) { try { exit( secondary_main(argc, argv ); } catch(...) { exit(1); } }
MyNamespace::MyClass* pClass = new MyNamespace::MyClass();
using namespace MyNamespace; MyClass* pClass = new MyClass();
void doSomething() { using std::string ; string a("Hello World!") ; std::cout << a << std::endl ; } void doSomethingElse() { using namespace std ; string a("Hello World!") ; cout << a << endl ; }
namespace AAA { void doSomething() ; } namespace BBB { void doSomethingElse() ; } namespace CCC { using namespace AAA ; using namespace BBB ; } void doSomethingAgain() { CCC::doSomething() ; CCC::doSomethingElse() ; }
Some::Impossibly::Annoyingly::Long:Name::For::Namespace::Finally::TheClassName foo; Some::Impossibly::Annoyingly::Long:Name::For::Namespace::Finally::AnotherClassName bar;
namespace Shorter = Some::Impossibly::Annoyingly::Long:Name::For::Namespace::Finally; Shorter::TheClassName foo; Shorter::AnotherClassName bar;
namespace MyNamespace { double square(double x) { return x * x; } }
namespace MyNamespace { double cube(double x) { return x * x * x; } }
void test(const std::string& s) { using namespace std; cout << s; }
using namespace boost; using namespace std; shared_ptr<int> p(new int(1)); cout << "cout belongs to std::" << endl;
bool hasEnding (std::string const &fullString, std::string const &ending) { if (fullString.length() >= ending.length()) { return (0 == fullString.compare (fullString.length() - ending.length(), ending.length(), ending)); } else { return false; } } int main () { std::string test1 = "binary"; std::string test2 = "unary"; std::string test3 = "tertiary"; std::string test4 = "ry"; std::string ending = "nary"; std::cout << hasEnding (test1, ending) << std::endl; std::cout << hasEnding (test2, ending) << std::endl; std::cout << hasEnding (test3, ending) << std::endl; std::cout << hasEnding (test4, ending) << std::endl; return 0; }
inline bool ends_with(std::string const & value, std::string const & ending) { if (ending.size() > value.size()) return false; return std::equal(ending.rbegin(), ending.rend(), value.rbegin()); }
assert(boost::algorithm::ends_with("mystring", "ing")); std::string haystack("mystring"); std::string needle("ing"); assert(boost::algorithm::ends_with(haystack, needle)); std::string haystack2("ng"); assert(! boost::algorithm::ends_with(haystack2, needle));
int str_ends_with(const char * str, const char * suffix) { if( str == NULL || suffix == NULL ) return 0; size_t str_len = strlen(str); size_t suffix_len = strlen(suffix); if(suffix_len > str_len) return 0; return 0 == strncmp( str + str_len - suffix_len, suffix, suffix_len ); }
const string sNoFruit = "ThisOneEndsOnNothingMuchFruitLike"; const string sOrange = "ThisOneEndsOnOrange"; const string sPattern = "Orange"; assert( mismatch( sPattern.rbegin(), sPattern.rend(), sNoFruit.rbegin() ) .first != sPattern.rend() ); assert( mismatch( sPattern.rbegin(), sPattern.rend(), sOrange.rbegin() ) .first == sPattern.rend() );
static bool endsWith(const std::string& str, const std::string& suffix) { return str.size() >= suffix.size() && 0 == str.compare(str.size()-suffix.size(), suffix.size(), suffix); } static bool startsWith(const std::string& str, const std::string& prefix) { return str.size() >= prefix.size() && 0 == str.compare(0, prefix.size(), prefix); }
static bool endsWith(const std::string& str, const char* suffix, unsigned suffixLen) { return str.size() >= suffixLen && 0 == str.compare(str.size()-suffixLen, suffixLen, suffix, suffixLen); } static bool endsWith(const std::string& str, const char* suffix) { return endsWith(str, suffix, std::string::traits_type::length(suffix)); } static bool startsWith(const std::string& str, const char* prefix, unsigned prefixLen) { return str.size() >= prefixLen && 0 == str.compare(0, prefixLen, prefix, prefixLen); } static bool startsWith(const std::string& str, const char* prefix) { return startsWith(str, prefix, std::string::traits_type::length(prefix)); }
bool EndsWith(const string& a, const string& b) { if (b.size() > a.size()) return false; return std::equal(a.begin() + a.size() - b.size(), a.end(), b.begin()); }
bool endsWith(const string& s, const string& suffix) { return s.rfind(suffix) == (s.size()-suffix.size()); }
bool EndsWith(string &str, string& key) { size_t keylen = key.length(); size_t strlen = str.length(); if(keylen =< strlen) return string::npos != str.rfind(key,strlen - keylen, keylen); else return false; }
static bool EndsWithCaseInsensitive(const std::string& value, const std::string& ending) { if (ending.size() > value.size()) { return false; } return std::equal(ending.rbegin(), ending.rend(), value.rbegin(), [](const char a, const char b) { return tolower(a) == tolower(b); } ); }
template<typename TString> inline bool starts_with(const TString& str, const TString& start) { if (start.size() > str.size()) return false; return str.compare(0, start.size(), start) == 0; } template<typename TString> inline bool ends_with(const TString& str, const TString& end) { if (end.size() > str.size()) return false; return std::equal(end.rbegin(), end.rend(), str.rbegin()); }
bool endsWith(const string& s, const string& suffix) { return s.size() >= suffix.size() && s.rfind(suffix) == (s.size()-suffix.size()); }
/* Check string is end with extension/suffix */ int strEndWith(char* str, const char* suffix) { size_t strLen = strlen(str); size_t suffixLen = strlen(suffix); if (suffixLen <= strLen) { return strncmp(str + strLen - suffixLen, suffix, suffixLen) == 0; } return 0; }
bool endsWith(const std::string& str, const std::string& suffix) { if (&suffix == &str) return true; if (suffix.length() > str.length()) return false; size_t delta = str.length() - suffix.length(); for (size_t i = 0; i < suffix.length(); ++i) { if (suffix[i] != str[delta + i]) return false; } return true; }
bool endsWithIgnoreCase(const std::string& str, const std::string& suffix) { if (&suffix == &str) return true; if (suffix.length() > str.length()) return false; size_t delta = str.length() - suffix.length(); for (size_t i = 0; i < suffix.length(); ++i) { if (std::tolower(suffix[i]) != std::tolower(str[delta + i])) return false; } return true; }
bool starts_with(std::string const & value, std::string const & prefix) { size_t valueSize = value.size(); size_t prefixSize = prefix.size(); if (prefixSize > valueSize) { return false; } return memcmp(value.data(), prefix.data(), prefixSize) == 0; } bool ends_with(std::string const & value, std::string const & suffix) { size_t valueSize = value.size(); size_t suffixSize = suffix.size(); if (suffixSize > valueSize) { return false; } const char * valuePtr = value.data() + valueSize - suffixSize; return memcmp(valuePtr, suffix.data(), suffixSize) == 0; }
std::map<ID, ICommand*> dispatchTable; ... dispatchTable[id] = concreteCommand; ... dispatchTable[id]->Execute();
string parsed,input="text to be parsed"; stringstream input_stringstream(input); if(getline(input_stringstream,parsed, { }
std::string s = "scott>=tiger"; std::string delimiter = ">="; std::string token = s.substr(0, s.find(delimiter));
s.erase(0, s.find(delimiter) + delimiter.length());
std::string s = "scott>=tiger>=mushroom"; std::string delimiter = ">="; size_t pos = 0; std::string token; while ((pos = s.find(delimiter)) != std::string::npos) { token = s.substr(0, pos); std::cout << token << std::endl; s.erase(0, pos + delimiter.length()); } std::cout << s << std::endl;
int main() { std::string s = "scott>=tiger"; std::string delim = ">="; auto start = 0U; auto end = s.find(delim); while (end != std::string::npos) { std::cout << s.substr(start, end - start) << std::endl; start = end + delim.length(); end = s.find(delim, start); } std::cout << s.substr(start, end); }
vector<string> split(const string& str, const string& delim) { vector<string> tokens; size_t prev = 0, pos = 0; do { pos = str.find(delim, prev); if (pos == string::npos) pos = str.length(); string token = str.substr(prev, pos-prev); if (!token.empty()) tokens.push_back(token); prev = pos + delim.length(); } while (pos < str.length() && prev < str.length()); return tokens; }
string token, mystring("scott>=tiger"); while(token != mystring){ token = mystring.substr(0,mystring.find_first_of(">=")); mystring = mystring.substr(mystring.find_first_of(">=") + 1); printf("%s ",token.c_str()); }
using namespace std; vector<string> split (string s, string delimiter) { size_t pos_start = 0, pos_end, delim_len = delimiter.length(); string token; vector<string> res; while ((pos_end = s.find (delimiter, pos_start)) != string::npos) { token = s.substr (pos_start, pos_end - pos_start); pos_start = pos_end + delim_len; res.push_back (token); } res.push_back (s.substr (pos_start)); return res; } int main() { string str = "adsf-+qwret-+nvfkbdsj-+orthdfjgh-+dfjrleih"; string delimiter = "-+"; vector<string> v = split (str, delimiter); for (auto i : v) cout << i << endl; return 0; }
using namespace std; vector<string> split (const string &s, char delim) { vector<string> result; stringstream ss (s); string item; while (getline (ss, item, delim)) { result.push_back (item); } return result; } int main() { string str = "adsf+qwer+poui+fdgh"; vector<string> v = split (str, for (auto i : v) cout << i << endl; return 0; }
vector<string> split(char *phrase, string delimiter){ vector<string> list; string s = string(phrase); size_t pos = 0; string token; while ((pos = s.find(delimiter)) != string::npos) { token = s.substr(0, pos); list.push_back(token); s.erase(0, pos + delimiter.length()); } list.push_back(s); return list; }
struct my_tokenizer_func { template<typename It> bool operator()(It& next, It end, std::string & tok) { if (next == end) return false; char const * del = ">="; auto pos = std::search(next, end, del, del + 2); tok.assign(next, pos); next = pos; if (next != end) std::advance(next, 2); return true; } void reset() {} }; int main() { std::string to_be_parsed = "1) one>=2) two>=3) three>=4) four"; for (auto i : boost::tokenizer<my_tokenizer_func>(to_be_parsed)) std::cout << i << }
bool endsWith(const std::string& s, const std::string& suffix) { return s.size() >= suffix.size() && s.substr(s.size() - suffix.size()) == suffix; } std::vector<std::string> split(const std::string& s, const std::string& delimiter, const bool& removeEmptyEntries = false) { std::vector<std::string> tokens; for (size_t start = 0, end; start < s.length(); start = end + delimiter.length()) { size_t position = s.find(delimiter, start); end = position != string::npos ? position : s.length(); std::string token = s.substr(start, end - start); if (!removeEmptyEntries || !token.empty()) { tokens.push_back(token); } } if (!removeEmptyEntries && (s.empty() || endsWith(s, delimiter))) { tokens.push_back(""); } return tokens; }
split("a-b-c", "-"); split("a--c", "-"); split("-b-", "-"); split("--c--", "-"); split("--c--", "-", true); split("a", "-"); split("", "-"); split("", "-", true);
inline std::vector<std::string> splitString( const std::string &s, const std::string &delimiter ){ std::vector<std::string> ret; size_t start = 0; size_t end = 0; size_t len = 0; std::string token; do{ end = s.find(delimiter,start); len = end - start; token = s.substr(start, len); ret.emplace_back( token ); start += len + delimiter.length(); std::cout << token << std::endl; }while ( end != std::string::npos ); return ret; }
using namespace std; int split_count(string str,char delimit){ return count(str.begin(),str.end(),delimit); } void split(string str,char delimit,string res[]){ int a=0,i=0; while(a<str.size()){ res[i]=str.substr(a,str.find(delimit)); a+=res[i].size()+1; i++; } } int main(){ string a="abc.xyz.mno.def"; int x=split_count(a, string res[x]; split(a, for(int i=0;i<x;i++) cout<<res[i]<<endl; return 0; }
std::vector<std::string> split(const std::string& s, char c) { std::vector<std::string> v; unsigned int ii = 0; unsigned int j = s.find(c); while (j < s.length()) { v.push_back(s.substr(i, j - i)); i = ++j; j = s.find(c, j); if (j >= s.length()) { v.push_back(s.substr(i, s,length())); break; } } return v; }
struct A { private: A(); }; struct B : A { }; int main() { sizeof B(); }
struct A { ~A() { throw "foo"; } }; int main() { try { A a; } catch(...) { } }
static void f(int) { } void f(long) { } template<typename T> void g(T t) { f(t); } int main() { g(0); }
struct B { }; struct A : B { }; template<typename T> void g(T t) { f(t); } static void f(A) { } void f(B) { } int main() { A a; g(a); }
template<template<typename> class X> struct M { }; template<template<typename> class X> void g(int = 0); template<typename T> void g(long = 0); template<typename T> struct A { void f() { g<A>(); g<A>(1); } }; void h() { A<int> a; a.f(); }
struct B { void f(); }; template<typename T> struct A : virtual B { void f(); }; template<typename T> struct C : virtual B, A<T> { void g() { this->f(); } }; int main() { C<int> c; c.g(); }
struct A { protected: int B; }; typedef A B; struct C : B { using B::B; }; int main() { C c; c.B = 0; }
int main() { std::stringstream ss; ss << int x = -1; assert(!(ss >> x)); assert(x == -1); assert(x == 0); }
template<class T> struct identity{ typedef T type; };
struct x { x(int) {} }; void f(auto x = 3) { } int main() { f(); }
double round(double); round(0.1) = 0 round(-0.1) = 0 round(-0.9) = -1
double a = boost::math::round(1.5); int b = boost::math::iround(1.5);
int main() { std::cout << std::round( 0.4 ) << " " << std::lround( 0.4 ) << " " << std::llround( 0.4 ) << std::endl ; std::cout << std::round( 0.5 ) << " " << std::lround( 0.5 ) << " " << std::llround( 0.5 ) << std::endl ; std::cout << std::round( 0.6 ) << " " << std::lround( 0.6 ) << " " << std::llround( 0.6 ) << std::endl ; }
int main() { std::cout << std::trunc( 0.4 ) << std::endl ; std::cout << std::trunc( 0.9 ) << std::endl ; std::cout << std::trunc( 1.1 ) << std::endl ; }
double myround(double d) { return std::floor(d + 0.5); }
float myround(float f) { return static_cast<float>( static_cast<unsigned int>( f ) ) ; }
float roundf(x) { int signbit; __uint32_t w; int exponent_less_127; GET_FLOAT_WORD(w, x); signbit = w & 0x80000000; exponent_less_127 = (int)((w & 0x7f800000) >> 23) - 127; if (exponent_less_127 < 23) { if (exponent_less_127 < 0) { w &= 0x80000000; if (exponent_less_127 == -1) w |= ((__uint32_t)127 << 23); } else { unsigned int exponent_mask = 0x007fffff >> exponent_less_127; if ((w & exponent_mask) == 0) return x; w += 0x00400000 >> exponent_less_127; w &= ~exponent_mask; } } else { if (exponent_less_127 == 128) return x + x; else return x; } SET_FLOAT_WORD(x, w); return x; }
int round_int( double r ) { return (r > 0.0) ? (r + 0.5) : (r - 0.5); }
int main(int argc, char** argv) { std::cout << "round(0.5):\t" << round(0.5) << std::endl; std::cout << "round(-0.5):\t" << round(-0.5) << std::endl; std::cout << "round(1.4):\t" << round(1.4) << std::endl; std::cout << "round(-1.4):\t" << round(-1.4) << std::endl; std::cout << "round(1.6):\t" << round(1.6) << std::endl; std::cout << "round(-1.6):\t" << round(-1.6) << std::endl; return 0; }
round(0.5): 1 round(-0.5): -1 round(1.4): 1 round(-1.4): -1 round(1.6): 2 round(-1.6): -2
long round(double x) { assert(x >= LONG_MIN-0.5); assert(x <= LONG_MAX+0.5); if (x >= 0) return (long) (x+0.5); return (long) (x-0.5); } error() : ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
template<typename T, typename S> T round2(const S& x) { typedef boost::numeric::conversion_traits<T, S> Traits; typedef boost::numeric::def_overflow_handler OverflowHandler; typedef boost::numeric::RoundEven<typename Traits::source_type> Rounder; typedef boost::numeric::converter<T, S, Traits, OverflowHandler, Rounder> Converter; return Converter::convert(x); } int main() { std::cout << round2<int, double>(0.1) << }
double round( double x ) { const double sd = 1000; return int(x*sd + (x<0? -0.5 : 0.5))/sd; }
int roundint(double r) { return (int)((r > 0.0) ? floor(r + 0.5) : ceil(r - 0.5)); }
int roundint (double r) { int tmp = static_cast<int> (r); tmp += (r-tmp>=.5) - (r-tmp<=-.5); return tmp; }
-bash-3.2$ cat >test-round.c <<END int main() { double x=5000000000000001.0; double y=round(x); double z=floor(x+0.5); printf(" x =%f\n",x); printf("round(x) =%f\n",y); printf("floor(x+0.5)=%f\n",z); return 0; } END -bash-3.2$ gcc test-round.c -bash-3.2$ ./a.out x =5000000000000001.000000 round(x) =5000000000000001.000000 floor(x+0.5)=5000000000000002.000000
double round(double x) { double truncated,roundedFraction; double fraction = modf(x, &truncated); modf(2.0*fraction, &roundedFraction); return truncated + roundedFraction; }
double round (double x); float roundf (float x); long double roundl (long double x);
double round (double x); float round (float x); long double round (long double x); double round (T x);
T roundedQuotient = (2 * integerNumerator + 1) / (2 * integerDenominator);
double round(double x) { using namespace std; if ((numeric_limits<double>::max() - 0.5) <= x) return numeric_limits<double>::max(); if ((-1*std::numeric_limits<double>::max() + 0.5) > x) return (-1*std::numeric_limits<double>::max()); double intpart; double fractpart = modf(x, &intpart); if (fractpart >= 0.5) return (intpart + 1); else if (fractpart >= -0.5) return intpart; else return (intpart - 1); }
inline double myRound(double x) { return (x >= 0.0 ? std::floor(x + 0.5) : std::ceil(x - 0.5)); }
template <typename Arg> int Round(Arg arg) { if ( (Arg)std::numeric_limits<int>::max() < arg + (Arg) 0.5) || (Arg)std::numeric_limits<int>::lowest() > arg - (Arg) 0.5) ) { throw std::overflow_error("out of bounds"); } return (arg > (Arg) 0.0) ? (int)(r + (Arg) 0.5) : (int)(r - (Arg) 0.5); }
float my_roundf (float x) { const float half = 0.5f; const float one = 2 * half; const float lbound = half; const float ubound = 1L << 23; float a, f, r, s, t; s = (x < 0) ? (-one) : one; a = x * s; t = (a < lbound) ? x : s; f = (a < lbound) ? 0 : floorf (a + half); r = (a > ubound) ? x : (t * f); return r; } double my_round (double x) { const double half = 0.5; const double one = 2 * half; const double lbound = half; const double ubound = 1ULL << 52; double a, f, r, s, t; s = (x < 0) ? (-one) : one; a = x * s; t = (a < lbound) ? x : s; f = (a < lbound) ? 0 : floor (a + half); r = (a > ubound) ? x : (t * f); return r; } uint32_t float_as_uint (float a) { uint32_t r; memcpy (&r, &a, sizeof(r)); return r; } float uint_as_float (uint32_t a) { float r; memcpy (&r, &a, sizeof(r)); return r; } float newlib_roundf (float x) { uint32_t w; int exponent_less_127; w = float_as_uint(x); exponent_less_127 = (int)((w & 0x7f800000) >> 23) - 127; if (exponent_less_127 < 23) { if (exponent_less_127 < 0) { w &= 0x80000000; if (exponent_less_127 == -1) { w |= ((uint32_t)127 << 23); } } else { uint32_t exponent_mask = 0x007fffff >> exponent_less_127; if ((w & exponent_mask) == 0) { return x; } w += 0x00400000 >> exponent_less_127; w &= ~exponent_mask; } } else { if (exponent_less_127 == 128) { return x + x; } else { return x; } } x = uint_as_float (w); return x; } int main (void) { uint32_t argi, resi, refi; float arg, res, ref; argi = 0; do { arg = uint_as_float (argi); ref = newlib_roundf (arg); res = my_roundf (arg); resi = float_as_uint (res); refi = float_as_uint (ref); if (resi != refi) { printf ("!!!! arg=%08x res=%08x ref=%08x\n", argi, resi, refi); return EXIT_FAILURE; } argi++; } while (argi); return EXIT_SUCCESS; }
__forceinline int Round(const double v) { int r; __asm { FLD v FISTP r FWAIT }; return r; }
__forceinline double dround(const double v) { double r; __asm { FLD v FRNDINT FSTP r FWAIT }; return r; }
dround(0.1): 0.000000000000000 dround(-0.1): -0.000000000000000 dround(0.9): 1.000000000000000 dround(-0.9): -1.000000000000000 dround(1.1): 1.000000000000000 dround(-1.1): -1.000000000000000 dround(0.49999999999999994): 0.000000000000000 dround(-0.49999999999999994): -0.000000000000000 dround(0.5): 0.000000000000000 dround(-0.5): -0.000000000000000
float MyFloat = 5.11133333311111333; float NewConvertedFloat = 0.0; string FirstString = " "; string SecondString = " "; stringstream ss (stringstream::in | stringstream::out); ss << MyFloat; FirstString = ss.str(); SecondString = FirstString.substr(0,5); stringstream(SecondString) >> NewConvertedFloat; cout << NewConvertedFloat; system("pause");
using namespace std; double roundh(double number, int place){ number *= 10^place; int istack = (int)floor(number); int out = number-istack; if (out < 0.5){ floor(number); number /= 10^place; return number; } if (out > 0.4) { ceil(number); number /= 10^place; return number; } }
if(!wptr.expired()) something_assuming_the_resource_is_still_alive();
struct BinaryTree { Tree* m_parent; std::unique_ptr<BinaryTree> m_children[2]; };
struct ListNode { std::shared_ptr<ListNode> m_next; std::weak_ptr<ListNode> m_prev; };
PS C:\Users\Anurag\SkyDrive\College\Programs> g++ -std=c++0x ttd.cpp ttd.cpp: In function ttd.cpp:11:2: error:
namespace patch { template < typename T > std::string to_string( const T& n ) { std::ostringstream stm ; stm << n ; return stm.str() ; } } int main() { std::cout << patch::to_string(1234) << }
int main() { std::ostringstream ss; long num = 123456; ss << num; std::cout << ss.str() << std::endl; }
template <typename T> std::string to_string(T value) { std::ostringstream os ; os << value ; return os.str() ; }
namespace std { template<typename T> std::string to_string(const T &n) { std::ostringstream s; s << n; return s.str(); } }
class A { public: static const std::size_t x = 10; A(); };
CMakeFiles/untitled2.dir/a.cpp.o:a.cpp:(.rdata$.refptr._ZN1A1xE[.refptr._ZN1A1xE]+0x0): undefined reference to `A::x' collect2: error: ld returned 1 exit status
namespace std { std::string to_string(size_t n) { std::ostringstream s; s << n; return s.str(); } }
string to_string(int number){ string number_string = ""; char ones_char; int ones = 0; while(true){ ones = number % 10; switch(ones){ case 0: ones_char = case 1: ones_char = case 2: ones_char = case 3: ones_char = case 4: ones_char = case 5: ones_char = case 6: ones_char = case 7: ones_char = case 8: ones_char = case 9: ones_char = default : ErrorHandling("Trouble converting number to string."); } number -= ones; number_string = ones_char + number_string; if(number == 0){ break; } number = number/10; } return number_string; }
struct address { int street_no; char *street_name; char *city; char *prov; char *postal_code; }; address temp_address = { .city = "Hamilton", .prov = "Ontario" };
address temp_addres = { 0, nullptr, "Hamilton", "Ontario", nullptr, };
address temp_address = {}; temp_address.city = "Hamilton"; temp_address.prov = "Ontario";
address temp_address = { 0, 0, "Hamilton", "Ontario", 0 };
initializer: assignment-expression { initializer-list } { initializer-list , } initializer-list: designation_opt initializer initializer-list , designationopt initializer designation: designator-list = designator-list: designator designator-list designator designator: [ constant-expression ] . identifier
initializer: brace-or-equal-initializer ( expression-list ) brace-or-equal-initializer: = initializer-clause braced-init-list initializer-clause: assignment-expression braced-init-list initializer-list: initializer-clause ...opt initializer-list , initializer-clause ...opt braced-init-list: { initializer-list ,opt } { }
struct address { int street_no; char *street_name; char *city; char *prov; char *postal_code; }; address ta = (ta = address(), ta.city = "Hamilton", ta.prov = "Ontario", ta);
struct address { address() : city("Hamilton"), prov("Ontario") {} int street_no; char *street_name; char *city; char *prov; char *postal_code; };
struct mp_struct_t { public: constexpr mp_struct_t(int member1) : mp_struct_t(member1, 0, 0) {} constexpr mp_struct_t(int member1, int member2, int member3) : member1(member1), member2(member2), member3(member3) {} constexpr mp_struct_t another_member(int member) { return {member1, member, member2}; } constexpr mp_struct_t yet_another_one(int member) { return {member1, member2, member}; } int member1, member2, member3; }; static mp_struct_t a_struct = mp_struct_t{1} .another_member(2) .yet_another_one(3);
struct address { int street_no; char *street_name; char *city; char *prov; char *postal_code; };
struct temp_address : address { temp_address() { city = "Hamilton"; prov = "Ontario"; } } temp_address;
struct Group { int x; int y; const char* s; }; int main() { Group group { .x = 1, .y = 2, .s = "Hello it works" }; printf("%d, %d, %s", group.x, group.y, group.s); }
struct address { int street_no; const char *street_name; const char *city; const char *prov; const char *postal_code; };
address temp_address = ADDRESS(( _.city = "Hamilton", _.prov = "Ontario" ));
address temp_address = INIT(address,( _.city = "Hamilton", _.prov = "Ontario" ));
typedef struct testdatum_s { public: std::string argument1; std::string argument2; std::string argument3; std::string argument4; int count; testdatum_s ( std::string argument1, std::string argument2, std::string argument3, std::string argument4, int count) { this->rotation = argument1; this->tstamp = argument2; this->auth = argument3; this->answer = argument4; this->count = count; } } testdatum;
std::vector<testdatum> testdata; testdata.push_back(testdatum("val11", "val12", "val13", "val14", 5)); testdata.push_back(testdatum("val21", "val22", "val23", "val24", 1)); testdata.push_back(testdatum("val31", "val32", "val33", "val34", 7)); for (std::vector<testdatum>::iterator i = testdata.begin(); i != testdata.end(); ++i) { function_in_test(i->argument1, i->argument2, i->argument3, i->argument4m i->count); }
extern "C" { struct address { int street_no; char *street_name;`enter code here` char *city; char *prov; char *postal_code; }; address temp_address ={ .city = "Hamilton", .prov = "Ontario" }; }
template<class M, class T> struct make_const { typedef T type; }; template<class M, class T> struct make_const<const M, T> { typedef typename boost::add_const<T>::type type; }; static const int fields_n = BOOST_PP_VARIADIC_SIZE(__VA_ARGS__); \ friend struct reflector; \ template<int N, class Self> \ struct field_data {}; \ BOOST_PP_SEQ_FOR_EACH_I(REFLECT_EACH, data, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) PAIR(x); \ template<class Self> \ struct field_data<i, Self> \ { \ Self & self; \ field_data(Self & self) : self(self) {} \ \ typename make_const<Self, TYPEOF(x)>::type & get() \ { \ return self.STRIP(x); \ }\ typename boost::add_const<TYPEOF(x)>::type & get() const \ { \ return self.STRIP(x); \ }\ const char * name() const \ {\ return BOOST_PP_STRINGIZE(STRIP(x)); \ } \ }; \
struct reflector { template<int N, class T> static typename T::template field_data<N, T> get_field_data(T& x) { return typename T::template field_data<N, T>(x); } template<class T> struct fields { static const int n = T::fields_n; }; };
struct field_visitor { template<class C, class Visitor, class I> void operator()(C& c, Visitor v, I) { v(reflector::get_field_data<I::value>(c)); } }; template<class C, class Visitor> void visit_each(C & c, Visitor v) { typedef boost::mpl::range_c<int,0,reflector::fields<C>::n> range; boost::mpl::for_each<range>(boost::bind<void>(field_visitor(), boost::ref(c), v, _1)); }
struct Person { Person(const char *name, int age) : name(name), age(age) { } private: REFLECTABLE ( (const char *) name, (int) age ) };
struct print_visitor { template<class FieldData> void operator()(FieldData f) { std::cout << f.name() << "=" << f.get() << std::endl; } }; template<class T> void print_fields(T & x) { visit_each(x, print_visitor()); }
int main() { Person p("Tom", 82); print_fields(p); return 0; }
class __declspec(export) MyClass { public: void Foo(float x); }
MyClass *instance_ptr=new MyClass; GetClass("MyClass")->GetFunction("Foo")->Invoke(instance_ptr,1.331);
namespace { static bool b2 = Filter::Filterable<const MyObj>::Register("MyObject"); } bool MyObj::BuildMap() { Filterable<const OutputDisease>::AddAccess("time", &MyObj::time); Filterable<const OutputDisease>::AddAccess("person", &MyObj::id); return true; }
FILTER-OUTPUT-OBJECT MyObject FILTER-OUTPUT-FILENAME file.txt FILTER-CLAUSE-1 person == 1773 FILTER-CLAUSE-2 time > 2000
struct S1 { ENUMERATE_MEMBERS(str,i); std::string str; int i; }; struct S2 { ENUMERATE_MEMBERS(s1,i2); S1 s1; int i2; };
void EnumerateWith(BinaryWriter & writer, int val) { writer.WriteBuffer(&val, sizeof(int)); } void EnumerateWith(BinaryWriter & writer, std::string val) { writer.WriteBuffer(val.c_str(), val.size()); }
template<typename TWriter, typename T> auto EnumerateWith(TWriter && writer, T && val) -> is_enumerable_t<T> { val.EnumerateWith(write); }
S1 s1; S2 s2; BinaryWriter writer("serialized.bin"); EnumerateWith(writer, s1); EnumerateWith(writer, s2);
template<typename TEnumerator> inline void EnumerateWith(TEnumerator & enumerator) const { EnumerateWithHelper(enumerator, __VA_ARGS__ ); }\ template<typename TEnumerator> inline void EnumerateWith(TEnumerator & enumerator) { EnumerateWithHelper(enumerator, __VA_ARGS__); } template<typename TEnumerator, typename ...T> inline void EnumerateWithHelper(TEnumerator & enumerator, T &...v) { int x[] = { (EnumerateWith(enumerator, v), 1)... }; } template<typename TEnumerator, typename T> auto EnumerateWith(TEnumerator & enumerator, T & val) -> std::void_t<decltype(val.EnumerateWith(enumerator))> { val.EnumerateWith(enumerator); }
using namespace std; class Person { public: REFLECTABLE( Person, (CString) name, (int) age ) }; class People { public: REFLECTABLE( People, (CString) groupName, (vector<Person>) people ) }; void main(void) { People ppl; ppl.groupName = "Group1"; Person p; p.name = L"Roger"; p.age = 37; ppl.people.push_back(p); p.name = L"Alice"; p.age = 27; ppl.people.push_back( p ); p.name = L"Cindy"; p.age = 17; ppl.people.push_back( p ); CStringA xml = ToXML( &ppl ); CStringW errors; People ppl2; FromXml( &ppl2, xml, errors ); CStringA xml2 = ToXML( &ppl2 ); printf( xml2 ); }
<?xml version="1.0" encoding="utf-8"?> <People groupName="Group1"> <people> <Person name="Roger" age="37" /> <Person name="Alice" age="27" /> <Person name="Cindy" age="17" /> </people> </People>
template <> class TypeTraitsT<CString> : public TypeTraits { public: virtual CStringW ToString( void* pField ) { CString* s = (CString*)pField; return *s; } virtual void FromString( void* pField, const wchar_t* value ) { CString* s = (CString*)pField; *s = value; } }; template <> class TypeTraitsT<int> : public TypeTraits { public: virtual CStringW ToString( void* pField ) { int* p = (int*) pField; return std::to_string(*p).c_str(); } virtual void FromString( void* pField, const wchar_t* value ) { int* p = (int*)pField; *p = _wtoi(value); } };
using namespace std; int main() { ifstream file("maze.txt"); if (file) { vector<char> vec(istreambuf_iterator<char>(file), (istreambuf_iterator<char>())); vector<char> path; int x = 17; char entrance = vec.at(16); char firstsquare = vec.at(x); if (entrance == path.push_back(entrance); } for (x = 17; isalpha(firstsquare); x++) { path.push_back(firstsquare); } for (int i = 0; i < path.size(); i++) { cout << path[i] << " "; } cout << endl; return 0; } }
std::vector<char> path; for (std::vector<char>::const_iterator i = path.begin(); i != path.end(); ++i) std::cout << *i <<
for (auto i = path.begin(); i != path.end(); ++i) std::cout << *i <<
typedef std::vector<char> Path; Path path; for (Path::const_iterator i = path.begin(); i != path.end(); ++i) std::cout << *i <<
for(int i=0; i<path.size(); ++i) std::cout << path[i] <<
for( Path::size_type i=0; i<path.size(); ++i) std::cout << path[i] <<
template <typename T> std::ostream& operator<< (std::ostream& out, const std::vector<T>& v) { if ( !v.empty() ) { out << std::copy (v.begin(), v.end(), std::ostream_iterator<T>(out, ", ")); out << "\b\b]"; } return out; }
int main() { std::vector<char> path; for (int ch = path.push_back(ch); std::copy(path.begin(), path.end(), std::ostream_iterator<char>(std::cout, " ")); return 0; }
using std::vector; using std::ostream; template<typename T> ostream& operator<< (ostream& out, const vector<T>& v) { out << "{"; size_t last = v.size() - 1; for(size_t i = 0; i < v.size(); ++i) { out << v[i]; if (i != last) out << ", "; } out << "}"; return out; }
vector<string> s = {"first", "second", "third"}; vector<bool> b = {true, false, true, false, false}; vector<int> i = {1, 2, 3, 4}; cout << s << endl; cout << b << endl; cout << i << endl;
{first, second, third} {1, 0, 1, 0, 0} {1, 2, 3, 4}
... std::vector<char> vec; ... std::for_each( vec.cbegin(), vec.cend(), [] (const char c) {std::cout << c << " ";} ); ...
std::vector<int> v{1,2,3,4}; std::copy(v.begin(),v.end(),std::ostream_iterator<int>(std::cout, " " ));
vector<char> items = { for (char n : items) cout << n <<
template<typename OutStream, typename T> OutStream& operator<< (OutStream& out, const vector<T>& v) { for (auto const& tmp : v) out << tmp << " "; out << endl; return out; }
template <typename T> void print_contents(const std::vector<T>& v, const char * const separator = " ") { if(!v.empty()) { std::copy(v.begin(), --v.end(), std::ostream_iterator<T>(std::cout, separator)); std::cout << v.back() << "\n"; } } int main() { std::vector<int> v{1, 2, 3, 4}; print_contents(v); print_contents(v, ":"); v = {}; print_contents(v); v = {1}; print_contents(v); return 0; }
class Foo { int i; friend std::ostream& operator<<(std::ostream& out, const Foo& obj); public: Foo(const int i) : i(i) {} }; std::ostream& operator<<(std::ostream& out, const Foo& obj) { return out << "foo_" << obj.i; } int main() { std::vector<Foo> v{1, 2, 3, 4}; print_contents(v); print_contents(v, ":"); v = {}; print_contents(v); v = {1}; print_contents(v); return 0; }
for (auto i = path.cbegin(); i != path.cend(); ++i) std::cout << *i <<
for (auto i = path.begin(); i != path.end(); ++i) std::cout << *i << for(int i=0; i<path.size(); ++i) std::cout << path[i] <<
CXXFLAGS+=-Xtemplight -profiler -Xtemplight -memory -Xtemplight -ignore-system
templight++ -Xtemplight -profiler -Xtemplight -memory -Xtemplight -ignore-system
$ templight-convert --format callgrind YOUR_BINARY --output YOUR_BINARY.trace $ templight-convert --format graphviz YOUR_BINARY --output YOUR_BINARY.dot
enum class PossibleChoices = {Option1, Option2, Option3} template <PossibleChoices pc> struct foo { };
template class foo<PossibleChoices::Option1>; template class foo<PossibleChoices::Option2>; template class foo<PossibleChoices::Option3>;
extern template class foo<PossibleChoices::Option1>; extern template class foo<PossibleChoices::Option2>; extern template class foo<PossibleChoices::Option3>;
namespace { template <typename T> struct foo { }; } using A = foo<int>;
__attribute__((visibility("default"))) void foo1() { } __attribute__((visibility("hidden"))) void foo2() { } __attribute__((visibility("hidden"))) class foo3 { }; void foo4() { }
-j [N], --jobs[=N] Allow N jobs at once; infinite jobs with no arg.
class Class2; class T { public: void doSomething(Class2 &c2); private: Class2 *m_Class2Ptr; }; void Class2::doSomething(Class2 &c2) { }
using namespace std; class node; class Solution; class Node { public: int a; int b; int c; Node(){} Node(vector<int> v) { sort(v.begin(), v.end()); a = v[0]; b = v[1]; c = v[2]; } bool operator==(Node i) { if ( i.a==this->a && i.b==this->b &&i.c==this->c ) { return true; } else { return false; } } }; int main() { unordered_map<Node, int> m; vector<int> v; v.push_back(3); v.push_back(8); v.push_back(9); Node n(v); m[n] = 0; return 0; }
In file included from /usr/include/c++/4.6/string:50:0, from /usr/include/c++/4.6/bits/locale_classes.h:42, from /usr/include/c++/4.6/bits/ios_base.h:43, from /usr/include/c++/4.6/ios:43, from /usr/include/c++/4.6/ostream:40, from /usr/include/c++/4.6/iostream:40, from 3sum.cpp:4: /usr/include/c++/4.6/bits/stl_function.h: In member function ‘bool std::equal_to<_Tp>::operator()(const _Tp&, const _Tp&) const [with _Tp = Node]’: /usr/include/c++/4.6/bits/hashtable_policy.h:768:48: instantiated from ‘bool std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, std::__detail::_Default_ranged_hash, false>::_M_compare(const _Key&, std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, std::__detail::_Default_ranged_hash, false>::_Hash_code_type, std::__detail::_Hash_node<_Value, false>*) const [with _Key = Node, _Value = std::pair<const Node, int>, _ExtractKey = std::_Select1st<std::pair<const Node, int> >, _Equal = std::equal_to<Node>, _H1 = std::hash<Node>, _H2 = std::__detail::_Mod_range_hashing, std::__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, std::__detail::_Default_ranged_hash, false>::_Hash_code_type = long unsigned int]’ /usr/include/c++/4.6/bits/hashtable.h:897:2: instantiated from ‘std::_Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, __cache_hash_code, __constant_iterators, __unique_keys>::_Node* std::_Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, __cache_hash_code, __constant_iterators, __unique_keys>::_M_find_node(std::_Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, __cache_hash_code, __constant_iterators, __unique_keys>::_Node*, const key_type&, typename std::_Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, __cache_hash_code, __constant_iterators, __unique_keys>::_Hash_code_type) const [with _Key = Node, _Value = std::pair<const Node, int>, _Allocator = std::allocator<std::pair<const Node, int> >, _ExtractKey = std::_Select1st<std::pair<const Node, int> >, _Equal = std::equal_to<Node>, _H1 = std::hash<Node>, _H2 = std::__detail::_Mod_range_hashing, _Hash = std::__detail::_Default_ranged_hash, _RehashPolicy = std::__detail::_Prime_rehash_policy, bool __cache_hash_code = false, bool __constant_iterators = false, bool __unique_keys = true, std::_Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, __cache_hash_code, __constant_iterators, __unique_keys>::_Node = std::__detail::_Hash_node<std::pair<const Node, int>, false>, std::_Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, __cache_hash_code, __constant_iterators, __unique_keys>::key_type = Node, typename std::_Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, __cache_hash_code, __constant_iterators, __unique_keys>::_Hash_code_type = long unsigned int]’ /usr/include/c++/4.6/bits/hashtable_policy.h:546:53: instantiated from ‘std::__detail::_Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::mapped_type& std::__detail::_Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::operator[](const _Key&) [with _Key = Node, _Pair = std::pair<const Node, int>, _Hashtable = std::_Hashtable<Node, std::pair<const Node, int>, std::allocator<std::pair<const Node, int> >, std::_Select1st<std::pair<const Node, int> >, std::equal_to<Node>, std::hash<Node>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, false, false, true>, std::__detail::_Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::mapped_type = int]’ 3sum.cpp:149:5: instantiated from here /usr/include/c++/4.6/bits/stl_function.h:209:23: error: passing ‘const Node’ as ‘this’ argument of ‘bool Node::operator==(Node)’ discards qualifiers [-fpermissive] make: *** [threeSum] Error 1
struct Key { std::string first; std::string second; int third; bool operator==(const Key &other) const { return (first == other.first && second == other.second && third == other.third); } };
namespace std { template <> struct hash<Key> { std::size_t operator()(const Key& k) const { using std::size_t; using std::hash; using std::string; return ((hash<string>()(k.first) ^ (hash<string>()(k.second) << 1)) >> 1) ^ (hash<int>()(k.third) << 1); } }; }
int main() { std::unordered_map<Key,std::string> m6 = { { {"John", "Doe", 12}, "example"}, { {"Mary", "Sue", 21}, "another"} }; }
struct KeyHasher { std::size_t operator()(const Key& k) const { using std::size_t; using std::hash; using std::string; return ((hash<string>()(k.first) ^ (hash<string>()(k.second) << 1)) >> 1) ^ (hash<int>()(k.third) << 1); } }; int main() { std::unordered_map<Key,std::string,KeyHasher> m6 = { { {"John", "Doe", 12}, "example"}, { {"Mary", "Sue", 21}, "another"} }; }
struct KeyHasher { std::size_t operator()(const Key& k) const { using boost::hash_value; using boost::hash_combine; std::size_t seed = 0; hash_combine(seed,hash_value(k.first)); hash_combine(seed,hash_value(k.second)); hash_combine(seed,hash_value(k.third)); return seed; } };
namespace std { template <> struct hash<Key> { size_t operator()( const Key& k ) const { size_t res = 17; res = res * 31 + hash<string>()( k.first ); res = res * 31 + hash<string>()( k.second ); res = res * 31 + hash<int>()( k.third ); return res; } }; }
struct test{ void f() &{ std::cout << "lvalue object\n"; } void f() &&{ std::cout << "rvalue object\n"; } }; int main(){ test t; t.f(); test().f(); }
$ clang++ -std=c++0x -stdlib=libc++ -Wall -pedantic t.cpp $ ./a.out lvalue object rvalue object
struct test2{ std::unique_ptr<int[]> heavy_resource; test2() : heavy_resource(new int[500]) {} operator std::unique_ptr<int[]>() const&{ std::unique_ptr<int[]> p(new int[500]); for(int i=0; i < 500; ++i) p[i] = heavy_resource[i]; return p; } operator std::unique_ptr<int[]>() &&{ return std::move(heavy_resource); } };
struct foo{ foo& operator<<(void*); }; foo& operator<<(foo&, char const*);
struct test{ void f() { std::cout << "lvalue or rvalue object\n"; } }; int main(){ test t; t.f(); test().f(); }
struct S { S& operator ++(); S* operator &(); }; S() = S(); S& foo = ++S(); &S();
struct S { S& operator ++() &; S* operator &() &; const S& operator =(const S&) &; };
Object foo; foo.RValueFunc(); Object().RValueFunc();
class X { std::vector<char> data_; public: std::vector<char> const & data() const & { return data_; } std::vector<char> && data() && { return data_; } }; X f(); X x; std::vector<char> a = x.data(); std::vector<char> b = f().data();
if(a.x == b.x && a.y == b.y) return true; return false;
if(std::find(v.begin(), v.end(), x) != v.end()) { } else { }
std::map<Key, Val> m; for (std::pair<Key, Val> const& item : m) { }
std::pair<Key, Val> __tmp = *iter; std::pair<Key, Val> const& item = __tmp;
std::function<bool(T, T)> cmp1 = std::bind(f, _2, 10, _1); auto cmp2 = std::bind(f, _2, 10, _1); auto cmp3 = [](T a, T b){ return f(b, 10, a); }; std::stable_partition(begin(x), end(x), cmp?);
std::function<void()> task1 = []{std::cout << "hello";}; auto task2 = []{std::cout << " world\n";};
const auto resAuto = Ha + Vector3(0.,0.,j * 2.567); const Vector3 resVector3 = Ha + Vector3(0.,0.,j * 2.567); std::cout << "resAuto = " << resAuto <<std::endl; std::cout << "resVector3 = " << resVector3 <<std::endl;
struct A { virtual ~A() {} virtual A * Clone() { return new A; } }; struct B : public A { virtual A * Clone() { return new B; } }; int main() { A * a1 = new B; A * a2 = a1->Clone(); delete a2; delete a1; }
Base* p = new Derived(...); Base* p2 = new p->Base();
class Shape { public: virtual ~Shape() { } virtual void draw() = 0; virtual void move() = 0; virtual Shape* clone() const = 0; virtual Shape* create() const = 0; }; class Circle : public Shape { public: Circle* clone() const; Circle* create() const; }; Circle* Circle::clone() const { return new Circle(*this); } Circle* Circle::create() const { return new Circle(); }
using namespace std; class aClass { public: virtual aClass() { } }; int main() { aClass a; }
using namespace std; class aClass { public: aClass() { cout<<"aClass contructor\n"; } ~aClass() { cout<<"aClass destructor\n"; } }; class anotherClass:public aClass { public: anotherClass() { cout<<"anotherClass Constructor\n"; } ~anotherClass() { cout<<"anotherClass destructor\n"; } }; int main() { aClass* a; a=new anotherClass; delete a; getchar(); }
curlpp::Cleanup myCleanup; std::ostringstream os; os << curlpp::options::Url(std::string("http: string asAskedInQuestion = os.str();
using namespace std; int main( void ){ WSADATA wsaData; SOCKET Socket; SOCKADDR_IN SockAddr; int lineCount=0; int rowCount=0; struct hostent *host; locale local; char buffer[10000]; int i = 0 ; int nDataLength; string website_HTML; string url = "www.google.com"; string get_http = "GET / HTTP/1.1\r\nHost: " + url + "\r\nConnection: close\r\n\r\n"; if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0){ cout << "WSAStartup failed.\n"; system("pause"); } Socket=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); host = gethostbyname(url.c_str()); SockAddr.sin_port=htons(80); SockAddr.sin_family=AF_INET; SockAddr.sin_addr.s_addr = *((unsigned long*)host->h_addr); if(connect(Socket,(SOCKADDR*)(&SockAddr),sizeof(SockAddr)) != 0){ cout << "Could not connect"; system("pause"); } send(Socket,get_http.c_str(), strlen(get_http.c_str()),0 ); while ((nDataLength = recv(Socket,buffer,10000,0)) > 0){ int i = 0; while (buffer[i] >= 32 || buffer[i] == website_HTML+=buffer[i]; i += 1; } } closesocket(Socket); WSACleanup(); cout<<website_HTML; cout<<"\n\nPress ANY key to close.\n\n"; cin.ignore(); cin.get(); return 0; }
using std::string; HINSTANCE hInst; WSADATA wsaData; void mParseUrl(char *mUrl, string &serverName, string &filepath, string &filename); SOCKET connectToServer(char *szServerName, WORD portNum); int getHeaderLength(char *content); char *readUrl2(char *szUrl, long &bytesReturnedOut, char **headerOut); int main() { const int bufLen = 1024; char *szUrl = "http: long fileSize; char *memBuffer, *headerBuffer; FILE *fp; memBuffer = headerBuffer = NULL; if ( WSAStartup(0x101, &wsaData) != 0) return -1; memBuffer = readUrl2(szUrl, fileSize, &headerBuffer); printf("returned from readUrl\n"); printf("data returned:\n%s", memBuffer); if (fileSize != 0) { printf("Got some data\n"); fp = fopen("downloaded.file", "wb"); fwrite(memBuffer, 1, fileSize, fp); fclose(fp); delete(memBuffer); delete(headerBuffer); } WSACleanup(); return 0; } void mParseUrl(char *mUrl, string &serverName, string &filepath, string &filename) { string::size_type n; string url = mUrl; if (url.substr(0,7) == "http: url.erase(0,7); if (url.substr(0,8) == "https: url.erase(0,8); n = url.find( if (n != string::npos) { serverName = url.substr(0,n); filepath = url.substr(n); n = filepath.rfind( filename = filepath.substr(n+1); } else { serverName = url; filepath = "/"; filename = ""; } } SOCKET connectToServer(char *szServerName, WORD portNum) { struct hostent *hp; unsigned int addr; struct sockaddr_in server; SOCKET conn; conn = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (conn == INVALID_SOCKET) return NULL; if(inet_addr(szServerName)==INADDR_NONE) { hp=gethostbyname(szServerName); } else { addr=inet_addr(szServerName); hp=gethostbyaddr((char*)&addr,sizeof(addr),AF_INET); } if(hp==NULL) { closesocket(conn); return NULL; } server.sin_addr.s_addr=*((unsigned long*)hp->h_addr); server.sin_family=AF_INET; server.sin_port=htons(portNum); if(connect(conn,(struct sockaddr*)&server,sizeof(server))) { closesocket(conn); return NULL; } return conn; } int getHeaderLength(char *content) { const char *srchStr1 = "\r\n\r\n", *srchStr2 = "\n\r\n\r"; char *findPos; int ofset = -1; findPos = strstr(content, srchStr1); if (findPos != NULL) { ofset = findPos - content; ofset += strlen(srchStr1); } else { findPos = strstr(content, srchStr2); if (findPos != NULL) { ofset = findPos - content; ofset += strlen(srchStr2); } } return ofset; } char *readUrl2(char *szUrl, long &bytesReturnedOut, char **headerOut) { const int bufSize = 512; char readBuffer[bufSize], sendBuffer[bufSize], tmpBuffer[bufSize]; char *tmpResult=NULL, *result; SOCKET conn; string server, filepath, filename; long totalBytesRead, thisReadSize, headerLen; mParseUrl(szUrl, server, filepath, filename); conn = connectToServer((char*)server.c_str(), 80); sprintf(tmpBuffer, "GET %s HTTP/1.0", filepath.c_str()); strcpy(sendBuffer, tmpBuffer); strcat(sendBuffer, "\r\n"); sprintf(tmpBuffer, "Host: %s", server.c_str()); strcat(sendBuffer, tmpBuffer); strcat(sendBuffer, "\r\n"); strcat(sendBuffer, "\r\n"); send(conn, sendBuffer, strlen(sendBuffer), 0); printf("Buffer being sent:\n%s", sendBuffer); totalBytesRead = 0; while(1) { memset(readBuffer, 0, bufSize); thisReadSize = recv (conn, readBuffer, bufSize, 0); if ( thisReadSize <= 0 ) break; tmpResult = (char*)realloc(tmpResult, thisReadSize+totalBytesRead); memcpy(tmpResult+totalBytesRead, readBuffer, thisReadSize); totalBytesRead += thisReadSize; } headerLen = getHeaderLength(tmpResult); long contenLen = totalBytesRead-headerLen; result = new char[contenLen+1]; memcpy(result, tmpResult+headerLen, contenLen); result[contenLen] = 0x0; char *myTmp; myTmp = new char[headerLen+1]; strncpy(myTmp, tmpResult, headerLen); myTmp[headerLen] = NULL; delete(tmpResult); *headerOut = myTmp; bytesReturnedOut = contenLen; closesocket(conn); return(result); }
int main(int argc, char** argv) { auto response = cpr::Get(cpr::Url{"http: std::cout << response.text << std::endl; }
http->setHost("qt.nokia.com"); http->get(QUrl::toPercentEncoding("/index.html"));
CURL* c; c = curl_easy_init(); curl_easy_setopt( c, CURL_URL, "www.google.com" ); curl_easy_perform( c ); curl_easy_cleanup( c );
CURLplusplus client; string x = client.Get("http: string y = client.Get("http:
class CURLplusplus { private: CURL* curl; stringstream ss; long http_code; public: CURLplusplus() : curl(curl_easy_init()) , http_code(0) { } ~CURLplusplus() { if (curl) curl_easy_cleanup(curl); } std::string Get(const std::string& url) { CURLcode res; curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data); curl_easy_setopt(curl, CURLOPT_WRITEDATA, this); ss.str(""); http_code = 0; res = curl_easy_perform(curl); if (res != CURLE_OK) { throw std::runtime_error(curl_easy_strerror(res)); } curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code); return ss.str(); } long GetHttpCode() { return http_code; } private: static size_t write_data(void *buffer, size_t size, size_t nmemb, void *userp) { return static_cast<CURLplusplus*>(userp)->Write(buffer,size,nmemb); } size_t Write(void *buffer, size_t size, size_t nmemb) { ss.write((const char*)buffer,size*nmemb); return size*nmemb; } };
using namespace web::http; using namespace web::http::client; int main(int argc, char** argv) { http_client client("http: http_response response; response = client.request(methods::GET, "/get").get(); std::cout << response.extract_string().get() << "\n"; response = client.request(methods::GET, "/get").get(); std::cout << "url: " << response.extract_json().get()[U("url")] << "\n"; }
using namespace std; int main (){ WSADATA wsaData; if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) { cout << "WSAStartup failed.\n"; system("pause"); return -1; } struct addrinfo hints; ZeroMemory(&hints, sizeof(hints)); hints.ai_family = AF_INET; hints.ai_protocol = IPPROTO_TCP; hints.ai_socktype = SOCK_STREAM; struct addrinfo* targetAdressInfo = NULL; DWORD getAddrRes = getaddrinfo("www.google.com", NULL, &hints, &targetAdressInfo); if (getAddrRes != 0 || targetAdressInfo == NULL) { cout << "Could not resolve the Host Name" << endl; system("pause"); WSACleanup(); return -1; } SOCKADDR_IN sockAddr; sockAddr.sin_addr = ((struct sockaddr_in*) targetAdressInfo->ai_addr)->sin_addr; sockAddr.sin_family = AF_INET; sockAddr.sin_port = htons(80); freeaddrinfo(targetAdressInfo); SOCKET webSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (webSocket == INVALID_SOCKET) { cout << "Creation of the Socket Failed" << endl; system("pause"); WSACleanup(); return -1; } cout << "Connecting...\n"; if(connect(webSocket, (SOCKADDR*)&sockAddr, sizeof(sockAddr)) != 0) { cout << "Could not connect"; system("pause"); closesocket(webSocket); WSACleanup(); return -1; } cout << "Connected.\n"; const char* httpRequest = "GET / HTTP/1.1\r\nHost: www.google.com\r\nConnection: close\r\n\r\n"; int sentBytes = send(webSocket, httpRequest, strlen(httpRequest),0); if (sentBytes < strlen(httpRequest) || sentBytes == SOCKET_ERROR) { cout << "Could not send the request to the Server" << endl; system("pause"); closesocket(webSocket); WSACleanup(); return -1; } char buffer[10000]; ZeroMemory(buffer, sizeof(buffer)); int dataLen; while ((dataLen = recv(webSocket, buffer, sizeof(buffer), 0) > 0)) { int i = 0; while (buffer[i] >= 32 || buffer[i] == cout << buffer[i]; i += 1; } } closesocket(webSocket); WSACleanup(); system("pause"); return 0; }
UrlRequest request; request.host("api.vk.com"); const auto countryId=1; const auto count=1000; request.uri("/method/database.getCities",{ {"lang","ru"}, {"country_id",countryId}, {"count",count}, {"need_all","1"}, }); request.addHeader("Content-Type: application/json"); auto response=std::move(request.perform()); if(response.statusCode()==200){ cout<<"status code = "<<response.statusCode()<<", body = *"<<response.body()<<"*"<<endl; }else{ cout<<"status code = "<<response.statusCode()<<", description = "<<response.statusDescription()<<endl; }
HINTERNET hOpenHandle, hResourceHandle, hConnectHandle; const TCHAR* szHeaders = _T("Content-Type:application/json; charset=utf-8\r\n"); hOpenHandle = InternetOpen(_T("HTTPS"), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0); if (hOpenHandle == NULL) { return false; } hConnectHandle = InternetConnect(hOpenHandle, GATEWAY, INTERNET_DEFAULT_HTTPS_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 1); if (hConnectHandle == NULL) { InternetCloseHandle(hOpenHandle); return false; } hResourceHandle = HttpOpenRequest(hConnectHandle, _T("POST"), GATEWAY, NULL, NULL, NULL, INTERNET_FLAG_SECURE | INTERNET_FLAG_KEEP_CONNECTION, 1); if (hResourceHandle == NULL) { InternetCloseHandle(hOpenHandle); InternetCloseHandle(hConnectHandle); return false; } InternetSetOption(hResourceHandle, INTERNET_OPTION_USERNAME, (LPVOID)USERNAME, _tcslen(USERNAME)); InternetSetOption(hResourceHandle, INTERNET_OPTION_PASSWORD, (LPVOID)PASSWORD, _tcslen(PASSWORD)); std::string buf; if (HttpSendRequest(hResourceHandle, szHeaders, 0, NULL, 0)) { while (true) { std::string part; DWORD size; if (!InternetQueryDataAvailable(hResourceHandle, &size, 0, 0))break; if (size == 0)break; part.resize(size); if (!InternetReadFile(hResourceHandle, &part[0], part.size(), &size))break; if (size == 0)break; part.resize(size); buf.append(part); } } if (!buf.empty()) { } InternetCloseHandle(hResourceHandle); InternetCloseHandle(hConnectHandle); InternetCloseHandle(hOpenHandle);
std::vector<char> download(std::string url, long* responseCode = nullptr);
using namespace std; size_t callback(void* contents, size_t size, size_t nmemb, void* user) { auto chunk = reinterpret_cast<char*>(contents); auto buffer = reinterpret_cast<vector<char>*>(user); size_t priorSize = buffer->size(); size_t sizeIncrease = size * nmemb; buffer->resize(priorSize + sizeIncrease); std::copy(chunk, chunk + sizeIncrease, buffer->data() + priorSize); return sizeIncrease; } vector<char> download(string url, long* responseCode) { vector<char> data; curl_global_init(CURL_GLOBAL_ALL); CURL* handle = curl_easy_init(); curl_easy_setopt(handle, CURLOPT_URL, url.c_str()); curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, callback); curl_easy_setopt(handle, CURLOPT_WRITEDATA, &data); curl_easy_setopt(handle, CURLOPT_USERAGENT, "libcurl-agent/1.0"); CURLcode result = curl_easy_perform(handle); if (responseCode != nullptr) curl_easy_getinfo(handle, CURLINFO_RESPONSE_CODE, responseCode); curl_easy_cleanup(handle); curl_global_cleanup(); if (result != CURLE_OK) { stringstream err; err << "Error downloading from URL \"" << url << "\": " << curl_easy_strerror(result); throw runtime_error(err.str()); } return move(data); }
HRESULT hr; CComPtr<IXMLHTTPRequest> request; hr = request.CoCreateInstance(CLSID_XMLHTTP60); hr = request->open( _bstr_t("GET"), _bstr_t("https: _variant_t(VARIANT_FALSE), _variant_t(), _variant_t()); hr = request->send(_variant_t()); long status; hr = request->get_status(&status); VARIANT responseVariant; hr = request->get_responseStream(&responseVariant); IStream* stream = (IStream*)responseVariant.punkVal; CImage *image = new CImage(); image->Load(stream); stream->Release();
using namespace std; ... IStream* stream; HRESULT result = URLOpenBlockingStream(0, "http: if (result != 0) { return 1; } char buffer[100]; unsigned long bytesRead; stringstream ss; stream->Read(buffer, 100, &bytesRead); while (bytesRead > 0U) { ss.write(buffer, (long long)bytesRead); stream->Read(buffer, 100, &bytesRead); } stream.Release(); string resultString = ss.str();
bcl::init(); bcl::execute<std::string>([&](bcl::Request *req) { bcl::setOpts(req, CURLOPT_URL , "http: CURLOPT_FOLLOWLOCATION, 1L, CURLOPT_WRITEFUNCTION, &bcl::writeContentCallback, CURLOPT_WRITEDATA, req->dataPtr, CURLOPT_USERAGENT, "libcurl-agent/1.0", CURLOPT_RANGE, "0-200000" ); }, [&](bcl::Response * resp) { std::string ret = std::string(resp->getBody<std::string>()->c_str()); printf("Sync === %s\n", ret.c_str()); }); bcl::cleanUp();
int main(int argc, ACE_TCHAR* argv[]) { char* szRequest = "GET /video/nice.mp4 HTTP/1.1\r\nHost: example.com\r\n\r\n"; int ilen = strlen(szRequest); char output[16*1024]; ACE_INET_Addr server (80, "example.com"); ACE_SOCK_Stream peer; ACE_SOCK_Connector connector; int ires = connector.connect(peer, server); int sum = 0; peer.send(szRequest, ilen); while (true) { ACE_Time_Value timeout = ACE_Time_Value(15); int rc = peer.recv_n(output, 16*1024, &timeout); if (rc == -1) { break; } sum += rc; } peer.close(); printf("Bytes transffered: %d",sum); return 0; }
const double PI = 3.141592653589793; constexpr double PI = 3.141592653589793;
const double PI1 = 3.141592653589793; constexpr double PI2 = 3.141592653589793;
struct S { constexpr S(int); }; const S s0(0); constexpr S s1(1);
int sz; constexpr auto arraySize1 = sz; std::array<int, sz> data1; constexpr auto arraySize2 = 10; std::array<int, arraySize2> data2;
int sz; const auto arraySize = sz; std::array<int, arraySize> data;
￼constexpr int max = 100; void use(int n) { constexpr int c1 = max+7; constexpr int c2 = n+7; }
￼constexpr int max = 100; void use(int n) { constexpr int c1 = max+7; const int c2 = n+7; c2 = 7; }
for (std::list<item*>::iterator i=items.begin();i!=items.end();i++) { bool isActive = (*i)->update(); other_code_involving(*i); } items.remove_if(CheckItemNotActive);
std::list<item*>::iterator i = items.begin(); while (i != items.end()) { bool isActive = (*i)->update(); if (!isActive) { items.erase(i++); } else { other_code_involving(*i); ++i; } }
// std::list< item * >::iterator iter = items.begin(); std::list< item * >::iterator end = items.end(); while (iter != items.end()) { item * pItem = *iter; if (pItem->update() == true) { other_code_involving(pItem); ++iter; } else { iter = items.erase(iter); } }
// // bool Item::update(void) { if (m_needsUpdates == true) { m_needsUpdates = other_code_involving(this); } return (m_needsUpdates); } items.remove_if(std::not1(std::mem_fun(&Item::update)));
typedef std::list<item*>::iterator item_iterator; for(item_iterator i = items.begin(); i != items.end(); ++i) { bool isActive = (*i)->update(); if (!isActive) { items.erase(i--); } else { other_code_involving(*i); } }
for(auto i = items.begin(); i != items.end();) { if(bool isActive = (*i)->update()) { other_code_involving(*i); ++i; } else { i = items.erase(i); } } items.remove_if(CheckItemNotActive);
std::list<item*>::iterator i = items.begin(); while (i != items.end()) { bool isActive = (*i)->update(); if (!isActive) { i = items.erase(i); } else { other_code_involving(*i); i++; } }
items.remove_if([] (item*i) { bool isActive = (*i)->update(); if (!isActive) return true; other_code_involving(*i); return false; });
items.erase(std::remove_if(begin(items), end(items), [] (item*i) { bool isActive = (*i)->update(); if (!isActive) return true; other_code_involving(*i); return false; }));
std::list<int> myList; int size = myList.size(); for (int i = 0; i < size; ++i) { int val = myList.back() myList.pop_back() if (val != 5) { myList.push_front(val) } }
list<int> lst{4, 1, 2, 3, 5}; auto it = lst.begin(); while (it != lst.end()){ if((*it % 2) == 1){ it = lst.erase(it); } else{ ++it; } } for(auto it:lst)cout<<it<<" "; cout<<endl;
list<int> lst{4, 1, 2, 3, 5}; lst.remove_if([](int a){return a % 2 == 1;}); for(auto it:lst)cout<<it<<" "; cout<<endl;
list<int> lst{4, 1, 2, 3, 5}; lst.erase(std::remove_if(lst.begin(), lst.end(), [](int a){ return a % 2 == 1; }), lst.end()); for(auto it:lst)cout<<it<<" "; cout<<endl;
list<int> lst{4, 1, 2, 3, 5}; for(auto it = lst.begin(); it != lst.end();++it){ if ((*it % 2) == 1){ it = lst.erase(it); erase and go to next(erase will return the next iterator) --it; } } for(auto it:lst)cout<<it<<" "; cout<<endl;
for (std::list<CAudioChannel *>::iterator itAudioChannel = audioChannels.begin(); itAudioChannel != audioChannels.end(); ) { CAudioChannel *audioChannel = *itAudioChannel; std::list<CAudioChannel *>::iterator itCurrentAudioChannel = itAudioChannel; itAudioChannel++; if (audioChannel->destroyMe) { audioChannels.erase(itCurrentAudioChannel); delete audioChannel; continue; } audioChannel->Mix(outBuffer, numSamples); }
int main() { int n; [&](){n = 10;}(); [=]() mutable {n = 20;}(); std::cout << n << "\n"; }
class unnamed1 { int& n; public: unnamed1(int& N) : n(N) {} /* OK. Your this is const but you don but the value pointed by it. You wouldn anyway even if your operator() was mutable. When you assign a reference it will always point to the same var. */ void operator()() const {n = 10;} }; class unnamed2 { int n; public: unnamed2(int N) : n(N) {} /* OK. Your this pointer is not const (since your operator() is "mutable" instead of const). So you can modify the "n" member. */ void operator()() {n = 20;} }; class unnamed3 { int n; public: unnamed3(int N) : n(N) {} void operator()() const {n = 10;} }; int main() { int n; unnamed1 u1(n); u1(); unnamed2 u2(n); u2(); std::cout << n << "\n"; }
void registerCallback(std::function<void()> f) { } void doSomething() { std::string name = receiveName(); registerCallback([name]{ }); }
int val = 0; auto x = [=](item e) { use(e,++val); }; auto y = [val](item e) { use(e,++val); };
int main(int argc, char *argv[]) { cout << "There are " << argc << " arguments:" << endl; for (int i=0; i<argc; i++) cout << i << " " << argv[i] << endl; return 0; }
int _tmain(int argc, char *argv[]) { cout << "There are " << argc << " arguments:" << endl; for (int i=0; i<argc; i++) cout << i << " " << argv[i] << endl; return 0; }
int _tmain(int argc, _TCHAR *argv[]) { _tcout << _T("There are ") << argc << _T(" arguments:") << std::endl; for (int i=0; i<argc; i++) _tcout << i << _T(" ") << argv[i] << std::endl; return 0; }
cout << _T( "There are " ) << argc << _T( " arguments:" ) << endl;
char non_repeating_char(std::string str){ while(str.size() >= 2){ std::vector<size_t> rmlist; for(size_t i = 1; i < str.size(); i++){ if(str[0] == str[i]) { rmlist.push_back(i); } } if(rmlist.size()){ size_t s = 0; str.erase(str.begin() + 0); ++s; for (size_t j : rmlist){ str.erase(str.begin() + (j-s)); ++s; } continue; } return str[0]; } if(str.size() == 1) return str[0]; else return -1; } int main(int argc, char ** args) { std::string test = "FabaccdbefafFG"; test = args[1]; char non_repeating = non_repeating_char(test); Std::cout << non_repeating << }
std::vector<std::string> getNextLineAndSplitIntoTokens(std::istream& str) { std::vector<std::string> result; std::string line; std::getline(str,line); std::stringstream lineStream(line); std::string cell; while(std::getline(lineStream,cell, { result.push_back(cell); } if (!lineStream && cell.empty()) { result.push_back(""); } return result; }
class CSVRow { public: std::string const& operator[](std::size_t index) const { return m_data[index]; } std::size_t size() const { return m_data.size(); } void readNextRow(std::istream& str) { std::string line; std::getline(str, line); std::stringstream lineStream(line); std::string cell; m_data.clear(); while(std::getline(lineStream, cell, { m_data.push_back(cell); } if (!lineStream && cell.empty()) { m_data.push_back(""); } } private: std::vector<std::string> m_data; }; std::istream& operator>>(std::istream& str, CSVRow& data) { data.readNextRow(str); return str; } int main() { std::ifstream file("plop.csv"); CSVRow row; while(file >> row) { std::cout << "4th Element(" << row[3] << ")\n"; } }
class CSVIterator { public: typedef std::input_iterator_tag iterator_category; typedef CSVRow value_type; typedef std::size_t difference_type; typedef CSVRow* pointer; typedef CSVRow& reference; CSVIterator(std::istream& str) :m_str(str.good()?&str:NULL) { ++(*this); } CSVIterator() :m_str(NULL) {} CSVIterator& operator++() {if (m_str) { if (!((*m_str) >> m_row)){m_str = NULL;}}return *this;} CSVIterator operator++(int) {CSVIterator tmp(*this);++(*this);return tmp;} CSVRow const& operator*() const {return m_row;} CSVRow const* operator->() const {return &m_row;} bool operator==(CSVIterator const& rhs) {return ((this == &rhs) || ((this->m_str == NULL) && (rhs.m_str == NULL)));} bool operator!=(CSVIterator const& rhs) {return !((*this) == rhs);} private: std::istream* m_str; CSVRow m_row; }; int main() { std::ifstream file("plop.csv"); for(CSVIterator loop(file); loop != CSVIterator(); ++loop) { std::cout << "4th Element(" << (*loop)[3] << ")\n"; } }
std::vector<std::string> vec; using namespace boost; tokenizer<escaped_list_separator<char> > tk( line, escaped_list_separator<char>( for (tokenizer<escaped_list_separator<char> >::iterator i(tk.begin()); i!=tk.end();++i) { vec.push_back(*i); }
enum class CSVState { UnquotedField, QuotedField, QuotedQuote }; std::vector<std::string> readCSVRow(const std::string &row) { CSVState state = CSVState::UnquotedField; std::vector<std::string> fields {""}; size_t i = 0; for (char c : row) { switch (state) { case CSVState::UnquotedField: switch (c) { case fields.push_back(""); i++; break; case break; default: fields[i].push_back(c); break; } break; case CSVState::QuotedField: switch (c) { case break; default: fields[i].push_back(c); break; } break; case CSVState::QuotedQuote: switch (c) { case fields.push_back(""); i++; state = CSVState::UnquotedField; break; case fields[i].push_back( state = CSVState::QuotedField; break; default: state = CSVState::UnquotedField; break; } break; } } return fields; } std::vector<std::vector<std::string>> readCSV(std::istream &in) { std::vector<std::vector<std::string>> table; std::string row; while (!in.eof()) { std::getline(in, row); if (in.bad() || in.fail()) { break; } auto fields = readCSVRow(row); table.push_back(fields); } return table; }
void foo() { std::string data = "1,2,3,4,5\n" "0,2,4,6,8\n" "1,3,5,7,9\n"; strtk::token_grid grid(data,data.size(),","); for(std::size_t i = 0; i < grid.row_count(); ++i) { strtk::token_grid::row_type r = grid.row(i); for(std::size_t j = 0; j < r.size(); ++j) { std::cout << r.get<int>(j) << "\t"; } std::cout << std::endl; } std::cout << std::endl; }
bool r = phrase_parse(first, last, ( double_ % ) , space, v);
int main() { using namespace std; using namespace boost; string data("data.csv"); ifstream in(data.c_str()); if (!in.is_open()) return 1; typedef tokenizer< escaped_list_separator<char> > Tokenizer; vector< string > vec; string line; while (getline(in,line)) { Tokenizer tok(line); vec.assign(tok.begin(),tok.end()); copy(vec.begin(), vec.end(), ostream_iterator<string>(cout, "|")); cout << "\n----------------------" << endl; } }
void ParseCSV(const string& csvSource, vector<vector<string> >& lines) { bool inQuote(false); bool newLine(false); string field; lines.clear(); vector<string> line; string::const_iterator aChar = csvSource.begin(); while (aChar != csvSource.end()) { switch (*aChar) { case newLine = false; inQuote = !inQuote; break; case newLine = false; if (inQuote == true) { field += *aChar; } else { line.push_back(field); field.clear(); } break; case case if (inQuote == true) { field += *aChar; } else { if (newLine == false) { line.push_back(field); lines.push_back(line); field.clear(); line.clear(); newLine = true; } } break; default: newLine = false; field.push_back(*aChar); break; } aChar++; } if (field.size()) line.push_back(field); if (line.size()) lines.push_back(line); }
const char input[] = "Year,Make,Model,Description,Price\n" "1997,Ford,E350,\"ac, abs, moon\",3000.00\n" "1999,Chevy,\"Venture \"\"Extended Edition\"\"\",\"\",4900.00\n" "1999,Chevy,\"Venture \"\"Extended Edition, Very Large\"\"\",\"\",5000.00\n" "1996,Jeep,Grand Cherokee,\"MUST SELL!\n\ air, moon roof, loaded\",4799.00\n" ;
std::istringstream ss(input); std::string title[5]; int year; std::string make, model, desc; float price; csv_istream(ss) >> title[0] >> title[1] >> title[2] >> title[3] >> title[4]; while (csv_istream(ss) >> year >> make >> model >> desc >> price) { }
struct csv_istream { std::istream &is_; csv_istream (std::istream &is) : is_(is) {} void scan_ws () const { while (is_.good()) { int c = is_.peek(); if (c != is_.get(); } } void scan (std::string *s = 0) const { std::string ws; int c = is_.get(); if (is_.good()) { do { if (c == if (s) { ws += c; if (c != *s += ws; ws.clear(); } } c = is_.get(); } while (is_.good()); if (is_.eof()) is_.clear(); } } template <typename T, bool> struct set_value { void operator () (std::string in, T &v) const { std::istringstream(in) >> v; } }; template <typename T> struct set_value<T, true> { template <bool SIGNED> void convert (std::string in, T &v) const { if (SIGNED) v = ::strtoll(in.c_str(), 0, 0); else v = ::strtoull(in.c_str(), 0, 0); } void operator () (std::string in, T &v) const { convert<is_signed_int<T>::val>(in, v); } }; template <typename T> const csv_istream & operator >> (T &v) const { std::string tmp; scan(&tmp); set_value<T, is_int<T>::val>()(tmp, v); return *this; } const csv_istream & operator >> (std::string &v) const { v.clear(); scan_ws(); if (is_.peek() != else { std::string tmp; is_.get(); std::getline(is_, tmp, while (is_.peek() == v += tmp; v += is_.get(); std::getline(is_, tmp, } v += tmp; scan(); } return *this; } template <typename T> const csv_istream & operator >> (T &(*manip)(T &)) const { is_ >> manip; return *this; } operator bool () const { return !is_.fail(); } };
template <typename T> struct is_signed_int { enum { val = false }; }; template <> struct is_signed_int<short> { enum { val = true}; }; template <> struct is_signed_int<int> { enum { val = true}; }; template <> struct is_signed_int<long> { enum { val = true}; }; template <> struct is_signed_int<long long> { enum { val = true}; }; template <typename T> struct is_unsigned_int { enum { val = false }; }; template <> struct is_unsigned_int<unsigned short> { enum { val = true}; }; template <> struct is_unsigned_int<unsigned int> { enum { val = true}; }; template <> struct is_unsigned_int<unsigned long> { enum { val = true}; }; template <> struct is_unsigned_int<unsigned long long> { enum { val = true}; }; template <typename T> struct is_int { enum { val = (is_signed_int<T>::val || is_unsigned_int<T>::val) }; };
int main(){ io::CSVReader<3> in("ram.csv"); in.read_header(io::ignore_extra_column, "vendor", "size", "speed"); std::string vendor; int size; double speed; while(in.read_row(vendor, size, speed)){ } }
for (auto row : csv<std::string, int, float>(file, std::cout << "first col: " << std::get<0>(row) << std::endl; }
namespace csvtools { template <std::size_t idx, class... fields> typename std::enable_if<idx >= std::tuple_size<std::tuple<fields...>>::value - 1>::type read_tuple(std::istream &in, std::tuple<fields...> &out, const char delimiter) { std::string cell; std::getline(in, cell, delimiter); std::stringstream cell_stream(cell); cell_stream >> std::get<idx>(out); } template <std::size_t idx, class... fields> typename std::enable_if<idx < std::tuple_size<std::tuple<fields...>>::value - 1>::type read_tuple(std::istream &in, std::tuple<fields...> &out, const char delimiter) { std::string cell; std::getline(in, cell, delimiter); std::stringstream cell_stream(cell); cell_stream >> std::get<idx>(out); read_tuple<idx + 1, fields...>(in, out, delimiter); } } template <class... fields> class csv { std::istream &_in; const char _delim; public: typedef std::tuple<fields...> value_type; class iterator; inline csv(std::istream &in, const char delim) : _in(in), _delim(delim) {} inline bool good() const { return _in.good(); } inline const std::istream &underlying_stream() const { return _in; } inline iterator begin(); inline iterator end(); private: inline value_type read_row() { std::string line; std::getline(_in, line); std::stringstream line_stream(line); std::tuple<fields...> retval; csvtools::read_tuple<0, fields...>(line_stream, retval, _delim); return retval; } }; template <class... fields> class csv<fields...>::iterator { csv::value_type _row; csv *_parent; public: typedef std::input_iterator_tag iterator_category; typedef csv::value_type value_type; typedef std::size_t difference_type; typedef csv::value_type * pointer; typedef csv::value_type & reference; inline iterator() : _parent(nullptr) {} inline iterator(csv &parent) : _parent(parent.good() ? &parent : nullptr) { ++(*this); } inline iterator &operator++() { if (_parent != nullptr) { _row = _parent->read_row(); if (!_parent->good()) { _parent = nullptr; } } return *this; } inline iterator operator++(int) { iterator copy = *this; ++(*this); return copy; } inline csv::value_type const &operator*() const { return _row; } inline csv::value_type const *operator->() const { return &_row; } bool operator==(iterator const &other) { return (this == &other) or (_parent == nullptr and other._parent == nullptr); } bool operator!=(iterator const &other) { return not (*this == other); } }; template <class... fields> typename csv<fields...>::iterator csv<fields...>::begin() { return iterator(*this); } template <class... fields> typename csv<fields...>::iterator csv<fields...>::end() { return iterator(); }
CsvParser parser = CsvParser(std::cin) .delimiter( .quote( .terminator(
using namespace aria::csv; int main() { std::ifstream f("some_file.csv"); CsvParser parser(f); for (auto& row : parser) { for (auto& field : row) { std::cout << field << " | "; } std::cout << std::endl; } }
extern const wchar_t *nextCsvField(const wchar_t *p, wchar_t sep, bool *newline); const wchar_t *nextCsvField(const wchar_t *p, wchar_t sep, bool *newline) { if ( p++; while (1) { p = wcschr(p, L if (!p || !p[1]) return 0; if (p[1] != break; p += 2; } } wchar_t newline_or_sep[4] = L"\n\r "; newline_or_sep[2] = sep; p = wcspbrk(p, newline_or_sep); if (!p) return 0; *newline = (p[0] == if (p[0] == p += 2; else p++; return p; } static wchar_t *csvFieldData(const wchar_t *fld_s, const wchar_t *fld_e, wchar_t *buffer, size_t buflen) { wchar_t *dst = buffer; wchar_t *end = buffer + buflen - 1; const wchar_t *src = fld_s; if (*src == L { const wchar_t *p = src + 1; while (p < fld_e && dst < end) { if (p[0] == L { *dst++ = p[0]; p += 2; } else if (p[0] == L { p++; break; } else *dst++ = *p++; } src = p; } while (src < fld_e && dst < end) *dst++ = *src++; if (dst >= end) return 0; *dst = L return(buffer); } static void dissect(const wchar_t *line) { const wchar_t *start = line; const wchar_t *next; bool eol; wprintf(L"Input %3zd: [%.*ls]\n", wcslen(line), wcslen(line)-1, line); while ((next = nextCsvField(start, L { wchar_t buffer[1024]; wprintf(L"Raw Field: [%.*ls] (eol = %d)\n", (next - start - eol), start, eol); if (csvFieldData(start, next-1, buffer, sizeof(buffer)/sizeof(buffer[0])) != 0) wprintf(L"Field %3zd: [%ls]\n", wcslen(buffer), buffer); start = next; } } static const wchar_t multiline[] = L"First field of first row,\"This field is multiline\n" "\n" "but that "is an escaped \"\" double quote\" but this one \"\" is not\n" " \"This is second field of second row, but it is not multiline\n" " because it doesn " with an immediate double quote\"\n" ; int main(void) { wchar_t line[1024]; while (fgetws(line, sizeof(line)/sizeof(line[0]), stdin)) dissect(line); dissect(multiline); return 0; }
bool fileExists(string fileName) { ifstream test; test.open(fileName.c_str()); if (test.fail()) { test.close(); return false; } else { test.close(); return true; } }
bool verifyExtension(string filename) { int period = 0; for (unsigned int i = 0; i < filename.length(); i++) { if (filename[i] == period = i; } string extension; for (unsigned int i = period; i < filename.length(); i++) extension += filename[i]; if (extension == ".csv") return true; else return false; }
string getExtension(string filename) { int period = 0; for (unsigned int i = 0; i < filename.length(); i++) { if (filename[i] == period = i; } string extension; if (period != 0) { for (unsigned int i = period; i < filename.length(); i++) extension += filename[i]; } else extension = "NO FILE"; return extension; }
void parseFile(string fileName) { if (fileExists(fileName) && verifyExtension(fileName)) { ifstream fs; fs.open(fileName.c_str()); string fileCommand; while (fs.good()) { string temp; getline(fs, fileCommand, for (unsigned int i = 0; i < fileCommand.length(); i++) { if (fileCommand[i] != temp += fileCommand[i]; else temp += " "; } if (temp != "\0") { } } fs.close(); } else if (!fileExists(fileName)) { cout << "Error: The provided file does not exist: " << fileName << endl; if (!verifyExtension(fileName)) { if (getExtension(fileName) != "NO FILE") cout << "\tCheck the file extension." << endl; else cout << "\tThere is no file in the provided path." << endl; } } else if (!verifyExtension(fileName)) { if (getExtension(fileName) != "NO FILE") cout << "Incorrect file extension provided: " << getExtension(fileName) << endl; else cout << "There is no file in the following path: " << fileName << endl; } }
/** Read line from a CSV file @param[in] fp file pointer to open file @param[in] vls reference to vector of strings to hold next line */ void readCSV( FILE *fp, std::vector<std::string>& vls ) { vls.clear(); if( ! fp ) return; char buf[10000]; if( ! fgets( buf,999,fp) ) return; std::string s = buf; int p,q; q = -1; while( 1 ) { p = q; q = s.find_first_of(",\n",p+1); if( q == -1 ) break; vls.push_back( s.substr(p+1,q-p-1) ); } } int _tmain(int argc, _TCHAR* argv[]) { std::vector<std::string> vls; FILE * fp = fopen( argv[1], "r" ); if( ! fp ) return 1; readCSV( fp, vls ); readCSV( fp, vls ); readCSV( fp, vls ); std::cout << "row 3, col 4 is " << vls[3].c_str() << "\n"; return 0; }
void loadFromCSV( const std::string& filename ) { std::ifstream file( filename.c_str() ); std::vector< std::vector<std::string> > matrix; std::vector<std::string> row; std::string line; std::string cell; while( file ) { std::getline(file,line); std::stringstream lineStream(line); row.clear(); while( std::getline( lineStream, cell, row.push_back( cell ); if( !row.empty() ) matrix.push_back( row ); } for( int i=0; i<int(matrix.size()); i++ ) { for( int j=0; j<int(matrix[i].size()); j++ ) std::cout << matrix[i][j] << " "; std::cout << std::endl; } }
FILE *fp; char str1[10], str2[10], str3[10], str4[10]; fp = fopen("G:\\data1.csv", "r"); if(NULL == fp) { printf("\nError in opening file."); return 0; } while(EOF != fscanf(fp, " %[^,], %[^,], %[^,], %s, %s, %s, %s ", str1, str2, str3, str4)) { printf("\n%s %s %s %s", str1, str2, str3, str4); } fclose(fp);
namespace qi = boost::spirit::qi; namespace bascii = boost::spirit::ascii; template <typename Iterator> struct csv_parser : qi::grammar<Iterator, std::vector<std::string>(), bascii::space_type> { qi::rule<Iterator, char() > COMMA; qi::rule<Iterator, char() > DDQUOTE; qi::rule<Iterator, std::string(), bascii::space_type > non_escaped; qi::rule<Iterator, std::string(), bascii::space_type > escaped; qi::rule<Iterator, std::string(), bascii::space_type > field; qi::rule<Iterator, std::vector<std::string>(), bascii::space_type > start; csv_parser() : csv_parser::base_type(start) { using namespace qi; using qi::lit; using qi::lexeme; using bascii::char_; start = field % field = escaped | non_escaped; escaped = lexeme[ non_escaped = lexeme[ *( char_ -(char_( DDQUOTE = lit("\"\"") [_val = COMMA = lit(",") [_val = } }; int main() { std::cout << "Enter CSV lines [empty] to quit\n"; using bascii::space; typedef std::string::const_iterator iterator_type; typedef csv_parser<iterator_type> csv_parser; csv_parser grammar; std::string str; int fid; while (getline(std::cin, str)) { fid = 0; if (str.empty()) break; std::vector<std::string> csv; std::string::const_iterator it_beg = str.begin(); std::string::const_iterator it_end = str.end(); bool r = phrase_parse(it_beg, it_end, grammar, space, csv); if (r && it_beg == it_end) { std::cout << "Parsing succeeded\n"; for (auto& field: csv) { std::cout << "field " << ++fid << ": " << field << std::endl; } } else { std::cout << "Parsing failed\n"; } } return 0; }
1,field 2,field 3, 1,field 2,"field 3 quoted, with separator", 1,field 2,"field 3 with newline", 1,field 2,"field 3 with newline and separator,",
read_csv_t csv; csv.open("../test.csv"); std::vector<std::string> row; while (true) { row = csv.read_row(); if (row.size() == 0) { break; } }
class read_csv_t { public: read_csv_t(); int open(const std::string &file_name); std::vector<std::string> read_row(); private: std::ifstream m_ifs; };
std::vector<std::string> read_csv_t::read_row() { bool quote_mode = false; std::vector<std::string> row; std::string column; char c; while (m_ifs.get(c)) { switch (c) { case if (quote_mode == true) { column += c; } else { row.push_back(column); column.clear(); } break; case quote_mode = !quote_mode; break; case case if (quote_mode == true) { column += c; } else { return row; } break; default: column += c; break; } } m_ifs.close(); std::vector<std::string> v; return v; }
void StringReplace(std::string& str, const std::string& oldStr, const std::string& newStr) { size_t pos = 0; while((pos = str.find(oldStr, pos)) != std::string::npos) { str.replace(pos, oldStr.length(), newStr); pos += newStr.length(); } } void LoadCSV(std::string &filename) { std::ifstream stream(filename); std::string in_line; std::string Field; std::string Chan; int ChanType; double Scale; int Import; while (std::getline(stream, in_line)) { StringReplace(in_line, ",", " "); std::stringstream line(in_line); line >> Field >> Chan >> ChanType >> Scale >> Import; if (Field.substr(0,2)!=" ShowMessage((String)Field.c_str() + "\n" + Chan.c_str() + "\n" + IntToStr(ChanType) + "\n" +FloatToStr(Scale) + "\n" +IntToStr(Import)); } } }
using namespace std; wstring trimquote(const wstring& str, const wstring& whitespace, const wchar_t quotChar) { wstring ws; wstring::size_type strBegin = str.find_first_not_of(whitespace); if (strBegin == wstring::npos) return L""; wstring::size_type strEnd = str.find_last_not_of(whitespace); wstring::size_type strRange = strEnd - strBegin + 1; if((str[strBegin] == quotChar) && (str[strEnd] == quotChar)) { ws = str.substr(strBegin+1, strRange-2); strBegin = 0; while((strEnd = ws.find(quotChar, strBegin)) != wstring::npos) { ws.erase(strEnd, 1); strBegin = strEnd+1; } } else ws = str.substr(strBegin, strRange); return ws; } pair<unsigned, unsigned> nextCSVQuotePair(const wstring& line, const wchar_t quotChar, unsigned ofs = 0) { pair<unsigned, unsigned> r; r.first = line.find(quotChar, ofs); r.second = wstring::npos; if(r.first != wstring::npos) { r.second = r.first; while(((r.second = line.find(quotChar, r.second+1)) != wstring::npos) && (line[r.second+1] == quotChar)) r.second++; } return r; } unsigned parseLine(vector<wstring>& fields, const wstring& line) { unsigned ofs, ofs0, np; const wchar_t delim = L const wstring whitespace = L" \t\xa0\x3000\x2000\x2001\x2002\x2003\x2004\x2005\x2006\x2007\x2008\x2009\x200a\x202f\x205f"; const wchar_t quotChar = L pair<unsigned, unsigned> quot; fields.clear(); ofs = ofs0 = 0; quot = nextCSVQuotePair(line, quotChar); while((np = line.find(delim, ofs)) != wstring::npos) { if((np > quot.first) && (np < quot.second)) { ofs = quot.second+1; quot = nextCSVQuotePair(line, quotChar, ofs); continue; } fields.push_back( trimquote(line.substr(ofs0, np-ofs0), whitespace, quotChar) ); ofs = ofs0 = np+1; } fields.push_back( trimquote(line.substr(ofs0), whitespace, quotChar) ); return fields.size(); }
using namespace std; /** * Parse a CSV data file and fill the 2d STL vector "data". * Limits: only "pure datas" of doubles, not encapsulated by " and without \n inside. * Further no formatting in the data (e.g. scientific notation) * It however handles both dots and commas as decimal separators and removes thousand separator. * * returnCodes[0]: file access 0-> ok 1-> not able to read; 2-> decimal separator equal to comma separator * returnCodes[1]: number of records * returnCodes[2]: number of fields. -1 If rows have different field size * */ vector<int> readCsvData (vector <vector <double>>& data, const string& filename, const string& delimiter, const string& decseparator){ int vv[3] = { 0,0,0 }; vector<int> returnCodes(&vv[0], &vv[0]+3); string rowstring, stringtoken; double doubletoken; int rowcount=0; int fieldcount=0; data.clear(); ifstream iFile(filename, ios_base::in); if (!iFile.is_open()){ returnCodes[0] = 1; return returnCodes; } while (getline(iFile, rowstring)) { if (rowstring=="") continue; rowcount ++; if(delimiter == decseparator){ returnCodes[0] = 2; return returnCodes; } if(decseparator != "."){ string::iterator end_pos = remove(rowstring.begin(), rowstring.end(), rowstring.erase(end_pos, rowstring.end()); replace(rowstring.begin(), rowstring.end(),decseparator.c_str()[0], } else { string::iterator end_pos = remove(rowstring.begin(), rowstring.end(), rowstring.erase(end_pos, rowstring.end()); } vector<double> tokens; string::size_type lastPos = rowstring.find_first_not_of(delimiter, 0); string::size_type pos = rowstring.find_first_of(delimiter, lastPos); while (string::npos != pos || string::npos != lastPos){ stringtoken = rowstring.substr(lastPos, pos - lastPos); if (stringtoken == "") { tokens.push_back(0.0); } else { istringstream totalSString(stringtoken); totalSString >> doubletoken; tokens.push_back(doubletoken); } lastPos = rowstring.find_first_not_of(delimiter, pos); pos = rowstring.find_first_of(delimiter, lastPos); } if(rowcount == 1){ fieldcount = tokens.size(); returnCodes[2] = tokens.size(); } else { if ( tokens.size() != fieldcount){ returnCodes[2] = -1; } } data.push_back(tokens); } iFile.close(); returnCodes[1] = rowcount; return returnCodes; }
namespace fusion = boost::fusion; struct CsvString { std::string value; friend std::istream& operator>>(std::istream& s, CsvString& v) { v.value.clear(); for(;;) { auto c = s.peek(); if(std::istream::traits_type::eof() == c || break; v.value.push_back(c); s.get(); } return s; } friend std::ostream& operator<<(std::ostream& s, CsvString const& v) { return s << v.value; } }; int main() { std::stringstream input("abc,123,true,3.14\n" "def,456,false,2.718\n"); typedef boost::tuple<CsvString, int, bool, double> CsvRow; using fusion::operator<<; std::cout << std::boolalpha; using fusion::operator>>; input >> std::boolalpha; input >> fusion::tuple_open("") >> fusion::tuple_close("\n") >> fusion::tuple_delimiter( for(CsvRow row; input >> row;) std::cout << row << }
struct CSVDict { std::vector< std::string > inputImages; std::vector< double > inputLabels; }; /** \brief Splits the string \param str String to split \param delim Delimiter on the basis of which splitting is to be done \return results Output in the form of vector of strings */ std::vector<std::string> stringSplit( const std::string &str, const std::string &delim ) { std::vector<std::string> results; for (size_t i = 0; i < str.length(); i++) { std::string tempString = ""; while ((str[i] != *delim.c_str()) && (i < str.length())) { tempString += str[i]; i++; } results.push_back(tempString); } return results; } /** \brief Parse the supplied CSV File and obtain Row and Column information. Assumptions: 1. Header information is in first row 2. Delimiters are only used to differentiate cell members \param csvFileName The full path of the file to parse \param inputColumns The string of input columns which contain the data to be used for further processing \param inputLabels The string of input labels based on which further processing is to be done \param delim The delimiters used in inputColumns and inputLabels \return Vector of Vector of strings: Collection of rows and columns */ std::vector< CSVDict > parseCSVFile( const std::string &csvFileName, const std::string &inputColumns, const std::string &inputLabels, const std::string &delim ) { std::vector< CSVDict > return_CSVDict; std::vector< std::string > inputColumnsVec = stringSplit(inputColumns, delim), inputLabelsVec = stringSplit(inputLabels, delim); std::vector< std::vector< std::string > > returnVector; std::ifstream inFile(csvFileName.c_str()); int row = 0; std::vector< size_t > inputColumnIndeces, inputLabelIndeces; for (std::string line; std::getline(inFile, line, { CSVDict tempDict; std::vector< std::string > rowVec; line.erase(std::remove(line.begin(), line.end(), rowVec = stringSplit(line, delim); if (row == 0) { for (size_t i = 0; i < rowVec.size(); i++) { for (size_t j = 0; j < inputColumnsVec.size(); j++) { if (rowVec[i] == inputColumnsVec[j]) { inputColumnIndeces.push_back(i); } } for (size_t j = 0; j < inputLabelsVec.size(); j++) { if (rowVec[i] == inputLabelsVec[j]) { inputLabelIndeces.push_back(i); } } } } else { for (size_t i = 0; i < inputColumnIndeces.size(); i++) { tempDict.inputImages.push_back(rowVec[inputColumnIndeces[i]]); } for (size_t i = 0; i < inputLabelIndeces.size(); i++) { double test = std::atof(rowVec[inputLabelIndeces[i]].c_str()); tempDict.inputLabels.push_back(std::atof(rowVec[inputLabelIndeces[i]].c_str())); } return_CSVDict.push_back(tempDict); } row++; } return return_CSVDict; }
std::ifstream t("file.txt"); std::string sin((std::istreambuf_iterator<char>(t)), std::istreambuf_iterator<char>());
std::regex word_regex(",\\s]+"); auto what = std::sregex_iterator(sin.begin(), sin.end(), word_regex); auto wend = std::sregex_iterator(); std::vector<std::string> v; for (;what!=wend ; wend) { std::smatch match = *what; v.push_back(match.str()); }
using namespace std; int main() { int A[100][10]; ifstream ifs; ifs.open("name_of_file.csv"); string s1; char c; for(int k=0; k<100; k++) { getline(ifs,s1); stringstream stream(s1); int j=0; while(1) { stream >>A[k][j]; stream >> c; j++; if(!stream) {break;} } } }
int main() { rapidcsv::Document doc("../tests/msft.csv"); std::vector<float> close = doc.GetColumn<float>("Close"); std::cout << "Read " << close.size() << " values." << std::endl; }
std::unique_ptr<SomeUserDefinedType> p(new SomeUserDefinedType(1, 2, 3));
auto p = std::make_unique<SomeUserDefinedType>(1, 2, 3);
template<typename T, typename... Args> std::unique_ptr<T> make_unique(Args&&... args) { return std::unique_ptr<T>(new T(std::forward<Args>(args)...)); }
template <typename T, typename... Args> std::unique_ptr<T> make_unique_helper(std::false_type, Args&&... args) { return std::unique_ptr<T>(new T(std::forward<Args>(args)...)); } template <typename T, typename... Args> std::unique_ptr<T> make_unique_helper(std::true_type, Args&&... args) { static_assert(std::extent<T>::value == 0, "make_unique<T[N]>() is forbidden, please use make_unique<T[]>()."); typedef typename std::remove_extent<T>::type U; return std::unique_ptr<T>(new U[sizeof...(Args)]{std::forward<Args>(args)...}); } template <typename T, typename... Args> std::unique_ptr<T> make_unique(Args&&... args) { return make_unique_helper<T>(std::is_array<T>(), std::forward<Args>(args)...); }
std::forward<Args>(args)... -> std::forward<int>(1), std::forward<int>(2), std::forward<int>(3) std::forward<Args...>(args...) -> std::forward<int, int, int>(1,2,3)
auto a = make_unique<int[100]>(); auto b = make_unique<int[100]>(1,2,3);
const unsigned long long size = 64ULL*1024ULL*1024ULL; unsigned long long a[size]; int main() { std::fstream myfile; myfile = std::fstream("file.binary", std::ios::out | std::ios::binary); for(int i = 0; i < 32; ++i){ myfile.write((char*)&a,size*sizeof(unsigned long long)); } myfile.close(); }
const unsigned long long size = 8ULL*1024ULL*1024ULL; unsigned long long a[size]; int main() { FILE* pFile; pFile = fopen("file.binary", "wb"); for (unsigned long long j = 0; j < 1024; ++j){ fwrite(a, 1, size*sizeof(unsigned long long), pFile); } fclose(pFile); return 0; }
std::vector<uint64_t> GenerateData(std::size_t bytes) { assert(bytes % sizeof(uint64_t) == 0); std::vector<uint64_t> data(bytes / sizeof(uint64_t)); std::iota(data.begin(), data.end(), 0); std::shuffle(data.begin(), data.end(), std::mt19937{ std::random_device{}() }); return data; } long long option_1(std::size_t bytes) { std::vector<uint64_t> data = GenerateData(bytes); auto startTime = std::chrono::high_resolution_clock::now(); auto myfile = std::fstream("file.binary", std::ios::out | std::ios::binary); myfile.write((char*)&data[0], bytes); myfile.close(); auto endTime = std::chrono::high_resolution_clock::now(); return std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count(); } long long option_2(std::size_t bytes) { std::vector<uint64_t> data = GenerateData(bytes); auto startTime = std::chrono::high_resolution_clock::now(); FILE* file = fopen("file.binary", "wb"); fwrite(&data[0], 1, bytes, file); fclose(file); auto endTime = std::chrono::high_resolution_clock::now(); return std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count(); } long long option_3(std::size_t bytes) { std::vector<uint64_t> data = GenerateData(bytes); std::ios_base::sync_with_stdio(false); auto startTime = std::chrono::high_resolution_clock::now(); auto myfile = std::fstream("file.binary", std::ios::out | std::ios::binary); myfile.write((char*)&data[0], bytes); myfile.close(); auto endTime = std::chrono::high_resolution_clock::now(); return std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count(); } int main() { const std::size_t kB = 1024; const std::size_t MB = 1024 * kB; const std::size_t GB = 1024 * MB; for (std::size_t size = 1 * MB; size <= 4 * GB; size *= 2) std::cout << "option1, " << size / MB << "MB: " << option_1(size) << "ms" << std::endl; for (std::size_t size = 1 * MB; size <= 4 * GB; size *= 2) std::cout << "option2, " << size / MB << "MB: " << option_2(size) << "ms" << std::endl; for (std::size_t size = 1 * MB; size <= 4 * GB; size *= 2) std::cout << "option3, " << size / MB << "MB: " << option_3(size) << "ms" << std::endl; return 0; }
64 * 1024 * 1024 * 8 /*sizeof(unsigned long long) */ * 32 = 16G = 16G/63 = 260M/s
using namespace std; int main() { FILE* stream = fopen("binary", "w"); for(int loop=0;loop < 32;++loop) { fwrite(a, sizeof(unsigned long long), size, stream); } fclose(stream); }
const unsigned long long size = 64ULL*1024ULL*1024ULL; unsigned long long a[size]; int main() { int data = open("test", O_WRONLY | O_CREAT, 0777); for(int loop = 0; loop < 32; ++loop) { write(data, a, size * sizeof(unsigned long long)); } close(data); }
int main() { std::ifstream input("input"); std::ofstream output("ouptut"); output << input.rdbuf(); }
------------------------------------------------> FF|WWWWWWWW|FF|WWWWWWWW|FF|WWWWWWWW|FF|WWWWWWWW|
------------------------------------------------> (main thread, fills buffers) FF|ff______|FF______|ff______|________| ------------------------------------------------> (writer thread) |WWWWWWWW|wwwwwwww|WWWWWWWW|wwwwwwww|
------------------------------------------------> (main thread, fills buffers) FF|fX| ------------------------------------------------> (writer thread) __|X|
int main () { FILE * pFile; char buffer[] = { pFile = fopen ( "myfile.bin" , "w+b" ); fwrite (buffer , 1 , sizeof(buffer) , pFile ); fclose (pFile); return 0; }
int main(void) { int filedesc = open("testfile.txt", O_WRONLY | O_APPEND); if (filedesc < 0) { return -1; } if (write(filedesc, "This will be output to testfile.txt\n", 36) != 36) { write(2, "There was an error writing to testfile.txt\n", 43); return -1; } return 0; }
using namespace std; using namespace std::chrono; const size_t sz = 512 * 1024 * 1024; const int numiter = 20; const size_t bufsize = 1024 * 1024; int main(int argc, char**argv) { unique_ptr<char[]> data(new char[sz]); unique_ptr<char[]> buf(new char[bufsize]); for (size_t p = 0; p < sz; p += 16) { memcpy(&data[p], "BINARY.DATA.....", 16); } unlink("file.binary"); int64_t total = 0; if (argc < 2 || strcmp(argv[1], "fopen") != 0) { cout << "fstream mode\n"; ofstream myfile("file.binary", ios::out | ios::binary); if (!myfile) { cerr << "open failed\n"; return 1; } myfile.rdbuf()->pubsetbuf(buf.get(), bufsize); for (int i = 0; i < numiter; ++i) { auto tm1 = high_resolution_clock::now(); myfile.write(data.get(), sz); if (!myfile) cerr << "write failed\n"; auto tm = (duration_cast<milliseconds>(high_resolution_clock::now() - tm1).count()); cout << tm << " ms\n"; total += tm; } myfile.close(); } else { cout << "fopen mode\n"; FILE* pFile = fopen("file.binary", "wb"); if (!pFile) { cerr << "open failed\n"; return 1; } setvbuf(pFile, buf.get(), _IOFBF, bufsize); auto tm1 = high_resolution_clock::now(); for (int i = 0; i < numiter; ++i) { auto tm1 = high_resolution_clock::now(); if (fwrite(data.get(), sz, 1, pFile) != 1) cerr << "write failed\n"; auto tm = (duration_cast<milliseconds>(high_resolution_clock::now() - tm1).count()); cout << tm << " ms\n"; total += tm; } fclose(pFile); auto tm2 = high_resolution_clock::now(); } cout << "Total: " << total << " ms, " << (sz*numiter * 1000 / (1024.0 * 1024 * total)) << " MB/s\n"; }
wfstream f; const size_t nBufferSize = 16184; wchar_t buffer[nBufferSize]; f.rdbuf()->pubsetbuf(buffer, nBufferSize);
void f() { srand(time(0)); vector<double> v(300000); generate_n(v.begin(), v.size(), &random); sort(v.begin(), v.end()); sort(v.rbegin(), v.rend()); sort(v.begin(), v.end()); sort(v.rbegin(), v.rend()); }
int maxof(int n_args, ...) { va_list ap; va_start(ap, n_args); int max = va_arg(ap, int); for(int i = 2; i <= n_args; i++) { int a = va_arg(ap, int); if(a > max) max = a; } va_end(ap); return max; }
template <typename T> void func(T t) { std::cout << t << std::endl ; } template<typename T, typename... Args> void func(T t, Args... args) { std::cout << t <<std::endl ; func(args...) ; } template <class T> void func2( std::initializer_list<T> list ) { for( auto elem : list ) { std::cout << elem << std::endl ; } } int main() { std::string str1( "Hello" ), str2( "world" ); func(1,2.5, func2( {10, 20, 30, 40 }) ; func2( {str1, str2 } ) ; }
std::cout << __PRETTY_FUNCTION__ << ": " << t <<std::endl ;
void func(T, Args...) [T = int, Args = <double, char, std::basic_string<char>>]: 1 void func(T, Args...) [T = double, Args = <char, std::basic_string<char>>]: 2.5 void func(T, Args...) [T = char, Args = <std::basic_string<char>>]: a void func(T) [T = std::basic_string<char>]: Hello
template <class T> void func1( std::vector<T> vec ) { for( typename std::vector<T>::iterator iter = vec.begin(); iter != vec.end(); ++iter ) { std::cout << *iter << std::endl ; } } int main() { int arr1[] = {10, 20, 30, 40} ; std::string arr2[] = { "hello", "world" } ; std::vector<int> v1( arr1, arr1+4 ) ; std::vector<std::string> v2( arr2, arr2+2 ) ; func1( v1 ) ; func1( v2 ) ; }
void simple_printf(const char *fmt, ...) { va_list args; va_start(args, fmt); while (*fmt != if (*fmt == int i = va_arg(args, int); std::cout << i << } else if (*fmt == char * s = va_arg(args, char*); std::cout << s << } ++fmt; } va_end(args); } int main() { std::string str1( "Hello" ), str2( "world" ); simple_printf("dddd", 10, 20, 30, 40 ); simple_printf("ss", str1.c_str(), str2.c_str() ); return 0 ; }
template <typename T> void f(std::vector<T> const&); std::vector<int> my_args; my_args.push_back(1); my_args.push_back(2); f(my_args);
void foo(const std::list<std::string> & myArguments) { } foo({"arg1","arg2"});
void myfunc( int i = 0, int j = 1, int k = 2 ); myfunc(); myfunc( 2 ); myfunc( 2, 1 ); myfunc( 2, 1, 0 );
template<class... Args> void print(Args... args) { (std::cout << ... << args) << "\n"; } print(1,
template<class Head, class... Tail> using are_same = std::conjunction<std::is_same<Head, Tail>...>; template<class Head, class... Tail, class = std::enable_if_t<are_same<Head, Tail...>::value, void>> void print_same_type(Head head, Tail... tail) { std::cout << head; (std::cout << ... << tail) << "\n"; } print_same_type("2: ", "Hello, ", "World!"); print_same_type(3, ": ", "Hello, ", "World!"); ^
void doStuff( int a, double termstator = 1.0, bool useFlag = true ) { } void doStuff( double std_termstator ) { return doStuff( 1, std_termstator ); }
doStuff( 1 ); doStuff( 2, 2.5 ); doStuff( 1, 1.0, false ); doStuff( 6.72 );
f(int a) {int res=a; return res;} f(int a, int b) {int res=a+b; return res;}
int fun(int n_args, ...) { int *p = &n_args; int s = sizeof(int); p += s + s - 1; for(int i = 0; i < n_args; i++) { printf("A1 %d!\n", *p); p += 2; } }
Console console; console.log("bunch", "of", "arguments"); console.warn("or some numbers:", 1, 2, 3); console.error("just a prank", "bro");
class Console { protected: template <typename T> void log_argument(T t) { std::cout << t << " "; } public: template <typename... Args> void log(Args&&... args) { int dummy[] = { 0, ((void) log_argument(std::forward<Args>(args)),0)... }; cout << endl; } template <typename... Args> void warn(Args&&... args) { cout << "WARNING: "; int dummy[] = { 0, ((void) log_argument(std::forward<Args>(args)),0)... }; cout << endl; } template <typename... Args> void error(Args&&... args) { cout << "ERROR: "; int dummy[] = { 0, ((void) log_argument(std::forward<Args>(args)),0)... }; cout << endl; } };
add_compile_definitions(OPENCV_VERSION=${OpenCV_VERSION}) add_compile_definitions(WITH_OPENCV2)
add_compile_definitions(OPENCV_VERSION=${OpenCV_VERSION} WITH_OPENCV2)
target_compile_definitions(my_target PRIVATE FOO=1 BAR=1)
add_definitions(-Dfoo) add_executable( ....) target_link_libraries(....)
add_definitions(-Dfoo=5) add_executable( ....) target_link_libraries(....)
RawResourceHandle* handle=createNewResource(); handle->performInvalidOperation(); ... deleteResource(handle);
class ManagedResourceHandle { public: ManagedResourceHandle(RawResourceHandle* rawHandle_) : rawHandle(rawHandle_) {}; ~ManagedResourceHandle() {delete rawHandle; } ... private: RawResourceHandle* rawHandle; }; ManagedResourceHandle handle(createNewResource()); handle->performInvalidOperation();
void fn(const std::string& str) { std::vector<char> vec; for (auto c : str) vec.push_back(c); }
char arr[ ] = "This is a test"; string str(arr); str = "This is another string"; str = arr;
char arr[] = "mom"; std::cout << "hi " << std::string(arr);
cout << string("123\0 123") << endl; cout << string("123\0 123", 8) << endl;
using namespace std; int main () { char *tmp = (char *)malloc(128); int n=sprintf(tmp, "Hello from Chile."); string tmp_str = tmp; cout << *tmp << " : is a char array beginning with " <<n <<" chars long\n" << endl; cout << tmp_str << " : is a string with " <<n <<" chars long\n" << endl; free(tmp); return 0; }
H : is a char array beginning with 17 chars long Hello from Chile. :is a string with 17 chars long
void my_test() { A a1 = A_factory_func(); A a2(A_factory_func()); double b1 = 0.5; double b2(0.5); A c1; A c2 = A(); A c3(A()); }
struct B; struct A { operator B(); }; struct B { B() { } B(A const&) { std::cout << "<direct> "; } }; A::operator B() { std::cout << "<copy> "; return B(); } int main() { A a; B b1(a); B b2 = a; }
using namespace std; class A { public: A() { cout << "default constructor" << endl; } A(const A& x) { cout << "copy constructor" << endl; } const A& operator = (const A& x) { cout << "operator =" << endl; return *this; } }; int main() { A a; A b(a); A c = a; c = b; return 0; }
class sss { public: explicit sss( int ) { std::cout << "int" << std::endl; }; sss( double ) { std::cout << "double" << std::endl; }; }; int main() { sss ddd( 7 ); sss xxx = 7; return 0; }
class A { A(int) { } A(int, int) { } }; class B { explicit B(int) { } explicit B(int, int) { } };
int main() { A a1 = 1; A a2(2); A a3 {4, 5}; A a4 = {4, 5}; A a5 = (A)1; B b2(2); B b3 {4, 5}; B b5 = (B)1; }
const char *s = "Hello, World!"; std::string str(s);
char* data = ...; int size = ...; std::string myString(data, size);
std::string myString; char* data = ...; int size = ...; myString.assign(data, size);
std::string oString; char* pStr; ... oString = pStr;
const char* dat = "my string!"; std::string my_string( dat );
std::string my_string("testing!"); const char* dat = my_string.c_str();
const char* charPointer = "Hello, World!\n"; std::string strFromChar; strFromChar.append(charPointer); std::cout<<strFromChar<<std::endl;
char* data; stringstream myStreamString; myStreamString << data; string myString = myStreamString.str(); cout << myString << endl;
string suffix; cin >> suffix; string mystring = "mystring"s + suffix;
std::string mystring; mystring = "This is a test!"; std::cout << mystring <<
int dd = 1, mm = 9, yy = 1; printf("%02d - %02d - %04d", mm, dd, yy);
int dd = 1, mm = 9, yy = 1; char s[25]; sprintf(s, "%02d - %02d - %04d", mm, dd, yy); cout << s;
cout.fill( cout << -12345 << endl; cout << setw(10) << -12345 << endl; cout << setw(10) << left << -12345 << endl; cout << setw(10) << right << -12345 << endl; cout << setw(10) << internal << -12345 << endl;
typedef signed long long Int64; // // void sprintfNum(char *pszBuffer, int size, char base, char numDigits, char isSigned, char padchar, Int64 n) { char *ptr = pszBuffer; if (!pszBuffer) { return; } char *p, buf[32]; unsigned long long x; unsigned char count; if (isSigned && (n < 0)) { x = -n; } else { x = n; } count = (numDigits-1) - (isSigned?1:0); p = buf + sizeof (buf); *--p = *--p = (char)hexchar(x%base); x = x / base; while(count--) { if(x != 0) { *--p = (char)hexchar(x%base); x /= base; } else { *--p = padchar; } } if (isSigned) { if (n < 0) { *--p = } else if (n > 0) { *--p = } else { *--p = } } count = numDigits; while (count--) { *ptr++ = *p++; } return; }
using namespace std; int main() { time_t t = time(0); struct tm * now = localtime(&t); cout.fill( cout << (now->tm_year + 1900) << << setw(2) << (now->tm_mon + 1) << << setw(2) << now->tm_mday << << setw(2) << now->tm_hour << << setw(2) << now->tm_min << << setw(2) << now->tm_sec << endl; return 0; }
struct IdAndValue { int ID; int value; }; IdAndValue IdAndValues[1000];
define PrintVal set $i=0 printf "ID = %d\n", $arg0 while $i<1000 if IdAndValues[$i].ID == $arg0 printf "ordinal = %d, value = %d\n", $i, IdAndValues[$i].vaue set $i++ end end end
std::shared_ptr<Object> p1 = std::make_shared<Object>("foo"); std::shared_ptr<Object> p2(new Object("foo"));
void F(const std::shared_ptr<Lhs> &lhs, const std::shared_ptr<Rhs> &rhs) { } F(std::shared_ptr<Lhs>(new Lhs("foo")), std::shared_ptr<Rhs>(new Rhs("bar")));
auto lhs = std::shared_ptr<Lhs>(new Lhs("foo")); auto rhs = std::shared_ptr<Rhs>(new Rhs("bar")); F(lhs, rhs);
F(std::make_shared<Lhs>("foo"), std::make_shared<Rhs>("bar"));
class A { public: A(): val(0){} std::shared_ptr<A> createNext(){ return std::make_shared<A>(val+1); } std::shared_ptr<A> createNext(){ return std::shared_ptr<A>(new A(val+1)); } private: int val; A(int v): val(v){} };
for (int k = 0 ; k < 30000000; ++k) { std::shared_ptr<int> foo = std::make_shared<int> (10); std::shared_ptr<int> foo2 = std::shared_ptr<int>(new int(10)); }
auto text = std::unique_ptr<char[]>(new char[len]);
mkdir build cd build cmake -G"Eclipse CDT4 - Unix Makefiles" -D CMAKE_BUILD_TYPE=Debug ..
_main PROC push ebp mov ebp, esp xor eax, eax pop ebp ret 0 _main ENDP
_getch proc xor AH, AH int 16h ;AL contains the keycode (AX is already there - so just return) ret
extern char getch(); void main(int, char **) { getch(); }
void addExclamation(std::string &str) { str.push_back( }
typedef struct _bah { int a; int b; } bah; struct _bah; typedef _bah bah; class foo { foo(bah * b); foo(bah b); bah * mBah; }; foo::foo(bah * b) { mBah = b; } foo::foo(bah b) { mBah = &b; }
struct A{}; typedef A *PA; struct A; typedef A *PA; void func(PA x); ... A x; func(&x);
typedef class A* APtr; typedef class A& ARef; typedef struct B* BPtr; typedef struct B& BRef; class C; typedef C* CPtr; typedef C& CRef; struct D; typedef D* DPtr; typedef D& DRef;
class BurstBoss { public: typedef std::pair<Ogre::ParticleSystem*, bool> ParticleSystem;
class ParticleSystem : public std::pair<Ogre::ParticleSystem*, bool> { public: ParticleSystem(Ogre::ParticleSystem* system, bool enabled) : std::pair<Ogre::ParticleSystem*, bool>(system, enabled) { }; };
class Implementation; class Library { ... private: Implementation* impl; };
// class Implementation : public std::shared_ptr<Foo> { public: using shared_ptr::shared_ptr; };
typedef boost::accumulators::accumulator_set<float, boost::accumulators::features< boost::accumulators::tag::median, boost::accumulators::tag::mean, boost::accumulators::tag::min, boost::accumulators::tag::max >> VanillaAccumulator_t ; std::unique_ptr<VanillaAccumulator_t> acc;
class VanillaAccumulator; std::unique_ptr<VanillaAccumulator> acc;
class VanillaAccumulator : public boost::accumulators::accumulator_set<float, boost::accumulators::features< boost::accumulators::tag::median, boost::accumulators::tag::mean, boost::accumulators::tag::min, boost::accumulators::tag::max >> { };
$ gdb ./a.out (gdb) r < t Starting program: /dir/a.out < t
gdb --args path/to/executable -every -arg you can=think < of
% gdb ./a.out (gdb) set args arg1 arg2 <file (gdb) run
% gdb --args echo 1 2 "<file" (gdb) show args Argument list to give program being debugged when it is started is "1 2 \<file". (gdb) run ... 1 2 <file ...
% gdb --args echo 1 2 <file zsh: no such file or directory: file
"$program" "$@" < <(in) 1> >(out) 2> >(two) 3> >(three)
debug() { 1000<&0 1001>&1 1002>&2 \ 0</dev/tty 1>/dev/tty 2>&0 \ /usr/bin/gdb -q -nx -nw \ -ex -ex r \ --args "$@"; }
p=($ "b u g" "${p[@]}" < <(in) 1> >(out) 2> >(two) 3> >(three)
p=($ debug "b u g" "${p[@]}" < <(in) 1> >(out) 2> >(two) 3> >(three)
using namespace std; struct MyStruct { int key; std::string stringValue; MyStruct(int k, const std::string& s) : key(k), stringValue(s) {} }; int main() { std::vector < MyStruct > vec; vec.push_back(MyStruct(4, "test")); vec.push_back(MyStruct(3, "a")); vec.push_back(MyStruct(2, "is")); vec.push_back(MyStruct(1, "this")); std::sort(vec.begin(), vec.end(), [] (const MyStruct& struct1, const MyStruct& struct2) { return (struct1.key < struct2.key); } ); return 0; }
int *temp = i - 1; int numbers_of_element = *temp; ... call destructor for numbers_of_element elements ... that are stored in temp + 1, temp + 2, ... temp + 4 if needed free (temp)
void SomeModule::doStuff() { controller->setWorkingModule(new OtherModule()); delete this; }
void myclass::delete_me() { std::unique_ptr<myclass> bye_bye(this); }
void myclass::throw_error() { std::unique_ptr<myclass> bye_bye(this); throw std::runtime_exception(this->error_msg); }
void IMyInterface::Release() { --instanceCount; if(instanceCount == 0) delete this; }
template<typename T> class explicit_delete_ref_cnt_ptr { private: T* ptr; int rc; ... public: void delete_if_rc0() { if( this->ptr ) { this->rc--; if( this->rc == 0 ) { delete this->ptr; } this->ptr = 0; } } };
class Pointee { private: int rc; ... public: void delete_if_rc0() { this->rc--; if( this->rc == 0 ) { delete this; } } } };
map<void*,int> keepalive_map; template<typename T> void delete_if_rc0(T*ptr) { void* tptr = (void*)ptr; if( keepalive_map[tptr] == 1 ) { delete ptr; } };
120. Reference arguments should always be `const` 121. Never use references as outputs, use pointers
bool test( int & a) { return (&a) == (int *) NULL; } int main() { int * i = (int *)NULL; cout << ( test(*i) ) << endl; };
double someValue = ... if (someValue < std::numeric_limits<double>::epsilon() && someValue > -std::numeric_limits<double>::epsilon()) { someValue = 0.0; }
1.0000 00000000 00000000 00000000 00000000 00000000 00000000 × 2^0 = 1
1.0000 00000000 00000000 00000000 00000000 00000000 00000001 × 2^0 = 1 + 2^-52
1.0000 00000000 00000000 00000000 00000000 00000000 00000000 × 2^-1022 = 2^-1022
int main () { struct Doubles { double one; double epsilon; double half_epsilon; } values; values.one = 1.0; values.epsilon = std::numeric_limits<double>::epsilon(); values.half_epsilon = values.epsilon / 2.0; }
double getEps (double m) { double approx=1.0; double lastApprox=0.0; while (m+approx!=m) { lastApprox=approx; approx/=2.0; } assert (lastApprox!=0); return lastApprox; } int main () { printf ("epsilon for 0.0 is %e\n", getEps (0.0)); printf ("epsilon for 1.0 is %e\n", getEps (1.0)); return 0; }
bool same(double a, double b) { return std::nextafter(a, std::numeric_limits<double>::lowest()) <= b && std::nextafter(a, std::numeric_limits<double>::max()) >= b; } double someValue = ... if (same (someValue, 0.0)) { someValue = 0.0; }
class my_class { ... my_class(my_class const &) = delete; ... };
class X { X& operator=(const X&) = delete; X(const X&) = delete; };
class Shape { public: Shape(const Shape&) =delete; Shape& operator=(const Shape&) =delete; Shape(Shape&&) =delete; Shape& operator=(Shape&&) =delete; ˜Shape(); };
Class ABC{ Int d; Public: ABC& operator= (const ABC& obj) =delete { } };
T(void) = delete; ~T(void) = delete; T(const T&) = delete; T(const T&&) = delete; T& operator= (const T&) = delete; T& operator= (const T&&) = delete;
FizzBuzz(void) = delete; FizzBuzz(const FizzBuzz&) = delete; FizzBuzz& operator= (const FizzBuzz&) = delete; FizzBuzz(const FizzBuzz&&) = delete; FizzBuzz& operator= (const FizzBuzz&&) = delete;
template <class T> operator T(void) = delete; template <class T> Vuint64& operator= (const T) = delete; template <class T> Vuint64& operator|= (const T) = delete; template <class T> Vuint64& operator&= (const T) = delete;
struct X { X& ref() { return *this; } }; X getx() { return X();} void g(X & x) {} int f() { const X& x = getx(); X& x = getx(); X& x = getx().ref(); g(getx()); g(getx().ref()); return 0; }
void g(X&); void g(X&&); X x; g(x); g(getx()); g(X());
class X { X(X&& rhs) : pimpl( rhs.pimpl ) { rhs.pimpl = NULL; } data* pimpl; }; X x(getx());
getPipeline().procInstr(1).procInstr(2).procInstr(3); std::cout << getManiplator() << 5;
void incr(int& a) { ++a; } int i = 0; incr(i); incr(0);
string name; person.GetNameAndAddr(name, string());
person.GetNameAndAddr(name, const_cast<string &>(static_cast<const string &>(string())));
string name; string unused; person.GetNameAndAddr(name, unused);
string name; { string unused; person.GetNameAndAddr(name, unused); }
MFnDoubleArrayData myArrayData; MObject myArrayObj = myArrayData.create(myArray); MPlug myPlug = myNode.findPlug(attributeName); myPlug.setValue(myArrayObj);
MPlug operator | (MFnDependencyNode& node, MObject& attribute){ MStatus status; MPlug returnValue = node.findPlug(attribute, &status); return returnValue; } void operator << (MPlug& plug, MDoubleArray& doubleArray){ MStatus status; MFnDoubleArrayData doubleArrayData; MObject doubleArrayObject = doubleArrayData.create(doubleArray, &status); status = plug.setValue(doubleArrayObject); }
QString qs; std::string utf8_text = qs.toUtf8().constData(); std::string current_locale_text = qs.toLocal8Bit().constData();
QString qs; std::cout << qs.toStdString() << std::endl;
QString qstr; std::string str = qstr.toStdString();
std::ostream& operator<<(std::ostream& str, const QString& string) { return str << string.toStdString(); }
QString qs; std::string current_locale_text = qs.toLocal8Bit().constData();
QString qs; std::string current_locale_text = qPrintable(qs);
QString qs; std::string utf8_text = qs.toUtf8().constData(); std::string current_locale_text = qs.toLocal8Bit().constData();
QString string; qDebug() << "right" << string << std::endl;
a[i] = i++; (a) a[i] (b) i++ (c) Assign (b) to (a) int rhs = i++; int lhs& = a[i]; lhs = rhs; int lhs& = a[i]; int rhs = i++; lhs = rhs;
A* a = new A("plop"); (a) allocate Memory (b) Call constructor (c) Assign value to (a) allocate Memory (c) Assign value to (b) Call constructor. if (a == null) { Lock lock(mutex); if (a == null) { a = new A("Plop"); } } a->doStuff(); if (a == null) { Lock lock(mutex); if (a == null) { A* tmp = new A("Plop"); a = tmp; } } a->doStuff();
const int i = 10; int *p = const_cast<int*>( &i ); *p = 1234;
class Z { }; class X { std::vector<Z> vecZ; public: Z& Z(size_t index) { Z& ret = vecZ[index]; return ret; } const Z& Z(size_t index) const { } };
struct C { const char & get() const { return c; } char & get() { return const_cast<char &>(static_cast<const C &>(*this).get()); } char c; };
class X { std::vector<Z> vecZ; public: const Z& Z(size_t index) const { return vecZ[index]; } Z& Z(size_t index) { return const_cast<Z&>( static_cast<const X&>(*this).Z(index) ); } Z& Z(size_t index) { const X& constMe = *this; return const_cast<Z&>( constMe.Z(index) ); } };
template <typename T> struct NonConst {typedef T type;}; template <typename T> struct NonConst<T const> {typedef T type;}; template <typename T> struct NonConst<T const&> {typedef T& type;}; template <typename T> struct NonConst<T const*> {typedef T* type;}; template <typename T> struct NonConst<T const&&> {typedef T&& type;}; template<typename TConstReturn, class TObj, typename... TArgs> typename NonConst<TConstReturn>::type likeConstVersion( TObj const* obj, TConstReturn (TObj::* memFun)(TArgs...) const, TArgs&&... args) { return const_cast<typename NonConst<TConstReturn>::type>( (obj->*memFun)(std::forward<TArgs>(args)...)); }
struct T { int arr[100]; int const& getElement(size_t i) const{ return arr[i]; } int& getElement(size_t i) { return likeConstVersion(this, &T::getElement, i); } };
class X { private: Z &_getZ(size_t index) const { return something; } public: Z &getZ(size_t index) { return _getZ(index); } const Z &getZ(size_t index) const { return _getZ(index); } };
class X { private: std::vector<Z> v; template<typename InstanceType> static auto get(InstanceType& instance, std::size_t i) -> decltype(instance.get(i)) { return instance.v[i]; } public: const Z& get(std::size_t i) const { return get(*this, i); } Z& get(std::size_t i) { return get(*this, i); } };
T const & f() const { return something_complicated(); } T & f() { return const_cast<T &>(std::as_const(*this).f()); }
template<typename T> constexpr T & as_mutable(T const & value) noexcept { return const_cast<T &>(value); } template<typename T> void as_mutable(T const &&) = delete;
T & f() { return as_mutable(std::as_const(*this).f()); }
class Z { }; class X { std::vector<Z> vecZ; public: const std::vector<Z>& GetVector() const { return vecZ; } std::vector<Z>& GetVector() { return vecZ; } Z& GetZ( size_t index ); const Z& GetZ( size_t index ) const; };
template< class ParentPtr, class Child > Child& GetZImpl( ParentPtr parent, size_t index ) { Child& ret = parent->GetVector()[index]; return ret; } Z& X::GetZ( size_t index ) { return GetZImpl< X*, Z >( this, index ); } const Z& X::GetZ( size_t index ) const { return GetZImpl< const X*, const Z >( this, index ); }
class MyClass { public: int getI() { std::cout << "non-const getter" << std::endl; return privateGetI<MyClass, int>(*this); } const int getI() const { std::cout << "const getter" << std::endl; return privateGetI<const MyClass, const int>(*this); } private: template <class C, typename T> static T privateGetI(C c) { return c._i; } int _i; }; int main() { const MyClass myConstClass = MyClass(); myConstClass.getI(); MyClass myNonConstClass; myNonConstClass.getI(); return 0; }
struct A { \ \ \ B& get() { GETTER_CORE_CODE } const B& get() const { GETTER_CORE_CODE } };
struct C { shared_ptr<const char> get() const { return c; } shared_ptr<char> get() { return const_pointer_cast<char>(static_cast<const C &>(*this).get()); } shared_ptr<char> c; };
class X { std::vector<Z> vecZ; template <typename ReturnType, typename ThisType> static ReturnType Z_impl(ThisType& self, size_t index) { ReturnType ret = self.vecZ[index]; return ret; } public: Z& Z(size_t index) { return Z_impl<Z&>(*this, index); } const Z& Z(size_t index) const { return Z_impl<const Z&>(*this, index); } };
struct C { int x[10]; int const* getp() const { return x; } int const* getp(int i) const { return &x[i]; } int const* getp(int* p) const { return &x[*p]; } int const& getr() const { return x[0]; } int const& getr(int i) const { return x[i]; } int const& getr(int* p) const { return x[*p]; } template<typename... Ts> auto* getp(Ts... args) { auto const* p = this; return const_cast<int*>(p->getp(args...)); } template<typename... Ts> auto& getr(Ts... args) { auto const* p = this; return const_cast<int&>(p->getr(args...)); } };
template<typename T, typename... Ts> auto* pwrap(T const* (C::*f)(Ts...) const, Ts... args) { return const_cast<T*>((this->*f)(args...)); } int* getp_i(int i) { return pwrap(&C::getp_i, i); } int* getp_p(int* p) { return pwrap(&C::getp_p, p); }
template<typename... Ts> auto* getp(Ts... args) { return pwrap<int, Ts...>(&C::getp, args...); }
struct bar{ std::vector<int> data; }; std::vector<bar> foo(1); foo.back().data.push_back(3); foo.reserve(10);
std::vector<int> foo(int count){ std::vector<int> v; if (count<=0) return std::vector<int>(); v.reserve(count); for(int i=0;i<count;++i) v.push_back(i); return v; }
std::vector<int> foo(bool which) { std::vector<int> a, b; if (which) return a; else return b; }
struct whatever { std::string data; int count; whatever( std::string d, int c ):data(d), count(c) {} }; std::vector<whatever> v; v.push_back( whatever("some long string goes here", 3) );
std::set<int> some_function(); std::set<int> some_value; some_value = some_function();
std::vector<int> foo(); std::vector<int> v; v = foo();
try{ } catch (const std::exception& ex) { } catch (const std::string& ex) { } catch (...) { }
int main() { try { throw ...; } catch(...) { std::exception_ptr p = std::current_exception(); std::clog <<(p ? p.__cxa_exception_type()->name() : "null") << std::endl; } return 1; }
catch (...) { std::clog << boost::current_exception_diagnostic_information() << std::endl; }
try { ... } catch( const std::exception &e) { ... }
try{ foo = new Foo; bar = new Bar; } catch(...) { delete foo; delete bar; throw; }
SEH exception terminate unexpected pure virtual method call invalid parameter new operator fault SIGABR SIGFPE SIGILL SIGINT SIGSEGV SIGTERM Raised exception C++ typed exception
my_multi_type::nth_index<2>::type::key_type::composite_key_type::\ key_extractor_tuple::tail_type::head_type::result_type
auto foo = std::make_shared<Foo>(); auto foo = bla(); const size_t max_size = 100; for ( auto x = max_size; x > 0; --x ) std::vector<some_class> v; for ( auto it = v.begin(); it != v.end(); ++it )
typedef float Height; typedef double Weight; Height h; Weight w;
auto i = SomeClass(); for (auto x = make_unsigned (y); ...)
for(auto i = container.begin(); i != container.end(); ++i);
r_and_t<r_and_t<r_char_t<char>&, r_char_t<char>&>, r_char_t<char>&> spaces = space & space & space;
auto A = Matrix(...); auto B = Matrix(...); auto C = A * B; cout << C; ... cout << C;
for ( auto x = make_unsigned(max_size); x > 0; --x )
MyBigObject& ref_to_big_object= big_object; auto another_ref = ref_to_big_object;
auto another_ref = function_returning_ref_to_big_object();
MyBigObject& ref_to_big_object= big_object; auto& another_ref = ref_to_big_object; const auto& yet_another_ref = function_returning_ref_to_big_object();
auto i = []() { return 0; }; cout<<"i = "<<i<<endl;
void add1(int &v) { v+=1; } void add2(int &v) { v+=2; } template <void (*T)(int &)> void doOperation() { int temp=0; T(temp); std::cout << "Result is " << temp << std::endl; } int main() { doOperation<add1>(); doOperation<add2>(); }
struct add3 { void operator() (int &v) {v+=3;} }; ... doOperation<add3>();
template <typename F> void doOperation(F f) { int temp=0; f(temp); std::cout << "Result is " << temp << std::endl; }
template<typename OP> int do_op(int a, int b, OP op) { return op(a,b); } int add(int a, int b) { return a + b; } ... int c = do_op(4,5,add);
int (* func_ptr)(int, int) = add; int c = do_op(4,5,func_ptr);
typedef int(*binary_int_op)(int, int); template<binary_int_op op> int do_op(int a, int b) { return op(a,b); } int add(int a, int b) { return a + b; } ... int c = do_op<add>(4,5);
int (* func_ptr)(int,int) = add; int c = do_op<func_ptr>(4,5);
template<typename OP> int do_op(int a, int b, OP op) { return op(a,b); } float fadd(float a, float b) { return a+b; } ... int c = do_op(4,5,fadd);
convert a and b from int to float. call the function ptr op with float a and float b. convert the result back to int and return it.
int i; void add1(int& i) { i += 1; } template<void op(int&)> void do_op_fn_ptr_tpl(int& i) { op(i); } i = 0; do_op_fn_ptr_tpl<&add1>(i);
struct add2_t { void operator()(int& i) { i += 2; } }; template<typename op> void do_op_fntr_tpl(int& i) { op o; o(i); } i = 0; do_op_fntr_tpl<add2_t>(i);
template<typename op> void do_op_fntr_arg(int& i, op o) { o(i); } i = 0; add2_t add2; do_op_fntr_arg(i, add1); do_op_fntr_arg(i, add2);
template<void op(int&)> void do_op(int& i) { op(i); } template<typename op> void do_op(int& i) { op o; o(i); } i = 0; do_op<&add1>(i); do_op<add2_t>(i);
template <class T> void doOperation(T t) { int temp=0; t(temp); std::cout << "Result is " << temp << std::endl; }
struct Square { double operator()(double number) { return number * number; } }; template <class Function> double integrate(Function f, double a, double b, unsigned int intervals) { double delta = (b - a) / intervals, sum = 0.0; while(a < b) { sum += f(a) * delta; a += delta; } return sum; }
std::cout << "interval : " << i << tab << tab << "intgeration = " << integrate(Square(), 0.0, 1.0, 10) << std::endl;
class Base { public: virtual void gogo(int a){ printf(" Base :: gogo (int) \n"); }; virtual void gogo(int* a){ printf(" Base :: gogo (int*) \n"); }; }; class Derived : public Base{ public: virtual void gogo(int* a){ printf(" Derived :: gogo (int*) \n"); }; }; int main(){ Derived obj; obj.gogo(7); }
class Base { int x; public: virtual void copy(Base* p) { x = p-> x; } }; class Derived{ int xx; public: virtual void copy(Derived* p) { xx = p->xx; Base::copy(p); } }; void f(Base a, Derived b) { a.copy(&b); b.copy(&a); }
class Base { public: void func (float x) { ... } } class Derived: public Base { public: void func (double x) { ... } } Derived dobj;
namespace Math { class Matrix { public: [...] friend std::ostream& operator<< (std::ostream& stream, const Matrix& matrix); } }
using namespace Math; std::ostream& Matrix::operator <<(std::ostream& stream, const Matrix& matrix) { [...] }
namespace Math { class Matrix { public: [...] friend std::ostream& operator<< (std::ostream& stream, const Matrix& matrix) { [...] } }; }
namespace Math { class Matrix { public: [...] } std::ostream& operator<< (std::ostream& stream, const Math::Matrix& matrix); }
std::ostream& operator<<(std::ostream& stream, const Math::Matrix& matrix) { matrix.print(stream); return stream; }
namespace Math { class Matrix { }; } std::ostream& operator<<(std::ostream&, const Math::Matrix&);
using namespace Math; using namespace std; ostream& operator<< (ostream& os, const Matrix& obj) { os << obj.getXYZ() << obj.getABC() << return os; }
namespace Math { class Matrix { public: friend std::ostream& operator<<(std::ostream&, const Matrix&); }; }
using namespace Math; using namespace std; namespace Math { ostream& operator<<(ostream& os, const Matrix& obj) { os << obj.XYZ << obj.ABC << return os; } }
template<class T> auto operator<<(std::ostream& os, const T& t) -> decltype(t.print(os), os) { t.print(os); return os; }
template <typename T> T* xor_ptrs(T* t1, T* t2) { return reinterpret_cast<T*>(reinterpret_cast<uintptr_t>(t1)^reinterpret_cast<uintptr_t>(t2)); }
template <template<class> class H, class S> void f(const H<S> &value) { }
template <template<class, class> class V, class T, class A> void f(V<T, A> &v) { T temp = v.back(); v.pop_back(); std::cout << temp << std::endl; }
template <class Cont> void f(Cont &v) { auto temp = v.back(); v.pop_back(); std::cout << temp << std::endl; }
template<typename T> static inline std::ostream& operator<<(std::ostream& out, std::list<T> const& v) { out << if (!v.empty()) { for (typename std::list<T>::const_iterator i = v.begin(); ;) { out << *i; if (++i == v.end()) break; out << ", "; } } out << return out; }
template<template <typename, typename> class Container, class V, class A> std::ostream& operator<<(std::ostream& out, Container<V, A> const& v) ...
template<typename T, template<class,class...> class C, class... Args> std::ostream& operator <<(std::ostream& os, const C<T,Args...>& objs) { os << __PRETTY_FUNCTION__ << for (auto const& obj : objs) os << obj << return os; } int main() { std::vector<float> vf { 1.1, 2.2, 3.3, 4.4 }; std::cout << vf << std::list<char> lc { std::cout << lc << std::deque<int> di { 1, 2, 3, 4 }; std::cout << di << return 0; }
std::ostream &operator<<(std::ostream &, const C<T, Args...> &) [T = float, C = vector, Args = <std::__1::allocator<float>>] 1.1 2.2 3.3 4.4 std::ostream &operator<<(std::ostream &, const C<T, Args...> &) [T = char, C = list, Args = <std::__1::allocator<char>>] a b c d std::ostream &operator<<(std::ostream &, const C<T, Args...> &) [T = int, C = deque, Args = <std::__1::allocator<int>>] 1 2 3 4
template <template <class> class CreationPolicy> class WidgetManager : public CreationPolicy<Widget> { ... };
typedef WidgetManager<MyCreationPolicy> MyWidgetMgr;
typedef WidgetManager< MyCreationPolicy<Widget> > MyWidgetMgr;
template <class T> class TensorGPU : public Tensor<T>
template <template <class> class TT, class T> class CLayerT: public Layer<TT<T> > { TT<T> weights; TT<T> inputs; TT<int> connection_matrix; }
template <typename DERIVED, typename VALUE> class interface { void do_something(VALUE v) { static_cast<DERIVED*>(this)->do_something(v); } }; template <typename VALUE> class derived : public interface<derived, VALUE> { void do_something(VALUE v) { ... } }; typedef interface<derived<int>, int> derived_t;
template <template <typename> class DERIVED, typename VALUE> class interface { void do_something(VALUE v) { static_cast<DERIVED<VALUE>*>(this)->do_something(v); } }; template <typename VALUE> class derived : public interface<derived, VALUE> { void do_something(VALUE v) { ... } }; typedef interface<derived, int> derived_t;
template <typename VALUE> struct derived_interface_type { typedef typename interface<derived, VALUE> type; }; typedef typename derived_interface_type<int>::type derived_t;
namespace containerdisplay { template<typename T, template<class,class...> class C, class... Args> std::ostream& operator <<(std::ostream& os, const C<T,Args...>& objs) { std::cout << __PRETTY_FUNCTION__ << for (auto const& obj : objs) os << obj << return os; } } template< typename K, typename V> std::ostream& operator << ( std::ostream& os, const std::map< K, V > & objs ) { std::cout << __PRETTY_FUNCTION__ << for( auto& obj : objs ) { os << obj.first << ": " << obj.second << std::endl; } return os; } int main() { { using namespace containerdisplay; std::vector<float> vf { 1.1, 2.2, 3.3, 4.4 }; std::cout << vf << std::list<char> lc { std::cout << lc << std::deque<int> di { 1, 2, 3, 4 }; std::cout << di << } std::map< std::string, std::string > m1 { { "foo", "bar" }, { "baz", "boo" } }; std::cout << m1 << std::endl; return 0; }
template<class A> class B { A& a; }; template<class B> class A { B b; }; class AInstance : A<B<A<B<A<B<A<B<... (oh oh)>>>>>>>> { };
template<class A> class B { A& a; }; template< template<class> class B> class A { B<A> b; }; class AInstance : A<B> { };
template<class A> class B { public: A* a; int GetInt() { return a->dummy; } }; template< template<class> class B> class A { public: A() : dummy(3) { b.a = this; } B<A> b; int dummy; }; class AInstance : public A<B> { public: void Print() { std::cout << b.GetInt(); } }; int main() { std::cout << "hello"; AInstance test; test.Print(); }
template <class T> class Alloc final { }; template <template <class T> class allocator=Alloc> class MyClass final { public: std::vector<short,allocator<short>> field0; std::vector<float,allocator<float>> field1; };
template <typename T> void print_container(const T& c) { for (const auto& v : c) { std::cout << v << } std::cout << }
template< template<typename, typename> class ContainerType, typename ValueType, typename AllocType> void print_container(const ContainerType<ValueType, AllocType>& c) { for (const auto& v : c) { std::cout << v << } std::cout << }
class Car { public: int speed; }; int main() { int Car::*pSpeed = &Car::speed; return 0; }
using namespace std; class Car { public: int speed; }; int main() { int Car::*pSpeed = &Car::speed; Car c1; c1.speed = 1; cout << "speed is " << c1.speed << endl; c1.*pSpeed = 2; cout << "speed is " << c1.speed << endl; return 0; }
void Apply( SomeClass * c, void (SomeClass::*func)() ) { (c->*func)(); }
class bowl { public: int apples; int oranges; }; int count_fruit(bowl * begin, bowl * end, int bowl::*fruit) { int count = 0; for (bowl * iterator = begin; iterator != end; ++ iterator) count += iterator->*fruit; return count; } int main() { bowl bowls[2] = { { 1, 2 }, { 3, 5 } }; std::cout << "I have " << count_fruit(bowls, bowls + 2, & bowl::apples) << " apples\n"; std::cout << "I have " << count_fruit(bowls, bowls + 2, & bowl::oranges) << " oranges\n"; return 0; }
struct apple { int data; apple * next; }; template<typename E> struct List { List(E *E::*next_ptr):head(0), next_ptr(next_ptr) { } void add(E &e) { e.*next_ptr = head; head = &e; } E * head; E *E::*next_ptr; }; int main() { List<apple> lst(&apple::next); apple a; lst.add(a); }
int main() { int Car::*pSpeed = &Car::speed; Car myCar; Car yourCar; int mySpeed = myCar.*pSpeed; int yourSpeed = yourCar.*pSpeed; assert(mySpeed > yourSpeed); return 0; }
struct Sample { time_t time; double value1; double value2; double value3; };
std::vector<Sample> samples; ... fill the vector ...
double Mean(std::vector<Sample>::const_iterator begin, std::vector<Sample>::const_iterator end, double Sample::* var) { float mean = 0; int samples = 0; for(; begin != end; begin++) { const Sample& s = *begin; mean += s.*var; samples++; } mean /= samples; return mean; } ... double mean = Mean(samples.begin(), samples.end(), &Sample::value2);
template<typename Titer, typename S> S mean(Titer begin, const Titer& end, S std::iterator_traits<Titer>::value_type::* var) { using T = typename std::iterator_traits<Titer>::value_type; S sum = 0; size_t samples = 0; for( ; begin != end ; ++begin ) { const T& s = *begin; sum += s.*var; samples++; } return sum / samples; } struct Sample { double x; } std::vector<Sample> samples { {1.0}, {2.0}, {3.0} }; double m = mean(samples.begin(), samples.end(), &Sample::x);
struct Sample { float w, x, y, z; }; std::vector<Sample> series = ...; float sum = 0; int samples = 0; for(auto it = series.begin(); it != series.end(); it++) { sum += *it.x; samples++; } float mean = sum / samples;
struct Samples { std::vector<float> w, x, y, z; }; Samples series = ...; float sum = 0; float samples = 0; for(auto it = series.x.begin(); it != series.x.end(); it++) { sum += *it; samples++; } float mean = sum / samples;
int Car::*pSpeed = &Car::speed; Car mycar; mycar.*pSpeed = 65;
class Car { public: Car(int s): speed(s) {} void drive() { std::cout << "Driving at " << speed << " km/h" << std::endl; } int speed; }; int main() { using namespace std; using namespace boost::lambda; list<Car> l; l.push_back(Car(10)); l.push_back(Car(140)); l.push_back(Car(130)); l.push_back(Car(60)); list<Car> s; remove_copy_if(l.begin(), l.end(), back_inserter(s), bind(&Car::speed, _1) <= 60); for_each(s.begin(), s.end(), bind(&Car::drive, _1)); return 0; }
struct vector3 { float x; float y; float z; float& operator[](std::size_t idx) { static float vector3::*component[3] = { &vector3::x, &vector3::y, &vector3::z }; return this->*component[idx]; } }; int main() { vector3 v = { 0.0f, 1.0f, 2.0f }; assert(&v[0] == &v.x); assert(&v[1] == &v.y); assert(&v[2] == &v.z); for (std::size_t i = 0; i < 3; ++i) { v[i] += 1.0f; } assert(v.x == 1.0f); assert(v.y == 2.0f); assert(v.z == 3.0f); return 0; }
class Algorithm { public: Algorithm() : m_impFn( &Algorithm::implementationA ) {} void frequentlyCalled() { (this->*m_impFn)(); } private: void implementationA() { } void implementationB() { } typedef void ( Algorithm::*IMP_FN ) (); IMP_FN m_impFn; };
template <typename Container, typename T, typename DataPtr> typename Container::value_type searchByDataMember (const Container& container, const T& t, DataPtr ptr) { for (const typename Container::value_type& x : container) { if (x->*ptr == t) return x; } return typename Container::value_type{}; } struct Object { int ID, value; std::string name; Object (int i, int v, const std::string& n) : ID(i), value(v), name(n) {} }; std::list<Object*> objects { new Object(5,6,"Sam"), new Object(11,7,"Mark"), new Object(9,12,"Rob"), new Object(2,11,"Tom"), new Object(15,16,"John") }; int main() { const Object* object = searchByDataMember (objects, 11, &Object::value); std::cout << object->name << }
void readDataFromText(std::istream & input, std::map<std::string, foo> & container, std::string foo::*storage) { std::string line, name, value; while (std::getline(input, line)) { std::stringstream linestr(line); if ( line.empty() ) { continue; } linestr >> name >> value; container[name].*storage = value; } } std::map<std::string, foo> readValues() { std::map<std::string, foo> foos; std::ifstream a("input-a"); readDataFromText(a, foos, &foo::a); std::ifstream b("input-b"); readDataFromText(b, foos, &foo::b); return foos; }
class x { public: int val; x(int i) { val=i;} int get_val(){return val;} int d_val(int i){return i+i;} }; int main() { int (x::*data)=&x::val; int (x::*func)(int)=&x::d_val; x ob1(1),ob2(2); cout<<ob1.*data; cout<<ob2.*data; cout<<(ob1.*func)(ob1.*data); cout<<(ob2.*func)(ob2.*data); return 0; }
unsigned int * pciMemory; askDriverForMapping( & pciMemory ); ... pciMemory[ 0 ] = someCommandIdx; pciMemory[ 0 ] = someCommandLength; for ( int i = 0; i < sizeof( someCommand ); i++ ) pciMemory[ 0 ] = someCommand[ i ];
class A { public: A() { fn(); } virtual void fn() { _n = 1; } int getn() { return _n; } protected: int _n; }; class B : public A { public: B() : A() {} virtual void fn() { _n = 2; } };
class Base { public: Base() { f(); } virtual void f() { std::cout << "Base" << std::endl; } }; class Derived : public Base { public: Derived() : Base() {} virtual void f() { std::cout << "Derived" << std::endl; } }; int main() { Derived d; }
public class Base { public Base() { polymorphic(); } public void polymorphic() { System.out.println( "Base" ); } } public class Derived extends Base { final int x; public Derived( int value ) { x = value; polymorphic(); } public void polymorphic() { System.out.println( "Derived: " + x ); } public static void main( String args[] ) { Derived d = new Derived( 5 ); } }
class AbstractClass { public: AbstractClass( ){ } virtual void pureVitualFunction() = 0; };
struct Base { protected: template<class T> explicit Base(const T*) : class_name(T::Name()) { std::cout << class_name << " created\n"; } public: Base() : class_name(Name()) { std::cout << class_name << " created\n"; } virtual ~Base() { std::cout << class_name << " destroyed\n"; } static std::string Name() { return "Base"; } private: std::string class_name; }; struct Derived : public Base { Derived() : Base(this) {} static std::string Name() { return "Derived"; } }; int main(int argc, const char *argv[]) { Derived{}; Base{}; return 0; }
Derived created Derived destroyed Base created Base destroyed
template<typename DerivedClass> class Base { public: inline Base() : foo(DerivedClass::getFoo()) {} inline int fooSq() { return foo * foo; } const int foo; }; class A : public Base<A> { public: inline static int getFoo() { return 1; } }; class B : public Base<B> { public: inline static int getFoo() { return 2; } }; class C : public Base<C> { public: inline static int getFoo() { return 3; } }; int main() { A a; B b; C c; std::cout << a.fooSq() << ", " << b.fooSq() << ", " << c.fooSq() << std::endl; return 0; }
int mat[MATSIZE][MATSIZE]; void transpose() { for ( int i = 0 ; i < MATSIZE ; i++ ) for ( int j = 0 ; j < MATSIZE ; j++ ) { int aux = mat[i][j]; mat[i][j] = mat[j][i]; mat[j][i] = aux; } } int main() { for ( int i = 0 ; i < MATSIZE ; i++ ) for ( int j = 0 ; j < MATSIZE ; j++ ) mat[i][j] = i+j; int t = clock(); for ( int i = 0 ; i < SAMPLES ; i++ ) transpose(); int elapsed = clock() - t; std::cout << "Average for a matrix of " << MATSIZE << ": " << elapsed / SAMPLES; }
for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) A[j][i] = A[i][j];
void recursiveTranspose(int i0, int i1, int j0, int j1) { int di = i1 - i0, dj = j1 - j0; const int LEAFSIZE = 32; if (di >= dj && di > LEAFSIZE) { int im = (i0 + i1) / 2; recursiveTranspose(i0, im, j0, j1); recursiveTranspose(im, i1, j0, j1); } else if (dj > LEAFSIZE) { int jm = (j0 + j1) / 2; recursiveTranspose(i0, i1, j0, jm); recursiveTranspose(i0, i1, jm, j1); } else { for (int i = i0; i < i1; i++ ) for (int j = j0; j < j1; j++ ) mat[j][i] = mat[i][j]; } }
int main() { LARGE_INTEGER start, end, freq; QueryPerformanceFrequency(&freq); QueryPerformanceCounter(&start); recursiveTranspose(0, MATSIZE, 0, MATSIZE); QueryPerformanceCounter(&end); printf("recursive: %.2fms\n", (end.QuadPart - start.QuadPart) / (double(freq.QuadPart) / 1000)); QueryPerformanceCounter(&start); transpose(); QueryPerformanceCounter(&end); printf("iterative: %.2fms\n", (end.QuadPart - start.QuadPart) / (double(freq.QuadPart) / 1000)); return 0; } results: recursive: 480.58ms iterative: 3678.46ms
template<class InIt, class OutIt> void transpose(InIt const input, OutIt const output, size_t const rows, size_t const columns, size_t const r1 = 0, size_t const c1 = 0, size_t r2 = ~(size_t) 0, size_t c2 = ~(size_t) 0, size_t const leaf = 0x20) { if (!~c2) { c2 = columns - c1; } if (!~r2) { r2 = rows - r1; } size_t const di = r2 - r1, dj = c2 - c1; if (di >= dj && di > leaf) { transpose(input, output, rows, columns, r1, c1, (r1 + r2) / 2, c2); transpose(input, output, rows, columns, (r1 + r2) / 2, c1, r2, c2); } else if (dj > leaf) { transpose(input, output, rows, columns, r1, c1, r2, (c1 + c2) / 2); transpose(input, output, rows, columns, r1, (c1 + c2) / 2, r2, c2); } else { for (ptrdiff_t i1 = (ptrdiff_t) r1, i2 = (ptrdiff_t) (i1 * columns); i1 < (ptrdiff_t) r2; ++i1, i2 += (ptrdiff_t) columns) { for (ptrdiff_t j1 = (ptrdiff_t) c1, j2 = (ptrdiff_t) (j1 * rows); j1 < (ptrdiff_t) c2; ++j1, j2 += (ptrdiff_t) rows) { output[j2 + i1] = input[i2 + j1]; } } } }
int main() { int* ptr = new int(10); int* ref = ptr; delete ptr; std::shared_ptr<int> sptr; sptr.reset(new int); *sptr = 10; std::weak_ptr<int> weak1 = sptr; sptr.reset(new int); *sptr = 5; std::weak_ptr<int> weak2 = sptr; if(auto tmp = weak1.lock()) std::cout << *tmp << else std::cout << "weak1 is expired\n"; if(auto tmp = weak2.lock()) std::cout << *tmp << else std::cout << "weak2 is expired\n"; }
shared_ptr<Parent> tempParentSharedPtr = parentWeakPtr_.lock(); if( !tempParentSharedPtr ) { } else { }
void MyClass::startTimer() { std::weak_ptr<MyClass> weak = shared_from_this(); timer_.async_wait( [weak](const boost::system::error_code& ec) { auto self = weak.lock(); if (self) { self->handleTimeout(); } else { std::cout << "Target object no longer exists!\n"; } } ); }
std::weak_ptr<X> weak_x{ shared_x }; shared_x.reset(); BOOST_CHECK(weak_x.lock()); ... BOOST_CHECK(!weak_x.lock());
struct ImageData { std::string path; std::unique_ptr<YourFavoriteImageLibData> image; }; void read( std::vector<std::shared_ptr<ImageData>> imagesToLoad ) { for( auto& imageData : imagesToLoad ) imageData->image = YourFavoriteImageLib::load( imageData->path ); } class Manager { std::vector<std::shared_ptr<ImageData>> m_imageDatas; std::vector<std::unique_ptr<std::thread>> m_threads; public: void load( const std::string& folderPath ) { std::vector<std::string> imagePaths = readFolder( folderPath ); m_imageDatas = createImageDatas( imagePaths ); const unsigned numThreads = std::thread::hardware_concurrency(); std::vector<std::vector<std::shared_ptr<ImageData>>> splitDatas = splitImageDatas( m_imageDatas, numThreads ); for( auto& dataRangeToLoad : splitDatas ) m_threads.push_back( std::make_unique<std::thread>(read, dataRangeToLoad) ); } };
void read( std::vector<std::weak_ptr<ImageData>> imagesToLoad ) { for( auto& imageDataWeak : imagesToLoad ) { std::shared_ptr<ImageData> imageData = imageDataWeak.lock(); if( !imageData ) continue; imageData->image = YourFavoriteImageLib::load( imageData->path ); } } class Manager { std::vector<std::shared_ptr<ImageData>> m_imageDatas; std::vector<std::unique_ptr<std::thread>> m_threads; public: void load( const std::string& folderPath ) { std::vector<std::string> imagePaths = readFolder( folderPath ); m_imageDatas = createImageDatas( imagePaths ); const unsigned numThreads = std::thread::hardware_concurrency(); std::vector<std::vector<std::weak_ptr<ImageData>>> splitDatas = splitImageDatasToWeak( m_imageDatas, numThreads ); for( auto& dataRangeToLoad : splitDatas ) m_threads.push_back( std::make_unique<std::thread>(read, dataRangeToLoad) ); } };
class A { shared_ptr<int> sPtr1; weak_ptr<int> wPtr1; }
shard_ptr<A> <----| shared_ptr<B> <------ ^ | ^ | | | | | | | | | | | | | | | | | class A | class B | | | | | | ------------ | | | -------------------------------------
class B; class A { shared_ptr<B> sP1; public: A() { cout << "A()" << endl; } ~A() { cout << "~A()" << endl; } void setShared(shared_ptr<B>& p) { sP1 = p; } }; class B { shared_ptr<A> sP1; public: B() { cout << "B()" << endl; } ~B() { cout << "~B()" << endl; } void setShared(shared_ptr<A>& p) { sP1 = p; } }; int main() { shared_ptr<A> aPtr(new A); shared_ptr<B> bPtr(new B); aPtr->setShared(bPtr); bPtr->setShared(aPtr); return 0; }
std::shared_ptr< Texture > texture; struct Widget { std::weak_ptr< Texture > texture_handle; void render() { if (auto texture = texture_handle.get(); texture) { } else { } } };
struct Node { std::shared_ptr< Node > next; std::shared_ptr< Node > prev; }; struct Node { std::shared_ptr< Node > parent; std::shared_ptr< Node > left_child; std::shared_ptr< Node > right_child; }; struct Node { std::shared_ptr< Node > next; std::weak_ptr< Node > prev; }; struct Node { std::weak_ptr< Node > parent; std::shared_ptr< Node > left_child; std::shared_ptr< Node > right_child; };
void divide(int dividend, int divisor, int& quotient, int& remainder);
int divide(int dividend, int divisor, int& remainder);
struct divide_result { int quotient; int remainder; }; divide_result divide(int dividend, int divisor);
std::tuple<int, int> divide(int dividend, int divisor) { return std::make_tuple(dividend / divisor, dividend % divisor); } int main() { using namespace std; int quotient, remainder; tie(quotient, remainder) = divide(14, 3); cout << quotient << }
std::tuple<int, int> divide(int dividend, int divisor) { return {dividend / divisor, dividend % divisor}; } int main() { using namespace std; auto [quotient, remainder] = divide(14, 3); cout << quotient << }
auto divide(int dividend, int divisor) { struct result {int quotient; int remainder;}; return result {dividend / divisor, dividend % divisor}; } int main() { using namespace std; auto result = divide(14, 3); cout << result.quotient << auto [quotient, remainder] = divide(14, 3); cout << quotient << }
pair<double,double> calculateResultingVelocity(double windSpeed, double windAzimuth, double planeAirspeed, double planeCourse); pair<double,double> result = calculateResultingVelocity(25, 320, 280, 90); cout << result.first << endl; cout << result.second << endl;
struct Velocity { double speed; double azimuth; }; Velocity calculateResultingVelocity(double windSpeed, double windAzimuth, double planeAirspeed, double planeCourse); Velocity result = calculateResultingVelocity(25, 320, 280, 90); cout << result.speed << endl; cout << result.azimuth << endl;
std::pair<int, int> divide(int dividend, int divisor) { return std::make_pair(quotient, remainder); } std::pair<int, int> answer = divide(5,2);
template<typename T1,typename T2,typename T3> struct many { T1 a; T2 b; T3 c; }; template<class T1, class T2, class T3> many(T1, T2, T3) -> many<T1, T2, T3>; auto f(){ return many{string(),5.7, unmovable()}; }; int main(){ auto [x,y,z] = f(); }
using namespace std; tuple < int,int,int,int,int > cal(int n1, int n2) { return make_tuple(n1/n2,n1%n2,n1+n2,n1-n2,n1*n2); } int main() { int qut,rer,add,sub,mul,a,b; cin>>a>>b; tie(qut,rer,add,sub,mul)=cal(a,b); cout << "quotient= "<<qut<<endl; cout << "remainder= "<<rer<<endl; cout << "addition= "<<add<<endl; cout << "subtraction= "<<sub<<endl; cout << "multiplication= "<<mul<<endl; return 0; }
class div{ public: int remainder; int quotient(int dividend, int divisor){ remainder = ...; return ...; } };
template<class T> struct out { std::function<void(T)> target; out(T* t):target([t](T&& in){ *t = std::move(in); }) {} out(std::aligned_storage_t<sizeof(T), alignof(T)>* t): target([t](T&& in){ ::new( (void*)t ) T(std::move(in)); } ) {} template<class...Args> void emplace(Args&&...args) { target( T(std::forward<Args>(args)...) ); } template<class X> void operator=(X&&x){ emplace(std::forward<X>(x)); } template<class...Args> void operator()(Args...&&args){ emplace(std::forward<Args>(args)...); } };
struct foo_r { int result; int other_result; }; foo_r foo();
int result, other_result; std::tie(result, other_result) = foo();
void foo( std::function<void(int result, int other_result)> );
void get_all_values( std::function<void(int)> value )
void foo( std::function<void(int, std::function<void(int)>)> result );
foo( [&](int result, auto&& other){ other([&](int other){ }) });
void foo( std::function< void(span<int>) > results )
void foo( std::function< void(span<int>) > results ) { int local_buffer[1024]; std::size_t used = 0; auto send_data=[&]{ if (!used) return; results({ local_buffer, used }); used = 0; }; auto add_datum=[&](int x){ local_buffer[used] = x; ++used; if (used == 1024) send_data(); }; auto add_data=[&](gsl::span<int const> xs) { for (auto x:xs) add_datum(x); }; for (int i = 0; i < 7+(1<<20); ++i) { add_datum(i); } send_data(); }
std::function<void(std::function<void(int result, int other_result)>)> foo(int input);
template<class...Args> struct broadcaster; broadcaster<int, int> foo();
include "boost/tuple/tuple.hpp" tuple <int,int> divide( int dividend,int divisor ) { return make_tuple(dividend / divisor,dividend % divisor ) }
namespace { const int SIZE_OF_ARRAY_X; const int SIZE_OF_ARRAY_Y; bool getState(userType*,otherUserType*); } newusertype::newusertype(...) {...
namespace unique { } using namespace unique; namespace unique { }
template<int * ptr> struct sample { }; sample<&a1> s1; sample<&a2> s2;
namespace __unique_compiler_generated_identifer0x42 { ... } using namespace __unique_compiler_generated_identifer0x42;
namespace { const int SIZE_OF_ARRAY_X; const int SIZE_OF_ARRAY_Y;
namespace { double a; void b(double x) { a -= x; } void add_val(double x) { a += x; if(x==0.01) b(0); if(x==0.02) b(0.6); if(x==0.03) b(-0.1); if(x==0.04) b(0.4); } } int main() { a = 0; for(int i=0; i<1000000000; ++i) { add_val(i*1e-10); } std::cout << a << return 0; }
for(auto iv = begin(a); iv != end(a); ++iv) { Type& v = *iv; ... }
{ auto && __range = range_expression ; for (auto __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) { range_declaration = *__begin; loop_statement } }
{ auto && __range = range_expression ; auto __begin = begin_expr; auto __end = end_expr for (;__begin != __end; ++__begin) { range_declaration = *__begin; loop_statement } }
struct null_sentinal_t { template<class Rhs, std::enable_if_t<!std::is_same<Rhs, null_sentinal_t>{},int> =0 > friend bool operator==(Rhs const& ptr, null_sentinal_t) { return !*ptr; } template<class Rhs, std::enable_if_t<!std::is_same<Rhs, null_sentinal_t>{},int> =0 > friend bool operator!=(Rhs const& ptr, null_sentinal_t) { return !(ptr==null_sentinal_t{}); } template<class Lhs, std::enable_if_t<!std::is_same<Lhs, null_sentinal_t>{},int> =0 > friend bool operator==(null_sentinal_t, Lhs const& ptr) { return !*ptr; } template<class Lhs, std::enable_if_t<!std::is_same<Lhs, null_sentinal_t>{},int> =0 > friend bool operator!=(null_sentinal_t, Lhs const& ptr) { return !(null_sentinal_t{}==ptr); } friend bool operator==(null_sentinal_t, null_sentinal_t) { return true; } friend bool operator!=(null_sentinal_t, null_sentinal_t) { return false; } };
int i=0; struct A { A() { std::generate(&v[0], &v[10], [&i](){ return ++i;} ); } int * begin() { return &v[0]; } int * end() { return &v[10]; } int v[10]; }; int main() { A a; for( auto it : a ) { std::cout << it << std::endl; } }
namespace foo{ int i=0; struct A { A() { std::generate(&v[0], &v[10], [&i](){ return ++i;} ); } int v[10]; }; int *begin( A &v ) { return &v.v[0]; } int *end( A &v ) { return &v.v[10]; } } int main() { foo::A a; for( auto it : a ) { std::cout << it << std::endl; } }
template <typename DataType> class PodArray { public: class iterator { public: iterator(DataType * ptr): ptr(ptr){} iterator operator++() { ++ptr; return *this; } bool operator!=(const iterator & other) const { return ptr != other.ptr; } const DataType& operator*() const { return *ptr; } private: DataType* ptr; }; private: unsigned len; DataType *val; public: iterator begin() const { return iterator(val); } iterator end() const { return iterator(val + len); } };
PodArray<char> array; for(auto& c : array) printf("char: %c\n", c);
using std::cout; using std::endl; using std::string; using std::vector; using std::map; class VectorValues { private: vector<int> v = vector<int>(10); public: vector<int>::iterator begin(){ return v.begin(); } vector<int>::iterator end(){ return v.end(); } vector<int>::const_iterator begin() const { return v.begin(); } vector<int>::const_iterator end() const { return v.end(); } }; class MapValues { private: map<string,int> v; public: map<string,int>::iterator begin(){ return v.begin(); } map<string,int>::iterator end(){ return v.end(); } map<string,int>::const_iterator begin() const { return v.begin(); } map<string,int>::const_iterator end() const { return v.end(); } const int& operator[](string key) const { return v.at(key); } int& operator[](string key) { return v[key]; } }; int main() { VectorValues items; int i = 0; for(int& item : items) { item = i; i++; } for(int& item : items) cout << item << " "; cout << endl << endl; MapValues m; m["a"] = 1; m["b"] = 2; m["c"] = 3; for(auto pair: m) cout << pair.first << " " << pair.second << endl; }
using namespace std; template<typename T, int sizeOfArray> class MyCustomType { private: T *data; int indx; public: MyCustomType(){ data = new T[sizeOfArray]; indx = -1; } ~MyCustomType(){ delete []data; } void addData(T newVal){ data[++indx] = newVal; } T* begin(){ return &data[0]; } T* end(){ return &data[sizeOfArray]; } }; int main() { MyCustomType<double, 2> numberList; numberList.addData(20.25); numberList.addData(50.12); for(auto val: numberList){ cout<<val<<endl; } return 0; }
class MyCustomClass{ QList<MyCustomDatatype> data_; public: QList<MyCustomDatatype>::iterator begin() { return data_.begin(); } QList<MyCustomDatatype>::iterator end() { return data_.end(); } QList<MyCustomDatatype>::const_iterator begin() const{ return data_.constBegin(); } QList<MyCustomDatatype>::const_iterator end() const{ return data_.constEnd(); } };
float f; int i; for (i = 0,f = 0.0; i < 5; i++) { }
{ float f; int i; for (i = 0,f = 0.0; i < 5; i++) { } }
for(struct { int a; char b; } s = { 0, { std::cout << s.a << " " << s.b << std::endl; }
for (auto [i, f, s] = std::tuple{1, 1.0, std::string{"abc"}}; i < N; ++i) { }
for (auto p = std::make_pair(5, std::string("Hello World")); p.first < 10; ++p.first) { std::cout << p.second << std::endl; }
for (auto t = std::make_tuple(0, std::string("Hello world"), std::vector<int>{}); std::get<0>(t) < 10; ++std::get<0>(t)) { std::cout << std::get<1>(t) << std::endl; std::get<2>(t).push_back(std::get<0>(t)); }
for (auto t = std::make_tuple(0, std::string("Hello world"), std::vector<int>{}); std::get<0>(t) < 10; ++std::get<0>(t)) { auto& i = std::get<0>(t); auto& s = std::get<1>(t); auto& v = std::get<2>(t); std::cout << s << std::endl; v.push_back(i); }
for (std::pair<int, std::string> p(5, "Hello World"); p.first < 10; ++p.first) { std::cout << p.second << std::endl; }
std::vector<char> vec(1000000); std::unique_ptr<char[]> p(new char[1000000]);
void legacy_func(const int *array_or_null); void some_func() { std::unique_ptr<int[]> ptr; if (some_condition) { ptr.reset(new int[10]); } legacy_func(ptr.get()); }
std::unique_ptr<BYTE[]> buffer; UINT32 bufferLength = ; LONG returnCode = ERROR_INSUFFICIENT_BUFFER; while (returnCode == ERROR_INSUFFICIENT_BUFFER) { buffer.reset( BYTE[bufferLength] ); // // // // // // returnCode = ::SomeApiCall(inParam1, inParam2, inParam3, &bufferLength, buffer.get(), &outParam1, &outParam2); } if (Failed(returnCode)) { ... } ...
unique_ptr<byte[]> data = get_some_data(); threadpool->post_work([](void* param) { do_a_thing(unique_ptr<byte[]>((byte*)param)); }, data.release());
class ALargeAndComplicatedClassWithLotsOfDependencies; class MyClass { ... private: std::unique_ptr<ALargeAndComplicatedClassWithLotsOfDependencies[]> m_InternalArray; };
foo * f; void bar(foo g) { g.i = 10; f->i = 2; g.i += 5; }
class Person { public: Person(std::string name) : name_(std::move(name)) {} private: std::string name_; };
template <typename PointerType> class MyIterator { }; typedef MyIterator<int*> iterator_type; typedef MyIterator<const int*> const_iterator_type;
template<typename blDataType> class blRawIterator : public std::iterator<std::random_access_iterator_tag, blDataType, ptrdiff_t, blDataType*, blDataType&> { public: blRawIterator(blDataType* ptr = nullptr){m_ptr = ptr;} blRawIterator(const blRawIterator<blDataType>& rawIterator) = default; ~blRawIterator(){} blRawIterator<blDataType>& operator=(const blRawIterator<blDataType>& rawIterator) = default; blRawIterator<blDataType>& operator=(blDataType* ptr){m_ptr = ptr;return (*this);} operator bool()const { if(m_ptr) return true; else return false; } bool operator==(const blRawIterator<blDataType>& rawIterator)const{return (m_ptr == rawIterator.getConstPtr());} bool operator!=(const blRawIterator<blDataType>& rawIterator)const{return (m_ptr != rawIterator.getConstPtr());} blRawIterator<blDataType>& operator+=(const ptrdiff_t& movement){m_ptr += movement;return (*this);} blRawIterator<blDataType>& operator-=(const ptrdiff_t& movement){m_ptr -= movement;return (*this);} blRawIterator<blDataType>& operator++(){++m_ptr;return (*this);} blRawIterator<blDataType>& operator--(){--m_ptr;return (*this);} blRawIterator<blDataType> operator++(ptrdiff_t){auto temp(*this);++m_ptr;return temp;} blRawIterator<blDataType> operator--(ptrdiff_t){auto temp(*this);--m_ptr;return temp;} blRawIterator<blDataType> operator+(const ptrdiff_t& movement){auto oldPtr = m_ptr;m_ptr+=movement;auto temp(*this);m_ptr = oldPtr;return temp;} blRawIterator<blDataType> operator-(const ptrdiff_t& movement){auto oldPtr = m_ptr;m_ptr-=movement;auto temp(*this);m_ptr = oldPtr;return temp;} ptrdiff_t operator-(const blRawIterator<blDataType>& rawIterator){return std::distance(rawIterator.getPtr(),this->getPtr());} blDataType& operator*(){return *m_ptr;} const blDataType& operator*()const{return *m_ptr;} blDataType* operator->(){return m_ptr;} blDataType* getPtr()const{return m_ptr;} const blDataType* getConstPtr()const{return m_ptr;} protected: blDataType* m_ptr; };
template<typename blDataType> class blRawReverseIterator : public blRawIterator<blDataType> { public: blRawReverseIterator(blDataType* ptr = nullptr):blRawIterator<blDataType>(ptr){} blRawReverseIterator(const blRawIterator<blDataType>& rawIterator){this->m_ptr = rawIterator.getPtr();} blRawReverseIterator(const blRawReverseIterator<blDataType>& rawReverseIterator) = default; ~blRawReverseIterator(){} blRawReverseIterator<blDataType>& operator=(const blRawReverseIterator<blDataType>& rawReverseIterator) = default; blRawReverseIterator<blDataType>& operator=(const blRawIterator<blDataType>& rawIterator){this->m_ptr = rawIterator.getPtr();return (*this);} blRawReverseIterator<blDataType>& operator=(blDataType* ptr){this->setPtr(ptr);return (*this);} blRawReverseIterator<blDataType>& operator+=(const ptrdiff_t& movement){this->m_ptr -= movement;return (*this);} blRawReverseIterator<blDataType>& operator-=(const ptrdiff_t& movement){this->m_ptr += movement;return (*this);} blRawReverseIterator<blDataType>& operator++(){--this->m_ptr;return (*this);} blRawReverseIterator<blDataType>& operator--(){++this->m_ptr;return (*this);} blRawReverseIterator<blDataType> operator++(ptrdiff_t){auto temp(*this);--this->m_ptr;return temp;} blRawReverseIterator<blDataType> operator--(ptrdiff_t){auto temp(*this);++this->m_ptr;return temp;} blRawReverseIterator<blDataType> operator+(const int& movement){auto oldPtr = this->m_ptr;this->m_ptr-=movement;auto temp(*this);this->m_ptr = oldPtr;return temp;} blRawReverseIterator<blDataType> operator-(const int& movement){auto oldPtr = this->m_ptr;this->m_ptr+=movement;auto temp(*this);this->m_ptr = oldPtr;return temp;} ptrdiff_t operator-(const blRawReverseIterator<blDataType>& rawReverseIterator){return std::distance(this->getPtr(),rawReverseIterator.getPtr());} blRawIterator<blDataType> base(){blRawIterator<blDataType> forwardIterator(this->m_ptr); ++forwardIterator; return forwardIterator;} };
template<typename blDataType> class blCustomContainer { public: typedef blRawIterator<blDataType> iterator; typedef blRawIterator<const blDataType> const_iterator; typedef blRawReverseIterator<blDataType> reverse_iterator; typedef blRawReverseIterator<const blDataType> const_reverse_iterator; . . . public: iterator begin(){return iterator(&m_data[0]);} iterator end(){return iterator(&m_data[m_size]);} const_iterator cbegin(){return const_iterator(&m_data[0]);} const_iterator cend(){return const_iterator(&m_data[m_size]);} reverse_iterator rbegin(){return reverse_iterator(&m_data[m_size - 1]);} reverse_iterator rend(){return reverse_iterator(&m_data[-1]);} const_reverse_iterator crbegin(){return const_reverse_iterator(&m_data[m_size - 1]);} const_reverse_iterator crend(){return const_reverse_iterator(&m_data[-1]);} . . . blDataType* m_data; };
template <class Value> class node_iter : public boost::iterator_adaptor< node_iter<Value> , Value* , boost::use_default , boost::forward_traversal_tag > { private: struct enabler {}; public: node_iter() : node_iter::iterator_adaptor_(0) {} explicit node_iter(Value* p) : node_iter::iterator_adaptor_(p) {} template <class OtherValue> node_iter( node_iter<OtherValue> const& other , typename boost::enable_if< boost::is_convertible<OtherValue*,Value*> , enabler >::type = enabler() ) : node_iter::iterator_adaptor_(other.base()) {} private: friend class boost::iterator_core_access; void increment() { this->base_reference() = this->base()->next(); } };
template<class T, class Tag = void> class IntrusiveSlistIterator : public std::iterator<std::forward_iterator_tag, T> { typedef SlistNode<Tag> Node; Node* node_; public: IntrusiveSlistIterator(Node* node); T& operator*() const; T* operator->() const; IntrusiveSlistIterator& operator++(); IntrusiveSlistIterator operator++(int); friend bool operator==(IntrusiveSlistIterator a, IntrusiveSlistIterator b); friend bool operator!=(IntrusiveSlistIterator a, IntrusiveSlistIterator b); operator IntrusiveSlistIterator<T const, Tag>() const; };
template< class ValueType, class NodeType > struct my_iterator : std::iterator< std::bidirectional_iterator_tag, T > { ValueType &operator*() { return cur->payload; } template< class VT2, class NT2 > friend bool operator== ( my_iterator const &lhs, my_iterator< VT2, NT2 > const &rhs ); private: NodeType *cur; friend class my_container; my_iterator( NodeType * ); }; typedef my_iterator< T, my_node< T > > iterator; typedef my_iterator< T const, my_node< T > const > const_iterator;
struct myClass { std::vector<float> vec; STL_TYPEDEFS(float); struct it_state { int pos; inline void begin(const myClass* ref) { pos = 0; } inline void next(const myClass* ref) { ++pos; } inline void end(const myClass* ref) { pos = ref->vec.size(); } inline float& get(myClass* ref) { return ref->vec[pos]; } inline bool cmp(const it_state& s) const { return pos != s.pos; } inline void prev(const myClass* ref) { --pos; } inline const float& get(const myClass* ref) const { return ref->vec[pos]; } }; SETUP_ITERATORS(myClass, float&, it_state); SETUP_REVERSE_ITERATORS(myClass, float&, it_state); };
int main() { myClass c1; c1.vec.push_back(1.0); c1.vec.push_back(2.0); c1.vec.push_back(3.0); std::cout << "iterator:" << std::endl; for (float& val : c1) { std::cout << val << " "; } std::cout << "reverse iterator:" << std::endl; for (auto it = c1.rbegin(); it != c1.rend(); ++it) { std::cout << *it << " "; } }
try { File file = new File("/path/to/file"); } finally { file.close(); }
std::string* foo() { std::string str; return &str; }
std::string* foo() { std::string* str = new std::string(); return str; }
shared_ptr<std::string> foo() { shared_ptr<std::string> str = new std::string(); return str; }
shared_ptr<std::string> str = foo(); shared_ptr<std::string> str2 = str;
void setLog(const Foo & foo, const Bar & bar) { File file("/path/to/file", File::append); foo.setLogFile(file); bar.setLogFile(file); }
void setLog(const Foo & foo, const Bar & bar) { File* file = new File("/path/to/file", File::append); foo.setLogFile(file); bar.setLogFile(file); }
void setLog(const Foo & foo, const Bar & bar) { shared_ptr<File> file = new File("/path/to/file", File::append); foo.setLogFile(file); bar.setLogFile(file); }
void o_really() { resource * r = allocate_resource(); try { } catch(...) { deallocate_resource(r); throw; } if(...) { return; } deallocate_resource(r); }
struct resource_holder { resource_holder() { r = allocate_resource(); } ~resource_holder() { deallocate_resource(r); } resource * r; }; void o_really() { resource_holder r; if(...) { return; } }
shared_ptr<Entry> create_entry(Parameters p) { shared_ptr<Entry> e(Entry::createEntry(p), &Entry::freeEntry); return e; }
unique_ptr<plot_src> p(new plot_src); unique_ptr<plot_src> u(move(p)); unique_ptr<plot_src> v(u); vector<unique_ptr<plot_src>> pv; pv.emplace_back(new plot_src); pv.emplace_back(new plot_src);
void do_something() { scoped_ptr<pipe> sp(new pipe); }
shared_ptr<plot_src> p(new plot_src(&fx)); plot1->add(p)->setColor(" plot2->add(p)->setColor("
std::map<Big, Bigger> createBigMap(); void example () { std::map<Big, Bigger> map; createBigMap().swap(map); }
struct B : public A { virtual void hello() { ... } };
struct Base { virtual void some_func(float); }; struct Derived : Base { virtual void some_func(int) override; };
struct None {}; template<typename... Interfaces> struct B : public Interfaces { void hello() { ... } }; struct A { virtual void hello() = 0; }; template<typename... Interfaces> void t_hello(const B<Interfaces...>& b) { b.hello(); } void hello(const A& a) { a.hello(); } int main() { B<None> b; B<None>* pb = &b; B<None>& rb = b; b.hello(); pb->hello(); rb->hello(); t_hello(b); B<A> ba; B<None>* pba = &ba; B<None>& rba = ba; ba.hello(); pba->hello(); rba->hello(); hello(ba); }
struct B : public A { virtual void hello() { ... } }; struct C : public B { void hello() { ... } };
struct Base { virtual int foo() const; }; struct Derived : Base { virtual int foo() { } };
struct aggregate { int foo; int bar; }; std::vector<aggregate> v; v.push_back({ 42, 121 });
std::vector<T> v; v.push_back(x); v.emplace_back(x);
std::vector<std::unique_ptr<T>> v; T a; v.emplace_back(std::addressof(a)); v.push_back(std::addressof(a));
std::vector<int> v; v.emplace_back(123); v.emplace_back(v[0]);
std::vector<int> v; v.emplace_back(123); v.push_back(v[0]);
template <Constraint T> void foo(T x) { auto bar = [](auto x){}; }
using namespace std; template<typename T> void boring_template_fn(T t){ auto identity = [](decltype(t) t){ return t;}; std::cout << identity(t) << std::endl; } int main(int argc, char *argv[]) { std::string s("My string"); boring_template_fn(s); boring_template_fn(1024); boring_template_fn(true); }
auto get_container_size = [] (auto container) { return container.size(); };
template <class something> inline std::function<void()> templateLamda() { return [](){ std::cout << something.memberfunc() }; }
base::for_each(_widgets, [] <typename Key_T, typename Widget_T> (boost::fusion::pair<Key_T, Widget_T*>& pair) -> void { pair.second = new Widget_T(); pair.second->set_label_str(Key_T::label); } );
template <typename DATUM> std::function<double(DATUM)> makeUnweighted() { return [](DATUM datum){return 1.0;}; }
int main() { auto slice = [](auto input, int beg, int end) { using T = decltype(input); const auto size = input.size(); if (beg > size || end > size || beg < 0 || end < 0) { throw std::out_of_range("beg/end must be between [0, input.size())"); } if (beg > end) { throw std::invalid_argument("beg must be less than end"); } return T(input.begin() + beg, input.begin() + end); }; auto v = std::vector<int> { 1,2,3,4,5 }; for (auto e : slice(v, 1, 4)) { std::cout << e << " "; } std::cout << std::endl; }
template <typename T> struct LamT { static void Go() { auto lam = []() { T var; std::cout << "lam, type = " << typeid(var).name() << std::endl; }; lam(); } };
LamT<int>::Go(); LamT<char>::Go(); lam, type = i lam, type = c
error: a template declaration cannot appear at block scope
template <typename T> using LamdaT = decltype( [](void) { std::cout << "LambT type = " << typeid(T).name() << std::endl; });
Logger& g_logger() { static Logger lg; return lg; }
class Foo { public: static const int MEMBER = 1; }; int main(){ vector<int> v; v.push_back( Foo::MEMBER ); v.push_back( (int) Foo::MEMBER ); return 0; }
class Foo { }; const int Foo::MEMBER; int main() { }
class Foo { public: static const int MEMBER; }; const int Foo::MEMBER = 1; int main(){ std::vector<int> v; v.push_back( Foo::MEMBER ); v.push_back( (int) Foo::MEMBER ); return 0; }
class Foo { public: static constexpr int MEMBER = 1; };
unique_ptr<T> myPtr(new T); unique_ptr<T> myOtherPtr = myPtr;
unique_ptr<T> myPtr(new T); unique_ptr<T> myOtherPtr = std::move(myPtr);
unique_ptr<T> MyFunction() { unique_ptr<T> myPtr( ); return myPtr; }
shared_ptr<T> myPtr(new T); shared_ptr<T> myOtherPtr = myPtr;
void waitForSemaphore() { volatile uint16_t* semPtr = WELL_KNOWN_SEM_ADDR; while ((*semPtr) != IS_OK_FOR_ME_TO_PROCEED); }
LONG __cdecl InterlockedIncrement( __inout LONG volatile *Addend );
static volatile sig_atomic_t sig_num = 0; static void sig_handler(int signum) { signal(signum, sig_handler); sig_num = signum; }
template <typename T> class Foo { std::enable_if_t<sizeof(T)==4, void> f(T& t) { std::cout << 1 << t; } void f(T volatile& t) { std::cout << 2 << const_cast<T&>(t); } void bar() { T t; f(t); } };
class Derived : public Base { public : typedef Base super; } ;
class DerivedDerived : public Derived { public : typedef Derived super; } ; void DerivedDerived::bar() { super::bar() ; super::super::bar ; }
class MyClass : public MyBase { private: typedef MyBase inherited; ...
class Base { public: virtual void foo() { ... } }; class Derived: public Base { public: typedef Base super; virtual void foo() { super::foo(); ... } }; class DerivedAgain: public Derived { public: virtual void foo() { super::foo(); ... } };
template <class C> struct MakeAlias : C { typedef C BaseAlias; };
class Derived : public Base { private: typedef Base Super; };
template <typename TText, typename TSpec> class Finder<Index<TText, PizzaChili<TSpec> >, PizzaChiliFinder> : public Finder<Index<TText, PizzaChili<TSpec> >, Default> { typedef Finder<Index<TText, PizzaChili<TSpec> >, Default> TBase; }
template <typename T, size_t C, typename U> class A { ... }; template <typename T> class B : public A<T,99,T> { ... };
template<typename BaseClass> class PrimaryParent : virtual public BaseClass { protected: using super = BaseClass; public: template<typename ...ArgTypes> PrimaryParent<BaseClass>(ArgTypes... args) : BaseClass(args...){} }
class MyObject : public PrimaryParent<SomeBaseClass> { public: MyObject() : PrimaryParent<SomeBaseClass>(SomeParams) {} }
class SomeOtherBase : public PrimaryParent<Ancestor>{} class MixinClass {} class BaseClass : public PrimaryParent<SomeOtherBase>, public MixinClass {} class MyObject : public PrimaryParent<BaseClass>, public SomeOtherBase{} class MyObject : public PrimaryParent<BaseClass>, public PrimaryParent<SomeOtherBase>{}
template<typename T> class CLASS : SUPER_CLASS { typedef CLASS<T> class_type; class_type& operator++(); }; template<typename T> typename CLASS<T>::class_type CLASS<T>::operator++( int) { class_type copy = *this; ++SUPER; return copy; }
for(int counter = 0; counter <= 10; counter++) { string someString = "testing"; cout << someString; }
{ int i, retainValue; for (i=0; i<N; i++) { int tmpValue; } }
int result; (...) result = f1(); if (result) then { (...) } (...) result = f2(); if (result) then { (...) }
(...) { int const result = f1(); if (result) then { (...) } } (...) { int const result = f2(); if (result) then { (...) } }
for (int counter = 0; counter <= 10; counter++) { const char testing[] = "testing"; cout << testing; }
const std::string testing = "testing"; for (int counter = 0; counter <= 10; counter++) { cout << testing; }
for (int counter = 0; counter <= 10; counter++) { string testing = "testing"; cout << testing; }
string testing; for (int counter = 0; counter <= 10; counter++) { testing = "testing"; cout << testing; }
class myTimeEatingClass { public: myTimeEatingClass() { sleep(2000); ms_usedTime+=2; } ~myTimeEatingClass() { sleep(3000); ms_usedTime+=3; } const unsigned int getTime() const { return ms_usedTime; } static unsigned int ms_usedTime; };
myTimeEatingClass::ms_CreationTime=0; myFunc() { for (int counter = 0; counter <= 10; counter++) { myTimeEatingClass timeEater(); } cout << "Creating class took "<< timeEater.getTime() <<"seconds at all<<endl; } myOtherFunc() { myTimeEatingClass timeEater(); for (int counter = 0; counter <= 10; counter++) { } cout << "Creating class took "<< timeEater.getTime() <<"seconds at all<<endl; }
{ string someString = "testing"; for(int counter = 0; counter <= 10; counter++) { cout << someString; } }
class A { public: A() { x = 0; } A(int x_) { x = x_; } int x; }; class B { public: B() { a.x = 3; } private: A a; };
class A { public: A(int x_) { x = x_; } int x; } class B { public: B() : a(3), y(2) { } private: A a; const int y; };
class MyClass { Type variable; public: MyClass(Type a) { variable = a; } };
class MyClass { Type variable; public: MyClass(Type a):variable(a) { } };
class Sample { public: int Sam_x; int Sam_y; Sample(): Sam_x(1), Sam_y(2) { } };
class Sample { public: int Sam_x; int Sam_y; Sample() * * { Sam_x = 1; * * Sam_y = 2; } };
class Sample1 { int i; public: Sample1 (int temp) { i = temp; } }; class Sample2 { Sample1 a; public: Sample2 (int x): a(x) { } };
1. Default constructor of Sample1 class 2. Initialization list in Sample2 class which will call the parametric constructor of Sample1 class (as per above program)
class Sample3 { int i; public: Sample3 (int i) { i = i; print(i); } int getI() const { print(i); return i; } };
class NumArray { public: vector<int> preSum; NumArray(vector<int> nums) { preSum = vector<int>(nums.size()+1, 0); int ps = 0; for (int i = 0; i < nums.size(); i++) { ps += nums[i]; preSum[i+1] = ps; } } int sumRange(int i, int j) { return preSum[j+1] - preSum[i]; } };
class NumArray { public: vector<int> preSum; NumArray(vector<int> nums) : preSum(nums.size()+1, 0) { int ps = 0; for (int i = 0; i < nums.size(); i++) { ps += nums[i]; preSum[i+1] = ps; } } int sumRange(int i, int j) { return preSum[j+1] - preSum[i]; } };
int vv[2] = { 12,43 }; std::vector<int> v(&vv[0], &vv[0]+2);
template <typename T, size_t N> T* begin(T(&arr)[N]) { return &arr[0]; } template <typename T, size_t N> T* end(T(&arr)[N]) { return &arr[0]+N; }
int vv[] = { 12,43 }; std::vector<int> v(begin(vv), end(vv));
template <typename T> class make_vector { public: typedef make_vector<T> my_type; my_type& operator<< (const T& val) { data_.push_back(val); return *this; } operator std::vector<T>() const { return data_; } private: std::vector<T> data_; };
std::vector<int> v = make_vector<int>() << 1 << 2 << 3;
struct mycclass { template<class T=int> void mymember(T* vec) { } };
template<typename Iterator, typename Comp = std::less< typename std::iterator_traits<Iterator>::value_type> > void sort(Iterator beg, Iterator end, Comp c = Comp()) { ... }
struct S { template <class R = int> R get_me_R() { return R(); } };
struct S { template <class R> R get_me_R() { return R(); } int get_me_R() { return int(); } };
template <int N = 1> int &increment(int &i) { i += N; return i; }
template <int N> int &increment(int &i) { i += N; return i; } int &increment(int &i) { return increment<1>(i); }
template<typename Iterator, typename Comp = std::less<Iterator> > void sort(Iterator beg, Iterator end, Comp c = Comp())
template<typename Iterator> void sort(Iterator beg, Iterator end, std::less<Iterator> c = std::less<Iterator>()) template<typename Iterator, typename Comp > void sort(Iterator beg, Iterator end, Comp c = Comp())
template <class T, class U = double> void f(T t = 0, U u = 0);
template <typename S, typename T> void f(S s = 0, T t = 0); template <typename S> void f(S s = 0, double t = 0);
template <typename T> T prettify(T t) { return t; } std::string prettify(char c) { std::stringstream ss; if (isprint((unsigned char)c)) { ss << " } else { ss << (int)c; } return ss.str(); } template <typename S, typename T> void g(S s, T t){ std::cout << "f<" << typeid(S).name() << "," << typeid(T).name() << ">(" << s << "," << prettify(t) << ")\n"; } template <typename S, typename T> void f(S s = 0, T t = 0){ g<S,T>(s,t); } template <typename S> void f(S s = 0, double t = 0) { g<S,double>(s, t); } int main() { f(1, f(1); f<int>(); f<int,char>(); }
template <typename E, typename ARR_E = MyArray_t<E> > void doStuff(ARR_E array) { E one(1); array.add( one ); }
template <typename T> struct MyArray_t { void add(T i) { } }; template <typename E, typename ARR_E = MyArray_t<E> > class worker { public: ARR_E* parr_; void doStuff(); }; template <typename E, typename ARR_E> void worker<E, ARR_E>::doStuff() { E one(1); parr_->add( one ); }
MyArray_t<int> my_array; worker<int> w; w.parr_ = &arr; w.doStuff();
void foo(int*); void foo (int); void bar() { foo (NULL); }
cerr << sizeof(0) << endl; cerr << sizeof(NULL) << endl; cerr << sizeof(void*) << endl; ============ On a 64-bit gcc RHEL platform you get: 4 8 8 ================
const class nullptr_t { public: template<class T> operator T*() const { return 0; } template<class C, class T> operator T C::*() const { return 0; } private: void operator&() const; } nullptr = {};
std::string str = ???; for(char& c : str) { do_things_with(c); }
std::string str = ???; for(std::string::iterator it = str.begin(); it != str.end(); ++it) { do_things_with(*it); }
std::string str = ???; for(std::string::size_type i = 0; i < str.size(); ++i) { do_things_with(str[i]); }
char* str = ???; for(char* it = str; *it; ++it) { do_things_with(*it); }
string str("HELLO"); for (int i = 0; i < str.size(); i++){ cout << str[i]; }
char str[6] = "hello"; for (int i = 0; str[i] != cout << str[i]; }
std::string s("Hello world"); for (char & c : s) { std::cout << "One character: " << c << "\n"; c = }
for (std::string::iterator it = s.begin(), end = s.end(); it != end; ++it) { std::cout << "One character: " << *it << "\n"; *it = }
const char* str = "abcde"; int len = strlen(str); for (int i = 0; i < len; i++) { char chr = str[i]; }
int main() { std::string name = "some string"; std::for_each(name.begin(), name.end(), [] (char c) { std::cout << c; }); }
char cs[] = "This is a c string\u0031 \x32 3"; for (char& c : cs) { printf("%c", c); }
int ia[] = {1,2,3,4,5,6}; for (int& i : ia) { printf("%d", i); }
char mystring[] = "My String"; int size = strlen(mystring); int i; for(i = 0; i < size; i++) { char c = mystring[i]; }
std::string mystring = "My String"; std::string::iterator it; for(it = mystring.begin(); it != mystring.end(); it++) { char c = *it; }
for (int x = 0; x < yourString.size();x++){ if (yourString[x] == } if (yourString[x] == } if (yourString[x] == } }
string words; for (unsigned int i = 0; i < words.length(); i++) { if (words.at(i) == { spacecounter++; if (words.at(i + 1) == { i += 1; }
class C { C(const C&) = default; C(C&&) = default; C& operator=(const C&) & = default; C& operator=(C&&) & = default; virtual ~C() { } };
attribute-specifier-seq opt decl-specifier-seq opt declarator virt-specifier-seq opt = default ;
struct S { constexpr S() = default; S(int a = 0) = default; void operator=(const S&) = default; ~ S() noexcept(false) = default; private: int i; S(S&); }; S::S(S&) = default;
struct trivial { trivial() = default; trivial(const trivial&) = default; trivial(trivial&&) = default; trivial& operator=(const trivial&) = default; trivial& operator=(trivial&&) = default; ~ trivial() = default; }; struct nontrivial1 { nontrivial1(); }; nontrivial1::nontrivial1() = default;
double get(const double* p, int k) { return p[k]; }
double get(const double* p, std::ptrdiff_t k) { return p[k]; }
v.erase(std::remove(v.begin(), v.end(), 10), v.end());
$ sudo apt-get install openssl Reading package lists... Done Building dependency tree Reading state information... Done openssl is already the newest version. 0 upgraded, 0 newly installed, 0 to remove and 3 not upgraded.
foo.cpp:21:25: error: openssl/bio.h: No such file or directory foo.cpp:22:28: error: openssl/buffer.h: No such file or directory foo.cpp:23:25: error: openssl/des.h: No such file or directory foo.cpp:24:25: error: openssl/evp.h: No such file or directory foo.cpp:25:25: error: openssl/pem.h: No such file or directory foo.cpp:26:25: error: openssl/rsa.h: No such file or directory
sudo apt-get install pkg-config cd WORKDIR git clone https: cd openssl ./config make sudo make install sudo ldconfig
bool is_big_endian(void) { union { uint32_t i; char c[4]; } bint = {0x01020304}; return bint.c[0] == 1; }
int num = 1; if(*(char *)&num == 1) { printf("\nLittle-Endian\n"); } else { printf("Big-Endian\n"); }
if constexpr (std::endian::native == std::endian::big) { } else if constexpr (std::endian::native == std::endian::little) { } else { }
int32 DNA_GetEndianness(void) { union { uint8 c[4]; uint32 i; } u; u.i = 0x01020304; if (0x04 == u.c[0]) return DNA_ENDIAN_LITTLE; else if (0x01 == u.c[0]) return DNA_ENDIAN_BIG; else return DNA_ENDIAN_UNKNOWN; }
PUBLIC _DNA_GetEndianness ; Function compile flags: /Ogtpy ; File c:\development\dna\source\libraries\dna\endian.c ; COMDAT _DNA_GetEndianness _TEXT SEGMENT _DNA_GetEndianness PROC ; COMDAT ; 11 : union ; 12 : { ; 13 : uint8 c[4]; ; 14 : uint32 i; ; 15 : } u; ; 16 : ; 17 : u.i = 1; ; 18 : ; 19 : if (1 == u.c[0]) ; 20 : return DNA_ENDIAN_LITTLE; mov eax, 1 ; 21 : else if (1 == u.c[3]) ; 22 : return DNA_ENDIAN_BIG; ; 23 : else ; 24 : return DNA_ENDIAN_UNKNOWN; ; 25 : } ret _DNA_GetEndianness ENDP END
char* startPart = reinterpret_cast<char*>( &variable ); char* endPart = reinterpret_cast<char*>( &variable ) + sizeof( int ) - 1;
int TestByteOrder() { short int word = 0x0001; char *byte = (char *) &word; return(byte[0] ? LITTLE_ENDIAN : BIG_ENDIAN); }
template <typename T> T endian(T w, uint32_t endian) { union { uint64_t quad; uint32_t islittle; } t; t.quad = 1; if (t.islittle ^ endian) return w; T r = 0; for (int i = 0; i < sizeof(r); i++) { r <<= 8; r |= w & 0xff; w >>= 8; } return r; };
short temp = 0x1234; char* tempChar = (char*)&temp;
bool isBigEndian() { static unsigned long x(1); static bool result(reinterpret_cast<unsigned char*>(&x)[0] == 0); return result; }
bool isBigEndian() { static const uint16_t m_endianCheck(0x00ff); return ( *((uint8_t*)&m_endianCheck) == 0x0); }
union { uint16_t s; unsigned char c[2]; } constexpr static d {1}; constexpr bool is_little_endian() { return d.c[0] == 1; }
union { int i; char c[sizeof(int)]; } x; x.i = 1; if(x.c[0] == 1) printf("little-endian\n"); else printf("big-endian\n");
bool runtimeIsLittleEndian(void) { volatile uint16_t i=1; return ((uint8_t*)&i)[0]==0x01; }
int main() { unsigned int n = 1; char *p = 0; p = (char*)&n; if (*p == 1) std::printf("Little Endian\n"); else if (*(p + sizeof(int) - 1) == 1) std::printf("Big Endian\n"); else std::printf("What the crap?\n"); return 0; }
... if (__BYTE_ORDER == __LITTLE_ENDIAN) { ... } else if (__BYTE_ORDER == __BIG_ENDIAN) { ... } else { throw std::runtime_error("Sorry, this version does not support PDP Endian!"); ...
i = (data[0]<<0) | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
i = *((int*)data); i = ((i&0xFF)<<24) | (((i>>8)&0xFF)<<16) | (((i>>16)&0xFF)<<8) | (((i>>24)&0xFF)<<0);
enum ENDIANESS{ LITTLEENDIAN , BIGENDIAN , UNHANDLE }; ENDIANESS CheckArchEndianalityV1( void ) { int Endian = 0x00000001; return (*(char *) &Endian == 0x01) ? LITTLEENDIAN : BIGENDIAN; }
(((union { __typeof__(VALUE) src; TYPE dest; }){ .src = VALUE }).dest) _Bool is_little_endian(void) { return wicked_cast(unsigned char, 1u); }
int main() { unsigned int i = 1; char *c = (char*)&i; if (*c) printf("Little endian"); else printf("Big endian"); getchar(); return 0; }
int main(void){ int i=1; unsigned char* ii = &i; printf("This computer is %s endian.\n", ((ii[0]==1) ? "little" : "big")); return 0; }
int* _BE = 0; int is_big_endian() { if (_BE == 0) { uint16_t* teste = (uint16_t*)malloc(4); *teste = (*teste & 0x01FE) | 0x0100; uint8_t teste2 = ((uint8_t*) teste)[0]; free(teste); _BE = (int*)malloc(sizeof(int)); *_BE = (0x01 == teste2); } return *_BE; }
struct X { const int n; }; union U { X x; float f; }; ... U u = {{ 1 }};
aligned_storage<sizeof(int), alignof(int)>::type data; new(&data) int; int *p = std::launder(reinterpret_cast<int*>(&data));
struct S { int padding; std::vector<int> v; int * p; std::vector<int>::iterator i; }; int pointer_index (S & s) { return s.p[3]; } int vector_index (S & s) { return s.v[3]; } int pointer_deref (S & s) { return *s.p; } int iterator_deref (S & s) { return *s.i; } void pointer_increment (S & s) { ++s.p; } void iterator_increment (S & s) { ++s.i; }
vector<double> vector; vector.push_back(42); double *array = &(*vector.begin());
int main() { int v[3]; v[0]=1; v[1]=2;v[2]=3; int sum; int starttime=time(NULL); cout << starttime << endl; for (int i=0;i<50000;i++) for (int j=0;j<10000;j++) { X x(v); sum+=x.first(); } int endtime=time(NULL); cout << endtime << endl; cout << endtime - starttime << endl; }
class X { vector<int> vec; public: X(const vector<int>& v) {vec = v;} int first() { return vec[0];} };
class X { int f[3]; public: X(int a[]) {f[0]=a[0]; f[1]=a[1];f[2]=a[2];} int first() { return f[0];} };
const_reference operator[](size_type __n) const { return *(this->_M_impl._M_start + __n); }
+--------------------------------------------------------------------+ | | Numeric values | Non-numeric | | Category +-----------------------------------+ | | | -1 | 0 | +1 | values | +------------------+------+------------+---------------+-------------+ | strong_ordering | less | equal | greater | | | weak_ordering | less | equivalent | greater | | | partial_ordering | less | equivalent | greater | unordered | | strong_equality | | equal | nonequal | | | weak_equality | | equivalent | nonequivalent | | +------------------+------+------------+---------------+-------------+
int main() { switch(std::string("raj")) { case"sda": } }
enum string_code { eFred, eBarney, eWilma, eBetty, ... }; string_code hashit (std::string const& inString) { if (inString == "Fred") return eFred; if (inString == "Barney") return eBarney; ... } void foo() { switch (hashit(stringValue)) { case eFred: ... case eBarney: ... } }
static enum StringValue { evNotDefined, evStringValue1, evStringValue2, evStringValue3, evEnd }; static std::map<std::string, StringValue> s_mapStringValues; static char szInput[_MAX_PATH]; static void Initialize(); int main(int argc, char* argv[]) { Initialize(); while(1) { cout << "Please enter a string (end to terminate): "; cout.flush(); cin.getline(szInput, _MAX_PATH); switch(s_mapStringValues[szInput]) { case evStringValue1: cout << "Detected the first valid string." << endl; break; case evStringValue2: cout << "Detected the second valid string." << endl; break; case evStringValue3: cout << "Detected the third valid string." << endl; break; case evEnd: cout << "Detected program end command. " << "Programm will be stopped." << endl; return(0); default: cout << " << " << s_mapStringValues.size() << " entries." << endl; break; } } return 0; } void Initialize() { s_mapStringValues["First Value"] = evStringValue1; s_mapStringValues["Second Value"] = evStringValue2; s_mapStringValues["Third Value"] = evStringValue3; s_mapStringValues["end"] = evEnd; cout << "s_mapStringValues contains " << s_mapStringValues.size() << " entries." << endl; }
enum class TestType { SetType, GetType }; std::map<std::string, TestType> MnCTest::s_mapStringToTestType = { { "setType", TestType::SetType }, { "getType", TestType::GetType } }; std::map<TestType, std::string> MnCTest::s_mapTestTypeToString { {TestType::SetType, "setType"}, {TestType::GetType, "getType"}, };
std::string someString = "setType"; TestType testType = s_mapStringToTestType[someString]; switch (testType) { case TestType::SetType: break; case TestType::GetType: break; default: LogError("Unknown TestType ", s_mapTestTypeToString[testType]); }
int main() { int result; const std::unordered_map<std::string,std::function<void()>> m{ {"one", [&](){ result = 1; }}, {"two", [&](){ result = 2; }}, {"three", [&](){ result = 3; }}, }; const auto end = m.end(); std::vector<std::string> strings{"one", "two", "three", "foobar"}; for (const auto& s : strings) { auto it = m.find(s); if (it != end) { it->second(); } else { result = -1; } std::cout << s << " " << result << std::endl; } }
class RangeSwitch { public: void method(std::string key, int &result) { static const std::unordered_map<std::string,std::function<void(int&)>> m{ {"one", [](int& result){ result = 1; }}, {"two", [](int& result){ result = 2; }}, {"three", [](int& result){ result = 3; }}, }; static const auto end = m.end(); auto it = m.find(key); if (it != end) { it->second(result); } else { result = -1; } } }; int main() { RangeSwitch rangeSwitch; int result; std::vector<std::string> strings{"one", "two", "three", "foobar"}; for (const auto& s : strings) { rangeSwitch.method(s, result); std::cout << s << " " << result << std::endl; } }
std::string name = "Alice"; std::string gender = "boy"; std::string role; SWITCH(name) CASE("Alice") FALL CASE("Carol") gender = "girl"; FALL CASE("Bob") FALL CASE("Dave") role = "participant"; BREAK CASE("Mallory") FALL CASE("Trudy") role = "attacker"; BREAK CASE("Peggy") gender = "girl"; FALL CASE("Victor") role = "verifier"; BREAK DEFAULT role = "other"; END
constexpr unsigned int hash(const char *s, int off = 0) { return !s[off] ? 5381 : (hash(s, off+1)*33) ^ s[off]; } switch( hash(str) ){ case hash("one") : case hash("two") : }
const static std::unordered_map<std::string,int> string_to_case{ {"raj",1}, {"ben",2} }; switch(string_to_case.at("raj")) { case 1: break; case 2: break; }
const static std::unordered_map<std::string,int> string_to_case{ {"raj",1}, {"ben",2} }; switch(string_to_case.count("raj") ? string_to_case.at("raj") : 0) { case 1: break; case 2: break; case 0: }
cout << "\nEnter word to select your choice\n"; cout << "ex to exit program (0)\n"; cout << "m to set month(1)\n"; cout << "y to set year(2)\n"; cout << "rm to return the month(4)\n"; cout << "ry to return year(5)\n"; cout << "pc to print the calendar for a month(6)\n"; cout << "fdc to print the first day of the month(1)\n"; cin >> c; cout << endl; a = c.compare("ex") ?c.compare("m") ?c.compare("y") ? c.compare("rm")?c.compare("ry") ? c.compare("pc") ? c.compare("fdc") ? 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0; switch (a) { case 0: return 1; case 1: { cout << "enter month\n"; cin >> c; cout << endl; myCalendar.setMonth(c); break; } case 2: cout << "Enter year(yyyy)\n"; cin >> y; cout << endl; myCalendar.setYear(y); break; case 3: myCalendar.getMonth(); break; case 4: myCalendar.getYear(); case 5: cout << "Enter month and year\n"; cin >> c >> y; cout << endl; myCalendar.almanaq(c,y); break; case 6: break; }
class APIHandlerImpl { std::map<string, std::function<void(server*, websocketpp::connection_hdl, string)>> in_events; public: APIHandlerImpl() { in_events["/hello"] = std::bind(&APIHandlerImpl::handleHello, this, _1, _2, _3); in_events["/bye"] = std::bind(&APIHandlerImpl::handleBye, this, _1, _2, _3); } void onEvent(string event = "/hello", string data = "{}") { in_events[event](s, hdl, data); } void APIHandlerImpl::handleHello(server* s, websocketpp::connection_hdl hdl, string data) { } void APIHandlerImpl::handleBye(server* s, websocketpp::connection_hdl hdl, string data) { } }
movf INDEX,W ; move the index value into the W (working) register from memory addwf PCL,F ; add it to the program counter. each PIC instruction is one byte ; so there is no need to perform any multiplication. ; Most architectures will transform the index in some way before ; adding it to the program counter table ; the branch table begins here with this label goto index_zero ; each of these goto instructions is an unconditional branch goto index_one ; of code goto index_two goto index_three index_zero ; code is added here to perform whatever action is required when INDEX = zero return index_one ...
class A { public: typedef struct/class {...} B; ... C::D *someField; } class C { public: typedef struct/class {...} D; ... A::B *someField; }
class IDontControl { class Nested { Nested(int i); }; };
class IDontControl_Nested : public IDontControl::Nested { IDontControl_Nested(int i) : Nested(i) { } };
class MyClass { public: template<typename ThrowAway> void doesStuff(); };
namespace others { struct A { struct Nested { Nested(int i) :i(i) {} int i{}; void print() const { std::cout << i << std::endl; } }; }; }
namespace others { namespace A { class Nested; } } class MyClass { public: MyClass(int i); ~MyClass(); void print() const; private: std::unique_ptr<others::A::Nested> _aNested; };
MyClass::MyClass(int i) : _aNested(std::make_unique<others::A::Nested>(i)) {} MyClass::~MyClass() {} void MyClass::print() const { _aNested->print(); }
namespace C { typedef struct {} D; } class A { public: typedef struct/class {...} B; ... C::D *someField; } class C { public: typedef struct/class {...} D; ... A::B *someField; }
class C_base { public: class D { }; }; class A { public: class B { }; C_base::D *someField; }; class C : public C_base { public: A::B *someField; }; int main() { A a; C::D * test = a.someField; }
if (highly_likely) else if (somewhat_likely) else if (unlikely)
if (unlikely) else if (somewhat_likely) else if (highly_likely)
using namespace std; int main() { long long sortedTime = 0; long long reverseTime = 0; for (int n = 0; n != 500; ++n) { random_device rnd_device; mt19937 rnd_engine(rnd_device()); uniform_int_distribution<int> rnd_dist(1, 100); auto gen = std::bind(rnd_dist, rnd_engine); vector<int> rand_vec(5000); generate(begin(rand_vec), end(rand_vec), gen); volatile int nLow, nMid, nHigh; chrono::time_point<chrono::high_resolution_clock> start, end; nLow = nMid = nHigh = 0; start = chrono::high_resolution_clock::now(); for (int& i : rand_vec) { if (i >= 95) ++nHigh; else if (i < 20) ++nLow; else if (i >= 20 && i < 95) ++nMid; } end = chrono::high_resolution_clock::now(); reverseTime += chrono::duration_cast<chrono::nanoseconds>(end-start).count(); nLow = nMid = nHigh = 0; start = chrono::high_resolution_clock::now(); for (int& i : rand_vec) { if (i >= 20 && i < 95) ++nMid; else if (i < 20) ++nLow; else if (i >= 95) ++nHigh; } end = chrono::high_resolution_clock::now(); sortedTime += chrono::duration_cast<chrono::nanoseconds>(end-start).count(); } cout << "Percentage difference: " << 100 * (double(reverseTime) - double(sortedTime)) / double(sortedTime) << endl << endl; }
using namespace std; int main() { random_device rnd_device; mt19937 rnd_engine(rnd_device()); uniform_int_distribution<int> rnd_dist(1, 100); auto gen = std::bind(rnd_dist, rnd_engine); vector<int> rand_vec(5000); generate(begin(rand_vec), end(rand_vec), gen); volatile int nLow, nMid, nHigh; for (int n = 0; n != 10; ++n) { { nLow = nMid = nHigh = 0; auto start = chrono::high_resolution_clock::now(); for (int& i : rand_vec) { if (i >= 95) ++nHigh; else if (i < 20) ++nLow; else if (i >= 20 && i < 95) ++nMid; } auto end = chrono::high_resolution_clock::now(); cout << "Reverse-sorted: \t" << chrono::duration_cast<chrono::nanoseconds>(end-start).count() << "ns" << endl; } { nLow = nMid = nHigh = 0; auto start = chrono::high_resolution_clock::now(); for (int& i : rand_vec) { if (i >= 20 && i < 95) ++nMid; else if (i < 20) ++nLow; else if (i >= 95) ++nHigh; } auto end = chrono::high_resolution_clock::now(); cout << "Sorted:\t\t\t" << chrono::duration_cast<chrono::nanoseconds>(end-start).count() << "ns" << endl; } cout << endl; } }
for (i = 0; i < data_sz * 1024; i++) { if (data[i] < check_point) s += 3; else if (data[i] > check_point) s += 2; else if (data[i] == check_point) s += 1; }
for (i = 0; i < data_sz * 1024; i++) { if (data[i] == check_point) s += 1; else if (data[i] > check_point) s += 2; else if (data[i] < check_point) s += 3; }
for (i = 0; i < data_sz * 1024; i++) { if (likely(data[i] < check_point)) s += 3; else if (data[i] > check_point) s += 2; else if (unlikely(data[i] == check_point)) s += 1; }
for (i = 0; i < data_sz * 1024; i++) { if (unlikely(data[i] == check_point)) s += 1; else if (data[i] > check_point) s += 2; else if (likely(data[i] < check_point)) s += 3; }
const int RANGE_MAX = 100; uint8_t data[DATA_MAX * 1024]; static void data_init(int data_sz) { int i; srand(0); for (i = 0; i < data_sz * 1024; i++) data[i] = rand() % RANGE_MAX; }
--------------------------------------------------------------------- Benchmark Time CPU Iterations --------------------------------------------------------------------- ordered_ifs/50/4 4660 ns 4658 ns 150948 ordered_ifs/50/8 25636 ns 25635 ns 27852 ordered_ifs/75/4 4326 ns 4325 ns 162613 ordered_ifs/75/8 18242 ns 18242 ns 37931 ordered_ifs/100/4 1673 ns 1673 ns 417073 ordered_ifs/100/8 3381 ns 3381 ns 207612 reversed_ifs/50/4 5342 ns 5341 ns 126800 reversed_ifs/50/8 26050 ns 26050 ns 26894 reversed_ifs/75/4 3616 ns 3616 ns 193130 reversed_ifs/75/8 15697 ns 15696 ns 44618 reversed_ifs/100/4 3738 ns 3738 ns 188087 reversed_ifs/100/8 7476 ns 7476 ns 93752 ordered_ifs_with_hints/50/4 5551 ns 5551 ns 125160 ordered_ifs_with_hints/50/8 23191 ns 23190 ns 30028 ordered_ifs_with_hints/75/4 3165 ns 3165 ns 218492 ordered_ifs_with_hints/75/8 13785 ns 13785 ns 50574 ordered_ifs_with_hints/100/4 1575 ns 1575 ns 437687 ordered_ifs_with_hints/100/8 3130 ns 3130 ns 221205 reversed_ifs_with_hints/50/4 6573 ns 6572 ns 105629 reversed_ifs_with_hints/50/8 27351 ns 27351 ns 25568 reversed_ifs_with_hints/75/4 3537 ns 3537 ns 197470 reversed_ifs_with_hints/75/8 16130 ns 16130 ns 43279 reversed_ifs_with_hints/100/4 3737 ns 3737 ns 187583 reversed_ifs_with_hints/100/8 7446 ns 7446 ns 93782
--------------------------------------------------------------------- Benchmark Time CPU Iterations --------------------------------------------------------------------- ordered_ifs/100/4 1673 ns 1673 ns 417073 reversed_ifs/100/4 3738 ns 3738 ns 188087
--------------------------------------------------------------------- Benchmark Time CPU Iterations --------------------------------------------------------------------- ordered_ifs/50/4 4660 ns 4658 ns 150948 reversed_ifs/50/4 5342 ns 5341 ns 126800
--------------------------------------------------------------------- Benchmark Time CPU Iterations --------------------------------------------------------------------- ordered_ifs/100/4 1673 ns 1673 ns 417073 ordered_ifs/100/8 3381 ns 3381 ns 207612
--------------------------------------------------------------------- Benchmark Time CPU Iterations --------------------------------------------------------------------- ordered_ifs/50/4 4660 ns 4658 ns 150948 ordered_ifs/50/8 25636 ns 25635 ns 27852
ordered_ifs/100/4 0.01% of branch-misses ordered_ifs/100/8 0.01% of branch-misses ordered_ifs/50/4 3.18% of branch-misses ordered_ifs/50/8 15.22% of branch-misses
--------------------------------------------------------------------- Benchmark Time CPU Iterations --------------------------------------------------------------------- ordered_ifs/50/4 4660 ns 4658 ns 150948 ordered_ifs/100/4 1673 ns 1673 ns 417073 ordered_ifs_with_hints/50/4 5551 ns 5551 ns 125160 ordered_ifs_with_hints/100/4 1575 ns 1575 ns 437687
--------------------------------------------------------------------- Benchmark Time CPU Iterations --------------------------------------------------------------------- ordered_ifs/50/8 25636 ns 25635 ns 27852 ordered_ifs/100/8 3381 ns 3381 ns 207612 ordered_ifs_with_hints/50/8 23191 ns 23190 ns 30028 ordered_ifs_with_hints/100/8 3130 ns 3130 ns 221205
if (likely(access_ok(VERIFY_READ, from, n))) { kasan_check_write(to, n); res = raw_copy_from_user(to, from, n); } if (unlikely(res)) memset(to + (n - res), 0, res);
jump to ELSE if not(most_likely) jump to end ELSE: …
.L233: mov DWORD PTR [rsp+104], 0 mov DWORD PTR [rsp+100], 0 mov DWORD PTR [rsp+96], 0 call std::chrono::_V2::system_clock::now() mov rbp, rax mov rax, QWORD PTR [rsp+8] jmp .L219 .L293: mov edx, DWORD PTR [rsp+104] add edx, 1 mov DWORD PTR [rsp+104], edx .L217: add rax, 4 cmp r14, rax je .L292 .L219: mov edx, DWORD PTR [rax] cmp edx, 94 jg .L293 cmp edx, 19 jg .L218 mov edx, DWORD PTR [rsp+96] add rax, 4 add edx, 1 mov DWORD PTR [rsp+96], edx cmp r14, rax jne .L219 .L292: call std::chrono::_V2::system_clock::now() .L218: mov edx, DWORD PTR [rsp+100] add edx, 1 mov DWORD PTR [rsp+100], edx jmp .L217 And sorted mov DWORD PTR [rsp+104], 0 mov DWORD PTR [rsp+100], 0 mov DWORD PTR [rsp+96], 0 call std::chrono::_V2::system_clock::now() mov rbp, rax mov rax, QWORD PTR [rsp+8] jmp .L226 .L296: mov edx, DWORD PTR [rsp+100] add edx, 1 mov DWORD PTR [rsp+100], edx .L224: add rax, 4 cmp r14, rax je .L295 .L226: mov edx, DWORD PTR [rax] lea ecx, [rdx-20] cmp ecx, 74 jbe .L296 cmp edx, 19 jle .L297 mov edx, DWORD PTR [rsp+104] add rax, 4 add edx, 1 mov DWORD PTR [rsp+104], edx cmp r14, rax jne .L226 .L295: call std::chrono::_V2::system_clock::now() .L297: mov edx, DWORD PTR [rsp+96] add edx, 1 mov DWORD PTR [rsp+96], edx jmp .L224
high, low, mid: 43000000ns mid, low, high: 46000000ns high, mid, low: 45000000ns low, mid, high: 44000000ns mid, high, low: 46000000ns low, high, mid: 44000000ns high, low, mid: 44000000ns mid, low, high: 47000000ns high, mid, low: 44000000ns low, mid, high: 45000000ns mid, high, low: 46000000ns low, high, mid: 45000000ns high, low, mid: 43000000ns mid, low, high: 47000000ns high, mid, low: 44000000ns low, mid, high: 45000000ns mid, high, low: 46000000ns low, high, mid: 44000000ns high, low, mid: 42000000ns mid, low, high: 46000000ns high, mid, low: 46000000ns low, mid, high: 45000000ns mid, high, low: 46000000ns low, high, mid: 43000000ns high, low, mid: 43000000ns mid, low, high: 47000000ns high, mid, low: 44000000ns low, mid, high: 44000000ns mid, high, low: 46000000ns low, high, mid: 44000000ns high, low, mid: 43000000ns mid, low, high: 48000000ns high, mid, low: 44000000ns low, mid, high: 44000000ns mid, high, low: 45000000ns low, high, mid: 45000000ns high, low, mid: 43000000ns mid, low, high: 47000000ns high, mid, low: 45000000ns low, mid, high: 45000000ns mid, high, low: 46000000ns low, high, mid: 44000000ns high, low, mid: 43000000ns mid, low, high: 47000000ns high, mid, low: 45000000ns low, mid, high: 45000000ns mid, high, low: 46000000ns low, high, mid: 44000000ns high, low, mid: 43000000ns mid, low, high: 46000000ns high, mid, low: 45000000ns low, mid, high: 45000000ns mid, high, low: 45000000ns low, high, mid: 44000000ns high, low, mid: 42000000ns mid, low, high: 46000000ns high, mid, low: 44000000ns low, mid, high: 45000000ns mid, high, low: 45000000ns low, high, mid: 44000000ns 1900020, 7498968, 601012 Process returned 0 (0x0) execution time : 2.899 s Press any key to continue.
if (i >= 95) ++nHigh; else if (i < 20) ++nLow; else if (i >= 20 && i < 95) ++nMid;
if (i >= 20 && i < 95) ++nMid; else if (i < 20) ++nLow; else if (i >= 95) ++nHigh;
mispredict*penalty+count+loop 0.06*17+1+1+ (=3.02) (propability)*(first check+mispredict*penalty+count+loop) (0.19)*(1+0.20*17+1+1)+ (= 0.19*6.4=1.22) (propability)*(first check+second check+count+loop) (0.75)*(1+1+1+1) (=3) = 7.24 cycles per iteration
0.25*17+1+1+ (=6.25) (1-0.75)*(1+0.24*17+1+1)+ (=.25*7.08=1.77) (1-0.75-0.19)*(1+1+1+1) (= 0.06*4=0.24) = 8.26
if(NewType* v = dynamic_cast<NewType*>(old)) { v->doSomething(); }
if(old->getType() == BOX) { Box* box = static_cast<Box*>(old); }
if(old->getType() == BOX || old->getType() == SPECIAL_BOX) { Box* box = static_cast<Box*>(old); }
template<typename Base, typename T> inline bool instanceof(const T*) { return std::is_base_of<Base, T>::value; }
template<typename Base, typename T> inline bool instanceof(const T *ptr) { return dynamic_cast<const Base*>(ptr) != nullptr; }
if (dynamic_cast<B*>(aPtr) != nullptr) { } else { }
using BaseTypes = decltype(std::tuple_cat(std::tuple<BaseClass>(), Class::BaseTypes())); static const std::set<std::type_index> baseTypeContainer; \ virtual bool instanceOfHelper(const std::type_index &_tidx) { \ if (std::type_index(typeid(ThisType)) == _tidx) return true; \ if (std::tuple_size<BaseTypes>::value == 0) return false; \ return baseTypeContainer.find(_tidx) != baseTypeContainer.end(); \ } \ template <typename... T> \ static std::set<std::type_index> getTypeIndexes(std::tuple<T...>) { \ return std::set<std::type_index>{std::type_index(typeid(T))...}; \ } protected: \ using ThisType = Class; \ _BASE_TYPE_DECL(Class, BaseClass) \ _INSTANCE_OF_DECL_BODY(Class) protected: \ using ThisType = Class; \ _EMPTY_BASE_TYPE_DECL() \ _INSTANCE_OF_DECL_BODY(Class) \ public: \ template <typename Of> \ typename std::enable_if<std::is_base_of<Class, Of>::value, bool>::type instanceOf() { \ return instanceOfHelper(std::type_index(typeid(Of))); \ } const std::set<std::type_index> Class::baseTypeContainer = Class::getTypeIndexes(Class::BaseTypes());
struct A { virtual ~A() {} INSTANCE_OF_BASE_DECL(A) }; INSTANCE_OF_IMPL(A) struct B : public A { virtual ~B() {} INSTANCE_OF_SUB_DECL(B, A) }; INSTANCE_OF_IMPL(B) struct C : public A { virtual ~C() {} INSTANCE_OF_SUB_DECL(C, A) }; INSTANCE_OF_IMPL(C) struct D : public C { virtual ~D() {} INSTANCE_OF_SUB_DECL(D, C) }; INSTANCE_OF_IMPL(D)
int main() { A *a2aPtr = new A; A *a2bPtr = new B; std::shared_ptr<A> a2cPtr(new C); C *c2dPtr = new D; std::unique_ptr<A> a2dPtr(new D); std::cout << "a2aPtr->instanceOf<A>(): expected=1, value=" << a2aPtr->instanceOf<A>() << std::endl; std::cout << "a2aPtr->instanceOf<B>(): expected=0, value=" << a2aPtr->instanceOf<B>() << std::endl; std::cout << "a2aPtr->instanceOf<C>(): expected=0, value=" << a2aPtr->instanceOf<C>() << std::endl; std::cout << "a2aPtr->instanceOf<D>(): expected=0, value=" << a2aPtr->instanceOf<D>() << std::endl; std::cout << std::endl; std::cout << "a2bPtr->instanceOf<A>(): expected=1, value=" << a2bPtr->instanceOf<A>() << std::endl; std::cout << "a2bPtr->instanceOf<B>(): expected=1, value=" << a2bPtr->instanceOf<B>() << std::endl; std::cout << "a2bPtr->instanceOf<C>(): expected=0, value=" << a2bPtr->instanceOf<C>() << std::endl; std::cout << "a2bPtr->instanceOf<D>(): expected=0, value=" << a2bPtr->instanceOf<D>() << std::endl; std::cout << std::endl; std::cout << "a2cPtr->instanceOf<A>(): expected=1, value=" << a2cPtr->instanceOf<A>() << std::endl; std::cout << "a2cPtr->instanceOf<B>(): expected=0, value=" << a2cPtr->instanceOf<B>() << std::endl; std::cout << "a2cPtr->instanceOf<C>(): expected=1, value=" << a2cPtr->instanceOf<C>() << std::endl; std::cout << "a2cPtr->instanceOf<D>(): expected=0, value=" << a2cPtr->instanceOf<D>() << std::endl; std::cout << std::endl; std::cout << "c2dPtr->instanceOf<A>(): expected=1, value=" << c2dPtr->instanceOf<A>() << std::endl; std::cout << "c2dPtr->instanceOf<B>(): expected=0, value=" << c2dPtr->instanceOf<B>() << std::endl; std::cout << "c2dPtr->instanceOf<C>(): expected=1, value=" << c2dPtr->instanceOf<C>() << std::endl; std::cout << "c2dPtr->instanceOf<D>(): expected=1, value=" << c2dPtr->instanceOf<D>() << std::endl; std::cout << std::endl; std::cout << "a2dPtr->instanceOf<A>(): expected=1, value=" << a2dPtr->instanceOf<A>() << std::endl; std::cout << "a2dPtr->instanceOf<B>(): expected=0, value=" << a2dPtr->instanceOf<B>() << std::endl; std::cout << "a2dPtr->instanceOf<C>(): expected=1, value=" << a2dPtr->instanceOf<C>() << std::endl; std::cout << "a2dPtr->instanceOf<D>(): expected=1, value=" << a2dPtr->instanceOf<D>() << std::endl; delete a2aPtr; delete a2bPtr; delete c2dPtr; return 0; }
a2aPtr->instanceOf<A>(): expected=1, value=1 a2aPtr->instanceOf<B>(): expected=0, value=0 a2aPtr->instanceOf<C>(): expected=0, value=0 a2aPtr->instanceOf<D>(): expected=0, value=0 a2bPtr->instanceOf<A>(): expected=1, value=1 a2bPtr->instanceOf<B>(): expected=1, value=1 a2bPtr->instanceOf<C>(): expected=0, value=0 a2bPtr->instanceOf<D>(): expected=0, value=0 a2cPtr->instanceOf<A>(): expected=1, value=1 a2cPtr->instanceOf<B>(): expected=0, value=0 a2cPtr->instanceOf<C>(): expected=1, value=1 a2cPtr->instanceOf<D>(): expected=0, value=0 c2dPtr->instanceOf<A>(): expected=1, value=1 c2dPtr->instanceOf<B>(): expected=0, value=0 c2dPtr->instanceOf<C>(): expected=1, value=1 c2dPtr->instanceOf<D>(): expected=1, value=1 a2dPtr->instanceOf<A>(): expected=1, value=1 a2dPtr->instanceOf<B>(): expected=0, value=0 a2dPtr->instanceOf<C>(): expected=1, value=1 a2dPtr->instanceOf<D>(): expected=1, value=1
template <typename Base, typename Derived, typename Duration> Duration instanceOfMeasurement(unsigned _loopCycles) { auto start = std::chrono::high_resolution_clock::now(); volatile bool isInstanceOf = false; for (unsigned i = 0; i < _loopCycles; ++i) { Base *ptr = new Derived; isInstanceOf = ptr->template instanceOf<Derived>(); delete ptr; } auto end = std::chrono::high_resolution_clock::now(); return std::chrono::duration_cast<Duration>(end - start); } template <typename Base, typename Derived, typename Duration> Duration dynamicCastMeasurement(unsigned _loopCycles) { auto start = std::chrono::high_resolution_clock::now(); volatile bool isInstanceOf = false; for (unsigned i = 0; i < _loopCycles; ++i) { Base *ptr = new Derived; isInstanceOf = dynamic_cast<Derived *>(ptr) != nullptr; delete ptr; } auto end = std::chrono::high_resolution_clock::now(); return std::chrono::duration_cast<Duration>(end - start); } int main() { unsigned testCycles = 10000000; std::string unit = " us"; using DType = std::chrono::microseconds; std::cout << "InstanceOf performance(A->D) : " << instanceOfMeasurement<A, D, DType>(testCycles).count() << unit << std::endl; std::cout << "InstanceOf performance(A->C) : " << instanceOfMeasurement<A, C, DType>(testCycles).count() << unit << std::endl; std::cout << "InstanceOf performance(A->B) : " << instanceOfMeasurement<A, B, DType>(testCycles).count() << unit << std::endl; std::cout << "InstanceOf performance(A->A) : " << instanceOfMeasurement<A, A, DType>(testCycles).count() << unit << "\n" << std::endl; std::cout << "DynamicCast performance(A->D) : " << dynamicCastMeasurement<A, D, DType>(testCycles).count() << unit << std::endl; std::cout << "DynamicCast performance(A->C) : " << dynamicCastMeasurement<A, C, DType>(testCycles).count() << unit << std::endl; std::cout << "DynamicCast performance(A->B) : " << dynamicCastMeasurement<A, B, DType>(testCycles).count() << unit << std::endl; std::cout << "DynamicCast performance(A->A) : " << dynamicCastMeasurement<A, A, DType>(testCycles).count() << unit << "\n" << std::endl; return 0; }
InstanceOf performance(A->D) : 699638 us InstanceOf performance(A->C) : 642157 us InstanceOf performance(A->B) : 671399 us InstanceOf performance(A->A) : 626193 us DynamicCast performance(A->D) : 754937 us DynamicCast performance(A->C) : 706766 us DynamicCast performance(A->B) : 751353 us DynamicCast performance(A->A) : 676853 us
InstanceOf performance(A->D) : 3035 us InstanceOf performance(A->C) : 5030 us InstanceOf performance(A->B) : 5250 us InstanceOf performance(A->A) : 3021 us DynamicCast performance(A->D) : 666903 us DynamicCast performance(A->C) : 698567 us DynamicCast performance(A->B) : 727368 us DynamicCast performance(A->A) : 3098 us
InstanceOf performance(A->D) : 390768 us InstanceOf performance(A->C) : 333994 us InstanceOf performance(A->B) : 334596 us InstanceOf performance(A->A) : 300959 us DynamicCast performance(A->D) : 331942 us DynamicCast performance(A->C) : 303715 us DynamicCast performance(A->B) : 400262 us DynamicCast performance(A->A) : 324942 us
InstanceOf performance(A->D) : 209501 us InstanceOf performance(A->C) : 208727 us InstanceOf performance(A->B) : 207815 us InstanceOf performance(A->A) : 197953 us DynamicCast performance(A->D) : 259417 us DynamicCast performance(A->C) : 256203 us DynamicCast performance(A->B) : 261202 us DynamicCast performance(A->A) : 193535 us
template<typename T, typename K> inline bool isType(const K &k) { return typeid(T).hash_code() == typeid(k).hash_code(); }
DerivedA k; Base *p = &k; cout << boolalpha << isType<DerivedA>(*p) << endl; cout << boolalpha << isType<DerivedB>(*p) << endl;
template<class T> void fun(T a) { if(typeid(T) == typeid(int)) { cout<<"int"; } else if(typeid(T) == typeid(float)) { cout<<"float"; } } void main() { fun(23); fun(90.67f); }
using namespace std; class Publication { protected: char title[SIZE]; int price; public: Publication() { cout<<endl<<" Enter title of media : "; cin>>title; cout<<endl<<" Enter price of media : "; cin>>price; } virtual void show()=0; }; class Book : public Publication { int pages; public: Book() { cout<<endl<<" Enter number of pages : "; cin>>pages; } void show() { cout<<endl<<setw(12)<<left<<" Book Title"<<": "<<title; cout<<endl<<setw(12)<<left<<" Price"<<": "<<price; cout<<endl<<setw(12)<<left<<" Pages"<<": "<<pages; cout<<endl<<" ----------------------------------------"; } }; class Tape : public Publication { int duration; public: Tape() { cout<<endl<<" Enter duration in minute : "; cin>>duration; } void show() { cout<<endl<<setw(10)<<left<<" Tape Title"<<": "<<title; cout<<endl<<setw(10)<<left<<" Price"<<": "<<price; cout<<endl<<setw(10)<<left<<" Duration"<<": "<<duration<<" minutes"; cout<<endl<<" ----------------------------------------"; } }; int main() { int n, i, type; cout<<endl<<" Enter number of media : "; cin>>n; Publication **p = new Publication*[n]; cout<<endl<<" Enter "<<n<<" media details : "; for(i=0;i<n;i++) { cout<<endl<<" Select Media Type [ 1 - Book / 2 - Tape ] "; cin>>type; if ( type == 1 ) { p[i] = new Book(); } else if ( type == 2 ) { p[i] = new Tape(); } else { i--; cout<<endl<<" Invalid type. You have to Re-enter choice"; } } for(i=0;i<n;i++) { if ( typeid(Book) == typeid(*p[i]) ) { p[i]->show(); } } return 0; }
using namespace std; class contact { public: string name; int phonenumber; string address; contact() { name= "Noname"; phonenumber= 0; address= "Noaddress"; } }; int main() { contact *d; d = new contact[200]; string name,add; int choice,modchoice,t; int phno,phno1; int i=0; int initsize=0, i1=0; bool flag=false,flag_no_blank=false; fstream f1; fstream f2; fstream f3; string file_input_name; string file_input_address; int file_input_number; f1.open("./names"); while(f1>>file_input_name){ d[i].name=file_input_name; i++; } initsize=i; f2.open("./numbers"); while(f2>>file_input_number){ d[i1].phonenumber=file_input_number; i1++; } i1=0; f3.open("./address"); while(f3>>file_input_address){ d[i1].address=file_input_address; i1++; } cout<<"\tWelcome to the phone Directory\n"; do{ cout<<"Select :\n1.Add New Contact\n2.Update Existing Contact\n3.Display All Contacts\n4.Search for a Contact\n5.Delete a Contact\n6.Exit PhoneBook\n\n\n"; cin>>choice; switch(choice){ case 1: i++; i1++; do{ cout<<"\nEnter The Name\n"; cin>>name; if(name==" "){cout<<"Blank Entries are not allowed"; flag_no_blank=true; } }while(flag_no_blank==true); flag_no_blank=false; d[i].name=name; cout<<"\nEnter the Phone Number\n"; cin>>phno; d[i1].phonenumber=phno; cout<<"\nEnter the address\n"; cin>>add; d[i1].address=add; i1++; i++; break; case 2: cout<<"\nEnter the name\n"; cin>>name; int k=0,val; cout<<"\n\nSearching.........\n\n"; for(int j=0;j<=i;j++){ if(d[j].name==name){ k++; cout<<k<<".\t"<<d[j].name<<"\t"<<d[j].phonenumber<<"\t"<<d[j].address<<"\n\n"; val=j; } } char ch; cout<<"\nTotal of "<<k<<" Entries were found....Do you wish to edit?\n"; string staticname; staticname=d[val].name; cin>>ch; if(ch== cout<<"Which entry do you wish to modify ?(enter the old telephone number)\n"; cin>>phno; for(int j=0;j<=i;j++){ if(d[j].phonenumber==phno && staticname==d[j].name){ cout<<"Do you wish to change the name?\n"; cin>>ch; if(ch== cout<<"Enter new name\n"; cin>>name; d[j].name=name; } cout<<"Do you wish to change the number?\n"; cin>>ch; if(ch== cout<<"Enter the new number\n"; cin>>phno1; d[j].phonenumber=phno1; } cout<<"Do you wish to change the address?\n"; cin>>ch; if(ch== cout<<"Enter the new address\n"; cin>>add; d[j].address=add; } } } } break; case 3 : { cout<<"\n\tContents of PhoneBook:\n\n\tNames\tPhone-Numbers\tAddresses"; for(int t=0;t<=i;t++){ cout<<t+1<<".\t"<<d[t].name<<"\t"<<d[t].phonenumber<<"\t"<<d[t].address; } break; } } } while(flag==false); return 0; }
switch(foo) { case 1: int i = 42; dostuff(i); break; case 2: dostuff(i*2); }
switch(foo) { case 1: { int i = 42; dostuff(i); break; } case 2: dostuff(123); }
int main() { if(rand() % 2) goto end; int i = 42; end: std::cout << i; }
switch(choice) { case 1: { }break; case 2: { }break; case 3: { }break; }
switch(choice) { case 1: int i = 10; printf("i = %d\n", i); break; case 2: int j = 20; printf("j = %d\n", j); break; }
int main() { int choice; printf("Please enter 1 or 2: "); scanf("%d", &choice); switch(choice) { case 1: ; int i = 10; printf("i = %d\n", i); break; case 2: ; int j = 20; printf("j = %d\n", j); break; } }
my_class(my_class const &) = delete; my_class& operator=(const my_class&) = default;
class AbstractBase { virtual void PureVirtualFunction() = 0; }
class Derived : public AbstractBase { virtual void PureVirtualFunction() override { } }
struct Parent { Snapshot s; }; Parent p; Parent p = {};
struct Snapshot { int x; double y; Snapshot():x(0),y(0) { } };
int x; int y = 42; struct { int a, b; } foo; void foo() { struct { int a, b; } bar; static struct { int c, d; } quux; }
struct init { template <typename T> operator T * () { return new T(); } }; Snapshot* s = init();
Snapshot *sp = new Snapshot; memset(sp, 0, sizeof (*sp));
struct foo_pod { int x; int y; int z; }; struct foo : foo_pod { std::string name; foo(std::string name) : foo_pod() , name(name) { } }; int main() { foo f("bar"); printf("%d %d %d %s\n", f.x, f.y, f.z, f.name.c_str()); }
+---------+ | stack | function-local variables, return addresses, return values, etc. | | often grows downward, commonly accessed via "push" and "pop" (but can be | | accessed randomly, as well; disassemble a program to see) +---------+ | shared | mapped shared libraries (C libraries, math libs, etc.) | libs | +---------+ | hole | unused memory allocated between the heap and stack "chunks", spans the | | difference between your max and min memory, minus the other totals +---------+ | heap | dynamic, random-access storage, allocated with +---------+ | bss | Uninitialized global variables; must be in read-write memory area +---------+ | data | data segment, for globals and static variables that are initialized | | (can further be split up into read-only and read-write areas, with | | read-only areas being stored elsewhere in ROM on some systems) +---------+ | text | program code, this is the actual executable code that is running. +---------+
+-----------+ top of memory | extended | above the high memory area, and up to your total memory; needed drivers to | | be able to access it. +-----------+ 0x110000 | high | just over 1MB->1MB+64KB, used by 286s and above. +-----------+ 0x100000 | upper | upper memory area, from 640kb->1MB, had mapped memory for video devices, the | | DOS "transient" area, etc. some was often free, and could be used for drivers +-----------+ 0xA0000 | USER PROC | user process address space, from the end of DOS up to 640KB +-----------+ |command.com| DOS command interpreter +-----------+ | DOS | DOS permanent area, kept as small as possible, provided routines for display, | kernel | *basic* hardware access, etc. +-----------+ 0x600 | BIOS data | BIOS data area, contained simple hardware descriptions, etc. +-----------+ 0x400 | interrupt | the interrupt vector table, starting from 0 and going to 1k, contained | vector | the addresses of routines called when interrupts occurred. e.g. | table | interrupt 0x21 checked the address at 0x21*4 and far-jumped to that | | location to service the interrupt. +-----------+ 0x0
int mul( int x, int y ) { return x * y; } int main() { int x = 2, y = 3; mul( x, y ); }
int main() { int stackValue = 0; int *addressOnStack = &stackValue; int *addressOnHeap = malloc(sizeof(int)); if (addressOnStack > addressOnHeap) { puts("The stack is above the heap."); } else { puts("The heap is above the stack."); } }
using namespace std; int main() { string s; cout << "Please enter your first name followed by a newline\n"; cin >> s; cout << "Hello, " << s << system("pause"); return 0; }
std::cout << "Paused, press ENTER to continue." << std::endl; cin.ignore(100000, "\n");
_tprintf(_T("Press a key to continue ")); while( _kbhit() ) _gettch(); _gettch();
std::cin.clear(); std::cin.ignore(INT_MAX, std::cin.get(); return 0;
using namespace std; int main() { std::cout << "hello programmer!\n\nEnter 2 numbers: "; int x, y; std::cin >> x >> y; int w = x*y; std::cout <<"\nyour answer is: "<< w << endl; system("pause"); }
using namespace std; int main() { cout << "Press any key to continue..."; getch(); return 0; }
@echo off :1 cls call helloworld.exe pause >nul goto :1
cout<<"\nPress any key and hit enter to end..."; cin>>x;
unsigned short _byteswap_ushort(unsigned short value);
unsigned long _byteswap_ulong(unsigned long value);
unsigned __int64 _byteswap_uint64(unsigned __int64 value);
int32_t __builtin_bswap32 (int32_t x) int64_t __builtin_bswap64 (int64_t x)
template <typename T> T swap_endian(T u) { static_assert (CHAR_BIT == 8, "CHAR_BIT != 8"); union { T u; unsigned char u8[sizeof(T)]; } source, dest; source.u = u; for (size_t k = 0; k < sizeof(T); k++) dest.u8[k] = source.u8[sizeof(T) - k - 1]; return dest.u; }
i = (data[0]<<0) | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
i = (data[3]<<0) | (data[2]<<8) | (data[1]<<16) | (data[0]<<24);
enum endianness { little_endian, big_endian, network_endian = big_endian, host_endian = little_endian host_endian = big_endian }; namespace detail { template<typename T, size_t sz> struct swap_bytes { inline T operator()(T val) { throw std::out_of_range("data size"); } }; template<typename T> struct swap_bytes<T, 1> { inline T operator()(T val) { return val; } }; template<typename T> struct swap_bytes<T, 2> { inline T operator()(T val) { return ((((val) >> 8) & 0xff) | (((val) & 0xff) << 8)); } }; template<typename T> struct swap_bytes<T, 4> { inline T operator()(T val) { return ((((val) & 0xff000000) >> 24) | (((val) & 0x00ff0000) >> 8) | (((val) & 0x0000ff00) << 8) | (((val) & 0x000000ff) << 24)); } }; template<> struct swap_bytes<float, 4> { inline float operator()(float val) { uint32_t mem =swap_bytes<uint32_t, sizeof(uint32_t)>()(*(uint32_t*)&val); return *(float*)&mem; } }; template<typename T> struct swap_bytes<T, 8> { inline T operator()(T val) { return ((((val) & 0xff00000000000000ull) >> 56) | (((val) & 0x00ff000000000000ull) >> 40) | (((val) & 0x0000ff0000000000ull) >> 24) | (((val) & 0x000000ff00000000ull) >> 8 ) | (((val) & 0x00000000ff000000ull) << 8 ) | (((val) & 0x0000000000ff0000ull) << 24) | (((val) & 0x000000000000ff00ull) << 40) | (((val) & 0x00000000000000ffull) << 56)); } }; template<> struct swap_bytes<double, 8> { inline double operator()(double val) { uint64_t mem =swap_bytes<uint64_t, sizeof(uint64_t)>()(*(uint64_t*)&val); return *(double*)&mem; } }; template<endianness from, endianness to, class T> struct do_byte_swap { inline T operator()(T value) { return swap_bytes<T, sizeof(T)>()(value); } }; template<class T> struct do_byte_swap<little_endian, little_endian, T> { inline T operator()(T value) { return value; } }; template<class T> struct do_byte_swap<big_endian, big_endian, T> { inline T operator()(T value) { return value; } }; } template<endianness from, endianness to, class T> inline T byte_swap(T value) { BOOST_STATIC_ASSERT(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8); BOOST_STATIC_ASSERT(boost::is_arithmetic<T>::value); return detail::do_byte_swap<from, to, T>()(value); }
void swapByteOrder(unsigned short& us) { us = (us >> 8) | (us << 8); } void swapByteOrder(unsigned int& ui) { ui = (ui >> 24) | ((ui<<8) & 0x00FF0000) | ((ui>>8) & 0x0000FF00) | (ui << 24); } void swapByteOrder(unsigned long long& ull) { ull = (ull >> 56) | ((ull<<40) & 0x00FF000000000000) | ((ull<<24) & 0x0000FF0000000000) | ((ull<<8) & 0x000000FF00000000) | ((ull>>8) & 0x00000000FF000000) | ((ull>>24) & 0x0000000000FF0000) | ((ull>>40) & 0x000000000000FF00) | (ull << 56); }
template<> inline void endian_byte_swapper< 2 >(char* dest, char const* src) { ushort* p_dest = reinterpret_cast< ushort* >(dest); ushort const* const p_src = reinterpret_cast< ushort const* >(src); *p_dest = (*p_src >> 8) | (*p_src << 8); } template<> inline void endian_byte_swapper< 4 >(char* dest, char const* src) { uint* p_dest = reinterpret_cast< uint* >(dest); uint const* const p_src = reinterpret_cast< uint const* >(src); *p_dest = (*p_src >> 24) | ((*p_src & 0x00ff0000) >> 8) | ((*p_src & 0x0000ff00) << 8) | (*p_src << 24); }
short big = 0xdead; short little = (((big & 0xff)<<8) | ((big & 0xff00)>>8));
unsigned int change_endian(unsinged int x) { unsigned char *ptr = (unsigned char *)&x; return (ptr[0] << 24) | (ptr[1] << 16) | (ptr[2] << 8) | ptr[3]; }
template<size_t N> struct SizeT {}; template<class T> inline T htobe(T t, SizeT<bits / 8>) { return htobe template<class T> inline T htole(T t, SizeT<bits / 8>) { return htole template<class T> inline T betoh(T t, SizeT<bits / 8>) { return be template<class T> inline T letoh(T t, SizeT<bits / 8>) { return le BYTESWAPS(16) BYTESWAPS(32) BYTESWAPS(64) template<class T> inline T htobe(T t) { return htobe(t, SizeT<sizeof t>()); } template<class T> inline T htole(T t) { return htole(t, SizeT<sizeof t>()); } template<class T> inline T betoh(T t) { return betoh(t, SizeT<sizeof t>()); } template<class T> inline T letoh(T t) { return letoh(t, SizeT<sizeof t>()); } int main() { std::cout << std::hex; std::cout << htobe(static_cast<unsigned short>(0xfeca)) << std::cout << htobe(0xafbeadde) << std::cout << htobe(0xfecaefbeafdeedfeULL) << }
long swap(long i) { char *c = (char *) &i; return * (long *) (char[]) {c[3], c[2], c[1], c[0] }; }
template <typename T> void SwapEnd(T& var) { char* varArray = reinterpret_cast<char*>(&var); for(long i = 0; i < static_cast<long>(sizeof(var)/2); i++) std::swap(varArray[sizeof(var) - 1 - i],varArray[i]); }
enum EEndian { LITTLE_ENDIAN_ORDER, BIG_ENDIAN_ORDER, HOST_ENDIAN_ORDER = LITTLE_ENDIAN_ORDER HOST_ENDIAN_ORDER = BIG_ENDIAN_ORDER }; template <class T, unsigned int size> inline T SwapBytes(T value) { union { T value; char bytes[size]; } in, out; in.value = value; for (unsigned int i = 0; i < size / 2; ++i) { out.bytes[i] = in.bytes[size - 1 - i]; out.bytes[size - 1 - i] = in.bytes[i]; } return out.value; } // // template<EEndian from, EEndian to, class T> inline T EndianSwapBytes(T value) { BOOST_STATIC_ASSERT(sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8); BOOST_STATIC_ASSERT(boost::is_arithmetic<T>::value); if (from == to) return value; return SwapBytes<T, sizeof(T)>(value); }
template<typename T> void ByteSwap(T * p) { for (int i = 0; i < sizeof(T)/2; ++i) std::swap(((char *)p)[i], ((char *)p)[sizeof(T)-1-i]); }
x = ((x & 0x00000000ffffffff) << 32) ^ ((x >> 32) & 0x00000000ffffffff); x = ((x & 0x0000ffff0000ffff) << 16) ^ ((x >> 16) & 0x0000ffff0000ffff); x = ((x & 0x00ff00ff00ff00ff) << 8) ^ ((x >> 8) & 0x00ff00ff00ff00ff);
uint64_t k = 0x00000000ffffffff; x = ((x & k) << 32) ^ ((x >> 32) & k); k ^= k << 16; x = ((x & k) << 16) ^ ((x >> 16) & k); k ^= k << 8; x = ((x & k) << 8) ^ ((x >> 8) & k);
int i = sizeof(x) * CHAR_BIT / 2; uintmax_t k = (1 << i) - 1; while (i >= 8) { x = ((x & k) << i) ^ ((x >> i) & k); i >>= 1; k ^= k << i; }
x = ( x << 16) ^ (x >> 16); x = ((x & 0x00ff00ff) << 8) ^ ((x >> 8) & 0x00ff00ff);
template<typename T> inline static T swapByteOrder(const T& val) { int totalBytes = sizeof(val); T swapped = (T) 0; for (int i = 0; i < totalBytes; ++i) { swapped |= (val >> (8*(totalBytes-i-1)) & 0xFF) << (8*i); } return swapped; }
(((uint16_t)(x) & 0xff00)>>8)) (((uint32_t)(x) & 0x0000ff00)<<8)| \ (((uint32_t)(x) & 0x00ff0000)>>8)| \ (((uint32_t)(x) & 0xff000000)>>24))
__declspec(naked) uint32_t EndianSwap(uint32 value) { __asm { mov eax, dword ptr[esp + 4] bswap eax ret } }
unsigned long _byteswap_ulong(unsigned long value);
mov ebx, eax shr ebx, 16 xchg bl, bh xchg al, ah shl eax, 16 or eax, ebx
uint32_t sw_get_uint32_1234(pu32) uint32_1234 *pu32; { union { uint32_1234 u32_1234; uint32_t u32; } bou32; bou32.u32_1234[0] = (*pu32)[BO32_0]; bou32.u32_1234[1] = (*pu32)[BO32_1]; bou32.u32_1234[2] = (*pu32)[BO32_2]; bou32.u32_1234[3] = (*pu32)[BO32_3]; return(bou32.u32); } void sw_set_uint32_1234(pu32, u32) uint32_1234 *pu32; uint32_t u32; { union { uint32_1234 u32_1234; uint32_t u32; } bou32; bou32.u32 = u32; (*pu32)[BO32_0] = bou32.u32_1234[0]; (*pu32)[BO32_1] = bou32.u32_1234[1]; (*pu32)[BO32_2] = bou32.u32_1234[2]; (*pu32)[BO32_3] = bou32.u32_1234[3]; } int64 sw_get_int64_12345678(pi64) int64_12345678 *pi64; { union { int64_12345678 i64_12345678; int64 i64; } boi64; boi64.i64_12345678[0] = (*pi64)[BO64_0]; boi64.i64_12345678[1] = (*pi64)[BO64_1]; boi64.i64_12345678[2] = (*pi64)[BO64_2]; boi64.i64_12345678[3] = (*pi64)[BO64_3]; boi64.i64_12345678[4] = (*pi64)[BO64_4]; boi64.i64_12345678[5] = (*pi64)[BO64_5]; boi64.i64_12345678[6] = (*pi64)[BO64_6]; boi64.i64_12345678[7] = (*pi64)[BO64_7]; return(boi64.i64); } int32_t sw_get_int32_3412(pi32) int32_3412 *pi32; { union { int32_3412 i32_3412; int32_t i32; } boi32; boi32.i32_3412[2] = (*pi32)[BO32_0]; boi32.i32_3412[3] = (*pi32)[BO32_1]; boi32.i32_3412[0] = (*pi32)[BO32_2]; boi32.i32_3412[1] = (*pi32)[BO32_3]; return(boi32.i32); } void sw_set_int32_3412(pi32, i32) int32_3412 *pi32; int32_t i32; { union { int32_3412 i32_3412; int32_t i32; } boi32; boi32.i32 = i32; (*pi32)[BO32_0] = boi32.i32_3412[2]; (*pi32)[BO32_1] = boi32.i32_3412[3]; (*pi32)[BO32_2] = boi32.i32_3412[0]; (*pi32)[BO32_3] = boi32.i32_3412[1]; } uint32_t sw_get_uint32_3412(pu32) uint32_3412 *pu32; { union { uint32_3412 u32_3412; uint32_t u32; } bou32; bou32.u32_3412[2] = (*pu32)[BO32_0]; bou32.u32_3412[3] = (*pu32)[BO32_1]; bou32.u32_3412[0] = (*pu32)[BO32_2]; bou32.u32_3412[1] = (*pu32)[BO32_3]; return(bou32.u32); } void sw_set_uint32_3412(pu32, u32) uint32_3412 *pu32; uint32_t u32; { union { uint32_3412 u32_3412; uint32_t u32; } bou32; bou32.u32 = u32; (*pu32)[BO32_0] = bou32.u32_3412[2]; (*pu32)[BO32_1] = bou32.u32_3412[3]; (*pu32)[BO32_2] = bou32.u32_3412[0]; (*pu32)[BO32_3] = bou32.u32_3412[1]; } float sw_get_float_1234(pf) float_1234 *pf; { union { float_1234 f_1234; float f; } bof; bof.f_1234[0] = (*pf)[BO32_0]; bof.f_1234[1] = (*pf)[BO32_1]; bof.f_1234[2] = (*pf)[BO32_2]; bof.f_1234[3] = (*pf)[BO32_3]; return(bof.f); } void sw_set_float_1234(pf, f) float_1234 *pf; float f; { union { float_1234 f_1234; float f; } bof; bof.f = (float)f; (*pf)[BO32_0] = bof.f_1234[0]; (*pf)[BO32_1] = bof.f_1234[1]; (*pf)[BO32_2] = bof.f_1234[2]; (*pf)[BO32_3] = bof.f_1234[3]; } double sw_get_double_12345678(pd) double_12345678 *pd; { union { double_12345678 d_12345678; double d; } bod; bod.d_12345678[0] = (*pd)[BO64_0]; bod.d_12345678[1] = (*pd)[BO64_1]; bod.d_12345678[2] = (*pd)[BO64_2]; bod.d_12345678[3] = (*pd)[BO64_3]; bod.d_12345678[4] = (*pd)[BO64_4]; bod.d_12345678[5] = (*pd)[BO64_5]; bod.d_12345678[6] = (*pd)[BO64_6]; bod.d_12345678[7] = (*pd)[BO64_7]; return(bod.d); } void sw_set_double_12345678(pd, d) double_12345678 *pd; double d; { union { double_12345678 d_12345678; double d; } bod; bod.d = d; (*pd)[BO64_0] = bod.d_12345678[0]; (*pd)[BO64_1] = bod.d_12345678[1]; (*pd)[BO64_2] = bod.d_12345678[2]; (*pd)[BO64_3] = bod.d_12345678[3]; (*pd)[BO64_4] = bod.d_12345678[4]; (*pd)[BO64_5] = bod.d_12345678[5]; (*pd)[BO64_6] = bod.d_12345678[6]; (*pd)[BO64_7] = bod.d_12345678[7]; }
typedef char int8_1[1], uint8_1[1]; typedef char int16_12[2], uint16_12[2]; typedef char int16_21[2], uint16_21[2]; typedef char int24_321[3], uint24_321[3]; typedef char int32_1234[4], uint32_1234[4]; typedef char int32_3412[4], uint32_3412[4]; typedef char int32_4321[4], uint32_4321[4]; typedef char int64_12345678[8], uint64_12345678[8]; typedef char int64_34128756[8], uint64_34128756[8]; typedef char int64_87654321[8], uint64_87654321[8]; typedef char float_1234[4]; typedef char float_3412[4]; typedef char float_4321[4]; typedef char double_12345678[8]; typedef char double_78563412[8]; typedef char double_87654321[8];
((unsigned char*)&(__VA_ARGS__))[REVERSE_BYTES] ^= ((unsigned char*)&(__VA_ARGS__))[sizeof(__VA_ARGS__)-1-REVERSE_BYTES],\ ((unsigned char*)&(__VA_ARGS__))[sizeof(__VA_ARGS__)-1-REVERSE_BYTES] ^= ((unsigned char*)&(__VA_ARGS__))[REVERSE_BYTES],\ ((unsigned char*)&(__VA_ARGS__))[REVERSE_BYTES] ^= ((unsigned char*)&(__VA_ARGS__))[sizeof(__VA_ARGS__)-1-REVERSE_BYTES];\ while(0)
int main(){ unsigned long long x = 0xABCDEF0123456789; printf("Before: %llX\n",x); REVERSE_BYTES(x); printf("After : %llX\n",x); char c[7]="nametag"; printf("Before: %c%c%c%c%c%c%c\n",c[0],c[1],c[2],c[3],c[4],c[5],c[6]); REVERSE_BYTES(c); printf("After : %c%c%c%c%c%c%c\n",c[0],c[1],c[2],c[3],c[4],c[5],c[6]); }
Before: ABCDEF0123456789 After : 8967452301EFCDAB Before: nametag After : gateman
((unsigned char*)&(__VA_ARGS__))[REVERSE_BYTES] ((unsigned char*)&(__VA_ARGS__))[sizeof(__VA_ARGS__)-1-REVERSE_BYTES]
/* * read a double from a stream in ieee754 format regardless of host * encoding. * fp - the stream * bigendian - set to if big bytes first, clear for little bytes * first * */ double freadieee754(FILE *fp, int bigendian) { unsigned char buff[8]; int i; double fnorm = 0.0; unsigned char temp; int sign; int exponent; double bitval; int maski, mask; int expbits = 11; int significandbits = 52; int shift; double answer; for (i = 0; i < 8; i++) buff[i] = fgetc(fp); if (!bigendian) { for (i = 0; i < 4; i++) { temp = buff[i]; buff[i] = buff[8 - i - 1]; buff[8 - i - 1] = temp; } } sign = buff[0] & 0x80 ? -1 : 1; exponent = ((buff[0] & 0x7F) << 4) | ((buff[1] & 0xF0) >> 4); bitval = 0.5; maski = 1; mask = 0x08; for (i = 0; i < significandbits; i++) { if (buff[maski] & mask) fnorm += bitval; bitval /= 2.0; mask >>= 1; if (mask == 0) { mask = 0x80; maski++; } } if (exponent == 0 && fnorm == 0) return 0.0; shift = exponent - ((1 << (expbits - 1)) - 1); if (shift == 1024 && fnorm != 0) return sqrt(-1.0); if (shift == 1024 && fnorm == 0) { return sign == 1 ? INFINITY : -INFINITY; return (sign * 1.0) / 0.0; } if (shift > -1023) { answer = ldexp(fnorm + 1.0, shift); return answer * sign; } else { if (fnorm == 0.0) return 0.0; shift = -1022; while (fnorm < 1.0) { fnorm *= 2; shift--; } answer = ldexp(fnorm, shift); return answer * sign; } }
class __attribute__ ((visibility("default"))) boom{ virtual void stick(); }
if argv[1].startswith( foo_value = int(argv[1][len(
try { if (boost::starts_with(argv[1], "--foo=")) foo_value = boost::lexical_cast<int>(argv[1]+6); } catch (boost::bad_lexical_cast) { }
std::string prefix("--foo="); if (!arg.compare(0, prefix.size(), prefix)) foo_value = atoi(arg.substr(prefix.size()).c_str());
std::string s = "tititoto"; if (s.rfind("titi", 0) == 0) { }
strncmp(str.c_str(), substr.c_str(), substr.size())
std::string prefix = "-param="; std::string argument = argv[1]; if(argument.substr(0, prefix.size()) == prefix) { std::string argumentValue = argument.substr(prefix.size()); }
std::mismatch(prefix.begin(), prefix.end(), toCheck.begin()).first == prefix.end()
int main(int argc, char** argv) { if (argc != 3) { std::cerr << "Usage: " << argv[0] << " prefix string" << std::endl << "Will print true if return -1; } std::string prefix(argv[1]); std::string toCheck(argv[2]); if (prefix.length() > toCheck.length()) { std::cerr << "Usage: " << argv[0] << " prefix string" << std::endl << " return 2; } if (std::mismatch(prefix.begin(), prefix.end(), toCheck.begin()).first == prefix.end()) { std::cout << return 0; } else { std::cout << return 1; } }
std::equal(prefix.begin(), prefix.end(), toCheck.begin())
int main(int argc, char **argv) { if (argc != 3) { std::cerr << "Usage: " << argv[0] << " prefix string" << std::endl << "Will print true if << std::endl; return -1; } std::string prefix(argv[1]); std::string toCheck(argv[2]); if (prefix.length() > toCheck.length()) { std::cerr << "Usage: " << argv[0] << " prefix string" << std::endl << " return 2; } if (std::equal(prefix.begin(), prefix.end(), toCheck.begin())) { std::cout << << return 0; } else { std::cout << << toCheck << return 1; } }
const char * foo = "--foo"; if (text.rfind(foo, 0) == 0) foo_value = text.substr(strlen(foo));
std::string foo("--foo"); if (text.rfind(foo, 0) == 0) foo_value = text.substr(foo.length());
int main(int argc, char **argv) { for (int i = 1; i != argc; ++i) { int number = 0; int size = 0; sscanf(argv[i], "--foo=%d%n", &number, &size); if (size == strlen(argv[i])) { printf("number: %d\n", number); } else { printf("not-a-number\n"); } } return 0; }
$ ./scan --foo=2 --foo=2d --foo= number: 2 not-a-number not-a-number not-a-number
std::string prefix = "--foo="; std::string arg = argv[1]; if (prefix.size()<=arg.size() && std::equal(prefix.begin(), prefix.end(), arg.begin())) { std::istringstream iss(arg.substr(prefix.size())); iss >> foo_value; }
int main(int argc, char** argv) { option long_options[] = { {"foo", required_argument, 0, 0}, {0,0,0,0} }; getopt_long(argc, argv, "f:", long_options, 0); printf("%s\n", optarg); }
static bool startsWith(const string& s, const string& prefix) { return s.size() >= prefix.size() && s.compare(0, prefix.size(), prefix) == 0; }
while ((ep = readdir(dp))) { string s(ep->d_name); if(!(s[0] == files.push_back(s); }
std::string text = "--foo=98"; std::string start = "--foo="; if (text.find(start) == 0) { int n = stoi(text.substr(start.length())); std::cout << n << std::endl; }
const char * argument = "--foo=42"; const char * argumentPrefix = "--foo"; int inputValue = 0; std::string_view argView = argument; if (argView.starts_with(argumentPrefix)) { std::string_view prefixView = argumentPrefix; try { inputValue = std::atoi(argView.substr(prefixView.size() + 1).data()); } catch (std::exception& e) { std::cerr << e.what(); } }
std::string startsWith(const std::string &str, const std::string &prefix) { std::smatch match; std::regex_search(str, match, std::regex("^" + prefix)); return match.suffix(); }
static bool starts_with(const std::string str, const std::string prefix) { return ((prefix.size() <= str.size()) && std::equal(prefix.begin(), prefix.end(), str.begin())); } int main(int argc, char* argv[]) { bool usage = false; unsigned int foos = 0; if (argc > 1) { const std::string fParamPrefix = "-f="; const std::string fooParamPrefix = "--foo="; for (unsigned int i = 1; i < argc; ++i) { const std::string arg = argv[i]; try { if ((arg == "-h") || (arg == "--help")) { usage = true; } else if (starts_with(arg, fParamPrefix)) { foos = std::stoul(arg.substr(fParamPrefix.size())); } else if (starts_with(arg, fooParamPrefix)) { foos = std::stoul(arg.substr(fooParamPrefix.size())); } } catch (std::exception& e) { std::cerr << "Invalid parameter: " << argv[i] << std::endl << std::endl; usage = true; } } } if (usage) { std::cerr << "Usage: " << argv[0] << " [OPTION]..." << std::endl; std::cerr << "Example program for parameter parsing." << std::endl << std::endl; std::cerr << " -f, --foo=N use N foos (optional)" << std::endl; return 1; } std::cerr << "number of foos given: " << foos << std::endl; }
if(boost::starts_with(string_to_search, string_to_look_for)) intval = boost::lexical_cast<int>(string_to_search.substr(string_to_look_for.length()));
... char a = -58; std::bitset<8> x(a); std::cout << x; short c = -315; std::bitset<16> y(c); std::cout << y;
int main() { int a = -58, b = a>>3, c = -315; std::cout << "a = " << std::bitset<8>(a) << std::endl; std::cout << "b = " << std::bitset<8>(b) << std::endl; std::cout << "c = " << std::bitset<16>(c) << std::endl; }
template<typename T> void show_binrep(const T& a) { const char* beg = reinterpret_cast<const char*>(&a); const char* end = beg + sizeof(a); while(beg != end) std::cout << std::bitset<CHAR_BIT>(*beg++) << std::cout << } int main() { char a, b; short c; a = -58; c = -315; b = a >> 3; show_binrep(a); show_binrep(b); show_binrep(c); float f = 3.14; show_binrep(f); }
template<typename T> void printBin(const T& t){ size_t nBytes=sizeof(T); char* rawPtr((char*)(&t)); for(size_t byte=0; byte<nBytes; byte++){ for(size_t bit=0; bit<CHAR_BIT; bit++){ std::cout<<(((rawPtr[byte])>>bit)&1); } } std::cout<<std::endl; }; int main(void){ for(int i=0; i<50; i++){ std::cout<<i<<": "; printBin(i); } }
template<typename T> static std::string toBinaryString(const T& x) { std::stringstream ss; ss << std::bitset<sizeof(T) * 8>(x); return ss.str(); }
int main(){ uint16_t x=8; std::cout << toBinaryString(x); }
using namespace std; string show_binary(unsigned int u, int num_of_bits); int main() { cout << show_binary(128, 8) << endl; cout << show_binary(128, 5) << endl; cout << show_binary(128, 10) << endl; return 0; } string show_binary(unsigned int u, int num_of_bits) { string a = ""; int t = pow(2, num_of_bits); for(t; t>0; t = t/2) if(u >= t){ u -= t; a += "1"; } else { a += "0"; } return a ; }
MyObject object; MyObject object(blah); MyObject object();
std::ifstream ifs("file.txt"); std::vector<T> v(std::istream_iterator<T>(ifs), std::istream_iterator<T>());
std::vector<T> v((std::istream_iterator<T>(ifs)), std::istream_iterator<T>());
std::vector<T> v{std::istream_iterator<T>{ifs}, std::istream_iterator<T>{}};
MyObject object1 = MyObject(); MyObject object2 = MyObject(object1);
auto object1 = MyObject(); auto object2 = MyObject(object1);
std::for_each(vec.begin(), vec.end(), SomeFunctor());
const std::vector<int> &vec_ref = vec; std::for_each(vec_ref.begin(), vec_ref.end(), SomeFunctor());
std::for_each(vec.cbegin(), vec.cend(), SomeFunctor());
void SomeClass::f(const vector<int>& a) { auto it = someNonConstMemberVector.begin(); ... it = a.begin(); ... }
vector<MyType> v; typedef vector<MyType>::iterator iter; for( iter it = v.begin(); it != v.end(); ++it ) { }
int numbers = array[7]; const auto it = begin(numbers); auto it = cbegin(numbers);
class T {} MyT1, MyT2, MyT3; std::vector<T> MyVector = {MyT1, MyT2, MyT3}; for (std::vector<T>::const_iterator it=MyVector.begin(); it!=MyVector.end(); ++it) { }
for (std::vector<T>::const_iterator it=MyVector.cbegin(); it!=MyVector.cend(); ++it) { }
layout clipping_path { view dialog(name: "Clipping Path") { column(child_horizontal: align_fill) { popup(name: "Path:", bind: @path, items: [ { name: "None", value: empty }, { name: "Path 1", value: 1 }, { name: "Path 2", value: 2 } ]); edit_number(name: "Flatness:", digits: 9, bind: @flatness); } button(name: "OK", default: true, bind: @result); } }
int main () { string str1="123"; string str2 = str1.substr (0,str1.length()-1); cout<<str2; return 0; }
CString str; if (!str.IsEmpty()) str.Delete(str.GetLength()-1);
std::string stringName ("milan stringName.back() = std::cout<<stringName; **Output:** milan$
std::auto_ptr<int> p(new int); std::auto_ptr<int> p2 = p;
std::unique_ptr<int> p(new int); std::unique_ptr<int> p2 = std::move(p);
std::auto_ptr<int> a(new int(10)), b; b = a; std::unique_ptr<int> a(new int(10)), b; b = std::move(a);
struct A { int m; }; struct B { ~B(); int m; }; struct C { C() : m() {}; ~C(); int m; }; int main() { char buf[sizeof(B)]; memset( buf, 0x5a, sizeof( buf)); B* pB = new(buf) B(); printf( "m is %d\n", pB->m); return 0; }
if (value < 0 || value > 36) __builtin_unreachable();
int func(int x){ assume(x >=0 && x <= 10); if (x > 11){ return 2; } else{ return 17; } }
unsigned foo(unsigned x) { return x * (x + 1); } unsigned bar(unsigned x) { return foo(x + 1) + foo(2 * x); } int main() { unsigned x; scanf("%u", &x); unsigned r; if (x == 1) { r = bar(bar(x)); } else if (x == 0) { r = bar(bar(x)); } else { r = bar(x + 1); } printf("% }
namespace detail { [[noreturn]] void unreachable(){} } int func(int x){ assume(x >=0 && x <= 10); if (x > 11){ return 2; } else{ return 17; } }
detail::unreachable(): rep ret func(int): movl $17, %eax ret
class a { ~a() {} friend void delete_a(a* p); }; void delete_a(a* p) { delete p; } int main() { a *p = new a; delete_a(p); return 0; }
int MyRefCountedObject::Release() { _refCount--; if ( 0 == _refCount ) { delete this; return 0; } return _refCount; }
class myclass { public: static myclass* create( ) { return new myclass( ); } static void destroy(myclass* ptr) { delete ptr; } private: myclass( ) { ... } ~myclass() { ... } } int main () { myclass m; myclass* mp = new myclass (..); myclass* mp = myclass::create(..); delete mp; myclass::destroy(mp); }
class Handler { public: virtual void onClose() = 0; protected: virtual ~Handler(); }; class HandlerHolder { public: void setHandler( Handler* ); Handler* getHandler() const; protected: ~HandlerHolder(){} private: Handler* handler_; }; class GuiWindow : public HandlerHolder { public: void finish() { getHandler()->onClose(); } virtual ~GuiWindow(){} };
class PrivateCD { private: PrivateCD(int i) : _i(i) {}; ~PrivateCD(){}; int _i; public: static void TryMe(int i) { PrivateCD p(i); cout << "inside PrivateCD::TryMe, p._i = " << p._i << endl; }; }; int main() { PrivateCD::TryMe(8); };
---------------------------------- | | ----------------------------------
---------------------------------- |aaaabbccccccddeeee | ----------------------------------
---------------------------------- | eeee | ----------------------------------
---------------------------------- |ffffffffffffffeeeeff | ----------------------------------
------------------------------------------------------... | eeeeffffffffffffffff ------------------------------------------------------...
| A | A | A | B | B | B | C | C | C | | 0 1 2 3 4 5 6 7 8 9
| A | A | A | | | | C | C | C | | 0 1 2 3 4 5 6 7 8 9
obj1 (10kb) | obj2(20kb) | obj3(5kb) | unused space (100kb)
void func( int x ) { char* pleak = new char[1024]; std::string s( "hello world" ); if ( x ) throw std::runtime_error( "boom" ); delete [] pleak; } int main() { try { func( 10 ); } catch ( const std::exception& e ) { return 1; } return 0; }
void hw() { string hello("Hello, "); string world("world!\n"); cout << hello << world; }
using namespace std; class A { public: ~A() { cout << "A }; class B { public: ~B() { cout << "B }; void f1() { B b; throw (100); } void f() { A a; f1(); } int main() { try { f(); } catch (int num) { cout << "Caught exception: " << num << endl; } return 0; }
bool some_func() throw(myExc) { ... if (problem_occurred) { throw myExc("problem occurred"); } ... }
void throw_exception() throw(const char *) { throw 10; } void my_unexpected(){ std::cout << "well - this was unexpected" << std::endl; } int main(int argc, char **argv){ std::set_unexpected(my_unexpected); try{ throw_exception(); }catch(int x){ std::cout << "catch int: " << x << std::endl; }catch(...){ std::cout << "catch ..." << std::endl; } }
class MyClass { size_t CalculateFoo() { : : }; size_t MethodThatCannotThrow() throw() { return 100; }; void ExampleMethod() { size_t foo, bar; try { foo = CalculateFoo(); bar = foo * 100; MethodThatCannotThrow(); printf("bar is %d", bar); } catch (...) { } } };
Constructor::Constructor() { existing code { New code: do some new fancy stuff here } existing code }
{ bool isInit; (void)isStillInInitMode(&isInit); if (isInit) { return isInit; } }
{ i= (i+1) mod ARRAYSIZE; sum = sum - A[i]; A[i] = new_value; sum = sum + new_value; average = sum / ARRAYSIZE ; }
{ auto my_variable = ... ; } { auto my_variable = ... ; }
namespace N1 { class A { }; } namespace N2 { class A { }; } void foo() { { using namespace N1; A a; } { using namespace N2; A a; } }
{ MyRaiiClass guard1 = ...; { MyRaiiClass guard2 = ...; } }
{ bool isInit; (void)isStillInInitMode(&isInit); if (isInit) { return isInit; } }
int unusedInt = 1; int main(void) { int k; for(k = 0; k<10; k++) { int returnValue = myFunction(k); printf("returnValue (int) is: %d (k=%d)",returnValue,k); } for(k = 0; k<100; k++) { char returnValue = myCharacterFunction(k); printf("returnValue (char) is: %c (k=%d)",returnValue,k); } return 0; }
int: unusedInt: File and global scope (if this were a static int, it would only be file scope) int: k: Function scope int: returnValue: Block scope char: returnValue: Block scope
{ bool isInit; (void)isStillInInitMode(&isInit); if (isInit) { return isInit; } return -1; }
{ bool isInit; (void)isStillInInitMode(&isInit); if (isInit) return isInit; return -1; }
{ bool isInit; (void)isStillInInitMode(&isInit); if (isInit) CallSomethingNewHere(); return isInit; return -1; }
class MyClass; template <class T> class MyClassT; namespace project { class Bar; } namespace project { class MyClass { public: struct Color { enum type { Red, Orange, Green }; }; typedef Color::type Color_t; public: MyClass(); private: struct Impl; pimpl<Impl> mImpl; }; template <class T> class MyClassT: public MyClass {}; } template <class T> void check(MyClass<T> const& c) { }
class demo { private: unsigned char len, *dat; public: demo(unsigned char le = 5, unsigned char default) : len(le) { dat = new char[len]; for (int i = 0; i <= le; i++) dat[i] = default; } void ~demo(void) { delete [] *dat; } }; class newdemo : public demo { private: int *dat1; public: newdemo(void) : demo(0, 0) { *dat1 = 0; return 0; } };
class Demo { Demo(int& val) { m_val = val; } private: const int& m_val; };
class Demo { Demo(int& val) : m_val(val) { } private: const int& m_val; };
(x-1)^3 - (x^3 - 1) = x^3 + 3x^2 - 3x - 1 - (x^3 - 1) = 3x^2 - 3x
(x-1)^4 - (x^4-1) = x^4 - 4x^3 + 6x^2 - 4x + 1 - (x^4 - 1) = -4x^3 + 6x^2 - 4x
using System; namespace PrimeNumbers { public static class Program { static int primesCount = 0; public static void Main() { DateTime startingTime = DateTime.Now; RangePrime(1,1000000); DateTime endingTime = DateTime.Now; TimeSpan span = endingTime - startingTime; Console.WriteLine("span = {0}", span.TotalSeconds); } public static void RangePrime(int start, int end) { for (int i = start; i != end+1; i++) { bool isPrime = IsPrime(i); if(isPrime) { primesCount++; Console.WriteLine("number = {0}", i); } } Console.WriteLine("primes count = {0}",primesCount); } public static bool IsPrime(int ToCheck) { if (ToCheck == 2) return true; if (ToCheck < 2) return false; if (IsOdd(ToCheck)) { for (int i = 3; i <= (ToCheck / 3); i += 2) { if (ToCheck % i == 0) return false; } return true; } else return false; } public static bool IsOdd(int ToCheck) { return ((ToCheck % 2 != 0) ? true : false); } } }
using namespace std; unsigned long long int num = 0; bool prime(){ if(num % 2 == 0 || num == 1){ return false; } unsigned long int square_root = sqrt(num); for(unsigned long int i = 3;i <= square_root;i += 2){ if(num % i == 0){ return false; } } return true; } int main() { do{ system("cls"); cout << "Enter number : "; cin >> num; if(prime()){ cout<<"The number is a prime number"<<endl<<endl<<endl<<endl; }else{ cout<<"The number is not a prime number"<<endl<<endl<<endl<<endl; } system("pause"); }while(1); return 0; }
void primelist() { for(int i = 4; i < pr; i += 2) mark[ i ] = false; for(int i = 3; i < pr; i += 2) mark[ i ] = true; mark[ 2 ] = true; for(int i = 3, sq = sqrt( pr ); i < sq; i += 2) if(mark[ i ]) for(int j = i << 1; j < pr; j += i) mark[ j ] = false; prime[ 0 ] = 2; ind = 1; for(int i = 3; i < pr; i += 2) if(mark[ i ]) ind++; printf("%d\n", ind); }
main() { long long unsigned x,y,b,z,e,r,c; scanf("%llu",&x); if(x<2)return 0; scanf("%llu",&y); if(y<x)return 0; if(x==2)printf("|2"); if(x%2==0)x+=1; if(y%2==0)y-=1; for(b=x;b<=y;b+=2) { z=b;e=0; for(c=2;c*c<=z;c++) { if(z%c==0)e++; if(e>0)z=3; } if(e==0) { printf("|%llu",z); r+=1; } } printf("|\n%llu outputs...\n",r); scanf("%llu",&r); }
using namespace std; int set [1000000]; int main (){ for (int i=0; i<1000000; i++){ set [i] = 0; } int set_size= 1000; set [set_size]; set [0] = 2; set [1] = 3; int Ps = 0; int last = 2; cout << 2 << " " << 3 << " "; for (int n=1; n<10000; n++){ int t = 0; Ps = (n%2)+1+(3*n); for (int i=0; i==i; i++){ if (set [i] == 0) break; if (Ps%set[i]==0){ t=1; break; } } if (t==0){ cout << Ps << " "; set [last] = Ps; last++; } } cout << endl; system ("pause"); return 0; }
var P = [1, 2], j, k, l = 3 for (k = 3 ; k < 10000000 ; k += 2) { loop: if (++l < 5) { for (j = 2 ; P[j] <= Math.sqrt(k) ; ++j) if (k % P[j] == 0) break loop P[P.length] = k } else l = 0 }
using namespace std; void main() { int num,i,j,prime; cout<<"Enter the upper limit :"; cin>>num; cout<<"Prime numbers till "<<num<<" are :2, "; for(i=3;i<=num;i++) { prime=1; for(j=2;j<i;j++) { if(i%j==0) { prime=0; break; } } if(prime==1) cout<<i<<", "; } }
int add(int x, int y); int main() { using namespace std; cout << "The sum of 3 and 4 is " << add(3, 4) << endl; return 0; }
long long SafePop(std::vector<uint32_t>& v) { auto const& cv = v; long long n = -1; if (!cv.empty()) { n = cv.back(); v.pop_back(); } return n; }
int main() { for (std::size_t i = 0; i < 10; ++i) { } }
for (size_t i = 0, max = strlen (str); i < max; i++) doSomethingWith (str[i]);
std::vector<A> data; [...] size_t i = calc_index(param1, param2); if( i - 1 < 0 ) { return LEFT_BORDER; } else if( i >= data.size() - 1 ) { return RIGHT_BORDER; } return calc_something(data[i-1], data[i], data[i+1]);
calc_something(data[size_t(i-1)], data[size_t(i)], data[size_t(i+1)]);
size_t i = containner.find("mytoken"); size_t x = 99; if (i-x>-1 && i+x < containner.size()) { cout << containner[i-x] << " " << containner[i+x] << endl; }
size_t i = 5; cerr << "i-7=" << i-7 << " (int)(i-7)=" << (int)(i-7) << endl;
for (size_t i = thing.size(); i >= 0; --i) { printf("the never ending story. la la la la"); }
void * operator new (size_t size); is a good use of it.
char* getCmdOption(char ** begin, char ** end, const std::string & option) { char ** itr = std::find(begin, end, option); if (itr != end && ++itr != end) { return *itr; } return 0; } bool cmdOptionExists(char** begin, char** end, const std::string& option) { return std::find(begin, end, option) != end; } int main(int argc, char * argv[]) { if(cmdOptionExists(argv, argv+argc, "-h")) { } char * filename = getCmdOption(argv, argv + argc, "-f"); if (filename) { } return 0; }
class InputParser{ public: InputParser (int &argc, char **argv){ for (int i=1; i < argc; ++i) this->tokens.push_back(std::string(argv[i])); } const std::string& getCmdOption(const std::string &option) const{ std::vector<std::string>::const_iterator itr; itr = std::find(this->tokens.begin(), this->tokens.end(), option); if (itr != this->tokens.end() && ++itr != this->tokens.end()){ return *itr; } static const std::string empty_string(""); return empty_string; } bool cmdOptionExists(const std::string &option) const{ return std::find(this->tokens.begin(), this->tokens.end(), option) != this->tokens.end(); } private: std::vector <std::string> tokens; }; int main(int argc, char **argv){ InputParser input(argc, argv); if(input.cmdOptionExists("-h")){ } const std::string &filename = input.getCmdOption("-f"); if (!filename.empty()){ } return 0; }
int main(int argc, char** argv) { try { TCLAP::CmdLine cmd("Command description message", TCLAP::ValueArg<std::string> nameArg("n","name","Name to print",true,"homer","string"); cmd.add( nameArg ); TCLAP::SwitchArg reverseSwitch("r","reverse","Print name backwards", cmd, false); cmd.parse( argc, argv ); std::string name = nameArg.getValue(); bool reverseName = reverseSwitch.getValue(); if ( reverseName ) { std::reverse(name.begin(),name.end()); std::cout << "My name (spelled backwards) is: " << name << std::endl; } else std::cout << "My name is: " << name << std::endl; } catch (TCLAP::ArgException &e) { std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; } }
using namespace std; int main(int argc, char** argv) { int opt; string input = ""; bool flagA = false; bool flagB = false; if ( (argc <= 1) || (argv[argc-1] == NULL) || (argv[argc-1][0] == cerr << "No argument provided!" << endl; } else { input = argv[argc-1]; } cout << "input = " << input << endl; opterr = 0; while ( (opt = getopt(argc, argv, "ab")) != -1 ) { switch ( opt ) { case flagA = true; break; case flagB = true; break; case cerr << "Unknown option: break; } } cout << "flagA = " << flagA << endl; cout << "flagB = " << flagB << endl; return 0; }
for (int i = 1; i < argc; i++) { if (strcmp(argv[i],"-i")==0) { filename = argv[i+1]; printf("filename: %s",filename); } else if (strcmp(argv[i],"-c")==0) { convergence = atoi(argv[i + 1]); printf("\nconvergence: %d",convergence); } else if (strcmp(argv[i],"-a")==0) { accuracy = atoi(argv[i + 1]); printf("\naccuracy:%d",accuracy); } else if (strcmp(argv[i],"-t")==0) { targetBitRate = atof(argv[i + 1]); printf("\ntargetBitRate:%f",targetBitRate); } else if (strcmp(argv[i],"-f")==0) { frameRate = atoi(argv[i + 1]); printf("\nframeRate:%d",frameRate); } }
struct foo { foo() { cout << "!"; } }; struct foo { foo() { cout << "!"; } } instance;
enum Days {Saturday, Sunday, Tuesday,Wednesday, Thursday, Friday};
if (day == Days.Saturday) { std::cout<<"Ok its Saturday"; }
enum Days { Saturday,Sunday,Tuesday,Wednesday,Thursday,Friday}; Days day = Days.Saturday; if(day == Days.Saturday)
enum Days { Saturday,Sunday,Tuesday,Wednesday,Thursday,Friday}; Days day = Saturday; if(day == Saturday)
enum Days { Saturday,Sunday,Tuesday,Wednesday,Thursday,Friday}; Days day = Saturday; if(day == Saturday){ std::cout<<"Ok its Saturday"; }
enum Days { Saturday, Sunday, Monday, Tuesday, Wednesday, Thursday, Friday };
enum class Days { SUNDAY, MONDAY, } if (day == Days::SUNDAY)
struct Days { enum type { Saturday,Sunday,Tuesday,Wednesday,Thursday,Friday }; }; Days::type day = Days::Saturday; if (day == Days::Saturday)
enum eAppState { STARTUP, EDIT, ZONECREATION, SHUTDOWN, NOCHANGE };
eAppState state = eAppState::STARTUP; switch(state) { case STARTUP: break; case EDIT: break; case ZONECREATION: break; case SHUTDOWN: break; case NOCHANGE: break; }
namespace Daysofweek{ enum Days {Saturday, Sunday, Tuesday,Wednesday, Thursday, Friday}; }
Daysofweek::Days day = Daysofweek::Saturday; if (day == Daysofweek::Saturday) { std::cout<<"Ok its Saturday"; }
class EnumName { public: static int EnumVal1; (more definitions) }; EnumName::EnumVal1 = {value}; if ([your value] == EnumName::EnumVal1) ...
enum Days {Saturday, Sunday, Tuesday,Wednesday, Thursday, Friday}; Days day = Days::Saturday; if (day == Days::Saturday) { cout<<" Today is Saturday !"<<endl; }
enum Days {Saturday, Sunday, Tuesday, Wednesday, Thursday, Friday}; Days day = Days::Saturday; if(Days::Saturday == day) { std::cout<<"Ok its Saturday"; }
std::string readContentsOfFile(std::string fileName) { std::ifstream file(fileName.c_str()); if (file.good()) { std::stringstream buffer; buffer << file.rdbuf(); file.close(); return buffer.str(); } throw std::runtime_exception("file not found"); }
using std::ofstream; int main() { ofstream ofs("hello.txt"); ofs << "Hello world\n"; return 0; }
using std::ofstream; int main() { ofstream ofs("hello.txt"); ofs << "Hello world\n"; exit(0); }
void foo( std::string_view bob ) { std::cout << bob << "\n"; } int main(int argc, char const*const* argv) { foo( "This is a string long enough to avoid the std::string SBO" ); if (argc > 1) foo( argv[1] ); }
std::string str{"foobar"}; auto bar = str.substr(3); assert(bar == "bar");
std::string str{"foobar"}; std::string_view bar{str.c_str(), str.size()}; bar.remove_prefix(3); assert(bar == "bar");
string remove_prefix(const string &str) { return str.substr(3); } string_view remove_prefix(string_view str) { str.remove_prefix(3); return str; } static void BM_remove_prefix_string(benchmark::State& state) { std::string example{"asfaghdfgsghasfasg3423rfgasdg"}; while (state.KeepRunning()) { auto res = remove_prefix(example); if (res != "aghdfgsghasfasg3423rfgasdg") { throw std::runtime_error("bad op"); } } }
Benchmark Time CPU Iterations ------------------------------------------------------------------- BM_remove_prefix_string 90 ns 90 ns 7740626 BM_remove_prefix_string_view 6 ns 6 ns 120468514
void foo(const std::string& s); ... foo("hello, world!"); char msg[] = "good morning!"; foo(msg);
int compare( int a, int b ) { if ( a < 0 || b < 0 ) { throw std::invalid_argument( "received negative value" ); } }
try { compare( -1, 3 ); } catch( const std::invalid_argument& e ) { }
int compare(int a, int b) { if (a < 0 || b < 0) { throw std::invalid_argument("a or b negative"); } } void foo() { try { compare(-1, 0); } catch (const std::invalid_argument& e) { } }
Library API: Exception caught in function Backtrace: ~/Git/mwe-cpp-exception/src/detail/Library.cpp:17 : library_function failed ~/Git/mwe-cpp-exception/src/detail/Library.cpp:13 : could not open file "nonexistent.txt"
throw std::invalid_argument( "received negative value" );
std::runtime_error greatScott("Great Scott!"); double getEnergySync(int year) { if (year == 1955 || year == 1885) throw greatScott; return 1.21e9; }
try { }catch (std::exception& e){ std::cerr << "exception: " << e.what() << std::endl; }
using namespace std; class MyException : public exception { public: MyException(const string& msg) : m_msg(msg) { cout << "MyException::MyException - set m_msg to:" << m_msg << endl; } ~MyException() { cout << "MyException::~MyException" << endl; } virtual const char* what() const throw () { cout << "MyException - what" << endl; return m_msg.c_str(); } const string m_msg; }; void throwDerivedException() { cout << "throwDerivedException - thrown a derived exception" << endl; string execptionMessage("MyException thrown"); throw (MyException(execptionMessage)); } void illustrateDerivedExceptionCatch() { cout << "illustrateDerivedExceptionsCatch - start" << endl; try { throwDerivedException(); } catch (const exception& e) { cout << "illustrateDerivedExceptionsCatch - caught an std::exception, e.what:" << e.what() << endl; } catch(const MyException& e) { cout << "illustrateDerivedExceptionsCatch - caught an MyException, e.what::" << e.what() << endl; } cout << "illustrateDerivedExceptionsCatch - end" << endl; } int main(int argc, char** argv) { cout << "main - start" << endl; illustrateDerivedExceptionCatch(); cout << "main - end" << endl; return 0; }
struct A {}; struct B : A {}; struct C {}; int main() { A* a = new A; int i = 10; a = (A*) (&i); A* b = new B; B* b2 = static_cast<B*>(b); C* c = (C*)(b); }
struct ghost { ghost* operator&() const volatile { return 0; } }; int main() { ghost clyde; ghost* clydes_address = &clyde; }
template<class T> struct addr_impl_ref { T & v_; inline addr_impl_ref( T & v ): v_( v ) {} inline operator T& () const { return v_; } private: addr_impl_ref & operator=(const addr_impl_ref &); }; template<class T> struct addressof_impl { static inline T * f( T & v, long ) { return reinterpret_cast<T*>( &const_cast<char&>(reinterpret_cast<const volatile char &>(v))); } static inline T * f( T * v, int ) { return v; } }; template<class T> T * addressof( T & v ) { return addressof_impl<T>::f( addr_impl_ref<T>( v ), 0 ); }
char* start = &reinterpret_cast<char&>(clyde); ghost* pointer_to_clyde = reinterpret_cast<ghost*>(start);
target_include_directories(test PRIVATE ${YOUR_DIRECTORY})
set(SOURCES file.cpp file2.cpp ${YOUR_DIRECTORY}/file1.h ${YOUR_DIRECTORY}/file2.h) add_executable(test ${SOURCES})
set(HEADER_FILES ${YOUR_DIRECTORY}/file1.h ${YOUR_DIRECTORY}/file2.h) add_library(mylib libsrc.cpp ${HEADER_FILES}) target_include_directories(mylib PRIVATE ${YOUR_DIRECTORY}) add_executable(myexec execfile.cpp ${HEADER_FILES}) target_include_directories(myexec PRIVATE ${YOUR_DIRECTORY})
include_directories(include) add_executable(MyExec src/main.c src/other_source.c include/header1.h include/header2.h )
--project ---Classes ----Application -----.h and .c files ----OtherFolders --main.cpp
file(GLOB source_files "*.h" "*.cpp" "Classes/*/*.cpp" "Classes/*/*.h" ) add_executable(Server ${source_files})
static std::string namespaceScope = "Hello"; void foo() { static std::string functionScope= "World"; } struct A { static std::string classScope = "!"; };
T& get_global() { static T global = initial_value(); return global; }
struct A { A() {++A_count;} A(const A&) {++A_count;} A(A&&) {++A_count;} ~A() {--A_count;} static int get_count() {return A_count;} private: static int A_count; } int main() { A var; int c0 = var.get_count(); int c1 = A::get_count(); }
// static int x; int y; struct X { static int x; }; void foo() { static int x; }
int myFun() { static int i=5; i++; return i; } int main() { printf("%d", myFun()); printf("%d", myFun()); printf("%d", myFun()); }
struct A { static int a; }; int main() { A first; A second; first.a = 3; second.a = 4; printf("%d", first.a); }
int global_var1; const global_var2(1.618); int main() { int local_var1(23); const double local_var2(3.14); { char block_char1; int local_var1(32) std::cout << local_var1 <<"\n"; } std::cout << local_var1 << "\n"; global_var1 = 29; std::cout << global_var1 << "\n"; std::cout << global_var2 << "\n"; return 0; }
static int global_var3 = 23; extern double global_var4 = 71; int main() { return 0; }
int main() { extern int gloabl_var4; std::cout << global_var4 << "\n"; return 0; }
int globalVar1; static int globalVar2; const int globalVar3; const int globalVar4 = 23; extern const double globalVar5 = 1.57;
extern int globalVar1; extern int globalVar2; extern const int globalVar4; /* incorrect since globalVar4 has no extern specifier, limited to internal linkage by default (static specifier for const variables) */ extern const double globalVar5;
int localNextID() { int tempID = 1; return tempID++; } int newNextID() { static int newID = 0; return newID++; } int main() { int employeeID1 = nextID(); int employeeID2 = nextID(); int employeeID3 = newNextID(); int employeeID4 = newNextID(); int employeeID5 = newNextID(); return 0; }
class DesignNumber { private: static int m_designNum; int m_iteration; public: DesignNumber() { } int getItrNum() { m_iteration = m_designNum++; return m_iteration; } static int m_anyNumber; }; int DesignNumber::m_designNum = 0; int DesignNumber::m_anyNumber = 99; enter code here int main() { DesignNumber firstDesign, secondDesign, thirdDesign; std::cout << firstDesign.getItrNum() << "\n"; std::cout << secondDesign.getItrNum() << "\n"; std::cout << thirdDesign.getItrNum() << "\n"; std::cout << DesignNumber::m_anyNumber++ << "\n"; std::cout << DesignNumber::m_anyNumber++ << "\n"; std::cout << DesignNumber::m_anyNumber++ << "\n"; return 0; }
class MyClass { public: int myVar; static int myStaticVar; }; MyClass::myStaticVar = 0; MyClass classA; MyClass classB;
int myFunc() { int myVar = 0; myVar++; std::cout << myVar << std::endl; static int myStaticVar = 0; myStaticVar++; std::cout << myStaticVar << std::endl; }
class MyClass { public: int Func() { } static int StaticFunc() { } }; int main() { MyClass myClassA; myClassA.Func(); myClassA.StaticFunc(); MyClass::StaticFunc(); MyClass::Func(); return 0; }
static int x = 7; void printax() { cout << "from a.cpp: x=" << x << endl; }
static int x = 9; void printbx() { cout << "from b.cpp: x=" << x << endl; }
int main(int, char **) { printax(); printbx(); return 0; }
unsigned int powersoftwo() { static unsigned lastpow; if(lastpow == 0) lastpow = 1; else lastpow *= 2; return lastpow; } int main(int, char **) { for(int i = 0; i != 10; i++) cout << "2^" << i << " = " << powersoftwo() << endl; }
class Test { private: static char *xxx; public: static int yyy; public: Test() { cout << this << "The static class variable xxx is at address " << static_cast<void *>(xxx) << endl; cout << this << "The static class variable yyy is at address " << static_cast<void *>(&y) << endl; } }; char *Test::xxx = "I int Test::yyy = 0; int main(int, char **) { Test t1; Test t2; Test::yyy = 666; Test t3; };
static void printfilename() { cout << "this is a.cpp" << endl; }
static void printfilename() { cout << "this is b.cpp" << endl; }
class Test { private: static int count; public: static int GetTestCount() { return count; }; Test() { cout << this << "Created an instance of Test" << endl; count++; } ~Test() { cout << this << "Destroyed an instance of Test" << endl; count--; } }; int Test::count = 0; int main(int, char **) { Test *arr[10] = { NULL }; for(int i = 0; i != 10; i++) arr[i] = new Test(); cout << "There are " << Test::GetTestCount() << " instances of the Test class!" << endl; for(int i = 1; i != 9; i++) delete arr[i]; cout << "There are " << Test::GetTestCount() << " instances of the Test class!" << endl; delete arr[0]; cout << "There are " << Test::GetTestCount() << " instances of the Test class!" << endl; delete arr[9]; cout << "There are " << Test::GetTestCount() << " instances of the Test class!" << endl; return 0; }
class A { public: A(); ~A(); void somePublicMethod(); private: void somePrivateMethod(); };
class A { public: A(); ~A(); void somePublicMethod(); static int x; private: void somePrivateMethod(); };
int main() { A a1; a1.x = 1; cout << a1.x << endl; A a2; a2.x++; cout << a2.x << endl; }
using namespace std; class Box { public: static int objectCount; Box(double l=2.0, double b=2.0, double h=2.0) { cout <<"Constructor called." << endl; length = l; breadth = b; height = h; objectCount++; } double Volume() { return length * breadth * height; } private: double length; double breadth; double height; }; int Box::objectCount = 0; int main(void) { Box Box1(3.3, 1.2, 1.5); Box Box2(8.5, 6.0, 2.0); cout << "Total objects: " << Box::objectCount << endl; return 0; }
Constructor called. Constructor called. Total objects: 2
using namespace std; class Box { public: static int objectCount; Box(double l=2.0, double b=2.0, double h=2.0) { cout <<"Constructor called." << endl; length = l; breadth = b; height = h; objectCount++; } double Volume() { return length * breadth * height; } static int getCount() { return objectCount; } private: double length; double breadth; double height; }; int Box::objectCount = 0; int main(void) { cout << "Inital Stage Count: " << Box::getCount() << endl; Box Box1(3.3, 1.2, 1.5); Box Box2(8.5, 6.0, 2.0); cout << "Final Stage Count: " << Box::getCount() << endl; return 0; }
Inital Stage Count: 0 Constructor called. Constructor called. Final Stage Count: 2
Library API: Exception caught in function Backtrace: ~/Git/mwe-cpp-exception/src/detail/Library.cpp:17 : library_function failed ~/Git/mwe-cpp-exception/src/detail/Library.cpp:13 : could not open file "nonexistent.txt"
static const char BACKTRACE_START[] = "<2>--- backtrace of entire stack ---\n"; static const char BACKTRACE_STOP[] = "<2>--- backtrace finished ---\n"; static char *ltrim(char *s) { while ( s++; } return s; } void Backtracer::print() { int child_pid = ::fork(); if (child_pid == 0) { ::dup2(2, 1); char pid_buf[32]; const char* stem = " "; const char* s = stem; char* d = &pid_buf[0]; while (static_cast<bool>(*s)) { *d++ = *s++; } *d-- = char* hexppid = d; int ppid = getppid(); while (ppid != 0) { *hexppid = ((ppid & 0xF) + if(*hexppid > *hexppid += } --hexppid; ppid >>= 4; } *hexppid-- = *hexppid = char name_buf[512]; name_buf[::readlink("/proc/self/exe", &name_buf[0], 511)] = 0; ssize_t r = ::write(STDERR_FILENO, &BACKTRACE_START[0], sizeof(BACKTRACE_START)); (void)r; ::execl("/usr/bin/gdb", "/usr/bin/gdb", "--batch", "-n", "-ex", "thread apply all bt full", "-ex", "quit", &name_buf[0], ltrim(&pid_buf[0]), nullptr); ::exit(1); } else if (child_pid == -1) { ::exit(1); } else { if (0 != getuid()) { ::prctl(PR_SET_PTRACER, PR_SET_PTRACER_ANY, 0, 0, 0); } ::waitpid(child_pid, nullptr, 0); ssize_t r = ::write(STDERR_FILENO, &BACKTRACE_STOP[0], sizeof(BACKTRACE_STOP)); (void)r; } }
static bool dumpCallback(const google_breakpad::MinidumpDescriptor& descriptor, void* context, bool succeeded) { int child_pid = ::fork(); if (child_pid == 0) { ::dup2(open("/dev/null", O_WRONLY), 2); ssize_t r = ::write(STDOUT_FILENO, &MINIDUMP_STACKWALK_START[0], sizeof(MINIDUMP_STACKWALK_START)); (void)r; ::execl("/usr/bin/minidump_stackwalk", "/usr/bin/minidump_stackwalk", descriptor.path(), "/usr/share/breakpad-syms", nullptr); ::exit(1); } else if (child_pid == -1) { ::exit(1); } else { ::waitpid(child_pid, nullptr, 0); ssize_t r = ::write(STDOUT_FILENO, &MINIDUMP_STACKWALK_STOP[0], sizeof(MINIDUMP_STACKWALK_STOP)); (void)r; } ::remove(descriptor.path()); return succeeded; }
std::set_terminate([]() { ssize_t r = ::write(STDERR_FILENO, EXCEPTION, sizeof(EXCEPTION)); (void)r; google_breakpad::ExceptionHandler::WriteMinidump(std::string("/tmp"), dumpCallback, NULL); exit(1); });
/****************************************** CXXFLAGS=-g LDFLAGS=-rdynamic turducken: turducken.cc ******************************************/ class btoverflow_error: public std::overflow_error { public: btoverflow_error( const std::string& arg ) : std::overflow_error( arg ) { print_stacktrace(); }; }; void chicken(void) { throw btoverflow_error( "too big" ); } void duck(void) { chicken(); } void turkey(void) { duck(); } int main( int argc, char *argv[]) { try { turkey(); } catch( btoverflow_error e) { printf( "caught exception: %s\n", e.what() ); } }
stack trace: ./turducken : btoverflow_error::btoverflow_error(std::string const&)+0x43 ./turducken : chicken()+0x48 ./turducken : duck()+0x9 ./turducken : turkey()+0x9 ./turducken : main()+0x15 /lib/x86_64-linux-gnu/libc.so.6 : __libc_start_main()+0xf5 ./turducken() [0x401629]
void beforeCrash(void); static const bool SET_TERMINATE = std::set_terminate(beforeCrash); void beforeCrash() { __asm("int3"); } int main(int argc, char *argv[]) { SetUnhandledExceptionFilter(windows_exception_handler); ... }
void* data = something; MyClass* foo = reinterpret_cast<MyClass*>(data); foo->bar();
typedef void* hMyClass; hMyClass = something; const MyClass& foo = static_cast<MyClass&>(*hMyClass); foo.bar();
std::string s = "a_b_c"; size_t n = std::count(s.begin(), s.end(),
count = 0 For each character c in string s Check if c equals If yes, increase count
int count_underscores(string s) { int count = 0; for (int i = 0; i < s.size(); i++) if (s[i] == return count; }
std::string str = "a_b_c"; int cnt = boost::count(str,
using namespace boost::lambda; std::string s = "a_b_c"; std::cout << std::count_if (s.begin(), s.end(), _1 ==
using namespace std; int main() { string s="Sakib Hossain"; int cou=count(s.begin(),s.end(), cout<<cou; }
string str2 = "_"; string strData = "bla_bla_blabla_bla_"; size_t pos = 0,pos2; while ((pos = strData.find(str2, pos)) < strData.length()) { printf("\n%d", pos); pos += str2.length(); }
using namespace std; int main() { int count = 0; string s("Hello_world"); for (int i = 0; i < s.size(); i++) { if (s.at(i) == count++; } cout << endl << count; cin.ignore(); return 0; }
const char* str = "bla_bla_blabla_bla"; char* p = str; unsigned int count = 0; while (*p != if (*p++ == count++;
public static void main(String[] args) { char[] array = "aabsbdcbdgratsbdbcfdgs".toCharArray(); char[][] countArr = new char[array.length][2]; int lastIndex = 0; for (char c : array) { int foundIndex = -1; for (int i = 0; i < lastIndex; i++) { if (countArr[i][0] == c) { foundIndex = i; break; } } if (foundIndex >= 0) { int a = countArr[foundIndex][1]; countArr[foundIndex][1] = (char) ++a; } else { countArr[lastIndex][0] = c; countArr[lastIndex][1] = lastIndex++; } } for (int i = 0; i < lastIndex; i++) { System.out.println(countArr[i][0] + " " + countArr[i][1]); } }
using namespace std; int WordOccurrenceCount( std::string const & str, std::string const & word ) { int count(0); std::string::size_type word_pos( 0 ); while ( word_pos!=std::string::npos ) { word_pos = str.find(word, word_pos ); if ( word_pos != std::string::npos ) { ++count; word_pos += word.length(); } } return count; } int main() { string sting1="theeee peeeearl is in theeee riveeeer"; string word1="e"; cout<<word1<<" occurs "<<WordOccurrenceCount(sting1,word1)<<" times in ["<<sting1 <<"] \n\n"; return 0; }
class List { public: List(): head(nullptr), tail(nullptr) {} private: class Node { public: int data; Node* next; Node* prev; }; private: Node* head; Node* tail; };
class Product { public: enum ProductType { FANCY, AWESOME, USEFUL }; enum ProductBoxType { BOX, BAG, CRATE }; Product(ProductType t, ProductBoxType b, String name); };
class Product { public: struct ProductType { enum Enum { FANCY, AWESOME, USEFUL }; }; struct ProductBoxType { enum Enum { BOX, BAG, CRATE }; }; Product(ProductType::Enum t, ProductBoxType::Enum b, String name); };
Product p(Product::ProductType::FANCY, Product::ProductBoxType::BOX);
class X { public: X(); virtual ~X(); void publicInterface(); void publicInterface2(); private: struct Impl; std::unique_ptr<Impl> impl; }
struct X::Impl { HWND hWnd; void privateMethod(HWND wnd); void privateMethod(); }; X::X() : impl(new Impl()) { }
class Field { public: unsigned id_; string name_; unsigned type_; class match : public std::unary_function<bool, Field> { public: match(const string& name) : name_(name), has_name_(true) {}; match(unsigned id) : id_(id), has_id_(true) {}; bool operator()(const Field& rhs) const { bool ret = true; if( ret && has_id_ ) ret = id_ == rhs.id_; if( ret && has_name_ ) ret = name_ == rhs.name_; return ret; }; private: unsigned id_; bool has_id_; string name_; bool has_name_; }; };
vector<Field>::const_iterator it = find_if(fields.begin(), fields.end(), Field::match("FieldName"));
class Product{ public: class Builder; } class Product::Builder { }
int main() { int y[10]; int *a = fillarr(y); cout << a[0] << endl; }
int ( &fillarr( int (&arr)[5] ) )[5] { return arr; }
array< int, 5 > &fillarr( array< int, 5 > &arr ) { return arr; }
int (&fn1(int (&arr)[5]))[5]{ return arr; } int *fn2(int arr[]){ return arr; } int main(){ int buf[5]; fn1(buf); fn2(buf); }
using namespace std; array<int, 5> fillarr(int arr[]) { array<int, 5> arr2; for(int i=0; i<5; ++i) { arr2[i]=arr[i]*2; } return arr2; }
std::vector<int> fillarr( std::vector<int> arr ) { return arr; }
std::auto_ptr<std::vector<int> > fillarr( const std::vector<int> & arr) { std::auto_ptr<std::vector<int> > myArr(new std::vector<int>); return myArr; }
template <class Iterator> Iterator fillarr(Iterator arrStart, Iterator arrEnd) { Iterator arrIter = arrStart; for(;arrIter <= arrEnd; arrIter++) ; return arrStart; }
vector<int> arr; vector<int>::iterator foo = fillarr(arr.begin(), arr.end());
int fillarr(int arr[]){ array[0] = 10; array[1] = 5; } int main(int argc, char* argv[]){ int arr[] = { 1,2,3,4,5 }; int result = fillarr(arr); return 0; }
int * fillarr(int arr[], int length){ for (int i = 0; i < length; ++i){ } return arr; } int arr[5]; int *arr2; arr2 = fillarr(arr, 5);
void setMarks(int marks_array[]){ for(int i=0;i<sizeof(marks_array)/sizeof(int);i++) marks_list.list[i]=marks_array[i]; }
std::array<int, 5>& fillarr(std::array<int, 5>& arr) { for(auto it = arr.begin(); it != arr.end(); ++it) { } for(auto it = std::begin(arr); it != std::end(arr); ++it) { } for(auto& element : arr) { } return arr; } std::vector<int>& fillarr(std::vector<int>& arr) { for(auto it = arr.begin(); it != arr.end(); ++it) { } return arr; }
template <size_t N> int(&fillarr(int(&arr)[N]))[N] { for(int* it = arr; it != arr + N; ++it) { } return arr; }
template <typename T> using type_t = T; template <size_t N> type_t<int(&)[N]> fillarr(type_t<int(&)[N]> arr) { for(int* it = arr; it != arr + N; ++it) { } return arr; }
type_t<int(&)[5]> fillarr(type_t<int(&)[5]> arr) { for(int* it = arr; it != arr + sizeof(arr)/sizeof(arr[0]); ++it) { } return arr; }
template<typename T> struct type { typedef T type; }; typename type<int(&)[5]>::type fillarr(typename type<int(&)[5]>::type arr) { for(int* it = arr; it != arr + sizeof(arr)/sizeof(arr[0]); ++it) { } return arr; }
type<int(&)[5]>::type fillarr(type<int(&)[5]>::type arr) { for(int* it = arr; it != arr + sizeof(arr)/sizeof(arr[0]); ++it) { } return arr; }
typedef int(&array5)[5]; array5 fillarr(array5 arr) { for(int* it = arr; it != arr + sizeof(arr)/sizeof(arr[0]); ++it) { } return arr; }
void other_function(type_t<int(&)[5]> x) { } void fn() { int array[5]; other_function(fillarr(array)); }
void fn() { int array[5]; auto& array2 = fillarr(array); int forth_entry = array[4]; int forth_entry2 = array2[4]; }
int* fillarr(int* arr, size_t size) { for(int* it = arr; it != arr + size; ++it) { } return arr; }
int* fillarr(int* arr, int* end) { for(int* it = arr; it != end; ++it) { } return arr; }
int* fillarr(int* arr) { for(int* it = arr; it != arr + 5; ++it) { } return arr; }
std::pair<int*, int*> fillarr(std::pair<int*, int*> arr) { for(int* it = arr.first; it != arr.second; ++it) { } return arr; } void fn() { int array[5]; auto array2 = fillarr(std::make_pair(&array[0], &array[5])); int fourth_element = array2.first[4]; }
void other_function(std::pair<int*, int*> array) { int fourth_element = array2.first[4]; } void fn() { int array[5]; other_function(fillarr(std::make_pair(&array[0], &array[5]))); }
int *returned_array = fillarr(some_other_array); if(returned_array[0] == 3) do_important_cool_stuff();
template<typename T, size_t N> using ARR_REF = T (&)[N]; template <typename T, size_t N> ARR_REF<T,N> ArraySizeHelper(ARR_REF<T,N> arr);
using namespace std; int * fillarr( ); int main () { int *p; p = fillarr(); for ( int i = 0; i < 5; i++ ) cout << "p[" << i << "] : "<< *(p + i) << endl; return 0; } int * fillarr( ) { static int arr[5]; for (int i = 0; i < 5; ++i) arr[i] = i; return arr; }
int (*func()) { int *f = new int[10] {1,2,3}; return f; } int fa[10] = { 0 }; auto func2() -> int (*) [10] { return &fa; }
using namespace std; int* func(int ar[]) { for(int i=0;i<100;i++) ar[i]=i; int *ptr=ar; return ptr; } int main() { int *p; int y[100]={0}; p=func(y); for(int i=0;i<100;i++) cout<<i<<" : "<<y[i]<< }
private string[] functionReturnValueArray(string one, string two) { string[] x = {one, two}; x[0] = "a"; x[1] = "b"; return x; }
string[] y; y = functionReturnValueArray(stringOne, stringTwo)
class Lorem { typedef boost::shared_ptr<Lorem> ptr; typedef std::vector<Lorem::ptr> vector; // // };
Lorem::vector lorems; Lorem::ptr lorem( new Lorem() ); lorems.push_back( lorem );
Trait<Loren>::ptr Trait<Loren>::collection Trait<Loren>::map
typedef enum TokenType { blah1 = 0x00000000, blah2 = 0X01000000, blah3 = 0X02000000 } TokenType;
enum TokenType { blah1 = 0x00000000, blah2=0x01000000, blah3=0x02000000 };
enum TokenType { blah1 = 0x00000000, blah2 = 0X01000000, blah3 = 0X02000000 };
typedef enum e_TokenType { blah1 = 0x00000000, blah2 = 0X01000000, blah3 = 0X02000000 } TokenType;
typedef enum e_TokenType { blah1 = 0x00000000, blah2 = 0X01000000, blah3 = 0X02000000 } TokenType; foo(enum e_TokenType token); foo(TokenType token);
int main() { struct X { static void a() { } }; X::a(); return 0; }
int main() { auto f = []() { return 42; }; std::cout << "f() = " << f() << std::endl; }
int main() { struct { unsigned int operator() (unsigned int val) const { return val<=1 ? 1 : val*(*this)(val-1); } } fac; std::cout << fac(5) << }
auto fac = [] (unsigned int val) { return val*42; };
int main(void) { struct foo { void operator()() { int a = 1; } }; foo b; b(); }
void moo() { class dummy { public: static void a() { printf("I }; dummy::a(); dummy::a(); }
int main(){ int x = 1; std::function<void()> lambda1 = [=](){ std::cout << x << std::endl; }; std::function<void()> lambda2 = [&](){ std::cout << x << std::endl; }; x = 2; lambda1(); lambda2(); std::function<void()> lambda3 = [](){}, lambda4 = [](){}; { int y = 3; lambda3 = [=](){ std::cout << y << endl; }; lambda4 = [&](){ std::cout << y << endl; }; } lambda3(); lambda4(); return 0; }
int main(){ int x = 4, y = 5; std::function<void(int)> myLambda = [y](int z){ int xSquare = x * x; int ySquare = y * y; int zSquare = z * z; }; return 0; }
int main(){ int x = 3, y = 5; std::function<void()> myLambda = [x, &y](){ x = 2; y = 2; }; x = 2; return 0; }
int main(){ std::function<void()> a = [](){ } a(); return 0; }
int main(){ int x = 4; std::function<float(int)> divideByX = [x](int y){ return (float)y / (float)x; } std::cout << divideByX(3) << std::endl; return 0; }
struct { RETURN_TYPE operator () FUNCTION } NAME; ... int main(){ DECLARE_LAMBDA(demoLambda, void, (){ cout<<"I demoLambda(); DECLARE_LAMBDA(plus, int, (int i, int j){ return i+j; }); cout << "plus(1,2)=" << plus(1,2) << endl; return 0; }
struct U { U() : val(0) {} U(int val) : val(val) {} int val; }; struct V { V(U a, U b) { std::cout << "V(" << a.val << ", " << b.val << ");\n"; } ~V() { std::cout << "~V();\n"; } }; int main() { int five = 5; V v(U(five), U()); }
keywords.operator =("and").operator ,("or").operator ,("not").operator ,("xor");
int main() { int i; i = (1,2,3); printf("i:%d\n",i); return 0; }
int main() { int i; i = 1,2,3; printf("i:%d\n",i); return 0; }
class StaticStuff { std::vector<char> letters_; public: StaticStuff() { for (char c = letters_.push_back(c); } }; class Elsewhere { static StaticStuff staticStuff; };
class MyClass { public: static vector<char> a; static class _init { public: _init() { for(char i= } _initializer; };
vector<char> MyClass::a; MyClass::_init MyClass::_initializer;
vector<char> MyClass::letters = [] { vector<char> letters; for (char c = letters.push_back(c); return letters; }();
vector<char> MyClass::letters = [] { }(); size_t MyClass::letterCount = [] { return letters.size(); }();
class ToBeInitialized { class Initializer { public: Initializer(); }; friend class Initializer; static const int numberOfFloats; static float *theFloats; static Initializer initializer; };
const int ToBeInitialized::numberOfFloats = 17; ToBeInitialized::Initializer::Initializer() { ToBeInitialized::theFloats = (float *)malloc(ToBeInitialized::numberOfFloats * sizeof(float)); for (int i = 0; i < ToBeInitialized::numberOfFloats; ++i) ToBeInitialized::theFloats[i] = calculateSomeFancyValue(i); }
template<void(*ctor)()> struct static_constructor { struct constructor { constructor() { ctor(); } }; static constructor c; }; template<void(*ctor)()> typename static_constructor<ctor>::constructor static_constructor<ctor>::c; struct Test { static int number; static void StaticTest() { static_constructor<&Test::StaticTest>::c; number = 123; cout << "static ctor" << endl; } }; int Test::number; int main(int argc, char *argv[]) { cout << Test::number << endl; return 0; }
class MyClass { static std::vector<char> alphabet; }; static const char alphabet[] = "abcdefghijklmnopqrstuvwxyz"; std::vector<char> MyClass::alphabet( boost::begin( ::alphabet ), boost::end( ::alphabet ) );
class A { class MyInitedVar: public std::vector<char> { public: MyInitedVar() { for(char c = { push_back(c); } } }; static int count; static MyInitedVar var1; }; int A::count = 0; A::MyInitedVar A::var1;
error LNK2001: unresolved external symbol "private: static class StaticStuff Elsewhere::staticStuff" (?staticStuff@Elsewhere@@0VStaticStuff@@A)
class Elsewhere { public: static StaticStuff& GetStaticStuff() { static StaticStuff staticStuff; return staticStuff; } };
class X { public: X(void); ~X(void); private: static bool IsInit; static bool Init(); }; X::X(void) { } X::~X(void) { } bool X::IsInit(Init()); bool X::Init() { std::cout<< "ddddd"; return true; } int main () { return 0; }
interface IRandClass { public: virtual int GetRandom() = 0; }; class RandClassSingleton { private: class RandClass : public IRandClass { public: RandClass() { srand(GetTickCount()); }; virtual int GetRandom(){return rand();}; }; RandClassSingleton(){}; RandClassSingleton(const RandClassSingleton&); public: static RandClass& GetInstance() { static RandClass m_Instance; return m_Instance; }; }; main() { IRandClass *p = &RandClassSingleton::GetInstance(); int randValue = p->GetRandom(); } abc() { IRandClass *same_p = &RandClassSingleton::GetInstance(); }
template <typename Aux> class _MyClass { public: static vector<char> a; _MyClass() { (void) _initializer; } private: static struct _init { _init() { for(char i= } _initializer; }; typedef _MyClass<void> MyClass; template <typename Aux> vector<char> _MyClass<Aux>::a; template <typename Aux> typename _MyClass<Aux>::_init _MyClass<Aux>::_initializer;
void foobar() { MyClass foo; for (vector<char>::iterator it = MyClass::a.begin(); it < MyClass::a.end(); ++it) { cout << *it; } cout << endl; }
using namespace std; namespace { vector<int> vec; struct I { I() { vec.push_back(1); vec.push_back(3); vec.push_back(5); }} i; } int main() { vector<int>::const_iterator end = vec.end(); for (vector<int>::const_iterator i = vec.begin(); i != end; ++i) { cout << *i << endl; } return 0; }
vector<char> const & letters() { static vector<char> v = { return v; }
class Foo { public: void bar(); private: static int count; };
class Foo { private: static int hello; }; int Foo::hello = 1;
template<class T> class StaticConstructor { bool m_StaticsInitialised = false; public: typedef void (*StaticCallback)(void); StaticConstructor(StaticCallback callback) { if (m_StaticsInitialised) return; callback(); m_StaticsInitialised = true; } } template<class T> bool StaticConstructor<T>::m_StaticsInitialised; class Test : public StaticConstructor<Test> { static std::vector<char> letters_; static void _Test() { for (char c = letters_.push_back(c); } public: Test() : StaticConstructor<Test>(&_Test) { }; };
class MyClass { static const char * const letters(void){ static const char * const var = "abcdefghijklmnopqrstuvwxyz"; return var; } public: void show(){ std::cout << letters() << "\n"; } }; int main(){ MyClass c; c.show(); }
class Foo { public: size_t count; Foo() { static size_t count = 0; this->count = count += 1; } };
class ClassStatic{ private: static char *str; public: char* get_str() { return str; } void set_str(char *s) { str = s; } static class ClassInit{ public: ClassInit(int size){ str = new char[size]; str = "How are you?"; } } initializer; }; char* ClassStatic::str; ClassStatic::ClassInit ClassStatic::initializer(20); int main() { ClassStatic a; ClassStatic b; std::cout << "String in a: " << a.get_str() << std::endl; std::cout << "String in b: " << b.get_str() << std::endl; a.set_str("I am fine"); std::cout << "String in a: " << a.get_str() << std::endl; std::cout << "String in b: " << b.get_str() << std::endl; std::cin.ignore(); }
String in a: How are you? String in b: How are you? String in a: I am fine String in b: I am fine
enum EStaticConstructor { kNotRun, kRunning, kDone }; static volatile EStaticConstructor sm_eClass = kNotRun;
while (sm_eClass == kNotRun) { if (atomic_compare_exchange_weak(&sm_eClass, kNotRun, kRunning)) { atomic_thread_fence(memory_order_release); sm_eClass = kDone; } } while (sm_eClass != kDone) atomic_pause();
std::thread::~thread{ if((joinable ()) std::terminate (); }
using namespace std; class A { public: A(A *pa){pa->f();} virtual void f()=0; }; class D : public A { public: D():A(this){} virtual void f() {cout<<"D::f\n";} }; int main(){ D d; A *pa = &d; pa->f(); return 0; }
pure virtual method called terminate called without an active exception Aborted (core dumped)
i r rdx 0x6 6 rsi 0x69a 1690 rdi 0x69a 1690 rip 0x7feae3170c37
mov $0xea,%eax = 234 <- this is the kill syscall, sends signal to process syscall <-----
foreach(cookies, i) printf("Cookie: %s", cookies[i]);
catch (::mylib::exception& e) { \ throw gcnew MyDotNetLib::Exception(e); \ } \ catch (::std::exception& e) { \ throw gcnew MyDotNetLib::Exception(e, __LINE__, __FILE__); \ } \ catch (...) { \ throw gcnew MyDotNetLib::UnknownException(__LINE__, __FILE__); \ }
void Foo() { try { ::mylib::Foo() } HANDLE_EXCEPTIONS }
RegOpenKey(HKEY_CURRENT_USER, BASE_HKEY "Settings", &settings); RegOpenKey(HKEY_CURRENT_USER, BASE_HKEY "TypedURLs", &URLs);
const char* BaseHkey = "Software\\Microsoft\\Internet Explorer\\"; RegOpenKey(HKEY_CURRENT_USER, (string(BaseHkey) + "Settings").c_str(), &settings); RegOpenKey(HKEY_CURRENT_USER, (string(BaseHkey) + "TypedURLs").c_str(), &URLs);
if (!(condition)) { \ assert(false && return ret_val; }
bool andf(bool a, bool b) { return a && b; } andm(x, y) andf(x, y)
do \ { \ try \ { \ std::tstringstream strBuffer ; \ strBuffer << p_strMessage ; \ strMessage = strBuffer.str() ; \ raiseSomeAlert(__FILE__, __FUNCSIG__, __LINE__, strBuffer.str().c_str()) \ } \ catch(...){} \ { \ } \ } \ while(false)
RAISE_ERROR_STL("Hello... The following values " << i << " and " << j << " are wrong") ;
Error Raised: ==================================== File : MyFile.cpp, line 225 Function : MyFunction(int, double) Message : "Hello... The following values 23 and 12 are wrong"
C:\my_project\my_cpp_file.cpp (225) : ------------ Hello World
MY_TRY doSomethingDangerous() ; MY_CATCH tryToRecoverEvenWithoutMeaningfullInfo() ; damnThoseMacros() ; MY_END_TRY
int main() { std::string hello( "Hello, world!" ); BOOST_FOREACH( char ch, hello ) { std::cout << ch; } return 0; }
OUR_OWN_THROW(InvalidOperationException, (L"Uninitialized foo!"));
/* * List of fields, names and values. */ FIELD(EXAMPLE1, "first example", 10) FIELD(EXAMPLE2, "second example", 96) FIELD(ANOTHER, "more stuff", 32) ...
void lock() { EnterCriticalSection(...) pthread_mutex_lock(...) }
void debugAssert(bool val, const char* file, int lineNumber);
DEF_EXCEPTION(RessourceNotFound, "Ressource not found")
{\ public:\ virtual const char* what() const throw()\ {\ return B;\ };\ }\
SECURITY_CHECK(ROLE_BUSINESS_INFORMATION_STEWARD | ROLE_WORKER_ADMINISTRATOR); LRESULT CAddPerson1::OnWizardNext() { if(m_Role.GetItemData(m_Role.GetCurSel()) == parent->ROLE_EMPLOYEE) { SECURITY_CHECK(ROLE_WORKER_ADMINISTRATOR | ROLE_BUSINESS_INFORMATION_STEWARD ) -1; } else if(m_Role.GetItemData(m_Role.GetCurSel()) == parent->ROLE_CONTINGENT) { SECURITY_CHECK(ROLE_CONTINGENT_WORKER_ADMINISTRATOR | ROLE_BUSINESS_INFORMATION_STEWARD | ROLE_WORKER_ADMINISTRATOR) -1; } ...
void MultiplyEveryElementInList(std::list<int>& ints, int mul) { foreach(std::list<int>, ints, i) (*i) *= mul; } int GetSumOfList(const std::list<int>& ints) { int ret = 0; foreach_const(std::list<int>, ints, i) ret += *i; return ret; }
if( FnType theFunction = get_op_from_name(FName) ) { \ return theFunction(__VA_ARGS__); \ } else { \ throw invalid_function_name(FName); \ } \ /**/
cout <<"Hello, World!" <<endl; DEBUG_ONLY cout <<"This is outputed only in debug mode" <<endl;
import os cpp_source = def check_if_array_size_compiles(size): f = open(name= f.write(cpp_source.format(m)) f.close() os.system( errors = open( return len(errors) == 0 l = 0 r = 10 ** 50 while r - l > 1: m = (r + l) if check_if_array_size_compiles(m): l = m else: r = m answer = l + check_if_array_size_compiles(r) print
long long** a = new long long*[x]; for (unsigned i = 0; i < x; i++) a[i] = new long long[y];
int main() { int max_ints[257400]{ 0 }; return 0; }
int main() { int max_ints[257500]{ 0 }; return 0; }
int main() { int maxish_ints[257000]{ 0 }; int more_ints[400]{ 0 }; return 0; }
int main() { int maxish_ints[257000]{ 0 }; int more_ints[500]{ 0 }; return 0; }
1>Form.obj : error LNK2019: unresolved external symbol "public: class Field * __thiscall Field::addField(class Field *)" (?addField@Field@@QAEPAV1@PAV1@@Z) referenced in function "public: void __thiscall Form::parse(class std::basic_stringstream<char,struct std::char_traits<char>,class std::allocator<char> > &)" (?parse@Form@@QAEXAAV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z) 1>Form.obj : error LNK2019: unresolved external symbol "public: virtual void __thiscall Field::parse(class std::basic_stringstream<char,struct std::char_traits<char>,class std::allocator<char> > &)" (?parse@Field@@UAEXAAV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z) referenced in function "public: __thiscall InputField::InputField(class std::basic_stringstream<char,struct std::char_traits<char>,class std::allocator<char> > &)" (??0InputField@@QAE@AAV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z) 1>Form.obj : error LNK2001: unresolved external symbol "public: virtual void __thiscall Field::prompt(void)" (?prompt@Field@@UAEXXZ) 1>Form.obj : error LNK2001: unresolved external symbol "public: virtual class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > __thiscall Field::getName(void)" (?getName@Field@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ) 1>Form.obj : error LNK2001: unresolved external symbol "public: virtual class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > __thiscall Field::getType(void)" (?getType@Field@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ) 1>Form.obj : error LNK2001: unresolved external symbol "public: virtual void __thiscall Field::describe(void)" (?describe@Field@@UAEXXZ) 1>C:\Users\tomy\Documents\Visual Studio 2010\Projects\zapoctovkac++\Debug\zapoctovkac++.exe : fatal error LNK1120: 6 unresolved externals
class A { public: void myFunc(); }; void A::myFunc() { }
class test { void myFunc(); } class IamInterface { virtual void myFunc(); } class IamConcreteImpl { void myFunc() { 1+1=2; } }
class ClassB; class ClassA{ void foo(){ ClassB* tmp = new ClassB(); } };
namespace mmap_allocator_namespace { template <typename T> class mmap_allocator: public std::allocator<T> { public: typedef size_t size_type; typedef T* pointer; typedef const T* const_pointer; template<typename _Tp1> struct rebind { typedef mmap_allocator<_Tp1> other; }; pointer allocate(size_type n, const void *hint=0) { fprintf(stderr, "Alloc %d bytes.\n", n*sizeof(T)); return std::allocator<T>::allocate(n, hint); } void deallocate(pointer p, size_type n) { fprintf(stderr, "Dealloc %d bytes (%p).\n", n*sizeof(T), p); return std::allocator<T>::deallocate(p, n); } mmap_allocator() throw(): std::allocator<T>() { fprintf(stderr, "Hello allocator!\n"); } mmap_allocator(const mmap_allocator &a) throw(): std::allocator<T>(a) { } template <class U> mmap_allocator(const mmap_allocator<U> &a) throw(): std::allocator<T>(a) { } ~mmap_allocator() throw() { } }; }
using namespace std; using namespace mmap_allocator_namespace; vector<int, mmap_allocator<int> > int_vec(1024, 0, mmap_allocator<int>());
template <class charT> bool isspace (charT c, const locale& loc); template <class charT> bool isprint (charT c, const locale& loc); template <class charT> bool iscntrl (charT c, const locale& loc); template <class charT> charT toupper(charT c, const locale& loc); template <class charT> charT tolower(charT c, const locale& loc);
class Temp { public: virtual ~Temp() { } virtual void myVirtualFunction() const { cout<<"Temp::myVirtualFunction"<<endl; } }; class TempDerived : public Temp { public: void myVirtualFunction() const { cout<<"TempDerived::myVirtualFunction"<<endl; } }; int main(void) { TempDerived aDerivedObj; aDerivedObj.myVirtualFunction(); Temp* pTemp = &aDerivedObj; pTemp->myVirtualFunction(); return 0; }
class A { virtual void foo(); }; class B : public A { inline virtual void foo() final { } }; class C : public B { }; void bar(B const& b) { A const& a = b; a.foo(); }
class Base { public: inline virtual ~Base () { } }; class Derived1 : public Base { inline virtual ~Derived1 () { } }; class Derived2 : public Derived1 { inline virtual ~Derived2 () { } }; void foo (Base * base) { delete base; }
class Base { virtual void F() = 0; }; class Derived1 : public Base { virtual void F(); }; class Derived2 : public Base { virtual void F(); };
switch (typeof(b)) { case Derived1: b->Derived1::F(); break; case Derived2: b->Derived2::F(); break; case Base: assert(!"pure virtual function call!"); default: b->F(); break; }
switch (typeof(b)) { case Derived1: b->Derived1::F(); break; default: b->F(); break; }
int foo(int * __restrict__ a, int * __restrict__ b) { return *a + *b; } int main(void) { int a = 1, b = 1, c; c = foo(&a, &b); printf("c == %d\n", c); return 0; }
void f(int *a, int *b, int *x) { *a += *x; *b += *x; }
load R1 ← *x ; Load the value of x pointer load R2 ← *a ; Load the value of a pointer add R2 += R1 ; Perform Addition set R2 → *a ; Update the value of a pointer ; Similarly for b, note that x is loaded twice, ; because a may be equal to x. load R1 ← *x load R2 ← *b add R2 += R1 set R2 → *b
void fr(int *__restrict__ a, int *__restrict__ b, int *__restrict__ x);
load R1 ← *x load R2 ← *a add R2 += R1 set R2 → *a ; Note that x is not reloaded, ; because the compiler knows it is unchanged ; load R1 ← *x load R2 ← *b add R2 += R1 set R2 → *b
g++ -g -std=gnu++98 -O0 -c main.cpp objdump -S main.o
void f(int *a, int *b, int *x) { *a += *x; 0: 8b 02 mov (%rdx),%eax 2: 01 07 add %eax,(%rdi) *b += *x; 4: 8b 02 mov (%rdx),%eax 6: 01 06 add %eax,(%rsi) void fr(int *__restrict__ a, int *__restrict__ b, int *__restrict__ x) { *a += *x; 10: 8b 02 mov (%rdx),%eax 12: 01 07 add %eax,(%rdi) *b += *x; 14: 01 06 add %eax,(%rsi)
void f(char *restrict p1, char *restrict p2, size_t size) { for (size_t i = 0; i < size; i++) { p1[i] = 4; p2[i] = 9; } }
3f0: 48 85 d2 test %rdx,%rdx 3f3: 74 33 je 428 <fr+0x38> 3f5: 55 push %rbp 3f6: 53 push %rbx 3f7: 48 89 f5 mov %rsi,%rbp 3fa: be 04 00 00 00 mov $0x4,%esi 3ff: 48 89 d3 mov %rdx,%rbx 402: 48 83 ec 08 sub $0x8,%rsp 406: e8 00 00 00 00 callq 40b <fr+0x1b> 407: R_X86_64_PC32 memset-0x4 40b: 48 83 c4 08 add $0x8,%rsp 40f: 48 89 da mov %rbx,%rdx 412: 48 89 ef mov %rbp,%rdi 415: 5b pop %rbx 416: 5d pop %rbp 417: be 09 00 00 00 mov $0x9,%esi 41c: e9 00 00 00 00 jmpq 421 <fr+0x31> 41d: R_X86_64_PC32 memset-0x4 421: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 428: f3 c3 repz retq
template<typename T> struct Check1 { template<typename U = T> U read(typename std::enable_if< std::is_same<U, int>::value >::type* = 0) { return 42; } template<typename U = T> U read(typename std::enable_if< std::is_same<U, double>::value >::type* = 0) { return 3.14; } };
template<typename T> struct Check2 { template<typename U = T, typename std::enable_if< std::is_same<U, int>::value, int>::type = 0> U read() { return 42; } template<typename U = T, typename std::enable_if< std::is_same<U, double>::value, int>::type = 0> U read() { return 3.14; } };
template<typename T> struct Check3 { template<typename U = T> typename std::enable_if<std::is_same<U, int>::value, U>::type read() { return 42; } template<typename U = T> typename std::enable_if<std::is_same<U, double>::value, U>::type read() { return 3.14; } };
template<typename T> T fun(T arg) { return detail::fun(arg, typename some_template_trait<T>::type() ); } namespace detail { template<typename T> fun(T arg, std::false_type ) { } template<typename T> fun(T arg, std::true_type ) {} }
template<typename T, typename = std::enable_if_t<std::is_same<T, int>::value>> void f() { } template<typename T, typename = std::enable_if_t<std::is_same<T, float>::value>> void f() { }
struct Base { template <std::size_t I, std::enable_if_t<I == 0>* = nullptr> void f() {} template <std::size_t I> std::enable_if_t<I == 0> g() {} }; struct S : Base { using Base::f; using Base::g; template <std::size_t I, std::enable_if_t<I == 1>* = nullptr> void f() {} template <std::size_t I> std::enable_if_t<I == 1> g() {} };
struct Base { template <std::size_t I> void h(std::enable_if_t<I == 0>* = nullptr) {} }; struct S : Base { using Base::h; template <std::size_t I> void h(std::enable_if_t<I == 1>* = nullptr) {} };
std::string str = boost::lexical_cast<std::string>(dbl);
std::ostringstream strs; strs << dbl; std::string str = strs.str();
char buffer[32]; snprintf(buffer, sizeof(buffer), "%g", myDoubleVar); std::ostringstream sstream; sstream << myDoubleVar; std::string varAsString = sstream.str(); std::string varAsString = std::to_string(myDoubleVar); std::string varAsString = boost::lexical_cast<std::string>(myDoubleVar);
template <typename T> std::string to_string(T const& value) { stringstream sstr; sstr << value; return sstr.str(); }
double d = 3.0; std::string str = std::to_string(d);
double d = 453.23; std::ostringstream os; os << d; std::string str = os.str();
double d = 453.23; std::string str = boost::lexical_cast<string>(d);
double pi = M_PI; std::string pi_as_string = strtk::type_to_string<double>( pi );
string temp = ""; stringstream outStream; double ratio = (currentImage->width*1.0f)/currentImage->height; outStream << " R: " << ratio; temp = outStream.str();
main () { char buffer [20]; gcvt (1365.249,6,buffer); puts (buffer); gcvt (1365.249,3,buffer); puts (buffer); return 0; } Output: 1365.25 1.37e+003
void double_to_char(double f,char * buffer){ gcvt(f,10,buffer); }
std::string number_in_string; double number_in_double; std::ostringstream output; number_in_string = (dynamic_cast< std::ostringstream*>(&(output << number_in_double << std::endl)))->str();
using namespace std; int main () { string pi = "pi is " + to_string(3.1415926); cout<< "pi = "<< pi << endl; return 0; }
string to_string (int val); string to_string (long val); string to_string (long long val); string to_string (unsigned val); string to_string (unsigned long val); string to_string (unsigned long long val); string to_string (float val); string to_string (double val); string to_string (long double val);
template<class T = std::string, class U> T to(U a) { std::stringstream ss; T ret; ss << a; ss >> ret; return ret; };
std::string str = to(2.5); double d = to<double>("2.5");
template <typename T> class base { protected: int x; }; template <typename T> class derived : public base<T> { public: int f() { return this->x; } }; int main() { derived<int> d; d.f(); return 0; }
typedef int A; int A; static const int x = 2; template <typename T> void foo() { A *x = 0; }
template <typename T> struct Foo : Bar<T> { Foo() { A *x = 0; } };
template <typename T> class derived : public base<T> { public: using base<T>::x; int f() { return x; } };
template <typename Iter, typename F> void map(Iter begin, Iter end, F f) { for (; begin != end; ++begin) *begin = f(*begin); }
int a[] = { 1, 2, 3, 4 }; map(begin(a), end(a), [](int n) { return n * 2; });
template <> void map<int*, _some_lambda_type>(int* begin, int* end, _some_lambda_type f) { for (; begin != end; ++begin) *begin = f.operator()(*begin); }
template <> void map<int*, int (*)(int)>(int* begin, int* end, int (*f)(int)) { for (; begin != end; ++begin) *begin = f(*begin); }
QString string("hello $name"); string.replace("$name", "Somename");
bool replace(std::string& str, const std::string& from, const std::string& to) { size_t start_pos = str.find(from); if(start_pos == std::string::npos) return false; str.replace(start_pos, from.length(), to); return true; } std::string string("hello $name"); replace(string, "$name", "Somename");
void replaceAll(std::string& str, const std::string& from, const std::string& to) { if(from.empty()) return; size_t start_pos = 0; while((start_pos = str.find(from, start_pos)) != std::string::npos) { str.replace(start_pos, from.length(), to); start_pos += to.length(); } }
std::string string("hello $name"); string = std::regex_replace(string, std::regex("\\$name"), "Somename");
s.replace(s.find("$name"), sizeof("Somename")-1, "Somename");
std::string ReplaceString(std::string subject, const std::string& search, const std::string& replace) { size_t pos = 0; while ((pos = subject.find(search, pos)) != std::string::npos) { subject.replace(pos, search.length(), replace); pos += replace.length(); } return subject; }
void ReplaceStringInPlace(std::string& subject, const std::string& search, const std::string& replace) { size_t pos = 0; while ((pos = subject.find(search, pos)) != std::string::npos) { subject.replace(pos, search.length(), replace); pos += replace.length(); } }
std::string input = "abc abc def"; std::cout << "Input string: " << input << std::endl; std::cout << "ReplaceString() return value: " << ReplaceString(input, "bc", "!!") << std::endl; std::cout << "ReplaceString() input string not modified: " << input << std::endl; ReplaceStringInPlace(input, "bc", "??"); std::cout << "ReplaceStringInPlace() input string modified: " << input << std::endl;
Input string: abc abc def ReplaceString() return value: a!! a!! def ReplaceString() input string not modified: abc abc def ReplaceStringInPlace() input string modified: a?? a?? def
string s("hello $name"); size_type pos = s.find( "$name" ); if ( pos != string::npos ) { s.replace( pos, 5, "somename" ); }
std::string& replace(std::string& s, const std::string& from, const std::string& to) { if(!from.empty()) for(size_t pos = 0; (pos = s.find(from, pos)) != std::string::npos; pos += to.size()) s.replace(pos, from.size(), to); return s; }
sHaystack.replace(sHaystack.find(sNeedle), sNeedle.size(), sReplace);
std::string sHaystack = "This is %XXX% test."; std::string sNeedle = "%XXX%"; std::string sReplace = "my special"; sHaystack.replace(sHaystack.find(sNeedle),sNeedle.size(),sReplace); std::cout << sHaystack << std::endl;
std::string replace(std::string base, const std::string from, const std::string to) { std::string SecureCopy = base; for (size_t start_pos = SecureCopy.find(from); start_pos != std::string::npos; start_pos = SecureCopy.find(from,start_pos)) { SecureCopy.replace(start_pos, from.length(), to); } return SecureCopy; }
using namespace std; void ReplaceString(string& subject, char search, const string& replace) { size_t initSize = subject.size(); int count = 0; for (auto c : subject) { if (c == search) ++count; } size_t idx = subject.size()-1 + count * replace.size()-1; subject.resize(idx + 1, string reverseReplace{ replace }; reverse(reverseReplace.begin(), reverseReplace.end()); char *end_ptr = &subject[initSize - 1]; while (end_ptr >= &subject[0]) { if (*end_ptr == search) { for (auto c : reverseReplace) { subject[idx - 1] = c; --idx; } } else { subject[idx - 1] = *end_ptr; --idx; } --end_ptr; } } int main() { string s{ "Mr John Smith" }; ReplaceString(s, cout << s << "\n"; }
using namespace std; long strReplace(string& str, const string& from, const string& to, size_t start = 0, long count = -1) { if (from.empty()) return 0; size_t startpos = str.find(from, start); long replaceCount = 0; while (startpos != string::npos){ str.replace(startpos, from.length(), to); startpos += to.length(); replaceCount++; if (count > 0 && replaceCount >= count) break; startpos = str.find(from, startpos); } return replaceCount; }
wstring myString = L"Hello $$ this is an example. By $$."; wstring search = L"$$"; wstring replace = L"Tom"; for (int i = myString.find(search); i >= 0; i = myString.find(search)) myString.replace(i, search.size(), replace);
vector<int> v = {1, 3, 5, 7, 9}; for (auto x : v) cout << x <<
class X { public: X() : m_data(0) {} X(int data) : m_data(data) {} ~X() {} X(const X& other) : m_data(other.m_data) { cout << "X copy ctor.\n"; } X& operator=(const X& other) { m_data = other.m_data; cout << "X copy assign.\n"; return *this; } int Get() const { return m_data; } private: int m_data; }; ostream& operator<<(ostream& os, const X& x) { os << x.Get(); return os; }
vector<X> v = {1, 3, 5, 7, 9}; cout << "\nElements:\n"; for (auto x : v) { cout << x << }
[... copy constructor calls for vector<X> initialization ...] Elements: X copy ctor. 1 X copy ctor. 3 X copy ctor. 5 X copy ctor. 7 X copy ctor. 9
vector<X> v = {1, 3, 5, 7, 9}; cout << "\nElements:\n"; for (const auto& x : v) { cout << x << }
[... copy constructor calls for vector<X> initialization ...] Elements: 1 3 5 7 9
vector<int> v = {1, 3, 5, 7, 9}; for (auto x : v) x *= 10; for (auto x : v) cout << x <<
TestRangeFor.cpp:138:11: error: assignment of read-only reference x *= 10; ^
vector<int> v = {1, 3, 5, 7, 9}; for (auto& x : v) x *= 10; for (auto x : v) cout << x <<
vector<string> v = {"Bob", "Jeff", "Connie"}; for (auto& x : v) x = "Hi " + x + "!"; for (const auto& x : v) cout << x <<
vector<bool> v = {true, false, false, true}; for (auto& x : v) x = !x;
TestRangeFor.cpp:168:20: error: invalid initialization of non-const reference of type ce {aka std::_Bit_reference}' for (auto& x : v) ^
vector<bool> v = {true, false, false, true}; for (auto&& x : v) x = !x; cout << boolalpha; for (const auto& x : v) cout << x <<
for(auto it = container.begin(); it != container.end(); ++it) { auto elem = *it; }
for(auto it = container.begin(); it != container.end(); ++it) { auto& elem = *it; }
for(auto it = container.begin(); it != container.end(); ++it) { const auto& elem = *it; }
struct Range { struct Iterator { Iterator(int v, int s) : val(v), step(s) {} int operator*() const { return val; } Iterator& operator++() { val += step; return *this; } bool operator!=(Iterator const& rhs) const { return (this->val < rhs.val); } int val; int step; }; Range(int l, int h, int s=1) : low(l), high(h), step(s) {} Iterator begin() const { return Iterator(low, step); } Iterator end() const { return Iterator(high, 1); } int low, high, step; };
int main() { Range r1(1, 10); for ( auto item : r1 ) { std::cout << item << " "; } std::cout << std::endl; Range r2(1, 20, 2); for ( auto item : r2 ) { std::cout << item << " "; } std::cout << std::endl; Range r3(1, 20, 3); for ( auto item : r3 ) { std::cout << item << " "; } std::cout << std::endl; }
-j [jobs], --jobs[=jobs] Specifies the number of jobs (commands) to run simultaneously. If there is more than one -j option, the last one is effective. If the -j option is given without an argument, make will not limit the number of jobs that can run simultaneously.
int main() { double x = 6.3; double y = 2; double z = x % y; }
int main() { double x = 6.3; double y = 2.0; double z = std::fmod(x,y); }
template<typename T, typename U> constexpr double dmod (T x, U mod) { return !mod ? x : x - mod * static_cast<long long>(x / mod); } double z = dmod<double, unsigned int>(14.3, 4); double z = dmod<long, float>(14, 4.6); double z = dmod(14.7, 0.3); double z = dmod(14.7, 0); double z = dmod(0, 0.3f); double z = dmod(myFirstVariable, someOtherVariable);
double dmod(double x, double y) { return x - (int)(x/y) * y; }
template<typename T> struct Pointer { typedef std::unique_ptr<T> type; typedef T* type; };
template<typename T> void Destroy (T* p) { delete p; } template<typename T> void Destroy (std::unique_ptr<T> p) { }
Pointer<X>::type p = new X; Pointer<X>::type p2(Assign(p));
template<typename T> T* Assign (T *p) { return p; } template<typename T> ... Assign (SmartPointer<T> &p) { }
cannot declare member function static void Foo::Bar(std::ostream&, const Foo::Node*) to have static linkage
class Foo { public: Foo(); ~Foo(); bool insert(const Foo2 &v); Foo * find(const Foo2 &v); const Foo * find(const Foo2 &v) const; void output(ostream &s) const; private: struct Node { Foo2 info; Node *left; Node *right; }; Node * root; static bool insert(const Foo2 &v, Node *&p); static void output(ostream &s, const Node *p); static void deleteAll(Node *p);
class Foo { static void Bar(); }; ... static void Foo::Bar() { ... }
template<typename T, T *ptr> struct something{}; template<> struct something<nullptr_t, nullptr>{};
template<typename T> void f(T *ptr); void f(nullptr_t);
std::string * str = NULL; void (A::*ptrFunc) () = &A::doSomething; if (ptrFunc == NULL) {}
void doSomething(int) { std::cout<<"In Int version"; } void doSomething(char *) { std::cout<<"In char* version"; } int main() { doSomething(NULL); return 0; }
void doSomething(int); void doSomething(char *); int main() { doSomething(static_cast <char *>(0)); doSomething(0); doSomething(NULL) }
void doSomething(int) { std::cout<<"In Int version"; } void doSomething(char *) { std::cout<<"In char* version"; } int main() { char *pc = nullptr; int i = nullptr; bool flag = nullptr; doSomething(nullptr); return 0; }
void f(int* p); template<typename T> void forward(T&& t) { f(std::forward<T>(t)); } int main() { forward(0); }
void f(int); void f(int*); int main() { f(0); f(nullptr); }
auto result = findRecord( ); if (result == 0) { .... }
auto result = findRecord( ); if (result == nullptr) { ... }
using namespace std; int f1(std::shared_ptr<int> spw) { return 0; } double f2(std::unique_ptr<int> upw) { return 0.0; } bool f3(int* pw) { return 0; } std::mutex f1m, f2m, f3m; using MuxtexGuard = std::lock_guard<std::mutex>; void lockAndCallF1() { MuxtexGuard g(f1m); auto result = f1(static_cast<int>(0)); cout<< result<<endl; } void lockAndCallF2() { MuxtexGuard g(f2m); auto result = f2(static_cast<int>(NULL)); cout<< result<<endl; } void lockAndCallF3() { MuxtexGuard g(f3m); auto result = f3(nullptr); cout<< result<<endl; } int main() { lockAndCallF1(); lockAndCallF2(); lockAndCallF3(); return 0; }
using namespace std; int f1(std::shared_ptr<int> spw) { return 0; } double f2(std::unique_ptr<int> upw) { return 0.0; } bool f3(int* pw) { return 0; } std::mutex f1m, f2m, f3m; using MuxtexGuard = std::lock_guard<std::mutex>; template<typename FuncType, typename MuxType, typename PtrType> auto lockAndCall(FuncType func, MuxType& mutex, PtrType ptr) -> decltype(func(ptr)) { MuxtexGuard g(mutex); return func(ptr); } int main() { auto result1 = lockAndCall(f1, f1m, 0); auto result2 = lockAndCall(f2, f2m, NULL); auto result3 = lockAndCall(f3, f3m, nullptr); return 0; }
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr); if(derived_ptr != nullptr) { ... }
if(auto derived_ptr = dynamic_cast<Derived*>(base_ptr)) { ... }
makeSoupOf :: Foodstuff -> Liquid makeSoupOf p@(Potato{..}) = mash (boil p) <> water makeSoupOf vegetable | isSoft vegetable = squeeze vegetable <> salt makeSoupOf stuff = boil (throwIn (water<>salt) stuff)
const bool local_predicate = *if-expression*; if (local_predicate) ...
_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF | _CRTDBG_CHECK_ALWAYS_DF );
enum AnimalFlags { HasClaws = 1, CanFly =2, EatsFish = 4, Endangered = 8 }; seahawk.flags = CanFly | EatsFish | Endangered;
enum AnimalFlags { HasClaws = 1, CanFly =2, EatsFish = 4, Endangered = 8 }; inline AnimalFlags operator|(AnimalFlags a, AnimalFlags b) {return static_cast<AnimalFlags>(static_cast<int>(a) | static_cast<int>(b));}
enum Flags { A = 1 << 0, B = 1 << 1, C = 1 << 2, D = 1 << 3, };
template<class T> inline T operator~ (T a) { return (T)~(int)a; } template<class T> inline T operator| (T a, T b) { return (T)((int)a | (int)b); } template<class T> inline T operator& (T a, T b) { return (T)((int)a & (int)b); } template<class T> inline T operator^ (T a, T b) { return (T)((int)a ^ (int)b); } template<class T> inline T& operator|= (T& a, T b) { return (T&)((int&)a |= (int)b); } template<class T> inline T& operator&= (T& a, T b) { return (T&)((int&)a &= (int)b); } template<class T> inline T& operator^= (T& a, T b) { return (T&)((int&)a ^= (int)b); }
int iFlags = HasClaws | CanFly; assert(iFlags & ~(InvalidAnimalFlagMaxValue-1) == 0); enum AnimalFlags { HasClaws = 1, CanFly =2, EatsFish = 4, Endangered = 8, InvalidAnimalFlagMaxValue = 16 };
enum class AnimalFlags { CanFly = 2, HasClaws = 4 }; if(CanFly == 2) { }
enum AnimalFlags { HasClaws = 1, CanFly =2, EatsFish = 4, Endangered = 8 }; DEFINE_ENUM_FLAG_OPERATORS(AnimalFlags) seahawk.flags = CanFly | EatsFish | Endangered;
enum class ObjectType : uint32_t { ANIMAL = (1 << 0), VEGETABLE = (1 << 1), MINERAL = (1 << 2) }; constexpr enum ObjectType operator |( const enum ObjectType selfValue, const enum ObjectType inValue ) { return (enum ObjectType)(uint32_t(selfValue) | uint32_t(inValue)); }
template<class ENUM,class UNDERLYING=typename std::underlying_type<ENUM>::type> class SafeEnum { public: SafeEnum() : mFlags(0) {} SafeEnum( ENUM singleFlag ) : mFlags(singleFlag) {} SafeEnum( const SafeEnum& original ) : mFlags(original.mFlags) {} SafeEnum& operator |=( ENUM addValue ) { mFlags |= addValue; return *this; } SafeEnum operator |( ENUM addValue ) { SafeEnum result(*this); result |= addValue; return result; } SafeEnum& operator &=( ENUM maskValue ) { mFlags &= maskValue; return *this; } SafeEnum operator &( ENUM maskValue ) { SafeEnum result(*this); result &= maskValue; return result; } SafeEnum operator ~() { SafeEnum result(*this); result.mFlags = ~result.mFlags; return result; } explicit operator bool() { return mFlags != 0; } protected: UNDERLYING mFlags; };
enum TFlags_ { EFlagsNone = 0, EFlagOne = (1 << 0), EFlagTwo = (1 << 1), EFlagThree = (1 << 2), EFlagFour = (1 << 3) }; typedef SafeEnum<enum TFlags_> TFlags;
TFlags myFlags; myFlags |= EFlagTwo; myFlags |= EFlagThree; if( myFlags & EFlagTwo ) std::cout << "flag 2 is set" << std::endl; if( (myFlags & EFlagFour) == EFlagsNone ) std::cout << "flag 4 is not set" << std::endl;
template <class T, int N> class FlagSet { bitset<N> bits; FlagSet(T enumVal) { bits.set(enumVal); } }; enum MyFlags { FLAG_ONE, FLAG_TWO }; FlagSet<MyFlags, 2> myFlag;
template<typename T = typename std::enable_if<std::is_enum<T>::value, T>::type> class auto_bool { T val_; public: constexpr auto_bool(T val) : val_(val) {} constexpr operator T() const { return val_; } constexpr explicit operator bool() const { return static_cast<std::underlying_type_t<T>>(val_) != 0; } }; template <typename T = typename std::enable_if<std::is_enum<T>::value, T>::type> constexpr auto_bool<T> operator&(T lhs, T rhs) { return static_cast<T>( static_cast<typename std::underlying_type<T>::type>(lhs) & static_cast<typename std::underlying_type<T>::type>(rhs)); } template <typename T = typename std::enable_if<std::is_enum<T>::value, T>::type> constexpr T operator|(T lhs, T rhs) { return static_cast<T>( static_cast<typename std::underlying_type<T>::type>(lhs) | static_cast<typename std::underlying_type<T>::type>(rhs)); } enum class AnimalFlags : uint8_t { HasClaws = 1, CanFly = 2, EatsFish = 4, Endangered = 8 }; enum class PlantFlags : uint8_t { HasLeaves = 1, HasFlowers = 2, HasFruit = 4, HasThorns = 8 }; int main() { AnimalFlags seahawk = AnimalFlags::CanFly; AnimalFlags lion = AnimalFlags::HasClaws; PlantFlags rose = PlantFlags::HasFlowers; if (seahawk != lion) {} seahawk = seahawk | AnimalFlags::EatsFish; lion = AnimalFlags::HasClaws | AnimalFlags::Endangered; if (seahawk & AnimalFlags::CanFly) {} seahawk = seahawk & AnimalFlags::CanFly; return 0; }
enum AnimalFlags : unsigned int { HasClaws = 1, CanFly = 2, EatsFish = 4, Endangered = 8 }; constexpr AnimalFlags operator|(AnimalFlags X, AnimalFlags Y) { return static_cast<AnimalFlags>( static_cast<unsigned int>(X) | static_cast<unsigned int>(Y)); } AnimalFlags& operator|=(AnimalFlags& X, AnimalFlags Y) { X = X | Y; return X; }
AnimalFlags% operator|=(AnimalFlags% X, AnimalFlags Y) { X = X | Y; return X; }
template <typename TENUM> class FlagSet { private: using TUNDER = typename std::underlying_type<TENUM>::type; std::bitset<std::numeric_limits<TUNDER>::max()> m_flags; public: FlagSet() = default; template <typename... ARGS> FlagSet(TENUM f, ARGS... args) : FlagSet(args...) { set(f); } FlagSet& set(TENUM f) { m_flags.set(static_cast<TUNDER>(f)); return *this; } bool test(TENUM f) { return m_flags.test(static_cast<TUNDER>(f)); } FlagSet& operator|=(TENUM f) { return set(f); } };
FlagSet<Flags> flags{Flags::FLAG_A, Flags::FLAG_C}; flags |= Flags::FLAG_D;
enum AnimalFlag { HasClaws = 0, CanFly, EatsFish, Endangered }; class AnimalFlagSet { int m_Flags; public: AnimalFlagSet() : m_Flags(0) { } void Set( AnimalFlag flag ) { m_Flags |= (1 << flag); } void Clear( AnimalFlag flag ) { m_Flags &= ~ (1 << flag); } bool Get( AnimalFlag flag ) const { return (m_Flags >> flag) & 1; } };
struct AnimalProperties { bool HasClaws : 1; bool CanFly : 1; bool EatsFish : 1; bool Endangered : 1; }; union AnimalDescription { AnimalProperties Properties; int Flags; }; void TestUnionFlags() { AnimalDescription propertiesA; propertiesA.Properties.CanFly = true; AnimalDescription propertiesB = propertiesA; propertiesB.Properties.EatsFish = true; if( propertiesA.Flags == propertiesB.Flags ) { cout << "Life is terrible :("; } else { cout << "Life is great!"; } AnimalDescription propertiesC = propertiesA; if( propertiesA.Flags == propertiesC.Flags ) { cout << "Life is great!"; } else { cout << "Life is terrible :("; } }
class AnimalDefinition { public: static AnimalDefinition *GetAnimalDefinition( AnimalFlags flags ); static AnimalDefinition *GetAnimalDefinition( AnimalProperties properties ); static AnimalDefinition *GetAnimalDefinition( int flags ); AnimalFlags animalFlags; int flags; private: AnimalDescription m_description; }
enum AnimalFlags_ { HasClaws, CanFly, EatsFish, Endangered }; typedef FlagsEnum<AnimalFlags_> AnimalFlags; seahawk.flags = AnimalFlags() | CanFly | EatsFish | Endangered;
template <typename EnumType, typename Underlying = int> class FlagsEnum { typedef Underlying FlagsEnum::* RestrictedBool; public: FlagsEnum() : m_flags(Underlying()) {} FlagsEnum(EnumType singleFlag): m_flags(1 << singleFlag) {} FlagsEnum(const FlagsEnum& original): m_flags(original.m_flags) {} FlagsEnum& operator |=(const FlagsEnum& f) { m_flags |= f.m_flags; return *this; } FlagsEnum& operator &=(const FlagsEnum& f) { m_flags &= f.m_flags; return *this; } friend FlagsEnum operator |(const FlagsEnum& f1, const FlagsEnum& f2) { return FlagsEnum(f1) |= f2; } friend FlagsEnum operator &(const FlagsEnum& f1, const FlagsEnum& f2) { return FlagsEnum(f1) &= f2; } FlagsEnum operator ~() const { FlagsEnum result(*this); result.m_flags = ~result.m_flags; return result; } operator RestrictedBool() const { return m_flags ? &FlagsEnum::m_flags : 0; } Underlying value() const { return m_flags; } protected: Underlying m_flags; };
enum AnimalFlags { HasClaws = 1, CanFly =2, EatsFish = 4, Endangered = 8 }; int main(void) { AnimalFlags seahawk; seahawk= static_cast<AnimalFlags>(CanFly | EatsFish | Endangered); }
namespace EFoobar { enum { FB_A = 0x1, FB_B = 0x2, FB_C = 0x4, }; typedef long Flags; } void Foobar(EFoobar::Flags flags) { if (flags & EFoobar::FB_A) ; if (flags & EFoobar::FB_B) ; } void ExampleUsage() { Foobar(EFoobar::FB_A | EFoobar::FB_B); EFoobar::Flags otherflags = 0; otherflags|= EFoobar::FB_B; otherflags&= ~EFoobar::FB_B; Foobar(otherflags); }
enum class EFoobarFlags { FB_A = 1, FB_B, FB_C, }; void Foobar(const std::set<EFoobarFlags>& flags) { if (flags.find(EFoobarFlags::FB_A) != flags.end()) ; if (flags.find(EFoobarFlags::FB_B) != flags.end()) ; } void ExampleUsage() { Foobar({EFoobarFlags::FB_A, EFoobarFlags::FB_B}); std::set<EFoobarFlags> otherflags{}; otherflags.insert(EFoobarFlags::FB_B); otherflags.erase(EFoobarFlags::FB_B); Foobar(otherflags); }
enum class T1 : T2; \ inline T1 operator~ (T1 a) { return (T1)~(int)a; } \ inline T1 operator| (T1 a, T1 b) { return static_cast<T1>((static_cast<T2>(a) | static_cast<T2>(b))); } \ inline T1 operator& (T1 a, T1 b) { return static_cast<T1>((static_cast<T2>(a) & static_cast<T2>(b))); } \ inline T1 operator^ (T1 a, T1 b) { return static_cast<T1>((static_cast<T2>(a) ^ static_cast<T2>(b))); } \ inline T1& operator|= (T1& a, T1 b) { return reinterpret_cast<T1&>((reinterpret_cast<T2&>(a) |= static_cast<T2>(b))); } \ inline T1& operator&= (T1& a, T1 b) { return reinterpret_cast<T1&>((reinterpret_cast<T2&>(a) &= static_cast<T2>(b))); } \ inline T1& operator^= (T1& a, T1 b) { return reinterpret_cast<T1&>((reinterpret_cast<T2&>(a) ^= static_cast<T2>(b))); } \ enum class T1 : T2 ENUM(Options, short) { FIRST = 1 << 0, SECOND = 1 << 1, THIRD = 1 << 2, FOURTH = 1 << 3 }; auto options = Options::FIRST | Options::SECOND; options |= Options::THIRD; if ((options & Options::SECOND) == Options::SECOND) cout << "Contains second option." << endl; if ((options & Options::THIRD) == Options::THIRD) cout << "Contains third option." << endl; return 0;
template <typename Enum, typename std::enable_if_t<std::is_enum<Enum>::value, int> = 0> constexpr inline Enum& operator~ (Enum& val) { val = static_cast<Enum>(~static_cast<std::underlying_type_t<Enum>>(val)); return val; } template <typename Enum, typename std::enable_if_t<std::is_enum<Enum>::value, int> = 0> constexpr inline Enum operator& (Enum lhs, Enum rhs) { return static_cast<Enum>(static_cast<std::underlying_type_t<Enum>>(lhs) & static_cast<std::underlying_type_t<Enum>>(rhs)); } template <typename Enum, typename std::enable_if_t<std::is_enum<Enum>::value, int> = 0> constexpr inline Enum operator&= (Enum& lhs, Enum rhs) { lhs = static_cast<Enum>(static_cast<std::underlying_type_t<Enum>>(lhs) & static_cast<std::underlying_type_t<Enum>>(rhs)); return lhs; } template <typename Enum, typename std::enable_if_t<std::is_enum<Enum>::value, int> = 0> constexpr inline Enum operator| (Enum lhs, Enum rhs) { return static_cast<Enum>(static_cast<std::underlying_type_t<Enum>>(lhs) | static_cast<std::underlying_type_t<Enum>>(rhs)); } template <typename Enum, typename std::enable_if_t<std::is_enum<Enum>::value, int> = 0> constexpr inline Enum& operator|= (Enum& lhs, Enum rhs) { lhs = static_cast<Enum>(static_cast<std::underlying_type_t<Enum>>(lhs) | static_cast<std::underlying_type_t<Enum>>(rhs)); return lhs; }
template<typename T> class BitFlags { public: constexpr inline BitFlags() = default; constexpr inline BitFlags(T value) { mValue = value; } constexpr inline BitFlags operator| (T rhs) const { return mValue | rhs; } constexpr inline BitFlags operator& (T rhs) const { return mValue & rhs; } constexpr inline BitFlags operator~ () const { return ~mValue; } constexpr inline operator T() const { return mValue; } constexpr inline BitFlags& operator|=(T rhs) { mValue |= rhs; return *this; } constexpr inline BitFlags& operator&=(T rhs) { mValue &= rhs; return *this; } constexpr inline bool test(T rhs) const { return (mValue & rhs) == rhs; } constexpr inline void set(T rhs) { mValue |= rhs; } constexpr inline void clear(T rhs) { mValue &= ~rhs; } private: T mValue; };
void main() { enum class Options : uint32_t { NoOption = 0 << 0 , Option1 = 1 << 0 , Option2 = 1 << 1 , Option3 = 1 << 2 , Option4 = 1 << 3 }; const uint32_t Option1 = 1 << 0; const uint32_t Option2 = 1 << 1; const uint32_t Option3 = 1 << 2; const uint32_t Option4 = 1 << 3; BitFlags<Options> optionsEnum(Options::NoOption); optionsEnum.set(Options::Option1 | Options::Option3); BitFlags<uint32_t> optionsUint32(0); optionsUint32.set(Option1 | Option3); return 0; }
namespace UserRole { constexpr uint8_t dea = 1; constexpr uint8_t red = 2; constexpr uint8_t stu = 4; constexpr uint8_t kie = 8; constexpr uint8_t adm = 16; constexpr uint8_t mas = 32; }
class GrandParent; class Parent1 : public GrandParent; class Parent2 : public GrandParent; class Child : public Parent1, public Parent2;
class GrandParent; class Parent1 : public virtual GrandParent; class Parent2 : public virtual GrandParent; class Child : public Parent1, public Parent2;
class CounterMixin { int count; public: CounterMixin() : count( 0 ) {} virtual ~CounterMixin() {} virtual void increment() { count += 1; } virtual int getCount() { return count; } }; class Foo : public Bar, virtual public CounterMixin { ..... };
std::vector<int> A; std::vector<int> B; std::vector<int> AB;
AB.reserve( A.size() + B.size() ); AB.insert( AB.end(), A.begin(), A.end() ); AB.insert( AB.end(), B.begin(), B.end() );
std::vector<int> AB = A; AB.insert(AB.end(), B.begin(), B.end());
std::vector<int> v0; v0.push_back(1); v0.push_back(2); v0.push_back(3); std::vector<int> v1; v1.push_back(4); v1.push_back(5); v1.push_back(6); ... BOOST_FOREACH(const int & i, boost::join(v0, v1)){ cout << i << endl; }
template <typename T> std::vector<T> operator+(const std::vector<T> &A, const std::vector<T> &B) { std::vector<T> AB; AB.reserve( A.size() + B.size() ); AB.insert( AB.end(), A.begin(), A.end() ); AB.insert( AB.end(), B.begin(), B.end() ); return AB; } template <typename T> std::vector<T> &operator+=(std::vector<T> &A, const std::vector<T> &B) { A.reserve( A.size() + B.size() ); A.insert( A.end(), B.begin(), B.end() ); return A; }
copy(A.begin(),A.end(),std::back_inserter(AB)); copy(B.begin(),B.end(),std::back_inserter(AB));
template<template<typename, typename...> class Container, class T> std::string toString(const Container<T>& v) { std::stringstream ss; std::copy(v.begin(), v.end(), std::ostream_iterator<T>(ss, "")); return ss.str(); }; int main() { std::vector<int> A(10); std::vector<int> B(5); std::vector<int> AB(15); std::for_each(A.begin(), A.end(), [](int& f)->void { f = rand() % 100; }); std::cout << "before merge: " << toString(A) << "\n"; std::cout << "before merge: " << toString(B) << "\n"; merge(B.begin(),B.end(), begin(A), end(A), AB.begin(), [](int&,int&)->bool {}); std::cout << "after merge: " << toString(AB) << "\n"; return 1; }
set_union(A.begin(), A.end(), B.begin(), B.end(), AB.begin());
template <class T1, class T2> void ContainerInsert(T1 t1, T2 t2) { t1->insert(t1->end(), t2->begin(), t2->end()); }
false < false false < true true < false true < true
false < false = false false < true = true true < false = false true < true = false
const char * s(bool a) { return (a ? "true" : "false"); } void test(bool a, bool b) { std::cout << s(a) << " < " << s(b) << " = " << s(a < b) << std::endl; } int main(int argc, char* argv[]) { test(false, false); test(false, true); test(true, false); test(true, true); return 0; }
false < false false < true true < false true < true
false < false false < true true < false true < true
char data[0x1000]; std::ifstream in("file.bin"); while (in) { in.read(data, 0x1000); }
const int file_size=something; const int page_size=0x1000; int off=0; void *data; int fd = open("filename.bin", O_RDONLY); while (off < file_size) { data = mmap(NULL, page_size, PROT_READ, 0, fd, off); munmap(data, page_size); off += page_size; }
char data[0x1000]; std::ifstream in("file.bin"); while (in) { in.read(data, 0x1000); }
char data[0x1000]; std::ifstream iifle( "file.bin"); std::istream in( ifile.rdbuf() ); while( in ) { in.read( data, 0x1000); }
addr1 = NULL; while( size_left > 0 ) { r = min(MMAP_SIZE, size_left); addr2 = mmap(NULL, r, PROT_READ, MAP_FLAGS, 0, pos); if (addr1 != NULL) { feed_data(ctx, addr1, MMAP_SIZE); munmap(addr1, MMAP_SIZE); } addr1 = addr2; size_left -= r; pos += r; } feed_data(ctx, addr1, r); munmap(addr1, r);
int main() { int x = readNumber(); int y = readNumber(); writeAnswer(x + y); return(0); }
int readNumber() { int x; std::cout << "Number: "; std::cin >> x; return x; } void writeAnswer(int x) { std::cout << "Answer: "; std::cout << x; }
struct foo { void bar(); static constexpr char baz[] = "quz"; }; void foo::bar() { std::string str(baz); }
struct A { static constexpr int n = 5; }; constexpr int A::n;
struct foo { static constexpr auto& baz() { return "quz"; } }; auto sz = sizeof(foo::baz()); auto& foo_baz = foo::baz(); auto sz2 = sizeof(foo_baz); auto name = typeid(foo_baz).name();
C c = C(); assert(c.x == 0); C *pc = new C(); assert(pc->x == 0);
C c = {}; assert(c.x == 0); C d{}; assert(d.x == 0);
MyNonPodClass instance1; MyPodClass instance2; MyPodClass* instance3 = new MyPodClass; MyPodClass* instance3 = new MyPodClass() ;
struct A { int x; }; int a; A b; int main() { int c; int d = int(); A e; A f = A(); }
int buffer[BUFFER_SIZE]; read_into(buffer, BUFFER_SIZE);
int base_chance = 20; int current_chance = base_chance; int hit = generate_random_number(0, 100) + 1; if(hit < current_chance) { if(current_chance > base_chance) current_chance = base_chance; else current_chance *= 0.8; } else { if(current_chance < base_chance) current_chance = base_chance; else current_chance *= 1.1; }
int GetRand(int nSize) { return 1 + (::rand() % nSize); } int GetDice() { static int nPrevious=-1; while (1) { int nValue = GetRand(6); if (nValue==nPrevious && GetRand(100)<95) continue; nPrevious = nValue; return nValue; } }
if (randNumber <= .2 + progressiveChance ) { progressiveChance = 0; } else { progressiveChance += CHANCE_MODIFIER; }
IF turns_since_last_critical < M THEN critial = false turns_since_last_critical++; ELSE critial = IsCritical(chance); IF Critial THEN turns_since_last_critica = 0; ELSE turns_since_last_critica++; END IF; END IF;
c_h = c_h -1; if ( c_h == 0 ) { c_h = random(5) + 1 }
switch (numError) { case ERROR_01 : case ERROR_07 : case ERROR_0A : case ERROR_10 : case ERROR_15 : case ERROR_16 : case ERROR_20 : { fire_special_event(); } break; default: { } break; }
if ((ERROR_01 == numError) || (ERROR_07 == numError) || (ERROR_0A == numError) || (ERROR_10 == numError) || (ERROR_15 == numError) || (ERROR_16 == numError) || (ERROR_20 == numError)) { fire_special_event(); }
if (RequiresSpecialEvent(numError)) fire_special_event();
bool RequiresSpecialEvent(int numError) { return specialSet.find(numError) != specialSet.end(); }
extern const int MY_VALUE ; void doSomething(const int p_iValue) { switch(p_iValue) { case MY_VALUE : ; break ; default : ; break ; } }
const int MY_VALUE = 25 ; void doSomething(const int p_iValue) { switch(p_iValue) { case MY_VALUE : ; break ; default : ; break ; } }
errhandler_switch(errtype): cmpl $32, %edi ja .L5 movabsq $4301325442, %rax btq %rdi, %rax jc .L10 .L5: rep ret .L10: jmp fire_special_event()
errhandler_switch(errtype): leal -1(%rdi), %ecx cmpl $31, %ecx ja .L5 movl $1, %eax salq %cl, %rax testl $2150662721, %eax jne .L10 .L5: rep ret .L10: jmp fire_special_event()
cmpl $32, %edi ja .L5 mov $2150662721, %eax dec %edi bt %edi, %eax jc fire_special_event .L5: ret
unsigned int special_events[] = { ERROR_01, ERROR_07, ERROR_0A, ERROR_10, ERROR_15, ERROR_16, ERROR_20 }; int special_events_length = sizeof (special_events) / sizeof (unsigned int); void process_event(unsigned int numError) { for (int i = 0; i < special_events_length; i++) { if (numError == special_events[i]) { fire_special_event(); break; } } }
special_events = [ ERROR_01, ERROR_07, ERROR_0A, ERROR_10, ERROR_15, ERROR_16, ERROR_20, ] def process_event(numError): if numError in special_events: fire_special_event()
switch(numerror){ ERROR_20 : { fire_special_event(); } break; default : { null; } break; }
public class SwitchTest { static final int max = 100000; public static void main(String[] args) { int counter1 = 0; long start1 = 0l; long total1 = 0l; int counter2 = 0; long start2 = 0l; long total2 = 0l; boolean loop = true; start1 = System.currentTimeMillis(); while (true) { if (counter1 == max) { break; } else { counter1++; } } total1 = System.currentTimeMillis() - start1; start2 = System.currentTimeMillis(); while (loop) { switch (counter2) { case max: loop = false; break; default: counter2++; } } total2 = System.currentTimeMillis() - start2; System.out.println("While if/else: " + total1 + "ms"); System.out.println("Switch: " + total2 + "ms"); System.out.println("Max Loops: " + max); System.exit(0); } }
`int a; cout<<"enter value:\n"; cin>>a; if( a > 0 && a < 5) { cout<<"a is between 0, 5\n"; }else if(a > 5 && a < 10) cout<<"a is between 5,10\n"; }else{ "a is not an integer, or is not in range 0,10\n";
`int a; cout<<"enter value:\n"; cin>>a; switch(a) { case 0: case 1: case 2: case 3: case 4: case 5: cout<<"a is between 0,5 and equals: "<<a<<"\n"; break; default: cout<<"a is not between the range or is not a good value\n" break;
template <typename F> float calc1(F f) { return -1.0f * f(3.3f) + 666.0f; } float calc2(std::function<float(float)> f) { return -1.0f * f(3.3f) + 666.0f; } int main() { using namespace std::chrono; const auto tp1 = system_clock::now(); for (int i = 0; i < 1e8; ++i) { calc1([](float arg){ return arg * 0.5f; }); } const auto tp2 = high_resolution_clock::now(); const auto d = duration_cast<milliseconds>(tp2 - tp1); std::cout << d.count() << std::endl; return 0; }
for (int i = 0; i < 1e8; ++i) { } calc1([](float arg){ return arg * 0.5f; });
float a, b, c; calc2([a,b,c](float arg){ return arg * 0.5f; });
auto func = [a,b,c](float arg){ return arg * 0.5f; }; calc2(std::cref(func));
float result=0; for (int i = 0; i < 1e8; ++i) { result+=calc2([](float arg){ return arg * 0.5f; }); }
clang: calc1: 1.4 seconds clang: calc2: 1.4 seconds (identical binary) gcc 4.7.2: calc1: 1.1 seconds gcc 4.7.2: calc2: 6.0 seconds VS2012 CTPNov calc1: 0.8 seconds VS2012 CTPNov calc2: 2.0 seconds VS2015 (14.0.23.107) calc1: 1.1 seconds VS2015 (14.0.23.107) calc2: 1.5 seconds MinGW (4.7.2) calc1: 0.9 seconds MinGW (4.7.2) calc2: 20.5 seconds
template <typename F> float calc1(F f, float x) { return 1.0f + 0.002*x+f(x*1.223) ; } float calc2(std::function<float(float)> f,float x) { return 1.0f + 0.002*x+f(x*1.223) ; } int main() { using namespace std::chrono; const auto tp1 = high_resolution_clock::now(); float result=0; for (int i = 0; i < 1e8; ++i) { result=calc1([](float arg){ return arg * 0.5f; },result); } const auto tp2 = high_resolution_clock::now(); const auto d = duration_cast<milliseconds>(tp2 - tp1); std::cout << d.count() << std::endl; std::cout << result<< std::endl; return 0; }
void eval(const std::function<int(int)>& f) { std::cout << f(3); } int f1(int i) { return i; } float f2(double d) { return d; } int main() { std::function<int(int)> fun(f1); eval(fun); fun = f2; eval(fun); return 0; }
float func_half( float x ) { return x * 0.5; } float mul_by( float x, float scale ) { return x * scale; } // // float test_stdfunc( std::function<float(float)> const & func, int nloops ) { float x = 1.0; float y = 0.0; for(int i =0; i < nloops; i++ ){ y += x; x = func(x); } return y; } float test_funcptr( float (*func)(float), int nloops ) { float x = 1.0; float y = 0.0; for(int i =0; i < nloops; i++ ){ y += x; x = func(x); } return y; } float test_inline( int nloops ) { float x = 1.0; float y = 0.0; for(int i =0; i < nloops; i++ ){ y += x; x = func_half(x); } return y; }
extern float func_half( float x ); extern float mul_by( float x, float scale ); extern float test_inline( int nloops ); extern float test_stdfunc( std::function<float(float)> const & func, int nloops ); extern float test_funcptr( float (*func)(float), int nloops ); int main() { using namespace std::chrono; for(int icase = 0; icase < 4; icase ++ ){ const auto tp1 = system_clock::now(); float result; switch( icase ){ case 0: result = test_inline( 1e9); break; case 1: result = test_funcptr( func_half, 1e9); break; case 2: result = test_stdfunc( func_half, 1e9); break; case 3: result = test_stdfunc( std::bind( mul_by, std::placeholders::_1, 0.5), 1e9); break; } const auto tp2 = high_resolution_clock::now(); const auto d = duration_cast<milliseconds>(tp2 - tp1); std::cout << d.count() << std::endl; std::cout << result<< std::endl; } return 0; }
movq (%rdi), %rax ; get the std::func data movsd 8(%rax), %xmm1 ; get the bound value (0.5) movq (%rax), %rdx ; get the function to call (mul_by) cvtpd2ps %xmm1, %xmm1 ; convert 0.5 to 0.5f jmp *%rdx ; jump to the func
movl $16, %edi movq $0, 32(%rsp) call operator new(unsigned long) ; get 16 bytes for std::function movsd .LC0(%rip), %xmm1 ; get 0.5 leaq 16(%rsp), %rdi ; (1st parm to test_stdfunc) movq mul_by(float, float), (%rax) ; store &mul_by in std::function movl $1000000000, %esi ; (2nd parm to test_stdfunc) movsd %xmm1, 8(%rax) ; store 0.5 in std::function movq %rax, 16(%rsp) ; save ptr to allocated mem ;; the next two ops store pointers to generated code related to the std::function. ;; the first one points to the adaptor I showed above. movq std::_Function_handler<float (float), std::_Bind<float (*(std::_Placeholder<1>, double))(float, float)> >::_M_invoke(std::_Any_data const&, float), 40(%rsp) movq std::_Function_base::_Base_manager<std::_Bind<float (*(std::_Placeholder<1>, double))(float, float)> >::_M_manager(std::_Any_data&, std::_Any_data const&, std::_Manager_operation), 32(%rsp) call test_stdfunc(std::function<float (float)> const&, int)
template <typename F> float calc1(F f, float i) { return -1.0f * f(i) + 666.0f; } float calc2(std::function<float(float)> f, float i) { return -1.0f * f(i) + 666.0f; } int main() { const auto tp1 = system_clock::now(); for (int i = 0; i < 1e8; ++i) { t += calc2([&](float arg){ return arg * 0.5f + t; }, i); } const auto tp2 = high_resolution_clock::now(); }
.L34: cvtsi2ss %edx, %xmm0 addl $1, %edx movaps %xmm3, %xmm5 mulss %xmm4, %xmm0 addss %xmm1, %xmm0 subss %xmm0, %xmm5 movaps %xmm5, %xmm0 addss %xmm1, %xmm0 cvtsi2sd %edx, %xmm1 ucomisd %xmm1, %xmm2 ja .L37 movss %xmm0, 16(%rsp)
float calc3(float i) { return -1.0f * f2(i) + 666.0f; } std::function<float(float)> f2 = [](float arg){ return arg * 0.5f; }; int main() { const auto tp1 = system_clock::now(); for (int i = 0; i < 1e8; ++i) { t += calc3([&](float arg){ return arg * 0.5f + t; }, i); } const auto tp2 = high_resolution_clock::now(); }
int my_array[5] = {1, 2, 3, 4, 5}; for(int &x : my_array) { x *= 2; }
range based for loops are not allowed in c++ 98 mode
greaterThan(QT_MAJOR_VERSION, 4){ CONFIG += c++11 } else { QMAKE_CXXFLAGS += -std=c++0x }
QMAKE_CXXFLAGS+= -std=c++11 QMAKE_LFLAGS += -std=c++11
QMAKE_CFLAGS += -fno-keep-inline-dllexport -std=c++11
template <class T> class X{...}; class A : public X<A> {...};
template <class ActualClass> class Singleton { public: static ActualClass& GetInstance() { if(p == nullptr) p = new ActualClass; return *p; } protected: static ActualClass* p; private: Singleton(){} Singleton(Singleton const &); Singleton& operator = (Singleton const &); }; template <class T> T* Singleton<T>::p = nullptr;
template<class Derived> class Equality { }; template <class Derived> bool operator == (Equality<Derived> const& op1, Equality<Derived> const & op2) { Derived const& d1 = static_cast<Derived const&>(op1); Derived const& d2 = static_cast<Derived const&>(op2); return !(d1 < d2) && !(d2 < d1); }
struct Apple:public Equality<Apple> { int size; }; bool operator < (Apple const & a1, Apple const& a2) { return a1.size < a2.size; }
int main() { Apple a1; Apple a2; a1.size = 10; a2.size = 10; if(a1 == a2) { } }
template <class T> class Writer { public: Writer() { } ~Writer() { } void write(const char* str) const { static_cast<const T*>(this)->writeImpl(str); } }; class FileWriter : public Writer<FileWriter> { public: FileWriter(FILE* aFile) { mFile = aFile; } ~FileWriter() { fclose(mFile); } void writeImpl(const char* str) const { fprintf(mFile, "%s\n", str); } private: FILE* mFile; }; class ConsoleWriter : public Writer<ConsoleWriter> { public: ConsoleWriter() { } ~ConsoleWriter() { } void writeImpl(const char* str) const { printf("%s\n", str); } };
template <typename T> struct Base { void foo() { (static_cast<T*>(this))->foo(); } }; struct Derived : public Base<Derived> { void foo() { cout << "derived foo" << endl; } }; struct AnotherDerived : public Base<AnotherDerived> { void foo() { cout << "AnotherDerived foo" << endl; } }; template<typename T> void ProcessFoo(Base<T>* b) { b->foo(); } int main() { Derived d1; AnotherDerived d2; ProcessFoo(&d1); ProcessFoo(&d2); return 0; }
template <typename T> class Base { public: void method() { static_cast<T*>(this)->method(); } }; class Derived1 : public Base<Derived1> { public: void method() { std::cout << "Derived1 method" << std::endl; } }; class Derived2 : public Base<Derived2> { public: void method() { std::cout << "Derived2 method" << std::endl; } }; int main() { Derived1 d1; Derived2 d2; d1.method(); d2.method(); return 0; }
struct Node; void process_node(const std::shared_ptr<Node> &); struct Node : std::enable_shared_from_this<Node> { std::weak_ptr<Node> parent; std::vector<std::shared_ptr<Node>> children; void add_child(std::shared_ptr<Node> child) { process_node(shared_from_this()); child->parent = weak_from_this(); children.push_back(std::move(child)); } };
struct S { std::shared_ptr<S> get_shared() const { return std::shared_ptr<S>(this); } }; std::shared_ptr<S> s1 = std::make_shared<S>(); std::shared_ptr<S> s2 = s1->get_shared(); assert(s2.use_count() == 1);
class Interface { virtual void doSomething() = 0; }; class Derived : public Interface { Derived(); ~Derived() { } }; void myFunc(void) { Interface* p = new Derived(); delete p; }
class IFoo { public: virtual void DoFoo() = 0; }; class Bar : public IFoo { char* dooby = NULL; public: virtual void DoFoo() { dooby = new char[10]; } void ~Bar() { delete [] dooby; } }; IFoo* baz = new Bar(); baz->DoFoo(); delete baz;
class window { window(const rectangle& rect); private: class window_impl; std::unique_ptr<window_impl> impl_; };
class foo { class impl; std::unique_ptr<impl> impl_; public: foo(); ~foo(); };
class impl; struct ptr_impl : std::unique_ptr<impl> { ~ptr_impl(); } impl_;
class FooImpl; struct FooImplDeleter { void operator()(FooImpl *p); } class Foo { ... private: std::unique_ptr<FooImpl, FooImplDeleter> impl_; }; ... void FooImplDeleter::operator()(FooImpl *p) { delete p; }
class foo { struct pimpl; struct pimpl_deleter { void operator()(pimpl*) const; }; std::unique_ptr<pimpl,pimpl_deleter> m_pimpl; public: foo(some data); foo(foo&&) = default; foo&operator=(foo&&) = default; }; struct foo::pimpl { }; void foo::pimpl_deleter::operator()(foo::pimpl*ptr) const { delete ptr; }
class foo { struct pimpl; static void delete_pimpl(pimpl*); std::unique_ptr<pimpl,[](pimpl*ptr){delete_pimpl(ptr);}> m_pimpl; };
/** Helper to define a `std::unique_ptr` that works just with a forward declaration The "regular" `std::unique_ptr<T>` requires the full definition of `T` to be available, as it has to emit calls to `delete` in every TU that may use it. A workaround to this problem is to have a `std::unique_ptr` with a custom deleter, which is defined in a TU that knows the full definition of `T`. This header standardizes and generalizes this trick. The usage is quite simple: - everywhere you would have used `std::unique_ptr<T>`, use `czu::unique_opaque<T>`; it will work just fine with `T` being a forward declaration; - in a TU that knows the full definition of `T`, at top level invoke the macro `CZU_DEFINE_OPAQUE_DELETER`; it will define the custom deleter used by `czu::unique_opaque<T>` */ namespace czu { template<typename T> struct opaque_deleter { void operator()(T *it) { void opaque_deleter_hook(T *); opaque_deleter_hook(it); } }; template<typename T> using unique_opaque = std::unique_ptr<T, opaque_deleter<T>>; }
bool myclass::do_work123(<unknown long Color>int& Filled*&, long, int&)
unsigned mult (unsigned x, unsigned y) { return x*y; } mult(unsigned int, unsigned int): mov eax, edi imul eax, esi ret
struct pair { unsigned x : 31; unsigned y : 31; }; unsigned mult (pair p) { return p.x*p.y; } mult(pair): mov eax, edi shr rdi, 32 and eax, 2147483647 and edi, 2147483647 imul eax, edi ret
| xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | ...
int foo() { int bar = 1; int baz = 42; return bar+baz; }
void gen_random(char *s, const int len) { static const char alphanum[] = "0123456789" "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz"; for (int i = 0; i < len; ++i) { s[i] = alphanum[rand() % (sizeof(alphanum) - 1)]; } s[len] = 0; }
std::string random_string( size_t length ) { auto randchar = []() -> char { const char charset[] = "0123456789" "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz"; const size_t max_index = (sizeof(charset) - 1); return charset[ rand() % max_index ]; }; std::string str(length,0); std::generate_n( str.begin(), length, randchar ); return str; }
typedef std::vector<char> char_array; char_array charset() { return char_array( { }); }; std::string random_string( size_t length, std::function<char(void)> rand_char ) { std::string str(length,0); std::generate_n( str.begin(), length, rand_char ); return str; } int main() { const auto ch_set = charset(); std::default_random_engine rng(std::random_device{}()); std::uniform_int_distribution<> dist(0, ch_set.size()-1); auto randchar = [ ch_set,&dist,&rng ](){return ch_set[ dist(rng) ];}; auto length = 5; std::cout<<random_string(length,randchar)<<std::endl; return 0; }
std::string random_string(std::string::size_type length) { static auto& chrs = "0123456789" "abcdefghijklmnopqrstuvwxyz" "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; thread_local static std::mt19937 rg{std::random_device{}()}; thread_local static std::uniform_int_distribution<std::string::size_type> pick(0, sizeof(chrs) - 2); std::string s; s.reserve(length); while(length--) s += chrs[pick(rg)]; return s; }
void gen_random(char *s, size_t len) { for (size_t i = 0; i < len; ++i) { int randomChar = rand()%(26+26+10); if (randomChar < 26) s[i] = else if (randomChar < 26+26) s[i] = else s[i] = } s[len] = 0; }
struct rnd_gen { rnd_gen(char const* range = "abcdefghijklmnopqrstuvwxyz0123456789") : range(range), len(std::strlen(range)) { } char operator ()() const { return range[static_cast<std::size_t>(std::rand() * (1.0 / (RAND_MAX + 1.0 )) * len)]; } private: char const* range; std::size_t len; }; std::generate_n(s, len, rnd_gen()); s[len] =
char rand_alnum() { char c; while (!std::isalnum(c = static_cast<char>(std::rand()))) ; return c; } std::string rand_alnum_str (std::string::size_type sz) { std::string s; s.reserve (sz); generate_n (std::back_inserter(s), sz, rand_alnum); return s; }
using namespace std; string RandomString(int len) { srand(time(0)); string str = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; string newstr; int pos; while(newstr.size() != len) { pos = ((rand() % (str.size() - 1))); newstr += str.substr(pos,1); } return newstr; } int main() { string random_str = RandomString(100); cout << "random_str : " << random_str << endl; }
void gen_random(char *s, int l) { for (int c; c=rand()%62, *s++ = (c+"07="[(c+16)/26])*(l-->0);); }
void randomString(int size, char* output) { srand(time(NULL)); char src[size]; size = rand() % size; src[size] = while(--size > -1) src[size] = (rand() % 94) + 32; strcpy(output, src); }
auto randchar = []() -> char { const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz"; const size_t max_index = (sizeof(charset) - 1); return charset[randomGenerator(0, max_index)]; }; std::string custom_string; size_t LENGTH_NAME = 6 generate_n(custom_string.begin(), LENGTH_NAME, randchar);
QString random_string(int length=32, QString allow_symbols=QString("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")) { QString result; qsrand(QTime::currentTime().msec()); for (int i = 0; i < length; ++i) { result.append(allow_symbols.at(qrand() % (allow_symbols.length()))); } return result; }
template<size_t N> void genRandomString(char (&buffer)[N]) { std::random_device rd; const char alphanumeric[] = { "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" }; std::mt19937 eng(rd()); std::uniform_int_distribution<> distr(0, 61); for (auto& c : buffer) c = alphanumeric[distr(eng)]; buffer[N] = } int main() { char buffer[100]; genRandomString(buffer); std::cout << buffer << return 0; }
std::string generateRandomId(size_t length = 0) { static const std::string allowed_chars {"123456789BCDFGHJKLMNPQRSTVWXZbcdfghjklmnpqrstvwxz"}; static thread_local std::default_random_engine randomEngine(std::random_device{}()); static thread_local std::uniform_int_distribution<int> randomDistribution(0, allowed_chars.size() - 1); std::string id(length ? length : 32, for (std::string::value_type& c : id) { c = allowed_chars[randomDistribution(randomEngine)]; } return id; } int main() { std::cout << generateRandomId() << std::endl; }
int main() { int size; std::cout << "Enter size : "; std::cin >> size; std::string str; for (int i = 0; i < size; i++) { auto d = rand() % 26 + str.push_back(d); } for (int i = 0; i < size; i++) { std::cout << str[i] << } return 0; }
class Randomer { std::mt19937 gen_; std::uniform_int_distribution<size_t> dist_; public: Randomer(size_t min, size_t max, unsigned int seed = std::random_device{}()) : gen_{seed}, dist_{min, max} { } void SetSeed(unsigned int seed) { gen_.seed(seed); } size_t operator()() { return dist_(gen_); } };
std::string GenerateString(size_t len) { std::string str; auto rand_char = [](){ return alphabet[randomer()]; }; std::generate_n(std::back_inserter(str), len, rand_char); return str; }
string gen_random(const int len) { static const char alphanum[] = "0123456789" "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; stringstream ss; for (int i = 0; i < len; ++i) { ss << alphanum[rand() % (sizeof(alphanum) - 1)]; } return ss.str(); }
void SerialNumberGenerator() { srand(time(NULL)); for (int i = 0; i < 5; i++) { cout << gen_random(10) << endl; } }
void strGetRandomAlphaNum(char *sStr, unsigned int iLen) { char Syms[] = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; unsigned int Ind = 0; srand(time(NULL) + rand()); while(Ind < iLen) { sStr[Ind++] = Syms[rand()%62]; } sStr[iLen] = }
void raise(); void f(int y) { int x = y!=0 ? 100/y : raise(); cout << x << endl; }
void f(int y) { int x = y!=0 ? 100/y : throw exception(); cout << x << endl; }
noreturn raise() { throw exception(); } ... int x = y!=0 ? 100/y : raise();
int f(bool b){ if (b) { return 7; } else { abort(); } }
class A { char *someHeapMemory; public: A() : someHeapMemory(new char[1000]) {} ~A() { delete[] someHeapMemory; } }; class B { A* APtr; public: B() : APtr(new A()) {} ~B() { delete APtr; } }; class C { A Amember; public: C() : Amember() {} ~C() {} }; int main() { B* BPtr = new B(); delete BPtr; C *CPtr = new C(); delete CPtr; B b; C c; }
class A { shared_array<char> someHeapMemory; public: A() : someHeapMemory(new char[1000]) {} ~A() { } }; class B { shared_ptr<A> APtr; public: B() : APtr(new A()) {} ~B() { } }; int main() { shared_ptr<B> BPtr = new B(); }
struct A {} class B { A *a; public: B () : a (new A) {} ~B() { delete a; } }; class C { A *a; public: C () : a (new A) {} }; int main () { delete new B; delete new C; }
class B { public: B() { p = new int[1024]; } virtual ~B() { cout<<"B destructor"<<endl; } int *p; }; class D : public B { public: virtual ~D() { cout<<"D destructor"<<endl; } };
class A { public: A(){}; ~A(); }; A::~A() { std::cout << "Destructor of A" << std::endl; } class B { public: B(){ptr = new A();}; ~B(); private: A* ptr; }; B::~B() { delete ptr; std::cout << "Destructor of B" << std::endl; } int main() { B* b = new B(); delete b; return 0; }
long long ll; int long long ill; long int long lil; long long int lli;
long long* llp; int long long* illp; long int long* lilp; long long int* llip;
constexpr long static long const int signed x = 10;
const long const long static const int const signed x = 10;
Specifier(s) Type ... ... long long int “long long int” long long “long long int” long int “long int” long “long int” ... ...
long long long long int long int long int long long
class base { public: virtual int foo(float x) = 0; }; class derived: public base { public: int foo(float x) override { ... do stuff with x and such ... } } class derived2: public base { public: int foo(int x) override { ... } };
struct base { virtual void foo() = 0; }; struct derived : base { virtual void foo() override { std::cout << __PRETTY_FUNCTION__ << std::endl; } }; int main() { base* override = new derived(); override->foo(); return 0; }
zaufi@gentop /work/tests $ g++ -std=c++11 -o override-test override-test.cc zaufi@gentop /work/tests $ ./override-test virtual void derived::foo()
class Foo { public: virtual void func1(); } class Bar : public Foo { public: void func1() override; }
using DecisionFn = bool(*)(); class Decide { public: Decide(DecisionFn dec) : _dec{dec} {} private: DecisionFn _dec; }; int main() { int x = 5; Decide greaterThanThree{ [x](){ return x > 3; } }; return 0; }
typedef bool(*DecisionFn)(int); Decide greaterThanThree{ []( int x ){ return x > 3; } };
typedef bool(*DecisionFn)(); Decide greaterThanThree{ [](){ return true ; } };
struct Decide { using DecisionFn = std::function<bool()>; Decide(DecisionFn dec) : dec_ {std::move(dec)} {} DecisionFn dec_; }; int main() { int x = 5; Decide greaterThanThree { [x](){ return x > 3; } }; }
int main() { int x = 5; Decide greaterThanThree { (x > 3) ? [](){ return true; } : [](){ return false; } }; }
int first = 5; auto lambda = [=](int x, int z) { return x + z + first; }; int(decltype(lambda)::*ptr)(int, int)const = &decltype(lambda)::operator(); std::cout << "test = " << (lambda.*ptr)(2, 3) << std::endl;
template<typename OT, typename RT, typename ... A> struct lambda_expression { OT _object; RT(OT::*_function)(A...)const; lambda_expression(const OT & object) : _object(object), _function(&decltype(_object)::operator()) {} RT operator() (A ... args) const { return (_object.*_function)(args...); } };
auto capture_lambda() { int first = 5; auto lambda = [=](int x, int z) { return x + z + first; }; return lambda_expression<decltype(lambda), int, int, int>(lambda); } auto noncapture_lambda() { auto lambda = [](int x, int z) { return x + z; }; return lambda_expression<decltype(lambda), int, int, int>(lambda); } void refcapture_lambda() { int test; auto lambda = [&](int x, int z) { test = x + z; }; lambda_expression<decltype(lambda), void, int, int>f(lambda); f(2, 3); std::cout << "test value = " << test << std::endl; } int main(int argc, char **argv) { auto f_capture = capture_lambda(); auto f_noncapture = noncapture_lambda(); std::cout << "main test = " << f_capture(2, 3) << std::endl; std::cout << "main test = " << f_noncapture(2, 3) << std::endl; refcapture_lambda(); system("PAUSE"); return 0; }
template <typename CT, typename ... A> struct function : public function<decltype(&CT::operator())(A...)> {}; template <typename C> struct function<C> { private: C mObject; public: function(const C & obj) : mObject(obj) {} template<typename... Args> typename std::result_of<C(Args...)>::type operator()(Args... a) { return this->mObject.operator()(a...); } template<typename... Args> typename std::result_of<const C(Args...)>::type operator()(Args... a) const { return this->mObject.operator()(a...); } }; namespace make { template<typename C> auto function(const C & obj) { return ::function<C>(obj); } } int main(int argc, char ** argv) { auto func = make::function([](int y, int x) { return x*y; }); std::cout << func(2, 4) << std::endl; system("PAUSE"); return 0; }
static Callable callable; static bool wrapper() { return callable(); }
template<typename Callable> union storage { storage() {} std::decay_t<Callable> callable; }; template<int, typename Callable, typename Ret, typename... Args> auto fnptr_(Callable&& c, Ret (*)(Args...)) { static bool used = false; static storage<Callable> s; using type = decltype(s.callable); if(used) s.callable.~type(); new (&s.callable) type(std::forward<Callable>(c)); used = true; return [](Args... args) -> Ret { return Ret(s.callable(std::forward<Args>(args)...)); }; } template<typename Fn, int N = 0, typename Callable> Fn* fnptr(Callable&& c) { return fnptr_<N>(std::forward<Callable>(c), (Fn*)nullptr); }
void foo(void (*fn)()) { fn(); } int main() { int i = 42; auto fn = fnptr<void()>([i]{std::cout << i;}); foo(fn); }
std::function<void()> func1, func2; auto fn1 = fnptr<void(), 1>(func1); auto fn2 = fnptr<void(), 2>(func2);
extern "C" void UT(void(*)(double*,double*,double*),double*,double*,double*, double*,double*,double*,int*); static void rk_ut(void(*)(double*,double*,double*),double*,double*,double*, double*,double*,double*,int*); mathlib::RungeKuttaSolver::rk_ut([](double* T,double* Y,double* YP)->void{YP[0]=Y[1]; YP[1]= -Y[0];}, TWANT,T,Y,YP,YMAX,WORK,UFLAG);
using namespace std; int main() { timespec time1, time2; int temp; clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &time1); clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &time2); return 0; }
+* The `clock_* + directly in the main C library. Previously it was necessary to link with + -lrt to use these functions. This change has the effect that a + single-threaded program that uses a function such as `clock_gettime + is not linked with -lrt) will no longer implicitly load the pthreads + library at runtime and so will not suffer the overheads associated with + multi-thread support in other code such as the C++ runtime library.
class A { public: virtual void f() = 0; }; void A::f() { cout<<"Test"<<endl; }
class B : public A { virtual void f() { A::f(); } };
class Base { public: virtual ~Base() = 0; }; Base::~Base() {} class Derived : public Base {}; int main() { Derived d; }
class A { public: virtual void foo()=0; virtual void bar(); } class B : public virtual A { public: void foo() { bar(); } } class C : public virtual A { public: void bar(); } class D : public B, public C {} int main(int argc, const char* argv[]) { A* obj = new D(); **obj->foo();** return 0; }
using SerialBuffer = vector< unsigned char >; SerialBuffer read( size_t size ) const { SerialBuffer buffer( size ); read( begin( buffer ), end( buffer ) ); return buffer; } SerialBuffer read( size_t size ) const { SerialBuffer buffer( size ); read( begin( buffer ), end( buffer ) ); return move( buffer ); }
Foo f() { Foo result; mangle(result); return result; }
class Thing { public: Thing(); ~Thing(); Thing(const Thing&); }; Thing f() { Thing t; return t; } Thing t2 = f();
Buffer read(Buffer&& buffer) { return std::move( buffer ); }
public Thing calculateThing() { Thing thing = new Thing(); return thing; }
Thing* calculateThing() { Thing* thing(new Thing()); return thing; }
Thing calculateThing() { Thing thing; return thing; }
Thing calculateThing() { Thing thing(); return thing; }
std::auto_ptr<Thing> calculateThing() { std::auto_ptr<Thing> thing(new Thing); return thing; } { std::auto_ptr<Thing> thing = calculateThing(); }
MyClass::MyClass(const MyClass &other) { std::cout << "Copy constructor was called" << std::endl; } MyClass someFunction() { MyClass dummy; return dummy; }
class MyClass { public: MyClass(); virtual void DoSomething(); private: int x; };
using namespace std; extern "C" MyClass* create_object() { return new MyClass; } extern "C" void destroy_object( MyClass* object ) { delete object; } MyClass::MyClass() { x = 20; } void MyClass::DoSomething() { cout<<x<<endl; }
using namespace std; int main(int argc, char **argv) { /* on Linux, use "./myclass.so" */ void* handle = dlopen("myclass.so", RTLD_LAZY); MyClass* (*create)(); void (*destroy)(MyClass*); create = (MyClass* (*)())dlsym(handle, "create_object"); destroy = (void (*)(MyClass*))dlsym(handle, "destroy_object"); MyClass* myClass = (MyClass*)create(); myClass->DoSomething(); destroy( myClass ); }
g++ -dynamiclib -flat_namespace myclass.cc -o myclass.so g++ class_user.cc -o class_user
g++ -fPIC -shared myclass.cc -o myclass.so g++ class_user.cc -ldl -o class_user
class myclass { int myx; public: myclass() { myx=0; } void setx(int newx); int getx(); };
void myclass::setx(int newx) { myx = newx; } int myclass::getx() { return myx; }
using namespace std; int main(int argc, char *argv[]) { myclass m; cout << m.getx() << endl; m.setx(10); cout << m.getx() << endl; }
main: libshared.so main.o $(CXX) -o main main.o -L. -lshared libshared.so: shared.cpp $(CXX) -fPIC -c shared.cpp -o shared.o $(CXX) -shared -Wl,-soname,libshared.so -o libshared.so shared.o clean: $rm *.o *.so
~/prj/test/shared$ LD_LIBRARY_PATH=. ldd main linux-gate.so.1 => (0xb7f88000) libshared.so => ./libshared.so (0xb7f85000) libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0xb7e74000) libm.so.6 => /lib/libm.so.6 (0xb7e4e000) libgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0xb7e41000) libc.so.6 => /lib/libc.so.6 (0xb7cfa000) /lib/ld-linux.so.2 (0xb7f89000)
using namespace std; class Sandbox { public: Sandbox(const string& n) : member(n) {} const string& member; }; int main() { Sandbox sandbox(string("four")); cout << "The answer is: " << sandbox.member << endl; return 0; }
int main() { string temp = string("four"); Sandbox sandbox(temp); cout << sandbox.member << endl; return 0; }
using namespace std; class Sandbox { public: const string member = " "; Sandbox(const string& n) : member(n) {} }; int main() { Sandbox sandbox(string("four")); cout << "The answer is: " << sandbox.member << endl; return 0; }
int puts(const char *); int main() { puts("Hello, world!"); }
int eighty_four() { return 84; } int output_result(int callback()) { printf("Returned: %d\n", callback()); return 0; } int main() { return output_result(eighty_four); }
<stdin>:1:19: error: expected declaration specifiers or ‘...’ before ‘(’ token
<stdin>:2:36: error: invalid conversion from ‘char’ to ‘const char*’ [-fpermissive] In file included from /usr/include/c++/4.8/string:53:0, from <stdin>:1: /usr/include/c++/4.8/bits/basic_string.tcc:212:5: error: initializing argument 1 of ‘std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’ [-fpermissive] basic_string<_CharT, _Traits, _Alloc>:: ^
if(some condition) { int a[3]; fill_it(a); print_it(a); }
string globalA; int main() { foo(); foo(); } void foo() { static string localA; localA += "ab" cout << localA; }
class A { static string classScopeA; }; string A::classScopeA; A a, b; &a.classScopeA == &b.classScopeA == &A::classScopeA;
int main() { string *s = new string; foo(s); delete s; } void foo(string *s) { cout << s->size(); }
int main() { shared_ptr<string> s(new string); foo(s); } void foo(shared_ptr<string> s) { cout << s->size(); }
namespace Company { namespace Communications { namespace Sockets { } } }
identifier: identifier-nondigit identifier identifier-nondigit identifier digit identifier-nondigit: nondigit universal-character-name nondigit: one of a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ digit: one of 0 1 2 3 4 5 6 7 8 9
source.cpp(1) windows.h(100) winsock.h some_other_thing.h(1234) winsock2.h
int + float = ? int * float = ? float * int = ? int / float = ? float / int = ? int / int = ? int ^ float = ?
If either is long double the other is promoted to long double If either is double the other is promoted to double If either is float the other is promoted to float If either is long long unsigned int the other is promoted to long long unsigned int If either is long long int the other is promoted to long long int If either is long unsigned int the other is promoted to long unsigned int If either is long int the other is promoted to long int If either is unsigned int the other is promoted to unsigned int If either is int the other is promoted to int Both operands are promoted to int
int + float => float + float = float int * float => float * float = float float * int => float * float = float int / float => float / float = float float / int => float / float = float int / int = int int ^ float => <compiler error>
int + float = float int * float = float float * int = float int / float = float float / int = float int / int = int
int i = 3, j = 2; double k = 33; cout << k * j / i << endl; cout << j / i * k << endl;
template<typename T> T max (T a, T b) { return b < a ? a : b; }
template<class T> constexpr const T& max(const T& a, const T& b);
struct X { int a; int b; }; bool operator< (X lhs, X rhs) { return lhs.a < rhs.a; } X x1 {0, 1}; X x2 {0, 2}; auto x3 = std::max(x1, x2);
for ( std::list< Cursor::Enum >::reverse_iterator i = m_CursorStack.rbegin(); i != m_CursorStack.rend(); ++i ) { if ( *i == pCursor ) { m_CursorStack.erase( i ); break; } }
std::advance(i, 1); m_CursorStack.erase( i.base() );
auto it=vt.end(); while (it>vt.begin()) { it--; if (*it == pCursor) it = vt.erase(it); }
typedef std::map<size_t, some_class*> TMap; TMap Map; ....... for( TMap::const_reverse_iterator It = Map.rbegin(), end = Map.rend(); It != end; It++ ) { TMap::const_iterator Obsolete = It.base(); It++; Map.erase( Obsolete ); It--; }
m_CursorStack.erase(std::remove(m_CursorStack.begin(), m_CursorStack.end(), pCursor), m_CursorStack.end());
std::set<int> set{1,2,3,4,5}; for (auto itr = set.rbegin(); itr != set.rend(); ) { if (*itr == 3) { auto it = set.erase(--itr.base()); itr = std::reverse_iterator(it); } else ++itr; }
std::list< int >::iterator i = myList.begin(); while ( ; i != myList.end(); ) { if ( *i == to_delete ) { i = myList.erase( i ); } else { ++i; } }
std::list< int >::reverse_iterator i = myList.rbegin(); while ( ; i != myList.rend(); ) { if ( *i == to_delete ) { i = decltype(i)(myList.erase( std::next(i).base() )); } else { ++i; } }
int i = 0; int var; while(i < 100) { var = 4; i++; }
_main: pushl %ebp movl %esp, %ebp subl $24, %esp movl $0, -16(%ebp) jmp L2 L3: movl $4, -12(%ebp) L2: cmpl $99, -16(%ebp) jle L3 leave ret
_main: pushl %ebp movl %esp, %ebp subl $24, %esp movl $0, -16(%ebp) jmp L2 L3: movl $4, -12(%ebp) L2: cmpl $99, -16(%ebp) jle L3 leave ret
L3: movl $4, -12(%ebp) L2: cmpl $99, -16(%ebp) jle L3
while (i< 100) { LockMgr lock( myCriticalSection); }
LockMgr lock( myCriticalSection); while (i< 100) { }
int main() { for(int i = 0; i < 10; i++) { int test; if(i == 0) test = 100; printf("%d\n", test); } }
class A { public: virtual ~A() = 0; }; inline A::~A() { }
X( X && move_semantics_are_cool ) : pImpl(NULL) { this->swap(move_semantics_are_cool); } X& swap( X& rhs ) { std::swap( pImpl, rhs.pImpl ); return *this; } X& operator=( X && move_semantics_are_cool ) { return this->swap(move_semantics_are_cool); } X& operator=( const X& rhs ) { X temporary_copy(rhs); return this->swap(temporary_copy); }
==11366== Conditional jump or move depends on uninitialised value(s) ==11366== at 0x43CAE4F: __printf_fp (in /lib/tls/i686/cmov/libc-2.7.so) ==11366== by 0x43C6563: vfprintf (in /lib/tls/i686/cmov/libc-2.7.so) ==11366== by 0x43EAC03: vsnprintf (in /lib/tls/i686/cmov/libc-2.7.so) ==11366== by 0x42D475B: (within /usr/lib/libstdc++.so.6.0.9) ==11366== by 0x42E2C9B: std::ostreambuf_iterator<char, std::char_traits<char> > std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::_M_insert_float<double>(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, char, double) const (in /usr/lib/libstdc++.so.6.0.9) ==11366== by 0x42E31B4: std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::do_put(std::ostreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, char, double) const (in /usr/lib/libstdc++.so.6.0.9) ==11366== by 0x42EE56F: std::ostream& std::ostream::_M_insert<double>(double) (in /usr/lib/libstdc++.so.6.0.9) ==11366== by 0x81109ED: Snake::SnakeBody::syncBodyPos() (ostream:221) ==11366== by 0x810B9F1: Snake::Snake::update() (snake.cpp:257) ==11366== by 0x81113C1: SnakeApp::updateState() (snakeapp.cpp:224) ==11366== by 0x8120351: RoenGL::updateState() (roengl.cpp:1180) ==11366== by 0x81E87D9: Roensachs::update() (rs.cpp:321)
==11366== by 0x81109ED: Snake::SnakeBody::syncBodyPos() (ostream:221)
movespeed = stat.speedfactor * speedfac * currentbendfactor.val;
int* p = new int[10]; for (int i = 0; i < 10; i++) { p[i] = 0; }
int a[] = { 1, 2, 3 }; vector<int> v = { 1, 2, 3 };
int myArray[10]; memset( myArray, 0, 10 * sizeof( int ));
int main() { std::ofstream outfile; outfile.open("test.txt", std::ios_base::app); outfile << "Data"; return 0; }
FILE * pFileTXT; int counter int main() { pFileTXT = fopen ("aTextFile.txt","a"); for(counter=0;counter<9;counter++) fprintf (pFileTXT, "%c", characterarray[counter] ); fprintf(pFileTXT,"\n"); for(counter=0;counter<9;counter++) fprintf (pFileTXT, "%d", digitarray[counter] ); fprintf(pFileTXT,"A Sentence"); fprintf (pFileXML,"%.2x",character); fclose (pFileTXT); return 0; }
static void appendLineToFile(string filepath, string line) { std::ofstream file; file.open(filepath, std::ios::out | std::ios::app); if (file.fail()) throw std::ios_base::failure(std::strerror(errno)); file.exceptions(file.exceptions() | std::ios::failbit | std::ifstream::badbit); file << line << std::endl; }
using namespace std; int main() { ofstream writer("filename.file-extension" , ios::app); if (!writer) { cout << "Error Opening File" << endl; return -1; } string info = "insert text here"; writer.append(info); writer << info << endl; writer.close; return 0; }
... fstream f("filename.ext", f.out | f.app); f << "any"; f << "text"; f << "written"; f << "wll"; f << "be append"; ...
template <class ForwardIterator, class T> ForwardIterator remove (ForwardIterator first, ForwardIterator last, const T& val) { ForwardIterator result = first; while (first!=last) { if (!(*first == val)) { *result = *first; ++result; } ++first; } return result; }
struct Example { int i; Example() : i(0) {} bool operator==(Example const& other) const { return i == other.i; } bool operator!=(Example const& other) const { return i == 5; } }; int main() { std::vector<Example> v(10); auto it = std::remove(v.begin(), v.end(), Example()); }
Specifier(s) Type ------------- ------------- long long int long long int long long long long int long int long int long long int
void overloaded( int const &arg ) { std::cout << "by lvalue\n"; } void overloaded( int && arg ) { std::cout << "by rvalue\n"; } template< typename t > /* "t &&" with "t" being template param is special, and adjusts "t" to be (for example) "int &" or non-ref "int" so std::forward knows what to do. */ void forwarding( t && arg ) { std::cout << "via std::forward: "; overloaded( std::forward< t >( arg ) ); std::cout << "via std::move: "; overloaded( std::move( arg ) ); std::cout << "by simple passing: "; overloaded( arg ); } int main() { std::cout << "initial caller passes rvalue:\n"; forwarding( 5 ); std::cout << "initial caller passes lvalue:\n"; int x = 5; forwarding( x ); }
int main() { while(1) ; std::cout << "Hello" << std::endl; }
for (p = q; p != 0; p = p -> next) { ++count; } for (p = q; p != 0; p = p -> next) { ++count2; }
for (p = q; p != 0; p = p -> next) { ++count; ++count2; }
while (complicated_condition()) { x = complicated_but_externally_invisible_operation(x); } complex_io_operation(); cout << "Results:" << endl; cout << x << endl;
volatile int dummy_side_effect; while (1) { dummy_side_effect = 0; } printf("Never prints.\n");
Method | executable size | Time Taken (in sec) | | -O0 | -O3 | -O0 | -O3 | ------------|---------|---------|-----------|----------| 1. memset | 17 kB | 8.6 kB | 0.125 | 0.124 | 2. fill | 19 kB | 8.6 kB | 13.4 | 0.124 | 3. manual | 19 kB | 8.6 kB | 14.5 | 0.124 | 4. assign | 24 kB | 9.0 kB | 1.9 | 0.591 |
const size_t TEST_ITERATIONS = 100000; const size_t TEST_ARRAY_SIZE = 10000; int main(int argc, char** argv) { std::vector<int> v(TEST_ARRAY_SIZE, 0); for(size_t i = 0; i < TEST_ITERATIONS; ++i) { memset(&v[0], 0, v.size() * sizeof v[0]); std::fill(v.begin(), v.end(), 0); for (std::vector<int>::iterator it=v.begin(), end=v.end(); it!=end; ++it) { *it = 0; } v.assign(v.size(),0); } return EXIT_SUCCESS; }
memset(&my_vector[0], 0, my_vector.size() * sizeof my_vector[0]);
std::size siz = vec.size(); vec.resize(0); vec.resize(siz, 0);
-O0 -O3 -------- -------- memset 0.666 1.045 fill 19.357 1.066 iterator 67.368 1.043 assign 17.975 0.530 for i 22.610 1.004
const size_t TEST_ITERATIONS = 34359738; const size_t TEST_ARRAY_SIZE = 200; using namespace std; int main(int argc, char** argv) { std::vector<int> v(TEST_ARRAY_SIZE, 0); for(size_t i = 0; i < TEST_ITERATIONS; ++i) { memset(&v[0], false, v.size() * sizeof v[0]); std::fill(v.begin(), v.end(), false); for (std::vector<int>::iterator it=v.begin(), end=v.end(); it!=end; ++it) { *it = 0; } v.assign(v.size(),false); for (size_t i = 0; i < TEST_ARRAY_SIZE; i++) { v[i] = false; } } return EXIT_SUCCESS; }
g++ -std=c++11 -O0 main.cpp g++ -std=c++11 -O3 main.cpp
template <typename T> T sum(T a, T b) { return a + b; }
char* str = new char [30]; str = new char [60]; delete [] str;
char* str1 = new char [30]; char* str2 = new char [40]; strcpy(str1, "Memory leak"); str2 = str1; delete [] str2; delete [] str1;
char* one = new char; delete [] one; char* many = new char [30]; delete many;
==4230== at 0x1B977DD0: malloc (vg_replace_malloc.c:136) ==4230== by 0x804990F: main (example.c:6)
namespace MyNamespace { class MyClass {}; void doSomething(MyClass); } MyNamespace::MyClass obj; int main() { doSomething(obj); }
std::operator<<(std::operator<<(std::cout, "Hello World!"), "\n");
namespace N { class X {}; void f(X); X& operator++(X&); } int main() { N::X x; N::f(x); ??? }
std::vector<boost::shared_ptr<int>> v; auto x = begin(v);
const auto& stuff = *func_that_returns_unique_ptr();
SomeType operator* (const Matrix &lhs, const Vector &rhs);
MultExpression<Matrix, Vector> operator* (const Matrix &lhs, const Vector &rhs);
extern Matrix a, b, c; extern Vector v; void compute() { Vector res = a * (b * (c * v)); }
map<string,int> usa; auto city_it = usa.find("New York");
a a = 10 a = "10" a = ClassA() auto a; auto a = 10; a = "10"; a = ClassA{} a = 10.0;
std::vector<boost::tuple<ClassWithLongName1,std::vector<ClassWithLongName2>,int> v(); .. std::vector<boost::tuple<ClassWithLongName1,std::vector<ClassWithLongName2>,int>::iterator it = v.begin(); auto vi = v.begin();
int test (ClassWithLongName1 a, ClassWithLongName2 b, int c) { .. } .. int (*fp)(ClassWithLongName1, ClassWithLongName2, int) = test; auto *f = test;
std::cout << (-7 % 3) << std::endl; std::cout << (7 % -3) << std::endl;
(-7/3) => -2 -2 * 3 => -6 so a%b => -1 (7/-3) => -2 -2 * -3 => 6 so a%b => 1
(-7/3) => -2 -2 * 3 => -6 so a%b => -1 (7/-3) => -2 -2 * -3 => 6 so a%b => 1
template<class T> void foo(T&& arg) { bar(std::forward<T>(arg)); }
template<int val, typename... Params> void doSomething(Params... args) { doSomethingElse<val, Params...>(args...); }
template<int val, typename... Params> void doSomething(Params&&... args) { doSomethingElse<val, Params...>(std::forward<Params>(args)...); }
template<int val, typename... Params> void doSomething(Params&&... args) { doSomethingElse<val, Params...>(std::forward<Params>(args)...); doSomethingWeird<val, Params...>(std::forward<Params>(args)...); }
template <typename T> void f(T && x) { g(std::forward<T>(x)); } template <typename ...Args> void f(Args && ...args) { g(std::forward<Args>(args)...); }
int roundUp(int numToRound, int multiple) { if(multiple == 0) { return numToRound; } int roundDown = ( (int) (numToRound) / multiple) * multiple; int roundUp = roundDown + multiple; int roundCalc = roundUp; return (roundCalc); }
roundUp(7, 100) roundUp(117, 100) roundUp(477, 100) roundUp(1077, 100) roundUp(52, 20) roundUp(74, 30)
int roundUp(int numToRound, int multiple) { if(multiple == 0) { return numToRound; } int remainder = numToRound % multiple; if (remainder == 0) { return numToRound; } return numToRound + multiple - remainder; }
int roundUp(int numToRound, int multiple) { if (multiple == 0) return numToRound; int remainder = numToRound % multiple; if (remainder == 0) return numToRound; return numToRound + multiple - remainder; }
int roundUp(int numToRound, int multiple) { if (multiple == 0) return numToRound; int remainder = abs(numToRound) % multiple; if (remainder == 0) return numToRound; if (numToRound < 0) return -(abs(numToRound) - remainder); else return numToRound + multiple - remainder; }
int roundUp(int numToRound, int multiple) { assert(multiple); return ((numToRound + multiple - 1) / multiple) * multiple; }
int roundUp(int numToRound, int multiple) { assert(multiple); int isPositive = (int)(numToRound >= 0); return ((numToRound + isPositive * (multiple - 1)) / multiple) * multiple; }
int roundUp(int numToRound, int multiple) { assert(multiple && ((multiple & (multiple - 1)) == 0)); return (numToRound + multiple - 1) & -multiple; }
int round_up(int num, int factor) { return num + factor - 1 - (num - 1) % factor; }
int RoundUp(int n, int roundTo) { if (roundTo == 0) return 0; return ((n + roundTo - 1) / roundTo) * roundTo; }
int roundUp(int numToRound, int multiple) { if(multiple == 0) { return 0; } return ((numToRound - 1) / multiple + 1) * multiple; }
float roundUp(float number, float fixedBase) { if (fixedBase != 0 && number != 0) { float sign = number > 0 ? 1 : -1; number *= sign; number /= fixedBase; int fixedPoint = (int) ceil(number); number = fixedPoint * fixedBase; number *= sign; } return number; }
int roundUp(int number, int fixedBase) { if (fixedBase != 0 && number != 0) { int sign = number > 0 ? 1 : -1; int baseSign = fixedBase > 0 ? 1 : 0; number *= sign; int fixedPoint = (number + baseSign * (fixedBase - 1)) / fixedBase; number = fixedPoint * fixedBase; number *= sign; } return number; }
template<typename T> T roundMultiple( T value, T multiple ) { if (multiple == 0) return value; return static_cast<T>(std::round(static_cast<double>(value)/static_cast<double>(multiple))*static_cast<double>(multiple)); } int main() { std::cout << roundMultiple(39298.0, 100.0) << std::endl; std::cout << roundMultiple(20930.0f, 1000.0f) << std::endl; std::cout << roundMultiple(287399, 10) << std::endl; }
template<> long double roundMultiple<long double>( long double value, long double multiple) { if (multiple == 0.0l) return value; return std::round(value/multiple)*multiple; } template<> long long roundMultiple<long long>( long long value, long long multiple) { if (multiple == 0.0l) return value; return static_cast<long long>(std::round(static_cast<long double>(value)/static_cast<long double>(multiple))*static_cast<long double>(multiple)); }
template<typename T> T roundCeilMultiple( T value, T multiple ) { if (multiple == 0) return value; return static_cast<T>(std::ceil(static_cast<double>(value)/static_cast<double>(multiple))*static_cast<double>(multiple)); }
template<typename T> T roundFloorMultiple( T value, T multiple ) { if (multiple == 0) return value; return static_cast<T>(std::floor(static_cast<double>(value)/static_cast<double>(multiple))*static_cast<double>(multiple)); }
int roundUp(int numToRound, int multiple) { if(multiple == 0) { return 0; } else if(numToRound % multiple == 0) { return numToRound } int roundDown = (int) (( (double) numToRound / multiple ) * multiple); int roundUp = roundDown + multiple; int roundCalc = roundUp; return (roundCalc); }
int roundPow2 (int number, int pow2) { pow2--; pow2 = 0x01 << pow2; pow2--; // // number--; number = number | pow2; number++; return number; }
roundPow2(int, int): lea ecx, [rsi-1] mov eax, 1 sub edi, 1 sal eax, cl sub eax, 1 or eax, edi add eax, 1 ret
template <class _Ty> inline _Ty n_Align_Up(_Ty n_x, _Ty n_alignment) { assert(n_alignment > 0); n_x += (n_x >= 0)? n_alignment - 1 : -1; return n_x - n_x % n_alignment; }
template <class _Ty> bool b_Is_POT(_Ty n_x) { return !(n_x & (n_x - 1)); } template <class _Ty> inline _Ty n_Align_Up_POT(_Ty n_x, _Ty n_pot_alignment) { assert(n_pot_alignment > 0); assert(b_Is_POT(n_pot_alignment)); -- n_pot_alignment; return (n_x + n_pot_alignment) & ~n_pot_alignment; }
n_Align_Up(10, 100) = 100 n_Align_Up(110, 100) = 200 n_Align_Up(0, 100) = 0 n_Align_Up(-10, 100) = 0 n_Align_Up(-110, 100) = -100 n_Align_Up(-210, 100) = -200 n_Align_Up_POT(10, 128) = 128 n_Align_Up_POT(130, 128) = 256 n_Align_Up_POT(0, 128) = 0 n_Align_Up_POT(-10, 128) = 0 n_Align_Up_POT(-130, 128) = -128 n_Align_Up_POT(-260, 128) = -256
int noOfMultiples = int((numToRound / multiple)+0.5); return noOfMultiples*multiple
int roundUp = roundDown + multiple; int roundCalc = roundUp; return (roundCalc);
int roundUp = roundDown + multiple; return roundUp;
int RoundUpToNearestMultOfNumber(int val, int num) { assert(0 != num); return (floor((val + num) / num) * num); }
int alwaysRoundUp(int n, int multiple) { if (n % multiple != 0) { n = ((n + multiple) / multiple) * multiple; } return n; }
int alwaysRoundDown(int n, int multiple) { n = (n / multiple) * multiple; return n; }
int normalRound(int n, int multiple) { n = ((n + multiple/2)/multiple) * multiple; return n; }
public static int mod(int x, int n) { return ((x % n) + n) % n; } public static int roundUp(int numToRound, int multiple) { return numRound + mod(-numToRound, multiple); }
int roundUp(int numToRound, int multiple) { if (numToRound == 0) return multiple; if (multiple == 0) return numToRound; float rounds = static_cast<float>(numToRound) / static_cast<float>(multiple); int floorRounds = static_cast<int>(floor(rounds)); if (rounds - floorRounds > 0) return (floorRounds+1) * multiple; else return (floorRounds) * multiple; }
int roundUp (int numToRound, int multiple) { return multiple * ((numToRound + multiple - 1) / multiple); }
int roundUp(int numToRound, int multiple) { return (multiple ? (((numToRound+multiple-1) / multiple) * multiple) : numToRound); }
roundup() { echo $(( ${2} ? ((${1}+${2}-1)/${2})*${2} : ${1} )) }
int round_up(int x, int div) { return x + (div - x % div) % div; }
int RoundUp(int n, int multiple) { if (multiple == 0) return n; int roundedDown = n / multiple * multiple; if (roundedDown == n) return n; return (n < 0) ? roundedDown - multiple : roundedDown + multiple; }
void test_roundUp() { if (true) {{ unsigned m; { m = roundUp(17,8); } ++m; assertTrue( 24 == roundUp(17,8) ); { m = roundUp(24,8); } assertTrue( 24 == roundUp(24,8) ); assertTrue( 24 == roundUp(24,4) ); assertTrue( 24 == roundUp(23,4) ); { m = roundUp(23,4); } assertTrue( 24 == roundUp(21,4) ); assertTrue( 20 == roundUp(20,4) ); assertTrue( 20 == roundUp(19,4) ); assertTrue( 20 == roundUp(18,4) ); assertTrue( 20 == roundUp(17,4) ); assertTrue( 17 == roundUp(17,0) ); assertTrue( 20 == roundUp(20,0) ); }} }
using namespace std; int roundUp(int numToRound, int multiple); int main() { cout << "answer is: " << roundUp(7, 100) << endl; cout << "answer is: " << roundUp(117, 100) << endl; cout << "answer is: " << roundUp(477, 100) << endl; cout << "answer is: " << roundUp(1077, 100) << endl; cout << "answer is: " << roundUp(52,20) << endl; cout << "answer is: " << roundUp(74,30) << endl; return 0; } int roundUp(int numToRound, int multiple) { if (multiple == 0) { return 0; } int result = (int) (numToRound / multiple) * multiple; if (numToRound % multiple) { result += multiple; } return result; }
answer is: 100 answer is: 200 answer is: 500 answer is: 1100 answer is: 60 answer is: 90
int main() { int i, j; printf("\nEnter Two Integers i and j..."); scanf("%d %d", &i, &j); int Round_Off=i+j-i%j; printf("The Rounded Off Integer Is...%d\n", Round_Off); return 0; }
public static int roundUp(int numToRound, int multiple) { if (multiple == 0) { return 0; } else if (numToRound % multiple == 0) { return numToRound; } int mod = numToRound % multiple; int diff = multiple - mod; return numToRound + diff; }
int mod(int num) { return num % 256; } mod(int): mov edx, edi sar edx, 31 shr edx, 24 lea eax, [rdi+rdx] movzx eax, al sub eax, edx ret
int mod(int num) { return num & 0xFF; } mod(int): movzx eax, dil ret
void foo(int (&myArray)[100]) { } int main() { int a[100]; foo(a); }
void foo(int * x); void foo(int x[100]); void foo(int x[]);
QString Get::osName() { return QLatin1String("android"); return QLatin1String("blackberry"); return QLatin1String("ios"); return QLatin1String("osx"); return QLatin1String("wince"); return QLatin1String("windows"); return QLatin1String("linux"); return QLatin1String("unix"); return QLatin1String("unknown"); }
__linux__ Defined on Linux __sun Defined on Solaris __FreeBSD__ Defined on FreeBSD __NetBSD__ Defined on NetBSD __OpenBSD__ Defined on OpenBSD __APPLE__ Defined on Mac OS X __hpux Defined on HP-UX __osf__ Defined on Tru64 UNIX (formerly DEC OSF1) __sgi Defined on Irix _AIX Defined on AIX
class Base { public: int x; }; class Derived : Base { }; int main() { Derived d; d.x = 20; getchar(); return 0; } struct Base { public: int x; }; struct Derived : Base { }; int main() { Derived d; d.x = 20; getchar(); return 0; }
using namespace std; int main() { int array[2]; array[0] = 1; array[1] = 2; array[3] = 3; array[4] = 4; cout << array[3] << endl; cout << array[4] << endl; return 0; }
$ g++ -W -Wall errorRange.cpp -o errorRange $ ./errorRange 3 4
vector<int> vint(2); vint[0] = 0; vint[1] = 1; vint[2] = 2; vint[5] = 5; cout << vint[2] << endl; cout << vint[5] << endl;
> g++ -o t -fstack-protector-all t.cc > ./t 3 4 /bin/bash: line 1: 15450 Segmentation fault ./t
int main() { int array[1]; for (int i = 0; i != 100000; i++) { array[i] = i; } return 0; }
int main() { int array[1]; int *ptr = array; for (int i = 0; i != 100000; i++, ptr++) { *ptr++ = i; } return 0; }
int main() { boost::array<int,2> array; array.at(0) = 1; array[1] = 2; try { std::cout << "array.at(0) = " << array.at(0) << std::endl; std::cout << "array.at(2) = " << array.at(2) << std::endl; std::cout << "array.at(1) = " << array.at(1) << std::endl; } catch(const std::out_of_range& r) { std::cout << "Something goes wrong: " << r.what() << std::endl; } return 0; }
array.at(0) = 1 Something goes wrong: array<>: index out of range
int main(void) { int array[1]; array[1] = 1; return 0; }
g++ --stack-check -W -Wall errorRange.cpp -o errorRange valgrind ./errorRange
int pagesWordsLength = sizeof(pagesWords) / sizeof(pagesWords[0]); realloc (pagesWords, sizeof(pagesWords[0]) * (pagesWordsLength + 1); pagesWords[pagesWordsLength] = MY_NULL; for (uint i = 0; i < 1000; i++) { if (pagesWords[i] == MY_NULL) { break; } }
using namespace std; int main() { int array[2]; INT NOTHING; CHAR FOO[4]; STRCPY(FOO, "BAR"); array[0] = 1; array[1] = 2; array[3] = 3; array[4] = 4; cout << array[3] << endl; cout << array[4] << endl; COUT << FOO << ENDL; return 0; }
<identifier> => lookup(); Goal -> [Declaration]... <eof> +> goal_ Declaration -> Type... VarList -> typedef Type... TypeVarList VarList -> Var / TypeVarList -> TypeVar / Var -> [Ptr]... Identifier TypeVar -> [Ptr]... TypeIdentifier Identifier -> <identifier> +> identifier_(1) TypeIdentifier -> <identifier> =+> typedefidentifier_(1,{typedef}) Ptr -> Type -> char +> type_(1) -> int +> type_(1) -> short +> type_(1) -> unsigned +> type_(1) -> {typedef} +> type_(1)
typedef int x; x * y; typedef unsigned int uint, *uintptr; uint a, b, c; uintptr p, q, r;
char *bits = NULL; ... bits = new (std::nothrow) char[((int *) copyMe->bits)[0]]; if (bits == NULL) { cout << "ERROR Not enough memory.\n"; exit(1); } memcpy (bits, copyMe->bits, ((int *) copyMe->bits)[0]);
std::copy memcpy % increase 6.11 6.29 2.86% 6.09 6.28 3.03% 6.10 6.29 3.02% 6.08 6.27 3.03% 6.08 6.27 3.03%
std::copy memcpy % difference 5.52 5.56 +0.72% 5.56 5.55 -0.18% 5.57 5.53 -0.72% 5.57 5.52 -0.91% 5.56 5.57 +0.18% 5.56 5.57 +0.18% 5.56 5.53 -0.54% 5.53 5.57 +0.72% 5.59 5.57 -0.36% 5.57 5.56 -0.18%
std::copy memcpy % difference 5.54 5.57 +0.54% 5.50 5.53 +0.54% 5.54 5.58 +0.72% 5.50 5.57 +1.26% 5.54 5.58 +0.72% 5.54 5.57 +0.54% 5.54 5.56 +0.36% 5.54 5.58 +0.72% 5.51 5.58 +1.25% 5.54 5.57 +0.54%
struct foo { int x, y; }; void bar(foo* a, foo* b, size_t n) { std::copy(a, a + n, b); }
bar(foo*, foo*, unsigned long): salq $3, %rdx sarq $3, %rdx testq %rdx, %rdx je .L5 subq $8, %rsp movq %rsi, %rax salq $3, %rdx movq %rdi, %rsi movq %rax, %rdi call memmove addq $8, %rsp .L5: rep ret
void bar(foo* __restrict a, foo* __restrict b, size_t n)
Benchmark Time CPU Iterations --------------------------------------------------- bm_memcpy 17 ns 17 ns 40867738 bm_stdcopy 62 ns 62 ns 11176219 bm_stdcopy_n 72 ns 72 ns 9481749
Benchmark Time CPU Iterations --------------------------------------------------- bm_memcpy 3 ns 3 ns 274527617 bm_stdcopy 3 ns 3 ns 272663990 bm_stdcopy_n 3 ns 3 ns 274732792
constexpr int N = 10; void bm_memcpy(benchmark::State& state) { std::vector<int> a(N); std::vector<int> r(N); while (state.KeepRunning()) { memcpy(r.data(), a.data(), N * sizeof(int)); } } void bm_stdcopy(benchmark::State& state) { std::vector<int> a(N); std::vector<int> r(N); while (state.KeepRunning()) { std::copy(a.begin(), a.end(), r.begin()); } } void bm_stdcopy_n(benchmark::State& state) { std::vector<int> a(N); std::vector<int> r(N); while (state.KeepRunning()) { std::copy_n(a.begin(), N, r.begin()); } } BENCHMARK(bm_memcpy); BENCHMARK(bm_stdcopy); BENCHMARK(bm_stdcopy_n); BENCHMARK_MAIN()
const uint32_t arr_size = (1080 * 720 * 3); const uint32_t iterations = 100000; uint8_t arr1[arr_size]; uint8_t arr2[arr_size]; std::vector<uint8_t> v; main(){ { DPROFILE; memcpy(arr1, arr2, sizeof(arr1)); printf("memcpy()\n"); } v.reserve(sizeof(arr1)); { DPROFILE; std::copy(arr1, arr1 + sizeof(arr1), v.begin()); printf("std::copy()\n"); } { time_t t = time(NULL); for(uint32_t i = 0; i < iterations; ++i) memcpy(arr1, arr2, sizeof(arr1)); printf("memcpy() elapsed %d s\n", time(NULL) - t); } { time_t t = time(NULL); for(uint32_t i = 0; i < iterations; ++i) std::copy(arr1, arr1 + sizeof(arr1), v.begin()); printf("std::copy() elapsed %d s\n", time(NULL) - t); } }
{ time_t t = time(NULL); for(uint32_t i = 0; i < iterations; ++i) memcpy(arr1, arr2, sizeof(arr1)); printf("memcpy() elapsed %ld s\n", time(NULL) - t); } { time_t t = time(NULL); for(uint32_t i = 0; i < iterations; ++i) std::copy(arr1, arr1 + sizeof(arr1), arr2); printf("std::copy() elapsed %ld s\n", time(NULL) - t); } memcpy() elapsed 44 s std::copy() elapsed 48 s
class SymbolIndexer { protected: SymbolIndexer ( ) { } public: static inline SymbolIndexer & GetUniqueInstance ( ) { static SymbolIndexer uniqueinstance_ ; return uniqueinstance_ ; } };
SymbolIndexer symbol_indexer_ = SymbolIndexer::GetUniqueInstance ( );
SymbolIndexer & ref_symbol_indexer_ = SymbolIndexer::GetUniqueInstance ( );
class NonAssignable { private: NonAssignable(NonAssignable const&); NonAssignable& operator=(NonAssignable const&); public: NonAssignable() {} }; class SymbolIndexer: public Indexer, public NonAssignable { };
class NonAssignable { public: NonAssignable(NonAssignable const&) = delete; NonAssignable& operator=(NonAssignable const&) = delete; NonAssignable() {} };
class SymbolIndexer: public Indexer, private boost::noncopyable { };
class A { public: static ::std::shared_ptr<A> create() { return ::std::make_shared<A>(); } protected: A() {} A(const A &) = delete; const A &operator =(const A &) = delete; }; ::std::shared_ptr<A> foo() { return A::create(); }
g++ -std=c++0x -march=native -mtune=native -O3 -Wall testmakeshared.cpp In file included from /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr.h:52:0, from /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/memory:86, from testmakeshared.cpp:1: testmakeshared.cpp: In constructor ‘std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc) [with _Tp = A, _Alloc = std::allocator<A>, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]’: /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr_base.h:518:8: instantiated from ‘std::__shared_count<_Lp>::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&, _Args&& ...) [with _Tp = A, _Alloc = std::allocator<A>, _Args = {}, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]’ /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr_base.h:986:35: instantiated from ‘std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<A>, _Args = {}, _Tp = A, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]’ /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr.h:313:64: instantiated from ‘std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<A>, _Args = {}, _Tp = A]’ /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr.h:531:39: instantiated from ‘std::shared_ptr<_Tp> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = A, _Alloc = std::allocator<A>, _Args = {}]’ /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr.h:547:42: instantiated from ‘std::shared_ptr<_Tp1> std::make_shared(_Args&& ...) [with _Tp = A, _Args = {}]’ testmakeshared.cpp:6:40: instantiated from here testmakeshared.cpp:10:8: error: ‘A::A()’ is protected /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr_base.h:400:2: error: within this context Compilation exited abnormally with code 1 at Tue Nov 15 07:32:58
class A { protected: struct this_is_private; public: explicit A(const this_is_private &) {} A(const this_is_private &, ::std::string, int) {} template <typename... T> static ::std::shared_ptr<A> create(T &&...args) { return ::std::make_shared<A>(this_is_private{0}, ::std::forward<T>(args)...); } protected: struct this_is_private { explicit this_is_private(int) {} }; A(const A &) = delete; const A &operator =(const A &) = delete; }; ::std::shared_ptr<A> foo() { return A::create(); } ::std::shared_ptr<A> bar() { return A::create("George", 5); } ::std::shared_ptr<A> errors() { ::std::shared_ptr<A> retval; retval = A::create("George"); retval = new A(A::this_is_private{0}); return ::std::move(retval); }
std::shared_ptr<A> make_a(); namespace { struct concrete_A: public A {}; } std::shared_ptr<A> make_a() { return std::make_shared<concrete_A>(); }
class A { public: static std::shared_ptr<A> create() { struct make_shared_enabler : public A {}; return std::make_shared<make_shared_enabler>(); } private: A() {} };
class A { public: static shared_ptr<A> Create(); private: A() {} struct MakeSharedEnabler; }; struct A::MakeSharedEnabler : public A { MakeSharedEnabler() : A() { } }; shared_ptr<A> A::Create() { return make_shared<MakeSharedEnabler>(); }
static std::shared_ptr<A> create() { std::shared_ptr<A> pA(new A()); return pA; }
struct A { public: template<typename ...Arg> std::shared_ptr<A> static create(Arg&&...arg) { struct EnableMakeShared : public A { EnableMakeShared(Arg&&...arg) :A(std::forward<Arg>(arg)...) {} }; return std::make_shared<EnableMakeShared>(std::forward<Arg>(arg)...); } void dump() const { std::cout << a_ << std::endl; } private: A(int a) : a_(a) {} A(int i, int j) : a_(i + j) {} A(std::string const& a) : a_(a.size()) {} int a_; };
template<typename Private> struct MyAlloc : std::allocator<Private> { void construct(void* p) { ::new(p) Private(); } }; class A { public: static ::std::shared_ptr<A> create() { return ::std::allocate_shared<A>(MyAlloc<A>()); } protected: A() {} A(const A &) = delete; const A &operator =(const A &) = delete; friend struct MyAlloc<A>; }; int main() { auto p = A::create(); return 0; }
template<typename T> class safe_enable_shared_from_this : public std::enable_shared_from_this<T> { public: template<typename... _Args> static ::std::shared_ptr<T> create(_Args&&... p_args) { return ::std::allocate_shared<T>(Alloc(), std::forward<_Args>(p_args)...); } protected: struct Alloc : std::allocator<T> { template<typename _Up, typename... _Args> void construct(_Up* __p, _Args&&... __args) { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); } }; safe_enable_shared_from_this(const safe_enable_shared_from_this&) = delete; safe_enable_shared_from_this& operator=(const safe_enable_shared_from_this&) = delete; }; class A : public safe_enable_shared_from_this<A> { private: A() {} friend struct safe_enable_shared_from_this<A>::Alloc; }; class B : public safe_enable_shared_from_this<B> { private: B(int v) {} friend struct safe_enable_shared_from_this<B>::Alloc; }; int main() { auto a = A::create(); auto b = B::create(5); return 0; }
class test { test() {} ALLOW_MAKE_SHARED(test); public: static std::shared_ptr<test> create() { return std::make_shared<test>(); } }; int main() { std::shared_ptr<test> t(test::create()); }
template<typename S> struct enable_make : public S { template<typename... T> enable_make(T&&... t) : S(std::forward<T>(t)...) { } }; class foo { public: static std::unique_ptr<foo> create(std::unique_ptr<int> u, char const* s) { return std::make_unique<enable_make<foo>>(std::move(u), s); } protected: foo(std::unique_ptr<int> u, char const* s) { } }; void test() { auto fp = foo::create(std::make_unique<int>(3), "asdf"); }
namespace std { class shared_ptr_access { template <typename _T, typename ... _Args> static _T* __construct(void* __pv, _Args&& ... __args) { return ::new(__pv) _T(forward<_Args>(__args)...); } template <typename _T> static void __destroy(_T* __ptr) { __ptr->~_T(); } template <typename _T, typename _A> friend class __shared_ptr_storage; }; }
class A { public: static std::shared_ptr<A> create() { return std::make_shared<A>(); } protected: friend class std::shared_ptr_access; A() {} A(const A &) = delete; const A &operator =(const A &) = delete; };
class B { public: class Pass { Pass() {} friend class A; }; B(Pass, int someArgument) { } }; class A { public: A() { auto ptr = std::make_shared<B>(B::Pass(), 42); } }; class C { public: C() { auto ptr = std::make_shared<B>(B::Pass(), 42); } };
class Factory final { public: template<typename T, typename... A> static std::shared_ptr<T> make_shared(A&&... args) { return std::allocate_shared<T>(Alloc<T>(), std::forward<A>(args)...); } private: template<typename T> struct Alloc : std::allocator<T> { template<typename U, typename... A> void construct(U* ptr, A&&... args) { new(ptr) U(std::forward<A>(args)...); } template<typename U> void destroy(U* ptr) { ptr->~U(); } }; }; class X final : public std::enable_shared_from_this<X> { friend class Factory; private: X() { std::cout << "X() addr=" << this << "\n"; } X(int i) { std::cout << "X(int) addr=" << this << " i=" << i << "\n"; } ~X() { std::cout << "~X()\n"; } }; int main() { auto p1 = Factory::make_shared<X>(42); auto p2 = p1->shared_from_this(); std::cout << "p1=" << p1 << "\n" << "p2=" << p2 << "\n" << "count=" << p1.use_count() << "\n"; }
class Factory final { public: template<typename T, typename... A> static std::shared_ptr<T> make_shared(A&&... args) { auto ptr = std::make_shared<Type<T>>(std::forward<A>(args)...); return std::shared_ptr<T>(ptr, &ptr->type); } private: template<typename T> struct Type final { template<typename... A> Type(A&&... args) : type(std::forward<A>(args)...) { std::cout << "Type(...) addr=" << this << "\n"; } ~Type() { std::cout << "~Type()\n"; } T type; }; }; class X final { friend struct Factory::Type<X>; private: X() { std::cout << "X() addr=" << this << "\n"; } X(int i) { std::cout << "X(...) addr=" << this << " i=" << i << "\n"; } ~X() { std::cout << "~X()\n"; } }; int main() { auto ptr1 = Factory::make_shared<X>(); auto ptr2 = Factory::make_shared<X>(42); }
template<typename T> class EnableShared { friend class Factory; public: std::shared_ptr<T> shared_from_this() { return weak.lock(); } protected: EnableShared() = default; virtual ~EnableShared() = default; EnableShared<T>& operator=(const EnableShared<T>&) { return *this; } private: std::weak_ptr<T> weak; }; class Factory final { public: template<typename T, typename... A> static std::shared_ptr<T> make_shared(A&&... args) { auto ptr = std::make_shared<Type<T>>(std::forward<A>(args)...); auto alt = std::shared_ptr<T>(ptr, &ptr->type); assign(std::is_base_of<EnableShared<T>, T>(), alt); return alt; } private: template<typename T> struct Type final { template<typename... A> Type(A&&... args) : type(std::forward<A>(args)...) { std::cout << "Type(...) addr=" << this << "\n"; } ~Type() { std::cout << "~Type()\n"; } T type; }; template<typename T> static void assign(std::true_type, const std::shared_ptr<T>& ptr) { ptr->weak = ptr; } template<typename T> static void assign(std::false_type, const std::shared_ptr<T>&) {} }; class X final : public EnableShared<X> { friend struct Factory::Type<X>; private: X() { std::cout << "X() addr=" << this << "\n"; } X(int i) { std::cout << "X(...) addr=" << this << " i=" << i << "\n"; } ~X() { std::cout << "~X()\n"; } }; int main() { auto ptr1 = Factory::make_shared<X>(); auto ptr2 = ptr1->shared_from_this(); std::cout << "ptr1=" << ptr1.get() << "\nptr2=" << ptr2.get() << "\n"; }
class A; typedef std::shared_ptr<A> APtr; class A { template<class T> friend class std::_Ref_count_obj; public: APtr create() { return std::make_shared<A>(); } private: A() {} };
class T; \ typedef std::shared_ptr<T> template<class T> \ friend class std::_Ref_count_obj;
SHARED_PTR_DECL(B); class B { FRIEND_STD_MAKE_SHARED public: BPtr create() { return std::make_shared<B>(); } private: B() {} };
class CVal { friend std::shared_ptr<CVal>; friend std::_Ref_count<CVal>; public: static shared_ptr<CVal> create() { shared_ptr<CVal> ret_sCVal(new CVal()); return ret_sCVal; } protected: CVal() {}; ~CVal() {}; };
class A : public std::enable_shared_from_this<A> { private: A(){} explicit A(int a):m_a(a){} public: template <typename... Args> static std::shared_ptr<A> create(Args &&... args) { class make_shared_enabler : public A { public: make_shared_enabler(Args &&... args):A(std::forward<Args>(args)...){} }; return std::make_shared<make_shared_enabler>(std::forward<Args>(args)...); } int val() const { return m_a; } private: int m_a=0; }; int main(int, char **) { std::shared_ptr<A> a0=A::create(); std::shared_ptr<A> a1=A::create(10); std::cout << a0->val() << " " << a1->val() << std::endl; return 0; }
using FunctionPtr = std::add_pointer<void()>::type;
void f() {} using Function_t = void(); Function_t* ptr = f; ptr();
typedef someStructureWithAWeirdName& (FunctionPtr*)(type1*, type2**, type3<type4&>);
using FunctionPtr = auto (*)(type1*, type2**, type3<type4&>) -> someStructureWithAWeirdName&;
int bar(int, int); int foo(int n, int acc) { return (n == 0) ? acc : bar(n - 1, acc + 2); } int bar(int n, int acc) { return (n == 0) ? acc : foo(n - 1, acc + 1); }
static int atoi(const char *str, int n) { if (str == 0 || *str == 0) return n; return atoi(str+1, n*10 + *str- } int main(int argc, char **argv) { for (int i = 1; i != argc; ++i) printf("%s -> %d\n", argv[i], atoi(argv[i], 0)); return 0; }
int fn(int j, int i) { if (i <= 0) return j; Funky cls(j,i); return fn(j, i-1); }
template< typename T > struct array_deleter { void operator ()( T const * p) { delete[] p; } };
std::shared_ptr<int> sp(new int[10], array_deleter<int>());
std::shared_ptr<int> sp(new int[10], std::default_delete<int[]>());
std::shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
typedef typename remove_extent<T>::type element_type;
element_type& operator[](ptrdiff_t i) const noexcept;
int i = 4; string text = "Player "; cout << (text + i);
int i = 4; std::string text = "Player "; text += std::to_string(i);
std::ostringstream oss; oss << text << i; std::cout << oss.str();
std::stringstream Stream; Stream.str(MyStr); Stream << MyInt; MyStr = Stream.str(); someStream << MyInt;
string text = "Player: "; int i = 4; cout << text << i << endl;
using namespace std; std::string operator+(std::string const &a, int b) { std::ostringstream oss; oss << a << b; return oss.str(); } int main() { int i = 4; string text = "Player: "; cout << (text + i) << endl; }
template <class T> std::string operator+(std::string const &a, const T &b){ std::ostringstream oss; oss << a << b; return oss.str(); }
int main() { int i = 4; std::string text = "Player"; std::cout << boost::format("%1% %2%\n") % text % i; }
using namespace std; int main(){ string str; int i = 321; std::stringstream ss; ss << 123; str = "/dev/video"; cout << str << endl; cout << str << 456 << endl; cout << str << i << endl; str += ss.str(); cout << str << endl; }
/dev/video /dev/video456 /dev/video321 /dev/video123
int i = 4; QString qs = QString("Player %1").arg(i); std::cout << qs.toLocal8bit().constData();
for(k = 0; *(count + k); k++) { text += count[k]; }
int i = 4; string text = "Player "; text.push_back(i + cout << text;
using namespace std; int main() { string names[] = { "amz","Waq","Mon","Sam","Has","Shak","GBy" }; int length = sizeof(names) / sizeof(names[0]); int id; string append[7]; for (size_t i = 0; i < length; i++) { id = rand() % 20000 + 2; append[i] = names[i] + to_string(id); } for (size_t i = 0; i < length; i++) { cout << append[i] << endl; } }
std::cout << text; std::cout << i; std::cout << endl;
int i = 4; string text = "Player "; text+=(i+ cout << (text);
int i = 4; CString strOutput; strOutput.Format("Player %d", i);
qInfo() << "C++ Style Info Message"; qInfo( "C Style Info Message" ); qDebug() << "C++ Style Debug Message"; qDebug( "C Style Debug Message" ); qWarning() << "C++ Style Warning Message"; qWarning( "C Style Warning Message" ); qCritical() << "C++ Style Critical Error Message"; qCritical( "C Style Critical Error Message" ); qFatal( "C Style Fatal Error Message" );
QTextStream& qStdOut() { static QTextStream ts( stdout ); return ts; }
QTextStream out(stdout); foreach(QString x, strings) out << x << endl;
inline QTextStream& qStdout() { static QTextStream r{stdout}; return r; } ... foreach(QString x, strings) qStdout() << x << endl;
qDebug() << "Debug Message"; qWarning() << "Warning Message"; qCritical() << "Critical Error Message"; qFatal("Fatal Error Message");
typedef struct{ CONSOLE_SCREEN_BUFFER_INFOEX conScreenBuffInfoEX; HANDLE con_screenbuf; HWND hwndConsole; HMENU consoleMenu ; QString consoleTitle; QMessageBox mBox; QString localMsg; QString errorMessage; WINBOOL errorCode; } consoleT; static consoleT *console; BOOL WINAPI catchCTRL( DWORD ctrlMsg ){ if( ctrlMsg == CTRL_C_EVENT ){ HWND hwndWin = GetConsoleWindow(); ShowWindow(hwndWin,SW_FORCEMINIMIZE); } return TRUE; } void removeCloseMenu(){ int i; for( i = 0; i < 10; i++){ console->hwndConsole = FindWindowW( NULL, console->consoleTitle.toStdWString().data()); if(console->hwndConsole != NULL) break; } if( !(console->errorCode = 0) && (console->hwndConsole == NULL)) console->errorMessage += QString("\nFindWindowW error: %1 \n").arg(console->errorCode); if( !(console->errorCode = 0) && !(console->consoleMenu = GetSystemMenu( console->hwndConsole, FALSE )) ) console->errorMessage += QString("GetSystemMenu error: %1 \n").arg(console->errorCode); if(!(console->errorCode = DeleteMenu( console->consoleMenu, SC_CLOSE, MF_BYCOMMAND ))) console->errorMessage += QString("DeleteMenu error: %1 \n").arg(console->errorCode); } void initialiseConsole(){ console->conScreenBuffInfoEX.cbSize = sizeof(CONSOLE_SCREEN_BUFFER_INFOEX); console->consoleMenu = NULL; console->consoleTitle = YOURCONSOLETITLE; console->con_screenbuf = INVALID_HANDLE_VALUE; console->errorCode = 0; console->errorMessage = ""; console->hwndConsole = NULL; console->localMsg = ""; if(!(console->errorCode = FreeConsole())) console->errorMessage += QString("\nFreeConsole error: %1 \n").arg(console->errorCode); if(!(console->errorCode = AllocConsole())) console->errorMessage += QString("\nAllocConsole error: %1 \n").arg(console->errorCode); if( (console->errorCode = -1) && (INVALID_HANDLE_VALUE ==(console->con_screenbuf = CreateConsoleScreenBuffer( GENERIC_WRITE | GENERIC_READ,0, NULL, CONSOLE_TEXTMODE_BUFFER, NULL)))) console->errorMessage += QString("\nCreateConsoleScreenBuffer error: %1 \n").arg(console->errorCode); if(!(console->errorCode = SetConsoleActiveScreenBuffer(console->con_screenbuf))) console->errorMessage += QString("\nSetConsoleActiveScreenBuffer error: %1 \n").arg(console->errorCode); if(!(console->errorCode = GetConsoleScreenBufferInfoEx(console->con_screenbuf, &console->conScreenBuffInfoEX))) console->errorMessage += QString("\nGetConsoleScreenBufferInfoEx error: %1 \n").arg(console->errorCode); console->conScreenBuffInfoEX.dwSize.X = CONSOLE_COLUMNS; console->conScreenBuffInfoEX.dwSize.Y = CONSOLE_ROWS; if(!(console->errorCode = SetConsoleScreenBufferInfoEx(console->con_screenbuf, &console->conScreenBuffInfoEX))) console->errorMessage += QString("\nSetConsoleScreenBufferInfoEx error: %1 \n").arg(console->errorCode); if(!(console->errorCode = SetConsoleTitleW(console->consoleTitle.toStdWString().data()))) console->errorMessage += QString("SetConsoleTitle error: %1 \n").arg(console->errorCode); SetConsoleCtrlHandler(NULL, FALSE); SetConsoleCtrlHandler(catchCTRL, TRUE); removeCloseMenu(); if(console->errorMessage.length() > 0){ console->mBox.setText(console->errorMessage); console->mBox.show(); } } void messageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg){ if((console->con_screenbuf != INVALID_HANDLE_VALUE)){ switch (type) { case QtDebugMsg: console->localMsg = console->errorMessage + "Debug: " + msg; WriteConsoleW(console->con_screenbuf, console->localMsg.toStdWString().data(), console->localMsg.toStdWString().length(), NULL, NULL ); WriteConsoleA(console->con_screenbuf, "\n--\n", 4, NULL, NULL ); break; case QtWarningMsg: console->localMsg = console->errorMessage + "Warning: " + msg; WriteConsoleW(console->con_screenbuf, console->localMsg.toStdWString().data(), console->localMsg.toStdWString().length() , NULL, NULL ); WriteConsoleA(console->con_screenbuf, "\n--\n", 4, NULL, NULL ); break; case QtCriticalMsg: console->localMsg = console->errorMessage + "Critical: " + msg; WriteConsoleW(console->con_screenbuf, console->localMsg.toStdWString().data(), console->localMsg.toStdWString().length(), NULL, NULL ); WriteConsoleA(console->con_screenbuf, "\n--\n", 4, NULL, NULL ); break; case QtFatalMsg: console->localMsg = console->errorMessage + "Fatal: " + msg; WriteConsoleW(console->con_screenbuf, console->localMsg.toStdWString().data(), console->localMsg.toStdWString().length(), NULL, NULL ); WriteConsoleA(console->con_screenbuf, "\n--\n", 4, NULL, NULL ); abort(); } } } int main(int argc, char *argv[]) { qInstallMessageHandler(messageHandler); QApplication a(argc, argv); console = new consoleT(); initialiseConsole(); qDebug() << "Hello World!"; MainWindow w; w.show(); return a.exec(); }
std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter; std::string narrow = converter.to_bytes(wide_utf16_source_string); std::wstring wide = converter.from_bytes(narrow_utf8_source_string);
int StringToWString(std::wstring &ws, const std::string &s) { std::wstring wsTmp(s.begin(), s.end()); ws = wsTmp; return 0; }
std::wstring ws(s.size(), L ws.resize(std::mbstowcs(&ws[0], s.c_str(), s.size()));
using std::runtime_error; using std::string; using std::vector; using std::wstring; wstring utf8toUtf16(const string & str) { if (str.empty()) return wstring(); size_t charsNeeded = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), NULL, 0); if (charsNeeded == 0) throw runtime_error("Failed converting UTF-8 string to UTF-16"); vector<wchar_t> buffer(charsNeeded); int charsConverted = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), &buffer[0], buffer.size()); if (charsConverted == 0) throw runtime_error("Failed converting UTF-8 string to UTF-16"); return wstring(&buffer[0], charsConverted); }
... string s = "some string"; CA2W ca2w(s.c_str()); wstring w = ca2w; printf("%s = %ls", s.c_str(), w.c_str());
... wstring w = L"some wstring"; CW2A cw2a(w.c_str()); string s = cw2a; printf("%s = %ls", s.c_str(), w.c_str());
char* str = "hello worlddd"; wstring wstr (str, str+strlen(str));
string str = "hello worlddd"; wstring wstr (str.begin(), str.end());
std::string narrow = "narrow"; std::wstring wide = "wide"; std::wstringstream cls; cls << " abc " << narrow.c_str() << L" def " << wide.c_str(); std::wstring total= cls.str();
std::wstring convert(const std::string& input) { try { std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter; return converter.from_bytes(input); } catch(std::range_error& e) { size_t length = input.length(); std::wstring result; result.reserve(length); for(size_t i = 0; i < length; i++) { result.push_back(input[i] & 0xFF); } return result; } }
std::wstring s2ws(const std::string& s) { std::string curLocale = setlocale(LC_ALL, ""); const char* _Source = s.c_str(); size_t _Dsize = mbstowcs(NULL, _Source, 0) + 1; wchar_t *_Dest = new wchar_t[_Dsize]; wmemset(_Dest, 0, _Dsize); mbstowcs(_Dest,_Source,_Dsize); std::wstring result = _Dest; delete []_Dest; setlocale(LC_ALL, curLocale.c_str()); return result; }
wstring utf8toUtf16(const string & str) { USES_CONVERSION; _acp = CP_UTF8; return A2W( str.c_str() ); }
string ansi2utf8( const string& s ) { USES_CONVERSION; _acp = CP_ACP; wchar_t* pw = A2W( s.c_str() ); _acp = CP_UTF8; return W2A( pw ); }
std::wstring string2wString(const std::string& s){ int len; int slength = (int)s.length() + 1; len = MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, 0, 0); wchar_t* buf = new wchar_t[len]; MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, buf, len); std::wstring r(buf); delete[] buf; return r; } int main(){ std::wstring str="your string"; std::wstring wStr=string2wString(str); return 0; }
template <class T1, class T2> inline pair<T1,T2> make_pair(T1 x, T2 y) { return pair<T1,T2>(x, y); }
std::pair<std::string, int> p = make_pair("foo", 0);
template <class T1, class T2> inline pair< typename decay<T1>::type, typename decay<T2>::type > make_pair(T1&& x, T2&& y) { return pair< typename decay<T1>::type, typename decay<T2>::type >(std::forward<T1>(x), std::forward<T2>(y)); }
template<class T> void func(T&& param) { if (std::is_same<T,int>::value) std::cout << "param is an int\n"; else std::cout << "param is not an int\n"; } int main() { int three = 3; func(three); }
template<class T> void func(T&& param) { if (std::is_same<typename std::decay<T>::type,int>::value) std::cout << "param is an int\n"; else std::cout << "param is not an int\n"; }
class Piece { private: Shape m_shape; public: typedef std::vector<Point>::iterator iterator; typedef std::vector<Point>::const_iterator const_iterator; iterator begin() { return m_shape.container.begin(); } const_iterator begin() const { return m_shape.container.begin(); } iterator end() { return m_shape.container.end(); } const_iterator end() const { return m_shape.const_container.end(); } }
for (vector <Point>::iterator i = points.begin(); i != points.end(); ++i)
struct Point { int x; int y; Point() {} Point(int x, int y) : x(x), y(y) {} Point operator+(Point other) const { other.x += x; other.y += y; return other; } }; struct Shape { std::vector<Point> vec; }; struct Piece { Shape& shape; Point offset; Piece(Shape& shape, int x, int y) : shape(shape), offset(x,y) {} struct it_state { int pos; inline void next(const Piece* ref) { ++pos; } inline void begin(const Piece* ref) { pos = 0; } inline void end(const Piece* ref) { pos = ref->shape.vec.size(); } inline Point get(Piece* ref) { return ref->offset + ref->shape.vec[pos]; } inline bool cmp(const it_state& s) const { return pos != s.pos; } }; SETUP_ITERATORS(Piece, Point, it_state); };
int main() { Shape shape; shape.vec.emplace_back(1,2); shape.vec.emplace_back(2,3); shape.vec.emplace_back(3,4); Piece piece(shape, 1, 1); for (Point p : piece) { std::cout << p.x << " " << p.y << std::endl; } return 0; }
output = min + (rand() * (int)(max - min) / RAND_MAX)
output = min + (rand() % static_cast<int>(max - min + 1))
std::random_device rd; std::mt19937 rng(rd()); std::uniform_int_distribution<int> uni(min,max); auto random_integer = uni(rng);
int main() { typedef std::chrono::high_resolution_clock Clock; typedef std::chrono::duration<double> sec; Clock::time_point t0 = Clock::now(); const int N = 10000000; typedef std::minstd_rand G; G g; typedef std::uniform_int_distribution<> D; D d(-57, 365); int c = 0; for (int i = 0; i < N; ++i) c += d(g); Clock::time_point t1 = Clock::now(); std::cout << N/sec(t1-t0).count() << " random numbers per second.\n"; return c; }
typedef std::uniform_int_distribution<long long> D;
min = -57 max = 365 mean = 154.131 x_mean = 154 var = 14931.9 x_var = 14910.7 skew = -0.00197375 x_skew = 0 kurtosis = -1.20129 x_kurtosis = -1.20001
boost::mt19937 gen; int roll_die() { boost::uniform_int<> dist(1, 6); boost::variate_generator<boost::mt19937&, boost::uniform_int<> > die(gen, dist); return die(); }
int RandU(int nMin, int nMax) { return nMin + (int)((double)rand() / (RAND_MAX+1) * (nMax-nMin+1)); }
int r; do { r = rand(); } while (r < ((unsigned int)(RAND_MAX) + 1) % (high + 1 - low)); return r % (high + 1 - low) + low;
int randInInterval(int min, int max) { int intervalLen = max - min + 1; int ceilingPowerOf2 = pow(2, ceil(log2(intervalLen))); int randomNumber = rand() % ceilingPowerOf2; if (randomNumber < intervalLen) return min + randomNumber; return randInInterval(min, max); }
QDir dir("path/to/dir"); if (!dir.exists()) dir.mkpath(".");
QString folder= QString ("%1").arg(QDateTime::currentMSecsSinceEpoch()); while(QDir(folder).exists()) { folder= QString ("%1").arg(QDateTime::currentMSecsSinceEpoch()); } QDir().mkdir(folder);
struct foo { virtual void bar() = 0; }; void foo::bar() { } class foof : public foo { void bar() { foo::bar(); } };
struct IParams { IParams(const ModelConfiguration& aModelConf); virtual ~IParams() = 0; void setParameter(const N_Configuration::Parameter& aParam); std::map<std::string, std::string> m_Parameters; }; struct NumericsParams : IParams { NumericsParams(const ModelConfiguration& aNumericsConf); virtual ~NumericsParams(); double dt() const; double ti() const; double tf() const; }; struct PhysicsParams : IParams { PhysicsParams(const N_Configuration::ModelConfiguration& aPhysicsConf); virtual ~PhysicsParams(); double g() const; double rho_i() const; double rho_w() const; };
class Base { public: Base(); virtual ~Base() = 0; }; Base::Base() { cout << "Base Constructor" << endl; } Base::~Base() { cout << "Base Destructor" << endl; } class Derived : public Base { public: Derived(); ~Derived(); }; Derived::Derived() { cout << "Derived Constructor" << endl; } Derived::~Derived() { cout << "Derived Destructor" << endl; } int _tmain(int argc, _TCHAR* argv[]) { Base* pBase = new Derived(); delete pBase; Base* pBase2 = new Base(); }
class exception_string; class error_base : public std::exception { public: error_base(const char* error_message); error_base(const error_base& other); virtual ~error_base() = 0; virtual const char* what() const; private: std::auto_ptr<exception_string> error_message_; }; template<class error_type> class error : public error_base { public: error(const char* error_message) : error_base(error_message) {} error(const error& other) : error_base(other) {} ~error() {} }; class error_oh_shucks { virtual ~error_oh_shucks() = 0; } class error_oh_blast { virtual ~error_oh_blast() = 0; }
error_base::error_base(const char* error_message) : error_message_(new exception_string(error_message)) {} error_base::error_base(const error_base& other) : error_message_(new exception_string(other.error_message_->get())) {} error_base::~error_base() {} const char* error_base::what() const { return error_message_->get(); }
class exception_string { public: exception_string(const char* message) : message_(message) {} const char* get() const { return message_.c_str(); } private: std::string message_; };
try { } catch (const error<error_oh_shucks>&) { } catch (const error<error_oh_blast>&) { }
class Printable { virtual void print() const = 0; };
class Printer { void queDocument(unique_ptr<Printable> doc); void printAll(); };
class PostponedDestructor { void queObjectForDestruction(unique_ptr<Destroyable> obj); void destroyAll(); };
int i = 5; std::string s; std::stringstream out; out << i; s = out.str();
int main(int argc, char** argv) { std::string foo = boost::lexical_cast<std::string>(argc); }
char str[12]; int num = 3; sprintf(str, "%d", num);
std::stringstream str; str << myint; std::string result; str >> result;
string itoa(int a) { string ss=""; while(a) { int x=a%10; a/=10; char i= i=i+x; ss=i+ss; } return ss; }
template <typename T> string toStr(T tmp) { ostringstream out; out << tmp; return out.str(); } template <typename T> T strTo(string tmp) { T output; istringstream in(tmp); in >> output; return output; }
fastformat::fmt(result, "{0}", i); fastformat::write(result, i);
using namespace std; string intToString(int x) { /**************************************/ /* This function is similar to itoa() */ /* itoa() returned a C-string (null- */ /* terminated) */ /**************************************/ string r; stringstream s; s << x; r = s.str(); return r; } template <class T> string toString( T argument) { /**************************************/ /**************************************/ string r; stringstream s; s << argument; r = s.str(); return r; } int main( ) { string s; cout << "What directory would you like me to make?"; cin >> s; try { mkdir(s.c_str()); } catch (exception& e) { cerr << e.what( ) << endl; } chdir(s.c_str()); for(int i = 0; i < 10; i++) { s = "Dir_"; s = s + toString(i); mkdir(s.c_str()); } system("PAUSE"); return EXIT_SUCCESS; }
int number = 123; stringstream = s; s << number; cout << ss.str() << endl;
fmt::FormatInt(42).str(); fmt::FormatInt(42).c_str();
start = clock(); for (int i = LONG_MIN; i < LONG_MAX; i++) { if (i != atoi(_i32toa(buff, (int32_t)i))) { printf("\nError for %i", i); } if (!i) printf("\nAt zero"); } printf("\nElapsed time was %f milliseconds", (double)clock() - (double)(start));
int main() { char d = std::string y("Hello worl"); y.append(d); std::cout << y; return 0; }
int main() { char d[1] = { std::string y("Hello worl"); y.append(d); std::cout << y; return 0; }
std::string y("Hello worl"); y.push_back( std::cout << y;
long start = clock(); int a = 0; std::string ret; for (int i = 0; i < 60000000; i++) { ret.append(1, } long stop = clock(); long test = stop - start; return 0;
operation time(ms) note ------------------------------------------------------------------------ append 66015 += 67328 1.02 time slower than resize 83867 1.27 time slower than push_back & insert 90000 more than 1.36 time slower than
std::string y("Hello worl"); y.push_back( std::cout << y;
int main() { char d = std::string y("Hello worl"); y += d; y.push_back(d); y.append(1, d); y.insert(y.end(), 1, d); y.resize(y.size()+1, d); y += std::string(1, d); }
char list; std::string cmd, state[], Slist; Slist = list; cmd = Slist + state[x] + "whatever"; system(cmd.c_str());
std::map<K, V> map; for(auto i : map) if(needs_removing(i))
for (auto it = m.cbegin(); it != m.cend() ; ) { if (must_delete) { m.erase(it++); } else { ++it; } }
for (std::map<K,V>::iterator it = m.begin(); it != m.end(); ) { }
for (auto it = m.cbegin(), next_it = it; it != m.cend(); it = next_it) { ++next_it; if (must_delete) { m.erase(it); } }
/** * @brief Erases an element from a %map. * @param position An iterator pointing to the element to be erased. * @return An iterator pointing to the element immediately following * @a position prior to the element being erased. If no such * element exists, end() is returned. * * This function erases an element, pointed to by the given * iterator, from a %map. Note that this function only erases * the element, and that if the element is itself a pointer, * the pointed-to memory is not touched in any way. Managing * the pointer is the user */ iterator erase(iterator __position) { return _M_t.erase(__position); } /** * @brief Erases an element from a %map. * @param position An iterator pointing to the element to be erased. * * This function erases an element, pointed to by the given * iterator, from a %map. Note that this function only erases * the element, and that if the element is itself a pointer, * the pointed-to memory is not touched in any way. Managing * the pointer is the user */ void erase(iterator __position) { _M_t.erase(__position); }
using namespace std; typedef map<int, int> t_myMap; typedef vector<t_myMap::key_type> t_myVec; int main() { cout << "main() ENTRY" << endl; t_myMap mi; mi.insert(t_myMap::value_type(1,1)); mi.insert(t_myMap::value_type(2,1)); mi.insert(t_myMap::value_type(3,1)); mi.insert(t_myMap::value_type(4,1)); mi.insert(t_myMap::value_type(5,1)); mi.insert(t_myMap::value_type(6,1)); cout << "Init" << endl; for(t_myMap::const_iterator i = mi.begin(); i != mi.end(); i++) cout << t_myVec markedForDeath; for (t_myMap::const_iterator it = mi.begin(); it != mi.end() ; it++) if (it->first > 2 && it->first < 5) markedForDeath.push_back(it->first); for(size_t i = 0; i < markedForDeath.size(); i++) mi.erase(markedForDeath[i]); cout << "after old style erase of 3 & 4.." << endl; for(t_myMap::const_iterator i = mi.begin(); i != mi.end(); i++) cout << for (auto it = mi.begin(); it != mi.end(); ) { if (it->first == 5) it = mi.erase(it); else ++it; } cout << "after new style erase of 5" << endl; for_each(mi.cbegin(), mi.cend(), [](t_myMap::const_reference it){cout << return 0; }
main() ENTRY Init 1-1 2-1 3-1 4-1 5-1 6-1 after old style erase of 3 & 4.. 1-1 2-1 5-1 6-1 after new style erase of 5 1-1 2-1 6-1 Process returned 0 (0x0) execution time : 0.021 s Press any key to continue.
std::map<K,V> map; std::list< std::map<K,V>::iterator > iteratorList; for(auto i : map ){ if ( needs_removing(i)){ iteratorList.push_back(i); } } for(auto i : iteratorList){ map.erase(*i) }
using Map = std::map<K,V>; Map map; for (Map::const_iterator itr = map.cbegin() ; itr != map.cend() ; ) itr = needs_removing(itr) ? map.erase(itr) : std::next(itr);
int main(int argc, char* argv[]) int main(int argc, char** argv)
class Device { }; class Settings { Device *device; public: Settings(Device *device) { this->device = device; } Device *getDevice() { return device; } }; int main() { Device *device = new Device(); Settings settings(device); Device *myDevice = settings.getDevice(); }
class Device { }; class Settings { std::shared_ptr<Device> device; public: Settings(std::shared_ptr<Device> device) { this->device = device; } std::weak_ptr<Device> getDevice() { return device; } }; int main() { std::shared_ptr<Device> device(new Device()); Settings settings(device); std::weak_ptr<Device> myDevice = settings.getDevice(); }
class Device { }; class Settings { std::unique_ptr<Device> device; public: Settings(std::unique_ptr<Device> d) { device = std::move(d); } Device* getDevice() { return device.get(); } }; int main() { std::unique_ptr<Device> device(new Device()); Settings settings(std::move(device)); Device *myDevice = settings.getDevice(); }
class Device { }; class Settings { std::shared_ptr<Device> device; public: Settings(std::shared_ptr<Device> const& d) { device = d; } std::shared_ptr<Device> getDevice() { return device; } }; int main() { std::shared_ptr<Device> device = std::make_shared<Device>(); Settings settings(device); std::shared_ptr<Device> myDevice = settings.getDevice(); }
class Device { }; class Settings { std::shared_ptr<Device> device; public: Settings(const std::shared_ptr<Device>& device) : device(device) { } const std::shared_ptr<Device>& getDevice() { return device; } }; int main() { std::shared_ptr<Device> device(new Device()); Settings settings(device); std::shared_ptr<Device> myDevice(settings.getDevice()); return 0; }
MOCK_BASE_CLASS( mock_view, view ) { MOCK_METHOD( display, 1 ) }; BOOST_AUTO_TEST_CASE( zero_plus_zero_is_zero ) { mock_view v; calculator c( v ); MOCK_EXPECT( v, display ).once().with( 0 ); c.add( 0, 0 ); }
namespace ublas = boost::numeric::ublas; ublas::vector<double> v;
namespace Mine { class MyClass { public: int i; }; } namespace His = Mine; namespace Yours { class Mine: public His::MyClass { void f() { i = 1; } }; }
namespace Nope { class Oops { public: int j; }; } namespace Drat { class Nope: public Hmm::Oops { void f () { j = 1; } }; }
namespace A { int foo; namespace AA { int bar; } namespace AB { int bar; } } namespace B { int foo; namespace BA { int bar; } namespace BB { int bar; } } bool nsChooser1, nsChooser2; namespace C = (nsChooser1 ? A : B); C::foo = 3; if (nsChooser1) if (nsChooser2) using namespace A::AA; else using namespace A::AB; else if (nsChooser2) using namespace B::BA; else using namespace B::BB;
int& foo = (nsChooser1 ? A::foo : B::foo); int* bar; if (nsChooser1) { if (nsChooser2) { bar = &A::AA::bar; } else { bar = &A::AB::bar; } } else { if (nsChooser2) { bar = &B::BA::bar; } else { bar = &B::BB::bar; } }
namespace foo { class bar { }; } namespace baz { class bar { }; }
class X { }; X x1; class X::X x2; class X::X::X x3;
void X() { } class X { public: static X create() { return X(); } };
std::complex<long double> operator "" _i(long double d) { return std::complex<long double>(0, d); } auto val = 3.14_i; int operator "" _B(const char*); int answer = 101010_B; std::string operator "" _s(const char* str, size_t ) { return std::string(str); } auto hi = "hello"_s + " world"; assert(1_kg == 2.2_lb);
template<char... Bits> struct checkbits { static const bool valid = false; }; template<char High, char... Bits> struct checkbits<High, Bits...> { static const bool valid = (High == && checkbits<Bits...>::valid; }; template<char High> struct checkbits<High> { static const bool valid = (High == }; template<char... Bits> inline constexpr std::bitset<sizeof...(Bits)> operator"" _bits() noexcept { static_assert(checkbits<Bits...>::valid, "invalid digit in binary string"); return std::bitset<sizeof...(Bits)>((char []){Bits..., } int main() { auto bits = 0101010101010101010101010101010101010101010101010101010101010101_bits; std::cout << bits << std::endl; std::cout << "size = " << bits.size() << std::endl; std::cout << "count = " << bits.count() << std::endl; std::cout << "value = " << bits.to_ullong() << std::endl; auto badbits = 2101010101010101010101010101010101010101010101010101010101010101_bits; std::bitset<64> badbits2("2101010101010101010101010101010101010101010101010101010101010101_bits"); }
MyComplex z1 = { 1, 2 } ; double complex z1 = 1 + 2*I; std::complex<double> z1(1, 2) ; std::complex<double> z1 = 1 + 2_i ;
css::Font::Size p0 = 12_pt ; css::Font::Size p1 = 50_percent ; css::Font::Size p2 = 15_px ; css::Font::Size p3 = 10_em ; css::Font::Size p4 = 15 ;
"1974-01-06"_AD ; "06/01/1974"_AD ; "jan 06 1974"_AD ; 19740106_AD ;
double operator ""_deg(long double d) { return d*M_PI/180; }
int operator ""_fix(long double d) { return (int)(d*65536.0f); }
typedef ::ecore::Class< Attribute<int>, Attribute<int> > MyClass;
typedef ::ecore::Class< "MyClass", Attribute< "x", int>, Attribute<"y", int> > MyClass;
typedef ::ecore::Class< MyClass_n, Attribute< x_n, int>, Attribute<y_n, int> > MyClass;
auto force = 2_N; auto dx = 2_m; auto energy = force * dx; assert(energy == 4_J);
std::complex<double> operator ""_i(long double d) { return std::complex(0, d); }
typedef std::complex<double> complex; complex val = std::complex(0, 3.14);
A o1, o2, o3; o1.foo(); o2.foo(); o3.foo(); o1.foo();
template<int num> void bar() { static int baz; printf("bar<%i>::baz = %i\n", num, baz++); } int main() { bar<1>(); bar<2>(); bar<3>(); bar<1>(); bar<2>(); bar<3>(); bar<1>(); bar<2>(); bar<3>(); return 0; }
if (typeid(a) == typeid(b)) { B* ba = static_cast<B*>(&a); etc; }
1) dynamic_cast< FireType* >( mDelegate ) 2) typeid( *iDelegate ) == typeid( *mDelegate ) 3) typeid( *iDelegate ).name() == typeid( *mDelegate ).name() 4) &typeid( *iDelegate ) == &typeid( *mDelegate ) 5) { fastdelegate::FastDelegateBase *iDelegate; iDelegate = new fastdelegate::FastDelegate1< t1 >; typeid( *iDelegate ) == typeid( *mDelegate ) }
1) 1,840,000 Ticks (~2 Seconds) - dynamic_cast 2) 870,000 Ticks (~1 Second) - typeid() 3) 890,000 Ticks (~1 Second) - typeid().name() 4) 615,000 Ticks (~1 Second) - &typeid() 5) 14,261,000 Ticks (~23 Seconds) - typeid() with extra variable allocations.
1) 1,356,000 Ticks - dynamic_cast 2) 76,000 Ticks - typeid() 3) 76,000 Ticks - typeid().name() 4) 75,000 Ticks - &typeid() 5) 75,000 Ticks - typeid() with extra variable allocations.
class ZoomManager { public: template < class Observer, class t1 > void Subscribe( void *aObj, void (Observer::*func )( t1 a1 ) ) { mDelegate = new fastdelegate::FastDelegate1< t1 >; std::cout << "Subscribe\n"; Fire( true ); } template< class t1 > void Fire( t1 a1 ) { fastdelegate::FastDelegateBase *iDelegate; iDelegate = new fastdelegate::FastDelegate1< t1 >; int t = 0; ticks start = getticks(); clock_t iStart, iEnd; iStart = clock(); typedef fastdelegate::FastDelegate1< t1 > FireType; for ( int i = 0; i < 100000000; i++ ) { if ( dynamic_cast< FireType* >( mDelegate ) ) if ( typeid( *iDelegate ) == typeid( *mDelegate ) ) { t++; } else { t--; } } iEnd = clock(); printf("Clock ticks: %i,\n", iEnd - iStart ); std::cout << typeid( *mDelegate ).name()<<"\n"; ticks end = getticks(); double e = elapsed(start, end); std::cout << "Elasped: " << e; } template< class t1, class t2 > void Fire( t1 a1, t2 a2 ) { std::cout << "Fire\n"; } fastdelegate::FastDelegateBase *mDelegate; }; class Scaler { public: Scaler( ZoomManager *aZoomManager ) : mZoomManager( aZoomManager ) { } void Sub() { mZoomManager->Subscribe( this, &Scaler::OnSizeChanged ); } void OnSizeChanged( int X ) { std::cout << "Yey!\n"; } private: ZoomManager *mZoomManager; }; int main(int argc, const char * argv[]) { ZoomManager *iZoomManager = new ZoomManager(); Scaler iScaler( iZoomManager ); iScaler.Sub(); delete iZoomManager; return 0; }
struct Base { virtual ~Base() {} }; struct Derived { virtual ~Derived() {} }; int main() { Base *d = new Derived(); const char *name = typeid(*d).name(); const vtable *vt = reinterpret_cast<vtable *>(d); type_info *ti = vt->typeinfo; const char *name = ProcessRawName(ti->name); }
using namespace std; enum AnimalClassTypeTag { TypeAnimal=1, TypeCat=1<<2,TypeBigCat=1<<3,TypeDog=1<<4 } ; struct Animal { int typeTag ; Animal() { typeTag=TypeAnimal; } virtual ~Animal(){} } ; struct Cat : public Animal { Cat(){ typeTag|=TypeCat; } } ; struct BigCat : public Cat { BigCat(){ typeTag|=TypeBigCat; } } ; struct Dog : public Animal { Dog(){ typeTag|=TypeDog; } } ; typedef unsigned long long ULONGLONG; void dynamicCasts(vector<Animal*> &zoo, ULONGLONG tests) { ULONGLONG animals=0,cats=0,bigcats=0,dogs=0; for( ULONGLONG i = 0 ; i < tests ; i++ ) { for( Animal* an : zoo ) { if( dynamic_cast<Dog*>( an ) ) dogs++; else if( dynamic_cast<BigCat*>( an ) ) bigcats++; else if( dynamic_cast<Cat*>( an ) ) cats++; else animals++; } } printf( "%lld animals, %lld cats, %lld bigcats, %lld dogs\n", animals,cats,bigcats,dogs ) ; } void regularSwitch(vector<Animal*> &zoo, ULONGLONG tests) { ULONGLONG animals=0,cats=0,bigcats=0,dogs=0; for( ULONGLONG i = 0 ; i < tests ; i++ ) { for( Animal* an : zoo ) { if( an->typeTag & TypeDog ) dogs++; else if( an->typeTag & TypeBigCat ) bigcats++; else if( an->typeTag & TypeCat ) cats++; else animals++; } } printf( "%lld animals, %lld cats, %lld bigcats, %lld dogs\n", animals,cats,bigcats,dogs ) ; } int main(int argc, const char * argv[]) { vector<Animal*> zoo ; zoo.push_back( new Animal ) ; zoo.push_back( new Cat ) ; zoo.push_back( new BigCat ) ; zoo.push_back( new Dog ) ; ULONGLONG tests=50000000; dynamicCasts( zoo, tests ) ; regularSwitch( zoo, tests ) ; }
cout << (typeid(Base).name() == typeid(Derived).name()) << endl;
cout << (&typeid(Base) == &typeid(Derived)) << endl;
cout << ( typeid(Base).name() == typeid(Derived).name() || typeid(Base) == typeid(Derived) ) << endl;
using namespace std; struct Base { virtual ~Base() {} virtual char Type() const = 0; }; struct A : public Base { char Type() const { return } }; struct B : public Base {; char Type() const { return } }; int main() { Base * bp = new A; int n = 0; for ( int i = 0; i < 10000000; i++ ) { if ( A * a = dynamic_cast <A*> ( bp ) ) { n++; } if ( bp->Type() == A * a = static_cast <A*>(bp); n++; } } cout << n << endl; }
vptr_of_C = [ vptr_of_A | vptr_of_new_methods_in_B | vptr_of_new_methods_in_C ]
void * something = [...]; MyClass * c = dynamic_cast<MyClass*>(something);
K t; V u; std::map<K,V> m; m.insert( std::pair<const K,V>(t,u) ); m.insert( std::map<K,V>::value_type(t,u) ); m.insert( std::make_pair(t,u) );
template <typename T, typename U> std::pair<T,U> make_pair(T const & t, U const & u );
struct foo { explicit foo(int); }; int main() { std::vector<foo> v; v.emplace(v.end(), 10); v.insert(v.end(), foo(10)); }
struct Foo { static int foo_counter; int val; Foo() { val = foo_counter++; std::cout << "Foo() with val: " << val << } Foo(int value) : val(value) { foo_counter++; std::cout << "Foo(int) with val: " << val << } Foo(Foo& f2) { val = foo_counter++; std::cout << "Foo(Foo &) with val: " << val << " \tcreated from: \t" << f2.val << } Foo(const Foo& f2) { val = foo_counter++; std::cout << "Foo(const Foo &) with val: " << val << " \tcreated from: \t" << f2.val << } Foo(Foo&& f2) { val = foo_counter++; std::cout << "Foo(Foo&&) moving: " << f2.val << " \tand changing it to:\t" << val << } ~Foo() { std::cout << "~Foo() destroying: " << val << Foo& operator=(const Foo& rhs) { std::cout << "Foo& operator=(const Foo& rhs) with rhs.val: " << rhs.val << " \tcalled with lhs.val = \t" << val << " \tChanging lhs.val to: \t" << rhs.val << val = rhs.val; return *this; } bool operator==(const Foo &rhs) const { return val == rhs.val; } bool operator<(const Foo &rhs) const { return val < rhs.val; } }; int Foo::foo_counter = 0; namespace std { template<> struct hash<Foo> { std::size_t operator()(const Foo &f) const { return std::hash<int>{}(f.val); } }; } int main() { std::unordered_map<Foo, int> umap; Foo foo0, foo1, foo2, foo3; int d; std::cout << "\numap.insert(std::pair<Foo, int>(foo0, d))\n"; umap.insert(std::pair<Foo, int>(foo0, d)); std::cout << "\numap.insert(std::move(std::pair<Foo, int>(foo1, d)))\n"; umap.insert(std::move(std::pair<Foo, int>(foo1, d))); std::cout << "\nstd::pair<Foo, int> pair(foo2, d)\n"; std::pair<Foo, int> pair(foo2, d); std::cout << "\numap.insert(pair)\n"; umap.insert(pair); std::cout << "\numap.emplace(foo3, d)\n"; umap.emplace(foo3, d); std::cout << "\numap.emplace(11, d)\n"; umap.emplace(11, d); std::cout << "\numap.insert({12, d})\n"; umap.insert({12, d}); std::cout.flush(); }
Foo() with val: 0 Foo() with val: 1 Foo() with val: 2 Foo() with val: 3 umap.insert(std::pair<Foo, int>(foo0, d)) Foo(Foo &) with val: 4 created from: 0 Foo(Foo&&) moving: 4 and changing it to: 5 ~Foo() destroying: 4 umap.insert(std::move(std::pair<Foo, int>(foo1, d))) Foo(Foo &) with val: 6 created from: 1 Foo(Foo&&) moving: 6 and changing it to: 7 ~Foo() destroying: 6 std::pair<Foo, int> pair(foo2, d) Foo(Foo &) with val: 8 created from: 2 umap.insert(pair) Foo(const Foo &) with val: 9 created from: 8 umap.emplace(foo3, d) Foo(Foo &) with val: 10 created from: 3 umap.emplace(11, d) Foo(int) with val: 11 umap.insert({12, d}) Foo(int) with val: 12 Foo(const Foo &) with val: 13 created from: 12 ~Foo() destroying: 12 ~Foo() destroying: 8 ~Foo() destroying: 3 ~Foo() destroying: 2 ~Foo() destroying: 1 ~Foo() destroying: 0 ~Foo() destroying: 13 ~Foo() destroying: 11 ~Foo() destroying: 5 ~Foo() destroying: 10 ~Foo() destroying: 7 ~Foo() destroying: 9
std::cout << "\numap.insert({{" << Foo::foo_counter << ", d}})\n"; umap.insert({{Foo::foo_counter, d}}); std::cout << "\numap.insert(std::pair<const Foo, int>({" << Foo::foo_counter << ", d}))\n"; umap.insert(std::pair<const Foo, int>({Foo::foo_counter, d})); std::cout << "\numap.insert(std::pair<Foo, int>({" << Foo::foo_counter << ", d}))\n"; umap.insert(std::pair<Foo, int>({Foo::foo_counter, d})); std::cout << "\numap.insert({std::pair<Foo, int>({" << Foo::foo_counter << ", d})})\n"; umap.insert({std::pair<Foo, int>({Foo::foo_counter, d})}); int cur_foo_counter = Foo::foo_counter; std::cout << "\numap.insert({{cur_foo_counter, d}, {cur_foo_counter+1, d}}) where " << "cur_foo_counter = " << cur_foo_counter << "\n"; umap.insert({{cur_foo_counter, d}, {cur_foo_counter+1, d}}); std::cout << "\numap.insert({{Foo::foo_counter, d}, {Foo::foo_counter+1, d}}) where " << "Foo::foo_counter = " << Foo::foo_counter << "\n"; umap.insert({{Foo::foo_counter, d}, {Foo::foo_counter+1, d}}); std::cout << "\numap.insert(std::initializer_list<std::pair<const Foo, int>>({{" << Foo::foo_counter << ", d}}))\n"; umap.insert(std::initializer_list<std::pair<const Foo, int>>({{Foo::foo_counter, d}}));
configure.exe -release -no-webkit -no-phonon -no-phonon-backend -no-script -no-scripttools -no-qt3support -no-multimedia -no-ltcg
std::string stHehe("Hello "); stHehe += "stackoverflow.com"; stHehe += "!";
MyClass::MyClass(int numItems) { mNumItems = numItems; for (int iItem = 0; iItem < mNumItems; iItem++) { Item *pItem = new Item(); itemList[iItem] = pItem; } }
for (int i = 0; i < 100; i++) for (int j = 0; j < 5; j++) list[i].score += other[j].score;
for (int iCompany = 0; iCompany < numCompanies; iCompany++) for (int iUser = 0; iUser < numUsers; iUser++) companyList[iCompany].score += userList[iUser].score;
class Foo { private: int bar_; public: int bar() { return bar_; } };
void Foo::bar( int apples ) { int bananas = apples + grapes; melons = grapes * bananas; spuds += melons; }
void Foo::bar( int apples ) { int bananas = apples + g_grapes; m_melons = g_grapes * bananas; s_spuds += m_melons; }
void Foo::bar( int iApples ) { int iBananas = iApples + g_fGrapes; m_fMelons = g_fGrapes * iBananas; s_dSpuds += m_fMelons; }
class person { public: person(const std::string& full_name) : full_name_(full_name) {} const std::string& full_name() const { return full_name_; } private: std::string full_name_; };
void myFunc(int index){ this->index = index; } void myFunc(int index){ m_index = index; }
private int privateMember; public int PublicMember; public int Function(int parameter) { this.privateMember = parameter; }
void MyClass::SetName(const RWCString &theName) { itsName = theName; }
class Person { std::string m_Name; public: std::string Name() { return m_Name; } void SetName(std::string name) { m_Name = name; } }; int main() { Person *p = new Person(); p->Name(); p->m_Name; return 1; }
Error 1 fatal error C1083: Cannot open precompiled header file:
<ClCompile Include="stdafx.cpp"> <PrecompiledHeader Condition=
[[deprecated("Replaced by bar, which has an improved interface")]] void foo(int);
... DEPRECATED(void OldFunc(int a, float b)); void NewFunc(int a, double b);
DEPRECATED void OldFunc(int a, float b); void NewFunc(int a, double b);
HEDLEY_GCC_HAS_EXTENSION(attribute_deprecated_with_message,4,5,0) || \ HEDLEY_INTEL_VERSION_CHECK(16,0,0) || \ HEDLEY_ARM_VERSION_CHECK(5,6,0) HEDLEY_GCC_HAS_ATTRIBUTE(deprcated,4,0,0) || \ HEDLEY_ARM_VERSION_CHECK(4,1,0)
Mat t_mean, t_mean_2; Mat grayF; outImg_gray.convertTo(grayF, CV_32F); int winSize = 35; blur(grayF, t_mean, cv::Size(winSize,winSize)); blur(grayF.mul(grayF), t_mean_2, cv::Size(winSize,winSize)); Mat varMat = t_mean_2 - t_mean.mul(t_mean); varMat.convertTo(varMat, CV_8U); Mat varMatRegions = varMat > 100;
std::vector<cv::Rect> detectLetters(cv::Mat img) { std::vector<cv::Rect> boundRect; cv::Mat img_gray, img_sobel, img_threshold, element; cvtColor(img, img_gray, CV_BGR2GRAY); cv::Sobel(img_gray, img_sobel, CV_8U, 1, 0, 3, 1, 0, cv::BORDER_DEFAULT); cv::threshold(img_sobel, img_threshold, 0, 255, CV_THRESH_OTSU+CV_THRESH_BINARY); element = getStructuringElement(cv::MORPH_RECT, cv::Size(17, 3) ); cv::morphologyEx(img_threshold, img_threshold, CV_MOP_CLOSE, element); std::vector< std::vector< cv::Point> > contours; cv::findContours(img_threshold, contours, 0, 1); std::vector<std::vector<cv::Point> > contours_poly( contours.size() ); for( int i = 0; i < contours.size(); i++ ) if (contours[i].size()>100) { cv::approxPolyDP( cv::Mat(contours[i]), contours_poly[i], 3, true ); cv::Rect appRect( boundingRect( cv::Mat(contours_poly[i]) )); if (appRect.width>appRect.height) boundRect.push_back(appRect); } return boundRect; }
int main(int argc,char** argv) { cv::Mat img1=cv::imread("side_1.jpg"); cv::Mat img2=cv::imread("side_2.jpg"); std::vector<cv::Rect> letterBBoxes1=detectLetters(img1); std::vector<cv::Rect> letterBBoxes2=detectLetters(img2); for(int i=0; i< letterBBoxes1.size(); i++) cv::rectangle(img1,letterBBoxes1[i],cv::Scalar(0,255,0),3,8,0); cv::imwrite( "imgOut1.jpg", img1); for(int i=0; i< letterBBoxes2.size(); i++) cv::rectangle(img2,letterBBoxes2[i],cv::Scalar(0,255,0),3,8,0); cv::imwrite( "imgOut2.jpg", img2); return 0; }
The MIT License (MIT) Copyright (c) 2014 Dhanushka Dangampola Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. using namespace cv; using namespace std; int _tmain(int argc, _TCHAR* argv[]) { Mat large = imread(INPUT_FILE); Mat rgb; pyrDown(large, rgb); Mat small; cvtColor(rgb, small, CV_BGR2GRAY); Mat grad; Mat morphKernel = getStructuringElement(MORPH_ELLIPSE, Size(3, 3)); morphologyEx(small, grad, MORPH_GRADIENT, morphKernel); Mat bw; threshold(grad, bw, 0.0, 255.0, THRESH_BINARY | THRESH_OTSU); Mat connected; morphKernel = getStructuringElement(MORPH_RECT, Size(9, 1)); morphologyEx(bw, connected, MORPH_CLOSE, morphKernel); Mat mask = Mat::zeros(bw.size(), CV_8UC1); vector<vector<Point>> contours; vector<Vec4i> hierarchy; findContours(connected, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE, Point(0, 0)); for(int idx = 0; idx >= 0; idx = hierarchy[idx][0]) { Rect rect = boundingRect(contours[idx]); Mat maskROI(mask, rect); maskROI = Scalar(0, 0, 0); drawContours(mask, contours, idx, Scalar(255, 255, 255), CV_FILLED); double r = (double)countNonZero(maskROI)/(rect.width*rect.height); if (r > .45 && (rect.height > 8 && rect.width > 8) ) { rectangle(rgb, rect, Scalar(0, 255, 0), 2); } } imwrite(OUTPUT_FOLDER_PATH + string("rgb.jpg"), rgb); return 0; }
The MIT License (MIT) Copyright (c) 2017 Dhanushka Dangampola Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. import cv2 import numpy as np large = cv2.imread( rgb = cv2.pyrDown(large) small = cv2.cvtColor(rgb, cv2.COLOR_BGR2GRAY) kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)) grad = cv2.morphologyEx(small, cv2.MORPH_GRADIENT, kernel) _, bw = cv2.threshold(grad, 0.0, 255.0, cv2.THRESH_BINARY | cv2.THRESH_OTSU) kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (9, 1)) connected = cv2.morphologyEx(bw, cv2.MORPH_CLOSE, kernel) contours, hierarchy = cv2.findContours(connected.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) mask = np.zeros(bw.shape, dtype=np.uint8) for idx in range(len(contours)): x, y, w, h = cv2.boundingRect(contours[idx]) mask[y:y+h, x:x+w] = 0 cv2.drawContours(mask, contours, idx, (255, 255, 255), -1) r = float(cv2.countNonZero(mask[y:y+h, x:x+w])) / (w * h) if r > 0.45 and w > 8 and h > 8: cv2.rectangle(rgb, (x, y), (x+w-1, y+h-1), (0, 255, 0), 2) cv2.imshow(
import cv2 image = cv2.imread("card.png") gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) _,thresh = cv2.threshold(gray,150,255,cv2.THRESH_BINARY_INV) kernel = cv2.getStructuringElement(cv2.MORPH_CROSS,(3,3)) dilated = cv2.dilate(thresh,kernel,iterations = 13) _, contours, hierarchy = cv2.findContours(dilated,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_NONE) for contour in contours: [x,y,w,h] = cv2.boundingRect(contour) if h>300 and w>300: continue if h<40 or w<40: continue cv2.rectangle(image,(x,y),(x+w,y+h),(255,0,255),2) cv2.imwrite("contoured.jpg", image)
import cv2 import numpy as np from cv2 import boundingRect, countNonZero, cvtColor, drawContours, findContours, getStructuringElement, imread, morphologyEx, pyrDown, rectangle, threshold large = imread(image_path) rgb = pyrDown(large) small = cvtColor(rgb, cv2.COLOR_BGR2GRAY) morph_kernel = getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)) grad = morphologyEx(small, cv2.MORPH_GRADIENT, morph_kernel) _, bw = threshold(src=grad, thresh=0, maxval=255, type=cv2.THRESH_BINARY+cv2.THRESH_OTSU) morph_kernel = getStructuringElement(cv2.MORPH_RECT, (9, 1)) connected = morphologyEx(bw, cv2.MORPH_CLOSE, morph_kernel) mask = np.zeros(bw.shape, np.uint8) im2, contours, hierarchy = findContours(connected, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE) for idx in range(0, len(hierarchy[0])): rect = x, y, rect_width, rect_height = boundingRect(contours[idx]) mask = drawContours(mask, contours, idx, (255, 255, 2555), cv2.FILLED) r = float(countNonZero(mask)) / (rect_width * rect_height) if r > 0.45 and rect_height > 8 and rect_width > 8: rgb = rectangle(rgb, (x, y+rect_height), (x+rect_width, y), (0,255,0),3)
public static List<Rect> detectLetters(Mat img){ List<Rect> boundRect=new ArrayList<>(); Mat img_gray =new Mat(), img_sobel=new Mat(), img_threshold=new Mat(), element=new Mat(); Imgproc.cvtColor(img, img_gray, Imgproc.COLOR_RGB2GRAY); Imgproc.Sobel(img_gray, img_sobel, CvType.CV_8U, 1, 0, 3, 1, 0, Core.BORDER_DEFAULT); Imgproc.threshold(img_sobel, img_threshold, 0, 255, 8); element=Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(15,5)); Imgproc.morphologyEx(img_threshold, img_threshold, Imgproc.MORPH_CLOSE, element); List<MatOfPoint> contours = new ArrayList<MatOfPoint>(); Mat hierarchy = new Mat(); Imgproc.findContours(img_threshold, contours,hierarchy, 0, 1); List<MatOfPoint> contours_poly = new ArrayList<MatOfPoint>(contours.size()); for( int i = 0; i < contours.size(); i++ ){ MatOfPoint2f mMOP2f1=new MatOfPoint2f(); MatOfPoint2f mMOP2f2=new MatOfPoint2f(); contours.get(i).convertTo(mMOP2f1, CvType.CV_32FC2); Imgproc.approxPolyDP(mMOP2f1, mMOP2f2, 2, true); mMOP2f2.convertTo(contours.get(i), CvType.CV_32S); Rect appRect = Imgproc.boundingRect(contours.get(i)); if (appRect.width>appRect.height) { boundRect.add(appRect); } } return boundRect; }
System.loadLibrary(Core.NATIVE_LIBRARY_NAME); Mat img1=Imgcodecs.imread("abc.png"); List<Rect> letterBBoxes1=Utils.detectLetters(img1); for(int i=0; i< letterBBoxes1.size(); i++) Imgproc.rectangle(img1,letterBBoxes1.get(i).br(), letterBBoxes1.get(i).tl(),new Scalar(0,255,0),3,8,0); Imgcodecs.imwrite("abc1.png", img1);
def process_rgb(rgb): hasText = 0 gray = cv2.cvtColor(rgb, cv2.COLOR_BGR2GRAY); morphKernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3)) grad = cv2.morphologyEx(gray, cv2.MORPH_GRADIENT, morphKernel) _, bw = cv2.threshold(grad, 0.0, 255.0, cv2.THRESH_BINARY | cv2.THRESH_OTSU) morphKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (9, 1)) connected = cv2.morphologyEx(bw, cv2.MORPH_CLOSE, morphKernel) mask = np.zeros(bw.shape[:2], dtype="uint8"); _,contours, hierarchy = cv2.findContours(connected, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE) idx = 0 while idx >= 0: x,y,w,h = cv2.boundingRect(contours[idx]); cv2.drawContours(mask, contours, idx, (255, 255, 255), cv2.FILLED); r = cv2.contourArea(contours[idx])/(w*h) if(r > 0.45 and h > 5 and w > 5 and w > h): cv2.rectangle(rgb, (x,y), (x+w,y+h), (0, 255, 0), 2) hasText = 1 idx = hierarchy[0][idx][0] return hasText, rgb
std::string str(static_cast<std::stringstream const&>(std::stringstream() << in.rdbuf()).str());
std::string slurp(std::ifstream& in) { std::stringstream sstr; sstr << in.rdbuf(); return sstr.str(); }
std::string slurp(std::ifstream& in) { return static_cast<std::stringstream const&>(std::stringstream() << in.rdbuf()).str(); }
string readFile2(const string &fileName) { ifstream ifs(fileName.c_str(), ios::in | ios::binary | ios::ate); ifstream::pos_type fileSize = ifs.tellg(); ifs.seekg(0, ios::beg); vector<char> bytes(fileSize); ifs.read(bytes.data(), fileSize); return string(bytes.data(), fileSize); }
std::string str(std::istreambuf_iterator<char>{ifs}, {});
int main() { std::ifstream input("file.txt"); std::stringstream sstr; while(input >> sstr.rdbuf()); std::cout << sstr.str() << std::endl; }
... std::streamsize size = file.tellg(); std::vector<char> buffer(size); ...
string readFile2(const string &fileName) { ifstream ifs(fileName.c_str(), ios::in | ios::binary | ios::ate); ifstream::pos_type fileSize = ifs.tellg(); if (fileSize < 0) <--- ADDED return std::string(); <--- ADDED ifs.seekg(0, ios::beg); vector<char> bytes(fileSize); ifs.read(&bytes[0], fileSize); return string(&bytes[0], fileSize); }
namespace fs = std::filesystem; std::string readFile(fs::path path) { std::ifstream f{ path }; const auto sz = fs::file_size(path); std::string result(sz, f.read(result.data(), sz); return result; }
void slurp(std::string& data, const std::string& filename, bool is_binary) { std::ios_base::openmode openmode = ios::ate | ios::in; if (is_binary) openmode |= ios::binary; ifstream file(filename.c_str(), openmode); data.clear(); data.reserve(file.tellg()); file.seekg(0, ios::beg); data.append(istreambuf_iterator<char>(file.rdbuf()), istreambuf_iterator<char>()); }
std::string file_to_string(const std::string& file_name) { std::ifstream file_stream{file_name}; if (file_stream.fail()) { } std::ostringstream str_stream{}; file_stream >> str_stream.rdbuf(); if (file_stream.fail() && !file_stream.eof()) { } return str_stream.str(); }
std::string data; std::ifstream in( "test.txt" ); std::getline( in, data, std::string::traits_type::to_char_type( std::string::traits_type::eof() ) );
struct A { virtual void f(int a = 7); }; struct B : public A { void f(int a); }; void m() { B* pb = new B; A* pa = pb; pa->f(); pb->f(); }
using std::stringstream; using std::string; using std::cout; using std::endl; struct Base { virtual string Speak(int n = 42); }; struct Der : public Base { string Speak(int n = 84); }; string Base::Speak(int n) { stringstream ss; ss << "Base " << n; return ss.str(); } string Der::Speak(int n) { stringstream ss; ss << "Der " << n; return ss.str(); } int main() { Base b1; Der d1; Base *pb1 = &b1, *pb2 = &d1; Der *pd1 = &d1; cout << pb1->Speak() << "\n" << pb2->Speak() << "\n" << pd1->Speak() << "\n" << endl; }
class A { virtual void foo(int i = 1) { cout << "A::foo" << i << endl; } }; class B: public A { virtual void foo(int i = 2) { cout << "B::foo" << i << endl; } }; void test() { A a; B b; A* ap = &b; a.foo(); b.foo(); ap->foo(); }
struct base { virtual void x(int a=0) { std::cout << a; } virtual ~base() {} }; struct derived1 : base { void x(int a) { std:: cout << a; } }; struct derived2 : base { void x(int a = 1) { std::cout << a; } }; int main() { base *b[3]; b[0] = new base; b[1] = new derived1; b[2] = new derived2; for (int i=0; i<3; i++) { b[i]->x(); delete b[i]; } derived1 d; derived2 d2; d2.x(); return 0; }
struct A { virtual void display(int i = 5) { std::cout << "Base::" << i << "\n"; } }; struct B : public A { virtual void display(int i = 9) override { std::cout << "Derived::" << i << "\n"; } }; int main() { A * a = new B(); a->display(); A* aa = new A(); aa->display(); B* bb = new B(); bb->display(); }
A * a = new B(); a->display(5); A* aa = new A(); aa->display(5); B* bb = new B(); bb->display(9);
struct Param1 { int x = 0, y = 0, z = 0; }; virtual method1(const Param1& p)
class Container { public: class Iterator { ... }; ... };
class Container::Iterator; class Foo { void Read(Container::Iterator& it); };
test.h:3: error: ‘Iterator’ in class ‘Container’ does not name a type test.h:5: error: variable or field ‘Foo’ declared void test.h:5: error: incomplete type ‘Container’ used in nested name specifier test.h:5: error: ‘it’ was not declared in this scope
struct Foo { export template<class T> void Read(T it); };
export template<> void Foo::Read<Container::Inner>(Container::Inner& it) { }
int main() { Foo f; Container::Inner i; f.Read(i); f.Read(3); }
void deleteForMe(int* pointer) { delete[] pointer; }
int main() { int* arr = new int[5]; deleteForMe(arr); return 0; }
int main() { int* num = new int(1); deleteForMe(num); return 0; }
int *temp = i - 1; int numbers_of_element = *temp; ... call destructor for numbers_of_element elements if needed ... that are stored in temp + 1, temp + 2, ... temp + 4 free (temp)
void* operator new[]( size_t size ) { int* ptr = (int*)malloc( size + 4 ); *ptr = 0; ++ptr; return ptr; } void static operator delete[]( void* ptr ) { int* realPtr = (int*)ptr; --realPtr; free( realPtr ); } template<class T> void Deallocate( T* ptr ) { int* instanceCount = (int*)ptr; --instanceCount; if(*instanceCount > 0) { for(int i = 0; i < *instanceCount; i++) { ptr[i].~T(); } ::operator delete[]( instanceCount ); } else { ptr->~T(); ::operator delete[]( ptr ); } } struct StructureOne { StructureOne(): someInt(0) {} ~StructureOne() { someInt = 0; } int someInt; }; struct StructureTwo { int someInt; }; void main(void) { const unsigned int numElements = 30; StructureOne* structOne = nullptr; StructureTwo* structTwo = nullptr; int* basicType = nullptr; size_t ArraySize = 0; /**********************************************************************/ ArraySize = sizeof( int ) * numElements; basicType = MyNew int[numElements]; MyDelete( basicType ); /**********************************************************************/ ArraySize = sizeof( StructureTwo ) * numElements; structTwo = MyNew StructureTwo[numElements]; MyDelete( structTwo ); /**********************************************************************/ ArraySize = sizeof( StructureOne ) * numElements; structOne = MyNew StructureOne[numElements]; MyDelete( structOne ); }
class Car { public: enum Color { RED, BLUE, WHITE }; void SetColor( Car::Color color ) { _color = color; } Car::Color GetColor() const { return _color; } private: Car::Color _color; };
struct Color { enum Type { Red, Green, Black }; Type t_; Color(Type t) : t_(t) {} operator Type () const {return t_;} private: template<typename T> operator T () const; };
Color c = Color::Red; switch(c) { case Color::Red: break; } Color2 c2 = Color2::Green; c2 = c; c2 = 3; if (c2 == Color::Red ) {} If (c2) {} error
struct EnumName {\ enum type \ { \ BOOST_PP_SEQ_FOR_EACH_I(DEFINE_SIMPLE_ENUM_VAL, EnumName, seq)\ }; \ type v; \ EnumName(type v) : v(v) {} \ operator type() const {return v;} \ private: \ template<typename T> \ operator T () const;};\ BOOST_PP_TUPLE_ELEM(2, 0, record) = BOOST_PP_TUPLE_ELEM(2, 1, record),
DEFINE_SIMPLE_ENUM(Color, ((Red, 1)) ((Green, 3)) )
using namespace std; int main() { string strings[] = { "hello", "world" }; static const size_t num_strings = sizeof(strings)/sizeof(strings[0]); string best_string = "foo"; for_each( &strings[0], &strings[num_strings], [&best_string](const string& s) { best_string = s; } ); return 0; }
[&best_string = static_cast<const std::string&>(best_string)](const string& s) { best_string = s; };
[&best_string = std::as_const(best_string)](const string& s) { best_string = s; };
const string better_string = "XXX"; [&better_string](string s) { better_string = s; }
using namespace std; int main() { string strings[] = { "hello", "world" }; static const size_t num_strings = sizeof(strings)/sizeof(strings[0]); string best_string = "foo"; const string& string_processed = best_string; for_each( &strings[0], &strings[num_strings], [&string_processed] (const string& s) -> void { string_processed = s; } ); return 0; }
int main() { int a = 5; std::function<int ()> f2 = std::bind( [](const int &a){return a;}, a); }
[best_string = cref(best_string)](const string& s) { best_string = s; };
int main () { auto [hello, world] = std::make_tuple("Hello ", "world!"); std::cout << hello << world << std::endl; return 0; }
std::vector<uint8_t> main_arr; std::vector<uint32_t> sec_arr; uint8_t lookup(unsigned idx) { uint8_t v = (main_arr[idx>>2]>>(2*(idx&3)))&3; if(v != 3) return v; auto ptr = std::lower_bound(sec_arr.begin(), sec_arr.end(), idx<<8); if(ptr == sec_arr.end()) std::abort(); if((*ptr >> 8) != idx) std::abort(); return (*ptr) & 0xff; } void populate(uint8_t *source, size_t size) { main_arr.clear(); sec_arr.clear(); main_arr.resize((size+3)/4); for(size_t idx = 0; idx < size; ++idx) { uint8_t in = source[idx]; uint8_t &target = main_arr[idx>>2]; if(in >= 3) { sec_arr.push_back((idx << 8) | in); in = 3; } target |= in << ((idx & 3)*2); } }
using namespace std::chrono; struct XorShift32 { typedef uint32_t result_type; static uint32_t min() { return 1; } static uint32_t max() { return uint32_t(-1); } uint32_t y; XorShift32(uint32_t seed = 0) : y(seed) { if(y == 0) y = 2463534242UL; } uint32_t operator()() { y ^= (y<<13); y ^= (y>>17); y ^= (y<<15); return y; } uint32_t operator()(uint32_t limit) { return (*this)()%limit; } }; struct mean_variance { double rmean = 0.; double rvariance = 0.; int count = 0; void operator()(double x) { ++count; double ormean = rmean; rmean += (x-rmean)/count; rvariance += (x-ormean)*(x-rmean); } double mean() const { return rmean; } double variance() const { return rvariance/(count-1); } double stddev() const { return std::sqrt(variance()); } }; std::vector<uint8_t> main_arr; std::vector<uint32_t> sec_arr; uint8_t lookup(unsigned idx) { uint8_t v = (main_arr[idx>>2]>>(2*(idx&3)))&3; if(v != 3) return v; auto ptr = std::lower_bound(sec_arr.begin(), sec_arr.end(), idx<<8); if(ptr == sec_arr.end()) std::abort(); if((*ptr >> 8) != idx) std::abort(); return (*ptr) & 0xff; } void populate(uint8_t *source, size_t size) { main_arr.clear(); sec_arr.clear(); main_arr.resize((size+3)/4); for(size_t idx = 0; idx < size; ++idx) { uint8_t in = source[idx]; uint8_t &target = main_arr[idx>>2]; if(in >= 3) { sec_arr.push_back((idx << 8) | in); in = 3; } target |= in << ((idx & 3)*2); } } volatile unsigned out; int main() { XorShift32 xs; std::vector<uint8_t> vec; int size = 10000000; for(int i = 0; i<size; ++i) { uint32_t v = xs(); if(v < 1825361101) v = 0; else if(v < 4080218931) v = 1; else if(v < 4252017623) v = 2; else { while((v & 0xff) < 3) v = xs(); } vec.push_back(v); } populate(vec.data(), vec.size()); mean_variance lk_t, arr_t; for(int i = 0; i<50; ++i) { { unsigned o = 0; auto beg = high_resolution_clock::now(); for(int i = 0; i < size; ++i) { o += lookup(xs() % size); } out += o; int dur = (high_resolution_clock::now()-beg)/microseconds(1); fprintf(stderr, "lookup: %10d µs\n", dur); lk_t(dur); } { unsigned o = 0; auto beg = high_resolution_clock::now(); for(int i = 0; i < size; ++i) { o += vec[xs() % size]; } out += o; int dur = (high_resolution_clock::now()-beg)/microseconds(1); fprintf(stderr, "array: %10d µs\n", dur); arr_t(dur); } } fprintf(stderr, " lookup | ± | array | ± | speedup\n"); printf("%7.0f | %4.0f | %7.0f | %4.0f | %0.2f\n", lk_t.mean(), lk_t.stddev(), arr_t.mean(), arr_t.stddev(), arr_t.mean()/lk_t.mean()); return 0; }
CPU | cache | lookup (µs) | array (µs) | speedup (x) Xeon E5-1650 v3 @ 3.50GHz | 15360 KB | 60011 ± 3667 | 29313 ± 2137 | 0.49 Xeon E5-2697 v3 @ 2.60GHz | 35840 KB | 66571 ± 7477 | 33197 ± 3619 | 0.50 Celeron G1610T @ 2.30GHz | 2048 KB | 172090 ± 629 | 162328 ± 326 | 0.94 Core i3-3220T @ 2.80GHz | 3072 KB | 111025 ± 5507 | 114415 ± 2528 | 1.03 Core i5-7200U @ 2.50GHz | 3072 KB | 92447 ± 1494 | 95249 ± 1134 | 1.03 Xeon X3430 @ 2.40GHz | 8192 KB | 111303 ± 936 | 127647 ± 1503 | 1.15 Core i7 920 @ 2.67GHz | 8192 KB | 123161 ± 35113 | 156068 ± 45355 | 1.27 Xeon X5650 @ 2.67GHz | 12288 KB | 106015 ± 5364 | 140335 ± 6739 | 1.32 Core i7 870 @ 2.93GHz | 8192 KB | 77986 ± 429 | 106040 ± 1043 | 1.36 Core i7-6700 @ 3.40GHz | 8192 KB | 47854 ± 573 | 66893 ± 1367 | 1.40 Core i3-4150 @ 3.50GHz | 3072 KB | 76162 ± 983 | 113265 ± 239 | 1.49 Xeon X5650 @ 2.67GHz | 12288 KB | 101384 ± 796 | 152720 ± 2440 | 1.51 Core i7-3770T @ 2.50GHz | 8192 KB | 69551 ± 1961 | 128929 ± 2631 | 1.85
unsigned char lookup(int index) { int code = (bmap[index>>2]>>(2*(index&3)))&3; if (code != 3) return code; return full_array[index]; }
[0, 15000] = 0 [15001, 15002] = 153 [15003, 26876] = 2 [25677, 31578] = 0 ...
class Interval{ private: uint32_t start; uint32_t end; uint8_t value; public: Interval(uint32_t start, uint32_t end, uint8_t value); bool isInInterval(uint32_t item); uint8_t getValue(); }
Interval intervals[INTERVAL_COUNT]; intervals[0] = Interval(0, 15000, 0); intervals[1] = Interval(15001, 15002, 153); intervals[2] = Interval(15003, 26876, 2); intervals[3] = Interval(25677, 31578, 0); ... uint8_t checkIntervals(uint32_t item) for(int i=0; i<INTERVAL_COUNT-1; i++) { if(intervals[i].isInInterval(item) == true) { return intervals[i].getValue(); } } return DEFAULT_VALUE; }
class C { public static bool operator false (C c) { whatever } public static C operator & (C left, C right) { whatever } ...
C cresult; C tempLeft = cleft; cresult = C.false(tempLeft) ? tempLeft : C.&(tempLeft, cright);
cresult = C.true(tempLeft) ? tempLeft : C.|(tempLeft , cright);
template< typename T > ClassA.operator&&( T const & objectB )
A operator&&(B b, __lazy C c) {return c;} exp_b && exp_c; operator&&(exp_b, exp_c);
template<class Func> A operator&&(B b, Func& f) {auto&& c = f(); return c;} operator&&(exp_b, [&]{return exp_c;});
auto&& and_arg = a; auto&& and_result = (and_arg? and_arg && b : and_arg); auto x = (and_result? and_result : and_result || c);
auto x = [&]() -> T_op_result { auto&& and_arg = a; auto&& and_result = (and_arg? and_arg && b : and_arg); if( and_result ) { return and_result; } else { return and_result || b; } }();
using namespace std; void say( char const* s ) { cout << s; } struct S { using Op_result = S; bool value; auto is_true() const -> bool { say( "!! " ); return value; } friend auto operator&&( S const a, S const b ) -> S { say( "&& " ); return a.value? b : a; } friend auto operator||( S const a, S const b ) -> S { say( "|| " ); return a.value? a : b; } friend auto operator<<( ostream& stream, S const o ) -> ostream& { return stream << o.value; } }; template< class T > auto is_true( T const& x ) -> bool { return !!x; } template<> auto is_true( S const& x ) -> bool { return x.is_true(); } [&]() \ { \ auto&& and_arg = (a); \ return (is_true( and_arg )? and_arg && (b) : and_arg); \ }() [&]() \ { \ auto&& or_arg = (a); \ return (is_true( or_arg )? or_arg : or_arg || (b)); \ }() auto main() -> int { cout << boolalpha; for( int a = 0; a <= 1; ++a ) { for( int b = 0; b <= 1; ++b ) { for( int c = 0; c <= 1; ++c ) { S oa{!!a}, ob{!!b}, oc{!!c}; cout << a << b << c << " -> "; auto x = SHORTED_OR( SHORTED_AND( oa, ob ), oc ); cout << x << endl; } } } }
X operator&&(Y const& y, Z const& z) { if (shortcircuitCondition(y)) return shortcircuitEvaluation(y); <"Syntax for an evaluation-Point for z here"> return actualImplementation(y,z); }
struct S { bool val; explicit S(int i) : val(i) {} explicit S(bool b) : val(b) {} template <class Expr> S (const Expr & expr) : val(evaluate(expr).val) { } template <class Expr> S & operator = (const Expr & expr) { val = evaluate(expr).val; return *this; } explicit operator bool () const { return val; } }; S logical_and (const S & lhs, const S & rhs) { std::cout << "&& "; return S{lhs.val && rhs.val}; } S logical_or (const S & lhs, const S & rhs) { std::cout << "|| "; return S{lhs.val || rhs.val}; } const S & evaluate(const S &s) { return s; } template <class Expr> S evaluate(const Expr & expr) { return expr.eval(); } struct And { template <class LExpr, class RExpr> S operator ()(const LExpr & l, const RExpr & r) const { const S & temp = evaluate(l); return temp? logical_and(temp, evaluate(r)) : temp; } }; struct Or { template <class LExpr, class RExpr> S operator ()(const LExpr & l, const RExpr & r) const { const S & temp = evaluate(l); return temp? temp : logical_or(temp, evaluate(r)); } }; template <class Op, class LExpr, class RExpr> struct Expr { Op op; const LExpr &lhs; const RExpr &rhs; Expr(const LExpr& l, const RExpr & r) : lhs(l), rhs(r) {} S eval() const { return op(lhs, rhs); } }; template <class LExpr> auto operator && (const LExpr & lhs, const S & rhs) { return Expr<And, LExpr, S> (lhs, rhs); } template <class LExpr, class Op, class L, class R> auto operator && (const LExpr & lhs, const Expr<Op,L,R> & rhs) { return Expr<And, LExpr, Expr<Op,L,R>> (lhs, rhs); } template <class LExpr> auto operator || (const LExpr & lhs, const S & rhs) { return Expr<Or, LExpr, S> (lhs, rhs); } template <class LExpr, class Op, class L, class R> auto operator || (const LExpr & lhs, const Expr<Op,L,R> & rhs) { return Expr<Or, LExpr, Expr<Op,L,R>> (lhs, rhs); } std::ostream & operator << (std::ostream & o, const S & s) { o << s.val; return o; } S and_result(S s1, S s2, S s3) { return s1 && s2 && s3; } S or_result(S s1, S s2, S s3) { return s1 || s2 || s3; } int main(void) { for(int i=0; i<= 1; ++i) for(int j=0; j<= 1; ++j) for(int k=0; k<= 1; ++k) std::cout << and_result(S{i}, S{j}, S{k}) << std::endl; for(int i=0; i<= 1; ++i) for(int j=0; j<= 1; ++j) for(int k=0; k<= 1; ++k) std::cout << or_result(S{i}, S{j}, S{k}) << std::endl; return 0; }
optional<Foo*> p (new Foo); delete p.get(); p = optional<Foo*>();
static void TreeItem::DeleteSubtree(TreeItem *&rootObject) { if (rootObject == NULL) return; rootObject->UnlinkFromParent(); for (int i = 0; i < numChildren) DeleteSubtree(rootObject->child[i]); delete rootObject; rootObject = NULL; }
lock(myObjMutex); delete myObj; myobj = 0 unlock(myObjMutex);
"A" = 41 "ABC" = 41 42 43 L"A" = 00 41 L"ABC" = 00 41 00 42 00 43
T lval; foo(lval); foo(T {}); foo(std::move(lval));
class T { U u; V v; public: T(U u, V v) : u(std::move(u)) , v(std::move(v)) {} };
void copy_antipattern(T const& t) { auto copy = t; t.some_mutating_function(); } void copy_pattern(T t) { t.some_mutating_function(); }
std::vector<T> v; void move_antipattern(T const& t) { v.push_back(t); } void move_pattern(T t) { v.push_back(std::move(t)); }
void read_pattern(T const& t) { t.some_const_function(); }
std::stringstream ss; ss.fill( ss << setw(2) << timestruct.tm_mday; ss << timestruct.tm_hour; ss << timestruct.tm_min; std::string filingTime = ss.str();
setiosflags resetiosflags setbase setfill setprecision setw
setiosflags: Sticky resetiosflags:Sticky setbase: Sticky setfill: Sticky setprecision: Sticky
[no]boolalpha [no]showbase [no]showpoint [no]showpos [no]skipws [no]unitbuf [no]uppercase dec/ hex/ oct fixed/ scientific internal/ left/ right
struct SquareBracktAroundNextItem { SquareBracktAroundNextItem(std::ostream& str) :m_str(str) {} std::ostream& m_str; }; struct PutSquareBracket {}; SquareBracktAroundNextItem operator<<(std::ostream& str,PutSquareBracket const& data) { return SquareBracktAroundNextItem(str); } template<typename T> std::ostream& operator<<(SquareBracktAroundNextItem const& bracket,T const& data) { std::ios_base::fmtflags flags = bracket.m_str.flags(); std::streamsize currentPrecision = bracket.m_str.precision(); bracket.m_str << bracket.m_str.flags(flags); return bracket.m_str; } int main() { std::cout << 5.34 << "\n" << PutSquareBracket() << 5.34 << "\n" << 5.34 << "\n"; } > ./a.out 5.34 [5.3400000000] 5.34
template<class charT, class traits, class Allocator> basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& os, const basic_string<charT,traits,Allocator>& str);
std::cout << std::setw(6) << 4.5 << " 4.5 | 3.6 \n"
std::cout << std::setw(6) << 4.5 << std::setw(0) <<
cout.width(6); cout << right << "a" << endl; cout.width(6); cout << "b" << endl; cout.width(6); cout << "c" << endl;
cout.width(6); cout << right << "a" << endl; cout << "b" << endl; cout << "c" << endl;
int main() { using namespace std; string myString = "Press ENTER to quit program!"; cout << "Come up and C++ me some time." << endl; printf("Follow this command: %s", myString); cin.get(); return 0; }
int main() { using namespace std; string myString = "Press ENTER to quit program!"; cout << "Come up and C++ me some time." << endl; printf("Follow this command: %s", myString.c_str()); cin.get(); return 0; }
std::locale loc(""); std::cout.imbue(loc); std::cout << 123456.78;
std::printf("Follow this command: %s", myString.c_str());
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set_target_properties( targets... PROPERTIES ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib" LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib" RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin" )
$ cat CMakeLists.txt project (hello) set(EXECUTABLE_OUTPUT_PATH "bin") add_executable (hello hello.c)
set( ARCHIVE_OUTPUT_DIRECTORY "/home/xy/cmake_practice/lib/" LIBRARY_OUTPUT_DIRECTORY "/home/xy/cmake_practice/lib/" RUNTIME_OUTPUT_DIRECTORY "/home/xy/cmake_practice/bin/" )
set_target_properties(demo5 PROPERTIES ARCHIVE_OUTPUT_DIRECTORY "/home/xy/cmake_practice/lib/" LIBRARY_OUTPUT_DIRECTORY "/home/xy/cmake_practice/lib/" RUNTIME_OUTPUT_DIRECTORY "/home/xy/cmake_practice/bin/" )
cat CMakeLists.txt project (hello) set(CMAKE_BINARY_DIR "/bin") set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}) add_executable (hello hello.c)
static string getScopedClassMethod( string thePrettyFunction ) { size_t index = thePrettyFunction . find( "(" ); if ( index == string::npos ) return thePrettyFunction; thePrettyFunction . erase( index ); index = thePrettyFunction . rfind( " " ); if ( index == string::npos ) return thePrettyFunction; thePrettyFunction . erase( 0, index + 1 ); return thePrettyFunction; }
using namespace std; int main() { stringstream ss("this is a string\n"); string str(ss.str()); const char* cstr1 = str.c_str(); const char* cstr2 = ss.str().c_str(); cout << cstr1 << cstr2; system("PAUSE"); return 0; }
const std::string tmp = stringstream.str(); const char* cstr = tmp.c_str();
{ const std::string& tmp = stringstream.str(); const char* cstr = tmp.c_str(); }
using namespace std; int main() { stringstream ss("this is a string\n"); string str(ss.str()); const char* cstr1 = str.c_str(); const std::string& resultstr = ss.str(); const char* cstr2 = resultstr.c_str(); cout << cstr1 << cstr2; system("PAUSE"); return 0; }
std::string resultstr = ss.str(); const char* cstr2 = resultstr.c_str();
string a = "hello"; string b(a); assert(a.c_str() == b.c_str());
class Widget { public: virtual ~Widget() = default; };
struct Trivial2 { int foo; Trivial2() = default; };
struct A { private: ~A(); }; class Widget { A a_; public: virtual ~Widget() = default; virtual ~Widget() {} };
test.cpp:8:7: error: field of type A a_; ^ test.cpp:4:5: note: declared private here ~A(); ^ 1 error generated.
class A { public: A(){} int i; int j; }; class B { public: B() = default; int i; int j; }; int main() { for( int i = 0; i < 100; ++i) { A* pa = new A(); B* pb = new B(); std::cout << pa->i << "," << pa->j << std::endl; std::cout << pb->i << "," << pb->j << std::endl; delete pa; delete pb; } return 0; }
0,0 0,0 145084416,0 0,0 145084432,0 0,0 145084416,0
class A { ... }; struct B { ... }; A *object1 = new A(); B object2 = *(new B());
template <typename T> class automatic_pointer { public: automatic_pointer(T* pointer) : pointer(pointer) {} ~automatic_pointer() { delete pointer; } T& operator*() const { return *pointer; } T* operator->() const { return pointer; } private: T* pointer; automatic_pointer(automatic_pointer const&); automatic_pointer& operator=(automatic_pointer const&); }; automatic_pointer<A> a(new A()); automatic_pointer<B> b(new B());
class B { public: B() {}; B(const B& other) { delete &other; } }
class A { B b; public: A(); }; A::A() : b( 1, 2 ) { }
using namespace::std; template <class Type> class Stack { public: Stack (int max):stack(new Type[max]), top(-1), maxsize(max){} ~Stack (void) {delete []stack;} void Push (Type &val); void Pop (void) {if (top>=0) --top;} Type& Top (void) {return stack[top];} private: Type *stack; int top; const int maxSize; }; template <class Type> void Stack <Type>:: Push (Type &val) { if (top+1<maxsize) stack [++top]=val; }
TYPE& dynamic_cast<TYPE&> (object); TYPE* dynamic_cast<TYPE*> (object);
using namespace std; class A { public: virtual ~A() = default; }; class B : public A { } ; class C : public A { } ; int main(int argc, char* argv[]) { B b; A& a = b; cout << "a is B: " << boolalpha << (typeid(a) == typeid(B)) << endl; cout << "a is C: " << boolalpha << (typeid(a) == typeid(C)) << endl; cout << "b is B: " << boolalpha << (typeid(b) == typeid(B)) << endl; cout << "b is A: " << boolalpha << (typeid(b) == typeid(A)) << endl; cout << "b is C: " << boolalpha << (typeid(b) == typeid(C)) << endl; }
a is B: true a is C: false b is B: true b is A: false b is C: false
struct BaseClas { int base; virtual ~BaseClas(){} }; class Derived1 : public BaseClas { int derived1; };
class A {}; class B : public A {}; class Foo { public: void Bar(A& a) { } void Bar(B& b) { Bar(static_cast<A&>(b)); } };
int a; int& ff() { return a; } int main() { ff() = 10; using boost::typeindex::type_id_with_cvr; std::cout << type_id_with_cvr<int&>().pretty_name() << std::endl; std::cout << type_id_with_cvr<decltype(ff())>().pretty_name() << std::endl; std::cout << typeid(ff()).name() << std::endl; }
using namespace std; int main() { int* ptr = new int; cout << "ptr = " << ptr << endl; delete ptr; cout << "ptr = " << ptr << endl; system("pause"); return 0; }
ptr = 0050BC10 ptr = 00008123 Press any key to continue....
struct Object { struct TypeInformation; static virtual const TypeInformation &GetTypeInformation() const; }; struct SomeObject : public Object { static virtual const TypeInformation &GetTypeInformation() const; };
class Object { public: static string getTypeInformationStatic() { return "base class";} virtual string getTypeInformation() { return getTypeInformationStatic(); } }; class Foo: public Object { public: static string getTypeInformationStatic() { return "derived class";} virtual string getTypeInformation() { return getTypeInformationStatic(); } };
class TypeKeeper { public: virtual string getTypeInformation() = 0; }; template<class T> class TypeKeeperImpl: public TypeKeeper { public: virtual string getTypeInformation() { return T::getTypeInformationStatic(); } };
class Object { public: Object(){} boost::scoped_ptr<TypeKeeper> keeper; string getTypeInformation() const { return keeper? keeper->getTypeInformation(): string("base class"); } };
class Foo: public Object { public: Foo() { keeper.reset(new TypeKeeperImpl<Foo>()); } static string getTypeInformationStatic() { return "class for proving static virtual functions concept"; } };
template<class T> void override_static_functions(T* t) { t->keeper.reset(new TypeKeeperImpl<T>()); }
class Foo: public Object { public: Foo() { OVERRIDE_STATIC_FUNCTIONS; } static string getTypeInformationStatic() { return "class for proving static virtual functions concept"; } }; class Bar: public Foo { public: Bar() { OVERRIDE_STATIC_FUNCTIONS; } static string getTypeInformationStatic() { return "another class for the same reason"; } };
Object* obj = new Foo(); cout << obj->getTypeInformation() << endl; obj = new Bar(); cout << obj->getTypeInformation() << endl; Foo* foo = new Bar(); cout << foo->getTypeInformation() << endl; Foo::getTypeInformation(); Foo::getTypeInformationStatic(); Bar::getTypeInformationStatic();
class Foo { public: static void f(bool f=true) { cout << "static";} virtual void f() { cout << "virtual";} }; Foo::f(); ptr_to_foo->f();
class Object { public: virtual char* GetClassName() = 0; };
template<class ObjectType> class ObjectImpl : public Object { public: virtual char* GetClassName() { return ObjectType::GetClassNameStatic(); } };
class MyObject : public ObjectImpl<MyObject> { public: static char* GetClassNameStatic() { return "MyObject"; } }; class YourObject : public ObjectImpl<YourObject> { public: static char* GetClassNameStatic() { return "YourObject"; } };
char* GetObjectClassName(Object* object) { return object->GetClassName(); } int main() { MyObject myObject; YourObject yourObject; printf("%s\n", MyObject::GetClassNameStatic()); printf("%s\n", myObject.GetClassName()); printf("%s\n", GetObjectClassName(&myObject)); printf("%s\n", YourObject::GetClassNameStatic()); printf("%s\n", yourObject.GetClassName()); printf("%s\n", GetObjectClassName(&yourObject)); return 0; }
class MyObject : public ObjectImpl<MyObject> { public: static inline const char* const s_ClassName = "MyObject"; };
struct Object{ struct TypeInformation; static const TypeInformation &GetTypeInformationStatic() const { return GetTypeInformationMain1(); } virtual const TypeInformation &GetTypeInformation() const { return GetTypeInformationMain1(); } protected: static const TypeInformation &GetTypeInformationMain1(); }; struct SomeObject : public Object { static const TypeInformation &GetTypeInformationStatic() const { return GetTypeInformationMain2(); } virtual const TypeInformation &GetTypeInformation() const { return GetTypeInformationMain2(); } protected: static const TypeInformation &GetTypeInformationMain2(); };
class Foo { public: void M() {...} }; class Bar : public Foo { public: void M() {...} }; void Try() { xxx::M(); } int main() { Try(); }
class Foo { public: void M() {...} }; class Bar : public Foo { public: void M() {...} }; template <class T> void Try() { T::M(); } int main() { Try<Bar>(); }
void SomeObject::accept(ObjectVisitor& v) const { v.visit(*this); } void AnotherObject::accept(ObjectVisitor& v) const { v.visit(*this); }
struct ObjectVisitor { virtual ~ObjectVisitor() {} virtual void visit(const SomeObject& o) {} virtual void visit(const AnotherObject& o) {} };
struct ObjectVisitorGetTypeInfo { Object::TypeInformation result; virtual void visit(const SomeObject& o) { result = SomeObject::GetTypeInformation(); } virtual void visit(const AnotherObject& o) { result = AnotherObject::GetTypeInformation(); } };
void printInfo(Object& o) { ObjectVisitorGetTypeInfo getTypeInfo; Object::TypeInformation info = o.accept(getTypeInfo).result; std::cout << info << std::endl; }
struct ObjectVisitorGetTypeInfo { Object::TypeInformation result; virtual void visit(const SomeObject& o) { doVisit(o); } virtual void visit(const AnotherObject& o) { doVisit(o); } private: template <typename T> void doVisit(const T& o) { result = T::GetTypeInformation(); } };
struct Base { static virtual void sayMyName() { cout << "Base\n"; } }; struct Derived : public Base { static void sayMyName() override { cout << "Derived\n"; } }; void foo(Base *b) { b->sayMyName(); Derived::sayMyName(); }
struct Base { virtual void sayMyName() { cout << "Base\n"; } virtual void foo() { } int somedata; }; struct Derived : public Base { void sayMyName() override { cout << "Derived\n"; } }; void foo(Base *b) { b->sayMyName(); }
enum Base_Virtual_Functions { sayMyName = 0; foo = 1; }; using VTable = void*[]; const VTable Base_VTable = { &Base::sayMyName, &Base::foo }; const VTable Derived_VTable = { &Derived::sayMyName, &Base::foo };
struct Base { VTable* vtable; virtual void sayMyName() { cout << "Base\n"; } virtual void foo() { } int somedata; }; struct Derived : public Base { VTable* vtable; void sayMyName() override { cout << "Derived\n"; } };
class Base { public: Base(void); virtual ~Base(void); public: virtual void MyVirtualFun(void) = 0; static void MyStaticFun(void) { assert( mSelf != NULL); mSelf->MyVirtualFun(); } private: static Base* mSelf; }; Base::mSelf = NULL; Base::Base(void) { mSelf = this; } Base::~Base(void) { } class DerivedClass : public Base { public: DerivedClass(void) : Base() {} ~DerivedClass(void){} public: virtual void MyVirtualFun(void) { cout<<"Hello, it is DerivedClass!"<<endl; } }; int main() { DerivedClass testCls; testCls.MyStaticFun(); DerivedClass::MyStaticFun(); return 0; }
struct Foo { static int boo() { return 2; } }; int _tmain(int argc, _TCHAR* argv[]) { Foo* pFoo = NULL; int b = pFoo->boo(); return 0; }
class dumb_array { public: friend void swap(dumb_array& first, dumb_array& second) { using std::swap; swap(first.mSize, second.mSize); swap(first.mArray, second.mArray); } };
namespace std { template <> void swap(myclass&, myclass&) { } }
namespace std { template <typename T> void swap<T>(myclass<T>&, myclass<T>&) { } }
namespace xyz { struct myclass { friend void swap(myclass&, myclass&); }; }
struct foo { friend void bar() { } }; struct foo { friend void bar(); }; void bar() { }
class dumb_array { public: friend void swap(dumb_array& first, dumb_array& second); }; inline void swap(dumb_array& first, dumb_array& second) { using std::swap; swap(first.mSize, second.mSize); swap(first.mArray, second.mArray); }
struct A { virtual void f() { } }; struct B : public A { }; struct C { }; void f () { A a; B b; A* ap = &b; B* b1 = dynamic_cast<B*> (&a); B* b2 = dynamic_cast<B*> (ap); C* c = dynamic_cast<C*> (ap); A& ar = dynamic_cast<A&> (*ap); B& br = dynamic_cast<B&> (*ap); C& cr = dynamic_cast<C&> (*ap); }
class B {}; class D : public B {}; class X {}; int main() { D* d = new D; B* b = static_cast<B*>(d); X* x = static_cast<X*>(d); return 0; }
using namespace std; class Base { public: virtual void DoIt() = 0; virtual ~Base() {}; }; class Foo : public Base { public: virtual void DoIt() { cout << "Foo"; }; void FooIt() { cout << "Fooing It..."; } }; class Bar : public Base { public : virtual void DoIt() { cout << "Bar"; } void BarIt() { cout << "baring It..."; } }; Base* CreateRandom() { if( (rand()%2) == 0 ) return new Foo; else return new Bar; } int main() { for( int n = 0; n < 10; ++n ) { Base* base = CreateRandom(); base->DoIt(); Bar* bar = (Bar*)base; bar->BarIt(); } return 0; }
int main() { for( int n = 0; n < 10; ++n ) { Base* base = CreateRandom(); base->DoIt(); Bar* bar = dynamic_cast<Bar*>(base); Foo* foo = dynamic_cast<Foo*>(base); if( bar ) bar->BarIt(); if( foo ) foo->FooIt(); } return 0; }
class Base {}; class Der : public Base {}; int main() { Base* base = new Der; Der* der = dynamic_cast<Der*>(base); return 0; }
class Base { public: virtual ~Base(){}; }; class Der : public Base {}; int main() { Base* base = new Der; Der* der = dynamic_cast<Der*>(base); return 0; }
class Base { virtual ~Base() {} }; class Derived : public Base {}; class Derived2 : public Base {}; class ReDerived : public Derived {}; void test( Base & base ) { dynamic_cast<Derived&>(base); } int main() { Base b; Derived d; Derived2 d2; ReDerived rd; test( b ); test( d ); test( d2 ); test( rd ); }
struct Animal { enum Type { Dog, Cat }; Type type; }; Animal * make_dog() { Animal * dog = new Animal; dog->type = Animal::Dog; return dog; } Animal * make_cat() { Animal * cat = new Animal; cat->type = Animal::Cat; return cat; } Animal * dyn_cast(AnimalType type, Animal * animal) { if(animal->type == type) return animal; return 0; } void bark(Animal * dog) { assert(dog->type == Animal::Dog); } int main() { Animal * animal; if(rand() % 2) animal = make_dog(); else animal = make_cat(); if(dyn_cast(Animal::Dog, animal)) { bark(animal); } delete animal; }
class SafeCastableBase { public: typedef long TypeID; static TypeID s_nextTypeID; static TypeID GetNextTypeID() { return s_nextTypeID++; } static TypeID GetTypeID() { return 0; } virtual bool CanCastTo(TypeID id) { if (GetTypeID() != id) { return false; } return true; } template <class Target> static Target *SafeCast(SafeCastableBase *pSource) { if (pSource->CanCastTo(Target::GetTypeID())) { return (Target*)pSource; } return NULL; } }; SafeCastableBase::TypeID SafeCastableBase::s_nextTypeID = 1; class TypeIDInitializer { public: TypeIDInitializer(SafeCastableBase::TypeID *pTypeID) { *pTypeID = SafeCastableBase::GetNextTypeID(); } }; class ChildCastable : public SafeCastableBase { public: static TypeID s_typeID; static TypeID GetTypeID() { return s_typeID; } virtual bool CanCastTo(TypeID id) { if (GetTypeID() != id) { return SafeCastableBase::CanCastTo(id); } return true; } }; SafeCastableBase::TypeID ChildCastable::s_typeID; TypeIDInitializer ChildCastableInitializer(&ChildCastable::s_typeID); class PeerChildCastable : public SafeCastableBase { public: static TypeID s_typeID; static TypeID GetTypeID() { return s_typeID; } virtual bool CanCastTo(TypeID id) { if (GetTypeID() != id) { return SafeCastableBase::CanCastTo(id); } return true; } }; SafeCastableBase::TypeID PeerChildCastable::s_typeID; TypeIDInitializer PeerChildCastableInitializer(&PeerChildCastable::s_typeID); int _tmain(int argc, _TCHAR* argv[]) { ChildCastable *pChild = new ChildCastable(); SafeCastableBase *pBase = new SafeCastableBase(); PeerChildCastable *pPeerChild = new PeerChildCastable(); ChildCastable *pSameChild = SafeCastableBase::SafeCast<ChildCastable>(pChild); SafeCastableBase *pBaseToChild = SafeCastableBase::SafeCast<SafeCastableBase>(pChild); ChildCastable *pNullDownCast = SafeCastableBase::SafeCast<ChildCastable>(pBase); SafeCastableBase *pBaseToPeerChild = SafeCastableBase::SafeCast<SafeCastableBase>(pPeerChild); ChildCastable *pNullCrossCast = SafeCastableBase::SafeCast<ChildCastable>(pPeerChild); return 0; }
using namespace std; class A { public: virtual void f(){cout << "A::f()" << endl;} }; class B : public A { public: void f(){cout << "B::f()" << endl;} }; int main() { A a; B b; a.f(); b.f(); A *pA = &a; B *pB = &b; pA->f(); pB->f(); pA = &b; pB = dynamic_cast<B*>(&a); return 0; }
using namespace std; class A { public: virtual void print()const {cout << " A\n";} }; class B { public: virtual void print()const {cout << " B\n";} }; class C: public A, public B { public: void print()const {cout << " C\n";} }; int main() { A* a = new A; B* b = new B; C* c = new C; a -> print(); b -> print(); c -> print(); b = dynamic_cast< B*>(a); if (b) b -> print(); else cout << "no B\n"; a = c; a -> print(); b = dynamic_cast< B*>(a); if (b) b -> print(); else cout << "no B\n"; }
typedef struct A { void**vtable; int data;} A; int AGetData(A*this){ return this->data; } void * Avtable[] = { (void*)AGetData }; A * newA() { A*res = malloc(sizeof(A)); res->vtable = Avtable; return res; } typedef struct B { void**vtable; int data; int moredata; } B; int BGetData(B*this){ return this->data + 1; } void * Bvtable[] = { (void*)BGetData }; B * newB() { B*res = malloc(sizeof(B)); res->vtable = Bvtable; return res; } int temp = ((int(*)())ptr->vtable[0])();
A * ptr = (A*) newB(); B * aB = ( ptr->vtable == Bvtable ? (B*) aB : (B*) 0 );
class A { vector<string> t_Names; public: A () : t_Names(1000) {} };
std::vector<int> v1; v1.resize(1000); cout <<(v1.size() == 1000)<< endl; cout <<(v1.capacity()==1000)<< endl; std::vector<int> v2; v2.reserve(1000); cout <<(v2.size() == 1000)<< endl; cout <<(v2.capacity()==1000)<< endl;
class A2DD { private: int gx; int gy; public: A2DD(int x,int y) { gx = x; gy = y; } int getSum() { return gx + gy; } };
class A2DD { int gx; int gy; public: A2DD(int x,int y); int getSum(); };
A2DD::A2DD(int x,int y) { gx = x; gy = y; } int A2DD::getSum() { return gx + gy; }
A2DD.h: class A2DD { private: int gx; int gy; public: A2DD(int x,int y); int getSum(); };
A2DD.cpp: A2DD::A2DD(int x,int y) { gx = x; gy = y; } int A2DD::getSum() { return gx + gy; }
class A2DD { private: int gx; int gy; public: A2DD(int x,int y); int getSum(); };
A2DD::A2DD(int x,int y) { gx = x; gy = y; } int A2DD::getSum() { return gx + gy; }
class A2DD { private: int gx; int gy; public: A2DD(int x,int y); int getSum(); };
A2DD::A2DD(int x,int y) { gx = x; gy = y; } int A2DD::getSum() { return gx + gy; }
class A2DD { private: int gx; int gy; public: A2DD(int x,int y); int getSum(); };
A2DD::A2DD(int x,int y) { gx = x; gy = y; } int A2DD::getSum() { return gx + gy; }
class A { public: A(); inline int GetA() const { return a_; } void DoSomethingCoplex(); private: int a_; };
int main() { std::cout << "type\tlowest()\tmin()\t\tmax()\n\n"; std::cout << "uchar\t" << +std::numeric_limits<unsigned char>::lowest() << << +std::numeric_limits<unsigned char>::min() << << +std::numeric_limits<unsigned char>::max() << std::cout << "int\t" << std::numeric_limits<int>::lowest() << << std::numeric_limits<int>::min() << << std::numeric_limits<int>::max() << std::cout << "float\t" << std::numeric_limits<float>::lowest() << << std::numeric_limits<float>::min() << << std::numeric_limits<float>::max() << std::cout << "double\t" << std::numeric_limits<double>::lowest() << << std::numeric_limits<double>::min() << << std::numeric_limits<double>::max() << }
template< class CharT, class Traits> basic_ostream<CharT,Traits>& operator<<( basic_ostream<CharT,Traits>& os, char ch );
template<typename T> class Object { public: int x; };
class Object { public: template<class T> void DoX(){} };
class Vector { int array[3]; template <class TVECTOR2> void eqAdd(TVECTOR2 v2); }; template <class TVECTOR2> void Vector::eqAdd(TVECTOR2 a2) { for (int i(0); i < 3; ++i) array[i] += a2[i]; }
class Foo { public: template <typename T> void some_method(T t) { }
class Foo { public: template <typename T> void some_method(T t); } template <typename T> void Foo::some_method(T t) { template void Foo::some_method<int>(int); template void Foo::some_method<double>(double);
namespace std { template<typename T> class list; } template<typename T> void Pop(std::list<T> * l) { while(!l->empty()) l->pop(); }
namespace std { template<class T, class Allocator = std::allocator<T>> class list; }
ifndef STATE_H_ template <class T> class LinkFrame; using namespace std; template <class T> class State { protected: LinkFrame<int> *myFrame; }
template <class T> bool State<T>::replace(Frame<T> *f){
class std_int_vector; class A{ std_int_vector* vector; public: A(); virtual ~A(); };
class std_int_vector: public std::vectror<int> {} A::A() : vector(new std_int_vector()) {} [...]
std::string str = "Hello world"; QString qstr = QString::fromStdString(str);
const char* str = "Hello world"; QString qstr = QString::fromAscii(str);
const char* str = "zażółć gęślą jaźń"; QString qstr = QString::fromLocal8Bit(str);
const char* str = read_raw("hello.txt"); QString qstr = QString::fromUtf8(str);
const ushort* str = read_raw("hello.txt"); QString qstr = QString::fromUtf16(str);
std::string str = "abc"; QString qstr = QString::fromStdString(str);
std::string s = "This is an STL string"; QString qs = QString::fromAscii(s.data(), s.size());
std::string s = "Übernahme"; QString q = QString::fromLocal8Bit(s.c_str());
std::string str("hello !"); qDebug() << QVariant(str.c_str()).toString(); int test = 10; double titi = 5.42; qDebug() << QVariant(test).toString(); qDebug() << QVariant(titi).toString(); qDebug() << QVariant(titi).toInt();
char name[] = "Stack Overflow"; QString qname(name);
std::string name2("Stack Overflow"); QString qname2(name2.c_str());
struct a { enum LOCAL_A { A1, A2 }; }; enum class b { B1, B2 }; int foo( int input ) { return input; } int main(void) { std::cout<<foo(a::A1)<<std::endl; std::cout<<foo(static_cast<int>(b::B2))<<std::endl; }
template <typename E> constexpr typename std::underlying_type<E>::type to_underlying(E e) noexcept { return static_cast<typename std::underlying_type<E>::type>(e); } std::cout << foo(to_underlying(b::B2)) << std::endl;
template <typename E> constexpr auto to_underlying(E e) noexcept { return static_cast<std::underlying_type_t<E>>(e); }
namespace utils { namespace details { template< typename E > using enable_enum_t = typename std::enable_if< std::is_enum<E>::value, typename std::underlying_type<E>::type >::type; } template< typename E > constexpr inline details::enable_enum_t<E> underlying_value( E e )noexcept { return static_cast< typename std::underlying_type<E>::type >( e ); } template< typename E , typename T> constexpr inline typename std::enable_if< std::is_enum<E>::value && std::is_integral<T>::value, E >::type to_enum( T value ) noexcept { return static_cast<E>( value ); } } int main() { enum class E{ a = 1, b = 3, c = 5 }; constexpr auto a = utils::underlying_value(E::a); constexpr E b = utils::to_enum<E>(5); constexpr auto bv = utils::underlying_value(b); printf("a = %d, b = %d", a,bv); return 0; }
enum class EnumClass : int { Zero, One, Two, Three, Four }; union Union { EnumClass ec; int i; }; int main() { using namespace std; Union un2; un2.ec = EnumClass::Three; cout << "un2.i = " << un2.i << endl; Union un; un.i = 0; if(un.ec == EnumClass::Zero) cout << "True" << endl; return 0; }
template <typename T> constexpr auto operator+(T e) noexcept -> std::enable_if_t<std::is_enum<T>::value, std::underlying_type_t<T>> { return static_cast<std::underlying_type_t<T>>(e); }
inline constexpr unsigned operator+ (name const val) { return static_cast<unsigned>(val); }
using namespace std; namespace Foo { enum { bar, baz }; } int main() { cout << Foo::bar << endl; cout << Foo::baz << endl; return 0; }
class b { private: int underlying; public: static constexpr int B1 = 0; static constexpr int B2 = 1; b(int v) : underlying(v) {} operator int() { return underlying; } };
enum class Flags { ......, Total }; std::bitset<static_cast<unsigned int>(Total)> MaskVar; std::vector<Flags> NewFlags; ----------- auto scui = [](Flags a){return static_cast<unsigned int>(a); }; for (auto const& it : NewFlags) { switch (it) { case Flags::Horizontal: MaskVar.set(scui(Flags::Horizontal)); MaskVar.reset(scui(Flags::Vertical)); break; case Flags::Vertical: MaskVar.set(scui(Flags::Vertical)); MaskVar.reset(scui(Flags::Horizontal)); break; case Flags::LongText: MaskVar.set(scui(Flags::LongText)); MaskVar.reset(scui(Flags::ShorTText)); break; case Flags::ShorTText: MaskVar.set(scui(Flags::ShorTText)); MaskVar.reset(scui(Flags::LongText)); break; case Flags::ShowHeading: MaskVar.set(scui(Flags::ShowHeading)); MaskVar.reset(scui(Flags::NoShowHeading)); break; case Flags::NoShowHeading: MaskVar.set(scui(Flags::NoShowHeading)); MaskVar.reset(scui(Flags::ShowHeading)); break; default: break; } }
public class ObservableList<T extends List> { ... }
template<typename T> class ObservableList { BOOST_STATIC_ASSERT((is_base_of<List, T>::value)); ... };
template<typename T> class my_template; template<> class my_template<int> { ... }; template<typename T> class my_template<T*> { ... };
template<typename T> class observable_list { static_assert(std::is_base_of<list, T>::value, "T must inherit from list"); };
template<typename...> struct void_ { using type = void; }; template<typename... Args> using Void = typename void_<Args...>::type; template<typename T, typename = void> struct has_const_iterator : std::false_type {}; template<typename T> struct has_const_iterator<T, Void<typename T::const_iterator>> : std::true_type {}; struct has_begin_end_impl { template<typename T, typename Begin = decltype(std::declval<const T&>().begin()), typename End = decltype(std::declval<const T&>().end())> static std::true_type test(int); template<typename...> static std::false_type test(...); }; template<typename T> struct has_begin_end : decltype(has_begin_end_impl::test<T>(0)) {}; template<typename T> class observable_list { static_assert(has_const_iterator<T>::value, "Must have a const_iterator typedef"); static_assert(has_begin_end<T>::value, "Must have begin and end member functions"); };
class Base {}; class Derived: public Base {}; template <class T> class MyClass { private: static_assert(std::is_base_of<Base, T>::value, "T is not derived from Base"); typename std::enable_if<std::is_base_of<Base, T>::value, T>::type inner; }; template <class T> class MyClass: protected std::enable_if<std::is_base_of<Base, T>::value, T>::type { private: static_assert(std::is_base_of<Base, T>::value, "T is not derived from Base"); }; template <class T> class MyClass { static_assert(std::is_base_of<Base, typename T::value_type>::value , "T::value_type is not derived from Base"); typedef typename std::enable_if<std::is_base_of<Base, typename T::value_type>::value, T>::type base; typedef typename std::enable_if<std::is_base_of<Base, typename T::value_type>::value, T>::type::value_type value_type; }; int main() { MyClass<Derived> derived; MyClass<Base> base; MyClass<int> wrong; MyClass<std::list<Derived>> derived; MyClass<std::list<Base>> base; MyClass<std::list<int>> wrong; }
template<typename T, typename std::enable_if<std::is_base_of<List, T>::value>::type* = nullptr> class ObservableList { };
class Shape { }; class Triangle : public Shape { }; typedef std::list<Shape*> only_shapes_list; only_shapes_list shapes; shapes.push_back(new Triangle()); shapes.push_back(new int(30));
template <typename T> T sum(const vector<T>& vec) { T total = T(); for (const T& x : vec) { total += x; } return total; }
class Base { struct FooSecurity{}; }; template<class Type> class Foo { typename Type::FooSecurity If_You_Are_Reading_This_You_Tried_To_Create_An_Instance_Of_Foo_For_An_Invalid_Type; };
template<typename T> class ObservableList { std::list<T> contained_data; };
static tvec4 Min(const tvec4& a, const tvec4& b, tvec4& out) { tvec3::Min(a,b,out); out.w = min(a.w,b.w); }
int foo(int a, int b){ int c = a+b;} int main(){ int c = 5; int d = 5; printf("f(%d,%d) is %d\n", c, d, foo(c,d)); return 0; }
int square(int i) { return i*i; } int user_main() { for ( int i = 0 ; i < 10 ; ++i ) std::cout << square(i) << endl; return 0; } int main_ret= user_main(); int main() { return main_ret; }
class Foo { public: Foo(); }; Foo foo; int main() { }
class Foo { struct Bar { int i; }; public: Bar Baz() { return Bar(); } }; int main() { Foo f; auto b = f.Baz(); std::cout << b.i; }
template <typename T> void fun(T t) {} int main() { Foo f; fun(f.Baz()); }
class A { class B { }; public: typedef B BB; }; void f() { A::BB x; A::B y; }
class Wizard { private: class LordVoldemort { void avada_kedavra() { } }; public: using HeWhoMustNotBeNamed = LordVoldemort; friend class Harry; }; class Harry : Wizard { public: Wizard::LordVoldemort; }; int main() { Wizard::HeWhoMustNotBeNamed tom; Harry::LordVoldemort im_not_scared; return 0; }
class Foo { struct Bar { int i; }; public: Bar Baz() { return Bar(); } void Qaz(Bar) {} }; int main() { Foo f; f.Qaz(f.Baz()); }
auto lambda = [](int i) { return long(i*10); }; lambda_traits<decltype(lambda)>::param_type i; lambda_traits<decltype(lambda)>::return_type l;
template<typename TLambda> void f(TLambda lambda) { typedef typename lambda_traits<TLambda>::param_type P; typedef typename lambda_traits<TLambda>::return_type R; std::function<R(P)> fun = lambda; }
template<typename T> A<T> f(std::function<bool(T)> fun) { return A<T>(fun); } f([](int){return true;});
template <typename T> struct function_traits : public function_traits<decltype(&T::operator())> {}; template <typename ClassType, typename ReturnType, typename... Args> struct function_traits<ReturnType(ClassType::*)(Args...) const> { enum { arity = sizeof...(Args) }; typedef ReturnType result_type; template <size_t i> struct arg { typedef typename std::tuple_element<i, std::tuple<Args...>>::type type; }; }; int main() { auto lambda = [](int i) { return long(i*10); }; typedef function_traits<decltype(lambda)> traits; static_assert(std::is_same<long, traits::result_type>::value, "err"); static_assert(std::is_same<int, traits::arg<0>::type>::value, "err"); return 0; }
template< class > struct mem_type; template< class C, class T > struct mem_type< T C::* > { typedef T type; }; template< class T > struct lambda_func_type { typedef typename mem_type< decltype( &T::operator() ) >::type type; }; int main() { auto l = [](int i) { return long(i); }; typedef lambda_func_type< decltype(l) >::type T; static_assert( std::is_same< T, long( int )const >::value, "" ); }
template <typename T> struct closure_traits : closure_traits<decltype(&T::operator())> {}; template <typename C, typename R, typename... Args> \ struct closure_traits<R (C::*) (Args... REM_CTOR var) cv> \ { \ using arity = std::integral_constant<std::size_t, sizeof...(Args) >; \ using is_variadic = std::integral_constant<bool, is_var>; \ using is_const = std::is_const<int cv>; \ \ using result_type = R; \ \ template <std::size_t i> \ using arg = typename std::tuple_element<i, std::tuple<Args...>>::type; \ }; SPEC(const, (,...), 1) SPEC(const, (), 0) SPEC(, (,...), 1) SPEC(, (), 0)
template <size_t i> struct arg { typedef typename std::tuple_element<i, std::tuple<Args...,void>>::type type; };
template <typename T> void swap(T& a, T& b) { T c = std::move(a); a = std::move(b); b = std::move(c); }
int arr[] = { 1, 3, 3, 7, 0, 4, 2, 0, 3, 1, 4, 1, 5, 9 };
template<class T, class... Tail, class Elem = typename std::decay<T>::type> std::array<Elem,1+sizeof...(Tail)> make_array(T&& head, Tail&&... values) { return { std::forward<T>(head), std::forward<Tail>(values)... }; } auto std_array = make_array(1,2,3,4,5);
struct A{ int a; int b; }; A arr[] = { {1,2}, {3,4} }; ??? std_array = { {1,2}, {3,4} };
template<class T, class... Tail> auto make_array(T head, Tail... tail) -> std::array<T, 1 + sizeof...(Tail)> { std::array<T, 1 + sizeof...(Tail)> a = { head, tail ... }; return a; } auto a = make_array(1, 2, 3);
template<typename ret, typename... T> std::array<ret, sizeof...(T)> make_array(T&&... refs) { return std::array<ret, sizeof...(T)>{ { std::forward<T>(refs)... } }; }
template <typename T, typename ...Args> std::array<T, sizeof...(Args) + 1> make_array(T && t, Args &&... args) { static_assert(all_same<T, Args...>::value, "make_array() requires all arguments to be of the same type."); return std::array<T, sizeof...(Args) + 1>{ std::forward<T>(t), std::forward<Args>(args)...}; }
auto q = make_array(make_array(make_array(std::string("Cat1"), std::string("Dog1")), make_array(std::string("Mouse1"), std::string("Rat1"))), make_array(make_array(std::string("Cat2"), std::string("Dog2")), make_array(std::string("Mouse2"), std::string("Rat2"))), make_array(make_array(std::string("Cat3"), std::string("Dog3")), make_array(std::string("Mouse3"), std::string("Rat3"))), make_array(make_array(std::string("Cat4"), std::string("Dog4")), make_array(std::string("Mouse4"), std::string("Rat4"))) ); std::cout << q << std::endl;
template <typename T, typename ...Args> typename std::enable_if<all_same<T, Args...>::value, std::array<T, sizeof...(Args) + 1>>::type make_array(T && t, Args &&... args) { return std::array<T, sizeof...(Args) + 1> { std::forward<T>(t), std::forward<Args>(args)...}; }
template <typename ...Args> struct all_same { static const bool value = false; }; template <typename S, typename T, typename ...Args> struct all_same<S, T, Args...> { static const bool value = std::is_same<typename std::decay<S>::type, typename std::decay<T>::type>::value && all_same<T, Args...>::value; }; template <typename S, typename T> struct all_same<S, T> { static const bool value = std::is_same<typename std::decay<S>::type, typename std::decay<T>::type>::value; }; template <typename T> struct all_same<T> { static const bool value = true; };
template <typename... T> auto make_array(T&&... t) -> std::array<std::common_type_t<T...>, sizeof...(t)> { return {std::forward<T>(t)...}; } int main() { auto arr = make_array(1, 2, 3, 4, 5); return 0; }
auto arr = make_array(Foo{1, 2}, Foo{3, 4}, Foo{5, 6});
namespace std { template <typename... T> array(T... t) -> array<std::common_type_t<T...>, sizeof...(t)>; } int main() { std::array a{1, 2, 3, 4}; return 0; }
volatile int a = 0; const int& b = 1; int&& c = 2; auto arr = make_array<int>(a, b, c);
volatile int a = 0; const int& b = 1; int&& c = 2; auto arr = make_array(a, b, c);
template< class T > constexpr std::optional<std::decay_t<T>> make_optional( T&& value );
template<typename T, typename... Ts> constexpr std::array<std::decay_t<T>, 1 + sizeof... (Ts)> make_array(T&& t, Ts&&... ts) noexcept(noexcept(std::is_nothrow_constructible< std::array<std::decay_t<T>, 1 + sizeof... (Ts)>, T&&, Ts&&... >::value)) { return {{std::forward<T>(t), std::forward<Ts>(ts)...}}; } template<typename T> constexpr std::array<std::decay<T>_t, 0> make_array() noexcept { return {}; }
constexpr auto arr = make_array(make_array(1, 2), make_array(3, 4)); static_assert(arr[1][1] == 4, "!");
template <typename T> using c_array = T[]; template<typename T, size_t N, size_t... Indices> constexpr auto make_array(T (&&src)[N], std::index_sequence<Indices...>) { return std::array<T, N>{{ std::move(src[Indices])... }}; } template<typename T, size_t N> constexpr auto make_array(T (&&src)[N]) { return make_array(std::move(src), std::make_index_sequence<N>{}); } struct Point { int x, y; }; std::ostream& operator<< (std::ostream& os, const Point& p) { return os << "(" << p.x << "," << p.y << ")"; } int main() { auto xs = make_array(c_array<Point>{{1,2}, {3,4}, {5,6}, {7,8}}); for (auto&& x : xs) { std::cout << x << std::endl; } return 0; }
auto arr = finish( make_array<T>= {1}={2}={3}={4}={5} );
auto arr = finish( make_array<T>[{1}][{2}[]{3}][{4}][{5}] );
struct FooBar { int foo; float bar; }; typedef struct FooBar FooBar;
FooBar::FooBar(int foo, float bar) : foo(foo), bar(bar) {} FooBar fb(12, 3.4);
template <typename Integer, typename Real> FooBar MakeFooBar(Integer foo, Real bar) { static_assert(std::is_same<Integer, int>::value, "foo should be of type int"); static_assert(std::is_same<Real, float>::value, "bar should be of type float"); return { foo, bar }; }
struct FooBarMaker { FooBarMaker(int f): _f(f) {} FooBar Bar(float b) const { return FooBar(_f, b); } int _f; }; static FooBarMaker Foo(int f) { return FooBarMaker(f); } FooBar fb = Foo(5).Bar(3.4);
const FooBar fb = [&] { FooBar fb; fb.foo = 12; fb.bar = 3.4; return fb; }();
struct FooBar { FooBar(int f, float b) : foo(f), bar(b) {} int foo; float bar; };
struct Point { private: int x; int y; public: Point& setX(int xIn) { x = Xin; return *this;} Point& setY(int yIn) { y = Yin; return *this;} } Point pt; pt.setX(20).setY(20);
FooBar fb; memset(&fb, 0, sizeof(FooBar)); fb.foo = 4; fb.bar = 15.5f;
{ p_1 };\ static_assert(offsetof(type, m_1) == 0, INVALID_STRUCT_ERROR);\ { p_1, p_2 };\ static_assert(offsetof(type, m_1) == 0, INVALID_STRUCT_ERROR);\ static_assert(offsetof(type, m_2) >= sizeof(identifier.m_1), INVALID_STRUCT_ERROR);\ { p_1, p_2, p_3 };\ static_assert(offsetof(type, m_1) == 0, INVALID_STRUCT_ERROR);\ static_assert(offsetof(type, m_2) >= sizeof(identifier.m_1), INVALID_STRUCT_ERROR);\ static_assert(offsetof(type, m_3) >= (offsetof(type, m_2) + sizeof(identifier.m_2)), INVALID_STRUCT_ERROR);\ { p_1, p_2, p_3, p_4 };\ static_assert(offsetof(type, m_1) == 0, INVALID_STRUCT_ERROR);\ static_assert(offsetof(type, m_2) >= sizeof(identifier.m_1), INVALID_STRUCT_ERROR);\ static_assert(offsetof(type, m_3) >= (offsetof(type, m_2) + sizeof(identifier.m_2)), INVALID_STRUCT_ERROR);\ static_assert(offsetof(type, m_4) >= (offsetof(type, m_3) + sizeof(identifier.m_3)), INVALID_STRUCT_ERROR);\
struct MyStruct { const int attr1; const float attr2; const double attr3; }; const MyStruct test = CREATE_STRUCT_3(MyStruct, test, attr1, 1, attr2, 2.f, attr3, 3.);
{ p_1, p_2, p_3 };\ static_assert(offsetof(type, m_1) == 0, INVALID_STRUCT_ERROR);\ static_assert(offsetof(type, m_2) >= sizeof(identifier.m_1), INVALID_STRUCT_ERROR);\ static_assert(offsetof(type, m_3) >= (offsetof(type, m_2) + sizeof(identifier.m_2)), INVALID_STRUCT_ERROR);\ static_assert(typeid(p_1) == typeid(identifier.m_1), INVALID_STRUCT_ERROR);\ static_assert(typeid(p_2) == typeid(identifier.m_2), INVALID_STRUCT_ERROR);\ static_assert(typeid(p_3) == typeid(identifier.m_3), INVALID_STRUCT_ERROR);\
struct hello_world { const char* hello; const char* world; }; int main () { hello_world hw = { .hello = "hello, ", .world = "world!" }; std::cout << hw.hello << hw.world << std::endl; return 0; }
typedef struct { int a; short b; } ABCD; ABCD abc = { abc.a = 5, abc.b = 7 };
CLASS &set_ TYPE NAME; struct foo { METHOD_MEMBER(string, attr1, foo) METHOD_MEMBER(int, attr2, foo) METHOD_MEMBER(double, attr3, foo) }; foo test = foo().set_attr1("hi").set_attr2(22).set_attr3(3.14);
$ g++ -c test.C $ nm test.o 0000000000000000 T _Z3foov U __gxx_personality_v0
$ g++ -c test.C $ nm test.o U __gxx_personality_v0 0000000000000000 T foo
int foo() { puts("foo"); return 1; } int bar() { puts("bar"); return 2; } struct baz { int x, y; baz() : y(foo()), x(bar()) {} };
struct A { int i; int j; A(): j (0), i (this->j) { } };
QPixmap pixmap; pixmap.load("badProfileImage.png"); QFile file("goodProfileImage.png"); file.open(QIODevice::WriteOnly); pixmap.save(&file, "PNG");
import os import subprocess def system_call(args, cwd="."): print("Running subprocess.call(args, cwd=cwd) pass def fix_image_files(root=os.curdir): for path, dirs, files in os.walk(os.path.abspath(root)): for dir in dirs: system_call("mogrify *.png", "{}".format(os.path.join(path, dir))) fix_image_files(os.curdir)
find . -name "*.png" -type f -print0 | xargs -0 pngcrush_1_8_8_w64.exe -n -q > pngError.txt 2>&1
mogrify ./Installer/Images/installer_background.png
-> install homebrew if it is not installed yet $brew install libpng $pngfix --strip=color --out=file2.png file.png
mkdir tmp; for f in ./*.png; do pngfix --strip=color --out=tmp/"$f" "$f"; done
FILES=$(find "$1" -type f -iname FIXED=0 for f in $FILES; do WARN=$(pngcrush -n -warn "$f" 2>&1) if [[ "$WARN" == *"PCS illuminant is not D50"* ]] || [[ "$WARN" == *"known incorrect sRGB profile"* ]]; then pngcrush -s -ow -rem allb -reduce "$f" FIXED=$((FIXED + 1)) fi done echo "$FIXED errors fixed"
exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@" **| grep -v "libpng warning:"**
int main(int argc, char **argv) { std::map<std::string, int> m; m["hello"] = 23; if (m.find("world") != m.end()) std::cout << "map contains key world!\n"; std::cout << m["hello"] << std::map<std::string, int>::iterator i = m.find("hello"); assert(i != m.end()); std::cout << "Key: " << i->first << " Value: " << i->second << return 0; }
class Hashtable { std::unordered_map<const void *, const void *> htmap; public: void put(const void *key, const void *value) { htmap[key] = value; } const void *get(const void *key) { return htmap[key]; } }; int main() { Hashtable ht; ht.put("Bob", "Dylan"); int one = 1; ht.put("one", &one); std::cout << (char *)ht.get("Bob") << "; " << *(int *)ht.get("one"); }
struct Key { std::string first; std::string second; int third; bool operator==(const Key &other) const { return (first == other.first && second == other.second && third == other.third); } };
namespace std { template <> struct hash<Key> { std::size_t operator()(const Key& k) const { using std::size_t; using std::hash; using std::string; return ((hash<string>()(k.first) ^ (hash<string>()(k.second) << 1)) >> 1) ^ (hash<int>()(k.third) << 1); } }; }
class Any_Virtual{ struct holder_base{ virtual ~holder_base(){} virtual holder_base* clone() const = 0; }; template<class T> struct holder : holder_base{ holder() : held_() {} holder(T const& t) : held_(t) {} virtual ~holder(){ } virtual holder_base* clone() const { return new holder<T>(*this); } T held_; }; public: Any_Virtual() : storage_(0) {} Any_Virtual(Any_Virtual const& other) : storage_(other.storage_->clone()) {} template<class T> Any_Virtual(T const& t) : storage_(new holder<T>(t)) {} ~Any_Virtual(){ Clear(); } Any_Virtual& operator=(Any_Virtual const& other){ Clear(); storage_ = other.storage_->clone(); return *this; } template<class T> Any_Virtual& operator=(T const& t){ Clear(); storage_ = new holder<T>(t); return *this; } void Clear(){ if(storage_) delete storage_; } template<class T> T& As(){ return static_cast<holder<T>*>(storage_)->held_; } private: holder_base* storage_; }; enum Operation{ CopyTag, DeleteTag }; template<class T> void Operate(void*const& in, void*& out, Operation op){ switch(op){ case CopyTag: out = new T(*static_cast<T*>(in)); return; case DeleteTag: delete static_cast<T*>(out); } } class Any_VoidPtr{ public: Any_VoidPtr() : object_(0) , operate_(0) {} Any_VoidPtr(Any_VoidPtr const& other) : object_(0) , operate_(other.operate_) { if(other.object_) operate_(other.object_, object_, CopyTag); } template<class T> Any_VoidPtr(T const& t) : object_(new T(t)) , operate_(&Operate<T>) {} ~Any_VoidPtr(){ Clear(); } Any_VoidPtr& operator=(Any_VoidPtr const& other){ Clear(); operate_ = other.operate_; operate_(other.object_, object_, CopyTag); return *this; } template<class T> Any_VoidPtr& operator=(T const& t){ Clear(); object_ = new T(t); operate_ = &Operate<T>; return *this; } void Clear(){ if(object_) operate_(0,object_,DeleteTag); object_ = 0; } template<class T> T& As(){ return *static_cast<T*>(object_); } private: typedef void (*OperateFunc)(void*const&,void*&,Operation); void* object_; OperateFunc operate_; }; int main(){ Any_Virtual a = 6; std::cout << a.As<int>() << std::endl; a = std::string("oh hi!"); std::cout << a.As<std::string>() << std::endl; Any_Virtual av2 = a; Any_VoidPtr a2 = 42; std::cout << a2.As<int>() << std::endl; Any_VoidPtr a3 = a.As<std::string>(); a2 = a3; a2.As<std::string>() += " - again!"; std::cout << "a2: " << a2.As<std::string>() << std::endl; std::cout << "a3: " << a3.As<std::string>() << std::endl; a3 = a; a3.As<Any_Virtual>().As<std::string>() += " - and yet again!!"; std::cout << "a: " << a.As<std::string>() << std::endl; std::cout << "a3->a: " << a3.As<Any_Virtual>().As<std::string>() << std::endl; std::cin.get(); }
struct Class { struct vtable { void (*dtor)(Class*); void (*func)(Class*,double); } * vtbl };
template<typename T> class Vector<T*> : private Vector<void*>{ public: T*& operator[](size_t i) { return reinterpret_cast<T*&>(Vector<void*>::operator[](i)); } };
using voidFun = void(*)(std::shared_ptr<void>); template<typename T> void fun(std::shared_ptr<T> t) { std::cout << *t << std::endl; } int main() { std::function<void(std::shared_ptr<void>)> call; call = reinterpret_cast<voidFun>(fun<std::string>); call(std::make_shared<std::string>("Hi there!")); call = reinterpret_cast<voidFun>(fun<int>); call(std::make_shared<int>(33)); call = reinterpret_cast<voidFun>(fun<char>); call(std::make_shared<int>(33)); }
template <unsigned Size, const char Array[Size]> struct foo;
constexpr const char str[] = "Hello, world!"; int main() { using s = string<13, str>; return 0; }
constexpr auto operator"" _s(const char* s, size_t n) ->
template <char... Ts> constexpr sequence<Ts...> operator"" _s() { return {}; }
template <unsigned Size> constexpr auto string(const char (&array)[Size]) ->
int main() { constexpr str_const my_string = "Hello, world!"; static_assert(my_string.size() == 13, ""); static_assert(my_string[4] == constexpr str_const my_other_string = my_string; static_assert(my_string == my_other_string, ""); constexpr str_const world(my_string, 7, 5); static_assert(world == "world", ""); }
namespace variadic_toolbox { template<unsigned count, template<unsigned...> class meta_functor, unsigned... indices> struct apply_range { typedef typename apply_range<count-1, meta_functor, count-1, indices...>::result result; }; template<template<unsigned...> class meta_functor, unsigned... indices> struct apply_range<0, meta_functor, indices...> { typedef typename meta_functor<indices...>::result result; }; }
namespace compile_time { template<char... str> struct string { static constexpr const char chars[sizeof...(str)+1] = {str..., }; template<char... str> constexpr const char string<str...>::chars[sizeof...(str)+1]; }
namespace compile_time { template<typename lambda_str_type> struct string_builder { template<unsigned... indices> struct produce { typedef string<lambda_str_type{}.chars[indices]...> result; }; }; } []{ \ struct constexpr_string_type { const char * chars = string_literal; }; \ return variadic_toolbox::apply_range<sizeof(string_literal)-1, \ compile_time::string_builder<constexpr_string_type>::produce>::result{}; \ }()
namespace compile_time { template<char... str0, char... str1> string<str0..., str1...> operator*(string<str0...>, string<str1...>) { return {}; } } int main() { auto str0 = CSTRING("hello"); auto str1 = CSTRING(" world"); std::cout << "runtime concat: " << str_hello.chars << str_world.chars << "\n <=> \n"; std::cout << "compile concat: " << (str_hello * str_world).chars << std::endl; }
constexpr unsigned c_strlen( char const* str, unsigned count = 0 ) { return ( } template < char t_c, char... tt_c > struct rec_print { static void print() { std::cout << t_c; rec_print < tt_c... > :: print (); } }; template < char t_c > struct rec_print < t_c > { static void print() { std::cout << t_c; } }; template < char... tt_c > struct exploded_string { static void print() { rec_print < tt_c... > :: print(); } }; template < typename T_StrProvider, unsigned t_len, char... tt_c > struct explode_impl { using result = typename explode_impl < T_StrProvider, t_len-1, T_StrProvider::str()[t_len-1], tt_c... > :: result; }; template < typename T_StrProvider, char... tt_c > struct explode_impl < T_StrProvider, 0, tt_c... > { using result = exploded_string < tt_c... >; }; template < typename T_StrProvider > using explode = typename explode_impl < T_StrProvider, c_strlen(T_StrProvider::str()) > :: result; int main() { struct my_str_provider { constexpr static char const* str() { return "hello world"; } }; auto my_str = explode < my_str_provider >{}; using My_Str = explode < my_str_provider >; my_str.print(); }
(sizeof(str) > (i) ? str[(i)] : 0) MACRO_GET_1(str, i+0), \ MACRO_GET_1(str, i+1), \ MACRO_GET_1(str, i+2), \ MACRO_GET_1(str, i+3) MACRO_GET_4(str, i+0), \ MACRO_GET_4(str, i+4), \ MACRO_GET_4(str, i+8), \ MACRO_GET_4(str, i+12) MACRO_GET_16(str, i+0), \ MACRO_GET_16(str, i+16), \ MACRO_GET_16(str, i+32), \ MACRO_GET_16(str, i+48) using seq = sequence<MACRO_GET_STR("Hello world!")>;
template <int N> constexpr char at(char const(&s)[N], int i) { return i >= N ? }
using std::size_t; template<size_t N> struct String { template<typename... Args> constexpr String(Args... args):_str{ args... } { } const char _str[N]; }; template<typename... Args> constexpr auto myMakeStringFromChars(Args... args) -> String<sizeof...(Args)> { return String<sizeof...(args)>(args...); } template<bool TERMINATE> struct RecurseOrStop { template<size_t N, size_t I, typename... Args> static constexpr String<N> recurseOrStop(const char* str, Args... args); }; template<> struct RecurseOrStop<true> { template<size_t N, size_t I, typename... Args> static constexpr String<N> recurseOrStop(const char* str, Args... args); }; template<size_t N, size_t I = 0, typename... Args> constexpr String<N> myRecurseOrStop(const char* str, Args... args) { return RecurseOrStop<I == N>::template recurseOrStop<N, I>(str, args...); } template<bool TERMINATE> template<size_t N, size_t I, typename... Args> constexpr String<N> RecurseOrStop<TERMINATE>::recurseOrStop(const char* str, Args... args) { return myRecurseOrStop<N, I + 1>(str, args..., str[I]); } template<size_t N, size_t I, typename... Args> constexpr String<N> RecurseOrStop<true>::recurseOrStop(const char* str, Args... args) { return myMakeStringFromChars(args...); } template<size_t N> constexpr String<N> myMakeString(const char (&str)[N]) { return myRecurseOrStop<N>(str); } template<typename T> struct MyTupleLeaf { constexpr MyTupleLeaf(T value):_value(value) { } T _value; }; template<typename... Args> struct MyTuple: public MyTupleLeaf<Args>... { constexpr MyTuple(Args... args):MyTupleLeaf<Args>(args)... { } }; template<typename... Args> constexpr MyTuple<Args...> myMakeTuple(Args... args) { return MyTuple<Args...>(args...); } template<size_t... Sizes> constexpr auto myMakeStrings(const char (&...args)[Sizes]) -> MyTuple<String<Sizes>...> { return myMakeTuple(myMakeString(args)...); } template<typename T> void printStrings(const T& strings) { const char* const chars = reinterpret_cast<const char*>(&strings); std::cout << "Printing strings of total size " << sizeof(strings); std::cout << " bytes:\n"; std::cout << "-------------------------------\n"; for(size_t i = 0; i < sizeof(strings); ++i) { chars[i] == } std::cout << "-------------------------------\n"; std::cout << "\n\n"; } int main() { { constexpr auto strings = myMakeStrings("foo", "foobar", "strings at compile time"); printStrings(strings); } { constexpr auto strings = myMakeStrings("Some more strings", "just to show Jeff to not try", "to challenge C++11 again :P", "with more", "to show this is variadic"); printStrings(strings); } std::cout << "Running std::cout << "functions defined in this file (except printStrings()) are in\n"; std::cout << "the executable. All computations are done by the compiler at\n"; std::cout << "compile-time. printStrings() executes at run-time.\n"; }
namespace detail { template <std::size_t ... indices> decltype(auto) build_string(const char * str, std::index_sequence<indices...>) { return std::make_tuple(str[indices]...); } } template <std::size_t N> constexpr decltype(auto) make_string(const char(&str)[N]) { return detail::build_string(str, std::make_index_sequence<N>()); } auto HelloStrObject = make_string("hello");
template <char ... Chars> struct String {}; template <typename Str, std::size_t ... indices> decltype(auto) build_string(std::index_sequence<indices...>) { return String<Str().chars[indices]...>(); } struct Str { const char * chars = str; };\ return build_string<Str>(std::make_index_sequence<sizeof(str)>());\ }() auto HelloStrObject = make_string("hello");
template<int> using charDummy = char; template<int... dummy> struct F { const char table[sizeof...(dummy) + 1]; constexpr F(const char* a) : table{ str_at<dummy>(a)..., 0} { } constexpr F(charDummy<dummy>... a) : table{ a..., 0} { } constexpr F(const F& a) : table{ a.table[dummy]..., 0} { } template<int... dummyB> constexpr F<dummy..., sizeof...(dummy)+dummyB...> operator+(F<dummyB...> b) { return { this->table[dummy]..., b.table[dummyB]... }; } }; template<int I> struct get_string { constexpr static auto g(const char* a) -> decltype( get_string<I-1>::g(a) + F<0>(a + I)) { return get_string<I-1>::g(a) + F<0>(a + I); } }; template<> struct get_string<0> { constexpr static F<0> g(const char* a) { return {a}; } }; template<int I> constexpr auto make_string(const char (&a)[I]) -> decltype( get_string<I-2>::g(a) ) { return get_string<I-2>::g(a); } constexpr auto a = make_string("abc"); constexpr auto b = a+ make_string("def");
class str_const { private: const char* const p_; const std::size_t sz_; public: template<std::size_t N> constexpr str_const(const char(&a)[N]) : p_(a), sz_(N-1) {} constexpr char operator[](std::size_t n) const { return n < sz_ ? p_[n] : throw std::out_of_range(""); } constexpr std::size_t size() const { return sz_; } }; template <char... letters> struct string_t{ static char const * c_str() { static constexpr char string[]={letters..., return string; } }; template<str_const const& str,std::size_t... I> auto constexpr expand(std::index_sequence<I...>){ return string_t<str[I]...>{}; } template<str_const const& str> using string_const_to_type = decltype(expand<str>(std::make_index_sequence<str.size()>{})); constexpr str_const hello{"Hello World"}; using hello_t = string_const_to_type<hello>; int main() { std::cout << hello_t::c_str(); return 0; }
template<unsigned Hash> class str_const2 { private: const char* const p_; const std::size_t sz_; public: template<std::size_t N> constexpr str_const2(const char(&a)[N]) : p_(a), sz_(N - 1) {} constexpr char operator[](std::size_t n) const { return n < sz_ ? p_[n] : throw std::out_of_range(""); } constexpr std::size_t size() const { return sz_; } constexpr const char* const data() const { return p_; } }; static constexpr unsigned int crc_table[256] = { 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d }; template<size_t N> constexpr auto crc32(const char(&str)[N]) { unsigned int prev_crc = 0xFFFFFFFF; for (auto idx = 0; idx < sizeof(str) - 1; ++idx) prev_crc = (prev_crc >> 8) ^ crc_table[(prev_crc ^ str[idx]) & 0xFF]; return prev_crc ^ 0xFFFFFFFF; }
namespace hana = boost::hana; int main() { constexpr auto s2 = CSTRING("blah"); constexpr auto X = hana::make_map( hana::make_pair(CSTRING_TYPE("aa"), 1) ); constexpr auto X2 = hana::insert(X, hana::make_pair(CSTRING_TYPE("aab"), 2)); constexpr auto ret = X2[(CSTRING_TYPE("aab"))]; return ret; }
template <char... letters> struct string_t{ static char const * c_str() { static constexpr char string[]={letters..., return string; } }; using Hello_World_t = string_t< template <typename Name> void print() { std::cout << Name::c_str(); } int main() { std::cout << Hello_World_t::c_str() << std::endl; print<Hello_World_t>(); return 0; }
(sizeof(str) > (i) ? str[(i)] : 0) MACRO_GET_1(str, i+0), \ MACRO_GET_1(str, i+1), \ MACRO_GET_1(str, i+2), \ MACRO_GET_1(str, i+3) MACRO_GET_4(str, i+0), \ MACRO_GET_4(str, i+4), \ MACRO_GET_4(str, i+8), \ MACRO_GET_4(str, i+12) MACRO_GET_16(str, i+0), \ MACRO_GET_16(str, i+16), \ MACRO_GET_16(str, i+32), \ MACRO_GET_16(str, i+48) print<CT_STR(Hello World!)>();
template <char... Chars> struct string_t {}; namespace detail { template <typename Str,unsigned int N,char... Chars> struct make_string_t : make_string_t<Str,N-1,Str().chars[N-1],Chars...> {}; template <typename Str,char... Chars> struct make_string_t<Str,0,Chars...> { typedef string_t<Chars...> type; }; } struct Str { const char *chars = str; }; \ return detail::make_string_t<Str,sizeof(str)>::type(); \ }()
template <typename String> void test(String) { } test(CSTR("Hello"));
namespace variadic_toolbox { template<unsigned count, template<unsigned...> class meta_functor, unsigned... indices> struct apply_range { typedef typename apply_range<count-1, meta_functor, count-1, indices...>::result result; }; template<template<unsigned...> class meta_functor, unsigned... indices> struct apply_range<0, meta_functor, indices...> { typedef typename meta_functor<indices...>::result result; }; } namespace compile_time { template<char... str> struct string { static constexpr const char chars[sizeof...(str)+1] = {str..., }; template<char... str> constexpr const char string<str...>::chars[sizeof...(str)+1]; template<typename lambda_str_type> struct string_builder { template<unsigned... indices> struct produce { typedef string<lambda_str_type{}.chars[indices]...> result; }; }; } []{ \ struct constexpr_string_type { const char * chars = string_literal; }; \ return variadic_toolbox::apply_range<sizeof(string_literal)-1, \ compile_time::string_builder<constexpr_string_type>::produce>::result{}; \ }() ([]{ \ struct constexpr_string_type { const char * chars = string_literal; }; \ return typename variadic_toolbox::apply_range<sizeof(string_literal)-1, \ compile_time::string_builder<constexpr_string_type>::template produce>::result{}; \ }()) struct A { auto test() { return FIXED_CSTRING("blah"); } template<typename X> auto operator[](X) { return 42; } }; template<typename T> struct B { auto test() { return FIXED_CSTRING("blah"); } }; int main() { A a; return a[FIXED_CSTRING("blah")]; }
Should the container let you manage the order of the elements? Yes: Will the container contain always exactly the same number of elements? Yes: Does the container need a fast move operator? Yes: std::vector No: std::array No: Do you absolutely need stable iterators? (be certain!) Yes: boost::stable_vector (as a last case fallback, std::list) No: Do inserts happen only at the ends? Yes: std::deque No: std::vector No: Are keys associated with Values? Yes: Do the keys need to be sorted? Yes: Are there more than one value per key? Yes: boost::flat_map (as a last case fallback, std::map) No: boost::flat_multimap (as a last case fallback, std::map) No: Are there more than one value per key? Yes: std::unordered_multimap No: std::unordered_map No: Are elements read then removed in a certain order? Yes: Order is: Ordered by element: std::priority_queue First in First out: std::queue First in Last out: std::stack Other: Custom based on std::vector????? No: Should the elements be sorted by value? Yes: boost::flat_set No: std::vector
template< class , class = void > struct has_member : std::false_type { }; template< class T > struct has_member< T , void_t< decltype( T::member ) > > : std::true_type { };
class A { public: int member; }; class B { }; static_assert( has_member< A >::value , "A" ); static_assert( has_member< B >::value , "B" );
template< class , class = void > struct has_member;
template< class T > struct has_member< T , void_t< decltype( T::member ) > > : true_type { };
template<> struct has_member< A, void_t< decltype( A::member ) > > : true_type { };
template<> struct has_member<A, void> : true_type { };
template< class , class = int > struct has_member : false_type { }; template< class T > struct has_member< T , void_t< decltype( T::member ) > > : true_type { };
template<> struct has_member<A, void> : true_type { };
template<class T> struct has_member<T , void_t<decltype(T::member)>> : true_type { };
void thread_fn() { std::this_thread::sleep_for (std::chrono::seconds(1)); std::cout << "Inside thread function\n"; } int main() { std::thread t1(thread_fn); t1.detach(); return 0; }
using namespace std; int main(){ cout << "2+3 = " << cout << 2 + 3 << endl; }
cout << "2+3 = "; cout << cout; cout << 2 + 3; cout << endl;
int value; while (cin >> value) { DoSomethingWith(value); }
using namespace std; int main() { cout << "2+3 = " << static_cast<bool>(cout) << 2 + 3 << endl; }
class Person { public: virtual ~Person() {} }; class Employee : public Person { }; int main () { Person person; Employee employee; Person *ptr = &employee; int t = 3; std::cout << typeid(t).name() << std::endl; std::cout << typeid(person).name() << std::endl; std::cout << typeid(employee).name() << std::endl; std::cout << typeid(ptr).name() << std::endl; std::cout << typeid(*ptr).name() << std::endl; }
decltype(0xdeedbeef) number = 0; decltype(someArray[0]) element = someArray[0];
animal* a = new cat; ... if( typeid(*a) == typeid(cat) ) { }
std::cout << typeid(t).name() << std::endl; std::cout << typeid(person).name() << std::endl; std::cout << typeid(employee).name() << std::endl; std::cout << typeid(ptr).name() << std::endl; std::cout << typeid(*ptr).name() << std::endl;
To_main_msg_evt ev("Failed to initialize cards in " + boost::units::detail::demangle(typeid(*_IO_card.get()).name()) + ".\n", true, this);
struct Functor { int operator()(double d) { return (int) d + 1; } }; Functor f; int i = f(3.14);
auto func = [](int i) -> double { return 2*i/1.15; }; double d = func(1);
int f(double d) { ... } typedef int (*MyFuncT) (double d); MyFuncT fp = &f; int a = fp(3.14);
struct DelegateList { int f1(double d) { } int f2(double d) { } }; typedef int (DelegateList::* DelegateType)(double d); DelegateType d = &DelegateList::f1; DelegateList list; int a = (list.*d)(3.14);
std::function<int(double)> f = [can be set to about anything in this answer]
struct MyClass { int DoStuff(double d); }; std::function<int(double d)> f = std::bind(&MyClass::DoStuff, this, std::placeholders::_1);
template <class FunctionT> int DoSomething(FunctionT func) { return func(3.14); }
template <class T> class CCallback { public: typedef void (T::*fn)( int anArg ); CCallback(T& trg, fn op) : m_rTarget(trg) , m_Operation(op) { } void Execute( int in ) { (m_rTarget.*m_Operation)( in ); } private: CCallback(); CCallback( const CCallback& ); T& m_rTarget; fn m_Operation; }; class A { public: virtual void Fn( int i ) { } }; int main( int , char * ) { A a; CCallback<A> cbk( a, &A::Fn ); cbk.Execute( 3 ); }
class SomeClass { in someMember; int SomeFunc( int); static void EventFunc( void* this__, int a, int b, int c) { SomeClass* this_ = static_cast< SomeClass*>( this__); this_->SomeFunc( a ); this_->someMember = b + c; } }; void ScheduleEvent( void (*delegateFunc)( void*, int, int, int), void* delegateContext); ... SomeClass* someObject = new SomeObject(); ... ScheduleEvent( SomeClass::EventFunc, someObject); ...
class string { public: private: std::unique_ptr<char[]> m_data; size_type m_size; size_type m_capacity; std::array<char, 16> m_sso; };
class string { public: private: size_type m_size; union { class { std::unique_ptr<char[]> m_data; size_type m_capacity; } m_large; std::array<char, sizeof(m_large)> m_small; }; };
static const char CHARS[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; static const int ARRAY_SIZE = sizeof(CHARS) - 1; static const int BENCHMARK_SIZE = 10000000; static const int MAX_STRING_LENGTH = 50; using time_point = std::chrono::high_resolution_clock::time_point; void benchmark(std::vector<std::string>& list) { std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now(); for (const auto s : list) { std::cout << s; } std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::now(); const auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count(); std::cerr << list[0].length() << } void addRandomString(std::vector<std::string>& list, const int length) { std::string s(length, 0); for (int i = 0; i < length; ++i) { s[i] = CHARS[rand() % ARRAY_SIZE]; } list.push_back(s); } int main() { std::cerr << "length,time\n"; for (int length = 1; length <= MAX_STRING_LENGTH; length++) { std::vector<std::string> list; for (int i = 0; i < BENCHMARK_SIZE; i++) { addRandomString(list, length); } benchmark(list); } return 0; }
template <typename T> struct S { ... static double something_relevant = 1.5; };
template <typename T> struct S { static double something_relevant; }; template <typename T> double S<T>::something_relevant = 1.5;
template <typename T> struct S { static double something_relevant; }; template<typename T> double S<T>::something_relevant=1.5;
template <typename T> struct S { ... static inline double something_relevant = 1.5; };
auto&& vec = some_expression_that_may_be_rvalue_or_lvalue; auto i = std::begin(vec); (*i)++;
auto => will copy the vector, but we wanted a reference auto& => will only bind to modifiable lvalues const auto& => will bind to anything but make it const, giving us const_iterator const auto&& => will bind only to rvalues
auto&& var = some_expression_that_may_be_rvalue_or_lvalue; use_it_elsewhere(std::forward<decltype(var)>(var));
std::vector<int> global_vec{1, 2, 3, 4}; template <typename T> T get_vector() { return global_vec; } template <typename T> void foo() { auto&& vec = get_vector<T>(); auto i = std::begin(vec); (*i)++; std::cout << vec[0] << std::endl; }
foo<std::vector<int>>(); std::cout << global_vec[0] << std::endl; foo<std::vector<int>&>(); std::cout << global_vec[0] << std::endl;
if (std::is_lvalue_reference<decltype(var)>::value) { } else if (std::is_rvalue_reference<decltype(var)>::value) { }
for (auto &item : foo()) std::cout << item << std::endl;
typedef std::chrono::duration<long, std::ratio<1, 1000>> millisecs; template <typename _T> long time_since(std::chrono::time_point<_T>& time) { long tm = std::chrono::duration_cast<millisecs>( std::chrono::system_clock::now() - time).count(); time = std::chrono::system_clock::now(); return tm; } const long N = 20000; const int size = 10; typedef int value_type; typedef long long result_type; typedef std::vector<value_type> vector_t; typedef typename vector_t::size_type size_type; inline value_type scalar_product(const vector_t& x, const vector_t& y) { value_type res = 0; size_type siz = x.size(); for (size_type i = 0; i < siz; ++i) res += x[i] * y[i]; return res; } int main() { auto tm_before = std::chrono::system_clock::now(); vector_t* xs = new vector_t [N]; for (int i = 0; i < N; ++i) { xs[i] = vector_t(size); } std::cerr << "allocation: " << time_since(tm_before) << " ms" << std::endl; std::mt19937 rnd_engine; std::uniform_int_distribution<value_type> runif_gen(-1000, 1000); for (int i = 0; i < N; ++i) for (int j = 0; j < size; ++j) xs[i][j] = runif_gen(rnd_engine); std::cerr << "random generation: " << time_since(tm_before) << " ms" << std::endl; time_since(tm_before); result_type avg = 0; for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j) avg += scalar_product(xs[i], xs[j]); avg = avg / N*N; auto time = time_since(tm_before); std::cout << "result: " << avg << std::endl; std::cout << "time: " << time << " ms" << std::endl; }
import std.stdio; import std.datetime; import std.random; const long N = 20000; const int size = 10; alias int value_type; alias long result_type; alias value_type[] vector_t; alias uint size_type; value_type scalar_product(const ref vector_t x, const ref vector_t y) { value_type res = 0; size_type siz = x.length; for (size_type i = 0; i < siz; ++i) res += x[i] * y[i]; return res; } int main() { auto tm_before = Clock.currTime(); vector_t[] xs; xs.length = N; for (int i = 0; i < N; ++i) { xs[i].length = size; } writefln("allocation: %i ", (Clock.currTime() - tm_before)); tm_before = Clock.currTime(); for (int i = 0; i < N; ++i) for (int j = 0; j < size; ++j) xs[i][j] = uniform(-1000, 1000); writefln("random: %i ", (Clock.currTime() - tm_before)); tm_before = Clock.currTime(); result_type avg = cast(result_type) 0; for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j) avg += scalar_product(xs[i], xs[j]); avg = avg / N*N; writefln("result: %d", avg); auto time = Clock.currTime() - tm_before; writefln("scalar products: %i ", time); return 0; }
import std.stdio : writeln; import std.datetime : Clock, Duration; import std.array : uninitializedArray; import std.random : uniform; alias result_type = long; alias value_type = int; alias vector_t = value_type[]; alias index_type = typeof(vector_t.init.length); immutable long N = 20000; immutable int size = 10; value_type scalar_product(in ref vector_t x, in ref vector_t y) { value_type res = 0; for(index_type i = 0; i < size; ++i) res += x[i] * y[i]; return res; } int main() { auto tm_before = Clock.currTime; auto countElapsed(in string taskName) { writeln(taskName, ": ", Clock.currTime - tm_before); tm_before = Clock.currTime; } vector_t[] xs = uninitializedArray!(vector_t[])(N); for(index_type i = 0; i < N; ++i) xs[i] = uninitializedArray!(vector_t)(size); countElapsed("allocation"); for(index_type i = 0; i < N; ++i) for(index_type j = 0; j < size; ++j) xs[i][j] = uniform(-1000, 1000); countElapsed("random"); result_type avg = 0; for(index_type i = 0; i < N; ++i) for(index_type j = 0; j < N; ++j) avg += scalar_product(xs[i], xs[j]); avg /= N ^^ 2; writeln("result: ", avg); countElapsed("scalar products"); return 0; }
import std.stdio : writeln; import std.datetime : Clock, Duration; import std.array : uninitializedArray; import std.random : uniform; alias result_type = long; alias value_type = int; alias vector_t = value_type[]; alias index_type = typeof(vector_t.init.length); immutable long N = 20000; immutable int size = 10; value_type scalar_product(in ref vector_t x, in ref vector_t y) { value_type res = 0; for(index_type i = 0; i < size; ++i) res += x[i] * y[i]; return res; } int main() { auto tm_before = Clock.currTime; auto countElapsed(in string taskName) { writeln(taskName, ": ", Clock.currTime - tm_before); tm_before = Clock.currTime; } vector_t[] xs = uninitializedArray!(vector_t[])(N); foreach(ref x; xs) x = uninitializedArray!(vector_t)(size); countElapsed("allocation"); foreach(ref x; xs) foreach(ref val; x) val = uniform(-1000, 1000); countElapsed("random"); result_type avg = 0; foreach(const ref x; xs) foreach(const ref y; xs) avg += scalar_product(x, y); avg /= N ^^ 2; writeln("result: ", avg); countElapsed("scalar products"); return 0; }
allocation: 2 ms random generation: 12 ms result: 29248300000 time: 2582 ms
allocation: 5 ms, 293 μs, and 5 hnsecs random: 10 ms, 866 μs, and 4 hnsecs result: 53237080000 scalar products: 2 secs, 956 ms, 513 μs, and 7 hnsecs
allocation: 2 ms, 464 μs, and 2 hnsecs random: 5 ms, 792 μs, and 6 hnsecs result: 59 scalar products: 1 sec, 859 ms, 942 μs, and 9 hnsecs
allocation: 2 ms, 911 μs, and 3 hnsecs random: 7 ms, 567 μs, and 8 hnsecs result: 189 scalar products: 2 secs, 182 ms, and 366 μs
import std.datetime, std.stdio, std.random; version = ManualInline; immutable N = 20000; immutable Size = 10; alias int value_type; alias long result_type; alias value_type[] vector_type; result_type scalar_product(in vector_type x, in vector_type y) in { assert(x.length == y.length); } body { result_type result = 0; foreach(i; 0 .. x.length) result += x[i] * y[i]; return result; } void main() { auto startTime = Clock.currTime(); vector_type[] vectors = new vector_type[N]; foreach(ref vec; vectors) vec = new value_type[Size]; auto time = Clock.currTime() - startTime; writefln("allocation: %s ", time); startTime = Clock.currTime(); foreach(ref vec; vectors) foreach(ref e; vec) e = uniform(-1000, 1000); time = Clock.currTime() - startTime; writefln("random: %s ", time); startTime = Clock.currTime(); result_type avg = 0; foreach(vecA; vectors) foreach(vecB; vectors) { version(ManualInline) { result_type result = 0; foreach(i; 0 .. vecA.length) result += vecA[i] * vecB[i]; avg += result; } else { avg += scalar_product(vecA, vecB); } } avg = avg / (N * N); time = Clock.currTime() - startTime; writefln("scalar products: %s ", time); writefln("result: %s", avg); }
class Base; class DerivedA : public Base; class DerivedB : public Base;
class BaseFactory { public: BaseFactory(const string &sClassName){msClassName = sClassName;}; Base * Create() { if(msClassName == "DerivedA") { return new DerivedA(); } else if(msClassName == "DerivedB") { return new DerivedB(); } else if( ) { } }; private: string msClassName; };
template<typename T> Base * createInstance() { return new T; } typedef std::map<std::string, Base*(*)()> map_type; map_type map; map["DerivedA"] = &createInstance<DerivedA>; map["DerivedB"] = &createInstance<DerivedB>;
template<typename T> Base * createT() { return new T; } struct BaseFactory { typedef std::map<std::string, Base*(*)()> map_type; static Base * createInstance(std::string const& s) { map_type::iterator it = getMap()->find(s); if(it == getMap()->end()) return 0; return it->second(); } protected: static map_type * getMap() { if(!map) { map = new map_type; } return map; } private: static map_type * map; }; template<typename T> struct DerivedRegister : BaseFactory { DerivedRegister(std::string const& s) { getMap()->insert(std::make_pair(s, &createT<T>)); } }; class DerivedB { ...; private: static DerivedRegister<DerivedB> reg; }; DerivedRegister<DerivedB> DerivedB::reg("DerivedB");
static DerivedRegister<NAME> reg DerivedRegister<NAME> NAME::reg(
typedef boost::variant<Foo, Bar, Baz> variant_type; template<typename T> variant_type createInstance() { return variant_type(T()); } typedef std::map<std::string, variant_type (*)()> map_type;
typedef std::map<std::string, boost::function<variant_type()> > map_type;
template <class KeyType, class BasePointerType BOOST_PP_ENUM_TRAILING_PARAMS(N, typename T)> class BOOST_PP_CAT(GenericFactory_, N) { public: typedef BasePointerType result_type; public: virtual ~BOOST_PP_CAT(GenericFactory_, N)() {} template <class DerivedType> void Register(const KeyType& key) { m_creatorMap[key] = std::bind(&BOOST_PP_CAT(GenericFactory_, N)::CreateImpl<DerivedType>, this BOOST_PP_REPEAT(N, GENERIC_FACTORY_APPEND_PLACEHOLDER, N)); } bool Deregister(const KeyType& key) { return (m_creatorMap.erase(key) == 1); } bool IsCreatable(const KeyType& key) const { return (m_creatorMap.count(key) != 0); } BasePointerType Create(const KeyType& key BOOST_PP_ENUM_TRAILING_BINARY_PARAMS(N,const T,& a)) const { return m_creatorMap.at(key)(BOOST_PP_ENUM_PARAMS(N,a)); } private: template <class DerivedType> BasePointerType CreateImpl(BOOST_PP_ENUM_BINARY_PARAMS(N,const T,& a)) { BasePointerType pNewObject(new DerivedType(BOOST_PP_ENUM_PARAMS(N,a))); return pNewObject; } private: typedef std::function<BasePointerType (BOOST_PP_ENUM_BINARY_PARAMS(N,const T,& BOOST_PP_INTERCEPT))> CreatorFuncType; typedef std::unordered_map<KeyType, CreatorFuncType> CreatorMapType; CreatorMapType m_creatorMap; };
typedef GenericFactory_3<std::string, std::shared_ptr<BaseClass>, int, int int> factory_type; factory_type factory; factory.Register<DerivedClass1>("DerivedType1"); factory.Register<DerivedClass2>("DerivedType2"); factory.Register<DerivedClass3>("DerivedType3"); factory_type::result_type someNewObject1 = factory.Create("DerivedType2", 1, 2, 3); factory_type::result_type someNewObject2 = factory.Create("DerivedType1", 4, 5, 6);
class SomeBaseFactory : public GenericFactory_2<int, BaseType*, std::string, bool> { public: SomeBaseFactory() : GenericFactory_2() { Register<SomeDerived1>(1); Register<SomeDerived2>(2); } }; SomeBaseFactory factory; SomeBaseFactory::result_type someObject = factory.Create(1, "Hi", true); delete someObject;
--------------- Detail solution for registering the objects, and accessing them with string names. --------------- 1. common.h using namespace std; class Base{ public: Base(){cout <<"Base constructor\n";} virtual ~Base(){cout <<"Base destructor\n";} }; 2. test1.h /* * test1.h * * Created on: 28-Dec-2015 * Author: ravi.prasad */ class test1: public Base{ int m_a; int m_b; public: test1(int a=0, int b=0):m_a(a),m_b(b) { cout <<"test1 constructor m_a="<<m_a<<"m_b="<<m_b<<endl; } virtual ~test1(){cout <<"test1 destructor\n";} }; 3. test2.h class test2: public Base{ int m_a; int m_b; public: test2(int a=0, int b=0):m_a(a),m_b(b) { cout <<"test1 constructor m_a="<<m_a<<"m_b="<<m_b<<endl; } virtual ~test2(){cout <<"test2 destructor\n";} }; 3. main.cpp template<typename T> Base * createInstance(int a, int b) { return new T(a,b); } typedef std::map<std::string, Base* (*)(int,int)> map_type; map_type mymap; int main() { mymap["test1"] = &createInstance<test1>; mymap["test2"] = &createInstance<test2>; /*for (map_type::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout << it->first << " => " << it->second(10,20) << Base *b = mymap["test1"](10,20); Base *b2 = mymap["test2"](30,40); return 0; } ------------------------ Compile and Run it (Have done this with Eclipse) ------------------------ /Output Base constructor test1 constructor m_a=10m_b=20 Base constructor test1 constructor m_a=30m_b=40
int add(int, int); int add(int a, int b) { return a + b; }
Linux Ruby 100,000 100,000 core functionality (just kernel/*, ruby top level dir) 10,000,000 200,000 everything
int main() { std::mt19937 rng; std::seed_seq sequence{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; rng.seed(sequence); rng.discard(12 * 629143 + 6); float random = std::generate_canonical<float, std::numeric_limits<float>::digits>(rng); if (random == 1.0f) { std::cout << "Bug!\n"; } return 0; }
clang++ -stdlib=libc++ -std=c++11 test.c && ./a.out
commit baf369d7a57fb4d0d5897b02549c3517bb8800fd Date: Mon Sep 1 08:26:51 2014 +0000
linux-vdso.so.1 (0x00007fff39d0d000) libstdc++.so.6 => /home/cschwan/temp/prefix/lib64/libstdc++.so.6 (0x00007f123d785000) libm.so.6 => /lib64/libm.so.6 (0x000000317ea00000) libgcc_s.so.1 => /home/cschwan/temp/prefix/lib64/libgcc_s.so.1 (0x00007f123d54e000) libc.so.6 => /lib64/libc.so.6 (0x000000317e600000) /lib64/ld-linux-x86-64.so.2 (0x000000317e200000)
double rd = std::generate_canonical<double, std::numeric_limits<float>::digits>(rng); float rf = rd; if (rf > rd) { rf = std::nextafter(rf, -std::numeric_limits<float>::infinity()); }
template<class F> void test(long long N, const F& get_a_float) { int count = 0; for (long long i = 0; i < N; ++i) { float f = get_a_float(); if (f == 1.0f) { ++count; } } printf("Expected %d } int main() { std::mt19937 g(std::random_device{}()); auto N = (1uLL << 29); test(N, [&g]() { return std::uniform_real_distribution<float>(0,1)(g); }); test(N, [&g]() { return std::generate_canonical<float, 32>(g); }); }
vector<int> v; v.push_back(1); v.reserve(v.size() + 1); v.push_back(v[0]);
void push_back(const _Ty& _Val) { if (_Inside(_STD addressof(_Val))) { ... } else { ... } }
void __push_back_slow_path(_Up& __x) { allocator_type& __a = this->__alloc(); __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a); __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x)); __v.__end_++; __swap_out_circular_buffer(__v); }
void doSandwich() { T * p = new T() ; delete p ; } void doRAIIDynamic() { std::auto_ptr<T> p(new T()) ; } void doRAIIStatic() { T p ; }
int main() { Object* obj = new Object(); delete obj; }
int main() { boost::shared_ptr<Object> obj(new Object()); }
void foo() { boost::shared_ptr<Object> obj(new Object()); PostThreadMessage(...., (LPARAM)ob.get()); }
struct myparams { int x; std::vector<double> z; } std::auto_ptr<myparams> param(new myparams(x, ...)); if (0 == pthread_create(&th, NULL, th_func, param.get()) param.release(); ...
extern "C" void* th_func(void* p) { try { std::auto_ptr<myparams> param((myparams*)p); ... } catch(...) { } return 0; }
new a() if (Bad()) {delete a; return;} new b() if (Bad()) {delete a; delete b; return;} ...
explicit myClass(const char *func) { strcpy(str,func); }
char* x = (char*) malloc(strlen("foo bar")+1); strcpy(x,"foo bar");
class StringWrapper { std::vector<char> vec; public: StringWrapper(const std::string &str) : vec(str.begin(), str.end()) { } char *getChars() { return &vec[0]; } };
void Swap(const char * & left, const char * & right) { const char *const temp = left; left = right; right = temp; } int main() { const char * x = "Hello"; const char * y = "World"; std::cout << "x = " << x << ", y = " << y << Swap(x, y); std::cout << "x = " << x << ", y = " << y << }
class Foo { public: void doSomething() {} void bindFunction() { std::function<void(void)> f = &Foo::doSomething; } };
std::function<void(void)> f = std::bind(&Foo::doSomething, this);
using namespace std::placeholders; std::function<void(int,int)> f = std::bind(&Foo::doSomethingArgs, this, _1, _2);
std::function<void(int,int)> f = [=](int a, int b) { this->doSomethingArgs(a, b); }
std::function<void(void)> f = std::bind(&Foo::doSomething, this);
class MyClass { public: void MemberFunc(int value) { } }; auto callable = std::mem_fn(&MyClass::MemberFunc); MyClass myInst; callable(&myInst, 123);
std::_Mem_fn_wrap<void,void (__cdecl TestA::*)(int),TestA,int> callable
std::function<void(int)> binding = std::bind(callable, &testA, std::placeholders::_1); binding(123);
cmake_minimum_required(VERSION 2.8) file(GLOB helloworld_SRC "*.h" "*.cpp" ) add_executable(helloworld ${helloworld_SRC})
__declspec( naked ) int func( formal_parameters ) {}
auto foo = "You auto compiler_detector = [foo](auto foo) { std::puts(foo); }; compiler_detector("You
struct S1 { int x, y; int operator()(int); void f() { [=]()->int { return operator()(this->x+y); }; } };
struct Lambda { template<typename T> void operator()(T foo) const { } private: decltype(outer_foo) foo{outer_foo}; };
string s = new String(); s += "Hello world, " + myInt + niceToSeeYouString; s += someChar1 + interestingDecimal + someChar2;
string s; s += "Hello world, " + "nice to see you, " + "or not.";
std::stringstream ss; ss << "Hello, world, " << myInt << niceToSeeYouString; std::string s = ss.str();
s += "Hello world, " + "nice to see you, " + "or not.";
s += string("Hello world, ") + string("nice to see you, ") + string("or not.");
template <typename T> string Str( const T & t ) { ostringstream os; os << t; return os.str(); }
std::string s; s.append("Hello world, "); s.append("nice to see you, "); s.append("or not.");
std::stringstream ss; ss << "Hello world, " << 42 << "nice to see you."; std::string s = ss.str();
using namespace std::literals::string_literals; std::string str; str += "Hello World, "s + "nice to see you, "s + "or not"s; str += "Hello World, "s + std::to_string(my_int) + other_string;
str += "Hello World, " "nice to see you, " "or not";
std::string s = concat(someObject, " Hello, ", 42, " I concatenate", anyStreamableType);
void addToStream(std::ostringstream&) { } template<typename T, typename... Args> void addToStream(std::ostringstream& a_stream, T&& a_value, Args&&... a_args) { a_stream << std::forward<T>(a_value); addToStream(a_stream, std::forward<Args>(a_args)...); } template<typename... Args> std::string concat(Args&&... a_args) { std::ostringstream s; addToStream(s, std::forward<Args>(a_args)...); return s.str(); }
std::stringstream msg; msg << "Hello world, " << myInt << niceToSeeYouString; msg.str();
string s0 = "Hello world, " "nice to see you, " "or not."; string s1 = "Hello world, " "nice to see you, " "or not."; string s2 = "Hello world, " "nice to see you, " "or not.";
int a = 5; TRACE(a) a += 7; TRACE(a) TRACE(a+7) TRACE(17*11)
string s = string("Hello world, ")+"nice to see you, "+"or not.";
string s; s += "Hello world, " s += "nice to see you, " s += "or not.";
auto s = fmt::format("{}{}{}", "Hello world, ", myInt, niceToSeeYouString);
auto s = std::format("{}{}{}", "Hello world, ", myInt, niceToSeeYouString);
string join(const string& separator, const vector<string>& strings) { if (strings.empty()) return ""; if (strings.size() == 1) return strings[0]; stringstream ss; ss << strings[0]; auto aggregate = [&ss, &separator](const string& s) { ss << separator << s; }; for_each(begin(strings) + 1, end(strings), aggregate); return ss.str(); }
std::vector<std::string> strings { "a", "b", "c" }; std::string joinedStrings = join(", ", strings);
using namespace std; string join(const string& separator, const vector<string>& strings) { if (strings.empty()) return ""; if (strings.size() == 1) return strings[0]; stringstream ss; ss << strings[0]; auto aggregate = [&ss, &separator](const string& s) { ss << separator << s; }; for_each(begin(strings) + 1, end(strings), aggregate); return ss.str(); } int main() { const int reps = 1000; const string sep = ", "; auto generator = [](){return "abcde";}; vector<string> strings10(10); generate(begin(strings10), end(strings10), generator); vector<string> strings100(100); generate(begin(strings100), end(strings100), generator); vector<string> strings1000(1000); generate(begin(strings1000), end(strings1000), generator); vector<string> strings10000(10000); generate(begin(strings10000), end(strings10000), generator); auto t1 = chrono::system_clock::now(); for(int i = 0; i<reps; ++i) { join(sep, strings10); } auto t2 = chrono::system_clock::now(); for(int i = 0; i<reps; ++i) { join(sep, strings100); } auto t3 = chrono::system_clock::now(); for(int i = 0; i<reps; ++i) { join(sep, strings1000); } auto t4 = chrono::system_clock::now(); for(int i = 0; i<reps; ++i) { join(sep, strings10000); } auto t5 = chrono::system_clock::now(); auto d1 = chrono::duration_cast<chrono::milliseconds>(t2 - t1); auto d2 = chrono::duration_cast<chrono::milliseconds>(t3 - t2); auto d3 = chrono::duration_cast<chrono::milliseconds>(t4 - t3); auto d4 = chrono::duration_cast<chrono::milliseconds>(t5 - t4); cout << "join(10) : " << d1.count() << endl; cout << "join(100) : " << d2.count() << endl; cout << "join(1000) : " << d3.count() << endl; cout << "join(10000): " << d4.count() << endl; }
join(10) : 2 join(100) : 10 join(1000) : 91 join(10000): 898
using namespace std; class Streamer { public: Streamer& clear() { ss.str(""); ss.clear(); return *this; } template <typename T> friend Streamer& operator<<(Streamer& streamer,T str); string str() { return ss.str();} private: stringstream ss; }; template <typename T> Streamer& operator<<(Streamer& streamer,T str) { streamer.ss<<str;return streamer;} Streamer streamer; class MyTestClass { public: MyTestClass() : data(0.12345){} friend ostream& operator<<(ostream& os,const MyTestClass& myClass); private: double data; }; ostream& operator<<(ostream& os,const MyTestClass& myClass) { return os<<myClass.data;} int main() { int i=0; string s1=(streamer.clear()<<"foo"<<"bar"<<"test").str(); string s2=(streamer.clear()<<"i:"<<i++<<" "<<i++<<" "<<i++<<" "<<0.666).str(); string s3=(streamer.clear()<<"test class:"<<MyTestClass()).str(); cout<<"s1: cout<<"s2: cout<<"s3: }
auto s = string("one").append("two").append("three")
string s("Some initial data. "); int i = 5; s = s + "Hello world, " + "nice to see you, " + to_string(i) + "\n";
using namespace concat; assert(concat(1,2,3,4,5) == "12345");
using namespace std; int main() { int i = 0; float f = 0.4; double d = 1.3e-2; string s; s += "Hello world, "_ + "nice to see you. "_ + i + " "_ + 47 + " "_ + f + cout << s << endl; return 0; }
inline std::string operator "" _(const char a[], long unsigned int i) { return std::string(a); } template<typename T> inline typename std::enable_if<!std::is_same<std::string, T>::value && !std::is_same<char, T>::value && !std::is_same<const char*, T>::value, std::string>::type operator+ (std::string s, T i) { return s + std::to_string(i); } template<typename T> inline typename std::enable_if<!std::is_same<std::string, T>::value && !std::is_same<char, T>::value && !std::is_same<const char*, T>::value, std::string>::type operator+ (T i, std::string s) { return std::to_string(i) + s; }
namespace perso { class string:public std::string { public: string(): std::string(){} template<typename T> string(const T v): std::string(v) {} template<typename T> string& operator<<(const T s){ *this+=s; return *this; } }; } using namespace std; int main() { using string = perso::string; string s1, s2="she"; s1 << "no " << "sunshine when " << s2 << cout << "Aint return 0; }
namespace detail { void concat_impl(std::ostream&) { } template<typename T, typename ...Args> void concat_impl(std::ostream& os, const T& t, Args&&... args) { os << t; concat_impl(os, std::forward<Args>(args)...); } } template<typename ...Args> std::string concat(Args&&... args) { std::ostringstream os; detail::concat_impl(os, std::forward<Args>(args)...); return os.str(); } std::string s{"Hello World, "}; s = concat(s, myInt, niceToSeeYouString, myChar, myFoo);
var_string x("abc %d %s", 123, "def"); std::string y = (std::string)x; const char *z = x.c_str();
class var_string { public: var_string(const char *cmd, ...) { va_list args; va_start(args, cmd); vsnprintf(buffer, sizeof(buffer) - 1, cmd, args); } ~var_string() {} operator std::string() { return std::string(buffer); } operator char*() { return buffer; } const char *c_str() { return buffer; } int system() { return ::system(buffer); } private: char buffer[4096]; };
void printMessage(std::string&& message) { std::cout << message << std::endl; return message; }
printMessage("message number : " + std::to_string(id));
int main() { std::string s = std::string("Hi") + " there" + " friends"; std::cout << s << std::endl; std::string r = std::string("Magic number: ") + std::to_string(13) + "!"; std::cout << r << std::endl; return 0; }
using namespace std; int main() { const char* filename = "myfile"; string path = CONCAT4(HOMEDIR,"\\",filename,".txt"); cout << path; return 0; }
string myName; int _age = 30; AnsiString aux = AnsiString("Giancarlo") + " Andre " + _age + " " + 2019; myName = aux.c_str();
int 17 = 497; int 42 = 6 * 9; String 1111 = "Totally text";
class Thingy; Thingy* foo( ) { int a; Thingy B; Thingy *pointerToB = &B; Thingy *pointerToC = new Thingy(); return pointerToC; return pointerToB; }
void GetSomeNumbers(std::vector<int> &result) { std::vector<int> v(10); result.swap(v); }
template <class T> int numDigits(T number) { int digits = 0; if (number < 0) digits = 1; while (number) { number /= 10; digits++; } return digits; } template<> int numDigits(int32_t x) { if (x == MIN_INT) return 10 + 1; if (x < 0) return numDigits(-x) + 1; if (x >= 10000) { if (x >= 10000000) { if (x >= 100000000) { if (x >= 1000000000) return 10; return 9; } return 8; } if (x >= 100000) { if (x >= 1000000) return 7; return 6; } return 5; } if (x >= 100) { if (x >= 1000) return 4; return 3; } if (x >= 10) return 2; return 1; } template <> int numDigits(char n) { static char x[256] = {0}; if (x[0] == 0) { for (char c = 1; c != 0; c++) x[c] = numDigits((int32_t)c); x[0] = 1; } return x[n]; }
unsigned GetNumberOfDigits (unsigned i) { return i > 0 ? (int) log10 ((double) i) + 1 : 1; }
int NumDigits(int x) { x = abs(x); return (x < 10 ? 1 : (x < 100 ? 2 : (x < 1000 ? 3 : (x < 10000 ? 4 : (x < 100000 ? 5 : (x < 1000000 ? 6 : (x < 10000000 ? 7 : (x < 100000000 ? 8 : (x < 1000000000 ? 9 : 10))))))))); }
int digits = 0; while (number != 0) { number /= 10; digits++; }
int digits = 0; do { number /= 10; digits++; } while (number != 0);
template <unsigned long long N, size_t base=10> struct numberlength { enum { value = 1 + numberlength<N/base, base>::value }; }; template <size_t base> struct numberlength<0, base> { enum { value = 0 }; };
unsigned int i; cout<< to_string(i).length()<<endl;
int digits = 1, pten=10; while ( pten <= number ) { digits++; pten*=10; }
using namespace std; int main() { double num; int result; cout<<"Enter a number to find the number of digits, not including decimal places: "; cin>>num; result = ((num<=1)? 1 : log10(num)+1); cout<<"Number of digits "<<result<<endl; return 0; }
/** \code ---+--- ---+--- 10 | 4 5 | 4 9 | 4 4 | 4 8 | 3 3 | 3 7 | 3 2 | 3 6 | 3 1 | 3 \endcode */ unsigned NumDigits32bs(uint32_t x) { return ( x >= 100000u ? ( x >= 10000000u ? ( x >= 100000000u ? ( x >= 1000000000u ? 10 : 9 ) : 8 ) : ( x >= 1000000u ? 7 : 6 ) ) : ( x >= 100u ? ( x >= 1000u ? ( x >= 10000u ? 5 : 4 ) : 3 ) : ( x >= 10u ? 2 : 1 ) ) ); }
template<typename T> T max_decimal() { T t = 1; for (unsigned i = boost::integer_traits<T>::digits10; i; --i) t *= 10; return t; } template<typename T> unsigned digits(T v) { if (v < 0) v = -v; if (max_decimal<T>() <= v) return boost::integer_traits<T>::digits10 + 1; unsigned digits = 1; T boundary = 10; while (boundary <= v) { boundary *= 10; ++digits; } return digits; }
/** \code ---+--- ---+--- ---+--- ---+--- 20 | 5 15 | 5 10 | 5 5 | 5 19 | 5 14 | 5 9 | 5 4 | 5 18 | 4 13 | 4 8 | 4 3 | 4 17 | 4 12 | 4 7 | 4 2 | 4 16 | 4 11 | 4 6 | 4 1 | 4 \endcode */ unsigned NumDigits64bs(uint64_t x) { return ( x >= 10000000000ul ? ( x >= 1000000000000000ul ? ( x >= 100000000000000000ul ? ( x >= 1000000000000000000ul ? ( x >= 10000000000000000000ul ? 20 : 19 ) : 18 ) : ( x >= 10000000000000000ul ? 17 : 16 ) ) : ( x >= 1000000000000ul ? ( x >= 10000000000000ul ? ( x >= 100000000000000ul ? 15 : 14 ) : 13 ) : ( x >= 100000000000ul ? 12 : 11 ) ) ) : ( x >= 100000ul ? ( x >= 10000000ul ? ( x >= 100000000ul ? ( x >= 1000000000ul ? 10 : 9 ) : 8 ) : ( x >= 1000000ul ? 7 : 6 ) ) : ( x >= 100ul ? ( x >= 1000ul ? ( x >= 10000ul ? 5 : 4 ) : 3 ) : ( x >= 10ul ? 2 : 1 ) ) ) ); }
int x = 1000; int numberOfDigits = static_cast<int>(log10(x)) + 1;
template <typename type> class number_of_decimal_digits { const powers_and_max<type> mPowersAndMax; public: number_of_decimal_digits(){ } inline size_t ndigits( type i) const { if(i<0){ i += (i == std::numeric_limits<type>::min()); i=-i; } const type* begin = &*mPowersAndMax.begin(); const type* end = begin+mPowersAndMax.size(); return 1 + std::lower_bound(begin,end,i) - begin; } inline size_t string_ndigits(const type& i) const { return (i<0) + ndigits(i); } inline size_t operator[](const type& i) const { return string_ndigits(i); } };
template <typename type> struct powers_and_max : protected std::vector<type>{ typedef std::vector<type> super; using super::const_iterator; using super::size; type& operator[](size_t i)const{return super::operator[](i)}; const_iterator begin()const {return super::begin();} const_iterator end()const {return super::end();} powers_and_max() { const int size = (int)(log10(double(std::numeric_limits<type>::max()))); int j = 0; type i = 10; for( ; j<size ;++j){ push_back(i-1); i*=10; } ASSERT(back()<std::numeric_limits<type>::max()); push_back(std::numeric_limits<type>::max()); } };
number_of_decimal_digits<int> ndd; ASSERT(ndd[0]==1); ASSERT(ndd[9]==1); ASSERT(ndd[10]==2); ASSERT(ndd[-10]==3); ASSERT(ndd[-1]==2); ASSERT(ndd[-9]==2); ASSERT(ndd[1000000000]==10); ASSERT(ndd[0x7fffffff]==10); ASSERT(ndd[-1000000000]==11); ASSERT(ndd[0x80000000]==11);
int num; int count = 0; while(num) { num /= 10; ++count; }
int main() { int num; std::cin >> num; std::cout << "number of digits for " << num << ": "; int count = 0; while(num) { num /= 10; ++count; } std::cout << count << return 0; }
template <class T> size_t NumberOfDecPositions ( T v, typename std::enable_if<std::is_unsigned<T>::value>::type* = 0 ) { typedef std::array<T,std::numeric_limits<T>::digits10+1> array_type; static array_type powers_of_10; if ( powers_of_10.front() == 0 ) { T n = 1; for ( T& i: powers_of_10 ) { i = n; n *= 10; } } size_t l = 0, r = powers_of_10.size(), p; while ( l+1 < r ) { p = (l+r)/2; if ( powers_of_10[p] <= v ) l = p; else r = p; } return l + 1; }; template <class T> size_t NumberOfDecPositions ( T v, typename std::enable_if<std::is_signed<T>::value>::type* = 0 ) { typedef typename std::make_unsigned<T>::type unsigned_type; if ( v < 0 ) return NumberOfDecPositions ( static_cast<unsigned_type>(-v) ) + 1; else return NumberOfDecPositions ( static_cast<unsigned_type>(v) ); }
int64_t = number, digitValue, digits = 0; while (number != 0) { digitValue = number % 10; digits ++; number /= 10; }
template <typename T> typename std::enable_if<std::numeric_limits<T>::is_integer, unsigned int>::type numberDigits(T value) { unsigned int digits = 0; if (value < 0) digits = 1; while (value) { value /= 10; ++digits; } return digits; }
int numberOfDigits(double number){ if(number < 0){ number*=-1; } int i=0; while(number > pow(10, i)) i++; cout << "This number has " << i << " digits" << endl; return i; }
template <unsigned long long N, unsigned base=10> struct numberlength { enum { value = ( 1<=N && N<base ? 1 : 1+numberlength<N/base, base>::value ) }; }; template <unsigned base> struct numberlength<0, base> { enum { value = 1 }; }; { assert( (1 == numberlength<0,10>::value) ); } assert( (1 == numberlength<1,10>::value) ); assert( (1 == numberlength<5,10>::value) ); assert( (1 == numberlength<9,10>::value) ); assert( (4 == numberlength<1000,10>::value) ); assert( (4 == numberlength<5000,10>::value) ); assert( (4 == numberlength<9999,10>::value) );
int numberOfDigits(int n){ if(n<=9){ return 1; } return 1 + numberOfDigits(n/10); }
int x = 1000 ; cout<<numberOfDigits = 1+floor(log10(x))<<endl ;
int digitcount(int n) { int count = 1; int temp = n; while (true) { temp /= 10; if (temp != 0) ++count; if (temp == 0) break; } return count; }
digits = sprintf(numArr, "%d", num); if (num < 0) digits--;
movl $42, -24(%ebp) movl -16(%ebp), %eax movl %eax, 4(%esp) movl $.LC0, (%esp) call printf #
class A { public: int i; }; std::ostream& operator<<(std::ostream &strm, const A &a) { return strm << "A(" << a.i << ")"; }
class A { private: friend std::ostream& operator<<(std::ostream&, const A&); int j; }; std::ostream& operator<<(std::ostream &strm, const A &a) { return strm << "A(" << a.j << ")"; }
class Base { public: virtual std::ostream& dump(std::ostream& o) const { return o << "Base: " << b << "; "; } private: int b; }; class Derived : public Base { public: virtual std::ostream& dump(std::ostream& o) const { return o << "Derived: " << d << "; "; } private: int d; } std::ostream& operator<<(std::ostream& o, const Base& b) { return b.dump(o); }
A a; std::stringstream sstream; sstream << a; std::string s = sstream.str();
class Point{ public: Point(int theX, int theY) :x(theX), y(theY) {} friend ostream& operator <<(ostream& outputStream, const Point& p); private: int x; int y; }; ostream& operator <<(ostream& outputStream, const Point& p){ int posX = p.x; int posY = p.y; outputStream << "x="<<posX<<","<<"y="<<posY; return outputStream; }
template< class T > class Y { public: template < typename = typename std::enable_if< true >::type > T foo() { return 10; } template < typename = typename std::enable_if< false >::type > T foo() { return 10; } }; int main() { Y< double > y; std::cout << y.foo() << std::endl; }
% LANG=C make CXXFLAGS="-std=c++0x" enable_if g++ -std=c++0x enable_if.cpp -o enable_if enable_if.cpp:12:65: error: `type enable_if.cpp:13:15: error: `template<class T> template<class> T Y::foo() enable_if.cpp:9:15: error: with `template<class T> template<class> T Y::foo()'
class Y<int> { public: /* instantiated from template < typename = typename std::enable_if< std::is_same< T, int >::value >::type > T foo() { return 10; } */ template < typename = typename std::enable_if< true >::type > int foo(); /* instantiated from template < typename = typename std::enable_if< ! std::is_same< T, int >::value >::type > T foo() { return 10; } */ template < typename = typename std::enable_if< false >::type > int foo(); };
class foo; class bar; template<class T> struct check { template<class Q = T> typename std::enable_if<std::is_same<Q, bar>::value, bool>::type test() { return true; } template<class Q = T> typename std::enable_if<!std::is_same<Q, bar>::value, bool>::type test() { return false; } }; int main() { check<foo> check_foo; check<bar> check_bar; if (!check_foo.test() && check_bar.test()) std::cout << "It works!" << std::endl; return 0; }
template< typename T > class Y { template< bool cond, typename U > using resolvedType = typename std::enable_if< cond, U >::type; public: template< typename U = T > resolvedType< true, U > foo() { return 11; } template< typename U = T > resolvedType< false, U > foo() { return 12; } }; int main() { Y< double > y; std::cout << y.foo() << std::endl; }
struct Foo { template < class T, class std::enable_if < !std::is_integral<T>::value, int >::type = 0 > void f(const T& value) { std::cout << "Not int" << std::endl; } template<class T, class std::enable_if<std::is_integral<T>::value, int>::type = 0> void f(const T& value) { std::cout << "Int" << std::endl; } }; int main() { Foo foo; foo.f(1); foo.f(1.1); }
template< class T, bool condition> struct FooImpl; template<class T> struct FooImpl<T, true> { T foo() { return 10; } }; template<class T> struct FoolImpl<T,false> { T foo() { return 5; } }; template< class T > class Y : public FooImpl<T, boost::is_integer<T> > { public: typedef FooImpl<T, boost::is_integer<T> > inherited; };
template<class T, bool condition> class Goo; template<class T, bool condition> class Foo<T, true> : public Goo<T, boost::test<T> > { public: typedef Goo<T, boost::test<T> > inherited: };
template< class T > class Y { public: template < bool EnableBool = true, typename = typename std::enable_if<( std::is_same<T, double>::value && EnableBool )>::type > T foo() { return 10; } };
template< class T > class Y { public: TICK_MEMBER_REQUIRES(std::is_same<T, double>::value) T foo() { return 10; } TICK_MEMBER_REQUIRES(!std::is_same<T, double>::value) T foo() { return 10; } };
template<long N> struct requires_enum { enum class type { none, all }; }; typename requires_enum<__LINE__>::type PrivateRequiresEnum class=typename std::enable_if<((PrivateRequiresEnum
std::set <double> input; input.insert(5); input.insert(6); std::vector <double> output; std::copy(input.begin(), input.end(), output.begin());
std::copy(input.begin(), input.end(), std::back_inserter(output));
std::vector<double> output(input.size()); std::copy(input.begin(), input.end(), output.begin());
std::vector<double> output(input.begin(), input.end());
std::set<T> s; std::vector v( s.begin(), s.end() );
std::vector<double> output(input.size()); std::copy(input.begin(), input.end(), output.begin());
std::set<double> input; input.insert(5); input.insert(6); std::vector<double> output; std::copy(input.begin(), input.end(), inserter(output, output.begin()));
struct cintref { cintref(const int & ref) : ref(ref) {} operator const int &() { return ref; } private: const int & ref; void operator=(const cintref &); }; int main() { int a=1,b=2,c=3; cintref arr[] = {a,b,c,8}; }
struct mys { int & a; int & b; int & c; }; ... int ivar1, ivar2, arr[200]; mys my_refs = { ivar1, ivar2, arr[12] }; my_refs.a += 3 ;
struct mys { ... int & operator[]( int i ) { return i==0?a : i==1? b : c; } };
int ivar1, ivar2, arr[200]; mys my_refs = { ivar1, ivar2, arr[12] }; my_refs[1] = my_refs[2] ; &my_refs[0];
int & operator[]( int i ) { return *(reinterpret_cast<int**>(this)[i]); }
using namespace std; int main() { int a=1,b=2,c=3,d=4; using intlink = std::reference_wrapper<int>; intlink arr[] = {a,b,c,d}; return 0; }
template<class T, int N> struct fake_ref_array { T * ptrs[N]; T & operator [] ( int i ){ return *ptrs[i]; } }; int A,B,X[3]; void func( int j, int k) { fake_ref_array<int,3> refarr = { &A, &B, &X[1] }; refarr[j] = k; } int main() { func(1,7); func(2,8); printf("A=%d B=%d X = {%d,%d,%d}\n", A,B,X[0],X[1],X[2]); return 0; }
struct Object { Object(int value) { } }; Object objects[1];
g++ -c myclass.cpp g++ -c main.cpp g++ myclass.o main.o ./a.out
all: executable1 CC=$(CXX) executable1: file1.o file2.o
AMEFObject *object = new AMEFObject(); object->addPacket("This is the Automated Message Exchange Format Object property!!","adasd"); object->addPacket(21213); object->addPacket(true); AMEFObject *object2 = new AMEFObject(); string j = "This is the property of a nested Automated Message Exchange Format Object"; object2->addPacket(j); object2->addPacket(134123); object2->addPacket(false); object2->addPacket( object->addPacket(object2); string str = new AMEFEncoder()->encode(object,false);
string arr = amef encoded byte array value; AMEFDecoder decoder = new AMEFDecoder() AMEFObject object1 = AMEFDecoder.decode(arr,true);
std::vector<int> data({22, 333, -4444}); std::string serialized = hps::serialize_to_string(data); auto parsed = hps::parse_from_string<std::vector<int>>(serialized);
class myClass { public: void sayHello () { cout << "Hello"; } }; int main () { myClass* myPointer; myClass myObject = myClass(* myPointer); myObject.sayHello(); return 0; }
int main(int argc, char* argv[]) { int a = 5; auto it = [&](auto self) { return [&](auto b) { std::cout << (a + b) << std::endl; return self(self); }; }; it(it)(4)(6)(42)(77)(999); }
auto it = [&](auto& self, auto b) { std::cout << (a + b) << std::endl; return [&](auto p) { return self(self,p); }; }; it(it,4)(6)(42)(77)(999);
auto f1 = [&](auto& self) { return [&](auto) { return self(self); } ; }; f1(f1)(0); auto f2 = [&](auto& self, auto) { return [&](auto p) { return self(self,p); }; }; f2(f2, 0);
template<class Fun> class y_combinator_result { Fun fun_; public: template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {} template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); } }; template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }
auto it = y_combinator([&](auto self, auto b){ std::cout << (a + b) << std::endl; return self; });
int main(int argc, char* argv[]) { int a = 5; auto it = [&](auto self) { return [&](auto b) { std::cout << (a + b) << std::endl; return self(self); }; }; it(it)(4)(6)(42)(77)(999); }
==5485== Memcheck, a memory error detector ==5485== Copyright (C) 2002-2017, and GNU GPL ==5485== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==5485== Command: ./test ==5485== 9 ==5485== Use of uninitialised value of size 8 ==5485== at 0x108A20: _ZZZ4mainENKUlT_E_clIS0_EEDaS_ENKUlS_E_clIiEEDaS_ (test.cpp:8) ==5485== by 0x108AD8: main (test.cpp:12) ==5485== ==5485== Invalid read of size 4 ==5485== at 0x108A20: _ZZZ4mainENKUlT_E_clIS0_EEDaS_ENKUlS_E_clIiEEDaS_ (test.cpp:8) ==5485== by 0x108AD8: main (test.cpp:12) ==5485== Address 0x4fefffdc4 is not stack ==5485== ==5485== ==5485== Process terminating with default action of signal 11 (SIGSEGV) ==5485== Access not within mapped region at address 0x4FEFFFDC4 ==5485== at 0x108A20: _ZZZ4mainENKUlT_E_clIS0_EEDaS_ENKUlS_E_clIiEEDaS_ (test.cpp:8) ==5485== by 0x108AD8: main (test.cpp:12) ==5485== If you believe this happened as a result of a stack ==5485== overflow in your program ==5485== possible), you can try to increase the size of the ==5485== main thread stack using the --main-stacksize= flag. ==5485== The main thread stack size used in this run was 8388608.
int main(int argc, char* argv[]) { int a = 5; auto it = [&](auto& self) { return [&](auto b) { std::cout << (a + b) << std::endl; return self(self); }; }; it(it)(4)(6)(42)(77)(999); }
==5492== Memcheck, a memory error detector ==5492== Copyright (C) 2002-2017, and GNU GPL ==5492== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info ==5492== Command: ./test ==5492== 9 11 47 82 1004
auto n = n; auto f(); void g() { &f; } auto sum(int i) { if (i == 1) return i; else return sum(i-1)+i; }
template<class Fun> class y_combinator_result { Fun fun_; public: template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {} template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); } }; template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }
auto x = []fib(int a) { return a > 1 ? fib(a - 1) + fib(a - 2) : a; };
void read(Socket sock, OutputBuffer buff) { sock.readsome([&] (Data data) { buff.append(data); sock.readsome( ); }).get();
auto on_read = [&] (Data data) { buff.append(data); sock.readsome(on_read); };
std::function on_read = [&] (Data data) { buff.append(data); sock.readsome(on_read); };
auto it = [](auto& self) { return [&self]() { return self(self); }; }; it(it);
template<class F> struct ycombinator { F f; template<class...Args> auto operator()(Args&&...args){ return f(f, std::forward<Args>(args)...); } }; template<class F> ycombinator(F) -> ycombinator<F>;
ycombinator bob = {[x=0](auto&& self)mutable{ std::cout << ++x << "\n"; ycombinator ret = {self}; return ret; }}; bob()()();
auto it = [&](auto self) { return [&](auto b) { std::cout << (a + b) << std::endl; return self(self); }; }; it(it)(4)(5)(6);
[&](auto self) { return [self,&a](auto b) { std::cout << (a + b) << std::endl; return self(self); }; };
struct __outer_lambda__ { template<class T> auto operator()(T self) const { struct __inner_lambda__ { template<class B> auto operator()(B b) const { std::cout << (a + b) << std::endl; return self(self); } int& a; T self; }; return __inner_lambda__{a, self}; } int& a; }; __outer_lambda__ it{a}; it(it);
template<> auto __outer_lambda__::operator()(__outer_lambda__ self) const { struct __inner_lambda__ { template<class B> auto operator()(B b) const { std::cout << (a + b) << std::endl; return self(self); } int& a; __outer_lambda__ self; }; return __inner_lambda__{a, self}; } int& a; };
struct __inner_lambda__ { template<class B> auto operator()(B b) const { std::cout << (a + b) << std::endl; return self(self); } int& a; __outer_lambda__ self; };
template<class A, class B> struct second_type_helper { using result=B; }; template<class A, class B> using second_type = typename second_type_helper<A,B>::result; int main(int argc, char* argv[]) { int a = 5; auto it = [&](auto self) { return [self,&a](auto b) { std::cout << (a + b) << std::endl; return self(second_type<decltype(b), decltype(self)&>(self) ); }; }; it(it)(4)(6)(42)(77)(999); }
struct Outer { int& a; template< class Arg > auto operator()( Arg& self ) const { return Inner( a, self ); } struct Inner { int& a; Outer& self; template< class Arg > auto operator()( Arg b ) const { std::cout << (a + b) << std::endl; return self( self ); } Inner( int& an_a, Outer& a_self ): a( an_a ), self( a_self ) {} }; Outer( int& ref ): a( ref ) {} }; int main() { int a = 5; auto&& it = Outer( a ); it(it)(4)(6)(42)(77)(999); }
struct Outer { int& a; template< class > class Inner; template< class Arg > auto operator()( Arg& self ) const { return Inner<Arg>( a, self ); } template< class Self > struct Inner { int& a; Self& self; template< class Arg > auto operator()( Arg b ) const { std::cout << (a + b) << std::endl; return self( self ); } Inner( int& an_a, Self& a_self ): a( an_a ), self( a_self ) {} }; Outer( int& ref ): a( ref ) {} }; int main() { int a = 5; auto&& it = Outer( a ); it(it)(4)(6)(42)(77)(999); }
class test { public: test() { std::cout << "Test created" << std::endl; } ~test() { std::cout << "Test destroyed" << std::endl; } }; int main() { std::cout << "At begin of main.\ncreating std::vector<std::shared_ptr<void>>" << std::endl; std::vector<std::shared_ptr<void>> v; { std::cout << "Creating test" << std::endl; v.push_back( std::shared_ptr<test>( new test() ) ); std::cout << "Leaving scope" << std::endl; } std::cout << "Leaving main" << std::endl; return 0; }
At begin of main. creating std::vector<std::shared_ptr<void>> Creating test Test created Leaving scope Leaving main Test destroyed
template <typename T> void delete_deleter( void * p ) { delete static_cast<T*>(p); } template <typename T> class my_unique_ptr { std::function< void (void*) > deleter; T * p; template <typename U> my_unique_ptr( U * p, std::function< void(void*) > deleter = &delete_deleter<U> ) : p(p), deleter(deleter) {} ~my_unique_ptr() { deleter( p ); } }; int main() { my_unique_ptr<void> p( new double ); }
shared_ptr -> hidden_refcounted_object -> real_object
class sp_counted_base { public: sp_counted_base() : refCount( 1 ) { } virtual ~sp_deleter_base() {}; virtual void destruct() = 0; void incref(); void decref(); private: long refCount; }; template< typename T > class sp_counted_impl : public sp_counted_base { public: typedef function< void( T* ) > func_type; void destruct() { func(ptr); delete this; } template< typename F > sp_counted_impl( T* t, F f ) : ptr( t ), func( f ) private: T* ptr; func_type func; }; template< typename T > struct checked_deleter { public: template< typename T > operator()( T* t ) { size_t z = sizeof( T ); delete t; } }; class shared_ptr_base { private: sp_counted_base * counter; protected: shared_ptr_base() : counter( 0 ) {} explicit shared_ptr_base( sp_counter_base * c ) : counter( c ) {} ~shared_ptr_base() { if( counter ) counter->decref(); } shared_ptr_base( shared_ptr_base const& other ) : counter( other.counter ) { if( counter ) counter->addref(); } shared_ptr_base& operator=( shared_ptr_base& const other ) { shared_ptr_base temp( other ); std::swap( counter, temp.counter ); } };
template< typename T, typename F > sp_counted_impl<T> * make_sp_counted_impl( T* ptr, F func ) { try { return new sp_counted_impl( ptr, func ); } catch( ... ) { func( ptr ); throw; } } template< typename T > sp_counted_impl<T> * make_sp_counted_impl( T* ptr ) { return make_sp_counted_impl( ptr, checked_deleter<T>() ); }
template< typename T > class shared_ptr : public shared_ptr_base { public: template < typename U > explicit shared_ptr( U * ptr ) : shared_ptr_base( make_sp_counted_impl( ptr ) ) { } };
template<typename T, typename U> auto add(T t, U u) { return t + u; }
auto foo() { std::vector<std::map<std::pair<int, double>, int>> ret; return ret; }
auto position() { return pos_; } auto area() { return length_ * width_; }
template<typename F, typename Tuple, int... I> auto apply_(F&& f, Tuple&& args, int_seq<I...>) -> decltype(std::forward<F>(f)(std::get<I>(std::forward<Tuple>(args))...)) { return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(args))...); } template<typename F, typename Tuple, typename Indices = make_int_seq<std::tuple_size<Tuple>::value>> auto apply(F&& f, Tuple&& args) -> decltype(apply_(std::forward<F>(f), std::forward<Tuple>(args), Indices())) { return apply_(std::forward<F>(f), std::forward<Tuple>(args), Indices()); }
template <typename F, typename Tuple, size_t... I> decltype(auto) apply_impl(F&& f, Tuple&& t, index_sequence<I...>) { return forward<F>(f)(get<I>(forward<Tuple>(t))...); } template <typename F, typename Tuple> decltype(auto) apply(F&& f, Tuple&& t) { using Indices = make_index_sequence<tuple_size<decay_t<Tuple>>::value>; return apply_impl(forward<F>(f), forward<Tuple>(t), Indices{}); }
struct X { void foo() const { std::cout << "foo\n"; } }; struct Y { void bar() const { std::cout << "bar\n"; } }; template<typename C> auto foobar(const C& c) -> decltype(c.foo()) { return c.foo(); } template<typename C> auto foobar(const C& c) -> decltype(c.bar()) { return c.bar(); }
inline auto CreateEntity() { return GetContext()->GetEntityManager()->CreateEntity(); }
std::vector<std::map<std::pair<int, double>, int>> foo() { decltype(foo()) ret; return ret; }
class MyClass { public: MyClass(unsigned short port); virtual ~MyClass(void); };
c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(91) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(460) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(124) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(479) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(163) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(402) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(206) : error C2011: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(485) : see declaration of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(384) : error C2143: syntax error : missing c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(384) : error C2143: syntax error : missing c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(384) : error C2059: syntax error : c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(437) : error C2143: syntax error : missing c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(437) : error C4430: missing type specifier - int assumed. Note: C++ does not support default-int c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(437) : error C4430: missing type specifier - int assumed. Note: C++ does not support default-int c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(518) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(287) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(524) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(293) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(530) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(299) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(541) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(304) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(543) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(306) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\ws2def.h(577) : error C2011: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(312) : see declaration of c:\program files\microsoft sdks\windows\v6.0a\include\winsock2.h(132) : error C2011: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(68) : see declaration of c:\program files\microsoft sdks\windows\v6.0a\include\winsock2.h(167) : warning C4005: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(102) : see previous definition of c:\program files\microsoft sdks\windows\v6.0a\include\winsock2.h(176) : error C2011: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(111) : see declaration of c:\program files\microsoft sdks\windows\v6.0a\include\winsock2.h(232) : error C2011: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(167) : see declaration of c:\program files\microsoft sdks\windows\v6.0a\include\winsock2.h(245) : error C2011: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(180) : see declaration of c:\program files\microsoft sdks\windows\v6.0a\include\winsock2.h(252) : error C2011: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(187) : see declaration of c:\program files\microsoft sdks\windows\v6.0a\include\winsock2.h(264) : error C2011: c:\program files\microsoft sdks\windows\v6.0a\include\winsock.h(199) : see declaration of
class MyClass { public: MyClass(unsigned short port); virtual ~MyClass(void); };
/*++ Copyright (c) Microsoft Corporation. All rights reserved. Module Name: ws2def.h Abstract: This file contains the core definitions for the Winsock2 specification that can be used by both user-mode and kernel mode modules. This file is included in WINSOCK2.H. User mode applications should include WINSOCK2.H rather than including this file directly. This file can not be included by a module that also includes WINSOCK.H. Environment: user mode or kernel mode --*/
class Engine { public: void SetState( int var, bool val ); { SetStateBool( int var, bool val ); } void SetState( int var, int val ); { SetStateInt( int var, int val ); } private: virtual void SetStateBool(int var, bool val ) = 0; virtual void SetStateInt(int var, int val ) = 0; };
class Engine { public: virtual void SetState( int var, bool val ) { } virtual void SetState( int var, int val ) { } };
class MyTurbochargedV8 : public Engine { public: using Engine::SetState; void SetState( int var, int val ) { } };
MyTurbochargedV8* myV8 = new MyTurbochargedV8(); myV8->SetState(5, true);
class MyTurbochargedV8 : public Engine { private: void SetStateInt(int var, int val ) { } };
class Base { public: void f(); private: virtual void DerivedClassSpecific() = 0; }; void Base::f() { DerivedClassSpecific(); } class Derived: public Base { private: virtual void DerivedClassSpecific(); }; void Derived::DerivedClassSpecific() { }
class Engine { public: void SetState( int var, bool val ) { SetStateBool( var, val ); } void SetState( int var, int val ) { SetStateInt( var, val ); } private: virtual void SetStateBool(int var, bool val ) = 0; virtual void SetStateInt(int var, int val ) = 0; }; class DerivedEngine : public Engine { private: virtual void SetStateBool(int var, bool val ) { std::cout << "DerivedEngine::SetStateBool() called" << std::endl; } virtual void SetStateInt(int var, int val ) { std::cout << "DerivedEngine::SetStateInt() called" << std::endl; } }; int main() { DerivedEngine e; Engine * be = &e; be->SetState(4, true); be->SetState(2, 1000); }
using namespace std; class MyClass { string figName; public: MyClass(const string& s) { figName = s; } const string& getName() const { return figName; } }; ostream& operator<<(ostream& ausgabe, const MyClass& f) { ausgabe << f.getName(); return ausgabe; } int main() { MyClass f1("Hello"); cout << f1; return 0; }
typedef basic_string<char, char_traits<char>, allocator<char> > string;
start: operator<<(MyClass) -> MyClass::MyClass(MyClass::getName()) -> operator<<(MyClass) -> ... goto start;
class MyClass { string figName; public: explicit MyClass(const string& s) { figName = s; } const string& getName() const { return figName; } };
static Singleton& instance() { static Singleton s; return s; }
static Singleton& instance() { static bool initialized = false; static char s[sizeof( Singleton)]; if (!initialized) { initialized = true; new( &s) Singleton(); } return (*(reinterpret_cast<Singleton*>( &s))); }
class CritSection : public CRITICAL_SECTION { public: CritSection() { InitializeCriticalSection( this); } ~CritSection() { DeleteCriticalSection( this); } private: CritSection( CritSection const&); CritSection& operator=( CritSection const&); }; class Singleton { public: static Singleton& instance(); private: Singleton(); ~Singleton(); Singleton( Singleton const&); Singleton& operator=( Singleton const&); static CritSection instance_lock; }; CritSection Singleton::instance_lock; Singleton::Singleton() { } Singleton& Singleton::instance() { EnterCriticalSection( &instance_lock); static Singleton s; LeaveCriticalSection( &instance_lock); return s; }
template<typename Tret, typename... T> Tret func(const T&... t);
/** * Object Function Tuple Argument Unpacking * * This recursive template unpacks the tuple parameters into * variadic template arguments until we reach the count of 0 where the function * is called with the correct parameters * * @tparam N Number of tuple arguments to unroll * * @ingroup g_util_tuple */ template < uint N > struct apply_obj_func { template < typename T, typename... ArgsF, typename... ArgsT, typename... Args > static void applyTuple( T* pObj, void (T::*f)( ArgsF... ), const std::tr1::tuple<ArgsT...>& t, Args... args ) { apply_obj_func<N-1>::applyTuple( pObj, f, t, std::tr1::get<N-1>( t ), args... ); } }; /** * Object Function Tuple Argument Unpacking End Point * * This recursive template unpacks the tuple parameters into * variadic template arguments until we reach the count of 0 where the function * is called with the correct parameters * * @ingroup g_util_tuple */ template <> struct apply_obj_func<0> { template < typename T, typename... ArgsF, typename... ArgsT, typename... Args > static void applyTuple( T* pObj, void (T::*f)( ArgsF... ), const std::tr1::tuple<ArgsT...>& , Args... args ) { (pObj->*f)( args... ); } }; /** * Object Function Call Forwarding Using Tuple Pack Parameters */ template < typename T, typename... ArgsF, typename... ArgsT > void applyTuple( T* pObj, void (T::*f)( ArgsF... ), std::tr1::tuple<ArgsT...> const& t ) { apply_obj_func<sizeof...(ArgsT)>::applyTuple( pObj, f, t ); } /** * Static Function Tuple Argument Unpacking * * This recursive template unpacks the tuple parameters into * variadic template arguments until we reach the count of 0 where the function * is called with the correct parameters * * @tparam N Number of tuple arguments to unroll * * @ingroup g_util_tuple */ template < uint N > struct apply_func { template < typename... ArgsF, typename... ArgsT, typename... Args > static void applyTuple( void (*f)( ArgsF... ), const std::tr1::tuple<ArgsT...>& t, Args... args ) { apply_func<N-1>::applyTuple( f, t, std::tr1::get<N-1>( t ), args... ); } }; /** * Static Function Tuple Argument Unpacking End Point * * This recursive template unpacks the tuple parameters into * variadic template arguments until we reach the count of 0 where the function * is called with the correct parameters * * @ingroup g_util_tuple */ template <> struct apply_func<0> { template < typename... ArgsF, typename... ArgsT, typename... Args > static void applyTuple( void (*f)( ArgsF... ), const std::tr1::tuple<ArgsT...>& , Args... args ) { f( args... ); } }; /** * Static Function Call Forwarding Using Tuple Pack Parameters */ template < typename... ArgsF, typename... ArgsT > void applyTuple( void (*f)(ArgsF...), std::tr1::tuple<ArgsT...> const& t ) { apply_func<sizeof...(ArgsT)>::applyTuple( f, t ); } template < typename T, typename... Args > class Message : public IMessage { typedef void (T::*F)( Args... args ); public: Message( const std::string& name, T& obj, F pFunc, Args... args ); private: virtual void doDispatch( ); T* pObj_; F pFunc_; std::tr1::tuple<Args...> args_; }; template < typename T, typename... Args > Message<T, Args...>::Message( const std::string& name, T& obj, F pFunc, Args... args ) : IMessage( name ), pObj_( &obj ), pFunc_( pFunc ), args_( std::forward<Args>(args)... ) { } template < typename T, typename... Args > void Message<T, Args...>::doDispatch( ) { try { applyTuple( pObj_, pFunc_, args_ ); } catch ( std::exception& e ) { } }
template<int...> struct index_tuple{}; template<int I, typename IndexTuple, typename... Types> struct make_indexes_impl; template<int I, int... Indexes, typename T, typename ... Types> struct make_indexes_impl<I, index_tuple<Indexes...>, T, Types...> { typedef typename make_indexes_impl<I + 1, index_tuple<Indexes..., I>, Types...>::type type; }; template<int I, int... Indexes> struct make_indexes_impl<I, index_tuple<Indexes...> > { typedef index_tuple<Indexes...> type; }; template<typename ... Types> struct make_indexes : make_indexes_impl<0, index_tuple<>, Types...> {};
using namespace std; template<class Ret, class... Args, int... Indexes > Ret apply_helper( Ret (*pf)(Args...), index_tuple< Indexes... >, tuple<Args...>&& tup) { return pf( forward<Args>( get<Indexes>(tup))... ); } template<class Ret, class ... Args> Ret apply(Ret (*pf)(Args...), const tuple<Args...>& tup) { return apply_helper(pf, typename make_indexes<Args...>::type(), tuple<Args...>(tup)); } template<class Ret, class ... Args> Ret apply(Ret (*pf)(Args...), tuple<Args...>&& tup) { return apply_helper(pf, typename make_indexes<Args...>::type(), forward<tuple<Args...>>(tup)); }
void one(int i, double d) { std::cout << "function one(" << i << ", " << d << ");\n"; } int two(int i) { std::cout << "function two(" << i << ");\n"; return i; } int main() { std::tuple<int, double> tup(23, 4.5); apply(one, tup); int d = apply(two, std::make_tuple(2)); return 0; }
template<size_t N> struct Apply { template<typename F, typename T, typename... A> static inline auto apply(F && f, T && t, A &&... a) -> decltype(Apply<N-1>::apply( ::std::forward<F>(f), ::std::forward<T>(t), ::std::get<N-1>(::std::forward<T>(t)), ::std::forward<A>(a)... )) { return Apply<N-1>::apply(::std::forward<F>(f), ::std::forward<T>(t), ::std::get<N-1>(::std::forward<T>(t)), ::std::forward<A>(a)... ); } }; template<> struct Apply<0> { template<typename F, typename T, typename... A> static inline auto apply(F && f, T &&, A &&... a) -> decltype(::std::forward<F>(f)(::std::forward<A>(a)...)) { return ::std::forward<F>(f)(::std::forward<A>(a)...); } }; template<typename F, typename T> inline auto apply(F && f, T && t) -> decltype(Apply< ::std::tuple_size< typename ::std::decay<T>::type >::value>::apply(::std::forward<F>(f), ::std::forward<T>(t))) { return Apply< ::std::tuple_size< typename ::std::decay<T>::type >::value>::apply(::std::forward<F>(f), ::std::forward<T>(t)); }
void foo(int i, bool b); std::tuple<int, bool> t = make_tuple(20, false); void m() { apply(&foo, t); }
template<size_t N> struct Apply { template<typename F, typename T, typename... A> static inline auto apply(F && f, T && t, A &&... a) { return Apply<N-1>::apply(::std::forward<F>(f), ::std::forward<T>(t), ::std::get<N-1>(::std::forward<T>(t)), ::std::forward<A>(a)... ); } }; template<> struct Apply<0> { template<typename F, typename T, typename... A> static inline auto apply(F && f, T &&, A &&... a) { return ::std::forward<F>(f)(::std::forward<A>(a)...); } }; template<typename F, typename T> inline auto apply(F && f, T && t) { return Apply< ::std::tuple_size< ::std::decay_t<T> >::value>::apply(::std::forward<F>(f), ::std::forward<T>(t)); }
using std::forward; template<size_t N> struct ApplyMember { template<typename C, typename F, typename T, typename... A> static inline auto apply(C&& c, F&& f, T&& t, A&&... a) -> decltype(ApplyMember<N-1>::apply(forward<C>(c), forward<F>(f), forward<T>(t), std::get<N-1>(forward<T>(t)), forward<A>(a)...)) { return ApplyMember<N-1>::apply(forward<C>(c), forward<F>(f), forward<T>(t), std::get<N-1>(forward<T>(t)), forward<A>(a)...); } }; template<> struct ApplyMember<0> { template<typename C, typename F, typename T, typename... A> static inline auto apply(C&& c, F&& f, T&&, A&&... a) -> decltype((forward<C>(c)->*forward<F>(f))(forward<A>(a)...)) { return (forward<C>(c)->*forward<F>(f))(forward<A>(a)...); } }; template<typename C, typename F, typename T> inline auto apply(C&& c, F&& f, T&& t) -> decltype(ApplyMember<std::tuple_size<typename std::decay<T>::type>::value>::apply(forward<C>(c), forward<F>(f), forward<T>(t))) { return ApplyMember<std::tuple_size<typename std::decay<T>::type>::value>::apply(forward<C>(c), forward<F>(f), forward<T>(t)); }
class MyClass { public: void foo(int i, bool b); }; MyClass mc; std::tuple<int, bool> t = make_tuple(20, false); void m() { apply(&mc, &MyClass::foo, t); }
template<typename F, typename Tuple, std::size_t ... I> auto apply_impl(F&& f, Tuple&& t, std::index_sequence<I...>) { return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...); } template<typename F, typename Tuple> auto apply(F&& f, Tuple&& t) { using Indices = std::make_index_sequence<std::tuple_size<std::decay_t<Tuple>>::value>; return apply_impl(std::forward<F>(f), std::forward<Tuple>(t), Indices()); }
template <typename T, typename U> void my_func(T &&t, U &&u) {} int main(int argc, char *argv[argc]) { std::tuple<int, float> my_tuple; std::apply([](auto &&... args) { my_func(args...); }, my_tuple); return 0; }
template<int ...> struct seq {}; template<int N, int ...S> struct gens : gens<N-1, N-1, S...> {}; template<int ...S> struct gens<0, S...>{ typedef seq<S...> type; }; template<typename TT> using makeSeq = typename gens< std::tuple_size< typename std::decay<TT>::type >::value >::type; template<class ...Args> struct fn_type; template<class ...Args> struct fn_type< std::tuple<Args...> >{ template<class Self, class Fn> static auto type_helper(Self &self, Fn f) -> decltype((self.*f)(declval<Args>()...)){ return NULL; } }; template<class Self, class ...Args> struct APPLY_TUPLE{}; template<class Self, class ...Args> struct APPLY_TUPLE<Self, std::tuple<Args...>>{ Self &self; APPLY_TUPLE(Self &self): self(self){} template<class T, T (Self::* f)(Args...), class Tuple> void delayed_call(Tuple &&list){ caller<T, f, Tuple >(forward<Tuple>(list), makeSeq<Tuple>() ); } template<class T, T (Self::* f)(Args...), class Tuple, int ...S> void caller(Tuple &&list, const seq<S...>){ (self.*f)( std::get<S>(forward<Tuple>(list))... ); } }; APPLY_TUPLE<typename decay<decltype(obj)>::type, typename decay<decltype(tuple)>::type >(obj).delayed_call< \ decltype( fn_type< type_of(tuple) >::type_helper(obj, &decay<decltype(obj)>::type::fname) ), \ &decay<decltype(obj)>::type::fname \ > \ (tuple);
struct DelayedCall { void call_me(int a, int b, int c){ std::cout << a+b+c; } void fire(){ tuple<int,int,int> list = make_tuple(1,2,3); apply_tuple(*this, call_me, list); } };
APPLY_TUPLE<typename decay<decltype(obj)>::type, typename decay<decltype(tuple)>::type >(obj).delayed_call< \ decltype( fn_type< type_of(tuple) >::type_helper(obj, &decay<decltype(obj)>::type::fname) ), \ &decay<decltype(obj)>::type::fname \ /* ,decltype(tuple) */> \ (tuple); ... apply_tuple(obj, call_me, list); apply_tuple(call_me, list);
template <class... Args> void tie_func(std::tuple<Args...> t, Args&... args) { std::tie<Args...>(args...) = t; } int main() { std::tuple<int, double, std::string> t(2, 3.3, "abc"); int i; double d; std::string s; tie_func(t, i, d, s); std::cout << i << " " << d << " " << s << std::endl; }
template<int N> struct apply_wrap { template<typename R, typename... TupleArgs, typename... UnpackedArgs> static R applyTuple( std::function<R(TupleArgs...)>& f, const std::tuple<TupleArgs...>& t, UnpackedArgs... args ) { return apply_wrap<N-1>::applyTuple( f, t, std::get<N-1>( t ), args... ); } }; template<> struct apply_wrap<0> { template<typename R, typename... TupleArgs, typename... UnpackedArgs> static R applyTuple( std::function<R(TupleArgs...)>& f, const std::tuple<TupleArgs...>&, UnpackedArgs... args ) { return f( args... ); } }; template<typename R, typename... TupleArgs> R applyTuple( std::function<R(TupleArgs...)>& f, std::tuple<TupleArgs...> const& t ) { return apply_wrap<sizeof...(TupleArgs)>::applyTuple( f, t ); } int fac(int n) { int r=1; for(int i=2; i<=n; ++i) r *= i; return r; } int main() { auto t = std::make_tuple(5); auto f = std::function<decltype(fac)>(&fac); cout << applyTuple(f, t); }
using std::declval; using std::forward; using std::get; using std::integral_constant; using std::size_t; using std::tuple; namespace detail { template < typename Func, typename ...T, typename ...Args > auto explode_tuple( integral_constant<size_t, 0u>, tuple<T...> const &t, Func &&f, Args &&...a ) -> decltype( forward<Func>(f)(declval<T const>()...) ) { return forward<Func>( f )( forward<Args>(a)... ); } template < size_t Index, typename Func, typename ...T, typename ...Args > auto explode_tuple( integral_constant<size_t, Index>, tuple<T...> const&t, Func &&f, Args &&...a ) -> decltype( forward<Func>(f)(declval<T const>()...) ) { return explode_tuple( integral_constant<size_t, Index - 1u>{}, t, forward<Func>(f), get<Index - 1u>(t), forward<Args>(a)... ); } } template < typename Func, typename ...T > auto run_tuple( Func &&f, tuple<T...> const &t ) -> decltype( forward<Func>(f)(declval<T const>()...) ) { return detail::explode_tuple( integral_constant<size_t, sizeof...(T)>{}, t, forward<Func>(f) ); } template < typename Tret, typename ...T > Tret func_T( tuple<T...> const &t ) { return run_tuple( &func<Tret, T...>, t ); }
apply_tuple([&ret1](double a){ret1 = cos(a); }, std::make_tuple<double>(.2)); ret2 = apply_tuple((double(*)(double))cos, std::make_tuple<double>(.2));
template<size_t N> struct apply_impl { template<typename F, typename T, typename... A> static inline auto apply_tuple(F&& f, T&& t, A&&... a) -> decltype(apply_impl<N-1>::apply_tuple(std::forward<F>(f), std::forward<T>(t), std::get<N-1>(std::forward<T>(t)), std::forward<A>(a)...)) { return apply_impl<N-1>::apply_tuple(std::forward<F>(f), std::forward<T>(t), std::get<N-1>(std::forward<T>(t)), std::forward<A>(a)...); } template<typename C, typename F, typename T, typename... A> static inline auto apply_tuple(C*const o, F&& f, T&& t, A&&... a) -> decltype(apply_impl<N-1>::apply_tuple(o, std::forward<F>(f), std::forward<T>(t), std::get<N-1>(std::forward<T>(t)), std::forward<A>(a)...)) { return apply_impl<N-1>::apply_tuple(o, std::forward<F>(f), std::forward<T>(t), std::get<N-1>(std::forward<T>(t)), std::forward<A>(a)...); } }; template<> struct apply_impl<6> { template<typename F, typename T, typename... A> static inline auto apply_tuple(F&& f, T&& t, A&&... a) -> decltype(std::forward<F>(f)(std::get<0>(std::forward<T>(t)), std::get<1>(std::forward<T>(t)), std::get<2>(std::forward<T>(t)), std::get<3>(std::forward<T>(t)), std::get<4>(std::forward<T>(t)), std::get<5>(std::forward<T>(t)), std::forward<A>(a)...)) { return std::forward<F>(f)(std::get<0>(std::forward<T>(t)), std::get<1>(std::forward<T>(t)), std::get<2>(std::forward<T>(t)), std::get<3>(std::forward<T>(t)), std::get<4>(std::forward<T>(t)), std::get<5>(std::forward<T>(t)), std::forward<A>(a)...); } template<typename C, typename F, typename T, typename... A> static inline auto apply_tuple(C*const o, F&& f, T&& t, A&&... a) -> decltype((o->*std::forward<F>(f))(std::get<0>(std::forward<T>(t)), std::get<1>(std::forward<T>(t)), std::get<2>(std::forward<T>(t)), std::get<3>(std::forward<T>(t)), std::get<4>(std::forward<T>(t)), std::get<5>(std::forward<T>(t)), std::forward<A>(a)...)) { return (o->*std::forward<F>(f))(std::get<0>(std::forward<T>(t)), std::get<1>(std::forward<T>(t)), std::get<2>(std::forward<T>(t)), std::get<3>(std::forward<T>(t)), std::get<4>(std::forward<T>(t)), std::get<5>(std::forward<T>(t)), std::forward<A>(a)...); } }; template<> struct apply_impl<0> { template<typename F, typename T, typename... A> static inline auto apply_tuple(F&& f, T&&, A&&... a) -> decltype(std::forward<F>(f)(std::forward<A>(a)...)) { return std::forward<F>(f)(std::forward<A>(a)...); } template<typename C, typename F, typename T, typename... A> static inline auto apply_tuple(C*const o, F&& f, T&&, A&&... a) -> decltype((o->*std::forward<F>(f))(std::forward<A>(a)...)) { return (o->*std::forward<F>(f))(std::forward<A>(a)...); } }; template<typename F, typename T> inline auto apply_tuple(F&& f, T&& t) -> decltype(apply_impl<std::tuple_size<typename std::decay<T>::type>::value>::apply_tuple(std::forward<F>(f), std::forward<T>(t))) { return apply_impl<std::tuple_size<typename std::decay<T>::type>::value>::apply_tuple(std::forward<F>(f), std::forward<T>(t)); } template<typename C, typename F, typename T> inline auto apply_tuple(C*const o, F&& f, T&& t) -> decltype(apply_impl<std::tuple_size<typename std::decay<T>::type>::value>::apply_tuple(o, std::forward<F>(f), std::forward<T>(t))) { return apply_impl<std::tuple_size<typename std::decay<T>::type>::value>::apply_tuple(o, std::forward<F>(f), std::forward<T>(t)); }
template <class F, F func> struct static_functor { template <class... T, class... Args_tmp> static inline auto apply(const std::tuple<T...>& t, Args_tmp... args) -> decltype(func(std::declval<T>()...)) { return static_functor<F,func>::apply(t, args..., std::get<sizeof...(Args_tmp)>(t)); } template <class... T> static inline auto apply(const std::tuple<T...>& t, T... args) -> decltype(func(args...)) { return func(args...); } }; static_functor<decltype(&myFunc), &myFunc>::apply(my_tuple);
template <class F, class... T, class... Args_tmp> inline auto apply_functor(F&& func, const std::tuple<T...>& t, Args_tmp... args) -> decltype(func(std::declval<T>()...)) { return apply_functor(func, t, args..., std::get<sizeof...(Args_tmp)>(t)); } template <class F, class... T> inline auto apply_functor(F&& func, const std::tuple<T...>& t, T... args) -> decltype(func(args...)) { return func(args...); } apply_functor(&myFunc, my_tuple);
template<typename... Args> auto get_args_as_tuple(Args... args) -> std::tuple<Args...> { return std::make_tuple(args); }
template<typename... T> void unwrap_tuple(std::tuple<T...>* tp) { std::cout << "And here I have the tuple types, all " << sizeof...(T) << " of them" << std::endl; } int main() { using TupleType = std::tuple<int, float, std::string, void*>; unwrap_tuple((TupleType*)nullptr); }
class Foo { public: virtual ~Foo() { } virtual void someMethod() = 0; static Foo *create(); }
namespace { class FooImpl: virtual public Foo { public: void someMethod() { } }; } Foo *Foo::create() { return new FooImpl; }
struct Omg{ void purr(){ cout<< "purr\n"; } }; struct Lol{ Omg* omg; void purr(){ try{ pre(); omg-> purr(); post(); }catch(...){ error(); } } };
catlib::Cat::Purr(){ cat_->Purr(); } cat::Cat::Purr(){ printf("purrrrrr"); }
template<int> void DoMyOperationHelper(); template<> void DoMyOperationHelper<4>() { } template<> void DoMyOperationHelper<8>() { } inline void DoMyOperation() { DoMyOperationHelper<sizeof(size_t)>(); } int main() { DoMyOperation(); return 0; }
if (sizeof(void*) != 8) { wprintf(L"ENV64BIT: Error: pointer should be 8 bytes. Exiting."); exit(0); } wprintf(L"Diagnostics: we are running in 64-bit mode.\n"); if (sizeof(void*) != 4) { wprintf(L"ENV32BIT: Error: pointer should be 4 bytes. Exiting."); exit(0); } wprintf(L"Diagnostics: we are running in 32-bit mode.\n");
static_assert(sizeof(void *) == 4, "Error: The Arch is not what I think it is") static_assert(sizeof(void *) == 8, "Error: The Arch is not what I think it is")
const std::string version = "0.09"; const std::string arch = (std::to_string(sizeof(void*) * 8) + "-bit");
int main() { std::cerr << "My App v" << version << " [" << arch << "]" << std::endl; }
class IC_Utility { public: IC_Utility(); ~IC_Utility(); std::string CP_PStringToString( const unsigned char *outString ); void CP_StringToPString( std::string& inString, unsigned char *outString, short inMaxLength ); static void CP_StringToPString( std::string& inString, unsigned char *outString); void CP_StringToPString( FxString& inString, FxUChar *outString); };
static void IC_Utility::CP_StringToPString(std::string& inString, unsigned char *outString) { short length = inString.length(); if( outString != NULL ) { if( length >= 1 ) CPLAT::CP_Utility::CP_CopyMemory( inString.c_str(), &outString[ 1 ], length ); outString[ 0 ] = length; } }
IC_Utility::CP_StringToPString(directoryNameString, directoryName );
static void CP_StringToPString( std::string& inString, unsigned char *outString);
string text ; text = WordList[i].substr(0,20) ; cout << "String is : " << text << endl ;
string text ; text = "hello" ; cout << "String is : " << text << endl ;
ostream& operator<<(ostream& os, string& msg) { os<<msg.c_str(); return os; }
int main () { std::string str="We think in generalities, but we live in details."; std::string str2 = str.substr (3,5); std::size_t pos = str.find("live"); std::string str3 = str.substr (pos); std::cout << str2 << return 0; }
float stof(const string& str, size_t *idx = 0); double stod(const string& str, size_t *idx = 0); long double stold(const string& str, size_t *idx = 0); int stoi(const string& str, size_t *idx = 0, int base = 10); long stol(const string& str, size_t *idx = 0, int base = 10); unsigned long stoul(const string& str, size_t *idx = 0, int base = 10); long long stoll(const string& str, size_t *idx = 0, int base = 10); unsigned long long stoull(const string& str, size_t *idx = 0, int base = 10);
string to_string(int val); string to_string(unsigned val); string to_string(long val); string to_string(unsigned long val); string to_string(long long val); string to_string(unsigned long long val); string to_string(float val); string to_string(double val); string to_string(long double val);
int main() { int number = 1234; std::ostringstream ostr; ostr << number; std::string theNumberString = ostr.str(); }
std::ostringstream ostr; float f = 1.2; int i = 3; ostr << f << " + " i << " = " << f + i; std::string s = ostr.str();
int main() { float f = 1.2; int i = 42; std::string sf = boost::lexical_cast<std::string>(f); std::string si = boost::lexical_cast<std::string>(i); }
int main() { std::string si = "12"; std::string sf = "1.2"; int i = atoi(si.c_str()); double f = atof(sf.c_str()); }
int main() { std::string inputString = "1234 12.3 44"; std::istringstream istr(inputString); int i1, i2; float f; istr >> i1 >> f >> i2; }
int main() { std::string sf = "42.2"; std::string si = "42"; float f = boost::lexical_cast<float>(sf); int i = boost::lexical_cast<int>(si); }
using Type = ; std::size_t buffer_size = ; [[noreturn]] void report_and_exit(int ret, const char *output) noexcept { std::printf("%s\n", output); std::exit(ret); } void check(const std::errc &ec) noexcept { if (ec == std::errc::value_too_large) report_and_exit(1, "Failed"); } int main() { char buffer[buffer_size]; Type val_to_be_converted, result_of_converted_back; auto result1 = std::to_chars(buffer, buffer + buffer_size, val_to_be_converted); check(result1.ec); *result1.ptr = auto result2 = std::from_chars(buffer, result1.ptr, result_of_converted_back); check(result2.ec); assert(val_to_be_converted == result_of_converted_back); report_and_exit(0, buffer); }
class make_string { public: template <typename T> make_string& operator<<( T const & val ) { buffer_ << val; return *this; } operator std::string() const { return buffer_.str(); } private: std::ostringstream buffer_; };
template <typename RETURN_TYPE, typename STRING_TYPE> RETURN_TYPE parse_string(const STRING_TYPE& str) { std::stringstream buf; buf << str; RETURN_TYPE val; buf >> val; return val; }
typedef enum { xNew = 1, xDeleted, xModified = 4, xExisting = 8 } RecordType;
namespace RecordType { static const uint8 xNew = 1; static const uint8 xDeleted = 2; static const uint8 xModified = 4; static const uint8 xExisting = 8; }
enum TRecordType { xNew = 1, xDeleted = 2, xModified = 4, xExisting = 8,
inline bool IsValidState( TRecordType v) { switch(v) { case xNew: case xDeleted: case xModified: case xExisting: return true; } return false; } inline bool IsValidMask( TRecordType v) { return v >= xNew && v < xInvalid ; }
void showRecords(TRecordType mask) { assert(RecordType::IsValidMask(mask)); } void wombleRecord(TRecord rec, TRecordType state) { assert(RecordType::IsValidState(state)); if (RecordType ::xNew) { } in runtime TRecordType updateRecord(TRecord rec, TRecordType newstate) { assert(RecordType::IsValidState(newstate)); if (! access_was_successful) return RecordType ::xInvalid; return newstate; }
struct RecordFlag { unsigned isnew:1, isdeleted:1, ismodified:1, isexisting:1; };
namespace RecordType { static const uint8 xNew = 1; static const uint8 xDeleted = 2; static const uint8 xModified = 4; static const uint8 xExisting = 8; }
namespace RecordType { const uint8 xNew = 1; const uint8 xDeleted = 2; const uint8 xModified = 4; const uint8 xExisting = 8; }
typedef enum { xNew = 1, xDeleted, xModified = 4, xExisting = 8 } RecordType;
enum RecordType { xNew = 1, xDeleted, xModified = 4, xExisting = 8 } ; void doSomething(RecordType p_eMyEnum) { if(p_eMyEnum == xNew) { } }
namespace RecordType { enum Value { xNew = 1, xDeleted, xModified = 4, xExisting = 8 } ; } void doSomething(RecordType::Value p_eMyEnum) { if(p_eMyEnum == RecordType::xNew) { } }
namespace RecordType { extern const uint8 xNew ; extern const uint8 xDeleted ; extern const uint8 xModified ; extern const uint8 xExisting ; }
namespace RecordType { const uint8 xNew = 1; const uint8 xDeleted = 2; const uint8 xModified = 4; const uint8 xExisting = 8; }
static const RecordType xNew(1); static const RecordType xDeleted(2); static const RecordType xModified(4); static const RecordType xExisting(8);
RecordType rt = whatever; rt |= xNew; rt &= ~xDeleted; if ((rt & xModified) != 0) ...
struct X { RecordType recordType : 4; RecordType recordType2 : 4; };
RecordType operator|(RecordType lhs, RecordType rhs) { return RecordType((unsigned)lhs | (unsigned)rhs); }
enum RecordType { New, Deleted, Modified, Existing }; showRecords([](RecordType r) { return r == New || r == Deleted; });
struct RecordFlag { unsigned isnew:1, isdeleted:1, ismodified:1, isexisting:1; };
typedef enum { xNew = 1, xDeleted, xModified = 4, xExisting = 8 } RecordType;
class a { int value = 0; public: struct change_value_guard { friend a; private: change_value_guard(a& owner, int value) : owner{ owner } { owner.value = value; } change_value_guard(change_value_guard&&) = delete; change_value_guard(const change_value_guard&) = delete; public: ~change_value_guard() { owner.value = 0; } private: a& owner; }; change_value_guard changeValue(int newValue) { return{ *this, newValue }; } }; int main() { a a; { auto guard = a.changeValue(2); } }
template <class T> class cola; template <class T> class nodo_colaypila { T elem; nodo_colaypila<T>* sig; friend class cola<T>; public: nodo_colaypila(T, nodo_colaypila<T>*); };
template <class T> nodo_colaypila<T>::nodo_colaypila(T a, nodo_colaypila<T>* siguiente = NULL) { elem = a; sig = siguiente; }
template <class T> class cola { nodo_colaypila<T>* ult, pri; public: cola<T>(); void anade(T&); T saca(); void print() const; virtual ~cola(); };
using namespace std; template <class T> cola<T>::cola() { pri = NULL; ult = NULL; } template <class T> void cola<T>::anade(T& valor) { nodo_colaypila <T> * nuevo; if (ult) { nuevo = new nodo_colaypila<T> (valor); ult->sig = nuevo; ult = nuevo; } if (!pri) { pri = nuevo; } } template <class T> T cola<T>::saca() { nodo_colaypila <T> * aux; T valor; aux = pri; if (!aux) { return 0; } pri = aux->sig; valor = aux->elem; delete aux; if(!pri) { ult = NULL; } return valor; } template <class T> cola<T>::~cola() { while(pri) { saca(); } } template <class T> void cola<T>::print() const { nodo_colaypila <T> * aux; aux = pri; while(aux) { cout << aux->elem << endl; aux = aux->sig; } }
using namespace std; int main() { float a, b, c; string d, e, f; cola<float> flo; cola<string> str; a = 3.14; b = 2.71; c = 6.02; flo.anade(a); flo.anade(b); flo.anade(c); flo.print(); cout << endl; d = "John"; e = "Mark"; f = "Matthew"; str.anade(d); str.anade(e); str.anade(f); cout << endl; c = flo.saca(); cout << "First In First Out Float: " << c << endl; cout << endl; f = str.saca(); cout << "First In First Out String: " << f << endl; cout << endl; flo.print(); cout << endl; str.print(); cout << "Hello world!" << endl; return 0; }
template class cola<float>; template class cola<string>;
template class nodo_colaypila<float>; template class nodo_colaypila<std :: string>;
using namespace std; int main() { int num = 255; cout.setf(ios::hex, ios::basefield); cout << "Hex: " << num << endl; cout.unsetf(ios::hex); cout << "Original format: " << num << endl; return 0; }
class Example { private: int *ptr; string name; string *pname; string &rname; const string &crname; int age; public: Example() {} };
int *ptr; string name; string *pname; string &rname; const string &crname; int age;
static const char s_str[] = "bodacydo"; class Example { private: int *ptr; string name; string *pname; string &rname; const string &crname; int age; public: Example() : name(s_str, s_str + 8), rname(name), crname(name), age(-4) { } };
class another_example{ public: another_example(); ~another_example(); private: int m_iInteger=10; double m_dDouble=10.765; };
class Registry_Entry{ public: Registry_Entry(); ~Registry_Entry(); Commit(); Retrieve(); private: CDynamicString m_cKeyName{L"Postal Address"}; CDynamicString m_cAddress; };
int *ptr; string name; string *pname; string &rname; const string &crname; int age;
std::unique_ptr<int> myPointer(new int); std::function<void(void)> = [std::move(myPointer)]{ (*myPointer) = 4; };
using namespace std; auto u = make_unique<some_type>( some, parameters ); go.run( [ u{move(u)} ] { do_something_with( u ); } );
auto lambda = [value = 0] mutable { return ++value; };
template <typename T> struct rref_impl { rref_impl() = delete; rref_impl( T && x ) : x{std::move(x)} {} rref_impl( rref_impl & other ) : x{std::move(other.x)}, isCopied{true} { assert( other.isCopied == false ); } rref_impl( rref_impl && other ) : x{std::move(other.x)}, isCopied{std::move(other.isCopied)} { } rref_impl & operator=( rref_impl other ) = delete; T && move() { return std::move(x); } private: T x; bool isCopied = false; }; template<typename T> rref_impl<T> make_rref( T && x ) { return rref_impl<T>{ std::move(x) }; }
int main() { std::unique_ptr<int> p{new int(0)}; auto rref = make_rref( std::move(p) ); auto lambda = [rref]() mutable -> std::unique_ptr<int> { return rref.move(); }; assert( lambda() ); assert( !lambda() ); }
int main() { std::unique_ptr<int> p{new int(0)}; auto lambda = capture( std::move(p), []( std::unique_ptr<int> & p ) { return std::move(p); } ); assert( lambda() ); assert( !lambda() ); }
template <typename T, typename F> class capture_impl { T x; F f; public: capture_impl( T && x, F && f ) : x{std::forward<T>(x)}, f{std::forward<F>(f)} {} template <typename ...Ts> auto operator()( Ts&&...args ) -> decltype(f( x, std::forward<Ts>(args)... )) { return f( x, std::forward<Ts>(args)... ); } template <typename ...Ts> auto operator()( Ts&&...args ) const -> decltype(f( x, std::forward<Ts>(args)... )) { return f( x, std::forward<Ts>(args)... ); } }; template <typename T, typename F> capture_impl<T,F> capture( T && x, F && f ) { return capture_impl<T,F>( std::forward<T>(x), std::forward<F>(f) ); }
std::function<void()> f = std::bind( [] (std::unique_ptr<int>& p) { *p=4; }, std::move(myPointer) );
std::unique_ptr<int> myPointer(new int{42}); auto lambda = std::bind([](std::unique_ptr<int>& myPointerArg){ *myPointerArg = 4; myPointerArg.reset(new int{237}); }, std::move(myPointer));
std::unique_ptr<int> myPointer(new int{42}); auto lambda = [myPointerCapture = std::move(myPointer)]() mutable { *myPointerCapture = 56; myPointerCapture.reset(new int{237}); };
void showPtr(const char* name, const std::unique_ptr<size_t>& ptr) { std::cout << "- &" << name << " = " << &ptr << ", " << name << ".get() = " << ptr.get(); if (ptr) std::cout << ", *" << name << " = " << *ptr; std::cout << std::endl; } template <typename F> class shared_function : public std::shared_ptr<F> { public: using std::shared_ptr<F>::shared_ptr; template <typename ...Args> auto operator()(Args&&...args) const -> typename std::result_of<F(Args...)>::type { return (*(this->get()))(std::forward<Args>(args)...); } }; template <typename F> shared_function<F> make_shared_fn(F&& f) { return shared_function<F>{ new typename std::remove_reference<F>::type{std::forward<F>(f)}}; } int main() { std::unique_ptr<size_t> myPointer(new size_t{42}); showPtr("myPointer", myPointer); std::cout << "Creating lambda\n"; auto lambda = std::bind([](std::unique_ptr<size_t>& myPointerArg){ showPtr("myPointerArg", myPointerArg); *myPointerArg *= 56; showPtr("myPointerArg", myPointerArg); myPointerArg.reset(new size_t{*myPointerArg * 237}); showPtr("myPointerArg", myPointerArg); }, std::move(myPointer)); auto lambda = [myPointerCapture = std::move(myPointer)]() mutable { showPtr("myPointerCapture", myPointerCapture); *myPointerCapture *= 56; showPtr("myPointerCapture", myPointerCapture); myPointerCapture.reset(new size_t{*myPointerCapture * 237}); showPtr("myPointerCapture", myPointerCapture); }; showPtr("myPointer", myPointer); std::cout << " lambda(); std::cout << " lambda(); std::cout << " lambda(); std::cout << "Moving to std::packaged_task\n"; std::packaged_task<void()> f{std::move(lambda)}; std::cout << " f(); std::cout << "Moving to std::function\n"; std::function<void()> f{make_shared_fn(std::move(lambda))}; std::cout << " f(); std::cout << " f(); std::cout << " f(); }
- &myPointer = 0xbfffe5c0, myPointer.get() = 0x7ae3cfd0, *myPointer = 42 Creating lambda - &myPointer = 0xbfffe5c0, myPointer.get() = 0x0 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfd0, *myPointerArg = 42 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfd0, *myPointerArg = 2352 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 557424 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 557424 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 31215744 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfd0, *myPointerArg = 3103164032 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfd0, *myPointerArg = 3103164032 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfd0, *myPointerArg = 1978493952 - &myPointerArg = 0xbfffe5b4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 751631360 Moving to std::function - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 751631360 - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 3436650496 - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3d000, *myPointerArg = 2737348608 - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3d000, *myPointerArg = 2737348608 - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3d000, *myPointerArg = 2967666688 - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 3257335808 - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 3257335808 - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 2022178816 - &myPointerArg = 0x7ae3cfd4, myPointerArg.get() = 0x7ae3d000, *myPointerArg = 2515009536
Moving to std::packaged_task - &myPointerArg = 0xbfffe590, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 751631360 - &myPointerArg = 0xbfffe590, myPointerArg.get() = 0x7ae3cfe0, *myPointerArg = 3436650496 - &myPointerArg = 0xbfffe590, myPointerArg.get() = 0x7ae3d000, *myPointerArg = 2737348608
namespace detail { enum selection_enabler { enabled }; } = ::detail::enabled template <typename T> struct move_with_copy_ctor { template <typename T2 , ENABLE_IF( !std::is_same<std::remove_reference_t<T2>, move_with_copy_ctor>::value ) > move_with_copy_ctor(T2&& object) : wrapped_object(std::forward<T2>(object)) { } move_with_copy_ctor(T&& object) : wrapped_object(std::move(object)) { } move_with_copy_ctor(move_with_copy_ctor const& object) { std::swap(wrapped_object, const_cast<move_with_copy_ctor&>(object).wrapped_object); } T& operator()() { return wrapped_object; } private: T wrapped_object; }; template <typename T> move_with_copy_ctor<T> make_movable(T&& object) { return{ std::forward<T>(object) }; } auto fn1() { std::unique_ptr<int, std::function<void(int*)>> x(new int(1) , [](int * x) { std::cout << "Destroying " << x << std::endl; delete x; }); return [y = make_movable(std::move(x))]() mutable { std::cout << "value: " << *y() << std::endl; return; }; } int main() { { auto x = fn1(); x(); std::cout << "object still not deleted\n"; x(); } std::cout << "object was deleted\n"; }
struct Foo {}; void bar(std::unique_ptr<Foo> p) { std::cout << "bar\n"; } int main() { std::unique_ptr<Foo> p(new Foo); auto f = [ptr = std::move(p)]() mutable { bar(std::move(ptr)); }; f(); return 0; }
std::unique_ptr<int> myPointer(new int); std::shared_ptr<int> mySharedPointer( std::move(myPointer) ); std::function<void(void)> = [mySharedPointer](){ *mySharedPointer = 4; };
std::unique_ptr<int> myPointer(new int); int* myRawPointer = myPointer.release(); std::function<void(void)> = [myRawPointer](){ *myRawPointer = 4; delete myRawPointer; }; myRawPointer = nullptr;
class Parent { protected: std::string something; }; class Child : public Parent { private: Child() : something("Hello, World!") { } };
class Parent { protected: Parent( const std::string& something ) : something( something ) {} std::string something; } class Child : public Parent { private: Child() : Parent("Hello, World!") { } }
class Parent { protected: std::string something; }; class Child : public Parent { private: using Parent::something; Child() { something="Hello, World!"; } };
int main() { int8_t c = 0; printf("SCHAR_MIN: %i\n", SCHAR_MIN); printf("SCHAR_MAX: %i\n", SCHAR_MAX); for (int32_t i = 0; i <= 300; i++) printf("c: %i\n", c--); printf("c: %i\n", c); return 0; }
Quadrant Angle sin cos tan ------------------------------------------------- I 0 < α < π/2 + + + II π/2 < α < π + - - III π < α < 3π/2 - - + IV 3π/2 < α < 2π - + -
System.out.println(Math.atan2(1,1)); System.out.println(Math.atan2(1,-1)); System.out.println(Math.atan2(-1,-1 )); System.out.println(Math.atan2(-1,-1)+2*Math.PI); System.out.println(Math.atan2(-1,1 )); System.out.println(Math.atan2(-1,1)+2*Math.PI); System.out.println(Math.atan(1 )); System.out.println(Math.atan(-1 ));
typedef boost::tuple<MyClass1,MyClass2,MyClass3> MyTuple;
struct ReturnInts ( int y,z; } bool f(int x, ReturnInts& vals); int x = 0; ReturnInts vals; if(!f(x, vals)) { ..report error.. ..error handling/return... }
std::tuple<int, int, bool> f(int x); int x = 0; std::tuple<int, int, bool> result = f(x); if(!result.get<2>()) { ... report error, error handling ... }
template <typename CallbackFunction> void myFunction(..., CallbackFunction && callback) { ... callback(...); ... }
template <class T> void swap(T& a, T& b) { T tmp(static_cast<T&&>(a)); a = static_cast<T&&>(b); b = static_cast<T&&>(tmp); }
template <class T> void swap(T& a, T& b) { T tmp(move(a)); a = move(b); b = move(tmp); }
template <class T> void swap(T& a, T& b) { T tmp(cast_to_rvalue(a)); a = cast_to_rvalue(b); b = cast_to_rvalue(tmp); }
template <class T> void swap(T& a, T& b) { T tmp(set_value_category_to_xvalue(a)); a = set_value_category_to_xvalue(b); b = set_value_category_to_xvalue(tmp); }
template <class T> void swap(T& a, T& b) { T tmp(move(a)); a = move(b); b = move(tmp); }
template <class T> void swap(T& a, T& b) { T tmp(static_cast<T&&>(a)); a = static_cast<T&&>(b); b = static_cast<T&&>(tmp); }
template <class T> inline constexpr typename std::remove_reference<T>::type&& set_value_category_to_xvalue(T&& t) noexcept { return static_cast<typename std::remove_reference<T>::type&&>(t); }
template <class T> inline constexpr auto&& set_value_category_to_xvalue(T&& t) noexcept { return static_cast<std::remove_reference_t<T>&&>(t); }
__Z4testRiS_: .cfi_startproc pushq %rbp Ltmp0: .cfi_def_cfa_offset 16 Ltmp1: .cfi_offset %rbp, -16 movq %rsp, %rbp Ltmp2: .cfi_def_cfa_register %rbp movl (%rsi), %eax movl %eax, (%rdi) popq %rbp retq .cfi_endproc
struct X { X& operator=(const X&); }; void test(X& i, X& j) { i = j; }
__Z4testR1XS0_: .cfi_startproc pushq %rbp Ltmp0: .cfi_def_cfa_offset 16 Ltmp1: .cfi_offset %rbp, -16 movq %rsp, %rbp Ltmp2: .cfi_def_cfa_register %rbp popq %rbp jmp __ZN1XaSERKS_ .cfi_endproc
struct X { X& operator=(const X&); X& operator=(X&&); };
__Z4testR1XS0_: .cfi_startproc pushq %rbp Ltmp0: .cfi_def_cfa_offset 16 Ltmp1: .cfi_offset %rbp, -16 movq %rsp, %rbp Ltmp2: .cfi_def_cfa_register %rbp popq %rbp jmp __ZN1XaSEOS_ .cfi_endproc
void foo() throw(); void bar() throw(int); void baz() throw(...);
template<class T> void f( T k ) { T x( k ); x.x(); }
virtual void open() throw( FileNotFound, SocketNotReady, InterprocessObjectNotImplemented, HardwareUnresponsive );
int lib_f(); void g() throw( k_too_small_exception ) { int k = lib_f(); if( k < 0 ) throw k_too_small_exception(); }
Error e = open( "bla.txt" ); if( e == FileNotFound ) MessageUser( "File bla.txt not found" ); if( e == AccessDenied ) MessageUser( "Failed to open bla.txt, because we don if( e != Success ) MessageUser( "Failed due to some other error, error code = " + itoa( e ) ); try { std::vector<TObj> k( 1000 ); } catch( const bad_alloc& b ) { MessageUser( "out of memory, exiting process" ); throw; }
struct B { }; struct C { C (){ std::cout << "C" << C (B *) { std::cout << "C (B *)" << }; B *y = nullptr; int main() { C::C (y); }
bool bValue1; bool bValue2; bool bValue3; bool bValue4;
Scenario 1 | Scenario 2 | Scenario 3 bValue1: true | true | true bValue2: true | true | false bValue3: true | true | false bValue4: true | false | false
bValue1: false bValue2: true bValue3: true bValue4: true
if(((bValue4 && (!bValue3 || !bValue2 || !bValue1)) || ((bValue3 && (!bValue2 || !bValue1)) || (bValue2 && !bValue1) || (!bValue1 && !bValue2 && !bValue3 && !bValue4)) { }
bool valid = false; if (bValue1 && bValue2 && bValue3 && bValue4) valid = true; else if (bValue1 && bValue2 && bValue3 && !bValue4) valid = true; else if (bValue1 && !bValue2 && !bValue3 && !bValue4) valid = true;
bool scenario1 = bValue1 && bValue2 && bValue3 && bValue4; bool scenario2 = bValue1 && bValue2 && bValue3 && !bValue4; bool scenario3 = bValue1 && !bValue2 && !bValue3 && !bValue4; if (scenario1 || scenario2 || scenario3) { }
bool scenario1or2 = bValue1 && bValue2 && bValue3; bool scenario3 = bValue1 && !bValue2 && !bValue3 && !bValue4; if (scenario1or2 || scenario3) { }
bValue1 && bValue2 && bValue3 || bValue1 && !bValue2 && !bValue3 && !bValue4
if(!(bValue1 && bValue2 && bValue3 || bValue1 && !bValue2 && !bValue3 && !bValue4)) { }
const int SCENARIO_1 = 0x0F; const int SCENARIO_2 = 0x0E; const int SCENARIO_3 = 0x08; bool bValue1 = true; bool bValue2 = false; bool bValue3 = false; bool bValue4 = false; int scenario = bValue1 << 3 | bValue2 << 2 | bValue3 << 1 | bValue4; bool match = scenario == SCENARIO_1 || scenario == SCENARIO_2 || scenario == SCENARIO_3; std::cout << (match ? "ok" : "error");
int scenarios[3][4] = { {true, true, true, true}, {true, true, true, false}, {true, false, false, false}, }; int main() { bool bValue1 = true; bool bValue2 = false; bool bValue3 = true; bool bValue4 = true; bool match = false; for (int i = 0; i < 4 && !match; ++i) { auto current = scenarios[i]; match = bValue1 == current[0] && bValue2 == current[1] && bValue3 == current[2] && bValue4 == current[3]; } std::cout << (match ? "ok" : "error"); }
int GetScenarioInt(bool bValue1, bool bValue2, bool bValue3, bool bValue4) { return bValue1 << 3 | bValue2 << 2 | bValue3 << 1 | bValue4; } bool IsValidScenario(bool bValue1, bool bValue2, bool bValue3, bool bValue4) { std::set<int> validScenarios; validScenarios.insert(GetScenarioInt(true, true, true, true)); validScenarios.insert(GetScenarioInt(true, true, true, false)); validScenarios.insert(GetScenarioInt(true, false, false, false)); int currentScenario = GetScenarioInt(bValue1, bValue2, bValue3, bValue4); return validScenarios.find(currentScenario) != validScenarios.end(); } int main() { std::cout << IsValidScenario(true, true, true, false) << "\n"; std::cout << IsValidScenario(true, true, false, false) << "\n"; return 0; }
unsigned bitmap_from_bools(bool b) { return b; } template<typename... args> unsigned bitmap_from_bools(bool b, args... pack) { return (bitmap_from_bools(b) << sizeof...(pack)) | bitmap_from_bools(pack...); } int main() { bool bValue1; bool bValue2; bool bValue3; bool bValue4; unsigned summary = bitmap_from_bools(bValue1, bValue2, bValue3, bValue4); if (summary != 0b1111u && summary != 0b1110u && summary != 0b1000u) { } }
bool equals_any(unsigned target, unsigned compare) { return target == compare; } template<typename... args> bool equals_any(unsigned target, unsigned compare, args... compare_pack) { return equals_any(target, compare) ? true : equals_any(target, compare_pack...); } int main() { bool bValue1; bool bValue2; bool bValue3; bool bValue4; unsigned summary = bitmap_from_bools(bValue1, bValue2, bValue3, bValue4); if (!equals_any(summary, 0b1111u, 0b1110u, 0b1000u)) { } }
if (bValue1&&(bValue2==bValue3)&&(bValue2||!bValue4)) { } else { }
if (bValue1&&(bValue2==bValue3)&&(bValue2>=bValue4)) ...
template<class T0> auto is_any_of( T0 const& t0, std::initializer_list<T0> il ) { for (auto&& x:il) if (x==t0) return true; return false; }
if (is_any_of( std::make_tuple(bValue1, bValue2, bValue3, bValue4), { {true, true, true, true}, {true, true, true, false}, {true, false, false, false} } ))
using entry = std::array<bool, 4>; constexpr entry acceptable[] = { {true, true, true, true}, {true, true, true, false}, {true, false, false, false} }; if (std::any_of( begin(acceptable), end(acceptable), [&](auto&&x){ return entry{bValue1, bValue2, bValue3, bValue4} == x; }) { }
bool CChristianLifeMinistryValidationDlg::IsFirstWeekStudentItems(CChristianLifeMinistryEntry *pEntry) { return (INCLUDE_ITEM1(pEntry) && !INCLUDE_ITEM2(pEntry) && !INCLUDE_ITEM3(pEntry) && !INCLUDE_ITEM4(pEntry)); } bool CChristianLifeMinistryValidationDlg::IsSecondWeekStudentItems(CChristianLifeMinistryEntry *pEntry) { return (INCLUDE_ITEM1(pEntry) && INCLUDE_ITEM2(pEntry) && INCLUDE_ITEM3(pEntry) && INCLUDE_ITEM4(pEntry)); } bool CChristianLifeMinistryValidationDlg::IsOtherWeekStudentItems(CChristianLifeMinistryEntry *pEntry) { return (INCLUDE_ITEM1(pEntry) && INCLUDE_ITEM2(pEntry) && INCLUDE_ITEM3(pEntry) && !INCLUDE_ITEM4(pEntry)); }
if (!IsFirstWeekStudentItems(pEntry) && !IsSecondWeekStudentItems(pEntry) && !IsOtherWeekStudentItems(pEntry)) { ; Error }
constexpr bool IsScenario1(bool b1, bool b2, bool b3, bool b4) noexcept { return b1 && b2 && b3 && b4; } constexpr bool IsScenario2(bool b1, bool b2, bool b3, bool b4) noexcept { return b1 && b2 && b3 && !b4; } constexpr bool IsScenario3(bool b1, bool b2, bool b3, bool b4) noexcept { return b1 && !b2 && !b3 && !b4; }
const auto is_scenario_1 = bValue1 && bValue2 && bValue3 && bValue4; const auto is_scenario_2 = bvalue1 && bvalue2 && bValue3 && !bValue4; const auto is_scenario_3 = bValue1 && !bValue2 && !bValue3 && !bValue4;
bool scenario[3][4] = {{true, true, true, true}, {true, true, true, false}, {true, false, false, false}}; bool CheckScenario(bool bValue1, bool bValue2, bool bValue3, bool bValue4) { bool temp[] = {bValue1, bValue2, bValue3, bValue4}; for(int i = 0 ; i < sizeof(scenario) / sizeof(scenario[0]); i++) { if(memcmp(temp, scenario[i], sizeof(temp)) == 0) return true; } return false; }
bool valid = false; if(bValue1 && bValue2 && bValue3) { if (bValue4) valid = true; else if (!bValue4) valid = true; } else if (bValue1 && !bValue2 && !bValue3 && !bValue4) valid = true;
bool valid = false; if(bValue1) { if(bValue2 && bValue3) { if (bValue4) valid = true; else if (!bValue4) valid = true; } else if (!bValue2 && !bValue3 && !bValue4) valid = true; }
bool valid = false; if(bValue1) { bool bValue1and2 = bValue1 && bValue2; bool notBValue1and2 = !bValue2 && !bValue3; if(bValue1and2) { if (bValue4) valid = true; else if (!bValue4) valid = true; } else if (notBValue1and2 && !bValue4) valid = true; }
if(!((bValue1 && bValue2 && bValue3) || (bValue1 && !bValue2 && !bValue3 && !bValue4)) )
bool any_of_three_scenarios(bool v1, bool v2, bool v3, bool v4) { return (v1 && v2 && v3 && v4) || (v1 && v2 && v3 && !v4) || (v1 && !v2 && !v3 && !v4); } if (any_of_three_scenarios(bValue1,bValue2,bValue3,bValue4)) { }
switch( (bValue4 << 3) | (bValue3 << 2) | (bValue2 << 1) | (bValue1) ) { case 0b1111: break; case 0b0111: break; case 0b0001: break; default: break; }
bool MAJORLY_TRUE=bValue1 && bValue2 && bValue3 bool MAJORLY_FALSE=!(bValue2 || bValue3 || bValue4)
if (MAJORLY_TRUE || (bValue1 && MAJORLY_FALSE)) { } else { }
using namespace std; struct Values { bool bValue1; bool bValue2; bool bValue3; bool bValue4; }; class Scenario { public: Scenario(Values& values) : mValues(values) {} virtual operator bool() = 0; protected: Values& mValues; }; class Scenario1_TheCarWasNotDamagedAtAll : public Scenario { public: Scenario1_TheCarWasNotDamagedAtAll(Values& values) : Scenario(values) {} virtual operator bool() { return mValues.bValue1 && mValues.bValue2 && mValues.bValue3 && mValues.bValue4; } }; class Scenario2_TheCarBreaksDownButDidntGoOnFire : public Scenario { public: Scenario2_TheCarBreaksDownButDidntGoOnFire(Values& values) : Scenario(values) {} virtual operator bool() { return mValues.bValue1 && mValues.bValue2 && mValues.bValue3 && !mValues.bValue4; } }; class Scenario3_TheCarWasCompletelyWreckedAndFireEverywhere : public Scenario { public: Scenario3_TheCarWasCompletelyWreckedAndFireEverywhere(Values& values) : Scenario(values) {} virtual operator bool() { return mValues.bValue1 && !mValues.bValue2 && !mValues.bValue3 && !mValues.bValue4; } }; Scenario* findMatchingScenario(std::vector<Scenario*>& scenarios) { for(std::vector<Scenario*>::iterator it = scenarios.begin(); it != scenarios.end(); it++) { if (**it) { return *it; } } return NULL; } int main() { Values values = {true, true, true, true}; std::vector<Scenario*> scenarios = { new Scenario1_TheCarWasNotDamagedAtAll(values), new Scenario2_TheCarBreaksDownButDidntGoOnFire(values), new Scenario3_TheCarWasCompletelyWreckedAndFireEverywhere(values) }; Scenario* matchingScenario = findMatchingScenario(scenarios); if(matchingScenario) { std::cout << matchingScenario << " was a match" << std::endl; } else { std::cout << "No match" << std::endl; } return 0; }
Key && ( (Alice && Bob) || ((!Alice && !Bob) && !Charlie) )
int bitwise = (bValue4 << 3) | (bValue3 << 2) | (bValue2 << 1) | (bValue1); if (bitwise == 0b1111 || bitwise == 0b0111 || bitwise == 0b0001) { }
bValue1 = a (!A) bValue2 = b (!B) bValue3 = c (!C) bValue4 = d (!D)
1 = abcd + abcD + aBCD = a (bcd + bcD + BCD) = a (bc + BCD) = a (bcd + D (b ^C))
If (!bValue1 || (bValue2 != bValue3) || (!bValue4 && bValue2)) { }
bool valid = false; valid = valid || (bValue1 && bValue2 && bValue3 && bValue4); valid = valid || (bValue1 && bValue2 && bValue3 && !bValue4); valid = valid || (bValue1 && !bValue2 && !bValue3 && !bValue4);
public class Options { public const bool A = 2; public const bool B = 4; public const bool C = 16; public const bool D = 32; } ... public isScenario3(int options) { int s3 = Options.A | Options.B | Options.C; return options == s3; }
bool check(int bValue1, int bValue2, int bValue3, int bValue4) { if (bValue1) { if (bValue2) { return bValue3; } else { return !bValue3 && !bValue4; } } return false; }
Scenario 1 | Scenario 2 | Scenario 3 bValue1: true | true | true bValue2: true | true | false bValue3: true | true | false bValue4: true | false | false
0 1 2 3 Scenario 1: T T T T Scenario 2: T T T F Scenario 3: T F F F
if( myarray == scenario1 ) { } else if ( myarray == scenario2 ) { } else if ( myarray == scenario3 ) { } else { }
Scenario 1 | Scenario 2 | Scenario 3 bValue1: true | true | true bValue2: true | true | false bValue3: true | true | false bValue4: true | false | false
enum State { scenario1, scenario2, scenario3, }; inline bool isValue1(State s) { return true; } inline bool isValue2(State s) { switch (s) { case scenario1: case scenario2: return true; case scenario3: return false; } } inline bool isValue3(State s) { return isValue2(s); } inline bool isValue4(State s) { switch (s) { case scenario1: return true; case scenario2: case scenario3: return false; } }
if(bValue1) { sum=sum+1; } if(bValue2) { sum=sum+2; } if(bValue3) { sum=sum+4; } if(bValue4) { sum=sum+8; }
class BaseValidator { BaseValidator* nextValidator; public: BaseValidator() { nextValidator = 0; } void link(BaseValidator validator) { if (nextValidator) { nextValidator->link(validator); } else { nextValidator = validator; } } bool callLinkedValidator(bool v1, bool v2, bool v3, bool v4) { if (nextValidator) { return nextValidator->validate(v1, v2, v3, v4); } return false; } virtual bool validate(bool v1, bool v2, bool v3, bool v4) { return false; } }
class Validator1: public BaseValidator { public: bool validate(bool v1, bool v2, bool v3, bool v4) { if (v1 && v2 && v3 && v4) { return true; } return nextValidator->callLinkedValidator(v1, v2, v3, v4); } }
Validator1 firstValidator = new Validator1(); Validator2 secondValidator = new Validator2(); Validator3 thirdValidator = new Validator3(); firstValidator.link(secondValidator); firstValidator.link(thirdValidator); if (firstValidator.validate(value1, value2, value3, value4)) { ... }
class BaseValidator: def __init__(self): self.nextValidator = 0 def link(self, validator): if (self.nextValidator): self.nextValidator.link(validator) else: self.nextValidator = validator def callLinkedValidator(self, v1, v2, v3, v4): if (self.nextValidator): return self.nextValidator.validate(v1, v2, v3, v4) return False def validate(self, v1, v2, v3, v4): return False class Validator1(BaseValidator): def validate(self, v1, v2, v3, v4): if (v1 and v2 and v3 and v4): return True return self.callLinkedValidator(v1, v2, v3, v4) class Validator2(BaseValidator): def validate(self, v1, v2, v3, v4): if (v1 and v2 and v3 and not v4): return True return self.callLinkedValidator(v1, v2, v3, v4) class Validator3(BaseValidator): def validate(self, v1, v2, v3, v4): if (v1 and not v2 and not v3 and not v4): return True return self.callLinkedValidator(v1, v2, v3, v4) firstValidator = Validator1() secondValidator = Validator2() thirdValidator = Validator3() firstValidator.link(secondValidator) firstValidator.link(thirdValidator) print(firstValidator.validate(False, False, True, False))
(boolean1 && boolean2 && boolean3) || ((boolean1 && !boolean2 && !boolean3 && !boolean4)
unoin { struct { bool b1: 1; bool b2: 1; bool b3: 1; bool b4: 1; } b; int i; } u; u.b.b1=true; ... if (u.i == 0x0f) {...} if (u.i == 0x0e) {...} if (u.i == 0x08) {...}
set<vector<int>> s; s.insert({1, 2}); s.insert({1, 3}); s.insert({1, 2}); for(const auto& vec:s) cout<<vec<<endl;
struct VectorHash { size_t operator()(const std::vector<int>& v) const { std::hash<int> hasher; size_t seed = 0; for (int i : v) { seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2); } return seed; } }; vector<vector<int>> two(){ unordered_set<vector<int>, VectorHash> s; s.insert({1, 2}); s.insert({1, 3}); s.insert({1, 2}); for(const auto& vec:s) cout<<vec<<endl; }
class Node { public: Node(int data); int m_data; Node *m_next; };
/** Brief Create a list, show it, then destroy it */ void raw_pointer_demo() { cerr << "\n" << "raw_pointer_demo()..." << "\n"; struct Node { Node(int data, Node *next) : data(data), next(next) {} int data; Node *next; }; Node * items = 0; items = new Node(1,items); items = new Node(7,items); items = new Node(3,items); items = new Node(9,items); for (Node *i = items; i != 0; i = i->next) cerr << (i==items?"":", ") << i->data; cerr << "\n"; while (items) { Node *temp = items; items = items->next; delete temp; } }
/** Brief Create a list, show it, then destroy it */ void shared_pointer_demo() { cerr << "\n" << "shared_pointer_demo()..." << "\n"; struct Node; typedef std::shared_ptr<Node> Node_reference; struct Node { Node(int data, std::shared_ptr<Node> next ) : data(data), next(next) {} int data; Node_reference next; }; Node_reference items = 0; items.reset( new Node(1,items) ); items.reset( new Node(7,items) ); items.reset( new Node(3,items) ); items.reset( new Node(9,items) ); for (Node_reference i = items; i != 0; i = i->next) cerr << (i==items?"":", ") << i->data; cerr<<"\n"; while (items) items = items->next; }
/** Brief Show the contents of a standard container */ template< typename C > void show(std::string const & msg, C const & container) { cerr << msg; bool first = true; for ( int i : container ) cerr << (first?" ":", ") << i, first = false; cerr<<"\n"; }
/** Brief Create a list, manipulate it, then destroy it */ void std_list_demo() { cerr << "\n" << "std_list_demo()..." << "\n"; std::list<int> items = { 9, 3, 7, 1 }; show( "A: ", items ); items.insert(std::find( items.begin(), items.end(), 3), 8); show("B: ", items); items.sort(); show( "C: ", items); items.erase(std::find(items.begin(), items.end(), 7)); show("D: ", items); items.clear(); show("E: ", items); }
std_list_demo()... A: 9, 3, 7, 1 B: 9, 8, 3, 7, 1 C: 1, 3, 7, 8, 9 D: 1, 3, 8, 9 E:
/** brief Create a list, manipulate it, then destroy it */ void std_vector_demo() { cerr << "\n" << "std_vector_demo()..." << "\n"; std::vector<int> items = { 9, 3, 7, 1 }; show( "A: ", items ); items.insert(std::find(items.begin(), items.end(), 3), 8); show( "B: ", items ); sort(items.begin(), items.end()); show("C: ", items); items.erase( std::find( items.begin(), items.end(), 7 ) ); show("D: ", items); items.clear(); show("E: ", items); }
std_vector_demo()... A: 9, 3, 7, 1 B: 9, 8, 3, 7, 1 C: 1, 3, 7, 8, 9 D: 1, 3, 8, 9 E:
int main() { raw_pointer_demo(); shared_pointer_demo(); std_list_demo(); std_vector_demo(); }
class AddressClass { public: int Code; char[50] Street; char[10] Number; char[50] POBox; char[50] City; char[50] State; char[50] Country; }; class CustomerClass { public: int Code; char[50] FirstName; char[50] LastName; AddressClass Address; }; int main(...) { CustomerClass MyCustomer(); MyCustomer.Code = 1; strcpy(MyCustomer.FirstName, "John"); strcpy(MyCustomer.LastName, "Doe"); MyCustomer.Address.Code = 2; strcpy(MyCustomer.Address.Street, "Blue River"); strcpy(MyCustomer.Address.Number, "2231 A"); return 0; } ....................................... ..+---------------------------------+.. ..| AddressClass |.. ..+---------------------------------+.. ..| [+] int: Code |.. ..| [+] char[50]: Street |.. ..| [+] char[10]: Number |.. ..| [+] char[50]: POBox |.. ..| [+] char[50]: City |.. ..| [+] char[50]: State |.. ..| [+] char[50]: Country |.. ..+---------------------------------+.. ....................................... ..+---------------------------------+.. ..| CustomerClass |.. ..+---------------------------------+.. ..| [+] int: Code |.. ..| [+] char[50]: FirstName |.. ..| [+] char[50]: LastName |.. ..+---------------------------------+.. ..| [+] AddressClass: Address |.. ..| +-----------------------------+ |.. ..| | [+] int: Code | |.. ..| | [+] char[50]: Street | |.. ..| | [+] char[10]: Number | |.. ..| | [+] char[50]: POBox | |.. ..| | [+] char[50]: City | |.. ..| | [+] char[50]: State | |.. ..| | [+] char[50]: Country | |.. ..| +-----------------------------+ |.. ..+---------------------------------+.. .......................................
class AddressClass { public: int Code; char[50] Street; char[10] Number; char[50] POBox; char[50] City; char[50] State; char[50] Country; }; class CustomerClass { public: int Code; char[50] FirstName; char[50] LastName; AddressClass* Address; }; ....................................... ..+-----------------------------+...... ..| AddressClass +<--+.. ..+-----------------------------+...|.. ..| [+] int: Code |...|.. ..| [+] char[50]: Street |...|.. ..| [+] char[10]: Number |...|.. ..| [+] char[50]: POBox |...|.. ..| [+] char[50]: City |...|.. ..| [+] char[50]: State |...|.. ..| [+] char[50]: Country |...|.. ..+-----------------------------+...|.. ....................................|.. ..+-----------------------------+...|.. ..| CustomerClass |...|.. ..+-----------------------------+...|.. ..| [+] int: Code |...|.. ..| [+] char[50]: FirstName |...|.. ..| [+] char[50]: LastName |...|.. ..| [+] AddressClass*: Address +---+.. ..+-----------------------------+...... ....................................... int main(...) { CustomerClass* MyCustomer = new CustomerClass(); MyCustomer->Code = 1; strcpy(MyCustomer->FirstName, "John"); strcpy(MyCustomer->LastName, "Doe"); AddressClass* MyCustomer->Address = new AddressClass(); MyCustomer->Address->Code = 2; strcpy(MyCustomer->Address->Street, "Blue River"); strcpy(MyCustomer->Address->Number, "2231 A"); free MyCustomer->Address(); free MyCustomer(); return 0; }
class Node { public: Node(int data); int m_data; Node *m_next; }; ....................................... ..+-----------------------------+...... ..| Node |...... ..+-----------------------------+...... ..| [+] int: m_data |...... ..| [+] Node*: m_next +---+.. ..+-----------------------------+...|.. ....................................|.. ..+-----------------------------+...|.. ..| Node +<--+.. ..+-----------------------------+...... ..| [+] int: m_data |...... ..| [+] Node*: m_next +---+.. ..+-----------------------------+...|.. ....................................|.. ..+-----------------------------+...|.. ..| Node +<--+.. ..+-----------------------------+...... ..| [+] int: m_data |...... ..| [+] Node*: m_next +---+.. ..+-----------------------------+...|.. ....................................v.. ...................................[X]. .......................................
int main (..) { MyClass myObject; MyClass * myObjectPointer = new MyClass(); .. }
public static void main (..) { MyClass myObjectReference = new MyClass(); }
<return-type> function(<params>) { <initialization> do { <main code for function> } while(false); <tidy-up & return> }
if( foo ) PRINT_IF_DEBUGMODE_ON("Hullo\n") else doSomethingElse();
do { if (!condition1) break; some_code; if (!condition2) break; some_further_code; } while(false);
<return-type> function(<params>) { <initialization> <main code for function using "goto error;" if something goes wrong> <tidy-up in success case & return> error: <commmon tidy-up actions for error case & return error code or throw exception> }
if (data == &array[o1]) operation = O1; else if (data == &array[o2]) operation = O2; else if (data == &array[on]) operation = ON; Log("operation:",operation);
do { if (data == &array[o1]) { operation = O1; break; } if (data == &array[o2]) { operation = O2; break; } if (data == &array[on]) { operation = ON; break; } } while (false); Log("operation:",operation);
if (data == &array[o1]) { operation = O1; break; } else if (...)
init(); ... { c = NULL; mkwidget(&c); finishwidget(&c); } shutdown();
if (finished) { closewindows(&windows); freememory(&cache); }
if (finished) closewindows(&windows); freememory(&cache);
import java.util.Arrays; import java.util.List; import java.util.Set; import java.util.stream.Collectors; import java.util.stream.Stream; public class p45 { static List<String> cakeNames = Arrays.asList("schwarzwald torte", "princess", "icecream"); static Set<Integer> forbidden = Stream.of(0, 2).collect(Collectors.toSet()); public static void main(String[] argv) { for (int i = 0; i < 4; i++) { System.out.println(String.format("cake(%d)=\"%s\"", i, describeCake(i))); } } static String describeCake(int typeOfCake) { String result = "unknown"; do { if (typeOfCake < 0 || typeOfCake >= cakeNames.size()) break; if (forbidden.contains(typeOfCake)) { result = "not for you!!"; break; } result = cakeNames.get(typeOfCake); } while (false); return result; } }
int main() { { for (int i = 0; i != 10; ++i) { std::cout << "delete i->second;" << std::endl; } } { for (size_t i = 0; i < 20; ++i) { std::cout << "delete m_indices[i];" << std::endl; } } return 0; }
{ for (int i=0; i<1; ++i){} for (int i=0; i<2; ++i){} }
float average; { int sum = 0; for (int i = 0; i < count; ++i) { sum += v[i]; } average = (float)sum / count; }
template<typename T> void deleten(T *&ptr) { delete ptr; ptr = NULL; }
int main() { bool someValue = true; int x = 10, y = 10; someValue ? ++x, ++y : --x, --y; std::cout << x << " " << y << std::endl; return 0; }
whatIreallyWanted = someValue ? ++x, ++y : --x, --y;
---------------------------------------------------------------------------- | trigraph | replacement | trigraph | replacement | trigraph | replacement | ---------------------------------------------------------------------------- | ??= | | ??/ | \ | ??) | ] | ??> | } | | ??’ | ˆ | ??! | | | ??- | ˜ | ----------------------------------------------------------------------------
ScopeGuard const& guard = MakeGuard(&cleanUpFunction);
struct ScopeGuard { ~ScopeGuard() { } }; template<typename T> struct Derived : ScopeGuard { T t; Derived(T t):t(t) { } ~Derived() { t(); } }; template<typename T> Derived<T> MakeGuard(T t) { return Derived<T>(t); }
struct SmartPtr { int getCopies() const { return mCopiesMade; } };
struct MyString { char * getData() { return mData; } char const* getData() const { return mData; } };
int main() { string const a = "1234"; string const b = a; cout << (void*)&a[0] << ", " << (void*)&b[0]; }
int main() { string const a = "1234"; string b = a; cout << (void*)&a[0] << ", " << (void*)&b[0]; }
struct MyClass { MyClass(MyClass const& that) { } };
void PrintStudent(const Student& student) { cout << student.GetName(); }
class Student { public: string GetName() const { ... } };
enum class Color : char { red = 0x1, yellow = 0x2 } char *data = ReadFile(); Color color = static_cast<Color>(data[0]);
const char digit_pairs[201] = { "00010203040506070809" "10111213141516171819" "20212223242526272829" "30313233343536373839" "40414243444546474849" "50515253545556575859" "60616263646566676869" "70717273747576777879" "80818283848586878889" "90919293949596979899" }; std::string& itostr(int n, std::string& s) { if(n==0) { s="0"; return s; } int sign = -(n<0); unsigned int val = (n^sign)-sign; int size; if(val>=10000) { if(val>=10000000) { if(val>=1000000000) size=10; else if(val>=100000000) size=9; else size=8; } else { if(val>=1000000) size=7; else if(val>=100000) size=6; else size=5; } } else { if(val>=100) { if(val>=1000) size=4; else size=3; } else { if(val>=10) size=2; else size=1; } } size -= sign; s.resize(size); char* c = &s[0]; if(sign) *c= c += size-1; while(val>=100) { int pos = val % 100; val /= 100; *(short*)(c-1)=*(short*)(digit_pairs+2*pos); c-=2; } while(val>0) { *c--= val /= 10; } return s; } std::string& itostr(unsigned val, std::string& s) { if(val==0) { s="0"; return s; } int size; if(val>=10000) { if(val>=10000000) { if(val>=1000000000) size=10; else if(val>=100000000) size=9; else size=8; } else { if(val>=1000000) size=7; else if(val>=100000) size=6; else size=5; } } else { if(val>=100) { if(val>=1000) size=4; else size=3; } else { if(val>=10) size=2; else size=1; } } s.resize(size); char* c = &s[size-1]; while(val>=100) { int pos = val % 100; val /= 100; *(short*)(c-1)=*(short*)(digit_pairs+2*pos); c-=2; } while(val>0) { *c--= val /= 10; } return s; }
template <typename T> std::string itostr(T t) { std::string ret; itostr(t, ret); return ret; }
template <typename T> T reduce2(T v) { T k = ((v * 410) >> 12) & 0x000F000F000F000Full; return (((v - k * 10) << 8) + k); } template <typename T> T reduce4(T v) { T k = ((v * 10486) >> 20) & 0xFF000000FFull; return reduce2(((v - k * 100) << 16) + (k)); } typedef unsigned long long ull; inline ull reduce8(ull v) { ull k = ((v * 3518437209u) >> 45); return reduce4(((v - k * 10000) << 32) + (k)); } template <typename T> std::string itostr(T o) { union { char str[16]; unsigned short u2[8]; unsigned u4[4]; unsigned long long u8[2]; }; unsigned v = o < 0 ? ~o + 1 : o; u8[0] = (ull(v) * 3518437209u) >> 45; u8[0] = (u8[0] * 28147497672ull); u8[1] = v - u2[3] * 100000000; u8[1] = reduce8(u8[1]); char* f; if (u2[3]) { u2[3] = reduce2(u2[3]); f = str + 6; } else { unsigned short* k = u4[2] ? u2 + 4 : u2 + 6; f = *k ? (char*)k : (char*)(k + 1); } if (!*f) f++; u4[1] |= 0x30303030; u4[2] |= 0x30303030; u4[3] |= 0x30303030; if (o < 0) *--f = return std::string(f, (str + 16) - f); }
struct itostr_helper { static unsigned out[10000]; itostr_helper() { for (int i = 0; i < 10000; i++) { unsigned v = i; char * o = (char*)(out + i); o[3] = v % 10 + o[2] = (v % 100) / 10 + o[1] = (v % 1000) / 100 + o[0] = (v % 10000) / 1000; if (o[0]) o[0] |= 0x30; else if (o[1] != else if (o[2] != else o[0] |= 0x00; } } }; unsigned itostr_helper::out[10000]; itostr_helper hlp_init; template <typename T> std::string itostr(T o) { typedef itostr_helper hlp; unsigned blocks[3], *b = blocks + 2; blocks[0] = o < 0 ? ~o + 1 : o; blocks[2] = blocks[0] % 10000; blocks[0] /= 10000; blocks[2] = hlp::out[blocks[2]]; if (blocks[0]) { blocks[1] = blocks[0] % 10000; blocks[0] /= 10000; blocks[1] = hlp::out[blocks[1]]; blocks[2] |= 0x30303030; b--; } if (blocks[0]) { blocks[0] = hlp::out[blocks[0] % 10000]; blocks[1] |= 0x30303030; b--; } char* f = ((char*)b); f += 3 - (*f >> 4); char* str = (char*)blocks; if (o < 0) *--f = return std::string(f, (str + 12) - f); }
const char digit_pairs[201] = { "00010203040506070809" "10111213141516171819" "20212223242526272829" "30313233343536373839" "40414243444546474849" "50515253545556575859" "60616263646566676869" "70717273747576777879" "80818283848586878889" "90919293949596979899" }; static const int BUFFER_SIZE = 11; std::string itostr(int val) { char buf[BUFFER_SIZE]; char *it = &buf[BUFFER_SIZE-2]; if(val>=0) { int div = val/100; while(div) { memcpy(it,&digit_pairs[2*(val-div*100)],2); val = div; it-=2; div = val/100; } memcpy(it,&digit_pairs[2*val],2); if(val<10) it++; } else { int div = val/100; while(div) { memcpy(it,&digit_pairs[-2*(val-div*100)],2); val = div; it-=2; div = val/100; } memcpy(it,&digit_pairs[-2*val],2); if(val<=-10) it--; *it = } return std::string(it,&buf[BUFFER_SIZE]-it); } std::string itostr(unsigned int val) { char buf[BUFFER_SIZE]; char *it = (char*)&buf[BUFFER_SIZE-2]; int div = val/100; while(div) { memcpy(it,&digit_pairs[2*(val-div*100)],2); val = div; it-=2; div = val/100; } memcpy(it,&digit_pairs[2*val],2); if(val<10) it++; return std::string((char*)it,(char*)&buf[BUFFER_SIZE]-(char*)it); }
typedef unsigned buf_t; static buf_t * reduce(unsigned val, buf_t * stp) { unsigned above = val / 10000; if (above != 0) { stp = reduce(above, stp); val -= above * 10000; } buf_t digit = val / 1000; *stp++ = digit + val -= digit * 1000; digit = val / 100; *stp++ = digit + val -= digit * 100; digit = val / 10; *stp++ = digit + val -= digit * 10; *stp++ = val + return stp; } std::string itostr(int input) { buf_t buf[16]; if(input == INT_MIN) { char buf2[16]; std::sprintf(buf2, "%d", input); return std::string(buf2); } unsigned val = input; if(input < 0) val = -input; buf[0] = buf_t* endp = reduce(val, buf+1); *endp = 127; buf_t * stp = buf+1; while (*stp == stp++; if (stp == endp) stp--; if (input < 0) { stp--; *stp = } return std::string(stp, endp); }
Integer To String Test (Type 1) [modp_ufast]Numbers: 240000000 Total: 657777786 Time: 1.1633sec Rate:206308473.0686nums/sec [sprintf] Numbers: 240000000 Total: 657777786 Time: 24.3629sec Rate: 9851045.8556nums/sec [karma] Numbers: 240000000 Total: 657777786 Time: 5.2389sec Rate: 45810870.7171nums/sec [strtk] Numbers: 240000000 Total: 657777786 Time: 3.3126sec Rate: 72450283.7492nums/sec [so ] Numbers: 240000000 Total: 657777786 Time: 3.0828sec Rate: 77852152.8820nums/sec [timo ] Numbers: 240000000 Total: 657777786 Time: 4.7349sec Rate: 50687912.9889nums/sec [voigt] Numbers: 240000000 Total: 657777786 Time: 5.1689sec Rate: 46431985.1142nums/sec [hopman] Numbers: 240000000 Total: 657777786 Time: 4.6169sec Rate: 51982554.6497nums/sec Press any key to continue . . . Integer To String Test(Type 2) [modp_ufast]Numbers: 240000000 Total: 660000000 Time: 0.5072sec Rate:473162716.4618nums/sec [sprintf] Numbers: 240000000 Total: 660000000 Time: 22.3483sec Rate: 10739062.9383nums/sec [karma] Numbers: 240000000 Total: 660000000 Time: 4.2471sec Rate: 56509024.3035nums/sec [strtk] Numbers: 240000000 Total: 660000000 Time: 2.1683sec Rate:110683636.7123nums/sec [so ] Numbers: 240000000 Total: 660000000 Time: 2.7133sec Rate: 88454602.1423nums/sec [timo ] Numbers: 240000000 Total: 660000000 Time: 2.8030sec Rate: 85623453.3872nums/sec [voigt] Numbers: 240000000 Total: 660000000 Time: 3.4019sec Rate: 70549286.7776nums/sec [hopman] Numbers: 240000000 Total: 660000000 Time: 2.7849sec Rate: 86178023.8743nums/sec Press any key to continue . . . Integer To String Test (type 3) [modp_ufast]Numbers: 240000000 Total: 505625000 Time: 1.6482sec Rate:145610315.7819nums/sec [sprintf] Numbers: 240000000 Total: 505625000 Time: 20.7064sec Rate: 11590618.6109nums/sec [karma] Numbers: 240000000 Total: 505625000 Time: 4.3036sec Rate: 55767734.3570nums/sec [strtk] Numbers: 240000000 Total: 505625000 Time: 2.9297sec Rate: 81919227.9275nums/sec [so ] Numbers: 240000000 Total: 505625000 Time: 3.0278sec Rate: 79266003.8158nums/sec [timo ] Numbers: 240000000 Total: 505625000 Time: 4.0631sec Rate: 59068204.3266nums/sec [voigt] Numbers: 240000000 Total: 505625000 Time: 4.5616sec Rate: 52613393.0285nums/sec [hopman] Numbers: 240000000 Total: 505625000 Time: 4.1248sec Rate: 58184194.4569nums/sec Press any key to continue . . . int ufast_utoa10(unsigned int value, char* str) { JOIN(N "5"), JOIN(N "6"), JOIN(N "7"), JOIN(N "8"), JOIN(N "9") JOIN2(N "5"), JOIN2(N "6"), JOIN2(N "7"), JOIN2(N "8"), JOIN2(N "9") JOIN3("5"), JOIN3("6"), JOIN3("7"), JOIN3("8"), JOIN3("9") JOIN(N "5"), JOIN(N "6"), JOIN(N "7"), JOIN(N "8"), JOIN(N "9") JOIN5("5"), JOIN5("6"), JOIN5("7"), JOIN5("8"), JOIN5("9") F10(N+50),F10(N+60),F10(N+70),F10(N+80),F10(N+90) static const short offsets[] = { F100(0), F100(100), F100(200), F100(300), F100(400), F100(500), F100(600), F100(700), F100(800), F100(900)}; static const char table1[][4] = { JOIN("") }; static const char table2[][4] = { JOIN2("") }; static const char table3[][4] = { JOIN3("") }; static const char table4[][5] = { JOIN4 }; static const char table5[][4] = { JOIN6 }; char *wstr; int remains[2]; unsigned int v2; if (value >= 100000000) { v2 = value / 10000; remains[0] = value - v2 * 10000; value = v2; v2 = value / 10000; remains[1] = value - v2 * 10000; value = v2; wstr = str; if (value >= 1000) { *(__int32 *) wstr = *(__int32 *) table4[value]; wstr += 4; } else { *(__int32 *) wstr = *(__int32 *) table5[value]; wstr += offsets[value]; } *(__int32 *) wstr = *(__int32 *) table4[remains[1]]; wstr += 4; *(__int32 *) wstr = *(__int32 *) table4[remains[0]]; wstr += 4; *wstr = 0; return (wstr - str); } else if (value >= 10000) { v2 = value / 10000; remains[0] = value - v2 * 10000; value = v2; wstr = str; if (value >= 1000) { *(__int32 *) wstr = *(__int32 *) table4[value]; wstr += 4; *(__int32 *) wstr = *(__int32 *) table4[remains[0]]; wstr += 4; *wstr = 0; return 8; } else { *(__int32 *) wstr = *(__int32 *) table5[value]; wstr += offsets[value]; *(__int32 *) wstr = *(__int32 *) table4[remains[0]]; wstr += 4; *wstr = 0; return (wstr - str); } } else { if (value >= 1000) { *(__int32 *) str = *(__int32 *) table4[value]; str += 4; *str = 0; return 4; } else if (value >= 100) { *(__int32 *) str = *(__int32 *) table3[value]; return 3; } else if (value >= 10) { *(__int16 *) str = *(__int16 *) table2[value]; str += 2; *str = 0; return 2; } else { *(__int16 *) str = *(__int16 *) table1[value]; return 1; } } } int ufast_itoa10(int value, char* str) { if (value < 0) { *(str++) = return ufast_utoa10(-value, str) + 1; } else return ufast_utoa10(value, str); } void ufast_test() { print_mode("[modp_ufast]"); std::string s; s.reserve(32); std::size_t total_length = 0; strtk::util::timer t; t.start(); char buf[128]; int len; for (int i = (-max_i2s / 2); i < (max_i2s / 2); ++i) { s.resize(ufast_itoa10(((i & 1) ? i : -i), const_cast<char*>(s.c_str()))); total_length += s.size(); s.resize(ufast_itoa10(max_i2s + i, const_cast<char*>(s.c_str()))); total_length += s.size(); s.resize(ufast_itoa10(randval[(max_i2s + i) & 1023], const_cast<char*>(s.c_str()))); total_length += s.size(); } t.stop(); printf("Numbers:%10lu\tTotal:%12lu\tTime:%8.4fsec\tRate:%14.4fnums/sec\n", static_cast<unsigned long>(3 * max_i2s), static_cast<unsigned long>(total_length), t.time(), (3.0 * max_i2s) / t.time()); }
HOPMAN_FAST - performance reference TM_CPP, TM_VEC - scalar and vector versions of Terje Mathisen algorithm WM_VEC - intrinsics implementation of Wojciech Mula AK_BW - word-at-a-time routine with a jump table that fills a buffer in reverse AK_FW - forward-stepping word-at-a-time routine with a jump table in assembly AK_UNROLLED - generic word-at-a-time routine that uses an unrolled loop
using namespace std; typedef __gnu_cxx::__vstring string_type; typedef string string_type; namespace detail { inline size_t num_digits(unsigned u) { struct { uint32_t count; uint32_t max; } static digits[32] ALIGN(64) = { { 1, 9 }, { 1, 9 }, { 1, 9 }, { 1, 9 }, { 2, 99 }, { 2, 99 }, { 2, 99 }, { 3, 999 }, { 3, 999 }, { 3, 999 }, { 4, 9999 }, { 4, 9999 }, { 4, 9999 }, { 4, 9999 }, { 5, 99999 }, { 5, 99999 }, { 5, 99999 }, { 6, 999999 }, { 6, 999999 }, { 6, 999999 }, { 7, 9999999 }, { 7, 9999999 }, { 7, 9999999 }, { 7, 9999999 }, { 8, 99999999 }, { 8, 99999999 }, { 8, 99999999 }, { 9, 999999999 }, { 9, 999999999 }, { 9, 999999999 }, { 10, UINT_MAX }, { 10, UINT_MAX } }; size_t l = u; __asm__ __volatile__ ( "bsrl %k0, %k0 \n\t" "shlq $32, %q1 \n\t" "movq %c2(,%0,8), %0\n\t" "cmpq %0, %q1 \n\t" "seta %b1 \n\t" "addl %1, %k0 \n\t" : "+r" (l), "+r"(u) : "i"(digits) : "cc" ); return l; __asm__ __volatile__ ( "bsr %0, %0;" : "+r" (l) ); return digits[l].count + ( u > digits[l].max ); size_t l = (u != 0) ? 31 - __builtin_clz(u) : 0; return digits[l].count + ( u > digits[l].max ); } inline unsigned msb_u32(unsigned x) { static const unsigned bval[] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 }; unsigned base = 0; if (x & (unsigned) 0xFFFF0000) { base += 32/2; x >>= 32/2; } if (x & (unsigned) 0x0000FF00) { base += 32/4; x >>= 32/4; } if (x & (unsigned) 0x000000F0) { base += 32/8; x >>= 32/8; } return base + bval[x]; } inline size_t num_digits(unsigned x) { static const unsigned powertable[] = { 0,10,100,1000,10000,100000,1000000,10000000,100000000, 1000000000 }; size_t lg_ten = msb_u32(x) * 1233 >> 12; size_t adjust = (x >= powertable[lg_ten]); return lg_ten + adjust; } struct CharBuffer { class reverse_iterator : public iterator<random_access_iterator_tag, char> { char* m_p; public: reverse_iterator(char* p) : m_p(p - 1) {} reverse_iterator operator++() { return --m_p; } reverse_iterator operator++(int) { return m_p--; } char operator*() const { return *m_p; } bool operator==( reverse_iterator it) const { return m_p == it.m_p; } bool operator!=( reverse_iterator it) const { return m_p != it.m_p; } difference_type operator-( reverse_iterator it) const { return it.m_p - m_p; } }; }; union PairTable { char c[2]; unsigned short u; } PACK table[100] ALIGN(1024) = { {{ {{ {{ {{ {{ {{ {{ {{ {{ {{ }; } struct progress_timer { clock_t c; progress_timer() : c(clock()) {} int elapsed() { return clock() - c; } ~progress_timer() { clock_t d = clock() - c; cout << d / CLOCKS_PER_SEC << "." << (((d * 1000) / CLOCKS_PER_SEC) % 1000 / 100) << (((d * 1000) / CLOCKS_PER_SEC) % 100 / 10) << (((d * 1000) / CLOCKS_PER_SEC) % 10) << " s" << endl; } }; namespace hopman_fast { static unsigned long cpu_cycles = 0; struct itostr_helper { static ALIGN(1024) unsigned out[10000]; itostr_helper() { for (int i = 0; i < 10000; i++) { unsigned v = i; char * o = (char*)(out + i); o[3] = v % 10 + o[2] = (v % 100) / 10 + o[1] = (v % 1000) / 100 + o[0] = (v % 10000) / 1000; if (o[0]) o[0] |= 0x30; else if (o[1] != else if (o[2] != else o[0] |= 0x00; } } }; unsigned itostr_helper::out[10000]; itostr_helper hlp_init; template <typename T> string_type itostr(T o) { typedef itostr_helper hlp; long first_clock = __rdtsc(); unsigned blocks[3], *b = blocks + 2; blocks[0] = o < 0 ? ~o + 1 : o; blocks[2] = blocks[0] % 10000; blocks[0] /= 10000; blocks[2] = hlp::out[blocks[2]]; if (blocks[0]) { blocks[1] = blocks[0] % 10000; blocks[0] /= 10000; blocks[1] = hlp::out[blocks[1]]; blocks[2] |= 0x30303030; b--; } if (blocks[0]) { blocks[0] = hlp::out[blocks[0] % 10000]; blocks[1] |= 0x30303030; b--; } char* f = ((char*)b); f += 3 - (*f >> 4); char* str = (char*)blocks; if (o < 0) *--f = str += 12; cpu_cycles += __rdtsc() - first_clock; return string_type(f, str); } unsigned long cycles() { return cpu_cycles; } void reset() { cpu_cycles = 0; } } namespace ak { namespace unrolled { static unsigned long cpu_cycles = 0; template <typename value_type> class Proxy { static const size_t MaxValueSize = 16; static inline char* generate(int value, char* buffer) { union { char* pc; unsigned short* pu; } b = { buffer + MaxValueSize }; unsigned u, v = value < 0 ? unsigned(~value) + 1 : value; *--b.pu = detail::table[v % 100].u; u = v; if ((v /= 100)) { *--b.pu = detail::table[v % 100].u; u = v; if ((v /= 100)) { *--b.pu = detail::table[v % 100].u; u = v; if ((v /= 100)) { *--b.pu = detail::table[v % 100].u; u = v; if ((v /= 100)) { *--b.pu = detail::table[v % 100].u; u = v; } } } } *(b.pc -= (u >= 10)) = return b.pc + (value >= 0); } static inline char* generate(unsigned value, char* buffer) { union { char* pc; unsigned short* pu; } b = { buffer + MaxValueSize }; unsigned u, v = value; *--b.pu = detail::table[v % 100].u; u = v; if ((v /= 100)) { *--b.pu = detail::table[v % 100].u; u = v; if ((v /= 100)) { *--b.pu = detail::table[v % 100].u; u = v; if ((v /= 100)) { *--b.pu = detail::table[v % 100].u; u = v; if ((v /= 100)) { *--b.pu = detail::table[v % 100].u; u = v; } } } } return b.pc + (u < 10); } public: static inline string_type convert(value_type v) { char buf[MaxValueSize]; long first_clock = __rdtsc(); char* p = generate(v, buf); char* e = buf + MaxValueSize; cpu_cycles += __rdtsc() - first_clock; return string_type(p, e); } }; string_type itostr(int i) { return Proxy<int>::convert(i); } string_type itostr(unsigned i) { return Proxy<unsigned>::convert(i); } unsigned long cycles() { return cpu_cycles; } void reset() { cpu_cycles = 0; } } namespace bw { static unsigned long cpu_cycles = 0; typedef uint64_t u_type; template <typename value_type> class Proxy { static inline void generate(unsigned v, size_t len, char* buffer) { u_type u = v; switch(len) { default: u = (v * 1374389535ULL) >> 37; *(uint16_t*)(buffer + 8) = detail::table[v -= 100 * u].u; case 8: v = (u * 1374389535ULL) >> 37; *(uint16_t*)(buffer + 6) = detail::table[u -= 100 * v].u; case 6: u = (v * 1374389535ULL) >> 37; *(uint16_t*)(buffer + 4) = detail::table[v -= 100 * u].u; case 4: v = (u * 167773) >> 24; *(uint16_t*)(buffer + 2) = detail::table[u -= 100 * v].u; case 2: *(uint16_t*)buffer = detail::table[v].u; case 0: return; case 9: u = (v * 1374389535ULL) >> 37; *(uint16_t*)(buffer + 7) = detail::table[v -= 100 * u].u; case 7: v = (u * 1374389535ULL) >> 37; *(uint16_t*)(buffer + 5) = detail::table[u -= 100 * v].u; case 5: u = (v * 1374389535ULL) >> 37; *(uint16_t*)(buffer + 3) = detail::table[v -= 100 * u].u; case 3: v = (u * 167773) >> 24; *(uint16_t*)(buffer + 1) = detail::table[u -= 100 * v].u; case 1: *buffer = v + 0x30; } } public: static inline string_type convert(bool neg, unsigned val) { char buf[16]; long first_clock = __rdtsc(); size_t len = detail::num_digits(val); buf[0] = char* e = buf + neg; generate(val, len, e); e += len; cpu_cycles += __rdtsc() - first_clock; return string_type(buf, e); } }; string_type itostr(int i) { return Proxy<int>::convert(i < 0, i < 0 ? unsigned(~i) + 1 : i); } string_type itostr(unsigned i) { return Proxy<unsigned>::convert(false, i); } unsigned long cycles() { return cpu_cycles; } void reset() { cpu_cycles = 0; } } namespace fw { static unsigned long cpu_cycles = 0; typedef uint32_t u_type; template <typename value_type> class Proxy { static inline void generate(unsigned v, size_t len, char* buffer) { uint16_t w; uint32_t u; __asm__ __volatile__ ( "jmp %*T%=(,%3,8) \n\t" "T%=: .quad L0%= \n\t" " .quad L1%= \n\t" " .quad L2%= \n\t" " .quad L3%= \n\t" " .quad L4%= \n\t" " .quad L5%= \n\t" " .quad L6%= \n\t" " .quad L7%= \n\t" " .quad L8%= \n\t" " .quad L9%= \n\t" " .quad L10%= \n\t" "L10%=: \n\t" " imulq $1441151881, %q0, %q1\n\t" " shrq $57, %q1 \n\t" " movw %c5(,%q1,2), %w2 \n\t" " imull $100000000, %1, %1 \n\t" " subl %1, %0 \n\t" " movw %w2, (%4) \n\t" "L8%=: \n\t" " imulq $1125899907, %q0, %q1\n\t" " shrq $50, %q1 \n\t" " movw %c5(,%q1,2), %w2 \n\t" " imull $1000000, %1, %1 \n\t" " subl %1, %0 \n\t" " movw %w2, -8(%4,%3) \n\t" "L6%=: \n\t" " imulq $429497, %q0, %q1 \n\t" " shrq $32, %q1 \n\t" " movw %c5(,%q1,2), %w2 \n\t" " imull $10000, %1, %1 \n\t" " subl %1, %0 \n\t" " movw %w2, -6(%4,%3) \n\t" "L4%=: \n\t" " imull $167773, %0, %1 \n\t" " shrl $24, %1 \n\t" " movw %c5(,%q1,2), %w2 \n\t" " imull $100, %1, %1 \n\t" " subl %1, %0 \n\t" " movw %w2, -4(%4,%3) \n\t" "L2%=: \n\t" " movw %c5(,%q0,2), %w2 \n\t" " movw %w2, -2(%4,%3) \n\t" "L0%=: jmp 1f \n\t" "L9%=: \n\t" " imulq $1801439851, %q0, %q1\n\t" " shrq $54, %q1 \n\t" " movw %c5(,%q1,2), %w2 \n\t" " imull $10000000, %1, %1 \n\t" " subl %1, %0 \n\t" " movw %w2, (%4) \n\t" "L7%=: \n\t" " imulq $43980466, %q0, %q1 \n\t" " shrq $42, %q1 \n\t" " movw %c5(,%q1,2), %w2 \n\t" " imull $100000, %1, %1 \n\t" " subl %1, %0 \n\t" " movw %w2, -7(%4,%3) \n\t" "L5%=: \n\t" " imulq $268436, %q0, %q1 \n\t" " shrq $28, %q1 \n\t" " movw %c5(,%q1,2), %w2 \n\t" " imull $1000, %1, %1 \n\t" " subl %1, %0 \n\t" " movw %w2, -5(%4,%3) \n\t" "L3%=: \n\t" " imull $6554, %0, %1 \n\t" " shrl $15, %1 \n\t" " andb $254, %b1 \n\t" " movw %c5(,%q1), %w2 \n\t" " leal (%1,%1,4), %1 \n\t" " subl %1, %0 \n\t" " movw %w2, -3(%4,%3) \n\t" "L1%=: \n\t" " addl $48, %0 \n\t" " movb %b0, -1(%4,%3) \n\t" "1: \n\t" : "+r"(v), "=&q"(u), "=&r"(w) : "r"(len), "r"(buffer), "i"(detail::table) : "memory", "cc" ); u_type u; switch(len) { default: u = (v * 1441151881ULL) >> 57; *(uint16_t*)(buffer) = detail::table[u].u; v -= u * 100000000; case 8: u = (v * 1125899907ULL) >> 50; *(uint16_t*)(buffer + len - 8) = detail::table[u].u; v -= u * 1000000; case 6: u = (v * 429497ULL) >> 32; *(uint16_t*)(buffer + len - 6) = detail::table[u].u; v -= u * 10000; case 4: u = (v * 167773) >> 24; *(uint16_t*)(buffer + len - 4) = detail::table[u].u; v -= u * 100; case 2: *(uint16_t*)(buffer + len - 2) = detail::table[v].u; case 0: return; case 9: u = (v * 1801439851ULL) >> 54; *(uint16_t*)(buffer) = detail::table[u].u; v -= u * 10000000; case 7: u = (v * 43980466ULL) >> 42; *(uint16_t*)(buffer + len - 7) = detail::table[u].u; v -= u * 100000; case 5: u = (v * 268436ULL) >> 28; *(uint16_t*)(buffer + len - 5) = detail::table[u].u; v -= u * 1000; case 3: u = (v * 6554) >> 16; *(uint16_t*)(buffer + len - 3) = detail::table[u].u; v -= u * 10; case 1: *(buffer + len - 1) = v + 0x30; } } public: static inline string_type convert(bool neg, unsigned val) { char buf[16]; long first_clock = __rdtsc(); size_t len = detail::num_digits(val); if (neg) buf[0] = char* e = buf + len + neg; generate(val, len, buf + neg); cpu_cycles += __rdtsc() - first_clock; return string_type(buf, e); } }; string_type itostr(int i) { return Proxy<int>::convert(i < 0, i < 0 ? unsigned(~i) + 1 : i); } string_type itostr(unsigned i) { return Proxy<unsigned>::convert(false, i); } unsigned long cycles() { return cpu_cycles; } void reset() { cpu_cycles = 0; } } } namespace wm { namespace vec { static unsigned long cpu_cycles = 0; template <typename value_type> class Proxy { static inline unsigned generate(unsigned v, char* buf) { static struct { unsigned short mul_10[8]; unsigned short div_const[8]; unsigned short shl_const[8]; unsigned char to_ascii[16]; } ALIGN(64) bits = { { 10, 10, 10, 10, 10, 10, 10, 10 }, { 8389, 5243, 13108, 0x8000, 8389, 5243, 13108, 0x8000 }, { 1 << (16 - (23 + 2 - 16)), 1 << (16 - (19 + 2 - 16)), 1 << (16 - 1 - 2), 1 << (15), 1 << (16 - (23 + 2 - 16)), 1 << (16 - (19 + 2 - 16)), 1 << (16 - 1 - 2), 1 << (15) }, { } }; unsigned x, y, l; x = (v * 1374389535ULL) >> 37; y = v; l = 0; if (x) { unsigned div = 0xd1b71759; unsigned mul = 55536; __m128i z, m, a, o; y -= 100 * x; z = _mm_cvtsi32_si128(x); m = _mm_load_si128((__m128i*)bits.mul_10); o = _mm_mul_epu32( z, _mm_cvtsi32_si128(div)); z = _mm_add_epi32( z, _mm_mul_epu32( _mm_cvtsi32_si128(mul), _mm_srli_epi64( o, 45) ) ); z = _mm_slli_epi64( _mm_shuffle_epi32( _mm_unpacklo_epi16(z, z), 5 ), 2 ); a = _mm_load_si128((__m128i*)bits.to_ascii); z = _mm_mulhi_epu16( _mm_mulhi_epu16( z, *(__m128i*)bits.div_const ), *(__m128i*)bits.shl_const ); z = _mm_sub_epi16( z, _mm_slli_epi64( _mm_mullo_epi16( m, z ), 16 ) ); z = _mm_add_epi8( _mm_packus_epi16( z, _mm_xor_si128(o, o) ), a ); x = __builtin_ctz( ~_mm_movemask_epi8( _mm_cmpeq_epi8( a, z ) ) ); l = 8 - x; uint64_t q = _mm_cvtsi128_si64(z) >> (x * 8); *(uint64_t*)buf = q; buf += l; x = 1; } v = (y * 6554) >> 16; l += 1 + (x | (v != 0)); *(unsigned short*)buf = 0x30 + ((l > 1) ? ((0x30 + y - v * 10) << 8) + v : y); return l; } public: static inline string_type convert(bool neg, unsigned val) { char buf[16]; long first_clock = __rdtsc(); buf[0] = unsigned len = generate(val, buf + neg); char* e = buf + len + neg; cpu_cycles += __rdtsc() - first_clock; return string_type(buf, e); } }; inline string_type itostr(int i) { return Proxy<int>::convert(i < 0, i < 0 ? unsigned(~i) + 1 : i); } inline string_type itostr(unsigned i) { return Proxy<unsigned>::convert(false, i); } unsigned long cycles() { return cpu_cycles; } void reset() { cpu_cycles = 0; } } } namespace tmn { namespace cpp { static unsigned long cpu_cycles = 0; template <typename value_type> class Proxy { static inline void generate(unsigned v, char* buffer) { unsigned const f1_10000 = (1 << 28) / 10000; unsigned tmplo, tmphi; unsigned lo = v % 100000; unsigned hi = v / 100000; tmplo = lo * (f1_10000 + 1) - (lo >> 2); tmphi = hi * (f1_10000 + 1) - (hi >> 2); unsigned mask = 0x0fffffff; unsigned shift = 28; for(size_t i = 0; i < 5; i++) { buffer[i + 0] = buffer[i + 5] = tmphi = (tmphi & mask) * 5; tmplo = (tmplo & mask) * 5; mask >>= 1; shift--; } } public: static inline string_type convert(bool neg, unsigned val) { long first_clock = __rdtsc(); char buf[16]; size_t len = detail::num_digits(val); char* e = buf + 11; generate(val, buf + 1); buf[10 - len] = len += neg; char* b = e - len; cpu_cycles += __rdtsc() - first_clock; return string_type(b, e); } }; string_type itostr(int i) { return Proxy<int>::convert(i < 0, i < 0 ? unsigned(~i) + 1 : i); } string_type itostr(unsigned i) { return Proxy<unsigned>::convert(false, i); } unsigned long cycles() { return cpu_cycles; } void reset() { cpu_cycles = 0; } } namespace vec { static unsigned long cpu_cycles = 0; template <typename value_type> class Proxy { static inline unsigned generate(unsigned val, char* buffer) { static struct { unsigned char mul_10[16]; unsigned char to_ascii[16]; unsigned char gather[16]; unsigned char shift[16]; } ALIGN(64) bits = { { 10,0,0,0,10,0,0,0,10,0,0,0,10,0,0,0 }, { { 3,5,6,7,9,10,11,13,14,15,0,0,0,0,0,0 }, { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 } }; unsigned u = val / 1000000; unsigned l = val - u * 1000000; __m128i x, h, f, m, n; n = _mm_load_si128((__m128i*)bits.mul_10); x = _mm_set_epi64x( l, u ); h = _mm_mul_epu32( x, _mm_set1_epi32(4294968) ); x = _mm_sub_epi64( x, _mm_srli_epi64( _mm_mullo_epi32( h, _mm_set1_epi32(1000) ), 32 ) ); f = _mm_set1_epi32((1 << 28) / 1000 + 1); m = _mm_srli_epi32( _mm_cmpeq_epi32(m, m), 4 ); x = _mm_shuffle_epi32( _mm_blend_epi16( x, h, 204 ), 177 ); f = _mm_sub_epi32( _mm_mullo_epi32(f, x), _mm_srli_epi32(x, 2) ); h = _mm_load_si128((__m128i*)bits.to_ascii); x = _mm_srli_epi32(f, 28); f = _mm_mullo_epi32( _mm_and_si128( f, m ), n ); x = _mm_or_si128( x, _mm_slli_epi32(_mm_srli_epi32(f, 28), 8) ); f = _mm_mullo_epi32( _mm_and_si128( f, m ), n ); x = _mm_or_si128( x, _mm_slli_epi32(_mm_srli_epi32(f, 28), 16) ); f = _mm_mullo_epi32( _mm_and_si128( f, m ), n ); x = _mm_or_si128( x, _mm_slli_epi32(_mm_srli_epi32(f, 28), 24) ); x = _mm_add_epi8( _mm_shuffle_epi8(x, *(__m128i*)bits.gather), h ); l = __builtin_ctz( ~_mm_movemask_epi8( _mm_cmpeq_epi8( h, x ) ) | (1 << 9) ); x = _mm_shuffle_epi8( x, _mm_add_epi8(*(__m128i*)bits.shift, _mm_set1_epi8(l) ) ); _mm_store_si128( (__m128i*)buffer, x ); return 10 - l; } public: static inline string_type convert(bool neg, unsigned val) { long first_clock = __rdtsc(); char arena[32]; char* buf = (char*)((uintptr_t)(arena + 16) & ~(uintptr_t)0xf); *(buf - 1)= unsigned len = generate(val, buf) + neg; buf -= neg; char* end = buf + len; cpu_cycles += __rdtsc() - first_clock; return string_type(buf, end); } }; string_type itostr(int i) { return Proxy<int>::convert(i < 0, i < 0 ? unsigned(~i) + 1 : i); } string_type itostr(unsigned i) { return Proxy<unsigned>::convert(false, i); } unsigned long cycles() { return cpu_cycles; } void reset() { cpu_cycles = 0; } } } bool fail(string in, string_type out) { cout << "failure: " << in << " => " << out << endl; return false; } stringstream ss; \ string_type s = n::itostr(x); \ ss << (long long)x; \ if (::strcmp(ss.str().c_str(), s.c_str())) { \ passed = fail(ss.str(), s); \ break; \ } passed = true; \ if (0 && passed) { \ char c = CHAR_MIN; \ do { \ TEST(c, x); \ } while (c++ != CHAR_MAX); \ if (!passed) cout << } \ if (0 && passed) { \ short c = numeric_limits<short>::min(); \ do { \ TEST(c, x); \ } while (c++ != numeric_limits<short>::max()); \ if (!passed) cout << } \ if (passed) { \ int c = numeric_limits<int>::min(); \ do { \ TEST(c, x); \ } while ((c += 100000) < numeric_limits<int>::max() - 100000); \ if (!passed) cout << } \ if (passed) { \ unsigned c = numeric_limits<unsigned>::max(); \ do { \ TEST(c, x); \ } while ((c -= 100000) > 100000); \ if (!passed) cout << } \ } if (passed) { \ static const int64_t limits[] = \ {0, 10, 100, 1000, 10000, 100000, \ 1000000, 10000000, 100000000, 1000000000, 10000000000ULL }; \ long passes = 0; \ cout << progress_timer t; \ uint64_t s = 0; \ if (do_time) { \ for (int n = 0; n < N1; n++) { \ int i = 0; \ while (i < N2) { \ int v = ((NM - i) % limits[N]) | (limits[N] / 10); \ int w = x::itostr(v).size() + \ x::itostr(-v).size(); \ i += w * mult; \ passes++; \ } \ s += i / mult; \ } \ } \ k += s; \ cout << N << " digits: " \ << s / double(t.elapsed()) * CLOCKS_PER_SEC/1000000 << " MB/sec, " << (x::cycles() / passes >> 1) << " clocks per pass "; \ x::reset(); \ } { if (do_test) test(n); if (do_time) time(n, 1); if (do_time) time(n, 2); \ if (do_time) time(n, 3); if (do_time) time(n, 4); if (do_time) time(n, 5); \ if (do_time) time(n, 6); if (do_time) time(n, 7); if (do_time) time(n, 8); \ if (do_time) time(n, 9); if (do_time) time(n, 10); } int N1 = 1, N2 = 500000000, NM = INT_MAX; int mult = 1; unsigned long long k = 0; int main(int argc, char** argv) { bool do_time = 1, do_test = 1; bool passed = true; series(hopman_fast) series(wm::vec) series(tmn::cpp) series(tmn::vec) series(ak::unrolled) series(ak::bw) series(ak::fw) return k; }
struct logarithm { static inline int log2(unsigned int value) { unsigned long index; if (!_BitScanReverse(&index, value)) { return 0; } return index + (value&(value - 1) ? 1 : 0); } static inline int numberDigits(unsigned int v) { static unsigned int const PowersOf10[] = { 0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 }; int t = (logarithm::log2(v) + 1) * 1233 >> 12; return 1 + t - (v < PowersOf10[t]); } };
template <int count> struct WriteHelper { inline static void WriteChar(char* buf, unsigned int value) { unsigned int div = value / 10; unsigned int rem = value % 10; buf[count - 1] = rem + WriteHelper<count - 1>::WriteChar(buf, div); } }; template <> struct WriteHelper<1> { inline static void WriteChar(char* buf, unsigned int value) { buf[0] = } }; static inline void WriteNumber(char* data, int len, unsigned int val) { switch (len) { case 1: WriteHelper<1>::WriteChar(data, static_cast<unsigned int>(val)); break; case 2: WriteHelper<2>::WriteChar(data, static_cast<unsigned int>(val)); break; case 3: WriteHelper<3>::WriteChar(data, static_cast<unsigned int>(val)); break; case 4: WriteHelper<4>::WriteChar(data, static_cast<unsigned int>(val)); break; case 5: WriteHelper<5>::WriteChar(data, static_cast<unsigned int>(val)); break; case 6: WriteHelper<6>::WriteChar(data, static_cast<unsigned int>(val)); break; case 7: WriteHelper<7>::WriteChar(data, static_cast<unsigned int>(val)); break; case 8: WriteHelper<8>::WriteChar(data, static_cast<unsigned int>(val)); break; case 9: WriteHelper<9>::WriteChar(data, static_cast<unsigned int>(val)); break; case 10: WriteHelper<10>::WriteChar(data, static_cast<unsigned int>(val)); break; } } static int Write(char* data, int val) { int len; if (val >= 0) { len = logarithm::numberDigits(val); WriteNumber(data, len, unsigned int(val)); return len; } else { unsigned int v(-val); len = logarithm::numberDigits(v); WriteNumber(data+1, len, v); data[0] = return len + 1; } }
/** Kabuki Toolkit @version 0.x @file ~/source/crabs/print_itos.cc @author Cale McCollough <cale.mccollough@gmail.com> @license Copyright (C) 2017-2018 Cale McCollough <calemccollough@gmail.com>; All right reserved (R). Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License [here](http: required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ sprintf_s (buffer, 24, "%u", value); *text_end = 0;\ printf ("\n Printed \"%s\" leaving value:\"%s\":%u",\ begin, buffer, (uint)strlen (buffer)); namespace _ { void PrintLine (char c) { std::cout << for (int i = 80; i > 0; --i) std::cout << c; } char* Print (uint32_t value, char* text, char* text_end) { static const uint32_t k10ToThe[]{ 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, ~(uint32_t)0 }; /** Lookup table of ASCII char pairs for 00, 01, ..., 99. To convert this algorithm to big-endian, flip the digit pair bytes. */ static const uint16_t kDigits00To99[100] = { 0x3030, 0x3130, 0x3230, 0x3330, 0x3430, 0x3530, 0x3630, 0x3730, 0x3830, 0x3930, 0x3031, 0x3131, 0x3231, 0x3331, 0x3431, 0x3531, 0x3631, 0x3731, 0x3831, 0x3931, 0x3032, 0x3132, 0x3232, 0x3332, 0x3432, 0x3532, 0x3632, 0x3732, 0x3832, 0x3932, 0x3033, 0x3133, 0x3233, 0x3333, 0x3433, 0x3533, 0x3633, 0x3733, 0x3833, 0x3933, 0x3034, 0x3134, 0x3234, 0x3334, 0x3434, 0x3534, 0x3634, 0x3734, 0x3834, 0x3934, 0x3035, 0x3135, 0x3235, 0x3335, 0x3435, 0x3535, 0x3635, 0x3735, 0x3835, 0x3935, 0x3036, 0x3136, 0x3236, 0x3336, 0x3436, 0x3536, 0x3636, 0x3736, 0x3836, 0x3936, 0x3037, 0x3137, 0x3237, 0x3337, 0x3437, 0x3537, 0x3637, 0x3737, 0x3837, 0x3937, 0x3038, 0x3138, 0x3238, 0x3338, 0x3438, 0x3538, 0x3638, 0x3738, 0x3838, 0x3938, 0x3039, 0x3139, 0x3239, 0x3339, 0x3439, 0x3539, 0x3639, 0x3739, 0x3839, 0x3939, }; static const char kMsbShift[] = { 4, 7, 11, 14, 17, 21, 24, 27, 30, }; if (!text) { return nullptr; } if (text >= text_end) { return nullptr; } uint16_t* text16; char digit; uint32_t scalar; uint16_t digits1and2, digits3and4, digits5and6, digits7and8; uint32_t comparator; for (int i = 0; i <= 21; ++i) { *(text + i) = } *(text + 21) = 0; char* begin = text; char buffer[256]; if (value < 10) { PRINTF ("\n Range:[0, 9] length:1 ") if (text + 1 >= text_end) { return nullptr; } *text++ = PRINT_PRINTED return text; } if (value < 100) { PRINTF ("\n Range:[10, 99] length:2 ") if (text + 2 >= text_end) { return nullptr; } *reinterpret_cast<uint16_t*> (text) = kDigits00To99[value]; PRINT_PRINTED return text + 2; } if (value >> 14) { if (value >> 27) { if (value >> 30) { PRINTF ("\n Range:[1073741824, 4294967295] length:10") Print10: if (text + 10 >= text_end) { return nullptr; } comparator = 100000000; digits1and2 = (uint16_t)(value / comparator); PRINTF ("\n digits1and2:%u", digits1and2) value -= digits1and2 * comparator; *reinterpret_cast<uint16_t*> (text) = kDigits00To99[digits1and2]; PRINT_PRINTED text += 2; goto Print8; } else { comparator = 1000000000; if (value >= comparator) { PRINTF ("\n Range:[100000000, 1073741823] length:10") goto Print10; } PRINTF ("\n Range:[134217727, 999999999] length:9") if (text + 9 >= text_end) { return nullptr; } comparator = 100000000; digit = (char)(value / comparator); *text++ = digit + PRINT_PRINTED value -= comparator * digit; goto Print8; } } else if (value >> 24) { comparator = k10ToThe[8]; if (value >= comparator) { PRINTF ("\n Range:[100000000, 134217728] length:9") if (text + 9 >= text_end) { return nullptr; } *text++ = PRINT_PRINTED value -= comparator; } PRINTF ("\n Range:[16777216, 9999999] length:8") if (text + 8 >= text_end) { return nullptr; } Print8: PRINTF ("\n Print8:") scalar = 10000; digits5and6 = (uint16_t)(value / scalar); digits1and2 = value - scalar * digits5and6; digits7and8 = digits5and6 / 100; digits3and4 = digits1and2 / 100; digits5and6 -= 100 * digits7and8; digits1and2 -= 100 * digits3and4; *reinterpret_cast<uint16_t*> (text + 6) = kDigits00To99[digits1and2]; PRINT_PRINTED *reinterpret_cast<uint16_t*> (text + 4) = kDigits00To99[digits3and4]; PRINT_PRINTED *reinterpret_cast<uint16_t*> (text + 2) = kDigits00To99[digits5and6]; PRINT_PRINTED *reinterpret_cast<uint16_t*> (text) = kDigits00To99[digits7and8]; PRINT_PRINTED return text + 8; } else if (value >> 20) { comparator = 10000000; if (value >= comparator) { PRINTF ("\n Range:[10000000, 16777215] length:8") if (text + 8 >= text_end) { return nullptr; } *text++ = PRINT_PRINTED value -= comparator; } else { PRINTF ("\n Range:[1048576, 9999999] length:7") if (text + 7 >= text_end) { return nullptr; } } scalar = 10000; digits5and6 = (uint16_t)(value / scalar); digits1and2 = value - scalar * digits5and6; digits7and8 = digits5and6 / 100; digits3and4 = digits1and2 / 100; digits5and6 -= 100 * digits7and8; digits1and2 -= 100 * digits3and4;; *reinterpret_cast<uint16_t*> (text + 5) = kDigits00To99[digits1and2]; PRINT_PRINTED *reinterpret_cast<uint16_t*> (text + 3) = kDigits00To99[digits3and4]; PRINT_PRINTED *reinterpret_cast<uint16_t*> (text + 1) = kDigits00To99[digits5and6]; PRINT_PRINTED *text = (char)digits7and8 + return text + 7; } else if (value >> 17) { comparator = 1000000; if (value >= comparator) { PRINTF ("\n Range:[100000, 1048575] length:7") if (text + 7 >= text_end) { return nullptr; } *text++ = PRINT_PRINTED value -= comparator; } else { PRINTF ("\n Range:[131072, 999999] length:6") if (text + 6 >= text_end) { return nullptr; } } Print6: scalar = 10000; digits5and6 = (uint16_t)(value / scalar); digits1and2 = value - scalar * digits5and6; digits7and8 = digits5and6 / 100; digits3and4 = digits1and2 / 100; digits5and6 -= 100 * digits7and8; digits1and2 -= 100 * digits3and4; text16 = reinterpret_cast<uint16_t*> (text + 6); *reinterpret_cast<uint16_t*> (text + 4) = kDigits00To99[digits1and2]; PRINT_PRINTED *reinterpret_cast<uint16_t*> (text + 2) = kDigits00To99[digits3and4]; PRINT_PRINTED *reinterpret_cast<uint16_t*> (text ) = kDigits00To99[digits5and6]; PRINT_PRINTED return text + 6; } else { if (value >= 100000) { PRINTF ("\n Range:[65536, 131071] length:6") goto Print6; } PRINTF ("\n Range:[10000, 65535] length:5") if (text + 5 >= text_end) { return nullptr; } digits5and6 = 10000; digit = (uint8_t)(value / digits5and6); value -= digits5and6 * digit; *text = digit + PRINT_PRINTED digits1and2 = (uint16_t)value; digits5and6 = 100; digits3and4 = digits1and2 / digits5and6; digits1and2 -= digits3and4 * digits5and6; *reinterpret_cast<uint16_t*> (text + 1) = kDigits00To99[digits3and4]; PRINT_PRINTED PRINTF ("\n digits1and2:%u", digits1and2) *reinterpret_cast<uint16_t*> (text + 3) = kDigits00To99[digits1and2]; PRINT_PRINTED return text + 5; } } digits1and2 = (uint16_t)value; if (value >> 10) { digits5and6 = 10000; if (digits1and2 >= digits5and6) { if (text + 5 >= text_end) { return nullptr; } PRINTF ("\n Range:[10000, 16383] length:5") *text++ = PRINT_PRINTED digits1and2 -= digits5and6; } else { PRINTF ("\n Range:[1024, 9999] length:4") if (text + 4 >= text_end) { return nullptr; } } digits5and6 = 100; digits3and4 = digits1and2 / digits5and6; digits1and2 -= digits3and4 * digits5and6; *reinterpret_cast<uint16_t*> (text ) = kDigits00To99[digits3and4]; PRINT_PRINTED *reinterpret_cast<uint16_t*> (text + 2) = kDigits00To99[digits1and2]; PRINT_PRINTED return text + 4; } else { if (text + 4 >= text_end) { return nullptr; } digits3and4 = 1000; if (digits1and2 >= digits3and4) { PRINTF ("\n Range:[1000, 1023] length:4") digits1and2 -= digits3and4; text16 = reinterpret_cast<uint16_t*> (text + 2); *text16-- = kDigits00To99[digits1and2]; PRINT_PRINTED *text16 = (((uint16_t) PRINT_PRINTED return text + 4; } PRINTF ("\n Range:[100, 999] length:3") digits1and2 = (uint16_t)value; digits3and4 = 100; digit = (char)(digits1and2 / digits3and4); digits1and2 -= digit * digits3and4; *text = digit + PRINT_PRINTED *reinterpret_cast<uint16_t*> (text + 1) = kDigits00To99[digits1and2]; PRINT_PRINTED return text + 3; } } }
// using namespace std; const char digit_pairs[201] = { "00010203040506070809" "10111213141516171819" "20212223242526272829" "30313233343536373839" "40414243444546474849" "50515253545556575859" "60616263646566676869" "70717273747576777879" "80818283848586878889" "90919293949596979899" }; void itostr(int n, char* c) { int sign = -(n<0); unsigned int val = (n^sign)-sign; int size; if(val>=10000) { if(val>=10000000) { if(val>=1000000000) { size=10; } else if(val>=100000000) { size=9; } else size=8; } else { if(val>=1000000) { size=7; } else if(val>=100000) { size=6; } else size=5; } } else { if(val>=100) { if(val>=1000) { size=4; } else size=3; } else { if(val>=10) { size=2; } else if(n==0) { c[0]= c[1] = return; } else size=1; } } size -= sign; if(sign) *c= c += size-1; while(val>=100) { int pos = val % 100; val /= 100; *(short*)(c-1)=*(short*)(digit_pairs+2*pos); c-=2; } while(val>0) { *c--= val /= 10; } c[size+1] = } void itostr(unsigned val, char* c) { int size; if(val>=10000) { if(val>=10000000) { if(val>=1000000000) size=10; else if(val>=100000000) size=9; else size=8; } else { if(val>=1000000) size=7; else if(val>=100000) size=6; else size=5; } } else { if(val>=100) { if(val>=1000) size=4; else size=3; } else { if(val>=10) size=2; else if (val==0) { c[0]= c[1] = return; } else size=1; } } c += size-1; while(val>=100) { int pos = val % 100; val /= 100; *(short*)(c-1)=*(short*)(digit_pairs+2*pos); c-=2; } while(val>0) { *c--= val /= 10; } c[size+1] = } void test() { bool foundmismatch = false; char str[16]; char compare[16]; for(int i = -1000000; i < 1000000; i++) { int random = rand(); itostr(random, str); itoa(random, compare, 10); if(strcmp(str, compare) != 0) { cout << "Mismatch found: " << endl; cout << "Generated: " << str << endl; cout << "Reference: " << compare << endl; foundmismatch = true; } } if(!foundmismatch) { cout << "No mismatch found!" << endl; } cin.get(); } void benchmark() { StopWatch stopwatch; stopwatch.setup("Timer"); stopwatch.reset(); stopwatch.start(); char str[16]; for(unsigned int i = 0; i < 2000000; i++) { itostr(i, str); } stopwatch.stop(); cin.get(); } int main( int argc, const char* argv[]) { benchmark(); }
namespace intrin { template<typename TIntegerValue> __forceinline auto tBitScanReverse(DWORD * out_index, TIntegerValue mask) -> std::enable_if_t<(std::is_integral<TIntegerValue>::value && sizeof(TIntegerValue) == 4), unsigned char> { return _BitScanReverse(out_index, mask); } template<typename TIntegerValue> __forceinline auto tBitScanReverse(DWORD * out_index, TIntegerValue mask) -> std::enable_if_t<(std::is_integral<TIntegerValue>::value && sizeof(TIntegerValue) == 8), unsigned char> { auto res = _BitScanReverse(out_index, (unsigned long)(mask >> 32)); if (res) { out_index += 32; return res; } return _BitScanReverse(out_index, (unsigned long)mask); return _BitScanReverse64(out_index, mask); } }
template<typename TChar> inline constexpr TChar ascii_0(); template<> inline constexpr char ascii_0() { return template<> inline constexpr wchar_t ascii_0() { return L template<typename TChar, typename TInt> inline constexpr TChar ascii_DEC(TInt d) { return (TChar)(ascii_0<TChar>() + d); }
static uint32 uint32_powers10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 }; static uint64 uint64_powers10[] = { 1ULL, 10ULL, 100ULL, 1000ULL, 10000ULL, 100000ULL, 1000000ULL, 10000000ULL, 100000000ULL, 1000000000ULL, 10000000000ULL, 100000000000ULL, 1000000000000ULL, 10000000000000ULL, 100000000000000ULL, 1000000000000000ULL, 10000000000000000ULL, 100000000000000000ULL, 1000000000000000000ULL, 10000000000000000000ULL }; template<typename TUint> inline constexpr const TUint * powers10(); template<> inline constexpr const uint32 * powers10() { return uint32_powers10; } template<> inline constexpr const uint64 * powers10() { return uint64_powers10; }
template<typename TChar, typename TUInt> __forceinline auto print_dec( TUInt u, TChar * & buffer) -> typename std::enable_if_t<std::is_unsigned<TUInt>::value> { if (u < 10) { *buffer++ = ascii_DEC<TChar>(u); } else { DWORD log2u; intrin::tBitScanReverse(&log2u, u); DWORD log10u = ((log2u + 1) * 77) >> 8; DWORD digits = log10u + (u >= powers10<TUInt>()[log10u]); buffer += digits; auto p = buffer; for (--digits; digits; --digits) { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } *--p = ascii_DEC<TChar>(u); } }
switch (digits) { case 10: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } case 9: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } case 8: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } case 7: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } case 6: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } case 5: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } case 4: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } case 3: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; } case 2: { auto x = u / 10, d = u - x * 10; *--p = ascii_DEC<TChar>(d); u = x; *--p = ascii_DEC<TChar>(u); break; } default: __assume(0); }
if(val >= 0) { div_t d2 = div(val,100); while(d2.quot) { COPYPAIR(it,2 * d2.rem); it-=2; d2 = div(d2.quot,100); } COPYPAIR(it,2*d2.rem); if(d2.quot<10) it++; } else { div_t d2 = div(val,100); while(d2.quot) { COPYPAIR(it,-2 * d2.rem); it-=2; d2 = div(d2.quot,100); } COPYPAIR(it,-2*d2.rem); if(d2.quot<=-10) it--; *it = }
namespace fs = boost::filesystem; fs::path myPath( strPath, fs::native );
for(struct { int a; float b; } loop = { 1, 2 }; ...; ...) { ... }
template<typename From, typename To> union union_cast { From from; To to; union_cast(From from) :from(from) { } To getTo() const { return to; } };
struct Foo { static int const value = 42; }; template<typename T> void f(T const&); int main() { f(Foo::value); f(+Foo::value); }
template<typename T> void f(T const& a, T const& b); int main() { int a[2]; int b[3]; f(a, b); f(+a, +b); }
int Function() try { return 42; } catch(...) { return -1; }
id<void()>::type *f; id<void(int)>::type *f(id<void()>::type *p); id<int[2]>::type *p = new int[10][2]; id<void(int)>::type C::*p = 0;
template<typename T> struct id { typedef T type; };
struct MutexLocker { MutexLocker(Mutex&); ~MutexLocker(); operator bool() const { return false; } private: Mutex &m; }; void someCriticalPath() { locked(myLocker) { } }
for(T i, j; can_continue(i, j); ++i, void(), ++j) do_code(i, j);
struct A { protected: int a; }; struct B : A { static int get(A &x) { return x.a; } }; struct C : A { };
void f(std::stack<int> &s) { struct pillager : std::stack<int> { static std::deque<int> &get(std::stack<int> &s) { return s.c; } }; std::deque<int> &d = pillager::get(s); }
struct A { protected: int a; }; struct B : A { static int get(A &x) { return x.*(&B::a); } }; struct C : A { };
void f(std::stack<int> &s) { struct pillager : std::stack<int> { static std::deque<int> &get(std::stack<int> &s) { return s.*(pillager::c); } }; std::deque<int> &d = pillager::get(s); }
void f(std::stack<int> &s) { struct pillager : std::stack<int> { using std::stack<int>::c; }; std::deque<int> &d = s.*(&pillager::c); }
template<typename Func1, typename Func2> class callable { Func1 *m_f1; Func2 *m_f2; public: callable(Func1 *f1, Func2 *f2):m_f1(f1), m_f2(f2) { } operator Func1*() { return m_f1; } operator Func2*() { return m_f2; } }; void foo(int i) { std::cout << "foo: " << i << std::endl; } void bar(long il) { std::cout << "bar: " << il << std::endl; } int main() { callable<void(int), void(long)> c(foo, bar); c(42); c(42L); }
struct Bar { void modify() {} } int main (void) { Bar().modify(); }
void foo (int) {} void foo (double) {} struct X { X (double d = 0.0) {} }; void foo (X) {} int main(void) { int i = 1; foo(i ? 0 : 0.0); X x; foo(i ? 0.0 : x); }
map<int, string> m; string& s = m[42]; if (s.empty()) { s.assign(...); } cout << s;
template <typename T> class Creator { friend void appear() { … } }; Creator<void> miracle; Creator<double> oops;
template <typename T> class Creator { friend void feed(Creator<T>*){ … } }; Creator<void> one; Creator<double> two;
template<typename T> struct sample { T dosomething() { return f<T>(); } };
vector<string> V; copy(istream_iterator<string>(cin), istream_iterator<string>(), back_inserter(V));
template <size_t X, size_t Y> struct bitfield { char left : X; char right : Y; };
SomeType t = u; SomeType t(u); SomeType t(); SomeType t; SomeType t(SomeType(u));
struct global { void main() { a = 1; b(); } int a; void b(){} } singleton;
string result = a==0 ? "zero" : a==1 ? "one" : a==2 ? "two" : 0;
int angle = (short)((+180+30)*65536/360) * 360/65536;
struct ref { int& r; ref(int& r):r(r){} }; int b; ref a(b); int c; *(int**)&a = &c;
struct A { void f() { } }; struct B : virtual A { void f() { cout << "B!"; } }; struct C : virtual A { }; struct D : B, C { void g() { f(); } };
unsigned int x; std::stringstream ss; ss << std::hex << "fffefffe"; ss >> x;
int main() { unsigned int x; std::stringstream ss; ss << std::hex << "fffefffe"; ss >> x; std::cout << static_cast<int>(x) << std::endl; }
std::string s = "0xfffefffe"; unsigned int x = std::stoul(s, nullptr, 16);
try { unsigned int x = lexical_cast<int>("0x0badc0de"); } catch(bad_lexical_cast &) { }
template<typename T2, typename T1> inline T2 lexical_cast(const T1 &in) { T2 out; std::stringstream ss; ss << in; ss >> out; return out; }
unsigned int x = lexical_cast<unsigned int>("0xdeadbeef");
using namespace std; int main() { string s = "abcd"; char * p; long n = strtol( s.c_str(), & p, 16 ); if ( * p != 0 ) { cout << "not a number" << endl; } else { cout << n << endl; } }
template <typename ElemT> struct HexTo { ElemT value; operator ElemT() const {return value;} friend std::istream& operator>>(std::istream& in, HexTo& out) { in >> std::hex >> out.value; return in; } };
uint32_t value = boost::lexical_cast<HexTo<uint32_t> >("0x2a");
using namespace std; int main() { string s = "fffefffe"; char * p; long n = strtoul( s.c_str(), & p, 16 ); if ( * p != 0 ) { cout << "not a number" << endl; } else { cout << n << endl; } }
using namespace std; int main() { string s = "-0x10002"; char * p; long n = strtol( s.c_str(), & p, 16 ); if ( * p != 0 ) { cout << "not a number" << endl; } else { cout << n << endl; } }
string hexString = "7FF"; int hexNumber; sscanf(hexString.c_str(), "%x", &hexNumber);
const char *hexString = "7FFEA5"; unsigned long hexNumber; sscanf(hexString, "%x", &hexNumber);
typedef unsigned int uint32; typedef signed int int32; class uint32_from_hex { uint32 value; public: operator uint32() const { return value; } friend std::istream& operator>>( std::istream& in, uint32_from_hex& outValue ) { in >> std::hex >> outValue.value; } }; class int32_from_hex { uint32 value; public: operator int32() const { return static_cast<int32>( value ); } friend std::istream& operator>>( std::istream& in, int32_from_hex& outValue ) { in >> std::hex >> outvalue.value; } }; uint32 material0 = lexical_cast<uint32_from_hex>( "0x4ad" ); uint32 material1 = lexical_cast<uint32_from_hex>( "4ad" ); uint32 material2 = lexical_cast<uint32>( "1197" ); int32 materialX = lexical_cast<int32_from_hex>( "0xfffefffe" ); int32 materialY = lexical_cast<int32_from_hex>( "fffefffe" );
string string_test = "80123456"; unsigned long x; signed long val; std::stringstream ss; ss << std::hex << string_test; ss >> x; val = (signed long)x;
using namespace System; template <typename NUM> NUM hexstr2num(String^ h) { NUM v=0; String^ k=L"0123456789ABCDEF"; short l=h->Length; char off; h=h->ToUpper(); if(h->Substring(0,1)!=L"H") {if(h->Substring(0,2)==L"0X") off=2;} else {off=1;} if(!off) throw; char dx=0; for(int i=l;i>off;i--) { if((dx=k->IndexOf(h->Substring(i-1,1)))>=0) {v+=dx<<((l-i)<<2);} else {throw;} } return v; }
struct base { virtual void f(); }; struct derived : base { void f() final; }; struct mostderived : derived { };
struct Base1 final { }; struct Derived1 : Base1 { };
struct Base2 { virtual void f() final; }; struct Derived2 : Base2 { void f(); };
class IAbstract { public: virtual void DoSomething() = 0; }; class CDerived : public IAbstract { void DoSomething() final { m_x = 1 ; } void Blah( void ) { DoSomething(); } };
struct A { void foo(); }; struct B : public A { void foo(); }; A * a = new B; a -> foo();
struct A { virtual void foo(); }; struct B : public A { virtual void foo(); }; struct C : public B { virtual void foo() final; }; struct D : public C { };
class FooInterface { public: virtual void DoSomething() = 0; private: virtual void DoSomethingImpl() = 0; }; class FooBase : public FooInterface { public: virtual void DoSomething() final { DoFirst(); DoSomethingImpl(); DoLast(); } private: virtual void DoSomethingImpl() { } void DoFirst(); void DoLast(); }; class FooDerived : public FooBase { private: virtual void DoSomethingImpl() { } };
struct A { virtual int foo(); }; struct B : A { int foo(); };
struct Foo { virtual void DoStuff(); } struct Bar : public Foo { void DoStuff() final; } struct Babar : public Bar { void DoStuff(); }
using namespace std; class Base { public: virtual void myfun() final { cout << "myfun() in Base"; } }; class Derived : public Base { void myfun() { cout << "myfun() in Derived\n"; } }; int main() { Derived d; Base &b = d; b.myfun(); return 0; }
class Base final { }; class Derived : public Base { }; int main() { Derived d; return 0; }
class IA { public: virtual int getNum() const = 0; }; class BaseA : public IA { public: inline virtual int getNum() const final {return ...}; }; class ImplA : public BaseA {...}; IA* pa = ...; ... ImplA* impla = static_cast<ImplA*>(pa); int n = impla->getNum();
int main() { std::clock_t start; double duration; start = std::clock(); duration = ( std::clock() - start ) / (double) CLOCKS_PER_SEC; std::cout<<"printf: "<< duration << }
typedef std::chrono::high_resolution_clock Clock; int main() { auto t1 = Clock::now(); auto t2 = Clock::now(); std::cout << "Delta t2-t1: " << std::chrono::duration_cast<std::chrono::nanoseconds>(t2 - t1).count() << " nanoseconds" << std::endl; }
clock_t startTime = clock(); doSomeOperation(); clock_t endTime = clock(); clock_t clockTicksTaken = endTime - startTime; double timeInSeconds = clockTicksTaken / (double) CLOCKS_PER_SEC;
using namespace std; int main() { clock_t cl; cl = clock(); _sleep(5167); cl = clock() - cl; _sleep(1000); cout << cl/(double)CLOCKS_PER_SEC << endl; return 0; }
using namespace std; void newline(); int main() { int msec = 0; int sec = 0; int min = 0; int hr = 0; for (;;) { newline(); if(msec == 1000) { ++sec; msec = 0; } if(sec == 60) { ++min; sec = 0; } if(min == 60) { ++hr; min = 0; } cout << hr << " : " << min << " : " << sec << " . " << msec << endl; ++msec; usleep(100000); } return 0; } void newline() { cout << "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"; }
int isCPP() { typedef int T; { struct T { int a[2]; }; return sizeof(T) == sizeof(struct T); } }
template<int> struct int_ { }; template<typename T> bool isCpp0xImpl(int_<T::X>*) { return true; } template<typename T> bool isCpp0xImpl(...) { return false; } enum A { X }; bool isCpp0x() { return isCpp0xImpl<A>(0); }
struct a { }; struct b { a a1, a2; }; struct c : a { static b constexpr (a()); }; bool isCpp0x() { return (sizeof c::a()) == sizeof(b); }
bool isCpp0xImpl(...) { return true; } bool isCpp0xImpl(char*) { return false; } bool isCpp0x() { return isCpp0xImpl(""); }
struct x { x(int z = 0):z(z) { } int z; } y(1); bool isCpp0x() { auto x(y); return (y.z == 1); }
struct Y { bool x1, x2; }; struct A { operator int(); template<typename T> operator T(); bool operator+(); } a; Y operator+(bool, A); bool isCpp0x() { return sizeof(&A::operator int&& +a) == sizeof(Y); }
template<typename T> bool g(long) { return false; } template<template<typename> class> bool g(int) { return true; } template<typename T> struct A { static bool doIt() { return g<A>(0); } }; bool isCpp0x() { return A<void>::doIt(); }
struct X { }; struct Y { X x1, x2; }; struct A { static X B(int); }; typedef A B; struct C : A { using ::B::B; static Y B(...); }; bool isCpp0x() { return (sizeof C::B(0)) == sizeof(Y); }
struct E { E(std::ostream &) { } }; template<typename T> bool isCpp0xImpl(E, T) { return true; } bool isCpp0xImpl(void*, int) { return false; } bool isCpp0x() { return isCpp0xImpl(std::cout, 0); }
bool isCpp0x() { const std::string s = u8"def"; return s == "def"; }
const unsigned reallyIsCpp0x=1; const unsigned isNotCpp0x=0; template<unsigned> struct isCpp0xImpl2 { typedef unsigned isNotCpp0x; }; template<typename> struct isCpp0xImpl { static unsigned const reallyIsCpp0x=0x8000; static unsigned const isNotCpp0x=0; }; bool isCpp0x() { unsigned const dummy=0x8000; return isCpp0xImpl<isCpp0xImpl2<dummy>>::reallyIsCpp0x > ::isNotCpp0x>::isNotCpp0x; } int main() { std::cout<<isCpp0x()<<std::endl; }
struct any { template<typename T> any(T const&) {} }; int move(any) { return 42; } bool is_int(int const&) { return true; } bool is_int(any) { return false; } bool isCpp0x() { std::vector<int> v; return !is_int(move(v)); }
template <class T> bool func(T&) {return true; } template <class T> bool func(...){return false;} bool isCpp0x() { int v = 1; return func<int&>(v); }
template <class T> bool cpp0X(T) {return true;} bool cpp0X(...){return false;} bool isCpp0x() { struct local {} var; return cpp0X(var); }
int IsCxx03() { auto x = (int *)0; return ((int)(x+1) != 1); }
struct T { bool flag; T() : flag(false) {} T(const T&) : flag(true) {} }; std::vector<T> test(1); bool is_cpp0x = !test[0].flag;
template< template< class > class > char f( int ); template< class > char (&f(...))[2]; template< class > class A { char i[ sizeof f< A >(0) ]; }; bool isCpp0x() { return sizeof( A<int> ) == 1; }
template<typename T> void test(T t) { t.first = false; } bool isCpp0x() { bool b = true; test( std::make_pair<bool&>(b, 0) ); return b; }
void f(int& x) { x += 2; } void f(double& x) { x += 2; }
struct Base { virtual Base& operator+=(int) = 0; }; struct X : Base { X(int n) : n_(n) { } X& operator+=(int n) { n_ += n; return *this; } int n_; }; struct Y : Base { Y(double n) : n_(n) { } Y& operator+=(int n) { n_ += n; return *this; } double n_; }; void f(Base& x) { x += 2; }
template <typename Duck> void do_ducky_stuff(const Duck& x) { x.walk().swim().quack(); } do_ducky_stuff(Vilified_Cygnet());
double a(double x) { return x + 2; } a(3.14); a(42);
void f() { typedef int Amount; Amount x = 13; x /= 2; std::cout << x * 1.1; }
void f() void f() { { typedef int Amount; typedef double Amount; Amount x = 13; Amount x = 13.0; x /= 2; x /= 2.0; std::cout << double(x) * 1.1; std::cout << x * 1.1; } }
template <typename Amount> void f() { Amount x = 13; x /= 2; std::cout << x * 1.1; }
template <typename Amount, typename Policy> void f() { Amount x = Policy::thirteen; x /= static_cast<Amount>(2); std::cout << traits<Amount>::to_double(x) * 1.1; }
|----------------------+--------------| | Form | Resolved at | |----------------------+--------------| | function overloading | compile-time | | operator overloading | compile-time | | templates | compile-time | | virtual methods | run-time | |----------------------+--------------|
|---------------+--------------| | early binding | compile-time | | late binding | run-time | |---------------+--------------|
|------------+---------------| | parametric | unconstrained | | ad-hoc | constrained | |------------+---------------|
myfunc1 :: Bool -> a -> a -> a myfunc1 c x y = if c then x else y
START Library MyLibrary; Book MyBook("My Book", "Me"); MyBook.Summarize(); MyBook += "Hello World"; MyBook += "HI"; MyBook.EditAuthor("Joe"); MyBook.EditName("Hello Book"); MyBook.Summarize(); FixedBookCollection<FairyTale> FBooks("Fairytale Books"); FairyTale MyTale("Tale", "Joe"); FBooks += MyTale; BookCollection E("E"); MyLibrary += E; MyLibrary += FBooks; MyLibrary.Summarize(); MyLibrary -= FBooks; MyLibrary.Summarize(); FixedSizeBookCollection<5> Collection("My Fixed Size Collection"); Book* Duplicate = MyLibrary.DuplicateBook(&MyBook); Duplicate->Summarize(); END
class Book; class Library; typedef std::vector<const Book*> Books; bool sContains(const std::string s, const char c){ return (s.find(c) != std::string::npos); } bool approve(std::string s){ return (!sContains(s, } template <class C> bool isBook(){ return (typeid(C) == typeid(Book) || std::is_base_of<Book, C>()); } template<class ClassToDuplicate> class DuplicatableClass{ public: ClassToDuplicate* Duplicate(ClassToDuplicate ToDuplicate){ return new ClassToDuplicate(ToDuplicate); } }; class Book : private DuplicatableClass<Book>{ friend class Library; friend struct BookCollection; public: Book(const char* Name, const char* Author) : name_(Name), author_(Author){} void operator+=(const char* Page){ pages_.push_back(Page); } void EditAuthor(const char* AuthorName){ if(approve(AuthorName)){ author_ = AuthorName; } else{ std::ostringstream errorMessage; errorMessage << "The author of the book " << name_ << " could not be changed as it was not approved"; throw std::exception(errorMessage.str().c_str()); } } void EditName(const char* Name){ if(approve(Name)){ name_ = Name; } else{ std::ostringstream errorMessage; errorMessage << "The name of the book " << name_ << " could not be changed as it was not approved"; throw std::exception(errorMessage.str().c_str()); } } virtual void Summarize(){ std::cout << "Book called " << name_ << "; written by " << author_ << ". Contains " << pages_.size() << ((pages_.size() == 1) ? " page:" : ((pages_.size() > 0) ? " pages:" : " pages")) << std::endl; if(pages_.size() > 0){ ListPages(std::cout); } } private: std::vector<const char*> pages_; const char* name_; const char* author_; void ListPages(std::ostream& output){ for(int i = 0; i < pages_.size(); ++i){ output << pages_[i] << std::endl; } } }; class FairyTale : public Book{ public: FairyTale(const char* Name, const char* Author) : Book(Name, Author){} }; struct BookCollection{ friend class Library; BookCollection(const char* Name) : name_(Name){} virtual void operator+=(const Book& Book)try{ Collection.push_back(&Book); }catch(const std::exception& e){ std::ostringstream errorMessage; errorMessage << e.what() << " - on line (approx.) " << (__LINE__ -3); throw std::exception(errorMessage.str().c_str()); } virtual void operator-=(const Book& Book){ for(int i = 0; i < Collection.size(); ++i){ if(Collection[i] == &Book){ Collection.erase(Collection.begin() + i); return; } } std::ostringstream errorMessage; errorMessage << "The Book " << Book.name_ << " was not found, and therefore cannot be erased"; throw std::exception(errorMessage.str().c_str()); } private: const char* name_; Books Collection; }; template<class FixedType> struct FixedBookCollection : public BookCollection{ FixedBookCollection(const char* Name) : BookCollection(Name){ if(!isBook<FixedType>()){ std::ostringstream errorMessage; errorMessage << "The type " << typeid(FixedType).name() << " cannot be initialized as a FixedBookCollection"; throw std::exception(errorMessage.str().c_str()); delete this; } } void operator+=(const FixedType& Book)try{ Collection.push_back(&Book); }catch(const std::exception& e){ std::ostringstream errorMessage; errorMessage << e.what() << " - on line (approx.) " << (__LINE__ -3); throw std::exception(errorMessage.str().c_str()); } void operator-=(const FixedType& Book){ for(int i = 0; i < Collection.size(); ++i){ if(Collection[i] == &Book){ Collection.erase(Collection.begin() + i); return; } } std::ostringstream errorMessage; errorMessage << "The Book " << Book.name_ << " was not found, and therefore cannot be erased"; throw std::exception(errorMessage.str().c_str()); } private: std::vector<const FixedType*> Collection; }; template<size_t Size> struct FixedSizeBookCollection : private std::array<const Book*, Size>{ FixedSizeBookCollection(const char* Name) : name_(Name){ if(Size < 1){ throw std::exception("A fixed size book collection cannot be smaller than 1"); currentPos = 0; } } void operator+=(const Book& Book)try{ if(currentPos + 1 > Size){ std::ostringstream errorMessage; errorMessage << "The FixedSizeBookCollection " << name_ << " throw std::exception(errorMessage.str().c_str()); } this->at(currentPos++) = &Book; }catch(const std::exception& e){ std::ostringstream errorMessage; errorMessage << e.what() << " - on line (approx.) " << (__LINE__ -3); throw std::exception(errorMessage.str().c_str()); } private: const char* name_; int currentPos; }; class Library : private std::vector<const BookCollection*>{ public: void operator+=(const BookCollection& Collection){ for(int i = 0; i < size(); ++i){ if((*this)[i] == &Collection){ std::ostringstream errorMessage; errorMessage << "The BookCollection " << Collection.name_ << " was already in the library, and therefore cannot be added"; throw std::exception(errorMessage.str().c_str()); } } push_back(&Collection); } void operator-=(const BookCollection& Collection){ for(int i = 0; i < size(); ++i){ if((*this)[i] == &Collection){ erase(begin() + i); return; } } std::ostringstream errorMessage; errorMessage << "The BookCollection " << Collection.name_ << " was not found, and therefore cannot be erased"; throw std::exception(errorMessage.str().c_str()); } Book* DuplicateBook(Book* Book)const{ return (Book->Duplicate(*Book)); } void Summarize(){ std::cout << "Library, containing " << size() << ((size() == 1) ? " book collection:" : ((size() > 0) ? " book collections:" : " book collections")) << std::endl; if(size() > 0){ for(int i = 0; i < size(); ++i){ std::cout << (*this)[i]->name_ << std::endl; } } } };
class Animal{ public: Animal(const char* Name) : name_(Name){ virtual void Speak(){ std::cout << "I am an animal called " << name_ << std::endl; } const char* name_; }; class Dog : public Animal{ public: Dog(const char* Name) : Animal(Name) { } void Speak(){ std::cout << "I am a dog called " << name_ << std::endl; } }; int main(void){ Animal Bob("Bob"); Dog Steve("Steve"); Bob.Speak(); Steve.Speak(); }
The Surgeon would begin to make an incision. The Hair Stylist would begin to cut someone The Actor would abruptly stop acting out of the current scene, awaiting directorial guidance.
for (unsigned x = 0; x < static_cast<unsigned>(bitmap->width); ++x) { *p++ = 0xAA; *p++ = 0xBB; *p++ = 0xCC; }
unsigned width(static_cast<unsigned>(bitmap->width)); for (unsigned x = 0; x < width; ++x) { *p++ = 0xAA; *p++ = 0xBB; *p++ = 0xCC; }
struct bitmap_t { long long width; } bitmap; int main(int argc, char** argv) { for (unsigned x = 0 ; x < static_cast<unsigned>(bitmap.width) ; ++x) { argv[x][0] = } return 0; }
struct bitmap_t { long long width; } bitmap; int main(int argc, char** argv) { const unsigned width = static_cast<unsigned>(bitmap.width); for (unsigned x = 0 ; x < width ; ++x) { argv[x][0] = } return 0; }
.file "unoptimized.cpp" .text .p2align 4,,15 .globl main .type main, @function main: .LFB0: .cfi_startproc .cfi_personality 0x3,__gxx_personality_v0 movl bitmap(%rip), %eax testl %eax, %eax je .L2 xorl %eax, %eax .p2align 4,,10 .p2align 3 .L3: mov %eax, %edx addl $1, %eax movq (%rsi,%rdx,8), %rdx movb $0, (%rdx) cmpl bitmap(%rip), %eax jb .L3 .L2: xorl %eax, %eax ret .cfi_endproc .LFE0: .size main, .-main .globl bitmap .bss .align 8 .type bitmap, @object .size bitmap, 8 bitmap: .zero 8 .ident "GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-16)" .section .note.GNU-stack,"",@progbits
.file "optimized.cpp" .text .p2align 4,,15 .globl main .type main, @function main: .LFB0: .cfi_startproc .cfi_personality 0x3,__gxx_personality_v0 movl bitmap(%rip), %eax testl %eax, %eax je .L2 subl $1, %eax leaq 8(,%rax,8), %rcx xorl %eax, %eax .p2align 4,,10 .p2align 3 .L3: movq (%rsi,%rax), %rdx addq $8, %rax cmpq %rcx, %rax movb $0, (%rdx) jne .L3 .L2: xorl %eax, %eax ret .cfi_endproc .LFE0: .size main, .-main .globl bitmap .bss .align 8 .type bitmap, @object .size bitmap, 8 bitmap: .zero 8 .ident "GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-16)" .section .note.GNU-stack,"",@progbits
$ diff -uN unoptimized.s optimized.s --- unoptimized.s 2015-11-24 16:11:55.837922223 +0000 +++ optimized.s 2015-11-24 16:12:02.628922941 +0000 @@ -1,4 +1,4 @@ - .file "unoptimized.cpp" + .file "optimized.cpp" .text .p2align 4,,15 .globl main @@ -10,16 +10,17 @@ movl bitmap(%rip), %eax testl %eax, %eax je .L2 + subl $1, %eax + leaq 8(,%rax,8), %rcx xorl %eax, %eax .p2align 4,,10 .p2align 3 .L3: - mov %eax, %edx - addl $1, %eax - movq (%rsi,%rdx,8), %rdx + movq (%rsi,%rax), %rdx + addq $8, %rax + cmpq %rcx, %rax movb $0, (%rdx) - cmpl bitmap(%rip), %eax - jb .L3 + jne .L3 .L2: xorl %eax, %eax ret
for (unsigned x = static_cast<unsigned>(bitmap->width);x > 0; x--) { *p++ = 0xAA; *p++ = 0xBB; *p++ = 0xCC; }
for (unsigned x = static_cast<unsigned>(bitmap->width); x-- > 0;) { *p++ = 0xAA; *p++ = 0xBB; *p++ = 0xCC; }
const std::size_t n = 0x80000000ull; bitmap->width = n; static unsigned char d[n*3]; std::size_t i=0; for (unsigned x = 0; x < static_cast<unsigned>(bitmap->width); ++x) { d[i++] = 0xAA; d[i++] = 0xBB; d[i++] = 0xCC; }
const std::size_t n = 0x80000000ull; bitmap->width = n; static unsigned char d[n*3]; std::size_t i=0; unsigned width(static_cast<unsigned>(bitmap->width)); for (unsigned x = 0; x < width; ++x) { d[i++] = 0xAA; d[i++] = 0xBB; d[i++] = 0xCC; }
for (unsigned int x = 0, n = static_cast<unsigned>(bitmap->width); x < n; ++x) { *p++ = 0xAA; *p++ = 0xBB; *p++ = 0xCC; }
struct Bitmap_line { int blah; unsigned int width; Bitmap_line(unsigned int w) { blah = 0; width = w; } }; int main(int argc, char* argv[]) { unsigned int size = (4 * 1024 * 1024) / 3 * 3; unsigned char* pointer = (unsigned char*)malloc(size); memset(pointer, 0, size); std::unique_ptr<Bitmap_line> bitmap(new Bitmap_line(size / 3)); clock_t told = clock(); for (int iter = 0; iter < 10000; iter++) { unsigned char* p = pointer; for (unsigned x = 0; x < static_cast<unsigned>(bitmap->width); ++x) { *p++ = 0xAA; *p++ = 0xBB; *p++ = 0xCC; } } for (int iter = 0; iter < 10000; iter++) { unsigned char* p = pointer; unsigned x = 0; for (const unsigned n = static_cast<unsigned>(bitmap->width) - 4; x < n; x += 4) { *(int64_t*)p = 0xBBAACCBBAACCBBAALL; p += 8; *(int32_t*)p = 0xCCBBAACC; p += 4; } for (const unsigned n = static_cast<unsigned>(bitmap->width); x < n; ++x) { *p++ = 0xAA; *p++ = 0xBB; *p++ = 0xCC; } } double ms = 1000.0 * double(clock() - told) / CLOCKS_PER_SEC; printf("time %0.3f\n", ms); { unsigned char* p = pointer; for (unsigned x = 0, n = static_cast<unsigned>(bitmap->width); x < n; ++x) { if ((*p++ != 0xAA) || (*p++ != 0xBB) || (*p++ != 0xCC)) { printf("EEEEEEEEEEEEERRRRORRRR!!!\n"); abort(); } } } return 0; }
for (unsigned x = 0; x < static_cast<unsigned>(bitmap->width); ++x)
unsigned width(static_cast<unsigned>(bitmap->width)); for (unsigned x = 0; x<width ; ++x)
Array<> myDynamicArray; myDynamicArray.resize(N); ...
class A { public: A() { std::cerr << "Empty constructor" << std::endl; } A(const A&) { std::cerr << "Copy constructor" << std::endl; } A(const char* str) { std::cerr << "char constructor: " << str << std::endl; } ~A() { std::cerr << "destructor" << std::endl; } }; void direct() { std::cerr << std::endl << "TEST: " << __FUNCTION__ << std::endl; A a(__FUNCTION__); static_cast<void>(a); } void assignment() { std::cerr << std::endl << "TEST: " << __FUNCTION__ << std::endl; A a = A(__FUNCTION__); static_cast<void>(a); } void prove_copy_constructor_is_called() { std::cerr << std::endl << "TEST: " << __FUNCTION__ << std::endl; A a(__FUNCTION__); A b = a; static_cast<void>(b); } int main() { direct(); assignment(); prove_copy_constructor_is_called(); return 0; }
TEST: direct char constructor: direct destructor TEST: assignment char constructor: assignment destructor TEST: prove_copy_constructor_is_called char constructor: prove_copy_constructor_is_called Copy constructor destructor destructor
using namespace std; class Thing { public: Thing(); }; Thing::Thing() { cout << "Hi" << endl; } int main() { Thing myThing; }
class Thing { public: Thing(const char*){puts(__FUNCTION__ );} Thing(const Thing&){puts(__FUNCTION__ );} ~Thing(){puts(__FUNCTION__);} }; int main(int , const char** ) { Thing myThing = Thing("asdf"); }
void f() { } struct S {}; int main() { int x = 1; const char * p1 = x == 1 ? "foo" : throw S(); const char * p2 = x == 1 ? "foo" : f(); }
template<typename T> struct PrintType; int main() { PrintType<decltype(throw "error")> a; }
cc_binary( name = "<project name>", srcs = ["<project name>.cc"], deps = [ " ] )
mkdir /usr/local/include/tf cp -r bazel-genfiles/ /usr/local/include/tf/ cp -r tensorflow /usr/local/include/tf/ cp -r third_party /usr/local/include/tf/ cp -r bazel-bin/libtensorflow_cc.so /usr/local/lib/
g++ -std=c++11 -o tf_example \ -I/usr/local/include/tf \ -I/usr/local/include/eigen3 \ -g -Wall -D_DEBUG -Wshadow -Wno-sign-compare -w \ -L/usr/local/lib/libtensorflow_cc \ `pkg-config --cflags --libs protobuf` -ltensorflow_cc tf_example.cpp
tensorflow tensorflow/bazel-tensorflow/external/eigen_archive tensorflow/bazel-tensorflow/external/protobuf_archive/src tensorflow/bazel-genfiles
tensorflow/bazel-bin/tensorflow/libtensorflow_framework.so (unused if you build with --config=monolithic) tensorflow/bazel-bin/tensorflow/libtensorflow_cc.so
