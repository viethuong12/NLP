do putStrLn "What is your name?" name <- getLine putStrLn ("Welcome, " ++ name ++ "!")
parseExpr = parseString <|> parseNumber parseString = do char x <- many (noneOf "\"") char return (StringValue x) parseNumber = do num <- many1 digit return (NumberValue (read num))
let AsyncHttp(url:string) = async { let req = WebRequest.Create(url) let! rsp = req.GetResponseAsync() use stream = rsp.GetResponseStream() use reader = new System.IO.StreamReader(stream) return reader.ReadToEnd() }
putStrLn "What is your name?" >>= (\_ -> getLine) >>= (\name -> putStrLn ("Welcome, " ++ name ++ "!"))
fmap :: (a -> b) -> (Wrapped a -> Wrapped b) fmap f (Wrap x) = Wrap (f x)
bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b) bind f (Wrap x) = f x
class Monad m where return :: a -> m a (>>=) :: forall a b . m a -> (a -> m b) -> m b
instance Monad [ ] where [] >>= k = [] (x:xs) >>= k = k x ++ (xs >>= k) return x = [x] instance Monad Maybe where Just x >>= k = k x Nothing >>= k = Nothing return x = Just x
consolestate FinalConsole = print(input(print(myconsole, "Hello, what
consolestate FinalConsole = myconsole: print("Hello, what input(): print("hello, %inputbuffer%!");
f(<x, messages>) := <x, messages "called f. "> g(<x, messages>) := <x, messages "called g. "> wrap(x) := <x, "">
f(g(wrap(x))) = f(g(<x, "">)) = f(<x, "called g. ">) = <x, "called g. called f. ">
f(x) := <x, "called f. "> g(x) := <x, "called g. "> wrap(x) := <x, "">
f(g(wrap(x))) = f(g(<x, "">)) = f(<<x, "">, "called g. ">) = <<<x, "">, "called g. ">, "called f. ">
feed(f, feed(g, wrap(x))) = feed(f, feed(g, <x, "">)) = feed(f, <x, "called g. ">) = <x, "called g. called f. ">
feed(f, <x, messages>) := let <y, message> = f(x) in <y, messages message>
feed(f, wrap(x)) = feed(f, <x, "">) = let <y, message> = f(x) in <y, "" message> = let <y, message> = <x, "called f. "> in <y, "" message> = <x, "" "called f. "> = <x, "called f. "> = f(x)
feed(wrap, <x, messages>) = let <y, message> = wrap(x) in <y, messages message> = let <y, message> = <x, ""> in <y, messages message> = <x, messages ""> = <x, messages>
feed(h, <x, messages>) = let <y, message> = h(x) in <y, messages message> = let <y, message> = feed(f, g(x)) in <y, messages message> = let <y, message> = feed(f, <x, "called g. ">) in <y, messages message> = let <y, message> = let <z, msg> = f(x) in <z, "called g. " msg> in <y, messages message> = let <y, message> = let <z, msg> = <x, "called f. "> in <z, "called g. " msg> in <y, messages message> = let <y, message> = <x, "called g. " "called f. "> in <y, messages message> = <x, messages "called g. " "called f. "> = feed(f, <x, messages "called g. ">) = feed(f, feed(g, <x, messages>))
{- newtype Id t = Id t instance Monad Id where return :: t -> Id t return = Id (=<<) :: (a -> Id b) -> Id a -> Id b f =<< (Id x) = f x
(.) :: (b -> c) -> (a -> b) -> (a -> c) f . g = \ x -> f $ g x infixr 9 .
f . id = f :: c -> d Right identity id . g = g :: b -> c Left identity (f . g) . h = f . (g . h) :: a -> d Associativity
{- class Functor (f :: * -> *) where map :: (a -> b) -> (f a -> f b)
map id = id :: f t -> f t Identity map f . map g = map (f . g) :: f a -> f c Composition / short cut fusion
class Functor m => Monad m where return :: t -> m t (=<<) :: (a -> m b) -> m a -> m b infixr 1 =<<
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c) f <=< g = \ x -> f =<< g x infixr 1 <=<
return <=< g = g :: b -> m c Left identity f <=< return = f :: c -> m d Right identity (f <=< g) <=< h = f <=< (g <=< h) :: a -> m d Associativity
return :: t -> Id t = id :: t -> t (=<<) :: (a -> Id b) -> Id a -> Id b = ($) :: (a -> b) -> a -> b (<=<) :: (b -> Id c) -> (a -> Id b) -> (a -> Id c) = (.) :: (b -> c) -> (a -> b) -> (a -> c)
newtype Id t = Id t instance Functor Id where map :: (a -> b) -> Id a -> Id b map f (Id x) = Id (f x) instance Monad Id where return :: t -> Id t return = Id (=<<) :: (a -> Id b) -> Id a -> Id b f =<< (Id x) = f x
instance Functor Maybe where map :: (a -> b) -> (Maybe a -> Maybe b) map f (Just x) = Just (f x) map _ Nothing = Nothing instance Monad Maybe where return :: t -> Maybe t return = Just (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b f =<< (Just x) = f x _ =<< Nothing = Nothing
toNat :: Int -> Maybe Nat toNat i | i >= 0 = Just (Nat i) | otherwise = Nothing
(-?) :: Nat -> Nat -> Maybe Nat (Nat n) -? (Nat m) = toNat (n - m) infixl 6 -?
(++) :: [t] -> [t] -> [t] (x : xs) ++ ys = x : xs ++ ys [] ++ ys = ys infixr 5 ++
instance Functor [] where map :: (a -> b) -> ([a] -> [b]) map f (x : xs) = f x : map f xs map _ [] = [] instance Monad [] where return :: t -> [t] return = (: []) (=<<) :: (a -> [b]) -> [a] -> [b] f =<< (x : xs) = f x ++ f =<< xs _ =<< [] = []
divisors :: Integral t => t -> [t] divisors n = filter (`divides` n) [2 .. n - 1] divides :: Integral t => t -> t -> Bool (`divides` n) = (== 0) . (n `rem`)
class Applicative m => Monad m where (>>=) :: forall a b. m a -> (a -> m b) -> m b (>>) :: forall a b. m a -> m b -> m b m >> k = m >>= \ _ -> k {- return :: a -> m a return = pure fail :: String -> m a fail s = errorWithoutStackTrace s
class Functor f class Functor p => Applicative p class Applicative m => Monad m
for a in (1, ..., 10) for b in (1, ..., 10) p <- a * b if even(p) yield p
do a <- [1 .. 10] b <- [1 .. 10] let p = a * b guard (even p) return p
[p | a <- [1 .. 10], b <- [1 .. 10], let p = a * b, even p]
[1 .. 10] >>= (\ a -> [1 .. 10] >>= (\ b -> let p = a * b in guard (even p) >> return p ) )
let x = v in e = (\ x -> e) $ v = v & (\ x -> e) do r <- m; c = (\ r -> c) =<< m = m >>= (\ r -> c)
(&) :: a -> (a -> b) -> b (&) = flip ($) infixl 0 &
guard :: Additive m => Bool -> m () guard True = return () guard False = fail
class Monad m => Additive m where fail :: m t (<|>) :: m t -> m t -> m t infixl 3 <|> instance Additive Maybe where fail = Nothing Nothing <|> m = m m <|> _ = m instance Additive [] where fail = [] (<|>) = (++)
fail <|> l = l k <|> fail = k (k <|> l) <|> m = k <|> (l <|> m)
newtype State st t = State { stateProc :: st -> (t, st) } instance Functor (State st) where map :: (a -> b) -> ((State st) a -> (State st) b) map f (State p) = State $ \ s0 -> let (x, s1) = p s0 in (f x, s1) instance Monad (State st) where return :: t -> (State st) t return x = State $ \ s -> (x, s) (=<<) :: (a -> (State st) b) -> (State st) a -> (State st) b f =<< (State p) = State $ \ s0 -> let (x, s1) = p s0 in stateProc (f x) s1
run :: State st t -> st -> (t, st) run = stateProc eval :: State st t -> st -> t eval = fst . run exec :: State st t -> st -> st exec = snd . run
{- class Monad m => Stateful m st | m -> st where get :: m st put :: st -> m ()
instance Stateful (State st) st where get :: State st st get = State $ \ s -> (s, s) put :: st -> State st () put s = State $ \ _ -> ((), s)
modify :: Stateful m st => (st -> st) -> m () modify f = do s <- get put (f s) gets :: Stateful m st => (st -> t) -> m t gets f = do s <- get return (f s)
let s0 = 34 s1 = (+ 1) s0 n = (* 12) s1 s2 = (+ 7) s1 in (show n, s2)
(flip run) 34 (do modify (+ 1) n <- gets (* 12) modify (+ 7) return (show n) )
(flip run) 34 (modify (+ 1) >> gets (* 12) >>= (\ n -> modify (+ 7) >> return (show n) ) )
do { do { do { r1 <- do { x <- m; r0 <- m; r0 <- m; = do { = r1 <- f r0; f r0 r1 <- f x; g r1 }; g r1 } g r1 } } }
for :: Monad m => (a -> m b) -> [a] -> m () for f = foldr ((>>) . f) (return ()) while :: Monad m => m Bool -> m t -> m () while c m = do b <- c if b then m >> while c m else return () forever :: Monad m => m t forever m = m >> forever m
getChar :: IO Char putChar :: Char -> IO () readFile :: FilePath -> IO String writeFile :: FilePath -> String -> IO () hSetBuffering :: Handle -> BufferMode -> IO () hTell :: Handle -> IO Integer . . . . . .
Tmor : HomC(X, Y) -> HomD(Tobj(X), Tobj(Y)) map :: (a -> b) -> (f a -> f b)
Tmor Tobj T(id) = id : T(X) -> T(X) Identity T(f) . T(g) = T(f . g) : T(X) -> T(Z) Composition
(_)* : Hom(X, T(Y)) -> Hom(T(X), T(Y)) (=<<) :: (a -> m b) -> (m a -> m b)
f .T g = f* . g : X -> T(Z) f <=< g = (f =<<) . g :: a -> m c
eta .T g = g : Y -> T(Z) Left identity return <=< g = g :: b -> m c f .T eta = f : Z -> T(U) Right identity f <=< return = f :: c -> m d (f .T g) .T h = f .T (g .T h) : X -> T(U) Associativity (f <=< g) <=< h = f <=< (g <=< h) :: a -> m d
eta .T g = g eta* . g = g By definition of .T eta* . g = id . g forall f. id . f = f eta* = id forall f g h. f . h = g . h ==> f = g (f .T g) .T h = f .T (g .T h) (f* . g)* . h = f* . (g* . h) By definition of .T (f* . g)* . h = f* . g* . h . is associative (f* . g)* = f* . g* forall f g h. f . h = g . h ==> f = g
eta* = id : T(X) -> T(X) Left identity (return =<<) = id :: m t -> m t f* . eta = f : Z -> T(U) Right identity (f =<<) . return = f :: c -> m d (f* . g)* = f* . g* : T(X) -> T(Z) Associativity (((f =<<) . g) =<<) = (f =<<) . (g =<<) :: m a -> m c
eta : Id -> T return :: t -> f t mu : T . T -> T join :: f (f t) -> f t
mu . T(mu) = mu . mu : T . T . T -> T . T Associativity join . map join = join . join :: f (f (f t)) -> f t mu . T(eta) = mu . eta = id : T -> T Identity join . map return = join . return = id :: f t -> f t
class Functor m => Monad m where return :: t -> m t join :: m (m t) -> m t
instance Monad Maybe where return = Just join (Just m) = m join Nothing = Nothing
concat :: [[a]] -> [a] concat (x : xs) = x ++ concat xs concat [] = []
instance Monad [] where return :: t -> [t] return = (: []) (=<<) :: (a -> [b]) -> ([a] -> [b]) (f =<<) = concat . map f
mu = id* : T . T -> T join = (id =<<) :: m (m t) -> m t
f* = mu . T(f) : T(X) -> T(Y) (f =<<) = join . map f :: m a -> m b
$ hoogle "a -> (a -> a) -> [a]" Prelude iterate :: (a -> a) -> a -> [a]
Joeri van Eekelen, et al. | Wikibooks Published in 2012, 597 pages
-- | A natural transformations between two -- -- > fmap f . eta g == eta g . fmap f -- -- Neat fact: the type system actually guarantees this law. -- newtype f :-> g = Natural { eta :: forall x. f x -> g x }
listToMaybe :: [] :-> Maybe listToMaybe = Natural go where go [] = Nothing go (x:_) = Just x maybeToList :: Maybe :-> [] maybeToList = Natural go where go Nothing = [] go (Just x) = [x] reverse reverse
newtype Identity a = Identity { runIdentity :: a } instance Functor Identity where fmap f (Identity a) = Identity (f a)
newtype Compose f g a = Compose { getCompose :: f (g a) } -- | The composition of two instance (Functor f, Functor g) => Functor (Compose f g) where fmap f (Compose fga) = Compose (fmap (fmap f) fga)
Compose f Identity a ~= f (Identity a) -- newtype Compose f g a = Compose (f (g a)) ~= f a -- newtype Identity a = Identity a Q.E.D.
~t :: m * -> m * -> m * and a neutral value for m *
putStrLn (show $ 1 + 1) putStrLn $ show (1 + 1) putStrLn $ show $ 1 + 1
infixr 9 . (.) :: (b -> c) -> (a -> b) -> (a -> c) (f . g) x = f (g x) infixr 0 $ ($) :: (a -> b) -> a -> b f $ x = f x
Prelude> head (tail "asdf") Prelude> head $ tail "asdf"
Prelude> let second x = head $ tail x Prelude> second "asdf" Prelude> let second = head . tail Prelude> second "asdf"
Prelude> let third x = head $ tail $ tail x Prelude> map third ["asdf", "qwer", "1234"] "de3"
Prelude> map (\x -> head $ tail $ tail x) ["asdf", "qwer", "1234"] "de3"
Prelude> map (head . tail . tail) ["asdf", "qwer", "1234"] "de3"
-- | Function composition. {- -- Make sure it has TWO args only on the left, so that it inlines -- when applied to two functions, even if there is no final argument (.) :: (b -> c) -> (a -> b) -> a -> c (.) f g = \x -> f (g x)
-- | Application operator. This operator is redundant, since ordinary -- application @(f x)@ means the same as @(f -- low, right-associative binding precedence, so it sometimes allows -- parentheses to be omitted; for example: -- -- > f $ g $ h x = f (g (h x)) -- -- It is also useful in higher-order situations, such as @ -- or @ {- ($) :: (a -> b) -> a -> b f $ x = f x
double x = x * 2 triple x = x * 3 times6 = double . triple :i times6 times6 :: Num c => c -> c
factorCount number = factorCount where square = sqrt $ fromIntegral number isquare = floor square factorCount | fromIntegral candidate > sqrt = count | number `mod` candidate == 0 = factorCount | otherwise = factorCount nextTriangle index triangle | factorCount triangle > 1000 = triangle | otherwise = nextTriangle (index + 1) (triangle + index + 1) main = print $ nextTriangle 1 1
$ time ./so 842161320 real 0m7.954s user 0m7.944s sys 0m0.004s
factorCount number = factorCount where square = sqrt $ fromIntegral number isquare = floor square factorCount factorCount where go candidate count | candidate > sqrt = count | number `rem` candidate == 0 = go (candidate + 1) (count + 2) | otherwise = go (candidate + 1) count nextTriangle index triangle | factorCount triangle > 1000 = triangle | otherwise = nextTriangle (index + 1) (triangle + index + 1) main = print $ nextTriangle 1 1
import Control.Applicative import Control.Monad import Data.Either import Math.NumberTheory.Powers.Squares isInt :: RealFrac c => c -> Bool isInt = (==) <$> id <*> fromInteger . round intSqrt :: (Integral a) => a -> Int --intSqrt = fromIntegral . floor . sqrt . fromIntegral intSqrt = fromIntegral . integerSquareRoot' factorize :: Int -> [Int] factorize 1 = [] factorize n = first : factorize (quot n first) where first = (!! 0) $ [a | a <- [2..intSqrt n], rem n a == 0] ++ [n] factorize2 :: Int -> [(Int,Int)] factorize2 = foldl (\ls@((val,freq):xs) y -> if val == y then (val,freq+1):xs else (y,1):ls) [(0,0)] . factorize numDivisors :: Int -> Int numDivisors = foldl (\acc (_,y) -> acc * (y+1)) 1 <$> factorize2 nextTriangleNumber :: (Int,Int) -> (Int,Int) nextTriangleNumber (n,acc) = (n+1,acc+n+1) forward :: Int -> (Int, Int) -> Either (Int, Int) (Int, Int) forward k val@(n,acc) = if numDivisors acc > k then Left val else Right (nextTriangleNumber val) problem12 :: Int -> (Int, Int) problem12 n = (!!0) . lefts . scanl (>>=) (forward n (1,1)) . repeat . forward $ n main = do let (n,val) = problem12 1000 print val
factorCount number = foldr factorCount (fromEnum $ square == fromIntegral isquare) where square = sqrt $ fromIntegral number isquare = floor square factorCount | number `rem` candidate == 0 = (2 +) | otherwise = id triangles :: [Int] triangles = scanl1 (+) [1,2..] main = print . head $ dropWhile ((< 1001) . factorCount) triangles
type Clock = Integer -- To make it more similar to the C code -- An action that returns nothing, but might do something main :: IO () main = do -- An action that returns an Integer, which we view as CPU Clock values c <- getCPUTime :: IO Clock -- An action that prints data, but returns nothing print (c + 2*1000*1000*1000*1000) :: IO ()
import Data.Vector.Unboxed as U import Foo main = let y = Bar $ Qux $ U.replicate 11221184 0 :: Foo (Qux Int) (Bar (Qux ans)) = iterate (plus y) y !! 100 in putStr $ show $ foldl1
module Foo (Qux(..), Foo(..), plus) where import Data.Vector.Unboxed as U newtype Qux r = Qux (Vector r) -- GHC inlines `plus` if I remove the bangs or the Baz constructor data Foo t = Bar !t | Baz !t instance (Num r, Unbox r) => Num (Qux r) where {- (Qux x) + (Qux y) = Qux $ U.zipWith (+) x y {- plus :: (Num t) => (Foo t) -> (Foo t) -> (Foo t) plus (Bar v1) (Bar v2) = Bar $ v1 + v2
instance (Num r, Unbox r) => Num (Qux r) where (+) = quxAdd quxAdd (Qux x) (Qux y) = Qux $ U.zipWith (+) x y
-- | Play a game in a window. Like `simulate`, but you manage your own input events. play :: Display -- ^ Display mode. -> Color -- ^ Background color. -> Int -- ^ Number of simulation steps to take for each second of real time. -> world -- ^ The initial world. -> (world -> Picture) -- ^ A function to convert the world a picture. -> (Event -> world -> world) -- ^ A function to handle input events. -> (Float -> world -> world) -- ^ A function to step the world one iteration. -- It is passed the period of time (in seconds) needing to be advanced. -> IO ()
swap (x, y) = (y, x) (.*) = (.) . (.) filterAccum :: (a -> b -> (Bool, a)) -> a -> [b] -> [b] filterAccum f a xs = [x | (x, True) <- zip xs $ snd $ mapAccumL (swap .* f) a xs]
filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a] filterM _ [] = return [] filterM p (x:xs) = do flg <- p x ys <- filterM p xs return (if flg then x:ys else ys)
nub arr <- newArray (1, 9) True :: ST s (STUArray s Int Bool) let p i = readArray arr i <* writeArray arr i False filterM p xs main = print $ nub
main = filterM p [1,2,4,5] >>= print where p i = putStrLn ("return " ++ show i ++ "?") *> readLn
return 1? -- output True -- input return 2? False return 4? False return 5? True [1,5] -- output
filterAccum f a xs = evalState (filterM (state . flip f) xs) a
data Output = TxtOutput String | Beep Frequency main₁ :: String -> [Output] main₁ _ = [ TxtOutput "Hello World" -- , Beep 440 -- for debugging ]
readFile :: Filepath -> (String -> [Output]) -> [Output]
data IO₀ = TxtOut String | TxtIn (String -> [Output]) | FileWrite FilePath String | FileRead FilePath (String -> [Output]) | Beep Double main₂ :: String -> [IO₀] main₂ _ = [ FileRead "/dev/null" $ \_ -> [TxtOutput "Hello World"] ]
data IO₁ = TxtOut String | TxtIn (String -> [IO₁]) | FileWrite FilePath String | FileRead FilePath (String -> [IO₁]) | Beep Double main₃ :: String -> [IO₁] main₃ _ = [ TxtIn $ \_ -> [TxtOut "Hello World"] ]
data IO₂ = TxtOut String IO₂ | TxtIn (String -> IO₂) | Terminate main₄ :: IO₂ main₄ = TxtIn $ \_ -> TxtOut "Hello World" Terminate
getTime :: (UTCTime -> IO₂) -> IO₂ randomRIO :: Random r => (r,r) -> (r -> IO₂) -> IO₂ findFile :: RegEx -> (Maybe FilePath -> IO₂) -> IO₂
type IO₃ a = (a -> IO₂) -> IO₂ -- If this reminds you of continuation-passing -- style, you getTime :: IO₃ UTCTime randomRIO :: Random r => (r,r) -> IO₃ r findFile :: RegEx -> IO₃ (Maybe FilePath)
data IO₄ a = TxtOut String (IO₄ a) | TxtIn (String -> IO₄ a) | TerminateWith a txtOut :: String -> IO₄ () txtOut s = TxtOut s $ TerminateWith () txtIn :: IO₄ String txtIn = TxtIn $ TerminateWith instance Functor IO₄ where fmap f (TerminateWith a) = TerminateWith $ f a fmap f (TxtIn g) = TxtIn $ fmap f . g fmap f (TxtOut s c) = TxtOut s $ fmap f c instance Applicative IO₄ where pure = TerminateWith (<*>) = ap instance Monad IO₄ where TerminateWith x >>= f = f x TxtOut s c >>= f = TxtOut s $ c >>= f TxtIn g >>= f = TxtIn $ (>>=f) . g
perm [e] = [[e]] perm l = do (leader, index) <- zip l [0 :: Int ..] let shortened = take index l ++ drop (index + 1) l trailer <- perm shortened return (leader : trailer)
*Main> perm "a" ["a"] *Main> perm "ab" ["ab","ba"] *Main> perm "" [] *Main> perm "abc" ["abc","acb","bac","bca","cab","cba"]
liftFree :: Functor f => f a -> Free f a foldFree :: Functor f => (f r -> r) -> Free f r -> r
class Monoid m where mempty :: m mappend :: m -> m -> m
instance Monoid [t] where mempty = [] mappend = (++)
--it needs to be a functor instance Functor f => Functor (Free f) where fmap f (Pure a) = Pure (f a) fmap f (Roll x) = Roll (fmap (fmap f) x) --this is the same thing as (++) basically concatFree :: Functor f => Free f (Free f a) -> Free f a concatFree (Pure x) = x concatFree (Roll y) = Roll (fmap concatFree y) instance Functor f => Monad (Free f) where return = Pure -- just like [] x >>= f = concatFree (fmap f x) --this is the standard concatMap definition of bind
-- this is essentially the same as \x -> [x] liftFree :: Functor f => f a -> Free f a liftFree x = Roll (fmap Pure x) -- this is essentially the same as folding a list foldFree :: Functor f => (f r -> r) -> Free f r -> r foldFree _ (Pure a) = a foldFree f (Roll x) = f (fmap (foldFree f) x)
U : Mon → Set -- is our forgetful functor U (a,mappend,mempty) = a F : Set → Mon -- is our free functor F a = ([a],(++),[])
newtype List a = List (forall b. Monoid b => (a -> b) -> b)
class Algebra f x where phi :: f x -> x newtype Free f a = Free (forall x. Algebra f x => (a -> x) -> x)
foldFree :: Functor f => (a -> b) -> (f b -> b) -> Free f a -> b foldFree return join :: Monad m => Free m a -> m a
foldFree :: Monad m => (a -> (m a)) -> (m (m a) -> (m a)) -> Free m a -> (m a)
data List a = Nil | Cons a (List a ) data Free f r = Pure r | Free (f (Free f r))
{- import Data.Syntactic -- Based on NanoFeldspar.hs data Let a where Let :: Let (a :-> (a -> b) :-> Full b) share :: (Let :<: sup, Domain a ~ sup, Domain b ~ sup, SyntacticN (a -> (a -> b) -> b) fi) => a -> (a -> b) -> a share = sugarSym Let
share :: (Let :<: sup, Domain a ~ sup, Domain b ~ sup, Domain (a -> b) ~ sup, Internal (a -> b) ~ (Internal a -> Internal b), Syntactic a, Syntactic b, Syntactic (a -> b), SyntacticN (a -> (a -> b) -> b) fi) => a -> (a -> b) -> b share = sugarSym Let
foo :: (forall a. a -> a) -> (Char,Bool) bar :: forall a. ((a -> a) -> (Char, Bool))
foob :: forall a b. (b -> b) -> b -> (a -> b) -> Maybe a -> b foob postProcess onNothin onJust mval = postProcess val where val :: b val = maybe onNothin onJust mval
ghci> let putInList x = [x] ghci> liftTup putInList (5, "Blah") ([5], ["Blah"])
ghci> let liftTup liftFunc (a, b) = (liftFunc a, liftFunc b) ghci> liftTup (\x -> [x]) (5, "Hello") No instance for (Num [Char]) ... ghci> -- huh? ghci> :t liftTup liftTup :: (t -> t1) -> (t, t) -> (t1, t1)
-- test.hs liftTup :: (x -> f x) -> (a, b) -> (f a, f b) liftTup liftFunc (t, v) = (liftFunc t, liftFunc v) ghci> :l test.hs Couldnt match expected type ...
{- liftTup :: (forall x. x -> f x) -> (a, b) -> (f a, f b) liftTup liftFunc (t, v) = (liftFunc t, liftFunc v)
-- test.hs {- data EQList = forall a. EQList [a] eqListLen :: EQList -> Int eqListLen (EQList x) = length x ghci> :l test.hs ghci> eqListLen $ EQList ["Hello", "World"] 2
ghci> :set -XRankNTypes ghci> length (["Hello", "World"] :: forall a. [a]) Couldnt match expected type ...
foo :: (forall a. a -> a) -> (Char,Bool) bar :: forall a. ((a -> a) -> (Char, Bool))
forall n f e x . (forall e x . n e x -> f -> Fact x f) -> Block n e x -> f -> Fact x f
fmap = /\ f a b -> case f of Maybe -> (\g x -> case x of Just y -> Just b g y Nothing -> Nothing b) :: (a -> b) -> Maybe a -> Maybe b [] -> (\g x -> case x of (y:ys) -> g y : fmap [] a b g ys [] -> [] b) :: (a -> b) -> [a] -> [b]
foo :: (forall a. a -> a) -> (Char,Bool) bar :: forall a. ((a -> a) -> (Char, Bool))
data T = forall a. MkT a -- an existential datatype MkT :: forall a. a -> T -- the type of the existential constructor
data T = forall a. MkT a -- an existential datatype data T = MkT (exists a. a) -- (pseudo-Haskell)
WHNF = thunk : thunk HNF = 0 : thunk NF = 0 : 1 : 2 : 3 : []
myAverage = uncurry (/) . foldl (\(acc, len) x -> acc `seq` len `seq` (acc+x, len+1)) (0,0)
1 + 2 -- we could evaluate this to 3 (\x -> x + 1) 2 -- we could apply the function "he" ++ "llo" -- we could apply the (++) (1 + 1, 2 + 2) -- we could evaluate 1 + 1 and 2 + 2
(1 + 1, 2 + 2) -- the outermost part is the data constructor (,) \x -> 2 + 2 -- the outermost part is a lambda abstraction
1 + 2 -- the outermost part here is an application of (+) (\x -> x + 1) 2 -- the outermost part is an application of (\x -> x + 1) "he" ++ "llo" -- the outermost part is an application of (++)
foldl (+) 0 [1, 2, 3, 4, 5, 6] = foldl (+) (0 + 1) [2, 3, 4, 5, 6] = foldl (+) ((0 + 1) + 2) [3, 4, 5, 6] = foldl (+) (((0 + 1) + 2) + 3) [4, 5, 6] = foldl (+) ((((0 + 1) + 2) + 3) + 4) [5, 6] = foldl (+) (((((0 + 1) + 2) + 3) + 4) + 5) [6] = foldl (+) ((((((0 + 1) + 2) + 3) + 4) + 5) + 6) [] = (((((0 + 1) + 2) + 3) + 4) + 5) + 6 = ((((1 + 2) + 3) + 4) + 5) + 6 = (((3 + 3) + 4) + 5) + 6 = ((6 + 4) + 5) + 6 = (10 + 5) + 6 = 15 + 6 = 21
data List a = Cons a (List a) | Nil foldr Cons Nil [1, 2, 3, 4, 5, 6] = Cons 1 (foldr Cons Nil [2, 3, 4, 5, 6]) -- Cons is a constructor, stop.
foldl = foldl = foldl = foldl = foldl = foldl = foldl = 21 -- 21 is a data constructor, stop.
f (acc, len) x = (acc + x, len + 1) foldl = foldl = foldl = foldl = (((0 + 1) + 2) + 3, ((0 + 1) + 1) + 1) -- tuple constructor, stop.
f len in acc foldl = foldl = foldl = foldl = (6, 3) -- tuple constructor, stop.
take 1 (1:2:3:[]) => { apply take } 1 : take (1-1) (2:3:[]) => { apply (-) } 1 : take 0 (2:3:[]) => { apply take } 1 : []
3 : take 2 [2,3,4] -- outermost function is a constructor (:) (3+1) : [4..] -- ditto \x -> 4+5 -- lambda expression
let a = \b c d e -> (\f -> b + c + d + e + f) b b = a 2 in seq b (b 5)
% ghci GHCi, version 7.8.3: http: ... Prelude> -- I Prelude> -- in all GHCi output. Prelude> :set -XTemplateHaskell Prelude> import Language.Haskell.TH Prelude Language.Haskell.TH> class C a where f :: a -> Int Prelude Language.Haskell.TH> putStrLn $(stringE . show =<< reify ClassI (ClassD [] Ghci1.C [PlainTV a_1627398388] [] [SigD Ghci1.f (ForallT [PlainTV a_1627398388] [ClassP Ghci1.C [VarT a_1627398388]] (AppT (AppT ArrowT (VarT a_1627398388)) (ConT GHC.Types.Int)))]) []
Prelude Language.Haskell.TH> :set -XTypeFamilies Prelude Language.Haskell.TH> class C Prelude Language.Haskell.TH> putStrLn $(stringE . show =<< reify ClassI (ClassD [] Ghci3.C [SigD Ghci3.f' (ForallT [PlainTV a_1627405973] [ClassP Ghci3.C (AppT (AppT ArrowT (VarT a_1627405973)) (ConT GHC.Types.Int)))]) []
Prelude Language.Haskell.TH> putStrLn $(stringE . show =<< reify FamilyI (FamilyD TypeFam Ghci3.F [PlainTV a_1627405973] (Just StarT)) []
Prelude Language.Haskell.TH> instance C Prelude Language.Haskell.TH> f 7 Prelude Language.Haskell.TH> 42 :: F [Integer] 42 Prelude Language.Haskell.TH> putStrLn $(stringE . show =<< reify ClassI (ClassD [] Ghci3.C [SigD Ghci3.f' (ForallT [PlainTV a_1627405973] [ClassP Ghci3.C (AppT (AppT ArrowT (VarT a_1627405973)) (ConT GHC.Types.Int)))]) [InstanceD [] (AppT (ConT Ghci3.C (AppT ListT (VarT a_1627406161))) []]
data Foo = Foo Int Int !Int !(Maybe Int) f = Foo (2+2) (3+3) (4+4) (Just (5+5))
case f of Foo 0 _ _ _ -> "first arg is zero" _ -> "first arge is something else"
data Foo = Foo Int !Int first (Foo x _) = x second (Foo _ y) = y
> first (Foo 1 undefined) *** Exception: Prelude.undefined
{- import Data.Syntactic import Data.Syntactic.Sugar.BindingT data Let a where Let :: Let (a :-> (a -> b) :-> Full b) share :: (Let :<: sup, sup ~ Domain b, sup ~ Domain a, Syntactic a, Syntactic b, Syntactic (a -> b), SyntacticN (a -> (a -> b) -> b) fi) => a -> (a -> b) -> b share = sugarSym Let
(ASTF sup (Internal a) -> AST sup ((Internal a) :-> Full (Internal b)) -> ASTF sup (Internal b))
sugarSym :: (sub :<: AST sup, ApplySym sig fi sup, SyntacticN f fi) => sub sig -> f sugarSym = sugarN . appSym
class ApplySym sig f sym | sig sym -> f, f -> sig sym class SyntacticN f internal | f -> internal sugarSym :: ( sub :<: AST sup , ApplySym sig fi sup , SyntacticN f fi ) => sub sig -> f share :: ( Let :<: sup , sup ~ Domain b , sup ~ Domain a , Syntactic a , Syntactic b , Syntactic (a -> b) , SyntacticN (a -> (a -> b) -> b) fi ) => a -> (a -> b) -> b
Overlapping instances for SyntacticN b fi arising from the ambiguity check for ‘share’ Matching givens (or their superclasses): (SyntacticN (a -> (a -> b) -> b) fi1) Matching instances: instance [overlap ok] (Syntactic f, Domain f ~ sym, fi ~ AST sym (Full (Internal f))) => SyntacticN f fi -- Defined in ‘Data.Syntactic.Sugar’ instance [overlap ok] (Syntactic a, Domain a ~ sym, ia ~ Internal a, SyntacticN f fi) => SyntacticN (a -> f) (AST sym (Full ia) -> fi) -- Defined in ‘Data.Syntactic.Sugar’ (The choice depends on the instantiation of ‘b, fi’) To defer the ambiguity check to use sites, enable AllowAmbiguousTypes
{- class Foo a where whichOne :: a -> String instance Foo a where whichOne _ = "a" instance Foo [a] where whichOne _ = "[a]" -- | -- >>> main -- [a] main :: IO () main = putStrLn $ whichOne (undefined :: [Int])
{- class Foo a where whichOne :: a -> String instance Foo (f Int) where -- this is the line which changed whichOne _ = "f Int" instance Foo [a] where whichOne _ = "[a]" -- | -- >>> main -- Error: Overlapping instances for Foo [Int] main :: IO () main = putStrLn $ whichOne (undefined :: [Int])
{- ambiguousNatVal :: forall n . (KnownNat n) => Integer ambiguousNatVal = natVal @n Proxy five = ambiguousNatVal @5 -- no `Proxy ` needed!
ones :: [Integer] ones = 1:ones twos = map (+1) ones tenTwos = take 10 twos
Prelude.map ---> Prelude.fmap (works for every Functor) Prelude.foldr/foldl/etc ---> Data.Foldable.foldr/foldl/etc Prelude.sequence ---> Data.Traversable.sequence etc
newSequence newValue oldSequence = Sequence.update 3000 newValue oldSequence
fmap :: Functor f => (a -> b) -> f a -> f b contramap :: Contravariant f => (a -> b) -> f b -> f a
instance Monoid Data.Void where mempty = undefined mappend _ _ = undefined mconcat _ = undefined
mkarray [(+10), (+100), id] <*> mkarray [1, 2] == mkarray [[11, 101, 1], [12, 102, 2]]
Functor :: * -> * Applicative :: * -> * Monad :: * -> *
instance Functor Dead where fmap f (Oops corpse) = Oops corpse
instance Applicative Boo where pure _ = Boo True Boo b1 <*> Boo b2 = Boo (b1 == b2)
instance Functor ((,) r) where fmap f (x,y) = (x, f y)
pure x = ZipList (repeat x) ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
instance Functor P where fmap :: (a -> b) -> P a -> P b fmap fab (P pa) = P (\q -> fmap fab $ pa (q . fab))
(<*>) :: P (a -> b) -> P a -> P b (P pfab) <*> (P pa) = \_ -> Nothing -- fails the laws!
data B a = Maybe (a, a) deriving Functor instance Applicative B where pure x = Just (x, x) b1 <*> b2 = case (b1, b2) of (Just (x1, y1), Just (x2, y2)) -> Just((x1, x2), (y1, y2)) _ -> Nothing
join :: Maybe (Maybe (a, a, a), Maybe (a, a, a), Maybe (a, a, a)) -> Maybe (a, a, a) join Nothing = Nothing join Just (Nothing, Just (x1,x2,x3), Just (y1,y2,y3)) = ??? join Just (Just (x1,x2,x3), Nothing, Just (y1,y2,y3)) = ??? -- etc.
data Trs f a = Leaf (f a) | Branch (f (Trs f a)) join :: Trs f (Trs f a) -> Trs f a join (Leaf ftrs) = Branch ftrs join (Branch ftrstrs) = Branch (fmap @f join ftrstrs)
join :: (m1 (m1 a, m2 a), m2 (m1 a, m2 a)) -> (m1 a, m2 a) join (m1x, m2x) = (join @m1 (fmap fst m1x), join @m2 (fmap snd m2x))
data M m a = Either a (m a) instance Monad m => Monad M m where pure x = Left x join :: Either (M m a) (m (M m a)) -> M m a join (Left mma) = mma join (Right me) = Right $ join @m $ fmap @m squash me where squash :: M m a -> m a squash (Left x) = pure @m x squash (Right ma) = ma
| sym | pronunciation | |------|--------------------------------------------------| | | | "such that" | | <- | "is drawn from" | | = | "is defined to be" / "is defined as" | | :: | "has type" / "of type" / "is of type" | | -> | "a function that takes ... and returns a ..." / | | | "function that maps" / | | | "is a function from" / | | | "to" | | $ | "apply" | | _ | "whatever" | | !! | "index" | | ++ | "concat" | | [] | "empty list" | | : | "cons" | | \ | "lambda" | | => | "implies" / "then" | | *> | "then" | | <$> | "fmap" / "dollar cyclops" | | <$ | "map-replace by" | | <*> | "ap" / "star cyclops" | | . | "pipe to" / "compose" / "dot" | | <|> | "or" | | @ | "as" | | ~ | "lazy" | | <=< | "left fish" |
-- literator main = translateLn <$> getLine >>= putStrLn translateLn :: String -> String translateLn = unwords . map t . words t :: String -> String -- t(ranslate) -- historical accurate naming t "=" = "is equal too" -- The Whetstone of Witte - Robert Recorde (1557) -- proposed namings -- src http: t ">>=" = "bind" t "*>" = "then" t "->" = "to" -- a -> b: a to b t "<$" = "map-replace by" -- 0 <$ f: "f map-replace by 0" t "<*>" = "ap(ply)" -- (as it is the same as Control.Monad.ap) t "!!" = "index" t "!" = "index/strict" -- a ! b: "a index b", foo !x: foo strict x t "<|>" = "or/alternative" -- expr <|> term: "expr or term" t "[]" = "empty list" t ":" = "cons" t "\\" = "lambda" t "@" = "as" -- go ll@(l:ls): go ll as l cons ls t "~" = "lazy" -- go ~(a,b): go lazy pair a, b -- t ">>" = "then" -- t "<-" = "bind" -- (as it desugars to >>=) -- t "<$>" = "(f)map" -- t "$" = "" -- (none, just as " " [whitespace]) -- t "." = "pipe to" -- a . b: "b pipe-to a" -- t "++" = "concat/plus/append" -- t "::" = "ofType/as" -- f x :: Int: f x of type Int -- additional names -- src http: t "|" = "such that" t "<-" = "is drawn from" t "::" = "is of type" t "_" = "whatever" t "++" = "append" t "=>" = "implies" t "." = "compose" t "<=<" = "left fish" -- t "=" = "is defined as" -- t "<$>" = "(f)map" -- src http: t "$" = "of" -- src http: t ">>" = "sequence" -- t "<$>" = "infix fmap" -- t ">>=" = "bind" -------------- -- Examples -- -------------- -- "(:) <$> Just 3 <*> Just [4]" -- meaning "Cons applied to just three applied to just list with one element four" t "(:)" = "Cons" t "Just" = "just" t "<$>" = "applied to" t "3" = "three" -- this is might go a bit too far t "[4]" = "list with one element four" -- this one too, let -- additional expressions to translate from -- src http: -- delete (0, 0) $ (,) <$> [-1..1] <*> [-1..1] -- (,) <$> [-1..1] <*> [-1..1] & delete (0, 0) -- liftA2 (,) [-1..1] [-1..1] & delete (0, 0) t "(,)" = "tuple constructor" t "&" = "then" -- flipped `$` -- everything not matched until this point stays at it is t x = x
+ plus - minus (OR negative OR negate for unary use) * multiply OR times / divide . dot OR compose $ apply OR of
Glasgow Haskell Compiler, Version 7.4.2, stage 2 booted by GHC version 7.4.1 Using binary package database: /usr/lib/ghc-7.4.2/package.conf.d/package.cache wired-in package ghc-prim mapped to ghc-prim-0.2.0.0-7d3c2c69a5e8257a04b2c679c40e2fa7 wired-in package integer-gmp mapped to integer-gmp-0.4.0.0-af3a28fdc4138858e0c7c5ecc2a64f43 wired-in package base mapped to base-4.5.1.0-6e4c9bdc36eeb9121f27ccbbcb62e3f3 wired-in package rts mapped to builtin_rts wired-in package template-haskell mapped to template-haskell-2.7.0.0-2bd128e15c2d50997ec26a1eaf8b23bf wired-in package dph-seq not found. wired-in package dph-par not found. Hsc static flags: -static *** Chasing dependencies: Chasing modules from: *SleepSort.hs Stable obj: [Main] Stable BCO: [] Ready for upsweep [NONREC ModSummary { ms_hs_date = Tue Oct 18 22:22:11 CDT 2011 ms_mod = main:Main, ms_textual_imps = [import (implicit) Prelude, import Control.Monad, import Control.Concurrent, import System.Environment] ms_srcimps = [] }] *** Deleting temp files: Deleting: compile: input file SleepSort.hs Created temporary directory: /tmp/ghc4784_0 *** Checking old interface for main:Main: [1 of 1] Compiling Main ( SleepSort.hs, SleepSort.o ) *** Parser: *** Renamer/typechecker: *** Desugar: Result size of Desugar (after optimization) = 79 *** Simplifier: Result size of Simplifier iteration=1 = 87 Result size of Simplifier iteration=2 = 93 Result size of Simplifier iteration=3 = 83 Result size of Simplifier = 83 *** Specialise: Result size of Specialise = 83 *** Float out(FOS {Lam = Just 0, Consts = True, PAPs = False}): Result size of Float out(FOS {Lam = Just 0, Consts = True, PAPs = False}) = 95 *** Float inwards: Result size of Float inwards = 95 *** Simplifier: Result size of Simplifier iteration=1 = 253 Result size of Simplifier iteration=2 = 229 Result size of Simplifier = 229 *** Simplifier: Result size of Simplifier iteration=1 = 218 Result size of Simplifier = 218 *** Simplifier: Result size of Simplifier iteration=1 = 283 Result size of Simplifier iteration=2 = 226 Result size of Simplifier iteration=3 = 202 Result size of Simplifier = 202 *** Demand analysis: Result size of Demand analysis = 202 *** Worker Wrapper binds: Result size of Worker Wrapper binds = 202 *** Simplifier: Result size of Simplifier = 202 *** Float out(FOS {Lam = Just 0, Consts = True, PAPs = True}): Result size of Float out(FOS {Lam = Just 0, Consts = True, PAPs = True}) = 210 *** Common sub-expression: Result size of Common sub-expression = 210 *** Float inwards: Result size of Float inwards = 210 *** Liberate case: Result size of Liberate case = 210 *** Simplifier: Result size of Simplifier iteration=1 = 206 Result size of Simplifier = 206 *** SpecConstr: Result size of SpecConstr = 206 *** Simplifier: Result size of Simplifier = 206 *** Tidy Core: Result size of Tidy Core = 206 writeBinIface: 4 Names writeBinIface: 28 dict entries *** CorePrep: Result size of CorePrep = 224 *** Stg2Stg: *** CodeGen: *** CodeOutput: *** Assembler: Upsweep completely successful. *** Deleting temp files: Deleting: /tmp/ghc4784_0/ghc4784_0.c /tmp/ghc4784_0/ghc4784_0.s Warning: deleting non-existent /tmp/ghc4784_0/ghc4784_0.c link: linkables are ... LinkableM (Sat Sep 29 20:21:02 CDT 2012) main:Main [DotO SleepSort.o] Linking SleepSort ... *** C Compiler: *** C Compiler: *** Linker: link: done *** Deleting temp files: Deleting: /tmp/ghc4784_0/ghc4784_1.o /tmp/ghc4784_0/ghc4784_0.s /tmp/ghc4784_0/ghc4784_0.o /tmp/ghc4784_0/ghc4784_0.c *** Deleting temp dirs: Deleting: /tmp/ghc4784_0
fac :: (Num a, Eq a) => a -> a fac 0 = 1 fac n = n * fac (n - 1)
fac_Int :: Int -> Int fac_Int 0 = 1 fac_Int n = n * fac_Int (n - 1)
\x -> x + f 2 \x -> x + let f_2 = f 2 in f_2 \x -> let f_2 = f 2 in x + f_2 let f_2 = f 2 in \x -> x + f_2
case v of True -> let x = big in x + 1 False -> let x = big in 0
factorial :: Int -> Int factorial 0 = 1 factorial n = n * factorial (n - 1)
factorial :: Int -> Int factorial (I factorial (I I
factorial :: Int -> Int factorial (I factorial factorial factorial
x = (1 + (2 + 3)) + ((1 + 2) + 3) y = f x z = g (f x) y
f = \ t -> case v of V a b -> a : (letrec f = \ t -> case v of V a b -> a : f t in f) t
f = \ t -> case v of V a b -> a : (letrec f = \ t -> a : f t in f t)
f (Left x) y = somthingComplicated1 f (Right x) y = somethingComplicated2
f_Left x y = somethingComplicated1 f_Right x y = somethingComplicated2 {- f (Left x) = f_Left x f (Right x) = f_Right x
last [] = error "last: empty list" last (x:[]) = x last (x:x2:xs) = last (x2:xs)
last_nil = error "last: empty list" last_cons x [] = x last_cons x (x2:xs) = last (x2:xs) {- last [] = last_nil last (x : xs) = last_cons x xs
last_nil = error "last: empty list" last_cons x [] = x last_cons x (x2:xs) = last_cons x2 xs {- last [] = last_nil last (x : xs) = last_cons x xs
foo (0:_ ) = "zero" foo (1:_ ) = "one" foo (_:xs) = foo xs foo ( []) = "end"
foo xs = case xs of y:ys -> case y of 0 -> "zero" 1 -> "one" _ -> foo ys [] -> "end"
newtype T r a = Cons { decons :: a -> r -> (a, r) }
newtype Lens s t = Lens (forall a. State t a -> State s a)
data Iso a b = Iso { hither :: a -> b, yon :: b -> a }
type Lens a b = forall f. Functor f => (b -> f b) -> a -> f a
type LensFamily a b c d = forall f. Functor f => (c -> f d) -> a -> f b
newtype Book = Book (Int, Int) -- "Book Int Int" is syntactically invalid
Prelude> read "3" :: Int 3 Prelude> read "3" :: Double 3.0
Prelude> show 3 "3" Prelude> read $ show 3 :: Int 3
myIntToStr :: Int -> String myIntToStr x | x < 3 = show x ++ " is less than three" | otherwise = "normal"
module Lib ( someFunc ) where someFunc :: IO () x = 123 someFunc = putStrLn (show x)
f :: Int -> RealWorld -> (Int, RealWorld) -- input some states of the whole world, -- modify the whole world because of the a side effects, -- then return the new world.
getLine :: IO String = RealWorld -> (String, RealWorld) getContents :: String -> IO String = String -> RealWorld -> (String, RealWorld) putStrLn :: String -> IO () = String -> RealWorld -> ((), RealWorld)
printFile :: RealWorld -> ((), RealWorld) printFile world0 = let (filename, world1) = getLine world0 (contents, world2) = (getContents filename) world1 in (putStrLn contents) world2 -- results in ((), world3)
... (<result-of-f>, worldY) = f worldX (<result-of-g>, worldZ) = g <result-of-f> worldY ...
(~~~) :: (IO b) -> (b -> IO c) -> IO c (~~~) :: (RealWorld -> (b, RealWorld)) -> (b -> RealWorld -> (c, RealWorld)) -> RealWorld -> (c, RealWorld) (f ~~~ g) worldX = let (resF, worldY) = f worldX in g resF worldY
impureUpperCase :: String -> RealWorld -> (String, RealWorld) impureUpperCase str world = (upperCase str, world)
impurify :: a -> IO a impurify :: a -> RealWorld -> (a, RealWorld) impurify a world = (a, world)
printUpperCaseFile = getLine ~~~ getContents ~~~ (impurify . upperCase) ~~~ putStrLn
impurify a = (\world -> (a, world)) (impurify a ~~~ f) worldX = let (resF, worldY) = (\world -> (a, world)) worldX in f resF worldY = let (resF, worldY) = (a, worldX)) in f resF worldY = f a worldX
(f ~~~ impurify) a worldX = let (resF, worldY) = impuify a worldX in f resF worldY = let (resF, worldY) = (a, worldX) in f resF worldY = f a worldX
data Nat = Z | S Nat data Vec :: Nat -> * -> * where VNil :: Vec Z x VCons :: x -> Vec n x -> Vec (S n) x
vApply :: Vec n (s -> t) -> Vec n s -> Vec n t vApply VNil VNil = VNil vApply (VCons f fs) (VCons s ss) = VCons (f s) (vApply fs ss)
data Natty :: Nat -> * where Zy :: Natty Z Sy :: Natty n -> Natty (S n)
vReplicate :: Natty n -> x -> Vec n x vReplicate Zy x = VNil vReplicate (Sy n) x = VCons x (vReplicate n x)
class Nattily (n :: Nat) where natty :: Natty n instance Nattily Z where natty = Zy instance Nattily n => Nattily (S n) where natty = Sy natty
instance Nattily n => Applicative (Vec n) where pure = vReplicate natty (<*>) = vApply
data Vec (n :: Nat) (x :: *) = n ~ Z => VNil | forall m. n ~ S m => VCons x (Vec m x)
data InVec :: x -> Vec n x -> * where Here :: InVec z (VCons z zs) After :: InVec z ys -> InVec z (VCons y ys)
data InVec (a :: x) (as :: Vec n x) = forall m z (zs :: Vec x m). (n ~ S m, as ~ VCons z zs) => Here | forall m y z (ys :: Vec x m). (n ~ S m, as ~ VCons y ys) => After (InVec z ys)
vReplicate :: pi n :: Nat -> x -> Vec n x vReplicate Z x = VNil vReplicate (S n) x = VCons x (vReplicate n x)
data Some :: (k -> *) -> * where Like :: p x -> Some p fromInt :: Int -> Some Natty fromInt 0 = Like Zy fromInt n = case fromInt (n - 1) of Like n -> Like (Sy n) withZeroes :: (forall n. Vec n Int -> IO a) -> IO a withZeroes k = do Like n <- fmap (fromInt . read) getLine k (vReplicate n 0) *Main> withZeroes print 5 VCons 0 (VCons 0 (VCons 0 (VCons 0 (VCons 0 VNil))))
{- {- forall m . (Factored m Int) => (FastCyc (VT U.Vector m) Int) -> (FastCyc (VT U.Vector m) Int) -> (FastCyc (VT U.Vector m) Int) -- Although the next specialization makes `fcTest` fast, -- it isn -- {- -- FastCyc (VT U.Vector M) Int -> -- FastCyc (VT U.Vector M) Int -> -- FastCyc (VT U.Vector M) Int plusFastCyc :: (Num (t r)) => (FastCyc t r) -> (FastCyc t r) -> (FastCyc t r) plusFastCyc (PowBasis v1) (PowBasis v2) = PowBasis $ v1 + v2
instance (Num r, V.Vector v r, Factored m r) => Num (VT v m r) where {- VT x + VT y = VT $ V.zipWith (+) x y
instance (Factored m Int) => Num (VT U.Vector m Int) where VT x + VT y = VT $ V.zipWith (+) x y
{- import Control.Morphism.Zygo import Control.Morphism.Prepro import Control.Morphism.Histo import Control.Functor.Algebra import Control.Functor.Extras import Control.Functor.Fix import Control.Comonad.Cofree zygohistomorphic_prepromorphism :: Functor f => Algebra f b -> GAlgebra f (ZygoT (Cofree f) b) a -> (f :~> f) -> FixF f -> a zygohistomorphic_prepromorphism f = g_prepro (distZygoT (liftAlgebra f) (distHisto id))
zygoHistoPrepro :: (Unfoldable t, Foldable t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (EnvT b (Stream (Base t)) a) -> a) -> t -> a
zygoHistoPrepro f = gprepro (distZygoT f distHisto)
Prelude> (minBound, maxBound) :: (Int, Int) (-9223372036854775808,9223372036854775807)
Prelude> (minBound, maxBound) :: (Integer, Integer) <interactive>:3:2: No instance for (Bounded Integer) arising from a use of `minBound' Possible fix: add an instance declaration for (Bounded Integer) In the expression: minBound In the expression: (minBound, maxBound) :: (Integer, Integer) In an equation for `it it = (minBound, maxBound) :: (Integer, Integer)
$ ghci Prelude> (12345678901234567890 :: Integer, 12345678901234567890 :: Int) (12345678901234567890,-350287150)
ghci> :t foldr foldr :: (a -> b -> b) -> b -> [a] -> b ghci> :t foldl foldl :: (a -> b -> a) -> a -> [b] -> a ghci>
$ aptitude show ghc6 | grep Size Uncompressed Size: 388M
$ aptitude show openjdk-6-jdk openjdk-6-jre openjdk-6-jre-headless ant maven2 ivy | grep Size Uncompressed Size: 34.9M Uncompressed Size: 905k Uncompressed Size: 77.3M Uncompressed Size: 1,585k Uncompressed Size: 3,736k Uncompressed Size: 991k
$ dpkg -L ghc6 | grep 57048 /usr/lib/ghc-6.12.1/ghc-6.12.1/libHSghc-6.12.1.a 22668 /usr/lib/ghc-6.12.1/Cabal-1.8.0.2/libHSCabal-1.8.0.2.a 21468 /usr/lib/ghc-6.12.1/base-4.2.0.0/libHSbase-4.2.0.0.a $ dpkg -L ghc6-prof | grep 112596 /usr/lib/ghc-6.12.1/ghc-6.12.1/libHSghc-6.12.1_p.a 33536 /usr/lib/ghc-6.12.1/Cabal-1.8.0.2/libHSCabal-1.8.0.2_p.a 31724 /usr/lib/ghc-6.12.1/base-4.2.0.0/libHSbase-4.2.0.0_p.a
runProxy :: PortID -> AddrInfo -> IO () runProxy localPort@(PortNumber lpn) serverAddrInfo = do listener <- listenOn localPort forever $ do (sClient, clientAddr) <- accept listener let finalize sServer = do sClose sServer sClose sClient forkIO $ do tidToServer <- myThreadId bracket (connectToServer serverAddrInfo) finalize $ \sServer -> do -- execute one -- and make sure that if one direction dies, the other gets -- pulled down as well bracket (forkIO (copySocket sServer sClient `finally` killThread tidToServer)) (killThread) $ \_ -> do copySocket sClient sServer -- "controlling" thread where -- |Copy data from source to dest until EOF occurs on source -- Copying may also be aborted due to exceptions copySocket :: Socket -> Socket -> IO () copySocket src dst = go where go = do buf <- B.recv src 4096 unless (B.null buf) $ do B.sendAll dst buf go -- |Create connection to given AddrInfo target and return socket connectToServer saddr = do sServer <- socket (addrFamily saddr) Stream defaultProtocol connect sServer (addrAddress saddr) return sServer
copyIn :: SSL.SSL -> Socket -> IO () copyIn src dst = go where go = do buf <- SSL.read src 4096 unless (B.null buf) $ do SB.sendAll dst buf go copyOut :: Socket -> SSL.SSL -> IO () copyOut src dst = go where go = do buf <- SB.recv src 4096 unless (B.null buf) $ do SSL.write dst buf go
-- |Create connection to given AddrInfo target and return socket connectToServer saddr = do sServer <- socket (addrFamily saddr) Stream defaultProtocol putStrLn "connecting" connect sServer (addrAddress saddr) putStrLn "establishing ssl context" ctx <- SSL.context putStrLn "setting ciphers" SSL.contextSetCiphers ctx "DEFAULT" putStrLn "setting verfication mode" SSL.contextSetVerificationMode ctx SSL.VerifyNone putStrLn "making ssl connection" sslServer <- SSL.connection ctx sServer putStrLn "doing handshake" SSL.connect sslServer putStrLn "connected" return sslServer
let finalize sServer = do putStrLn "shutting down ssl" SSL.shutdown sServer SSL.Unidirectional putStrLn "closing server socket" maybe (return ()) sClose (SSL.sslSocket sServer) putStrLn "closing client socket" sClose sClient
main = withOpenSSL $ do let hints = defaultHints { addrSocketType = Stream, addrFamily = AF_INET } addrs <- getAddrInfo (Just hints) (Just "localhost") (Just "22222") let addr = head addrs print addr runProxy (PortNumber 11111) addr
test.hs|71 col 13 error| Couldn || with ‘[GHC.Types.Char]’ || Expected type: containers-0.5.6.2:Data.Map.Base.Map || [GHC.Types.Char] || ([(integer-gmp-1.0.0.0:GHC.Integer.Type.Integer, || integer-gmp-1.0.0.0:GHC.Integer.Type.Integer)], || containers-0.5.6.2:Data.Set.Base.Set || integer-gmp-1.0.0.0:GHC.Integer.Type.Integer) || Actual type: containers-0.5.6.2:Data.Map.Base.Map || Data.Text.Internal.Text || ([(integer-gmp-1.0.0.0:GHC.Integer.Type.Integer, || integer-gmp-1.0.0.0:GHC.Integer.Type.Integer)], || containers-0.5.6.2:Data.Set.Base.Set || integer-gmp-1.0.0.0:GHC.Integer.Type.Integer) || In the second argument of ‘containers-0.5.6.2:Data.Map.Base.map’, namely || ‘zippedMap’ || In the second argument of ‘(GHC.Base.$)’, namely || ‘containers-0.5.6.2:Data.Map.Base.map ...
test.hs:71:13: Couldn Expected type: M.Map [Char] ([(Integer, Integer)], S.Set Integer) Actual type: M.Map T.Text ([(Integer, Integer)], S.Set Integer) In the second argument of ‘M.map’, namely ‘zippedMap’ In the second argument of ‘($)’, namely ‘M.map ...
Prelude> let abs n | n >= 0 = n Prelude> | otherwise = -n <interactive>:1:0: parse error on input `|'
Prelude> :set +m Prelude> let fac 0 = 1 Prelude| fac n = n * fac (n-1) Prelude| Prelude> fac 10 3628800
> :{ > let foo a b = a + > b > :} > :t foo foo :: (Num a) => a -> a -> a
> :{ | let prRev = do | inp <- getLine | putStrLn $ reverse inp | :} <interactive>:1:18: The last statement in a
> :{ | let prRev = do { | inp <- getLine; | putStrLn $ reverse inp; | } | :} > :t prRev prRev :: IO ()
data Profession = Fighter | Archer | Accountant data Race = Human | Elf | Orc | Goblin data PlayerCharacter = PlayerCharacter Race Profession
helloMe :: CoolBool -> String helloMe (CoolBool _) = "hello"
ghci> helloMe undefined "*** Exception: Prelude.undefined
newtype CoolBool = CoolBool { getCoolBool :: Bool }
newtype Fd = Fd CInt -- data Fd = Fd CInt would also be valid -- newtypes can have deriving clauses just like normal types newtype Identity a = Identity a deriving (Eq, Ord, Read, Show) -- record syntax is still allowed, but only for one field newtype State s a = State { runState :: s -> (s, a) } -- this is *not* allowed: -- newtype Pair a b = Pair { pairFst :: a, pairSnd :: b } -- but this is: data Pair a b = Pair { pairFst :: a, pairSnd :: b } -- and so is this: newtype Pair
State :: (s -> (a, s)) -> State s a runState :: State s a -> (s -> (a, s))
data DataBox a = DataBox Int newtype NewtypeBox a = NewtypeBox Int dataMatcher :: DataBox -> String dataMatcher (DataBox _) = "data" newtypeMatcher :: NewtypeBox -> String newtypeMatcher (NewtypeBox _) = "newtype" ghci> dataMatcher undefined "*** Exception: Prelude.undefined ghci> newtypeMatcher undefined “newtype"
otool -L TryHint TryHint: /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1213.0.0) /usr/lib/libiconv.2.dylib (compatibility version 7.0.0, current version 7.0.0) /usr/local/lib/libgmp.10.dylib (compatibility version 13.0.0, current version 13.0.0)
import Control.Monad import Language.Haskell.Interpreter main = do f <- runInterpreter $ loadModules ["Test"] >> setTopLevelModules ["Test"] >> interpret "f" (as :: Int -> Int) case f of Left e -> print e Right r -> mapM_ (print . r) [1..10]
ghci> import Data.List.Split ghci> splitOn "," "my,comma,separated,list" ["my","comma","separated","list"]
words :: String -> [String] words s = case dropWhile Char.isSpace s of "" -> [] s where (w, s
wordsWhen :: (Char -> Bool) -> String -> [String] wordsWhen p s = case dropWhile p s of "" -> [] s where (w, s
import qualified Data.Text as T main = print $ T.splitOn (T.pack " ") (T.pack "this is a test")
{- import qualified Data.Text as T main = print $ T.splitOn " " "this is a test"
[me@localhost]$ ghci Prelude> import Data.List.Split Prelude Data.List.Split> let l = splitOn "," "1,2,3,4" Prelude Data.List.Split> :t l l :: [[Char]] Prelude Data.List.Split> l ["1","2","3","4"] Prelude Data.List.Split> let { convert :: [String] -> [Integer]; convert = map read } Prelude Data.List.Split> let l2 = convert l Prelude Data.List.Split> :t l2 l2 :: [Integer] Prelude Data.List.Split> l2 [1,2,3,4]
import Data.List (unfoldr) separateBy :: Eq a => a -> [a] -> [[a]] separateBy chr = unfoldr sep where sep [] = Nothing sep l = Just . fmap (drop 1) . break (== chr) $ l
split :: Eq a => a -> [a] -> [[a]] split d [] = [] split d s = x : split d (drop 1 y) where (x,y) = span (/= d) s
split :: Eq a => a -> [a] -> [[a]] split x y = func x y [[]] where func x [] z = reverse $ map (reverse) z func x (y:ys) (z:zs) = if y==x then func x ys ([]:(z:zs)) else func x ys ((y:z):zs)
*Main> splitWithStr " and " "this and is and a and test" ["this","is","a","test"]
splitWithStr :: Eq a => [a] -> [a] -> [[a]] splitWithStr x y = func x y [[]] where func x [] z = reverse $ map (reverse) z func x (y:ys) (z:zs) = if (take (length x) (y:ys)) == x then func x (drop (length x) (y:ys)) ([]:(z:zs)) else func x ys ((y:z):zs)
-- Correct but inefficient implementation wordsBy :: String -> Char -> [String] wordsBy s c = reverse (go s []) where go s "" -> ws rem -> go ((dropWhile (\c -- Breaks up by predicate function to allow for more complex conditions (\c -> c == wordsByF :: String -> (Char -> Bool) -> [String] wordsByF s f = reverse (go s []) where go s "" -> ws rem -> go ((dropWhile (\c
> import qualified Text.Regex as R > R.splitRegex (R.mkRegex "x") "2x3x777" > ["2","3","777"]
(\ f x → (f x)) -- church number 1 (\ f x → (f (f (f x)))) -- church number 3 (\ f x → (f (f (f (f x))))) -- church number 4
3 { iterations: 11523, applications: 5748, used_memory: 27729 } real 0m0.104s user 0m0.086s sys 0m0.019s
5 { iterations: 10351327, applications: 5175644, used_memory: 23754870 } real 0m4.025s user 0m3.686s sys 0m0.341s
data Term = F !(Term -> Term) | N !Double instance Show Term where { show (N x) = "(N "++(if fromIntegral (floor x) == x then show (floor x) else show x)++")"; show (F _) = "(λ...)"} infixl 0 # (F f) churchNum = F(\(N n)->F(\f->F(\x->if n<=0 then x else (f expMod = (F(\v0->(F(\v1->(F(\v2->((((((churchNum main = print $ (expMod
(λab.(b(λcd.(c(λe.(d(λfg.(f(efg)))e))))(λc.(c(λde.e)))(λc.(a(b(λdef.(d(λg.(egf))))(λd.d)(λde.(ed)))(b(λde.d)(λd.d)(λd.d))))))
f :: (Int -> Int) -> Int -> Int f mf 0 = 0 f mf n = max n $ mf (n `div` 2) + mf (n `div` 3) + mf (n `div` 4)
f_list :: [Int] f_list = map (f faster_f) [0..] faster_f :: Int -> Int faster_f n = f_list !! n
data Tree a = Tree (Tree a) a (Tree a) instance Functor Tree where fmap f (Tree l m r) = Tree (fmap f l) (f m) (fmap f r)
index :: Tree a -> Int -> a index (Tree _ m _) 0 = m index (Tree l _ r) n = case (n - 1) `divMod` 2 of (q,0) -> index l q (q,1) -> index r q
nats :: Tree Int nats = go 0 1 where go !n !s = Tree (go l s where l = n + s r = l + s s
toList :: Tree a -> [a] toList as = map (index as) [0..]
f_tree :: Tree Int f_tree = fmap (f fastest_f) nats fastest_f :: Int -> Int fastest_f = index f_tree
*Main> fastest_f 12380192300 67652175206 *Main> fastest_f 12793129379123 120695231674999
*Main> fastest_f 93721573993600178112200489 *Main> fastest_f 11097012733777002208302545289166620866358
{- import Data.Function (fix) f :: (Integer -> Integer) -> Integer -> Integer f mf 0 = 0 f mf n = max n $ mf (div n 2) + mf (div n 3) + mf (div n 4) -- Memoizing using a list -- The memoizing functionality depends on this being in eta reduced form! memoList :: ((Integer -> Integer) -> Integer -> Integer) -> Integer -> Integer memoList f = memoList_f where memoList_f = (memo !!) . fromInteger memo = map (f memoList_f) [0..] faster_f :: Integer -> Integer faster_f = memoList f -- Memoizing using a tree data Tree a = Tree (Tree a) a (Tree a) instance Functor Tree where fmap f (Tree l m r) = Tree (fmap f l) (f m) (fmap f r) index :: Tree a -> Integer -> a index (Tree _ m _) 0 = m index (Tree l _ r) n = case (n - 1) `divMod` 2 of (q,0) -> index l q (q,1) -> index r q nats :: Tree Integer nats = go 0 1 where go !n !s = Tree (go l s where l = n + s r = l + s s toList :: Tree a -> [a] toList as = map (index as) [0..] -- The memoizing functionality depends on this being in eta reduced form! memoTree :: ((Integer -> Integer) -> Integer -> Integer) -> Integer -> Integer memoTree f = memoTree_f where memoTree_f = index memo memo = fmap (f memoTree_f) nats fastest_f :: Integer -> Integer fastest_f = memoTree f
f = 0 : [ g n | n <- [1..] ] where g n = max n $ f!!(n `div` 2) + f!!(n `div` 3) + f!!(n `div` 4)
f = 0 : g 1 : g 2 : g 3 : g 4 : g 5 : g 6 : g 7 : g 8 : g 9 : g 10 : g 11 : g 12 : ...
f !! 6 = g 6 = max 6 $ f !! 3 + f !! 2 + f !! 1 f !! 3 = g 3 = max 3 $ f !! 1 + f !! 1 + f !! 0 f !! 1 = g 1 = max 1 $ f !! 0 + f !! 0 + f !! 0 f !! 0 = 0
f = 0 : 1 : g 2 : g 3 : g 4 : g 5 : g 6 : g 7 : g 8 : g 9 : g 10 : g 11 : g 12 : ...
f = 0 : 1 : g 2 : 3 : g 4 : g 5 : g 6 : g 7 : g 8 : g 9 : g 10 : g 11 : g 12 : ...
f !! 6 = g 6 = max 6 $ 3 + f !! 2 + 1 f !! 2 = g 2 = max 2 $ f !! 1 + f !! 0 + f !! 0 = max 2 $ 1 + 0 + 0 = 2 f !! 6 = g 6 = max 6 $ 3 + 2 + 1 = 6
f = 0 : 1 : 2 : 3 : g 4 : g 5 : 6 : g 7 : g 8 : g 9 : g 10 : g 11 : g 12 : ...
f !! 12 = g 12 = max 12 $ 6 + f!!4 + 3 f !! 4 = g 4 = max 4 $ f !! 2 + f !! 1 + f !! 1 = max 4 $ 2 + 1 + 1 = 4 f !! 12 = g 12 = max 12 $ 6 + 4 + 3 = 13
f = 0 : 1 : 2 : 3 : 4 : g 5 : 6 : g 7 : g 8 : g 9 : g 10 : g 11 : 13 : ...
fm :: (Integral a, Monad m) => (a -> m a) -> a -> m a fm _ 0 = return 0 fm recf n = do recs <- mapM recf $ div n <$> [2, 3, 4] return $ max n (sum recs)
noMemoF :: (Integral n) => n -> n noMemoF = runIdentity . fix fm
import qualified Data.Map.Strict as MS withMemoStMap :: (Integral n) => n -> n withMemoStMap n = evalState (fm recF n) MS.empty where recF i = do v <- MS.lookup i <$> get case v of Just v Nothing -> do v modify $ MS.insert i v' return v'
import qualified Data.HashMap.Strict as HMS withMemoStHMap :: (Integral n, Hashable n) => n -> n withMemoStHMap n = evalState (fm recF n) HMS.empty where recF i = do v <- HMS.lookup i <$> get case v of Just v Nothing -> do v modify $ HMS.insert i v' return v'
import qualified Data.HashTable.ST.Linear as MHM withMemoMutMap :: (Integral n, Hashable n) => n -> n withMemoMutMap n = runST $ do ht <- MHM.new recF ht n where recF ht i = do k <- MHM.lookup ht i case k of Just k Nothing -> do k MHM.insert ht i k' return k'
nats where l = fmap (\n -> n*2) nats' r = fmap (\n -> n*2 + 1) nats' nats
dilate :: Int -> [x] -> [x] dilate n xs = replicate n =<< xs
fs = f0 : zipWith max [1..] (tail $ fs where (.+.) = zipWith (+) infixl 6 .+. ( infixl 7
data NatTrie v = NatTrie (NatTrie v) v (NatTrie v) memo1 arg_to_index index_to_arg f = (\n -> index nats (arg_to_index n)) where nats = go 0 1 go i s = NatTrie (go (i+s) s where s index (NatTrie l v r) i | i < 0 = f (index_to_arg i) | i == 0 = v | otherwise = case (i-1) `divMod` 2 of (i (i memoNat = memo1 id id
fib = memoNat f where f 0 = 0 f 1 = 1 f n = fib (n-1) + fib (n-2)
memoInt = memo1 arg_to_index index_to_arg where arg_to_index n | n < 0 = -2*n | otherwise = 2*n + 1 index_to_arg i = case i `divMod` 2 of (n,0) -> -n (n,1) -> n
data Tree a = Node {datum :: a, child2 :: Tree a, child3 :: Tree a} f :: Int -> Int f n = datum root where root = f -- Pass in the arg -- and this node f f where leaf = Node 0 leaf leaf f where d = if n < 12 then n else max n (d2 + d3 + d4) [n2,n3,n4,n6] = map (n `div`) [2,3,4,6] [d2,d3,d4,d6] = map datum [c2,c3,c4,c6] c2 = case m2 of -- Check for a passed-in subtree before recursing. Just c2 Nothing -> f c3 = case m3 of Just c3 Nothing -> f c4 = child2 c2 c6 = f main = print (f 123801) -- Should print 248604.
liftFoo2 :: (a -> b -> c) -> Foo a -> Foo b -> Foo c
import Control.Applicative instance Applicative Foo where pure x = Foo $ ... -- Wrap (<*>) = liftFoo2 ($)
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
result = myFunction <$> arg1 <*> arg2 <*> arg3 <*> arg4
> replicate 3 "aaa" > :t replicate replicate :: Int -> a -> [a] > :t liftA2 replicate liftA2 replicate :: (Applicative f) => f Int -> f a -> f [a] > (liftA2 replicate) [1,2,3] [ ["a","b","c","aa","bb","cc","aaa","bbb","ccc"] > :t liftA2 liftA2 :: (Applicative f) => (a -> b -> c) -> (f a -> f b -> f c)
module Main (main) where import qualified Control.Exception as Exception import qualified Control.Monad as Monad import qualified Data.ByteString as ByteString import qualified Data.Map.Strict as Map data Msg = Msg !Int !ByteString.ByteString type Chan = Map.Map Int ByteString.ByteString message :: Int -> Msg message n = Msg n (ByteString.replicate 1024 (fromIntegral n)) pushMsg :: Chan -> Msg -> IO Chan pushMsg chan (Msg msgId msgContent) = Exception.evaluate $ let inserted = Map.insert msgId msgContent chan in if 200000 < Map.size inserted then Map.deleteMin inserted else inserted main :: IO () main = Monad.foldM_ pushMsg Map.empty (map message [1..1000000])
$ ghc --version The Glorious Glasgow Haskell Compilation System, version 7.10.3 $ ghc -O2 -optc-O3 Main.hs $ ./Main +RTS -s 3,116,460,096 bytes allocated in the heap 385,101,600 bytes copied during GC 235,234,800 bytes maximum residency (14 sample(s)) 124,137,808 bytes maximum slop 600 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 6558 colls, 0 par 0.238s 0.280s 0.0000s 0.0012s Gen 1 14 colls, 0 par 0.179s 0.250s 0.0179s 0.0515s INIT time 0.000s ( 0.000s elapsed) MUT time 0.652s ( 0.745s elapsed) GC time 0.417s ( 0.530s elapsed) EXIT time 0.010s ( 0.052s elapsed) Total time 1.079s ( 1.326s elapsed) %GC time 38.6% (40.0% elapsed) Alloc rate 4,780,213,353 bytes per MUT second Productivity 61.4% of total user, 49.9% of total elapsed
msgs history length max GC pause (ms) =================== ================= 12500 3 25000 6 50000 13 100000 30 200000 56 400000 104 800000 199 1600000 487 3200000 1957 6400000 5378
import qualified Control.Exception as Exception import qualified Control.Monad as Monad import qualified Data.ByteString as ByteString import qualified Data.Map.Strict as Map import qualified Data.Vector.Mutable as Vector data Msg = Msg !Int !ByteString.ByteString type Chan = Map.Map Int ByteString.ByteString data Chan2 = Chan2 { next :: !Int , maxId :: !Int , ringBuffer :: !(Vector.IOVector ByteString.ByteString) } chanSize :: Int chanSize = 200000 message :: Int -> Msg message n = Msg n (ByteString.replicate 1024 (fromIntegral n)) newChan2 :: IO Chan2 newChan2 = Chan2 0 0 <$> Vector.unsafeNew chanSize pushMsg2 :: Chan2 -> Msg -> IO Chan2 pushMsg2 (Chan2 ix _ store) (Msg msgId msgContent) = let ix in Vector.unsafeWrite store ix pushMsg :: Chan -> Msg -> IO Chan pushMsg chan (Msg msgId msgContent) = Exception.evaluate $ let inserted = Map.insert msgId msgContent chan in if chanSize < Map.size inserted then Map.deleteMin inserted else inserted main, main1, main2 :: IO () main = main2 main1 = Monad.foldM_ pushMsg Map.empty (map message [1..1000000]) main2 = newChan2 >>= \c -> Monad.foldM_ pushMsg2 c (map message [1..1000000])
msgs history length max GC pause (ms) =================== ================= 12500 0.7 25000 1.4 50000 2.8 100000 5.4 200000 10.9 400000 21.8 800000 46 1600000 87 3200000 175 6400000 350
{- import qualified Control.Exception as Exception import qualified Control.Monad as Monad import qualified Data.ByteString as ByteString import Data.Sequence as S newtype Msg = Msg ByteString.ByteString data Chan = Chan Int (Seq ByteString.ByteString) message :: Int -> Msg message n = Msg (ByteString.replicate 1024 (fromIntegral n)) maxSize :: Int maxSize = 200000 pushMsg :: Chan -> Msg -> IO Chan pushMsg (Chan !offset sq) (Msg msgContent) = Exception.evaluate $ let newSize = 1 + S.length sq newSq = sq |> msgContent in if newSize <= maxSize then Chan offset newSq else case S.viewl newSq of (_ :< newSq S.EmptyL -> error "Can getMsg :: Chan -> Int -> Maybe Msg getMsg (Chan offset sq) i_ = getMsg where getMsg | i < 0 = Nothing | i >= S.length sq = Nothing | otherwise = Just (Msg (S.index sq i)) main :: IO () main = Monad.foldM_ pushMsg (Chan 0 S.empty) (map message [1..5 * maxSize])
$ du -hs A 13M A $ file A A: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.27, not stripped $ ldd A linux-vdso.so.1 => (0x00007fff1b9ff000) libXrandr.so.2 => /usr/lib/libXrandr.so.2 (0x00007fb21f418000) libX11.so.6 => /usr/lib/libX11.so.6 (0x00007fb21f0d9000) libGLU.so.1 => /usr/lib/libGLU.so.1 (0x00007fb21ee6d000) libGL.so.1 => /usr/lib/libGL.so.1 (0x00007fb21ebf4000) libgmp.so.10 => /usr/lib/libgmp.so.10 (0x00007fb21e988000) libm.so.6 => /lib/libm.so.6 (0x00007fb21e706000) ...
$ cabal install opengl --enable-shared --reinstall $ cabal install glfw --enable-shared --reinstall
$ ghc -O2 -dynamic A.hs [1 of 4] Compiling S3DM.V3 ( S3DM/V3.hs, S3DM/V3.o ) [2 of 4] Compiling S3DM.M3 ( S3DM/M3.hs, S3DM/M3.o ) [3 of 4] Compiling S3DM.X4 ( S3DM/X4.hs, S3DM/X4.o ) [4 of 4] Compiling Main ( A.hs, A.o ) Linking A...
$ ldd A libHSOpenGL-2.4.0.1-ghc7.0.3.so => ... libHSTensor-1.0.0.1-ghc7.0.3.so => ... libHSStateVar-1.0.0.0-ghc7.0.3.so =>... libHSObjectName-1.0.0.0-ghc7.0.3.so => ... libHSGLURaw-1.1.0.0-ghc7.0.3.so => ... libHSOpenGLRaw-1.1.0.1-ghc7.0.3.so => ... libHSbase-4.3.1.0-ghc7.0.3.so => ... libHSinteger-gmp-0.2.0.3-ghc7.0.3.so => ... libHSghc-prim-0.2.0.0-ghc7.0.3.so => ... libHSrts-ghc7.0.3.so => ... libm.so.6 => /lib/libm.so.6 (0x00007ffa4ffd6000) librt.so.1 => /lib/librt.so.1 (0x00007ffa4fdce000) libdl.so.2 => /lib/libdl.so.2 (0x00007ffa4fbca000) libHSffi-ghc7.0.3.so => ...
1 :: Int8 1 :: Integer 2^100 :: Integer \x -> x + 1 (1 :: Int8, 2 :: Int8) [1] :: [Int8] Just (1 :: Int8) Nothing
$ ./A +RTS -s 64,952 bytes allocated in the heap 1 MB total memory in use %GC time 0.0% (6.1% elapsed) Productivity 100.0% of total user, 0.0% of total elapsed
$ ./A +RTS -t --machine-readable [("bytes allocated", "64952") ,("num_GCs", "1") ,("average_bytes_used", "43784") ,("max_bytes_used", "43784") ,("num_byte_usage_samples", "1") ,("peak_megabytes_allocated", "1") ,("init_cpu_seconds", "0.00") ,("init_wall_seconds", "0.00") ,("mutator_cpu_seconds", "0.00") ,("mutator_wall_seconds", "0.00") ,("GC_cpu_seconds", "0.00") ,("GC_wall_seconds", "0.00") ]
[DEFAULT] hostname: localhost [file1] location: /usr/local user: Fred
concat $ withStrategy (parBuffer 40 rdeepseq) (chunksOf 100 (map colorPixel pixels))
render :: [([(Float,Float)],[(Float,Float)])] -> World -> [Color] render grids world = cs where ps = [ (i,j) | j <- reverse [0..wImgHt world - 1] , i <- [0..wImgWd world - 1] ] cs = map (colorPixel world) (zip ps grids) --cs = withStrategy (parListChunk (round (wImgWd world)) rdeepseq) (map (colorPixel world) (zip ps grids)) --cs = withStrategy (parBuffer 16 rdeepseq) (map (colorPixel world) (zip ps grids)) --cs = concat $ withStrategy (parBuffer 40 rdeepseq) (chunksOf 100 (map (colorPixel world) (zip ps grids)))
colorPixel :: World -> ((Float,Float),([(Float,Float)],[(Float,Float)])) -> Color
main = loop (Just [1..1000]) where loop :: Maybe [Int] -> IO () loop obj = do print obj resp <- getLine if resp == "clear" then loop Nothing else loop obj
f :: Integer -> Integer f x = let x2 = x*x in x2*x2
f :: Integer -> (Integer, Integer) f x = let x2 = x * x in (x2, x2+1) g :: Integer -> Integer g x = case f x of (y, z) -> y + z
type Nodetag = String type Neighbours = [Nodetag] data Node a = Node a Nodetag Neighbours
import Data.Maybe (fromJust) data Node a = Node { label :: a , adjacent :: [Node a] } data Graph a = Graph [Node a]
mkGraph :: Eq a => [(a, [a])] -> Graph a mkGraph links = Graph $ map snd nodeLookupList where mkNode (lbl, adj) = (lbl, Node lbl $ map lookupNode adj) nodeLookupList = map mkNode links lookupNode lbl = fromJust $ lookup lbl nodeLookupList
type Node = Int type Adj b = [(b, Node)] type Context a b = (Adj b, Node, a, Adj b) data Graph a b = Empty | Context a b & Graph a b
-- Graph we want to represent: -- .----> a <----. -- / \ -- b <------------. \ -- \ \ / -- `----> c ----> d -- Code for the graph: a = leaf b = node2 a c c = node1 d d = node2 a b -- Yes, it -- If you want to convert the graph to a Node-Label format: main = do g <- reifyGraph b --can print g
{- {- import Data.Reify import Control.Applicative import Data.Traversable --Pointer-based graph representation data PtrNode = PtrNode [PtrNode] --Label-based graph representation data LblNode lbl = LblNode [lbl] deriving Show --Convenience functions for our DSL leaf = PtrNode [] node1 a = PtrNode [a] node2 a b = PtrNode [a, b] -- This looks scary but we -- in our graph representation so they can be turned to labels instance MuRef PtrNode where type DeRef PtrNode = LblNode mapDeRef f (PtrNode as) = LblNode <$> (traverse f as)
import Data.Maybe import Data.Array class Enum b => Graph a b | a -> b where vertices :: a -> [b] edge :: a -> b -> b -> Maybe Double fromInt :: a -> Int -> b
f = id id id id id id id id id id id id id id id id id id id id id id id id id id id main = print $ f 8
id :: ((a -> a) -> (a -> a)) -> ((a -> a) -> (a -> a))
quickSort [] = [] quickSort (x:xs) = quickSort (filter (< x) xs) ++ [x] ++ quickSort (filter (>= x) xs)
foo x y = if condition1 then some (complicated set of combinators) (involving bigscaryexpression) else if condition2 then bigscaryexpression else Nothing where some x y = ... bigscaryexpression = ... condition1 = ... condition2 = ...
foo x y | condition1 = some (complicated set of combinators) (involving bigscaryexpression) | condition2 = bigscaryexpression | otherwise = Nothing where some x y = ... bigscaryexpression = ... condition1 = ... condition2 = ...
> square (square (2 * 2)) > square (square 4) > square (4 * 4) > square 16 > 16 * 16 > 256
> (square (square 2)) * (square (square 2)) > ((square 2) * (square 2)) * (square (square 2)) > ((2 * 2) * (square 2)) * (square (square 2)) > (4 * (square 2)) * (square (square 2)) > (4 * (2 * 2)) * (square (square 2)) > (4 * 4) * (square (square 2)) > 16 * (square (square 2)) > ... > 256
> (square (square 2)) * (square (square 2)) > ((square 2) * (square 2)) * ((square 2) * (square 2)) > ((2 * 2) * (2 * 2)) * ((2 * 2) * (2 * 2)) > (4 * 4) * (4 * 4) > 16 * 16 > 256
square (square (square 2)) || \/ * / \ \ / square (square 2) || \/ * / \ \ / * / \ \ / square 2 || \/ * / \ \ / * / \ \ / * / \ \ / 2
if (conditionOne && conditionTwo) { doSomething(); }
type | EmptyStack | StackNode of let rec append x y = match x with | EmptyStack -> y | StackNode(hd, tl) -> StackNode(hd, append tl y)
type | StackNode of Lazy< | EmptyStack let rec append x y = match x with | StackNode(item) -> Node(lazy(let hd, tl = item.Force(); hd, append tl y)) | Empty -> y
import time def now(): return time.time() def fibonacci(n): if n < 2: return n else: return fibonacci(n-1)+fibonacci(n-2) before1 = now() notlazy = [fibonacci(x) for x in range(20)] after1 = now() before2 = now() lazy = (fibonacci(x) for x in range(20)) after2 = now() before3 = now() for i in notlazy: print i after3 = now() before4 = now() for i in lazy: print i after4 = now() print "Not lazy generation: %f" % (after1-before1) print "Lazy generation: %f" % (after2-before2) print "Not lazy output: %f" % (after3-before3) print "Lazy output: %f" % (after4-before4)
fact = fix $ \f n -> if n == 0 then 1 else n * f (n-1)
def fix[A](f: A => A): A = f(fix(f)) val fact = fix[Int=>Int] { f => n => if (n == 0) 1 else n*f(n-1) }
def fix[A](f: (=>A) => A): A = f(fix(f)) def fact1(f: =>Int=>Int) = (n: Int) => if (n == 0) 1 else n*f(n-1) val fact = fix(fact1)
bool Function(void) { if (!SubFunction1()) return false; if (!SubFunction2()) return false; if (!SubFunction3()) return false; (etc) return true; }
bool Function(void) { if (!SubFunction1() || !SubFunction2() || !SubFunction3() || (etc) ) return false; return true; }
class Employee { private int supervisorId; private Employee supervisor; public Employee(int employeeId) { } public Employee Supervisor { get { return supervisor?? (supervisor = new Employee(supervisorId)); } } }
largestDivisible :: (Integral a) => a largestDivisible = head (filter p [100000,99999..]) where p x = x `mod` 3829 == 0
Prelude> :{ Prelude| let addTwo :: Int -> Int -> Int Prelude| addTwo x y = x + y Prelude| :} Prelude> addTwo 4 7 11
Prelude> let addTwo :: Int -> Int -> Int ; addTwo x y = x + y
Prelude> :set +m Prelude> let addTwo :: Int -> Int -> Int Prelude| addTwo x y = x + y Prelude| Prelude> addTwo 1 3 4
Prelude> :{ Prelude| let addTwo :: Int -> Int -> Int Prelude| addTwo x y = x + y Prelude| :} Prelude> addTwo 2 3 5
λ: addTwo x y = x + y λ: addTwo 1 2 3 λ: :t addTwo addTwo :: Num a => a -> a -> a
λ: let addTwo :: Int -> Int -> Int | addTwo x y = x + y | λ: addTwo 1 2 3
λ: addTwo 2.0 1.0 <interactive>:34:8: error: • No instance for (Fractional Int) arising from the literal ‘2.0’ • In the first argument of ‘addTwo’, namely ‘2.0’ In the expression: addTwo 2.0 1.0 In an equation for ‘it’: it = addTwo 2.0 1.0
GHCi, version 8.0.1.20161213: http: Prelude> f x = x * 2 Prelude> f 4 8
tails :: [a] -> [[a]] tails [] = [[]] tails xxs@(_:xs) = xxs : tails xs
let a @ (b @ (Just c), Just d) = (Just 1, Just 2) in (a, b, c, d)
{- DataKinds, PolyKinds, TypeFamilies, UndecidableInstances, GADTs, TypeOperators data (==) :: k -> k -> * where Refl :: x == x sym :: a == b -> b == a sym Refl = Refl data Nat = Zero | Succ Nat data SNat :: Nat -> * where SZero :: SNat Zero SSucc :: SNat n -> SNat (Succ n) type family a + b where Zero + b = b Succ a + b = Succ (a + b) addAssoc :: SNat a -> SNat b -> SNat c -> (a + (b + c)) == ((a + b) + c) addAssoc SZero b c = Refl addAssoc (SSucc a) b c = case addAssoc a b c of Refl -> Refl addComm :: SNat a -> SNat b -> (a + b) == (b + a) addComm SZero SZero = Refl addComm (SSucc a) SZero = case addComm a SZero of Refl -> Refl addComm SZero (SSucc b) = case addComm SZero b of Refl -> Refl addComm sa@(SSucc a) sb@(SSucc b) = case addComm a sb of Refl -> case addComm b sa of Refl -> case addComm a b of Refl -> Refl
(+.) :: SNat a -> SNat b -> SNat (a + b) SZero +. b = b SSucc a +. b = SSucc (a +. b) infixl 5 +. type family a * b where Zero * b = Zero Succ a * b = b + (a * b) (*.) :: SNat a -> SNat b -> SNat (a * b) SZero *. b = SZero SSucc a *. b = b +. (a *. b) infixl 6 *. mulDistL :: SNat a -> SNat b -> SNat c -> (a * (b + c)) == ((a * b) + (a * c)) mulDistL SZero b c = Refl mulDistL (SSucc a) b c = case sym $ addAssoc b (a *. b) (c +. a *. c) of -- At this point the target type is -- ((b + c) + (n * (b + c))) == (b + ((n * b) + (c + (n * c)))) -- The next step would be to update the RHS of the equivalence: Refl -> case addAssoc (a *. b) c (a *. c) of Refl -> _ -- but the type of this hole remains unchanged...
mulDistL mulDistL mulDistL (sym $ addAssoc b (a *. b) (c +. a *. c), addAssoc (a *. b) c (a *. c), addComm (a *. b) c, sym $ addAssoc c (a *. b) (a *. c), addAssoc b c (a *. b +. a *. c), mulDistL ) of (Refl, Refl, Refl, Refl, Refl, Refl) -> Refl
-- program to copy a file -- import System.Environment main = do --read command-line arguments [file1, file2] <- getArgs --copy file contents str <- readFile file1 writeFile file2 str
primes = sieve [2..] where sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0]
bottomUp :: (Ord a, Num a) => [[a]] -> a bottomUp = head . bu where bu [bottom] = bottom bu (row : base) = merge row $ bu base merge [] [_] = [] merge (x:xs) (y1:y2:ys) = x + max y1 y2 : merge xs (y2:ys)
data BubbleResult i o = BubbleResult { bestResult :: o , result :: o , leftoverRandoms :: [Double] } bubbleSearch :: (Ord result) => ([a] -> result) -> -- greedy search algorithm Double -> -- probability [a] -> -- list of items to be searched [Double] -> -- list of random numbers [BubbleResult a result] -- monotone list of results bubbleSearch search p startOrder rs = bubble startOrder rs where bubble order rs = BubbleResult answer answer rs : walk tries where answer = search order tries = perturbations p order rs walk ((order, rs) : rest) = if result > answer then bubble order rs else BubbleResult answer result rs : walk rest where result = search order perturbations :: Double -> [a] -> [Double] -> [([a], [Double])] perturbations p xs rs = xr where xr perturb :: [a] -> [Double] -> ([a], [Double]) perturb xs rs = shift_all p [] xs rs shift_all p new shift_all p new where shift_one :: [a] -> [a] -> [Double] -> ([a]->[a]->[Double]->b) -> b shift_one new where shift new shift new | r <= p = k (x:new | otherwise = shift new revApp xs ys = foldl (flip (:)) ys xs
> foobar " " ["is","there","such","a","function","?"] ["is there such a function ?"]
Prelude> import Data.List Prelude Data.List> intercalate " " ["is","there","such","a","function","?"] "is there such a function ?"
Prelude> import Data.List Prelude Data.List> concat (intersperse " " ["is","there","such","a","function","?"]) "is there such a function ?"
Prelude> unwords ["is","there","such","a","function","?"] "is there such a function ?"
joinBy sep cont = drop (length sep) $ concat $ map (\w -> sep ++ w) cont
join sep xs = foldr (\a b-> a ++ if b=="" then b else sep ++ b) "" xs join " " ["is","there","such","a","function","?"]
intercalate :: [a] -> [[a]] -> [a] intercalate s [] = [] intercalate s [x] = x intercalate s (x:xs) = x ++ s ++ (intercalate s xs) intersperse :: a -> [a] -> [a] intersperse s [] = [] intersperse s [x] = [x] intersperse s (x:xs) = x : s : (intersperse s xs)
*Main> mod 2 3 2 *Main> rem 2 3 2 *Main> mod 10 5 0 *Main> rem 10 5 0 *Main> mod 1 0 *** Exception: divide by zero *Main> rem 1 0 *** Exception: divide by zero *Main> mod 1 (-1) 0 *Main> rem 1 (-1) 0
5 `mod` 3 == 2 5 `rem` 3 == 2 5 `mod` (-3) == -1 5 `rem` (-3) == 2 (-5) `mod` 3 == 1 (-5) `rem` 3 == -2 (-5) `mod` (-3) == -2 (-5) `rem` (-3) == -2
fib n = (xs!!(n-1)) + (xs!!(n-2)) where xs = 0:1:map fib [2..]
fib1 = f fib2 n = f n fib3 n = f n where where where f i = xs !! i f i = xs !! i f i = xs !! i xs = map fib fib fib fib
zipWith :: (a->b->c) -> [a]->[b]->[c] zipWith op (n1:val1) (n2:val2) = (n1 + n2) : (zipWith op val1 val2) zipWith _ _ _ = []
[1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,4052739537881,6557470319842,10610209857723,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,190392490709135,308061521170129,498454011879264,806515533049393,1304969544928657,2111485077978050,3416454622906707,5527939700884757,8944394323791464,14472334024676221,23416728348467685,37889062373143906,61305790721611591,99194853094755497,160500643816367088,259695496911122585,420196140727489673,679891637638612258,1100087778366101931,1779979416004714189,2880067194370816120,4660046610375530309,7540113804746346429,12200160415121876738,19740274219868223167,31940434634990099905,51680708854858323072,83621143489848422977,135301852344706746049,218922995834555169026,354224848179261915075,573147844013817084101]
return :: a ~> m a flip (>>=) :: (a ~> m b) -> (m a ~> m b)
extract :: a <~ w a extend :: (a <~ w b) -> (w a <~ w b)
extract :: w a -> a extend :: (w a -> b) -> w a -> w b
data Car = Car { company :: String , model :: String , year :: Int } deriving (Show)
data Car a b c = Car { company :: a , model :: b , year :: c } deriving (Show)
data SBTree = Leaf String | Branch String SBTree SBTree
data BBTree = Leaf Bool | Branch Bool BBTree BBTree
data BTree a = Leaf a | Branch a (BTree a) (BTree a)
myFavoriteColor :: Color myFavoriteColor = Green 50
myFavoriteColor :: Color Bool myFavoriteColor = Green False
myFavoriteColor :: Color Int myFavoriteColor = Green 50
maybeHead :: [Int] -> Maybe Int maybeHead [] = Nothing maybeHead (x:_) = Just x > maybeHead [1,2,3] -- Just 1 > maybeHead [] -- None
maybeHead :: [t] -> Maybe t maybeHead [] = Nothing maybeHead (x:_) = Just x
doubleMaybe :: Maybe Int -> Maybe Int doubleMaybe Just x = Just (2*x) doubleMaybe Nothing= Nothing
-- Reader is a monad instance Monad (Reader env) -- and we have a function to get its environment ask :: Reader env env -- finally, we can run a Reader runReader :: Reader env a -> env -> a
import Control.Monad.Reader data GameState = NotOver | FirstPlayerWin | SecondPlayerWin | Tie data Game position = Game { getNext :: position -> [position], getState :: position -> GameState } getNext getNext = do game <- ask return $ getNext game position getState getState = do game <- ask return $ getState game position negamax :: Double -> position -> Reader (Game position) Double negamax color position = do state <- getState case state of FirstPlayerWin -> return color SecondPlayerWin -> return $ negate color Tie -> return 0 NotOver -> do possible <- getNext values <- mapM ((liftM negate) . negamax (negate color)) possible return $ maximum values
type CurrencyDict = Map CurrencyName Dollars currencyDict :: CurrencyDict
computePrice :: Reader CurrencyDict Dollars computePrice = do currencyDict <- ask --insert computation here
local :: (env -> env) -> Reader env a -> Reader env a
data Term = Apply Term Term | Lambda String Term | Var Term deriving (Show)
newtype Env = Env ([(String,Closure)]) type Closure = (Term, Env)
interp --when we have lambda term, we can just return it interp = do env <- ask return $ Lam nv (t, env) --when we run into a value we look it up in the environment interp = do (Env env) <- ask case lookup (show v) env of -- if it is not in the environment we have a problem Nothing -> return . Failure $ "unbound variable: " ++ (show v) -- if it is in the environment, then we should interpret it Just (term, env) -> local (const env) $ interp --the complicated case is an application interp = do v1 <- interp case v1 of Failure s -> return (Failure s) Lam nv clos -> local (\(Env ls) -> Env ((nv,clos):ls)) $ interp --I guess not that complicated!
interp :: Term -> Value interp term = runReader (interp
newtype Reader env a = Reader {runReader :: env -> a}
instance Functor (Reader env) where fmap f (Reader g) = Reader $ f . g
instance Monad (Reader env) where return x = Reader (\_ -> x) (Reader f) >>= g = Reader $ \x -> runReader (g (f x)) x
local f (Reader g) = Reader $ \x -> runReader g (f x)
instance Functor ((->) env) where fmap = (.) instance Monad ((->) env) where return = const f >>= g = \x -> g (f x) x
import Control.Applicative -- | A History with timeline type t and value type a. newtype History t a = History { observe :: t -> a } instance Functor (History t) where -- Apply a function to the contents of a historical value fmap f hist = History (f . observe hist) instance Applicative (History t) where -- A "pure" History is one that has the same value at all points in time pure = History . const -- This applies a function that changes over time to a value that also -- changes, by observing both at the same point in time. ff <*> fx = History $ \t -> (observe ff t) (observe fx t) instance Monad (History t) where return = pure ma >>= f = History $ \t -> observe (f (observe ma t)) t
-- | For any given day, the list of employees followed by the customers employeesAndCustomers :: History Day [Person] employeesAndCustomers = (++) <$> employees <*> customers
newtype Hypercube intersection value = Hypercube { get :: intersection -> value }
instance Functor (Hypercube intersection) where fmap f cube = Hypercube (f . get cube) instance Applicative (Hypercube intersection) where -- A "pure" Hypercube is one that has the same value at all intersections pure = Hypercube . const -- Apply each function in the @ff@ hypercube to its corresponding point -- in @fx@. ff <*> fx = Hypercube $ \x -> (get ff x) (get fx x)
m1 = ((filter odd [1..]) !!) m2 n = ((filter odd [1..]) !! n)
m1 :: Int -> Integer m2 :: (Integral a) => Int -> a
primes = filter isPrime [2..] where isPrime n = null [factor | factor <- [2..n-1], factor `divides` n] where f `divides` n = (n `mod` f) == 0
Prelude> show _ <interactive>:7:6: Found hole ‘_’ with type: a0 Where: ‘a0’ is an ambiguous type variable Relevant bindings include it :: String (bound at <interactive>:7:1) In the first argument of ‘show’, namely ‘_’ In the expression: show _ In an equation for ‘it’: it = show _
> show _ <interactive>:7:6: error: • Found hole: _h :: () Or perhaps ‘_h’ is mis-spelled, or not in scope • In the first argument of ‘show’, namely ‘_h’ In the expression: show _h In an equation for ‘it’: it = show _h • Relevant bindings include it :: String (bound at <interactive>:7:1)
<interactive>:3:1: error: • Ambiguous type variable ‘a0’ arising from a use of ‘show’ prevents the constraint ‘(Show a0)’ from being solved. Probable fix: use a type annotation to specify what ‘a0’ should be. These potential instances exist: instance Show Ordering -- Defined in ‘GHC.Show’ instance Show Integer -- Defined in ‘GHC.Show’ instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’ ...plus 22 others ...plus 11 instances involving out-of-scope types (use -fprint-potential-instances to see them all) • In the expression: show _ In an equation for ‘it’: it = show _ <interactive>:3:6: error: • Found hole: _ :: a0 Where: ‘a0’ is an ambiguous type variable • In the first argument of ‘show’, namely ‘_’ In the expression: show _ In an equation for ‘it’: it = show _ • Relevant bindings include it :: String (bound at <interactive>:3:1)
lend amount balance = let reserve = 100 newBalance = balance - amount in if balance < reserve then Nothing else Just newBalance
case maybeVal of Nothing -> "There is nothing!" Just val -> "There is a value, and it is " ++ (show val)
case maybeVal of Nothing -> Nothing -- there is nothing, so just return Nothing Just val -> Just (f val) -- there is a value, so apply the function to it
if balance < reserve then (Nothing :: Maybe nb) -- same type else (Just newBalance :: Maybe nb) -- same type
f Int String :: ((String → Int) → String → Int) → Int
myObject :: ∀r.(∀a.(a → Int, a -> String) → a → r) → r
myObject String (Λa. λ(length, name):(a → Int, a → String). λobjData:a. name objData)
{- {- type ShowBox = forall b. (forall a. Show a => a -> b) -> b mkShowBox :: Show a => a -> ShowBox mkShowBox x = \k -> k x -- | This is the key function for using a -- a function @k@ that will be applied to the contents of the -- ShowBox. But you don -- ShowBox does. However, it -- implements @Show@, so you know that whatever type it picks, you -- can use the runShowBox :: forall b. (forall a. Show a => a -> b) -> ShowBox -> b -- Expanded type: -- -- runShowBox -- :: forall b. (forall a. Show a => a -> b) -- -> (forall b. (forall a. Show a => a -> b) -> b) -- -> b -- runShowBox k box = box k example :: [ShowBox] -- example :: [ShowBox] expands to this: -- -- example :: [forall b. (forall a. Show a => a -> b) -> b] -- -- Without the annotation the compiler infers the following, which -- breaks in the definition of -- -- example :: forall b. [(forall a. Show a => a -> b) -> b] -- example = [mkShowBox 5, mkShowBox "foo"] result :: [String] result = map (runShowBox show) example
data Country = BigEnemy | MediumEnemy | PunyEnemy | TradePartner | Ally | BestAlly
f g = launchMissilesAt $ g [BigEnemy, MediumEnemy, PunyEnemy]
data IEmployeeVisitor r = IEmployeeVisitor { visitPermanent :: PermanentEmployee -> r, visitContractor :: Contractor -> r } newtype IEmployee = IEmployee { accept :: forall r. IEmployeeVisitor r -> r }
type WithId<T> = T & { id: number } type Identifier = <T>(obj: T) => WithId<T> type Identify = <TObj>(obj: TObj, f: Identifier) => WithId<TObj>
--Get Number of Divisors of n numDivs :: Integer -> Integer numDivs n = toInteger $ length [ x | x<-[2.. ((n `quot` 2)+1)], n `rem` x == 0] + 2 --Generate a List of Triangular Values triaList :: [Integer] triaList = [foldr (+) 0 [1..n] | n <- [1..]] --The same recursive triaList2 = go 0 1 where go cs n = (cs+n):go (cs+n) (n+1) --Finds the first triangular Value with more than n Divisors sol :: Integer -> Integer sol n = head $ filter (\x -> numDivs(x)>n) triaList2
$ time ./A +RTS -s ./A +RTS -s 749700 9,961,432,992 bytes allocated in the heap 2,463,072 bytes copied during GC 29,200 bytes maximum residency (1 sample(s)) 187,336 bytes maximum slop **2 MB** total memory in use (0 MB lost due to fragmentation) Generation 0: 19002 collections, 0 parallel, 0.11s, 0.15s elapsed Generation 1: 1 collections, 0 parallel, 0.00s, 0.00s elapsed INIT time 0.00s ( 0.00s elapsed) MUT time 13.15s ( 13.32s elapsed) GC time 0.11s ( 0.15s elapsed) RP time 0.00s ( 0.00s elapsed) PROF time 0.00s ( 0.00s elapsed) EXIT time 0.00s ( 0.00s elapsed) Total time 13.26s ( 13.47s elapsed) %GC time **0.8%** (1.1% elapsed) Alloc rate 757,764,753 bytes per MUT second Productivity 99.2% of total user, 97.6% of total elapsed ./A +RTS -s 13.26s user 0.05s system 98% cpu 13.479 total
$ ghc -O2 --make A.hs -prof -auto-all [1 of 1] Compiling Main ( A.hs, A.o ) Linking A ...
$ time ./A +RTS -p 749700 ./A +RTS -p 13.23s user 0.06s system 98% cpu 13.547 total
Sun Jul 18 10:08 2010 Time and Allocation Profiling Report (Final) A +RTS -p -RTS total time = 13.18 secs (659 ticks @ 20 ms) total alloc = 4,904,116,696 bytes (excludes profiling overheads) COST CENTRE MODULE %time %alloc numDivs Main 100.0 100.0
toInteger $ length [ x | x<-[2.. ((n `quot` 2)+1)], n `rem` x == 0] + 2
numDivs n = fromIntegral $ 2 + (U.length $ U.filter (\x -> fromIntegral n `rem` x == 0) $ (U.enumFromN 2 ((fromIntegral n `div` 2) + 1) :: U.Vector Int))
$ time ./Z 749700 ./Z 3.73s user 0.01s system 99% cpu 3.753 total
triaList = U.scanl (+) 0 (U.enumFrom 1 top) where top = 10^6
sol :: Int -> Int sol n = U.head $ U.filter (\x -> numDivs x > n) triaList
typedef enum { MONOME_BUTTON_UP = 0x00, MONOME_BUTTON_DOWN = 0x01, MONOME_ENCODER_DELTA = 0x02, MONOME_ENCODER_KEY_UP = 0x03, MONOME_ENCODER_KEY_DOWN = 0x04, MONOME_TILT = 0x05, MONOME_EVENT_MAX = 0x06 } monome_event_type_t; typedef struct monome monome_t; typedef struct monome_event monome_event_t; typedef void (*monome_event_callback_t) (const monome_event_t *event, void *data); struct monome_event { monome_t *monome; monome_event_type_t event_type; __extension__ union { struct { unsigned int x; unsigned int y; } grid; struct { unsigned int number; int delta; } encoder; struct { unsigned int sensor; int x; int y; int z; } tilt; }; };
struct monome_event { monome_t *monome; monome_event_type_t event_type; __extension__ union { struct me_grid { unsigned int x; unsigned int y; } grid; struct me_encoder { unsigned int number; int delta; } encoder; struct me_tilt { unsigned int sensor; int x; int y; int z; } tilt; }; };
quicksort [] = [] quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater) where lesser = filter (< p) xs greater = filter (>= p) xs
void qsort(int a[], int lo, int hi) { int h, l, p, t; if (lo < hi) { l = lo; h = hi; p = a[hi]; do { while ((l < h) && (a[l] <= p)) l = l+1; while ((h > l) && (a[h] >= p)) h = h-1; if (l < h) { t = a[l]; a[l] = a[h]; a[h] = t; } } while (l < h); a[hi] = a[l]; a[l] = p; qsort( a, lo, l-1 ); qsort( a, l+1, hi ); } }
import qualified Data.Vector.Generic as V import qualified Data.Vector.Generic.Mutable as M qsort :: (V.Vector v a, Ord a) => v a -> v a qsort = V.modify go where go xs | M.length xs < 2 = return () | otherwise = do p <- M.read xs (M.length xs `div` 2) j <- M.unstablePartition (< p) xs let (l, pr) = M.splitAt j xs k <- M.unstablePartition (== p) pr go l; go $ M.drop k pr
import Control.Monad import Data.Array.IO import Data.IORef qsort :: IOUArray Int Int -> Int -> Int -> IO () qsort a lo hi = do (h,l,p,t) <- liftM4 (,,,) z z z z when (lo < hi) $ do l .= lo h .= hi p .=. (a!hi) doWhile (get l .< get h) $ do while ((get l .< get h) .&& ((a.!l) .<= get p)) $ do modifyIORef l succ while ((get h .> get l) .&& ((a.!h) .>= get p)) $ do modifyIORef h pred b <- get l .< get h when b $ do t .=. (a.!l) lVal <- get l hVal <- get h writeArray a lVal =<< a!hVal writeArray a hVal =<< get t lVal <- get l writeArray a hi =<< a!lVal writeArray a lVal =<< get p hi qsort a lo hi' lo qsort a lo
let z :: IO (IORef Int) z = newIORef 0 (.=) = writeIORef ref .=. action = do v <- action; ref .= v (!) = readArray (.!) a ref = readArray a =<< get ref get = readIORef (.<) = liftM2 (<) (.>) = liftM2 (>) (.<=) = liftM2 (<=) (.>=) = liftM2 (>=) (.&&) = liftM2 (&&) -- ... where doWhile cond foo = do foo b <- cond when b $ doWhile cond foo while cond foo = do b <- cond when b $ foo >> while cond foo
main = do a <- (newListArray (0,9) [10,9..1]) :: IO (IOUArray Int Int) printArr a putStrLn "Sorting..." qsort a 0 9 putStrLn "Sorted." printArr a where printArr a = mapM_ (\x -> print =<< readArray a x) [0..9]
main = putStrLn (show (quicksort [8, 6, 7, 5, 3, 0, 9]))
qsort xs = qsort qsort qsort qsort qpart [] as bs r = qsort qpart (x | x
tsort :: (Ord a) => [a] -> [a] tsort [] = [] tsort (x:xs) = tsort [a | a<-xs, a<x] ++ x:[b | b<-xs, b==x] ++ tsort [c | c<-xs, c>x]
psort xs = concat $ pass xs [] pass [] xss = xss pass (x:xs) xss = step xs [] [x] [] xss where step [] as bs cs xss = pass as (bs:pass cs xss) step (x | x | x
tqsort xs = tqsort tqsort tqsort qpart [] as bs cs r = tqsort qpart (x | x | x
qsort [] = [] qsort [x] = [x] qsort [x, y] = [min x y, max x y] qsort (x:y:z:rest) = qsort (filter (< m) (s:rest)) ++ [m] ++ qsort (filter (>= m) (l:rest)) where xs = [x, y, z] [s, m, l] = [minimum xs, median xs, maximum xs]
readMaybe :: (Read a) => String -> Maybe a readMaybe s = case reads s of [(x, "")] -> Just x _ -> Nothing
readMaybe :: (Read a) => String -> Maybe a readMaybe s = case [x | (x,t) <- reads s, ("","") <- lex t] of [x] -> Just x _ -> Nothing
-- file: ch14/State.hs newtype State s a = State runState :: s -> (a, s) }
type State s = StateT s Identity type Writer w = WriterT w Identity type Reader r = ReaderT r Identity
pcre_ptr <- c_pcre_compile pattern (combineOptions flags) errptr erroffset nullPtr if pcre_ptr == nullPtr then do err <- peekCString =<< peek errptr return (Left err) else do reg <- newForeignPtr finalizerFree pcre_ptr -- release with free() return (Right (Regex reg str))
mean :: [Double] -> Double mean xs = sum xs / fromIntegral (length xs)
myAny :: (a -> Bool) -> [a] -> Bool myAny p list = foldl step False list where step acc item = p item || acc
myAny even [1..] foldl step False [1..] step (foldl step False [2..]) 1 even 1 || (foldl step False [2..]) False || (foldl step False [2..]) foldl step False [2..] step (foldl step False [3..]) 2 even 2 || (foldl step False [3..]) True || (foldl step False [3..]) True
myAny even [1..] foldl step False [1..] foldl step (step False 1) [2..] foldl step (step (step False 1) 2) [3..] foldl step (step (step (step False 1) 2) 3) [4..]
(<*>) :: Applicative a => a (s -> t) -> a s -> a t (>>=) :: Monad m => m s -> (s -> m t) -> m t
miffy :: Monad m => m Bool -> m x -> m x -> m x miffy mb mt mf = do b <- mb if b then mt else mf
iffy :: Applicative a => a Bool -> a x -> a x -> a x iffy ab at af = pure cond <*> ab <*> at <*> af where cond b t f = if b then t else f
(>>>>==) :: (Monad m, Monad n) => m (n s) -> (s -> m (n t)) -> m (n t) mns >>>>== f = mns >>-{-m-} \ ns -> let nmnt = ns >>= (return . f) in ???
(<<**>>) :: (Applicative a, Applicative b) => a (b (s -> t)) -> a (b s) -> a (b t) abf <<**>> abs = pure (<*>) <*> abf <*> abs
app :: [String -> (a -> b)] -> [String -> a] -> [String -> b] app f x = (<*>) <$> f <*> x
app :: (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
data Foo = Bar { a :: Integer, b :: String, c :: String }
walkDuck x = Bar { a = a x, b = b x, c = lemonadeStand (a x) (b x) }
> data Foo = Foo { a :: Int, b :: Int, c :: String } -- define a Foo > let foo = Foo { a = 1, b = 2, c = "Hello" } -- create a Foo > let updateFoo x = x { c = "Goodbye" } -- function to update Foos > updateFoo foo -- update the Foo Foo {a = 1, b = 2, c = "Goodbye" }
data Foo = Foo { a :: Int, b :: Int , c :: String } test = Foo 1 2 "Hello"
data Foo = Foo { a :: Int, b :: Int , c :: String } test = Foo 1 2 "Hello"
type Coord = (Float,Float) data Obj = Player { oPos :: Coord, oDims :: Coord }
(<*>) :: f (a -> b) -> f a -> f b (*>) :: f a -> f b -> f b (<*) :: f a -> f b -> f a
class (Functor f) => StrongLaxMonoidalFunctor f where . . .
maybeNot :: Maybe Bool -> Maybe Bool maybeNot = fmap not
maybeAnd :: Maybe Bool -> Maybe Bool -> Maybe Bool maybeAnd x y = do x y return (x
class Functor f where fmap :: (a -> b) -> f a -> f b class Monoid a where mempty :: a mappend :: a -> a -> a
class (Functor f) => MonoidalFunctor f where mfEmpty :: f ? mfAppend :: f ? -> f ? -> f ?
class (Functor f) => MonoidalFunctor f where mfEmpty :: f () mfAppend :: f a -> f b -> f ?
class (Functor f) => MonoidalFunctor f where mfEmpty :: f () mfAppend :: f a -> f b -> f (a, b)
mfPure x = fmap (\() -> x) mfEmpty mfApply f x = fmap (\(f, x) -> f x) (mfAppend f x)
(<*>) -- Tie Fighter (*>) -- Right Tie (<*) -- Left Tie pure -- also called "return"
> printf "%d\n" 3 3 > printf "%s %f %d" "foo" 3.3 3 foo 3.3 3
> :t printf "%d\n" "foo" printf "%d\n" "foo" :: (PrintfType ([Char] -> t)) => t
class PrintfType r printf :: PrintfType r => String -> r
instance (PrintfArg x, PrintfType r) => PrintfType (x -> r)
{- foo :: FooType a => a foo = bar (return ()) class FooType a where bar :: IO () -> a instance FooType (IO ()) where bar = id instance (Show x, FooType r) => FooType (x -> r) where bar s x = bar (s >> print x)
*Main> foo 3 :: IO () 3 *Main> foo 3 "hello" :: IO () 3 "hello" *Main> foo 3 "hello" True :: IO () 3 "hello" True
class Testable a instance Testable Bool instance (Arbitrary x, Testable r) => Testable (x -> r)
f :: State s a f = State $ \x -> y where y = ... x ...
f :: State s a f = State $ \x -> let y = ... x ... in y
f x | cond1 x = a | cond2 x = g a | otherwise = f (h x a) where a = w x f x = let a = w x in case () of _ | cond1 x = a | cond2 x = g a | otherwise = f (h x a)
Declaration style | Expression-style --------------------------------------+--------------------------------------------- where clause | let expression arguments LHS: f x = x*x | Lambda abstraction: f = \x -> x*x Pattern matching: f [] = 0 | case expression: f xs = case xs of [] -> 0 Guards: f [x] | x>0 =
f x y | y>z = ... | y==z = ... | y<z = ... where z = x*x
f :: State s a f = State $ \x -> y where y = ... x ...
module StateExample where data State a s = State (s -> (a, s)) f1 :: State Int (Int, Int) f1 = State $ \state@(a, b) -> let hypot = a^2 + b^2 result = (hypot, state) in result f2 :: State Int (Int, Int) f2 = State f where f state@(a, b) = result where hypot = a^2 + b^2 result = (hypot, state)
hasVowel [] = False hasVowel (x:xs) | x `elem` vowels = True | otherwise = False where vowels = "AEIOUaeiou"
{- {- {- import GHC.TypeLits data Container (xs::[*]) = Container
data Nat1 = Zero | Succ Nat1 type family Replicate (n::Nat1) x :: [*] type instance Replicate Zero x = type instance Replicate (Succ n) x = x type LotsOfStrings = Replicate (Succ (Succ (Succ (Succ (Succ Zero))))) String
ghci> :t undefined :: Container (Replicate (Succ (Succ (Succ (Succ (Succ Zero))))) String)
import GHC.TypeLits data Container (xs::[*]) = Container
buildManager :: Phase -> IO () buildManager phase = do let buildSeq = findSeq phase jid = JobID $ pack "8" config = MkConfig $ Just jid flip C.catch exceptionHandler $ runReaderT (sequence_ $ buildSeq <*> stages) config -- ^^ I would really like to keep the above line of code, or something like it. return ()
foo :: Stage -> ReaderT Config IO () data Config = MkConfig (Either JobID Product) BaseDir JobMap
ireturn :: a -> m i i a -- returning a pure value preserves state ibind :: m i j a -> -- we can go from i to j and get an a, thence (a -> m j k b) -- we can go from j to k and get a b, therefore -> m i k b -- we can indeed go from i to k and get a b
a -> m i j b -- values a in, b out; state transition i to j
icomp :: IxMonad m => (b -> m j k c) -> (a -> m i j b) -> a -> m i k c icomp f g = \ a -> ibind (g a) f
ireturn `icomp` g = g f `icomp` ireturn = f (f `icomp` g) `icomp` h = f `icomp` (g `icomp` h)
g(); skip = g() skip; f() = f() {h(); g()}; f() = h(); {g(); f()}
data DVDDrive :: Bool -> Bool -> * -> * where -- Bool is "drive full?" DReturn :: a -> DVDDrive i i a DInsert :: DVD -> -- you have a DVD DVDDrive True k a -> -- you know how to continue full DVDDrive False k a -- so you can insert from empty DEject :: (DVD -> -- once you receive a DVD DVDDrive False k a) -> -- you know how to continue empty DVDDrive True k a -- so you can eject when full instance IxMonad DVDDrive where -- put these methods where they need to go ireturn = DReturn -- so this goes somewhere else ibind (DReturn a) k = k a ibind (DInsert dvd j) k = DInsert dvd (ibind j k) ibind (DEject j) k = DEject j $ \ dvd -> ibind (j dvd) k
dInsert :: DVD -> DVDDrive False True () dInsert dvd = DInsert dvd $ DReturn () dEject :: DVDrive True False DVD dEject = DEject $ \ dvd -> DReturn dvd
discSwap :: DVD -> DVDDrive True True DVD discSwap dvd = do dvd
discSwap :: DVD -> DVDDrive True True DVD discSwap dvd = do dInsert dvd; dEject -- ouch!
data DVDCommand :: Bool -> Bool -> * -> * where InsertC :: DVD -> DVDCommand False True () EjectC :: DVDCommand True False DVD
data CommandIxMonad :: (state -> state -> * -> *) -> state -> state -> * -> * where CReturn :: a -> CommandIxMonad c i i a (:?) :: c i j a -> (a -> CommandIxMonad c j k b) -> CommandIxMonad c i k b instance IxMonad (CommandIxMonad c) where ireturn = CReturn ibind (CReturn a) k = k a ibind (c :? j) k = c :? \ a -> ibind (j a) k
type f :-> g = forall state. f state -> g state class MonadIx (m :: (state -> *) -> (state -> *)) where returnIx :: x :-> m x flipBindIx :: (a :-> m b) -> (m a :-> m b) -- tidier than bindIx
bindIx :: forall i. m a i -> (forall j. a j -> m b j) -> m b i
class IMonad m where ireturn :: a -> m i i a ibind :: m i j a -> (a -> m j k b) -> m i k b
class IMonad m where ireturn :: a ~> m a ibind :: (a ~> m b) -> (m a ~> m b)
blueToRed :: State S () blueToBlue :: State S () foo :: State S () foo = do blueToRed blueToBlue
data Red data Blue -- assume a new indexed State monad blueToRed :: State S Blue Red () blueToBlue :: State S Blue Blue () foo :: State S ?? ?? () foo = blueToRed `ibind` \_ -> blueToBlue -- type error
push :: a -> State old (a,old) () pop :: State (a,new) new a
openFile :: IO any FilesAccessed () newIORef :: a -> IO any any (IORef a) -- no operation of type :: IO any NoAccess _
para :: (a -> [a] -> b -> b) -> b -> [a] -> b para f base = h where h [] = base h (x:xs) = f x xs (h xs)
para :: (a -> [a] -> b -> b) -> b -> [a] -> b foldr :: (a -> b -> b) -> b -> [a] -> b para c n (x : xs) = c x xs (para c n xs) foldr c n (x : xs) = c x (foldr c n xs) para c n [] = n foldr c n [] = n
suff :: [x] -> [[x]] suff = para (\ x xs suffxs -> xs : suffxs) []
suff "suffix" = ["uffix", "ffix", "fix", "ix", "x", ""]
safeTail :: [x] -> Maybe [x] safeTail = para (\ _ xs _ -> Just xs) Nothing
foldr c n = para (\ x xs t -> c x t) n para c n = snd . foldr (\ x (xs, t) -> (x : xs, c x xs t)) ([], n)
cata :: Functor f => (f t -> t) -> Fix f -> t para :: Functor f => (f (Fix f, t) -> t) -> Fix f -> t cata phi (In ff) = phi (fmap (cata phi) ff) para psi (In ff) = psi (fmap keepCopy ff) where keepCopy x = (x, para psi x)
para psi = snd . cata (\ fxt -> (In (fmap fst fxt), psi fxt))
nthElement :: [a] -> Int -> Maybe a nthElement [] a = Nothing nthElement (x:xs) a | a <= 0 = Nothing | a == 1 = Just x | a > 1 = nthElement xs (a-1) nthElementIf :: [a] -> Int -> Maybe a nthElementIf [] a = Nothing nthElementIf (x:xs) a = if a <= 1 then if a <= 0 then Nothing else Just x -- a == 1 else nthElementIf xs (a-1) nthElementCases :: [a] -> Int -> Maybe a nthElementCases [] a = Nothing nthElementCases (x:xs) a = case a <= 0 of True -> Nothing False -> case a == 1 of True -> Just x False -> nthElementCases xs (a-1)
let absOfN = if n < 0 -- Single binary expression then -n else n
case mapping of Constant v -> const v Function f -> map f
handle ExitSuccess = return () handle (ExitFailure code) | code < 0 = putStrLn . ("internal error " ++) . show . abs $ code | otherwise = putStrLn . ("user error " ++) . show $ code
-- NO! nthElement (x:xs) a | a <= 0 = Nothing | a == 1 = Just x | a > 1 = nthElement xs (a-1) -- Much more compact! Look at those spaces we didn nthElement (x:xs) a | a <= 0 = Nothing | a == 1 = Just x | otherwise = nthElement xs (a-1)
nthElement xs n = guard (n > 0) >> listToMaybe (drop (n-1) xs)
nthElement :: [a] -> Int -> Maybe a nthElement [] a = Nothing nthElement (x:xs) a = if a < 1 then Nothing else if a == 1 then Just x else nthElement xs (a-1)
main :: IO () main = do str <- getLine let no = fst . head $ reads str :: Integer ...
return :: a -> IO a return a = \rw -> (a,rw) (>>=) :: IO a -> (a -> IO b) -> IO b ioa >>= fn = \rw -> let (a,rw
main = getLine >>= \str -> let no = (fst . head $ reads str :: Integer) in ...
(g plus3) = (λ f. (f (f (succ 0)))(λ x . (succ (succ (succ x)))) = ((λ x. (succ (succ (succ x)))((λ x. (succ (succ (succ x)))) (succ 0))) = ((λ x. (succ (succ (succ x)))) (succ (succ (succ (succ 0))))) = (succ (succ (succ (succ (succ (succ (succ 0)))))))
RealWorld pureScanf(RealWorld world, const char* format, ...);
int compute_sum_of_squares (int min, int max) { int result = 0; for (int i = min; i < max; ++ i) result += i * i; return result; }
int compute_sum_of_squares (int min, int max) { if (min >= max) return 0; else return min * min + compute_sum_of_squares(min + 1, max); }
$ hoogle --help Hoogle v4.2.8, (C) Neil Mitchell 2004-2011 http: hoogle [COMMAND] ... [OPTIONS] Commands: [search] Perform a search data Generate Hoogle databases server Start a Hoogle server combine Combine multiple databases into one convert Convert an input file to a database test Run tests dump Dump sections of a database to stdout rank Generate ranking information log Analyse log files Common flags: -? --help Display help message -V --version Print version information -v --verbose Loud verbosity -q --quiet Quiet verbosity
$ hoogle No query entered Try --help for command line options $ hoogle data (downloads databases...takes a few minutes)
$cd .cabal/share/hoogle-4.2.8/databases $hoogle combine base.hoo $hoogle foldl\' Data.List foldl Data.Foldable foldl
instance TH_Render Body where render (NormalB exp) = build render (GuardedB guards) = build
-- Generate an intance of the class TH_Render for the type typName gen_render :: Name -> Q [Dec] gen_render typName = do (TyConI d) <- reify typName -- Get all the information on the type (type_name,_,_,constructors) <- typeInfo (return d) -- extract name and constructors i_dec <- gen_instance (mkName "TH_Render") (conT type_name) constructors -- generation function for method "render" [(mkName "render", gen_render)] return [i_dec] -- return the instance declaration -- function to generation the function body for a particular function -- and constructor where gen_render (conName, components) vars -- function name is based on constructor name = let funcName = makeName $ unCapalize $ nameBase conName -- choose the correct builder function headFunc = case vars of [] -> "func_out" otherwise -> "build" -- build in appsE $ (varE $ mkName headFunc):funcName:vars -- put it all together -- equivalent to makeName funcStr = (appE (varE (mkName "mkName")) (litE $ StringL funcStr))
type Constructor = (Name, [(Maybe Name, Type)]) -- the list of constructors type Cons_vars = [ExpQ] -- A list of variables that bind in the constructor type Function_body = ExpQ type Gen_func = Constructor -> Cons_vars -> Function_body type Func_name = Name -- The name of the instance function we will be creating -- For each function in the instance we provide a generator function -- to generate the function body (the body is generated for each constructor) type Funcs = [(Func_name, Gen_func)]
-- construct an instance of class class_name for type for_type -- funcs is a list of instance method names with a corresponding -- function to build the method body gen_instance :: Name -> TypeQ -> [Constructor] -> Funcs -> DecQ gen_instance class_name for_type constructors funcs = instanceD (cxt []) (appT (conT class_name) for_type) (map func_def funcs) where func_def (func_name, gen_func) = funD func_name -- method name -- generate function body for each constructor (map (gen_clause gen_func) constructors)
-- Generate the pattern match and function body for a given method and -- a given constructor. func_body is a function that generations the -- function body gen_clause :: (Constructor -> [ExpQ] -> ExpQ) -> Constructor -> ClauseQ gen_clause func_body data_con@(con_name, components) = -- create a parameter for each component of the constructor do vars <- mapM var components -- function (unnamed) that pattern matches the constructor -- mapping each component to a value. (clause [(conP con_name (map varP vars))] (normalB (func_body data_con (map varE vars))) []) -- create a unique name for each component. where var (_, typ) = newName $ case typ of (ConT name) -> toL $ nameBase name otherwise -> "parm" where toL (x:y) = (toLower x):y unCapalize :: [Char] -> [Char] unCapalize (x:y) = (toLower x):y
typeInfo :: DecQ -> Q (Name, [Name], [(Name, Int)], [(Name, [(Maybe Name, Type)])]) typeInfo m = do d <- m case d of d@(DataD _ _ _ _ _) -> return $ (simpleName $ name d, paramsA d, consA d, termsA d) d@(NewtypeD _ _ _ _ _) -> return $ (simpleName $ name d, paramsA d, consA d, termsA d) _ -> error ("derive: not a data type declaration: " ++ show d) where consA (DataD _ _ _ cs _) = map conA cs consA (NewtypeD _ _ _ c _) = [ conA c ] {- This part no longer works on 7.6.3 paramsA (DataD _ _ ps _ _) = ps paramsA (NewtypeD _ _ ps _ _) = ps -} -- Use this on more recent GHC rather than the above paramsA (DataD _ _ ps _ _) = map nameFromTyVar ps paramsA (NewtypeD _ _ ps _ _) = map nameFromTyVar ps nameFromTyVar (PlainTV a) = a nameFromTyVar (KindedTV a _) = a termsA (DataD _ _ _ cs _) = map termA cs termsA (NewtypeD _ _ _ c _) = [ termA c ] termA (NormalC c xs) = (c, map (\x -> (Nothing, snd x)) xs) termA (RecC c xs) = (c, map (\(n, _, t) -> (Just $ simpleName n, t)) xs) termA (InfixC t1 c t2) = (c, [(Nothing, snd t1), (Nothing, snd t2)]) conA (NormalC c xs) = (simpleName c, length xs) conA (RecC c xs) = (simpleName c, length xs) conA (InfixC _ c _) = (simpleName c, 2) name (DataD _ n _ _ _) = n name (NewtypeD _ n _ _ _) = n name d = error $ show d simpleName :: Name -> Name simpleName nm = let s = nameBase nm in case dropWhile (/= [] -> mkName s _:[] -> mkName s _:t -> mkName t
x = fix (\vs -> 1 : map (2*) vs) x = fix ((1:) . map (2*))
x = fix (liftA2 (.) (:) (map . (*) . (*2)) 1) x = fix (((.) <$> (:) <*> (map . (*) . (*2))) 1) x = fix (((<$>) <$> (:) <*> (map <$> (*) <$> (*2))) 1)
map f x = x >>= return . f map f x = ((:[]) <$> f) =<< x
map = (=<<) . ((:[]) <$>) map = (=<<) <$> ((:[]) <$>) map = (<$> ((:[]) <$>)) (=<<)
x = fix (((<$>) <$> (:) <*> ((<$> ((:[]) <$>)) (=<<) <$> (*) <$> (*2))) 1)
x=fix(((<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2)))1)
Jan 25 23:47:23 <olsner> @pl let q = 2 : map (2*) q in q Jan 25 23:47:23 <lambdabot> fix ((2 :) . map (2 *))
fix$(<$>)<$>(:)<*>((<$>((:[{- Jörð -}])<$>))(=<<)<$>(*)<$>(>>=)(+)($))$1
-- | Since -- reasoning tool of \"ex falso quodlibet\". absurd :: Void -> a
simple :: Either Void a -> a simple (Left x) = absurd x simple (Right y) = y
data Pipe a b r = Pure r | Await (a -> Pipe a b r) | Yield !b (Pipe a b r)
foldConsumer :: (r -> s) -> ((a -> s) -> s) -> Consumer a r -> s foldConsumer onPure onAwait p = case p of Pure x -> onPure x Await f -> onAwait $ \x -> foldConsumer onPure onAwait (f x) Yield x _ -> absurd x
data Tm a = Var a | Tm a :$ Tm a | Lam (Tm (Maybe a))
instance Functor Tm where fmap rho (Var a) = Var (rho a) fmap rho (f :$ s) = fmap rho f :$ fmap rho s fmap rho (Lam t) = Lam (fmap (fmap rho) t) instance Monad Tm where return = Var Var a >>= sig = sig a (f :$ s) >>= sig = (f >>= sig) :$ (s >>= sig) Lam t >>= sig = Lam (t >>= maybe (Var Nothing) (fmap Just . sig))
data Val b = b :$$ [Val b] -- a stuck application | forall a. LV (a -> Val b) (Tm (Maybe a)) -- we have an incomplete environment
eval :: (a -> Val b) -> Tm a -> Val b eval g (Var a) = g a eval g (f :$ s) = eval g f $$ eval g s where (b :$$ vs) $$ v = b :$$ (vs ++ [v]) -- stuck application gets longer LV g t $$ v = eval (maybe v g) t -- an applied lambda gets unstuck eval g (Lam t) = LV g t
class Differentiable f where type D f :: * -> * -- an f with a hole plug :: (D f x, x) -> f x -- plugging a child in the hole newtype K a x = K a -- no children, just a label newtype I x = I x -- one child data (f :+: g) x = L (f x) -- choice | R (g x) data (f :*: g) x = f x :&: g x -- pairing instance Differentiable (K a) where type D (K a) = K Void -- no children, so no way to make a hole plug (K v, x) = absurd v -- can
instance Differentiable I where type D I = K () plug (K (), x) = I x instance (Differentiable f, Differentiable g) => Differentiable (f :+: g) where type D (f :+: g) = D f :+: D g plug (L df, x) = L (plug (df, x)) plug (R dg, x) = R (plug (dg, x)) instance (Differentiable f, Differentiable g) => Differentiable (f :*: g) where type D (f :*: g) = (D f :*: g) :+: (f :*: D g) plug (L (df :&: g), x) = plug (df, x) :&: g plug (R (f :&: dg), x) = f :&: plug (dg, x)
data Term f x = Var x | Con (f (Term f x)) -- the Free monad, yet again
data RuleSet a = Known !a | Unknown String data GoRuleChoices = Japanese | Chinese type LinesOfActionChoices = Void type GoRuleSet = RuleSet GoRuleChoices type LinesOfActionRuleSet = RuleSet LinesOfActionChoices
handleLOARules :: (String -> a) -> LinesOfActionsRuleSet -> a handleLOARules f r = case r of Known a -> absurd a Unknown s -> f s
shrink : (xs : Vect (S n) a) -> Elem x xs -> Vect n a shrink (x :: ys) Here = ys shrink (y :: []) (There p) = absurd p shrink (y :: (x :: xs)) (There p) = y :: shrink (x :: xs) p
Prelude> :info map map :: (a -> b) -> [a] -> [b] -- Defined in ‘GHC.Base’
Prelude> :info fmap class Functor (f :: * -> *) where fmap :: (a -> b) -> f a -> f b ... -- Defined in ‘GHC.Base’
instance Functor Maybe where fmap _ Nothing = Nothing fmap f (Just a) = Just (f a)
instance Functor ((,) a) where fmap f (x,y) = (x, f y)
map (+3) [1..5] fmap (+3) (Just 15) fmap (+3) (5, 7)
map :: (a -> b) -> [a] -> [b] fmap :: Functor f => (a -> b) -> f a -> f b liftM :: Monad m => (a -> b) -> m a -> m b
Prelude> error (error "") *** Exception: Prelude> (error . error) "" *** Exception: *** Exception:
drawClass :: Sample -> RVar Class drawClass = ... drawClasses :: Array U DIM1 Sample -> RVar (Array U DIM1 Class) drawClasses samples = A.mapM drawClass samples
mapM :: ParallelMonad m => (a -> m b) -> Array r sh a -> m (Array r sh b)
withSqliteConn ":memory:" $ \conn -> return $ toRawSql SELECT (unsafeCoerce ((const mempty) :: a -> Text.Lazy.Builder.Builder)) (conn, initialIdentState) myFromStatement)
import Control.Monad import Data.Array data Node = Leaf Int -- value | Branch Int Node Node -- sum, left child, right child type NodeArray = Array Int Node -- create an empty node with range [l, r) create :: Int -> Int -> Node create l r | l + 1 == r = Leaf 0 | otherwise = Branch 0 (create l m) (create m r) where m = (l + r) `div` 2 -- Get the sum in range [0, r). The range of the node is [nl, nr) sumof :: Node -> Int -> Int -> Int -> Int sumof (Leaf val) r nl nr | nr <= r = val | otherwise = 0 sumof (Branch sum lc rc) r nl nr | nr <= r = sum | r > nl = (sumof lc r nl m) + (sumof rc r m nr) | otherwise = 0 where m = (nl + nr) `div` 2 -- Increase the value at x by 1. The range of the node is [nl, nr) increase :: Node -> Int -> Int -> Int -> Node increase (Leaf val) x nl nr = Leaf (val + 1) increase (Branch sum lc rc) x nl nr | x < m = Branch (sum + 1) (increase lc x nl m) rc | otherwise = Branch (sum + 1) lc (increase rc x m nr) where m = (nl + nr) `div` 2 -- signature said it all tonodes :: Int -> [Int] -> [Node] tonodes n = reverse . tonodes where tonodes tonodes tonodes -- find the minimum m in [l, r] such that (predicate m) is True binarysearch :: (Int -> Bool) -> Int -> Int -> Int binarysearch predicate l r | l == r = r | predicate m = binarysearch predicate l m | otherwise = binarysearch predicate (m+1) r where m = (l + r) `div` 2 -- main, literally main :: IO () main = do [n, m] <- fmap (map read . words) getLine nodes <- fmap (listArray (0, n) . tonodes n . map (subtract 1) . map read . words) getLine replicateM_ m $ query n nodes where query :: Int -> NodeArray -> IO () query n nodes = do [p, k] <- fmap (map read . words) getLine print $ binarysearch (ok nodes n p k) 0 n where ok :: NodeArray -> Int -> Int -> Int -> Int -> Bool ok nodes n p k s = (sumof (nodes ! min (p + s + 1) n) s 0 n) - (sumof (nodes ! max (p - s) 0) s 0 n) >= k
main :: IO () main = do [n, m] <- fmap (map read . words) getLine line <- getLine let nodes = listArray (0, n) . tonodes n . map (subtract 1) . map read . words $ line replicateM_ m $ query n nodes
main = do [n, m] <- fmap (map read . words) getLine line <- getLine replicateM_ m $ do let nodes = listArray (0, n) . tonodes n . map (subtract 1) . map read . words $ line query n nodes
foo x = let y = ...x... in \world1 -> let (world2, ()) = putStrLn y world1 let (world3, ()) = putStrLn y world2 in (world3, ())
foo x world1 = let y = ...x... in let (world2, ()) = putStrLn y world1 let (world3, ()) = putStrLn y world2 in (world3, ())
average :: [Float] -> Float average xs = sum xs / length xs
average2 :: [Float] -> Float average2 xs = uncurry (/) <$> foldl (\(sumT, n) x -> (sumT+x, n+1)) (0,0) xs -- N.B. this will build up thunks as written, use a strict pair and foldl'
badAveIter = (\xs -> sum xs / length xs) <$> I.stream2list
> bad_ctx (\(x,y) -> x == y) True > bad_ctx (\(x,y) -> y == x) False
wrong = do fileData <- withFile "test.txt" ReadMode hGetContents putStr fileData
right = withFile "test.txt" ReadMode $ \handle -> do fileData <- hGetContents handle putStr fileData
G |- valid G |- S : Set -------------- ----------------------------- x fresh for G . |- valid G, x:S |- valid
G |- valid G |- S : Set G |- T : Pi S \ x:S -> Set ------------------ --------------------------------------------- G |- Set : Set G |- Pi S T : Set G |- S : Set G, x:S |- t : T x G |- f : Pi S T G |- s : S ------------------------------------ -------------------------------- G |- \ x:S -> t : Pi S T G |- f s : T s G |- valid G |- s : S G |- T : Set -------------- x:S in G ----------------------------- S ={beta} T G |- x : S G |- s : T
data SKUP = S | K | U | P deriving (Show, Eq) data Unty a = C SKUP | Unty a :. Unty a | V a deriving (Functor, Eq) infixl 4 :.
norm :: Unty a -> Unty a norm (f :. a) = norm f $. a norm c = c ($.) :: Unty a -> Unty a -> Unty a -- requires first arg in normal form C S :. f :. a $. g = f $. g $. (a :. g) -- S f a g = f g (a g) share environment C K :. a $. g = a -- K a g = a drop environment n $. g = n :. norm g -- guarantees output in normal form infixl 4 $.
data Tm a = Var a | Lam (Tm a) (Tm (Su a)) -- Lam is the only place where binding happens | Tm a :$ Tm a | Pi (Tm a) (Tm a) -- the second arg of Pi is a function computing a Set | Set deriving (Show, Functor) infixl 4 :$ data Ze magic :: Ze -> a magic x = x `seq` error "Tragic!" data Su a = Ze | Su a deriving (Show, Functor, Eq)
tm :: Tm a -> Unty a tm (Var a) = V a tm (Lam _ b) = bra (tm b) tm (f :$ a) = tm f :. tm a tm (Pi a b) = C P :. tm a :. tm b tm Set = C U bra :: Unty (Su a) -> Unty a -- binds a variable, building a function bra (V Ze) = C S :. C K :. C K -- the variable itself yields the identity bra (V (Su x)) = C K :. V x -- free variables become constants bra (C c) = C K :. C c -- combinators become constant bra (f :. a) = C S :. bra f :. bra a -- S is exactly lifted application
U : Set P : (A : Set) -> (B : (a : A) -> Set) -> Set
G : Set A : Set ------------------------------- K : (a : A) -> (g : G) -> A
G : Set A : (g : G) -> Set B : (g : G) -> (a : A g) -> Set ---------------------------------------------------- S : (f : (g : G) -> (a : A g) -> B g a ) -> (a : (g : G) -> A g ) -> (g : G) -> B g (a g)
--------- U : U --------------------------------------------------------- P : PU(S(S(KP)(S(S(KP)(SKK))(S(KK)(KU))))(S(KK)(KU))) G : U A : U ----------------------------------------- K : P[A](S(S(KP)(K[G]))(S(KK)(K[A]))) G : U A : P[G](KU) B : P[G](S(S(KP)(S(K[A])(SKK)))(S(KK)(KU))) -------------------------------------------------------------------------------------- S : P(P[G](S(S(KP)(S(K[A])(SKK)))(S(S(KS)(S(S(KS)(S(KK)(K[B])))(S(KK)(SKK)))) (S(S(KS)(KK))(KK)))))(S(S(KP)(S(S(KP)(K[G]))(S(S(KS)(S(KK)(K[A]))) (S(S(KS)(KK))(KK)))))(S(S(KS)(S(S(KS)(S(KK)(KP)))(S(KK)(K[G])))) (S(S(KS)(S(S(KS)(S(KK)(KS)))(S(S(KS)(S(S(KS)(S(KK)(KS))) (S(S(KS)(S(KK)(KK)))(S(KK)(K[B])))))(S(S(KS)(S(S(KS)(S(KK)(KS)))(S(KK)(KK)))) (S(KK)(KK))))))(S(S(KS)(S(S(KS)(S(KK)(KS)))(S(S(KS)(S(KK)(KK))) (S(S(KS)(KK))(KK)))))(S(S(KS)(S(S(KS)(S(KK)(KS)))(S(KK)(KK))))(S(KK)(KK))))))) M : A B : U ----------------- A ={norm} B M : B
pTy :: Tm a pTy = fmap magic $ pil Set $ \ _A -> pil (pil _A $ \ _ -> Set) $ \ _B -> Set kTy :: Tm a kTy = fmap magic $ pil Set $ \ _G -> pil Set $ \ _A -> pil _A $ \ a -> pil _G $ \ g -> _A sTy :: Tm a sTy = fmap magic $ pil Set $ \ _G -> pil (pil _G $ \ g -> Set) $ \ _A -> pil (pil _G $ \ g -> pil (_A :$ g) $ \ _ -> Set) $ \ _B -> pil (pil _G $ \ g -> pil (_A :$ g) $ \ a -> _B :$ g :$ a) $ \ f -> pil (pil _G $ \ g -> _A :$ g) $ \ a -> pil _G $ \ g -> _B :$ g :$ (a :$ g)
class Fin x where top :: Su x emb :: x -> Su x embd :: Su x -> Maybe x
instance Fin Ze where top = Ze -- Ze is the only, so the highest emb = magic embd _ = Nothing -- there was nothing to embed instance Fin x => Fin (Su x) where top = Su top -- the highest is one higher emb Ze = Ze -- emb preserves Ze emb (Su x) = Su (emb x) -- and Su embd Ze = Just Ze -- Ze is definitely embedded embd (Su x) = fmap Su (embd x) -- otherwise, wait and see
instance Fin y => Le Ze y where wk = magic -- nothing to embed instance Le x y => Le (Su x) (Su y) where wk x = case embd x of Nothing -> top -- top maps to top Just y -> emb (wk y) -- embedded gets weakened and embedded
lam :: forall x. Tm x -> ((forall y. Le (Su x) y => Tm y) -> Tm (Su x)) -> Tm x lam s f = Lam s (f (Var (wk (Ze :: Su x)))) pil :: forall x. Tm x -> ((forall y . Le (Su x) y => Tm y) -> Tm (Su x)) -> Tm x pil s f = Pi s (lam s f)
{- module Nat where data Nat = Z | S Nat data Parity = Even | Odd type family Flip (x :: Parity) :: Parity where Flip Even = Odd Flip Odd = Even data ParNat :: Parity -> * where PZ :: ParNat Even PS :: (x ~ Flip y, y ~ Flip x) => ParNat x -> ParNat (Flip x) halve :: ParNat Even -> Nat halve PZ = Z halve (PS a) = helper a where helper :: ParNat Odd -> Nat helper (PS b) = S (halve b)
Nat.$WPZ :: Nat.ParNat Nat.$WPZ = Nat.PZ @ Nat.$WPS :: forall (x_apH :: Nat.Parity) (y_apI :: Nat.Parity). (x_apH ~ Nat.Flip y_apI, y_apI ~ Nat.Flip x_apH) => Nat.ParNat x_apH -> Nat.ParNat (Nat.Flip x_apH) Nat.$WPS = \ (@ (x_apH :: Nat.Parity)) (@ (y_apI :: Nat.Parity)) (dt_aqR :: x_apH ~ Nat.Flip y_apI) (dt_aqS :: y_apI ~ Nat.Flip x_apH) (dt_aqT :: Nat.ParNat x_apH) -> case dt_aqR of _ { GHC.Types.Eq case dt_aqS of _ { GHC.Types.Eq Nat.PS @ (Nat.Flip x_apH) @ x_apH @ y_apI @~ <Nat.Flip x_apH>_N @~ dt_aqU @~ dt_aqV dt_aqT } } Rec { Nat.halve :: Nat.ParNat Nat.halve = \ (ds_dJB :: Nat.ParNat case ds_dJB of _ { Nat.PZ dt_dKD -> Nat.Z; Nat.PS @ x_aIX @ y_aIY dt_dK6 dt1_dK7 dt2_dK8 a_apK -> case a_apK `cast` ((Nat.ParNat (dt1_dK7 ; (Nat.Flip (dt2_dK8 ; Sym dt_dK6))_N ; Nat.TFCo:R:Flip[0]))_R :: Nat.ParNat x_aIX ~ of _ { Nat.PS @ x1_aJ4 @ y1_aJ5 dt3_dKa dt4_dKb dt5_dKc b_apM -> Nat.S (Nat.halve (b_apM `cast` ((Nat.ParNat (dt4_dKb ; (Nat.Flip (dt5_dKc ; Sym dt3_dKa ; Sym Nat.TFCo:R:Flip[0] ; (Nat.Flip (dt_dK6 ; Sym dt2_dK8))_N ; Sym dt1_dK7))_N ; Sym dt_dK6))_R :: Nat.ParNat x1_aJ4 ~ } } end Rec }
data Foo = FooString String … class Fooable a where --(is this a good way to name this?) toFoo :: a -> Foo
Illegal instance declaration for `Fooable String' (All instance types must be of the form (T t1 ... tn) where T is not a synonym. Use -XTypeSynonymInstances if you want to disable this.) In the instance declaration for `Fooable String'
Illegal instance declaration for `Fooable [Char]' (All instance types must be of the form (T a1 ... an) where a1 ... an are type *variables*, and each type variable appears at most once in the instance head. Use -XFlexibleInstances if you want to disable this.) In the instance declaration for `Fooable [Char]'
newtype Wrapper = Wrapper String instance Fooable Wrapper where ...
class Element a where listToFoo :: [a] -> Foo instance Element Char where listToFoo = FooString instance Element a => Fooable [a] where toFoo = listToFoo
Module SrcLoc ModuleName [ModulePragma] (Maybe WarningText) (Maybe [ExportSpec]) [ImportDecl] [Decl]
data SrcLoc = SrcLoc { srcFilename :: String , srcLine :: Int , srcColumn :: Int }
-- tail :: [a] -> [a] tail (_:xs) = xs -- append :: [a] -> [a] -> [a] append [] ys = ys append (x:xs) ys = x : append xs ys -- zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] zipWith f (a:as) (b:bs) = f a b : zipWith f as bs zipWith _ _ _ = [] -- showList :: (a -> String) -> [a] -> String showList _ [] = showList show (x:xs) = -- showItems :: (a -> String) -> [a] -> String showItems show [] = showItems show (x:xs) = -- fibs :: [Int] fibs = 0 : 1 : zipWith add fibs (tail fibs) -- main :: String main = showList showInt (take 40 fibs)
import Control.Monad.Writer logNumber :: Int -> Writer [String] Int logNumber x = Writer (x, ["Got number: " ++ show x]) multWithLog :: Writer [String] Int multWithLog = do a <- logNumber 3 b <- logNumber 5 return (a*b)
more1.hs:4:15: Not in scope: data constructor `Writer' Perhaps you meant `WriterT Failed, modules loaded: none.
Prelude Control.Monad.Writer> :info Writer type Writer w = WriterT w Data.Functor.Identity.Identity -- Defined in `Control.Monad.Trans.Writer.Lazy'
ghci> import Control.Monad.Writer ghci> let logNumber x = writer (x, ["Got number: " ++ show x])
ghci> :t logNumber logNumber :: (Show a, MonadWriter [String] m) => a -> m a
ghci> let multWithLog = do { a <- logNumber 3; b <- logNumber 5; return (a*b) } :: Writer [String] Int
ghci> runWriter multWithLog (15, ["Got number: 3","Got number: 5"])
instance (Monoid w, MonadWriter w m) => MonadWriter w (ReaderT r m)
import qualified Control.Monad.Trans.Writer.Lazy as W
import Data.Monoid import qualified Control.Monad.Trans.Writer.Lazy as W output :: String -> W.Writer [String] () output x = W.tell [x] gcd gcd | b == 0 = do output ("Finished with " ++ show a) return a | otherwise = do output (show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)) gcd main :: IO() main = mapM_ putStrLn $ snd $ W.runWriter (gcd
data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
instance Functor Tree where fmap f Empty = Empty fmap f (Leaf x) = Leaf (f x) fmap f (Node l k r) = Node (fmap f l) (f k) (fmap f r)
instance Traversable Tree where traverse f Empty = pure Empty traverse f (Leaf x) = Leaf <$> f x traverse f (Node l k r) = Node <$> traverse f l <*> f k <*> traverse f r
Node.prototype.traverse = function (f) { return new Node(this.l.traverse(f), f(this.k), this.r.traverse(f)); }
half x = if even x then Just (x `div` 2) else Nothing
traverse rep [1..3] --[[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b) traverse f = sequenceA . fmap f
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) sequenceA = traverse id
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
λ> import Data.Traversable λ> let qs = ["name", "quest", "favorite color"] λ> traverse (\thing -> putStrLn ("What is your " ++ thing ++ "?") *> getLine) qs What is your name? Sir Lancelot What is your quest? to seek the holy grail What is your favorite color? blue ["Sir Lancelot","to seek the holy grail","blue"]
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
mapUserIDsToUsernames :: (Num -> IO String) -> [Num] -> IO [String] mapUserIDsToUsernames fn ids = traverse fn ids
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
data Bin a = Branch (Bin a) a (Bin a) | Leaf a deriving Functor
data Dir = L | R data Step a = Step a Dir (Bin a) deriving Functor data Zip a = Zip [Step a] (Bin a) deriving Functor instance Comonad Zip where ...
data Zipper t a = Zipper { diff :: D t a, here :: a } deriving instance Diff t => Functor (Zipper t) class (Functor t, Functor (D t)) => Diff t where data D t :: * -> * inTo :: t a -> t (Zipper t a) outOf :: Zipper t a -> t a
instance Diff Bin where data D Bin a = DBin { context :: [Step a], descend :: Maybe (Bin a, Bin a) } ...
{- TypeOperators, FlexibleInstances, RankNTypes, ScopedTypeVariables, StandaloneDeriving, UndecidableInstances
class (Functor f, Functor (DF f)) => Diff1 f where type DF f :: * -> * upF :: ZF f x -> f x downF :: f x -> f (ZF f x) aroundF :: ZF f x -> ZF f (ZF f x) data ZF f x = (:<-:) {cxF :: DF f x, elF :: x}
class Functor c => Comonad c where extract :: c x -> x duplicate :: c x -> c (c x)
instance Diff1 f => Functor (ZF f) where fmap f (df :<-: x) = fmap f df :<-: f x instance Diff1 f => Comonad (ZF f) where extract = elF duplicate = aroundF
extract . duplicate == id fmap extract . duplicate == id duplicate . duplicate == fmap duplicate . duplicate
fmap extract (downF xs) == xs -- downF decorates the element in position fmap upF (downF xs) = fmap (const xs) xs -- downF gives the correct context
data KF a x = KF a instance Functor (KF a) where fmap f (KF a) = KF a instance Diff1 (KF a) where type DF (KF a) = KF Void upF (KF w :<-: _) = absurd w downF (KF a) = KF a aroundF (KF w :<-: _) = absurd w
data IF x = IF x instance Functor IF where fmap f (IF x) = IF (f x) instance Diff1 IF where type DF IF = KF () upF (KF () :<-: x) = IF x downF (IF x) = IF (KF () :<-: x) aroundF z@(KF () :<-: x) = KF () :<-: z
data (f :+: g) x = LF (f x) | RF (g x) instance (Functor f, Functor g) => Functor (f :+: g) where fmap h (LF f) = LF (fmap h f) fmap h (RF g) = RF (fmap h g) instance (Diff1 f, Diff1 g) => Diff1 (f :+: g) where type DF (f :+: g) = DF f :+: DF g upF (LF f upF (RF g
downF (LF f) = LF (fmap (\ (f downF (RF g) = RF (fmap (\ (g
aroundF z@(LF f LF (fmap (\ (f :<-: z aroundF z@(RF g RF (fmap (\ (g :<-: z
data (f :*: g) x = f x :*: g x instance (Functor f, Functor g) => Functor (f :*: g) where fmap h (f :*: g) = fmap h f :*: fmap h g
instance (Diff1 f, Diff1 g) => Diff1 (f :*: g) where type DF (f :*: g) = (DF f :*: g) :+: (f :*: DF g) upF (LF (f upF (RF (f :*: g
aroundF z@(LF (f LF (fmap (\ (f (cxF $ aroundF (f :*: fmap (\ (g :<-: z where f = upF (f aroundF z@(RF (f :*: g RF (fmap (\ (f fmap (\ (g (cxF $ aroundF (g :<-: z where g = upF (g
deriving instance (Show (DF f x), Show x) => Show (ZF f x)
> downF (IF 1 :*: IF 2) IF (LF (KF () :*: IF 2) :<-: 1) :*: IF (RF (IF 1 :*: KF ()) :<-: 2) > fmap aroundF it IF (LF (KF () :*: IF (RF (IF 1 :*: KF ()) :<-: 2)) :<-: (LF (KF () :*: IF 2) :<-: 1)) :*: IF (RF (IF (LF (KF () :*: IF 2) :<-: 1) :*: KF ()) :<-: (RF (IF 1 :*: KF ()) :<-: 2))
instance Bifunctor b => Functor (Mu b) where fmap f (In b) = In (bimap (fmap f) f b)
newtype K a x y = K a instance Bifunctor (K a) where bimap f g (K a) = K a
data Var = X | Y data V :: Var -> * -> * -> * where XX :: x -> V X x y YY :: y -> V Y x y
instance Bifunctor (V v) where bimap f g (XX x) = XX (f x) bimap f g (YY y) = YY (g y)
data (:++:) f g x y = L (f x y) | R (g x y) deriving Show instance (Bifunctor b, Bifunctor c) => Bifunctor (b :++: c) where bimap f g (L b) = L (bimap f g b) bimap f g (R b) = R (bimap f g b) data (:**:) f g x y = f x y :**: g x y deriving Show instance (Bifunctor b, Bifunctor c) => Bifunctor (b :**: c) where bimap f g (b :**: c) = bimap f g b :**: bimap f g c
List = Mu (K () :++: (V Y :**: V X)) Bin = Mu (V Y :**: (K () :++: (V X :**: V X)))
data Vary :: Var -> * where VX :: Vary X VY :: Vary Y
class (Bifunctor b, Bifunctor (D b X), Bifunctor (D b Y)) => Diff2 b where type D b (v :: Var) :: * -> * -> * up :: Vary v -> Z b v x y -> b x y down :: b x y -> b (Z b X x y) (Z b Y x y) around :: Vary v -> Z b v x y -> Z b v (Z b X x y) (Z b Y x y) data Z b v x y = (:<-) {cxZ :: D b v x y, elZ :: V v x y}
instance Diff2 (K a) where type D (K a) v = K Void up _ (K q :<- _) = absurd q down (K a) = K a around _ (K q :<- _) = absurd q
instance Diff2 (V X) where type D (V X) X = K () type D (V X) Y = K Void up VX (K () :<- XX x) = XX x up VY (K q :<- _) = absurd q down (XX x) = XX (K () :<- XX x) around VX z@(K () :<- XX x) = K () :<- XX z around VY (K q :<- _) = absurd q instance Diff2 (V Y) where type D (V Y) X = K Void type D (V Y) Y = K () up VX (K q :<- _) = absurd q up VY (K () :<- YY y) = YY y down (YY y) = YY (K () :<- YY y) around VX (K q :<- _) = absurd q around VY z@(K () :<- YY y) = K () :<- YY z
vV :: Vary v -> Z b v x y -> V v (Z b X x y) (Z b Y x y) vV VX z = XX z vV VY z = YY z
zimap :: (Bifunctor c) => (forall v. Vary v -> D b v x y -> D b c (Z b X x y) (Z b Y x y) -> c (Z b zimap f = bimap (\ (d :<- XX x) -> f VX d :<- XX x) (\ (d :<- YY y) -> f VY d :<- YY y) dzimap :: (Bifunctor (D c X), Bifunctor (D c Y)) => (forall v. Vary v -> D b v x y -> D b Vary v -> Z c v (Z b X x y) (Z b Y x y) -> D c v (Z b dzimap f VX (d :<- _) = bimap (\ (d :<- XX x) -> f VX d :<- XX x) (\ (d :<- YY y) -> f VY d :<- YY y) d dzimap f VY (d :<- _) = bimap (\ (d :<- XX x) -> f VX d :<- XX x) (\ (d :<- YY y) -> f VY d :<- YY y) d
instance (Diff2 b, Diff2 c) => Diff2 (b :++: c) where type D (b :++: c) v = D b v :++: D c v up v (L b down (L b) = L (zimap (const L) (down b)) down (R c) = R (zimap (const R) (down c)) around v z@(L b = L (dzimap (const L) v ba) :<- vV v z where ba = around v (b around v z@(R c = R (dzimap (const R) v ca) :<- vV v z where ca = around v (c
instance (Diff2 b, Diff2 c) => Diff2 (b :**: c) where type D (b :**: c) v = (D b v :**: c) :++: (b :**: D c v) up v (L (b up v (R (b :**: c down (b :**: c) = zimap (const (L . (:**: c))) (down b) :**: zimap (const (R . (b :**:))) (down c) around v z@(L (b = L (dzimap (const (L . (:**: c))) v ba :**: zimap (const (R . (b :**:))) (down c)) :<- vV v z where b = up v (b ba = around v (b around v z@(R (b :**: c = R (zimap (const (L . (:**: c))) (down b):**: dzimap (const (R . (b :**:))) v ca) :<- vV v z where c = up v (c ca = around v (c
data MuZpr b y = MuZpr { aboveMu :: [D b X (Mu b y) y] , hereMu :: Mu b y }
muUp :: Diff2 b => MuZpr b y -> Mu b y muUp (MuZpr {aboveMu = [], hereMu = t}) = t muUp (MuZpr {aboveMu = (dX : dXs), hereMu = t}) = muUp (MuZpr {aboveMu = dXs, hereMu = In (up VX (dX :<- XX t))})
data MuCx b y = MuCx { aboveY :: [D b X (Mu b y) y] , belowY :: D b Y (Mu b y) y } instance Diff2 b => Functor (MuCx b) where fmap f (MuCx { aboveY = dXs, belowY = dY }) = MuCx { aboveY = map (bimap (fmap f) f) dXs , belowY = bimap (fmap f) f dY }
instance Diff2 b => Diff1 (Mu b) where type DF (Mu b) = MuCx b
zAboveY :: ZF (Mu b) y -> [D b X (Mu b y) y] -- the stack of `X`-derivatives above me zAboveY (d :<-: y) = aboveY d zZipY :: ZF (Mu b) y -> Z b Y (Mu b y) y -- the `Y`-zipper where I am zZipY (d :<-: y) = belowY d :<- YY y
upF z = muUp (MuZpr {aboveMu = zAboveY z, hereMu = In (up VY (zZipY z))})
yOnDown :: Diff2 b => [D b X (Mu b y) y] -> Mu b y -> Mu b (ZF (Mu b) y) yOnDown dXs (In b) = In (contextualize dXs (down b))
contextualize :: (Bifunctor c, Diff2 b) => [D b X (Mu b y) y] -> c (Z b X (Mu b y) y) (Z b Y (Mu b y) y) -> c (Mu b (ZF (Mu b) y)) (ZF (Mu b) y) contextualize dXs = bimap (\ (dX :<- XX t) -> yOnDown (dX : dXs) t) (\ (dY :<- YY y) -> MuCx {aboveY = dXs, belowY = dY} :<-: y)
aroundF z@(MuCx {aboveY = dXs, belowY = dY} :<-: _) = MuCx { aboveY = yOnUp dXs (In (up VY (zZipY z))) , belowY = contextualize dXs (cxZ $ around VY (zZipY z)) } :<-: z
yOnUp :: Diff2 b => [D b X (Mu b y) y] -> Mu b y -> [D b X (Mu b (ZF (Mu b) y)) (ZF (Mu b) y)] yOnUp [] t = [] yOnUp (dX : dXs) (t :: Mu b y) = contextualize dXs (cxZ $ around VX (dX :<- XX t)) : yOnUp dXs (In (up VX (dX :<- XX t)))
instance (Diff t, Diff (D t)) => Comonad (Zipper t) where extract = here duplicate = fmap outOf . inTo
fmap extract . duplicate == \z -> fmap (const (here z)) z
-- Zippers are themselves products toZipper :: (D t :*: Identity) a -> Zipper t a toZipper (d :*: (Identity h)) = Zipper d h fromZipper :: Zipper t a -> (D t :*: Identity) a fromZipper (Zipper d h) = (d :*: (Identity h))
inToFor (forall a. r a -> t a) -> (forall a. t a -> r a) -> (forall a. D r a -> D t a) -> (forall a. D t a -> D r a) -> t a -> t (Zipper t a) inToFor outOfFor (forall a. r a -> t a) -> (forall a. t a -> r a) -> (forall a. D r a -> D t a) -> (forall a. D t a -> D r a) -> Zipper t a -> t a outOfFor
inToFor :: (Diff r, D r ~ D t) => (forall a. r a -> t a) -> (forall a. t a -> r a) -> t a -> t (Zipper t a) inToFor to from = inToFor outOfFor :: (Diff r, D r ~ D t) => (forall a. r a -> t a) -> (forall a. t a -> r a) -> Zipper t a -> t a outOfFor to from = outOfFor
-- This requires undecidable instances, due to the need to take D (D t) instance (Diff t, Diff (D t)) => Diff (Zipper t) where type D (Zipper t) = D ((D t) :*: Identity) -- inTo :: t a -> t (Zipper t a) -- inTo :: Zipper t a -> Zipper t (Zipper (Zipper t) a) inTo = inToFor toZipper fromZipper -- outOf :: Zipper t a -> t a -- outOf :: Zipper (Zipper t) a -> Zipper t a outOf = outOfFor toZipper fromZipper
{- {- {- {- {- {- {- import Control.Monad.Identity import Data.Proxy import Control.Comonad data Zipper t a = Zipper { diff :: D t a, here :: a } onDiff :: (D t a -> D u a) -> Zipper t a -> Zipper u a onDiff f (Zipper d a) = Zipper (f d) a deriving instance Diff t => Functor (Zipper t) deriving instance (Eq (D t a), Eq a) => Eq (Zipper t a) deriving instance (Show (D t a), Show a) => Show (Zipper t a) class (Functor t, Functor (D t)) => Diff t where type D t :: * -> * inTo :: t a -> t (Zipper t a) outOf :: Zipper t a -> t a
data (:+:) a b x = InL (a x) | InR (b x) deriving (Eq, Show) data (:*:) a b x = a x :*: b x deriving (Eq, Show) infixl 7 :*: infixl 6 :+: deriving instance (Functor a, Functor b) => Functor (a :*: b) instance (Functor a, Functor b) => Functor (a :+: b) where fmap f (InL a) = InL . fmap f $ a fmap f (InR b) = InR . fmap f $ b instance (Diff a, Diff b) => Diff (a :*: b) where type D (a :*: b) = D a :*: b :+: a :*: D b inTo (a :*: b) = (fmap (onDiff (InL . (:*: b))) . inTo) a :*: (fmap (onDiff (InR . (a :*:))) . inTo) b outOf (Zipper (InL (a :*: b)) x) = (:*: b) . outOf . Zipper a $ x outOf (Zipper (InR (a :*: b)) x) = (a :*:) . outOf . Zipper b $ x instance (Diff a, Diff b) => Diff (a :+: b) where type D (a :+: b) = D a :+: D b inTo (InL a) = InL . fmap (onDiff InL) . inTo $ a inTo (InR b) = InR . fmap (onDiff InR) . inTo $ b outOf (Zipper (InL a) x) = InL . outOf . Zipper a $ x outOf (Zipper (InR a) x) = InR . outOf . Zipper a $ x instance Diff (Identity) where type D (Identity) = Proxy inTo = Identity . (Zipper Proxy) . runIdentity outOf = Identity . here instance Diff (Proxy) where type D (Proxy) = Proxy inTo = const Proxy outOf = const Proxy
newtype Bin a = Bin {unBin :: (Bin :*: Identity :*: Bin :+: Identity) a} deriving (Functor, Eq, Show) newtype DBin a = DBin {unDBin :: D (Bin :*: Identity :*: Bin :+: Identity) a} deriving (Functor, Eq, Show) newtype DDBin a = DDBin {unDDBin :: D (D (Bin :*: Identity :*: Bin :+: Identity)) a} deriving (Functor, Eq, Show) instance Diff Bin where type D Bin = DBin inTo = inToFor outOf = outOfFor instance Diff DBin where type D DBin = DDBin inTo = inToFor outOf = outOfFor
aTree :: Bin Int aTree = (Bin . InL) ( (Bin . InL) ( (Bin . InR) (Identity 2) :*: (Identity 1) :*: (Bin . InR) (Identity 3) ) :*: (Identity 0) :*: (Bin . InR) (Identity 4) )
fmap ( \z -> (fmap extract . duplicate) z == z) . inTo $ aTree
Bin {unBin = InL ((Bin {unBin = InL ((Bin {unBin = InR (Identity False)} :*: Identity False) :*: Bin {unBin = InR (Identity False)})} :*: Identity False) :*: Bin {unBin = InR (Identity False)})}
fmap extract . duplicate == \z -> fmap (const (here z)) z
main = do putStrLn "fmap (\\z -> (extract . duplicate) z == z) . inTo $ aTree" print . fmap ( \z -> (extract . duplicate) z == z) . inTo $ aTree putStrLn "" putStrLn "fmap (\\z -> (fmap extract . duplicate) z == z) . inTo $ aTree" print . fmap ( \z -> (fmap extract . duplicate) z == z) . inTo $ aTree putStrLn "" putStrLn "fmap (\\z -> (duplicate . duplicate) z) == (fmap duplicate . duplicate) z) . inTo $ aTree" print . fmap ( \z -> (duplicate . duplicate) z == (fmap duplicate . duplicate) z) . inTo $ aTree
class (Functor t, Functor (D t)) => Diff t where type D t :: * -> * up :: Zipper t a -> t a down :: t a -> t (Zipper t a) -- Require that types be infinitely differentiable ddiff :: p t -> Dict (Diff (D t))
around z@(Zipper d h) = Zipper ctx z where ctx = fmap (\z
instance Diff t => Comonad (Zipper t) where extract = here duplicate = around
around :: Diff t => Zipper t a -> Zipper t (Zipper t a) around z = Zipper (withDict d where d p p
while :: (Monad m) => m Bool -> m () -> m () while cond action = do c <- cond if c then action >> while cond action else return ()
lastElt :: [a] -> IO a lastElt [] = fail "Empty list!!" lastElt xs = do lst <- newIORef xs ret <- newIORef (head xs) while (not . null <$> readIORef lst) $ do (x:xs) <- readIORef lst writeIORef lst xs writeIORef ret x readIORef ret
def last_elt(xs): assert xs, "Empty list!!" lst = xs ret = xs.head while lst: ret = lst.head lst = lst.tail return ret
lastElt [] = fail "Unsafe lastElt called on empty list" lastElt [x] = return x lastElt (_:xs) = lastElt xs
import Data.Foldable (Foldable, foldMap) import Data.Monoid (Monoid(..), Last(..)) lastElt :: (Foldable t) => t a -> Maybe a lastElt = getLast . foldMap (Last . Just)
λ➔ let example = fromList [(10, "spam"), (50, "eggs"), (20, "ham")] :: Map Int String λ➔ lastElt example Just "eggs"
do let printBoth s = putStrLn s >> hPutStrLn stderr s printBoth "Hello" -- Some other code printBoth "Goodbye"
sortBy (\a b -> compare (length a) (length b)) ["aaaa", "b", "cc"]
f = sequence_ (reverse [print 1, print 2, print 3])
do putStrLn "What is your name?" name <- getLine putStrLn ("Welcome, " ++ name ++ "!")
parseExpr = parseString <|> parseNumber parseString = do char x <- many (noneOf "\"") char return (StringValue x) parseNumber = do num <- many1 digit return (NumberValue (read num))
let AsyncHttp(url:string) = async { let req = WebRequest.Create(url) let! rsp = req.GetResponseAsync() use stream = rsp.GetResponseStream() use reader = new System.IO.StreamReader(stream) return reader.ReadToEnd() }
putStrLn "What is your name?" >>= (\_ -> getLine) >>= (\name -> putStrLn ("Welcome, " ++ name ++ "!"))
fmap :: (a -> b) -> (Wrapped a -> Wrapped b) fmap f (Wrap x) = Wrap (f x)
bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b) bind f (Wrap x) = f x
class Monad m where return :: a -> m a (>>=) :: forall a b . m a -> (a -> m b) -> m b
instance Monad [ ] where [] >>= k = [] (x:xs) >>= k = k x ++ (xs >>= k) return x = [x] instance Monad Maybe where Just x >>= k = k x Nothing >>= k = Nothing return x = Just x
consolestate FinalConsole = print(input(print(myconsole, "Hello, what
consolestate FinalConsole = myconsole: print("Hello, what input(): print("hello, %inputbuffer%!");
f(<x, messages>) := <x, messages "called f. "> g(<x, messages>) := <x, messages "called g. "> wrap(x) := <x, "">
f(g(wrap(x))) = f(g(<x, "">)) = f(<x, "called g. ">) = <x, "called g. called f. ">
f(x) := <x, "called f. "> g(x) := <x, "called g. "> wrap(x) := <x, "">
f(g(wrap(x))) = f(g(<x, "">)) = f(<<x, "">, "called g. ">) = <<<x, "">, "called g. ">, "called f. ">
feed(f, feed(g, wrap(x))) = feed(f, feed(g, <x, "">)) = feed(f, <x, "called g. ">) = <x, "called g. called f. ">
feed(f, <x, messages>) := let <y, message> = f(x) in <y, messages message>
feed(f, wrap(x)) = feed(f, <x, "">) = let <y, message> = f(x) in <y, "" message> = let <y, message> = <x, "called f. "> in <y, "" message> = <x, "" "called f. "> = <x, "called f. "> = f(x)
feed(wrap, <x, messages>) = let <y, message> = wrap(x) in <y, messages message> = let <y, message> = <x, ""> in <y, messages message> = <x, messages ""> = <x, messages>
feed(h, <x, messages>) = let <y, message> = h(x) in <y, messages message> = let <y, message> = feed(f, g(x)) in <y, messages message> = let <y, message> = feed(f, <x, "called g. ">) in <y, messages message> = let <y, message> = let <z, msg> = f(x) in <z, "called g. " msg> in <y, messages message> = let <y, message> = let <z, msg> = <x, "called f. "> in <z, "called g. " msg> in <y, messages message> = let <y, message> = <x, "called g. " "called f. "> in <y, messages message> = <x, messages "called g. " "called f. "> = feed(f, <x, messages "called g. ">) = feed(f, feed(g, <x, messages>))
{- newtype Id t = Id t instance Monad Id where return :: t -> Id t return = Id (=<<) :: (a -> Id b) -> Id a -> Id b f =<< (Id x) = f x
(.) :: (b -> c) -> (a -> b) -> (a -> c) f . g = \ x -> f $ g x infixr 9 .
f . id = f :: c -> d Right identity id . g = g :: b -> c Left identity (f . g) . h = f . (g . h) :: a -> d Associativity
{- class Functor (f :: * -> *) where map :: (a -> b) -> (f a -> f b)
map id = id :: f t -> f t Identity map f . map g = map (f . g) :: f a -> f c Composition / short cut fusion
class Functor m => Monad m where return :: t -> m t (=<<) :: (a -> m b) -> m a -> m b infixr 1 =<<
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c) f <=< g = \ x -> f =<< g x infixr 1 <=<
return <=< g = g :: b -> m c Left identity f <=< return = f :: c -> m d Right identity (f <=< g) <=< h = f <=< (g <=< h) :: a -> m d Associativity
return :: t -> Id t = id :: t -> t (=<<) :: (a -> Id b) -> Id a -> Id b = ($) :: (a -> b) -> a -> b (<=<) :: (b -> Id c) -> (a -> Id b) -> (a -> Id c) = (.) :: (b -> c) -> (a -> b) -> (a -> c)
newtype Id t = Id t instance Functor Id where map :: (a -> b) -> Id a -> Id b map f (Id x) = Id (f x) instance Monad Id where return :: t -> Id t return = Id (=<<) :: (a -> Id b) -> Id a -> Id b f =<< (Id x) = f x
instance Functor Maybe where map :: (a -> b) -> (Maybe a -> Maybe b) map f (Just x) = Just (f x) map _ Nothing = Nothing instance Monad Maybe where return :: t -> Maybe t return = Just (=<<) :: (a -> Maybe b) -> Maybe a -> Maybe b f =<< (Just x) = f x _ =<< Nothing = Nothing
toNat :: Int -> Maybe Nat toNat i | i >= 0 = Just (Nat i) | otherwise = Nothing
(-?) :: Nat -> Nat -> Maybe Nat (Nat n) -? (Nat m) = toNat (n - m) infixl 6 -?
(++) :: [t] -> [t] -> [t] (x : xs) ++ ys = x : xs ++ ys [] ++ ys = ys infixr 5 ++
instance Functor [] where map :: (a -> b) -> ([a] -> [b]) map f (x : xs) = f x : map f xs map _ [] = [] instance Monad [] where return :: t -> [t] return = (: []) (=<<) :: (a -> [b]) -> [a] -> [b] f =<< (x : xs) = f x ++ f =<< xs _ =<< [] = []
divisors :: Integral t => t -> [t] divisors n = filter (`divides` n) [2 .. n - 1] divides :: Integral t => t -> t -> Bool (`divides` n) = (== 0) . (n `rem`)
class Applicative m => Monad m where (>>=) :: forall a b. m a -> (a -> m b) -> m b (>>) :: forall a b. m a -> m b -> m b m >> k = m >>= \ _ -> k {- return :: a -> m a return = pure fail :: String -> m a fail s = errorWithoutStackTrace s
class Functor f class Functor p => Applicative p class Applicative m => Monad m
for a in (1, ..., 10) for b in (1, ..., 10) p <- a * b if even(p) yield p
do a <- [1 .. 10] b <- [1 .. 10] let p = a * b guard (even p) return p
[p | a <- [1 .. 10], b <- [1 .. 10], let p = a * b, even p]
[1 .. 10] >>= (\ a -> [1 .. 10] >>= (\ b -> let p = a * b in guard (even p) >> return p ) )
let x = v in e = (\ x -> e) $ v = v & (\ x -> e) do r <- m; c = (\ r -> c) =<< m = m >>= (\ r -> c)
(&) :: a -> (a -> b) -> b (&) = flip ($) infixl 0 &
guard :: Additive m => Bool -> m () guard True = return () guard False = fail
class Monad m => Additive m where fail :: m t (<|>) :: m t -> m t -> m t infixl 3 <|> instance Additive Maybe where fail = Nothing Nothing <|> m = m m <|> _ = m instance Additive [] where fail = [] (<|>) = (++)
fail <|> l = l k <|> fail = k (k <|> l) <|> m = k <|> (l <|> m)
newtype State st t = State { stateProc :: st -> (t, st) } instance Functor (State st) where map :: (a -> b) -> ((State st) a -> (State st) b) map f (State p) = State $ \ s0 -> let (x, s1) = p s0 in (f x, s1) instance Monad (State st) where return :: t -> (State st) t return x = State $ \ s -> (x, s) (=<<) :: (a -> (State st) b) -> (State st) a -> (State st) b f =<< (State p) = State $ \ s0 -> let (x, s1) = p s0 in stateProc (f x) s1
run :: State st t -> st -> (t, st) run = stateProc eval :: State st t -> st -> t eval = fst . run exec :: State st t -> st -> st exec = snd . run
{- class Monad m => Stateful m st | m -> st where get :: m st put :: st -> m ()
instance Stateful (State st) st where get :: State st st get = State $ \ s -> (s, s) put :: st -> State st () put s = State $ \ _ -> ((), s)
modify :: Stateful m st => (st -> st) -> m () modify f = do s <- get put (f s) gets :: Stateful m st => (st -> t) -> m t gets f = do s <- get return (f s)
let s0 = 34 s1 = (+ 1) s0 n = (* 12) s1 s2 = (+ 7) s1 in (show n, s2)
(flip run) 34 (do modify (+ 1) n <- gets (* 12) modify (+ 7) return (show n) )
(flip run) 34 (modify (+ 1) >> gets (* 12) >>= (\ n -> modify (+ 7) >> return (show n) ) )
do { do { do { r1 <- do { x <- m; r0 <- m; r0 <- m; = do { = r1 <- f r0; f r0 r1 <- f x; g r1 }; g r1 } g r1 } } }
for :: Monad m => (a -> m b) -> [a] -> m () for f = foldr ((>>) . f) (return ()) while :: Monad m => m Bool -> m t -> m () while c m = do b <- c if b then m >> while c m else return () forever :: Monad m => m t forever m = m >> forever m
getChar :: IO Char putChar :: Char -> IO () readFile :: FilePath -> IO String writeFile :: FilePath -> String -> IO () hSetBuffering :: Handle -> BufferMode -> IO () hTell :: Handle -> IO Integer . . . . . .
Tmor : HomC(X, Y) -> HomD(Tobj(X), Tobj(Y)) map :: (a -> b) -> (f a -> f b)
Tmor Tobj T(id) = id : T(X) -> T(X) Identity T(f) . T(g) = T(f . g) : T(X) -> T(Z) Composition
(_)* : Hom(X, T(Y)) -> Hom(T(X), T(Y)) (=<<) :: (a -> m b) -> (m a -> m b)
f .T g = f* . g : X -> T(Z) f <=< g = (f =<<) . g :: a -> m c
eta .T g = g : Y -> T(Z) Left identity return <=< g = g :: b -> m c f .T eta = f : Z -> T(U) Right identity f <=< return = f :: c -> m d (f .T g) .T h = f .T (g .T h) : X -> T(U) Associativity (f <=< g) <=< h = f <=< (g <=< h) :: a -> m d
eta .T g = g eta* . g = g By definition of .T eta* . g = id . g forall f. id . f = f eta* = id forall f g h. f . h = g . h ==> f = g (f .T g) .T h = f .T (g .T h) (f* . g)* . h = f* . (g* . h) By definition of .T (f* . g)* . h = f* . g* . h . is associative (f* . g)* = f* . g* forall f g h. f . h = g . h ==> f = g
eta* = id : T(X) -> T(X) Left identity (return =<<) = id :: m t -> m t f* . eta = f : Z -> T(U) Right identity (f =<<) . return = f :: c -> m d (f* . g)* = f* . g* : T(X) -> T(Z) Associativity (((f =<<) . g) =<<) = (f =<<) . (g =<<) :: m a -> m c
eta : Id -> T return :: t -> f t mu : T . T -> T join :: f (f t) -> f t
mu . T(mu) = mu . mu : T . T . T -> T . T Associativity join . map join = join . join :: f (f (f t)) -> f t mu . T(eta) = mu . eta = id : T -> T Identity join . map return = join . return = id :: f t -> f t
class Functor m => Monad m where return :: t -> m t join :: m (m t) -> m t
instance Monad Maybe where return = Just join (Just m) = m join Nothing = Nothing
concat :: [[a]] -> [a] concat (x : xs) = x ++ concat xs concat [] = []
instance Monad [] where return :: t -> [t] return = (: []) (=<<) :: (a -> [b]) -> ([a] -> [b]) (f =<<) = concat . map f
mu = id* : T . T -> T join = (id =<<) :: m (m t) -> m t
f* = mu . T(f) : T(X) -> T(Y) (f =<<) = join . map f :: m a -> m b
fib = fix (\f -> \n -> if n < 2 then n else f (n-1) + f (n-2))
x = f . f $ x -- or x = f (f x) x = f . f . f $ x -- or x = f (f (f x)) x = f . f . f . f . f . f . f . f . f . f . f $ x -- etc.
fix id --> let x = id x in x --> id x --> id (id x) --> id (id (id x)) --> ...
(fix (\f h -> if (pred h) then f (mutate h) else h)) q
fix (\recurse d -> if d > 0 then d * (recurse (d-1)) else 1) 5 -->* 120
fix (\recurse d -> if d > 0 then d * (recurse (d-1)) else 1) 3 --> let x = (\recurse d -> if d > 0 then d * (recurse (d-1)) else 1) x in x 3 --> let x = ... in (\recurse d -> if d > 0 then d * (recurse (d-1)) else 1) x 3 --> let x = ... in (\d -> if d > 0 then d * (x (d-1)) else 1) 3
let x = ... in if 3 > 0 then 3 * (x (3 - 1)) else 1) --> let x = ... in 3 * x 2 --> let x = ... in 3 * (\recurse d -> if d > 0 then d * (recurse (d-1)) else 1) x 2 -->
let x = ... in 3 * (\d -> if d > 0 then d * (x (d-1)) else 1) 2 -->
λ <*Main Data.Function>: id undefined *** Exception: Prelude.undefined
λ <*Main Data.Function>: undefined *** Exception: Prelude.undefined λ <*Main Data.Function>: (\x->1:x) undefined [1*** Exception: Prelude.undefined
λ <*Main Data.Function>: let y=y in y ^CInterrupted. λ <*Main Data.Function>: (\x->1:x) (let y=y in y) [1^CInterrupted.
λ <*Main Data.Function>: repeat 1 [1,1,1,1,1,1, and so on λ <*Main Data.Function>: (\x->1:x) $ repeat 1 [1,1,1,1,1,1, and so on
(^) :: (Num a, Integral b) => a -> b -> a (^^) :: (Fractional a, Integral b) => a -> b -> a (**) :: Floating a => a -> a -> a
class Exp a b where (^) :: a -> b -> a instance (Num a, Integral b) => Exp a b where ... -- current ^ instance (Fractional a, Integral b) => Exp a b where ... -- current ^^ instance (Floating a, Floating b) => Exp a b where ... -- current **
import Data.Functor 42 <$ Just "boring" --> Just 42 42 <$ Nothing --> Nothing "cool" <$ ["nonsense","stupid","uninteresting"] --> ["cool","cool","cool"]
instance Bits Int where isSigned = const True bitSize = const wordSize ...
listOfNothings :: String -> [Maybe Char] listOfNothings = (map . const) Nothing
module Test ( module Test , module A ) where import Prelude() import A f x = x
data Pair a = P a a instance Functor Pair where fmap f (P x y) = P (f x) (f y) instance Monad Pair where return x = P x x P a b >>= f = P x y where P x _ = f a P _ y = f b
instance Functor Bad where fmap f (B x) = B $ fmap (fmap f) x
(1) join (return x) = x (2) join (fmap return x) = x (3) join (join x) = join (fmap join x)
join :: Bad (Bad a) -> Bad a (A) join (B Nothing) = ??? (B) join (B (Just (P (B Nothing) (B Nothing)))) = ??? (C) join (B (Just (P (B (Just (P x1 x2))) (B Nothing)))) = ??? (D) join (B (Just (P (B Nothing) (B (Just (P x1 x2)))))) = ??? (E) join (B (Just (P (B (Just (P x1 x2))) (B (Just (P x3 x4)))))) = ???
-- apply (1) to (B (Just (P y1 y2))) join (return = -- using our definition of return' join (B (Just (P (B (Just (P y1 y2))) (B (Just (P y1 y2)))))) = -- from (1) this should equal B (Just (P y1 y2))
-- apply (2) to (B (Just (P y1 y2))) join (fmap return = -- def of fmap join (B (Just (P (return y1) (return y2)))) = -- def of return join (B (Just (P (B (Just (P y1 y1))) (B (Just (P y2 y2)))))) = -- from (2) this should equal B (Just (P y1 y2))
{- import Control.Monad (guard) data Pair a = P a a deriving (Eq, Show) instance Functor Pair where fmap f (P x y) = P (f x) (f y) instance Monad Pair where return x = P x x P a b >>= f = P x y where P x _ = f a P _ y = f b newtype Bad a = B (Maybe (Pair a)) deriving (Eq, Show) instance Functor Bad where fmap f (B x) = B $ fmap (fmap f) x -- The only definition that could possibly work. unit :: a -> Bad a unit x = B (Just (P x x)) -- Number of possible definitions of join for this type. If this equals zero, no monad for you! joins :: Integer joins = sum $ do -- Try all possible ways of handling cases 3 and 4 in the definition of join below. let ways = [ \_ _ -> B Nothing , \a b -> B (Just (P a a)) , \a b -> B (Just (P a b)) , \a b -> B (Just (P b a)) , \a b -> B (Just (P b b)) ] :: [forall a. a -> a -> Bad a] c3 :: forall a. a -> a -> Bad a <- ways c4 :: forall a. a -> a -> Bad a <- ways let join :: forall a. Bad (Bad a) -> Bad a join (B Nothing) = B Nothing -- no choice join (B (Just (P (B Nothing) (B Nothing)))) = B Nothing -- again, no choice join (B (Just (P (B (Just (P x1 x2))) (B Nothing)))) = c3 x1 x2 join (B (Just (P (B Nothing) (B (Just (P x3 x4)))))) = c4 x3 x4 join (B (Just (P (B (Just (P x1 x2))) (B (Just (P x3 x4)))))) = B (Just (P x1 x4)) -- derived from monad laws -- We guard $ all (\x -> join (unit x) == x) bad1 guard $ all (\x -> join (fmap unit x) == x) bad1 -- This is the one that matters guard $ all (\x -> join (join x) == join (fmap join x)) bad3 return 1 main = putStrLn $ show joins ++ " combinations work." -- Functions for making all the different forms of Bad values containing distinct Ints. bad1 :: [Bad Int] bad1 = map fst (bad1 bad3 :: [Bad (Bad (Bad Int))] bad3 = map fst (bad3 bad1 bad1 bad2 bad2 (x, n (y, n return (B (Just (P x y)), n bad3 bad3 (x, n (y, n return (B (Just (P x y)), n
data Flip x = Flip Bool x instance Monad Flip where return x = Flip False x Flip False x >>= f = f x Flip True x >>= f = Flip (not b) y where Flip b y = f x
instance Monad (Flip :.: Thud) where -- that return x = C (Flip ??? Thud) ...
import Control.Monad newtype Comp r e a = Comp { uncomp :: Either e (r -> a) }
swap :: (r -> Either e a) -> Either e (r -> a) swap = uncomp . join . Comp . return . liftM (Comp . liftM return)
data False -- an empty datatype corresponding to logical false type Neg a = (a -> False) -- corresponds to logical negation
excludedMiddle :: Either b (Neg b) excludedMiddle = swap Left
newtype Comp r a = Comp { uncomp :: IO (r -> a) } swap :: (r -> IO a) -> IO (r -> a) swap = uncomp . join . Comp . return . liftM (Comp . liftM return)
main :: IO () main = do let foo True = print "First" >> return 1 foo False = print "Second" >> return 2 f <- swap foo input <- readLn print (f input)
swapEither :: IO (Either e a) -> Either e (IO a) swapWriter :: (Monoid e) => IO (Writer e a) -> Writer e (IO a) swapState :: IO (State e a) -> State e (IO a) ...
λ> let v n = ListT $ do {putStr (show n); return [0, 1]} λ> runListT $ ((v >=> v) >=> v) 0 0010101[0,1,0,1,0,1,0,1] λ> runListT $ (v >=> (v >=> v)) 0 0001101[0,1,0,1,0,1,0,1]
class Monoid m where mempty :: m mappend :: m -> m -> m
class Monad m => MonadPlus m where mzero :: m a mplus :: m a -> m a -> m a
instance MonadPlus Maybe where mzero = Nothing mplus (Just a) _ = Just a mplus _ mb = mb
instance Monoid a => Monoid (Maybe a) where mempty = Nothing mappend (Just a) (Just b) = Just (mappend a b) mappend Nothing x = x mappend x Nothing = x mappend Nothing Nothing = Nothing
$ cabal install lens $ ghci GHCi, version 7.6.3: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. > import Control.Lens
> [1,2,3,4,5] ^? element 2 -- 0 based indexing Just 3
> [1,2,3] !! 9 *** Exception: Prelude.(!!): index too large > [1,2,3] ^? element 9 Nothing
> [1,2,3] ^?! element 1 2 > [1,2,3] ^?! element 9 *** Exception: (^?!): empty Fold
> import Data.Tree > :{ let tree = Node 1 [ Node 2 [Node 4[], Node 5 []] , Node 3 [Node 6 [], Node 7 []] ] :} > putStrLn . drawTree . fmap show $tree 1 | +- 2 | | | +- 4 | | | `- 5 | `- 3 | +- 6 | `- 7
> tree ^? element 0 Just 1 > tree ^? element 1 Just 2 > tree ^? element 2 Just 4 > tree ^? element 3 Just 5 > tree ^? element 4 Just 3 > tree ^? element 5 Just 6 > tree ^? element 6 Just 7
> import qualified Data.Sequence as Seq > Seq.fromList [1,2,3,4] ^? element 3 Just 4
> [[1,2,3],[4,5,6]] ^? element 0 . element 1 Just 2 > [[1,2,3],[4,5,6]] ^? element 1 . element 2 Just 6
> :{ let tree = Node 1 [ Node 2 [] , Node 3 [] ] :} > putStrLn . drawTree . fmap show $ tree 1 | +- 2 | `- 3 > :{ let listOfTrees = [ tree , fmap (*2) tree -- All tree elements times 2 , fmap (*3) tree -- All tree elements times 3 ] :} > listOfTrees ^? element 1 . element 0 Just 2 > listOfTrees ^? element 1 . element 1 Just 4
>>> a = [1,2,3,4,5] >>> a[3] = 9 >>> a [1, 2, 3, 9, 5]
> let a = [1,2,3,4,5] > a & element 3 .~ 9 [1,2,3,9,5] > a [1,2,3,4,5]
> [[1,2,3],[4,5,6]] & element 0 . element 1 .~ 9 [[1,9,3],[4,5,6]]
data Maybe a = Nothing | Just a lookup :: Int -> [a] -> Maybe a lookup _ [] = Nothing lookup 0 (x : _) = Just x lookup i (_ : xs) = lookup (i - 1) xs
nth :: Int -> [a] -> Maybe a nth _ [] = Nothing nth 1 (x : _) = Just x nth n (_ : xs) = nth (n - 1) xs
dataAt :: Int -> [a] -> a dataAt _ [] = error "Empty List!" dataAt y (x:xs) | y <= 0 = x | otherwise = dataAt (y-1) xs
Publisher.hs:45:9: Warning: orphan instance: instance ToSElem Result
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a foldr k v (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr -> go v (ptr `plusPtr` (s+l-1)) (ptr `plusPtr` (s-1)) where STRICT3(go) go z p q | p == q = return z | otherwise = do c <- peek p go (c `k` z) (p `plusPtr` (-1)) q -- tail recursive {-
foldr k z = go where go [] = z go (y:ys) = y `k` go ys
myCollectBinders expr = go [] expr where go bs (Lam b e) = go (b:bs) e go bs e@(Note (SCC _) _) = (reverse bs, e) go bs (Cast e _) = go bs e go bs (Note _ e) = go bs e go bs e = (reverse bs, e)
showInt n r | n < 0 = error "Numeric.showInt: can | otherwise = go n r where go n r = case quotRem n 10 of { (n case chr (ord_0 + fromIntegral d) of { C let r in if n }}
data Lens a b = Lens { getter :: a -> b, setter :: b -> a -> a }
fstLens :: Lens (a, b) a fstLens = Lens fst $ \x (a, b) -> (x, b) sndLens :: Lens (a, b) b sndLens = Lens snd $ \x (a, b) -> (a, x)
compose :: Lens b c -> Lens a b -> Lens a c compose f g = Lens (getter f . getter g) $ \c a -> setter g (setter f c (getter g a)) a
lensGet :: MonadState s m => Lens s a -> m a lensGet = gets . getter lensSet :: MonadState s m => Lens s b -> b -> m () lensSet f = modify . setter f lensMod :: MonadState s m => Lens s b -> (b -> b) -> m () lensMod f g = modify $ setter f =<< g . getter f (+=) :: (MonadState s m, Num b) => Lens s b -> b -> m () f += x = lensMod f (+ x)
--tail recursive fac :: (Integral a) => a -> a fac x = fac fac fac --normal recursive facSlow :: (Integral a) => a -> a facSlow 1 = 1 facSlow x = x * facSlow (x-1)
facSlow 5 5 * facSlow 4 -- Note that the `5-1` only got evaluated to 4 5 * (4 * facSlow 3) -- because it has to be checked against 1 to see 5 * (4 * (3 * facSlow 2)) -- which definition of `facSlow` to apply. 5 * (4 * (3 * (2 * facSlow 1))) 5 * (4 * (3 * (2 * 1))) 5 * (4 * (3 * 2)) 5 * (4 * 6) 5 * 24 120
fac 5 fac fac fac fac fac {2*{3*{4*{5*1}}}} -- the thunk "{...}" (2*{3*{4*{5*1}}}) -- is retraced (2*(3*{4*{5*1}})) -- to create (2*(3*(4*{5*1}))) -- the computation (2*(3*(4*(5*1)))) -- on the stack (2*(3*(4*5))) (2*(3*20)) (2*60) 120
facSlim :: (Integral a) => a -> a facSlim x = facS facS facS
length $ foldl1 (++) $ replicate 1000 "The size of intermediate expressions is more important than tail recursion." length $ foldr1 (++) $ replicate 1000 "The number of reductions performed is more important than tail recursion!!!"
{- fac :: (Integral a) => a -> a fac x = fac fac fac
func = boo . boppity . bippity . snd where boo = ... boppity = ... bippity = ...
template<typename T> class Singleton { public: static T& Instance() { static T me; return me; } protected: virtual ~Singleton() {}; Singleton() {}; }
-- silly example, doesn findMatches :: Eq a => a -> [a] -> [a] findMatches x ys = [ y | y <- ys, x == y ] -- version using EqDict findMatchesDict :: EqDict a -> a -> [a] -> [a] findMatchesDict (EqDict f) x ys = [ y | y <- ys, f x y ]
htmlToItems :: Text -> [Item] htmlToItems = getItems . parseTags . convertFuzzy Discard "CP1251" "UTF8"
htmlToItems :: Text -> [Item] htmlToItems = getItems . parseTags . fromLazyBS . convertFuzzy Discard "CP1251" "UTF8" . toLazyBS where toLazyBS t = fromChunks [encodeUtf8 t] fromLazyBS t = decodeUtf8 $ intercalate "" $ toChunks t
Data.ByteString.Lazy.fromChunks :: [Data.ByteString.Internal.ByteString] -> ByteString
main1 = do s <- getLine if s == "foo" then putStr "You entered foo"
nop :: IO () nop = sequence_ [] main2 = do s <- getLine if s == "foo" then putStr "You entered foo" else nop
doIf :: Bool -> IO () -> IO () doIf b m = if b then m else nop main3 = do s <- getLine doIf (s == "foo") (putStr "You entered foo")
import Control.Monad main = do s <- getLine when (s == "foo") $ putStr "You entered foo"
myDiv :: Int -> Int -> Int myDiv a b = let x = fromIntegral a y = fromIntegral b in truncate (x / y)
class (Functor f, Functor g) => Adjoint f g where counit :: f (g a) -> a unit :: a -> g (f a)
phiLeft :: Adjoint f g => (f a -> b) -> (a -> g b) phiLeft f = fmap f . unit phiRight :: Adjoint f g => (a -> g b) -> (f a -> b) phiRight f = counit . fmap f
instance Adjoint f g => Monad (Compose g f) where return x = Compose $ unit x x >>= f = Compose . fmap counit . getCompose $ fmap (getCompose . f) x
instance Adjoint ((,) a) ((->) a) where -- counit :: (a,a -> b) -> b counit (x, f) = f x -- unit :: b -> (a -> (a,b)) unit x = \y -> (y, x)
import Prelude hiding (zip,zipWith) import Graphics.Gnuplot.Simple import Data.Array.Accelerate -- import Data.Array.Accelerate.Interpreter import Data.Array.Accelerate.CUDA f :: Vector Float -> Vector Float -> Acc (Vector Float) f xs ys = let xs ys in (zipWith (*) xs n=10::Int points = toList.run $ f (fromList (Z:.n) [1..10]) (fromList (Z:.n) [-5..4]) main = plotList [] points
import System.Process clear :: IO () clear = system "cls"
import qualified System.Process as SP clearScreen :: IO () clearScreen = do _ <- SP.system "reset" return ()
mkList :: Int -> [Int] mkList n = [1..n-1] euler :: Int -> Int euler n = length (filter (relprime n) (mkList n)) sumEuler :: Int -> Int sumEuler = sum . (map euler) . mkList
sum :: Num a => [a] -> a map :: (a -> b) -> [a] -> [b] euler :: Int -> Int mkList :: Int -> [Int] (map euler) :: [Int] -> [Int] (map euler) . mkList :: Int -> [Int] sum . (map euler) . mkList :: Int -> Int
sumEuler myArgument = sum (map euler (mkList myArgument))
map_euler = map euler sumEuler = sum . map_euler . mkList
(.) :: (b -> c) -> (a -> b) -> a -> c (.) f g = \x -> f (g x)
x = 5 `div` 0 test = try (print x) :: IO (Either SomeException ())
main = do result <- try (evaluate (5 `div` 0)) :: IO (Either SomeException Int) case result of Left ex -> putStrLn $ "Caught exception: " ++ show ex Right val -> putStrLn $ "The answer was: " ++ show val
main = catch (print $ 5 `div` 0) handler where handler :: SomeException -> IO () handler ex = putStrLn $ "Caught exception: " ++ show ex
main = do result <- tryJust selectDivByZero (evaluate $ 5 `div` 0) case result of Left what -> putStrLn $ "Division by " ++ what Right val -> putStrLn $ "The answer was: " ++ show val where selectDivByZero :: ArithException -> Maybe String selectDivByZero DivideByZero = Just "zero" selectDivByZero _ = Nothing
do handle (\NonTermination -> exitWith (ExitFailure 1)) $ ...
let handler = handle (\NonTermination -> exitWith (ExitFailure 1))
do let result = 5 `div` 0 let handler = (\_ -> print "Error") :: IOException -> IO () catch (print result) handler
let x = 5 `div` 0 result <- try (print x) :: IO (Either SomeException ()) case result of Left _ -> putStrLn "Error" Right () -> putStrLn "OK"
let x = 5 `div` 0 result <- try (print x) case result of Left (_ :: SomeException) -> putStrLn "Error" Right () -> putStrLn "OK"
f <$> ZipList xs1 <*> ... <*> ZipList xsn = ZipList (zipWithn f xs1 ... xsn)
userData = User <$> field "Name" <*> field "Address"
userData = do name <- field "Name" address <- field $ name ++ " return (User name address)
-- file: ch16/FormApp.hs p_hex :: CharParser () Char p_hex = do char a <- hexDigit b <- hexDigit let ((d, _):_) = readHex [a,b] return . toEnum $ d
-- file: ch16/FormApp.hs a_hex = hexify <$> (char where hexify a b = toEnum . fst . head . readHex $ [a,b]
import Control.Applicative hasCommentA blogComments = BlogComment <$> lookup "title" blogComments <*> lookup "user" blogComments <*> lookup "comment" blogComments
Prelude> head [] *** Exception: Prelude.head: empty list
True = const True (head []) = head [] = const False (head []) = False
mergesortBy less [] = [] mergesortBy less xs = head $ until (null.tail) pairs [[x] | x <- xs] where pairs (x:y:t) = merge x y : pairs t pairs xs = xs merge (x:xs) (y:ys) | less y x = y : merge (x:xs) ys | otherwise = x : merge xs (y:ys) merge xs [] = xs merge [] ys = ys
mgsort xs = go $ map ((,) 0) xs where go [] = [] go xs = head $ until (null.tail) pairs [[x] | x <- xs] where .... merge ((a,b):xs) ((c,d):ys) | (d < b) = (a+c+1,d) : merge ((a+1,b):xs) ys -- cumulative | otherwise = (a+c+1,b) : merge xs ((c+1,d):ys) -- cost .... g n = concat [[a,b] | (a,b) <- zip [1,3..n] [n,n-2..1]] -- a little scrambler
*Main> map (fst . head . mgsort . g) [10, 20, 40, 80, 160, 1600] [9,19,39,79,159,1599]
merge ((a,b):xs) ((c,d):ys) | (d < b) = (c+1,d) : merge ((a+1,b):xs) ys -- individual | otherwise = (a+1,b) : merge xs ((c+1,d):ys) -- cost
*Main> let xs = map (sum . map fst . mgsort . g) [20, 40, 80, 160, 320, 640] [138,342,810,1866,4218,9402] *Main> map (logBase 2) $ zipWith (/) (tail xs) xs [1.309328,1.2439256,1.2039552,1.1766101,1.1564085]
*Main> let xs = [n*log n | n<- [20, 40, 80, 160, 320, 640]] in map (logBase 2) $ zipWith (/) (tail xs) xs [1.3002739,1.2484156,1.211859,1.1846942,1.1637106]
sort :: (Ord a) => [a] -> [a] sort xs = xmin:(sort xs where (xmin, xs
sort [] = [] sort (x:xs) = m : sort (delete m (x:xs)) where m = foldl (\x y -> if x < y then x else y) x xs
import Debug.Trace import Data.List myCmp x y = trace (" myCmp " ++ show x ++ " " ++ show y) $ compare x y xs = [5,8,1,3,0,54,2,5,2,98,7] main = do print "Sorting entire list" print $ sortBy myCmp xs print "Head of sorted list" print $ head $ sortBy myCmp xs
import System.Random import Debug.Trace import Data.List import System.Environment rs n = do gen <- newStdGen let ns = randoms gen :: [Int] return $ take n ns cmp1 x y = trace "*" $ compare x y cmp2 x y = trace " main = do n <- fmap (read . (!!0)) getArgs xs <- rs n print "Sorting entire list" print $ sortBy cmp1 xs print "Head of sorted list" print $ head $ sortBy cmp2 xs
import matplotlib.pyplot as plt import numpy as np import envoy res = [] x = range(10,500000,10000) for i in x: r = envoy.run( res.append((r.std_err.count( plt.plot(x, map(lambda x:x[0], res), label="sort") plt.plot(x, map(lambda x:x[1], res), label="minimum") plt.plot(x, x*np.log2(x), label="n*log(n)") plt.plot(x, x, label="n") plt.legend() plt.show()
>>> import numpy as np >>> np.polyfit(x, map(lambda x:x[1], res), deg=1) array([ 1.41324057, -17.7512292 ])
type T = ReaderT Int (WriterT String IO) Bool > :t \x -> (lift x :: T) \x -> (lift x :: T) :: WriterT String IO Bool -> T > :t \x -> (liftIO x :: T) \x -> (liftIO x :: T) :: IO Bool -> T
foo :: Int -> Int foo x = g (x + 2) where g y = x^y
> :break foo Breakpoint 1 activated at /tmp/Foo.hs:(2,1)-(3,17) > foo 42 Stopped at /tmp/Foo.hs:(2,1)-(3,17) _result :: Int = _
[/tmp/Foo.hs:(2,1)-(3,17)] > :step Stopped at /tmp/Foo.hs:2:9-17 _result :: Int = _ g :: Integral b => b -> Int = _ x :: Int = 42
[/tmp/Foo.hs:2:9-17] > g 2 1764 [/tmp/Foo.hs:2:9-17] > g 3 74088
{- module THEnv ( -- * Compile-time configuration lookupCompileEnv , lookupCompileEnvExp , getCompileEnv , getCompileEnvExp , fileAsString ) where import Control.Monad import qualified Data.Text as T import qualified Data.Text.IO as T import Language.Haskell.TH import Language.Haskell.TH.Syntax (Lift(..)) import System.Environment (getEnvironment) -- Functions that work with compile-time configuration -- | Looks up a compile-time environment variable. lookupCompileEnv :: String -> Q (Maybe String) lookupCompileEnv key = lookup key `liftM` runIO getEnvironment -- | Looks up a compile-time environment variable. The result is a TH -- expression of type @Maybe String@. lookupCompileEnvExp :: String -> Q Exp lookupCompileEnvExp = (`sigE` [t| Maybe String |]) . lift <=< lookupCompileEnv -- We need to explicly type the result so that things like `print Nothing` -- work. -- | Looks up an compile-time environment variable and fail, if it -- present. getCompileEnv :: String -> Q String getCompileEnv key = lookupCompileEnv key >>= maybe (fail $ "Environment variable " ++ key ++ " not defined") return -- | Looks up an compile-time environment variable and fail, if it -- present. The result is a TH expression of type @String@. getCompileEnvExp :: String -> Q Exp getCompileEnvExp = lift <=< getCompileEnv -- | Loads the content of a file as a string constant expression. -- The given path is relative to the source directory. fileAsString :: FilePath -> Q Exp fileAsString = do -- addDependentFile path -- works only with template-haskell >= 2.7 stringE . T.unpack . T.strip <=< runIO . T.readFile
{- import THEnv main = print $( lookupCompileEnvExp "DEBUG" )
Prelude> take 10 $ foldr (:) [] [1..] [1,2,3,4,5,6,7,8,9,10]
Prelude> foldl (flip (:)) [] [1..] ^CInterrupted. Prelude> foldl (\x y -> y) 0 [1..] ^CInterrupted.
foldr (:) z (1:[2..]) ==> (:) 1 (foldr (:) z [2..]) 1 : foldr (:) z (2:[3..]) ==> 1 : (:) 2 (foldr (:) z [3..]) 1 : 2 : foldr (:) z (3:[4..]) ==> 1 : 2 : (:) 3 (foldr (:) z [4..]) 1 : 2 : 3 : ( lazily evaluated thunk - foldr (:) z [4..] )
foldr _ z [] = z foldr f z (x:xs) = f x $ foldr f z xs
dumbFunc :: a -> b -> String dumbFunc _ _ = "always returns the same string" testFold = foldr dumbFunc 0 [1..]
any :: (a -> Bool) -> [a] -> Bool any f = (foldr (||) False) . (map f)
foldl f z [] = z foldl f z (x:xs) = foldl f (f z x) xs
-- file: ch04/Fold.hs myFoldl :: (a -> b -> a) -> a -> [b] -> a myFoldl f z xs = foldr step id xs z where step x g a = g (f a x)
myFoldl stepL zeroL xs = (foldr stepR id xs) zeroL where stepR lastL accR accInitL = accR (stepL accInitL lastL)
myFoldl (+) 0 [1, 2, 3] = (foldR step id [1, 2, 3]) 0 = (step 1 (step 2 (step 3 id))) 0 = (step 1 (step 2 (\a3 -> id ((+) a3 3)))) 0 = (step 1 (\a2 -> (\a3 -> id ((+) a3 3)) ((+) a2 2))) 0 = (\a1 -> (\a2 -> (\a3 -> id ((+) a3 3)) ((+) a2 2)) ((+) a1 1)) 0 = (\a1 -> (\a2 -> (\a3 -> (+) a3 3) ((+) a2 2)) ((+) a1 1)) 0 = (\a1 -> (\a2 -> (+) ((+) a2 2) 3) ((+) a1 1)) 0 = (\a1 -> (+) ((+) ((+) a1 1) 2) 3) 0 = (+) ((+) ((+) 0 1) 2) 3 = ((0 + 1) + 2) + 3
foldl :: (β → α → β) → β → ([α] → β) foldl f v [ ] = v foldl f v (x : xs) = foldl f (f v x) xs
reverse :: [α] → [α] reverse = foldl (λxs x → x : xs) [ ]
foldl f v xs = fold (λx g → (λa → g (f a x))) id xs v
foldl :: (a -> b -> a) -> a -> [b] -> a foldl f v [] = v foldl f v (x : xs) = foldl f (f v x) xs
foldl :: (a -> b -> a) -> a -> [b] -> a foldl f v xs = g xs v where g [] v = v g (x:xs) v = g xs (f v x)
foldl f v xs = g xs v where g [] = \v -> v g (x:xs) = \v -> g xs (f v x)
foldl f v xs = g xs v where g [] = id g (x:xs) = \v -> g xs (f v x)
fold :: (α → β → β) → β → ([α] → β) fold f v [ ] = v fold f v (x : xs) = f x (fold f v xs)
g (x:xs) = k x (g xs) <=> g (x:xs) v = k x (g xs) v -- accumulator of functions <=> g xs (f v x) = k x (g xs) v -- definition of foldl <= g <=> k = \x g
foldl :: (a -> b -> a) -> a -> [b] -> a foldl f v xs = foldr (\x g -> (\a -> g (f v x))) id xs v
step :: b -> (a -> a) -> (a -> a) step x g = \a -> g (f a x)
sum [] = 0 {- recursion becomes fold -} sum (x:xs) = x + sum xs ⇒ sum = foldr 0 (+)
product [] = 1 product (x:xs) = x * product xs ⇒ product = foldr 1 (*) length [] = 0 length (x:xs) = 1 + length xs ⇒ length = foldr (\_ a -> 1 + a) 0
sum [] = 0 -- given `sum [1,2,3]` expands into `(1 + (2 + 3))` sum (x:xs) = x + sum xs
suml -- expand suml suml -- replace `suml g (n+x) = f x g n
foldr (\x g n -> g (n + x)) id [1..10] 0 -- return 55
foldl f a xs = foldr (\x g n -> g (n `f` x)) id xs a foldl (-) 10 [1..5] -- returns -5
myfoldl f z xs = foldr step_f id xs z where step_f x g a = g (f a x)
myfoldl f z [] = foldr step_f id [] z (by definition of myfoldl) = id z (by definition of foldr) = z foldl f z [] = z (by definition of foldl)
myfoldl f z (x:xs) = foldr step_f id (x:xs) z (by definition of myfoldl) = step_f x (foldr step_f id xs) z (-> apply step_f) = (foldr step_f id xs) (f z x) (-> remove parentheses) = foldr step_f id xs (f z x) = myfoldl f (f z x) xs (definition of myfoldl) foldl f z (x:xs) = foldl f (f z x) xs
h z = (foldr step id xs) z where step x g = \a -> g (f a x)
= (\a0 -> (\a1 -> (\a2 -> id (f a2 x2)) (f a1 x1)) (f a0 x0)) z
= (\a1 -> (\a2 -> id (f a2 x2)) (f a1 x1)) (f z x0) = (\a2 -> id (f a2 x2)) (f (f z x0) x1) = id (f (f (f z x0) x1) x2)
myFoldl (+) 0 [1,2,3] = foldr step id [1,2,3] 0 = foldr step (\a -> id (a+3)) [1,2] 0 = foldr step (\b -> (\a -> id (a+3)) (b+2)) [1] 0 = foldr step (\b -> id ((b+2)+3)) [1] 0 = foldr step (\c -> (\b -> id ((b+2)+3)) (c+1)) [] 0 = foldr step (\c -> id (((c+1)+2)+3)) [] 0 = (\c -> id (((c+1)+2)+3)) 0 = ...
foldr step zero (x:xs) = step x (foldr step zero xs) foldr _ zero [] = zero myFold f z xs = foldr step id xs z where step x g a = g (f a x) myFold (+) 0 [1, 2, 3] = foldr step id [1, 2, 3] 0 -- Expanding foldr function step 1 (foldr step id [2, 3]) 0 step 1 (step 2 (foldr step id [3])) 0 step 1 (step 2 (step 3 (foldr step id []))) 0 -- Expanding step function if it is possible step 1 (step 2 (step 3 id)) 0 step 2 (step 3 id) (0 + 1) step 3 id ((0 + 1) + 2) id (((0 + 1) + 2) + 3)
import Data.List numUniques :: (Eq a) => [a] -> Int numUniques = length . nub
Prelude Data.List> import Data.List Prelude Data.List> let numUniques Prelude Data.List> :t numUniques' numUniques
-- Haskell data Positioning a = Append | AppendIf (a -> Bool) | Explicit ([a] -> [a])
newtype Cont r a = Cont { runCont :: (a -> r) -> r } instance Monad (Cont r) where return a = Cont ($ a) m >>= k = Cont $ \c -> runCont m $ \a -> runCont (k a) c
> :t flip ($) True flip ($) True :: (Bool -> b) -> b
m >>= k = Cont $ \c -> runCont m $ \a -> runCont (k a) c
do x <- [10, 20] y <- [3,5] return (x+y) [10,20] >>= \x -> [3,5] >>= \y -> return (x+y) ([10,20] >>=) $ \x -> ([3,5] >>=) $ \y -> return (x+y)
newtype Cont r a = Cont { runCont :: (a -> r) -> r }
flip runCont id $ do v <- thing1 thing2 v x <- Cont $ \k -> ... thing3 x thing4
instance Functor (Cont r) where fmap f (Cont c) = Cont $ \k -> ...
instance Applicative (Cont r) where pure x = Cont $ \k -> ...
Cont cf <*> Cont cx = Cont $ \k -> cf (\fn -> cx (\x -> k (fn x)))
data GroceryItem = CartItem ItemName Price Quantity | StockItem ItemName Price Quantity makeGroceryItem :: String -> Float -> Int -> GroceryItem makeGroceryItem name price quantity = CartItem name price quantity I want to create a `GroceryItem` when using a `String` or `[String]` createGroceryItem :: [String] -> GroceryItem createGroceryItem (a:b:c) = makeGroceryItem a b c
*Type error in application *** Expression : makeGroceryItem a read b read c *** Term : makeGroceryItem *** Type : String -> Float -> Int -> GroceryItem *** Does not match : a -> b -> c -> d -> e -> f*
Prelude> :set +t Prelude> read "123.456" :: Float 123.456 it :: Float Prelude> read "123456" :: Int 123456 it :: Int
reads :: (Read a) => String -> [(a, String)] Prelude> reads "5" :: [(Double, String)] [(5.0,"")] Prelude> reads "5ds" :: [(Double, String)] [(5.0,"ds")] Prelude> reads "dffd" :: [(Double, String)] []
createGroceryItem [a, b, c] = makeGroceryItem a (parse b) (parse c) -- pattern match error if not exactly 3 items in list
createGroceryItem (a : b : c : _) = makeGroceryItem a (parse b) (parse c) -- pattern match error if fewer than 3 items in list, ignore excess items
filterNumberFromString :: String -> String filterNumberFromString s = let allowedString = [ toPoint n | n == | otherwise = n f = filter (`elem` allowedString) s d = map toPoint f in d convertStringToFloat :: String -> Float convertStringToFloat s = let betterString = filterNumberFromString s asFloat = read betterString :: Float in asFloat print (convertStringToFloat "15,00" + 1)
-- This is an error... but let let a = runST $ newSTRef (15 :: Int) b = runST $ writeSTRef a 20 c = runST $ readSTRef a in b `seq` c
a = runST (newSTRef (15 :: Int) :: forall s. ST s (STRef s Int))
f :: (forall a. [a] -> b) -> Bool -> b f g flag = if flag then g "abcd" else g [1,2] > :t f length f length :: Bool -> Int > :t f id -- error --
(tool-bar-mode -1) (scroll-bar-mode -1) (setq-default truncate-lines t) (setq line-number-mode t) (setq column-number-mode t) (set-keyboard-coding-system (prefer-coding-system (set-face-attribute (setq-default indent-tabs-mode nil) (setq default-tab-width 4) (load "~/.emacs.d/haskell-mode/haskell-mode") (add-to-list (add-to-list (add-hook
intersperse :: a -> [[a]] -> [a] -- intersperse -- should produce the following: -- "foo*bar*baz*quux" -- intersperse -99 [ [1,2,3],[4,5,6],[7,8,9]] -- should produce the following: -- [1,2,3,-99,4,5,6,-99,7,8,9] intersperse _ [] = [] intersperse _ [x] = x intersperse s (x:y:xs) = x:s:y:intersperse s xs
Prelude> :load ./chapter.3.ending.real.world.haskell.exercises.hs [1 of 1] Compiling Main (chapter.3.ending.real.world.haskell.exercises.hs, interpreted ) chapter.3.ending.real.world.haskell.exercises.hs:147:0: Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `intersperse' Failed, modules loaded: none.
intersperse _ [] = [] intersperse _ [x] = x intersperse s (x:xs) = x ++ s:intersperse s xs
intersperse _ [] = [] intersperse _ [x] = x intersperse s (x:y:xs) = x ++ [s] ++ y ++ intersperse s xs
intersperse _ [] = [] intersperse _ [x] = x intersperse s (x:xs) = x ++ [s] ++ intersperse s xs
Occurs check: cannot construct the infinite type: a = [a] Expected type: [a] -> [[a]] -> [[a]] Inferred type: [a] -> [[a]] -> [a] In the second argument of `(:) In the second argument of `(:)
intersperse 11 [1, 3, 5, 7, 9] = [1, 11, 3, 11, 5, 11, 7, 11, 9] intersperse "*" ["foo","bar","baz","quux"] = ["foo", "*", "bar", "*", "baz", "*", "quux"]
fibs = 0 : 1 : <thunk1> tail fibs = 1 : <thunk1> zipWith (+) fibs (tail fibs) = <thunk1>
fibs = 0 : 1 : 1: <thunk2> tail fibs = 1 : 1 : <thunk2> zipWith (+) fibs (tail fibs) = 1 : <thunk2>
fibs = 0 : 1 : 1 : 2 : <thunk3> tail fibs = 1 : 1 : 2 : <thunk3> zipWith (+) fibs (tail fibs) = 1 : 2 : <thunk3>
fibs = 0 : 1 : 1 : 2 : 3 : <thunk4> tail fibs = 1 : 1 : 2 : 3 : <thunk4> zipWith (+) fibs (tail fibs) = 1 : 2 : 3 : <thunk4>
printf :: (PrintfType r) => String -> r printf fmts = spr fmts [] class PrintfType t where spr :: String -> [UPrintf] -> t instance (IsChar c) => PrintfType [c] where spr fmts args = map fromChar (uprintf fmts (reverse args)) instance (PrintfArg a, PrintfType r) => PrintfType (a -> r) where spr fmts args = \a -> spr fmts (toUPrintf a : args)
variadicFunction :: VariadicReturnClass r => RequiredArgs -> r variadicFunction reqArgs = variadicImpl reqArgs mempty class VariadicReturnClass r where variadicImpl :: RequiredArgs -> AccumulatingType -> r instance VariadicReturnClass ActualReturnType where variadicImpl reqArgs acc = constructActualResult reqArgs acc instance (ArgClass a, VariadicReturnClass r) => VariadicReturnClass (a -> r) where variadicImpl reqArgs acc = \a -> variadicImpl reqArgs (specialize a `mappend` acc)
class SumRes r where sumOf :: Integer -> r instance SumRes Integer where sumOf = id instance (Integral a, SumRes r) => SumRes (a -> r) where sumOf x = sumOf . (x +) . toInteger
*Main> sumOf 1 :: Integer 1 *Main> sumOf 1 4 7 10 :: Integer 22 *Main> sumOf 1 4 7 10 0 0 :: Integer 22 *Main> sumOf 1 4 7 10 2 5 8 22 :: Integer 59
instance BuildList a r => BuildList a (a->r) where build
sumOf 1 4 7 10 (( \ x -> ( sumOf . (x +) . toInteger ) 1 ) 4 7 10 ((sumOf . (1 + ) . toInteger) 4 ) 7 10 ( sumOf 5 ) 7 10 ( sumOf . (5 + ) . toInteger ) 7 10 sumOf 12 10 sumOf . (12 + ) . toInteger 10 sumof 22 id 22 22
$ ghci ... Prelude> :k (->) (->) :: ?? -> ? -> * Prelude>
? /\ / \ ?? ( / \ * Where: * [LiftedTypeKind] means boxed type ( ?? [ArgTypeKind] is the lub of {*, ? [OpenTypeKind] means any type at all
> error :: forall a:?. String -> a > (->) :: ?? -> ? -> * > (\\(x::t) -> ...)
{- import GHC.Prim example :: Int example = id -- does not work, since id :: a -> a
Couldn When matching types a0 :: * Int Expected type: Int Actual type: a0 -> a0 In the expression: id
($) :: forall (w :: Levity) a (b :: TYPE w). (a -> b) -> a -> b -- will likely change according to Richard E.
-- pseudo types ($) :: forall a (b :: TYPE Lifted). (a -> b) -> a -> b ($) :: forall a (b :: TYPE Unlifted). (a -> b) -> a -> b
Con :: Int -> T Nil :: T unCon :: T -> Int unCon (Con x) = x
data T = Con (exists x. t) | Nil data T = forall x. Con t | Nil
class SymbolSet tpe where data Symbol tpe :: * data SSet tpe where Identity :: tpe -> SSet tpe And :: SSet tpe -> Symbol tpe -> SSet tpe class HasElem a b where instance (SymbolSet tpe) => HasElem (And (Identity tpe) s) s instance (HasElem sset s) => HasElem (And sset s) s
{- class SymbolSet tpe where -- data Symbol tpe :: * data Symbol tpe :: * -- ...
{- class SymbolSet tpe where -- MOVED OUT OF CLASS: data Symbol tpe :: * data SSet tpe where Identity :: tpe -> SSet tpe And :: SSet tpe -> Symbol tpe -> SSet tpe -- ADDED KIND SIGNATURES: class HasElem (a :: SSet *) (b :: Symbol *) where instance (SymbolSet tpe) => HasElem (And (Identity tpe) s) s instance (HasElem sset s) => HasElem (And sset s) s
-- | Takes a generic type of STM chan and, given read and close functionality, -- returns a conduit chanSource :: (MonadIO m, MonadSTM m) => a -- ^ The channel -> (a -> STM (Maybe b)) -- ^ The read function -> (a -> STM ()) -- ^ The close/finalizer function -> Source m b chanSource ch readCh closeCh = ConduitM pull where close = liftSTM $ closeCh ch pull = PipeM $ liftSTM $ readCh ch >>= translate translate = return . maybe (Done ()) (HaveOutput pull close)
-- | Takes a stream and, given write and close functionality, returns a sink -- which wil consume elements and broadcast them into the channel chanSink :: (MonadIO m, MonadSTM m) => a -- ^ The channel -> (a -> b -> STM()) -- ^ The write function -> (a -> STM()) -- ^ The close/finalizer function -> Sink b m () chanSink ch writeCh closeCh = ConduitM sink where close = const . liftSTM $ closeCh ch sink = NeedInput push close write = liftSTM . writeCh ch push x = PipeM $ write x >> return sink
-- | Merges a list of -- a source which consumes the elements of the channel. mergeSources :: (MonadIO m, MonadBaseControl IO m, MonadSTM m) => [Source (ResourceT m) a] -- ^ The list of sources -> ResourceT m (Source (ResourceT m) a) mergeSources sx = liftSTM newTMChan >>= liftA2 (>>) (fsrc sx) retn where push c s = s $$ chanSink c writeTMChan closeTMChan fsrc x c = mapM_ (\s -> resourceForkIO $ push c s) x retn c = return $ chanSource c readTMChan closeTMChan
-- | Helper which represents a conduit chain for each client connection serverApp :: Application SessionIO serverApp appdata = do use ssBroadcast >>= liftIO . atomically . dupTMChan >>= assign ssBroadcast -- appSource appdata $$ decoder $= protocol =$= encoder =$ appSink appdata mergsrc $$ protocol $= encoder =$ appSink appdata where chansrc = chanSource (use ssBroadcast) readTMChan closeTMChan mergsrc = mergeSources [appSource appdata $= decoder, chansrc] -- | Structure which holds mutable information for clients data SessionState = SessionState { _ssBroadcast :: TMChan Packet -- ^ Outbound packet broadcast channel } makeLenses -- | A transformer encompassing both SessionReader and SessionState type Session m = ReaderT SessionReader (StateT SessionState m) -- | Macro providing Session applied to an IO monad type SessionIO = Session IO
mergeSources => [Source (ResourceT m) a] -- ^ The sources to merge. -> Int -- ^ The bound of the intermediate channel. -> ResourceT m (Source (ResourceT m) a) mergeSources c <- liftSTM $ newTBMChan bound mapM_ (\s -> resourceForkIO $ s $$ chanSink c writeTBMChan closeTBMChan) sx return $ sourceTBMChan c
factorial 0 = 1 factorial n = n * factorial (n - 1)
factorial(0, 1). factorial(X, Y) :- X1 is X - 1, factorial(X1, Z), Y is Z * X.
> let v = iterate (tail) [1..3] > v [[1,2,3],[2,3],[3],[],*** Exception: Prelude.tail: empty list
?- length(Xs,3), Xs = [X|Ys], maplist(dif(X), Ys). Xs = [X, _G639, _G642], Ys = [_G639, _G642], dif(X, _G642), dif(X, _G639).
?- maplist(=(_),Xs). Xs = [] ; Xs = [_G231] ; Xs = [_G231, _G231] ; Xs = [_G231, _G231, _G231] ; Xs = [_G231, _G231, _G231, _G231] .
?- length(Xs,3), Xs = [X|Ys], maplist(dif(X), Ys), maplist(=(_),Xs). false.
append [] ys = ys append (x:xs) ys = x : append xs ys
append([], Ys, Ys). append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
let foo = "foo" ++ bigchunk bar = "bar" ++ bigchunk
integer_cmm_int2Integerzh (W_ val) { W_ s, p; ALLOC_PRIM_N (SIZEOF_StgArrWords + WDS(1), integer_cmm_int2Integerzh, val); p = Hp - SIZEOF_StgArrWords; SET_HDR(p, stg_ARR_WORDS_info, CCCS); StgArrWords_bytes(p) = SIZEOF_W; if (%lt(val,0)) { s = -1; Hp(0) = -val; } else { if (%gt(val,0)) { s = 1; Hp(0) = val; } else { s = 0; } } /* returns ( data :: ByteArray# */ return (s,p); }
W_ is alias for word. ALLOC_PRIM_N is a function for allocating memory on the heap for primitive object. Sp(n) and Hp(n) are defined as below (comments are mine):
Hp = Hp + (SIZEOF_StgArrWords + WDS(1)); if (Hp > HpLim) { HpAlloc = SIZEOF_StgArrWords + WDS(1); goto stg_gc_prim_n(integer_cmm_int2Integerzh, val); }
8 bit numbers = 256 unique representable values 16 bit numbers = 65 536 unique representable values 32 bit numbers = 4 294 967 296 unique representable values 64 bit numbers = 18 446 744 073 709 551 616 unique representable values
var integer_cmm_int2Integerzh = function(word) { return WORDSIZE == 32 ? goog.math.Integer.fromInt(word)) : goog.math.Integer.fromBits([word.getLowBits(), word.getHighBits()]); };
goog.math.Integer.fromInt = function(value) { if (-128 <= value && value < 128) { var cachedObj = goog.math.Integer.IntCache_[value]; if (cachedObj) { return cachedObj; } } var obj = new goog.math.Integer([value | 0], value < 0 ? -1 : 0); if (-128 <= value && value < 128) { goog.math.Integer.IntCache_[value] = obj; } return obj; }; goog.math.Integer.fromBits = function(bits) { var high = bits[bits.length - 1]; return new goog.math.Integer(bits, high & (1 << 31) ? -1 : 0); };
ALLOC_PRIM_N (SIZEOF_StgArrWords + WDS(1), integer_cmm_int2Integerzh, val); p = Hp - SIZEOF_StgArrWords; SET_HDR(p, stg_ARR_WORDS_info, CCCS); StgArrWords_bytes(p) = SIZEOF_W;
class Monad m => MonadCont callCC shift :: (forall r.(a -> m r) -> m r) -> m a reset :: m a -> m a
--satisfy law: mzero >>= f === mzero class Monad m => MonadZero m where mzero :: m a instance (MonadZero m, MonadRef r m) => MonadCont callCC ref <- newRef Nothing v <- k (\a -> writeRef ref (Just a) >> mzero) r <- readRef ref return $ maybe v id r shift = ... reset = ...
instance (MonadPlus m, MonadRef r m) => MonadCont callCC ref <- newRef mzero mplus (k $ \a -> writeRef ref (return a) >> mzero) (join (readRef ref))
Prelude Control.Applicative> (++) <$> getLine <*> getLine hi there "hithere"
Prelude Control.Applicative> (+) <$> Just 3 <*> Just 5 Just 8
Prelude Control.Applicative> (+) <$> Just 3 <*> Nothing Nothing
data Foo = Foo Int Double randomFoo = do x <- randomIO y <- randomIO return $ Foo x y
ghci> import Data.Time.Clock ghci> import Data.Time.Calendar ghci> getCurrentTime >>= return . toGregorian . utctDay
ghci> import Control.Applicative ghci> toGregorian . utctDay <$> getCurrentTime
data Coord = Coord { x :: Double, y :: Double } instance FromJSON Coord where parseJSON (Object v) = Coord <$> v .: "x" <*> v .: "y"
data Maybe a = Nothing | Just a data Pair a b = Pair a b data List a = Nil | Cons a (List a) data Tree x = Leaf x | Branch (Tree x) (Tree x) data BTree a = Empty | Node a (BTree a) (BTree a)
foldMaybe :: ... -> Maybe a -> r foldPair :: ... -> Pair a b -> r foldList :: ... -> List a -> r foldTree :: ... -> Tree a -> r foldBTree :: ... -> BTree a -> r
foldMaybe :: nothing -> just -> Maybe a -> r foldPair :: pair -> Pair a b -> r foldList :: nil -> cons -> List a -> r foldTree :: leaf -> branch -> Tree a -> r foldBTree :: empty -> node -> BTree a -> r
Nothing :: Maybe a Just :: a -> Maybe a Pair :: a -> b -> Pair a b Nil :: List a Cons :: a -> List a -> List a Leaf :: a -> Tree a Branch :: Tree a -> Tree a -> Tree a Empty :: BTree a Node :: a -> BTree a -> BTree a -> BTree a
nothing := r just := a -> r pair := a -> b -> r nil := r cons := a -> r -> r leaf := a -> r branch := r -> r -> r empty := r node := a -> r -> r -> r
foldMaybe :: r -> (a -> r) -> Maybe a -> r foldPair :: (a -> b -> r) -> Pair a b -> r foldList :: r -> (a -> r -> r) -> List a -> r foldTree :: (a -> r) -> (r -> r -> r) -> Tree a -> r foldBTree :: r -> (a -> r -> r -> r) -> BTree a -> r
foldMaybe :: (a -> r) -> r -> Maybe a -> r foldPair :: (a -> b -> r) -> Pair a b -> r foldList :: (a -> r -> r) -> r -> List a -> r foldTree :: (r -> r -> r) -> (a -> r) -> Tree a -> r foldBTree :: (a -> r -> r -> r) -> r -> BTree a -> r
foldBTree :: (a -> r -> r -> r) -> r -> BTree a -> r foldBTree = ???
foldBTree :: (a -> r -> r -> r) -> r -> BTree a -> r foldBTree branch empty tree = ???
foldBTree :: (a -> r -> r -> r) -> r -> BTree a -> r foldBTree branch empty Empty = ??? foldBTree branch empty (Branch a l r) = ??? -- Let -- a :: a -- l, r :: BTree a
foldBTree :: (a -> r -> r -> r) -> r -> BTree a -> r foldBTree branch empty Empty = empty foldBTree branch empty (Branch a l r) = ??? -- a :: a -- l, r :: BTree a
foldBTree :: (a -> r -> r -> r) -> r -> BTree a -> r foldBTree branch empty Empty = empty foldBTree branch empty (Branch a l r) = branch a (subfold l) (subfold r) where subfold = foldBTree branch empty
mangleBTree :: (a -> r -> r -> r) -> r -> BTree a -> r mangleBTree branch empty Empty = empty mangleBTree branch empty (Branch a l r) = branch a (submangle r) (submangle l) where submangle = mangleBTree branch empty
{- -- | A Church-encoded list is a function that takes the two -- and produces a result from them. newtype ChurchList a = ChurchList { runList :: forall r. (a -> r -> r) -- ^ first arg of -> r -- ^ second arg of -> r -- ^ } -- | Convenience function: make a ChurchList out of a regular list toChurchList :: [a] -> ChurchList a toChurchList xs = ChurchList (\kons knil -> foldr kons knil xs) -- | -- completely. cons :: a -> ChurchList a -> ChurchList a cons x xs = ChurchList (\f z -> f x (runlist xs f z)) nil :: ChurchList a nil = ChurchList (\f z -> z) foldr foldr head :: ChurchList a -> Maybe a head = foldr append :: ChurchList a -> ChurchList a -> ChurchList a append xs ys = foldr -- | Convert a fromChurchList :: ChurchList a -> [a] fromChurchList xs = runList xs (:) []
build :: (forall b. (a -> b -> b) -> b -> b) -> [a] build g = g (:) []
-- Don -- fold it right away: foldr kons knil (fromChurchList xs) ==> runChurchList xs kons knil
data List a = Cons a (List a) | Nil data Tree a = Branch (Tree a) (Tree a) | Leaf a
data ListContainer a rest = Cons a rest | Nil type List a = Fix (ListContainer a)
Roll Nil Roll (Cons 1 (Roll Nil)) Roll (Cons 1 (Roll (Cons 2 (Roll Nil))))
instance Functor (ListContainer a) where fmap f (Cons a rest) = Cons a (f rest) fmap f Nil = Nil
fold :: Functor f => (f a -> a) -> (Fix f -> a) fold h = h . fmap (fold h) . unRoll where unRoll (Roll a) = a
fold :: (ListContainer a b -> b) -> (Fix (ListContainer a) -> b)
h :: Either a b -> c h (Left a) = f a h (Right b) = g b
foldr :: (Either (a, b) () -> b) -> ([a] -> b) fold :: (Either (a, b) () -> b) -> (List a -> b)
data TreeContainer a rest = Branch rest rest | Leaf a type Tree a = Fix (TreeContainer a)
foldTree :: (b -> b -> b) -> (a -> b) -> Tree a -> b
foldTree :: (Either (b, b) a -> b) -> (Tree a -> b)
class Functor f => Algebra f a where op :: f a -> a
foldr cons nil ((:) 1 ((:) 2 [])) = cons 1 (cons 2 nil)
foldTree branch leaf (Branch (Branch (Leaf 1) (leaf 2)) (Leaf 3)) = branch (branch (leaf 1) (leaf 2)) (leaf 2)
foldr :: (a -> list -> list) -> list -> [a] -> list foldTree :: (tree -> tree -> tree) -> (a -> tree) -> Tree a -> tree
import Criterion.Measurement main = secs <$> time_ someIOFunction >>= print
import System.TimeIt timeItTPure :: (a -> ()) -> a -> IO (Double,a) timeItTPure p a = timeItT $ p a `seq` return a
instance Alternative Maybe where empty = Nothing Nothing <|> r = r l <|> _ = l
instance Alternative [] where empty = [] (<|>) = (++)
Nothing <|> Nothing == Nothing [] <|> [] == [] Just a <|> Nothing == Just a [a] <|> [] == [a] Nothing <|> Just b == Just b [] <|> [b] == [b]
average :: (Num a, Fractional b) => [a] -> b average xs = ...
averageInt :: (Integral a, Fractional b) => [a] -> b averageInt xs = fromIntegral (sum xs) / fromIntegral (length xs)
averageFrac :: (Fractional a) => [a] -> a averageFrac xs = sum xs / fromIntegral (length xs)
*Main> averageFrac [1,2,3] 2.0 *Main> let x = [1,2,3] *Main> :t x x :: [Integer] *Main> averageFrac x <interactive>:1:0: No instance for (Fractional Integer) arising from a use of `averageFrac Possible fix: add an instance declaration for (Fractional Integer) In the expression: average x In the definition of `it
import Data.List average xs = realToFrac (sum xs) / genericLength xs
Prelude> average ([1 .. 10] :: [Double]) 5.5 Prelude> average ([1 .. 10] :: [Int]) 5.5 Prelude> average ([1 .. 10] :: [Float]) 5.5 Prelude> average ([1 .. 10] :: [Data.Word.Word8]) 5.5
:set -XBangPatterns import Data.List let avg l=let (t,n) = foldl avg ([1,2,3,4]::[Int]) 2.5 avg ([1,2,3,4]::[Double]) 2.5
:m Data.List let list = [1..10] let average = div (sum list) (genericLength list) average
Prelude> :t fromIntegral fromIntegral :: (Integral a, Num b) => a -> b
Prelude> let average xs = (sum xs) / (fromIntegral (length xs)) Prelude> :t average average :: (Fractional a) => [a] -> a
Prelude> average [1,2,3,4,5] 3.0 Prelude> average [1.2,3.4,5.6,7.8,9.0] 5.4 Prelude> average [1.2,3,4.5,6,7.8,9] 5.25
-- | A file name (not a file path). newtype Filename = Filename { unFilename :: String } deriving (Show,Eq)
-- | A sanitized (safe) filename. newtype SanitizedFilename = SanitizedFilename { unSafe :: String } deriving Show -- | Unique, sanitized filename. newtype UniqueFilename = UniqueFilename { unUnique :: SanitizedFilename } deriving Show -- | An uploaded file. data File = File { file_name :: String -- ^ Uploaded file. ,file_location :: UniqueFilename -- ^ Saved location. ,file_type :: String -- ^ File type. } deriving (Show)
-- | Sanitize a filename for saving to upload directory. sanitizeFilename :: String -- ^ Arbitrary filename. -> SanitizedFilename -- ^ Sanitized filename. sanitizeFilename = SanitizedFilename . filter ok where ok c = isDigit c || isLetter c || elem c "-_."
-- | Generate a unique filename. uniqueFilename :: SanitizedFilename -- ^ Sanitized filename. -> IO UniqueFilename -- ^ Unique filename.
-- | Get the form fields for a form. formFields :: ConferenceId -> Controller [Field] formFields (unConferenceId -> cid) = getFields where ... code using cid ..
The Glorious Glasgow Haskell Compilation System, version 7.2.1
data Ord a => MyType a = ConstructorOne a = ConstructorTwo a a
data MyType a where ConstructorOne :: Ord a => a -> MyType a ConstructorTwo :: Ord a => a -> a -> MyType a
Test-Suite test-melody type: exitcode-stdio-1.0 main-is: Main.hs hs-source-dirs: test build-depends: base >=4.6 && <4.7, test-framework, test-framework-hunit, HUnit, containers == 0.5.*
import Test.HUnit import Test.Framework import Test.Framework.Providers.HUnit import Data.Monoid import Control.Monad import Utils pushTest :: Assertion pushTest = [NumLit 1] ^? push (NumLit 1) pushPopTest :: Assertion pushPopTest = [] ^? (push (NumLit 0) >> void pop) main :: IO () main = defaultMainWithOpts [testCase "push" pushTest ,testCase "push-pop" pushPopTest] mempty
-- Tests.hs import Test.QuickCheck prop_reverseReverse :: [Int] -> Bool prop_reverseReverse xs = reverse (reverse xs) == xs
$ ghci Tests.hs > import Test.QuickCheck > quickCheck prop_reverseReverse .... Passed Tests (100/100)
module SafePrelude where safeHead :: [a] -> Maybe a safeHead [] = Nothing safeHead (x:_) = Just x
module TestSafePrelude where import Test.HUnit import SafePrelude testSafeHeadForEmptyList :: Test testSafeHeadForEmptyList = TestCase $ assertEqual "Should return Nothing for empty list" Nothing (safeHead ([]::[Int])) testSafeHeadForNonEmptyList :: Test testSafeHeadForNonEmptyList = TestCase $ assertEqual "Should return (Just head) for non empty list" (Just 1) (safeHead ([1]::[Int])) main :: IO Counts main = runTestTT $ TestList [testSafeHeadForEmptyList, testSafeHeadForNonEmptyList]
import {-@ HTF_TESTS @-} ModuleA import {-@ HTF_TESTS @-} ModuleB main :: IO () main = htfMain htf_importedTests
ll ~/.ghc/ total 24 -rw-r--r-- 1 johnl johnl 2300 Aug 21 11:47 ghci_history drwxr-xr-x 3 johnl johnl 4096 Jun 17 19:09 x86_64-linux-6.12.3 drwxr-xr-x 3 johnl johnl 4096 May 17 08:17 x86_64-linux-7.2.1 drwxr-xr-x 3 johnl johnl 4096 May 16 17:34 x86_64-linux-7.4.1 drwxr-xr-x 3 johnl johnl 4096 Jun 15 08:21 x86_64-linux-7.4.2 drwxrwxr-x 3 johnl johnl 4096 Aug 15 12:37 x86_64-linux-7.6.0.20120810
rseq x y = case x of x:xs -> (x:xs) : y [] -> [] : y evalList (x:xs) = rseq x (evalList xs) evalList [] = [] instance Monad [] where return x = [x] ls >>= f = concat (evalList (map f ls))
instance Monad [] where return x = [x] ls >>= f = case ls of [] -> [] x:xs -> case f x of y:ys -> (y:ys) ++ (xs >>= f) [] -> [] ++ (xs >>= f)
data List a = List (forall b. b -> (a -> List a -> b) -> b)
data ListT m a = ListT (forall b. m b -> (a -> List a -> m b) -> m b) cons x xs = \_ f -> f x xs nil = \x _ -> x instance (Monad m) => Monad (ListT m) where return x = cons x nil ls >>= f = ls nil (\x xs -> f x >>= \g -> g (liftM (nil ++) (xs >>= f)) (\y ys -> liftM (cons y ys ++) (xs >>= f))
instance Monad (L z) where return x = Left x (Left x) >>= f = f x (Right q) >>= f = Right(merge (f (q z))) where merge :: Either a (z -> a) -> z -> a merge (Left x) _ = x merge (Right p) z = p z
merge :: Either a (m a) -> m a merge (Left x) = return @m x merge (Right p) = p
data Pause s a = Pause { runPause :: s -> (PauseResult s a, s) } data PauseResult s a = Done a | Suspend (Pause s a) instance Monad (Pause s) where return a = Pause (\s -> (Done a, s)) m >>= k = Pause $ \s -> case runPause m s of (Done a, s (Suspend m get :: Pause s s get = Pause (\s -> (Done s, s)) put :: s -> Pause s () put s = Pause (\_ -> (Done (), s)) yield :: Pause s () yield = Pause (\s -> (Suspend (return ()), s)) step :: Pause s () -> s -> (Maybe (Pause s ()), s) step m s = case runPause m s of (Done _, s (Suspend m
data Pause s a = Return a | Mutate (s -> s) (Pause s a) | Yield (Pause s a) instance Monad (Pause s) where return = Return Return a >>= k = k a Mutate f p >>= k = Mutate f (p >>= k) Yield p >>= k = Yield (p >>= k)
mutate :: (s -> s) -> Pause s () mutate f = Mutate f (return ()) yield :: Pause s () yield = Yield (return ())
step :: s -> Pause s () -> (s, Maybe (Pause s ())) step s (Mutate f k) = step (f s) k step s (Return ()) = (s, Nothing) step s (Yield k) = (s, Just k)
instance Functor f => Monad ((:^*) f) where return = Ret Ret x >>= k = k x Do ffx >>= k = Do (fmap (>>= k) ffx)
data (:>>:) s t x = s :? (t -> x) instance Functor (s :>>: t) where fmap k (s :? f) = s :? (k . f)
type Modify s = (s -> s) :>>: () type Yield = () :>>: ()
data (:+:) f g x = L (f x) | R (g x) instance (Functor f, Functor g) => Functor (f :+: g) where fmap k (L fx) = L (fmap k fx) fmap k (R gx) = R (fmap k gx)
mutate :: (s -> s) -> Pause s () mutate f = Do (L (f :? Ret)) yield :: Pause s () yield = Do (R (() :? Ret))
step :: s -> Pause s () -> (s, Maybe (Pause s ())) step s (Ret ()) = (s, Nothing) step s (Do (L (f :? k))) = step (f s) (k ()) step s (Do (R (() :? k))) = (s, Just (k ()))
{- import Control.Monad.State newtype ContinuableT m a = Continuable { runContinuable :: m (Either a (ContinuableT m a)) } instance Monad m => Monad (ContinuableT m) where return = Continuable . return . Left Continuable m >>= f = Continuable $ do v <- m case v of Left a -> runContinuable (f a) Right b -> return (Right (b >>= f)) instance MonadTrans ContinuableT where lift m = Continuable (liftM Left m) instance MonadState s m => MonadState s (ContinuableT m) where get = lift get put = lift . put yield :: Monad m => ContinuableT m a -> ContinuableT m a yield = Continuable . return . Right step :: ContinuableT (State s) a -> s -> (Either a (ContinuableT (State s) a), s) step = runState . runContinuable -- mutate unnecessary, just use modify
{- newtype Pause s x = Pause (s -> (s, Either x (Pause s x))) instance Monad (Pause s) where return x = Pause (, Left x) Pause k >>= f = Pause $ \s -> let (s case v of Left x -> step (f x) s' Right x -> (s mutate :: (s -> s) -> Pause s () mutate f = Pause (\s -> (f s, Left ())) yield :: Pause s () yield = Pause (, Right (return ())) step :: Pause s x -> s -> (s, Either x (Pause s x)) step (Pause x) = x
mutate :: State s () - Pause s () step :: Pause s () - State s (Maybe (Pause s ()))
mutate :: (Monad m) = m () -> Pause m () yield :: (Monad m) = Pause m () step :: (Monad m) = Pause m () -> m (Maybe (Pause m ()))
mutate :: (Monad m) = m a -> Pause m a yield :: (Monad m) = Pause m () step :: (Monad m) = Pause m a -> m (Either (Pause m a) a)
import Control.Monad import Control.Monad.Cont import Control.Monad.State import Control.Monad.Trans data Pause m a = Pause { step :: m (Either (Pause m a) a) }
instance MonadTrans Pause where lift k = Pause (liftM Right k)
mutate :: (Monad m) => m () -> Pause m () mutate = lift
suspend :: (Monad m) => Pause m a -> Pause m a suspend = Pause . return . Left
yield :: (Monad m) => Pause m () yield = suspend (return ())
instance (Monad m) => Monad (Pause m) where return x = lift (return x) -- Pause (return (Right x)) (Pause s) >>= f = Pause $ s >>= \x -> case x of Right y -> step (f y) Left p -> return (Left (p >>= f))
test1 :: Int -> Pause (State Int) Int test1 y = do x <- lift get lift $ put (x * 2) yield return (y + x)
debug :: Show s => s -> Pause (State s) a -> IO (s, a) debug s p = case runState (step p) s of (Left next, s (Right r, s main :: IO () main = do debug 1000 (test1 1 >>= test1 >>= test1) >>= print
-- type representing a computation data MyArr b c = MyArr (b -> (c,MyArr b c))
instance Arrow (->) b c where instance Arrow MyArr b c where
-- run a function arrow runF :: (b -> c) -> b -> c runF = id -- run a MyArr arrow, discarding the remaining computation runMyArr :: MyArr b c -> b -> c runMyArr (MyArr step) = fst . step
-- run a function arrow over multiple inputs runFList :: (b -> c) -> [b] -> [c] runFList f = map f -- run a MyArr over multiple inputs. -- Each step of the computation gives the next step to use runMyArrList :: MyArr b c -> [b] -> [c] runMyArrList _ [] = [] runMyArrList (MyArr step) (b:bs) = let (this, step in this : runMyArrList step
-- count the number of inputs received: count :: MyArr b Int count = count where count
-- combine two arrows in sequence >>> :: Arrow a => a b c -> a c d -> a b d -- the function arrow instance -- >>> :: (b -> c) -> (c -> d) -> (b -> d) -- this is just flip (.) -- MyArr instance -- >>> :: MyArr b c -> MyArr c d -> MyArr b d
-- &&& applies two arrows to a single input in parallel &&& :: Arrow a => a b c -> a b c -- function instance type -- &&& :: (b -> c) -> (b -> c -- MyArr instance type -- &&& :: MyArr b c -> MyArr b c -- first and second omitted for brevity, see the accepted answer from KennyTM -- for further details.
-- function that, given an input n, returns "n+1" and "n*2" calc1 :: Int -> (Int,Int) calc1 = (+1) &&& (*2)
data StreamTrans a b = StreamTrans (a -> (b, StreamTrans a b))
data IOArrow a b = IOArrow { runIOArrow :: a -> IO b } instance Category IOArrow where id = IOArrow return IOArrow f . IOArrow g = IOArrow $ f <=< g instance Arrow IOArrow where arr f = IOArrow $ return . f first (IOArrow f) = IOArrow $ \(a, c) -> do x <- f a return (x, c)
foo :: Int -> String foo = show bar :: String -> IO Int bar = return . read
main :: IO () main = do let f = arr (++ "!") . arr foo . IOArrow bar . arr id result <- runIOArrow f "123" putStrLn result
main :: IO () main = do let g = arr (++ "!") . arr foo . Kleisli bar . arr id result <- runKleisli g "123" putStrLn result
arrowUser :: Arrow a => a String String -> a String String arrowUser f = proc x -> do y <- f -< x returnA -< y main :: IO () main = do let h = arr (++ "!") <<< arr foo <<< Kleisli bar <<< arr id result <- runKleisli (arrowUser h) "123" putStrLn result
arrowUser arrowUser main main let h = (++ "!") . foo . unsafePerformIO . bar . id result = arrowUser putStrLn result
a::a -> [a] -> [a] a x = ([x] ++ ) main = putStrLn(show ( sum (foldr a [] [0.. 100000])))
b::[b] -> b -> [b] b xs = ( ++ xs). (\y->[y]) main = putStrLn(show ( sum (foldl b [] [0.. 100000])))
map :: (a -> b) -> [a] -> [b] map _ [] = [] map f (x:xs) = f x : map f xs
foldr f z [] = z foldr f z (x:xs) = f x (foldr f z xs)
foldl f z [] = z foldl f z (x:xs) = foldl f (f z x) xs sum = foldl (+) 0 sum [1..1000000] = foldl (+) 0 [1..1000000] = foldl (+) ((+) 0 1) [2..1000000] = foldl (+) ((+) ((+) 0 1) 2) [3..1000000] = foldl (+) ((+) ((+) ((+) 0 1) 2) 3) [4..1000000] ... = (+) ((+) ((+) (...) 999999) 1000000)
foldr (\x -> [x] ++ ) [] [0..10000] [0] ++ foldr a [] [1..10000] [0] ++ ([1] ++ foldr a [] [2..10000]) ...
b xs = ( ++xs) . (\y->[y]) foldl b [] [0..10000] foldl b ( [0] ++ [] ) [1..10000] foldl b ( [1] ++ ([0] ++ []) ) [2..10000] foldl b ( [2] ++ ([1] ++ ([0] ++ [])) ) [3..10000] ...
foldl f z [] = z foldl f z (x:xs) = foldl f (z `f` x) xs foldr f z [] = z foldr f z (x:xs) = x `f` (foldr f z xs)
foldl (+) 0 [1, 2, 3] foldl (+) (0+1) [2, 3] foldl (+) ((0+1)+2) [3] foldl (+) (((0+1)+2)+3) [ ] (((0+1)+2)+3) ((1+2)+3) (3+3) 6
foldr (+) 0 [1, 2, 3] 1 + (foldr (+) 0 [2, 3]) 1 + (2 + (foldr (+) 0 [3])) 1 + (2 + (3 + (foldr (+) 0 []))) 1 + (2 + (3 + 0))) 1 + (2 + 3) 1 + 5 6
foldr (&&) True (False:(repeat True)) foldl (&&) True (False:(repeat True))
[100000] [99999, 100000] [99998, 99999, 100000] ... [0.. 100000] -- i.e., the original list
[0] [0, 1] [0, 1, 2] ... [0, 1, ..., 99999] [0.. 100000]
a :: a -> [a] -> [a] a = (:) b :: [b] -> b -> [b] b = flip (:)
mergesort :: Ord a => [a] -> [a] mergesort [] = [] mergesort [x] = [x] mergesort l = merge (mergesort left) (mergesort right) where size = div (length l) 2 (left, right) = splitAt size l merge :: Ord a => [a] -> [a] -> [a] merge ls [] = ls merge [] vs = vs merge first@(l:ls) second@(v:vs) | l < v = l : merge ls second | otherwise = v : merge first vs quicksort :: Ord a => [a] -> [a] quicksort [] = [] quicksort [x] = [x] quicksort l = quicksort less ++ pivot:(quicksort greater) where pivotIndex = div (length l) 2 pivot = l !! pivotIndex [less, greater] = foldl addElem [[], []] $ enumerate l addElem [less, greater] (index, elem) | index == pivotIndex = [less, greater] | elem < pivot = [elem:less, greater] | otherwise = [less, elem:greater] enumerate :: [a] -> [(Int, a)] enumerate = zip [0..]
Quicksort replaced by mergesort, 14/5/2002. From: Ian Lynagh <igloo@earth.li> I am curious as to why the List.sort implementation in GHC is a quicksort algorithm rather than an algorithm that guarantees n log n time in the worst case? I have attached a mergesort implementation along with a few scripts to time it
tqsort [] = [] tqsort (x:xs) = sortp xs [] [x] [] where sortp [] us ws vs = tqsort us ++ ws ++ tqsort vs sortp (y:ys) us ws vs = case compare y x of LT -> sortp ys (y:us) ws vs GT -> sortp ys us ws (y:vs) _ -> sortp ys us (y:ws) vs
benchmarking Data.List.sort/Diverse/10^5 time 223.0 ms (217.0 ms .. 228.8 ms) 1.000 R² (1.000 R² .. 1.000 R²) mean 226.4 ms (224.5 ms .. 228.3 ms) std dev 2.591 ms (1.824 ms .. 3.354 ms) variance introduced by outliers: 14% (moderately inflated) benchmarking 3-way Quicksort/Diverse/10^5 time 91.45 ms (86.13 ms .. 98.14 ms) 0.996 R² (0.993 R² .. 0.999 R²) mean 96.65 ms (94.48 ms .. 98.91 ms) std dev 3.665 ms (2.775 ms .. 4.554 ms)
data () = () -- the left () is blue; the right () is red
main = do x <- putStrLn "Hello" case x of () -> putStrLn "The only value..."
special -> ( | ) | , | ; | [ | ] | `| { | } symbol -> ascSymbol | uniSymbol<special | _ | : | " | ascSymbol -> ! | \ | ^ | | | - | ~ uniSymbol -> any Unicode symbol or punctuation
varsym -> ( symbol {symbol | :})<reservedop | dashes> consym -> (: {symbol | :})<reservedop> reservedop -> .. | : | :: | = | \ | | | <- | -> | @ | ~ | =>
trace :: String -> a -> a trace string expr = unsafePerformIO $ do putTraceMsg string return expr
... Couldn because type variable `b This (rigid, skolem) type variable is bound by the type signature for groupBy :: Ord b => (a -> b) -> Set a -> Set (b, [a]) The following variables have types that mention k0 ...
{- data I a = I a deriving (Show) data SomeI = forall a. MkSomeI (I a)
data AnyEq = forall a. Eq a => AE a -- reflexive :: AnyEq -> Bool reflexive (AE x) = x == x
{- {- example :: String -> I a -> String example str x = withContext x s where s i = "Foo" ++ str withContext :: I a -> (forall b. I b -> c) -> c withContext x f = f x
xs = [1,2,3] ys = [4,5,6] cartProd :: [a] -> [b] -> [(a,b)] cartProd xs ys ==> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
import Control.Monad (liftM2) cartProd :: [a] -> [b] -> [(a, b)] cartProd = liftM2 (,)
> sequence [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
import Control.Applicative (,) <$> [1,2,3] <*> [4,5,6] -- [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
cartProd :: [a] -> [b] -> [(a,b)] cartProd xs [] = [] cartProd [] ys = [] cartProd (x:xs) ys = map (\y -> (x,y)) ys ++ cartProd xs ys
import Control.Applicative cartProd :: [a] -> [b] -> [(a,b)] cartProd xs ys = (,) <$> xs <*> ys
1 2 3 4 ... a a1 a2 a3 a4 ... b b1 b2 b3 b4 ... c c1 c2 c3 c4 ... d d1 d2 d3 d4 ... . . . . . . . . . . . . . . . . . .
cartesian2d :: [a] -> [b] -> [[(a, b)]] cartesian2d as bs = [[(a, b) | a <- as] | b <- bs]
diagonalBad :: [[a]] -> [a] diagonalBad xs = [ xs !! row !! col | diagonal <- [0..] , depth <- [0..diagonal] , let row = depth col = diagonal - depth ]
a1 a2 / a3 a4 ... / / b1 / b2 b3 b4 ... / / / c1 c2 c3 c4 ... --------------------------------- d1 d2 d3 d4 ... . . . . . . . . . . . . . . .
diagonal :: [[a]] -> [a] diagonal = go [] where go upper lower = [h | h:_ <- upper] ++ case lower of [] -> concat (transpose upper row:lower where upper
Data.Universe.Helpers> mapM_ print . diagonals $ cartesian2d "abcd" [1..4] [( [( [( [( [( [( [(
cartProd :: [a] -> [b] -> [(a,b)] cartProd xs ys = do x <- xs y <- ys return (x,y)
cartProd :: [a] -> [b] -> [(a, b)] cartProd xs ys = [(x, y) | x <- xs, y <- ys]
cartesian :: [[a]] -> [[a]] cartesian [] = return [] cartesian (x:xs) = x >>= \x *Main> cartesian [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
cartesian :: [[a]] -> [[a]] cartesian = mapM id *Main> cartesian [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
crossProduct :: [[a]] -> [[a]] crossProduct (axis:[]) = [ [v] | v <- axis ] crossProduct (axis:rest) = [ v:r | v <- axis, r <- crossProduct rest ]
cartProd :: [a]->[b]->[(a,b)] cartProd _ []=[] cartProd [] _ = [] cartProd (x:xs) (y:ys) = [(x,y)] ++ cartProd [x] ys ++ cartProd xs ys ++ cartProd xs [y]
(<*>) :: Parser (a -> b) -> Parser a -> Parser b (>>=) :: Parser a -> (a -> Parser b) -> Parser b
empty :: Parser a -> Bool first :: Parser a -> Set Char
empty (f <*> x) = empty f && empty x first (f <*> x) | empty f = first f `union` first x | otherwise = first f
empty (x >>= f) = empty x && empty (f ???) first (x >>= f) | empty x = first x `union` first (f ???) | otherwise = first x
instance (Monad m) => Applicative m where pure = return (<*>) = ap
instance (Applicative a) => Monad a where return = pure (>>=) = ???
permute :: [a] -> [[a]] permute = foldr (concatMap.ins) [[]] where ins x [] = [[x]] ins x (y:ys) = (x:y:ys):[ y:res | res <- ins x ys]
bash$ cat b.hs ins x [] = [[x]] ins x (y:ys) = (x:y:ys):[ y:res | res <- ins x ys] bash$ ghci Prelude> :load b.hs [1 of 1] Compiling Main ( b.hs, interpreted ) Ok, modules loaded: Main. *Main> ins 1 [2,3] [[1,2,3],[2,1,3],[2,3,1]]
*Main> let g=concatMap . ins *Main> g 1 [[2,3]] [[1,2,3],[2,1,3],[2,3,1]]
*Main> concatMap (ins 1 [[2,3]]) <interactive>:1:11: Couldn against inferred type `[[[t]]]' In the first argument of `concatMap In the expression: concatMap (ins 1 [[2, 3]]) In the definition of `it
*Main> concatMap (ins 1) [[2,3]] [[1,2,3],[2,1,3],[2,3,1]]
*Main> (concatMap . ins) 1 [[2,3]] [[1,2,3],[2,1,3],[2,3,1]]
*Main> :info ins ins :: t -> [t] -> [[t]] -- Defined at b.hs:1:0-2
let oh gosh, boom, let yep, works, that must be it, proceed)
a=[2,3] print [a[:x]+[1]+a[x:] for x in xrange(len(a)+1)] [[1, 2, 3], [2, 1, 3], [2, 3, 1]]
def dot(f, g): def result(arg): return f(g(arg)) return result
-- let lst = [x, y, z] foldr f init lst = foldr f init [x, y, z] = foldr f init (x : y : z : []) = f x (f y (f z init))
foldr (concatMap . ins) [[]] [1, 2, 3] = (concatMap . ins) 1 ((concatMap . ins) 2 ((concatMap . ins) 3 [[]]))
(concatMap . ins) 3 [[]] = (\x -> concatMap (ins x)) 3 [[]] -- definition of (.) = (concatMap (ins 3)) [[]] = concatMap (ins 3) [[]] -- parens are unnecessary = concat (map (ins 3) [[]]) -- definition of concatMap
map (ins 3) [[]] == (ins 3 []) : [] -- definition of map = [3] : [] = [[3]]
foldr (concatMap . ins) [[]] [1, 2, 3] = (concatMap . ins) 1 ((concatMap . ins) 2 ((concatMap . ins) 3 [[]])) = (concatMap . ins) 1 ((concatMap . ins) 2 [[3]]
(concatMap . ins) 2 [[3]] = (\x -> concatMap (ins x)) 2 [[3]] = (concatMap (ins 2)) [[3]] = concatMap (ins 2) [[3]] -- parens are unnecessary = concat (map (ins 2) [[3]]) -- definition of concatMap = concat (ins 2 [3] : []) = concat ([[2, 3], [3, 2]] : []) = concat [[[2, 3], [3, 2]]] = [[2, 3], [3, 2]]
foldr (concatMap . ins) [[]] [1, 2, 3] = (concatMap . ins) 1 [[2, 3], [3, 2]] = (\x -> concatMap (ins x)) 1 [[2, 3], [3, 2]] = concatMap (ins 1) [[2, 3], [3, 2]] = concat (map (ins 1) [[2, 3], [3, 2]]) = concat [ins 1 [2, 3], ins 1 [3, 2]] -- definition of map = concat [[[1, 2, 3], [2, 1, 3], [2, 3, 1]], [[1, 3, 2], [3, 1, 2], [3, 2, 1]]] -- defn of ins = [[1, 2, 3], [2, 1, 3], [2, 3, 1], [1, 3, 2], [3, 1, 2], [3, 2, 1]]
main = untilM (isCorrect 42) (read `liftM` getLine)
isCorrect num guess = case compare num guess of EQ -> putStrLn "You Win!" >> return True ...
main = untilM (isCorrect 42) (read <$> getLine) EQ -> True <$ putStrLn "You Win!"
import Control.Applicative ifte condition trueClause falseClause = do c <- condition if c then trueClause else falseClause x = ifte (return True) (putStrLn "True") (putStrLn "False") ifte if condition then trueClause else falseClause y = ifte
import Paths_xmonad (version) import Data.Version (showVersion)
case args of ["--version"] -> putStrLn ("xmonad " ++ showVersion version)
version, getBinDir, getLibDir, getDataDir, getLibexecDir, getDataFileName
public static IEnumerable Power(int number, int exponent) { int counter = 0; int result = 1; while (counter++ < exponent) { result = result * number; yield return result; } }
int f1() { return 1;} int f2() { return 2;} int lazy(int (*cb1)(), int (*cb2)() , int x) { if (x == 0) return cb1(); else return cb2(); } int eager(int e1, int e2, int x) { if (x == 0) return e1; else return e2; } lazy(f1, f2, x); eager(f1(), f2(), x);
data TwoNumbers = forall a. Num a => TwoNumbers a a f :: TwoNumbers -> TwoNumbers f (TwoNumbers x y) = TwoNumbers (x+y) (x*y) list1 = map f [TwoNumbers (42 :: Int) 7, TwoNumbers (3.14 :: Double) 9] -- ==> [TwoNumbers (49 :: Int) 294, TwoNumbers (12.14 :: Double) 28.26]
data SomeBoundedNumber = forall a. (Bounded a, Num a) => SBN a g :: SomeBoundedNumber -> SomeBoundedNumber g (SBN n) = SBN (maxBound - n) list2 = map g [SBN (42 :: Int32), SBN (42 :: Int64)] -- ==> [SBN (2147483605 :: Int32), SBN (9223372036854775765 :: Int64)]
class List<a> { class Cons : List<a> { a head; List<a> tail; } class Nil : List<a> {} }
myUpdate :: Update MyState () myUpdate = <some outdated implementation>
maybeToList :: Maybe a -> [a] maybeToList Nothing = [] maybeToList (Just x) = [x]
class Eq a where (==) :: a -> a -> Bool instance Eq Bool where False == False = True False == True = False True == False = False True == True = True instance Eq a => Eq [a] where [] == [] = True (x:xs) == (y:ys) = x == y && xs == ys _ == _ = False
maybeToList Nothing = [] maybeToList (Just x) = [x]
Prelude Data.Maybe> :t maybe maybe :: b -> (a -> b) -> Maybe a -> b Prelude Data.Maybe> maybe 7 id (Just 2) 2
Prelude Data.Maybe> :t foldr (.) id [(+2), (*7)] :: (Num a) => a -> a Prelude Data.Maybe> let f = foldr (.) id [(+2), (*7)] Prelude Data.Maybe> f 7 51
instance Monoid (a -> a) where mempty = id f `mappend` g = (f . g)
Data.HashTable> h <- new (==) id :: IO (HashTable Data.Int.Int32 Int) Data.HashTable> insert h 7 2 Data.HashTable> Data.HashTable.lookup h 7 Just 2
foo = return >>= bar >>= baz foos = [] ++ bars ++ bazs
import Control.Applicative pal :: [a] -> [a] pal = (++) <$> id <*> reverse
join (Leaf tree) = tree join (Node h t) = Node (join h) (join t)
instance Functor Tree where fmap f (Leaf x) = Leaf (f x) fmap f (Node h t) = Node (fmap f h) (fmap f t)
join = concat -- [] join f = \x -> f x x -- (e ->) join f = \s -> let (f join (Just (Just a)) = Just a; join _ = Nothing -- Maybe join (Identity (Identity a)) = Identity a -- Identity join (Right (Right a)) = Right a; join (Right (Left e)) = Left e; join (Left e) = Left e -- Either join ((a, m), m join f = \k -> f (\f
newtype Reader s x = Reader (s -> x) join (Reader f) = Reader (\ s -> let Reader g = f s in g s)
Reader f >>= g = Reader (\ s -> let x = f s in g x)
data State s x = State (s -> (s, x)) join (State f) = State (\ s0 -> let (s1, State g) = f s0 in g s1)
ma `bind` (f >=> g) = (ma `bind` f) `bind` g -- bind = (>>=) = (`bind` g) . (`bind` f) $ ma = join . fmap g . join . fmap f $ ma
((g <=< f) =<<) = (g =<<) . (f =<<) = join . (g <$>) . join . (f <$>)
> :t showIntAtBase showIntAtBase :: (Integral a) => a -> (Int -> Char) -> a -> String -> String
import Numeric (showHex, showIntAtBase) import Data.Char (intToDigit) putStrLn $ showHex 12 "" -- prints "c" putStrLn $ showIntAtBase 2 intToDigit 12 "" -- prints "1100"
showIntAtBase 2 intToDigit 10 "" => "1010" showIntAtBase 16 intToDigit 1023 "" => "3ff"
import Text.Printf main = do let i = 65535 :: Int putStrLn $ printf "The value of %d in hex is: 0x%08x" i i putStrLn $ printf "The html color code would be: putStrLn $ printf "The value of %d in binary is: %b" i i
decToBin x = reverse $ decToBin where decToBin decToBin
import Data.Char (digitToInt) import Data.Char (intToDigit) -- generic function from base to decimal toNum :: [Char] -> Int -> (Char -> Int) -> Int toNum [] base map = 0 toNum s base map = base * toNum (init(s)) base map + map(last(s)) -- generic function from decimal to base k toKBaseNum :: Int -> Int -> (Int -> Char) -> [Char] toKBaseNum x base map | x < base = [map x] | otherwise = toKBaseNum (x `div` base) base map ++ [map(x `mod` base)] -- mapping function for hex to decimal mapHexToDec :: Char -> Int mapHexToDec x | x == | x == | x == | x == | x == | x == | otherwise = digitToInt(x) :: Int -- map decimal to hex mapDecToHex :: Int -> Char mapDecToHex x | x < 10 = intToDigit(x) | x == 10 = | x == 11 = | x == 12 = | x == 13 = | x == 14 = | x == 15 = -- hex to decimal hexToDec :: String -> Int hexToDec [] = 0 hexToDec s = toNum s 16 mapHexToDec -- binary to decimal binToDec :: String -> Int binToDec [] = 0 binToDec s = toNum s 2 (\x -> if x == -- decimal to binary decToBin :: Int -> String decToBin x = toKBaseNum x 2 (\x -> if x == 1 then -- decimal to hex decToHex :: Int -> String decToHex x = toKBaseNum x 16 mapDecToHex
-- decimal to octal decToOct :: Int -> String decToOct x = toKBaseNum x 8 (\x -> intToDigit(x))
(\d -> let fix f = let {x = f x} in x in fmap (\n -> "0123456789abcdef" !! n) (fix (\f l n -> if n == 0 then l :: [Int] else let (q, r) = quotRem n 16 in f (r:l) q) [] d)) 247
{- stack script --resolver lts-12.1 -} -- file: DecToHex.hs module Main where import System.Environment fix :: (a -> a) -> a fix f = let {x = f x} in x ff :: ([Int] -> Int -> [Int]) -> [Int] -> Int -> [Int] ff = \f l n -> if n == 0 then l else let (q, r) = quotRem n 16 in f (r:l) q decToHex :: Int -> String decToHex d = fmap (\n -> "0123456789abcdef" !! n) (fix ff [] d) main :: IO () main = getArgs >>= putStrLn . show . decToHex . read . head
fempty :: (Applicative f, Monoid a) => f a fempty = pure mempty (>|<) :: (Applicative f, Monoid a) => f a -> f a -> f a (>|<) = liftA2 mappend
class Alternative empty (<||>) :: f a -> f a -> f a
instance (Monoid a, Monoid b) => Monoid (a,b) where mempty = (mempty, mempty) (a1,b1) `mappend` (a2,b2) = (a1 `mappend` a2, b1 `mappend` b2)
instance Monoid a => Applicative ((,) a) where pure x = (mempty, x) (u, f) <*> (v, x) = (u `mappend` v, f x)
instance Monoid a => Monoid (Maybe a) where mempty = Nothing Nothing `mappend` m = m m `mappend` Nothing = m Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
instance Alternative Maybe where empty = Nothing Nothing <|> r = r l <|> _ = l
f <$> (Nothing <|> b) = f <$> b by the definition of (<|>) = Nothing <|> (f <$> b) by the definition of (<|>) = (f <$> Nothing) <|> (f <$> b) by the definition of (<$>) f <$> (Just a <|> b) = f <$> Just a by the definition of (<|>) = Just (f a) by the definition of (<$>) = Just (f a) <|> (f <$> b) by the definition of (<|>) = (f <$> Just a) <|> (f <$> b) by the definition of (<$>)
class (Applicative f, forall a. Monoid (f a)) => Alternative
(<>) :: Monoid a => a -> a -> a (<>) = mappend -- I
data Perhaps a = Yes a | No deriving (Eq, Show) instance Functor Perhaps where fmap f (Yes a) = Yes (f a) fmap f No = No instance Applicative Perhaps where pure a = Yes a No <*> _ = No _ <*> No = No Yes f <*> Yes x = Yes (f x)
data Zip a = Zip [a] deriving (Eq,Show) instance Functor Zip where fmap f (Zip xs) = Zip (map f xs) instance Applicative Zip where Zip fs <*> Zip xs = Zip (zipWith id fs xs) -- zip them up, applying the fs to the xs pure a = Zip (repeat a) -- infinite so that when you zip with something, lengths don
(<++>) :: Perhaps String -> Perhaps String -> Perhaps String Yes xs <++> Yes ys = Yes (xs ++ ys) Yes xs <++> No = Yes xs No <++> Yes ys = Yes ys No <++> No = No
(<++>) :: Monoid a => Perhaps a -> Perhaps a -> Perhaps a Yes xs <++> Yes ys = Yes (xs `mappend` ys) Yes xs <++> No = Yes xs No <++> Yes ys = Yes ys No <++> No = No
instance Monoid a => Monoid (Perhaps a) where mappend = (<++>) mempty = No
Zip ["HELLO","MUM","HOW","ARE","YOU?"] <> Zip ["this", "is", "fun"] = Zip ["HELLO" ? "this", "MUM" ? "is", "HOW" ? "fun"] mempty = ["","","","",..] -- sensible zero element for zipping with ?
Zip [Just 1, Nothing, Just 3, Just 4] <> Zip [Just 40, Just 70, Nothing] = Zip [Just 1 ? Just 40, Nothing ? Just 70, Just 3 ? Nothing] mempty = [Nothing, Nothing, Nothing, .....] -- sensible zero element
instance Monoid a => Monoid (Zip a) where Zip as `mappend` Zip bs = Zip (zipWith (<>) as bs) -- zipWith the internal mappend mempty = Zip (repeat mempty) -- repeat the internal mempty
Zip [Just (Sum 1), Nothing, Just (Sum 3), Just (Sum 4)] <> Zip [Just (Sum 40), Just (Sum 70), Nothing] = Zip [Just (Sum 41),Just (Sum 70), Just (Sum 3)] Zip [Product 5,Product 10,Product 15] <> Zip [Product 3, Product 4] = Zip [Product 15,Product 40]
(<||>) :: Perhaps String -> Perhaps String -> Perhaps String Yes xs <||> Yes ys = Yes xs -- if we can have both, choose the left one Yes xs <||> No = Yes xs No <||> Yes ys = Yes ys No <||> No = No
(<||>) :: Perhaps a -> Perhaps a -> Perhaps a Yes xs <||> Yes ys = Yes xs -- if we can have both, choose the left one Yes xs <||> No = Yes xs No <||> Yes ys = Yes ys No <||> No = No
instance Alternative Perhaps where (<|>) = (<||>) empty = No
Zip [] <|> Zip ys = Zip ys Zip xs <|> Zip [] = Zip xs
instance Alternative Zip where empty = Zip [] Zip [] <|> x = x Zip xs <|> _ = Zip xs
sum = foldr (+) 0 concat = foldr (++) [] msum = foldr (`mappend`) mempty -- any Monoid whichEverWorksFirst = foldr (<|>) empty -- any Alternative
import Text.Parsec import Text.Parsec.String import Control.Applicative ((<$>),(<*>),liftA2,empty) import Data.Monoid import Data.Char
data Type = Literal String | Variable String deriving Show examples = [Literal "Int",Variable "a"]
literal :: Parser Type literal = fmap Literal $ (:) <$> upper <*> many alphaNum
variable :: Parser Type variable = fmap Variable $ (:) <$> lower <*> many alphaNum
No instance for (Monoid Type) arising from a use of `mappend' Possible fix: add an instance declaration for (Monoid Type) In the first argument of `liftA2 In the expression: liftA2 mappend literal variable In an equation for `litvar litvar = liftA2 mappend literal variable
instance Monoid (Parser a) where mempty = empty mappend = (<|>)
Illegal instance declaration for `Monoid (Parser a)' (All instance types must be of the form (T t1 ... tn) where T is not a synonym. Use -XTypeSynonymInstances if you want to disable this.) In the instance declaration for `Monoid (Parser a)'
data MyMaybe a = MyJust a | MyNothing deriving Show instance Monoid (MyMaybe Int) where mempty = MyNothing mappend MyNothing x = x mappend x MyNothing = x mappend (MyJust a) (MyJust b) = MyJust (a + b)
data Seq a = End a | Cons a (Seq a) deriving (Show, Eq, Ord)
empyGraph :: Graph mkLabel :: Label -> Graph mkAssignment :: Assignment -> Graph -- modify a register or memory mkTransfer :: ControlTransfer -> Graph -- any control transfer (<*>) :: Graph -> Graph -> Graph
withFreshLabel :: (Label -> Graph) -> Graph mkIfThenElse :: (Label -> Label -> Graph) -- branch condition -> Graph -- code in the -> Graph -- code in the -> Graph -- resulting if-then-else construct
type Graph = RealGraph -> [Label] -> (RealGraph, [Label])
type Graph = RealGraph -> State [Label] RealGraph -- a Graph is a monadic function from a successor RealGraph to a new RealGraph
data AbstractSyntax = Literal Int | Block AbstractSyntax | Comment String AbstractSyntax compile :: AbstractSyntax -> [Label] -> (Code, Comments) compile (Literal x) _ = (generateCode x, []) compile (Block ast) (l:ls) = let (code in (labelCode l code compile (Comment s ast) ls = let (code, comments in (code, s : comments generateCode :: Int -> Code labelCode :: Label -> Code -> Code
Name: myprogram Version: 0.1 -- blah blah blah Cabal-version: >=1.9.2 Executable myprogram HS-source-dirs: src Main-is: Main.hs Build-depends: attoparsec == 0.10.*, base == 4.3.*, -- long long list of packages Test-Suite test HS-source-dirs: test, src Type: exitcode-stdio-1.0 Main-is: Main.hs Build-depends: attoparsec == 0.10.*, base == 4.3.*, -- long long list of packages QuickCheck == 2.4.*
cabal-version: 2.2 name: myprogram version: 0.1 -- blah blah blah common deps build-depends: base ^>= 4.11, -- long long list of packages ghc-options: -Wall library import: deps exposed-modules: Foo test-suite tests import: deps type: exitcode-stdio-1.0 main-is: Tests.hs build-depends: foo
name: my-program version: ... library hs-source-dirs: src-lib build-depends: base, containers, ... exposed-modules: My.Program.Main, ... executable my-program hs-source-dirs: src-exec main-is: my-program.hs Build-depends: base, my-program test-suite tests type: exitcode-stdio-1.0 hs-source-dirs: src-test main-is: tests.hs other-modules: ... build-depends: base, my-program, test-framework, ...
name: myprogram version: 0.1 -- blah blah blah cabal-version: >=1.9.2 library build-depends: attoparsec == 0.10.* , base == 4.3.* -- long long list of packages executable myprogram hs-source-dirs: src main-is: Main.hs test-suite test hs-source-dirs: test, src type: exitcode-stdio-1.0 main-is: Main.hs build-depends: QuickCheck == 2.4.*
f = do a <- Just 1 b <- Just $ Just 2 -- ^ The above line does not utilize an `a` variable, so it can be safely -- executed in parallel with the preceding line c <- b -- ^ The above line references a `b` variable, so it can only be executed -- sequentially after it return (a, c) -- On the exit from a monad scope we wait for all computations to finish and -- gather the results
do | +---------+---------+ | | a <- Just 1 b <- Just $ Just 2 | | | c <- b | | +---------+---------+ | return (a, c)
x :: Maybe ([Int], [Int]) x = Just undefined y :: Maybe ([Int], [Int]) y = Just (undefined, undefined) z :: Maybe ([Int], [Int]) z = Just ([0], [1..]) a :: Maybe ([Int], [Int]) a = undefined b :: Maybe ([Int], [Int]) b = Just ([0], map fib [0..]) where fib 0 = 1 fib 1 = 1 fib n = fib (n - 1) + fib (n - 2)
main1 x = case x of Just _ -> putStrLn "Just" Nothing -> putStrLn "Nothing"
main2 x = case x of Just (_, _) -> putStrLn "Just" Nothing -> putStrLn "Nothing"
main3 x = case x of Just (a, b) -> print a >> print b Nothing -> putStrLn "Nothing"
main = maybe (return ()) (print . take 5 . snd) b -- Prints first 5 Fibbonacci numbers
{- {- {- {- data Nat = Z | S Nat data U (n :: Nat) x where Point :: x -> U Z x Dimension :: [U n x] -> U n x -> [U n x] -> U (S n) x dmap :: (U n x -> U m r) -> U (S n) x -> U (S m) r dmap f (Dimension ls mid rs) = Dimension (map f ls) (f mid) (map f rs) instance Functor (U n) where fmap f (Point x) = Point (f x) fmap f d@Dimension{} = dmap (fmap f) d
class Functor w => Comonad w where (=>>) :: w a -> (w a -> b) -> w b coreturn :: w a -> a cojoin :: w a -> w (w a) x =>> f = fmap f (cojoin x) cojoin xx = xx =>> id instance Comonad (U n) where coreturn (Point x) = x coreturn (Dimension _ mid _) = coreturn mid -- cojoin :: U Z x -> U Z (U Z x) cojoin (Point x) = Point (Point x) -- cojoin ::U (S n) x -> U (S n) (U (S n) x) cojoin d@Dimension{} = undefined -- =>> :: U Z x -> (U Z x -> r) -> U Z r p@Point{} =>> f = Point (f p) -- =>> :: U (S n) x -> (U (S n) x -> r) -> U (S n) r d@Dimension{} =>> f = undefined
data Bwd x = B0 | Bwd x :< x deriving (Functor, Foldable, Traversable, Show) data Fwd x = F0 | x :> Fwd x deriving (Functor, Foldable, Traversable, Show) infixl 5 :< infixr 5 :> data Cursor x = Cur (Bwd x) x (Fwd x) deriving (Functor, Foldable, Traversable, Show)
class Functor f => Comonad f where counit :: f x -> x cojoin :: f x -> f (f x)
instance Comonad Cursor where counit (Cur _ x _) = x cojoin c = Cur (lefts c) c (rights c) where lefts (Cur B0 _ _) = B0 lefts (Cur (xz :< x) y ys) = lefts c :< c where c = Cur xz x (y :> ys) rights (Cur _ _ F0) = F0 rights (Cur xz x (y :> ys)) = c :> rights c where c = Cur (xz :< x) y ys
> cojoin (Cur (B0 :< 1) 2 (3 :> 4 :> F0)) Cur (B0 :< Cur B0 1 (2 :> 3 :> 4 :> F0)) (Cur (B0 :< 1) 2 (3 :> 4 :> F0)) ( Cur (B0 :< 1 :< 2) 3 (4 :> F0) :> Cur (B0 :< 1 :< 2 :< 3) 4 F0 :> F0)
newtype (:.:) f g x = C {unC :: f (g x)} deriving Show
f (g x) -(fmap cojoin)-> f (g (g x)) -cojoin-> f (f (g (g x))) -(fmap transpose)-> f (g (f (g x)))
counit . transpose = fmap counit cojoin . transpose = fmap transpose . transpose . fmap cojoin
instance Applicative Bwd where pure x = pure x :< x (fz :< f) <*> (sz :< s) = (fz <*> sz) :< f s _ <*> _ = B0 instance Applicative Fwd where pure x = x :> pure x (f :> fs) <*> (s :> ss) = f s :> (fs <*> ss) _ <*> _ = F0 instance Applicative Cursor where pure x = Cur (pure x) x (pure x) Cur fz f fs <*> Cur sz s ss = Cur (fz <*> sz) (f s) (fs <*> ss)
> regularMatrixCursor Cur (B0 :< Cur (B0 :< 1) 2 (3 :> F0)) (Cur (B0 :< 4) 5 (6 :> F0)) (Cur (B0 :< 7) 8 (9 :> F0) :> F0) > sequenceA regularMatrixCursor Cur (B0 :< Cur (B0 :< 1) 4 (7 :> F0)) (Cur (B0 :< 2) 5 (8 :> F0)) (Cur (B0 :< 3) 6 (9 :> F0) :> F0)
> raggedyMatrixCursor Cur (B0 :< Cur ((B0 :< 1) :< 2) 3 F0) (Cur (B0 :< 4) 5 (6 :> F0)) (Cur (B0 :< 7) 8 (9 :> F0) :> F0) > sequenceA raggedyMatrixCursor Cur (B0 :< Cur (B0 :< 2) 4 (7 :> F0)) (Cur (B0 :< 3) 5 (8 :> F0)) F0
instance (Comonad f, Traversable f, Comonad g, Applicative g) => Comonad (f :.: g) where counit = counit . counit . unC cojoin = C . fmap (fmap C . sequenceA) . cojoin . fmap cojoin . unC
instance (Functor f, Functor g) => Functor (f :.: g) where fmap h (C fgx) = C (fmap (fmap h) fgx) instance (Applicative f, Applicative g) => Applicative (f :.: g) where pure = C . pure . pure C f <*> C s = C (pure (<*>) <*> f <*> s) instance (Functor f, Foldable f, Foldable g) => Foldable (f :.: g) where fold = fold . fmap fold . unC instance (Traversable f, Traversable g) => Traversable (f :.: g) where traverse h (C fgx) = C <$> traverse (traverse h) fgx
> cojoin (C regularMatrixCursor) C {unC = Cur (B0 :< Cur (B0 :< C {unC = Cur B0 (Cur B0 1 (2 :> (3 :> F0))) (Cur B0 4 (5 :> (6 :> F0)) :> (Cur B0 7 (8 :> (9 :> F0)) :> F0))}) (C {unC = Cur B0 (Cur (B0 :< 1) 2 (3 :> F0)) (Cur (B0 :< 4) 5 (6 :> F0) :> (Cur (B0 :< 7) 8 (9 :> F0) :> F0))}) (C {unC = Cur B0 (Cur ((B0 :< 1) :< 2) 3 F0) (Cur ((B0 :< 4) :< 5) 6 F0 :> (Cur ((B0 :< 7) :< 8) 9 F0 :> F0))} :> F0)) (Cur (B0 :< C {unC = Cur (B0 :< Cur B0 1 (2 :> (3 :> F0))) (Cur B0 4 (5 :> (6 :> F0))) (Cur B0 7 (8 :> (9 :> F0)) :> F0)}) (C {unC = Cur (B0 :< Cur (B0 :< 1) 2 (3 :> F0)) (Cur (B0 :< 4) 5 (6 :> F0)) (Cur (B0 :< 7) 8 (9 :> F0) :> F0)}) (C {unC = Cur (B0 :< Cur ((B0 :< 1) :< 2) 3 F0) (Cur ((B0 :< 4) :< 5) 6 F0) (Cur ((B0 :< 7) :< 8) 9 F0 :> F0)} :> F0)) (Cur (B0 :< C {unC = Cur ((B0 :< Cur B0 1 (2 :> (3 :> F0))) :< Cur B0 4 (5 :> (6 :> F0))) (Cur B0 7 (8 :> (9 :> F0))) F0}) (C {unC = Cur ((B0 :< Cur (B0 :< 1) 2 (3 :> F0)) :< Cur (B0 :< 4) 5 (6 :> F0)) (Cur (B0 :< 7) 8 (9 :> F0)) F0}) (C {unC = Cur ((B0 :< Cur ((B0 :< 1) :< 2) 3 F0) :< Cur ((B0 :< 4) :< 5) 6 F0) (Cur ((B0 :< 7) :< 8) 9 F0) F0} :> F0) :> F0)}
InContext (f :><: g) ~= InContext f :><: InContext g
class Applicative f => Naperian f where type Log f project :: f x -> Log f -> x positions :: f (Log f) --- project positions = id
newtype Id x = Id {unId :: x} deriving Show instance Naperian Id where type Log Id = () project (Id x) () = x positions = Id () newtype (:*:) f g x = Pr (f x, g x) deriving Show instance (Naperian f, Naperian g) => Naperian (f :*: g) where type Log (f :*: g) = Either (Log f) (Log g) project (Pr (fx, gx)) (Left p) = project fx p project (Pr (fx, gx)) (Right p) = project gx p positions = Pr (fmap Left positions, fmap Right positions)
instance (Naperian f, Naperian g) => Naperian (f :.: g) where type Log (f :.: g) = (Log f, Log g) project (C fgx) (p, q) = project (project fgx p) q positions = C $ fmap (\ p -> fmap (p ,) positions) positions
data Focused f x = f x :@ Log f instance Functor f => Functor (Focused f) where fmap h (fx :@ p) = fmap h fx :@ p instance Naperian f => Comonad (Focused f) where counit (fx :@ p) = project fx p cojoin (fx :@ p) = fmap (fx :@) positions :@ p
{- {- {- {- {- import Data.List (genericIndex) import Data.Monoid import Data.Key import Data.Functor.Representable data Nat = Z | S Nat data U (n :: Nat) x where Point :: x -> U Z x Dimension :: [U n x] -> U n x -> [U n x] -> U (S n) x dmap :: (U n x -> U m r) -> U (S n) x -> U (S m) r dmap f (Dimension ls mid rs) = Dimension (map f ls) (f mid) (map f rs) instance Functor (U n) where fmap f (Point x) = Point (f x) fmap f d@Dimension{} = dmap (fmap f) d class Functor w => Comonad w where (=>>) :: w a -> (w a -> b) -> w b coreturn :: w a -> a cojoin :: w a -> w (w a) x =>> f = fmap f (cojoin x) cojoin xx = xx =>> id
type instance Key (U n) = UKey n data UKey (n :: Nat) where P :: UKey Z D :: Integer -> UKey n -> UKey (S n) instance Lookup (U n) where lookup = lookupDefault instance Indexable (U n) where index (Point x) P = x index (Dimension ls mid rs) (D i k) | i < 0 = index (ls `genericIndex` (-i - 1)) k | i > 0 = index (rs `genericIndex` ( i - 1)) k | otherwise = index mid k
instance Representable (U Z) where tabulate f = Point (f P) instance Representable (U n) => Representable (U (S n)) where tabulate f = Dimension (map (\i -> tabulate (f . D (-i))) [1..]) (tabulate (f . D 0)) (map (\i -> tabulate (f . D i)) [1..]) instance Monoid (UKey Z) where mempty = P mappend P P = P instance Monoid (UKey n) => Monoid (UKey (S n)) where mempty = D 0 mempty mappend (D il kl) (D ir kr) = D (il + ir) (mappend kl kr)
instance (Monoid (UKey n), Representable (U n)) => Comonad (U n) where coreturn = extractRep cojoin = duplicateRep (=>>) = flip extendRep
testVal :: U (S (S Z)) Int testVal = Dimension (repeat (Dimension (repeat (Point 1)) (Point 2) (repeat (Point 3)))) (Dimension (repeat (Point 4)) (Point 5) (repeat (Point 6))) (repeat (Dimension (repeat (Point 7)) (Point 8) (repeat (Point 9)))) -- Hacky Eq instance, just for testing instance Eq x => Eq (U n x) where Point a == Point b = a == b Dimension la a ra == Dimension lb b rb = take 3 la == take 3 lb && a == b && take 3 ra == take 3 rb instance Show x => Show (U n x) where show (Point x) = "(Point " ++ show x ++ ")" show (Dimension l a r) = "(Dimension " ++ show (take 2 l) ++ " " ++ show a ++ " " ++ show (take 2 r) ++ ")" test = coreturn (cojoin testVal) == testVal && fmap coreturn (cojoin testVal) == testVal && cojoin (cojoin testVal) == fmap cojoin (cojoin testVal)
{- {- {- {- data Nat = Z | S Nat data U (n :: Nat) x where Point :: x -> U Z x Dimension :: [U n x] -> U n x -> [U n x] -> U (S n) x unPoint :: U Z x -> x unPoint (Point x) = x dmap :: (U n x -> U m r) -> U (S n) x -> U (S m) r dmap f (Dimension ls mid rs) = Dimension (map f ls) (f mid) (map f rs) right, left :: U (S n) x -> U (S n) x right (Dimension a b (c:cs)) = Dimension (b:a) c cs left (Dimension (a:as) b c) = Dimension as a (b:c) instance Functor (U n) where fmap f (Point x) = Point (f x) fmap f d@Dimension{} = dmap (fmap f) d class Functor w => Comonad w where (=>>) :: w a -> (w a -> b) -> w b coreturn :: w a -> a cojoin :: w a -> w (w a) x =>> f = fmap f (cojoin x) cojoin xx = xx =>> id instance Comonad (U n) where coreturn (Point x) = x coreturn (Dimension _ mid _) = coreturn mid cojoin (Point x) = Point (Point x) cojoin d@Dimension{} = fmap unlayer . unlayer . fmap dist . cojoin1 . fmap cojoin . layer $ d dist :: U (S Z) (U n x) -> U n (U (S Z) x) dist = layerUnder . unlayer layerUnder :: U (S n) x -> U n (U (S Z) x) layerUnder d@(Dimension _ Point{} _) = Point d layerUnder d@(Dimension _ Dimension{} _) = dmap layerUnder d unlayer :: U (S Z) (U n x) -> U (S n) x unlayer = dmap unPoint layer :: U (S n) x -> U (S Z) (U n x) layer = dmap Point cojoin1 :: U (S Z) x -> U (S Z) (U (S Z) x) cojoin1 a = layer $ Dimension (tail $ iterate left a) a (tail $ iterate right a)
Prelude> foldr (-) 54 [10, 11] 53 Prelude> foldr (\x y -> (x+y)/2) 54 [12, 4, 10, 6] 12.0
Starting accumulator = 54 11 - 54 = -43 10 - (-43) = 53 ^ Result from the previous line ^ Next list item
Starting accumulator = 54 (6 + 54) / 2 = 30 (10 + 30) / 2 = 20 (4 + 20) / 2 = 12 (12 + 12) / 2 = 12
sum [1,2,3] = foldr (+) 0 [1,2,3] [1,2,3] === 1:(2:(3:[]))
foodChain = (human : (shark : (fish : (algae : [])))) foldl step [] foodChain where step eater food = eater `eats` food -- note that "eater" is the accumulator and "food" is the element foldl `eats` [] (human : (shark : (fish : (algae : [])))) == foldl eats (human `eats` shark) (fish : (algae : [])) == foldl eats ((human `eats` shark) `eats` fish) (algae : []) == foldl eats (((human `eats` shark) `eats` fish) `eats` algae) [] == (((human `eats` shark) `eats` fish) `eats` algae)
foldr step [] foodChain where step food eater = eater `eats` food. -- note that "eater" is the element and "food" is the accumulator foldr `eats` [] (human : (shark : (fish : (algae : [])))) == foldr eats (human `eats` shark) (fish : (algae : [])))) == foldr eats (human `eats` (shark `eats` (fish)) (algae : []) == foldr eats (human `eats` (shark `eats` (fish `eats` algae))) [] == (human `eats` (shark `eats` (fish `eats` algae)
-- if the list is empty, the result is the initial value z foldr f z [] = z -- if not, apply f to the first element and the result of folding the rest foldr f z (x:xs) = f x (foldr f z xs)
myMap f [] = [] myMap f (x:xs) = f x : myMap f xs myFoldL f i [] = i myFoldL f i (x:xs) = myFoldL f (f i x) xs > tail [1,2,3,4] ==> [2,3,4] > last [1,2,3,4] ==> 4 > head [1,2,3,4] ==> 1 > init [1,2,3,4] ==> [1,2,3] -- where f is a function, -- acc is an accumulator which is given initially -- l is a list. -- myFoldR myFoldR myFoldR f z [] = z myFoldR f z (x:xs) = f x (myFoldR f z xs) > map (\x -> x/2) [12,4,10,6] ==> [6.0,2.0,5.0,3.0] > myMap (\x -> x/2) [12,4,10,6] ==> [6.0,2.0,5.0,3.0] > foldl (\x y -> (x+y)/2) 54 [12, 4, 10, 6] ==> 10.125 > myFoldL (\x y -> (x+y)/2) 54 [12, 4, 10, 6] ==> 10.125 foldl from above: Starting accumulator = 54 (12 + 54) / 2 = 33 (4 + 33) / 2 = 18.5 (10 + 18.5) / 2 = 14.25 (6 + 14.25) / 2 = 10.125` > foldr (++) "5" ["1", "2", "3", "4"] ==> "12345" > foldl (++) "5" ["1", "2", "3", "4"] ==> “51234" > foldr (\x y -> (x+y)/2) 54 [12,4,10,6] ==> 12 > myFoldR > myFoldR (\x y -> (x+y)/2) 54 [12,4,10,6] ==> 12 foldr from above: Starting accumulator = 54 (6 + 54) / 2 = 30 (10 + 30) / 2 = 20 (4 + 20) / 2 = 12 (12 + 12) / 2 = 12
{- import Data.List(sortBy) plus = (+) plus sort = sortBy compare main = do print $ plus print $ plus 1.0 2.0 print $ sort [3, 1, 2]
main = do print $ plus print $ plus (1 :: Int) 2 print $ sort [3, 1, 2]
main = do print $ plus print $ plus (1 :: Int) 2 print $ plus 1.0 2.0 print $ sort [3, 1, 2]
main = do print $ plus print $ plus 1.0 2.0 print $ sort [3, 1, 2] print $ sort "cba"
{- module TestMono where import Data.List(sortBy) plus = (+) plus sort = sortBy compare
plus :: Num a => a -> a -> a plus = (+) -- Okay! -- Runs as: Prelude> plus 1.0 1 2.0
Prelude> :t plus plus :: Integer -> Integer -> Integer
f1 x = show x f2 = \x -> show x f3 :: (Show a) => a -> String f3 = \x -> show x f4 = show f5 :: (Show a) => a -> String f5 = show
plus = (+) x :: Integer x = plus 1 2 y :: Double y = plus 1.0 2
let len :: Num a => a len = genericLength xs in (len, len)
show :: Show a => a -> String read :: Read a => String -> a
plus = (+) minus = (-) x = plus 1.0 1 y = minus 2 1
plus :: Fractional a => a -> a -> a minus :: Num a => a -> a -> a
plus :: Double -> Double -> Double minus :: Integer -> Integer -> Integer
-- using only prefix notation and n+k-patterns (no longer allowed in Haskell 2010) factorial 0 = 1 factorial (n+1) = (*) (n+1) (factorial n)
$ ghci GHCi, version 6.12.3: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Loading package ffi-1.0 ... linking ... done. Prelude> let f 0 = 0 ; f (n+5) = n Prelude> :t f f :: (Integral t) => t -> t Prelude> f 0 0 Prelude> f 1 *** Exception: <interactive>:1:4-24: Non-exhaustive patterns in function f Prelude> f 2 *** Exception: <interactive>:1:4-24: Non-exhaustive patterns in function f Prelude> f 3 *** Exception: <interactive>:1:4-24: Non-exhaustive patterns in function f Prelude> f 4 *** Exception: <interactive>:1:4-24: Non-exhaustive patterns in function f Prelude> f 5 0 Prelude> f 6 1
$ ghci GHCi, version 6.12.3: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Loading package ffi-1.0 ... linking ... done. Prelude> let f 0 = 0 ; f n | n >= 5 = n - 5 Prelude> :t f f :: (Num t, Ord t) => t -> t Prelude> f 0 0 Prelude> f 1 *** Exception: <interactive>:1:4-33: Non-exhaustive patterns in function f Prelude> f 2 *** Exception: <interactive>:1:4-33: Non-exhaustive patterns in function f Prelude> f 3 *** Exception: <interactive>:1:4-33: Non-exhaustive patterns in function f Prelude> f 4 *** Exception: <interactive>:1:4-33: Non-exhaustive patterns in function f Prelude> f 5 0 Prelude> f 6 1
Prelude> let f 0 = 0 ; f n | n >= 5 = n Prelude> :t f f :: (Num t, Ord t) => t -> t Prelude> f 0 0 Prelude> f 5 0 Prelude> f 6 1
Prelude> let f 0 = 0 ; f n | n >= 5 = let n Prelude> :t f f :: (Num t, Ord t) => t -> t Prelude> f 0 0 Prelude> f 5 0
data SkewHeap a = Empty | SkewNode a (SkewHeap a) (SkewHeap a) deriving (Show) (+++) :: Ord a => SkewHeap a -> SkewHeap a -> SkewHeap a heap1@(SkewNode x1 l1 r1) +++ heap2@(SkewNode x2 l2 r2) | x1 <= x2 = SkewNode x1 (heap2 +++ r1) l1 | otherwise = SkewNode x2 (heap1 +++ r2) l2 Empty +++ heap = heap heap +++ Empty = heap extractMin Empty = Nothing extractMin (SkewNode x l r ) = Just (x , l +++ r )
test = foldl (\acc x->acc +++ x) Empty nodes where nodes = map (\x-> SkewNode x Empty Empty) [3,5,1,9,7,2]
mainLoop :: [Monkey] -> [Elephant] -> [Bear] -> String mainLoop monkeys elephants bears = let monkeys elephants bears in if shouldExit monkeys elephants bears then "Done" else mainLoop monkeys
mainLoop :: GameState -> String mainLoop gs0 = let gs1 = updateMonkeys gs0 gs2 = updateElephants gs1 gs3 = updateBears gs2 in if shouldExit gs0 then "Done" else mainLoop gs3
stomp :: Elephant -> Monkey -> (Elephant, Monkey) stomp elephant monkey = (elongateEvilGrin elephant, decrementHealth monkey)
pure 15 :: Wire a Integer -- or even: 15 :: Wire a Integer
stats . keyDown Spacebar <|> "stats currently disabled"
mapTuple :: (a -> b) -> (a, a) -> (b, b) mapTuple f (a1, a2) = (f a1, f a2)
import Control.Monad (join) import Control.Arrow ((***)) mapTuple = join (***)
Prelude Control.Arrow> let f = (*2) *** (*2) Prelude Control.Arrow> f (1,2) (2,4) Prelude Control.Arrow> let f Prelude Control.Arrow> f (2,2) (4,4) Prelude Control.Arrow> f (4,6)
import Control.Monad (join) import Data.Bifunctor (bimap) join bimap (2*) (1,2)
import Data.Data import Data.Generics.Aliases double :: Int -> Int double = (*2) tuple :: (Int, Int, Int, Int) tuple = gmapT (mkT double) (1,2,3,4)
mapPair :: (a -> b) -> (a, a) -> (b, b) -- this is the inferred type mapPair f = uncurry ((,) `on` f)
import Control.Applicative mapTuple :: (a -> a mapTuple f g = (,) <$> f . fst <*> g . snd
import Control.Arrow (+2) . fst &&& (+2) . snd $ (2, 3)
Apply a single function to both components of a pair. > both succ (1,2) == (2,3) both :: (a -> b) -> (a, a) -> (b, b)
descend (\x -> 2*x) (1,2) == (2,4) descend (\x -> 2*x) (1,"test",Just 2) == (2,"test",Just 4) descend (\x -> 2*x) (1,2,3,4,5) == (2,4,6,8,10) descend (\x -> 2*x) [1,2,3,4,5] == [2,4,6,8,10]
mylib/ mylib.cabal src/ tests/ mylib-commandline/ mylib-server/
mylib/ mylib.cabal src/ Web/ Mylib.hs Mylib/ ModuleA ModuleB tests/ ... mylib-commandline/ Main.hs Web/ Mylib/ Commandline/ Main.hs Arguments.hs mylib-server/ Server.hs Web/ Mylib/ Server/ Main.hs Arguments.hs
module Main where import qualified Web.Mylib.Server.Main as MylibServer main :: IO () main = MylibServer.main
library hs-source-dirs: src exposed-modules: Web.Mylib Web.Mylib.ModuleA Web.Mylib.ModuleB build-depends: base >= 4 && <= 5 , [other dependencies of the library] executable mylib-commandline hs-source-dirs: mylib-commandline main-is: Main.hs other-modules: Web.Mylib.Commandline.Main Web.Mylib.Commandline.Arguments build-depends: base >= 4 && <= 5 , mylib , [other depencencies for the CLI] executable mylib-server hs-source-dirs: mylib-server main-is: Server.hs other-modules: Web.Mylib.Server.Main build-depends: base >= 4 && <= 5 , mylib , warp >= X.X , [other dependencies for the server]
runhaskell -isrc:mylib-commandline mylib-commandline/Main.hs runhaskell -isrc:mylib-server mylib-server/Server.hs
module Main where import C:\Haskell\time.hs main = do putStrLn "Starting..." time $ print answer putStrLn "Done."
module time where Import <necessary modules> time a = do start <- getCPUTime v <- a end <- getCPUTime let diff = (fromIntegral (end - start)) / (10^12) printf "Computation time: %0.3f sec\n" (diff :: Double) return v
f (map g [False, True]) = f [undefined, True] = [undefined]
0: id = id 1: fmap = map 3: fmap fmap fmap = (map . map) 8: fmap fmap fmap fmap fmap fmap fmap fmap = (map . map . map)
fmap^(4k+1) = fmap^(4k) fmap fmap :: (x -> y) -> F4 x -> F4 y
fmap^(4k+1) :: F1 F2 F3 (x -> y) -> F1 F2 F3 (F4 x -> F4 y)
fmap^(4k+2) :: F1 F2 F3 (F4 x -> F4 y) = (a -> (x -> y)) -> F3 a -> F3 (F4 x -> F4 y)
fmap^(4k+3) :: F3 a -> F3 (F4 x -> F4 y) = F3 (m -> n) -> F3 (F4 F6 m -> F4 F6 n)
fmap^(4k+4) :: F3 (F4 F6 m -> F4 F6 n) = (a -> b) -> (F4 F6 F7 a -> F4 F6 F7 b)
arrayLoop :: (Phi a, IsType b, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> Value (Ptr b) -> a -> (Value (Ptr b) -> a -> CodeGenFunction r a) -> CodeGenFunction r a arrayLoop len ptr start loopBody = do
mList :: CodeGenModule (Function (StablePtr (IORef [Word32]) -> Word32 -> Ptr Word32 -> IO Int32)) mList = createFunction ExternalLinkage $ \ ref size ptr -> do next <- staticFunction nelem let _ = next :: Function (StablePtr (IORef [Word32]) -> IO Word32) s <- arrayLoop size ptr (valueOf 0) $ \ ptri y -> do flip store ptri =<< call next ref return y ret (s :: Value Int32)
{- module Flatten where class Flatten i o where flatten :: [i] -> [o] instance Flatten a a where flatten = id instance Flatten i o => Flatten [i] o where flatten = concatMap flatten
*Flatten> let g = [1..5] *Flatten> flatten g :: [Integer] [1,2,3,4,5] *Flatten> let h = [[1,2,3],[4,5]] *Flatten> flatten h :: [Integer] [1,2,3,4,5] *Flatten> let i = [[[1,2],[3]],[],[[4,5],[6]]] *Flatten> :t i i :: [[[Integer]]] *Flatten> flatten i :: [Integer] [1,2,3,4,5,6]
*Flatten> :t sum sum :: Num a => [a] -> a *Flatten> sum $ flatten g <interactive>:1:7: No instance for (Flatten Integer a0) arising from a use of `flatten' Possible fix: add an instance declaration for (Flatten Integer a0) In the second argument of `($) In the expression: sum $ flatten g In an equation for `it *Flatten> let sumInt = sum :: [Integer] -> Integer *Flatten> sumInt $ flatten g 15 *Flatten> sumInt $ flatten h 15
concat :: [[a]] -> [a] concat xss = foldr (++) [] xss
Prelude> (concat . concat) [[[1,2],[3]],[[4]]] [1,2,3,4]
Prelude Control.Monad> join [[1, 2], [3, 4]] [1,2,3,4] Prelude Control.Monad> join (Just (Just 3)) Just 3 Prelude Control.Monad.Reader> join (+) 21 42
flatten xsss = do xss <- xsss xs <- xss x <- xs return x
import Data.List let flatten = intercalate [] flatten $ flatten [[[1,2],[3]],[[4]]] [1,2,3,4]
class Functor f where fmap :: (a -> b) -> f a -> f b
public interface HasSize { public int size(); public boolean isEmpty(); }
--Haskell class HasSize a where size :: a -> Int isEmpty :: a -> Bool isEmpty x = size x == 0
check :: [a] -> String check [] = "Empty" check (x:xs) = "Contains Elements"
check_ :: [a] -> String check_ lst | length lst < 1 = "Empty" | otherwise = "Contains elements"
infixr 0 <| {- (<|) :: (a -> b) -> a -> b f <| x = f x foo :: a -> (forall b. b -> b) -> a foo x f = f x
ghci> foo 3 <| id Couldn with actual type `a0 -> a0' In the second argument of `(<|) In the expression: f 3 <| id In an equation for `it
Either a b ~ a + b (a, b) ~ a * b a -> b ~ b^a () ~ 1 Void ~ 0 -- from Data.Void
pair :: forall r . (a -> b -> r) -> r pair ~ ((a, b) -> r) - > r ~ (a, b) ~ a * b
(a, (b, c)) ~ ((a, b), c) a * (b * c) = (a * b) * c a -> (b -> c) ~ (a, b) -> c (c^b)^a = c^(b * a)
data Iso a b = Iso { to :: a -> b , from :: b -> a -- proof1 :: forall x. to (from x) == x -- proof2 :: forall x. from (to x) == x }
Either ~ (+) (,) ~ (*) (->) b ~ flip (^) () ~ 1 Void ~ 0
(a, (b, c)) <=> ((a, b), c) ~ a * (b * c) = (a * b) * c
Type | Modeled¹ as | In category -------------------+---------------------------+------------- Unit | Terminal object | CCC Bottom | Initial object | Record | Product | Union | Sum (coproduct) | Function | Exponential | -------------------+---------------------------+------------- Dependent product² | Right adjoint to pullback | LCCC Dependent sum | Left adjoint to pullback |
twelve, eleven :: Arrow f => f p Int twelve = arr (const 12) eleven = arr (const 11)
arr (+) -- <<< twelve -- :: f b (Int -> Int) +----------+ +-----+ +--------------+ | const 12 |----> | (+) | == | const (+ 12) | +----------+ +-----+ +--------------+
uncurry :: (a -> b -> c) -> ((a, b) -> c) uncurry (+) :: Num a => (a, a) -> a
(arr.uncurry) (+) :: (Num a, Arrow f) => f (a, a) a
(arr.uncurry) (+) -- <<< twelve -- &&& eleven -- :: f b a +--------+ |const 12|-----. +--------+ | +-----+ +----------+ &&&====> | (+) | == | const 23 | +--------+ | +-----+ +----------+ |const 11|-----' +--------+
add :: Monad m => m Int -> m Int -> m Int add x y = x >>= \u -> (y >>= \v -> return (u + v))
add :: Arrow a => a b Int -> a b Int -> a b Int add f g = ...
ls = [ "banana", "mango", "orange" ] main = do map PutStrLn list_of_strings
ghc print-list.hs print-list.hs:3:0: Couldn In the expression: main When checking the type of the function `main'
Prelude> :type map putStrLn ls map putStrLn ls :: [IO ()]
ls = [ "banana", "mango", "orange" ] main = mapM_ putStrLn ls
class Negatable t where negate :: t -> t normalize :: (Negatable t) => t -> t normalize x = negate (negate x)
Couldn with actual type `m0 a0' Expected type: a0 -> forall s. ST s c0 Actual type: a0 -> m0 a0 In the second argument of `(.) In the expression: runST . return
> :m + Control.Monad.ST > :set -XRankNTypes > :t (((.) :: ((forall s0. ST s0 a) -> a) -> (a -> forall s1. ST s1 a) -> a -> a) runST return) $ True (((.) :: ((forall s0. ST s0 a) -> a) -> (a -> forall s1. ST s1 a) -> a -> a) runST return) $ True :: Bool
> let app f x = f x > :t runST `app` (return `app` True) <interactive>:1:14: Couldn with actual type `m0 t10' Expected type: t10 -> forall s. ST s t0 Actual type: t10 -> m0 t10 In the first argument of `app In the second argument of `app
> :t (app :: ((forall s0. ST s0 a) -> a) -> (forall s1. ST s1 a) -> a) runST (return `app` True) (app :: ((forall s0. ST s0 a) -> a) -> (forall s1. ST s1 a) -> a) runST (return `app` True) :: Bool
runST (return True) -- return True is ST s Bool (runST . return) True -- cannot work
foo :: Int -> Int foo seed = flip execState seed $ do modify $ (+) 3 modify $ (+) 4 modify $ (-) 2
class (Monoid w, Monad m) => MonadWriter w m | m -> w
data Customer = Customer { ..., foo :: Int, ... } data Product = Product { ..., foo :: Int, ... }
module Customer where data Customer = Customer { ..., foo :: Int, ... }
module Product where data Product = Product { ..., foo :: Int, ... }
module Third where import qualified Customer as C import qualified Product as P .. C.foo .. .. P.foo ..
class getFoo a where foo :: a -> Int instance getFoo Customer where foo = cFoo
-- stack runghc --resolver lts-8.20 --install-ghc {- newtype Foo = Foo { baz :: String } newtype Bar = Bar { baz :: String } foo = Foo { baz = "foo text" } bar = Bar { baz = "bar text" } main = do putStrLn $ "Foo: " ++ baz (foo :: Foo) -- Foo: foo text putStrLn $ "Bar: " ++ baz (bar :: Bar) -- Bar: bar text
* UHC (Utrecht Haskell Compiler) backend converts UHC core to JavaScript, allowing the compiling of Haskell code to JS. * YHC (York Haskell Compiler) backend, as above but with YHC core language. * jshaskell
bmiTell :: (RealFloat a) => a -> a -> String bmiTell weight height | weight / height ^ 2 <= 18.5 = "You | weight / height ^ 2 <= 25.0 = "You | weight / height ^ 2 <= 30.0 = "You | otherwise = "You
bmiTell :: (RealFloat weight, RealFloat height) => weight -> height -> String
Could not deduce (height ~ weight) from the context (RealFloat weight, RealFloat height) bound by the type signature for bmiTell :: (RealFloat weight, RealFloat height) => weight -> height -> String at example.hs:(25,1)-(27,27) `height the type signature for bmiTell :: (RealFloat weight, RealFloat height) => weight -> height -> String at example.hs:25:1 `weight the type signature for bmiTell :: (RealFloat weight, RealFloat height) => weight -> height -> String at example.hs:25:1 In the first argument of `(^) In the second argument of `(/) In the first argument of `(<=)
map :: (a -> b) -> [a] -> [b] map f (x:xs) = f x : map f xs map _ [] = []
type Meaning a b = a bmiTell :: (RealFloat a) => a `Meaning` weight -> a `Meaning` height -> String bmiTell weight height = -- etc.
bmiTell :: (RealFloat weight, RealFloat height, weight ~ height) => weight -> height -> String bmiTell weight height = -- etc.
type Weight a = a type Height a = a bmiTell :: (RealFloat a) => Weight a -> Height a -> String bmiTell weight height = -- etc.
newtype Weight a = Weight { getWeight :: a } newtype Height a = Height { getHeight :: a } bmiTell :: (RealFloat a) => Weight a -> Height a -> String bmiTell (Weight weight) (Height height)
bmiTell :: (RealFloat a) => a -- ^ your weight -> a -- ^ your height -> String -- ^ what I
(RealFloat weight, RealFloat height) => weight -> height -> String
{- bmiTell :: (RealFloat weight, RealFloat height,weight~height) => weight -> height -> String bmiTell weight height | weight / height ^ 2 <= 18.5 = "You | weight / height ^ 2 <= 25.0 = "You | weight / height ^ 2 <= 30.0 = "You | otherwise = "You
data Person = Person {name :: String, weight :: Float, height :: Float} bmiOffence :: Person -> String bmiOffence p | weight p / height p ^ 2 <= 18.5 = "You | weight p / height p ^ 2 <= 25.0 = "You | weight p / height p ^ 2 <= 30.0 = "You | otherwise = "You
type Weight = Float -- a type synonym - Float and Weight are exactly the same type, but human-readably different type Height = Float bmiClear :: Weight -> Height -> String ....
type FilePath = String writeFile :: FilePath -> String -> IO () -- take the path, the contents, and make an IO operation
type Height a = a type Weight a = a bmiTell :: (RealFloat a) => Weight a -> Height a -> String
data Body a = Body {weight, height :: a} bmiTell :: (RealFloat a) => Body a -> String
module Main where import qualified Data.Text as T import qualified Data.Text.IO as TIO import Control.Monad import Control.Applicative ((<$>)) import Data.Vector.Unboxed (Vector,(!)) import qualified Data.Vector.Unboxed as V solve :: Vector Int -> Int solve ar = V.foldl ar go sr (p,m) = sr + m - p main = do t <- fmap (read . T.unpack) TIO.getLine -- With Data.Text, the example finishes 15% faster. T.unlines . map (T.pack . show . solve . V.fromList . map (read . T.unpack) . T.words) <$> replicateM t (TIO.getLine >> TIO.getLine) >>= TIO.putStr
class PrettyPrint a where pretty :: a -> String type Logger m = forall a. (PrettyPrint a) => a -> m ()
noLogger :: (Monad m) => Logger m noLogger _ = return () stderrLogger :: (MonadIO m) => Logger m stderrLogger x = liftIO . hPutStrLn stderr $ pretty x fileLogger :: (MonadIO m) => FilePath -> Logger m fileLogger logF x = liftIO . withFile logF AppendMode $ \h -> hPutStrLn h (pretty x) acidLogger :: (MonadIO m) => AcidState MyDB -> Logger m acidLogger db x = update
printFile :: (MonadIO m) => Logger m -> FilePath -> m () printFile log fp = do log ("Printing file: " ++ fp) liftIO (readFile fp >>= putStr) log "Done printing."
import Control.Proxy -- This is just some pseudo-code. I type QueryString = String type Result = String query :: QueryString -> IO Result database :: (Proxy p) => QueryString -> Server p QueryString Result IO r database = runIdentityK $ foreverK $ \queryString -> do result <- lift $ query queryString respond result
user :: (Proxy p) => () -> Client p QueryString Result IO r user () = forever $ do lift $ putStrLn "Enter a query" queryString <- lift getLine result <- request queryString lift $ putStrLn $ "Result: " ++ result
mockDatabase :: (Proxy p) => QueryString -> Server p QueryString Result IO r mockDatabase = runIdentityK $ foreverK $ \query -> respond "42"
reproduce :: (Proxy p) => () -> Client p QueryString Result IO () reproduce () = do request "SELECT * FROM WHATEVER" request "CREATE TABLE BUGGED" request "I DON
{- module DependencyInjection where import Prelude hiding (log) import Control.Monad.IO.Class import Control.Monad.Identity import System.IO import Control.Monad.State -- |Any function that can turn a string into an action is considered a Logger. type Logger m = String -> m () -- |Logger that does nothing, for testing. noLogger :: (Monad m) => Logger m noLogger _ = return () -- |Logger that prints to STDERR. stderrLogger :: (MonadIO m) => Logger m stderrLogger x = liftIO $ hPutStrLn stderr x -- |Logger that appends messages to a given file. fileLogger :: (MonadIO m) => FilePath -> Logger m fileLogger filePath value = liftIO logToFile where logToFile :: IO () logToFile = withFile filePath AppendMode $ flip hPutStrLn value -- |Programs have to provide a way to the get the logger to use. class (Monad m) => MonadLogger m where getLogger :: m (Logger m) -- |Logs a given string using the logger obtained from the environment. log :: (MonadLogger m) => String -> m () log value = do logger <- getLogger logger value -- |Example function that we want to run in different contexts, like -- skip logging during testing. printFile :: (MonadIO m, MonadLogger m) => FilePath -> m () printFile fp = do log ("Printing file: " ++ fp) liftIO (readFile fp >>= putStr) log "Done printing." -- |Let type RealProgram = StateT String IO -- |To get the logger, build the right fileLogger. instance MonadLogger RealProgram where getLogger = do filePath <- get return $ fileLogger filePath -- |And this is how you run printFile "for real". realMain :: IO () realMain = evalStateT (printFile "file-to-print.txt") "log.out" -- |This is a fake program for testing: it will not do any logging. type FakeProgramForTesting = IO -- |Use noLogger. instance MonadLogger FakeProgramForTesting where getLogger = return noLogger -- |The program doesn fakeMain :: IO () fakeMain = printFile "file-to-print.txt"
-- | Every layout must be an instance of -- the basic layout operations along with a sensible default for each. -- -- ... -- class Show (layout a) => LayoutClass layout a where ...
-- | An existential type that can hold any object that is in -- and data Layout a = forall l. (LayoutClass l a, Read (l a)) => Layout (l a)
instance LayoutClass Layout Window where runLayout (Workspace i (Layout l) ms) r = fmap (fmap Layout) `fmap` runLayout (Workspace i l ms) r doLayout (Layout l) r s = fmap (fmap Layout) `fmap` doLayout l r s emptyLayout (Layout l) r = fmap (fmap Layout) `fmap` emptyLayout l r handleMessage (Layout l) = fmap (fmap Layout) . handleMessage l description (Layout l) = description l
-- | Set the layout of the currently viewed workspace setLayout :: Layout Window -> X () setLayout l = do ss@(W.StackSet { W.current = c@(W.Screen { W.workspace = ws })}) <- gets windowset handleMessage (W.layout ws) (SomeMessage ReleaseResources) windows $ const $ ss {W.current = c { W.workspace = ws { W.layout = l } } }
*** WARNING: ~/.ghci is writable by someone else, IGNORING!
{- module Main where import qualified Data.ByteString.Char8 as B import FFIFun.Foo main :: IO () main = do B.putStrLn "main" callMeFromC callMeFromHaskell return ()
{- {- module FFIFun.Foo where import qualified Data.ByteString.Char8 as B foreign import ccall "callMeFromHaskell" callMeFromHaskell :: IO () foreign export ccall callMeFromC :: IO () callMeFromC :: IO () callMeFromC = B.putStrLn "callMeFromC"
import System.Win32.Com import System.Win32.Com.Automation -- -- createObjectExcel -- coming from Automation.hs and com.hs -- iidIDispatch_unsafe = mkIID "{00020400-0000-0000-C000-000000000046}" createObjExl :: IO (IDispatch ()) createObjExl = do clsidExcel <- clsidFromProgID "Excel.Application" pExl <- coCreateInstance clsidExcel Nothing LocalProcess iidIDispatch_unsafe return pExl fichierTest2 = "E:/Programmation/haskell/Com/qos1.xls" main = coRun $ do pExl <- createObjExl workBooks <- pExl workBook <- workBooks workSheets <- workBook workBooks pExl mapM release [workSheets,workBook, workBooks, pExl]
*Main> coInitialize *Main> pExl <- createObjExl *Main> release pExl 0
*Main> pExl <interface pointer = 0x020844cc> *Main> coUnInitialize *Main> :q leaving Ghci Segmentation Fault/access violation ...
import Control.Monad import qualified Data.HashTable as H import System.Environment main = do [size] <- fmap (fmap read) getArgs m <- H.new (==) H.hashInt forM_ [1..size] $ \n -> H.insert m n n v <- H.lookup m 100 print v
import Control.Monad import Data.List import qualified Data.IntMap as I import System.Environment main = do [size] <- fmap (fmap read) getArgs let k = foldl print $ I.lookup 100 k
$ time ./A 10000000 +RTS -s ./A 10000000 +RTS -s 6s
import Control.Monad import Data.List import System.Environment import qualified Data.Judy as J main = do [size] <- fmap (fmap read) getArgs j <- J.new :: IO (J.JudyL Int) forM_ [1..size] $ \n -> J.insert (fromIntegral n) n j print =<< J.lookup 100 j
-- | Given a generator that uses different substate type, convert it -- to a generator that runs with our substate type. As well as the -- other-substate-type generator, the caller must provide an initial -- substate for that generator and a function taking the final substate -- of the generator and producing a new substate of our type. This -- preserves all other (non-substate) parts of the master state touched -- by the generator. -- mgConvertSubstate :: MsgGen msg st
>>> take 10 $ liftM2 (,) [0..] [0..] [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9)] >>> take 10 $ runOmega $ liftM2 (,) (each [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)]
runShpider $ do download "http: theForm : _ <- getFormsByAction "http: sendForm $ fillOutForm theForm $ pairs $ do "occupation" =: "unemployed Haskell programmer" "location" =: "mother
import Database.HaskellDB import Database.HaskellDB.DBLayout data Revision a = Revision deriving Eq data Book = Book instance FieldTag (Revision a) where fieldName _ = "rev_id" revIdField :: Attr (Revision Book) (Revision Book) revIdField = mkAttr undefined branch :: Table (RecCons (Revision Book) (Expr (Revision Book)) RecNil) branch = baseTable "branch" $ hdbMakeEntry undefined bookRevision :: Table (RecCons (Revision Book) (Expr (Revision Book)) RecNil) bookRevision = baseTable "book_revision" $ hdbMakeEntry undefined masterHead :: Query (Rel (RecCons (Revision Book) (Expr (Revision Book)) RecNil)) masterHead = do revisions <- table bookRevision branches <- table branch restrict $ revisions ! revIdField .==. branches ! revIdField return revisions
branch :: Table (RecCons (Revision entity) (Expr (Revision entity)) RecNil) branch = baseTable "branch" $ hdbMakeEntry undefined
Overlapping instances for HasField (Revision Book) (RecCons (Revision entity0) (Expr (Revision entity0)) RecNil) arising from a use of `!' Matching instances: instance [overlap ok] HasField f r => HasField f (RecCons g a r) -- Defined in Database.HaskellDB.HDBRec instance [overlap ok] HasField f (RecCons f a r) -- Defined in Database.HaskellDB.HDBRec (The choice depends on the instantiation of `entity0' To pick the first instance above, use -XIncoherentInstances when compiling the other instance declarations) In the second argument of `(.==.) In the second argument of `($) `revisions ! revIdField .==. branches ! revIdField' In a stmt of a restrict $ revisions ! revIdField .==. branches ! revIdField
type BranchTable entity = Table (RecCons (Revision entity) (Expr (Revision entity)) RecNil) branch :: BrancTable entity branch = baseTable "branch" $ hdbMakeEntry undefined
masterHead :: Query (Rel (RecCons (Revision Book) (Expr (Revision Book)) RecNil)) masterHead = do revisions <- table bookRevision branches <- table (branch :: BranchTable Book) restrict $ revisions ! revIdField .==. branches ! revIdField return revisions
masterHead :: (ShowRecRow r, HasField (Revision e) r) => Table r -> e -> Query (Rel r) masterHead revTable et = do revisions <- table revTable branches <- table branch' restrict $ revisions ! revIdField return revisions where (branch revBundle :: HasField (Revision e) r => Table r -> e -> (BranchTable e, Attr (Revision e) (Revision e)) revBundle table et = (branch, revIdField)
SELECT rev_id1 as rev_id FROM (SELECT rev_id as rev_id2 FROM branch as T1) as T1, (SELECT rev_id as rev_id1 FROM book_revision as T1) as T2 WHERE rev_id1 = rev_id2
$ ghc-pkg list /usr/lib/ghc-6.12.1/package.conf.d: Cabal-1.7.4 array-0.2.0.1 base-3.0.3.0 base-4.2.0.0 bin-package-db-0.0.0.0 binary-0.5.0.1 bytestring-0.9.1.4 containers-0.2.0.1 directory-1.0.0.2 (dph-base-0.4.0) (dph-par-0.4.0) (dph-prim-interface-0.4.0) (dph-prim-par-0.4.0) (dph-prim-seq-0.4.0) (dph-seq-0.4.0) extensible-exceptions-0.1.1.0 ffi-1.0 filepath-1.1.0.1 (ghc-6.12.1) ghc-prim-0.1.0.0 haskeline-0.6.2 haskell98-1.0.1.0 hpc-0.5.0.2 integer-gmp-0.1.0.0 mtl-1.1.0.2 old-locale-1.0.0.1 old-time-1.0.0.1 pretty-1.0.1.0 process-1.0.1.1 random-1.0.0.1 rts-1.0 syb-0.1.0.0 template-haskell-2.4.0.0 terminfo-0.3.1 time-1.1.4 unix-2.3.1.0 utf8-string-0.3.4
import Data.Char groupsOf _ [] = [] groupsOf n xs = take n xs : groupsOf n ( tail xs ) problem_8 x = maximum . map product . groupsOf 5 $ x main = do t <- readFile "p8.log" let digits = map digitToInt $concat $ lines t print $ problem_8 digits
let digits = map digitToInt $concat $ lines t print $ problem_8 digits
let digits = map digitToInt $concat $ lines t in print $ problem_8 digits
f x y | y>z = ... | y==z = ... | y<z = ... where z = x*x
> [(x, y) | x <- [1..3], let y = 2*x] [(1,2),(2,4),(3,6)]
someFunc x y | guard1 = blah1 | guard2 = blah2 where {assignments}
do stuff let val = ... in do more stuff $ using val
main = readFile "p8.log" >>= (\t -> let digits = map digitToInt $ concat $ lines t in print (problem_8 digits))
Within do-blocks or list comprehensions let { d1 ; ... ; dn } without `in` serves to introduce local bindings.
(x `quot` y)*y + (x `rem` y) == x (x `div` y)*y + (x `mod` y) == x
Hugs> (-20) `divMod` 3 (-7,1) Hugs> (-20) `quotRem` 3 (-6,-2)
class MyClass a where someFunc :: a -> a myShow :: a -> String instance MyClass a => Show a where show a = myShow a
class MyClass a where someFunc :: a -> a myShow :: a -> String instance Show (MyClass a) where show a = myShow a
data Foo = Foo data Bar = Bar instance MyClass Foo where myShow a = "foo" instance MyClass Bar where myShow a = "bar" main = do print Foo print Bar
instance MyClass a => Show a where data MyFoo = MyFoo ... deriving (Show) instance MyClass MyFoo where
instance MyClass a => Show a where show a = myShow a
instance MyClass a => Show a where show = myShow instance HisClass a => Show a where show = hisShow
instance Show HisDataTypeThatHasNeverHeardOfMyClass
instance MyClass Foo where ... instance Show Foo where show = myShow
newtype WrappedMyClass a = WrapMyClass { unwrapMyClass :: a } instance MyClass a => Show (WrappedMyClass a) where show (WrapMyClass a) = myShow a
instance Foo a => Show (WrappedFoo a) where ... instance Bar a => Show (WrappedBar a) where ...
instance Monad t => Applicative t where pure = return (<*>) = ap
class Show a => MyClass a where someFunc :: a -> a myShow :: MyClass a => a -> String myShow = show
{- class MyClass a where someFunc :: a -> Int class MyShow a where myShow :: a -> String default myShow :: MyClass a => a -> String myShow = show . someFunc instance MyClass Int where someFunc i = i instance MyShow Int main = putStrLn (myShow 5)
-- given `readChunk` which reads a chunk beginning at n readChunk :: FilePath -> Int -> IO (Int, ByteString) readFile fp = readChunks 0 where readChunks n = do (n chunks <- readChunks n' return (chunk <> chunks)
readFile fp = readChunks 0 where readChunks n = do (n chunks <- unsafeInterleaveIO (readChunks n return (chunk <> chunks)
readFileCo :: Monoid a => FilePath -> (ByteString -> IO a) -> IO a readFileCo fp action = readChunks 0 where readChunks n = do (n a <- action chunk as <- readChunks n return (a <> as)
produceFile :: FilePath -> Producer ByteString IO () produceFile fp = produce 0 where produce n = do (n yield chunk produce n'
import System.IO main = withFile "myfile" ReadMode hGetContents >>= return . (take 5) >>= putStrLn
main = withFile "myfile" ReadMode $ \handle -> hGetContents handle >>= return . (take 5) >>= putStrLn
main = withFile "myfile" ReadMode $ \handle -> fmap (take 5) (hGetContents handle) >>= putStrLn
class Category cat where id :: cat a a (.) :: cat b c -> cat a b -> cat a c
class Monoid a where mempty :: a mappend :: a -> a -> a
newtype Sum a = Sum {getSum :: a} instance (Num a) => Monoid (Sum a) where mempty = Sum 0 mappend (Sum a) (Sum b) = Sum (a + b) instance Monoid [a] where mempty = [] mappend = (++)
instance (Functor f) => Applicative f where pure :: a -> f a (<*>) :: f (a -> b) -> f a -> f b
join (Just (Just 42)) -- gives Just 42 join (Just (Nothing)) -- gives Nothing
int ack(int m, int n) { if (m == 0) return n+1; if (n == 0) return ack(m-1, 1); return ack(m-1, ack(m, n-1)); } int main() { printf("%d\n", ack(4,1)); return 0; }
let rec ack = function | 0,n -> n+1 | m,0 -> ack (m-1, 1) | m,n -> ack (m-1, ack (m, n-1)) in print_int (ack (4, 1))
fun ack 0 n = n+1 | ack m 0 = ack (m-1) 1 | ack m n = ack (m-1) (ack m (n-1)); print (Int.toString (ack 4 1));
(require racket/unsafe/ops) (define + unsafe-fx+) (define - unsafe-fx-) (define (ack m n) (cond [(zero? m) (+ n 1)] [(zero? n) (ack (- m 1) 1)] [else (ack (- m 1) (ack m (- n 1)))])) (time (ack 4 1))
main = print $ ack 4 1 where ack :: Int -> Int -> Int ack 0 n = n+1 ack m 0 = ack (m-1) 1 ack m n = ack (m-1) (ack m (n-1))
module Main where data P = P !Int !Int main :: IO () main = print $ ack (P 4 1) id where ack :: P -> (Int -> Int) -> Int ack (P 0 n) k = k (n + 1) ack (P m 0) k = ack (P (m-1) 1) k ack (P m n) k = ack (P m (n-1)) (\a -> ack (P (m-1) a) k)
$ time ./Test 65533 ./Test 52,47s user 0,50s system 96% cpu 54,797 total
$ time ./test 65533./test 7,97s user 0,05s system 94% cpu 8,475 total
$ time ./hs.out 65533 ./hs.out 5,31s user 0,03s system 96% cpu 5,515 total
{- module Main where data P = P {- ack0 :: Int -> Int ack0 n =(n+1) AckType(1) AckType(2) AckType(3) AckType(4) CONCAT(ack,M) n = case n of { 0 -> CONCAT(ack,M1) 1 \ ; 1 -> CONCAT(ack,M1) (CONCAT(ack,M1) 1) \ ; _ -> CONCAT(ack,M1) (CONCAT(ack,M) (n-1)) } AckDecl(1,0) AckDecl(2,1) AckDecl(3,2) AckDecl(4,3) ack :: P -> (Int -> Int) -> Int ack (P m n) k = case m of 0 -> k (ack0 n) 1 -> k (ack1 n) 2 -> k (ack2 n) 3 -> k (ack3 n) 4 -> k (ack4 n) _ -> case n of 0 -> ack (P (m-1) 1) k 1 -> ack (P (m-1) 1) (\a -> ack (P (m-1) a) k) _ -> ack (P m (n-1)) (\a -> ack (P (m-1) a) k) main :: IO () main = print $ ack (P 4 1) id
$ time ./Test +RTS -kc1M 65533 ./Test +RTS -kc1M 6,30s user 0,04s system 97% cpu 6,516 total
ackermann :: Int -> Int -> Int ackermann 0 n = n + 1 ackermann m 0 = ackermann (m - 1) 1 ackermann 1 n = n + 2 ackermann 2 n = 2 * n + 3 ackermann 3 n = 2 ^ (n + 3) - 3 ackermann m n = ackermann (m - 1) (ackermann m (n - 1))
import Data.Function.Memoize ackermann :: Integer -> Integer -> Integer ackermann 0 n = n + 1 ackermann m 0 = ackermann (m - 1) 1 ackermann 1 n = n + 2 ackermann 2 n = 2 * n + 3 ackermann 3 n = 2 ^ (n + 3) - 3 ackermann m n = ackermann (m - 1) (ackermann m (n - 1)) main :: IO () main = print $ memoize2 ackermann 4 2
acks :: [[Int]] acks = [ [ case (m, n) of (0, _) -> n + 1 (_, 0) -> acks !! (m - 1) !! 1 (_, _) -> acks !! (m - 1) !! (acks !! m !! (n - 1)) | n <- [0..] ] | m <- [0..] ] main :: IO () main = print $ acks !! 4 !! 1
main = print $ ack 4 2 where ack :: Int -> Integer -> Integer ack 0 n = n + 1 ack 1 n = n + 2 ack 2 n = 2 * n + 3 ack m 0 = ack (m-1) 1 ack m n = ack (m-1) (ack m (n-1) )
data Ack = Ack !Int ack :: Int -> Int -> Int ack m n = length . ackR $ Ack m : replicate n (Ack 0) where ackR n@(Ack 0 : _) = n ackR n = ackR $ ack ack ack ack ack decr (Ack 0 : n) = n decr n = decr $ ack
int ack(int m,int n){ if(m==0) return n+1; if(n==0) return ack(m-1,1); return ack(m-1, ack(m,n-1)); }
ack :: Int -> Int -> Int ack 0 n = n+1 ack m 0 = ack (m-1) 1 ack m n = ack (m-1) (ack m (n-1))
myLast :: [a] -> a myLast [x] = x myLast (_:xs) = myLast xs
{- import Test.QuickCheck import Test.QuickCheck.All myLast :: [a] -> a myLast [x] = x myLast (_:xs) = myLast xs -- here we specify that -- as prop_myLast xs = myLast xs == last xs return [] -- need this for GHC 7.8 -- quickCheckAll generates test cases for all main = $(quickCheckAll)
=== prop_myLast on tmp3.hs:12 === *** Failed! Exception: [] False
prop_myLast xs = length xs > 0 ==> myLast xs == last xs
=== prop_myLast on tmp3.hs:11 === +++ OK, passed 100 tests. True
prop_myLast3 x xs = x `notElem` xs ==> myLast (xs++[x]) == x
Prelude> reads "7a7" :: [(Int, String)] [(7,"a7")] Prelude> reads "7e7" :: [(Int, String)] []
read (str,s) <- lex r (n,"") <- readPos str return (n,s)
GHCi, version 7.4.1: http: Prelude> reads "7a7" :: [(Int, String)] [(7,"a7")] Prelude> reads "7e7" :: [(Int, String)] [(70000000,"")] Prelude>
has :: (Eq a) => [a] -> a -> Bool has [] _ = False has (x:xs) a | x == a = True | otherwise = has xs a unique :: (Eq a) => [a] -> [a] unique [] = [] unique (x:xs) | has xs x = unique xs | otherwise = x : unique xs
import qualified Data.Set as Set nubOrd :: Ord a => [a] -> [a] nubOrd xs = go Set.empty xs where go s (x:xs) | x `Set.member` s = go s xs | otherwise = x : go (Set.insert x s) xs go _ _ = []
import Data.Set (toList, fromList) uniquify lst = toList $ fromList lst
unique_alt :: [Int] -> [Int] unique_alt [] = [] unique_alt (x:xs) | elem x ( unique_alt xs ) = [ y | y <- ( unique_alt xs ), y /= x ] | otherwise = x : ( unique_alt xs )
unique [1,2,1] = [2,1] unique_alt [1,2,1] = [2] unique [1,2,1,2] = [1,2] unique_alt [1,2,1,2] = [] unique [4,2,1,3,2,3] = [4,1,2,3] unique_alt [4,2,1,3,2,3] = [4,1]
unique [] = [] unique (x:xs) = x:unique (filter ((/=) x) xs)
unique :: [Int] -> [Int] unique xs = [x | (x,y) <- zip xs [0..], x `notElem` (take y xs)]
data Foo = Foo { id_ :: Int , name_ :: String } deriving (Show) alldata = [ Foo 1 "Name" , Foo 2 "Name" , Foo 3 "Karl" , Foo 4 "Karl" , Foo 5 "Karl" , Foo 7 "Tim" , Foo 8 "Tim" , Foo 9 "Gaby" , Foo 9 "Name" ] isolate :: [Foo] -> [Foo] isolate [] = [] isolate (x:xs) = (fst f) : isolate (snd f) where f = foldl helper (x,[]) xs helper (a,b) y = if name_ x == name_ y then if id_ x >= id_ y then (x,b) else (y,b) else (a,y:b) main :: IO () main = mapM_ (putStrLn . show) (isolate alldata)
Foo {id_ = 9, name_ = "Name"} Foo {id_ = 9, name_ = "Gaby"} Foo {id_ = 5, name_ = "Karl"} Foo {id_ = 8, name_ = "Tim"}
Suppose we wish to deﬁne a function that repeats its argument indeﬁnitely: repeat x = x : repeat x or, in lambdas: repeat = λx → x : repeat x This requires O(n) space. But we can achieve O(1) space by writing instead: repeat = λx → let xs = x : xs in xs
r = \x -> x: r x r 3 -> 3: r 3 -> 3: 3: 3: ........ -> [3,3,3,......]
r = \x -> let xs = x:xs in xs r 3 -> let xs = 3:xs in xs -> xs, according to the definition above: -> 3:xs, where xs = 3:xs -> 3:xs:xs, where xs = 3:xs
error: Variable not in scope: x | 1 | main = putStrLn $ show x | ^
main = print (3 + 4) where -- silly redefinition of `+` follows 0 + y = y x + y = x * ((x-1) + y)
<interactive>:11:6: warning: [-Wname-shadowing] This binding for ‘+’ shadows the existing binding
instance MonadState MyState MyMonad where get = MyMonad get put s = MyMonad (put s)
bangMe :: State String () bangMe = do str <- get put $ str ++ "!" -- or just modify (++"!")
-- BAD: f is too ambiguous, due to non-injectivity -- type family F a -- OK data family F a f :: F a -> F a f = undefined g :: F Int -> F Int g x = f x
class GMapKey k where data GMap k :: * -> * empty :: GMap k v lookup :: k -> GMap k v -> Maybe v insert :: k -> v -> GMap k v -> GMap k v
class Collects ce where type Elem ce empty :: ce insert :: Elem ce -> ce -> ce member :: Elem ce -> ce -> Bool toList :: ce -> [Elem ce]
import Data.ByteString as S import Data.ByteString.Lazy as L -- Declare a family of type synonyms, called `Element` -- `Element` has kind `* -> *`; it takes one parameter, which we call `container` type family Element container -- ByteString is a container for Word8, so... -- The Element of a `S.ByteString` is a `Word8` type instance Element S.ByteString = Word8 -- and the Element of a `L.ByteString` is also `Word8` type instance Element L.ByteString = Word8
-- `w` is a Word8.... >let w = 0::Word8 -- ... and also an `Element L.ByteString` >:t w :: Element L.ByteString w :: Element L.ByteString :: Word8 -- ... and also an `Element S.ByteString` >:t w :: Element S.ByteString w :: Element S.ByteString :: Word8 -- but not an `Int` >:t w :: Int Couldn
-- As before, `Word8` matches `Element L.ByteString` ... >(0::Word8)::(Element L.ByteString) -- .. but GHC can >(w)::(Element a) Couldn with actual type `Element a0' NB: `Element The type variable `a0
type instance Element Int = Bool > True::(Element a) > NB: `Element
-- Declare a list-like data family data family XList a -- Declare a list-like instance for Char data instance XList Char = XCons Char (XList Char) | XNil -- Declare a number-like instance for () data instance XList () = XListUnit Int -- ERROR: "Multiple declarations of `XListUnit data instance XList () = XListUnit Bool -- (Note: GHCI accepts this; the new declaration just replaces the previous one.)
> class Const a where constE :: (Element a) -> a -> (Element a) > instance Const S.ByteString where constE = const > constE (0::Word8) undefined ERROR: Couldn -- By providing a match `a = S.ByteString`, `Word8` matches `(Element S.ByteString)` > constE (0::Word8) (undefined::S.ByteString) 0 -- impossible, since `Char` cannot match `Element a` under our current definitions. > constF
data Vec :: Nat -> * where Nil :: Vec Z Cons :: Int -> Vec n -> Vec (S n)
data Vec n a where Vnil :: Vec Zero a Vcons :: a -> Vec n a -> Vec (Succ n) a data Zero data Succ a
case [1,2..10000000] of [x] -> x (_:xs) -> last xs [] -> error "empty list"
import System.Directory (removeFile) import System.IO (hGetContents, hPutStr, hSeek, openBinaryTempFile, SeekMode (..)) import Test.QuickCheck (arbitrary, Property, quickCheck, (==>)) import Test.QuickCheck.Monadic (assert, monadicIO, pick, pre, run) -- Demonstrating pick and pre as well: prop_writeThenRead :: Property prop_writeThenRead = monadicIO $ do writtenData <- pick arbitrary pre $ not (null writtenData) readData <- run $ writeThenRead writtenData assert $ writtenData == readData -- A more idiomatic way to write the above: prop_writeThenRead2 :: [Char] -> Property prop_writeThenRead2 writtenData = not (null writtenData) ==> monadicIO test where test = do readData <- run $ writeThenRead writtenData assert $ writtenData == readData writeThenRead :: [Char] -> IO [Char] writeThenRead output = do (path, h) <- openBinaryTempFile "/tmp" "quickcheck.tmp" removeFile path hPutStr h output hSeek h AbsoluteSeek 0 hGetContents h main :: IO () main = do quickCheck prop_writeThenRead quickCheck prop_writeThenRead2
myLength :: [a] -> Integer myLength xs = len xs 0 where len [] l = l len (x:xs) l = len xs (l+1) main = print $ myLength [1..10000000]
myLength :: [a] -> Integer myLength xs = len xs 0 where len [] l = l len (x:xs) l = len xs $! (l+1) main = print $ myLength [1..10000000]
len [1..100000] 0 -> len [2..100000] (0+1) -> len [3..100000] (0+1+1)
module Main where import Data.List import System.Environment (getArgs) main = do n <- getArgs >>= readIO.head putStrLn $ "Length of an array from 1 to " ++ show n ++ ": " ++ show (myLength [1..n]) myLength :: [a] -> Int myLength = foldl
C:\haskell>ghc --make Test.hs -O2 -fforce-recomp [1 of 1] Compiling Main ( Test.hs, Test.o ) Linking Test.exe ... C:\haskell>Test.exe 10000000 +RTS -sstderr Test.exe 10000000 +RTS -sstderr Length of an array from 1 to 10000000: 10000000 401,572,536 bytes allocated in the heap 18,048 bytes copied during GC 2,352 bytes maximum residency (1 sample(s)) 13,764 bytes maximum slop 1 MB total memory in use (0 MB lost due to fragmentation) Generation 0: 765 collections, 0 parallel, 0.00s, 0.00s elapsed Generation 1: 1 collections, 0 parallel, 0.00s, 0.00s elapsed INIT time 0.00s ( 0.00s elapsed) MUT time 0.27s ( 0.28s elapsed) GC time 0.00s ( 0.00s elapsed) EXIT time 0.00s ( 0.00s elapsed) Total time 0.27s ( 0.28s elapsed) %GC time 0.0% (0.7% elapsed) Alloc rate 1,514,219,539 bytes per MUT second Productivity 100.0% of total user, 93.7% of total elapsed C:\haskell>
file :: String file = "the first line\nthe second line\nthe third line"
file :: String file = "the first line the second line the third line"
factor.hs:58:33: lexical error in string/character literal at character Failed, modules loaded: none.
x = "This is some text which we escape \ \ and unescape to keep writing"
"This is some text which we escape and unescape to keep writing"
x = "This is some text which we escape \n\ \ and unescape to keep writing"
This is some text which we escape and unescape to keep writing
{- import NeatInterpolation (text) import qualified Data.Text.IO f :: Text -> Text -> Text f a b = [text| function(){ function(){ $a } return $b } |] main = Data.Text.IO.putStrLn $ f "1" "2"
main = Data.Text.IO.putStrLn $ f "{\n indented line\n indented line\n}" "{\n indented line\n indented line\n}"
function(){ function(){ { indented line indented line } } return { indented line indented line } }
function(){ function(){ { indented line indented line } } return { indented line indented line } }
file :: String file = "the first line\n\ \the second line\n\ \the third line\n"
file :: String file = unlines [ "the first line", "the second line", "the third line" ]
file = [q| the first line the second line the third line |]
{- import Text.RawString.QQ multiline :: String multiline = [r|<HTML> <HEAD> <TITLE>Auto-generated html formated source</TITLE> <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252"> </HEAD> <BODY LINK="800080" BGCOLOR=" <P> </P> <PRE>|]
instance Monad (Either e) where return = Right Left e >>= _ = Left e Right a >>= f = f a
instance Applicative (Either e) where pure = return (<*>) = ap
ap :: Monad m => m (a -> b) -> m a -> m b ap mf ma = do f <- mf a <- ma return (f a)
instance Monoid e => Applicative (Either e) where pure = Right
Right f <*> Right a = Right (f a) -- neutral Left e <*> Right _ = Left e -- short-circuit Right _ <*> Left e = Left e -- short-circuit Left e1 <*> Left e2 = Left (e1 <> e2) -- combine!
> Right (+1) <*> Left [1] <*> Left [2] > Left [1,2]
ifA :: Applicative f => f Bool -> f a -> f a -> f a
ifM :: Monad m => m Bool -> m a -> m a -> m a ifM mbool th el = do bool <- mbool if bool then th else el
ifM (return True) t e == t ifM (return False) t e == e
return 42 >>= (\x -> if x == 1 then return (x+1) else return (x-1) >>= (\y -> return (1/y) ))
instance Monoid e => Applicative (Either e) where pure = Right Right f <*> Right a = Right (f a) -- neutral Left e <*> Right _ = Left e -- short-circuit Right _ <*> Left e = Left e -- short-circuit Left e1 <*> Left e2 = Left (e1 <> e2) -- combine!
ifA :: Applicative f => f Bool -> f a -> f a -> f a
ap :: m (a->b) -> (m a->m b) =<< :: (a->m b) -> (m a->m b)
f 1 = Nothing -- here f "decides" to produce Nothing f x = Just x Just 1 >>= f >>= g -- g doesn
f 1 = 0 f x = x g <$> f <$> Just 1 -- oh well, this will produce Just 0, but can -- from getting applied
instance Monad Maybe where return = Just Nothing >>= _ = Nothing Just a >>= k = k a
-- | The composition of two functors. newtype Compose f g a = Compose { getCompose :: f (g a) } -- | The composition of two functors is also a functor. instance (Functor f, Functor g) => Functor (Compose f g) where fmap f (Compose x) = Compose (fmap (fmap f) x) -- | The composition of two applicatives is also an applicative. instance (Applicative f, Applicative g) => Applicative (Compose f g) where pure x = Compose (pure (pure x)) Compose f <*> Compose x = Compose ((<*>) <$> f <*> x) -- | The product of two functors. data Product f g a = Pair (f a) (g a) -- | The product of two functors is also a functor. instance (Functor f, Functor g) => Functor (Product f g) where fmap f (Pair x y) = Pair (fmap f x) (fmap f y) -- | The product of two applicatives is also an applicative. instance (Applicative f, Applicative g) => Applicative (Product f g) where pure x = Pair (pure x) (pure x) Pair f g <*> Pair x y = Pair (f <*> x) (g <*> y) -- | The sum of a functor @f@ with the data Lift f a = Pure a | Other (f a) -- | The sum of two functors is always a functor. instance (Functor f) => Functor (Lift f) where fmap f (Pure x) = Pure (f x) fmap f (Other y) = Other (fmap f y) -- | The sum of any applicative with instance (Applicative f) => Applicative (Lift f) where pure = Pure Pure f <*> Pure x = Pure (f x) Pure f <*> Other y = Other (f <$> y) Other f <*> Pure x = Other (($ x) <$> f) Other f <*> Other y = Other (f <*> y)
newtype Constant a b = Constant { getConstant :: a } instance Functor (Constant a) where fmap f (Constant x) = Constant x instance (Monoid a) => Applicative (Constant a) where pure _ = Constant mempty Constant x <*> Constant y = Constant (x `mappend` y)
iffy :: Applicative f => f Bool -> f a -> f a -> f a iffy fb ft fe = cond <$> fb <*> ft <*> fe where cond b t e = if b then t else e case 1>> iffy (Just True) (Just “True”) Nothing ->> Nothing
case 2>> iffy (Just False) (Just “True”) (Just "False") ->> Just "False"
Just (Cond True "True") <*> something [something being "accidentaly" Nothing]
func :: exists a. a -> a func True = False func False = True
class Monad m where join :: m (m a) -> m a return :: a -> m a fmap :: (a -> b) -> m a -> m b
class Monad (m :: * -> *) where return :: a -> m a (>>=) :: m a -> (a -> m b) -> m b
class Monad m where return :: a -> m a (>>=) :: m a -> (a -> m b) -> m b
(if expensiveTest1 then 0 else 2) * (if expensiveTest2 then 0 else 2)
-- | Multiply two timesInteger :: Integer -> Integer -> Integer timesInteger _ (S timesInteger (S timesInteger x (S timesInteger (S timesInteger x (S timesInteger (S timesInteger (S = case mulIntMayOflo 0 _ -> timesInt2Integer x timesInteger x@(S -- no S timesInteger (Jp timesInteger (Jp timesInteger (Jp | isTrue | True = Jn timesInteger (Jn timesInteger (Jn timesInteger (Jn | isTrue | True = Jp
module Test where import Data.Function(fix) -- fix (0 ~*) == 0 -- fix (~* 0) == ***Exception<<loop>> (~*) :: (Num a, Eq a) => a -> a -> a 0 ~* _ = 0 _ ~* 0 = 0 x ~* y = x ~* y -- fix (0 *~) == ***Exception<<loop>> -- fix (*~ 0) == 0 (*~) :: (Num a, Eq a) => a -> a -> a _ *~ 0 = 0 0 *~ _ = 0 x *~ y = x *~ y
*Test> let x = fix (* 0) *Test> x 0 *Test> x :: Double *** Exception: <<loop>> *Test>
# # 30.65% queens queens [.] s1ql_info 18.67% queens queens [.] s1qj_info 12.17% queens queens [.] s1qi_info 9.94% queens queens [.] s1o9_info 5.85% queens queens [.] r1nI_info 5.33% queens queens [.] s1sF_info 5.18% queens queens [.] s1sG_info 3.69% queens queens [.] s1oP_info 1.68% queens queens [.] stg_upd_frame_info 0.88% queens queens [.] stg_ap_2_upd_info 0.62% queens queens [.] s1sE_info 0.56% queens [kernel] [k] read_hpet 0.39% queens queens [.] stg_ap_p_info 0.35% :2030 f76beb [.] 0x00000000f76beb 0.31% queens queens [.] s1oD_info 0.28% swapper [kernel] [k] mwait_idle_with_hints 0.25% queens queens [.] __stg_gc_enter_1 0.23% queens queens [.] evacuate 0.18% swapper [kernel] [k] read_hpet 0.12% queens queens [.] scavenge_block
import qualified Data.Text as T let s :: String = " abc " in T.strip s
> :set -XOverloadedStrings > import Data.Text > strip " abc " "abc"
import Data.Char trim xs = dropSpaceTail "" $ dropWhile isSpace xs dropSpaceTail maybeStuff "" = "" dropSpaceTail maybeStuff (x:xs) | isSpace x = dropSpaceTail (x:maybeStuff) xs | null maybeStuff = x : dropSpaceTail "" xs | otherwise = reverse maybeStuff ++ x : dropSpaceTail "" xs > trim " hello this \t should trim ok.. .I think .. \t " "hello this \t should trim ok.. .I think .."
import Data.Char (isSpace) trim :: String -> String trim = f . f where f = reverse . dropWhile isSpace
strip = lstrip . rstrip lstrip = dropWhile (`elem` " \t") rstrip = reverse . lstrip . reverse
rstrip :: String -> String rstrip str = let (zs, f) = go str in if f then [] else zs where go [] = ([], True) go (y:ys) = if isSpace y then let (zs, f) = go ys in (y:zs, f) else (y:(rstrip ys), False)
import qualified Data.Text as T strip = T.unpack . T.strip . T.pack lstrip = T.unpack . T.stripStart . T.pack rstrip = T.unpack . T.stripEnd . T.pack
> let s = " hello " > strip s "hello" > lstrip s "hello " > rstrip s " hello"
import Data.String.Utils myString = " foo bar " -- strip :: String -> String myTrimmedString = strip myString -- myTrimmedString == "foo bar"
import Data.Char (isSpace) import Data.List (foldl trim :: String -> String trim s = let s trim (\(c,w) x -> if isSpace x then (c,w+1) else (c+w+1,0)) (0,0) s' in take (fst trim
print $ trim " a b c " print $ trim " ab c " print $ trim " abc " print $ trim "abc" print $ trim "a bc "
-- entirely input is to be trimmed trim :: String -> String trim = Prelude.filter (not . isSpace -- just the left and the right side of the input is to be trimmed lrtrim :: String -> String lrtrim = \xs -> rtrim $ ltrim xs where ltrim = dropWhile (isSpace rtrim xs | Prelude.null xs = [] | otherwise = if isSpace then rtrim $ init xs else xs -- returns True if input equals isSpace isSpace
>lrtrim "" >"" >lrtrim " " >"" >lrtrim "haskell " >"haskell" >lrtrim " haskell " >"haskell" >lrtrim " h a s k e ll " >"h a s k e ll"
import Data.Char (isSpace) dropFromTailWhile _ [] = [] dropFromTailWhile p item | p (last items) = dropFromTailWhile p $ init items | otherwise = items trim :: String -> String trim = dropFromTailWhile isSpace . dropWhile isSpace
import Data.Char (isSpace) trim :: String -> String -- Trimming the front is easy. Use a helper for the end. trim = dropWhile isSpace . trim where trim -- When finding whitespace, put it in the space bin. When finding -- non-whitespace, include the binned whitespace and continue with an -- empty bin. When at the end, just throw away the bin. trim trim | otherwise = bin ++ a : trim
import System.Environment import Data.Text strip :: String -> IO String strip = return . unpack . Data.Text.strip . pack main = getLine >>= Main.strip >>= putStrLn
fibs :: [Integer] fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
fib :: Integer -> Integer fib 0 = 0 fib 1 = 1 fib n = fib (n-1) + fib (n-2)
[ 1, 1, 2, 3, 5, 8, 13, .... ] + [ 1, 2, 3, 5, 8, 13, 21, .... ] = [ 2, 3, 5, 8, 13, 21, 34, .... ]
fibonacci :: Integer -> Integer fibonacci 0 = 1 fibonacci 1 = 1 fibonacci x = fibonacci (x-1) + fibonacci (x-2)
n = 0 => (0,0,1) n = 1 => (1,1,1) - calculated from the previous triple n = 2 => (2,1,2) - calculated from the previous triple n = 3 => (3,2,3) - calculated from the previous triple n = 4 => (4,3,5) - calculated from the previous triple n = 5 => (5,5,8) - calculated from the previous triple
nextTripleIfCurrentNIsLessThanN :: (Int, Integer, Integer) -> Int -> (Int, Integer, Integer) nextTripleIfCurrentNIsLessThanN (currentN, x, y) n = if currentN < n then nextTripleIfCurrentNIsLessThanN (currentN + 1, y, x + y) n else (currentN, x, y) thirdElementOfTriple :: (x,y,z) -> z thirdElementOfTriple (x,y,z) = z fibonacci :: Int -> Integer fibonacci n = thirdElementOfTriple (nextTripleIfCurrentNIsLessThanN (0,0,1) n)
fibonacci 0 1 fibonacci 1 1 fibonacci 2 2 fibonacci 3 3 fibonacci 4 5 fibonacci 5 8 fibonacci 5000 6276302800488957086035253108349684055478528702736457439025824448927937256811663264475883711527806250329984690249846819800648580083040107584710332687596562185073640422286799239932615797105974710857095487342820351307477141875012176874307156016229965832589137779724973854362777629878229505500260477136108363709090010421536915488632339240756987974122598603591920306874926755600361865354330444681915154695741851960071089944015319300128574107662757054790648152751366475529121877212785489665101733755898580317984402963873738187000120737824193162011399200547424034440836239726275765901190914513013217132050988064832024783370583789324109052449717186857327239783000020791777804503930439875068662687670678802914269784817022567088069496231111407908953313902398529655056082228598715882365779469902465675715699187225655878240668599547496218159297881601061923195562143932693324644219266564617042934227893371179832389642895285401263875342640468017378925921483580111278055044254198382265567395946431803304304326865077742925818757370691726168228648841319231470626
fibs :: [Integer] fibs = unfoldr (\(f,s) -> Just (f,(s,f+s))) (0,1)
f = (\(x:y:xs) -> (x+y):x:xs) -- notice, no y: put back only x+y & x
fib n = take n . map head $ iterate (\(x:y:xs) -> (x+y):x:xs) [0,1]
fib n = take n . map fst $ iterate (\(a,b) -> (b,a+b)) (0,1)
fib n = take n [ fst t | t <- iterate (\(a,b) -> (b,a+b)) (0,1)]
fibonaci = map fst (iterate f (0,1)) where f (x,y) = (y,x+y)
take 10 fibonaci [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377]
data Weird a = Weird a (a -> a) instance Foldable Weird where foldMap f (Weird a b) = f $ b a
foldr :: (a -> b -> b) -> b -> Set a -> b map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
instance Functor (Store f a) where fmap f (Store x g) = Store x (f . g) instance (F.Foldable f) => F.Foldable (Store f a) where foldr f z (Store x g) = F.foldr (f . g) z x
sequenceA :: Applicative f => (r -> (f a)) -> f (r -> a)
countWhere = (length .) . filter duplicate = (concat .) . replicate concatMap = (concat .) . map
infixr 9 . (.) :: (b -> c) -> (a -> b) -> a -> c f . g = \x -> f (g x)
main = interact (\x -> unlines (reverse (lines x)))
countWhere = length . filter -- this is not allowed
countWhere f xs = length (filter f xs) -- But `f x y` is `(f x) y`. Hence: countWhere f xs = length ((filter f) xs) -- But `\x -> f (g x)` is `f . g`. Hence: countWhere f = length . (filter f) -- But `f . g` is `(f .) g`. Hence: countWhere f = (length .) (filter f) -- But `\x -> f (g x)` is `f . g`. Hence: countWhere = (length .) . filter
f . g --> \x -> f (g x) (f .) . g --> \x y -> f (g x y) ((f .) .) . g --> \x y z -> f (g x y z) (((f .) .) .) . g --> \w x y z -> f (g w x y z)
f .: g = (f .) . g f .:: g = ((f .) .) . g f .::: g = (((f .) .) .) . g
f .: g = (f .) . g -- But `f . g` is `(.) f g`. Hence: f .: g = (.) (f .) g -- But `\x -> f x` is `f`. Hence: (f .:) = (.) (f .) -- But `(f .)` is `((.) f)`. Hence: (f .:) = (.) ((.) f) -- But `\x -> f (g x)` is `f . g`. Hence: (.:) = (.) . (.)
(.::) = (.) . (.) . (.) (.:::) = (.) . (.) . (.) . (.)
(.) .^ 1 = (.) (.) .^ 2 = (.:) (.) .^ 3 = (.::) (.) .^ 4 = (.:::)
mf a b c = filter a (map b c) mf a b c = filter a ((map b) c) mf a b = filter a . (map b) mf a b = (filter a .) (map b) mf a = (filter a .) . map mf a = (. map) (filter a .) mf a = (. map) ((filter a) .) mf a = (. map) ((.) (filter a)) mf a = ((. map) . (.)) (filter a) mf = ((. map) . (.)) . filter mf = (. map) . (.) . filter
compose f g = (. f) . (.) . g compose f g = ((. f) . (.)) . g compose f g = (.) ((. f) . (.)) g compose f = (.) ((. f) . (.)) compose f = (.) ((. (.)) (. f)) compose f = ((.) . (. (.))) (. f) compose f = ((.) . (. (.))) (flip (.) f) compose f = ((.) . (. (.))) ((flip (.)) f) compose = ((.) . (. (.))) . (flip (.))
countWhere p = ((length .) . filter) p = (length .) (filter p) = length . filter p
(.:) :: (r -> z) -> (a -> b -> r) -> a -> b -> z (f .: g) x y = f (g x y)
animatePowBoomWhenHearNoiseInMicrophone :: TimeDiff -> Sample -> IO () animatePowBoomWhenHearNoiseInMicrophone levelWeightedAverageHalfLife levelThreshord = ... programA :: IO () programA = animatePowBoomWhenHearNoiseInMicrophone 3 10000 programB :: IO () programB = animatePowBoomWhenHearNoiseInMicrophone 3 10000
sortBy :: (a -> a -> Ordering) -> [a] -> [a] myComparator :: Int -> (String -> String -> Ordering) myComparator n = \s1 s2 -> (s1 !! n) `compare` (s2 !! n) -- n is implicitly stored in the closure of the function we return foo = sortBy (myComparator 5) myList
data Widget = Widget { onMouseClick :: Int -> Int -> IO (), onKeyPress :: Key -> IO (), paint :: IO (), ... } constructMyWidget :: ... -> IO Widget constructMyWidget = do foo <- newIORef someFoo bar <- newIORef someBar return $ Widget { onMouseClick = \x y -> do ... do stuff with foo and bar ..., onKeyPress = \key -> do ..., paint = do ... }
-- the same record as before, we just gave it a different name data WidgetImpl = WidgetImpl { onMouseClick :: Int -> Int -> IO (), onKeyPress :: Key -> IO (), paint :: IO (), ... } class IsWidget a where widgetImpl :: a -> WidgetImpl data Widget = forall a. IsWidget a => Widget a sendClick :: Int -> Int -> Widget -> IO () sendClick x y (Widget a) = onMouseClick (widgetImpl a) x y data MyWidget = MyWidget { foo :: IORef Foo, bar :: IORef Bar } constructMyWidget :: ... -> IO MyWidget constructMyWidget = do foo_ <- newIORef someFoo bar_ <- newIORef someBar return $ MyWidget { foo = foo_, bar = bar_ } instance IsWidget MyWidget where widgetImpl myWidget = WidgetImpl { onMouseClick = \x y -> do ... do stuff with (foo myWidget) and (bar myWidget) ..., onKeyPress = \key -> do ..., paint = do ... }
class IsWidget a where onMouseClick :: Int -> Int -> a -> IO () onKeyPress :: Key -> a -> IO () paint :: a -> IO () ... instance IsWidget MyWidget where onMouseClick x y myWidget = ... do stuff with (foo myWidget) and (bar myWidget) ... onKeyPress key myWidget = ... paint myWidget = ... sendClick :: Int -> Int -> Widget -> IO () sendClick x y (Widget a) = onMouseClick x y a -- the rest is unchanged from above
class IsWidget a => IsWidgetExtra a where ...additional methods to implement...
data Animal = Dog {dogName :: String} | Cat {catName :: String} | Unicorn say :: Animal -> String say (Dog {dogName = name}) = "Woof Woof, my name is " ++ name say (Cat {catName = name}) = "Meow meow, my name is " ++ name say Unicorn = "Unicorns do not talk"
($) :: (a -> b) -> (a -> b) f $ x = f x -- or ($) f x = f x -- or ($) = id
forM_ [1..10] $ \i -> do l <- readLine replicateM_ i $ print l
forM_ [1..10] (\i -> do l <- readLine replicateM_ i (print l) )
applyArg :: a -> (a -> b) -> b applyArg x = ($ x) >>> map ($ 10) [(+1), (+2), (+3)] [11, 12, 13]
fnSig = undefined :: [Char] -> a fn | False = fnSig | True = (* 2) . length
fn = (2 *) . length where _ = fn `asTypeOf` (undefined :: [Char] -> a) _ = fn `asTypeOf` (undefined :: a -> Int) _ = fn `asTypeOf` (undefined :: a -> b) _ = fn `asTypeOf` (undefined :: a)
-- Your function, without type signature. fn = (2 *) . length -- The type signature, without actual definition. fnTy :: [Char] -> a fnTy = undefined -- If this type checks, then the type of -- with the type of fn_unifies_with_type :: () fn_unifies_with_type = let _ = fn `asTypeOf` fnTy in ()
fn = (2 *) . length where _ = fn `asTypeOf` (undefined :: [Char] -> a)
fn list = 2 * length list where a :: [Char] a = list `asTypeOf` a
fn list = 2 * fromIntegral (length list) where a :: [Char] a = list `asTypeOf` a
*Main> :t fn fn :: [Char] -> Int *Main> :r -- changed file reloaded *Main> :t fn fn :: (Num t) => [Char] -> t
fn2 list = r where r :: Int r = f list f = (2 *) . length
fnSig :: exists _1 _2. forall a. _1 a -> _2 fnSig = fn
{- fnSig :: (forall _1 _2. (forall a. _1 a -> _2) -- your actual type, _ ->r)->r fnSig = \k->k fn -- the compiler infers _1=[] , _2=Int -- fn :: [] a -> Int fn = (2 *) . length
{- data Ex where Ex :: (forall a. _1 a -> _2) -> Ex fnSig = Ex fn
data Trivial a = Cow instance Monad Trivial where _ >>= _ = Cow return _ = Cow
main :: [Response] -> [Request] main responses = [ AppendChan "stdout" "Please enter a Number\n", ReadChan "stdin", AppendChan "stdout" . show $ enteredNumber * 2 ] where (Str input) = responses !! 1 firstLine = head . lines $ input enteredNumber = read firstLine
import System.IO.Unsafe -- Since the Request and Response types no longer exist, we have to redefine -- them here ourselves. To support more I/O operations, we -- these types data Request = ReadChan String | AppendChan String String data Response = Success | Str String deriving Show -- Execute a request using the IO monad and return the corresponding Response. executeRequest :: Request -> IO Response executeRequest (AppendChan "stdout" message) = do putStr message return Success executeRequest (AppendChan chan _) = error ("Output channel " ++ chan ++ " not supported") executeRequest (ReadChan "stdin") = do input <- getContents return $ Str input executeRequest (ReadChan chan) = error ("Input channel " ++ chan ++ " not supported") -- Take an old style main function and turn it into an IO action executeOldStyleMain :: ([Response] -> [Request]) -> IO () executeOldStyleMain oldStyleMain = do -- I -- I don let responses = map (unsafePerformIO . executeRequest) . oldStyleMain $ responses -- Make sure that all responses are evaluated (so that the I/O actually takes -- place) and then return () foldr seq (return ()) responses
-- In an old-style Haskell application to double a number, this would be the -- main function doubleUserInput :: [Response] -> [Request] doubleUserInput responses = [ AppendChan "stdout" "Please enter a Number\n", ReadChan "stdin", AppendChan "stdout" . show $ enteredNumber * 2 ] where (Str input) = responses !! 1 firstLine = head . lines $ input enteredNumber = read firstLine main :: IO () main = executeOldStyleMain doubleUserInput
data Request = Readline | PutStrLn String data Response = Success | Str String type Dialog = [Response] -> [Request] execRequest :: Request -> IO Response execRequest Readline = getLine >>= \s -> return (Str s) execRequest (PutStrLn s) = putStrLn s >> return Success dialogToIOMonad :: Dialog -> IO () dialogToIOMonad dialog = let getFirstReq :: Dialog -> Request getFirstReq dialog = let (req:_) = dialog [] in req getTailReqs :: Dialog -> Response -> Dialog getTailReqs dialog resp = \resps -> let (_:reqs) = dialog (resp:resps) in reqs in do let req = getFirstReq dialog resp <- execRequest req dialogToIOMonad (getTailReqs dialog resp)
ghci> let lucky x = show (x + 1) ghci> :t lucky lucky :: (Num a) => a -> String
:{ lucky :: Int -> String lucky a = show(a) :} :type lucky lucky :: Int -> String
trigamma :: Double -> Double trigamma x = snd $ last $ take 7 $ iterate next (x where x p = 1 / x p c = foldr1 (\a b -> (a + b * p)) [1, 1/6, -1/30, 1/42, -1/30, 5/66] next (x, p) = (x - 1, 1 / x ^ 2 + p)
invSq x = 1 / (x * x) computeP x = (((((5/66*p-1/30)*p+1/42)*p-1/30)*p+1/6)*p+1)/x+0.5*p where p = invSq x trigamma_d :: Double -> Double trigamma_d x = go 0 (x + 5) $ computeP $ x + 6 where go :: Int -> Double -> Double -> Double go !i !x !p | i >= 6 = p | otherwise = go (i+1) (x-1) (1 / (x*x) + p) trigamma_y :: Double -> Double trigamma_y x = V.foldl
{- {- {- trigamma :: Double -> Double trigamma x = go 0 (x where x p = 1 / (x p *p-0.033333333333333)*p+0.166666666666667)*p+1)/x go :: Int -> Double -> Double -> Double go !i !x !p | i >= 6 = p | otherwise = go (i+1) (x-1) (1 / (x*x) + p)
readLog :: Config -> IO String readLog (C logFile) = readFile logFile writeLog :: Config -> String -> IO () writeLog (C logFile) message = do x <- readFile logFile writeFile logFile $ x ++ message getUserInput :: Config -> IO String getUserInput config = do input <- getLine writeLog config $ "Input: " ++ input return input runProgram :: Config -> IO () runProgram config = do input <- getUserInput config putStrLn $ "You wrote: " ++ input
type Program = ReaderT Config IO readLog :: Program String readLog = do C logFile <- ask readFile logFile writeLog :: String -> Program () writeLog message = do C logFile <- ask x <- readFile logFile writeFile logFile $ x ++ message
getUserInput :: Program String getUserInput = do input <- getLine writeLog $ "Input: " ++ input return input runProgram :: Program () runProgram = do input <- getUserInput putStrLn $ "You wrote: " ++ input
getUserInput :: (MonadReader Config m, MonadIO m) => m String runProgram :: (MonadReader Config m, MonadIO m) => m ()
data ProgramState = PS Int Int Int type Program a = StateT ProgramState (ReaderT Config IO) a
instance Monad (IOT Maybe) where return x = IOT (Just (return x)) IOT Nothing >>= _ = IOT Nothing IOT (Just m) >>= k = IOT $ error "what now?" where m
{- import qualified Data.Vector.Generic as G import qualified Data.Vector.Generic.Mutable as M import Control.Monad (liftM, zipWithM_) import Data.Vector.Unboxed.Base data Point3D = Point3D {- newtype instance MVector s Point3D = MV_Point3D (MVector s Int) newtype instance Vector Point3D = V_Point3D (Vector Int) instance Unbox Point3D
instance M.MVector MVector Point3D where basicLength (MV_Point3D v) = M.basicLength v `div` 3 basicUnsafeSlice a b (MV_Point3D v) = MV_Point3D $ M.basicUnsafeSlice (a*3) (b*3) v basicOverlaps (MV_Point3D v0) (MV_Point3D v1) = M.basicOverlaps v0 v1 basicUnsafeNew n = liftM MV_Point3D (M.basicUnsafeNew (3*n)) basicUnsafeRead (MV_Point3D v) n = do [a,b,c] <- mapM (M.basicUnsafeRead v) [3*n,3*n+1,3*n+2] return $ Point3D a b c basicUnsafeWrite (MV_Point3D v) n (Point3D a b c) = zipWithM_ (M.basicUnsafeWrite v) [3*n,3*n+1,3*n+2] [a,b,c] instance G.Vector Vector Point3D where basicUnsafeFreeze (MV_Point3D v) = liftM V_Point3D (G.basicUnsafeFreeze v) basicUnsafeThaw (V_Point3D v) = liftM MV_Point3D (G.basicUnsafeThaw v) basicLength (V_Point3D v) = G.basicLength v `div` 3 basicUnsafeSlice a b (V_Point3D v) = V_Point3D $ G.basicUnsafeSlice (a*3) (b*3) v basicUnsafeIndexM (V_Point3D v) n = do [a,b,c] <- mapM (G.basicUnsafeIndexM v) [3*n,3*n+1,3*n+2] return $ Point3D a b c
product a (Just b) = a * b product a Nothing = a * 2
def multiProduct (a, b=10, c=20, d=30): return a * b * c * d
multiProduct req1 opt1 opt2 opt3 = req1 * opt1 where opt1 where opt2 where opt3
{- module Optional where class Optional1 a b r where opt1 :: (a -> b) -> a -> r instance Optional1 a b b where opt1 = id instance Optional1 a b (a -> b) where opt1 = const class Optional2 a b c r where opt2 :: (a -> b -> c) -> a -> b -> r instance Optional2 a b c c where opt2 = id instance (Optional1 b c r) => Optional2 a b c (a -> r) where opt2 f _ b = \a -> opt1 (f a) b {- Optional3, Optional4, etc defined similarly -}
{- module Main where import Optional foo :: (Optional2 Int Char String r) => r foo = opt2 replicate 3 _5 :: Int _5 = 5 main = do putStrLn $ foo -- prints "fff" putStrLn $ foo _5 -- prints "fffff" putStrLn $ foo _5
( Just x Nothing -- basically fromMaybe, just want to be transparent multiProduct req1 opt1 opt2 opt3 = req1 * (opt1
{- import Data.Maybe (fromMaybe) def :: a -> Maybe a -> a def = fromMaybe multiProduct :: Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int multiProduct req1 (def 10 -> opt1) (def 20 -> opt2) (def 30 -> opt3) = req1 * opt1 * opt2 * opt3
multiProduct req1 opt1 opt2 opt3 = req1 * opt1 where opt1 opt2 opt3
$ runhaskell dog.hs Snoopy (Beagle): Ruff! Snoopy (Beagle): Ruff! Wishbone (Terrier): Ruff! Wishbone (Terrier): Ruff! Wishbone (Terrier): Ruff!
import Control.Monad (replicateM_) data Dog = Dog { name :: String, breed :: String, barks :: Int } defaultDog :: Dog defaultDog = Dog { name = "Dog", breed = "Beagle", barks = 2 } bark :: Dog -> IO () bark dog = replicateM_ (barks dog) $ putStrLn $ (name dog) ++ " (" ++ (breed dog) ++ "): Ruff!" main :: IO () main = do bark $ defaultDog { name = "Snoopy", barks = 2 } bark $ defaultDog { name = "Wishbone", breed = "Terrier", barks = 3 }
{- data Dog = Dog { _name :: String, _breed :: String, _barks :: Int } makeLenses defaultDog :: Dog defaultDog = Dog { _name = "Dog", _breed = "Beagle", _barks = 2 } bark :: (Dog -> Dog) -> IO () bark modDog = do let dog = modDog defaultDog replicateM_ (barks dog) $ putStrLn $ (name dog) ++ " (" ++ (breed dog) ++ "): Ruff!" main :: IO () main = do bark $ name .~ "Snoopy" . barks .~ 2 bark $ name .~ "Wishbone" . breed .~ "Terrier" . barks .~ 3
main = print . sum =<< getIntList getIntList :: IO [Int] getIntList = fmap (map read . words) getLine
(*) . (+) :: (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
(*) :: Num x => x -> x -> x (+) :: Num y => y -> y -> y (.) :: (b -> c) -> (a -> b) -> a -> c
(.) :: (b -> c) -> (a -> b) -> a -> c |______| |______| | | (*) (+)
(*) :: Num x => x -> x -> x -- remember that `x -> x -> x` | |____| -- is implicitly `x -> (x -> x)` | | b -> c (.) (*) :: (a -> b) -> a -> c | | | |‾‾‾‾| Num x => x x -> x (.) (*) :: Num x => (a -> x) -> a -> x -> x
(+) :: Num y => y -> y -> y -- remember that `y -> y -> y` | |____| -- is implicitly `y -> (y -> y)` | | Num x => a -> x (.) (*) (+) :: Num x => a -> x -> x | | | | |‾‾‾‾| |‾‾‾‾| Num y => y y -> y y -> y (.) (*) (+) :: (Num (y -> y), Num y) => y -> (y -> y) -> y -> y
( f . g ) = \z -> f ( g z) ((*) . (+)) = \z -> (*) ((+) z)
(.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> d f .: g = \x y -> f (g x y)
(*) . (+) :: (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
x f y (*) . (+) :: (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
weird :: (Num (a -> a), Num a) => a -> (a -> a) -> a -> a weird x g = (x +) * g
instance Enum DiffInt where toEnum n = (n +) fromEnum n = n 0 instance Num DiffInt where n + m = n . m n * m = foldr (+) id $ replicate (fromEnum n) m
{- weird :: (Num (a -> a), Num a) => a -> (a -> a) -> a -> a weird x g = (x +) * g instance (Enum a, Num a) => Enum (a -> a) where toEnum n = (toEnum n +) fromEnum n = fromEnum $ n (toEnum 0) instance (Enum a, Num a) => Num (a -> a) where n + m = n . m n * m = foldr (+) id $ replicate (fromEnum n) m type DiffInt = Int -> Int
-- difference ints over difference ints type DiffDiffInt = DiffInt -> DiffInt test test
((*) . (+)) 1 2 = (((*) . (+)) 1) 2 = ((*) ((+) 1)) 2 = ((+) 1) * 2,
minus :: Num n => n -> n -> n minus = (-) infixl 6 `minus`
type PrintOnlyIO = String main :: PrintOnlyIO main = "Hello world!"
type InteractIO = String -> String main :: InteractIO main = map toUpper
data Request = PutStrLn String | GetLine | Exit | ... data Response = Success | Str String | ... type DialogueIO = [Response] -> [Request] main :: DialogueIO main resps1 = PutStrLn "what : GetLine : case resps1 of Success : Str name : resps2 -> PutStrLn ("hi " ++ name ++ "!") : Exit
data ContIO = Exit | PutStrLn String ContIO | GetLine (String -> ContIO) | ... main :: ContIO main = PutStrLn "what GetLine $ \name -> PutStrLn ("hi " ++ name ++ "!") $ Exit
stepStream :: Stream a -> (a, Stream a) stepStream (Stream x xs) = (x, xs)
main k = print "What is your name? " $ getLine $ \ myName -> print ("Hello, " ++ myName ++ "\n") $ k ()
main w0 = let w1 = print "What is your name? " w0 (w2, myName) = getLine w1 w3 = print $ "Hello, " ++ myName ++ "!\n" in w3
main resps = [ PrintReq "What is your name? ", GetLineReq, PrintReq $ "Hello, " ++ myName ++ "!\n" ] where LineResp myName = resps !! 1
type Cont = [Response] -> [Request] print :: String -> Cont -> Cont print msg k resps = PrintReq msg : case resps of PrintResp () : resps1 -> k resps1 getLine :: (String -> Cont) -> Cont getLine k resps = GetLineReq : case resps of GetLineResp msg : resps1 -> k msg resps1
Prelude> :t (:) (:) :: a -> [a] -> [a] Prelude> :t (++) (++) :: [a] -> [a] -> [a]
import Control.Arrow import Data.List data LNode a = LNode { here :: a, prev :: LList a, next :: LList a } type LList a = Maybe (LNode a) toList :: LList a -> [a] toList = unfoldr $ fmap $ here &&& next fromList :: [a] -> LList a fromList l = head nodes where nodes = scanr ((.) Just . uncurry LNode) Nothing $ zip l $ Nothing : nodes append :: LList a -> LList a -> LList a append = join Nothing where join k (Just a) b = a a join k _ (Just b) = b b join _ _ _ = Nothing
type t = { a : t Lazy.t } let cycle n = let rec start = {a = lazy (aux n) } and aux = function | 0 -> start | n -> { a = lazy (aux (n-1))} in start
type let of_list l = match l with [] -> assert false | hd::tl -> let rec start = { data = hd; before = last; after = next } and couple = lazy (aux (lazy start) hd) and next = lazy (Lazy.force (fst (Lazy.force couple))) and last = lazy (Lazy.force (snd (Lazy.force couple))) and aux before = function | [] -> (lazy start), before | hd::tl -> let rec current = lazy { data = hd; before = before; after = after } and couple = lazy (aux current tl) and after = lazy (Lazy.force (fst (Lazy.force couple))) and last = lazy (Lazy.force (snd (Lazy.force couple))) in current, last in start
ghc --make HelloZ.hs \ -optl-Wl,--whole-archive \ -optl/usr/lib/x86_64-linux-gnu/libffi.a \ -optl/usr/lib/x86_64-linux-gnu/libz.a \ -optl-Wl,--no-whole-archive
Prelude> :m Data.List Control.Applicative Prelude Data.List Control.Applicative> :m Prelude>
Prelude> import Numeric Prelude Numeric> :m -Numeric Prelude> :m +Numeric Prelude Numeric>
data ExecutionAST result where Return :: result -> ExecutionAST result Bind :: (ExecutionAST oldres) -> (oldres -> ExecutionAST result) -> ExecutionAST result WriteRegister :: M_Register -> Word8 -> ExecutionAST () ReadRegister :: M_Register -> ExecutionAST Word8 WriteRegister2 :: M_Register2 -> Word16 -> ExecutionAST () ReadRegister2 :: M_Register2 -> ExecutionAST Word16 WriteMemory :: Word16 -> Word8 -> ExecutionAST () ReadMemory :: Word16 -> ExecutionAST Word8
data E a where A :: a -> E a B :: Integer -> E a C :: Bool -> E Bool
data ExecutionAST result = Return result | WriteRegister M_Register Word8 | ReadRegister M_Register | ReadMemory Word16 | WriteMemory Word16 | ...
x :: M_Register2 x = ... a = Bind (ReadMemory 1) (WriteRegister2 x)
data ExecutionAST result = ... | Bind (ExecutionAST oldres) (oldres -> ExecutionAST result)
data ExecutionAST result = ... | forall oldres. Bind (ExecutionAST oldres) (oldres -> ExecutionAST result)
addM :: (Monad m, Num a) => m a -> m a -> m a addM ma mb = do a <- ma b <- mb return (a + b)
addM ma mb = ma >>= \a -> mb >>= \b -> return (a + b)
instance Monad Identity where return a = Identity a -- create an Identity value (Identity a) >>= f = f a -- apply f to a
(Identity 1) >>= (\a -> (Identity 2) >>= (\b -> return (a + b))) (\a -> (Identity 2) >>= (\b -> return (a + b)) 1 (Identity 2) >>= (\b -> return (1 + b)) (\b -> return (1 + b)) 2 return (1 + 2) Identity 3
instance Monad Maybe where return a = Just a -- same as Identity monad! (Just a) >>= f = f a -- same as Identity monad again! Nothing >>= _ = Nothing -- the only real difference from Identity
Nothing >>= (\a -> (Just 1) >>= (\b -> return (a + b))) Nothing
(Just 1) >>= (\a -> Nothing >>= (\b -> return (a + b))) (\a -> Nothing >>= (\b -> return (a + b)) 1 Nothing >>= (\b -> return (1 + b)) Nothing
fireTheMissiles :: IO Int -- returns the number of casualties
fireTheMissilesTwice :: IO () fireTheMissilesTwice = do a <- fireTheMissiles print a b <- fireTheMissiles print b
fg x = f x >>= g xs >>= f = concatMap f xs return x = [x]
fg x = f x >>= g x >>= f = \rw -> let (y, rw (r, rw in (r, rw return x = \rw -> (x, rw)
instance M Monad where ... -- Modify the counter and do not produce any result: incrementCounter :: M () decrementCounter :: M () -- Get the current value of the counter readCounter :: M Integer
{ counter++; counter++; } if (condition) { counter++; counter++; }
-- We don module Prompt (Prompt(), echo, prompt) where -- Opaque data Prompt a = ... instance Monad Prompt where ... -- Display a line to the CLI: echo :: String -> Prompt () -- Ask a question to the user: prompt :: String -> Prompt String
-- Incomplete version, some bits are missing: promptBoolean :: String -> M Boolean promptBoolean message = prompt (message ++ "[y/n]") >>= f where f result = if result == "y" then ???? -- We need here an action which does nothing but produce `True` as output else if result=="n" then ???? -- We need here an action which does nothing but produce `False` as output else echo "Input not recognised, try again." >> promptBoolean
-- "return 5" is an action which does nothing but outputs 5 return :: (Monad m) => a -> m a
promptBoolean :: String -> Prompt Boolean promptBoolean message :: prompt (message ++ "[y/n]") >>= f where f result = if result=="y" then return True else if result=="n" then return False else echo "Input not recognised, try again." >> promptBoolean message
promptInt :: String -> M Int promptInt = ... -- similar -- Classic "guess a number game/dialogue" guess :: Int -> m() guess n = promptInt "Guess:" m -> f where f m = if m == n then echo "Found" else (if m > n then echo "Too big" then echo "Too small") >> guess n
(>>): Monad m => m a -> m b -> m b a >> b = a >>= f where f x = b
class Monad m where return :: m a (>>=) :: m a -> (a -> m b) -> m b (>>) :: m a -> m b -> m b -- can be derives from (>>=) fail :: String -> m a -- mostly a hack
-- while x y : does action y while action x output True while :: (Monad m) => m Boolean -> m a -> m () while x y = x >>= f where f True = y >> while x y f False = return ()
-- Sample an Int from some distribution action :: Rand Int
-- Estimate mean by sampling nsamples times the random variable x sampleMean :: Real a => Int -> m a -> m a sampleMean n x = ...
l = [] for x in [4,5]: for y in [0,1]: l.append(x+y)
flags: {} packages: - extra-deps: - hakyll-4.7.1.0 resolver: lts-2.15
type IsBijection (f :: a -> b) (g :: b -> a) = forall x. Equal (f (g x)) (g (f x))
{- module Equality where -- Peano arithmetic. -- -- ℕ-formation: ℕ is set. -- -- ℕ-introduction: o ∈ ℕ, -- a ∈ ℕ | (1 + a) ∈ ℕ. -- data ℕ : Set where o : ℕ 1+ : ℕ → ℕ -- Axiom for _+_. -- -- Form of ℕ-elimination. -- infixl 6 _+_ _+_ : ℕ → ℕ → ℕ o + m = m 1+ n + m = 1+ (n + m) -- The identity type for ℕ. -- infix 4 _≡_ data _≡_ (m : ℕ) : ℕ → Set where refl : m ≡ m -- Usefull property. -- cong : {m n : ℕ} → m ≡ n → 1+ m ≡ 1+ n cong refl = refl -- Proof _of_ mathematical induction: -- -- P 0, ∀ x. P x → P (1 + x) | ∀ x. P x. -- ind : (P : ℕ → Set) → P o → (∀ n → P n → P (1+ n)) → ∀ n → P n ind P P₀ _ o = P₀ ind P P₀ next (1+ n) = next n (ind P P₀ next n) -- Associativity of addition using mathematical induction. -- +-associative : (m n p : ℕ) → (m + n) + p ≡ m + (n + p) +-associative m n p = ind P P₀ is m where P : ℕ → Set P i = (i + n) + p ≡ i + (n + p) P₀ : P o P₀ = refl is : ∀ i → P i → P (1+ i) is i Pi = cong Pi -- Associativity of addition using (dependent) pattern matching. -- +-associative′ : (m n p : ℕ) → (m + n) + p ≡ m + (n + p) +-associative′ o _ _ = refl +-associative′ (1+ m) n p = cong (+-associative′ m n p)
Windows could not stop the Test service on Local Computer. Error 1061: The service cannot accept control messages at this time.
module Main where import Control.Applicative import Foreign import System.Win32 wIN32_OWN_PROCESS :: DWORD wIN32_OWN_PROCESS = 0x00000010 sTART_PENDING, rUNNING :: DWORD sTART_PENDING = 0x00000002 rUNNING = 0x00000004 aCCEPT_STOP, aCCEPT_NONE :: DWORD aCCEPT_STOP = 0x00000001 aCCEPT_NONE = 0x00000000 nO_ERROR :: DWORD nO_ERROR = 0x00000000 type HANDLER_FUNCTION = DWORD -> IO () type MAIN_FUNCTION = DWORD -> Ptr LPTSTR -> IO ()
data TABLE_ENTRY = TABLE_ENTRY LPTSTR (FunPtr MAIN_FUNCTION) instance Storable TABLE_ENTRY where sizeOf _ = 8 alignment _ = 4 peek ptr = TABLE_ENTRY <$> peek (castPtr ptr) <*> peek (castPtr ptr `plusPtr` 4) poke ptr (TABLE_ENTRY name proc) = do poke (castPtr ptr) name poke (castPtr ptr `plusPtr` 4) proc data STATUS = STATUS DWORD DWORD DWORD DWORD DWORD DWORD DWORD instance Storable STATUS where sizeOf _ = 28 alignment _ = 4 peek ptr = STATUS <$> peek (castPtr ptr) <*> peek (castPtr ptr `plusPtr` 4) <*> peek (castPtr ptr `plusPtr` 8) <*> peek (castPtr ptr `plusPtr` 12) <*> peek (castPtr ptr `plusPtr` 16) <*> peek (castPtr ptr `plusPtr` 20) <*> peek (castPtr ptr `plusPtr` 24) poke ptr (STATUS a b c d e f g) = do poke (castPtr ptr) a poke (castPtr ptr `plusPtr` 4) b poke (castPtr ptr `plusPtr` 8) c poke (castPtr ptr `plusPtr` 12) d poke (castPtr ptr `plusPtr` 16) e poke (castPtr ptr `plusPtr` 20) f poke (castPtr ptr `plusPtr` 24) g
foreign import stdcall "wrapper" smfToFunPtr :: MAIN_FUNCTION -> IO (FunPtr MAIN_FUNCTION) foreign import stdcall "wrapper" handlerToFunPtr :: HANDLER_FUNCTION -> IO (FunPtr HANDLER_FUNCTION) foreign import stdcall "windows.h RegisterServiceCtrlHandlerW" c_RegisterServiceCtrlHandler :: LPCTSTR -> FunPtr HANDLER_FUNCTION -> IO HANDLE foreign import stdcall "windows.h SetServiceStatus" c_SetServiceStatus :: HANDLE -> Ptr STATUS -> IO BOOL foreign import stdcall "windows.h StartServiceCtrlDispatcherW" c_StartServiceCtrlDispatcher :: Ptr TABLE_ENTRY -> IO BOOL
main :: IO () main = withTString "Test" $ \name -> smfToFunPtr svcMain >>= \fpMain -> withArray [TABLE_ENTRY name fpMain, TABLE_ENTRY nullPtr nullFunPtr] $ \ste -> c_StartServiceCtrlDispatcher ste >> return () svcMain :: MAIN_FUNCTION svcMain argc argv = do appendFile "c:\\log.txt" "svcMain: svcMain here!\n" args <- peekArray (fromIntegral argc) argv fpHandler <- handlerToFunPtr svcHandler h <- c_RegisterServiceCtrlHandler (head args) fpHandler _ <- setServiceStatus h running appendFile "c:\\log.txt" "svcMain: exiting\n" svcHandler :: DWORD -> IO () svcHandler _ = appendFile "c:\\log.txt" "svcCtrlHandler: received.\n" setServiceStatus :: HANDLE -> STATUS -> IO BOOL setServiceStatus h status = with status $ c_SetServiceStatus h running :: STATUS running = STATUS wIN32_OWN_PROCESS rUNNING aCCEPT_STOP nO_ERROR 0 0 3000
C:\path>ghc -threaded --make Main.hs [1 of 1] Compiling Main ( Main.hs, Main.o ) Linking Main.exe ... C:\path>
C:\Path>sc query Test SERVICE_NAME: Test TYPE : 10 WIN32_OWN_PROCESS STATE : 4 RUNNING (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 C:\Path>
C:\Path>sc query Test SERVICE_NAME: Test TYPE : 10 WIN32_OWN_PROCESS STATE : 1 STOPPED WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 C:\Path>
import Text.Printf import System.Win32 foreign import stdcall "windows.h GetLastError" c_GetLastError :: IO DWORD ... d <- c_GetLastError appendFile "c:\\log.txt" (Text.Printf.printf "%d\n" (fromEnum d))
fpHandler <- handlerToFunPtr svcHandler h <- c_RegisterServiceCtrlHandler (head args) fpHandler _ <- setServiceStatus h running
t <- newTString "Foo" h <- c_RegisterServiceCtrlHandler t fpHandler
map (subtract 1) [2,4,8,16] = [1,3,7,15] -- Int->Int [Int] [Int]
fmap (* 10) [2,4,8,16] = [20,40,80,160] -- Int->Int [Int] [Int]
fmap (+7) (Just 10) = Just 17 fmap (+7) Nothing = Nothing -- Int->Int Maybe Int Maybe Int
fmap length Nothing = Nothing fmap length (Just [5.0, 4.0, 3.0, 2.0, 1.573458]) = Just 5 -- [Double]->Int Maybe [Double] Maybe Int
fmap show (Just 12) = Just "12" fmap show Nothing = Nothing -- Int->String Maybe Int Maybe String
fmap show [3,4,5] = ["3", "4", "5"] -- Int->String [Int] [String]
fmap (5*) (Left "hi") = Left "hi" fmap (5*) (Right 4) = Right 20 -- Int->Int Either String Int Either String Int
fmap (++ ", cool!") (Left 4) = Left 4 fmap (++ ", cool!") (Right "fmap edits values") = Right "fmap edits values, cool!" -- String->String Either Int String Either Int String
echo1 :: IO () echo1 = do putStrLn "Say something!" whattheysaid <- getLine -- getLine :: IO String putStrLn whattheysaid -- putStrLn :: String -> IO ()
echo2 :: IO () echo2 = putStrLn "Say something" >> getLine >>= putStrLn
greet1 :: IO () greet1 = do putStrLn "What name <- getLine putStrLn ("Hello, " ++ name)
greet2 :: IO () greet2 = putStrLn "What >> getLine >>= (\name -> putStrLn ("Hello, " ++ name))
fmap ("Hello, " ++) getLine = -- read a line, return "Hello, " in front of it -- String->String IO String IO String
greet3 :: IO () greet3 = putStrLn "What >> fmap ("Hello, "++) getLine >>= putStrLn
fmap not readLn = -- read a line that has a Bool on it, change it -- Bool->Bool IO Bool IO Bool
fmap length (readFile "test.txt") = -- read the file, return its length -- String->Int IO String IO Int -- [a]->Int IO [Char] IO Int (more precisely)
fmap :: Functor something => (a -> b) -> something a -> something b
fmap id == id -- identity identity fmap (f . g) == fmap f . fmap g -- composition
> fmap (+1) (Just 3) Just 4 > fmap length (Data.Map.fromList [(1, "hi"), (2, "there")]) fromList [(1,2),(2,5)]
Prelude> :i Functor class Functor f where fmap :: (a -> b) -> f a -> f b
$ cabal configure --enable-executable-profiling ... $ cabal build ... Could not find module Perhaps you havent installed the profiling libraries for package ... $ $ cabal install -p GLUT --reinstall ... Could not find module Perhaps you havent installed the profiling libraries for package ...
$ cabal install -p OpenGLRaw --reinstall $ cabal install -p StateVar --reinstall $ cabal install -p Tensor --reinstall $ cabal install -p ObjectName --reinstall $ cabal install -p GLURaw --reinstall $ cabal install -p OpenGL --reinstall $ cabal install -p GLUT --reinstall
class Differentiable f where type D f :: * -> * newtype K a x = K a newtype I x = I x data (f :+: g) x = L (f x) | R (g x) data (f :*: g) x = f x :&: g x instance Differentiable (K a) where type D (K a) = K Void instance Differentiable I where type D I = K () instance (Differentiable f, Differentiable g) => Differentiable (f :+: g) where type D (f :+: g) = D f :+: D g instance (Differentiable f, Differentiable g) => Differentiable (f :*: g) where type D (f :*: g) = (D f :*: g) :+: (f :*: D g)
class Differentiable f where type D f instance Differentiable (D f)
class SortContainer c where type WhatsIn c instance Ord (WhatsIn c) ...
class Ord w => SortContainer c w | c -> w where ...
class (Differentiable (D f)) => Differentiable (f :: * -> *) where
ConstrainTF.hs:17:1: Cycle in class declaration (via superclasses): Differentiable -> Differentiable In the class declaration for `Differentiable'
import GHC.Prim type family DiffConstraint (f :: * -> *) :: Constraint type instance DiffConstraint f = Differentiable f class (DiffConstraint (D f)) => Differentiable (f :: * -> *) where type D f :: * -> *
instance Differentiable (K a) where type D (K a) = K Void instance Differentiable I where type D I = K ()
ConstrainTF.hs:29:10: No instance for (Differentiable []) arising from the superclasses of an instance declaration Possible fix: add an instance declaration for (Differentiable []) In the instance declaration for `Differentiable I'
instance (Differentiable f, Differentiable g) => Differentiable (f :+: g) where type D (f :+: g) = D f :+: D g
type family DiffConstraint (f :: * -> *) :: Constraint type instance DiffConstraint (K a) = Differentiable (K a) type instance DiffConstraint I = Differentiable I type instance DiffConstraint (f :+: g) = (Differentiable f, Differentiable g)
instance (Differentiable (D f), Differentiable (D g)) => Differentiable (f :+: g) where type D (f :+: g) = D f :+: D g
import Data.Constraint class Differentiable (f :: * -> *) where type D f :: * -> * witness :: p f -> Dict (Differentiable (D f))
class Differentiable (D f) => Differentiable (f :: Type -> Type) where
withDict :: Dict c -> (c => x) -> x withDict Dict x = x withDict2 :: Dict a -> Dict b -> ((a, b) => x) -> x withDict2 Dict Dict x = x
class Differentiable f where type D f :: * -> * d2 :: p f -> Dict (Differentiable (D f)) -- This is just something to recover from the dictionary make :: a -> f a
d :: Dict (Differentiable t) -> Dict (Differentiable (D t)) d d1 = withDict d1 (d2 (pt (d1))) where pt :: Dict (Differentiable t) -> Proxy t pt = const Proxy
data K x = K deriving (Show) newtype I x = I x deriving (Show) data (f :+: g) x = L (f x) | R (g x) deriving (Show) data (f :*: g) x = f x :&: g x deriving (Show)
instance Differentiable K where type D K = K make = const K d2 = const Dict instance Differentiable I where type D I = K make = I d2 = const Dict
instance (Differentiable f, Differentiable g) => Differentiable (f :+: g) where type D (f :+: g) = D f :+: D g make = R . make d2 p = withDict2 df dg $ Dict where df = d2 . pf $ p dg = d2 . pg $ p pf :: p (f :+: g) -> Proxy f pf = const Proxy pg :: p (f :+: g) -> Proxy g pg = const Proxy instance (Differentiable f, Differentiable g) => Differentiable (f :*: g) where type D (f :*: g) = (D f :*: g) :+: (f :*: D g) make x = make x :&: make x d2 p = withDict2 df dg $ Dict where df = d2 . pf $ p dg = d2 . pg $ p pf :: p (f :*: g) -> Proxy f pf = const Proxy pg :: p (f :*: g) -> Proxy g pg = const Proxy
make1 :: Differentiable f => p f -> a -> D f a make1 p = withDict (d2 p) make make2 :: Differentiable f => p f -> a -> D (D f) a make2 p = withDict (d (d2 p)) make
data Ratio n = Ratio Double 1.234 :: Ratio D3 data Ask ccy = Ask Double Ask 1.5123 :: Ask GBP
{- newtype Distance a = Distance Double deriving (Num, Show) data Kilometer data Mile marathonDistance :: Distance Kilometer marathonDistance = Distance 42.195 distanceKmToMiles :: Distance Kilometer -> Distance Mile distanceKmToMiles (Distance km) = Distance (0.621371 * km) marathonDistanceInMiles :: Distance Mile marathonDistanceInMiles = distanceKmToMiles marathonDistance
>>> marathonDistanceInMiles Distance 26.218749345 >>> marathonDistanceInMiles + marathonDistance <interactive>:10:27: Couldn Expected type: Distance Mile Actual type: Distance Kilometer In the second argument of ‘(+)’, namely ‘marathonDistance’ In the expression: marathonDistanceInMiles + marathonDistance
{- {- {- data LengthUnit = Kilometer | Mile newtype Distance (a :: LengthUnit) = Distance Double deriving (Num, Show) marathonDistance :: Distance marathonDistance = Distance 42.195 distanceKmToMiles :: Distance distanceKmToMiles (Distance km) = Distance (0.621371 * km) marathonDistanceInMiles :: Distance marathonDistanceInMiles = distanceKmToMiles marathonDistance
>>> marathonDistanceInMiles Distance 26.218749345 >>> marathonDistance + marathonDistance Distance 84.39 >>> marathonDistanceInMiles + marathonDistance <interactive>:28:27: Couldn Expected type: Distance Actual type: Distance In the second argument of ‘(+)’, namely ‘marathonDistance’ In the expression: marathonDistanceInMiles + marathonDistance
data Distance = Distance { distanceUnit :: LengthUnit, distanceValue :: Double } deriving (Show)
{- {- {- {- {- data Kilometer data Mile data Distance a where KilometerDistance :: Double -> Distance Kilometer MileDistance :: Double -> Distance Mile deriving instance Show (Distance a) marathonDistance :: Distance Kilometer marathonDistance = KilometerDistance 42.195 distanceKmToMiles :: Distance Kilometer -> Distance Mile distanceKmToMiles (KilometerDistance km) = MileDistance (0.621371 * km) marathonDistanceInMiles :: Distance Mile marathonDistanceInMiles = distanceKmToMiles marathonDistance
>>> marathonDistanceInMiles MileDistance 26.218749345
{- data Expr a where Number :: Int -> Expr Int Boolean :: Bool -> Expr Bool Increment :: Expr Int -> Expr Int Not :: Expr Bool -> Expr Bool
Nil :: List a Cons :: a -> List a -> List a |____| | -- return type is generalized
data Expr a = Number Int | Boolean Bool | Increment (Expr Int) | Not (Expr Bool)
Number :: Int -> Expr a Boolean :: Bool -> Expr a Increment :: Expr Int -> Expr a Not :: Expr Bool -> Expr a
Increment (Boolean False) -- you shouldn Not (Number 0) -- you shouldn
number :: Int -> Expr Int boolean :: Bool -> Expr Bool increment :: Expr Int -> Expr Int not :: Expr Bool -> Expr Bool number = Number boolean = Boolean increment = Increment not = Not
increment (boolean False) -- error not (number 0) -- error
data Either a b = Left a | Right b Left :: a -> Either a b Right :: b -> Either a b
instance Functor Wrap where fmap f (Wrap x) = Wrap (f x) instance Applicative Wrap where pure = Wrap Wrap f <*> Wrap x = Wrap (f x)
import Control.Applicative -- Otherwise you can import Control.Monad (liftM, ap) instance Functor ??? where fmap = liftM instance Applicative ??? where pure = return (<*>) = ap
> instance Applicative Wrapped where > pure = return > (<*>) = ap
import Control.Monad import Control.Monad.ST import Data.STRef data STRefPair s a b = STRefPair { left :: STRef s a, right :: STRef s b } mkStRefPair :: a -> b -> ST s (STRefPair s a b) mkStRefPair a b = do a b return $ STRefPair a derp :: (Num a, Num b) => STRefPair s a b -> ST s () derp p = do modifySTRef (left p) (\x -> x + 1) modifySTRef (right p) (\x -> x - 1) herp :: (Num a, Num b) => (a, b) herp = runST $ do p <- mkStRefPair 0 0 replicateM_ 10 $ derp p a <- readSTRef $ left p b <- readSTRef $ right p return (a, b) main = print herp -- should print (10, -10)
isTautology (\x -> x && not x) isTautology (\x y -> x && y || not y)
-- A Bool is a tautology if it instance Stmt Bool where tautology = id
-- A function is a tautology if it always returns a tautology. instance Stmt b => Stmt (Bool -> b) where tautology f = tautology (f True) && tautology (f False)
instance (Enum a, Bounded a, Stmt b) => Stmt (a -> b) where tautology f = all (tautology . f) [minBound .. maxBound]
> tautology $ \x y -> (not x && not y) == not (x && y) False > tautology $ \x y -> (not x && not y) == not (x || y) True
ld: pointer in read-only segment not allowed in slidable image, used in ___gmpn_modexact_1c_odd
Library not loaded: /usr/local/lib/ghc-7.0.4/base-4.3.1.0/libHSbase-4.3.1.0-ghc7.0.4.dylib
ghc -O2 --make \ -no-hs-main -optl -o libTest.so Test.hs module_init.c
extern void CAT(__stginit_, MODULE)(void); static void library_init(void) __attribute__((constructor)); static void library_init(void) { static char *argv[] = { STR(MODULE) ".so", 0 }, **argv_ = argv; static int argc = 1; hs_init(&argc, &argv_); hs_add_root(CAT(__stginit_, MODULE)); } static void library_exit(void) __attribute__((destructor)); static void library_exit(void) { hs_exit(); }
name: MyApp version: 0.1.0.0 synopsis: homepage: author: simon.bourne category: build-type: Simple cabal-version: >=1.10 library exposed-modules: HelloWorld build-depends: base >= 4.7 && < 5 hs-source-dirs: src default-language: Haskell2010 executable MyApp main-is: Main.hs extra-lib-dirs: lib extra-libraries: helloWorld build-depends: base >= 4.7 && < 5, MyApp hs-source-dirs: app default-language: Haskell2010
foreign import ccall safe "helloWorld" c_helloWorld :: IO ()
extern "C" __declspec(dllexport) int __cdecl addFive(int number); extern "C" __declspec(dllexport) int __cdecl addFive(int number) { return number + 5; }
foreign import ccall "addFive" addFive :: Int -> Int
ghc -c Adder.hs ghc -c StartEnd.c ghc -shared -o Adder.dll Adder.o Adder_stub.o StartEnd.o
class Ord a where compare :: a -> a -> Ordering sort :: Ord a => [a] -> [a] sort = undefined
prop_preservesLength l = (length l) == (length $ sort l) ...
> :set -Rank2Types > :t id :: (forall b. b) -> (forall b. b) {- no complaint, but very chatty -}
{- module Main where import Data.Int import Data.Maybe (fromJust) import qualified Data.Vector as Vector import qualified Data.HashMap.Strict as HashMap import Network -- Thrift libraries import Thrift.Server -- Generated Thrift modules import Performance_Types import ItemStore_Iface import ItemStore i32toi :: Int32 -> Int i32toi = fromIntegral itoi32 :: Int -> Int32 itoi32 = fromIntegral port :: PortNumber port = 9090 data ItemHandler = ItemHandler instance ItemStore_Iface ItemHandler where ping _ = return () --putStrLn "ping" getItems _ mtname mtsize = do let size = i32toi $ fromJust mtsize item i = Item mtname (Just $ Vector.fromList $ map itoi32 [i..100]) items = map item [0..(size-1)] itemsv = Vector.fromList items mappers = zip (map itoi32 [0..(size-1)]) items mappersh = HashMap.fromList mappers itemPack = ItemPack (Just itemsv) (Just mappersh) putStrLn "getItems" return itemPack setItems _ _ = do putStrLn "setItems" return True getVector _ mtsize = do putStrLn "getVector" let size = i32toi $ fromJust mtsize return $ Vector.generate size itoi32 main :: IO () main = do _ <- runBasicServer ItemHandler process port putStrLn "Server stopped"
{- module Foo where import Foreign.C.String import Foreign.C.Types foreign export ccall foo :: CString -> IO CInt foo :: CString -> IO CInt foo c_str = do str <- peekCString c_str result <- hs_foo str return $ fromIntegral result hs_foo :: String -> IO Int hs_foo str = do putStrLn $ "Hello, " ++ str return (length str + 42)
Back-end Front-end Low-level C C++ High-level FP VB, C#
interface IStack<T> extends Iterable<T> { IStack<T> Push(T value); IStack<T> Pop(); T Peek(); boolean IsEmpty(); } final class EmptyStack<T> implements IStack<T> { public boolean IsEmpty() { return true; } public IStack<T> Push(T value) { return Stack.cons(value, this); } public IStack<T> Pop() { throw new Error("Empty Stack"); } public T Peek() { throw new Error("Empty Stack"); } public java.util.Iterator<T> iterator() { return new java.util.Iterator<T>() { public boolean hasNext() { return false; } public T next() { return null; } public void remove() { } }; } } final class Stack<T> implements IStack<T> { public static <T> IStack<T> cons(T hd, IStack<T> tl) { return new Stack<T>(hd, tl); } public static <T> IStack<T> append(IStack<T> x, IStack<T> y) { return x.IsEmpty() ? y : new Stack(x.Peek(), append(x.Pop(), y)); } private final T hd; private final IStack<T> tl; private Stack(T hd, IStack<T> tl) { this.hd = hd; this.tl = tl; } public IStack<T> Push(T value) { return new <T> Stack(value, this); } public IStack<T> Pop() { return this.tl; } public T Peek() { return this.hd; } public boolean IsEmpty() { return false; } public java.util.Iterator<T> iterator() { final IStack<T> outer = this; return new java.util.Iterator<T>() { private IStack<T> current = outer; public boolean hasNext() { return !current.IsEmpty(); } public T next() { T hd = current.Peek(); current = current.Pop(); return hd; } public void remove() { } }; } } public class Main { public static void main(String[] args) { IStack<Integer> x = Stack.cons(1, Stack.cons(2, Stack.cons(3, Stack.cons(4, new EmptyStack())))); IStack<Integer> y = Stack.cons(5, Stack.cons(6, Stack.cons(7, Stack.cons(8, new EmptyStack())))); IStack<Integer> z = Stack.append(x, y); for (Integer num : z) { System.out.printf("%s ", num); } } }
Prelude Control.Monad> :t join join :: Monad m => m (m a) -> m a
data Foo = Foo { fooID :: Int, fooName :: String } deriving (Show)
data Foo = Foo id :: Int name :: String deriving (Show)
λ> flap ^. donald *Flap flap flap* λ> flap ^. chris I fly :: (Has Flap duck) => duck -> IO () fly duck = do go; go; go where go = flap ^. duck λ> fly donald *Flap flap flap* *Flap flap flap* *Flap flap flap*
data Person = Person { id :: Int, name :: String } data Company { name :: String, employees :: [Person] } companyNames :: Company -> [String] companyNames c = name c : map name (employees c)
--record data Foo = Foo {i :: Int, s :: String} deriving (Show) --non-record data Foo = Foo Int String deriving (Show) --new-record data Foo = Foo i :: Int, s :: String deriving (Show) --record data LotsaInts = LI {a,b,c,i,j,k :: Int} --new-record data LostaInts = LI a,b,c,i,j,k :: Int
let f1 = Foo {s = "foo1", i = 1} let f2 = f1 {s = "foo2"} let f1 = Foo s = "foo1", i = "foo2" let f2 = f1 s = "foo2"
import Prelude hiding (id) data Foo = Foo {a,b,c,i,j,k :: Int, s :: String} deriving (Show) id = i
ghci> :l data.hs ghci> let foo = Foo 1 2 3 4 5 6 "foo" ghci> id foo 4 ghci> Prelude.id f1 Foo {a = 1, b = 2, c = 3, i = 4, j = 5, k = 6, s = "foo"}
import qualified Data.MemoCombinators as Memo fib = Memo.integral fib' where fib fib fib
import Data.MemoCombinators.Class (memoize) fib = memoize fib' where fib ...
type Key = Int type Value = Int dynamic :: (Table Value Key -> Key -> Value) -> Key -> Table Value Key dynamic compute bnd = t where t = newTable (map (\coord -> (coord, compute t coord)) [0..bnd])
fib = findTable (dynamic helper n) n where helper t i = if i <= 1 then i else findTable t (i-1) + findTable t (i-2)
newTable :: [(k,v)] -> Table v k findTable :: Table v k -> k -> v
t = newTable (map (\coord -> (coord, compute t coord)) [0..bnd])
o | |--0--> 1 | |--1--> 1 | |--2--> 2 | |--3--> 2 . . .
helper t i = if i <= 1 then i else findTable t (i-1) + findTable t (i-2) o | |--0--> 1 . . .
import Data.Array.IArray answer :: String -> Int answer s = table ! (1, l) where l = length s --signatyres are needed, because GHC doesn --string is stored in Array because we need quick access to individual chars a :: Array Int Char a = listArray (1, l) s table :: Array (Int, Int) Int table = listArray ((1, 1), (l, l)) [f i j | i <- [1..l], j <- [1..l]] f i j | i > j = 0 | i == j = 1 | (a ! i) == (a ! j) = 2 + table ! (i+1, j-1) | otherwise = maximum [table ! (i+1, j), table ! (i, j-1)]
class MonadPlus m where mzero :: m a mplus :: m a -> m a -> m a
mzero `mplus` m = m m `mplus` mzero = m (m1 `mplus` m2) `mplus` m3 = m1 `mplus` (m2 `mplus` m3)
class Monoid a where mempty :: a mappend :: a -> a -> a mempty `mplus` a = a a `mplus` mempty = a (a1 `mplus` a2) `mplus` a3 = a1 `mplus` (a2 `mplus` a3)
data Compose t1 t2 m r = C (t1 (t2 m) r) instance (MonadTrans t1, MonadTrans t2) => MonadTrans (Compose t1 t2) where lift = C . lift . lift
class (forall m . Monad m => Monad (t m)) => MonadTrans t where lift :: (Monad m) => m r -> t m r
class SomeClass someHigherKindedTypeConstructor where ...
class (SomeConstraint (someHigherKindedTypeConstructor a b c)) => SomeClass someHigherKindedTypeConstructor where ...
<functions-definition> ::= <functions> :: <quantified-type-expression> <quantified-type-expression> ::= forall <type-variables-with-kinds> . (<constraints>) => <type-expression> <type-expression> ::= <type-expression> -> <quantified-type-expression> | ... ...
<simply-quantified-type-expression> ::= (<constraints-that-uses-rank-1-type-variables>) => <type-expression>
{- msum :: forall m a. Monoid (m a) => [m a] -> m a msum = mconcat mfilter :: forall m a. (Monad m, Monoid (m a)) => (a -> Bool) -> m a -> m a mfilter p ma = do { a <- ma; if p a then return a else mempty } guard :: forall m. (Monad m, Monoid (m ())) => Bool -> m () guard True = return () guard False = mempty
{- msum :: MonadPlus(m, a) => [m a] -> m a msum = mconcat mfilter :: MonadPlus(m, a) => (a -> Bool) -> m a -> m a mfilter p ma = do { a <- ma; if p a then return a else mempty } guard :: MonadPlus(m, ()) => Bool -> m () guard True = return () guard False = mempty
class (Monad m, Monoid (m a)) => MonadPlus m where ...
class forall m a. (Monad m, Monoid (m a)) => MonadPlus m where ...
class (constraints[a, b, c, d, e, ...]) => ClassName (a b c) (d e) ...
{- class (Monad m, Monoid (m a)) => MonadPlus m a where mzero :: m a mzero = mempty mplus :: m a -> m a -> m a mplus = mappend instance MonadPlus [] a instance Monoid a => MonadPlus Maybe a msum :: MonadPlus m a => [m a] -> m a msum = mconcat mfilter :: MonadPlus m a => (a -> Bool) -> m a -> m a mfilter p ma = do { a <- ma; if p a then return a else mzero } guard :: MonadPlus m () => Bool -> m () guard True = return () guard False = mzero
instance MonadPlus Maybe where mzero = Nothing Nothing `mplus` ys = ys xs `mplus` _ys = xs
instance Monoid a => Monoid (Maybe a) where mempty = Nothing Nothing `mappend` m = m m `mappend` Nothing = m Just m1 `mappend` Just m2 = Just (m1 `mappend` m2) -- < here
(Just [1,2] `mplus` Just [3,4]) `mplus` Just [5,6] => Just [1,2] (Just [1,2] `mappend` Just [3,4]) `mappend` Just [5,6] => Just [1,2,3,4,5,6]
λ» let x = 1 + 2 :: Int λ» let z = (x,x) λ» :sprint x x = _ λ» :sprint z z = (_,_) λ» seq x () () λ» :sprint z z = (3,3)
module Thunk where import Debug.Trace x :: Int x = trace "add" $ 1 + 2 z :: (Int,Int) z = (x,x)
λ» :sprint x x = _ λ» :sprint z z = _ λ» seq x () add () λ» :sprint z z = _ λ» seq z () () λ» z (3,3)
factMaker _ 0 = 1 factMaker fn n = n * ((fn fn) (n -1) {- to be called as (factMaker factMaker) 5 -}
(define Y (lambda (X) ((lambda (procedure) (X (lambda (arg) ((procedure procedure) arg)))) (lambda (procedure) (X (lambda (arg) ((procedure procedure) arg)))))))
(λ (f) ((λ (x) (f (λ (a) ((x x) a)))) (λ (x) (f (λ (a) ((x x) a))))))
newtype Mu a = Mu (Mu a -> a) y f = (\h -> h $ Mu h) (\x -> f . (\(Mu g) -> g) x $ x)
x :: a -> b -- x is a function x :: a -- x is applied to x -------------------------------- a = a -> b -- infinite type
import Unsafe.Coerce y :: (a -> a) -> a y = \f -> (\x -> f (unsafeCoerce x x)) (\x -> f (unsafeCoerce x x)) main = putStrLn $ y ("circular reasoning works because " ++)
1 : 1 : zipWith (+) [(1, 2), (2, 3)] => 1 : 1 : 3 : 5
module TraceFibs where import Debug.Trace fibs :: [Integer] fibs = 0 : 1 : zipWith tadd fibs (tail fibs) where tadd x y = let s = x+y in trace ("Adding " ++ show x ++ " and " ++ show y ++ "to obtain " ++ show s) s
*TraceFibs> fibs !! 5 Adding 0 and 1 to obtain 1 Adding 1 and 1 to obtain 2 Adding 1 and 2 to obtain 3 Adding 2 and 3 to obtain 5 5 *TraceFibs> fibs !! 5 5 *TraceFibs> fibs !! 6 Adding 3 and 5 to obtain 8 8 *TraceFibs> fibs !! 16 Adding 5 and 8 to obtain 13 Adding 8 and 13 to obtain 21 Adding 13 and 21 to obtain 34 Adding 21 and 34 to obtain 55 Adding 34 and 55 to obtain 89 Adding 55 and 89 to obtain 144 Adding 89 and 144 to obtain 233 Adding 144 and 233 to obtain 377 Adding 233 and 377 to obtain 610 Adding 377 and 610 to obtain 987 987 *TraceFibs>
let l = [1..10] print l print l -- None of the elements of the list are recomputed
let l = [1..10] print $ take 5 l -- Evaluates l to [1, 2, 3, 4, 5, _] print l -- 1 to 5 is already evaluated; only evaluates 6..10
fibs () = 0 : 1 : zipWith tadd (fibs ()) (tail (fibs ()))
instance (Num a,Num b) => Num (Pair a b) where Pair (a,b) + Pair (c,d) = Pair (a+c,b+d) Pair (a,b) * Pair (c,d) = Pair (a*c,b*d) Pair (a,b) - Pair (c,d) = Pair (a-c,b-d) abs (Pair (a,b)) = Pair (abs a, abs b) signum (Pair (a,b)) = Pair (signum a, signum b) fromInteger i = Pair (fromInteger i, fromInteger i)
*Main> Pair (3,4.0) + Pair (7, 10.5) Pair (10,14.5) *Main> Pair (3,4.0) + 1 -- * Pair (4,5.0)
data Pair a b = Pair a b deriving Show infixl 6 |+| -- optional; set same precedence and associativity as + Pair a b |+| Pair c d = Pair (a+c) (b+d)
import Prelude hiding ((+)) -- hide the autoimport of + import qualified Prelude as P -- allow us to refer to Prelude functions with a P prefix data Pair a = Pair (a,a) (+) :: Num a => Pair a -> Pair a -> Pair a -- redefinition of (+) (Pair (a,b)) + (Pair (c,d)) = Pair ((P.+) a c,(P.+) b d ) -- using qualified (+) from Prelude
import Prelude hiding ((+)) import qualified Prelude as P data Pair a = Pair (a,a) class Addable a where (+) :: a -> a -> a instance Num a => Addable (Pair a) where (Pair (a,b)) + (Pair (c,d)) = Pair ((P.+) a c,(P.+) b d )
class (Eq a, Show a) => Num a where (+), (*), (-) :: a -> a -> a negate :: a -> a ...
instance Num a => Num (Pair a) where Pair (x, y) + Pair (u, v) = Pair (x+u, y+v) ...
class (Monoid a, Monoid b) => Monoid (a, b) where mempty = (mempty, mempty) (a1, b1) `mappend` (a2, b2) = (a1 `mappend` a2, b1 `mappend` b2)
(1,2) ++ (3,4) == (4,6) ("hel", "wor") ++ ("lo", "ld") == ("hello", "world")
\k | k < 0 -> "negative" | k == 0 -> "zero" | otherwise -> "positive"
\k -> case () of _ | k < 0 -> "negative" | k == 0 -> "zero" | otherwise -> "positive"
\k -> if | k < 0 -> "negative" | k == 0 -> "zero" | otherwise -> "positive"
\case "negative" -> -1 "zero" -> 0 "positive" -> 1 _ -> error "invalid sign"
showSign k = mysign ++ " (" ++ show k ++ ")" where mysign | k < 0 = "negative" | k == 0 = "zero" | otherwise = "positive"
\case k | k < 0 -> "negative" | k == 0 -> "zero" | otherwise -> "positive"
\case k | k < 0 -> "negative" | k == 0 -> "zero" | otherwise -> "positive"
o <- hGetContents e `catch` (\case (e :: IOException) | isEOFError e -> return "")
data Fin : Nat -> Set where zerof : (n : Nat) -> Fin (succ n) succf : (n : Nat) -> (i : Fin n) -> Fin (succ n)
zerof 1 : Fin 2 zerof 2 : Fin 3 -- nope! zerof 0 : Fin 1 -- nope! succf 1 (zerof 0) : Fin 2
data Typed t where TyInt :: Int -> Typed Int TyChar :: Char -> Typed Char TyUnit :: Typed () TyProd :: Typed a -> Typed b -> Typed (a, b) ...
data Z data S a = S a > undefined :: S (S (S Z)) -- 3
data Nat where Zero :: Nat Z Succ :: Nat n -> Nat (S n)
data Fin n where ZeroF :: Nat n -> Fin (S n) SuccF :: Nat n -> Fin n -> Fin (S n)
*Fin> :t ZeroF (Succ Zero) ZeroF (Succ Zero) :: Fin (S (S Z)) *Fin> :t SuccF (Succ Zero) (ZeroF Zero) SuccF (Succ Zero) (ZeroF Zero) :: Fin (S (S Z))
{- data Zero data Succ s = Succ s data Node s a where Leaf2 :: a -> Node Zero a Leaf3 :: a -> a -> Node Zero a Node2 :: Node s a -> a -> Node s a -> Node (Succ s) a Node3 :: Node s a -> a -> Node s a -> a -> Node s a -> Node (Succ s) a
data BTree a where Root0 :: BTree a Root1 :: a -> BTree a RootN :: Node s a -> BTree a
data Term a where ... IsZero :: Term Char -> Term Char
longerThan :: Int -> [a] -> Bool longerThan n xs = isNonEmpty $ drop n xs
isInfinite :: [a] -> Bool isInfinite ls = {- Magic! -}
-- using a string here so you can watch it explode in ghci impossibleList :: [String] impossibleList = case isInfinite impossibleList of True -> [] False -> "loop!" : impossibleList
terminatingLength :: (Finite a) => a t -> Int terminatingLength = length . toList
-- Type-level version of "[]" data Nil a = Nil instance Finite Nil where toList Nil = []
-- Type-level version of ":" data Cons v a = Cons a (v a) -- A finite tail implies a finite Cons instance (Finite a) => Finite (Cons a) where toList (Cons h t) = h : toList t -- Simple tail recursion
function div <Err> (n: Int, d: Int): Int if d == 0 throwError("division by 0") else return (n / d)
function div(n: Int, d: Int): <Err> () -> Int () => if d == 0 throwError("division by 0") else return (n / d)
div :: Int -> Int -> Err Int div _ 0 = throwError "division by 0" div n d = return $ n / d
import Data.Word import qualified Data.ByteString as B import qualified Data.ByteString.Lazy as L import Data.Bits import Data.Int import Data.ByteString.Parser import System.Log.Logger import System.Log.Handler.Syslog importFile :: FilePath -> IO (Either String (PESFile )) importFile n = do warningM "MyApp.Component2" "Something Bad is about to happen." ...
... parsePES :: Parser PESFile parsePES = do header <- string " warningM "parsing header" ... return (PESFile ...)
Couldn with actual type `String -> IO ()' In the return type of a call of `warningM' In a stmt of a In the expression: do { header <- string " warningM "parsing header"; ...
newtype Parser a = Parser { unParser :: S -> Either String (a, S) }
newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
(define (create-shipping-employee-association name) `((name ,name) (employee-id-no ,(get-next-employee-id!)) (department shipping) (hire-date ,(get-day) ,(get-month) ,(get-year))))
(x `quot` y)*y + (x `rem` y) == x (x `div` y)*y + (x `mod` y) == x
Prelude> (-12) `quot` 5 -2 Prelude> (-12) `div` 5 -3
(-11)/5 = -2 (-11)%5 = -1 5*((-11)/5) + (-11)%5 = 5*(-2) + (-1) = -11.
(-11)/5 = -3 (-11)%5 = 4 5*((-11)/5) + (-11)%5 = 5*(-3) + 4 = -11.
let buggyOdd x = x `rem` 2 == 1 buggyOdd 1 buggyOdd (-1) let odd x = x `mod` 2 == 1 odd 1 odd (-1)
Text Text.Parsec Text.Parsec.ByteString Text.Parsec.ByteString.Lazy Text.Parsec.Char Text.Parsec.Combinator Text.Parsec.Error Text.Parsec.Expr Text.Parsec.Language Text.Parsec.Perm Text.Parsec.Pos Text.Parsec.Prim Text.Parsec.String Text.Parsec.Token ParserCombinators Text.ParserCombinators.Parsec Text.ParserCombinators.Parsec.Char Text.ParserCombinators.Parsec.Combinator Text.ParserCombinators.Parsec.Error Text.ParserCombinators.Parsec.Expr Text.ParserCombinators.Parsec.Language Text.ParserCombinators.Parsec.Perm Text.ParserCombinators.Parsec.Pos Text.ParserCombinators.Parsec.Prim Text.ParserCombinators.Parsec.Token
Prelude> [1, 3 .. 10] :: [Int] [1,3,5,7,9] Prelude> [1, 3 .. 10] :: [Float] [1.0,3.0,5.0,7.0,9.0,11.0] Prelude> [ "ace"
Prelude> map fromIntegral [1, 3 .. 10] :: [Float] [1.0,3.0,5.0,7.0,9.0]
trIntegrate f l r s = sum [ f x | x<-[l,(l+s)..r] ] * s - (f(l)+f(r))*s/2
bad_trIntegrate f l r s = sum [ f x | x<-[l,(l+s)..(r-s)] ] * s - (f(l)+f(r))*s/2
bad_trIntegrate ( \x -> exp(x + cos(sqrt(x) - x*x)) ) 1.0 3.0 0.1
Prelude> :info ($) ($) :: (a -> b) -> a -> b -- Defined in GHC.Base infixr 0 $
ghci> :i repeat repeat :: a -> [a] -- Defined in GHC.List
Name: foo Version: 1.0 License: BSD3 Cabal-Version: >= 1.9.2 Build-Type: Simple Test-Suite test-foo type: exitcode-stdio-1.0 main-is: test-foo.hs build-depends: base
module Main where import System.Exit (exitFailure) main = do putStrLn "This test always fails!" exitFailure
test test-is: Test build-depends: QuickCheck hs-source-dirs: tests src
$ ghc -o hello hello.hs $ strip -p --strip-unneeded --remove-section=.comment -o hello-small hello $ du hello hello-small 700 hello 476 hello-small
$ ghc -dynamic -o hello hello.hs $ strip -p --strip-unneeded --remove-section=.comment -o hello-small hello $ du hello hello-small 24 hello 16 hello-small
$ gcc hello.c -o hello $ strip -p --strip-unneeded --remove-section=.comment -o hello-small hello $ du hello hello-small 12 hello 8 hello-small
strip -p --strip-unneeded --remove-section=.comment -o your_executable_small your_executable
cutString :: (Num n, String str) => n -> str -> str cutString n str = case n of 0 -> tail str n -> cutString (n-1) (tail str)
`String In the type signature for `cutString cutString :: (Num n, String str) => n -> str -> str
Type constructor `String In the type `(Num n, String str) => n -> str -> str'
stack exec -- <your program> +RTS <profiling options>
stack --work-dir .stack-work-profile --profile <cmd>
stack build --executable-profiling --library-profiling --ghc-options="-fprof-auto -rtsopts"
stack exec -- <your program> +RTS <profiling options>
module Main where main :: IO () main = do print $ foo 0 foo :: Int -> Int foo x = fooSub (x+1) where fooSub x = bar (x+1) bar :: Int -> Int bar x = barSub (x+1) where barSub x = barSubSub (x+1) where barSubSub x = x+1
individual inherited COST CENTRE MODULE SRC no. entries %time %alloc %time %alloc [... many lines omitted ...] main Main src/Main.hs:(4,1)-(5,15) 97 0 0.0 0.0 0.0 0.0 foo Main src/Main.hs:(8,1)-(10,24) 98 1 0.0 0.0 0.0 0.0 foo.fooSub Main src/Main.hs:10:5-24 99 1 0.0 0.0 0.0 0.0 bar Main src/Main.hs:(13,1)-(17,46) 100 1 0.0 0.0 0.0 0.0 bar.barSub Main src/Main.hs:(15,5)-(17,46) 101 1 0.0 0.0 0.0 0.0 bar.barSub.barSubSub Main src/Main.hs:17:9-46 102 1 0.0 0.0 0.0 0.0 main Main src/Main.hs:(4,1)-(5,15) 95 0 0.0 20.5 0.0 20.5
individual inherited COST CENTRE MODULE SRC no. entries %time %alloc %time %alloc [... many lines omitted ...] main Main src/Main.hs:(4,1)-(5,15) 97 0 0.0 0.0 0.0 0.0 foo Main src/Main.hs:(8,1)-(10,24) 98 1 0.0 0.0 0.0 0.0 bar Main src/Main.hs:(13,1)-(17,46) 99 1 0.0 0.0 0.0 0.0 main Main src/Main.hs:(4,1)-(5,15) 95 0 0.0 20.5 0.0 20.5
test: 4 CallStack (from HasCallStack): error, called at src/Main.hs:17:23 in main:Main CallStack (from -prof): Main.bar.barSub.barSubSub (src/Main.hs:17:9-36) Main.bar.barSub (src/Main.hs:(15,5)-(17,36)) Main.bar (src/Main.hs:(13,1)-(17,36)) Main.foo.fooSub (src/Main.hs:10:5-24) Main.foo (src/Main.hs:(8,1)-(10,24)) Main.main (src/Main.hs:(4,1)-(5,15)) Main.CAF:lvl8_r4Fc (<no location info>)
data Store s a = Store (s -> a) s instance Functor (Store s) where fmap f (Store g s) = Store (f . g) s instance Extend (Store s) where duplicate (Store f s) = Store (Store f) s instance Comonad (Store s) where extract (Store f s) = f s
type State s a = s -> (a, s) type Store s a = (s -> a, s)
data Store s a = Store { peek :: s -> a, pos :: s }
module SomeModule.Internal where -- ... exports all private methods
module SomeModule where (export1, export2) import SomeModule.Internal
putStrLn (show 1) putStrLn (show [1, 2, 3]) putStrLn (show (Just 42))
func x = case tryEval x of Left e -> Left e Right val -> Right $ val + 1 func x = (+1) <$> trvEval x
listOfLists : Nat -> Set -> Set listOfLists Zero a = a listOfLists (Succ n) a = List (listOfLists n a)
listOfLists Zero Bool = Bool listOfLists (Succ Zero) Bool = List Bool listOfLists (Succ (Succ Zero)) Bool = List (List Bool)
mapN : {a b : Set} -> (a -> b) -> (n : Nat) -> listOfLists n a -> listOfLists n b mapN f Zero x = f x mapN f (Succ n) [] = [] mapN f (Succ n) (x :: xs) = mapN f n x :: mapN f (Succ n) xs
cheating : Set -> Bool cheating Nat = True cheating _ = False
class Arbitrary a where arbitrary :: Gen a shrink :: a -> [a]
FormulaPrim deparsing : *** Failed! Falsifiable (after 4 tests): Poly (Polynome "p" [(CoeffRatio (26 % 25),PolyRest (CoeffRatio (129 % 40))),(CoeffInt 96,PolyRest (CoeffInt 11)),(CoeffInt 29,PolyRest (CoeffRatio (147 % 121))),(CoeffRatio (62 % 9),PolyRest (CoeffRatio (90 % 43))),(CoeffInt 56,PolyRest (CoeffInt 27))])
FormulaPrim deparsing : *** Failed! Falsifiable (after 2 tests and 3 shrinks): Poly (Polynome "t" [(CoeffInt 14,PolyRest (CoeffInt 126))])
{- import qualified Control.Monad.State as S data Knot s = Knot { past :: s, future :: s } newtype RecStateT s m a = RecStateT (S.StateT (Knot s) m a) deriving ( Alternative , Applicative , Functor , Monad , MonadCont , MonadError e , MonadFix , MonadIO , MonadPlus , MonadReader r , MonadTrans , MonadWriter w ) runRecStateT :: RecStateT s m a -> Knot s -> m (a, Knot s) runRecStateT (RecStateT st) = S.runStateT st tie :: MonadFix m => RecStateT s m a -> s -> m (a, s) tie m s = do rec (a, Knot s return (a, s get :: Monad m => RecStateT s m (Knot s) get = RecStateT S.get put :: Monad m => s -> RecStateT s m () put s = RecStateT $ S.modify $ \ ~(Knot _ s
do Knot past future <- get let {- ... -} = past {- ... -} = future node = {- ... -} put $ {- ... -} return node
see :: Monoid s => Seer s s send :: Monoid s => s -> Seer s ()
import Control.Seer import qualified Data.Map as M import Data.Map (Map, (!)) bar :: Seer (Map Int Char) String bar = do m <- see send (M.singleton 1 $ succ (m ! 2)) send (M.singleton 2 return [m ! 1, m ! 2]
{- import Control.Monad.State import Control.Monad.Reader import Control.Applicative newtype RecStateT s m a = RecStateT (StateT s (ReaderT s m) a) deriving ( Alternative , Applicative , Functor , Monad , MonadPlus ) tie :: MonadFix m => RecStateT s m a -> s -> m (a, s) tie (RecStateT m) s = do rec (a, s return (a, s getPast :: Monad m => RecStateT s m s getPast = RecStateT get getFuture :: Monad m => RecStateT s m s getFuture = RecStateT ask putPresent :: Monad m => s -> RecStateT s m () putPresent = RecStateT . put
data Node = Node { value :: Int, next :: Node } deriving Show … tie = … parse = … data ParserState = … … example :: Node example = let (_, _, m) = tie parse $ ParserState 0 [(0, 1), (1, 2), (2, 0)] in (m Map.! 0)
{- import Data.Vector as Vector example :: Node example = let node :: Int -> Node node = (Vector.!) $ Vector.fromList $ [ Node{value,next} | (value,node->next) <- [(0, 1), (1, 2), (2, 0)] ] in (node 0)
{- import Data.Vector as Vector example :: Node example = (\node->(Vector.fromList[ Node{value,next} | (value,node->next) <- [(0, 1), (1, 2), (2, 0)] ] Vector.!)) `fix` 0
-- Public Domain import Control.Monad import Data.Map (Map) import qualified Data.Map as Map import Data.Maybe (fromJust) -- Fixed point operator on types and catamohism/anamorphism methods -- for constructing/deconstructing them: newtype Fix f = Fix { unfix :: f (Fix f) } catam :: Functor f => (f a -> a) -> (Fix f -> a) catam f = f . fmap (catam f) . unfix anam :: Functor f => (a -> f a) -> (a -> Fix f) anam f = Fix . fmap (anam f) . f anam anam -- The loader itself -- A representation of a loader. Type parameter -- which the nodes are represented. Type parameter -- data type representing the values. data Loader k v = Loader (Map k (v k)) -- | Creates an empty loader. empty :: Loader k v empty = Loader $ Map.empty -- | Adds a new node into a loader. update :: (Ord k) => k -> v k -> Loader k v -> Loader k v update k v = update -- | Modifies a node in a loader. update update -- | Does the actual knot-tying. Creates a new data structure -- where the references to nodes are replaced by the actual data. tie :: (Ord k, Functor v) => Loader k v -> Map k (Fix v) tie (Loader m) = Map.map (anam -- ----------------------------------------------------------------- -- Usage example: data NodeF n t = NodeF n [t] instance Functor (NodeF n) where fmap f (NodeF n xs) = NodeF n (map f xs) -- A data structure isomorphic to Fix (NodeF n), but easier to work with. data Node n = Node n [Node n] deriving Show -- The isomorphism that does the conversion. nodeunfix :: Fix (NodeF n) -> Node n nodeunfix = catam (\(NodeF n ts) -> Node n ts) main :: IO () main = do -- Each node description consist of an integer ID and a list of other nodes -- it references. let lss = [ (1, [4]) , (2, [1]) , (3, [2, 1]) , (4, [3, 2, 1]) , (5, [5]) ] print lss -- Fill a new loader with the data: let loader = foldr f empty lss f (label, dependsOn) = update label (NodeF label dependsOn) -- Tie the knot: let tied -- And convert Fix (NodeF n) into Node n: let tied = Map.map nodeunfix tied' -- For each node print the label of the first node it references -- and the count of all referenced nodes. print $ Map.map (\(Node n ls@((Node n1 _) : _)) -> (n1, length ls)) tied
Applicative m, Monad m => mf :: m (a -> b), ma :: m a
mf <*> ma === do { f <- mf; a <- ma; return (f a) }
newtype LeftA m a = LeftA (m a) instance Monad m => Applicative (LeftA m) where pure = return mf <*> ma = do { f <- mf; a <- ma; return (f a) } newtype RightA m a = RightA (m a) instance Monad m => Applicative (RightA m) where pure = return mf <*> ma = do { a <- ma; f <- mf; return (f a) }
(>>) return mzero mplus mapM mapM_ forM forM_ sequence sequence_ forever msum filterM mapAndUnzipM zipWithM zipWithM_ replicateM replicateM_ guard when unless liftM liftM2 liftM3 liftM4 liftM5 ap
sequenceA :: Applicative f, Traversable t => t (f a) -> f (t a) join :: Monad m => m (m a) -> m a
-- icu.hs import Data.Text.ICU main = print $ Locale "tr-TR"
stack exec -- pacman -Sy mingw64/mingw-w64-x86_64-icu stack build text-icu
main :: () main = case putStr "Hello, " of () -> putStrLn " world!" -- prints “Hello, world!\n”
main :: () main = case putStr "Hello, " of _ -> putStrLn " world!"
printAndAdd :: String -> Integer -> Integer -> Integer printAndAdd msg x y = putStrLn msg `seq` (x + y) main :: () main = let x = printAndAdd "first" 1 2 y = printAndAdd "second" 3 4 in (y + x) `seq` ()
{- import Foreign import Foreign.C.Types foreign import ccall unsafe "stdlib.h rand" c_rand :: CUInt main = putStrLn (show c_rand) >> putStrLn (show c_rand)
{- import Foreign import Foreign.C.Types foreign import ccall unsafe "stdlib.h rand" c_rand :: IO CUInt main = c_rand >>= putStrLn . show >> c_rand >>= putStrLn . show
c_write :: String -> () -> () c_rand :: () -> CUInt
newtype IO a = IO { runIO :: () -> a } instance Monad IO where return = IO . const m >>= f = IO $ \() -> let x = runIO m () in x `seq` f x rand :: IO CUInt rand = IO c_rand
data FooWrap where FooWrap :: Foo a => a -> FooWrap type FooList = [FooWrap]
data FooElem = ElemFoo Foo | ElemBar Bar type FooList = [FooElem]
{- class Foo a where foo :: a -> a data AnyFoo = forall a. Foo a => AnyFoo a instance Foo AnyFoo where foo (AnyFoo a) = AnyFoo $ foo a mapFoo :: [AnyFoo] -> [AnyFoo] mapFoo = map foo
import qualified Data.Map as M mFoo :: M.Map String AnyFoo mFoo = M.fromList [("a", AnyFoo SomeFoo), ("b", AnyFoo SomeBar)]
data Attribute a = Attribute { name :: String, value :: a }
testAttr = Attribute { name = "this is only a test", value = Node 3 [] }
{- import Data.Convertible data Conv b where Conv :: a -> (a -> b) -> Conv b Chain :: Conv b -> (b -> c) -> Conv c unconv :: (Conv b) -> b unconv (Conv a f) = f a unconv (Chain c f) = f $ unconv c conv :: Convertible a b => a -> Conv b conv a = (Conv a convert) totype :: Convertible b c => Conv b -> Conv c totype a = Chain a convert
echo "jobs: $(getconf _NPROCESSORS_ONLN)" >> ~/.cabal/config
cabal update cabal install cabal-install --bindir ~/bin --upgrade-dependencies
val = 5 -- is `val` a pointer to a box containing 5? add x y = x + y result = add 2 val main = print $ result
average list = if null list then 0 else div (sum list) (length list)
{- data Showable = forall a. Show a => Sh a aList :: [Showable] aList = [Sh (1 :: Int), Sh "abc"]
{- aList :: [forall a. Show a => a] aList = [(1 :: Int), "abc"]
Couldn ‘a’ is a rigid type variable bound by a type expected by the context: Show a => a
{- data ConstrList c = forall a. c a => a :> ConstrList c | Nil infixr :> constrMap :: (forall a. c a => a -> b) -> ConstrList c -> [b] constrMap f (x :> xs) = f x : constrMap f xs constrMap f Nil = []
example :: [String] example = constrMap show (( :> True :> () :> Nil) :: ConstrList Show)
data AnyList c f = forall a. c a => f a :| (AnyList c f) | Nil infixr :| anyMap :: (forall a. c a => f a -> b) -> AnyList c f -> [b] anyMap g (x :| xs) = g x : anyMap g xs anyMap g Nil = []
example2 :: Int -> [String] example2 x = anyMap (\m -> show (m x)) (( f :| g :| h :| Nil) :: AnyList Show ((->) Int)) where f :: Int -> String f = show g :: Int -> Bool g = (< 3) h :: Int -> () h _ = ()
type ConstrList c = AnyList c Identity (>:) :: forall c a. c a => a -> AnyList c Identity -> AnyList c Identity x >: xs = Identity x :| xs infixr >: constrMap :: (forall a. c a => a -> b) -> AnyList c Identity -> [b] constrMap f (Identity x :| xs) = f x : constrMap f xs constrMap f Nil = []
{- , TypeOperators, DataKinds, ConstraintKinds, RankNTypes, PatternSynonyms import Data.List (intercalate) import GHC.Prim (Constraint) infixr 5 :& data HList xs where None :: HList (:&) :: a -> HList bs -> HList (a -- | Constraint All c xs holds if c holds for all x in xs type family All (c :: k -> Constraint) xs :: Constraint where All c All c (x -- | The list whose element types are unknown, but known to satisfy -- a class predicate. data CList c where CL :: All c xs => HList xs -> CList c cons :: c a => a -> CList c -> CList c cons a (CL xs) = CL (a :& xs) empty :: CList c empty = CL None uncons :: (forall a . c a => a -> CList c -> r) -> r -> CList c -> r uncons _ n (CL None) = n uncons c n (CL (x :& xs)) = c x (CL xs) foldrC :: (forall a . c a => a -> r -> r) -> r -> CList c -> r foldrC f z = go where go = uncons (\x -> f x . go) z showAll :: CList Show -> String showAll l = "[" ++ intercalate "," (foldrC (\x xs -> show x : xs) [] l) ++ "]" test = putStrLn $ showAll $ CL $ 1 :& "foo" :& [2.3, 2.5 .. 3] :& None
infixr 5 <: (<:) :: Show a => a -> [String] -> [String] x <: l = show x : l
λ > (1 :: Int) <: True <: "abs" <: [] ["1","True","\"abs\""]
{- {- {- {- {- {- {- import GHC.Exts (Constraint) infixr 5 ::: type family All (c :: k -> Constraint) (xs :: [k]) :: Constraint where All c All c (x data HList as where HNil :: HList (:::) :: a -> HList as -> HList (a instance All Show as => Show (HList as) where showsPrec d HNil = showString "HNil" showsPrec d (x ::: xs) = showParen (d > 5) (showsPrec 5 x) . showString " ::: " . showParen (d > 5) (showsPrec 5 xs)
λ *Main > (1 :: Int) ::: True ::: "foo" ::: HNil 1 ::: True ::: "foo" ::: HNil λ *Main > :t (1 :: Int) ::: True ::: "foo" ::: HNil (1 :: Int) ::: True ::: "foo" ::: HNil :: HList
newtype Strings = Strings { getStrings :: [String] } newtype DiffList a = DiffList { getDiffList :: [a] -> [a] } instance Monoid (DiffList a) where mempty = DiffList id DiffList f `mappend` DiffList g = DiffList (f . g) class ShowList a where showList instance ShowList Strings where showList instance (Show a, ShowList b) => ShowList (a -> b) where showList showList = showList
toString :: Stringable -> String toStringable :: String -> Stringable
{- import Data.Typeable data Showable = Showable Showable :: (Show a, Typeable a) => a -> Stringable downcast :: Typeable a => Showable -> Maybe a downcast (Showable a) = cast a
data Sphere = ... data Triangle = ... data Ray = ... data IntersectionResult = ... class Intersect t where intersect :: t -> Ray -> Maybe IntersectionResult instance Intersect Sphere where ... instance Intersect Triangle where ...
myList :: [(Ray -> Maybe IntersectionResult)] myList = [intersect sphere, intersect triangle, ...]
class ShapeWithSomething t where getSomething :: t -> OtherParam -> Float data ShapeIntersectAndSomething = ShapeIntersectAndSomething { intersect :: Ray -> Maybe IntersectionResult, getSomething :: OtherParam -> Float}
data ShowableInterface = ShowInt Int | ShowApple Apple | ShowBusiness Business instance Show ShowableInterface where show (ShowInt i) = show i show (ShowApple a) = show a show (ShowBusiness b) = show b list=[ShowInt 2, ShowApple CrunchyGold, ShowBusiness MoulinRouge] show list
class Int implements ShowableInterface { public show {return Integer.asString(i)}; } class Apple implements ShowableInterface { public show {return this.name}; } class ShowBusiness implements ShowableInterface { public show {return this.fancyName}; } List list = new ArrayList (new Apple("CrunchyGold"), new ShowBusiness("MoulingRouge"), new Integer(2));
newtype DiffList a = DiffList {getDiffList :: [a] -> [a] } instance Monoid (DiffList a) where mempty = DiffList (\xs -> [] ++ xs) (DiffList f) `mappend` (DiffList g) = DiffList (\xs -> f (g xs))
(++) / \ (++) f / \ (++) e / \ (++) d / \ (++) c / \ a b
a ++ b = (a ++ b) ++ c = ((a ++ b) ++ c) ++ d = (((a ++ b) ++ c) ++ d) ++ e = ((((a ++ b) ++ c) ++ d) ++ e) ++ f =
(...((a_d ++ a_{d-1}) ++ a_{d-2}) ...) ++ a_2) ++ a_1
((((a ++) . (b ++)) . (c ++)) . (d ++)) . (e ++) $ f
((((a ++) . (b ++)) . (c ++)) . (d ++)) $ (e ++) f (((a ++) . (b ++)) . (c ++)) $ (d ++) ((e ++) f) ((a ++) . (b ++)) $ (c ++) ((d ++) ((e ++) f)) (a ++) $ (b ++) ((c ++) ((d ++) ((e ++) f))) a ++ (b ++ (c ++ (d ++ (e ++ f))))
($) / \ (.) f / \ (.) (e ++) / \ (.) (d ++) / \ (.) (c ++) / \ (a ++) (b ++)
($)--------- / \ (.) ($) / \ / \ (.) (d ++) (e ++) f / \ (.) (c ++) / \ (a ++) (b ++)
($) / \ (a ++) ($) / \ (b ++) ($) / \ (c ++) ($) / \ (d ++) ($) / \ (e ++) f
newtype DiffList a = DiffList {getDiffList :: [a] -> [a] } instance Monoid (DiffList a) where mempty = DiffList (\xs -> [] ++ xs) (DiffList f) `mappend` (DiffList g) = DiffList (\xs -> f (g xs))
DiffList (a ++) `mappend` DiffList (b ++) ~> DiffList ((a ++) . (b++))
--This is O(n) (a ++ (b ++ (c ++ (d ++ (e ++ f)))))
GHCi> expr <- runQ [| \f g x -> f (x*2 + 3) . g |] GHCi> putStrLn $ pprint expr \f_0 g_1 x_2 -> f_0 ((x_2 GHC.Num.* 2) GHC.Num.+ 3) GHC.Base.. g_1
> putStrLn $(stringE . pprint =<< [| \f g x -> f (x*2 + 3) . g |]) \f_0 g_1 x_2 -> f_0 ((x_2 GHC.Num.* 2) GHC.Num.+ 3) GHC.Base.. g_1
:m + Data.Map let map = fromList [(1, 2)] lookup 1 map
<interactive>:1:0: Ambiguous occurrence `lookup' It could refer to either `Prelude.lookup or `Data.Map.lookup > :t map map :: Map Integer Integer > :t Prelude.lookup Prelude.lookup :: (Eq a) => a -> [(a, b)] -> Maybe b > :t Data.Map.lookup Data.Map.lookup :: (Ord k) => k -> Map k a -> Maybe a
> lookup 1 [(1,2), (3,4)] Just 2 > Map.lookup 1 Map.empty Nothing
import Prelude hiding (lookup) import Data.Map (lookup)
import Language.Haskell.Exts main = interact codeFormat codeFormat = check . fmap reformat . parseModuleWithComments where reformat = prettyPrint check r = case r of ParseOk a -> a ParseFailed loc err -> error $ show (loc,err)
λ> putStrLn $ codeFormat "module X where x = 1 where { y 1 = 2; y _ = 2 }" module X where x = 1 where y 1 = 2 y _ = 2
exactPrint :: ExactP ast => ast SrcSpanInfo -> [Comment] -> String
prettyHS :: String -> String prettyHS src = case parseFileContentsWithComments defaultParseMode src of ParseOk (ast, _) -> prettyPrint ast _ -> src
Prelude> :t (flip id) (flip id) :: b -> (b -> c) -> c
($) :: (a -> b) -> a -> b ($) f x = f x -- unpoint: ($) f = f -- hence: ($) = id
data Sg (S : Set) (T : S -> Set) : Set where Ex : (s : S) -> T s -> Sg S T
choice : a -> a -> Bool -> a choice l r True = l choice l r False = r
eitherIsSg : {a b : Set} -> Either a b -> Sg Bool (choice a b) eitherIsSg (Left a) = Sg True a eitherIsSg (Right b) = Sg False b sgIsEither : {a b : Set} -> Sg Bool (choice a b) -> Either a b sgIsEither (Sg True a) = Left a sgIsEither (Sg False b) = Right b
fand :: (a -> Bool) -> (a -> Bool) -> a -> Bool fand f1 f2 x = (f1 x) && (f2 x) f_or :: (a -> Bool) -> (a -> Bool) -> a -> Bool f_or f1 f2 x = (f1 x) || (f2 x)
import Text.ParserCombinators.Parsec import Data.Char nameChar = satisfy (isLetter `f_or` isDigit)
instance Applicative ((->) a) where (<*>) f g x = f x (g x) liftA2 f a b = f <$> a <*> b (<$>) = fmap instance Functor ((->) r) where fmap = (.)
\f g -> liftA2 (&&) f g = \f g -> (&&) <$> f <*> g -- defn of liftA2 = \f g -> ((&&) . f) <*> g -- defn of <$> = \f g x -> (((&&) . f) x) (g x) -- defn of <*> - (.) f g = \x -> f (g x) = \f g x -> ((&&) (f x)) (g x) -- defn of (.) = \f g x -> (f x) && (g x) -- infix (&&)
instance Monad ((->) r) where return = const f >>= k = \ r -> k (f r) r
\f g -> liftM2 (&&) f g = \f g -> do { x1 <- f; x2 <- g; return ((&&) x1 x2) } -- defn of liftM2 = \f g -> f >>= \x1 -> g >>= \x2 -> return ((&&) x1 x2) -- by do notation = \f g -> (\r -> (\x1 -> g >>= \x2 -> return ((&&) x1 x2)) (f r) r) -- defn of (>>=) = \f g -> (\r -> (\x1 -> g >>= \x2 -> const ((&&) x1 x2)) (f r) r) -- defn of return = \f g -> (\r -> (\x1 -> (\r -> (\x2 -> const ((&&) x1 x2)) (g r) r)) (f r) r) -- defn of (>>=) = \f g x -> (\r -> (\x2 -> const ((&&) (f x) x2)) (g r) r) x -- beta reduce = \f g x -> (\x2 -> const ((&&) (f x) x2)) (g x) x -- beta reduce = \f g x -> const ((&&) (f x) (g x)) x -- beta reduce = \f g x -> ((&&) (f x) (g x)) -- defn of const = \f g x -> (f x) && (g x) -- inline (&&)
mapAp fs x = map ($x) fs fAnd fs = and . mapAp fs fOr fs = or . mapAp fs > fOr [(>2), (<0), (== 1.1)] 1.1 True > fOr [(>2), (<0), (== 1.1)] 1.2 False > fOr [(>2), (<0), (== 1.1)] 4 True
ghci> fAnd [even, odd] 3 False ghci> fOr [even, odd] 3 True
import Control.Arrow ((&&&), (>>>), Arrow(..)) split_combine :: Arrow cat => cat (b, c) d -> cat a b -> cat a c -> cat a d split_combine h f g = (f &&& g) >>> h letter_or_digit = split_combine (uncurry (||)) isLetter isDigit
> map letter_or_digit "aQ_%8" [True,True,False,False,True]
> :t split_combine split_combine :: Arrow cat => cat (b, c) d -> cat a b -> cat a c -> cat a d > :t liftA2 liftA2 :: Applicative f => (b -> c -> d) -> f b -> f c -> f d
(\a b c -> a && b && c) <$> aCheckOnA <*> anotherCheckOnA <*> ohNoNotAnotherCheckOnA $ a
-- Simulate infinite lists as functions from Integer type List a = Int -> a cons :: a -> List a -> List a cons x xs n | n == 0 = x | otherwise = xs (n-1) tailF :: List a -> List a tailF xs n = xs (n+1) fib :: List Integer fib = 1 `cons` (1 `cons` (\n -> fib n + tailF fib n))
{- aaaaaaaaa :: [a] -> Int aaaaaaaaa x = length x + length x {- bbbbbbbbb :: [a] -> Int bbbbbbbbb x = l + l where l = length x main = bbbbbbbbb [1..2000000] `seq` aaaaaaaaa [1..2000000] `seq` return ()
Main.aaaaaaaaa [NEVER Nothing] :: forall a_adp. [a_adp] -> GHC.Types.Int GblId [Arity 1 NoCafRefs Str: DmdType Sm] Main.aaaaaaaaa = \ (@ a_ahc) (x_adq :: [a_ahc]) -> case GHC.List.$wlen @ a_ahc x_adq 0 of ww_anf { __DEFAULT -> case GHC.List.$wlen @ a_ahc x_adq 0 of ww1_Xnw { __DEFAULT -> GHC.Types.I } } Main.bbbbbbbbb [NEVER Nothing] :: forall a_ado. [a_ado] -> GHC.Types.Int GblId [Arity 1 NoCafRefs Str: DmdType Sm] Main.bbbbbbbbb = \ (@ a_adE) (x_adr :: [a_adE]) -> case GHC.List.$wlen @ a_adE x_adr 0 of ww_anf { __DEFAULT -> GHC.Types.I }
f :: a -> Maybe a g :: a -> Maybe a h :: a -> Maybe a
instance MonadPlus Maybe where mzero = Nothing Nothing `mplus` ys = ys xs `mplus` _ys = xs
import Data.List import Data.Maybe import Control.Monad join $ find isJust [f x, g y, h z]
function = runReaderT $ ReaderT f `mplus` ReaderT g `mplus` ReaderT h
715,584,711,208 bytes allocated in the heap 390,936,909,408 bytes copied during GC 4,731,021,848 bytes maximum residency (745 sample(s)) 76,081,048 bytes maximum slop 7146 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 24103 colls, 24103 par 240.99s 104.44s 0.0043s 0.0603s Gen 1 745 colls, 744 par 2820.18s 619.27s 0.8312s 1.3200s Parallel GC work balance: 50.36% (serial 0%, perfect 100%) TASKS: 18 (1 bound, 17 peak workers (17 total), using -N5) SPARKS: 1295 (1274 converted, 0 overflowed, 0 dud, 0 GC INIT time 0.00s ( 0.00s elapsed) MUT time 475.11s (454.19s elapsed) GC time 3061.18s (723.71s elapsed) EXIT time 0.27s ( 0.50s elapsed) Total time 3536.57s (1178.41s elapsed) Alloc rate 1,506,148,218 bytes per MUT second Productivity 13.4% of total user, 40.3% of total elapsed
-Ffactor [Default: 2] This option controls the amount of memory reserved for the older generations (and in the case of a two space collector the size of the allocation area) as a factor of the amount of live data. For example, if there was 2M of live data in the oldest generation when we last collected it, then by default we collecting it again.
-- yes, this is a horrible name createManagerFactory :: a -> IO ((IO a), IO (((a -> a) -> IO a)))
(query, modifierFactory) <- createManagerVactory initValue
handleKey :: Key -> TextCursor -> Maybe (Damage, TextCursor)
data Damage = NoChange -- use this if nothing at all happened | PointChanged -- use this if you moved the cursor but kept the text | LineChanged -- use this if you changed text only on the current line | LotsChanged -- use this if you changed text off the current line deriving (Show, Eq, Ord)
deactivate :: Cursor x Here -> (Int, [x]) deactivate c = outward 0 c where outward i (B0, Here, xs) = (i, xs) outward i (xz :< x, Here, xs) = outward (i + 1) (xz, Here, x : xs)
activate :: (Int, [x]) -> Cursor x Here activate (i, xs) = inward i (B0, Here, xs) where inward _ c@(_, Here, []) = c -- we can go no further inward 0 c = c -- we should go no further inward i (xz, Here, x : xs) = inward (i - 1) (xz :< x, Here, xs) -- and on!
handleKey :: Key -> TextCursor -> Maybe (Damage, TextCursor) handleKey (CharKey c) (sz, (cz, Here, cs), ss) = Just (LineChanged, (sz, (cz, Here, c : cs), ss)) handleKey _ _ = Nothing
data Cursor = Cursor { upLines :: Seq Line , curLine :: CurLine , downLines :: Seq Line }
$ man ghc | grep String -XExtendedDefaultRules -XNoExtendedDefaultRules -XOverloadedStrings -XNoOverloadedStrings -XGADTs -XNoGADTs -XGADTSyntax -XNoGADTSyntax
-- in GHC.Types (ghc-prim) newtype IO a = IO (State -- in GHC.Base (base) instance Monad IO where {- {- {- m >> k = m >>= \ _ -> k return = returnIO (>>=) = bindIO fail s = failIO s returnIO :: a -> IO a returnIO x = IO $ \ s -> ( bindIO :: IO a -> (a -> IO b) -> IO b bindIO (IO m) k = IO $ \ s -> case m s of ( thenIO :: IO a -> IO b -> IO b thenIO (IO m) k = IO $ \ s -> case m s of ( unIO :: IO a -> (State unIO (IO a) = a
return x >>= f ≡ f x: return x >>= f = IO $ \s -> case (\t -> ( ( = IO $ \s -> case ( ( = IO $ \s -> unIO (f x) s
m >>= return ≡ m: (IO k) >>= return = IO $ \s -> case k s of ( = IO $ \s -> case k s of ( = IO $ \s -> case k s of ( = IO $ \s -> k s
m >>= (\x -> g x >>= h) ≡ (m >>= g) >>= h: (IO k) >>= (\x -> g x >>= h) = IO $ \s -> case k s of ( = IO $ \s -> case k s of ( = IO $ \s -> case k s of ( ( = IO $ \s -> case k s of ( ( ((IO k) >>= g) >>= h = IO $ \s -> case (\t -> case k t of ( ( = IO $ \s -> case (case k s of ( (
case (case e of case e of pat1 -> ex1) of ≡ pat1 -> case ex1 of pat2 -> ex2 pat2 -> ex2
seq (return <=< undefined :: a -> Identity b) () = () seq (undefined :: a -> Identity b) () = undefined seq (return <=< undefined :: a -> Maybe b) () = () seq (undefined :: a -> Maybe b) () = undefined
Prelude> seq ( undefined >>= return :: IO () ) "hello, world" "hello, world" Prelude> seq ( undefined :: IO () ) "hello, world" *** Exception: Prelude.undefined
Prelude> seq ( undefined >>= return :: Maybe () ) "hello, world" *** Exception: Prelude.undefined Prelude> seq ( undefined :: Maybe () ) "hello, world" *** Exception: Prelude.undefined
sequence_ $ take 100000 $ iterate (>>=return) (return ()) :: IO ()
sequence_ $ take 100000 $ iterate (>>=return) (return ()) :: Maybe ()
data Plane = Plane { point :: Point, normal :: Vector Double } data Sphere = Sphere { center :: Point, radius :: Double } class Shape s where intersect :: s -> Ray -> Maybe Point surfaceNormal :: s -> Point -> Vector Double
shapes :: (Shape t) => [t] shapes = [ Sphere { center = Point [0, 0, 0], radius = 2.0 }, Plane { point = Point [1, 2, 1], normal = 3 |> [0.5, 0.6, 0.2] } ]
data Shape = Shape { intersect :: Ray -> Maybe Point, surfaceNormal :: Point -> Vector Double }
plane :: Point -> Vector Double -> Shape sphere :: Point -> Double -> Shape
data Foo = F deriving Show data Bar = B deriving Show data Contain = CFoo Foo | CBar Bar deriving Show stuffExplicit :: [Contain] stuffExplicit = [CFoo F, CBar B] main = print stuffExplicit
data AnyShow = forall s. Show s => AS s showIt (AS s) = show s stuffAnyShow :: [AnyShow] stuffAnyShow = [AS F, AS B] main = print (map showIt stuffAnyShow)
buildTrie :: [B.ByteString] -> MyDFA buildTrie l = fst3 $ foldl step :: (MyDFA , B.ByteString, Int) -> B.ByteString -> (MyDFA , B.ByteString, Int) step (dfa, lastWord, newIndex) newWord = (insertNewStates, newWord, newIndex + B.length newSuffix) where (pref, lastSuffix, newSuffix) = splitPrefix lastWord newWord branchPoint = transStar dfa pref --new state labels for the newSuffix path newStates = [newIndex .. newIndex + B.length newSuffix - 1] --insert newStates insertNewStates = (foldl
data NumCol = Empty | Single Int | Pair Int Int | Lots [Int]
get_pairs :: [NumCol] -> [NumCol] get_pairs = filter is_pair where is_pair (Pair _ _) = True is_pair _ = False
{- import Control.Lens import Control.Lens.Extras (is) data NumCol = Empty | Single Int | Pair Int Int | Lots [Int] -- Uses Template Haskell to create the Prisms _Empty, _Single, _Pair and _Lots -- corresponding to your constructors makePrisms get_pairs :: [NumCol] -> [NumCol] get_pairs = filter (is _Pair)
{- TypeFamilies, PolyKinds, FlexibleInstances, PatternSynonyms
data TagType = EmptyTag | SingleTag | PairTag | LotsTag
data Tag :: TagType -> * where EmptyT :: Tag EmptyTag SingleT :: Tag SingleTag PairT :: Tag PairTag LotsT :: Tag LotsTag
type family Stuff (t :: TagType) :: * where Stuff EmptyTag = () Stuff SingleTag = Int Stuff PairTag = (Int, Int) Stuff LotsTag = [Int]
data NumCol :: * where (:&) :: Tag t -> Stuff t -> NumCol
pattern Empty = EmptyT :& () pattern Single i = SingleT :& i pattern Pair i j = PairT :& (i, j) pattern Lots is = LotsT :& is
data Ex :: (k -> *) -> * where -- wish I could say newtype here Witness :: p x -> Ex p
instance Eq (Ex Tag) where Witness EmptyT == Witness EmptyT = True Witness SingleT == Witness SingleT = True Witness PairT == Witness PairT = True Witness LotsT == Witness LotsT = True _ == _ = False
numColTag :: NumCol -> Ex Tag numColTag (n :& _) = Witness n
filter ((Witness PairT ==) . numColTag) :: [NumCol] -> [NumCol]
data NumCol = Empty | Single Int | Pair Int Int | Lots [Int] deriving (Typeable, Data)
is_pair x = toConstr x == toConstr (Pair undefined undefined)
class Constrable a where constr :: a -> Constr instance Data a => Constrable a where constr = toConstr instance Constrable a => Constrable (b -> a) where constr f = constr (f undefined)
(=|=) :: (Data a, Constrable b) => a -> b -> Bool e =|= c = toConstr e == constr c
action :: Int -> IO String action n = print n >> getLine
test :: IO () test = do f <- action' putStr "enter n" n <- readLn putStrLn (f n)
42 (printed by action hello (typed by the user when getLine runs) enter n 42 (typed by the user when readLn runs) hello (printed by test)
transform const :: forall a b. ((a -> b) -> a) -> a
case P of (a -> b) -> add a to S, and prove b (-> introduction) (a ^ b) -> prove a, then prove b (and introduction) (a v b) -> try to prove a, if that doesn
for each conjunction `a ^ b` in S, add a and b to S (and elimination) for each disjunction `a v b` in S, try proving `(a -> P) ^ (b -> P)` (or elimination) for each implication `a -> P` is S, try proving `a` (-> elimination)
class Listable container where head :: container a -> a instance Listable [] where head (x:xs) = x instance Listable ByteString where --compiler error, wrong kind instance Listable SV.Vector where head v = SV.head --compiler error, can
class ListableMPTC container elem | container -> elem where
class ListableAT container where type Elem container :: *
class Seq a b | a -> b where head :: a -> b isTail :: a -> Bool instance Seq [a] a where head (x:xs) = x isTail = (== []) instance Seq ByteString Char
main = do putStr "Test input : " content <- getLine putStrLn content
import System.IO main = print =<< hGetBuffering stdout
toFloat :: (F.Storable word, F.Storable float) => word -> float toFloat word = F.unsafePerformIO $ F.alloca $ \buf -> do F.poke (F.castPtr buf) word F.peek buf
{- import Data.Word (Word32, Word64) import Data.Array.ST (newArray, castSTUArray, readArray, MArray, STUArray) import GHC.ST (runST, ST) wordToFloat :: Word32 -> Float wordToFloat x = runST (cast x) floatToWord :: Float -> Word32 floatToWord x = runST (cast x) wordToDouble :: Word64 -> Double wordToDouble x = runST (cast x) doubleToWord :: Double -> Word64 doubleToWord x = runST (cast x) {- cast :: (MArray (STUArray s) a (ST s), MArray (STUArray s) b (ST s)) => a -> ST s b cast x = newArray (0 :: Int, 0) x >>= castSTUArray >>= flip readArray 0
main = do inFile <- openFile "foo" ReadMode contents <- hGetContents inFile putStr contents hClose inFile
main = do inFile <- openFile "foo" ReadMode contents <- hGetContents inFile hClose inFile putStr contents
import Control.Parallel.Strategies (rnf) -- rnf means "reduce to normal form" main = do inFile <- openFile "foo" contents <- hGetContents inFile rnf contents `seq` hClose inFile -- force the whole file to be read, then close putStr contents
import qualified Data.ByteString as Str main = do contents <- Str.readFile "foo" -- readFile is strict, so the the entire string is read here Str.putStr contents
go fname = do putStrLn "reading" body <- readFile fname let body putStrLn body putStrLn "writing" writeFile fname body' return ()
Test> go "Foo.hs" reading writing Exception: Foo.hs: openFile: permission denied (Permission denied) Test>
main = do contents <- readFile "foo" putStr contents
main = do inFile <- openFile "foo" ReadMode contents <- hGetContents $! inFile contents `seq` hClose inFile putStr contents
saveDocument :: RawDocument -> DBAction () getDocuments :: DocumentFilter -> DBAction [RawDocument] getDocumentStats :: DBAction [(DocId, DocumentStats)]
data DBAction a = SaveDocument RawDocument (DBAction a) | GetDocuments DocumentFilter ([RawDocument] -> DBAction a) | GetDocumentStats ([(DocId, DocumentStats)] -> DBAction a) | Return a
instance Monad DBAction where return = Return SaveDocument doc k >>= f = SaveDocument doc (k >>= f) GetDocuments df k >>= f = GetDocuments df (k >=> f)
newtype DBM err a = DBM (ReaderT DB (EitherT err IO) a) deriving (Monad, MonadIO, MonadReader DB) indexImage :: (ImageId, UTCTime) -> Exif -> Thumbnail -> DBM SaveError () removeImage :: DB -> ImageId -> DBM DeleteError ()
class (Monad m) => MonadImageDB m where indexImage :: (ImageId, UTCTime) -> Exif -> Thumbnail -> m SaveResult removeImage :: ImageId -> m DeleteResult
data DBActionF next = SaveDocument RawDocument ( next) | GetDocuments DocumentFilter ([RawDocument] -> next) | GetDocumentStats ([(DocId, DocumentStats)] -> next)
data ImageActionF next = IndexImage (ImageId, UTCTime) Exif Thumbnail (SaveResult -> next) | RemoveImage ImageId (DeleteResult -> next)
class Monad m => MonadAddDel m where add :: String -> m Int del :: Int -> m () set :: Int -> String -> m () add2 :: String -> String -> m (Int, Int) nop :: m ()
data AddDelF next = Add String ( Int -> next) | Del Int ( next) | Set Int String ( next) | Add2 String String (Int -> Int -> next) | Nop ( next) deriving (Functor)
run :: MonadAddDel m => Free AddDelF a -> m a run (Pure a) = return a run (Free (Add x next)) = add x >>= run . next run (Free (Del id next)) = del id >> run next run (Free (Set id x next)) = set id x >> run next run (Free (Add2 x y next)) = add2 x y >>= \ids -> run (next (fst ids) (snd ids)) run (Free (Nop next)) = nop >> run next
instance MonadAddDel (Free AddDelF) where add x = Free . (Add x ) $ Pure del id = Free . (Del id ) $ Pure () set id x = Free . (Set id x) $ Pure () add2 x y = Free . (Add2 x y) $ \id1 id2 -> Pure (id1, id2) nop = Free . Nop $ Pure ()
example1 :: MonadAddDel m => m () example1 = do id <- add "Hi" del id nop (id3, id4) <- add2 "Hello" "World" set id4 "Again"
debugInterpreter :: Free AddDelF a -> IO a debugInterpreter = go 0 where go n (Pure a) = return a go n (Free (Add x next)) = do print $ "Adding " ++ x ++ " with id " ++ show n go (n+1) (next n) go n (Free (Del id next)) = do print $ "Deleting " ++ show id go n next go n (Free (Set id x next)) = do print $ "Setting " ++ show id ++ " to " ++ show x go n next go n (Free (Add2 x y next)) = do print $ "Adding " ++ x ++ " with id " ++ show n ++ " and " ++ y ++ " with id " ++ show (n+1) go (n+2) (next n (n+1)) go n (Free (Nop next)) = do print "Nop" go n next main = do debugInterpreter example1 debugInterpreter . run $ example1
$ cd $YOUR_PACKAGE_DIR $ ghci -no-user-package-db -package-db .cabal-sandbox/i386-linux-ghc-7.6.1-packages.conf.d $ ghci -no-user-package-conf -package-conf .cabal-sandbox/i386-linux-ghc-7.4.2-packages.conf.d
class JSONSchema a where schema :: Proxy a -> Schema
{- schemaOf :: JSONSchema a => a -> Schema a schemaOf (v :: x) = schema (Proxy :: Proxy x) -- With proxy schemaOf (v :: x) = schema :: Schema x -- With `:: a` schemaOf _ = schema -- Even simpler with `:: a`
f :: forall proxy a. (Read a, Show a) => proxy a -> String -> String f _ = (show :: a -> String) . read
> f (Proxy :: Proxy Int) "3" "3" > f (Proxy :: Proxy Bool) "3" "*** Exception: Prelude.read: no parse
f :: Input -> Output f = g . h where h :: Gr graph Data => Input -> graph Data g :: Gr graph Data => graph Data -> Output
class MightBeA t a where isA :: proxy t -> a -> Maybe t fromA :: t -> a instance MightBeA t t where isA _ = Just fromA = id instance MightBeA t (Either t b) where isA _ (Left i) = Just i isA _ _ = Nothing fromA = Left instance MightBeA t b => MightBeA t (Either a b) where isA p (Right xs) = isA p xs isA _ _ = Nothing fromA = Right . fromA
instance MightBeA -- no proxy argument isA isA fromA
class JSONSchema a where schema :: proxy a -> Schema
data Free f a = Pure a | Free (f (Free f a)) instance Functor f => Monad (Free f) where return = Pure Pure a >>= f = f a Free m >>= f = Free ((>>= f) <$> m)
instance Contravariant PS where contramap f (PS g) = PS (g . f)
> let x = fromList [0, -1, 0/0, -5, -6, -3] :: Set Float
data MyDataType = Foo | Bar | Baz instance Enum MyDataType toEnum 0 = Foo toEnum 1 = Bar toEnum 2 = Baz fromEnum Foo = 0 fromEnum Bar = 1 fromEnum Baz = 2
instance Enum MyDataType where fromEnum = fromJust . flip lookup table toEnum = fromJust . flip lookup (map swap table) table = [(Foo, 0), (Bar, 1), (Baz, 2)]
{- import Data.Data data MyDataType = Foo | Bar | Baz deriving (Eq, Show, Data, Typeable) toNumber enum = case enum of Foo -> 1 Bar -> 2 Baz -> 4
table = map (\cData -> let c = (fromConstr cData :: MyDataType) in (c, toNumber c) ) $ dataTypeConstrs $ dataTypeOf Foo
λ: data MyDataType = Foo | Bar | Baz deriving (Enum, Show, Eq) λ: [Foo ..] [Foo,Bar,Baz]
arbitrary e = case e of Foo -> 10 Bar -> 200 Baz -> 3000
printElements :: [String] -> IO() printElements (x:xs) = print x (some kind of newline, then loop?) printElements xs
Prelude> mapM_ print ["1","2","3","4"] "1" "2" "3" "4" Prelude>
print :: Show a => a -> IO () print x = putStrLn (show x)
Prelude> mapM_ putStrLn ["1","2","3","4"] 1 2 3 4 Prelude>
Prelude> unlines ["1","2","3","4"] "1\n2\n3\n4\n" Prelude>
Prelude> putStr ( unlines ["1","2","3","4"] ) 1 2 3 4 Prelude>
printElements :: [String] -> IO() printElements [] = return () printElements (x:xs) = do putStrLn x printElements xs
printElements :: [String] -> IO() printElements = mapM_ putStrLn
printElements :: [String] -> IO () printElements = mapM_ putStrLn
-- Put the a in the box. box :: a -> Box a box a f = f a
-- Get the a out of the box. unbox :: Box a -> a unbox f = f id
unbox . box = {- definition of (.) -} \b -> unbox (box b) = {- definition of unbox and (f a) b = f a b -} \b -> box b id = {- definition of box -} \b -> id b = {- definition of id -} \b -> b = {- definition of id, backwards -} id
newtype Cont b a = Cont ((a -> b) -> b) newtype Cod a = Cod (forall b. (a -> b) -> b)
box . unbox = {- definition of (.) -} \m -> box (unbox m) = {- definition of box -} \m f -> f (unbox m) = {- definition of unbox -} \m f -> f (m id) = {- free theorem: f (m id) = m f -} \m f -> m f = {- eta: (\f -> m f) = m -} \m -> m = {- definition of id, backwards -} id
m :: (Bool -> b) -> b m k = seq (k true) (k false) f :: Bool -> Int f x = if x then ⊥ else 2`
f (m id) = {- definition f -} if (m id) then ⊥ else 2 = {- definition of m -} if (seq (id true) (id false)) then ⊥ else 2 = {- definition of id -} if (seq true (id false)) then ⊥ else 2 = {- definition of seq -} if (id false) then ⊥ else 2 = {- definition of id -} if false then ⊥ else 2 = {- definition of if -} 2 m f = {- definition of m -} seq (f true) (f false) = {- definition of f -} seq (if true then ⊥ else 2) (f false) = {- definition of if -} seq ⊥ (f false) = {- definition of seq -} ⊥
type StateArray a = Control.Monad.State (ST s (STArray s Int Int)) a
import Control.Monad import Control.Monad.ST import Data.Array.ST import Data.Array.Unboxed primesUpto :: Int -> [Int] primesUpto n = [p | (p, True) <- assocs $ sieve n] sieve :: Int -> UArray Int Bool sieve n = runSTUArray $ do sieve <- newArray (2, n) True forM_ [2..n] $ \p -> do isPrime <- readArray sieve p when isPrime $ do forM_ [p*2, p*3 .. n] $ \k -> do writeArray sieve k False return sieve
data HList ls where Nil :: HList Cons :: x -> HList xs -> HList (x
returnIO :: a -> IO a returnIO x = IO $ \ s -> ( bindIO :: IO a -> (a -> IO b) -> IO b bindIO (IO m) k = IO $ \ s -> case m s of (
{- | A value of type @ does some I\/O before returning a value of type @a@. There is really only one way to \"perform\" an I\/O action: bind it to @Main.main@ in your program. When your program is run, the I\/O will be performed. It isn function, unless that function is itself in the at some point, directly or indirectly, from @Main.main@. or the -} newtype IO a = IO (State
instance Monad IO where {- {- {- m >> k = m >>= \ _ -> k return = returnIO (>>=) = bindIO fail s = failIO s returnIO :: a -> IO a returnIO x = IO $ \ s -> ( bindIO :: IO a -> (a -> IO b) -> IO b bindIO (IO m) k = IO $ \ s -> case m s of (
main :: IO () main = putStr "hello" >> return " world" >>= putStrLn
main :: IO () main = putStr "hello" and then, do nothing, but the result of doing nothing is " world" and then, using the result of the previous action, putStrLn
import Data.Dynamic import Data.Typeable apply :: Dynamic -> [Dynamic] -> Dynamic apply f [] = f apply f (x:xs) = apply (f `dynApp` x) xs
headF :: ListF a b -> b headF (Cons b _) = b mapF :: (b -> c) -> ListF a b -> ListF a c mapF f (Cons v fs) = Cons (f v) (mapF (f.) fs) partialApply :: ListF a b -> [a] -> ListF a b partialApply fs [] = fs partialApply (Cons f fs) (x:xs) = partialApply (mapF ($x) fs) xs apply :: ListF a b -> [a] -> b apply f xs = headF (partialApply f xs)
sumF :: Num a => ListF a a sumF = Cons 0 (mapF (+) sumF) sumExample = apply sumF [3, 4, 5]
f True True True = 32 f True True False = 67 f _ _ _ = 9 tooMany = error "too many arguments" tooFew = error "too few arguments" lift0 v = Cons v tooMany lift1 f = Cons tooFew (lift0 f) lift2 f = Cons tooFew (lift1 f) lift3 f = Cons tooFew (lift2 f) fF1 = lift3 f fExample1 = apply fF1 [True, True, True] fExample2 = apply fF1 [True, False] fExample3 = apply (partialApply fF1 [True, False]) [False]
class Lift n a b where type I n a b :: * lift :: n -> I n a b -> ListF a b instance Lift Z a b where type I Z a b = b lift _ b = Cons b tooMany instance (Lift n a (a -> b), I n a (a -> b) ~ (a -> I n a b)) => Lift (S n) a b where type I (S n) a b = a -> I n a b lift (S n) f = Cons tooFew (lift n f)
fF2 = lift (S (S (S Z))) f fExample4 = apply fF2 [True, True, True] fExample5 = apply fF2 [True, False] fExample6 = apply (partialApply fF2 [True, False]) [False]
{- {- {- {- {- class Apply f a r | f -> a r where apply :: f -> [a] -> r instance Apply f a r => Apply (a -> f) a r where apply f (a:as) = apply (f a) as instance Apply r a r where apply r _ = r test = apply ((+) :: Int -> Int -> Int) [1::Int,2] apply apply test
type let rec apply (f: match (lst,f) with | ([],_) -> f | ((x::xs), RecFunction z) -> apply (z x) xs
{- -- n represents function type, o represents output type data LApp n o where -- no arguments applied (function and output type are the same) End :: LApp o o -- intentional similarity to ($) (:$) :: a -> LApp m o -> LApp (a -> m) o infixr 5 :$ -- same as :
-- the apply function listApply :: n -> LApp n o -> o listApply fun End = fun listApply fun (p :$ l) = listApply (fun p) l
-- showing off the power of AppL main = do print . listApply reverse $ "yrruC .B lleksaH" :$ End print . listApply (*) $ 1/2 :$ pi :$ End print . listApply ($) $ head :$ [1..] :$ End print $ listApply True End
-- Alternative definition -- data FList n o a where -- Nil :: FList o o a -- Cons :: a -> FList f o a -> FList (a -> f) o a
instance Show (a -> b) where show a = "function" apply :: Num a => (a -> a) -> [a] -> (a -> a) apply f [] = f apply f (x:xs) = apply ((\_ -> f) (f x)) xs
pure f <*> [arg] <*> [arg2] ... -- example λ>pure (\a b c -> (a*b)+c) <*> [2,4] <*> [3] <*> [1] [7,13] λ>pure (+) <*> [1] <*> [2] [3]
λ>pure (+1) <*> [1..10] [2,3,4,5,6,7,8,9,10,11] -- Or, apply (+1) to items 1 through 10 and collect the results in a list λ>pure (+) <*> [1..5] <*> [1..5] [2,3,4,5,6,3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,6,7,8,9,10] {- The applicative instance of list gives you every possible combination of elements from the lists provided, so that is every possible sum of pairs between one and five -} λ>pure (\a b c -> (a*b)+c) <*> [2,4] <*> [4,3] <*> [1] [9,7,17,13] {- that Or, I am repeating argC when I call this function twice, but a and b are different -} λ>pure (\a b c -> show (a*b) ++ c) <*> [1,2] <*> [3,4] <*> [" look mah, other types"] ["3 look mah, other types","4 look mah, other types","6 look mah, other types","8 look mah, other types"]
data Rec a = Rec {unrec :: Rec a -> a} y :: (a -> a) -> a y f = u (Rec u) where u x = f $ unrec x x
root = AP left_n en left_n = AP left_n-1 en-1 ... left_2 = AP left_1 e1 left_1 = FUN f
Alloc Copied Live GC GC TOT TOT Page Flts bytes bytes bytes user elap user elap [...] 5476616 44504 2505736 0.00 0.00 23.21 410.03 0 0 (Gen: 0) 35499296 41624 2603032 0.00 0.00 23.26 410.25 0 0 (Gen: 0) 51841800 46848 2701592 0.00 0.00 23.32 410.49 0 0 (Gen: 0) 31259144 36416 2612088 0.00 0.00 23.40 410.61 0 0 (Gen: 0) 53433632 51976 2742664 0.00 0.00 23.49 412.05 0 0 (Gen: 0) 48142768 50928 2784744 0.00 0.00 23.54 412.49 0 0 (Gen: 0) [...]
backward lf n (out,tar) das = do let δout = tr (derivate lf (tar, out)) -- dE/dy deltas = scanr (\(l, a return (deltas)
grad lf (n, (i,t)) = do -- forward propagation: compute layers outputs and activation derivatives let (as, as (out) = last as (ds) <- backward lf n (out, t) (init as let r = fromIntegral $ rows i -- size of minibatch let gs = zipWith (\δ a -> tr (δ <> a)) ds (i:init as) --gradients for weights return $ GradBatch ((recip r .*) <$> gs, (recip r .*) <$> squeeze <$> ds)
move lr (n, (i,t)) (GradBatch (gs, ds)) = do -- update function let update = (\(FC w b af) g δ -> FC (w + (lr).*g) (b + (lr).*δ) af) n return (n
mse :: (Floating a) => LossFunction a a mse = let f (y,y f in Evaluator f f'
f1 = do x <- [1,2] [x, x+1] -- this is monad, right? f2 = do x <- [1,2] return [x, x+1]
concatMap :: (a -> [b]) -> [a] -> [b] concatMap f xs = concat (map f xs)
[1,2] >>= (\x-> [x,x+1]) === concatMap (\x-> [ x,x+1 ]) [1,2] [1,2] >>= (\x-> return [x,x+1]) === concatMap (\x-> [ [x,x+1] ]) [1,2]
-- WRONG: type mismatch [1,2] >>= (\x-> (x,x+1)) === concatMap (\x-> ( x,x+1 )) [1,2] -- OK: [1,2] >>= (\x-> return (x,x+1)) === concatMap (\x-> [ (x,x+1) ]) [1,2]
ma >>= famb === join (fmap famb ma) -- famb :: a -> m b, m ~ [] join (fmap (\x-> [x,x+1]) [1,2]) = concat [ [ x,x+1 ] | x<-[1,2]] join (fmap (\x-> (x,x+1)) [1,2]) = concat [ ( x,x+1 ) | x<-[1,2]] -- WRONG join (fmap (\x-> return [x,x+1]) [1,2]) = concat [ [ [x,x+1] ] | x<-[1,2]] = [y | x<-[1,2], y<-[ x,x+1 ]] {- WRONG -} = [y | x<-[1,2], y<-( x,x+1 )] = [y | x<-[1,2], y<-[[x,x+1]]]
f1 = [1,2] >>= \x -> [x, x+1] f2 = [1,2] >>= \x -> return [x, x+1]
class Monad m where (>>=) :: m a -> (a -> m b) -> m b return :: a -> m a
instance Monad [] where (>>=) :: [a] -> (a -> [b]) -> [b] ...
instance Monad [] where m >>= k = foldr ((++) . k) [] m return x = [x] ...
f1 = concatMap (\x -> [x, x+1]) [1,2] f2 = concatMap (\x -> [[x, x+1]]) [1,2]
(->) :: * -> * -> * a :: * b :: * --------------------- a -> b :: *
{- newtype Void = Void (forall a b. a -> b) absurd :: Void -> a absurd (Void f) = f f
bool :: Memo Bool bool f = table (f True, f False) where table (t,f) True = t table (t,f) False = f
maybe :: Memo a -> Memo (Maybe a) maybe ma f = table (f Nothing, ma (f . Just)) where table (n,j) Nothing = n table (n,j) (Just x) = j x
1 10 100 1000 1001 101 1010 1011 11 110 1100 1101 111 1110 1111
boundedMemo :: Integer -> Memo Integer boundedMemo bound f = \z -> if z < bound then memof z else f z where memof = integral f
memo :: MonadState ... m => ((Integer -> m r) -> (Integer -> m r)) -> m (Integer -> m r)
-- | Memoize an ordered type with a bits instance. bits :: (Ord a, Bits a) => Memo a bits f = IntTrie.apply (fmap f IntTrie.identity)
Memo.integral f => wrap fromInteger toInteger bits f => bits (f . fromInteger) . toInteger => IntTrie.apply (fmap (f . fromInteger) IntTrie.identity) . toInteger ~> (semantically equivalent) (map (f . fromInteger) [0..] !!) . toInteger
palindromize :: IO () palindromize = do a <- readFile "foo.txt" let b = reverse a putStrLn (a ++ b)
makeMess :: IO () makeMess = do a <- readFile "foo.txt" let b = reverse a putStrLn (a ++ b) let b = a putStrLn (a ++ b)
left :: a -> (a -> r) -> (b -> r) -> r left x l _ = l x right :: b -> (a -> r) -> (b -> r) -> r right x _ r = r x match :: (a -> r) -> (b -> r) -> ((a -> r) -> (b -> r) -> r) -> r match l r k = k l r -- Or, with a type synonym for convenience: type Either a b r = (a -> r) -> (b -> r) -> r left :: a -> Either a b r right :: b -> Either a b r match :: (a -> r) -> (b -> r) -> Either a b r -> r
Prelude> let (a, 10) = (15, 15) in a *** Exception: <interactive>:5:5-22: Irrefutable pattern failed for pattern (a, 10)
Prelude> let (a, 10) = (15, 15) in "Something else" "Something else"
Prelude> let (a, 10, 999) = (15, 15) in "Something else" <interactive>:7:20: error: • Couldn with actual type ‘(Integer, Integer)’ • In the expression: (15, 15) In a pattern binding: (a, 10, 999) = (15, 15) In the expression: let (a, 10, 999) = (15, 15) in "Something else" • Relevant bindings include a :: t (bound at <interactive>:7:6)
Prelude Control.Applicative Data.List Database.HDBC Database.HDBC.Sqlite3 System.Directory>
import Control.Applicative import Data.Char import Data.List :set prompt "> "
GHCi, version 6.12.1: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. > toLower <$> "Hello, world!" "hello, world!" >
:set -isrc:dist/build/autogen :set -hide-package mtl
data Cell = Cell { x :: Int, y :: Int } deriving (Show)
instance Arbitrary Cell where arbitrary = do Positive x <- arbitrary Positive y <- arbitrary return $ Cell x y
instance Arbitrary Cell where arbitrary = Cell <$> pos <*> pos where pos = getPositive <$> arbitrary -- getPositive requires QC >= 2.5
template <T> struct Maybe { bool isJust; T value; };
fibs :: Num a => [a] fibs@(_:xs) = 0:1:zipWith (+) fibs xs
map (`div` 2) fibs -- integral context (fibs !! 10) + 1.234 -- rational context map (:+ 1.0) fibs -- Complex context
permutations :: [a] -> [[a]] permutations xs0 = xs0 : perms xs0 [] where perms [] _ = [] perms (t:ts) is = foldr interleave (perms ts (t:is)) (permutations is) where interleave xs r = let (_,zs) = interleave interleave interleave in (y:us, f (t:y:us) : zs)
length (take (factorial n) $ permutations ([1..n] ++ undefined))) `seq` () == ()
map (take n) (take (factorial n) $ permutations [1..]) == permutations [1..n]
map (take n) (take (factorial n) $ permutations ([1..n] ++ undefined)) == permutations [1..n]
permutations [] = [[]] permutations xxs = [(y:ys) | (y,xs) <- picks xxs, ys <- permutations xs] where picks (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- picks xs]
permutations [] = [[]] permutations (x:xs) = [y | p <- permutations xs, y <- interleave p] where interleave [] = [[x]] interleave (y:ys) = (x:y:ys) : map (y:) (interleave ys)
interleave yss = (x:yss) : interleave interleave interleave
permutations xxs = xxs : permutations permutations permutations where interleave = ..
permutations = tail $ concatMap interleave $ permutations xs = tail $ interleave xs ++ concatMap interleave (permutations = tail $ (x:xs) : interleave = interleave
permutations xxs = xxs : permutations permutations permutations where interleave yss = (x:yss) : interleave interleave interleave
permutations where interleave f yss = f (x:yss) : interleave interleave interleave
permutations where interleave f yss r = f (x:yss) : interleave interleave interleave
*Main> let n = 4 *Main> map (take n) (take (factorial n) $ permutations ([1..n] ++ undefined)) [[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1]*** Exception: Prelude.undefined
[1..n] == [] ++ 1 : [2..n] == [1] ++ 2 : [3..n] == [1,2] ++ 3 : [4..n]
permutations xs = xs : concat (zipWith newPerms (init $ tail $ tails xs) (init $ tail $ inits xs)) where newPerms (t:ts) = map (++ts) . concatMap (interleave t) . permutations3 interleave t [y] = [[t, y]] interleave t ys@(y:ys
*Main> let xs = [1..5] in zip (init $ tail $ tails xs) (init $ tail $ inits xs) [([2,3,4,5],[1]),([3,4,5],[1,2]),([4,5],[1,2,3]),([5],[1,2,3,4])]
permutations xs = xs : concat (zipWith newPerms (tails xs) (inits xs)) where newPerms [] is = [] newPerms (t:ts) is = map (++ts) (concatMap (interleave t) (permutations is)) interleave t [] = [] interleave t ys@(y:ys
tails xxs = xxs : case xxs of [] -> [] (_:xs) -> tails xs inits xxs = [] : case xxs of [] -> [] (x:xs) -> map (x:) (inits xs)
permutations xs = xs : concat (newPerms where newPerms newPerms xxs is : case xxs of [] -> [] (x:xs) -> newPerms newPerms [] is = [] newPerms (t:ts) is = map (++ts) (concatMap (interleave t) (permutations3 is))
permutations xs = xs : concat (newPerms where newPerms newPerms map (++ts) (concatMap (interleave t) (permutations is)) : newPerms
permutations xs = xs : newPerms where newPerms newPerms concatMap interleave (permutations is) ++ newPerms where interleave [] = [] interleave (y:ys) = (t:y:ys++ts) : map (y:) (interleave ys)
permutations xs = xs : newPerms where newPerms newPerms foldr (interleave id) (newPerms where interleave f [] r = r interleave f (y:ys) r = f (t:y:ys++ts) : interleave (f . (y:)) ys r
permutations xs = xs : newPerms where newPerms newPerms foldr interleave (newPerms where interleave ys r = let (_,zs) = interleave interleave interleave let (us,zs) = interleave in (y:us, f (t:y:us) : zs)
[[1..]] ++ [[2,1,3..]] ++ [[3,2,1,4..], [2,3,1,4..]] ++ [[3,1,2,4..], [1,3,2,4..]] [[4,3,2,1,5..], etc
perms (t:ts) is = <prepend_stuff_to> (perms ts (t:is))
y = 1, f = id y = 2, f = (id . (1:)) y = 3, f = ((id . (1:)) . (2:)) (the functions are conceptually the same as ([]++), ([1]++), and ([1,2]++) respectively)
([1,2]++) (4:3:[5..]) === [1,2,4,3,5..] ([1]++) (4:2[3,5..]) === [1,4,2,3,5..] ([]++) (4:1[2,3,5..]) === [4,1,2,3,5..]
map toLower "FOO" fmap toLower "FOO" toLower <$> "FOO"
mapSubFrom5 x = map (sub 5) x *Main> mapSubFrom5 [1,2,3,4,5] [4,3,2,1,0]
mapSub5 x = map sub5 x where sub5 x = sub x 5 *Main> mapSub5 [1,2,3,4,5] [-4,-3,-2,-1,0]
>>> spoon True :: Maybe Bool Just True >>> spoon (error "fork") :: Maybe Bool Nothing >>> spoon undefined :: Maybe Bool Nothing >>> spoon (let x = x in x) :: Maybe Bool <... let
>>> try $ return (error "thimble") :: IO (Either SomeException Bool) Right *** Exception: thimble
data User = User { name :: String , birthDate :: Date }
data Message = Message { user :: User , timestamp :: Date , content :: String }
data User = User { name :: String , birthDate :: Date , messages :: [(String, Date)] -- you get the idea }
newtype Id a = Id Integer type Table a = Map (Id a) a
data User = User { name :: String , birthDate :: Date } deriving (Ord, Typeable) data Message = Message { user :: User , timestamp :: Date , content :: String } deriving (Ord, Typeable) instance Indexable Message where empty = ixSet [ ixGen (Proxy :: Proxy User) ]
user1 = User "John Doe" undefined user2 = User "John Smith" undefined messageSet = foldr insert empty [ Message user1 undefined "bla" , Message user2 undefined "blu" ]
data User = User { name :: String , birthDate :: Date , messages :: [Message] } deriving (Ord, Typeable) data Message = Message { users :: [User] , timestamp :: Date , content :: String } deriving (Ord, Typeable)
instance Indexable Message where empty = ixSet [ ixFun users ] instance Indexable User where empty = ixSet [ ixFun messages ]
userSet = foldr insert empty [ User "John Doe" undefined [ messageFoo, messageBar ] , User "John Smith" undefined [ messageBar ] ]
data UserMessage = UserMessage { umUser :: User, umMessage :: Message } instance Indexable UserMessage where empty = ixSet [ ixGen (Proxy :: Proxy User), ixGen (Proxy :: Proxy Message) ]
{- module Main (main) where import Data.Int import Data.Data import Data.IxSet import Data.Typeable -- use newtype for everything on which you want to query; -- IxSet only distinguishes indexes by type data User = User { userId :: UserId , userName :: UserName } deriving (Eq, Typeable, Show, Data) newtype UserId = UserId Int64 deriving (Eq, Ord, Typeable, Show, Data) newtype UserName = UserName String deriving (Eq, Ord, Typeable, Show, Data) -- define the indexes, each of a distinct type instance Indexable User where empty = ixSet [ ixFun $ \ u -> [userId u] , ixFun $ \ u -> [userName u] ] -- this effectively defines userId as the PK instance Ord User where compare p q = compare (userId p) (userId q) -- make a user set userSet :: IxSet User userSet = foldr insert empty $ fmap (\ (i,n) -> User (UserId i) (UserName n)) $ zip [1..] ["Bob", "Carol", "Ted", "Alice"] main :: IO () main = do -- Here, it showMe "user 1" $ userSet @= (UserId 1) showMe "user Carol" $ userSet @= (UserName "Carol") showMe "users with ids > 2" $ userSet @> (UserId 2) where showMe :: (Show a, Ord a) => String -> IxSet a -> IO () showMe msg items = do putStr $ "-- " ++ msg let xs = toList items putStrLn $ " [" ++ (show $ length xs) ++ "]" sequence_ $ fmap (putStrLn . show) xs
{- {- {- {- import Opaleye import Data.Profunctor.Product (p2, p3) import Data.Profunctor.Product.TH (makeAdaptorAndInstance) import Control.Arrow (returnA) data UserId a = UserId { unUserId :: a } $(makeAdaptorAndInstance "pUserId" data User , name :: b , birthDate :: c } $(makeAdaptorAndInstance "pUser" type User = User (Column PGText) (Column PGDate) data Message , timestamp :: b , content :: c } $(makeAdaptorAndInstance "pMessage" type Message = Message (Column PGDate) (Column PGText) userTable :: Table User User userTable = Table "user_table" (pUser User { userId = pUserId (UserId (required "user_id")) , name = required "name" , birthDate = required "birthdate" }) messageTable :: Table Message Message messageTable = Table "message_table" (pMessage Message { user = pUserId (UserId (required "user_id")) , timestamp = required "timestamp" , content = required "content" })
usersJoinMessages :: Query (User, Message) usersJoinMessages = proc () -> do aUser <- queryTable userTable -< () aMessage <- queryTable messageTable -< () restrict -< unUserId (userId aUser) .== unUserId (user aMessage) returnA -< (aUser, aMessage)
record Sg (S : Set)(T : S -> Set) : Set where constructor _,_ field fst : S snd : T fst open Sg data _==_ {X : Set}(x : X) : X -> Set where refl : x == x
Q : {S T : Set}(f g : S -> T) -> Set Q {S}{T} f g = Sg S \ s -> f s == g s
_o_ : {R S T : Set} -> (S -> T) -> (R -> S) -> R -> T (f o g) x = f (g x)
mediator : {R S T : Set}(f g : S -> T)(h : R -> S) -> (q : (f o h) == (g o h)) -> Sg (R -> Q f g) \ u -> h == (fst o u)
funq : {S T : Set}{f g : S -> T} -> f == g -> (s : S) -> f s == g s funq refl s = refl
mediatorUnique : {R S T : Set}(f g : S -> T)(h : R -> S) -> (qh : (f o h) == (g o h)) -> (m : R -> Q f g) -> (qm : h == (fst o m)) -> m == fst (mediator f g h qh)
mediatorUnique f g .(fst o m) qh m refl = ? ? : m == (\ r -> (fst (m r) , funq qh r))
snd (m _) != funq qh _ of type f (fst (m _)) == g (fst (m _))
postulate ext : {S T : Set}{f g : S -> T} -> ((s : S) -> f s == g s) -> f == g sndq : {S : Set}{T : S -> Set}{s : S}{t t t == t sndq refl = refl uip : {X : Set}{x y : X}{q q uip {q = refl}{q ? = ext (\ s -> sndq uip)
record Ex (S : Set)(T : S -> Set) : Set where constructor _,_ field fst : S .snd : T fst open Ex
Q : {S T : Set}(f g : S -> T) -> Set Q {S}{T} f g = Ex S \ s -> f s == g s
f, g: ([Int], Int) -> Int f (p,v) = treat p as a polynomial with given coefficients, and evaluate p(v). g _ = 0
{- import Prelude import qualified Data.Text as T import qualified Data.Text.IO as T fromString :: String -> T.Text fromString = T.pack main :: IO () main = T.putStrLn "Hello, world!"
TestStrings.hs:11:17: Couldn Expected type: [Char] -> String Actual type: String -> T.Text In the first argument of `putStrLn In the expression: putStrLn "Hello, world!"
TestStrings.hs:11:19: Not in scope: `fromString' Perhaps you meant `showString
import Control.Monad.Cont ... getCC :: MonadCont m => m (m a) getCC = callCC (\c -> let x = c x in return x) getCC getCC
import Control.Monad.Cont getCC getCC main :: IO () main = (`runContT` return) $ do (x, loopBack) <- getCC lift (print x) when (x < 10) (loopBack (x + 1)) lift (putStrLn "finish")
{- import Control.Monad.Cont import Control.Monad.Writer getCC :: MonadCont m => m (m a) getCC = callCC (\c -> let x = c x in return x) getCC getCC -- a simple monad transformer stack involving MonadCont and MonadWriter type APP= WriterT [String] (ContT () IO) runAPP :: APP a -> IO () runAPP a= runContT (runWriterT a) process where process (_,w)= do putStrLn $ unlines w return () driver :: Int -> APP () driver k = do tell [ "The quick brown fox ..." ] (x,loop) <- getCC collect x when (x<k) $ loop (x+1) collect :: Int -> APP () collect n= tell [ (show n) ] main :: IO () main = do runAPP $ driver 4
--replace in the above example type APP= ContT () (WriterT [String] IO) ... runAPP a = do (_,w) <- runWriterT $ runContT a (return . const ()) putStrLn $ unlines w
instance (MonadWriter w m) => MonadWriter w (ContT r m) where tell = lift . tell listen = undefined pass = undefined
func :: Int -> WriterT [String] (ErrorT String IO) Int func x = do liftIO $ print "start loop" tell [show x] if x < 4 then func (x+1) else throwError "aborted..." *Main> runErrorT $ runWriterT $ func 0 "start loop" "start loop" "start loop" "start loop" "start loop" Left "aborted..."
switch :: Int -> ErrorT String (WriterT [String] IO) () switch x = do liftIO $ print "start loop" tell [show x] if x < 4 then switch (x+1) else throwError "aborted..." *Main> runWriterT $ runErrorT $ switch 0 "start loop" "start loop" "start loop" "start loop" "start loop" (Left "aborted...",["0","1","2","3","4"])
type APP a = WriterT [String] (ContT () IO) a = ContT () IO (a,[String]) = ((a,[String]) -> IO()) -> IO()
{- , MultiParamTypeClasses , FunctionalDependencies , FlexibleContexts , FlexibleInstances , UndecidableInstances , OverlappingInstances
Prelude> seq undefined 5 *** Exception: Prelude.undefined
-- ok, lambda is outermost Prelude> seq (\x -> undefined) -- not ok. Because of the inner seq, `undefined` must be evaluated before -- the lambda is showing Prelude> seq (seq undefined (\x -> x)) *** Exception: Prelude.undefined
import Database.Persist.Types (PersistValue(PersistInt64)) getByIntId :: Integral i => i -> Handler (Maybe Person) getByIntId i = runDB $ get $ Key $ PersistInt64 (fromIntegral i)
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase| Users email String password String alias String deriving Show |] connStr = "host=localhost dbname=communis_db user=communis password=develpass port=5432" inBackend :: ReaderT SqlBackend (NoLoggingT (ResourceT IO)) a-> IO a inBackend action = runStderrLoggingT $ withPostgresqlPool connStr 10 $ \pool -> liftIO $ do flip runSqlPersistMPool pool $ do runMigration migrateAll action toUserId :: Int64 -> UsersId toUserId = toSqlKey get_user :: Int64 -> IO (Maybe Users) get_user = inBackend . get . toUserId delete_user :: Int64 -> IO () delete_user = inBackend . delete . toUserId
class Problem p s a where initial :: p s a -> s successor :: p s a -> s -> [(a,s)] goaltest :: p s a -> s -> Bool
data Problem s a { initial :: s, successor :: s -> [(a,s)], goaltest :: s -> Bool }
{- class Problem p s a where initial :: p s a -> s successor :: p s a -> s -> [(a,s)] goaltest :: p s a -> s -> Bool data CanonicalProblem s a = CanonicalProblem { initial successor goaltest } instance Problem CanonicalProblem s a where initial = initial' successor = successor' goaltest = goaltest' canonicalize :: Problem p s a => p s a -> CanonicalProblem s a canonicalize p = CanonicalProblem { initial successor goaltest }
instance Problem Foo s a where initial = initialFoo successor = successorFoo goaltest = goaltestFoo
-- definition of canonicalize canonicalize :: Problem p s a => p s a -> CanonicalProblem s a canonicalize x = CanonicalProblem { initial successor goaltest } -- specialize to the Problem instance for Foo s a canonicalize :: Foo s a -> CanonicalProblem s a canonicalize x = CanonicalProblem { initial successor goaltest }
data Q class Modulus a where value :: Tagged a Int instance Modulus Q where value = Tagged 5 f x y = (x+y) `mod` (proxy value (Proxy::Proxy Q))
data Q class Modulus a where value :: Proxy a -> Int instance Modulus Q where value _ = 5 f x y = (x+y) `mod` (value (Proxy::Proxy Q))
data P = Three | Default instance Modulus P where value Three = 3 value _ = 5 f x y = (x+y) `mod` (value (undefined :: P))
{- MultiParamTypeClasses, PolyKinds, FlexibleContexts, ScopedTypeVariables import Data.Tagged import Data.Proxy class Foo (a::[*]) b where foo:: Tagged a [b] instance Foo foo = Tagged [] instance (Foo xs Int) => Foo (x foo = Tagged $ 1 : (proxy foo (Proxy :: Proxy xs)) -- xs has kind [*] toUnary :: [Int] toUnary = proxy foo (Proxy :: Proxy
data Nat = Ze | Su Nat data List a = Nil | Cons a (List a) data Pair a b = Pair a b data Sum a b = L a | R b
{- module LazyVec where import Control.Monad.Primitive import Data.PrimRef import Data.Vector.Mutable (MVector) import qualified Data.Vector.Mutable as M import Data.Vector (fromList, thaw) import Control.Monad (forM_) data LazyVec m a = PrimMonad m => LazyVec (MVector (PrimState m) a) (PrimRef m [a]) -- prime the LazyVec with the first n elements lazyFromListN :: PrimMonad m => Int -> [a] -> m (LazyVec m a) lazyFromListN n xs = do let (as,bs) = splitAt n xs mvec <- thaw $ fromList as mref <- newPrimRef bs return $ LazyVec mvec mref -- look up the i lazyIndex :: PrimMonad m => Int -> LazyVec m a -> m a lazyIndex i lv@(LazyVec mvec mref) | i < 0 = error "negative index" | i < n = M.read mvec i | otherwise = do xs <- readPrimRef mref if null xs then error "index out of range" else do -- expand the mvec by some power of 2 -- so that it includes the i -- or ends let n let growth = n let (as, bs) = splitAt growth xs M.grow mvec $ if null bs then length as else growth forM_ (zip [n,n+1..] as) . uncurry $ M.write mvec writePrimRef mref bs lazyIndex i lv where n = M.length mvec
import System main = do [file1, file2] <- getArgs --copy file contents str <- readFile file1 writeFile file2 str
import System main = do [file1, file2] = getArgs str = readFile file1 writeFile file2 str
> :t writeFile writeFile :: FilePath -> String -> IO () > > :t readFile readFile :: FilePath -> IO String
main = do strFile <- readFile "testfile.txt" let analysisResult = stringAnalyzer strFile return analysisResult
main = do strFile <- readFile "testfile.txt" let analysisResult = stringAnalyzer strFile return analysisResult
main = do strFile <- readFile "testfile.txt" return (stringAnalyzer strFile)
main = readFile "testFile.txt" >>= \strFile -> return (stringAnalyser strFile)
main = readFile "testFile.txt" >>= (return . stringAnalyser)
main = fmap stringAnalyser (readFile "testFile.txt")
nameDo :: IO () nameDo = do putStr "What is your first name? " first <- getLine putStr "And your last name? " last <- getLine let full = first++" "++last putStrLn ("Pleased to meet you, "++full++"!")
name :: IO () name = putStr "What is your first name? " >> getLine >>= f where f first = putStr "And your last name? " >> getLine >>= g where g last = putStrLn ("Pleased to meet you, "++full++"!") where full = first++" "++last
nameLambda :: IO () nameLambda = putStr "What is your first name? " >> getLine >>= \first -> putStr "And your last name? " >> getLine >>= \last -> let full = first++" "++last in putStrLn ("Pleased to meet you, "++full++"!")
name = getName >>= welcome where ask :: String -> IO String ask s = putStr s >> getLine join :: [String] -> String join = concat . intersperse " " getName :: IO String getName = join <$> traverse ask ["What is your first name? ", "And your last name? "] welcome :: String -> IO () welcome full = putStrLn ("Pleased to meet you, "++full++"!")
f = ((ite . (<= 1)) `flip` 1) <*> (((+) . (f . (subtract 1))) <*> (f . (subtract 2))) where ite e x y = if e then x else y
do x <- getLine print (length x) y <- getLine return (x ++ y)
getLine >>= \x -> print (length x) >> getLine >>= \y -> return (x ++ y)
slice from to xs = take (to - from + 1) (drop from xs)
slice start end = take (end - start + 1) . drop start
takeStep :: Int -> [a] -> [a] takeStep _ [] = [] takeStep n (x:xs) | n >= 0 = x : takeStep n (drop (n-1) xs) | otherwise = takeStep (-n) (reverse xs) slice :: Int -> Int -> Int -> [a] -> [a] slice a e d xs = z . y . x $ xs -- a:start, e:stop, d:step where a e x = if d >= 0 then drop a y = if d >= 0 then take (e z = takeStep d test :: IO () -- slice works exactly in both languages test = forM_ t (putStrLn . show) where xs = [0..9] t = [slice 2 6 1 xs, -- [2, 3, 4, 5] slice 6 2 (-1) xs, -- [6, 5, 4, 3] slice 6 2 (-2) xs, -- [6, 4] slice (-8) 6 1 xs, -- [2, 3, 4, 5] slice 2 (-4) 1 xs, -- [2, 3, 4, 5] slice (-8)(-4) 1 xs, -- [2, 3, 4, 5] slice 6 (-8)(-1) xs, -- [6, 5, 4, 3] slice (-4) 2 (-1) xs, -- [6, 5, 4, 3] slice (-4)(-8)(-1) xs] -- [6, 5, 4, 3]
import Data.List slice :: Int -> Int -> [a] -> [a] slice start stop xs = fst $ splitAt (stop - start) (snd $ splitAt start xs)
Prelude Data.List> slice 0 2 [1, 2, 3, 4, 5, 6] [1,2] Prelude Data.List> slice 0 0 [1, 2, 3, 4, 5, 6] [] Prelude Data.List> slice 5 2 [1, 2, 3, 4, 5, 6] [] Prelude Data.List> slice 1 4 [1, 2, 3, 4, 5, 6] [2,3,4] Prelude Data.List> slice 5 7 [1, 2, 3, 4, 5, 6] [6] Prelude Data.List> slice 6 10 [1, 2, 3, 4, 5, 6] []
-- Where lst is an arbitrary list and indc is a list of indices [lst!!x|x<-[1..]] -- all of lst [lst!!x|x<-[1,3..]] -- odd-indexed elements of lst [lst!!x|x<-indc]
slice from to = reverse.snd.foldl build ((from, to + 1), []) where build res@((_, 0), _) _ = res build ((0, to), xs) x = ((0, to - 1), x:xs) build ((from, to), xs) _ = ((from - 1, to - 1), xs)
sublist start length = take length . snd . splitAt start slice start end = snd .splitAt start . take end
import Data.Vector ( fromList, slice, toList ) import Data.Function ( (&) ) vSlice :: Int -> Int -> [a] -> [a] vSlice start len xs = xs & fromList & slice start len & toList
print (drop 2 $ take 9 "Hello, World!") -- prints: "llo, Wo" -- This is the same: print (drop 2 (take 9 "Hello, World!")) -- prints: "llo, Wo"
"Hello, World!" !!! (2, 9) -- evaluates to "llo, Wo"
print $ "Hello, World!" !!! (2, 9) -- prints: "llo, Wo"
fib 0 = 1 fib 1 = 1 fib n | n >= 2 = fib (n-1) + fib (n-2)
fib n | n == 0 = 1 | n == 1 = 1 | n >= 2 = fib (n-1) + fib (n-2)
data StringSeq = Empty -- the empty sequence | Cat StringSeq StringSeq -- two sequences in succession | Single String -- a sequence holding a single element
slen :: StringSeq -> Int slen s = case s of Empty -> 0 Cat s s Single _ -> 1
let rec len lst = match lst with [] -> 0 | h :: t -> 1 + len t
let is_one_or_two num = match num with 1 -> true | 2 -> true | _ -> false
let a = [1;2;3];; match a with | [a;b] -> printfn "List contains 2 elements" | a::tail -> printfn "Head is %d" a | [] -> printfn "List is empty"
Prelude> :info ($) ($) :: (a -> b) -> a -> b -- Defined in GHC.Base infixr 0 $ Prelude> :info (+) class (Eq a, Show a) => Num a where (+) :: a -> a -> a infixl 6 +
type Either left right = forall output. (left -> output) -> (right -> output) -> output
ghci> let (|>) = flip ($) ghci> 3 |> (+4) |> (*6) 42
Prelude> let a $> b = b a Prelude> 1 $> (+2) 3 Prelude> sum [1, 2] $> (+2) 5 Prelude> map (+2) [1, 2] $> map (+3) [6,7]
Prelude Data.Aviary.BirdsInter> 1 `thrush` (+2) Loading package data-aviary-0.2.3 ... linking ... done. 3
import Data.Maybe data Op = Add | Sub | Mul | Div | And | Or | Not | Eq | Less | Great deriving (Eq, Show) data Exp = Literal Value | Primitive Op [Exp] | Variable String | If Exp Exp Exp | Let [(String, Exp)] Exp deriving (Show, Eq) data Value = Number Int | Bool Bool | String String deriving (Eq, Show) type Env = [(String, Value)] eval :: Env -> Exp -> Value eval e (Literal v) = v eval e (Variable x) = fromJust (lookup x e) --22 prim :: Op -> [Value] -> Value prim Add [Number a, Number b] = Number (a + b) prim And [Bool a, Bool b] = Bool (a && b) prim Sub [Number a, Nuamber b] = Number (a - b) -- No instance for (Fractional Int) arising from a use of `/' prim Mul [Number a, Number b] = Number (a * b) prim Div [Number a, Number b] = Number (a / b) prim Or [Bool a, Bool b] = Bool (a || b) prim Not [Bool a] = Bool (not a) prim Eq [Number a, Number b] = Bool (a == b) prim Eq [String a, String b] = Bool (a == b) prim Less [Number a, Number b] = Bool (a < b) prim Less [String a, String b] = Bool (a < b) prim Great [Number a, Number b] = Bool (a > b) prim Great [String a, String b] = Bool (a > b) --37 main = do eval [("y", (Number 40))] (Let [("x", (Literal (Number 2)))] (prim Add [(Variable "x"), (Variable "y")])) -- Couldn
-- No instance for (Fractional Int) arising from a use of `/'
Let [("x", (Literal (Number 2)))] (prim Add [(Variable "x"), (Variable "y")])
Prelude> :i (/) class Num a => Fractional a where (/) :: a -> a -> a ... -- Defined in `GHC.Real' infixl 7 / Prelude> :i Int data Int = GHC.Types.I instance Bounded Int -- Defined in `GHC.Enum' instance Enum Int -- Defined in `GHC.Enum' instance Eq Int -- Defined in `GHC.Classes' instance Integral Int -- Defined in `GHC.Real' instance Num Int -- Defined in `GHC.Num' instance Ord Int -- Defined in `GHC.Classes' instance Read Int -- Defined in `GHC.Read' instance Real Int -- Defined in `GHC.Real' instance Show Int -- Defined in `GHC.Show'
module Treefold where -- treefold (*) z [a,b,c,d,e,f] = (((a*b)*(c*d))*(e*f)) treefold f zero [] = zero treefold f zero [x] = x treefold f zero (a:b:l) = treefold f zero (f a b : pairfold l) where pairfold (x:y:rest) = f x y : pairfold rest pairfold l = l -- here l will have fewer than 2 elements module Heapsort where import Treefold data Heap a = Nil | Node a [Heap a] heapify x = Node x [] heapsort :: Ord a => [a] -> [a] heapsort = flatten_heap . merge_heaps . map heapify where merge_heaps :: Ord a => [Heap a] -> Heap a merge_heaps = treefold merge_heap Nil flatten_heap Nil = [] flatten_heap (Node x heaps) = x:flatten_heap (merge_heaps heaps) merge_heap heap Nil = heap merge_heap node_a@(Node a heaps_a) node_b@(Node b heaps_b) | a < b = Node a (node_b: heaps_a) | otherwise = Node b (node_a: heaps_b)
{- import Control.Monad (forM, forM_) import Control.Monad.ST (ST, runST) import Data.Array.MArray (newListArray, readArray, writeArray) import Data.Array.ST (STArray) import Data.STRef (newSTRef, readSTRef, writeSTRef) heapSort :: forall a. Ord a => [a] -> [a] heapSort list = runST $ do let n = length list heap <- newListArray (1, n) list :: ST s (STArray s Int a) heapSizeRef <- newSTRef n let heapifyDown pos = do val <- readArray heap pos heapSize <- readSTRef heapSizeRef let children = filter (<= heapSize) [pos*2, pos*2+1] childrenVals <- forM children $ \i -> do childVal <- readArray heap i return (childVal, i) let (minChildVal, minChildIdx) = minimum childrenVals if null children || val < minChildVal then return () else do writeArray heap pos minChildVal writeArray heap minChildIdx val heapifyDown minChildIdx lastParent = n `div` 2 forM_ [lastParent,lastParent-1..1] heapifyDown forM [n,n-1..1] $ \i -> do top <- readArray heap 1 val <- readArray heap i writeArray heap 1 val writeSTRef heapSizeRef (i-1) heapifyDown 1 return top
data Heap a = Empty | Heap a (Heap a) (Heap a) fromList :: Ord a => [a] -> Heap a toSortedList :: Ord a => Heap a -> [a] heapSort = toSortedList . fromList
import Data.Array fromList xs = heapify 0 where size = length xs elems = listArray (0, size - 1) xs :: Array Int a heapify n = ...
const id 1 2 -- Haskell evaluates -- constId 1 2 -- Haskell now evaluates id 2 -- 2 -- final result
Maybe_g :: Maybe b -> Maybe (Maybe c) Maybe_g Nothing = Nothing Maybe_g (Just a) = Just (g a)
u :: Maybe (Maybe c) -> Maybe c u Nothing = Nothing u (Just Nothing) = Nothing u (Just (Just c)) = Just c
State_s_g :: (s->(s,b)) -> (s->(s,(s->(s,c)))) State_s_g p s1 = let (s2, b) = p s1 in (s2, g b)
u :: (s->(s,(s->(s,c)))) -> (s->(s,c)) u p1 s1 = let (s2, p2) = p1 s1 in p2 s2
m :: * -> * -- this is endofunctor from haskell types to haskell types! return :: a -> m a (>>=) :: m a -> (a -> m b) -> m b
m :: * -> * return :: a -> m a join :: m (m a) -> m a
{- import Prelude (($), const, uncurry) -- In the red corner, we have arrows, from the land of * -> * -> * import Control.Category import Control.Arrow hiding (Kleisli) -- In the blue corner, we have applicative functors and monads, -- the pride of * -> * import Control.Applicative import Control.Monad -- Recall the well-known result that every monad yields an ArrowApply: newtype Kleisli m a b = Kleisli{ runKleisli :: a -> m b} instance (Monad m) => Category (Kleisli m) where id = Kleisli return Kleisli g . Kleisli f = Kleisli $ g <=< f instance (Monad m) => Arrow (Kleisli m) where arr = Kleisli . (return .) first (Kleisli f) = Kleisli $ \(x, y) -> liftM (,y) (f x) instance (Monad m) => ArrowApply (Kleisli m) where app = Kleisli $ \(Kleisli f, x) -> f x -- Every arrow arr can be turned into an applicative functor -- for any choice of origin o newtype Arrplicative arr o a = Arrplicative{ runArrplicative :: arr o a } instance (Arrow arr) => Functor (Arrplicative arr o) where fmap f = Arrplicative . (arr f .) . runArrplicative instance (Arrow arr) => Applicative (Arrplicative arr o) where pure = Arrplicative . arr . const Arrplicative af <*> Arrplicative ax = Arrplicative $ arr (uncurry ($)) . (af &&& ax) -- Arrplicatives over ArrowApply are monads, even instance (ArrowApply arr) => Monad (Arrplicative arr o) where return = pure Arrplicative ax >>= f = Arrplicative $ (ax >>> arr (runArrplicative . f)) &&& id >>> app -- Every applicative functor f can be turned into an arrow?? newtype Applicarrow f a b = Applicarrow{ runApplicarrow :: f (a -> b) } instance (Applicative f) => Category (Applicarrow f) where id = Applicarrow $ pure id Applicarrow g . Applicarrow f = Applicarrow $ (.) <$> g <*> f instance (Applicative f) => Arrow (Applicarrow f) where arr = Applicarrow . pure first (Applicarrow f) = Applicarrow $ first <$> f
runKleisli ((Kleisli $ \() -> getLine) >>> Kleisli putStrLn) ()
data IOM ∷ ⋆ → ⋆ instance Monad IOM readFile ∷ FilePath → IOM String writeFile ∷ FilePath → String → IOM ()
copy ∷ FilePath → FilePath → IOM () copy from to = readFile from >>= writeFile to
copyIndirect ∷ FilePath → FilePath → IOM () copyIndirect index target = do from ← readFile index copy from (target ⟨/⟩ to)
data IOF ∷ ⋆ → ⋆ instance Applicative IOF readFile ∷ FilePath → IOF String writeFile ∷ FilePath → String → IOF ()
copy ∷ FilePath → FilePath → IOF () copy from to = writeFile′ to ⟨*⟩ readFile from
(λ write → [write "foo", write "bar", write "foo"]) ⟨$⟩ writeFile′ "out.txt"
readFile ∷ Kleisli IOM FilePath String writeFile ∷ Kleisli IOM (FilePath, String) ()
copyIndirect ∷ Kleisli IOM (FilePath, FilePath) () copyIndirect = proc (index, target) → do from ← readFile ↢ index s ← readFile ↢ from writeFile ↢ (to, s)
readFile ∷ FilePath → Applicarrow IOF () String writeFile ∷ FilePath → String → Applicarrow IOF () ()
data IOA ∷ ⋆ → ⋆ → ⋆ instance Arrow IOA readFile ∷ FilePath → IOA () String writeFile ∷ FilePath → IOA String ()
copy ∷ FilePath → FilePath → IOA () () copy from to = readFile from >>> writeFile to
inLocalEnvironment :: (r -> r) -> (r -> a) -> (r -> a) inLocalEnvironment xform f = \env -> f (xform env)
1. return a >>= f = f a return a >>= f = (\b -> a) >>= f -- by definition of return = (\x y z -> y (x z) z) (\b -> a) f -- by definition of (>>=) = (\y z -> y ((\b -> a) z) z) f -- beta reduction = (\z -> f ((\b -> a) z) z) -- beta reduction = (\z -> f a z) -- beta reduction = f a -- eta reduction 2. m >>= return = m m >>= return = (\x y z -> y (x z) z) m return -- definition of (>>=) = (\y z -> y (m z) z) return -- beta reduction = (\z -> return (m z) z) -- beta reduction = (\z -> const (m z) z) -- definition of return = (\z -> m z) -- definition of const = m -- eta reduction
instance Applicative ((->) r) where -- pure :: a -> r -> a pure = const -- (<*>) :: (r -> a -> b) -> (r -> a) -> r -> b (<*>) g f r = g r (f r)
enter code here instance Monoid a => Monoid (b -> a) where -- mempty :: Monoid a => b -> a mempty _ = mempty -- mappend :: Monoid a => (b -> a) -> (b -> a) -> b -> a mappend f g b = f b `mappend` g b
instance Monoid a => Monoid (r -> a) where mempty = pure mempty mappend = liftA2 mappend
instance Monoid a => Monoid (r -> a) where mempty = return mempty mappend = liftM2 mappend
No instance for (Num (Cofree [] a0)) arising from a use of ‘it’ In the first argument of ‘print’, namely ‘it’ In a stmt of an interactive GHCi command: print it
> let a = 1 :< [] > extract a 1 > let b = 1 :< [(2 :< []), (3 :< [])] > extract b 1 > unwrap b [2 :< [],3 :< []] > map extract $ unwrap b [2,3]
zero :: Cofree Maybe () zero = () :< Nothing succ :: Cofree Maybe () -> Cofree Maybe () succ n = () :< Just n
pack :: y -> Cofree (Const y) () pack y = () :< Const y
data Cofree nodeOf label = label :< nodeOf (Cofree nodeOf label)
pair :: x -> y -> Cofree (Const y) x pair x y = x :< Const y
one :: x -> Cofree Maybe x one = x :< Nothing cons :: x -> Cofree Maybe x -> Cofree Maybe x cons x xs = x :< Just xs
duplicate :: Cofree f a -> Cofree f (Cofree f a) duplicate a :< fca = (a :< fca) :< fmap duplicate fca -- f
fmap :: (a -> b) -> Cofree f a -> Cofree f b fmap g (a :< fca) = g a :< fmap (fmap g) fca -- ^^^^ ^^^^ -- f -- (Cofree f)
fmap length . duplicate :: Cofree f a -> Cofree f Int
extend :: Comonad c => (c a -> b) -> c a -> c b extend f = fmap f -- context-dependent map everywhere . -- after duplicate -- decorating everything with its context
extend :: (Cofree f a -> b) -> Cofree f a -> Cofree f b extend g ca@(_ :< fca) = g ca :< fmap (extend g) fca
duplicate = extend id -- the output label is the input label in its context
(=<=) :: Comonad c => (c s -> t) -> (c r -> s) -> (c r -> t) (g =<= h) = g . extend h
play :: [move] -> Cofree ((->) move) prize -> prize play [] (prize :< _) = prize play (m : ms) (_ :< f) = play ms (f m)
data Responder x = Resp {ifSend :: Char -> x, ifReceive :: (Char, x)}
chatter :: Free Comms x -> Cofree Responder y -> (x, y)
data F b a = F (a,b) data G b a = G (b -> a) instance Functor (F b) where fmap f (F (a,b)) = F (f a, b) instance Functor (G b) where fmap f (G g) = G (f . g)
iso1 :: (F b a -> c) -> a -> G b c iso1 f = \a -> G $ \b -> f (F (a,b)) iso2 :: (a -> G b c) -> F b a -> c iso2 g = \(F (a,b)) -> let (G g
data M b a = M { unM :: b -> (a,b) } instance Monad (M b) where return a = M (\b -> (a,b)) (M f) >>= g = M (\r -> let (a,r
{- import Control.Arrow import Control.Category hiding ((.)) import qualified Control.Category as C import Control.Monad class (Category c, Category d) => CFunctor f c d | f -> c d where cfmap :: c a b -> d (f a) (f b)
-- m is phantom, hence the explicit kind is required newtype LeftAdj (m :: * -> *) a = LeftAdj { unLeftAdj :: a } instance Monad m => CFunctor (LeftAdj m) (->) (Kleisli m) where cfmap f = Kleisli $ liftM LeftAdj . return . f . unLeftAdj -- we could also express it as liftM LeftAdj . (return .) f . unLeftAdj
newtype RightAdj m a = RightAdj { unRightAdj :: m a } instance Monad m => CFunctor (RightAdj m) (Kleisli m) (->) where cfmap (Kleisli g) = RightAdj . join . liftM g . unRightAdj -- this can be shortened as RightAdj . (=<<) g . unRightAdj
User name Text age Int Login user UserId login Text passwd Text
Just (Entity uid _) <- selectFirst [ UserName ==. "Some User ] [] Just (Entity lid Login {..}) <- selectFirst [ LoginUser ==. uid ] []
g3 :: (Floating a, RealFrac a) => a g3 = 1/6 {- int :: (Integral a, Num b) => a -> b int = fromIntegral grad3 :: (Floating a, RealFrac a) => V.Vector (a,a,a) grad3 = V.fromList $ [(1,1,0),(-1, 1,0),(1,-1, 0),(-1,-1, 0), (1,0,1),(-1, 0,1),(1, 0,-1),(-1, 0,-1), (0,1,1),( 0,-1,1),(0, 1,-1),( 0,-1,-1)] {- dot3 :: Num a => (a, a, a) -> a -> a -> a -> a dot3 (a,b,c) x y z = a * x + b * y + c * z {- fastFloor :: RealFrac a => a -> Int fastFloor x = truncate (if x > 0 then x else x - 1) --Generate a random permutation for use in the noise functions perm :: Int -> Permutation perm seed = V.fromList . concat . replicate 2 . shuffle --Generate 3D noise between -0.5 and 0.5 simplex3D :: (Floating a, RealFrac a) => Permutation -> a -> a -> a -> a simplex3D p x y z = {- (i,j,k) = {- (x0,y0,z0) = {- (i1,j1,k1,i2,j2,k2) = {- then if y0 >= z0 then (1,0,0,1,1,0) else if x0 >= z0 then (1,0,0,1,0,1) else (0,0,1,1,0,1) else if y0 < z0 then (0,0,1,0,1,1) else if x0 < z0 then (0,1,0,0,1,1) else (0,1,0,1,1,0) xyz1 = {- xyz2 = {- xyz3 = {- (ii,jj,kk) = {- gi0 = {- gi1 = {- gi2 = {- gi3 = {- {- n gi (x a*a*a*a*dot3 (grad3 V.! gi) x harmonic :: (Num a, Fractional a) => Int -> (a -> a) -> a harmonic octaves noise = f octaves / (2 - 1 / int (2 ^ (octaves - 1))) where f 0 = 0 f o = let r = int $ 2 ^ (o - 1) in noise r / r + f (o - 1) --Generate harmonic 3D noise between -0.5 and 0.5 harmonicNoise3D :: (RealFrac a, Floating a) => Permutation -> Int -> a -> a -> a -> a -> a harmonicNoise3D p octaves l x y z = harmonic octaves (\f -> simplex3D p (x * f / l) (y * f / l) (z * f / l))
q _ = let p = perm 0 in sum [harmonicNoise3D p 3 l x y z :: Float | l <- [1..10], y <- [0..127], x <- [0..15], z <- [0..15]] main = do start <- getCurrentTime print $ q () end <- getCurrentTime print $ diffUTCTime end start
COST CENTRE MODULE %time %alloc simplex3D Main 18.8 21.0 n Main 18.0 19.6 out Main 10.1 9.2 harmonicNoise3D Main 9.8 4.5 harmonic Main 6.4 5.8 int Main 4.0 2.9 gi3 Main 4.0 3.0 xyz2 Main 3.5 5.9 gi1 Main 3.4 3.4 gi0 Main 3.4 2.7 fastFloor Main 3.2 0.6 xyz1 Main 2.9 5.9 ijk Main 2.7 3.5 gi2 Main 2.7 3.3 xyz3 Main 2.6 4.1 iijjkk Main 1.6 2.5 dot3 Main 1.6 0.7
module Noise ( Permutation, perm , noise3D, simplex3D ) where import Data.Bits import qualified Data.Vector.Unboxed as UV import System.Random import System.Random.Shuffle type Permutation = UV.Vector Int g3 :: Double g3 = 1/6 {- int :: Int -> Double int = fromIntegral grad3 :: UV.Vector (Double, Double, Double) grad3 = UV.fromList $ [(1,1,0),(-1, 1,0),(1,-1, 0),(-1,-1, 0), (1,0,1),(-1, 0,1),(1, 0,-1),(-1, 0,-1), (0,1,1),( 0,-1,1),(0, 1,-1),( 0,-1,-1)] {- dot3 :: (Double, Double, Double) -> Double -> Double -> Double -> Double dot3 (a,b,c) x y z = a * x + b * y + c * z {- fastFloor :: Double -> Int fastFloor x = truncate (if x > 0 then x else x - 1) --Generate a random permutation for use in the noise functions perm :: Int -> Permutation perm seed = UV.fromList . concat . replicate 2 . shuffle --Generate 3D noise between -0.5 and 0.5 noise3D :: Permutation -> Double -> Double -> Double -> Double noise3D p x y z = 16 * (n gi0 (x0,y0,z0) + n gi1 xyz1 + n gi2 xyz2 + n gi3 xyz3) where (i,j,k) = (s x, s y, s z) where s a = fastFloor (a + (x + y + z) / 3) (x0,y0,z0) = (x - int i + t, y - int j + t, z - int k + t) where t = int (i + j + k) * g3 (i1,j1,k1,i2,j2,k2) = if x0 >= y0 then if y0 >= z0 then (1,0,0,1,1,0) else if x0 >= z0 then (1,0,0,1,0,1) else (0,0,1,1,0,1) else if y0 < z0 then (0,0,1,0,1,1) else if x0 < z0 then (0,1,0,0,1,1) else (0,1,0,1,1,0) xyz1 = (x0 - int i1 + g3, y0 - int j1 + g3, z0 - int k1 + g3) xyz2 = (x0 - int i2 + 2*g3, y0 - int j2 + 2*g3, z0 - int k2 + 2*g3) xyz3 = (x0 - 1 + 3*g3, y0 - 1 + 3*g3, z0 - 1 + 3*g3) (ii,jj,kk) = (i .&. 255, j .&. 255, k .&. 255) gi0 = rem (UV.unsafeIndex p (ii + UV.unsafeIndex p (jj + UV.unsafeIndex p kk ))) 12 gi1 = rem (UV.unsafeIndex p (ii + i1 + UV.unsafeIndex p (jj + j1 + UV.unsafeIndex p (kk + k1)))) 12 gi2 = rem (UV.unsafeIndex p (ii + i2 + UV.unsafeIndex p (jj + j2 + UV.unsafeIndex p (kk + k2)))) 12 gi3 = rem (UV.unsafeIndex p (ii + 1 + UV.unsafeIndex p (jj + 1 + UV.unsafeIndex p (kk + 1 )))) 12 {- n gi (x a*a*a*a*dot3 (UV.unsafeIndex grad3 gi) x harmonic :: Int -> (Double -> Double) -> Double harmonic octaves noise = f octaves / (2 - 1 / int (2 ^ (octaves - 1))) where f 0 = 0 f o = let r = 2 ^^ (o - 1) in noise r / r + f (o - 1) --3D simplex noise --syntax: simplex3D permutation number_of_octaves wavelength x y z simplex3D :: Permutation -> Int -> Double -> Double -> Double -> Double -> Double simplex3D p octaves l x y z = harmonic octaves (\f -> noise3D p (x * f / l) (y * f / l) (z * f / l))
import qualified Data.Vector as V import Data.Bits import Data.Time.Clock import System.Random import System.Random.Shuffle type Permutation = V.Vector Int
⟦_⟧ᶜ : ∀ {α β γ} -> Container α β -> Set γ -> Set (α ⊔ β ⊔ γ) ⟦ Sh ◃ Pos ⟧ᶜ A = ∃ λ sh -> Pos sh -> A Kᶜ : ∀ {α β} -> Set α -> Container α β Kᶜ A = A ◃ const (Lift ⊥)
[_]C : Cont -> Set -> Set [ S <| P ]C X = Sg S \ s -> P s -> X -- I mapC : (C : Cont){X Y : Set} -> (X -> Y) -> [ C ]C X -> [ C ]C Y mapC (S <| P) f (s , k) = (s , f o k) -- o is composition
data Desc : Set1 where var : Desc sg pi : (A : Set)(D : A -> Desc) -> Desc one : Desc -- could be Pi with A = Zero _*_ : Desc -> Desc -> Desc -- could be Pi with A = Bool con : Set -> Desc -- constant descriptions as singleton tuples con A = sg A \ _ -> one _+_ : Desc -> Desc -> Desc -- disjoint sums by pairing with a tag S + T = sg Two \ { true -> S ; false -> T }
[_]D : Desc -> Set -> Set [ var ]D X = X [ sg A D ]D X = Sg A \ a -> [ D a ]D X [ pi A D ]D X = (a : A) -> [ D a ]D X [ one ]D X = One [ D * D mapD : (D : Desc){X Y : Set} -> (X -> Y) -> [ D ]D X -> [ D ]D Y mapD var f x = f x mapD (sg A D) f (a , d) = (a , mapD (D a) f d) mapD (pi A D) f g = \ a -> mapD (D a) f (g a) mapD one f <> = <> mapD (D * D
ShD : Desc -> Set ShD D = [ D ]D One PosD : (D : Desc) -> ShD D -> Set PosD var <> = One PosD (sg A D) (a , d) = PosD (D a) d PosD (pi A D) f = Sg A \ a -> PosD (D a) (f a) PosD one <> = Zero PosD (D * D ContD : Desc -> Cont ContD D = ShD D <| PosD D
_-[_] : (X : Set) -> X -> Set X -[ x ] = Sg X \ x dC : Cont -> Cont dC (S <| P) = (Sg S P) <| (\ { (s , p) -> P s -[ p ] })
dD : Desc -> Desc dD var = one dD (sg A D) = sg A \ a -> dD (D a) dD (pi A D) = sg A \ a -> (pi (A -[ a ]) \ { (a dD one = con Zero dD (D * D
data Obfuncscate f x where (:<) :: forall p. f p -> (p -> x) -> Obfuncscate f x
data Obfuncscate f x where (:<) :: pi (s :: exists p. f p) -> (fst s -> x) -> Obfuncscate f x
toS : S -> S' fromP : (s : S) -> P f (s , k) = (toS s , k o fromP s)
data KDTree v a = Node a (Node v a) (Node v a) | Leaf v a
null [] = True null _ = False Prelude> :t null null :: [a] -> Bool -- Notice lack of (Eq a).
nonemptyLists :: [[a]] -> [[a]] nonemptyLists = filter (not . null)
sortGT (a1, b1) (a2, b2) | a1 < a2 = GT | a1 > a2 = LT | a1 == a2 = compare b1 b2
*Main Data.List> sortBy sortGT [(1, "b"), (1, "a"), (2, "b"), (2, "a")] [(2,"a"),(2,"b"),(1,"a"),(1,"b")]
import Data.List (sortBy) import Data.Monoid (mconcat) myPredicate (a1, a2) (b1, b2) = mconcat [compare b1 a1, compare a2 b2]
import Data.List (sortBy) import Data.Monoid (mappend) myPredicate (a1, a2) (b1, b2) = compare b1 a1 `mappend` compare a2 b2
import Data.Ord import Data.List import Data.Monoid ascending = id descending = flip sortPairs f x g y = f (comparing x) `mappend` g (comparing y) mySort = sortBy (sortPairs descending fst ascending snd)
sortGT (a1,b1) (a2,b2) = case compare a1 a2 of EQ -> compare b1 b2 LT -> GT GT -> LT
*Main> sortBy sortGT [(1, "b"), (1, "a"), (2, "b"), (2, "a")] [(2,"a"),(2,"b"),(1,"a"),(1,"b")]
import Data.Ord import Data.List import Data.Monoid main :: IO () main = do print $ sortBy cmp [(1, "b"), (1, "a"), (2, "b"), (2, "a")] where cmp = flip (comparing fst) `mappend` comparing snd
import Data.List myCompare :: (Ord a, Ord b) => (a,b) -> (a,b) -> Ordering myCompare (a1,b1) (a2,b2) | a1 < a2 = GT | a2 == a1 = EQ | otherwise = LT
*Main> sortBy myCompare [(1, "b"), (1, "a"), (2, "b"), (2, "a")]
invert :: Ordering -> Ordering invert GT = LT invert LT = GT invert EQ = EQ sosort :: (Ord a, Ord b) => [(a, b)] -> [(a, b)] sosort = sortBy (\p p sortBy (\p p where double f a a
sosort :: (Ord a, Ord b) => [(a, b)] -> [(a, b)] sosort = sortBy (compare EQ `post` comparing fst) . sortBy (comparing snd) where post f g x x
Prelude Data.Ord Data.List Data.Function> (reverse.sortBy (comparing fst)) [(1, "b"), (1, "a"), (2, "b"), (2, "a")]
?- length([],0). % is the length of empty list zero? ?- length([a,b,c],X). % what ?- length(L,5). % give me all lists that have length of 5
| ?- length(L,5). L = [_,_,_,_,_] | ?- length(L,5), maplist(=(E),L). L = [E,E,E,E,E]
swapPairs([], []). swapPairs([X], [X]). swapPairs([X, Y|T], [Y, X|R]) :- swapPairs(T, R).
if arch(i386) || arch(x86_64) cpp-options: -DFastWordExtract
getNthWord n b = inlinePerformIO (unsafeUseAsCString b (flip peekElemOff n . castPtr)) ... other code ...
data Vec2 = Vec2 { vecX :: Float , vecY :: Float } data Mat2 = Mat2 { matCol1 :: Vec2 , matCol2 :: Vec2 }
let vec = Vec2 2 3 -- Reading the components of vec foo = vecX vec -- Creating a new vector with some component changed. vec2 = vec { vecY = foo } mat = Mat2 vec2 vec2
mat2 = mat { matCol2 = (matCol2 mat) { vecX = 4 } }
data Data = Data { member :: Int } -- The "getter" of the member variable getMember :: Data -> Int getMember d = member d -- The "setter" or more accurately "updater" of the member variable setMember :: Data -> Int -> Data setMember d m = d { member = m } memberLens :: (Data -> Int, Data -> Int -> Data) memberLens = (getMember, setMember)
getL :: Lens a b -> a -> b getL (getter, setter) = getter setL :: Lens a b -> a -> b -> a setL (getter, setter) = setter
data Foo = Foo { subData :: Data } subDataLens :: Lens Foo Data subDataLens = (subData, \ f s -> f { subData = s }) -- short lens definition
( ( (getter2 . getter1, combinedSetter) where combinedSetter a x = let oldInner = getter1 a newInner = setter2 oldInner x in setter1 a newInner
increment :: Lens a Int -> a -> a increment l a = setL l a (getL l a + 1)
d = Data 3 print $ increment memberLens d -- Prints "Data 4", the inner field is updated.
f = Foo (Data 5) print $ increment (subDataLens -- Prints "Foo (Data 6)", the innermost field is updated.
with (Foo (Data 5)) $ do subDataLens . memberLens $= 7
polar :: (Floating a, RealFloat a) => Lens (Complex a) (a, a) mag :: (RealFloat a) => Lens (Complex a) a
import Control.Concurrent import Control.Concurrent.MVar main = do something -- the thread forked in something can be killed here -- because the MVar used for communication is no longer in scope etc something = do v <- newEmptyMVar forkIO $ forever $ work =<< takeMVar v putMVar v "Haskell" putMVar v "42"
import Control.Concurrent import Control.Concurrent.MVar import Control.Monad import Control.Exception import Prelude hiding (catch) main = do something threadDelay (10 * 10^6) print "Still here" something = do v <- newEmptyMVar forkIO $ finally (let go = do x <- takeMVar v case x of Nothing -> return () Just v -> print v >> go in go) (print "Done!") putMVar v $ Just "Haskell" putMVar v $ Just "42" putMVar v Nothing
import Control.Monad import Control.Exception import Control.Concurrent import Control.Concurrent.MVar import System.Mem(performGC) import System.Mem.Weak dologger :: MVar String -> IO () dologger mv = do tid <- myThreadId weak <- mkWeakPtr mv (Just (putStrLn "X" >> killThread tid)) logger weak logger :: Weak (MVar String) -> IO () logger weak = act where act = do v <- deRefWeak weak case v of Just mv -> do a <- try (takeMVar mv) :: IO (Either SomeException String) print a either (\_ -> return ()) (\_ -> act) a Nothing -> return () play mv = act where act = do c <- getLine if c=="quit" then return () else putMVar mv c >> act doplay mv = do forkIO (dologger mv) play mv main = do putStrLn "Enter a string to escape, or quit to exit" mv <- newEmptyMVar doplay mv putStrLn "*" performGC putStrLn "*" yield putStrLn "*" threadDelay (10^6) putStrLn "*"
(chrisk)-(/tmp) (! 624)-> ghc -threaded -rtsopts --make weak2.hs [1 of 1] Compiling Main ( weak2.hs, weak2.o ) Linking weak2 ... (chrisk)-(/tmp) (! 625)-> ./weak2 +RTS -N4 -RTS Enter a string to escape, or quit to exit This is a test Right "This is a test" Tab Tab Right "Tab\tTab" quit * * X * Left thread killed *
cataL :: (a -> b -> b) -> b -> [a] -> b cataL f b (a : as) = f a (cataL f b as) cataL _ b [] = b paraL :: (a -> [a] -> b -> b) -> b -> [a] -> b paraL f b (a : as) = f a as (paraL f b as) paraL _ b [] = b -- TODO: histo -- DONE: zygo (see below) anaL :: (b -> (a, b)) -> b -> [a] anaL f b = let (a, b anaL anaL Just (a, b Nothing -> [] apoL :: ([b] -> Maybe (a, Either [b] [a])) -> [b] -> [a] apoL f b = case f b of Nothing -> [] Just (x, Left c) -> x : apoL f c Just (x, Right e) -> x : e -- DONE: futu (see below) hyloL :: (a -> c -> c) -> c -> (b -> Maybe (a, b)) -> b -> c hyloL f z g = cataL f z . anaL hyloL hyloL Nothing -> z Just (x,z
lengthEven :: [a] -> Bool lengthEven = even . length pm0 [] = 0 pm0 (x:xs) = if lengthEven xs then x - pm0 xs else x + pm0 xs
paraL :: (a -> [a] -> b -> b) -> b -> [a] -> b paraL f z [] = z paraL f z (x:xs) = f x xs (paraL f z xs) pm1 = paraL (\x xs acc -> if lengthEven xs then x - acc else x + acc) 0
pm2 = snd . cataL (\x (isEven, total) -> (not isEven, if isEven then x - total else x + total)) (True, 0)
zygoL :: (a -> b -> b) -> -- a folding function (a -> b -> c -> c) -> -- a folding function which depends on the result of the other fold b -> c -> -- zeroes for the two folds [a] -> c zygoL f g z e = snd . cataL (\x (p, q) -> (f x p, g x p q)) (z, e)
pm3 = zygoL (\_ p -> not p) (\x isEven total -> if isEven then x - total else x + total) True 0
mutuL :: (a -> b -> c -> b) -> (a -> b -> c -> c) -> b -> c -> [a] -> c mutuL f g z e = snd . cataL (\x (p, q) -> (f x p q, g x p q)) (z, e)
newtype Fix f = Fix { unFix :: f (Fix f) } cata :: Functor f => (f a -> a) -> Fix f -> a cata f = f . fmap (cata f) . unFix para :: Functor f => (f (Fix f, a) -> a) -> Fix f -> a para f = snd . cata (\x -> (Fix $ fmap fst x, f x)) zygo :: Functor f => (f b -> b) -> (f (b, a) -> a) -> Fix f -> a zygo f g = snd . cata (\x -> (f $ fmap fst x, g x)) mutu :: Functor f => (f (b, a) -> b) -> (f (b, a) -> a) -> Fix f -> a mutu f g = snd . cata (\x -> (f x, g x))
data ListF a r = Nil_ | Cons_ a r deriving Functor type List a = Fix (ListF a) zygoL zygoL where k Nil_ = z k (Cons_ x y) = f x y l Nil_ = e l (Cons_ x (y, z)) = g x y z pm4 = zygoL then x - total else x + total) True 0
(a -> Base [b] (Free (Base [b]) a)) -> a -> [b] (a -> ListF b (Free (ListF b) a)) -> a -> [b]
futuL f x = case f x of Nothing -> [] Just (y, (ys, mz)) -> y : (ys ++ fz) where fz = case mz of Nothing -> [] Just z -> futuL f z
notFutuL :: (a -> ([b], Maybe a)) -> a -> [b] notFutuL f x = case f x of (ys, mx) -> ys ++ case mx of Nothing -> [] Just x
data History a b = Ancient b | Age a b (History a b)
cataL = foldr history :: (a -> History a b -> b) -> b -> [a] -> History a b history f z = cataL (\x h -> Age x (f x h) h) (Ancient z)
headH :: History a b -> b headH (Ancient x) = x headH (Age _ x _) = x histoL :: (a -> History a b -> b) -> b -> [a] -> b histoL f z = headH . history f z
data Cofree f a = Cofree { headC :: a, tailC :: f (Cofree f a) }
newtype Fix f = Fix { unFix :: f (Fix f) } cata :: Functor f => (f b -> b) -> Fix f -> b cata f = f . fmap (cata f) . unFix histo :: Functor f => (f (Cofree f b) -> b) -> Fix f -> b histo f = headC . cata (\x -> Cofree (f x) x)
data ListF a r = Nil_ | Cons_ a r deriving Functor type List a = Fix (ListF a) type History histoL histoL where g Nil_ = z g (Cons_ x h) = f x h
histo :: Functor f => (f (Cofree f a) -> a) -> (Fix f -> a) futu :: Functor f => (a -> f (Free f a)) -> (a -> Fix f)
crabgrass:~/programming% ghc test.hs -e test.hs:1:7: No instance for (Num (a0 -> t0)) arising from the literal `3' Possible fix: add an instance declaration for (Num (a0 -> t0)) In the expression: 3 In the expression: 3 4 In an equation for `foo zsh: exit 1 ghc test.hs -e
nOfNeg l = length(filter (<0) l) main = print(nOfNeg [0,-1,-2,1,2,3,4] ) --2
some v = (:) <$> v <*> many v many v = some v <|> pure []
import Control.Monad(Functor(..)) import Control.Applicative import Data.Char -- char string parser newtype P a = P { runP :: String -> [(a,String)] } -- runP (P p) s = p s instance Functor P where -- fmap :: (a -> b) -> f a -> f b fmap f (P q) = P (\s -> [ (f y,ys) | (y,ys) <- q s]) instance Applicative P where -- pure :: a -> f a pure x = P (\s -> [(x,s)]) -- (<*>) :: f (a -> b) -> f a -> f b P p <*> P q = P (\s -> [(x y, ys) | (x,xs) <- p s, (y,ys) <- q xs]) letter = P p where -- sample parser p (x:xs) | isAlpha x = [(x,xs)] p _ = []
*Main Data.Char> runP letter "123" [] *Main Data.Char> runP letter "a123" [( *Main Data.Char> runP ( (:) <$> letter <*> pure []) "a123" [("a","123")] *Main Data.Char> runP ( (:) <$> letter <*> ((:)<$>letter <*> pure []) ) "a123" [] *Main Data.Char> runP ( (:) <$> letter <*> ((:)<$>letter <*> pure []) ) "ab123" [("ab","123")] -- NOT NICE ^^^^^^^^^^^^^^^^^^^^ -}
instance Alternative P where -- (<|>) :: f a -> f a -> f a P p <|> P q = P (\s-> p s ++ q s) -- empty :: f a -- the identity of <|> empty = P (\s-> [])
*Main Data.Char> runP (many letter) "ab123" [("ab","123"),("a","b123"),("","ab123")] *Main Data.Char> runP (some letter) "ab123" [("ab","123"),("a","b123")] *Main Data.Char> runP (optional letter) "ab123" [(Just *Main Data.Char> runP (optional letter) "123" [(Nothing,"123")] Prelude Main Data.Traversable> runP (sequenceA $ replicate 2 letter) "ab123" [("ab","123")] -- NICE ^^^^^^^^^^^^^^^^^^^ -}
(,) (,,) (,,,) (,,,,) --etc (,,,,,,,,,,,,,,) (,,,,,,,,,,,,,,,) --etc (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) --etc
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__ = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__
data Tuple2 a b = Tuple2 a b data Tuple3 a b c = Tuple3 a b c
instance Functor (Either a) where fmap f (Right x) = Right (f x) fmap f (Left x) = Left x
instance Functor (Either a) where fmap g (Right x) = Right (g x) fmap g (Left x) = Left x
data MightBe b = Nope () | Yep b data UnlessError b = Bad String | Good b data ElseInt b = Else Int | Value b
instance Functor MightBe where fmap f (Nope ()) = Nope () -- compare with Nothing fmap f (Yep x) = Yep (f x) -- compare with Just (f x) instance Functor UnlessError where fmap f (Bad str) = Bad str -- a more informative Nothing fmap f (Good x) = Good (f x) instance Functor ElseInt where fmap f (Else n) = Else n fmap f (Value b) = Value (f b)
instance Functor (Unless a) where fmap f (Mere a) = Mere a fmap f (Genuine x) = Genuine (f x)
newtype FlipEither b a = FlipEither { unFlipEither :: Either a b }
instance Functor (FlipEither b) where fmap f (FlipEither (Left x)) = FlipEither (Left (f x)) fmap f (FlipEither (Right x)) = FlipEither (Right x)
fmapE2 :: (a -> b) -> Either a c -> Either b c fmapE2 f = unFlipEither . fmap f . FlipEither
instance Bifunctor Either where bimap f _ (Left a) = Left (f a) bimap _ g (Right b) = Right (g b) first f = bimap f id second f = bimap id f
Every Monad is an Applicative Functor Every Applicative Functor is a Functor
class Functor f => Applicative f where pure :: a -> f a (<*>) :: f (a -> b) -> f a -> f b
class Monad m where return :: a -> m a (>>=) :: m a -> (a -> m b) -> m b (>>) :: m a -> m b -> m b m >> n = m >>= \_ -> n fail :: String -> m a
class Applicative m => Monad (>>=) :: m a -> (a -> m b) -> m b
{- class Arity f where arity :: f -> Int instance Arity x where arity _ = 0 instance Arity f => Arity ((->) a f) where arity f = 1 + arity (f undefined)
ghci> arity foldr blah blah ambiguous blah blah possible fix blah ghci> arity (foldr :: (a -> Int -> Int) -> Int -> [a] -> Int) 3 ghci> let f x y = 3 in arity f 2 ghci> arity $ \x y -> 3 2
ghci> arity foldr 3 ghci> let f x y = 3 in arity f 2 ghci> arity $ \x y -> 3 -- should be 2 0
<interactive>:1:1: Ambiguous type variable `b0 (Arity b0) arising from a use of `arity' Probable fix: add a type signature that fixes these type variable(s) In the expression: arity foldr In an equation for `it
<interactive>:1:1: Overlapping instances for Arity (Bool -> Bool -> Bool) arising from a use of `arity' Matching instances: instance Arity f => Arity (a -> f) -- Defined at tmp/test.hs:9:10-36 instance Arity x -- Defined at tmp/test.hs:12:10-16 In the expression: arity (&&) In an equation for `it
<interactive>:1:1: Ambiguous type variable `f0 (Arity f0) arising from a use of `arity' Probable fix: add a type signature that fixes these type variable(s) In the expression: arity undefined In an equation for `it
*Main> let f a b = 3 *Main> arity f 2 *Main> arity (\a b -> 3) 0
commutativity :: forall (n :: Nat) (m :: Nat). n + m :~: m + n commutativity = ...
gcastWith (commutativity @n @m) someExpression ==> someExpression
sendCommand :: SMTPConnection -> Command -> IO (ReplyCode, ByteString)
EmailSender.Email email = new EmailSender.Email(); email.ConfigServer("SMTP Here", Port Here, SSL/TSL Here); email.AuthenticateUser("Sender Email Address Here", "Sender Password Here"); email.CustomizeEmail("Sender Email Address", "Recepient Email Address", "Subject", "Body In Text"); email.AddCC("CC Email Address Here") email.AddBcc("Bcc Email Address Here") email.AddAttachment("Filename With Full Path Here"); email.SendEmail();
map :: (a -> b) -> [a] -> [b] foldr :: (a -> b -> b) -> b -> [a] -> b filter :: (a -> Bool) -> [a] -> [a] unfoldr :: (b -> Maybe (a, b)) -> b -> [a] iterate :: (a -> a) -> a -> [a]
Consume $ \x -> Consume $ \y -> Consume $ \z -> Return (x+y+z)
sumStream :: Coro Int Int sumStream = Consume (go 0) where go accum 0 = Return accum go accum n = Consume (\x -> go (accum+x) (n-1))
equal :: ((Integer -> Bool) -> Int) -> ((Integer -> Bool) -> Int) -> Bool
(defn make-object [initial-value] (let [data (atom {:value initial-value})] (fn [op & args] (case op :set (swap! data assoc :value (first args)) :get (:value @data)))))
(def a (make-object 10)) (a :get) => 10 (a :set 40) (a :get) => 40
rays :: ChessPieceType -> [[(Int, Int)]] rays Bishop = do dx <- [1, -1] dy <- [1, -1] return $ iterate (addPos (dx, dy)) (dx, dy) ... -- Other piece types -- takeUntilIncluding is an inclusive version of takeUntil takeUntilIncluding :: (a -> Bool) -> [a] -> [a] possibleMoves board piece = do relRay <- rays (pieceType piece) let ray = map (addPos src) relRay takeUntilIncluding (not . isNothing . pieceAt board) (takeWhile notBlocked ray) where notBlocked pos = inBoard pos && all isOtherSide (pieceAt board pos) isOtherSide = (/= pieceSide piece) . pieceSide
iterate :: (a -> a) -> a -> [a] takeUntilIncluding -- not a standard function takeWhile :: (a -> Bool) -> [a] -> [a] all :: (a -> Bool) -> [a] -> Bool map :: (a -> b) -> [a] -> [b] (.) :: (b -> c) -> (a -> b) -> a -> c (>>=) :: Monad m => m a -> (a -> m b) -> m b
statFuncs :: [ [Double] -> Double ] statFuncs = [minimum, maximum, mean, median, mode, stddev] runWith funcs samples = map ($samples) funcs
@ARGV = map { /\.gz$/ ? "gzip -dc < $_ |" : $_ } @ARGV; @unempty = grep { defined && length } @many;
@txtfiles = map { $_->[1] } sort { $b->[0] <=> $a->[0] || lc $a->[1] cmp lc $b->[1] || $b->[1] cmp $a->[1] } map { -s => $_ } grep { -f && -T } glob("/etc/*");
@sorted_lines = map { $_->[0] } sort { $a->[4] <=> $b->[4] || $a->[-1] cmp $b->[-1] || $a->[3] <=> $b->[3] || ... } map { [$_ => reverse split /:/] } @lines;
$sum = reduce { $a + $b } @numbers; $max = reduce { $a > $b ? $a : $b } $MININT, @numbers;
let maybeAge = (\futureYear birthYear -> if futureYear < birthYear then yearDiff birthYear futureYear else yearDiff futureYear birthYear) <$> (readMay futureYearString) <*> (readMay birthYearString)
ifM :: Monad m => m Bool -> m a -> m a -> m a ifM c x y = c >>= \z -> if z then x else y whileM :: Monad m => (a -> m Bool) -> (a -> m a) -> a -> m a whileM p step x = ifM (p x) (step x >>= whileM p step) (return x)
import Control.Applicative ifA :: Applicative f => f Bool -> f a -> f a -> f a ifA c x y = (\c
*Main> ifM (Just True) (Just 1) (Just 2) Just 1 *Main> ifM (Just True) (Just 1) (Nothing) Just 1 *Main> ifA (Just True) (Just 1) (Just 2) Just 1 *Main> ifA (Just True) (Just 1) (Nothing) Nothing
whileA :: Applicative f => (a -> f Bool) -> (a -> f a) -> a -> f a whileA p step x = ifA (p x) (whileA p step <*> step x) (pure x)
main = do b <- readLn :: IO Bool if b then fireMissiles else return ()
import Control.Applicative checkPasswordM :: IO () checkPasswordM = do putStrLn "What pass <- getLine if pass == "swordfish" then putStrLn "Correct. The secret answer is 42." else putStrLn "INTRUDER ALERT! INTRUDER ALERT!" checkPasswordA :: IO () checkPasswordA = if <$> (putStrLn "What <*> putStrLn "Correct. The secret answer is 42." <*> putStrLn "INTRUDER ALERT! INTRUDER ALERT!" if if if
*Main> checkPasswordM What swordfish Correct. The secret answer is 42. *Main> checkPasswordM What zvbxrpl INTRUDER ALERT! INTRUDER ALERT!
*Main> checkPasswordA What hunter2 Correct. The secret answer is 42. INTRUDER ALERT! INTRUDER ALERT!
do pass <- putStrLn "What unit1 <- putStrLn "Correct. The secret answer is 42." unit2 <- putStrLn "INTRUDER ALERT! INTRUDER ALERT!" pure $ if
do val1 <- app1 val2 <- app2 ... valN <- appN pure $ f val1 val2 ... valN
pure :: a -> f a (<$>) :: (a -> b) -> f a -> f b (<*>) :: f (a -> b) -> f a -> f b
(=<<) :: (a -> m b) -> m a -> m b join :: m (m a) -> m a
checkPasswordFn :: String -> IO () checkPasswordFn pass = if pass == "swordfish" then putStrLn "Correct. The secret answer is 42." else putStrLn "INTRUDER ALERT! INTRUDER ALERT!" checkPasswordA checkPasswordA
*Main> checkPasswordM' What 12345 INTRUDER ALERT! INTRUDER ALERT!
data AllErrors e a = Error e | Pure a deriving (Functor) instance Monoid e => Applicative (AllErrors e) where pure = Pure (Pure f) <*> (Pure x) = Pure (f x) (Error e) <*> (Pure _) = Error e (Pure _) <*> (Error e) = Error e -- This is the non-Monadic case (Error e1) <*> (Error e2) = Error (e1 <> e2)
> Left "a" <*> Left "b" Left > Error "a" <*> Error "b" Error "ab"
myElem :: (Eq a) => a -> [a] -> Bool myElem x = maybe False (const True) . find (== x)
myElem x = any (== x) myElem x = or . map (== x) myElem x = not . null . filter (== x) myElem x = foldr (\y b -> y == x || b) False
isMember n [] = False isMember n (x:xs) | n == x = True | otherwise = isMember n xs
isMember 2 [1,9,4,5] -- False isMember 2 [4,5,2,9] -- True
l=[1,2,3,4,5] checkIfElem :: Int -> [Int] ->Bool checkIfElem x l |x`elem` l =True |otherwise=False
reverse ::[a]->[a] reverse [] = [] reverse (x:xs) = reverse(xs)++[x]
reversex ::[Int]->[Int] reversex [] = [] reversex (x:xs) = reversex(xs):x:[]
reversex ::[Int]->[Int] reversex [] = [] reversex (x:xs) = reversex(xs):x:[]
(++) :: [a] -> [a] -> [a] (++) [] ys = ys (++) (x:xs) ys = x : xs ++ ys
reversex ::[Int]->[Int] reversex [] = [] reversex (x:xs) = reversex(xs)++[x]
reversex [1, 2, 3, 4] reversex [2, 3, 4] ++ [1] reversex [3, 4] ++ [2] ++ [1] reversex [4] ++ [3] ++ [2] ++ [1] reversex [] ++ [4] ++ [3] ++ [2] ++ [1] [] ++ [4] ++ [3] ++ [2] ++ [1] [4] ++ [3] ++ [2] ++ [1] [4, 3] ++ [2] ++ [1] [4, 3, 2] ++ [1] [4, 3, 2, 1]
let x : xs = [1, 2, 3] in x -- known as type deconstructing
data List a = Cons a (List a) -- is equvalent with `data [a] = a:[a]`
import Data.Function reversex1 [] = [] reversex1 arr = reversex arr [] reversex [] arr = arr reversex (x:xs) ys = reversex xs (x:ys) main = do reversex1 [1..10] & print
index :: String -> [(String, [Integer])] index a = [...]
readAndIndex fileName = do text <- readFile fileName return $ index text
readAndIndex :: FilePath -> IO [(String, [Integer])]
index (launchMissiles >> deleteRoot >> return "PWNd!")
data TTrue = TTrue data FFalse = FFalse class TypeLevelIf tf a b where type If tf a b weirdIfStatement :: tf -> a -> b -> tf a b instance TypeLevelIf TTrue a b where type If TTrue a b = a weirdIfStatement TTrue a b = a instance TypeLevelIf FFalse a b where type If FFalse a b = b weirdIfStatement FFalse a b = a
combine a b c = (eliminate a, eliminate b, eliminate c) where eliminate (Just a) = a eliminate Nothing = 0
eliminate :: (Nothingish a) => Maybe a -> a eliminate (Just a) = a eliminate Nothing = nada
ghci> eliminate (Just 2) 2 ghci> eliminate (Just "foo") "foo" ghci> eliminate (Just (Just 3)) Just 3 ghci> eliminate (Just Nothing) Nothing ghci> :t eliminate eliminate :: (Nothingish t) => Maybe t -> t ghci> eliminate Nothing error! blah blah blah...**Ambiguous type variable**
ghci> let combine a b c = (eliminate a, eliminate b, eliminate c) ghci> combine (Just 2) (Just "foo") (Just (Just 3)) (2,"foo",Just 3) ghci> combine (Just 2) Nothing (Just 4) error! blah blah Ambiguous Type blah blah
ghci> combine (Just 2) (Nothing :: Maybe Int) (Just 4) (2,0,4) ghci> combine (Just 2) Nothing (Just 4) :: (Int, Int, Int) (2,0,4)
combine :: (Nothingish a) => Maybe a -> Maybe a -> Maybe a -> (a,a,a) combine a b c = (eliminate a, eliminate b, eliminate c)
ghci> combine (Just 2) (Just "foo") (Just (Just 3)) error! blah blah Couldn blah blah blah against inferred type blah blah
maybe :: b -> (a -> b) -> Maybe a -> b maybe n _ Nothing = n maybe _ f (Just x) = f x
fromJust :: Maybe a -> a fromJust Nothing = error "Maybe.fromJust: Nothing" fromJust (Just x) = x
getOrElse::Maybe a -> a -> a getOrElse (Just v) d = v getOrElse Nothing d = d
combine :: Maybe Int -> Maybe Int -> Maybe Int -> (Int, Int, Int)
combine a b c = (eliminate a, eliminate b, eliminate c) where eliminate (Just a) = a eliminate Nothing = undefined
(.) f g = \x -> f (g x) (.) (.) (.) = \x -> (.) ((.) x) \x f -> (.) ((.) x) f \x f y -> (((.)(f y)) x) \x f y g-> (((.)(f y) g) x) \x f y g-> ((f (g y)) x) \x f y g-> ((f (g y)) x):: t2 -> (t1 -> t2 -> t) -> t3 -> (t3 -> t1) -> t
fmap . fmap :: (a -> b) -> foo (bar a) -> foo (bar b)
(.) . (.) :: (a -> b) -> ((->) s) ((->) t a) -> ((->) s) ((->) t b) = (a -> b) -> (s -> (t -> a)) -> (s -> (t -> b)) = (a -> b) -> (s -> t -> a) -> (s -> t -> b)
(.) . (.) . (.) :: (a -> b) -> (s -> t -> u -> a) -> (s -> t -> u -> b)
concatMap :: (a -> [b]) -> [a] -> [b] concatMap f xs = concat (map f xs)
concatMap f = (.) concat (map f) concatMap f = (.) concat . map $ f concatMap = (.) concat . map concatMap = (concat .) . map
-- .: is fairly standard name for this combinator (.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> d (f .: g) x y = f (g x y) concatMap = concat .: map
(.:) = \f g x y -> f (g x y) = \f g x y -> f ((g x) y) = \f g x y -> f . g x $ y = \f g x -> f . g x
= \f g x -> (.) f (g x) = \f g x -> (.) f . g $ x = \f g -> (.) f . g = \f g -> (.) ((.) f) g = \f -> (.) ((.) f) = \f -> (.) . (.) $ f = (.) . (.)
result :: (b -> c) -> ((a -> b) -> (a -> c)) result = (.)
\x f y -> ((.) ((.) x) f) y :: (c -> d) -> (a -> b -> c) -> a -> b -> d \x f y z -> ((.) ((.) x) f) y z :: (c -> d) -> (a -> b -> c) -> a -> b -> d \x f y z -> ((.) x (f y)) z :: (c -> d) -> (a -> b -> c) -> a -> b -> d -- Or alternately: \x f y z -> (x . f y) z :: (c -> d) -> (a -> b -> c) -> a -> b -> d \x f y z -> (x (f y z)) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
(\f0 g0 x0 -> f0 (g0 x0)) (\f1 g1 x1 -> f1 (g1 x1)) (\f2 g2 x2 -> f2 (g2 x2))
\x0 -> (\f1 g1 x1 -> f1 (g1 x1)) ((\f2 g2 x2 -> f2 (g2 x2)) x0)
\x0 -> \g1 x1 -> ((\f2 g2 x2 -> f2 (g2 x2)) x0) (g1 x1)
(.) f g = \x -> f (g x) (.) . g = \x -> (.) (g x) = \x -> \y -> (.) (g x) y = \x -> \y -> \z -> (g x) (y z) = \x y z -> (g x) (y z) (.) . (.) = \x y z -> ((.) x) (y z) = \x y z -> \k -> x (y z k) = \x y z k -> x (y z k)
Prelude> :t (.) . (.) (.) . (.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c Prelude> :t \x y z k -> x (y z k) \x y z k -> x (y z k) :: (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t Prelude>
-- _B = (.) _B f g x = f (g x) _B _B _B f g x y = _B (_B f) g x y = (_B f) (g x) y = _B f (g x) y = f ((g x) y) = f (g x y)
type Ground = Int type FirstOrder a = Maybe a -- a is ground type SecondOrder c = c Int -- c is a first-order constructor type ThirdOrder c = c Maybe -- c is second-order
class Functor f where fmap :: (a -> b) -> f a -> f b -- a couple examples: instance Functor Maybe where -- fmap :: (a -> b) -> Maybe a -> Maybe b fmap _ Nothing = Nothing fmap f (Just x) = Just (f x) instance Functor [] where -- fmap :: (a -> b) -> [a] -> [b] fmap _ [] = [] fmap f (x:xs) = f x : fmap f xs
focusFirst :: Functor f => (a -> f b) -> (a, c) -> f (b, c) focusFirst f (a, c) = fmap (\x -> (x, c)) (f a) focusSecond :: Functor f => (a -> f b) -> (c, a) -> f (c, b) focusSecond f (c, a) = fmap (\x -> (c, x)) (f a)
newtype Identity a = Identity { runIdentity :: a } instance Functor Identity where -- fmap :: (a -> b) -> Identity a -> Identity b fmap f (Identity x) = Identity (f x) newtype Const c b = Const { getConst :: c } instance Functor (Const c) where -- fmap :: (a -> b) -> Const c a -> Const c b fmap _ (Const c) = Const c set :: ((a -> Identity b) -> s -> Identity t) -> b -> s -> t set f b s = runIdentity (f (\_ -> Identity b) s) get :: ((a -> Const a b) -> s -> Const a t) -> s -> a get f s = getConst (f (\x -> Const x) s)
function collection.sum --> inject(zero, function (v,t) --> t+v )
shuffle(Lst) -> array:to_list(shuffle(array:from_list(Lst), erlang:length(Lst) - 1)). shuffle(Array, 0) -> Array; shuffle(Array, N) -> K = random:uniform(N) - 1, Ek = array:get(K, Array), En = array:get(N, Array), shuffle(array:set(K, En, array:set(N, Ek, Array)), N-1).
def area(figure : List[Point]) : Float = { if(figure.empty) return 0 val last = figure(0) var first= figure(0) val ret = 0 for (pt <- figure) { ret+=crossprod(last - first, pt - first) last = pt } ret }
def area(figure : List[Point]) : Float = { if figure.length < 3 0 else var a = figure(0) var b = figure(1) var c = figure(2) if figure.length == 3 magnitude(crossproduct(b-a,c-a)) else foldLeft((0,a,b))(figure.rest)) { ((t,a,b),c) => (t+area([a,b,c]),a,c) }
def area([]) = 0.0 def area([_]) = 0.0 def area([_,_]) = 0.0 def area([a,b,c]) = magnitude(crossproduct(b-a,c-a)) def area(figure) = as_triangles(figure).collect(area).sum def as_triangles([]) = [] def as_triangles([_]) = [] def as_triangles([_,_]) = [] def as_triangles([a,b,c | rest) = [[a,b,c] | as_triangles([a,c | rest])]
-- | Implementation of the random swap algorithm for shuffling. Reads a list -- into a mutable ST array, shuffles it in place, and reads out the result -- as a list. module Data.Shuffle (shuffle) where import Control.Monad import Control.Monad.ST import Data.Array.ST import Data.STRef import System.Random -- | Shuffle a value based on a random seed. shuffle :: (RandomGen g) => g -> [a] -> [a] shuffle _ [] = [] shuffle g xs = runST $ do sg <- newSTRef g let n = length xs v <- newListArray (1, n) xs mapM_ (shuffle1 sg v) [1..n] getElems v -- Internal function to swap element i with a random element at or above it. shuffle1 :: (RandomGen g) => STRef s g -> STArray s Int a -> Int -> ST s () shuffle1 sg v i = do (_, n) <- getBounds v r <- getRnd sg $ randomR (i, n) when (r /= i) $ do vi <- readArray v i vr <- readArray v r writeArray v i vr writeArray v r vi -- Internal function for using random numbers getRnd :: (RandomGen g) => STRef s g -> (g -> (a, g)) -> ST s a getRnd sg f = do g1 <- readSTRef sg let (v, g2) = f g1 writeSTRef sg g2 return
module Vector = type point = { x : float; y : float} with static member ( + ) ((p1 : point), (p2 : point)) = { x = p1.x + p2.x; y = p1.y + p2.y;} static member ( * ) ((p : point), (scalar : float)) = { x = p.x * scalar; y = p.y * scalar;} static member ( - ) ((p1 : point), (p2 : point)) = { x = p1.x - p2.x; y = p1.y - p2.y;} let empty = { x = 0.; y = 0.;} let to_tuple2 (p : point) = (p.x, p.y) let from_tuple2 (x, y) = { x = x; y = y;} let crossproduct (p1 : point) (p2 : point) = { x = p1.x * p2.y; y = -p1.y * p2.x }
let area (figure : point list) = figure |> Seq.map to_tuple2 |> Seq.fold (fun (sum, (a, b)) (c, d) -> (sum + a*d - b*c, (c, d) ) ) (0., to_tuple2 (List.hd figure)) |> fun (sum, _) -> abs(sum) / 2.0
let area2 (figure : point list) = figure |> Seq.fold (fun (acc, prev) cur -> (acc + (crossproduct prev cur), cur)) (empty, List.hd figure) |> fun (acc, _) -> abs(acc.x + acc.y) / 2.0
shuffle(Lst) -> array:to_list(shuffle(array:from_list(Lst), erlang:length(Lst) - 1)). shuffle(Array, 0) -> Array; shuffle(Array, N) -> K = random:uniform(N) - 1, Ek = array:get(K, Array), En = array:get(N, Array), shuffle(array:set(K, En, array:set(N, Ek, Array)), N-1).
function forbidden_input?(s) (s = (s = (s = n = if forbidden_input?(s) fail " else case s /^\d*$/ : s.to_int else fail "I don
def quant[A](x : List[A], q : A) = { var tmp : A=0 for (el <- x) { tmp+= el; if(tmp > q) return el; } }
def area(figure : List[Point]) : Float = { if(figure.empty) return 0 val last = figure(0) var first= figure(0) val ret = 0 for (pt <- figure) { ret+=crossprod(last - first, pt - first) last = pt } ret }
blah :: a -> b -> a blah x y = ble x where ble :: b -> b ble x = x
blah :: forall a b. a -> b -> a blah x y = ble x where ble :: b -> b ble x = x
foo.hs:2:16: Couldn `a the type signature for blah :: a -> b -> a at foo.hs:2:1 `b the type signature for blah :: a -> b -> a at foo.hs:2:1 In the first argument of `ble In the expression: ble x In an equation for `blah blah x y = ble x where ble :: b -> b ble x = x
-- defined in Prelude asTypeOf :: a -> a -> a x `asTypeOf` y = x
blah :: a -> b -> a blah x y = ble x where ble x = x `asTypeOf` y
foo :: Bounded a => Maybe a -> a foo m = x where x = maxBound -- Q: how do I make (x :: a) when given (Maybe a)? _ = Just x `asTypeof` m -- A: witchcraft!
newtype Exit a = Exit { getExit :: a } deriving (Typeable) instance Show (Exit a) where show _ = "EXIT" instance (Typeable a) => Exception (Exit a) unsafeCatch :: (Exception e) => a -> (e -> a) -> a unsafeCatch x f = unsafePerformIO $ catch (seq x $ return x) (return . f)
callCC :: (Typeable a) => ((a -> b) -> a) -> a callCC f = unsafeCatch (f (throw . Exit)) (\(Exit e) -> e)
-- This will clearly never terminate, no matter what k is foo k = fix (\f x -> if x > 100 then f (k x) else f (x + 1)) 0
seqs :: [a] -> [a] seqs xs = foldr (\h t -> h `seq` t `seq` (h:t)) [] xs bar n k = map (\x -> if x > 10 then k [x] else x) [0..n]
∀x. x ⊢ callCC (seqs . bar 9) [0,1,2,3,4,5,6,7,8,9] ∀x. x ⊢ callCC (seqs . bar 11) [11]
takeN :: Integer -> [a] -> [a] takeN n l = take n l
takeN :: Integer -> [a] -> [a] takeN n l = take (fromIntegral n) l
module (Even) where newtype Even = Even Integer instance Num Even where ... fromInteger x | x `mod` 2 == 0 = Even x | otherwise = error "Not an even number." instance Integral Even where ... toInteger (Even x) = x
Prelude Data.Word> let x = 0 :: Word in if x - 1 > x then "Ouch" else "Ohayoo" "Ouch"
Prelude Data.Word> let f acc x y = if x <= y then f (acc + 1) x (y - 1) else acc Prelude Data.Word> :t f f :: (Num a1, Num a, Ord a) => a1 -> a -> a -> a1
Prelude Data.Word> let len Prelude Data.Word> :t len' len Prelude Data.Word> f 0 0 (len 4
Prelude Data.Word> let len x = if null x then 0 else 1 + len (tail x) :: Word Prelude Data.Word> :t len len :: [a] -> Word Prelude Data.Word> f 0 0 (len [1,2,3]) ...diverges...
instance (b ~ c, CanFilterFunc b a) => CanFilter (b -> c) a where filter = filterFunc
instance (CanFilterFunc b a) => CanFilter (c -> c) a where filter = filterFunc
instance (CanFilterFunc b a) => CanFilter (b -> b) a where filter = filterFunc
class Twice1 f where twice1 :: f -> f class Twice2 f where twice2 :: f -> f
instance Twice1 (a -> a) where twice1 f = f . f instance (a ~ b) => Twice2 (a -> b) where twice2 f = f . f
class Example a where transform :: Int -> a instance Example Int where transform n = n + 1 instance Example Char where transform _ =
apply1 x = twice1 transform x apply2 x = twice2 transform x
apply1 :: (Example a, Twice1 (Int -> a)) => Int -> a apply2 :: Int -> Int
module Main where import Prelude -- copied from https: class TypeEquals a b | a -> b, b -> a where to :: a -> b from :: b -> a instance refl :: TypeEquals a a where to a = a from a = a ----------------- class Twice1 f where twice1 :: f -> f class Twice2 f where twice2 :: f -> f instance mytwice1 :: Twice1 (a -> a) where twice1 f = f >>> f instance mytwice2 :: TypeEquals a b => Twice2 (a -> b) where twice2 f = f >>> from >>> f class Example a where transform :: Int -> a instance exampleInt :: Example Int where transform n = n + 1 instance exampleChar :: Example Char where transform _ = {-- -- will raise error -- No type class instance was found for Main.Twice1 (Int -> t1) apply1 x = twice1 transform x -- to resolve error add type declaration apply1 :: Int -> Int --} -- compiles without error and manual type declaration, has type Int -> Int automatically apply2 x = twice2 transform x
module Main import Prelude interface Twice f where twice : f -> f Twice (a -> a) where twice f = f . f interface Example a where transform : Int -> a Example Int where transform n = n + 1 Example Char where transform _ = -- run in REPL to see that it derives properly: -- $ idris src/15_EqualityConstraint_Twice_class.idr -- *src/15_EqualityConstraint_Twice_class> :t twice transform -- twice transform : Int -> Int -- Summary: -- in idris you dont need equality constaint to derive type of such functions properly
f :: Ord a => a -> a -> Ordering g :: Ord a => a -> a -> Ordering
h x y = case v of EQ -> g x y otherwise -> v where v = f x y
Prelude Data.Monoid> let f a b = EQ Prelude Data.Monoid> let g a b = LT Prelude Data.Monoid> :t f `mappend` g f `mappend` g :: t -> t1 -> Ordering Prelude Data.Monoid> (f `mappend` g) undefined undefined LT Prelude Data.Monoid> let f a b = GT Prelude Data.Monoid> (f `mappend` g) undefined undefined GT
myF1 :: forall a . a -> Int myF1 _ = 123 -- okay, that function (`a -> Int`) does exist for any `a` -- because we have just defined it
myF2 :: exists a . a -> Int myF2 _ = 123 -- okay, there is at least one type `a` for which there is such function -- because, in fact, we have just defined it for any type -- and there is at least one type... -- so these two lines are equivalent to the two lines above
class Player p m where -- deal them in to a particular game dealIn :: TotalPlayers -> PlayerPosition -> [Card] -> StateT p m () -- let them know what another player does notify :: Event -> StateT p m () -- ask them to make a suggestion suggest :: StateT p m (Maybe Scenario) -- ask them to make an accusation accuse :: StateT p m (Maybe Scenario) -- ask them to reveal a card to invalidate a suggestion reveal :: (PlayerPosition, Scenario) -> StateT p m Card
-- wrapper for storing a player within a given monad data WpPlayer m = forall p. Player p m => WpPlayer p
WpPlayer :: forall p. Player p m => p -> WpPlayer m
unWpPlayer :: forall p. Player p m => WpPlayer m -> p
unWpPlayer :: exists p. Player p m => WpPlayer m -> p
x2 :: exists a . (a, a -> Int) x2 = (3 :: Int, id) xapp :: (exists b . (b,b -> a)) -> a xapp (v,f) = f v x2app = xapp x2
mkx :: Bool -> exists a . (a, a -> Int) mkx b = if b then x2 else ( y1 = mkx True -- y1 :: (C_3_225_0_0,C_3_225_0_0 -> Int) y2 = mkx False -- y2 :: (C_3_245_0_0,C_3_245_0_0 -> Int) mixy = let (v1,f1) = y1 (v2,f2) = y2 in f1 v2
main :: IO () main = do putStrLn (show (xapp y1)) putStrLn (show (xapp y2))
class SomeService a where g :: a -> typeOfSomeParms -> gReturnType data SomeServiceImpl = SomeServiceImpl data MockSomeServiceImpl = MockSomeServiceImpl instance SomeService SomeServiceImpl where g _ someParms = ... -- real implementation of g instance SomeService MockSomeServiceImpl where g _ someParms = ... -- mock implementation of g
f someService ... = ... g someService someParms ...
{- import Control.Monad.RWS data (Monad m) => ServiceImplementation m = ServiceImplementation { serviceHello :: m () , serviceGetLine :: m String , servicePutLine :: String -> m () } serviceHelloBase :: (Monad m) => ServiceImplementation m -> m () serviceHelloBase impl = do name <- serviceGetLine impl servicePutLine impl $ "Hello, " ++ name realImpl :: ServiceImplementation IO realImpl = ServiceImplementation { serviceHello = serviceHelloBase realImpl , serviceGetLine = getLine , servicePutLine = putStrLn } mockImpl :: (Monad m, MonadReader String m, MonadWriter String m) => ServiceImplementation m mockImpl = ServiceImplementation { serviceHello = serviceHelloBase mockImpl , serviceGetLine = ask , servicePutLine = tell } main = serviceHello realImpl test = case runRWS (serviceHello mockImpl) "Dave" () of (_, _, "Hello, Dave") -> True; _ -> False
data FunctionGroup t = FunctionGroup { g :: Int -> Int, h :: t -> Int } a grp ... = ... g grp someThing ... h grp someThingElse ...
class HasFunctionGroup t where g :: Int -> t h :: t -> Int a :: HasFunctionGroup t => <some type involving t> a ... = ... g someThing ... h someThingElse
g :: typeOfSomeParms -> gReturnType g = g_mock -- change this to "g_real" when you need to g_mock someParms = ... -- mock implementation of g g_real someParms = ... -- real implementation of g
import Data.List -- Declaration of rand minMax :: [Int] -> Maybe (Int, Int) minMax [] = Nothing minMax (x:xs) = Just (foldl where f (a, b) c = (if c < a then c else a, if c > b then c else b)
main = print $ minMax $ take 1000000 $ rand 7666532
f (a, b) c = a `seq` b `seq` (if c < a then c else a, if c > b then c else b)
minMax :: [Int] -> Maybe (Pair Int Int) minMax [] = Nothing minMax (x:xs) = Just (foldl where f (Pair a b) c = Pair (if c < a then c else a) (if c > b then c else b)
guard :: (MonadPlus m) => Bool -> m () guard True = return () guard False = mzero
data PipeF a b m r = M (m r) | Await (a -> r) | Yield b r instance Monad m => Functor (PipeF a b m) where fmap f (M mr) = M $ liftM mr fmap f (Await g) = Await $ f . g fmap f (Yield b p) = Yield b (f p) --Giving: newtype Pipe a b m r = Pipe {unPipe :: Free (PipeF a b m) r} deriving (Functor, Applicative, Monad) --and instance MonadTrans (Pipe a b) where lift = Pipe . inj . M
{- {- module Text.Parsec.Text ( Parser, GenParser ) where import Text.Parsec.Prim import qualified Data.Text as T instance (Monad m) => Stream T.Text m Char where uncons = return . T.uncons type Parser = Parsec T.Text () type GenParser t st = Parsec T.Text st
module TestText where import Data.Text as T import Text.Parsec import Text.Parsec.Prim import Text.Parsec.Text input = T.pack "xxxxxxxxxxxxxxyyyyxxxxxxxxxp" parser = do x1 <- many1 (char y <- many1 (char x2 <- many1 (char return (T.pack x1, T.pack y, T.pack x2) test = runParser parser () "test" input
-- A derivate work from -- http: {- {- module Text.Parsec.Text ( Parser, GenParser, parseFromUtf8File ) where import Text.Parsec.Prim import qualified Data.Text as T import qualified Data.ByteString as B import Data.Text.Encoding import Text.Parsec.Error instance (Monad m) => Stream T.Text m Char where uncons = return . T.uncons type Parser = Parsec T.Text () type GenParser t st = Parsec T.Text st -- | @parseFromUtf8File p filePath@ runs a strict bytestring parser -- @p@ on the input read from @filePath@ using -- -- value of type @a@ ( -- -- > main = do{ result <- parseFromFile numbers "digits.txt" -- > ; case result of -- > Left err -> print err -- > Right xs -> print (sum xs) -- > } parseFromUtf8File :: Parser a -> String -> IO (Either ParseError a) parseFromUtf8File p fname = do raw <- B.readFile fname let input = decodeUtf8 raw return (runP p () fname input)
data Term = Hol Term | Var Int | Lam (Term -> Term) | App Term Term pretty :: Term -> String pretty = go 0 where go lvl term = case term of Hol hol -> go lvl hol Var idx -> "x" ++ show idx Lam bod -> "λx" ++ show lvl ++ ". " ++ go (lvl+1) (bod (Hol (Var lvl))) App fun arg -> "(" ++ go lvl fun ++ " " ++ go lvl arg ++ ")" reduce :: Term -> Term reduce (Hol hol) = hol reduce (Var idx) = Var idx reduce (Lam bod) = Lam (\v -> reduce (bod v)) reduce (App fun arg) = case reduce fun of Hol fhol -> App (Hol fhol) (reduce arg) Var fidx -> App (Var fidx) (reduce arg) Lam fbod -> fbod (reduce arg) App ffun farg -> App (App ffun farg) (reduce arg) main :: IO () main = putStrLn . pretty . reduce $ App (Lam$ \x -> App x x) (Lam$ \s -> Lam$ \z -> App s (App s (App s z)))
isPrime a = isPrimeHelper a primes isPrimeHelper a (p:ps) | p*p > a = True | a `mod` p == 0 = False | otherwise = isPrimeHelper a ps primes = 2 : filter isPrime [3,5..]
*Main> :set +s *Main> primes!!10000 104743 (2.10 secs, 169800904 bytes) *Main> primes!!10000 104743 (0.00 secs, 0 bytes)
import Graphics.Rendering.OpenGL as GL import qualified Graphics.UI.GLFW as GLFW import Graphics.Rendering.OpenGL (($=)) import Control.Monad import EnableGUI main = do enableGUI GLFW.initialize -- open window GLFW.openWindow (GL.Size 400 400) [GLFW.DisplayAlphaBits 8] GLFW.Window GLFW.windowTitle $= "Bitmap Test" -- enable alpha channel GL.blend $= GL.Enabled GL.blendFunc $= (GL.SrcAlpha, GL.OneMinusSrcAlpha) -- set the color to clear background GL.clearColor $= GL.Color4 0.8 0.8 0.8 0 -- set 2D orthogonal view inside windowSizeCallback because -- any change to the Window size should result in different -- OpenGL Viewport. GLFW.windowSizeCallback $= \ size@(GL.Size w h) -> do GL.viewport $= (GL.Position 0 0, size) GL.matrixMode $= GL.Projection GL.loadIdentity GL.ortho2D 0 (realToFrac w) (realToFrac h) 0 render <- initialize loop render GLFW.closeWindow loop render = do -- draw the entire screen render -- swap buffer GLFW.swapBuffers -- check whether ESC is pressed for termination p <- GLFW.getKey GLFW.ESC unless (p == GLFW.Press) $ do -- sleep for 1ms to yield CPU to other applications GLFW.sleep 0.001 -- only continue when the window is not closed windowOpenStatus <- GLFW.getParam GLFW.Opened unless (windowOpenStatus == False) $ loop render -- rendering initialize = do -- load texture from file GL.texture GL.Texture2D $= Enabled [textureName] <- GL.genObjectNames 1 GL.textureBinding GL.Texture2D $= Just textureName GL.textureFilter GL.Texture2D $= ((GL.Nearest, Nothing), GL.Nearest) GLFW.loadTexture2D "Bitmap.tga" [] return $ do GL.clear [GL.ColorBuffer] GL.renderPrimitive GL.Quads $ do GL.texCoord $ texCoord2 0 0 GL.vertex $ vertex3 (0) 256 0 GL.texCoord $ texCoord2 0 1 GL.vertex $ vertex3 (0) (0) 0 GL.texCoord $ texCoord2 1 1 GL.vertex $ vertex3 256 (0) 0 GL.texCoord $ texCoord2 1 0 GL.vertex $ vertex3 256 256 0 -- type signatures to avoid ambiguity vertex3 :: GLfloat -> GLfloat -> GLfloat -> GL.Vertex3 GLfloat vertex3 = GL.Vertex3 texCoord2 :: GLfloat -> GLfloat -> GL.TexCoord2 GLfloat texCoord2 = GL.TexCoord2 color3 :: GLfloat -> GLfloat -> GLfloat -> GL.Color3 GLfloat color3 = GL.Color3
import Graphics.UI.Gtk hello :: (ButtonClass o) => o -> IO () hello b = set b [buttonLabel := "Hello World"] main :: IO () main = do initGUI window <- windowNew button <- buttonNew set window [windowDefaultWidth := 200, windowDefaultHeight := 200, containerChild := button, containerBorderWidth := 10] onClicked button (hello button) onDestroy window mainQuit widgetShowAll window mainGUI
break (Fix f) = Free (fmap break f) affix (Free f) = Fix (fmap affix f)
(break . affix) (Free f) === [definition of affix] break (Fix (fmap affix f)) === [definition of break] Free (fmap break (fmap affix f)) === [definition of (.)] Free ( (fmap break . fmap affix) f ) === [functor coherence laws] Free (fmap (break . affix) f)
import Data.Void import Control.Monad.Free free2fix :: Functor f => Free f Void -> Fix f free2fix (Pure void) = absurd void free2fix (Free body) = Fix (free2fix <$> body) fixToFree :: Functor f => Fix f -> Free f Void fixToFree (Fix body) = Free (fixToFree <$> body)
import Control.Comonad.Cofree cofree2fix :: Functor f => Cofree f () -> Fix f cofree2fix (() :< body) = Fix (cofree2fix <$> body) fixToCofree :: Functor f => Fix f -> Cofree f () fixToCofree (Fix body) = () :< (fixToCofree <$> body)
{- {- class (Eq a, Show a) => Genome a where crossover :: (Fractional b) => b -> a -> a -> IO (a, a) mutate :: (Fractional b) => b -> a -> IO a develop :: (Phenotype b a) => a -> b class (Eq a, Show a) => Phenotype a b | a -> b where -- In case of Coevolution where each phenotype needs to be compared to -- every other in the population fitness :: [a] -> a -> Int genome :: (Genome b) => a -> b -- here, the problem breed parents cross mute = do children <- mapM (\ (dad, mom) -> crossover cross (genome dad) (genome mom)) parents let ch1 = map fst children ++ map snd children mutated <- mapM (mutate mute) ch1 return $ map develop mutated
class (Eq a, Show a, Genome b) => Phenotype a b | a -> b where -- In case of Coevolution where each phenotype needs to be compared to -- every other in the population fitness :: [a] -> a -> Int genome :: a -> b
class (Bounded i, Enum i) => Partition a i where index :: a -> i
data NormalDist = NormalDist Double Double -- mean, var instance PDist NormalDist where... data LognormalDist = LognormalDist Double Double instance PDist LognormalDist where...
mkNormalDist :: Double -> Double -> PDist... mkLognormalDist :: Double -> Double -> PDist...
data SumDist a b = SumDist a b instance (PDist a, PDist b) => PDist (SumDist a b)...
class Drawing a where drawAsHtml :: a -> Html drawOpenGL :: a -> IO () exampleFunctionA :: Drawing a => a -> a -> Something exampleFunctionB :: (Drawing a, Drawing b) => a -> b -> Something
main = do let mvars = sequence (replicate num_of_child_threads newEmptyMVar) returnVals <- sequence (zipWith (\m f -> f m) mvars (list_of_child_threads :: [MVar -> IO a]))
import Control.Monad.State import Control.Monad.Trans.List import Control.Monad.Morph import Data.List (foldl type CS a b = StateT [a] (ListT (State Int)) b select select select select :: CS a a select = do i <- lift . lift $ get xs <- get lift . lift . put $! i + length xs hoist (ListT . return) (StateT select runCS :: CS a b -> [a] -> ([b], Int) runCS a xs = flip runState 0 . runListT $ evalStateT a xs fromDigits :: [Int] -> Int fromDigits = foldl sendMoreMoney :: ([(Int, Int, Int)], Int) sendMoreMoney = flip runCS [0..9] $ do [s,e,n,d,m,o,r,y] <- replicateM 8 select let send = fromDigits [s,e,n,d] more = fromDigits [m,o,r,e] money = fromDigits [m,o,n,e,y] guard $ s /= 0 && m /= 0 && send + more == money return (send, more, money) main :: IO () main = print sendMoreMoney
$ ghc -O2 -Wall -fforce-recomp -rtsopts statefulbacktrack.hs [1 of 1] Compiling Main ( statefulbacktrack.hs, statefulbacktrack.o ) Linking statefulbacktrack ... $ time ./statefulbacktrack ([(9567,1085,10652)],2606500) real 0m6.960s user 0m3.880s sys 0m2.968s
$ strace -cf ./statefulbacktrack ([(9567,1085,10652)],2606500) % time seconds usecs/call calls errors syscall ------ ----------- ----------- --------- --------- ---------------- 98.38 0.033798 1469 23 munmap 1.08 0.000370 0 21273 rt_sigprocmask 0.26 0.000090 0 10638 clock_gettime 0.21 0.000073 0 10638 getrusage 0.07 0.000023 4 6 mprotect 0.00 0.000000 0 8 read 0.00 0.000000 0 1 write 0.00 0.000000 0 144 134 open 0.00 0.000000 0 10 close 0.00 0.000000 0 1 execve 0.00 0.000000 0 9 9 access 0.00 0.000000 0 3 brk 0.00 0.000000 0 1 ioctl 0.00 0.000000 0 847 sigreturn 0.00 0.000000 0 1 uname 0.00 0.000000 0 1 select 0.00 0.000000 0 13 rt_sigaction 0.00 0.000000 0 1 getrlimit 0.00 0.000000 0 387 mmap2 0.00 0.000000 0 16 15 stat64 0.00 0.000000 0 10 fstat64 0.00 0.000000 0 1 1 futex 0.00 0.000000 0 1 set_thread_area 0.00 0.000000 0 1 set_tid_address 0.00 0.000000 0 1 timer_create 0.00 0.000000 0 2 timer_settime 0.00 0.000000 0 1 timer_delete 0.00 0.000000 0 1 set_robust_list ------ ----------- ----------- --------- --------- ---------------- 100.00 0.034354 44039 159 total
$ ./statefulbacktrack +RTS -s ([(9567,1085,10652)],2606500) 5,541,572,660 bytes allocated in the heap 1,465,208,164 bytes copied during GC 27,317,868 bytes maximum residency (66 sample(s)) 635,056 bytes maximum slop 65 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 10568 colls, 0 par 1.924s 2.658s 0.0003s 0.0081s Gen 1 66 colls, 0 par 0.696s 2.226s 0.0337s 0.1059s INIT time 0.000s ( 0.001s elapsed) MUT time 1.656s ( 2.279s elapsed) GC time 2.620s ( 4.884s elapsed) EXIT time 0.000s ( 0.009s elapsed) Total time 4.276s ( 7.172s elapsed) %GC time 61.3% (68.1% elapsed) Alloc rate 3,346,131,972 bytes per MUT second Productivity 38.7% of total user, 23.1% of total elapsed
$ ghc --version The Glorious Glasgow Haskell Compilation System, version 7.10.1 $ uname -a Linux debian 3.2.0-4-686-pae
-- BIG UGLY HACK: The desugarer special cases this module. Despite the uses of -- the desugarer does not load -- the present module may not use any other piece of -- -- This will be cleaned up when we change the internal represention of -- rely on a wired-in type constructor.
{- data Foo = forall a. Foo a ignorefoo f = 1 where Foo a = f
$ hoogle "Num a => [a] -> a" Prelude product :: Num a => [a] -> a Prelude sum :: Num a => [a] -> a $ hoogle "[Maybe a] -> [a]" Data.Maybe catMaybes :: [Maybe a] -> [a] $ hoogle "Monad m => [m a] -> m [a]" Prelude sequence :: Monad m => [m a] -> m [a] $ hoogle "[a] -> [b] -> (a -> b -> c) -> [c]" Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
class Monad m where (>>=) :: m a -> (a -> m b) -> m b return :: a -> m a
instance Monad [] where (>>=) :: [a] -> (a -> [b]) -> [b] return :: a -> [a]
return a >>= f == f a ma >>= (\a -> return a) == ma (ma >>= f) >>= g == ma >>= (\a -> f a >>= g)
instance Monad [] where (>>=) = concatMap return = (:[]) return a >>= f == [a] >>= f == concatMap f [a] == f a ma >>= (\a -> return a) == concatMap (\a -> [a]) ma == ma (ma >>= f) >>= g == concatMap g (concatMap f ma) == concatMap (concatMap g . f) ma == ma >>= (\a -> f a >>= g)
double x = [x,x] main = do print $ map double [1,2,3] -- [[1,1],[2,2],[3,3]] print . concat $ map double [1,2,3] -- [1,1,2,2,3,3] print $ concatMap double [1,2,3] -- [1,1,2,2,3,3] print $ [1,2,3] >>= double -- [1,1,2,2,3,3]
{- inside a comment, {- inside another comment, -} still commented! -}
{- module Exp where data Exp a where Num :: (Num a) => a -> Exp a Bool :: Bool -> Exp Bool Plus :: (Num a) => Exp a -> Exp a -> Exp a If :: Exp Bool -> Exp a -> Exp a -> Exp a Lt :: (Num a, Ord a) => Exp a -> Exp a -> Exp Bool Lam :: (a -> Exp b) -> Exp (a -> b) -- higher order abstract syntax App :: Exp (a -> b) -> Exp a -> Exp b -- deriving (Show) -- failse eval :: Exp a -> a eval (Num n) = n eval (Bool b) = b eval (Plus e1 e2) = eval e1 + eval e2 eval (If p t f) = eval $ if eval p then t else f eval (Lt e1 e2) = eval e1 < eval e2 eval (Lam body) = \x -> eval $ body x eval (App f a) = eval f $ eval a instance Eq a => Eq (Exp a) where e1 == e2 = eval e1 == eval e2 instance Show (Exp a) where show e = "<exp>" -- very weak show instance instance (Num a) => Num (Exp a) where fromInteger = Num (+) = Plus
five :: Int Just five = Just 5 a, b, c :: Char [a,b,c] = "abc"
main = foo (error "explode!") where foo _ = print "ignored"
main = error "first" `seq` print "impossible to print"
main = seq (error "first") (print "impossible to print")
main = print (1 +++ 2 *** 3) infixr 6 +++ infixr 7 ***, (+++) :: Int -> Int -> Int a +++ b = a + 2*b (***) :: Int -> Int -> Int a *** b = a - 4*b ( a Output: -19
main = print (a `foo` b) foo :: Int -> Int -> Int foo a b = a + b
map (\a -> {- some long expression -}) list flip map list $ \a -> {- some long expression -}
foo : bar : baz : _ = [100 ..] -- foo = 100, bar = 101, baz = 102
fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
module Foo (module Bar, blah) -- this is module Foo, export everything that Bar expored, plus blah import qualified Some.Long.Name as Short import Some.Long.Name (name) -- can import multiple times, with different options import Baz hiding (blah) -- import everything from Baz, except something named
-- factorial can be written, using the strict HOF foldl fac n = Data.List.foldl -- there fac n = product [1..n] -- and it can even be written pointfree: fac = product . enumFromTo 1
fibs = 0 : 1 : [ a + b | a <- fibs | b <- tail fibs ]
data MyEnum = A | B | C deriving(Eq, Show, Enum) main = do print $ [A ..] -- prints "[A,B,C]" print $ map fromEnum [A ..] -- prints "[0,1,2]"
every n xs = case drop (n-1) xs of (y:ys) -> y : every n ys [] -> []
extractEvery m = map snd . filter (\(x,y) -> (mod x m) == 0) . zip [1..]
everyf n [] = [] everyf n as = head as : everyf n (drop n as)
extractEvery n = map snd . filter fst . zip (cycle (replicate (n-1) False ++ [True]))
extractEvery n = map snd . filter ((== n) . fst) . zip (cycle [1..n])
everynth :: Int -> [a] -> [a] everynth n xs = y : everynth n ys where y : ys = drop (n-1) xs
takeEveryM m lst = [n | (i,n) <- zip [1..] lst, i `mod` m == 0]
import Data.List takeEveryMth m = (unfoldr g) . dr where dr = drop (m-1) g (x:xs) = Just (x, dr xs) g [] = Nothing
{- everynth n (drop (n-1) -> l) | null l = [] | otherwise = head l : everynth n (tail l)
everynth :: Int -> [a] -> [a] everynth n l = case splitAt (n-1) l of (_, (x:xs)) -> x : everynth n xs _ -> []
everyNth n l = foldr cons nil l (n-1) where nil _ = [] cons x rest 0 = x : rest n cons x rest n = rest (n-1)
everyNth :: Int -> [a] -> [a] everyNth n = unfoldr g where g [] = Nothing g xs = let (ys, zs) = splitAt n xs in Just (head ys, zs)
everyNth :: [a] -> Int -> [a] everyNth xs n = [snd x | x <- (zip [1..] xs), fst x `mod` n == 0]
{- import Data.List (unfoldr) import Data.Maybe (listToMaybe) every n = unfoldr f . drop (n - 1) where f xs = (,drop n xs) <$> listToMaybe xs
everyNth n [] = [] everyNth n (x:xs) = x : (everyNth n . drop (n-1)) xs
{-| keep every k-th value from the list -} sieve, sieve sieve k = unfoldr (\xs -> toMaybe (not (null xs)) (head xs, drop k xs)) sieve sieve sieve propSieve :: Eq a => Int -> [a] -> Bool propSieve n x = sieve n x == sieve sieve n x == sieve
everyNth :: Int -> [a] -> [a] everyNth 0 = take 1 everyNth n = foldr ($) [] . zipWith ($) operations where operations = cycle $ (:) : replicate (n-1) (const id)
every :: Eq a => Int -> [a] -> [a] every n xs = if rest == [] then [] else head rest : every n (tail rest) where rest = drop (n-1) xs
every n xs = if rest == [] then [] else head rest : every n (tail rest) where rest = drop (n-1) xs
every :: Int -> [a] -> [[a]] every _ [] = [] every n list = take n list : (every n $ drop n list)
return :: Monad m => a -> m a (>>=) :: Monad m => m a -> (a -> m b) -> m b
data Null a = Null instance Monad Null where return a = Null ma >>= f = Null
appendLine :: String -> String appendLine str = str ++ extract getLine
data Action = Get (Char -> Action) | Put Char Action | End
data IO a = Get (Char -> Action) | Put Char Action | End a
int f() { char x; scanf("%c", &x); if (x == printf("B"); return 3; } else return 4; }
bool comp(char x) { char y; scanf("%c", &y); if (x > y) { printf(">"); return true; } else { printf("<"); return false; } }
comp :: Char -> IO Bool comp x = Get (\y -> if x > y then Put
(Get (\x -> Put (toUpper x) (End 0)), Get (\x -> Put (toLower x) (End 0))) :: (IO Int, IO Int)
pair<vector<char>, world_t> read(world_t, filepath_t)
import Control.Concurrent import System.IO as IO import Data.IORef as IOR import Control.Monad.STM import Control.Concurrent.STM.TVar limit = 150000 threadsCount = 50 -- Don -- in unlocked memory ... PURE language don -- there isn main = do hSetBuffering stdout NoBuffering putStr "Lock counter? : " a <- getLine if a == "y" || a == "yes" || a == "Yes" || a == "Y" then withLocking else noLocking noLocking = do counter <- newIORef 0 let doWork = mapM_ (\_ -> IOR.modifyIORef counter (\x -> x + 1)) [1..limit] threads <- mapM (\_ -> forkIO doWork) [1..threadsCount] -- Sorry, it threadDelay (15 * 1000 * 1000) val <- IOR.readIORef counter IO.putStrLn ("It may be " ++ show (threadsCount * limit) ++ " but it is " ++ show val) withLocking = do counter <- atomically (newTVar 0) let doWork = mapM_ (\_ -> atomically $ modifyTVar counter (\x -> x + 1)) [1..limit] threads <- mapM (\_ -> forkIO doWork) [1..threadsCount] threadDelay (15 * 1000 * 1000) val <- atomically $ readTVar counter IO.putStrLn ("It may be " ++ show (threadsCount * limit) ++ " but it is " ++ show val)
compose2 :: (c -> d) -> (a -> b -> c) -> a -> b -> d compose2 g f x y = g (f x y) diffsq = (^2) `compose2` (-)
fmap . fmap :: (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
(.) . (.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
fmap . fmap . fmap :: (Functor f, Functor g, Functor h) => (a -> b) -> f (g (h a)) -> f (g (h b)) fmap . fmap . fmap . fmap :: (Functor f, Functor g, Functor h, Functor i) => (a -> b) -> f (g (h (i a))) -> f (g (h (i b))
(.) . (.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
(.*) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d) (.*) = (.) . (.) (.**) :: (d -> e) -> (a -> b -> c -> d) -> (a -> b -> c -> e) (.**) = (.) . (.*) diffsq :: (Num a) => a -> a -> a diffsq = (^2) .* (-) modminus :: (Integral a) => a -> a -> a -> a modminus n = (`mod` n) .* (-) diffsqmod :: (Integral a) => a -> a -> a -> a diffsqmod = (^2) .** modminus
\f g -> (f .) . g :: (c -> d) -> (a -> b -> c) -> a -> b -> d
o1 :: (c -> d) -> (b -> c) -> (b -> d) f `o1` g = fmap f g
o2 :: (c -> d) -> (a -> (b -> c)) -> a -> (b -> d) f `o2` g = fmap (fmap f) g
[1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36]
1962938367679548095642112423564462631020433036610484123229980468750
merge xxs@(x:xs) yys@(y:ys) = case (x`compare`y) of LT -> x:merge xs yys EQ -> x:merge xs ys GT -> y:merge xxs ys hamming = 1 : m 2 `merge` m 3 `merge` m 5 where m k = map (k *) hamming main = print (hamming !! 499999)
while :: Monad m -> m Bool -> m a -> m () while m p body = (>>=) m p $ \x -> if x then (>>) m body (while m p body) else return m () average :: Floating a -> a -> a -> a -> a average f a b c = (/) f ((+) (floatingToNum f) a ((+) (floatingToNum f) b c)) (fromInteger (floatingToNum f) 3)
? 1 ++ [2,3,4] ERROR: Type error in application *** expression :: 1 ++ [2,3,4] *** term :: 1 *** type :: Int *** does not match :: [Int]
Prelude> 1 ++ [2,3,4] :2:1: No instance for (Num [a0]) arising from the literal `1' Possible fix: add an instance declaration for (Num [a0]) In the first argument of `(++) In the expression: 1 ++ [2, 3, 4] In an equation for `it :2:7: No instance for (Num a0) arising from the literal `2' The type variable `a0 Possible fix: add a type signature that fixes these type variable(s) Note: there are several potential instances: instance Num Double -- Defined in `GHC.Float' instance Num Float -- Defined in `GHC.Float' instance Integral a => Num (GHC.Real.Ratio a) -- Defined in `GHC.Real' ...plus three others In the expression: 2 In the second argument of `(++) In the expression: 1 ++ [2, 3, 4]
? :t (==) (==) :: Eq a => a -> a -> Bool ? :t (+) (+) :: Num a => a -> a -> a
? :t (==) (==) :: a -> a -> Bool ? :t (+) (+) :: Int -> Int -> Int
data ShuttleInterface = SI { launch :: Delay -> IO Handle , deploy :: Payload -> IO () , getStatus :: IO Status }
deployAllSensors :: ShuttleInterface -> IO () deployAllSensors shuttle = do status <- getStatus shuttle let notDeployed = filter (not . deployed) (sensors status) when (isOrbiting status) (mapM_ deploySensor notDeployed) -- we used the well-known Haskell functions: filter, not, , when, mapM_ -- and some supporting functions were assumed: isOrbitting :: Status -> Bool deploySensor :: Sensor -> IO () sensors :: Status -> [Sensor] deployed :: Sensor -> Bool
> import Control.Lens > data A = A deriving (Show) > (1, 1 > (1, > (1, "3" > (1, A
cabal update cabal install tuple ghci λ> import Data.Tuple.Select λ> sel3 (0, "1", 2) --select the third element
case maybeValue of Just value -> ... Nothing -> ...
sumOfThree :: Maybe Int sumOfThree = do a <- someMaybeNumber b <- someMaybeNumber c <- someMaybeNumber let k = 42 -- Just for fun return (a + b + c + k)
> maybe 0 (+ 42) Nothing 0 > maybe 0 (+ 42) (Just 12) 54
Data.Maybe.fromJust $ lookup "a" [("a",1),("b",2),("c",3)] 1
Data.Maybe.fromJust $ lookup "z" [("a",1),("b",2),("c",3)] *** Exception: Maybe.fromJust: Nothing
tidySecond :: [a] -> Maybe a tidySecond (_:x:_) = Just x tidySecond _ = Nothing
lend amount balance = let reserve = 100 newBalance = balance - amount in if balance < reserve then Nothing else Just newBalance
map :: (a->b) -> [a] -> [b] map f [] = [] map f (x:xs) = f x : map f xs
var list = new int[] { 1, 2, 3, 4, 5 }; int countEven = list.Count(n => n % 2 == 0)
list.Aggregate(0, (total, value) => total += value);
type MyTypeA = (Int, Int, Char, Char) type MyTypeB = ([Int], [Char]) myFunction :: MyTypeA_or_MyTypeB -> Char myFunction constrainedToTypeA = something myFunction constrainedToTypeB = somethingElse
public abstract class ConstrainedType { } public class MyTypeA extends ConstrainedType { ...various members... } public class MyTypeB extends ConstrainedType { ...various members... } ... public Char myFunction(ConstrainedType a) { if (a TypeOf MyTypeA) { return doStuffA(); } else if (a TypeOf MyTypeB) { return doStuffB(); } }
abstract class IntBox { } class Empty : IntBox { } class Full : IntBox { int inside; Full(int inside) { this.inside = inside; } } int Get(IntBox a) { if (a is Empty) { return 0; } if (a is Full) { return ((Full)a).inside; } error("IntBox not of expected type"); }
data IntBox = Empty | Full Int get :: IntBox -> Int get Empty = 0 get (Full x) = x
abstract class Animal { abstract string CatchPhrase(); virtual void Speak() { print(CatchPhrase()); } } class Cat : Animal { override string CatchPhrase() { return "Meow"; } } class Dog : Animal { override string CatchPhrase() { return "Woof"; } override void Speak() { print("Rowwrlrw"); } }
data Animal = Animal { catchPhrase :: String, speak :: IO () } protoAnimal :: Animal protoAnimal = Animal { speak = putStrLn (catchPhrase protoAnimal) } cat :: Animal cat = protoAnimal { catchPhrase = "Meow" } dog :: Animal dog = protoAnimal { catchPhrase = "Woof", speak = putStrLn "Rowwrlrw" }
class Animal a where catchPhrase :: a -> String speak :: a -> IO () speak a = putStrLn (catchPhrase a) data Cat = Cat instance Animal Cat where catchPhrase Cat = "Meow" data Dog = Dog instance Animal Dog where catchPhrase Dog = "Woof" speak Dog = putStrLn "Rowwrlrw"
{- data AnyAnimal = forall a. Animal a => AnyAnimal a instance Animal AnyAnimal where catchPhrase (AnyAnimal a) = catchPhrase a speak (AnyAnimal a) = speak a
{- -- ------------------------------------------------------------------------------- class MVC tState tAction tReaction | tState -> tAction tReaction where changeState :: tState -> tAction -> tState -- get a new state given the current state and an action ("abstract") whatReaction :: tState -> tReaction -- get the reaction given a new state ("abstract") view :: (tState, tReaction) -> IO () -- show a state and reaction pair ("abstract") -- get a new state and a reaction given an state and an action (defined using previous functions) runModel :: tState -> tAction -> (tState, tReaction) runModel s a = let ns = (changeState s a) r = (whatReaction ns) in (ns, r) -- get a new state given the current state and an action, calling run :: tState -> tAction -> IO tState run s a = do let (s view (s return s' -- get a new state given the current state and a function control :: tState -> IO (Maybe tAction) -> IO tState control s getAction = do ma <- getAction case ma of Nothing -> return s Just a -> do ns <- run s a control ns getAction -- ------------------------------------------------------------------------------- -- concrete instance for MVC, where -- tState=Int tAction=Char ( -- Define here the "abstract" functions instance MVC Int Char Char where changeState i c | c == | c == | otherwise = i -- no change in state whatReaction i | i == 0 = | i < 0 = | otherwise = view (s, r) = do putStrLn $ "view: state=" ++ (show s) ++ " reaction=" ++ (show r) ++ "\n" -- -- define here the function "asking the user" getAChar :: IO (Maybe Char) -- return (Just a char) or Nothing when getAChar = do putStrLn "?" str <- getLine putStrLn "" let c = str !! 0 case c of _ -> return (Just c) -- -------------------------------------------------------------------------------------------- -- -------------------------------------------------------------------------------------------- -- call finalState = control 0 getAChar :: IO Int -- main = do s <- finalState print s
Prelude> :browse Data.List (\\) :: (Eq a) => [a] -> [a] -> [a] delete :: (Eq a) => a -> [a] -> [a] deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a] deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a] elemIndex :: (Eq a) => a -> [a] -> Maybe Int ... Prelude> :help ... :browse[!] [[*]<mod>] display the names defined by module <mod> (!: more details; *: all top-level names) ...
Prelude> :m +Data.List Prelude Data.List> Data.List.<PRESS TAB KEY HERE> Display all 109 possibilities? (y or n) <PRESS n> Prelude Data.List> Data.List.un<PRESS TAB KEY HERE> Data.List.unfoldr Data.List.unlines Data.List.unzip3 Data.List.unzip6 Data.List.union Data.List.unwords Data.List.unzip4 Data.List.unzip7 Data.List.unionBy Data.List.unzip Data.List.unzip5
import Text.Printf str :: String str = printf "%d %d" 10 20
import Text.Format format "{0} {1}" [show 10, show 20]
format "Some {0} believes that 1 + 1 = {1}." ["people",show 10]
> "There are "+|n|+" million bicycles in "+|city|+"."
module Foo where data Foo = FooA | FooB deriving (Eq, Ord)
module Bar (myMap) where import Data.Map (Map) import qualified Data.Map as Map import Foo myMap :: Map Foo Int myMap = Map.singleton FooA 42
module Baz where import Data.Map (Map) import qualified Data.Map as Map import Foo hiding (instance Ord Foo) import Bar (myMap) instance Ord Foo where FooA > FooB = True FooB > FooA = False ouch :: Map Foo Int ouch = Map.insert FooB 42 myMap
with (import <nixpkgs> {}).pkgs; (haskellngPackages.callPackage ./. {}).env
with (import <nixpkgs> {}).pkgs; let modifiedHaskellPackages = haskellngPackages.override { overrides = self: super: { engine-io = self.callPackage ../engine-io {}; socket-io = self.callPackage ./. {}; }; }; in modifiedHaskellPackages.socket-io.env
main = do l <- getArgs let n = length l n `seq` return () let thunk = trace "I am evaluated" $ n + n let x = Foo 1 thunk a x `seq` return () performGC s1 <- closureSize x s2 <- closureSize thunk r <- recursiveSize x print (s1, s2, r)
main = do l <- getArgs let n = length l n `seq` return () let thunk = trace "I am evaluated" $ n let x = Foo 1 thunk a x `seq` return () performGC s1 <- closureSize x s2 <- closureSize thunk s3 <- closureSize n r <- recursiveSize x buildHeapTree 1000 (asBox x) >>= putStrLn . ppHeapTree print (s1, s2, s3, r)
library: ghc-options: -optl-fuse-ld=gold ld-options: -fuse-ld=gold executable myExecutable ghc-options: -optl-fuse-ld=gold ld-options: -fuse-ld=gold
library ghc-options: "-pgmP clang" "-pgmc clang" "-pgma clang" "-pgml clang" "-optl-fuse-ld=lld" ld-options: -fuse-ld=lld executable myExecutable ghc-options: "-pgmP clang" "-pgmc clang" "-pgma clang" "-pgml clang" ld-options: -fuse-ld=lld
type Transducer a b = forall r . (b -> r -> r) -> (a -> r -> r)
-- cf. with foldr :: (x -> r -> r) -> r -> [x] -> r ffoldr :: (x -> r -> r) -> [x] -> r -> r ffoldr = flip . foldr
(.) :: Transducer a b -> Transducer b c -> Transducer a c
tfilter :: (a -> Bool) -> (a -> r -> r) -> a -> r -> r -- or: (a -> Bool) -> Transducer a a tfilter predicate f a = if predicate a then f a else id
tmap :: (a -> b) -> (b -> r -> r) -> a -> r -> r tmap ba f a = f (ba a)
tl_map f = \a -> [f a] tl_filter predicate = \a -> if predicate a then [a] else []
> {- > import Control.Monad > import Control.Monad.ST > import Data.STRef
> newtype PTRef s a = Ref {unref :: s a} -- This is defined liked this to make `toST
> data PT s a where > MkRef :: a -> PT s (PTRef s a) > GetRef :: PTRef s a -> PT s a > PutRef :: a -> PTRef s a -> PT s () > AndThen :: PT s a -> (a -> PT s b) -> PT s b
> instance Monad (PT s) where > (>>=) = AndThen > return a = AndThen (MkRef a) GetRef --Sorry. I like minimalism. > instance Functor (PT s) where > fmap = liftM > instance Applicative (PT s) where > pure = return > (<*>) = ap
> fib :: Int -> PT s Integer > fib n = do > rold <- MkRef 0 > rnew <- MkRef 1 > replicateM_ n $ do > old <- GetRef rold > new <- GetRef rnew > PutRef new rold > PutRef (old+new) rnew > GetRef rold
> toST :: PT (STRef s) a -> ST s a > toST (MkRef a ) = fmap Ref $ newSTRef a > toST (GetRef (Ref r)) = readSTRef r > toST (PutRef a (Ref r)) = writeSTRef r a > toST (pa `AndThen` apb) = (toST pa) >>= (toST . apb)
> runPF :: (forall s. PT s a) -> a > runPF p = runST $ toST p
newtype Ix a = MkIx Int -- the index of an element in a list interp :: PT Ix a -> State [b] a interp (MkRef x) = modify (++ [x]) >> gets (Ref . MkIx . length) -- ...
infixr 4 :> data Tuple as where E :: Tuple (:>) :: a -> Tuple as -> Tuple (a
ghci> :t ghci> :t "hello" :> True :> E "hello" :> True :> E :: Tuple
data Elem as a where -- order of indices arranged for convenient partial application Here :: Elem (a There :: Elem as a -> Elem (b
(!) :: Tuple as -> Elem as a -> a (x :> xs) ! Here = x (x :> xs) ! (There ix) = xs ! ix
type family as :++: bs where (a appendT :: a -> Tuple as -> (Tuple (as :++: appendT x E = (x :> E, Here) appendT x (y :> ys) = let (t, ix) = appendT x ys in (y :> t, There ix)
interp :: PT (Elem as) a -> State (Tuple as) a interp (MkRef x) = do t <- get let (newT, el) = appendT x t put newT return el -- ...
{- module PureST (ST, STRef, newSTRef, readSTRef, modifySTRef, runST) where import Data.IntMap (IntMap, (!)) import qualified Data.IntMap as M import Control.Monad import Control.Applicative import Control.Monad.Trans.State import GHC.Prim (Any) import Unsafe.Coerce (unsafeCoerce) type role ST nominal representational type role STRef nominal representational newtype ST s a = ST (State (IntMap Any, Int) a) deriving (Functor, Applicative, Monad) newtype STRef s a = STRef Int deriving Show newSTRef :: a -> ST s (STRef s a) newSTRef a = ST $ do (m, i) <- get put (M.insert i (unsafeCoerce a) m, i + 1) pure (STRef i) readSTRef :: STRef s a -> ST s a readSTRef (STRef i) = ST $ do (m, _) <- get pure (unsafeCoerce (m ! i)) writeSTRef :: STRef s a -> a -> ST s () writeSTRef (STRef i) a = ST $ modify $ \(m, i modifySTRef :: STRef s a -> (a -> a) -> ST s () modifySTRef (STRef i) f = ST $ modify $ \(m, i runST :: (forall s. ST s a) -> a runST (ST s) = evalState s (M.empty, 0) foo :: Num a => ST s (a, Bool) foo = do a <- newSTRef 0 modifySTRef a (+100) b <- newSTRef False modifySTRef b not (,) <$> readSTRef a <*> readSTRef b
class FunctorIx f where imap :: (a -> b) -> f i j a -> f i j b class FunctorIx m => MonadIx m where ireturn :: a -> m i i a (>>>=) :: m i j a -> (a -> m j k b) -> m i k b (>>>) :: MonadIx m => m i j a -> m j k b -> m i k b ma >>> mb = ma >>>= \_ -> mb replicateM_ :: MonadIx m => Int -> m i i a -> m i i () replicateM_ 0 _ = ireturn () replicateM_ n m = m >>> replicateM_ (n - 1) m
data PTF ref as bs r where MkRef_ :: a -> (ref (a GetRef_ :: ref as a -> (a -> r) -> PTF ref as as r PutRef_ :: a -> ref as a -> r -> PTF ref as as r instance FunctorIx (PTF ref) where imap f (MkRef_ x next) = MkRef_ x (f . next) imap f (GetRef_ ref next) = GetRef_ ref (f . next) imap f (PutRef_ x ref next) = PutRef_ x ref (f next)
class Expand ref where expand :: ref as a -> ref (b
data FreeIx f i j a where Pure :: a -> FreeIx f i i a Free :: f i j (FreeIx f j k a) -> FreeIx f i k a lift :: FunctorIx f => f i j a -> FreeIx f i j a lift f = Free (imap Pure f) instance FunctorIx f => MonadIx (FreeIx f) where ireturn = Pure Pure x >>>= f = f x Free love {- , man -} >>>= f = Free $ imap (>>>= f) love instance FunctorIx f => FunctorIx (FreeIx f) where imap f x = x >>>= (ireturn . f)
type PT ref = FreeIx (PTF ref) mkRef :: a -> PT ref as (a mkRef x = lift $ MkRef_ x id getRef :: ref as a -> PT ref as as a getRef ref = lift $ GetRef_ ref id putRef :: a -> ref as a -> PT ref as as () putRef x ref = lift $ PutRef_ x ref () pattern MkRef x next = Free (MkRef_ x next) pattern GetRef ref next = Free (GetRef_ ref next) pattern PutRef x ref next = Free (PutRef_ x ref next)
-- fib adds two Ints to an arbitrary environment fib :: Expand ref => Int -> PT ref as (Int fib n = do rold rnew <- mkRef 1 let rold = expand rold' replicateM_ n $ do old <- getRef rold new <- getRef rnew putRef new rold putRef (old+new) rnew getRef rold where (>>=) = (>>>=) (>>) = (>>>) return :: MonadIx m => a -> m i i a return = ireturn fail :: MonadIx m => String -> m i j a fail = error
infixr 5 :> data Tuple as where E :: Tuple (:>) :: a -> Tuple as -> Tuple (a data Elem as a where Here :: Elem (a There :: Elem as a -> Elem (b (!) :: Tuple as -> Elem as a -> a (x :> xs) ! Here = x (x :> xs) ! There ix = xs ! ix updateT :: Elem as a -> a -> Tuple as -> Tuple as updateT Here x (y :> ys) = x :> ys updateT (There ix) x (y :> ys) = y :> updateT ix x ys
interp :: PT Elem as bs a -> Tuple as -> a interp (MkRef x next) tup = let newTup = x :> tup in interp (next $ Here) newTup interp (GetRef ix next) tup = let x = tup ! ix in interp (next x) tup interp (PutRef x ix next) tup = let newTup = updateT ix x tup in interp next newTup interp (Pure x) tup = x
run :: (forall ref. Expand ref => PT ref run x = interp x E
data T = T0 | T1 | T2 | ... | TN toInt :: T -> Int toInt t = case t of T0 -> 0 T1 -> 1 T2 -> 2 ... TN -> N
if (t.tag == T0) { ... } else if (t.tag == T1) { ... } else ...
{- module FreeA ( FreeA, effect ) where import Prelude hiding ((.), id) import Control.Category import Control.Arrow import Control.Applicative import Data.Monoid data FreeA eff a b where Pure :: (a -> b) -> FreeA eff a b Effect :: eff a b -> FreeA eff a b Seq :: FreeA eff a b -> FreeA eff b c -> FreeA eff a c Par :: FreeA eff a₁ b₁ -> FreeA eff a₂ b₂ -> FreeA eff (a₁, a₂) (b₁, b₂) effect :: eff a b -> FreeA eff a b effect = Effect instance Category (FreeA eff) where id = Pure id (.) = flip Seq instance Arrow (FreeA eff) where arr = Pure first f = Par f id second f = Par id f (***) = Par
{- {- analyze :: forall f eff a₀ b₀ r. (Applicative f, Monoid r) => (forall a b. eff a b -> f r) -> FreeA eff a₀ b₀ -> f r analyze visit = go where go :: forall a b. FreeA eff a b -> f r go arr = case arr of Pure _ -> pure mempty Seq f₁ f₂ -> mappend <$> go f₁ <*> go f₂ Par f₁ f₂ -> mappend <$> go f₁ <*> go f₂ Effect eff -> visit eff evalA :: forall eff arr a₀ b₀. (Arrow arr) => (forall a b. eff a b -> arr a b) -> FreeA eff a₀ b₀ -> arr a₀ b₀ evalA exec = go where go :: forall a b. FreeA eff a b -> arr a b go freeA = case freeA of Pure f -> arr f Seq f₁ f₂ -> go f₂ . go f₁ Par f₁ f₂ -> go f₁ *** go f₂ Effect eff -> exec eff
leftAdjunct :: (FreeA x :~> y) -> x :~> y rightAdjunct :: Arrow y => (x :~> y) -> FreeA x :~> y
analyze visit = getApp . getConstArr . evalA (ConstArr . Ap . visit)
newtype ConstArr m a b = ConstArr { getConstArr :: m }
hfmap :: (x :~> y) -> FreeA x :~> FreeA y hfmap f = evalA (effect . f)
newtype FreeA eff a b = FreeA { runFreeA :: forall arr. Arrow arr => (eff :~> arr) -> arr a b } evalA f a = runFreeA a f effect a = FreeA $ \k -> k a instance Category (FreeA f) where id = FreeA $ const id FreeA f . FreeA g = FreeA $ \k -> f k . g k instance Arrow (FreeA f) where arr f = FreeA $ const (arr f) first (FreeA f) = FreeA $ \k -> first (f k) second (FreeA f) = FreeA $ \k -> second (f k) FreeA f *** FreeA g = FreeA $ \k -> f k *** g k FreeA f &&& FreeA g = FreeA $ \k -> f k &&& g k
main = do a <- readLn if (a>=0) then return () else do print "a is negative" ...
main = do { a <- readLn; if (a>=0) then return () else do {}; print "a is negative" ... }
exp → infixexp :: [context =>] type | infixexp infixexp → lexp qop infixexp | - infixexp | lexp lexp → \ apat1 … apatn -> exp | let decls in exp | if exp [;] then exp [;] else exp | case exp of { alts } | do { stmts } | fexp fexp → [fexp] aexp aexp → ( exp ) | …
{- import Data.Aeson data Coord = Coord { x :: Double, y :: Double } instance ToJSON Coord where toJSON (Coord x y) = object ["x" .= x, "y" .= y]
{- import Data.Aeson import GHC.Generics data Coord = Coord { x :: Double, y :: Double } deriving Generic instance ToJSON Coord
{- import Data.Data import Data.Aeson.Generic data Coord = Coord { x :: Double, y :: Double } deriving (Data, Typeable)
user error (SQLite3 returned ErrorBusy while attempting to perform step.)
{- , TypeFamilies, FlexibleContexts, GADTs , OverloadedStrings import Control.Concurrent (forkIO, threadDelay) import Database.Persist import Database.Persist.Sqlite hiding (get) import Database.Persist.TH import Control.Monad import Control.Monad.IO.Class share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist| SomeData myId Int myData Double MyId myId |] main = withSqlitePool "TEST" 40 $ \pool -> do runSqlPool (runMigration migrateAll) pool mapM_ forkIO [runSqlPool (dbThread i) pool | i <- [0..5]] threadDelay maxBound dbThread :: Int -> SqlPersist IO () dbThread i = forever $ do x <- getBy (MyId i) insert (SomeData i (fromIntegral i)) liftIO (print x) liftIO (threadDelay 100000) -- Just to calm down the CPU, -- not needed for demonstrating -- the problem
$ ./so Nothing so: user error (SQLite3 returned ErrorBusy while attempting to perform step.) so: user error (SQLite3 returned ErrorBusy while attempting to perform step.) so: user error (SQLite3 returned ErrorBusy while attempting to perform step.) so: user error (SQLite3 returned ErrorBusy while attempting to perform step.) so: user error (SQLite3 returned ErrorBusy while attempting to perform step.) so: user error (SQLite3 returned ErrorConstraint while attempting to perform step.)
module StackOverflow where -- yes, the source of this post compiles as is
dunnoNow :: [String] -> [String] dunnoNow [] = [] dunnoNow (line:lines) | all (== | otherwise = let (first4,therest) = splitAt 4 line in if first4 /=" " -- || null therest -- so the next line won || head therest `elem` "*:" -- special chars that don then line:knowNow False lines -- this isn else (
knowNow :: Bool -> [String] -> [String] knowNow _ [] = [] knowNow itsCode (line:lines) | all (== | otherwise = (if itsCode then
loadso :: String -> IO String loadso fn = fmap (unlines.dunnoNow.lines) (readFile $ fn++".so") -- so2bird each line >>= writeFile (fn++"_so.lhs") -- write to a new file >> return (":def! rso (\\_ -> return \":so "++ fn ++"\")\n:load "++fn++"_so.lhs")
:{ let dunnoNow [] = [] dunnoNow (line:lines) | all (== | otherwise = let (first4,therest) = splitAt 4 line in if first4 /=" " -- || null therest -- so the next line won || head therest `elem` "*:" -- special chars that don then line:knowNow False lines -- this isn else ( knowNow _ [] = [] knowNow itsCode (line:lines) | all (== | otherwise = (if itsCode then loadso fn = fmap (unlines.dunnoNow.lines) (readFile $ fn++".so") -- convert each line >>= writeFile (fn++"_so.lhs") -- write to a new file >> return (":def! rso (\\_ -> return \":so "++ fn ++"\")\n:load "++fn++"_so.lhs") :} :def so loadso
*Prelude> :so StackOverflow [1 of 1] Compiling StackOverflow ( StackOverflow_so.lhs, interpreted ) Ok, modules loaded: StackOverflow. *StackOverflow> :rso [1 of 1] Compiling StackOverflow ( StackOverflow_so.lhs, interpreted ) Ok, modules loaded: StackOverflow. *StackOverflow>
{- module Main where import Data.Array.Accelerate as A import Data.Array.Accelerate.CUDA as C import Data.Time.Clock (diffUTCTime, getCurrentTime) main :: IO () main = do start <- getCurrentTime print $ C.run $ A.maximum $ A.map (+1) $ A.use (fromList (Z:.1000000) [1..1000000] :: Vector Double) end <- getCurrentTime print $ diffUTCTime end start
$ ghc -O2 Main.hs -o main -threaded [1 of 1] Compiling Main ( Main.hs, Main.o ) Linking main ... $ ./main Array (Z) [1000001.0] 0.092906s
$ ghc -O2 Main.hs -c -dynamic $ ghci Main ghci> main Array (Z) [1000001.0] 0.258224s
$ ghc -O2 -dynamic -c -threaded Main.hs && ghci GHCi, version 7.8.3: http: … Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Ok, modules loaded: Main. Prelude Main> Loading package transformers-0.3.0.0 ... linking ... done. … Loading package array-0.5.0.0 ... linking ... done. (...) Loading package accelerate-cuda-0.15.0.0 ... linking ... done. >>>>> run >>>>> runAsyncIn.execute >>>>> runAsyncIn.seq ctx <<<<< runAsyncIn.seq ctx: 4.1609e-2 CPU 0.041493s TOTAL >>>>> runAsyncIn.seq a <<<<< runAsyncIn.seq a: 1.0e-6 CPU 0.000001s TOTAL >>>>> runAsyncIn.seq acc >>>>> convertAccWith True <<<<< convertAccWith: 0.0 CPU 0.000017s TOTAL <<<<< runAsyncIn.seq acc: 2.68e-4 CPU 0.000219s TOTAL >>>>> evalCUDA >>>>> push <<<<< push: 0.0 CPU 0.000002s TOTAL >>>>> evalStateT >>>>> runAsyncIn.compileAcc >>>>> compileOpenAcc >>>>> compileOpenAcc.traveuseAcc.Alet >>>>> compileOpenAcc.traveuseAcc.Use >>>>> compileOpenAcc.traveuseAcc.use3 >>>>> compileOpenAcc.traveuseAcc.use1 <<<<< compileOpenAcc.traveuseAcc.use1: 0.0 CPU 0.000001s TOTAL >>>>> compileOpenAcc.traveuseAcc.use2 >>>>> compileOpenAcc.traveuseAcc.seq arr <<<<< compileOpenAcc.traveuseAcc.seq arr: 0.105716 CPU 0.105501s TOTAL >>>>> useArrayAsync <<<<< useArrayAsync: 1.234e-3 CPU 0.001505s TOTAL <<<<< compileOpenAcc.traveuseAcc.use2: 0.108012 CPU 0.108015s TOTAL <<<<< compileOpenAcc.traveuseAcc.use3: 0.108539 CPU 0.108663s TOTAL <<<<< compileOpenAcc.traveuseAcc.Use: 0.109375 CPU 0.109005s TOTAL >>>>> compileOpenAcc.traveuseAcc.Fold1 >>>>> compileOpenAcc.traveuseAcc.Avar <<<<< compileOpenAcc.traveuseAcc.Avar: 0.0 CPU 0.000001s TOTAL >>>>> compileOpenAcc.traveuseAcc.Avar <<<<< compileOpenAcc.traveuseAcc.Avar: 0.0 CPU 0s TOTAL >>>>> compileOpenAcc.traveuseAcc.Avar <<<<< compileOpenAcc.traveuseAcc.Avar: 0.0 CPU 0.000001s TOTAL >>>>> compileOpenAcc.traveuseAcc.Avar <<<<< compileOpenAcc.traveuseAcc.Avar: 0.0 CPU 0s TOTAL <<<<< compileOpenAcc.traveuseAcc.Fold1: 2.059e-3 CPU 0.002384s TOTAL <<<<< compileOpenAcc.traveuseAcc.Alet: 0.111434 CPU 0.112034s TOTAL <<<<< compileOpenAcc: 0.11197 CPU 0.112615s TOTAL <<<<< runAsyncIn.compileAcc: 0.11197 CPU 0.112833s TOTAL >>>>> runAsyncIn.dumpStats <<<<< runAsyncIn.dumpStats: 2.0e-6 CPU 0.000001s TOTAL >>>>> runAsyncIn.executeAcc >>>>> executeAcc <<<<< executeAcc: 8.96e-4 CPU 0.00049s TOTAL <<<<< runAsyncIn.executeAcc: 9.36e-4 CPU 0.0007s TOTAL >>>>> runAsyncIn.collect <<<<< runAsyncIn.collect: 0.0 CPU 0.000027s TOTAL <<<<< evalStateT: 0.114156 CPU 0.115327s TOTAL >>>>> pop <<<<< pop: 0.0 CPU 0.000002s TOTAL >>>>> performGC <<<<< performGC: 5.7246e-2 CPU 0.057814s TOTAL <<<<< evalCUDA: 0.17295 CPU 0.173943s TOTAL <<<<< runAsyncIn.execute: 0.215475 CPU 0.216563s TOTAL <<<<< run: 0.215523 CPU 0.216771s TOTAL Array (Z) [1000001.0] 0.217148s Prelude Main> Leaving GHCi.
$ ghc -O2 -threaded Main.hs && ./Main [1 of 1] Compiling Main ( Main.hs, Main.o ) Linking Main ... >>>>> run >>>>> runAsyncIn.execute >>>>> runAsyncIn.seq ctx <<<<< runAsyncIn.seq ctx: 4.0639e-2 CPU 0.041498s TOTAL >>>>> runAsyncIn.seq a <<<<< runAsyncIn.seq a: 1.0e-6 CPU 0.000001s TOTAL >>>>> runAsyncIn.seq acc >>>>> convertAccWith True <<<<< convertAccWith: 1.2e-5 CPU 0.000005s TOTAL <<<<< runAsyncIn.seq acc: 1.15e-4 CPU 0.000061s TOTAL >>>>> evalCUDA >>>>> push <<<<< push: 2.0e-6 CPU 0.000002s TOTAL >>>>> evalStateT >>>>> runAsyncIn.compileAcc >>>>> compileOpenAcc >>>>> compileOpenAcc.traveuseAcc.Alet >>>>> compileOpenAcc.traveuseAcc.Use >>>>> compileOpenAcc.traveuseAcc.use3 >>>>> compileOpenAcc.traveuseAcc.use1 <<<<< compileOpenAcc.traveuseAcc.use1: 0.0 CPU 0.000001s TOTAL >>>>> compileOpenAcc.traveuseAcc.use2 >>>>> compileOpenAcc.traveuseAcc.seq arr <<<<< compileOpenAcc.traveuseAcc.seq arr: 3.6651e-2 CPU 0.03712s TOTAL >>>>> useArrayAsync <<<<< useArrayAsync: 1.427e-3 CPU 0.001427s TOTAL <<<<< compileOpenAcc.traveuseAcc.use2: 3.8776e-2 CPU 0.039152s TOTAL <<<<< compileOpenAcc.traveuseAcc.use3: 3.8794e-2 CPU 0.039207s TOTAL <<<<< compileOpenAcc.traveuseAcc.Use: 3.8808e-2 CPU 0.03923s TOTAL >>>>> compileOpenAcc.traveuseAcc.Fold1 >>>>> compileOpenAcc.traveuseAcc.Avar <<<<< compileOpenAcc.traveuseAcc.Avar: 2.0e-6 CPU 0.000001s TOTAL >>>>> compileOpenAcc.traveuseAcc.Avar <<<<< compileOpenAcc.traveuseAcc.Avar: 2.0e-6 CPU 0.000001s TOTAL >>>>> compileOpenAcc.traveuseAcc.Avar <<<<< compileOpenAcc.traveuseAcc.Avar: 0.0 CPU 0.000001s TOTAL >>>>> compileOpenAcc.traveuseAcc.Avar <<<<< compileOpenAcc.traveuseAcc.Avar: 0.0 CPU 0.000001s TOTAL <<<<< compileOpenAcc.traveuseAcc.Fold1: 1.342e-3 CPU 0.001284s TOTAL <<<<< compileOpenAcc.traveuseAcc.Alet: 4.0197e-2 CPU 0.040578s TOTAL <<<<< compileOpenAcc: 4.0248e-2 CPU 0.040895s TOTAL <<<<< runAsyncIn.compileAcc: 4.0834e-2 CPU 0.04103s TOTAL >>>>> runAsyncIn.dumpStats <<<<< runAsyncIn.dumpStats: 0.0 CPU 0s TOTAL >>>>> runAsyncIn.executeAcc >>>>> executeAcc <<<<< executeAcc: 2.87e-4 CPU 0.000403s TOTAL <<<<< runAsyncIn.executeAcc: 2.87e-4 CPU 0.000488s TOTAL >>>>> runAsyncIn.collect <<<<< runAsyncIn.collect: 9.2e-5 CPU 0.000049s TOTAL <<<<< evalStateT: 4.1213e-2 CPU 0.041739s TOTAL >>>>> pop <<<<< pop: 0.0 CPU 0.000002s TOTAL >>>>> performGC <<<<< performGC: 9.41e-4 CPU 0.000861s TOTAL <<<<< evalCUDA: 4.3308e-2 CPU 0.042893s TOTAL <<<<< runAsyncIn.execute: 8.5154e-2 CPU 0.084815s TOTAL <<<<< run: 8.5372e-2 CPU 0.085035s TOTAL Array (Z) [1000001.0] 0.085169s
import Data.Array.Accelerate.Array.Sugar import Data.Time.Clock (diffUTCTime, getCurrentTime) import System.Mem (performGC) main :: IO () main = do measure $ seq (fromList (Z:.1000000) [1..1000000] :: Vector Double) $ return () measure $ performGC measure action = do start <- getCurrentTime action end <- getCurrentTime print $ diffUTCTime end start
data Color = Red | Yellow | Green deriving Enum allColors = [Red ..]
data Color = Red | Yellow | Green deriving (Enum, Bounded) allColors = [(minBound :: Color) ..]
allValues :: (Bounded a, Enum a) => [a] allValues = [minBound..]
data FavoriteColor = Maroon | Black | Green | Red | Blue | Pink | Yellow | Orange deriving (Show, Read, Enum, Bounded)
parseColor :: Parser FavoriteColor parseColor = fmap read . foldr1 (<|>) $ map (try . string . show) [ minBound :: FavoriteColor ..]
applyNTimes :: Int -> (a -> a) -> a -> a applyNTimes n f x | n == 0 = x | otherwise = f (applyNTimes (n-1) f x)
*Main> let n f = (\a -> \b -> not $ f a b) n :: (t -> t1 -> Bool) -> t -> t1 -> Bool Main> :t n f n f :: (Ord t) => t -> t -> Bool *Main> let g = n f g :: () -> () -> Bool
t -> Bool t -> t1 -> Bool t -> t1 -> t2 -> Bool t -> t1 -> t2 -> t3 -> Bool
argument = flip (.) -- contravariant first f (a,b) = (f a, b) second f (a,b) = (a, f b) left f (Left x) = Left (f x) left f (Right x) = Right x ...
module Pred where class Predicate a where complement :: a -> a instance Predicate Bool where complement = not instance (Predicate b) => Predicate (a -> b) where complement f = \a -> complement (f a) -- if you want to be mysterious, then -- complement = (complement .) -- also works ge :: Ord a => a -> a -> Bool ge = complement (<)
lift2 = (.).(.) lift3 = (.).(.).(.) lift4 = (.).(.).(.).(.) lift5 = (.).(.).(.).(.).(.)
Prelude> :ty (n f) (n f) :: (Ord t) => t -> t -> Bool Prelude> let g = n f Prelude> :ty g g :: () -> () -> Bool
module X where n f = (\a -> \b -> not $ f a b) f a b = a > b g :: Ord a => a -> a -> Bool g = n f
-- | 4) Counts the number of characters in a file numCharactersInFile :: FilePath -> IO Int numCharactersInFile fileName = do contents <- readFile fileName return (length contents)
import Test.QuickCheck import Test.QuickCheck.Monadic(monadicIO,run,assert) import System.Directory(removeFile,getTemporaryDirectory) import System.IO import Control.Exception(finally,bracket) numCharactersInFile :: FilePath -> IO Int numCharactersInFile fileName = do contents <- readFile fileName return (length contents)
numAlternative :: FilePath -> IO Integer numAlternative p = bracket (openFile p ReadMode) hClose hFileSize
data TestFile = TestFile String deriving (Eq,Ord,Show) instance Arbitrary TestFile where arbitrary = do n <- choose (0,2000) testString <- vectorOf n $ elements [ return $ TestFile testString
prop_charsInFile (TestFile string) = length string > 0 ==> monadicIO $ do (res,alternative) <- run $ createTmpFile string $ \p h -> do alternative <- numAlternative p testRes <- numCharactersInFile p return (testRes,alternative) assert $ res == fromInteger alternative
createTmpFile :: String -> (FilePath -> Handle -> IO a) -> IO a createTmpFile content func = do tempdir <- catch getTemporaryDirectory (\_ -> return ".") (tempfile, temph) <- openTempFile tempdir "" hPutStr temph content hFlush temph hClose temph finally (func tempfile temph) (removeFile tempfile)
$ quickCheck prop_charsInFile +++ OK, passed 100 tests.
class Monad m => FSMonad m where readFile :: FilePath -> m String -- | 4) Counts the number of characters in a file numCharactersInFile :: FSMonad m => FilePath -> m Int numCharactersInFile fileName = do contents <- readFile fileName return (length contents)
instance FSMonad IO where readFile = Prelude.readFile
data MockFS = SingleFile FilePath String instance FSMonad (State MockFS) where -- ^ Reader would be enough in this particular case though readFile pathRequested = do (SingleFile pathExisting contents) <- get if pathExisting == pathRequested then return contents else fail "file not found" testNumCharactersInFile :: Bool testNumCharactersInFile = evalState (numCharactersInFile "test.txt") (SingleFile "test.txt" "hello world") == 11
numCharactersInFile :: (FilePath -> IO String) -> FilePath -> IO Int numCharactersInFile reader fileName = do contents <- reader fileName return (length contents)
fakeFile :: FilePath -> IO String fakeFile fileName = return "Fake content"
numCharactersInFile numCharactersInFile contents <- f filePath return (length contents)
mockFileSystem :: FilePath -> Identity String mockFileSystem "fileName" = return "mock file contents"
numCharactersInFile :: IO Int numCharactersInFile = NumCharactersInFile
ptri = [1] : mkptri ptri mkptri (row:rows) = newRow : mkptri rows where newRow = zipWith (+) row (0:row) ++ [1]
import Data.Sequence ((|>), (<|), zipWith, singleton) import Prelude hiding (zipWith) ptri = singleton 1 : mkptri ptri mkptri (seq:seqs) = newRow : mkptri seqs where newRow = zipWith (+) seq (0 <| seq) |> 1
ptri = []:mkptri ptri mkptri (xs:ys) = pZip xs (0:xs) : mkptri ys where pZip (x:xs) (y:ys) = x+y : pZip xs ys pZip [] _ = [1]
ptri = zipWith take [0,1..] ptri' where ptri stepRow row = 1 : zipWith (+) row (tail row)
import Data.List ptri = [1] : mkptri ptri mkptri :: [[Int]] -> [[Int]] mkptri (xs:ys) = mkptri mkptri mkptri mkptri mkptri mkptri
mapOnto :: [b] -> (a -> b) -> [a] -> [b] mapOnto bs f = foldr ((:).f) bs
zipOntoWith :: [c] -> (a -> b -> c) -> [a] -> [b] -> [c] zipOntoWith cs f = foldr step (const cs) where step x g [] = cs step x g (y:ys) = f x y : g ys
zipWith = zipOntoWith [] zip = zipWith (\a b -> (a,b))
ptri :: (Num a) => [[a]] ptri = [] : map mkptri ptri where mkptri xs = zipOntoWith [1] (+) xs (0:xs)
ptri = []:mkptri ptri mkptri (xs:ys) = (newRow xs []) : mkptri ys newRow :: [Int] -> [Int] -> [Int] newRow xs = listS (zipWith (+) xs (0:xs)) . (1:) listS :: [a] -> [a] -> [a] listS [] = id listS (x:xs) = (x:) . listS xs
newRow :: [Int] -> [Int] -> [Int] newRow xs = zipWithS (+) xs (0:xs) . (1:) zipWithS :: (a -> b -> c) -> [a] -> [b] -> [c] -> [c] zipWithS z (a:as) (b:bs) xs = z a b : zipWithS z as bs xs zipWithS _ _ _ xs = xs
list1, list2 :: [Integer] -> [Integer] list1 = \xs -> 1 : 2 : 3 : xs list2 = \xs -> 4 : 5 : 6 : xs
list1 . list2 $ [] -> [1,2,3,4,5,6] list2 . list1 $ [] -> [4,5,6,1,2,3] (7:) . list1 . (8:) . list2 $ [9] -> [7,1,2,3,8,4,5,6,9]
ptri = [] : mkptri ptri mkptri (xs:yss) = newRow : mkptri yss where newRow = zipWith
ptri = ([] : ) . map ($ []) . iterate (\x -> zipWith
instance Functor (Either a) where fmap f (Right x) = Right (f x) fmap f (Left x) = Left x
instance Functor (Either a) where fmap f (Right x) = Right (x) fmap f (Left x) = Left (f x)
class Functor f where fmap :: (a -> b) -> f a -> f b
instance Functor (Either c) where fmap f (Right rval) = Right (f rval) fmap f (Left lval) = Left lval
class Functor f where fmap :: (a -> b) -> f a -> f b instance Functor (Either c) where ...
leftMap :: (c -> d) -> Either c a -> Either d a leftMap mapfunc (Left x) = Left (mapfunc x) leftMap mapfunc (Right x) = Right x instance Functor (Either c) where --fmap :: (c -> d) -> Either c a -> Either d a fmap = leftMap
class BiFunctor f where lMap :: (a -> b) -> f a c -> f b c rMap :: (c -> d) -> f a c -> f a d biMap :: (a -> b) -> (c -> d) -> f a c -> f b d
instance BiFunctor Either where lMap = leftMap rMap = rightMap --the same as the standard fmap definition biMap fl fr e = rMap fr (lMap fl e)
class Functor f where fmap :: (a -> b) -> f a -> f b
instance Functor (Either c) where fmap func (Right x) = Right (x) fmap func (Left x) = Left (func x)
instance Functor (Either a) where fmap f (Right x) = Right (x) fmap f (Left x) = Left (f x)
foo f (Right x) = Right (x) foo f (Left x) = Left (f x)
*Main> :t foo foo :: (t1 -> a) -> Either t1 t -> Either a t
*Main> :t fmap fmap :: (Functor f) => (a -> b) -> f a -> f b
data Choice a = Default Integer | Chosen a -- This corresponds to your top, working, instance. instance Functor Choice where fmap f (Default i) = Default i fmap f (Chosen a) = Chosen (f a)
-- Broken! instance Functor Choice where fmap f (Default i) = Default (f i) fmap f (Chosen a) = Chosen a
instance Functor (Either c) where fmap f (Left c) = Left c fmap f (Right a) = Right (f a)
instance Functor (Either c) where fmap :: forall a b. (a -> b) -> (Either c) a -> (Either c) b fmap f (Left (c :: c)) = Left c fmap f (Right (a :: a)) = Right (f a :: b)
instance Functor (Either c) where fmap :: forall a b. (a -> b) -> (Either c) a -> (Either c) b fmap f (Left (c :: c)) = Left (f c) fmap f (Right (a :: a)) = Right a
class Functor f where fmap :: (p -> q) -> f p -> f q
data Tree a = ... instance Functor Tree where fmap func_a2b tree_of_a = ... -- tree of b.
instance Functor (Either a) where fmap f (Right x) = Right (f x) fmap f (Left x) = Left x
fmap :: (a -> b) -> (Either Integer a -> Either Integer b)
fmap f (Right x) = Right (x) fmap f (Left x) = Left (f x)
fmap :: (a -> b) -> Either c d -> Either c d fmap :: (a -> b) -> Either a d -> Either b d
data Either instance Functor (Either fmap f (Right fmap f (Left
fmap2 :: (a -> b) -> (a `Either` c) -> (b `Either` c)
fmap2 :: (a -> b) -> (`Either` c) a -> (`Either` c) b
data Person = Person { first_name :: String, last_name :: String, age :: Int } deriving (Eq, Ord, Show)
print_age Person { age = a } = {- the a variable contains the person
{- print_age Person { age } = {- the age variable contains the person
{- print_age Person { .. } = {- first_name, last_name, and age are all defined -}
choose n k = factorial n `div` (factorial k * factorial (n-k))
choose n 0 = 1 choose 0 k = 0 choose n k = choose (n-1) (k-1) * n `div` k
factorial n = product [n, n-1 .. 1] nCr n r = n where -- unroll just what you need and nothing more n r
myAny :: (a -> Bool) -> [a] -> Bool myAny p list = foldr step False list where step item acc = p item || acc
myAny even [1..] foldr step False [1..] step 1 (foldr step False [2..]) even 1 || (foldr step False [2..]) False || (foldr step False [2..]) foldr step False [2..] step 2 (foldr step False [3..]) even 2 || (foldr step False [3..]) True || (foldr step false [3..]) True
foldr f z [] = z foldr f z (x:xs) = f x (foldr f z xs)
(a, b) ↦ (a, a) (a, b) ↦ (b, b) (a, b) ↦ (a, b) (a, b) ↦ (b, a)
data File open :: String -> File close :: File -> () -- consumes a file, but we t1 :: File -> File t2 :: File -> File
close . t1 . t2 . open close . t2 . t1 . open close . t1 . open close . t2 . open
let f1 = open "foo" f2 = t1 f1 f3 = t2 f1 in close f3
class Comonoid m where destroy :: m -> () split :: m -> (m, m)
instance Comonoid a where destroy a = () split a = (a, a)
import Control.Applicative main = print $ fmap (*2) (1,2)
class Functor f where fmap :: (a -> b) -> f a -> f b
instance Functor ((,) x) where -- fmap :: (a -> b) -> (x,a) -> (x,b)
class Bifunctor f where bimap :: (a -> b) -> (c -> d) -> f a c -> f b d bimap f g = first f . second g first :: (a -> b) -> f a y -> f b y first f = bimap f id second :: (c -> d) -> f x c -> f x d second g = bimap id g
newtype Join p a = Join { runJoin :: p a a } instance Bifunctor p => Functor (Join p) where fmap f = Join . bimap f f . runJoin
instance Functor T2 where fmap f (T2 x y) = T2 (f x) (f y)
case <- computation of Pat_1 -> computation_1 ... Pat_n -> computation_n
let bs = map expensiveFunction as cs = bs `using` parList rdeepseq
import Control.Parallel.Strategies func as = let bs = map (+1) as cs = bs `using` parList rdeepseq in cs
-- pseudocode readNStrings :: (n :: Int) -> IO (Vect n String) readNStrings O = return Vect.empty readNStrings (S p) = do s <- getLine vp <- readNStrings p return (Vect.cons s vp)
fst :: forall a b. (a, b) -> a fst (x, y) = x test1 = fst @ Int @ Float (2, 3.5) test2 = fst @ String @ Bool ("hi!", True) ...
unsafePerformIO (do n <- getLine; return (IO (Vect (read n :: Int) Nat)))
type MyAPI = "date" :> Get :<|> "time" :> Capture "tz" Timezone :> Get
module TinyServant where import Control.Applicative import GHC.TypeLits import Text.Read import Data.Time
data Get (a :: *) data a :<|> b = a :<|> b infixr 8 :<|> data (a :: k) :> (b :: *) infixr 9 :> data Capture (a :: *)
type MyAPI = "date" :> Get Day :<|> "time" :> Capture TimeZone :> Get ZonedTime
serve :: HasServer layout => Proxy layout -> Server layout -> [String] -> IO String
type instance Server (a :<|> b) = (Server a, Server b) -- preliminary
type instance Server (a :<|> b) = Server a :<|> Server b
type instance Server ((s :: Symbol) :> r) = Server r
type instance Server (Capture a :> r) = a -> Server r
Server MyAPI ~ Server ("date" :> Get Day :<|> "time" :> Capture TimeZone :> Get ZonedTime) ~ Server ("date" :> Get Day) :<|> Server ("time" :> Capture TimeZone :> Get ZonedTime) ~ Server (Get Day) :<|> Server ("time" :> Capture TimeZone :> Get ZonedTime) ~ IO Day :<|> Server ("time" :> Capture TimeZone :> Get ZonedTime) ~ IO Day :<|> Server (Capture TimeZone :> Get ZonedTime) ~ IO Day :<|> TimeZone -> Server (Get ZonedTime) ~ IO Day :<|> TimeZone -> IO ZonedTime
handleDate :: IO Day handleDate = utctDay <$> getCurrentTime handleTime :: TimeZone -> IO ZonedTime handleTime tz = utcToZonedTime tz <$> getCurrentTime handleMyAPI :: Server MyAPI handleMyAPI = handleDate :<|> handleTime
class HasServer layout where route :: Proxy layout -> Server layout -> [String] -> Maybe (IO String)
serve :: HasServer layout => Proxy layout -> Server layout -> [String] -> IO String serve p h xs = case route p h xs of Nothing -> ioError (userError "404") Just m -> m
instance Show a => HasServer (Get a) where route :: Proxy (Get a) -> IO a -> [String] -> Maybe (IO String) route _ handler [] = Just (show <$> handler) route _ _ _ = Nothing
instance (HasServer a, HasServer b) => HasServer (a :<|> b) where route :: Proxy (a :<|> b) -> (Server a :<|> Server b) -> [String] -> Maybe (IO String) route _ (handlera :<|> handlerb) xs = route (Proxy :: Proxy a) handlera xs <|> route (Proxy :: Proxy b) handlerb xs
instance (KnownSymbol s, HasServer r) => HasServer ((s :: Symbol) :> r) where route :: Proxy (s :> r) -> Server r -> [String] -> Maybe (IO String) route _ handler (x : xs) | symbolVal (Proxy :: Proxy s) == x = route (Proxy :: Proxy r) handler xs route _ _ _ = Nothing
instance (Read a, HasServer r) => HasServer (Capture a :> r) where route :: Proxy (Capture a :> r) -> (a -> Server r) -> [String] -> Maybe (IO String) route _ handler (x : xs) = do a <- readMaybe x route (Proxy :: Proxy r) (handler a) xs route _ _ _ = Nothing
GHCi> serve (Proxy :: Proxy MyAPI) handleMyAPI ["time", "CET"] "2015-11-01 20:25:04.594003 CET" GHCi> serve (Proxy :: Proxy MyAPI) handleMyAPI ["time", "12"] *** Exception: user error (404) GHCi> serve (Proxy :: Proxy MyAPI) handleMyAPI ["date"] "2015-11-01" GHCi> serve (Proxy :: Proxy MyAPI) handleMyAPI [] *** Exception: user error (404)
module Euler1D ( stepEuler , makeu0 ) where -- impose zero flux condition zeroflux :: (Floating a) => a -> [a] -> [a] zeroflux mu (boundary:inner:xs) = [boundary+mu*2*(inner-boundary)] -- one step of integration stepEuler :: (Floating a) => a -> [a] -> [a] stepEuler mu u@(x:xs) = (applyBC . (diffused mu)) u where diffused mu (left:x:[]) = [] -- ignore outer points diffused mu (left:x:right:xs) = -- integrate inner points (x+mu*(left+right-2*x)) : diffused mu (x:right:xs) applyBC inner = (lbc u where u lbc = zeroflux mu -- left boundary rbc = (zeroflux mu) . reverse -- right boundary -- initial condition makeu0 :: Int -> [Double] makeu0 n = [ ((^2) . sin . (pi*) . xi) x | x <- [0..n]] where xi x = fromIntegral x / fromIntegral n
module Main where import System ( getArgs ) import Euler1D main = do args <- getArgs let n = read $ head args :: Int let u0 = makeu0 n let un = stepEuler 0.5 u0 putStrLn $ show $ sum un
$ time ./eulerhs 200000 100000.00000000112 real 0m3.552s user 0m3.304s sys 0m0.128s
$ time ./eulerc 200000 100000 real 0m0.088s user 0m0.048s sys 0m0.008s
total time = 0.36 secs (18 ticks @ 20 ms) total alloc = 116,835,180 bytes (excludes profiling overheads) COST CENTRE MODULE %time %alloc makeu0 Euler1D 61.1 34.9 stepEuler Euler1D 33.3 59.6 CAF:sum Main 5.6 5.5
module Euler1D ( stepEuler ) where -- impose zero flux condition zeroflux mu (boundary:inner:xs) = boundary+mu*2*(inner-boundary) -- one step of integration stepEuler mu n = (applyBC . (diffused mu)) $ makeu0 n where diffused mu (left:x:[]) = [] -- ignore outer points diffused mu (left:x:right:xs) = -- integrate inner points let y = (x+mu*(left+right-2*x)) in y `seq` y : diffused mu (x:right:xs) applyBC inner = lbc + sum inner + rbc -- boundary conditions where lbc = zeroflux mu ((f 0 n):inner) -- left boundary rbc = zeroflux mu ((f n n):(take 2 $ reverse inner)) -- right boundary -- initial condition makeu0 n = [ f x n | x <- [0..n]] f x n = ((^2) . sin . (pi*) . xi) x where xi x = fromIntegral x / fromIntegral n
-- |Convenient import module module Foo.Import (module All) where -- Import what you want to export import Foo.Stuff as All hiding (local_func) -- You can import several modules into the same namespace for this trick! -- For example if using your module also requires import Data.Aeson as All (decode)
module M (module M hiding (quux)) where foo = quux quux = 1+2
Packages GHC can use | Are registered with "ghc-pkg register" | And (almost always) built with Cabal | With build dependencies resolved by cabal-install | From Hackage.
module Example where add :: Int -> Int -> Int add x y = x + y
-- Terms e ::= x | \x:T.e | e e -- Types T ::= A | T -> T -- Contexts C ::= . | C,x:T
type TmVar = String type TyVar = String data Tm = Lam TmVar Ty Tm | TmVar TmVar | Tm :@: Tm deriving Show data Ty = TyVar TyVar | Ty :->: Ty deriving (Eq , Show) type Ctx = [(TmVar,Ty)]
(x:T) in C ---------- Axiom C |- x : T C,x:T1 |- e : T2 --------------------- -> Introduction C |- \x:T1.e : T1->T2 C |- e : T1 -> T2 C |- e1 : T1 --------------------------------- -> Elimination C |- e e1 : T2
-- The mode is data R = R { _ctx :: Ctx , _mode :: Bool } type M a = Reader R a extendCtx :: TmVar -> Ty -> M a -> M a extendCtx x t = local extend where extend r = r { _ctx = _ctx r ++ [(x,t)] } -- These take the place of the inferred type when there is a type -- error. here , there :: String here = "\\,!" there = "\\,\\uparrow" -- Return the inferred type---or error string if type inference -- fails---and the latex proof-tree presentation of the inference. -- -- This produces different output than -- all premises are always computed, whereas -- first failing premise. inferProof :: Tm -> M (Either String Ty , String) inferProof tm@(Lam x t e) = do (et let et addProof et inferProof tm@(TmVar x) = do mt <- lookup x <$> asks _ctx let et = maybe (Left here) Right mt addProof et [] tm inferProof tm@(e :@: e1) = do (et , p) <- inferProof e (et1 , p1) <- inferProof e1 case (et , et1) of (Right t , Right t1) -> case t of t1 _ -> addProof (Left here) [p , p1] tm _ -> addProof (Left there) [p , p1] tm
-- Given the inferred type, the proof-trees for all premise inferences -- (subcalls), and the input term, annotate the inferred type with a -- result proof tree. addProof :: Either String Ty -> [String] -> Tm -> M (Either String Ty , String) addProof et premises tm = do R { _mode , _ctx } <- ask let (judgment , rule) = conclusion _mode _ctx tm et let tex = "\\infer[ " ++ rule ++ " ]{ " ++ judgment ++ " }{ " ++ intercalate " & " premises ++ " }" return (et , tex)
conclusion :: Mode -> Ctx -> Tm -> Either String Ty -> (String , String) conclusion mode ctx tm e = (judgment mode , rule tm) where rule (TmVar _) = "\\textsc{Axiom}" rule (Lam {}) = "\\to \\text{I}" rule (_ :@: _) = "\\to \\text{E}" tyOrError = either id pp e judgment True = pp ctx ++ " \\vdash " ++ pp tm ++ " : " ++ tyOrError judgment False = ppCtxOnlyTypes ctx ++ " \\vdash " ++ tyOrError
type Mode = Bool type Stream = LogStream (ProofTree Mode) type M a = ErrorT String (ReaderT Ctx (Writer Stream)) a type InferTy = Tm -> M Ty infer , infer infer = simpleLogger (Proxy::Proxy "infer") ask (return ()) infer' infer err = throwError $ "Variable " ++ x ++ " not in context!" infer infer t <- infer e t1 <- infer e1 case t of t1 _ -> throwError $ "Can
infer = simpleLogger (Proxy::Proxy "infer") ask (return ()) infer'
instance ProofTree Mode (Proxy (SimpleCall "infer" Ctx InferTy ())) where callAndReturn mode t = conclusion mode ctx tm (Right ty) where (tm , ()) = _arg t ty = _ret t ctx = _before t callAndError mode t = conclusion mode ctx tm (Left error) where (tm , ()) = _arg how = _how t ctx = _before error = maybe "\\,!" (const "\\,\\uparrow") how
proofTree :: mode -> Ex2T (LogTree (ProofTree mode)) -> String proofTree mode (Ex2T t@(CallAndReturn {})) = "\\infer[ " ++ rule ++ " ]{ " ++ conclusion ++ " }{ " ++ intercalate " & " premises ++ " }" where (conclusion , rule) = callAndReturn mode t premises = map (proofTree mode) (_children t) proofTree mode (Ex2T t@(CallAndError {})) = "\\infer[ " ++ rule ++ " ]{ " ++ conclusion ++ " }{ " ++ intercalate " & " premises ++ " }" where (conclusion , rule) = callAndError mode t premises = map (proofTree mode) (_children
- Precedence: higher value means tighter binding. type Prec = Double between :: Prec -> Prec -> Prec between x y = (x + y) / 2 lowest , highest , precLam , precApp , precArr :: Prec highest = 1 lowest = 0 precLam = lowest precApp = between precLam highest precArr = lowest -- Associativity: left, none, or right. data Assoc = L | N | R deriving Eq -- Wrap a pretty print when the context dictates. wrap :: Pretty a => Assoc -> a -> a -> String wrap side ctx x = if prec x `comp` prec ctx then pp x else parens . pp $ x where comp = if side == assoc x || assoc x == N then (>=) else (>) parens s = "(" ++ s ++ ")"
class Pretty t where pp :: t -> String prec :: t -> Prec prec _ = highest assoc :: t -> Assoc assoc _ = N instance Pretty Ty where pp (TyVar v) = v pp t@(t1 :->: t2) = wrap L t t1 ++ " {\\to} " ++ wrap R t t2 prec (_ :->: _) = precArr prec _ = highest assoc (_ :->: _) = R assoc _ = N instance Pretty Tm where pp (TmVar v) = v pp (Lam x t e) = "\\lambda " ++ x ++ " {:} " ++ pp t ++ " . " ++ pp e pp e@(e1 :@: e2) = wrap L e e1 ++ " " ++ wrap R e e2 prec (Lam {}) = precLam prec (_ :@: _) = precApp prec _ = highest assoc (_ :@: _) = L assoc _ = N instance Pretty Ctx where pp [] = "\\cdot" pp ctx@(_:_) = intercalate " , " [ x ++ " {:} " ++ pp t | (x,t) <- ctx ]
-- Terms e ::= x | \x:T.e | e e -- Types T ::= A | T -> T -- Contexts C ::= . | C,x:T
-- Terms e ::= e e -- Types T ::= T T -- Contexts C ::= . | C,x:T
type P a = Parsec String () a parens :: P a -> P a parens = Text.Parsec.between (char tmVar , tyVar :: P String tmVar = (:[]) <$> lower tyVar = (:[]) <$> upper tyAtom , arrs , ty :: P Ty tyAtom = parens ty <|> TyVar <$> tyVar arrs = chainr1 tyAtom arrOp where arrOp = string "->" *> pure (:->:) ty = arrs tmAtom , apps , lam , tm :: P Tm tmAtom = parens tm <|> TmVar <$> tmVar apps = chainl1 tmAtom appOp where appOp = pure (:@:) lam = uncurry Lam <$> (char <*> (char tm = apps <|> lam typing :: P (TmVar , Ty) typing = (,) <$> tmVar <*> (char ctx :: P Ctx ctx = typing `sepBy` (char
./tm2latex.sh S.ctx ./tm2latex.sh S.lam ./tm2latex.sh S.err ./tm2latex.sh K.ctx ./tm2latex.sh K.lam ./tm2latex.sh I.ctx ./tm2latex.sh I.lam ./tm2latex.sh MP.ctx ./tm2latex.sh MP.lam ./tm2latex.sh ZERO ./tm2latex.sh SUCC ./tm2latex.sh ADD ./tm2latex.sh MULT ./tm2latex.sh Y.err ./tm2latex.sh Y.ctx
unlines [ "\\documentclass[10pt]{article}" , "\\usepackage{proof}" , "\\usepackage{amsmath}" , "\\usepackage[landscape]{geometry}" , "\\usepackage[cm]{fullpage}" -- The most slender font I could find: -- http: , "\\usepackage[light,condensed,math]{iwona}" , "\\usepackage[T1]{fontenc}" , "\\begin{document}" , "\\tiny" , "\\[" ++ tex ++ "\\]" , "\\end{document}" ]
import GHC.Prim trustFromJust :: Maybe x -> x trustFromJust x = y where Just1 y = unsafeCoerce data Just1 a = Just1 a
main2 = case (Data.Maybe.Just @ Type.Integer main3) `cast` (CoUnsafe (Data.Maybe.Maybe Type.Integer) (Just1 Type.Integer) :: Data.Maybe.Maybe Type.Integer ~ Just1 Type.Integer) of _ { Just1 y_aeb -> $wshowsPrec 0 y_aeb ([] @ Char)
-- 1. First line. -- -- 2. Second line with instructions to do something -- -- >>> command-linecmd param -- -- 3. Third line.. --
</p><ol><li> First line. </li><li> Second line with instructions to do something </li></ol><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>command-linecmd param </code></strong></pre><ol><li> Third line.. </li></ol>
1. First element 2. Second element >>> your example your example result 3. Third element
type Constraint = Text data Value = Value [Constraint] data Literal = Literal Value [Value] type Formula = [Literal]
sudo apt-get install ghc sudo apt-get install cabal-install cabal update cabal install hsenv
xx@xx-VirtualBox:~/scm/t1$ hsenv Creating Virtual Haskell directory structure Installing GHC Initializing GHC Package database at /home/xx/scm/t1/.hsenv/ghc_pkg_db Copying necessary packages from original GHC package database Failed to copy optional package ghc-binary from system /usr/bin/ghc-pkg process failed with status 1 Using user-wide (~/.cabal/packages) Hackage download cache directory Installing cabal config at /home/xx/scm/t1/.hsenv/cabal/config Installing activate script Installing cabal wrapper using /home/xx/scm/t1/.hsenv/cabal/config at /home/xx/scm/t1/.hsenv/bin/cabal Skipping to ~/.cabal/packages/. You can update it manually with (from inside or outside the virtual environment).
static void Main(string[] args) { int number = 1234567890; string numberAsString = number.ToString(); foreach(char x in numberAsString) { string y = x.ToString(); int z = int.Parse(y); Foo(z); } } void Foo(int n) { Console.WriteLine(n*n); }
digs :: Integral x => x -> [x] digs 0 = [] digs x = digs (x `div` 10) ++ [x `mod` 10]
digs :: Integral x => x -> [x] digs 0 = [] digs x = x `mod` 10 : digs (x `div` 10)
digits :: Integer -> [Int] digits = map (read . (:[])) . show
digits :: Integer -> [Int] digits = map (read . return) . show
digits :: Integer -> [Int] digits = map digitToInt . show
digits :: Integer -> [Int] digits n = map (\x -> read [x] :: Int) (show n)
digits = map (`mod` 10) . reverse . takeWhile (> 0) . iterate (`div` 10)
rev_digits = map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10)
digits n = map(`mod` 10) $ reverse $ takeWhile (> 0) $ iterate (`div`10) n
import qualified Data.List as L digits = reverse . L.unfoldr (\x -> if x == 0 then Nothing else Just (mod x 10, div x 10))
import Data.Char digits :: Integer -> [Integer] digits n = [toInteger (digitToInt x) | x <- show n]
toDigits :: Integer -> [Integer] -- 12 -> [1,2], 0 -> [0], 10 -> [1,0] toDigits x | x < 10 = [x] | otherwise = toDigits (div x 10) ++ [mod x 10]
import Data.Char toDigits :: Integer -> [Integer] toDigits n = map (\x -> toInteger (digitToInt x)) (show n)
digs :: Int -> [Int] digs 0 = [] digs x | x < 0 = digs ((-1) * x) | x > 0 = digs (div x 10) ++ [mod x 10]
import Data.List import Data.Tuple import Data.Bool import Control.Applicative digits = unfoldr $ liftA2 (bool Nothing) (Just . swap . (`divMod` 10)) (> 0)
{- digits :: Integral a => a -> NonEmpty Word8 digits = go [] where go s x = loop (head :| s) tail where head = fromIntegral (x `mod` 10) tail = x `div` 10 loop s@(r :| rs) = \case 0 -> s x -> go (r : rs) x
toDigits :: Integer -> [Integer] toDigits n | n >=0 && n < 10 = [n] | n >= 10 = toDigits (n`div`10) ++ [n`mod`10] | otherwise = error "make sure your input is greater than 0"
toDigits :: Integer -> [Integer] toDigits x = reverse $ toDigitsRev x toDigitsRev :: Integer -> [Integer] toDigitsRev x | x <= 0 = [] | otherwise = x `rem` 10 : toDigitsRev (x `quot` 10)
digits = reverse . unfoldr go where go = uncurry (*>) . (&&&) (guard . (>0)) (Just . swap . (`quotRem` 10))
ghci> maxBound :: Char ghci> maxBound :: Int 9223372036854775807
data C a = C {value :: a, count :: Int} deriving (Show) instance Monad C where (>>=) (C x c) f = C (value $ f x) (c + 1) return x = C x 0 add :: (Num a) => a -> a -> C a add x y = return $ x + y -- Simpler way to do this? foldM is obviously something different. mysum [x] = return x mysum (x:xs) = mysum xs >>= add x
(1) return x >>= f = f x (2) m >>= return = m (3) m >>= (f >=> g) = (m >>= f) >>= g
return 0 >>= return = C 0 0 >>= return = C (value $ return 0) 1 = C 0 1 Not equal to return 0 = C 0 0
C 0 0 >>= return = C (value $ return 0) 1 = C 0 1 Not equal to C 0 0
C 0 0 >>= (return >=> return) = C (value $ (return >=> return) 0) 1 = C (value $ return 0 >>= return) 1 = C (value $ C 0 1) 1 = C 0 1 Is not equal to: (C 0 0 >>= return) >>= return = C (value $ return 0) 1 >>= return = C 0 1 >>= return = C (value $ return 0) 2 = C 0 2
import Control.Monad import Control.Monad.Trans import Control.Monad.Trans.Maybe
greet :: IO () -- type: greet = do putStr "What is your name? " -- IO () n <- getLine -- IO String putStrLn $ "Hello, " ++ n -- IO ()
mgreet :: MaybeT IO () mgreet = do putStr "What is your name? " -- IO monad - need MaybeT IO here ...
liftIO :: IO a -> MaybeT IO a mgreet :: MaybeT IO () -- types: mgreet = do liftIO $ putStr "What is your name? " -- MaybeT IO () n <- liftIO getLine -- MaybeT IO String liftIO $ putStrLn $ "Hello, " ++ n -- MaybeT IO ()
ghci> :t runMaybeT mgreet mgreet :: IO (Maybe ()) ghci> runMaybeT mgreet What is your name? user5402 Hello, user5402 Just ()
askfor :: String -> IO String askfor prompt = do putStr $ "What is your " ++ prompt ++ "? " getLine survey :: IO (String,String) survey = do n <- askfor "name" c <- askfor "favorite color" return (n,c)
askfor1 :: String -> IO (Maybe String) askfor1 prompt = do putStr $ "What is your " ++ prompt ++ " (type END to quit)? " r <- getLine if r == "END" then return Nothing else return (Just r) survey1 :: IO (Maybe (String, String)) survey1 = do ma <- askfor1 "name" case ma of Nothing -> return Nothing Just n -> do mc <- askfor1 "favorite color" case mc of Nothing -> return Nothing Just c -> return (Just (n,c))
askfor2 :: String -> MaybeT IO String askfor2 prompt = do liftIO $ putStr $ "What is your " ++ prompt ++ " (type END to quit)? " r <- liftIO getLine if r == "END" then MaybeT (return Nothing) -- has type: MaybeT IO String else MaybeT (return (Just r)) -- has type: MaybeT IO String
Nothing :: Maybe String return Nothing :: IO (Maybe String) MaybeT (return Nothing) :: MaybeT IO String Just "foo" :: Maybe String return (Just "foo") :: IO (Maybe String) MaybeT (return (Just "foo")) :: MaybeT IO String
survey2 :: IO (Maybe (String,String)) survey2 = runMaybeT $ do a <- askfor2 "name" b <- askfor2 "favorite color" return (a,b)
MaybeT (return (Just r)) -- return is from the IO monad
askfor2 prompt = do r <- liftIO $ do putStr $ "What is your " ++ prompt ++ " (type END to quit)?" getLine if r == "END" then mzero -- break out of the monad else return r -- continue, returning r
loop1 = do putStr "Password:" p <- getLine if p == "SECRET" then return () else loop1
def loop(): while True: p = raw_prompt("Password: ") if p == "SECRET": break
loop2 :: IO (Maybe ()) loop2 = runMaybeT $ forever $ do liftIO $ putStr "Password: " p <- liftIO $ getLine if p == "SECRET" then mzero -- break out of the loop else return ()
do ma <- foo case ma of Nothing -> return Nothing Just a -> do mb <- func1 a case mb of Nothing -> return Nothing Just b -> func2 b
newtype MaybeOverIO a = MaybeOverIO { runMaybeOverIO :: IO (Maybe a) }
betterBind :: MaybeOverIO a -> (a -> MaybeOverIO b) -> MaybeOverIO b betterBind mia mf = MaybeOverIO $ do ma <- runMaybeOverIO mia case ma of Nothing -> return Nothing Just a -> runMaybeOverIO (mf a)
newtype MaybeOverM m a = MaybeOverM { runMaybeOverM :: m (Maybe a) }
newtype MaybeT m a = MaybeT {unMaybeT :: m (Maybe a)}
instance (Monad m) => Monad (MaybeT m) where return a = MaybeT (return (Just a)) (MaybeT mmv) >>= f = MaybeT $ do mv <- mmv case mv of Nothing -> return Nothing Just a -> unMaybeT (f a)
MaybeT . getDatabaseResult :: String -> MaybeT IO String
return a >>= k = k a m >>= return = m xs >>= return . f = fmap f xs m >>= (\x -> k x >>= h) = (m >>= k) >>= h
-- defined in Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c mf >=> n = \x -> mf x >>= n
1) return >=> mf = mf -- left identity 2) mf >=> return = mf -- right identity 4) (f >=> g) >=> h = f >=> (g >=> h) -- associativity
do do y <- do x <- m x <- m y <- k x <=> k x h y h y
import Data.Array.Repa as R import qualified Data.Vector.Unboxed as V import Prelude as P -- Calculate the volume of a sphere by putting it in a bath of coordinates. Generate coordinates (x,y,z) in a cuboid. Then, for each coordinate, check if it is inside the sphere. Sum those coordinates and multiply by the coordinate grid step size to find an approximate volume. particles = [(0,0,0)] -- used for the list alternative --[(0,0,0),(0,2,0)] particles_repa = [0,0,0::Double] -- used for the repa alternative, can currently just be one coordinate -- Radius of the particle a = 4 -- Generate the coordinates. Could this be done more efficiently, and at the same time simple? In Matlab I would use ndgrid. step = 0.1 --0.05 xrange = [-10,-10+step..10] :: [Double] yrange = [-10,-10+step..10] zrange = [-10,-10+step..10] -- All coordinates as triples. These are used directly in the list version below. coords = [(x,y,z) | x <- xrange, y <- yrange, z <- zrange] ---- List code ---- volumeIndividuals = fromIntegral (length particles) * 4*pi*a**3/3 volumeInside = step**3 * fromIntegral (numberInsideParticles particles coords) numberInsideParticles particles coords = length $ filter (==True) $ P.map (insideParticles particles) coords insideParticles particles coord = any (==True) $ P.map (insideParticle coord) particles insideParticle (xc,yc,zc) (xp,yp,zp) = ((xc-xp)^2+(yc-yp)^2+(zc-zp)^2) < a**2 ---- End list code ---- ---- Repa code ---- -- Put the coordinates in a Nx3 array. xcoords = P.map (\(x,_,_) -> x) coords ycoords = P.map (\(_,y,_) -> y) coords zcoords = P.map (\(_,_,z) -> z) coords -- Total number of coordinates num_coords = (length xcoords) ::Int xcoords_r = fromList (Z :. num_coords :. (1::Int)) xcoords ycoords_r = fromList (Z :. num_coords :. (1::Int)) ycoords zcoords_r = fromList (Z :. num_coords :. (1::Int)) zcoords rcoords = xcoords_r R.++ ycoords_r R.++ zcoords_r -- Put the particle coordinates in an array, then extend (replicate) this array so that its size becomes the same as that of rcoords particle = fromList (Z :. (1::Int) :. (3::Int)) particles_repa particle_slice = slice particle (Z :. (0::Int) :. All) particle_extended = extend (Z :. num_coords :. All) particle_slice -- Calculate the squared difference between the (x,y,z) coordinates of the particle and the coordinates of the cuboid. squared_diff = deepSeqArrays [rcoords,particle_extended] ((force2 rcoords) -^ (force2 particle_extended)) **^ 2 (**^) arr pow = R.map (**pow) arr xslice = slice squared_diff (Z :. All :. (0::Int)) yslice = slice squared_diff (Z :. All :. (1::Int)) zslice = slice squared_diff (Z :. All :. (2::Int)) -- Calculate the distance between each coordinate and the particle center sum_squared_diff = [xslice,yslice,zslice] `deepSeqArrays` xslice +^ yslice +^ zslice -- Do the rest using vector, since I didn ssd_vec = toVector sum_squared_diff -- Determine the number of the coordinates that are within the particle (instead of taking the square root to get the distances above, I compare to the square of the radius here, to improve performance) total_within = fromIntegral (V.length $ V.filter (<a**2) ssd_vec) --total_within = foldAll (\x acc -> if x < a**2 then acc+1 else acc) 0 sum_squared_diff -- Finally, calculate an approximation of the volume of the sphere by taking the volume of the cubes with side step, multiplied with the number of coordinates within the sphere. volumeInside_repa = step**3 * total_within -- Helper function that shows the size of a 2-D array. rsize = reverse . listOfShape . (extent :: Array DIM2 Double -> DIM2) ---- End repa code ---- -- Comment out the list or the repa version if you want to time the calculations separately. main = do putStrLn $ "Step = " P.++ show step putStrLn $ "Volume of individual particles = " P.++ show volumeIndividuals putStrLn $ "Volume of cubes inside particles (list) = " P.++ show volumeInside putStrLn $ "Volume of cubes inside particles (repa) = " P.++ show volumeInside_repa
function archimedes_simple() particles = [0 0 0] a = 4; step = 0.1; xrange = [-10:step:10]; yrange = [-10:step:10]; zrange = [-10:step:10]; [X,Y,Z] = ndgrid(xrange,yrange,zrange); dists2 = bsxfun(@minus,X,particles(1)).^2+ ... bsxfun(@minus,Y,particles(2)).^2+ ... bsxfun(@minus,Z,particles(3)).^2; inside = dists2 < a^2; num_inside = sum(inside(:)); disp( disp([ disp([ disp([ end
import Data.Array.Repa as R import Prelude as P import qualified Data.List as L -- Calculate the volume of a spherical particle by putting it in a bath of coordinates. Generate coordinates (x,y,z) in a cuboid. Then, for each coordinate, check if it is inside the sphere. Sum those coordinates and multiply by the coordinate grid step size to find an approximate volume. particles :: [(Double,Double,Double)] particles = [(0,0,0)] -- Radius of the spherical particle a = 4 volume_individuals = fromIntegral (length particles) * 4*pi*a^3/3 -- Generate the coordinates. step = 0.1 coords_list = [-10,-10+step..10] :: [Double] num_coords = (length coords_list) :: Int coords :: Array DIM1 Double coords = fromList (Z :. (num_coords ::Int)) coords_list coords_slice :: Array DIM1 Double coords_slice = slice coords (Z :. All) -- x, y and z are 3-D arrays, where the same index into each array can be used to find a single coordinate, e.g. (x(i,j,k),y(i,j,k),z(i,j,k)). x,y,z :: Array DIM3 Double x = extend (Z :. All :. num_coords :. num_coords) coords_slice y = extend (Z :. num_coords :. All :. num_coords) coords_slice z = extend (Z :. num_coords :. num_coords :. All) coords_slice -- Calculate the squared distance from each coordinate to the center of the spherical particle. dist2 :: (Double, Double, Double) -> Array DIM3 Double dist2 particle = ((R.map (squared_diff xp) x) + (R.map (squared_diff yp) y) + (R.map ( squared_diff zp) z)) where (xp,yp,zp) = particle squared_diff xi xa = (xa-xi)^2 -- Count how many of the coordinates are within the spherical particle. num_inside_particle :: (Double,Double,Double) -> Double num_inside_particle particle = foldAll (\acc x -> if x<a^2 then acc+1 else acc) 0 (force $ dist2 particle) -- Calculate the approximate volume covered by the spherical particle. volume_inside :: [Double] volume_inside = P.map ((*step^3) . num_inside_particle) particles main = do putStrLn $ "Step = " P.++ show step putStrLn $ "Volume of individual particles = " P.++ show volume_individuals putStrLn $ "Volume of cubes inside each particle (repa) = " P.++ (P.concat . ( L.intersperse ", ") . P.map show) volume_inside -- As an alternative, y and z could be generated from x, but this was slightly slower in my tests (~0.4 s). --y = permute_dims_3D x --z = permute_dims_3D y -- Permute the dimensions in a 3-D array, (forward, cyclically) permute_dims_3D a = backpermute (swap e) swap a where e = extent a swap (Z :. i:. j :. k) = Z :. k :. i :. j
COST CENTRE MODULE %time %alloc squared_diff Main 25.0 27.3 insideParticle Main 13.8 15.3 sum_squared_diff Main 9.8 5.6 rcoords Main 7.4 5.6 particle_extended Main 6.8 9.0 particle_slice Main 5.0 7.6 insideParticles Main 5.0 4.4 yslice Main 3.6 3.0 xslice Main 3.0 3.0 ssd_vec Main 2.8 2.1 **^ Main 2.6 1.4
squared_diff :: Array DIM2 Double squared_diff = deepSeqArrays [rcoords,particle_extended] ((force2 rcoords) -^ (force2 particle_extended)) **^ 2
COST CENTRE MODULE %time %alloc rcoords Main 32.6 34.4 particle_extended Main 21.5 27.2 **^ Main 9.8 12.7
numberInsideParticles particles coords = length $ filter id $ withStrategy (parListChunk 2000 rseq) $ P.map (insideParticles particles) coords
import Numeric formatFloatN floatNum numOfDecimals = showFFloat (Just numOfDecimals) floatNum ""
Prelude> import Text.Printf Prelude Text.Printf> printf "%.2f\n" (100 :: Float) 100.00 Prelude Text.Printf> printf "%.2f\n" $ fromIntegral 100 / 10.00 10.00
Prelude Text.Printf> printf "%.2f" (1337 :: Float) ++ " is a number" "1337.00 is a number"
Prelude Text.Printf> printf "%.2f\n" (1337 :: Float) :: IO a 1337.00 Prelude Text.Printf> printf "%.2f\n" (1337 :: Float) :: String "1337.00\n"
Downloading the latest package list from hackage.haskell.org Note: there is a new version of cabal-install available. To upgrade, run: cabal install cabal-install
Downloading the latest package list from hackage.haskell.org Note: there is a new version of cabal-install available. To upgrade, run: cabal install cabal-install
cabal: ../ghc-7.4.2/lib/cabal-install-1.16.0.2/bin/cabal: does not exist
$ which cabal /Users/luke/Library/Haskell/bin/cabal $ cabal update Downloading the latest package list from hackage.haskell.org $ cabal --version cabal-install version 1.16.0.2 using version 1.16.0.3 of the Cabal library
-- === Built executables will be installed in: -- ~/Library/Haskell/bin -- -- You may wish to place this on your PATH by adding the following -- line to your ~/.bash_profile: -- export PATH="$HOME/Library/Haskell/bin:$PATH"
class Contravariant (f :: * -> *) where contramap :: (a -> b) -> f b -> f a
fmap :: (r -> s) -> (a -> r) -> (a -> s) fmap adaptor f = adaptor . f fmap adaptor = (adaptor .) fmap = (.) contramap contramap contramap contramap
class (Ring.C a) => EuclideanDomain a where norm :: a -> Integer
newtype ByNorm a = ByNorm a instance (EuclideanDomain a, Eq a) => Ord (ByNorm a) where compare (ByNorm x) (ByNorm y) = compare (norm x) (norm y)
data Exp = Infix Op Exp Exp | ... data Op = Add | Subtract | Multiply | Divide
data Foo = IntFoo !Int | FooFoo !Foo | BarFoo !Bar data Bar = IntBar Int
> :k Int Int :: * > :k Maybe Maybe :: * -> * > :k Either Either :: * -> * -> * > :k Num Num :: * -> Constraint > :k Monad Monad :: (* -> *) -> Constraint
> undefined :: ByteArray# Error: Kind incompatibility when matching types: a0 :: * ByteArray
Prelude> :kind Maybe Int Maybe Int :: * Prelude> :kind Maybe Maybe :: * -> *
Prelude> :k [String] [String] :: * Prelude> :k [] [] :: * -> *
Prelude> :k Either Int String Either Int String :: * Prelude> :k Either Int Either Int :: * -> *
doGuessing num = do putStrLn "Enter your guess:" guess <- getLine if (read guess) < num then do putStrLn "Too low!" doGuessing num else if (read guess) > num then do putStrLn "Too high!" doGuessing num else do putStrLn "You Win!"
doGuessing num = do putStrLn "Enter your guess:" guess <- getLine if (read guess) < num then do putStrLn "Too low!" doGuessing num else if (read guess) > num then do putStrLn "Too high!" doGuessing num else do putStrLn "You Win!"
main = untilM (isCorrect 42) (read `liftM` getLine)
untilM :: Monad m => (a -> m Bool) -> m a -> m () untilM p a = do x <- a done <- p x if done then return () else untilM p a
isCorrect :: Int -> Int -> IO Bool isCorrect num guess = case compare num guess of EQ -> putStrLn "You Win!" >> return True LT -> putStrLn "Too high!" >> return False GT -> putStrLn "Too low!" >> return False
doGuessing num = do putStrLn "Enter your guess:" guess <- getLine case (read guess) of g | g < num -> do putStrLn "Too low!" doGuessing num g | g > num -> do putStrLn "Too high!" doGuessing num otherwise -> do putStrLn "You Win!"
doGuessing num = do putStrLn "Enter your guess:" guess <- getLine case (read guess) `compare` num of LT -> do putStrLn "Too low!" doGuessing num GT -> do putStrLn "Too high!" doGuessing num EQ -> putStrLn "You Win!"
{- import Criterion.Main import Data.Monoid import Control.Applicative import Control.Monad import Prelude hiding (sum) data Fold e r where Step :: !(a -> e -> a) -> !a -> !(a -> r) -> Fold e r Bind :: !(Fold e r) -> !(r -> Fold e s) -> Fold e s data P a b = P !a !b instance Functor (Fold e) where fmap f (Step step acc ret) = Step step acc (f . ret) fmap f (Bind fld g) = Bind fld (fmap f . g) instance Applicative (Fold e) where pure a = Step const a id Step fstep facc fret <*> Step xstep xacc xret = Step step acc ret where step (P fa xa) e = P (fstep fa e) (xstep xa e) acc = P facc xacc ret (P fa xa) = (fret fa) (xret xa) Bind fld g <*> fldx = Bind fld ((<*> fldx) . g) fldf <*> Bind fld g = Bind fld ((fldf <*>) . g) instance Monad (Fold e) where return = pure (>>=) = Bind fold :: Fold e r -> [e] -> r fold (Step _ acc ret) [] = ret acc fold (Step step acc ret) (x:xs) = fold (Step step (step acc x) ret) xs fold (Bind fld g) lst = fold (g $ fold fld lst) lst monoidalFold :: Monoid m => (e -> m) -> (m -> r) -> Fold e r monoidalFold f g = Step (\a -> mappend a . f) mempty g count :: Num n => Fold e n count = monoidalFold (const (Sum 1)) getSum sum :: Num n => Fold n n sum = monoidalFold Sum getSum avgA :: Fold Double Double avgA = liftA2 (/) sum count avgM :: Fold Double Double avgM = liftM2 (/) sum count main :: IO () main = defaultMain [ bench "Monadic" $ nf (test avgM) 1000000 , bench "Applicative" $ nf (test avgA) 1000000 ] where test f n = fold f [1..n]
benchmarking Monadic mean: 119.3114 ms, lb 118.8383 ms, ub 120.2822 ms, ci 0.950 std dev: 3.339376 ms, lb 2.012613 ms, ub 6.215090 ms, ci 0.950 benchmarking Applicative mean: 51.95634 ms, lb 51.81261 ms, ub 52.15113 ms, ci 0.950 std dev: 850.1623 us, lb 667.6838 us, ub 1.127035 ms, ci 0.950
data Nat = Z | S Nat deriving (Show, Eq, Ord) data Vec :: Nat -> * -> * where V0 :: Vec Z x (:>) :: x -> Vec n x -> Vec (S n) x
data Natty :: Nat -> * where Zy :: Natty Z Sy :: Natty n -> Natty (S n) class NATTY (n :: Nat) where natty :: Natty n instance NATTY Z where natty = Zy instance NATTY n => NATTY (S n) where natty = Sy natty
instance NATTY n => Applicative (Vec n) where pure = vcopies natty (<*>) = vapp vcopies :: forall n x. Natty n -> x -> Vec n x vcopies Zy x = V0 vcopies (Sy n) x = x :> vcopies n x vapp :: forall n s t. Vec n (s -> t) -> Vec n s -> Vec n t vapp V0 V0 = V0 vapp (f :> fs) (s :> ss) = f s :> vapp fs ss
vtail :: forall n x. Vec (S n) x -> Vec n x vtail (x :> xs) = xs vjoin :: forall n x. Natty n -> Vec n (Vec n x) -> Vec n x vjoin Zy _ = V0 vjoin (Sy n) ((x :> _) :> xxss) = x :> vjoin n (fmap vtail xxss) instance NATTY n => Monad (Vec n) where return = vcopies natty xs >>= f = vjoin natty (fmap f xs)
import Criterion.Main import Data.Vector as V import Control.Monad import Control.Applicative functions :: V.Vector (Int -> Int) functions = V.fromList [(+1), (*2), (subtract 1), \x -> x*x] values :: V.Vector Int values = V.enumFromN 1 32 type NRuns = Int apBencher :: (V.Vector (Int -> Int) -> V.Vector Int -> V.Vector Int) -> NRuns -> Int apBencher ap where run arr 0 = V.sum arr run arr n = run (functions `ap main = defaultMain [ bench "Monadic" $ nf (apBencher ap ) 4 , bench "Applicative" $ nf (apBencher (<*>)) 4 ]
foo :: (a -> b) -> a -> b foo f x = f x -- applies the function f on x
flip :: (a -> b -> c) -> b -> a -> c flip f x y = f y x
flip :: (a -> b -> c) -> b -> a -> c flip f x y = g where g = f y x
flip :: (a -> b -> c) -> b -> a -> c flip f x y = g x y where g a b = f b a
flip :: (a -> b -> c) -> b -> a -> c flip f = g where g a b = f b a
flip :: (a -> b -> c) -> b -> a -> c flip f = g where g x y = f y x
$ cd /home/john/webapps/mysite $ cabal install ... Preprocessing executable Installing executable(s) in /home/john/.cabal/bin
start on startup chdir /home/john/webapps/mysite exec /home/john/.cabal/bin/mysite -p 80
class Contravariant f => Divisible f where divide :: (a -> (b, c)) -> f b -> f c -> f a conquer :: f a
data Group a = Group (forall b . [(a, b)] -> [[b]])
groupId :: Group a -> [a] -> [[a]] groupId (Group grouper) = grouper . map (\a -> (a, a))
divide :: (a -> (b, c)) -> Group b -> Group c -> Group a
instance Divisible Group where conquer = Group $ return . fmap snd divide k (Group l) (Group r) = Group $ \xs -> -- a bit more cleverly done here... l [ (b, (c, d)) | (a,d) <- xs, let (b, c) = k a] >>= r
class Divisible f => Decidable f where lose :: (a -> Void) -> f a choose :: (a -> Either b c) -> f b -> f c -> f a instance Decidable Group where lose :: (a -> Void) -> Group a choose :: (a -> Either b c) -> Group b -> Group c -> Group a
window :: Event DrawCommand -> Signal WindowIcon -> Signal WindowTitle -> ... -> FRP (Event (Int, Int) {- mouse events -}, Event (Key, Action) {- key events -}, ...)
window :: WindowProperties -> ReactiveWidget -> FRP (ReactiveWindow, ReactiveWidget)
button :: ButtonProperties -> ReactiveWidget -> (ReactiveButton, ReactiveWidget)
horizontalLayout :: HLayoutProperties -> ReactiveWidget -> (ReactiveLayout, ReactiveWidget)
main = runFRP $ do rec -- Recursive do, lets us use winInp lazily before it is defined -- Create window: (win, winOut) <- window winProps winInp -- Create some arbitrary layout with our 2 widgets: let (lay, layOut) = layout (def { widgets = [butOut, labOut] }) layInp -- Create a button: (but, butOut) = button butProps butInp -- Create a label: (lab, labOut) = label labProps labInp -- Connect the layout input to the window output layInp = winOut -- Connect the layout output to the window input winInp = layOut -- Get the spliced input from the layout [butInp, layInp] = layoutWidgets lay -- "pure" is of course from Applicative Functors and indicates a constant Signal winProps = def { title = pure "Hello, World!", size = pure (800, 600) } butProps = def { title = pure "Click me!" } labProps = def { text = reactiveIf (buttonPressed but) (pure "Button pressed") (pure "Button not pressed") } return ()
type Object a = ForeignPtr a data CWindow a data CControl a data CButton a type Window a = Object (CWindow a) type Control a = Window (CControl a) type Button a = Control (CButton a)
data CWindow a = CWindow { close :: IO () , ... } data CButton a = CButton { onClick :: (Mouse -> IO ()) -> IO () , ... }
class PtS f where unit :: f Void (**) :: f a -> f b -> f (Either a b) -- some example instances instance PtS Maybe where unit = Nothing Nothing ** Nothing = Nothing Just a ** Nothing = Just (Left a) Nothing ** Just b = Just (Right b) Just a ** Just b = Just (Left a) -- ick, but it does satisfy the laws instance PtS [] where unit = [] xs ** ys = map Left xs ++ map Right ys
pure a = fmap (const a) unit unit = pure () ff <*> fa = fmap (\(f,a) -> f a) $ ff ** fa fa ** fb = pure (,) <*> fa <*> fb
liftA2 :: (a -> b -> c) -> f a -> f b -> f c liftA2 (,) :: f a -> f b -> f (a,b)
(<*>) :: f (a -> b) -> f a -> f b (<*>) = liftA2 ($)
empty :: f a empty = fmap absurd unit unit :: f Void unit = empty
data Either a b = Left a | Right b {- type Sum a b = forall c. (a -> c) -> (b -> c) -> c
either :: (a -> c) -> (b -> c) -> Either a b -> c toSum :: Either a b -> Sum a b toSum e = \forA forB -> either forA forB e toEither :: Sum a b -> Either a b toEither s = s Left Right
(**) :: f a -> f b -> f (Either a b) (**) :: f a -> f b -> f (Sum a b) (**) :: f a -> f b -> f ((a -> c) -> (b -> c) -> c)
fmap (\f -> f forA forB) (fa ** fb) = fmap forA fa <||> fmap forB fb
fa ** fb = fmap Left fa <||> fmap Right fb fa1 <||> fa2 = fmap (either id id) $ fa1 ** fa2
class Functor f => AlmostAlternative f where empty :: f a (<||>) :: f a -> f a -> f a
class (Functor f, forall a. Monoid (f a)) => MonoidalFunctor f
class (Functor f) => Decisive f where nogood :: f Void -> Void orwell :: f (Either s t) -> Either (f s) (f t)
class Applicative f => Alternative f where empty :: f a (<|>) :: f a -> f a -> f a
Tue Oct 25 19:01 2011 Time and Allocation Profiling Report (Final) main +RTS -sstderr -p -hc -RTS jh e False total time = 6.56 secs (328 ticks @ 20 ms) total alloc = 4,086,951,472 bytes (excludes profiling overheads) COST CENTRE MODULE %time %alloc roundFunction Data.Digest.JHInternal 28.4 37.4 word128Shift Data.BigWord.Word128 14.9 19.7 blockMap Data.Digest.JHInternal 11.9 12.9 getBytes Data.Serialize.Get 6.7 2.4 unGet Data.Serialize.Get 5.5 1.3 sbox Data.Digest.JHInternal 4.0 7.4 getWord64be Data.Serialize.Get 3.7 1.6 e8 Data.Digest.JHInternal 3.7 0.0 swap4 Data.Digest.JHInternal 3.0 0.7 swap16 Data.Digest.JHInternal 3.0 0.7 swap8 Data.Digest.JHInternal 1.8 0.7 swap32 Data.Digest.JHInternal 1.8 0.7 parseBlock Data.Digest.JHInternal 1.8 1.2 swap2 Data.Digest.JHInternal 1.5 0.7 swap1 Data.Digest.JHInternal 1.5 0.7 linearTransform Data.Digest.JHInternal 1.5 8.6 shiftl_w64 Data.Serialize.Get 1.2 1.1 Detailed breakdown omitted ...
shiftL (W (xh .&. 0x5555555555555555) (xl .&. 0x5555555555555555)) 1 .|. shiftR (W (xh .&. 0xaaaaaaaaaaaaaaaa) (xl .&. 0xaaaaaaaaaaaaaaaa)) 1
(+) :: Real -> Real -> Real (+) x y n = (x $ n + 1) + (y $ n + 1)
type VectorField = SmoothFunction -> SmoothFunction
type AnalyticFunction = Double -> Integer -> [Double]
import Control.Monad.Cont import Data.Foldable (foldrM) import Data.Set setReturn :: a -> Set a setReturn = singleton setBind :: (Ord b) => Set a -> (a -> Set b) -> Set b setBind set f = foldl type SetM r a = ContT r Set a fromSet :: (Ord r) => Set a -> SetM r a fromSet = ContT . setBind toSet :: SetM r r -> Set r toSet c = runContT c setReturn
step :: (Ord r) => Int -> SetM r Int step i = fromSet $ fromList [i, i + 1] -- repeated application of step: stepN :: Int -> Int -> Set Int stepN times start = toSet $ foldrM ($) start (replicate times step)
[0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5]
(...(return 0 >>= step) >>= step) >>= step) >>= ...)
m >>= k = ContT $ \c -> runContT m (\a -> runContT (k a) c)
setReturn 0 `setBind` (\x1 -> step x1 `setBind` (\x2 -> step x2 `setBind` (\x3 -> ...)...)
{- module SetMonadOpt where import qualified Data.Set as S import Control.Monad data SetMonad a where SMOrd :: Ord a => S.Set a -> SetMonad a SMAny :: [a] -> SetMonad a instance Monad SetMonad where return x = SMAny [x] m >>= f = collect . map f $ toList m toList :: SetMonad a -> [a] toList (SMOrd x) = S.toList x toList (SMAny x) = x collect :: [SetMonad a] -> SetMonad a collect [] = SMAny [] collect [x] = x collect ((SMOrd x):t) = case collect t of SMOrd y -> SMOrd (S.union x y) SMAny y -> SMOrd (S.union x (S.fromList y)) collect ((SMAny x):t) = case collect t of SMOrd y -> SMOrd (S.union y (S.fromList x)) SMAny y -> SMAny (x ++ y) runSet :: Ord a => SetMonad a -> S.Set a runSet (SMOrd x) = x runSet (SMAny x) = S.fromList x instance MonadPlus SetMonad where mzero = SMAny [] mplus (SMAny x) (SMAny y) = SMAny (x ++ y) mplus (SMAny x) (SMOrd y) = SMOrd (S.union y (S.fromList x)) mplus (SMOrd x) (SMAny y) = SMOrd (S.union x (S.fromList y)) mplus (SMOrd x) (SMOrd y) = SMOrd (S.union x y) choose :: MonadPlus m => [a] -> m a choose = msum . map return test1 = runSet (do n1 <- choose [1..5] n2 <- choose [1..5] let n = n1 + n2 guard $ n < 7 return n) -- fromList [2,3,4,5,6] -- Values to choose from might be higher-order or actions test1 n1 <- choose . map return $ [1..5] n2 <- choose . map return $ [1..5] n <- liftM2 (+) n1 n2 guard $ n < 7 return n) -- fromList [2,3,4,5,6] test2 = runSet (do i <- choose [1..10] j <- choose [1..10] k <- choose [1..10] guard $ i*i + j*j == k * k return (i,j,k)) -- fromList [(3,4,5),(4,3,5),(6,8,10),(8,6,10)] test3 = runSet (do i <- choose [1..10] j <- choose [1..10] k <- choose [1..10] guard $ i*i + j*j == k * k return k) -- fromList [5,10] -- Test by Petr Pudlak -- First, general, unoptimal case step :: (MonadPlus m) => Int -> m Int step i = choose [i, i + 1] -- repeated application of step on 0: stepN :: Int -> S.Set Int stepN = runSet . f where f 0 = return 0 f n = f (n-1) >>= step -- it works, but clearly exponential {- *SetMonad> stepN 14 fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] (0.09 secs, 31465384 bytes) *SetMonad> stepN 15 fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] (0.18 secs, 62421208 bytes) *SetMonad> stepN 16 fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] (0.35 secs, 124876704 bytes) -} -- And now the optimization chooseOrd :: Ord a => [a] -> SetMonad a chooseOrd x = SMOrd (S.fromList x) stepOpt :: Int -> SetMonad Int stepOpt i = chooseOrd [i, i + 1] -- repeated application of step on 0: stepNOpt :: Int -> S.Set Int stepNOpt = runSet . f where f 0 = return 0 f n = f (n-1) >>= stepOpt {- stepNOpt 14 fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] (0.00 secs, 515792 bytes) stepNOpt 15 fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] (0.00 secs, 515680 bytes) stepNOpt 16 fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] (0.00 secs, 515656 bytes) stepNOpt 30 fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30] (0.00 secs, 1068856 bytes) -}
smash :: (Ord r, Ord k) => SetM r r -> SetM k r smash = fromSet . toSet
{- {- {- import qualified Data.Foldable as F import qualified Data.Set as S import Prelude hiding (Monad(..), Functor(..)) class CFunctor m where -- Each instance defines a constraint it valust must satisfy: type Constraint m a -- The default is no constraints. type Constraint m a = () fmap :: (Constraint m a, Constraint m b) => (a -> b) -> (m a -> m b) class CFunctor m => CMonad (m :: * -> *) where return :: (Constraint m a) => a -> m a (>>=) :: (Constraint m a, Constraint m b) => m a -> (a -> m b) -> m b fail :: String -> m a fail = error -- [] instance instance CFunctor [] where fmap = map instance CMonad [] where return = (: []) (>>=) = flip concatMap -- Set instance instance CFunctor S.Set where -- Sets need Ord. type Constraint S.Set a = Ord a fmap = S.map instance CMonad S.Set where return = S.singleton (>>=) = flip F.foldMap -- Example: -- prints fromList [3,4,5] main = print $ do x <- S.fromList [1,2] y <- S.fromList [2,3] return $ x + y
indices = let index = getStdRandom $ randomR (0, number_of_peers - 1) in sequence $ replicate 10 index
indices = let index = getStdRandom $ randomR (0, M.size active - 1) in sequence $ replicate (n * 2) index
newtype Dual f a = Dual {dual :: forall r. f(a -> r)->r}
W(a) = ∀r.F(a->r)->r W(f) = F(f∗)∗ where g∗(h) = h∘g
class Functor f => Fibration f where projection :: ∀r. f(r)->r some_section :: ∀r. r->f(r) -- _any_ section will work to :: forall f a. Fibration f => (∀r.f(a->r) -> r) -> (∀r.f(r)->r, a) to(f) = ( f . fmap const , f(some_section(id))) from :: forall f a. Fibration f => (∀r.f(r)->r, a) -> (∀r.f(a->r) -> r) from (π,η) = ev(η) . π ev :: a -> (a->b) -> b ev x f = f x
a ^ | ε | a+a+a ^ | ^ Wε | |δ | εW | v | (a+a+a)+(a+a+a)+(a+a+a)
-- ghc/libraries/ghc-prim/GHC/Types.hs newtype IO a = IO (State
{- {- import Control.Comonad class Functor f => Fibration f where x0 :: f () x0 = some_section () some_section :: forall r. r -> f(r) some_section x = fmap (const x) x0 projection :: forall r. f(r) -> r newtype W f a = W { un_w :: forall r. f(a->r)->r } instance Functor f => Functor (W f) where fmap f (W c) = W $ c . fmap (. f) instance Fibration f => Comonad (W f) where extract = ε duplicate = δ -- The counit is determined uniquely, independently of the choice of a particular section. ε :: forall f a. Fibration f => W f a -> a ε (W f) = f (some_section id) -- The comultiplication is unique too. δ :: forall f a. Fibration f => W f a -> W f (W f a) δ f = W $ ev(f) . un_w f . fmap const ev :: forall a b. a -> (a->b)->b ev x f = f x -- An Example data Pair a = P {p1 ::a ,p2 :: a } deriving (Eq,Show) instance Functor Pair where fmap f (P x y) = P (f x) (f y) instance Fibration Pair where x0 = P () () projection = p1 type PairCover a = W Pair a -- How to construct a cover (you will need unsafePerformIO if you want W IO.) cover :: a -> W Pair a cover x = W $ ev(x) . p1
class IFunctor f where ifmap :: (a -> b) -> f n a -> f n b
data IEither a n b where ILeft :: a -> IEither a Z b IRight :: b -> IEither a (S n) b
instance IFunctor (IEither a) where ifmap _ l@(ILeft _) = l ifmap f (IRight r) = IRight $ f r
mymain :: IO () mymain = do myData <- getMyData ... ...
class LeN (m :: Nat) (n :: Nat) where instance LeN Z n where instance LeN m n => LeN (S m) (S n) where
data OWOTO :: Nat -> Nat -> * where LE :: LeN x y => OWOTO x y GE :: LeN y x => OWOTO x y
data Natty :: Nat -> * where Zy :: Natty Z Sy :: Natty n -> Natty (S n)
owoto :: forall m n. Natty m -> Natty n -> OWOTO m n owoto Zy n = LE owoto (Sy m) Zy = GE owoto (Sy m) (Sy n) = case owoto m n of LE -> LE GE -> GE
data Bound x = Bot | Val x | Top deriving (Show, Eq, Ord)
class LeB (a :: Bound Nat)(b :: Bound Nat) where instance LeB Bot b where instance LeN x y => LeB (Val x) (Val y) where instance LeB (Val x) Top where instance LeB Top Top where
data OList :: Bound Nat -> Bound Nat -> * where ONil :: LeB l u => OList l u (:<) :: forall l x u. LeB l (Val x) => Natty x -> OList (Val x) u -> OList l u
merge :: OList l u -> OList l u -> OList l u merge ONil lu = lu merge lu ONil = lu merge (x :< xu) (y :< yu) = case owoto x y of LE -> x :< merge xu (y :< yu) GE -> y :< merge (x :< xu) yu
data NATTY :: * where Nat :: Natty n -> NATTY natty :: Nat -> NATTY natty Z = Nat Zy natty (S n) = case natty n of Nat n -> Nat (Sy n)
deal :: [x] -> ([x], [x]) deal [] = ([], []) deal (x : xs) = (x : zs, ys) where (ys, zs) = deal xs sort :: [Nat] -> OList Bot Top sort [] = ONil sort [n] = case natty n of Nat n -> n :< ONil sort xs = merge (sort ys) (sort zs) where (ys, zs) = deal xs
instance Show (Natty n) where show Zy = "Zy" show (Sy n) = "(Sy " ++ show n ++ ")" instance Show (OList l u) where show ONil = "ONil" show (x :< xs) = show x ++ " :< " ++ show xs ni :: Int -> Nat ni 0 = Z ni x = S (ni (x - 1))
module Sorted (Sorted, sort) where newtype Sorted a = Sorted { list :: [a] } sort :: [a] -> Sorted a sort = Sorted . List.sort
$ ghci GHCi, version 7.0.3: http: Prelude> import System.Environment Prelude System.Environment> let main = getArgs >>= mapM_ putStrLn Prelude System.Environment> withArgs ["hello", "world"] main hello world
data CoinType = Fair | Biased deriving (Show) data Coin = Head | Tail deriving (Eq,Show)
toss Fair = [Head, Tail] toss Biased = [Head, Head]
experiment = do coin <- pick -- Pick a coin at random result <- toss coin -- Toss it, to get a result guard (result == Head) -- We only care about results that come up Heads return coin -- Return which coin was used in this case
> v <- newIORef 0 > readIORef v 0 > writeIORef v 7 > readIORef v 7
inc n = n + 1 f = inc 0 g = inc 1 main = print (f+g)
doubleMe [] = [] doubleMe (x:xs) = (2*x):(doubleMe xs)
case doubleMe [a,b,c] of [] -> [] (x:xs) -> (2*x):(doubleMe xs)
case (2*a):(doubleMe [b,c]) of [] -> [] (x:xs) -> (2*x):(doubleMe xs)
doubleMe (...) doubleMe ( { [] | (_:_) }? ) doubleMe ( doubleMe (...)! )
doubleMe ( doubleMe (...) ) doubleMe ( doubleMe( { [] | (_:_) }? ) ) doubleMe ( doubleMe( a:_ ! ) ) doubleMe ( (2*a) : doubleMe(_) ) doubleMe ( (2*a):_ ! )
tail( { [] | (_:_) }? ) tail( doubleMe(...)! ) tail( doubleMe ( { [] | (_:_) }? ) ) ... tail( doubleMe ( doubleMe( a:_ ! ) ) ) tail( doubleMe ( _:_ ) ) tail( _ : doubleMe ( _ ) ) doubleMe ( ... )
let pair :: (Int,Int) pair = (1, fst pair) in snd pair
snd pair = -- definition of pair snd (1, fst pair) = -- application of snd fst pair = -- definition of pair fst (1, fst pair) = -- application of fst 1
snd pair = -- definition of pair snd (1, fst pair) = -- must evaluate arguments before application, expand pair again snd (1, fst (1, fst pair)) = -- must evaluate arguments snd (1, fst (1, fst (1, fst pair))) = -- must evaluate arguments ...
d [] = [] -- Rule 1 d (x:xs) = (2*x) : d xs -- Rule 2 d [1, 2, 3] = d (1:2:3:[]) = (2*1) : d (2:3:[]) -- Rule 2 = 2 : d (2:3:[]) -- Reduce = 2 : (2*2) : d (3:[]) -- Rule 2 = 2 : 4 : d (3:[]) -- Reduce = 2 : 4 : (2*3) : d [] -- Rule 2 = 2 : 4 : 6 : d [] -- Reduce = 2 : 4 : 6 : [] -- Rule 1 = [2, 4, 6]
d (d [1, 2, 3]) = d (d (1:2:3:[])) = d ((2*1) : d (2:3:[])) -- Rule 2 (inner) = d (2 : d (2:3:[])) -- Reduce = (2*2) : d (d (2:3:[])) -- Rule 2 (outer) = 4 : d (d (2:3:[])) -- Reduce = 4 : d ((2*2) : d (3:[])) -- Rule 2 (inner) = 4 : d (4 : d (3:[])) -- Reduce = 4 : 8 : d (d (3:[])) -- Rule 2 (outer) / Reduce = 4 : 8 : d (6 : d []) -- Rule 2 (inner) / Reduce = 4 : 8 : 12 : d (d []) -- Rule 2 (outer) / Reduce = 4 : 8 : 12 : d [] -- Rule 1 (inner) = 4 : 8 : 12 : [] -- Rule 1 (outer) = [4, 8, 12]
d (d [1, 2, 3]) = d (d (1:2:3:[])) = d ((2*1) : d (2:3:[])) = (2*(2*1)) : d (d (2:3:[])) = -- Rest of the steps left as an exercise for the reader = (2*(2*1)) : (2*(2*2)) : (2*(2*3)) : [] = (2*2) : (2*4) : (2*6) : [] = 4 : 6 : 12 : [] = [4, 6, 12]
doubleMe [] = [] doubleMe (x:xs) = (2*x):(doubleMe xs) doubleMe (doubleMe [a,b,c])
-- Let -- ("Forcing" = demanding that the expression be evaluated only just enough -- to pattern match on its data constructor.) doubleMe (doubleMe [a,b,c]) -- The argument to the outer `doubleMe` is not headed by a constructor, -- so we must force the inner application of `doubleMe`. To do that, -- first force its argument to make it explicitly headed by a -- constructor. = doubleMe (doubleMe (a:[b,c])) -- Now that the argument has been forced we can tell which of the two -- `doubleMe` equations applies to it: the second one. So we use that -- to rewrite it. = doubleMe (2*a : doubleMe [b,c]) -- Since the argument to the outer `doubleMe` in the previous expression -- is headed by the list constructor `:`, we -- Now we use the second `doubleMe` equation to rewrite the outer -- function application. = 2*2*a : doubleMe (doubleMe [b, c]) -- And now we -- is a data constructor (`:`). This means that we -- forced the expression, and can stop here. There wouldn -- further evaluation unless some consumer tried to match either of -- the two subexpressions of this result.
fib n | n == 0 = 0 | n == 1 = 1 | n > 1 = fib (n-1) + fib (n-2) print fib 5
[1 of 1] Compiling Main ( test.hs, test.o ) test.hs:8:1: Parse error: naked expression at top level
codata HList : Type -> Type where Nil : HList a Cons : a -> HList a -> HList a
filter : {A : Set} -> (A -> Bool) -> Stream A -> Stream A filter f xs with f (head xs) ... | true = head xs :: filter f (tail xs) ... | false = filter f (tail xs) -- unguarded recursion
Prelude> :set -XTypeSynonymInstances Prelude> instance Num String where (+) = (++) <interactive>:3:10: Illegal instance declaration for `Num String' (All instance types must be of the form (T a1 ... an) where a1 ... an are *distinct type variables*, and each type variable appears at most once in the instance head. Use -XFlexibleInstances if you want to disable this.) In the instance declaration for `Num String'
Prelude> :set -XFlexibleInstances Prelude> instance Num String where (+) = (++) ... errors about undefined methods ... Prelude> "a" + "b" "ab"
Prelude> instance Eq String where Prelude> "a" == "b" <interactive>:8:5: Overlapping instances for Eq [Char] arising from a use of `==' Matching instances: instance Eq a => Eq [a] -- Defined in `GHC.Classes' instance Eq String -- Defined at <interactive>:7:10 In the expression: "a" == "b" In an equation for `it
data Point2 = Point2 {x :: Float, y :: Float} data Point3 = Point3 {x :: Float, y :: Float, z :: Float}
(define (if2 cond x y) (if cond x y)) (define (spin n) (if (= n 0) (void) (spin (- n 1))))
if if if spin : Nat -> () spin Z = () spin (S n) = spin n
Idris> \n, m => (S n) + m \n => \m => S (plus n m) : Nat -> Nat -> Nat Idris> \n, m => n + (S m) \n => \m => plus n (S m) : Nat -> Nat -> Nat
using namespace std; int addition (int a, int b) { int r; r=a+b; return (r); } int main () { int z; z = addition (5,3); cout << "The result is " << z; return 0; }
module Main where addition a b = a + b main :: IO () main = do let z = addition 5 3 putStrLn $ "The result is: " ++ show z
module Blarg (exportedFunction) where helper a b = ... -- this will *not* be exported exportedFunction a b = helper a b -- this *will* be exported
complicatedFunction a b c = helper 0 where helper count = ...
class Functor f where fmap :: (a -> b) -> f a -> f b class Functor f => Pointed f where pure :: a -> f a class Pointed f => Applicative f where (<*>) :: f (a -> b) -> f a -> f b class Applicative m => Monad m where -- either the traditional bind operation (>>=) :: (m a) -> (a -> m b) -> m b -- or the join operation, which together with fmap is enough join :: m (m a) -> m a -- or both with mutual default definitions f >>= x = join ((fmap f) x) join x = x >>= id -- with return replaced by the inherited pure -- ignoring fail for the purposes of discussion
liftA :: (Applicative f) => (a -> b) -> f a -> f b liftM :: (Monad m) => (a -> b) -> m a -> m b
(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b ap :: (Monad m) => m (a -> b) -> m a -> m b
instance Applicative [] where (f:fs) <*> (x:xs) = f x : fs <*> xs _ <*> _ = [] pure = repeat
filepathNormalise :: BS.ByteString -> BS.ByteString filepathNormalise xs | isWindows, Just (a,xs) <- BS.uncons xs, sep a, Just (b,_) <- BS.uncons xs, sep b =
guards → | guard1, …, guardn (n ≥ 1) guard → pat <- infixexp (pattern guard) | let decls (local declaration) | infixexp (boolean guard)
import Graphics.Rendering.Chart.Simple main = plotWindow [0,0.1..5::Double] sin
test_graph2 = do plot (ts,[point (ds,es) (Cross,red),line fs blue]) title "Testing plot package:" subtitle "with 1 second of a 15Hz sine wave" xlabel "time (s)" ylabel "amplitude" yrange Linear (-1.25) 1.25
cabal install gnuplot sudo apt-get install gnuplot-x11 ghci GHCi, version 7.4.1: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. h> import Graphics.Gnuplot.Simple h> plotFunc [] (linearScale 1000 (-20,20)) (\x -> sin x / x)
import Graphics.Matplotlib plotQuadraticFn :: IO () plotQuadraticFn = onscreen $ plot x y where x = [-10..10] y = fmap (**2) x
counter :: ArrowCircuit a => a Bool Int counter = proc reset -> do rec output <- returnA -< if reset then 0 else next next <- delay 0 -< output+1 returnA -< output
rec output <- returnA -< if reset then 0 else next next <- delay 0 -< output+1
-- Monadic classes class Functor f where map :: (a -> b) -> f a -> f b class Monad m where (>>=) :: m a -> (a -> m b) -> m b (>>) :: m a -> m b -> m b return :: a -> m a m >> k = m >>= \_ -> k class (Monad m) => MonadZero m where zero :: m a class (MonadZero m) => MonadPlus m where (++) :: m a -> m a -> m a
-- Monadic classes class Functor f where fmap :: (a -> b) -> f a -> f b class Monad m where (>>=) :: m a -> (a -> m b) -> m b (>>) :: m a -> m b -> m b return :: a -> m a fail :: String -> m a -- Minimal complete definition: -- (>>=), return m >> k = m >>= \_ -> k fail s = error s
{- module M where class C a b | a -> b where f :: a -> b instance C a b => C [a] [b] where f = map f
Context reduction stack overflow; size = 201 Use -fcontext-stack=N to increase stack size to N C [b] b In the second argument of `(+) In the expression: x + f [x] In an equation for `g
Prelude Data.Number.CReal> let cx = 1 + sqrt (3 :: CReal) Prelude Data.Number.CReal> showCReal 400 cx "2.7320508075688772935274463415058723669428052538103806280558069794519330169088000370811461867572485756756261414154067030299699450949989524788116555120943736485280932319023055820679748201010846749232650153123432669033228866506722546689218379712270471316603678615880190499865373798593894676503475065760507566183481296061009476021871903250831458295239598329977898245082887144638329173472241639845878553977"
-- hanoi for n disks and r pegs [p1, p2, ..., pr] hanoiR :: Int -> [a] -> [(a, a)] -- zero disks: no moves needed. hanoiR 0 _ = [] -- one disk: one move and two pegs needed. hanoiR 1 (p1 : p2 : rest) = [(p1, p2)] -- only needed for smart-alecks? {- -- n disks and 3 pegs -- unneeded; covered by (null rest) below. hanoiR n [p1, p2, p3] = hanoiR (n - 1) [p1, p3, p2] ++ [(p1, p2)] ++ hanoiR (n - 1) [p3, p2, p1] -} -- n disks and r > 3 pegs: use Frame-Stewart algorithm hanoiR n (p1 : p2 : p3 : rest) = hanoiR k (p1 : p3 : p2 : rest) ++ hanoiR (n - k) (p1 : p2 : rest) ++ hanoiR k (p3 : p2 : p1 : rest) where k | null rest = n - 1 | otherwise = n `quot` 2
[(1,2),(1,3),(2,3),(1,4),(1,2),(4,2),(3,1),(3,2),(1,2)]
hanoiR k (p1 : (p3 : (p2 : rest))) ++ -- step 1; corresponds to T(k,r) hanoiR (n-k) (p1 : (p2 : rest)) ++ -- step 2; corresponds to T(n-k, r-1) hanoiR k (p3 : (p2 : (p1 : rest))) -- step 3; corresponds to T(k,r)
Prelude> id :: (forall a. a -> a) -> (forall b. b -> b) <interactive>:1:1: Couldn with actual type `forall a. a -> a' Expected type: (forall a. a -> a) -> b -> b Actual type: (forall a. a -> a) -> forall a. a -> a In the expression: id :: (forall a. a -> a) -> (forall b. b -> b) In an equation for `it it = id :: (forall a. a -> a) -> (forall b. b -> b)
restrictedId :: (forall a. a -> a) -> (forall b. b -> b) restrictedId x = x
restrictedId :: (forall a. a -> a) -> (forall b. b -> b) restrictedId = id -- Similar error to above
GHCi, version 7.4.2: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Prelude>
.... .... .... Loading package vector-0.10.0.1 ... linking ... done. Loading package zlib-0.5.4.0 ... linking ... done. Loading package zlib-bindings-0.1.1.3 ... linking ... done. Loading package zlib-enum-0.2.3 ... linking ... done. Loading package snap-core-0.9.3.1 ... linking ... done. Loading package snap-server-0.9.3.3 ... linking ... done. Loading package directory-tree-0.11.0 ... linking ... done. cabal: Error: some packages failed to install: snap-0.11.2 failed during the building phase. The exception was: ExitFailure 11
$ brew search haskell haskell-platform $ brew install haskell-platform ==> Installing haskell-platform dependency: ghc ==> Downloading https: ==> Pouring ghc-7.4.2.lion.bottle.1.tar.gz ==> Caveats This brew is for GHC only; you might also be interested in haskell-platform. ==> Summary 🍺 /usr/local/Cellar/ghc/7.4.2: 5176 files, 767M ==> Installing haskell-platform ==> Downloading http: ==> ./configure --prefix=/usr/local/Cellar/haskell-platform/2012.4.0.0 --enable-unsupported-ghc-version ==> make install ==> Caveats Run `cabal update` to initialize the package list. If you are replacing a previous version of haskell-platform, you may want to unregister packages belonging to the old version. You can find broken packages using: ghc-pkg check --simple-output You can uninstall them using: ghc-pkg check --simple-output | xargs -n 1 ghc-pkg unregister --force ==> Summary 🍺 /usr/local/Cellar/haskell-platform/2012.4.0.0: 952 files, 208M, built in 15.3 minutes
$ ghc ghc: no input files Usage: For basic information, try the `--help
$ ghci GHCi, version 7.4.2: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Prelude> putStrLn "Hello World" Hello World Prelude> Leaving GHCi.
> $ brew install ghc cabal-install ==> Downloading https: ==> Pouring ghc-7.10.1_1.yosemite.bottle.tar.gz 🍺 /usr/local/Cellar/ghc/7.10.1_1: 5423 files, 821M ==> Downloading https: ==> Pouring cabal-install-1.22.2.0.yosemite.bottle.1.tar.gz ==> Caveats Bash completion has been installed to: /usr/local/etc/bash_completion.d ==> Summary 🍺 /usr/local/Cellar/cabal-install/1.22.2.0: 6 files, 19M
$ brew update $ brew install haskell-stack $ stack --version $ stack --help $ stack setup $ stack ghci
printStringNTimes 0 = return () printStringNTimes n = do putStrLn "a string" printStringNTimes (n-1) main = printStringNTimes 10
repeatNTimes 0 _ = return () repeatNTimes n action = do action repeatNTimes (n-1) action main = repeatNTimes 10 (putStrLn "a string")
main = do putStr result where string = "a string" result = concat [string ++ "\n" | i <- [1,2..10]]
def foo(x,y): x = f(x) if a(x) if c(x): x = g(x) else: x = h(x) x = f(x) y = f(y) if a(y) x = g(x) if b(y) return [x,y]
foo x0 y0 = let x1 = if a x0 then f x0 else x0 in let x2 = if c x1 then g x1 else h x1 in let x3 = f x2 in let y1 = if a y0 then f y0 else y0 in let x4 = if b y1 then g x3 else x3 in [x4,y1]
fooSt x y = execState (do (x,y) <- get when (a x) (put (f x, y)) (x,y) <- get if c x then put (g x, y) else put (h x, y) (x,y) <- get put (f x, y) (x,y) <- get when (a y) (put (x, f y)) (x,y) <- get when (b y) (put (g x, x))) (x,y)
do x <- return $ if somePredicate x then g x else h x x <- return $ if someOtherPredicate x then a x else b x
foo x y = runIdentity $ do x <- return $ if a x then f x else x x <- return $ if c x then g x else h x x <- return $ f x y <- return $ if a x then f y else y x <- return $ if b y then g x else y return (x,y)
condM :: Monad m => Bool -> a -> a -> m a condM p a b = return $ if p then a else b
foo x y = runIdentity $ do x <- condM (a x) (f x) x x <- fmap f $ condM (c x) (g x) (h x) y <- condM (a y) (f y) y x <- condM (b y) (g x) x return (x , y)
(?) :: Bool -> (a, a) -> a b ? ie = if b then fst ie else snd ie (??) :: Monad m => Bool -> (a, a) -> m a (??) p = return . (?) p ( ( infixr 2 ?? infixr 2 # infixr 2 ? foo x y = runIdentity $ do x <- a x ?? f x x <- fmap f $ c x ?? g x y <- a y ?? f y x <- b y ?? g x return (x , y)
foo x y = runIdentity $ a x ?? f x c x ?? g x return (f x) >>= \x -> a y ?? f y b y ?? g x return (x , y)
($>) :: a -> (a -> b) -> b ($>) = flip ($) infixr 0 $> -- same infix as ($) foo x y = a x ? f x c x ? g x f x $> \x -> a y ? f y b y ? g x (x, y)
import Control.Arrow if if foo2 :: (Int,Int) -> (Int,Int) foo2 = first (if first f >>> second (if (\(x,y) -> (if b y then g x else x , y))
import Control.Applicative (liftA3) -- a functional if for lifting if if if
foo x y = ( x where x y af z = (if a z then f else id) z cgh z = (if c z then g else h) z bg y x = (if b y then g else id) x
whenM :: Monad m => m Bool -> m () -> m () whenM c a = c >>= \res -> when res a ifM :: Monad m => m Bool -> m a -> m a -> m a ifM mb ml mr = mb >>= \b -> if b then ml else mr foo :: Int -> Int -> (Int, Int) foo = curry . execState $ do whenM (uses _1 a) $ _1 %= f ifM (uses _1 c) (_1 %= g) (_1 %= h) _1 %= f whenM (uses _2 a) $ _2 %= f whenM (uses _2 b) $ do _1 %= g
foo :: Int -> Int -> (Int, Int) foo = curry . execState $ do let x :: Lens (a, c) (b, c) a b x = _1 y :: Lens (c, a) (c, b) a b y = _2 whenM (uses x a) $ x %= f ifM (uses x c) (x %= g) (x %= h) x %= f whenM (uses y a) $ y %= f whenM (uses y b) $ do x %= g
-- STRef assignment. (=:) :: STRef s a -> ST s a -> ST s () ref =: x = writeSTRef ref =<< x -- STRef function application. ($:) :: (a -> b) -> STRef s a -> ST s b f $: ref = f `fmap` readSTRef ref -- Postfix guard syntax. if_ :: Monad m => m () -> m Bool -> m () action `if_` guard = act where act else return ()
a = (< 10) b = even c = odd f x = x + 3 g x = x * 2 h x = x - 1 f3 x = x + 2 -- A stateful computation that takes two integer STRefs and result in a final [x,y]. fooST :: Integral n => STRef s n -> STRef s n -> ST s [n] fooST x y = do x =: (f $: x) `if_` (a $: x) x if c x x =: (g $: x) else x =: (h $: x) x =: (f $: x) y =: (f $: y) `if_` (a $: y) x =: (g $: x) `if_` (b $: y) sequence [readSTRef x, readSTRef y] -- Pure wrapper: simply call fooST with two fresh references, and run it. foo :: Integral n => n -> n -> [n] foo x y = runST $ do x y fooST x -- This will print "[9,3]". main = print (foo 0 0)
foo x0 y0 = let x1 = if a x0 then f x0 else x0 in let x2 = if c x1 then g x1 else h x1 in let x3 = f x2 in let y1 = if a y0 then f y0 else y0 in let x4 = if b y1 then g x3 else x3 in [x4,y1]
foo x y = let x_bar = if a x then f x else x x_baz = f if c x_bar then g x_bar else h x_bar y_bar = if a y then f y else y x_there = if b y_bar then g x_baz else x_baz in [x_there, y_bar]
foo x y = let x_bar = f_if_a x y_bar = f_if_a y x_baz = f (g_if_c_else_h x_bar) x_there = g_if_b x_baz y_bar in [x_there, y_bar] where f_if_a x | a x = f x | otherwise = x g_if_c_else_h x | c x = g x | otherwise = h x g_if_b x y | b y = g x | otherwise = x
import Control.Monad.Trans.Class import Control.Monad.Trans.State foo :: x -> y -> (x, y) foo x y = (flip runState) y $ (flip execStateT) x $ do get >>= \v -> when (a v) (put (f v)) get >>= \v -> put ((if c v then g else h) v) modify f lift $ get >>= \v -> when (a v) (put (f v)) lift get >>= \v -> when (b v) (modify g)
{- instance Num (Integer -> Integer) where fromInteger n = \scale -> n * scale -- return a function that takes -- a number and returns a number
seconds, minutes, hours, days :: Integer seconds = 1000000 -- base unit, e.g. microseconds minutes = 60 seconds hours = 60 minutes days = 24 hours soon :: Integer soon = 2 hours + 4 seconds
newtype TimeUnit = TimeUnit Integer deriving (Eq, Show, Num) instance Num (TimeUnit -> TimeUnit) where fromInteger n = \(TimeUnit scale) -> TimeUnit (n * scale) seconds, minutes, hours, days :: TimeUnit seconds = TimeUnit 1000000 minutes = 60 seconds hours = 60 minutes days = 24 hours
allTheSame :: (Eq a) => [a] -> Bool allTheSame xs = and $ map (== head xs) (tail xs)
allTheSame allTheSame | n == 0 = False | n == 1 = True | n == 2 = xs !! 0 == xs !! 1 | otherwise = (xs !! 0 == xs !! 1) && (allTheSame where n = length xs
allTheSame allTheSame | n == 0 = False | n == 1 = True | n == 2 = xs !! 0 == xs !! 1 | n == 3 = xs !! 0 == xs !! 1 && xs !! 1 == xs !! 2 | otherwise = allTheSame where n = length xs split = splitAt (n `div` 2) xs
and [] = True and (x:xs) = x && and xs map f [] = [] map f (x:xs) = f x : map f xs True && x = x False && x = False
allTheSame [7,7,7,7,8,7,7,7] allTheSame (7:7:7:7:8:7:7:7:[]) and $ map (== head (7:7:7:7:8:7:7:7:[])) (tail (7:7:7:7:8:7:7:7:[])) and $ map (== 7) (tail (7:7:7:7:8:7:7:7:[])) and $ map (== 7) (7:7:7:8:7:7:7:[]) and $ (== 7) 7 : map (== 7) (7:7:8:7:7:7:[]) (== 7) 7 && and (map (== 7) (7:7:8:7:7:7:[])) True && and (map (== 7) (7:7:8:7:7:7:[])) and (map (== 7) (7:7:8:7:7:7:[])) (== 7) 7 && and (map (== 7) (7:8:7:7:7:[])) True && and (map (== 7) (7:8:7:7:7:[])) and (map (== 7) (7:8:7:7:7:[])) (== 7) 7 && and (map (== 7) (8:7:7:7:[])) True && and (map (== 7) (8:7:7:7:[])) and (map (== 7) (8:7:7:7:[])) (== 7) 8 && and (map (== 7) (7:7:7:[])) False && and (map (== 7) (7:7:7:[])) False
allTheSame :: (Eq a) => [a] -> Bool allTheSame xs = and $ map (== head xs) (tail xs)
Test.allTheSame :: forall a_abG. GHC.Classes.Eq a_abG => [a_abG] -> GHC.Bool.Bool [GblId, Arity=2, Str=DmdType LS, Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True, ConLike=True, Cheap=True, Expandable=True, Guidance=IF_ARGS [3 3] 16 0}] Test.allTheSame = \ (@ a_awM) ($dEq_awN :: GHC.Classes.Eq a_awM) (xs_abH :: [a_awM]) -> case xs_abH of _ { [] -> GHC.List.tail1 `cast` (CoUnsafe (forall a1_axH. [a1_axH]) GHC.Bool.Bool :: (forall a1_axH. [a1_axH]) ~ GHC.Bool.Bool); : ds1_axJ xs1_axK -> letrec { go_sDv [Occ=LoopBreaker] :: [a_awM] -> GHC.Bool.Bool [LclId, Arity=1, Str=DmdType S] go_sDv = \ (ds_azk :: [a_awM]) -> case ds_azk of _ { [] -> GHC.Bool.True; : y_azp ys_azq -> case GHC.Classes.== @ a_awM $dEq_awN y_azp ds1_axJ of _ { GHC.Bool.False -> GHC.Bool.False; GHC.Bool.True -> go_sDv ys_azq } }; } in go_sDv xs1_axK }
Test.allTheSame' :: forall a_abF. GHC.Classes.Eq a_abF => [a_abF] -> GHC.Bool.Bool [GblId, Arity=2, Str=DmdType LS, Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True, ConLike=True, Cheap=True, Expandable=True, Guidance=IF_ARGS [3 3] 20 0}] Test.allTheSame \ (@ a_awF) ($dEq_awG :: GHC.Classes.Eq a_awF) (xs_abI :: [a_awF]) -> case GHC.List.$wlen @ a_awF xs_abI 0 of ww_aC6 { __DEFAULT -> case GHC.List.$wlen @ a_awF (GHC.List.takeWhile @ a_awF (let { ds_sDq :: a_awF [LclId, Str=DmdType] ds_sDq = case xs_abI of _ { [] -> GHC.List.badHead @ a_awF; : x_axk ds1_axl -> x_axk } } in \ (ds1_dxa :: a_awF) -> GHC.Classes.== @ a_awF $dEq_awG ds1_dxa ds_sDq) xs_abI) 0 of ww1_XCn { __DEFAULT -> GHC.Prim.== } }
case GHC.List.$wlen @ a_awF xs_abI 0 of ww_aC6 { __DEFAULT -> case GHC.List.$wlen
allTheSame allTheSame | n == 0 = False | n == 1 = True | n == 2 = xs !! 0 == xs !! 1 | otherwise = (xs !! 0 == xs !! 1) && (allTheSame where n = length xs
allTheSame allTheSame | n == 0 = False | n == 1 = True | n == 2 = xs !! 0 == xs !! 1 | n == 3 = xs !! 0 == xs !! 1 && xs !! 1 == xs !! 2 | otherwise = allTheSame where n = length xs split = splitAt (n `div` 2) xs
Test.allTheSame :: forall a_abC. GHC.Classes.Eq a_abC => [a_abC] -> GHC.Bool.Bool [GblId, Arity=2, Str=DmdType LS, Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True, ConLike=True, Cheap=True, Expandable=True, Guidance=IF_ARGS [3 3] 10 0}] Test.allTheSame \ (@ a_am5) ($dEq_am6 :: GHC.Classes.Eq a_am5) (xs_alK :: [a_am5]) -> case xs_alK of _ { [] -> GHC.List.tail1 `cast` (CoUnsafe (forall a1_axH. [a1_axH]) GHC.Bool.Bool :: (forall a1_axH. [a1_axH]) ~ GHC.Bool.Bool); : ds1_axJ xs1_axK -> GHC.List.all @ a_am5 (\ (ds_dwU :: a_am5) -> GHC.Classes.== @ a_am5 $dEq_am6 ds_dwU ds1_axJ) xs1_axK }
main = do print $ allTheSame (replicate 100000000 1)
{- allTheSame [] = True allTheSame ((!x):xs) = go x xs where go !x [] = True go !x (!y:ys) = (x == y) && (go x ys)
allTheSame [] = True allTheSame (x:xs) = isNothing $ find (x /= ) xs
{- allSame :: Eq a => [a] -> Bool allSame xs = foldr go (`seq` True) xs Nothing where go x r Nothing = r (Just x) go x r (Just prev) = x == prev && r (Just x)
allSame [] = True allSame (x : xs) = allSame allSame allSame
allSame :: forall a. Eq a => [a] -> Bool allSame = \ (@ a) ($dEq_a :: Eq a) (xs0 :: [a]) -> let { equal :: a -> a -> Bool equal = == $dEq_a } in letrec { go :: [a] -> a -> Bool go = \ (xs :: [a]) (prev :: a) -> case xs of _ { [] -> True; : y ys -> case equal y prev of _ { False -> False; True -> go ys y } }; } in case xs0 of _ { [] -> True; : x xs -> go xs x }
allSame xs = foldr go (`seq` True) xs Nothing where go x r Nothing = r (Just x) go x r (Just prev) = x == prev && r (Just x)
replicate k0 a = build $ \c n -> let rep 0 = n rep k = a `c` rep (k - 1) in rep k0
let rep 0 = (`seq` True) rep k = go a (rep (k - 1)) in rep k0 Nothing
let rep 0 acc = acc `seq` True rep k acc = go a (rep (k - 1)) acc in rep k0 Nothing
let rep 0 acc = acc `seq` True rep k Nothing = rep (k - 1) (Just a) rep k (Just prev) = a == prev && rep (k - 1) (Just a) in rep k0 Nothing
let rep 0 acc = acc `seq` True rep k Nothing = rep rep k (Just prev) = a == prev && rep rep rep in rep k0 Nothing
$wfoo :: Int $wfoo = \ (ww_s1bY :: Int case tagToEnum False -> letrec { $sgo_s1db :: Int $sgo_s1db = \ (sc_s1d9 :: Int case tagToEnum False -> False; True -> case tagToEnum False -> $sgo_s1db (+ True -> True } }; } in case ww_s1bY of _ { __DEFAULT -> $sgo_s1db 1 0; 0 -> True }; True -> True } foo :: Int -> Bool foo = \ (w_s1bV :: Int) -> case w_s1bV of _ { I
sameElement x:y:xs = if x /= y then Nothing else sameElement y:xs sameElement [x] = Just x allEqual [] = True allEqual xs = isJust $ sameElement xs
import Data.List (group) allTheSame :: (Eq a) => [a] -> Bool allTheSame = (== 1) . length . group
allSame [ ] = True allSame (h:t) = aux h t aux x1 [ ] = True aux x1 (x2:xs) | x1==x2 = aux x2 xs | otherwise = False
import qualified Data.List result :: [Int] result = Data.List.sort [3,1,2,4]
import qualified Data.List as L result :: [Int] result = L.sort [3,1,2,4]
myFunction arg | arg == 1 = a | arg == 2 = a*b | arg == 3 = b+c | otherwise = (a+b)*c where a = ... b = ... c = ... d = ...
myFunction arg | arg == 1 = a | arg == 2 = a*b | arg == 3 = b+c | otherwise = (a+b)*c where (a,b,c,d) = anotherFunction arg
myFunction arg | arg == 1 = a | arg == 2 = a*b | arg == 3 = b+c | otherwise = (a+b)*c where (a,b,c,d) = anotherFunction arg anotherFunction x = (x, undefined, undefined, undefined)
anotherFunction :: Int -> (Int,Int,Int,Int) anotherFunction x = (z,t,f,g) where f = x*x g = f+x z = g-2 t = 3
anotherFunction n = if p > 1000 then (n, p) else (n, 0) where p = product [1..n]
anotherFunction n = (n, if p > 1000 then p else 0) where p = product [1..n]
Prelude> :set +m Prelude> let anotherFunction = (100, 1 `div` 0) Prelude| Prelude> let myFunction arg Prelude| | arg == 1 = a Prelude| | otherwise = b Prelude| where Prelude| (a, b) = anotherFunction Prelude|
Prelude> myFunction 2 *** Exception: divide by zero
import Data.Array.Repa as Repa r, sigma, k, t, xMax, deltaX, deltaT :: Double m, n, p :: Int r = 0.05 sigma = 0.2 k = 50.0 t = 3.0 m = 3 p = 1 xMax = 150 deltaX = xMax / (fromIntegral m) n = 800 deltaT = t / (fromIntegral n) singleUpdater a = traverse a id f where Z :. m = extent a f _get (Z :. ix) | ix == 0 = 0.0 f _get (Z :. ix) | ix == m-1 = xMax - k f get (Z :. ix) = a * get (Z :. ix-1) + b * get (Z :. ix) + c * get (Z :. ix+1) where a = deltaT * (sigma^2 * (fromIntegral ix)^2 - r * (fromIntegral ix)) / 2 b = 1 - deltaT * (r + sigma^2 * (fromIntegral ix)^2) c = deltaT * (sigma^2 * (fromIntegral ix)^2 + r * (fromIntegral ix)) / 2 priceAtT :: Array U DIM1 Double priceAtT = fromListUnboxed (Z :. m+1) [max 0 (deltaX * (fromIntegral j) - k) | j <- [0..m]] testSingle :: IO (Array U DIM1 Double) testSingle = computeP $ singleUpdater priceAtT
multiUpdater a = fromFunction (extent a) f where f :: DIM2 -> Double f (Z :. ix :. jx) = (singleUpdater x)!(Z :. ix) where x :: Array D DIM1 Double x = slice a (Any :. jx) priceAtTMulti :: Array U DIM2 Double priceAtTMulti = fromListUnboxed (Z :. m+1 :. p+1) [max 0 (deltaX * (fromIntegral j) - k) | j <- [0..m], _l <- [0..p]] testMulti :: IO (Array U DIM2 Double) testMulti = computeP $ multiUpdater priceAtTMulti
bash-3.2$ ghc -fext-core --make Test.hs [1 of 1] Compiling Main ( Test.hs, Test.o ) ghc: panic! (the (GHC version 7.4.1 for x86_64-apple-darwin): MkExternalCore died: make_lit
$ ghc -O2 -rtsopts --make A.hs -threaded [1 of 1] Compiling Main ( A.hs, A.o ) Linking A ...
$ time ./A +RTS -N4 [0.0,0.0,8.4375e-3,8.4375e-3,50.009375,50.009375,100.0,100.0] ./A 0.00s user 0.00s system 85% cpu 0.008 total
$ time ./A +RTS -N2 ./A +RTS -N2 3.03s user 1.33s system 159% cpu 2.735 total
$ time ./A +RTS -N1 -A100M ./A +RTS -N1 -A100M 1.99s user 0.29s system 99% cpu 2.287 total $ time ./A +RTS -N2 -A100M ./A +RTS -N2 -A100M 2.30s user 0.86s system 147% cpu 2.145 total
$ ghc -O2 -rtsopts --make A.hs -threaded -fforce-recomp -fllvm [1 of 1] Compiling Main ( A.hs, A.o ) Linking A ... $ time ./A +RTS -N2 -A100M ./A +RTS -N2 -A100M 2.09s user 0.95s system 147% cpu 2.065 total
$ ghc -Odph -rtsopts --make A.hs -threaded -fforce-recomp -fllvm $ time ./A +RTS -N2 -A60M -s ./A +RTS -N2 -A60M 1.99s user 0.73s system 144% cpu 1.880 total
$ ghc -O2 -fllvm -rtsopts -threaded -eventlog --make A.hs $ ./A +RTS -ls -N2 -A60M
$ time ./A +RTS -N2 -A60M ./A +RTS -N2 -A60M 1.76s user 0.25s system 186% cpu 1.073 total
$ time ./A +RTS -N1 -A25M ./A +RTS -N1 -A25M 1.75s user 0.11s system 100% cpu 1.855 total
$ time ./A +RTS -N2 -A25M ./A +RTS -N2 -A25M 1.78s user 0.13s system 188% cpu 1.014 total
instance Applicative ((->) r) where pure x = (\_ -> x) f <*> g = \x -> f x (g x)
Prelude Control.Applicative> (pure (+5)) <*> (*3) $ 4 17
Prelude Control.Applicative> (:) <*> (\x -> [x]) $ 2 [2,2]
class Shower a b where myShow :: a -> b doSomething :: Shower a String => a -> String doSomething = myShow
doSomethingWithState :: MonadState MyState m => m () doSomethingWithState = do current <- get let something1 = computeSomething1 current something2 = computeSomething2 current something1 put something2
Prelude> max (1, 2) 3 <interactive>:1:1: error: • Non type-variable argument in the constraint: Num (a, b) (Use FlexibleContexts to permit this) • When checking the inferred type it :: forall a b. (Num (a, b), Num b, Num a, Ord b, Ord a) => (a, b)
Prelude> max (1, 2) 3 <interactive>:1:1: error: • No instance for (Num (Integer, Integer)) arising from a use of ‘it’ • In the first argument of ‘print’, namely ‘it’ In a stmt of an interactive GHCi command: print it
if exists "foo.txt" then delete "foo.txt" doSomethingElse
import System.Directory main = do filename <- getFileNameSomehow fileExists <- doesFileExist filename if fileExists then removeFile filename ??? doSomethingElse
import Prelude hiding (catch) import System.Directory import Control.Exception import System.IO.Error hiding (catch) removeIfExists :: FilePath -> IO () removeIfExists fileName = removeFile fileName `catch` handleExists where handleExists e | isDoesNotExistError e = return () | otherwise = throwIO e
import Control.Monad import System.Directory import System.Environment doSomethingElse :: IO () main = do args <- getArgs fileExists <- doesFileExist (head args) when fileExists (removeFile (head args)) doSomethingElse
formatRow :: Car -> String formatRow (a, d:ds, c, x:xs) = a ++ " | " ++ x ++ concat xs ++ " | " ++ show c ++ " | " ++ d ++ concat ds ++ (show
sequence [] = return [] sequence (m:ms) = do x <- m xs <- sequence ms return (x:xs)
sequence [] = [[]] sequence (list : lists) = [ x : xs | x <- list , xs <- sequence lists ]
module Bla.Internal where data Bla = Blu Int | Bli String -- ... module Bla (Bla, makeBla) where -- ONLY export the Bla type, not the constructors import Bla.Internal makeBla :: String -> Bla -- Some function only dealing with the opaque type makeBla = undefined
(+) x = \y -> x + y (+) x y = (\y -> x + y) y = x + y
-- instead of return x >>= f >>= g -- simply go with f x >>= g -- instead of \x -> return x >>= f >>= g -- simply go with f >=> g -- or g <=< f
sine x = (sin x, "sine was called.") cube x = (x * x * x, "cube was called.")
*Main> :t sine sine :: Floating t => t -> (t, [Char]) *Main> :t bind sine bind sine :: Floating t1 => (t1, [Char]) -> (t1, [Char]) *Main> (bind sine . bind cube) (3, "") (0.956375928404503,"cube was called.sine was called.")
*Main> bind (0.956375928404503,"cube was called.sine was called.")
*Main> (3, "") `bind (0.956375928404503,"cube was called.sine was called.")
var bind = function(tuple) { return function(f) { var x = tuple[0], s = tuple[1], fx = f(x), y = fx[0], t = fx[1]; return [y, s + t]; }; }; var f = function(x) { return bind(bind(x)(cube))(sine); } f([3, ""]);
import Data.List main = do let xs = [1..10000000] sum = foldl len = foldl print (sum / len)
{- import Data.List main = do let xs = [1..10000000] (sum, len) = foldl print (sum / len)
f :: [a] -> [b] -> Int f [] _ = error "undefined for empty array" f _ [] = error "undefined for empty array" f (_:xs) (_:ys) = length xs + length ys
mod2 :: Integer -> Integer mod2 n | even n = 0 mod2 n | odd n = 1
duplicate :: [a] -> [a] duplicate [] = [] duplicate (x:xs) = x : x : (duplicate xs) removeDuplicates :: Eq a => [a] -> [a] removeDuplicates [] = [] removeDuplicates (x:y:xs) | x == y = x : removeDuplicates xs
removeDuplicates . duplicate == id duplicate . removeDuplicates == id (for values in the range of duplicate)
newtype DuplicatedList a = DuplicatedList [a] duplicate :: [a] -> DuplicatedList a removeDuplicates :: Eq a => DuplicatedList a -> [a] -- implementations omitted
home/ |-- user/ |-- haskell/ |-- Module1.hs |-- foo/ |-- Module2.hs
$ cd /home/user/haskell/foo $ runhaskell -i/home/user/haskell Module2.hs
newtype Machine k o = Step k o (Machine k o) data Step k o r = Stop | Yield o r | forall t . Await (t -> r) (k t) r
Prelude> (*2) <$> [1..3] [2,4,6] Prelude> show <$> Just 11 Just "11"
getConst . traverse Const :: (Monoid a, Traversable f) => f a -> a
{- import Control.Applicative import Control.Monad.Identity -- The definition of Van Laarhoven lenses: type Lens a b = forall f . Functor f => (b -> f b) -> (a -> f a) -- Getter passes the Const functor to the lens: get :: Lens a b -> a -> b get l = getConst . (l Const) -- Updater passes the Identity functor to the lens: modify :: Lens a b -> (b -> b) -> (a -> a) modify l f = runIdentity . l (Identity . f) set :: Lens a b -> b -> (a -> a) set l r = modify l (const r) -- Example: ------------------------------------------- data Person = Person { _name :: String, _age :: Int } deriving Show name :: Lens Person String name f (Person n a) = fmap (\x -> Person x a) (f n) age :: Lens Person Int age f (Person n a) = fmap (\x -> Person n x) (f a) main :: IO () main = do let john = Person "John" 34 print $ get age john print $ set name "Pete" john
instance Applicative Triple instance Traversable Triple
instance (Applicative f, Applicative g) => Applicative (f :. g) instance (Traversable f, Traversable g) => Traversable (f :. g)
newtype Parse x = Parser {parse :: String -> [(x, String)]} deriving Monoid
instance Applicative Parse instance Alternative Parse -- just follow the `Monoid`
crush :: (Traversable f, Monoid b) => (a -> b) -> f a -> b
complete :: Board Int -> Bool ok :: Board Int -> Bool
import qualified Text.Parsec as P import qualified Text.Parsec.Token as P import Control.Applicative data Expr = Number Int | Plus Expr Expr lex = P.makeTokenParser ... -- language config expr = number <|> plus where number = Number <$> P.integer lex plus = Plus <$> number <* P.symbol lex "+" <*> expr
(<*>) :: Applicative f => f (a -> b) -> f a -> f b (>>=) :: Monad m => m a -> (a -> m b) -> m b
newtype Compose f g x = Compose { getCompose :: f (g x) }
instance (Applicative f, Applicative g) => Applicative (Compose f g) instance (Monad f, Monad g) => Monad (Compose f g)
instance (Functor f, Functor g) => Functor (Compose f g) where fmap f (Compose fgx) = Compose (fmap (fmap f) fgx)
instance (Applicative f, Applicative g) => Applicative (Compose f g) where pure a = Compose (pure (pure a))
Compose fgf <*> Compose fgx = Compose ((<*>) <$> fgf <*> fgx)
join :: Compose f g (Compose f g x) -> Compose f g x
join_f :: f (f x) -> f x -- and join_g :: g (g x) -> g x
class Commute f g where commute :: g (f x) -> f (g x)
instance (Monad f, Monad g, Commute f g) => Monad (Compose f g)
join :: f (g (f (g x))) -> f (g x) join fgfgx = fgx where ffggx :: f (f (g (g x))) ffggx = fmap commute fgfgx fggx :: f (g (g x)) fggx = join_f ffggx fgx :: f (g x) fgx = fmap join_g fggx
instance Commute ((->) x) ((->) y) where commute = flip instance Commute ((,) x) ((,) y) where commute (y, (x, a)) = (x, (y, a)) instance Commute ((->) x) ((,) y) where commute (y, xa) = \x -> (y, xa x) -- instance Commute ((,) x) ((->) y) does not exist; try to write yourself! -- -- OR: -- It turns out that you need to somehow "travel back in time" to make it -- work... -- -- instance Commute ((,) x) ((->) y) where -- commute yxa = ( ..., \y -> let (x, a) = yxa y in a )
main :: IO () main = do putStrLn "do something" main
import Control.Monad main :: IO () main = forever $ putStrLn "do something"
foo :: Int -> Int foo = const 5 . (+3) . (`div` 10)
foo 0 => (const 5 . ((+3) . (`div` 10))) 0 => (\x -> const 5 (((+3) . (`div` 10)) x)) 0 => const 5 (((+3) . (`div` 10)) 0) => 5
foo 0 => ((const 5 . (+3)) . (`div` 10)) 0 => (\x -> (const 5 . (+3)) (x `div` 10)) 0 => (const 5 . (+3)) (0 `div` 10) => (\x -> const 5 (x + 3)) (0 `div` 10) => const 5 ((0 `div` 10) + 3) => 5
data Value = FunVal (Value -> Value) | PriVal Int | ConVal Id [Value] | Error String
data Value : Set where FunVal : (Value -> Value) -> Value PriVal : ℕ -> Value ConVal : String -> List Value -> Value Error : String -> Value
apply : Value -> Value -> Value apply (FunVal f) x = f x apply _ x = Error "Applying non-function" w : Value w = FunVal (\x -> apply x x)
X -> Bool (X -> Nat) -> Nat -- this one is "positive", but not strictly (X * Nat) -> X
data Foo x = X x | Y Int | Z String | ...(other constructors not involving x)
instance Functor Foo where fmap f (X x) = X (f x) fmap _ (Y y) = Y y fmap _ (Z z) = Z z ... And so on
instance Functor Foo where fmap f (X x) = X (f x) fmap _ a = a
{- import Control.Lens data Foo x y = X x | Y y | Z String makePrisms mapOverX :: (x -> x mapOverX = over _X
import Control.Lens newtype Fix f = Fix {out :: f (Fix f)} -- k marks the recursive positions -- so the original type would be "data Foo x y = ... | Two (Foo x y) (Foo x y)" data FooF x y k = X x | Y y | Z String | Two k k deriving (Functor) type Foo x y = Fix (FooF x y) makePrisms mapOverX :: (x -> x mapOverX f = Fix . -- rewrap over _X f . -- map f over X if possible fmap (mapOverX f) . -- map over recursively out -- unwrap
cata :: (Functor f) => (f a -> a) -> Fix f -> a cata f = go where go = f . fmap go . out mapOverX :: (x -> x mapOverX f = cata (Fix . over _X f)
data Bar = S String | B Bool | I Int -- "Inner" type data Foo a = X a | Q Bar -- "Outer" type instance Functor Foo where fmap f (X a) = X (f a) fmap _ (Q b) = Q b -- `b
{- import Control.Lens import Control.Lens.Prism data Foo x = X x | Y Int | Z String deriving Show makePrisms instance Functor Foo where -- super simple impl, by András Kovács fmap = over _X -- My overly complicated idea -- fmap f = id & outside _X .~ (X . f) -- Original still more complicated implementation below -- fmap f (X x) = X (f x) -- fmap _ a = id & outside _X .~ undefined $ a
*Main> fmap (++ "foo") (Y 3) Y 3 *Main> fmap (++ "foo") (X "abc") X "abcfoo"
import Unsafe.Coerce instance Functor Foo where fmap f (X x) = X (f x) fmap _ a = unsafeCoerce a
for(i = 0; i < 1000; i++) actor[i].decision = HaskellCode(20kB of data here, actor[i].personality);
$ ./foo IO : 2381952795 nanoseconds total, 238.195279 nanoseconds per, 160000000 value Pure: 2188546976 nanoseconds total, 218.854698 nanoseconds per, 160000000 value
ghc -no-hs-main -lstdc++ -O2 -optc-O2 -o foo ForeignExportCost.hs Driver.cpp
{- module ForeignExportCost where import Foreign.C.Types foreign export ccall simpleFunction :: CInt -> CInt simpleFunction i = i * i foreign export ccall simpleFunctionIO :: CInt -> IO CInt simpleFunctionIO i = return (i * i)
static const int s_loop = 10000000; int main(int argc, char** argv) { hs_init(&argc, &argv); struct mach_timebase_info timebase_info = { }; kern_return_t err; err = mach_timebase_info(&timebase_info); if (err != KERN_SUCCESS) { fprintf(stderr, "error: %x\n", err); return err; } uint64_t start = mach_absolute_time(); HsInt32 val = 0; for (int i = 0; i < s_loop; ++i) { val += simpleFunctionIO(4); } uint64_t duration = (mach_absolute_time() - start) * timebase_info.numer / timebase_info.denom; double duration_per = static_cast<double>(duration) / s_loop; printf("IO : %lld nanoseconds total, %f nanoseconds per, %d value\n", duration, duration_per, val); start = mach_absolute_time(); val = 0; for (int i = 0; i < s_loop; ++i) { val += simpleFunction(4); } duration = (mach_absolute_time() - start) * timebase_info.numer / timebase_info.denom; duration_per = static_cast<double>(duration) / s_loop; printf("Pure: %lld nanoseconds total, %f nanoseconds per, %d value\n", duration, duration_per, val); hs_exit(); }
f :: LotsaData -> Personality -> Decision f data p = ...
helper :: LotsaData -> [Personality] -> [Decision] helper data ps = map (f data) ps
liftM2 :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r liftM2 f m1 m2 = do x1 <- m1 x2 <- m2 return $ f x1 x2
data A = A Int Int | B m :: A -> Int m a = case a of A{} -> 1 _ -> 2
apat -> qcon { fpat1 , … , fpatk } (labeled pattern, k ≥ 0)
(o) case v of { K {} -> e ; _ -> e′ } = case v of { K _… _ -> e ; _ -> e′ }
read = act readSTRef test1 term i var = do t <- fromRTerm term v <- rep var ty <- v^!varType.read ts <- v^!terms.read let ts when (ty /= Void && V.length ts V.mapM_ substitute ts'
read = act readSTRef test2 term i var = do t <- fromRTerm term v <- rep var ty <- v^!varType.read ts <- TL.toVector <$> v^!terms.read when (ty /= Void && V.length ts == 1) . updateChild term t i $ ts V.! 0 V.mapM_ substitute ts
case ipv5_X2Q6 of _ [Occ=Dead] { __DEFAULT -> case GHC.Prim.writeMutVar# @ s_aJBu @ TypeInferencer.Stage dt5_dMoe TypeInferencer.Substituted ipv4_X2Q4 of s2 letrec { a15_sSPP [Occ=LoopBreaker] :: [GHC.Types.Int] -> [TypeInferencer.RNode s_aJBu] -> GHC.Prim.State -> ( [LclId, Arity=3, Str=DmdType <S,1*U><L,1*U><L,U>] a15_sSPP = \ (ds_aPlu :: [GHC.Types.Int]) (_ys_aPlv :: [TypeInferencer.RNode s_aJBu]) (eta_B1 :: GHC.Prim.State case ds_aPlu of _ [Occ=Dead] { [] -> ( : ipv6_aPlA ipv7_aPlB -> case _ys_aPlv of _ [Occ=Dead] { [] -> ( : ipv8_aPlH ipv9_aPlI -> tick<substitute.go> case scc<substitute.go> (scctick<fromRNode> GHC.STRef.readSTRef1 @ s_aJBu @ (Data.Either.Either (TypeInferencer.Term s_aJBu) (TypeInferencer.Var s_aJBu)) (ipv8_aPlH `cast` (TypeInferencer.NTCo:RNode[0] <s_aJBu>_N :: TypeInferencer.RNode s_aJBu ~# GHC.STRef.STRef s_aJBu (Data.Either.Either (TypeInferencer.Term s_aJBu) (TypeInferencer.Var s_aJBu))))) eta_B1 of _ [Occ=Dead] { ( case ipv11_X2DX of _ [Occ=Dead] { Data.Either.Left ds5_dLX6 -> case scc<substitute.go> a11_rYpY @ s_aJBu ipv8_aPlH ipv10_X2DV of _ [Occ=Dead] { ( a15_sSPP ipv7_aPlB ipv9_aPlI ipv12_a2tf }; Data.Either.Right var_aJrt -> case scc<substitute.go> a14_sPTG ipv10_X2DV of _ [Occ=Dead] { ( tick<rep> case scc<substitute.go> scc<rep> a4_rYnT @ s_aJBu var_aJrt ipv12_X2PP of _ [Occ=Dead] { ( case scc<substitute.go> scc<rep> a3_rYnR @ s_aJBu ipv15_X2PY var_aJrt ipv14_X2PW of _ [Occ=Dead] { ( case ipv17_X2Q2 of _ [Occ=Dead] { TypeInferencer.Var dt6_dMth x1_XJka dt7_dMti dt8_dMtj dt9_dMtk dt10_dMtl dt11_dMtm -> case scc<substitute.go> GHC.Prim.readMutVar# @ s_aJBu @ TypeInferencer.VarType dt7_dMti ipv16_X2Q0 of _ [Occ=Dead] { ( case scc<substitute.go> GHC.Prim.readMutVar# @ s_aJBu @ (TreeList.TreeList (TypeInferencer.RNode s_aJBu)) dt9_dMtk ipv18_X2Qt of _ [Occ=Dead] { ( case scc<substitute.go> scctick<substitute.go.ts TreeList.toVector @ (TypeInferencer.RNode s_aJBu) ipv21_X2QN of _ [Occ=Dead] { Data.Vector.Vector ww1_sTzM ww2_sTzN ww3_sTzO -> tick<==> tick</=> case scc<substitute.go> let { $w$j_sTA0 :: GHC.Prim.State [LclId, Arity=1, Str=DmdType <L,U>] $w$j_sTA0 = \ (w_sTzY :: GHC.Prim.State letrec { $s$wa_sWUL [Occ=LoopBreaker] :: GHC.Prim.Int# -> GHC.Prim.State -> ( [LclId, Arity=2, Str=DmdType <L,U><L,U>] $s$wa_sWUL = \ (sc_sWUJ :: GHC.Prim.Int (sc1_sWUK :: GHC.Prim.State case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>= of _ [Occ=Dead] { GHC.Types.False -> case GHC.Prim.indexArray# @ (TypeInferencer.RNode s_aJBu) ww3_sTzO (GHC.Prim.+ of _ [Occ=Dead] { ( case a11_rYpY @ s_aJBu ipv22_aQSr sc1_sWUK of _ [Occ=Dead] { ( $s$wa_sWUL (GHC.Prim.+ } }; GHC.Types.True -> ( }; } in $s$wa_sWUL 0 w_sTzY } in
case ipv5_X2Q6 of _ [Occ=Dead] { __DEFAULT -> case GHC.Prim.writeMutVar# @ s_aJBt @ TypeInferencer.Stage dt5_dMog TypeInferencer.Substituted ipv4_X2Q4 of s2 letrec { a15_sSPP [Occ=LoopBreaker] :: [GHC.Types.Int] -> [TypeInferencer.RNode s_aJBt] -> GHC.Prim.State -> ( [LclId, Arity=3, Str=DmdType <S,1*U><L,1*U><L,U>] a15_sSPP = \ (ds_aPlu :: [GHC.Types.Int]) (_ys_aPlv :: [TypeInferencer.RNode s_aJBt]) (eta_B1 :: GHC.Prim.State case ds_aPlu of _ [Occ=Dead] { [] -> ( : ipv6_aPlA ipv7_aPlB -> case _ys_aPlv of _ [Occ=Dead] { [] -> ( : ipv8_aPlH ipv9_aPlI -> tick<substitute.go> case scc<substitute.go> (scctick<fromRNode> GHC.STRef.readSTRef1 @ s_aJBt @ (Data.Either.Either (TypeInferencer.Term s_aJBt) (TypeInferencer.Var s_aJBt)) (ipv8_aPlH `cast` (TypeInferencer.NTCo:RNode[0] <s_aJBt>_N :: TypeInferencer.RNode s_aJBt ~# GHC.STRef.STRef s_aJBt (Data.Either.Either (TypeInferencer.Term s_aJBt) (TypeInferencer.Var s_aJBt))))) eta_B1 of _ [Occ=Dead] { ( case ipv11_X2DX of _ [Occ=Dead] { Data.Either.Left ds5_dLX8 -> case scc<substitute.go> a11_rYpY @ s_aJBt ipv8_aPlH ipv10_X2DV of _ [Occ=Dead] { ( a15_sSPP ipv7_aPlB ipv9_aPlI ipv12_a2tf }; Data.Either.Right var_aJrt -> case scc<substitute.go> a14_sPTG ipv10_X2DV of _ [Occ=Dead] { ( tick<rep> case scc<substitute.go> scc<rep> a4_rYnT @ s_aJBt var_aJrt ipv12_X2PP of _ [Occ=Dead] { ( case scc<substitute.go> scc<rep> a3_rYnR @ s_aJBt ipv15_X2PY var_aJrt ipv14_X2PW of _ [Occ=Dead] { ( case ipv17_X2Q2 of _ [Occ=Dead] { TypeInferencer.Var dt6_dMtj x1_XJka dt7_dMtk dt8_dMtl dt9_dMtm dt10_dMtn dt11_dMto -> case scc<substitute.go> GHC.Prim.readMutVar# @ s_aJBt @ TypeInferencer.VarType dt7_dMtk ipv16_X2Q0 of _ [Occ=Dead] { ( case scc<substitute.go> GHC.Prim.readMutVar# @ s_aJBt @ (TreeList.TreeList (TypeInferencer.RNode s_aJBt)) dt9_dMtm ipv18_X2Qt of _ [Occ=Dead] { ( case scc<substitute.go> TreeList.toVector @ (TypeInferencer.RNode s_aJBt) ipv21_a6bT of _ [Occ=Dead] { Data.Vector.Vector ww1_sTzM ww2_sTzN ww3_sTzO -> tick<==> tick</=> case scc<substitute.go> let { $w$j_sTA0 :: GHC.Prim.State [LclId, Arity=1, Str=DmdType <L,U>] $w$j_sTA0 = \ (w_sTzY :: GHC.Prim.State letrec { $s$wa_sWUL [Occ=LoopBreaker] :: GHC.Prim.Int# -> GHC.Prim.State -> ( [LclId, Arity=2, Str=DmdType <L,U><L,U>] $s$wa_sWUL = \ (sc_sWUJ :: GHC.Prim.Int (sc1_sWUK :: GHC.Prim.State case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>= of _ [Occ=Dead] { GHC.Types.False -> case GHC.Prim.indexArray# @ (TypeInferencer.RNode s_aJBt) ww3_sTzO (GHC.Prim.+ of _ [Occ=Dead] { ( case a11_rYpY @ s_aJBt ipv22_aQSr sc1_sWUK of _ [Occ=Dead] { ( $s$wa_sWUL (GHC.Prim.+ } }; GHC.Types.True -> ( }; } in $s$wa_sWUL 0 w_sTzY } in
data NonEmptyList a = Single a | Cons a (NonEmptyList a)
{- data Zero data NonZero data Binary a where I :: Binary a -> Binary NonZero O :: Binary a -> Binary a Z :: Binary Zero N :: Binary NonZero instance Show (Binary a) where show (I x) = "1" ++ show x show (O x) = "0" ++ show x show (Z) = "0" show (N) = "1"
module Positive (toPositive, Positive(unPositive)) where newtype Positive = Positive { unPositive :: Int } toPositive :: Int -> Maybe Positive toPositive n = if (n < 0) then Nothing else Just (Positive n)
class (Eq a, Show a) => Num a where (+) :: a -> a -> a (*) :: a -> a -> a (-) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a
U+004E N (Lu): LATIN CAPITAL LETTER N U+00ED í (Ll): LATIN SMALL LETTER I WITH ACUTE U+00F0 ð (Ll): LATIN SMALL LETTER ETH U+0068 h (Ll): LATIN SMALL LETTER H U+006F o (Ll): LATIN SMALL LETTER O U+0308 ̈ (Mn): COMBINING DIAERESIS U+0067 g (Ll): LATIN SMALL LETTER G U+0067 g (Ll): LATIN SMALL LETTER G U+0072 r (Ll): LATIN SMALL LETTER R
do x <- [1, 2] -- if x is 1 or 2 y <- [4, 5, 6] -- and y is 4, 5, or 6 return (x + y) -- then what are the possible values of x + y?
newtype Identity a = Identity {runIdenity :: a} deriving Functor instance Monad Identity where return = Identity join = runIdentity instance CoMonad Identity where coreturn = runIdentity cojoin = Identity
class CoMonoid m where comempty :: (m,a) -> a comappend :: m -> (m,m) --every haskell type is a CoMonoid --that is because CCCs are boring! instance Monoid a => Monad ((,) a) where return x = (mempty,x) join (a,(b,x)) = (a <> b, x) instance CoMonoid a => CoMonad ((,) a) where coreturn = comempty cojoin = associate . first comappend instance CoMonoid a => Monad ((->) a) where return = flip (curry comempty) join f = uncurry f . comappend instance Monoid a => CoMonad ((->) a) where coreturn f = f mempty cojoin f a b = f (a <> b)
instance Alternative f => Monad (Cofree f) where return x = x :< empty (a :< m) >>= k = case k a of b :< n -> b :< (n <|> fmap (>>= k) m)
data Stream a = a :> Stream a instance Comonad Stream where duplicate = tails extend f w = f w :> extend f (tail w) extract = head instance Monad Stream where return = repeat m >>= f = unfold (\(bs :> bss) -> (head bs, tail <$> bss)) (fmap f m)
data Moore a b = Moore b (a -> Moore a b) instance Monad (Moore a) where return a = r where r = Moore a (const r) Moore a k >>= f = case f a of Moore b _ -> Moore b (k >=> f) _ >> m = m instance Comonad (Moore a) where extract (Moore b _) = b extend f w@(Moore _ g) = Moore (f w) (extend f . g)
instance Monoid e => Monad ((,) e) instance Comonad ((,) e)
instance Monad ((->) e) instance Monoid e => Comonad ((->)e)
newtype Id a = Id a instance Monad Identity where return = Id (Id a) >>= f = f a instance Comonad Identity where extract (Id a) = a extend f ida = Id (f ida)
module ThingModule (Thing, ThingView(..), view) where data Thing = Foo Thing | Bar Int data ThingView = FooV Thing | BarV Int view :: Thing -> ThingView view (Foo x) = FooV x view (Bar y) = BarV y
{- module Main where import ThingModule doSomethingWithThing :: Thing -> Int doSomethingWithThing(view -> FooV x) = doSomethingWithThing x doSomethingWithThing(view -> BarV y) = y
doSomethingWithThing :: Thing -> Int doSomethingWithThing = doIt . view where doIt (FooV x) = doSomethingWithThing x doIt (BarV y) = y
module ThingModule (ThingView(..), Thing, view) where newtype Thing = T {view :: ThingView Thing} data ThingView a = Foo a | Bar Int
{- module Main where import ThingModule doSomethingWithThing :: Thing -> Int doSomethingWithThing(view -> Foo x) = doSomethingWithThing x doSomethingWithThing(view -> Bar y) = y
{- module ThingModule (Thing, pattern Foo, pattern Bar) where pattern Foo a <- RealFoo a pattern Bar a <- RealBar a data Thing = RealFoo Thing | RealBar Int
{- module Main where import ThingModule doSomethingWithThing :: Thing -> Int doSomethingWithThing (Foo x) = doSomethingWithThing x doSomethingWithThing (Bar y) = y
Main.hs:9:32: Bar used in an expression, but it In the expression: Bar y
import Data.Word ( Word16 ) import Data.String ( IsString(fromString) ) type String16 = [Word16] instance IsString [Word16] where fromString = encodeUTF16 encodeUTF16 :: String -> String16
Data/String16.hs:35:10: Illegal instance declaration for `IsString [Word16]' (All instance types must be of the form (T a1 ... an) where a1 ... an are *distinct type variables*, and each type variable appears at most once in the instance head. Use -XFlexibleInstances if you want to disable this.) In the instance declaration for `IsString [Word16]'
type String16 = [Word16] instance IsString String16 where ...
newtype String16 = String16 { unString16 :: [Word16] } instance IsString String16 where ...
(All instance types must be of the form (T a1 ... an) where a1 ... an are *distinct type variables*, and each type variable appears at most once in the instance head.
Use -XFlexibleInstances if you want to disable this.)
ifM :: Monad m => m Bool -> m a -> m a -> m a ifM c x y = c >>= \z -> if z then x else y whileM :: Monad m => (a -> m Bool) -> (a -> m a) -> a -> m a whileM p step x = ifM (p x) (step x >>= whileM p step) (return x) (*&&) :: Monad m => m Bool -> m Bool -> m Bool x *&& y = ifM x y (return False) (*||) :: Monad m => m Bool -> m Bool -> m Bool x *|| y = ifM x (return True) y notM :: Monad m => m Bool -> m Bool notM x = x >>= return . not
ifA :: Applicative f => f Bool -> f a -> f a -> f a ifA c x y = (\c
whileA :: Applicative f => (a -> f Bool) -> (a -> f a) -> a -> f a whileA p step x = ifA (p x) (whileA p step <$> step x) (pure x)
whileA :: Applicative f => (a -> f Bool) -> (a -> f a) -> a -> f a whileA p step x = ifA (p x) (whileA p step <*> step x) (pure x)
fac :: (Eq a, Num a) => a -> a fac 0 = 1 fac n = n * fac (n-1) f :: Int -> Int f x = 1 + fac x
map f xs0 = go xs0 where go [] = [] go (x:xs) = f x : go xs
map :: (a -> b) -> [a] -> [b] map _ [] = [] map f (x:xs) = f x : map f xs
{- "map" [~1] forall f xs. map f xs = build (\c n -> foldr (mapFB c f) n xs) "mapList" [1] forall f. foldr (mapFB (:) f) [] = map f "mapFB" forall c f g. mapFB (mapFB c f) g = mapFB c (f.g)
proc1 = sum . take 10 . map (+1) . map (*2) eval1 = proc1 [1..5] eval2 = proc1 [1..]
class (Functor f) => Applicative f where pure :: a -> f a (<*>) :: f (a -> b) -> f a -> f b
instance Applicative ((->) r) where pure :: a -> ((->) r) a (<*>) :: (->) r (a -> b) -> (->) r a -> (->) r b
instance Applicative ((->) r) where pure :: a -> r -> a (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)
(<*>) :: (r -> a -> b ) -> (r -> a) -> (r -> b) (==) :: Eq e => e -> e -> Bool | | | | | +-> `b` must be `Bool` | | | +------> `a` must be `e` | +-----------> `r` must also be `e`
class Read a where read :: String -> a instance Read Integer where read s = -- parse a string into an integer instance Read Double where read s = -- parse a string into a double
x :: Integer x = read "12345" y :: Double y = read "12345.0"
import Data.List roundDouble :: Double -> Int -> Double roundDouble x acc = fromIntegral (round $ x * 10 ** fromIntegral acc) / 10 ** fromIntegral acc
roundDouble x acc = (round $ x * 10 ^ acc) /. (10 ^ acc) where x /. y = fromIntegral x / fromIntegral y
(/.) :: (Real a, Real b, Fractional c) => a -> b -> c (/.) x y = fromRational $ (toRational x) / (toRational y)
ghci> let (a,b,c) = (2::Int, 3::Double, 5::Int) ghci> (b/.a, c/.a, a/.c) (1.5,2.5,0.4)
roundDouble :: Double -> Int -> Double roundDouble x acc = (round $ x * 10 ^ acc) /. (10 ^ acc)
-- | Create a new mutable array of the specified size and initialise all -- elements with the given value. newArray :: PrimMonad m => Int -> a -> m (MutableArray (PrimState m) a) newArray (I (\s ( -- | Read a value from the array at the given index. readArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> m a readArray (MutableArray arr -- | Write a value to the array at the given index. writeArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> a -> m () writeArray (MutableArray arr
src/ utils/Utils.hs subsystem/Subsystem.hs ..... myproject.cabal Setup.hs
$ ghci GHCi, version 7.8.3: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Prelude>:load src/subsystem/Subsystem.hs ... should load Subsystem.hs
src\Main.hs:224:7: Couldn `s the type signature for `test In the expression: "asdasd" In the definition of `test
f x = case catch (seq x True) (\exception -> False) of True -> -- there was no exception undefined False -> -- there was an exception, return defined value 42
import Prelude hiding (catch) import System.IO.Unsafe (unsafePerformIO) import qualified Control.Exception as E catch :: a -> (E.SomeException -> a) -> a catch x h = unsafePerformIO $ E.catch (return $! x) (return . h) f x = case catch (seq x True) (\exception -> False) of True -> -- there was no exception undefined False -> -- there was an exception, return defined value 42
head [] = error "oh no!" -- this type of exception head (x:xs) = x
-- The reciprocal is not defined for the value 0 myRecip :: Fractional a => a -> a myRecip x | x == 0 = throw DivideByZero | otherwise = 1 / x
safeRecip :: Fractional a => a -> Maybe a safeRecip x | x == 0 = Nothing | otherwise = Just $ 1 / x
restrictInput :: (a -> Bool) -> (a -> b) -> (a -> Maybe b) restrictInput pred f x = if pred x then Just (f x) else Nothing safeRecip
prop_recip 0 = (safeRecip >=> safeRecip) 0 == Nothing prop_recip x = (safeRecip >=> safeRecip) x == Just x
error :: [Char] -> a error s = throw (ErrorCall s) undefined :: a undefined = error "Prelude.undefined"
data Expr = PlusExpr Expr Expr ... data Def = TypeAlias String [String] Type ...
data AnnotatedExpr = PlusExpr Expr Expr [Annotation] ... data AnnotatedDef = TypeAlias String [String] Type [Annotation] ...
Data AnnotationTree = Leaf [Annotation] | Internal [AnnotationTree] [Annotation]
data Hutton x -- non-recursive functor type = Int Int | Plus x x deriving Functor newtype Tie f = Tie (f (Tie f)) data Annotate f a = Annotate { annotation :: a, layer :: (f (Annotate f a)) } type Unannotated = Tie Hutton type Annotated a = Annotate Hutton a
interp :: Hutton Int -> Int interp (Int i) = i interp (Plus a b) = a + b runUnannotated :: Functor f => (f x -> x) -> Tie f -> x runUnannotated phi (Tie f) = phi (fmap (runUnannotated phi) f) runAnnotated :: Functor f => (f x -> x) -> Annotate f a -> x runAnnotated phi (Annotate _ f) = phi (fmap (runAnnotated phi) f)
annotate :: Functor f => (f b -> b) -> Tie f -> Annotate f b annotate phi = runUnannotated $ \x -> Annotate (phi (fmap annotation x)) x memoize :: Unannotated -> Annotated Int memoize = annotate interp
λ> memoize (2 + (2 + 2)) Annotate 6 (Plus (Annotate 2 (Int 2)) (Annotate 4 (Plus (Annotate 2 (Int 2)) (Annotate 2 (Int 2)))))
strip :: Annotated a -> Unannotated strip = runAnnotated Tie
data Expr = PlusExpr Expr Expr | AnnotatedExpr Annotation Expr ...
data MailboxInfo = MboxInfo { _mailbox :: MailboxName , _exists :: Integer , _recent :: Integer , _flags :: [Flag] , _permanentFlags :: [Flag] , _isWritable :: Bool , _isFlagWritable :: Bool , _uidNext :: UID , _uidValidity :: UID } deriving (Show, Eq)
module Coords (Coords(), -- hide the constructor x,y,buildCoords) where data Coords = Coords { x :: Int, y :: Int } buildCoords :: Int -> Int -> Coords buildCoords x y | x < 0 || y < 0 = error "omg" buildCoords x y = Coords { x = x, y = y }
module Coords (Coords(), -- hide the constructor x,y,buildCoords) where data Coords = Coords { _x :: Int, _y :: Int } x = _x y = _y buildCoords :: Int -> Int -> Coords buildCoords x y | x < 0 || y < 0 = error "omg" buildCoords x y = Coords { _x = x, _y = y }
item : (b : Bool) -> if b then Nat else List Nat item True = 42 item False = [1,2,3]
type family Cond (b :: Bool)(t :: k)(e :: k) :: k where Cond Cond
item :: pi (b :: Bool) -> Cond b Int [Int] item True = 42 item False = [1,2,3]
data Booly :: Bool -> * where Truey :: Booly Falsey :: Booly item :: forall b. Booly b -> Cond b Int [Int] item Truey = 42 item Falsey = [1,2,3]
@INPROCEEDINGS{Hudak07ahistory, author = {Paul Hudak and John Hughes and Simon Peyton Jones and Philip Wadler}, title = {A history of Haskell: Being lazy with class}, booktitle = {In Proceedings of the 3rd ACM SIGPLAN Conference on History of Programming Languages (HOPL-III}, year = {2007}, pages = {1--55}, publisher = {ACM Press} }
data Foo = Foo Integer Critical data Bar = Bar String Critical
goodConvert, badConvert :: Foo -> Bar goodConvert (Foo n c) = Bar (show n) c badConvert (Foo n (Critical s)) = Bar (show n) (Critical $ "Bzzt - " ++ s)
swapFooBar :: (Foo, Bar) -> (Bar, Foo) swapFooBar (Foo n c1, Bar s c2) = (Bar s c1, Foo n c2)
data Foo c = Foo Integer c data Bar c = Bar String c goodConvert :: Foo c -> Bar c goodConvert (Foo n c) = Bar (show n) c
badConvert :: Foo c -> Bar c badConvert (Foo n c) = Bar (show n) undefined
Require Import String. Require Import ZArith. Inductive Critical := Crit : string -> Critical. Inductive FooT := Foo : Z -> Critical -> FooT. Inductive BarT := Bar : string -> Critical -> BarT.
Definition critF f := match f with Foo _ c => c end. Definition critB b := match b with Bar _ c => c end.
Definition ascii_of_Z (z : Z) : string := EmptyString. (* FIXME *)
Definition goodConvert (foo : FooT) : BarT := match foo with Foo n c => Bar (ascii_of_Z n) c end.
Lemma convertIsGood : forall (f : FooT) (b : BarT), goodConvert f = b -> critF f = critB b. Proof. intros. destruct f. destruct b. unfold goodConvert in H. simpl. inversion H. reflexivity. Qed.
Extraction Language Haskell. Extract Constant ascii_of_Z => "Prelude.show". (* obviously, all sorts of unsafe and incorrect behavior can be introduced by your extraction *) Extract Inductive string => "Prelude.String" ["[]" ":"]. Print positive. Extract Inductive positive => "Prelude.Integer" ["`Data.Bits.shiftL` 1 + 1" "`Data.Bits.shiftL` 1" "1"]. Extract Inductive Z => "Prelude.Integer" ["0" "" ""]. Extraction "so.hs" goodConvert critF critB.
module So where import qualified Prelude data Bool = True | False data Ascii0 = Ascii Bool Bool Bool Bool Bool Bool Bool Bool type Critical = Prelude.String -- singleton inductive, whose constructor was crit data FooT = Foo Prelude.Integer Critical data BarT = Bar Prelude.String Critical critF :: FooT -> Critical critF f = case f of { Foo z c -> c} critB :: BarT -> Critical critB b = case b of { Bar s c -> c} ascii_of_Z :: Prelude.Integer -> Prelude.String ascii_of_Z z = [] goodConvert :: FooT -> BarT goodConvert foo = case foo of { Foo n c -> Bar (ascii_of_Z n) c}
mkCritical :: String -> D Critical extract :: Critical -> String
data C a = C a Critical modify :: (a -> String -> b) -> C a -> C b modify f (C x (Critical y)) = C (f x y) (Critical y)
goodConvert :: C Int -> C String goodConvert = modify (\(a, _) -> show a)
-- | Dummy parameter to avoid creating a CAF twoTrues :: () -> [[[Bool]]] twoTrues _ = map (++ (True : repeat False)) . trueBlock <$> [1..]
module A where big :: () -> [Int] big _ = [1..10^7]
A.big1 :: [Int] [ Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False, ConLike=False, Cheap=False, Expandable=False, Guidance=IF_ARGS [] 7 0}] A.big1 = case A.$wf1 10 A.big2 of ww_sDD { __DEFAULT -> eftInt 1 ww_sDD } A.big :: () -> [Int] [Arity=1, Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True, ConLike=True, Cheap=True, Expandable=True, Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True) Tmpl= \ _ -> A.big1}] A.big = \ _ -> A.big1
A.big :: () -> [Int] [GblId, Arity=1] A.big = \ _ -> enumFromTo @ Int $fEnumInt (I (^ @ Int @ Type.Integer $fNumInt $fIntegralInteger (I (smallInteger 7))
big :: () -> [Int] big u = myEnumFromTo u 1 (10^7) {- myEnumFromTo :: () -> Int -> Int -> [Int] myEnumFromTo _ n m = enumFromTo n m {-
A.myEnumFromTo [InlPrag=NOINLINE] :: () -> Int -> Int -> [Int] A.myEnumFromTo = \ _ (n_afx :: Int) (m_afy :: Int) -> $fEnumInt_$cenumFromTo n_afx m_afy A.big [InlPrag=NOINLINE] :: () -> [Int] A.big = \ (u_abx :: ()) -> A.myEnumFromTo u_abx A.$s^2 lvl3_rEe
twoTrues u = map (++ (True : repeat False)) . trueBlock <$> [(u `seq` 1)..]
twoTrues :: () -> [[[Bool]]] twoTrues u = map (++ (True : repeat (false u))) . trueBlock <$> [1..] {- false :: () -> Bool false _ = False
twoTrues :: a -> [[[Bool]]] twoTrues _ = map (++ (True : repeat False)) . trueBlock <$> [1..]
usual :: a -> String usual _ = "Hello World!" unusual :: a -> String unusual a = seq a "Hello World!"
lenDigits n = length (show n) factorial n = product [1..n]
Prelude> ((lenDigits . factorial) 199) <= 199 False Prelude> (\i -> ((lenDigits . factorial) i) <= i) 199 True
((lenDigits . factorial) (fromInteger (199 :: Integer)) <= (fromInteger (199 :: Integer))
(lenDigits . factorial) (fromInteger (199 :: Integer))
((lenDigits . factorial) (fromInteger (199 :: Integer)) <= (199 :: Int)
((lenDigits . factorial) (199 :: Integer)) <= (199 :: Int)
GHCi> :t \i -> (lenDigits . factorial) i <= i \i -> (lenDigits . factorial) i <= i :: Int -> Bool
((lenDigits . factorial) (199 :: Int)) <= (199 :: Int)
GHCi> :t \i -> (lenDigits . factorial) i <= fromInteger i \i -> (lenDigits . factorial) i <= fromInteger i :: Integer -> Bool GHCi> (\i -> (lenDigits . factorial) i <= fromInteger i) 199 False
{- data ALL = forall a. Show a => ALL { theA :: a } -- data ok xALL :: ALL -> String xALL (ALL a) = show a -- pattern matching ok -- ABOVE: heaven -- BELOW: hell yALL :: ALL -> String yALL all = show $ theA all -- record selector failed
forall.hs:11:19: Cannot use record selector `theA Probable fix: use pattern-matching syntax instead In the second argument of `($) In the expression: show $ theA all In an equation for `yALL
-- Not a real type signature! theA :: ALL -> t -- for a fresh type t on each use of theA; t is an instance of Show
{- module Main where import qualified Data.Map as M import Text.XML.HXT.Arrow classes :: (ArrowXml a) => a XmlTree (M.Map String String) classes = listA (divs >>> pairs) >>> arr M.fromList where divs = getChildren >>> hasName "div" pairs = proc div -> do cls <- getAttrValue "class" -< div val <- deep getText -< div returnA -< (cls, val) getValues :: (ArrowXml a) => [String] -> a XmlTree (String, Maybe String) getValues cs = classes >>> arr (zip cs . lookupValues cs) >>> unlistA where lookupValues cs m = map (flip M.lookup m) cs xml = "<div><div class= \<div class= values :: [(String, Maybe String)] values = runLA (xread >>> getValues ["c1", "c2", "c3", "c4"]) xml main = print values
classes = (getChildren >>> hasName "div" >>> pairs) >. M.fromList where pairs = getAttrValue "class" &&& deep getText
upIO :: XmlPickler a => String -> IO [a] upIO str = runX $ readString [] str >>> arrL (maybeToList . unpickleDoc xpickle)
upPure :: XmlPickler a => String -> [a] upPure str = runLA (xreadDoc >>> arrL (maybeToList . unpickleDoc xpickle)) str
{- f :: forall a . [a] -> [a] -- The `forall` is required here ... f (x:xs) = xs ++ [x :: a] -- ... to relate this `a` to the ones above.
f :: [a] -> [a] -- No `forall` here ... f (x:xs) = xs ++ [x :: a] -- ... or here.
f :: forall a . [a] -> [a] -- With a `forall` here ... f (x:xs) = xs ++ [x :: forall a . a] -- ... and another one here.
f :: forall a . [a] -> [a] f (x:xs) = xs ++ [x :: forall b . b] -- I
f :: forall a . [a] -> [a] -- A `forall` here ... f (x:xs) = xs ++ [x :: a] -- ... but not here.
class Bifunctor f where bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
class Bifunctor f => Biapplicative f where bipure :: a -> b -> f a b biap :: f (a -> b) (c -> d) -> f a c -> f b d class Biapplicative m => Bimonad m where bibind :: m a b -> (a -> b -> m c d) -> m c d bireturn :: a -> b -> m a b bireturn = bipure bilift :: Biapplicative f => (a -> b) -> (c -> d) -> f a c -> f b d bilift f g = biap $ bipure f g bilift2 :: Biapplicative f => (a -> b -> c) -> (x -> y -> z) -> f a x -> f b y -> f c z bilift2 f g = biap . biap (bipure f g)
instance Bifunctor (,) where bimap f g (x,y) = (f x, g y) instance Biapplicative (,) where bipure x y = (x,y) biap (f,g) (x,y) = (f x, g y) instance Bimonad (,) where bibind (x,y) f = f x y
data Maybe2 a b = Fst a | Snd b | None --or data Or a b = Both a b | This a | That b | Nope
(a -> c, b -> d) -> (l a b -> l c d, r a b -> r c d)
class (Bifunctor l, Bifunctor r) => Bimonad l r where bireturn :: (a -> l a b, b -> r a b) bijoin :: (l (l a b) (r a b) -> l a b, r (l a b) (r a b) -> r a b)
class (Bifunctor l, Bifunctor r) => Bimonad l r where bireturnl :: a -> l a b bireturnr :: b -> r a b bijoinl :: l (l a b) (r a b) -> l a b bijoinr :: r (l a b) (r a b) -> r a b
bibindl :: l a b -> (a -> l c d) -> (b -> r c d) -> l c d bibindl lab l r = bijoinl (bimap l r lab) bibindr :: r a b -> (a -> l c d) -> (b -> r c d) -> r c d bibindr rab l r = bijoinr (bimap l r rab)
class RelativeBimonad j m where bireturn :: j a b -> m a b bibind :: m a b -> (j a b -> m c d) -> m c d
bireturn jab `bibind` k = k jab m `bibind` bireturn = m m `bibind` (\jab -> k jab `bibind` h) = (m `bibind` k) `bibind` h
import qualified Data.Sequence as S import qualified Data.Foldable as F import System.Random import Control.DeepSeq import Criterion.Main import Test.QuickCheck import Control.Exception ( evaluate ) instance (Arbitrary a) => Arbitrary (S.Seq a) where arbitrary = fmap S.fromList arbitrary instance NFData a => NFData (S.Seq a) where rnf = F.foldr seq () funs :: [(String, S.Seq Int -> Int)] funs = [ ("seqDirect" , seqDirect) , ("seqFoldr" , seqFoldr) , ("seqFoldl , ("seqSplit 1" , (seqSplit 1)) , ("seqSplit 2" , (seqSplit 2)) , ("seqSplit 4" , (seqSplit 4)) , ("seqSplit 8" , (seqSplit 8)) , ("seqSplit 16" , (seqSplit 16)) , ("seqSplit 32" , (seqSplit 32)) ] main :: IO () main = do mapM_ (\(_,f) -> quickCheck (\xs -> seqDirect xs == f xs)) funs gen <- newStdGen let inpt = S.fromList . take 100000 $ randoms gen evaluate (rnf inpt) defaultMain [ bench n (nf f inpt) | (n,f) <- funs ] seqDirect :: S.Seq Int -> Int seqDirect v = case S.viewl v of S.EmptyL -> 0 x S.:< xs -> x + seqDirect xs seqFoldr :: S.Seq Int -> Int seqFoldr = F.foldr (+) 0 seqFoldl seqFoldl seqSplit :: Int -> S.Seq Int -> Int seqSplit 1 xs = seqFoldr xs seqSplit _ xs | S.null xs = 0 seqSplit n xs = let (a, b) = S.splitAt (S.length xs `div` n) xs sa = seqFoldr a sb = seqSplit (n-1) b in sa + sb
seqFoldr :: S.Seq Int -> Int seqFoldr = F.foldr (+) 0
./seq-customized +RTS -s -A128M [Length] [Performance of function seqFoldr] 25000: mean: 1.096352 ms, lb 1.083301 ms, ub 1.121152 ms, ci 0.950 50000: mean: 2.542133 ms, lb 2.514076 ms, ub 2.583209 ms, ci 0.950 100000: mean: 6.068437 ms, lb 5.951889 ms, ub 6.237442 ms, ci 0.950 200000: mean: 14.41332 ms, lb 13.95552 ms, ub 15.21217 ms, ci 0.950
[Length] [Performance of function seqFoldr] 1x: mean: 1.00 = 1*1.00 2x: mean: 2.32 = 2*1.16 4x: mean: 5.54 = 4*1.39 8x: mean: 13.15 = 8*1.64
seqSplit n xs = let (a, b) = S.splitAt (S.length xs `div` n) xs sa = seqFoldr a sb = seqSplit (n-1) b in sa + sb
(length xs)/n = (length a) -------------------------- 100000/32 = 3125 (100000-3125)/31 = 3125 (100000-2*3125)/30 = 3125 ... (100000-30*3125)/2 = 3125
benchmarking seqFoldr collecting 100 samples, 1 iterations each, in estimated 2.516484 s bootstrapping with 100000 resamples mean: 24.93222 ms, lb 24.72772 ms, ub 25.15255 ms, ci 0.950 std dev: 1.081204 ms, lb 938.4503 us, ub 1.332666 ms, ci 0.950 found 1 outliers among 100 samples (1.0%) variance introduced by outliers: 0.999% variance is unaffected by outliers benchmarking seqFoldr' collecting 100 samples, 1 iterations each, in estimated 902.7004 ms bootstrapping with 100000 resamples mean: 11.05375 ms, lb 10.68481 ms, ub 11.42519 ms, ci 0.950 std dev: 1.895777 ms, lb 1.685334 ms, ub 2.410870 ms, ci 0.950 found 1 outliers among 100 samples (1.0%) variance introduced by outliers: 1.000% variance is unaffected by outliers benchmarking seqFoldl' collecting 100 samples, 1 iterations each, in estimated 862.4077 ms bootstrapping with 100000 resamples mean: 10.35651 ms, lb 9.947395 ms, ub 10.73637 ms, ci 0.950 std dev: 2.011693 ms, lb 1.875869 ms, ub 2.131425 ms, ci 0.950 variance introduced by outliers: 1.000% variance is unaffected by outliers
$ ghc --make -dynamic -shared -fPIC foo.hs -o libfoo.so $ ldd libfoo.so linux-vdso.so.1 => (0x00007fff125ff000) libHSbase-4.2.0.2-ghc6.12.3.so => /usr/lib/ghc-6.12.3/base-4.2.0.2/libHSbase-4.2.0.2-ghc6.12.3.so (0x00007f7d5fcbe000) libHSinteger-gmp-0.2.0.1-ghc6.12.3.so => /usr/lib/ghc-6.12.3/integer-gmp-0.2.0.1/libHSinteger-gmp-0.2.0.1-ghc6.12.3.so (0x00007f7d5faac000) libgmp.so.10 => /usr/lib/libgmp.so.10 (0x00007f7d5f816000) libHSghc-prim-0.2.0.0-ghc6.12.3.so => /usr/lib/ghc-6.12.3/ghc-prim-0.2.0.0/libHSghc-prim-0.2.0.0-ghc6.12.3.so (0x00007f7d5f591000) libHSffi-ghc6.12.3.so => /usr/lib/ghc-6.12.3/libHSffi-ghc6.12.3.so (0x00007f7d5f383000) libc.so.6 => /lib/libc.so.6 (0x00007f7d5f022000) /lib/ld-linux-x86-64.so.2 (0x00007f7d60661000) $ ghc foo.hs $ ldd foo linux-vdso.so.1 => (0x00007fff2d3ff000) libgmp.so.10 => /usr/lib/libgmp.so.10 (0x00007f50014ec000) libm.so.6 => /lib/libm.so.6 (0x00007f5001269000) librt.so.1 => /lib/librt.so.1 (0x00007f5001061000) libdl.so.2 => /lib/libdl.so.2 (0x00007f5000e5d000) libc.so.6 => /lib/libc.so.6 (0x00007f5000afc000) libpthread.so.0 => /lib/libpthread.so.0 (0x00007f50008df000) /lib/ld-linux-x86-64.so.2 (0x00007f5001759000)
$ ghc --make -shared -fPIC foo.hs -o libfoo.so Linking libfoo.so ... /usr/bin/ld: foo.o: relocation R_X86_64_32S against `stg_CAF_BLACKHOLE_info foo.o: could not read symbols: Bad value collect2: ld returned 1 exit status
extern void CAT (__stginit_, MODULE) (void); static void library_init (void) __attribute__ ((constructor)); static void library_init (void) { static char *argv[] = { STR (MODULE) ".so", 0 }, **argv_ = argv; static int argc = 1; hs_init (&argc, &argv_); hs_add_root (CAT (__stginit_, MODULE)); } static void library_exit (void) __attribute__ ((destructor)); static void library_exit (void) { hs_exit (); }
Library x ... ghc-options: -O2 -Wall -fno-warn-missing-signatures -fwarn-incomplete-patterns -fno-warn-name-shadowing Executable y ... ghc-options: -O2 -Wall -fno-warn-missing-signatures -fwarn-incomplete-patterns -fno-warn-name-shadowing
echorequest :: TXT echorequest = TXT { f_TXT_anytxt = Just "Ping" } echoreply :: TXT echoreply = TXT { f_TXT_anytxt = Just "Pong" } serverFunc :: a -> (BinaryProtocol Handle, BinaryProtocol Handle) -> IO Bool serverFunc a (h1,h2) = do let t1 = getTransport h1 dat <- read_TXT h1 -- the following two lines are only for debugging putStrLn "Recieved data:" print dat write_TXT h1 echoreply tFlush t1 -- the following line is for debugging putStrLn "Data written" return False main :: IO () main = do runBasicServer () serverFunc 4390 putStrLn "Server stopped"
main :: IO () main = do h <- connectTo "127.0.0.1" $ PortNumber 4390 let proto = BinaryProtocol h putStrLn "Client started" let tryOnePing c i = do write_TXT proto echorequest putStrLn "ping sent" tFlush h w <- read_TXT proto putStrLn "pong received" return $ if w == echoreply then c+1 else c c <- foldM tryOnePing 0 [0 .. 1000] tClose h print (c, 10000 - c)
data TestVector = TestVector !Double !Double !Double !Double addVec :: TestVector -> TestVector -> TestVector addVec (TestVector x1 y1 z1 w1) (TestVector x2 y2 z2 w2) = TestVector (x1 + x2) (y1 + y2) (z1 + z2) (w1 + w2)
ghc -tmpdir tmp -hidir hi -odir obj -fext-core -fexcess-precision -funbox-strict-fields -threaded -rtsopts -fwarn-missing-signatures -Wall -O2 Main.hs -o main
module Main where data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show) insert :: (Ord a) => a -> Tree a -> Tree a insert x EmptyTree = Node x EmptyTree EmptyTree insert x (Node a left right) | x == a = Node a left right | x < a = Node a (insert x left) right | x > a = Node a left (insert x right) main :: IO() main = do let nums = [1..10]::[Int] print . foldr insert EmptyTree $ nums
test.hs|6| 1: || Warning: Pattern match(es) are non-exhaustive || In an equation for `insert
insert :: (Ord a) => a -> Tree a -> Tree a insert x EmptyTree = Node x EmptyTree EmptyTree insert x (Node a left right) | x == a = Node a left right | x < a = Node a (insert x left) right | otherwise = Node a left (insert x right)
insert :: (Ord a) => a -> Tree a -> Tree a insert x EmptyTree = Node x EmptyTree EmptyTree insert x (Node a left right) = case x `compare` a of EQ -> Node a left right LT -> Node a (insert x left) right GT -> Node a left (insert x right)
contains :: (Ord a) => a -> Tree a -> Bool contains _ EmptyTree = False contains x (Node a left right) = case x `compare` a of EQ -> True ...
insert :: (Ord a) => a -> Tree a -> Tree a insert x EmptyTree = Node x EmptyTree EmptyTree insert x (Node a left right) = Node a newLeft newRight where comparison = x `compare` a newLeft = if comparison == LT then insert x left else left newRight = if comparison == GT then insert x right else right
Prelude> let x = 5::Int Prelude> sqrt (fromIntegral x) 2.23606797749979
data Serialized a = Serialized { packetSize :: Int , packetData :: ByteArray serialize :: a -> IO (Serialized a) deserialize :: Serialized a -> IO a
Prelude> 1/0 Infinity Prelude> :t 1/0 1/0 :: (Fractional t) => t Prelude> let inf=1/0 Prelude> filter (>=inf) [1..]
data Infinitable a = Regular a | NegativeInfinity | PositiveInfinity deriving (Eq, Show) instance Ord a => Ord (Infinitable a) where compare NegativeInfinity NegativeInfinity = EQ compare PositiveInfinity PositiveInfinity = EQ compare NegativeInfinity _ = LT compare PositiveInfinity _ = GT compare _ PositiveInfinity = LT compare _ NegativeInfinity = GT compare (Regular x) (Regular y) = compare x y main = let five = Regular 5 pinf = PositiveInfinity::Infinitable Integer ninf = NegativeInfinity::Infinitable Integer results = [(pinf > five), (ninf < pinf), (five > ninf)] in do putStrLn (show results)
λ: let infinity = (read "Infinity")::Double λ: infinity > 1e100 True λ: -infinity < -1e100 True
type Bound a = Maybe a withinBounds :: (Num a, Ord a) => Bound a -> Bound a -> a -> Bool withinBounds lo hi v = maybe True (<=v) lo && maybe True (v<=) hi
for all x>0 in R, .. -inf < -x < -d < -d^2 < .. < 0 < .. < d^2 < d < x < inf < inf^2 < .. where d = 1/inf.
factors :: Int -> [Int] factors n = [x | x <- [1..n], n `mod` x == 0] prime :: Int -> Bool prime n = factors n == [1,n]
take 0 ( _) = [] take n ( []) = [] take n (x:xs) = x : (take (n-1) xs)
take 10 ([1..] ++ [0]) take 10 (1 : ([2..] ++ [0])) 1 : take 9 ([2..] ++ [0]) 1 : take 9 (2 : ([3..] ++ [0])) 1 : 2 : take 8 ([3..] ++ [0]) 1 : 2 : take 8 (3 : ([4..] ++ [0])) 1 : 2 : 3 : take 7 ([4..] ++ [0]) ... 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : take 0 ([11..] ++ [0]) 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : []
( []) == ( []) = True (x:xs) == (y:ys) = (x == y) && (xs == ys) ( _) == ( _) = False
prime 6 factors 6 == [1,6] ??? == [1,6] 1 : ??? == [1,6] ??? == [6] 2 : ??? == [6] False
{- class C a where f :: a -> a instance C [[a]] => C [a] where f = id g x = x + f [x]
class Mul a b c | a b -> c where mul :: a -> b -> c instance Mul a b c => Mul a [b] [c] where mul a = map (mul a) f b x y = if b then mul x [y] else y
class Mul type MulT a b mul instance Mul type MulT a [b] = [MulT a b] mul g b x y = if b then mul
import Data.Aeson (decode) import Data.Text (Text) import Data.ByteString.Lazy (ByteString) import Data.String.Conversions (cs) decodeTextStoredJson decodeTextStoredJson
list0, list1, list2 :: [a] -> a list0 l = l !! 0 list1 l = l !! 1 list2 l = l !! 2 -- etc. -- Or mkList0, mkList1, mkList2 :: a -> [a] mkList0 _ = [] mkList1 a = [a] mkList2 a = [a,a] -- etc.
factorial :: Integer -> Integer factorial 1 = 1 factorial (n + 1) = (n + 1) * factorial n
factorial = fixpoint (\ff n -> if n == 1 then 1 else n * ff(n-1))
data Paradox a = Self (Paradox a -> a) fixpoint f = let half (Self twin) = f (twin (Self twin)) in half (Self half)
fact :: Int -> Int fact = fix (\f n -> if n == 0 then 1 else n * (f (n-1)))
Prelude> (let fib n = if n == 1 then 1 else n * fib(n-1) in fib ) 4 24
Prelude> fix f = f (fix f) Prelude> fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 6 720
import System.IO main :: IO () main = do h <- openFile "test.txt" ReadMode xs <- getlines h sequence_ $ map putStrLn xs getlines :: Handle -> IO [String] getlines h = hGetContents h >>= return . lines
import System.IO main :: IO () main = do xs <- withFile "test.txt" ReadMode getlines sequence_ $ map putStrLn xs getlines :: Handle -> IO [String] getlines h = hGetContents h >>= return . lines
import System.IO main :: IO () main = withFile "test.txt" ReadMode $ \h -> getlines h >>= mapM_ putStrLn getlines :: Handle -> IO [String] getlines h = lines `fmap` hGetContents h
main = withFile "test.txt" ReadMode $ \handle -> do xs <- getlines handle sequence_ $ map putStrLn xs
main :: IO () main = do xs <- fmap lines $ readFile "test.txt" mapM_ putStrLn xs
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
main = withFile "test.txt" ReadMode $ \h -> do xs <- getlines h sequence_ $ map putStrLn xs
main = do xs <- withFile "test.txt" ReadMode getlines sequence_ $ map putStrLn xs
main = withFile "test.txt" ReadMode$ \h -> do xs <- getlines h mapM_ putStrLn xs
import Control.DeepSeq forceM :: (NFData a, Monad m) => m a -> m a forceM m = do val <- m return $!! val main = do xs <- withFile "text.txt" ReadMode (forceM . getlines) ...
-------------------------------------------------------------------------- Typechecking Stmts in GHCi Here is the grand plan, implemented in tcUserStmt What you type The IO [HValue] that hscStmt returns ------------- ------------------------------------ let pat = expr ==> let pat = expr in return [coerce HVal x, coerce HVal y, ...] bindings: [x,y,...] pat <- expr ==> expr >>= \ pat -> return [coerce HVal x, coerce HVal y, ...] bindings: [x,y,...] expr (of IO type) ==> expr >>= \ it -> return [coerce HVal it] [NB: result not printed] bindings: [it] expr (of non-IO type, ==> let it = expr in print it >> return [coerce HVal it] result showable) bindings: [it] expr (of non-IO type, result not showable) ==> error
doNotation4 = do let val1 = expr1 val2 = expr2 {- ... etc. -} valN = exprN act1 act2 {- ... etc. -} actN
translated4 = let val1 = expr1 val2 = expr2 {- ... etc. -} valN = exprN in do act1 act2 {- ... etc. -} actN
dropAB :: String -> String dropAB [] = [] dropAB (x:[]) = x:[] dropAB (x:y:xs) = if x== then dropAB xs else x:(dropAB $ y:xs)
dropR :: BS.ByteString -> BS.ByteString dropR [] = [] dropR (x:[]) = [x] <...>
Couldn against inferred type `[a]' In the pattern: [] In the definition of `dropR
dropR :: BS.ByteString -> BS.ByteString dropR empty = empty dropR (x cons empty) = x cons empty <...>
{- import Data.ByteString (ByteString, cons, uncons, singleton, empty) import Data.ByteString.Internal (c2w) dropR :: ByteString -> ByteString dropR (uncons -> Nothing) = empty dropR (uncons -> Just (x,uncons -> Nothing)) = singleton x dropR (uncons -> Just (x,uncons -> Just(y,xs))) = if x == c2w then dropR xs else cons x (dropR $ cons y xs)
module Test where import Data.ByteString as BS import Data.Text as T import Data.Text.IO as TIO import Data.Text.Encoding removeAll :: Char -> Text -> Text removeAll c t = T.filter (/= c) t main = do bytes <- BS.readFile "test.txt" TIO.putStr $ removeAll
{- import Data.ByteString (ByteString, cons, uncons, singleton, empty) import Data.ByteString.Internal (c2w) infixr 5 :< pattern b :< bs <- (uncons -> Just (b, bs)) pattern Empty <- (uncons -> Nothing) dropR :: ByteString -> ByteString dropR Empty = empty dropR (x :< Empty) = singleton x dropR (x :< y :< xs) | x == c2w | otherwise = cons x (dropR (cons y xs))
{- import qualified Data.ByteString as BS import Data.ByteString (ByteString, singleton) import Data.ByteString.Internal (c2w) import Data.Word class ListLike l where type Elem l empty :: l uncons :: l -> Maybe (Elem l, l) cons :: Elem l -> l -> l instance ListLike ByteString where type Elem ByteString = Word8 empty = BS.empty uncons = BS.uncons cons = BS.cons instance ListLike [a] where type Elem [a] = a empty = [] uncons [] = Nothing uncons (x:xs) = Just (x, xs) cons = (:)
-- dropR :: [Word8] -> [Word8] -- dropR :: ByteString -> ByteString dropR :: (ListLike l, Elem l ~ Word8) => l -> l dropR Empty = empty dropR (x :< Empty) = cons x empty dropR (x :< y :< xs) | x == c2w | otherwise = cons x (dropR (cons y xs))
import Data.ByteString.Internal (w2c) infixr 5 :• pattern b :• bs <- (w2c -> b) :< bs dropR :: (ListLike l, Elem l ~ Word8) => l -> l dropR Empty = empty dropR (x :< Empty) = cons x empty dropR ( dropR (x :< y :< xs) = cons x (dropR (cons y xs))
Couldn against inferred type `[a]' In the pattern: [] In the definition of `dropR
data Registers = Reg {...} data ST = ST {registers :: Registers, memory :: Array Int Int} newtype Op a = Op {runOp :: ST -> (ST, a)} instance Monad Op where return a = Op $ \st -> (st, a) (>>=) stf f = Op $ \st -> let (st1, a1) = runOp stf st (st2, a2) = runOp (f a1) st1 in (st2, a2)
getState :: (ST -> a) -> Op a getState g = Op (\st -> (st, g st) updState :: (ST -> ST) -> Op () updState g = Op (\st -> (g st, ()))
runOp (do x <- getLine; setMem 10 ... (read x :: Int) ... ) st
import Data.Array import Control.Monad.Trans data Registers = Reg { foo :: Int } data ST = ST {registers :: Registers, memory :: Array Int Int} newtype Op m a = Op {runOp :: ST -> m (ST, a)} instance Monad m => Monad (Op m) where return a = Op $ \st -> return (st, a) (>>=) stf f = Op $ \st -> do (st1, a1) <- runOp stf st (st2, a2) <- runOp (f a1) st1 return (st2, a2) instance MonadTrans Op where lift m = Op $ \st -> do a <- m return (st, a) getState :: Monad m => (ST -> a) -> Op m a getState g = Op $ \st -> return (st, g st) updState :: Monad m => (ST -> ST) -> Op m () updState g = Op $ \st -> return (g st, ()) testOpIO :: Op IO String testOpIO = do x <- lift getLine return x test = runOp testOpIO
liftIO :: IO a -> Op a liftIO io = Op $ \st -> do x <- io return (st, x)
import Control.Monad.Trans class Monad m => MonadIO m where liftIO :: IO a -> m a
handyCheck limit = check defaultConfig { configMaxTest = limit , configEvery = \_ _ -> "" }
quickCheckWith stdArgs { maxSuccess = 5000 } someProp
return [] main = $forAllProperties (quickCheckWithResult stdArgs { maxSuccess = 500 })
import System foo :: Show a => Int -> a -> IO () foo 0 x = print x foo n x = foo (n-1) [x] main = do [num_lists] <- getArgs foo (read num_lists) 0
data MkList = MkList (forall a. a -> [a]) singleton = MkList (\x -> [x])
data SomeShow = forall a. Show a => SomeShow a instance Show SomeShow where show (SomeShow a) = show a
template<typename T> String showVoid(void *x) { show(*(T*)x); } class SomeShow { private: void *m_data; String (*m_show)(void*); public: template<typename T> SomeShow(T x) : m_data(new T(x)) , m_show(&showVoid<T>) { } String show() { return m_show(m_data); } }; String show(SomeShow x) { return x.show(); }
data MonadDict m = MonadDict { return :: forall a. a -> m a, (>>=) :: forall a b. m a -> (a -> m b) -> m b }
-- | Test whether a list is empty. null :: [a] -> Bool null [] = True null (_:_) = False
mNull :: [a] -> Bool mNull [] = True mNull _ = False
-- | Test whether a list is empty. null :: [a] -> Bool null (_:_) = False null _ = True
data FavoriteFood = Pizza | SesameSpinachPancake | ChanaMasala
-- by the definition of a right operator section foobar
fork (f,g) x = (f x, g x) -- == (f &&& g) prod (f,g) x = (f $ fst x, g $ snd x) -- == (f *** g) pmap f (x,y) = (f x, f y) -- == (f *** f) dup x = (x,x)
foobar = (\(a,b)->[a,b]) . fork (id,reverse) = (\(a,b)->[a,b]) . (id &&& reverse) = (\(a,b)->[a,b]) . (id *** reverse) . dup = join $ curry ( (\(a,b)->[a,b]) . second reverse)
ghci> const 1 (error "noo!") 1 ghci> const 1 $! (error "noo!") *** Exception: noo!
data Cars = Brakes | Wheels | Engine data Computers = Processor | RAM | HardDrive class Repairable a where is_reparaible :: a -> Bool instance Repairable Cars where is_repairable (Brakes) = True is_repairable (Wheels) = False is_repairable (Engine) = False instance Repairable Computers where is_repairable (Processor) = False is_repairable (RAM) = False is_repairable (HardDrive) = True checkState :: (Reparaible a) => a -> ... checkState a = ...
checkState :: (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b checkState is_repairable repairs destroy a = if (is_repairable a) then repairs a else destroy a
data Repairable a = Repairable { getRepairable :: a , isRepairable :: Bool , canBeRepairedWith :: [Tool] -> Bool -- just to give an example of a function }
$ ghci GHCi, version 7.0.3: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... <command line>: can
$ ldd /usr/local/lib/ghc-7.0.3/ghc linux-vdso.so.1 => (0x00007fffe5f5c000) libncursesw.so.5 => /lib64/libncursesw.so.5 (0x0000003ee7000000) librt.so.1 => /lib64/librt.so.1 (0x0000003ee5800000) libutil.so.1 => /lib64/libutil.so.1 (0x0000003ef3000000) libdl.so.2 => /lib64/libdl.so.2 (0x0000003ee5000000) libgmp.so.3 => /usr/lib64/libgmp.so.3 (0x0000003ee4400000) libm.so.6 => /lib64/libm.so.6 (0x0000003ee4c00000) libpthread.so.0 => /lib64/libpthread.so.0 (0x0000003ee5400000) libc.so.6 => /lib64/libc.so.6 (0x0000003ee4800000) libtinfo.so.5 => /lib64/libtinfo.so.5 (0x0000003ef3400000) /lib64/ld-linux-x86-64.so.2 (0x0000003ee4000000)
[] := λc. λn. n [1,2,3] := λc. λn. c 1 (c 2 (c 3 n))
mapChurch :: (t->s) -> (Churchlist t u) -> (Churchlist s u) mapChurch f l = \c n -> l (c.f) n
(c 1 (c 2 (c 3 n))) -- replace `c` with `(c . f)`, and `n` with `n` ((c . f) 1 ((c . f) 2) ((c . f) 3 n))) -- simplify `(foo . bar) baz` to `foo (bar baz)` (c (f 1) (c (f 2) (c (f 3) n))
[] := λc. λn. n [1,2,3] := λc. λn. c 1 (c 2 (c 3 n))
cons 1 (cons 2 (cons 3 nil))) = cons 1 (cons 2 (cons 3 (\c n -> n)) = cons 1 (cons 2 (\c n -> c 3 ((\c cons 1 (cons 2 (\c n -> c 3 n)) = cons 1 (\c n -> c 2 ((\c cons 1 (\c n -> c 2 (c 3 n)) = \c n -> c 1 ((\c \c n -> c 1 (c 2 (c 3 n)) =
mapChurch f nil = \c n -> nil (c.f) n = \c n -> (\c = \c n -> n = nil
mapChurch f (cons x xs) = \c n -> (cons x xs) (c.f) n = \c n -> (\c = \c n -> (c.f) x (xs (c.f) n) -- (c.f) x = c (f x) by definition of (.) = \c n -> c (f x) (xs (c.f) n) = \c n -> c (f x) ((\c = \c n -> c (f x) ((mapChurch f xs) c n) = cons (f x) (mapChurch f xs)
-- Tell me... type Churchlist t u = (t -> u -> u) -- ...how to handle a pair -> u -- ...and how to handle an empty list -> u -- ...and then I -- the type you want
foldr :: (t -> u -> u) -> u -> [t] -> u foldr k z [] = z foldr k z (x:xs) = k x (foldr k z xs)
copyList :: [t] -> [t] copyList xs = foldr (:) [] xs
-- Note that the definitions of nil and cons mirror the two foldr equations! nil :: Churchlist t u nil = \k z -> z cons :: t -> Churchlist t u -> Churchlist t u cons x xs = \k z -> k x (xs k z) copyChurchlist :: ChurchList t u -> Churchlist t u copyChurchlist xs = xs cons nil
map :: (a -> b) -> [a] -> [b] map f xs = foldr (\x xs
filter :: (a -> Bool) -> [a] -> [a] append :: [a] -> [a] -> [a] -- Return first element of list that satisfies predicate, or Nothing find :: (a -> Bool) -> [a] -> Maybe a
- | Constants tempFilePath :: String tempFilePath = "/tmp/restrq.txt" -- | Helper Functions -- Bytestring Conversion strictToLazy :: B.ByteString -> BL.ByteString strictToLazy x | B.null x = BL.Empty | otherwise = BL.Chunk x BL.Empty lazyToStrict :: BL.ByteString -> B.ByteString lazyToStrict = B.concat . BL.toChunks getRequestString :: MonadSnap m => m B.ByteString getRequestString = do message <- getRequestBody return (lazyToStrict message) -- | Action for PUT request action :: Application () action = do message <- getRequestString liftIO $ B.writeFile tempFilePath (B8.append (B8.pack "--- REST BODY ---\n") message) -- | /mytest (GET and PUT requests possible) mytest :: Application () mytest = method GET (writeBS "Get request") <|> method PUT action -- | The main entry point handler. site :: Application () site = route [ ("/", index) , ("/mytest", mytest) ] <|> serveDirectory "resources/static"
map f (map g []) = [] map f (map g (x:xs)) = f (g x) : map f (map g xs)
Prelude> :t 3 3 :: (Num t) => t Prelude> let x = 3 Prelude> :t x x :: Integer
> :set -XNoMonomorphismRestriction > let y = 3 > :t y y :: (Num t) => t
> :t y * (2.5 :: Float) y * (2.5 :: Float) :: Float > :t y * (3 :: Int) y * (3 :: Int) :: Int
sudo /Library/Frameworks/GHC.framework/Versions/Current/Tools/Uninstaller
rm -r ~/.cabal rm -r ~/.ghc rm -r ~/Library/Haskell
echo >timestamp [activity] sudo find -x / -newer timestamp -print >snapshot.txt
set -x sudo rm -rf /Library/Frameworks/GHC.framework sudo rm -rf /Library/Frameworks/HaskellPlatform.framework sudo rm -rf /Library/Haskell rm -rf ~/.cabal rm -rf ~/.ghc rm -rf ~/Library/Haskell find /usr/bin /usr/local/bin -type l | \ xargs -If sh -c egrep cut -f 1 -d sudo rm -f `cat /tmp/hs-bin-links`
mv ~/.cabal/config /tmp/cabal-config 2>/dev/null || true mv ~/.ghc/gchi.conf /tmp/ghci-config 2>/dev/null || true
mkdir ~/.cabal mkdir ~/.ghc cp /tmp/cabal-config ~/.cabal/config 2>/dev/null || true cp /tmp/ghci-config ~/.ghc/gchi.conf 2>/dev/null || true
for package in `ls ~/.cabal/lib/`; do if [ ! -d ~/.cabal/lib/${package}/ghc-7.0.3 ]; then echo $package; else echo "OK for $package"; fi; done
import Data.Text (pack, unpack) import Data.Text.ICU (LocaleName(Locale), toLower) main = do let trLocale = Locale "tr-TR" upStr = "ÇIİĞÖŞÜ" lowStr = unpack $ toLower trLocale $ pack upStr putStrLn $ "toLower " ++ upStr ++ " gives " ++ lowStr
import qualified Data.Char as Char toLower toLower x = Char.toLower x
data Polygon = Quad Point Point | Triangle Point Point Point | RegularNGon Int Radius | ...
data Shape = IsPoint Point | IsLine Line | IsPolygon Polygon data Point = Point { x :: Int, y :: Int } data Line = Line { a :: Point, b :: Point } data Polygon = IsTriangle Triangle | IsQuad Quad | ...
{- ... class Shape a where bounds :: a -> AABB draw :: a -> IO () data AnyShape = forall a. Shape a => AnyShape a
data Line = Line Point Point instance Shape Line where ... data Circle= Circle {center :: Point, radius :: Double} instance Shape Circle where ... ...
shapes = [AnyShape(Line a b), AnyShape(Circle a 3.0), AnyShape(Circle b 1.8)]
drawIn box xs = sequence_ [draw s | AnyShape s <- xs, bounds s `hits` box]
get :: m s --or equivalently (s -> m a) -> m a set :: s -> m () --or (s,m a) -> m a runState :: m a -> s -> (a,s)
data StateF s a = Get (s -> a) | Set s a deriving Functor
get = Impure (Get Pure) set x = Impure (Set x (Pure ())
runState (Pure a) s = (a,s) runState (Impure (Get f)) s = runState (f s) s runState (Impure (Set s next)) _ = runState next s
data StopF a = StopF deriving Functor maybe _ f (Pure a) = f a maybe b _ (Impure Stop) = b
data f :+: g a = Inl (f a) | Inr (g a) instance (Functor f, Functor g) => Functor (f :+: g) where fmap f (Inl x) = Inl (fmap f x) fmap f (Inr x) = Inr (fmap f x) compAlg :: (f a -> a) -> (g a -> a) -> f :+: g a -> a compAlg f _ (Inl x) = f x compAlf _ g (Inr x) = g x
freeAlg :: (f a -> a) -> Free f a -> a freeAlg _ (Pure a) = a freeAlg f (Impure x) = f $ fmap (freeAlg f) x
class Calculator f where eval :: f Integer -> Integer
data Mult a = Mult a a deriving Functor instance Calculator Mult where eval (Mult a b) = a*b data Add a = Add a a deriving Functor instance Calculator Add where eval (Add a b) = a+b data Neg a = Neg a deriving Functor instance Calculator Neg where eval (Neg a) = negate a instance Calculator (Const Integer) where eval (Const a) = a data Signum a = Signum a deriving Functor instance Calculator Signum where eval (Signum a) = signum a data Abs a = Abs a deriving Functor instance Calculator Abs where eval (Abs a) = abs a
instance (Calculator f, Calculator g) => Calculator (f :+: g) where eval = compAlg eval
newtype Numerical a = Numerical ( Free (Mult :+: Add :+: Neg :+: Const Integer :+: Signum :+: Abs) a deriving (Functor, Monad)
class Pretty f where pretty :: f String -> String instance Pretty Mult where pretty (Mult a b) = a ++ "*" ++ b
runState (Pure a) s = (a,s) runState (Impure (Get f)) s = runState (f s) s runState (Impure (Set s next)) _ = runState next s
runState (return a) = return a runState (x >>= f) = (runState x) >>= (runState f) runState (set x) = set x runState get = get
runState (return a) = (Pure a) = \s -> (a,s) runState (set x) = runState (Impure (Set x (Pure ()))) = \_ -> runState (Pure ()) x = \_ -> (\s -> (a,s)) x = \_ -> (a,x) runState get = runState (Impure (Get Pure)) = \s -> runState (Pure s) s = \s -> (s,s)
toMaybe :: Free f a -> Maybe a toMaybe (Pure a) = Just a toMaybe (Impure _) = Nothing
data StateF s a = Put s a | Get (s -> a). -- NB: This functor is itself a free functor over a type constructor -- which is sometimes called StateI [1], rendering Free (StateF s) what -- Oleg and Hiromi Ishii call a "freer monad" [2].
run :: Free (StateF s) a -> State s a run (Pure x) = return x run (Roll (Put s m)) = put s >> run m run (Roll (Get k)) = get >>= run . k
do b <- [False,True] -- not of the form (return _) if b then return 47 else [] -- The result is the singleton list [47], so of the form (return _).
main = do args@(~( aString : aInteger : [] ) ) <- getArgs let parsed@( ~[(n,_)] ) = reads aInteger if length args /= 2 || L.null parsed then do name <- getProgName hPutStrLn stderr $ "usage: " ++ name ++ " <string> <integer>" exitFailure else do doStuffWith aString n
main :: IO () main = do args <- getArgs case args of [aString, aInteger] | [(n,_)] <- reads aInteger -> doStuffWith aString n _ -> do name <- getProgName hPutStrLn stderr $ "usage: " ++ name ++ " <string> <integer>" exitFailure
case args of [aString, reads -> [(n,_)]] -> doStuffWith aString n _ -> ...
-- file: repstring.hs import Options.Applicative import Data.Monoid ((<>)) data Sample = Sample { string :: String , n :: Int , flip :: Bool } replicateString :: Sample -> IO () replicateString (Sample string n flip) = do if not flip then putStrLn repstring else putStrLn $ reverse repstring where repstring = foldr (++) "" $ replicate n string sample :: Parser Sample sample = Sample <$> argument str ( metavar "STRING" <> help "String to replicate" ) <*> argument auto ( metavar "INTEGER" <> help "Number of replicates" ) <*> switch ( long "flip" <> short <> help "Whether to reverse the string" ) main :: IO () main = execParser opts >>= replicateString where opts = info (helper <*> sample) ( fullDesc <> progDesc "Replicate a string" <> header "repstring - an example of the optparse-applicative package" )
$ ./repstring --help repstring - an example of the optparse-applicative package Usage: repstring STRING INTEGER [-f|--flip] Replicate a string Available options: -h,--help Show this help text STRING String to replicate INTEGER Number of replicates -f,--flip Whether to reverse the string $ ./repstring "hi" 3 hihihi $ ./repstring "hi" 3 -f ihihih
-- file: repstring2.hs import Options.Applicative import Data.Monoid ((<>)) import Data.Maybe (fromJust, isJust) data Sample = Sample { string :: String , n :: Int , flip :: Bool , name :: Maybe String } replicateString :: Sample -> IO () replicateString (Sample string n flip maybeName) = do if not flip then putStrLn $ repstring ++ name else putStrLn $ reverse repstring ++ name where repstring = foldr (++) "" $ replicate n string name = if isJust maybeName then fromJust maybeName else "" sample :: Parser Sample sample = Sample <$> argument str ( metavar "STRING" <> help "String to replicate" ) <*> argument auto ( metavar "INTEGER" <> help "Number of replicates" ) <*> switch ( long "flip" <> short <> help "Whether to reverse the string" ) <*> ( optional $ strOption ( metavar "NAME" <> long "append" <> short <> help "Append name" ))
import Options.Applicative doStuffWith :: String -> Int -> IO () doStuffWith s n = mapM_ putStrLn $ replicate n s parser = fmap (,) (argument str (metavar "<string>")) <*> (argument auto (metavar "<integer>")) main = execParser (info parser fullDesc) >>= (uncurry doStuffWith)
{- module Main where import Options.Generic main :: IO () main = do (n, c) <- getRecord "Example program" putStrLn $ replicate n c
$ ./OptparseGenericExample Missing: INT CHAR Usage: OptparseGenericExample INT CHAR $ ./OptparseGenericExample 5 c ccccc
data Lens s a = Lens { get :: s -> a, set :: a -> s -> s }
data Prism s a = Prism { up :: a -> s, down :: s -> Maybe a }
_Left :: Prism (Either a b) a _Left = Prism { up = Left, down = either Just (const Nothing) } _Right :: Prism (Either a b) b _Right = Prism { up = Right, down = either (const Nothing) Just }
data Wibble = Wobble { _wobble :: Int } | Wubble { _wubble :: Bool }
_ArithException :: Prism _AsyncException :: Prism -- etc.
showRead :: (Show a, Read a) => Prism String a showRead = Prism { up = show, down = listToMaybe . fmap fst . reads }
type Lens s t a b = forall p. Strong p => p a b -> p s t type Prism s t a b = forall p. Choice p => p a b -> p s t
review l x ≡ review l y -- x ≡ y -> f x ≡ f y preview l (review l x) ≡ preview l (review l y) -- rewrite both sides with the first law Just x ≡ Just y -- injectivity of Just x ≡ y
-- Bad! _CI :: FoldCase s => Prism _CI = prism λ> review _CI "FOO" == review _CI "foo" True λ> "FOO" == "foo" False
foo :: Int -> Int -> Float foo a b = fromRational $ a % b
instance Monad ((->) r) where return = const f >>= k = \ r -> k (f r) r
f :: (Int -> Int) -> Bool f g = g `seq` True *Main> f undefined *** Exception: Prelude.undefined *Main> f (\x -> undefined) True
pseudoop "seq" a -> b -> b { Evaluates its first argument to head normal form, and then returns its second argument as the result. }
-- Allow us to construct Nats mkNat :: Integer -> Nat mkNat n | n < 0 = error "cannot construct negative natural number" mkNat 0 = Z mkNat n = S $ mkNat (n-1)
data NatF a = SF a | ZF -- Aside: this is just Maybe
cata f Z = f ZF -- No subterm to fold, base case cata f (S subterm) = f $ SF $ cata f subterm -- Fold subterm first, recursive case
natToInteger :: Nat -> Integer natToInteger = cata phi where -- We only need to provide a function to fold -- a non-recursive Nat-like structure phi :: NatF Integer -> Integer phi ZF = 0 phi (SF x) = x + 1
-- We could use the type NatF (NonEmptyList a) here. -- But because NatF is Maybe, NatF (NonEmptyList a) is equal to [a]. -- Using just [a] is a lot simpler histo :: ([a] -> a) -> Nat -> a histo f = head . go where -- go :: Nat -> [a] -- This signature would need ScopedTVs go Z = [f []] go (S x) = let subvalues = go x in f subvalues : subvalues
-- Example: calculate the n-th fibonacci number fibN :: Nat -> Integer fibN = histo $ \x -> case x of (x:y:_) -> x + y _ -> 1
histo :: Functor f => (f (Cofree f a) -> a) -> Fix f -- ^ This is the fixed point of f -> a
Foldable t => (Base t a -> a) -> (t -> a) -- (1) Foldable t => (Base t (Cofree (Base t) a) -> a) -> (t -> a) -- (2) Functor f => (f (Cofree f a) -> a) -> (t -> f t) -> (t -> a) -- (3)
data instance Prim [a] x = Nil | Cons a x type instance Base [a] = Prim [a] instance Foldable [a] where project [] = Nil project (a:as) = Cons a as foldr :: (a -> b -> b) -> b -> [a] -> b foldr cons nil = cata $ \case Nil -> nil Cons a b -> cons a b
foldr :: (a -> b -> b) -> b -> [a] -> b foldr cons nil = histo $ \case Nil -> nil Cons a (b :< _) -> cons a b
tail :: [a] -> Maybe [a] tail = histo $ \case Nil -> Nothing -- empty list Cons _ (b :< x) -> case x of Nil -> Just [] -- length 1 list Cons a _ -> fmap (a:) b
histo phi = dyna phi project -- project is from the Foldable class
data NEL a = Some a | More a (NEL a) data NELf a x = Somef a | Moref a x deriving Functor
natural :: Int -> NELf Int Int natural 0 = Somef 0 natural n = Moref n (n-1)
-- here zcata :: (Comonad w, Functor f) => (a -> f a) -> (f (w (w c)) -> w b) -> (b -> c) -> a -> c zcata z k g = g . extract . c where c = k . fmap (duplicate . fmap g . c) . z dyna :: Functor f => (f (Cofree f c) -> c) -> (a -> f a) -> a -> c dyna phi z = zcata z distHisto phi takeC :: Int -> Cofree (NELf a) a -> [a] takeC 0 _ = [] takeC n (a :< Somef v) = [a] takeC n (a :< Moref v as) = a : takeC (n-1) as catalan :: Int -> Int catalan = dyna phi natural where phi :: NELf Int (Cofree (NELf Int) Int) -> Int phi (Somef 0) = 1 phi (Moref n table) = sum (zipWith (*) xs (reverse xs)) where xs = takeC n table
data ProgramData = ProgramData { pState :: ProgramState, pConfig :: ProgramConfig, pLogs :: String } complexFunction :: Int -> State ProgramData Int
betterFunction :: Int -> RWS ProgramConfig String ProgramState Int
let cur fill = do { cwd <- System.Directory.getCurrentDirectory; return (":set prompt \"" ++ cwd ++ fill ++ " \""); } :def doprompt (\_ -> cur ">") :def mycd (\dir -> System.Directory.setCurrentDirectory dir >> cur ">") :doprompt
let cur fill = do { cwd <- System.Directory.getCurrentDirectory; return (":set prompt \"" ++ cwd ++ fill ++ " \""); } :def doprompt (\_ -> cur ">") :def mycd (\dir -> System.Directory.setCurrentDirectory dir >> cur ">") :doprompt
good = do (xs1,xs2) <- copyThunk xs print $ foldl1 print $ length xs2
xsFunction :: () -> [Int] xsFunction = const [1..10000000] better = do print $ foldl1 print $ length $ xsFunction ()
let xs () = [1..1000000] good = do print $ foldl1 print $ length (xs ())
{- {- {- {- data Foo = Foo class ConvertFoo a b where convertFoo :: a -> b instance (ConvertFoo a Foo, ConvertFoo Foo b) => ConvertFoo a b where convertFoo = convertFoo . (convertFoo :: a -> Foo) evil :: Int -> String evil = convertFoo
data X class Convert a b where convert :: a -> b instance (Convert a X, Convert X b) => Convert a b where convert = convert . (convert :: a -> X) evil :: a -> b evil = convert
class Loop a where loop :: a instance Loop a => Loop a where loop = loop
... Constraint is no smaller than the instance head in the constraint: Convert a X (Use UndecidableInstances to permit this) In the instance declaration for ‘Convert a b’ ... Constraint is no smaller than the instance head in the constraint: Convert X b (Use UndecidableInstances to permit this) In the instance declaration for ‘Convert a b’
convertXX :: X -> X convertXX = convertXX . convertXX
convertAB :: A -> B convertAB = convertXB . convertAX where convertAX = convertXX . convertAX convertXX = convertXX . convertXX convertXB = convertXB . convertXX
class ConvertFoo a b where convertFoo :: a -> b instance (ConvertFoo a Foo, ConvertFoo Foo b) => ConvertFoo a b where convertFoo = ... evil :: Int -> String evil = convertFoo
convertFoo_1 :: Int -> String convertFoo_1 = convertFoo_3 . convertFoo_2 convertFoo_2 :: Int -> Foo convertFoo_2 = convertFoo_4 . convertFoo_2 convertFoo_3 :: Foo -> String convertFoo_3 = convertFoo_3 . convertFoo_4 convertFoo_4 :: Foo -> Foo convertFoo_4 = convertFoo_4 . convertFoo_4
-- This is my current "weakly typed" interface: bake :: IO Cake eat :: Cake -> IO () keep :: Cake -> IO () -- This is OK do brownie <- bake muffin <- bake eat brownie keep muffin -- Eating and having the same cake is not OK: do brownie <- bake eat brownie keep brownie -- oops! already eaten!
{- TypeFamilies, GADTs, TypeOperators, PartialTypeSignatures, DataKinds, PolyKinds import GHC.TypeLits import Data.Proxy import GHC.Exts -- Allocate a new cake type family New cs where New New (c -- Constraint satisfiable if "c" is in "cs" type family Elem c cs :: Constraint where Elem c (c Elem c (c type family Remove c cs where Remove c Remove c (c Remove c (c data Bake :: [Nat] -> [Nat] -> * -> * where Pure :: a -> Bake cs cs a Bake :: (Proxy (New cs) -> Bake (New cs Eat :: Elem c cs => Proxy c -> Bake (Remove c cs) cs Keep :: Elem c cs => Proxy c -> Bake cs cs ok :: Bake ok = Bake $ \cake1 -> Bake $ \cake2 -> Eat cake1 $ Keep cake2 $ Eat cake2 $ Pure () not_ok :: Bake not_ok = Bake $ \cake1 -> Bake $ \cake2 -> Eat cake1 $ Keep cake1 $ -- we already ate that Eat cake2 $ Pure ()
foo = Bake $ \cake1 -> Bake $ \cake2 -> Eat cake1 $ Pure () -- Error: Could not deduce (Elem (New cs0) (New cs0 + 1 : New cs0 : cs0))
{- TypeFamilies, GADTs, TypeOperators, PartialTypeSignatures, StandaloneDeriving, DataKinds, PolyKinds, NoImplicitPrelude, RebindableSyntax, DeriveFunctor import Prelude hiding (Monad(..)) import GHC.TypeLits import Data.Proxy import GHC.Exts class IxFunctor f where imap :: (a -> b) -> f i j a -> f i j b class IxFunctor m => IxMonad m where return :: a -> m i i a (>>=) :: m i j a -> (a -> m j k b) -> m i k b fail :: String -> m i j a infixl 1 >> infixl 1 >>= (>>) :: IxMonad m => m i j a -> m j k b -> m i k b ma >> mb = ma >>= const mb data IxFree f i j a where Pure :: a -> IxFree f i i a Free :: f i j (IxFree f j k a) -> IxFree f i k a liftf :: IxFunctor f => f i j a -> IxFree f i j a liftf = Free . imap Pure instance IxFunctor f => IxFunctor (IxFree f) where imap f (Pure a) = Pure (f a) imap f (Free fa) = Free (imap (imap f) fa) instance IxFunctor f => IxMonad (IxFree f) where return = Pure Pure a >>= f = f a Free fa >>= f = Free (imap (>>= f) fa) fail = error -- Old stuff for Bake type family New cs where New New (c type family Elem c cs :: Constraint where Elem c (c Elem c (c type family Remove c cs where Remove c Remove c (c Remove c (c -- Now the return type indices of BakeF directly express the change -- from the old store to the new store. data BakeF cs cs BakeF :: (Proxy (New cs) -> k) -> BakeF cs (New cs EatF :: Elem c cs => Proxy c -> k -> BakeF cs (Remove c cs) k KeepF :: Elem c cs => Proxy c -> k -> BakeF cs cs k deriving instance Functor (BakeF cs cs instance IxFunctor BakeF where imap = fmap type Bake = IxFree BakeF bake = liftf (BakeF id) eat c = liftf (EatF c ()) keep c = liftf (KeepF c ()) ok :: Bake ok = do cake1 <- bake cake2 <- bake eat cake1 keep cake2 eat cake2 -- not_ok :: Bake -- not_ok = do -- cake1 <- bake -- cake2 <- bake -- eat cake1 -- keep cake1 -- already ate it -- eat cake2
data Caked a = Caked { getCacked :: IO a } -- ^ internal constructor
beforeCake :: IO a -> (a -> Caked b) -> Caked b beforeCake a f = Caked (a >>= getCaked . f) afterCake :: Caked a -> (a -> IO b) -> Caked b afterCake (Caked a) f = Caked (a >>= f)
eat :: Cake -> Caked () eat = undefined keep :: Cake -> Caked () keep = undefined
withCake :: (Cake -> Caked b) -> IO b withCake = undefined
ghci> len = length [1..10^8] ghci> len -- Consumes 5 GiB 100000000 ghci> :quit -- Consumes 3 GiB -- Exits
Prelude> length [1..10^8] 10000000 -- pretty fast Prelude> let len = length [1..10^8] Prelude> len 10000000 -- pretty fast Prelude>
Prelude> len = length [1..10^8] Prelude> len 10000000 Prelude>
> :set +s > length [1..10^8] 100000000 (1.54 secs, 7,200,156,128 bytes) >
import Control.DeepSeq import System.CPUTime type Time = Double timed :: (NFData a) => a -> IO (a, Time) timed x = do t1 <- getCPUTime r <- return $!! x t2 <- getCPUTime let diff = fromIntegral (t2 - t1) / 10^12 return (r, diff)
timeLimited :: (NFData a) => Time -> [a] -> IO [a] timeLimited remaining [] = return [] timeLimited remaining (x:xs) = if remaining < 0 then return [] else do (y,t) <- timed x ys <- timeLimited (remaining - t) xs return (y:ys)
timeOut :: Time -> a -> IO (Maybe (a,t)) timeOut = undefined
timeLimited timeLimited timeLimited result <- timeOut remaining x case result of Nothing -> return [] Just (y,t) -> do ys <- timeLimited return (y:ys)
import Control.Concurrent.STM import Control.DeepSeq import System.Timeout type Time = Int -- | Compute as many items of a list in given timeframe (microseconds) -- This is done by running a function that computes (with `force`) -- list items and pushed them onto a `TVar [a]`. When the requested time -- expires, ghc will terminate the execution of `forceIntoTVar`, and we -- return what has been pushed onto the tvar. timeLimited :: (NFData a) => Time -> [a] -> IO [a] timeLimited t xs = do v <- newTVarIO [] _ <- timeout t (forceIntoTVar xs v) readTVarIO v -- | Force computed values into given tvar forceIntoTVar :: (NFData a) => [a] -> TVar [a] -> IO [()] forceIntoTVar xs v = mapM (atomically . modifyTVar v . forceCons) xs -- | Returns function that does actual computation and cons forceCons :: (NFData a) => a -> [a] -> [a] forceCons x = (force x:)
main = do xs <- timeLimited 100000 expensiveThing -- run for 100 milliseconds print $ length $ xs -- how many did we get? -- | Some high-cost computation expensiveThing :: [Integer] expensiveThing = sieve [2..] where sieve (p:xs) = p : sieve [x|x <- xs, x `mod` p > 0]
$ time ./timeLimited 1234 ./timeLimited 0.10s user 0.01s system 97% cpu 0.112 total
timeoutPure :: Int -> a -> IO (Maybe a) timeoutPure t a = timeout t (evaluate a)
forceIntoTVar :: (NFData a) => [a] -> TVar [a] -> IO [()] forceIntoTVar xs v = mapM (atomically . modifyTVar v . forceCons) xs -- | Returns function that does actual computation and cons forceCons :: (NFData a) => a -> [a] -> [a] forceCons x = (force x:) main = do v <- newTVarIO [] tID <- forkIO $ forceIntoTVar args v threadDelay 200 killThread tID readTVarIO v
- location: git: git@example.com/netwire commit: 6a86ee32e5b869a877151f74064572225e1a0398
Vec4f multiplier, addend; Vec4f vecList[]; for (int i = 0; i < count; i++) vecList[i] = vecList[i] * multiplier + addend;
{- {- import Data.Vector.Storable import qualified Data.Vector.Storable as V import Foreign.C.Types import Data.Bits repCount = 10000 arraySize = 20000 a = fromList $ [0.2::CFloat, 0.1, 0.6, 1.0] m = fromList $ [0.99::CFloat, 0.7, 0.8, 0.6] multAdd :: Int -> CFloat -> CFloat multAdd !i !v = v * (m ! (i .&. 3)) + (a ! (i .&. 3)) multList :: Int -> Vector CFloat -> Vector CFloat multList !count !src | count <= 0 = src | otherwise = multList (count-1) $ V.imap multAdd src main = do print $ Data.Vector.Storable.sum $ multList repCount $ Data.Vector.Storable.replicate (arraySize*4) (0::CFloat)
typedef float v4fs __attribute__ ((vector_size (16))); typedef struct { float x, y, z, w; } Vector4; void setv4(v4fs *v, float x, float y, float z, float w) { float *a = (float*) v; a[0] = x; a[1] = y; a[2] = z; a[3] = w; } float sumv4(v4fs *v) { float *a = (float*) v; return a[0] + a[1] + a[2] + a[3]; } void vecmult(v4fs *MAYBE_RESTRICT s, v4fs *MAYBE_RESTRICT d, v4fs a, v4fs m) { for (int j = 0; j < N; j++) { d[j] = s[j] * m + a; } } void scamult(float *MAYBE_RESTRICT s, float *MAYBE_RESTRICT d, Vector4 a, Vector4 m) { for (int j = 0; j < (N*4); j+=4) { d[j+0] = s[j+0] * m.x + a.x; d[j+1] = s[j+1] * m.y + a.y; d[j+2] = s[j+2] * m.z + a.z; d[j+3] = s[j+3] * m.w + a.w; } } int main () { v4fs a, m; v4fs *s, *d; setv4(&a, 0.2, 0.1, 0.6, 1.0); setv4(&m, 0.99, 0.7, 0.8, 0.6); s = calloc(N, sizeof(v4fs)); d = s; double start = clock(); for (int i = 0; i < M; i++) { d = malloc(N * sizeof(v4fs)); vecmult(s, d, a, m); Vector4 aa = *(Vector4*)(&a); Vector4 mm = *(Vector4*)(&m); scamult((float*)s, (float*)d, aa, mm); free(s); s = d; } double end = clock(); float sum = 0; for (int j = 0; j < N; j++) { sum += sumv4(s+j); } printf("%-50s %2.5f %f\n\n", NAME, (end - start) / (double) CLOCKS_PER_SEC, sum); }
import System.Process import GHC.IOBase cBase = ("cmath", "gcc mult.c -ggdb --std=c99 -DM=10000 -DN=20000") cOptions = [ [("32", "-m32"), ("64", "-m64")], [("generic", ""), ("native", "-march=native -msse4")], [("O1", "-O1"), ("O2", "-O2"), ("O3", "-O3")], [("restrict", "-DMAYBE_RESTRICT=__restrict__"), ("norestrict", "-DMAYBE_RESTRICT=")], [("vector", "-DVECTOR"), ("scalar", "")], [("copy", "-DCOPY"), ("nocopy", "")] ] -- Fold over the Cartesian product of the double list. Probably a Prelude function -- or two that does this, but hey. The -- that this wasn permfold :: (a -> a -> a) -> a -> [[a]] -> [a] permfold f z [] = [z] permfold f z (x:xs) = concat $ map (\a -> (permfold f (f z a) xs)) x prepCmd :: (String, String) -> (String, String) -> (String, String) prepCmd (name, cmd) (namea, cmda) = (name ++ "-" ++ namea, cmd ++ " " ++ cmda) runCCmd name compileCmd = do res <- system (compileCmd ++ " -DNAME=\\\"" ++ name ++ "\\\" -o " ++ name) if res == ExitSuccess then do system ("./" ++ name) return () else putStrLn $ name ++ " did not compile" main = do mapM_ (uncurry runCCmd) $ permfold prepCmd cBase cOptions
{- import Data.Vector.Storable import qualified Data.Vector.Storable as V import Foreign import Foreign.C.Types -- Define a 4 element vector type data Vec4 = Vec4 {- {- {- {-
instance Storable Vec4 where sizeOf _ = sizeOf (undefined :: CFloat) * 4 alignment _ = alignment (undefined :: CFloat) {- peek p = do a <- peekElemOff q 0 b <- peekElemOff q 1 c <- peekElemOff q 2 d <- peekElemOff q 3 return (Vec4 a b c d) where q = castPtr p {- poke p (Vec4 a b c d) = do pokeElemOff q 0 a pokeElemOff q 1 b pokeElemOff q 2 c pokeElemOff q 3 d where q = castPtr p
a = Vec4 0.2 0.1 0.6 1.0 m = Vec4 0.99 0.7 0.8 0.6 add :: Vec4 -> Vec4 -> Vec4 {- add (Vec4 a b c d) (Vec4 a mult :: Vec4 -> Vec4 -> Vec4 {- mult (Vec4 a b c d) (Vec4 a vsum :: Vec4 -> CFloat {- vsum (Vec4 a b c d) = a+b+c+d multList :: Int -> Vector Vec4 -> Vector Vec4 multList !count !src | count <= 0 = src | otherwise = multList (count-1) $ V.map (\v -> add (mult v m) a) src main = do print $ Data.Vector.Storable.sum $ Data.Vector.Storable.map vsum $ multList repCount $ Data.Vector.Storable.replicate arraySize (Vec4 0 0 0 0) repCount, arraySize :: Int repCount = 10000 arraySize = 20000
{- {- -- multiply-add of four floats, Vec4f multiplier, addend; Vec4f vecList[]; for (int i = 0; i < count; i++) vecList[i] = vecList[i] * multiplier + addend; -} import qualified Data.Vector.Storable as V import Data.Vector.Storable (Vector) import Data.Bits repCount, arraySize :: Int repCount = 10000 arraySize = 20000 a, m :: Vector Float a = V.fromList [0.2, 0.1, 0.6, 1.0] m = V.fromList [0.99, 0.7, 0.8, 0.6] multAdd :: Int -> Float -> Float multAdd i v = v * (m `V.unsafeIndex` (i .&. 3)) + (a `V.unsafeIndex` (i .&. 3)) go :: Int -> Vector Float -> Vector Float go n s | n <= 0 = s | otherwise = go (n-1) (f s) where f = V.imap multAdd main = print . V.sum $ go repCount v where v :: Vector Float v = V.replicate (arraySize * 4) 0 -- ^ a flattened Vec4f []
$ ghc -O2 --make A.hs [1 of 1] Compiling Main ( A.hs, A.o ) Linking A ... $ time ./A 516748.13 ./A 3.58s user 0.01s system 99% cpu 3.593 total
case readFloatOffAddr# rb_aVn (word2Int# (and realWorld# of _ { ( case readFloatOffAddr# rb11_X118 (word2Int# (and realWorld# of _ { ( case writeFloatOffAddr# @ RealWorld a17_s1Oe sc3_s1Yz (plusFloat# (timesFloat
extraText :: String -> String extraText who = "\nHello, " ++ who ++ "!"
public class FregeActivity extends Activity { /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); TextView textView = (TextView) findViewById(R.id.txt); textView.append(FregeCode.extraText("Android")); } }
data Bundle = native android.os.Bundle data Context = native android.content.Context data FregeActivity = native android.app.Activity where native getApplicationContext :: MutableIO FregeActivity -> IO (MutableIO Context) native setContentView :: MutableIO FregeActivity -> MutableIO TextView -> IO () data TextView = native android.widget.TextView where native new :: MutableIO Context -> STMutable RealWorld TextView native setText :: MutableIO TextView -> String -> IO () onCreateF :: MutableIO FregeActivity -> IO () onCreateF !this = do context <- this.getApplicationContext tv <- TextView.new context tv.setText "Hello, Android - Love, Frege" this.setContentView tv native module type FregeActivity where { @Override public void onCreate(android.os.Bundle savedInstanceState) { super.onCreate(savedInstanceState); final frege.run7.Func.U<Object,Short> res = RunTM.<frege.run7.Func.U<Object,Short>>cast(onCreateF(this)).call(); frege.prelude.PreludeBase.TST.run(res).call(); } }
{- module Computation where -- model the steps of a computation data Computation a = forall b. Step b (b -> Computation a) | Done a instance Monad Computation where (Step b g) >>= f = Step b $ (>>=f) . g (Done b) >>= f = Step b f return = Done runComputation :: Computation a -> a runComputation (Step b g) = runComputation (g b) runComputation (Done a) = a isDone :: Computation a -> Bool isDone (Done _) = True isDone _ = False -- an order for a set of computations data Schedule a = a :> Computation (Schedule a) | Last toList :: Schedule a -> [a] toList Last = [] toList (a :> c) = a : (toList . runComputation) c -- given a set of computations, find a schedule to generate all their results type Strategy a = [Computation a] -> Computation (Schedule a) -- schedule all the completed computations, and step the rest, -- passing the remaining to the given function scheduleOrStep :: (Queue (Computation a) -> Computation (Schedule a)) -> Strategy a scheduleOrStep s cs = scheduleOrStep where scheduleOrStep scheduleOrStep scheduleOrStep -- schedule all completed compuations, step all the rest once, and repeat -- (may never complete for infinite lists) -- checking each row of -- [ [ c0s0, c1s0, c2s0, ... ] -- , [ c0s1, c1s1, c2s1, ... ] -- , [ c0s2, c1s2, c2s2, ... ] -- ... -- ] -- (where cNsM is computation N stepped M times) fair :: Strategy a fair [] = Done Last fair cs = scheduleOrStep (fair . ($[])) cs -- schedule more steps for earlier computations rather than later computations -- (works on infinite lists) -- checking the sw-ne diagonals of -- [ [ c0s0, c1s0, c2s0, ... ] -- , [ c0s1, c1s1, c2s1, ... ] -- , [ c0s2, c1s2, c2s2, ... ] -- ... -- ] -- (where cNsM is computation N stepped M times) diag :: Enqueue (Computation a)-> Strategy a diag _ [] = Done Last diag enq cs = diag where diag diag -- diagonal downwards : -- [ c0s0, -- c1s0, c0s1, -- c2s0, c1s1, c0s2, -- ... -- cNs0, c{N-1}s1, ..., c1s{N-1}, c0sN, -- ... -- ] diagd :: Strategy a diagd = diag prepend -- diagonal upwards : -- [ c0s0, -- c0s1, c1s0, -- c0s2, c1s1, c2s0, -- ... -- c0sN, c1s{N-1}, ..., c{s1N-1}, cNs0, -- ... -- ] diagu :: Strategy a diagu = diag append -- a queue type type Queue a = [a] -> [a] type Enqueue a = a -> Queue a -> Queue a append :: Enqueue a append x q = q . (x:) prepend :: Enqueue a prepend x q = (x:) . q
data Computation a = Step (Computation a) | Done a instance Monad Computation where (Step g) >>= f = Step $ g >>= f (Done b) >>= f = Step (f b) return = Done
± % diff -u /tmp/{old,new} --- /tmp/old 2016-04-11 11:02:42.000000000 -0400 +++ /tmp/new 2016-04-11 11:02:56.000000000 -0400 @@ -19,6 +19,7 @@ ctx <- SSL.context SSL.contextSetPrivateKeyFile ctx key + SSL.contextSetVerificationMode ctx (SSL.VerifyPeer True True (Just (\_ _ -> return True))) if chainCert then SSL.contextSetCertificateChainFile ctx cert else SSL.contextSetCertificateFile ctx cert
(.) :: (b->c) -> (a->b) -> (a->c) f . g = \ x -> f (g x)
(Man => Mortal), (Socrates => Man), therefore (Socrates => Mortal)
int f(int x); int g(int x); int theComposition(int x) { return f(g(x)); }
tuplify2 :: [a] -> (a,a) tuplify2 [x,y] = (x,y) tuplify3 :: [a] -> (a,a,a) tuplify3 [x,y,z] = (x,y,z)
{- import Language.Haskell.TH tuple :: Int -> ExpQ tuple n = do ns <- replicateM n (newName "x") lamE [foldr (\x y -> conP
$(tuple 6) [1,2,3,4,5,6] == (1,2,3,4,5,6) $(tuple 3) "abc" == (
> list2Tuple lst = read $ "(" ++ (init.tail.show) lst ++ ")" > list2Tuple [1,2,3] :: (Int, Int, Int) (1,2,3) > list2Tuple [1,2,3,4] :: (Int, Int, Int, Int) (1,2,3,4)
toTuple :: [a] -> (a,a,a,a,a,a) toTuple [a,b,c,d,e,f] = (a,b,c,d,e,f)
> :m +Language.Haskell.TH > :set -XTemplateHaskell > runQ [| [1,2,3,4,5,6] |] >>= putStrLn . pprint [1, 2, 3, 4, 5, 6] > runQ [| [1,2,3,4,5,6] |] >>= \ (ListE exps) -> putStrLn (pprint (TupE exps)) (1, 2, 3, 4, 5, 6)
run :: IO (Int, Int, [(Int,Int,Int)]) run = do contents <- readFile "text.txt" -- use let [a,b,c] = lines contents -- split on newlines let firstLine = read (init a) -- let secondLine = read (init b) let thirdLine = read (init c) -- this reads a list of Int-tuples return (firstLine, secondLine, thirdLine)
main = do putStrLn "How much do you love Haskell?" amount <- getLine putStrln ("You love Haskell this much: " ++ amount)
import Control.Applicative ... doTheRightThingWithString <$> readStringFromFile
import Control.Monad ... liftM doTheRightThingWithString readStringFromFile
readStringFromFile >>= \string -> return (doTheRightThingWithString string) readStringFromFile >>= \string -> return $ doTheRightThingWithString string readStringFromFile >>= return . doTheRightThingWithString return . doTheRightThingWithString =<< readStringFromFile
do ... string <- readStringFromFile -- ^ you escape String from IO but only inside this do-block let result = doTheRightThingWithString string ... return result
prob99 = maximum $ map (\xs -> (head xs)^(head (tail xs))) numbers
n = [[519432,525806],[632382,518061].... prob99b [a,b] = b* (log a) answer = snd $ maximum (zip (map prob99b n) [1..])
ghci> let maxIndex xs = head $ filter ((== maximum xs) . (xs !!)) [0..]
$ hoogle "Ord a => [a] -> Int" | head <Nothing relevant> $ $ $ hoogle "a -> [a] -> Int" | head Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int Data.List elemIndices :: Eq a => a -> [a] -> [Int]
import Data.List import Data.Ord maxIndex :: Ord a => [a] -> Int maxIndex = fst . maximumBy (comparing snd) . zip [0..]
foldr :: (a -> b -> b) -> b -> [a] -> b foldr _ z [] = z foldr f z (x:xs) = f x (foldr f z xs)
foldr k z = go where go [] = z go (y:ys) = y `k` go ys
dropR :: Char -> String -> String dropR x r = if x == main :: IO () main = do s <- getLine putStrLn $ foldr dropR "" s
main :: IO () main = do s <- getLine -- I putStrLn $ let { go [] = ""; go (x:xs) = dropR x (go xs) } in go s
foldr :: (a -> b -> b) -> b -> [a] -> b foldr _ z [] = z foldr f z (x:xs) = f x (foldr f z xs)
foldr k z = go where go [] = z go (y:ys) = y `k` go ys
-- Inline only in the final stage, after the foldr/cons rule has had a chance -- Also note that we inline it when it has *two* parameters, which are the -- ones we are keen about specialising!
data Prediction = Prediction Int Int Int showPrediction :: Prediction -> String showPrediction (Prediction a b c) = show a ++ "-" ++ show b ++ "-" ++ show c instance Show (Prediction p) => showPrediction p
instance «preconditions» => Class «type» where «method» = «definition»
instance Show Prediction where show (Prediction a b c) = show a ++ "-" ++ show b ++ "-" ++ show c
data Prediction = Prediction Int Int Int deriving Show
instance Show Foo where show = ... -- or show x = ...
instance Show Prediction where show = showPrediction
instance Show Prediction where show (Prediction a b c) = show a ++ "-" ++ show b ++ "-" ++ show c
instance Show Prediction where show = showPrediction
data Foo = Bar | Baz Int f :: Foo -> Int f Bar = 1 f (Baz x) = x - 1
> let (_, a:_) = (1, [2, 3, 4]) in a 2 > let a:_ = "xyzzy" > case [1, 2, 3] of; a:b -> a; otherwise -> 0; 1
{- -fwarn-monomorphism-restriction -fwarn-hi-shadowing
if flag(production) cpp-options: -DPRODUCTION ghc-options: -Wall -threaded -O2 -static -optl-static else ghc-options: -Wall -threaded -O0
Linking dist/build/personal-website/personal-website ... /usr/lib/ghc-7.0.3/libHSrts_thr.a(Linker.thr_o): In function `internal_dlopen Linker.c:(.text+0x407): warning: Using applications requires at runtime the shared libraries from the glibc version used for linking /usr/lib/ghc-7.0.3/unix-2.4.2.0/libHSunix-2.4.2.0.a(HsUnix.o): In function `__hsunix_getpwent HsUnix.c:(.text+0xa1): warning: Using applications requires at runtime the shared libraries from the glibc version used for linking /usr/lib/ghc-7.0.3/unix-2.4.2.0/libHSunix-2.4.2.0.a(HsUnix.o): In function `__hsunix_getpwnam_r HsUnix.c:(.text+0xb1): warning: Using linked applications requires at runtime the shared libraries from the glibc version used for linking /usr/lib/libpq.a(thread.o): In function `pqGetpwuid (.text+0x15): warning: Using applications requires at runtime the shared libraries from the glibc version used for linking /usr/lib/libpq.a(ip.o): In function `pg_getaddrinfo_all (.text+0x31): warning: Using applications requires at runtime the shared libraries from the glibc version used for linking /usr/lib/ghc-7.0.3/site-local/network-2.3.0.2/ libHSnetwork-2.3.0.2.a(BSD__63.o): In function `sD3z_info (.text+0xe4): warning: Using applications requires at runtime the shared libraries from the glibc version used for linking /usr/lib/ghc-7.0.3/site-local/network-2.3.0.2/ libHSnetwork-2.3.0.2.a(BSD__164.o): In function `sFKc_info (.text+0x12d): warning: Using applications requires at runtime the shared libraries from the glibc version used for linking /usr/lib/ghc-7.0.3/site-local/network-2.3.0.2/ libHSnetwork-2.3.0.2.a(BSD__155.o): In function `sFDs_info (.text+0x4c): warning: Using applications requires at runtime the shared libraries from the glibc version used for linking /usr/lib/libpq.a(fe-misc.o): In function `pqSocketCheck (.text+0xa2d): undefined reference to `SSL_pending' /usr/lib/libpq.a(fe-secure.o): In function `SSLerrmessage (.text+0x31): undefined reference to `ERR_get_error' /usr/lib/libpq.a(fe-secure.o): In function `SSLerrmessage (.text+0x41): undefined reference to `ERR_reason_error_string' /usr/lib/libpq.a(fe-secure.o): In function `initialize_SSL (.text+0x2f8): undefined reference to `SSL_check_private_key' /usr/lib/libpq.a(fe-secure.o): In function `initialize_SSL (.text+0x3c0): undefined reference to `SSL_CTX_load_verify_locations' (... snip ...)
2011-12-28T01:20:51+00:00 heroku[web.1]: Starting process with command `./dist/build/personal-website/personal-website -p 41083` 2011-12-28T01:20:51+00:00 app[web.1]: ./dist/build/personal-website/ personal-website: error while loading shared libraries: libgmp.so.10: cannot open shared object file: No such file or directory 2011-12-28T01:20:52+00:00 heroku[web.1]: State changed from starting to crashed
2011-12-28T01:31:23+00:00 app[web.1]: ./dist/build/personal-website/ personal-website: /lib/libc.so.6: version `GLIBC_2.14 (required by ./dist/build/personal-website/personal-website) 2011-12-28T01:31:23+00:00 app[web.1]: ./dist/build/personal-website/ personal-website: /lib/libc.so.6: version `GLIBC_2.14 (required by /app/dist/build/personal-website/libgmp.so.10) 2011-12-28T01:31:25+00:00 heroku[web.1]: State changed from starting to crashed 2011-12-28T01:31:25+00:00 heroku[web.1]: Process exited
/path/to/ld-2.14.so --library-path <whatever> /path/to/your/executable
import System.IO import Control.Monad main = do let list = [] handle <- openFile "test.txt" ReadMode contents <- hGetContents handle singlewords <- (words contents) list <- f singlewords print list hClose handle f :: [String] -> [Int] f = map read
import System.IO import Control.Monad main = do let list = [] handle <- openFile "test.txt" ReadMode contents <- hGetContents handle let singlewords = words contents list = f singlewords print list hClose handle f :: [String] -> [Int] f = map read
main = do contents <- readFile "test.txt" print . map readInt . words $ contents -- alternately, main = print . map readInt . words =<< readFile "test.txt" readInt :: String -> Int readInt = read
{- import System.IO import qualified Data.ByteString.Lazy.Char8 as B import Control.Applicative import Data.List sumNums :: B.ByteString -> Int sumNums s = foldl sumStrs :: Int -> B.ByteString -> Int sumStrs m i = m+int where Just(int,_) = B.readInt i main = do sums <- map sumNums <$> B.lines <$> B.readFile "testy" print sums
instance Eq Edge where (Edge s1 _) == (Edge s2 _) = s1 == s2
instance Ord Edge where (Edge s1 _) `compare` (Edge s2 _) = s1 `compare` s2
import Data.Set data Edge = Edge (Set String) Bool deriving Show instance Eq Edge where (Edge a _) == (Edge b _) = a == b instance Ord Edge where compare (Edge a _) (Edge b _) = compare a b
monadSwitch :: Monad m => m a -> m a -> (Bool -> m a) monadSwitch computation1 computation2 test = if test then computation1 else computation2
parseTerm = do x <- parseSubterm o <- parseOperator y <- parseSubterm return $ Term x o y
parseTerm = proc _ -> do x <- parseSubterm -< () o <- parseOperator -< () y <- parseSubterm -< () returnA -< Term x o y
parseTerm = Term <$> parseSubterm <*> parseOperator <*> parseSubterm
newtype ArrowMonad (~>) b = ArrowMonad (() ~> b) instance Arrow (~>) => Functor (ArrowMonad (~>)) where fmap f (ArrowMonad m) = ArrowMonad $ m >>> arr f instance ArrowApply (~>) => Monad (ArrowMonad (~>)) where return x = ArrowMonad (arr (\_ -> x)) ArrowMonad m >>= f = ArrowMonad $ m >>> arr (\x -> let ArrowMonad h = f x in (h, ())) >>> app
instance Arrow (~>) => Functor (() ~>) where fmap f m = m >>> arr f
instance ArrowApply (~>) => Monad (() ~>) where -- return :: b -> (() ~> b) return x = arr (\_ -> x) -- (>>=) :: ()~>a -> (a -> ()~>b ) -> ()~>b m >>= f = m >>> arr (\x -> (f x, ()) ) >>> app
instance Monad m => Category (a -> m b) where id = return (f . g) x = g x >>= f instance Monad m => Arrow (a -> m b) where arr f = return . f first f (x, y) = f x >>= \ x
hello = ("hello" ++) world = ("world" ++) -- We can "concatenate" ShowS values simply by composing them: helloworld = hello . world -- and turn them into Strings by passing them an empty list: helloworld
seqLen2 :: Int -> Integer -> Int seqLen2 a 1 = a seqLen2 a n = seqLen2 (a+1) (nextNumber n) sequenceLength :: Integer -> Int sequenceLength = seqLen2 1
nextNumber :: Integer -> Integer nextNumber n | r == 0 = q | otherwise = 6*q + 4 where (q,r) = quotRem n 2
longestSequence = snd $ maximum [(sequenceLength a, a) | a <- [1..searchTo]]
nextNumber :: Integer -> Integer nextNumber n | fromInteger n .&. 1 == (0 :: Int) = n `quot` 2 | otherwise = 3*n+1
module Main (main) where import Data.Bits result :: Int result = findMax 0 0 1 findMax :: Int -> Int -> Int -> Int findMax start len can | can > 1000000 = start | canlen > len = findMax can canlen (can+1) | otherwise = findMax start len (can+1) where canlen = findLen 1 can findLen :: Int -> Int -> Int findLen l 1 = l findLen l n | n .&. 1 == 0 = findLen (l+1) (n `shiftR` 1) | otherwise = findLen (l+1) (3*n+1) main :: IO () main = print result
type I = Integer data P = P {- searchTo = 1000000 nextNumber :: I -> I nextNumber n = case quotRem n 2 of (n2,0) -> n2 _ -> 3*n+1 sequenceLength :: I -> Int sequenceLength x = count x 1 where count 1 acc = acc count n acc = count (nextNumber n) (succ acc) longestSequence = maximum . map (\i -> P (sequenceLength i) i) $ [1..searchTo] main = putStrLn $ show $ longestSequence
{- -- Compiled with ghc -O2 -fvia-C -optc-O3 -Wall euler.hs module Main (main) where searchTo :: Int searchTo = 1000000 nextNumber :: Int -> Int nextNumber n = case n `divMod` 2 of (k,0) -> k _ -> 3*n + 1 sequenceLength :: Int -> Int sequenceLength n = sl 1 n where sl k 1 = k sl k x = sl (k + 1) (nextNumber x) longestSequence :: Int longestSequence = testValues 1 0 0 where testValues number !longest !longestNum | number > searchTo = longestNum | otherwise = testValues (number + 1) longest nlength = sequenceLength number (longest then (nlength,number) else (longest,longestNum) main :: IO () main = print longestSequence
~$ cabal install ghc-mod Resolving dependencies... [1 of 1] Compiling Main ( /tmp/haskell-src-exts-1.13.5-21238/haskell-src-exts-1.13.5/Setup.hs, /tmp/haskell-src-exts-1.13.5-21238/haskell-src-exts-1.13.5/dist/setup/Main.o ) /tmp/haskell-src-exts-1.13.5-21238/haskell-src-exts-1.13.5/Setup.hs:1:1: Warning: In the use of `runTests' (imported from Distribution.Simple, but defined in Distribution.Simple.UserHooks): Deprecated: "Please use the new testing interface instead!" Linking /tmp/haskell-src-exts-1.13.5-21238/haskell-src-exts-1.13.5/dist/setup/setup ... Configuring haskell-src-exts-1.13.5... Building haskell-src-exts-1.13.5... Preprocessing library haskell-src-exts-1.13.5... dist/build/Language/Haskell/Exts/InternalParser.hs:1:12: Warning: -fglasgow-exts is deprecated: Use individual extensions instead [ 1 of 22] Compiling Language.Haskell.Exts.Annotated.Syntax ( src/Language/Haskell/Exts/Annotated/Syntax.hs, dist/build/Language/Haskell/Exts/Annotated/Syntax.o ) cabal: Error: some packages failed to install: ghc-mod-1.11.1 depends on haskell-src-exts-1.13.5 which failed to install. haskell-src-exts-1.13.5 failed during the building phase. The exception was: ExitFailure 9 hlint-1.8.33 depends on haskell-src-exts-1.13.5 which failed to install.
... World file is already up to date. cabal: Error: some packages failed to install: ghc-mod-1.11.1 depends on haskell-src-exts-1.13.5 which failed to install. haskell-src-exts-1.13.5 failed during the building phase. The exception was: ExitFailure 9 hlint-1.8.33 depends on haskell-src-exts-1.13.5 which failed to install.
dd if=/dev/zero of=/swapfile bs=1M count=1024 mkswap /swapfile swapon /swapfile
fn = \a b -> case (a,b) of (pat1a, pat1b) -> r1 (pat2a, pat2b) -> r2
data Operace = Op (Int->Int->Int) String (Int->Int->Int) deriving Show
instance Show Operace where show (Op op str inv) = show str
No instance for (Show (Int -> Int -> Int)) arising from the Possible fix: add an instance declaration for (Show (Int -> Int -> Int)) or use a standalone so you can specify the instance context yourself When deriving the instance for (Show Operace)
data Operace = Op (Int->Int->Int) String (Int->Int->Int) instance Show Operace where show (Op op str inv) = str
data Operace = Op (Int->Int->Int) String (Int->Int->Int) instance Show Operace where show (Op op str inv) = show str
$ ghci GHCi, version 7.4.2: http: Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Prelude> :t 1 ++ 2 1 ++ 2 :: Num [a] => [a]
Prelude> 1 ++ 2 <interactive>:3:1: No instance for (Num [a0]) arising from the literal `1' Possible fix: add an instance declaration for (Num [a0]) In the first argument of `(++) In the expression: 1 ++ 2 In an equation for `it
Prelude> instance Num a => Num [a] where fromInteger n = Data.List.genericReplicate n 1 <interactive>:2:10: Warning: No explicit method or default declaration for `+' In the instance declaration for `Num [a]' <interactive>:2:10: Warning: No explicit method or default declaration for `*' In the instance declaration for `Num [a]' <interactive>:2:10: Warning: No explicit method or default declaration for `abs' In the instance declaration for `Num [a]' <interactive>:2:10: Warning: No explicit method or default declaration for `signum' In the instance declaration for `Num [a]' Prelude> 1 ++ 2 :: [Int] [1,1,1]
instance Num a => Num [a] where (+) = zipWith (+) (*) = zipWith (*) (-) = zipWith (-) negate = map negate abs = map abs signum = map signum fromInteger x = [fromInteger x]
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
mempty `mappend` x == x -- for any x x `mappend` mempty == x -- for any x -- and a `mappend` (b `mappend` c) == (a `mappend` b) `mappend` c -- for all a, b, c
μ :: m a × m a -> m a μ :: (m × m) a -> m a μ :: m (m a) -> m a -- join in Haskell
-- Category laws for Hask: f . id = id id . f = f h . (g . f) = (h . g) . f -- Functor laws for a Haskell Functor: fmap id = id fmap (g . f) = fmap g . fmap f
f <=< return = return return <=< f = f h <=< (g <=< f) = (h <=< g) <=< f
return =<< x = x -- right unit (g <=< f) =<< x = g =<< (f =<< x) -- associativity
traverse :: (Traversable t, Applicative f) => (a -> f b) -> (t a -> f (t b))
-- cf. Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> (t a -> m) foldMapDefault f = getConst . traverse (Const . f)
foldMapDefault => (a -> Const m b) -> (t a -> Const m (t b)) foldMapDefault
-- Identity and composition for the "traversable category". idT = Identity g .*. f = Compose . fmap g . f -- Category laws: right identity f .*. idT ~ f f .*. idT Compose . fmap f . idT Compose . fmap f . Identity Compose . Identity . f f -- using getIdentity . getCompose -- Category laws: left identity idT .*. f ~ f idT .*. f Compose . fmap Identity . f f -- using fmap getIdentity . getCompose -- Category laws: associativity h .*. (g .*. f) ~ (h .*. g) .*. f h .*. (g .*. f) -- LHS h .*. (Compose . fmap g . f) Compose . fmap h . (Compose . fmap g . f) Compose . Compose . fmap (fmap h) . fmap g . f (h .*. g) .*. f -- RHS (Compose . fmap h . g) .*. f Compose . fmap (Compose . fmap h . g) . f Compose . fmap (Compose . fmap h) . fmap g . f Compose . fmap Compose . fmap (fmap h) . fmap g . f -- using Compose . Compose . fmap getCompose . getCompose Compose . Compose . fmap (fmap h) . fmap g . f -- RHS ~ LHS
-- Functor laws for traverse: identity traverse idT ~ idT traverse Identity ~ Identity -- i.e. the identity law of Traversable -- Functor laws for traverse: composition traverse (g .*. f) ~ traverse g .*. traverse f traverse (Compose . fmap g . f) ~ Compose . fmap (traverse g) . traverse f -- i.e. the composition law of Traversable
traverse_ :: Applicative f => (a -> f b) -> t a -> f ()
newtype Constant a b = Constant { getConstant :: a } -- no b value at the term level! Monoid a => Applicative (Constant a)
gchi> Constant (Sum 1) <*> Constant (Sum 2) :: Constant (Sum Int) whatever Constant (Sum {getSum = 3})
join (fmap (\x -> fmap (\y -> f x y) ys) xs) = f <$> xs <*> ys
ljoin xs | any null xs = [] | otherwise = concat xs
newtype Backwards f x = Backwards {backwards :: f x} instance Applicative f => Applicative (Backwards f) where pure x = Backwards (pure x) Backwards ff <*> Backwards fs = Backwards (flip ($) <$> fs <*> ff)
(S0 <| P0) . (S1 <| P1) ~= ((S0 <| P0) S1) <| \ (s0, e0) -> (p0 : P0, P1 (e0 p0))
(S0 <| P0) (X) (S1 <| P1) = ((S0, S1) <| \ (s0, s1) -> (P0 s0, P1 s1))
unit : () -> (S <| P) () mult : forall X, Y. ((S <| P) X, (S <| P) Y) -> (S <| P) (X, Y)
return_f : () -> S join_f : (S <| P) S -> S -- (s : S, P s -> S) -> S
> :m + Data.Time System.Locale Control.Applicative > epoch_int <- (read <$> formatTime defaultTimeLocale "%s" <$> getCurrentTime) :: IO Int > epoch_int 1375025861
> :m + Data.Time.Clock.POSIX > round `fmap` getPOSIXTime 1375040716 it :: Integer
import Data.Time import Data.Time.Clock.POSIX t = getPOSIXTime
import Data.Time.Clock.POSIX (getPOSIXTime) timeNanos, timeMicros, timeMillis :: IO Integer t mul = round . (mul *) <$> getPOSIXTime timeNanos = t 1000000000 timeMicros = t 1000000 timeMillis = t 1000 main = do tNanos <- timeNanos tMicros <- timeMicros tMillis <- timeMillis print tNanos print tMicros print tMillis -- OUT: -- 1539161680010615122 -- 1539161680010617 -- 1539161680011
import System.Time getClockTime >>= (\(TOD sec _) -> return sec)
getCurrentTime >>= pure . (1000*) . utcTimeToPOSIXSeconds >>= pure . round
import System.IO.Unsafe import Data.Time.Clock.POSIX time = round (unsafePerformIO getPOSIXTime) :: Int
data DoubleList a = LeftEnd a (DoubleList a) | Middle a (DoubleList a) (DoubleList a) | RightEnd a (DoubleList a)
let e1 = LeftEnd 1 e2 e2 = Middle 2 e1 e3 e3 = Middle 3 e2 e4 e4 = Middle 4 e3 e5 e5 = RightEnd 5 e4
stg_atomicModifyMutVarzh { ... retry: x = StgMutVar_var(mv); StgThunk_payload(z,1) = x; (h) = foreign "C" cas(mv + SIZEOF_StgHeader + OFFSET_StgMutVar_var, x, y) []; if (h != x) { goto retry; } StgMutVar_var(mv) = y; ... }
/* * Compare-and-swap. Atomically does this: */ EXTERN_INLINE StgWord cas(StgVolatilePtr p, StgWord o, StgWord n); /* * CMPXCHG - the single-word atomic compare-and-exchange instruction. Used * in the STM implementation. */ EXTERN_INLINE StgWord cas(StgVolatilePtr p, StgWord o, StgWord n) { __asm__ __volatile__ ( "lock\ncmpxchg %3,%1" :"=a"(o), "=m" (*(volatile unsigned int *)p) :"0" (o), "r" (n)); return o; StgWord r; arm_atomic_spin_lock(); r = *p; if (r == o) { *p = n; } arm_atomic_spin_unlock(); return r; StgWord result; result = *p; if (result == o) { *p = n; } return result;
$ ghci >>> let x = 330492039485 :: Data.Word.Word8 <interactive>:2:9: Warning: Literal 330492039485 is out of the GHC.Word.Word8 range 0..255
Prelude> :m +Data.Word Prelude Data.Word> :set -W Prelude Data.Word> :set -XNegativeLiterals Prelude Data.Word> -1 :: Word <interactive>:74:1: Warning: Literal -1 is out of the Word range 0..18446744073709551615 18446744073709551615 Prelude Data.Word>
module Foo ( module Foo.A , module Foo.B ) where import Foo.A import Foo.B
import Data.Text import Data.Text.Lazy (toStrict) import Data.Text.Lazy.Builder (toLazyText) import Data.Text.Lazy.Builder.Int (decimal) showIntegral :: Integral a => a -> T.Text showIntegral = toStrict. toLazyText . decimal
import Data.Text import Data.Text.Lazy (toStrict) import Data.Text.Lazy.Builder (toLazyText) import Data.Text.Lazy.Builder.Int (decimal) import Data.Text.Lazy.Builder.RealFloat (realFloat) class ShowText a where showText :: a -> Text instance ShowText Int where showText = toStrict . toLazyText . decimal instance ShowText Float where showText = toStrict . toLazyText . realFloat
showText :: Show a => a -> Text showText = pack . show
let s = blocks pes pts = map (map mkPt) s {- stitches to points-} lines = map Line pts {-points to lines -} pict = Pictures lines {- lines to a picture -} in do displayInWindow "My Window" (200, 200) (10, 10) white pict
let pict = Pictures . (map Line) . (map $ map $ mkPt) . blocks $ pes in do displayInWindow "My Window" (200, 200) (10, 10) white pict
let pict = Pictures . (map Line) . (map $ map $ mkPt) . blocks $ pes in do displayInWindow "My Window" (200, 200) (10, 10) white pict
let pict = Pictures . map Line . (map $ map mkPt) . blocks $ pes in do displayInWindow "My Window" (200, 200) (10, 10) white pict
let pict = Pictures . map Line . map (map mkPt) . blocks $ pes in do displayInWindow "My Window" (200, 200) (10, 10) white pict
let pict = Pictures . map Line . map (map mkPt) . blocks $ pes in do displayInWindow "My Window" (200, 200) (10, 10) white pict
let displayPict = displayInWindow "My Window" (200, 200) (10, 10) white . Pictures . map Line . map (map mkPt) . blocks in displayPict pes
let displayPict = displayInWindow "My Window" (200, 200) (10, 10) white . Pictures . map (Line . map mkPt) . blocks in displayPict pes
let displayPict = blocks >>> map (Line . map mkPt) >>> Pictures >>> displayInWindow "My Window" (200, 200) (10, 10) white in displayPict pes
foo x = d where a = etc x c = doThis b b = doThat a d = map show c
length (1, 1, 1) <interactive>:6:1: No instance for (Foldable ((,,) t0 t1)) arising from a use of ‘length’ In the expression: length (1, 1, 1) In an equation for ‘it’: it = length (1, 1, 1) <interactive>:6:9: No instance for (Num t0) arising from the literal ‘1’ The type variable ‘t0’ is ambiguous Note: there are several potential instances: instance Num Integer -- Defined in ‘GHC.Num’ instance Num Double -- Defined in ‘GHC.Float’ instance Num Float -- Defined in ‘GHC.Float’ ...plus two others In the expression: 1 In the first argument of ‘length’, namely ‘(1, 1, 1)’ In the expression: length (1, 1, 1) <interactive>:6:12: No instance for (Num t1) arising from the literal ‘1’ The type variable ‘t1’ is ambiguous Note: there are several potential instances: instance Num Integer -- Defined in ‘GHC.Num’ instance Num Double -- Defined in ‘GHC.Float’ instance Num Float -- Defined in ‘GHC.Float’ ...plus two others In the expression: 1 In the first argument of ‘length’, namely ‘(1, 1, 1)’ In the expression: length (1, 1, 1)
length (1::Int, 1::Int, 1::Int) <interactive>:7:1: No instance for (Foldable ((,,) Int Int)) arising from a use of ‘length’ In the expression: length (1 :: Int, 1 :: Int, 1 :: Int) In an equation for ‘it’: it = length (1 :: Int, 1 :: Int, 1 :: Int)
instance Foldable ((,) a) where foldMap f (_, y) = f y foldr f z (_, y) = f y z
class Foldable t where length :: t a -> Int length = foldl foldl foldl where f minimum :: forall a . Ord a => t a -> a minimum = fromMaybe (error "minimum: empty structure") . getMin . foldMap (Min
length (a, b) = { definition of length } foldl = { definition of foldl foldr (\x k z -> k $! (\c _ -> c+1) z x) id (a, b) 0 = { definition of foldr } (\x k z -> k $! (\c _ -> c+1) z x) b id 0 = { beta reduction } id $! (\c _ -> c+1) 0 b = { id $! e = e } (\c _ -> c+1) 0 b = { beta reduction } 1
minimum (a, b) = { definition of minimum } ( fromMaybe (error "minimum: empty structure") . getMin . foldMap (Min . Just) ) (a, b) = { definition of (.) } ( fromMaybe (error "minimum: empty structure") . getMin ) (foldMap (Min . Just) (a, b)) = { definition of foldMap } ( fromMaybe (error "minimum: empty structure") . getMin ) ((Min . Just) b) = { definition of (.) } fromMaybe (error "minimum: empty structure") (getMin (Min (Just b))) = { definition of getMin } fromMaybe (error "minimum: empty structure") (Just b) = { definition of fromMaybe } b
{- class Monad m => Effect p e r m | p e m -> r where fin :: p e m -> e -> m r data ErrorEff :: * -> (* -> *) -> * where CatchError :: (e -> m a) -> ErrorEff ((e -> m a) -> m a) m instance Monad m => Effect ErrorEff ((e -> m a) -> m a) a m where fin (CatchError h) = \f -> f h
Could not deduce (a1 ~ a) from the context (Monad m) [...] or from (((e -> m a) -> m a) ~ ((e1 -> m a1) -> m a1)) [...]
type T a = Int type family F a :: * type instance F Int = Bool type instance F Char = Bool
g : T a1 .. an ~ T b1 .. bn --------------------------- nth i g : ai ~ bi
{- data ErrorEff x where CatchError :: m a -> ErrorEff (m a) fin :: ErrorEff (m a) -> m a fin (CatchError h) = h
data ErrorEff x where CatchError :: x -> ErrorEff x
data ErrorEff x where CatchError :: { fin :: m a } -> ErrorEff (m a)
data Prop = Pred String | Not Prop | And Prop Prop | Or Prop Prop | Impl Prop Prop | Equiv Prop Prop deriving (Eq, Ord)
data Prop = Not Prop | And Prop Prop | Or Prop Prop | Impl Prop Prop | Equiv Prop Prop | Equals Obj Obj | ForAll (Obj -> Prop) | Exists (Obj -> Prop) deriving (Eq, Ord) data Obj = Num Integer | Add Obj Obj | Mul Obj Obj deriving (Eq, Ord)
ForAll (\x -> Exists (\y -> Equals (Add x y) (Mul x y))))
data Prop = Not Prop | And Prop Prop | Or Prop Prop | Impl Prop Prop | Equiv Prop Prop | Equals Obj Obj | ForAll String Prop | Exists String Prop deriving (Eq, Ord) data Obj = Num Integer | Var String | Add Obj Obj | Mul Obj Obj deriving (Eq, Ord)
ForAll "x" (Exists "y" (Equals (Add (Var "x") (Var "y"))) (Mul (Var "x") (Var "y"))))))
data FOL a where True :: FOL Bool False :: FOL Bool Not :: FOL Bool -> FOL Bool And :: FOL Bool -> FOL Bool -> FOL Bool ... -- first solution Exists :: (FOL Integer -> FOL Bool) -> FOL Bool ForAll :: (FOL Integer -> FOL Bool) -> FOL Bool -- second solution Exists :: String -> FOL Bool -> FOL Bool ForAll :: String -> FOL Bool -> FOL Bool Var :: String -> FOL Integer -- operations in the universe Num :: Integer -> FOL Integer Add :: FOL Integer -> FOL Integer -> FOL Integer ...
forAll :: (Prop -> Prop) -> Prop forAll f = ForAll n body where body = f (Var n) n = maxBV body + 1 bot :: Name bot = 0 -- Computes the maximum bound variable in the given expression maxBV :: Prop -> Name maxBV (Var _ ) = bot maxBV (App f a) = maxBV f `max` maxBV a maxBV (Lam n _) = n
data Prop = Pred String [Name] | Not Prop | And Prop Prop | Or Prop Prop | Impl Prop Prop | Equiv Prop Prop | ForAll Name Prop deriving (Eq, Ord)
