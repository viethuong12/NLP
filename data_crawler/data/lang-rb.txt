case x when 1..5 "It when 6 "It when "foo", "bar" "It when String "You passed a string" else "You gave me end
obj = case obj.class when String print( when Fixnum print( else print( end
obj = case obj when String print( when Fixnum print( else print( end
case n when 0 puts when 1, 9 puts when 2 puts puts when 3, 5, 7 puts when 4, 6, 8 puts else puts end
score = 70 result = case score when 0..40 then "Fail" when 41..60 then "Pass" when 61..70 then "Pass with Merit" when 71..100 then "Pass with Distinction" else "Invalid Score" end puts result
case a when 1 puts "Single value" when 2, 3 puts "One of comma-separated values" when 4..6 puts "One of 4, 5, 6" when 7...9 puts "One of 7, 8, but not 9" else puts "Any other thing" end
case when b < 3 puts "Little than 3" when b == 3 puts "Equal to 3" when (1..10) === b puts "Something in closed range of [1..10]" end
is_even = ->(x) { x % 2 == 0 } case number when 0 then puts when is_even then puts else puts end
Moddable = Struct.new(:n) do def ===(numeric) numeric % n == 0 end end mod4 = Moddable.new(4) mod3 = Moddable.new(3) case number when mod4 then puts when mod3 then puts end
class Vehicle def ===(another_vehicle) self.number_of_wheels == another_vehicle.number_of_wheels end end four_wheeler = Vehicle.new 4 two_wheeler = Vehicle.new 2 case vehicle when two_wheeler puts when four_wheeler puts end
case foo when /^(true|false)$/ puts "Given string is boolean" when /^[0-9]+$/ puts "Given string is integer" when /^[0-9\.]+$/ puts "Given string is float" else puts "Given string is probably string" end
case 5 when 3..7 when 3,4,5,6 when Fixnum when Integer when Numeric when Comparable when Object when Kernel when BasicObject ... end
case when x.nil? ... when (x.match / ... when (x.include? ... when x.gsub( ... when Time.now.tuesday? ... end
menu = {a: :menu1, b: :menu2, c: :menu2, d: :menu3} def menu1 puts end def menu2 puts end def menu3 puts end selected_menu = :a send(menu[selected_menu])
print "Enter your grade: " grade = gets.chomp case grade when "A", "B" puts when "C", "D" puts else puts "You can end
print "Enter a string: " some_string = gets.chomp case when some_string.match(/\d/) puts when some_string.match(/[a-zA-Z]/) puts else puts end
case x when 1,2,3 puts "1, 2, or 3" when 10 puts "10" else puts "Some other number" end
case x when 1,2,3 then puts "1, 2, or 3" when 10 then puts "10" else puts "Some other number" end
case 5 when (1..10) puts "case statements match inclusion in a range" end
case "FOOBAR" when /BAR$/ puts "they can match regular expressions!" end
case 40 when -> (n) { n.to_s == "40" } puts "lambdas!" end
class Success def self.===(item) item.status >= 200 && item.status < 300 end end class Empty def self.===(item) item.response_size == 0 end end case http_response when Empty puts "response was empty" when Success puts "response was a success" end
age = 20 case when age >= 21 puts "display something" when 1 == 0 puts "omg" else puts "default condition" end
case params[:unknown] when /Something/ then when /Something else/ then end
case expression when condtion1 function when condition2 function else function end
puts "Recommend me a language to learn?" input = gets.chomp.downcase.to_s case input when puts "Learn Ruby" when puts "Learn Python" when puts "Learn Java" when puts "Learn PHP" else "Go to Sleep!" end
String === "zen" Range === (1..2) Array === [1,2,3] Integer === 2
(1..4) === 3 (1..4) === 2.345 (1..4) === 6 ("a".."d") === "c" ("a".."d") === "e"
$age = 5 case $age when 0 .. 2 puts "baby" when 3 .. 6 puts "little child" when 7 .. 12 puts "child" when 13 .. 18 puts "youth" else puts "adult" end
a = "secondcase" var_name = case a when "firstcase" then "foo" when "secondcase" then "bar" end puts var_name >> "bar"
code = class StrContains def self.===(item) item.include? item.include? end end case code.upcase when puts "Code when puts else puts end
require ALLOWED_METHODS = Set[:to_s, :to_i, :upcase, :downcase ] def foo(what) raise "Not allowed" unless ALLOWED_METHODS.include?(what.to_sym) bar.send(what) end
%w{ant bear cat}.any? {|word| word.length >= 3} %w{ant bear cat}.any? {|word| word.length >= 4} [ nil, true, 99 ].any?
rb_ary_includes(VALUE ary, VALUE item) { long i; for (i=0; i<RARRAY_LEN(ary); i++) { if (rb_equal(RARRAY_AREF(ary, i), item)) { return Qtrue; } } return Qfalse; }
a = %w/cat dog bird/ require trie = Rambling::Trie.create { |trie| a.each do |e| trie << e end }
array.include?(element) array.member?(element) array.to_set.include?(element) array.to_set.member?(element) array.index(element) > 0 array.find_index(element) > 0 array.index { |each| each == element } > 0 array.find_index { |each| each == element } > 0 array.any? { |each| each == element } array.find { |each| each == element } != nil array.detect { |each| each == element } != nil
VALUE rb_ary_includes(VALUE ary, VALUE item) { long i; VALUE e; for (i=0; i<RARRAY_LEN(ary); i++) { e = RARRAY_AREF(ary, i); switch (rb_equal_opt(e, item)) { case Qundef: if (rb_equal(e, item)) return Qtrue; break; case Qtrue: return Qtrue; } } return Qfalse; }
static VALUE member_i(RB_BLOCK_CALL_FUNC_ARGLIST(iter, args)) { struct MEMO *memo = MEMO_CAST(args); if (rb_equal(rb_enum_values_pack(argc, argv), memo->v1)) { MEMO_V2_SET(memo, Qtrue); rb_iter_break(); } return Qnil; } static VALUE enum_member(VALUE obj, VALUE val) { struct MEMO *memo = MEMO_NEW(val, Qfalse, 0); rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo); return memo->v2; }
def member?(value) memo = [value, false, 0] each_with_object(memo) do |each, memo| if each == memo[0] memo[1] = true break end memo[1] end
module Enumerable def to_set(klass = Set, *args, &block) klass.new(self, *args, &block) end end class Set def initialize(enum = nil, &block) @hash ||= Hash.new enum.nil? and return if block do_with_enum(enum) { |o| add(block[o]) } else merge(enum) end end def merge(enum) if enum.instance_of?(self.class) @hash.update(enum.instance_variable_get(:@hash)) else do_with_enum(enum) { |o| add(o) } end self end def add(o) @hash[o] = true self end def include?(o) @hash.include?(o) end alias member? include? ... end
array.grep(element).any? array.select { |each| each == element }.size > 0 ...
require s = Set.new 100.times{|i| s << "foo s.include?("foo99") => true [1,2,3,4,5,6,7,8].to_set.include?(4) => true
fake_array = {} 100.times{|i| fake_array["foo fake_array.has_key?("foo99") => true
require require array = [] set = Set.new 10_000.times do |i| array << "foo set << "foo end Benchmark.bm do |x| x.report("array") { 10_000.times { array.include?("foo9999") } } x.report("set ") { 10_000.times { set.include?("foo9999") } } end
user system total real array 7.020000 0.000000 7.020000 ( 7.031525) set 0.010000 0.000000 0.010000 ( 0.004816)
a = [ if a.index( puts "dog exists in the array" end
a = [1,2,3,4,5] 2.in? a 8.in? a a.member? 1 a.member? 8
[ :edit, :update, :create, :show ].select{|v| v if "my brother would like me to update his profile".downcase =~ /[,|.| |]
arr = [ hash = arr.map {|x| [x,true]}.to_h => {"Cat"=>true, "Dog"=>true, "Bird"=>true} hash["Dog"] => true hash["Insect"] => false
def in_array?(array, item) item = [item] unless item.is_a?(Array) item == array & item end
"hello James!".upcase "hello James!".capitalize "hello James!".titleize
$ gem install unicode_utils $ irb > require => true > UnicodeUtils.downcase("FEN BİLİMLERİ", :tr) => "fen bilimleri"
gem install activesupport irb -ractive_support/core_ext/string "STRING ÁÂÃÀÇÉÊÍÓÔÕÚ".mb_chars.downcase.to_s => "string áâãàçéêíóôõú" "string áâãàçéêíóôõú".mb_chars.upcase.to_s => "STRING ÁÂÃÀÇÉÊÍÓÔÕÚ"
nil.blank? == true false.blank? == true [].blank? == true {}.blank? == true "".blank? == true 5.blank? == false 0.blank? == false
false.present? == false false.blank? == true false.nil? == false
"".empty? "hi".empty? {}.empty? {"" => ""}.empty? [].empty? [nil].empty? nil.empty?
namespace :thing do desc "it does a thing" task :work, [:option, :foo, :bar] do |task, args| puts "work", args end task :another, [:option, :foo, :bar] do |task, args| puts "another Rake::Task["thing:work"].invoke(args[:option], args[:foo], args[:bar]) end end
rake thing:work[1,2,3] => work: {:option=>"1", :foo=>"2", :bar=>"3"} rake thing:another[1,2,3] => another {:option=>"1", :foo=>"2", :bar=>"3"} => work: {:option=>"1", :foo=>"2", :bar=>"3"}
task :work, [:option, :foo, :bar] => [:environment] do |task, args| puts "work", args end
require task :my_task, [:arg1, :arg2] do |t, args| puts "Args were: end task :invoke_my_task do Rake.application.invoke_task("my_task[1, 2]") end task :invoke_my_task_2 do Rake::Task[:my_task].invoke(3, 4) end task :with_prerequisite, [:arg1, :arg2] => :my_task task :with_defaults, :arg1, :arg2 do |t, args| args.with_defaults(:arg1 => :default_1, :arg2 => :default_2) puts "Args with defaults were: end
$ rake user:create -- --user test@example.com --pass 123
require require namespace :user do |args| desc task :create do options = {} OptionParser.new(args) do |opts| opts.banner = "Usage: rake user:create [options]" opts.on("-u", "--user {username}","User options[:user] = user end opts.on("-p", "--pass {password}","User options[:pass] = pass end end.parse! puts "creating user account..." u = Hash.new u[:email] = options[:user] u[:password] = options[:pass] puts "user: " + u.to_s puts "account created." exit 0 end end
desc task :task_name => [:depends_on_taskA, :depends_on_taskB] do end
desc task :task_name, :display_value, :display_times, :needs => [:depends_on_taskA, :depends_on_taskB] do |t, args| args.display_times.to_i.times do puts args.display_value end end
task :caller do puts Rake::Task[:task_name].invoke( end
task :my_task do myvar = ENV[ puts "myvar: end rake my_task myvar=10
namespace :db do desc task :export, [:file_token, :file_path] => :environment do |t, args| args.with_defaults(:file_token => "products", :file_path => "./lib/data/") end end
desc task :task_name, [:arg1, :arg2] => [:dependency1, :dependency2] do |t, args| puts args[:arg1] end
namespace :some do task task: :environment do arg1, arg2 = ARGV exit end end
require task :mytask, :args_expr do |t,args| args.with_defaults(:args_expr => "width=10&height=10") options = Rack::Utils.parse_nested_query(args[:args_expr]) end
bundle exec rake "dj:start[ebooks[workers_number]=16&ebooks[worker_timeout]=60&albums[workers_number]=32&albums[worker_timeout]=120]"
namespace :dj do task :start, [ :args_expr ] => :environment do |t, args| options = Rack::Utils.parse_nested_query(args[:args_expr]) end end
=> {"ebooks"=>{"workers_number"=>"16", "worker_timeout"=>"60"}, "albums"=>{"workers_number"=>"32", "worker_timeout"=>"120"}}
task :default, [:version] => [:build] task :build, :version do |t,args| version = args[:version] puts version ? "version is end
task :task_name, [:arg_1] => [:pre_1, :pre_2] do |t, args| end
namespace :dummy_data do desc "Tests options hash like arguments" task :test, [:options] => :environment do |t, args| arg_options = args[:options] || two_d_array = arg_options.scan(/\W*(\w*): (\w*)\W*/) puts two_d_array.to_s + string_key_hash = two_d_array.to_h puts string_key_hash.to_s + options = two_d_array.map {|p| [p[0].to_sym, p[1]]}.to_h puts options.to_s + default_options = {users: options = default_options.merge(options) puts options.to_s + end end
$ rake dummy_data:test["users: 100 friends: 50 colour: red"] [["users", "100"], ["friends", "50"], ["colour", "red"]] {"users"=>"100", "friends"=>"50", "colour"=>"red"} {:users=>"100", :friends=>"50", :colour=>"red"} {:users=>"100", :friends=>"50", :colour=>"red", :name=>"tom"}
namespace :name_sapace_task do desc "Description task...." task :name_task => :environment do data = ActiveSupport::JSON.decode(File.read(Rails.root+"public/file.json")) if defined?(data) end end
{ "name_task": "I "user_id": 389, "users_assigned": [389,672,524], "task_id": 3 }
install: --no-rdoc --no-ri update: --no-rdoc --no-ri
--- :update_sources: true :sources: - http: - http: :benchmark: false :bulk_threshold: 1000 :backtrace: false :verbose: true gem: --no-ri --no-rdoc
c:\Documents and Settings\All Users\Application Data\gemrc
sudo /Applications/TextEdit.app/Contents/MacOS/TextEdit ~/.gemrc
def current_url(overwrite={}) url_for :only_path => false, :params => params.merge(overwrite) end
current_url --> http: current_url(:page=>4) --> http:
<%= request.env["HTTP_HOST"] + page = "/" + request.path_parameters[
- if request.env["HTTP_REFERER"].to_s.scan("history").length > 0 - back_url = user_history_issue_path(@user, list: "needed_type") - else - back_url = user_needed_type_issue_path(@user) - remote ||= false =link_to t("static.back"), back_url, :remote => remote
(url_for(:only_path => false) == "/" )? root_url : url_for(:only_path => false)
link_to current_path(@resource, :only_path => false), current_path(@resource)
request.original_url or request.env["HTTP_REFERER"] or request.env[
def current_url_without_parameters request.base_url + request.path end
class Person def name @name end end person = Person.new person.name person.name = "Dennis"
class Person def name @name end def name=(str) @name = str end end person = Person.new person.name = person.name
class Person attr_reader :name attr_writer :name end
class Person attr_accessor :name end person = Person.new person.name = "Dennis" person.name
class Person attr_accessor :name def greeting "Hello end end person = Person.new person.name = "Dennis" person.greeting
class Foo def bar @bar end def bar=( new_value ) @bar = new_value end end
class Module def var( method_name ) inst_variable_name = "@ define_method method_name do instance_variable_get inst_variable_name end define_method " instance_variable_set inst_variable_name, new_value end end end class Foo var :bar end f = Foo.new p f.bar f.bar = 42 p f.bar
def self.attr_accessor(*names) names.each do |name| define_method(name) {instance_variable_get("@ define_method(" end end
class Person attr_accessor :name def initialize(name) @name = name end def greeting "Hello end end person = Person.new("Denis") puts person.greeting
class Person attr_accessor :name def greeting "Hello end end person = Person.new person.name = "Dennis" puts person.greeting
class Item def initialize(item_name, quantity) @item_name = item_name @quantity = quantity end def item_name @item_name end def quantity @quantity end end example = Item.new("TV",2) puts example.item_name puts example.quantity
class Item attr_reader :item_name, :quantity def initialize(item_name, quantity) @item_name = item_name @quantity = quantity end end item = Item.new("TV",2) puts item.item_name puts item.quantity
class Item attr_reader :item_name def item_name=(str) @item_name = (str) end end
class Item attr_reader :item_name attr_writer :item_name end item = Item.new puts item.item_name = "TV"
class Item attr_reader :item_name def initialize(item_name) @item_name = item_name end end item = Item.new("TV") puts item.item_name
class Person def name @name end def name=(str) @name = str end end person = Person.new person.name = person.name
class Person attr_accessor :name end person = Person.new person.name = "Eshaan" person.name
attr_reader :v is equivalant to def v @v end attr_writer :v is equivalant to def v=(value) @v=value end
attr_accessor :v which means attr_reader :v; attr_writer :v
class BankAccount def initialize( account_owner ) @owner = account_owner @balance = 0 end def deposit( amount ) @balance = @balance + amount end def withdraw( amount ) @balance = @balance - amount end end
$ bankie = BankAccout.new("Iggy") $ bankie $ bankie.deposit(100) $ bankie.withdraw(5)
module Mod attr_accessor(:one, :two) end Mod.instance_methods.sort
class Car def initialize @wheels = 4 end end c = Car.new c.wheels
class Car def wheels @wheels end def wheels=(val) @wheels = val end end f = Car.new f.wheels = 4 f.wheels
class Car attr_accessor :wheels end f = Car.new f.wheels = 4 f.wheels
<form action="http: <p><input type="hidden" name="to" value="ciro"></p> <p><input type="hidden" name="ammount" value="100"></p> <p><button type="submit">CLICK TO GET PRIZE!!!</button></p> </form>
<form action="http: <p><input type="hidden" name="authenticity_token" value="j/DcoJ2VZvr7vdf8CHKsvjdlDbmiizaOb5B8DMALg6s=" ></p> <p><input type="hidden" name="to" value="ciro"></p> <p><input type="hidden" name="ammount" value="100"></p> <p><button type="submit">Send 100$ to Ciro.</button></p> </form>
<input name="authenticity_token" type="hidden" value="token_value">
<a href="http: var f = document.createElement( f.style.display = this.parentNode.appendChild(f); f.method = f.action = f.submit(); return false;">To the harmless survey</a>
<form accept-charset="UTF-8" action="/" method="post"> <input name="utf8" type="hidden" value="& <input name="authenticity_token" type="hidden" value="J7CBxfHalt49OSHp27hblqK20c9PgwJ108nDHX/8Cts=" /> Form contents </form>
<input name="authenticity_token" type="hidden" value="J7CBxfHalt49OSHp27hblqK20c9PgwJ108nDHX/8Cts=" />
loop do begin sleep 1 eval "djsakru3924r9eiuorwju3498 += 5u84fior8u8t4ruyf8ihiure" rescue Exception puts "I refuse to fail or be stopped!" end end
while true do begin line = STDIN.gets rescue Exception => e puts "caught exception end end
begin rescue Exception => e myLogger.error("uncaught myLogger.error("Stack trace: end
%W/INT QUIT TERM/.each { |sig| trap sig,"SYSTEM_DEFAULT" }
begin do_something rescue Exception => e critical_cleanup raise end
begin eval self.steering_wheel rescue Exception => e self.beep self.log "Caught self.log "Logged Error - Continuing Process.", :info end
begin rescue Exception => e self.airbags.inflate if self.exceeding_safe_stopping_momentum? raise end
begin ensure self.airbags.inflate if self.exceeding_safe_stopping_momentum? end
a = class << a def inspect end end a.inspect a = a.inspect
class String class << self def value_of obj obj.to_s end end end String.value_of 42
class String def self.value_of obj obj.to_s end end
class StateMachineExample def process obj process_hook obj end private def process_state_1 obj class << self alias process_hook process_state_2 end end def process_state_2 obj class << self alias process_hook process_state_1 end end alias process_hook process_state_1 end
class Foo def an_instance_method puts "I am an instance method" end def self.a_class_method puts "I am a class method" end end foo = Foo.new def foo.a_singleton_method puts "I am a singletone method" end
foo = Foo.new class << foo def a_singleton_method puts "I am a singleton method" end end
class Foo class << self def a_singleton_and_class_method puts "I am a singleton method for self and a class method for Foo" end end end
class Hi self class << self self self == Hi.singleton_class end end
hi = String.new def hi.a end hi.class.instance_methods.include? :a hi.singleton_class.instance_methods.include? :a
class Zen end z1 = Zen.new z2 = Zen.new class << z1 def say_hello puts "Hello!" end end z1.say_hello z2.say_hello
class Zabuton class << self def stuff puts "Stuffing zabuton…" end end end
class SomeClass class << self def test end end end test_obj = SomeClass.new def test_obj.test_2 end class << test_obj def test_3 end end puts "Singleton puts SomeClass.singleton_methods puts puts "Singleton puts test_obj.singleton_methods
%w(one two three) %i(one two three) %w[one two three] %i[one two three]
names = %( Porter Smith Jimmy Jones Ronald Jackson).split(
require p SecureRandom.random_number(100) p SecureRandom.random_number(100) p SecureRandom.random_number p SecureRandom.random_number p SecureRandom.hex
https: class String # # # # # # # # # # # # def self.random(len=32, character_set = ["A".."Z", "a".."z", "0".."9"]) chars = character_set.map{|x| x.is_a?(Range) ? x.to_a : x }.flatten Array.new(len){ chars.sample }.join end end
$ gem install rails:0.14.4 rubyzip: … Successfully installed rails-0.14.4 Successfully installed rubyzip-0.9.9
$ apt-cache madison ruby ruby | 1:1.9.3 | http: ruby | 4.5 | http:
sudo bash -c "source /usr/local/rvm/scripts/rvm; rvm 1.9.3"
source /usr/local/rvm/scripts/rvm && rvm install ruby-1.9.3 sudo bash -c "source /usr/local/rvm/scripts/rvm && rvm install ruby-1.9.3"
value = ""; 8.times{value << ((rand(2)==1?65:97) + rand(25)).chr}
o = [( string = (0...50).map { o[rand(o.length)] }.join
def generate_activation_code(size = 6) charset = %w{ 2 3 4 6 7 9 A C D E F G H J K M N P Q R T V W X Y Z} (0...size).map{ charset.to_a[rand(charset.size)] }.join end
require p SecureRandom.urlsafe_base64(5) p SecureRandom.urlsafe_base64 p SecureRandom.urlsafe_base64(nil, true)
len = 8 SecureRandom.alphanumeric(len) => "larHSsgL"
require require len = 10 n = 100_000 Benchmark.bm(12) do |x| x.report( x.report( o = [( n.times { (0...len).map { o[rand(o.length)] }.join } end end
user system total real SecureRandom 0.429442 0.002746 0.432188 ( 0.432705) rand 0.306650 0.000716 0.307366 ( 0.307745)
def random_string(length=10) chars = password = length.times { password << chars[rand(chars.size)] } password end
require srand seed = "-- Digest::SHA1.hexdigest(seed)[0,8]
ALPHABET = ( 10.times.map { ALPHABET.sample }.join 10.times.inject(
length = 10 characters = ( password = SecureRandom.random_bytes(length).each_char.map do |char| characters[(char.ord % characters.length)] end.join
def random_string(length = 8) rand(32**length).to_s(32) end
class String def self.random(len=32, character_set = ["A".."Z", "a".."z", "0".."9"]) characters = character_set.map { |i| i.to_a }.flatten characters_len = characters.length (0...len).map{ characters[rand(characters_len)] }.join end end
def token(length=16) chars = [*( (0..length).map {chars.sample}.join end
def generate_random_string(length=6) string = "" chars = ("A".."Z").to_a length.times do string << chars[rand(chars.length-1)] end string end
CHARS = ( def rand_string(length=8) s= length.times{ s << CHARS[rand(CHARS.length)] } s end
=begin Every body mentioned this way to have multiline comments. The =begin and =end must be at the beginning of the line or it will be a syntax error. =end puts "Hello world!" <<-DOC Also, you could create a docstring. which... DOC puts "Hello world!" "..is kinda ugly and creates a String instance, but I know one guy with a Smalltalk background, who does this." puts "Hello world!" __END__ But all forgot there is another option. Only at the end of a file, of course.
=begin Between =begin and =end, any number of lines may be written. All of these lines are ignored by the Ruby interpreter. =end puts "Hello world!"
=begin print "Give me a number:" number = gets.chomp.to_f total = number * 10 puts "The total value is : =end
<% =begin %> ... multiple HTML lines to comment out <%= image_tag("image.jpg") %> <% =end %>
<% if false %> ... multiple HTML lines to comment out <%= image_tag("image.jpg") %> <% end %>
varMessage = "hi/thsid/sdfhsjdf/dfjsd/sdjfsdn\n" "/my/name/is/balaji.so\n" "call::myFunction(int const&)\n" "void::secondFunction(char const&)\n" . . . "this/is/last/line/liobrary.so"
"hi/thsid/sdfhsjdf/dfjsd/sdjfsdn\n" "/my/name/is/balaji.so\n" "call::myFunction(int const&)\n"
my_string = "abcdefg" if my_string.include? "cde" puts "String includes end
my_string = "Hello world" if my_string["Hello"] puts else puts end
"foobar" =~ /bar/ "foobar" =~ /foo/ "foobar" =~ /zzz/
my_string = "abcdefg" if "cde".in? my_string puts " puts "i.e. String includes end
0> if s[sub_s] 1> puts "\" 1> else 1* puts "\" 1> end "abcdefg" has "abc" 0> if s[sub_s] 1> puts "\" 1> else 1* puts "\" 1> end "abcdefg" does not have "xyz"
user_input = gets.chomp user_input.downcase! if user_input.include?( end
puts "Enter a string" user_input = gets.chomp user_input.downcase! if user_input.include?( puts "Found" else puts "Not found" end
str = str.match? str.match? str.match? str.match? str.match?
for i in 0..5 if i < 2 next end puts "Value of local variable is end
Value of local variable is 2 Value of local variable is 3 Value of local variable is 4 Value of local variable is 5 => 0..5
namespace :schema do desc task :dump => [:environment, :load_config] do require filename = ENV[ File.open(filename, "w:utf-8") do |file| ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, file) end db_namespace[ end desc task :load => [:environment, :load_config, :check_protected_environments] do ActiveRecord::Tasks::DatabaseTasks.load_schema_current(:ruby, ENV[ end
namespace :migrate do task :redo => [:environment, :load_config] do if ENV[ db_namespace[ db_namespace[ else db_namespace[ db_namespace[ end end
namespace :db do task create: ["db:mysql:build", "db:postgresql:build"] task drop: ["db:mysql:drop", "db:postgresql:drop"] end
>> a = 1 => 1 >> defined? a => "local-variable" >> defined? b => nil >> defined? nil => "nil" >> defined? String => "constant" >> defined? 1 => "expression"
if (defined?(var)).nil? print "var is not defined\n".color(:red) else print "var is defined\n".color(:green) end
a = "apple" c = nil unless defined? a puts "a is not defined" end unless defined? b puts "b is not defined" end unless defined? c puts "c is not defined" end
require require if defined?(var).nil? print "var is not defined\n".color(:red) else print "car is defined\n".color(:green) end
def method1 return @x if defined? @x @x = method2 end
› irb >> a = nil => nil >> defined?(a) => "local-variable" >> defined?(b) => nil >> !!defined?(a) => true >> !!defined?(b) => false
>> (!!defined?(a) ? "var is defined".colorize(:green) : "var is not defined".colorize(:red)) == (defined?(a) ? "var is defined".colorize(:green) : "var is not defined".colorize(:red)) => true
>> puts "var is defined? var is defined? true vs local-variable => nil
foo = 1 my_foo = "foo" my_bar = "bar" try(:foo) try(:bar) try(my_foo) try(my_bar)
require my_object = { :array => [1, 2, 3, { :sample => "hash"} ], :foo => "bar" } puts JSON.pretty_generate(my_object)
{ "array": [ 1, 2, 3, { "sample": "hash" } ], "foo": "bar" }
class PrettyJsonResponse def initialize(app) @app = app end def call(env) status, headers, response = @app.call(env) if headers["Content-Type"] =~ /^application\/json/ obj = JSON.parse(response.body) pretty_str = JSON.pretty_unparse(obj) response = [pretty_str] headers["Content-Length"] = pretty_str.bytesize.to_s end [status, headers, response] end end
<% if !@data.blank? %> <pre><%= JSON.pretty_generate(@data) %></pre> <% end %>
ActionController::Renderers.add :json do |json, options| unless json.kind_of?(String) json = json.as_json(options) if json.respond_to?(:as_json) json = JSON.pretty_generate(json, options) end if options[:callback].present? self.content_type ||= Mime::JS " else self.content_type ||= Mime::JSON json end end
pp User.first.as_json "id" => 1, "first_name" => "Polar", "last_name" => "Bear" }
<% require hash = JSON[{hey: "test", num: [{one: 1, two: 2, threes: [{three: 3, tthree: 33}]}]}.to_json] %> <pre> <%= JSON.pretty_generate(hash) %> </pre>
require "awesome_print" require "json" json = ap(JSON.parse(json))
{ "holy" => [ [0] "nested", [1] "json" ], "batman!" => { "a" => 1, "b" => 2 } }
class PrettyJsonResponse def initialize(app) @app = app end def call(env) @status, @headers, @response = @app.call(env) [@status, @headers, self] end def each(&block) @response.each do |body| if @headers["Content-Type"] =~ /^application\/json/ body = pretty_print(body) end block.call(body) end end private def pretty_print(json) obj = JSON.parse(json) JSON.pretty_unparse(obj) end end
def branch @data = Model.all render json: JSON.pretty_generate(@data.as_json) end
require "pp" require "json" class File def pp(*objs) objs.each {|obj| PP.pp(obj, self) } objs.size <= 1 ? objs.first : objs end def jj(*objs) objs.each {|obj| obj = JSON.parse(obj.to_json) self.puts JSON.pretty_generate(obj) } objs.size <= 1 ? objs.first : objs end end test_object = { :name => { first: "Christopher", last: "Mullins" }, :grades => [ "English" => "B+", "Algebra" => "A+" ] } test_json_object = JSON.parse(test_object.to_json) File.open("log/object_dump.txt", "w") do |file| file.pp(test_object) end File.open("log/json_dump.txt", "w") do |file| file.jj(test_json_object) end
def index my_json = render json: JSON.pretty_generate( JSON.parse my_json ) end
class LogJson def initialize(app) @app = app end def call(env) dup._call(env) end def _call(env) @status, @headers, @response = @app.call(env) [@status, @headers, self] end def each(&block) if @headers["Content-Type"] =~ /^application\/json/ obj = JSON.parse(@response.body) pretty_str = JSON.pretty_unparse(obj) @headers["Content-Length"] = Rack::Utils.bytesize(pretty_str).to_s Rails.logger.info ("HTTP Headers: Rails.logger.info ("HTTP Status: Rails.logger.info ("JSON Response: end @response.each(&block) end end
class PrettyJson def self.dump(object) JSON.pretty_generate(object, {:indent => " "}) end end Rabl.configure do |config| ... config.json_engine = PrettyJson if Rails.env.development? ... end
ActiveSupport::TimeWithZone.class_eval do alias_method :orig_to_s, :to_s def to_s(format = :default) format == :default ? iso8601 : orig_to_s(format) end end
a_hash = {user_info: {type: "query_service", e_mail: "my@email.com", phone: "+79876543322"}, cars_makers: ["bmw", "mitsubishi"], car_models: [bmw: {model: "1er", year_mfc: 2006}, mitsubishi: {model: "pajero", year_mfc: 1997}]} pretty_html = a_hash.pretty_html module MyPrettyPrint def pretty_html indent = 0 result = "" if self.class == Hash self.each do |key, value| result += " end elsif self.class == Array result = "[ end " end end class Hash include MyPrettyPrint end class Array include MyPrettyPrint end
my_hash = {} my_hash[:my_key] = my_hash.has_key?("my_key") => false my_hash.has_key?("my_key".to_sym) => true my_hash2 = {} my_hash2[ my_hash2.has_key?("my_key") => true my_hash2.has_key?("my_key".to_sym) => false
hash = { one: 1, two:2 } hash.key?(:one) hash.key?(:four)
str = "A 54mpl3 string w1th 7 numb3rs scatter36 ar0und" str.scan(/\d+/)
str.to_enum(:scan, /\d+/).map { Regexp.last_match }
match_datas = str.to_enum(:scan, /\d+/).map { Regexp.last_match } match_datas[0].offset(0) match_datas[1].offset(0)
str="A 54mpl3 string w1th 7 numbers scatter3r ar0und" re=/(\d+)[m-t]/
ruby script/generate migration RemoveFieldNameFromTableName field_name:datatype
rails generate migration RemoveFieldNameFromTableName field_name:datatype
rails generate migration RemoveFieldNameFromTableName field_name:datatype
def up remove_column :table_name, :field_name end def down add_column :table_name, :field_name, :datatype end
def change remove_column :table_name, :field_name end
class RemoveFieldFromTableName < ActiveRecord::Migration def change remove_column :table_name, :field_name, :data_type, {} end end
change_table :users do |t| t.remove :first_name end
rails generate migration remove_COLUMNNAME_from_TABLENAME COLUMNNAME:DATATYPE
rails generate migration remove_access_level_from_users access_level:string
rails g migration Remove<Anything>From<TableName> [columnName:type]
class RemoveAgeFromUsers < ActiveRecord::Migration def up remove_column :users, :age end def down add_column :users, :age, :integer end end
rails g migration RemoveXColumnFromY column_name:data_type
rails g migration remove_column_name_from_table_name column_name:data_type
class RemoveColumn < ActiveRecord::Migration def change remove_column :table_name, :column_name, :data_type end end
Psychologist intervened, cancelling implosion, crisis avoided :)
rm -rf /usr/local/rvm sudo rm /etc/profile.d/rvm.sh sudo rm /etc/rvmrc sudo rm ~/.rvmrc
~/.bashrc ~/.bash_profile ~/.profile ~/.zshrc ~/.zlogin
source /etc/profile.d/sm.sh source /etc/profile.d/rvm.sh
class Array def sum inject(0) { |sum, x| sum + x } end end
class Array def sum(method = nil, &block) if block_given? raise ArgumentError, "You cannot pass a block and a method!" if method inject(0) { |sum, i| sum + yield(i) } elsif method inject(0) { |sum, i| sum + i.send(method) } else inject(0) { |sum, i| sum + i } end end end
{ 1 => 10, 2 => 20 }.sum {|k, v| k * v } (1..10).sum (1..10).sum {|v| v * 2 }
a = [1,2,3,4,5,12,23.45,nil,23,nil] puts a.compact.inject(:+)
[1] pry(main)> [1,2,3,4].sum => 10 [2] pry(main)> [].sum => 0 [3] pry(main)> [1,2,3,5,nil].sum TypeError: nil can
[24] pry(main)> [].inject(:+) => nil [25] pry(main)> [].inject(0, :+) => 0 [4] pry(main)> [1,2,3,4,5].inject(0, :+) => 15 [5] pry(main)> [1,2,3,4,nil].inject(0, :+) TypeError: nil can from (pry):5:in `+'
[6] pry(main)> [1,2,3].reduce(:+) => 6 [9] pry(main)> [].reduce(:+) => nil [7] pry(main)> [1,2,nil].reduce(:+) TypeError: nil can from (pry):7:in `+'
[16] pry(main)> sum = 0 => 0 [17] pry(main)> [1,2,3,4,nil, => [1, 2, 3, 4, nil, ""] [18] pry(main)> sum => 10
[26] pry(main)> a = [1,3,4,5] => [1, 3, 4, 5] [27] pry(main)> eval a.join => 13 [30] pry(main)> a = [1,3,4,5, nil] => [1, 3, 4, 5, nil] [31] pry(main)> eval a.join SyntaxError: (eval):1: syntax error, unexpected end-of-input 1+3+4+5+
def sum(array) array.length == 1 ? array.pop() : array.pop() + sum(array) end
def sum(numbers) return 0 if numbers.length < 1 result = 0 numbers.each { |num| result += num } result end
myArray = ["stuff", "widget", "ruby", "goodies", "java", "emerald", "etc" ] item = myArray[rand(myarray.length)]
def random_items(array) array.sample(1 + rand(array.count)) end
my_array = ["one", "two", "three"] my_array.sample(1 + rand(my_array.count)) => ["two", "three"] => ["one", "three", "two"] => ["two"]
arr = [1,9,5,2,4,9,5,8,7,9,0,8,2,7,5,8,0,2,9] arr[rand(arr.count)]
begin file = File.open("/tmp/some_file", "w") file.write("your text") rescue IOError => e ensure file.close unless file.nil? end
static VALUE rb_io_s_open(int argc, VALUE *argv, VALUE klass) { VALUE io = rb_class_new_instance(argc, argv, klass); if (rb_block_given_p()) { return rb_ensure(rb_yield, io, io_close, io); } return io; }
class Object def all_equals(o) ops = [:==, :===, :eql?, :equal?] Hash[ops.map(&:to_s).zip(ops.map {|s| send(s, o) })] end end "a".all_equals "a"
case some_object when /a regex/ when 2..4 when lambda {|x| some_crazy_custom_predicate } end
class Equ attr_accessor :val alias_method :initialize, :val= def hash() self.val % 2 end def eql?(other) self.hash == other.hash end end h = {Equ.new(3) => 3, Equ.new(8) => 8, Equ.new(15) => 15} h.size h[Equ.new(27)]
"meditation".hash "meditation".hash "meditation".hash
Symbol.instance_method(:hash).owner Integer.instance_method(:hash).owner String.instance_method(:hash).owner Hash.instance_method(:hash).owner
String === "zen" Range === (1..2) Array === [1,2,3] Integer === 2
2.is_a? Integer 2.kind_of? Integer 2.instance_of? Integer
(1..4) === 3 (1..4) === 2.345 (1..4) === 6 ("a".."d") === "c" ("a".."d") === "e"
minutes = 15 case minutes when 10..20 puts "match" else puts "no match" end
if (10..20) === minutes puts "match" else puts "no match" end
"practice zazen" =~ /zen/ "practice zazen" =~ /discursive thought/ :zazen =~ /zen/ :zazen =~ /discursive thought/
/zen/ =~ "practice zazen" /zen/ =~ "discursive thought"
puts "yes" if "zazen" =~ /zen/ "zazen" =~ /zen/?"yes":"no"
if meditation_type == "zazen" || meditation_type == "shikantaza" || meditation_type == "kinhin" true end Can be rewritten as: if meditation_type =~ /^(zazen|shikantaza|kinhin)$/ true end
case value when /regexp/ when 4..10 when MyClass when ->(value) { ... } when a, b, c, d when *array when x end
arr = [ arr.grep(/[qx]/) arr.grep(4..10) arr.grep(String) arr.grep(1)
def eq(a, b) puts " puts " puts " puts " end eq("all", "all") eq(:all, :all) eq(Object.new, Object.new) eq(3, 3) eq(1, 1.0)
s = " I have leading and trailing white space ".strip
"1232 23 2 23 232 232".delete( => "123223223232232"
user system total real gsub, s 0.180000 0.010000 0.190000 (0.193014) gsub, s+ 0.200000 0.000000 0.200000 (0.196408) gsub, space 0.220000 0.000000 0.220000 (0.222711) gsub, join 0.200000 0.000000 0.200000 (0.193478) delete 0.040000 0.000000 0.040000 (0.045157)
content = " a big nasty chunk of something that like this " content.gsub(/\s+/, " ").strip
" leading trailing ".squeeze( => "leading trailing"
require " leading trailing ".squish => "leading trailing" " good men ".squish => "good men"
$ s = " I have white space ".split => ["I", "have", "white", "space"]
"Some Special Text Values".gsub(/[[:space:]]+/, "")
a = "\tI have some whitespaces.\t" a.gsub!(/\s/, a.gsub!(/ /, a.delete!(" ") a.delete!("/\s/") a.delete!(
string = " Many have tried; many have failed! " puts "Original [ new_string = string.strip puts "Updated [
string = " Many have tried; many have failed! " puts "Original [ string.strip! puts "Updated [
Original [ Many have tried; many have failed! ]:40 Updated [Many have tried; many have failed!]:34
require string = Times = 25_000 a = Times.times.map {|n| spaces = b = Times.times.map {|n| spaces = c = Times.times.map {|n| spaces = d = Times.times.map {|n| spaces = puts RUBY_DESCRIPTION puts "============================================================" puts "Running tests for trimming strings" Benchmark.bm(20) do |x| x.report("s.strip:") { a.each {|s| s = s.strip } } x.report("s.rstrip.lstrip:") { a.each {|s| s = s.rstrip.lstrip } } x.report("s.gsub:") { a.each {|s| s = s.gsub(/^\s+|\s+$/, "") } } x.report("s.sub.sub:") { a.each {|s| s = s.sub(/^\s+/, "").sub(/\s+$/, "") } } x.report("s.strip!") { a.each {|s| s.strip! } } x.report("s.rstrip!.lstrip!:") { b.each {|s| s.rstrip! ; s.lstrip! } } x.report("s.gsub!:") { c.each {|s| s.gsub!(/^\s+|\s+$/, "") } } x.report("s.sub!.sub!:") { d.each {|s| s.sub!(/^\s+/, "") ; s.sub!(/\s+$/, "") } } end
ruby 2.2.5p319 (2016-04-26 revision 54774) [x86_64-darwin14] ============================================================ Running tests for trimming strings user system total real s.strip: 2.690000 0.320000 3.010000 ( 4.048079) s.rstrip.lstrip: 2.790000 0.060000 2.850000 ( 3.110281) s.gsub: 13.060000 5.800000 18.860000 ( 19.264533) s.sub.sub: 9.880000 4.910000 14.790000 ( 14.945006) s.strip! 2.750000 0.080000 2.830000 ( 2.960402) s.rstrip!.lstrip!: 2.670000 0.320000 2.990000 ( 3.221094) s.gsub!: 13.410000 6.490000 19.900000 ( 20.392547) s.sub!.sub!: 10.260000 5.680000 15.940000 ( 16.411131)
string = "this is a string to smash together" string.tr(
string = "this is a string with tabs\t and a \nnewline" string.tr(" \n\t",
string = "White spaces in me".scan(/\w+/).join =>"Whitespacesinme"
my_string = "Foo bar\nbaz quux" my_string.split.join => "Foobarbazquux"
attr_accessor :var attr_reader :var attr_writer :var
irb(main):024:0> class A irb(main):025:1> attr_reader :a irb(main):026:1> def initialize irb(main):027:2> @a = {a:1, b:2} irb(main):028:2> end irb(main):029:1> end => :initialize irb(main):030:0> a = A.new => irb(main):031:0> a.a => {:a=>1, :b=>2} irb(main):032:0> a.a.delete(:b) => 2 irb(main):033:0> a.a => {:a=>1} irb(main):034:0> a.a = {} NoMethodError: undefined method `a= from (irb):34 from /usr/local/bin/irb:11:in `<main>'
file = File.open("myFile.txt", "w") begin file << " rescue ensure file.close unless file.nil? end
file = File.open("myFile.txt", "w") begin file << " file.close rescue ensure file.close unless file.nil? end
begin rescue SomeExceptionClass => some_variable rescue SomeOtherException => some_other_variable else ensure end
File.open( file.puts content end def File.open(filename, mode= yield filehandle = new(filename, mode, perm, opt) ensure filehandle&.close end
class File { static T open<T>(string filename, string mode, Func<File, T> block) { var handle = new File(filename, mode); try { return block(handle); } finally { handle.Dispose(); } } } File.open("myFile.txt", "w", (file) => { file.WriteLine(contents); });
begin raise "Error!!" rescue puts "test1" raise ensure puts "Ensure block" end
File.open("myFile.txt", "w") do |file| begin file << " rescue end end
begin raise "Error!!" rescue ensure p "=========inside ensure block" end
def hoge begin raise rescue raise ensure puts end puts end
rails generate scaffold posts title:string content:text rails destroy scaffold posts title:string content:text
> invoke active_record > create db/migrate/20160905064128_create_games.rb > create app/models/game.rb > invoke test_unit > create test/models/game_test.rb > create test/fixtures/games.yml > invoke resource_route > route resources :games > invoke inherited_resources_controller > create app/controllers/games_controller.rb > invoke erb > create app/views/games > create app/views/games/index.html.erb > create app/views/games/edit.html.erb > create app/views/games/show.html.erb > create app/views/games/new.html.erb > create app/views/games/_form.html.erb > invoke test_unit > create test/controllers/games_controller_test.rb > invoke helper > create app/helpers/games_helper.rb > invoke test_unit > create test/helpers/games_helper_test.rb > invoke jbuilder > create app/views/games/index.json.jbuilder > create app/views/games/show.json.jbuilder > invoke assets > invoke coffee > create app/assets/javascripts/games.js.coffee > invoke scss > create app/assets/stylesheets/games.css.scss > invoke scss > create app/assets/stylesheets/scaffolds.css.scss
rails generate scaffold MODEL_NAME FIELD_NAME:DATATYPE Ex - rails generate scaffold User name:string address:text
rails destroy scaffold User name:string address:text
rails generate scaffold User name:string address:text rake db:migrate
rake db:rollback rails destroy scaffold User name:string address:text
class Hash # def except(*keys) dup.except!(*keys) end def except!(*keys) keys.each { |key| delete(key) } self end end
1.9.3p0 :002 > h = {:a => 1, :b => 2} => {:a=>1, :b=>2} 1.9.3p0 :003 > h.tap { |hs| hs.delete(:a) } => {:b=>2}
➜ ~ irb 1.9.3p125 :001 > require 1.9.3p125 :002 > h = {:a => 1, :b => 2, :c => 3} => {:a=>1, :b=>2, :c=>3} 1.9.3p125 :003 > h.except(:a) => {:b=>2, :c=>3} 1.9.3p125 :004 > h.slice(:a) => {:a=>1}
1.9.3p125 :011 > {:a => 1, :b => 2, :c => 3}.except!(:a) => {:b=>2, :c=>3} 1.9.3p125 :012 > {:a => 1, :b => 2, :c => 3}.slice!(:a) => {:b=>2, :c=>3}
2.2.2 :074 > hash = {"one"=>1, "two"=>2, "three"=>3} => {"one"=>1, "two"=>2, "three"=>3} 2.2.2 :075 > hash.slice("one","two") => {"one"=>1, "two"=>2} 2.2.2 :076 > hash => {"one"=>1, "two"=>2, "three"=>3}
2.2.2 :094 > hash = {"one"=>1, "two"=>2, "three"=>3} => {"one"=>1, "two"=>2, "three"=>3} 2.2.2 :095 > hash.delete("one") => 1 2.2.2 :096 > hash => {"two"=>2, "three"=>3}
2.2.2 :097 > hash = {"one"=>1, "two"=>2, "three"=>3} => {"one"=>1, "two"=>2, "three"=>3} 2.2.2 :098 > hash.except("one","two") => {"three"=>3} 2.2.2 :099 > hash => {"one"=>1, "two"=>2, "three"=>3}
2.2.2 :115 > hash = {"one"=>1, "two"=>2, "three"=>3, "one_again"=>1} => {"one"=>1, "two"=>2, "three"=>3, "one_again"=>1} 2.2.2 :116 > value = 1 => 1 2.2.2 :117 > hash.delete_if { |k,v| v == value } => {"two"=>2, "three"=>3} 2.2.2 :118 > hash => {"two"=>2, "three"=>3}
>> x = {:a => 1, :b => 2, :c => 3} => {:a=>1, :b=>2, :c=>3} >> x.select{|x| x != :a} => {:b=>2, :c=>3} >> x.select{|x| ![:a, :b].include?(x)} => {:c=>3} >> x => {:a=>1, :b=>2, :c=>3}
class Hash def remove!(*keys) keys.each{|key| self.delete(key) } self end def remove(*keys) self.dup.remove!(*keys) end end require
>> hash = {:a => 1, :b => 2} => {:b=>2, :a=>1} >> hash.remove(:a) => {:b=>2} >> hash => {:b=>2, :a=>1} >> hash.remove!(:a) => {:b=>2} >> hash => {:b=>2} >> hash.remove!(:a, :b) => {}
>> require => true >> {:a => 1, :b => 2}.except(:a) => {:b=>2}
module HashExtensions refine Hash do def except!(*candidates) candidates.each { |candidate| delete(candidate) } self end def except(*candidates) dup.remove!(candidates) end end end
class FabulousCode using HashExtensions def incredible_stuff delightful_hash.except(:not_fabulous_key) end end
hash = {a: 1, b: 2, c: 3} {b: hash.delete(:b)} hash
use_remaining_hash_for_something(Proc.new { hash.delete(:key); hash }.call)
foo = "A STRING" bar = foo.downcase puts foo puts bar
foo = "BEST DAY EVER" => foo.downcase "best day ever" => foo "BEST DAY EVER" => foo.downcase! => foo "best day ever"
numbers=[1,0,10,5,8] numbers.collect{|n| puts n*2} numbers numbers.collect!{|n| puts n*2} numbers
def tag_names @tag_names || tags.map(&:name).join( end
class Symbol def to_proc Proc.new do |obj, *args| obj.send self, *args end end end
def tag_names @tag_names || tags.map { |tag| tag.name }.join( end
class Array def to_proc proc { |receiver| receiver.send *self } end end [
class Symbol def to_proc Proc.new do |receiver| receiver.send self end end end
class Symbol def to_proc Proc.new do |obj, *args| obj.send self, *args end end end
def some_method(*args, &block) puts "args: puts "block: end some_method(:whatever) some_method(&:whatever) some_method(&"whatever")
arr = %w(apple banana) reverse_upcase = proc { |i| i.reverse.upcase } reverse_upcase.is_a?(Proc) => true arr.map(reverse_upcase) arr.map(&reverse_upcase) => ["ELPPA", "ANANAB"]
def tag_names if @tag_names @tag_names else tags.map{ |t| t.name }.join( end
$ ruby -v ruby 1.8.7 (2012-02-08 patchlevel 358) [universal-darwin12.0]
$ ruby -v ruby 1.9.3p448 (2013-06-27 revision 41675) [x86_64-darwin12.4.0]
export PATH="/Users/justin/.rbenv/shims:${PATH}" source "/usr/local/Cellar/rbenv/0.4.0/libexec/../completions/rbenv.zsh" rbenv rehash 2>/dev/null rbenv() { typeset command command="$1" if [ "$ shift fi case "$command" in rehash|shell) eval `rbenv "sh-$command" "$@"`;; *) command rbenv "$command" "$@";; esac }
sudo gem update --system sudo gem install (gemfile)
rbenv install 2.1.2 (or whatever version you prefer) rbenv global 2.1.2 gem update --system
rvm install 2.1.2 rvm use 2.1.2 gem update --system
RubyGems Environment: - RUBYGEMS VERSION: 2.0.14 - RUBY VERSION: 2.0.0 - INSTALLATION DIRECTORY: /Library/Ruby/Gems/2.0.0 - RUBY EXECUTABLE: /System/Library/.../2.0/usr/bin/ruby - EXECUTABLE DIRECTORY: /usr/bin - RUBYGEMS PLATFORMS: - ruby - universal-darwin-14 - GEM PATHS: - /Library/Ruby/Gems/2.0.0 - /Users/mylogin/.gem/ruby/2.0.0 - /System/Library/.../usr/lib/ruby/gems/2.0.0 ...
ERROR: While executing gem ... (Gem::FilePermissionError) You don
sudo gem uninstall cocoapods sudo gem install cocoapods
==> which ruby /usr/bin/ruby ==> rbenv install 1.9.3-p551 Downloading ruby-1.9.3-p551.tar.bz2... -> https: Installing ruby-1.9.3-p551... Installed ruby-1.9.3-p551 to /Users/username/.rbenv/versions/1.9.3-p551 ==> which ruby /Users/username/.rbenv/shims/ruby ==> which gem /Users/username/.rbenv/shims/gem ==> gem install compass ERROR: While executing gem ... (Gem::FilePermissionError) You don ==> ruby -v ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15] ==> rbenv global 1.9.3-p551 ==> ruby -v ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin15] ==> rbenv global 1.9.3-p551 ==> rbenv rehash ==> ruby -v ruby 1.9.3p551 (2014-11-13 revision 48407) [x86_64-darwin15.4.0] ==> gem install compass Fetching: sass-3.4.22.gem (100%) Fetching: multi_json-1.11.3.gem (100%) Fetching: compass-core-1.0.3.gem (100%) Fetching: compass-import-once-1.0.5.gem (100%) Fetching: chunky_png-1.3.5.gem (100%) Fetching: rb-fsevent-0.9.7.gem (100%) Fetching: ffi-1.9.10.gem (100%) Building native extensions. This could take a while... Fetching: rb-inotify-0.9.7.gem (100%) Fetching: compass-1.0.3.gem (100%) Compass is charityware. If you love it, please donate on our behalf at http: Successfully installed sass-3.4.22 Successfully installed multi_json-1.11.3 Successfully installed compass-core-1.0.3 Successfully installed compass-import-once-1.0.5 Successfully installed chunky_png-1.3.5 Successfully installed rb-fsevent-0.9.7 Successfully installed ffi-1.9.10 Successfully installed rb-inotify-0.9.7 Successfully installed compass-1.0.3 9 gems installed Installing ri documentation for sass-3.4.22... Installing ri documentation for multi_json-1.11.3... Installing ri documentation for compass-core-1.0.3... Installing ri documentation for compass-import-once-1.0.5... Installing ri documentation for chunky_png-1.3.5... Installing ri documentation for rb-fsevent-0.9.7... Installing ri documentation for ffi-1.9.10... Installing ri documentation for rb-inotify-0.9.7... Installing ri documentation for compass-1.0.3... Installing RDoc documentation for sass-3.4.22... Installing RDoc documentation for multi_json-1.11.3... Installing RDoc documentation for compass-core-1.0.3... Installing RDoc documentation for compass-import-once-1.0.5... Installing RDoc documentation for chunky_png-1.3.5... Installing RDoc documentation for rb-fsevent-0.9.7... Installing RDoc documentation for ffi-1.9.10... Installing RDoc documentation for rb-inotify-0.9.7... Installing RDoc documentation for compass-1.0.3...
def not_found raise ActionController::RoutingError.new( end
user = User.find_by_email(params[:email]) or not_found user.do_something!
lambda { visit }.should raise_error(ActionController::RoutingError) expect { get }.to raise_error(ActionController::RoutingError)
assert_raises(ActionController::RoutingError) do get end
def render_404 respond_to do |format| format.html { render :file => " format.xml { head :not_found } format.any { head :not_found } end end
def action render_404 and return if params[:something].blank? end
def show user = User.find_by_email(params[:email]) or raise("not found") end
def show user = User.find_by_email!(params[:email]) end
describe "user view" do before do get :show, :id => end it { should_not assign_to :user } it { should respond_with :not_found } it { should respond_with_content_type :html } it { should_not render_template :show } it { should_not render_with_layout } it { should_not set_the_flash } end
raise ActiveRecord::RecordNotFound, "Record not found."
unless Rails.application.config.consider_all_requests_local rescue_from Exception, with: :handle_exception end def not_found raise ActionController::RoutingError.new( end def handle_exception(exception=nil) if exception logger = Logger.new(STDOUT) logger.debug "Exception Message: logger.debug "Exception Class: logger.debug "Exception Backtrace: \n" logger.debug exception.backtrace.join("\n") if [ActionController::RoutingError, ActionController::UnknownController, ActionController::UnknownAction].include?(exception.class) return render_404 else return render_500 end end end def render_404 respond_to do |format| format.html { render template: format.all { render nothing: true, status: 404 } end end def render_500 respond_to do |format| format.html { render template: format.all { render nothing: true, status: 500} end end
config.after_initialize do |app| app.routes.append{ match end
@resource = Resource.find(params[:id]) or not_found
class ApplicationController < ActionController::Base protect_from_forgery unless Rails.application.config.consider_all_requests_local rescue_from ActionController::RoutingError, ActionController::UnknownController, ::AbstractController::ActionNotFound, ActiveRecord::RecordNotFound, with: lambda { |exception| render_error 404, exception } end private def render_error(status, exception) Rails.logger.error status.to_s + " " + exception.message.to_s Rails.logger.error exception.backtrace.join("\n") respond_to do |format| format.html { render template: "errors/error_ format.all { render nothing: true, status: status } end end end
class ErrorsController < ApplicationController def error_404 @not_found_path = params[:not_found] end end
.site .services-page .error-template %h1 Oops! %h2 404 Not Found .error-details Sorry, an error has occured, Requested page not found! You tried to access .error-actions %a.button_simple_orange.btn.btn-primary.btn-lg{href: root_path} %span.glyphicon.glyphicon-home Take Me Home
feature ErrorHandling do before do Rails.application.config.consider_all_requests_local = false Rails.application.config.action_dispatch.show_exceptions = true end scenario visit expect(page).to have_content "The page you were looking for doesn end end
class ApplicationController < ActionController::Base rescue_from ActiveRecord::RecordNotFound, with: :conditional_404_redirect if ENV[ private def conditional_404_redirect track_404(@current_user) if @current_user.present? redirect_to_user_home else redirect_to_front end end end
class AdminController < ApplicationController before_action :blackhole_admin private def blackhole_admin return if current_user.admin? raise ActionController::RoutingError, rescue ActionController::RoutingError render file: " end end
A = Class.new B = Class.new A a, b = A.new, B.new b.class < A a.class < B b.class.ancestors.include? A a.class.ancestors.include? B
module A def say puts "this is module A" end end class B include A end class C extend A end
module Log def class_type "This class is of type: end end class TestClass include Log end tc = TestClass.new.class_type tc = TestClass.class_type
module Log def class_type "This class is of type: end end class TestClass extend Log end tc = TestClass.class_type
let(:object) {FactoryGirl.create :object} expect { post :destroy, id: review.id }.to change(Object, :count).by(-1)
context "foo" do let(:params) do { :foo => foo, :bar => "bar" } end let(:foo) { "foo" } it "is set to foo" do params[:foo].should eq("foo") end context "when foo is bar" do let(:foo) { "bar" } it "is set to bar" do params[:foo].should eq("bar") end end end
let!(:country) { create(:country) } let(:country_id) { country.id } before { get "api/countries/ it context let(:country_id) { -1 } it end
rails destroy controller lalala rails destroy model yadayada rails destroy scaffold hohoho
rails d controller lalala rails d model yadayada rails d scaffold hohoho
$ rails d controller welcome -p remove app/controllers/welcome_controller.rb invoke erb remove app/views/welcome invoke test_unit remove test/controllers/welcome_controller_test.rb invoke helper remove app/helpers/welcome_helper.rb invoke test_unit remove test/helpers/welcome_helper_test.rb invoke assets invoke coffee remove app/assets/javascripts/welcome.js.coffee invoke scss remove app/assets/stylesheets/welcome.css.scss
rails generate/destroy controller/model [controller/model Name]
rm app/controllers/welcome_controller.rb rm app/views/welcome rm test/controllers/welcome_controller_test.rb rm app/helpers/welcome_helper.rb rm test/helpers/welcome_helper_test.rb rm app/assets/javascripts/welcome.js.coffee rm app/assets/stylesheets/welcome.css.scss
rails destroy model CamelCase rails destroy controller CamelCase
people = [] info = while not info.empty? info = gets.chomp people += [Person.new(info)] if not info.empty? end
people = [] do info = gets.chomp people += [Person.new(info)] if not info.empty? while not info.empty?
begin tmpname = File.join(tmpdir, make_tmpname(basename, n)) lock = tmpname + n += 1 end while @@cleanlist.include?(tmpname) or File.exist?(lock) or File.exist?(tmpname)
>> begin ?> puts "do {} while ()" >> end while false do {} while () => nil
>> n = 3 => 3 >> begin ?> puts n >> n -= 1 >> end while n > 0 3 2 1 => nil
def expensive @expensive ||= begin n = 99 buf = "" begin buf << " n -= 1 end while n > 0 buf << "no more bottles of beer" end end
people = [] begin info = gets.chomp people += [Person.new(info)] if not info.empty? end while not info.empty?
people = [] until (info = gets.chomp).empty? people += [Person.new(info)] end
begin tmpname = File.join(tmpdir, make_tmpname(basename, n)) lock = tmpname + n += 1 end while @@cleanlist.include?(tmpname) or File.exist?(lock) or File.exist?(tmpname)
>> begin ?> puts "do {} while ()" >> end while false do {} while () => nil
>> n = 3 => 3 >> begin ?> puts n >> n -= 1 >> end while n > 0 3 2 1 => nil
def expensive @expensive ||= begin n = 99 buf = "" begin buf << " n -= 1 end while n > 0 buf << "no more bottles of beer" end end
if <cond> then <one_line_code> while <cond> then <one_line_code> <one_line_code> while <cond> begin <multiple_line_code> end while <cond>
people = [] 1.times do info = gets.chomp unless info.empty? people += [Person.new(info)] redo end end
ppl = [] while (input=gets.chomp) if !input.empty? ppl << input else p ppl; puts "Goodbye"; break end end
somearray = ["some", "thing"] anotherarray = ["another", "thing"] somearray.push(anotherarray.flatten!)
a1[a1.length, 0] = a2 a1[a1.length..0] = a2 a1.insert(a1.length, *a2)
irb(main):001:0> a = [1,2] => [1, 2] irb(main):002:0> b = [3,4] => [3, 4] irb(main):003:0> a + b => [1, 2, 3, 4]
irb(main):001:0> a=[1,2] => [1, 2] irb(main):003:0> b=[3,4] => [3, 4] irb(main):002:0> c=[5,6] => [5, 6] irb(main):004:0> [*a,*b,*c] => [1, 2, 3, 4, 5, 6]
array1 = ["foo", "bar"] array2 = ["foo1", "bar1"] array3 = array1|array2
somearray = ["some", "thing"] anotherarray = ["another", "thing"] somearray += anotherarray somearray = ["some", "thing"] somearray.concat anotherarray
[[a, b], | [[x], [[a, b, x], [c, d]] | [y]] => [c, d, y]]
m1 = [[:a, :b], [:c, :d]] m2 = [[:x], [:y]] m1m2 = m1.zip(m2).map(&:flatten)
[somearray, anotherarray].flatten => ["some", "thing", "another", "thing"]
require huge_ary_1 = Array.new(1_000_000) { rand(5_000_000..30_000_00) } huge_ary_2 = Array.new(1_000_000) { rand(35_000_000..55_000_00) } Benchmark.bm do |bm| p bm.report { huge_ary_1.concat(huge_ary_2) } p bm.report { huge_ary_1.push(*huge_ary_2) } end
user system total real "-------------------CONCAT ----------------" 0.000000 0.000000 0.000000 ( 0.009388) "------------------- PUSH ----------------" example/array_concat_vs_push.rb:13:in `block (2 levels) in <main>
lists = [["a", "b"], ["c", "d"]] flatlist = lists.reduce(:+)
somearray = ["some", "thing"] anotherarray = ["another", "thing"] somearray.push anotherarray somearray << anotherarray somearray.flatten! somearray
module MySampleModule CONST1 = "some constant" def self.method_one(arg1) arg1 + 2 end end
module Apple def a puts end end module Apple def b puts end end class Fruit include Apple end > f = Fruit.new => > f.a => a > f.b => b
module Apple module Green def green puts end end end class Fruit include Apple end > f = Fruit.new => > f.green NoMethodError: undefined method `green
class Fruit include Apple::Green end => Fruit > f.green => green
class Foo def bar() "Hello" end end class Foo def bar() super() + " World" end end >> Foo.new.bar == "Hello World"
class Foo def bar end end class ExtendedFoo < Foo def bar super + end end ExtendedFoo.new.bar
require class Foo def bar end end class WrappedFoo < DelegateClass(Foo) def initialize(wrapped_foo) super end def bar super + end end foo = Foo.new wrapped_foo = WrappedFoo.new(foo) wrapped_foo.bar
class Foo def bar end end module FooExtensions def bar super + end end class Foo prepend FooExtensions end Foo.new.bar
class Foo def bar end end module FooExtensions def bar super + end end class Foo include FooExtensions end
class Foo def bar end end class Foo old_bar = instance_method(:bar) define_method(:bar) do old_bar.bind(self).() + end end Foo.new.bar
class Foo def bar end end class Foo alias_method :old_bar, :bar def bar old_bar + end end Foo.new.bar Foo.new.old_bar
class Foo def bar end end module ExtendedFoo module FooExtensions def bar super + end end refine Foo do prepend FooExtensions end end Foo.new.bar using ExtendedFoo Foo.new.bar
class Foo def bar end end class Foo def bar:after super + end end
class Foo def bar:before end end module BarBefore def bar super end end class Foo prepend BarBefore end
class Foo def bar:after end end class BarAfter def bar original_return_value = super end end class Foo prepend BarAfter end
class Foo def bar end end class Foo def bar old + end end Foo.new.bar
class Foo def bar end end class Foo redef bar old + end end Foo.new.bar
class Foo def bar end end class Foo redef bar super + end end Foo.new.bar
a = [ "a", "b", "c", "d" ] a.collect {|x| x + "!" } a
require h = { abc: a = 1..10 many = 500_000 Benchmark.bm do |b| GC.start b.report("hash keys collect") do many.times do h.keys.collect(&:to_s) end end GC.start b.report("hash keys map") do many.times do h.keys.map(&:to_s) end end GC.start b.report("array collect") do many.times do a.collect(&:to_s) end end GC.start b.report("array map") do many.times do a.map(&:to_s) end end end
user system total real hash keys collect 0.540000 0.000000 0.540000 ( 0.570994) hash keys map 0.500000 0.010000 0.510000 ( 0.517126) array collect 1.670000 0.020000 1.690000 ( 1.731233) array map 1.680000 0.020000 1.700000 ( 1.744398)
static VALUE rb_ary_collect(VALUE ary) { long i; VALUE collect; RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length); collect = rb_ary_new2(RARRAY_LEN(ary)); for (i = 0; i < RARRAY_LEN(ary); i++) { rb_ary_push(collect, rb_yield(RARRAY_AREF(ary, i))); } return collect; }
Array.instance_method(:map) == Array.instance_method(:collect) => true
require arr.enum_for(:each_with_index).map { |x,i| [x, i+2] }
arr = ( indexes = arr.each_index.map(&2.method(:+)) arr.zip(indexes)
arr = ( arr.zip( (2..(arr.length+2)).to_a ) n = 1 arr.map{ |c| [c, n+=1 ] }
a = [1, 2, 3, 4] a.each_with_index.map { |el, index| el + index }
module Enumerable def map_with_index(&block) i = 0 self.map { |val| val = block.call(val, i) i += 1 val } end end ["foo", "bar"].map_with_index {|item, index| [item, index] } => [["foo", 0], ["bar", 1]]
arr = ["a", "b", "c"] (0...arr.length).map do |int| [arr[int], int + 2] end
class Bar def do_things Foo.some_method(x) do |x| y = x.do_something return y_is_bad if y.bad? y.do_something_else end keep_doing_more_things end end
class Foo def self.some_method(targets, &block) targets.each do |target| begin r = yield(target) rescue failed << target end end end end
f.each do |line| next if line[0,1] == " puts eval(line) end
f.each do |line| break if line == "quit\n" puts eval(line) end puts "Good bye"
def find(array, target) array.each_with_index do |element,index| return index if (element == target) end nil end
for b in 1..2 do puts b begin puts break puts end while false puts end
def contrived_example(numbers) numbers.inject(0) do |count, x| if x % 3 == 0 count + 2 elsif x.odd? count + 1 else count end end end
def contrived_example(numbers) numbers.inject(0) do |count, x| next count if x.even? next (count + 2) if x % 3 == 0 count + 1 end end
def contrived_example(numbers) numbers.inject(0) { |count, x| count + extracted_logic(x) } end def extracted_logic(x) return 0 if x.even? return 2 if x % 3 == 0 1 end
class Array def first_frog detect {|i| i =~ /frog/ } end def last_frog select {|i| i =~ /frog/ }.last end end p ["dog", "cat", "godzilla", "dogfrog", "woot", "catfrog"].first_frog p ["hats", "coats"].first_frog p ["houses", "frogcars", "bottles", "superfrogs"].last_frog
class Bar def do_things Foo.some_method(x) do |i| end end end class Foo def self.failed @failed ||= [] end def self.some_method(targets, &block) targets.reject {|t| t.do_something.bad? }.each(&block) end end
class Bar def self.do_things Foo.some_method(1..10) do |x| next if x == 2 break if x == 9 print " end end end class Foo def self.some_method(targets, &block) targets.each do |target| begin r = yield(target) rescue => x puts "rescue end end end end Bar.do_things
task :build_all do [ :debug, :release ].each do |t| $build_type = t end end
task :build => [:some_other_tasks] do build end task :build_all do [:debug, :release].each { |t| build t } end def build(type = :debug) end
Rake::Task["build"].reenable Rake::Task["build"].invoke
task :build_all do [ :debug, :release ].each do |t| $build_type = t Rake::Task["build"].reenable Rake::Task["build"].invoke end end
task :build_all do [ :debug, :release ].each do |t| $build_type = t Rake::Task["build"].execute end end
task :invoke_another_task do Rake::Task["another:task"].invoke end
task :build_all do [:debug, :release].each do |t| ts = 0 begin Rake::Task["build"].invoke(t) rescue ts = 1 next ensure Rake::Task["build"].reenable end return ts end end
WAYS = [ FLAGS = {} FLAGS[ FLAGS[ def out_dir(way) File.join( end def out_file(way) File.join(out_dir(way), end WAYS.each do |way| desc "create output directory for directory out_dir(way) desc "build in the file out_file(way) => [out_dir(way), sh "gcc end end desc task :all => WAYS.map{|way|out_file(way)} task :default => [:all]
require File.expand_path( module YouApplication class Application < Rails::Application config.i18n.enforce_available_locales = true I18n.config.enforce_available_locales = true end end
["/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/i18n-0.6.9/lib/i18n.rb:150:in `translate "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/i18n/translator.rb:8:in `translate "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/i18n.rb:79:in `translate "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/acts_as_authentic/email.rb:68:in `validates_format_of_email_field_options "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/acts_as_authentic/email.rb:102:in `block in included "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/acts_as_authentic/email.rb:99:in `class_eval "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/acts_as_authentic/email.rb:99:in `included "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/acts_as_authentic/base.rb:37:in `include "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/acts_as_authentic/base.rb:37:in `block in acts_as_authentic "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/acts_as_authentic/base.rb:37:in `each "/Users/weppos/.rvm/gems/ruby-2.0.0-p247@application/gems/authlogic-3.1.0/lib/authlogic/acts_as_authentic/base.rb:37:in `acts_as_authentic "/Users/weppos/Projects/application/app/models/user.rb:8:in `<class:User> "/Users/weppos/Projects/application/app/models/user.rb:1:in `<top (required)>
require File.expand_path( . . . module SampleApp class Application < Rails::Application . . . I18n.enforce_available_locales = true . . . end end
begin Haml; rescue NameError; else raise; end begin Faker; rescue NameError; else raise; end Bundler.require Haml begin Faker; rescue NameError; else raise; end require Faker
bundle install --path=.bundle bundle exec ruby main.rb
new_record = old_record.clone new_record = old_record.dup
class Post < ActiveRecord::Base has_many :comments has_and_belongs_to_many :tags amoeba do enable end end class Comment < ActiveRecord::Base belongs_to :post end class Tag < ActiveRecord::Base has_and_belongs_to_many :posts end class PostsController < ActionController def some_method my_post = Post.find(params[:id]) new_post = my_post.dup new_post.save end end
class Post < ActiveRecord::Base has_many :comments has_and_belongs_to_many :tags amoeba do exclude_field :comments end end
class Post < ActiveRecord::Base has_many :comments has_and_belongs_to_many :tags amoeba do include_field :tags prepend :title => "Copy of " append :contents => " (copied version)" regex :contents => {:replace => /dog/, :with => "cat"} end end
class Post < ActiveRecord::Base has_many :comments amoeba do enable end end class Comment < ActiveRecord::Base belongs_to :post has_many :ratings amoeba do enable end end class Rating < ActiveRecord::Base belongs_to :comment end
new_user = User.new(old_user.attributes.merge(:login => "newlogin"))
o = Model.find(id) (1..109).each do |item| new_record = o.dup new_record.save end
o = Model.find(id) (1..109).each do |item| new_record = o.clone new_record.save end
class User < ActiveRecord::Base has_one :profile has_many :posts end
class UserCloner < Clowne::Cloner adapter :active_record include_association :profile, clone_with: SpecialProfileCloner include_association :posts nullify :login finalize do |_source, record, params| record.email = params[:email] end end class SpecialProfileCloner < Clowne::Cloner adapter :active_record nullify :name end
user = User.last cloned = UserCloner.call(user, email: cloned.persisted? cloned.save! cloned.login cloned.email cloned.posts.count == user.posts.count cloned.profile.name
class Offer < ApplicationRecord has_many :offer_items def dup super.tap do |new_offer| new_offer.title = "Copy of self.offer_items.each { |offer_item| new_offer.offer_items << offer_item.dup } end end end
module SomeModule module InnerModule class MyClass CONSTANT = 4 end end end
MR_COUNT = 0 module Foo MR_COUNT = 0 ::MR_COUNT = 1 MR_COUNT = 2 end puts MR_COUNT puts Foo::MR_COUNT
MyClass::new::instance_method MyClass::new.instance_method MyClass.new::instance_method MyClass.new.instance_method
class User < ActiveRecord::Base VIDES_COUNT = 10 Languages = { "English" => "en", "Spanish" => "es", "Mandarin Chinese" => "cn"} end
User::VIDEOS_COUNT User::Languages User::Languages.values_at("Spanish") => "en"
devise_for :users, controllers: {omniauth_callbacks: "users/omniauth_callbacks"} class Users::OmniauthCallbacksController < Devise::OmniauthCallbacksController end
module Amimal module Herbivorous EATER="plants" end end Amimal::Herbivorous::EATER => "plants"
module Math def self.max(*values) values.max end end
people = { people.min_by { |name, age| age } people.max_by { |name, age| age }
module ReusableModule def module_method puts "Module Method: Hi there!" end end class ClassThatIncludes include ReusableModule end class ClassThatExtends extend ReusableModule end puts "Include" ClassThatIncludes.new.module_method puts "Extend" ClassThatExtends.module_method
class UserAction include Calculations def self.page_views(campaign) overall_profit = calculate_campaign_profit(campaign) end end
class UserAction extend Calculations def self.page_views(campaign) overall_profit = calculate_campaign_profit(campaign) end end
sleep(4.minutes) sleep(2.hours); sleep(3.days) sleep(0.5)
module Foo class Bar def self.say_name puts "I end end end Foo::Bar.say_name
str = => "this is a multi-line string using implicit concatenation to eliminate spare \\n
p <<END_SQL.gsub(/\s+/, " ").strip SELECT * FROM users ORDER BY users.id DESC END_SQL
p %{ SELECT * FROM users ORDER BY users.id DESC }.gsub(/\s+/, " ").strip
conn.exec from table1, table2, table3, etc, etc, etc, etc, etc, where etc etc etc etc etc etc etc etc etc etc etc etc etc'
conn.exec <<-eos select attr1, attr2, attr3, attr4, attr5, attr6, attr7 from table1, table2, table3, etc, etc, etc, etc, etc, where etc etc etc etc etc etc etc etc etc etc etc etc etc eos
SQL = %{ SELECT user, name FROM users WHERE users.id = LIMIT }
conn.exec %q{select attr1, attr2, attr3, attr4, attr5, attr6, attr7 from table1, table2, table3, etc, etc, etc, etc, etc, where etc etc etc etc etc etc etc etc etc etc etc etc etc}
conn.exec %Q{select attr1, attr2, attr3, attr4, attr5, attr6, attr7 from where etc etc etc etc etc etc etc etc etc etc etc etc etc}
conn.exec <<-eos.squish select attr1, attr2, attr3, attr4, attr5, attr6, attr7 from table1, table2, table3, etc, etc, etc, etc, etc, where etc etc etc etc etc etc etc etc etc etc etc etc etc eos
conn.exec = <<eos select attr1, attr2, attr3, attr4, attr5, attr6, attr7 from table1, table2, table3, etc, etc, etc, etc, etc, where etc etc etc etc etc etc etc etc etc etc etc etc etc eos
x = 2.3.3 :012 > x => "\nthis is\na multiline\nstring\n"
multiline_string = <<EOM This is a very long string that contains interpolation like EOM puts multiline_string message = <<-EOF asdfasdfsador asdfadsfasdfadsfad. EOF puts message
[1] pry(main)> <<~SQL.squish [1] pry(main)* select attr1, attr2, attr3, attr4, attr5, attr6, attr7 [1] pry(main)* from table1, table2, table3, etc, etc, etc, etc, etc, [1] pry(main)* where etc etc etc etc etc etc etc etc etc etc etc etc etc [1] pry(main)* SQL => "select attr1, attr2, attr3, attr4, attr5, attr6, attr7 from table1, table2, table3, etc, etc, etc, etc, etc, where etc etc etc etc etc etc etc etc etc etc etc etc etc"
conn.exec %w{select attr1, attr2, attr3, attr4, attr5, attr6, attr7 from table1, table2, table3, etc, etc, etc, etc, etc, where etc etc etc etc etc etc etc etc etc etc etc etc etc} *
conn.exec [ "select attr1, attr2, attr3, ...", "from table1, table2, table3, ...", "where ..." ].join(
"select attr1, attr2, attr3, attr4, attr5, attr6, attr7 \ from table1, table2, table3, etc, etc, etc, etc, etc, \ where etc etc etc etc etc etc etc etc etc etc etc etc etc"
@car = Car.new(:make => @car.update_attributes(:model => @car.save
class User < ActiveRecord::Base attr_accessible :name attr_accessible :name, :is_admin, :as => :admin end user = User.new user.assign_attributes({ :name => user.assign_attributes({ :name => user.name user.is_admin? user.new_record?
class User < ActiveRecord::Base attr_protected :is_admin end user = User.new user.attributes = { :username => user.username user.is_admin? user.send(:attributes=, { :username => user.is_admin?
@user.assign_attributes{ model: "Sierra", year: "2012", looks: "Sexy" } @user.attributes = { model: "Sierra", year: "2012", looks: "Sexy" }
@user.attributes = [ { model: "Sierra" }, { year: "2012" }, { looks: "Sexy" } ]
@user.assign_attributes([ { model: "Sierra" }, { year: "2012" }, { looks: "Sexy" } ])
@user.assign_attributes{ model: "Sierra", year: "2012", looks: "Sexy" }.valid?
class User def full_name puts "Johnnie Walker" end alias name full_name end User.new.name
class User def full_name puts "Johnnie Walker" end alias_method :name, :full_name end User.new.name
class User def full_name puts "Johnnie Walker" end def self.add_rename alias_method :name, :full_name end end class Developer < User def full_name puts "Geeky geek" end add_rename end Developer.new.name
class User def full_name puts "Johnnie Walker" end def self.add_rename alias :name :full_name end end class Developer < User def full_name puts "Geeky geek" end add_rename end Developer.new.name
class Engine def start puts "start me" end end Engine.new.start() Engine.class_eval do unless method_defined?(:run) alias_method :run, :start define_method(:start) do puts " run() puts " end end end Engine.new.start Engine.new.run
class Westerner def first_name @names.first end alias given_name first_name end
module Mononymous def self.included(other) other.class_eval { alias_method :full_name, :given_name } end end class Sting < Westerner include Mononymous end
>> system("date") Wed Sep 4 22:03:44 CEST 2013 => true
>> system("date") Wed Sep 4 22:11:02 CEST 2013 => true >> $? =>
require Open3.popen3("curl http: pid = thread.pid puts stdout.read.chomp end
require Time.at(seconds_since_epoch_integer).to_datetime
$ date +%s 1318996912 $ irb ruby-1.9.2-p180 :001 > require => true ruby-1.9.2-p180 :002 > Time.at(1318996912).to_datetime =>
ruby-1.9.2-p180 :003 > Time.at(1318996912).utc.to_datetime =>
irb(main):038:0> Benchmark.measure do irb(main):039:1* ["1318996912", "1318496912"].each do |s| irb(main):040:2* DateTime.strptime(s, irb(main):041:2> end irb(main):042:1> end => irb(main):044:0> Benchmark.measure do irb(main):045:1> [1318996912, 1318496912].each do |i| irb(main):046:2> DateTime.strptime(i.to_s, irb(main):047:2> end irb(main):048:1> end => irb(main):050:0* Benchmark.measure do irb(main):051:1* ["1318996912", "1318496912"].each do |s| irb(main):052:2* Time.at(s.to_i).to_datetime irb(main):053:2> end irb(main):054:1> end => irb(main):056:0* Benchmark.measure do irb(main):057:1* [1318996912, 1318496912].each do |i| irb(main):058:2* Time.at(i).to_datetime irb(main):059:2> end irb(main):060:1> end =>
Time.at(1318996912) == DateTime.strptime("1318996912",
Time.at(Time.new(2007,11,1,15,25,0, "+09:00")) => 2007-11-01 15:25:00 +0900
DateTime.strptime(Time.now.utc.to_i.to_s, Time.now.utc.to_i DateTime.strptime(Time.now.utc.to_i.to_s,
irb(main):034:0> DateTime.strptime("1410321600", "10 09 14"
def whowouldwin mylambda = lambda {return "Freddy"} mylambda.call return "Jason" end whowouldwin
def whowouldwin2 myproc = Proc.new {return "Freddy"} myproc.call return "Jason" end whowouldwin2
concat = ->(a, b=2){ " concat.call(4,5) concat.call(1)
l = lambda { |msg = SyntaxError: compile error (irb):1: syntax error, unexpected l = lambda { |msg =
def meth1 puts "method start" pr = lambda { return } pr.call puts "method end" end def meth2 puts "method start" pr = Proc.new { return } pr.call puts "method end" end def meth3 puts "method start" pr = proc { return } pr.call puts "method end" end puts "Using lambda" meth1 puts "--------" puts "using Proc.new" meth2 puts "--------" puts "using proc" meth3
def some_method myproc = Proc.new {return "End."} myproc.call end
irb(main):021:0> l = -> (x) { x.to_s } => irb(main):022:0> p = Proc.new { |x| x.to_s} => irb(main):025:0> l.call ArgumentError: wrong number of arguments (0 for 1) from (irb):21:in `block in irb_binding' from (irb):25:in `call' from (irb):25 from /usr/bin/irb:11:in `<main>' irb(main):026:0> p.call => "" irb(main):049:0> l.call 1, 2 ArgumentError: wrong number of arguments (2 for 1) from (irb):47:in `block in irb_binding' from (irb):49:in `call' from (irb):49 from /usr/bin/irb:11:in `<main>' irb(main):050:0> p.call 1, 2 => "1"
def m1 yield end def m2 m1 &Proc.new end m2 { |e| puts e }
def foo proc = Proc.new{return} foobar(proc) puts end def foobar(proc) proc.call puts end foo
Dir["/path/to/directory/*.rb"].each {|file| require file }
Dir[File.dirname(__FILE__) + require File.basename(file, File.extname(file)) end
$ irb irb(main):001:0> require => true irb(main):002:0> require => true irb(main):003:0> require => false irb(main):004:0> require => false
dir = "/path/to/directory" $LOAD_PATH.unshift(dir) Dir[File.join(dir, "*.rb")].each {|file| require File.basename(file) }
Dir["/path/to/directory/*.rb"].each {|file| load file }
Dir[File.join(__dir__, "/app/**/*.rb")].each do |file| require file end
Post Load (3.7ms) SELECT * FROM "posts" Comment Load (0.2ms) SELECT "comments.*" FROM "comments" WHERE ("comments".post_id IN (1,2,3,4)) ORDER BY created_at asc)
Post Load (6.0ms) SELECT "posts".* FROM "posts" INNER JOIN "comments" ON "posts".id = "comments".post_id
Comment.joins(:user).where("comments.user_id is null")
comment_1 = Comment.joins(:user).first comment_1.user.age
Comment.includes(:user).where("comment.user_id is null")
comment_1 = Comment.includes(:user).first comment_1.user.age
Post.joins(:comments).count => 10 Post.joins(:comments).distinct.count => 2
lets suppose you have tow model, User and Organisation User has_many organisations suppose you have 10 organisation for a user @records= User.joins(:organisations).where("organisations.user_id = 1") QUERY will be select * from users INNER JOIN organisations ON organisations.user_id = users.id where organisations.user_id = 1 it will return all records of organisation related to user and @records.map{|u|u.organisation.name} it run QUERY like select * from organisations where organisations.id = x then time(hwo many organisation you have)
select * from users INNER JOIN organisations ON organisations.user_id = users.id where organisations.user_id = 1 and select * from organisations where organisations.id IN(IDS of organisation(1, to 10)) if 10 organisation and when you run this
gem cleanup rjb gem uninstall rjb gem uninstall rjb --version 1.1.9 gem uninstall rjb --version
rm /home/rails/.rvm/gems/ruby-2.1.1@project/cache/nokogiri-1.6.6.2.gem
irb(main):001:0> s = => "a" irb(main):002:0> s + => "ab" irb(main):003:0> s => "a" irb(main):004:0> s << => "ab" irb(main):005:0> s => "ab"
require N = 1000 BASIC_LENGTH = 10 5.times do |factor| length = BASIC_LENGTH * (10 ** factor) puts "_" * 60 + "\nLENGTH: Benchmark.bm(10, concat_report = x.report("+=") do str1 = "" str2 = "s" * length N.times { str1 += str2 } end modify_report = x.report("<<") do str1 = "s" str2 = "s" * length N.times { str1 << str2 } end [concat_report / modify_report] end end
____________________________________________________________ LENGTH: 10 user system total real += 0.000000 0.000000 0.000000 ( 0.004671) << 0.000000 0.000000 0.000000 ( 0.000176) += VS << NaN NaN NaN ( 26.508796) ____________________________________________________________ LENGTH: 100 user system total real += 0.020000 0.000000 0.020000 ( 0.022995) << 0.000000 0.000000 0.000000 ( 0.000226) += VS << Inf NaN NaN (101.845829) ____________________________________________________________ LENGTH: 1000 user system total real += 0.270000 0.120000 0.390000 ( 0.390888) << 0.000000 0.000000 0.000000 ( 0.001730) += VS << Inf Inf NaN (225.920077) ____________________________________________________________ LENGTH: 10000 user system total real += 3.660000 1.570000 5.230000 ( 5.233861) << 0.000000 0.010000 0.010000 ( 0.015099) += VS << Inf 157.000000 NaN (346.629692) ____________________________________________________________ LENGTH: 100000 user system total real += 31.270000 16.990000 48.260000 ( 48.328511) << 0.050000 0.050000 0.100000 ( 0.105993) += VS << 625.400000 339.800000 NaN (455.961373)
require include Benchmark count = 100_000 puts "Dynamic strings" Benchmark.benchmark(CAPTION, 7, FORMAT) do |bm| bm.report("concat") { count.times { 11.to_s + bm.report("append") { count.times { 11.to_s << bm.report("interp") { count.times { " end puts "\nPredefined strings" s11 = "11" s12 = "12" Benchmark.benchmark(CAPTION, 7, FORMAT) do |bm| bm.report("concat") { count.times { s11 + bm.report("append") { count.times { s11 << bm.report("interp") { count.times { " end
begin ERB.new("<%= ERB.new("<%= Erubis::Eruby.new("<%=
ERB.new("a \nb <% 0 -%>\n c", nil, ERB.new("a\n<% 0 -%> \nc", nil, Erubis::Eruby.new(" <% 0 %> \nb").result == Erubis::Eruby.new(" <% 0 -%> \nb").result == Erubis::Eruby.new("a <% 0 %> \nb").result == "a \nb" or raise Erubis::Eruby.new(" <% 0 %> a\nb").result == " a\nb" or raise Erubis::Eruby.new(" <% 0 -%> a\nb").result == " a\nb" or raise Erubis::Eruby.new(" <%= 0 %> \nb").result == " 0 \nb" or raise Erubis::Eruby.new(" <%= 0 -%> \nb").result == " 0b" or raise Erubis::Eruby.new("a <%= 0 -%> \nb").result == "a 0b" or raise Erubis::Eruby.new(" <%= 0 -%> a\nb").result == " 0 a\nb" or raise
ERB.new("a \n <%- 0 %> b\n c", nil, ERB.new("a \nb <%- 0 %> c\n d", nil,
<h1>Names of all the people</h1> <% @people.each do |person| %> Name: <%= person.name %><br> <% end %>
<% temp = 1 %> <% if temp == 1%> temp is 1 <% else %> temp is not 1 <%end%>
$ bundle config local.GEM_NAME /path/to/local/git/repository
bundle config local.GEM_NAME /path/to/local/git/repository
Rails 4.0.2 ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-linux] Ubuntu 13.10 RubyMine 6.0.3
~/.rvm/rubies/ruby-1.9.3-p0/lib/ruby/1.9.1/webrick/httpresponse.rb
.../ruby-1.9.3-p0/lib/ruby/1.9.1/webrick/httpresponse.rb
~/.rvm/rubies/<ruby-version>/lib/ruby/1.9.1/webrick/httpresponse.rb
nano \`ruby -e"print %x{gem which webrick}.chomp %Q{.rb\n}"\`/httpresponse.rb
~/.rvm/rubies/jruby-<version>/lib/ruby/<1.8 or 1.9>/webrick/httpresponse.rb
cd `which ruby`/../../lib/ruby/1.9.1/webrick/ && sed -i
/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in `require from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in `require' from /usr/local/Library/Homebrew/utils.rb:6:in `<top (required)>' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in `require' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in `require' from /usr/local/Library/Homebrew/global.rb:9:in `<top (required)>' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in `require' from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in `require' from /usr/local/Library/brew.rb:16:in `<main>'
1. open terminal 2. $ cd /usr/local/Library/Homebrew 3. $ git reset --hard 4. $ git clean -df 5. $ brew update
$ sudo rm /System/Library/Frameworks/Ruby.framework/Versions/Current $ sudo ln -s /System/Library/Frameworks/Ruby.framework/Versions/1.8 /System/Library/Frameworks/Ruby.framework/Versions/Current
cd $(brew --prefix) && git fetch origin && git reset --hard origin/master
module Perpetrator def crime end end class Fixnum include Perpetrator end p 2.method(:crime)
require require m = 2.days.method(:ago) m.__file__ m.__line__
class A; def hello; puts "hello"; end end class B < A; end b = B.new b.method(:hello).owner => A
ActiveRecord::Base.method(:validates).source_location
[project_path/vendor/ruby/version_number/gems/activerecord-number/lib/active_record/associations.rb", line_number_of_where_method_is]
[project_path/vendor/ruby/version_number/gems/activerecord-number/lib/active_record/validations.rb", line_number_of_where_method_is]
set_trace_func proc{ |event, file, line, id, binding, classname| printf "%8s %s:%-2d %10s %8s\n", event, file, line, id, classname } set_trace_func nil
class String def String.method_added(name) if (name==:foo) puts "defining puts caller.join("\n\t") end end end
before_action :set_event, only: [:show, :update, :destroy, :edit]
require "rubygems" require "json" string = parsed = JSON.parse(string) p parsed["desc"]["someKey"] p parsed["main_item"]["stats"]["a"] file = open("shops.json") json = file.read parsed = JSON.parse(json) parsed["shop"].each do |shop| p shop["id"] end
require CONFIG_FILE = ENV[ configs = YAML.load_file(" puts configs[
add_column :items, :price, :decimal, :precision => 8, :scale => 2
class Product > ActiveRecord::Base composed_of :price, :class_name => :mapping => %w(price cents), :converter => Proc.new { |value| Money.new(value) }
add_column :products, :price, :decimal, :precision => 8, :scale => 2
def validate errors.add(:price, "should be at least 0.01") if price.nil? || price < 0.01 end
$ rails g migration add_price_in_cents_to_products price_in_cents:integer def price_in_dollars price_in_cents.to_d/100 if price_in_cents end def price_in_dollars=(dollars) self.price_in_cents = dollars.to_d*100 if dollars.present? end
<%= number_to_currency(1234567890.50) %> OUT PUT => $1,234,567,890.50
add_column :items, :price, :decimal, precision: 8, scale: 2
bin/rails g migration AddPriceToItems price:decimal{8-2}
ActiveSupport::NumberHelper.number_to_currency(2_500_000.61, unit:
module ApplicationHelper def format_currency(amount) number_to_currency(amount, unit: end end
class Item < ActiveRecord::Base def format_price number_to_currency(price, unit: end end
def refund_information amount_formatted = ActionController::Base.helpers.number_to_currency(@refund.amount, negative_format: { amount_formatted: amount_formatted, } end
array.length.times do |i| end array.each array.each_index for i in array
array = [1, 2, 3, 4, 5, 6] array.each { |x| puts x }
array = ["A", "B", "C"] array.each_with_index {|val, index| puts "
(*1..10).each{|i| puts "i= (*1..10).reverse.each{|i| puts "i= # (1..10).step(1){|i| puts "i= (1..10).step(-1){|i| puts "i= # (1..10).each{|i| puts "i= (10..1).each{|i| puts "i=
class Range def each_reverse(&block) self.to_a.reverse.each(&block) end end
class Hash def each_pairwise self.each { | x, y | yield [x, y] } end end class Array def each_pairwise self.each_with_index { | x, y | yield [y, x] } end end ["a","b","c"].each_pairwise { |x,y| puts " } {"a" => "Aardvark","b" => "Bogle","c" => "Catastrophe"}.each_pairwise { |x,y| puts " }
[1,2,[1,2,3]].flatten => [1,2,1,2,3] [1,2,[1,2,3]].flatten(0) => [1,2,[1,2,3]]
a = [ "a", "b", "c" ] a.each_index {|x| print x, " -- " }
class Truck def self.default_make "mac" end def initialize Truck.default_make end end
class Foo def self.some_class_method puts self end def some_instance_method self.class.some_class_method end end print "Class method: " Foo.some_class_method print "Instance method: " Foo.new.some_instance_method
class Truck def self.default_make "mac" end def make1 self.class.default_make end def make2 Truck.default_make end end class BigTruck < Truck def self.default_make "bigmac" end end ruby-1.9.3-p0 :021 > b=BigTruck.new => ruby-1.9.3-p0 :022 > b.make1 => "bigmac" ruby-1.9.3-p0 :023 > b.make2 => "mac"
class Truck attr_accessor :make, :year def self.default_make "Toyota" end def make @make || self.class.default_make end def initialize(make=nil, year=nil) self.year, self.make = year, make end end
t = Truck.new("Honda", 2000) t.make t.year t = Truck.new t.make t.year
class Truck def default_make "mac" end def initialize puts default_make end end myTruck = Truck.new()
class Truck attr_accessor :make def default_make "mac" end def self.buildTrucks(make, count) truckArray = [] (1..count).each do truckArray << Truck.new(make) end return truckArray end def initialize(make = nil) if( make == nil ) @make = default_make() else @make = make end end end myTrucks = Truck.buildTrucks("Yotota", 4) myTrucks.each do |truck| puts truck.make end
[20] pry(main)> class Foo [20] pry(main)* def self.bar [20] pry(main)* "foo bar" [20] pry(main)* end [20] pry(main)* delegate :bar, to: [20] pry(main)* end => [:bar] [21] pry(main)> Foo.new.bar => "foo bar" [22] pry(main)> Foo.bar => "foo bar"
[1] pry(main)> class Foo [1] pry(main)* module AvailableToClassAndInstance [1] pry(main)* def bar [1] pry(main)* "foo bar" [1] pry(main)* end [1] pry(main)* end [1] pry(main)* include AvailableToClassAndInstance [1] pry(main)* extend AvailableToClassAndInstance [1] pry(main)* end => Foo [2] pry(main)> Foo.new.bar => "foo bar" [3] pry(main)> Foo.bar => "foo bar"
class Truck def self.default_make "mac" end attr_reader :make private define_method :default_make, &method(:default_make) def initialize(make = default_make) @make = make end end puts Truck.new.make
require class Object def __; eval alias :_class :__ def caller_binding cc = nil; count = 0 set_trace_func lambda { |event, file, lineno, id, binding, klass| if count == 2 set_trace_func nil cc.call binding elsif event == "return" count += 1 end } return callcc { |cont| cc = cont } end end def Tiger def roar __.roar _class.roar end def self.roar end end
class Truck def default_make end def initialize super self.default_make end end
class Regexp def to_proc ->(str) { self =~ str ; $1 } end end %w(station nation information).map &/(.*)ion/ => ["stat", "nat", "informat"]
class Integer def to_proc ->(arr) { arr[self] } end end arr = [[*3..7],[*14..27],[*?a..?z]] arr.map &4 => [7, 18, "e"]
items.map! { |x| process_x url } items.select! { |x| !x.nil? }
new_items = [] items.each do |x| x = process_x x new_items.append(x) unless x.nil? end items = new_items
[1, 2, 3].reduce([]) { |memo, i| if i % 2 == 0 memo << i end memo }
new_items = items.each_with_object([]) do |x, memo| ret = process_x(x) memo << ret unless ret.nil? end
items.each_with_object([]) {|x, obj| (process x).tap {|r| obj << r unless r.nil?}}
items = [1,2,3,4,5] def process x rand(10) > 5 ? nil : x end items.each_with_object([]) {|x, obj| (process x).tap {|r| obj << r unless r.nil?}}
h = items.group_by {|x| (process x).nil? ? "Bad" : "Good"} h["Good"]
> a ||= nil => nil > a ||= 0; => 0 > a ||= 2; => 0 > foo = false; => false > foo ||= true; => true > foo ||= false; => true
a || a = b a ? a : a = b if a then a else a = b end
class User > ActiveRecord::Base def current_user @current_user ||= User.find_by_id(session[:user_id]) end end
def current_user @current_user ||= User.find_by_id(session[:user_id]) end helper_method :current_user
irb(main):001:0> a = 1 => 1 irb(main):002:0> a ||= 2 => 1
irb(main):003:0> a = nil => nil irb(main):004:0> a ||= 2 => 2
1000000.times do a ||= 1 a ||= 1 a ||= 1 a ||= 1 a ||= 1 a ||= 1 a ||= 1 a ||= 1 a ||= 1 a ||= 1 end
1000000.times do a = 1 unless a a = 1 unless a a = 1 unless a a = 1 unless a a = 1 unless a a = 1 unless a a = 1 unless a a = 1 unless a a = 1 unless a a = 1 unless a end
1000000.times do a = 1 if a.nil? a = 1 if a.nil? a = 1 if a.nil? a = 1 if a.nil? a = 1 if a.nil? a = 1 if a.nil? a = 1 if a.nil? a = 1 if a.nil? a = 1 if a.nil? a = 1 if a.nil? end
{ "errorCode": 0, "errorMessage": "", "results": { "http: { "hash": "e5TEd", "shortKeywordUrl": "", "shortUrl": "http: "userHash": "1a0p8G" } }, "statusCode": "OK" }
parsed_json = ActiveSupport::JSON.decode(your_json_string)
parsed_json["results"].each do |longUrl, convertedUrl| site = Site.find_by_long_url(longUrl) site.short_url = convertedUrl["shortUrl"] site.save end
hash_of_values = { array_of_values = [hash_of_values] JSON[hash_of_values] JSON[array_of_values] string_to_parse = array_of_values.to_json JSON[string_to_parse]
require h = { json = Oj.dump(h) h2 = Oj.load(json) puts "Same?
json = "{\"errorCode\":0,\"errorMessage\":\"\",\"results\":{\"http: hash = JSON.parse(json) results = hash[:results]
source_url = "http: results.fetch(source_url)[:shortUrl] => "http:
results.fetch(results.keys[0])[:shortUrl] => "http:
results = json[:results].stringify_keys results.fetch(results.keys[0])["shortUrl"] => "http:
require json_data = "errorCode": 0, "errorMessage": "", "results": { "http: { "hash": "e5TEd", "shortKeywordUrl": "", "shortUrl": "http: "userHash": "1a0p8G" } }, "statusCode": "OK" }' final_data = JSON.parse(json_data) puts final_data["results"]["http:
def details_to_json { :id => self.id, :credit_period_type => self.credit_period_type, :credit_payment_period => self.credit_payment_period, }.to_json end
sudo gem update --system Password: Updating rubygems-update Fetching: rubygems-update-2.6.8.gem (100%) Successfully installed rubygems-update-2.6.8 Parsing documentation for rubygems-update-2.6.8 Installing ri documentation for rubygems-update-2.6.8 Installing darkfish documentation for rubygems-update-2.6.8 Installing RubyGems 2.6.8 RubyGems 2.6.8 installed Parsing documentation for rubygems-2.6.8 Installing ri documentation for rubygems-2.6.8 ------------------------------------------------------------------------------ RubyGems installed the following executables: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/gem Ruby Interactive (ri) documentation was installed. ri is kind of like man pages for ruby libraries. You may access it like this: ri Classname ri Classname.class_method ri Classname
Dir.entries("your/folder").select {|f| !File.directory? f}
# Dir.entries( # home = "/home/test" Dir.entries( home ).select{ |f| File.file? File.join( home, f ) }
files = Dir["/work/myfolder/**/*.txt"] files.each do |file_name| if !File.directory? file_name puts file_name File.open(file_name) do |file| file.each_line do |line| if line =~ /banco1/ puts "Found: end end end end end
files = Dir.entries("your/folder").reject {|f| File.directory?(f) || f[0].include?(
Dir.entries(dir).select { |f| File.file?(File.join(dir, f)) }
user system total real Dir[*]: (34900 files stepped over 100 iterations) 0.110729 0.139060 0.249789 ( 0.249961) Dir.glob(*): (34900 files stepped over 100 iterations) 0.112104 0.142498 0.254602 ( 0.254902) Dir.entries(): (35600 files stepped over 100 iterations) 0.142441 0.149306 0.291747 ( 0.291998) Dir[**/*]: (2211600 files stepped over 100 iterations) 9.399860 15.802976 25.202836 ( 25.250166) Dir.glob(**/*): (2211600 files stepped over 100 iterations) 9.335318 15.657782 24.993100 ( 25.006243) Dir.entries() recursive walk: (2705500 files stepped over 100 iterations) 14.653018 18.602017 33.255035 ( 33.268056) Dir.glob(**/*, File::FNM_DOTMATCH): (2705500 files stepped over 100 iterations) 12.178823 19.577409 31.756232 ( 31.767093)
require base_dir = "/path/to/dir/" n = 100 Benchmark.bm do |x| x.report("Dir[*]:") do i = 0 n.times do i = i + Dir[" end puts " ( end x.report("Dir.glob(*):") do i = 0 n.times do i = i + Dir.glob(" end puts " ( end x.report("Dir.entries():") do i = 0 n.times do i = i + Dir.entries(base_dir).select {|f| !File.directory? File.join(base_dir, f)}.length end puts " ( end x.report("Dir[**/*]:") do i = 0 n.times do i = i + Dir[" end puts " ( end x.report("Dir.glob(**/*):") do i = 0 n.times do i = i + Dir.glob(" end puts " ( end x.report("Dir.entries() recursive walk:") do i = 0 n.times do def walk_dir(dir, result) Dir.entries(dir).each do |file| next if file == ".." || file == "." path = File.join(dir, file) if Dir.exist?(path) walk_dir(path, result) else result << file end end end result = Array.new walk_dir(base_dir, result) i = i + result.length end puts " ( end x.report("Dir.glob(**/*, File::FNM_DOTMATCH):") do i = 0 n.times do i = i + Dir.glob(" end puts " ( end end
def get_path_content(dir) queue = Queue.new result = [] queue << dir until queue.empty? current = queue.pop Dir.entries(current).each { |file| full_name = File.join(current, file) if not (File.directory? full_name) result << full_name elsif file != queue << full_name end } end result end
car = {:make => "bmw", :year => "2003"} car.to_json
car = {:make => "bmw", :year => "2003"} car.to_json require car.to_json
irb(main):419:0> [2,4,6,3,8,6].delete_if{|i|i==6} => [2, 4, 3, 8] irb(main):420:0>
require class Array def rodrigo_except(*values) self - values end def niels_except value value = value.kind_of?(Array) ? value : [value] self - value end end ARY = [2,4,6,3,8] compare do soziev { a = ARY.dup; a.delete(3); a } steve { a = ARY.dup; a -= [3]; a } barlop { a = ARY.dup; a.delete_if{ |i| i == 3 }; a } rodrigo { a = ARY.dup; a.rodrigo_except(3); } niels { a = ARY.dup; a.niels_except(3); } end
class Array def rodrigo_except(*values) self - values end def niels_except value value = value.kind_of?(Array) ? value : [value] self - value end end ARY = [2,4,6,3,8] * 1000 compare do soziev { a = ARY.dup; a.delete(3); a } steve { a = ARY.dup; a -= [3]; a } barlop { a = ARY.dup; a.delete_if{ |i| i == 3 }; a } rodrigo { a = ARY.dup; a.rodrigo_except(3); } niels { a = ARY.dup; a.niels_except(3); } end
class Array def rodrigo_except(*values) self - values end def niels_except value value = value.kind_of?(Array) ? value : [value] self - value end end ARY = [2,4,6,3,8] * 100_000 compare do soziev { a = ARY.dup; a.delete(3); a } steve { a = ARY.dup; a -= [3]; a } barlop { a = ARY.dup; a.delete_if{ |i| i == 3 }; a } rodrigo { a = ARY.dup; a.rodrigo_except(3); } niels { a = ARY.dup; a.niels_except(3); } end
class Array def except(*values) self - values end end
class Array def except value value = value.kind_of(Array) ? value : [value] self - value end end
arr = [2, 4, 6, 3, 8, 10, 3, 12] arr.delete_at arr.index 3
a = [2, 4, 6, 3, 8] n = a.index 3 a.take(n)+a.drop(n+1)
puts [1, 2, 3].map do |e| next 42 if e == 2 e end.inject(&:+)
def my_fun [1, 2, 3].map do |e| return "Hello." if e == 2 e end end
> cat input.txt | myprog.rb > myprog.rb < input.txt > myprog.rb arg1 arg2 arg3 ...
STDIN.read.split("\n").each do |a| puts a end ARGV.each do |b| puts b end
ARGF.each_with_index do |line, idx| print ARGF.filename, ":", idx, ";", line end ARGF.each do |line| puts line if line =~ /login/ end
Header = DATA.read ARGF.each_line do |e| puts Header if ARGF.pos - e.length == 0 puts e end __END__
until ARGV.empty? do puts "From arguments: end while a = gets puts "From stdin: end
$ cat input.txt | ./myprog.rb From stdin: line 1 From stdin: line 2 $ ./myprog.rb arg1 arg2 arg3 From arguments: arg1 From arguments: arg2 From arguments: arg3 hi! From stdin: hi!
if $stdin.tty? ARGV.each do |file| puts "do something with this file: end else $stdin.each_line do |line| puts "do something with this line: end end
> cat input.txt | ./myprog.rb do something with this line: this do something with this line: is do something with this line: a do something with this line: test > ./myprog.rb < input.txt do something with this line: this do something with this line: is do something with this line: a do something with this line: test > ./myprog.rb arg1 arg2 arg3 do something with this file: arg1 do something with this file: arg2 do something with this file: arg3
while STDIN.gets puts $_ end while ARGF.gets puts $_ end
File.open(ARGV[0], ARGV.clear ARGF.each do |line| puts line file.write(line) end end
all_lines = "" ARGV.each do |line| all_lines << line + "\n" end puts all_lines
$ cat tstarg.rb while a=(ARGV.shift or (!STDIN.tty? and STDIN.gets) ) puts a end
$ cat numbers 1 2 3 4 5 $ ./tstarg.rb a b c < numbers a b c 1 2 3 4 5
require stdin, stdout, stderr, wait_thr = Open3.popen3( stdout.gets(nil) stdout.close stderr.gets(nil) stderr.close exit_code = wait_thr.value
>> s = system 10:56 up 3 days, 23:10, 2 users, load averages: 0.17 0.17 0.14 => true >> s.class => TrueClass >> $?.class => Process::Status
>> result = %x[uptime] => "13:16 up 4 days, 1:30, 2 users, load averages: 0.39 0.29 0.23\n" >> p result "13:16 up 4 days, 1:30, 2 users, load averages: 0.39 0.29 0.23\n" >> result.class => String
untrusted = "; date; echo" out = `echo untrusted = out = `echo " untrusted = " out = `echo
out, err, st = Open3.capture3("echo out, err, st = Open3.capture3( out_err, st = Open3.capture2e( out, st = Open3.capture2( p st.exitstatus
# # def syscall(*cmd) begin stdout, stderr, status = Open3.capture3(*cmd) status.success? && stdout.slice!(0..-(1 + $/.size)) rescue end end
p system( p syscall( p system( p syscall( p system( p syscall(
nil nil false false /usr/bin/which <— stdout from system( true <- p system( "/usr/bin/which" <- p syscall(
out = IO.popen("xxd -p", "r+") { |io| io.print "xyz" io.close_write io.read.chomp } p out
require output = Open3.popen3("ls") { |stdin, stdout, stderr, wait_thr| stdout.read }
require def capture_stdout stdout = $stdout.dup Tempfile.open $stdout.reopen temp.path, yield if block_given? $stdout.reopen stdout temp.read end end
captured_content = capture_stdout do system end puts captured_content
puts `date` puts $? Mon Mar 7 19:01:15 PST 2016 pid 13093 exit 0
["bucket1:file1", "bucket2:file1", "bucket3:file2", "bucket4:file2"]
a = [1, 2, 2, 3] counts = Hash.new(0) a.each { |v| counts[v] += 1 } p counts.select { |v, count| count == 1 }.keys
a = [3,2,3,2,3,5,6,7].sort! result = a.reject.with_index do |ele,index| res = (a[index+1] ^ ele) res == 0 end print result
postal_code[:minnesota] = "MN" postal_code[:new_york] = "NY"
module Foo BAR = 1 BAZ = 2 BIZ = 4 end flags = Foo::BAR | Foo::BAZ
class Enum private def self.enum_attr(name, num) name = name.to_s define_method(name + @attrs & num != 0 end define_method(name + if set @attrs |= num else @attrs &= ~num end end end public def initialize(attrs = 0) @attrs = attrs end def to_i @attrs end end
class FileAttributes < Enum enum_attr :readonly, 0x0001 enum_attr :hidden, 0x0002 enum_attr :system, 0x0004 enum_attr :directory, 0x0010 enum_attr :archive, 0x0020 enum_attr :in_rom, 0x0040 enum_attr :normal, 0x0080 enum_attr :temporary, 0x0100 enum_attr :sparse, 0x0200 enum_attr :reparse_point, 0x0400 enum_attr :compressed, 0x0800 enum_attr :rom_module, 0x2000 end
>> example = FileAttributes.new(3) => >> example.readonly? => true >> example.hidden? => true >> example.system? => false >> example.system = true => true >> example.system? => true >> example.to_i => 7
class Conversation < ActiveRecord::Base enum status: [ :active, :archived ] end conversation.active! conversation.active? conversation.status conversation.archived! conversation.archived? conversation.status conversation.status = "archived" conversation.status = nil conversation.status.nil? conversation.status
module Kernel def enum(values) Module.new do |mod| values.each_with_index{ |v,i| mod.const_set(v.to_s.capitalize, 2**i) } def mod.inspect " end end end end States = enum %w(Draft Published Trashed) => States {Draft, Published, Trashed} States::Draft => 1 States::Published => 2 States::Trashed => 4 States::Draft | States::Trashed => 3
class Gender include Enum Gender.define :MALE, "male" Gender.define :FEMALE, "female" end Gender.all Gender::MALE
COLORS = Enum.new(:COLORS, :red => 1, :green => 2, :blue => 3) => COLORS(:red => 1, :green => 2, :blue => 3) COLORS.red == 1 && COLORS.red == :red => true class Car < ActiveRecord::Base attr_enum :color, :COLORS, :red => 1, :black => 2 end car = Car.new car.color = :red / "red" / 1 / "1" car.color => Car::COLORS.red car.color.black? => false Car.red.to_sql => "SELECT `cars`.* FROM `cars` WHERE `cars`.`color` = 1" Car.last.red? => true
my_hash = Hash.new do |hash, key| raise "You tried to access using end
my_hash = Hash[[[1,2]]] my_hash.default_proc = proc do |hash, key| raise "You tried to access using end
module MyConstants ABC = Class.new DEF = Class.new GHI = Class.new end
>> enum = Set[ => >> enum.member? "b" => true >> enum.member? "d" => false >> enum.add? "b" => nil >> enum.add? "d" =>
module EnumLike def EnumLike.server_role server_Symb=[ :SERVER_CLOUD, :SERVER_DESKTOP, :SERVER_WORKSTATION] server_Enum=Hash.new i=0 server_Symb.each{ |e| server_Enum[e]=i; i +=1} return server_Symb,server_Enum end end
require sSymb, sEnum =EnumLike.server_role() foreignvec[sEnum[:SERVER_WORKSTATION]]=8
module EnumType def self.find_by_id id if id.instance_of? String id = id.to_i end values.each do |type| if id == type.id return type end end nil end def self.values [@ENUM_1, @ENUM_2] end class Enum attr_reader :id, :label def initialize id, label @id = id @label = label end end @ENUM_1 = Enum.new(1, "first") @ENUM_2 = Enum.new(2, "second") end
class Profession def self.pro_enum {:BAKER => 0, :MANAGER => 1, :FIREMAN => 2, :DEV => 3, :VAL => ["BAKER", "MANAGER", "FIREMAN", "DEV"] } end end Profession.pro_enum[:DEV] Profession.pro_enum[:VAL][1]
require class Array def to_enum(base=0) OpenStruct.new(map.with_index(base).to_h) end end class Bar MY_ENUM = OpenStruct.new(ONE: 1, TWO: 2, THREE: 3) MY_ENUM2 = %w[ONE TWO THREE].to_enum def use_enum (value) case value when MY_ENUM.ONE puts "Hello, this is ENUM 1" when MY_ENUM.TWO puts "Hello, this is ENUM 2" when MY_ENUM.THREE puts "Hello, this is ENUM 3" else puts " end end end foo = Bar.new foo.use_enum 1 foo.use_enum 2 foo.use_enum 9
irb(main):016:0> num=[1,2,3,4] irb(main):017:0> alph=[ irb(main):018:0> l_enum=alph.to_enum irb(main):019:0> s_enum=num.to_enum irb(main):020:0> loop do irb(main):021:1* puts " irb(main):022:1> end
module Status BAD = 13 GOOD = 24 def self.to_str(status) for sym in self.constants if self.const_get(sym) == status return sym.to_s end end end end mystatus = Status::GOOD puts Status::to_str(mystatus)
module Enum def get_value(str) const_get(str) end def get_name(sym) sym.to_s.upcase end end class Fruits include Enum APPLE = "Delicious" MANGO = "Sweet" end Fruits.get_value( Fruits.get_value( Fruits.get_name(:apple) Fruits.get_name(:mango)
class Enum def self.new(values = nil) enum = Class.new do unless values def self.const_missing(name) const_set(name, new(name)) end end def initialize(name) @enum_name = name end def to_s " end end if values enum.instance_eval do values.each { |e| const_set(e, enum.new(e)) } end end enum end end Genre = Enum.new %w(Gothic Metal) Architecture = Enum.new Genre::Gothic == Genre::Gothic Genre::Gothic != Architecture::Gothic
p 1.instance_of? Fixnum p "1".instance_of? String p [1,2].instance_of? Array
(jalcazar@mac ~)$ ps -M 69877 USER PID TT %CPU STAT PRI STIME UTIME COMMAND jalcazar 69877 s002 0.0 S 31T 0:00.01 0:00.04 /Users/jalcazar/.rvm/rubies/ruby-2.1.0/bin/ruby threads.rb 69877 0.0 S 31T 0:00.01 0:00.00 69877 33.4 S 31T 0:00.01 0:08.73 69877 43.1 S 31T 0:00.01 0:08.73 69877 22.8 R 31T 0:00.01 0:08.65
(jalcazar@mac ~)$ ps -M 72286 USER PID TT %CPU STAT PRI STIME UTIME COMMAND jalcazar 72286 s002 0.0 S 31T 0:00.01 0:00.01 /Library/Java/JavaVirtualMachines/jdk1.7.0_25.jdk/Contents/Home/bin/java -Djdk.home= -Djruby.home=/Users/jalcazar/.rvm/rubies/jruby-1.7.10 -Djruby.script=jruby -Djruby.shell=/bin/sh -Djffi.boot.library.path=/Users/jalcazar/.rvm/rubies/jruby-1.7.10/lib/jni:/Users/jalcazar/.rvm/rubies/jruby-1.7.10/lib/jni/Darwin -Xss2048k -Dsun.java.command=org.jruby.Main -cp -Xbootclasspath/a:/Users/jalcazar/.rvm/rubies/jruby-1.7.10/lib/jruby.jar -Xmx1924M -XX:PermSize=992m -Dfile.encoding=UTF-8 org/jruby/Main threads.rb 72286 0.0 S 31T 0:00.00 0:00.00 72286 0.0 S 33T 0:00.00 0:00.00 72286 0.0 S 31T 0:00.09 0:02.34 72286 7.9 S 31T 0:00.15 0:04.63 72286 0.0 S 31T 0:00.00 0:00.00 72286 0.0 S 31T 0:00.00 0:00.00 72286 0.0 S 31T 0:00.00 0:00.00 72286 0.0 S 31T 0:00.04 0:01.68 72286 0.0 S 31T 0:00.03 0:01.54 72286 0.0 S 31T 0:00.00 0:00.00 72286 0.0 S 31T 0:00.01 0:00.01 72286 0.0 S 31T 0:00.00 0:00.01 72286 0.0 S 31T 0:00.00 0:00.03 72286 74.2 R 31T 0:09.21 0:37.73 72286 72.4 R 31T 0:09.24 0:37.71 72286 74.7 R 31T 0:09.24 0:37.80
(jalcazar@mac ~)$ ps -M 38293 USER PID TT %CPU STAT PRI STIME UTIME COMMAND jalcazar 38293 s002 0.0 R 0T 0:00.02 0:00.10 /Users/jalcazar/.rvm/rubies/macruby-0.12/usr/bin/macruby threads.rb 38293 0.0 S 33T 0:00.00 0:00.00 38293 100.0 R 31T 0:00.04 0:21.92 38293 100.0 R 31T 0:00.04 0:21.95 38293 100.0 R 31T 0:00.04 0:21.99
(jalcazar@mac ~)$ ps -M 70032 USER PID TT %CPU STAT PRI STIME UTIME COMMAND jalcazar 70032 s002 100.0 R 31T 0:00.08 0:26.62 /Users/jalcazar/.rvm/rubies/ruby-1.8.7-p374/bin/ruby threads.rb
def eratosthenes(n) nums = [nil, nil, *2..n] (2..Math.sqrt(n)).each do |i| (i**2..n).step(i){|m| nums[m] = nil} if nums[i] end nums.compact end MAX_PRIME=10000000 THREADS=8 threads = [] 1.upto(THREADS) do |num| puts "Starting thread threads[num]=Thread.new { eratosthenes MAX_PRIME } end 1.upto(THREADS) do |num| threads[num].join end
foo = :foo bar = nil a = foo and bar a a = foo && bar a a = (foo and bar) a (a = foo) && bar a
if some_condition && some_other_condition do_something end document.saved? or document.save!
> a = false || true => true > a => true > a = false or true => true > a => false
> a = true && false => false > a => false > a = true and false => false > a => true
> !puts(1) || !puts(2) && !puts(3) 1 => true > !puts(1) or !puts(2) and !puts(3) 1 3 => true > !puts(1) or (!puts(2) and !puts(3)) 1 => true
def happy?() true; end def know_it?() true; end todo = happy? && know_it? ? "Clap your hands" : "Do Nothing" todo todo = happy? and know_it? ? "Clap your hands" : "Do Nothing" todo
SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed
OpenSSL::SSL::SSLError (SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed): app/controllers/users_controller.rb:37:in `update'
sudo port install curl-ca-bundle export SSL_CERT_FILE=/opt/local/share/curl/curl-ca-bundle.crt
gem sources -r https: gem sources -a http: gem update --system gem sources -r http: gem sources -a https: gem install [NAME_OF_GEM]
rvm pkg install openssl rvm reinstall 1.9.2 --with-openssl-dir=$rvm_path/usr
$ brew install curl-ca-bundle Error: No available formula for curl-ca-bundle Searching formulae... Searching taps...
$ cd /usr/local/etc/openssl/certs/ $ sudo curl -O http:
export SSL_CERT_FILE=/usr/local/etc/openssl/certs/cacert.pem
require OpenSSL::SSL::VERIFY_PEER = OpenSSL::SSL::VERIFY_NONE
brew install curl-ca-bundle brew list curl-ca-bundle cp /usr/local/Cellar/curl-ca-bundle/1.87/share/ca-bundle.crt /usr/local/etc/openssl/cert.pem
rvm remove 1.9.3 brew install openssl rvm install 1.9.3 --with-openssl-dir=`brew --prefix openssl`
brew update brew remove openssl brew install openssl
OpenSSL::SSL::VERIFY_PEER = OpenSSL::SSL::VERIFY_NONE
Rails.application.config.middleware.use OmniAuth::Builder do provider :google_oauth2, APP_CONFIG[ :scope => :ssl => {:ca_path => "/share/curl/curl-ca-bundle.crt"} end
ruby -ropenssl -e "p OpenSSL::X509::DEFAULT_CERT_FILE" (should be /usr/local/etc/openssl) cd /usr/local/etc/openssl wget http: ln -s cacert.pem 77ee3751.0 (77ee3751.0 is my symbolic link, should depend on the openssl version)
group :development, :test do gem "autotest" gem "rspec-rails", "~> 2.4" gem "cucumber-rails", ">=0.3.2" gem "webrat", ">=0.7.2" gem gem end
require describe GroupsController do include Devise::TestHelpers describe "GET yourgroups" do it "should be successful and return 3 items" do Rails.logger.info get :yourgroups, :format => :json response.should be_success body = JSON.parse(response.body) body.should have(3).items end end end
rspec ./spec/controllers/groups_controller_spec.rb:42
bundle exec rspec ./spec/controllers/groups_controller_spec.rb:42
rake spec SPEC=path/to/spec.rb \ SPEC_OPTS="-e \"should be successful and return 3 items\""
spec path/to/my_spec.rb -e "should be the correct answer"
RSpec.configure do |config| config.filter_run :focus => true config.run_all_when_everything_filtered = true end
rspec spec rspec spec/models rspec spec/models/a_model_spec.rb rspec spec/models/a_model_spec.rb:nn rspec -e"text from a test" rspec spec --tag focus rspec spec --tag focus:special rspec spec --tag focus ~skip
RSpec.configure do |config| config.filter_run :focus => true config.run_all_when_everything_filtered = true end describe "something" do it "does something", :focus => true do end end
bundle exec rspec spec/controllers/users_controller_spec.rb:5
bundle exec rspec spec/controllers/groups_controller_spec.rb
rspec/spec/features/controller/spec_file_name.rb rspec/spec/features/controller_name.rb
VALUE rb_f_require(VALUE obj, VALUE fname) { return rb_require_safe(fname, rb_safe_level()); }
VALUE rb_f_require_relative(VALUE obj, VALUE fname) { VALUE base = rb_current_realfilepath(); if (NIL_P(base)) { rb_loaderror("cannot infer basepath"); } base = rb_file_dirname(base); return rb_require_safe(rb_file_absolute_path(fname, base), rb_safe_level()); }
rb_file_absolute_path =~ File.expand_path rb_file_dirname1 =~ File.dirname rb_current_realfilepath =~ __FILE__
sudo gem install --http-proxy <host address>:<port> json
Building native extensions. This could take a while... ERROR: Error installing json: ERROR: Failed to build gem native extension. /usr/bin/ruby extconf.rb mkmf.rb can Gem files will remain installed in /usr/lib64/ruby/gems/1.8/gems/json-1.8.1 for inspection. Results logged to /usr/lib64/ruby/gems/1.8/gems/json-1.8.1/ext/json/ext/generator/gem_make.out
sudo apt-get install ruby-dev sudo apt-get install ruby2.0-dev sudo apt-get install ruby2.2-dev sudo apt-get install ruby2.3-dev
sudo apt-get install ruby-dev sudo apt-get install ruby2.0-dev sudo apt-get install ruby2.2-dev sudo apt-get install ruby2.3-dev
$ ls /usr/local/Cellar/openssl/1.0.2a-1/include/openssl/ssl.h /usr/local/Cellar/openssl/1.0.2a-1/include/openssl/ssl.h $ gem install eventmachine -v /Users/pain/.rbenv/versions/2.1.2/bin/ruby -r ./siteconf20150612-56154-1hsjz2n.rb extconf.rb --with-ssl-dir=/usr/local/Cellar/openssl/1.0.2a-1/include checking for rb_trap_immediate in ruby.h,rubysig.h... no checking for rb_thread_blocking_region()... yes checking for ruby/thread.h... yes checking for rb_thread_call_without_gvl() in ruby/thread.h... yes checking for inotify_init() in sys/inotify.h... no checking for __NR_inotify_init in sys/syscall.h... no checking for writev() in sys/uio.h... yes checking for rb_thread_fd_select()... yes checking for rb_fdset_t in ruby/intern.h... yes checking for rb_wait_for_single_fd()... yes checking for rb_enable_interrupt()... no checking for rb_time_new()... yes checking for sys/event.h... yes checking for sys/queue... yes checking for clock_gettime()... no checking for gethrtime()... no creating Makefile make "DESTDIR=" clean make "DESTDIR=" compiling binder.cpp In file included from binder.cpp:20: ./project.h:116:10: fatal error: ^ 1 error generated. make: *** [binder.o] Error 1 make failed, exit code 2
$ gem install eventmachine -- --with-cppflags=-I/usr/local/opt/openssl/include Building native extensions with: This could take a while... Successfully installed eventmachine-1.0.8 1 gem installed
bundle config build.eventmachine --with-cppflags=-I/usr/local/opt/openssl/include
$ bundle config build.eventmachine --with-cppflags=-I$(brew --prefix openssl)/include $ bundle install
gem pristine eventmachine -- --with-cppflags=-I/usr/local/opt/openssl/include
gem install eventmachine -v 1.0.5 -- --with-cppflags=-I$(brew --prefix openssl)/include
cd ~ bundle config build.eventmachine --with-cppflags=-I$(brew --prefix openssl)/include
PKG_CONFIG_PATH="$(brew --prefix openssl)/lib/pkgconfig" gem install eventmachine -v "1.0.8"
gem install eventmachine -v Building native extensions with: This could take a while... Successfully installed eventmachine-1.0.7 Parsing documentation for eventmachine-1.0.7 Installing ri documentation for eventmachine-1.0.7 Done installing documentation for eventmachine after 9 seconds 1 gem installed
echo $PKG_CONFIG_PATH /usr/local/opt/openssl/lib/pkgconfig
gem install eventmachine -v Fetching: eventmachine-1.0.7.gem (100%) Building native extensions with: This could take a while... ERROR: Error installing eventmachine: ERROR: Failed to build gem native extension.
<% question = question.size > 20 ? question.question.slice(0, 20)+"..." : question.question %>
if_this_is_a_true_value ? then_the_result_is_this : else_it_is_this
puts (if 1 then 2 else 3 end) puts 1 ? 2 : 3 x = if 1 then 2 else 3 end puts x
question = if question.size > 20 then question.slice(0, 20) + "..." else question end
puts true ? "true" : "false" => "true" puts false ? "true" : "false" => "false"
<% question = question.size > 20 ? question.question.slice(0, 20)+"..." : question.question %>
<% question = (question.size > 20) ? question.question.slice(0, 20)+"..." : question.question %>
<% question = (question.size > 20) ? question.question.slice(0, 20) + "..." \ : question.question %>
<% question = if (question.size > 20) question.question.slice(0, 20) + "..." else question.question end %>
player_id=1 .... player_id==1? enemy_id=2 : enemy_id=1
if condition == true statement_A else statement_B end
file = File.open("path-to-file.tar.gz") contents = "" file.each {|line| contents << line }
newFile = File.open("test.tar.gz", "w") newFile.write(contents)
file = File.open("path-to-file.tar.gz", "rb") contents = file.read
contents = File.read("e.tgz") newFile = File.open("ee.tgz", "w") newFile.write(contents)
require file_contents = Base64.encode64(tar_file_data)
File.new("name_file.txt", "r").each {|line| puts line}
Dir.glob("*/*.txt") do |my_text_file| puts "working on: end
Dir.glob("**/*.txt") do |my_text_file| puts "working on: end
Dir.foreach("/home/mydir") do |fname| puts fname end
honda = [ toyota = [ ... if include_concept_cars: honda += [ ... case car when *toyota when *honda ... end
CAR_TYPES = { foo_type: [ bar_type: [ } @type_for_name = {} CAR_TYPES.each { |type, names| names.each { |name| @type_for_name[type] = name } } case @type_for_name[car] when :foo_type when :bar_type end
Gem::RemoteFetcher::FetchError: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https: An error occured while installing multi_json (1.3.2), and Bundler cannot continue. Make sure that `gem install multi_json -v
rvm remove 1.9.x (or whatever version of ruby you are using) rvm pkg install openssl rvm install 1.9.2 --with-openssl-dir=$rvm_path/usr
C:\>gem install --local C:\rubygems-update-2.6.7.gem C:\>update_rubygems --no-ri --no-rdoc
Gem::RemoteFetcher::FetchError: SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https: An error occured while installing builder (3.0.0), and Bundler cannot continue. Make sure that `gem install builder -v
Gem::RemoteFetcher::FetchError: SSL_connect returned=1 errno=0 state=unknown state: sslv3 alert handshake failure (https: An error occured while installing activesupport (3.2.3), and Bundler cannot continue. Make sure that `gem install activesupport -v
C:\gem sources *** CURRENT SOURCES *** https: C:\gem install bundler Fetching: bundler-1.13.5.gem (100%) Successfully installed bundler-1.13.5 1 gem installed
C:\>gem install --local C:\rubygems-update-1.8.30.gem C:\>update_rubygems --no-ri --no-rdoc
brew uninstall --force openssl brew install openssl
rvm osx-ssl-certs status all rvm osx-ssl-certs update all
export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
C:\>gem install --local C:\rubygems-update-2.6.7.gem C:\>update_rubygems --no-ri --no-rdoc
C:\>gem uninstall rubygems-update -x Removing update_rubygems Successfully uninstalled rubygems-update-2.6.7
bundle config --global ssl_ca_cert /path/to/file.pem
resources :photos do member do get :preview end end
resources :photos do collection do get :search end end
URL Helper Description ---------------------------------------------------------------------------------------------------------------------------------- member /photos/1/preview preview_photo_path(photo) Acts on a specific resource so required id (preview specific photo) collection /photos/search search_photos_path Acts on collection of resources(display all photos)
security find-certificate -a -p /Library/Keychains/System.keychain > "$cert_file" security find-certificate -a -p /System/Library/Keychains/SystemRootCertificates.keychain >> "$cert_file"
C:\>gem which rubygems C:/Ruby21/lib/ruby/2.1.0/rubygems.rb
sudo gem sources -r https: sudo gem sources -a http:
sudo gem sources -r http: sudo gem sources -a https:
gem sources -r https: gem sources -a http: gem update --system gem sources -r http: gem sources -a https:
Parsing documentation for typhoeus-0.7.0 WARNING: Unable to pull data from state=SSLv3 read server certificate B: certificate verify failed (https:
gem in activesupport --version 5.1.6 ERROR: Could not find a valid gem Unable to download data from https: : certificate verify failed (https:
class T def initialize(i) @i = i end def to_s @i.to_s end end t = T.new 42 puts t => 42 p t =>
array = [lots of objects to be processed] array.size >> 20
array.each do |obj| print "*" obj.some_long_executing_process end >> ******
>> puts => nil >> puts "sss\nsss\n" sss sss => nil >> puts "sss\nsss" sss sss => nil >> puts "a", "b" a b => nil >> puts "a", "b", ["c", "d"] a b c d => nil
>> p => nil >> p "sss\nsss\n" "sss\nsss\n" => "aaa\naaa\n" >> p "a", "b" "a" "b" => ["a", "b"] >> p "a", "b", ["c", "d"] "a" "b" ["c", "d"] => ["a", "b", ["c", "d"]]
1: 2: it "should be awesome" do 3: foo = 3 4: foo.should eq(3) 5: end 6:
rspec path/to/spec/file.rb -e ./scripts/spec path/to/spec/file.rb -e
-l, --line LINE_NUMBER Execute example group or example at given line. (does not work for dynamically generated examples)
rake spec:user rake test:users_c rake spec:user:token rake test:user:token rake test:last rake spec:last
rspec/spec/features/controller/spec_file_name.rb Example: Creating rspec spec/features/todos/create_spec.rb Editing rspec spec/features/todos/edit_spec.rb Deleting rspec spec/features/todos/destroy_spec.rb
rspec/spec/feaures/controller_name Example: rspec/spec/features/todos
it "creates an user", dev: :current do user = create(:user) expect(user.persisted?).to be_truthy end
ERROR: Error installing compass: ERROR: Failed to build gem native extension. ERROR: Error installing compass: ERROR: Failed to build gem native extension. /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb checking for ffi.h... no checking for ffi.h in /usr/local/include,/usr/include/ffi... yes checking for ffi_call() in -lffi... yes checking for ffi_prep_closure()... yes checking for ffi_raw_call()... no checking for rb_thread_blocking_region()... yes checking for rb_thread_call_with_gvl()... yes checking for rb_thread_call_without_gvl()... yes checking for ffi_prep_cif_var()... no creating extconf.h creating Makefile make "DESTDIR=" clean make "DESTDIR=" compiling AbstractMemory.c compiling ArrayType.c compiling Buffer.c compiling Call.c Call.c:303:5: warning: implicit declaration of function rbffi_thread_blocking_region(call_blocking_function, data, (void *) -1, NULL); ^ ./Thread.h:78:39: note: expanded from macro ^ 1 warning generated. compiling ClosurePool.c compiling DataConverter.c DataConverter.c:43:1: warning: control may reach end of non-void function [-Wreturn-type] } ^ 1 warning generated. compiling DynamicLibrary.c compiling ffi.c compiling Function.c Function.c:479:33: warning: incompatible pointer types passing rb_thread_call_with_gvl(callback_with_gvl, &cb); ^~~~~~~~~~~~~~~~~ Function.c:102:46: note: passing argument to parameter extern void *rb_thread_call_with_gvl(void *(*func)(void *), void *data1); ^ Function.c:563:9: warning: implicit declaration of function rb_thread_call_without_gvl(async_cb_wait, &w, async_cb_stop, &w); ^ Function.c:738:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ 3 warnings generated. compiling FunctionInfo.c compiling LastError.c compiling LongDouble.c compiling MappedType.c compiling MemoryPointer.c compiling MethodHandle.c compiling Platform.c compiling Pointer.c compiling Struct.c compiling StructByReference.c compiling StructByValue.c compiling StructLayout.c compiling Thread.c compiling Type.c compiling Types.c compiling Variadic.c linking shared-object ffi_c.bundle clang: error: unknown argument: clang: note: this will be a hard error (cannot be downgraded to a warning) in the future make: *** [ffi_c.bundle] Error 1 make failed, exit code 2 Gem files will remain installed in /Library/Ruby/Gems/2.0.0/gems/ffi-1.9.3 for inspection. Results logged to /Library/Ruby/Gems/2.0.0/extensions/universal-darwin-13/2.0.0/ffi-1.9.3/gem_make.out
$ rvm install ruby-2.2.5 $ rvm use ruby-2.2.5 $ gem install bundler $ bundle install
An error occurred while installing ffi (1.9.14), and Bundler cannot continue.
$ xcode-select -p /Library/Developer/CommandLineTools
make: /usr/local/bin/gmkdir: No such file or directory
Package The following packages were automatically installed and are no longer required: libruby2.2 ruby-chunky-png ruby-sass rubygems-integration Use
SOURCE_NAME = SOURCE_HOST = SOURCE_PORT = 143 SOURCE_SSL = false SOURCE_USER = SOURCE_PASS = DEST_NAME = DEST_HOST = DEST_PORT = 993 DEST_SSL = true DEST_USER = DEST_PASS =
require require options = {} OptionParser.new do |opts| opts.banner = "Usage: example.rb [options]" opts.on( opts.on( opts.on( end.parse! dest_options = YAML.load_file( puts dest_options[
--- dest_name: username@gmail.com dest_host: imap.gmail.com dest_port: 993 dest_ssl: true dest_user: username@gmail.com dest_pass: password
> ruby script.rb val_0 val_1 val_2 puts ARGV[0] puts ARGV[1] puts ARGV[2]
> ruby -s script_with_switches.rb -agreed > So do I!
require doc = <<DOCOPT Usage: Try: DOCOPT begin require "pp" pp Docopt::docopt(doc) rescue Docopt::Exit => e puts e.message end
N = gets; 1.step(N.to_i, 1) { |i| print "hello world\n" }
class Person def initialize( name ) @name = name end def do_with_name yield( @name ) end end
person = Person.new("Oscar") person.do_with_name do |name| puts "Hey, his name is end
reversed_name = "" person.do_with_name do |name| reversed_name = name.reverse end puts reversed_name => "racsO"
days = ["monday", "tuesday", "wednesday", "thursday", "friday"] days.select do | item | item.match /^t/ end => ["tuesday", "thursday"]
days.sort do |x,y| x.size <=> y.size end => ["monday", "friday", "tuesday", "thursday", "wednesday"]
>> a = "Hello" => "Hello" >> 1.times { |a| a = "Goodbye" } => 1 >> a => "Goodbye"
>> a = "Hello" => "Hello" >> 1.times { |a| a = "Goodbye" } => 1 >> a => "Hello"
def foo(x) puts "OK: called as foo( yield("A gift from foo!") if block_given? end foo(10) foo(123) {|y| puts "BLOCK:
def bar(x, &block) puts "OK: called as bar( block.call("A gift from bar!") if block end bar(10) bar(123) {|y| puts "BLOCK:
File.open("readfile.rb", "r") do |infile| while (line = infile.gets) puts " counter = counter + 1 end end
def test yield 5 puts "You are in the method test" yield 100 end test {|i| puts "You are in the block test do |i| puts "You are in the block end
You are in the block 5 You are in the method test You are in the block 100 You are in the block 5 You are in the method test You are in the block 100
respond_to do |format| format.html { render template: "my/view", layout: end
def meditate print "Today we will practice zazen" yield end meditate { print " for 40 minutes." } Output: Today we will practice zazen for 40 minutes.
def meditate puts "Today we will practice zazen." yield if block_given? end meditate Output: Today we will practice zazen.
def add_to_http "http: end puts add_to_http { "www.example.com" } puts add_to_http { "www.victim.com"}
class Fruit attr_accessor :kinds def initialize @kinds = %w(orange apple pear banana) end def each puts 3.times { yield (@kinds.tap {|kinds| puts "selecting from end end f = Fruit.new f.each do |kind| puts end => inside each => selecting from ["orange", "apple", "pear", "banana"] => inside block => selecting from ["orange", "apple", "pear", "banana"] => inside block => selecting from ["orange", "apple", "pear", "banana"] => inside block
class Fruit def initialize @kinds = %w(orange apple) end def kinds yield @kinds.shift yield @kinds.shift end end f = Fruit.new enum = f.to_enum(:kinds) enum.next => "orange" enum.next => "apple"
enum_for(method = :each, *args) → enum Creates a new Enumerator which will enumerate by calling method on obj, passing args if any. str = "xyz" enum = str.enum_for(:each_byte) enum.each { |b| puts b }
str = "I like fruit" enum = str.to_enum enum.next => NoMethodError: undefined method `each
fileObj = File.new($fileName, "r") while (line = fileObj.gets) puts(line) end fileObj.close
File.open("my/file/path", "r") do |f| f.each_line do |line| puts line end end
f = File.open("my/file/path", "r") f.each_line do |line| puts line end f.close
content = File.readlines content.each_with_index{|line, i| puts "
File.open( loop do break if not line = f.gets puts " end end
File.open( loop do break if not buf = f.gets(nil, 80) puts buf.unpack( end end
begin f = File.open while line = f.gets puts line end ensure f.close end
path = File.join(Rails.root, last_100_lines = `tail -n 100
class MyIO def initialize(filename) fd = IO.sysopen(filename) @io = IO.new(fd) @buffer = "" end def each(&block) @buffer << @io.sysread(512) until @buffer.include?($/) line, @buffer = @buffer.split($/, 2) block.call(line) each(&block) rescue EOFError @io.close end end
cities = ["Kathmandu", "Pokhara", "", "Dharan", "Butwal"]
cities = ["Kathmandu", "Pokhara", "Dharan", "Butwal"]
1.9.3p194 :001 > ["", "A", "B", "C", ""].reject(&:empty?) => ["A", "B", "C"]
["Kathmandu", "Pokhara", "", "Dharan", "Butwal"] - ["", nil]
puts ["Kathmandu", "Pokhara", "", "Dharan", "Butwal"] - [""]
cities = ["Kathmandu", "Pokhara", "", "Dharan", "Butwal", nil] cities.delete_if(&:blank?)
>> cities = ["Kathmandu", "Pokhara", "", "Dharan", "Butwal"].reject{ |e| e.empty? } => ["Kathmandu", "Pokhara", "Dharan", "Butwal"]
cities = ["Kathmandu", "Pokhara", " ", nil, "", "Dharan", "Butwal"].reject { |c| c.blank? }
cities = ["Kathmandu", "Pokhara", "", "Dharan", "Butwal"].select &:present?
cities = ["Kathmandu", "Pokhara", "", "Dharan", nil, "Butwal"] cities.select(&:presence) ["Kathmandu", "Pokhara", "Dharan", "Butwal"]
[nil,"some string here","",4,3,2].compact.reject{|r| r.empty? if r.class == String}
cities = ["Kathmandu", "Pokhara", "", "Dharan", "Butwal"].delete_if {|c| c.empty? }
> ["a","b","c","","","f","g"].keep_if{|some| some.present?} => ["a","b","c","f","g"]
cities = ["Kathmandu", "Pokhara", "", "Dharan", "Butwal"] cities.join(
require puts "I am now red".red puts "I am now blue".blue puts "Testing".yellow
class String def colorize(color_code) "\e[ end def red colorize(31) end def green colorize(32) end def yellow colorize(33) end def blue colorize(34) end def pink colorize(35) end def light_blue colorize(36) end end
class String def black; "\e[30m def red; "\e[31m def green; "\e[32m def brown; "\e[33m def blue; "\e[34m def magenta; "\e[35m def cyan; "\e[36m def gray; "\e[37m def bg_black; "\e[40m def bg_red; "\e[41m def bg_green; "\e[42m def bg_brown; "\e[43m def bg_blue; "\e[44m def bg_magenta; "\e[45m def bg_cyan; "\e[46m def bg_gray; "\e[47m def bold; "\e[1m def italic; "\e[3m def underline; "\e[4m def blink; "\e[5m def reverse_color; "\e[7m end
public static final String BLACK_TEXT() { return "\033[30m";} public static final String RED_TEXT() { return "\033[31m";} public static final String GREEN_TEXT() { return "\033[32m";} public static final String BROWN_TEXT() { return "\033[33m";} public static final String BLUE_TEXT() { return "\033[34m";} public static final String MAGENTA_TEXT() { return "\033[35m";} public static final String CYAN_TEXT() { return "\033[36m";} public static final String GRAY_TEXT() { return "\033[37m";} public static final String BLACK_BACK() { return "\033[40m";} public static final String RED_BACK() { return "\033[41m";} public static final String GREEN_BACK() { return "\033[42m";} public static final String BROWN_BACK() { return "\033[43m";} public static final String BLUE_BACK() { return "\033[44m";} public static final String MAGENTA_BACK() { return "\033[45m";} public static final String CYAN_BACK() { return "\033[46m";} public static final String WHITE_BACK() { return "\033[47m";} public static final String RESET_COLORS() { return "\033[0m";} public static final String BOLD_ON() { return "\033[1m";} public static final String BLINK_ON() { return "\033[5m";} public static final String REVERSE_ON() { return "\033[7m";} public static final String BOLD_OFF() { return "\033[22m";} public static final String BLINK_OFF() { return "\033[25m";} public static final String REVERSE_OFF() { return "\033[27m";}
def colortable names = %w(black red green yellow blue pink cyan white default) fgcodes = (30..39).to_a - [38] s = reg = "\e[%d;%dm%s\e[0m" bold = "\e[1;%d;%dm%s\e[0m" puts puts names.zip(fgcodes).each {|name,fg| s = " puts "%7s "%name + " fg,44,s,fg,44,s, fg,45,s,fg,45,s, fg,46,s,fg,46,s, fg,47,s,fg,47,s, fg,49,s,fg,49,s ] } end
require TermInfo.control("bold") puts "Bold text" TermInfo.control("sgr0") puts "Back to normal." puts "And now some " + TermInfo.control_string("setaf", 1) + "red" + TermInfo.control_string("sgr0") + " text."
require class Style def self.style() @@singleton ||= Style.new end colors = %w{black red green yellow blue magenta cyan white} colors.each_with_index do |color, index| define_method(color) { get("setaf", index) } define_method("bg_" + color) { get("setab", index) } end def bold() get("bold") end def under() get("smul") end def dim() get("dim") end def clear() get("sgr0") end def get(*args) begin TermInfo.control_string(*args) rescue TermInfo::TermInfoError "" end end end
puts "Hi! " + `tput setaf 1` + "This is red!" + `tput sgr0`
puts ANSI.color(:red) { "hello there" } puts ANSI.color(:green) + "Everything is green now" + ANSI.no_color
print red, bold, "red bold", reset, "\n" print red(bold("red bold")), "\n" print red { bold { "red bold" } }, "\n"
puts "this is red".foreground(:red) + " and " + "this on yellow bg".background(:yellow) + " and " + "even bright underlined!".underline.bright
def colorize(text, color = "default", bgColor = "default") colors = {"default" => "38","black" => "30","red" => "31","green" => "32","brown" => "33", "blue" => "34", "purple" => "35", "cyan" => "36", "gray" => "37", "dark gray" => "1;30", "light red" => "1;31", "light green" => "1;32", "yellow" => "1;33", "light blue" => "1;34", "light purple" => "1;35", "light cyan" => "1;36", "white" => "1;37"} bgColors = {"default" => "0", "black" => "40", "red" => "41", "green" => "42", "brown" => "43", "blue" => "44", "purple" => "45", "cyan" => "46", "gray" => "47", "dark gray" => "100", "light red" => "101", "light green" => "102", "yellow" => "103", "light blue" => "104", "light purple" => "105", "light cyan" => "106", "white" => "107"} color_code = colors[color] bgColor_code = bgColors[bgColor] return "\033[ end
class Colorizator COLOURS = { default: cyan: light_blue: BG_COLOURS = { default: purple: yellow: FONT_OPTIONS = { bold: def self.colorize(text, colour = :default, bg_colour = :default, **options) colour_code = COLOURS[colour] bg_colour_code = BG_COLOURS[bg_colour] font_options = options.select { |k, v| v && FONT_OPTIONS.key?(k) }.keys font_options = font_options.map { |e| FONT_OPTIONS[e] }.join( return "\e[ end end
Colorizator.colorize "Hello World", :gray, :white Colorizator.colorize "Hello World", :light_blue, bold: true Colorizator.colorize "Hello World", :light_blue, :white, bold: true, underline: true
red = 31 green = 32 blue = 34 def color (color=blue) printf "\033[ yield printf "\033[0m" end color { puts "this is blue" } color(red) { logger.info "and this is red" }
user system total real sort 1.340000 0.010000 1.350000 ( 1.346331) sort reverse 1.300000 0.000000 1.300000 ( 1.310446) sort_by -a[:bar] 0.430000 0.000000 0.430000 ( 0.429606) sort_by a[:bar]*-1 0.420000 0.000000 0.420000 ( 0.414383) sort_by.reverse! 0.400000 0.000000 0.400000 ( 0.401275)
require puts "Running Ruby ary = [] 1000.times { ary << {:bar => rand(1000)} } n = 500 puts "n= Benchmark.bm(20) do |x| x.report("sort") { n.times { ary.dup.sort{ |a,b| b[:bar] <=> a[:bar] } } } x.report("sort reverse") { n.times { ary.dup.sort{ |a,b| a[:bar] <=> b[:bar] }.reverse } } x.report("sort_by -a[:bar]") { n.times { ary.dup.sort_by{ |a| -a[:bar] } } } x.report("sort_by a[:bar]*-1") { n.times { ary.dup.sort_by{ |a| a[:bar]*-1 } } } x.report("sort_by.reverse") { n.times { ary.dup.sort_by{ |a| a[:bar] }.reverse } } x.report("sort_by.reverse!") { n.times { ary.dup.sort_by{ |a| a[:bar] }.reverse! } } end
Running Ruby 2.2.1 n=500 user system total real sort 0.650000 0.000000 0.650000 ( 0.653191) sort reverse 0.650000 0.000000 0.650000 ( 0.648761) sort_by -a[:bar] 0.240000 0.010000 0.250000 ( 0.245193) sort_by a[:bar]*-1 0.240000 0.000000 0.240000 ( 0.240541) sort_by.reverse 0.230000 0.000000 0.230000 ( 0.228571) sort_by.reverse! 0.230000 0.000000 0.230000 ( 0.230040)
descending = -1 a.sort_by { |h| h[:bar] * descending }
irb >> a = [ ?> { :foo => ?> { :foo => ?> { :foo => ?> ] => [{:bar=>2, :foo=>"foo"}, {:bar=>3, :foo=>"foo"}, {:bar=>5, :foo=>"foo"}] >> a.sort {|x,y| y[:bar]<=>x[:bar]} => [{:bar=>5, :foo=>"foo"}, {:bar=>3, :foo=>"foo"}, {:bar=>2, :foo=>"foo"}]
require NUM_RUNS = 1000 arr1 = 3000.times.map { { num: rand(1000) } } arr2 = 3000.times.map { |n| { num: n } }.reverse Benchmark.bm(20) do |x| { puts puts label x.report( NUM_RUNS.times { arr.sort_by { |h| h[:num] }.reverse } } x.report( NUM_RUNS.times { arr.sort_by { |h| -h[:num] } } } end end
$: ruby foo.rb user system total real --------------------------------------------------- randomized sort_by / reverse 1.680000 0.010000 1.690000 ( 1.682051) sort_by - 1.830000 0.000000 1.830000 ( 1.830359) --------------------------------------------------- sorted sort_by / reverse 0.400000 0.000000 0.400000 ( 0.402990) sort_by - 0.500000 0.000000 0.500000 ( 0.499350)
a = [{foo: 1, bar: 1},{foo: 2,bar: 1}] a.sort_by {|h| -h[:bar]} => [{:foo=>1, :bar=>1}, {:foo=>2, :bar=>1}] a.sort_by {|h| h[:bar]}.reverse => [{:foo=>2, :bar=>1}, {:foo=>1, :bar=>1}]
a.sort_by {|h| [-h[:bar],-h[:foo]]} => [{:foo=>2, :bar=>1}, {:foo=>1, :bar=>1}] a.sort_by {|h| [h[:bar],h[:foo]]}.reverse => [{:foo=>2, :bar=>1}, {:foo=>1, :bar=>1}]
require ary = [] 1000.times { ary << {:bar => rand(1000)} } Benchmark.ips do |x| x.report("sort") { ary.sort{ |a,b| b[:bar] <=> a[:bar] } } x.report("sort reverse") { ary.sort{ |a,b| a[:bar] <=> b[:bar] }.reverse } x.report("sort_by -a[:bar]") { ary.sort_by{ |a| -a[:bar] } } x.report("sort_by a[:bar]*-1") { ary.sort_by{ |a| a[:bar]*-1 } } x.report("sort_by.reverse!") { ary.sort_by{ |a| a[:bar] }.reverse } x.compare! end
Warming up -------------------------------------- sort 93.000 i/100ms sort reverse 91.000 i/100ms sort_by -a[:bar] 382.000 i/100ms sort_by a[:bar]*-1 398.000 i/100ms sort_by.reverse! 397.000 i/100ms Calculating ------------------------------------- sort 938.530 (± 1.8%) i/s - 4.743k in 5.055290s sort reverse 901.157 (± 6.1%) i/s - 4.550k in 5.075351s sort_by -a[:bar] 3.814k (± 4.4%) i/s - 19.100k in 5.019260s sort_by a[:bar]*-1 3.732k (± 4.3%) i/s - 18.706k in 5.021720s sort_by.reverse! 3.928k (± 3.6%) i/s - 19.850k in 5.060202s Comparison: sort_by.reverse!: 3927.8 i/s sort_by -a[:bar]: 3813.9 i/s - same-ish: difference falls within error sort_by a[:bar]*-1: 3732.3 i/s - same-ish: difference falls within error sort: 938.5 i/s - 4.19x slower sort reverse: 901.2 i/s - 4.36x slower
class JSONServer def call(env) [200, {"Content-Type" => "application/json"}, [ end end map run JSONServer.new end
$ rackup [2012-02-19 22:39:26] INFO WEBrick 1.3.1 [2012-02-19 22:39:26] INFO ruby 1.9.3 (2012-01-17) [x86_64-darwin11.2.0] [2012-02-19 22:39:26] INFO WEBrick::HTTPServer
module ActionDispatch module Routing class Mapper ... def initialize(app, constraints, request) @app, @constraints, @request = app, constraints, request end def matches?(env) req = @request.new(env) ... return true end def call(env) matches?(env) ? @app.call(env) : [ 404, { end ... end end
class RackLogger def initialize(app) @app = app end def call(env) @start = Time.now @status, @headers, @body = @app.call(env) @duration = ((Time.now - @start).to_f * 1000).round(2) puts " [@status, @headers, @body] end end
class JSONServer def call(env) [200, {"Content-Type" => "application/json"}, [ end end class RackLogger def initialize(app) @app = app end def call(env) @start = Time.now @status, @headers, @body = @app.call(env) @duration = ((Time.now - @start).to_f * 1000).round(2) puts " [@status, @headers, @body] end end use RackLogger map run JSONServer.new end
<!DOCTYPE HTML> <html> <head> <title>The Index</title> </head> <body> <p>Index Page</p> </body> </html>
app = Proc.new do |env| [ 200, { }, ["main\n"] ] end class Middleware def initialize(app) @app = app end def call(env) @status, @headers, @body = @app.call(env) [@status, @headers, @body << "Middleware\n"] end end use(Middleware) run(app)
class MessageApp def call(env) [200, {}, [ end end require_relative run MessageApp.new
class MessageApp def call(env) message = env[ [200, {}, [message]] end end
class MessageSetter def initialize(app) @app = app end def call(env) if env[ env[ else env[ end @app.call(env) end end class MessageApp def call(env) message = env[ [200, {}, [message]] end end require_relative require_relative app = Rack::Builder.new do use MessageSetter run MessageApp.new end run app
require_relative require_relative use MessageSetter run MessageApp.new
class MessageApp def call(env) Rack::Response.new([env[ end end
change_column :users, :admin, :boolean, :default => false
def change change_column_default :table, :column, value end
def up change_column :users, :admin, :boolean, default: false end def down change_column :users, :admin, :boolean, default: nil end
def up change_column :users, :admin, :boolean, default: false end def down change_column :users, :admin, :boolean, default: true end
$ rails generate migration add_columnname_to_tablename columnname:boolean
class AddColumnnameToTablename < ActiveRecord::Migration def change add_column :table_name, :column_name, :boolean, default: false end end
rails generate migration add_column_to_table column:boolean
class AddColumnToTable < ActiveRecord::Migration def change add_column :table, :column, :boolean end end
class Profile < ActiveRecord::Base before_save :set_default_val def set_default_val self.send_updates = end end
config.load_paths << File.join(Rails.root, "app", "classes")
config.eager_load_paths << File.join(Rails.root, "app", "classes")
module Authentication ... end class ApplicationController include Authentication end module Configurable ... end class Model include Indexable end class FooController < ApplicationController include Indexable end class BarController < ApplicationController include Indexable end
/lib/myapp.rb module MyApp VERSION = ... end /lib/myapp/CacheKey.rb /lib/myapp/somecustomlib.rb
/config/initializer/config.rb /config/initializer/core_ext/string.rb /config/initializer/core_ext/array.rb
is_array("something") is_array(["something", "else"])
>> s = "something" => "something" >> s.kind_of?(Array) => false >> s = ["something", "else"] => ["something", "else"] >> s.kind_of?(Array) => true
t = [*something] t = Array(something) def f *x ... end
def f x p Array(x).inspect p [*x].inspect end f 1 f [1] f [1,2]
def f *x p x.flatten.inspect end f 1 f 1,2 f [1] f [1,2] f [1,2],3,4
paths = [paths] unless paths.is_a? Array paths.each { |path| do_something(path) } [*paths].each { |path| do_something(path) } Array(paths).each { |path| do_something(path) }
hsh ={"a" => 1000, "b" => 10, "c" => 200000} Hash[hsh.sort_by{|k,v| v}]
require h = {"a"=>1, "c"=>3, "b"=>2, "d"=>4} many = 100_000 Benchmark.bm do |b| GC.start b.report("hash sort") do many.times do Hash[h.sort] end end GC.start b.report("keys sort") do many.times do nh = {} h.keys.sort.each do |k| nh[k] = h[k] end end end end user system total real hash sort 0.400000 0.000000 0.400000 ( 0.405588) keys sort 0.250000 0.010000 0.260000 ( 0.260303)
h = { "b" => 2, "c" => 1, "a" => 3 } h.sort hash.sort.to_h
@ordered = {} @unordered.keys.sort.each do |key| @ordered[key] = @unordered[key] end
<% @equipments.sort.each do |name, quantity| %> ... <% end %>
rails console >> require "db/migrate/20090408054532_add_foos.rb" >> AddFoos.up
rails_c> q = "delete from schema_migrations where version = rails_c> ActiveRecord::Base.connection.execute(q)
class AddPartNumberToProducts < ActiveRecord::Migration def change add_column :products, :part_number, :string end end
$ rails console >> require "db/migrate/20090408054532_add_part_number_to_products.rb" >> AddPartNumberToProducts.new.migrate(:down)
class CreateUsers < ActiveRecord::Migration def change create_table :users do |t| t.string :name t.string :email t.timestamps null: false end end end end
rake db:migrate:up VERSION=20160920130051 rails db:migrate:up VERSION=20160920130051
[0,1,2,3].drop(2) => [2, 3] [0,1,2,3].drop(3) => [3]
>> x = [4,5,6] => [4, 5, 6] >> x.shift => 4 >> x => [5, 6]
[0, 132, 432, 342, 234][1..-1] => [132, 432, 342, 234]
array.shift(n) => Remove first n elements from array array.shift(1) => Remove first element
@user.update_languages(params[:language][:language1], params[:language][:language2], params[:language][:language3]) lang_errors = @user.errors logger.debug "--------------------LANG_ERRORS----------101-------------" + lang_errors.full_messages.inspect if params[:user] @user.state = params[:user][:state] success = success & @user.save end logger.debug "--------------------LANG_ERRORS-------------102----------" + lang_errors.full_messages.inspect if lang_errors.full_messages.empty?
str = def mutate(str2) puts "str2: str2.replace str2 = puts "str2: end str.object_id mutate(str) str str.object_id
def foo(bar) bar = end baz = foo(baz) puts "Ruby is pass-by-
class A { public: int x; }; void inc(A arg) { arg.x++; printf("in inc: %d\n", arg.x); } void inc(A* arg) { arg->x++; printf("in inc: %d\n", arg->x); } int main() { A a; a.x = 5; inc(a); printf("in main: %d\n", a.x); A* b = new A; b->x = 0; inc(b); printf("in main: %d\n", b->x); return 0; }
void replace(A &arg) { A newA; newA.x = 10; arg = newA; printf("in replace: %d\n", arg.x); } int main() { A a; a.x = 5; replace(a); printf("in main: %d\n", a.x); return 0; }
class A attr_accessor :x end def inc(arg) arg.x += 1 puts arg.x end def replace(arg) arg = A.new arg.x = 3 puts arg.x end a = A.new a.x = 1 puts a.x inc a puts a.x replace a puts a.x puts def inc_var(arg) arg += 1 puts arg end b = 1 puts b inc_var b puts b
def bar(babar) babar.replace("reference") end bar(baz) puts "some people don
1.object_id 2.object_id a = 1 a.object_id b = 2 b.object_id
5.object_id c = 5 c.object_id a = c.object_id 11.object_id a.object_id == 11.object_id a
def foo(arg) p arg p arg.object_id end 11.object_id x = 11 x.object_id foo(x)
def foo(arg) p arg p arg.object_id arg = 12 p arg p arg.object_id end 11.object_id x = 11 x.object_id foo(x) x x.object_id
def my_foo(a_hash) a_hash["test"]="reference" end; hash = {"test"=>"value"} my_foo(hash) puts "Ruby is pass-by-
Two references refer to same object as long as there is no reassignment.
a = "first string" b = a b.upcase! => FIRST STRING a => FIRST STRING b = "second string" a => FIRST STRING hash = {first_sub_hash: {first_key: "first_value"}} first_sub_hash = hash[:first_sub_hash] first_sub_hash[:second_key] = "second_value" hash => {first_sub_hash: {first_key: "first_value", second_key: "second_value"}} def change(first_sub_hash) first_sub_hash[:third_key] = "third_value" end change(first_sub_hash) hash => {first_sub_hash: {first_key: "first_value", second_key: "second_value", third_key: "third_value"}}
names = [ names.map! {|name| name.capitalize } names.each { |name| puts name +
class Numeric def plusone self + 1 end end [1,2,3].map(&:plusone)
[["audi", "black", 2008], ["bmw", "red", 2014]].each do |make, color, year| puts "make: end
{:make => "audi", :color => "black", :year => 2008}.each do |k,v| puts " end
params = {"one" => 1, "two" => 2, "three" => 3} params.each do |k,v| puts " end
h = {a: 1, b: 2, c: 3} h.transform_values { |v| v * 10 }
Class Car attr_accessor :name, :model, :year Def initialize (make, model, year) @make, @model, @year = make, model, year end end list = [] list << Car.new("Honda", "Accord", 2016) list << Car.new("Toyota", "Camry", 2015) list << Car.new("Nissan", "Altima", 2014) p list.map {|p| p.model}
>> "Hello".methods.sort => ["%", "*", "+", "<", "<<", "<=", "<=>", "==", "===", "=~", ">", ">=", "[]", "[]=", "__id__", "__send__", "all?", "any?", "between?", "capitalize", "capitalize!", "casecmp", "center", "chomp", "chomp!", "chop", "chop!", "class", "clone", "collect", "concat", "count", "crypt", "delete", "delete!", "detect", "display", "downcase", "downcase!", "dump", "dup", "each", "each_byte", "each_line", "each_with_index", "empty?", "entries", "eql?", "equal?", "extend", "find", "find_all", "freeze", "frozen?", "grep", "gsub", "gsub!", "hash", "hex", "id", "include?", "index", "inject", "insert", "inspect", "instance_eval", "instance_of?", "instance_variable_defined?", "instance_variable_get", "instance_variable_set", "instance_variables", "intern", "is_a?", "is_binary_data?", "is_complex_yaml?", "kind_of?", "length", "ljust", "lstrip", "lstrip!", "map", "match", "max", "member?", "method", "methods", "min", "next", "next!", "nil?", "object_id", "oct", "partition", "private_methods", "protected_methods", "public_methods", "reject", "replace", "respond_to?", "reverse", "reverse!", "rindex", "rjust", "rstrip", "rstrip!", "scan", "select", "send", "singleton_methods", "size", "slice", "slice!", "sort", "sort_by", "split", "squeeze", "squeeze!", "strip", "strip!", "sub", "sub!", "succ", "succ!", "sum", "swapcase", "swapcase!", "taguri", "taguri=", "taint", "tainted?", "to_a", "to_f", "to_i", "to_s", "to_str", "to_sym", "to_yaml", "to_yaml_properties", "to_yaml_style", "tr", "tr!", "tr_s", "tr_s!", "type", "unpack", "untaint", "upcase", "upcase!", "upto", "zip"]
$foo = {:name => "Clem", :age => 43} puts $foo.to_yaml
obj.instance_variables.map do |var| puts [var, obj.instance_variable_get(var)].join(":") end
obj.instance_variables.map{|var| puts [var, obj.instance_variable_get(var)].join(":")}
require ... puts JSON.pretty_generate(JSON.parse(object.to_json))
require S = SL = S.length T = 10_000 A = 1_000.times.map { |n| " GC.disable Benchmark.bmbm do |x| x.report( x.report( end
Rehearsal ----------------------------------------- chomp 1.540000 0.040000 1.580000 ( 1.587908) range 1.810000 0.200000 2.010000 ( 2.011846) -------------------------------- total: 3.590000sec user system total real chomp 1.550000 0.070000 1.620000 ( 1.610362) range 1.970000 0.170000 2.140000 ( 2.146682)
>name = "Nabucodonosor" => "Nabucodonosor" > 7.times do name.chop! end => 7 > name => "Nabuco"
require "foobarbaz".first(3) "foobarbaz".first(-3) "foobarbaz".last(3) "foobarbaz".last(-3)
class String def chop_multiple(amount) amount.times.inject([self, end end hello, world = "hello world".chop_multiple 5 hello world
Started GET "/" for 127.0.0.1 at 2013-11-06 23:56:36 -0500 PG::ConnectionBad - could not connect to server: Connection refused Is the server running on host "localhost" (::1) and accepting TCP/IP connections on port 5432? could not connect to server: Connection refused Is the server running on host "localhost" (127.0.0.1) and accepting TCP/IP connections on port 5432? could not connect to server: Connection refused Is the server running on host "localhost" (fe80::1) and accepting TCP/IP connections on port 5432? : activerecord (4.0.0) lib/active_record/connection_adapters/postgresql_adapter.rb:825:in `connect' activerecord (4.0.0) lib/active_record/connection_adapters/postgresql_adapter.rb:542:in `initialize' activerecord (4.0.0) lib/active_record/connection_adapters/postgresql_adapter.rb:41:in `postgresql_connection' activerecord (4.0.0) lib/active_record/connection_adapters/abstract/connection_pool.rb:440:in `new_connection' activerecord (4.0.0) lib/active_record/connection_adapters/abstract/connection_pool.rb:450:in `checkout_new_connection' activerecord (4.0.0) lib/active_record/connection_adapters/abstract/connection_pool.rb:421:in `acquire_connection' activerecord (4.0.0) lib/active_record/connection_adapters/abstract/connection_pool.rb:356:in `block in checkout' /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/monitor.rb:211:in `mon_synchronize' activerecord (4.0.0) lib/active_record/connection_adapters/abstract/connection_pool.rb:355:in `checkout' activerecord (4.0.0) lib/active_record/connection_adapters/abstract/connection_pool.rb:265:in `block in connection' /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/monitor.rb:211:in `mon_synchronize' activerecord (4.0.0) lib/active_record/connection_adapters/abstract/connection_pool.rb:264:in `connection' activerecord (4.0.0) lib/active_record/connection_adapters/abstract/connection_pool.rb:546:in `retrieve_connection' activerecord (4.0.0) lib/active_record/connection_handling.rb:79:in `retrieve_connection' activerecord (4.0.0) lib/active_record/connection_handling.rb:53:in `connection' activerecord (4.0.0) lib/active_record/migration.rb:792:in `current_version' activerecord (4.0.0) lib/active_record/migration.rb:800:in `needs_migration?' activerecord (4.0.0) lib/active_record/migration.rb:379:in `check_pending!' activerecord (4.0.0) lib/active_record/migration.rb:366:in `call' actionpack (4.0.0) lib/action_dispatch/middleware/callbacks.rb:29:in `block in call' activesupport (4.0.0) lib/active_support/callbacks.rb:373:in `_run__1613334440513032208__call__callbacks' activesupport (4.0.0) lib/active_support/callbacks.rb:80:in `run_callbacks' actionpack (4.0.0) lib/action_dispatch/middleware/callbacks.rb:27:in `call' actionpack (4.0.0) lib/action_dispatch/middleware/reloader.rb:64:in `call' actionpack (4.0.0) lib/action_dispatch/middleware/remote_ip.rb:76:in `call' better_errors (0.9.0) lib/better_errors/middleware.rb:84:in `protected_app_call' better_errors (0.9.0) lib/better_errors/middleware.rb:79:in `better_errors_call' better_errors (0.9.0) lib/better_errors/middleware.rb:56:in `call' actionpack (4.0.0) lib/action_dispatch/middleware/debug_exceptions.rb:17:in `call' actionpack (4.0.0) lib/action_dispatch/middleware/show_exceptions.rb:30:in `call' railties (4.0.0) lib/rails/rack/logger.rb:38:in `call_app' railties (4.0.0) lib/rails/rack/logger.rb:21:in `block in call' activesupport (4.0.0) lib/active_support/tagged_logging.rb:67:in `block in tagged' activesupport (4.0.0) lib/active_support/tagged_logging.rb:25:in `tagged' activesupport (4.0.0) lib/active_support/tagged_logging.rb:67:in `tagged' railties (4.0.0) lib/rails/rack/logger.rb:21:in `call' quiet_assets (1.0.2) lib/quiet_assets.rb:18:in `call_with_quiet_assets' actionpack (4.0.0) lib/action_dispatch/middleware/request_id.rb:21:in `call' rack (1.5.2) lib/rack/methodoverride.rb:21:in `call' rack (1.5.2) lib/rack/runtime.rb:17:in `call' activesupport (4.0.0) lib/active_support/cache/strategy/local_cache.rb:83:in `call' rack (1.5.2) lib/rack/lock.rb:17:in `call' actionpack (4.0.0) lib/action_dispatch/middleware/static.rb:64:in `call' railties (4.0.0) lib/rails/engine.rb:511:in `call' railties (4.0.0) lib/rails/application.rb:97:in `call' rack (1.5.2) lib/rack/content_length.rb:14:in `call' thin (1.5.1) lib/thin/connection.rb:81:in `block in pre_process' thin (1.5.1) lib/thin/connection.rb:79:in `pre_process' thin (1.5.1) lib/thin/connection.rb:54:in `process' thin (1.5.1) lib/thin/connection.rb:39:in `receive_data' eventmachine (1.0.3) lib/eventmachine.rb:187:in `run' thin (1.5.1) lib/thin/backends/base.rb:63:in `start' thin (1.5.1) lib/thin/server.rb:159:in `start' rack (1.5.2) lib/rack/handler/thin.rb:16:in `run' rack (1.5.2) lib/rack/server.rb:264:in `start' railties (4.0.0) lib/rails/commands/server.rb:84:in `start' railties (4.0.0) lib/rails/commands.rb:78:in `block in <top (required)>' railties (4.0.0) lib/rails/commands.rb:73:in `<top (required)>' bin/rails:4:in `<main>'
development: adapter: postgresql encoding: unicode database: metals-directory_development pool: 5 username: password: template: template0 host: localhost port: 5432 test: &test adapter: postgresql encoding: unicode database: metals-directory_test pool: 5 username: password: template: template0 host: localhost port: 5432 staging: adapter: postgresql encoding: unicode database: metals-directory_production pool: 5 username: password: template: template0 host: localhost production: adapter: postgresql encoding: unicode database: metals-directory_production pool: 5 username: password: template: template0 host: localhost cucumber: <<: *test
launchctl unload homebrew.mxcl.postgresql.plist launchctl load -w homebrew.mxcl.postgresql.plist
launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
CREATE USER yourname WITH PASSWORD CREATE DATABASE metals-directory_production WITH OWNER yourname; GRANT ALL PRIVILEGES ON DATABASE metals-directory_production TO yourname;
development: adapter: postgresql encoding: unicode database: metals-directory_development pool: 5 username: yourname password: passwordhere host: localhost port: 5432
$ brew info postgresql /usr/local/Cellar/postgresql/9.5.4_1 (3,147 files, 35M) Poured from bottle on 2016-10-14 at 13:33:28 /usr/local/Cellar/postgresql/9.6.1 (3,242 files, 36.4M) * Poured from bottle on 2017-02-06 at 12:41:00
$ launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist $ brew services stop postgresql
$ ls /usr/local/Cellar/postgresql/ 9.5.3 9.5.4 9.6.1
$ pg_upgrade \ -d /usr/local/var/postgres \ -D /usr/local/var/postgres9.6 \ -b /usr/local/Cellar/postgresql/9.5.4/bin/ \ -B /usr/local/Cellar/postgresql/9.6.1/bin/ \ -v
$ mv /usr/local/var/postgres /usr/local/var/postgres9.5
$ mv /usr/local/var/postgres9.6 /usr/local/var/postgres
$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist $ brew services start postgresql
brew switch postgres 9.3.5 pg_dumpall > outputfile launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist mv /usr/local/var/postgres /usr/local/var/postgres.old brew switch postgres 9.4.1 initdb -D /usr/local/var/postgres psql -d postgres -f outputfile
kill_postgres() { if [[ $* -eq "" ]]; then echo "Usage: else gksudo echo "Granted sudo" pids="$(ps xa | grep postgres | grep $* | awk if [[ $pids -eq "" ]]; then echo "Nothing to kill" else for pid in "${pids[@]}" do echo "Killing ${pid}" sudo kill $pid echo "Killed ${pid}" done kill_postgres $* fi fi }
pg_ctl -D /usr/local/var/postgres start && brew services start postgresql
CREATE ROLE POSTGRES WITH SUPERUSER CREATEDB CREATEUSER CREATEROLE REPLICATION BYPASSRLS ;
class Customer def initialize(id, name, addr) @cust_id = id @cust_name = name @cust_addr = addr end def display_details puts "Customer id puts "Customer name puts "Customer address end end
array = [:peanut, :butter, :and, :jelly] array[0] array[0,1] array[0,2] array[0,0] array[2] array[2,2] array[2,20] array[4] array[4,0] array[4,100] array[5] array[5,0]
* call-seq: * array[index] -> obj or nil * array[start, length] -> an_array or nil * array[range] -> an_array or nil * array.slice(index) -> obj or nil * array.slice(start, length) -> an_array or nil * array.slice(range) -> an_array or nil
if (argc == 2) { if (SYMBOL_P(argv[0])) { rb_raise(rb_eTypeError, "Symbol as array index"); } beg = NUM2LONG(argv[0]); len = NUM2LONG(argv[1]); if (beg < 0) { beg += RARRAY(ary)->len; } return rb_ary_subseq(ary, beg, len); }
array[0,4] => [:peanut, :butter, :and, :jelly] array[1,3] => [:butter, :and, :jelly] array[2,2] => [:and, :jelly] array[3,1] => [:jelly] array[4,0] => []
array = [:peanut, :butter, :and, :jelly] array[4,0] = [:sandwich] array[0,0] = [:make, :me, :a] array[3, 4] = [:grilled, :cheese]
array[4, 0] = :sandwich array[0, 0] = :crunchy => [:crunchy, :peanut, :butter, :and, :jelly, :sandwich]
a = [ "a", "b", "c", "d", "e" ] a[2] + a[0] + a[1] a[6] a[1, 2] a[1..3] a[4..7] a[6..10] a[-3, 3] a[5] a[5, 1] a[5..10]
-4 -3 -2 -1 <-- numbering for single argument indexing 0 1 2 3 +---+---+---+---+ | a | b | c | d | +---+---+---+---+ 0 1 2 3 4 <-- numbering for two argument indexing or start of range -4 -3 -2 -1
s = "abcd" To insert text before To insert text after To replace first two characters: s[0,2] = "AB" To replace last two characters: s[-2,2] = "CD" To replace middle two characters: s[1..3] = "XX"
s = "abcd" s[1..1] s[1..1] = "X" s[1...1] s[1...1] = "X" the string s[1..3] s[1..3] = "X" s[1...3] s[1...3] = "X"
1189: if (offset < 0 || len <= offset) { 1190: return Qnil; 1191: }
1208: long alen = RARRAY_LEN(ary); 1209: 1210: if (beg > alen) return Qnil;
1213: if (alen < len || alen < beg + len) { 1214: len = alen - beg; 1215: } 1216: klass = rb_obj_class(ary); 1217: if (len == 0) return ary_new(klass, 0);
CREATE TABLE users ( firstname string, lastname string role string );
def update @user = User.find_by_id(params[:id]) @user.firstname = params[:user][:firstname] @user.lastname = params[:user][:lastname] if @user.save flash[:success] = t( end respond_with(@user) end
class User < ActiveRecord::Base attr_accessible :firstname, :lastname end
def update @user = User.find_by_id(params[:id]) if @user.update_attributes(params[:user]) flash[:success] = t( end respond_with(@user) end
class User < ActiveRecord::Base attr_accessible :firstname, :lastname attr_accessor :peekaboo end
class MyModel def my_variable @my_variable end def my_variable=(value) @my_variable = value end end
class Address attr_reader :street attr_writer :street def initialize @street = "" end end
class Address attr_accessor :street def initialize @street = "" end end
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"
RVM is not a function, selecting rubies with You need to change your terminal emulator preferences to allow login shell. Sometimes it is required to use `/bin/bash --login` as the command. Please visit https:
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm" source ~/.profile
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"
class Object def nil_zero? self.nil? || self == 0 end end nil.nil_zero? 0.nil_zero? 1.nil_zero? "a".nil_zero? unless discount.nil_zero? end
def is_nil_and_zero(data) data.blank? || data == 0 end
if discount.nil? || discount == 0 [do something] end
module Nothingness refine Numeric do alias_method :nothing?, :zero? end refine NilClass do alias_method :nothing?, :nil? end end using Nothingness if discount.nothing? end
a <=> b := if a < b then return -1 if a = b then return 0 if a > b then return 1 if a and b are not comparable then return nil
class Card include Comparable attr_reader :value def initialize(value) @value = value end def <=> (other) self.value <=> other.value end end a = Card.new(7) b = Card.new(10) c = Card.new(8) puts a > b puts c.between?(a,b) p [a,b,c].sort
my_objects.sort! { |a, b| a.zip <=> b.zip } my_objects.sort! { |a, b| b.zip <=> a.zip } my_objects.sort! { |a, b| -1 * (a.zip <=> b.zip) } my_objects.sort! { |a, b| 2 * (a.last <=> b.last) + (a.first <=> b.first) } my_objects.sort! do |a, b| 4 * (a.zip <=> b.zip) + -3 * (a.age <=> b.age) + 2 * (a.last <=> b.last) + (a.first <=> b.first) end
- Return 0 if values on either side are equal - Return 1 if value on the left is greater - Return -1 if the value on the right is greater
echo 1 <=> 1; echo 3 <=> 4; echo 4 <=> 3; echo "x" <=> "x"; echo "x" <=> "y"; echo "y" <=> "x";
echo 1 <=> 1; echo 1 <=> 2; echo 2 <=> 1; echo 1.5 <=> 1.5; echo 1.5 <=> 2.5; echo 2.5 <=> 1.5; echo "a" <=> "a"; echo "a" <=> "b"; echo "b" <=> "a"; echo "a" <=> "aa"; echo "zz" <=> "aa"; echo [] <=> []; echo [1, 2, 3] <=> [1, 2, 3]; echo [1, 2, 3] <=> []; echo [1, 2, 3] <=> [1, 2, 1]; echo [1, 2, 3] <=> [1, 2, 4]; $a = (object) ["a" => "b"]; $b = (object) ["a" => "b"]; echo $a <=> $b;
<% if false %> code to be commented out... <% end %>
my_hash = my_hash.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
myhash.keys.each do |key| myhash[(key.to_sym rescue key) || key] = myhash.delete(key) end
def symbolize(obj) return obj.inject({}){|memo,(k,v)| memo[k.to_sym] = symbolize(v); memo} if obj.is_a? Hash return obj.inject([]){|memo,v | memo << symbolize(v); memo} if obj.is_a? Array return obj end
class Object def deep_symbolize_keys return self.inject({}){|memo,(k,v)| memo[k.to_sym] = v.deep_symbolize_keys; memo} if self.is_a? Hash return self.inject([]){|memo,v | memo << v.deep_symbolize_keys; memo} if self.is_a? Array return self end end
json_obj = JSON.parse(json_str, symbolize_names: true)
def symbolize_keys(hash) hash.each_with_object({}) { |(k, v), h| h[k.to_sym] = v.is_a?(Hash) ? symbolize_keys(v) : v } end
my_hash = YAML.load_file( my_lamb = lambda { |key| my_hash[key.to_s] } my_lamb[:a] == my_hash[
my_hash = Hash.new { |h,k| h[k] = h[k.to_s] }.merge(YAML.load_file(
irb> x = { irb> y = Hash.new { |h,k| h[k] = h[k.to_s] }.merge(x) irb> y[:a] irb> y irb> y[:a] irb> y[ irb> y
irb> q = { irb> r = Hash.new { |h,k| h[k.to_s] }.merge(q) irb> r[:c] irb> r irb> r[:c] irb> r[:c] = 7 irb> r
my_hash.inject({}){|h,(k,v)| h.merge({ k.to_sym => v}) }
new_hash = Hash.new my_hash.each { |k, v| new_hash[k.to_sym] = v }
my_hash = HashWithIndifferentAccess.new(YAML.load_file(
class Hash def symbolize_keys! self.keys.each do |k| if self[k].is_a? Hash self[k].symbolize_keys! end if k.is_a? String raise RuntimeError, "Symbolizing key self[k.to_sym] = self[k] self.delete(k) end end return self end end
def deep_convert(element) return element.collect { |e| deep_convert(e) } if element.is_a?(Array) return element.inject({}) { |sh,(k,v)| sh[k.to_sym] = deep_convert(v); sh } if element.is_a?(Hash) element end
ruby-1.9.2-p180 :001 > h = { => {"aaa"=>1, "bbb"=>2} ruby-1.9.2-p180 :002 > Hash[h.map{|a| [a.first.to_sym, a.last]}] => {:aaa=>1, :bbb=>2}
def recursive_symbolize_keys(my_hash) case my_hash when Hash Hash[ my_hash.map do |key, value| [ key.respond_to?(:to_sym) ? key.to_sym : key, recursive_symbolize_keys(value) ] end ] when Enumerable my_hash.map { |value| recursive_symbolize_keys(value) } else my_hash end end
my_hash = { "a" => 1, "b" => "string", "c" => true } my_hash.keys.each { |key| my_hash[key.to_sym] = my_hash.delete(key) } my_hash => {:a=>1, :b=>"string", :c=>true}
my_hash.keys.each { |key| my_hash[key.to_sym] = my_hash.delete(key)}
module HashUtils def symbolize_keys(hash) transformer_function = ->(key) { key.to_sym } transform_keys(hash, transformer_function) end def stringify_keys(hash) transformer_function = ->(key) { key.to_s } transform_keys(hash, transformer_function) end def transform_keys(obj, transformer_function) case obj when Array obj.map{|value| transform_keys(value, transformer_function)} when Hash obj.each_with_object({}) do |(key, value), hash| hash[transformer_function.call(key)] = transform_keys(value, transformer_function) end else obj end end end
$ irb >> 2 / 3 => 0 >> 2.to_f / 3 => 0.666666666666667 >> 2 / 3.to_f => 0.666666666666667
Paperclip::Errors::MissingRequiredValidatorError in PostsController Paperclip::Errors::MissingRequiredValidatorError Extracted source (around line def create @post = Post.new(post_params)
def update @post = Post.find(params[:id]) if @post.update(post_params) redirect_to action: :show, id: @post.id else render end end def new @post = Post.new end def create @post = Post.new(post_params) if @post.save redirect_to action: :show, id: @post.id else render end end private def post_params params.require(:post).permit(:title, :text, :image) end
module PostsHelper def post_params params.require(:post).permit(:title, :body, :tag_list, :image) end end
validates_attachment_content_type :image, :content_type => ["image/jpg", "image/jpeg", "image/png", "image/gif"]
validates_attachment :image, content_type: { content_type: ["image/jpg", "image/jpeg", "image/png", "image/gif"] }
validates_attachment_file_name :image, :matches => [/png\Z/, /jpe?g\Z/, /gif\Z/]
validates_attachment :image, content_type: { content_type: /\Aimage\/.*\Z/ }
class User < ActiveRecord::Base attr_accessible :avatar has_attached_file :avatar, :styles => { :medium => "300x300>", :thumb => "100x100>" }, :default_url => "/images/:style/missing.png" validates_attachment_content_type :avatar, :content_type => /\Aimage\/.*\Z/ end
class User < ActiveRecord::Base has_attached_file :avatar, :styles => { :medium => "300x300>", :thumb => "100x100>" }, :default_url => "/images/:style/missing.png" validates_attachment_content_type :avatar, :content_type => /\Aimage\/.*\Z/ end
class Post < ActiveRecord::Base has_attached_file :photo validates_attachment_content_type :photo, :content_type => ["image/jpg", "image/jpeg", "image/png", "image/gif"] end
module PrettyDate def to_pretty a = (Time.now-self).to_i case a when 0 then when 1 then when 2..59 then a.to_s+ when 60..119 then when 120..3540 then (a/60).to_i.to_s+ when 3541..7100 then when 7101..82800 then ((a+99)/3600).to_i.to_s+ when 82801..172000 then when 172001..518400 then ((a+800)/(60*60*24)).to_i.to_s+ when 518400..1036800 then else ((a+180000)/(60*60*24*7)).to_i.to_s+ end end end Time.send :include, PrettyDate
include ActionView::Helpers::DateHelper def index @sexy_date = time_ago_in_words(Date.today - 1) end
def relative_time(start_time) diff_seconds = Time.now - start_time case diff_seconds when 0 .. 59 puts " when 60 .. (3600-1) puts " when 3600 .. (3600*24-1) puts " when (3600*24) .. (3600*24*30) puts " else puts start_time.strftime("%m/%d/%Y") end end
<abbr class="timeago" title="<%= comment.created_at.getutc.iso8601 %>"> <%= comment.created_at.to_s %> </abbr>
Time.now.yesterday Time.now.ago(2.days).end_of_day Time.now.next_month.beginning_of_month
Time.zone.now - 10.minute Time.zone.today.days_ago(5)
[1, 2, 3].should =~ [2, 3, 1] [1, 2, 3].should match_array([2, 3, 1])
expect([1, 2, 3]).to contain_exactly(2, 3, 1) expect([:a, :c, :b]).to contain_exactly(:a, :c )
expect([1, 2, 3]).to eq(1, 2, 3) expect([1, 2, 3]).to eq(2, 3, 1)
require url = URI.parse( req = Net::HTTP::Get.new(url.to_s) res = Net::HTTP.start(url.host, url.port) {|http| http.request(req) } puts res.body
require result = Net::HTTP.get(URI.parse( result = Net::HTTP.get(URI.parse(
require "uri" require proxy_host = proxy_port = proxy_user = proxy_pass = uri = URI.parse("https: proxy = Net::HTTP::Proxy(proxy_host, proxy_port, proxy_user, proxy_pass) req = Net::HTTP::Get.new(uri.path) req.basic_auth(<sauce_username>,<sauce_password>) result = proxy.start(uri.host,uri.port) do |http| http.request(req) end puts result.body
File.basename("/home/gumby/work/ruby.rb") File.basename("/home/gumby/work/ruby.rb", ".rb")
irb(main):024:0> f = => "C:/foobar/blah.txt" irb(main):027:0> File.basename(f,File.extname(f)) => "blah"
File.basename("a/b/d/test.rb", File.extname("a/b/d/test.rb"))
irb(main):003:0* f = irb(main):007:0> f.split( => ["C:", "path", "file.txt"] irb(main):008:0> f.split( => "file.txt"
set HTTP_PROXY=some.proxy.com set HTTP_PROXY_USER=user set HTTP_PROXY_PASS=password
set HTTP_PROXY=http: set HTTP_PROXY_USER=username set HTTP_PROXY_PASS=userparssword set HTTPS_PROXY=http: set HTTPS_PROXY_USER=username set HTTPS_PROXY_PASS=userpassword
"Book Author Title".gsub(/\s+/, "_").downcase.to_sym
"Book Author Title".parameterize( => :book_author_title
"Book Author Title".downcase.gsub(/\s+/, "_").to_sym => :book_author_title
def create @vote = Vote.new(params[:vote]) item = params[:vote][:item_id] uid = params[:vote][:user_id] @extant = Vote.find(:last, :conditions => ["item_id = ? AND user_id = ?", item, uid]) last_vote_time = @extant.created_at unless @extant.blank? curr_time = Time.now end
@extant = Vote.find(:last, :conditions => ["item_id = ? AND user_id = ?", item, uid])
some_method.should_raise <any kind of exception, I don
expect { some_method }.to raise_error expect { some_method }.to raise_error(SomeError) expect { some_method }.to raise_error("oops") expect { some_method }.to raise_error(/oops/) expect { some_method }.to raise_error(SomeError, "oops") expect { some_method }.to raise_error(SomeError, /oops/) expect { some_method }.to raise_error(...){|e| expect(e.data).to eq "oops" } expect { some_method }.to_not raise_error ...
lambda { some_method }.should raise_error lambda { some_method }.should raise_error(SomeError) lambda { some_method }.should raise_error(SomeError, "oops") lambda { some_method }.should raise_error(SomeError, /oops/) lambda { some_method }.should raise_error(...){|e| e.data.should == "oops" } lambda { some_method }.should_not raise_error ...
expect { raise StandardError }.to raise_error expect { raise StandardError }.to raise_error(StandardError)
RubyGems Environment: - RUBYGEMS VERSION: 2.1.5 - RUBY VERSION: 2.0.0 (2013-06-27 patchlevel 247) [x86_64-darwin12.4.0] - INSTALLATION DIRECTORY: /Users/ttm/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0 - RUBY EXECUTABLE: /Users/ttm/.rbenv/versions/2.0.0-p247/bin/ruby - EXECUTABLE DIRECTORY: /Users/ttm/.rbenv/versions/2.0.0-p247/bin - SPEC CACHE DIRECTORY: /Users/ttm/.gem/specs - RUBYGEMS PLATFORMS: - ruby - x86_64-darwin-12 - GEM PATHS: - /Users/ttm/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0 - /Users/ttm/.gem/ruby/2.0.0 - GEM CONFIGURATION: - :update_sources => true - :verbose => true - :backtrace => false - :bulk_threshold => 1000 - REMOTE SOURCES: - https: - SHELL PATH: - /Users/ttm/.rbenv/versions/2.0.0-p247/bin - /Users/ttm/.rbenv/libexec - /Users/ttm/.rbenv/plugins/ruby-build/bin - /Users/ttm/perl5/perlbrew/bin - /Users/ttm/perl5/perlbrew/perls/perl-5.18.1/bin - /Users/ttm/.pyenv/shims - /Users/ttm/.pyenv/bin - /Users/ttm/.rbenv/shims - /Users/ttm/.rbenv/bin - /Users/ttm/bin - /usr/local/mysql-5.6.12-osx10.7-x86_64/bin - /Users/ttm/libsmi/bin - /usr/local/bin - /usr/bin - /bin - /usr/sbin - /sbin - /usr/local/bin
gem path rails => /home/cbliard/.rvm/gems/ruby-2.1.5/gems/rails-4.0.13 gem path rails => /home/cbliard/.rvm/gems/ruby-2.1.5/gems/rails-3.2.21
kirti@kirti-Aspire-5733Z:~$ gem help commands GEM commands are: build Build a gem from a gemspec cert Manage RubyGems certificates and signing settings check Check a gem repository for added or missing files cleanup Clean up old versions of installed gems in the local repository contents Display the contents of the installed gems dependency Show the dependencies of an installed gem environment Display information about the RubyGems environment fetch Download a gem and place it in the current directory generate_index Generates the index files for a gem server directory help Provide help on the install Install a gem into the local repository list Display gems whose name starts with STRING lock Generate a lockdown list of gems mirror Mirror all gem files (requires rubygems-mirror) outdated Display all gems that need updates owner Manage gem owners on RubyGems.org. pristine Restores installed gems to pristine condition from files located in the gem cache push Push a gem up to RubyGems.org query Query gem information in local or remote repositories rdoc Generates RDoc for pre-installed gems regenerate_binstubs Re run generation of executable wrappers for gems. search Display all gems whose name contains STRING server Documentation and gem repository HTTP server sources Manage the sources and cache file RubyGems uses to search for gems specification Display gem specification (in yaml) stale List gems along with access times uninstall Uninstall gems from the local repository unpack Unpack an installed gem to the current directory update Update installed gems to the latest version which Find the location of a library file you can require yank Remove a specific gem version release from RubyGems.org For help on a particular command, use Commands may be abbreviated, so long as they are unambiguous. e.g. kirti@kirti-Aspire-5733Z:~$
kirti@kirti-Aspire-5733Z:~$ gem help environment Usage: gem environment [arg] [options] Common Options: -h, --help Get help on this command -V, --[no-]verbose Set the verbose level of output -q, --quiet Silence commands --config-file FILE Use this config file instead of default --backtrace Show stack backtrace on errors --debug Turn on Ruby debugging Arguments: packageversion display the package version gemdir display the path where gems are installed gempath display path used to search for gems version display the gem format version remotesources display the remote gem servers platform display the supported gem platforms <omitted> display everything Summary: Display information about the RubyGems environment Description: The RubyGems environment can be controlled through command line arguments, gemrc files, environment variables and built-in defaults. Command line argument defaults and some RubyGems defaults can be set in a ~/.gemrc file for individual users and a /etc/gemrc for all users. These files are YAML files with the following YAML keys: :sources: A YAML array of remote gem repositories to install gems from :verbose: Verbosity of the gem command. false, true, and :really are the levels :update_sources: Enable/disable automatic updating of repository metadata :backtrace: Print backtrace when RubyGems encounters an error :gempath: The paths in which to look for gems :disable_default_gem_server: Force specification of gem server host on push <gem_command>: A string containing arguments for the specified gem command Example: :verbose: false install: --no-wrappers update: --no-wrappers :disable_default_gem_server: true RubyGems GEM_HOME environment variables. GEM_HOME sets the default repository to install into. GEM_PATH allows multiple local repositories to be searched for gems. If you are behind a proxy server, RubyGems uses the HTTP_PROXY, HTTP_PROXY_USER and HTTP_PROXY_PASS environment variables to discover the proxy server. If you would like to push gems to a private gem server the RUBYGEMS_HOST environment variable can be set to the URI for that server. If you are packaging RubyGems all of RubyGems lib/rubygems/defaults.rb. You may override these in lib/rubygems/defaults/operating_system.rb kirti@kirti-Aspire-5733Z:~$
kirti@kirti-Aspire-5733Z:~$ gem environment gemdir /home/kirti/.rvm/gems/ruby-2.0.0-p0 kirti@kirti-Aspire-5733Z:~$ gem environment gempath /home/kirti/.rvm/gems/ruby-2.0.0-p0:/home/kirti/.rvm/gems/ruby-2.0.0-p0@global kirti@kirti-Aspire-5733Z:~$
RubyGems Environment: - RUBYGEMS VERSION: 2.0.14 - RUBY VERSION: 2.0.0 (2014-02-24 patchlevel 451) [i686-linux] - INSTALLATION DIRECTORY: /usr/local/lib/ruby/gems/2.0.0 - RUBY EXECUTABLE: /usr/local/bin/ruby - EXECUTABLE DIRECTORY: /usr/local/bin - RUBYGEMS PLATFORMS: - ruby - x86-linux - GEM PATHS: - /usr/local/lib/ruby/gems/2.0.0 - /root/.gem/ruby/2.0.0 - GEM CONFIGURATION: - :update_sources => true - :verbose => true - :backtrace => false - :bulk_threshold => 1000 - REMOTE SOURCES: - https:
VISUAL=echo gem open rails => /usr/local/opt/asdf/installs/ruby/2.4.3/lib/ruby/gems/2.4.0/gems/rails-5.1.4
>> "1,2,3,4".split(",").map { |s| s.to_i } => [1, 2, 3, 4]
>> "1,2,3,4".split(",").map(&:to_i) => [1, 2, 3, 4]
arr = "12345" arr.split( output: ["1","2","3","4","5"]
arr = "1 2 3 4 5" arr.split( output: ["1","2","3","4","5"]
require File.dirname(__FILE__) + "/../../config/environment"
$MY_FILE_PATH = File.expand_path(File.dirname(__FILE__)) puts $MY_FILE_PATH
File.expand_path(File.dirname(__FILE__) + "relative/path/to/file")
require n = 1_000_000 print print print print Benchmark.bm(10) do |b| b.report( b.report( b.report( b.report( end
"foo".equal? "foo" -> false "foo" == "foo" -> true :foo.equal? :foo -> true :foo == :foo -> true
user system total real string 0.370000 0.000000 0.370000 ( 0.371700) str == str 0.330000 0.000000 0.330000 ( 0.326368) symbol 0.170000 0.000000 0.170000 ( 0.174641) sym == sym 0.180000 0.000000 0.180000 ( 0.179374)
irb(main):025:0> irb(main):026:0> :foo => :foo irb(main):027:0> " => "foo" irb(main):028:0> irb(main):029:0> => nil irb(main):030:0> => 0 irb(main):031:0>
a_father = { "father" => "Bob", "age" => 40 } @fathers << a_father a_father = { "father" => "David", "age" => 32 } @fathers << a_father a_father = { "father" => "Batman", "age" => 50 } @fathers << a_father
array = [ {:name => "Hitesh" , :age => 27 , :place => "xyz"} , {:name => "John" , :age => 26 , :place => "xtz"} , {:name => "Anil" , :age => 26 , :place => "xsz"} ]
class Test attr_accessor :x end x = Test.new x.x = 7 y = x.dup z = x.clone y.x => 7 z.x => 7
o = Object.new def o.foo 42 end o.dup.foo o.clone.foo
class Foo attr_accessor :bar end o = Foo.new o.freeze o.dup.bar = 10 o.clone.bar = 10
class Test attr_accessor :x end x = Test.new x.x = 7 x.freeze y = x.dup z = x.clone y.x = 5 => 5 z.x = 5 => TypeError: can
def x.cool_method puts "Goodbye Space!" end y = x.dup z = x.clone y.cool_method => NoMethodError: undefined method `cool_method' z.cool_method => Goodbye Space!
class Klass attr_accessor :str end module Foo def foo; end s1 = Klass.new s1.extend(Foo) s1.foo s2 = s1.clone s2.foo s3 = s1.dup s3.foo
f = => "Frozen" f.frozen? => true f.clone.frozen? => true f.dup.frozen? => false
irb(main):001:0> RUBY_VERSION => "2.0.0" irb(main):002:0> Time.at(2**62-1).utc => 146138514283-06-19 07:44:38 UTC irb(main):003:0> Time.at(2**128).utc => 10783118943836478994022445751222-08-06 08:03:51 UTC irb(main):004:0> Time.at(-2**128).utc => -10783118943836478994022445747283-05-28 15:55:44 UTC
irb(main):001:0> RUBY_VERSION => "2.0.0" irb(main):002:0> require "date" => true irb(main):003:0> t = Time.new(2012,6,30,23,59,60,0) => 2012-06-30 23:59:60 +0000 irb(main):004:0> dt = t.to_datetime; dt.to_s => "2012-06-30T23:59:59+00:00" irb(main):005:0> t == dt.to_time => false irb(main):006:0> t.to_i => 1341100824 irb(main):007:0> dt.to_i => 1341100823
irb(main):001:0> RUBY_VERSION => "2.0.0" irb(main):002:0> require "date" => true irb(main):003:0> t = Time.local(2012,7,1) => 2012-07-01 00:00:00 +0200 irb(main):004:0> t.zone => "CEST" irb(main):005:0> t.dst? => true irb(main):006:0> dt = t.to_datetime; dt.to_s => "2012-07-01T00:00:00+02:00" irb(main):007:0> dt.zone => "+02:00" irb(main):008:0> dt.dst? NoMethodError: undefined method `dst?
>> Benchmark.bm do |bm| ?> bm.report( ?> n1 = DateTime.now >> n2 = DateTime.now >> 1_000_000.times{ n1 < n2 } >> end >> bm.report( ?> n1 = Time.now >> n2 = Time.now >> 1_000_000.times{ n1 < n2 } >> end >> end user system total real DateTime: 4.980000 0.020000 5.000000 ( 5.063963) Time: 0.330000 0.000000 0.330000 ( 0.335913)
user system total real DateTime: 0.330000 0.000000 0.330000 ( 0.333869) Time: 0.300000 0.000000 0.300000 ( 0.306444)
def self.format_date_time(date_time) if (date_time.respond_to?(:rfc822)) then return format_time(date_time) else time = Time.parse(date_time.to_s) return format_time(time) end end def self.format_time(time) return " end
irb(main):034:0> DateTime.parse( => Wed, 10 Oct 2012 23:59:59 +0300
irb(main):035:0> Time.parse( => 2012-10-10 23:59:59 +0000
irb(main):044:0> Time.zone = => "EET" irb(main):045:0> Time.zone.parse( => Wed, 10 Oct 2012 23:59:59 EEST +03:00
irb(main):001:0> Time.new(2016,9,1) => 2016-09-01 00:00:00 -0400 irb(main):002:0> DateTime.new(2016,9,1) => Thu, 01 Sep 2016 00:00:00 +0000 irb(main):003:0> Time.new(2016,9,1).to_i => 1472702400 irb(main):004:0> DateTime.new(2016,9,1).to_i => 1472688000
Time.parse("Ends from 28 Jun 2018 12:00 BST").utc.to_s
Date.parse("Ends from 28 Jun 2018 12:00 BST").to_time.utc.to_s
DateTime.parse("Ends from 28 Jun 2018 12:00 BST").to_time.utc.to_s
require start_date = Date.parse( end_date = Date.parse( wday = 5 (start_date..end_date).select{|d| d.wday == wday}.map{|d| d.to_s}.inspect
TableID: 1 Name: cycleA StartTime: 6 November 2014 (I kept thenumber of milliseconds), EndTime: 6 November 2015 (if it is repeated forever, and you can keep the value -1) Cycletype: WeekLy.
TableID: 1 Name, cycleB StartTime, 27 November 2014 EndTime,November 6 2015 Cycletype, WeekLy Foreignkey, 1 (pointingto the table recycle paternal events).
public static List<Map<String, Object>> recurringData(Context context, long start, long end) { long a = System.currentTimeMillis(); List<Map<String, Object>> finalDataList = new ArrayList<Map<String, Object>>(); List<Map<String, Object>> tDataList = BillsDao.selectTemplateBillRuleByBE(context); for (Map<String, Object> iMap : tDataList) { int _id = (Integer) iMap.get("_id"); long bk_billDuedate = (Long) iMap.get("ep_billDueDate"); long bk_billEndDate = (Long) iMap.get("ep_billEndDate"); int bk_billRepeatType = (Integer) iMap.get("ep_recurringType"); long startDate = 0; long endDate = 0; if (bk_billEndDate == -1) { if (end >= bk_billDuedate) { endDate = end; startDate = (bk_billDuedate <= start) ? start : bk_billDuedate; } } else { if (start <= bk_billEndDate && end >= bk_billDuedate) { endDate = (bk_billEndDate >= end) ? end : bk_billEndDate; startDate = (bk_billDuedate <= start) ? start : bk_billDuedate; } } Calendar calendar = Calendar.getInstance(); calendar.setTimeInMillis(bk_billDuedate); long virtualLong = bk_billDuedate; List<Map<String, Object>> virtualDataList = new ArrayList<Map<String, Object>>(); if (virtualLong == startDate) { Map<String, Object> bMap = new HashMap<String, Object>(); bMap.putAll(iMap); bMap.put("indexflag", 1); virtualDataList.add(bMap); } long before_times = 0; long remainder = -1; if (bk_billRepeatType == 1) { before_times = (startDate - bk_billDuedate) / (7 * DAYMILLIS); remainder = (startDate - bk_billDuedate) % (7 * DAYMILLIS); } else if (bk_billRepeatType == 2) { before_times = (startDate - bk_billDuedate) / (14 * DAYMILLIS); remainder = (startDate - bk_billDuedate) % (14 * DAYMILLIS); } else if (bk_billRepeatType == 3) { before_times = (startDate - bk_billDuedate) / (28 * DAYMILLIS); remainder = (startDate - bk_billDuedate) % (28 * DAYMILLIS); } else if (bk_billRepeatType == 4) { before_times = (startDate - bk_billDuedate) / (15 * DAYMILLIS); remainder = (startDate - bk_billDuedate) % (15 * DAYMILLIS); } else if (bk_billRepeatType == 5) { do { Calendar calendarCloneCalendar = (Calendar) calendar .clone(); int currentMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); calendarCloneCalendar.add(Calendar.MONTH, 1); int nextMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); if (currentMonthDay > nextMonthDay) { calendar.add(Calendar.MONTH, 1 + 1); virtualLong = calendar.getTimeInMillis(); } else { calendar.add(Calendar.MONTH, 1); virtualLong = calendar.getTimeInMillis(); } } while (virtualLong < startDate); } else if (bk_billRepeatType == 6) { do { Calendar calendarCloneCalendar = (Calendar) calendar .clone(); int currentMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); calendarCloneCalendar.add(Calendar.MONTH, 2); int nextMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); if (currentMonthDay > nextMonthDay) { calendar.add(Calendar.MONTH, 2 + 2); virtualLong = calendar.getTimeInMillis(); } else { calendar.add(Calendar.MONTH, 2); virtualLong = calendar.getTimeInMillis(); } } while (virtualLong < startDate); } else if (bk_billRepeatType == 7) { do { Calendar calendarCloneCalendar = (Calendar) calendar .clone(); int currentMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); calendarCloneCalendar.add(Calendar.MONTH, 3); int nextMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); if (currentMonthDay > nextMonthDay) { calendar.add(Calendar.MONTH, 3 + 3); virtualLong = calendar.getTimeInMillis(); } else { calendar.add(Calendar.MONTH, 3); virtualLong = calendar.getTimeInMillis(); } } while (virtualLong < startDate); } else if (bk_billRepeatType == 8) { do { calendar.add(Calendar.YEAR, 1); virtualLong = calendar.getTimeInMillis(); } while (virtualLong < startDate); } if (remainder == 0 && virtualLong != startDate) { before_times = before_times - 1; } if (bk_billRepeatType == 1) { virtualLong = bk_billDuedate + (before_times + 1) * 7 * (DAYMILLIS); calendar.setTimeInMillis(virtualLong); } else if (bk_billRepeatType == 2) { virtualLong = bk_billDuedate + (before_times + 1) * (2 * 7) * DAYMILLIS; calendar.setTimeInMillis(virtualLong); } else if (bk_billRepeatType == 3) { virtualLong = bk_billDuedate + (before_times + 1) * (4 * 7) * DAYMILLIS; calendar.setTimeInMillis(virtualLong); } else if (bk_billRepeatType == 4) { virtualLong = bk_billDuedate + (before_times + 1) * (15) * DAYMILLIS; calendar.setTimeInMillis(virtualLong); } while (startDate <= virtualLong && virtualLong <= endDate) { Map<String, Object> bMap = new HashMap<String, Object>(); bMap.putAll(iMap); bMap.put("ep_billDueDate", virtualLong); bMap.put("indexflag", 2); virtualDataList.add(bMap); if (bk_billRepeatType == 1) { calendar.add(Calendar.DAY_OF_MONTH, 7); } else if (bk_billRepeatType == 2) { calendar.add(Calendar.DAY_OF_MONTH, 2 * 7); } else if (bk_billRepeatType == 3) { calendar.add(Calendar.DAY_OF_MONTH, 4 * 7); } else if (bk_billRepeatType == 4) { calendar.add(Calendar.DAY_OF_MONTH, 15); } else if (bk_billRepeatType == 5) { Calendar calendarCloneCalendar = (Calendar) calendar .clone(); int currentMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); calendarCloneCalendar.add(Calendar.MONTH, 1); int nextMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); if (currentMonthDay > nextMonthDay) { calendar.add(Calendar.MONTH, 1 + 1); } else { calendar.add(Calendar.MONTH, 1); } }else if (bk_billRepeatType == 6) { Calendar calendarCloneCalendar = (Calendar) calendar .clone(); int currentMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); calendarCloneCalendar.add(Calendar.MONTH, 2); int nextMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); if (currentMonthDay > nextMonthDay) { calendar.add(Calendar.MONTH, 2 + 2); } else { calendar.add(Calendar.MONTH, 2); } }else if (bk_billRepeatType == 7) { Calendar calendarCloneCalendar = (Calendar) calendar .clone(); int currentMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); calendarCloneCalendar.add(Calendar.MONTH, 3); int nextMonthDay = calendarCloneCalendar .get(Calendar.DAY_OF_MONTH); if (currentMonthDay > nextMonthDay) { calendar.add(Calendar.MONTH, 3 + 3); } else { calendar.add(Calendar.MONTH, 3); } } else if (bk_billRepeatType == 8) { calendar.add(Calendar.YEAR, 1); } virtualLong = calendar.getTimeInMillis(); } finalDataList.addAll(virtualDataList); } /* * 开始处理重复特例事件特例事件，并且来时合并 */ List<Map<String, Object>>oDataList = BillsDao.selectBillItemByBE(context, start, end); Log.v("mtest", "特例结果大小" +oDataList ); List<Map<String, Object>> delectDataListf = new ArrayList<Map<String, Object>>(); List<Map<String, Object>> delectDataListO = new ArrayList<Map<String, Object>>(); for (Map<String, Object> fMap : finalDataList) { int pbill_id = (Integer) fMap.get("_id"); long pdue_date = (Long) fMap.get("ep_billDueDate"); for (Map<String, Object> oMap : oDataList) { int cbill_id = (Integer) oMap.get("billItemHasBillRule"); long cdue_date = (Long) oMap.get("ep_billDueDate"); int bk_billsDelete = (Integer) oMap.get("ep_billisDelete"); if (cbill_id == pbill_id) { if (bk_billsDelete == 2) { long old_due = (Long) oMap.get("ep_billItemDueDateNew"); if (old_due == pdue_date) { delectDataListf.add(fMap); } } else if (bk_billsDelete == 1) { if (cdue_date == pdue_date) { delectDataListf.add(fMap); delectDataListO.add(oMap); } } else { if (cdue_date == pdue_date) { delectDataListf.add(fMap); } } } } } finalDataList.removeAll(delectDataListf); oDataList.removeAll(delectDataListO); finalDataList.addAll(oDataList); List<Map<String, Object>> mOrdinaryList = BillsDao.selectOrdinaryBillRuleByBE(context, start, end); finalDataList.addAll(mOrdinaryList); long b = System.currentTimeMillis(); Log.v("mtest", "算法耗时"+(b-a)); return finalDataList; }
line_num=0 text=File.open( text.gsub!(/\r\n?/, "\n") text.each_line do |line| print " end
File.foreach(filename).with_index do |line, line_num| puts " end
File.open(file, "r") do |fh| header = fh.readline while(line = fh.gets) != nil end end
myFile=File.open("paths_to_file","r") while(line=myFile.gets) end
File.open( while chunk = io.read(16 * 1024) do something_with_the chunk end end
rbenv versions * 1.9.3-p0 (set by /Users/user/.rbenv/version) 1.9.3-p125 rbenv global 1.9.3-p0 rbenv rehash ruby -v ruby 1.8.7 (2011-12-28 patchlevel 357) [universal-darwin11.0] which ruby /usr/bin/ruby
rbenv local rbenv: no local version configured for this directory
export PATH="$HOME/.rbenv/bin:$PATH" eval "$(rbenv init -)"
[~/.rbenv] $ rbenv versions * system (set by /Users/alphadogg/.rbenv/version) 2.0.0-p247
if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi
export PATH="$HOME/.rbenv/bin:$PATH" eval "$(rbenv init -)"
➜ ~ rbenv install 2.4.0 ➜ ~ rbenv global 2.4.0 ➜ ~ rbenv global 2.4.0 ➜ ~ ruby -v ruby 2.4.0p0 (2016-12-24 revision 57164) [x86_64-darwin16]
[~]$ rbenv version 2.3.0 (set by /Users/user/.rbenv/version) [~]$ ruby -v ruby 2.3.3p222 (2016-11-21 revision 56859) [x86_64-darwin16] [~]$ which ruby /usr/local/bin/ruby
plugins=(git bower rails ruby rbenv gulp npm node nvm sublime)
export PATH="$HOME/.rbenv/bin:$PATH" eval "$(rbenv init -)"
set --universal fish_user_paths $fish_user_paths ~/.rbenv/shims/
hash.keys.sort.each do |key| puts " hash[key].each { |val| puts val } end
module HashRecursive refine Hash do def each(recursive=false, &block) if recursive Enumerator.new do |yielder| self.map do |key, value| value.each(recursive=true).map{ |key_next, value_next| yielder << [[key, key_next].flatten, value_next] } if value.is_a?(Hash) yielder << [[key], value] end end.entries.each(&block) else super(&block) end end alias_method(:each_pair, :each) end end using HashRecursive
hash = { :a => { :b => { :c => 1, :d => [2, 3, 4] }, :e => 5 }, :f => 6 } p hash.each, hash.each {}, hash.each.size p hash.each(true), hash.each(true) {}, hash.each(true).size hash.each do |key, value| puts " end hash.each(true) do |key, value| puts " end hash.each_pair(recursive=true) do |key, value| puts " end
hash = { 1 => ["a", "b"], 2 => ["c"], 3 => ["a", "d", "f", "g"], 4 => ["q"] } hash.each(recursive=false) do |key, value| puts " end
irb(main):002:0> filename = "%s/%s.%04d.txt" % ["dirname", "filename", 23] => "dirname/filename.0023.txt"
>> n = "000" >> 3.times { puts "file_ file_001 file_002 file_003
>> n = "file_000" >> 3.times { puts n.next! } file_001 file_002 file_003
start_cards = DeckCard.find :all, :joins => [:card], :conditions => ["deck_cards.deck_id = ? and cards.start_card = ?", @game.deck.id, true]
for player in @game.players player.tableau = Tableau.new start_card = start_cards.pop start_card.draw_pile = false player.tableau.deck_cards << start_card end
class Player < ActiveRecord::Base belongs_to :game belongs_to :user has_one :hand has_one :tableau end class Tableau < ActiveRecord::Base belongs_to :player has_many :deck_cards end class DeckCard < ActiveRecord::Base belongs_to :card belongs_to :deck end
module DeactivateImplicitReadonly def custom_join_sql(*args) result = super @implicit_readonly = false result end end ActiveRecord::Relation.send :include, DeactivateImplicitReadonly
class Test def hello; end end Test.method_defined? :hello
class Module def instance_respond_to?(method_name) public_instance_methods.include?(method_name) end end
methods = [:valid?, :chase, :test] def has_methods?(something, methods) methods & something.methods == methods end
class Foo def self.fclass_method end def finstance_method end end foo_obj = Foo.new foo_obj.class.methods(false) => [:fclass_method] foo_obj.class.instance_methods(false) => [:fclass_method]
desc "Testing args" task: :hello, :user, :message do |t, args| args.with_defaults(:message => "Thanks for logging on") puts "Hello end
desc "Testing environment" task: :hello => :environment do puts "Hello end
desc "Testing environment and variables" task: :hello => :environment, :message do |t, args| args.with_defaults(:message => "Thanks for logging on") puts "Hello end
desc "Testing environment and variables" task :hello, :message, :needs => :environment do |t, args| args.with_defaults(:message => "Thanks for logging on") puts "Hello end
desc "Testing environment and variables" task :hello, [:message] => :environment do |t, args| args.with_defaults(:message => "Thanks for logging on") puts "Hello end
task :name, [:first_name, :last_name] => [:pre_name] do |t, args| args.with_defaults(:first_name => "John", :last_name => "Dough") puts "First name is puts "Last name is end
$ rake eaternet:import country=us region=or agency=multco
task import: [:environment] do agency = agency_to_import puts "Importing data for agency.import_businesses end def agency_to_import country_code = ENV[ region_slug = ENV[ agency_slug = ENV[ Agency.from_slugs(country_code, region_slug, agency_slug) end
namespace :my_example do desc "Something" task :my_task => :environment do puts ARGV.inspect end end
class Test def initialize puts "I love India" end end Test.new
ruby: No such file or directory -- abc.rb (LoadError)
cd to/the/program/location chmod 777 program.rb ./program.rb
def handle_unverified_request forgery_protection_strategy.new(self).handle_unverified_request end
def handle_unverified_request raise ActionController::InvalidAuthenticityToken end
<%= tag(:input, :type => "hidden", :name => request_forgery_protection_token.to_s, :value => form_authenticity_token) %>
<%= hidden_field_tag :authenticity_token, form_authenticity_token %>
class FooController < ApplicationController protect_from_forgery except: :index
skip_before_filter :verify_authenticity_token, if: :json_request?
protect_from_forgery with: :null_session, if: Proc.new {|c| c.request.format.json? }
<%= hidden_field_tag :authenticity_token, form_authenticity_token %>
class NameController < ApplicationController skip_before_action :verify_authenticity_token
class ApplicationController < ActionController::Base protect_from_forgery with: :null_session end
<form accept-charset="UTF-8" action="/login/signin" method="post"> <div style="display:none"> <input name="utf8" type="hidden" value="& <input name="authenticity_token" type="hidden" value="x37DrAAwyIIb7s+w2+AdoCR8cAJIpQhIetKRrPgG5VA="> </div> ... </form>
if RUBY_VERSION < require else require class Win32API DLL = {}
begin original_verbose = $VERBOSE $VERBOSE = nil require "thor" ensure $VERBOSE = original_verbose end
class String def underscore self.gsub(/::/, gsub(/([A-Z]+)([A-Z][a-z])/, gsub(/([a-z\d])([A-Z])/, tr("-", "_"). downcase end end
class String def to_underscore! gsub!(/(.)([A-Z])/, downcase! end def to_underscore dup.tap { |s| s.to_underscore! } end end
def underscore(camel_cased_word) camel_cased_word.to_s.gsub(/::/, gsub(/([A-Z]+)([A-Z][a-z])/, gsub(/([a-z\d])([A-Z])/, tr("-", "_"). downcase end
def snake_case return downcase if match(/\A[A-Z]+\z/) gsub(/([A-Z]+)([A-Z][a-z])/, gsub(/([a-z])([A-Z])/, downcase end "FooBar".snake_case "HeadlineCNNNews".snake_case "CNN".snake_case
"SnakeCase".snakecase "Snake-Case".snakecase "Snake Case".snakecase "Snake - Case".snakecase
class String # # def snakecase gsub(/([A-Z]+)([A-Z][a-z])/, gsub(/([a-z\d])([A-Z])/, tr( gsub(/\s/, gsub(/__+/, downcase end # alias_method :underscore, :snakecase end
class String def snikize self.gsub(/::/, .gsub(/([a-z\d])([A-Z])/, "\1_\2") .downcase end def snikize self.gsub(/::/, .gsub(/([a-z\d])([A-Z])/) do " end .downcase end end
{:a => "a", :b => [{:c => "c", :d => "d"}, {:e => "e", :f => "f"}]
require "addressable/uri" uri = Addressable::URI.new uri.query_values = {:a => "a", :b => ["c", "d", "e"]} uri.query uri.query_values = {:a => "a", :b => [{:c => "c", :d => "d"}, {:e => "e", :f => "f"}]} uri.query uri.query_values = {:a => "a", :b => {:c => "c", :d => "d"}} uri.query uri.query_values = {:a => "a", :b => {:c => "c", :d => true}} uri.query uri.query_values = {:a => "a", :b => {:c => "c", :d => true}, :e => []} uri.query
>> {:a => "a", :b => ["c", "d", "e"]}.to_query => "a=a&b%5B%5D=c&b%5B%5D=d&b%5B%5D=e" >> CGI.unescape({:a => "a", :b => ["c", "d", "e"]}.to_query) => "a=a&b[]=c&b[]=d&b[]=e"
URI.encode_www_form([["q", "ruby"], ["lang", "en"]]) URI.encode_www_form("q" => "ruby", "lang" => "en") URI.encode_www_form("q" => ["ruby", "perl"], "lang" => "en") URI.encode_www_form([["q", "ruby"], ["q", "perl"], ["lang", "en"]])
require Rack::Utils.build_query( authorization_token: "foo", access_level: "moderator", previous: "index" )
Rack::Utils.build_query( {:a => "a", :b => ["c", "d", "e"]} ) Rack::Utils.parse_query _
Rack::Utils.build_nested_query( {:a => "a", :b => [{:c => "c", :d => "d"}, {:e => "e", :f => "f"}] } ) Rack::Utils.parse_nested_query _
def to_params params = stack = [] each do |k, v| if v.is_a?(Hash) stack << [k,v] else params << " end end stack.each do |parent, hash| hash.each do |k, v| if v.is_a?(Hash) stack << [" else params << " end end end params.chop! params end
hash = {"foo" => "bar", "fooz" => 123} query_string = hash.to_a.map { |x| "
class Hash def to_params params = stack = [] each do |k, v| if v.is_a?(Hash) stack << [k,v] elsif v.is_a?(Array) stack << [k,Hash.from_array(v)] else params << " end end stack.each do |parent, hash| hash.each do |k, v| if v.is_a?(Hash) stack << [" else params << " end end end params.chop! params end def self.from_array(array = []) h = Hash.new array.size.times do |t| h[t] = array[t] end h end end
{:a=>"a", :b=>"b", :c=>"c"}.map{ |x,v| " "a=a&b=b&c=c"
module QueryParams def self.encode(value, key = nil) case value when Hash then value.map { |k,v| encode(v, append_key(key,k)) }.join( when Array then value.map { |v| encode(v, " when nil then else " end end private def self.append_key(root_key, key) root_key.nil? ? key : " end end
puts PHP.http_build_query({"a"=>"b","c"=>"d","e"=>[{"hello"=>"world","bah"=>"black"},{"hello"=>"world","bah"=>"black"}]})
{a: 1, b: [1,2,3]}.to_param "a=1&b[]=1&b[]=2&b[]=3"
require class Hash def to_query_hash(key) reduce({}) do |h, (k, v)| new_key = key.nil? ? k : " v = Hash[v.each_with_index.to_a.map(&:reverse)] if v.is_a?(Array) if v.is_a?(Hash) h.merge!(v.to_query_hash(new_key)) else h[new_key] = v end h end end def to_query(key = nil) URI.encode_www_form(to_query_hash(key)) end end 2.4.2 :019 > {:a => "a", :b => "b"}.to_query_hash(nil) => {:a=>"a", :b=>"b"} 2.4.2 :020 > {:a => "a", :b => "b"}.to_query => "a=a&b=b" 2.4.2 :021 > {:a => "a", :b => ["c", "d", "e"]}.to_query_hash(nil) => {:a=>"a", "b[0]"=>"c", "b[1]"=>"d", "b[2]"=>"e"} 2.4.2 :022 > {:a => "a", :b => ["c", "d", "e"]}.to_query => "a=a&b%5B0%5D=c&b%5B1%5D=d&b%5B2%5D=e"
task :foo do puts "printed" next puts "never printed" end
task :foo do do_something end def do_something puts "startd" return puts "end" end
task :something do [1,2,3].each do |i| ... fail "some error" if ... end end
task :check do errors = get_errors abort( "There are end
task :check do errors = get_errors exit if errors.empty? end
task auto_invoice: :environment do if Application.feature_disabled?(:auto_invoice) $stderr.puts next end
class Person def self.get_name persons_name end class << self private def persons_name "Sam" end end end puts "Hey, " + Person.get_name puts "Hey, " + Person.persons_name
class Person def self.get_name persons_name end private def self.persons_name "Sam" end end puts "Hey, " + Person.get_name puts "Hey, " + Person.persons_name
class Person def self.get_name persons_name end def self.persons_name "Sam" end private_class_method :persons_name end puts "Hey, " + Person.get_name puts "Hey, " + Person.persons_name
class Person def self.get_name persons_name end private_class_method def self.persons_name "Sam" end end puts "Hey, " + Person.get_name puts "Hey, " + Person.persons_name
class Frob attr_reader :val1, :val2 Tolerance = 2 * Float::EPSILON def initialize(val1, val2) @val2 = val1 @val2 = val2 ... end def self.compare(reference, under_test) (reference - under_test).abs <= Tolerance end private_class_method :compare def ==(arg) self.class.send(:compare, val1, arg.val1) && self.class.send(:compare, val2, arg.val2) && ... end end
class A private def instance_method_1; end def instance_method_2; end end
class A private def instance_method; end class << self private def class_method; end end end
class Check def self.first_method second_method end private def self.second_method puts "well I executed" end end Check.first_method
p 10.to_s(16) p "%x" % 10 p "%02X" % 10 p sprintf("%02X", 10) p "
path = ActionController::Routing::Routes.recognize_path "/your/path/here/" # path = Rails.application.routes.recognize_path( controller = path[:controller] action = path[:action]
def current_controller?(names) names.include?(current_controller) end
Rails.application.routes.recognize_path "/your/path"
route, match, params = Rails.application.routes.set.recognize(controller.request)
Rails.application.routes.set.recognize(controller.request) do |r, m, p| ... do something here ... end
class ApplicationController < ActionController::Base def current_controller?(names) names.include?(params[:controller]) unless params[:controller].blank? || false end helper_method :current_controller? end
<ul class="nav nav-tabs"> <li role="presentation" class="<%= current_controller?( <%= link_to user_items_path(current_user) do %> <i class="fa fa-cloud-upload"></i> <% end %> </li> <li role="presentation" class="<%= current_controller?( <%= link_to users_path do %> <i class="fa fa-newspaper-o"></i> <% end %> </li> <li role="presentation" class="<%= current_controller?( <%= link_to alerts_path do %> <i class="fa fa-bell-o"></i> <% end %> </li> </ul>
current_page?(users_path) current_page?(alerts_path)
/users/x/items /users/x/items/x /users/x/items/new /users/x/items/x/edit
class BankController < ActionController::Base before_filter :pre_process def index end private def pre_process logger.debug("The URL" + request.url) end end
private def pre_process self.controller_name self.controller_class_name end
if foo string = "this is a \ string that spans lines" end
string = "this is a \ string that spans lines" puts string.inspect
class Subscription def warning_message <<~HEREDOC Subscription expiring soon! Your free trial will expire in Please update your billing information. HEREDOC end end
image_url = %w( http: bucket29/docs/b7cfab0e-0119-452c-b262-1b78e3fccf38/ 28ed3774-b234-4de2-9a11-7d657707f79c? X-Amz-Algorithm=AWS4-HMAC-SHA256& X-Amz-Credential=ABABABABABABABABA %2Fus-east-1%2Fs3%2Faws4_request& X-Amz-Date=20170702T000940Z& X-Amz-Expires=3600&X-Amz-SignedHeaders=host& X-Amz-Signature=ABABABABABABABABABABAB ABABABABABABABABABABABABABABABABABABA ).join
Temporarily enhancing PATH to include DevKit... Building native extensions. This could take a while... ERROR: Error installing pg: ERROR: Failed to build gem native extension. C:/Ruby/bin/ruby.exe extconf.rb checking for pg_config... no No pg_config... trying anyway. If building fails, please try again with --with-pg-config=/path/to/pg_config checking for libpq-fe.h... no Can *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options. Provided configuration options: --with-opt-dir --without-opt-dir --with-opt-include --without-opt-include=${opt-dir}/include --with-opt-lib --without-opt-lib=${opt-dir}/lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=C:/Ruby/bin/ruby --with-pg --without-pg --with-pg-dir --without-pg-dir --with-pg-include --without-pg-include=${pg-dir}/include --with-pg-lib --without-pg-lib=${pg-dir}/lib --with-pg-config --without-pg-config --with-pg_config --without-pg_config Gem files will remain installed in C:/Ruby/lib/ruby/gems/1.8/gems/pg-0.10.1 for inspection. Results logged to C:/Ruby/lib/ruby/gems/1.8/gems/pg-0.10.1/ext/gem_make.out
gem install pg -- --with-pg-config=/Applications/Postgres.app/Contents/Versions/9.3/bin/pg_config
export PATH=%PATH:/Applications/Postgres.app/Contents/Versions/9.3/bin/
sudo apt-get install postgresql postgresql-server-dev-9.1
sudo apt-get install postgresql-9.3 postgresql-server-dev-9.3
export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/9.4/bin
$ PATH=$PATH:/Library/PostgreSQL/9.1/bin sudo gem install pg
apt-get install postgresql-9.1 sudo apt-get install postgresql-server-dev-9.1
PATH=$PATH:/Library/PostgreSQL/9.4/bin/ gem install pg
export PATH=/usr/pgsql-9.2/bin:$PATH bundle install
/Users/za/.rbenv/versions/2.3.0/lib/ruby/gems/2.3.0/extensions/x86_64-darwin-15/2.3.0-static/pg-1.0.0/mkmf.log
Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers
za:myapp za$ cat /Users/za/.rbenv/versions/2.3.0/lib/ruby/gems/2.3.0/extensions/x86_64-darwin-15/2.3.0-static/pg-1.0.0/mkmf.log | grep yes find_executable: checking for pg_config... -------------------- yes find_header: checking for libpq-fe.h... -------------------- yes find_header: checking for libpq/libpq-fs.h... -------------------- yes find_header: checking for pg_config_manual.h... -------------------- yes have_library: checking for PQconnectdb() in -lpq... -------------------- yes have_func: checking for PQsetSingleRowMode()... -------------------- yes have_func: checking for PQconninfo()... -------------------- yes have_func: checking for PQsslAttribute()... -------------------- yes have_func: checking for PQencryptPasswordConn()... -------------------- yes have_const: checking for PG_DIAG_TABLE_NAME in libpq-fe.h... -------------------- yes have_header: checking for unistd.h... -------------------- yes have_header: checking for inttypes.h... -------------------- yes checking for C99 variable length arrays... -------------------- yes
sudo ARCHFLAGS="-arch x86_64" gem install pg -- --with-pg-config=/Applications/Postgres.app/Contents/Versions/9.5/bin/pg_config
>> Date.new(2009,11,26).to_time => Thu Nov 26 00:00:00 -0800 2009 >> Date.new(2009,11,26).to_time.to_i => 1259222400 >> Time.at(1259222400) => Thu Nov 26 00:00:00 -0800 2009
>> Date.today.to_time.to_i => 1259244000 >> Time.now.to_i => 1259275709
1.8.7-p374 :001 > require => true 1.8.7-p374 :002 > DateTime.new(2012, 1, 15).strftime( => "1326585600"
> Date.new(2016, 12, 25).to_time.utc.to_i => 1482584400
> Date.new(2016, 12, 25).to_time => 2016-12-25 00:00:00 +1100 > Date.new(2016, 12, 25).to_time.utc => 2016-12-24 13:00:00 UTC
anujm@test:~$ dpkg -l |grep -i rubygem ii rubygems 1.3.5-1ubuntu2 package management framework for Ruby libraries/applications ii rubygems-lwes 0.8.2-1323277262 LWES rubygems ii rubygems1.8 1.3.5-1ubuntu2 package management framework for Ruby libraries/applications ii rubygems1.9 1.3.5-1ubuntu2 package management framework for Ruby libraries/applications anujm@test:~$ anujm@test:~$ gem gem gem1.8 gem1.9 anujm@test:~$ sudo gem1.8 install serve ERROR: Error installing serve: multi_json requires RubyGems version >= 1.3.6 anujm@test:~$
gem install rubygems-update update_rubygems gem update --system
arr = [5, 6, 7, 8] arr.inject{ |sum, el| sum + el }.to_f / arr.size => 6.5
arr = [5, 6, 7, 8] arr.inject(0.0) { |sum, el| sum + el } / arr.size => 6.5
class Array def sum inject(0.0) { |result, el| result + el } end def mean sum / size end end
a = [0,4,8,2,5,0,2,6] a.instance_eval { reduce(:+) / size.to_f }
values = [0,4,8,2,5,0,2,6] average = values.sum / values.size.to_f
a = 0, 4, 8, 2, 5, 0, 2, 6 a.reduce [ 0.0, 0 ] do |(s, c), e| [ s + e, c + 1 ] end.reduce :/
a = [1,2,3,4,5,6,7,8] a.reduce(:+).try(:to_f).try(:/,a.size) a = [] a.reduce(:+).try(:to_f).try(:/,a.size)
class Object;def try(*options);self&&send(*options);end;end class Array;def avg;reduce(:+).try(:to_f).try(:/,size);end;end
class Array;def avg;reduce(0.0,:+).try(:/,size);end;end
array = (1..10_000_000).to_a Benchmark.bm do |bm| bm.report { array.instance_eval { reduce(:+) / size.to_f } } bm.report { array.sum.fdiv(array.size) } bm.report { array.sum / array.size.to_f } bm.report { array.reduce(:+).to_f / array.size } bm.report { array.reduce(:+).try(:to_f).try(:/, array.size) } bm.report { array.inject(0.0) { |sum, el| sum + el }.to_f / array.size } bm.report { array.reduce([ 0.0, 0 ]) { |(s, c), e| [ s + e, c + 1 ] }.reduce(:/) } end user system total real 0.480000 0.000000 0.480000 (0.473920) 0.500000 0.000000 0.500000 (0.502158) 0.500000 0.000000 0.500000 (0.508075) 0.510000 0.000000 0.510000 (0.512600) 0.520000 0.000000 0.520000 (0.516096) 0.760000 0.000000 0.760000 (0.767743) 1.530000 0.000000 1.530000 (1.534404)
array = Array.new(10) { rand(0.5..2.0) } Benchmark.bm do |bm| bm.report { 1_000_000.times { array.reduce(:+).to_f / array.size } } bm.report { 1_000_000.times { array.sum / array.size.to_f } } bm.report { 1_000_000.times { array.sum.fdiv(array.size) } } bm.report { 1_000_000.times { array.inject(0.0) { |sum, el| sum + el }.to_f / array.size } } bm.report { 1_000_000.times { array.instance_eval { reduce(:+) / size.to_f } } } bm.report { 1_000_000.times { array.reduce(:+).try(:to_f).try(:/, array.size) } } bm.report { 1_000_000.times { array.reduce([ 0.0, 0 ]) { |(s, c), e| [ s + e, c + 1 ] }.reduce(:/) } } end user system total real 0.760000 0.000000 0.760000 (0.760353) 0.870000 0.000000 0.870000 (0.876087) 0.900000 0.000000 0.900000 (0.901102) 0.920000 0.000000 0.920000 (0.920888) 0.950000 0.000000 0.950000 (0.952842) 1.690000 0.000000 1.690000 (1.694117) 1.840000 0.010000 1.850000 (1.845623)
class Array def sum inject( nil ) { |sum,x| sum ? sum+x : x } end def mean sum.to_f / size.to_f end end [0,4,8,2,5,0,2,6].mean
arr = [5, 6, 7, 8] arr.inject{ |sum, el| sum + el }.to_f / arr.size => 6.5
[5, 6, 7, 8].inject([0.0,0]) do |r,ele| [ r[0]+ele, r[1]+1 ] end.inject(:/) => 6.5
[5, 6, 7, 8].inject([0.0,0]) do |(sum, size), ele| [ sum + ele, size + 1 ] end.inject(:/)
[5, 6, 7, 8].inject([0.0,0]) do |(sum, size), ele| r2 = [ sum + ele, size + 1 ] puts "adding r2 end.inject(:/) adding 5 gives [5.0, 1] adding 6 gives [11.0, 2] adding 7 gives [18.0, 3] adding 8 gives [26.0, 4] => 6.5
R=Struct.new(:sum, :count) [5, 6, 7, 8].inject( R.new(0.0, 0) ) do |r,ele| r.sum += ele r.count += 1 r end.inject(:/)
values = [0,4,8,2,5,0,2,6] total = 0.0 values.each do |val| total += val end average = total/values.size
a = [0,4,8,2,5,0,2,6] sum = 0 a.each { |b| sum += b } average = sum / a.length
a = [0,4,8,2,5,0,2,6] a.empty? ? nil : a.reduce(:+)/a.size.to_f => 3.375
a = [0,4,8,2,5,0,2,6] a.empty? ? nil : [a.reduce(:+), a.size.to_f].reduce(:/) => 3.375
2.0.0-p648 :009 > a = [1,2,3,4,5] => [1, 2, 3, 4, 5] 2.0.0-p648 :010 > (a.sum/a.length).to_f => 3.0
[1,2].tap { |a| @asize = a.size }.inject(:+).to_f/@asize
irb> ("abc" =~ %r"abc") == 0 => true irb> ("aabc" =~ %r"abc") == 0 => false
(1..100).each do |i| binding.pry if i == 1 puts i end
class ApplicationController < ActionController::Base before_action :reenable_pry private def reenable_pry ENV[ end end
42: def test 43: 3.times do |i| => 44: binding.pry 45: puts i 46: end 47: puts :finish 48: end [1] pry(main)> f 0 1 2 Frame: 0/1 method From: playground/sand.rb:47 main 42: def test 43: 3.times do |i| 44: binding.pry 45: puts i 46: end => 47: puts :finish 48: end
$ gem cleanup Cleaning up installed gems... Attempting to uninstall builder-3.2.2 Successfully uninstalled builder-3.2.2 Attempting to uninstall amatch-0.3.0 Successfully uninstalled amatch-0.3.0 Attempting to uninstall tins-1.12.0 Successfully uninstalled tins-1.12.0 Clean Up Complete
<%= number_with_precision(@number, :precision => 2, :delimiter =>
number_with_delimiter(98765432.98, :delimiter => ",", :separator => ".")
number_with_delimiter(2444323.4) helper.number_with_delimiter(233423)
ActiveSupport::NumberHelper.number_to_delimited(1000000)
parts = number.to_s.split( parts[0].gsub!(/(\d)(?=(\d\d\d)+(?!\d))/, "\\1,") parts.join(
require 12345.to_s(:delimited) 12345.6789.to_s(:delimited)
function numberWithDelimiter(value) { return (value+"").split("").reverse().join("").replace(/(\d{3})(?=\d)/g, }
def add_commas(numstring) correct_idxs = (1..100).to_a.select{|n| n % 6 == 0}.map{|n| n - 1} numstring.reverse.chars.join(",").chars.select.with_index{|x, i| i.even? || correct_idxs.include?(i)}.join.reverse end
root = ::File.dirname(__FILE__) require ::File.join( root, run MyApp.new
require require class MyApp < Sinatra::Application enable :sessions configure :production do set :haml, { :ugly=>true } set :clean_trace, true end configure :development do end helpers do include Rack::Utils alias_method :h, :escape_html end end require_relative require_relative require_relative
require_relative MyApp.helpers PartialPartials require_relative MyApp.helpers NiceBytes
module PartialPartials def spoof_request(uri,env_modifications={}) call(env.merge("PATH_INFO" => uri).merge(env_modifications)).last.join end def partial( page, variables={} ) haml page, {layout:false}, variables end end
module NiceBytes K = 2.0**10 M = 2.0**20 G = 2.0**30 T = 2.0**40 def nice_bytes( bytes, max_digits=3 ) value, suffix, precision = case bytes when 0...K [ bytes, else value, suffix = case bytes when K...M then [ bytes / K, when M...G then [ bytes / M, when G...T then [ bytes / G, else [ bytes / T, end used_digits = case value when 0...10 then 1 when 10...100 then 2 when 100...1000 then 3 else 4 end leftover_digits = max_digits - used_digits [ value, suffix, leftover_digits > 0 ? leftover_digits : 0 ] end "%. end module_function :nice_bytes end
require DB = Sequel.postgres DB << "SET CLIENT_ENCODING TO require_relative
class MyApp < Sinatra::Application get "/login" do @title = "Login" haml :login end post "/login" do if user = check_login session[ :user ] = user.pk redirect else redirect end end get "/logout" do session[:user] = session[:pass] = nil redirect end end
class MyApp < Sinatra::Application get "/" do @title = "Welcome to MyApp" haml :main end end
!!! XML !!! 1.1 %html(xmlns="http: %head %title= @title %link(rel="icon" type="image/png" href="/favicon.png") %meta(http-equiv="X-UA-Compatible" content="IE=8") %meta(http-equiv="Content-Script-Type" content="text/javascript" ) %meta(http-equiv="Content-Style-Type" content="text/css" ) %meta(http-equiv="Content-Type" content="text/html; charset=utf-8" ) %meta(http-equiv="expires" content="0" ) %meta(name="author" content="MeWho") %body{id:@action} %h1= @title
Dir[root_path("app/**/*.rb")].each do |file| require file end
require "sinatra" require "sinatra/namespace" if [ENV["LOGNAME"], ENV["USER"]] == [nil, "naki"] require "sinatra/reloader" register Sinatra::Reloader set :port, 8719 else set :environment, :production end for server in Dir.glob "server_*.rb" require_relative server end get "/" do "this route is useless" end
module SomeProject def self.foo bar ... end ... end namespace "/someproject" do set :views, settings.root get "" do redirect request.env["REQUEST_PATH"] + "/" end get "/" do haml :view_someproject end post "/foo" do ... SomeProject.foo ... end end
require module Sinatra module Sample module Helpers def require_logged_in() redirect( end end end end
require module Sinatra module Sample module Routing module Foos def self.registered(app) app.get require_logged_in erb :foos_view, :locals => { :foo => some_loaded_foo } end end end end end end
require require_relative class SampleApp < Sinatra::Base helpers Sinatra::Sample::Helpers register Sinatra::Sample::Routing::Foos end
<% @images.each_with_index do |page, index| %> <% end %>
<% @images.each.with_index do |page, index| %> <% end %>
@collection.each do |item| end for item in @collection end
irb> [1,2,3].each { |x| } => [1, 2, 3] irb> x NameError: undefined local variable or method `x from (irb):2 from :0
irb> for x in [1,2,3]; end => [1, 2, 3] irb> x => 3
number = ["one", "two", "three"] => ["one", "two", "three"] loop1 = [] loop2 = [] number.each do |c| loop1 << Proc.new { puts c } end => ["one", "two", "three"] for c in number loop2 << Proc.new { puts c } end => ["one", "two", "three"] loop1[1].call two => nil loop2[1].call three => nil
$ irb >> for x in nil >> puts x >> end NoMethodError: undefined method `each from (irb):1 >> nil.each {|x| puts x} NoMethodError: undefined method `each from (irb):4
class Library def initialize @ary = [] end def method_with_block(&block) @ary << block end def method_that_uses_these_blocks @ary.map(&:call) end end lib = Library.new for n in %w{foo bar quz} lib.method_with_block { n } end puts lib.method_that_uses_these_blocks
irb(main):014:0* Benchmark.bm do |x| irb(main):015:1* x.report( irb(main):016:1> x.report( irb(main):017:1> end user system total real sample 3.870000 0.020000 3.890000 ( 3.888147) rand 0.150000 0.000000 0.150000 ( 0.153557)
--- javascripts: - fo_global: - lazyload-min - holla-min
@custom_asset_packages_yml = (File.exists?(" if !@custom_asset_packages_yml.nil? @custom_asset_packages_yml[ js[ script } } end
You have a nil object when you didn You might have expected an instance of Array. The error occurred while evaluating nil.each
if !@custom_asset_packages_yml.nil? @custom_asset_packages_yml[ js[ } end
{"javascripts"=>[{"fo_global"=>["lazyload-min", "holla-min"]}]}
if (md = contents.match(/^(?<metadata>---\s*\n.*?\n?)^(---\s*$\n?)/m)) self.contents = md.post_match self.metadata = YAML.load(md[:metadata]) end
h0 = { "John"=>"Adams","Thomas"=>"Jefferson","Johny"=>"Appleseed"} h1=Hash.new(h0) h2=h1.to_hash
def copyhash(inputhash) h = Hash.new inputhash.each do |pair| h.store(pair[0], pair[1]) end return h end
irb(main):003:0> h0 = {"John" => "Adams", "Thomas" => "Jefferson"} => {"John"=>"Adams", "Thomas"=>"Jefferson"} irb(main):004:0> h1 = h0.clone => {"John"=>"Adams", "Thomas"=>"Jefferson"} irb(main):005:0> h1["John"] = "Smith" => "Smith" irb(main):006:0> h1 => {"John"=>"Smith", "Thomas"=>"Jefferson"} irb(main):007:0> h0 => {"John"=>"Adams", "Thomas"=>"Jefferson"}
def deep_copy(o) Marshal.load(Marshal.dump(o)) end h1 = {:a => h2 = deep_copy(h1) h1[:a] << p h2
irb(main):009:0> h1 = {1 => 2} => {1=>2} irb(main):010:0> h2 = Hash[h1] => {1=>2} irb(main):011:0> h1.object_id => 2150233660 irb(main):012:0> h2.object_id => 2150205060
copy_of_original_hash = Hash.new.merge(original_hash)
require "json" original = {"John"=>"Adams","Thomas"=>"Jefferson","Johny"=>"Appleseed"} cloned = JSON.parse(JSON.generate(original)) original["John"] << p original p cloned
deeply_copied_hash = Marshal.load(Marshal.dump(original_hash))
require def bench Benchmark.bm do |b| test = { b.report 1_000_000.times do |i| h = test.clone h[ end end b.report 1_000_000.times do |i| h = {} h[ h.merge! test end end b.report 1_000_000.times do |i| h = test.inject({}) do |n, (k, v)| n[k] = v; n end h[ end end end end
h0 = { "John"=>"Adams","Thomas"=>"Jefferson","Johny"=>"Appleseed"} h1 = h0.inject({}) do |new, (name, value)| new[name] = value; new end
def johns { "John"=>"Adams","Thomas"=>"Jefferson","Johny"=>"Appleseed"} end h1 = johns
require module ProcessUtils def execute_and_handle(command, outhandler, errhandler) Open3.popen3(command) do |_, stdout, stderr| if (outhandler) outhandler.call(stdout) end if (errhandler) errhandler.call(stderr) end end end end
: jmglov@laurana; sudo gem install htmlentities Successfully installed htmlentities-4.2.4 : jmglov@laurana; irb irb(main):001:0> require => [] irb(main):002:0> HTMLEntities.new.decode "&iexcl;I& => "¡I
CGI.unescapeHTML("test &quot;unescaping&quot; &lt;characters&gt;")
a = Nokogiri::HTML.parse "foo&nbsp;b&auml;r" a.text => "foo bär"
<% str="<h1> Test </h1>" %> result: &lt; h1 &gt; Test &lt; /h1 &gt; <%= CGI.unescapeHTML(str).html_safe %>
ERROR: Error installing JSON: The Please update your PATH to include build tools or download the DevKit from at
[INFO] RubyGems override already in place for C:/Ruby192, skipping. [INFO] Installing C:/Ruby192/lib/ruby/site_ruby/devkit.rb
gem install json --platform=ruby ruby -rubygems -e "require
C:\RubyDev>devkitvars.bat Adding the DevKit to PATH...
module Kernel private def this_method_name caller[0] =~ /`([^ end end class Foo def test_method this_method_name end end puts Foo.new.test_method
require puts RUBY_VERSION class Foo def orig {callee: __callee__, method: __method__} end alias_method :myalias, :orig end pp( {call_orig: Foo.new.orig, call_alias: Foo.new.myalias} )
1.9.3 {:call_orig=>{:callee=>:orig, :method=>:orig}, :call_alias=>{:callee=>:orig, :method=>:orig}}
2.1.2 {:call_orig=>{:callee=>:orig, :method=>:orig}, :call_alias=>{:callee=>:myalias, :method=>:orig}}
params = { :irrelevant => "A String", :choice1 => "Oh look, another one", :choice2 => "Even more strings", :choice3 => "But wait", :irrelevant2 => "The last string" }
> { one: 1, two: 2, three: 3 }.slice(:one, :two) => {:one=>1, :two=>2}
choices = params.select { |key, value| key.to_s.match(/^choice\d+/) }
params.delete_if { |key, value| !key.to_s.match(/choice\d+/) }
params.keys.select { |key| key.to_s.match(/^choice\d+/) }
h1 = {:a => 1, :b => 2, :c => 3, :d => 4} h1.slice(:a, :b) h2 = h1.slice!(:a, :b)
keys = [:foo, :bar] hash1 = {foo: 1, bar:2, baz: 3} hash2 = hash1.slice(*keys) => {foo: 1, bar:2}
data = {} matcher = ->(key,value) { COMPLEX LOGIC HERE } data.select(&matcher)
def some_method(hash, matcher) hash.select(&matcher).values.join( end params = { :irrelevant => "A String", :choice1 => "Oh look, another one", :choice2 => "Even more strings", :choice3 => "But wait", :irrelevant2 => "The last string" } some_method(params, ->(k,_) { k[/choice/]}) some_method(params, ->(_,v) { v[/string/]})
class Hash def filter(*args) return nil if args.try(:empty?) if args.size == 1 args[0] = args[0].to_s if args[0].is_a?(Symbol) self.select {|key| key.to_s.match(args.first) } else self.select {|key| args.include?(key)} end end end
params = params.select { |key, value| /^choice\d+$/.match(key.to_s) }
params.delete_if {|k, v| ! k.match(/choice[0-9]+/)}
params.keys.delete_if {|k| ! k.match(/choice[0-9]+/)}
params.select{ |k,v| k =~ /choice\d/ }.map{ |k,v| v}.join("\t")
[[:choice1, "Oh look, another one"], [:choice2, "Even more strings"], [:choice3, "But wait"]]
filtered_params.join("\t") filtered_params.map(&:last).join("\t")
{:choice1=>"Oh look, another one", :choice2=>"Even more strings", :choice3=>"But wait"}
filtered_params.to_a.join("\t") filtered_params.values.join("\t")
params = { :irrelevant => "A String", :choice1 => "Oh look, another one", :choice2 => "Even more strings", :choice3 => "But wait", :irrelevant2 => "The last string" } choices = params.select { |key, value| key.to_s[/^choice\d+/] }
sudo gem install fakes3 ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/fakes3
mkdir -p $HOME/Software/ruby export GEM_HOME=$HOME/Software/ruby gem install cocoapods [...] 1 gem installed gem install fakes3 ERROR: While executing gem ... (Gem::FilePermissionError) You don
sudo gem install -n /usr/local/bin fakes3 sudo gem install -n /usr/local/bin compass sudo gem install -n /usr/local/bin susy
$ gem list | grep capistrano capistrano (3.4.0, 3.2.1, 2.14.2) $ sudo gem install capistrano -v 3.4.0
if which ruby >/dev/null && which gem >/dev/null; then PATH="$(ruby -rubygems -e fi
sudo gem install -n /usr/local/bin <gem_name> -- --use-system-libraries --with-xml2-include=/usr/include/libxml2 --with-xml2-lib=/usr/lib/
sudo gem install -n /usr/local/bin nokogiri -- --use-system-libraries --with-xml2-include=/usr/include/libxml2 --with-xml2-lib=/usr/lib/
xcode-select: error: command line tools are already installed, use "Software Update" to install updates
/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb
def clear system("cls") || system("clear") || puts("\e[H\e[2J") end clear
def cls puts "\ec\e[3J" end def clear puts "\e[H\e[2Js" end
->(a,b,c){x=a.method(b);a.send(c,b){send c,b,&x;false};print"\e[2J\e[H \e[D"}[irb_context,:echo?,:define_singleton_method]
lambda { original_echo = irb_context.method(:echo?) irb_context.send(:define_singleton_method, :echo?) { send :define_singleton_method, :echo?, &original_echo false } print "\e[2J\e[H \e[D" }.call
customerName == "Fred" ? "Hello Fred" : "Who are you?"
irb(main):001:0> test ?d, "/dev" => true irb(main):002:0> test ?-, "/etc/hosts", "/etc/hosts" => true
class MyModel < ActiveRecord::Base has_attached_file :image, ... end
@my_model = MyModel.new image_url = params[:image_url] @my_model.image = URI.parse(image_url)
irb>> a = [ 0, 1, 2] => [0, 1, 2] irb>> a.unshift( => ["x", 0, 1, 2] irb>> a.inspect => "["x", 0, 1, 2]"
array = ["foo"] array.unshift "bar" array => ["bar", "foo"]
require solve { a = [1,2,3]; a.____(0) == [0,1,2,3] }
a = ["item 1", "item 2", "item 3", "item 4"] h = a.to_h
a = ["item 1", "item 2", "item 3", "item 4"] h = Hash[*a]
[[1, 2], [3, 4]].inject({}) do |r, s| r.merge!({s[0] => s[1]}) end
a = ["item 1", "item 2", "item 3", "item 4"] a.each_slice(2).to_h
irb(main):019:0> a = ["item 1", "item 2", "item 3", "item 4"] => ["item 1", "item 2", "item 3", "item 4"] irb(main):020:0> Hash[*a] => {"item 1"=>"item 2", "item 3"=>"item 4"}
irb(main):022:0> a = [[1, 2], [3, 4]] => [[1, 2], [3, 4]] irb(main):023:0> Hash[*a.flatten] => {1=>2, 3=>4}
a = ["item 1", "item 2", "item 3", "item 4"] Hash[ a.each_slice( 2 ).map { |e| e } ]
a.each_slice( 2 ).each_with_object Hash.new do |(k, v), h| h[k] = v end
h = a.lazy.each_slice( 2 ).tap { |a| break Hash.new { |h, k| h[k] = a.find { |e, _| e == k }[1] } } h["item 1"] h["item 3"]
class Image < ActiveRecord::Base belongs_to :product, counter_cache: true end class Product < ActiveRecord::Base has_many :images end > product = Product.first > product.images.size > product.images.count > product.images.length
Model.count Model.all.size records = Model.all records.count
> foo 10 => [10, [], {}] > foo 10, 20, 30 => [10, [20, 30], {}] > foo 10, 20, 30, d: 40, e: 50 => [10, [20, 30], {:d=>40, :e=>50}] > foo 10, d: 40, e: 50 => [10, [], {:d=>40, :e=>50}]
def my_method(**options) puts options.inspect end my_method(key: "value")
def cycle(first_value, *values) options = values.extract_options! end
def foo(opts); p opts end bar = {a:1, b:2} foo(bar, c: 3) => ArgumentError: wrong number of arguments (given 2, expected 1) foo(**bar, c: 3) => {:a=>1, :b=>2, :c=>3}
clients = { "yellow"=>{"client_id"=>"2178"}, "orange"=>{"client_id"=>"2180"}, "red"=>{"client_id"=>"2179"}, "blue"=>{"client_id"=>"2181"} }
clients.select{|key, hash| hash["client_id"] == "2180" }
clients.find{|key,value| value["client_id"] == "2178"}.first
ROLE = {"customer" => 1, "designer" => 2, "admin" => 100} ROLE.key(2)
(1..10).detect {|i| i % 5 == 0 and i % 7 == 0 } (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }
clients.detect{|client| client.last[ clients.detect{|client| client.last[
gender = {"MALE" => 1, "FEMALE" => 2} gender.key(1)
clients.map{ |key, _| key if clients[key] == {"client_id"=>"2180"} }.compact
clients = { "yellow"=>{"client_id"=>"2178"}, "orange"=>{"client_id"=>"2180"}, "red"=>{"client_id"=>"2179"}, "blue"=>{"client_id"=>"2181"} } p clients.rassoc("client_id"=>"2180")
sergio@sergio-VirtualBox:~$ rvm list rvm rubies ruby-1.9.3 [ i386 ] sergio@sergio-VirtualBox:~$ rvm use 1.9.3 Using /usr/share/ruby-rvm/gems/ruby-1.9.3 sergio@sergio-VirtualBox:~$ ruby -v The program * ruby1.8 * ruby1.9.1 Try: sudo apt-get install <selected package>
sudo apt-get --purge remove ruby-rvm sudo rm -rf /usr/share/ruby-rvm /etc/rvmrc /etc/profile.d/rvm.sh
\curl -L https: bash -s stable --ruby --autolibs=enable --auto-dotfiles
> ruby -v ruby 2.0.0p481 > rvm list rvm rubies ruby-2.1.2 [ x86_64 ] =* ruby-2.2.1 [ x86_64 ] ruby-2.2.3 [ x86_64 ]
> rvm current Warning! PATH is not properly set up,
class Person def initialize(age) @age = age end def age @age end def age_difference_with(other_person) (self.age - other_person.age).abs end protected :age end
class Node < Struct.new(:value) def initialize(value) @value = value end def show() p @value p self.value end end n = Node.new(30) n.show()
class Node2 attr_accessor :value def initialize(value) @value = value end def show() p @value p self.value end end
class CrazyAccessors def bar=(val) @bar = val - 20 end def bar @bar end def baz=(value) self.bar = value end def quux=(value) @bar = value end end obj = CrazyAccessors.new obj.baz = 50 obj.bar obj.quux = 50 obj.bar
irb> 1..4.to_a (irb):1: warning: default `to_a ArgumentError: bad value for range from (irb):1
irb(main):007:0> Array(1..5) => [1, 2, 3, 4, 5] irb(main):008:0> Array(5..1) => []
require require REP = 100000 User = Struct.new(:name, :age) USER = "User".freeze AGE = 21 HASH = {:name => USER, :age => AGE}.freeze Benchmark.bm 20 do |x| x.report REP.times do |index| OpenStruct.new(:name => "User", :age => 21) end end x.report REP.times do |index| OpenStruct.new(HASH) end end x.report REP.times do |index| User.new("User", 21) end end x.report REP.times do |index| User.new(USER, AGE) end end end
user system total real OpenStruct slow 4.430000 0.250000 4.680000 ( 4.683851) OpenStruct fast 4.380000 0.270000 4.650000 ( 4.649809) Struct slow 0.090000 0.000000 0.090000 ( 0.094136) Struct fast 0.080000 0.000000 0.080000 ( 0.078940)
start = Time.now collection = (1..10**6).collect do |i| {:name => "User" , :age => 21} end; 1 stop = Time.now puts "
Newtype = Struct.new(:data1, :data2) n = Newtype.new
typedef struct { int data1; char data2; } newtype; newtype n;
o = OpenStruct.new(data1: 0, data2: 0) o.data1 = 1 o.data2 = 2
struct { int data1; char data2; } o; o.data1 = 1; o.data2 = 2;
h = { a: 1, b: 2 } o = OpenStruct.new(h) o.a = 1 o.b = 2
class MyClass < Struct.new(:a,:b,:c) end m = MyClass.new m.a = 1
require collection = (1..100000).collect do |index| OpenStruct.new(:name => "User", :age => 21) end
User = Struct.new(:name, :age) collection = (1..100000).collect do |index| User.new("User",21) end
>> s = Struct.new(:a, :b).new(1, 2) => >> s.a => 1 >> s.b => 2 >> s.c NoMethodError: undefined method `c` for
>> require => true >> os = OpenStruct.new(a: 1, b: 2) => >> os.a => 1 >> os.b => 2 >> os.c => nil
user system total real Hashie::Mash slow 3.600000 0.000000 3.600000 ( 3.755142) Hashie::Mash fast 3.000000 0.000000 3.000000 ( 3.318067) OpenStruct slow 11.200000 0.010000 11.210000 ( 12.095004) OpenStruct fast 10.900000 0.000000 10.900000 ( 12.669553) Struct slow 0.370000 0.000000 0.370000 ( 0.470550) Struct fast 0.140000 0.000000 0.140000 ( 0.145161)
@title = tokens[Title].strip! || tokens[Title] if !tokens[Title].nil?
>> @title = "abc" => "abc" >> @title.strip! => nil >> @title => "abc" >> @title = " abc " => " abc " >> @title.strip! => "abc" >> @title => "abc"
p "abc".strip! == " abc ".strip! p "abc".strip == " abc ".strip
static VALUE rb_str_strip(VALUE str) { str = rb_str_dup(str); rb_str_strip_bang(str); return str; }
@title = strip_or_self!(tokens[Title]) if tokens[Title]
def strip_or_self!(str) str.strip! || str if str end
class String def strip_or_self! strip! || self end end
@title = tokens[Title].strip_or_self! if tokens[Title] @title = tokens[Title] && tokens[Title].strip_or_self!
> @title = " abc " => " abc " > @title.squish => "abc" > @title => " abc " > @title.squish! => "abc" > @title => "abc"
> tokens["Title"] = " abc " => " abc " > tokens["Title"].strip! => "abc" > @title = tokens["Title"] => "abc"
> tokens["Title"] = " abc " => " abc " > @title = tokens["Title"].strip if tokens["Title"].present? => "abc"
@title = tokens[Title].strip! || tokens[Title] if tokens[Title]
> (@title = " abc ").strip! => "abc" > @title => "abc"
" success ".strip! || "rescue" "failure".strip! || "rescue"
u = User.find_by_name( u.usage_indexes.destroy_all u.sources.destroy_all u.user_stats.destroy_all u.delete
u = User.find_by_name( UsageIndex.destroy_all "user_id =
class String def remove(s) self[s.length, self.length - s.length] end end
asdf = asdf[ asdf asdf = asdf.sub( asdf = asdf + asdf asdf.gsub(
def remove!(*patterns) patterns.each do |pattern| gsub! pattern, "" end self end
module MinusString refine String do def -(str) partition(str).values_at(0,2).join end end end
2.2.1 :015 > class String; def remove!(start_index, end_index) (end_index - start_index + 1).times{ self.slice! start_index }; self end; end; 2.2.1 :016 > "idliketodeleteHEREallthewaytoHEREplease".remove! 14, 32 => "idliketodeleteplease" 2.2.1 :017 > ":)".remove! 1,1 => ":" 2.2.1 :018 > "ohnoe!".remove! 2,4 => "oh!"
class String def remove!(start_index, end_index) (end_index - start_index + 1).times{ self.slice! start_index } self end end
def replaceslug slug = "" + name @replacements = [ [ "," , ""], [ "\\?" , ""], [ " " , "-"], [ " [ "Ç" , "c"], [ "Ş" , "s"], [ "İ" , "i"], [ "I" , "i"], [ "Ü" , "u"], [ "Ö" , "o"], [ "Ğ" , "g"], [ "ç" , "c"], [ "ş" , "s"], [ "ı" , "i"], [ "ü" , "u"], [ "ö" , "o"], [ "ğ" , "g"], ] @replacements.each do |pair| slug.gsub!(pair[0], pair[1]) end self.slug = slug.downcase end
class Person < Contact def self.model_name Contact.model_name end end
resources :structures resources :buildings, :controller => resources :bridges, :controller =>
<% form_for(@structure, :as => :structure) do |f| %>
class Person < Contact model_name.class_eval do def route_key "contacts" end def singular_route_key superclass.model_name.singular_route_key end end end
module ActsAsCastable extend ActiveSupport::Concern module ClassMethods def new_with_cast(*args, &block) if (attrs = args.first).is_a?(Hash) if klass = descendant_class_from_attrs(attrs) return klass.new(*args, &block) end end new_without_cast(*args, &block) end def descendant_class_from_attrs(attrs) subclass_name = attrs.with_indifferent_access[inheritance_column] return nil if subclass_name.blank? || subclass_name == self.name unless subclass = descendants.detect { |sub| sub.name == subclass_name } raise ActiveRecord::SubclassNotFound.new("Invalid single-table inheritance type: end subclass end def acts_as_castable class << self alias_method_chain :new, :cast end end end end ActiveRecord::Base.send(:include, ActsAsCastable)
class Contact < ActiveRecord::Base acts_as_castable end require_dependency require_dependency
resources :person, :controller => resources :organisation, :controller =>
simple_form_for resource, as: resource_request_name, url: collection_url, html: { class: controller_name, multipart: true }
simple_form_for resource, as: resource_request_name, url: resource_url, html: { class: controller_name, multipart: true }
class ResourceController < ApplicationController protected helper_method :resource helper_method :resource_url helper_method :collection_url helper_method :resource_request_name def resource @model end def resource_url polymorphic_path(@model) end def collection_url polymorphic_path(Model) end def resource_request_name ActiveModel::Naming.param_key(Model) end end
class KasesController < ApplicationController def new setup_sti_model end def create setup_sti_model end private def setup_sti_model model = nil if !params[:kase].blank? and !params[:kase][:type].blank? model = params[:kase].delete(:type).constantize.to_s end @kase = Kase.new(params[:kase]) @kase.type = model end end class Kase < ActiveRecord::Base def self.inherited(child) child.instance_eval do def model_name Kase.model_name end end super end end class AlphaKase < Kase; end class BetaKase < Kase; end if Rails.env.development? %w[kase alpha_kase beta_kase].each do |c| require_dependency File.join("app","models"," end end
resources :employee, path: :person, controller: :person
resources :districts resources :district_counties, controller: resources :district_cities, controller:
= form_for(@district, as: :district, html: { class: "form-horizontal", role: "form" }) do |f|
class AModel < ActiveRecord::Base ; end class BModel < AModel ; end class CModel < AModel ; end class DModel < AModel ; end class EModel < AModel ; end
module ManagedAtAModelLevel def model_name AModel.model_name end end
class AModel < ActiveRecord::Base def self.instanciate_STI managed_deps = { :b_model => true, :c_model => true, :d_model => true, :e_model => true } managed_deps.each do |dep, managed| require_dependency dep.to_s klass = dep.to_s.camelize.constantize klass.send(:extend, ManagedAtAModelLevel) if managed end end instanciate_STI end
def self.inherited(child) child.instance_eval do alias :original_model_name :model_name def model_name Task::Base.model_name end end super end
class Parent < ActiveRecord::Base; end Class Child < Parent def class Parent end end
>> time = Time.new => Fri Oct 03 01:24:48 +0100 2008 >> time.strftime("%a %b => "Fri Oct 3rd"
>> 3.ordinalize => "3rd" >> 2.ordinalize => "2nd" >> 1.ordinalize => "1st"
Time::DATE_FORMATS.merge!( my_date: lambda { |time| time.strftime("%a, %b )
Time::DATE_FORMATS.merge!( datetime_military: datetime: time: time_military: datetime_short: due_date: lambda { |time| time.strftime("%a, %b )
>> require => [] >> t = Time.now => Thu Oct 02 17:28:37 -0700 2008 >> formatted = " => "Thu Oct 2nd"
d = DateTime.now Time::DATE_FORMATS[:weekday_month_ordinal] = lambda { |time| time.strftime("%a %b d.to_formatted_s :weekday_month_ordinal
class DateTime Time::DATE_FORMATS[:weekday_month_ordinal] = lambda { |time| time.strftime("%a %b def to_my_special_s to_formatted_s :weekday_month_ordinal end end DateTime.now.to_my_special_s
Time.new( 2018, 10, 2 ).strftime( "%a %b %o" ) => "Tue Oct 2nd"
DateTime.new( 2018, 10, 2 ).strftime( "%a %b %o" ) => "Tue Oct %o"
PATH remote: . specs: gem_one (0.0.1) GEM remote: http: specs: gem_two (0.0.2) gem_three (0.0.3) gem_four (0.0.4) PLATFORMS platform DEPENDENCIES gem_two gem_one!
gem "foo", :git => "git@github.com:company/foo.git"
Runtime dependencies in your gemspec are treated like base dependencies, and development dependencies are added by default to the group, :development
if (defined? params[:one]) && (defined? params[:two]) ... do something ... elsif (defined? params[:one]) ... do something ... end
unless params[:one].to_s.blank? && params[:two].to_s.blank?
required = [:one, :two, :three] if required.all? {|k| params.has_key? k} else ... end
if !params[:one].nil? and !params[:two].nil? elsif !params[:one].nil? elsif !params[:two].nil? end
if params[:one] && params[:two] ... do something ... elsif params[:one] ... do something ... end
unless params.values_at(:one, :two, :three, :four).includes?(nil) ... excute code .. end
some_hash = {x:3, y:5} some_hash.values_at(:x, :random, :y}
params.delete_if{|key,value| value.blank?} unless params.values_at(:one, :two, :three, :four).includes?(nil) ... excute code .. end
def check_presence params[:param1].present? && params[:param2].present? end def validate_presence if !check_presence render json: { error: { message: "Bad Request, parameters missing.", status: 500 } } end end
if params[:one] && param[:two] ... excute code .. end
before_filter :validate_params private def validate_params return head :bad_request unless params_present? end def params_present? Set.new(%w(one two three)) <= (Set.new(params.keys)) && params.values.all? end
if params.key?(:one) && params.key?(:two) ... do something ... elsif params.key?(:one) ... do something ... end
2.3.3 :016 > a = {first: 1, second: nil, third: => {:first=>1, :second=>nil, :third=>""} 2.3.3 :017 > puts " true, true, true, false
class A end class B < A end B.is_a? A => false B.superclass == A => true
class Class def is_subclass_of?(clazz) return true if superclass == clazz return false if self == Object superclass.is_subclass_of?(clazz) end end
if @item.rigged then if @item.rigged; if @item.rigged
irb(main):022:0> true && "Yes" || "No" => "Yes" irb(main):023:0> false && "Yes" || "No" => "No" irb(main):024:0> true ? "Yes" : "No" => "Yes" irb(main):025:0> false ? "Yes" : "No" => "No"
class S @@k = 23 @s = 15 def self.s @s end def self.k @@k end end p S.s p S.k
class Parent @things = [] def self.things @things end def things self.class.things end end class Child < Parent @things = [] end Parent.things << :car Child.things << :doll mom = Parent.new dad = Parent.new p Parent.things p Child.things p mom.things p dad.things
class Parent @@things = [] def self.things @@things end def things @@things end end class Child < Parent end Parent.things << :car Child.things << :doll p Parent.things p Child.things mom = Parent.new dad = Parent.new son1 = Child.new son2 = Child.new daughter = Child.new [ mom, dad, son1, son2, daughter ].each{ |person| p person.things }
class Parent @@family_things = [] @shared_things = [] def self.family_things @@family_things end def self.shared_things @shared_things end attr_accessor :my_things def initialize @my_things = [] end def family_things self.class.family_things end def shared_things self.class.shared_things end end class Child < Parent @shared_things = [] end
mama = Parent.new papa = Parent.new joey = Child.new suzy = Child.new Parent.family_things << :house papa.family_things << :vacuum mama.shared_things << :car papa.shared_things << :blender papa.my_things << :quadcopter joey.my_things << :bike suzy.my_things << :doll joey.shared_things << :puzzle suzy.shared_things << :blocks p Parent.family_things p Child.family_things p papa.family_things p mama.family_things p joey.family_things p suzy.family_things p Parent.shared_things p papa.shared_things p mama.shared_things p Child.shared_things p joey.shared_things p suzy.shared_things p papa.my_things p mama.my_things p joey.my_things p suzy.my_things
class T < S end p T.k => 23 S.k = 24 p T.k => 24 p T.s => nil
class Vars @class_ins_var = "class instance variable value" @@class_var = "class variable value" def self.class_method puts @class_ins_var puts @@class_var end def instance_method puts @class_ins_var puts @@class_var end end Vars.class_method puts "see the difference" obj = Vars.new obj.instance_method class VarsChild < Vars end VarsChild.class_method
class PortfolioController < ApplicationController before_action :set_portfolio_item, only: [:edit, :update, :show, :destroy] layout access all: [:show, :index, :angular], user: {except: [:destroy, :new, :create]} def index @portfolio_items = Portfolio.by_position end end
<%= form_for(@portfolio_item) do |f| %> <% if @portfolio_item.errors.any? %> <% @portfolio_item.errors.full_messages.each do |error| %> <% alert_generator error %> <% end %> <% end %>
def multiple_of(factor) Proc.new{|product| product.modulo(factor).zero?} end case number when multiple_of(3) puts "Multiple of 3" when multiple_of(7) puts "Multiple of 7" end
fruit = ["apple","red","banana","yellow"] => ["apple", "red", "banana", "yellow"] Hash[*fruit] => {"apple"=>"red", "banana"=>"yellow"}
match, text, number = *"Something 981".match(/([A-z]*) ([0-9]*)/)
a, b, c = *( Job = Struct.new(:name, :occupation) tom = Job.new("Tom", "Developer") name, occupation = *tom
1.upto(100) do |i| puts i if (i == 3)..(i == 15) end
class RandomSubclass < [Array, Hash, String, Fixnum, Float, TrueClass].sample end RandomSubclass.superclass
>> 1234567890.to_s(2) => "1001001100101100000001011010010" >> 1234567890.to_s(8) => "11145401322" >> 1234567890.to_s(16) => "499602d2" >> 1234567890.to_s(24) => "6b1230i" >> 1234567890.to_s(36) => "kf12oi"
parties = Hash.new {|hash, key| hash[key] = [] } parties["Summer party"] parties["Summer party"] << "Joe" parties["Other party"] << "Jane"
make golf ./goruby -e ./goruby -e ./goruby -e ./goruby19 -e "/home/manveru/pkgbuilds/ruby-svn/src/trunk"
it_is_day_of_week = lambda{ |day_of_week, date| date.wday == day_of_week } it_is_saturday = it_is_day_of_week.curry[6] it_is_sunday = it_is_day_of_week.curry[0] case Time.now when it_is_saturday puts "Saturday!" when it_is_sunday puts "Sunday!" else puts "Not the weekend" end
message = "My message" contrived_example = "<div id=\"contrived\">
contrived_example = %{<div id="contrived-example"> contrived_example = %[<div id="contrived-example">
sql = %{ SELECT strings FROM complicated_table WHERE complicated_condition = }
((0..9).each do |n| define_method "press_ @number = @number.to_i * 10 + n end end
module M def not! end module_function :not! end class C include M def fun not! end end M.not! C.new.fun C.new.not!
module M module_function def not! end def yea! end end class C include M def fun not! + end end M.not! M.yea! C.new.fun
a = [:x, :y, :z] b = [123, 456, 789] Hash[a.zip(b)]
def cnh Hash.new {|h,k| h[k] = Hash.new(&h.default_proc)} end my_hash = cnh my_hash[1][2][3] = 4 my_hash
class Wrapper attr_accessor :internal def self.forwards(*methods) methods.each do |method| define_method method do |*arguments, &block| internal.send method, *arguments, &block end end end forwards :to_i, :length, :split end w = Wrapper.new w.internal = "12 13 14" w.to_i w.length w.split(
case foo when /baz/ do_something_with_the_string_matching_baz when 12..15 do_something_with_the_integer_between_12_and_15 when lambda { |x| x % 5 == 0 } do_something_with_the_integer_that_is_a_multiple_of_5 when Bar do_something_with_the_instance_of_Bar when some_object do_something_with_the_thing_that_matches_some_object end
ruby -ne ruby -lne ruby -F, -ane ruby -ne ruby -pe ruby -p -e ruby -p -e ruby -i.bak -p -e
%w(7 8 9 / 4 5 6 * 1 2 3 - 0 Clr = +).each do |btn| button btn, :width => 46, :height => 46 do method = case btn when /[0-9]/: when when when when when when end number.send(method) number_field.replace strong(number) end end
$" << "test/spec" require File.join(File.dirname(__FILE__) + "/../bdrb_test_helper")
rand(36**8).to_s(36) => "fmhpjfao" rand(36**8).to_s(36) => "gcer9ecu" rand(36**8).to_s(36) => "krpm0h9r"
rand(36**6).to_s(36) => "bvhl8d" rand(36**6).to_s(36) => "lb7tis" rand(36**6).to_s(36) => "ibwgeh"
attr_accessible :attribute_name def attribute_name=(value) ... self[:attribute_name] = value end
attr_accessible :attribute_name def attribute_name=(value) ... self.attribute_name = value end
SystemStackError (stack level too deep): actionpack (3.2.2) lib/action_dispatch/middleware/reloader.rb:70
class Model < ActiveRecord::Base def attribute_name=(value) super(value) end end
class Model < ActiveRecord::Base attr_accessible :attribute_name def attribute_name=(value) write_attribute(:attribute_name, value) end end
class Person attr_accessor :name end class NewPerson < Person def name=(value) @name = value end end
def name @name end def name=(value) @name = value end
def attribute_name=(value) super(value.some_custom_encode) end
def age=(dob) now = Time.now.utc.to_date age = now.year - dob.year - ((now.month > dob.month || (now.month == dob.month && now.day >= dob.day)) ? 0 : 1) super(age) end
has_many :specialties def specialty_ids=(values) super values.uniq.first(3) end
line = "first_name=mickey;last_name=mouse;country=usa" record = Hash[*line.split(/=|;/)]
>> def func(a, b, c) >> puts a, b, c >> end => nil >> func(1, 2, 3) 1 2 3 => nil >> list = [1, 2, 3] => [1, 2, 3] >> func(list) ArgumentError: wrong number of arguments (1 for 3) from (irb):12:in from (irb):12 >> func(*list) 1 2 3 => nil
line = "first_name=mickey;last_name=mouse;country=usa" presplat = line.split(/=|;/) splat = Hash.new for i in (0..presplat.length-1) splat[presplat[i]] = presplat[i+1] if i%2==0 end puts splat["first_name"]
{"first_name"=>"mickey", "last_name"=>"mouse", "county"=>"usa"}
a = [5, 1, 6, 14, 2, 8] b = [2, 6, 15] a - b => [5, 1, 14, 8] b - a => [15] (b - a).empty? => false
a1 = Set.new [5, 1, 6, 14, 2, 8] a2 = Set.new [2, 6, 15] a1.subset?(a2) => false
def equal_a(a1, a2) a1sorted = a1.sort a2sorted = a2.sort return false if a1.length != a2.length 0.upto(a1.length - 1) do |i| return false if a1sorted[i] != a2sorted[i] end end
class Array def contains_all?(ary) ary.uniq.all? { |x| count(x) >= ary.count(x) } end end
irb(main):131:0> %w[a b c c].contains_all? %w[a b c] => true irb(main):132:0> %w[a b c c].contains_all? %w[a b c c] => true irb(main):133:0> %w[a b c c].contains_all? %w[a b c c c] => false irb(main):134:0> %w[a b c c].contains_all? %w[a] => true irb(main):135:0> %w[a b c c].contains_all? %w[x] => false irb(main):136:0> %w[a b c c].contains_all? %w[] => true irb(main):137:0> %w[a b c d].contains_all? %w[d c h] => false irb(main):138:0> %w[a b c d].contains_all? %w[d b c] => true
def contains_all?(a,b) b.uniq.all? { |x| a.count(x) >= b.count(x) } end
def contains_all?(a,b) b.all? { |x| a.count(x) >= b.count(x) } end
def contains_all?(a1, a2) try = a1.chars.all? do |letter| a1.count(letter) <= a2.count(letter) end return try end
let(:dummy_class) { Class.new { include ModuleToBeTested } }
let(:dummy_class) { Class.new { extend ModuleToBeTested } }
class DummyClass end before(:each) do @dummy_class = DummyClass.new @dummy_class.extend(Say) end it "get hello string" do expect(@dummy_class.hello).to eq "hello" end
describe MyModule do include MyModule it { hallo.should == "hallo" } end
shared_examples_for "all editions" do it "should behave like all editions" do end end
describe "SmallEdition" do it_should_behave_like "all editions" it "should also behave like a small edition" do end end
module Movable def self.movable_class? true end def has_feets? true end end class Person < ActiveRecord::Base include Movable end class Animal < ActiveRecord::Base include Movable end
shared_examples_for Movable do context before(:each) do @obj = described_class.new @obj = obj if obj.present? end it @obj.has_feets?.should be_true end end context it described_class.movable_class?.should be_true end end end describe Person do it_behaves_like Movable end describe Animal do it_behaves_like Movable do let(:obj) { Animal.new({ :name => end end
describe MyModule do subject { Object.new.extend(MyModule) } it "does stuff" do expect(subject.does_stuff?).to be_true end end
module YourCoolModule def your_cool_module_method end end describe YourCoolModule do context "cntxt1" do let(:dummy_class) do Class.new do include YourCoolModule def to_s "dummy" end def self.name "DummyClass" end end end context "instances" do subject { dummy_class.new } it { subject.should be_an_instance_of(dummy_class) } it { should respond_to(:your_cool_module_method)} it { should be_a(YourCoolModule) } its (:to_s) { should eq("dummy") } end context "classes" do subject { dummy_class } it { should be_an_instance_of(Class) } it { defined?(DummyClass).should be_nil } its (:name) { should eq("DummyClass") } end end context "cntxt2" do it "should not be possible to access let methods from anohter context" do defined?(dummy_class).should be_nil end end it "should not be possible to access let methods from a child context" do defined?(dummy_class).should be_nil end end describe "YourCoolModule" do dummy_class = Class.new { include YourCoolModule } describe dummy_class do it { should respond_to(:your_cool_module_method) } it { should_not be_an_instance_of(Class) } it { should be_an_instance_of(dummy_class) } it { should be_a(YourCoolModule) } end describe Object do it { should_not respond_to(:your_cool_module_method) } it { should_not be_an_instance_of(Class) } it { should_not be_an_instance_of(dummy_class) } it { should be_an_instance_of(Object) } it { should_not be_a(YourCoolModule) } end end describe Class.new { include YourCoolModule } do it { should respond_to(:your_cool_module_method) } it { should_not be_a(Class) } it { should be_a(YourCoolModule) } end describe "dummy_class not defined" do it { defined?(dummy_class).should be_nil } end
require describe Module::UnderTest do subject {Object.new.extend(described_class)} context it {is_expected.to respond_to(:module_method)} end end
Failure/Error: subject {Class.new{include described_class}.new} NameError: undefined local variable or method `described_class
require "api_helper" RSpec.describe Api, :type => :helper do describe " it { expect( helper.my_meth ).to eq 10 } end end
describe moduleToTest do let(:dummy_class) { Class.new { include moduleToTest } } let(:subject) { dummy_class.new } describe it expect(subject.method_to_test).to eq( end end end
p = Proc.new {|a, b| puts a**2+b**2 } p.call 1, 2 p.call 1 p.call 1, 2, 3 l = lambda {|a, b| puts a**2+b**2 } l.call 1, 2 l.call 1 l.call 1, 2, 3
lambda { return :foo }.call return Proc.new { return :foo }.call
def my_method puts "before proc" my_proc = Proc.new do puts "inside proc" return end my_proc.call puts "after proc" end my_method shoaib@shoaib-ubuntu-vm:~/tmp$ ruby a.rb before proc inside proc
def my_method puts "before proc" my_proc = lambda do puts "inside proc" return end my_proc.call puts "after proc" end my_method shoaib@shoaib-ubuntu-vm:~/tmp$ ruby a.rb before proc inside proc after proc
def batman_ironman_proc victor = Proc.new { return "Batman will win!" } victor.call "Iron Man will win!" end puts batman_ironman_proc def batman_ironman_lambda victor = lambda { return "Batman will win!" } victor.call "Iron Man will win!" end puts batman_ironman_lambda
> l = lambda { |a| a + 1 } > l.call(1) => 2 > l2= Proc.new { |a| a + 1 } > l2.call(1) => 2 def add(&block) end
def add(&block) block end l3 = add { |a| a + 1 } l3.call(1) => 2
> l = lambda {|a,b| puts " => > l.call(1) ArgumentError: wrong number of arguments (1 for 2) > l2 = Proc.new {|a,b| puts " => > l2.call(1) 1 +
> def add(a,b) l = Proc.new { return a + b} l.call puts "now exiting method" end > add(1,1) => 2 > def add(a,b) l = lambda { return a + b } l.call puts "now exiting method" end > add(1,1) => now exiting method
> def print(max) [1,2,3,4,5].each do |val| puts val return if val > max end end > print(3) 1 2 3 4
class NilClass def nil_or_empty? true end end class String def nil_or_empty? empty? end end
class Object def blank? respond_to?(:empty?) ? empty? : !self end end
class String def self.nilorempty?(string) string.nil? || string.empty? end end
module Nothingness refine String do alias_method :nothing?, :empty? end refine NilClass do alias_method :nothing?, :nil? end end using Nothingness return my_string.nothing?
module UsefulThings def get_file; ... def delete_file; ... def format_text(x); ... end
class UsefulWorker include UsefulThings def do_work format_text("abc") ... end end
module Mods def self.foo puts "Mods.foo(self)" end end
module Mods def foo puts "Mods.foo" end end class Includer include Mods end Includer.new.foo Mods.module_eval do module_function(:foo) public :foo end Includer.new.foo class Thing def bar Mods.foo end end Thing.new.bar
module UsefulThings def a puts "aaay" end module_function :a def b puts "beee" end end def test UsefulThings.a UsefulThings.b end test
module UsefulThings def self.get_file; ... def self.delete_file; ... def self.format_text(x); ... end
class UsefulWorker def do_work UsefulThings.instance_method(:format_text).bind(self).call("abc") ... end end
module UsefulThings def a puts "aaay" end def b puts "beee" end end def test ob = Class.new.send(:include, UsefulThings).new ob.a end test
module UsefulThings def self.get_file; ... def self.delete_file; ... def self.format_text(x); ... class << self def write_file; ... def commit_file; ... end end
module UsefulThingsMixin def get_file; ... def delete_file; ... def format_text(x); ... end module UsefulThings extend UsefulThingsMixin end
UsefulThings.get_file() class MyUser include UsefulThingsMixin def f format_text end end
module UsefulThings def add1 self + 1 end def add3 self + 3 end end UsefulThings.instance_methods
class Fixnum def add2 puts "cat" end def add3 puts "dog" end include UsefulThings end
Fixnum.instance_methods.select { |m| m.to_s.start_with? "add" } 1.add1 2 1.add2 cat 1.add3 dog
module UsefulThings def add1 self + 1 end def add2 self + 2 end def add3 self + 3 end end
class Fixnum def add2 puts "cat" end def add3 puts "dog" end include UsefulThings end
module Helpers def self.include_some(mod, klass, *args) klass.send(:include, mod) (mod.instance_methods - args - klass.instance_methods).each do |m| klass.send(:undef_method, m) end end end
class Fixnum def add2 puts "cat" end def add3 puts "dog" end Helpers.include_some(UsefulThings, self, :add1, :add3) end
Fixnum.instance_methods.select { |m| m.to_s.start_with? "add" } 1.add1 2 1.add2 cat 1.add3 dog
module CreateModuleFunctions def self.included(base) base.instance_methods.each do |method| base.module_eval do module_function(method) public(method) end end end end RSpec.describe CreateModuleFunctions do context "when included into a Module" do it "makes the Module module ModuleIncluded def instance_method_1;end def instance_method_2;end include CreateModuleFunctions end expect { ModuleIncluded.instance_method_1 }.to_not raise_error end end end
spec.add_dependency "reflection_utils", ">= 0.3.0" require include ReflectionUtils::CreateModuleFunctions
src_dir = "/full_path/to_some/ex_file.txt" dst_dir = "/full_path/target_dir" move_src_to_target_dir(src_dir, dst_dir) def archive_src_to_dst_dir(src_dir, dst_dir) if File.exist ? (src_dir) puts "about to move this file: FileUtils.mv(src_dir, dst_dir) else puts "can not find source file to move" end end
%w( it is less elegant to create arrays of symbols ).map( &:to_sym )
Modifier Meaning %q[ ] Non-interpolated String (except for \\ \[ and \]) %Q[ ] Interpolated String (default) %r[ ] Interpolated Regexp (flags can appear after the closing delimiter) %s[ ] Non-interpolated Symbol %w[ ] Non-interpolated Array of words, separated by whitespace %W[ ] Interpolated Array of words, separated by whitespace %x[ ] Interpolated shell command
gem "therubyracer" gem "less-rails" gem "twitter-bootstrap-rails"
Installing libv8 (3.16.14.3) Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension. c:/RailsInstaller/Ruby1.9.3/bin/ruby.exe extconf.rb creating Makefile 지정된 경로를 찾을 수 없습니다. 지정된 경로를 찾을 수 없습니다. 지정된 경로를 찾을 수 없습니다. c:/RailsInstaller/Ruby1.9.3/lib/ruby/ge ms/1.9.1/gems/libv8-3.16.14.3/ext/libv8/builder.rb:58:in `setup_python! python 2 to be installed in order to build, but it is currently not available (RuntimeErr or) from c:/RailsInstaller/Ruby1.9. 3/lib/ruby/gems/1.9.1/gems/libv8-3.16.14.3/ext/libv8/builder.rb:42:in `block in build_lib v8/builder.rb:42:in `block in build_libv8!' from c:/RailsInstaller/Ruby1.9.3/lib/ruby/gems/1.9.1/gems/libv8-3.16.14.3/ext/lib v8/builder.rb:40:in `chdir' from c:/RailsInstaller/Ruby1.9.3/lib/ruby/gems/1.9.1/gems/libv8-3.16.14.3/ext/lib v8/builder.rb:40:in `build_libv8!' from c:/RailsInstaller/Ruby1.9.3/lib/ruby/gems/1.9.1/gems/libv8-3.16.14.3/ext/lib v8/location.rb:24:in `install!' from extconf.rb:7:in `<main> Gem files will remain installed in c:/RailsInstaller/Ruby1.9.3/lib/ruby/gems/1.9.1/gems/l ibv8-3.16.14.3 for inspection. Results logged to c:/RailsInstaller/Ruby1.9.3/lib/ruby/gems/1.9.1/gems/libv8-3.16.14.3/ex t/libv8/gem_make.out An error occurred while installing libv8 (3.16.14.3), and Bundler cannot continue. Make sure that `gem install libv8 -v
$ gem uninstall libv8 $ brew install v8 $ gem install therubyracer $ bundle install
brew tap homebrew/versions brew install v8-315 gem install libv8 -v gem install therubyracer -- --with-v8-dir=/usr/local/opt/v8-315 bundle install
C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/net-ssh-2.9.2/lib/net/ssh/authentication/pageant.rb:1:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/net-ssh-2.9.2/lib/net/ssh/authentication/agent/socket.rb:5:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/net-ssh-2.9.2/lib/net/ssh/authentication/agent.rb:22:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/net-ssh-2.9.2/lib/net/ssh/authentication/key_manager.rb:4:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/net-ssh-2.9.2/lib/net/ssh/authentication/session.rb:4:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/net-ssh-2.9.2/lib/net/ssh.rb:11:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/ssh_helpers.rb:18:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/wizard.rb:77:in `<class:Wizard>' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/wizard.rb:7:in `<module:RHC>' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/wizard.rb:6:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/commands/base.rb:4:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/commands/account.rb:2:in `<module:Commands>' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/commands/account.rb:1:in `<top (required)>' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/2.2.0/rubygems/core_ext/kernel_require.rb:54:in `require' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/commands.rb:189:in `block in load' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/commands.rb:188:in `each' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/commands.rb:188:in `load' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/lib/rhc/cli.rb:36:in `start' from C:/Ruby22-x64/lib/ruby/gems/2.2.0/gems/rhc-1.35.1/bin/rhc:20:in `<top (required)>' from C:/Ruby22-x64/bin/rhc:23:in `load' from C:/Ruby22-x64/bin/rhc:23:in `<main>'
h.keys.each { |k| h[k[1, k.length - 1]] = h[k]; h.delete(k) }
new_h = Hash[h.map { |k, v| [k[1, k.length - 1], v] }]
new_h = h.inject({ }) { |x, (k,v)| x[k[1, k.length - 1]] = v; x }
h.keys.each { |k| h[k.sub(/\A_/, Hash[h.map { |k, v| [k.sub(/\A_/, h.inject({ }) { |x, (k,v)| x[k.sub(/\A_/,
h.keys.each do |k| if(k[0,1] == h[k[1, k.length - 1]] = h[k] h.delete(k) end end
Hash[h.map { |k, v| [k.sub(/\A_/, h.inject({ }) { |x, (k,v)| x[k.sub(/\A_/,
hash.inject({}){|option, (k,v) | option["id"] = v if k == "_id"; option}
hash.each {|k,v| hash.delete(k) && hash[k[1..-1]]=v if k[0,1] ==
ActiveRecord::Base.connection.data_sources ActiveRecord::Base.connection.data_source_exists? ActiveRecord::Base.connection.tables ActiveRecord::Base.connection.table_exists? ActiveRecord::Base.connection.views ActiveRecord::Base.connection.view_exists?
ActiveRecord::Base.connection.tables ActiveRecord::Base.connection.table_exists?
ActiveRecord::Migrator.get_all_versions ActiveRecord::Migrator.current_version
drop_table :kittens if (table_exists? :kittens) ActiveRecord::Migration.drop_table :kittens if (ActiveRecord::Base.connection.table_exists? :kittens)
if ActiveRecord::Base.connection.data_source_exists? drop_table :table_name end
class Dog < ApplicationRecord end do_something if Dog.table_exists?
>> [nil, 1].any? => true >> [nil, nil].any? => false
>> a = [] => [] >> a.empty? => true >> a = [nil, false] => [nil, false] >> a.empty? => false >> a = [nil] => [nil] >> a.empty? => false
>> a = [] => [] >> a.any? => false >> a.one? => false >> a.all? => true >> a.none? => true
>> a = [nil, true] => [nil, true] >> a.any? => true >> a.one? => true >> a.all? => false >> a.none? => false
>> a = [true, true] => [true, true] >> a.any? => true >> a.one? => false >> a.all? => true >> a.none? => false
static VALUE rb_ary_any_p(VALUE ary) { long i, len = RARRAY_LEN(ary); const VALUE *ptr = RARRAY_CONST_PTR(ary); if (!len) return Qfalse; if (!rb_block_given_p()) { for (i = 0; i < len; ++i) if (RTEST(ptr[i])) return Qtrue; } else { for (i = 0; i < RARRAY_LEN(ary); ++i) { if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qtrue; } } return Qfalse; }
static VALUE rb_ary_empty_p(VALUE ary) { if (RARRAY_LEN(ary) == 0) return Qtrue; return Qfalse; }
Object.class_eval do def size? respond_to?(:size) && size > 0 end end > "foo".size? => true > "".size? => false > " ".size? => true > [].size? => false > [11,22].size? => true > [nil].size? => true
require CSV.open("myfile.csv", "w") do |csv| csv << ["row", "of", "CSV", "data"] csv << ["another", "row"] end
require csv_string = CSV.generate do |csv| csv << ["row", "of", "CSV", "data"] csv << ["another", "row"] end
rows = [[ csv_str = rows.inject([]) { |csv, row| csv << CSV.generate_line(row) }.join("")
File.open("ss.csv", "w") {|f| f.write(rows.inject([]) { |csv, row| csv << CSV.generate_line(row) }.join(""))}
CSV.open(fn, csv << Model.column_names Model.where(query).each do |m| csv << m.attributes.values end end
rowid = 0 CSV.open(fn, hsh_ary.each do |hsh| rowid += 1 if rowid == 1 csv << hsh.keys else csv << hsh.values end end end
require rows = [[1,2,3],[4,5]] csv = rows.map(&:to_csv).join rows2 = csv.split("\n").map(&:parse_csv) filename = IO.write(filename, rows.map(&:to_csv).join) rows3 = CSV.read(filename) rows3 == rows2 rows3 == rows
rows = [["a1", "a2", "a3"],["b1", "b2", "b3", "b4"], ["c1", "c2", "c3"]]
require "csv" File.write("ss.csv", rows.map(&:to_csv).join)
CSV.open( csvfile << us_eco.first.keys us_eco.each do |row| csvfile << row.values end end
require class CSV def CSV.unparse array CSV.generate do |csv| array.each { |i| csv << i } end end end CSV.unparse [ %w(your array), %w(goes here) ]
It seems your ruby installation is missing psych (for YAML output). To eliminate this warning, please install libyaml and reinstall your ruby.
rm -rf /usr/local/lib/ruby/gems/ && brew reinstall ruby
sudo apt-get install libtool rvm pkg install libyaml rvm reinstall 1.9.3
./configure --prefix=/usr/local make sudo make install
./configure --prefix=/wherever/you/want/it/to/go make make install
yum install libtool yum install libyaml (or rvm pkg install libyaml) rvm reinstall 1.9.3
brew uninstall libyaml rvm autolibs enable rvm reinstall ruby-2.1.1
sudo port install libyaml rvm get latest rvm pkg install iconv rvm pkg install openssl rvm reinstall 1.9.3 --with-openssl-dir=~/.rvm/usr --with-iconv-dir=~/.rvm/usr curl -OL http: curl -OL http: gem install linecache19-0.5.13.gem ruby-debug-base19-0.11.26.gem -- --with-ruby-include=$rvm_path/src/ruby-1.9.3-p125/ gem install ruby-debug19 rvm reload
rm -rf /usr/local/lib/ruby ./configure make && make install gem -v
/usr/local/rvm/rubies/ruby-1.9.3-p286/lib/ruby/1.9.1/yaml.rb:56:in `<top (required)> It seems your ruby installation is missing psych (for YAML output). To eliminate this warning, please install libyaml and reinstall your ruby.
rvm remove all rvm install 1.9.1 rvm use 1.9.1 --default
$ wget http: $ tar xzvf yaml-0.1.4.tar.gz $ cd yaml-0.1.4 $ ./configure --prefix=/usr/local $ make $ sudo make install
sudo su - root echo /usr/local/lib64 >> /etc/ld.so.conf echo /usr/local/lib >> /etc/ld.so.conf ldconfig
patch .rvm/scripts/functions/manage/ruby < ruby-1.9.3-LDFLAGS.patch rvm uninstall ruby-1.9.3-p194 export LDFLAGS= rvm install ruby-1.9.3-p194 --disable-binary grep configure_args .rvm/src/ruby-1.9.3-p194/config.log
% uname -a Linux localhost.localdomain 2.6.32-358.el6.x86_64 % cat /etc/redhat-release CentOS release 6.4 (Final) % wget http: % sudo rpm -K rpmforge-release-0.3.6-1.el5.rf.*.rpm" % sudo rpm -ivh rpmforge-release-0.3.6-1.el5.rf.*.rpm"
% grep rpmforge ~/.aliases alias rpmforge "sudo yum --disablerepo= % rpmforge install libyaml libyaml-devel % sudo yum list installed | grep libyaml libyaml.x86_64 0.1.4-1.el5.rf @rpmforge libyaml-devel.x86_64 0.1.4-1.el5.rf @rpmforge
% tar zxvf ruby-1.9.3-p448.tar.gz % cd ruby-1.9.3-p448 % ./configure -prefix=$HOME/ruby-1.9.3-p448 % make ; make install % cd $HOME; ln -s ./ruby-1.9.3-p448 ruby
% echo $PATH /home/francis/ruby/bin:/usr/sbin:/home/francis/bin:/home/francis/jdk1.7.0_25/bin:/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/bin % which ruby /home/francis/ruby/bin/ruby % gem update --system
% echo $GEM_HOME % /home/francis/ruby/lib/ruby/gems % gem install mysql2 pg ruby-debug-ide rails capistrano capistrano-ext passenger
$ brew remove --force ruby $ sudo rm -rf /usr/local/lib/ruby $ brew install ruby $ gem install bundler $ bundle install
rm -rf /usr/local/lib/ruby/gems/2.4.0/gems/psych-2.2.4 rm -rf /usr/local/lib/ruby/gems/2.4.0/extensions/x86_64-darwin-16/2.4.0/psych-2.2.4
brew install libyaml rvm get head rvm reinstall 1.9.3 --with-gcc=clang
sudo rm /usr/local/lib/libyaml*.* rvm reinstall ruby-2.0.0-p0
1.upto(10).each { |n| puts "%04b" % n } 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010
>> lookup_table = Hash.new { |h, i| h[i] = i.to_s(2) } => {} >> lookup_table[1] => "1" >> lookup_table[2] => "10" >> lookup_table[20] => "10100" >> lookup_table[200] => "11001000" >> lookup_table => {1=>"1", 200=>"11001000", 2=>"10", 20=>"10100"}
def int_to_binary(x) p = 0 two_p = 0 output = "" while two_p * 2 <= x do two_p = 2 ** p output << ((two_p & x == two_p) ? "1" : "0") p += 1 end output.reverse end
1.upto(1000) do |n| built_in, custom = ("%b" % n), int_to_binary(n) if built_in != custom puts "I expected exit 1 end puts custom end
lookup_table = Hash.new (0..9).each {|x| lookup_table[x] = x.to_s(2) lookup_table[x.to_s] = x.to_s(2) } lookup_table[5] => "101" lookup_table["8"] => "1000"
class Binary def self.binary_to_decimal(binary) binary_array = binary.to_s.chars.map(&:to_i) total = 0 binary_array.each_with_index do |n, i| total += 2 ** (binary_array.length-i-1) * n end total end end class BinaryTest < Test::Unit::TestCase def test_1 test1 = Binary.binary_to_decimal(0001) assert_equal 1, test1 end def test_8 test8 = Binary.binary_to_decimal(1000) assert_equal 8, test8 end def test_15 test15 = Binary.binary_to_decimal(1111) assert_equal 15, test15 end def test_12341 test12341 = Binary.binary_to_decimal(11000000110101) assert_equal 12341, test12341 end end
require > Rickshaw::SHA1.hash( => "4659d94e7082a65ca39e7b6725094f08a413250a" > "hello world".to_sha1 => "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed"
def generateKey(data) return Digest::SHA1.hexdigest (" end
require File.expand_path(File.join(File.dirname(__FILE__),
unless Kernel.respond_to?(:require_relative) module Kernel def require_relative(path) require File.join(File.dirname(caller.first), path.to_str) end end end
require N = 1_000_000 puts RUBY_VERSION STR = "[12,23,987,43" Benchmark.bm(7) do |b| b.report( b.report( b.report( b.report( b.report( b.report( end
1.9.3 user system total real [0] 0.840000 0.000000 0.840000 ( 0.847496) sub 1.960000 0.010000 1.970000 ( 1.962767) gsub 4.350000 0.020000 4.370000 ( 4.372801) [1..-1] 0.710000 0.000000 0.710000 ( 0.713366) slice 1.020000 0.000000 1.020000 ( 1.020336) length 1.160000 0.000000 1.160000 ( 1.157882)
require N = 1_000_000 class String def eat!(how_many = 1) self.replace self[how_many..-1] end def first(how_many = 1) self[0...how_many] end def shift(how_many = 1) shifted = first(how_many) self.replace self[how_many..-1] shifted end alias_method :shift!, :shift end class Array def eat!(how_many = 1) self.replace self[how_many..-1] end end puts RUBY_VERSION STR = "[12,23,987,43" Benchmark.bm(7) do |b| b.report( b.report( b.report( b.report( b.report( b.report( b.report( b.report( end
2.1.2 user system total real [0] 0.300000 0.000000 0.300000 ( 0.295054) sub 0.630000 0.000000 0.630000 ( 0.631870) gsub 2.090000 0.000000 2.090000 ( 2.094368) [1..-1] 0.230000 0.010000 0.240000 ( 0.232846) slice 0.320000 0.000000 0.320000 ( 0.320714) length 0.340000 0.000000 0.340000 ( 0.341918) eat! 0.460000 0.000000 0.460000 ( 0.452724) reverse 0.400000 0.000000 0.400000 ( 0.399465)
require N = 1_000_000 class String def eat!(how_many = 1) self.replace self[how_many..-1] end def first(how_many = 1) self[0...how_many] end def shift(how_many = 1) shifted = first(how_many) self.replace self[how_many..-1] shifted end alias_method :shift!, :shift end class Array def eat!(how_many = 1) self.replace self[how_many..-1] end end puts RUBY_VERSION STR = "[12,23,987,43" Benchmark.bm(7) do |b| b.report( b.report( b.report( b.report( b.report( b.report( b.report( b.report( b.report( b.report( b.report( end
2.3.1 user system total real [0] 0.200000 0.000000 0.200000 ( 0.204307) [/^./] 0.390000 0.000000 0.390000 ( 0.387527) [/^\[/] 0.360000 0.000000 0.360000 ( 0.360400) sub+ 0.490000 0.000000 0.490000 ( 0.492083) sub 0.480000 0.000000 0.480000 ( 0.487862) gsub 1.990000 0.000000 1.990000 ( 1.988716) [1..-1] 0.180000 0.000000 0.180000 ( 0.181673) slice 0.260000 0.000000 0.260000 ( 0.266371) length 0.270000 0.000000 0.270000 ( 0.267651) eat! 0.400000 0.010000 0.410000 ( 0.398093) reverse 0.340000 0.000000 0.340000 ( 0.344077)
val = "abc" => "abc" val.slice!(0) => "a" val => "bc"
2.5.0 user system total real [0] 0.174766 0.000489 0.175255 ( 0.180207) [/^./] 0.318038 0.000510 0.318548 ( 0.323679) [/^\[/] 0.372645 0.001134 0.373779 ( 0.379029) sub+ 0.460295 0.001510 0.461805 ( 0.467279) sub 0.498351 0.001534 0.499885 ( 0.505729) gsub 1.669837 0.005141 1.674978 ( 1.682853) [1..-1] 0.199840 0.000976 0.200816 ( 0.205889) slice 0.279661 0.000859 0.280520 ( 0.285661) length 0.268362 0.000310 0.268672 ( 0.273829) eat! 0.341715 0.000524 0.342239 ( 0.347097) reverse 0.335301 0.000588 0.335889 ( 0.340965) delete_p 0.222297 0.000832 0.223129 ( 0.228455) delete_p! 0.225798 0.000747 0.226545 ( 0.231745)
1.9.2-p290 > a = "One Two Three" => "One Two Three" 1.9.2-p290 > a = a[1..-1] => "ne Two Three" 1.9.2-p290 > a = a[1..-1] => "e Two Three" 1.9.2-p290 > a = a[1..-1] => " Two Three" 1.9.2-p290 > a = a[1..-1] => "Two Three" 1.9.2-p290 > a = a[1..-1] => "wo Three"
class String def reverse_chop() self[1..self.length] end end "[12,23,987,43".reverse_chop()
class String def eat!(how_many = 1) self.replace self[how_many..-1] end end
class String def first(how_many = 1) self[0...how_many] end def shift(how_many = 1) shifted = first(how_many) self.replace self[how_many..-1] shifted end alias_method :shift!, :shift end
class Array def eat!(how_many = 1) self.replace self[how_many..-1] end end
> str = "[12,23,987,43" > str.eat! > str > str.eat!(3) > str > str.first(2) > str > str.shift!(3) > str > arr = [1,2,3,4,5] > arr.eat! > arr
class String def bye_felicia() felicia = self.strip[0] self.sub(felicia, end end
class Tokenizer def self.tokenize(string) return string.split(" ") end end
C:\Documents and Settings\my\src\folder>ruby main.rb C:/Ruby193/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require from C:/Ruby193/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require ' from main.rb:1:in `<main>'
irb> f = File.new( => irb> f.read => "class Tokenizer\n def self.tokenize(string)\n return string.split( \" \")\n end\nend\n" irb> require f LoadError: cannot load such file -- blabla.rb from D:/dev/Ruby193/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `req uire' from D:/dev/Ruby193/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `req uire' from (irb):24 from D:/dev/Ruby193/bin/irb:12:in `<main>'
irb f = File.new( => irb f.read => "class Tokenizer\n def self.tokenize(string)\n return string.split( \" \")\n end\nend\n" irb> require f => true
LoadError: no such file to load -- roman-numerals require at org/jruby/RubyKernel.java:1054 require at /Users/amanoharan/.rvm/rubies/jruby-1.7.4/lib/ruby/shared/rubygems/custom_require.rb:36 (root) at /Users/amanoharan/Documents/Aptana Studio 3 Workspace/RubyApplication/RubyApplication1/Ruby2.rb:2
for i in `gem list --no-versions`; do gem uninstall -aIx $i; done
$ sudo gem list --no-version | xargs sudo gem uninstall -ax
ruby -e "`gem list`.split(/$/).each { |line| puts `gem uninstall -Iax
ERROR: While executing gem ... (Gem::FilePermissionError) You don
for x in `gem list --no-versions`; do gem uninstall $x -a -x -I; done
gem list | cut -d" " -f1 | sudo xargs gem uninstall -Iax
gem list --no-version | grep "aws-sdk-" | xargs gem uninstall -aIx
sudo gem list | cut -d" " -f1 | xargs gem uninstall -aIx
sudo for gem (`gem list | cut -d" " -f1`); do gem uninstall $gem -aIx; done
@myvar = session[:comments][@comment.id]["temp_value"]
> params = nil nil > params&.country nil > params = OpenStruct.new(country: "Australia") > params&.country "Australia" > params&.country&.name NoMethodError: undefined method `name from (pry):38:in `<main>' > params.try(:country).try(:name) nil
city = params.fetch(:[], :country).try(:[], :state).try(:[], :city)
class Hash def get_deep(*fields) fields.inject(self) {|acc,e| acc[e] if acc} end end
class Hash def get_deep(*fields) fields.inject(self) {|acc,e| acc[e] if acc.is_a?(Hash)} end end a_hash = {:one => {:two => {:three => "asd"}, :arr => [1,2,3]}} puts a_hash.get_deep(:one, :two ).inspect puts a_hash.get_deep(:one, :two, :three ).inspect puts a_hash.get_deep(:one, :two, :three, :four).inspect puts a_hash.get_deep(:one, :arr ).inspect puts a_hash.get_deep(:one, :arr, :too_deep ).inspect
@session.try(:[], :comments).try(:[], commend.id).try(:[],
class Hash def get_deep(*fields) fields.inject(self) { |acc, e| acc[e] if acc.is_a?(Hash) || (e.is_a?(Integer) && acc.respond_to?(:[])) } end end
@myvar = session.fetch(:comments, {}).fetch(@comment.id, {})["temp_value"]
@myvar = session[:comments].to_h[@comment.id].to_h["temp_value"]
@myvar = session.dig(:comments, @comment.id, "temp_value")
h = { foo: {bar: {baz: 1}}} h.dig(:foo, :bar, :baz) h.dig(:foo, :zot)
@myvar = session[:comments][@comment.id]["temp_value"] rescue nil
def handle raise $! unless $!.kind_of? NoMethodError end @myvar = session[:comments][@comment.id]["temp_value"] rescue handle
>> hash = {:foo => "bar"} => {:foo=>"bar"} >> hash[:foo] => "bar" >> hash[:doo] => nil >> hash[:doo][:too] => nil
@myvar = session[:comments][@comment.id]["temp_value"] if session[:comments]
class FoosController < ApplicationController def show @foo = Foo.find(...) end end ... <%= @foo.bar %> ...
class FoosController < ApplicationController helper_method :foo def show end protected def foo @foo ||= Foo.find(...) end end ... <%= foo.bar %> ...
RSpec.configure do |config| config.color = true config.tty = true config.formatter = :documentation end
RSpec.configure do |config| config.color_enabled = true end
Rspec.configure do |config| config.tty = $stdout.tty? end
prefix_tmp_path = filename = "/ fullname = prefix_tmp_path + filename
>> File.join("path", "to", "join") => "path/to/join"
prefix_tmp_path = filename = " fullname = File.join(prefix_tmp_path, filename)
"Apple" == "Apple" "Apple" == "APPLE" "Apple" == "Apple1"
str1.casecmp(str2) == 0 "Apple".casecmp("APPLE") == 0
"abcdef".casecmp?("abcde") "aBcDeF".casecmp?("abcdef") "abcdef".casecmp?("abcdefg") "abcdef".casecmp?("ABCDEF")
begin do_something_error_prone rescue AParticularKindOfError rescue write_to_error_log raise end
catch :foo do catch :bar do do_something_that_can_throw_foo_or_bar end end
$ cat caller.rb require File.join(File.dirname(__FILE__), $ cat path/to/file.rb puts $ ruby caller Some testing $ pwd /tmp $ ruby /tmp/caller Some testing $ ruby tmp/caller tmp/caller.rb:1:in from tmp/caller.rb:1:in
require File.join(File.expand_path(File.dirname(__FILE__)),
unless Kernel.respond_to?(:require_relative) module Kernel def require_relative(path) require File.join(File.dirname(caller[0]), path.to_str) end end end
def require_relative(relative_feature) c = caller.first fail "Can file = $` if /\A\((.*)\)/ =~ file raise LoadError, "require_relative is called in end absolute = File.expand_path(relative_feature, File.dirname(file)) require absolute end
require File.join(File.expand_path(File.dirname(__FILE__)),
begin require "./path/to/file" require_local "path/to/file" rescue LoadError require "path/to/file" end
~/Projects/MyProject/foo.rb ~/Projects/MyProject/lib/someinclude.rb
require File.join(File.dirname(__FILE__), "lib/someinclude")
config_path = File.expand_path("../config.yml", __FILE__)
Can *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options.
$ export PKG_CONFIG_PATH="/opt/local/lib/pkgconfig:$PKG_CONFIG_PATH"
brew tap homebrew/versions brew install imagemagick@6
PKG_CONFIG_PATH=/usr/local/opt/imagemagick@6/lib/pkgconfig gem install rmagick
$ mdfind MagickWand.h /usr/local/Cellar/imagemagick/6.7.5-7/include/ImageMagick/wand/MagickWand.h
$ C_INCLUDE_PATH=/path/MagickWand.h gem install rmagick
$ C_INCLUDE_PATH=/usr/local/Cellar/imagemagick/6.7.5-7/include/ImageMagick/ gem install rmagick
$ brew install imagemagick ==> /usr/local/Cellar/imagemagick/6.8.6-3 $ brew install pkgconfig ==> /usr/local/Cellar/pkg-config/0.28 $ C_INCLUDE_PATH=/usr/local/Cellar/imagemagick/6.8.6-3/include/ImageMagick-6 PKG_CONFIG_PATH=/usr/local/Cellar/imagemagick/6.8.6-3/lib/pkgconfig/ gem install rmagick Successfully installed rmagick-2.13.2
brew install imagemagick@6 --force && brew link imagemagick@6 --force
C_INCLUDE_PATH=/usr/local/Cellar/imagemagick/6.7.7-6/include/ImageMagick/ PKG_CONFIG_PATH=/usr/local/Cellar/imagemagick/6.7.7-6/lib/pkgconfig/ gem install rmagick
sudo apt-get install imagemagick libmagickwand-dev gem install rmagick
brew uninstall pkg-config brew install pkg-config brew unlink pkg-config && brew link pkg-config
sudo apt-get update sudo apt-get autoclean sudo apt-get clean sudo apt-get autoremove
sudo dpkg --remove -force --force-remove-reinstreq package_name
apt-get install libmagickcore-dev libmagickwand-dev
$ gem install imagemagick@6 $ brew unlink imagemagick $ brew link imagemagick@6 --force
sudo apt-get install -y libmagickwand-6-headers C_INCLUDE_PATH=/usr/include/ImageMagick-6 gem install rmagick bundle update rmagick bundle install
C_INCLUDE_PATH=/usr/local/Cellar/imagemagick/6.7.7-6/include/ImageMagick gem install rmagick
$ Wand-config --ldflags --libs /usr/local/bin/Wand-config: line 50: pkg-config: command not found /usr/local/bin/Wand-config: line 53: pkg-config: command not found
$ Wand-config --ldflags --libs -L/usr/local/Cellar/imagemagick/6.8.8-9/lib -lMagickWand-6.Q16 -lMagickCore-6.Q16 -L/usr/local/Cellar/imagemagick/6.8.8-9/lib -lMagickWand-6.Q16 -lMagickCore-6.Q16
$ gem install rmagick Building native extensions. This could take a while... Successfully installed rmagick-2.13.2 Parsing documentation for rmagick-2.13.2 Done installing documentation for rmagick after 4 seconds 1 gem installed
C_INCLUDE_PATH=/usr/local/include/ImageMagick-6/ gem install rmagick
ERROR: Error installing rmagick: ERROR: Failed to build gem native extension. /home/vagrant/.rvm/rubies/ruby-1.9.3-p0/bin/ruby extconf.rb ... Package MagickCore was not found in the pkg-config search path. Perhaps you should add the directory containing `MagickCore.pc'
ln -s /usr/local/include/ImageMagick/wand /usr/local/include/ImageMagick-6/wand ln -s /usr/local/include/ImageMagick/magick /usr/local/include/ImageMagick-6/magick
$ gem install rmagick Building native extensions. This could take a while... Successfully installed rmagick-2.13.2 1 gem installed
yum install ImageMagick ImageMagick-devel gem install rmagick -v
checking for outdated ImageMagick version (<= 6.4.9)... no checking for presence of MagickWand API (ImageMagick version >= 6.9.0)... no .... checking for wand/MagickWand.h... no
gem "pony" gem "bcrypt-ruby", :require => "bcrypt" gem "nokogiri"
alex@ubuntu:~/$ bundle Fetching gem metadata from http: Fetching gem metadata from http: Enter your password to install the bundled RubyGems to your system: Installing bcrypt-ruby (3.0.1) with native extensions Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension. /usr/bin/ruby1.9.1 extconf.rb /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require from /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require' from extconf.rb:36:in `<main>' Gem files will remain installed in /home/alex/.bundler/tmp/5526/gems/bcrypt-ruby-3.0.1 for inspection. Results logged to /home/alex/.bundler/tmp/5526/gems/bcrypt-ruby-3.0.1/ext/mri/gem_make.out An error occurred while installing bcrypt-ruby (3.0.1), and Bundler cannot continue. Make sure that `gem install bcrypt-ruby -v
sudo gem install bcrypt-ruby -v Building native extensions. This could take a while... ERROR: Error installing bcrypt-ruby: ERROR: Failed to build gem native extension. /usr/bin/ruby1.9.1 extconf.rb /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require from /usr/lib/ruby/1.9.1/rubygems/custom_require.rb:36:in `require' from extconf.rb:36:in `<main>' Gem files will remain installed in /var/lib/gems/1.9.1/gems/bcrypt-ruby-3.0.1 for inspection. Results logged to /var/lib/gems/1.9.1/gems/bcrypt-ruby-3.0.1/ext/mri/gem_make.out
CONFIGURE_OPTS="--enable-shared" rbenv install 2.2.2
hash = {:item1 => 1} another_hash = {:item2 => 2, :item3 => 3} hash.merge(another_hash)
irb(main):001:0> hash = {:item1 => 1} => {:item1=>1} irb(main):002:0> hash[:item2] = 2 => 2 irb(main):003:0> hash => {:item1=>1, :item2=>2}
hash_items = {:item => 1} puts hash_items hash_items.merge!({:item => 2}) puts hash_items hash_items.merge({:item => 2}) puts hash_items
sudo gem install nokogiri -- --with-xml2-include=/usr/include/libxml2 --with-xml2-lib=/usr/lib --with-xslt-dir=/usr/
NOKOGIRI_USE_SYSTEM_LIBRARIES=1 gem install nokogiri -- --use-system-libraries --with-iconv-dir="$(brew --prefix libiconv)" --with-xml2-config="$(brew --prefix libxml2)/bin/xml2-config" --with-xslt-config="$(brew --prefix libxslt)/bin/xslt-config"
su yum search rubygem-nokogiri yum install rubygem-nokogiri.i686
cinst libxml2 cinst libxslt cinst libiconv gem install nokogiri -- --with-xml2-include=C:\Chocolatey\lib\libxml2.2.7.8.7\build\native\include --with-xml2-lib=C:\Chocolatey\lib\libxml2.redist.2.7.8.7\build\native\bin\v110\x64\Release\dynamic\cdecl --with-iconv-include=C:\Chocolatey\lib\libiconv.1.14.0.11\build\native\include --with-iconv-lib=C:\Chocolatey\lib\libiconv.redist.1.14.0.11\build\native\bin\v110\x64\Release\dynamic\cdecl --with-xslt-include=C:\Chocolatey\lib\libxslt.1.1.28.0\build\native\include --with-xslt-lib=C:\Chocolatey\lib\libxslt.redist.1.1.28.0\build\native\bin\v110\x64\Release\dynamic
gem install nokogiri -- --with-xml2-include=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libxml2 --use-system-libraries
The compiler failed to generate an executable file. (RuntimeError) You have to install development tools first.
NOKOGIRI_USE_SYSTEM_LIBRARIES=1 vagrant plugin install vagrant-aws
$ dnf group install "C Development Tools and Libraries" $ dnf install ruby-devel libxml2-devel patch
checking for xmlParseDoc() in libxml/parser.h... no checking for xmlParseDoc() in -lxml2... no checking for xmlParseDoc() in -llibxml2... no
conftest.c:15:27: error: too few arguments to function call, single argument int t(void) { xmlParseDoc(); return 0; }
rvm uninstall 2.2 rvm install 2.2 --with-gcc=clang gem install nokogiri
gem install nokogiri -- --with-xml2-include=/usr/local/Cellar/libxml2/2.7.8/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.7.8/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26 --with-iconv-include=/usr/local/Cellar/libiconv/1.14/include --with-iconv-lib=/usr/local/Cellar/libiconv/1.14/lib
<%= form_for @order do |f| %> <%= f.hidden_field :service, "test" %> <%= f.submit %> <% end %>
<%= form_for @order do |f| %> <%= f.hidden_field :service %> <%= f.submit %> <% end %>
File.new "out.txt" File.open "out.txt" File.new "out.txt","w" File.open "out.txt","w"
File.open("out.txt", [your-option-string]) {|f| f.write("write your stuff here") }
out_file = File.new("out.txt", "w") out_file.puts("write your stuff here") out_file.close
File.open("out.txt", "w") do |f| f.write(data_you_want_to_write) end
File.open("out.txt", "w+") { |file| file.write("boo!") }
<% content_for :title, "Title for specific page" %> <!-- or --> <h1><%= content_for(:title, "Title for specific page") %></h1>
<head> <title><%= yield(:title) %></title> <!-- Additional header tags here --> </head> <body> <!-- If all pages contain a headline tag, it <h1><%= yield(:title) %></h1> </body>
def page_title(separator = " – ") [content_for(:title), end def page_heading(title) content_for(:title){ title } content_tag(:h1, title) end
<title><%= @title || "Default Page Title" %></title>
class FooController < ApplicationController before_filter :set_title private def set_title @page_title = "Foo Page" end end <h1><%= page_title %></h1>
<%content_for :page_title do %><%= t :page_title, "Name of Your Page" %> <% end %>
<% provide(:title,"ttttttttttttttttttZ") %> <html> <head><title><%= yield(:title) %></title></head> <body></body> </html>
def get_title @action_title_name || case controller_name when when when when when when when else end end
Dir.chdir music = Dir[ puts @new = playlist_name = gets.chomp + music.each do |z| @new += z + end File.open playlist_name, f.write @new end
Dir.chdir music = Dir[ puts playlist_name = gets.chomp + File.open playlist_name, music.each do |z| f.puts z end end
Dir.chdir music = Dir[ puts playlist_name = gets.chomp + File.open(playlist_name,
number = 1.1164 number.round(2) The above shows the following error wrong number of arguments (1 for 0)
def float_of_2_decimal(float_n) float_n.to_d.round(2, :truncate).to_f end
def float_of_2_decimal(float_n) float_n.round(3).to_s[0..3].to_f end
module Util module MyUtil def self.redondear_up(suma,cantidad, decimales=0) unless suma.present? return nil end if suma>0 resultado= (suma.to_f/cantidad) return resultado.round(decimales) end return nil end end end
<th><% <% if prom == 0 or total == 0 %> N.E. <% else %> <%= Integer((prom/total).to_d*10)*0.1 %><!--1decimal,truncado--> <% end %> <% </th>
production: secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>
$ vi ~/.bash_profile $ vi ~/.bash_login $ vi ~/.profile
Rails.application.configure do ... config.secret_key_base = ENV["SECRET_KEY_BASE"] ... end
class LanguagePack::Rails41 < LanguagePack::Rails4 def compile instrument "rails41.compile" do super allow_git do create_secrets_yml end end end def create_secrets_yml instrument log("create_secrets_yml") do return unless File.directory?("config") topic("Writing config/secrets.yml to read from SECRET_KEY_BASE") File.open("config/secrets.yml", "w") do |file| file.puts <<-SECRETS_YML <% raise "No RACK_ENV or RAILS_ENV found" unless ENV["RAILS_ENV"] || ENV["RACK_ENV"] %> <%= ENV["RAILS_ENV"] || ENV["RACK_ENV"] %>: secret_key_base: <%= ENV["SECRET_KEY_BASE"] %> SECRETS_YML end end end end end
... <%= ENV["RAILS_ENV"] || ENV["RACK_ENV"] %>: secret_key_base: <%= ENV["SECRET_KEY_BASE"] %> third_party_api_key: <%= ENV["THIRD_PARTY_API"] %>
environment: production user: www-data group: www-data SECRET_KEY_BASE: mysecretkeyproduction
thin start -C /whereeveristhefieonprod/configthin.yml
Rails::Application.class_eval do fail "I def validate_secret_key_config! config.secret_token = secrets.secret_token if config.secret_token.blank? raise "Missing `secret_token` for end end end
Rails.application.config.secret_key_base = ENV["SECRET_KEY_BASE"]
config/initializers/secret_token.rb config/secrets.yml
>> Integer(:foobar) => 26017 >> Integer(:yikes) => 26025
class IntegerInString < String def initialize( s ) fail ArgumentError, "The string super end end
n = IntegerInString.new "2" n.to_i IntegerInString.new "blob" ArgumentError: The string
class NotAnIntError < StandardError end class String def is_int? self =~ /^-?[0-9]+$/ end def safe_to_i return self.to_i if is_int? raise NotAnIntError, "The string end end class Integer def safe_to_i return self end end class StringExtensions < Test::Unit::TestCase def test_is_int assert "98234".is_int? assert "-2342".is_int? assert "02342".is_int? assert !"+342".is_int? assert !"3-42".is_int? assert !"342.234".is_int? assert !"a342".is_int? assert !"342a".is_int? end def test_safe_to_i assert 234234 == 234234.safe_to_i assert 237 == "237".safe_to_i begin "a word".safe_to_i fail rescue NotAnIntError end end end
someString = "asdfasd123" number = someString.to_i if someString != number.to_s puts "oops, this isn end
def safeParse2(strToParse) if strToParse =~ /\A\d+\Z/ strToParse.to_i else raise Exception end end ["100", "1a", "b2", "t"].each do |number| begin puts safeParse2(number) rescue Exception puts " end end
s = "foo" h = {} h[s] = "bar" s.upcase! h.rehash h[s] h.keys h.keys.first.upcase!
Something.find(:all, :order => "id desc", :limit => 5).reverse
result = Something.find(:all, :order => "id desc", :limit => 5) while !result.empty? puts result.pop end
Something.limit(5).order( => Image::ActiveRecord_Relation Something.limit(5).order( => "SELECT \"somethings\".* FROM \"somethings\" ORDER BY id desc LIMIT 5"
class AddTimestampsToUser < ActiveRecord::Migration def change_table add_timestamps(:users) end end
class AddTimestampsToUser < ActiveRecord::Migration def change_table add_column :users, :created_at, :datetime, null: false add_column :users, :updated_at, :datetime, null: false end end
class AddTimestampsToUser < ActiveRecord::Migration def self.up change_table :users do |t| t.timestamps end end def self.down remove_column :users, :created_at remove_column :users, :updated_at end end
class AddTimestampsToUser < ActiveRecord::Migration def change change_table(:users) { |t| t.timestamps } end end
class AddTimestampsToUser < ActiveRecord::Migration def change add_timestamps(:users) end end
class AddTimestampsToUser < ActiveRecord::Migration def up add_timestamps(:users) end def down remove_timestamps(:users) end end
class AddTimestampsToUser < ActiveRecord::Migration def change change_table :users do |t| t.timestamps end end end
change_table :table do |t| t.column t.index t.timestamps t.change t.change_default t.rename t.references t.belongs_to t.string t.text t.integer t.float t.decimal t.datetime t.timestamp t.time t.date t.binary t.boolean t.remove t.remove_references t.remove_belongs_to t.remove_index t.remove_timestamps end
def change add_timestamps :projects, default: Time.zone.now change_column_default :projects, :created_at, nil change_column_default :projects, :updated_at, nil end
def change add_timestamps :campaigns, default: DateTime.now change_column_default :campaigns, :created_at, from: DateTime.now, to: nil change_column_default :campaigns, :updated_at, from: DateTime.now, to: nil end
def add_datetime tables = ActiveRecord::Base.connection.tables tables.each do |t| ActiveRecord::Base.connection.add_timestamps t end end
class AddTimestampsToUsers < ActiveRecord::Migration def change add_timestamps(:users, null: false) end end
ActiveRecord::Schema.define do change_table add_column(:mytable, :my_field_name, :integer) end end
class AddTimestampsToUsers < ActiveRecord::Migration def change add_timestamps(:users) end end
def up add_column :projects, :created_at, :datetime, default: nil, null: false add_column :projects, :updated_at, :datetime, default: nil, null: false end
def data Project.update_all created_at: Time.now end
class AddTimestampsToMyTable < ActiveRecord::Migration[5.2] def change add_timestamps :my_table end end
add_column :<table>, :created_at, :datetime, default: Time.zone.now, null: false add_column :<table>, :updated_at, :datetime, default: Time.zone.now, null: false
irb(main)> varA => {0=>["12", "34", "35", "231"]} irb(main)> varA = Hash[*ex.collect{|a,b| [a,b.join(",")]}.flatten] ...
{ :key1 => "value1", :key2 => "value2", :key3 => "value3" }
JSON.pretty_generate(a: 1, 2 => 3, 3 => nil). gsub(": null", ": nil"). gsub(/(^\s*)"([a-zA-Z][a-zA-Z\d_]*)":/, "\\1\\2:"). gsub(/(^\s*)(".*?"):/, "\\1\\2 =>") { a: 1, "2" => 3, "3" => nil }
require require formatter = Rouge::Formatters::Terminal256.new json_lexer = Rouge::Lexers::JSON.new puts formatter.format(json_lexer.lex(JSON.pretty_generate(JSON.parse(response))))
ALFA ROMEO => Alfa Romeo AUDI => Audi BMW => Bmw ONETWO THREE FOUR => Onetwo Three Four
"kirk douglas".split(/ |\_/).map(&:capitalize).join(" ") def titleize(str) str.split(/ |\_/).map(&:capitalize).join(" ") end
module Enumerable def does_not_include?(item) !include?(item) end end
if @players.include? && @spectators.exclude? do .... end
a = "hello there" a[1] a[1,3] a[1..3] a[6..-1] a[-3,2] a[-4..-2] a[12..-1] a[-2..-4] a[/[aeiou](.)\1/] a[/[aeiou](.)\1/, 0] a[/[aeiou](.)\1/, 1] a[/[aeiou](.)\1/, 2] a["lo"] a["bye"]
a = false || true => true a => true a = false or true => true a => false
download_file_via_fast_connection or download_via_slow_connection download_latest_currency_rates and store_them_in_the_cache
$ sudo vi /etc/paths /usr/local/bin /usr/local/sbin /usr/bin /bin /usr/sbin /sbin
export PATH="/usr/local/bin:/usr/local/sbin:~/bin:$PATH"
$ echo $PATH /usr/local/bin:/usr/local/sbin:/Users/<your account>/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin
echo export PATH="/usr/local/bin:$PATH" >> ~/.bash_profile
case ":$PATH:" in *:/usr/local/bin:*) ;; *) PATH=/usr/local/bin:$PATH ;; esac
def directory_exists?(directory) return false if Dir[directory] == nil true end
def directory_exists?(directory) File.directory?(directory) end
File.exists? => false File.directory? => false File.exists? File.expand_path( => true
class ApplicationController < ActionController::Base before_filter :set_cache_headers private def set_cache_headers response.headers["Cache-Control"] = "no-cache, no-store" response.headers["Pragma"] = "no-cache" response.headers["Expires"] = "Fri, 01 Jan 1990 00:00:00 GMT" end end
before_filter :reset_cache, if: :user_completed_demographics?
CGI.unescapeHTML "&lt;p&gt;This is a Paragraph.&lt;/p&gt;" => "<p>This is a Paragraph.</p>"
<%= content_tag translated_tag_type.to_sym, :class => " <%= translated_text %> <% end -%>
<%= "<center style=\"color: green; font-size: 1.1em\" > Administrators only </center>".html_safe if current_user.admin? % >
define_method(:say_hi) { |other| puts "Hi, " + other }
class Bar define_method(:foo) do |arg=nil| arg end end a = Bar.new a.foo a.foo 1
class Bar define_method(:foo) do |*arg| arg end end a = Bar.new a.foo a.foo 1 a.foo 1, 2 ,
class Bar define_method(:foo) do |bubla,*arg| p bubla p arg end end a = Bar.new a.foo a.foo 1 a.foo 1, 2 ,3 ,4
class Bar define_method(:foo) do |variable1, variable2,*arg, &block| p variable1 p variable2 p arg p block.inspect end end a = Bar.new a.foo :one, end
class Bar define_method(:foo) do |variable1, variable2,*arg,**options, &block| p variable1 p variable2 p arg p options p block.inspect end end a = Bar.new a.foo :one, end
class Bar define_method(:foo) do |variable1, color: p variable1 p color p other_options p block.inspect end end a = Bar.new a.foo :one, color: end
define_method(:foo) do |variable1, variable2,*arg, i_will_not:
define_method(:foo) do |variable1, variable2, i_will_not:
def meth(default = :foo, *splat, &block) puts define_method :meth { |default = :foo, *splat, &block| puts define_method :meth, ->(default = :foo, *splat, &block) { puts
define_method(:method) do |refresh: false| .......... end
def print_and_flush(str) print str $stdout.flush end 100.times do print_and_flush "." sleep 1 end
$stdout.sync = true 100.times do print "." sleep 1 end
a = ["A", "B", "C", "B", "A"] a.detect{ |e| a.count(e) > 1 }
def find_one_using_hash_map(array) map = {} dup = nil array.each do |v| map[v] = (map[v] || 0 ) + 1 if map[v] > 1 dup = v break end end return dup end
ary = ["A", "B", "C", "B", "A"] ary.group_by{ |e| e }.select { |k, v| v.size > 1 }.map(&:first) ary.sort.chunk{ |e| e }.select { |e, chunk| chunk.size > 1 }.map(&:first)
a = ["A", "B", "C", "B", "A"] a.find_all { |e| a.count(e) > 1 }
require def find_a_dup_using_set(arr) s = Set.new arr.find { |e| !s.add?(e) } end find_a_dup_using_set arr
class Array def difference(other) h = other.each_with_object(Hash.new(0)) { |e,h| h[e] += 1 } reject { |e| h[e] > 0 && h[e] -= 1 } end end def find_a_dup_using_difference(arr) arr.difference(arr.uniq).first end find_a_dup_using_difference arr
CAPS = ( def test_array(nelements, ndups) arr = CAPS[0, nelements-ndups] arr = arr.concat(arr[0,ndups]).shuffle end
require def benchmark(nelements, ndups) arr = test_array nelements, ndups puts "\n compare( Naveed: -> {arr.detect{|e| arr.count(e) > 1}}, Sergio: -> {(arr.inject(Hash.new(0)) {|h,e| h[e] += 1; h}.find {|k,v| v > 1} || [nil]).first }, Ryan: -> {(arr.group_by{|e| e}.find {|k,v| v.size > 1} || [nil]).first}, Chris: -> {arr.detect {|e| arr.rindex(e) != arr.index(e)} }, Cary_set: -> {find_a_dup_using_set(arr)}, Cary_diff: -> {find_a_dup_using_difference(arr)} ) end
benchmark(100, 0) 0 duplicates Running each test 64 times. Test will take about 2 seconds. Cary_set is similar to Cary_diff Cary_diff is similar to Ryan Ryan is similar to Sergio Sergio is faster than Chris by 4x ± 1.0 Chris is faster than Naveed by 2x ± 1.0 benchmark(100, 1) 1 duplicates Running each test 128 times. Test will take about 2 seconds. Cary_set is similar to Cary_diff Cary_diff is faster than Ryan by 2x ± 1.0 Ryan is similar to Sergio Sergio is faster than Chris by 2x ± 1.0 Chris is faster than Naveed by 2x ± 1.0 benchmark(100, 10) 10 duplicates Running each test 1024 times. Test will take about 3 seconds. Chris is faster than Naveed by 2x ± 1.0 Naveed is faster than Cary_diff by 2x ± 1.0 (results differ: AAC vs AAF) Cary_diff is similar to Cary_set Cary_set is faster than Sergio by 3x ± 1.0 (results differ: AAF vs AAC) Sergio is similar to Ryan
benchmark(10000, 0) 0 duplicates Running each test once. Test will take about 4 minutes. Ryan is similar to Sergio Sergio is similar to Cary_set Cary_set is similar to Cary_diff Cary_diff is faster than Chris by 400x ± 100.0 Chris is faster than Naveed by 3x ± 0.1 benchmark(10000, 1) 1 duplicates Running each test once. Test will take about 1 second. Cary_set is similar to Cary_diff Cary_diff is similar to Sergio Sergio is similar to Ryan Ryan is faster than Chris by 2x ± 1.0 Chris is faster than Naveed by 2x ± 1.0 benchmark(10000, 10) 10 duplicates Running each test once. Test will take about 11 seconds. Cary_set is similar to Cary_diff Cary_diff is faster than Sergio by 3x ± 1.0 (results differ: AAE vs AAA) Sergio is similar to Ryan Ryan is faster than Chris by 20x ± 10.0 Chris is faster than Naveed by 3x ± 1.0 benchmark(10000, 100) 100 duplicates Cary_set is similar to Cary_diff Cary_diff is faster than Sergio by 11x ± 10.0 (results differ: ADG vs ACL) Sergio is similar to Ryan Ryan is similar to Chris Chris is faster than Naveed by 3x ± 1.0
select {|item| block } → new_ary select → an_enumerator
count → int count(obj) → int count { |item| block } → int
a.select{|item| a.count(item) > 1}.uniq => ["A", "B"]
a = %w{the quick brown fox jumps over the lazy dog} h = Hash.new(0) a.find { |each| (h[each] += 1) == 2 }
arr = ["A", "B", "C", "B", "A"] arr.inject(Hash.new(0)) { |h,e| h[e] += 1; h }. select { |k,v| v > 1 }. collect { |x| x.first }
class ActiveRecordClass < ActiveRecord::Base end ActiveRecordClass.group(:email_address).having("count(*) > 1").count.keys
>> arr = ["A", "B", "C", "B", "A"] >> arr.find_all { |x| arr.count(x) > 1 } => ["A", "B", "B", "A"]
>> arr.find_all { |x| arr.count(x) > 1 }.uniq => ["A", "B"]
a = ["A", "B", "C", "B", "A"] a.each_with_object(Hash.new(0)) {|i,hash| hash[i] += 1}.select{|_, count| count > 1}.keys
a.each_with_object(Hash.new(0).merge dup: []){|x,h| h[:dup] << x if (h[x] += 1) == 2}[:dup] a.inject(Hash.new(0).merge dup: []){|h,x| h[:dup] << x if (h[x] += 1) == 2;h}[:dup]
h = {}; h = {} ps.select{ |e| ct = ps.count(e) h[e] = ct if ct > 1 }; nil
r = [1, 2, 3, 5, 1, 2, 3, 1, 2, 1] r.group_by(&:itself).map { |k, v| v.size > 1 ? [k] + [v.size] : nil }.compact.sort_by(&:last).map(&:first)
input = [:bla,:blubb,:bleh,:bla,:bleh,:bla,:blubb,:brrr] > input.each_with_object({}){|x,h| h[x] ||= 0; h[x] += 1} => {:bla=>3, :blubb=>2, :bleh=>2, :brrr=>1} > input.each_with_object({}){|x,h| h[x] ||= 0; h[x] += 1}.reject{|k,v| v < 2} => {:bla=>3, :blubb=>2, :bleh=>2}
a = ["A", "B", "C", "B", "A"] b = a.select {|e| a.count(e) > 1}.uniq c = a - b d = b + c
% rake test TEST=test/test_foobar.rb TESTOPTS="--name=test_foobar1 -v"
class Rake::TestTask def rake_loader end end Rake::TestTask.new {|i| i.test_files = FileList[ i.verbose = true }
-n, --name PATTERN Filter run on /pattern/ or string.
ruby spec/stories/foo_spec.rb --name 3 FAIL (0:00:00.022) test_0003_has foo Expected: "foo" Actual: nil
def plus_one_to_y(x) @y = x + 1 puts "In plus_one_to_y" end
def plus_one_to_y(x) @y = x + 1 puts "In plus_one_to_y" return @y end
def plus_one_to_y(x) @y = x + 1 puts "In plus_one_to_y" @y end
def some_func_which_returns_a_list( x, y, z) return nil if failed_some_early_check @list end
class Foo def bar? true end end foo = Foo.new foo.send(:bar?) foo.__send__(:bar?)
class Foo def bar? true end def send(*args) false end end foo = Foo.new foo.send(:bar?) foo.__send__(:bar?)
A, B, C = Module.new, Module.new, Module.new B.include A B.send :include, A C.public_send :include, A
class Person { public $name; public function setName($name) { $this->name = $name; } public function getName() { return $this->name; } }
class Person def set_name(name) @name = name end def get_name() @name end end
class Test @@shared = 1 def value @@shared end def value=(value) @@shared = value end end class AnotherTest < Test; end t = Test.new puts "t.value is t.value = 2 puts "t.value is x = Test.new puts "x.value is a = AnotherTest.new puts "a.value is a.value = 3 puts "a.value is puts "t.value is puts "x.value is
class Polygon class << self attr_accessor :sides end end class Triangle < Polygon @sides = 3 end class Rectangle < Polygon @sides = 4 end class Square < Rectangle end class Hexagon < Polygon @sides = 6 end puts "Triangle.sides: puts "Rectangle.sides: puts "Square.sides: puts "Hexagon.sides:
module A @a = @@a = def get1 @a end def get2 @@a end def set1(a) @a = a end def set2(a) @@a = a end def self.set1(a) @a = a end def self.set2(a) @@a = a end end
class X extend A puts get1.inspect puts get2.inspect @a = @@a = puts get1.inspect puts get2.inspect set1( set2( puts get1.inspect puts get2.inspect A.set1( A.set2( puts get1.inspect puts get2.inspect end class Y include A def doit puts get1.inspect puts get2.inspect @a = @@a = puts get1.inspect puts get2.inspect set1( set2( puts get1.inspect puts get2.inspect A.set1( A.set2( puts get1.inspect puts get2.inspect end end Y.new.doit
class Person @@people = [] def initialize @@people << self end def self.people @@people end end class Student < Person end class Graduate < Student end Person.new Student.new puts Graduate.people
class Person def initialize self.class.add_person self end def self.people @people end def self.add_person instance @people ||= [] @people << instance end end class Student < Person end class Graduate < Student end Person.new Person.new Student.new Student.new Graduate.new Graduate.new puts Student.people.join(",") puts Person.people.join(",") puts Graduate.people.join(",")
my_hash.each{ |_,str| str.gsub! /^|$/, my_hash.each{ |_,str| str.replace "%
my_hash.each{ |key,str| my_hash[key] = "% my_hash.inject(my_hash){ |h,(k,str)| h[k]="%
new_hash = Hash[*my_hash.map{|k,str| [k,"% new_hash = Hash[my_hash.map{|k,str| [k,"%
o = { a: o.merge!(o) { |key, value| "% puts o.inspect > { :a => "%a%", :b => "%b%" }
describe Hash do describe :map_values do it expect({:a => 2, :b => 3}.map_values { |x| x ** 2 }).to eq({:a => 4, :b => 9}) end end end
class Hash def map_values Hash[map { |k, v| [k, yield(v)] }] end end
break SomeClass break Foo break app/models/user.rb:15 break 14
@result = fetch_result p "--------------------------" p @result
= content_tag :div, :class => "post" + (" gray" unless post.published?).to_s do / Post stuff
= content_tag :div, :class => "post" + (post.published? ? "" : " gray") do / Post stuff
%div{:class => "post" + (" gray" unless post.published?).to_s} / Post stuff
- classes = ["post", ("gray" unless post.published?)] = content_tag :div, class: classes do /Post stuff
def post_tag post, &block classes = ["post", ("gray" unless post.published?)] content_tag :div, class: classes, &block end = post_tag post /Post stuff
%div{ :class => published_class(post) } def published_class(post) "post end
irb(main):001:0> foo="hello" => "hello" irb(main):002:0> %W(foo bar baz => ["foo", "bar", "baz", "hello"] irb(main):003:0> %w(foo bar baz => ["foo", "bar", "baz", "\
event_name = "load" def load() puts "load() function was executed." end def row_changed() puts "row_changed() function was executed." end
a = [2, 2, 3] a.send("length") a.public_send("length")
def load() puts "load() function was executed." end send( public_send(
> a = "my_string" > meth = a.method("size") > meth.call() => 9
method_object = s.method(:length) p method_object.call
require "benchmark" test = "hi man" m = test.method(:length) n = 100000 Benchmark.bmbm {|x| x.report("call") { n.times { m.call } } x.report("send") { n.times { test.send(:length) } } x.report("eval") { n.times { eval "test.length" } } }
require Benchmark.bmbm do |x| x.report( s = "" 10000.times { s += "something " } end x.report( s = "" 10000.times { s << "something " } end end
2.3.1 :001 > a = "hello" => "hello" 2.3.1 :002 > b = a => "hello" 2.3.1 :003 > b << " world" => "hello world" 2.3.1 :004 > a => "hello world"
2.3.1 :001 > a = "hello" => "hello" 2.3.1 :002 > b = a => "hello" 2.3.1 :003 > b += " world" => "hello world" 2.3.1 :004 > a => "hello"
"active_record".camelize "active_record".camelize(:lower)
class String def camel_case return self if self !~ /_/ && self =~ /[A-Z]+.*/ split( end end "foo_bar".camel_case
class String def camel_case_lower self.split( end end "foo_bar".camel_case_lower
user system total real capitalize and gsub : 0.360000 0.000000 0.360000 ( 0.357472) split and map, with &: 0.190000 0.000000 0.190000 ( 0.189493) split and map : 0.170000 0.000000 0.170000 ( 0.171859)
def snake_to_camel_case(str, mode: :class) case mode when :class str.split( when :method str.split( else raise "unknown mode end end
[28] pry(main)> snake_to_camel_case("asd_dsa_fds", mode: :class) => "AsdDsaFds" [29] pry(main)> snake_to_camel_case("asd_dsa_fds", mode: :method) => "asdDsaFds"
x="this_should_be_camel_case" x.gsub(/(?:_|^)(\w)/){$1.upcase}
class MultiSet attr_accessor :set def initialize(set) @set = set end def &(other) @set & other.set end def -(other) @set - other.set end def |(other) @set | other.set end end x = MultiSet.new([1,1,2,2,3,4,5,6]) y = MultiSet.new([1,3,5,6]) p x - y p x & y p x | y
x = [1, 1, 2, 4] y = [1, 2, 2, 2] x & y x | y x - y
x = [1, 1, 2, 4, 7] y = [1, 2, 2, 2] z = [1, 1, 3, 7]
metrics = {"sitea.com" => 745, "siteb.com" => 9, "sitec.com" => 10 }
metrics = {"sitea.com" => 745, "siteb.com" => 9, "sitec.com" => 10 } metrics.sort_by {|_key, value| value}
irb(main):001:0> metrics = {"sitea.com" => 745, "siteb.com" => 9, "sitec.com" => 10 } => {"siteb.com"=>9, "sitec.com"=>10, "sitea.com"=>745} irb(main):002:0> metrics.sort {|a1,a2| a2[1]<=>a1[1]} => [["sitea.com", 745], ["sitec.com", 10], ["siteb.com", 9]]
@arr = [ @arr.reduce(:+) => <p>Hello World</p><p>This is a test</p>
$ sudo gem install nokogiri -- --with-xml2-include=/usr/local/Cellar/libxml2/2.9.1/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.9.1/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.28 --with-iconv-include=/usr/local/Cellar/libiconv/1.14/include --with-iconv-lib=/usr/local/Cellar/libiconv/1.14/lib Building native extensions with: This could take a while... Building nokogiri using packaged libraries. ERROR: Error installing nokogiri: ERROR: Failed to build gem native extension. /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb --with-xml2-include=/usr/local/Cellar/libxml2/2.9.1/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.9.1/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.28 --with-iconv-include=/usr/local/Cellar/libiconv/1.14/include --with-iconv-lib=/usr/local/Cellar/libiconv/1.14/lib Building nokogiri using packaged libraries. checking for iconv.h... yes checking for iconv_open() in iconv.h... no checking for iconv_open() in -liconv... no checking for libiconv_open() in iconv.h... no checking for libiconv_open() in -liconv... no ----- libiconv is missing. please visit http: ----- *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options. Provided configuration options: --with-opt-dir --without-opt-dir --with-opt-include --without-opt-include=${opt-dir}/include --with-opt-lib --without-opt-lib=${opt-dir}/lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby --help --clean --use-system-libraries --enable-static --disable-static --with-zlib-dir --without-zlib-dir --with-zlib-include --without-zlib-include=${zlib-dir}/include --with-zlib-lib --without-zlib-lib=${zlib-dir}/lib --enable-cross-build --disable-cross-build Gem files will remain installed in /Library/Ruby/Gems/2.0.0/gems/nokogiri-1.6.2.1 for inspection. Results logged to /Library/Ruby/Gems/2.0.0/gems/nokogiri-1.6.2.1/ext/nokogiri/gem_make.out
gem install nokogiri -- --with-iconv-dir=/usr/local/Cellar/libiconv/1.14
bundle config build.nokogiri --use-system-libraries
brew install libxml2 brew link libxml2 wget ftp: tar -zxvf libxslt-1.1.26.tar.gz cd libxslt-1.1.26 ./configure --prefix=/usr/local/Cellar/libxslt/1.1.26 --with-libxml-prefix=/usr/local/Cellar/libxml2/2.7.8 make sudo make install
gem install nokogiri -- --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26
gem install nokogiri -- --with-xslt-lib=/usr/local/Cellar/libxslt/1.1.26/lib --with-xslt-include=/usr/local/Cellar/libxslt/1.1.26/include/libxslt
gem install nokogiri -- --with-xslt-lib=/usr/local/Cellar/libxslt/1.1.26/lib --with-xslt-include=/usr/local/Cellar/libxslt/1.1.26/include/libxslt --with-iconv-dir=/usr/local/Cellar/libiconv/1.14 --with-xml2-dir=/usr/local/Cellar/libxml2/2.7.8
in /opt/local/lib/libz.1.dylib, file was built for unsupported file format which is not the architecture being linked (x86_64) for architecture x86_64
gem install nokogiri -- --with-xslt-lib=/usr/local/Cellar/libxslt/1.1.26/lib --with-xslt-include=/usr/local/Cellar/libxslt/1.1.26/include/libxslt --with-iconv-dir=/usr/local/Cellar/libiconv/1.14 --with-xml2-dir=/usr/local/Cellar/libxml2/2.7.8
sudo env ARCHFLAGS="-arch x86_64" gem install nokogiri -- --use-system-libraries
wget http: tar xvfz libiconv-1.13.1.tar.gz cd libiconv-1.13.1 ./configure --prefix=/usr/local/Cellar/libiconv/1.13.1 make sudo make install
gem install nokogiri -- --with-xml2-include=/usr/local/Cellar/libxml2/2.8.0/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.8.0/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26 --with-iconv-include=/usr/local/Cellar/libiconv/1.13.1/include --with-iconv-lib=/usr/local/Cellar/libiconv/1.13.1/lib
$ gem install nokogiri -- --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26 --with-xml2-dir=/usr/local/Cellar/libxml2/2.7.8/
$ gem install nokogiri -- --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26 --with-xml2-dir=/usr/local/Cellar/libxml2/2.7.8/
$ bundle config build.nokogiri --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26 --with-xml2-dir=/usr/local/Cellar/libxml2/2.7.8/ --with-iconv-dir=/usr/local/Cellar/libiconv/1.14
╰─% cat .bundle/config --- BUNDLE_PATH: vendor/bundle BUNDLE_DISABLE_SHARED_GEMS: BUNDLE_JOBS: 4 ╰─% which ruby bundle gem ~/.rbenv/shims/ruby ~/.rbenv/shims/bundle ~/.rbenv/shims/gem
brew install libxml2 libxslt brew link libxml2 libxslt wget http: tar xvfz libiconv-1.13.1.tar.gz cd libiconv-1.13.1 ./configure --prefix=/usr/local/Cellar/libiconv/1.13.1 make sudo make install sudo ln -s /usr/bin/gcc /usr/bin/gcc-4.2 gem install nokogiri -- --with-xml2-include=/usr/local/Cellar/libxml2/2.9.0/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.9.0/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.28 --with-iconv-include=/usr/local/Cellar/libiconv/1.13.1/include --with-iconv-lib=/usr/local/Cellar/libiconv/1.13.1/lib
gem install nokogiri -- --with-iconv-dir=/opt/local
... CXX=/usr/local/opt/apple-gcc42/bin/g++-4.2 ... CC=/usr/local/opt/apple-gcc42/bin/gcc-4.2 ...
Installing nokogiri (1.6.2.1) Building nokogiri using packaged libraries. Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension. /usr/local/rvm/rubies/ruby-2.0.0-p0/bin/ruby extconf.rb Building nokogiri using packaged libraries. checking for iconv.h... yes checking for iconv_open() in iconv.h... no checking for iconv_open() in -liconv... no checking for libiconv_open() in iconv.h... no checking for libiconv_open() in -liconv... no ----- libiconv is missing. please visit http: ----- *** extconf.rb failed ***
brew unlink gcc-4.2 gem uninstall nokogiri xcode-select --install gem install nokogiri
xcode-select --install brew uninstall libiconv brew install libiconv gem install nokogiri
brew uninstall libiconv brew uninstall libxml2 brew uninstall libxslt
CC=gcc-4.2 rvm install 1.9.2-p290 --with-iconv-dir=/usr/local/Cellar/libiconv/1.13.1
gem install nokogiri -v=1.4.4 -- --with-xml2-include=/usr/local/Cellar/libxml2/2.7.8/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.7.8/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26
gem install nokogiri -- --with-xml2-lib=/usr/local/lib --with-xml2-include=/usr/local/include/libxml2 --with-xslt-lib=/usr/local/lib --with-xslt-include=/usr/local/include
$ gem install iconv $ ls -1 2.0.0-p0/lib/ruby/gems/2.0.0/gems/iconv-1.0.3/*/*/*.so 2.0.0-p0/lib/ruby/gems/2.0.0/gems/iconv-1.0.3/ext/iconv/iconv.so* 2.0.0-p0/lib/ruby/gems/2.0.0/gems/iconv-1.0.3/lib/iconv/iconv.so* $ ls -1 2.0.0-p247/lib/ruby/gems/2.0.0/gems/iconv-1.0.3/*/*/*.so 2.0.0-p247/lib/ruby/gems/2.0.0/gems/iconv-1.0.3/ext/iconv/iconv.so*
$ rbenv version 2.0.0-p247 (set by /home/XXX/tmp/.ruby-version) $ rbenv which gem /home/XXX/.rbenv/versions/2.0.0-p247/bin/gem $ gem --version 1.8.25 $ rbenv which pry /home/XXX/.rbenv/versions/2.0.0-p247/bin/pry $ pry [1] pry(main)> require LoadError: cannot load such file -- iconv/iconv.so from /home/XXX/.rbenv/versions/2.0.0-p247/lib/ruby/site_ruby/2.0.0/rubygems/custom_require.rb:36:in `require'
$ pushd ~/.rbenv/versions/ $ cp 2.0.0-p247/lib/ruby/gems/2.0.0/gems/iconv-1.0.3/ext/iconv/iconv.so 2.0.0-p247/lib/ruby/gems/2.0.0/gems/iconv-1.0.3/lib/iconv/
To allow the nokogiri gem to link against this libxslt run: gem install nokogiri -- --with-xslt-dir=/usr/local/opt/libxslt
bundle config build.nokogiri --use-system-libraries bundle install
<% @posts.each do |post| %> <% render middle %> <% end %>
<% @posts.each do |post| %> <% render middle, :post => post %> <% end %>
2.4.0 :004 > puts Hello \n World 2.4.0 :005 > puts "Hello \n World" Hello World
2.4.0 :008 > age=27 => 27 2.4.0 :009 > puts Age: 2.4.0 :009 > puts "Age: Age: 27
params.delete(:controller) params.delete(:action) params.delete(:other_key) redirect_to my_path(params)
[:controller, :action, :other_key].each do |k| params.delete(k) end
redirect_to my_path(params.except(:controller, :action, :other_key))
params.slice!(:param_to_remove_1, :param_to_remove_2) redirect_to my_path(params)
[:controller, :action, :other_key].each { |k| params.delete(k) }
params.delete_if { |k,v| [:controller, :action, :other_key].include? k }
class Hash def delete_keys!(*keys) keys.flatten.each do |k| delete(k) end self end def delete_keys(*keys) _dup = dup keys.flatten.each do |k| _dup.delete(k) end _dup end end
>> 2.3465.round => 2 >> 2.3465.round(2) => 2.35 >> 2.3465.round(3) => 2.347
class Float def precision(p) raise ArgumentError, " return self.round if p == 0 return (self * 10**p).round.to_f / 10**p end end
salary= 2921.9121 puts salary.to_f.round(2) puts salary.to_f.round()
def rounding(float,precision) return ((float * 10**precision).round.to_f) / (10**precision) end
class Float alias oldround:round def round(precision = nil) if precision.nil? return self else return ((self * 10**precision).oldround.to_f) / (10**precision) end end end
some_int = 5 some_int.to_s.rjust(2, some_int.to_s.rjust(5, another_int = 150 another_int.to_s.rjust(2, another_int.to_s.rjust(3, another_int.to_s.rjust(5,
2.0.0-p247 :001 > => "01" 2.0.0-p247 :002 > => " 1" 2.0.0-p247 :003 > => "1 "
def numeric92(num) if num.present? if num < 0 && num > -1 ( else ( end else end end
cheeses = %w(chedder stilton brie mozzarella feta haloumi) foods = %w(pizza feta foods bread biscuits yoghurt bacon) puts cheeses.collect{|c| foods.include?(c)}.include?(true) puts (cheeses - foods).size < cheeses.size
>> cheeses = %w(chedder stilton brie mozzarella feta haloumi) => ["chedder", "stilton", "brie", "mozzarella", "feta", "haloumi"] >> foods = %w(pizza feta foods bread biscuits yoghurt bacon) => ["pizza", "feta", "foods", "bread", "biscuits", "yoghurt", "bacon"] >> foods.any? {|food| cheeses.include?(food) } => true
require "benchmark" N = 1_000_000 puts "ruby version: CHEESES = %w(chedder stilton brie mozzarella feta haloumi).freeze FOODS = %w(pizza feta foods bread biscuits yoghurt bacon).freeze Benchmark.bm(15) do |b| b.report("&, empty?") { N.times { (FOODS & CHEESES).empty? } } b.report("any?, include?") { N.times { FOODS.any? {|food| CHEESES.include?(food) } } } end
ruby version: 2.1.9 user system total real &, empty? 1.170000 0.000000 1.170000 ( 1.172507) any?, include? 0.660000 0.000000 0.660000 ( 0.666015)
cheeses = %w(chedder stilton brie mozzarella feta haloumi) foods = %w(pizza feta foods bread biscuits yoghurt bacon) foods & cheeses => ["feta"] (foods & cheeses).empty? => false
User.new({:email => "guy@gmail.com", :roles => ["admin"], :password => "111111", :password_confirmation => "111111" }).save(false)
User.create!({:email => "guy@gmail.com", :roles => ["admin"], :password => "111111", :password_confirmation => "111111" })
u = User.new(:email => "user@name.com", :password => u.save
newuser = User.new({email: newuser.skip_confirmation! newuser.save
newuser = User.new({email: newuser.confirm! newuser.save
u = User.new({ email: password: password_confirmation: }) u.confirm! u.save
User.create(email: "a@a.com", password: "asdasd", password_confirmation: "asdasd")
require def pull_picture(picture) Aws.config = { :access_key_id => ENV["AWS_ACCESS_KEY_ID"], :secret_access_key => ENV["AWS_SECRET_ACCESS_KEY"], :region => } s3 = Aws::S3::Client.new test = s3.get_object( :bucket => ENV["AWS_S3_BUCKET"], :key => picture.image_url.split( ) end
:storage => :s3, :s3_credentials => {:access_key_id => access key, :secret_access_key => secret access key}, :bucket => bucket name here, :s3_host_name => s3-us-west-1.amazonaws.com or whatever comes as per your region}.
def do_division_by_zero; 5 / 0; end begin do_division_by_zero rescue => exception puts exception.backtrace raise end
begin rescue => e puts "Error during processing: puts "Backtrace:\n\t end
begin; Whatever.you.want; rescue => e; puts e.message; puts; puts e.backtrace; end
begin; Whatever.you.want; rescue => e; puts e.message; puts; puts e.backtrace.grep_v(/\/gems\
begin; Whatever.you.want; rescue => e; puts e.message; puts; puts e.backtrace.grep_v(/\/gems\
begin 0/0 rescue => e puts e.backtrace.join("\n\t") .sub("\n\t", ": end
begin class ActiveSupport::TestCase end rescue => e puts e.backtrace end
rescue Object => boom thread_count = 0 Thread.list.each do |t| thread_count += 1 err_msg += "--- thread err_msg += t.backtrace.join("\n") err_msg += "\n---thread end $stderr.puts(err_msg) raise end
require begin rescue StandardError => e puts Backtrace.new(e) end
describe SomeContext do it "won raise "never reached" end it "will run this", :focus => true do 1.should == 1 end end $ rspec --tag focus spec/my_spec.rb
RSpec.configure do |config| config.filter_run focus: true config.run_all_when_everything_filtered = true end
Run options: include {:locations=>{"./spec/models/company_spec.rb"=>[81, 82, 83, 103]}}
RSpec.configure do |c| c.filter_run focus: true c.run_all_when_everything_filtered = true end
RSpec.configure do |c| c.filter_run_when_matching :focus end RSpec.configure do |c| c.filter_run focus: true c.run_all_when_everything_filtered = true end
> ERROR: While executing gem ... (Errno::EPERM) Operation not permitted
gem "foreman", git: "git: gem "foreman", git: "git: gem "foreman", git: "git: gem "foreman", git: "git:
mkdir repo mkdir repo/gems cp *.gem repo/gems cd repo gem generate_index
gem unpack your.gem --target /path_to_app/vendor/gems/
irb(main):001:0> require => true irb(main):002:0> Benchmark.realtime { 1.upto(10000000) { "foobar"[/\Afoo/] }} => 12.477248 irb(main):003:0> Benchmark.realtime { 1.upto(10000000) { "foobar" =~ /\Afoo/ }} => 9.593959 irb(main):004:0> Benchmark.realtime { 1.upto(10000000) { "foobar"["foo"] }} => 9.086909 irb(main):005:0> Benchmark.realtime { 1.upto(10000000) { "foobar".start_with?("foo") }} => 6.973697
require Benchmark.bm do |x| x.report( x.report( x.report( x.report( end user system total real regex[] 4.020000 0.000000 4.020000 ( 4.024469) regex 3.160000 0.000000 3.160000 ( 3.159543) [] 2.930000 0.000000 2.930000 ( 2.931889) start_with 2.010000 0.000000 2.010000 ( 2.008162)
. |-- application.css |-- application.js |-- index.html |-- jquery.js `-- myapp.rb
require get send_file File.join(settings.public_folder, end
. -- myapp.rb `-- public |-- application.css |-- application.js |-- index.html `-- jquery.js
require require get html :index end def html(view) File.read(File.join( end
user@user-SVE1411EGXB:~/sintra1$ ls index.rb public user@user-SVE1411EGXB:~/sintra1$ find public/ public/ public/index.html public/about_us.html public/contact.html public/fonts public/fonts/fontawesome-webfont.svg public/fonts/fontawesome-webfont.ttf public/img public/img/drink_ZIDO.jpg public/js public/js/bootstrap.min.js public/js/jquery.min.js public/js/bootstrap.js public/carsoul2.html public/css public/css/font-awesome-ie7.css public/css/bootstrap.min.css public/css/font-awesome.min.css public/css/bootstrap.css public/css/font-awesome.css public/css/style.css user@user-SVE1411EGXB:~/sintra1$
user@user-SVE1411EGXB:~/sintra1$ ruby index.rb == Sinatra/1.4.5 has taken the stage on 4567 for development with backup from Thin >> Thin web server (v1.5.1 codename Straight Razor) >> Maximum connections set to 1024 >> Listening on localhost:4567, CTRL+C to stop
require require set :public_folder, File.dirname(__FILE__) + get "/" do File.read( end
get "/subdirectory/:file" do file = params[:file] + "index.html" if File.exists?(params[:file]) return File.open("subdirectory/" + file) else return "error" end end
rvm system env > before rvm jruby env > after diff after before
< GEM_HOME=$HOME/.gem/ruby/1.9.1 --- > GEM_HOME=$HOME/.rvm/gems/jruby-1.6.6 < GEM_PATH=$HOME/.gem/ruby/1.9.1 --- > GEM_PATH=$HOME/.rvm/gems/jruby-1.6.6:$HOME/.rvm/gems/jruby-1.6.6@global *bunch of rvm_* > MY_RUBY_HOME=$HOME/.rvm/rubies/jruby-1.6.6 > RUBY_VERSION=jruby-1.6.6 > IRBRC=$HOME/.rvm/rubies/jruby-1.6.6/.irbrc
$HOME/.rvm/gems/jruby-1.6.6/bin:$HOME/.rvm/gems/jruby-1.6.6@global/bin
static VALUE rb_ary_length(VALUE ary) { long len = RARRAY_LEN(ary); return LONG2NUM(len); }
static VALUE rb_ary_count(int argc, VALUE *argv, VALUE ary) { long n = 0; if (argc == 0) { VALUE *p, *pend; if (!rb_block_given_p()) return LONG2NUM(RARRAY_LEN(ary)); } }
<%= h(params.size.to_s) %> <%= h(params.count.to_s) %>
array = [1,2,3,4,5,6,7,4,3,2,4,5,6,7,1,2,4] array.size array.length array.count
class Test def self.foo Fooz.bar end end class Fooz def self.bar end end
module CallChain def self.caller_method(depth=1) parse_caller(caller(depth+1).first).last end private def self.parse_caller(at) if /^(.+?):(\d+)(?::in `(.*) file = Regexp.last_match[1] line = Regexp.last_match[2].to_i method = Regexp.last_match[3] [file, line, method] end end end
range = Xs.new(1)..Xs.new(10) range.step(2) {|x| puts x} range.step(3) {|x| puts x}
1 x 3 xxx 5 xxxxx 7 xxxxxxx 9 xxxxxxxxx 1 x 4 xxxx 7 xxxxxxx 10 xxxxxxxxxx
def method(a); end; def method(a, b = true); end; method(10)
def my_method(arg1) .. end def my_method(arg1, arg2) .. end
def my_method(*args) if args.length == 1 else end end
def my_method(options) if options[:arg1] and options[:arg2] elsif options[:arg1] end end my_method arg1:
def f(n, s = ... end def f(*args) case args.size when ... when 2 ... when 3 ... end end
class Factorial include Contracts Contract 1 => 1 def fact(x) x end Contract Num => Num def fact(x) x * fact(x - 1) end end Factorial.new.fact(5)
def method(param) case param when String method_for_String(param) when Type1 method_for_Type1(param) ... else end end
foo = "0.0.0.0" goo = "here is some other stuff 0.0.0.0" if goo =~ /value of foo here dynamically/ puts "success!" end
IP_REGEX = my_str = "192.0.89.234 blahblah text 1.2, 1.4" my_str.gsub!(/ puts my_str
foo = "0.0.0.0" goo = "here is some other stuff 0.0.0.0" puts "success!" if goo =~ /
{a: 1, b: 2, c: 2}.key(2) => :b {a: 1, b: 2, c: 2}.invert => {1=>:a, 2=>:c}
class Hash def safe_invert each_with_object({}) do |(key,value),out| out[value] ||= [] out[value] << key end end end
class Hash def safe_invert self.each_with_object({}){|(k,v),o|(o[v]||=[])<<k} end end
{a: :one, b: :two, c: :three}.invert => {:one=>:a, :two=>:b, :three=>:c}
class Hash def inverse i = Hash.new self.each_pair{ |k,v| if (v.class == Array) v.each{ |x| i[x] = i.has_key?(x) ? [k,i[x]].flatten : k } else i[v] = i.has_key?(v) ? [k,i[v]].flatten : k end } return i end end
h = {a: 1, b: 2, c: 2} h.inverse => {1=>:a, 2=>[:c, :b]} h.inverse.inverse => {:a=>1, :c=>2, :b=>2} h.inverse.inverse == h => true
h.invert => {1=>:a, 2=>:c} h.invert.invert == h => false
input = {:key1=>"value1", :key2=>"value2", :key3=>"value3", :key4=>"value4", :key5=>"value5"} output = Hash[input.to_a.map{|m| m.reverse}]
input = {:key1=>"value1", :key2=>"value2", :key3=>"value3", :key4=>"value4", :key5=>"value5"} output = input.invert
files = { } h = Hash.new{|h,k| h[k] = []} files.map {|k,v| h[v]<< k} puts h
> {a: 1, b: 2, c: 3}.invert => {1=>:a, 2=>:b, 3=>:c}
> {a: 1, b: 2, c: 3, d: 3, e: 2, f: 1}.invert => {1=>:f, 2=>:e, 3=>:d}
> hash={a: 1, b: 2, c: 3, d: 3, e: 2, f: 1} > hash.each_with_object(Hash.new { |h,k| h[k]=[] }) {|(k,v), h| h[v] << k } => {1=>[:a, :f], 2=>[:b, :e], 3=>[:c, :d]}
> hash={ "A" => [14, 15, 16], "B" => [17, 15], "C" => [35, 15] } > hash.each_with_object(Hash.new { |h,k| h[k]=[] }) {|(k,v), h| v.map {|t| h[t] << k} } => {14=>["A"], 15=>["A", "B", "C"], 16=>["A"], 17=>["B"], 35=>["C"]}
array_with_three_elements: - 1 - 2 - 3 empty_array:
$ convert --version Version: ImageMagick 6.9.5-9 Q16 x86_64 2016-09-09
$ gem install rmagick -v 2.16.0 Building native extensions. This could take a while... ERROR: Error installing rmagick: ERROR: Failed to build gem native extension. checking for /usr/local/opt/gcc46/bin/gcc-4.6... yes checking for Magick-config... yes checking for outdated ImageMagick version (<= 6.4.9)... no checking for presence of MagickWand API (ImageMagick version >= 6.9.0)... no checking for Ruby version >= 1.8.5... yes checking for stdint.h... no checking for sys/types.h... no checking for wand/MagickWand.h... no Can
find /usr/local -name MagickWand.h => /usr/local/Cellar/imagemagick/6.9.5-9_1/include/ImageMagick-6/wand/MagickWand.h find /usr/local -name MagickWand.pc => /usr/local/Cellar/imagemagick/6.9.5-9_1/lib/pkgconfig/MagickCore.pc
C_INCLUDE_PATH=/usr/local/Cellar/imagemagick/6.9.5-9_1/include/ImageMagick-6 PKG_CONFIG_PATH=/usr/local/lib/pkgconfig gem install rmagick
brew unlink imagemagick brew install imagemagick@6 && brew link imagemagick@6 --force
brew uninstall imagemagick brew install imagemagick@6 brew link imagemagick@6 --force
brew install imagemagick@6 && brew link imagemagick@6 --force
brew uninstall imagemagick brew install imagemagick@6 brew link imagemagick@6 --force
% brew unlink imagemagick && brew link imagemagick Unlinking /usr/local/Cellar/imagemagick/7.0.4-4... 71 symlinks removed Linking /usr/local/Cellar/imagemagick/7.0.4-4... 71 symlinks created % gem install rmagick Building native extensions. This could take a while... ERROR: Error installing rmagick: ERROR: Failed to build gem native extension. /Users/holger/.rbenv/versions/2.2.2/bin/ruby -r ./siteconf20170116-21103-1aikaka.rb extconf.rb checking for clang... yes checking for Magick-config... no checking for pkg-config... yes checking for outdated ImageMagick version (<= 6.4.9)... no checking for presence of MagickWand API (ImageMagick version >= 6.9.0)... no checking for Ruby version >= 1.8.5... yes checking for stdint.h... yes checking for sys/types.h... yes checking for wand/MagickWand.h... no Can
% brew switch imagemagick 6.9.7-3 Cleaning /usr/local/Cellar/imagemagick/6.9.6-6 Cleaning /usr/local/Cellar/imagemagick/6.9.7-0 Cleaning /usr/local/Cellar/imagemagick/6.9.7-1 Cleaning /usr/local/Cellar/imagemagick/6.9.7-3 Cleaning /usr/local/Cellar/imagemagick/7.0.4-4 75 links created for /usr/local/Cellar/imagemagick/6.9.7-3
% gem install rmagick Building native extensions. This could take a while... Successfully installed rmagick-2.16.0 1 gem installed
brew unlink imagemagick brew install imagemagick@6 && brew link imagemagick@6 --force export PKG_CONFIG_PATH=/usr/local/Cellar/imagemagick@6/6.9.9-24/lib/pkgconfig gem install rmagick -v
$ brew remove imagemagick && brew install imagemagick $ brew uninstall pkg-config && brew install pkg-config $ brew unlink pkg-config && brew link pkg-config $ gem install rmagick
brew install pkg-config brew uninstall imagemagick brew install imagemagick@6 brew link imagemagick@6 --force
$ gem install rmagick Building native extensions. This could take a while... Successfully installed rmagick-2.16.0 Parsing documentation for rmagick-2.16.0 Installing ri documentation for rmagick-2.16.0 Done installing documentation for rmagick after 4 seconds 1 gem installed
cd /usr/local/Cellar/imagemagick/7.0.7-1/include/ImageMagick-7 ln -s MagickWand/ wand ln -s MagicCore/ magick
brew install imagemagick@6 LDFLAGS="-L/usr/local/opt/imagemagick@6/lib" CPPFLAGS="-I/usr/local/opt/imagemagick@6/include" PKG_CONFIG_PATH="/usr/local/opt/imagemagick@6/lib/pkgconfig" gem install rmagick
wget http: tar -xvf <path_to_your_downloaded_file>.tar.gz
7z x <path_to_your_downloaded_file>.7z cd <path_to_your_downloaded_file>/ make ./configure sudo make install sudo ldconfig /usr/local/lib
$ brew info imagemagick imagemagick: stable 7.0.7-8 (bottled), HEAD Tools and libraries to manipulate images in many formats https: /usr/local/Cellar/imagemagick/6.9.1-10 (1,450 files, 17.5MB) Poured from bottle on 2015-07-26 at 09:10:58 /usr/local/Cellar/imagemagick/7.0.6-9 (1,522 files, 22.8MB) Poured from bottle on 2017-08-21 at 14:44:16 From: https:
PKG_CONFIG_PATH=/usr/local/Cellar/imagemagick/6.9.1-10/lib/pkgconfig \ gem install rmagick -v --with-opt-lib=/usr/local/Cellar/imagemagick/6.9.1-10/lib/ \ --with-opt-include=/usr/local/Cellar/imagemagick/6.9.1-10/include/ImageMagick-6/
context do setup { do_some_setup() } should "do somthing" do end end
context { setup { do_some_setup() } should("do somthing") { } }
puts [1,2,3].map{ |k| k+1 } 2 3 4 => nil puts [1,2,3].map do |k| k+1; end => nil
module I18n extend Module.new { old_translate=I18n.method(:translate) define_method(:translate) do |*args| InplaceTrans.translate(old_translate, *args) end alias :t :translate } end module InplaceTrans extend Module.new { def translate(old_translate, *args) Translator.new.translate(old_translate, *args) end } end
module I18n extend Module.new do old_translate=I18n.method(:translate) define_method(:translate) do |*args| InplaceTrans.translate(old_translate, *args) end alias :t :translate end end
extend Module.new {} evolves to extend(Module.new {})
extend Module.new do/end evolves to extend(Module.new) do/end
module I18n extend(Module.new do old_translate=I18n.method(:translate) define_method(:translate) do |*args| InplaceTrans.translate(old_translate, *args) end alias :t :translate end) end
[ 1, 2, 3 ].map { |e| e + 1 } [ 1, 2, 3 ].map do |e| e + 1 end [ 1, 2, 3 ].each_with_object [] do |e, o| o << e + 1 end [ 1, 2, 3 ].each_with_object( [] ) { |e, o| o << e + 1 } Foo = Module.new do include Comparable end Foo = Module.new { include Comparable } Foo = Module.new { include Comparable } Foo = module.new do include Comparable end [ [ 1 ], [ 1, 2 ] ].map { |e| e.map do |e| e + 1 end } [ [ 1 ], [ 1, 2 ] ].map { |e| e.map { |e| e + 1 } }
Foo = Module.new { if true then Bar = Module.new { def quux "quux".tap do |string| puts "( end end } end }
Thing.first(:order => "RANDOM()") Thing.order("RANDOM()").first
Thing.first(:offset => rand(Thing.count)) Thing.offset(rand(Thing.count)).first
select * from my_table where id >= trunc( random() * (select max(id) from my_table) + 1 ) order by id limit 1;
+----+-------------+-------+------+---------------+------+---------+------+--------+---------------------------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+--------+---------------------------------+ | 1 | SIMPLE | users | ALL | NULL | NULL | NULL | NULL | 110165 | Using temporary; Using filesort | +----+-------------+-------+------+---------------+------+---------+------+--------+---------------------------------+
users = User.scoped.select(:id);nil User.find( users.first( Random.rand( users.length )).last )
+----+-------------+-------+-------+---------------+--------------------------+---------+------+--------+-------------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+-------+---------------+--------------------------+---------+------+--------+-------------+ | 1 | SIMPLE | users | index | NULL | index_users_on_user_type | 2 | NULL | 110165 | Using index | +----+-------------+-------+-------+---------------+--------------------------+---------+------+--------+-------------+ +----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+ | 1 | SIMPLE | users | const | PRIMARY | PRIMARY | 4 | const | 1 | | +----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
users_count = User.count User.scoped.limit(1).offset(rand(users_count)).first
SELECT COUNT(*) FROM `users` SELECT `users`.* FROM `users` LIMIT 1 OFFSET 148794
module ActiveRecord class Base def self.random if (c = count) != 0 find(:first, :offset =>rand(c)) end end end end
module ActiveRecord class Base def self.random order("RAND()") end end end
def self.random ids = connection.select_all("SELECT id FROM things") find(ids[rand(ids.length)]["id"].to_i) unless ids.blank? end
thing_ids = Thing.find( :all, :select => @things = Thing.find( (1..10).map { thing_ids.delete_at( thing_ids.size * rand ) } )
module ActiveRecord class Base def self.sample offset(rand(size)).first end end end
@quotes = Quote.offset(rand(Quote.count - 3)).limit(3)
module Randomable extend ActiveSupport::Concern class_methods do def random(the_count = 1) records = offset(rand(count - the_count)).limit(the_count) the_count == 1 ? records.first : records end end end
class Book < ActiveRecord::Base include Randomable end
def get_random_things_for_home_page find(:all).sample(5) end
SELECT * FROM users ORDER BY DBMS_RANDOM.VALUE WHERE ROWNUM <= 10
@question1 = Question.where(:lesson_id => params[:lesson_id]).shuffle[1]
def stats(fb_post_url) url = BASE_URI + "?query= parsed_url = URI.parse(url) http = Net::HTTP.new(parsed_url.host, parsed_url.port) request = Net::HTTP::Get.new(parsed_url.request_uri) response = http.request(request) response.inspect end
EOFError: end of file reached from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/protocol.rb:135:in `sysread' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/protocol.rb:135:in `rbuf_fill' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/timeout.rb:67:in `timeout' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/timeout.rb:101:in `timeout' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/protocol.rb:134:in `rbuf_fill' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/protocol.rb:116:in `readuntil' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/protocol.rb:126:in `readline' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/http.rb:2028:in `read_status_line' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/http.rb:2017:in `read_new' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/http.rb:1051:in `request' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/http.rb:1037:in `request' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/http.rb:543:in `start' from /home/rahul/.rvm/rubies/ruby-1.8.7-p302/lib/ruby/1.8/net/http.rb:1035:in `request' from /home/rahul/Work/Radr/lib/fb_stats.rb:13:in `stats' from (irb):10
parsed_url = URI.parse(url) http = Net::HTTP.new(parsed_url.host, parsed_url.port) http.use_ssl = true
url = URI.parse(domain) req = Net::HTTP::Post.new(url.request_uri) req.set_form_data({ http = Net::HTTP.new(url.host, url.port) http.use_ssl = (url.scheme == "https") response = http.request(req)
@http = Net::HTTP.new( @http = @http.start url = req = Net::HTTP::Get.new(URI.encode(url)) req.basic_auth USERNAME, API_KEY res = @http.request(req)
res = timeout(120) { Net::HTTP.post_form(uri, args) }
req_profilepic = ActiveSupport::JSON.decode(open(URI.encode("https: profilepic_url = req_profilepic[
con = Mysql.real_connect("host", "user", "pw", "current_db")
config = Rails.configuration.database_configuration host = config[Rails.env]["host"] database = config[Rails.env]["database"] username = config[Rails.env]["username"] password = config[Rails.env]["password"]
require info = YAML::load(IO.read("database.yml")) print info["production"]["host"] print info["production"]["database"] ...
>> Rails.configuration.database_configuration[Rails.env] => {"encoding"=>"unicode", "username"=>"postgres", "adapter"=>"postgresql", "port"=>5432, "host"=>"localhost", "password"=>"postgres", "database"=>"mydb", "pool"=>5}
=> {:adapter=>ADAPTER_NAME, :host=>HOST, :port=>PORT, :database=>DB, :pool=>POOL, :username=>USERNAME, :password=>PASSWORD}
<% require c=ParseConfig.new( mysqlevn: &mysql adapter: mysql username: <%= c.params[ password: <%= c.params[ host: localhost socket: <%= [ production: database: app_production <<: *mysql development: database: app_development <<: *mysql test: database: app_test <<: *mysql
i=0 for blah in blahs puts i.to_s + " " + blah i+=1 end
blahs.each_with_index.map { |blah, index| something(blah, index)} blahs.map.with_index { |blah, index| something(blah, index) }
[:a, :b, :c].each_with_index do |item, i| puts "index: end
hash = Hash.new %w(cat dog wombat).each_with_index {|item, index| hash[item] = index } hash
blahs = %w{one two three four five} puts (1..blahs.length).zip(blahs).map{|pair|
range = ( length = range.length - 1 range.each_with_index do |letter, index| print letter + " " if index == length puts "You are at last item" end end
a b c d e f g h i j k l m n o p q r s t u v w x y z You are at last item
class AuthenticationError < StandardError; end class InvalidUsername < AuthenticationError; end
module GemName class AuthenticationError < StandardError; end class InvalidUsername < AuthenticationError; end end
module Exceptions class AuthenticationError < StandardError; end class InvalidUsername < AuthenticationError; end end
module AppName module Error class Base < StandardError; end end end
module AppName module Error class BadStuff < ::AppName::Error::Base; end end end
raise AppName::Error::BadStuff.new("Bad stuff just happened")
class MyClass class MissingRequirement < StandardError; end def my_instance_method raise MyClass::MissingRequirement, "My error msg" unless true end end
test "should raise MissingRequirement if ____ is missing" error = assert_raises(MyClass::MissingRequirement) { MyClass.new.my_instance_method } assert error.message = "My error msg" end
def MyModel < ActiveRecord::Base validate :code_does_not_contain_hyphens def code_does_not_contain_hyphens errors.add(:code, "cannot contain hyphens") if code.include?("-") end end
/usr/local/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `gem_original_require from /usr/local/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `require' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/spec_fetcher.rb:1 from /usr/local/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `gem_original_require' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `require' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/commands/update_command.rb:5 from /usr/local/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `gem_original_require' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `require' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/command_manager.rb:167:in `load_and_instantiate' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/command_manager.rb:88:in `[]' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/command_manager.rb:144:in `find_command' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/command_manager.rb:131:in `process_args' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/command_manager.rb:102:in `run' from /usr/local/lib/ruby/site_ruby/1.8/rubygems/gem_runner.rb:58:in `run' from /usr/local/bin/gem:21
cd ruby-1.9.2-p0/ext/zlib ruby extconf.rb make sudo make install sudo gem install rails
cd /home/myname/installers/ruby-1.8.7-p174/ext/zlib/ ruby extconf.rb --with-zlib-include=/usr/include --with-zlib-lib=/usr/lib make make install
cd ~ wget ftp: tar -xvvf ruby-1.9.2-p180.tar.gz cd ruby-* ./configure make install sudo make install
rvm package install zlib rvm remove 1.9.1 rvm install 1.9.1
wget http: tar xvzf ruby-zlib-0.6.0.tar.gz cd ruby-zlib-0.6.0 ruby extconf.rb && make sudo make install
cd /usr/local/src/ruby make clean make make install cd ../rubygems ruby setup.rb gem install rails
defaults: &defaults audiocast_uri_format: http: development: <<: *defaults test: <<: *defaults production: <<: *defaults
APP_CONFIG = YAML.load_file(" APP_CONFIG = YAML.load_file(Rails.root.join(
defaults: &DEFAULTS audiocast_uri_format: http: development: <<: *DEFAULTS test: <<: *DEFAULTS production: <<: *DEFAULTS
default: &default host: localhost port: 7474 username: neo4j password: root development: <<: *default test: <<: *default production: <<: *default
module MyApp class Application < Rails::Application config.neo4j = config_for(:neo4j) end end
Rails.configuration.neo4j[ Rails.configuration.neo4j[
config.x.payment_processing.schedule = :daily config.x.payment_processing.retries = 3 config.x.super_debugger = true
Rails.configuration.x.payment_processing.schedule Rails.configuration.x.payment_processing.retries Rails.configuration.x.super_debugger Rails.configuration.x.super_debugger.not_set
require require all_config = YAML.load_file(" env_config = all_config[Rails.env] || {} AppConfig = OpenStruct.new(env_config)
common: &common facebook: key: secret : twitter: key: secret : development: <<: *common test: <<: *common production: <<: *common
facebook_key = AppConfig.facebook[ twitter_key = AppConfig.twitter[
APP_CONFIG = YAML.load(ERB.new(File.new(File.expand_path(
default: &default host: localhost port: 6379 development: <<: *default test: <<: *default production: <<: *default host: <%= ENV[ port: <%= ENV[
module MyApp class Application < Rails::Application config.before_initialize do Rails.configuration.redis_configuration = YAML.load_file(" end end end
MyAppName::Application.define_singleton_method("myconfig") {YAML.load_file("
Bundler.require(*Rails.groups) mode = ENV[ file = File.dirname(__FILE__).concat( Settings = YAML.load_file(file).fetch(mode) Settings.define_singleton_method(:method_missing) {|name| self.fetch(name.to_s, nil)}
setting_config = File.join(Rails.root, raise " config = YAML.load_file(setting_config)[Rails.env].symbolize_keys @APP_ID = config[:app_id] @APP_SECRET = config[:app_secret]
development: app_id: 433387212345678 app_secret: f43df96fc4f65904083b679412345678 test: app_id: 148166412121212 app_secret: 7409bda8139554d11173a32222121212 production: app_id: 148166412121212 app_secret: 7409bda8139554d11173a32222121212
uri = Addressable::URI.parse("http: uri.query_values = {title: "My Blog & Your Blog"} uri.normalize.to_s
CGI.escape"/en/test?asd=qwe" => "%2Fen%2Ftest%3Fasd%3Dqwe" URI.escape"/en/test?asd=qwe" => "/en/test?asd=qwe"
gem list | cut -d" " -f1 | xargs gem uninstall -aIx
$ rvm gemset mygemset $ rvm gemset delete mygemset $ rvm gemset create mygemset
1) Admin::CommentsController handling GET to index is successful Failure/Error: get :index undefined method `authenticate! 124) PostsController handling GET for a single post should render show template Failure/Error: get :show, :year => undefined method `authenticate
class ActiveSupport::TestCase include Devise::TestHelpers end
RSpec.configure do |config| config.include Devise::TestHelpers, type: :controller end
require describe MyCoolController include Devise::TestHelpers it { } end
RSpec.configure do |config| config.include Devise::TestHelpers, type: :controller end
RSpec.describe "projects/show", type: :view do before(:each) do allow(view).to receive(:current_user).and_return(FactoryGirl.create(:user)) end it "renders attributes in <p>" do render expect(rendered).to match(/whatever you want to regex match here/) end end
def nil.authenticate! puts "Bingo! Nil is now authentic!" end
String.ancestors Enumerable.ancestors Comparable.ancestors Object.ancestors Kernel.ancestors
Animal.descendants Dog.descendants Enumerable.descendants
class Parent def self.descendants ObjectSpace.each_object(Class).select { |klass| klass < self } end end class Child < Parent end class GrandChild < Child end puts Parent.descendants puts Child.descendants
class Animal end class Mammal < Animal end class Dog < Mammal end class Fish < Animal end Animal.subclasses Animal.descendants
class Class def descendants ObjectSpace.each_object(::Class).select {|klass| klass < self } end end
class Class def descendants result = [] ObjectSpace.each_object(::Class) {|klass| result << klass if klass < self } result end end
ObjectSpace.each_object(YourRootClass.singleton_class)
ObjectSpace.each_object(class<<YourRootClass;self;end)
class Animal def self.inherited(subclass) @descendants = [] @descendants << subclass end def self.descendants puts @descendants end end
module DarthVader module DarkForce end BlowUpDeathStar = Class.new(StandardError) class Luck end class Lea end end DarthVader.constants DarthVader .constants .map { |class_symbol| DarthVader.const_get(class_symbol) } .select { |c| !c.ancestors.include?(StandardError) && c.class != Module }
class DarthVader def self.descendants DarthVader .constants .map { |class_symbol| DarthVader.const_get(class_symbol) } end class Luck < DarthVader end class Lea < DarthVader end def force end end
class DarthVader def self.inherited(klass) @descendants ||= [] @descendants << klass end def self.descendants @descendants || [] end end class Foo < DarthVader end DarthVader.descendants
def descendants(klass) all_classes = klass.subclasses (all_classes + all_classes.map { |c| descendants(c) }.reject(&:empty?)).flatten end
class Foo extend DescendantsTracker end class Bar < Foo end Foo.descendants
def descendants_mapper(klass) klass.subclasses.reduce({}){ |memo, subclass| memo[subclass] = descendants_mapper(subclass); memo } end { MasterClass => descendants_mapper(MasterClass) }
x = {} ObjectSpace.each_object(Class) do |klass| x[klass.superclass] ||= [] x[klass.superclass].push klass end x[String]
{"param1"=>["value1"], "param2"=>["value2"], "param3"=>["value3"]}
require url = "http: uri = URI(url) URI::decode_www_form(uri.query).to_h Hash[URI::decode_www_form(uri.query)]
require "addressable/uri" uri = Addressable::URI.parse("http: uri.query_values[ =>
:phone => "2130001111", :zip => "12345", :city => "sometown"
sorted = dataarray.sort {|a,b| a[:zip] <=> b[:zip]}
array_of_hashes = array_of_hashes.sort_by(&:zip).reverse
data = [ { "2018-11-13": { "avg_score": 4, "avg_duration": 29.24 } }, { "2017-03-13": { "avg_score": 4, "avg_duration": 40.24 } }, { "2018-03-13": { "avg_score": 4, "avg_duration": 39.24 } } ]
def compare_to(x) self.some_method <=> x.some_method end
irb(main):001:0> class A irb(main):002:1> private irb(main):003:1> def not_so_private_method irb(main):004:2> puts "Hello World" irb(main):005:2> end irb(main):006:1> end => nil irb(main):007:0> foo = A.new => irb(main):009:0> foo.send :not_so_private_method Hello World => nil
class Dwarf include Comparable def initialize(name, age, beard_strength) @name = name @age = age @beard_strength = beard_strength end attr_reader :name, :age, :beard_strength public :name private :age protected :beard_strength def <=>(other_dwarf) beard_strength <=> other_dwarf.beard_strength end def greet "Lo, I am My beard is end def blurt "My age is end end require
gloin = Dwarf.new( gimli = Dwarf.new( gloin > gimli gimli > gloin gimli.name gimli.age called for gimli.beard_strength called for gimli.greet My beard is 9 strong!" gimli.blurt
class Animal def intro_animal class_name end private def class_name "I am a end end
class Amphibian < Animal def intro_amphibian class_name end end
class Animal def animal_call protect_me end protected def protect_me p "protect_me called from end end
class Mammal < Animal def mammal_call protect_me end end
class Amphibian < Animal def amphi_call Mammal.new.protect_me self.protect_me end end
class Tree def tree_call Mammal.new.protect_me end end
public class Foo { private void myPrivateMethod() { } private void anotherMethod() { myPrivateMethod(); Foo foo = new Foo(); foo.myPrivateMethod(); } }
class Test1 def main_method method_private end private def method_private puts "Inside methodPrivate for end end class Test2 < Test1 def main_method method_private end end Test1.new.main_method Test2.new.main_method Inside methodPrivate for Test1 Inside methodPrivate for Test2 class Test3 < Test1 def main_method self.method_private end end Test1.new.main_method This will throw NoMethodError
class Test1 def main_method method_protected end protected def method_protected puts "InSide method_protected for end end class Test2 < Test1 def main_method method_protected end end class Test3 < Test1 def main_method self.method_protected end end InSide method_protected for Test1 InSide method_protected for Test2 InSide method_protected for Test3 class Test4 < Test1 def main_method Test2.new.method_protected end end Test4.new.main_method class Test5 def main_method Test2.new.method_protected end end Test5.new.main_method This would fail as object Test5 is not subclass of Test1 Consider Public methods with maximum visibility
important_hash.merge!(defaults) { |key, important, default| important }
hash2.each_key do |key| if ( hash1.has_key?(key) ) hash1[ "hash2-originated- else hash1[key]=hash2[key] end end
if i (1..10) do thing 1 elsif i (11..20) do thing 2 elsif i (21..30) do thing 3 etc...
def foo(x) if (1..10).include?(x) puts "1 to 10" elsif (11..20).include?(x) puts "11 to 20" end end
def select_f_from(collection, point) collection.each do |cutoff, f| if point <= cutoff return f end end return nil end def foo(x) collection = [ [ 0, nil ], [ 10, lambda { puts "doing thing 1"} ], [ 20, lambda { puts "doing thing 2"} ], [ 30, lambda { puts "doing thing 3"} ], [ 40, nil ] ] f = select_f_from(collection, x) f.call if f end
start_date = Date.parse "2012-03-02 14:46:21 +0100" end_date = Date.parse "2012-04-02 14:46:21 +0200"
<% start_time = "2012-03-02 14:46:21 +0100" %> <% end_time = "2012-04-02 14:46:21 +0200" %> <%= distance_of_time_in_words(start_time, end_time) %> "about 1 month"
(start_date..end_date).count (start_date..end_date).to_a.size
(start_date...end_date).count (start_date...end_date).to_a.size
(Time.now.to_i - 23.hours.ago.to_i) / 86400 >> 0 (Time.now.to_i - 25.hours.ago.to_i) / 86400 >> 1 (Time.now.to_i - 1.day.ago.to_i) / 86400 >> 1
def business_days_between(date1, date2) business_days = 0 date = date2 while date > date1 business_days = business_days + 1 unless date.saturday? or date.sunday? date = date - 1.day end business_days end
require Net::HTTP.start("somedomain.net") do |http| resp = http.get("/flv/sample/sample.flv") open("sample.flv", "wb") do |file| file.write(resp.body) end end puts "Done."
f = open( begin http.request_get( resp.read_body do |segment| f.write(segment) end end ensure f.close() end
require File.open("/my/local/path/sample.flv", "wb") do |saved_file| open("http: saved_file.write(read_file.read) end end
require "open-uri" require "fileutils" def download(url, path) case io = open(url) when StringIO then File.open(path, when Tempfile then io.close; FileUtils.mv(io.path, path) end end
require File.write("file_name", Net::HTTP.get(URI.parse("http:
File.open(filename, uri = URI.parse(url) Net::HTTP.start(uri.host,uri.port){ |http| http.request_get(uri.path){ |res| res.read_body{ |seg| f << seg sleep 0.005 } } } }
def http_to_file(filename,url,opt={}) opt = { :init_pause => 0.1, :learn_period => 0.3, :drop => 1.5, :adjust => 1.05 }.merge(opt) pause = opt[:init_pause] learn = 1 + (opt[:learn_period]/pause).to_i drop_period = true delta = 0 max_delta = 0 last_pos = 0 File.open(filename, uri = URI.parse(url) Net::HTTP.start(uri.host,uri.port){ |http| http.request_get(uri.path){ |res| res.read_body{ |seg| f << seg delta = f.pos - last_pos last_pos += delta if delta > max_delta then max_delta = delta end if learn <= 0 then learn -= 1 elsif delta == max_delta then if drop_period then pause /= opt[:drop_factor] else pause /= opt[:adjust] end elsif delta < max_delta then drop_period = false pause *= opt[:adjust] end sleep(pause) } } } } end
require "httparty" File.open("/tmp/my_file.flv", "wb") do |f| f.write HTTParty.get("http: end
ec = Encoding::Converter.new( ... f << ec.convert(seg) ...
require PullTempfile.transaction(url: CSV.foreach(tmp_file.path) do |row| end end
@post = Post.first hash = @post.as_json puts hash.pretty_inspect
{ :name => "test", :post_number => 20, :active => true }
class Post < ActiveRecord::Base def as_json(*args) { :name => "My name is :post_number => "Post } end end
@campaign.as_json( { except: [:created_at, :updated_at], include: { shop: { except: [:created_at, :updated_at, :customer_id], include: {customer: {except: [:created_at, :updated_at]}}}, list: { except: [:created_at, :updated_at, :observation_id], include: { list_tasks: { except: [:created_at, :updated_at], include: {comments: {except: [:created_at, :updated_at]}} } } }, }, methods: :tags })
>> p = Problem.last Problem Load (0.5ms) SELECT "problems".* FROM "problems" ORDER BY "problems"."id" DESC LIMIT 1 => >> >> p.attributes => {"id"=>137, "enabled"=>true, "created_at"=>Fri, 19 Feb 2016 11:20:28 UTC +00:00, "updated_at"=>Fri, 26 Feb 2016 07:47:34 UTC +00:00} >> >> p.as_json => {"id"=>137, "enabled"=>true, "created_at"=>Fri, 19 Feb 2016 11:20:28 UTC +00:00, "updated_at"=>Fri, 26 Feb 2016 07:47:34 UTC +00:00} >> >> n = 1000000 >> Benchmark.bmbm do |x| ?> x.report("attributes") { n.times { p.attributes } } ?> x.report("as_json") { n.times { p.as_json } } >> end Rehearsal ---------------------------------------------- attributes 6.910000 0.020000 6.930000 ( 7.078699) as_json 14.810000 0.160000 14.970000 ( 15.253316) ------------------------------------ total: 21.900000sec user system total real attributes 6.820000 0.010000 6.830000 ( 7.004783) as_json 14.990000 0.050000 15.040000 ( 15.352894)
@customer = Customer.new( name: "John Jacob" ) @customer.name @customer[:name] @customer[
h = Hash.new h["name"] = "test" h["post_number"] = 20 h["active"] = true h
def wordcount(str) h = Hash.new() str.split.each do |key| if h[key] == nil h[key] = 1 else h[key] = h[key] + 1 end end return h.inspect end
This class encapsulates a result returned from calling result = ActiveRecord::Base.connection.exec_query( result ... result.to_hash {"id" => 2, "title" => "title_2", "body" => "body_2"}, ... ] ...
class AddMultiWrongToUser < ActiveRecord::Migration def self.up add_column :users, :multi_wrong, :string end def self.down remove_column :users, :multi_wrong end end
class User < ActiveRecord::Base serialize :multi_wrong, Hash end
user = User.create() user.multi_wrong = {"test"=>"123"} user.save
def self.up add_column :users, :multi_wrong, :text end
class Migration0001 def change add_column :users, :location_data, :json, default: {} end end
class Migration0001 def change add_column :users, :location_data, :text end end
class User < ActiveRecord::Base serialize :location_data end
b = User.new b.location_data = [1,2,{foot: 3, bart: "noodles"}] b.save
class AddHstore < ActiveRecord::Migration def up enable_extension :hstore end def down disable_extension :hstore end end class Migration0001 def change add_column :users, :location_data, :hstore end end
class User < ActiveRecord::Base store_accessor :location_data, :city, :state end
class User < ActiveRecord::Base store :settings, accessors: [ :color, :homepage ], coder: JSON end u = User.new(color: u.color u.settings[:country] = u.settings[:country] u.settings[
def title "I return a string." end def title_exists? !!title end
class LinkStatus < ClassyEnum::Base def ! return true end end class LinkStatus::No < LinkStatus end class LinkStatus::Claimed < LinkStatus def ! return false end end class LinkStatus::Confirmed < LinkStatus def ! return false end end class LinkStatus::Denied < LinkStatus end
raise Application::Error unless !!object.link_status
carcher@carcher-laptop:~/Code/temp/RMagick-2.13.1$ sudo gem install rmagick Building native extensions. This could take a while... ERROR: Error installing rmagick: ERROR: Failed to build gem native extension. /usr/bin/ruby1.8 extconf.rb extconf.rb:1:in `require from extconf.rb:1 Gem files will remain installed in /usr/lib/ruby/gems/1.8/gems/rmagick-2.13.1 for inspection. Results logged to /usr/lib/ruby/gems/1.8/gems/rmagick-2.13.1/ext/RMagick/gem_make.out carcher@carcher-laptop:~/Code/temp/RMagick-2.13.1$
apt-get install graphicsmagick-libmagick-dev-compat
sudo apt-get purge graphicsmagick graphicsmagick-dbg imagemagick-common imagemagick imagemagick-6.q16 libmagickcore-6-headers libmagickwand-dev graphicsmagick-libmagick-dev-compat sudo apt-get autoremove sudo apt-get install imagemagick libmagickwand-dev sudo ln -s /usr/lib/x86_64-linux-gnu/ImageMagick-6.8.9/bin-Q16/Magick-config /usr/bin/Magick-config gem install rmagick
sudo apt-get install imagemagick libmagickcore-dev libmagickwand-dev
sudo apt-get install graphicsmagick-libmagick-dev-compat libmagickwand-dev gem install rmagick ... Building native extensions. This could take a while... Successfully installed rmagick-2.13.1 1 gem installed
apt-get install graphicsmagick-libmagick-dev-compat libmagickwand-dev
$ cd /usr/src $ sudo apt-get build-dep librmagick-ruby $ sudo apt-get source librmagick-ruby $ cd librmagick-ruby-2.11.1 $ sudo dch -i (add changelog entry) $ sudo dpkg-buildpackage $ cd .. $ sudo dpkg -i librmagick-ruby*.deb
brew install imagemagick@6 && brew link imagemagick@6 --force
sudo apt-get install build-essential imagemagick libmagickwand-dev export PATH="/usr/lib/x86_64-linux-gnu/ImageMagick-6.8.9/bin-Q16:$PATH" gem install rmagic
p = Person.new(:name => p.send(:create_without_callbacks) p = Person.find(1) p.send(:update_without_callbacks)
@person.update_column(:some_attribute, @person.update_columns(attributes)
class Person < ActiveRecord::Base attr_accessor :skip_some_callbacks before_validation :do_something after_validation :do_something_else skip_callback :validation, :before, :do_something, if: :skip_some_callbacks skip_callback :validation, :after, :do_something_else, if: :skip_some_callbacks end person = Person.new(person_params) person.skip_some_callbacks = true person.save
@person.update_column(:some_attribute, @person.update_columns(attributes)
class User < ActiveRecord::Base after_save :generate_nick_name end
User.send(:create_without_callbacks) User.send(:update_without_callbacks)
User.skip_callback(:save, :after, :generate_nick_name) User.create!()
User.set_callback(:save, :after, :generate_nick_name)
after_save :something_cool, :unless => :skip_callbacks def skip_callbacks ENV[RAILS_ENV] == end
class ImportedPerson < ActiveRecord::Base self.table_name = end
User.first.update_columns({:name => "sebastian", :age => 25})
class MyModel < ActiveRecord::Base attr_accessor :skip_after_save def after_save return false if @skip_after_save ... blah blah ... end end ... m = MyModel.new m.skip_after_save = true m.save
after_save :set_title, if: -> { !new_record? && self.name_changed? }
ActiveRecord::Base.connection.execute "update table set foo = bar where id =
if !ActiveRecord::Base.private_method_defined? :update_without_callbacks def update_without_callbacks attributes_with_values = arel_attributes_values(false, false, attribute_names) return false if attributes_with_values.empty? self.class.unscoped.where(self.class.arel_table[self.class.primary_key].eq(id)).arel.update(attributes_with_values) end end
class MyModel < ActiveRecord::Base before_save :do_something_before_save def after_save raise RuntimeError, "after_save called" end def do_something_before_save raise RuntimeError, "do_something_before_save called" end end o = MyModel.new MyModel.without_callbacks(:before_save, :after_save) do o.save end
YourModel.connection.execute("UPDATE your_models SET your_models.column_name=
class MyModel < ActiveRecord::Base before_save :do_stuff, unless: :skip_do_stuff_callback attr_accessor :skip_do_stuff_callback def do_stuff puts end end
m = MyModel.new() m.save m.skip_do_stuff_callback = true m.save m.skip_do_stuff_callback = false m.save
record = Something.new(attrs) ActiveRecord::Persistence.instance_method(:create_record).bind(record).call
module SaveWithoutCallbacks def self.included(base) base.const_set(:WithoutCallbacks, Class.new(ActiveRecord::Base) do self.table_name = base.table_name end ) end def save_without_callbacks new_record? ? create_without_callbacks : update_without_callbacks end def create_without_callbacks plain_model = self.class.const_get(:WithoutCallbacks) plain_record = plain_model.create(self.attributes) self.id = plain_record.id self.created_at = Time.zone.now self.updated_at = Time.zone.now @new_record = false true end def update_without_callbacks update_attributes = attributes.except(self.class.primary_key) update_attributes[ update_attributes[ update_columns update_attributes end end
class NoCallbacksModel < ActiveRecord::Base set_table_name include CommonModelMethods : : end
class Person < ActiveRecord::Base validate_on_create :do_something def do_something "something clever goes here" end end
module PlainModel def self.included(base) plainclass = Class.new(ActiveRecord::Base) do self.table_name = base.table_name end base.const_set(:Plain, plainclass) end end class User < ActiveRecord::Base include PlainModel validates_presence_of :email end User.create(email: "") User::Plain.create(email: "") user = User::Plain.find(1) user.email = "" user.save
my ~/.profile export PATH=/opt/local/bin:/opt/local/sbin:$PATH export PATH="/usr/local/bin:/usr/local/sbin:/usr/local/mysql/bin:$PATH"
if which ruby >/dev/null && which gem >/dev/null; then PATH="$(ruby -r rubygems -e fi
export GEM_HOME=/Users/‹your_user›/.gem export PATH="$GEM_HOME/bin:$PATH"
require class Time def to_datetime seconds = sec + Rational(usec, 10**6) offset = Rational(utc_offset, 60 * 60 * 24) DateTime.new(year, month, day, hour, min, seconds, offset) end end
class Date def to_gm_time to_time(new_offset, :gm) end def to_local_time to_time(new_offset(DateTime.now.offset-offset), :local) end private def to_time(dest, method) usec = (dest.sec_fraction * 60 * 60 * 24 * (10**6)).to_i Time.send(method, dest.year, dest.month, dest.day, dest.hour, dest.min, dest.sec, usec) end end
require require t = Time.now d = DateTime.now dd = DateTime.parse(t.to_s) tt = Time.parse(d.to_s)
pry [1] pry(main)> ts = => "Jan 1, 2000 12:01:01" [2] pry(main)> require => true [3] pry(main)> require => true [4] pry(main)> ds = Date.parse(ts) => [5] pry(main)> ds.to_date => [6] pry(main)> ds.to_datetime => [7] pry(main)> ds.to_time => 2000-01-01 00:00:00 -0700 [8] pry(main)> ds.to_time.class => Time [9] pry(main)> ds.to_datetime.class => DateTime [10] pry(main)> ts = Time.parse(ts) => 2000-01-01 12:01:01 -0700 [11] pry(main)> ts.class => Time [12] pry(main)> ts.to_date => [13] pry(main)> ts.to_date.class => Date [14] pry(main)> ts.to_datetime => [15] pry(main)> ts.to_datetime.class => DateTime
require d = DateTime.new(2010,01,01, 10,00,00, Rational(-2, 24)) puts d t = Time.new(d.year, d.month, d.day, d.hour, d.min, d.sec, d.zone) puts t d = DateTime.new(t.year, t.month, t.day, t.hour, t.min, t.sec, Rational(t.gmt_offset / 3600, 24)) puts d
2010-01-01T10:00:00-02:00 2010-01-01 10:00:00 -0200 2010-01-01T10:00:00-02:00
def to_time usec = (sec_fraction * 60 * 60 * 24 * (10**6)).to_i t = Time.gm(year, month, day, hour, min, sec, usec) t - offset.abs.div(SECONDS_IN_DAY) end
before(:each) do MyClass.send(:public, *MyClass.protected_instance_methods) end
--------------------------------------------------- Object obj.instance_eval(string [, filename [, lineno]] ) => obj obj.instance_eval {| | block } => obj ------------------------------------------------------------------------ Evaluates a string containing Ruby source code, or the given block, within the context of the receiver (obj). In order to set the context, the variable self is set to obj while the code is executing, giving the code access to obj the version of instance_eval that takes a String, the optional second and third parameters supply a filename and starting line number that are used when reporting compilation errors. class Klass def initialize @secret = 99 end end k = Klass.new k.instance_eval { @secret }
test_obj.a_private_method(...) test_obj.a_protected_method(...) class << test_obj public :a_private_method, :a_protected_method end test_obj.a_private_method(...) test_obj.a_protected_method(...) other_test_obj = test.obj.class.new other_test_obj.a_private_method(...) other_test_obj.a_protected_method(...)
class foo def public_method private_method end private unless def private_method end end
RSpec.configure do |config| config.before(:each) do described_class.send(:public, *described_class.protected_instance_methods) described_class.send(:public, *described_class.private_instance_methods) end end
describe "protected custom `validates` methods" do before(:all) do @protected_methods = MyClass.protected_instance_methods MyClass.send(:public, *@protected_methods) end after(:all) do MyClass.send(:protected, *@protected_methods) @protected_methods = nil end end
class Foo private def bar; puts "Oi! how did you reach me??"; end end class Foo def ah_hah; bar; end end Foo.new.ah_hah
class MockISIQuery < PublicationSearch::ISIQuery attr_accessor :result public :build_year_range end
assert_equal expected, MyClass.instance.method_name(params)
class Class def publicize_methods saved_private_instance_methods = self.private_instance_methods self.class_eval { public *saved_private_instance_methods } begin yield ensure self.class_eval { private *saved_private_instance_methods } end end end MyClass.publicize_methods do assert_equal 10, MyClass.new.secret_private_method end
def obj.my_private_method_publicly (*args) my_private_method(*args) end
disrespect_privacy @object do |p| assert p.private_method end
class ActiveSupport::TestCase def disrespect_privacy(object_or_class, &block) raise ArgumentError, yield Disrespect.new(object_or_class) end class Disrespect def initialize(object_or_class) @object = object_or_class end def method_missing(method, *args) @object.send(method, *args) end end end
PositiveInfinity = +1.0/0.0 => Infinity NegativeInfinity = -1.0/0.0 => -Infinity CompleteInfinity = NegativeInfinity..PositiveInfinity => -Infinity..Infinity
1.9.3p429 :025 > BigDecimal( => 1.9.3p429 :026 > BigDecimal( => 1.9.3p429 :027 > 3 < BigDecimal( => true 1.9.3p429 :028 > BigDecimal::INFINITY =>
<%= link_to image_tag("facebook.png", :class => "facebook_icon", :alt => "Facebook", :target => "_blank"), "http:
<%= link_to image_tag("facebook.png", class: :facebook_icon, alt: "Facebook"), "http:
<%= link_to "http: <%= image_tag("facebook.png", class: :facebook_icon, alt: "Facebook") %> <% end %>
<%= link_to image_tag("facebook.png", :class => "facebook_icon", :alt => "Facebook"), "http:
<%= link_to image_tag("facebook.png", class: "facebook_icon", alt: "Facebook"), "http:
<%= link_to "http: <%= image_tag "facebook.png", class: "facebook_icon", alt: "Facebook" %> <% end %>
class Variable def initialize value = nil @value = value end attr_accessor :value def method_missing *args, &blk @value.send(*args, &blk) end def to_s @value.to_s end def +(x = nil) x ? @value + x : @value += 1 end def -(x = nil) x ? @value - x : @value -= 1 end end i = Variable.new 5 puts i puts i + 4 puts i puts i.+ puts i
Dir.mkdir("/Users/Luigi/Desktop/Survey_Final/Archived/Survey/test") unless File.exists?("/Users/Luigi/Desktop/Survey_Final/Archived/Survey/test")
directory_name = "name" Dir.mkdir(directory_name) unless File.exists?(directory_name)
irb(main):001:0> require => true irb(main):002:0> require => true irb(main):003:0> str = "1110--ad6ca0b06e1fbeb7e6518a0418a73a6e04a67054" => "1110--ad6ca0b06e1fbeb7e6518a0418a73a6e04a67054" irb(main):004:0> Base64.encode64(str) => "MTExMC0tYWQ2Y2EwYjA2ZTFmYmViN2U2NTE4YTA0MThhNzNhNmUwNGE2NzA1\nNA==\n"
irb(main):005:0> Base64.decode64(Base64.encode64(str).gsub("\n", => true
$ ruby -v ruby 1.8.7 (2008-08-11 patchlevel 72) [i486-linux]
if (RTEST(rb_range_values(obj, &beg, &end, &excl))) { if (!memo.block_given && !memo.float_value && (FIXNUM_P(beg) || RB_TYPE_P(beg, T_BIGNUM)) && (FIXNUM_P(end) || RB_TYPE_P(end, T_BIGNUM))) { return int_range_sum(beg, end, excl, memo.v); } }
VALUE a; a = rb_int_plus(rb_int_minus(end, beg), LONG2FIX(1)); a = rb_int_mul(a, rb_int_plus(end, beg)); a = rb_int_idiv(a, LONG2FIX(2)); return rb_int_plus(init, a);
module AdditionInspector def +(b) puts "Calculating super end end class Integer prepend AdditionInspector end puts (1..5).sum puts (1..5).inject(:+)
irb(main):005:0> a = Date.parse("12/1/2010") => irb(main):007:0> b = Date.parse("12/21/2010") => irb(main):016:0> c = b.mjd - a.mjd => 20
2.0.0-p195 :005 > require => true 2.0.0-p195 :006 > a_date = Date.parse("25/12/2013") => 2.0.0-p195 :007 > b_date = Date.parse("10/12/2013") => 2.0.0-p195 :008 > a_date-b_date => (15/1)
2.0.0-p195 :017 > a_date_time = DateTime.now => 2.0.0-p195 :018 > b_date_time = DateTime.now-20 => 2.0.0-p195 :019 > a_date_time - b_date_time => (1727997655759/86400000000) 2.0.0-p195 :020 > (a_date_time - b_date_time).to_i => 19 2.0.0-p195 :021 > c_date_time = a_date_time-20 => 2.0.0-p195 :022 > a_date_time - c_date_time => (20/1) 2.0.0-p195 :023 > (a_date_time - c_date_time).to_i => 20
> endDate = Date.new(2014, 1, 2) => > beginDate = Date.new(2014, 1, 1) => > days = endDate - beginDate => (1/1) > days.class => Rational > days.to_i => 1
DateTime.now.mjd - DateTime.parse("01-01-1995").mjd
module Vehicle ... class SelfPropelling ... class Truck < SelfPropelling include Vehicle ...
module SelfPropelling ... class Vehicle include SelfPropelling ... class Truck < Vehicle ...
module A HELLO = "hi" def sayhi puts HELLO end end module B HELLO = "you stink" def sayhi puts HELLO end end class C include A include B end c = C.new c.sayhi
class Parent end module M end class Child < Parent include M end Child.ancestors => [Child, M, Parent, Object ...
module M def m puts end end class Test end Test.extend M Test.m
module M def self.included(target) puts "included into end def self.extended(target) puts "extended into end end class MyClass include M end class MyClass2 extend M end
module M def self.included(target) target.send(:include, InstanceMethods) target.extend ClassMethods target.class_eval do a_class_method end end module InstanceMethods def an_instance_method end end module ClassMethods def a_class_method puts "a_class_method called" end end end class MyClass include M end
module M extend ActiveSupport::Concern included do a_class_method end def an_instance_method end module ClassMethods def a_class_method puts "a_class_method called" end end end
begin load File.expand_path("../spring", __FILE__) rescue LoadError end # # # require "pathname" ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../../Gemfile", Pathname.new(__FILE__).realpath) require "rubygems" require "bundler/setup" load Gem.bin_path("rspec-core", "rspec")
"".frozen? => true (+"").frozen? => false "".dup.frozen? => false
>> 1.is_a? Integer => true >> "dadadad@asdasd.net".is_a? Integer => false >>
def is_numeric?(obj) obj.to_s.match(/\A[+-]?\d+?(\.\d+)?\Z/) == nil ? false : true end
1.kind_of? Integer (1.5).kind_of? Float is_numeric? "545" is_numeric? "2aa"
def is_number?(obj) obj.to_s == obj.to_i.to_s end is_number? "123fh" is_number? "12345"
if(s.respond_to?(:match) && s.match(".com")){ puts "It else puts "It end
"0014.56".to_i "0014.56".to_f "0.0".to_f "not_an_int".to_f "not_a_float".to_f
module CoreExtensions module Integerable refine String do def integer? Integer(self) rescue ArgumentError false else true end end end end
require class MyClass using CoreExtensions::Integerable def method end end
if column.class < Numeric number_to_currency(column) else column.html_safe end
[1, 2, 3, 4].inject(0) { |result, element| result + element }
[1,"a",Object.new,:hi].inject({}) do |hash, item| hash[item.to_s] = item hash end
[1, 2, 3, 4].inject(0) { |result, element| result + element } [2, 3, 4].inject(0 + 1) { |result, element| result + element } [3, 4].inject((0 + 1) + 2) { |result, element| result + element } [4].inject(((0 + 1) + 2) + 3) { |result, element| result + element } [].inject((((0 + 1) + 2) + 3) + 4) { |result, element| result + element } (((0 + 1) + 2) + 3) + 4 10
[1, 2, 3, 4].inject(0) { |result, element| result + element }
[1, 2, 3, 4].inject { |result, element| result + element }
result = 0 [1, 2, 3, 4].map { |element| result += element }
result = [1, 2, 3, 4].inject(0) { |x, element| x + element }
[1, 2, 3, 4].inject(0) { |result, element| result + element }
def my_function(r, e) r+e end a = [1, 2, 3, 4] result = 0 a.each do |value| result = my_function(result, value) end
def incomplete_inject(enumerable, result) enumerable.each do |item| result = yield(result, item) end result end incomplete_inject([1,2,3,4], 0) {|result, item| result + item}
[1, 2, 3, 4].inject(0) { |result, element| result.+ element }
[1, 2, 3, 4].inject() { |result = 0, element| result.+ element }
[1, 2, 3, 4].each { |result = 0, element| result + element }
[1, 2, 3, 4].each { |result = 0, element| p result + element }
str = "" length = 100000 (1..length).each {|i| str += "0"}
str = "" incrementor = "" length = 100000 (1..1000).each {|i| incrementor += "0"} (1..100).each {|i| str += incrementor}
require Benchmark.bm(9) do |x| x.report( x.report( end
user system total real format : 0.300000 0.080000 0.380000 ( 0.405345) multiply: 0.080000 0.080000 0.160000 ( 0.172504)
$ ruby -v ruby 1.9.3p0 (2011-10-30 revision 33570) [x86_64-darwin11.0.0] $ cat benchmark_quotes.rb require n = 1000000 Benchmark.bm(15) do |x| x.report("assign single") { n.times do; c = x.report("assign double") { n.times do; c = "a string"; end} x.report("concat single") { n.times do; x.report("concat double") { n.times do; "a string " + "b string"; end} end $ ruby benchmark_quotes.rb user system total real assign single 0.110000 0.000000 0.110000 ( 0.116867) assign double 0.120000 0.000000 0.120000 ( 0.116761) concat single 0.280000 0.000000 0.280000 ( 0.276964) concat double 0.270000 0.000000 0.270000 ( 0.278146)
$ ruby -v ruby 1.8.7 (2008-08-11 patchlevel 72) [i686-darwin9.6.2] $ cat benchmark_quotes.rb require n = 1000000 Benchmark.bm do |x| x.report("assign single") { n.times do; c = x.report("assign double") { n.times do; c = "a string"; end} x.report("assign interp") { n.times do; c = "a string x.report("concat single") { n.times do; x.report("concat double") { n.times do; "a string " + "b string"; end} end $ ruby -w benchmark_quotes.rb user system total real assign single 2.600000 1.060000 3.660000 ( 3.720909) assign double 2.590000 1.050000 3.640000 ( 3.675082) assign interp 2.620000 1.050000 3.670000 ( 3.704218) concat single 3.760000 1.080000 4.840000 ( 4.888394) concat double 3.700000 1.070000 4.770000 ( 4.818794)
require n = 1000000 Benchmark.bm do |x| x.report("assign single") { n.times do; c = x.report("assign double") { n.times do; c = "a string"; end} x.report("assign interp") { n.times do; c = "a x.report("concat single") { n.times do; x.report("concat double") { n.times do; "a string " + "b string"; end} x.report("concat interp") { n.times do; "a end
user system total real assign single 0.370000 0.000000 0.370000 ( 0.374599) assign double 0.360000 0.000000 0.360000 ( 0.366636) assign interp 1.540000 0.010000 1.550000 ( 1.577638) concat single 1.100000 0.010000 1.110000 ( 1.119720) concat double 1.090000 0.000000 1.090000 ( 1.116240) concat interp 3.460000 0.020000 3.480000 ( 3.535724)
require n = 1000000 Benchmark.bm do |x| x.report("assign single") { n.times do; c = x.report("assign double") { n.times do; c = "a string"; end} x.report("assign interp") { n.times do; c = "a x.report("concat single") { n.times do; x.report("concat double") { n.times do; "a string " + "b string"; end} x.report("concat interp") { n.times do; "a end
assign single 0.180000 0.000000 0.180000 ( 0.187233) assign double 0.180000 0.000000 0.180000 ( 0.187566) assign interp 0.880000 0.000000 0.880000 ( 0.877584) concat single 0.550000 0.020000 0.570000 ( 0.567285) concat double 0.570000 0.000000 0.570000 ( 0.570644) concat interp 1.800000 0.010000 1.810000 ( 1.816955)
user system total real assign single 0.140000 0.000000 0.140000 ( 0.144076) assign double 0.130000 0.000000 0.130000 ( 0.142316) assign interp 0.650000 0.000000 0.650000 ( 0.656088) concat single 0.370000 0.000000 0.370000 ( 0.370663) concat double 0.370000 0.000000 0.370000 ( 0.370076) concat interp 1.420000 0.000000 1.420000 ( 1.412210)
generate.rb: 10000.times do ( end $ ruby generate.rb > single_q.rb $ tr \ $ time ruby single_q.rb real 0m0.978s user 0m0.920s sys 0m0.048s $ time ruby double_q.rb real 0m0.994s user 0m0.940s sys 0m0.044s
~ > ruby -v jruby 1.6.7 (ruby-1.8.7-p357) (2012-02-22 3e82bc8) (Java HotSpot(TM) 64-Bit Server VM 1.6.0_37) [darwin-x86_64-java] ~ > cat qu.rb require n = 1000000 Benchmark.bm do |x| x.report("assign single") { n.times do; c = x.report("assign double") { n.times do; c = "a string"; end} x.report("concat single") { n.times do; x.report("concat double") { n.times do; "a string " + "b string"; end} end ~ > ruby qu.rb user system total real assign single 0.186000 0.000000 0.186000 ( 0.151000) assign double 0.062000 0.000000 0.062000 ( 0.062000) concat single 0.156000 0.000000 0.156000 ( 0.156000) concat double 0.124000 0.000000 0.124000 ( 0.124000)
require mark = <<EOS a string EOS n = 1000000 Benchmark.bm do |x| x.report("assign here doc") {n.times do; mark; end} end
`asign here doc 0.141000 0.000000 0.141000 ( 0.140625)`
require n = 1000000 attr_accessor = :a_str_single, :b_str_single, :a_str_double, :b_str_double @a_str_single = @b_str_single = @a_str_double = "a string" @b_str_double = "b string" @did_print = false def reset! @a_str_single = @b_str_single = @a_str_double = "a string" @b_str_double = "b string" end Benchmark.bm do |x| x.report( x.report( x.report( x.report( x.report( x.report( x.report( x.report( reset! x.report( x.report( end
jruby 1.7.4 (1.9.3p392) 2013-05-16 2390d3b on Java HotSpot(TM) 64-Bit Server VM 1.7.0_10-b18 [darwin-x86_64] user system total real assign single 0.220000 0.010000 0.230000 ( 0.108000) assign via << single 0.280000 0.010000 0.290000 ( 0.138000) assign double 0.050000 0.000000 0.050000 ( 0.047000) assing interp 0.100000 0.010000 0.110000 ( 0.056000) concat single 0.230000 0.010000 0.240000 ( 0.159000) concat double 0.150000 0.010000 0.160000 ( 0.101000) concat single interp 0.170000 0.000000 0.170000 ( 0.121000) concat single << 0.100000 0.000000 0.100000 ( 0.076000) concat double interp 0.160000 0.000000 0.160000 ( 0.108000) concat double << 0.100000 0.000000 0.100000 ( 0.074000) ruby 1.9.3p429 (2013-05-15 revision 40747) [x86_64-darwin12.4.0] user system total real assign single 0.100000 0.000000 0.100000 ( 0.103326) assign via << single 0.160000 0.000000 0.160000 ( 0.163442) assign double 0.100000 0.000000 0.100000 ( 0.102212) assing interp 0.110000 0.000000 0.110000 ( 0.104671) concat single 0.240000 0.000000 0.240000 ( 0.242592) concat double 0.250000 0.000000 0.250000 ( 0.244666) concat single interp 0.180000 0.000000 0.180000 ( 0.182263) concat single << 0.120000 0.000000 0.120000 ( 0.126582) concat double interp 0.180000 0.000000 0.180000 ( 0.181035) concat double << 0.130000 0.010000 0.140000 ( 0.128731)
def measure(t) single_measures = [] double_measures = [] double_quoted_string = "" single_quoted_string = single_quoted = 0 double_quoted = 0 t.times do |i| t1 = Time.now single_quoted_string << t1 = Time.now - t1 single_measures << t1 t2 = Time.now double_quoted_string << "a" t2 = Time.now - t2 double_measures << t2 if t1 > t2 single_quoted += 1 else double_quoted += 1 end end puts "Single quoted did took longer in puts "Double quoted did took longer in single_measures_avg = single_measures.inject{ |sum, el| sum + el }.to_f / t double_measures_avg = double_measures.inject{ |sum, el| sum + el }.to_f / t puts "Single did took an average of puts "Double did took an average of puts "\n" end both = 10.times do |i| measure(1000000) end
Single quoted did took longer in 32.33 percent of the cases Double quoted did took longer in 67.67 percent of the cases Single did took an average of 5.032084099982639e-07 seconds Double did took an average of 5.171539549983464e-07 seconds
Single quoted did took longer in 26.9 percent of the cases Double quoted did took longer in 73.1 percent of the cases Single did took an average of 4.998066229983696e-07 seconds Double did took an average of 5.223457359986066e-07 seconds
Single quoted did took longer in 26.44 percent of the cases Double quoted did took longer in 73.56 percent of the cases Single did took an average of 4.97640888998877e-07 seconds Double did took an average of 5.132918459987151e-07 seconds
Single quoted did took longer in 26.57 percent of the cases Double quoted did took longer in 73.43 percent of the cases Single did took an average of 5.017136069985988e-07 seconds Double did took an average of 5.004514459988143e-07 seconds
Single quoted did took longer in 26.03 percent of the cases Double quoted did took longer in 73.97 percent of the cases Single did took an average of 5.059069689983285e-07 seconds Double did took an average of 5.028807639983705e-07 seconds
Single quoted did took longer in 25.78 percent of the cases Double quoted did took longer in 74.22 percent of the cases Single did took an average of 5.107472039991399e-07 seconds Double did took an average of 5.216212339990241e-07 seconds
Single quoted did took longer in 26.48 percent of the cases Double quoted did took longer in 73.52 percent of the cases Single did took an average of 5.082368429989468e-07 seconds Double did took an average of 5.076817109989933e-07 seconds
Single quoted did took longer in 25.97 percent of the cases Double quoted did took longer in 74.03 percent of the cases Single did took an average of 5.077162969990005e-07 seconds Double did took an average of 5.108381859991112e-07 seconds
Single quoted did took longer in 26.28 percent of the cases Double quoted did took longer in 73.72 percent of the cases Single did took an average of 5.148080479983138e-07 seconds Double did took an average of 5.165793929982176e-07 seconds
Single quoted did took longer in 25.03 percent of the cases Double quoted did took longer in 74.97 percent of the cases Single did took an average of 5.227828659989748e-07 seconds Double did took an average of 5.218296609988378e-07 seconds
*** REMOTE GEMS *** rhc (0.84.15) rhcp (0.2.18) rhcp_shell (0.2.12)
*** REMOTE GEMS *** rhc (0.84.15, 0.84.13, 0.83.9, 0.82.18, 0.81.14, 0.80.5, 0.79.5, 0.77.8, 0.75.9, 0.74.6, 0.74.5, 0.73.14, 0.72.29, 0.71.2, 0.69.6, 0.69.3, 0.68.5) rhcp (0.2.18, 0.2.17, 0.2.16, 0.2.15, 0.2.14, 0.1.9, 0.1.8, 0.1.7, 0.1.6, 0.1.5, 0.1.4, 0.1.3, 0.1.2) rhcp_shell (0.2.12, 0.2.11, 0.0.9, 0.0.7, 0.0.6, 0.0.5, 0.0.4, 0.0.3, 0.0.2, 0.0.1)
gem search | grep -o | tr -d | tr | sort 0.0.10 0.1.0 0.1.1
function extract_gem_versions() { echo "$1" \ | grep -o | tr -d | tr } function gem_versions() { local gem_name="$1"; local pattern="^${gem_name}$"; local vers_str="$(gem search ${pattern} --all)"; extract_gem_versions "$vers_str"; } gem_versions rspec | sort 0.0.10 0.1.0 0.1.1
def show @user = User.find( params[:id] ) respond_to do |format| format.html format.json{ render :json => @user.to_json } end end
def show @user = User.find( params[:id] ) respond_to do |format| format.html format.json end end
respond_to do |format| format.json render :partial => "users/show.json" end
{ "first_name": "<%= @user.first_name.to_json %>", "last_name": "<%= @user.last_name.to_json %>" }
ActionView::Template.register_template_handler(:rb, :source.to_proc)
def show @user = User.find( params[:id] ) respond_to do |format| format.html format.json end end
/* views/users/show.json.erb */ { "name" : "<%= @user.name %>" }
<%= @user.attributes.merge(:avatar => image_path(@user.avatar)).to_json %>
class A class Realwork_A ... end class Realwork_B ... end def run ... end self end.new.run
$ irb > module Some end => nil > Some.class => Module > Module.superclass => Object
zsh: /Users/****/.gems/bin/pod: bad interpreter: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin: no such file or directory
sudo gem update --system sudo gem install -n /usr/local/bin cocoapods
ERROR: While executing gem ... (Gem::FilePermissionError) You don
$ brew install ruby $ gem install -n /usr/local/bin cocoapods
ERROR: While executing gem ... (Gem::FilePermissionError) You don
sudo gem uninstall cocoapods sudo gem install cocoapods
def ldap_get ( base_dn, filter, scope=LDAP::LDAP_SCOPE_SUBTREE, attrs=nil )
def ldap_get(base_dn, filter, scope = nil, attrs = nil) scope ||= LDAP::LDAP_SCOPE_SUBTREE ... do something ... end
def ldap_get(base_dn, filter, options = {}) options[:scope] ||= LDAP::LDAP_SCOPE_SUBTREE ... end ldap_get(base_dn, filter, :attrs => X)
def ldap_get ( base_dn, filter, scope: "some_scope", attrs: nil ) p attrs end ldap_get("first_arg", "second_arg", attrs: "attr1, attr2")
def ldap_get ( base_dn, filter, attrs=nil, scope=LDAP::LDAP_SCOPE_SUBTREE )
def ldap_get ( base_dn, filter, scope=LDAP::LDAP_SCOPE_SUBTREE, attrs=nil )
def ldap_get ( base_dn, filter, *param_array, attrs=nil ) scope = param_array.first || LDAP::LDAP_SCOPE_SUBTREE
class Array def ascii_to_text(params) param_len = params.length if param_len > 3 or param_len < 2 then raise "Invalid number of arguments bottom = params[0] top = params[1] keep = params[2] if keep.nil? == false if keep == 1 self.map{|x| if x >= bottom and x <= top then x = x.chr else x = x.to_s end} else raise "Invalid option end else self.map{|x| if x >= bottom and x <= top then x = x.chr end}.compact end end end
array = [1, 2, 97, 98, 99] p array.ascii_to_text([32, 126, 1])
array = [1, 2, 97, 98, 99] p array.ascii_to_text([32, 126])
def ascii_to_text(top, bottom, keep = nil) if keep.nil? self.map{|x| if x >= bottom and x <= top then x = x.chr end}.compact else self.map{|x| if x >= bottom and x <= top then x = x.chr else x = x.to_s end} end
Function.prototype.partial = function(){ var fn = this, args = Array.prototype.slice.call(arguments); return function(){ var arg = 0; for ( var i = 0; i < args.length && arg < arguments.length; i++ ) if ( args[i] === undefined ) args[i] = arguments[arg++]; return fn.apply(this, args); }; };
class Foo CONSTANT_NAME = ["a", "b", "c"] end Foo::CONSTANT_NAME
class Foo MY_CONSTANT = "hello" def bar MY_CONSTANT end end Foo.new.bar
class Foo MY_CONSTANT = "hello" end Foo::MY_CONSTANT Foo.const_get :MY_CONSTANT x = Foo.new x.class::MY_CONSTANT x.class.const_defined? :MY_CONSTANT x.class.const_get :MY_CONSTANT
validates :image_file_name, :format => { :with => %r{\.(gif|jpg|jpeg|png)$}i
>> require => true >> Time.now.utc.iso8601 => "2011-07-28T23:14:04Z"
% irb > Time.now.to_i == Time.now.getutc.to_i => true
class Array def clip n=1 take size - n end end a a.clip a = a + a a.clip 2
>> *a, b = [1,2,3] => [1, 2, 3] >> a => [1, 2] >> b => 3
> arr = [1, 2, 3, 4, 5] > arr.pop => 5 > arr => [1, 2, 3, 4] > arr.tap(&:pop) => [1, 2, 3]
class Array def drop(n) n < 0 ? self[0...n] : super end end
class Array def all_but_the_last(n) self.first(self.size - n) end end
arr = ["One", "Two", "Three", "Four", "Five"] arr.all_but_the_last(1) arr.all_but_the_last(3) arr.all_but_the_last(5) arr.all_but_the_last(6)
require include Pyper a = %w/lorem ipsum dolor sit amet/ a.τaτ a.τdτ a.τbτ a.τeτ a.τcτ a.τzτ a.τyτ a.τxτ
class Foo def useless warn "[DEPRECATION] `useless` is deprecated. Please use `useful` instead." useful end def useful end end
class MyFile extend Gem::Deprecate def no_more close end deprecate :no_more, :close, 2015, 5 def close end end MyFile.new.no_more
warn Kernel.caller.first + " whatever deprecation message here"
class Player < ActiveRecord::Base def to_s ActiveSupport::Deprecation.warn( partner_uid end end
require require class MyGem def self.deprecator ActiveSupport::Deprecation.new( end def old_method end def new_method end deprecate old_method: :new_method, deprecator: deprecator end MyGem.new.old_method
require require class DummyClass def monkey return true end deprecate :monkey end Deprecate.set_action(:throw) class DeprecateTest < Test::Unit::TestCase def test_set_action assert_raise(DeprecatedError) { raise StandardError.new unless DummyClass.new.monkey } Deprecate.set_action(proc { |msg| raise DeprecatedError.new(" assert_raise(DeprecatedError) { raise StandardError.new unless DummyClass.new.monkey } Deprecate.set_action(:warn) assert_nothing_raised(DeprecatedError) { raise StandardError.new unless DummyClass.new.monkey } end end
class Module def deprecate(old_method, new_method) define_method(old_method) do |*args, &block| warn "Method send(new_method, *args, &block) end end end class Test def my_new_method p "My method" end deprecate :my_old_method, :my_method end
def deprecate(msg) method = caller_locations(1, 1).first.label source = caller(2, 1).first warn " end
class MyClass def mymethod MYCONSTANT = "blah" end end
class MyClass class << self attr_accessor :my_constant end def my_method self.class.my_constant = "blah" end end p MyClass.my_constant MyClass.new.my_method p MyClass.my_constant
class MyClass BAR = "blah" def cheat(new_bar) BAR.replace new_bar end end p MyClass::BAR MyClass.new.cheat "whee" p MyClass::BAR
class MyClass MY_CONSTANT = "foo" end MyClass::MY_CONSTANT
class MyClass def my_method self.class.const_set(:MY_CONSTANT, "foo") end end MyClass::MY_CONSTANT MyClass.new.my_method MyClass::MY_CONSTANT
class MyClass def self.my_class_variable @@my_class_variable end def my_method @@my_class_variable = "foo" end end class SubClass < MyClass end MyClass.my_class_variable SubClass.my_class_variable MyClass.new.my_method MyClass.my_class_variable SubClass.my_class_variable
class MyClass class << self attr_accessor :my_class_attribute end def my_method self.class.my_class_attribute = "blah" end end class SubClass < MyClass end MyClass.my_class_attribute SubClass.my_class_attribute MyClass.new.my_method MyClass.my_class_attribute SubClass.my_class_attribute SubClass.new.my_method SubClass.my_class_attribute
class MyClass attr_accessor :instance_variable def my_method @instance_variable = "blah" end end my_object = MyClass.new my_object.instance_variable my_object.my_method my_object.instance_variable MyClass.new.instance_variable
class MyClass MYCONSTANT = "blah" def mymethod MYCONSTANT end end class MyClass def mymethod my_constant = "blah" end end
class MyClass def mymethod myconstant = "blah" end end
/usr/local/bin/brew: /usr/local/Library/brew.rb: /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby: bad interpreter: No such file or directory /usr/local/bin/brew: line 23: /usr/local/Library/brew.rb: Undefined error: 0
/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/fileutils.rb:245:in mkdir from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/fileutils.rb:219:in block (2 levels) in mkdir_p from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/fileutils.rb:217:in block in mkdir_p from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/fileutils.rb:203:in mkdir_p from /Library/Ruby/Site/2.0.0/rubygems/ext/builder.rb:132:in build_error from /Library/Ruby/Site/2.0.0/rubygems/ext/builder.rb:156:in build_extension from /Library/Ruby/Site/2.0.0/rubygems/ext/builder.rb:195:in each from /Library/Ruby/Site/2.0.0/rubygems/specification.rb:1436:in block in build_extensions from /Library/Ruby/Site/2.0.0/rubygems/specification.rb:1434:in build_extensions from /Library/Ruby/Site/2.0.0/rubygems/basic_specification.rb:56:in contains_requirable_file? from /Library/Ruby/Site/2.0.0/rubygems/specification.rb:924:in each from /Library/Ruby/Site/2.0.0/rubygems/specification.rb:924:in find_inactive_by_path from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/irb/locale.rb:150:in block in search_file from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/irb/locale.rb:167:in each_sublocale from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/irb/locale.rb:145:in search_file from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/irb/locale.rb:108:in load from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/irb/init.rb:114:in new from /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/irb/init.rb:16:in setup from /usr/bin/irb:12:in `'
/usr/local/bin/brew: /usr/local/Library/brew.rb: /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby: bad interpreter: No such file or directory /usr/local/bin/brew: line 23: /usr/local/Library/brew.rb: Undefined error: 0
cd /usr/local/Library git pull -q origin refs/heads/master:refs/remotes/origin/master
sudo mkdir -p /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin
sudo ln -s /usr/bin/ruby /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby
sudo chown -R $USER:admin /usr/local cd /usr/local git reset --hard origin/master brew update
require name = /^/i dep = Gem::Dependency.new(name, Gem::Requirement.default) specs = Gem.source_index.search(dep) puts specs[0..5].map{ |s| "
require def local_gems Gem::Specification.sort_by{ |g| [g.name.downcase, g.version] }.group_by{ |g| g.name } end
puts my_local_gems.map{ |name, specs| [ name, specs.map{ |spec| spec.version.to_s }.join( ].join( } ... ...
def all_installed_gems Gem::Specification.all = nil all = Gem::Specification.map{|a| a.name} Gem::Specification.reset all end
require puts Gem::Specification.all().map{|g| [g.name, g.version.to_s].join(
Gem::Specification.sort{|a,b| a.name <=> b.name}.map {|a| puts "
gemsdir = "gems directory" gems = Dir.new(gemsdir).entries
now = Date.today year = now.year - birth_date.year if (date+year.year) > now year = year - 1 end
def age(dob) now = Time.now.utc.to_date now.year - dob.year - ((now.month > dob.month || (now.month == dob.month && now.day >= dob.day)) ? 0 : 1) end
age = Date.today.year - birthday.year age -= 1 if Date.today < birthday + age.years
def age now = Time.now.utc.to_date now.year - birthday.year - (birthday.to_date.change(:year => now.year) > now ? 1 : 0) end
def age(birthday) (Time.now.to_s(:number).to_i - birthday.to_time.to_s(:number).to_i)/10e9.to_i end
birthday = DateTime.new(1900, 1, 1) age = (DateTime.now - birthday) / 365.25
def age(birthday) ((Time.now - birthday.to_time)/(60*60*24*365)).floor end
now = Date.current age = now.year - dob.year age -= 1 if now.yday < dob.yday
def age(dob) now = Date.today now.year - dob.year - (now.strftime( end
today = (Date.current.year * 100 + Date.current.month) * 100 + Date.today.day dob = (dob.year * 100 + dob.month) * 100 + dob.day years_old = (today - dob) / 10000
today = 20140702 years = (today - 20130702) / 10000 years = (today - 20130703) / 10000 years = (today - 20140702) / 10000 years = (20140228 - 19840229) / 10000 years = (20140301 - 19840229) / 10000 years = (20160229 - 19840229) / 10000
class User < ActiveRecord::Base include ActionView::Helpers::DateHelper
def age return nil if self.birthday.nil? date_today = Date.today age = distance_of_time_in_words_hash(date_today, self.birthday).fetch("years", 0) age *= -1 if self.birthday > date_today return age end
u = User.new("birthday(1i)" => "2011", "birthday(2i)" => "10", "birthday(3i)" => "23") u.age
age = now.year - bday.year age -= 1 if now.to_a[7] < bday.to_a[7]
def age return unless dob t = Date.today age = today.year - dob.year b4bday = Date.new(2016, t.month, t.day) < Date.new(2016, dob.month, dob.day) age - (b4bday ? 1 : 0) end
Date::DATE_FORMATS[:md] = def age return unless dob t = Date.today age = t.year - dob.year b4bday = t.to_s(:md) < dob.to_s(:md) age - (b4bday ? 1 : 0) end
def age(dob) t = Time.now age = t.year - dob.year b4bday = t.strftime( age - (b4bday ? 1 : 0) end
def age years = Time.zone.now.year - birthday.year y_days = Time.zone.now.yday - birthday.yday y_days < 0 ? years - 1 : years end
def age(dob) now = Date.today age = now.year - dob.year age -= 1 if dob > now.years_ago(age) age end
def birthday(user) today = Date.today new = user.birthday.to_date.change(:year => today.year) user = user.birthday if Date.civil_to_jd(today.year, today.month, today.day) >= Date.civil_to_jd(new.year, new.month, new.day) age = today.year - user.year else age = (today.year - user.year) -1 end age end
Time.now.year - self.birthdate.year - (birthdate.to_date.change(:year => Time.now.year) > Time.now.to_date ? 1 : 0)
def age return unless birthday now = Time.now.utc.to_date years = now.year - birthday.year years - (birthday.years_since(years) > now ? 1 : 0) end
def age on = Date.today (_ = on.year - birthday.year) - (on < birthday.since(_.years) ? 1 : 0) end
def month_number(today = Date.today) n = 0 while (dob >> n+1) <= today n += 1 end n end
def age(today = Date.today) n = 0 while (dob >> n+12) <= today n += 1 end n end
%w[address city state postal country].map(&:to_sym)
fields = [:address, :city, :state, :postal, :country]
\x12\x34\x56\x78\x9a\xbc\xde\xf1\x23\x45\x67\x89\xab\xcd\xef\x12\x34\x56\x78\x9a
irb(main):123:0> URI::encode "\x12\x34\x56\x78\x9a\xbc\xde\xf1\x23\x45\x67\x89\xab\xcd\xef\x12\x34\x56\x78\x9a" ArgumentError: invalid byte sequence in UTF-8 from /usr/local/lib/ruby/1.9.1/uri/common.rb:219:in `gsub' from /usr/local/lib/ruby/1.9.1/uri/common.rb:219:in `escape' from /usr/local/lib/ruby/1.9.1/uri/common.rb:505:in `escape' from (irb):123 from /usr/local/bin/irb:12:in `<main>'
irb(main):126:0> CGI::escape "\x12\x34\x56\x78\x9a\xbc\xde\xf1\x23\x45\x67\x89\xab\xcd\xef\x12\x34\x56\x78\x9a" ArgumentError: invalid byte sequence in UTF-8 from /usr/local/lib/ruby/1.9.1/cgi/util.rb:7:in `gsub' from /usr/local/lib/ruby/1.9.1/cgi/util.rb:7:in `escape' from (irb):126 from /usr/local/bin/irb:12:in `<main>'
require str = "\x12\x34\x56\x78\x9a\xbc\xde\xf1\x23\x45\x67\x89\xab\xcd\xef\x12\x34\x56\x78\x9a".force_encoding( puts URI::encode(str)
str = "\x12\x34\x56\x78\x9a\xbc\xde\xf1\x23\x45\x67\x89\xab\xcd\xef\x12\x34\x56\x78\x9a" require CGI.escape(str)
>> ERB::Util.url_encode("foo/bar? baz&") => "foo%2Fbar%3F%20baz%26" >> CGI.escape("foo/bar? baz&") => "foo%2Fbar%3F+baz%26"
require string = Addressable::URI.encode_component(string, Addressable::URI::CharacterClasses::QUERY)
2.1.2 :008 > CGI.escape( => "Hello%2C+this+is+me" 2.1.2 :009 > Addressable::URI.encode_component( => "Hello,%20this%20is%20me"
require str = "\x12\x34\x56\x78\x9a\xbc\xde\xf1\x23\x45\x67\x89\xab\xcd\xef\x12\x34\x56\x78\x9a".to_uri
@value = {"val":"test","val1":"test1","val2":"test2"}
@value = {"val"=>"test","val1"=>"test1","val2"=>"test2"}
value = json = JSON.parse(value).with_indifferent_access
require my_string = my_hash = my_string.json vals = my_string.json(:val1, :val2) puts my_hash._val1 puts my_hash.val1 puts my_hash[:val1]
require "open-uri" class User < ActiveRecord::Base has_attached_file :picture def picture_from_url(url) self.picture = open(url) end end
def picture_from_url(url) self.picture = URI.parse(url) end
self.picture = URI.parse("http: self.picture_file_name self.picture_content_type
def picture_from_url(url) self.picture = URI.parse(url).open end
require require require model.update_attribute(:photo,open(website_vehicle.image_url))
class Model < ActiveRecord::Base has_attached_file :photo, :styles => { :small => "150x150>", :thumb => "75x75>" } end
$ rails generate migration AddImageRemoteUrlToYour_Controller image_remote_url:string $ rake db:migrate
attr_accessible :description, :image, :image_remote_url . . . def image_remote_url=(url_value) self.image = URI.parse(url_value) unless url_value.blank? super end
<%= f.input :image_remote_url, label: "Enter a URL" %>
original_url = url.gsub(/\?.*$/, filename = original_url.gsub(/^.*\ extension = File.extname(filename) temp_images = Magick::Image.from_blob open(url).read temp_images[0].write(url = "/tmp/ self.file = File.open(url)
sudo apt-get update sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev
cd git clone https: echo echo exec $SHELL git clone https: echo exec $SHELL rbenv install 2.3.1 rbenv global 2.3.1 ruby -v
$ sudo apt-add-repository ppa:brightbox/ruby-ng $ sudo apt-get update $ sudo apt-get install ruby2.4 $ ruby -v ruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-linux-gnu]
sudo apt-get update sudo apt-get install build-essential make curl \curl -L https: source ~/.bash_profile rvm install ruby-2.1.4
$HOME/.rvm/rubies export PATH=$PATH:$HOME/.rvm/rubies/ruby-2.1.4/bin
sudo apt-get update sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev
\curl -sSL https: source ~/.bash_profile rvm install ruby-2.1.4
@budget = [ 100, 150, 25, 105 ] @actual = [ 120, 100, 50, 100 ]
@budget.each_index do |i| puts @budget[i] puts @actual[i] end
[@budget, @actual].each do |budget, actual| puts budget puts actual end
>> @budget = [ 100, 150, 25, 105 ] => [100, 150, 25, 105] >> @actual = [ 120, 100, 50, 100 ] => [120, 100, 50, 100] >> @budget.zip @actual => [[100, 120], [150, 100], [25, 50], [105, 100]] >> @budget.zip(@actual).each do |budget, actual| ?> puts budget >> puts actual >> end 100 120 150 100 25 50 105 100 => [[100, 120], [150, 100], [25, 50], [105, 100]]
2.1.2 :003 > enum = [1,2,4].each => 2.1.2 :004 > enum2 = [5,6,7].each => 2.1.2 :005 > loop do 2.1.2 :006 > a1,a2=enum.next,enum2.next 2.1.2 :007?> puts "array 1 2.1.2 :008?> end array 1 1 array 2 5 array 1 2 array 2 6 array 1 4 array 2 7
include Enumerable @budget = [ 100, 150, 25, 105 ] @actual = [ 120, 100, 50, 100 ] @budget.each_with_index { |val, i| puts val; puts @actual[i] }
Capybara::Ambiguous: Ambiguous match, found 2 elements matching css ".item"
Failure/Error: first(:link, "Agree").click NoMethodError: undefined method `click
within ".item" do click_link("Agree", :match => :first) end
expect(page).to have_css("selector") first("selector").click
rbenv 0.4.0-49-g8b04303 Usage: rbenv <command> [<args>] Some useful rbenv commands are: commands List all available rbenv commands local Set or show the local application-specific Ruby version global Set or show the global Ruby version shell Set or show the shell-specific Ruby version rehash Rehash rbenv shims (run this after installing executables) version Show the current Ruby version and its origin versions List all Ruby versions available to rbenv which Display the full path to an executable whence List all Ruby versions that contain the given executable See `rbenv help <command> For full documentation, see: https:
sudo apt-get update sudo apt-get install rbenv ruby-build
pkg install ruby-build cd /usr/ports/devel/ruby-build make install
export RBENV_ROOT="/usr/local/rbenv" if [ -d "${RBENV_ROOT}" ]; then export PATH="${RBENV_ROOT}/bin:${PATH}" fi
git clone git@github.com:rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build git clone https:
PATH=/usr/local/bin:$PATH /usr/local/bin/rbenv install ...
app/ bin/ lib/ appname.rb appname/ Rakefile README test,spec,features/ appname.gemspec
% tree freewill freewill/ ├── bin/ │ └── freewill ├── lib/ │ └── freewill.rb ├── test/ │ └── test_freewill.rb ├── README ├── Rakefile └── freewill.gemspec
hash_as_string = "{\"0\"=>{\"answer\"=>\"1\", \"value\"=>\"No\"}, \"1\"=>{\"answer\"=>\"2\", \"value\"=>\"Yes\"}, \"2\"=>{\"answer\"=>\"3\", \"value\"=>\"No\"}, \"3\"=>{\"answer\"=>\"4\", \"value\"=>\"1\"}, \"4\"=>{\"value\"=>\"2\"}, \"5\"=>{\"value\"=>\"3\"}, \"6\"=>{\"value\"=>\"4\"}}" JSON.parse hash_as_string.gsub(
require ruby_hash_text= puts ruby_hash_text ruby_hash_text.gsub!(/([{,]\s*):([^>\s]+)\s*=>/, ruby_hash_text.gsub!(/([{,]\s*)([0-9]+\.?[0-9]*)\s*=>/, ruby_hash_text.gsub!(/([{,]\s*)(".+?"|[0-9]+\.?[0-9]*)\s*=>\s*:([^,}\s]+\s*)/, ruby_hash_text.gsub!(/([\[,]\s*):([^,\]\s]+)/, ruby_hash_text.gsub!(/([{,]\s*)(".+?"|[0-9]+\.?[0-9]*)\s*=>/, puts ruby_hash_text puts JSON.parse(ruby_hash_text)
redis.set(key, ruby_hash.to_json) JSON.parse(redis.get(key))
class String def to_hash_object JSON.parse(self.gsub(/:([a-zA-z]+)/, end end
require a = "{ :key_a => { :key_1a => :key_b => { :key_1b => p HashParser.new.safe_load(a) a = "{ :key_a => system( p HashParser.new.safe_load(a)
the_string = the_hash = Hash.new the_string[1..-2].split(/, /).each {|entry| entryMap=entry.split(/=>/); value_str = entryMap[1]; the_hash[entryMap[0].strip[1..-1].to_sym] = value_str.nil? ? "" : value_str.strip[1..-2]}
require "json" module Ext module Hash module ClassMethods # # def from_string(s) s.gsub!(/(?<!\\)"=>nil/, s.gsub!(/(?<!\\)"=>/, JSON.parse(s) end end end end class Hash extend Ext::Hash::ClassMethods end
require "ext/hash/from_string" describe "Hash.from_string" do it "generally works" do [ [ [ [ [ [ [ [ ].each do |input, expected| output = Hash.from_string(input) expect([input, output]).to eq [input, expected] end end end
"12".is_an_integer? returns true "blah".is_an_integer? returns false
class String def is_i? !!(self =~ /\A[-+]?[0-9]+\z/) end end
class String def is_i? /\A[-+]?\d+\z/ === self end end
class String def is_integer? self.to_i.to_s == self end end >> "12".is_integer? => true >> "blah".is_integer? => false
class String def integer? [ /^[-+]?[1-9]([0-9]*)?$/, /^0[0-7]+$/, /^0x[0-9A-Fa-f]+$/, /^0b[01]+$/ ].each do |match_pattern| return true if self =~ match_pattern end return false end end
def is_num?(str) !!Integer(str, 10) rescue ArgumentError, TypeError false end
"12".match(/^(\d)+$/) "1.2".match(/^(\d)+$/) "dfs2".match(/^(\d)+$/) "13422".match(/^(\d)+$/)
str = ... int = Integer(str) rescue nil if int int.times {|i| p i} end
begin str = ... i = Integer(str) i.times do |j| puts j end rescue ArgumentError puts "Not an int, doing something else" end
class String def integer? Integer(self) return true rescue ArgumentError return false end end
val = Float "234" rescue nil Float "234" rescue nil Float "abc" rescue nil Float "234abc" rescue nil Float nil rescue nil Float "" rescue nil
class String def number? Integer(self).is_a?(Integer) rescue ArgumentError, TypeError false end end
[218] pry(main)> "123123123".number? => true [220] pry(main)> "123 123 123".gsub(/ /, => true [222] pry(main)> "123 123 123".number? => false
class String def integer?(str) !!Integer(str) rescue false end end
def isint(str) return !!(str =~ /^[-+]?[1-9]([0-9]*)?$/) end
class String IntegerRegex = /^(\d)+$/ def integer? !!self.match(IntegerRegex) end end
def integer?(str) /\A[+-]?\d+\z/ === str end integer? "123" integer? "-123" integer? "+123" integer? "a123" integer? "123b" integer? "1\n2"
def number?(obj) obj = obj.to_s unless obj.is_a? String /\A[+-]?\d+(\.[\d]+)?\z/.match(obj) end
(irb) >> number?(7) => >> !!number?(7) => true >> number?(-Math::PI) => >> !!number?(-Math::PI) => true >> number?( => nil >> !!number?( => false
class String def is_i? self =~ /\A[-+]?[0-9]+\z/ ? true : false end end
def is_integer?; true if Integer(self) rescue false end
var = "12" var.is_a?(Integer) var.is_a?(String) var = 12 var.is_a?(Integer) var.is_a?(String)
config.time_zone = config.active_record.default_timezone = :local
config.time_zone = config.active_record.default_timezone = :local
config.time_zone = "Melbourne" config.active_record.default_timezone = :local
config.time_zone = "UTC" config.active_record.default_timezone = :utc
Rails.application.configure do config.time_zone = "Pacific Time (US & Canada)" config.active_record.default_timezone = :local end
config.active_record.default_timezone = :local config.time_zone =
config.time_zone = config.active_record.default_timezone =
[1,2,3,4].scramble => [2,1,3,4] [1,2,3,4].scramble => [3,1,2,4] [1,2,3,4].scramble => [4,2,3,1]
[1,2,3,4].shuffle => [2, 1, 3, 4] [1,2,3,4].shuffle => [1, 3, 2, 4]
class Array def shuffle sort_by { rand } end end [1,2,3,4].shuffle [1,2,3,4].shuffle
class Array def shuffle dup.shuffle! end unless method_defined? :shuffle def shuffle! size.times do |i| r = i + Kernel.rand(size - i) self[i], self[r] = self[r], self[i] end self end unless method_defined? :shuffle! end
["Hash", "Array"].include?(@some_var.class) @some_var.kind_of?(Hash) @some_var.is_a?(Array)
irb(main):005:0> {}.class => Hash irb(main):006:0> [].class => Array
case item.class when MyClass when Array when String end
case item.class when MyClass.class when Array.class when String.class end
case item when MyClass ... when Array ... when String ...
if MyClass === item ... elsif Array === item ... elsif String === item ...
def foo puts caller end def bar foo end def baz bar end baz
caller.rb:8:in `bar' caller.rb:12:in `baz' caller.rb:15:in `<main>'
rescue_from Exception do |exception| logger.error exception.class logger.error exception.message logger.error exception.backtrace.join "\n" @exception = exception respond_to do |format| if [AbstractController::ActionNotFound, ActiveRecord::RecordNotFound, ActionController::RoutingError, ActionController::UnknownAction].include?(exception.class) format.html { render :template => "errors/404", :status => 404 } format.js { render :nothing => true, :status => 404 } format.xml { render :nothing => true, :status => 404 } elsif exception.class == CanCan::AccessDenied format.html { render :template => "errors/401", :status => 401 } format.js { render :template => else ExceptionNotifier::Notifier.exception_notification(env, exception).deliver format.html { render :template => "errors/500", :status => 500 } format.js { render :template => end end end
... $quiet = ARGV.delete( $interactive = ARGV.delete( ...
opts = Trollop::options do opt :quiet, "Use minimal output", :short => opt :interactive, "Be interactive" opt :filename, "File to process", :type => String end
% cat temp.rb require OptionParser.new do |o| o.on( o.on( o.on( o.on( o.parse! end p :quiet => $quiet, :interactive => $interactive, :filename => $filename % ruby temp.rb {:interactive=>nil, :filename=>nil, :quiet=>nil} % ruby temp.rb -h Usage: temp [options] -d -i -f FILENAME -h % ruby temp.rb -d {:interactive=>nil, :filename=>nil, :quiet=>true} % ruby temp.rb -i {:interactive=>true, :filename=>nil, :quiet=>nil} % ruby temp.rb -di {:interactive=>true, :filename=>nil, :quiet=>true} % ruby temp.rb -dif apelad {:interactive=>true, :filename=>"apelad", :quiet=>true} % ruby temp.rb -f apelad -i {:interactive=>true, :filename=>"apelad", :quiet=>nil}
def usage(s) $stderr.puts(s) $stderr.puts("Usage: exit(2) end $quiet = false $logfile = nil loop { case ARGV[0] when when when /^-/ then usage("Unknown option: else break end; } puts("quiet:
$ ./test ./test: Quiet= Interactive=, ARGV=[] $ ./test -q foo ./test: Quiet=true Interactive=, ARGV=["foo"] $ ./test -q -i foo bar baz ./test: Quiet=true Interactive=true, ARGV=["foo", "bar", "baz"] $ ./test -q=very foo ./test: Quiet=very Interactive=, ARGV=["foo"]
options = Parser.new do |p| p.version = "fancy script version 1.0" p.option :verbose, "turn on verbose mode" p.option :number_of_chairs, "defines how many chairs are in the classroom", :default => 1 p.option :room_number, "select room number", :default => 2, :value_in_set => [1,2,3,4] end.process!
Usage: micro-optparse-example [options] -v, --[no-]verbose turn on verbose mode -n, --number-of-chairs 1 defines how many chairs are in the classroom -r, --room-number 2 select room number -h, --help Show this message -V, --version Print version
require module Whatever extend OptiFlagSet flag "f" and_process! end ARGV.flags.f
if( ARGV.include( file = ARGV[ARGV.indexof( ARGV.delete( ARGV.delete(file) end
class MyApp < Thor map "-L" => :list desc "install APP_NAME", "install one of the available apps" method_options :force => :boolean, :alias => :optional def install(name) user_alias = options[:alias] if options.force? end end desc "list [SEARCH]", "list all of the available apps, limited by SEARCH" def list(search = "") end end
case ARGV.join when /-h/ puts "help message" exit when /-opt1/ puts "running opt1" end
if ARGV.count.odd? puts exit 1 end opts = {} (ARGV.count/2).times do |i| k,v = ARGV.shift(2) opts[k] = v end opts[ puts "username:
opts = {} (ARGV.count/2).times do |i| k,v = ARGV.shift(2) opts[k] = v end
arghash = Hash.new.tap { |h| i = -1 ARGV.map{ |s| /(-[a-zA-Z_-])?([^=]+)?(=)?(.+)?/m.match(s).to_a } .each{ |(_,a,b,c,d)| h[ a ? " (a ? (c ? " } [[:argc,Proc.new {|| h.count{|(k,_)| !k.is_a?(String)}}], [:switches, Proc.new {|| h.keys.select{|k| k[0] == ].each{|(n,p)| h.define_singleton_method(n,&p) } }
def usage "usage: end $quiet = false $logfile = nil ARGV.delete_if do |cur| next false if cur[0] != case cur when $quiet = true when /^-l=(.+)$/ $logfile = $1 else $stderr.puts "Unknown option: $stderr.puts usage exit 1 end end puts "quiet:
(options = []) << Acclaim::Option.new(:verbose, values = Acclaim::Option::Parser.new(ARGV, options).parse! puts
cmd.rb cmd.rb action cmd.rb action -a -b ... cmd.rb action -ab ...
ACTION = ARGV.shift OPTIONS = ARGV.join.tr( if ACTION == ... if OPTIONS.include? ... end ... end
other_args = Clap.run ARGV, "-s" => lambda { |s| switch = s }, "-o" => lambda { other = true }
flag = false option = nil opts = { "--flag" => ->() { flag = true }, "--option" => ->(v) { option = v } } argv = ARGV args = [] while argv.any? item = argv.shift flag = opts[item] if flag raise ArgumentError if argv.size < arity flag.call(*argv.shift(arity)) else args << item end end
opts = ParseOpt.new opts.usage = "git foo" opts.on("b", "bool", help: "Boolean") do |v| $bool = v end opts.on("s", "string", help: "String") do |v| $str = v end opts.on("n", "number", help: "Number") do |v| $num = v.to_i end opts.parse
require unless EasyOptions.options[:quiet] puts EasyOptions.arguments.each { |item| puts "Argument: end
require def valid_url?(uri) uri = URI.parse(uri) && !uri.host.nil? rescue URI::InvalidURIError false end
require def valid_url?(url) uri = URI.parse(url) uri.is_a?(URI::HTTP) && !uri.host.nil? rescue URI::InvalidURIError false end
class HttpUrlValidator < ActiveModel::EachValidator def self.compliant?(value) uri = URI.parse(value) uri.is_a?(URI::HTTP) && !uri.host.nil? rescue URI::InvalidURIError false end def validate_each(record, attribute, value) unless value.present? && self.class.compliant?(value) record.errors.add(attribute, "is not a valid HTTP URL") end end end validates :example_attribute, http_url: true
class UrlValidator < ActiveModel::EachValidator def validate_each(record, attribute, value) return if value.blank? begin uri = URI.parse(value) resp = uri.kind_of?(URI::HTTP) rescue URI::InvalidURIError resp = false end unless resp == true record.errors[attribute] << (options[:message] || "is not an url") end end end
validates :website, :allow_blank => true, :uri => { :format => /(^$)|(^(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(([0-9]{1,5})?\/.*)?$)/ix } def website= url_str unless url_str.blank? unless url_str.split( url_str = "http: end end write_attribute :website, url_str end
require class UriValidator < ActiveModel::EachValidator def validate_each(object, attribute, value) raise(ArgumentError, "A regular expression must be supplied as the :format option of the options hash") unless options[:format].nil? or options[:format].is_a?(Regexp) configuration = { :message => I18n.t( configuration.update(options) if value =~ configuration[:format] begin case Net::HTTP.get_response(URI.parse(value)) when Net::HTTPSuccess then true else object.errors.add(attribute, configuration[:message]) and false end rescue object.errors.add(attribute, configuration[:message]) and false end else object.errors.add(attribute, configuration[:message]) and false end end end
class WebSite < ActiveRecord::Base validates :url, :url => true end
before_validation :format_website validate :website_validator private def format_website self.website = "http: end def website_validator errors[:website] << I18n.t("activerecord.errors.messages.invalid") unless website_valid? end def website_valid? !!website.match(/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-=\?]*)*\/?$/) end
validates_format_of :url, :with => /\A(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w\.-]*)*\/?\Z/i
require class UriValidator < ActiveModel::EachValidator def validate_each(record, attribute, value) uri = parse_uri(value) if !uri record.errors[attribute] << generic_failure_message elsif !allowed_protocols.include?(uri.scheme) record.errors[attribute] << "must begin with end end private def generic_failure_message options[:message] || "is an invalid URL" end def allowed_protocols_humanized allowed_protocols.to_sentence(:two_words_connector => end def allowed_protocols @allowed_protocols ||= [(options[:allowed_protocols] || [ end def parse_uri(value) uri = Addressable::URI.parse(value) uri.scheme && uri.host && uri rescue URI::InvalidURIError, Addressable::URI::InvalidURIError, TypeError end end
require describe UriValidator do subject do Class.new do include ActiveModel::Validations attr_accessor :url validates :url, uri: true end.new end it "should be valid for a valid http url" do subject.url = subject.valid? subject.errors.full_messages.should == [] end [ it " subject.url = invalid_url subject.valid? subject.errors.full_messages.should == [] end end [ it " subject.url = invalid_url subject.valid? subject.errors.should have_key(:url) subject.errors[:url].should include("is an invalid URL") end end [ it " subject.url = invalid_url subject.valid? subject.errors.should have_key(:url) subject.errors[:url].should include("is an invalid URL") end end [ it " subject.url = invalid_url subject.valid? subject.errors.should have_key(:url) subject.errors[:url].should include("must begin with http or https") end end end
class Url < ActiveRecord::Base validates :url, :presence => true, :url => true end
validates_format_of [:field1, :field2], with: URI.regexp([
validates_format_of :url, :with => URI::regexp(%w(http https)) validate :validate_url def validate_url unless self.url.blank? begin source = URI.parse(self.url) resp = Net::HTTP.get_response(source) rescue URI::InvalidURIError errors.add(:url, rescue SocketError errors.add(:url, end end
module UrlValidator extend ActiveSupport::Concern included do validates :url, presence: true, uniqueness: true validate :url_format end def url_format begin errors.add(:url, "Invalid url") unless URI(self.url).is_a?(URI::HTTP) rescue URI::InvalidURIError errors.add(:url, "Invalid url") end end end
class UrlValidator < ActiveModel::Validator def validate(record) begin url = URI.parse(record.path) response = Net::HTTP.get(url) true if response.is_a?(Net::HTTPSuccess) rescue StandardError => error record.errors[:path] << false end end end
class Url < ApplicationRecord validates_presence_of :path validates_with UrlValidator end
(^|[\s.:;?\-\]<\(])(ftp|https?:\/\/[-\w;\/?:@&=+$\|\_.!~*\|
validates :some_field_expecting_url_value, format: { with: URI.regexp(%w[http https]), message: }
module URI def self.valid?(url) uri = URI.parse(url) uri.is_a?(URI::HTTP) && !uri.host.nil? rescue URI::InvalidURIError false end end
class Hash def compact delete_if { |k, v| v.nil? } end end
class Hash def compact(opts={}) inject({}) do |new_hash, (k,v)| if !v.nil? new_hash[k] = opts[:recurse] && v.class == Hash ? v.compact(opts) : v end new_hash end end end
hash = { a: true, b: false, c: nil } hash.compact hash hash.compact! hash { c: nil }.compact
class Hash def compact self.select { |_, value| !value.nil? } end end
swoop = Proc.new { |k, v| v.delete_if(&swoop) if v.kind_of?(Hash); v.empty? } hsh.delete_if &swoop
class Hash def clean! self.delete_if do |key, val| if block_given? yield(key,val) else test1 = val.nil? test2 = val === 0 test3 = val === false test4 = val.empty? if val.respond_to?( test5 = val.strip.empty? if val.is_a?(String) && val.respond_to?( test1 || test2 || test3 || test4 || test5 end end self.each do |key, val| if self[key].is_a?(Hash) && self[key].respond_to?( if block_given? self[key] = self[key].clean!(&Proc.new) else self[key] = self[key].clean! end end end return self end end
class Hash def deep_compact(options = {}) inject({}) do |new_hash, (k,v)| result = options[:exclude_blank] ? v.blank? : v.nil? if !result new_value = v.is_a?(Hash) ? v.deep_compact(options).presence : v new_hash[k] = new_value if new_value end new_hash end end end
rec_hash.each {|key,value| rec_hash.delete(key) if value.blank? }
def remove_blank_values(hash) hash.each_with_object({}) do |(k, v), new_hash| unless v.blank? && v != false v.is_a?(Hash) ? new_hash[k] = remove_blank_values(v) : new_hash[k] = v end end end
def remove_blank_values!(hash) hash.each do |k, v| if v.blank? && v != false hash.delete(k) elsif v.is_a?(Hash) hash[k] = remove_blank_values!(v) end end end
class Hash def remove_blank_values self.each_with_object({}) do |(k, v), new_hash| unless v.blank? && v != false v.is_a?(Hash) ? new_hash[k] = v.remove_blank_values : new_hash[k] = v end end end def remove_blank_values! self.each_pair do |k, v| if v.blank? && v != false self.delete(k) elsif v.is_a?(Hash) v.remove_blank_values! end end end end
class Hash def compact delete_if{|k, v| (v.is_a?(Hash) and v.respond_to?( (v.nil?) or (v.is_a?(String) and v.empty?) } end end
require require hash.recursively { |v| v.compact! }
module Helpers module RecursiveCompact extend self def recursive_compact(hash_or_array) p = proc do |*args| v = args.last v.delete_if(&p) if v.respond_to? :delete_if v.nil? || v.respond_to?(:"empty?") && v.empty? end hash_or_array.delete_if(&p) end end end
class Hash def compact delete_if {|k,v| v.is_a?(Hash) ? v.compact.empty? : v.nil? } end end
x = {:a=>{:b=>2, :c=>3}, :d=>nil, :e=>{:f=>nil}, :g=>{}} x.compact
class Hash def compact delete_if {|k,v| v.compact if v.is_a?(Hash); v.nil? } end end
class Hash def compact def _empty?(val) case val when Hash then val.compact.empty? when Array then val.all? { |v| _empty?(v) } when String then val.empty? when NilClass then true end end delete_if { |_key, val| _empty?(val) } end end
hash = { a: true, b: false, c: nil } => {:a=>true, :b=>false, :c=>nil} hash.inject({}){|c, (k, v)| c[k] = v unless v.nil?; c} => {:a=>true, :b=>false}
def recursive_compact inject({}) do |new_hash, (k,v)| if !v.nil? new_hash[k] = v.kind_of?(Hash) ? v.recursive_compact : v end new_hash end end
<input id="cityID" type="checkbox" style="text-align: center; opacity: 0;" value="61" name="cityID"> <input id="cityID" type="checkbox" style="text-align: center; opacity: 0;" value="62" name="cityID"> <input id="cityID" type="checkbox" style="text-align: center; opacity: 0;" value="63" name="cityID">
<label> <input type="checkbox" value="myvalue" name="myname" id="myid"> MyLabel </label>
ActiveRecord::Base.connection.tables.map(&:classify) .map{|name| name.constantize if Object.const_defined?(name)} .compact.each(&:delete_all)
def reset Rails.application.eager_load! ActiveRecord::Base.descendants.each { |c| c.delete_all unless c == ActiveRecord::SchemaMigration } end
$ script/console RAILS_ENV=test >> require Errno::ENOENT: No such file or directory - /Users/ethan/project/contactdb/config/environments/RAILS_ENV=test.rb
$ script/console -h Usage: console [environment] [options] -s, --sandbox Rollback database modifications on exit. --irb=[irb] Invoke a different irb. --debugger Enable ruby-debugging for the console.
config.gem "thoughtbot-factory_girl", :lib => "factory_girl", :source => "http:
>> require => [] >> Digest::SHA1.hexdigest("some-random-string")[8..16] => "2ebe5597f" >> SecureRandom.base64(8).gsub("/","_").gsub(/=+$/,"") => "AEWQyovNFo0" >> rand(36**8).to_s(36) => "uur0cj2h"
while Order.find_by_guid(guid = rand(36**8).to_s(36).upcase).present?; end
puts `uuidgen` 8adea17d-b918-43e0-b82f-f81b3029f688 puts `uuidgen` 6a4adcce-8f64-41eb-bd7e-e65ee6d11231 puts `uuidgen` 51d5348b-8fc3-4c44-a6f7-9a8588d7f08a puts `uuidgen` 332a0fa3-7b07-41e1-9fc8-ef804a377e4e
irb(main):003:0> uuid.generate => "40cdf890-ebf5-0132-2250-20c9d088be77" irb(main):004:0> uuid.generate => "4161ac40-ebf5-0132-2250-20c9d088be77"
def uuid "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".gsub("x") do "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[rand(36)] end end
def uuid "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".gsub("x") do rand(16).to_s(16) end end
ArgumentError: odd number of arguments for Hash from (irb):10:in `[]' from (irb):10
h3 = Hash[a3.map {|key, value| [key, value]}] puts "h3:
h3: {["orange", "seedless"]=>3, "apple"=>1, "banana"=>2}
a1 = [ h1 = Hash[*a1.flatten(1)] puts "h1: a2 = [[ h2 = Hash[*a2.flatten(1)] puts "h2:
a = [[:apple, 1], [:banana, 2]] h = a.inject({}) { |r, i| r[i.first] = i.last; r }
a = [:apple, 1, :banana, 2] h = {} a.each_slice(2) { |i| h[i.first] = i.last }
1.9.3p362 :005 > a= [[1,2],[3,4]] => [[1, 2], [3, 4]] 1.9.3p362 :006 > h = Hash[a] => {1=>2, 3=>4}
flat_array = [ apple, 1, banana, 2 ] nested_array = [ [apple, 1], [banana, 2] ] incomplete_f = [ apple, 1, banana ] incomplete_n = [ [apple, 1], [banana ] ] h1 = Hash[*flat_array] h2a = nested_array.to_h h2b = Hash[nested_array] h3 = Hash[incomplete_f.each_slice(2).to_a] h4 = Hash[incomplete_n] h1 == h2a h1 == h2b h1 == h3 h3 == h4
data = [["foo",1,2,3,4],["bar",1,2],["foobar",1,"*",3,5,:foo]]
data_hash = Hash[data.map { |key| [key.shift, key] }]
a = ["apple", 1, "banana", 2] m1 = {} for x in (a.length / 2).times m1[a[x*2]] = a[x*2 + 1] end b = [["apple", 1], ["banana", 2]] m2 = {} for x,y in b m2[x] = y end
input = ["cat", 1, "dog", 2, "wombat", 3] hash = Hash.new input.each_with_index {|item, index| if (index%2 == 0) hash[item] = input[index+1] } hash
"kirk douglas".split(/ |\_|\-/).map(&:capitalize).join(" ")
[ letters = word.split( letters.first.upcase! letters.join end => ["NASA", "MHz", "Sputnik"]
"hello".capitalize "HELLO".capitalize "123ABC".capitalize
class String def capitalize_first self[0] = self[0].mb_chars.upcase self end end
bootstrap/dist/css/bootstrap.css bootstrap/dist/css/bootstrap.min.css
bootstrap/dist/js/bootstrap.js bootstrap/dist/js/bootstrap.min.js
<link href="/assets/custom.css?body=1" media="screen" rel="stylesheet"> <link href="/assets/bootstrap.css?body=1" media="screen" rel="stylesheet">
$ rails console > Rails.application.config.assets.paths
chgrp -R admin /usr/local chmod -R g+w /usr/local chgrp -R admin /Library/Caches/Homebrew chmod -R g+w /Library/Caches/Homebrew
$ sudo dscl . append /Groups/wheel GroupMembership $USER
some_var = rand(1) == 1 ? true : false (some_var.is_a?(TrueClass) || some_var.is_a?(FalseClass))
module Boolean; end class TrueClass; include Boolean; end class FalseClass; include Boolean; end true.is_a?(Boolean) false.is_a?(Boolean)
class Object def boolean? self.is_a?(TrueClass) || self.is_a?(FalseClass) end end
?> "String".boolean? => false >> 1.boolean? => false >> Time.now.boolean? => false >> nil.boolean? => false >> true.boolean? => true >> false.boolean? => true >> (1 ==1).boolean? => true >> (1 ==2).boolean? => true
case mybool when TrueClass, FalseClass puts "It else puts "It end
mybool = true mybool.class == TrueClass || mybool.class == FalseClass => true
mybool = true [TrueClass, FalseClass].include?(mybool.class) => true
class Boolean < TrueClass self end true.is_a?(Boolean) false.is_a?(Boolean)
$ rvm upgrade 1.9.2-p0 1.9.2 Are you sure you wish to upgrade from ruby-1.9.2-p0 to ruby-1.9.2-p136? (Y/n): Y
Are you sure you wish to upgrade from ruby-2.0.0-p195 to ruby-2.0.0-p247? (Y/n): Y Are you sure you wish to MOVE gems from ruby-2.0.0-p195 to ruby-2.0.0-p247? This will overwrite existing gems in ruby-2.0.0-p247 and remove them from ruby-2.0.0-p195 (Y/n): Y Do you wish to move over aliases? (Y/n): Y Do you wish to move over wrappers? (Y/n): Y Do you also wish to completely remove ruby-2.0.0-p195 (inc. archive)? (Y/n): Y
rvm update; rvm reload rvm install ruby-1.9.2-p136 rvm --default ruby-1.9.2-p136
rvm get head rvm reload wget https: rvm install ruby-1.9.2-p290 --patch ruby-1.9.2p290.patch -n patched
require require "sinatra/reloader" class MyApp < Sinatra::Base register Sinatra::Reloader get "Hello Testing1!" end end
group :development do gem "guard" gem "guard-bundler" gem "guard-rack" end
guard watch( end guard watch( watch(%r{^(config|app|api)/.*}) end
gem install capybara-webkit -v Building native extensions. This could take a while... ERROR: Error installing capybara-webkit: ERROR: Failed to build gem native extension. /home/durrantm/.rvm/rubies/ruby-1.9.3-p194/bin/ruby extconf.rb sh: qmake: not found Gem files will remain installed in /home/durrantm/.rvm/gems/ruby-1.9.3-p194/gems/capybara-webkit-0.11.0 for inspection. Results logged to /home/durrantm/.rvm/gems/ruby-1.9.3-p194/gems/capybara-webkit-0.11.0/./gem_make.out
sudo apt-get install qt4-dev-tools libqt4-dev libqt4-core libqt4-gui
WARNING: The next major version of capybara-webkit will require at least version 5.0 of Qt. You
user&.profile NameError: undefined local variable or method `user
if defined?(user) user&.profile end user = nil user&.profile
u.?profile.?thumbnails u\profile\thumbnails u!profile!thumbnails u ? .profile ? .thumbnails u && .profile && .thumbnails u&.profile&.thumbnails
str = nil puts "Hello" if str.nil? || str.empty? puts "Hello" if str&.empty?
hash.keys.each_with_index do |key, index| value = hash[key] print "key: end
hash.each_with_index do |(key, value), index| print "key: end
Fetching: rvm-1.11.3.9.gem (100%) Successfully installed rvm-1.11.3.9 Parsing documentation for rvm-1.11.3.9 Installing ri documentation for rvm-1.11.3.9 1 gem installed
module Rake include Test::Unit::Assertions def run_tests end extend self end
module A class << self include A def x puts end end def y puts end end A.x A.y
require class Cheat include Singleton def initialize @host = @http = Net::HTTP.start(URI.parse(@host).host) end def sheet(name) @http.get("/s/ end end Cheat.instance.sheet Cheat.instance.sheet
require module Cheat extend self def host @host ||= end def http @http ||= Net::HTTP.start(URI.parse(host).host) end def sheet(name) http.get("/s/ end end Cheat.sheet Cheat.sheet
module Rake include Test::Unit::Assertions def run_tests end end Rake.extend(Rake)
class Gift def initialize @name = "book" @price = 15.95 end end gift = Gift.new hash = {} gift.instance_variables.each {|var| hash[var.to_s.delete("@")] = gift.instance_variable_get(var) } p hash
gift = Gift.new hash = gift.instance_variables.each_with_object({}) { |var, hash| hash[var.to_s.delete("@")] = gift.instance_variable_get(var) } p hash
class Gift def to_hash hash = {} instance_variables.each {|var| hash[var.to_s.delete("@")] = instance_variable_get(var) } hash end end h = Gift.new("Book", 19).to_hash
module ActiveRecordExtension def to_hash hash = {}; self.attributes.each { |k,v| hash[k] = v } return hash end end class Gift < ActiveRecord::Base include ActiveRecordExtension .... end class Purchase < ActiveRecord::Base include ActiveRecordExtension .... end
class Gift def to_hash instance_variables.map do |var| [var[1..-1].to_sym, instance_variable_get(var)] end.to_h end end
class Object def hashify Hash[instance_variables.map { |v| [v.to_s[1..-1].to_sym, instance_variable_get v] }] end end
class A include Hashable attr_accessor :blist def initialize @blist = [ B.new(1), { end end class B include Hashable attr_accessor :id def initialize(id); @id = id; end end a = A.new a.to_dh
# # def to_hash obj Hash[obj.instance_variables.map { |key| variable = obj.instance_variable_get key [key.to_s[1..-1].to_sym, if variable.respond_to? <:some_method> then hashify variable else variable end ] }] end
<div class="subcolumns"> <div class="c25l"> <div class="subcl"> <%= image_tag album.photo.media.url(:thumb), :class => "image" rescue nil %> </div> </div> <div class="c75r"> <div class="subcr"> <p><%= album.created_at %></p> <%= link_to h(album.title), album %> <p><%= album.created_at %></p> <p><%= album.photo_count %></p> </div> </div> </div>
<% content_tag(:a, :href => foo_path) do %> <span>Foo</span> <% end %>
<% link_to(@album) do %> <!-- insert html etc here --> <% end %>
➜ ~ rvm list rvm rubies ruby-1.9.2-p290 [ x86_64 ] ruby-1.9.3-p0 [ x86_64 ] ➜ ~ rvm use ruby-1.9.3-p0 RVM is not a function, selecting rubies with
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"
1. Edit > Profile Preferences 2. Open Title and Command Tab 3. Check Run Command as a login Shell 4. Restart terminal
[[ -s "$rvm_path/scripts/rvm" ]] && . "$rvm_path/scripts/rvm"
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"
[[ -s "$HOME/.rvm/scripts/rvm" ]] && ."$HOME/.rvm/scripts/rvm"
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"
$ sudo apt-get install zlib1g-dev $ rvm reinstall 1.9.3
$ sudo yum install zlib-devel $ rvm reinstall 1.9.3
rvm install 2.3.0 --with-zlib-dir=/usr/local/Cellar/zlib/1.2.8
a_new_hash = my_hash.inject({}) { |h, (k, v)| h[k] = v.upcase; h }
hash = {"a" => "b", "c" => "d"} new_hash = hash.transform_values(&:upcase)
config = Hash[ config.collect {|k,v| [k, v.upcase] } ]
my_hash.each_with_object({}) { |(key, value), hash| hash[key] = value.upcase }
h = {"a" => "b", "c" => "d"} h.each{|i,j| j.upcase!}
hash = {sample: result = {} hash.each do |key, value| result[key] = do_stuff(value) end
def convert_hash hash hash.inject({}) do |h,(k,v)| if v.kind_of? String h[k] = to_utf8(v) else h[k] = convert_hash(v) end h end end # def to_utf8 untrusted_string="" ic = Iconv.new( ic.iconv(untrusted_string + end
original_hash = { :a => original_hash.clone.tap{ |h| h.each{ |k,v| h[k] = v.upcase } } original_hash
new_hash = old_hash.merge(old_hash) do |_key, value, _value| value.upcase end
original_hash = { :a => JSON(original_hash.to_json)
Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension. /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/bin/ruby extconf.rb checking for libxml/parser.h... *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options. Provided configuration options: --with-opt-dir --with-opt-include --without-opt-include=${opt-dir}/include --with-opt-lib --without-opt-lib=${opt-dir}/lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=/Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/bin/ruby --with-zlib-dir --without-zlib-dir --with-zlib-include --without-zlib-include=${zlib-dir}/include --with-zlib-lib --without-zlib-lib=${zlib-dir}/lib --with-iconv-dir --without-iconv-dir --with-iconv-include --without-iconv-include=${iconv-dir}/include --with-iconv-lib --without-iconv-lib=${iconv-dir}/lib --with-xml2-dir --without-xml2-dir --with-xml2-include --without-xml2-include=${xml2-dir}/include --with-xml2-lib --without-xml2-lib=${xml2-dir}/lib --with-xslt-dir --without-xslt-dir --with-xslt-include --without-xslt-include=${xslt-dir}/include --with-xslt-lib --without-xslt-lib=${xslt-dir}/lib --with-libxslt-config --without-libxslt-config --with-pkg-config --without-pkg-config --with-libxml-2.0-config --without-libxml-2.0-config --with-libiconv-config --without-libiconv-config /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:368:in `try_do You have to install development tools first. from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:452:in `try_cpp' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:853:in `block in find_header' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:693:in `block in checking_for' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:280:in `block (2 levels) in postpone' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:254:in `open' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:280:in `block in postpone' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:254:in `open' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:276:in `postpone' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:692:in `checking_for' from /Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/lib/ruby/1.9.1/mkmf.rb:852:in `find_header' from extconf.rb:116:in `<main>' Gem files will remain installed in /Users/ericcamalionte/Locaweb/code/dns-panel/vendor/bundle/ruby/1.9.1/gems/nokogiri-1.5.9 for inspection. Results logged to /Users/ericcamalionte/Locaweb/code/dns-panel/vendor/bundle/ruby/1.9.1/gems/nokogiri-1.5.9/ext/nokogiri/gem_make.out An error occured while installing nokogiri (1.5.9), and Bundler cannot continue. Make sure that `gem install nokogiri -v
gem install nokogiri -- --with-xml2-include=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/libxml2
gem install nokogiri -- --with-xml2-include=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/libxml2 --use-system-libraries
gem install nokogiri -- --with-xml2-include=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include/libxml2 --use-system-libraries
gem install nokogiri -- --with-xml2-include=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/usr/include/libxml2 --use-system-libraries
package configuration for libxslt cflags: -I/usr/local/Cellar/libxslt/1.1.28/include -I/usr/local/Cellar/libxml2/2.9.1/include/libxml2 ldflags: -L/usr/local/Cellar/libxslt/1.1.28/lib -L/usr/local/Cellar/libxml2/2.9.1/lib libs: -lxslt -lxml2 -lz -lpthread -liconv -lm -lxml2 package configuration for libxml-2.0 cflags: -I/usr/local/Cellar/libxml2/2.9.1/include/libxml2 ldflags: -L/usr/local/Cellar/libxml2/2.9.1/lib libs: -lxml2 package configuration for libiconv is not found "/usr/bin/gcc-4.2 -o conftest -I/Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/include/ruby-1.9.1/x86_64-darwin11.4.0 -I/Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/include/ruby-1.9.1/ruby/backward -I/Users/ericcamalionte/.rvm/rubies/ruby-1.9.2-p320/include/ruby-1.9.1 -I. -I/usr/local/Cellar/libxslt/1.1.28/include -I/usr/local/Cellar/libxml2/2.9.1/include/libxml2 -I/usr/local/Cellar/libiconv/1.14/include -I/Users/ericcamalionte/.rvm/gems/ruby-1.9.2-p320@dns-panel/gems/nokogiri-1.6.0/ports/x86_64-apple-darwin13.0.0/libxml2/2.8.0/include -I/Users/ericcamalionte/.rvm/gems/ruby-1.9.2-p320@dns-panel/gems/nokogiri-1.6.0/ports/x86_64-apple-darwin13.0.0/libxslt/1.1.26/include -I/Users/ericcamalionte/.rvm/usr/include -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE -O3 -ggdb -Wextra -Wno-unused-parameter -Wno-parentheses -Wpointer-arith -Wwrite-strings -Wno-missing-field-initializers -Wshorten-64-to-32 -Wno-long-long -fno-common -pipe -g -DXP_UNIX -O3 -Wall -Wcast-qual -Wwrite-strings -Wconversion -Wmissing-noreturn -Winline -DNOKOGIRI_USE_PACKAGED_LIBRARIES -DNOKOGIRI_LIBXML2_PATH= sh: /usr/bin/gcc-4.2: No such file or directory checked program was: 1: 2: 3: int main() {return 0;}
sudo xcode-select -s /Library/Developer/CommandLineTools/
sudo ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future gem install nokogiri
sudo ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future gem install nokogiri -v
rvm remove ruby 2.0.0p451 rvm remove ruby-2.0.0-p451 && rvm install ruby-2.0.0-p451
gem install nokogiri -- --with-iconv-include=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/ --with-iconv-lib=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/
brew update brew install libiconv brew link libiconv
gem install nokogiri -- --with-iconv-dir=/usr/local/Cellar/libiconv/1.14
gem install nokogiri -- --with-xml2-include=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/usr/include/libxml2 --use-system-libraries
gem install nokogiri -- --with-xml2-include=/usr/local/Cellar/libxml2/2.9.1/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.9.1/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.28 --with-iconv-include=/usr/local/Cellar/libiconv/1.13.1/include --with-iconv-lib=/usr/local/Cellar/libiconv/1.13.1/lib
bundle config build.nokogiri --use-system-libraries bundle install
system: OS X Yosemite 10.10 rvm: 1.26.10 brew: 0.9.5 ruby: ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-darwin14]
.rvm/rubies/ruby-2.2.0-p0/lib/ruby/1.9.1/mkmf.rb:368:in `try_do
gem uninstall nokogiri libxml-ruby brew update brew uninstall libxml2 brew install libxml2 libxslt gem install nokogiri -- --with-xml2-include=/usr/local/Cellar/libxml2/2.9.2/include/libxml2/libxml --with-xml2-lib=/usr/local/Cellar/libxml2/2.9.2/lib --with-iconv-dir=/usr/local/Cellar/libiconv/1.14/ --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26/
bundle config build.nokogiri --with-xml2-include=/usr/local/Cellar/libxml2/2.9.2/include/libxml2/libxml --with-xml2-lib=/usr/local/Cellar/libxml2/2.9.2/lib --with-iconv-dir=/usr/local/Cellar/libiconv/1.14/ --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26/ bundle install
system: OS X Yosemite 10.10 rvm: 1.26.10 ruby: ruby 2.2.1
xcode-select --install brew install apple-gcc42 gem install nokogiri
brew install libxml2 libxslt gem install nokogiri -- \ --with-xml2-include=/usr/local/Cellar/libxml2/*/include/libxml2 \ --with-xml2-lib=/usr/local/Cellar/libxml2/*/lib \ --with-xslt-dir=/usr/local/Cellar/libxslt/*
-E, -S, -save-temps and -M options are not allowed with multiple -arch flags
bundle config build.nokogiri --with-xml2-include=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include/libxml2 --use-system-libraries
Warning: Unbrewed dylibs were found in /usr/local/lib. If you didn building Homebrew formulae, and may need to be deleted. Unexpected dylibs: /usr/local/lib/libcharset.1.dylib /usr/local/lib/libiconv.2.dylib
rm /usr/local/lib/libiconv* andromeda:nokogiri-1.6.0 Jeff$ brew install libxml2 libxslt ... ==> Summary 🍺 /usr/local/Cellar/libxslt/1.1.28: 145 files, 3.3M, built in 36 seconds
Jeff$ gem install nokogiri Building native extensions. This could take a while... Successfully installed nokogiri-1.6.0 1 gem installed
brew install ruby193 sudo gem install nokogiri -v bundle install
gem install nokogiri -- --use-system-libraries=true --with-xml2-include=/usr/include/libxml2
user_a@ubuntu:~/work/app_a$ rails console ^C/home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/client/run.rb:54:in `gets from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/client/run.rb:54:in `verify_server_version' from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/client/run.rb:25:in `call' from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/client/command.rb:7:in `call' from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/client/rails.rb:23:in `call' from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/client/command.rb:7:in `call' from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/client.rb:26:in `run' from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/bin/spring:48:in `<top (required)>' from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/binstub.rb:11:in `load' from /home/user_a/.rvm/gems/ruby-2.1.2/gems/spring-1.1.3/lib/spring/binstub.rb:11:in `<top (required)>' from /home/user_a/work/app_a/bin/spring:16:in `require' from /home/user_a/work/app_a/bin/spring:16:in `<top (required)>' from bin/rails:3:in `load' from bin/rails:3:in `<main>' user_a@ubuntu:~/work/app_a$
user 7163 0.0 0.0 110356 2165 pts/3 S+ 19:40 0:00 grep --color=auto -i spring user 16980 0.0 0.4 398826 17580 ? Sl Aug31 0:00 spring server | current | started 277 hours ago
result = nums.class == "Array".constantize ? nums : (nums.class == "NilClass".constantize ? [] : ([]<<nums))
current_user.posts.inject(true) {|result, element| result and (element.some_boolean_condition)}
Array([1, 2, 3]) Array(1) Array(nil) Array({a: 1, b: 2}) [*[1, 2, 3]] [*1] [*nil] [*{a: 1, b: 2}]
class Object; def ensure_array; [self] end end class Array; def ensure_array; to_a end end class NilClass; def ensure_array; to_a end end [1, 2, 3].ensure_array 1.ensure_array nil.ensure_array {a: 1, b: 2}.ensure_array
Array.wrap([1, 2, 3]) Array.wrap(1) Array.wrap(nil) Array.wrap({a: 1, b: 2})
class Array def self.wrap(object) if object.nil? [] elsif object.respond_to?(:to_ary) object.to_ary || [object] else [object] end end end
def wrap(foo) [foo].flatten(1) end wrap([1,2,3]) wrap([[1,2],[3,4]]) wrap(1) wrap(nil) wrap({key:
class Array def self.wrap(object) [*object] end end Array.wrap([1, 2, 3]) Array.wrap(nil)
class Array def self.wrap(object) object.is_a? Array ? object : [*object] end end Array.wrap([1, 2, 3]) Array.wrap(nil)
foo = foo.is_a?(Array) ? foo : foo.nil? ? [] : [foo]
"Hello world".to_a 123.to_a {a:1, b:2}.to_a nil.to_a
<td class="value"> <select name="organizationSelect" id="organizationSelect" class="required"> <option value="NULL">Choose...</option> <option value="4c430d62-f1ba-474f-8e8a-4452c55ea0a8">&nbsp;Institution1</option> <option value="e1a4efa7-352d-410a-957e-35c8a3b92944">&nbsp;Institution / test</option> </select> </td>
option = find(:xpath, " select(option, :from => organizationSelect)
Ambiguous match, found 2 elements matching option "Institution" (Capybara::Ambiguous)
find(:select, from, options).find(:option, value, options).select_option
select "option_name_here", :from => "organizationSelect"
def select_option(css_selector, value) find(:css, css_selector).find(:option, value).select_option end
option = Organization.all.sample option = Organization.all[0] option = Organization.where(some_attr: some_value)[2] option = Organization.where("some_attr OP some_value")[2]
candidates = my_array.select { |e| e.satisfies_condition? } found_it = candidates.first if !candidates.empty?
[1,2,3,11,34].detect(&:even?) OR [1,2,3,11,34].detect{|i| i.even?}
found_object = my_array.find { |e| e.satisfies_condition? }
found_it = my_array.any? { |e| e.satisfies_condition? }
class Array def uniq_by(&blk) transforms = [] self.select do |el| should_keep = !transforms.include?(t=blk[el]) transforms << t should_keep end end end
class Array def uniq_by(&blk) transforms = {} select do |el| t = blk[el] should_keep = !transforms[t] transforms[t] = true should_keep end end end
@photos = @photos.uniq { |p| [p.album_id, p.author_id] }
class Foo attr_accessor :foo, :bar, :baz def initialize(foo,bar,baz) @foo = foo @bar = bar @baz = baz end end objs = [Foo.new(1,2,3),Foo.new(1,2,3),Foo.new(2,3,4)] objs.inject([]) do |uniqs,obj| if uniqs.all? { |e| Marshal.dump(e) != Marshal.dump(obj) } uniqs << obj end uniqs end
def uniq_by hash, array = {}, [] each { |i| hash[yield(i)] ||= (array << i) } array end
class A attr_accessor :val def initialize(v); self.val = v; end end objs = [1,2,6,3,7,7,8,2,8].map{|i| A.new(i)} objs.sort_by{|a| a.val}.inject([]) do |uniqs, a| uniqs << a if uniqs.empty? || a.val != uniqs.last.val uniqs end
my_array = [:uno, :dos, :tres] my_array.each { |item| puts item } my_array = [:uno, :dos, :tres] my_array.each do |item| puts item end
def method1(var) puts "inside method1" puts "method1 arg = if block_given? puts "Block passed to method1" yield "method1 block is running" else puts "No block passed to method1" end end def method2 puts"inside method2" if block_given? puts "Block passed to method2" return yield("method2 block is running") else puts "no block passed to method2" return "method2 returned without block" end end method1 method2 do |x| puts x end method1 method2{ |x| puts x }
1.upto(10) do |x| add_some_num = x + rand(10) puts end
file_names = [ file_names.each do |file_name| text = File.read(file_name) new_contents = text.gsub(/search_regexp/, "replacement string") puts new_contents File.open(file_name, "w") {|file| file.puts new_contents } end
require def file_edit(filename, regexp, replacement) tempdir = File.dirname(filename) tempprefix = File.basename(filename) tempprefix.prepend( tempfile = begin Tempfile.new(tempprefix, tempdir) rescue Tempfile.new(tempprefix) end File.open(filename).each do |line| tempfile.puts line.gsub(regexp, replacement) end tempfile.fdatasync unless RUBY_PLATFORM =~ /mswin|mingw|windows/ tempfile.close unless RUBY_PLATFORM =~ /mswin|mingw|windows/ stat = File.stat(filename) FileUtils.chown stat.uid, stat.gid, tempfile.path FileUtils.chmod stat.mode, tempfile.path else end FileUtils.mv tempfile.path, filename end file_edit(
require def file_edit(filename, regexp, replacement) Tempfile.open(". File.open(filename).each do |line| tempfile.puts line.gsub(regexp, replacement) end tempfile.fdatasync tempfile.close stat = File.stat(filename) FileUtils.chown stat.uid, stat.gid, tempfile.path FileUtils.chmod stat.mode, tempfile.path FileUtils.mv tempfile.path, filename end end file_edit(
require def file_edit(filename, regexp, replacement) Tempfile.open(". File.open(filename).each do |line| tempfile.puts line.gsub(regexp, replacement) end tempfile.close FileUtils.mv tempfile.path, filename end end file_edit(
def inplace_edit(file, bak, &block) old_stdout = $stdout argf = ARGF.clone argf.argv.replace [file] argf.inplace_mode = bak argf.each_line do |line| yield line end argf.close $stdout = old_stdout end inplace_edit line = line.gsub(/search1/,"replace1") line = line.gsub(/search2/,"replace2") print line unless line.match(/something/) end
files = Dir.glob("/PATH/*") @original_string_or_regex = /REGEX/ @replacement_string = "STRING" files.each do |file_name| text = File.read(file_name) replace = text.gsub!(@original_string_or_regex, @replacement_string) File.open(file_name, "w") { |file| file.puts replace } end
filename = "foo" text = File.read(filename) content = text.gsub(/search_regexp/, "replacestring") File.open(filename, "w") { |file| file << content }
require opts = Trollop::options do opt :output, "Output file", :type => String opt :input, "Input file", :type => String opt :ss, "String to search", :type => String opt :rs, "String to replace", :type => String end text = File.read(opts.input) text.gsub!(opts.ss, opts.rs) File.open(opts.output,
ARGV[0..-3].each{|f| File.write(f, File.read(f).gsub(ARGV[-2],ARGV[-1]))}
ARGV[0..-3].each do |f| File.write(f, File.read(f) .gsub(ARGV[-2],ARGV[-1])) end
ActionView::Base.full_sanitizer.sanitize(html_string)
ActionView::Base.full_sanitizer.sanitize(html_string)
ActionView::Base.full_sanitizer.sanitize(html_string, :tags => %w(img br p), :attributes => %w(src style))
unsafe_html = "ohai! <div>div is safe</div> <script>but script is not</script>" doc = Loofah.fragment(unsafe_html).scrub!(:strip) doc.to_s doc.text
white_list_sanitizer = Rails::Html::WhiteListSanitizer.new WHITELIST = [ [Your, Models, Here].each do |klass| klass.all.each do |ob| klass.attribute_names.each do |attrs| if ob.send(attrs).is_a? String ob.send(" ob.save end end end end
myarray.sort! { |a, b| a.attribute <=> b.attribute }
objects_array.sort! { |a, b| a.attribute <=> b.attribute }
objects_array.sort! { |a, b| b.attribute <=> a.attribute }
objects_array.sort_by{ |obj| obj.attribute }.reverse
myarray.sort{ |a,b| (a.attr1 == b.attr1) ? a.attr2 <=> b.attr2 : a.attr1 <=> b.attr1 }
myarray.sort{ |a,b| (a[0] == b[0]) ? a[1] <=> b[1] : a[0] <=> b[0] }
class Person attr_accessor :first_name, :last_name def initialize(first_name, last_name) @first_name = first_name @last_name = last_name end def <=>(other) @last_name + @first_name <=> other.last_name + other.first_name end end
ar = [Person.new("Eric", "Cunningham"), Person.new("Homer", "Allen")] puts ar ar.sort! puts ar
myarray.sort! { |a, b| a.attribute <=> b.attribute }
@model_name.sort! { |a,b| a.attribute <=> b.attribute }
class A def self.new raise end end class B < A ... ... end
module Abstract def abstract_methods(*args) args.each do |name| class_eval(<<-END, __FILE__, __LINE__) def raise NotImplementedError.new("You must implement end END end end end require require describe "abstract methods" do before(:each) do @klass = Class.new do extend Abstract abstract_methods :foo, :bar end end it "raises NoMethodError" do proc { @klass.new.foo }.should raise_error(NoMethodError) end it "can be overridden" do subclass = Class.new(@klass) do def foo :overridden end end subclass.new.foo.should == :overridden end end
class A def initialize raise end end class B < A def initialize end end
class A private_class_method :new end class B < A public_class_method :new end
module Abstract extend ActiveSupport::Concern included do # # def self.abstract_methods(*methods) methods.each do |method_name| define_method method_name do raise NotImplementedError, end end end end end class AbstractBaseWidget include Abstract abstract_methods :widgetify end class SpecialWidget < AbstractBaseWidget end SpecialWidget.new.widgetify
module Abstract def self.append_features(klass) metaclass = lambda { |obj| class << obj; self ; end } metaclass[klass].instance_eval do old_new = instance_method(:new) undef_method :new define_method(:inherited) do |subklass| metaclass[subklass].instance_eval do define_method(:new, old_new) end end end end end
class A include Abstract end class B < A end B.new A.new
puts module Abstract def new throw end def inherited(child) @abstract = true puts non_abstract_parent = self.superclass; while non_abstract_parent.instance_eval {@abstract} non_abstract_parent = non_abstract_parent.superclass end puts "Non abstract superclass is (class << child;self;end).instance_eval do define_method :new, non_abstract_parent.method( end end end class AbstractParent extend Abstract def initialize puts end end class Child < AbstractParent def initialize puts super end end puts Child.new class AbstractChild < AbstractParent extend Abstract end class Child2 < AbstractChild end puts Child2.new
class Foo include AbstractType abstract_method :bar abstract_singleton_method :baz end Foo.new Foo.baz class Baz < Foo; end object = Baz.new object.bar
class A class AbstractClassInstiationError < RuntimeError; end def initialize raise AbstractClassInstiationError, "Cannot instantiate this class directly, etc..." end end
<%= stylesheet_link_tag "bootstrap.min", media: "all", "data-turbolinks-track" => true %> <%= stylesheet_link_tag "styles", media: "all", "data-turbolinks-track" => true %> <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
<link data-turbolinks-track="true" href="/stylesheets/bootstrap.min.css" media="all" rel="stylesheet" /> <link data-turbolinks-track="true" href="/stylesheets/styles.css" media="all" rel="stylesheet" /> <script data-turbolinks-track="true" src="/assets/application-0c647c942c6eff10ad92f1f2b0c64efe.js"></script>
config.assets.compile = true config.assets.precompile = [
RAILS_ENV=production bundle exec rake assets:precompile
config.serve_static_assets = false config.public_file_server.enabled = false
Rails.application.config.assets.precompile += %w( *.js ^[^_]*.css *.css.erb )
on roles(:app) do if DEPLOY_ENV == execute("cd end end
config.serve_static_assets = true or config.serve_static_files = true
location ~ ^/(assets|images|fonts)/(.*)$ { alias /var/www/foster_care/current/public/$1/$2; gzip on; expires max; add_header Cache-Control public; }
config.serve_static_assets = true config.public_file_server.enabled = true
config.assets.precompile += [ config.assets.precompile += [
location ~ ^/assets/ { expires 1y; add_header Cache-Control public; add_header ETag ""; }
some text <% ... %> more text <%= ... %> something else <% ... %>
<% =begin %> ... html and ruby code goes here <% =end %>
<p> This is some text I want to keep <%= @some_object.some_attribute %> </p> <p> I want to keep this text but comment out the erb tag <% </p> <!-- <p> I want all of this text commented out including the erb tag <% </p> --> <!-- <p> I just want this html commented out but I want to keep the erb tag <%= @some_object.some_attribute %> </p> -->
<% =begin code code code code code code code code code code code code code code code code code code code code code code code code =end %>
<% =begin <p>HTML will be ignored</p> <%= <p> <%= </p> =end %>
<% <<-COMMENT %> the above closing erb tag is just for looks (to match the end), but don
<P> this will not be displayed in the browser <strong> even in the developer </p> <% 1_000_000_000_000.times do |count| %> for the <%= count %> this is all just a string all of these %>, <%, <% end %>, end, do, <!--, won but the below opening erb tag is important (if you used any erb tags in the comment). I have no clue why?
<!-- <p> < %= @some_object.some_attribute %> </p> <p> < %= @some_object.another_attribute %> </p> <p> < %= @some_object.some_attribute %> </p> <p> < %= @some_object.some_attribute %> </p> -->
def create @person = Person.new(params[:person]) @person.save! redirect_to @person rescue ActiveRecord::RecordInvalid render :action => :new end
begin rescue SomeExceptionClass => some_variable ensure end
def rescue SomeExceptionClass => some_variable ensure end
require if String.method_defined?(:encode) file_contents.encode!( else ic = Iconv.new( file_contents = ic.iconv(file_contents) end
require if String.method_defined?(:encode) file_contents.encode!( file_contents.encode!( else ic = Iconv.new( file_contents = ic.iconv(file_contents) end
def to_utf8(str) str = str.force_encoding( return str if str.valid_encoding? str.encode("UTF-8", end
attachment = file.read begin cleaned = attachment.dup.force_encoding( unless cleaned.valid_encoding? cleaned = attachment.encode( end attachment = cleaned rescue EncodingError attachment = attachment.force_encoding("ISO-8859-1").encode("utf-8", replace: nil) end
ec1 = Encoding::Converter.new "UTF-8","Windows-1251",:invalid=>:replace,:undef=>:replace,:replace=>"" ec2 = Encoding::Converter.new "Windows-1251","UTF-8",:invalid=>:replace,:undef=>:replace,:replace=>"" t = ec2.convert ec1.convert t
def sanitize_utf8(string) return nil if string.nil? return string if string.valid_encoding? string.chars.select { |c| c.valid_encoding? }.join end
ryan_group[0][0] (first group) RyanOnRails ryan_group[0][1] (second group) : ryan_group[0][2] (third group) This is a test
string = "RyanOnRails: This is a test" one, two, three = string.match(/(^.*)(:)(.*)/i).captures p one p two p three
if match = string.match(/(^.*)(:)(.*)/i) one, two, three = match.captures end
if ryan_string =~ /(^.*)(:)(.*)/i first = $1 third = $3 end
string = "RyanOnRails: This is a test" /(?<one>^.*)(?<two>:)(?<three>.*)/i =~ string puts one, two, three
ryan_string = "RyanOnRails: This is a test" /^(?<webframework>.*)(?<colon>:)(?<rest>)/ =~ ryan_string^ webframework puts "W:
g1, g2, g3 = ryan_string.match(/(^.*)(:)(.*)/i).captures
sort_me = [] sort_me.push({"value"=>1, "name"=>"a"}) sort_me.push({"value"=>3, "name"=>"c"}) sort_me.push({"value"=>2, "name"=>"b"}) sort_me.sort_by { |k| k["value"]} puts sort_me
sorted = sort_me.sort_by { |k| k["value"] } puts sorted
require File.expand_path( require "action_controller/railtie" require "action_mailer/railtie" Bundler.require(:default, Rails.env) module MyApp class Application < Rails::Application config.app_middleware.delete "ActiveRecord::ConnectionAdapters::ConnectionManagement" end end
/home/alex/.rvm/gems/ruby-2.0.0-p247/gems/railties-4.0.0/lib/rails/railtie/configuration.rb:95:in method_missing: undefined method active_record for
require "action_controller/railtie" require "action_mailer/railtie" require "sprockets/railtie" require "rails/test_unit/railtie"
require "rails" require "active_model/railtie" require "active_job/railtie" require "action_controller/railtie" require "action_mailer/railtie" require "action_view/railtie" require "sprockets/railtie" require "rails/test_unit/railtie"
Rails.application.config.active_record.belongs_to_required_by_default = true
Rails.application.middleware.tap do |middleware| middleware.delete ActiveRecord::Migration::CheckPending middleware.delete ActiveRecord::ConnectionAdapters::ConnectionManagement middleware.delete ActiveRecord::QueryCache end
require "rails" require "active_model/railtie" require "active_job/railtie" require "action_controller/railtie" require "action_mailer/railtie" require "action_view/railtie" require "action_cable/engine" require "sprockets/railtie" require "rails/test_unit/railtie"
Cannot load `Rails.application.database_configuration`: Could not load database configuration. No such file - ["config/database.yml"]
require "active_model/railtie" require "active_job/railtie" require "action_cable/engine" require "action_controller/railtie" require "action_mailer/railtie" require "action_view/railtie" require "sprockets/railtie" require "rails/test_unit/railtie"
def a_method x = 7 def print_x; puts x end print_x end
a = b = "joe" a==b a.eql? b a.equal? b a = "joe" b = "joe" a==b a.eql? b a.equal? b a = 1 b = 1.0 a==b a.eql? b a.equal? b
class Person attr_reader name def == (rhs) rhs.name == self.name end def eql? (rhs) self == rhs end end
"joe" === "joe" "joe" === "bob" (1..10) === 5 (1..10) === 19 (1..10) === (1..10) [1,2,3] === [1,2,3] [1,2,3] === 2 String === "joe" String === 1.5 String === String
case a when "joe": puts "1" when 1.0 : puts "2" when (1..10), (15..20): puts "3" else puts "4" end
if "joe" === a puts "1" elsif 1.0 === a puts "2" elsif (1..10) === a || (15..20) === a puts "3" else puts "4" end
class Subnet [...] def include? (ip_address_or_subnet) [...] end def === (rhs) self.include? rhs end end case destination_ip when white_listed_subnet: puts "the ip belongs to the white-listed subnet" when black_listed_subnet: puts "the ip belongs to the black-listed subnet" [...] end
(1..5).each do |number| comment = " is even" if number%2==0 puts number.to_s + comment.to_s end
comment = nil (1..5).each do |number| comment = " is even" if number%2==0 puts number.to_s + comment.to_s end
class A def hello(name="Dan") puts "hello end end class B < A def hello(name) super end end B.new.hello("Bob")
class A @@classvar = "A1" @classattr = "A2" def self.showvars puts "@@classvar => "+@@classvar puts "@classattr => "+@classattr end end A.showvars class B < A @@classvar = "B1" @classattr = "B2" end B.showvars A.showvars
module Displayable def display puts name self.class.increment_displays end def self.included(base) base.extend Displayable::ClassMethods end module ClassMethods def number_of_displays @number_of_displays end def increment_displays @number_of_displays += 1 end def init_displays @number_of_displays = 0 end def self.extended(base) base.init_displays end end end class Person include Displayable def name; @name; end def initialize(name); @name=name; end end puts Person.number_of_displays john = Person.new "John" john.display puts Person.number_of_displays jack = Person.new "Jack" jack.display puts Person.number_of_displays
module Displayable def display puts name self.class.increment_displays end def self.number_of_displays @number_of_displays end [...] end
class Thing attr_accessor :foo def initialize @foo = 1 self.foo = 2 foo = 3 end end puts Thing.new.foo
class Demo def hello1 p "Hello from first definition" end def hello1 p "Hello from second definition" end end Demo.new.hello1
$ ruby -w demo.rb demo.rb:10: warning: method redefined; discarding old hello1 => "Hello from second definition"
irb(main):003:0* str_val = => "5.0" irb(main):006:0> str_val.to_int NoMethodError: undefined method `to_int from (irb):6 irb(main):005:0* str_val.to_i => 5 irb(main):007:0> float_val = 5.0 => 5.0 irb(main):008:0> float_val.to_int => 5 irb(main):009:0> float_val.to_i => 5 irb(main):010:0>
require dirname = File.dirname(some_path) unless File.directory?(dirname) FileUtils.mkdir_p(dirname) end
dirname = File.dirname(some_path) tokens = dirname.split(/[\/\\]/) 1.upto(tokens.size) do |n| dir = tokens[0...n] Dir.mkdir(dir) unless Dir.exist?(dir) end
directory_name = "name" Dir.mkdir(directory_name) unless File.exists?(directory_name)
screenshotfolder = "./screenshots/ unless File.directory?(screenshotfolder) FileUtils.mkdir_p(screenshotfolder) end Before do @screenshotfolder = screenshotfolder ... end
screenshotName = " @browser.take_screenshot(screenshotName) if scenario.failed? embed(screenshotName, "image/png", "SCREENSHOT") if scenario.failed?
target_dir = "" Dir.glob("/ target_dir = " end tokens = target_dir.split(/\ new_dir = 1.upto(tokens.size - 1) do |n| unless n == (tokens.size - 1) new_dir << " else new_dir << " end Dir.mkdir(new_dir) unless Dir.exist?(new_dir) end
require some_path = Pathname("somedir/some_subdir/some-file.html") some_path.dirname.mkdir_p some_path.write(builder.to_html)
"<name> <substring>"[/.*<([^>]*)/,1] => "substring"
s = "<ants> <pants>" matchdata = s.match(/<([^>]*)> <([^>]*)>/) matchdata.captures matchdata[0] matchdata[1] matchdata[2]
install: --no-rdoc --no-ri update: --no-rdoc --no-ri
hash.each{|key,value| value} => {"a"=>["a", "b", "c"], "b"=>["b", "c"]}
>> hash = { "a"=>["a", "b", "c"], "b"=>["b", "c"] } => {"a"=>["a", "b", "c"], "b"=>["b", "c"]} >> hash.values => [["a", "b", "c"], ["b", "c"]]
hash = { :a => ["a", "b", "c"], :b => ["b", "c"] } hash.values
Gem::Ext::BuildError: ERROR: Failed to build gem native extension. /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby extconf.rb creating Makefile make "DESTDIR=" clean make "DESTDIR=" compiling generator.c linking shared-object json/ext/generator.bundle clang: error: unknown argument: clang: note: this will be a hard error (cannot be downgraded to a warning) in the future make: *** [generator.bundle] Error 1 make failed, exit code 2 Gem files will remain installed in /opt/boxen/repo/.bundle/ruby/2.0.0/gems/json-1.8.0 for inspection. Results logged to /opt/boxen/repo/.bundle/ruby/2.0.0/extensions/universal-darwin-13/2.0.0/json-1.8.0/gem_make.out
\curl -sSL https: rvm install ruby-2.0.0-p451 ruby -v sudo gem install json
ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future gem install GemName
ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future bundle install
ERROR: Error installing json: ERROR: Failed to build gem native extension. fatal error:
Object.const_get(class_name).new.send(method_name,parameters_array)
Object.const_get(RandomClass).new.send(i_take_arguments,[10.0])
Object.const_get(RandomClass).new.send(i_take_multiple_arguments,[25.0,26.0])
class RandomClass def i_am_method_one puts "I am method 1" end def i_take_arguments(a) puts "the argument passed is end def i_take_multiple_arguments(b,c) puts "the arguments passed are end end
r = RandomClass.new r.__send__(:i_take_multiple_arguments,
imaginary_object.__send__(:find, :city => "city100")
imaginary_object.__send__(:find, city: "city100", loc: [-76, 39])
if r.respond_to?(method_name) puts r.__send__(method_name) else puts " end
window.myLib = window.myLib || {}; if (!window.myLib) window.myLib = {};
class Version < Array def initialize s super(s.split( end def < x (self <=> x) < 0 end def > x (self <=> x) > 0 end def == x (self <=> x) == 0 end end p [Version.new( p [Version.new(
require v1 = Versionomy.parse( v2 = Versionomy.parse( v3 = Versionomy.parse( v1 < v2 v2 < v3 v1 > v2 v2 > v3
%w<0.1 0.2.1 0.44>.map {|v| Gem::Version.new v}.max.to_s => "0.44"
class_name = "MyClass" instance = class_name.constantize.new
module One module Two class Three def say_hi puts "say hi" end end end end one = Object.const_get "One" puts one.class three = One::Two.const_get "Three" puts three.class three.new.say_hi
rake() { if [ -e ./Gemfile.lock ]; then bundle exec rake "$@"; else /usr/bin/env rake "$@"; fi; }
I18n.t("date.month_names") I18n.t("date.abbr_month_names") I18n.t("date.month_names")[Date.today.month] I18n.t("date.abbr_month_names")[Date.today.month]
<select> <option value="">Choose month</option> <%= 1.upto(12).each do |month| %> <option value="<%= month %>"><%= I18n.t("date.month_names")[month] %></option> <% end %> </select>
array = [ hash = Hash[array.map.with_index.to_a] hash[
array = %w( a b c d e) puts array.index( puts array.rindex(
a = [1, 2, 3, 1, 2, 3, 4] => [1, 2, 3, 1, 2, 3, 4] indices = a.each_with_index.inject(Hash.new { Array.new }) do |hash, (obj, i)| hash[obj] += [i] hash end => { 1 => [0, 3], 2 => [1, 4], 3 => [2, 5], 4 => [6] }
indices.select { |k, v| v.size > 1 } => { 1 => [0, 3], 2 => [1, 4], 3 => [2, 5] }
class Array def quick_index el hash = Hash[self.map.with_index.to_a] hash[el] end def quick_rindex el hash = Hash[self.reverse.map.with_index.to_a] array.length - 1 - hash[el] end end
class Array def b_search(e, l = 0, u = length - 1) return if lower_index > upper_index midpoint_index = (lower_index + upper_index) / 2 return midpoint_index if self[midpoint_index] == value if value < self[midpoint_index] b_search(value, lower_index, upper_index - 1) else b_search(value, lower_index + 1, upper_index) end end end
array.bsearch { |each| "Jamie" <=> each.name } (0..array.size).bsearch { |n| "Jamie" <=> array[n].name }
rails g model Rating user_id:integer message:string value:integer
bundle exec rake db:rollback rails destroy model <model_name>
class DropTables < ActiveRecord::Migration def up drop_table :table_you_dont_want end def down raise ActiveRecord::IrreversibleMigration end end
class DropEpisodes < ActiveRecord::Migration[5.1] def change drop_table :episodes end end
def weightedknn(data, vec1, k = 5, weightf = gaussian) foo weight = weightf(dist) foo end
gaussian = Proc.new do |dist, *args| sigma = args.first || 10.0 ... end def weightedknn(data, vec1, k = 5, weightf = gaussian) ... weight = weightf.call(dist) ... end
def weightedknn(data, vec1, k = 5, weightf = :gaussian) ... weight = self.send(weightf) ... end
def weightedknn(data, vec1, k = 5) ... weight = if block_given? yield(dist) else gaussian.call(dist) end end ... end weightedknn(foo, bar) do |dist| dist * dist end
def weightedknn( data, vec1, k = 5, weightf = method(:gaussian) ) ... weight = weightf.call( dist ) ... end
def weightedknn( data, vec1, k = 5 ) foo weight = yield( dist ) foo end
weightenknn( data, vec1 ) { |dist| gaussian( dist ) }
def foo(arg) p arg end def bar(&block) p block.call( end bar(&method(:foo))
# # def make_select_list( model, &cond ) cond ||= proc { true } model.all.map do |x| cond.( x ) ? { x.id => x.name } : {} end.reduce Hash.new do |memo, e| memo.merge( e ) end end
@contests = make_select_list Contest do |contest| logged_admin? or contest.organizer == @current_user end
class X < String end foo = X.new foo.is_a? String foo.kind_of? String foo.instance_of? String foo.instance_of? X
class Object def is_string? false end end class String def is_string? true end end print "test".is_string? print 1.is_string?
sudo apt-get install mercurial hg clone https: cd vim ./configure --enable-rubyinterp make sudo make install
-python3 +quickfix +reltime -rightleft +ruby +scrollbind +signs +smartindent
rvm use system brew install macvim ln -s /usr/local/bin/mvim /usr/local/bin/vim
hg clone https: cd vim ./configure --enable-rubyinterp
irb(main):002:0> {1,2} SyntaxError: (irb):2: syntax error, unexpected
irb(main):001:0> case SyntaxError: (irb):1: syntax error, unexpected expecting keyword_then or
irb(main):001:0> i=0; [1,2,3].each {|i|}; i => 0 irb(main):002:0> i=0; for i in [1,2,3]; end; i => 3
irb(main):001:0> {1=>2}.index(2) (irb):18: warning: Hash => 1 irb(main):002:0> {1=>2}.key(2) => 1
irb(main):001:0> 5.to_sym NoMethodError: undefined method
irb(main):001:0> {:a=>"a", :c=>"c", :b=>"b"} => {:a=>"a", :c=>"c", :b=>"b"}
irb(main):001:0> {:a=>"a", :c=>"c", :b=>"b"} => {:a=>"a", :b=>"b", :c=>"c"}
irb(main):001:0> /\x80/u SyntaxError: (irb):2: invalid multibyte escape: /\x80/
unicode(string).tr(CP1252_DIFFERENCES, UNICODE_EQUIVALENT). gsub(INVALID_XML_CHAR, REPLACEMENT_CHAR). gsub(XML_PREDEFINED) {|c| PREDEFINED[c.ord]}
def xchr(escape=true) n = XChar::CP1252[self] || self case n when *XChar::VALID XChar::PREDEFINED[n] or (n>128 ? n.chr : (escape ? "& else Builder::XChar::REPLACEMENT_CHAR end end unpack(
irb(main):001:0> class C < BasicObject; def f; Math::PI; end; end; C.new.f NameError: uninitialized constant C::Math
irb(main):001:0> require => true irb(main):002:0> class C < BlankSlate; def f; Math::PI; end; end; C.new.f => 3.14159265358979
irb(main):002:0> class C < SimpleDelegator; end => nil irb(main):003:0> C.new( => String
irb(main):002:0> class C < SimpleDelegator; end => nil irb(main):003:0> C.new( => C irb(main):004:0>
irb(main):004:1> $KCODE = (irb):4: warning: variable $KCODE is no longer effective; ignored => "UTF8"
short_enum = [1, 2, 3].to_enum long_enum = ( loop do puts " end
def foo(first, *middle, last) (->a, *b, c {p a-c}).(*5.downto(1))
f = Fiber.new do a,b = 0,1 Fiber.yield a Fiber.yield b loop do a,b = b,a+b Fiber.yield b end end 10.times {puts f.resume}
match = while line = gets next if line =~ /^ break line if line.find( end
def toggle def toggle "subsequent times" end "first time" end
def function(array) array.each { |v| p v } end function "1"
X=[1,2,3] X.each do |p| puts "current index..." end
X.each_with_index do |item, index| puts "current_index: end
def do() return ["a", 10, SomeObject.new] end [a, b, c] = do
def sumdiff(x, y) return x+y, x-y end sumdiff(3, 4) a = sumdiff(3,4) a a,b=sumdiff(3,4) a b a,b,c=sumdiff(3,4) a b c
ary = [1, 2, 3, 4] a, b, c = ary p a p b p c a, b, *c = ary p c a, b, c, d, e = ary p d p e
a, b = b, a a, b = 1, 2, 3 p b def foo; return 1, 2 end a, b = foo p a p b
def foo(((a, b, c, d), e, *f), g, *h) local_variables.sort.each do |lvar| puts " end foo([[1, 2, 3], 4, 5, 6], 7, 8, 9)
$ irb >> DateTime.new.to_date NoMethodError: undefined method from (irb):1 >> require => true >> DateTime.new.to_date => Mon, 01 Jan -4712
%a - The abbreviated weekday name (``Sun %A - The full weekday name (``Sunday %b - The abbreviated month name (``Jan %B - The full month name (``January %c - The preferred local date and time representation %d - Day of the month (01..31) %H - Hour of the day, 24-hour clock (00..23) %I - Hour of the day, 12-hour clock (01..12) %j - Day of the year (001..366) %m - Month of the year (01..12) %M - Minute of the hour (00..59) %p - Meridian indicator (``AM %S - Second of the minute (00..60) %U - Week number of the current year, starting with the first Sunday as the first day of the first week (00..53) %W - Week number of the current year, starting with the first Monday as the first day of the first week (00..53) %w - Day of the week (Sunday is 0, 0..6) %x - Preferred representation for the date alone, no time %X - Preferred representation for the time alone, no date %y - Year without a century (00..99) %Y - Year with century %Z - Time zone name %% - Literal ``% t = Time.now t.strftime("Printed on %m/%d/%Y") t.strftime("at %I:%M%p")
>> y User.first --- !ruby/object:User attributes: created_at: 2009-05-24 20:16:11.099441 updated_at: 2009-05-26 22:46:29.501245 current_login_ip: 127.0.0.1 id: "1" current_login_at: 2009-05-24 20:20:46.627254 login_count: "1" last_login_ip: last_login_at: login: admin attributes_cache: {} => nil >>
>> raise Rails.root RuntimeError: /home/marcin/work/github/project1 from (irb):17 >>
def index @posts = Post.all end <%= debug(@posts) %> rails -s
- !ruby/object:Post raw_attributes: id: 2 title: My Second Post body: Welcome! This is another example post published_at: created_at: updated_at: attributes: !ruby/object:ActiveRecord::AttributeSet attributes: !ruby/object:ActiveRecord::LazyAttributeHash types: &5 id: &2 !ruby/object:ActiveRecord::Type::Integer precision: scale: limit: range: !ruby/range begin: -2147483648 end: 2147483648 excl: true title: &3 !ruby/object:ActiveRecord::Type::String precision: scale: limit: body: &4 !ruby/object:ActiveRecord::Type::Text precision: scale: limit: published_at: !ruby/object:ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter subtype: &1 !ruby/object:ActiveRecord::Type::DateTime precision: scale: limit: created_at: !ruby/object:ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter subtype: *1 updated_at: !ruby/object:ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter subtype: *1
require module AppHelpers module Debug module VarDump class << self def dump(dump_object, file_path) File.open file_path, "a+" do |log_file| current_date = Time.new.to_s + "\n" + YAML::dump(dump_object) + "\n" log_file.puts current_date log_file.close end end end end end end
it "updates updated_at attribute" do Timecop.freeze patch :update @article.reload expect(@article.updated_at).to eq(Time.now) end
Failure/Error: expect(@article.updated_at).to eq(Time.now) expected: 2013-12-05 14:42:20 UTC got: Thu, 05 Dec 2013 08:42:20 CST -06:00 (compared using ==)
it "updates updated_at attribute" do Timecop.freeze patch :update @article.reload expect(@article.updated_at.utc).to eq(Time.now) end
Failure/Error: expect(@article.updated_at.utc).to eq(Time.now) expected: 2013-12-05 14:42:20 UTC got: 2013-12-05 14:42:20 UTC (compared using ==)
expect(@article.updated_at.utc.to_s).to eq(Time.now.to_s)
expect(@article.updated_at.utc.to_i).to eq(Time.now.to_i)
expect(@article.updated_at.utc).to be_within(1.second).of Time.now
it "updates updated_at attribute" do freezed_time = Time.utc(2015, 1, 1, 12, 0, 0) Timecop.freeze(freezed_time) patch :update @article.reload expect(@article.updated_at).to eq(freezed_time) end
it do stubtime = Time.now.midday expect(Time).to receive(:now).and_return(stubtime) patch :update expect(@article.reload.updated_at).to eq(stubtime) end
class MyService attr_reader :time_evaluator, resource def initialize(resource:, time_evaluator: ->{Time.now}) @time_evaluator = time_evaluator @resource = resource end def call resource.published_at = time_evaluator.call end end require require require RSpec.describe MyService do let(:service) { described_class.new(resource: resource, time_evaluator: -> { Time.now.midday } ) } let(:resource) { OpenStruct.new } it do service.call expect(resource.published_at).to eq(Time.now.midday) end end
expect({mytime: Time.now}).to match({mytime: be_within(3.seconds).of(Time.now)}) `
hash = {mytime: Time.now.to_s(:db)} expect(hash).to match({mytime: be_kind_of(String)) expect(Time.parse(hash.fetch(:mytime))).to be_within(3.seconds).of(Time.now)
expect(hash).to match({mytime: be_near_time_now_db_string})
expect(@article.updated_at.to_s(:db)).to eq expect(@article.updated_at.to_s(:db)).to eq Time.current.to_s(:db)
module SpecHelpers def current_time Time.zone.now.change(usec: 0) end end RSpec.configure do |config| config.include SpecHelpers end
it "updates updated_at attribute" do Timecop.freeze(current_time) patch :update @article.reload expect(@article.updated_at).to eq(current_time) end
>> str = => "[\\w\\s]+" >> Regexp.new str => /[\w\s]+/
puts "Enter A" a = gets.chomp puts "Enter B" b = gets.chomp c = a.to_i + b.to_i puts c
first_number = ARGV[0].to_i second_number = ARGV[1].to_i puts first_number + second_number
namespace :rake do desc "Run a task on a remote server." task :invoke do run("cd end end
desc task :invoke, [:command] => on primary(:app) do within current_path do with :rails_env => fetch(:rails_env) do rake args[:command] end end end end
desc "Run the super-awesome rake task" task :super_awesome do rake = fetch(:rake, rails_env = fetch(:rails_env, run "cd end
def run_rake(task, options={}, &block) command = "cd run(command, options, &block) end
Cape.local_rake_executable = Cape.remote_rake_executable =
namespace :rake_task do task :invoke do if ENV[ puts "USAGE: cap rake_task:invoke COMMAND= else run "cd end end end
def rake(cmd, options={}, &block) command = "cd run(command, options, &block) end
task :invoke, :command do |task, args| on roles(:app) do within current_path do with rails_env: fetch(:rails_env) do execute :rake, args[:command] end end end end
$ cap rake -s rake_task=$rake_task task :rake do rake = fetch(:rake, rails_env = fetch(:rails_env, run "cd end
task :invoke, [:command] => on primary(:app) do within current_path do with :rails_env => fetch(:rails_env) do execute :rake, " end end end end
namespace :invoke do desc task :bash, :execute do |_task, args| on roles(:app), in: :sequence do SSHKit.config.format = :supersimple execute args[:execute] end end desc task :rake, :task do |_task, args| on primary :app do within current_path do with rails_env: fetch(:rails_env) do SSHKit.config.format = :supersimple rake args[:task] end end end end end
module SSHKit module Formatter class SuperSimple < SSHKit::Formatter::Abstract def write(obj) case obj when SSHKit::Command then write_command(obj) when SSHKit::LogMessage then write_log_message(obj) end end alias :<< :write private def write_command(command) unless command.started? && SSHKit.config.output_verbosity == Logger::DEBUG original_output << "Running if SSHKit.config.output_verbosity == Logger::DEBUG original_output << "Command: end end unless command.stdout.empty? command.stdout.lines.each do |line| original_output << line original_output << "\n" unless line[-1] == "\n" end end unless command.stderr.empty? command.stderr.lines.each do |line| original_output << line original_output << "\n" unless line[-1] == "\n" end end end def write_log_message(log_message) original_output << log_message.to_s + "\n" end end end end
begin rescue SignalException => e raise e rescue Exception => e end
rescue SystemExit, Interrupt raise rescue Exception => e end
trap("SIGINT") { throw :ctrl_c } catch :ctrl_c do begin sleep(10) rescue Exception puts "Not printed" end end
require context = ZMQ::Context.new(1) socket = context.socket(ZMQ::REP) socket.bind("tcp: trap("INT") { puts "Shutting down."; socket.close; context.terminate; exit} puts "Starting up" while true do message = socket.recv_string puts "Message: socket.send_string("Message received") end
zone = ActiveSupport::TimeZone.new("Central Time (US & Canada)") Time.now.in_time_zone(zone)
Time.now.in_time_zone("Central Time (US & Canada)")
ActiveSupport::TimeZone.all.map(&:name) ActiveSupport::TimeZone.us_zones.map(&:name)
> @date => Tue, 02 Sep 2014 23:59:59 +0000 > @date.class => DateTime > @date.to_time => 2014-09-02 12:59:59 -1100 > @date.to_time.to_datetime => Tue, 02 Sep 2014 12:59:59 -1100
require d=DateTime.parse( l=d.new_offset( u=l.new_offset( puts "
class AddTimeZoneColumnToTextmessage < ActiveRecord::Migration def change add_column :textmessages, :time_zone, :string end end
class SetDefault < ActiveRecord::Migration def self.up change_column :people, :last_name, :type, :default => "Doe" end def self.down raise ActiveRecord::IrreversibleMigration, "Can end end
class GenericPerson < Person def initialize(attributes=nil) attr_with_defaults = {:last_name => "Doe"}.merge(attributes) super(attr_with_defaults) end end
class SetDefault < ActiveRecord::Migration def change change_column :table_name, :column_name, :type, default: "Your value" end end
add_column :accounts, :max_users, :integer, :default => 10
def after_initialize if new_record? max_users ||= 10 end end
class SetDefault < ActiveRecord::Migration def up change_column_default :people, :last_name, "Smith" end def down change_column_default :people, :last_name, nil end end
class AddSsl < ActiveRecord::Migration def self.up add_column :accounts, :ssl_enabled, :boolean, :default => true end def self.down remove_column :accounts, :ssl_enabled end end
class Foo < ActiveRecord::Base after_initialize :assign_defaults_on_new_Foo ... attr_accessible :bar ... private def assign_defaults_on_new_Foo self.bar = default_value unless self.attribute_whose_presence_has_been_validated end end
class Foo < ActiveRecord::Base after_initialize :assign_defaults_on_new_Foo, if: ... attr_accessible :bar ... private def assign_defaults_on_new_Foo self.bar = default_value end end
def change add_column :users, :eula_accepted, :boolean, default: false end
class StoreListing < ActiveRecord::Base attribute :country, :string, default: end
a = Item.new a.published_at a = Item.new(:published_at => nil) a.published_at
class Item < ActiveRecord::Base def self.column_defaults super.merge( end end
class SOF attr_accessor_with_default :is_awesome,true end sof = SOF.new sof.is_awesome => true
class SOF attr_writer :is_awesome def is_awesome @is_awesome ||= true end end sof = SOF.new sof.is_awesome
def initialize(*args) super(*args) self.attribute_that_needs_default_value ||= default_value self.attribute_that_needs_another_default_value ||= another_default_value end
seconds = total_seconds % 60 minutes = (total_seconds / 60) % 60 hours = total_seconds / (60 * 60) format("%02d:%02d:%02d", hours, minutes, seconds)
"%02d:%02d:%02d:%02d" % [t/86400, t/3600%24, t/60%60, t%60]
t = 123456 "%02d:%02d:%02d:%02d" % [t/86400, t/3600%24, t/60%60, t%60] => "01:10:17:36"
class Integer def pretty_duration parse_string = if self < 3600 else end Time.at(self).utc.strftime(parse_string) end end
def duration(seconds) minutes, seconds = seconds.divmod(60) hours, minutes = minutes.divmod(60) days, hours = hours.divmod(24) " end
2.2.2 :004 > Time.at(60 * 60).utc.strftime( => "01 h 00 m"
2.2.2 :006 > Time.at(60 * 60 * 24).utc.strftime( => "00 h 00 m"
def formatted_duration total_seconds hours = total_seconds / (60 * 60) minutes = (total_seconds / 60) % 60 seconds = total_seconds % 60 " end
milliseconds = duration.in_milliseconds % 1.second.in_milliseconds seconds = (duration / 1.second) % (1.minute / 1.second) minutes = (duration / 1.minute) % (1.hour / 1.minute) hours = (duration / 1.hour) % (1.day / 1.hour) format("%02d:%02d:%02d:%03d", hours, minutes, seconds, milliseconds)
ExecJS::RuntimeError in Static_pages Showing C:/Users/.../bootcamp-sample-app/app/views/layouts/application.html.erb where line ["ok","(function() {\n\n\n\n}).call(this);\n"] (in C:/Users/.../bootcamp-sample-app/app/assets/javascripts/sessions.js.coffee) Extracted source (around line 3: <head> 4: <title><%= full_title(yield(:title)) %></title> 5: <%= stylesheet_link_tag "application", media: "all" %> 6: <%= javascript_include_tag "application" %> 7: <%= csrf_meta_tags %> 8: <%= render 9: </head> Rails.root: C:/Users/.../bootcamp-sample-app Application Trace | Framework Trace | Full Trace app/views/layouts/application.html.erb:6:in `_app_views_layouts_application_html_erb___487732698_30422172' Request
source gem gem gem gem gem gem group :development, :test do gem gem gem gem end group :development do gem end group :assets do gem gem gem gem end gem gem group :test do gem gem gem gem gem gem end group :production do gem end
<!DOCTYPE html> <html> <head> <title><%= full_title(yield(:title)) %></title> <%= stylesheet_link_tag "application", media: "all" %> <%= javascript_include_tag "application" %> <%= csrf_meta_tags %> <%= render </head> <body> <%= render <div class="container"> <%= yield %> <%= render </div> </body> </html>
Processing by StaticPagesController Rendered static_pages/home.html.erb within layouts/application (45.0ms) Completed 500 Internal Server Error in 1136ms ActionView::Template::Error (["ok","(function() {\n\n\n\n}).call(this);\n"] (in C:/Users/.../bootcamp-sample-app/app/assets/javascripts/sessions.js.coffee)): 3: <head> 4: <title><%= full_title(yield(:title)) %></title> 5: <%= stylesheet_link_tag "application", media: "all" %> 6: <%= javascript_include_tag "application" %> 7: <%= csrf_meta_tags %> 8: <%= render 9: </head> app/views/layouts/application.html.erb:6:in `_app_views_layouts_application_html_erb___487732698_30422172' Rendered C:/RailsInstaller/Ruby1.9.3/lib/ruby/gems/1.9.1/gems/actionpack-3.2.8/lib/action_dispatch/middleware/templates/rescues/_trace.erb (2.0ms) Rendered C:/RailsInstaller/Ruby1.9.3/lib/ruby/gems/1.9.1/gems/actionpack-3.2.8/lib/action_dispatch/middleware/templates/rescues/_request_and_response.erb (1.0ms) Rendered C:/RailsInstaller/Ruby1.9.3/lib/ruby/gems/1.9.1/gems/actionpack-3.2.8/lib/action_dispatch/middleware/templates/rescues/template_error.erb within rescues/layout (34.0ms)
JScript = ExternalRuntime.new( :name => "JScript", :command => "cscript :runner_path => ExecJS.root + "/support/jscript_runner.js", :encoding => )
source gem group :development do gem end group :assets do gem gem gem end gem group :production do gem end
(1..5) === 3 (1..5) === 6 Integer === 42 Integer === /ell/ === /ell/ ===
case foo when bar baz when quux flurb else blarf end
_temp = foo if bar === _temp baz elsif quux === _temp flurb else blarf end
(1...3) === 2 => true /test/ === "this is a test" => true case when /blah/ "Blach" when /test/ "Test" else "Fail" end => "Test"
def self.create_methods(method_name) define_method method_name do ... end ??? end
class A define_singleton_method :loudly do |message| puts message.upcase end end A.loudly "my message"
class Object def metaclass class << self self end end end class MyClass self.metaclass.send(:define_method, :my_method) do ... end end
class A class << self def method_name ... end end end
self.create_class_method(method_name) (class << self; self; end).instance_eval do define_method method_name do ... end end end
self.create_class_method(method_name) (class << self; self; end).send(:define_method, method_name) do ... end end
module Concerns::Testable extend ActiveSupport::Concern included do singleton_class.instance_eval do define_method(:test) do puts end end end end
A.class_eval do def self.class_method_name(param) puts param end end A.class_method_name("hello")
class B def self.class_method(param) puts param end end B.class_method("something")
File.open( block = proc { |response| response.read_body do |chunk| f.write chunk end } RestClient::Request.execute(method: :get, url: block_response: block) }
irb(main):003:0> sprintf => "01" irb(main):004:0> sprintf => "10"
abc= 5 puts "%.2i" %abc >> 05 abc= 5.0 puts "%.2f" %abc >> 5.00
.rvm/rubies/ruby-1.9.2-p180/lib/ruby/site_ruby/1.9.1/rubygems/dependency.rb:247:in `to_specs [rake-0.8.7, rake-0.8.7, rubygems-update-1.8.4] (Gem::LoadError)
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"
name = puts name.[0..0] puts name.[0] puts name.[0,1] puts name.[0].chr
Given /^I login successfully$/ step "I login with valid credentials" end
Given /^I login successfully$/ Given "I login with valid credentials" Then "I should be logged in" end
Background: Given I log in with valid credentials Scenario: Change my password Given I am on the account page
When /^I make all my stuff shiny$/ step "I polish my first thing" end When /^I make all my stuff shiny$/ steps %Q{ When I polish my first thing When I shine my second thing } end
module KnowsUser def login visit( fill_in( fill_in( click_button( end def user @user ||= User.create!(:name => end end World(KnowsUser) When /^I login$/ do login end Given /^a logged in user$/ do login end
Given /^I login successfully$ step %{I login with valid credentials} end Given /^I login with (.*) credentials$/ |type| end
Scenario Outline: To check login functionality Given I login with "<username>" and "<password>" Then I "<may or may not>" login successfully Examples: |username|password|may or may not| |paul |123$ |may | |dave |1111 |may not |
@Given(I login with \"([^\"]*)\" and \"([^\"]*)\"$) public void I_login_with_and(String username, String password){ } @Then(I \"([^\"]*)\" login successfully$) public void I_login_successully_if(String validity){ if(validity.equals("may")){ } else if(validity.equals("may not")){ } }
require begin Date.parse("31-02-2010") rescue ArgumentError end
d, m, y = date_string.split Date.valid_date? y.to_i, m.to_i, d.to_i
>> Date.parse( ArgumentError: invalid date >> Date.parse(
class Date def self.parsable?(string) begin parse(string) true rescue ArgumentError false end end end
Date.parsable?("10-10-2010") Date.parse("10-10-2010") Date.parsable?("1") Date.parse("1")
date_hash = Date._parse(date.to_s) Date.valid_date?(date_hash[:year].to_i, date_hash[:mon].to_i, date_hash[:mday].to_i)
Date.parse("Tue, 2017-01-17", "%a, %Y-%m-%d") Date.parse("Wed, 2017-01-17", "%a, %Y-%m-%d")
module StrictDateParsing def self.parse(input_string, format) date = Date.strptime(input_string, format) confirmation = date.strftime(format) if confirmation == input_string date else fail InvalidDate.new( " ) end end InvalidDate = Class.new(RuntimeError) end
class String def is_date? temp = self.gsub(/[-.\/]/, [ begin return true if Date.strptime(temp, f) rescue end end return false end end
"test".is_date? "10-12-2010".is_date? params[:some_field].is_date? etc.
/(\d{1,2}[-\/]\d{1,2}[-\/]\d{4})|(\d{4}[-\/]\d{1,2}[-\/]\d{1,2})/.match("31-02-2010")
require def time_between(new_date, old_date) new_date = (Date.parse new_date rescue nil) old_date = (Date.parse old_date rescue nil) return nil if new_date.nil? || old_date.nil? (new_date - old_date).to_i end puts time_between(1,2).nil? puts time_between(Time.now.to_s,Time.now.to_s).nil?
Date.parse("12!12*2012") => Thu, 12 Apr 2018 Date.parse("12!12&2012") => Thu, 12 Apr 2018
Date.parse("12!12*2012".gsub(/[^\d,\.,\-]/, => ArgumentError: invalid date Date.parse("12-12-2012".gsub(/[^\d,\.,\-]/, => Wed, 12 Dec 2012 Date.parse("12.12.2012".gsub(/[^\d,\.,\-]/, => Wed, 12 Dec 2012
require def is_date_valid?(d) Date.valid_date? *" end
config[:dates].split(",").all? { |x| is_date_valid?(x)}
test "image upload" do test_image = path-to-fixtures-image + "/Test.jpg" file = Rack::Test::UploadedFile.new(test_image, "image/jpeg") post "/create", :user => { :avatar => file } post "/create", :user => { :avatar => file } assert_response 201 assert_response :success end
uploaded_file = ActionDispatch::Http::UploadedFile.new({ :tempfile => File.new(Rails.root.join("test/fixtures/files/test.jpg")) }) assert model.valid?
describe UsersController, "POST create" do after do end it "should be able to upload a user image = fixture_path + "/test_avatar.png" file = ActionController::TestUploadedFile.new image, "image/png" post :create, :user => { :avatar => file } User.last.avatar.original_filename.should == "test_avatar.png" end end
factory :image_100_100 do image File.new(File.join(::Rails.root.to_s, "/test/images", "100_100.jpg")) end
json_file = params[:json_file] FileUtils.mv(json_file.tempfile, File.expand_path(
json_file = mock( json_file.should_receive(:tempfile).and_return("files/bulk_bookmark.json") post response.should be_success
user = User.new.tap do |u| u.username = "foobar" u.save! end
user = User.new user.username = "foobar" user.save!
user = User.new user.username = "foobar" user.save!
user = User.new.tap do |u| u.username = "foobar" u.save! end
def some_method ... some_object.serialize some_object end
def some_method ... some_object.tap{ |o| o.serialize } end
user = User.new.tap do |u| u.build_profile u.process_credit_card u.ship_out_item u.send_email_confirmation u.blahblahyougetmypoint end
user = User.new user.build_profile user.process_credit_card user.ship_out_item user.send_email_confirmation user.blahblahyougetmypoint
User .active .tap { |users| puts "Users so far: .non_admin .tap { |users| puts "Users so far: .at_least_years_old(25) .tap { |users| puts "Users so far: .residing_in(
def rockwell_retro_encabulate provide_inverse_reactive_current synchronize_cardinal_graham_meters @result.tap(&method(:puts)) end
def make_user(name) user = User.new user.username = name user.save! end
def make_user(name) user = User.new user.username = name return user.save! end
def tapping2 Hash.new.tap do |h| h[:one] = 1 h[:two] = 2 end end
%w( annotations ... routes tmp ).tap { |arr| arr << }.each do |task| ... end
[].tap do |msg| msg << "EXPLAIN for: ... msg << connection.explain(sql, bind) end.join("\n")
def select(*args, &block) dup.tap { |hash| hash.select!(*args, &block) } end
Rails::Server.new.tap do |server| require APP_PATH Dir.chdir(Rails.application.root) server.start end
@pirate = Pirate.new.tap do |pirate| pirate.catchphrase = "Don pirate.birds_attributes = [{:name => pirate.save! end
yield.tap do |rendered_partial| collection_cache.write(key, rendered_partial, cache_options) end
(1..10).tap { |x| puts "original: tap { |x| puts "array: select { |x| x%2 == 0 }. tap { |x| puts "evens: map { |x| x*x }. tap { |x| puts "squares:
def update_params(params) params[:foo] = params end
def update_params(params) params.tap {|p| p[:foo] = end
def client_params params.require(:client).permit(:name).tap do |whitelist| whitelist[:name] = params[:client][:name] end end
def user_params params.require(:user).permit( :first_name, :last_name, :email, :address_attributes ) end
def user_params u_params = params.require(:user).permit( :first_name, :last_name, :email, :address_attributes ) u_params[:time_zone] = address_timezone if u_params[:address_attributes] u_params end
def user_params params.require(:user).permit( :first_name, :last_name, :email, :address_attributes ).tap do |u_params| u_params[:time_zone] = address_timezone if u_params[:address_attributes] end end
def a_method ... name = "foobar" ... return User.new.tap do |u| u.username = name u.save! end end
user = User.new.tap do |u| u.username = "foobar" u.save! end
function get_code(str){ return str.replace(/^(Z_.*): .*/,"$1")​​​​​​​​​​​​​​​​​​​​​​​​​​​; }
"Z_sdsd: sdsd".gsub(/^(Z_.*): .*/) { |capture| capture } "Z_sdsd: sdsd".gsub(/^(Z_.*): .*/, "$1") "Z_sdsd: sdsd".gsub(/^(Z_.*): .*/, " "Z_sdsd: sdsd".gsub(/^(Z_.*): .*/, "\1") "Z_sdsd: sdsd".gsub(/(.).*/) { |capture| capture }
str = "Leesburg, Virginia 20176" state_regex = Regexp.new(/,\s*([A-Za-z]{2,})\s*\d{5,}/) > str[state_regex] => ", Virginia 20176" > str[state_regex, 1] => "Virginia"
def show_methods(class) puts Object.const_get(class).methods.inspect end show_methods "Kernel"
test.rb:1: syntax error, unexpected kCLASS, expecting def show_methods(class) ^ test.rb:2: syntax error, unexpected puts Object.const_get(class).methods.inspect
def show_methods(klass) puts Object.const_get(klass).methods.inspect end show_methods "Kernel"
["method", "inspect", "name", "public_class_method", "chop!"...
class Author < ActiveRecord::Base has_many :books end Author.reflect_on_association(:books).klass
class User attr_accessor :name def set_fullname @name = " end end
module Authentication mattr_accessor :current_user def login @current_user = session[:user_id] || nil end end
module Config mattr_accessor :hostname mattr_accessor :admin_email end
module Config def self.hostname @hostname end def self.hostname=(hostname) @hostname = hostname end def self.admin_email @admin_email end def self.admin_email=(admin_email) @admin_email = admin_email end end
>> Config.hostname = "example.com" >> Config.admin_email = "admin@example.com" >> Config.hostname >> Config.admin_email
module MyModule mattr_accessor :mattr_in_module end class MyClass include MyModule def self.get_mattr; @@mattr_in_module; end end MyModule.mattr_in_module = => "foo" MyClass.get_mattr => "foo" class SecondClass include MyModule def self.get_mattr; @@mattr_in_module; end end SecondClass.get_mattr => "foo"
sudo gem uninstall -v sudo gem update --system --local
arr = [["Cat", "Dog", "Mouse", "boo", "zoo"], ["and", "&"], ["hello", "there", "you"]] first, *rest = *arr; first.zip(*rest).flatten.compact => ["Cat", "and", "hello", "Dog", "&", "there", "Mouse", "you", "boo", "zoo"]
>> a.map.with_index { |x, i| [x, i == a.size - 2 ? s.last : s.first] }.flatten[0..-2]
a = [ ["and", "&"], ["Cat", "Dog", "Mouse"] ] b = a.max_by(&:length) a -= [b] b.zip(*a).flatten.compact => ["Cat", "and", "Dog", "&", "Mouse"]
preferred_arr = ["Cat", "Dog", "Mouse"] other_arr = ["and","&","are","great","friends"] preferred_arr << nil while preferred_arr.length < other_arr.length preferred_arr.zip(other_arr).flatten.compact
s = "foo" old_id = s.object_id s << "bar" s s.object_id == old_id
require RestClient.post( :name_of_file_param => File.new(
require url = URI.parse( File.open("./image.jpg") do |jpg| req = Net::HTTP::Post::Multipart.new url.path, "file" => UploadIO.new(jpg, "image/jpeg", "image.jpg") res = Net::HTTP.start(url.host, url.port) do |http| http.request(req) end end
n = Net::HTTP.new(url.host, url.port) n.use_ssl = true res = n.start do |http|
data, headers = Multipart::Post.prepare_query("title" => my_string, "document" => my_file)
http = Net::HTTP.new(upload_uri.host, upload_uri.port) res = http.start {|con| con.post(upload_uri.path, data, headers) }
# require require require module Multipart VERSION = "1.0.0" class Post USERAGENT = "Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en-us) AppleWebKit/523.10.6 (KHTML, like Gecko) Version/3.0.4 Safari/523.10.6" BOUNDARY = "0123456789ABLEWASIEREISAWELBA9876543210" CONTENT_TYPE = "multipart/form-data; boundary= HEADER = { "Content-Type" => CONTENT_TYPE, "User-Agent" => USERAGENT } def self.prepare_query(params) fp = [] params.each do |k, v| if v.respond_to?(:path) and v.respond_to?(:read) then fp.push(FileParam.new(k, v.path, v.read)) else fp.push(StringParam.new(k, v)) end end query = fp.collect {|p| "--" + BOUNDARY + "\r\n" + p.to_multipart }.join("") + "--" + BOUNDARY + "--" return query, HEADER end end private class StringParam attr_accessor :k, :v def initialize(k, v) @k = k @v = v end def to_multipart return "Content-Disposition: form-data; name=\" end end class FileParam attr_accessor :k, :filename, :content def initialize(k, filename, content) @k = k @filename = filename @content = content end def to_multipart mime_type = MIME::Types.type_for(filename)[0] || MIME::Types["application/octet-stream"][0] return "Content-Disposition: form-data; name=\" "Content-Type: end end end
require require post_data = fields_hash.map { |k, v| Curl::PostField.content(k, v.to_s) } post_data << Curl::PostField.file( c = Curl::Easy.new( c.multipart_form_post = true c.http_post(post_data) y [c.response_code, c.body_str]
uri = URI( request = Net::HTTP::Post.new(uri) request[ form_data = [[ request.set_form form_data, response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http| http.request(request) end
class Multipart def initialize( file_names ) @file_names = file_names end def post( to_url ) boundary = parts = [] streams = [] @file_names.each do |param_name, filepath| pos = filepath.rindex( filename = filepath[pos + 1, filepath.length - pos] parts << StringPart.new ( "--" + boundary + "\r\n" + "Content-Disposition: form-data; name=\"" + param_name.to_s + "\"; filename=\"" + filename + "\"\r\n" + "Content-Type: video/x-msvideo\r\n\r\n") stream = File.open(filepath, "rb") streams << stream parts << StreamPart.new (stream, File.size(filepath)) end parts << StringPart.new ( "\r\n--" + boundary + "--\r\n" ) post_stream = MultipartStream.new( parts ) url = URI.parse( to_url ) req = Net::HTTP::Post.new(url.path) req.content_length = post_stream.size req.content_type = req.body_stream = post_stream res = Net::HTTP.new(url.host, url.port).start {|http| http.request(req) } streams.each do |stream| stream.close(); end res end end class StreamPart def initialize( stream, size ) @stream, @size = stream, size end def size @size end def read ( offset, how_much ) @stream.read ( how_much ) end end class StringPart def initialize ( str ) @str = str end def size @str.length end def read ( offset, how_much ) @str[offset, how_much] end end class MultipartStream def initialize( parts ) @parts = parts @part_no = 0; @part_offset = 0; end def size total = 0 @parts.each do |part| total += part.size end total end def read ( how_much ) if @part_no >= @parts.size return nil; end how_much_current_part = @parts[@part_no].size - @part_offset how_much_current_part = if how_much_current_part > how_much how_much else how_much_current_part end how_much_next_part = how_much - how_much_current_part current_part = @parts[@part_no].read(@part_offset, how_much_current_part ) if how_much_next_part > 0 @part_no += 1 @part_offset = 0 next_part = read ( how_much_next_part ) current_part + if next_part next_part else end else @part_offset += how_much_current_part current_part end end end
def model_params require_params = params.require(:model).permit(:param_one, :param_two, :param_three, :avatar) require_params[:avatar] = model_params[:avatar].present? ? UploadIO.new(model_params[:avatar].tempfile, model_params[:avatar].content_type, model_params[:avatar].original_filename) : nil require_params end require url = URI.parse( Net::HTTP.start(url.host, url.port) do |http| req = Net::HTTP::Post::Multipart.new(url, model_params) key = "authorization_key" req.add_field("Authorization", key) http.use_ssl = (url.scheme == "https") http.request(req) end
h = Hash.new([]) h[0] << h[1] << h[1] h[0].object_id == h[1].object_id h
h = Hash.new { |h, k| h[k] = [] } h[0] << h[1] << h
h1 = Hash.new { |h, k| h[k] = [] } h1[:x] h1 h2 = Hash.new { [] } h2[:x] h2
h = Hash.new { |hash, key| hash[key] = []; } h[1]<<=1 h[2]<<=2
[1] pry(main)> foo = Hash.new( [] ) => {} [2] pry(main)> foo[1]+=[1] => [1] [3] pry(main)> foo[2]+=[2] => [2] [4] pry(main)> foo => {1=>[1], 2=>[2]} [5] pry(main)> bar = Hash.new { [] } => {} [6] pry(main)> bar[1]+=[1] => [1] [7] pry(main)> bar[2]+=[2] => [2] [8] pry(main)> bar => {1=>[1], 2=>[2]}
ActionMailer::Base.send(:include, Company::TenantIdLoader)
module Company module TenantIdLoader extend ActiveSupport::Concern included do cattr_accessor :tenant_dependency self.tenant_dependency = {} after_initialize do self.tenant_id = Tenant.active.id if self.class.tenant_dependent? and self.new_record? and Tenant.active.present? and !Tenant.active.zero? end end module ClassMethods def tenant_dependent? self.tenant_dependency[self.table_name] ||= self.column_names.include?( end end end end
MacBook-Pro:~ skbc$ pod setup --verbose /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/universal-darwin13/rbconfig.rb:212: warning: Insecure world writable dir /usr/local/bin in PATH, mode 040777 Setting up CocoaPods master repo Cloning spec repo `master` from `https: $ /usr/bin/git clone Cloning into
pod repo remove master git clone --depth=1 git@github.com:CocoaPods/Specs.git ~/.cocoapods/repos/master pod setup
%F - The ISO 8601 date format (%Y-%m-%d) %T - 24-hour time (%H:%M:%S)
Date (Year, Month, Day): %Y - Year with century (can be negative, 4 digits at least) -0001, 0000, 1995, 2009, 14292, etc. %C - year / 100 (round down. 20 in 2009) %y - year % 100 (00..99) %m - Month of the year, zero-padded (01..12) %_m blank-padded ( 1..12) %-m no-padded (1..12) %B - The full month name (``January %^B uppercased (``JANUARY %b - The abbreviated month name (``Jan %^b uppercased (``JAN %h - Equivalent to %b %d - Day of the month, zero-padded (01..31) %-d no-padded (1..31) %e - Day of the month, blank-padded ( 1..31) %j - Day of the year (001..366) Time (Hour, Minute, Second, Subsecond): %H - Hour of the day, 24-hour clock, zero-padded (00..23) %k - Hour of the day, 24-hour clock, blank-padded ( 0..23) %I - Hour of the day, 12-hour clock, zero-padded (01..12) %l - Hour of the day, 12-hour clock, blank-padded ( 1..12) %P - Meridian indicator, lowercase (``am %p - Meridian indicator, uppercase (``AM %M - Minute of the hour (00..59) %S - Second of the minute (00..59) %L - Millisecond of the second (000..999) %N - Fractional seconds digits, default is 9 digits (nanosecond) %3N millisecond (3 digits) %6N microsecond (6 digits) %9N nanosecond (9 digits) %12N picosecond (12 digits)
%Y%m%d => 20071119 Calendar date (basic) %F => 2007-11-19 Calendar date (extended) %Y-%m => 2007-11 Calendar date, reduced accuracy, specific month %Y => 2007 Calendar date, reduced accuracy, specific year %C => 20 Calendar date, reduced accuracy, specific century %Y%j => 2007323 Ordinal date (basic) %Y-%j => 2007-323 Ordinal date (extended) %GW%V%u => 2007W471 Week date (basic) %G-W%V-%u => 2007-W47-1 Week date (extended) %GW%V => 2007W47 Week date, reduced accuracy, specific week (basic) %G-W%V => 2007-W47 Week date, reduced accuracy, specific week (extended) %H%M%S => 083748 Local time (basic) %T => 08:37:48 Local time (extended) %H%M => 0837 Local time, reduced accuracy, specific minute (basic) %H:%M => 08:37 Local time, reduced accuracy, specific minute (extended) %H => 08 Local time, reduced accuracy, specific hour %H%M%S,%L => 083748,000 Local time with decimal fraction, comma as decimal sign (basic) %T,%L => 08:37:48,000 Local time with decimal fraction, comma as decimal sign (extended) %H%M%S.%L => 083748.000 Local time with decimal fraction, full stop as decimal sign (basic) %T.%L => 08:37:48.000 Local time with decimal fraction, full stop as decimal sign (extended) %H%M%S%z => 083748-0600 Local time and the difference from UTC (basic) %T%:z => 08:37:48-06:00 Local time and the difference from UTC (extended) %Y%m%dT%H%M%S%z => 20071119T083748-0600 Date and time of day for calendar date (basic) %FT%T%:z => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended) %Y%jT%H%M%S%z => 2007323T083748-0600 Date and time of day for ordinal date (basic) %Y-%jT%T%:z => 2007-323T08:37:48-06:00 Date and time of day for ordinal date (extended) %GW%V%uT%H%M%S%z => 2007W471T083748-0600 Date and time of day for week date (basic) %G-W%V-%uT%T%:z => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended) %Y%m%dT%H%M => 20071119T0837 Calendar date and local time (basic) %FT%R => 2007-11-19T08:37 Calendar date and local time (extended) %Y%jT%H%MZ => 2007323T0837Z Ordinal date and UTC of day (basic) %Y-%jT%RZ => 2007-323T08:37Z Ordinal date and UTC of day (extended) %GW%V%uT%H%M%z => 2007W471T0837-0600 Week date and local time and difference from UTC (basic) %G-W%V-%uT%R%:z => 2007-W47-1T08:37-06:00 Week date and local time and difference from UTC (extended)
$ heroku create Creating electric-meadow-15..... done Created http: 5.git $ git push heroku master ! No such app as fierce-fog-63 fatal: The remote end hung up unexpectedly
git remote rm heroku git remote add heroku git@heroku.com:electric-meadow-15.git
array = [1,2,3] found = array.select {|e| e == 3} found = array.detect {|e| e == 3}
a = [ "a", "b", "c", "d", "e" ] a[2] + a[0] + a[1] a[6] a[1, 2] a[1..3] a[4..7] a[6..10] a[-3, 3] a[5] a[5, 1] a[5..10]
arr = [1,2,6,4,9] arr.find {|e| e%3 == 0} arr.select {|e| e%3 == 0} 6.in?
1.9.3-p327 :012 > x = [1,2,3,4,5] => [1, 2, 3, 4, 5] 1.9.3-p327 :013 > x.select {|y| y == 1} => [1]
class Wine < ActiveRecord::Base enum color: [:red, :white, :sparkling] end
f.input :color, :as => :select, :collection => Wine.colors
<select id="wine_color" name="wine[color]"> <option value=""></option> <option value="0">red</option> <option value="1">white</option> <option value="2">sparkling</option> </select>
<select id="wine_color" name="wine[color]"> <option value=""></option> <option value="red">red</option> <option value="white">white</option> <option value="sparkling">sparkling</option> </select>
f.select :color, Wine.colors.map { |key, value| [key.humanize, key] }
<%= f.select(:color, Wine.colors.keys.map {|key| [key.humanize, key]}) %>
module EnumHelper def options_for_enum(object, enum) options = enums_to_translated_options_array(object.class.name, enum.to_s) options_for_select(options, object.send(enum)) end def enums_to_translated_options_array(klass, enum) klass.classify.safe_constantize.send(enum.pluralize).map { |key, value| [I18n.t("activerecord.enums. } end end
en: activerecord: enums: wine: color: red: "Red Wine" white: "White Wine"
<%= f.select(:color, options_for_enum(@wine, :color)) %>
<select name="f[color]" id="f_color"> <option value="red">red</option> <option value="white">white</option> <option value="sparkling"> sparkling </option> </select>
def update_or_create change_enum_to_i .... end def change_enum_to_i params[:f]["color"] = params[:f]["color"].to_i end
<%= f.select :color, Wine.colors.keys.map {|key| [t("wine.
class Contract < ApplicationRecord enum status: { active: "active", ended: "active", on_hold: "on_hold", terminated: "terminated", under_review: "under_review" , unknown: "unknown" } end
<div class="field"> <%= form.select :status, Contract.statuses.keys, {}%> </div>
2.3.0 :001 > Contract.last.status Contract Load (0.2ms) SELECT "contracts".* FROM "contracts" ORDER BY "contracts"."id" DESC LIMIT ? [["LIMIT", 1]] => "active"
def enum_collection_for_select(attribute, include_blank = true) x = attribute.map { |r| [r[0].titleize, r[0]] } x.insert(0,[ x end
<%= f.input :role, collection: enum_collection_for_select(User.roles), selected: @user.role %>
"hello".index( "hello".index( "hello".index( "hello".index(?e) "hello".index(/[aeiou]/, -3)
module T @@foo = def self.set(x) @@foo = x end def self.get @@foo end end p T.get T.set( p T::get
module SomeModule module_function def param; @param end def param= v; @param = v end end SomeModule.param SomeModule.param = 1 SomeModule.param
module MyModule class << self; attr_accessor :var; end end MyModule.var = MyModule.var => "this is saved at @var"
module MyModule class << self attr_accessor :my_variable end self.my_variable = 2 + 2 end p MyModule.my_variable
d = DateTime.now d.strftime("%d/%m/%Y %H:%M") d.next_month.strftime("%d/%m/%Y %H:%M")
require current_time = DateTime.now current_time.strftime "%d/%m/%Y %H:%M" current_time.next_month.strftime "%d/%m/%Y %H:%M"
time = Time.now.to_s time = DateTime.parse(time).strftime("%d/%m/%Y %H:%M")
datetime_month_before = DateTime.parse(time) << 1 datetime_month_before = DateTime.now << 1
date = Time.new date = date.day.to_s + "/" + date.month.to_s + "/" + date.year.to_s puts date
time = Time.new time = time.hour.to_s + ":" + time.min.to_s puts time
tempHash = { "key_a" => "val_a", "key_b" => "val_b" } fJson = File.open("public/temp.json","w") fJson.write(tempHash) fJson.close
require tempHash = { "key_a" => "val_a", "key_b" => "val_b" } File.open("public/temp.json","w") do |f| f.write(tempHash.to_json) end
require tempHash = { "key_a" => "val_a", "key_b" => "val_b" } File.open("public/temp.json","w") do |f| f.write(JSON.pretty_generate(tempHash)) end
File.open("public/temp.json","w"){ |f| f.write tempHash.to_json }
map.resources :clients, :key => :client_name do |client| client.resources :sites, :key => :name do |site| site.resources :articles, :key => :title end end
/clients/:client_name /clients/:client_name/sites/:name /clients/:client_name/sites/:site_name/articles/:title
resources :posts, param: :slug @post = Post.find_by(slug: params[:slug])
class Client < ActiveRecord::Base has_friendly_id :name end
>> Annotation.last.created_at => Sat, 29 Aug 2009 23:30:09 UTC +00:00
Loading development environment (Rails 2.3.2) >> now = DateTime.now.utc => Sun, 06 Sep 2009 22:27:45 +0000 >> now.in_time_zone( => Sun, 06 Sep 2009 18:27:45 EDT -04:00 >> quit
around_filter :set_time_zone private def set_time_zone old_time_zone = Time.zone Time.zone = current_user.time_zone if logged_in? yield ensure Time.zone = old_time_zone end
class ApplicationController < ActionController::Base before_filter :set_timezone def set_timezone Time.zone = current_user.time_zone end end
config.time_zone = Time.now.in_time_zone DateTime.now.in_time_zone
begin raise rescue => e logger.error e.message logger.error e.backtrace.join("\n") end
begin raise rescue => e logger.error e.message e.backtrace.each { |line| logger.error line } end
begin raise rescue => e logger.error ([e.message]+e.backtrace).join($/) end
RSpec.configure do |config| config.full_backtrace = true end
RSpec.configure do |config| config.backtrace_exclusion_patterns = [] end
rescue Exception => e puts "" puts e.backtrace puts ""
2.4.1 :009 > a = => "abcdefghij" 2.4.1 :010 > a.chars.last(5).join => "fghij" 2.4.1 :011 > a.chars.last(100).join => "abcdefghij"
[1] pry(main)> a = => "abcdefg" [2] pry(main)> a.first(3) => "abc" [3] pry(main)> a.last(4) => "defg"
>> s ="{\"akey\":\"one\",\"bkey\":\"two\"}" >> JSON.parse(s,:symbolize_names => true) => {:akey=>"one", :bkey=>"two"}
JSON.parse( h.to_json, {:symbolize_names => true} ) => { :youtube => { :search=> "daffy", :history => ["goofy", "mickey"] } }
ActiveSupport::JSON.decode( ActiveSupport::JSON.encode(h) ).symbolize_keys => { :youtube => { "search" => "daffy", "history" => ["goofy", "mickey"] } }
Marshal.load( Marshal.dump(h) ) => { :youtube => { :search => "daffy", "history" => ["goofy", "mickey"] } }
require def json_to_sym_hash(json) json.gsub!( parsed = JSON.parse(json) symbolize_keys(parsed) end def symbolize_keys(hash) hash.inject({}){|new_hash, key_value| key, value = key_value value = symbolize_keys(value) if value.is_a?(Hash) new_hash[key.to_sym] = value new_hash } end
require def JSON.parse(source, opts = {}) r = JSON.parser.new(source, opts).parse r = keys_to_symbol(r) if opts[:symbolize_names] return r end def keys_to_symbol(h) new_hash = {} h.each do |k,v| if v.class == String || v.class == Fixnum || v.class == Float new_hash[k.to_sym] = v elsif v.class == Hash new_hash[k.to_sym] = keys_to_symbol(v) elsif v.class == Array new_hash[k.to_sym] = keys_to_symbol_array(v) else raise ArgumentError, "Type not supported: end end return new_hash end def keys_to_symbol_array(array) new_array = [] array.each do |i| if i.class == Hash new_array << keys_to_symbol(i) elsif i.class == Array new_array << keys_to_symbol_array(i) else new_array << i end end return new_array end
YAML.load({test: { => {:test=>{"test"=>{":test"=>5}}}
require my_str = "{ my_hash = my_str.json vals = my_str.json(:age, :city) puts my_hash._user._location._city puts my_hash.user.location.city puts my_hash[:user][:location][:city]
describe Something context "some tests" do it "should blah" do true end end context "some other tests" do pending "temporarily disabled" it "should do something destructive" do blah end end end
RSpec.configure do |c| c.filter_run_excluding :broken => true end
describe "group 1", :broken => true do it "group 1 example 1" do end it "group 1 example 2" do end end describe "group 2" do it "group 2 example 1" do end end
describe "something sweet", pending: "Refactor the wazjub for easier frobbing" do it "does something well" it "rejects invalid input" end
module RSpec module Core module DSL def xdescribe(*args, &blk) describe *args do pending end end alias xcontext xdescribe end end end
xdescribe "padding" do it "returns true" do 1.should == 1 end end
context "some other tests" do it "should do something destructive" do blah end end
pending "some other tests" do it "should do something destructive" do blah end end
describe "GET /blah" do before(:each) { pending "Feature to be implemented..." } it { expect(page).to have_button("Submit") } it { expect(page).to have_content("Blah") } end
private def self.sql_where(*args) sql = self.unscoped.where(*args).to_sql match = sql.match(/WHERE\s(.*)$/) "( end
scope :whatever, -> { ors = [] ors << sql_where(A, B) ors << sql_where(C, D) ors << sql_where(E, F) where(ors.join( }
scope a, -> { where(a) } scope b, -> { where(b) } scope a_or_b, -> { a.or(b) }
User.where(name: "abc").or(User.where(name: "abcd"))
path = "/tmp/a/b/c" FileUtils.mkdir_p(path) unless File.exists?(path)
def self.create_dir_if_not_exists(path) recursive = path.split( directory = recursive.each do |sub_directory| directory += sub_directory + Dir.mkdir(directory) unless (File.directory? directory) end end
def current_user @current_user ||= User.find(session[:user_id]) if session[:user_id] end
>> User.methods - Object.methods => ["field_types", "maximum", "create!", "active_connections", "to_dropdown", "content_columns", "su_pw?", "default_timezone", "encode_quoted_value", "reloadable?", "update", "reset_sequence_name", "default_timezone=", "validate_find_options", "find_on_conditions_without_deprecation", "validates_size_of", "execute_simple_calculation", "attr_protected", "reflections", "table_name_prefix", ...
>> User.methods - ActiveRecord::Base.methods => ["field_types", "su_pw?", "set_login_attr", "create_user_and_conf_user", "original_table_name", "field_type", "authenticate", "set_default_order", "id_name?", "id_name_column", "original_locking_column", "default_order", "subclass_associations", ...
module A def method1() end end class B def method2() end end class C < B def method3() end end A.instance_methods B.instance_methods(false) C.instance_methods(false) C.instance_methods(true).length
puts "\n\current_user.methods : "+ current_user.methods.sort.join("\n").to_s+"\n\n"
u = User.first u.posts.methods u.posts.methods - Object.methods
@current_user.methods - @current_user.class.superclass.new.methods
/mi/ =~ "hi mike" "hi mike" =~ /mi/ "mike" =~ /ruby/
raise raise( string ) raise( exception [, string [, array ] ] )
raise "Failed to create socket" raise ArgumentError, "No parameters", caller
$stdout.sync = true 100.times do print "." sleep 1 end
def largest_hash_key(hash) hash.max_by{|k,v| v} end
hash.each { |k, v| puts k if v == hash.values.max }
def descend_sort(hash) hash = hash.sort_by {|k,v| v}.reverse end
hash = { "CA"=>2, "MI"=>1, "NY"=>1 } hash.invert.max&.last => "CA"
def largest_hash_key(hash) key = hash.sort{|a,b| a[1] <=> b[1]}.last puts key end hash = { "n" => 100, "m" => 100, "y" => 300, "d" => 200, "a" => 0 } largest_hash_key(hash)
module Thing def self.pub; puts "Public method"; end private def self.priv; puts "Private method"; end end
module GTranslate class Translator def perform( text ); end def self.translate( text ) t = Translator.new t.perform( text ) end end
module Foo def self.included(base) base.instance_eval do def method_name end private_class_method :method_name end end end
module Thing def self.pub; puts "Public method"; end def self.priv; puts "Private method"; end private_class_method :priv end
module Thing def self.pub; puts "Public method"; end private_class_method def self.priv; puts "Private method"; end end
module Foo def self.included(base) class << base def public_method puts "public method" end def call_private private_method end private def private_method puts "private" end end end end class Bar include Foo end Bar.public_method begin Bar.private_method rescue puts "couldn end Bar.call_private
module Writer class << self def output(s) puts upcase(s) end private def upcase(s) s.upcase end end end Writer.output "Hello World" Writer.upcase "Hello World"
module MyModule class << self def public_method tmp = private_method :public end private def private_method :private end end end puts MyModule::public_method
ErrorService.notify("Something bad happened") class ErrorService include Singleton class << self delegate :notify, to: :instance end def notify(message, severity: :error) send_exception_notification(message) log_message(message, severity) end private def send_exception_notification(message) end def log_message(message, severity) end end
module PublicModule def self.do_stuff(input) @private_implementation.do_stuff(input) end @private_implementation = Module.new do def self.do_stuff(input) input.upcase end end end
module MyModule @@my_secret_method = lambda { } end
module A @@C = lambda{ puts "C" } def self.B ; puts "B"; @@C[] ; end private def self.D ; puts "D"; @@C[] ; end end for expr in %w{ A::B A.B A::C A.C A::D A.D } eval expr rescue puts expr end
validates :title, :presence => true,:message => "Story title is required"
validates :title, presence: { message: "Story title is required" }
<ul> <% @article.errors.full_messages.each do |msg| %> <li><%= msg %></li> <% end %> </ul>
<ul> <% @article.errors.each_with_index do |msg, i| %> <li><%= msg[1] %></li> <% end %> </ul>
validates :foo, inclusion: { in: [true, false], message: "cannot be blank" }, if: :bar?
HUMANIZED_ATTRIBUTES = { :title => "story" } def self.human_attribute_name(attr, options={}) HUMANIZED_ATTRIBUTES[attr.to_sym] || super end
>> "hello".sub( => "he*lo" >> "hello".gsub( => "he**o"
value = "abc abc" puts value value = value.sub("abc", "---") puts value value = value.gsub("abc", "---") puts value
sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE) sub("4", "8", "An Introduction to R Software Course will be of 4 weeks duration" ) gsub("4", "8", "An Introduction to R Software Course will be of 4 weeks duration" )
~/code $ bundle gem my_lib create my_lib/Gemfile create my_lib/Rakefile create my_lib/LICENSE.txt create my_lib/README.md create my_lib/.gitignore create my_lib/my_lib.gemspec create my_lib/lib/my_lib.rb create my_lib/lib/my_lib/version.rb Initializating git repo in /Users/john/code/my_lib ~/code $ cd my_lib/ ~/code/my_lib $ git commit -m "Empty project" ~/code/my_lib $ rspec --init The --configure option no longer needs any arguments, so true was ignored. create spec/spec_helper.rb create .rspec
~/code/my_lib $ git add spec/spec_helper.rb ~/code/my_lib $ git commit -am "Add RSpec" ~/code/my_lib $ vim my_lib.gemspec ~/code/my_lib $ bundle ~/code/my_lib $ bundle exec guard init ~/code/my_lib $ vim Guardfile ~/code/my_lib $ git add Guardfile ~/code/my_lib $ git commit -am "Add Guard"
~/code/my_lib $ curl -u myusername https: ~/code/my_lib $ git remote add origin git@github.com:myusername/my_lib.git ~/code/my_lib $ git push
class Parser::Error < RuntimeError; end begin Parser.new(:invalid).parse! rescue Parser::Error => e puts e.message end
hash = { :a => hash[:a] hash[ hash[:b] = hash[:b] hash
hash = { Object => true, Hash => false } hash[Object] hash[Hash] hash[Array]
hash = { :a => hash.merge(:b => hash hash.merge!(:b => hash
hash = {:a => 1, :b => 2} hash.merge! :c => 3, :d => 4 p hash
x = {:ca => "Canada", :us => "United States"} x[:de] = "Germany" p x
movies ={} movie = gets.chomp rating = gets.chomp movies[movie.to_sym] = rating.to_int
def is_number?(object) true if Float(object) rescue false end
def is_number? string true if Float(string) rescue false end
class String def is_number? true if Float(self) rescue false end end
class String def numeric? return true if self =~ /\A\d+\Z/ true if Float(self) rescue false end end p "1".numeric? p "1.2".numeric? p "5.4e-29".numeric? p "12e20".numeric? p "1a".numeric? p "1.2.3.4".numeric?
# require int = bad_int = Benchmark.ips do |x| x.report( Integer(int) rescue false end x.report( Integer(bad_int) rescue false end x.report( int.to_i.to_s == int end x.report( bad_int.to_i.to_s == bad_int end x.report( int =~ /^\d+$/ end x.report( bad_int =~ /^\d+$/ end end
# require float = bad_float = Benchmark.ips do |x| x.report( Float(float) rescue false end x.report( Float(bad_float) rescue false end x.report( float.to_f.to_s == float end x.report( bad_float.to_f.to_s == bad_float end x.report( float =~ /^[-+]?[0-9]*\.?[0-9]+$/ end x.report( bad_float =~ /^[-+]?[0-9]*\.?[0-9]+$/ end end
def regex_is_number? string no_commas = string.gsub( matches = no_commas.match(/-?\d+(?:\.\d+)?/) if !matches.nil? && matches.size == 1 && matches[0] == no_commas true else false end end
def rescue_is_number? string true if Float(string) rescue false end def regex_is_number? string no_commas = string.gsub( matches = no_commas.match(/-?\d+(?:\.\d+)?/) if !matches.nil? && matches.size == 1 && matches[0] == no_commas true else false end end
test_cases = { true => ["5.5", "23", "-123", "1,234,123"], false => ["hello", "99designs", "(123)456-7890"] }
test_cases.each do |expected_answer, cases| cases.each do |test_case| if rescue_is_number?(test_case) != expected_answer puts "**rescue_is_number? got else puts "rescue_is_number? got end if regex_is_number?(test_case) != expected_answer puts "**regex_is_number? got else puts "regex_is_number? got end end end
rescue_is_number? got 5.5 right regex_is_number? got 5.5 right rescue_is_number? got 23 right regex_is_number? got 23 right rescue_is_number? got -123 right regex_is_number? got -123 right **rescue_is_number? got 1,234,123 wrong** regex_is_number? got 1,234,123 right rescue_is_number? got hello right regex_is_number? got hello right rescue_is_number? got 99designs right regex_is_number? got 99designs right rescue_is_number? got (123)456-7890 right regex_is_number? got (123)456-7890 right
Benchmark.ips do |x| x.report("rescue") { test_cases.values.flatten.each { |c| rescue_is_number? c } } x.report("regex") { test_cases.values.flatten.each { |c| regex_is_number? c } } x.compare! end
Calculating ------------------------------------- rescue 128.000 i/100ms regex 4.649k i/100ms ------------------------------------------------- rescue 1.348k (±16.8%) i/s - 6.656k regex 52.113k (± 7.8%) i/s - 260.344k Comparison: regex: 52113.3 i/s rescue: 1347.5 i/s - 38.67x slower
object.to_i.to_s == object || object.to_f.to_s == object
class String def numeric? !!(self =~ /^-?\d+(\.\d*)?$/) end end
def is_numeric? val return val.try(:to_f).try(:to_s) == val end
def is_number?(i) begin i+0 == i rescue TypeError false end end
require "pathname" def rec_path(path, file= false) puts path path.children.collect do |child| if file and child.file? child elsif child.directory? rec_path(child, file) + [child] end end.select { |x| x }.flatten(1) end rec_path(Pathname.new(dir), false) rec_path(Pathname.new(dir), true)
Dir.chdir(folder) { Dir.glob("**/*").map {|path| File.expand_path(path) } }
Dir.glob("./logs/**/*").each { |file| File.delete(file) if File.file? file } Dir.glob("./logs/**/*/").each { |directory| Dir.delete(directory) }
describe " it "should call called_bar = false subject.stub(:bar).with("an argument I want") { called_bar = true } subject.foo expect(called_bar).to be_true end end
it "should call expect(subject).to receive(:bar).with("an argument I want") subject.foo end
expect(subject).to receive(:bar).with("an argument I want")
describe " it "should call subject.stub(:bar) subject.foo expect(subject).to have_received(:bar).with("Invalid number of arguments") end end
foo = [1,2,3,4,5,6] bar = [10,20,30,40,50,60] half = len(foo) / 2 foobar = foo[:half] + bar[half:]
--------------------------------------------------------------- Array array[index] -> obj or nil array[start, length] -> an_array or nil array[range] -> an_array or nil array.slice(index) -> obj or nil array.slice(start, length) -> an_array or nil array.slice(range) -> an_array or nil ------------------------------------------------------------------------ Element Reference---Returns the element at index, or returns a subarray starting at start and continuing for length elements, or returns a subarray specified by range. Negative indices count backward from the end of the array (-1 is the last element). Returns nil if the index (or starting index) are out of range. a = [ "a", "b", "c", "d", "e" ] a[2] + a[0] + a[1] a[6] a[1, 2] a[1..3] a[4..7] a[6..10] a[-3, 3] a[5] a[5, 1] a[5..10]
arr = arr.drop(i) > arr = [1,2,3,4,5] => [1, 2, 3, 4, 5] > arr.drop(2) => [3, 4, 5]
>> foo = [1,2,3,4,5,6] => [1, 2, 3, 4, 5, 6] >> bar = [10,20,30,40,50,60] => [10, 20, 30, 40, 50, 60] >> half = foo.length / 2 => 3 >> foobar = foo.slice(0, half) + bar.slice(half, foo.length) => [1, 2, 3, 40, 50, 60]
foo = [1,2,3,4,5,6] bar = [10,20,30,40,50,60] a = foo[0...3] b = bar[3...6] print a + b => [1, 2, 3, 40, 50 , 60]
def first_half(list) list[0...(list.length / 2)] end def last_half(list) list[(list.length / 2)..list.length] end
foo = [1,2,3,4,5,6,7] bar = [10,20,30,40,50,60,70] half = foo.length / 2 foobar = (foo.first half) + (bar.drop half) => [1, 2, 3, 40, 50, 60, 70]
response.body.should =~ /Invalid email or password/
flash[:alert].should == "Invalid email or password"
RSpec.configure do |config| config.render_views end
define_method(:from_s) do | arg | @ordered_parameter_names.each do | param | instance_eval "field_ref = @ field_ref.from_s(param) end end
name = "paramName" instance_variable_get(("@" + name).intern)
Time.now.in_time_zone("Eastern Time (US & Canada)")
> moment = Time.now.utc => 2011-03-14 15:15:58 UTC > moment.localtime => 2011-03-14 08:15:58 -0700
> Time.now.utc.in_time_zone("Eastern Time (US & Canada)") => Mon, 14 Mar 2011 11:21:05 EDT -04:00 > (Time.now.utc + 10.months).in_time_zone("Eastern Time (US & Canada)") => Sat, 14 Jan 2012 10:21:18 EST -05:00
$ r = 10..6 => 10..6 $ (r.first).downto(r.last).each { |i| puts i } 10 9 8 7 6
>> (-2..2).each { |n| puts -n } 2 1 0 -1 -2 => -2..2
class Range def each(&block) direction = (first<=last ? 1 : -1) i = first not_reached_the_end = if first<=last lambda {|i| i<=last} else lambda {|i| i>=last} end while not_reached_the_end.call(i) yield i i += direction end end end
$ irb 2.1.5 :001 > (0..4) => 0..4 2.1.5 :002 > (0..4).each { |i| puts i } 0 1 2 3 4 => 0..4 2.1.5 :003 > (4..0).each { |i| puts i } => 4..0 2.1.5 :007 > (0..4).reverse_each { |i| puts i } 4 3 2 1 0 => 0..4 2.1.5 :009 > 4.downto(0).each { |i| puts i } 4 3 2 1 0 => 4
plus_1 = Proc.new {|n| n + 1} Array.new(3, &plus_1)
2015-02-06T20:30:12.292187+00:00 app[web.1]: (1.9ms) ROLLBACK 2015-02-06T20:30:12.296299+00:00 app[web.1]: NameError (uninitialized constant Paperclip::Storage::S3::AWS): 2015-02-06T20:30:12.296301+00:00 app[web.1]: app/controllers/articles_controller.rb:24:in `create' 2015-02-06T20:45:14.691084+00:00 app[web.1]: [paperclip] saving /articles/images/000/000/013/original/git.jpeg 2015-02-06T20:45:14.698744+00:00 app[web.1]: Completed 500 Internal Server Error in 584ms 2015-02-06T20:45:14.700871+00:00 heroku[router]: at=info method=POST path="/articles" host=preston.herokuapp.com request_id=d9d02257-3616-4686-bce5-3d912cd528c2 fwd="76.22.102.38" dyno=web.1 connect=1ms service=698ms status=500 bytes=1754
class ArticlesController < ApplicationController http_basic_authenticate_with name: "name", password: "password", except: [:index, :show] def index @articles = Article.all.order("created_at DESC") end def show @article = Article.find(params[:id]) end def new @article = Article.new end def edit @article = Article.find(params[:id]) end def create @article = Article.new(article_params) if @article.save redirect_to @article else render end end def update @article = Article.find(params[:id]) if @article.update(article_params) redirect_to @article else render end end def destroy @article = Article.find(params[:id]) @article.destroy redirect_to articles_path end private def article_params params.require(:article).permit(:title, :text, :image) end end
source ruby gem gem gem gem gem gem gem gem gem gem gem group :development, :test do gem gem gem gem end group :production do gem gem end group :doc do gem end
Paperclip is now compatible with aws-sdk >= 2.0.0. If you are using S3 storage, aws-sdk >= 2.0.0 requires you to make a few small changes: * You must set the `s3_region` * If you are explicitly setting permissions anywhere, such as in an initializer, note that the format of the permissions changed from using an underscore to using a hyphen. For example, `:public_read` needs to be changed to `public-read`.
system("VBoxManage createvm --name test1") system("ruby test.rb")
`ruby test.rb` exit_code = `echo $?` if exit_code != 0 raise end
system("unknown command") system("echo foo") system("echo foo | grep bar")
system("VBoxManage createvm --invalid-option") $? $?.exitstatus
$?.exitstatus => return error code $?.success? => return true if error code is 0, otherwise false $?.pid => created process pid
system( "foo" ) or raise "Something went wrong with foo"
system("VBoxManage createvm --name test1") and system("ruby test.rb")
if ( system("VBoxManage createvm --name test1") && system("ruby test.rb") ) else end
require "yaml" require "active_support" file1 = YAML::load(File.open( file2 = YAML::load(File.open( arr = [] file1.select { |k,v| file2.select { |k2, v2| arr << " } } puts arr
hash1 = { hash2 = { hash3 = { hash1 == hash2 hash1 == hash3 hash1.to_a == hash2.to_a hash1.to_a == hash3.to_a
hash3.to_a - hash1.to_a if (hash3.size > hash1.size) difference = hash3.to_a - hash1.to_a else difference = hash1.to_a - hash3.to_a end Hash[*difference.flatten]
difference = (hash3.size > hash1.size) \ ? hash3.to_a - hash1.to_a \ : hash1.to_a - hash3.to_a => [["c", 3]] Hash[*difference.flatten] => {"c"=>3}
Hash[*( (hash3.size > hash1.size) \ ? hash3.to_a - hash1.to_a \ : hash1.to_a - hash3.to_a ).flatten] => {"c"=>3}
a = {a:{x:2, y:3, z:4}, b:{x:3, z:45}} b = {a:{y:3}, b:{y:3, z:30}} diff = HashDiff.diff(a, b) diff.should == [[
h1 = {:a => 20, :b => 10, :c => 44} h2 = {:a => 2, :b => 10, :c => "44"} result = {} h1.each {|k, v| result[k] = h2[k] if h2[k] != v } p result
hash1 = { a: 1 , b: 2 } hash2 = { a: 2 , b: 2 } overlapping_elements = hash1.to_a & hash2.to_a exclusive_elements_from_hash1 = hash1.to_a - overlapping_elements exclusive_elements_from_hash2 = hash2.to_a - overlapping_elements
def diff(one, other) (one.keys + other.keys).uniq.inject({}) do |memo, key| unless one.key?(key) && other.key?(key) && one[key] == other[key] memo[key] = [one.key?(key) ? one[key] : :_no_key, other.key?(key) ? other[key] : :_no_key] end memo end end
require def my_diff(a, b) as = a.ai(plain: true).split("\n").map(&:strip) bs = b.ai(plain: true).split("\n").map(&:strip) ((as - bs) + (bs - as)).join("\n") end puts my_diff({foo: :bar, nested: {val1: 1, val2: 2}, end: :v}, {foo: :bar, n2: {nested: {val1: 1, val2: 3}}, end: :v})
module Diffable def diff( b ) a, b = to_a, b.to_a [a - b, b - a] end def apply_diff( to_drop, to_add ) to_a - to_drop + to_add end end if __FILE__ == $0 Hash.send :include, Diffable rng = Random.new a = (:a..:q).to_a.reduce(Hash[]){|h,k| h.merge! Hash[k, rng.rand(2)] } b = (:i..:z).to_a.reduce(Hash[]){|h,k| h.merge! Hash[k, rng.rand(2)] } raise unless a == Hash[ b.apply_diff(*b.diff(a)) ] raise unless b == Hash[ a.apply_diff(*a.diff(b)) ] raise unless a == Hash[ a.apply_diff(*a.diff(a)) ] raise unless b == Hash[ b.apply_diff(*b.diff(b)) ] end
[22] pry(main)> "\u0221".ord.chr RangeError: 545 out of char range from (pry):2:in [23] pry(main)> x = "\u0221".unpack( => 545 [24] pry(main)> [x].pack( => "ȡ" [25] pry(main)>
def some_method redirect_to :back rescue ActionController::RedirectBackError redirect_to root_path end
def some_method redirect_back fallback_location: root_path end
def redirect_to_back(default = root_url) if request.env["HTTP_REFERER"].present? and request.env["HTTP_REFERER"] != request.env["REQUEST_URI"] redirect_to :back else redirect_to default end end
def store_location session[:return_to] = request.request_uri end def redirect_back_or_default(default) redirect_to(session[:return_to] || default) session[:return_to] = nil end
def redirect_back_or_default(default = root_path, *options) tag_options = {} options.first.each { |k,v| tag_options[k] = v } unless options.empty? redirect_to (request.referer.present? ? :back : default), tag_options end
def redirect_back_or_default(default = root_path, options = {}) redirect_to (request.referer.present? ? :back : default), options end
redirect_back_or_default answer_path(answer), flash: { error: I18n.t(
if request.env["HTTP_REFERER"].present? redirect_to :back else redirect_to end
fib = Fiber.new do x, y = 0, 1 loop do Fiber.yield y x,y = y,x+y end end
def clsr x, y = 0, 1 Proc.new do x, y = y, x + y x end end
irb(main):001:0> [1,2,3].reverse_each => irb(main):002:0> "abc".chars => irb(main):003:0> 1.upto(10) =>
irb(main):001:0> e = "abc".chars => irb(main):002:0> e.next => "a" irb(main):003:0> e.next => "b" irb(main):004:0> e.next => "c"
class SomeClass def an_iterator return enum_for(:an_iterator) if not block_given? yield 1 yield 2 yield 3 end end
irb(main):001:0> "Hello".chars.select { |c| c =~ /[A-Z]/ } => ["H"] irb(main):002:0> "Hello".bytes.sort => [72, 101, 108, 108, 111]
class InfiniteSeries include Enumerable def each i = 0 loop { yield(i += 1) } end end
f = Fiber.new do puts param = Fiber.yield puts "received param: Fiber.yield puts end puts f.resume f.resume f.resume
irb(main):002:0> accepted_formats = [".txt", ".pdf"] => [".txt", ".pdf"] irb(main):003:0> File.extname("example.pdf") => ".pdf" irb(main):004:0> accepted_formats.include? File.extname("example.pdf") => true irb(main):005:0> accepted_formats.include? File.extname("example.txt") => true irb(main):006:0> accepted_formats.include? File.extname("example.png") => false
File.extname(".test").strip.downcase[1..-1] File.extname(".test.").strip.downcase[1..-1] File.extname(".test.pdf").strip.downcase[1..-1] File.extname(".test.pdf ").strip.downcase[1..-1]
backup_file = s3 = AWS::S3.new( access_key_id: AMAZONS3[ secret_access_key: AMAZONS3[ ) s3_bucket = s3.buckets[ s3_name = "database-backups-last20days/ file_obj = s3_bucket.objects[s3_name] file_obj.write(file: backup_file)
var s3 = new AWS.S3( { endpoint: signatureVersion: region: } );
from botocore.client import Config s3 = boto3.resource( aws_access_key_id= aws_secret_access_key= config=Config(signature_version= )
System.setProperty(SDKGlobalConfiguration.ENFORCE_S3_SIGV4_SYSTEM_PROPERTY, "true")
s3Client.setRegion(Region.getRegion(Regions.EU_CENTRAL_1))
[default] aws_access_key_id = (your ID) aws_secret_access_key = (your secret key) s3 = signature_version = s3
CognitoCachingCredentialsProvider credentialsProvider = new CognitoCachingCredentialsProvider( context, "identityPoolId", Regions.US_EAST_1); AmazonS3 s3 = new AmazonS3Client(credentialsProvider); s3.setEndpoint("s3.us-east-2.amazonaws.com");
AWS_S3_REGION_NAME = "ap-south-1" AWS_S3_SIGNATURE_VERSION = "s3v4"
var = "Value|a|test" str = "a test Value" str.gsub( /
var = "*This*" str = "*This* is a string" p str.gsub( /
var = "*This*" str = "*This* is a string" p str.gsub(var,
var = "*This*" str = "*This* is a string" p str.gsub(Regexp.new(Regexp.escape(var)),
var = "Value" str = "a test Value" str.gsub!( / puts str
config.cache_classes = false config.whiny_nils = true config.consider_all_requests_local = true config.action_view.debug_rjs = true config.action_controller.perform_caching = false config.action_mailer.raise_delivery_errors = false config.active_support.deprecation = :log config.action_dispatch.best_standards_support = :builtin config.active_record.timestamped_migrations = false config.time_zone =
config.encoding = "utf-8" config.filter_parameters += [:password] config.active_record.schema_format = :sql
>> a = User.last => >> reload! Reloading... => true
include ActionView::Helpers::SanitizeHelper class Post < ActiveRecord::Base { before_validation :clean_input ... protected def clean_input self.input = sanitize(self.input, :tags => %w(b i u)) end end
class HelperProxy < ActionView::Base include ApplicationController.master_helper_module def current_user nil end def self.instance @instance ||= new end end
class Post < ActiveRecord::Base def clean_input self.input = Helpers.sanitize(self.input, :tags => %w(b i u)) end module Helpers extend ActionView::Helpers::SanitizeHelper end end
class TestClass def method1 end def method2 end def method3 end end
class TestClass def method1 end def method2 end def method3 end end TestClass.methods.grep(/method1/) TestClass.instance_methods.grep(/method1/) TestClass.methods.grep(/new/)
test_object = TestClass.new test_object.methods.grep(/method1/)
$ irb --simple-prompt class TestClass def method1 end def method2 end def method3 end end tc_list = TestClass.instance_methods(false) puts tc_list
module A def method1() puts "method1 say hi" end end class B include A def method2() puts "method2 say hi" end end class C < B def method3() puts "method3 say hi" end end
A.instance_methods(false) => [:method1] A.instance_methods => [:method1] B.instance_methods => [:method2, :method1, :nil?, :===, ... B.instance_methods(false) => [:method2] C.instance_methods => [:method3, :method2, :method1, :nil?, :===, ... C.instance_methods(false) => [:method3]
config.action_controller.include_all_helpers = false
config.action_controller.include_all_helpers = false
def self.inherited(klass) super klass.helper :all if klass.superclass == ActionController::Base end
class ApplicationController < ActionController::Base clear_helpers ... end
class ApplicationController < ActionController::Base helper :all end
require client = SOAP::WSDLDriverFactory.new( result = client.doStuff();
@@wsdl = targetNamespace="http: xmlns:tns="http: xmlns:xsd1="http: xmlns:soap="http: xmlns="http: ....... </wsdl:definitions>'
@@login_failure = "<s:Envelope xmlns:s="http: <s:Body> <LoginResponse xmlns="http: <LoginResult xmlns:a="http: <a:Error>Invalid username and password</a:Error> <a:ObjectInformation i:nil="true"/> <a:Response>false</a:Response> </LoginResult> </LoginResponse> </s:Body> </s:Envelope>"
require require require require_relative require_relative after do headers({ "Access-Control-Allow-Origin" => "*", "Access-Control-Allow-Methods" => "POST", "Access-Control-Allow-Headers" => "content-type", }) content_type :json end get "/HAWebMethods/" do case request.query_string when status 200 body = @@xsd0 when status 200 body = @@wsdl end end post request_payload = request.body.read request_payload = Nokogiri::XML request_payload request_payload.remove_namespaces! if request_payload.css( if request_payload.css( if request_payload.css( status 200 body = @@login_success else status 200 body = @@login_failure end end end end
require class MyHelper def initialize(server, port, username, password) @server = server @port = port @username = username @password = password puts "Initialised My Helper using end def post_job(job_name) puts "Posting job job_xml ="<soapenv:Envelope xmlns:soapenv=\"http: <soapenv:Header/> <soapenv:Body> <ns:CreateTestUpdateOrdersReq> <ContractGroup>ITE2</ContractGroup> <ProductID>topo</ProductID> <PublicationReference> </ns:CreateTestUpdateOrdersReq> </soapenv:Body> </soapenv:Envelope>" @http = Net::HTTP.new(@server, @port) puts "server: " + @server + "port : " + @port request = Net::HTTP::Post.new(( request.basic_auth(@username, @password) request.body = job_xml response = @http.request(request) puts "request was made to server " + @server validate_response(response, "post_job_to_pega_updateorder job", end private def validate_response(response, operation, required_code) if response.code != required_code raise " end end end /* test = MyHelper.new("mysvr.test.test.com","8102","myusername","mypassword") test.post_job("test_201601281419") */
class Foo @@i = 1 def self.i @@i end def self.i=(value) @@i = value end end
class Foo @i = 1 def self.i @i end def self.i=(value) @i = value end end
Hello = Class.new Hello.instance_variable_set(:@var, "good morning!") Hello.instance_variable_get(:@var)
hello = Hello.new hello.instance_variable_set(:@var, :"bad evening!") hello.instance_variable_get(:@var) Hello.instance_variable_get(:@var)
HelloChild = Class.new(Hello) Hello.class_variable_set(:@@class_var, "strange day!") hello = Hello.new hello_child = HelloChild.new Hello.class_variable_get(:@@class_var) HelloChild.class_variable_get(:@@class_var) hello.singleton_class.class_variable_get(:@@class_var) hello_child.singleton_class.class_variable_get(:@@class_Var)
class Foo def set_name @@name = end def get_name @@name end end a = Foo.new a.set_name p a.get_name b = Foo.new p b.get_name
class Foo def set_name @name = end def get_name @name end end a = Foo.new a.set_name p a.get_name b = Foo.new p b.get_name
>> ids = [100, 1, 6] => [100, 1, 6] >> WordDocument.find(ids).collect(&:id) => [1, 6, 100] >> WordDocument.find(ids, :order => "field(id, => [100, 1, 6]
Something.find(array_of_ids).sort_by{|thing| array_of_ids.index thing.id}
Something.find(array_of_ids).index_by(&:id).values_at(*array_of_ids)
class Something < ActiveRecrd::Base scope :for_ids_with_order, ->(ids) { order = sanitize_sql_array( ["position(( ) where(:id => ids).order(order) } end Something.for_ids_with_order([1, 3, 2])
Something.find(array_of_ids).order_as_specified(id: array_of_ids)
sorted = arr.inject([]){|res, val| res << Model.find(val)}
unsorted = Model.find(arr) sorted = arr.inject([]){|res, val| res << unsorted.detect {|u| u.id == val}}
module Enumerable def index_by_with_ordered_hash inject(ActiveSupport::OrderedHash.new) do |accum, elem| accum[yield(elem)] = elem accum end end alias_method_chain :index_by, :ordered_hash end
Something.find(array_of_ids).index_by(&:id).slice(*array_of_ids).values
module ActiveRecord class Base def self.find_with_relevance(array_of_ids) array_of_ids = Array(array_of_ids) unless array_of_ids.is_a?(Array) self.find(array_of_ids).index_by(&:id).slice(*array_of_ids).values end end end
SELECT * FROM colors ORDER BY CASE WHEN code= WHEN code= WHEN code= WHEN code= ELSE 5 END, name;
def self.order_by_ids(ids) if ids.present? order_by = ["CASE"] ids.each_with_index do |id, index| order_by << "WHEN id= end order_by << "END" order(order_by.join(" ")) end else all end
ordered_by_ids = [2,4,1,3] results = Model.where(id: ordered_by_ids).order_by_ids(ordered_by_ids) results.class
RSpec.shared_examples "a collection" do describe " it "returns number of elements" do collection = described_class.new([7, 2, 4]) expect(collection.size).to eq(3) end end end RSpec.describe Array do it_behaves_like "a collection" end RSpec.describe Set do it_behaves_like "a collection" end
class CollectionInterface def add(something) raise end end
module Interface def method(name) define_method(name) { |*args| raise "interface method } end end class Collection extend Interface method :add method :remove end
module Interface def method(name) define_method(name) { |*args| raise "interface method } end end module Collection extend Interface method :add method :remove end col = Collection.new
class MyCollection include Collection def add(thing) puts "Adding end end c1 = MyCollection.new c1.add(1) c1.remove(1)
class Object def interface(method_hash) obj = new method_hash.each do |k,v| if !obj.respond_to?(k) || !((instance_method(k).arity+1)*-1) raise NotImplementedError, " end end end end class Person def work(one,two,three) one + two + three end def sleep end interface({:work => 3, :sleep => 0}) end
class FooInterface class NotDefinedMethod < StandardError; end REQUIRED_METHODS = %i(foo).freeze def initialize(object) @object = object ensure_method_are_defined! end def method_missing(method, *args, &block) ensure_asking_for_defined_method!(method) @object.public_send(method, *args, &block) end private def ensure_method_are_defined! REQUIRED_METHODS.each do |method| if !@object.respond_to?(method) raise NotImplementedError, " end end end def ensure_asking_for_defined_method!(method) unless REQUIRED_METHODS.include?(method) raise NotDefinedMethod, " end end end
class FooImplementation def foo puts( end def bar puts( end end
module Interface def method(name) define_method(name) do raise "Interface method end end def required_variable(name) define_method(name) do sub_class_var = instance_variable_get("@ throw "@ sub_class_var end end def optional_variable(name, default) define_method(name) do instance_variable_get("@ end end end
require class Plugin include Singleton class << self extend Interface required_variable(:name) required_variable(:description) optional_variable(:safe, false) optional_variable(:dependencies, []) method :run end end
class MyPlugin < Plugin @name = @description = @safe = true def self.run puts end end
require class Instrument implements Playable end Instrument.new
name = "sample_string" name.reverse name.reverse! name.is_binary_data?
validates_inclusion_of :age, :in => 21..99 validates_exclusion_of :age, :in => 0...21, :message => "Sorry, you must be over 21"
(1..5).include?(5) (1...5).include?(5) (1..4).include?(4.1) (1...5).include?(4.1) (1..4).to_a == (1...5).to_a (1..4) == (1...5)
1.9.3p0 :005 > (1...10).to_a => [1, 2, 3, 4, 5, 6, 7, 8, 9] 1.9.3p0 :006 > (1..10).to_a => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
2.1.3 :001 > ( => ["a", "b", "c"] 2.1.3 :002 > ( => ["a", "b", "c", "d"]
>> (-1...3).to_a => [-1, 0, 1, 2] >> (-1..2).to_a => [-1, 0, 1, 2] >> (-1..2).to_a == (-1...3).to_a => true
>> (-1..2).step(0.5).to_a => [-1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0] >> (-1...3).step(0.5).to_a => [-1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5]
ruby-1.9.2-p290 :032 > (1...2).each do puts "p" end p => 1...2 ruby-1.9.2-p290 :033 > (1..2).each do puts "p" end p p
class MyCustomError < StandardError attr_reader :object def initialize(message, object) super(message) @object = object end end
rescue MyCustomError => e puts e.message puts e.object
class MyCustomError < StandardError attr_reader :object def initialize(object) @object = object end end begin raise MyCustomError.new("an object"), "a message" rescue MyCustomError => e puts e.message puts e.object end
module ExternalService class FailedCRUDError < ::StandardError def to_s end end class FailedToCreateError < FailedCRUDError; end class FailedToReadError < FailedCRUDError; end class FailedToUpdateError < FailedCRUDError; end class FailedToDeleteError < FailedCRUDError; end end
begin; raise ExternalService::FailedToCreateError; rescue => e; e.message; end begin; raise ExternalService::FailedToCreateError, begin; raise ExternalService::FailedToCreateError.new( raise ExternalService::FailedToCreateError
module ExternalService class FailedCRUDError < ::StandardError def initialize(service_model=nil) super(" end end class FailedToCreateError < FailedCRUDError; end class FailedToReadError < FailedCRUDError; end class FailedToUpdateError < FailedCRUDError; end class FailedToDeleteError < FailedCRUDError; end end
begin; raise ExternalService::FailedToCreateError; rescue => e; e.message; end begin; raise ExternalService::FailedToCreateError, Object.new; rescue => e; e.message; end begin; raise ExternalService::FailedToCreateError.new(Object.new); rescue => e; e.message; end raise ExternalService::FailedCRUDError raise ExternalService::FailedCRUDError.new(Object.new)
require module ExternalService class FailedCRUDError < ::StandardError def initialize(service_model=nil) @service_model = service_model super(" end end class FailedToCreateError < FailedCRUDError; end class FailedToReadError < FailedCRUDError; end class FailedToUpdateError < FailedCRUDError; end class FailedToDeleteError < FailedCRUDError; end end class Cloudinary def initialize(*error_args) @error_args = error_args.flatten end def create_read_update_or_delete begin try_and_fail rescue ExternalService::FailedCRUDError => e e.message end end private def try_and_fail raise *@error_args end end errors_map = [ ExternalService::FailedCRUDError, ExternalService::FailedToCreateError, ExternalService::FailedToReadError, ExternalService::FailedToUpdateError, ExternalService::FailedToDeleteError, ExternalService::FailedCRUDError.new, ExternalService::FailedToCreateError.new, ExternalService::FailedToReadError.new, ExternalService::FailedToUpdateError.new, ExternalService::FailedToDeleteError.new, [ExternalService::FailedCRUDError, Object.new], [ExternalService::FailedToCreateError, Object.new], [ExternalService::FailedToReadError, Object.new], [ExternalService::FailedToUpdateError, Object.new], [ExternalService::FailedToDeleteError, Object.new], ExternalService::FailedCRUDError.new(Object.new), ExternalService::FailedToCreateError.new(Object.new), ExternalService::FailedToReadError.new(Object.new), ExternalService::FailedToUpdateError.new(Object.new), ExternalService::FailedToDeleteError.new(Object.new), ].inject({}) do |errors, args| begin errors.merge!( args => Cloudinary.new(args).create_read_update_or_delete) rescue => e binding.pry end end if defined?(pp) || require( pp errors_map else errors_map.each{ |set| puts set.inspect } end
class FooError < StandardError attr_accessor :message def initialize(stuff) @message = stuff.reverse end end begin raise FooError.new("!dlroW olleH") rescue FooError => e puts e.message end
> CGI::escapeHTML("quote => "quote & > Rack::Utils.escape_html("quote => "quote & > ERB::Util.html_escape("quote => "quote &
def escape_html(str) CGI.escapeHTML(str).gsub("& end
&lt;%= link_to_remote " :action =>:delete_resourced, :id => result[r].id, :th => thread, :html =>{:title=> "<= Remove"}, :confirm => h(" :method => :delete %> &lt;a href="
public def my_method minion_method end private def minion_method end public def next_method end
class Example def xmethod end def ymethod end def zmethod end private :xmethod, :zmethod end
class FooBar def some_public_method end def another_public_method end private def some_private_method end def another_private method end end
class Example def xmethod end private def ymethod end private def zmethod end end
class FooBar def some_public_method end def another_public_method end private def some_private_method end def another_private method end end
class Example def my_private_method end private :my_private_method def my_public_method end end
class Example private def my_private_method end def my_public_method end protected def my_protected_method end private_class_method def self.my_private_class_method end end
class Example private def my_private_method end class << self private def my_private_class_method end end end
class Example def cthulhu end def rlyeh end def foo end private :foo def bar end private :bar def baz end private :baz end
private begin def foo end def bar end end def zip end
ages = { "Bruce" => 32, "Clark" => 28 } mappings = {"Bruce" => "Bruce Wayne", "Clark" => "Clark Kent"} ages.map {|k, v| [mappings[k], v] }.to_h
ages = { "Bruce" => 32, "Clark" => 28 } mappings = {"Bruce" => "Bruce Wayne", "Clark" => "Clark Kent"} ages.keys.each { |k| ages[ mappings[k] ] = ages.delete(k) if mappings[k] } ages
ages = { "Bruce" => 32, "Clark" => 28 } mappings = { "Bruce" => "Bruce Wayne", "Clark" => "Clark Kent" } ages.each_with_object({}) { |(k, v), memo| memo[mappings[k]] = v }
require AGES = { "Bruce" => 32, "Clark" => 28 } MAPPINGS = {"Bruce" => "Bruce Wayne", "Clark" => "Clark Kent"} def jörg_w_mittag_test(ages, mappings) Hash[ages.map {|k, v| [mappings[k], v] }] end require def tyler_rick_test(ages, mappings) ages.rekey(mappings) end def barbolo_test(ages, mappings) ages.keys.each { |k| ages[ mappings[k] ] = ages.delete(k) if mappings[k] } ages end class Hash def tfr_rekey(h) dup.tfr_rekey! h end def tfr_rekey!(h) h.each { |k, newk| store(newk, delete(k)) if has_key? k } self end end def tfr_test(ages, mappings) ages.tfr_rekey mappings end class Hash def rename_keys(mapping) result = {} self.map do |k,v| mapped_key = mapping[k] ? mapping[k] : k result[mapped_key] = v.kind_of?(Hash) ? v.rename_keys(mapping) : v result[mapped_key] = v.collect{ |obj| obj.rename_keys(mapping) if obj.kind_of?(Hash)} if v.kind_of?(Array) end result end end def greg_test(ages, mappings) ages.rename_keys(mappings) end compare do jörg_w_mittag { jörg_w_mittag_test(AGES.dup, MAPPINGS.dup) } tyler_rick { tyler_rick_test(AGES.dup, MAPPINGS.dup) } barbolo { barbolo_test(AGES.dup, MAPPINGS.dup) } greg { greg_test(AGES.dup, MAPPINGS.dup) } end
Running each test 1024 times. Test will take about 1 second. barbolo is faster than jörg_w_mittag by 19.999999999999996% ± 10.0% jörg_w_mittag is faster than greg by 10.000000000000009% ± 10.0% greg is faster than tyler_rick by 30.000000000000004% ± 10.0%
# class Hash def rename_keys(mapping) result = {} self.map do |k,v| mapped_key = mapping[k] ? mapping[k] : k result[mapped_key] = v.kind_of?(Hash) ? v.rename_keys(mapping) : v result[mapped_key] = v.collect{ |obj| obj.rename_keys(mapping) if obj.kind_of?(Hash)} if v.kind_of?(Array) end result end end
class Hash def rekey(h) dup.rekey! h end def rekey!(h) h.each { |k, newk| store(newk, delete(k)) if has_key? k } self end end ages = { "Bruce" => 32, "Clark" => 28, "John" => 36 } mappings = {"Bruce" => "Bruce Wayne", "Clark" => "Clark Kent"} p ages.rekey! mappings
ages = { "Bruce" => 32, "Clark" => 28 } mappings = {"Bruce" => "Bruce Wayne", "Clark" => "Clark Kent"} ages.tap {|h| h.keys.each {|k| (h[mappings[k]] = h.delete(k)) if mappings.key?(k)}}
require ages = { "Bruce" => 32, "Clark" => 28 } mappings = {"Bruce" => "Bruce Wayne", "Clark" => "Clark Kent"} ages.rekey(mappings) => {"Bruce Wayne"=>32, "Clark Kent"=>28}
ages.rekey!(mappings) ages => {"Bruce Wayne"=>32, "Clark Kent"=>28}
ages = { "Bruce" => 32, "Clark" => 28 } mappings = {"Bruce" => "Bruce Wayne", "Clark" => "Clark Kent"} ages = mappings.inject({}) {|memo, mapping| memo[mapping[1]] = ages[mapping[0]]; memo} puts ages.inspect
>> x={ :a => => {:a=>"qwe", :b=>"asd"} >> rename={:a=>:qwe} => {:a=>:qwe} >> rename.each{|old,new| x[new] = x.delete old} => {:a=>:qwe} >> x => {:b=>"asd", :qwe=>"qwe"}
Given(/^an organization exists with the following attributes:$/) do |table| map_to_keys = Hash.new table.transpose.hashes.first.keys.each { |x| map_to_keys[x] = x.downcase.gsub( table.transpose.hashes.each do |obj| obj.keys.each { |k| obj[map_to_keys[k]] = obj.delete(k) if map_to_keys[k] } create(:organization, Rack::Utils.parse_nested_query(obj.to_query)) end end
Background: And an organization exists with the following attributes: | Name | Example Org | | Subdomain | xfdc | | Phone Number | 123-123-1234 | | Address | 123 E Walnut St, Anytown, PA 18999 | | Billing Contact | Alexander Hamilton | | Billing Address | 123 E Walnut St, Anytown, PA 18999 |
{ "Name" => "name", "Subdomain" => "subdomain", "Phone Number" => "phone_number", "Address" => "address", "Billing Contact" => "billing_contact", "Billing Address" => "billing_address" }
ruby -r webrick -e "s = WEBrick::HTTPServer.new(:Port => 9090, :DocumentRoot => Dir.pwd); trap(
function serve { port="${1:-3000}" ruby -run -e httpd . -p $port }
~ $ cd tmp ~/tmp $ serve ~/tmp $ cd ../www ~/www $ serve 5000
require include WEBrick s = HTTPServer.new(:Port => 9090, :DocumentRoot => Dir::pwd) trap("INT"){ s.shutdown } s.start
class String def or(what) self.strip.blank? ? what : self end end @user.address.or("We don
class String def |(what) self.strip.blank? ? what : self end end @user.address | "We don
class User < Sequel::Model def address if (val=self[:address]).empty? "We don else val end end end
@user.address.or User.make_a_long_and_painful_SQL_query_here
class String def or what = "" self.strip.empty? ? block_given? ? yield : what : self end end @user.address.or "We don @user.address.or { User.make_a_long_and_painful_SQL_query_here }
<% form_for(something) do |f| %> .. <%= f.submit <%= f.submit .. <% end %>
<input type="submit" value="A" id=".." name="commit" /> <input type="submit" value="B" id=".." name="commit" />
def <controller action> if params[:commit] == elsif params[:commit] == end end
<% form_for(something) do |f| %> ... <%= f.submit "Create" %> <%= f.submit "Special Action", formaction: special_action_path %> <% end %>
<% form_for(something) do |f| %> .. <%= f.submit <%= f.submit .. <% end %>
resources :plan do post :save, constraints: lambda {|req| req.params.key?(:propose)}, action: :propose post :save, constraints: lambda {|req| req.params.key?(:finalize)}, action: :finalize end
resources :plan do post :save, constraints: CommitParamRouting.new("Propose"), action: :propose post :save, constraints: CommitParamRouting.new("Finalize"), action: :finalize end
class SearchController < ApplicationController SEARCH_TYPES = { :searchABC => "Search ABCs", :search123 => "Search 123s" } def search [...] if params[:commit] == SEARCH_TYPES[:searchABC] [...] elsif params[:commit] == SEARCH_TYPES[:search123] [...] else flash[:error] = "Search type not found!"] [...] end end [...] end
<% form_for(something) do |f| %> [...] <%= f.submit SearchController::SEARCH_TYPES[:searchABC] %> <%= f.submit SearchController::SEARCH_TYPES[:search123] %> [...] <% end %>
FileUtils.cd(" YoutubeDlhelperLibs::Downloader.get($url) if File.exists?( puts Dir[ File.delete(waste) end else puts end Dir[ rip.to_s rip.split puts puts rip end end
path = "/path/to/xyz.mp4" File.basename(path) File.extname(path) File.basename(path, ".mp4") File.basename(path, ".*") File.dirname(path)
RubyVM::InstructionSequence.compile_option = { :tailcall_optimization => true, :trace_instruction => false }
def fact(n, r) if n < 2 r else fact(n-1, n*r) end end
source = <<-SOURCE def fact n, acc = 1 if n.zero? acc else fact n - 1, acc * n end end fact 10000 SOURCE i_seq = RubyVM::InstructionSequence.new source, nil, nil, nil, tailcall_optimization: true, trace_instruction: false begin value = i_seq.eval p value rescue SystemStackError => e p e end
<a href="/berlin" >Berlin</a> <a href="/berlin" >Berlin Germany </a>
class Thing attr_reader :stuff def initialize(initial_stuff) @stuff = initial_stuff @state_lock = Mutex.new end def add(item) @state_lock.synchronize do @stuff << item end end end
STANDARD_OPTIONS = {:color => def find_stuff @some_service.load_things( end
config.action_controller.consider_all_requests_local = true
<%= f.select :month, (1..12).to_a, selected: @user.created_at.month %> <%= f.select :day, (1..31).to_a, selected: @user.created_at.day %> <%= f.select :year, ((Time.now.year - 20)..Time.now.year).to_a, selected: @user.created_at.year %>
attr_accessor :month, :day, :year validate :validate_created_at private def convert_created_at begin self.created_at = Date.civil(self.year.to_i, self.month.to_i, self.day.to_i) rescue ArgumentError false end end def validate_created_at errors.add("Created at date", "is invalid.") unless convert_created_at end
class Person < ActiveRecord::Base validates_date :date_of_birth, on_or_before: lambda { Date.current } validates :date_of_birth, timeliness: { on_or_before: lambda { Date.current }, type: :date } end
validates_date - validate value as date validates_time - validate value as time only i.e. validates_datetime - validate value as a full date and time validates - use the :timeliness key and set the type in the hash.
class MyModel < ActiveRecord::Base validate :valid_date? def valid_date? unless Chronic.parse(from_date) errors.add(:from_date, "is missing or invalid") end end end
def published_date=(value) self.write_attribute(:published_date, value) end
class Pimping < ActiveRecord::Base validate :valid_date? def valid_date? if scheduled_on.present? unless scheduled_on.is_a?(Time) errors.add(:scheduled_on, "Is an invalid date.") end end end
validate :date_field_must_be_a_date_or_blank def date_field_must_be_a_date_or_blank date_field_before_type_cast.to_date rescue ArgumentError errors.add(:birthday, :invalid) end
year = params[:date][:year].to_i month = params[:date][:month].to_i mday = params[:date][:mday].to_i hour = params[:date][:hour].to_i minute = params[:date][:minute].to_i valid_date = Date.valid_date? year, month, mday valid_hour = (0..23).to_a.include? hour valid_minute = (0..59).to_a.include? minute valid_time = valid_hour && valid_minute if valid_date && valid_time second = 0 offset = DateTime.civil(year, month, mday, hour, minute, second, offset) else DateTime.current.utc end
t = foo.start_time => 2000-01-01 14:20:00 UTC t.zone => "UTC" t.in_time_zone("America/New_York") => Sat, 01 Jan 2000 09:20:00 EST -05:00
t => 2000-01-01 14:20:00 UTC t.zone = "America/New_York" => "America/New_York" t => 2000-01-01 14:20:00 EST
def set_in_timezone(time, zone) Time.use_zone(zone) { time.to_datetime.change(offset: Time.zone.now.strftime("%z")) } end
t = Foo.start_time.in_time_zone("America/New_York") t -= t.utc_offset
1.9.3p194 :042 > utc_time = Time.now.utc => 2013-05-29 16:37:36 UTC 1.9.3p194 :043 > local_time = utc_time.in_time_zone( => Wed, 29 May 2013 12:37:36 EDT -04:00 1.9.3p194 :044 > desired_time = local_time-local_time.utc_offset => Wed, 29 May 2013 16:37:36 EDT -04:00
class Task include DateTimeAttribute date_time_attribute :due_at end task = Task.new task.due_at_time_zone = task.due_at task.due_at_time_zone = task.due_at
my_date_time = DateTimeAttribute::Container.new(Time.zone.now) my_date_time.date_time my_date_time.time_zone = my_date_time.date_time
def relative_time_in_time_zone(time, zone) DateTime.parse(time.strftime("%d %b %Y %H:%M:%S end
my_time = Time.now west_coast_time = my_time.in_time_zone(-8) east_coast_time = my_time.in_time_zone(-5)
def utc_offset_of_given_time(time, ignore_dst: false) utc_offset = time.utc_offset if !!ignore_dst && time.dst? utc_offset_ignoring_dst = utc_offset - 3600 utc_offset = utc_offset_ignoring_dst end utc_offset end def utc_offset_of_given_time_ignoring_dst(time) utc_offset_of_given_time(time, ignore_dst: true) end def change_offset_in_given_time_to_given_utc_offset(time, utc_offset) formatted_utc_offset = ActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset, false) datetime_with_changed_offset = time.to_datetime.change(offset: formatted_utc_offset) Time.parse(datetime_with_changed_offset.to_s) end def ignore_dst_in_given_time(time) return time unless time.dst? utc_offset = time.utc_offset if utc_offset < 0 dst_ignored_time = time - 1.hour elsif utc_offset > 0 dst_ignored_time = time + 1.hour end utc_offset_ignoring_dst = utc_offset_of_given_time_ignoring_dst(time) dst_ignored_time_with_corrected_offset = change_offset_in_given_time_to_given_utc_offset(dst_ignored_time, utc_offset_ignoring_dst) if utc_offset > 0 dst_ignored_time_with_corrected_offset -= 1.hour end dst_ignored_time_with_corrected_offset end
dd1 = dd2 = utc_zone = ActiveSupport::TimeZone[ est_zone = ActiveSupport::TimeZone[ tehran_zone = ActiveSupport::TimeZone[ utc_dd1 = utc_zone.parse(dd1) est_dd1 = est_zone.parse(dd1) tehran_dd1 = tehran_zone.parse(dd1) utc_dd1.dst? est_dd1.dst? tehran_dd1.dst? ignore_dst = true utc_to_est_time = utc_dd1.in_time_zone(est_zone.name) if utc_to_est_time.dst? && !!ignore_dst utc_to_est_time = ignore_dst_in_given_time(utc_to_est_time) end puts utc_to_est_time
system "rails new my_app" system "cd my_app" system "rails server &"
system "rails new my_app" Dir.chdir("my_app") do system "rails server &" end
puts Dir.chdir("/tmp") { IO.popen("ls -la") { |io| io.read } } puts IO.popen(["ls", "-la", "/tmp"]).read puts IO.popen("ls -la /tmp").read
git clone https: cd libv8 bundle install bundle exec rake clean build binary gem install pkg/libv8-3.16.14.3-x86_64-darwin-12.gem
gem uninstall libv8 brew install v8 gem install therubyracer gem install libv8 -v
brew tap homebrew/versions brew install v8-315 gem install libv8 -v gem install therubyracer -- --with-v8-dir=/usr/local/opt/v8-315 bundle install
$ gem uninstall libv8 $ gem install therubyracer -v Fetching: libv8-3.16.14.7-x86_64-darwin-14.gem ( 57%) Fetching: libv8-3.16.14.7-x86_64-darwin-14.gem (100%) Successfully installed libv8-3.16.14.7-x86_64-darwin-14 Building native extensions. This could take a while... Successfully installed therubyracer-0.12.0 2 gems installed
gem install libv8 -v brew link --overwrite v8-315 --force gem install therubyracer -v
brew install v8-315 gem install libv8 -v gem install therubyracer -- --with-v8-dir=/usr/local/opt/v8@3.15/
rvm list rvm uninstall ruby-x.x.x rvm install ruby-x.x.x
gem uninstall libv8 gem install therubyracer -v Fetching: libv8-3.16.14.19-x86_64-darwin-18.gem (100%) Successfully installed libv8-3.16.14.19-x86_64-darwin-18 Building native extensions. This could take a while... Successfully installed therubyracer-0.12.1 Parsing documentation for libv8-3.16.14.19-x86_64-darwin-18 Installing ri documentation for libv8-3.16.14.19-x86_64-darwin-18 Parsing documentation for therubyracer-0.12.1 Installing ri documentation for therubyracer-0.12.1 Done installing documentation for libv8, therubyracer after 0 seconds 2 gems installed gem install libv8 -v bundle install
irb(main):003:0> names = "erik kalle johan anders erik kalle johan anders" => "erik kalle johan anders erik kalle johan anders" irb(main):004:0> names[/kalle/] => "kalle"
"foo+account2@gmail.com"[/\+([^@]+)/, 1] "foo+account2@gmail.com"[/\+([^@]+)/, 0]
matchData = "string string".match(/string/) matchData[0] matchData[1]
/\$(?<dollars>\d+)\.(?<cents>\d+)/ =~ "$3.67" dollars
>> a=[:a, => [:a, "a", 1, 1.0] >> a.map(&:class) => [Symbol, String, Fixnum, Float]
class Symbol def with(*args, &block) ->(caller, *rest) { caller.send(self, *rest, *args, &block) } end end
arr = ["abc", "babc", "great", "fruit"] arr.map(&:center.with(20, arr.map(&:[].with(1, 3)) arr.map(&:[].with(/a(.*)/)) arr.map(&:[].with(/a(.*)/, 1))
[[ [%w(a b), %w(c d)].map(&:inject.with(&:+)) [(1..5), (6..10)].map(&:map.with(&:*.with(2)))
class Symbol def call(*args, &block) ->(caller, *rest) { caller.send(self, *rest, *args, &block) } end end a = [1,3,5,7,9] a.map(&:+.(2)) [(1..5), (6..10)].map(&:map.(&:*.(2)))
Arup-iMac:$ pry [1] pry(main)> a = [1,3,5,7,9] => [1, 3, 5, 7, 9] [2] pry(main)> a.map(&2.method(:+)) => [3, 5, 7, 9, 11] [3] pry(main)>
[3] pry(main)> 2.method(:+) => [4] pry(main)> 2.method(:+).to_proc => [5] pry(main)> 2.method(:+).to_proc.call(1) => 3
symbols_count = Symbol.all_symbols.count a = :one puts a.object_id a = :two puts a.object_id a = :one puts a.object_id puts Symbol.all_symbols.count - symbols_count
require require str = Benchmark.measure do 10_000.times do Haml::Engine.new( end end.total sym = Benchmark.measure do 10_000.times do Haml::Engine.new( end end.total puts "String: " + str.to_s puts "Symbol: " + sym.to_s
String: 5.14 Symbol: 5.07 String: 5.29 Symbol: 5.050000000000001 String: 4.7700000000000005 Symbol: 4.68
def string_comp str1, str2 return false if str1.length != str2.length for i in 0...str1.length return false if str1[i] != str2[i] end return true end string_comp "foo", "foo"
def symbol_comp sym1, sym2 sym1.object_id == sym2.object_id end symbol_comp :foo, :foo
enum BugStatus { OPEN, CLOSED }; BugStatus original_status = OPEN; BugStatus current_status = CLOSED;
options = {} options[:auto_save] = true options[:show_comments] = false
require string_AZ = Hash[("a".."z").to_a.zip((1..26).to_a)] symbol_AZ = Hash[(:a..:z).to_a.zip((1..26).to_a)] string_time = Benchmark.realtime do 1000_000.times { string_AZ["r"] } end symbol_time = Benchmark.realtime do 1000_000.times { symbol_AZ[:r] } end puts "String time: puts "Symbol time:
String time: 0.21983 seconds. Symbol time: 0.087873 seconds.
class Example def initialize( hash ) ... magic happens here... end end
hash.each { |name, value| instance_variable_set(name, value) }
h = { :foo => o = Struct.new(*h.keys).new(*h.values) o.baz => "qux" o.foo => "bar"
def initialize(hash) hash.each { |key, value| send(" end
class Example attr_accessor :foo, :baz def initialize(hash) hash.each { |key, value| send(" end end
rvm 1.9.2 irb -f irb(main):001:0> require => true irb(main):002:0> 1.week.ago => 2010-11-14 17:56:16 -0700 irb(main):003:0>
rvm 1.8.7 irb -f irb(main):001:0> require => true irb(main):002:0> require => true irb(main):003:0> 1.week.ago => Sun Nov 14 17:54:19 -0700 2010 irb(main):004:0>
$ sw_vers ProductName: Mac OS X ProductVersion: 10.6.5 BuildVersion: 10H574 $ rails c Loading development environment (Rails 3.0.3) >> 1.week.ago => Sun, 14 Nov 2010 16:57:18 UTC +00:00
a = ["a", "b", "c", "d"] a.map {|item|"a" == item} a.select {|item|"a" == item}
irb(main):105:0> details[1] => {:sku=>"507772-B21", :desc=>"HP 1TB 3G SATA 7.2K RPM LFF (3 .", :qty=>"", :qty2=>"1", :price=>"5,204.34 P"}
irb(main):001:0> h = {:sku=>"507772-B21", :desc=>"HP 1TB 3G SATA 7.2K RPM LFF (3 .", :qty=>"", :qty2=>"1", :price=>"5,204.34 P"} irb(main):002:0> h.select { |key, value| !value.empty? } => {:sku=>"507772-B21", :desc=>"HP 1TB 3G SATA 7.2K RPM LFF (3 .", :qty2=>"1", :price=>"5,204.34 P"}
details.map {|key,item|"" == item} =>[false, false, true, false, false]
fmt = res = fmt % [animal, action, other_animal] res = sprintf(fmt, animal, action, other_animal)
2.0.0p247 :001 > first_name = => "jim" 2.0.0p247 :002 > second_name = => "bob" 2.0.0p247 :003 > full_name = => "\ 2.0.0p247 :004 > full_name = " => "jim bob"
["The", animal, action, "the", second_animal].join(" ")
def merge_into_string(animal, second_animal, action) template = ERB.new(template).result(binding) end merge_into_string( => "The tiger eats the deer" merge_into_string( => "The bird finds the worm"
require Sidekiq::RetrySet.new.clear Sidekiq::ScheduledSet.new.clear Sidekiq::DeadSet.new.clear Sidekiq::Stats.new.reset stats = Sidekiq::Stats.new stats.queues queue = Sidekiq::Queue.new( queue.count queue.clear
$bundle exec rspec spec F Failures: 1) security signs users in Failure/Error: visit "/sessions/new" NoMethodError: undefined method `visit Finished in 0.006 seconds 1 example, 1 failure Failed examples: rspec ./spec/features/security_spec.rb:3
$ rake routes logout_sessions GET /sessions/logout(.:format) sessions sessions POST /sessions(.:format) sessions new_sessions GET /sessions/new(.:format) sessions contracts POST /contracts(.:format) contracts new_contracts GET /contracts/new(.:format) contracts edit_contracts GET /contracts/edit(.:format) contracts GET /contracts(.:format) contracts PUT /contracts(.:format) contracts DELETE /contracts(.:format) contracts root / contracts
source gem gem group :assets do gem gem gem end gem gem gem gem gem gem group :development do gem end group :test do gem gem gem end
ENV["RAILS_ENV"] ||= require File.expand_path("../../config/environment", __FILE__) require require require require Dir[Rails.root.join("spec/support/**/*.rb")].each {|f| require f} RSpec.configure do |config| config.use_transactional_fixtures = true config.infer_base_class_for_anonymous_controllers = false config.order = "random" config.include Rails.application.routes.url_helpers end
describe "security", :type => :feature do it "signs users in" do visit "/sessions/new" fill_in "username", :with => "user" fill_in "password", :with => "pass" click_button "Sign In" page.should have_content( end end
ENV["RAILS_ENV"] ||= require File.expand_path("../../config/environment", __FILE__) require require Dir[Rails.root.join("spec/support/**/*.rb")].each {|f| require f} RSpec.configure do |config| config.use_transactional_fixtures = true config.infer_base_class_for_anonymous_controllers = false config.order = "random" config.include Rails.application.routes.url_helpers config.include Capybara::DSL end
require describe "security", :type => :feature do it "signs users in" do visit new_sessions_path fill_in "username", :with => "user" fill_in "password", :with => "pass" click_button "Sign In" page.should have_content( end end
describe "security" do before do visit "/sessions/new" fill_in "username", :with => "user" fill_in "password", :with => "pass" click_button "Sign In" end it "signs users in" do page.should have_content( end end
require RSpec.describe "Products", type: :request do describe "GET /products" do it "display tasks" do Product.create!(:name => "samsung") visit products_path page.should have_content("samsung") end end end
RSpec.configure do |config| config.fixture_path = " config.use_transactional_fixtures = true config.infer_spec_type_from_file_location! config.include Capybara::DSL end
> zsh > rvm 1.9.2 > ruby -v ruby 1.8.7 (2009-06-12 patchlevel 174) [universal-darwin10.0] > which ruby /usr/bin/ruby
rvm rubies ruby-1.8.7-p302 [ x86_64 ] => ruby-1.9.2-p0 [ x86_64 ]
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"
[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm"
export PATH="$PATH:$HOME/.rvm/bin" export PATH=$PATH:"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/git/bin:/usr/local/mysql/bin:/opt/local/bin"
DateTime.strptime( => Sun, 09 Dec 2012 00:01:36 +0000
require s = "30/Nov/2009 16:29:30 +0100" p Time.mktime(*ParseDate.parsedate(s))
TCPServer Error: Address already in use - bind(2) INFO WEBrick::HTTPServer % lsof -i :4000 <fetches nothing>
% jekyll --version Jekyll 0.11.2 % where jekyll /home/bhaarat/.rvm/gems/ruby-1.9.2-p290/bin/jekyll /usr/bin/jekyll % ruby --version ruby 1.9.2p290 (2011-07-09 revision 32553) [i686-linux] % rvm --version rvm 1.10.0
% jekyll --server Configuration from /home/bhaarat/blog/omnipresent.github.com/_config.yml Auto-regenerating enabled: /home/bhaarat/blog/omnipresent.github.com -> /home/bhaarat/blog/omnipresent.github.com/_site [2012-04-21 13:46:40] regeneration: 38 files changed [2012-04-21 13:46:40] INFO WEBrick 1.3.1 [2012-04-21 13:46:40] INFO ruby 1.9.2 (2011-07-09) [i686-linux] [2012-04-21 13:46:40] WARN TCPServer Error: Address already in use - bind(2) [2012-04-21 13:46:40] INFO WEBrick::HTTPServer
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME nxd 449 nx 3u IPv4 0x8d22************ 0t0 TCP *:terabase (LISTEN) nxd 449 nx 4u IPv6 0x8d22************ 0t0 TCP *:terabase (LISTEN)
1003 4953 2614 0 08:51 pts/0 00:00:00 -bash 1003 5634 1 0 08:56 pts/0 00:00:00 spring server | moviestore | started 2 hours ago 1003 5637 5634 0 08:56 ? 00:00:01 spring app | moviestore | started 2 hours ago | development mode 1003 6078 4953 0 09:03 pts/0 00:00:03 puma 3.6.0 (tcp: 1003 6117 2614 0 09:03 pts/1 00:00:00 -bash root 6520 2 0 09:57 ? 00:00:00 [kworker/u8:2] root 6936 1225 0 11:09 ? 00:00:00 [lightdm] <defunct> 1003 7084 1 0 11:09 ? 00:00:00 /usr/bin/python /usr/share/apport/apport-gtk 1003 7475 1 0 11:10 ? 00:00:00 /usr/bin/python /usr/share/apport/apport-gtk root 8739 1225 1 11:29 tty8 00:00:11 /usr/bin/X :1 -auth /var/run/lightdm/root/:1 -nolisten tcp vt8 -novtswitch root 8853 1225 0 11:29 ? 00:00:00 lightdm --session-child 13 22 1002 8943 1 0 11:30 ? 00:00:00 /usr/bin/gnome-keyring-daemon --daemonize --login 1002 8954 8853 0 11:30 ? 00:00:00 gnome-session --session=ubuntu 1002 8992 8954 0 11:30 ? 00:00:00 /usr/bin/ssh-agent /usr/bin/dbus-launch --exit-with-session gnome-session --session=ubuntu 1002 8995 1 0 11:30 ? 00:00:00 /usr/bin/dbus-launch --exit-with-session gnome-session --session=ubuntu 1002 8996 1 0 11:30 ? 00:00:00 1002 9007 8954 0 11:30 ? 00:00:00 /usr/lib/gnome-settings-daemon/gnome-settings-daemon 1002 9015 1 0 11:30 ? 00:00:00 /usr/lib/gvfs/gvfsd 1002 9018 8954 1 11:30 ? 00:00:07 compiz 1002 9021 1 0 11:30 ? 00:00:00 /usr/lib/x86_64-linux-gnu/gconf/gconfd-2 1002 9028 8954 0 11:30 ? 00:00:00 /usr/lib/policykit-1-gnome/polkit-gnome-authentication-agent-1 1002 9029 8954 0 11:30 ? 00:00:01 nautilus -n 1002 9030 8954 0 11:30 ? 00:00:00 /usr/lib/gnome-settings-daemon/gnome-fallback-mount-helper 1002 9031 8954 0 11:30 ? 00:00:00 nm-applet 1002 9032 8954 0 11:30 ? 00:00:02 /opt/mTrac/mTrac 1002 9033 8954 0 11:30 ? 00:00:00 bluetooth-applet 1002 9045 9032 0 11:30 ? 00:00:00 /opt/mTrac/mTrac --type=zygote --no-sandbox 1002 9050 1 0 11:30 ? 00:00:00 /usr/lib/gvfs/gvfs-gdu-volume-monitor 1002 9054 1 0 11:30 ? 00:00:00 /usr/bin/pulseaudio --start --log-target=syslog 1002 9057 1 0 11:30 ? 00:00:00 /usr/lib/gvfs/gvfs-gphoto2-volume-monitor 1002 9062 1 0 11:30 ? 00:00:00 /usr/lib/gvfs/gvfs-afc-volume-monitor
1003 6078 4953 0 09:03 pts/0 00:00:03 puma 3.6.0 (tcp:
def time_diff_milli(start, finish) (finish - start) * 1000.0 end t1 = Time.now t2 = Time.now msecs = time_diff_milli t1, t2
class Time def to_ms (self.to_f * 1000.0).to_i end end start_time = Time.now sleep(3) end_time = Time.now elapsed_time = end_time.to_ms - start_time.to_ms
irb(main):038:0> t8 = Time.now => Sun Nov 01 15:18:04 +0100 2009 irb(main):039:0> t9 = Time.now => Sun Nov 01 15:18:18 +0100 2009 irb(main):040:0> dif = t9 - t8 => 13.940166 irb(main):041:0> (1000 * dif).to_i => 13940
puts Time.now.to_f (Time.now.to_f.round(3)*1000).to_i
require puts Time.now.strftime("%Y-%m-%dT%H:%M:%S.%L")
>> DateTime.now.strftime("%Q") => "1541433332357" >> DateTime.now.strftime("%Q").to_i => 1541433332357
t_start = Time.now t_end = Time.now milliseconds = (t_start - t_end) * 1000.0
def measure_time start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC) yield end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC) elapsed_time = end_time - start_time elapsed_time.round(3) end
elapsed = measure_time do sleep 2.2321 end => 2.232
@posts = Post.joins("LEFT OUTER JOIN users ON users.id = posts.user_id"). joins(:blog).select
Post.includes(:comments).where(comments: {visible: true})
@posts = Post.left_outer_joins(:user).joins(:blog).select
class User < ActiveRecord::Base has_many :friends, :foreign_key=>"u_from",:class_name=>"Friend" end class Friend < ActiveRecord::Base belongs_to :user end friends = user.friends.where(:u_req_status=>2).joins("LEFT OUTER JOIN users ON users.u_id = friends.u_to").select("friend_id,u_from,u_to,u_first_name,u_last_name,u_email,u_fbid,u_twtid,u_picture_url,u_quote")
def foo(first_name, last_name, age, sex, is_plumber) logger.error "Method has failed, here are all method arguments end
Method has failed, here are all method arguments {"Mario", "Super", 40, true, true}
args = method(__method__).parameters.map { |arg| arg[1].to_s }
logger.error "Method failed with " + args.map { |arg| "
def foo(x, y) method(__method__).parameters.map do |_, name| binding.local_variable_get(name) end end foo(1, 2)
def foo(*args) first_name, last_name, age, sex, is_plumber = *args logger.error "Method has failed, here are all method arguments end
class Test def method(first, last) local_variables.each do |var| puts eval var.to_s end end end Test.new().method("aaa", 1)
ARGS_TO_HASH = "method(__method__).parameters.map { |arg| arg[1].to_s }.map { |arg| { arg.to_sym => eval(arg) } }.reduce Hash.new, :merge"
args = eval(ARGS_TO_HASH) another_method_that_takes_the_same_arguments(**args)
def foo(x, y) args(binding) end def args(callers_binding) callers_name = caller[0][/`.* parameters = method(callers_name).parameters parameters.map { |_, arg_name| callers_binding.local_variable_get(arg_name) } end
def foo(*bar) ... log.error "Error with arguments end
def foo(*args) logger.error "Method has failed, here are all method arguments end
def foo(opts={}) logger.error "Method has failed, here are all method arguments end
def mymethod(firstarg, kw_arg1:, kw_arg2: :default) args = MethodArguments.(binding) ... end
class MethodArguments def self.call(ext_binding) raise ArgumentError, "Binding expected, method_name = ext_binding.eval("__method__") ext_binding.receiver.method(method_name).parameters.map do |_, name| [name, ext_binding.local_variable_get(name)] end.to_h end end
begin a = rand if a > 0.5 raise FooException else raise BarException end rescue FooException, BarException puts "rescued!" end
EXCEPTIONS = [FooException, BarException] begin a = rand if a > 0.5 raise FooException else raise BarException end rescue *EXCEPTIONS puts "rescued!" end
[BazException, FooException, BarException, BangExcepion]
method(BazException, FooException, BarException, BangExcepion)
class FileLoadError < StandardError end class FileNamesMissingError < FileLoadError end class InputFileMissingError < FileLoadError end class OutputDirectoryError < FileLoadError end [FileNamesMissingError, InputFileMissingError, OutputDirectoryError].each do |error| begin raise error rescue FileLoadError => e puts "Rescuing end end
DateTime.now.midnight DateTime.now.beginning_of_day
DateTime.now.change({ hour: 0, min: 0, sec: 0 }) DateTime.now.change({ hour: 0 })
now = DateTime.now DateTime.new(now.year, now.month, now.day, 0, 0, 0, now.zone)
now = DateTime.now DateTime.parse(now.strftime("%Y-%m-%dT00:00:00%z"))
DateTime.new(now.year, now.month, now.day, 0, 0, 0, 0)
$LOAD_PATH.unshift(File.expand_path(File.dirname(__FILE__))) unless $LOAD_PATH.include?(File.expand_path(File.dirname(__FILE__)))
libdir = File.dirname(__FILE__) $LOAD_PATH.unshift(libdir) unless $LOAD_PATH.include?(libdir)
libdir = File.expand_path(File.dirname(__FILE__)) $LOAD_PATH.unshift(libdir) unless $LOAD_PATH.include?(libdir)
$:.unshift(File.expand_path(File.dirname(__FILE__))) unless $:.include?(File.dirname(__FILE__)) || $:.include?(File.expand_path(File.dirname(__FILE__)))
%w{ models controllers models }.each do |dir| path = File.expand_path(File.join(File.dirname(__FILE__), $LOAD_PATH << path ActiveSupport::Dependencies.load_paths << path ActiveSupport::Dependencies.load_once_paths.delete(path) end
$LOAD_PATH.unshift(File.join(File.dirname(__FILE__),
Rails::Initializer.run do |config| * * * * * path = [] path.concat($LOAD_PATH) $LOAD_PATH.clear $LOAD_PATH << $LOAD_PATH << $LOAD_PATH.concat(path) * * * * * end
def name_with_override name_trans || name_without_override end alias_method_chain :name, :override
def name self[:name] = name_trans || self[:name] end
hash = {"apple" => "fruit", "carrot" => "vegetable"} array = hash.keys
hash = {"apple" => "fruit", "carrot" => "vegetable"} array = hash.collect {|key,value| key }
distance_of_time_in_words(from_time, to_time) time_ago_in_words(from_time)
Time.current 2.minutes.ago 2.minutes.since 1.month.ago 1.year.since
from_time = Time.now distance_of_time_in_words(from_time, from_time + 50.minutes) distance_of_time_in_words(from_time, 50.minutes.from_now) distance_of_time_in_words(from_time, from_time + 15.seconds) distance_of_time_in_words(from_time, from_time + 15.seconds, include_seconds: true)
time_ago_in_words(3.minutes.from_now) time_ago_in_words(3.minutes.ago) time_ago_in_words(Time.now - 15.hours)
{:foo => "hello", :bar => "world", :baz => 1, :bof => 2}
class MultiIO def initialize(*targets) @targets = targets end def write(*args) @targets.each {|t| t.write(*args)} end def close @targets.each(&:close) end end
log_file = File.open("log/debug.log", "a") Logger.new MultiIO.new(STDOUT, log_file)
require class MultiDelegator def initialize(*targets) @targets = targets end def self.delegate(*methods) methods.each do |m| define_method(m) do |*args| @targets.map { |t| t.send(m, *args) } end end self end class <<self alias to new end end log_file = File.open("debug.log", "a") log = Logger.new MultiDelegator.delegate(:write, :close).to(STDOUT, log_file)
file_logger = Logger.new(Rails.root.join("log/alternative-output.log")) config.logger.extend(ActiveSupport::Logger.broadcast(file_logger))
module ActiveSupport class Logger < ::Logger def self.broadcast(logger) Module.new do define_method(:add) do |*args, &block| logger.add(*args, &block) super(*args, &block) end define_method(:<<) do |x| logger << x super(x) end define_method(:close) do logger.close super() end define_method(:progname=) do |name| logger.progname = name super(name) end define_method(:formatter=) do |formatter| logger.formatter = formatter super(formatter) end define_method(:level=) do |level| logger.level = level super(level) end end end end end file_logger = Logger.new(Rails.root.join("log/alternative-output.log")) Rails.logger.extend(ActiveSupport::Logger.broadcast(file_logger))
require class Logger def attach(name) @logdev.attach(name) end def detach(name) @logdev.detach(name) end class LogDevice attr_reader :devs def attach(log) @devs ||= {} @devs[log] = open_logfile(log) end def detach(log) @devs ||= {} @devs[log].close @devs.delete(log) end alias_method :old_write, :write def write(message) old_write(message) @devs ||= {} @devs.each do |log, dev| dev.write(message) end end end end
logger = Logger.new(STDOUT) logger.warn( logger.attach( logger.warn( logger.detach( logger.warn(
class MultiLogger def initialize(*targets) @targets = targets end %w(log debug info warn error fatal unknown).each do |m| define_method(m) do |*args| @targets.map { |t| t.send(m, *args) } end end end $stderr_log = Logger.new(STDERR) $file_log = Logger.new(File.open( $stderr_log.level = Logger::INFO $file_log.level = Logger::DEBUG $log = MultiLogger.new( $stderr_log, $file_log )
class Tee < DelegateToAllClass(IO) end $stdout = Tee.new(STDOUT, File.open("
log = Logger.new("test.log") log.formatter = proc do |severity, datetime, progname, msg| puts msg msg end log.info "hi"
class BetterMultiDelegator def self.delegate(*methods) Class.new do def initialize(*targets) @targets = targets end methods.each do |m| define_method(m) do |*args| @targets.map { |t| t.send(m, *args) } end end class <<self alias to new end end end end
tee = MultiDelegator.delegate(:write).to(STDOUT) tee.respond_to? :write tee.respond_to? :size
tee2 = MultiDelegator.delegate(:size).to("bar") tee2.respond_to? :size tee2.respond_to? :write tee.respond_to? :size
see = BetterMultiDelegator.delegate(:write).to(STDOUT) see.respond_to? :write see.respond_to? :size see2 = BetterMultiDelegator.delegate(:size).to("bar") see2.respond_to? :size see2.respond_to? :write see.respond_to? :size
require LOGGER = Log4r::Logger.new( LOGGER.outputters << Log4r::StdoutOutputter.new( LOGGER.outputters << Log4r::FileOutputter.new( LOGGER.info(
class MultiIO def self.delegate_all IO.methods.each do |m| define_method(m) do |*args| ret = nil @targets.each { |t| ret = t.send(m, *args) } ret end end end def initialize(*targets) @targets = targets MultiIO.delegate_all end end
logger = Logger.new MultiIO.new(File.open("log/test.log", logger.error "Roses are red" logger.unknown "Violets are blue"
require log_file = File.open("debug.log", "a") logger = Logger.new(TeeRb::IODelegate.new(log_file, STDOUT)) logger.warn "warn" $stderr.puts "stderr hello" puts "stdout hello"
module ActiveSupport class Logger < ::Logger def self.broadcast(logger) Module.new do define_method(:add) do |*args, &block| logger.add(*args, &block) super(*args, &block) end define_method(:<<) do |x| logger << x super(x) end define_method(:close) do logger.close super() end define_method(:progname=) do |name| logger.progname = name super(name) end define_method(:formatter=) do |formatter| logger.formatter = formatter super(formatter) end define_method(:level=) do |level| logger.level = level super(level) end end end def initialize(*args) super @formatter = SimpleFormatter.new end class SimpleFormatter < ::Logger::Formatter def call(severity, time, progname, msg) element = caller[4] ? caller[4].split("/").last : "UNDEFINED" " end end end end custom_logger = ActiveSupport::Logger.new(Rails.root.join("log/alternative_ Rails.logger.extend(ActiveSupport::Logger.broadcast(custom_logger))
["fbfea87d1d8cc101a4ff9d12461ae810"] 2015-03-12 16:54:04 INFO logger.rb:28:in `call_app ["fbfea87d1d8cc101a4ff9d12461ae810"] 2015-03-12 16:54:04 INFO logger.rb:31:in `call_app
require class MultiDelegator def initialize(*targets) @targets = targets end def method_missing(method_sym, *arguments, &block) @targets.each do |target| target.send(method_sym, *arguments, &block) if target.respond_to?(method_sym) end end end log = MultiDelegator.new(Logger.new(STDOUT), Logger.new(File.open("debug.log", "a"))) log.info(
def watch(cmd) output = StringIO.new IO.popen(cmd) do |fd| until fd.eof? bit = fd.getc output << bit $stdout.putc bit end end output.rewind [output.read, $?.success?] ensure output.close end result, success = watch(
def delegator(*methods) Class.new do def initialize(*targets) @targets = targets end methods.each do |m| define_method(m) do |*args| @targets.map { |t| t.send(m, *args) } end end class << self alias for new end end end
IO_delegator_instance = delegator(:write, :read).for(STDOUT, STDERR) IO_delegator_instance.write("blah")
logger_delegator_class = delegator(:log, :warn, :error) secret_delegator = logger_delegator_class(main_logger, secret_logger) secret_delegator.warn("secret") general_delegator = logger_delegator_class(main_logger, debug_logger, other_logger) general_delegator.log("message")
hash = { "d" => [11, 22], "f" => [33, 44, 55] } hash.map {|k,vs| vs.map {|v| " => "d:11,d:22,f:33,f:44,f:55" hash.map {|k,vs| vs.each {|v| " => "11,22,33,44,55"
2.2.3 :001 > [:how, :now, :brown, :cow].map &:to_s => ["how", "now", "brown", "cow"]
a = ["a", "b", "c"]; p a.map {|item| "map_" + item} p a.each {|item| "map_" + item}
a = [1,2,3,4,5] a.object_id b = a.each {|n| n + 2} p b b.object_id
c = [1,2,3,4,5] c.object_id d = c.map {|n| n + 2} p d d.object_id
def to_indicators Indicator.where id: self.pluck(:id) end
all.to_indicators.applicable_for_bank(id).each do |indicator| total += indicator.residual_risk_for(id) indicator_count += 1 if indicator.completed_by?(id) end
SELECT .... WHERE `my_models`.id IN (2, 3, 4, 6, ....
SELECT ... FROM ... WHERE (id in (11,5,6,7,8,9,10)) ORDER BY field(id,11,5,6,7,8,9,10)
rvm remove ree export CC=/usr/bin/gcc-4.2 rvm install ree
brew update brew tap homebrew/dupes brew install apple-gcc42
CC=/usr/local/bin/gcc-4.2 rvm --verify-downloads 1 reinstall 1.8.7-p357 --without-tcl --without-tk
rvm --verify-downloads 1 reinstall 1.8.7-p357 --without-tcl --without-tk
test: on CREATE to :user with completely invalid email should respond with redirect (UsersControllerTest):ActionController::RedirectBackError: No HTTP_REFERER was set in the request to this action, so redirect_to :back could not be called successfully. If this is a test, make sure to specify request.env["HTTP_REFERER"].
setup do @request.env[ post :create, { :user => { :email => end
setup do @request.env[ post :create, { :user => { :email => end
test "blah" do get root_path, params: { id: 12 }, headers: { "HTTP_REFERER" => "http: ... end
def get(action, parameters = nil, session = nil, flash = nil)
setup do @request.env[ post :create, { :user => { :email => end
def to_boolean(str) return true if str=="true" return false if str=="false" return nil end
def is_true?(string) ActiveRecord::ConnectionAdapters::Column::TRUE_VALUES.include?(string) end
y|Y|yes|Yes|YES|n|N|no|No|NO |true|True|TRUE|false|False|FALSE |on|On|ON|off|Off|OFF
def to_boolean(s) s and !!s.match(/^(true|t|yes|y|1)$/i) end def to_boolean(s) !!(s =~ /^(true|t|yes|y|1)$/i) end
[3] pry(main)> ActiveRecord::Type::Boolean.new.type_cast_from_user("true") => true [4] pry(main)> ActiveRecord::Type::Boolean.new.type_cast_from_user("false") => false [5] pry(main)> ActiveRecord::Type::Boolean.new.type_cast_from_user("T") => true [6] pry(main)> ActiveRecord::Type::Boolean.new.type_cast_from_user("F") => false [7] pry(main)> ActiveRecord::Type::Boolean.new.type_cast_from_user("yes") DEPRECATION WARNING: You attempted to assign a value which is not explicitly `true` or `false` ("yes") to a boolean column. Currently this value casts to `false`. This will change to match Ruby => false [8] pry(main)> ActiveRecord::Type::Boolean.new.type_cast_from_user("no") DEPRECATION WARNING: You attempted to assign a value which is not explicitly `true` or `false` ("no") to a boolean column. Currently this value casts to `false`. This will change to match Ruby => false
class String def to_b ActiveRecord::Type::Boolean.new.type_cast_from_user(self) end end
class String def to_bool return true if self=="true" return false if self=="false" return nil end end
def to_boolean(s) map = Hash[%w[true yes 1].product([true]) + %w[false no 0].product([false])] map[s.to_s.downcase] end
%x(echo hi) %x(echo hi >&2) `echo hi` `echo hi >&2`
io = IO.popen $stdout = io puts $stdout = IO.new 0 p io.read(1) io.close
require stdout,stderr,status = Open3.capture3(some_command) STDERR.puts stderr if status.successful? puts stdout else STDERR.puts "OH NO!" end
irb(main):003:0> `date /t` => "Thu 07/01/2010 \n" irb(main):004:0> system("date /t") Thu 07/01/2010 => true irb(main):005:0> %x{date /t} => "Thu 07/01/2010 \n"
folder = "/" list_all_files = "ls -al output = ` puts output
require puts"Enter the command for execution" some_command=gets stdout,stderr,status = Open3.capture3(some_command) STDERR.puts stderr if status.success? puts stdout else STDERR.puts "ERRRR" end
class String def underscore word = self.dup word.gsub!(/::/, word.gsub!(/([A-Z]+)([A-Z][a-z])/, word.gsub!(/([a-z\d])([A-Z])/, word.tr!("-", "_") word.downcase! word end end
FooBar.model_name.param_key FooBar.model_name.route_key FooBar.model_name.human
module MyModule module ClassMethods def class_to_sym name_without_namespace = name.split("::").last name_without_namespace.gsub(/([^\^])([A-Z])/, end end def self.included(base) base.extend(ClassMethods) end end class ThisIsMyClass include MyModule end ThisIsMyClass.class_to_sym
class User attr_accessor :name, :age end user = User.new user.name = "John Smith" user.age = 30 puts user.inspect puts user.to_yaml
class Person < ActiveRecord::Base def to_s "Name: end end
def index @posts = Post.all end <%= debug(@posts) %> rails -s
- !ruby/object:Post raw_attributes: id: 2 title: My Second Post body: Welcome! This is another example post published_at: created_at: updated_at: attributes: !ruby/object:ActiveRecord::AttributeSet attributes: !ruby/object:ActiveRecord::LazyAttributeHash types: &5 id: &2 !ruby/object:ActiveRecord::Type::Integer precision: scale: limit: range: !ruby/range begin: -2147483648 end: 2147483648 excl: true title: &3 !ruby/object:ActiveRecord::Type::String precision: scale: limit: body: &4 !ruby/object:ActiveRecord::Type::Text precision: scale: limit: published_at: !ruby/object:ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter subtype: &1 !ruby/object:ActiveRecord::Type::DateTime precision: scale: limit: created_at: !ruby/object:ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter subtype: *1 updated_at: !ruby/object:ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter subtype: *1
user = User.new user.name = "will" user.email = "will@example.com" user.inspect
class Something < ApplicationRecord def to_s attributes.map{ |k, v| { k => v.to_s } }.inject(:merge) end end
def to_s attributes.merge({ my_attribute: my_attribute.to_s }) end
@a = Accrual.first ; pp @a id: 4, year: 2018, Jan: Feb: Mar: Apr: May: June: July: Aug: Sep: Oct: Nov: Dec:
<div class="field"> <%= f.label :name %><br /> <%= f.text_field :name %> </div>
Usage: runner [options] ( -e, --environment=name Specifies the environment for the runner to operate under (test/development/production). Default: development -h, --help Show this help message.
------------------------------------------------------------- Product.all.each { |p| p.price *= 2 ; p.save! } -------------------------------------------------------------
namespace :example do desc "Sample description you task create_user: :environment do User.create! first_name: "Foo", last_name: "Bar" end
user = FactoryGirl.build(:user) user = FactoryGirl.create(:user)
class Integer def factorial_recursive self <= 1 ? 1 : self * (self - 1).factorial end def factorial_iterative f = 1; for i in 1..self; f *= i; end; f end alias :factorial :factorial_iterative end
class Integer def fact (1..self).reduce(:*) || 1 end end >> 400.fact => 64034522846623895262347970319503005850702583026002959458684445942802397169186831436278478647463264676294350575035856810848298162883517435228961988646802997937341654150838162426461942352307046244325015114448670890662773914918117331955996440709549671345290477020322434911210797593280795101545372667251627877890009349763765710326350331533965349868386831339352024373788157786791506311858702618270169819740062983025308591298346162272304558339520759611505302236086810433297255194852674432232438669948422404232599805551610635942376961399231917134063858996537970147827206606320217379472010321356624613809077942304597360699567595836096158715129913822286578579549361617654480453222007825818400848436415591229454275384803558374518022675900061399560145595206127211192918105032491008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
class Integer def fact (2..self).reduce(1,:*) end end
def fact(n) if n<= 1 1 else n * fact( n - 1 ) end end
def fall_fact(n,k) if k <= 0 1 else n*fall_fact(n - 1, k - 1) end end
class Factorial attr_reader :num def initialize(num) @num = num end def find_factorial (1..num).inject(:*) || 1 end end number = Factorial.new(8).find_factorial puts number
class Integer def factorial return self < 0 ? false : self==0 ? 1 : self.downto(1).inject(:*) end end
def factorial(number) number = number.to_i number_range = (number).downto(1).to_a factorial = number_range.inject(:*) puts "The factorial of end factorial(
def factorial(num) step = 0 (num - 1).times do (step += 1 ;num *= step) end return num end
num = 8;step = 0;(num - 1).times do (step += 1 ;num *= step; puts num) end;num
def fact(n) (1..n).inject(1) {|r,i| r*i }end fact(6) => 720
$ nokogiri -v --- warnings: [] nokogiri: 1.5.0 ruby: version: 1.9.2 platform: x86_64-darwin11.0.0 description: ruby 1.9.2p290 (2011-07-09 revision 32553) [x86_64-darwin11.0.0] engine: ruby libxml: binding: extension compiled: 2.7.8 loaded: 2.7.8
bundle config build.nokogiri --with-xml2-include=/opt/local/include/libxml2 --with-xml2-lib=/opt/local/lib --with-xslt-dir=/opt/local
WARNING: Nokogiri was built against LibXML version 2.7.3, but has dynamically loaded 2.7.8
gem uninstall nokogiri libxml-ruby brew update brew uninstall libxml2 brew install libxml2 --with-xml2-config brew install libxslt bundle config build.nokogiri --with-xml2-include=/usr/local/Cellar/libxml2/2.9.1/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.9.1/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26/ bundle install
gem uninstall nokogiri libxml-ruby brew update brew uninstall libxml2 brew install libxml2 --with-xml2-config brew install libxslt gem install nokogiri -- --with-xml2-include=/usr/local/Cellar/libxml2/2.9.1/include/libxml2 --with-xml2-lib=/usr/local/Cellar/libxml2/2.9.1/lib --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26/
$ bundle config build.nokogiri --with-xml2-include=/opt/local/include/libxml2 --with-xml2-lib=/opt/local/lib --with-xslt-dir=/opt/local
$ ll /usr/bin/gcc* lrwxr-xr-x 1 root wheel 12 Jan 15 00:16 /usr/bin/gcc -> llvm-gcc-4.2
$ ll /usr/bin/gcc* lrwxr-xr-x 1 root wheel 12 Jan 15 00:16 /usr/bin/gcc -> llvm-gcc-4.2 lrwxr-xr-x 1 root wheel 12 Jan 15 21:07 /usr/bin/gcc-4.2 -> /usr/bin/gcc
brew update brew install libxml2 libxslt brew link libxml2 libxslt bundle config build.nokogiri --with-xml2-include=/usr/local/Cellar/libxml2/2.8.0/include/libxml2/ --with-xml2-lib=/usr/local/Cellar/libxml2/2.8.0/lib/ --with-xslt-dir=/usr/local/Cellar/libxslt/1.1.26/ bundle
gem install nokogiri -- --with-xml2-dir=/usr --with-xslt-dir=/opt/local --with-iconv-dir=/opt/local
gem uninstall nokogiri brew update cd /usr/local brew versions libxml2 git checkout 5dd45d7 /usr/local/Library/Formula/libxml2.rb brew install libxml2 bundle install or gem install nokogiri -v "1.5.11"
my_string = "Hello, my\n name is Michael." my_string = my_string.gsub( /\s+/, " " )
s = "Hello, my\n name is Michael." s.gsub(/\s+/, " ")
s = "Hello, my\n name is Michael." s.gsub(/\n\s+/, " ")
Use squish currency = " XCD" str = currency.squish str = "XCD"
(date2.year * 12 + date2.month) - (date1.year * 12 + date1.month)
(date2.year - date1.year) * 12 + date2.month - date1.month - (date2.day >= date1.day ? 0 : 1)
((date2.to_time - date1.to_time)/1.month.second).to_i
(date1.beginning_of_month...date2.beginning_of_month).select { |date| date.day == 1 }.size
((date2.to_time - date1.to_time)/1.month.second).round(1) ((date2.to_time - date1.to_time)/1.month.second).round(2) etc...
start_date = Date.today end_date = Date.today+90 months = (end_date.month+end_date.year*12) - (start_date.month+start_date.year*12)
def difference_in_months(date1, date2) month_count = (date2.year == date1.year) ? (date2.month - date1.month) : (12 - date1.month + date2.month) month_count = (date2.year == date1.year) ? (month_count + 1) : (((date2.year - date1.year - 1 ) * 12) + (month_count + 1)) month_count end
date1 = date2 = months = 0 months += 1 while (date2 << (count+1)) >= date1 puts months
def months_difference(period_start, period_end) period_end = period_end + 1.day months = (period_end.year - period_start.year) * 12 + period_end.month - period_start.month - (period_end.day >= period_start.day ? 0 : 1) remains = period_end - (period_start + months.month) (months + remains/period_end.end_of_month.day).to_f.round(2) end
expect(months_difference(Date.new(2017, 8, 1), Date.new(2017, 8, 31))).to eq 1.0 expect(months_difference(Date.new(2017, 8, 1), Date.new(2017, 8, 30))).to eq 0.97 expect(months_difference(Date.new(2017, 8, 1), Date.new(2017, 10, 31))).to eq 3.0 expect(months_difference(Date.new(2017, 1, 1), Date.new(2017, 3, 31))).to eq 3.0 expect(months_difference(Date.new(2017, 2, 10), Date.new(2017, 3, 9))).to eq 1.0 expect(months_difference(Date.new(2016, 2, 1), Date.new(2016, 2, 29))).to eq 1.0
def months_difference(date_time_start, date_time_end) curr_months = 0 while (date_time_start + curr_months.months) < date_time_end curr_months += 1 end curr_months -= 1 if (date_time_start + curr_months.months) > date_time_end curr_months.negative? ? 0 : curr_months end
some_array.select{|x| x % 2 == 0 }.collect{|x| x * 3}
class Array def comprehend(&block) return self if block.nil? self.collect(&block).compact end end some_array = [1, 2, 3, 4, 5, 6] new_array = some_array.comprehend {|x| x * 3 if x % 2 == 0} puts new_array
some_array.map {|x| x % 2 == 0 ? x * 3 : nil}.compact
require require class ListComprehensionTest < ActionController::PerformanceTest TEST_ARRAY = (1..100).to_a def test_map_compact 1000.times do TEST_ARRAY.map{|x| x % 2 == 0 ? x * 3 : nil}.compact end end def test_select_map 1000.times do TEST_ARRAY.select{|x| x % 2 == 0 }.map{|x| x * 3} end end def test_inject 1000.times do TEST_ARRAY.inject([]) {|all, x| all << x*3 if x % 2 == 0; all } end end end
/usr/bin/ruby1.8 -I"lib:test" "/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rake/rake_test_loader.rb" "test/performance/list_comprehension_test.rb" -- --benchmark Loaded suite /usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rake/rake_test_loader Started ListComprehensionTest wall_time: 1221 ms memory: 0.00 KB objects: 0 gc_runs: 0 gc_time: 0 ms .ListComprehensionTest wall_time: 855 ms memory: 0.00 KB objects: 0 gc_runs: 0 gc_time: 0 ms .ListComprehensionTest wall_time: 955 ms memory: 0.00 KB objects: 0 gc_runs: 0 gc_time: 0 ms . Finished in 66.683039 seconds. 15 tests, 0 assertions, 0 failures, 0 errors
some_array.inject([]){|res,x| x % 2 == 0 ? res << 3*x : res}
require some_array.comprehend{ |x| x * 3 if x % 2 == 0 }
[1, 2, 3, 4, 5, 6].collect{|x| x * 3 if x % 2 == 0}.compact => [6, 12, 18]
def lazy(collection, &blk) collection.map{|x| blk.call(x)}.compact end
some_array.flat_map {|x| x % 2 == 0 ? [x * 3] : [] }
some_array.each_with_object([]) {|x, list| x % 2 == 0 ? list.push(x * 3) : nil }
<%- unless @page.new_record? || !@page.image? -%> <%= f.check_box :image_delete, :label => <%- end -%>
def check_box(method, options = {}, checked_value = "1", unchecked_value = "0")
class Page < ActiveRecord::Base has_attached_file :image before_save :destroy_image? def image_delete @image_delete ||= "0" end def image_delete=(value) @image_delete = value end private def destroy_image? self.image.clear if @image_delete == "1" end end
attr_accessor :delete_asset before_validation { asset.clear if delete_asset ==
module DeletableAttachment extend ActiveSupport::Concern included do attachment_definitions.keys.each do |name| attr_accessor :"delete_ before_validation { send(name).clear if send("delete_ define_method :"delete_ instance_variable_set :"@delete_ send(" end end end end
module Mixins module PaperclipRemover extend ActiveSupport::Concern included do attachment_definitions.keys.each do |name| attribute :"remove_ before_validation do self.send(" end end end end end
unless user = Challenge.find(10) puts "some error msg" end
begin user = User.find(10) rescue ActiveRecord::RecordNotFound puts "some error msg" end
def example matchingLines = @lines.select{ |line| ... } results = matchingLines.map{ |line| ... } return results.uniq.sort end
jruby-1.5.0 > [1,1,1,2,3,4].map{|n| n*3 if n==1} => [3, 3, 3, nil, nil, nil] jruby-1.5.0 > [1,1,1,2,3,4].map{|n| n*3 if n==1}.compact => [3, 3, 3]
[1,1,1,2,3,4].reduce([]) { |a, n| a.push(n*3) if n==1; a } => [3, 3, 3]
def example results = @lines.reduce([]) do |lines, line| lines.push( ...(line) ) if ... lines end return results.uniq.sort end
def example @lines.lazy .select { |line| line.property == requirement } .map { |line| transforming_method(line) } .uniq .sort end
transformed_list = lines.select{|line| ...}.map{|line| ... }
my_favourite_numbers = [1,4,6] is_a_favourite_number = -> x { my_favourite_numbers.include? x } make_awesome = -> x { "*** my_data = [1,2,3,4] p my_data.grep(is_a_favourite_number, &make_awesome)
lines.map { |line| do_some_action if check_some_property }.reject(&:nil?)
lines.inject([]) { |all, line| all << line if check_some_property; all }
results = @lines.select { |line| line.should_include? }.map do |line| line.value_to_map end
def example @lines.select { |line| line.should_include? }.map { |line| line.value_to_map }.uniq.sort end
def example @lines.select {|line| ... }.map {|line| ... }.uniq.sort end
%w[a b 1 2 c d].map.select {|e| if /[0-9]/ =~ e then false else e.upcase end } %w[a b 1 2 c d].select.map {|e| if /[0-9]/ =~ e then false else e.upcase end }
records.map { |record| record.attribute if condition }.compact
items = [{version: "1.1"}, {version: nil}, {version: false}] items.select_map{|x| x[:version]} Rearmed.select_map(items){|x| x[:version]}
array = [1,1,1,2,3,4] new_array = map{|n| n*3 if n==1} new_array.compact!
array = [1,1,1,2,3,4] new_array = map{|n| n*3 if n==1}.tap { |array| array.compact! }
def example matchingLines = @lines.select{ |line| ... } results = matchingLines.map{ |line| ... } return results.uniq.sort end
def example results = {} @lines.each{ |line| results[line] = true if ... } return results.keys.sort end
def example lines.each do |x| new_value = do_transform(x) if new_value == some_thing return new_value else next end end end
class Test1 def meth1 def meth2 puts "Yay" end meth2 end end Test1.new.meth1
def test(value) inner = ->() { value * value } inner.call() end
def outer_method(arg) outer_variable = "y" inner_method = lambda { puts arg puts outer_variable } inner_method[] end outer_method "x"
module Methods define_method :outer do outer_var = 1 define_method :inner do puts "defining inner" inner_var = outer_var +1 end outer_var end extend self end Methods.outer Methods.inner
def mlet(name,func) my_class = (Class.new do def initialize(name,func) @name=name @func=func end def method_missing(methname, *args) puts "method_missing called on if methname == @name puts "Calling function @func.call(*args) else raise NoMethodError.new "Undefined method ` end end end) yield my_class.new(name,func) end
def outer mlet :inner, ->(x) { x*2 } do |c| c.inner 12 end end
1.9.3p484 :001 > def kme; => nil 1.9.3p484 :003 > self.methods.include? :kme => true 1.9.3p484 :004 > self.methods.include? :foo => false 1.9.3p484 :005 > kme => nil 1.9.3p484 :006 > self.methods.include? :foo => true 1.9.3p484 :007 > foo => "foo"
namespace :my_tasks do task :foo do do_something end task :bar do do_something_else end task :all => [:foo, :bar] end
namespace :my_tasks do task :foo do do_something end task :bar do do_something_else end end task :all => ["my_tasks:foo", "my_tasks:bar"]
namespace :my_tasks do task :foo, :arg1, :arg2 do |t, args| do_something end task :bar, :arg1, :arg2 do |t, args| do_something_else end end task :my_tasks, :arg1, :arg2 do |t, args| Rake::Task["my_tasks:foo"].invoke( args.arg1, args.arg2 ) Rake::Task["my_tasks:bar"].invoke( args.arg1, args.arg2 ) end
task :my_tasks do Rake.application.in_namespace(:my_tasks){|x| x.tasks.each{|t| t.invoke}} end
require require namespace :features do Cucumber::Rake::Task.new(:fast) do |t| t.profile = end Cucumber::Rake::Task.new(:slow) do |t| t.profile = end task :ci => [:fast, :slow] end task :default => "features:ci"
module Rake::DSL def group(name, &block) ns = namespace name, &block default = ns[:default] task name => " ns end end group :foo do task :foo1 do |t| puts t.name end task :foo2 do |t| puts t.name end task :default => [:foo1, :foo2] end task :default => :foo
desc "Run all my tasks" task :my_tasks => ["my_tasks:all"]
namespace :job1 do task :do_something1 do puts "job1:do_something1" end task :do_something2 do puts "job1:do_something2" end task :all => [:do_something1, :do_something2] end desc "Job 1" task :job1 => ["job1:all"] namespace :job2 do task :do_something1 do puts "job2:do_something1" end task :do_something2 do puts "job2:do_something2" end end desc "Job 2" task :job2 => ["job2:do_something1", "job2:do_something2"] namespace :superjob do namespace :job1 do task :do_something1 do puts "superjob:job1:do_something1" end task :do_something2 do puts "superjob:job1:do_something2" end end desc "Job 1 in Superjob" task :job1 => ["job1:do_something1", "job1:do_something2"] namespace :job2 do task :do_something1 do puts "superjob:job2:do_something1" end task :do_something2 do puts "superjob:job2:do_something2" end end desc "Job 2 in Superjob" task :job2 => ["job2:do_something1", "job2:do_something2"] end desc "My Super Job" task :superjob => ["superjob:job1", "superjob:job2"] task :default => [:job1, :job2, :superjob]
namespace :root do namespace :foo do end namespace :target do task :all do |task_all| Rake.application.in_namespace(task_all.scope.path) do |ns| ns.tasks.each { |task| task.invoke unless task.name == task_all.name } end end task :one do end task :another do end end end
localhost:TwitterForZombies wiz$ rails c /Users/wiz/.rbenv/versions/1.9.3-p194/lib/ruby/1.9.1/irb/completion.rb:9:in `require Referenced from: /Users/wiz/.rbenv/versions/1.9.3-p194/lib/ruby/1.9.1/x86_64-darwin12.2.1/readline.bundle Reason: image not found - /Users/wiz/.rbenv/versions/1.9.3-p194/lib/ruby/1.9.1/x86_64-darwin12.2.1/readline.bundle from /Users/wiz/.rbenv/versions/1.9.3-p194/lib/ruby/1.9.1/irb/completion.rb:9:in `<top (required)>' from /Users/wiz/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/railties-3.2.9/lib/rails/commands/console.rb:3:in `require' from /Users/wiz/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/railties-3.2.9/lib/rails/commands/console.rb:3:in `<top (required)>' from /Users/wiz/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/railties-3.2.9/lib/rails/commands.rb:38:in `require' from /Users/wiz/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/railties-3.2.9/lib/rails/commands.rb:38:in `<top (required)>' from script/rails:6:in `require' from script/rails:6:in `<main>'
ln -s /usr/local/opt/readline/lib/libreadline.7.0.dylib /usr/local/opt/readline/lib/libreadline.6.dylib
$ rbenv uninstall 2.3.1 $ rbenv install 2.3.1 $ cd /path/to/my/app $ bundle
rvm cleanup all rvm autolibs enable rvm install 2.1.0
brew update brew uninstall readline brew install readline
brew install readline ruby-build env CONFIGURE_OPTS=--with-readline-dir=`brew --prefix readline` rbenv install 1.9.3-p286
irb(main):016:0> Time.now => Thu Apr 16 12:40:44 +0100 2009
class DateTime def localtime new_offset(DateTime.now.offset) end def utc new_offset(Rational(0, 24)) end end
d = DateTime.now.new_offset(Rational(-4, 24)) => 1.8.7 :185 > d.to_s => "2012-08-03T15:42:48-04:00" 1.8.7 :186 > d.localtime.to_s => "2012-08-03T12:42:48-07:00" 1.8.7 :187 > d.utc.to_s => "2012-08-03T19:42:48+00:00"
require Time.now DateTime.now.to_s ENV[ Time.now DateTime.now.to_s
> Time.parse(DateTime.now.to_s).utc => 2015-10-06 14:53:51 UTC
class User def before_save puts end def after_save puts end def around_save puts yield puts end end User.save before save in around save out around save after_save => true
2.0.0-p643 :006 > b = "-300".gsub("-", "") => "300" 2.0.0-p643 :005 > b = "--300".gsub("-", "") => "300"
my_app$ gem install capybara-webkit Building native extensions. This could take a while... ERROR: Error installing capybara-webkit: ERROR: Failed to build gem native extension. /Users/joe/.rvm/rubies/ruby-1.9.2-p290/bin/ruby extconf.rb Gem files will remain installed in /Users/joe/.rvm/gems/ruby-1.9.2-p290/gems/capybara-webkit-0.7.2 for inspection. Results logged to /Users/joe/.rvm/gems/ruby-1.9.2-p290/gems/capybara-webkit-0.7.2/./gem_make.out
/Users/joe/.rvm/rubies/ruby-1.9.2-p290/bin/ruby extconf.rb
QMAKE=/opt/local/libexec/qt5/bin/qmake gem install capybara-webkit
brew update brew install qt gem install capybara-webkit
ln -s /Path/to/where/you/installed/Qt5.2/5.2.0-beta1/clang_64/bin/qmake /usr/local/bin/qmake
brew install qt brew linkapps qt gem install capybara-webkit
yum install qt-webkit-devel export QMAKE=/usr/bin/qmake-qt4 gem install capybara-webkit
brew install qt5 brew link --force qt5 gem install capybara-webkit
absolute_path(file_name [, dir_string] ) → abs_file_name
conf.return_format = "=> limited output\n %.512s\n"
require require module IRB class Irb ctx :ap do def output_value() ap(@context.last_value) end end ctx :puts do def output_value() puts(@context.last_value) end end ctx :p do def output_value() p(@context.last_value) end end ctx :quiet do def output_value() end end end end def irb_mode(mode) ctx(mode) { irb } end
irb(main):001:0> { this: => {:this=>"is a complex object", :that=>[{:will=>"probably"}, {:be=>"good to read"}], :in=>{:some=>{:formatted=>"way"}}}
irb(main):002:0> irb_mode(:ap) irb => { :this => "is a complex object", :that => [ [0] { :will => "probably" }, [1] { :be => "good to read" } ], :in => { :some => { :formatted => "way" } } }
→ brew info memcached memcached 1.4.7 http: Depends on: libevent /usr/local/Cellar/memcached/1.4.6 (8 files, 156K) You can enable memcached to automatically load on login with: mkdir -p ~/Library/LaunchAgents cp /usr/local/Cellar/memcached/1.4.7/com.danga.memcached.plist ~/Library/LaunchAgents/ launchctl load -w ~/Library/LaunchAgents/com.danga.memcached.plist Or start it manually: /usr/local/bin/memcached Add "-d" to start it as a daemon. http:
ps ux | grep memcached pkill -f memcached ps ux | grep memcached
launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist
launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist
alias memcached-start="launchctl load ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist" alias memcached-stop="launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist" alias memcached-restart="launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist;launchctl load ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist"
$ gem install lunchy $ mkdir ~/Library/LaunchAgents $ cp /usr/local/Cellar/memcached/$version/homebrew.mxcl.memcached.plist ~/Library/LaunchAgents/
ln -sfv /usr/local/Cellar/memcached/1.4.17/homebrew.mxcl.memcached.plist ~/Library/LaunchAgents/
launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist
def File.open(*args, &block) return open_with_block(*args, &block) if block_given? open_without_block(*args) end def File.open_without_block(*args) end def File.open_with_block(*args) yield f = open_without_block(*args) ensure f.close end
some_array.each_with_index{|item, index = 1| some_func(item, index) }
[:foo, :bar, :baz].to_enum.with_index(1).each do |elem, i| puts " end
[:foo, :bar, :baz].each.with_index(1) do |elem, i| puts " end
some_array.each_with_index{|item, index| some_func(item, index+1)}
some_array.each_with_index{|item, i| j = i + 1; some_func(item, j)}
module Enumerable def each_with_index_from_one *args, &pr each_with_index(*args){|obj, i| pr.call(obj, i+1)} end end %w(one two three).each_with_index_from_one{|w, i| puts " 1. one 2. two 3. three
some_array[offset..-1].each_with_index{|item, index| some_func(item, index) } some_array[offset..-1].each_with_index{|item, index| some_func(item, index+offset) } some_array[offset..-1].each_with_index{|item, index| index+=offset; some_func(item, index) }
some_array[1000,-1] => nil nil.each_with_index => Error
(some_array[offset..-1]||[]).each_with_index{|item, index| some_func(item, index) }
offset = 1000 some_array[offset..-1].each_with_index{|item, index| some_func(item, index) } if offset <= some_array.size
some_array = [:foo, :bar, :baz] some_array_plus_offset_index = some_array.each_with_index.map {|item, i| [item, i + 1]} some_array_plus_offset_index.each{|item, offset_index| some_func(item, offset_index) }
%W(one two three).zip(1..3).each do |value, index| puts value, index end
a.zip(1..a.length.each do |value, index| puts value, index end
offset = 2 some_array[offset..-1].each_with_index{|item, index| some_func(item, index+offset) }
dt = Time.local(2010, printf "%d/%d/%d", dt.day, dt.month, dt.year
Date (Year, Month, Day): %Y - Year with century (can be negative, 4 digits at least) -0001, 0000, 1995, 2009, 14292, etc. %C - year / 100 (rounded down such as 20 in 2009) %y - year % 100 (00..99) %m - Month of the year, zero-padded (01..12) %_m blank-padded ( 1..12) %-m no-padded (1..12) %B - The full month name (``January %^B uppercased (``JANUARY %b - The abbreviated month name (``Jan %^b uppercased (``JAN %h - Equivalent to %b %d - Day of the month, zero-padded (01..31) %-d no-padded (1..31) %e - Day of the month, blank-padded ( 1..31) %j - Day of the year (001..366) Time (Hour, Minute, Second, Subsecond): %H - Hour of the day, 24-hour clock, zero-padded (00..23) %k - Hour of the day, 24-hour clock, blank-padded ( 0..23) %I - Hour of the day, 12-hour clock, zero-padded (01..12) %l - Hour of the day, 12-hour clock, blank-padded ( 1..12) %P - Meridian indicator, lowercase (``am %p - Meridian indicator, uppercase (``AM %M - Minute of the hour (00..59) %S - Second of the minute (00..60) %L - Millisecond of the second (000..999) The digits under millisecond are truncated to not produce 1000. %N - Fractional seconds digits, default is 9 digits (nanosecond) %3N millisecond (3 digits) %6N microsecond (6 digits) %9N nanosecond (9 digits) %12N picosecond (12 digits) %15N femtosecond (15 digits) %18N attosecond (18 digits) %21N zeptosecond (21 digits) %24N yoctosecond (24 digits) The digits under the specified length are truncated to avoid carry up. Time zone: %z - Time zone as hour and minute offset from UTC (e.g. +0900) %:z - hour and minute offset from UTC with a colon (e.g. +09:00) %::z - hour, minute and second offset from UTC (e.g. +09:00:00) %Z - Abbreviated time zone name or similar information. Weekday: %A - The full weekday name (``Sunday %^A uppercased (``SUNDAY %a - The abbreviated name (``Sun %^a uppercased (``SUN %u - Day of the week (Monday is 1, 1..7) %w - Day of the week (Sunday is 0, 0..6) ISO 8601 week-based year and week number: The first week of YYYY starts with a Monday and includes YYYY-01-04. The days in the year before the first week are in the last week of the previous year. %G - The week-based year %g - The last 2 digits of the week-based year (00..99) %V - Week number of the week-based year (01..53) Week number: The first week of YYYY that starts with a Sunday or Monday (according to %U or %W). The days in the year before the first week are in week 0. %U - Week number of the year. The week starts with Sunday. (00..53) %W - Week number of the year. The week starts with Monday. (00..53) Seconds since the Epoch: %s - Number of seconds since 1970-01-01 00:00:00 UTC. Literal string: %n - Newline character (\n) %t - Tab character (\t) %% - Literal ``% Combination: %c - date and time (%a %b %e %T %Y) %D - Date (%m/%d/%y) %F - The ISO 8601 date format (%Y-%m-%d) %v - VMS date (%e-%^b-%4Y) %x - Same as %D %X - Same as %T %r - 12-hour time (%I:%M:%S %p) %R - 24-hour time (%H:%M) %T - 24-hour time (%H:%M:%S)
Flags: - don _ use spaces for padding. 0 use zeros for padding. ^ upcase the result string. : use colons for %z.
def chunk(string, size) (0..(string.length-1)/size).map{|i|string[i*size,size]} end >> chunk("abcdef",3) => ["abc", "def"] >> chunk("abcde",3) => ["abc", "de"] >> chunk("abc",3) => ["abc"] >> chunk("ab",3) => ["ab"] >> chunk("",3) => []
>> => ["abcd", "efgh", "ijkl", "mnop", "qrst", "uvwx"] >> => ["abcd", "efgh", "ijkl", "mnop", "qrst", "uvwx", "yz"] >> => ["abc", "def", "ghi", "jkl", "mno", "pqr", "stu", "vwx", "yz"]
"abcdefghijklmnopqrstuvwxyz".chars.to_a.each_slice(3).to_a.map {|s| s.to_s }
def chunk(string, size) (string.length / size).times.collect { |i| string[i * size, size] } end
def parts(string, count) size = string.length / count count.times.collect { |i| string[i * size, size] } end
io = StringIO.new(string) until io.eof? chunk = io.read(chunk_size) do_something(chunk) end
def distinct_count <<-EOF \tSELECT \t CAST( \t,COUNT(DISTINCT \tFROM EOF end
=> " \tSELECT\n \t CAST( COLUMN_NAME\n \t,COUNT(DISTINCT SRC_ACCT_NUM) AS DISTINCT_COUNT\n \tFROM UD461.MGMT_REPORT_HNB\n"
def test <<~END First content line. Two spaces here. No space here. END end test
def distinct_count <<-EOF.gsub /^\s+/, "" \tSELECT \t CAST( \t,COUNT(DISTINCT \tFROM EOF end
class String def unindent gsub(/^ end end def distinct_count <<-EOF.unindent \tSELECT \t CAST( \t,COUNT(DISTINCT \tFROM EOF end
foo = { bar: <<-ENDBAR.unindent My multiline and indented content here Yay! ENDBAR }
class String def strip_indent if mindent=scan(/^[ \t]+/).min_by(&:length) gsub /^ end end end
<<-EOF.gsub /^\s*/, \tSELECT \t CAST( \t,COUNT(DISTINCT \tFROM EOF
<<-EOF.gsub /^ */, \tSELECT \t CAST( \t,COUNT(DISTINCT \tFROM EOF
class String # # # def unindent lines = [] each_line {|ln| lines << ln } first_line_ws = lines[0].match(/^\s+/)[0] re = Regexp.new( lines.collect {|line| line.sub(re, "") }.join end end
def distinct_count <<-SQL.squish SELECT CAST( COUNT(DISTINCT FROM SQL end
class Match < ActiveRecord::Base has_one :invitation scope :upcoming, -> do joins(:invitation) .where(<<-SQL_QUERY.strip_heredoc, Date.current, Date.current).order( CASE WHEN invitations.autogenerated_for_round IS NULL THEN invitations.date >= ? ELSE (invitations.round_end_time >= ? AND match_plays.winner_id IS NULL) END SQL_QUERY end end
def update_makefile(build_path, version, sha1) system <<-CMD.strip_heredoc(true) \\sed -i".bak" -e "s/GIT_VERSION[\ ]*:=.*/GIT_VERSION := 20171-2342/g" -e "s/GIT_VERSION_SHA1[\ ]:=.*/GIT_VERSION_SHA1 := 2342/g" "/tmp/Makefile" CMD end
class ::String def strip_heredoc(compress = false) stripped = gsub(/^ compress ? stripped.gsub(/\n/," ").chop : stripped end end
class MyClass def foo; end def bar; end end obj = MyClass.new str = get_data_from_user str
method_name = obj.public_send(method_name) if obj.respond_to? method_name
if obj.respond_to?(method_name) && %w[foo bar].include?(method_name) obj.send(method_name) end
+---------------+-----------------+-----------------+------------+------------+ | Method | Arbitrary Code? | Access Private? | Dangerous? | Fastest On | +---------------+-----------------+-----------------+------------+------------+ | eval | Yes | No | Yes | TBD | | instance_eval | Yes | No | Yes | TBD | | send | No | Yes | Yes | TBD | | public_send | No | No | Yes | TBD | | method | No | Yes | Yes | TBD | +---------------+-----------------+-----------------+------------+------------+
class MyClass def foo(*args); end private def bar(*args); end end obj = MyClass.new
obj.instance_eval( obj.instance_eval( obj.instance_eval( obj.instance_eval(
obj.public_send( obj.public_send( obj.public_send( obj.public_send(
require puts Time.parse("2010-10-25 23:48:46 UTC").iso8601 "2010-10-25T23:48:46Z"
ruby-1.9.2-p180 :016 > "2010-10-25 23:48:46 UTC".to_time.iso8601 NoMethodError: undefined method `to_time from (irb):16
irb> ut = DateTime.parse("2010-10-25 23:48:46 UTC") irb> ut.iso8601 => "2010-10-25T23:48:46+00:00"
class P def self.mm; puts end class Q < P; end Q.mm
module M def self.mm; puts end class N; include M end M.mm N.mm
module Common def self.class_method; puts "class method here" end def instance_method; puts "instance method here" end end
class A; include Common end class B; include Common end
module Foo def self.included base base.send :include, InstanceMethods base.extend ClassMethods end module InstanceMethods def bar1 end end module ClassMethods def bar2 end end end class Test include Foo end Test.new.bar1 Test.bar2
module M def foo; "foo"; end end class C include M def bar; "bar"; end end C.ancestors
module M def instance_method "foo" end def self.class_method "bar" end end class C include M end M.class_method C.new.instance_method C.class_method
klass = Class.new do def foo "foo" end end klass.new.foo
obj = Object.new def obj.foo "foo" end obj.singleton_class.instance_methods(false)
class Abc end def Abc.foo "foo" end Abc.singleton_class.instance_methods(false)
class Abc def self.foo "foo" end end Abc.singleton_class.instance_methods(false)
module M def new_instance_method; "hi"; end module ClassMethods def new_class_method; "hello"; end end end class HostKlass include M self.singleton_class.include M::ClassMethods end HostKlass.new_class_method
class HostKlass include M extend M::ClassMethods end HostKlass.singleton_class.included_modules
module M def new_instance_method; "hi"; end def self.included(base) base.extend ClassMethods end module ClassMethods def new_class_method; "hello"; end end end class HostKlass include M def self.existing_class_method; "cool"; end end HostKlass.singleton_class.included_modules
def self.included(base) base.existing_class_method end
require module Common extend ActiveSupport::Concern def instance_method puts "instance method here" end class_methods do def class_method puts "class method here" end end end class A include Common end
module M def self.included(base) base.class_eval do def self.doit @@fred = "Flintstone" "class method doit called" end def doit(str) @@common_var = "all instances" @instance_var = str "instance method doit called" end def get_them [@@common_var,@instance_var,@@fred] end end end end class F; end F.include M F.doit a = F.new b = F.new a.doit("Yo") b.doit("Ho") a.get_them b.get_them
module OS def OS.windows? (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil end def OS.mac? (/darwin/ =~ RUBY_PLATFORM) != nil end def OS.unix? !OS.windows? end def OS.linux? OS.unix? and not OS.mac? end def OS.jruby? RUBY_ENGINE == end end
irb(main):001:0> Gem::Platform.local => irb(main):002:0> Gem::Platform.local.os => "mingw32"
irb(main):002:0> require => true irb(main):003:0> Config::CONFIG["arch"] => "i686-linux"
require include Config case CONFIG[ when /mswin|windows/i when /linux|arch/i when /sunos|solaris/i when /darwin/i else end
def self.windows? return File.exist? "c:/WINDOWS" if RUBY_PLATFORM == RUBY_PLATFORM =~ /mingw32/ || RUBY_PLATFORM =~ /mswin32/ end def self.linux? return File.exist? "/usr" if RUBY_PLATFORM == RUBY_PLATFORM =~ /linux/ end def self.os return :linux if self.linux? return :windows if self.windows? nil end
class Product < ActiveRecord::Base validates :title, :description, :image_url, presence: true validates :price, numericality: {greater_than_or_equal_to: 0.01} validates :title, uniqueness: true validates :image_url, allow_blank: true, format: { with: %r{\.(gif|jpg|png)$}i, message: } end
rake aborted! The provided regular expression is using multiline anchors (^ or $), which may present a security risk. Did you mean to use \A and \z, or forgot to add the :multiline => true option?
string = "abcde\nzzzz" /^abcde$/ === string /\Aabcde\z/ === string
"test.png\n<script>alert(1)</script>" === /\.(gif|jpg|png)$/i "test.png\n<script>alert(1)</script>" === /\.(gif|jpg|png)\z/i
config.email_regexp = /^([\w\.%\+\-]+)@([\w\-]+\.)+([\w]{2,})$/i
config.email_regexp = /\A([\w\.%\+\-]+)@([\w\-]+\.)+([\w]{2,})\Z/i
test = "image.gif\nthis is not an image" re = /\.(gif|jpg|png)$/i re.match(test)
validates :image_url, allow_blank: true, format: {with: %r{\.(gif|jpg|png)\z}i, message:
class NilClass def method_missing(*args); nil; end end my_hash[
module NestedHashLookup def nest *keys keys.reduce(self) {|m,k| m && m[k] } end end my_hash.extend(NestedHashLookup) my_hash.nest
def autovivifying_hash Hash.new {|ht,k| ht[k] = autovivifying_hash} end
def lookup(model, key, *rest) v = model[key] if rest.empty? v else v && lookup(v, *rest) end end lookup(my_hash, => nil or value
def driving_directions @address_to = params[:address_to] @address_from = params[:address_from] @map_center = params[:map_center_start] if !@map_center && @address_to @map_center = GeoKit::Geocoders::MultiGeocoder.geocode(@address_to).ll elsif !@map_center && @address_from @map_center = GeoKit::Geocoders::MultiGeocoder.geocode(@address_from).ll end end def printer_friendly starting_point = params[:starting_point].split( ne = params[:ne].split( sw = params[:sw].split( size = params[:size].split( address = params[:address] @markers = retrieve_points(ne,sw,size,false) @map = initialize_map([[sw[0],sw[1]],[ne[0],ne[1]]],[starting_point[0],starting_point[1]],false,@markers,true) @address_string = address end
Capybara.register_driver :selenium_chrome do |app| Capybara::Selenium::Driver.new(app, :browser => :chrome) end
Capybara.current_driver = :selenium_chrome ... tests ... Capybara.use_default_driver
sudo apt-get install xvfb sudo apt-get install x11-xkb-utils sudo apt-get install xfonts-100dpi xfonts-75dpi xfonts-scalable xfonts-cyrillic
task :migrate, :roles => :db, :only => { :primary => true } do end
W: Failed to fetch http: W: Failed to fetch http: W: Failed to fetch http: W: Failed to fetch http: W: Failed to fetch http: W: Failed to fetch http:
sudo apt-get -y update sudo apt-get -y install build-essential zlib1g-dev libssl-dev libreadline6-dev libyaml-dev cd /tmp wget http: tar -xvzf ruby-2.0.0-p481.tar.gz cd ruby-2.0.0-p481/ ./configure --prefix=/usr/local make sudo make install
/bin/bash --login rvm install 2.0.0 rvm use 2.0.0 rvm rubygems latest ruby --version
sudo apt-get update && sudo apt-get install git-core curl zlib1g-dev \ build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev \ sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev \ python-software-properties libffi-dev
cd git clone git: echo echo git clone git: echo source ~/.bash_profile
$ sudo apt-get install python-software-properties $ sudo apt-add-repository ppa:brightbox/ruby-ng $ sudo apt-get update $ sudo apt-get install ruby2.1 ruby-switch $ sudo ruby-switch --set ruby2.1
sudo apt-get update sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties
cd git clone git: echo echo exec $SHELL git clone git: echo exec $SHELL rbenv install 2.0.0 rbenv global 2.0.0 ruby -v
module MyModule def im_awesome puts " end end class ApplicationController < ActionController::Base include MyModule end class AnotherClass end AnotherClass.new.im_awesome
class AnotherClass include MyModule end AnotherClass.new.im_awesome
config.autoload_paths += %W( config.autoload_paths += Dir["
class Myclass < ActiveRecord::Base extend MyModule def self.method1 Myclass.my_module_method end end
class Myclass < ActiveRecord::Base include MyModule def method1 self.my_module_method end end
require_dependency class MyModel < ActiveRecord::Base include MyModule MyModule.some_method end
variable = id if variable.nil? || (!variable.nil? && variable.empty?)
a = nil b = [] c = "" a.blank? b.blank? c.blank? d = "1" e = ["1"] d.blank? e.blank?
h1 = {:a => :A, :b => :B, :c => :C, :d => :D} h2 = h1.select {|key, value| [:b, :d, :e, :f].include?(key) } h1 = Hash[h1.to_a - h2.to_a]
class Hash def extract_subhash(*extract) h2 = self.select{|key, value| extract.include?(key) } self.delete_if {|key, value| extract.include?(key) } h2 end end
h1 = {:a => :A, :b => :B, :c => :C, :d => :D} h1.delete_if {|key, value| [:b, :d, :e, :f].include?(key) } h1
x = {a: 1, b: 2, c: 3, d: 4} x.slice(:a, :b) x x.except(:a, :b) x
{:a => :A, :b => :B, :c => :C, :d => :D}.slice(:a, :c)
def slice(hash, *keys) Hash[ [keys, hash.values_at(*keys)].transpose] end def except(hash, *keys) desired_keys = hash.keys - keys Hash[ [desired_keys, hash.values_at(*desired_keys)].transpose] end
hash = {:a => 1, :b => 2, :c => 3} keys = [:a, :b] values = hash.values_at(*keys) transposed_matrix =[keys, values].transpose Hash[transposed_matrix]
module MyExtension module Hash def slice(*keys) ::Hash[[keys, self.values_at(*keys)].transpose] end def except(*keys) desired_keys = self.keys - keys ::Hash[[desired_keys, self.values_at(*desired_keys)].transpose] end end end Hash.include MyExtension::Hash
h = { a: 100, b: 200, c: 300 } h.slice(:a) h.slice(:b, :c, :d)
module HashExtensions def subhash(*keys) keys = keys.select { |k| key?(k) } Hash[keys.zip(values_at(*keys))] end end Hash.send(:include, HashExtensions) {:a => :A, :b => :B, :c => :C, :d => :D}.subhash(:a)
initial_hash = {:a => 1, :b => 2, :c => 3, :d => 4} extracted_slice = initial_hash.slice!(:a, :c)
h1 = {:a => :A, :b => :B, :c => :C, :d => :D} keys = [:b, :d, :e, :f] h2 = (h1.keys & keys).each_with_object({}) { |k,h| h.update(k=>h1.delete(k)) } h1
class Hash def extract(*keys) key_index = Hash[keys.map{ |k| [k, true] }] partition{ |k, v| key_index.has_key?(k) }.map{ |group| Hash[group] } end end h1 = {:a => :A, :b => :B, :c => :C, :d => :D} h2, h1 = h1.extract(:b, :d, :e, :f)
class Hash def extract_subhash! *keys to_keep = self.keys.to_a - keys to_delete = Hash[self.select{|k,v| !to_keep.include? k}] self.delete_if {|k,v| !to_keep.include? k} to_delete end end
h1 = {:a => :A, :b => :B, :c => :C, :d => :D} p h1.extract_subhash!(:b, :d, :e, :f) p h1
k = 1_000_000 Benchmark.bmbm do |x| x.report( x.report( x.report( end Rehearsal -------------------------------------------------- select 1.640000 0.010000 1.650000 ( 1.651426) hash transpose 1.720000 0.010000 1.730000 ( 1.729950) slice 1.740000 0.010000 1.750000 ( 1.748204) ----------------------------------------- total: 5.130000sec user system total real select 1.670000 0.010000 1.680000 ( 1.683415) hash transpose 1.680000 0.010000 1.690000 ( 1.688110) slice 1.800000 0.010000 1.810000 ( 1.816215)
module CoreExtensions module Extractable refine Hash do def extract(*keys) select { |k, _v| keys.include?(k) } end end end end
using ::CoreExtensions::Extractable { a: 1, b: 2, c: 3 }.extract(:a, :b)
h1 = {:a => :A, :b => :B, :c => :C, :d => :D} h2 = h1.clone p h1.keep_if { |key| [:b, :d, :e, :f].include?(key) } p h2.delete_if { |key, value| [:b, :d, :e, :f].include?(key) }
slice_hash = -> keys, hash { hash.select { |k, _v| keys.include?(k) } }.curry
my_hash = [{name: "Joe", age: 34}, {name: "Amy", age: 55}] my_hash.map(&slice_hash.([:name]))
module Music module Record end module EightTrack end end module Record end
module A def self.method; "Outer"; end end module B module A def self.method; "Inner"; end end A.method ::A.method end
if password.length < 8 fail "Password too short" end unless username fail "No user name set" end
def sample fail rescue => e logger.error e raise end
def thing(*args, &block) value = block.call puts "value= end thing { return 6 * 7 }
$ irb irb(main):001:0> def thing(*args, &block) irb(main):002:1> value = block.call irb(main):003:1> puts "value= irb(main):004:1> end => nil irb(main):005:0> irb(main):006:0* thing { irb(main):007:1* return 6 * 7 irb(main):008:1> } LocalJumpError: unexpected return from (irb):7:in `block in irb_binding' from (irb):2:in `call' from (irb):2:in `thing' from (irb):6 from /home/mirko/.rvm/rubies/ruby-1.9.1-p378/bin/irb:15:in `<main>' irb(main):009:0> thing { break 6 * 7 } => 42 irb(main):011:0> thing { next 6 * 7 } value=42 => nil
describe "The return keyword" do describe "within a block" do it "causes the method that lexically encloses the block to return" do it "returns from the lexically enclosing method even in case of chained calls" do
def thing(*args, &block) block.call.tap do |value| puts "value= end end thing { 6 * 7 }
class MyThing def ret b @retval = b end def thing(*args, &block) implicit = block.call value = @retval || implicit puts "value= end def example1 thing do ret 5 * 6 4 end end def example2 thing do 5 * 6 end end end
def return_wrap(&block) Thread.new { return yield }.join rescue LocalJumpError => ex ex.exit_value end def thing(*args, &block) value = return_wrap(&block) puts "value= end thing { return 6 * 7 }
def thing(*args, &block) if block block_response = nil begin block_response = block.call rescue Exception => e if e.message == "unexpected return" block_response = e.exit_value else raise e end end puts "value= else puts "no block given" end end
def thing(*args, &block) define_method(:__thing, &block) puts "value= end thing { return 6 * 7 }
class Base def initialize() set_defaults() end protected def set_defaults() @foo = 7 calculate_and_set_baz() end private def calculate_and_set_baz() @baz = "Something that only base classes have like a file handle or resource" end end class Derived < Base protected def set_defaults() @foo = 13 end end
class Foo def initialize(symbol) eigenclass = class << self self end eigenclass.class_eval do attr_accessor symbol end end end
class Foo class << self def a print "I could also have been defined as def Foo.a." end end end
str = "abc" other_str = "def" class << str def frob return self + "d" end end print str.frob print other_str.frob
f1 = Foo.new(:weasels) f2 = Foo.new(:monkeys) f1.weasels = 4 f2.monkeys = 5 print(f1.monkeys)
class F def eigen class << self self end end end F.new.eigen.new
Rails.application.config.session_store :active_record_store
config.action_controller.session_store = :active_record_store
before_filter :authenticate_rights, :only => [:show] def authenticate_rights project = Project.find(params[:id]) redirect_to signin_path unless project.hidden end
before_filter { |c| c.authenticate_rights correct_id_here } def authenticate_rights(project_id) project = Project.find(project_id) redirect_to signin_path unless project.hidden end
before_filter -> { find_campaign params[:id] }, only: [:show, :edit, :update, :destroy]
before_filter ->(param=params[:id]) { find_campaign param }, only: %i|show edit update destroy|
before_action ->(param=params[:id]) { find_campaign param }, only: %i|show edit update destroy|
before_filter :only => [:edit, :update, :destroy] do |c| c.authenticate_rights params[:id] end
before_action(only: [:show]) { authenticate_rights(id) }
project = Project.find(params[:project_id] || params[:id])
for (int i = 0; i < aString.length(); i++){ char currentChar = aString.charAt(i); System.out.println(currentChar); }
class String def each_char self.split("").each { |i| yield i } end end
a = "cruel world" a.scan(/\w+/) a.scan(/.../) a.scan(/(...)/) a.scan(/(..)(..)/)
proc = Proc.new { |what| puts "Hello, meth = method(:print) proc["World"] meth["Hello",","," ", "World!", "\n"]
%w{ hello world } %w[ hello world ] %r{ hello world } %r[ hello world ] %q{ hello world } %q[ hello world ] %q| hello world |
[1, 2, 3].class [1, 2, 3][1] { 1 => 2, 3 => 4 }.class { 1 => 2, 3 => 4 }[3] { 1 + 2 }.class lambda { 1 + 2 }.class lambda { 1 + 2 }.call
class A def [](position) end def @rank.[]= key, val end end
/* * call-seq: * File.atime(file_name) => time * * Returns the last access time for the named file as a Time object). * * File.atime("testfile") * */
config.generators do |g| g.template_engine :haml end
`-- app `-- views |-- layouts | `-- application.html.haml `-- users |-- edit.html.haml |-- index.html.haml |-- new.html.haml `-- show.html.haml
patient1 = { :ruby => "red" } patient2 = { :ruby => "programming" } patient1.each_key {|key| puts key.object_id.to_s} 3918094 patient2.each_key {|key| puts key.object_id.to_s} 3918094
x = :sym y = :sym (x.__id__ == y.__id__ ) && ( :sym.__id__ == x.__id__) x = "string" y = "string" (x.__id__ == y.__id__ ) || ( "string".__id__ == x.__id__)
hash1 = { "string" => "value"} hash2 = { "string" => "value"}
hash1 = { :symbol => "value"} hash2 = { :symbol => "value"}
patient1 = Hash.new patient1[:ruby] = puts patient1[:ruby]
[ "foo", "foo", "foo", "bar", "bar", "bar" ].each do |v| puts v.inspect + end
[ :foo, :foo, :foo, :bar, :bar, :bar ].each do |v| puts v.inspect + end
[ "foo", "foo", "foo", "bar", "bar", "bar" ].each do |v| v = v.to_sym puts v.inspect + end
[ :foo, :foo, :foo, :bar, :bar, :bar ].each do |v| v = v.to_s puts v.inspect + end
patient1 = { :ruby => "red" } patient2 = { :ruby => "programming" } patient1.each_key {|key| puts key.object_id.to_s} 3918094 patient2.each_key {|key| puts key.object_id.to_s} 3918094
log_database_production: adapter: mysql host: other_host username: logmein password: supersecret database: logs
class AccessLog < ActiveRecord::Base establish_connection "log_database_ end
class LogDatabase < ActiveRecord::Base self.abstract_class = true establish_connection "log_database_ end class AccessLog < LogDatabase end class CheckoutLog < LogDatabase end
class Person < ActiveRecord::Base end class Place < ActiveRecord::Base establish_connection ( :adapter => "mysql", :host => "other_host", :username => "username", :password => "password", :database => "other_db" ) end
support_development: adapter: blah database: blah username: blah password: blah
class SupportBase < ActiveRecord::Base self.abstract_class = true establish_connection("support_development") end
class TstTest < SupportBase self.table_name = def self.get_test_name(id) if id = nil return else query = "select tst_name from tst_test where tst_id = \ tst = connection.select_all(query) return tst[0].fetch( end end end
desc "Migrate the database through scripts in db/migrate directory." namespace :db do task :migrate do Rake::Task["db:migrate_db1"].invoke Rake::Task["db:migrate_db2"].invoke end task :migrate_db1 do ActiveRecord::Base.establish_connection DB1_CONF ActiveRecord::Migrator.migrate("db/migrate/db1/") end task :migrate_db2 do ActiveRecord::Base.establish_connection DB2_CONF ActiveRecord::Migrator.migrate("db/migrate/db2/") end end
a=%w[b c d] => ["b", "c", "d"] a.unshift("a") => ["a", "b", "c", "d"]
a = [2, 4, 8] a.push(16, 32) a.unshift(0, 1) a.shift a.pop
"".present? " ".present? [].present? false.present? YourActiveRecordModel.where("false = true").present?
!"".nil? !" ".nil? ![].nil? !false.nil? !YourActiveRecordModel.where("false = true").nil?
if object p "object exists" else p "object does not exist" end
git submodule add git@github.com:lgs/oauth2.git lib/oauth2
cd lib/oauth2 && git checkout <branchname_or_ref> cd .. && git add lib/oauth2 git commit -m "adding outh2 submodule"
uri = URI.parse(my_possible_url) if uri.kind_of?(URI::HTTP) or uri.kind_of?(URI::HTTPS) end
require SCHEMES = %w(http https) def valid_url?(url) parsed = Addressable::URI.parse(url) or return false SCHEMES.include?(parsed.scheme) rescue Addressable::URI::InvalidURIError false end
String.class_eval do def is_valid_url? uri = URI.parse self uri.kind_of? URI::HTTP rescue URI::InvalidURIError false end end
/^(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/ix
def valid_url?(url) url_regexp = /^(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/ix url =~ url_regexp ? true : false end
irb> uri = URI.parse "http: => irb> uri.instance_values => {"fragment"=>nil, "registry"=>nil, "scheme"=>"http", "query"=>nil, "port"=>80, "path"=>"", "host"=>"hello.it", "password"=>nil, "user"=>nil, "opaque"=>nil} irb> uri = URI.parse "http:||bra.ziz" rescue nil => nil irb> uri = URI.parse "ssh: => [26] pry(main)> uri.instance_values => {"fragment"=>nil, "registry"=>nil, "scheme"=>"ssh", "query"=>nil, "port"=>5888, "path"=>"", "host"=>"hello.it", "password"=>nil, "user"=>nil, "opaque"=>nil}
url_regex = Regexp.new("((https?|ftp|file):(( urls = [ "http: "http:||bra.ziz" ] urls.each { |url| if url =~ url_regex then puts "%s is valid" % url else puts "%s not valid" % url end }
require def local_ip orig, Socket.do_not_reverse_lookup = Socket.do_not_reverse_lookup, true UDPSocket.open do |s| s.connect s.addr.last end ensure Socket.do_not_reverse_lookup = orig end
require ip_address = Socket.ip_address_list.find { |ai| ai.ipv4? && !ai.ipv4_loopback? }.ip_address
require def my_first_private_ipv4 Socket.ip_address_list.detect{|intf| intf.ipv4_private?} end def my_first_public_ipv4 Socket.ip_address_list.detect{|intf| intf.ipv4? and !intf.ipv4_loopback? and !intf.ipv4_multicast? and !intf.ipv4_private?} end
ip= my_first_public_ipv4.ip_address unless my_first_public_ipv4.nil?
require "socket" local_ip = UDPSocket.open {|s| s.connect("64.233.187.99", 1); s.addr.last}
ip_addresses = `ifconfig | grep => [ ip_addresses = `ifconfig -a | grep => [
io = IO.popen( hostname = io.readlines io = IO.popen( ifconfig = io.readlines ip = ifconfig[11].scan(/\ \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\ /)
class MainController < ApplicationController def index @posts = Posts.find(:all, :limit => 10, :order => end end
class WelcomeController < ApplicationController def index @posts = Posts.find(:all, :limit => 10, :order => end end
class StaticController < ApplicationController def index end end
MyApp::Application.routes.draw do match root :to => "static end
users.each_with_index do |u, index| if index == users.size - 1 end end
users.each_with_index do |u, i| if users.size-1 == i end end
h = { :a => :aa, :b => :bb } h.each_with_index do |(k,v), i| puts end
users[0...-1].each do |user| method_for_all_users user end method_for_all_users users.last method_for_last_user users.last
user_list = users.each begin while true do user = user_list.next user.do_something end rescue StopIteration user.do_something end
h = { :a => :aa, :b => :bb } last_key = h.keys.last h.each do |k,v| puts "Put last key end
points = Post.find_by_sql("select point from posts")
Person.pluck(:id) Person.pluck(:role).uniq Person.distinct.pluck(:role) Person.where(:confirmed => true).limit(5).pluck(:id)
def select_values(arel, name = nil) result = select_rows(to_sql(arel), name) result.map { |v| v[0] } end
def too_much; something; something_else; end def no_braces_method; body end def no_braces_method; body; end def some_method() body end def some_method body end
Ruby: ruby 1.9.3dev (2011-09-23 revision 33323) [i686-linux] Rails: 3.2.9 Capybara: 2.0.3
link_to("Send Notification", notification_path(user_id: user_id), remote: true, method: :post)
:plain var notificationStatusContainer = $( notificationStatusContainer.val(" notificationStatusContainer.show();
page.find( page.should have_selector( page.should have_css( page.find( page.find(:css,
Not all drivers support CSS, so the result may be inaccurate.
module CustomMatchers def should_be_visible(css_selector) find(css_selector)[ end end World(CustomMatchers)
<div id="visible-empty" ></div> <div id="visible-empty-background" style="width:10px; height:10px; background:black;"></div> <div id="visible-empty-background-same" style="width:10px; height:10px; background:white;"></div> <div id="visible-visibility-hidden" style="visibility:hidden;" >a</div> <div id="visible-display-none" style="display:none;" >a</div>
Capybara.current_driver = :poltergeist !all( !all( !all( !all( all(
Capybara.current_driver = :selenium all( !all( !all( all( all(
def wait_for_ajax(timeout = Capybara.default_wait_time) page.wait_until(timeout) do page.evaluate_script end end
class User include Mongoid::Document end user = User.where(email: if user user.password = new_password user.password_confirmation = new_password user.save end
user.password = new_password; user.save user.update_attributes(password: new_password)
u=User.where(:email => u.password= u.password_confirmation= u.save!
u = User.find_by_email( u.update_attribute(:password,
irb(main):001:0> user = User.where("username = irb(main):002:0> u = user.first irb(main):003:0> u.password="root2014@Robin" => "root2014@Robin" irb(main):004:0> u.password_confirmation="root2014@Robin" => "root2014@Robin" irb(main):005:0> u.save => true irb(main):006:0> exit
require if Gem::Version.new(RUBY_VERSION) < Gem::Version.new( extend DL::Importable else extend DL::Importer end
def write_code(number_of_errors) if number_of_errors > 1 mood = "Ask me later" else mood = "No Problem" end mood end
def write_code(number_of_errors) if number_of_errors > 1 mood = "Ask me later" else mood = puts "No Problem" end return mood end
def write_code(number_of_errors) return "No problem" if number_of_errors == 0 badness = compute_badness(number_of_errors) "WHAT?! Badness = end
def last_name(name) return nil unless name name.split(/\s+/)[-1] end
def write_code(number_of_errors) if number_of_errors > 1 "ERROR" else "No Problem" end end puts write_code(10)
def write_code(number_of_errors) (number_of_errors > 1)? "ERROR" : "No Problem" end
GoogleChart::PieChart.new( pc.data "Broccoli", 30 pc.data "Pizza", 20 pc.data "PB&J", 40 pc.data "Turnips", 10 puts pc.to_url end
chris@chris-laptop:~$ gem environment RubyGems Environment: - RUBYGEMS VERSION: 1.3.2 - RUBY VERSION: 1.8.7 (2008-08-11 patchlevel 72) [i486-linux] - INSTALLATION DIRECTORY: /usr/lib/ruby/gems/1.8 - RUBY EXECUTABLE: /usr/bin/ruby1.8 - EXECUTABLE DIRECTORY: /usr/bin - RUBYGEMS PLATFORMS: - ruby - x86-linux - GEM PATHS: - /usr/lib/ruby/gems/1.8 - /home/chris/.gem/ruby/1.8 - GEM CONFIGURATION: - :update_sources => true - :verbose => true - :benchmark => false - :backtrace => false - :bulk_threshold => 1000 - REMOTE SOURCES:
chris@chris-laptop:~$ chris@chris-laptop:~$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games chris@chris-laptop:~$ chris@chris-laptop:~$ export PATH=$PATH:/var/lib/gems/1.8/bin chris@chris-laptop:~$ chris@chris-laptop:~$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/var/lib/gems/1.8/bin chris@chris-laptop:~$
rb(main):003:0> Gem.path => ["/opt/ruby1.9/lib/ruby1.9/gems/1.9.1"] irb(main):004:0> exit
:~/$ gem env RubyGems Environment: - RUBYGEMS VERSION: 1.3.7 - RUBY VERSION: 1.9.1 (2009-05-12 patchlevel 129) [x86_64-linux] - INSTALLATION DIRECTORY: /opt/ruby1.9/lib/ruby/gems/1.9.1 - RUBY EXECUTABLE: /opt/ruby1.9/bin/ruby1.9 - EXECUTABLE DIRECTORY: /opt/ruby1.9/bin - RUBYGEMS PLATFORMS: - ruby - x86_64-linux - GEM PATHS: - /opt/ruby1.9/lib/ruby/gems/1.9.1 - /home/mark/.gem/ruby/1.9.1 - GEM CONFIGURATION: - :update_sources => true - :verbose => true - :benchmark => false - :backtrace => false - :bulk_threshold => 1000 - REMOTE SOURCES: - http:
Please switch to Ruby 1.9 CSV library. It support for Ruby 1.9 engine.
require require secrecy_levels_array = [[ [ [ puts secrecy_levels_array.each do |line| puts line.to_csv end
> $LOAD_PATH.push("/Users/myuser") > load( foo.rb loaded! => true
DateTime now = new DateTime(); DateTime ninetyDaysAgo = now.minusDays(90);
require now = Date.today ninety_days_ago = (now - 90)
>>require now = Date.today ninety_days_ago = (now - 90) require => false now = Date.today => ninety_days_ago = (now - 90) =>
DateTime.now - 10.days => Sat, 04 May 2013 12:12:07 +0300 20.days.ago - 10.days => Sun, 14 Apr 2013 09:12:13 UTC +00:00
ruby-1.9.2-p136 :002 > Date.today => Wed, 02 Mar 2011 ruby-1.9.2-p136 :003 > Date.today - 90.days => Thu, 02 Dec 2010
ruby-1.9.2-p136 :016 > DateTime.now.to_date => ruby-1.9.2-p136 :017 > DateTime.now.to_date - 90 =>
$ irb > require => true > (DateTime.new(2015,4,1) - 90).to_s => "2015-01-01T00:00:00+00:00" > (DateTime.new(2015,4,1) - 1).to_s => "2015-03-31T00:00:00+00:00"
> (Date.new(2015, 5, 31) << 3).to_s => "2015-02-28"
@var = "Hi" puts " @@var = "Hi" puts " $var = "Hi" puts "
start = Time.now.to_i range = start..(start + 2) inside = start + 1 outside = start + 3 range === inside range === outside
irb(main):019:0> (Time.now .. (Time.now+1)) === Time.now TypeError: can from (irb):19:in `each' from (irb):19:in `include?' from (irb):19:in `include?' from (irb):19:in `===' from (irb):19 from /opt/ruby192/bin/irb:12:in `<main>'
irb(main):002:0> (Time.now..Time.now+4).cover?(Time.now) => true irb(main):003:0> (Time.now..Time.now+4).cover?(Time.now+10) => false
> start_time = Time.zone.parse( > end_time = start_time + 1.hour => Thu, 26 Jul 2012 13:00:00 EDT -04:00 > inside = Time.zone.parse( > outside = Time.zone.parse( > inside.between?(start_time, end_time) => true > outside.between?(start_time, end_time) => false
require today = Date.today tomorrow = today + 1 one_month_later = today >> 1 tomorrow.between?(today, one_month_later)
ruby-1.8.7-p299 :015 > a = DateTime.now => Fri, 02 Dec 2011 11:04:24 -0800 ruby-1.8.7-p299 :016 > (a.beginning_of_day..a.end_of_day).include_with_range? a => true ruby-1.8.7-p299 :017 > (a.beginning_of_day..a.end_of_day).include_with_range? a+10.days => false ruby-1.8.7-p299 :018 > (a.beginning_of_day..a.end_of_day).include_with_range? a+25.hours => false ruby-1.8.7-p299 :019 > (a.beginning_of_day..a.end_of_day).include_with_range? a+2.hours => true
currentDate = DateTime.now start_date = "2017-03-31" end_date = "2018-03-31" currentDate.between?(start_date, end_date) **Out Put Will be** true or false
d1 = DateTime.parse( d2 = DateTime.parse( outside = DateTime.parse( inside = DateTime.parse( (d1...d2).include?(d1) (d1...d2).include?(d2) (d1...d2).include?(outside) (d1...d2).include?(inside) (d1..d2).include?(d1) (d1..d2).include?(d2) (d1..d2).include?(outside) (d1..d2).include?(inside) (d1...d2) === d1 (d1...d2) === d2 (d1...d2) === outside (d1...d2) === inside (d1..d2) === d1 (d1..d2) === d2 (d1..d2) === outside (d1..d2) === inside (d1...d2).cover?(d1) (d1...d2).cover?(d2) (d1...d2).cover?(outside) (d1...d2).cover?(inside) (d1..d2).cover?(d1) (d1..d2).cover?(d2) (d1..d2).cover?(outside) (d1..d2).cover?(inside) d1.between?(d1, d2) d2.between?(d1, d2) outside.between?(d1, d2) inside.between?(d1, d2)
array.each_with_index do |element,index| element.do_stuff(index) end
limit = array.length; for counter in 0..limit --- make some actions --- end
start = Date.new(2013,06,30) stop = Date.new(2011,06,30) start.step(stop, -7).each do |d| puts d end
i = 0 while i < array.size do array[i] i = i + 1 end
1.9.3p392 :031 > (2..4).each {|i| puts i} 2 3 4 => 2..4
require "pathname" Pathname.new(directory_name).children.select { |c| c.directory? }
Pathname.new(directory_name).children.select { |c| c.directory? }.collect { |p| p.to_s }
directory = Dir.entries(directory).select { |file| File.directory? File.join(directory, file}
directory = puts Dir.entries(directory).select { |file| File.directory? File.join(directory, file)}
$dir_target = "/Users/david/Movies/Camtasia 2/AzureMobileServices.cmproj/media" Dir.glob(" if File.directory?(f) puts " end end
base_dir_path = directory_paths = Dir.glob(File.join(base_dir_path, directory_paths = Dir.glob(File.join(base_dir_path, directories = directory_paths.collect {|path| Pathname.new(path) } directory_names = directories.collect {|dir| dir.basename.to_s }
class MyClass attr_writer :item1, :item2 end my_array = get_array_of_my_class() unique_array_of_item1 = []
my_array.push(item1) unless my_array.include?(item1)
class Array def add_if_unique element return self if include? element push element end end
host_group = Array.new if not host_group.kind_of?(Array) host_group.push(host)
def File.expand_path(path, relative_to=Dir.getwd) absolute_path = File.join(relative_to, path) while absolute_path.include?( absolute_path = absolute_path.sub(%r{/[^/]+/\.\.}, end absolute_path end
def test_method_names_become_symbols symbols_as_strings = Symbol.all_symbols.map { |x| x.to_s } assert_equal true, symbols_as_strings.include?("test_method_names_become_symbols") end #
assert_equal true, all_symbols.include?(:test_method_names_become_symbols)
def test_you_create_a_new_symbol_in_the_test array_of_symbols = [] array_of_symbols << Symbol.all_symbols all_symbols = Symbol.all_symbols.map {|x| x} assert_equal false, array_of_symbols.include?(:this_should_not_be_in_the_symbols_collection) assert_equal true, all_symbols.include?(:this_also_should_not_be_in_the_symbols_collection) end
string = "the:rain:in:spain" words = string.split(/:/)
collection.each do |i| return nil if i == 3 ..many lines of code here.. end
collection = [1, 2, 3, 4, 5 ] stopped_at = collection.each do |i| break i if i == 3 puts "Processed end puts "Stopped at and did not process
collection.each do |i| break if i == 3 ...many lines end
class PagesController < ApplicationController def home end def about end def contact end end
class Page < ActiveRecord::Base attr_accessible :title, :content validates_presence_of :title, :content has_friendly_id :title, :use_slug => true, :approximate_ascii => true end
class PagesController < ApplicationController def show @page = Page.find(params[:id]) render end end
controller :pages do get :home get :about get :contact end
class PagesController < ApplicationController def show render params[:id] end end
class PagesController < ApplicationController def show begin render params[:id] rescue ActionView::MissingTemplate render :file => " end end end
string.start_with?("substring") string.end_with?("substring")
module MyModule def self.method_a(param) @var ||= 0 end end
module MyModule @species = "frog" @color = "red polka-dotted" @log = [] def self.log(msg) @log << msg end def self.show_log puts @log.map { |m| "A end end MyModule.log "I like cheese." MyModule.log "There MyModule.show_log
module MyModule @verb = "shouts" def self.show_log puts @log.map { |m| "A end end MyModule.log "What MyModule.show_log
module AppConfiguration mattr_accessor :google_api_key self.google_api_key = "123456789" ... end
module MyModule class << self; attr_accessor :var; end end MyModule.var => nil MyModule.var = => "this is saved at @var" MyModule.var => "this is saved at @var"
@shows = Show.find(:all, :order => "attending DESC") [
@shows = Show.find(:all, :order => "date, attending DESC")
@shows = Show.find(:all, :order => "date, attending ASC")
@shows = Show.find(:all, :order => "date ASC, attending DESC")
[4;35;1mUser Load (0.6ms)[0m [0mSELECT * FROM "users" WHERE ("users"."id" = 1) LIMIT 1[0m [4;36;1mShow Load (3.0ms)[0m [0;1mSELECT * FROM "shows" ORDER BY date ASC, attending DESC[0m [4;35;1mUser Load (0.6ms)[0m [0mSELECT * FROM "users" WHERE ("users"."id" = 1) [0m
create_table "shows", :force => true do |t| t.string "headliner" t.string "openers" t.string "venue" t.date "date" t.text "description" t.datetime "created_at" t.datetime "updated_at" t.decimal "price" t.time "showtime" t.integer "attending", :default => 0 t.string "time" end
@shows = Show.order("datetime(date) ASC, attending DESC")
/home/vmu/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activesupport-5.0.1/lib/active_support/xml_mini.rb:51: warning: constant ::Fixnum is deprecated /home/vmu/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activesupport-5.0.1/lib/active_support/xml_mini.rb:52: warning: constant ::Bignum is deprecated /home/vmu/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activesupport-5.0.1/lib/active_support/core_ext/numeric/conversions.rb:138: warning: constant ::Fixnum is deprecated Running via Spring preloader in process 3579 Expected string default value for invoke active_record identical db/migrate/20170104114702_create_books.rb identical app/models/book.rb invoke test_unit identical test/models/book_test.rb identical test/fixtures/books.yml
lambda { |x, x| 42 } lambda { |_, _| 42 }.call(4, 2) lambda { |_, _| 42 }.call(_, _) lambda { |_| _ + 1 }.call(42) lambda { |_, _| _ }.call(4, 2) _ = 42 _ * 100 _, _ = 4, 2; _
static ID shadowing_lvar_gen(struct parser_params *parser, ID name) { if (idUScore == name) return name;
static void warn_unused_var(struct parser_params *parser, struct local_vars *local) { for (i = 0; i < cnt; ++i) { if (!v[i] || (u[i] & LVAR_USED)) continue; if (idUScore == v[i]) continue; rb_compile_warn(ruby_sourcefile, (int)u[i], "assigned but unused variable - %s", rb_id2name(v[i])); } }
if (is_private_local_id(v[i])) continue; rb_warn4S(ruby_sourcefile, (int)u[i], "assigned but unused variable - %s", rb_id2name(v[i]));
if (name == idUScore) return 1; return RSTRING_PTR(s)[0] ==
@workspace.evaluate self, "_ = IRB.CurrentContext.last_value"
if (!uscore) uscore = rb_intern("_"); if (uscore == name) return;
BlueCloth: 13.029987s total time, 00.130300s average Maruku: 08.424132s total time, 00.084241s average RDiscount: 00.082019s total time, 00.000820s average
class String def valid_float? true if Float self rescue false end end
1.9.2p320 :001 > foo = "343" => "343" 1.9.2p320 :003 > goo = "fg5" => "fg5" 1.9.2p320 :002 > Integer(foo) rescue nil => 343 1.9.2p320 :004 > Integer(goo) rescue nil => nil 1.9.2p320 :005 > Float(foo) rescue nil => 343.0 1.9.2p320 :006 > Float(goo) rescue nil => nil
num = num == num.to_i.to_s num = num == num.to_i.to_s
def is_number? self.to_f == self end > 15.is_number? => true > 15.0.is_number? => true > => false > (0/0.0).is_number? => false
irb(main):005:0> 1.1.is_a? Numeric => true irb(main):006:0> 1.is_a? Numeric => true irb(main):007:0> => false
qichunren@zhaobak:~> gem install hpricot ERROR: While executing gem ... (Gem::FilePermissionError) You don
$ \curl -sSL https: $ rvm install ruby $ gem install $SOME_GEM_NAME
export RBENV_ROOT="$HOME/.rbenv" if [ -d $RBENV_ROOT ]; then export PATH="$RBENV_ROOT/bin:$PATH" eval "$(rbenv init -)" fi
require opts = GetoptLong.new( [ ) customParameter= opts.each do |opt, arg| case opt when customParameter=arg end end Vagrant.configure("2") do |config| ... config.vm.provision :shell do |s| s.args = " end end
$ vagrant --custom-option=option up $ vagrant --custom-option=option provision
options = {} options[:port_guest] = ARGV[1] || 8080 options[:port_host] = ARGV[2] || 8080 options[:port_guest] = Integer(options[:port_guest]) options[:port_host] = Integer(options[:port_host]) ARGV.delete_at(1) ARGV.delete_at(1) Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| config.vm.network :forwarded_port, guest: options[:port_guest], host: options[:port_host] config.vm.provision :shell, :path => "provision.sh", :args => "-g" + options[:port_guest].to_s + " -h" + options[:port_host].to_s
port_guest=8080 port_host=8080 while getopts ":g:h:" opt; do case "$opt" in g) port_guest="$OPTARG" ;; h) port_host="$OPTARG" ;; esac done
def find_ancestor_with_class(field, cssClass) ancestor = field loop do ancestor = ancestor.find(:xpath, break if ancestor.nil? break if ancestor.has_css? cssClass end ancestor end
*a, last = [1, 3, 4, 5] STDOUT: a: [1, 3, 4] last: 5
a = [ "d", "a", "e", "c", "b" ] a.sort a.sort { |x,y| y <=> x }
people.sort{|p1,p2| p1.age <=> p2.age} people.sort{|p1,p2| p1.children.count <=> p2.children.count}
1.9.3dev :001 > a = %w(d e a w f k) 1.9.3dev :003 > a.sort { |e1, e2| p [e2, e1]; e2 <=> e1 } ["w", "d"] ["k", "w"] ["k", "d"] ["k", "e"] ["k", "f"] ["k", "a"] ["f", "a"] ["d", "f"] ["d", "a"] ["d", "e"] ["e", "f"] => ["w", "k", "f", "e", "d", "a"]
[e2, e1] Comparsion Result Array State ["w", "d"] 1 ["w", "e", "a", "d", "f", "k"] ["k", "w"] -1 ["w", "e", "a", "d", "f", "k"] ["k", "d"] 1 ["w", "e", "a", "k", "f", "d"] ["k", "e"] 1 ["w", "k", "a", "e", "f", "d"] ["k", "f"] 1 ["w", "k", "a", "e", "f", "d"] ["k", "a"] 1 ["w", "k", "a", "e", "f", "d"] ["f", "a"] 1 ["w", "k", "f", "e", "a", "d"] ["d", "f"] -1 ["w", "k", "f", "e", "a", "d"] ["d", "a"] 1 ["w", "k", "f", "e", "d", "a"] ["d", "e"] -1 ["w", "k", "f", "e", "d", "a"] ["e", "f"] -1 ["w", "k", "f", "e", "d", "a"] (Result)
array.sort{|x, y| some_very_complicated_method(x, y) }
VALUE rb_ary_cmp(VALUE ary1, VALUE ary2) { long len; VALUE v; ary2 = rb_check_array_type(ary2); if (NIL_P(ary2)) return Qnil; if (ary1 == ary2) return INT2FIX(0); v = rb_exec_recursive_paired(recursive_cmp, ary1, ary2, ary2); if (v != Qundef) return v; len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2); if (len == 0) return INT2FIX(0); if (len > 0) return INT2FIX(1); return INT2FIX(-1); }
machine_bytes = [ machine_bits = machine_bytes * 8 machine_max_signed = 2**(machine_bits-1) - 1 machine_max_unsigned = 2**machine_bits - 1
FIXNUM_MAX = (2**(0.size * 8 -2) -1) FIXNUM_MIN = -(2**(0.size * 8 -2))
start = Time.now largest_known_fixnum = 1 smallest_known_bignum = nil until smallest_known_bignum == largest_known_fixnum + 1 if smallest_known_bignum.nil? next_number_to_try = largest_known_fixnum * 1000 else next_number_to_try = (smallest_known_bignum + largest_known_fixnum) / 2 end if next_number_to_try <= largest_known_fixnum || smallest_known_bignum && next_number_to_try >= smallest_known_bignum raise "Can end case next_number_to_try when Bignum then smallest_known_bignum = next_number_to_try when Fixnum then largest_known_fixnum = next_number_to_try else raise "Can end end finish = Time.now puts "The largest fixnum is puts "The smallest bignum is puts "Calculation took
class Fixnum N_BYTES = [42].pack( N_BITS = N_BYTES * 8 MAX = 2 ** (N_BITS - 2) - 1 MIN = -MAX - 1 end p(Fixnum::MAX)
fmax = ->{ if RUBY_PLATFORM == 2**63 - 1 else 2**(0.size * 8 - 2) - 1 end }.call p fmax.class fmax = fmax + 1 p fmax.class
module MyMod class Utils def self.find_x(myarg) end end end
allow(MyMod::Utils).to receive(:find_x).and_return({something:
2.1.5 :021 > => 0 2.1.5 :022 > => nil 2.1.5 :023 > => nil 2.1.5 :024 > => 0
sudo /etc/init.d/monit stop sudo monit start delayed_job
check process delayed_job with pidfile /var/app/shared/pids/delayed_job.pid start program = "/usr/bin/env RAILS_ENV=production /var/app/current/script/delayed_job start" stop program = "/usr/bin/env RAILS_ENV=production /var/app/current/script/delayed_job stop"
check process delayed_job with pidfile /var/www/app/shared/pids/delayed_job.pid start program = "/usr/bin/env PATH=$PATH:/usr/local/bin /var/www/app/current/script/delayed_job -e production start" stop program = "/usr/bin/env PATH=$PATH:/usr/local/bin /var/www/app/current/script/delayed_job -e production stop"
check process delayed_job with pidfile /var/app/shared/pids/delayed_job.pid start program = "/bin/su -c stop program = "/bin/su -c
case "$1" in start|stop|restart) DJ_CMD=$1 ;; *) echo "Usage: $0 {start|stop|restart}" exit esac su -c "cd /var/www/my_app/current && /usr/bin/env bin/delayed_job $DJ_CMD" - my_user
check process delayed_job with pidfile /var/www/my_app/shared/tmp/pids/delayed_job.pid start program = "/etc/init.d/delayed_job start" stop program = "/etc/init.d/delayed_job stop" if 5 restarts within 5 cycles then timeout
start() { echo "Starting $PROGNAME" sudo -u $USER /usr/bin/env HOME=$HOME RAILS_ENV=$RAILS_ENV $PROGNAME start } stop() { echo "Stopping $PROGNAME" sudo -u $USER /usr/bin/env HOME=$HOME RAILS_ENV=$RAILS_ENV $PROGNAME stop }
check process delayed_job with pidfile /home/user/app/shared/pids/delayed_job.pid start program = "/bin/sh -c stop program = "/bin/sh -c
<% @path = <% workers = 4 %> <% workers.times do |i| %> <% PIDFILE = "/mnt/custora- <%= "check process delayed_job. group delayed_job-<%= RUBBER_ENV %> <%= " start program = \"/bin/bash /mnt/ <%= " stop program = \"/bin/bash /mnt/ <% end %>
<% @path = "/mnt/ <%= "pid_file=/mnt/ if [ -e $pid_file ]; then pid=`cat $pid_file` if [ $2 == "start" ]; then ps -e | grep ^$pid if [ $? -eq 0 ]; then echo "already running $pid" exit fi rm $pid_file fi locked_by="delayed_job.$1 host:`hostname` pid:$pid" <%=" /usr/bin/mysql -e \"update delayed_jobs set locked_at = null, locked_by = null where locked_by= fi <%= "cd /mnt/ . /etc/profile <%= "RAILS_ENV=
check process delayed_job with pidfile /home/www1/your_app/current/tmp/pids/delayed_job.pid start program "/bin/bash -c stop program "/bin/bash -c if totalmem is greater than 200 MB for 2 cycles then alert
record = some_magic record.destroy record.is_destroyed?
attr_accessor :destroyed after_destroy :mark_as_destroyed def mark_as_destroyed self.destroyed = true end
record = Object.find(params[:id]) if record.destroy ... happy path else ... sad path end
irb(main):001:0> f = File.new("statements.xml", irb(main):002:0> f << Account.find(1).statements.to_xml irb(main):003:0> f.close
>> f = File.new(Rails.root + >> f << JSON.pretty_generate((q.get :customer, 1).as_json) >> f.close
if "irb" == $0 config.logger = Logger.new(Rails.root.join( end
ActiveRecord::Base.logger = Logger.new(Rails.root.join(
>> Hirb::View.render_method = lambda {|output| File.open("console.log", >> :blah => :blah >> Hirb::View.reset_render_method
cd $deploy_to/shared rm -rf cached-copy git clone ssh:
set :repository, "ssh: set :scm, :git set :deploy_via, :remote_cache
namespace :deploy do task :cope_with_git_repo_relocation do run "if [ -d end end before "deploy:update_code", "deploy:cope_with_git_repo_relocation"
cd /var/www/your-project/production/shared/cached-copy git remote remove origin git remote add origin git@bitbucket.org:/origin.git
desc "remove remote git cache repository" task :remove_git_cache_repo do on roles(:all) do execute "cd end end
namespace :deploy do desc task :fix_repo_origin do on roles(:web) do within repo_path do execute(:git, "remote set-url origin end end end end
[{"testPARAM1"=>"testVAL1"}, {"testPARAM2"=>"testVAL2"}]
{"testPARAM2"=>"testVAL2", "testPARAM1"=>"testVAL1"}
par={} mitem["params"].each { |h| h.each {|k,v| par[k]=v} }
input = [{"testPARAM1"=>"testVAL1"}, {"testPARAM2"=>"testVAL2"}] input.reduce({}, :merge) is {"testPARAM2"=>"testVAL2", "testPARAM1"=>"testVAL1"}
[{:a => 1}, {:b => 2}, {:c => 3}].reduce({}, :merge) is {}.merge({:a => 1}.merge({:b => 2}.merge({:c => 3}))) is {:a => 1, :b => 2, :c => 3}
h = [{"testPARAM1"=>"testVAL1"}, {"testPARAM2"=>"testVAL2"}] r = h.inject(:merge)
hashes = [{"testPARAM1"=>"testVAL1"}, {"testPARAM2"=>"testVAL2"}] merged = hashes.inject({}) { |aggregate, hash| aggregate.merge hash } merged
Theme.delete_all Theme.create(:id => 1, :name=> :component_theme_color=> :join_upper_gradient=> :cancel_link_color=> Theme.create(:id => 2, :name=> :component_theme_color=> :join_upper_gradient=> :cancel_link_color=> Theme.create(:id => 3, :name=> :component_theme_color=> :join_upper_gradient=> :cancel_link_color=> puts "Success: Theme data loaded"
Factory.define :theme do |t| t.background_color t.title_text_color t.component_theme_color t.carrier_select_color t.label_text_color t.join_upper_gradient t.join_lower_gradient t.join_text_color t.cancel_link_color t.border_color t.carrier_text_color t.public true end Factory(:theme, :id => 1, :name => "Lite", :background_color => Factory(:theme, :id => 2, :name => "Metallic", :background_color => Factory(:theme, :id => 3, :name => "Blues", :background_color =>
100.times do Factory(:company, :address => Factory(:address), :employees => [Factory(:employee)]) end
rake db:seed rake db:seed:bar rake db:seed:common rake db:seed:development rake db:seed:development:users rake db:seed:foo rake db:seed:original
ex="test1,test2,test3,test4,test5" all_but_first=ex.split(/,/)[1..-1]
parameter1,parameter2,parameter3,parameter4,parameter5 = ex.split(",")
ex="test1, test2, test3, test4, test5" ex.split(",").drop(1).join(",") => "test2,test3,test4,test5"
String is ex="test1, test2, test3, test4, test5" array = ex.split(/,/) array.size.times do |i| p array[i] end
proc { bar.do_it }.must_raise RuntimeError.new("Foo")
it "must raise" do assert_raises RuntimeError do bar.do_it end -> { bar.do_it }.must_raise RuntimeError lambda { bar.do_it }.must_raise RuntimeError proc { bar.do_it }.must_raise RuntimeError end
describe "testing the error object" do it "as an assertion" do err = assert_raises RuntimeError { bar.do_it } assert_match /Foo/, err.message end it "as an exception" do err = ->{ bar.do_it }.must_raise RuntimeError err.message.must_match /Foo/ end end
exception = assert_raises FooError do bar.do_it end assert_equal(
class ActiveSupport::TestCase def assert_raises_with_message(exception, msg, &block) block.call rescue exception => e assert_match msg, e.message else raise "Expected to raise end end
assert_raises_with_message RuntimeError, code_that_raises_RuntimeError_with_Foo_message end
if mystring.eql?(yourstring) puts "same" else puts "different" end
def my_method(width, height, show_border) my_method(400, 50, false)
def my_method(options) my_method({"width" => 400, "height" => 50, "show_border" => false})
def my_method(options = {}) my_method(:width => 400, :height => 50, :show_border => false)
my_method( width: 400, height: 50, show_border: false )
# def create_box(options={}) options[:show_border] ||= false end
# def create_box(width, height, show_border=false) end
def myfactory(otype, *args) if otype == "obj1" myobj1(*args) elsif otype == "obj2" myobj2(*args) else puts("unknown object") end end def myobj1(arg11) puts("this is myobj1 end def myobj2(arg21, arg22) puts("this is myobj2 end
class Example def initialize(args = {}) @code code = args[:code] @code = args.fetch(:code) begin @code = args.fetch(:code) rescue @code = 0 end end
[tim@ ~] ruby 1.8.7 (2010-01-10 patchlevel 249) [i686-darwin10.2.0] [tim@ ~] 1.3.6 [tim@ ~] RubyGems Environment: - RUBYGEMS VERSION: 1.3.6 - RUBY VERSION: 1.8.7 (2010-01-10 patchlevel 249) [i686-darwin10.2.0] - INSTALLATION DIRECTORY: /usr/local/lib/ruby/gems/1.8 - RUBY EXECUTABLE: /usr/local/bin/ruby - EXECUTABLE DIRECTORY: /usr/local/bin - RUBYGEMS PLATFORMS: - ruby - x86-darwin-10 - GEM PATHS: - /usr/local/lib/ruby/gems/1.8 - /Users/tim/.gem/ruby/1.8 - GEM CONFIGURATION: - :update_sources => true - :verbose => true - :benchmark => false - :backtrace => false - :bulk_threshold => 1000 - :sources => ["http: - REMOTE SOURCES: - http: - http: [tim@ ~] /usr/local/bin/ruby [tim@ ~] /usr/local/bin/gem [tim@ ~] Darwin tim-hoolihans-macbook-pro-15.local 10.2.0 Darwin Kernel Version 10.2.0: Tue Nov 3 10:37:10 PST 2009; root:xnu-1486.2.11~1/RELEASE_I386 i386 [tim@ ~]
/home/chance/.rvm/gems/ruby-1.9.2-p180@global/gems/railties-3.0.5/lib/rails/script_rails_loader.rb:11: warning: Insecure world writable dir /home/chance in PATH, mode 040777 /home/chance/.rvm/gems/ruby-1.9.2-p180@global/gems/bundler-1.0.10/lib/bundler/runtime.rb:136: warning: Insecure world writable dir /home/chance in PATH, mode 040777 Rails 3.0.5
/home/chance/.rvm/rubies/ruby-1.9.2-p180/bin/gem:4: warning: Insecure world writable dir /home/chance in PATH, mode 040777 1.6.2
source gem gem gem gem "haml" gem "formtastic" gem "will_paginate" gem "devise" gem "delayed_job" gem "whenever" gem "memcache-client" gem "capistrano" group :testing do gem "rspec" gem "rspec-rails" gem "autotest-standalone" gem "autotest-rails" gem "autotest-growl" gem "mocha" gem "shoulda" gem "factory_girl_rails" end group :development do gem "cheat" gem "bullet" gem "ruby-growl" end
warning: Insecure world writable dir /usr/local in PATH, mode 040777
Permissions differ on “usr”; should be drwxr-xr-x ; they are drwxrwxrwx. Repaired “usr”
# def which(cmd) exts = ENV[ ENV[ exts.each { |ext| exe = File.join(path, " return exe if File.executable?(exe) && !File.directory?(exe) } end return nil end
require def set_mkmf_log(logfile=File::NULL) MakeMakefile::Logging.instance_variable_set(:@logfile, logfile) end def which(cmd) old_mkmf_log = MakeMakefile::Logging.instance_variable_get(:@logfile) set_mkmf_log(nil) path_to_cmd = find_executable0(cmd) set_mkmf_log(old_mkmf_log) path_to_cmd end
def has_program?(program) ENV[ File.executable?(File.join(directory, program.to_s)) end end
# # # def which(cmd) raise ArgumentError.new("Argument not a string: return nil if cmd.empty? case RbConfig::CONFIG[ when /cygwin/ exts = nil when /dos|mswin|^win|mingw|msys/ pathext = ENV[ exts = pathext ? pathext.split( else exts = nil end if cmd[File::SEPARATOR] or (File::ALT_SEPARATOR and cmd[File::ALT_SEPARATOR]) if exts ext = File.extname(cmd) if not ext.empty? and exts.any?{ |e| e.casecmp(ext).zero? } \ and File.file?(cmd) and File.executable?(cmd) return File.absolute_path(cmd) end exts.each do |ext| exe = " return File.absolute_path(exe) if File.file?(exe) and File.executable?(exe) end else return File.absolute_path(cmd) if File.file?(cmd) and File.executable?(cmd) end else paths = ENV[ paths = paths ? paths.split(File::PATH_SEPARATOR).select{ |e| File.directory?(e) } : [] if exts ext = File.extname(cmd) has_valid_ext = (not ext.empty? and exts.any?{ |e| e.casecmp(ext).zero? }) paths.unshift( if has_valid_ext exe = File.join(path, " return File.absolute_path(exe) if File.file?(exe) and File.executable?(exe) end exts.each do |ext| exe = File.join(path, " return File.absolute_path(exe) if File.file?(exe) and File.executable?(exe) end end else paths.each do |path| exe = File.join(path, cmd) return File.absolute_path(exe) if File.file?(exe) and File.executable?(exe) end end end nil end
def command?(name) [name, *ENV[ ].find {|f| File.executable?(f)} end
irb(main):043:0> command?("/bin/bash") => "/bin/bash" irb(main):044:0> command?("bash") => "/bin/bash" irb(main):006:0> command?("bush") => nil
require def is_windows? Config::CONFIG["host_os"] =~ /mswin|mingw/ end def exists_in_path?(file) entries = ENV[ entries.any? {|f| File.exists?(" end
main » unix_process = java.lang.Runtime.getRuntime().exec("git status") => main » unix_process.exitValue() => 0 main »
class File class << self def cmd_executable?(cmd) !ENV[ end end end
def cmdExists?(c) system(c + " > /dev/null") return false if $?.exitstatus == 127 true end
-T, --tasks [PATTERN] Display the tasks (matching optional PATTERN) with descriptions, then exit. -A, --all Show all tasks, even uncommented ones (in combination with -T or -D)
Dir[File.join(Rails.root, "lib", "core_ext", "*.rb")].each {|l| require l }
[:foo, :bar, :baz].each.with_index(2) do |value, index| puts " end [:foo, :bar, :baz].each_with_index do |value, index| puts " end
@assigned_tasks = @user.assigned_tasks @created_tasks = @user.created_tasks @created_not_doing_tasks = Array.new @created_tasks.each do |task| unless @assigned_tasks.include?(task) @created_not_doing_tasks << task end end
class Array def delete_elements_in(ary) ary.each do |x| if index = index(x) delete_at(index) end end end end
irb(main):198:0> a = [ 1, 1, 2, 2, 3, 3, 4, 5 ] => [1, 1, 2, 2, 3, 3, 4, 5] irb(main):199:0> b = [ 1, 2, 4 ] => [1, 2, 4] irb(main):200:0> a.delete_elements_in(b) => [1, 2, 4] irb(main):201:0> a => [1, 2, 3, 3, 5]
if ARGV.length != 2 then puts "Usage: <command> arg1 arg2" end
$ ./test.rb $0 : ./test.rb __FILE__ : ./test.rb $PROGRAM_NAME : ./test.rb $ ~/Desktop/test.rb $0 : /Users/ttm/Desktop/test.rb __FILE__ : /Users/ttm/Desktop/test.rb $PROGRAM_NAME : /Users/ttm/Desktop/test.rb $ /Users/ttm/Desktop/test.rb $0 : /Users/ttm/Desktop/test.rb __FILE__ : /Users/ttm/Desktop/test.rb $PROGRAM_NAME : /Users/ttm/Desktop/test.rb
$ ./test1.rb $0 : ./test1.rb __FILE__ : ./test1.rb $PROGRAM_NAME : ./test1.rb $ ./test2.rb $0 : ./test2.rb __FILE__ : ./test2.rb $PROGRAM_NAME : ./test2.rb
ruby-1.9.2-p136 :004 > filename = => "/path/to/file/name.ext" ruby-1.9.2-p136 :005 > File.basename(filename, File.extname(filename)) => "name" ruby-1.9.2-p136 :006 > filename = => "/path/to/file/name.ext.txt" ruby-1.9.2-p136 :007 > File.basename(filename, File.extname(filename)) => "name.ext"
extern char** environ; int main() { char ** arr = malloc(10 * sizeof(char*)); arr[0] = "myscript"; arr[1] = "-h"; arr[2] = NULL; execve("/home/danyel/bin/myscript", arr, environ); }
int main(int argc, const char ** argv) { while(*argv) printf("%s\n", *(argv++)); }
extern char** environ; int main() { char ** arr = malloc(10 * sizeof(char*)); arr[0] = "This will be totally ignored by execve."; arr[1] = "-v"; arr[2] = "/var/log/apache2.log"; arr[3] = NULL; execve("/home/danyel/bin/myscript", arr, environ); }
desc "Importer statistikker" namespace :reklamer do task :iqmedier => :environment do ... end task :euroads => :environment do ... end task :mikkelsen => :environment do ... end task :orville => :environment do ... end end
task :runall => [:iqmedier, :euroads, :mikkelsen, :orville ] do end
require "rake" YourApp::Application.load_tasks Rake::Task["Namespace:task"].invoke
task :all => [:iqmedier, :euroads, :mikkelsen, :orville ] do end
class ApplicationController < ActionController::Base helper :all . . end
def controller_action @price = view_context.number_to_currency( 42.0 ) end def controller_action @price = @template.number_to_currency( 42.0 ) end
class ApplicationController < ActionController::Base helper_method :my_shared_method ... def my_shared_method end end
include LoginHelper cool_login_helper_method(x,y,z)
login_helper = Object.new.extend(LoginHelper) login_helper.cool_login_helper_method(x,y,z)
class Something include Singleton include ActionView::Helpers::UrlHelper end
class FooController < ActionController::Base def action self.class.helpers.helper_method arg end end
include ApplicationHelper def message hello_message end
module PostsHelper def find_category(number) return end def find_other_sport(number) "basketball" end end module ApplicationHelper def check_this_sentence end end
class ArticlesController < ApplicationController include ApplicationHelper include PostsHelper def show add_breadcrumb find_other_sport(@articles.type_activite), articles_path, :title => "Back to the Index" respond_with(@articles) end end
class ApplicationController < ActionController::Base protect_from_forgery with: :exception include SessionsHelper end
map.connect def show render :action => params[:path].join( end
render :template => params[:path] render :file => params[:path], :layout => true
class StaticController < ApplicationController layout caches_page :show def show valid = %w(static1 static2 static3) if valid.include?(params[:path]) render :template => File.join( else render :file => File.join(Rails.root, :status => 404 end end end
class HomesController < ApplicationController def show end def privacy end def aboutus end end
map.root :controller => "homes", :action => "show" map.aboutus "/aboutus", :controller => "homes", :action => "aboutus" map.privacy "/privacy", :controller => "homes", :action => "privacy"
app/views/homes/aboutus.html.erb --> you get http: app/views/homes/show.html.erb --> you get http: app/views/homes/privacy.html.erb --> you get http:
<%= cache "site-page- <%= render :partial => @page_name %> <% end %>
$ gem install therubyracer Building native extensions. This could take a while... ERROR: Error installing therubyracer: ERROR: Failed to build gem native extension. /Users/david/.rvm/rubies/ruby-1.9.3-p194/bin/ruby extconf.rb checking for main() in -lobjc... yes *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options. Provided configuration options: --with-opt-dir --with-opt-include --without-opt-include=${opt-dir}/include --with-opt-lib --without-opt-lib=${opt-dir}/lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=/Users/david/.rvm/rubies/ruby-1.9.3-p194/bin/ruby --with-objclib --without-objclib extconf.rb:15:in `<main>
gem uninstall libv8 brew install v8 gem install therubyracer
probably lack of necessary libraries and/or headers
gem uninstall libv8 brew install v8 gem install libv8 -- --with-system-v8 gem install therubyracer -v
bundler_args: --binstubs=./bundler_stubs --without development
validates :n, numericality: {only_integer: true, greater_than_or_equal_to: 1, less_than_or_equal_to: 10}
validates_inclusion_of :number, :in => start_number..end_number
validates :number, :inclusion => start_number..end_number
validates_numericality_of :tax_rate, greater_than_or_equal_to: 0, less_than_or_equal_to: 1, message:
require "highline/import" input = ask "Input text: "
def prompt(*args) print(*args) gets end name = prompt "Input name: "
def prompt(default, *args) print(*args) result = gets.strip return result.empty? ? default : result end
require def input(prompt="", newline=false) prompt += "\n" if newline Readline.readline(prompt, true).squeeze(" ").strip end
array = [1, 3, 5 , 6 ,7] array[0], array[1] = array[1] , array[0]
a, b, c = not_an_ary ary = not_an_ary.to_ary a = ary[0] b = ary[1] c = ary[2]
a, b, c = d, e, f ary = [d, e, f] a = ary[0] b = ary[1] c = ary[2]
a, b, *c = ary a = ary[0] b = ary[1] c = ary.drop(2)
a, (b, c), d = ary a = ary[0] b, c = ary[1] d = ary[2] a = ary[0] b = ary[1][0] c = ary[1][1] d = ary[2]
return 1, 2 next 1, 2 break 1, 2 yield 1, 2 return [1, 2] next [1, 2] break [1, 2] yield [1, 2]
def foo(a, (b, c), d) p a, b, c, d end bar {|a, (b, c), d| p a, b, c, d }
def make_hash x = 1 y = 2 {:x => x, :y => y} end hash = make_hash hash[:x] hash[:y]
a = "hello" def a.informal "hi" end a.informal => "hi"
class Greeting def self.say_hello "Hello" end def Greeting.informal "hi" end end
class HexHelper def self.to_h(num) sprintf("%x", num) end end use: HexHelper.to_h(12345)
public class HexHelper { public static String toHex(int num) { return new PrintfFormat("%x").sprintf(num); } } use: HexHelper.toHex(12345)
irb(main):001:0> require => true irb(main):002:0> Digest::MD5.hexdigest( => "3858f62230ac3c915f300c664312c63f"
Your Ruby version is 1.9.3, but your Gemfile specified 2.0.0
ruby gem group :development do gem end gem gem gem gem gem gem group :doc do gem end
› rvm current ruby-2.1.1 › heroku --version heroku-toolbelt/3.26.1 (x86_64-darwin10.8.0) ruby/1.9.3
mv ~/.heroku ~/.Trash sudo mv /usr/local/heroku ~/.Trash sudo mv /usr/bin/heroku ~/.Trash
sudo apt-get update && sudo apt-get upgrade sudo apt-get install ruby2.1 ruby2.1-dev sudo ruby-switch --set ruby2.1 sudo gem install bundler
require p DateTime.now.strftime( p DateTime.now.strftime(
irb(main):019:0> t=Time.now => 2015-04-10 16:41:35 -0500 irb(main):020:0> puts " 1428702095.1435847; 143584844
2.2.2 :001 > t = Time.new => 2015-06-02 12:16:56 -0700 2.2.2 :002 > t.strftime( => "1433272616888"
2.2.2 :003 > t.to_f => 1433272616.888615 2.2.2 :004 > t.usec => 888615
2.2.2 :010 > (t.to_f * 1000).round => 1433272616889
2.2.2 :011 > (t.to_r * 1000).round => 1433272616889
$ ri IO.noecho (from ruby core) ------------------------------------------------------------------------------ io.noecho {|io| } ------------------------------------------------------------------------------ Yields self with disabling echo back. STDIN.noecho(&:gets) will read and return a line without echo back.
require require password = ask("Enter password: ") { |q| q.echo = false }
begin require rescue LoadError end if STDIN.respond_to?(:noecho) def get_password(prompt="Password: ") print prompt STDIN.noecho(&:gets).chomp end else def get_password(prompt="Password: ") `read -s -p " end end
@password = get_password("Enter your password here: ")
def get_password(prompt="Password: ") `read -s -p end
require def get_password(prompt="Password: ") new_sigint = new_sigtstp = new_sigcont = nil old_sigint = old_sigtstp = old_sigcont = nil term = `stty -g`.chomp `stty -echo` new_sigint = Proc.new do `stty trap("SIGINT", old_sigint) Process.kill("SIGINT", Process.pid) end new_sigtstp = Proc.new do `stty trap("SIGCONT", new_sigcont) trap("SIGTSTP", old_sigtstp) Process.kill("SIGTSTP", Process.pid) end new_sigcont = Proc.new do `stty -echo` trap("SIGCONT", old_sigcont) trap("SIGTSTP", new_sigtstp) Process.kill("SIGCONT", Process.pid) end old_sigint = trap("SIGINT", new_sigint) || "DEFAULT" old_sigtstp = trap("SIGTSTP", new_sigtstp) || "DEFAULT" old_sigcont = trap("SIGCONT", new_sigcont) || "DEFAULT" print prompt password = STDIN.gets.chomp puts password ensure `stty trap("SIGINT", old_sigint) trap("SIGTSTP", old_sigtstp) trap("SIGCONT", old_sigcont) end
userid = `read -p "User Name: " uid; echo $uid`.chomp passwd = `read -s -p "Password: " password; echo $password`.chomp
Dog.find(:all).each do |dog| dog.owner.siblings.each do |sibling| sibling.pets.each do |pet| end end end
Dog.find(:all).each do |dog| dog.owner.siblings.each do |sibling| sibling.pets.each do |pet| end end end
Dog.Owners.Include() Dog.Owners.Siblings.Include() Dog.Owners.Siblings.Pets.Include()
require workbook = RubyXL::Parser.parse worksheets = workbook.worksheets puts "Found worksheets.each do |worksheet| puts "Reading: num_rows = 0 worksheet.each do |row| row_cells = row.cells.map{ |cell| cell.value } num_rows += 1 end puts "Read end
require workbook = Roo::Spreadsheet.open worksheets = workbook.sheets puts "Found worksheets.each do |worksheet| puts "Reading: num_rows = 0 workbook.sheet(worksheet).each_row_streaming do |row| row_cells = row.map { |cell| cell.value } num_rows += 1 end puts "Read end
require workbook = Creek::Book.new worksheets = workbook.sheets puts "Found worksheets.each do |worksheet| puts "Reading: num_rows = 0 worksheet.rows.each do |row| row_cells = row.values num_rows += 1 end puts "Read end
require workbook = SimpleXlsxReader.open worksheets = workbook.sheets puts "Found worksheets.each do |worksheet| puts "Reading: num_rows = 0 worksheet.rows.each do |row| row_cells = row num_rows += 1 end puts "Read end
require workbook = Spreadsheet.open worksheets = workbook.worksheets puts "Found worksheets.each do |worksheet| puts "Reading: num_rows = 0 worksheet.rows.each do |row| row_cells = row.to_a.map{ |v| v.methods.include?(:value) ? v.value : v } num_rows += 1 end puts "Read end
class Spreadsheet def initialize(file_path) @xls = Roo::Spreadsheet.open(file_path) end def each_sheet @xls.sheets.each do |sheet| @xls.default_sheet = sheet yield sheet end end def each_row 0.upto(@xls.last_row) do |index| yield @xls.row(index) end end def each_column 0.upto(@xls.last_column) do |index| yield @xls.column(index) end end end
require require count = 0 Find.find( if file =~ /\b.xlsx$\b/ workbook = RubyXL::Parser.parse(file).worksheets workbook.each do |worksheet| data = worksheet.extract_data.to_s if data =~ /regex/ puts file count += 1 end end end end puts "
require require Spreadsheet.client_encoding = count = 0 Find.find( if file =~ /\b.xls$\b/ workbook = Spreadsheet.open(file).worksheets workbook.each do |worksheet| worksheet.each do |row| if row.to_s =~ /regex/ puts file count += 1 end end end end end puts "
Spreadsheet.open(file_path).worksheets.first.rows do |row| end
require r = RemoteTable.new r.each do |row| puts row.inspect end
{"Class"=>"TWO SEATERS", "Manufacturer"=>"ACURA", "carline name"=>"NSX", "displ"=>"3.0", "cyl"=>"6.0", "trans"=>"Auto(S4)", "drv"=>"R", "bidx"=>"60.0", "cty"=>"17.0", "hwy"=>"24.0", "cmb"=>"20.0", "ucty"=>"19.1342", "uhwy"=>"30.2", "ucmb"=>"22.9121", "fl"=>"P", "G"=>"", "T"=>"", "S"=>"", "2pv"=>"", "2lv"=>"", "4pv"=>"", "4lv"=>"", "hpv"=>"", "hlv"=>"", "fcost"=>"1238.0", "eng dscr"=>"DOHC-VTEC", "trans dscr"=>"2MODE", "vpc"=>"4.0", "cls"=>"1.0"} {"Class"=>"TWO SEATERS", "Manufacturer"=>"ACURA", "carline name"=>"NSX", "displ"=>"3.2", "cyl"=>"6.0", "trans"=>"Manual(M6)", "drv"=>"R", "bidx"=>"65.0", "cty"=>"17.0", "hwy"=>"24.0", "cmb"=>"19.0", "ucty"=>"18.7", "uhwy"=>"30.4", "ucmb"=>"22.6171", "fl"=>"P", "G"=>"", "T"=>"", "S"=>"", "2pv"=>"", "2lv"=>"", "4pv"=>"", "4lv"=>"", "hpv"=>"", "hlv"=>"", "fcost"=>"1302.0", "eng dscr"=>"DOHC-VTEC", "trans dscr"=>"", "vpc"=>"4.0", "cls"=>"1.0"} {"Class"=>"TWO SEATERS", "Manufacturer"=>"ASTON MARTIN", "carline name"=>"ASTON MARTIN VANQUISH", "displ"=>"5.9", "cyl"=>"12.0", "trans"=>"Auto(S6)", "drv"=>"R", "bidx"=>"1.0", "cty"=>"12.0", "hwy"=>"19.0", "cmb"=>"14.0", "ucty"=>"13.55", "uhwy"=>"24.7", "ucmb"=>"17.015", "fl"=>"P", "G"=>"G", "T"=>"", "S"=>"", "2pv"=>"", "2lv"=>"", "4pv"=>"", "4lv"=>"", "hpv"=>"", "hlv"=>"", "fcost"=>"1651.0", "eng dscr"=>"GUZZLER", "trans dscr"=>"CLKUP", "vpc"=>"4.0", "cls"=>"1.0"}
class Klass def hello(*args) "Hello " + args.join( end end k = Klass.new k.send :hello, "gentle", "readers"
c = Car.new c.make="Honda" c.model="CRV" c.year="2014"
c.send("make=", "Honda") c.send("model=", "CRV") c.send("year=","2014")
c = Car.new() params.each do |key, value| c.send(" end
atts = [ @project = Project.first atts.each do |a| puts @project.a end
atts = [ @project = Project.first atts.each do |a| puts @project.send(a) end
<%= link_to send("first_part_of_path_{some_dynamic_parameters}_end_path", attr1, attr2), .... %>
@powershell -NoProfile -ExecutionPolicy unrestricted -Command "iex ((new-object net.webclient).DownloadString(
choco install ruby -y refreshenv gem install bundler
"Installing requirements for debian, might require sudo password."
$ rvm autolibs disable $ rvm requirements $ rvm install ruby
$ rvm autolibs fail $ rvm install ruby Searching for binary rubies, this might take some time. Found remote file https: Checking requirements for ubuntu. Missing required packages: gawk g++ gcc make libreadline6-dev zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 autoconf libgdbm-dev libncurses5-dev automake libtool bison pkg-config libffi-dev RVM autolibs is now configured with mode please run `rvm autolibs enable` to let RVM do its job or run and read `rvm autolibs [help]` or visit https: Requirements installation failed with status: 1.
rvm get 1.18.8 rvm install <whichever-version-you-want>
@suggested_horses = [] @suggested_horses << Horse.find(:first,:offset=>rand(Horse.count)) while @suggested_horses.length < 8 horse = Horse.find(:first,:offset=>rand(Horse.count)) unless @suggested_horses.exists?(horse.id) @suggested_horses<< horse end end
unless @suggested_horses.include?(horse) @suggested_horses << horse end
unless @suggested_horses.any? {|h| h.id == horse.id } @suggested_horses << horse end
offsets = (0...Horse.count).to_a.sample(8) @suggested_horses = offsets.map{|i| Horse.first(:offset => i) }
unless @suggested_horses.exists?(horse.id) @suggested_horses<< horse end
unless @suggested_horses.include?(horse) @suggested_horses << horse end
@suggested_horses = [] @suggested_horses << Horse.first(:offset => rand(Horse.count)) while @suggested_horses.length < 8 horse = Horse.first(:offset => rand(Horse.count)) @suggested_horses << horse unless @suggested_horses.include?(horse) end
hash = {} hash[ hash[ hash hash[ hash require ary = [].to_set ary << ary << ary ary << ary
require require ALPHABET = ( N = 100_000 Benchmark.bm(5) do |x| x.report( N.times { h = {} ALPHABET.each { |i| h[i] = nil } } } x.report( N.times { a = Set.new ALPHABET.each { |i| a << i } } } end
user system total real Hash 8.140000 0.130000 8.270000 ( 8.279462) Array 10.680000 0.120000 10.800000 ( 10.813385)
horse = Horse.find(:first,:offset=>rand(Horse.count)) unless @suggested_horses.exists?(horse.id) @suggested_horses<< horse end
horse = Horse.find(:first,:offset=>rand(Horse.count)) unless @suggested_horses.include?(horse) @suggested_horses<< horse end
A = [1 , "string", [1,2,3]] B = [[1,2,3] , "string", 1] (A-B).blank? and (B-A).blank? => true
require require a = [1, 2, 3, 4, 5, 6] b = [1, 2, 3, 4, 5, 6] Benchmark.ips do |x| x.report( x.report( x.report( x.report( end Warming up -------------------------------------- sort 88.338k i/100ms sort! 118.207k i/100ms to_set 19.339k i/100ms minus 67.971k i/100ms Calculating ------------------------------------- sort 1.062M (± 0.9%) i/s - 5.389M in 5.075109s sort! 1.542M (± 1.2%) i/s - 7.802M in 5.061364s to_set 200.302k (± 2.1%) i/s - 1.006M in 5.022793s minus 783.106k (± 1.5%) i/s - 3.942M in 5.035311s
class Array def frequency p = Hash.new(0) each{ |v| p[v] += 1 } p end end [:a, :b].frequency == [:a, :a, :b].frequency [:a, :b].frequency == [:b, :a].frequency
add_foreign_key :users, :memberships, on_delete: :nullify
add_foreign_key :users, :memberships, on_delete: :cascade
create_table :orders do |t| t.column :customer_id, :integer, :on_delete => :set_null, :on_update => :cascade ... end
/Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:60:in `require from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:60:in `rescue in require' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:35:in `require' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/lib/compass/sass_extensions/monkey_patches/browser_support.rb:1:in `<top (required)>' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/lib/compass/sass_extensions/monkey_patches.rb:2:in `block in <top (required)>' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/lib/compass/sass_extensions/monkey_patches.rb:1:in `each' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/lib/compass/sass_extensions/monkey_patches.rb:1:in `<top (required)>' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/lib/compass/sass_extensions.rb:9:in `<top (required)>' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/lib/compass.rb:5:in `block in <top (required)>' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/lib/compass.rb:4:in `each' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/lib/compass.rb:4:in `<top (required)>' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require' from /Users/sampurcell/.rvm/rubies/ruby-1.9.3-p194/lib/ruby/site_ruby/1.9.1/rubygems/custom_require.rb:55:in `require' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/bin/compass:20:in `block in <top (required)>' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/bin/compass:8:in `fallback_load_path' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/gems/compass-0.12.2/bin/compass:19:in `<top (required)>' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/bin/compass:19:in `load' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/bin/compass:19:in `<main>' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/bin/ruby_noexec_wrapper:14:in `eval' from /Users/sampurcell/.rvm/gems/ruby-1.9.3-p194/bin/ruby_noexec_wrapper:14:in `<main>'
gem install compass --pre gem install sass -v 3.3.3
start = now.milliseconds myfunction() end = now.milliseconds time = end - start
require "benchmark" puts(Benchmark.measure { sleep 0.5 })
t1 = Process.clock_gettime(Process::CLOCK_MONOTONIC) sleep 1.5 t2 = Process.clock_gettime(Process::CLOCK_MONOTONIC) delta = t2 - t1 delta_in_milliseconds = delta * 1000
def time now = Time.now.to_f yield endd = Time.now.to_f endd - now end
date1 = Time.now.to_f date2 = Time.now.to_f diff = date2 - date1
t = Time.now user.calculate_report puts Time.now - t
array = array.sort_by {|k,v| v}.reverse puts hash[0]["key"]
class Booking < ActiveRecord::Base has_many :booking_payments .... def destroy raise "Cannot delete booking with payments" unless booking_payments.count == 0 super end end
def before_destroy return true if booking_payments.count == 0 errors.add :base, "Cannot delete booking with payments" false throw(:abort) end
class Booking < ActiveRecord::Base before_destroy :booking_with_payments? private def booking_with_payments? errors.add(:base, "Cannot delete booking with payments") unless booking_payments.count == 0 errors.blank? end
before_destroy do cannot_delete_with_qrcodes throw(:abort) if errors.present? end def cannot_delete_with_qrcodes errors.add(:base, end
def destroy if (model.valid_destroy?) model.destroy end end
class ActiveRecord::Base def can_destroy? self.class.reflect_on_all_associations.all? do |assoc| assoc.options[:dependent] != :restrict || (assoc.macro == :has_one && self.send(assoc.name).nil?) || (assoc.macro == :has_many && self.send(assoc.name).empty?) end end end
class Enterprise < AR::Base has_many :products before_destroy :enterprise_with_products? private def empresas_with_portafolios? self.portafolios.empty? end end class Product < AR::Base belongs_to :enterprises end
class ApplicationRecord < ActiveRecord::Base before_destroy do throw :abort if invalid?(:destroy) end end
class Ticket < ApplicationRecord validate :validate_expires_on, on: :destroy def validate_expires_on errors.add :expires_on if expires_on > Time.now end end
var = var||1 puts var var = var||2 puts var CONST = CONST||1 puts CONST CONST = CONST||2 puts CONST => 1 1 uninitialized constant CONST (NameError)
execute(%Q[ INSERT INTO table_a (column_a) SELECT value FROM table_b WHERE key= ])
cap aborted! undefined method `execute /Users/Justin/Dropbox/xxxx/xxxx/xxxx/Capfile:45:in `block (2 levels) in <top (required)>' /Users/Justin/.rvm/gems/ruby-2.0.0-p247/bundler/gems/capistrano-2dc1627838f9/lib/capistrano/application.rb:12:in `run' /Users/Justin/.rvm/gems/ruby-2.0.0-p247/bundler/gems/capistrano-2dc1627838f9/bin/cap:3:in `<top (required)>' /Users/Justin/.rvm/gems/ruby-2.0.0-p247/bin/cap:23:in `load' /Users/Justin/.rvm/gems/ruby-2.0.0-p247/bin/cap:23:in `<main>' /Users/Justin/.rvm/gems/ruby-2.0.0-p247/bin/ruby_noexec_wrapper:14:in `eval' /Users/Justin/.rvm/gems/ruby-2.0.0-p247/bin/ruby_noexec_wrapper:14:in `<main>' Tasks: TOP => deploy:do_something
task :execute_on_server do on "root@example.com" do execute "some_command" end end
role :mailserver, "root@mail.example.com" task :check_mail do on roles(:mailserver) do execute "some_command" end end
send_data(_data_, options = {}) send_file(_path_, options = {})
data = "Hello World!" send_data( data, :filename => "my_file.txt" )
data = "Hello World!" file = "my_file.txt" File.open(file, "w"){ |f| f << data } send_file( file )
data = "Hello World!" file = "my_file.txt" File.open(file, "w"){ |f| f << data } send_data( data )
Client <---> Internet <---> Reverse proxy <---> Rails
config.action_dispatch.x_sendfile_header = "X-Sendfile" config.action_dispatch.x_sendfile_header =
module WithYield def self.thrice 3.times { yield } end end module WithProcCall def self.thrice(&block) 3.times { block.call } end end WithYield::thrice { puts "Hello world" } WithProcCall::thrice { puts "Hello world" }
require class A def test 10.times do yield end end end class B def test(&block) 10.times do block.call end end end Benchmark.bm do |b| b.report do a = A.new 10000.times do a.test{ 1 + 1 } end end b.report do a = B.new 10000.times do a.test{ 1 + 1 } end end b.report do a = A.new 100000.times do a.test{ 1 + 1 } end end b.report do a = B.new 100000.times do a.test{ 1 + 1 } end end end
user system total real 0.090000 0.040000 0.130000 ( 0.141529) 0.180000 0.060000 0.240000 ( 0.234289) 0.950000 0.370000 1.320000 ( 1.359902) 1.810000 0.570000 2.380000 ( 2.430991)
require class YieldCallProc include Benchable def initialize @count = 10000000 end def bench_yield @count.times { yield } end def bench_call &block @count.times { block.call } end def bench_proc &block @count.times &block end end YieldCallProc.new.benchmark
> WithYield::thrice LocalJumpError: no block given from (irb):3:in `thrice' from (irb):3:in `times' from (irb):3:in `thrice' > WithProcCall::thrice NoMethodError: undefined method `call from (irb):9:in `thrice' from (irb):9:in `times' from (irb):9:in `thrice'
> WithYield::thrice(42) ArgumentError: wrong number of arguments (1 for 0) from (irb):19:in `thrice' > WithProcCall::thrice(42) ArgumentError: wrong number of arguments (1 for 0) from (irb):20:in `thrice'
require "benchmark" def always_yield yield end def sometimes_block(flag, &block) if flag && block always_yield &block end end def sometimes_proc_new(flag) if flag && block_given? always_yield &Proc.new end end def sometimes_yield(flag) if flag && block_given? always_yield { yield } end end a = b = c = 0 n = 1_000_000 Benchmark.bmbm do |x| x.report("no &block") do n.times do sometimes_block(false) { "won end end x.report("no Proc.new") do n.times do sometimes_proc_new(false) { "won end end x.report("no yield") do n.times do sometimes_yield(false) { "won end end x.report("&block") do n.times do sometimes_block(true) { a += 1 } end end x.report("Proc.new") do n.times do sometimes_proc_new(true) { b += 1 } end end x.report("yield") do n.times do sometimes_yield(true) { c += 1 } end end end
user system total real no &block 0.580000 0.030000 0.610000 ( 0.609523) no Proc.new 0.080000 0.000000 0.080000 ( 0.076817) no yield 0.070000 0.000000 0.070000 ( 0.077191) &block 0.660000 0.030000 0.690000 ( 0.689446) Proc.new 0.820000 0.030000 0.850000 ( 0.849887) yield 0.250000 0.000000 0.250000 ( 0.249116)
require puts "Ruby puts firstname = middlename = lastname = def do_call(&block) block.call end def do_yield(&block) yield end def do_yield_without_block yield end existing_block = proc{} Benchmark.ips do |x| x.report("block.call") do |i| buffer = String.new while (i -= 1) > 0 do_call(&existing_block) end end x.report("yield with block") do |i| buffer = String.new while (i -= 1) > 0 do_yield(&existing_block) end end x.report("yield") do |i| buffer = String.new while (i -= 1) > 0 do_yield_without_block(&existing_block) end end x.compare! end
Ruby 2.3.1 at 2016-11-15 23:55:38 +1300 Warming up -------------------------------------- block.call 266.502k i/100ms yield with block 269.487k i/100ms yield 262.597k i/100ms Calculating ------------------------------------- block.call 8.271M (± 5.4%) i/s - 41.308M in 5.009898s yield with block 11.754M (± 4.8%) i/s - 58.748M in 5.011017s yield 16.206M (± 5.6%) i/s - 80.880M in 5.008679s Comparison: yield: 16206091.2 i/s yield with block: 11753521.0 i/s - 1.38x slower block.call: 8271283.9 i/s - 1.96x slower
ruby 1.9.2p180 (2011-02-18 revision 30909) [x86_64-linux]
user system total real 0.010000 0.000000 0.010000 ( 0.015555) 0.030000 0.000000 0.030000 ( 0.024416) 0.120000 0.000000 0.120000 ( 0.121450) 0.240000 0.000000 0.240000 ( 0.239760)
require iterations = 1_00_000 firstname = middlename = lastname = puts puts 5.times do Benchmark.bm(10) do |benchmark| benchmark.report( iterations.times do end end benchmark.report( iterations.times do "Mr. end end end puts end puts puts 5.times do Benchmark.bm(10) do |benchmark| benchmark.report( iterations.times do firstname + middlename + lastname end end benchmark.report( iterations.times do " end end end puts end
Without predefined strings ==================================================== user system total real concatination 0.170000 0.000000 0.170000 ( 0.165821) interpolaton 0.130000 0.010000 0.140000 ( 0.133665) -------------------------------------------------- user system total real concatination 0.180000 0.000000 0.180000 ( 0.180410) interpolaton 0.120000 0.000000 0.120000 ( 0.125051) -------------------------------------------------- user system total real concatination 0.140000 0.000000 0.140000 ( 0.134256) interpolaton 0.110000 0.000000 0.110000 ( 0.111427) -------------------------------------------------- user system total real concatination 0.130000 0.000000 0.130000 ( 0.132047) interpolaton 0.120000 0.000000 0.120000 ( 0.120443) -------------------------------------------------- user system total real concatination 0.170000 0.000000 0.170000 ( 0.170394) interpolaton 0.150000 0.000000 0.150000 ( 0.149601) -------------------------------------------------- With predefined strings ==================================================== user system total real concatination 0.070000 0.000000 0.070000 ( 0.067735) interpolaton 0.100000 0.000000 0.100000 ( 0.099335) -------------------------------------------------- user system total real concatination 0.060000 0.000000 0.060000 ( 0.061955) interpolaton 0.130000 0.000000 0.130000 ( 0.127011) -------------------------------------------------- user system total real concatination 0.090000 0.000000 0.090000 ( 0.092136) interpolaton 0.110000 0.000000 0.110000 ( 0.110224) -------------------------------------------------- user system total real concatination 0.080000 0.000000 0.080000 ( 0.077587) interpolaton 0.110000 0.000000 0.110000 ( 0.112975) -------------------------------------------------- user system total real concatination 0.090000 0.000000 0.090000 ( 0.088154) interpolaton 0.140000 0.000000 0.140000 ( 0.135349) --------------------------------------------------
require puts "Ruby puts firstname = middlename = lastname = Benchmark.ips do |x| x.report("String\ buffer = String.new while (i -= 1) > 0 buffer << end end x.report("String interpolate") do |i| buffer = String.new while (i -= 1) > 0 buffer << "Mr. end end x.compare! end
Ruby 2.3.1 at 2016-11-15 15:03:57 +1300 Warming up -------------------------------------- String String interpolate 234.274k i/100ms Calculating ------------------------------------- String String interpolate 1.242M (± 5.4%) i/s - 6.325M in 5.108324s Comparison: String String interpolate: 1241784.9 i/s - 1.89x slower
time = Time.now time.to_formatted_s(:time) time.to_s(:time) time.to_formatted_s(:db) time.to_formatted_s(:number) time.to_formatted_s(:short) time.to_formatted_s(:long) time.to_formatted_s(:long_ordinal) time.to_formatted_s(:rfc822)
Time::DATE_FORMATS[:month_and_year] = "%B %Y" Time::DATE_FORMATS[:short_ordinal] = lambda { |time| time.strftime("%B
time = Time.now time.to_formatted_s(:time) time.to_s(:time) time.to_formatted_s(:db) time.to_formatted_s(:number) time.to_formatted_s(:short) time.to_formatted_s(:long) time.to_formatted_s(:long_ordinal) time.to_formatted_s(:rfc822)
Date::DATE_FORMATS[:month_day_comma_year] = "%B %e, %Y"
From http: %a - The abbreviated weekday name (``Sun %A - The full weekday name (``Sunday %b - The abbreviated month name (``Jan %B - The full month name (``January %c - The preferred local date and time representation %d - Day of the month (01..31) %e - Day of the month without leading 0 (1..31) %g - Year in YY (00-99) %H - Hour of the day, 24-hour clock (00..23) %I - Hour of the day, 12-hour clock (01..12) %j - Day of the year (001..366) %m - Month of the year (01..12) %M - Minute of the hour (00..59) %p - Meridian indicator (``AM %S - Second of the minute (00..60) %U - Week number of the current year, starting with the first Sunday as the first day of the first week (00..53) %W - Week number of the current year, starting with the first Monday as the first day of the first week (00..53) %w - Day of the week (Sunday is 0, 0..6) %x - Preferred representation for the date alone, no time %X - Preferred representation for the time alone, no date %y - Year without a century (00..99) %Y - Year with century %Z - Time zone name %% - Literal ``% t = Time.now t.strftime("Printed on %m/%d/%Y") t.strftime("at %I:%M%p")
date_formats = { concise: } Time::DATE_FORMATS.merge! date_formats Date::DATE_FORMATS.merge! date_formats
Date::DATE_FORMATS.keys.each{|k| puts [k,Date.today.to_s(k)].join( Time::DATE_FORMATS.keys.each{|k| puts [k,Time.now.to_s(k)].join(
Date.strptime( Date.strptime( DateTime.strptime( DateTime.strptime(
rvm install 1.8.7 rvm use 1.8.7 gem install rails -v=3.0.7
Rails is not currently installed on this system. To get the latest version, simply type: $ sudo gem install rails You can then rerun your "rails" command.
ruby-1.8.7-p352@rails: system: uname: "Darwin yicai.local 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun 7 16:32:41 PDT 2011; root:xnu-1504.15.3~1/RELEASE_X86_64 x86_64" bash: "/bin/bash => GNU bash, version 3.2.48(1)-release (x86_64-apple-darwin10.0)" zsh: "/bin/zsh => zsh 4.3.9 (i386-apple-darwin10.0)" rvm: version: "rvm 1.8.6 by Wayne E. Seguin (wayneeseguin@gmail.com) [https: ruby: interpreter: "ruby" version: "1.8.7" date: "2011-06-30" platform: "i686-darwin10.8.0" patchlevel: "2011-06-30 patchlevel 352" full_version: "ruby 1.8.7 (2011-06-30 patchlevel 352) [i686-darwin10.8.0]" homes: gem: "/Users/nil/.rvm/gems/ruby-1.8.7-p352@rails" ruby: "/Users/nil/.rvm/rubies/ruby-1.8.7-p352" binaries: ruby: "/Users/nil/.rvm/rubies/ruby-1.8.7-p352/bin/ruby" irb: "/Users/nil/.rvm/rubies/ruby-1.8.7-p352/bin/irb" gem: "/Users/nil/.rvm/rubies/ruby-1.8.7-p352/bin/gem" rake: "/Users/nil/.rvm/bin/rake" environment: PATH: "/Users/nil/.rvm/gems/ruby-1.8.7-p352@rails/bin:/Users/nil/.rvm/gems/ruby-1.8.7-p352@global/bin:/Users/nil/.rvm/rubies/ruby-1.8.7-p352/bin:/Users/nil/.rvm/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin:/usr/local/sbin" GEM_HOME: "/Users/nil/.rvm/gems/ruby-1.8.7-p352@rails" GEM_PATH: "/Users/nil/.rvm/gems/ruby-1.8.7-p352@rails:/Users/nil/.rvm/gems/ruby-1.8.7-p352@global" MY_RUBY_HOME: "/Users/nil/.rvm/rubies/ruby-1.8.7-p352" IRBRC: "/Users/nil/.rvm/rubies/ruby-1.8.7-p352/.irbrc" RUBYOPT: "" gemset: "rails"
$ rvm list => ruby-1.8.7-p352 [ x86_64 ] ruby-1.9.2-p290 [ x86_64 ] $ rvm use 1.9.2
$ rvm gemset list_all gemsets for ruby-1.8.7-p352 (found in /Users/asgeo1/.rvm/gems/ruby-1.8.7-p352) global gemsets for ruby-1.9.2-p290 (found in /Users/asgeo1/.rvm/gems/ruby-1.9.2-p290) global rails31 $ rvm use ruby-1.9.2-p290@rails31
export PATH="$HOME/.rbenv/bin:/usr/local/bin:$PATH" eval "$(rbenv init -)"
$ gem install rails $ rbenv rehash $ which rails /Users/palmerc/.rbenv/shims/rails
rvm list => ree-1.8.7-2012.02 [ i686 ] ruby-1.9.3-p125 [ x86_64 ] which ruby /Users/dev/.rvm/rubies/ree-1.8.7-2012.02/bin/ruby which rails /usr/bin/rails gem list --local .. rails (3.2.8) rails2_asset_pipeline (0.1.20) railties (3.2.8) .. rvm use ruby-1.9.3-p125 which ruby /Users/dev/.rvm/rubies/ruby-1.9.3-p125/bin/ruby which rails /Users/dev/.rvm/gems/ruby-1.9.3-p125/bin/rails
export PATH="$HOME/.rbenv/versions/2.3.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"
validates_length_of :foo, :maximum => 5 validates_length_of :foo, :minimum => 5
validates_length_of :foo, minimum: 5, maximum: 5, allow_blank: true
validates :foo, length: {minimum: 5, maximum: 5}, allow_blank: true
validates_length_of :phone, :in => 7..32, :allow_blank => true
validates_length_of :foo, :maximum => 5, :if => :validate_foo_condition
validates_length_of :foo, :maximum => 5, :unless => Proc.new {|object| object.foo.blank?}
validates_length_of :reason, minimum: 3, maximum: 30
it { should validate_length_of(:reason).is_at_least(3).is_at_most(30) }
base = "http: for i in 1..50 url = " file = "tutthreads_ File.open(file, system "curl -o end end
result = ` curl -X POST https: -d "name=pat" \ -d "age=21" ` puts result
$ which -a ruby /Users/matthew/.rvm/rubies/ruby-1.9.3-p0/bin/ruby /Users/matthew/.rvm/bin/ruby /usr/bin/ruby
$ brew update $ brew install rbenv $ brew install ruby-build
$ gem install jekyll bundler ERROR: While executing gem ... (Gem::FilePermissionError) You don
@data = Net::HTTP.get(uri, Net::HTTP.https_default_port())
uri = URI.parse("https: http = Net::HTTP.new(uri.host, uri.port) http.use_ssl = true @data = http.get(uri.request_uri)
uri = URI( Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.scheme == request = Net::HTTP::Get.new uri response = http.request request end
uri.port = Net::HTTP.https_default_port() @data = Net::HTTP.get(uri)
{"admin_user_new_image_file"=> { :filename=>"freddie-on-shetland-pony.png", :type=>"image/png", :name=>"admin_user_new_image_file", :tempfile=> :head=>"Content-Disposition: form-data; name=\"admin_user_new_image_file\"; filename=\"freddie-on-shetland-pony.png\"\r\nContent-Type: image/png\r\n" } }
post "/admin/user/:account_name/image/new/" do if params[:admin_user_new_image_file][:tempfile] thumbnail = Magick::Image.read("png:"+params[:admin_user_new_image_file][:tempfile].path).first end end
config.ru:229: [BUG] Segmentation fault ruby 1.9.1p376 (2009-12-07 revision 26041) [i386-darwin10.3.0] -- control frame ---------- c:0042 p:---- s:0196 b:0196 l:000195 d:000195 CFUNC :read c:0041 p:0121 s:0192 b:0192 l:001ab8 d:000191 LAMBDA config.ru:229 c:0040 p:---- s:0189 b:0189 l:000188 d:000188 FINISH c:0039 p:---- s:0187 b:0187 l:000186 d:000186 CFUNC :call c:0038 p:0018 s:0184 b:0184 l:001d78 d:000183 BLOCK /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:865 c:0037 p:---- s:0182 b:0182 l:000181 d:000181 FINISH c:0036 p:---- s:0180 b:0180 l:000179 d:000179 CFUNC :instance_eval c:0035 p:0016 s:0177 b:0175 l:000174 d:000174 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:521 c:0034 p:0024 s:0171 b:0171 l:000148 d:000170 BLOCK /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:500 c:0033 p:---- s:0169 b:0169 l:000168 d:000168 FINISH c:0032 p:---- s:0167 b:0167 l:000166 d:000166 CFUNC :catch c:0031 p:0140 s:0163 b:0163 l:000148 d:000162 BLOCK /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:497 c:0030 p:---- s:0154 b:0154 l:000153 d:000153 FINISH c:0029 p:---- s:0152 b:0152 l:000151 d:000151 CFUNC :each c:0028 p:0073 s:0149 b:0149 l:000148 d:000148 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:476 c:0027 p:0076 s:0141 b:0141 l:000140 d:000140 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:601 c:0026 p:0009 s:0137 b:0137 l:000138 d:000136 BLOCK /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:411 c:0025 p:---- s:0135 b:0135 l:000134 d:000134 FINISH c:0024 p:---- s:0133 b:0133 l:000132 d:000132 CFUNC :instance_eval c:0023 p:0012 s:0130 b:0130 l:000121 d:000129 BLOCK /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:566 c:0022 p:---- s:0128 b:0128 l:000127 d:000127 FINISH c:0021 p:---- s:0126 b:0126 l:000125 d:000125 CFUNC :catch c:0020 p:0013 s:0122 b:0122 l:000121 d:000121 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:566 c:0019 p:0098 s:0115 b:0115 l:000138 d:000138 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:411 c:0018 p:0019 s:0108 b:0108 l:000107 d:000107 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:399 c:0017 p:0014 s:0104 b:0104 l:000103 d:000103 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/showexceptions.rb:24 c:0016 p:0150 s:0098 b:0098 l:000097 d:000097 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/methodoverride.rb:24 c:0015 p:0031 s:0092 b:0092 l:000091 d:000091 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/commonlogger.rb:18 c:0014 p:0018 s:0084 b:0084 l:002080 d:000083 BLOCK /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:979 c:0013 p:0032 s:0082 b:0082 l:000081 d:000081 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:1005 c:0012 p:0011 s:0078 b:0078 l:002080 d:002080 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:979 c:0011 p:0100 s:0074 b:0074 l:000ff0 d:000ff0 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/lint.rb:47 c:0010 p:0022 s:0068 b:0068 l:000067 d:000067 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/lint.rb:35 c:0009 p:0014 s:0064 b:0064 l:000063 d:000063 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/showexceptions.rb:24 c:0008 p:0031 s:0058 b:0058 l:000057 d:000057 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/commonlogger.rb:18 c:0007 p:0014 s:0050 b:0050 l:000049 d:000049 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/content_length.rb:13 c:0006 p:0320 s:0042 b:0042 l:000041 d:000041 METHOD /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/handler/webrick.rb:48 c:0005 p:0256 s:0030 b:0030 l:000029 d:000029 METHOD /usr/local/lib/ruby/1.9.1/webrick/httpserver.rb:111 c:0004 p:0382 s:0020 b:0020 l:000019 d:000019 METHOD /usr/local/lib/ruby/1.9.1/webrick/httpserver.rb:70 c:0003 p:0123 s:0009 b:0009 l:000bc8 d:000008 BLOCK /usr/local/lib/ruby/1.9.1/webrick/server.rb:183 c:0002 p:---- s:0004 b:0004 l:000003 d:000003 FINISH c:0001 p:---- s:0002 b:0002 l:000001 d:000001 TOP --------------------------- -- Ruby level backtrace information----------------------------------------- config.ru:229:in `read' config.ru:229:in `block (2 levels) in <main>' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:865:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:865:in `block in route' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:521:in `instance_eval' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:521:in `route_eval' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:500:in `block (2 levels) in route!' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:497:in `catch' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:497:in `block in route!' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:476:in `each' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:476:in `route!' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:601:in `dispatch!' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:411:in `block in call!' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:566:in `instance_eval' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:566:in `block in invoke' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:566:in `catch' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:566:in `invoke' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:411:in `call!' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:399:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/showexceptions.rb:24:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/methodoverride.rb:24:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/commonlogger.rb:18:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:979:in `block in call' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:1005:in `synchronize' /usr/local/lib/ruby/gems/1.9.1/gems/sinatra-1.0/lib/sinatra/base.rb:979:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/lint.rb:47:in `_call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/lint.rb:35:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/showexceptions.rb:24:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/commonlogger.rb:18:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/content_length.rb:13:in `call' /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.1.0/lib/rack/handler/webrick.rb:48:in `service' /usr/local/lib/ruby/1.9.1/webrick/httpserver.rb:111:in `service' /usr/local/lib/ruby/1.9.1/webrick/httpserver.rb:70:in `run' /usr/local/lib/ruby/1.9.1/webrick/server.rb:183:in `block in start_thread' -- C level backtrace information ------------------------------------------- 0x10010cd8d 0 libruby.dylib 0x000000010010cd8d rb_vm_bugreport + 77 0x10002b184 1 libruby.dylib 0x000000010002b184 report_bug + 260 0x10002b318 2 libruby.dylib 0x000000010002b318 rb_bug + 200 0x1000b7124 3 libruby.dylib 0x00000001000b7124 sigsegv + 132 0x7fff8301c80a 4 libSystem.B.dylib 0x00007fff8301c80a _sigtramp + 26 0x1032313ac 5 libMagickCore.3.dylib 0x00000001032313ac Splay + 300 0x103119245 6 libMagickCore.3.dylib 0x0000000103119245 AcquirePixelCache + 325 0x1031cb317 7 libMagickCore.3.dylib 0x00000001031cb317 AcquireImage + 375 0x10333035b 8 libMagickCore.3.dylib 0x000000010333035b ReadPNGImage + 155 0x1031418fd 9 libMagickCore.3.dylib 0x00000001031418fd ReadImage + 2221 0x101f1b72b 10 RMagick2.bundle 0x0000000101f1b72b rd_image + 339 0x101f1b59b 11 RMagick2.bundle 0x0000000101f1b59b Image_read + 36 0x1000fd0e4 12 libruby.dylib 0x00000001000fd0e4 vm_call_cfunc + 340 0x1000fe9b0 13 libruby.dylib 0x00000001000fe9b0 vm_call_method + 896 0x1000ff8fc 14 libruby.dylib 0x00000001000ff8fc vm_exec_core + 3180 0x100104b93 15 libruby.dylib 0x0000000100104b93 vm_exec + 1203 0x100106643 16 libruby.dylib 0x0000000100106643 rb_vm_invoke_proc + 691 0x100106ccd 17 libruby.dylib 0x0000000100106ccd vm_call0 + 1085 0x1000317c6 18 libruby.dylib 0x00000001000317c6 rb_method_call + 406 0x1000fd0e4 19 libruby.dylib 0x00000001000fd0e4 vm_call_cfunc + 340 0x1000fe9b0 20 libruby.dylib 0x00000001000fe9b0 vm_call_method + 896 0x1000ff8fc 21 libruby.dylib 0x00000001000ff8fc vm_exec_core + 3180 0x100104b93 22 libruby.dylib 0x0000000100104b93 vm_exec + 1203 0x100105ce6 23 libruby.dylib 0x0000000100105ce6 yield_under + 710 0x100106188 24 libruby.dylib 0x0000000100106188 specific_eval + 72 0x1000fd0e4 25 libruby.dylib 0x00000001000fd0e4 vm_call_cfunc + 340 0x1000fe9b0 26 libruby.dylib 0x00000001000fe9b0 vm_call_method + 896 0x1000ff8fc 27 libruby.dylib 0x00000001000ff8fc vm_exec_core + 3180 0x100104b93 28 libruby.dylib 0x0000000100104b93 vm_exec + 1203 0x10010b6bf 29 libruby.dylib 0x000000010010b6bf rb_f_catch + 639 0x1000fd0e4 30 libruby.dylib 0x00000001000fd0e4 vm_call_cfunc + 340 0x1000fe9b0 31 libruby.dylib 0x00000001000fe9b0 vm_call_method + 896 0x1000ff8fc 32 libruby.dylib 0x00000001000ff8fc vm_exec_core + 3180 0x100104b93 33 libruby.dylib 0x0000000100104b93 vm_exec + 1203 0x10010aac9 34 libruby.dylib 0x000000010010aac9 rb_yield + 505 0x100007902 35 libruby.dylib 0x0000000100007902 rb_ary_each + 82 0x1000fd0e4 36 libruby.dylib 0x00000001000fd0e4 vm_call_cfunc + 340 0x1000fe9b0 37 libruby.dylib 0x00000001000fe9b0 vm_call_method + 896 0x1000ff8fc 38 libruby.dylib 0x00000001000ff8fc vm_exec_core + 3180 0x100104b93 39 libruby.dylib 0x0000000100104b93 vm_exec + 1203 0x100105ce6 40 libruby.dylib 0x0000000100105ce6 yield_under + 710 0x100106188 41 libruby.dylib 0x0000000100106188 specific_eval + 72 0x1000fd0e4 42 libruby.dylib 0x00000001000fd0e4 vm_call_cfunc + 340 0x1000fe9b0 43 libruby.dylib 0x00000001000fe9b0 vm_call_method + 896 0x1000ff8fc 44 libruby.dylib 0x00000001000ff8fc vm_exec_core + 3180 0x100104b93 45 libruby.dylib 0x0000000100104b93 vm_exec + 1203 0x10010b6bf 46 libruby.dylib 0x000000010010b6bf rb_f_catch + 639 0x1000fd0e4 47 libruby.dylib 0x00000001000fd0e4 vm_call_cfunc + 340 0x1000fe9b0 48 libruby.dylib 0x00000001000fe9b0 vm_call_method + 896 0x1000ff8fc 49 libruby.dylib 0x00000001000ff8fc vm_exec_core + 3180 0x100104b93 50 libruby.dylib 0x0000000100104b93 vm_exec + 1203 0x100106643 51 libruby.dylib 0x0000000100106643 rb_vm_invoke_proc + 691 0x100111803 52 libruby.dylib 0x0000000100111803 thread_start_func_2 + 835 0x100111921 53 libruby.dylib 0x0000000100111921 thread_start_func_1 + 17 0x7fff82ff58b6 54 libSystem.B.dylib 0x00007fff82ff58b6 _pthread_start + 331 0x7fff82ff5769 55 libSystem.B.dylib 0x00007fff82ff5769 thread_start + 13 [NOTE] You may encounter a bug of Ruby interpreter. Bug reports are welcome. For details: http: Abort trap
brew uninstall imagemagick && brew install imagemagick --disable-openmp
brew uninstall imagemagick brew install imagemagick --disable-openmp
class Object def nil_or_zero? return (self.nil? or self == 0) end end my_object = MyClass.new my_object.nil_or_zero? ==> false
module Nothingness refine Numeric do alias_method :nothing?, :zero? end refine NilClass do alias_method :nothing?, :nil? end end using Nothingness if val.nothing? end
not_valid = nil, 0 case val1 with *not_valid end case val2 with *not_valid, false end
def nil_zero? if respond_to?(:zero?) zero? else !self end end
nil.nil_zero? => true 0.nil_zero? => true 10.nil_zero? => false if val.nil_zero? end
module NilOrZero refine Object do def nil_or_zero? nil? or zero? end end end using NilOrZero class Car def initialize(speed: 100) puts speed.nil_or_zero? end end car = Car.new car = Car.new(speed: nil) car = Car.new(speed: 0)
void DoStuff( int parameter, CallbackPtr callback ) { ... callback( status_code ) }
def my_callback(a, b, c, status_code) puts "did stuff with end def do_stuff(a, b, c, callback) sum = a + b + c callback.call(a, b, c, sum) end def main a = 1 b = 2 c = 3 do_stuff(a, b, c, method(:my_callback)) end
def do_stuff(a, b, c, &block) sum = a + b + c yield sum end def main a = 1 b = 2 c = 3 do_stuff(a, b, c) { |status_code| puts "did stuff with } end
def x(z, &block) callback = block callback.call(z) end x(4) {|y| y * y}
def x(z,fn) fn.call(z) end x(5, lambda {|y| y * y})
class A def b(z) z*z end end callable = A.new.method(:b) callable.call(6) def x(z,fn) fn.call(z) end x(7, callable)
require module SuperSimpleCallbacks include Observable def self.included(klass) klass.extend ClassMethods klass.initialize_included_features end def initialize add_observer(self) end def update(method_name, callback_type) case callback_type when :before then self.class.callbacks[:before][method_name.to_sym].each{|callback| send callback} when :after then self.class.callbacks[:after][method_name.to_sym].each{|callback| send callback} end end module ClassMethods def initialize_included_features @callbacks = Hash.new @callbacks[:before] = Hash.new{|h,k| h[k] = []} @callbacks[:after] = @callbacks[:before].clone class << self attr_accessor :callbacks end end def method_added(method) redefine_method(method) if is_a_callback?(method) end def is_a_callback?(method) registered_methods.include?(method) end def registered_methods callbacks.values.map(&:keys).flatten.uniq end def store_callbacks(type, method_name, *callback_methods) callbacks[type.to_sym][method_name.to_sym] += callback_methods.flatten.map(&:to_sym) end def before(original_method, *callbacks) store_callbacks(:before, original_method, *callbacks) end def after(original_method, *callbacks) store_callbacks(:after, original_method, *callbacks) end def objectify_and_remove_method(method) if method_defined?(method.to_sym) original = instance_method(method.to_sym) remove_method(method.to_sym) original else nil end end def redefine_method(original_method) original = objectify_and_remove_method(original_method) mod = Module.new mod.class_eval do define_method(original_method.to_sym) do changed; notify_observers(original_method, :before) original.bind(self).call if original changed; notify_observers(original_method, :after) end end include mod end end end class MyObservedHouse include SuperSimpleCallbacks before :party, [:walk_dinosaure, :prepare, :just_idle] after :party, [:just_idle, :keep_house, :walk_dinosaure] before :home_office, [:just_idle, :prepare, :just_idle] after :home_office, [:just_idle, :walk_dinosaure, :just_idle] before :second_level, [:party] def home_office puts "learning and working with ruby...".upcase end def party puts "having party...".upcase end def just_idle puts "...." end def prepare puts "preparing snacks..." end def keep_house puts "house keeping..." end def walk_dinosaure puts "walking the dinosaure..." end def second_level puts "second level..." end end MyObservedHouse.new.tap do |house| puts "-------------------------" puts "-- about calling party --" puts "-------------------------" house.party puts "-------------------------------" puts "-- about calling home_office --" puts "-------------------------------" house.home_office puts "--------------------------------" puts "-- about calling second_level --" puts "--------------------------------" house.second_level end
class EventHandler def initialize @client_map = {} end def add_listener(id, func) (@client_map[id.hash] ||= []) << func end def remove_listener(id) return @client_map.delete(id.hash) end def alert_listeners(*args) @client_map.each_value { |v| v.each { |func| func.call(*args) } } end end
class Foo attr_reader :some_value_changed def initialize @some_value_changed = EventHandler.new end end
foo.some_value_changed.add_listener(self, lambda { some_func })
class Foo def initialize callback( :on_die_cast ) end def run while( true ) die = 1 + rand( 6 ) on_die_cast( die ) sleep( die ) end end def callback( *names ) names.each do |name| eval <<-EOF @ def if( block ) @ elsif( @ @ end end EOF end end end foo = Foo.new foo.on_die_cast do |number| puts( number ) end foo.run
class ObjectWithCallbackHooks include ActiveSupport::Callbacks define_callbacks :initialize include ObjectWithCallbackHooks::Plugin def initialize(*) run_callbacks(:initialize) do puts "- initializing" end end end module ObjectWithCallbackHooks::Plugin include ActiveSupport::Concern included do set_callback :initialize, :after, :initialize_some_plugin end end
class User < ActiveRecord::Base has_many :event_users has_many :events, :through => :event_users end class EventUser < ActiveRecord::Base belongs_to :event belongs_to :user end class Event < ActiveRecord::Base has_many :event_users has_many :users, :through => :event_users end
u = User.find :first active_events = u.events.find_by_active(true)
u = User.find :first active_events = [] u.event_users.find_by_active(true).do |eu| active_events << eu.event end
has_many :active_events, :through => :event_users, :class_name => "Event", :source => :event, :conditions => [
has_many :event_users has_many :active_event_users, -> { where active: true }, class_name: has_many :active_events, :through => :active_event_users, class_name:
u.events.find(:all, :conditions => ["user_events.active = ?", true])
class EventUser < ActiveRecord::Base belongs_to :event belongs_to :user scope :active, -> { where(active: true) } scope :inactive, -> { where(active: false) } end
class User < ActiveRecord::Base has_many :active_event_users, -> { active }, class_name: "EventUser" has_many :inactive_event_users, -> { inactive }, class_name: "EventUser" has_many :inactive_events, through: :inactive_event_user, class_name: "Event", source: :event has_many :active_events, through: :active_event_users, class_name: "Event", source: :event end
% rails server --environment=development --debug => Booting WEBrick => Rails 3.1.0 application starting in development on http: => Call with -d to detach => Ctrl-C to shutdown server You need to install ruby-debug to run the server in debugging mode. With gems, use Exiting
$ gem install linecache19-0.5.13.gem Building native extensions. This could take a while... Successfully installed linecache19-0.5.13 1 gem installed $ gem install ruby-debug-base19-0.11.26.gem -- --with-ruby-include=/Users/santiago/.rbenv/source/ruby-1.9.3-p0 Building native extensions. This could take a while... Successfully installed ruby-debug-base19-0.11.26 1 gem installed $ irb irb(main):001:0> require => true
if defined?(Rails) && Rails.env extend Rails::ConsoleMethods end
wget http: wget http: gem install linecache19-0.5.13.gem gem install ruby-debug-base19-0.11.26.gem -- --with-ruby-include=$HOME/.rvm/src/ruby-1.9.3-p0-falcon gem install ruby-debug-base19-0.11.26.gem -- --with-ruby-include=$HOME/.rbenv/source/ruby-1.9.3-p0-falcon
linecache19 (0.5.13) ruby-debug-base19x (0.11.30.pre10) ruby-debug-ide (0.4.16)
theme: name: default css_path: compiled/themes/$theme.name layout_path: themes/$theme.name
default: &default_title This Post Has No Title title: *default_title
example_post: &example title: My mom likes roosters body: Seriously, she does. And I don date: 8/18/2012 first_post: *example second_post: title: whatever, etc.
default: &DEFAULT URL: stooges.com throw_pies?: true stooges: &stooge_list larry: first_stooge moe: second_stooge curly: third_stooge development: <<: *DEFAULT URL: stooges.local stooges: shemp: fourth_stooge test: <<: *DEFAULT URL: test.stooges.qa stooges: <<: *stooge_list shemp: fourth_stooge
require file = YAML.load_file( foobar = content = file[ modified_content = content % { :foobar => foobar } puts modified_content
foo = bar = modified_content = content % { :foo => foo, :bar => bar }
require require doc = <<-EOF theme: name: default css_path: compiled/themes/<%= data[ layout_path: themes/<%= data[ image_path: <%= data[ recursive_path: <%= data[ EOF data = YAML::load("---" + doc) template = ERB.new(data.to_yaml); str = template.result(binding) while /<%=.*%>/.match(str) != nil str = ERB.new(str).result(binding) end puts str
doc = <<-EOF theme: name: default css_path: compiled/themes/<%= data.theme.name %> layout_path: themes/<%= data.theme.name %> image_path: <%= data.theme.css_path %>/images recursive_path: <%= data.theme.image_path %>/plus/one/more EOF
uri = URI( req = Net::HTTP::Post.new(uri, req.body = {param1: res = Net::HTTP.start(uri.hostname, uri.port) do |http| http.request(req) end
require require def create_agent uri = URI( http = Net::HTTP.new(uri.host, uri.port) req = Net::HTTP::Post.new(uri.path, req.body = {name: res = http.request(req) puts "response rescue => e puts "failed end
require uri = URI.parse("http: response = Net::HTTP.post_form(uri, {"search" => "Berlin"})
require require require class MakeHttpsRequest def call(url, hash_json) uri = URI.parse(url) req = Net::HTTP::Post.new(uri.to_s) req.body = hash_json.to_json req[ response = https(uri).request(req) response.body end private def https(uri) Net::HTTP.new(uri.host, uri.port).tap do |http| http.use_ssl = true http.verify_mode = OpenSSL::SSL::VERIFY_NONE end end end project_id = project_key = url = "https: body_hash = { "environment":"production", "username":"tomas", "repository":"https: "revision":"live-20160905_0001", "version":"v2.0" } puts MakeHttpsRequest.new.call(url, body_hash)
response = Unirest.post "http: headers:{ "Accept" => "application/json" }, parameters:{ :age => 23, :foo => "bar" } response.code response.headers response.body response.raw_body
require "net/http" uri = URI.parse(uri) Net::HTTP.new(uri.host, uri.port).start do |client| request = Net::HTTP::Post.new(uri.path) request.body = "{}" request["Content-Type"] = "application/json" client.request(request) end
data = {a: {b: [1, 2]}}.to_json uri = URI https = Net::HTTP.new uri.host, uri.port https.use_ssl = true https.post2 uri.path, data,
$ gem install rdoc-data $ rdoc-data --install $ gem rdoc --all --overwrite
$ gem list *** LOCAL GEMS *** aasm (2.1.1) actionmailer (3.2.3, 3.2.2, 3.1.4, 3.1.3, 3.1.1, 3.1.0, 2.3.8, 2.3.5) actionpack (3.2.3, 3.2.2, 3.1.4, 3.1.3, 3.1.1, 3.1.0, 2.3.8, 2.3.5) active_support (3.0.0) ... +100 ...
$ gem uninstall actionmailer \ actionpack \ active_support \ ... 100 more ... ZenTest \ -a -x -I
def func2(arg1, arg2, *other_args) p arg1.inspect p arg2.inspect p other_args.inspect end
my_func arg1, arg2, :html_arg => value, :html_arg2 => value2
my_func(arg1, arg2, {:html_arg => value, :html_arg2 => value2})
subject { MovieList.add_new(10) } specify { subject.should have(10).items } it { subject.track_number.should == 10}
describe Array do describe "with 3 items" do before { @arr = [1, 2, 3] } specify { @arr.should_not be_empty } specify { @arr.count.should eq(3) } end end describe Array do describe "with 3 items" do subject { [1, 2, 3] } it { should_not be_empty } its(:count) { should eq(3) } end end
class TrueClass def &(other) other end def |(_) self end def ^(other) !other end def to_s end end
class FalseClass def &(_) self end def |(other) other end def ^(other) other end def to_s end end
class TrueClass def if yield end def ifelse(then_branch=->{}, _=nil) then_branch.() end def unless end def unlesselse(_=nil, else_branch=->{}) ifelse(else_branch, _) end def and yield end def or self end def not false end end
class FalseClass def if end def ifelse(_=nil, else_branch=->{}) else_branch.() end def unless yield end def unlesselse(unless_branch=->{}, _=nil) ifelse(_, unless_branch) end def and self end def or yield end def not true end end
class Object def trueish?; !!self; end end class String def trueish? return true if self.strip.downcase == [:Integer, :Float, :Rational, :Complex].each do |t| begin converted_number = Kernel.send(t, self) return false if converted_number == 0 rescue ArgumentError end end return false end end
puts false.trueish? puts true.trueish? puts puts puts puts puts puts
if nil puts "nil is true" else puts "nil is false" end
class Boolean def self.new(bool) bool end def self.true true end def self.false false end end class FalseClass def is_a?(other) other == Boolean || super end def self.===(other) other == Boolean || super end end class TrueClass def is_a?(other) other == Boolean || super end def self.===(other) other == Boolean || super end end
lines2 = lines.gsub( /\r\n/m, "\n" ) if ( lines == lines2 ) print "still the same\n" else print "made the change\n" end
string = string.gsub(/\r/," ") string = string.gsub(/\n/," ")
irb(main):003:0> my_string = "Some text with a carriage return \r" => "Some text with a carriage return \r" irb(main):004:0> my_string.gsub(/\r/,"") => "Some text with a carriage return " irb(main):005:0>
irb(main):007:0> my_string = "Some text with a carriage return \r\n" => "Some text with a carriage return \r\n" irb(main):008:0> my_string.gsub(/\r\n/,"\n") => "Some text with a carriage return \n" irb(main):009:0>
def dos2unix(input) input.each_byte.map { |c| c.chr unless c == 13 }.join end remove_all_the_carriage_returns = dos2unix(some_blob)
require module ActiveRecord module Usesguid def self.append_features(base) super base.extend(ClassMethods) end module ClassMethods def usesguid(options = {}) class_eval do self.primary_key = options[:column] if options[:column] after_initialize :create_id def create_id self.id ||= SecureRandom.uuid end end end end end end ActiveRecord::Base.class_eval do include ActiveRecord::Usesguid end
class CreateUuidFunction < ActiveRecord::Migration def self.up execute "create or replace function uuid() returns uuid as end def self.down execute "drop function uuid();" end end
class CreateContacts < ActiveRecord::Migration def change create_table :contacts, id: false do |t| t.column :id, :uuid, null:false t.string :name t.string :mobile_no t.timestamps end end end
def us_states [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ ] end
<%= select_tag :state, options_for_select(us_states) %>
def us_states [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ ] end
subregion_select(:address, :state_code, Carmen::Country.coded(
module StatesHelper def us_states [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ ] end end
config.action_controller.include_all_helpers = true
= form_for :order_submissions, url: order_url, html: { id: "order_form"} do |f| fieldset .form-group = f.select(:state, options_for_select(us_states, "CA"))
STATES = [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ ]
<%= simple_form_for(@user) do |f| %> <%= f.input :state, as: :select, collection: User::STATES %> <%= f.button :submit %> <% end %>
class CreateStates < ActiveRecord::Migration def change create_table :states, id: false do |t| t.string :state_code, null: false t.string :state_name end add_index :states, :state_code, unique: true end end
states = State.create!([ { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: { state_name: ])
<%= f.label :state_code, <%= f.collection_select(:state_code, State.select(:state_name, :state_code), :state_code, :state_name, {selected:
<%= f.select :country_code, ::ISO3166::Country.all_names_with_codes,{ include_blank: true } %>
class SupportsController < ApplicationController before_action :set_support, only: [:show, :edit, :update, :destroy] ....
before_action only: [:show, :edit, :update, :destroy] do set_support("value") end
class SupportsController < ApplicationController before_action -> { set_support("value") }, only: [:show, :edit, :update, :destroy] ...
before_action except:[:index, :show] { method :param1, :param2 }
after_filter only:[:destroy, :kerplode] { method2_namey_name(p1, p2) }
class SupportsController < ApplicationController before_action(only: [:show, :edit, :update, :destroy]) ->{|c| c.set_support params[:action]} ....
require "csv" CSV.open("file.csv", "wb") do |csv| csv << ["animal", "count", "price"] csv << ["fox", "1", "$90.00"] end
CSV.open("file.csv", "a+") do |csv| csv << ["cow", "3","2500"] end
Timecop.travel(6.days.ago) do @model = TimeSensitiveMode.new end assert @model.times_up!
class MyTest < Test::Unit::TestCase def setup Timecop.travel(...) end def teardown Timecop.return end end
Given it is currently January 24, 2008 And I go to the new post page And I fill in "title" with "An old post" And I fill in "body" with "..." And I press "Submit" And we jump in our Delorean and return to the present When I go to the home page I should not see "An old post"
class MyClass attr_writer :clock def initialize @clock = Time end def hello puts "the time is now: end end
now = Time.parse("1969-07-20 20:17:40") allow(Time).to receive(:now) { now }
real_time_class = Time Time = FakeTimeClass Time = real_time_class
future: comparing_date: <%= Time.now + 10.years %> ... past: comparing_date: <%= Time.now - 10.years %> ...
Time.stub!(:now).and_return(Time.mktime(2014,10,22,5,35,28))
class Time class << self attr_accessor :stack, :depth end def self.warp(time) Time.stack ||= [] Time.depth ||= -1 Time.depth += 1 Time.stack.push time if Time.depth == 0 class << self alias_method :real_now, :now alias_method :real_new, :new define_method :now do stack[depth] end define_method :new do now end end end yield Time.depth -= 1 Time.stack.pop class << self if Time.depth < 0 alias_method :new, :real_new alias_method :now, :real_now remove_method :real_new remove_method :real_now end end end end
time1 = 2.days.ago time2 = 5.months.ago Time.warp(time1) do Time.real_now.should_not == Time.now Time.now.should == time1 Time.warp(time2) do Time.now.should == time2 end Time.now.should == time1 end Time.now.should_not == time1 Time.now.should_not be_nil
future: comparing_date: <%= Time.now + 10.years %> ... past: comparing_date: <%= Time.now - 10.years %> ...
def time_right_now current_time = Time.parse("07/09/10 14:20") current_time = convert_time_to_utc(current_date) return current_time end
def time_right_now current_time= Time.new return current_time end
fake_time = Time.at(12345) Test::Redef.rd assert_equal 12345, Time.now.to_i end
ruby --version ruby 2.2.3p173 (2015-08-18 revision 51636) [x86_64-darwin13]
foo = "10/10/2011" case foo when /^([0-9][0-9])/ print "the month is else print "something else" end
case foo when /^([0-9][0-9])/ print "the month is else print "something else" end
case foo when /^(?<number>[0-9][0-9])/ print "the month is else print "something else" end
res = [ /pat1/, /pat2/, ... ] m = nil res.find { |re| m = foo.match(re) }
class Hello def method1 @hello = "pavan" end end h = Hello.new puts h.method1
class Hello def method1 @hello = "pavan" end end h = Hello.new p h.instance_variable_get(:@hello) p h.method1 p h.instance_variable_get(:@hello)
class Hello def method1 @hello = "pavan" end attr_reader :hello end h = Hello.new p h.hello p h.method1 p h.hello
class Hello attr_reader :hello def initialize @hello = "pavan" end end
class Hello attr_accessor :hello def initialize @hello = "pavan" end end
A User .... can only have one name A User .... can ...
$ rspec --help Usage: rspec [options] [files or directories] -f, --format FORMATTER Choose a formatter [p]rogress (default - dots) [d]ocumentation (group and example names) [h]tml [t]extmate custom formatter class name
RSpec.configure do |config| config.formatter = :documentation end
bundle config build.nokogiri --use-system-libraries=true --with-xml2-include="$(xcrun --show-sdk-path)"/usr/include/libxml2 bundle install
gem install nokogiri -v 1.6.8.1 -- --use-system-libraries=true --with-xml2-include="$(xcrun --show-sdk-path)"/usr/include/libxml2
bundle config build.nokogiri --use-system-libraries \ --with-xml2-include=$(brew --prefix libxml2)/include/libxml2 bundle install
gem install nokogiri -- --use-system-libraries \ --with-xml2-include=$(brew --prefix libxml2)/include/libxml2
gem update --system xcode-select --install brew unlink xz gem install nokogiri -v brew link xz
namespace :db do namespace :seed do Dir[Rails.root.join( task_name = File.basename(filename, desc "Seed " + task_name + ", based on the file with the same name in `db/seeds/*.rb`" task task_name.to_sym => :environment do load(filename) if File.exist?(filename) end end end end
namespace :db do namespace :seed do task :single => :environment do filename = Dir[File.join(Rails.root, puts "Seeding load(filename) if File.exist?(filename) end end end
rake db:seed:single SEED=<seed_name_without_.seeds.rb>
desc "Run all files in db/seeds directory" namespace :db do task seed: :environment do Dir[File.join(Rails.root, puts "seeding - load(filename) end end end
post :create, user: Fabricate.attributes_for(:user)
bundle exec rake db:drop RAILS_ENV=test bundle exec rake db:create RAILS_ENV=test bundle exec rake db:schema:load RAILS_ENV=test
config.after :all do ActiveRecord::Base.subclasses.each(&:delete_all) end
$ redis-cli keys * (press * followed by Ctrl-D) ... (prints a list of keys and exits) $
irb(main):002:0> require => true irb(main):003:0> require => true irb(main):004:0> r = Redis.new => irb(main):005:0> r.keys(
ActionView::Template::Error (incompatible character encodings: ASCII-8BIT and UTF-8): 21: -flash.each do |name, msg| 22: =content_tag :div, msg, :id => "flash_ 23: %div.clear 24: 25: = yield 26: = render :partial => "layouts/grid_right" if render_grid_right? 27: = render :partial => "layouts/footer" app/views/layouts/application.html.haml:24:in `_app_views_layouts_application_html_haml___4380000789490545718_2180251300_2717546578298801795' actionpack (3.0.5) lib/action_view/template.rb:135:in `block in render' activesupport (3.0.5) lib/active_support/notifications.rb:54:in `instrument' actionpack (3.0.5) lib/action_view/template.rb:127:in `render' actionpack (3.0.5) lib/action_view/render/layouts.rb:80:in `_render_layout' actionpack (3.0.5) lib/action_view/render/rendering.rb:62:in `block in _render_template' activesupport (3.0.5) lib/active_support/notifications.rb:52:in `block in instrument' activesupport (3.0.5) lib/active_support/notifications/instrumenter.rb:21:in `instrument' activesupport (3.0.5) lib/active_support/notifications.rb:52:in `instrument' actionpack (3.0.5) lib/action_view/render/rendering.rb:56:in `_render_template' actionpack (3.0.5) lib/action_view/render/rendering.rb:26:in `render' haml (3.0.25) lib/haml/helpers/action_view_mods.rb:13:in `render_with_haml' actionpack (3.0.5) lib/abstract_controller/rendering.rb:115:in `_render_template' actionpack (3.0.5) lib/abstract_controller/rendering.rb:109:in `render_to_body' actionpack (3.0.5) lib/action_controller/metal/renderers.rb:47:in `render_to_body' actionpack (3.0.5) lib/action_controller/metal/compatibility.rb:55:in `render_to_body' actionpack (3.0.5) lib/abstract_controller/rendering.rb:102:in `render_to_string' actionpack (3.0.5) lib/abstract_controller/rendering.rb:93:in `render' actionpack (3.0.5) lib/action_controller/metal/rendering.rb:17:in `render' actionpack (3.0.5) lib/action_controller/metal/instrumentation.rb:40:in `block (2 levels) in render' activesupport (3.0.5) lib/active_support/core_ext/benchmark.rb:5:in `block in ms' /Users/michaelkoper/.rvm/rubies/ruby-1.9.2-p180/lib/ruby/1.9.1/benchmark.rb:309:in `realtime' activesupport (3.0.5) lib/active_support/core_ext/benchmark.rb:5:in `ms' actionpack (3.0.5) lib/action_controller/metal/instrumentation.rb:40:in `block in render' actionpack (3.0.5) lib/action_controller/metal/instrumentation.rb:78:in `cleanup_view_runtime' activerecord (3.0.5) lib/active_record/railties/controller_runtime.rb:15:in `cleanup_view_runtime' actionpack (3.0.5) lib/action_controller/metal/instrumentation.rb:39:in `render' actionpack (3.0.5) lib/action_controller/metal/implicit_render.rb:10:in `default_render' actionpack (3.0.5) lib/action_controller/metal/mime_responds.rb:261:in `block in retrieve_response_from_mimes' actionpack (3.0.5) lib/action_controller/metal/mime_responds.rb:192:in `call' actionpack (3.0.5) lib/action_controller/metal/mime_responds.rb:192:in `respond_to' app/controllers/home_controller.rb:9:in `index' actionpack (3.0.5) lib/action_controller/metal/implicit_render.rb:4:in `send_action' actionpack (3.0.5) lib/abstract_controller/base.rb:150:in `process_action' actionpack (3.0.5) lib/action_controller/metal/rendering.rb:11:in `process_action' actionpack (3.0.5) lib/abstract_controller/callbacks.rb:18:in `block in process_action' activesupport (3.0.5) lib/active_support/callbacks.rb:445:in `_run__3968431659371141392__process_action__3163094469870857953__callbacks' activesupport (3.0.5) lib/active_support/callbacks.rb:409:in `_run_process_action_callbacks' activesupport (3.0.5) lib/active_support/callbacks.rb:93:in `run_callbacks' actionpack (3.0.5) lib/abstract_controller/callbacks.rb:17:in `process_action' actionpack (3.0.5) lib/action_controller/metal/instrumentation.rb:30:in `block in process_action' activesupport (3.0.5) lib/active_support/notifications.rb:52:in `block in instrument' activesupport (3.0.5) lib/active_support/notifications/instrumenter.rb:21:in `instrument' activesupport (3.0.5) lib/active_support/notifications.rb:52:in `instrument' actionpack (3.0.5) lib/action_controller/metal/instrumentation.rb:29:in `process_action' actionpack (3.0.5) lib/action_controller/metal/rescue.rb:17:in `process_action' actionpack (3.0.5) lib/abstract_controller/base.rb:119:in `process' actionpack (3.0.5) lib/abstract_controller/rendering.rb:41:in `process' actionpack (3.0.5) lib/action_controller/metal.rb:138:in `dispatch' actionpack (3.0.5) lib/action_controller/metal/rack_delegation.rb:14:in `dispatch' actionpack (3.0.5) lib/action_controller/metal.rb:178:in `block in action' actionpack (3.0.5) lib/action_dispatch/routing/route_set.rb:62:in `call' actionpack (3.0.5) lib/action_dispatch/routing/route_set.rb:62:in `dispatch' actionpack (3.0.5) lib/action_dispatch/routing/route_set.rb:27:in `call' rack-mount (0.6.13) lib/rack/mount/route_set.rb:148:in `block in call' rack-mount (0.6.13) lib/rack/mount/code_generation.rb:93:in `block in recognize' rack-mount (0.6.13) lib/rack/mount/code_generation.rb:68:in `optimized_each' rack-mount (0.6.13) lib/rack/mount/code_generation.rb:92:in `recognize' rack-mount (0.6.13) lib/rack/mount/route_set.rb:139:in `call' actionpack (3.0.5) lib/action_dispatch/routing/route_set.rb:492:in `call' haml (3.0.25) lib/sass/plugin/rack.rb:41:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/best_standards_support.rb:17:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/head.rb:14:in `call' rack (1.2.1) lib/rack/methodoverride.rb:24:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/params_parser.rb:21:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/flash.rb:182:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/session/abstract_store.rb:149:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/cookies.rb:302:in `call' activerecord (3.0.5) lib/active_record/query_cache.rb:32:in `block in call' activerecord (3.0.5) lib/active_record/connection_adapters/abstract/query_cache.rb:28:in `cache' activerecord (3.0.5) lib/active_record/query_cache.rb:12:in `cache' activerecord (3.0.5) lib/active_record/query_cache.rb:31:in `call' activerecord (3.0.5) lib/active_record/connection_adapters/abstract/connection_pool.rb:354:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/callbacks.rb:46:in `block in call' activesupport (3.0.5) lib/active_support/callbacks.rb:415:in `_run_call_callbacks' actionpack (3.0.5) lib/action_dispatch/middleware/callbacks.rb:44:in `call' rack (1.2.1) lib/rack/sendfile.rb:107:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/remote_ip.rb:48:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/show_exceptions.rb:47:in `call' railties (3.0.5) lib/rails/rack/logger.rb:13:in `call' rack (1.2.1) lib/rack/runtime.rb:17:in `call' activesupport (3.0.5) lib/active_support/cache/strategy/local_cache.rb:72:in `call' rack (1.2.1) lib/rack/lock.rb:11:in `block in call' <internal:prelude>:10:in `synchronize' rack (1.2.1) lib/rack/lock.rb:11:in `call' actionpack (3.0.5) lib/action_dispatch/middleware/static.rb:30:in `call' railties (3.0.5) lib/rails/application.rb:168:in `call' railties (3.0.5) lib/rails/application.rb:77:in `method_missing' railties (3.0.5) lib/rails/rack/log_tailer.rb:14:in `call' rack (1.2.1) lib/rack/content_length.rb:13:in `call' rack (1.2.1) lib/rack/chunked.rb:15:in `call' rack (1.2.1) lib/rack/handler/mongrel.rb:67:in `process' mongrel (1.2.0.pre2) lib/mongrel.rb:165:in `block in process_client' mongrel (1.2.0.pre2) lib/mongrel.rb:164:in `each' mongrel (1.2.0.pre2) lib/mongrel.rb:164:in `process_client' mongrel (1.2.0.pre2) lib/mongrel.rb:291:in `block (2 levels) in run'
Using rake (0.8.7) Using RedCloth (4.2.2) Using abstract (1.0.0) Using activesupport (3.0.5) Using builder (2.1.2) Using i18n (0.5.0) Using activemodel (3.0.5) Using erubis (2.6.6) Using rack (1.2.1) Using rack-mount (0.6.13) Using rack-test (0.5.7) Using tzinfo (0.3.24) Using actionpack (3.0.5) Using mime-types (1.16) Using polyglot (0.3.1) Using treetop (1.4.9) Using mail (2.2.15) Using actionmailer (3.0.5) Using arel (2.0.9) Using activerecord (3.0.5) Using activeresource (3.0.5) Using authlogic (2.1.6) Using xml-simple (1.0.14) Using aws-s3 (0.6.2) Using block_helpers (0.3.3) Using bundler (1.0.10) Using diff-lcs (1.1.2) Using json (1.4.6) Using gherkin (2.3.4) Using term-ansicolor (1.0.5) Using cucumber (0.10.0) Using cucumber-rails (0.3.2) Using daemons (1.0.10) Using database_cleaner (0.6.5) Using factory_girl (1.3.3) Using faker (0.9.5) Using formtastic (1.2.3) Using gem_plugin (0.2.3) Using haml (3.0.25) Using thor (0.14.6) Using railties (3.0.5) Using rails (3.0.5) Using kaminari (0.10.4) Using mongrel (1.2.0.pre2) Using mysql2 (0.2.6) Using nokogiri (1.4.4) Using paperclip (2.3.8) Using rspec-core (2.5.1) Using rspec-expectations (2.5.0) Using rspec-mocks (2.5.0) Using rspec (2.5.0) Using yard (0.6.4) Using pickle (0.4.4) Using populator (1.0.0) Using rspec-rails (2.5.0) Using webrat (0.7.3)
Encoding.default_external = Encoding::UTF_8 Encoding.default_internal = Encoding::UTF_8
\begin{document} <%= yield.force_encoding("UTF-8") %> \end{document}
add_column :cms_push_msgs, :android_content, :string
CSV.foreach("file.txt", encoding: "UTF-8") do |row| foo, bar, ... = row end
require Rake::Task.clear Sample::Application.load_tasks class RakeController < ApplicationController def run Rake::Task[params[:task]].reenable Rake::Task[params[:task]].invoke end end
class SomeController < ApplicationController def whatever SomeServiceObject.call end end
namespace :example do desc task :important_task do SomeServiceObject.call end end
assert some_string != "some value" assert clients.empty?, "Isn invariant "Lists with different sizes?" do one_variable = calculate_some_value other_variable = calculate_some_other_value one_variable > other_variable end
def assert(msg=nil) if DEBUG raise msg || "Assertion failed!" unless yield end end
$ jekyll serve [...] Server address: http: Server running... press ctrl-c to stop.
$ jekyll serve --host=0.0.0.0 [...] Server address: http: Server running... press ctrl-c to stop.
irb[0]> x = (1..1000000000).to_a [printout out the whole array]
irb(main):018:0> x = 1; c = 0 => 0 irb(main):019:0> x => 1 irb(main):020:0> c => 0
irb(main):021:0> (c += x; x += 1) while x < 10 => nil irb(main):022:0> x => 10 irb(main):023:0> c => 45
attr_reader :property1_enabled attr_reader :property2_enabled attr_reader :property3_enabled alias_method :property1_enabled?, :property1_enabled alias_method :property2_enabled?, :property2_enabled alias_method :property3_enabled?, :property3_enabled
attr_reader :property1_enabled; alias_method :property1_enabled?, :property1_enabled attr_reader :property2_enabled; alias_method :property2_enabled?, :property2_enabled attr_reader :property3_enabled; alias_method :property3_enabled?, :property3_enabled
a = [2, 3 , 1, 2, 3].reduce(Hash.new(0)) { |h, num| h[num] += 1; h }
rvm gemset rename current_gemset_name new_gemset_name
$ irb irb(main):001:0> require => true irb(main):002:0> fm = FileMagic.new => irb(main):003:0> fm.file( => "Zip archive data, at least v2.0 to extract" irb(main):004:0>
def get_image_extension(local_file_path) png = Regexp.new("\x89PNG".force_encoding("binary")) jpg = Regexp.new("\xff\xd8\xff\xe0\x00\x10JFIF".force_encoding("binary")) jpg2 = Regexp.new("\xff\xd8\xff\xe1(.*){2}Exif".force_encoding("binary")) case IO.read(local_file_path, 10) when /^GIF8/ when /^ when /^ when /^ else mime_type = `file raise UnprocessableEntity, "unknown file type" if !mime_type mime_type.split( end end
class File def mime_type `file --brief --mime-type end def charset `file --brief --mime end end
def unprocess_move(board, move) if move[0].instance_of?(Array) multi_move = @multi_move.pop(2).reverse multi_move.each do |single_move| unapply_move(board, single_move) end else board = unapply_move(board, move) end board end
class Foo def initialize @foo = 5 end end foo = Foo.new puts foo.instance_variable_get(:@foo)
foo.instance_variable_set(:@foo, 12) puts foo.instance_variable_get(:@foo)
class A def qwerty; @q; end def qwerty=(value); @q = value; end def asdf; self.qwerty = 4; end def xxx; asdf; end def dump; puts "qwerty = end a = A.new a.xxx a.dump
using System; public class A { public A() {} int q; public int qwerty { get { return q; } set { q = value; } } public void asdf() { qwerty = 4; } public void xxx() { asdf(); } public void dump() { Console.WriteLine("qwerty = {0}", qwerty); } } public class Test { public static void Main() { A a = new A(); a.xxx(); a.dump(); } }
using System; public class A { public A() {} public int test { get { return 4; }} public int useVariable() { int test = 5; return test; } public int useMethod() { int test = 5; return this.test; } } public class Test { public static void Main() { A a = new A(); Console.WriteLine("{0}", a.useVariable()); Console.WriteLine("{0}", a.useMethod()); } }
class A def test 4 end def use_variable test = 5 test end def use_method test = 5 self.test end end a = A.new a.use_variable a.use_method
class ExampleClass attr_reader :last_set def method_missing(name, *args) if name.to_s =~ /=$/ @last_set = args.first else super end end def some_method some_variable = 5 puts some_variable end end
example = ExampleClass.new example.blah = example.last_set example.some_method example.last_set
C:\>gem env RubyGems Environment: - RUBYGEMS VERSION: 2.0.3 - RUBY VERSION: 2.0.0 (2013-02-24 patchlevel 0) [i386-mingw32] - INSTALLATION DIRECTORY: C:/sbox/ruby/dump/.gems - RUBY EXECUTABLE: C:/Ruby200/bin/ruby.exe - EXECUTABLE DIRECTORY: C:/sbox/ruby/dump/.gems/bin - RUBYGEMS PLATFORMS: - ruby - x86-mingw32 - GEM PATHS: - C:/sbox/ruby/dump/.gems - C:/Documents and Settings/User/.gem/ruby/2.0.0 - C:/Ruby200/lib/ruby/gems/2.0.0 - GEM CONFIGURATION: - :update_sources => true - :verbose => true - :backtrace => false - :bulk_threshold => 1000 - REMOTE SOURCES: - https:
C:\>bundle env Bundler 1.3.4 Ruby 2.0.0 (2013-02-24 patchlevel 0) [i386-mingw32] Rubygems 2.0.3 GEM_HOME C:\sbox\ruby\dump\.gems GEM_PATH
def show @category = Category.friendly.find(params[:id]) @categories = Category.all @search = @category.products.approved.order(updated_at: :desc).ransack(params[:q]) @products = @search.result.page(params[:page]).per(50) rate end
before_action :fetch_current_category, only: [:show,:edit,:update] before_action :fetch_categories, only: [:show,:edit,:update] before_action :fetch_search_results, only: [:show,:edit,:update] def show rate end private def fetch_current_category @category = Category.friendly.find(params[:id]) end def fetch_categories @categories = Category.all end def fetch_search_results @search = category.products.approved.order(updated_at: :desc).ransack(params[:q]) @products = @search.result.page(params[:page]).per(50) end
-bash: /usr/local/bin/pod: /usr/local/opt/ruby/bin/ruby: bad interpreter: No such file or directory
sudo gem uninstall cocoapods sudo gem install cocoapods
class Foo validates_presence_of :name before_validate :set_canonical_name private def set_canonical_name self.canonical_name ||= canonicalize(self.name) if self.name end def canonicalize(x) x.downcase. end end
>> "àáâãäå".mb_chars.normalize(:kd).gsub(/[^\x00-\x7F]/n, => "aaaaaa"
1.9.3-p392 :001 > require "i18n" => false 1.9.3-p392 :002 > I18n.transliterate("Olá Mundo!") => "Ola Mundo!"
string.tr( "ÀÁÂÃÄÅàáâãäåĀāĂăĄąÇçĆćĈĉĊċČčÐðĎďĐđÈÉÊËèéêëĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħÌÍÎÏìíîïĨĩĪīĬĭĮįİıĴĵĶķĸĹĺĻļĽľĿŀŁłÑñŃńŅņŇňŉŊŋÒÓÔÕÖØòóôõöøŌōŎŏŐőŔŕŖŗŘřŚśŜŝŞşŠšſŢţŤťŦŧÙÚÛÜùúûüŨũŪūŬŭŮůŰűŲųŴŵÝýÿŶŷŸŹźŻżŽž", "AAAAAAaaaaaaAaAaAaCcCcCcCcCcDdDdDdEEEEeeeeEeEeEeEeEeGgGgGgGgHhHhIIIIiiiiIiIiIiIiIiJjKkkLlLlLlLlLlNnNnNnNnnNnOOOOOOooooooOoOoOoRrRrRrSsSsSsSssTtTtTtUUUUuuuuUuUuUuUuUuUuWwYyyYyYZzZzZz" )
"Le cœur de la crémiére".parameterize => "le-coeur-de-la-cremiere"
irb -ractive_support/all > "àáâãäå".mb_chars.normalize(:kd).gsub(/\p{Mn}/, aaaaaa
"anything".parameterize.underscore.humanize.downcase
2.3.1 :045 > ActiveRecord::Base.connection.execute("SELECT unaccent( => {"unaccent"=>"aaaaaaAA"}
scope :with_canonical_name, -> (name) { where("unaccent(foos.name) iLIKE unaccent( }
<p>Unhappy? <%= link_to "Cancel my account", registration_path(resource_name), :confirm => "Are you sure?", :method => :delete %>.</p>
class RegistrationsController < Devise::RegistrationsController end
devise_for :users, :controllers => { :registrations =>
def destroy resource.destroy set_flash_message :notice, :destroyed sign_out_and_redirect(self.resource) end
class User < ActiveRecord::Base def soft_delete update_attribute(:deleted_at, Time.current) end end class RegistrationsController < Devise::RegistrationsController def destroy resource.soft_delete Devise.sign_out_all_scopes ? sign_out : sign_out(resource_name) set_flash_message :notice, :destroyed if is_navigational_format? respond_with_navigational(resource){ redirect_to after_sign_out_path_for(resource_name) } end end class RegistrationsController < Devise::RegistrationsController def destroy resource.soft_delete set_flash_message :notice, :destroyed sign_out_and_redirect(resource) end end
def active_for_authentication? super && !deleted_at end
$(document).ready(function() { $( alert( event.preventDefault(); }); });
class User << ActiveRecord::Base after_create :set_default_association def set_default_association self.create_profile end end
has_one :profile before_create :build_default_profile private def build_default_profile build_profile true end
class User < ActiveRecord::Base has_one :profile after_create :create_profile end
class User < ActiveRecord::Base has_one :profile before_create :build_associations def profile super || build_profile(avatar: "anon.jpg") end private def build_associations profile || true end end
alias_method :db_profile, :profile def profile self.profile = Profile.create(:user => self) if self.db_profile.nil? self.db_profile end
def profile_with_auto_build build_profile unless profile_without_auto_build profile_without_auto_build end alias_method_chain :profile, :auto_build
@emails = ["joe@example.com", "Peter@example.com", "alice@example.com"] @emails * "," => "joe@example.com", "Peter@example.com", "alice@example.com"
(3..5).to_a.product([2]).collect { |index| a[index] } [2].product((3..5).to_a).collect { |index| a[index] }
rows, cols = x,y grid = Array.new(rows) { Array.new(cols) }
require m = Matrix[ [1, 2, 3], [4, 5, 6] ] m.column(0)
class Array3D def initialize(d1,d2,d3) @data = Array.new(d1) { Array.new(d2) { Array.new(d3) } } end def [](x, y, z) @data[x][y][z] end def []=(x, y, z, value) @data[x][y][z] = value end end
a = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [21, 22, 23, 24, 25] ] puts a.transpose[2][1..2].inspect puts a[1..2].map {|r| r[2]}.inspect
2.0.0p247 :032 > list = Array.new(5) => [nil, nil, nil, nil, nil] 2.0.0p247 :033 > list.map!{ |x| x = [0] } => [[0], [0], [0], [0], [0]] 2.0.0p247 :034 > list[0][0] => 0
a = Array.new(Array.new(4)) 0.upto(a.length-1) do |i| 0.upto(a.length-1) do |j| a[i[j]] = 1 end end 0.upto(a.length-1) do |i| 0.upto(a.length-1) do |j| print a[i[j]] = 1 end puts "\n" end
a = [[0]*10]*10 row, col = 10, 10 a = [[0]*row]*col
2.1.1 :004 > m=Array.new(3,Array.new(3,true)) => [[true, true, true], [true, true, true], [true, true, true]]
class Thing def do_something end class << self def foo puts "I am end end end
t = Thing.new t.do_something => does something t.class.foo => "I am Thing" t.foo => NoMethodError: undefined method `foo'
class Awesomeness end class Awesome << Awesomeness end SyntaxError: (irb):3: syntax error, unexpected tLSHFT, expecting
>> defined?("Object".constantize) => "method" >> defined?("AClassNameThatCouldNotPossiblyExist".constantize) => "method"
>> Object.const_defined?( => false >> Account => Account(id: integer, username: string, google_api_key: string, created_at: datetime, updated_at: datetime, is_active: boolean, randomize_search_results: boolean, contact_url: string, hide_featured_results: boolean, paginate_search_results: boolean) >> Object.const_defined?( => true
amber = "Amber".constantize rescue nil if amber end
def class_send(class_name, method, *args) Object.const_defined?(class_name) ? Object.const_get(class_name).send(method, *args) : nil end
def class_send(class_name, method, *args) return nil unless Object.const_defined?(class_name) c = Object.const_get(class_name) c.respond_to?(method) ? c.send(method, *args) : nil end
validate :adapter_exists def adapter_exists Object.const_get("Irs:: rescue NameError => e errors.add(:adapter_name, end
class ClassValidator < ActiveModel::EachValidator def validate_each(record,attribute,value) unless value.split( record.errors.add attribute, end end end
class String def to_class(class_name) begin class_name = class_name.classify (optional bonus feature if using Rails) Object.const_get(class_name) rescue end end end > class Article > nil > puts Hello yes this is class
class A def foo end end file, line = A.instance_method(:foo).source_location file, line = A.new.method(:foo).source_location puts "Method foo is defined in
$ rails console > require > I18n::Backend::Simple.instance_method(:lookup).source.display def lookup(locale, key, scope = [], options = {}) init_translations unless initialized? keys = I18n.normalize_keys(locale, key, scope, options[:separator]) keys.inject(translations) do |result, _key| _key = _key.to_sym return nil unless result.is_a?(Hash) && result.has_key?(_key) result = result[_key] result = resolve(locale, _key, result, options.merge(:scope => nil)) if result.is_a?(Symbol) result end end => nil
puts File.read(OBJECT_TO_GET.method(:METHOD_FROM).source_location[0])
method = SomeConstant.method(:some_method_name) file_path, line = method.source_location IO.readlines(file_path)[line-1, 10]
class Method def source(limit=10) file, line = source_location if file && line IO.readlines(file)[line-1,limit] else nil end end end
pry(main)> show-method Array From: array.c in Ruby Core (C Method): Number of lines: 15 static VALUE rb_ary_select(VALUE ary) { VALUE result; long i; RETURN_ENUMERATOR(ary, 0, 0); result = rb_ary_new2(RARRAY_LEN(ary)); for (i = 0; i < RARRAY_LEN(ary); i++) { if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) { rb_ary_push(result, rb_ary_elt(ary, i)); } } return result; }
require User.method(:last).source User.method(:last).source_location
JSON.dump object JSON.generate object object.to_json
class A def initialize a=[1,2,3], b= @a = a @b = b end end
class A def to_json { end def self.from_json string data = JSON.load string self.new data[ end end
class JSONable def to_json hash = {} self.instance_variables.each do |var| hash[var] = self.instance_variable_get var end hash.to_json end def from_json! string JSON.load(string).each do |var, val| self.instance_variable_set var, val end end end
require class A def initialize a=[1,2,3], b= @a = a @b = b end end a = A.new puts Oj::dump a, :indent => 2
require class User attr_accessor :name, :age def initialize(name, age) @name = name @age = age end def as_json(options={}) { name: @name, age: @age } end def to_json(*options) as_json(*options).to_json(*options) end end user = User.new("Foo Bar", 42) puts user.to_json
sampleObj.name sampleObj.last_name Jbuilder.encode do |json| json.name sampleObj.name json.last_name sampleObj.last_name end
i = 0 my_array.each do |item| if i==0 end i += 1 end
my_array.each_with_index do |item, index| if index == 0 end end
my_array.each_with_index do |item, i| item.do_something if i==0 end
irb(main):001:0> nums = (1..10).to_a => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] irb(main):003:0> nums.each_with_index do |num, idx| irb(main):004:1* if idx == 0 irb(main):005:2> puts "At index irb(main):006:2> end irb(main):007:1> end At index 0, the number is 1. => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
ar = %w(reversed hello world) puts ar.shift.upcase ar.each{|item| puts item.reverse}
> l=[1,2,3,4] => [1, 2, 3, 4] > l.inject(0) {|sum, elem| sum+elem} => 10
> puts fruits.inject("I like to eat: ") {|acc, elem| acc << elem << " "} I like to eat: apples pears peaches plums oranges => nil
{% if page.type == "post" %} {% include post.html %} {% elseif page.class == "contact" %} {% include contact.html %} {% else %} {{ content }} {% endif %}
{% if page.type == "post" %} {% include post.html %} {% elsif page.class == "contact" %} {% include contact.html %} {% else %} {{ content }} {% endif %}
Ignoring bcrypt-3.1.11 because its extensions are not built. Try: gem pristine bcrypt --version 3.1.11 Ignoring bcrypt-3.1.10 because its extensions are not built. Try: gem pristine bcrypt --version 3.1.10 Ignoring binding_of_caller-0.7.2 because its extensions are not built. Try: gem pristine binding_of_caller --version 0.7.2 Ignoring byebug-9.0.5 because its extensions are not built. Try: gem pristine byebug --version 9.0.5 Ignoring byebug-5.0.0 because its extensions are not built. Try: gem pristine byebug --version 5.0.0 Ignoring concurrent-ruby-ext-1.0.2 because its extensions are not built. Try: gem pristine concurrent-ruby-ext --version 1.0.2 Ignoring debug_inspector-0.0.2 because its extensions are not built. Try: gem pristine debug_inspector --version 0.0.2
rvm implode gem uninstall rvm rm -rf ~/.rvm rm -rf ~/.rvmrc
rbenv clean sudo apt-get remove rbenv rm -rf ~/.rbenv
rvm list rvm use ruby-version rvm remove ruby-useless-version
MyModel.where(MyModel.arel_table[:created_at].lt(2.days.ago))
scope :arel, ->(column, predication, *args) { where(arel_table[column].public_send(predication, *args)) }
MyModel.custom_scope1.arel(:created_at, :lt, 2.days.ago).arel(:updated_at, :gt, 2.days.ago).custom_scope2
MyTable.where(event_date: 2.days.from_now..DateTime::Infinity.new)
options = { :font_size => 10, :font_family => "Arial" }
s = SomeObject.new method = s.method(:dynamic_method) method.call
class Foo def method_missing(name) " end end Foo.new.send(:bar) Foo.new.method(:bar).call
require class Foo def bar; end end Benchmark.bm(4) do |b| b.report("send") { 1_000_000.times { Foo.new.send(:bar) } } b.report("call") { 1_000_000.times { Foo.new.method(:bar).call } } end
user system total real send 0.210000 0.000000 0.210000 ( 0.215181) call 0.740000 0.000000 0.740000 ( 0.739262)
require class Foo def bar; end end foo = Foo.new foo_bar = foo.method(:bar) Benchmark.bm(4) do |b| b.report("send") { 1_000_000.times { foo.send(:bar) } } b.report("call") { 1_000_000.times { foo_bar.call } } end
user system total real send 0.080000 0.000000 0.080000 ( 0.088685) call 0.110000 0.000000 0.110000 ( 0.108249)
require class FooBar def name; end end el = FooBar.new Benchmark.ips do |x| x.report( x.report( x.report( x.report( x.report( x.compare! end
Warming up -------------------------------------- plain 236.448k i/100ms eval 20.743k i/100ms method call 131.408k i/100ms send sym 205.491k i/100ms send str 168.137k i/100ms Calculating ------------------------------------- plain 9.150M (± 6.5%) i/s - 45.634M in 5.009566s eval 232.303k (± 5.4%) i/s - 1.162M in 5.015430s method call 2.602M (± 4.5%) i/s - 13.009M in 5.010535s send sym 6.729M (± 8.6%) i/s - 33.495M in 5.016481s send str 4.027M (± 5.7%) i/s - 20.176M in 5.027409s Comparison: plain: 9149514.0 i/s send sym: 6729490.1 i/s - 1.36x slower send str: 4026672.4 i/s - 2.27x slower method call: 2601777.5 i/s - 3.52x slower eval: 232302.6 i/s - 39.39x slower
receiver.send(method_that_changes_dynamically, argument) eval "
number_with_precision(1.5, :precision => 2) => 1.50
<% price = 45.9999 %> <price><%= number_to_currency(price)%></price> => <price>$45.99</price>
arr = ["apples", "bananas", "coconuts", "watermelons"]
def f(fruit) fruit + "!" end arr = ["apples", "bananas", "coconuts", "watermelons"] h = Hash[ *arr.collect { |v| [ v, f(v) ] }.flatten ]
{"watermelons"=>"watermelons!", "bananas"=>"bananas!", "apples"=>"apples!", "coconuts"=>"coconuts!"}
Benchmark.measure { 100000.times { Hash[arr.map{ |a| [a.id, a] }] } }
Benchmark.measure { 100000.times { h = Hash[arr.collect { |v| [v.id, v] }] } }
Benchmark.measure { 100000.times { hash = {} arr.each { |a| hash[a.id] = a } } }
Benchmark.measure { 100000.times { arr.each_with_object({}) { |v, h| h[v.id] = v } } }
array = ["apples", "bananas", "coconuts", "watermelons"] hash = array.inject({}) { |h,fruit| h.merge(fruit => f(fruit)) }
Hash[*array.reduce([]) { |memo, fruit| memo << fruit << f(fruit) }]
2.1.5 :026 > array = ["apples", "bananas", "coconuts", "watermelons"] => ["apples", "bananas", "coconuts", "watermelons"] 2.1.5 :027 > Hash[*array.reduce([]) { |memo, fruit| memo << fruit << fruit.length }] => {"apples"=>6, "bananas"=>7, "coconuts"=>8, "watermelons"=>11} 2.1.5 :028 >
["value1", "value2", "value3"] {"key1" => "value1"}
>> data = { => {"cow"=>"Fleante", "horse"=>"Gregoire", "dog"=>"Flemeale"} >> y data --- cow: Fleante horse: Gregoire dog: Flemeale
>> a = ["value1", "value2", "value3"] => ["value1", "value2", "value3"] >> a.inspect => "[\"value1\", \"value2\", \"value3\"]" >> a = {"key1" => "value1"} => {"key1"=>"value1"} >> a.inspect => "{\"key1\"=>\"value1\"}"
require pp({ :hello => :world, :this => [ => {:hello=>:world, :this=>["is", "an", "array"]}
h => {"67676.mpa"=>{:link=>"pool/sdafdsaff", :size=>4556}} > h.each do |key, value| > puts key > puts value > end 67676.mpa linkpool/sdafdsaffsize4556
h.each do |key, value| puts key value.each do |k,v| puts k puts v end end
h.each do |key, value| puts key value.values.each do |v| puts v end end
def ihash(h) h.each_pair do |k,v| if v.is_a?(Hash) puts "key: ihash(v) else puts "key: end end end
h = { "x" => "a", "y" => { "y1" => { "y2" => "final" }, "yy1" => "hello" } } ihash(h)
class Hash def nested_each_pair self.each_pair do |k,v| if v.is_a?(Hash) v.nested_each_pair {|k,v| yield k,v} else yield(k,v) end end end end {"root"=>{:a=>"tom", :b=>{:c => 1, :x => 2}}}.nested_each_pair{|k,v| puts k puts v }
h.each do |key, value| puts key puts value[:link] puts value[:size] end
> h = {"67676.mpa"=>{:link=>"pool/sdafdsaff", :size=>4556}} > h.values.each do |key, value| > puts " > end link pool/sdafsaff size 4556
threads = [] elemets.each do |element| threads.push(Thread.new{process(element)}} end threads.each { |aThread| aThread.join }
>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].each_slice(4) {|a| p a} [1, 2, 3, 4] [5, 6, 7, 8] [9, 10, 11, 12]
elements.each_slice(4) do | batch | batch.each do | element | threads.push(Thread.new{process(element)}} end (do stuff to check to see if the threads are done, otherwise wait ) end
require elements = [1,2,3,4,5,6,7,8,9,10] def process(element) puts "working on sleep rand * 10 end queue = Queue.new elements.each{|e| queue << e } threads = [] 4.times do threads << Thread.new do while (e = queue.pop(true) rescue nil) process(e) end end end threads.each {|t| t.join }
x = (1..10).to_a 0.step(x.size - 1, 4) do |i| p x.slice(i, 4) p x[i, 4] end
class Array def / len a = [] each_with_index do |x,i| a << [] if i % len == 0 a.last << x end a end end
my_model_instance = MyModel.new file = File.open(file_path) my_model_instance.attachment = file file.close my_model_instance.save!
class MyModel < ActiveRecord::Base has_attached_file :attachment end
photo_path = Dir.glob(photo_path).entries.each do |e| model = Model.find(<query here>) model.attachment = File.open(e) model.save end
Class Model_Name < ActiveRecord::Base has_attached_file :my_attachment, :params_for_attachment
my_instance = Model_name.new my_instance.my_attachment = File.open( my_instance.save!
>> => "ust" >> SyntaxError: compile error (irb):2: syntax error, unexpected from (irb):2
-8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 <- error| you can use this | error ->
string = string[1..string.length] string[1..string.size]
require Benchmark.bm 10 do |bench| bench.report "Hash: " do 50_000_000.times do { name: "John Smith", age: 45 } end end bench.report "Struct: " do klass = Struct.new(:name, :age) 50_000_000.times do klass.new("John Smith", 45) end end end
ruby-1.9.1-p378 > Point = Struct.new(:x, :y) => Point ruby-1.9.1-p378 > p = Point.new(4,5) => ruby-1.9.1-p378 > p.x => 4 ruby-1.9.1-p378 > p.y => 5 ruby-1.9.1-p378 > p = {:x => 4, :y => 5} => {:x=>4, :y=>5} ruby-1.9.1-p378 > p.x NoMethodError: undefined method `x from (irb):7 from /Users/mr/.rvm/rubies/ruby-1.9.1-p378/bin/irb:17:in `<main>' ruby-1.9.1-p378 > p[:x] => 4 ruby-1.9.1-p378 > p[:y] => 5
Customer = Struct.new(:name, :address) do def greeting; "Hello end Customer.new("Dave", "123 Main").greeting
Point = Struct.new(:x, :y) point_a = Point.new(0,0) point_b = Point.new(2,3) class Point def distance_to another_point Math.sqrt((self.x - another_point.x)**2 + (self.y - another_point.y)**2) end end puts point_a.distance_to point_b
class Monkey def chatter puts "I am a chattering monkey!" end def method_missing(m) puts "No def screech puts "This is the new screech." end end end m1 = Monkey.new m2 = Monkey.new m1.chatter m2.chatter def m1.screech puts "Aaaaaargh!" end m1.screech m2.screech m2.screech m1.screech m2.screech
def method_missing(m) puts "No define_method(:screech) do puts "This is the new screech." end end
ArgumentError: wrong number of arguments (2 for 1) method method_missing in untitled document at line 9 method method_missing in untitled document at line 9 at top level in untitled document at line 26 Program exited.
def method_missing(m) puts "No self.class.send(:define_method, :screech) do puts "This is the new screech." end end
def method_missing(m) puts "No class << self define_method(:screech) do puts "This is the new screech." end end end
class << self public :define_method end def method_missing(m) puts "No Monkey.define_method(:screech) do puts "This is the new screech." end
def method_missing(m) self.class.class_exec do define_method(:screech) {puts "This is the new screech."} end end
def combine_arrays(*arrays) if arrays.empty? yield else first, *rest = arrays first.map do |x| combine_arrays(*rest) {|*args| yield x, *args } end.flatten end end combine_arrays([1,2,3],[3,4,5],[6,7,8]) do |x,y,z| x+y+z end
require a = [1,2] b = [3,4] (a.product b).collect {|x, y| f(x, y)}
case x when 0 puts "Lots" when Numeric puts(100.0 / x) when /^\d+$/ puts(100.0 / x.to_f) default raise ArgumentError, "x is not a number or numeric string" end
if 0 == x puts "Lots" elsif x.is_a? Numeric puts(100.0 / x) elsif x =~ /^\d+$/ puts(100.0 / x.to_f) else raise ArgumentError, "x is not a number or numeric string" end
class Example def self.===(exception) puts "Triple equals has been called." true end end raise rescue Example
response = HTTParty.get( case response.code when 200 puts "All good!" when 404 puts "O noes not found!" when 500...600 puts "ZOMG ERROR end
begin HTTParty.get( rescue HTTParty::Error rescue StandardError end
response = HTTParty.post(uri, options) p response.success?
>gem install thin --no-ri --no-rdoc Temporarily enhancing PATH to include DevKit... Building native extensions. This could take a while... ERROR: Error installing thin: ERROR: Failed to build gem native extension. C:/Ruby/bin/ruby.exe extconf.rb checking for rb_trap_immediate in ruby.h,rubysig.h... no checking for rb_thread_blocking_region()... yes checking for inotify_init() in sys/inotify.h... no checking for __NR_inotify_init in sys/syscall.h... no checking for writev() in sys/uio.h... no checking for rb_thread_check_ints()... yes checking for rb_time_new()... yes checking for windows.h... yes checking for winsock.h... yes checking for main() in -lkernel32... yes checking for main() in -lrpcrt4... yes checking for main() in -lgdi32... yes checking for main() in -lssl... no creating Makefile make g++ -I. -IC:/Ruby/include/ruby-1.9.1/i386-mingw32 -I/C/Ruby/include/ruby-1.9.1/ruby/backward -I/C/Ru by/include/ruby-1.9.1 -I. -DBUILD_FOR_RUBY -DHAVE_RB_THREAD_BLOCKING_REGION -DHAVE_TBR -DHAVE_RB_THR EAD_CHECK_INTS -DHAVE_RB_TIME_NEW -DOS_WIN32 -DHAVE_WINDOWS_H -DHAVE_WINSOCK_H -DWITHOUT_SSL -DHAVE_ MAKE_PAIR -O3 -g -Wextra -Wno-unused-parameter -Wno-parentheses -Wpointer-arith -Wwrite-strings - Wno-missing-field-initializers -Wno-long-long -o binder.o -c binder.cpp In file included from project.h:137:0, from binder.cpp:20: binder.h:35:34: warning: type qualifiers ignored on function return type In file included from project.h:138:0, from binder.cpp:20: em.h:91:47: warning: type qualifiers ignored on function return type em.h:92:76: warning: type qualifiers ignored on function return type em.h:93:56: warning: type qualifiers ignored on function return type em.h:95:57: warning: type qualifiers ignored on function return type em.h:96:60: warning: type qualifiers ignored on function return type em.h:97:58: warning: type qualifiers ignored on function return type em.h:98:55: warning: type qualifiers ignored on function return type em.h:99:36: warning: type qualifiers ignored on function return type em.h:101:47: warning: type qualifiers ignored on function return type em.h:106:42: warning: type qualifiers ignored on function return type em.h:123:45: warning: type qualifiers ignored on function return type em.h:132:36: warning: type qualifiers ignored on function return type In file included from project.h:145:0, from binder.cpp:20: eventmachine.h:45:61: warning: type qualifiers ignored on function return type eventmachine.h:46:112: warning: type qualifiers ignored on function return type eventmachine.h:47:69: warning: type qualifiers ignored on function return type eventmachine.h:49:73: warning: type qualifiers ignored on function return type eventmachine.h:62:75: warning: type qualifiers ignored on function return type eventmachine.h:63:74: warning: type qualifiers ignored on function return type eventmachine.h:64:77: warning: type qualifiers ignored on function return type eventmachine.h:65:41: warning: type qualifiers ignored on function return type In file included from project.h:145:0, from binder.cpp:20: eventmachine.h:99:60: warning: type qualifiers ignored on function return type eventmachine.h:100:58: warning: type qualifiers ignored on function return type eventmachine.h:102:60: warning: type qualifiers ignored on function return type eventmachine.h:105:41: warning: type qualifiers ignored on function return type g++ -I. -IC:/Ruby/include/ruby-1.9.1/i386-mingw32 -I/C/Ruby/include/ruby-1.9.1/ruby/backward -I/C/Ru by/include/ruby-1.9.1 -I. -DBUILD_FOR_RUBY -DHAVE_RB_THREAD_BLOCKING_REGION -DHAVE_TBR -DHAVE_RB_THR EAD_CHECK_INTS -DHAVE_RB_TIME_NEW -DOS_WIN32 -DHAVE_WINDOWS_H -DHAVE_WINSOCK_H -DWITHOUT_SSL -DHAVE_ MAKE_PAIR -O3 -g -Wextra -Wno-unused-parameter -Wno-parentheses -Wpointer-arith -Wwrite-strings - Wno-missing-field-initializers -Wno-long-long -o cmain.o -c cmain.cpp In file included from project.h:137:0, from cmain.cpp:20: binder.h:35:34: warning: type qualifiers ignored on function return type In file included from project.h:138:0, from cmain.cpp:20: em.h:91:47: warning: type qualifiers ignored on function return type em.h:92:76: warning: type qualifiers ignored on function return type em.h:93:56: warning: type qualifiers ignored on function return type em.h:95:57: warning: type qualifiers ignored on function return type em.h:96:60: warning: type qualifiers ignored on function return type em.h:97:58: warning: type qualifiers ignored on function return type em.h:98:55: warning: type qualifiers ignored on function return type em.h:99:36: warning: type qualifiers ignored on function return type em.h:101:47: warning: type qualifiers ignored on function return type em.h:106:42: warning: type qualifiers ignored on function return type em.h:123:45: warning: type qualifiers ignored on function return type em.h:132:36: warning: type qualifiers ignored on function return type In file included from project.h:145:0, from cmain.cpp:20: eventmachine.h:45:61: warning: type qualifiers ignored on function return type eventmachine.h:46:112: warning: type qualifiers ignored on function return type eventmachine.h:47:69: warning: type qualifiers ignored on function return type eventmachine.h:49:73: warning: type qualifiers ignored on function return type eventmachine.h:62:75: warning: type qualifiers ignored on function return type eventmachine.h:63:74: warning: type qualifiers ignored on function return type eventmachine.h:64:77: warning: type qualifiers ignored on function return type eventmachine.h:65:41: warning: type qualifiers ignored on function return type In file included from project.h:145:0, from cmain.cpp:20: eventmachine.h:99:60: warning: type qualifiers ignored on function return type eventmachine.h:100:58: warning: type qualifiers ignored on function return type eventmachine.h:102:60: warning: type qualifiers ignored on function return type eventmachine.h:105:41: warning: type qualifiers ignored on function return type cmain.cpp:98:71: warning: type qualifiers ignored on function return type cmain.cpp:109:122: warning: type qualifiers ignored on function return type cmain.cpp:119:79: warning: type qualifiers ignored on function return type cmain.cpp:129:83: warning: type qualifiers ignored on function return type cmain.cpp:260:85: warning: type qualifiers ignored on function return type cmain.cpp:270:84: warning: type qualifiers ignored on function return type cmain.cpp:280:88: warning: type qualifiers ignored on function return type cmain.cpp:290:51: warning: type qualifiers ignored on function return type cmain.cpp:300:70: warning: type qualifiers ignored on function return type cmain.cpp:320:55: warning: type qualifiers ignored on function return type cmain.cpp:546:70: warning: type qualifiers ignored on function return type cmain.cpp:669:68: warning: type qualifiers ignored on function return type cmain.cpp: In function cmain.cpp:752:6: error: cannot convert , _stati64*)' make: *** [cmain.o] Error 1 Gem files will remain installed in C:/Ruby/lib/ruby/gems/1.9.1/gems/eventmachine-0.12.10 for inspect ion. Results logged to C:/Ruby/lib/ruby/gems/1.9.1/gems/eventmachine-0.12.10/ext/gem_make.out
> gem install specific_install Successfully installed backports-1.18.1 Successfully installed specific_install-0.2.3 2 gems installed ... > gem specific_install -l http: git installing from http: ... Successfully built RubyGem Name: eventmachine Version: 0.12.11 File: eventmachine-0.12.11.gem Temporarily enhancing PATH to include DevKit... Building native extensions. This could take a while... Successfully installed eventmachine-0.12.11 1 gem installed ... successfully installed
> gem install thin Temporarily enhancing PATH to include DevKit... Successfully installed thin-1.2.7-x86-mingw32 1 gem installed ... > thin start Using rack adapter Thin web server (v1.2.7 codename No Hup) Maximum connections set to 1024 Listening on 0.0.0.0:3000, CTRL+C to stop
gem install rack gem install eventmachine -l gem install thin –ignore-dependencies
$ gem install specific_install $ gem specific_install -l http:
class Model < ActiveRecord::Base attr_accessible nil end
def compare_3_values(a, b, c) a == b && a == c && b == c end
def compare_3_values(a_original, b_original, c_original) a, b, c = a_original.dup, b_original.dup, c_original.dup a == b && b == c && a == c end
false .== false == true => true false .== true == false => true true .== false == false => true false .== false == false => false true .== true == false false
false == false == true => true false == true == false => true true == false == false => true false == false == false => false true == true == false => false
(1 == 1) == 1 true == 1 1 == (1 == 1) 1 == true 1 .== 1 == 1 (1 == 1) == 1 true == 1 false .== false == true (false == false) == true true == true false .== true == false (false == true) == false false == false true .== false == false (true == false) == false false == false false .== false == false (false == false) == false true == false true .== true == false (true == true) == false true == false
<% unless @messages.blank? %> <% @messages.each do |message| %> <% <% end %> <% else %> You have no messages. <% end %>
<% @messages.each do |message| %> <% <% and_if_it_was_blank %> You have no messages. <% end %>
<% if @messages.each do |message| %> <% <% end.empty? %> You have no messages. <% end %>
<%= render(@user.recipes) || content_tag("p") do %> This user hasn <% end %>
def unless_empty(collection, message = "You have no messages", &block) if collection.empty? concat(message) else concat(capture(&block)) end end <% unless_empty @messages do %> <% <% end %>
<% @messages.each do |message| %> <% <% end %> <% if (@messages.blank?) %> You have no messages. <% end %>
<% render_each(:message) do |message| %> <% <% end %> You have no messages.
def render_each(item, &block) plural = " items = instance_variable_get("@ if (items.blank?) render(:partial => "common/empty/ else items.each(&block) end end
<% content_for :no_messages do %> <p> <strong>No Messages Found</strong> </p> <% end %> <%= render @messages || content_for(:no_messages) %>
<%= render(:partial => :collection => @user.messages) || content_for(:no_messages) %>
def render_action_or_empty (collection, options = {}) template = params[:template] || " template << render options.reverse_merge { :template => template } end
sudo apt-add-repository ppa:brightbox/ruby-ng-experimental && sudo apt-get update && sudo apt-get install -y ruby2.0 ruby2.0-dev ruby2.0-doc
sudo apt-add-repository ppa:brightbox/ruby-ng sudo apt-get update sudo apt-get install ruby2.2 ruby2.2-dev sudo update-alternatives --remove ruby /usr/bin/ruby2.2 sudo update-alternatives --remove irb /usr/bin/irb2.2 sudo update-alternatives --remove gem /usr/bin/gem2.2 sudo update-alternatives \ --install /usr/bin/ruby ruby /usr/bin/ruby2.2 50 \ --slave /usr/bin/irb irb /usr/bin/irb2.2 \ --slave /usr/bin/rake rake /usr/bin/rake2.2 \ --slave /usr/bin/gem gem /usr/bin/gem2.2 \ --slave /usr/bin/rdoc rdoc /usr/bin/rdoc2.2 \ --slave /usr/bin/testrb testrb /usr/bin/testrb2.2 \ --slave /usr/bin/erb erb /usr/bin/erb2.2 \ --slave /usr/bin/ri ri /usr/bin/ri2.2 update-alternatives --config ruby update-alternatives --display ruby $ irb irb(main):001:0> RUBY_VERSION => "2.2.0" $ ruby --version ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux-gnu]
sudo apt-get install python-software-properties sudo apt-add-repository ppa:brightbox/ruby-ng sudo apt-get update sudo apt-get -y install ruby2.2 ruby-switch sudo ruby-switch --set ruby2.2
$ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev
$ cd $ git clone https: $ echo $ echo $ exec $SHELL $ git clone https: $ echo $ exec $SHELL
@table1 = Table1.find(:all) @unique_activities = @table1.map{|t| t.activity}.uniq
@event_attendees = Activity.only(:user_id).where(:action =>
<% @event_attendees.each do |event_attendee| %> <%= event_attendee[ <% end %>
1.9.3p194 :015 > h={} => {} 1.9.3p194 :016 > h.merge(:key => => {:key=>"bar"} 1.9.3p194 :017 >
my_hash_static = {:header =>{:company => :type=> my_hash_dynamic = {:mp=>{:msg=>message, :no=>phones} } my_hash_full = my_hash_static[:body].push my_hash_dynamic
hash = {} hash.merge!(key: "value") hash.merge!(:key => "value") puts hash
hash = {} hash.store(:key, "value") hash.store("key", "value") puts hash
class Hello @hello = "hello" def display puts @hello end end h = Hello.new h.display
class Hello def create_some_state @hello = "hello" end end h = Hello.new p h.instance_variables h.create_some_state p h.instance_variables [] ["@hello"]
class Hello attr_accessor :hello end h = Hello.new p h.instance_variables h.hello = "hello" p h.instance_variables [] ["@hello"]
class Hello def initialize @hello = "hello" end def display puts @hello end end h = Hello.new h.display
class Point @n = 0 @totalX = 0 @totalY = 0 def initialize(x,y) @x,@y = x, y end def self.new(x,y) @n += 1 @totalX += x @totalY += y super end def self.report puts "Number of points created: puts "Average X coordinate: puts "Average Y coordinate: end end
class << self attr_accessor :n, :totalX, :totalY end
class T @@class_variable = "BBQ" @class_instance_variable_1 = "WTF" @class_instance_variable_2 = "LOL" def self.class_method puts "@@class_variable == puts "@class_instance_variable_1 == puts "@class_instance_variable_2 == puts "@instance_variable == end def initialize @instance_variable = "omg" @class_instance_variable_1 = "wtf" puts "@@class_variable == puts "@class_instance_variable_1 == puts "@class_instance_variable_2 == puts "@instance_variable == end def instance_method puts "@@class_variable == puts "@class_instance_variable_1 == puts "@class_instance_variable_2 == puts "@instance_variable == end end
irb> T.class_method @@class_variable == BBQ @class_instance_variable_1 == WTF @class_instance_variable_2 == LOL @instance_variable == nil => nil irb> t = T.new @@class_variable == BBQ @class_instance_variable_1 == wtf @class_instance_variable_2 == nil @instance_variable == omg => irb> t.instance_method @@class_variable == BBQ @class_instance_variable_1 == wtf @class_instance_variable_2 == nil @instance_variable == omg => nil irb> T.class_method @@class_variable == BBQ @class_instance_variable_1 == WTF @class_instance_variable_2 == LOL @instance_variable == nil => nil
class Vars @@classvar="foo" def test @instancevar="bar" end def Vars.show puts "classvar: puts "instancevar: end def instance_show puts "classvar: puts "instancevar: end end Vars::show vars = Vars.new vars.instance_show vars.test vars.instance_show
$offset = Point.new(100, 200); def draw(point) pointNew = $offset + point; drawAbsolute(point) end draw(Point.new(3, 4));
class Point attr_accessor :x, :y def initialize(x = 0, y = 0) @x = x @y = y end def +(point) Point.new(self.x + point.x, self.y + point.y) end def draw(offset = nil) if offset.nil? new_point = self else new_point = self + offset end new_point.draw_absolute end def draw_absolute puts "x: end end first_point = Point.new(100, 200) second_point = Point.new(3, 4) second_point.draw(first_point)
require "test123" =~ /1/ => 4 Benchmark.measure{ 1000000.times { "test123" =~ /1/ } } => 0.610000 0.000000 0.610000 ( 0.578133) "test123"[/1/] => "1" Benchmark.measure{ 1000000.times { "test123"[/1/] } } => 0.718000 0.000000 0.718000 ( 0.750010) irb(main):019:0> "test123".match(/1/) => Benchmark.measure{ 1000000.times { "test123".match(/1/) } } => 1.703000 0.000000 1.703000 ( 1.578146)
require str = "aacaabc" re = Regexp.new( N = 4_000_000 Benchmark.bm do |b| b.report("str.match re\t") { N.times { str.match re } } b.report("str =~ re\t") { N.times { str =~ re } } b.report("str[re] \t") { N.times { str[re] } } b.report("re =~ str\t") { N.times { re =~ str } } b.report("re.match str\t") { N.times { re.match str } } if re.respond_to?(:match?) b.report("re.match? str\t") { N.times { re.match? str } } end end
$ ./bench-re.rb | sort -t $ user system total real re =~ str 2.390000 0.000000 2.390000 ( 2.397331) str =~ re 2.450000 0.000000 2.450000 ( 2.446893) str[re] 2.940000 0.010000 2.950000 ( 2.941666) re.match str 3.620000 0.000000 3.620000 ( 3.619922) str.match re 4.180000 0.000000 4.180000 ( 4.180083)
$ ./bench-re.rb | sort -t $ user system total real re =~ str 1.150000 0.000000 1.150000 ( 1.144880) str =~ re 1.160000 0.000000 1.160000 ( 1.150691) str[re] 1.330000 0.000000 1.330000 ( 1.337064) re.match str 2.250000 0.000000 2.250000 ( 2.255142) str.match re 2.270000 0.000000 2.270000 ( 2.270948)
$ ./bench-re.rb | sort -t $ user system total real re =~ str 3.540000 0.000000 3.540000 ( 3.535881) str =~ re 3.560000 0.000000 3.560000 ( 3.560657) str[re] 4.300000 0.000000 4.300000 ( 4.299403) re.match str 5.210000 0.010000 5.220000 ( 5.213041) str.match re 6.000000 0.000000 6.000000 ( 6.000465)
$ ./bench-re.rb | sort -t $ user system total real re.match? str 0.690000 0.010000 0.700000 ( 0.682934) re =~ str 1.040000 0.000000 1.040000 ( 1.035863) str =~ re 1.040000 0.000000 1.040000 ( 1.042963) str[re] 1.340000 0.000000 1.340000 ( 1.339704) re.match str 2.040000 0.000000 2.040000 ( 2.046464) str.match re 2.180000 0.000000 2.180000 ( 2.174691)
2.4.0 > require => true 2.4.0 > Benchmark.measure{ 10000000.times { /^CVE-[0-9]{4}-[0-9]{4,}$/.match?("CVE-2018-1589") } } => 2.4.0 > Benchmark.measure{ 10000000.times { "CVE-2018-1589".match?(/^CVE-[0-9]{4}-[0-9]{4,}$/) } } =>
%Q[ <meta property="og:title" content=" <meta property="og:description" content=" ].html_safe
class Ilike def turtles(*args) puts args.inspect end end
begin ...some code... rescue => ex logger.error ex.message end
class Foo @@foos = 0 def initialize @@foos += 1 end def self.number_of_foos @@foos end end Foo.new Foo.new Foo.number_of_foos
require nil_obj = nil N = 10_000_000 puts RUBY_DESCRIPTION [1_000_000, 100_000.0, false, true, "string", /\w/].each do |obj| title = " puts "============================================================" puts "Running tests for obj = Benchmark.bm(15, title) do |x| implicit_obj_report = x.report("obj:") { N.times { obj } } implicit_nil_report = x.report("nil_obj:") { N.times { nil_obj } } explicit_obj_report = x.report("obj.nil?:") { N.times { obj.nil? } } explicit_nil_report = x.report("nil_obj.nil?:") { N.times { nil_obj.nil? } } not_obj_report = x.report("!obj:") { N.times { !obj } } not_nil_report = x.report("!nil_obj:") { N.times { !nil_obj } } not_not_obj_report = x.report("!!obj:") { N.times { !!obj } } not_not_nil_report = x.report("!!nil_obj:") { N.times { !!nil_obj } } equals_obj_report = x.report("obj == nil:") { N.times { obj == nil } } equals_nil_report = x.report("nil_obj == nil:") { N.times { nil_obj == nil } } not_equals_obj_report = x.report("obj != nil:") { N.times { obj != nil } } not_equals_nil_report = x.report("nil_obj != nil:") { N.times { nil_obj != nil } } end end
ruby 2.2.5p319 (2016-04-26 revision 54774) [x86_64-darwin14] ============================================================ Running tests for obj = 1000000 (Fixnum) user system total real obj: 0.970000 0.000000 0.970000 ( 0.987204) nil_obj: 0.980000 0.010000 0.990000 ( 0.980796) obj.nil?: 1.250000 0.000000 1.250000 ( 1.268564) nil_obj.nil?: 1.280000 0.000000 1.280000 ( 1.287800) !obj: 1.050000 0.000000 1.050000 ( 1.064061) !nil_obj: 1.070000 0.000000 1.070000 ( 1.170393) !!obj: 1.110000 0.000000 1.110000 ( 1.122204) !!nil_obj: 1.120000 0.000000 1.120000 ( 1.147679) obj == nil: 2.110000 0.000000 2.110000 ( 2.137807) nil_obj == nil: 1.150000 0.000000 1.150000 ( 1.158301) obj != nil: 2.980000 0.010000 2.990000 ( 3.041131) nil_obj != nil: 1.170000 0.000000 1.170000 ( 1.203015) ============================================================ Running tests for obj = 100000.0 (Float) user system total real obj: 0.940000 0.000000 0.940000 ( 0.947136) nil_obj: 0.950000 0.000000 0.950000 ( 0.986488) obj.nil?: 1.260000 0.000000 1.260000 ( 1.264953) nil_obj.nil?: 1.280000 0.000000 1.280000 ( 1.306817) !obj: 1.050000 0.000000 1.050000 ( 1.058924) !nil_obj: 1.070000 0.000000 1.070000 ( 1.096747) !!obj: 1.100000 0.000000 1.100000 ( 1.105708) !!nil_obj: 1.120000 0.010000 1.130000 ( 1.132248) obj == nil: 2.140000 0.000000 2.140000 ( 2.159595) nil_obj == nil: 1.130000 0.000000 1.130000 ( 1.151257) obj != nil: 3.010000 0.000000 3.010000 ( 3.042263) nil_obj != nil: 1.170000 0.000000 1.170000 ( 1.189145) ============================================================ Running tests for obj = false (FalseClass) user system total real obj: 0.930000 0.000000 0.930000 ( 0.933712) nil_obj: 0.950000 0.000000 0.950000 ( 0.973776) obj.nil?: 1.250000 0.000000 1.250000 ( 1.340943) nil_obj.nil?: 1.270000 0.010000 1.280000 ( 1.282267) !obj: 1.030000 0.000000 1.030000 ( 1.039532) !nil_obj: 1.060000 0.000000 1.060000 ( 1.068765) !!obj: 1.100000 0.000000 1.100000 ( 1.111930) !!nil_obj: 1.110000 0.000000 1.110000 ( 1.115355) obj == nil: 1.110000 0.000000 1.110000 ( 1.121403) nil_obj == nil: 1.100000 0.000000 1.100000 ( 1.114550) obj != nil: 1.190000 0.000000 1.190000 ( 1.207389) nil_obj != nil: 1.140000 0.000000 1.140000 ( 1.181232) ============================================================ Running tests for obj = true (TrueClass) user system total real obj: 0.960000 0.000000 0.960000 ( 0.964583) nil_obj: 0.970000 0.000000 0.970000 ( 0.977366) obj.nil?: 1.260000 0.000000 1.260000 ( 1.265229) nil_obj.nil?: 1.270000 0.010000 1.280000 ( 1.283342) !obj: 1.040000 0.000000 1.040000 ( 1.059689) !nil_obj: 1.070000 0.000000 1.070000 ( 1.068290) !!obj: 1.120000 0.000000 1.120000 ( 1.154803) !!nil_obj: 1.130000 0.000000 1.130000 ( 1.155932) obj == nil: 1.100000 0.000000 1.100000 ( 1.102394) nil_obj == nil: 1.130000 0.000000 1.130000 ( 1.160324) obj != nil: 1.190000 0.000000 1.190000 ( 1.202544) nil_obj != nil: 1.200000 0.000000 1.200000 ( 1.200812) ============================================================ Running tests for obj = string (String) user system total real obj: 0.940000 0.000000 0.940000 ( 0.953357) nil_obj: 0.960000 0.000000 0.960000 ( 0.962029) obj.nil?: 1.290000 0.010000 1.300000 ( 1.306233) nil_obj.nil?: 1.240000 0.000000 1.240000 ( 1.243312) !obj: 1.030000 0.000000 1.030000 ( 1.046630) !nil_obj: 1.060000 0.000000 1.060000 ( 1.123925) !!obj: 1.130000 0.000000 1.130000 ( 1.144168) !!nil_obj: 1.130000 0.000000 1.130000 ( 1.147330) obj == nil: 2.320000 0.000000 2.320000 ( 2.341705) nil_obj == nil: 1.100000 0.000000 1.100000 ( 1.118905) obj != nil: 3.040000 0.010000 3.050000 ( 3.057040) nil_obj != nil: 1.150000 0.000000 1.150000 ( 1.162085) ============================================================ Running tests for obj = (?-mix:\w) (Regexp) user system total real obj: 0.930000 0.000000 0.930000 ( 0.939815) nil_obj: 0.960000 0.000000 0.960000 ( 0.961852) obj.nil?: 1.270000 0.000000 1.270000 ( 1.284321) nil_obj.nil?: 1.260000 0.000000 1.260000 ( 1.275042) !obj: 1.040000 0.000000 1.040000 ( 1.042543) !nil_obj: 1.040000 0.000000 1.040000 ( 1.047280) !!obj: 1.120000 0.000000 1.120000 ( 1.128137) !!nil_obj: 1.130000 0.000000 1.130000 ( 1.138988) obj == nil: 1.520000 0.010000 1.530000 ( 1.529547) nil_obj == nil: 1.110000 0.000000 1.110000 ( 1.125693) obj != nil: 2.210000 0.000000 2.210000 ( 2.226783) nil_obj != nil: 1.170000 0.000000 1.170000 ( 1.169347)
arr = [1, 2, 3] arr.any?(&:nil?) arr.any?{|x| x == nil} ! arr.all?
x = { "one" => "one", "two" => "two", "three" => "three"} y = x.some_function y == { "one" => "one", "two" => "two"}
wanted_keys = %w[one two] x = { "one" => "one", "two" => "two", "three" => "three"} x.select { |key,_| wanted_keys.include? key }
y = x.slice("one", "two") y = x.except("three") x.slice!("one", "two")
x = { "one" => "one", "two" => "two", "three" => "three"} y = x.reject {|key,value| key == "three" } y == { "one" => "one", "two" => "two"}
hash = { "one" => "one", "two" => "two", "three" => "three"} keys_whitelist = %W(one two) hash.slice(*keys_whitelist)
hash = { "one" => "one", "two" => "two", "three" => "three"} keys_whitelist = %W(one two) Hash[hash.find_all{|k,v| keys_whitelist.include?(k)}]
wanted_keys = %w[one two] x = { "one" => "one", "two" => "two", "three" => "three"} x.reject { |key,_| !wanted_keys.include? key } =>{ "one" => "one", "two" => "two"}
x = { "one" => "one", "two" => "two", "three" => "three"} matcher = ->(key,value) { !key[/three/] } x.select(&matcher) == { "one" => "one", "two" => "two"}
>> B.new.class >> B.new.parent >> B.parent >> B.parent.class
class A end class B < A end B.superclass B.superclass.name
> a = Array.new => [] > a.class.ancestors => [Array, Enumerable, Object, Kernel, BasicObject]
class A < ActiveRecord::Base end class B < A end > A.superclass => ActiveRecord::Base > B.superclass => A > A.base_class => A > B.base_class => A
module Mux def sam p "I am an module" end end class A include Mux end class B < A end class C < B end class D < A end
C.superclass => B B.superclass => A A.superclass => Object Object.superclass => BasicObject
C.ancestors => [C, B, A, Mux, Object, Kernel, BasicObject]
h.sort {|x,y| -(x[1]<=>y[1])} -- 16.7s h.sort {|x,y| y[1] <=> x[1]} -- 12.3s h.sort_by {|k,v| -v} -- 5.9s h.sort_by {|k,v| v}.reverse -- 3.7
require pdf_file_paths = [] Find.find( pdf_file_paths << path if path =~ /.*\.pdf$/ end
Warming up -------------------------------------- Find.find 124.000 i/100ms Dir.glob 515.000 i/100ms Calculating ------------------------------------- Find.find 1.242k (± 4.7%) i/s - 6.200k in 5.001398s Dir.glob 5.249k (± 4.5%) i/s - 26.265k in 5.014632s Comparison: Dir.glob: 5248.5 i/s Find.find: 1242.4 i/s - 4.22x slower
require require dir = Benchmark.ips do |x| x.report Find.find(dir).select { |f| f =~ /\*\.pdf/ } end x.report Dir.glob(" end x.compare! end
class Person < ActiveRecord::Base has_one :cell end class Cell < ActiveRecord::Base belongs_to :person end
class Person < ActiveRecord::Base has_one :cell end class Cell < ActiveRecord::Base has_one :person end
class Person < ActiveRecord::Base belongs_to :cell end class Cell < ActiveRecord::Base belongs_to :person end
class Person < ActiveRecord::Base has_one :cell end class Cell < ActiveRecord::Base belongs_to :person end
@cell.person.whatever_info and @person.cell.whatever_info.
if a.uniq.length == a.length puts "a does not contain duplicates" else puts "a does contain duplicates" end
array = [1, 2, 1, 3, 5, 4, 5, 5] => [1, 2, 1, 3, 5, 4, 5, 5] dup = array.select{|element| array.count(element) > 1 } => [1, 1, 5, 5, 5] dup.uniq => [1, 5]
dups = [1,1,1,2,2,3].group_by{|e| e}.keep_if{|_, e| e.length > 1}
class Array def uniq? self.length == self.uniq.length end end
irb(main):018:0> [1,2].uniq? => true irb(main):019:0> [2,2].uniq? => false
require Rake::TestTask.new do |t| t.pattern = "spec/*_spec.rb" end
require Minitest::Reporters.use!(Minitest::Reporters::SpecReporter.new) require
require "minitest/autorun" Dir.glob("**/*Test.rb") { |f| require_relative(f) }
require require options = { :exclude => [], } OptionParser.new do |opts| opts.on( options[:exclude] = css.split( end end.parse! commands = [] Find.find(File.dirname(__FILE__)) do |path| Find.prune if path =~ / if !File.directory?(path) && (path =~ /(.*)\.rb$/) if options[:exclude].none? {|e| path.include?(e)} commands << "ruby end end end command_string = commands.join(" && ") exec(command_string)
class TestEval def method1 puts "name: end end class_name = "TestEval" dummy = eval(" puts "dummy: dynamic_name = "TestEval2" class_string = """ class def method1 end end """ dummy2 = eval(class_string) puts "dummy2:
dynamic_name = "TestEval2" Object.const_set(dynamic_name, Class.new) dummy2 = eval(" puts "dummy2:
dynamic_name = "ClassName" Object.const_set(dynamic_name, Class.new { def method1() 42 end }) ClassName.new.method1
test_model_class = Class.new(ActiveRecord::Base) do def self.name end attr_accessor :foo, :bar end
module Redbeam def self.create_klasses(parent_klass, klasses) parent_klass.instance_eval do klasses.each do |klass, superklass| parent_klass.const_set klass, Class.new(superklass) end end end def self.create_modules(parent_klass, modules) parent_klass.instance_eval do modules.each do |new_module, supermodule| parent_klass.const_set new_module, Module.new { extend supermodule } end end end end
module Redbeam::Options Redbeam.create_klasses(self, [ [ ]) Redbeam.create_modules(self, [ [ ]) end
dynamic_name = "TestEval2" class_string = """ class def method1 end end """ eval(class_string) dummy2 = Object.const_get(dynamic_name) puts "dummy2:
irb(main):001:0> def foo=(bar) irb(main):002:1> p "foo= irb(main):003:1> end => nil
irb(main):004:0> defined?(foo=) SyntaxError: compile error (irb):4: syntax error, unexpected from (irb):4 from :0
defined? self.foo=() defined? self.foo = "bar" def foo=(bar) end defined? self.foo=() defined? self.foo = "bar"
respond_to? :foo= def foo=(bar) end respond_to? :foo=
def create @item = Item.new @item.current_user = current_user ... end
class Post < ActiveRecord::Base has_many :comments belongs_to :author, class_name: end class User < ActiveRecord::Base has_many: :posts end class Comment < ActiveRecord::Base belongs_to :post end
class PostsController < ActionController::Base def index @posts = Post.includes(:comments).latest(10) end end
class Admin::BaseController < ActionController::Base before_action: :auth, :set_current_user after_action: :unset_current_user private def auth @user = login_or_redirect end def set_current_user User.current = @user end def unset_current_user User.current = nil end end
class Admin::User < User def self.current=(user) Thread.current[:current_user] = user end def self.current Thread.current[:current_user] end end
class Admin::Post < Post before_save: :assign_author def default_scope where(author: User.current) end def assign_author self.author = User.current end end
class Admin::PostsController < Admin::BaseController def index @posts = Post.all end def new @post = Post.find_by_id(params[:id]) @post.attributes = params.require(:post).permit() if @post.save else end end end
class Admin::Comment < Comment validate: :check_posts_author private def check_posts_author unless post.author == User.current errors.add(:blog, end end end
class Node < ActiveRecord belongs_to :user def authorized?(user) user && ( user.admin? or self.user_id == user.id ) end end node.authorized? current_user
class ApplicationController < ActionController::Base before_filter do |c| User.current_user = User.find(c.session[:user]) unless c.session[:user].nil? end end class User < ActiveRecord::Base cattr_accessor :current_user end
def find_current_user (1..Kernel.caller.length).each do |n| RubyVM::DebugInspector.open do |i| current_user = eval "current_user rescue nil", i.frame_binding(n) return current_user unless current_user.nil? end end return nil end
def set_current_user Authorization.current_user = current_user end
auth = {:username => "test", :password => "test"} @blah = HTTParty.get("http: :basic_auth => auth)
consumers = YAML.load(" Rails.application.config.middleware.use OmniAuth::Builder do provider :twitter, consumers[ end
a = [1, 2, 3, 4, 5] a.each do |x| next if x < 3 a.delete x end a
a.delete_if do |element| if element >= 3 do_something_with(element) true end end
a = [1, 2, 3, 4, 5] b = a.select {|x| x < 3} puts b.inspect b.each {|i| puts i}
def load_plugins Dir.glob(File.dirname(__FILE__) + MyModule.class_eval File.read(f) end end
MyModule.constants.select {|c| MyModule.const_get(c).is_a? Class}
public Person(String name) { this.name = name; } public Person(String firstName, String lastName) { this(firstName + " " + lastName); }
class Person def initialize(name, lastName = nil) name = name + " " + lastName unless lastName.nil? @name = name end end class Person def initialize(args) name = args["name"] + " " + args["lastName"] unless args["lastName"].nil? @name = name end end class Person def initialize(*args) end end
class Person def self.new_using_both_names(first_name, last_name) self.new([first_name, last_name].join(" ")) end def self.new_using_single_name(single_name) self.new(single_name) end def initialize(name) @name = name end end
class Person def initialize(name, lastName = nil) name = name + " " + lastName unless lastName.nil? @name = name end end
class StatementItem attr_reader :category, :id, :time, :amount def initialize(item) case item when Order initialize_with_order(item) when Transaction initialize_with_transaction(item) end end def valid? !(@category && @id && @time && @amount).nil? end private def initialize_with_order(order) return nil if order.status != @category = @id = order.id @time = order.updated_at @amount = order.price end def initialize_with_transaction(transaction) @category = transaction.category @id = transaction.id @time = transaction.updated_at @amount = transaction.amount end end
class Person def initialize(name) @name = name end konstructor def from_two_names(first_name, last_name) @name = first_name + end end Person.new( Person.from_two_names(
class Person attr_reader :name def initialize(first: nil, last: nil) @name = [first, last].compact.join( end end Person.new(first: Person.new(first:
