subindex = @(A, r, c) A(r, c); % An anonymous function for 2-D indexing value = subindex(magic(5), 3, 3); % Use the function to index the matrix
paren = @(x, varargin) x(varargin{:}); curly = @(x, varargin) x{varargin{:}};
subs=@(M,i,j) M(i,j); >> for nit=1:10;tic;subs(magic(100),1:10,1:10);tlap(nit)=toc;end;mean(tlap) ans = 0.0103 >> for nit=1:10,tic;M=magic(100); M(1:10,1:10);tlap(nit)=toc;end;mean(tlap) ans = 0.0101
function [ element ] = getElem( matrix, index1, index2 ) element = matrix(index1, index2); end
M = magic(5); %create value = M(3,3); % extract useful data clear M; %free memory
>> tic; for i=1:1e6, feval( Elapsed time is 49.904117 seconds. >> tic; for i=1:1e6, builtin( Elapsed time is 51.485339 seconds.
function path = solve_maze(img_file) %% Init data img = imread(img_file); img = rgb2gray(img); maze = img > 0; start = [985 398]; finish = [26 399]; %% Init BFS n = numel(maze); Q = zeros(n, 2); M = zeros([size(maze) 2]); front = 0; back = 1; function push(p, d) q = p + d; if maze(q(1), q(2)) && M(q(1), q(2), 1) == 0 front = front + 1; Q(front, :) = q; M(q(1), q(2), :) = reshape(p, [1 1 2]); end end push(start, [0 0]); d = [0 1; 0 -1; 1 0; -1 0]; %% Run BFS while back <= front p = Q(back, :); back = back + 1; for i = 1:4 push(p, d(i, :)); end end %% Extracting path path = finish; while true q = path(end, :); p = reshape(M(q(1), q(2), :), 1, 2); path(end + 1, :) = p; if isequal(p, start) break; end end end
% x = 1:0.1:10; y1 = sin(x).*exp(-x/3) + 3; y2 = 3*exp(-(x-7).^2/2) + 1; % fh = figure( hold on plot(x,y1, plot(x,y2, plot(x,y2, xlim([0.95 10]) ylim([0 5]) set(gca, % annotation(fh, % im = export_fig( % im = padarray(im,[15 15 0],255); % sfc = size(im); [yy,xx]=ndgrid(1:7:sfc(1),1:7:sfc(2)); pts = [xx(:),yy(:)]; tf = cp2tform(pts+randn(size(pts)),pts, w = warning; warning off images:inv_lwm:cannotEvaluateTransfAtSomeOutputLocations imt = imtransform(im,tf); warning(w) % imt = imt(16:end-15,16:end-15,:); figure( imshow(imt)
% x = 1:0.1:10; y1 = sin(x).*exp(-x/3) + 3; y2 = 3*exp(-(x-7).^2/2) + 1; % x = x+randn(size(x))*0.01; y1 = y1+randn(size(x))*0.01; y2 = y2+randn(size(x))*0.01; % figure( hold on plot(x,y1, plot(x,y2, plot(x,y2, xlim([0.95 10]) ylim([0 5]) set(gca,
function hAxes = xkcd_axes(xkcdOptions, varargin) hAxes = axes(varargin{:}, axesUnits = get(hAxes, set(hAxes, axesPos = get(hAxes, set(hAxes, xPoints = round(axesPos(3)/10); yPoints = round(axesPos(4)/10); limits = [xlim(hAxes) ylim(hAxes)]; ranges = [abs(limits(2) - limits(1)) abs(limits(4) - limits(3))]; backColor = get(get(hAxes, xColor = get(hAxes, yColor = get(hAxes, line( line( xTicks = get(hAxes, if ~isempty(xTicks) yOffset = limits(3) - 0.05.*ranges(2); tickIndex = true(size(xTicks)); if ismember( tickIndex(1) = false; xkcd_arrow( yOffset, xColor); end if ismember( tickIndex(end) = false; xkcd_arrow( yOffset, xColor); end plot([1; 1]*xTicks(tickIndex), ... 0.5.*[-yOffset; yOffset]*ones(1, sum(tickIndex)), ... xLabels = cellstr(get(hAxes, for iLabel = 1:numel(xLabels) xkcd_text(xTicks(iLabel), yOffset, xLabels{iLabel}, ... end end yTicks = get(hAxes, if ~isempty(yTicks) xOffset = limits(1) - 0.05.*ranges(1); tickIndex = true(size(yTicks)); if ismember( tickIndex(1) = false; xkcd_arrow( [limits(3) + 0.02.*ranges(2) yTicks(1)], yColor); end if ismember( tickIndex(end) = false; xkcd_arrow( [yTicks(end) limits(4) - 0.02.*ranges(2)], yColor); end plot(0.5.*[-xOffset; xOffset]*ones(1, sum(tickIndex)), ... [1; 1]*yTicks(tickIndex), ... yLabels = cellstr(get(hAxes, for iLabel = 1:numel(yLabels) xkcd_text(xOffset, yTicks(iLabel), yLabels{iLabel}, ... end end function xkcd_arrow(arrowType, xArrow, yArrow, arrowColor) if ismember(arrowType, { xLine = linspace(xArrow(1), xArrow(2), 10); yLine = yArrow + rand(1, 10).*0.003.*ranges(2); arrowScale = 0.05.*ranges(1); if strcmp(arrowType, xArrow = xLine(1) + arrowScale.*[0 0.5 1 1 1 0.5]; yArrow = yLine(1) + arrowScale.*[0 0.125 0.25 0 -0.25 -0.125]; else xArrow = xLine(end) - arrowScale.*[0 0.5 1 1 1 0.5]; yArrow = yLine(end) + arrowScale.*[0 -0.125 -0.25 0 0.25 0.125]; end else xLine = xArrow + rand(1, 10).*0.003.*ranges(1); yLine = linspace(yArrow(1), yArrow(2), 10); arrowScale = 0.05.*ranges(2); if strcmp(arrowType, xArrow = xLine(1) + arrowScale.*[0 0.125 0.25 0 -0.25 -0.125]; yArrow = yLine(1) + arrowScale.*[0 0.5 1 1 1 0.5]; else xArrow = xLine(end) + arrowScale.*[0 -0.125 -0.25 0 0.25 0.125]; yArrow = yLine(end) - arrowScale.*[0 0.5 1 1 1 0.5]; end end line( patch( end end
function hText = xkcd_text(varargin) hText = text(varargin{:}); set(hText, backColor = get(hText, edgeColor = get(hText, if ~strcmp(backColor, hParent = get(hText, extent = get(hText, nLines = size(get(hText, extent = extent + [-0.5 -0.5 1 1].*0.25.*extent(4)./nLines; yPoints = 5*nLines; xPoints = round(yPoints*extent(3)/extent(4)); noiseScale = 0.05*extent(4)/nLines; set(hText, xBox = [linspace(extent(1), extent(1) + extent(3), xPoints) ... extent(1) + extent(3) + noiseScale.*rand(1, yPoints) ... linspace(extent(1) + extent(3), extent(1), xPoints) ... extent(1) + noiseScale.*rand(1, yPoints)]; yBox = [extent(2) + noiseScale.*rand(1, xPoints) ... linspace(extent(2), extent(2) + extent(4), yPoints) ... extent(2) + extent(4) + noiseScale.*rand(1, xPoints) ... linspace(extent(2) + extent(4), extent(2), yPoints)]; patch( hKids = get(hParent, set(hParent, end end
function hLine = xkcd_line(xData, yData, varargin) yData = yData + 0.01.*max(range(xData), range(yData)).*rand(size(yData)); line(xData, yData, varargin{:}, hLine = line(xData, yData, varargin{:}, end
xS = [0.0359 0.0709 0.1004 0.1225 0.1501 0.1759 0.2219 0.2477 0.2974 0.3269 0.3582 0.3895 0.4061 0.4337 0.4558 0.4797 0.5074 0.5276 0.5589 0.5810 0.6013 0.6179 0.6271 0.6344 0.6381 0.6418 0.6529 0.6713 0.6842 0.6934 0.7026 0.7118 0.7265 0.7376 0.7560 0.7726 0.7836 0.7965 0.8149 0.8370 0.8573 0.8867 0.9033 0.9346 0.9659 0.9843 0.9936]; yS = [0.2493 0.2520 0.2548 0.2548 0.2602 0.2629 0.2629 0.2657 0.2793 0.2657 0.2575 0.2575 0.2602 0.2629 0.2657 0.2766 0.2793 0.2875 0.3202 0.3856 0.4619 0.5490 0.6771 0.7670 0.7970 0.8270 0.8433 0.8433 0.8243 0.7180 0.6199 0.5272 0.4510 0.4128 0.3392 0.2711 0.2275 0.1757 0.1485 0.1131 0.1022 0.0858 0.0858 0.1022 0.1267 0.1567 0.1594]; xF = [0.0304 0.0488 0.0727 0.0967 0.1335 0.1630 0.2090 0.2348 0.2698 0.3011 0.3269 0.3545 0.3803 0.4153 0.4466 0.4724 0.4945 0.5110 0.5350 0.5516 0.5608 0.5700 0.5755 0.5810 0.5884 0.6013 0.6179 0.6363 0.6492 0.6584 0.6676 0.6731 0.6842 0.6860 0.6934 0.7007 0.7136 0.7265 0.7394 0.7560 0.7726 0.7818 0.8057 0.8444 0.8794 0.9107 0.9475 0.9751 0.9917]; yF = [0.0804 0.0940 0.0967 0.1049 0.1185 0.1458 0.1512 0.1540 0.1649 0.1812 0.1812 0.1703 0.1621 0.1594 0.1703 0.1975 0.2411 0.3065 0.3801 0.4782 0.5708 0.6526 0.7452 0.8106 0.8324 0.8488 0.8433 0.8270 0.7888 0.7343 0.6826 0.5981 0.5300 0.4782 0.3910 0.3420 0.2847 0.2248 0.1621 0.0995 0.0668 0.0395 0.0232 0.0177 0.0204 0.0232 0.0259 0.0204 0.0232]; xE = [0.0267 0.0488 0.0856 0.1409 0.1759 0.2164 0.2514 0.3011 0.3269 0.3637 0.3969 0.4245 0.4503 0.4890 0.5313 0.5608 0.5939 0.6344 0.6694 0.6934 0.7192 0.7394 0.7523 0.7689 0.7891 0.8131 0.8481 0.8757 0.9070 0.9346 0.9604 0.9807 0.9936]; yE = [0.0232 0.0232 0.0232 0.0259 0.0259 0.0259 0.0313 0.0259 0.0259 0.0259 0.0368 0.0395 0.0477 0.0586 0.0777 0.0886 0.1213 0.1730 0.2466 0.2902 0.3638 0.5082 0.6499 0.7916 0.8924 0.9414 0.9550 0.9387 0.9060 0.8760 0.8542 0.8379 0.8188]; hFigure = figure( hAxes = xkcd_axes({ hSpeed = xkcd_line(xS, yS, hFear = xkcd_line(xF, yF, hEmb = xkcd_line(xE, yE, hText = xkcd_text(0.27, 0.9, ... { hSpeedNote = xkcd_text(0.36, 0.35, { hSpeedLine = xkcd_line([0.4116 0.4282 0.4355 0.4411], ... [0.3392 0.3256 0.3038 0.2820], ... hFearNote = xkcd_text(0.15, 0.45, { hFearLine = xkcd_line([0.1906 0.1998 0.2127 0.2127 0.2201 0.2256], ... [0.3501 0.3093 0.2629 0.2221 0.1975 0.1676], ... hEmbNote = xkcd_text(0.88, 0.45, { hEmbLine = xkcd_line([0.8168 0.8094 0.7983 0.7781 0.7578], ... [0.4864 0.5436 0.5872 0.6063 0.6226], ...
% % noise = @(x,A) A*randn(size(x)); ns = @(x,A) A*ones(size(x)); h = figure(2); clf, hold on pos = get(h, set(h, blackline = { axisline = { textprops = { % % x = 1:0.1:10; y0 = sin(x).*exp(-x/30) + 3; y1 = sin(x).*exp(-x/3) + 3; y2 = 3*exp(-(x-7).^6/.05) + 1; y0 = y0 + noise(x, 0.01); y1 = y1 + noise(x, 0.01); y2 = y2 + noise(x, 0.01); % plot(x,y0, plot(x,y1, plot(x,y1, plot(x,y2, plot(x,y2, % % ll(1) = text(1.3, 4.2,... { ll(2) = text(5, 0.7, ll(3) = text(6.2, 0.7, ll(4) = text(7, 0.7, ll(5) = text(8, 0.7, set(ll, textprops{:}); % % % xx = 1.2:0.1:3.74; yy = ns(xx, 4.6) + noise(xx, 0.007); plot(xx, yy, blackline{:}) xx = 1.2:0.1:3.74; yy = ns(xx, 3.8) + noise(xx, 0.007); plot(xx, yy, blackline{:}) yy = 3.8:0.1:4.6; xx = ns(yy, 1.2) + noise(yy, 0.007); plot(xx, yy, blackline{:}) xx = ns(yy, 3.74) + noise(yy, 0.007); plot(xx, yy, blackline{:}) % x_arr = 1.2:0.1:4.8; y_arr = 0.65 * ones(size(x_arr)) + noise(x_arr, 0.005); plot(x_arr, y_arr, blackline{:}) x_head = [1.1 1.6 1.62]; y_head = [0.65 0.72 0.57]; patch(x_head, y_head, % x_arr = 8.7:0.1:9.8; y_arr = 0.65 * ones(size(x_arr)) + noise(x_arr, 0.005); plot(x_arr, y_arr, blackline{:}) x_head = [9.8 9.3 9.3]; y_head = [0.65 0.72 0.57]; patch(x_head, y_head, % y_line = 0.8:0.1:1.1; x_line = ns(y_line, 6.5) + noise(y_line, 0.005); plot(x_line, y_line, blackline{:}) % y_line = 0.8:0.1:1.1; x_line = ns(y_line, 7.2) + noise(y_line, 0.005); plot(x_line, y_line, blackline{:}) % x_xax = x; y_xax = 0.95 + noise(x_xax, 0.01); y_yax = 0.95:0.1:5; x_yax = x(1) + noise(y_yax, 0.01); plot(x_xax, y_xax, axisline{:}) plot(x_yax, y_yax, axisline{:}) % finalize % xlim([0.95 10]) ylim([0 5]) axis off
function funs = makefuns funs.fun1=@fun1; funs.fun2=@fun2; end function y=fun1(x) y=x; end function z=fun2 z=1; end
>> myfuns = makefuns; >> myfuns.fun1(5) ans = 5 >> myfuns.fun2() ans = 1
function message = makefuns assignin( assignin( message= end function y=fun1(x) y=x; end function z=fun2 z=1; end
>> makefuns ans = Done importing functions to workspace >> fun1(123) ans = 123 >> fun2() ans = 1
classdef Statistics methods(Static) function val = MyMean(data) val = mean(data); end function val = MyStd(data) val = std(data); end end end
data = 1:10; mean = Statistics.MyMean(data); std = Statistics.MyStd(data);
octave:8> help source -- Built-in Function: source (FILE) Parse and execute the contents of FILE. This is equivalent to executing commands from a script file, but without requiring the file to be named `FILE.m
function [varargout] = main( subfun, varargin ) [varargout{1:nargout}] = feval( subfun, varargin{:} ); % paste your subfunctions below .... function str=subfun1 str=
function message = makefuns assignin( assignin( message.fun1=@fun1; % SCFrench message.fun2=@fun2; % SCFrench end function y=fun1(x) y=x; end function z=fun2 z=1; end
printf("%d\n", makefuns.fun1(123)); printf("%d\n", makefuns.fun2());
>> b = 2 b = 2 >> a = a = Hi >> class(b) ans = double >> class(a) ans = char
>> a = [0 0 7]; >> whos a Name Size Bytes Class Attributes a 1x3 24 double >> b = >> whos b Name Size Bytes Class Attributes b 1x10 20 char
>> % Define a number >> num = 67 num = 67 >> % Get type of variable num >> class(num) ans = >> % Define character vector >> myName = myName = >> % Check type of myName >> class(myName) ans = >> % Define a cell array >> cellArr = { >> >> class(cellArr) ans = >> % Get more details including type >> whos num Name Size Bytes Class Attributes num 1x1 8 double >> whos myName Name Size Bytes Class Attributes myName 1x17 34 char >> whos cellArr Name Size Bytes Class Attributes cellArr 1x5 634 cell >> % Another way to use whos i.e using whos(char_vector) >> whos( Name Size Bytes Class Attributes cellArr 1x5 634 cell >> whos( Name Size Bytes Class Attributes num 1x1 8 double >> whos( Name Size Bytes Class Attributes myName 1x17 34 char >>
float temp = 0; timer.start(); for(int j = 0; j < rozmer; j++) { for (int k = 0; k < rozmer; k++) { temp = 0; for (int m = 0; m < rozmer; m++) { temp = temp + matice1[j][m] * matice2[m][k]; } matice3[j][k] = temp; } } timer.stop();
>> A = rand(1024); gA = gpuArray(A); % warm up by executing the operations a couple of times, and then: >> tic, C = A * A; toc Elapsed time is 0.075396 seconds. >> tic, gC = gA * gA; toc Elapsed time is 0.008621 seconds.
>> A = rand(1024); gA = gpuArray(A); >> timeit(@()A*A) ans = 0.0324 >> gputimeit(@()gA*gA) ans = 0.0022
>> timeit(@()A*A) ans = 0.0229 >> gputimeit(@()gA*gA) ans = 4.8019e-04
timer.start(); float temp = 0; for (int p = 0; p < rozmer; p++) { for (int q = 0; q < rozmer; q++) { tempmat[p][q] = matice2[q][p]; } } for(int j = 0; j < rozmer; j++) { for (int k = 0; k < rozmer; k++) { temp = 0; for (int m = 0; m < rozmer; m++) { temp = temp + matice1[j][m] * tempmat[k][m]; } matice3[j][k] = temp; } } timer.stop();
const int rozmer = 1024; double[][] matice1 = new double[rozmer * 3][]; Random rnd = new Random(); public Form1() { InitializeComponent(); System.Threading.Thread thr = new System.Threading.Thread(new System.Threading.ThreadStart(() => { string res = ""; Stopwatch timer = new Stopwatch(); timer.Start(); double temp = 0; int r2 = rozmer * 2; for (int i = 0; i < rozmer*3; i++) { if (matice1[i] == null) { matice1[i] = new double[rozmer]; { for (int e = 0; e < rozmer; e++) { matice1[i][e] = rnd.NextDouble(); } } } } timer.Stop(); res += timer.ElapsedMilliseconds.ToString(); int j = 0; int k = 0; int m = 0; timer.Reset(); timer.Start(); for (j = 0; j < rozmer; j++) { for (k = 0; k < rozmer; k++) { temp = 0; for (m = 0; m < rozmer; m++) { temp = temp + matice1[j][m] * matice1[m + rozmer][k]; } matice1[j + r2][k] = temp; } } timer.Stop(); this.Invoke((Action)delegate { this.Text = res + " : " + timer.ElapsedMilliseconds.ToString(); }); })); thr.Start(); }
1024x1024 2048x2048 4096x4096 --------- --------- --------- CUDA C (ms) 43.11 391.05 3407.99 C++ (ms) 6137.10 64369.29 551390.93 C Java (ms) 9149.90 92562.28 838357.94 MATLAB (ms) 75.01 423.10 3133.90
struct matrix { matrix(int x, int y) : n_row(x), n_col(y), M(x * y) {} int n_row; int n_col; std::vector<double> M; double &operator()(int i, int j); };
double &matrix::operator()(int i, int j) { return M[n_col * i + j]; }
n = 10; f = n; while n > 1 n = n-1; f = f*n; end disp([
A = java.util.ArrayList(); A.add(1); A.add(2); A.add(3); A.add(4); A.add(5); itr = A.listIterator(); while itr.hasNext() k = itr.next(); disp(k); % modify data structure while iterating itr.remove(); itr.add(k); end
for i=1:10000 % do something end for i=[1:10000] % do something end
s.a = 1:3 ; s.b = 10 ; for test = fieldnames(s)' s.(cell2mat(test)) end
>> A = zeros(4); A(:) = 1:16 A = 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 >> i = 1; for col = A; disp(col 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 >> A A = 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4
% This example transposes each field of a struct. s.a = 1:3; s.b = zeros(2,3); s % a: [1 2 3]; b: [2x3 double] for f = fieldnames(s)' s.(f{1}) = s.(f{1}) end s % a: [3x1 double]; b: [3x2 double] % Redefining f simplifies the indexing. for f = fieldnames(s)' f = f{1}; s.(f) = s.(f) end s % back to a: [1 2 3]; b: [2x3 double]
array = -1:0.1:10 for i=1:numel(array) disp(array(i)) end
val2 = val + i % 1 val2 = val + ii % 2 val2 = val + 1i % 3
n = 300; k=1; % a = ones(10,1); rr = zeros(n,1); bb=zeros(n,1); ntt=100; tt=zeros(ntt,1); for i=1:n; r = rand(1,i*k); for it=1:ntt; tic, x=bsxfun(@plus,a,r); tt(it)=toc; end; bb(i)=median(tt); for it=1:ntt; tic, y=repmat(a,1,i*k)+repmat(r,10,1); tt(it)=toc; end; rr(i)=median(tt); end
a = rand(1e7,1); tic; idx = bsxfun(@plus, [0:2] toc % equivalent code from im2col function in MATLAB tic; idx0 = repmat([0:2] idx1 = repmat(1:numel(a)-2, 3, 1); idx2 = idx0+idx1; toc; isequal(idx, idx2) Elapsed time is 0.297987 seconds. Elapsed time is 0.501047 seconds. ans = 1
v1=[0:2] v2 = 1:numel(a)-2; tic; vout = v1*v2; toc Elapsed time is 0.309763 seconds.
classdef String < handle .... properties stringobj = end function o = plus( o, b ) o.stringobj = [ o.stringobj b ]; end function n = Length( o ) n = length( o.stringobj ); end function o = SetLength( o, n ) o.stringobj = o.stringobj( 1 : n ); end end function atest( a, b ) %plain functions n = length( a ); a = [ a b ]; a = a( 1 : n ); function btest( a, b ) %OOP n = a.Length(); a = a + b; a.SetLength( n ); function RunProfilerLoop( nLoop, fun, varargin ) profile on; for i = 1 : nLoop fun( varargin{ : } ); end profile off; profile report; a = aString = String( RunProfilerLoop( 1000, @(x,y)atest(x,y), a, RunProfilerLoop( 1000, @(x,y)btest(x,y), aString,
function n = atest( x, y ) n = ctest( x, y ); % ctest is in matlab path function n = btest( x, y ) n = util.ctest( x, y ); % ctest is in +util directory, parent directory is in path
classdef Pointh < handle properties X Y end methods function p = Pointh (x,y) p.X = x; p.Y = y; end function d = dist(p,p1) d = (p.X - p1.X)^2 + (p.Y - p1.Y)^2 ; end end end
%handle points ph = Pointh(1,2); ph1 = Pointh(2,3); %values points p = Pointh(1,2); p1 = Pointh(2,3); % vector points pa1 = [1 2 ]; pa2 = [2 3 ]; %Structur points Ps.X = 1; Ps.Y = 2; ps1.X = 2; ps1.Y = 3; N = 1000000; tic for i =1:N ph.dist(ph1); end t1 = toc tic for i =1:N p.dist(p1); end t2 = toc tic for i =1:N norm(pa1-pa2)^2; end t3 = toc tic for i =1:N (Ps.X-ps1.X)^2+(Ps.Y-ps1.Y)^2; end t4 = toc
function wave(a, b, n, k, T, f, flag, fTrue=inline(
??? Error: File: wave.m Line: 1 Column: 37 The expression to the left of the equals sign is not a valid target for an assignment.
function f(arg1, arg2, arg3) if nargin < 3 arg3 = end end
function wave(a,b,n,k,T,f,flag,varargin) i_p = inputParser; i_p.FunctionName = i_p.addRequired( i_p.addRequired( i_p.addRequired( i_p.addRequired( i_p.addRequired( i_p.addRequired( i_p.addRequired( i_p.addOptional( i_p.parse(a,b,n,k,T,f,flag,varargin{:});
if (nargin<3) or isempty(myParameterName) MyParameterName = defaultValue; elseif (.... tests for non-validity of the value actually provided ...) error( end
function z = myfun (a,varargin) %% Default values b = 1; c = 1; d = 1; e = 1; try b = varargin{1}; c = varargin{2}; d = varargin{3}; e = varargin{4}; end %% Calculation z = a * b * c * d * e ; end
defaults = {50/6,3,true,false,[375,20,50,0]}; %set all defaults defaults(1:nargin-numberForcedParameters) = varargin; %overload with function input [sigma,shifts,applyDifference,loop,weights] = ... defaults{:}; %unfold the cell struct
function y = somefun2Alt(a,b,varargin) % Some function that requires 2 inputs and has some optional inputs. % only want 3 optional inputs at most numvarargs = length(varargin); if numvarargs > 3 error( end % set defaults for optional inputs optargs = {eps 17 @magic}; % now put these defaults into the valuesToUse cell array, % and overwrite the ones specified in varargin. optargs(1:numvarargs) = varargin; % or ... % [optargs{1:numvarargs}] = varargin{:}; % Place optional args in memorable variable names [tol, mynum, func] = optargs{:};
function setParameterDefault(pname, defval) % setParameterDefault(pname, defval) % Author: Tobias Kienzler (https: % sets the parameter NAMED pname to the value defval if it is undefined or % empty if ~isParameterDefined( error( elseif ~isvarname(pname) error( elseif ~isParameterDefined( error( end; % isParameterNotDefined copy&pasted since evalin can % caller... if ~evalin( callername = evalin( warnMsg = [ if isscalar(defval) || ischar(defval) || isvector(defval) warnMsg = [warnMsg end; warnMsg = [warnMsg warning([callername assignin( end
function b = isParameterDefined(pname) % b = isParameterDefined(pname) % Author: Tobias Kienzler (https: % returns true if a parameter NAMED pname exists in the caller % and if it is not empty b = evalin(
function my_output = wave ( a, b, n, k, T, f, flag, varargin ) optargin = numel(varargin); fTrue = inline( if optargin > 0 fTrue = varargin{1}; end % code ... end
function varargout = getargs(args, defaults) %GETARGS Parse function arguments, with defaults % % args is varargin from the caller. By convention, a [] means "use default". % defaults (optional) is a cell vector of corresponding default values if nargin < 2; defaults = {}; end varargout = cell(1, nargout); for i = 1:nargout if numel(args) >= i && ~isequal(args{i}, []) varargout{i} = args{i}; elseif numel(defaults) >= i varargout{i} = defaults{i}; end end
function y = foo(varargin) %FOO % % y = foo(a, b, c, d, e, f, g) [a, b, c, d, e, f, g] = getargs(varargin,... {1, 14,
function output = wave(varargin); % comments, etc [reg, props] = parseparams(varargin); ctrls = cell2struct(props(2:2:end),props(1:2:end),2); %yes this is ugly! a = reg{1}; b = reg{2}; %etc fTrue = ctrl.fTrue;
function f(arg1, arg2, varargin) arg3 = default3; arg4 = default4; % etc. for ii = 1:length(varargin)/2 if ~exist(varargin{2*ii-1}) error([ end; eval([varargin{2*ii-1} end;
function hello (who = "World") printf ("Hello, %s!\n", who); endfunction
parameters.flag =42; parameters.fTrue =1; wave(a,b,n,k,T,f,parameters);
function output = wave(a,b,n,k,T,f,parameters) flagDefault=18; fTrueDefault=0; if (isfield(parameters, if (isfield(parameter, ... end
function [a,b,c,d] = func() a = 1; b = 2; c = 3; d = 4;
[dummy, dummy, variableThatIWillUse, dummy] = func; clear dummy;
[variableThatIWillUse, variableThatIWillUse, variableThatIWillUse] = func;
Func3 = @() deal(1,2,3); [a,b,c]=Func3(); % yields a=1, b=2, c=3
[b,b,c]=Func3(); % yields b=2, c=3 [c,c,c]=Func3(); % yields c=3
a = cell(1,3); % For capturing 3 outputs % OR... a = cell(1,nargout(@func)); % For capturing all outputs from "func"
function kth = kthout(k,ffnc,varargin) %% kthout: take the kth varargout from a func call %FOLDUP % % kth = kthout(k,ffnc,varargin) % % input: % k which varargout to get % ffnc function to call; % varargin passed to ffnc; % output: % kth the kth argout; % global: % nb: % See also: % todo: % changelog: % %% %UNFOLD [outargs{1:k}] = feval(ffnc,varargin{:}); kth = outargs{k}; end %function
val_i_want = kthout(3,@myfunc,func_input_1,func_input_2); %etc
func_i_want = @(varargin)(kthout(3,@myfunc,varargin{:})); %assuming you want the 3rd output.
val_i_want = func_i_want(func_input_1,func_input_2);
for n=1:10 source(n).data=normrnd(rand()*100,abs(rand()*50),100,1); %generate random data end cstring= figure hold on for n=1:length(source) [f,x]=ksdensity(source(n).data); % calculate the distribution plot(x,f,cstring(mod(n,7)+1)) % plot with a different color each time end
cc=hsv(12); figure; hold on; for i=1:12 plot([0 1],[0 i], end
% Starting with X of size N-by-P-by-2, where P is number of plots mpdc10 = distinguishable_colors(10) % 10x3 color list hold on for ii=1:size(X,2), plot(X(:,ii,1),X(:,ii,2), end
data = randn(100, 5); figure; plot(data); legend(cellstr(num2str((1:size(data,2))
T = 4000; N = 500; x = randn(T, N); Func1 = @(a) (3*a^2 + 2*a - 1); tic Soln1 = ones(T, N); for t = 1:T for n = 1:N Soln1(t, n) = Func1(x(t, n)); end end toc tic Soln2 = arrayfun(Func1, x); toc
Elapsed time is 1.020689 seconds. Elapsed time is 9.248388 seconds.
Elapsed time is 28.183422 seconds. Elapsed time is 23.525251 seconds.
tic Soln3 = ones(T, N); for t = 1:T for n = 1:N Soln3(t, n) = 3*x(t, n)^2 + 2*x(t, n) - 1; end end toc
Soln1 1.158446 seconds. Soln2 10.392475 seconds. Soln3 0.239023 seconds. Oli 0.010672 seconds.
tic Soln4 = ones(T, N); for t = 1:T Soln4(t, :) = 3*x(t, :).^2 + 2*x(t, :) - 1; end toc Soln4 0.053926 seconds.
tic Soln5 = ones(T, N); for n = 1:N Soln5(:, n) = 3*x(:, n).^2 + 2*x(:, n) - 1; end toc Soln5 0.013875 seconds.
tic Soln6 = ones(T, N); for n = 1:N for t = 1:T Soln6(t, n) = 3*x(t, n)^2 + 2*x(t, n) - 1; end end toc Soln6 0.201661 seconds.
tic Soln7 = arrayfun(@(a)(3*x(:,a).^2 + 2*x(:,a) - 1), 1:N, toc Soln7 0.016786 seconds.
Soln5 8.192912 seconds. Soln7 13.419675 seconds. Oli 8.089113 seconds.
M = magic(10); % C = num2cell(M, 1); % columnSums = cellfun(@sum, C); %
applyToGivenRow = @(func, matrix) @(row) func(matrix(row, :)) applyToRows = @(func, matrix) arrayfun(applyToGivenRow(func, matrix), 1:size(matrix,1))' % Example myMx = [1 2 3; 4 5 6; 7 8 9]; myFunc = @sum; applyToRows(myFunc, myMx)
applyToGivenRow = @(func, matrix) @(row) func(matrix(row, :)); newApplyToRows = @(func, matrix) arrayfun(applyToGivenRow(func, matrix), 1:size(matrix,1), takeAll = @(x) reshape([x{:}], size(x{1},2), size(x,1)) genericApplyToRows = @(func, matrix) takeAll(newApplyToRows(func, matrix));
>> % Example myMx = [1 2 3; 4 5 6; 7 8 9]; myFunc = @(x) [mean(x), std(x), sum(x), length(x)]; >> genericApplyToRows(myFunc, myMx) ans = 2 1 6 3 5 1 15 3 8 1 24 3 >> applyToRows(myFunc, myMx) ??? Error using ==> arrayfun Non-scalar in Uniform output, at index 1, output 1. Set Error in ==> @(func,matrix)arrayfun(applyToGivenRow(func,matrix),1:size(matrix,1))'
Element-wise arithmetic operators — +, -, .*, .^, ./, .\ Relational operators — <, <=, >, >=, ==, ~= Logical operators — &, |, xor Bit-wise functions — bitand, bitor, bitxor Elementary math functions — max, min, mod, rem, hypot, atan2, atan2d
a = magic(6); incrementRow = cell2mat(cellfun(@(x) x+1,table2cell(table(a)),
dataBinner = cell2mat(arrayfun(@(x) Binner(a(x,:),2)
vec1 = [ stuff ]; % n x 1 vector vec2 = [ stuff ]; % m x 1 vector result = bsxfun(
apply_func_2_cols = @(f,M) cell2mat(cellfun(f,num2cell(M,1),
f = @(v) [0 1;1 0]*v + [0 0.1] apply_func_2_cols(f,[0 0 1 1;0 1 0 1]) ans = 0.00000 1.00000 0.00000 1.00000 0.10000 0.10000 1.10000 1.10000
a=rand(9,3); b=rand(9,3); arrayfun(@(x1,x2,y1,y2,z1,z2) line([x1,x2],[y1,y2],[z1,z2]) , a(:,1),b(:,1),a(:,2),b(:,2),a(:,3),b(:,3) )
function fileList = getAllFiles(dirName) dirData = dir(dirName); % dirIndex = [dirData.isdir]; % fileList = {dirData(~dirIndex).name} if ~isempty(fileList) fileList = cellfun(@(x) fullfile(dirName,x),... % fileList, end subDirs = {dirData(dirIndex).name}; % validIndex = ~ismember(subDirs,{ % for iDir = find(validIndex) % nextDir = fullfile(dirName,subDirs{iDir}); % fileList = [fileList; getAllFiles(nextDir)]; % end end
dirlist = dir( for i = 1:length(dirlist) dirlist(i) end
function fileList = getAllFiles(dirName, fileExtension, appendFullPath) dirData = dir([dirName dirWithSubFolders = dir(dirName); dirIndex = [dirWithSubFolders.isdir]; % fileList = {dirData.name} if ~isempty(fileList) if appendFullPath fileList = cellfun(@(x) fullfile(dirName,x),... % fileList, end end subDirs = {dirWithSubFolders(dirIndex).name}; % validIndex = ~ismember(subDirs,{ % for iDir = find(validIndex) % nextDir = fullfile(dirName,subDirs{iDir}); % fileList = [fileList; getAllFiles(nextDir, fileExtension, appendFullPath)]; % end end
list=dir(pwd); %get info of files/folders in current directory isfile=~[list.isdir]; %determine index of files vs folders filenames={list(isfile).name}; %create cell array of file names
dirnames={list([list.isdir]).name}; dirnames=dirnames(~(strcmp(
tic asdfList = getAllFiles( toc % Elapsed time is 19.066170 seconds. tic [status,cmdout] = system( C = strsplit(strtrim(cmdout)); toc % Elapsed time is 0.603163 seconds.
filenamelist=[]; for d=1:length(dirlist) % keep only filenames filelist=dir(dirlist{d}); filelist={filelist.name}; % remove filelist([strmatch( % or to ignore all hidden files, use filelist(strmatch( % prepend directory name to each filename entry, separated by filesep* for f=1:length(filelist) filelist{f}=[dirlist{d} filesep filelist{f}]; end filenamelist=[filenamelist filelist]; end
function filenames = getFilenames(rootDir, format) % Get filenames with specified `format` in given `foler` % % Parameters % ---------- % - rootDir: char vector % Target folder % - format: char vector = % File foramt % default values if ~exist( format = end format = [ filenames = dir(fullfile(rootDir, format)); filenames = arrayfun(... @(x) fullfile(x.folder, x.name), ... filenames, ... ); end
filenames = getFilenames( for i = 1:numel(filenames) filename = filenames{i}; % do your job! end
dataFolderPath = dirData = dir(dataFolderPath); % dirIndex = [dirData.isdir]; % fileList = {dirData(~dirIndex).name} if ~isempty(fileList) fileList = cellfun(@(x) fullfile(dataFolderPath,x),... % fileList, end subDirs = {dirData(dirIndex).name}; % validIndex = ~ismember(subDirs,{ % for iDir = find(validIndex) % nextDir = fullfile(dataFolderPath,subDirs{iDir}); % getAllFiles = dir(nextDir); for k = 1:1:size(getAllFiles,1) validFileIndex = ~ismember(getAllFiles(k,1).name,{ if(validFileIndex) filePathComplete = fullfile(nextDir,getAllFiles(k,1).name); fprintf( end end end
>> y = arrayfun(@(x) x^2, 1:10) y = 1 4 9 16 25 36 49 64 81 100
>> x = 1:10; >> y = x.^2 y = 1 4 9 16 25 36 49 64 81 100
x = 1:10; % Sample array f = @(x) x.^2; % Anonymous function that squares each element of its input % Option y = x.^2; % Use the element-wise power operator % Option y = f(x); % Pass a vector to f % Option y = arrayfun(f, x); % Pass each element to f separately
a = [ 10 20 30 40 50 ]; % the array with the original values b = [ 10 8 6 4 2 ]; % the mapping array c = zeros( 1, 10 ); % your target array
function results = map(f,list) % why doesn for k = 1:length(list) if (k==1) r1=f(list(k)); results = zeros(length(r1),length(list)); results(:,k)=r1; else results(:,k) = f(list(k)); end; end; end
>v = [1 2]; >v10 = v x 5; %x represents some function. Something like "1 2" x 5 in perl
C:\<a long path here>\matlab.exe" -nodisplay -nosplash -nodesktop -r "try, run(
C:\<a long path here>\matlab.exe" -nodisplay -nosplash -nodesktop -r "try, run(
matlab -nodisplay -nojvm -nosplash -nodesktop -r \ "try, run( echo "matlab exit code: $?"
try some_code ... catch message display([ display([ end;
ERROR in file: C:\..\..\.. ERROR: Undefined function or variable Error in sub-m-file (line 63) legacy_code( Error in m-file (line 11) sub-m-file Error in run (line 63) evalin(
arr[find(array_of_ks_ = k)] = <image filtered with k-th guassian>
arr{array_of_ks==k} = <image filtered with k-th Gaussian>
arr(:,:,array_of_ks==k) = <image filtered with k-th Gaussian>
arr{i} = GaussFilter(arr{i-1},sigma*s^(array_of_ks(i)) - sigma*s^(array_of_ks(i-1)))
>> keys = { >> values = {327.2, 368.2, 197.6, 178.4, 100.0, 69.9, ... 32.3, 37.3, 19.0, 37.0, 73.2, 110.9, 1551.0}; >> rainfallMap = containers.Map(keys, values) rainfallMap = containers.Map handle Package: containers Properties: Count: 13 KeyType: ValueType: Methods, Events, Superclasses
values = rainfallMap.values; keys = rainfallMap.keys; sz = rainfallMap.size;
dict = java.util.Hashtable; dict.put( dict.put( dict.put( dict.get(
dict.a = 1; dict.b = 2; var = display( dict.(var) ); % prints 1
figure (1) hFig = figure(1); set(gcf, set(hFig, plot(x,y) print -depsc2 correlation.eps; % for saving in eps, look up options for saving as png or other formats you may need
h = gcf; % Current figure handle set(h, set(h, set(h, set(h, set(h, set(h, % xpos, ypos must be set txlabel = text(xpos,ypos, % Dump colored encapsulated PostScript print(
Error using eig LAPACK loading error: dlopen: cannot load any more object with static TLS
Error using * BLAS loading error: dlopen: cannot load any more object with static TLS
>> randn(3,3) ans = 2.7694 0.7254 -0.2050 -1.3499 -0.0631 -0.1241 3.0349 0.7147 1.4897 >> eig(ans) Error using eig LAPACK loading error: dlopen: cannot load any more object with static TLS
matlabroot/bin/glnxa64/libut.so /lib64/libstdc++.so.6 /lib64/libpthread.so.0 matlabroot/bin/glnxa64/libunwind.so.8 /lib64/libuuid.so.1 matlabroot/sys/java/jre/glnxa64/jre/lib/amd64/server/libjvm.so matlabroot/sys/java/jre/glnxa64/jre/lib/amd64/libfontmanager.so matlabroot/sys/java/jre/glnxa64/jre/lib/amd64/libt2k.so matlabroot/bin/glnxa64/mkl.so matlabroot/sys/os/glnxa64/libiomp5.so /lib64/libasound.so.2 matlabroot/sys/jxbrowser/glnxa64/xulrunner/xulrunner-linux-64/libxul.so /lib64/libselinux.so.1 /lib64/libpixman-1.so.0 /lib64/libEGL.so.1 /lib64/libGL.so.1 /lib64/libglapi.so.0
for i = 1:size(m,1) for j = 1:size(m,2) for k = 1:size(m,3)
for idx = 1:numel(array) element = array(idx) .... end
A = magic(3) A = 8 1 6 3 5 7 4 9 2 A(2,3) ans = 7 A(8) ans = 7
B = zeros(size(A)); for i = 1:numel(A) B(i) = A(i).^2; end B B = 64 1 36 9 25 49 16 81 4
d = zeros( 3, 4, 5, 6 ); % Let nel = numel( d ); sz = size( d ); szargs = cell( 1, ndims( d ) ); % We for ii=1:nel [ szargs{:} ] = ind2sub( sz, ii ); % Convert linear index back to subscripts if all( [szargs{2:end}] == szargs{1} ) % On the diagonal? d( ii ) = 1; end end
for idx = reshape(array,1,[]), element = element + idx; end
d = size(m); dims = ndims(m); for dimNumber = 1:dims for i = 1:d[dimNumber] ...
for(int x=0;x<3;x++) for(int y=0;y<4;y++) for(int z=0;z<5;z++) T[x][y][z]=...
0 0 0 0 0 1 0 0 2 0 0 3 0 0 4 0 1 0 0 1 1 0 1 2 0 1 3 0 1 4 0 2 0 0 2 1 0 2 2 0 2 3 0 2 4 0 3 0 0 3 1 0 3 2 0 3 3 0 3 4 and so on
profile on % some lines of code profile off profile viewer
x = rand(1,50) .* 100; xpart = x( x > 20 & x < 35);
function y = transmog(x) %TRANSMOG Transmogrifies a matrix X using reverse orthogonal eigenvectors % % Usage: % y = transmog(x) % % SEE ALSO % UNTRANSMOG, TRANSMOG2
% quick functions f = @(x) 3*x.^2 + 2*x + 7; t = (0:0.001:1); plot(t,f(t),t,f(2*t),t,f(3*t)); % closures (linfunc below is a function that returns a function, % and the outer functions arguments are held for the lifetime % of the returned function. linfunc = @(m,b) @(x) m*x+b; C2F = linfunc(9/5, 32); F2C = linfunc(5/9, -32*5/9);
M = rand(1000, 1000); v = rand(1000, 1); c = bsxfun(@plus, M, v);
t=(0:0.001:1); plot(t,sin(2*pi*[t ; t+0.25])); xlabel( ylabel( legend({
% Build a list of args, like so: args = { % Then expand this into arguments: output = func(args{:})
switch number, case 1, outargs = fcn1(inargs); case 2, outargs = fcn2(inargs); ... end % %can be turned into % fcnArray = {@fcn1, @fcn2, ...}; outargs = fcnArray{number}(inargs);
function hLine=myplot(x,y,plotColor,markerType) % set defaults for optional paramters if nargin<4, markerType= if nargin<3, plotColor= hL = plot(x,y, % return handle of plot object if required if nargout>0, hLine = hL; end
t = (0:0.005:10) x = sin(2*pi*t); x(x>0.5 & t<5) = 0.5; % This limits all values of x to a maximum of 0.5, where t<5 plot(t,x);
>> a=rand(1,7); >> diff(a) ./ a(1:end-1) ans = -0.5822 -0.9935 224.2015 0.2708 -0.3328 0.0458 >> a=1; >> diff(a) ./ a(1:end-1) ??? Error using ==> rdivide Matrix dimensions must agree.
>> diff(a, [], 2) ./ a(1, 1:end-1) ans = Empty matrix: 1-by-0 >>
x=rand(10,10); flattened=x(:); Acolumn=x(:,10); Arow=x(10,:); y=rand(100); firstSix=y(1:6); lastSix=y(end-5:end); alternate=y(1:2:end);
function result = multiply(a, b) if nargin == 0 %no inputs provided, run using defaults for a and b clc; disp( a = 1; b = 2; end result = a*b;
%Merge B into A based on Text identifiers UniverseA = { UniverseB = { DataA = [20 40 60 80]; DataB = [30 50 70]; MergeData = NaN(length(UniverseA),2); MergeData(:,1) = DataA; [tf, loc] = ismember(UniverseA, UniverseB); MergeData(tf,2) = DataB(loc(tf)); MergeData = 20 30 40 NaN 60 50 80 70
function Y=run_my_sim(t,input1,params) % runs "my_sim.mdl" % with a From Workspace block referencing I1 as an input signal % and parameters referenced as fields of the "params" structure % and output retrieved from a To Workspace block with name O1. opt = simset( I1 = struct( Y = struct; Y.t = sim( Y.output1 = O1.signals.values;
function iNeedle = findClosest(hay,needle) %FINDCLOSEST find the indicies of the closest elements in an array. % Given two vectors [A,B], findClosest will find the indicies of the values % in vector A closest to the values in vector B. [hay iOrgHay] = sort(hay(:) % Use histogram to find indices of elements in hay closest to elements in % needle. The bins are centered on values in hay, with the edges on the % midpoint between elements. [iNeedle iNeedle] = histc(needle,[-inf hay+[diff(hay)/2 inf]]); % % Reversing the sorting. iNeedle = iOrgHay(iNeedle);
function av = runningAverage(x) % The number of values entered so far - declared persistent. persistent n; % The sum of values entered so far - declared persistent. persistent sumOfX; if x == n = 0; sumOfX = 0; av = 0; else % A data value has been added. n = n + 1; sumOfX = sumOfX + x; av = sumOfX / n; % Update the running average. end
runningAverage( ans = 0 >> runningAverage(5) ans = 5 >> runningAverage(10) ans = 7.5000 >> runningAverage(3) ans = 6 >> runningAverage( ans = 0 >> runningAverage(8) ans = 8
% define model f1 = 1100; % frequency of tone generator 1; unit: Hz f2 = 2900; % frequency of tone generator 2; unit: Hz Ts = 1/(40*max(f1,f2)); % sampling period; unit: s dMic = 1; % distance between microphones centered about origin; unit: m dSrc = 10; % distance between tone generators centered about origin; unit: m c = 340.29; % speed of sound; unit: m / s % generate tones figure(1); t = [0:Ts:0.025]; tone1 = sin(2*pi*f1*t); tone2 = sin(2*pi*f2*t); plot(t,tone1); hold on; plot(t,tone2, hold off; % mix tones at microphones % assume inverse square attenuation of sound intensity (i.e., inverse linear attenuation of sound amplitude) figure(2); dNear = (dSrc - dMic)/2; dFar = (dSrc + dMic)/2; mic1 = 1/dNear*sin(2*pi*f1*(t-dNear/c)) + \ 1/dFar*sin(2*pi*f2*(t-dFar/c)); mic2 = 1/dNear*sin(2*pi*f2*(t-dNear/c)) + \ 1/dFar*sin(2*pi*f1*(t-dFar/c)); plot(t,mic1); hold on; plot(t,mic2, hold off; % use svd to isolate sound sources figure(3); x = [mic1 [W,s,v]=svd((repmat(sum(x.*x,1),size(x,1),1).*x)*x plot(t,v(:,1)); hold on; maxAmp = max(v(:,1)); plot(t,v(:,2), hold off;
[x1, Fs1] = audioread( [x2, Fs2] = audioread( xx = [x1, x2] yy = sqrtm(inv(cov(xx [W,s,v] = svd((repmat(sum(yy.*yy,1),size(yy,1),1).*yy)*yy a = W*xx; %W is unmixing matrix subplot(2,2,1); plot(x1); title( subplot(2,2,2); plot(x2); title( subplot(2,2,3); plot(a(1,:), subplot(2,2,4); plot(a(2,:), audiowrite( audiowrite(
data = 1:10; % A vector of data squaredData = f(data); % Invoke the local function function y = f(x) y = x.^2; end
data = 1:10; % A vector of data f = @(x) x.^2; % An anonymous function squaredData = f(data); % Invoke the anonymous function
function [] = myScriptAsAFunction() img = randn(200); img = smooth(img); figure(1); imagesc(img); axis image; colorbar; end function simg = smooth(img) simg = img / 5; end
function my_file %script here end function out = f(in) %function here end
x = 1; y = add1(x); function z = add1(x) z = x + 1; end
function [] = test3() %clear all a = myfunc( 1 ); a endfunction; %--------------------------------- % Auxiliary functions function retval = myfunc( a ) retval = 2 * a; endfunction;
% Change default axes fonts. set(0, set(0, % Change default text fonts. set(0, set(0,
>> N = 5; >> f = strrep(matlab.lang.makeUniqueStrings(repmat({ f = 1×5 cell array
counts2_1 = hist( M, numel(unique(M)) ); counts2_2 = histc( M, unique(M) );
counts3 = accumarray(M, ones(size(M)), [], @sum); %
[MM idx] = unique( sort(M) ); counts4 = diff([0;idx]);
>> M = randi(7,1500,1); % >> dayCounts = accumarray(M,1) % dayCounts = 218 % 200 % 213 % 220 % 234 % 219 % 196 %
hold on x = [0; 0.2; 0.4; 0.6; 0.8; 1; 1.2; 1.4; 1.6; 1.8; 2; 2.2; 2.4; 2.6; 2.8; 3; 3.2; 3.4; 3.6; 3.8; 4; 4.2; 4.4; 4.6; 4.8; 5; 5.2; 5.4; 5.6; 5.8; 6; 6.2; 6.4; 6.6; 6.8; 7; 7.2; 7.4; 7.6; 7.8; 8; 8.2; 8.4; 8.6; 8.8; 9; 9.2; 9.4; 9.6; 9.8; 10; 10.2; 10.4; 10.6; 10.8; 11; 11.2; 11.4; 11.6; 11.8; 12; 12.2; 12.4; 12.6; 12.8; 13; 13.2; 13.4; 13.6; 13.8; 14; 14.2; 14.4; 14.6; 14.8; 15; 15.2; 15.4; 15.6; 15.8; 16; 16.2; 16.4; 16.6; 16.8; 17; 17.2; 17.4; 17.6; 17.8; 18; 18.2; 18.4; 18.6; 18.8]; y = [0; 0.198669; 0.389418; 0.564642; 0.717356; 0.841471; 0.932039; 0.98545; 0.999574; 0.973848; 0.909297; 0.808496; 0.675463; 0.515501; 0.334988; 0.14112; -0.0583741; -0.255541; -0.44252; -0.611858; -0.756802; -0.871576; -0.951602; -0.993691; -0.996165; -0.958924; -0.883455; -0.772764; -0.631267; -0.464602; -0.279415; -0.0830894; 0.116549; 0.311541; 0.494113; 0.656987; 0.793668; 0.898708; 0.96792; 0.998543; 0.989358; 0.940731; 0.854599; 0.734397; 0.584917; 0.412118; 0.22289; 0.0247754; -0.174327; -0.366479; -0.544021; -0.699875; -0.827826; -0.922775; -0.980936; -0.99999; -0.979178; -0.919329; -0.822829; -0.693525; -0.536573; -0.358229; -0.165604; 0.033623; 0.23151; 0.420167; 0.592074; 0.740376; 0.859162; 0.943696; 0.990607; 0.998027; 0.965658; 0.894791; 0.788252; 0.650288; 0.486399; 0.303118; 0.107754; -0.0919069; -0.287903; -0.472422; -0.638107; -0.778352; -0.887567; -0.961397; -0.9969; -0.992659; -0.948844; -0.867202; -0.750987; -0.604833; -0.434566; -0.246974; -0.0495356]; plot(x, y, x = [0; 0.2; 0.4; 0.6; 0.8; 1; 1.2; 1.4; 1.6; 1.8; 2; 2.2; 2.4; 2.6; 2.8; 3; 3.2; 3.4; 3.6; 3.8; 4; 4.2; 4.4; 4.6; 4.8; 5; 5.2; 5.4; 5.6; 5.8; 6; 6.2; 6.4; 6.6; 6.8; 7; 7.2; 7.4; 7.6; 7.8; 8; 8.2; 8.4; 8.6; 8.8; 9; 9.2; 9.4; 9.6; 9.8; 10; 10.2; 10.4; 10.6; 10.8; 11; 11.2; 11.4; 11.6; 11.8; 12; 12.2; 12.4; 12.6; 12.8; 13; 13.2; 13.4; 13.6; 13.8; 14; 14.2; 14.4; 14.6; 14.8; 15; 15.2; 15.4; 15.6; 15.8; 16; 16.2; 16.4; 16.6; 16.8; 17; 17.2; 17.4; 17.6; 17.8; 18; 18.2; 18.4; 18.6; 18.8]; y = [-1; -0.980133; -0.921324; -0.825918; -0.697718; -0.541836; -0.364485; -0.172736; 0.0257666; 0.223109; 0.411423; 0.583203; 0.731599; 0.850695; 0.935744; 0.983355; 0.991629; 0.960238; 0.890432; 0.784994; 0.648128; 0.48529; 0.302972; 0.108443; -0.0905427; -0.286052; -0.470289; -0.635911; -0.776314; -0.885901; -0.960303; -0.996554; -0.993208; -0.950399; -0.869833; -0.754723; -0.609658; -0.44042; -0.253757; -0.057111; 0.141679; 0.334688; 0.514221; 0.673121; 0.805052; 0.904756; 0.968256; 0.993023; 0.978068; 0.923987; 0.832937; 0.708548; 0.555778; 0.380717; 0.190346; -0.00774649; -0.205663; -0.395514; -0.56973; -0.721365; -0.844375; -0.933855; -0.986238; -0.999436; -0.972923; -0.907755; -0.806531; -0.673287; -0.513333; -0.333047; -0.139617; 0.0592467; 0.255615; 0.44166; 0.609964; 0.753818; 0.867487; 0.946439; 0.987526; 0.989111; 0.95113; 0.875097; 0.764044; 0.622398; 0.455806; 0.27091; 0.0750802; -0.123876; -0.318026; -0.499631; -0.66145; -0.797032; -0.900972; -0.969126; -0.998776]; plot(x, y, hold off title( xlabel( ylabel(
figure( hold on x = [0; 0.2; 0.4; 0.6; 0.8; 1; 1.2; 1.4; 1.6; 1.8; 2; 2.2; 2.4; 2.6; 2.8; 3; 3.2; 3.4; 3.6; 3.8; 4; 4.2; 4.4; 4.6; 4.8; 5; 5.2; 5.4; 5.6; 5.8; 6; 6.2; 6.4; 6.6; 6.8; 7; 7.2; 7.4; 7.6; 7.8; 8; 8.2; 8.4; 8.6; 8.8; 9; 9.2; 9.4; 9.6; 9.8; 10; 10.2; 10.4; 10.6; 10.8; 11; 11.2; 11.4; 11.6; 11.8; 12; 12.2; 12.4; 12.6; 12.8; 13; 13.2; 13.4; 13.6; 13.8; 14; 14.2; 14.4; 14.6; 14.8; 15; 15.2; 15.4; 15.6; 15.8; 16; 16.2; 16.4; 16.6; 16.8; 17; 17.2; 17.4; 17.6; 17.8; 18; 18.2; 18.4; 18.6; 18.8]; y = [0; 0.198669; 0.389418; 0.564642; 0.717356; 0.841471; 0.932039; 0.98545; 0.999574; 0.973848; 0.909297; 0.808496; 0.675463; 0.515501; 0.334988; 0.14112; -0.0583741; -0.255541; -0.44252; -0.611858; -0.756802; -0.871576; -0.951602; -0.993691; -0.996165; -0.958924; -0.883455; -0.772764; -0.631267; -0.464602; -0.279415; -0.0830894; 0.116549; 0.311541; 0.494113; 0.656987; 0.793668; 0.898708; 0.96792; 0.998543; 0.989358; 0.940731; 0.854599; 0.734397; 0.584917; 0.412118; 0.22289; 0.0247754; -0.174327; -0.366479; -0.544021; -0.699875; -0.827826; -0.922775; -0.980936; -0.99999; -0.979178; -0.919329; -0.822829; -0.693525; -0.536573; -0.358229; -0.165604; 0.033623; 0.23151; 0.420167; 0.592074; 0.740376; 0.859162; 0.943696; 0.990607; 0.998027; 0.965658; 0.894791; 0.788252; 0.650288; 0.486399; 0.303118; 0.107754; -0.0919069; -0.287903; -0.472422; -0.638107; -0.778352; -0.887567; -0.961397; -0.9969; -0.992659; -0.948844; -0.867202; -0.750987; -0.604833; -0.434566; -0.246974; -0.0495356]; plot(x, y, x = [0; 0.2; 0.4; 0.6; 0.8; 1; 1.2; 1.4; 1.6; 1.8; 2; 2.2; 2.4; 2.6; 2.8; 3; 3.2; 3.4; 3.6; 3.8; 4; 4.2; 4.4; 4.6; 4.8; 5; 5.2; 5.4; 5.6; 5.8; 6; 6.2; 6.4; 6.6; 6.8; 7; 7.2; 7.4; 7.6; 7.8; 8; 8.2; 8.4; 8.6; 8.8; 9; 9.2; 9.4; 9.6; 9.8; 10; 10.2; 10.4; 10.6; 10.8; 11; 11.2; 11.4; 11.6; 11.8; 12; 12.2; 12.4; 12.6; 12.8; 13; 13.2; 13.4; 13.6; 13.8; 14; 14.2; 14.4; 14.6; 14.8; 15; 15.2; 15.4; 15.6; 15.8; 16; 16.2; 16.4; 16.6; 16.8; 17; 17.2; 17.4; 17.6; 17.8; 18; 18.2; 18.4; 18.6; 18.8]; y = [-1; -0.980133; -0.921324; -0.825918; -0.697718; -0.541836; -0.364485; -0.172736; 0.0257666; 0.223109; 0.411423; 0.583203; 0.731599; 0.850695; 0.935744; 0.983355; 0.991629; 0.960238; 0.890432; 0.784994; 0.648128; 0.48529; 0.302972; 0.108443; -0.0905427; -0.286052; -0.470289; -0.635911; -0.776314; -0.885901; -0.960303; -0.996554; -0.993208; -0.950399; -0.869833; -0.754723; -0.609658; -0.44042; -0.253757; -0.057111; 0.141679; 0.334688; 0.514221; 0.673121; 0.805052; 0.904756; 0.968256; 0.993023; 0.978068; 0.923987; 0.832937; 0.708548; 0.555778; 0.380717; 0.190346; -0.00774649; -0.205663; -0.395514; -0.56973; -0.721365; -0.844375; -0.933855; -0.986238; -0.999436; -0.972923; -0.907755; -0.806531; -0.673287; -0.513333; -0.333047; -0.139617; 0.0592467; 0.255615; 0.44166; 0.609964; 0.753818; 0.867487; 0.946439; 0.987526; 0.989111; 0.95113; 0.875097; 0.764044; 0.622398; 0.455806; 0.27091; 0.0750802; -0.123876; -0.318026; -0.499631; -0.66145; -0.797032; -0.900972; -0.969126; -0.998776]; plot(x, y, hold off title( xlabel( ylabel(
>> num = 2.71828182845904553488; >> class(num) % Display the variable type ans = double
>> fprintf( 2.71828182845904550000 >> sprintf( ans = 2.71828182845904550000
>> num = 2.71828182845904553488; % Declare with 20 digits past the decimal >> num = 2.718281828459045531; % Re-declare with 18 digits past the decimal >> vpa(num, 21) ans = 2.71828182845904553488 % It
x = [ 2.7182818284590455348848081484902650117874145507812500 2.7182818284590455348848081484902650117874145507819999 2.7182818284590455348848 2.71828182845904553488485555555555555555555555555555 exp(1) ] unique(x)
big = 1e5; tic; x = rand(big,1); toc x = zeros(big,1); tic; for ii = 1:big x(ii) = rand; end toc x = []; tic; for ii = 1:big x(end+1) = rand; end; toc x = []; tic; for ii = 1:big x = [x rand]; end; toc Elapsed time is 0.004611 seconds. Elapsed time is 0.016448 seconds. Elapsed time is 0.034107 seconds. Elapsed time is 12.341434 seconds.
Elapsed time is 0.003044 seconds. Elapsed time is 0.009947 seconds. Elapsed time is 12.013875 seconds. Elapsed time is 12.165593 seconds.
tol = 10*eps; any(abs(X - 3.1415926535897932384) <= tol)
[tf, loc]=ismember(0.3, 0:0.1:1) % returns false [tf, loc]=ismemberf(0.3, 0:0.1:1) % returns true
ismemberf(9.99, 0:10:100) % returns false ismemberf(9.99, 0:10:100,
>> pi_estimate = 3.14159; >> abs(pi_estimate - pi) ans = 5.3590e-08 >> tol = 1e-7; >> ismembertol(pi,pi_estimate,tol) ans = 1
teststruct = struct( fields = fieldnames(teststruct) for i=1:numel(fields) fields(i) teststruct.(fields(i)) end
ans = ??? Argument to dynamic structure reference must evaluate to a valid field name.
>> fields(1) % Get the first cell of the cell array ans = >> fields{1} % Get the contents of the first cell of the cell array ans = a % This is how the single character is displayed
teststruct = struct( fields = fieldnames(teststruct) for fn=fields' fn % teststruct.(fn{1}) end
>> signal signal = sin: {{1x1x25 cell} {1x1x25 cell}} cos: {{1x1x25 cell} {1x1x25 cell}} >> each(fieldnames(signal)) ans = CellIterator with properties: NumberOfIterations: 2.0000e+000
for bridge = each(fieldnames(signal)) signal.(bridge) = rand(10); end
function example(varargin) % Lots of set up stuff vargs = varargin; nargs = length(vargs); names = vargs(1:2:nargs); values = vargs(2:2:nargs); validnames = { for name = names validatestring(name{:}, validnames); end % Do something ... foo = strmatch( disp(values(foo)) end example(
function example(varargin) % % % options = struct( % optionNames = fieldnames(options); % nArgs = length(varargin); if round(nArgs/2)~=nArgs/2 error( end for pair = reshape(varargin,2,[]) % inpName = lower(pair{1}); % if any(strcmp(inpName,optionNames)) % % % options.(inpName) = pair{2}; else error( end end
function example(args) %EXAMPLE % % Where args is a struct or {name,val;...} cell array
function out = my_example_function(varargin) %MY_EXAMPLE_FUNCTION Example function % No type handling args = parsemyargs(varargin, { }); fprintf( disp(args); % With type handling typed_args = parsemyargs(varargin, { }); fprintf( disp(typed_args); % And now in your function body, you just reference stuff like % args.Stations % args.FromDate
function out = parsemyargs(args, defaults) %PARSEMYARGS Arg parser helper % % out = parsemyargs(Args, Defaults) % % Parses name/value argument pairs. % % Args is what you pass your varargin in to. It may be % % ArgTypes is a list of argument names, default values, and optionally % argument types for the inputs. It is an n-by-1, n-by-2 or n-by-3 cell in one % of these forms forms: % { Name; ... } % { Name, DefaultValue; ... } % { Name, DefaultValue, Type; ... } % You may also pass a struct, which is converted to the first form, or a % cell row vector containing name/value pairs as % { Name,DefaultValue, Name,DefaultValue,... } % Row vectors are only supported because it % has at most 3 columns. If there were more columns possible, I think you % have to require the 2-d form because 4-element long vectors would be % ambiguous as to whether they were on record, or two records with two % columns omitted. % % Returns struct. % % This is slow - don % in tight loops. args = structify(args); defaults = parse_defaults(defaults); % You could normalize case if you want to. I recommend you don % and just one more potential source of inconsistency. %[args,defaults] = normalize_case_somehow(args, defaults); out = merge_args(args, defaults); %% function out = parse_defaults(x) %PARSE_DEFAULTS Parse the default arg spec structure % % Returns n-by-3 cellrec in form {Name,DefaultValue,Type;...}. if isstruct(x) if ~isscalar(x) error( end x = [fieldnames(s) struct2cell(s)]; end if ~iscell(x) error( end % Allow {name,val, name,val,...} row vectors % Does not work for the general case of >3 columns in the 2-d form! if size(x,1) == 1 && size(x,2) > 3 x = reshape(x, [numel(x)/2 2]); end % Fill in omitted columns if size(x,2) < 2 x(:,2) = {[]}; % Make everything default to value [] end if size(x,2) < 3 x(:,3) = {[]}; % No default type conversion end out = x; %% function out = structify(x) %STRUCTIFY Convert a struct or name/value list or record list to struct if isempty(x) out = struct; elseif iscell(x) % Cells can be {name,val;...} or {name,val,...} if (size(x,1) == 1) && size(x,2) > 2 % Reshape {name,val, name,val, ... } list to {name,val; ... } x = reshape(x, [2 numel(x)/2]); end if size(x,2) ~= 2 error( end % Convert {name,val, name,val, ...} list to struct if ~iscellstr(x(:,1)) error( end % Little trick for building structs from name/vals % This protects cellstr arguments from expanding into nonscalar structs x(:,2) = num2cell(x(:,2)); x = x x = x(:); out = struct(x{:}); elseif isstruct(x) if ~isscalar(x) error( end out = x; end %% function out = merge_args(args, defaults) out = structify(defaults(:,[1 2])); % Apply user arguments % You could normalize case if you wanted, but I avoid it because it % runtime cost and one more chance for inconsistency. names = fieldnames(args); for i = 1:numel(names) out.(names{i}) = args.(names{i}); end % Check and convert types for i = 1:size(defaults,1) [name,defaultVal,type] = defaults{i,:}; if ~isempty(type) out.(name) = needa(type, out.(name), type); end end %% function out = needa(type, value, name) %NEEDA Check that a value is of a given type, and convert if needed % % out = needa(type, value) % HACK to support common switch type case isThatType = iscellstr(value); case isThatType = isnumeric(value); otherwise isThatType = isa(value, type); end if isThatType out = value; else % Here you can auto-convert if you % conversion constructor form of all type names works. % Unfortunately this ends up with bad results if you try converting % between string and number (you get Unicode encoding/decoding). Use % at your discretion. % If you don % with: % error( try out = feval(type, value); catch err error( name, class(value), type, err.message); end end
% which -all statgetargs which -all internal.stats.getargs which -all internal.stats.parseArgs % which -all statslib.internal.parseArgs
function varargout = parseArgs(pnames, dflts, varargin) % % [A,B,...] = parseArgs(PNAMES, DFLTS, % PNAMES : cell array of N valid parameter names. % DFLTS : cell array of N default values for these parameters. % varargin : Remaining arguments as name/value pairs to be parsed. % [A,B,...]: N outputs assigned in the same order as the names in PNAMES. % % [A,B,...,SETFLAG] = parseArgs(...) % SETFLAG : structure of N fields for each parameter, indicates whether % the value was parsed from input, or taken from the defaults. % % [A,B,...,SETFLAG,EXTRA] = parseArgs(...) % EXTRA : cell array containing name/value parameters pairs not % specified in PNAMES.
function my_plot(x, varargin) % pnames = { dflts = { % [clr,lw,ls,txt] = internal.stats.parseArgs(pnames, dflts, varargin{:}); % % % end
>> my_plot(data) % >> my_plot(data, >> my_plot(data,
% >> my_plot(x, Error using [...] Invalid parameter name: width. % >> my_plot(x, 1,2) Error using [...] Parameter name must be text. % >> my_plot(x, Error using [...] Wrong number of arguments. % >> my_plot(x, Error using [...] Ambiguous parameter name: line.
function TestExample(req1, req2, varargin) for i = 1:2:length(varargin) if strcmpi(varargin{i}, ALPHA = varargin{i+1}; elseif strcmpi(varargin{i}, CUTOFF = varargin{i+1}; %we need to remove these so seqlogo doesn rm_inds = [rm_inds i, i+1]; % elseif strcmpi(varargin{i}, colors = varargin{i+1}; rm_inds = [rm_inds i, i+1]; elseif strcmpi(varargin{i}, handle = varargin{i+1}; rm_inds = [rm_inds i, i+1]; elseif strcmpi(varargin{i}, TOPN = varargin{i+1}; rm_inds = [rm_inds i, i+1]; elseif strcmpi(varargin{i}, npos = varargin{i+1}; rm_inds = [rm_inds i, i+1]; elseif strcmpi(varargin{i}, LETTERFILE = varargin{i+1}; rm_inds = [rm_inds i, i+1]; elseif strcmpi(varargin{i}, lo = varargin{i+1}; rm_inds = [rm_inds i, i+1]; end end
function argStruct = NameValuePairToStruct(defaults, varargin) %NAMEVALUEPAIRTOSTRUCT Converts name/value pairs to a struct. % % ARGSTRUCT = NAMEVALUEPAIRTOSTRUCT(DEFAULTS, VARARGIN) converts % name/value pairs to a struct, with defaults. The function expects an % even number of arguments to VARARGIN, alternating NAME then VALUE. % (Each NAME should be a valid variable name.) % % Examples: % % No defaults % NameValuePairToStruct(struct, ... % % % % % With defaults % NameValuePairToStruct( ... % struct( % % % % % See also: inputParser nArgs = length(varargin); if rem(nArgs, 2) ~= 0 error( end argStruct = defaults; for i = 1:2:nArgs name = varargin{i}; if ~isvarname(name) error( end argStruct = setfield(argStruct, name, varargin{i + 1}); % end end
function example(varargin) defaults = struct( params = struct(varargin{:}); for f = fieldnames(defaults) if ~isfield(params, f{1}), params.(f{1}) = defaults.(f{1}); end end %now just access them as params.A, params.B
function htmldlg(varargin) names = { defaults = {[],[], [url, html,titleStr] = parsepvpairs(names,defaults,varargin{:}); %... code to create figure using the parsed input values end
function y = func(x, y, varargin) [u, v] = process_options(varargin,
function argtest(varargin) a = 1; for ii=1:length(varargin)/2 [~] = evalc([varargin{2*ii-1} end; disp(a); who
% Overlay default fields with input fields % Good for option management % Arguments % $opts - Default options % $optsIn - Input options % Can be struct(), cell of {name, value, ...}, or empty [] % $recurseStructs - Applies optOverlay to any existing structs, given new % value is a struct too and both are 1x1 structs % Output % $opts - Outputs with optsIn values overlayed function [opts] = optOverlay(opts, optsIn, recurseStructs) if nargin < 3 recurseStructs = false; end isValid = @(o) isstruct(o) && length(o) == 1; assert(isValid(opts), assert(isValid(optsIn), if ~isempty(optsIn) if iscell(optsIn) optsIn = struct(optsIn{:}); end assert(isstruct(optsIn)); fields = fieldnames(optsIn); for i = 1:length(fields) field = fields{i}; assert(isfield(opts, field), newValue = optsIn.(field); % Apply recursion if recurseStructs curValue = opts.(field); % Both values must be proper option structs if isValid(curValue) && isValid(newValue) newValue = optOverlay(curValue, newValue, true); end end opts.(field) = newValue; end end end
function argStruct = getnargs(varargin, defaults, restrict_flag) %GETNARGS Converts name/value pairs to a struct (this allows to process named optional arguments). % % ARGSTRUCT = GETNARGS(VARARGIN, DEFAULTS, restrict_flag) converts % name/value pairs to a struct, with defaults. The function expects an % even number of arguments in VARARGIN, alternating NAME then VALUE. % (Each NAME should be a valid variable name and is case sensitive.) % Also VARARGIN should be a cell, and defaults should be a struct(). % Optionally: you can set restrict_flag to true if you want that only arguments names specified in defaults be allowed. Also, if restrict_flag = 2, arguments that aren % After calling this function, you can access your arguments using: argstruct.your_argument_name % % Examples: % % No defaults % getnargs( { % % With defaults % getnargs( { % struct( % % See also: inputParser % % Authors: Jonas, Richie Cotton and LRQ3000 % % Extract the arguments if it if (numel(varargin) == 1) varargin = varargin{:}; end % Sanity check: we need a multiple of couples, if we get an odd number of arguments then that nArgs = length(varargin); if rem(nArgs, 2) ~= 0 error( end % Sanity check: if defaults is not supplied, it if ~exist( defaults = struct; end if ~exist( restrict_flag = false; end % Syntactic sugar: if defaults is also a cell instead of a struct, we convert it on-the-fly if iscell(defaults) defaults = struct(defaults{:}); end optionNames = fieldnames(defaults); % extract all default arguments names (useful for restrict_flag) argStruct = defaults; % copy over the defaults: by default, all arguments will have the default value.After we will simply overwrite the defaults with the user specified values. for i = 1:2:nArgs % iterate over couples of argument/value varname = varargin{i}; % make case insensitive % check that the supplied name is a valid variable identifier (it does not check if the variable is allowed/declared in defaults, just that it if ~isvarname(varname) error( % if options are restricted, check that the argument elseif restrict_flag && ~isempty(defaults) && ~any(strmatch(varname, optionNames)) if restrict_flag ~= 2 % restrict_flag = 2 means that we just ignore this argument, else we show an error error( end % else alright, we replace the default value for this argument with the user supplied one (or we create the variable if it wasn else argStruct = setfield(argStruct, varname, varargin{i + 1}); % end end end
function varspull(s) % Import variables in a structures into the local namespace/workspace % eg: s = struct( % Will print: 1 and qwerty % % % Author: Jason S % for n = fieldnames(s)' name = n{1}; value = s.(name); assignin( end end
g=@() zeros(1000,0)*zeros(0,1000) timeit(g) ans = 9.2048e-06
n=unique(round(logspace(0,4,200))); for k=1:length(n) f=@() zeros(n(k)); t1(k)=timeit(f); g=@() zeros(n(k),0)*zeros(0,n(k)); t2(k)=timeit(g); end loglog(n,t1, legend( xlabel(
n = 1e4; clear z1 tic z1 = zeros( n ); for cc = 1 : n z1(:,cc)=cc; end toc % Elapsed time is 0.445780 seconds. %% clear z0 tic z0 = zeros(n,0)*zeros(0,n); for cc = 1 : n z0(:,cc)=cc; end toc % Elapsed time is 0.297953 seconds.
>> g = @() zeros(1000, 0) * zeros(0, 1000); >> f = @() zeros(1000) f = @()zeros(1000) >> timeit(f) ans = 8.5019e-04 >> timeit(f) ans = 8.4627e-04 >> timeit(g) ans = 8.4627e-04
int main(int argc, char **argv) { for (int i = 1975; i <= 2100; i+=25) { timer::start(); double *foo = (double *)malloc(i * i * sizeof(double)); for (int k = 0; k < i * i; k++) foo[k] = 0; double mftime = timer::stop(); free(foo); timer::start(); double *bar = (double *)malloc(i * i * sizeof(double)); memset(bar, 0, i * i * sizeof(double)); double mmtime = timer::stop(); free(bar); timer::start(); double *baz = (double *)calloc(i * i, sizeof(double)); double catime = timer::stop(); free(baz); printf("%d, %lf, %lf, %lf\n", i, mftime, mmtime, catime); } }
$ ./test 1975, 0.013812, 0.013578, 0.003321 2000, 0.014144, 0.013879, 0.003408 2025, 0.014396, 0.014219, 0.003490 2050, 0.014732, 0.013784, 0.000043 2075, 0.015022, 0.014122, 0.000045 2100, 0.014606, 0.014480, 0.000045
>> test 1975, 0.003296, 0.003297 2000, 0.003377, 0.003385 2025, 0.003465, 0.003464 2050, 0.015987, 0.000019 2075, 0.016373, 0.000019 2100, 0.016762, 0.000020
N = 1000; clear z tic, z = zeros(N,N); toc tic, z = z + 1; toc assert(isequal(z,ones(N))) clear z tic, z = zeros(N,0)*zeros(0,N); toc tic, z = z + 1; toc assert(isequal(z,ones(N))) clear z tic, z(N,N) = 0; toc tic, z = z + 1; toc assert(isequal(z,ones(N))) clear z tic, z = full(spalloc(N,N,0)); toc tic, z = z + 1; toc assert(isequal(z,ones(N))) clear z tic, z(1:N,1:N) = 0; toc tic, z = z + 1; toc assert(isequal(z,ones(N))) clear z val = 0; tic, z = val(ones(N)); toc tic, z = z + 1; toc assert(isequal(z,ones(N))) clear z tic, z = repmat(0, [N N]); toc tic, z = z + 1; toc assert(isequal(z,ones(N)))
Elapsed time is 0.004525 seconds. Elapsed time is 0.000792 seconds. Elapsed time is 0.000052 seconds. Elapsed time is 0.004365 seconds. Elapsed time is 0.000053 seconds. Elapsed time is 0.004119 seconds.
Elapsed time is 0.001463 seconds. Elapsed time is 0.003751 seconds. Elapsed time is 0.006820 seconds. Elapsed time is 0.000647 seconds. Elapsed time is 0.034880 seconds. Elapsed time is 0.000911 seconds. Elapsed time is 0.001320 seconds. Elapsed time is 0.003749 seconds.
N = 1000; tic, a = cell(N,N); toc tic, b = repmat({[]}, [N,N]); toc tic, c{N,N} = []; toc
Elapsed time is 0.001245 seconds. Elapsed time is 0.040698 seconds. Elapsed time is 0.004846 seconds.
>> assert(isequal(a,b,c)) >> whos a b c Name Size Bytes Class Attributes a 1000x1000 8000000 cell b 1000x1000 112000000 cell c 1000x1000 8000104 cell
function compare_zeros_init() iter = 100; for N = 512.*(1:8) % ZEROS(N,N) t = zeros(iter,3); for i=1:iter clear z tic, z = zeros(N,N); t(i,1) = toc; tic, z(:) = 9; t(i,2) = toc; tic, z = z + 1; t(i,3) = toc; end fprintf( % z(N,N)=0 t = zeros(iter,3); for i=1:iter clear z tic, z(N,N) = 0; t(i,1) = toc; tic, z(:) = 9; t(i,2) = toc; tic, z = z + 1; t(i,3) = toc; end fprintf( % ZEROS(N,0)*ZEROS(0,N) t = zeros(iter,3); for i=1:iter clear z tic, z = zeros(N,0)*zeros(0,N); t(i,1) = toc; tic, z(:) = 9; t(i,2) = toc; tic, z = z + 1; t(i,3) = toc; end fprintf( end end
>> compare_zeros_init N = 512, ZEROS = 0.001560168 N = 512, GROW = 0.001479991 N = 512, MULT = 0.001457031 N = 1024, ZEROS = 0.005744873 N = 1024, GROW = 0.005352638 N = 1024, MULT = 0.005359236 N = 1536, ZEROS = 0.011950846 N = 1536, GROW = 0.009051589 N = 1536, MULT = 0.008418878 N = 2048, ZEROS = 0.012154002 N = 2048, GROW = 0.010996315 N = 2048, MULT = 0.011002169 N = 2560, ZEROS = 0.017940950 N = 2560, GROW = 0.017641046 N = 2560, MULT = 0.017640323 N = 3072, ZEROS = 0.025657999 N = 3072, GROW = 0.025836506 N = 3072, MULT = 0.051533432 N = 3584, ZEROS = 0.074739924 N = 3584, GROW = 0.070486857 N = 3584, MULT = 0.072822335 N = 4096, ZEROS = 0.098791732 N = 4096, GROW = 0.095849788 N = 4096, MULT = 0.102148452
tic; x=zeros(1000,1000); toc Elapsed time is 0.002863 seconds. tic; clear x; x(1000,1000)=0; toc Elapsed time is 0.000282 seconds. tic; x=full(spalloc(1000,1000,0)); toc Elapsed time is 0.000273 seconds. tic; x=spalloc(1000,1000,1000000); toc %Is this the same for practical purposes? Elapsed time is 0.000281 seconds.
figHandles = findall(groot, figHandles = findall(0,
[points(:,1), points(:,2)] = intersections(... obj.modifiedVGVertices(1,:), obj.modifiedVGVertices(2,:), ... [vertex1(1) vertex2(1)], [vertex1(2) vertex2(2)]);
>> points points = 12.0000 15.0000 33.0000 24.0000 33.0000 24.0000 >> vertex1 vertex1 = 12 15 >> vertex2 vertex2 = 33 24
points = points((points(:,1) ~= vertex1(1)) | (points(:,2) ~= vertex1(2)), :); points = points((points(:,1) ~= vertex2(1)) | (points(:,2) ~= vertex2(2)), :);
>> points(1) ~= vertex2(1) ans = 0 >> points(2) ~= vertex2(2) ans = 1 % <-- It means 24.0000 is not equal to 24.0000?
points = [12.0000 15.0000 33.0000 24.0000 33.0000 24.0000]; vertex1 = [12 ; 15]; vertex2 = [33 ; 24]; points = points((points(:,1) ~= vertex1(1)) | (points(:,2) ~= vertex1(2)), :); points = points((points(:,1) ~= vertex2(1)) | (points(:,2) ~= vertex2(2)), :);
>> pi ans = 3.1416 >> format long >> pi ans = 3.141592653589793 >> num2hex(pi) ans = 400921fb54442d18
>> a=sum([0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1]); % Sum 10 0.1s >> b=1; % Initialize to 1 >> a == b ans = logical 0 % They are unequal! >> num2hex(a) % Let ans = 3fefffffffffffff >> num2hex(b) ans = 3ff0000000000000
a = 24; b = 24.000001; tolerance = 0.001; if abs(a-b) < tolerance, disp(
points = points((abs(points(:,1)-vertex1(1)) > tolerance) | ... (abs(points(:,2)-vertex1(2)) > tolerance),:)
>> realmin ans = 2.225073858507201e-308 >> realmax ans = 1.797693134862316e+308
>> eps(1) ans = 2.220446049250313e-16 >> eps(1000) ans = 1.136868377216160e-13
>> format long % Display full precision >> x = rand(1, 10); % Get 10 random values between 0 and 1 >> a = mean(x) % Take the mean a = 0.587307428244141 >> b = mean(x+10000)-10000 % Take the mean at a different scale, then shift back b = 0.587307428244458
% Function that takes two arguments, X & Y, followed by a variable % number of additional arguments function varlist(X,Y,varargin) fprintf( nVarargs = length(varargin); fprintf( for k = 1:nVarargs fprintf( end
function [ output_args ] = input_example( a, b, c ) if nargin < 1 error( end if nargin < 2 b = 20 end if nargin < 3 c = 30 end end
function [a] = train(x, y, opt) if (~exist( opt = true; end end
LOG_20120509_120002_002.csv (year)(month)(day)_(hour)(minute)(second)_(log part number)
loop through each day loop through each hour read in LOG_DATA for whole hour loop through each segment read in LOG for each segment compile a table of all the data
files = dir( for file = files' csv = load(file.name); % Do some stuff end
files = dir (strcat(path, L = length (files); for i=1:L image{i}=csvread(strcat(path, % process the image in here end
combs = [ 1 3 10 1 3 20 1 6 10 1 6 20 1 9 10 1 9 20 2 3 10 2 3 20 2 6 10 2 6 20 2 9 10 2 9 20 ]
vectors = { [1 2], [3 6 9], [10 20] }; % n = numel(vectors); % combs = cell(1,n); % [combs{end:-1:1}] = ndgrid(vectors{end:-1:1}); % % % combs = cat(n+1, combs{:}); % combs = reshape(combs,[],n); %
vectors = {[1 2], [3 6 9], [10 20]}; combs = combvec(vectors{:}).
combs = 1 3 10 2 3 10 1 6 10 2 6 10 1 9 10 2 9 10 1 3 20 2 3 20 1 6 20 2 6 20 1 9 20 2 9 20
combs = sortrows(combvec(vectors{:}). % Or equivalently as per @LuisMendo in the comments: % combs = fliplr(combvec(vectors{end:-1:1}).
combs = 1 3 10 1 3 20 1 6 10 1 6 20 1 9 10 1 9 20 2 3 10 2 3 20 2 6 10 2 6 20 2 9 10 2 9 20
vectors = [1 2;3 6;10 20]; vectors = num2cell(vectors,2); combs = sortrows(combvec(vectors{:}).
function combs = f1(vectors) n = numel(vectors); % combs = cell(1,n); % [combs{end:-1:1}] = ndgrid(vectors{end:-1:1}); % % % combs = cat(n+1, combs{:}); % combs = reshape(combs,[],n);
function combs = f2(vectors) combs = combvec(vectors{:}).
nn = 20:20:240; t1 = []; t2 = []; for n = nn; % vectors = {1:n/10, 1:n, 1:n*10}; t = timeit(@() f1(vectors)); t1 = [t1; t]; t = timeit(@() f2(vectors)); t2 = [t2; t]; end
tic; v = {[1 2], [3 6 9], [10 20]}; L = [0 cumsum(cellfun(@length,v))]; V = cell2mat(v); J = nchoosek(1:L(end),length(v)); J(any(J>repmat(L(2:end),[size(J,1) 1]),2) | ... any(J<=repmat(L(1:end-1),[size(J,1) 1]),2),:) = []; V(J) toc
ans = 1 3 10 1 3 20 1 6 10 1 6 20 1 9 10 1 9 20 2 3 10 2 3 20 2 6 10 2 6 20 2 9 10 2 9 20 Elapsed time is 0.018434 seconds.
J = 1 2 3 1 2 4 1 2 5 1 2 6 1 2 7 1 3 4 1 3 5 1 3 6 1 3 7 1 4 5 1 4 6 1 4 7 1 5 6 1 5 7 1 6 7 2 3 4 2 3 5 2 3 6 2 3 7 2 4 5 2 4 6 2 4 7 2 5 6 2 5 7 2 6 7 3 4 5 3 4 6 3 4 7 3 5 6 3 5 7 3 6 7 4 5 6 4 5 7 4 6 7 5 6 7
>> i=imread( >> j=imread( >> i=rgb2gray(i); >> j=rgb2gray(j); >> [a, b]=sift(i); % a has the frames and b has the descriptors >> [c, d]=sift(j);
I = imread( J = imread( I = single(rgb2gray(I)); % Conversion to single is recommended J = single(rgb2gray(J)); % in the documentation [F1 D1] = vl_sift(I); [F2 D2] = vl_sift(J); % Where 1.5 = ratio between euclidean distance of NN2/NN1 [matches score] = vl_ubcmatch(D1,D2,1.5); subplot(1,2,1); imshow(uint8(I)); hold on; plot(F1(1,matches(1,:)),F1(2,matches(1,:)), subplot(1,2,2); imshow(uint8(J)); hold on; plot(F2(1,matches(2,:)),F2(2,matches(2,:)),
rng(1) x=rand(1,100)*5; y=rand(1,100)*5; voronoi(x,y);
dt=delaunayTriangulation([x;y]. cc=circumcenter(dt); %voronoi edges
for ii=1:size(cc,1) if cc(ii,1)>0 && cc(ii,1)<5 && cc(ii,2)>0 && cc(ii,2)<5 point=dt.Points(dt.ConnectivityList(ii,1),:); %the first one, or any other (they are the same distance) distance(ii)=sqrt((cc(ii,1)-point(1)).^2+(cc(ii,2)-point(2)).^2); end end
hold on ang=0:0.01:2*pi; xp=r*cos(ang); yp=r*sin(ang); point=cc(ind,:); voronoi(x,y) triplot(dt, plot(point(1)+xp,point(2)+yp, plot(point(1),point(2),
function [xBest,yBest,R] = q42806059 rng(1) x=rand(1,100)*5; y=rand(1,100)*5; %% Find the approximate region(s) where there exists a point farthest from all the rest: xExtent = linspace(min(x),max(x),numel(x)); yExtent = linspace(min(y),max(y),numel(y)). % Create a grid: [XX,YY] = meshgrid(xExtent,yExtent); % Compute pairwise distance from grid points to free points: D = reshape(min(pdist2([XX(:),YY(:)],[x(:),y(:)]),[],2),size(XX)); % Intermediate plot: % figure(); plot(x,y, % Remove irrelevant candidates: D(D<prctile(D(:),95)) = NaN; D(D > xExtent | D > yExtent | D > yExtent(end)-yExtent | D > xExtent(end)-xExtent) = NaN; %% Keep only the region with the largest distance L = bwlabel(~isnan(D)); [~,I] = max(table2array(regionprops( D(L~=I) = NaN; % surf(XX,YY,D, %% Iterate until sufficient precision: xExtent = xExtent(~isnan(min(D,[],1, yExtent = yExtent(~isnan(min(D,[],2, cnt = 1; % increase or decrease according to the nature of the problem while true % Same ideas as above, so no explanations: xExtent = linspace(xExtent(1),xExtent(end),20); yExtent = linspace(yExtent(1),yExtent(end),20). [XX,YY] = meshgrid(xExtent,yExtent); D = reshape(min(pdist2([XX(:),YY(:)],[x(:),y(:)]),[],2),size(XX)); D(D<prctile(D(:),95)) = NaN; I = find(D == max(D(:))); xBest = XX(I); yBest = YY(I); if nanvar(D(:)) < 1E-10 || cnt == 10 R = D(I); break end xExtent = (1+[-1 +1]*10^-cnt)*xBest; yExtent = (1+[-1 +1]*10^-cnt)*yBest; cnt = cnt+1; end % Finally: % rectangle(
img = imread( %convert the image to a binary image points = img(:,:,3)<200; %compute the distance transform of the binary image dist = bwdist(points); %find the circle that has maximum radius radius = max(dist(:)); %find position of the circle [x y] = find(dist == radius); imshow(dist,[]); hold on plot(y,x,
function [x,y,r] = q42806059b(cloudOfPoints) % Problem setup if nargin == 0 rng(1) cloudOfPoints = rand(100,2)*5; % equivalent to Ander end %{ figure(); plot(cloudOfPoints(:,1),cloudOfPoints(:,2), set(gca, %} nVariables = 3; options = optimoptions(@ga, S = max(cloudOfPoints,[],1); L = min(cloudOfPoints,[],1); % Find geometric bounds: % In R2017a: use [S,L] = bounds(cloudOfPoints,1); % Here we also define distance-from-boundary constraints. g = ga(@(g)vectorized_fitness(g,cloudOfPoints,[L;S]), nVariables,... [],[], [],[], [L 0],[S min(S-L)], [], options); x = g(1); y = g(2); r = g(3); %{ plot(x,y, rectangle( %} function f = vectorized_fitness(genes,pts,extent) % genes = [x,y,r] % extent = [Xmin Ymin; Xmax Ymax] % f, the fitness, is the largest radius. f = min(pdist2(genes(:,1:2), pts, % Instant death if circle contains a point: f( f < genes(:,3) ) = Inf; % Instant death if circle is too close to boundary: f( any( genes(:,3) > genes(:,1:2) - extent(1,:) | ... genes(:,3) > extent(2,:) - genes(:,1:2), 2) ) = Inf; % Note: this condition may possibly be specified using the A,b inputs of ga(). f(isfinite(f)) = -genes(isfinite(f),3); %DEBUG: %{ scatter(genes(:,1),genes(:,2),10 ,[0, .447, .741] , z = ~isfinite(f); scatter(genes(z,1),genes(z,2),30, z = isfinite(f); scatter(genes(z,1),genes(z,2),30, [~,I] = sort(f); scatter(genes(I(1:5),1),genes(I(1:5),2),30, %}
figure(2); plot(something); ... figure(3); plot(something else); ...
figHandle.PaperOrientation = figHandle.PaperUnits =
[~, sortIndex] = sort(A(:), maxIndex = sortIndex(1:5); % Get a linear index into A of the 5 largest values
sortedValues = unique(A(:)); % Unique sorted values maxValues = sortedValues(end-4:end); % Get the 5 largest values maxIndex = ismember(A, maxValues); % Get a logical index of all values % equal to the 5 largest values
Arraycopy = Array; for j = 1:n [a, Index(j)] = max(Arraycopy); Arraycopy(Index(j)) = -inf; end maximumValues = Array(Index);
function setupPaths(projectName) basedir = fullfile( addpath(genpath(fullfile(basedir, projectName))); switch (projectName) case { addpath(genpath(fullfile(basedir, end
tic; x = zeros(1e8,1); toc Elapsed time is 0.260525 seconds.
tic; x(:) = 1; toc Elapsed time is 0.094316 seconds.
eff_bandwidth = numel(x) * 8 bytes per double * 2 / time
tic; x(1:end) = 2; toc Elapsed time is 0.496476 seconds.
tic; x(1:1e8) = 3; toc Elapsed time is 0.482083 seconds.
tic; id = 1:1e8; % colon(1,1e8); x(id) = 4; toc Elapsed time is 1.208419 seconds.
tic; for i=1:numel(x) x(i) = 5; end toc Elapsed time is 0.788944 seconds.
tic; for i=1:1e8 x(i) = 6; end toc Elapsed time is 0.321246 seconds.
tic; id = logical(ones(1, 1e8)); x(id) = 7; toc Elapsed time is 0.613363 seconds.
function test tic; x = zeros(1,1e8); toc tic; x(:) = 1; toc tic; x(1:end) = 2; toc tic; x(1:1e8) = 3; toc tic; id = 1:1e8; % colon(1,1e8); x(id) = 4; toc tic; for i=1:numel(x) x(i) = 5; end toc tic; for i=1:1e8 x(i) = 6; end toc end
% with JIT no JIT 0.1677 0.0011 % 0.0974 0.0936 % 0.4005 0.4028 % 0.4047 0.4005 % 1.1160 1.1180 % 0.8221 48.3239 % 0.3232 48.2197 % 0.5464 %
% withoutJit./withJit 0.0067 % 0.9614 % 1.0057 % 0.9897 % 1.0018 % 58.7792 % 149.2010 %
function tt = speedTest tt = zeros(8,1); tic; x = zeros(1,1e8); tt(1)=toc; x(:) = 2; tic; x(:) = 1; tt(2)=toc; tic; x(1:end) = 2; tt(3)=toc; tic; x(1:1e8) = 3; tt(4)=toc; tic; id = 1:1e8; % colon(1,1e8); x(id) = 4; tt(5)=toc; tic; for i=1:numel(x) x(i) = 5; end tt(6)=toc; tic; for i=1:1e8 x(i) = 6; end tt(7)=toc; % tic; id = true(1e8,1)); x(id)=7; tt(8)=toc;
tic; x = zeros(1e8,1); toc Elapsed time is 0.260525 seconds.
tic; id = 1:1e8; % colon(1,1e8); toc tic x(id) = 4; toc Elapsed time is 0.475243 seconds. Elapsed time is 0.763450 seconds.
tic(); id = malloc(sizeof(double)*n); for(i=0; i<n; i++) id[i] = i; toc("create id"); tic(); for(i=0; i<n; i++) { long iid = (long)id[i]; if(iid>=0 && iid<n && (double)iid==id[i]){ x[iid] = 4; } else break; } toc("x(id) = 4");
tic; id = uint32(1):1e8; toc tic x(id) = 8; toc Elapsed time is 0.327704 seconds. Elapsed time is 0.561121 seconds.
function [ array, listp, freep ] = initialize( size ) array = zeros(size, 3); listp = 0; freep = 1; end
[a b c] = yourfunction(optional) %your code a = 5; b = 7; c = 10; return end
mat = rand(5); % A 5-by-5 matrix of random values from 0 to 1 imagesc(mat); % Create a colored plot of the matrix values colormap(flipud(gray)); % Change the colormap to gray (so higher values are % black and lower values are white) textStrings = num2str(mat(:), textStrings = strtrim(cellstr(textStrings)); % Remove any space padding [x, y] = meshgrid(1:5); % Create x and y coordinates for the strings hStrings = text(x(:), y(:), textStrings(:), ... % Plot the strings midValue = mean(get(gca, textColors = repmat(mat(:) > midValue, 1, 3); % Choose white or black for the % text color of the strings so % they can be easily seen over % the background color set(hStrings, { set(gca,
int nodes, nodeX[MAX_POLY_CORNERS], pixelX, pixelY, i, j, swap ; for (pixelY=IMAGE_TOP; pixelY<IMAGE_BOT; pixelY++) { nodes=0; j=polyCorners-1; for (i=0; i<polyCorners; i++) { if (polyY[i]<(double) pixelY && polyY[j]>=(double) pixelY || polyY[j]<(double) pixelY && polyY[i]>=(double) pixelY) { nodeX[nodes++]=(int) (polyX[i]+(pixelY-polyY[i])/(polyY[j]-polyY[i]) *(polyX[j]-polyX[i])); } j=i; } i=0; while (i<nodes-1) { if (nodeX[i]>nodeX[i+1]) { swap=nodeX[i]; nodeX[i]=nodeX[i+1]; nodeX[i+1]=swap; if (i) i--; } else { i++; }} for (i=0; i<nodes; i+=2) { if (nodeX[i ]>=IMAGE_RIGHT) break; if (nodeX[i+1]> IMAGE_LEFT ) { if (nodeX[i ]< IMAGE_LEFT ) nodeX[i ]=IMAGE_LEFT ; if (nodeX[i+1]> IMAGE_RIGHT) nodeX[i+1]=IMAGE_RIGHT; for (j=nodeX[i]; j<nodeX[i+1]; j++) flagPixel(j,pixelY); }}}
void GetRandomPoint(Polygon p, ref float x, ref float y) { float xrand = random(); float yrand = random(); float h0 = p.Vertices[0] + xrand * p.Vertices[1]; float h1 = p.Vertices[2] + yrand * p.Vertices[3]; float v0 = p.Vertices[0] + xrand * p.Vertices[2]; float v1 = p.Vertices[1] + yrand * p.Vertices[3]; GetLineIntersection(h0, h1, v0, v1, x, y); }
CREATE or replace FUNCTION random_point(geometry) RETURNS geometry AS $$ DECLARE env geometry; corner1 geometry; corner2 geometry; minx real; miny real; maxx real; maxy real; x real; y real; ret geometry; begin select ST_Envelope($1) into env; select ST_PointN(ST_ExteriorRing(env),1) into corner1; select ST_PointN(ST_ExteriorRing(env),3) into corner2; select st_x(corner1) into minx; select st_x(corner2) into maxx; select st_y(corner1) into miny; select st_y(corner2) into maxy; loop select minx+random()*(maxx-minx) into x; select miny+random()*(maxy-miny) into y; select ST_SetSRID(st_point(x,y), st_srid($1)) into ret; if ST_Contains($1,ret) then return ret ; end if; end loop; end; $$ LANGUAGE plpgsql volatile RETURNS NULL ON NULL INPUT;
ha(1) = subplot(2,1,1); % get the axes handle when you create the subplot plot([1:10]); % Plot random stuff here as an example ha(2) = subplot(2,1,2); % get the axes handle when you create the subplot plot([1:10]+10); % Plot random stuff here as an example linkaxes(ha,
figure_handle = figure; subplot(2,1,1); plot([1:10]); subplot(2,1,2); plot([1:10]+10); % find all axes handle of type all_ha = findobj( figure_handle, linkaxes( all_ha,
figure;imagesc(data1); f1h=findobj(gcf,,’type’,’axes’) figure;imagesc(data2); f2h=findobj(gcf,,’type’,’axes’) linkaxes([f1h,f2h],’xy’)
set(gcf, set(gcf, set(gcf, set(gcf, set(gcf, set(gcf, set(gcf, set(gcf, print(gcf, print(gcf, print(gcf,
function printpdf(h,outfilename) set(h, set(h, pos=get(h, set(h, set(h, set(h, print(
function printpdf(h,outfilename) % first use the same non-relative unit system for paper and screen (see % below) set(h, % now get all existing plots/subplots a=get(h, nfigs=length(a); % bounds will contain lower-left and upper-right corners of plots plus one % line to make sure single plots work bounds=zeros(nfigs+1,4); bounds(end,1:2)=inf; bounds(end,3:4)=-inf; % generate all coordinates of corners of graphs and store them in % bounds as [lower-left-x lower-left-y upper-right-x upper-right-y] in % the same unit system as paper (centimeters here) for i=1:nfigs set(a(i), pos=get(a(i), inset=get(a(i), bounds(i,:)=[pos(1)-inset(1) pos(2)-inset(2) ... pos(1)+pos(3)+inset(3) pos(2)+pos(4)+inset(4)]; end % compute the rectangular convex hull of all plots and store that info % in mypos as [lower-left-x lower-left-y width height] in centimeters auxmin=min(bounds(:,1:2)); auxmax=max(bounds(:,3:4)); mypos=[auxmin auxmax-auxmin]; % set the paper to the exact size of the on-screen figure using % figure property PaperSize [width height] set(h, % ensure that paper position mode is in manual in order for the % printer driver to honor the figure properties set(h, % use the PaperPosition four-element vector [left, bottom, width, height] % to control the location on printed page; place it using horizontal and % vertical negative offsets equal to the lower-left coordinates of the % rectangular convex hull of the plot, and increase the size of the figure % accordingly set(h, mypos(3)+mypos(1) mypos(4)+mypos(2)]); % print stuff print(
h = figure; % For example, h = openfig( set(h, pos = get(h, set(h, print(h,
function SaveFigureAsVectorPDF(InputFigureHandle, OutFileName, ShouldPrintAxes) %% Check input parameters [NumberOfFigures, ~] = size(InputFigureHandle); if(NumberOfFigures ~= 1) error( end if(isempty(OutFileName)) error( end cUnit = %% Copy the input figure so we can mess with it %Make a copy of the figure so we don %original. FigureHandleCopy = copy(InputFigureHandle); %NOTE: Do not set this figure to be invisible, for some bizarre reason % it must be visible otherwise Matlab will just ignore attempts % to set its properties. % % I would prefer it if the figure did not briefly flicker into % view but I am not sure how to prevent that. %% Find the axis handle ChildAxisHandles = get(FigureHandleCopy, NumberOfChildFigures = length(ChildAxisHandles); if(NumberOfChildFigures ~= 1) %note that every plot has at least one child figure error( end AxisHandle = ChildAxisHandles(1); %% Set Units % It doesn % the figure, axis, and paper. Note that % does not support set(FigureHandleCopy, set(FigureHandleCopy, set(AxisHandle, %% Get old axis position and inset offsets %Note that the axes and title are contained in the inset OldAxisPosition = get(AxisHandle, OldAxisInset = get(AxisHandle, OldAxisWidth = OldAxisPosition(3); OldAxisHeight = OldAxisPosition(4); OldAxisInsetLeft = OldAxisInset(1); OldAxisInsetBottom = OldAxisInset(2); OldAxisInsetRight = OldAxisInset(3); OldAxisInsetTop = OldAxisInset(4); %% Set positions and size of the figure and the Axis if(~ShouldPrintAxes) FigurePosition = [0.0, 0.0, OldAxisWidth, OldAxisHeight]; PaperSize = [OldAxisWidth, OldAxisHeight]; AxisPosition = FigurePosition; else WidthWithInset = OldAxisWidth + OldAxisInsetLeft + OldAxisInsetRight; HeightWithInset = OldAxisHeight + OldAxisInsetTop + OldAxisInsetBottom; FigurePosition = [0.0, 0.0, WidthWithInset, HeightWithInset]; PaperSize = [WidthWithInset, HeightWithInset]; AxisPosition = [OldAxisInsetLeft, OldAxisInsetBottom, OldAxisWidth, OldAxisHeight]; end set(FigureHandleCopy, set(AxisHandle, %Note: these properties do not effect the preview but they are % absolutely necessary for the pdf!! set(FigureHandleCopy, set(FigureHandleCopy, %% Write the figure to the PDF file print( set(FigureHandleCopy, %If you want to see the figure (e.g., for debugging purposes), comment %the line below out. close(FigureHandleCopy); end
%% Generates a graph and saves it to pdf FigureHandle = figure; plot(1:100); title( %with axes SaveFigureAsVectorPDF(FigureHandle, %without axes SaveFigureAsVectorPDF(FigureHandle,
/usr/texbin/epstopdf "$1.eps" /usr/texbin/pdfcrop "$1.pdf" /usr/local/bin/pdftops -eps "$1-crop.pdf"`
Inkscape.exe --file SomePDFWithWhitespace.pdf --export-pdf=SomePDFWithWhitespaceRemoved.pdf --export-area-drawing
dir = theFunctionImLookingFor; system(fullfile(dir,
V = rand(10000000,1); % Run once tic; V1=V/norm(V); toc % result: 0.228273s tic; V2=V/sqrt(sum(V.*V)); toc % result: 0.325161s tic; V1=V/norm(V); toc % result: 0.218892s
clc; clear all; V = rand(1024*1024*32,1); N = 10; tic; for i=1:N, V1 = V/norm(V); end; toc % 6.3 s tic; for i=1:N, V2 = V/sqrt(sum(V.*V)); end; toc % 9.3 s tic; for i=1:N, V3 = V/sqrt(V tic; for i=1:N, V4 = V/sqrt(sum(V.^2)); end; toc % 9.2 s tic; for i=1:N, V1=V/norm(V); end; toc % 6.4 s
oldState = warning( % turn off DBZ warning uV = V/norm(V); warning(oldState); % Restore previous state
normV = norm(V); if normV > 0, % Or some other threshold, like EPS uV = V/normV; else, uV = V; % Do nothing since it end
clc; clear all; V = rand(1024*1024*32,1); N = 10; tic; for i=1:N, V1 = V/norm(V); end; toc % 7.0 s tic; for i=1:N, V2 = V/sqrt(sum(V.*V)); end; toc % 6.4 s tic; for i=1:N, V3 = V/sqrt(V tic; for i=1:N, V4 = V/sqrt(sum(V.^2)); end; toc % 6.6 s tic; for i=1:N, V1 = V/norm(V); end; toc % 7.1 s tic; for i=1:N, d = 1/norm(V); V1 = V*d;end; toc % 4.7 s
clc; clear all; m = 2048; V = rand(m); N = 100; tic; for i=1:N, V1 = V ./ (sum(V,2)*ones(1,m)); end; toc % 8.2 s tic; for i=1:N, V2 = bsxfun(@rdivide, V, sum(V,2)); end; toc % 5.8 s tic; for i=1:N, V3 = bsxfun(@rdivide, V, V*ones(m,1)); end; toc % 5.7 s tic; for i=1:N, V4 = V ./ (V*ones(m,m)); end; toc % 77.5 s tic; for i=1:N, d = 1./sum(V,2);V5 = bsxfun(@times, V, d); end; toc % 2.83 s tic; for i=1:N, d = 1./(V*ones(m,1));V6 = bsxfun(@times, V, d);end; toc % 2.75 s tic; for i=1:N, V1 = V ./ (sum(V,2)*ones(1,m)); end; toc % 8.2 s
clc; clear all; V = rand(1024*1024*32,1); N = 10; tic; for i=1:N, V1 = V/norm(V); end; toc % 4.5 s tic; for i=1:N, V2 = V/sqrt(sum(V.*V)); end; toc % 7.5 s tic; for i=1:N, V3 = V/sqrt(V tic; for i=1:N, V4 = V/sqrt(sum(V.^2)); end; toc % 6.8 s tic; for i=1:N, V1 = V/norm(V); end; toc % 4.7 s tic; for i=1:N, d = 1/norm(V); V1 = V*d;end; toc % 4.9 s tic; for i=1:N, d = norm(V)^-1; V1 = V*d;end;toc % 4.4 s
clc; clear all; V = rand(1024*1024*32,1); N = 10; tic; for i=1:N, d = 1/sqrt(V(1)*V(1)+V(2)*V(2)+V(3)*V(3)); V1 = V*d; end; toc % 1.5s
{ "cmd": ["/usr/local/octave/3.8.0/bin/octave-3.8.0", "$file"], "selector": "source.m" }
vec1 = 1:4; vec2 = 1:3; i = 0; pairs = zeros([4*3 2]); for val1 = vec1 for val2 = vec2 i = i + 1; pairs(i,1) = val1; pairs(i,2) = val2; end end
a = 1:4; b = 1:3; result = combvec(a,b); result = result'
[idx2, idx1] = find(true(numel(vec2),numel(vec1))); pairs = [reshape(vec1(idx1), [], 1), reshape(vec2(idx2), [], 1)];
a = 1:4; b = 1:3; c = reshape( repmat(a, numel(b), 1), numel(a) * numel(b), 1 ); d = repmat(b(:), length(a), 1); e = [c d] e = 1 1 1 2 1 3 2 1 2 2 2 3 3 1 3 2 3 3 4 1 4 2 4 3
x = [3,2,1]; y = [11,22,33,44,55]; v = [(ones(length(y),1) * x)(:), (ones(length(x), 1) * y)
x = [3,2,1]; y = [11,22,33,44,55]; A = ones(length(y),1) * x; B = (ones(length(x), 1) * y) v = [A(:) B(:)]
v = 3 11 3 22 3 33 3 44 3 55 2 11 2 22 2 33 2 44 2 55 1 11 1 22 1 33 1 44 1 55
v1 = 1: 1: 3; v2 = 11: 11: 44; v3 = 111:111:555; dimensions = cellfun(@numel, {v1,v2,v3}); [i1,i2,i3] = ind2sub(dimensions, 1:prod(dimensions)); combinations = [v1(i1); v2(i2); v3(i3)]'
>> pkg install -forge linear-algebra >> pkg load linear-algebra >> sortrows(cartprod(1:4,1:3)) ans = 1 1 1 2 1 3 2 1 2 2 2 3 3 1 3 2 3 3 4 1 4 2 4 3
t = 0:0.001:2*pi+0.001; figure(2); for i = 1 : 25; subplot(5,5,i); plot(t, sin(i*t)); axis off end
t = 0:0.001:2*pi+0.001; figure(2); for i = 1 : 25; subaxis(5,5,i, plot(t, sin(i*t)); axis tight axis off end
Fs = 1000; % Sampling frequency T = 1/Fs; % Sample time L = 1000; % Length of signal t = (0:L-1)*T; % Time vector % Sum of a 50 Hz sinusoid and a 120 Hz sinusoid x = 0.7*sin(2*pi*50*t) + sin(2*pi*120*t); y = x + 2*randn(size(t)); % Sinusoids plus noise plot(Fs*t(1:50),y(1:50)) title( xlabel(
NFFT = 2^nextpow2(L); % Next power of 2 from length of y Y = fft(y,NFFT)/L; f = Fs/2*linspace(0,1,NFFT/2+1); % Plot single-sided amplitude spectrum. plot(f,2*abs(Y(1:NFFT/2+1))) title( xlabel( ylabel(
fig1=figure; fig2=figure; drawnow; [a b]=do_complex_processing; change_current_figure(fig1) plot(a); change_current_figure(fig2) plot(b);
set(0, for i = 1:10 fprintf( figure; pause(1); end set(0, figHandles = findall(0, set(figHandles(:),
set(0, for i = 1:10 fprintf( figure; pause(1); end set(0,
classdef (Sealed) Colors properties (Constant) RED = 1; GREEN = 2; BLUE = 3; end methods (Access = private) % private so that you cant instantiate function out = Colors end end end
line1 = Colors.RED; ... if Colors.BLUE == line1 end
classdef Colors properties R = 0; G = 0; B = 0; end methods function c = Colors(r, g, b) c.R = r; c.G = g; c.B = b; end end enumeration Red (1, 0, 0) Green (0, 1, 0) Blue (0, 0, 1) end end
classdef(Enumeration) DmatFileMode < int32 enumeration ReadMode(0) ReadCompatibilityMode(1) WriteMode(2) end <snip> end
package test; public enum ColorEnum { RED, GREEN, BLUE }
mycolor = test.ColorEnum.RED if mycolor == test.ColorEnum.RED disp( else disp( end % Use ordinal() to get a primitive you can use in a switch statement switch mycolor.ordinal case test.ColorEnum.BLUE.ordinal disp( otherwise disp(sprintf( end
>> test.ColorEnum.RED == ans = 0 >> test.ColorEnum.RED == ans = 1 1 1
classdef (Sealed) Color %COLOR Example of Java-style typesafe enum for Matlab properties (Constant) RED = Color(1, GREEN = Color(2, BLUE = Color(3, end properties (SetAccess=private) % All these properties are immutable. Code; Name; end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% methods (Access = private) %private so that you can function out = Color(InCode, InName) out.Code = InCode; out.Name = InName; end end methods (Static = true) function needa(obj) %NEEDA Asserts that obj must be a Color if ~isa(obj, mfilename) error( end end end methods (Access = public) function display(obj) disp([inputname(1) disp(obj); end function disp(obj) if isscalar(obj) disp(sprintf( else disp(sprintf( end end function out = eq(a, b) %EQ Basic "type-safe" eq check_type_safety(a, b); out = [a.Code] == [b.Code]; end function [tf,loc] = ismember(a, b) check_type_safety(a, b); [tf,loc] = ismember([a.Code], [b.Code]); end function check_type_safety(varargin) %CHECK_TYPE_SAFETY Check that all inputs are of this enum type for i = 1:nargin if ~isa(varargin{i}, mfilename) error( end end end end end
function do_stuff_with_color(c) %DO_STUFF_WITH_COLOR Demo use of the Color typesafe enum Color.needa(c); % Make sure input was a color if (c == Color.BLUE) disp( else disp( end % To work with switch statements, you have to explicitly pop the code out switch c.Code case Color.BLUE.Code disp( otherwise disp(sprintf( end
>> Color.RED == Color.RED ans = 1 >> Color.RED == 1 ??? Error using ==> Color>Color.check_type_safety at 55 Non-typesafe comparison of Color vs. double Error in ==> Color>Color.eq at 44 check_type_safety(a, b); >> do_stuff_with_color(Color.BLUE) color was blue blue >> do_stuff_with_color(Color.GREEN) color was not blue some other color: GREEN >> do_stuff_with_color(1+1) % oops - passing the wrong type, should error ??? Error using ==> Color>Color.needa at 26 Input must be a Color; got a double Error in ==> do_stuff_with_color at 4 Color.needa(c); % Make sure input was a color >>
>> Colors.BLUE = 42 Colors = BLUE: 42 >> Color.BLUE = 42 Color = BLUE: 42 >> Color.RED ??? Reference to non-existent field
classdef (Sealed) Color %COLOR Example of Java-style typesafe enum for Matlab properties (Constant) RED = Color(1); GREEN = Color(2); BLUE = Color(3); end methods (Access = private) % private so that you can function out = Color(InCode) out.Code = InCode; end end % ============================================================================ % Everything from here down is completely boilerplate - no need to change anything. % ============================================================================ properties (SetAccess=private) % All these properties are immutable. Code; end properties (Dependent, SetAccess=private) Name; end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% methods function out = eq(a, b) %EQ Basic "type-safe" eq check_type_safety(a, b); out = reshape([a.Code],size(a)) == reshape([b.Code],size(b)); end function [tf,loc] = ismember(a, b) check_type_safety(a, b); [tf,loc] = ismember(reshape([a.Code],size(a)), [b.Code]); end function check_type_safety(varargin) %CHECK_TYPE_SAFETY Check that all inputs are of this enum type theClass = class(varargin{1}); for ii = 2:nargin if ~isa(varargin{ii}, theClass) error( end end end % Display stuff: function display(obj) disp([inputname(1) disp(obj); end function disp(obj) if isscalar(obj) fprintf( else fprintf( end end function name=get.Name(obj) mc=metaclass(obj); mp=mc.Properties; for ii=1:length(mp) if (mp{ii}.Constant && isequal(obj.(mp{ii}.Name).Code,obj.Code)) name = mp{ii}.Name; return; end; end; error( end; end end
A = NET.addAssembly(MyName.dll) % suppose you have enum called "MyAlerts" in your assembly myvar = MyName.MyAlerts.(
public enum MyAlerts { value_1 = 0, value_2 = 1, MyAlerts_Count = 2, }
No preallocation: 0.075524 Preallocate Using indexing: 0.063774 Preallocate with repmat: 0.005234
clear; N = 10000; %1) GROWING A STRUCT tic; for ii=1:N a(ii).x(1)=1; end noPreAll = toc; %2)PREALLOCATING A STRUCT tic; b = repmat( struct( for ii=1:N b(ii).x(1)=1; end; repmatBased=toc; %3)Index to preallocate c(N).x = 1; for ii=1:N c(ii).x(1)=1; end; preIndex=toc; disp([ disp([ disp([ No preallocation: 0.075524 Preallocate Indexing: 0.063774 Preallocate with repmat: 0.0052338 >>
xx = num2cell(1:100); [a(1:100).x]=deal(xx{:}); a(99).x ans = 99
No preallocation: 0.10137 Preallocate Indexing: 0.07615 Preallocate with repmat: 0.01458 Preallocate with struct: 0.07588
No preallocation: 0.0962 Preallocate Indexing: 0.0745 Preallocate with repmat: 0.0259 Preallocate with struct: 0.0184
>> [x, y] = deal(foo{:}); ??? Cell contents reference from a non-cell array object.
foo = [88, 12]; fooCell = num2cell(foo); [x y]=fooCell{:} x = 88 y = 12
foo = [88, 12]; fooCell = num2cell(foo); [x y]=deal(fooCell{:}) x = 88 y = 12
> z = plus(1,2) z = 3 > c = {1,2}; > z = plus(c{:}); z = 3
function varargout = list(x) % return matrix elements as separate output arguments % example: [a1,a2,a3,a4] = list(1:4) varargout = num2cell(x); end
foo = [88,12;89,13;90,14]; % fooCell = mat2cell(foo,size(foo,1),ones(size(foo,2),1)); [x,y] = deal(fooCell{:});
> foo = {88, 12} foo = { [1,1] = 88 [1,2] = 12 } > [x,y] = deal(foo{:}) x = 88 y = 12
>> [x,y,z,w] = deal(a,b,c,d) x = 123 y = 0.6370 0.2165 0.6711 0.2945 0.8803 0.2705 0.7633 0.1537 0.0767 z = [123] [3x3 double] w = field:
function varargout = arr2vars(arr) % Distribute elements over variables N = numel(arr); if nargout ~= N error( end for k = 1:N varargout{k} = arr(k); end
>>> foo = [88, 12]; >>> [x, y] = deal(foo(1), foo(2))
shuffledArray = orderedArray(randperm(size(orderedArray,1)),:);
matrix=matrix(randsample(1:length(matrix),length(matrix)),:);
function ret = shuffleRow(mat) [r c] = size(mat); shuffledRow = randperm(r); ret = mat(shuffledRow, :);
fcn1 = @() ...; fcn2 = @() ...; fcn3 = @() ...; fcnArray = {fcn1 fcn2 fcn3};
foo = @(x) cellfun(@feval,fcnArray,x); inArgs = {1 foo(inArgs); %
function F = createfcn(a,...) F = @myfunc; function b = myfunc(...) a = a+1; b = a; end end
call1 = @(a,b) a(); call12 = @(a,b) call1(b,call1(a,b));
>> print1=@()fprintf( >> print2=@()fprintf( >> call12(print1,print2) 1 2
call1(print3, call1(print2, call1(print1,print2)));
call1(print4, call1(print3, call1(print2, call1(print1,print2))));
call1arg1 = @(a,arg_a,b) a(arg_a); call12arg1 = @(a, arg_a, b, arg_b) call1arg1(b, arg_b, call1arg1(a, arg_a, b))
curly = @(x, varargin) x{varargin{:}}; f=@(x)curly({exp(x),log(x)}) [a,b]=f(2)
M=magic(4); % M = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1 X=[9 7 6 12]; % find(ismember(M,X),1) ans = 3
tolerance = 1e-16; %setting the desired tolerance find(sum(abs(M-ones(rows(M),1)*X),2)<tolerance)
function ind = findRow(M,X) tmp = M - repmat(X,size(M,1),1); ind = find(tmp,1); end
im = imread( f = figure, imshow(im, rectangle( print(f,
im = imread( [r,c,d] = size(im); x0 = 100; y0 = 100; w = 10; h = 10; x = [x0:x0+w x0*ones(1,h+1) x0:x0+w (x0+w)*ones(1,h+1)]; y = [y0*ones(1,w+1) y0:y0+h (y0+h)*ones(1,w+1) y0:y0+h]; index = sub2ind([r c],y,x); im(index) = 0; im(index+r*c) = 0; im(index+2*r*c) = 0; imwrite(im,
% prevent the figure window from appearing at all f = figure( % alternative way of hiding an existing figure set(f, % If you start getting odd error messages or blank images, % add in a DRAWNOW call. Sometimes it helps fix rendering % bugs, especially in long-running scripts on Linux. %drawnow; % optional: have the axes take up the whole figure subplot( % show the image and rectangle im = imread( imshow(im, rectangle( % Save the image, controlling exactly the output % image size (in this case, making it equal to % the input [H,W,D] = size(im); dpi = 100; set(f, set(f, print(f, sprintf(
function foo %% fancy code that works in both if (is_octave) %% use octave super_powers else %% do it matlab way end %% fancy code that works in both end %% subfunction that checks if we are in octave function r = is_octave () persistent x; if (isempty (x)) x = exist ( end r = x; end
x = rand(10).^3; x(:,3) = 1.3*mean(x,2); schemaball(x, {
h = schemaball; set(h.l(~isnan(h.l)), set(h.s, set(h.t,
[f, x] = hist(randn(10000, 1), 50); % Create histogram from a normal distribution. g = 1 / sqrt(2 * pi) * exp(-0.5 * x .^ 2); % pdf of the normal distribution % METHOD 1: DIVIDE BY SUM figure(1) bar(x, f / sum(f)); hold on plot(x, g, % METHOD 2: DIVIDE BY AREA figure(2) bar(x, f / trapz(x, f)); hold on plot(x, g,
% METHOD 3: DIVIDE BY AREA USING sum() figure(3) dx = diff(x(1:2)) bar(x, f / sum(f * dx)); hold on plot(x, g,
data = 2*randn(5000,1) + 5; % generate normal random (m=5, std=2) h = histogram(data,
Nbins = h.NumBins; edges = h.BinEdges; x = zeros(1,Nbins); for counter=1:Nbins midPointShift = abs(edges(counter)-edges(counter+1))/2; x(counter) = edges(counter)+midPointShift; end mu = mean(data); sigma = std(data); f = exp(-(x-mu).^2./(2*sigma^2))./(sigma*sqrt(2*pi));
A = randn(10000,1); centers = -6:0.5:6; d = diff(centers)/2; edges = [centers(1)-d(1), centers(1:end-1)+d, centers(end)+d(end)]; edges(2:end) = edges(2:end)+eps(edges(2:end)); figure; subplot(2,2,1); hist(A,centers); title( subplot(2,2,2); h = histogram(A,edges); title( subplot(2,2,3) [counts, centers] = hist(A,centers); %get the count with hist bar(centers,counts/trapz(centers,counts)) title( subplot(2,2,4) h = histogram(A,edges, title( dx = diff(centers(1:2)) normalization_difference_trapz = abs(counts/trapz(centers,counts) - h.Values); normalization_difference_sum = abs(counts/sum(counts*dx) - h.Values); max(normalization_difference_trapz) max(normalization_difference_sum)
Y = rand(10,1); C = hist(Y); C = C ./ sum(C); bar(C)
%http: N=10000; Nbins=50; [f,x]=hist(randn(N,1),Nbins); % create histogram from ND %METHOD 4: Count Densities, not Sums! figure(3) dx=diff(x(1:2)); % width of bin g=1/sqrt(2*pi)*exp(-0.5*x.^2) .* dx; % pdf of ND with dx % 1.0000 bar(x, f/sum(f));hold on plot(x,g,
%%METHOD 5: with histogram() % http: N=10000; figure(4); h = histogram(randn(N,1), Nbins=h.NumBins; edges=h.BinEdges; x=zeros(1,Nbins); f=h.Values; for counter=1:Nbins midPointShift=abs(edges(counter)-edges(counter+1))/2; % same constant for all x(counter)=edges(counter)+midPointShift; end dx=diff(x(1:2)); % constast for all g=1/sqrt(2*pi)*exp(-0.5*x.^2) .* dx; % pdf of ND % Use if Nbins manually set %new_area=sum(f)/N % diff of consecutive edges constant % Use if histogarm() Normalization probability new_area=sum(f) % 1.0000 % No bar() needed here with histogram() Normalization probability hold on; plot(x,g,
[N,h]=hist(q_f./theta,30000); % there Is a large range but most of the bins will be empty plot(h,N/(sum(N)*mean(diff(h))),
>> tic; for i = 1:1e6, x=5*ones(10,1); end; toc Elapsed time is 3.426347 seconds. >> tic; for i = 1:1e6, y=repmat(5,10,1); end; toc Elapsed time is 20.603680 seconds.
>> tic; x=5*ones(10,1); toc Elapsed time is 0.000415 seconds.
>> tic; x=5; x=x(ones(10,1)); toc Elapsed time is 0.000257 seconds.
>> A = zeros(5); >> V = [1 3 4]; >> A(V,V) = 1 A = 1 0 1 1 0 0 0 0 0 0 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0
A = magic(4) A(logical(eye(size(A)))) = 99 A = 99 2 3 13 5 99 10 8 9 7 99 12 4 14 15 99
[nRows,nCols] = size(A); A(1:(nRows+1):nRows*nCols) = 101 A = 101 2 3 13 5 101 10 8 9 7 101 12 4 14 15 101
subsetIdx = [1 3]; diagonalIdx = (subsetIdx-1) * (nRows + 1) + 1; A(diagonalIdx) = 203 A = 203 2 3 13 5 101 10 8 9 7 203 12 4 14 15 101
diagonalIdx = false(nRows,1); diagonalIdx(subsetIdx) = true; A(diag(diagonalIdx)) = -1 A = -1 2 3 13 5 101 10 8 9 7 -1 12 4 14 15 101
>> tt = zeros(5,5) tt = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 >> tt(1:6:end) = 3 tt = 3 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 3
>> V=[1 2 5]; N=5; >> tt = zeros(N,N); >> tt((N+1)*(V-1)+1) = 3 tt = 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3
A = zeros(7,6); V = [1 3 5]; [n m] = size(A); diagIdx = 1:n+1:n*m; A( diagIdx(V) ) = 1 A = 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
>> A=randn(10000,10000); >> tic;A(logical(eye(size(A))))=12;toc
>> B=[0,4,4;4,0,4;4,4,0] B = 0 4 4 4 0 4 4 4 0 >> v=[1,2,3] v = 1 2 3 >> B(eye(size(B))==1)=v %insert values from v to eye positions in B B = 1 4 4 4 2 4 4 4 3
A = zeros(4) V=[2 4] idx = sub2ind(size(A), V,V) % idx = [6, 16] A(idx) = 1 % A = % 0 0 0 0 % 0 1 0 0 % 0 0 0 0 % 0 0 0 1
curve = [8.4663 8.3457 5.4507 5.3275 4.8305 4.7895 4.6889 4.6833 4.6819 4.6542 4.6501 4.6287 4.6162 4.585 4.5535 4.5134 4.474 4.4089 4.3797 4.3494 4.3268 4.3218 4.3206 4.3206 4.3203 4.2975 4.2864 4.2821 4.2544 4.2288 4.2281 4.2265 4.2226 4.2206 4.2146 4.2144 4.2114 4.1923 4.19 4.1894 4.1785 4.178 4.1694 4.1694 4.1694 4.1556 4.1498 4.1498 4.1357 4.1222 4.1222 4.1217 4.1192 4.1178 4.1139 4.1135 4.1125 4.1035 4.1025 4.1023 4.0971 4.0969 4.0915 4.0915 4.0914 4.0836 4.0804 4.0803 4.0722 4.065 4.065 4.0649 4.0644 4.0637 4.0616 4.0616 4.061 4.0572 4.0563 4.056 4.0545 4.0545 4.0522 4.0519 4.0514 4.0484 4.0467 4.0463 4.0422 4.0392 4.0388 4.0385 4.0385 4.0383 4.038 4.0379 4.0375 4.0364 4.0353 4.0344]; plot(1:100, curve)
curve = [8.4663 8.3457 5.4507 5.3275 4.8305 4.7895 4.6889 4.6833 4.6819 4.6542 4.6501 4.6287 4.6162 4.585 4.5535 4.5134 4.474 4.4089 4.3797 4.3494 4.3268 4.3218 4.3206 4.3206 4.3203 4.2975 4.2864 4.2821 4.2544 4.2288 4.2281 4.2265 4.2226 4.2206 4.2146 4.2144 4.2114 4.1923 4.19 4.1894 4.1785 4.178 4.1694 4.1694 4.1694 4.1556 4.1498 4.1498 4.1357 4.1222 4.1222 4.1217 4.1192 4.1178 4.1139 4.1135 4.1125 4.1035 4.1025 4.1023 4.0971 4.0969 4.0915 4.0915 4.0914 4.0836 4.0804 4.0803 4.0722 4.065 4.065 4.0649 4.0644 4.0637 4.0616 4.0616 4.061 4.0572 4.0563 4.056 4.0545 4.0545 4.0522 4.0519 4.0514 4.0484 4.0467 4.0463 4.0422 4.0392 4.0388 4.0385 4.0385 4.0383 4.038 4.0379 4.0375 4.0364 4.0353 4.0344]; % nPoints = length(curve); allCoord = [1:nPoints;curve] % firstPoint = allCoord(1,:); % lineVec = allCoord(end,:) - firstPoint; % lineVecN = lineVec / sqrt(sum(lineVec.^2)); % % vecFromFirst = bsxfun(@minus, allCoord, firstPoint); % % % % % % % % % % scalarProduct = dot(vecFromFirst, repmat(lineVecN,nPoints,1), 2); vecFromFirstParallel = scalarProduct * lineVecN; vecToLine = vecFromFirst - vecFromFirstParallel; % distToLine = sqrt(sum(vecToLine.^2,2)); % figure( % [maxDist,idxOfBestPoint] = max(distToLine); % figure, plot(curve) hold on plot(allCoord(idxOfBestPoint,1), allCoord(idxOfBestPoint,2),
import numpy as np curve = [8.4663, 8.3457, 5.4507, 5.3275, 4.8305, 4.7895, 4.6889, 4.6833, 4.6819, 4.6542, 4.6501, 4.6287, 4.6162, 4.585, 4.5535, 4.5134, 4.474, 4.4089, 4.3797, 4.3494, 4.3268, 4.3218, 4.3206, 4.3206, 4.3203, 4.2975, 4.2864, 4.2821, 4.2544, 4.2288, 4.2281, 4.2265, 4.2226, 4.2206, 4.2146, 4.2144, 4.2114, 4.1923, 4.19, 4.1894, 4.1785, 4.178, 4.1694, 4.1694, 4.1694, 4.1556, 4.1498, 4.1498, 4.1357, 4.1222, 4.1222, 4.1217, 4.1192, 4.1178, 4.1139, 4.1135, 4.1125, 4.1035, 4.1025, 4.1023, 4.0971, 4.0969, 4.0915, 4.0915, 4.0914, 4.0836, 4.0804, 4.0803, 4.0722, 4.065, 4.065, 4.0649, 4.0644, 4.0637, 4.0616, 4.0616, 4.061, 4.0572, 4.0563, 4.056, 4.0545, 4.0545, 4.0522, 4.0519, 4.0514, 4.0484, 4.0467, 4.0463, 4.0422, 4.0392, 4.0388, 4.0385, 4.0385, 4.0383, 4.038, 4.0379, 4.0375, 4.0364, 4.0353, 4.0344] nPoints = len(curve) allCoord = np.vstack((range(nPoints), curve)).T np.array([range(nPoints), curve]) firstPoint = allCoord[0] lineVec = allCoord[-1] - allCoord[0] lineVecNorm = lineVec / np.sqrt(np.sum(lineVec**2)) vecFromFirst = allCoord - firstPoint scalarProduct = np.sum(vecFromFirst * np.matlib.repmat(lineVecNorm, nPoints, 1), axis=1) vecFromFirstParallel = np.outer(scalarProduct, lineVecNorm) vecToLine = vecFromFirst - vecFromFirstParallel distToLine = np.sqrt(np.sum(vecToLine ** 2, axis=1)) idxOfBestPoint = np.argmax(distToLine)
%% Order curve = [8.4663 8.3457 5.4507 5.3275 4.8305 4.7895 4.6889 4.6833 4.6819 4.6542 4.6501 4.6287 4.6162 4.585 4.5535 4.5134 4.474 4.4089 4.3797 4.3494 4.3268 4.3218 4.3206 4.3206 4.3203 4.2975 4.2864 4.2821 4.2544 4.2288 4.2281 4.2265 4.2226 4.2206 4.2146 4.2144 4.2114 4.1923 4.19 4.1894 4.1785 4.178 4.1694 4.1694 4.1694 4.1556 4.1498 4.1498 4.1357 4.1222 4.1222 4.1217 4.1192 4.1178 4.1139 4.1135 4.1125 4.1035 4.1025 4.1023 4.0971 4.0969 4.0915 4.0915 4.0914 4.0836 4.0804 4.0803 4.0722 4.065 4.065 4.0649 4.0644 4.0637 4.0616 4.0616 4.061 4.0572 4.0563 4.056 4.0545 4.0545 4.0522 4.0519 4.0514 4.0484 4.0467 4.0463 4.0422 4.0392 4.0388 4.0385 4.0385 4.0383 4.038 4.0379 4.0375 4.0364 4.0353 4.0344]; x_axis = 1:numel(curve); points = [x_axis ; curve ] %% Get the scaling info f = figure(1); plot(points(:,1),points(:,2)); ticks = get(get(f, ticks = str2num(ticks); aspect = get(get(f, aspect = [aspect(2) aspect(1)]; close(f); %% Get the "origin" O = [x_axis(1) ticks(1)]; %% Scale the data - now the scaled values look like MATLAB % what a good plot should look like scaled_O = O.*aspect; scaled_points = bsxfun(@times,points,aspect); %% Find the closest point del = sum((bsxfun(@minus,scaled_points,scaled_O).^2),2); [val ind] = min(del); best_ROC = [ind curve(ind)]; %% Display plot(x_axis,curve, hold on; plot(O(1),O(2), plot(best_ROC(1),best_ROC(2),
elbow_finder <- function(x_values, y_values) { max_x_x <- max(x_values) max_x_y <- y_values[which.max(x_values)] max_y_y <- max(y_values) max_y_x <- x_values[which.max(y_values)] max_df <- data.frame(x = c(max_y_x, max_x_x), y = c(max_y_y, max_x_y)) fit <- lm(max_df$y ~ max_df$x) distances <- c() for(i in 1:length(x_values)) { distances <- c(distances, abs(coef(fit)[2]*x_values[i] - y_values[i] + coef(fit)[1]) / sqrt(coef(fit)[2]^2 + 1^2)) } x_max_dist <- x_values[which.max(distances)] y_max_dist <- y_values[which.max(distances)] return(c(x_max_dist, y_max_dist)) }
elbow_finder <- function(x_values, y_values) { i_max <- length(x_values) - 1 first_derived <- list() second_derived <- list() for(i in 2:i_max){ slope1 <- (y_values[i+1] - y_values[i]) / (x_values[i+1] - x_values[i]) slope2 <- (y_values[i] - y_values[i-1]) / (x_values[i] - x_values[i-1]) slope_avg <- (slope1 + slope2) / 2 first_derived[[i]] <- slope_avg } first_derived[[1]] <- NA first_derived[[i_max+1]] <- NA first_derived <- unlist(first_derived) for(i in 3:i_max-1){ d1 <- (first_derived[i+1] - first_derived[i]) / (x_values[i+1] - x_values[i]) d2 <- (first_derived[i] - first_derived[i-1]) / (x_values[i] - x_values[i-1]) d_avg <- (d1 + d2) / 2 second_derived[[i]] <- d_avg } second_derived[[1]] <- NA second_derived[[2]] <- NA second_derived[[i_max]] <- NA second_derived[[i_max+1]] <- NA second_derived <- unlist(second_derived) return(list(d1 = first_derived, d2 = second_derived)) }
variableName(index,index) variableName{index,index} variableName{indices}(indices)
a = 1; b = 2; c = 3; d = 1:10; a(b+mean(d(cell2mat({b}):c)))
>> a=0 a = 0 >> a*(a+a) ans = 0 >> a(a+a) Subscript indices must either be real positive integers or logicals.
p = rand(10,2); labels = cellstr( num2str([1:10] plot(p(:,1), p(:,2), text(p(:,1), p(:,2), labels,
%% Original data (Normal with mean 1 and standard deviation 2) x = 1 + 2*randn(100,1); mean(x) var(x) std(x) %% Normalized data with mean 0 and variance 1 z = (x-mean(x))/std(x); mean(z) var(z) std(z)
function x = normalize(x, eps) % Normalize vector `x` (zero mean, unit variance) % default values if (~exist( eps = 1e-6; end mu = mean(x(:)); sigma = std(x(:)); if sigma < eps sigma = 1; end x = (x - mu) / sigma; end
x=0:0.01:2*pi; % y1=sin(x); % y2=sin(x)+.5; % X=[x,fliplr(x)]; % Y=[y1,fliplr(y2)]; % fill(X,Y,
fill_between_lines = @(X,Y1,Y2,C) fill( [X fliplr(X)], [Y1 fliplr(Y2)], C );
x = 1:100; % y1 = rand(1,100)+1.5; % y2 = rand(1,100)+0.5; % baseLine = 0.2; % index = 30:70; % plot(x,y1, hold on; % h1 = fill(x(index([1 1:end end])),... % [baseLine y1(index) baseLine],... plot(x,y2, h2 = fill(x(index([1 1:end end])),... % [baseLine y2(index) baseLine],... plot(x(index),baseLine.*ones(size(index)),
x = 0:.1:2*pi; y = sin(x)+rand(size(x))/2; x2 = [0 x 2*pi]; y2 = [.1 y .1]; patch(x2, y2, [.8 .8 .1]);
fid = fopen( tline = fgetl(fid); while ischar(tline) nums = str2num(tline); %do stuff with nums tline = fgetl(fid); end fclose(fid);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Create a test file cd(tempdir); fName = fid = fopen(fName, for ixLoop = 1:5 d = randi(1e6, 1e5,2); fprintf(fid, end fclose(fid); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Initial code CHECK = 0; tic; fid = fopen( tline = fgetl(fid); while ischar(tline) nums = str2num(tline); CHECK = round((CHECK + mean(nums) ) /2); tline = fgetl(fid); end fclose(fid); t = toc; fprintf(1, %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Using sscanf, once per line CHECK = 0; tic; fid = fopen( tline = fgetl(fid); while ischar(tline) nums = sscanf(tline, CHECK = round((CHECK + mean(nums) ) /2); tline = fgetl(fid); end fclose(fid); t = toc; fprintf(1, %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Using fscanf in large batches CHECK = 0; tic; bufferSize = 1e4; fid = fopen( scannedData = reshape(fscanf(fid, while ~isempty(scannedData) for ix = 1:size(scannedData,1) nums = scannedData(ix,:); CHECK = round((CHECK + mean(nums) ) /2); end scannedData = reshape(fscanf(fid, end fclose(fid); t = toc; fprintf(1, %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Using textscan in large batches CHECK = 0; tic; bufferSize = 1e4; fid = fopen( scannedData = textscan(fid, while ~isempty(scannedData{1}) for ix = 1:size(scannedData{1},1) nums = [scannedData{1}(ix) scannedData{2}(ix)]; CHECK = round((CHECK + mean(nums) ) /2); end scannedData = textscan(fid, end fclose(fid); t = toc; fprintf(1, %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Reading in large batches into memory, incrementing to end-of-line, sscanf CHECK = 0; tic; fid = fopen( bufferSize = 1e4; eol = sprintf( dataBatch = fread(fid,bufferSize, dataIncrement = fread(fid,1, while ~isempty(dataIncrement) && (dataIncrement(end) ~= eol) && ~feof(fid) dataIncrement(end+1) = fread(fid,1, end data = [dataBatch dataIncrement]; while ~isempty(data) scannedData = reshape(sscanf(data, for ix = 1:size(scannedData,1) nums = scannedData(ix,:); CHECK = round((CHECK + mean(nums) ) /2); end dataBatch = fread(fid,bufferSize, dataIncrement = fread(fid,1, while ~isempty(dataIncrement) && (dataIncrement(end) ~= eol) && ~feof(fid) dataIncrement(end+1) = fread(fid,1, end data = [dataBatch dataIncrement]; end fclose(fid); t = toc; fprintf(1, %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Using Java single line readers + sscanf CHECK = 0; tic; bufferSize = 1e4; reader = java.io.LineNumberReader(java.io.FileReader( tline = char(reader.readLine()); while ~isempty(tline) nums = sscanf(tline, CHECK = round((CHECK + mean(nums) ) /2); tline = char(reader.readLine()); end reader.close(); t = toc; fprintf(1, %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Using Java scanner for file reading and string conversion CHECK = 0; tic; jFile = java.io.File( scanner = java.util.Scanner(jFile); scanner.useDelimiter( while scanner.hasNextInt() nums = [scanner.nextInt() scanner.nextInt()]; CHECK = round((CHECK + mean(nums) ) /2); end scanner.close(); t = toc; fprintf(1, %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Reading in large batches into memory, vectorized operations (non-compliant solution) CHECK = 0; tic; fid = fopen( bufferSize = 1e4; eol = sprintf( dataBatch = fread(fid,bufferSize, dataIncrement = fread(fid,1, while ~isempty(dataIncrement) && (dataIncrement(end) ~= eol) && ~feof(fid) dataIncrement(end+1) = fread(fid,1, end data = [dataBatch dataIncrement]; while ~isempty(data) scannedData = reshape(sscanf(data, CHECK = round((CHECK + mean(scannedData(:)) ) /2); dataBatch = fread(fid,bufferSize, dataIncrement = fread(fid,1, while ~isempty(dataIncrement) && (dataIncrement(end) ~= eol) && ~feof(fid) dataIncrement(end+1) = fread(fid,1, end data = [dataBatch dataIncrement]; end fclose(fid); t = toc; fprintf(1,
fname = fstats = dir(fname); % Map the file as one long character string m = memmapfile(fname, textdata = char(m.Data(1).asUint8); % Use textscan() to parse the string and convert to an int32 matrix data = textscan(textdata, data = data{:}; % Tidy up! clear(
classdef MyConstants properties (Constant = true) SECONDS_PER_HOUR = 60*60; DISTANCE_TO_MOON_KM = 384403; end end
>> MyConstants.SECONDS_PER_HOUR ans = 3600 >> MyConstants.SECONDS_PER_HOUR = 42 MyConstants = SECONDS_PER_HOUR: 42 >> whos Name Size Bytes Class Attributes MyConstants 1x1 132 struct ans 1x1 8 double
function broken_constant_use MyConstants(); % "import" to protect assignment MyConstants.SECONDS_PER_HOUR = 42 % this bug is a syntax error now
% Define constants params.PI = 3.1416; params.SQRT2 = 1.414; % Call a function which needs one or more of the constants myFunction( params );
classdef TestHandleObj < handle properties field = 10; end end
classdef TestConstant properties (Constant) field = 10; end end
Access(s) Assign(s) Type of object/call 0.0034 0.0042 0.0033 0.0042 0.0034 0.0033 0.0033 0.0042 0.1581 0.3066 0.1694 0.3124 29.2161 - 0.0034 - 0.0051 0.0078 0.1574 0.3053
public class JtestObj { public double field = 10; public double getMe() { double N = 1000000; double val = 0; for (int i = 1; i < N; i++) { val = this.field; } return val; } public void setMe(double val) { double N = 1000000; for (int i = 1; i < N; i++){ this.field = val; } } }
set(gca, pos = get(gca, ti = get(gca, set(gcf, set(gcf, set(gcf, set(gcf,
A = hgload( % set desired output size set(A, height = 15; width = 19; % the last two parameters of set(A, ); saveas(A,
% Config: rows = 1e6; runs = 50; % Start: orig = round(rand(rows, 1)); t1 = 0; for i = 1:runs A = orig; tic A(A == 0) = []; t1 = t1 + toc; end t1 = t1 / runs; t2 = 0; for i = 1:runs A = orig; tic A = A(A ~= 0); t2 = t2 + toc; end t2 = t2 / runs; t1 t2 t1 / t2
function fHandle = start_counting(count) disp(count); fHandle = @increment; function increment count = count+1; disp(count); end end
>> fh = start_counting(3); % Initialize count to 3 and return handle 3 >> fh(); % Invoke increment function using its handle 4 >> fh(); 5
>> fh2 = start_counting(-4); -4 >> fh2(); -3 >> fh2(); -2 >> fh(); % Invoke the first handle to increment 6 >> fh2(); % Invoke the second handle to increment -1
x = linspace(0,pi,1000); tic,y = fofx(x);toc Elapsed time is 0.000493 seconds.
finline = inline( tic,y = finline(x,2);toc Elapsed time is 0.002546 seconds.
xmin = fminbnd(@(x) cos(x),0,2*pi) xmin = 3.14159265358979
% function to add two numbers function total = add(first, second) total = first + second; end % this variable now points to the add function operation = @add;
% prints hello function sayHello disp( end % does something five times function doFiveTimes(thingToDo) for idx = 1 : 5 thingToDo(); end end % now I can say hello five times easily: doFiveTimes(@sayHello); % if there % the five times logic again, only the operation itself: function sayCheese disp( end doFiveTimes(@sayCheese); % I don % anonymous function: doFiveTimes(@() disp(
F = fftshift(F); % Center FFT F = abs(F); % Get the magnitude F = log(F+1); % Use log, for perceptual scaling, and +1 since log(0) is undefined F = mat2gray(F); % Use mat2gray to scale the image between 0 and 1 imshow(F,[]); % Display the result
close all; clear all; img = imread( imagesc(img) img = fftshift(img(:,:,2)); F = fft2(img); figure; imagesc(100*log(1+abs(fftshift(F)))); colormap(gray); title( figure; imagesc(angle(F)); colormap(gray); title(
>> Names Names = 1×3 string array "Sample Text" "Sample Text" "Sample Text"
t = 0 : 0.01 : 2 * pi; s = sin(t); c = cos(t); m = -sin(t); hold on; plot(t, s, plot(t, c, plot(t, m, hold off; legend(
hold on; plot(t, s, h2 = plot(t, c, plot(t, m, hold off; legend(h2,
t = 0 : 0.01 : 2 * pi; s = sin(t); c = cos(t); m = -sin(t); hold on; plot(t, s, h2 = plot(t, c, plot(t, m, legend show % Generating legend based on already submitted values
t = 0 : 0.01 : 2 * pi; s = sin(t); c = cos(t); m = -sin(t); figure; hold ( hs = plot(t, s); hc = plot(t, c); hm = plot(t, m);
hsAnno = get(hs, hsLegend = get(hsAnno, set(hsLegend,
t = 0 : 0.01 : 2 * pi; s = sin(t); c = cos(t); m = -sin(t); plot(t,c,t,s,t,m) % cosine is plotted FIRST legend(
plot(t,c,t,m,t,s) % cosine and -sine are first and second curves legend(
for ii=1:nBeams if X(ii)<0 %Bars with negative force are in compession h1=plot(linspace(beamCord(ii,1),beamCord(ii,3)),... linspace(beamCord(ii,2),beamCord(ii,4)), elseif X(ii)>0 %Bars with positive force are in tension h2=plot(linspace(beamCord(ii,1),beamCord(ii,3)),... linspace(beamCord(ii,2),beamCord(ii,4)), end end legend([h1;h2],[
>> profile on % turn profiling on >> foo; % entry point to your matlab function or script >> profile off % turn profiling off >> profview % view the report
function lineArray = read_mixed_csv(fileName, delimiter) fid = fopen(fileName, lineArray = cell(100, 1); % Preallocate a cell array (ideally slightly % larger than is needed) lineIndex = 1; % Index of cell to place the next line in nextLine = fgetl(fid); % Read the first line from the file while ~isequal(nextLine, -1) % Loop while not at the end of the file lineArray{lineIndex} = nextLine; % Add the line to the cell array lineIndex = lineIndex+1; % Increment the line index nextLine = fgetl(fid); % Read the next line from the file end fclose(fid); % Close the file lineArray = lineArray(1:lineIndex-1); % Remove empty cells, if needed for iLine = 1:lineIndex-1 % Loop over lines lineData = textscan(lineArray{iLine}, lineData = lineData{1}; % Remove cell encapsulation if strcmp(lineArray{iLine}(end), delimiter) % Account for when the line lineData{end+1} = end lineArray(iLine, 1:numel(lineData)) = lineData; % Overwrite line data end end
>> data = read_mixed_csv( data = Columns 1 through 7 Columns 8 through 10
>> data(:, 1) = cellfun(@(s) {str2double(s)}, data(:, 1)) data = Columns 1 through 7 [ 4] [NaN] [NaN] Columns 8 through 10
fid = fopen( C = textscan(fid, repmat( C = C{1}; fclose(fid);
>> table = readtable( >> table = Var1 Var2 Var3 Var4 Var5 Var6 Var7 Var8 Var9 Var10 ____ _____ _____ _____ _____ __________ __________ ________ ____ _____ 4 NaN NaN
% Assuming that the dataset is ";"-delimited and each line ends with ";" fid = fopen( tline = fgetl(fid); u=sprintf( id=findstr(u, data=cell(1,n); for I=1:n if I==1 data{1,I}=u(1:id(I)-1); else data{1,I}=u(id(I-1)+1:id(I)-1); end end ct=1; while ischar(tline) ct=ct+1; tline = fgetl(fid); u=sprintf( id=findstr(u, if~isempty(id) for I=1:n if I==1 data{ct,I}=u(1:id(I)-1); else data{ct,I}=u(id(I-1)+1:id(I)-1); end end end end fclose(fid);
nUnknown; % The number of unknown arrays myArray = zeros(500,800,nUnknown);
subMatrix = myArray(:,:,3); % Gets the third matrix
myArray = cat(3,myArray,zeros(500,800)); % OR myArray(:,:,nUnknown+1) = zeros(500,800);
function result = createArrays(nArrays, arraySize) result = cell(1, nArrays); for i = 1 : nArrays result{i} = zeros(arraySize); end end
myArray = createArrays(requiredNumberOfArrays, [500 800]);
myArray{1} = zeros(500, 800); if twoRequired, myArray{2} = zeros(500, 800); end
buffer=zeros(1,512*512*512,"uint16"); vol=reshape(buffer,512,512,512);
myArray = zeros(2,2); for i: 1:unknown myArray(:,i) = zeros(x,y); end
x=zeros(100,200); for i=1:100 for j=1:200 x(i,j)=input( end end
h=figure; plot(x,y, % ... saveas(h,name, saveas(h,name,
plot(cos(linspace(0, 7, 1000))); set(gcf, export_fig test2.png
A = [ 1 11 22 33 44 13 12 33 1 14 33 44 ]; idx = ( A(:,4)==33 ); A_new = A(idx,:)
xy = rand(10000000,2); xy = bsxfun(@times,xy,1./sum(xy,2)); hist(xy(:,1),100)
xyz = rand(10000,3); xyz = bsxfun(@times,xyz,1./sum(xyz,2)); plot3(xyz(:,1),xyz(:,2),xyz(:,3), view(70,35) box on grid on
t = rand(10000000,1); xy = t*[0 1] + (1-t)*[1 0]; hist(xy(:,1),100)
n = 10000; uv = [zeros(n,1),sort(rand(n,2),2),ones(n,1)]; xyz = diff(uv,[],2); plot3(xyz(:,1),xyz(:,2),xyz(:,3), box on grid on view(70,35)
xyz = randfixedsum(3,10000,1.25,0,1) plot3(xyz(:,1),xyz(:,2),xyz(:,3), view(70,35) box on grid on
a = [1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0]; n = 10000; r = drchrnd(a,n) function r = drchrnd(a,n) p = length(a); r = gamrnd(repmat(a,n,1),1,n,p); r = r ./ repmat(sum(r,2),1,p);
sound(mute,fs); % Mute is a short vector containing all zeroes
player = audioplayer(Y, Fs) % start the playback play(player); % pause the playback pause(player); % resume the playback resume(player) % stop the playback stop(player)
player = audioplayer(x, fs); play(player) % start the player stop(player) % stop whenever you like...
filename = [cdata,map] = imread( filename ); % convert to RGB if it is indexed image if ~isempty( map ) cdata = idx2rgb( cdata, map ); end %imtool( imWidth = 685; imHeight = 428; % RGB ranges of a color we want to keep redRange = [140 255]; greenRange = [0 40]; blueRange = [0 40]; % RGB values we don redToKeep = zeros(imHeight, imWidth); greenToKeep = zeros(imHeight, imWidth); blueToKeep = zeros(imHeight, imWidth); for x=1:imWidth for y=1:imHeight red = cdata( y, x, 1 ); green = cdata( y, x, 2 ); blue = cdata( y, x, 3 ); if (red >= redRange(1) && red <= redRange(2) && green >= greenRange(1) && green <= greenRange(2) && blue >= blueRange(1) && blue <= blueRange(2)) redToKeep( y, x ) = red; greenToKeep( y, x ) = green; blueToKeep( y, x ) = blue; else redToKeep( y, x ) = 999; greenToKeep( y, x ) = 999; blueToKeep( y, x ) = 999; end end end im = rgb2gray(cdata); [X, map] = gray2ind(im); im = ind2rgb(X, map); for x=1:imWidth for y=1:imHeight if (redToKeep( y, x ) < 999) im( y, x, 1 ) = 240; end if (greenToKeep( y, x ) < 999) im( y, x, 2 ) = greenToKeep( y, x ); end if (blueToKeep( y, x ) < 999) im( y, x, 3 ) = blueToKeep( y, x ); end end end imshow(im);
figure pic = imread( for mm = 1:size(pic,1) for nn = 1:size(pic,2) if pic(mm,nn,1) < 80 || pic(mm,nn,2) > 80 || pic(mm,nn,3) > 100 gsc = 0.3*pic(mm,nn,1) + 0.59*pic(mm,nn,2) + 0.11*pic(mm,nn,3); pic(mm,nn,:) = [gsc gsc gsc]; end end end imshow(pic)
cdata = imread( hsvImage = rgb2hsv(cdata); % Convert the image to HSV space hPlane = 360.*hsvImage(:, :, 1); % Get the hue plane scaled from 0 to 360 sPlane = hsvImage(:, :, 2); % Get the saturation plane nonRedIndex = (hPlane > 20) & ... % Select "non-red" pixels (hPlane < 340); sPlane(nonRedIndex) = 0; % Set the selected pixel saturations to 0 hsvImage(:, :, 2) = sPlane; % Update the saturation plane rgbImage = hsv2rgb(hsvImage); % Convert the image back to RGB space
binEdges = 0:360; % Edges of histogram bins hFigure = figure(); % New figure % Bin pixel hues and plot histogram: if verLessThan( N = histc(hPlane(:), binEdges); % Use histc in older versions hBar = bar(binEdges(1:end-1), N(1:end-1), else N = histcounts(hPlane(:), binEdges); hBar = bar(binEdges(1:end-1), N, end set(hBar, colormap(hsv(360)); % Change to an HSV color map with 360 points axis([0 360 0 max(N)]); % Change the axes limits set(gca, set(hFigure, xlabel( ylabel(
figure; pause(0.00001); frame_h = get(handle(gcf), set(frame_h,
h = figure; % plot(1:10); % figure(h) % robot = java.awt.Robot; robot.keyPress(java.awt.event.KeyEvent.VK_ALT); % robot.keyPress(java.awt.event.KeyEvent.VK_SPACE); % robot.keyRelease(java.awt.event.KeyEvent.VK_SPACE); % robot.keyRelease(java.awt.event.KeyEvent.VK_ALT); % robot.keyPress(java.awt.event.KeyEvent.VK_X); % robot.keyRelease(java.awt.event.KeyEvent.VK_X); %
figure; % do your job here drawnow; set(get(handle(gcf),
%% maximizeFigure % % Maximizes the current figure or creates a new figure. maximizeFigure() simply maximizes the % current or a specific figure % |h = maximizeFigure();| can be directly used instead of |h = figure();| % % *Examples* % % * |maximizeFigure(); % maximizes the current figure or creates a new figure| % * |maximizeFigure( % * |maximizeFigure(hf); % maximizes the figure with the handle hf| % * |maximizeFigure( % * |hf = maximizeFigure(...); % returns the (i.e. new) figure handle as an output| % % *Acknowledgements* % % * Big thanks goes out to Yair Altman from http: % % *See Also* % % * |figure()| % * |gcf()| % % *Authors* % % * Daniel Kellner, medPhoton GmbH, Salzburg, Austria, 2015-2017 %% function varargout = maximizeFigure(varargin) warning( % Check input variables if isempty(varargin) hf = gcf; % use current figure elseif strcmp(varargin{1}, hf = figure(varargin{2:end}); elseif strcmp(varargin{1}, hf = findobj( elseif ~isa(varargin{1}, strcmp(get(varargin{1}, hf = varargin{1}; else error( end for cHandle = 1:length(hf) % Skip invalid handles and plotbrowser handles if ~ishandle(cHandle) || strcmp(get(hf, continue end % Carry the current resize property and set (temporarily) to oldResizeStatus = get(hf(cHandle), set(hf(cHandle), % Usage of the undocumented % http: jFrame = get(handle(hf(cHandle)), % Due to an Event Dispatch thread, the pause is neccessary as described at: % http: pause(0.05) % Don if strcmp(get(cHandle, continue end % Don if jFrame.isMaximized continue end % Unfortunately, if it is invisible, it can % null pointer exception is raised (java.lang.NullPointerException). Instead, we maximize it the % straight way so that we do not end up in small sized plot exports. if strcmp(get(hf, set(hf, continue end jFrame.setMaximized(true); % If if strcmp(oldResizeStatus, pause(0.05) set(hf, end end if nargout varargout{1} = hf; end
>> s = dir( s = name: date: bytes: 20 isdir: 0 datenum: 7.3344e+005
dirInfo = dir(dirName); % % index = strcmp({dirInfo.name},fileName); % % fileSize = dirInfo(index).bytes; %
function file_length = get_file_length(fid) % extracts file length in bytes from a file opened by fopen % fid is file handle returned from fopen % store current seek current_seek = ftell(fid); % move to end fseek(fid, 0, 1); % read end position file_length = ftell(fid); % move to previous position fseek(fid, current_seek, -1); end
dirInfo=dir(pwd); index = strcmp({dirInfo.name},[filename, fileSize = dirInfo(index).bytes
>> M = [1 2 3; 4 5 6; 7 8 9]; % Sample matrix >> vector = reshape(M. vector = 1 2 3 4 5 6 7 8 9 >> vector = M(:) % Collect the column contents into a column vector vector = 1 4 7 2 5 8 3 6 9
B = zeros(4,4); C = zeros(size(B,1), size(B,2), 4); % C(:,:,1) = B; %
octave:3> m = ones(2,3,2) m = ans(:,:,1) = 1 1 1 1 1 1 ans(:,:,2) = 1 1 1 1 1 1
octave:11> Three_D = zeros(2,3,2) Three_D = ans(:,:,1) = 0 0 0 0 0 0 ans(:,:,2) = 0 0 0 0 0 0 octave:12> Three_D(:,:,1) = Two_D Three_D = ans(:,:,1) = 1 1 1 1 1 1 ans(:,:,2) = 0 0 0 0 0 0
function dummy(arg1, arg2) if nargin < 2 arg2 = 0; end if nargin < 1 arg1 = 0; end % function body
% emptyCells = cellfun(@isempty,a); % a(emptyCells) = [];
myCellARRAY(all(cellfun(@isempty,myCellARRAY),2), : ) = [];
M = randi(100, [3 4]); % ind = reshape(1:numel(M), size(M)); % ind = fliplr( spdiags( fliplr(ind) ) ); % ind(:,1:2:end) = flipud( ind(:,1:2:end) ); % ind(ind==0) = []; % M(ind) %
» M M = 17 35 26 96 12 59 51 55 50 23 70 14 96 76 90 15 » M(ind) ans = 17 35 12 50 59 26 96 51 23 96 76 70 55 14 90 15
M = 69 9 16 100 75 23 83 8 46 92 54 45 ans = 69 9 75 46 23 16 100 83 92 54 8 45
X = randn(500,2000); % [r, c] = size(X); M = bsxfun(@plus, (1:r). M = M + bsxfun(@times, (1:r). [~, ind] = sort(M(:)); y = X(ind).
% function y = zigzag_Amro(M) ind = reshape(1:numel(M), size(M)); ind = fliplr( spdiags( fliplr(ind) ) ); ind(:,1:2:end) = flipud( ind(:,1:2:end) ); ind(ind==0) = []; y = M(ind); % function y = zigzag_Luis(X) [r, c] = size(X); M = bsxfun(@plus, (1:r). M = M + bsxfun(@times, (1:r). [~, ind] = sort(M(:)); y = X(ind). % S = [10 30 100 300 1000 3000]; % f = [1 1]; % % % t_Amro = NaN(size(S)); t_Luis = NaN(size(S)); for n = 1:numel(S) X = rand(f(1)*S(n), f(2)*S(n)); f_Amro = @() zigzag_Amro(X); f_Luis = @() zigzag_Luis(X); t_Amro(n) = timeit(f_Amro); t_Luis(n) = timeit(f_Luis); end loglog(S.^2*prod(f), t_Amro, hold on loglog(S.^2*prod(f), t_Luis, xlabel( ylabel(
function [M,index] = zig_zag(M) [r,c] = size(M); checker = rem(hankel(1:r,r-1+(1:c)),2); [rEven,cEven] = find(checker); [cOdd,rOdd] = find(~checker. rTotal = [rEven; rOdd]; cTotal = [cEven; cOdd]; [junk,sortIndex] = sort(rTotal+cTotal); rSort = rTotal(sortIndex); cSort = cTotal(sortIndex); index = sub2ind([r c],rSort,cSort); M = M(index); end
>> M = [magic(4) zeros(4,1)]; M = 16 2 3 13 0 5 11 10 8 0 9 7 6 12 0 4 14 15 1 0 >> newM = zig_zag(M) % newM = 16 2 5 9 11 3 13 10 7 4 14 6 8 0 0 12 15 1 0 0
% for a 3x3 array n=3; numElementsPerDiagonal = [1:n,n-1:-1:1]; hadaRC = cumsum([0,numElementsPerDiagonal(1:end-1)]); array2add = fliplr(hankel(hadaRC(1:n),hadaRC(end-n+1:n))); % loop through the hankel array and add numbers counting either up or down % if they are even or odd for d = 1:(2*n-1) if floor(d/2)==d/2 % even, count down array2add = array2add + diag(1:numElementsPerDiagonal(d),d-n); else % odd, count up array2add = array2add + diag(numElementsPerDiagonal(d):-1:1,d-n); end end % now flip to get the result indexMatrix = fliplr(array2add) result = 1 2 6 3 5 7 4 8 9
indexMatrixT = indexMatrix [dummy,sortedIdx] = sort(indexMatrixT(:)); sortedIdx = 1 2 4 7 5 3 6 8 9
[m,n] = size(X); nlim = m*n; n = n+mod(n-m,2); mask = bsxfun(@le,[1:m] start_vec = m:m-1:m*(m-1)+1; a = bsxfun(@plus,start_vec offset_startcol = 2- mod(m+1,2); [~,idx] = min(mask,[],1); idx = idx - 1; idx(idx==0) = m; end_ind = a([0:n-1]*m + idx); offsets = a(1,offset_startcol:2:end) + end_ind(offset_startcol:2:end); a(:,offset_startcol:2:end) = bsxfun(@minus,offsets,a(:,offset_startcol:2:end)); out = a(mask); out2 = m*n+1 - out(end:-1:1+m*(n-m+1)); result = X([out2 ; out(out<=nlim)]);
Datasize: 500 x 2000 ------------------------------------- With Proposed Approach Elapsed time is 0.037145 seconds. ------------------------------------- With Luis Approach Elapsed time is 0.045900 seconds. Datasize: 5000 x 20000 ------------------------------------- With Proposed Approach Elapsed time is 3.947325 seconds. ------------------------------------- With Luis Approach Elapsed time is 6.370463 seconds.
[~,I] = sort (idx(:)); %sort the 1D indices of the image into ascending order according to idx reorderedim = im(I);
index = cellfun(@(f) license( availableFeatures = featureStr(logical(index));
index = cellfun(@(f) license( checkedOutFeatures = availableFeatures(logical(index));
>> license( matlab >> gaussFilter = fspecial( >> license( image_toolbox matlab
function tf = areTheseToolboxesInstalled(requiredToolboxes) %ARETHESETOOLBOXESINSTALLED takes a cell array of toolbox names and checks whether they are currently installed % SYNOPSIS tf = areTheseToolboxesInstalled(requiredToolboxes) % % INPUT requiredToolboxes: cell array with toolbox names to test for. Eg. % { % % OUTPUT tf: true or false if the required toolboxes are installed or not %%%%%%%%%%%%%%%%%%%%%%%%%% % get all installed toolbox names v = ver; % collect the names in a cell array [installedToolboxes{1:length(v)}] = deal(v.Name); % check tf = all(ismember(requiredToolboxes,installedToolboxes));
bioinfo curvefit database gads ident images nnet optim pde signal stats wavelet
function test globalX = getappdata(0, disp(globalX); end x = 10
for ii = 1:N do_stuff(); clear empty_script; empty_script; end
sig = [1 1 0 0 0 0 1 1 1 1 1 0 1 0 0 0 1 1 1 1 1 1 1 1 0 0 1 1 1 0];
startIndex EndIndex Duration 3 6 4 12 12 1 14 16 3 25 26 2 30 30 1
sig = [1 1 0 0 0 0 1 1 1 1 1 0 1 0 0 0 1 1 1 1 1 1 1 1 0 0 1 1 1 0]; len = length(sig); thresh = 3; % % v = true(1,len-thresh+1); for i=1:thresh v = v & ( sig(i:len-thresh+i) == 0 ); end % for i=1:thresh-1 v(find(v)+1) = true; end % v = find(v);
dsig = diff([1 tsig 1]); startIndex = find(dsig < 0); endIndex = find(dsig > 0)-1; duration = endIndex-startIndex+1;
stringIndex = (duration >= 3); startIndex = startIndex(stringIndex); endIndex = endIndex(stringIndex);
indices = zeros(1,max(endIndex)+1); indices(startIndex) = 1; indices(endIndex+1) = indices(endIndex+1)-1; indices = find(cumsum(indices));
function indice=sigvec(sig,thresh) %extend sig head and tail to avoid 0 head and 0 tail exsig=[1,sig,1]; %convolution sig with extend sig cvexsig=conv(exsig,ones(1,thresh)); tempsig=double(cvexsig==0); indice=find(conv(tempsig,ones(1,thresh)))-thresh;
tsig = (abs(sig) >= eps); dsig = diff([0 tsig 0]); startIndex = find(dsig > 0); endIndex = find(dsig < 0)-1; duration = endIndex-startIndex+1;
cs = cumsum(logcl); islands = cs(1+thresh:end) == cs(1:end-thresh);
v = zeros(1,max(endInd)+1); % v(startInd) = 1; % v(endInd+1) = v(endInd+1)-1; % indices = find(cumsum(v)); %
endcap = zeros(thresh,1); indices = find(cumsum([islands ; endcap] - [endcap ; islands]))
sig = [1 1 0 0 0 0 1 1 1 1 1 0 1 0 0 0 1 1 1 1 1 1 1 1 0 0 1 1 1 0]; logcl = abs(sig(:)) >= .1; cs = cumsum(logcl); islands = cs(1+thresh:end) == cs(1:end-thresh); endcap = zeros(thresh,1); indices = find(cumsum([islands ; endcap] - [endcap ; islands]))
REPMAT: A + repmat(B,size(A,1),1) BSXFUN: bsxfun(@plus,A,B)
datasizes = [ 100 100; 100 1000; 100 10000; 100 100000; 1000 100; 1000 1000; 1000 10000; 10000 100; 10000 1000; 10000 10000; 100000 100; 100000 1000]; num_funcs = 11; tsec_rep = NaN(size(datasizes,1),num_funcs); tsec_bsx = NaN(size(datasizes,1),num_funcs); for iter = 1:size(datasizes,1) m = datasizes(iter,1); n = datasizes(iter,2); A = rand(m,n); B = rand(1,n); fcns_rep= {@() A + repmat(B,size(A,1),1),@() A - repmat(B,size(A,1),1),... @() A .* repmat(B,size(A,1),1), @() A ./ repmat(B,size(A,1),1),... @() A.\repmat(B,size(A,1),1), @() A .^ repmat(B,size(A,1),1),... @() rem(A ,repmat(B,size(A,1),1)), @() mod(A,repmat(B,size(A,1),1)),... @() atan2(A,repmat(B,size(A,1),1)),@() atan2d(A,repmat(B,size(A,1),1)),... @() hypot( A , repmat(B,size(A,1),1) )}; fcns_bsx = {@() bsxfun(@plus,A,B), @() bsxfun(@minus,A,B), ... @() bsxfun(@times,A,B),@() bsxfun(@rdivide,A,B),... @() bsxfun(@ldivide,A,B), @() bsxfun(@power,A,B), ... @() bsxfun(@rem,A,B), @() bsxfun(@mod,A,B), @() bsxfun(@atan2,A,B),... @() bsxfun(@atan2d,A,B), @() bsxfun(@hypot,A,B)}; for k1 = 1:numel(fcns_bsx) tsec_rep(iter,k1) = timeit(fcns_rep{k1}); tsec_bsx(iter,k1) = timeit(fcns_bsx{k1}); end end speedups = tsec_rep./tsec_bsx;
fcns_rep = { @() A == repmat(B,size(A,1),1), @() A ~= repmat(B,size(A,1),1),... @() A < repmat(B,size(A,1),1), @() A <= repmat(B,size(A,1),1), ... @() A > repmat(B,size(A,1),1), @() A >= repmat(B,size(A,1),1)}; fcns_bsx = { @() bsxfun(@eq,A,B), @() bsxfun(@ne,A,B), @() bsxfun(@lt,A,B),... @() bsxfun(@le,A,B), @() bsxfun(@gt,A,B), @() bsxfun(@ge,A,B)};
fcns_rep = { @() A & repmat(B,size(A,1),1), @() A | repmat(B,size(A,1),1), ... @() xor(A,repmat(B,size(A,1),1))}; fcns_bsx = { @() bsxfun(@and,A,B), @() bsxfun(@or,A,B), @() bsxfun(@xor,A,B)};
MATLAB Version: 8.5.0.197613 (R2015a) Operating System: Windows 7 Professional 64-bit RAM: 16GB CPU Model: Intel® Core i7-4790K @4.00GHz
a = {[1 2], [1 2], [4 5]}; allcomb(a{:}) ans = 1 1 4 1 1 5 1 2 4 1 2 5 2 1 4 2 1 5 2 2 4 2 2 5
sets = {[1 2], [1 2], [4 5]}; [x y z] = ndgrid(sets{:}); cartProd = [x(:) y(:) z(:)]; cartProd = 1 1 4 2 1 4 1 2 4 2 2 4 1 1 5 2 1 5 1 2 5 2 2 5
function result = cartesianProduct(sets) c = cell(1, numel(sets)); [c{:}] = ndgrid( sets{:} ); result = cell2mat( cellfun(@(v)v(:), c, end
N = numel(a); v = cell(N,1); [v{:}] = ndgrid(a{:}); res = reshape(cat(N+1,v{:}),[],N);
no_inp=3 % number of inputs we want...in this case we have 3 inputs a=[1 2 3] b=[1 2 3] c=[1 2 3] pre_final=combvec(c,b,a) final=zeros(size(pre_final)); for i=1:no_inp final(:,i)=pre_final(:,no_inp-i+1); end final
>> foo.( foo = one: 1 >> foo.( >> x = >> foo.(x) ans = 2
BW = im2bw( imread( subplot(121), imshow(BW) % used here as if it was cvFloodFill holes = imfill(BW, [1 1]); % [1 1] is the starting location point BW(~holes) = 1; % fill holes subplot(122), imshow(BW)
function PlotUpdate() x = 0:.1:8; y = sin(x); h = plot(x,y); y = sin(x.^3); set(h, end
function PlotUpdate() x = 0:.1:8; y = sin(x); h = plot(x,y); set(h, set(h, y = sin(x.^3); refreshdata(h, end
% gather up all the objects to refresh objs = {}; for k = 1:length(h) obj = h(k); objfields = fields(obj); for k2 = 1:length(objfields) % search for properties ending in DataSource if strncmpi(fliplr(objfields{k2}), objs = {objs{:},obj, objfields{k2}}; end end end
function PlotUpdate() x = 0:.1:8; y = sin(x); h = plot(x,y); set(h, set(h, y = sin(x.^3); delete(h); h = plot(x,y); end
function PlotUpdate() x = 0:.1:8; y = sin(x); h = plot(x,y); y = sin(x.^3); set(h, end
function PlotUpdate() x = 0:.1:8; y = sin(x); h = plot(x,y); y = sin(x.^3); h.XData = x; h.YData = y; end
function PlotUpdateTimeCompare() x = 0:.1:8; y = sin(x); h = plot(x,y); set(h, set(h, y = sin(x.^3); tic for i=1:100 refreshdata(h, end toc tic for i=1:100 delete(h); h = plot(x,y); end toc tic for i=1:100 set(h, end toc end
h = plot(nan); for i = 1:n y = ... set(h, drawnow %update the graph end
function value = nth_output(N,fcn,varargin) [value{1:N}] = fcn(varargin{:}); value = value{N}; end
axesHandles = get(fig, classHandles = handle(axesHandles); count = length(axesHandles); isNotInstanceOfSubtype = false(1, count); for i = 1:count isNotInstanceOfSubtype(i) = strcmp(class(classHandles(i)), end axesHandles = axesHandles(isNotInstanceOfSubtype);
classHandles = cellfun(@(x) handle(x), axesHandles)
??? Error using ==> cellfun scribe.legend type is not currently implemented.
copied_axes = findobj(temp_fig, copied_legend = findobj(temp_fig,
% initialize `fig` somehow, i.e., "fig=gcf()" for the current figure or % "fig=get(0, ax = findall(fig, ax = ax(arrayfun(@(i) strcmp(class(handle(i)),
>> userpath ans = C:\Users\MYUSERNAME\Documents\MATLAB;
cd /Applications/MATLAB_R2012a.app/toolbox/local/ ln -s ~/myDir/startup.m .
<key name="UserPath"> <string> <value><![CDATA[<some_directory>]]></value> </string> </key>
somePlaceOnThePath/@Tata/Tata.m somePlaceOnThePath/@Tata/methodOne.m somePlaceOnThePath/@Tata/methodTwo.m
% classdef Tata methods result = methodTwo(obj, arg) function methodOne(obj) disp( end end end
% function result = methodTwo(obj, arg) % do stuff with obj and arg end
>> clf %clear figure >> cla %clear axis >> close all %close all windows >> clear %clear workspace of variables
h = gca; % Handle to currently active axes set(h, % or... h.YDir =
>> set(gca, Error using matlab.graphics.axis.Axes/set While setting property Invalid enum value. Use one of these values:
>> gca.YDir Undefined variable "gca" or class "gca.YDir". >> gca.YDir = gca = struct with fields: YDir:
imagesc(x,y,data); axis xy; % results in the correct plot
S = struct( SNames = fieldnames(S); for loopIndex = 1:2 field = getfield(S, SNames(loopIndex)); %do stuff w/ field end ??? Index exceeds matrix dimensions
S = struct( SNames = fieldnames(S); for loopIndex = 1:numel(SNames) stuff = S.(SNames{loopIndex}) end
S = {[1 2], [3 4 5]}; % Create the cell array for loopIndex = 1:numel(S) % Loop over the number of cells array = S{loopIndex}; % Access the contents of each cell % Do stuff with array end
S = struct( SNames = fieldnames(S); for SName = [SNames{:}] stuff = S.(SName) end
S = struct( S_Cell = struct2cell(S); %Then as per gnovice for loopIndex = 1:numel(S_Sell) % Loop over the number of cells array = S{loopIndex}; % Access the contents of each cell % end
S = struct( for SName = fieldnames(S)' stuff = S.(SName{1}) end
function varargout = wrapper(varargin) varargout = someFunction(varargin);
function varargout = wrapper( varargin ) [varargout{1:nargout}] = someFunction( varargin{:} );
>> clear uninit % just to make sure uninit is uninitialized >> [uninit{[]}] = sin(0) uninit = [0]
function varargout = wrapper( varargin ) if ~nargout someFunction( varargin{:} ); else [varargout{1:nargout}] = someFunction( varargin{:} ); end
function varargout = wrapper(varargin) [varargout{1:nargin}] = someFunction(varargin{:});
% % %# % % % %# % % %# classdef myClass properties myProp = []; % end % methods %% function myMethod(obj) % %# % % % %# try doc(class(obj)) catch help(class(obj)) end end % end % end %
function [outputs] = my_fun(args) % MY_FUN does really cool stuff % [OUTPUTS] = MY_FUN(ARGS) % % :param args: Input arguments % :type args: cell array % :returns: outputs % :raises: :exc:`my_project.InvalidInput` code ... end
.. _my-project My Project ========== .. automodule:: my_project This folder contains all the functions and classes for my project. My Function ----------- .. autofunction:: my_fun
>> A = magic(3) A = 8 1 6 3 5 7 4 9 2 >> A(A>5) ans = 8 9 6 7
>> A = magic(3) A = 8 1 6 3 5 7 4 9 2 >> A(1:2, [true false true]) ans = 8 6 3 7
A(:,:,1) = 8 1 6 3 5 7 4 9 2 A(:,:,2) = 17 10 15 12 14 16 13 18 11
>> A([true true false], [false true false], [false true]) ans = 10 14
>> A([true true], [false true false false], [false true]) ans = 10 14
>> A([false true false false true true true]) ans = 3 5 9 6
>> A([true true false], [false true true true false false]) ans = 1 6 17 5 7 12
>> A([true false true], [false true true], 2) ans = 10 15 18 11
>> A([1 2], [true false true false true false]) ans = 8 6 10 3 7 14
C(:,:,1) = [8] [1] [6] [3] [5] [7] [4] [9] [2] C(:,:,2) = [17] [10] [15] [12] [14] [16] [13] [18] [11]
>> C([1 2], [true false true false true false]) ans = [8] [6] [10] [3] [7] [14]
>> C{[1 2], [true false true false true false]} ans = 8 ans = 3 ans = 6 ans = 7 ans = 10 ans = 14
function result=sgn(in) if in<0 result=-1; else result=1; end end
function result=theta(in) if in<0 result=0; else if in==0 result=0.5; else result=1; end end end
clc;clear; t=0:0.0001:76*pi; x=((4619/60*sin(t+11/7)+109/8*sin(2*t+11/7)+9/7*sin(3*t+11/7)+89/15*sin(4*t+11/7)+5/11*sin(5*t+11/7)-9839/41)*theta(75*pi-t)*theta(t-71*pi)+(-179/8*sin(11/7-2*t)+2101/20*sin(t+11/7)+5/6*sin(3*t+23/5)+65/9*sin(4*t+33/7)+33/8*sin(5*t+8/5)-698/9)*theta(71*pi-t)*theta(t-67*pi)+(952/15*sin(t+11/7)+116/21*sin(2*t+19/12)+26/5*sin(3*t+11/7)+11/9*sin(4*t+11/7)+25/11*sin(5*t+11/7)+3071/10)*theta(67*pi-t)*theta(t-63*pi)+(-4/11*sin(17/11-4*t)+657/13*sin(t+33/7)+29/11*sin(2*t+47/10)+17/6*sin(3*t+14/9)+2/13*sin(5*t+22/13)+15/8*sin(6*t+33/7)+16/11*sin(7*t+47/10)+5/3*sin(8*t+47/10)+24/13*sin(9*t+33/7)+9/11*sin(10*t+47/10)+6/5*sin(11*t+47/10)+17/18*sin(12*t+47/10)+4/9*sin(13*t+75/16)+1163/3)*theta(63*pi-t)*theta(t-59*pi)+(-11/13*sin(11/7-6*t)-17/10*sin(11/7-4*t)+261/7*sin(t+11/7)+17/3*sin(2*t+33/7)+44/19*sin(3*t+11/7)+7/9*sin(5*t+14/9)+259/3)*theta(59*pi-t)*theta(t-55*pi)+(-9/11*sin(26/17-23*t)-287/9*sin(11/7-5*t)-271/9*sin(17/11-3*t)+1551/13*sin(t+17/11)+685/8*sin(2*t+17/11)+535/11*sin(4*t+14/9)+311/11*sin(6*t+14/9)+1141/60*sin(7*t+61/13)+19/9*sin(8*t+21/11)+55/8*sin(9*t+77/17)+239/12*sin(10*t+9/2)+7/9*sin(11*t+69/16)+59/6*sin(12*t+13/10)+73/24*sin(13*t+13/11)+17/12*sin(14*t+47/11)+11/16*sin(15*t+22/5)+17/6*sin(16*t+4/3)+7/11*sin(17*t+17/13)+17/9*sin(18*t+11/9)+7/4*sin(19*t+7/5)+5/4*sin(20*t+53/12)+50/13*sin(21*t+12/11)+103/13*sin(22*t+8/7)+13/5*sin(24*t+29/7)+1/2*sin(25*t+16/5)+31/16*sin(26*t+13/3)+8/7*sin(27*t+33/8)+17/14*sin(28*t+123/31)+22/9*sin(29*t+30/7)+2/3*sin(30*t+48/13)+19/12*sin(31*t+89/22)+18/11*sin(32*t+46/11)+417/8)*theta(55*pi-t)*theta(t-51*pi)+(-2/7*sin(14/9-10*t)-9/13*sin(14/9-8*t)-224/11*sin(11/7-3*t)+197/11*sin(t+11/7)+139/14*sin(2*t+11/7)+17/12*sin(4*t+47/10)+43/12*sin(5*t+33/7)+2/5*sin(6*t+47/10)+28/19*sin(7*t+47/10)+34/33*sin(9*t+47/10)+1/4*sin(11*t+14/3)+6/19*sin(12*t+19/12)-955/8)*theta(51*pi-t)*theta(t-47*pi)+(-149/28*sin(11/7-5*t)-65/6*sin(11/7-3*t)-641/12*sin(11/7-t)+265/9*sin(2*t+11/7)+37/5*sin(4*t+11/7)+7931/15)*theta(47*pi-t)*theta(t-43*pi)+(1810/9*sin(t+11/7)+1904/5*sin(2*t+11/7)+481/24*sin(3*t+61/13)+181/30*sin(4*t+11/7)+277/10*sin(5*t+19/12)+292/11*sin(6*t+19/12)+25/7*sin(7*t+47/10)+38/5*sin(8*t+8/5)+74/11*sin(9*t+8/5)+75/13*sin(10*t+8/5)+18/11*sin(11*t+19/12)+3109/13)*theta(43*pi-t)*theta(t-39*pi)+(-19/9*sin(11/7-12*t)-21/8*sin(11/7-10*t)-1/11*sin(17/11-8*t)-32/19*sin(14/9-6*t)+4137/22*sin(t+11/7)+177/14*sin(2*t+33/7)+173/14*sin(3*t+11/7)+3/2*sin(4*t+19/12)+5/8*sin(5*t+14/9)+21/8*sin(7*t+11/7)+19/10*sin(9*t+11/7)+41/15*sin(11*t+11/7)+2104/3)*theta(39*pi-t)*theta(t-35*pi)+(-5/6*sin(17/12-11*t)-7/15*sin(5/12-10*t)-32/13*sin(7/13-3*t)-139/7*sin(2/7-2*t)+2224/15*sin(t+9/10)+103/10*sin(4*t+23/5)+45/44*sin(5*t+7/3)+35/9*sin(6*t+23/8)+21/10*sin(7*t+25/11)+10/11*sin(8*t+4/5)+23/15*sin(9*t+5/7)+4/5*sin(12*t+9/2)+1339/11)*theta(35*pi-t)*theta(t-31*pi)+(1069/6*sin(t+18/13)+643/28*sin(2*t+11/7)+255/16*sin(3*t+11/15)+247/29*sin(4*t+45/13)+53/6*sin(5*t+9/11)+14/29*sin(6*t+31/7)+21/5*sin(7*t+19/7)+53/20*sin(8*t+3/14)+24/13*sin(9*t+24/11)+sin(10*t+27/14)+7/8*sin(11*t+11/9)+1/3*sin(12*t+7/4)+4512/25)*theta(31*pi-t)*theta(t-27*pi)+(-73/8*sin(1/9-11*t)-101/7*sin(7/8-3*t)+3221/13*sin(t+4/5)+389/8*sin(2*t+36/11)+368/11*sin(4*t+80/27)+107/4*sin(5*t+1/4)+29/2*sin(6*t+13/4)+237/19*sin(7*t+1/6)+263/17*sin(8*t+10/3)+79/9*sin(9*t+5/14)+68/9*sin(10*t+67/22)+43/5*sin(12*t+29/9)-3139/7)*theta(27*pi-t)*theta(t-23*pi)+(-7/9*sin(9/10-17*t)-22/13*sin(86/85-11*t)-43/10*sin(1/33-7*t)-64/7*sin(2/9-5*t)-19/10*sin(7/10-4*t)+2327/9*sin(t+19/5)+46*sin(2*t+7/4)+52/7*sin(3*t+31/9)+44/13*sin(6*t+17/11)+35/13*sin(8*t+23/8)+45/17*sin(9*t+9/2)+35/17*sin(10*t+34/9)+17/10*sin(12*t+17/8)+3/5*sin(13*t+41/10)+15/13*sin(14*t+41/14)+10/19*sin(15*t+139/35)+7/9*sin(16*t+24/11)+7/8*sin(18*t+3/5)+9/8*sin(19*t+6/7)+7/9*sin(20*t+25/14)+17/18*sin(21*t+7/11)+9/8*sin(22*t+22/15)+3/7*sin(23*t+11/4)+7/12*sin(24*t+26/9)+3/14*sin(25*t+26/7)+12/25*sin(26*t+62/25)+7/11*sin(27*t+64/15)+1/4*sin(28*t+95/24)+7/20*sin(29*t+3)+4/9*sin(30*t+14/5)+1/9*sin(31*t+4)+1/11*sin(32*t+9/11)+3/13*sin(33*t+8/5)+1/8*sin(34*t+20/11)+2/5*sin(35*t+2/7)-16257/22)*theta(23*pi-t)*theta(t-19*pi)+(-3/8*sin(2/7-5*t)-51/19*sin(1/28-3*t)-34/7*sin(3/8-2*t)+20/9*sin(t+155/52)+16/17*sin(4*t+25/7)+4/9*sin(6*t+24/7)+3/10*sin(7*t+3/7)+3/11*sin(8*t+41/11)+2/11*sin(9*t+9/19)+1/8*sin(10*t+389/97)+1/6*sin(11*t+2/7)+1/6*sin(12*t+47/16)+5910/19)*theta(19*pi-t)*theta(t-15*pi)+(-4/15*sin(12/23-7*t)+24/7*sin(t+21/8)+15/4*sin(2*t+3/2)+31/9*sin(3*t+7/5)+8/5*sin(4*t+25/7)+13/17*sin(5*t+1/4)+2/3*sin(6*t+46/15)+5/13*sin(8*t+3)+3/7*sin(9*t+2/5)+3/10*sin(10*t+53/15)+2/7*sin(11*t+2/5)+1/3*sin(12*t+25/7)+109/2)*theta(15*pi-t)*theta(t-11*pi)+(-53/14*sin(18/13-4*t)+592/7*sin(t+21/10)+107/27*sin(2*t+17/4)+29/13*sin(3*t+41/11)+859/12)*theta(11*pi-t)*theta(t-7*pi)+(287/3*sin(t+19/9)+16/5*sin(2*t+43/13)+57/10*sin(3*t+21/8)+33/17*sin(4*t+31/7)+1877/6)*theta(7*pi-t)*theta(t-3*pi)+(-5/8*sin(2/3-15*t)-17/8*sin(11/10-12*t)-11/6*sin(9/13-9*t)-507/10*sin(2/9-3*t)-69/13*sin(41/27-2*t)+1813/5*sin(t+11/3)+63/13*sin(4*t+25/8)+63/4*sin(5*t+23/5)+122/11*sin(6*t+49/16)+32/7*sin(7*t+19/9)+37/8*sin(8*t+12/7)+20/9*sin(10*t+17/8)+43/17*sin(11*t+1/69)+31/14*sin(13*t+21/5)+5/3*sin(14*t+32/11)+66/65*sin(16*t+53/14)+760/3)*theta(3*pi-t)*theta(t+pi))*theta(sqrt(sgn(sin(t/2)))); y=((-13/5*sin(11/7-5*t)-51/8*sin(11/7-3*t)-28*sin(11/7-t)+97/6*sin(2*t+11/7)+124/25*sin(4*t+11/7)-7811/8)*theta(75*pi-t)*theta(t-71*pi)+(-76/7*sin(13/9-4*t)-69/4*sin(43/29-3*t)-50*sin(17/11-2*t)+229/12*sin(t+17/11)+13/8*sin(5*t+4/5)-2538/7)*theta(71*pi-t)*theta(t-67*pi)+(-17/4*sin(11/7-3*t)-217/11*sin(11/7-t)+79/7*sin(2*t+11/7)+11/6*sin(4*t+11/7)+15/14*sin(5*t+33/7)-79/6)*theta(67*pi-t)*theta(t-63*pi)+(-164/9*sin(11/7-2*t)+845/12*sin(t+11/7)+7/8*sin(3*t+18/11)+89/10*sin(4*t+33/7)+34/23*sin(5*t+47/10)+105/26*sin(6*t+33/7)+8/11*sin(7*t+14/9)+1/8*sin(8*t+17/11)+25/12*sin(9*t+11/7)+13/9*sin(10*t+11/7)+33/16*sin(11*t+14/9)+13/27*sin(12*t+14/9)+2/3*sin(13*t+14/9)+2671/13)*theta(63*pi-t)*theta(t-59*pi)+(-64/65*sin(14/9-6*t)-25/9*sin(14/9-5*t)-34/9*sin(14/9-4*t)-57/14*sin(14/9-3*t)-19/14*sin(11/7-2*t)+21/2*sin(t+11/7)+3133/11)*theta(59*pi-t)*theta(t-55*pi)+(-25/24*sin(23/15-27*t)-5/14*sin(14/11-25*t)-2/3*sin(16/11-17*t)-55/9*sin(40/27-8*t)-352/13*sin(14/9-5*t)-1519/38*sin(14/9-3*t)+3329/32*sin(t+47/10)+297/4*sin(2*t+14/9)+1939/38*sin(4*t+14/9)+239/9*sin(6*t+32/21)+34/9*sin(7*t+19/15)+107/6*sin(9*t+10/7)+271/10*sin(10*t+40/9)+693/13*sin(11*t+86/19)+160/7*sin(12*t+13/9)+289/16*sin(13*t+7/6)+385/48*sin(14*t+9/7)+44/9*sin(15*t+5/4)+41/11*sin(16*t+13/10)+12/13*sin(18*t+12/5)+46/9*sin(19*t+40/9)+10/9*sin(20*t+38/25)+46/31*sin(21*t+75/16)+37/16*sin(22*t+41/10)+35/11*sin(23*t+43/10)+10/13*sin(24*t+63/16)+2/3*sin(26*t+47/13)+19/7*sin(28*t+6/5)+13/10*sin(29*t+59/13)+3/2*sin(30*t+4/3)+11/10*sin(31*t+5/7)+17/13*sin(32*t+15/4)-11101/75)*theta(55*pi-t)*theta(t-51*pi)+(-3/10*sin(14/9-12*t)-29/12*sin(11/7-6*t)-38/9*sin(11/7-4*t)-59/8*sin(11/7-t)+183/7*sin(2*t+11/7)+125/13*sin(3*t+11/7)+31/16*sin(5*t+19/12)+4/9*sin(7*t+11/7)+3/13*sin(8*t+47/10)+64/63*sin(9*t+14/9)+3/13*sin(10*t+33/7)+1/2*sin(11*t+19/12)-11360/13)*theta(51*pi-t)*theta(t-47*pi)+(-60/11*sin(11/7-4*t)-528/31*sin(11/7-3*t)-661/55*sin(11/7-2*t)-623/3*sin(11/7-t)+39/8*sin(5*t+33/7)-5871/8)*theta(47*pi-t)*theta(t-43*pi)+(-43/13*sin(14/9-11*t)-45/8*sin(11/7-9*t)-41/15*sin(14/9-8*t)-57/11*sin(14/9-7*t)-157/6*sin(11/7-5*t)-1813/6*sin(11/7-t)+1997/15*sin(2*t+11/7)+89/6*sin(3*t+47/10)+19/6*sin(4*t+23/15)+191/8*sin(6*t+11/7)+191/17*sin(10*t+19/12)-7307/9)*theta(43*pi-t)*theta(t-39*pi)+(-15/8*sin(11/7-12*t)-72/73*sin(14/9-11*t)-19/9*sin(11/7-10*t)-35/11*sin(11/7-9*t)-7/11*sin(14/9-8*t)-60/11*sin(11/7-7*t)-191/13*sin(11/7-5*t)-184/5*sin(11/7-3*t)-109/10*sin(11/7-2*t)-609/2*sin(11/7-t)+1/6*sin(4*t+5/4)+11/5*sin(6*t+47/10)-6582/11)*theta(39*pi-t)*theta(t-35*pi)+(-11/15*sin(6/7-9*t)-47/13*sin(26/25-5*t)-67/27*sin(13/12-4*t)-633/8*sin(3/10-t)+251/7*sin(2*t+9/8)+123/8*sin(3*t+64/15)+23/8*sin(6*t+22/13)+26/9*sin(7*t+23/6)+14/9*sin(8*t+3/5)+19/12*sin(10*t+9/7)+25/19*sin(11*t+13/3)+11/17*sin(12*t+7/12)-5757/11)*theta(35*pi-t)*theta(t-31*pi)+(-50/3*sin(3/4-3*t)+263/10*sin(t+83/28)+669/13*sin(2*t+11/5)+17*sin(4*t+13/7)+67/11*sin(5*t+19/8)+11/3*sin(6*t+1/12)+38/17*sin(7*t+9/5)+51/14*sin(8*t+5/3)+49/25*sin(9*t+41/10)+17/12*sin(10*t+7/12)+53/54*sin(11*t+24/7)+5/7*sin(12*t+7/4)-10661/26)*theta(31*pi-t)*theta(t-27*pi)+(-127/10*sin(16/17-7*t)-119/9*sin(11/9-5*t)-1191/4*sin(1/3-t)+735/11*sin(2*t+2/9)+287/8*sin(3*t+61/16)+504/19*sin(4*t+17/9)+73/9*sin(6*t+9/5)+62/7*sin(8*t+14/5)+32/5*sin(9*t+1/6)+7/2*sin(10*t+19/7)+19/7*sin(11*t+1/44)+167/56*sin(12*t+51/14)-12878/17)*theta(27*pi-t)*theta(t-23*pi)+(-5/12*sin(14/15-32*t)-1/18*sin(17/13-31*t)-23/11*sin(1/6-19*t)-11/9*sin(38/25-18*t)-243/61*sin(25/17-8*t)-35/9*sin(11/21-7*t)-87/7*sin(4/5-6*t)-2249/15*sin(1/10-2*t)+1997/10*sin(t+23/12)+725/13*sin(3*t+1)+67/8*sin(4*t+9/4)+216/11*sin(5*t+23/5)+18/11*sin(9*t+32/31)+48/13*sin(10*t+19/8)+211/35*sin(11*t+16/5)+36/13*sin(12*t+64/15)+30/29*sin(13*t+8/13)+20/11*sin(14*t+28/13)+11/17*sin(15*t+37/16)+5/8*sin(16*t+23/14)+4/7*sin(17*t+14/9)+91/45*sin(20*t+14/27)+47/31*sin(21*t+8/5)+6/7*sin(22*t+29/15)+8/9*sin(23*t+53/20)+13/10*sin(24*t+89/30)+8/9*sin(25*t+39/10)+7/20*sin(26*t+97/24)+4/9*sin(27*t+18/13)+7/8*sin(28*t+45/14)+2/7*sin(29*t+42/13)+3/11*sin(30*t+22/5)+8/17*sin(33*t+4/11)+5/9*sin(34*t+18/13)+3/14*sin(35*t+12/5)-3384/11)*theta(23*pi-t)*theta(t-19*pi)+(-1/38*sin(2/11-7*t)-35/11*sin(9/14-t)+341/85*sin(2*t+25/14)+34/11*sin(3*t+22/21)+42/43*sin(4*t+223/56)+14/15*sin(5*t+3/4)+12/23*sin(6*t+7/2)+1/7*sin(8*t+4)+2/11*sin(9*t+9/8)+2/11*sin(10*t+73/29)+1/7*sin(11*t+1/4)+2/11*sin(12*t+74/25)+2961/20)*theta(19*pi-t)*theta(t-15*pi)+(-3/11*sin(13/25-12*t)-1/3*sin(15/29-10*t)-1/9*sin(4/3-8*t)-16/9*sin(12/13-4*t)+35/18*sin(t+89/19)+33/8*sin(2*t+49/16)+43/14*sin(3*t+33/13)+3/10*sin(5*t+26/11)+3/10*sin(6*t+4/11)+9/17*sin(7*t+94/27)+1/5*sin(9*t+35/11)+1/4*sin(11*t+20/7)+2917/15)*theta(15*pi-t)*theta(t-11*pi)+(949/15*sin(t+11/3)+63/11*sin(2*t+19/9)+26/7*sin(3*t+22/5)+7/8*sin(4*t+28/13)+3715/23)*theta(11*pi-t)*theta(t-7*pi)+(658/9*sin(t+107/27)+57/10*sin(2*t+9/5)+56/13*sin(3*t+38/9)+7/6*sin(4*t+10/11)+1681/16)*theta(7*pi-t)*theta(t-3*pi)+(-9/11*sin(13/10-16*t)-14/15*sin(2/7-15*t)-12/7*sin(3/8-12*t)-29/6*sin(5/11-8*t)-80/9*sin(5/14-4*t)+3076/7*sin(t+12/5)+343/18*sin(2*t+13/3)+230/17*sin(3*t+31/8)+21/4*sin(5*t+53/21)+23/10*sin(6*t+1/5)+27/7*sin(7*t+5/12)+60/17*sin(9*t+38/9)+11/8*sin(10*t+49/16)+10/7*sin(11*t+2/3)+4/7*sin(13*t+18/5)+17/12*sin(14*t+9/7)+598/9)*theta(3*pi-t)*theta(t+pi))*theta(sqrt(sgn(sin(t/2)))); plot(x,y);
function main clc;clear; t=0:0.0001:(76*pi); x=((4619/60*sin(t+11/7)+109/8*sin(2*t+11/7)+9/7*sin(3*t+11/7)+89/15*sin(4*t+11/7)+5/11*sin(5*t+11/7)-9839/41).*theta(75*pi-t).*theta(t-71*pi)+(-179/8*sin(11/7-2*t)+2101/20*sin(t+11/7)+5/6*sin(3*t+23/5)+65/9*sin(4*t+33/7)+33/8*sin(5*t+8/5)-698/9).*theta(71*pi-t).*theta(t-67*pi)+(952/15*sin(t+11/7)+116/21*sin(2*t+19/12)+26/5*sin(3*t+11/7)+11/9*sin(4*t+11/7)+25/11*sin(5*t+11/7)+3071/10).*theta(67*pi-t).*theta(t-63*pi)+(-4/11*sin(17/11-4*t)+657/13*sin(t+33/7)+29/11*sin(2*t+47/10)+17/6*sin(3*t+14/9)+2/13*sin(5*t+22/13)+15/8*sin(6*t+33/7)+16/11*sin(7*t+47/10)+5/3*sin(8*t+47/10)+24/13*sin(9*t+33/7)+9/11*sin(10*t+47/10)+6/5*sin(11*t+47/10)+17/18*sin(12*t+47/10)+4/9*sin(13*t+75/16)+1163/3).*theta(63*pi-t).*theta(t-59*pi)+(-11/13*sin(11/7-6*t)-17/10*sin(11/7-4*t)+261/7*sin(t+11/7)+17/3*sin(2*t+33/7)+44/19*sin(3*t+11/7)+7/9*sin(5*t+14/9)+259/3).*theta(59*pi-t).*theta(t-55*pi)+(-9/11*sin(26/17-23*t)-287/9*sin(11/7-5*t)-271/9*sin(17/11-3*t)+1551/13*sin(t+17/11)+685/8*sin(2*t+17/11)+535/11*sin(4*t+14/9)+311/11*sin(6*t+14/9)+1141/60*sin(7*t+61/13)+19/9*sin(8*t+21/11)+55/8*sin(9*t+77/17)+239/12*sin(10*t+9/2)+7/9*sin(11*t+69/16)+59/6*sin(12*t+13/10)+73/24*sin(13*t+13/11)+17/12*sin(14*t+47/11)+11/16*sin(15*t+22/5)+17/6*sin(16*t+4/3)+7/11*sin(17*t+17/13)+17/9*sin(18*t+11/9)+7/4*sin(19*t+7/5)+5/4*sin(20*t+53/12)+50/13*sin(21*t+12/11)+103/13*sin(22*t+8/7)+13/5*sin(24*t+29/7)+1/2*sin(25*t+16/5)+31/16*sin(26*t+13/3)+8/7*sin(27*t+33/8)+17/14*sin(28*t+123/31)+22/9*sin(29*t+30/7)+2/3*sin(30*t+48/13)+19/12*sin(31*t+89/22)+18/11*sin(32*t+46/11)+417/8).*theta(55*pi-t).*theta(t-51*pi)+(-2/7*sin(14/9-10*t)-9/13*sin(14/9-8*t)-224/11*sin(11/7-3*t)+197/11*sin(t+11/7)+139/14*sin(2*t+11/7)+17/12*sin(4*t+47/10)+43/12*sin(5*t+33/7)+2/5*sin(6*t+47/10)+28/19*sin(7*t+47/10)+34/33*sin(9*t+47/10)+1/4*sin(11*t+14/3)+6/19*sin(12*t+19/12)-955/8).*theta(51*pi-t).*theta(t-47*pi)+(-149/28*sin(11/7-5*t)-65/6*sin(11/7-3*t)-641/12*sin(11/7-t)+265/9*sin(2*t+11/7)+37/5*sin(4*t+11/7)+7931/15).*theta(47*pi-t).*theta(t-43*pi)+(1810/9*sin(t+11/7)+1904/5*sin(2*t+11/7)+481/24*sin(3*t+61/13)+181/30*sin(4*t+11/7)+277/10*sin(5*t+19/12)+292/11*sin(6*t+19/12)+25/7*sin(7*t+47/10)+38/5*sin(8*t+8/5)+74/11*sin(9*t+8/5)+75/13*sin(10*t+8/5)+18/11*sin(11*t+19/12)+3109/13).*theta(43*pi-t).*theta(t-39*pi)+(-19/9*sin(11/7-12*t)-21/8*sin(11/7-10*t)-1/11*sin(17/11-8*t)-32/19*sin(14/9-6*t)+4137/22*sin(t+11/7)+177/14*sin(2*t+33/7)+173/14*sin(3*t+11/7)+3/2*sin(4*t+19/12)+5/8*sin(5*t+14/9)+21/8*sin(7*t+11/7)+19/10*sin(9*t+11/7)+41/15*sin(11*t+11/7)+2104/3).*theta(39*pi-t).*theta(t-35*pi)+(-5/6*sin(17/12-11*t)-7/15*sin(5/12-10*t)-32/13*sin(7/13-3*t)-139/7*sin(2/7-2*t)+2224/15*sin(t+9/10)+103/10*sin(4*t+23/5)+45/44*sin(5*t+7/3)+35/9*sin(6*t+23/8)+21/10*sin(7*t+25/11)+10/11*sin(8*t+4/5)+23/15*sin(9*t+5/7)+4/5*sin(12*t+9/2)+1339/11).*theta(35*pi-t).*theta(t-31*pi)+(1069/6*sin(t+18/13)+643/28*sin(2*t+11/7)+255/16*sin(3*t+11/15)+247/29*sin(4*t+45/13)+53/6*sin(5*t+9/11)+14/29*sin(6*t+31/7)+21/5*sin(7*t+19/7)+53/20*sin(8*t+3/14)+24/13*sin(9*t+24/11)+sin(10*t+27/14)+7/8*sin(11*t+11/9)+1/3*sin(12*t+7/4)+4512/25).*theta(31*pi-t).*theta(t-27*pi)+(-73/8*sin(1/9-11*t)-101/7*sin(7/8-3*t)+3221/13*sin(t+4/5)+389/8*sin(2*t+36/11)+368/11*sin(4*t+80/27)+107/4*sin(5*t+1/4)+29/2*sin(6*t+13/4)+237/19*sin(7*t+1/6)+263/17*sin(8*t+10/3)+79/9*sin(9*t+5/14)+68/9*sin(10*t+67/22)+43/5*sin(12*t+29/9)-3139/7).*theta(27*pi-t).*theta(t-23*pi)+(-7/9*sin(9/10-17*t)-22/13*sin(86/85-11*t)-43/10*sin(1/33-7*t)-64/7*sin(2/9-5*t)-19/10*sin(7/10-4*t)+2327/9*sin(t+19/5)+46*sin(2*t+7/4)+52/7*sin(3*t+31/9)+44/13*sin(6*t+17/11)+35/13*sin(8*t+23/8)+45/17*sin(9*t+9/2)+35/17*sin(10*t+34/9)+17/10*sin(12*t+17/8)+3/5*sin(13*t+41/10)+15/13*sin(14*t+41/14)+10/19*sin(15*t+139/35)+7/9*sin(16*t+24/11)+7/8*sin(18*t+3/5)+9/8*sin(19*t+6/7)+7/9*sin(20*t+25/14)+17/18*sin(21*t+7/11)+9/8*sin(22*t+22/15)+3/7*sin(23*t+11/4)+7/12*sin(24*t+26/9)+3/14*sin(25*t+26/7)+12/25*sin(26*t+62/25)+7/11*sin(27*t+64/15)+1/4*sin(28*t+95/24)+7/20*sin(29*t+3)+4/9*sin(30*t+14/5)+1/9*sin(31*t+4)+1/11*sin(32*t+9/11)+3/13*sin(33*t+8/5)+1/8*sin(34*t+20/11)+2/5*sin(35*t+2/7)-16257/22).*theta(23*pi-t).*theta(t-19*pi)+(-3/8*sin(2/7-5*t)-51/19*sin(1/28-3*t)-34/7*sin(3/8-2*t)+20/9*sin(t+155/52)+16/17*sin(4*t+25/7)+4/9*sin(6*t+24/7)+3/10*sin(7*t+3/7)+3/11*sin(8*t+41/11)+2/11*sin(9*t+9/19)+1/8*sin(10*t+389/97)+1/6*sin(11*t+2/7)+1/6*sin(12*t+47/16)+5910/19).*theta(19*pi-t).*theta(t-15*pi)+(-4/15*sin(12/23-7*t)+24/7*sin(t+21/8)+15/4*sin(2*t+3/2)+31/9*sin(3*t+7/5)+8/5*sin(4*t+25/7)+13/17*sin(5*t+1/4)+2/3*sin(6*t+46/15)+5/13*sin(8*t+3)+3/7*sin(9*t+2/5)+3/10*sin(10*t+53/15)+2/7*sin(11*t+2/5)+1/3*sin(12*t+25/7)+109/2).*theta(15*pi-t).*theta(t-11*pi)+(-53/14*sin(18/13-4*t)+592/7*sin(t+21/10)+107/27*sin(2*t+17/4)+29/13*sin(3*t+41/11)+859/12).*theta(11*pi-t).*theta(t-7*pi)+(287/3*sin(t+19/9)+16/5*sin(2*t+43/13)+57/10*sin(3*t+21/8)+33/17*sin(4*t+31/7)+1877/6).*theta(7*pi-t).*theta(t-3*pi)+(-5/8*sin(2/3-15*t)-17/8*sin(11/10-12*t)-11/6*sin(9/13-9*t)-507/10*sin(2/9-3*t)-69/13*sin(41/27-2*t)+1813/5*sin(t+11/3)+63/13*sin(4*t+25/8)+63/4*sin(5*t+23/5)+122/11*sin(6*t+49/16)+32/7*sin(7*t+19/9)+37/8*sin(8*t+12/7)+20/9*sin(10*t+17/8)+43/17*sin(11*t+1/69)+31/14*sin(13*t+21/5)+5/3*sin(14*t+32/11)+66/65*sin(16*t+53/14)+760/3).*theta(3*pi-t).*theta(t+pi)).*theta(sqrt(sign(sin(t/2)))); y=((-13/5*sin(11/7-5*t)-51/8*sin(11/7-3*t)-28*sin(11/7-t)+97/6*sin(2*t+11/7)+124/25*sin(4*t+11/7)-7811/8).*theta(75*pi-t).*theta(t-71*pi)+(-76/7*sin(13/9-4*t)-69/4*sin(43/29-3*t)-50*sin(17/11-2*t)+229/12*sin(t+17/11)+13/8*sin(5*t+4/5)-2538/7).*theta(71*pi-t).*theta(t-67*pi)+(-17/4*sin(11/7-3*t)-217/11*sin(11/7-t)+79/7*sin(2*t+11/7)+11/6*sin(4*t+11/7)+15/14*sin(5*t+33/7)-79/6).*theta(67*pi-t).*theta(t-63*pi)+(-164/9*sin(11/7-2*t)+845/12*sin(t+11/7)+7/8*sin(3*t+18/11)+89/10*sin(4*t+33/7)+34/23*sin(5*t+47/10)+105/26*sin(6*t+33/7)+8/11*sin(7*t+14/9)+1/8*sin(8*t+17/11)+25/12*sin(9*t+11/7)+13/9*sin(10*t+11/7)+33/16*sin(11*t+14/9)+13/27*sin(12*t+14/9)+2/3*sin(13*t+14/9)+2671/13).*theta(63*pi-t).*theta(t-59*pi)+(-64/65*sin(14/9-6*t)-25/9*sin(14/9-5*t)-34/9*sin(14/9-4*t)-57/14*sin(14/9-3*t)-19/14*sin(11/7-2*t)+21/2*sin(t+11/7)+3133/11).*theta(59*pi-t).*theta(t-55*pi)+(-25/24*sin(23/15-27*t)-5/14*sin(14/11-25*t)-2/3*sin(16/11-17*t)-55/9*sin(40/27-8*t)-352/13*sin(14/9-5*t)-1519/38*sin(14/9-3*t)+3329/32*sin(t+47/10)+297/4*sin(2*t+14/9)+1939/38*sin(4*t+14/9)+239/9*sin(6*t+32/21)+34/9*sin(7*t+19/15)+107/6*sin(9*t+10/7)+271/10*sin(10*t+40/9)+693/13*sin(11*t+86/19)+160/7*sin(12*t+13/9)+289/16*sin(13*t+7/6)+385/48*sin(14*t+9/7)+44/9*sin(15*t+5/4)+41/11*sin(16*t+13/10)+12/13*sin(18*t+12/5)+46/9*sin(19*t+40/9)+10/9*sin(20*t+38/25)+46/31*sin(21*t+75/16)+37/16*sin(22*t+41/10)+35/11*sin(23*t+43/10)+10/13*sin(24*t+63/16)+2/3*sin(26*t+47/13)+19/7*sin(28*t+6/5)+13/10*sin(29*t+59/13)+3/2*sin(30*t+4/3)+11/10*sin(31*t+5/7)+17/13*sin(32*t+15/4)-11101/75).*theta(55*pi-t).*theta(t-51*pi)+(-3/10*sin(14/9-12*t)-29/12*sin(11/7-6*t)-38/9*sin(11/7-4*t)-59/8*sin(11/7-t)+183/7*sin(2*t+11/7)+125/13*sin(3*t+11/7)+31/16*sin(5*t+19/12)+4/9*sin(7*t+11/7)+3/13*sin(8*t+47/10)+64/63*sin(9*t+14/9)+3/13*sin(10*t+33/7)+1/2*sin(11*t+19/12)-11360/13).*theta(51*pi-t).*theta(t-47*pi)+(-60/11*sin(11/7-4*t)-528/31*sin(11/7-3*t)-661/55*sin(11/7-2*t)-623/3*sin(11/7-t)+39/8*sin(5*t+33/7)-5871/8).*theta(47*pi-t).*theta(t-43*pi)+(-43/13*sin(14/9-11*t)-45/8*sin(11/7-9*t)-41/15*sin(14/9-8*t)-57/11*sin(14/9-7*t)-157/6*sin(11/7-5*t)-1813/6*sin(11/7-t)+1997/15*sin(2*t+11/7)+89/6*sin(3*t+47/10)+19/6*sin(4*t+23/15)+191/8*sin(6*t+11/7)+191/17*sin(10*t+19/12)-7307/9).*theta(43*pi-t).*theta(t-39*pi)+(-15/8*sin(11/7-12*t)-72/73*sin(14/9-11*t)-19/9*sin(11/7-10*t)-35/11*sin(11/7-9*t)-7/11*sin(14/9-8*t)-60/11*sin(11/7-7*t)-191/13*sin(11/7-5*t)-184/5*sin(11/7-3*t)-109/10*sin(11/7-2*t)-609/2*sin(11/7-t)+1/6*sin(4*t+5/4)+11/5*sin(6*t+47/10)-6582/11).*theta(39*pi-t).*theta(t-35*pi)+(-11/15*sin(6/7-9*t)-47/13*sin(26/25-5*t)-67/27*sin(13/12-4*t)-633/8*sin(3/10-t)+251/7*sin(2*t+9/8)+123/8*sin(3*t+64/15)+23/8*sin(6*t+22/13)+26/9*sin(7*t+23/6)+14/9*sin(8*t+3/5)+19/12*sin(10*t+9/7)+25/19*sin(11*t+13/3)+11/17*sin(12*t+7/12)-5757/11).*theta(35*pi-t).*theta(t-31*pi)+(-50/3*sin(3/4-3*t)+263/10*sin(t+83/28)+669/13*sin(2*t+11/5)+17*sin(4*t+13/7)+67/11*sin(5*t+19/8)+11/3*sin(6*t+1/12)+38/17*sin(7*t+9/5)+51/14*sin(8*t+5/3)+49/25*sin(9*t+41/10)+17/12*sin(10*t+7/12)+53/54*sin(11*t+24/7)+5/7*sin(12*t+7/4)-10661/26).*theta(31*pi-t).*theta(t-27*pi)+(-127/10*sin(16/17-7*t)-119/9*sin(11/9-5*t)-1191/4*sin(1/3-t)+735/11*sin(2*t+2/9)+287/8*sin(3*t+61/16)+504/19*sin(4*t+17/9)+73/9*sin(6*t+9/5)+62/7*sin(8*t+14/5)+32/5*sin(9*t+1/6)+7/2*sin(10*t+19/7)+19/7*sin(11*t+1/44)+167/56*sin(12*t+51/14)-12878/17).*theta(27*pi-t).*theta(t-23*pi)+(-5/12*sin(14/15-32*t)-1/18*sin(17/13-31*t)-23/11*sin(1/6-19*t)-11/9*sin(38/25-18*t)-243/61*sin(25/17-8*t)-35/9*sin(11/21-7*t)-87/7*sin(4/5-6*t)-2249/15*sin(1/10-2*t)+1997/10*sin(t+23/12)+725/13*sin(3*t+1)+67/8*sin(4*t+9/4)+216/11*sin(5*t+23/5)+18/11*sin(9*t+32/31)+48/13*sin(10*t+19/8)+211/35*sin(11*t+16/5)+36/13*sin(12*t+64/15)+30/29*sin(13*t+8/13)+20/11*sin(14*t+28/13)+11/17*sin(15*t+37/16)+5/8*sin(16*t+23/14)+4/7*sin(17*t+14/9)+91/45*sin(20*t+14/27)+47/31*sin(21*t+8/5)+6/7*sin(22*t+29/15)+8/9*sin(23*t+53/20)+13/10*sin(24*t+89/30)+8/9*sin(25*t+39/10)+7/20*sin(26*t+97/24)+4/9*sin(27*t+18/13)+7/8*sin(28*t+45/14)+2/7*sin(29*t+42/13)+3/11*sin(30*t+22/5)+8/17*sin(33*t+4/11)+5/9*sin(34*t+18/13)+3/14*sin(35*t+12/5)-3384/11).*theta(23*pi-t).*theta(t-19*pi)+(-1/38*sin(2/11-7*t)-35/11*sin(9/14-t)+341/85*sin(2*t+25/14)+34/11*sin(3*t+22/21)+42/43*sin(4*t+223/56)+14/15*sin(5*t+3/4)+12/23*sin(6*t+7/2)+1/7*sin(8*t+4)+2/11*sin(9*t+9/8)+2/11*sin(10*t+73/29)+1/7*sin(11*t+1/4)+2/11*sin(12*t+74/25)+2961/20).*theta(19*pi-t).*theta(t-15*pi)+(-3/11*sin(13/25-12*t)-1/3*sin(15/29-10*t)-1/9*sin(4/3-8*t)-16/9*sin(12/13-4*t)+35/18*sin(t+89/19)+33/8*sin(2*t+49/16)+43/14*sin(3*t+33/13)+3/10*sin(5*t+26/11)+3/10*sin(6*t+4/11)+9/17*sin(7*t+94/27)+1/5*sin(9*t+35/11)+1/4*sin(11*t+20/7)+2917/15).*theta(15*pi-t).*theta(t-11*pi)+(949/15*sin(t+11/3)+63/11*sin(2*t+19/9)+26/7*sin(3*t+22/5)+7/8*sin(4*t+28/13)+3715/23).*theta(11*pi-t).*theta(t-7*pi)+(658/9*sin(t+107/27)+57/10*sin(2*t+9/5)+56/13*sin(3*t+38/9)+7/6*sin(4*t+10/11)+1681/16).*theta(7*pi-t).*theta(t-3*pi)+(-9/11*sin(13/10-16*t)-14/15*sin(2/7-15*t)-12/7*sin(3/8-12*t)-29/6*sin(5/11-8*t)-80/9*sin(5/14-4*t)+3076/7*sin(t+12/5)+343/18*sin(2*t+13/3)+230/17*sin(3*t+31/8)+21/4*sin(5*t+53/21)+23/10*sin(6*t+1/5)+27/7*sin(7*t+5/12)+60/17*sin(9*t+38/9)+11/8*sin(10*t+49/16)+10/7*sin(11*t+2/3)+4/7*sin(13*t+18/5)+17/12*sin(14*t+9/7)+598/9).*theta(3*pi-t).*theta(t+pi)).*theta(sqrt(sign(sin(t/2)))); plot(x,y, end % function result=sign(in) % % if in<0 % result=-1; % else % result=1; % end % % end function result=theta(in) result = (in>0); end
try f = fopen( % do something fclose(f); catch me fclose(f); rethrow(me); end
classdef safefopen < handle properties(Access=private) fid; end methods(Access=public) function this = safefopen(fileName,varargin) this.fid = fopen(fileName,varargin{:}); end function fwrite(this,varargin) fwrite(this.fid,varargin{:}); end function fprintf(this,varargin) fprintf(this.fid,varargin{:}); end function delete(this) fclose(this.fid); end end end
function delete(this) [msg,errorId] = fclose(this.fid); if errorId~=0 throw(MException( end end
function fileOpenSafely(fileName) fid = fopen(fileName, c = onCleanup(@()fclose(fid)); functionThatMayError(fid); end % c executes fclose(fid) here
methods(Access=public) function varargout = subsref(this, s) switch s(1).type case if numel(s) > 1, feval(s(1).subs, this.fid, s(2).subs{:}); else feval(s(1).subs, this.fid); end % We ignore outputs, but see below for an ugly solution to this varargout = {}; otherwise varargout{1} = builtin( end end end
methods(Access=public) function varargout = subsref(this, s) if nargout > 0, lhs = lhs = repmat(lhs, 1, nargout); lhs = [ else lhs = end switch s(1).type case if numel(s) > 1, eval(... sprintf(... lhs, s(1).subs) ... ); else eval(... sprintf( lhs, s(1).subs) ... ); end otherwise varargout{1} = builtin( end end end
myFile = safefopen( count = myFile.fprintf( [filename,permission,machineformat,encoding] = myFile.fopen();
function Z=myfunc() % Do some calculations dlmwrite( end
matlab_exec=matlab X="${1}(${2})" echo ${X} > matlab_command_${2}.m cat matlab_command_${2}.m ${matlab_exec} -nojvm -nodisplay -nosplash < matlab_command_${2}.m rm matlab_command_${2}.m
matlab -nosplash -nodesktop -logfile remoteAutocode.log -r matlabCommand
matlab -nodisplay -r "funcname arg1 arg2 arg3 argN"
nohup matlab -nodisplay -nodesktop -nojvm -nosplash -r script.m > output &
matlab_exec=matlab i=0 for var in "$@" do args[$i]=$var let i=$i+1 done unset args[0] X="${1}(" for arg in ${args[*]} ; do if ! [[ "$arg" =~ ^[0-9]+([.][0-9]+)?$ ]] ; then X="${X} else X="${X}"$arg"," fi done X="${X%?}" X="${X})" echo The MATLAB function call is ${X} echo "cd( ${matlab_exec} -nojvm -nodisplay -nosplash < matlab_command.m rm matlab_command.m
d = dir(pathFolder); isub = [d(:).isdir]; % nameFolds = {d(isub).name}
% `rootDir` is given dirs = dir(rootDir); % remove `.` and `..` dirs(1:2) = []; % select just directories not files dirs = dirs([obj.dirs.isdir]); % select name of directories dirs = {dirs.name};
function [ dirList ] = get_directory_names( dir_name ) %get_directory_names; this function outputs a cell with directory names (as %strings), given a certain dir name (string) %from: http: %in-a-folder-matlab-only-subfolders-not-files dd = dir(dir_name); isub = [dd(:).isdir]; % dirList = {dd(isub).name} dirList(ismember(dirList,{ end
Error using ^ Inputs must be a scalar and a square matrix. To compute elementwise POWER, use POWER (.^) instead.
+---+------------------------------------------------------+ | | 1 2 3 4 5 6 7 8 9 | +---+------------------------------------------------------+ | 1 | 0 1 0 1 0 0 0 0 0 | | 2 | 1 0 1 0 1 0 0 0 0 | | 3 | 0 1 0 0 0 1 0 0 0 | | 4 | 1 0 0 0 1 0 1 0 0 | | 5 | 0 1 0 1 0 1 0 1 0 | | 6 | 0 0 1 0 1 0 0 0 1 | | 7 | 0 0 0 1 0 0 0 1 0 | | 8 | 0 0 0 0 1 0 1 0 1 | | 9 | 0 0 0 0 0 1 0 1 0 | +---+------------------------------------------------------+
N = 3; M = 3; adj = zeros(N*M); for i=1:N for j=1:M k = sub2ind([N M],i,j); if i>1 ii=i-1; jj=j; adj(k,sub2ind([N M],ii,jj)) = 1; end if i<N ii=i+1; jj=j; adj(k,sub2ind([N M],ii,jj)) = 1; end if j>1 ii=i; jj=j-1; adj(k,sub2ind([N M],ii,jj)) = 1; end if j<M ii=i; jj=j+1; adj(k,sub2ind([N M],ii,jj)) = 1; end end end
mat = [1 2 3; 4 5 6; 7 8 9]; % Sample matrix [r, c] = size(mat); % Get the matrix size diagVec1 = repmat([ones(c-1, 1); 0], r, 1); % Make the first diagonal vector % (for horizontal connections) diagVec1 = diagVec1(1:end-1); % Remove the last value diagVec2 = ones(c*(r-1), 1); % Make the second diagonal vector % (for vertical connections) adj = diag(diagVec1, 1)+diag(diagVec2, c); % Add the diagonals to a zero matrix adj = adj+adj. % itself to make it symmetric
adj = 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0
mat = [1 2 3; 4 5 6; 7 8 9]; % Sample matrix [r, c] = size(mat); % Get the matrix size diagVec1 = repmat([ones(c-1, 1); 0], r, 1); % Make the first diagonal vector % (for horizontal connections) diagVec1 = diagVec1(1:end-1); % Remove the last value diagVec2 = [0; diagVec1(1:(c*(r-1)))]; % Make the second diagonal vector % (for anti-diagonal connections) diagVec3 = ones(c*(r-1), 1); % Make the third diagonal vector % (for vertical connections) diagVec4 = diagVec2(2:end-1); % Make the fourth diagonal vector % (for diagonal connections) adj = diag(diagVec1, 1)+... % Add the diagonals to a zero matrix diag(diagVec2, c-1)+... diag(diagVec3, c)+... diag(diagVec4, c+1); adj = adj+adj. % itself to make it symmetric
adj = 0 1 0 1 1 0 0 0 0 1 0 1 1 1 1 0 0 0 0 1 0 0 1 1 0 0 0 1 1 0 0 1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 0 1 0 0 1 1 0 0 0 1 1 0 0 1 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 1 0 1 0
N = 3; M = 3; % CONNECTED = 8; % % if CONNECTED == 4, distFunc = elseif CONNECTED == 8, distFunc = % [X Y] = meshgrid(1:N,1:M); X = X(:); Y = Y(:); adj = squareform( pdist([X Y], distFunc) == 1 );
% subplot(121), spy(adj) % [xx yy] = gplot(adj, [X Y]); subplot(122), plot(xx, yy, axis([0 N+1 0 M+1]) % [X Y] = meshgrid(1:N,1:M); X = reshape(X text(X, Y(end:-1:1), cellstr(num2str((1:N*M)
function W = getAdjacencyMatrix(I) [m, n] = size(I); I_size = m*n; % 1-off diagonal elements V = repmat([ones(m-1,1); 0],n, 1); V = V(1:end-1); % remove last zero % n-off diagonal elements U = ones(m*(n-1), 1); % get the upper triangular part of the matrix W = sparse(1:(I_size-1), 2:I_size, V, I_size, I_size)... + sparse(1:(I_size-m),(m+1):I_size, U, I_size, I_size); % finally make W symmetric W = W + W
% Construct sparse adjacency matrix (provides ii and jj indices into the % matrix) % % Usage: % [ii jj] = sparse_adj_matrix(sz, r, p) % % inputs: % sz - grid size (determine the number of variables n=prod(sz), and the % geometry/dimensionality) % r - the radius around each point for which edges are formed % p - in what p-norm to measure the r-ball, can be 1,2 or % % outputs % ii, jj - linear indices into adjacency matrix (for each pair (m,n) % there is also the pair (n,m)) % % How to construct the adjacency matrix? % >> A = sparse(ii, jj, ones(1,numel(ii)), prod(sz), prod(sz)); % % % Example: % >> [ii jj] = sparse_adj_matrix([10 20], 1, inf); % construct indices for 200x200 adjacency matrix for 8-connect graph over a % grid of 10x20 nodes. % To visualize the graph: % >> [r c]=ndgrid(1:10,1:20); % >> A = sparse(ii, jj, 1, 200, 200);; % >> gplot(A, [r(:) c(:)]);
function adj = AdjMatrixLattice4( N, M ) % Size of adjacency matrix MN = M*N; adj = zeros(MN,MN); % number nodes as such % [1]---[2]-- .. --[M] % | | | % [M+1]-[M+2]- .. -[2*M] % : : : % [] [] .. [M*N] for i=1:N for j=1:N A = M*(i-1)+j; %Node if(j<N) B = M*(i-1)+j+1; %Node adj(A,B) = 1; adj(B,A) = 1; end if(i<M) B = M*i+j; %Node adj(A,B) = 1; adj(B,A) = 1; end end end end
0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0
[M,I] = max (A(:)); [ind1, ind2, ind3] = ind2sub(size(A),I)
howManyColumns_in_A = cols(A) howManyRows_in_A = rows(A)
function ByteSize(in, fid) % BYTESIZE writes the memory usage of the provide variable to the given file % identifier. Output is written to screen if fid is 1, empty or not provided. if nargin == 1 || isempty(fid) fid = 1; end s = whos( fprintf(fid,[Bytes2str(s.bytes) end function str = Bytes2str(NumBytes) % BYTES2STR Private function to take integer bytes and convert it to % scale-appropriate size. scale = floor(log(NumBytes)/log(1024)); switch scale case 0 str = [sprintf( case 1 str = [sprintf( case 2 str = [sprintf( case 3 str = [sprintf( case 4 str = [sprintf( case -inf % Size occasionally returned as zero (eg some Java objects). str = otherwise str = end end
function b = getByteSize(theVariable, returnType, fid) % getByteSize returns the mem.usage of the provided variable(theVariable) to the given file % identifier. % returnType is assigned meaningfully according to the byte size if not stated % Output is written to screen if fid is 1, empty or not provided. s = whos( b = s.bytes; if nargin == 1 || isempty(returnType) scale = floor(log(b)/log(1024)); switch scale case 0 returnType = case 1 returnType = case 2 returnType = case 3 returnType = case 4 returnType = case -inf % Size occasionally returned as zero (eg some Java objects). returnType = warning( otherwise returnType = warning( end end switch returnType case { b = s.bytes; case { b = b / 1024; case { b = b / 1024^2; case { b = b / 1024^3; case { b = b / 1024^4; case { b = b / 1024^5; otherwise returnType = end if nargin <= 2 || isempty(fid) || fid == 1 fprintf(1,[num2str(b) elseif nargin > 2 && ~isempty(fid) && fid > 2 try fprintf(fid,[num2str(b) catch warning([ fprintf(1,[num2str(b) end end end
fid = fopen(filename); if fid==-1 error( end try line = getl(fid); catch ME fclose(fid); rethrow ME; end fclose(fid);
function data = load_line(filename) data = []; fid = fopen(filename); if fid == -1 error( end c = onCleanup(@()fclose(fid)); data = getl(fid); end
>> x(1.2) >> x(-0.3) >> x([1.4 2 3]) >> x([1.4 2.4 3.4]) >> x([1.4:4]) >> x(end/2)
>> x(1.2:3) ans = 10 20 >> x(0.4:3) ans = 10 10 20 >> x(0.6:3) ans = 10 20 30 >> x(1.2:0.7:5) ans = 10 20 30 30 40 50 >> x(-0.4:3) ans = 10 10 20 30
>> x(1.5:end-2) ans = 20 30 >> x(1.5:end/6:end-1) ans = 20 20 30 40
N = 10; names = cell(1,N); for i=1:N names{i} = end
>> string1 = >> string2 = >> S = strvcat(string1,string2) S = hi there
name = {}; for i = somearray name = [name; {string}]; end
name=[]; for_loop filename = name=[name; {filename}]; end
N = 10; names = strings(1,N); for i=1:N names(i) = end
stringtable = for i = 1:3 stringtable = {stringtable;new_string(i)} end
%% I = imread( % G = fspecial( % Ig = imfilter(I,G, % imshow(Ig)
[X,Y] = meshgrid(-8:.5:8); R = sqrt(X.^2 + Y.^2) + eps; Z = sin(R)./R; % surface in 3D figure; surf(Z,
% using imagesc to view just Z figure; imagesc(Z); colormap jet;
figure; surf(X, Y, Z, view(2); axis equal; axis off;
[X,Y] = meshgrid(-8:.5:8); R = sqrt(X.^2 + Y.^2) + eps; Z = sin(R)./R; figure; subplot(1,3,1); pcolor(X,Y,Z); subplot(1,3,2); pcolor(X,Y,Z); shading flat; subplot(1,3,3); pcolor(X,Y,Z); shading interp;
[x, y] = meshgrid(1:10,1:5); z = x.^3 + y.^3; subplot(3,1,1) imagesc(flipud(z)), axis equal tight, colorbar set(gca, title( subplot(3,1,2) surf(x,y,z, title( subplot(3,1,3) imagesc(flipud(z)), axis equal tight, colorbar axis([0.5 9.5 1.5 5.5]) set(gca, title( colormap jet
% x = 0:20; N = numel(x); y1 = rand(1,N); y2 = 5.*rand(1,N)+5; y3 = 50.*rand(1,N)-50; % axesPosition = [110 40 200 200]; % yWidth = 30; % xLimit = [min(x) max(x)]; % xOffset = -yWidth*diff(xLimit)/axesPosition(3); % figure( h1 = axes( h2 = axes( h3 = axes( xlabel(h1, ylabel(h3, % plot(h1,x,y1, plot(h2,x,y2, plot(h3,x,y3,
% x=1:20; y = [randn(20,1)*1 + 0 , randn(20,1)*5 + 10 , randn(20,1)*0.3 + 50]; % plotyy(x,y(:,1), x,y(:,3)) % figure subplot(221), plot(x,y(:,1), x,y(:,2), x,y(:,3)) title( % yy = bsxfun(@times, bsxfun(@minus,y,min(y)), 1./range(y)); subplot(222), plot(x,yy(:,1), x,yy(:,2), x,yy(:,3)) title( % yy = zscore(y); subplot(223), plot(x,yy(:,1), x,yy(:,2), x,yy(:,3)) title( % yy = 1 ./ ( 1 + exp( -zscore(y) ) ); subplot(224), plot(x,yy(:,1), x,yy(:,2), x,yy(:,3)) title(
close all clear all display( x = 0:10; y1 = rand(1,11); y2 = 10.*rand(1,11); y3 = 100.*rand(1,11); y4 = 100.*rand(1,11); display( figure; ax1 = gca; get(ax1, set(ax1, line(x, y1, ax2 = axes( line(x, y2, ax3 = axes( line(x, y3, ax4 = axes( line(x, y4,
clear clc x = linspace(0,1,10); N = numel(x); y = rand(1,N); y_extra_1 = 5.*rand(1,N)+5; y_extra_2 = 50.*rand(1,N)+20; Y = [y;y_extra_1;y_extra_2]; xLimit = [min(x) max(x)]; xWidth = xLimit(2)-xLimit(1); numberOfExtraPlots = 2; a = 0.05; N_ = numberOfExtraPlots+1; for i=1:N_ L=1-(numberOfExtraPlots*a)-0.2; axesPosition = [(0.1+(numberOfExtraPlots*a)) 0.1 L 0.8]; if(i==1) color = [rand(1),rand(1),rand(1)]; figure( axes( plot(x,Y(i,:), xlabel( ylab = strcat( ylabel(ylab) numberOfExtraPlots = numberOfExtraPlots - 1; else color = [rand(1),rand(1),rand(1)]; axes( V = (xWidth*a*(i-1))/L; b=xLimit+[V 0]; x_=linspace(b(1),b(2),10); plot(x_,Y(i,:), ylab = strcat( ylabel(ylab) numberOfExtraPlots = numberOfExtraPlots - 1; end end
img = imread( % img = rgb2gray(img); % fimg = medfilt2(img,[15 15]); % imshow(fimg,[])
% img = zeros(100); img(25,65) = 1; % figure imshow(img); % [x,y] = find(img); hold on % plot(x,y, % % plot(y,x,
m(1:2,1:2) = 1; % m(2,:) = ones(3,1); % m(:) = 1:9; %
>> m = magic(4); % >> id = logical([1 1 0 1 0]) id = 1 1 0 1 0 >> m(id,:) % ans = 16 2 3 13 5 11 10 8 4 14 15 1 % >> id = logical([1 1 0]) id = 1 1 0 >> m(id,:) % ans = 16 2 3 13 5 11 10 8
function allAreTrue = my_all(inArray) allAreTrue = true; N = numel(inArray); index = 1; while allAreTrue && (index <= N) allAreTrue = (inArray(index) ~= 0); index = index + 1; end end
M = magic(4) M = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1 det(M) ans = -1.4495e-12
[L,U,P] = lu(M) L = 1 0 0 0 0.25 1 0 0 0.3125 0.76852 1 0 0.5625 0.43519 1 1 U = 16 2 3 13 0 13.5 14.25 -2.25 0 0 -1.8889 5.6667 0 0 0 3.5527e-15 P = 1 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0
cond(M) ans = 8.148e+16 cond(.0001*eye(100)) ans = 1
rcond(M) ans = 1.3061e-17 rcond(.0001*eye(100)) ans = 1
m = randn(4); cond(m) %Well conditioned, usually in the 10 m = diag([1e-6 1 2 1e6]); cond(m) %Less well conditioned, 1e12 m = diag([0 1 2 3]); cond(m) %Singular: Inf
% figure, set(gcf, Z = peaks; surf(Z); axis tight set(gca, % nFrames = 20; mov(1:nFrames) = struct( % for k=1:nFrames surf(sin(2*pi*k/20)*Z, Z) mov(k) = getframe(gca); end close(gcf) % movie2avi(mov, winopen(
% figure, set(gcf, Z = peaks; surf(Z); axis tight set(gca, % nFrames = 20; aviobj = avifile( % for k=1:nFrames surf(sin(2*pi*k/20)*Z, Z) aviobj = addframe(aviobj, getframe(gca)); end close(gcf) % aviobj = close(aviobj); winopen(
% figure, set(gcf, Z = peaks; surf(Z); axis tight set(gca, % nFrames = 20; vidObj = VideoWriter( vidObj.Quality = 100; vidObj.FrameRate = 10; open(vidObj); % for k=1:nFrames surf(sin(2*pi*k/20)*Z, Z) writeVideo(vidObj, getframe(gca)); end close(gcf) % close(vidObj); winopen(
% figure, set(gcf, Z = peaks; surf(Z); axis tight set(gca, % nFrames = 20; f = getframe(gca); [f,map] = rgb2ind(f.cdata, 256, mov = repmat(f, [1 1 1 nFrames]); % for k=1:nFrames surf(sin(2*pi*k/20)*Z, Z) f = getframe(gca); mov(:,:,1,k) = rgb2ind(f.cdata, map, end close(gcf) % imwrite(mov, map, winopen(
for ii=1:100 plot(something(ii)) F = getframe; end movie(F)
% Prepare new movie file using the default PNG compression movObj = QTWriter( % Create an animation hf = figure; Z = peaks; surfc(Z); frames = 100; axis tight; set(hf, set(gca, % Animate plot and write movie for k = 0:frames hs = surfc(sin(2*pi*k/frames)*Z,Z); set(hs, light( movObj.FrameRate = k; % Vary the frame-rate writeMovie(movObj,getframe(hf)); % Write each frame to the file end movObj.Loop = close(movObj); % Finish writing movie and close file
function [x, y, dt] = simple_polygon(numSides) if numSides < 3 x = []; y = []; dt = DelaunayTri(); return end oldState = warning( fudge = ceil(numSides/10); x = rand(numSides+fudge, 1); y = rand(numSides+fudge, 1); dt = DelaunayTri(x, y); boundaryEdges = freeBoundary(dt); numEdges = size(boundaryEdges, 1); while numEdges ~= numSides if numEdges > numSides triIndex = vertexAttachments(dt, boundaryEdges(:,1)); triIndex = triIndex(randperm(numel(triIndex))); keep = (cellfun( end if (numEdges < numSides) || all(keep) triIndex = edgeAttachments(dt, boundaryEdges); triIndex = triIndex(randperm(numel(triIndex))); triPoints = dt([triIndex{:}], :); keep = all(ismember(triPoints, boundaryEdges(:,1)), 2); end if all(keep) warning( break end triPoints = dt.Triangulation; triPoints(triIndex{find(~keep, 1)}, :) = []; dt = TriRep(triPoints, x, y); boundaryEdges = freeBoundary(dt); numEdges = size(boundaryEdges, 1); end boundaryEdges = [boundaryEdges(:,1); boundaryEdges(1,1)]; x = dt.X(boundaryEdges, 1); y = dt.X(boundaryEdges, 2); warning(oldState); end
import math, random def generatePolygon( ctrX, ctrY, aveRadius, irregularity, spikeyness, numVerts ) : then creates the polygon by sampling points on a circle around the centre. Randon noise is added by varying the angular spacing between sequential points, and by varying the radial distance of each point from the centre. Params: ctrX, ctrY - coordinates of the "centre" of the polygon aveRadius - in px, the average radius of this polygon, this roughly controls how large the polygon is, really only useful for order of magnitude. irregularity - [0,1] indicating how much variance there is in the angular spacing of vertices. [0,1] will map to [0, 2pi/numberOfVerts] spikeyness - [0,1] indicating how much variance there is in each vertex from the circle of radius aveRadius. [0,1] will map to [0, aveRadius] numVerts - self-explanatory Returns a list of vertices, in CCW order. irregularity = clip( irregularity, 0,1 ) * 2*math.pi / numVerts spikeyness = clip( spikeyness, 0,1 ) * aveRadius angleSteps = [] lower = (2*math.pi / numVerts) - irregularity upper = (2*math.pi / numVerts) + irregularity sum = 0 for i in range(numVerts) : tmp = random.uniform(lower, upper) angleSteps.append( tmp ) sum = sum + tmp k = sum / (2*math.pi) for i in range(numVerts) : angleSteps[i] = angleSteps[i] / k points = [] angle = random.uniform(0, 2*math.pi) for i in range(numVerts) : r_i = clip( random.gauss(aveRadius, spikeyness), 0, 2*aveRadius ) x = ctrX + r_i*math.cos(angle) y = ctrY + r_i*math.sin(angle) points.append( (int(x),int(y)) ) angle = angle + angleSteps[i] return points def clip(x, min, max) : if( min > max ) : return x elif( x < min ) : return min elif( x > max ) : return max else : return x
verts = generatePolygon( ctrX=250, ctrY=250, aveRadius=100, irregularity=0.35, spikeyness=0.2, numVerts=16 ) black = (0,0,0) white=(255,255,255) im = Image.new( imPxAccess = im.load() draw = ImageDraw.Draw(im) tupVerts = map(tuple,verts) draw.polygon( tupVerts, outline=black,fill=white ) draw.line( tupVerts+[tupVerts[0]], width=2, fill=black ) im.show()
function CreateRandomPoly() figure(); colors = { for i=1:5 [x,y]=CreatePoly(); c = colors{ mod(i-1,numel(colors))+1}; plotc(x,y,c); hold on; end end function [x,y]=CreatePoly() numOfPoints = randi(30); theta = randi(360,[1 numOfPoints]); theta = theta * pi / 180; theta = sort(theta); rho = randi(200,size(theta)); [x,y] = pol2cart(theta,rho); xCenter = randi([-1000 1000]); yCenter = randi([-1000 1000]); x = x + xCenter; y = y + yCenter; end function plotc(x,y,varargin) x = [x(:) ; x(1)]; y = [y(:) ; y(1)]; plot(x,y,varargin{:}) end
function [points] = generatePolygon(ctrX, ctrY, aveRadius, irregularity, spikeyness, numVerts) %{ Start with the centre of the polygon at ctrX, ctrY, then creates the polygon by sampling points on a circle around the centre. Randon noise is added by varying the angular spacing between sequential points, and by varying the radial distance of each point from the centre. Params: ctrX, ctrY - coordinates of the "centre" of the polygon aveRadius - in px, the average radius of this polygon, this roughly controls how large the polygon is, really only useful for order of magnitude. irregularity - [0,1] indicating how much variance there is in the angular spacing of vertices. [0,1] will map to [0, 2pi/numberOfVerts] spikeyness - [0,1] indicating how much variance there is in each vertex from the circle of radius aveRadius. [0,1] will map to [0, aveRadius] numVerts - self-explanatory Returns a list of vertices, in CCW order. Website: https: %} irregularity = clip( irregularity, 0,1 ) * 2*pi/ numVerts; spikeyness = clip( spikeyness, 0,1 ) * aveRadius; % generate n angle steps angleSteps = []; lower = (2*pi / numVerts) - irregularity; upper = (2*pi / numVerts) + irregularity; sum = 0; for i =1:numVerts tmp = unifrnd(lower, upper); angleSteps(i) = tmp; sum = sum + tmp; end % normalize the steps so that point 0 and point n+1 are the same k = sum / (2*pi); for i =1:numVerts angleSteps(i) = angleSteps(i) / k; end % now generate the points points = []; angle = unifrnd(0, 2*pi); for i =1:numVerts r_i = clip( normrnd(aveRadius, spikeyness), 0, 2*aveRadius); x = ctrX + r_i* cos(angle); y = ctrY + r_i* sin(angle); points(i,:)= [(x),(y)]; angle = angle + angleSteps(i); end end function value = clip(x, min, max) if( min > max ); value = x; return; end if( x < min ) ; value = min; return; end if( x > max ) ; value = max; return; end value = x; end
>> A = [12 25 34 466 55] A = 12 25 34 466 55 >> arrayfun(@num2str, A, ans =
gca.Children=gca.Children([2:end 1]); % Put the topmost graphic in the bottom gca.Children=gca.Children([end:-1:1]); % Flip the stack gca.Children=gca.Children([1:N-1 N+1:end N]); % Put Nth graphics ontop the stack
Structure(1).a = 7 Structure(1).b = 3 Structure(2).a = 2 Structure(2).b = 6 Structure(3).a = 1 Structure(3).b = 6 ... ... (thousands more) ... Structure(2345).a = 4 Structure(2345).b = 9
>> S(1).a = 7; S(1).b = 3; S(2).a = 2; S(2).b = 6; S(3).a = 1; S(3).b = []; S(4).a = 1; S(4).b = 6; >> find( cellfun(@(x)isequal(x,6),{S.b}) ) ans = 2 4
% Set up test N = 1e5; S(N).b = []; for ii = 1:N S(ii).b = randi(6); end % Rody Oldenhuis 1 tic sol1 = find( cellfun(@(x)isequal(x,6),{S.b}) ); toc % EitanT 1 tic sol2 = find([S.b] == 6); toc % EitanT 2 tic str = sprintf( values = textscan(str, sol3 = find(values{:} == 6); toc % Rody Oldenhuis 2 tic ids = false(N,1); for ii = 1:N ids(ii) = isequal(S(ii).b, 6); end sol4 = find(ids); toc % Rody Oldenhuis 3 tic idx = false(size(S)); SS = {S.b}; inds = ~cellfun( idx(inds) = [SS{inds}]==6; sol5 = find(idx); toc % make sure they are all equal all(sol1(:)==sol2(:)) all(sol1(:)==sol3(:)) all(sol1(:)==sol4(:)) all(sol1(:)==sol5(:))
Elapsed time is 28.990076 seconds. % Rody Oldenhuis 1 (cellfun) Elapsed time is 0.119165 seconds. % EitanT 1 (no empties) Elapsed time is 22.430720 seconds. % EitanT 2 (string manipulation) Elapsed time is 0.706631 seconds. % Rody Oldenhuis 2 (loop) Elapsed time is 0.207165 seconds. % Rody Oldenhuis 3 (vectorized) ans = 1 ans = 1 ans = 1 ans = 1
Elapsed time is 0.572098 seconds. % cellfun Elapsed time is 0.119557 seconds. % no emtpties Elapsed time is 0.220903 seconds. % string manipulation Elapsed time is 0.107345 seconds. % loop Elapsed time is 0.180842 seconds. % cellfun-with-string
B = cell(1, 4); B{1,1} = 10; B{1,2} = 20; B{1,3} = 30; B{1,4} = 40;
function [ out ] = iif( condition, thenF, elseF, in, out) %iif Implements the ternary ?: operator % out = iif (@condition, @thenF, @elseF, in[, out]) % % The result is equivalent to: % condition(x) ? thenF(x) : elseF(x) % % The optional argument out serves as a template, if the output type is % different from the input type, e.g. for mapping arrays to cells and % vice versa. % % This code is in the public domain. mask = condition(in); if nargin <= 4 out = in; end if sum(mask) out(mask) = thenF(in(mask)); end if sum(~mask) out(~mask) = elseF(in(~mask)); end end
a = [1, 2, 5, 7, 6, 9, 8, 3, 4, 7, 0]; b = [5, 9, 6];
for i = 1:length(b) index = find(a == b(i)); c = [c, index(1)] end
a = [1, 2, 5, 7, 6, 9, 8, 3, 4, 7, 0, 6]; b = [5, 9, 6]; [~,c] = ismember(b,a, >> c c = 3 6 5
[tf,loc] = ismember(a,b); tf = find(tf); [~,idx] = unique(loc(tf), c = tf(idx);
a = [1, 2, 5, 7, 6, 9, 8, 3, 4, 7, 0, 6]; b = [5, 9, 6]; [r c]=find(bsxfun(@eq,a,b [~,ia,~]=unique(c, >> r(ia) ans = 3 6 5
a = [1, 2, 5, 7, 6, 9, 8, 3, 4, 7, 0]; b = [5, 9, 6]; c = dsearchn(a
[valid, result] = max(bsxfun(@eq, a(:), b(:). result = result(valid); %
>> a=java.util.LinkedList; >> li=a.listIterator; >> li.add(2); >> li.add(int8(77)); >> li.add(77); >> li.add(boolean(true)); >> li.add( >> li.previous(); >> li.add([1 2 3 4 5]); >> a a = [2.0, 77, 77.0, true, [D@66a917, Mr. Bill] >> a.get(4) ans = 1 2 3 4 5
function listObject = linked_list(values) data = reshape(values,1,[]); listObject = struct( function display_list % disp(data); end function add_element(values,index) % % index = min(index,numel(data)); data = [data(1:index) reshape(values,1,[]) data(index+1:end)]; end function delete_element(index) % data(index) = []; end end
>> listObj = linked_list([1 2 3]); % >> listObj.display() % 1 2 3
>> listObj.addAfter(4,2) % >> listObj.display() 1 2 4 3
classdef Node < handle properties next prev value end methods function this = Node(inVal) this.value = inVal; end end end
classdef LinkedList < handle properties firstNode lastNode end methods function this = LinkedList(newNode) % Initialize LinkedList with newNode this.firstNode = newNode; this.lastNode = newNode; end function addNode(this,newNode) % Add newNode to the end of the list newNode.prev = this.lastNode; this.lastNode.next = newNode; this.lastNode = newNode; end end end
function listObject = listfuncs() data = cell(0); listObject = struct( function display_list % disp(data); end function N = listlength % N = length(data); end function add_firstelement(datain) % data = [datain;data]; end function add_firstelements(datain) % data = [datain(:);data]; end function add_lasttelement(datain) % data = [data;datain]; end function add_lasttelements(datain) % data = [data;datain(:)]; end function add_element(datain,index) % % index = min(index,numel(data)); data = [data(1:index) datain data(index+1:end)]; end function add_elements(datain,index) % % index = min(index,numel(data)); data = [data(1:index) datain(:) data(index+1:end)]; end function set_element(datain,index) % data{index} = datain; end function delete_element(index) % if (index<=length(data) && index>0) data(index) = []; end end function delete_first() % data = data(2:end); end function delete_last() % data = data(1:end-1); end function dataout = GET_first() % dataout = data{1}; end function dataout = GET_last() % dataout = data{end}; end function dataout = GET(index) % dataout = cell2mat(data(index)); end end
[A,B,C] = size(X); Z = cellfun(@(x) x*Y,mat2cell(X,A,B,ones(1,C)),
A = 2; B = 3; C = 4; D = 5; X = rand(A,B,C); Y = rand(B,D); % Z = reshape(reshape(permute(X, [2 1 3]), [A B*C]), [B A*C]) % Z = permute(reshape(Z
Z(:,:,1) = ZZ(1:2, :); Z(:,:,2) = ZZ(3:4, :); Z(:,:,3) = ZZ(5:6, :); Z(:,:,4) = ZZ(7:8, :);
% generate data A = 20; B = 30; C = 40; D = 50; X = rand(A,B,C); Y = rand(B,D); % ------ Approach 1: Loop (via @Zaid) tic Z1 = zeros(A,D,C); for m = 1:C Z1(:,:,m) = X(:,:,m)*Y; end toc % ------ Approach 2: Reshape+Permute (via @Amro) tic Z2 = reshape(reshape(permute(X, [2 1 3]), [A B*C]), [B A*C]) Z2 = permute(reshape(Z2 toc % ------ Approach 3: cellfun (via @gnovice) tic Z3 = cellfun(@(x) x*Y,num2cell(X,[1 2]), Z3 = cat(3,Z3{:}); toc
Elapsed time is 0.000418 seconds. Elapsed time is 0.000887 seconds. Elapsed time is 0.001841 seconds.
% pretty big data... A = 200; B = 300; C = 400; D = 500; Elapsed time is 0.373831 seconds. Elapsed time is 0.638041 seconds. Elapsed time is 0.724581 seconds. % even bigger.... A = 200; B = 200; C = 400; D = 5000; Elapsed time is 4.314076 seconds. Elapsed time is 11.553289 seconds. Elapsed time is 5.233725 seconds.
A = 2; B = 3; C = 400000; D = 5; Elapsed time is 0.780933 seconds. Elapsed time is 0.073189 seconds. Elapsed time is 2.590697 seconds.
nT = 100; t = 2*pi*linspace (0,1,nT)’; signals = zeros(nT,3,2); signals(:,:,1) = [sin(2*t) cos(2*t) sin(4*t).^2]; signals(:,:,2) = [sin(2*t+pi/4) cos(2*t+pi/4) sin(4*t+pi/6).^2]; sT(:,:,1) = signals(:,:,1)’; sT(:,:,2) = signals(:,:,2)’; G = ndmult (signals,sT,[1 2]);
function M = ndmult (A,B,dim) dA = dim(1); dB = dim(2); sA = size (A); nA = length (sA); perA = [1:(dA-1) (dA+1):(nA-1) nA dA](1:nA); Ap = permute (A, perA); Ap = reshape (Ap, prod (sA(perA(1:end-1))), sA(perA(end))); sB = size (B); nB = length (sB); perB = [dB 1:(dB-1) (dB+1):(nB-1) nB](1:nB); Bp = permute (B, perB); Bp = reshape (Bp, sB(perB(1)), prod (sB(perB(2:end)))); M = Ap * Bp; s = [sA(perA(1:end-1)) sB(perB(2:end))]; M = squeeze (reshape (M, s)); endfunction
function myGui fig = figure(...); % h is a struct that contains handles to all the ui objects to be instantiated. My convention is to have the first field be the uicontrol type I h = struct([]); draw_gui; set_callbacks; % Basically a bunch of set(h.(...), %% DRAW FUNCTIONS function draw_gui h.Panel.Panel1 = uipanel(... ...); h.Panel.Panel2 = uipanel(... ...); draw_panel1; draw_panel2; function draw_panel1 h.Edit.Panel1.thing1 = uicontrol( end function draw_panel2 h.Edit.Panel2.thing1 = uicontrol( end end %% CALLBACK FUNCTIONS % Setting/getting application data is done by set/getappdata(fig, end
classdef Model < handle %MODEL represents a signal composed of two components + white noise % with sampling frequency FS defined over t=[0,1] as: % y(t) = a * sin(2pi * f*t) + sin(2pi * 2*f*t) + white_noise % observable properties, listeners are notified on change properties (SetObservable = true) f % frequency components in Hz a % amplitude end % read-only properties properties (SetAccess = private) fs % sampling frequency (Hz) t % time vector (seconds) noise % noise component end % computable dependent property properties (Dependent = true, SetAccess = private) data % signal values end methods function obj = Model(fs, f, a) % constructor if nargin < 3, a = 1.2; end if nargin < 2, f = 5; end if nargin < 1, fs = 100; end obj.fs = fs; obj.f = f; obj.a = a; % 1 time unit with obj.t = 0 : 1/obj.fs : 1-(1/obj.fs); obj.noise = 0.2 * obj.a * rand(size(obj.t)); end function y = get.data(obj) % signal data y = obj.a * sin(2*pi * obj.f*obj.t) + ... sin(2*pi * 2*obj.f*obj.t) + obj.noise; end end % business logic methods function [mx,freq] = computePowerSpectrum(obj) num = numel(obj.t); nfft = 2^(nextpow2(num)); % frequencies vector (symmetric one-sided) numUniquePts = ceil((nfft+1)/2); freq = (0:numUniquePts-1)*obj.fs/nfft; % compute FFT fftx = fft(obj.data, nfft); % calculate magnitude mx = abs(fftx(1:numUniquePts)).^2 / num; if rem(nfft, 2) mx(2:end) = mx(2:end)*2; else mx(2:end -1) = mx(2:end -1)*2; end end end end
function handles = View_TimeDomain(m) %VIEW a GUI representation of the signal model % build the GUI handles = initGUI(); onChangedF(handles, m); % populate with initial values % observe on model changes and update view accordingly % (tie listener to model object lifecycle) addlistener(m, @(o,e) onChangedF(handles,e.AffectedObject)); end function handles = initGUI() % initialize GUI controls hFig = figure( hAx = axes( hSlid = uicontrol( hLine = line( % define a color property specific to the view hMenu = uicontextmenu; hMenuItem = zeros(3,1); hMenuItem(1) = uimenu(hMenu, hMenuItem(2) = uimenu(hMenu, hMenuItem(3) = uimenu(hMenu, set(hLine, % customize xlabel(hAx, ylabel(hAx, title(hAx, % return a structure of GUI handles handles = struct( end function onChangedF(handles,model) % respond to model changes by updating view if ~ishghandle(handles.fig), return, end set(handles.line, set(handles.slider, end
function handles = View_FrequencyDomain(m) handles = initGUI(); onChangedF(handles, m); hl = event.proplistener(m, findprop(m, @(o,e) onChangedF(handles,e.AffectedObject)); setappdata(handles.fig, end function handles = initGUI() % load FIG file (its really a MAT-file) hFig = hgload( %S = load( % extract handles to GUI components hAx = findobj(hFig, hSlid = findobj(hFig, hTxt = findobj(hFig, hMenu = findobj(hFig, hMenuItem = findobj(hFig, % initialize line and hook up context menu hLine = line( set(hLine, % customize xlabel(hAx, ylabel(hAx, title(hAx, % return a structure of GUI handles handles = struct( end function onChangedF(handles,model) [mx,freq] = model.computePowerSpectrum(); set(handles.line, set(handles.slider, set(handles.txt, end
function [m,v1,v2] = Controller %CONTROLLER main program % controller knows about model and view m = Model(100); % model is independent v1 = View_TimeDomain(m); % view has a reference of model % we can have multiple simultaneous views of the same data v2 = View_FrequencyDomain(m); % hook up and respond to views events set(v1.slider, set(v2.slider, set(v1.menu, set(v2.menu, % simulate some change pause(3) m.f = 10; end function onSlide(o,~,model) % update model (which in turn trigger event that updates view) model.f = get(o, end function onChangeColor(o,~,handles) % update view clr = get(o, set(handles.line, set(handles.menu, set(o, end
function pushbutton17_callback(hObject,evt, handles) some_text = someOtherFunction(); set(handles.text45, end
handles.panel17 = uipanel(...); createTable(handles.panel17); % creates a table in the specified panel
uigetfile % or uigetdir if you need every file in a directory
figure; for c=1:15 subplot(5,3,c); imagesc(reshape(image(:,c), 360,480)), ;colormap gray; axis image; end
fpass=[0.05 0.2];% fstop=[0.045 0.205]; % Rpass=1;% Astop=40;% n=cheb2ord(fpass,fstop,Rpass,Astop);% [b,a]=cheby2(n,Astop,fstop);
[z,p,k]=cheby2(n,Astop,fstop); [s,g]=zp2sos(z,p,k);% Hd=dfilt.df2sos(s,g);%
* Make a copy of the signal * Smooth it. For a 100KHz signal and wanting to eliminate about 10Hz on down, you * Subtract the smoothed version from the original. Baseline drift will be gone.
dd = loadjson( dd = 1×3 cell array {["Titi"]} {["Toto"]} {["Tata"]}
cellfun(@isstring, test) ans = 2×3 logical array 0 1 0 0 0 1
test = { ind = cellfun(@isstring, test); % indexing for string type items test(ind) = cellstr(test(ind)) % char-ify the strings!
% rapid ind = cellfun( % akin to looping ind = cellfun(@isstring, test);
% Create large test array of random strings c = cell(100,1000); c = cellfun(@(x) string(char(randi([65,122],1,10))), c, % Create functions for benchmarking f=@()cellfun( g=@()cellfun(@isstring,c); % Timing on MATLAB R2017b timeit( f ) % >> 0.017sec timeit( g ) % >> 0.066sec
test = { ind = cellfun(@isstring, test); test(ind) = cellfun(@char, test(ind),
test = { fixed_test = controllib.internal.util.hString2Char(test); fixed_test = 2×3 cell array { {
test = {"target1", struct( ft = controllib.internal.util.hString2Char(test); {ft{2}.field} ans = 1×3 cell array {[123]} {
main.m: x=[0 0.2 0.4 0.6 0.8 1.0]; y=[0 0.2 0.4 0.6 0.8 1.0]; func2(x,y, func 2.m : function t =func2(x, y, z, t= func(x,y,z); func2eq.m: function z= func2eq(x,y) z= x + sin(pi * x)* exp(y);
... func2(x, y, @func2eq); % The "@" operator creates a "function handle"
function t = func2(x, y, fcnHandle) t = fcnHandle(x, y); end
function t = func2(x, y, funcName) % no quotes around funcName func = str2func(funcName) t = func(x, y) end
% start of my code: create function handles % to the functions I need: try cd Map map1_func = @map1; catch mexception end cd ..
classdef testprop properties numRequests=0; end methods function Request(this, val) disp(val); this.numRequests=this.numRequests+1; end end end
>> a=testprop; >> a.Request(9); >> a.Request(5); >> a.numRequests ans = 0
>> a=testprop >> a.Request(5); % will NOT change the value of a.numRequests. 5 >> a.Request(5) 5 >> a.numRequests ans = 0 >> a=a.Request; % However, this will work but as you it makes a copy of variable, a. 5 >> a=a.Request; 5 >> a.numRequests ans = 2
>> a.Request(5); >> a.Request(5); >> a.numRequests ans = 2
>> a = testprop; >> a = a.Request(1); >> a.numRequests ans = 1
>> fid = fopen( >> [x, x, x, enc] = fopen(fid); enc enc = UTF-8 >> tbl = textscan(fid, >> tbl{1}{1} ans = ÎÎÎÎÎÎ Î£Î¦Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾ÏÏÏÏÏÏÏÏÏÏ >>
% fid = fopen( b = fread(fid, fclose(fid); % str = native2unicode(b,
>> double(str) ans = Columns 1 through 13 915 916 920 923 926 928 931 934 937 945 946 947 948 Columns 14 through 26 949 950 951 952 953 954 955 956 957 958 960 961 962 Columns 27 through 35 963 964 965 966 967 968 969 13 10
% label = javax.swing.JLabel(); label.setFont( java.awt.Font( label.setText(str); f = javax.swing.JFrame( f.getContentPane().add(label); f.pack(); f.setVisible(true);
>> str str = ΓΔΘΛΞΠΣΦΩαβγδεζηθικλμνξπρςστυφχψω >> disp(str) Î“Î”Î˜Î›ÎžÎ Î£Î¦Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰
<locale name="de_DE" encoding="ISO-8859-1" xpg_name="de_DE.ISO8859-1">
<locale name="de_DE" encoding="UTF-8" xpg_name="de_DE.UTF-8">
<codeset> <encoding name="UTF-8"> <encoding_alias name="windows-1252" /> </encoding> </codeset>
>> x = [1,2,3]; >> x(1:end-1) ans = 1 2 >> x(end+1) = 4 x = 1 2 3 4
classdef IndexDisplayer methods function subsref(self, s) disp(s); end end end
>> a = IndexDisplayer; >> a(1:3) type: subs: {[1 2 3]} >> a(:) type: subs: {
classdef IndexDisplayer methods function subsref(self, s) disp(s); end function len = length(self) len = 10; end end end
>> a = IndexDisplayer; >> length(a) ans = 10 >> a(end) type: subs: {[1]}
classdef IndexDisplayer methods function ind = end(self,k,n) disp(k) disp(n) ind = builtin( end end end >> a = IndexDisplayer; >> a(1,end,1) 2 3
a = [1 2 3]; b = rand(7,3); c(:,1) = b(:,1) - a(1); c(:,2) = b(:,2) - a(2); c(:,3) = b(:,3) - a(3);
c(:,1) = b(:,1) - a(1); c(:,2) = b(:,2) - a(2); c(:,3) = b(:,3) - a(3);
n = 1e6; m = 3; iter = 100; a = rand(1,m); b = rand(n,m); tic c = zeros(size(b)); for i = 1:iter c(:,1) = b(:,1) - a(1); c(:,2) = b(:,2) - a(2); c(:,3) = b(:,3) - a(3); end toc tic c = zeros(size(b)); for i = 1:iter c(:,1) = b(:,1) - a(1); c(:,2) = b(:,2) - a(2); c(:,3) = b(:,3) - a(3); end toc tic c = zeros(size(b)); for i = 1:iter for j = 1:3 c(:,j) = b(:,j) - a(j); end end toc tic for i = 1:iter c = b-repmat(a,size(b,1),1); end toc tic for i = 1:iter c = bsxfun(@minus,b,a); end toc tic c = zeros(size(b)); for i = 1:iter for j = 1:size(b,1) c(j,:) = b(j,:) - a; end end toc
Elapsed time is 0.622730 seconds. Elapsed time is 0.627321 seconds. Elapsed time is 0.713384 seconds. Elapsed time is 2.621642 seconds. Elapsed time is 1.323490 seconds. Elapsed time is 17.269901 seconds.
tic for i = 1:10000 c = zeros(size(b)); b = rand(7,3); c = b - ones(size(b))*diag(a); end toc
N_arr = 15:5:100; % N_arr = 50:40:1000; % N_arr = 200:400:3800; % timeall = zeros(2,numel(N_arr)); for k1 = 1:numel(N_arr) A = round(rand(N_arr(k1))*20); f = @() ~A; timeall(1,k1) = timeit(f); clear f f = @() A==0; timeall(2,k1) = timeit(f); clear f end
N_arr = 200:400:3800; % for k1 = 1:numel(N_arr) A = randi(1,N_arr(k1)); [~]=eq(A,0); clear A A = randi(1,N_arr(k1)); [~]=not(A); clear A end
%~ Logical NOT. % ~A performs a logical NOT of input array A, and returns an array % containing elements set to either logical 1 (TRUE) or logical 0 (FALSE). % An element of the output array is set to 1 if A contains a zero value % element at that same array location. Otherwise, that element is set to % 0. % % B = NOT(A) is called for the syntax % % ~ can also be used to ignore input arguments in a function definition, % and output arguments in a function call. See "help punct" % Copyright 1984-2005 The MathWorks, Inc.
%== Equal. % A == B does element by element comparisons between A and B % and returns a matrix of the same size with elements set to logical 1 % where the relation is true and elements set to logical 0 where it is % not. A and B must have the same dimensions unless one is a % scalar. A scalar can be compared with any size array. % % C = EQ(A,B) is called for the syntax % object. % Copyright 1984-2005 The MathWorks, Inc.
clear all clear classes array_sizes = [1000:1000:10000]; repetitions = 10000; for i = 1:length(array_sizes) A1 = randi([0, 1], array_sizes(i), 1); for j = 1:repetitions tmp1 = eq(A1, 0); end end for i = 1:length(array_sizes) A2 = randi([0, 1], array_sizes(i), 1); for j = 1:repetitions tmp2 = not(A2); end end
while (....) ..... new_row =[x y] ; % new row with values x & y mat = [mat ; new_row];
BLOCK_SIZE = 2000; % initial capacity (& increment size) listSize = BLOCK_SIZE; % current list capacity list = zeros(listSize, 2); % actual list listPtr = 1; % pointer to last free position while rand<1-1e-5 % (around 1e5 iterations on avrg) % push items on list list(listPtr,:) = [rand rand]; % store new item listPtr = listPtr + 1; % increment position pointer % add new block of memory if needed if( listPtr+(BLOCK_SIZE/10) > listSize ) % less than 10%*BLOCK_SIZE free slots listSize = listSize + BLOCK_SIZE; % add new BLOCK_SIZE slots list(listPtr+1:listSize,:) = 0; end end list(listPtr:end,:) = []; % remove unused slots
Matrix = []; while size(Matrix,1) <= 10 Matrix = [Matrix;rand(1,2)]; end disp(Matrix);
% Allocate space using the upper bound of rows (20) Matrix = zeros(20,2); k = 1; for k = 1:10 Matrix(k,:) = rand(1,2); end % Remove the rest of the dummy rows Matrix(k+1:end,:) = [];
for counter = 1:10 Matrix(counter,:) = rand(1,2); end disp(Matrix);
r = rand; prob = [0.5, 0.1, 0.4]; x = sum(r >= cumsum([0, prob]));
r = rand(3); % x = arrayfun(@(z)sum(z >= cumsum([0, prob])), r);
% assume n = numel(prob) is large and sum(prob) == 1 r = rand(m,1); [~,x] = histc(r,cumsum([0,prob]));
>> c = cumsum([0.5, 0.1, 0.4]); >> r = rand(1e5, 1); >> x = arrayfun(@(x) find(x <= c, 1, >> h = hist(x, 1:3) h = 49953 10047 40000
r=rand; prob=[.5,.1,.4]; prob=cumsum(prob); value=[1,2,3]; %values corresponding to the probabilities ind=find(r<=prob,1, x=value(ind)
pmf = [0.5, 0.1, 0.4]; population = 1:3; sample_size = 1; random_number = randsample(population,sample_size,true,pmf);
100 200 300 400 500 600 1 2 3 4 5 6 10 20 30 40 50 60 ...
100 100 100 100 100 100 1 1 1 1 1 1 10 10 10 10 10 10 ...
M = [100 200 300 400 500 600 1 2 3 4 5 6 10 20 30 40 50 60]; % MM = bsxfun(@rdivide, M, M(2,:)); % MM = M ./ repmat(M(2,:),size(M,1),1); % MM = M ./ ( ones(size(M,1),1)*M(2,:) ); % MM = zeros(size(M)); for i=1:size(M,1) MM(i,:) = M(i,:) ./ M(2,:); end
mat = [100 200 300 400 500 600 1 2 3 4 5 6 10 20 30 40 50 60]; result = mat ./ mat(2,:)
result = 100 100 100 100 100 100 1 1 1 1 1 1 10 10 10 10 10 10
fi = @(varargin)varargin{length(varargin)-varargin{1}}
cond = what < ever; n = getfield([23,42], {1+(what < ever)}) % for any 1x1-data s = cell2mat(getfield({
>> y = { >> [~,index] = unique(y, >> y(sort(index)) % ans =
octave:6> 4 * 0 ans = 0 octave:7> 4 * -0 ans = -0 octave:8> 4 / 0 warning: division by zero ans = Inf octave:9> 4 / -0 warning: division by zero ans = -Inf
fc = 300; % Cut off frequency fs = 1000; % Sampling rate [b,a] = butter(6,fc/(fs/2)); % Butterworth filter of order 6 x = filter(b,a,signal); % Will be the filtered signal
> symbols > a = sym("a") a = a > b = sym("b") b = b > mat = [a,b] error: octave_base_value::resize (): wrong type argument `ex' error: octave_base_value::resize (): wrong type argument `<unknown type>' octave-3.2.3.exe:4:C:\Octave\3.2.3_gcc-4.4.0\bin
octave> syms Symbolic variables in current scope: a b
octave> mat = [a,b] mat = (sym) [a b] (1×2 matrix) octave:34> mat * 2 ans = (sym) [2⋅a 2⋅b] (1×2 matrix)
pkg load symbolic syms psi phi theta psidot phidot thetadot RzPsi = [[cos(psi), -sin(psi), 0]; [sin(psi), cos(psi), 0]; [0,0,1]] RyTheta = [[cos(theta), 0, sin(theta)];[0,1,0];[-sin(theta), 0, cos(theta)]] RzPhi = [[cos(phi), -sin(phi), 0]; [sin(phi), cos(phi), 0]; [0,0,1]] RzPsi = (sym 3×3 matrix) ⎡cos(ψ) -sin(ψ) 0⎤ ⎢ ⎥ ⎢sin(ψ) cos(ψ) 0⎥ ⎢ ⎥ ⎣ 0 0 1⎦ RyTheta = (sym 3×3 matrix) ⎡cos(θ) 0 sin(θ)⎤ ⎢ ⎥ ⎢ 0 1 0 ⎥ ⎢ ⎥ ⎣-sin(θ) 0 cos(θ)⎦ RzPhi = (sym 3×3 matrix) ⎡cos(φ) -sin(φ) 0⎤ ⎢ ⎥ ⎢sin(φ) cos(φ) 0⎥ ⎢ ⎥ ⎣ 0 0 1⎦ octave> RzPhi * RyTheta ans = (sym 3×3 matrix) ⎡cos(φ)⋅cos(θ) -sin(φ) sin(θ)⋅cos(φ)⎤ ⎢ ⎥ ⎢sin(φ)⋅cos(θ) cos(φ) sin(φ)⋅sin(θ)⎥ ⎢ ⎥ ⎣ -sin(θ) 0 cos(θ) ⎦
octave:1> symbols octave:2> q1 = sym("q1"); octave:3> differentiate(Sin(q1)*Cos(q1),q1) ans = -sin(q1)^2+cos(q1)^2
octave:6> -Sin(q1) error: unary operator `- octave:6> -q1 error: unary operator `-
disp("2-state markov chain symbolic analysis"); syms lambda mu L = [lambda,0] U = [1;0] C = [ [1,1]; [lambda,-mu]] C^-1 P = C^-1 * U # lambda_sys = L * C^-1 * U #
b(1,1).vector = @sin; b(1,2).vector = @cos; b(2,1).vector = @sec; b(2,2).vector = @csc; b b.vector printf( "\n\nCalling each element:\n" ) b(1,1).vector b(1,2).vector b(2,1).vector b(2,2).vector printf( "\nCalculatin the sin of 1:\n" ) b(1,1).vector(1)
b = 2x2 struct array containing the fields: vector ans = @sin ans = @sec ans = @cos ans = @csc Calling each element: ans = @sin ans = @cos ans = @sec ans = @csc Calculatin the sin of 1: ans = 0.841470984807897
pkg load symbolic; b(1,1).vector = sym("a"); b(1,2).vector = sym("b"); b(2,1).vector = sym("c"); b(2,2).vector = sym("d"); b b.vector printf( "\n\nCalling each element:\n" ) b(1,1).vector b(1,2).vector b(2,1).vector b(2,2).vector
b = 2x2 struct array containing the fields: vector ans = (sym) a ans = (sym) c ans = (sym) b ans = (sym) d Calling each element: ans = (sym) a ans = (sym) b ans = (sym) c ans = (sym) d
function exitcode = echo(a, b) display(a); display(b); exitcode = 0;
function rc = display_product(a, b) a = str2num(a); b = str2num(b); display(a*b); rc = 0;
function r=evalArguments(parser, arguments) % Evaluates parsed arguments % Given a parser containing parsed arguments, all string values of the % arguments specified by parameter "arguments" are evaluated % and the complete results is returned in a new struct. r = parser.Results; for j=1:length(arguments) argValue = r.(arguments{j}); if ischar(argValue) r.(arguments{j}) = eval(argValue); end end end
p = inputParser; p.addRequired( p.addRequired( p.addParameter( p.parse(arg1, arg2, varargin{:}); nonStringArguments = { args = evalArguments(p, nonStringArguments); ... x = args.arg1; y = args.arg2; z = args.optional1;
octave:5> A = [2 3 4]; octave:6> A = [A; 3 4 5] A = 2 3 4 3 4 5 octave:7> B = [4 5 6]; octave:8> B = vertcat(B,[5 6 7]) B = 4 5 6 5 6 7
octave:9> C = [6 7 8]; octave:10> C(end+1,:) = [7 8 9] C = 6 7 8 7 8 9
for t = [] % 1 end for t = ones(1, 0) % 2 end for t = ones(0, 1) % 3 end
for t = ones(0, 1) % size(t) % t is a 0x1 matrix end
function echo(varargin) str = for k=1:length(varargin) str = [str end disp(str)
fid = fopen( % fseek(fid, 0, fileSize = ftell(fid); frewind(fid); % data = fread(fid, fileSize, % numLines = sum(data == 10) + 1; fclose(fid);
Author Mean time +- standard deviation (s) ------------------------------------------------------ Rody Oldenhuis 0.3189 +- 0.0314 Edric (2) 0.3282 +- 0.0248 Mehrwolf 0.4075 +- 0.0178 Jonas 1.0813 +- 0.0665 Edric (1) 26.8825 +- 0.6790
function count = countLines(fname) fh = fopen(fname, assert(fh ~= -1, x = onCleanup(@() fclose(fh)); count = 0; while ischar(fgetl(fh)) count = count + 1; end end
function count = countLines(fname) fh = fopen(fname, assert(fh ~= -1, x = onCleanup(@() fclose(fh)); count = 0; while ~feof(fh) count = count + sum( fread( fh, 16384, end end
if (isunix) % [status, result] = system( [ numlines = str2num(result); elseif (ispc) % numlines = str2num( perl( else error( end
fid = fopen( allText = textscan(fid, numberOfLines = length(allText{1}); fclose(fid)
YourPC$ cloc <directory_path> 87 text files. 81 unique files. 23 files ignored. http: ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- MATLAB 59 1009 1074 4993 HTML 1 0 0 23 ------------------------------------------------------------------------------- SUM: 60 1009 1074 5016 -------------------------------------------------------------------------------
nRows = 10000; % number of rows nSample = 1000; % number of samples rndIDX = randperm(nRows); newSample = data(rndIDX(1:nSample), :);
nRows = 10000; % number of rows nSample = 1000; % number of samples rndIDX = randi(nRows, nSample, 1); newSample = data(rndIDX, :);
nrows = size(x,1); nrand = 1000; % Choose 1000 rows assert(nrand<=nrows, rand_rows = randperm(nrows, nrand); xx = x(rand_rows,:); % Select the random rows from x
rndIdx = randsample(size(data,1),1000,true); % with replacement subset = samples(rndIdx(1:1000), :); rndIdx = randsample(size(data,1),1000,false); % without replacement subset = samples(rndIdx(1:1000), :);
function out = varname(var) out = inputname(1); end
reshape(magic(3),[],2) ??? Error using ==> reshape Product of known dimensions, 2, not divisible into total number of elements, 9.
n = 4; V = [3;2;1;4]; M = sparse(V,1:n,1,n,n); M = (3,1) 1 (2,2) 1 (1,3) 1 (4,4) 1
n = 2000; V = randperm(n); M = sparse(V,1:n,1,n,n); FM = full(M); whos FM M Name Size Bytes Class Attributes FM 2000x2000 32000000 double M 2000x2000 48008 double sparse
A = magic(2000); tic,B = A*M;toc Elapsed time is 0.012803 seconds. tic,B = A*FM;toc Elapsed time is 0.560671 seconds.
vSize = size(V); Index = sparse(vSize(1),max(V)); for i = 1:vSize(1) Index(i, v(i)) = 1; end
input vector: [ 1 0 2 0 7 7 7 0 5 0 0 0 9 ] output vector: [ 1 1 2 2 7 7 7 7 5 5 5 5 9 ]
in = out = repmat([ 1 0 2 0 7 7 7 0 5 0 0 0 9 ] ,1 ,100000); tic; for i=2:length(out) if (out(i)==0) out(i)=out(i-1); endif; endfor; toc; [in(1:20); out(1:20)] Elapsed time is 15.047 seconds.
in = V = repmat([ 1 0 2 0 7 7 7 0 5 0 0 0 9 ] ,1 ,100000); tic; d = double(diff([0,V])>0); d(find(d(2:end))+1) = find(diff([0,~V])==-1) - find(diff([0,~V])==1); out = V(cumsum(~~V+d)-1); toc; [in(1:20); out(1:20)] Elapsed time is 0.188167 seconds.
in = a = repmat([ 1 0 2 0 7 7 7 0 5 0 0 0 9 ] ,1 ,100000); tic; pada = [a,888]; b = pada(find(pada >0)); bb = b(:,1:end-1); c = find (pada==0); d = find(pada>0); length = d(2:end) - (d(1:end-1)); t = accumarray(cumsum([1,length]) out = R = bb(cumsum(t(1:end-1))); toc; Elapsed time is 0.130558 seconds.
in = repmat([ 1 0 2 0 7 7 7 0 5 0 0 0 9 ] , 1, 100000); tic; out = nonzeros(in). toc; Elapsed time is 0.0597501 seconds.
in = [1 0 2 0 7 7 7 0 5 0 0 0 9]; t = cumsum(in~=0); u = nonzeros(in); out = u(t).
V = [1 0 2 0 7 7 7 0 5 0 0 0 9] % d = double(diff([0,V])>0) % d(find(d(2:end))+1) = find(diff([0,~V])==-1) - find(diff([0,~V])==1) % V(cumsum(~~V+d)-1)
a = [ 1 0 2 0 7 7 7 0 5 0 0 0 9 ] % pada = [a,888]; % b = pada(find(pada >0)); % bb = b(:,1:end-1); % c = find (pada==0); % d = find(pada>0); % length = d(2:end) - (d(1:end-1)); % % ----------EDIT--------- % t = accumarray(cumsum([1,length]) R = bb(cumsum(t(1:end-1)));
a = repmat([ 1 0 2 0 7 7 7 0 5 0 0 0 9 ] ,1,10000); % Arrayfun Method : Elapsed time is 6.840973 seconds. AccumArray Method : Elapsed time is 2.097432 seconds.
in = [1 0 2 0 7 7 7 0 5 0 0 0 9] mask = logical(in); idx = 1:numel(in); in(~mask) = interp1(idx(mask),in(mask),idx(~mask), %
F = griddedInterpolant(idx(mask),in(mask), in(~mask) = F(idx(~mask));
0.699347403200000 % 1.329058123200000 % 0.408333643200000 % 1.585014923200000 %
function [t] = bench() in = repmat([ 1 0 2 0 7 7 7 0 5 0 0 0 9 ] ,1 ,100000); % functions to compare fcns = { @() thewaywewalk(in); @() GameOfThrows(in); @() LuisMendo(in); @() Dan(in); }; % timeit t = zeros(4,1); for ii = 1:10; t = t + cellfun(@timeit, fcns); end format long end function in = thewaywewalk(in) mask = logical(in); idx = 1:numel(in); in(~mask) = interp1(idx(mask),in(mask),idx(~mask), end function out = GameOfThrows(a) pada = [a,888]; b = pada(find(pada >0)); bb = b(:,1:end-1); c = find (pada==0); d = find(pada>0); length = d(2:end) - (d(1:end-1)); t = accumarray(cumsum([1,length]) out = bb(cumsum(t(1:end-1))); end function out = LuisMendo(in) t = cumsum(in~=0); u = nonzeros(in); out = u(t). end function out = Dan(V) d = double(diff([0,V])>0); d(find(d(2:end))+1) = find(diff([0,~V])==-1) - find(diff([0,~V])==1); out = V(cumsum(~~V+d)-1); end
M = [fieldnames(A) [tmp, rows] = unique(M(1,:), M=M(:, rows); C=struct(M{:});
% struct with fields s = struct( s = color: count: 2
% struct with fields s2 = struct( s2 = count: 4 shape:
>> s = setstructfields(s,s2) s = color: count: 4 shape:
a.f1 = 1; a.f2 = 2; b.f2 = 3; b.f4 = 4; s = catstruct(a,b)
% SETDEFAULTS sets the default structure values % SOUT = SETDEFAULTS(S, SDEF) reproduces in S % all the structure fields, and their values, that exist in % SDEF that do not exist in S. % SOUT = SETDEFAULTS(S, SDEF, OVERRIDE) does % the same function as above, but if OVERRIDE is 1, % it copies all fields of SDEF to SOUT. function sout = setdefaults(s,sdef,override) if (not(exist( override = 0; end sout = s; for f = fieldnames(sdef)' cf = char(f); if (override | not(isfield(sout,cf))) sout = setfield(sout,cf,getfield(sdef,cf)); end end
% SETDEFAULTS2 sets the default structure values % SOUT = SETDEFAULTS(S, SDEF) reproduces in S % all the structure fields, and their values, that exist in % SDEF that do not exist in S. function sout = setdefaults2(s,sdef) sout = sdef; for f = fieldnames(s)' sout = setfield(sout,f{1},getfield(s,f{1})); end
>> S1 = struct( >> S2 = struct( >> setdefaults2(S1,S2) ans = b: 2 c: 3 d: 6 a: 1 >> setdefaults2(S2,S1) ans = a: 1 b: 4 c: 5 d: 6
for str = { fprintf( end ??? Error using ==> fprintf Function is not defined for
h = figure( a = axes( % render using `scatter3()` or other plot function. content = frame2im(getframe(h));
h = figure( a = axes( % render using `scatter3()` or other plot function. saveas(h, content = imread(/path/to/file.png
avi = avifile( figure_handle = figure( % ... for something = 1:1000 cla % (draw stuff...) avi = addframe(avi, figure_handle); end
hFig = figure( aviobj = avifile( for k=1:N % aviobj = addframe(aviobj, hFig); end aviobj = close(aviobj);
hFig = figure( set(hFig, aviobj = avifile( for k=1:N % print([ img = imread( aviobj = addframe(aviobj, im2frame(img)); end aviobj = close(aviobj);
hFig = figure( set(hFig, aviobj = avifile( for k=1:N % img = hardcopy(hFig, aviobj = addframe(aviobj, im2frame(img)); end aviobj = close(aviobj);
saveas [M-file] --> print [M-file] --> render [private M-file] --> hardcopy [P-file] hgexport [P-file] --> print [M-file] --> ... @avifile/addframe [M-file] --> hardcopy [P-file]
!start /B /MIN matlab -noFigureWindows -automation -r "cd(
hFig = figure( set(hFig, aviobj = VideoWriter( for k=1:N % img = hardcopy(hFig, writeVideo(aviobj, im2frame(img)); end close(aviobj);
function JpgSaveIssueDemo( ) figure( 1 ); t = 0:0.1:8; subplot( 2, 2, 1 ); plot( t, sin(t) ); title( subplot( 2, 2, 2 ); plot( t, sin(t) ); title( subplot( 2, 2, 3 ); plot( t, sin(t) ); title( subplot( 2, 2, 4 ); plot( t, sin(t) ); title( saveas( gcf, end
drawnow; jFrame = get(handle(gcf), jFrame.setMaximized(true);
unitSave = get(figureHandle, set(figureHandle, set(figureHandle, set(figureHandle,
h1=figure % create figure plot(t,Data, legend( % Create title with required font size title({ % Create xlabel with required font size xlabel({ % Create ylabel with required font size ylabel({ print(h1,
classdef myclass properties x_array = []; end methods function increment(obj,value) obj.x_array = [obj.x_array ; value); end end end
>>s = myclass >>increment(s,5) >>s.x_array ans = []
classdef myclass<handle properties x_array = [] end methods function obj=increment(obj,val) obj.x_array=[obj.x_array val]; end end end
>> s=myclass; >> s.increment(5) >> s.increment(6) >> s s = myclass handle properties: x_array: [5 6] lists of methods, events, superclasses
for s = some_cell_array s = s{1}; % unpeel the enclosing cell % do stuff with s end
some_cell_array = {1,2,3} for s = [some_cell_array{:}] % convert to array s end
%% Import own package [~, pkgdir] = fileparts(fileparts(mfilename( import([pkgdir(2:end)
%% Import own package try [~, pkgdir] = fileparts(fileparts(mfilename( import([pkgdir(2:end) catch err if ~strcmp(err.identifier, end
function to_eval = importthis(exclude_list) if nargin == 0 exclude_list = []; end var_name = genvarname( to_eval = [ , var_name... , , , var_name... , , , var_name ]; end
function B = myfunc(A) eval(importthis); %function body end
function B = myfunc(A) eval(importthis(who)); %function body end
%images is a 459 x 1 cell array where each cell contains the training image [locations, all_feats] = vl_dsift(single(images{1}), for i=2:(size(images,1)) [locations, feats] = vl_dsift(single(images{i}), all_feats = cat(2, all_feats, feats); %cat column wise all features end numClusters = 50; %Just a random selection. % Run KMeans to pre-cluster the data [initMeans, assignments] = vl_kmeans(single(all_feats), numClusters, ... initMeans = double(initMeans); %GMM needs it to be double % Find the initial means, covariances and priors for i=1:numClusters data_k = all_feats(:,assignments==i); initPriors(i) = size(data_k,2) / numClusters; if size(data_k,1) == 0 || size(data_k,2) == 0 initCovariances(:,i) = diag(cov(data else initCovariances(:,i) = double(diag(cov(double((data_k end end % Run EM starting from the given parameters [means,covariances,priors,ll,posteriors] = vl_gmm(double(all_feats), numClusters, ...
% create GMM mu = [0; 5]; sigma = cat(3, 1, 2); p = [0.5; 0.5]; gmm = gmdistribution(mu, sigma, p); % view PDF ezplot(@(x) pdf(gmm,x));
>> x = 0.5; >> posterior(gmm, x) ans = 0.9950 0.0050 % probability x came from each component
>> x = 2.2 >> posterior(gmm, 2.2) ans = 0.4717 0.5283
% first distribution is centered at (0,0), second at (-1,3) mu = [0 0; 3 3]; % covariance of first is identity matrix, second diagonal sigma = cat(3, eye(2), [5 0; 0 1]); % again I p = [0.5; 0.5]; % build GMM gmm = gmdistribution(mu, sigma, p); % 2D projection ezcontourf(@(x,y) pdf(gmm,[x y])); % view PDF surface ezsurfc(@(x,y) pdf(gmm,[x y]));
% load Fisher Iris dataset load fisheriris % project it down to 2 dimensions for the sake of visualization [~,data] = pca(meas, mn = min(data); mx = max(data); D = size(data,2); % data dimension % inital kmeans step used to initialize EM K = 3; % number of mixtures/clusters cInd = kmeans(data, K, % fit a GMM model gmm = fitgmdist(data, K, % means, covariances, and mixing-weights mu = gmm.mu; sigma = gmm.Sigma; p = gmm.PComponents; % cluster and posterior probablity of each instance % note that: [~,clustIdx] = max(p,[],2) [clustInd,~,p] = cluster(gmm, data); tabulate(clustInd) % plot data, clustering of the entire domain, and the GMM contours clrLite = [1 0.6 0.6 ; 0.6 1 0.6 ; 0.6 0.6 1]; clrDark = [0.7 0 0 ; 0 0.7 0 ; 0 0 0.7]; [X,Y] = meshgrid(linspace(mn(1),mx(1),50), linspace(mn(2),mx(2),50)); C = cluster(gmm, [X(:) Y(:)]); image(X(:), Y(:), reshape(C,size(X))), hold on gscatter(data(:,1), data(:,2), species, clrDark) h = ezcontour(@(x,y)pdf(gmm,[x y]), [mn(1) mx(1) mn(2) mx(2)]); set(h, hold off, axis xy, colormap(clrLite) title(
X = 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Y = 0 0 0 0 0 0 0 0 0.38 0.82 0.38 0.04 0 0 0.32 0.82 0.68 0.17 0 0 0.04 0.14 0.11 0 0 0 0 0 0 0
indrow = double(im1(:)) + 1; indcol = double(im2(:)) + 1; % jointHistogram = accumarray([indrow indcol], 1); jointProb = jointHistogram / numel(indrow);
indNoZero = jointHistogram ~= 0; jointProb1DNoZero = jointProb(indNoZero);
jointEntropy = -sum(jointProb1DNoZero.*log2(jointProb1DNoZero));
[~,~,indrow] = unique(im1(:)); % [~,~,indcol] = unique(im2(:)); % % jointHistogram = accumarray([indrow indcol], 1); jointProb = jointHistogram / numel(indrow); indNoZero = jointHistogram ~= 0; jointProb1DNoZero = jointProb(indNoZero); jointEntropy = -sum(jointProb1DNoZero.*log2(jointProb1DNoZero));
histogramImage1 = sum(jointHistogram, 1); histogramImage2 = sum(jointHistogram, 2);
% indNoZero = histogramImage1 ~= 0; % prob1NoZero = histogramImage1(indNoZero); prob1NoZero = prob1NoZero / sum(prob1NoZero); % entropy1 = -sum(prob1NoZero.*log2(prob1NoZero)); % indNoZero = histogramImage2 ~= 0; prob2NoZero = histogramImage2(indNoZero); prob2NoZero = prob2NoZero / sum(prob2NoZero); entropy2 = -sum(prob2NoZero.*log2(prob2NoZero)); % mutualInformation = entropy1 + entropy2 - jointEntropy;
robot = java.awt.Robot; command = system([command pause(5) % robot.keyPress (java.awt.event.KeyEvent.VK_ENTER); % robot.keyRelease (java.awt.event.KeyEvent.VK_ENTER); %
NET.addAssembly( System.Windows.Forms.SendKeys.SendWait(
%% NET.addAssembly( sendkey = @(strkey) System.Windows.Forms.SendKeys.SendWait(strkey) ; %% str1 = str2 = file2save = [pwd if exist(file2save, %% % system( sendkey(str1) % sendkey( sendkey(str2) % sendkey( sendkey( pause(1) % sendkey(file2save); % sendkey( pause(3) % sendkey(
Shift + Control (Ctrl) ^ Alt % Tab {TAB} Backspace {BACKSPACE}, {BS}, or {BKSP} Validation {ENTER} or ~ (a tilde) Ins Or Insert {INSERT} or {INS} Delete {DELETE} or {DEL} Text Navigation {HOME} {END} {PGDN} {PGUP} Arrow Keys {UP} {RIGHT} {DOWN} {LEFT} Escape {ESC} Function Keys {F1} ... {F16} Print Screen {PRTSC} Break {BREAK}
var WshShell = WScript.CreateObject("WScript.Shell"); WshShell.SendKeys(WScript.Arguments(0));
>> c = { 1, c = [1] [2] >> c(end+1,:) = {3, c = [1] [2] [3]
>> xd = get(kids, >> yd = get(kids, >> xd1 = xd{1}; %
figure plot([1:5],[1:5]*3, % text(2.94,8.3, text(2.8,7.8,
plot(1:10); ha = annotation( ha.Parent = gca; % associate the arrow the the current axes ha.X = [5.5 5.5]; % the location in data units ha.Y = [2 8]; ha.LineWidth = 3; % make the arrow bolder for the picture ha.HeadWidth = 30; ha.HeadLength = 30;
%% example plot clf plot(rand(5,2)*5) %% get info specific to the axes you plan to plot into set(gcf, set(gca, ax = axis; ap = get(gca, %% annotation from 1,2 to 3,4 xo = [1,3]; yo = [2,4]; xp = (xo-ax(1))/(ax(2)-ax(1))*ap(3)+ap(1); yp = (yo-ax(3))/(ax(4)-ax(3))*ap(4)+ap(2); ah=annotation(
Ax=[0 -0.003 0.003 0]; % (Ax,Ay) form an upward pointing arrowhead. Ay=[0.01 0.0060 0.0060 0.01]; Ax=Ax-mean(Ax); % center it on zero Ay=Ay-mean(Ay);
x1=vv(in,1); y1=vv(in,2); x2=vv(in+1,1); y2=vv(in+1,2); u=x2-x1; v=y2-y1; th=-pi/2+atan2(v,u); R=[cos(th) -sin(th); sin(th) cos(th)]; % Rotation matrix for local slope of vv. A=R*[Ax;Ay]; % Rotate the arrowhead. patch(x1+A(1,:),y1+A(2,:), plot(x1+A(1,:),y1+A(2,:),
% tmp = dbstatus; save( % close all clear classes % clc % load( dbstop(tmp) % clear tmp delete(
function out = compact( in ) d = in for i = 1:size(in, 2) %do ( m = d > 0 %shift left, pad w/ 0 on right ml = [m(2:end) 0] % shift dl = [d(2:end) 0] % shift %if the data originally has a gap, fill it in w/ the %left shifted one use = (m == 0) & (ml == 1) %2 comparison d = use .* dl + ~use .* d %zero out elements that have been moved to the left use_r = [0 use(1:end-1)] d = d .* ~use_r end out = d(1 : size(find(in > 0), 2)) %truncate the end end
typedef unsigned long long ull; const ull h = 0x8080808080808080; const ull l = 0x0101010101010101; const ull end = 0xffffffffffffffff; ull x = 0x0100802300887700; ull m = h & ~(x | ((x|h) - l)); m = ~(m | (m - (m>>7))); m |= (m - 1); while (m != end) { ull tailm = m ^ (m + 1); ull tailx = x & tailm; tailm |= (tailm << 8); m |= tailm; x = (x ^ tailx) | (tailx << 8); }
for(int inIdx = 0, outIdx = 0; inIdx < inLength; inIdx++) { if(mask[inIdx] == 1) { out[outIdx] = in[inIdx]; outIdx++; } }
function out = compact( in ) m = in <= 0 for i = 1:size(in, 2)-1 m = [0 m(1:end-1)] s = s + m end d = in shift = 1 for j = 1:ceil(log2(size(in, 2))) s1 = rem(s, 2) s = (s - s1) / 2 d = (d .* ~s1) + ([d(1+shift:end) zeros(1,shift)] .* [s1(1+shift:end) zeros(1,shift)]) shift = shift*2 end out = d end
float array[8]; unsigned int mask = ...; int a = 0, b = 0; while (mask) { if (mask & 1) { array[a++] = array[b]; } b++; mask >>= 1; } while (a < 8) array[a++] = 0.0;
int j = 0; int arraysize = (sizeof k)/4; int store[arraysize]; for(int i = 0; i<arraysize; i++) { if(k[i] > 0) { store[j] = k[i]; j++; } }
clear % NxN, Nx1, addition / power N1 = 2.^(4:1:12); t1_bsxfun_add = NaN(size(N1)); t1_implicit_add = NaN(size(N1)); t1_bsxfun_pow = NaN(size(N1)); t1_implicit_pow = NaN(size(N1)); for k = 1:numel(N1) N = N1(k); x = randn(N,N); y = randn(N,1); % y = randn(1,N); % use this line or the preceding one t1_bsxfun_add(k) = timeit(@() bsxfun(@plus, x, y)); t1_implicit_add(k) = timeit(@() x+y); t1_bsxfun_pow(k) = timeit(@() bsxfun(@power, x, y)); t1_implicit_pow(k) = timeit(@() x.^y); end % NxNxNxN, Nx1xN, addition / power N2 = round(sqrt(N1)); t2_bsxfun_add = NaN(size(N2)); t2_implicit_add = NaN(size(N2)); t2_bsxfun_pow = NaN(size(N2)); t2_implicit_pow = NaN(size(N2)); for k = 1:numel(N1) N = N2(k); x = randn(N,N,N,N); y = randn(N,1,N); % y = randn(1,N,N); % use this line or the preceding one t2_bsxfun_add(k) = timeit(@() bsxfun(@plus, x, y)); t2_implicit_add(k) = timeit(@() x+y); t2_bsxfun_pow(k) = timeit(@() bsxfun(@power, x, y)); t2_implicit_pow(k) = timeit(@() x.^y); end % Plots figure colors = get(gca, subplot(121) title( % title( set(gca, hold on grid on loglog(N1.^2, t1_bsxfun_add, loglog(N1.^2, t1_implicit_add, loglog(N1.^2, t1_bsxfun_pow, loglog(N1.^2, t1_implicit_pow, legend( subplot(122) title( % title( set(gca, hold on grid on loglog(N2.^4, t2_bsxfun_add, loglog(N2.^4, t2_implicit_add, loglog(N2.^4, t2_bsxfun_pow, loglog(N2.^4, t2_implicit_pow, legend(
%% Input parser p = inputParser; addRequired(p, validationFcn = @(x) (isnumeric(x) && isscalar(x)); addRequired(p, addRequired(p, validationFcn = @(x) (isa(x, addRequired(p, parse(p, x, fftSize, fftShift, analysisWindowHandle);
array1MirrorImage = padarray(array1, [0 length(array1)], array1MirrorImage = array1MirrorImage(1:length(array1));
a = flip(a, 1); % Reverses elements in each column a = flip(a, 2); % Reverses elements in each row
a = flipdim(a, 1); % Flips the rows of a a = flipdim(a, 2); % Flips the columns of a
rowreverse = fliplr(row) % for a row vector (or each row of a 2D array) colreverse = flipud(col) % for a column vector (or each column of a 2D array) genreverse = x(end:-1:1) % for the general case of a 1D vector (either row or column)
function [b,c]=findInSorted(x,range) %findInSorted fast binary search replacement for ismember(A,B) for the %special case where the first input argument is sorted. % % [a,b] = findInSorted(x,s) returns the range which is equal to s. % r=a:b and r=find(x == s) produce the same result % % [a,b] = findInSorted(x,[from,to]) returns the range which is between from and to % r=a:b and r=find(x >= from & x <= to) return the same result % % For any sorted list x you can replace % [lia] = ismember(x,from:to) % with % [a,b] = findInSorted(x,[from,to]) % lia=a:b % % Examples: % % x = 1:99 % s = 42 % r1 = find(x == s) % [a,b] = myFind(x,s) % r2 = a:b % %r1 and r2 are equal % % See also FIND, ISMEMBER. % % Author Daniel Roeske <danielroeske.de> A=range(1); B=range(end); a=1; b=numel(x); c=1; d=numel(x); if A<=x(1) b=a; end if B>=x(end) c=d; end while (a+1<b) lw=(floor((a+b)/2)); if (x(lw)<A) a=lw; else b=lw; end end while (c+1<d) lw=(floor((c+d)/2)); if (x(lw)<=B) c=lw; else d=lw; end end end
function [lower_index,upper_index] = myFindDrGar(x,LowerBound,UpperBound) % fast O(log2(N)) computation of the range of indices of x that satify the % upper and lower bound values using the fact that the x vector is sorted % from low to high values. Computation is done via a binary search. % % Input: % % x- A vector of sorted values from low to high. % % LowerBound- Lower boundary on the values of x in the search % % UpperBound- Upper boundary on the values of x in the search % % Output: % % lower_index- The smallest index such that % LowerBound<=x(index)<=UpperBound % % upper_index- The largest index such that % LowerBound<=x(index)<=UpperBound if LowerBound>x(end) || UpperBound<x(1) || UpperBound<LowerBound % no indices satify bounding conditions lower_index = []; upper_index = []; return; end lower_index_a=1; lower_index_b=length(x); % x(lower_index_b) will always satisfy lowerbound upper_index_a=1; % x(upper_index_a) will always satisfy upperbound upper_index_b=length(x); % % The following loop increases _a and decreases _b until they differ % by at most 1. Because one of these index variables always satisfies the % appropriate bound, this means the loop will terminate with either % lower_index_a or lower_index_b having the minimum possible index that % satifies the lower bound, and either upper_index_a or upper_index_b % having the largest possible index that satisfies the upper bound. % while (lower_index_a+1<lower_index_b) || (upper_index_a+1<upper_index_b) lw=floor((lower_index_a+lower_index_b)/2); % split the upper index if x(lw) >= LowerBound lower_index_b=lw; % decrease lower_index_b (whose x value remains \geq to lower bound) else lower_index_a=lw; % increase lower_index_a (whose x value remains less than lower bound) if (lw>upper_index_a) && (lw<upper_index_b) upper_index_a=lw;% increase upper_index_a (whose x value remains less than lower bound and thus upper bound) end end up=ceil((upper_index_a+upper_index_b)/2);% split the lower index if x(up) <= UpperBound upper_index_a=up; % increase upper_index_a (whose x value remains \leq to upper bound) else upper_index_b=up; % decrease upper_index_b if (up<lower_index_b) && (up>lower_index_a) lower_index_b=up;%decrease lower_index_b (whose x value remains greater than upper bound and thus lower bound) end end end if x(lower_index_a)>=LowerBound lower_index = lower_index_b; else lower_index = lower_index_a; end if x(upper_index_b)<=UpperBound upper_index = upper_index_a; else upper_index = upper_index_b; end
function [lower_index,upper_index] = mySearchForDrGar(x,value) [lower_index,upper_index] = myFindDrGar(x,value,value);
>> x = [1 2 2 3 3 3 4 5 6 7 7]; >> [tf,loc]=ismember(x,3); >> inds = find(tf)
% ISMEMBC - S must be sorted - Returns logical vector indicating which % elements of A occur in S tf = ismembc(x,3); inds = find(tf);
firstInd = builtin( lastInd = ismembc2(searchfor,x); % find last occurrence % lastInd = ismembc2(searchfor,x(firstInd:end))+firstInd-1; % slower inds = firstInd:lastInd;
mean([rntm1 rntm2 rntm3 rntmX]) ans = 0.559204323050486 0.263756852283128 0.000017989974213 0.000153682125682
% ISMEMBC2 - S must be sorted - Returns a vector of the locations of % the elements of A occurring in S. If multiple instances occur, % the last occurrence is returned % ISMEMBERFIRST(A,B) - B must be sorted - Returns a vector of the % locations of the elements of A occurring in B. If multiple % instances occur, the first occurence is returned.
N = 5e7; % length of vector p = 0.99; % probability KK = 100; % number of instances rntm1 = zeros(KK, 1); % runtime with ismember rntm2 = zeros(KK, 1); % runtime with ismembc rntm3 = zeros(KK, 1); % runtime with Daniel for kk = 1:KK x = cumsum(rand(N, 1) > p); searchfor = x(ceil(4*N/5)); tic [tf,loc]=ismember(x, searchfor); inds1 = find(tf); rntm1(kk) = toc; tic tf = ismembc(x, searchfor); inds2 = find(tf); rntm2(kk) = toc; tic a=1; b=numel(x); c=1; d=numel(x); while (a+1<b||c+1<d) lw=(floor((a+b)/2)); if (x(lw)<searchfor) a=lw; else b=lw; end lw=(floor((c+d)/2)); if (x(lw)<=searchfor) c=lw; else d=lw; end end inds3 = (b:c) rntm3(kk) = toc; end
% Mean of running time mean([rntm1 rntm2 rntm3]) % 0.631132275892504 0.295233981447746 0.000400786666188 % Percentiles of running time prctile([rntm1 rntm2 rntm3], [0 25 50 75 100]) % 0.410663611685559 0.175298784336465 0.000012828868032 % 0.429120717937665 0.185935198821797 0.000014539383770 % 0.582281366154709 0.268931132925888 0.000019243302048 % 0.775917520641649 0.385297304740352 0.000026940622867 % 1.063753914942895 0.592429428396956 0.037773746662356
function idx = findInSorted(x,range) % Author Dídac Rodríguez Arbonès (May 2018) % Based on Daniel Roeske % Daniel Roeske <danielroeske.de> % https: range = sort(range); idx = nan(size(range)); for i=1:numel(range) idx(i) = aux(x, range(i)); end end function b = aux(x, lim) a=1; b=numel(x); if lim<=x(1) b=a; end if lim>=x(end) a=b; end while (a+1<b) lw=(floor((a+b)/2)); if (x(lw)<lim) a=lw; else b=lw; end end end
N = 5e6; % length of vector p = 0.99; % probability KK = 100; % number of instances rntm1 = zeros(KK, 1); % runtime with ismember rntm2 = zeros(KK, 1); % runtime with ismembc rntm3 = zeros(KK, 1); % runtime with Daniel for kk = 1:KK x = cumsum(rand(N, 1) > p); searchfor = x(ceil(4*N/5)); tic range = sort(searchfor); idx = nan(size(range)); for i=1:numel(range) idx(i) = aux(x, range(i)); end rntm1(kk) = toc; tic a=1; b=numel(x); c=1; d=numel(x); while (a+1<b||c+1<d) lw=(floor((a+b)/2)); if (x(lw)<searchfor) a=lw; else b=lw; end lw=(floor((c+d)/2)); if (x(lw)<=searchfor) c=lw; else d=lw; end end inds3 = (b:c) rntm2(kk) = toc; end %% function b = aux(x, lim) a=1; b=numel(x); if lim<=x(1) b=a; end if lim>=x(end) a=b; end while (a+1<b) lw=(floor((a+b)/2)); if (x(lw)<lim) a=lw; else b=lw; end end end
% Mean of running time mean([rntm1 rntm2]) % 9.9624e-05 5.6303e-05 % Percentiles of running time prctile([rntm1 rntm2], [0 25 50 75 100]) % 3.0435e-05 1.0524e-05 % 3.4133e-05 1.2231e-05 % 3.7262e-05 1.3369e-05 % 3.9111e-05 1.4507e-05 % 0.0027426 0.0020301
[found, idx] = ismember(range, x); idx(~found) = arrayfun(@(r) aux(x, r), range(~found));
function fcnHandle = counter value = 0; function currentValue = increment value = value+1; currentValue = value; end fcnHandle = @increment; end
>> f1 = counter(); >> f2 = counter(); >> output = [f1() f1() f2() f1() f2()]; %
c1 = (a+b)/2, or c2 = a + (b-a)/2, or c3 = a/2 + b/2.
for i=1:nx for j=1:ny output(i,j) = A(ix(i,j),iy(i,j)); end end
true(10); true(n,m,k,..); % for an all-true 10-by-10 or n-by-m-by-k-by-...matrix false(10); false(n,m,k,..); % for an all-false 10-by-10 or n-by-m-by-k-by-...matrix inf(10); inf(n,m,k,..); % for an all-inf 10-by-10 or n-by-m-by-k-by-...matrix nan(10); nan(n,m,k,..); % for an all-nan 10-by-10 or n-by-m-by-k-by-...matrix
a = inf; % alias for a = inf(1); b = true; % alias for b = true(1);
rand(10); rand(n,m,k,..); % for an all-random 10-by-10 or n-by-m-by-k-by-...matrix zeros(10); zeros(n,m,k,..); % for an all-zero 10-by-10 or n-by-m-by-k-by-...matrix zeros(n,m,k,..., ones(10); zeros(n,m,k,..); % for an all-one 10-by-10 or n-by-m-by-k-by-...matrix ones(n,m,k,..., eye(10); eye(n,m,
A = [1 0 2; -1 0 0; 0 1.53 -100.00] B = logical(A) B = 1 0 1 1 0 0 0 1 1
img = imread( imgMirror = flipdim(img,2); % imgUpsideDown = flipdim(img,1); %
I = imread( I2 = I(:,end:-1:1,:); % I3 = I(end:-1:1,:,:); % I4 = I(end:-1:1,end:-1:1,:); % subplot(2,2,1), imshow(I) subplot(2,2,2), imshow(I2) subplot(2,2,3), imshow(I3) subplot(2,2,4), imshow(I4)
I = imread( % flip left-right, or up-down: Iflipud = flip(I, 1) Ifliplr = flip(I, 2) % or: Iflipud = I(size(I,1):-1:1,:,:); Ifliplr = I(:,size(I,1):-1:1,:); % flip both left-right, and up-down, stupid way: Iflipboth = I(size(I,1):-1:1,size(I,1):-1:1,:); % flip both left-right, and up-down, smart way:): Iflipboth = imrotate(I, 180)
cmap = hsv(6); % for i = 1:6 % plot(X(:,i),Y(:,i), % end
myMap = rand(nbColors, 3); for i = 1:nbColors plot(X(:,i),Y(:,i), end
load fisheriris % groups = ismember(species, % % % % % % k=10; cvFolds = crossvalind( cp = classperf(groups); % for i = 1:k % testIdx = (cvFolds == i); % trainIdx = ~testIdx; % % svmModel = svmtrain(meas(trainIdx,:), groups(trainIdx), ... % pred = svmclassify(svmModel, meas(testIdx,:), % cp = classperf(cp, pred, testIdx); end % cp.CorrectRate % % cp.CountingMatrix
i_lower = find(data <= b,1, i_higher = find(data >= b,1, lower_than_b = data(i_lower) higher_than_b = data(i_higher)
data = [1 1.2 1.3 1.5 1.8] b = 1.23 find(abs(data-b)==min(abs(data-b)))
nearestTo = @(x, xq) interp1(x, x, xq, nearestTo([2 4 6 8 10], [pi 2*pi 3*pi]) % 4 6 10 nearestTo(sort([2 7 11 3 5]), abs(-3.5)) % 3
>> f = @(x)deal(x.^2,x.^3); >> [a,b]=f(3) a = 9 b = 27
deal2 = @(varargin) deal(varargin{1:nargout}); myAnonymousFunc = @(x) deal2(x.^2, x.^3);
x = 2; [b,a] = myAnonymousFunc(x) b = myAnonymousFunc(x)
fdoubleEig = @(x) eig(2*x) [e, v] = fdoubleEig(magic(3))
>>> f = @(x, y, z) deal(2*x, 3*y, 4*z) >>> [a, b, c] = f(1, 2, 3) a = 2 b = 6 c = 12
>>> f = @(x, y, z) {2*x, 3*y, 4*z} >>> t = f(1, 2, 3) >>> [a, b, c] = t{:} a = 2 b = 6 c = 12
startLoop = tic; for i = 1:N startIteration = tic; someCode; endIteration = toc(startIteration); end endLoop = toc(startLoop);
startLoop = tic; for i = 1:N startIteration(i) = tic; someCode; endIteration(i) = toc(startIteration(i)); end endLoop = toc(startLoop);
tStartOverall = tic; ... tStartLoop = tic; <your loop code here> tEndLoop = toc(tStartLoop); ... tEndOverall = toc(tStartOverall);
history = com.mathworks.mlservices.MLCommandHistoryServices.getSessionHistory; historyText = char(history);
>> chdir(prefdir) >> !grep plot history.m plot(f, abs(tf)) doc biplot !grep plot history.m
{ "myFunction": { "inputs": [ {"name":"filename", "kind":"required", "type":"filepath=*.ext" } ] } }
A = rand(3,4); [val ind] = sort(A,2); B = rand(3,4); %
0.048524 1.4632 1.4791 1.195 1.0662 1.108 1.0082 0.96335 0.93155 0.90532 0.88976
0.63202 1.3029 1.1112 1.0501 0.94703 0.92847 0.90411 0.8849 0.8667 0.92098 0.85569
A = rand(3,4); B = rand(3,4); [sortedA,ind] = sort(A,2); for r = 1:size(A,1) B(r,:) = B(r,ind(r,:)); end
siz = 10:100:1010; tt = zeros(100,2,length(siz)); for s = siz for k = 1:100 A = rand(s,1*s); B = rand(s,1*s); [sortedA,ind] = sort(A,2); tic; for r = 1:size(A,1) B(r,:) = B(r,ind(r,:)); end,tt(k,1,s==siz) = toc; tic; m = size(A,1); B = B(bsxfun(@plus,(ind-1)*m,(1:m). tt(k,2,s==siz) = toc; end end m = squeeze(mean(tt,1)); m(1,:)./m(2,:)
ans = 0.7149 2.1508 1.2203 1.4684 1.2339 1.1855 1.0212 1.0201 0.8770 0.8584 0.8405
ans = 0.8431 1.2874 1.3550 1.1311 0.9979 0.9921 0.8263 0.7697 0.6856 0.7004 0.7314
A = rand(3,4); B = A; % [A2 ix2] = sort(A,2); % ix1 = repmat([1:size(A,1)] % ix = sub2ind(size(A), ix1, ix2) % B2 = B(ix) ok = isequal(A2, B2) %
primary_expression : IDENTIFIER | CONSTANT | STRING_LITERAL | | | ; postfix_expression : primary_expression | array_expression | postfix_expression TRANSPOSE | postfix_expression NCTRANSPOSE ; index_expression : | expression ; index_expression_list : index_expression | index_expression_list ; array_expression : IDENTIFIER ; unary_expression : postfix_expression | unary_operator postfix_expression ; unary_operator : | | ; multiplicative_expression : unary_expression | multiplicative_expression | multiplicative_expression | multiplicative_expression | multiplicative_expression | multiplicative_expression ARRAYMUL unary_expression | multiplicative_expression ARRAYDIV unary_expression | multiplicative_expression ARRAYRDIV unary_expression | multiplicative_expression ARRAYPOW unary_expression ; additive_expression : multiplicative_expression | additive_expression | additive_expression ; relational_expression : additive_expression | relational_expression | relational_expression | relational_expression LE_OP additive_expression | relational_expression GE_OP additive_expression ; equality_expression : relational_expression | equality_expression EQ_OP relational_expression | equality_expression NE_OP relational_expression ; and_expression : equality_expression | and_expression ; or_expression : and_expression | or_expression ; expression : or_expression | expression ; assignment_expression : postfix_expression eostmt : | | CR ; statement : global_statement | clear_statement | assignment_statement | expression_statement | selection_statement | iteration_statement | jump_statement ; statement_list : statement | statement_list statement ; identifier_list : IDENTIFIER | identifier_list IDENTIFIER ; global_statement : GLOBAL identifier_list eostmt ; clear_statement : CLEAR identifier_list eostmt ; expression_statement : eostmt | expression eostmt ; assignment_statement : assignment_expression eostmt ; array_element : expression | expression_statement ; array_list : array_element | array_list array_element ; selection_statement : IF expression statement_list END eostmt | IF expression statement_list ELSE statement_list END eostmt | IF expression statement_list elseif_clause END eostmt | IF expression statement_list elseif_clause ELSE statement_list END eostmt ; elseif_clause : ELSEIF expression statement_list | elseif_clause ELSEIF expression statement_list ; iteration_statement : WHILE expression statement_list END eostmt | FOR IDENTIFIER | FOR ; jump_statement : BREAK eostmt | RETURN eostmt ; translation_unit : statement_list | FUNCTION function_declare eostmt statement_list ; func_ident_list : IDENTIFIER | func_ident_list ; func_return_list : IDENTIFIER | ; function_declare_lhs : IDENTIFIER | IDENTIFIER | IDENTIFIER ; function_declare : function_declare_lhs | func_return_list ;
m = 1e5; n = 100; A = rand(m,n); frepmat = @() A - repmat(mean(A),size(A,1),1); timeit(frepmat) fbsxfun = @() bsxfun(@minus,A,mean(A)); timeit(fbsxfun)
m = 1e5; n = 100; A = rand(m,n); frepmat = @() A - repmat(mean(A),size(A,1),1); timeit(frepmat) fbsxfun = @() bsxfun(@minus,A,mean(A)); timeit(fbsxfun) ans = 0.03756 ans = 0.034831
>> m = 1e5; n = 8e3; A = rand(m,n); >> B = A - repmat(mean(A),size(A,1),1); >> clear B >> C = bsxfun(@minus,A,mean(A)); >> clear C
>> m = 1e5; n = 8e3; A = rand(m,n); >> A = A - repmat(mean(A),size(A,1),1); >> clear all >> m = 1e5; n = 8e3; A = rand(m,n); >> A = bsxfun(@minus,A,mean(A));
>> regexp(char([0 0 0 0 0 0 0 1 0 0 10 0 0 0]),char([0 0 0 0 46 0 0 10])) ans = 1 % current 4 % expected >> regexp(char([0 0 0 1 0 0 0 1 0 0 10 0 0 0]),char([1 0 0 0 46 0 0 10])) ans = 4 % current 4 % expected >> regexp(char([0 0 0 1 0 0 0 1 0 0 10 0 0 0]),char([0 0 0 0 46 0 0 10])) ans = [] % current [] % expected >> regexp(char([0 0 0 0 10 0 0 1 0 0 10 0 0 0]),char([0 0 0 0 46 0 0 10])) ans = 1 % current [] % expected >> regexp(char([0 0 0 0 0 0 0 1 0 0 10 0 0 0]),char([1 0 0 0 46 0 0 10])) ans = [] % current [] % expected
>> regexp(char([0 0 0 0 50 0 0 100 0 0 90 0 0 0]),char([0 0 46 0 0 90])) ans = 1 9
>> regexp(char([0 0 1 0 41 41 41 41 41 41]),char([0 ans = 2
>> regexp(char([0 0 1 0 41 41 41 41 41 41]),char([0 ans = 2
>> regexp(char([0 0 1 0 41 41 41 41 41 41]),char([0 ans = []
% libSVM version_1 clc; clear all; load fisheriris [~,~,labels] = unique(species); % Labels: 1/2/3 data = zscore(meas); % Scale features numInst = size(data,1); numLabels = max(labels); % idx = randperm(numInst); numTrain = 100; numTest = numInst - numTrain; trainData = data(idx(1:numTrain),:); testData = data(idx(numTrain+1:end),:); trainLabel = labels(idx(1:numTrain)); testLabel = labels(idx(numTrain+1:end)); % model = cell(numLabels,1); for k=1:numLabels model{k} = libsvmtrain(double(trainLabel==k), trainData, end % prob = zeros(numTest,numLabels); for k=1:numLabels [~,~,p] = svmpredict(double(testLabel==k), testData, model{k}, prob(:,k) = p(:,model{k}.Label==1); % Probability of class==k end % Predict the class with the highest probability [~,pred] = max(prob,[],2); acc = sum(pred == testLabel) ./ numel(testLabel); % Accuracy C = confusionmat(testLabel, pred); % Confusion matrix
% Matlab build-in SVM version_1 clc; clear all; load fisheriris [g, gn] = grp2idx(species); % Nominal class to numeric % Split training and testing sets [trainIdx, testIdx] = crossvalind( pairwise = nchoosek(1:length(gn),2); % 1-vs-1 pairwise models svmModel = cell(size(pairwise,1),1); % Store binary-classifers predTest = zeros(sum(testIdx),numel(svmModel)); % Store binary predictions % for k=1:numel(svmModel) % idx = trainIdx & any( bsxfun(@eq, g, pairwise(k,:)) , 2 ); % svmModel{k} = svmtrain(meas(idx,:), g(idx), ... % predTest(:,k) = svmclassify(svmModel{k}, meas(testIdx,:)); end pred = mode(predTest,2); % Voting: clasify as the class receiving most votes % cmat = confusionmat(g(testIdx),pred); acc = 100*sum(diag(cmat))./sum(cmat(:)); fprintf( fprintf(
[dim_y,dim_x]=size(pic); enlarged_pic=[zeros(1,dim_x+2); zeros(dim_y,1),pic,zeros(dim_y,1); zeros(1,dim_x+2)]; % now build a 3D array % each plane will be the enlarged picture % moved up,down,left or right, % to all the diagonals, or not at all [en_dim_y,en_dim_x]=size(enlarged_pic); three_d(:,:,1)=enlarged_pic; three_d(:,:,2)=[enlarged_pic(2:end,:);zeros(1,en_dim_x)]; three_d(:,:,3)=[zeros(1,en_dim_x);enlarged_pic(1:end-1,:)]; three_d(:,:,4)=[zeros(en_dim_y,1),enlarged_pic(:,1:end-1)]; three_d(:,:,5)=[enlarged_pic(:,2:end),zeros(en_dim_y,1)]; three_d(:,:,6)=[pic,zeros(dim_y,2);zeros(2,en_dim_x)]; three_d(:,:,7)=[zeros(2,en_dim_x);pic,zeros(dim_y,2)]; three_d(:,:,8)=[zeros(dim_y,2),pic;zeros(2,en_dim_x)]; three_d(:,:,9)=[zeros(2,en_dim_x);zeros(dim_y,2),pic];
(max_val, max_i) = max(three_d, 3); result = find(max_i == 1);
CC = bwconncomp(BW); for i = 1:CC.NumObjects, index = CC.PixelIdxList{i}; if (numel(index) > 1), BW(index) = false; end end
I = imread( BW = nlfilter(I, [3 3], @(x) all(x(5) > x([1:4 6:9])) ); imshow(BW)
>> mask = ones(3); mask(5) = 0 % 3x3 max mask = 1 1 1 1 0 1 1 1 1
>> B = ordfilt2(A,8,mask) B = 3 3 3 3 3 4 4 4 3 5 5 5 4 4 4 4 3 5 3 5 4 4 4 4 3 5 5 5 4 6 6 6 3 3 3 3 4 6 4 6 1 1 1 1 4 6 6 6
>> peaks = A > B peaks = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0
function [ output_args ] = example( input_args ) figure ( x = [10 30] y = [10 30] xlim([1, 100]) ylim([1, 100]) arrow (x, y) ??? end
drawArrow = @(x,y) quiver( x(1),y(1),x(2)-x(1),y(2)-y(1),0 ) x1 = [10 30]; y1 = [10 30]; drawArrow(x1,y1); hold on x2 = [25 15]; y2 = [15 25]; drawArrow(x2,y2)
drawArrow = @(x,y,varargin) quiver( x(1),y(1),x(2)-x(1),y(2)-y(1),0, varargin{:} ) drawArrow(x1,y1); hold on drawArrow(x2,y2,
x1 = [10 30]; y1 = [10 30]; drawArrow(x1,y1,{ x2 = [25 15]; y2 = [15 25]; drawArrow(x2,y2,{ xlim([1, 100]) ylim([1, 100])
function [ h ] = drawArrow( x,y,xlimits,ylimits,props ) xlim(xlimits) ylim(ylimits) h = annotation( set(h, props{:} ); end
drawArrow(x1,y1,[1, 100],[1, 100],{ drawArrow(x2,y2,[1, 100],[1, 100],{
data(2:n-1) = alpha*data(2:n-1) + (1-alpha)*0.5*(data(1:n-2)+data(3:n))
f = fft(data) f(n/2+1-20:n/2+20) = zeros(40,1) smoothed = real(ifft(f))
% some noisy signal Fs = 200; f = 5; t = 0:1/Fs:1-1/Fs; y = sin(2*pi*f*t) + 0.6*randn(size(t)); subplot(411) plot(y), title( % smoothed signal subplot(412) plot( smooth(y, 5, ylim([-2 2])
% equivalent to a moving average window wndwSize = 5; h = ones(1,wndwSize)/wndwSize; subplot(413) plot( filter(h, 1, y) ), title( % Guassian h = pdf( subplot(414) plot( filter(h, 1, y) ), title(
A = rand(4); % 4x4 matrix [ row_max row_argmax ] = max( A, [], 2 ); % max for each row - 2nd dimension [ col_min col_argmin ] = min( A, [], 1 ); % min for each column - 1st dimension
a = [1 2 999 3]; [the_max, index_of_max] = max(a) the_max = 999 index_of_max = 3
x = rand(100,1); len = length(x); % nfft = 2^nextpow2(2*len-1); r = ifft( fft(x,nfft) .* conj(fft(x,nfft)) ); % r = [r(end-len+2:end) ; r(1:len)]; % all( (xcorr(x)-r) < 1e-10 )
x = [ ... ]; x_pad = [x zeros(size(x))]; X = fft(x_pad); X_psd = abs(X).^2; r_xx = ifft(X_psd);
A = [row1; row2; ...; rowM] B = [row1, row2, ..., rowM]
a = [2 3 5]; b = [1 1 0]; c = a+b; starts = zeros(3,3); ends = [a;b;c]; quiver3(starts(:,1), starts(:,2), starts(:,3), ends(:,1), ends(:,2), ends(:,3)) axis equal
o = [0 0 0]; % a = [2 3 5]; % b = [1 1 0]; % c = a+b; % arrowStarts = [o; a; o]; % arrowEnds = [a; c; c]; % arrow(arrowStarts,arrowEnds); %
o = [0 0 0]; % a = [2 3 5]; % b = [1 1 0]; % c = a+b; % arrowStarts = [o; o; o]; % arrowEnds = [a; b; c]; % arrow(arrowStarts,arrowEnds); % hold on; lineX = [a(1) b(1); c(1) c(1)]; % lineY = [a(2) b(2); c(2) c(2)]; % lineZ = [a(3) b(3); c(3) c(3)]; % line(lineX,lineY,lineZ,
% vectors I want to plot as rows (XSTART, YSTART) (XDIR, YDIR) rays = [ 1 2 1 0 ; 3 3 0 1 ; 0 1 2 0 ; 2 0 0 2 ; ] ; % quiver plot quiver( rays( :,1 ), rays( :,2 ), rays( :,3 ), rays( :,4 ) );
% vectors I want to plot as rows (XSTART, YSTART, ZSTART) (XDIR, YDIR, ZDIR) rays = [ 1 2 0 1 0 0; 3 3 2 0 1 -1 ; 0 1 -1 2 0 8; 2 0 0 0 2 1; ] ; % quiver plot quiver3( rays( :,1 ), rays( :,2 ), rays( :,3 ), rays( :,4 ), rays( :,5 ), rays( :,6 ) );
% draw simple vector from pt a to pt b % wtr : with respect to scale=0;%for drawin vectors with true scale a = [10 20 30];% wrt origine O(0,0,0) b = [10 10 20];% wrt origine O(0,0,0) starts=a;% a now is the origine of my vector to draw (from a to b) so we made a translation from point O to point a = to vector a c = b-a;% c is the new coordinates of b wrt origine a ends=c;% plot3(a(1),a(2),a(3), hold on plot3(b(1),b(2),b(3), quiver3(starts(:,1), starts(:,2), starts(:,3), ends(:,1), ends(:,2), ends(:,3),scale);% Use scale = 0 to plot the vectors without the automatic scaling. % axis equal hold off
function [] = my_awesome_function(image,filename,other_inputs) % Do awesome things. end
function my_awesome_function(image,filename,other_inputs) % Do awesome things. end
3.00 1.00 1.00 3.00 NaN NaN 3.00 3.00 1.00 1.00 NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN
function data_out = remove_nan (data_in, remove_dim) %remove row or col from the data_in if there is a NaN element % e.g., data_in =[1 2 3 4 NaN; 1 2 3 4 5; 1 2 3 NaN NaN] % from this data remove col 4 and 5 such that data_out=[ 1 2 3; 1 2 3; 1 2 % 3] if nargin==1 col_loc=any(isnan(data_in),1); data_in(:,col_loc)=[]; data_out=data_in; elseif nargin==2 if remove_dim== %find the cols with nan and remove the colums col_loc=any(isnan(data_in),1); data_in(:,col_loc)=[]; data_out=data_in; elseif remove_dim= %find the rows with nan and remove the rows row_loc=any(isnan(data_in),2); data_in(row_loc,:)=[]; data_out=data_in; end else error( end
MINGWPATH=c:/MinGW64 CYGPATH=c:/cygwin MATLABROOT=c:/Progra~1/MATLAB/R2011b CC=$(MINGWPATH)/bin/x86_64-w64-mingw32-gcc CFLAG= -Wall -m64 -O3 -I$(MATLABROOT)/extern/include $(SRC) $(LIBS) -o $(EXE) MEXFLAG=-m64 -shared -DMATLAB_MEX_FILE -I$(MATLABROOT)/extern/include -Wl,--export-all-symbols $(LIBS) $(MEXSRC) -o $(MEXTGT).mexw64 LIBS= -L$(MATLABROOT)/bin/win64 -L$(MATLABROOT)/extern/lib/win64/microsoft -lmex -lmx -lmwlapack -lmwblas -leng EXE=../bin/engwindemo.exe MEXTGT= SRC=engwindemo.c MEXSRC= all:$(EXE) $(EXE): $(SRC) $(CC) $(CFLAG) -ladvapi32 -luser32 -lgdi32 -lkernel32 -lmingwex -o $(EXE) @rm -f *.o* $(MEXTGT): $(MEXSRC) $(CC) $(MEXFLAG) -ladvapi32 -luser32 -lgdi32 -lkernel32 -lmingwex @rm -f *.o*
@echo off set MINGWPATH=p:\mingw64-tdm set PATH=%MINGWPATH%\bin;%PATH% set COMPILER=gcc set COMPFLAGS=-c -m64 -I"%MATLAB%\extern\include" -DMATLAB_MEX_FILE -Wall -std=c99 set OPTIMFLAGS=-O3 -DNDEBUG set DEBUGFLAGS=-g set NAME_OBJECT=-o set LINKER=gcc set LINKFLAGS=-shared -L"%MATLAB%\bin\win64" -L"%MATLAB%\extern\lib\win64\microsoft" -lmex -lmx -leng -lmat -lmwlapack -lmwblas set NAME_OUTPUT=-o "%OUTDIR%%MEX_NAME%%MEX_EXT%"
mex -v p:\matlab\R2012a\extern\examples\mex\yprime.c which yprime
setenv( mex -setup:H:\building\GitHub\MATLAB\MinGW\mex_C++_mingw-w64.xml C++
x86_64-w64-mingw32-c++ -m64 -shared -I"C:\Program Files\MATLAB\R2010b\extern\include" -o bla.mexw64 -DMATLAB_MEX_FILE -Wl,--export-all-symbols *.cpp
EXPORTS ... relevant function names go here, such as mexErrMsgTxt, matOpen, etc.
x86_64-w64-mingw32-dlltool -d libmx.def --dllname libmx.dll -l libmx.a
x86_64-w64-mingw32-c++ -m64 -shared -I"C:\..." -DMATLAB_MEX_FILE -o bla.mexw64 -Wl,--export-all-symbols *.cpp libmex.a libmx.a libmat.a libeng.a
x86_64-w64-mingw32-c++ -m64 -shared -I"%MATLAB%/extern/include" -DMATLAB_MEX_FILE -o bla.mexw64 -Wl,--export-all-symbols *.cpp -L"%MATLAB%/bin/win64" -lmex -lmx -leng -lmat
Warning: You are using gcc version "4.6.3-1ubuntu5)". The version currently supported with MEX is "4.4.6". For a list of currently supported compilers see: http:
"c:\mingw64\bin\x86_64-w64-mingw32-g++.exe" -m64 -shared -I"C:/Program Files/MATLAB/R2012b/extern/include" -DMATLAB_MEX_FILE -o CCODEFILE.mexw64 -Wl,--export-all-symbols CCODEFILE.c -L"C:/Program Files/MATLAB/R2012b/bin/win64" -lmex -lmx -leng -lmat
rem Add path to where dlls are: set DLL_PATH="C:\Program Files\MATLAB\R2011a\bin\win64" rem Add every dll needed: set GM_ADD_LIBS=%DLL_PATH%\libmx.dll %DLL_PATH%\libmex.dll %DLL_PATH%\libmat.dll
queue = new Queue(); queue.put(param); result = 0; while (!queue.isEmpty()) { param = queue.remove(); queue.add(param1); queue.add(param2); } return result;
import java.util.LinkedList q = LinkedList(); q.add( q.add(2); q.add([3 3 3]); item = q.remove(); q.add(
classdef Queue < handle properties ( Access = private ) elements nextInsert nextRemove end properties ( Dependent = true ) NumElements end methods function obj = Queue obj.elements = cell(1, 10); obj.nextInsert = 1; obj.nextRemove = 1; end function add( obj, el ) if obj.nextInsert == length( obj.elements ) obj.elements = [ obj.elements, cell( 1, length( obj.elements ) ) ]; end obj.elements{obj.nextInsert} = el; obj.nextInsert = obj.nextInsert + 1; end function el = remove( obj ) if obj.isEmpty() error( end el = obj.elements{ obj.nextRemove }; obj.elements{ obj.nextRemove } = []; obj.nextRemove = obj.nextRemove + 1; % Trim "elements" if obj.nextRemove > ( length( obj.elements ) / 2 ) ntrim = fix( length( obj.elements ) / 2 ); obj.elements = obj.elements( (ntrim+1):end ); obj.nextInsert = obj.nextInsert - ntrim; obj.nextRemove = obj.nextRemove - ntrim; end end function tf = isEmpty( obj ) tf = ( obj.nextRemove >= obj.nextInsert ); end function n = get.NumElements( obj ) n = obj.nextInsert - obj.nextRemove; end end end
q = {}; head = 1; q{head} = param; result = 0; while (head<=numel(q)) %process param{head} and obtain new param(s) head = head + 1; %change result q{end+1} = param1; q{end+1} = param2; end %loop over q return result;
chunkSize = 100; chunk = cell(1, chunkSize); q = chunk; head = 1; nextLoc = 2; q{head} = param; result = 0; while (head<endLoc) %process param{head} and obtain new param(s) head = head + 1; %change result if nextLoc > numel(q); q = [q chunk]; end q{nextLoc} = param1; nextLoc = nextLoc + 1; q{end+1} = param2; nextLoc = nextLoc + 1; end %loop over q return result;
properties (Access = private) buffer % a cell, to maintain the data beg % the start position of the queue rear % the end position of the queue % the actually data is buffer(beg:rear-1) end properties (Access = public) capacity % ص»µؤبفء؟£¬µ±بفء؟²»¹»ت±£¬بفء؟ہ©³نخھ2±¶،£ end methods function obj = CQueue(c) % ³ُت¼»¯ if nargin >= 1 && iscell(c) obj.buffer = [c(:); cell(numel(c), 1)]; obj.beg = 1; obj.rear = numel(c) + 1; obj.capacity = 2*numel(c); elseif nargin >= 1 obj.buffer = cell(100, 1); obj.buffer{1} = c; obj.beg = 1; obj.rear = 2; obj.capacity = 100; else obj.buffer = cell(100, 1); obj.capacity = 100; obj.beg = 1; obj.rear = 1; end end function s = size(obj) % ¶سءذ³¤¶ب if obj.rear >= obj.beg s = obj.rear - obj.beg; else s = obj.rear - obj.beg + obj.capacity; end end function b = isempty(obj) % return true when the queue is empty b = ~logical(obj.size()); end function s = empty(obj) % clear all the data in the queue s = obj.size(); obj.beg = 1; obj.rear = 1; end function push(obj, el) % ر¹بëذآشھثطµ½¶سخ² if obj.size >= obj.capacity - 1 sz = obj.size(); if obj.rear >= obj.beg obj.buffer(1:sz) = obj.buffer(obj.beg:obj.rear-1); else obj.buffer(1:sz) = obj.buffer([obj.beg:obj.capacity 1:obj.rear-1]); end obj.buffer(sz+1:obj.capacity*2) = cell(obj.capacity*2-sz, 1); obj.capacity = numel(obj.buffer); obj.beg = 1; obj.rear = sz+1; end obj.buffer{obj.rear} = el; obj.rear = mod(obj.rear, obj.capacity) + 1; end function el = front(obj) % ·µ»ط¶ست×شھثط if obj.rear ~= obj.beg el = obj.buffer{obj.beg}; else el = []; warning( end end function el = back(obj) % ·µ»ط¶سخ²شھثط if obj.rear == obj.beg el = []; warning( else if obj.rear == 1 el = obj.buffer{obj.capacity}; else el = obj.buffer{obj.rear - 1}; end end end function el = pop(obj) % µ¯³ِ¶ست×شھثط if obj.rear == obj.beg error( else el = obj.buffer{obj.beg}; obj.beg = obj.beg + 1; if obj.beg > obj.capacity, obj.beg = 1; end end end function remove(obj) % اه؟ص¶سءذ obj.beg = 1; obj.rear = 1; end function display(obj) % دشت¾¶سءذ if obj.size() if obj.beg <= obj.rear for i = obj.beg : obj.rear-1 disp([num2str(i - obj.beg + 1) disp(obj.buffer{i}); end else for i = obj.beg : obj.capacity disp([num2str(i - obj.beg + 1) disp(obj.buffer{i}); end for i = 1 : obj.rear-1 disp([num2str(i + obj.capacity - obj.beg + 1) disp(obj.buffer{i}); end end else disp( end end function c = content(obj) % ب،³ِ¶سءذشھثط if obj.rear >= obj.beg c = obj.buffer(obj.beg:obj.rear-1); else c = obj.buffer([obj.beg:obj.capacity 1:obj.rear-1]); end end end end
myQueueSize = 25; % Define queue size myQueue = zeros(1,myQueueSize); % Initialize queue k = 1 % Counter variable while 1 % Do something, and then % Store some number into the queue in a FIFO manner myQueue(mod(k, myQueueSize)+1) = someNumberToQueue; k= k+1; % Iterate counter end
queue = zeros( n, 1 ); firstq = 1; lastq = 1; while( lastq >= firstq && firstq <= n ) i = queue( firstq ); % pull first element from the queue % you do not physically remove it from an array, % thus saving time on memory access firstq = firstq + 1; % % % % % % % % % % % % % WORKER PART HERE % do stuff % % % % % % % % % % % % % % % % % % % % % % queue( lastq ) = j; % push element to the end of the queue lastq = lastq + 1; % increment index end;
FOO BAR BAZ BUZZ FUZZ ROW1 0.1622 0.4505 0.1067 0.4314 0.8530 ROW2 0.7943 0.0838 0.9619 0.9106 0.6221 ROW3 0.3112 0.2290 0.0046 0.1818 0.3510 ROW4 0.5285 0.9133 0.7749 0.2638 0.5132 ROW5 0.1656 0.1524 0.8173 0.1455 0.4018
| FOO BAR BAZ BUZZ FUZZ -----+------------------------------------------------- ROW1 | 0.1622 0.4505 0.1067 0.4314 0.8530 ROW2 | 0.7943 0.0838 0.9619 0.9106 0.6221 ROW3 | 0.3112 0.2290 0.0046 0.1818 0.3510 ROW4 | 0.5285 0.9133 0.7749 0.2638 0.5132 ROW5 | 0.1656 0.1524 0.8173 0.1455 0.4018
>> help printmat printmat Print matrix with labels. printmat(A,NAME,RLAB,CLAB) prints the matrix A with the row labels RLAB and column labels CLAB. NAME is a string used to name the matrix. RLAB and CLAB are string variables that contain the row and column labels delimited by spaces. For example, the string RLAB = defines second row and contain the same number of space delimited labels as there are rows and columns respectively. printmat(A,NAME) prints the matrix A with numerical row and column labels. printmat(A) prints the matrix A without a name. See also: printsys.
>> M = rand(5); >> printmat(M, My Matrix = FOO BAR BAZ BUZZ FUZZ ROW1 0.81472 0.09754 0.15761 0.14189 0.65574 ROW2 0.90579 0.27850 0.97059 0.42176 0.03571 ROW3 0.12699 0.54688 0.95717 0.91574 0.84913 ROW4 0.91338 0.95751 0.48538 0.79221 0.93399 ROW5 0.63236 0.96489 0.80028 0.95949 0.67874
>> M = rand(5); >> dataset({M ans = FOO BAR BAZ BUZZ FUZZ ROW1 0.52853 0.68921 0.91334 0.078176 0.77491 ROW2 0.16565 0.74815 0.15238 0.44268 0.8173 ROW3 0.60198 0.45054 0.82582 0.10665 0.86869 ROW4 0.26297 0.083821 0.53834 0.9619 0.084436 ROW5 0.65408 0.22898 0.99613 0.0046342 0.39978
>> M = rand(5); >> names= { >> array2table( M, ans = A B C D E _______ _______ _______ _______ ________ A 0.81472 0.09754 0.15761 0.14189 0.65574 B 0.90579 0.2785 0.97059 0.42176 0.035712 C 0.12699 0.54688 0.95717 0.91574 0.84913 D 0.91338 0.95751 0.48538 0.79221 0.93399 E 0.63236 0.96489 0.80028 0.95949 0.67874
function out = dispmat(M,name,row_labels,col_labels); %% Matthew Oberhardt % 02/08/2013 % intended to display a matrix along with row and column labels. %% ex: % M = rand(2,3); % row_labels = { % col_labels = { % % if there are no labels for rows or cols, put % row_labels = %Modified 14.07.2014 %Nestor Cantu %Added the name of the matrix. %% check that the row & col labels are the right sizes [nrows,ncols] = size(M); %% populate if either of the inputs is empty if isempty(row_labels) row_labels = cell(1,nrows); for n = 1:nrows row_labels{1,n} = end end if isempty(col_labels) col_labels = cell(1,ncols); for n = 1:ncols col_labels{1,n} = end end assert(length(row_labels)==nrows, assert(length(col_labels)==ncols, row_labels = reshape(row_labels,1,length(row_labels)); col_labels = reshape(col_labels,1,length(col_labels)); %% remove spaces (since they are separators in printmat.m cols = strrep(col_labels, rows = strrep(row_labels, %% create labels, space delimited c_out = []; for n = 1:length(cols) c_out = [c_out,cols{n}, end c_out = c_out(1:end-1); r_out = []; for n = 1:length(rows) r_out = [r_out,rows{n}, end r_out = r_out(1:end-1); %% print printmat(M,name,r_out,c_out) end
[m n] = size(conv); for i=1:n col{i} = [ end for i=1:m row{i} = [ end outMat(conv,
Convergence = K_=_1 K_=_2 K_=_3 K_=_4 K_=_5 n_=1 0.74218 0.42070 0.11101 9.86259e-006 9.86259e-006 n_=2 0.49672 0.26686 0.00233 4.46114e-011 4.46114e-011 n_=3 0.01221 0.00488 1.23422e-007 0 0 n_=4 0.00010 7.06889e-008 7.06889e-008 0 0
function out = dispmat(M,row_labels,col_labels); %% Matthew Oberhardt % 02/08/2013 % intended to display a matrix along with row and column labels. % % ex: % M = rand(2,3); % row_labels = { % col_labels = { % % if there are no labels for rows or cols, put % row_labels = %% check that the row & col labels are the right sizes [nrows,ncols] = size(M); %% populate if either of the inputs is empty if isempty(row_labels) row_labels = cell(1,nrows); for n = 1:nrows row_labels{1,n} = end end if isempty(col_labels) col_labels = cell(1,ncols); for n = 1:ncols col_labels{1,n} = end end assert(length(row_labels)==nrows, assert(length(col_labels)==ncols, row_labels = reshape(row_labels,1,length(row_labels)); col_labels = reshape(col_labels,1,length(col_labels)); %% remove spaces (since they are separators in printmat.m cols = strrep(col_labels, rows = strrep(row_labels, %% create labels, space delimited c_out = []; for n = 1:length(cols) c_out = [c_out,cols{n}, end c_out = c_out(1:end-1); r_out = []; for n = 1:length(rows) r_out = [r_out,rows{n}, end r_out = r_out(1:end-1); %% print printmat(M,
function output = nearest(input) [x,y]=size(input); output = repmat(uint8(0),x*2,y*2); [newwidth,newheight]=size(output); for i=1:y for j=1:x xloc = round ((j * (newwidth+1)) / (x+1)); yloc = round ((i * (newheight+1)) / (y+1)); output(xloc,yloc) = input(j,i); end end
% scale = [2 2]; % oldSize = size(inputImage); % newSize = max(floor(scale.*oldSize(1:2)),1); % % rowIndex = min(round(((1:newSize(1))-0.5)./scale(1)+0.5),oldSize(1)); colIndex = min(round(((1:newSize(2))-0.5)./scale(2)+0.5),oldSize(2)); % outputImage = inputImage(rowIndex,colIndex,:);
rowIndex = min(round(((1:newSize(1))-0.5)./scale(1)+0.5),oldSize(1)); colIndex = min(round(((1:newSize(2))-0.5)./scale(2)+0.5),oldSize(2));
x-minX y-minY --------- = --------- maxX-minX maxY-minY
jj = (j-1)*(c-1)/(scaleC*c-1) + 1 ii = (i-1)*(r-1)/(scaleR*r-1) + 1
% read a sample image inputI = imread( [r,c] = size(inputI); scale = [2 2]; % you could scale each dimension differently outputI = zeros(scale(1)*r,scale(2)*c, class(inputI)); for i=1:scale(1)*r for j=1:scale(2)*c % map from output image location to input image location ii = round( (i-1)*(r-1)/(scale(1)*r-1)+1 ); jj = round( (j-1)*(c-1)/(scale(2)*c-1)+1 ); % assign value outputI(i,j) = inputI(ii,jj); end end figure(1), imshow(inputI) figure(2), imshow(outputI)
xloc = (j * (newwidth+1)) / (x+1); yloc = (i * (newheight+1)) / (y+1);
% [dataClass, data] = libsvmread( % trainData = data(1:150,:); testData = data(151:270,:); trainClass = dataClass(1:150,:); testClass = dataClass(151:270,:); numTrain = size(trainData,1); numTest = size(testData,1); % sigma = 2e-3; rbfKernel = @(X,Y) exp(-sigma .* pdist2(X,Y, % % K = [ (1:numTrain) KK = [ (1:numTest) % model = svmtrain(trainClass, K, [predClass, acc, decVals] = svmpredict(testClass, KK, model); % C = confusionmat(testClass,predClass)
* optimization finished, nu = 0.933333 obj = -117.027620, rho = 0.183062 nSV = 140, nBSV = 140 Total nSV = 140 Accuracy = 85.8333% (103/120) (classification) C = 65 5 12 38
%function lotkavolterra % Plots time series and phase space diagrams. clear all; close all; t0 = 0; tf = 20; N0 = 20; P0 = 5; % Original plot r = 2; a = 1; b = 0.2; d = 1.5; % Time series plots lv = @(t,x)(lv_eq(t,x,r,a,b,d)); [t,NP] = ode45(lv,[t0,tf],[N0 P0]); N = NP(:,1); P = NP(:,2); figure plot(t,N,t,P, axis([0 20 0 50]) xlabel( ylabel( title([ saveas(gcf, legend( % Phase space plot figure quiver(N,P); axis([0 50 0 10]) %axis tight % Change variables r = 2; a = 1.5; b = 0.1; d = 1.5; %time series plots lv = @(t,x)(lv_eq(t,x,r,a,b,d)); [t,NP] = ode45(lv,[t0,tf],[N0 P0]); N = NP(:,1); P = NP(:,2); figure plot(t,N,t,P, axis([0 20 0 50]) xlabel( ylabel( title([ saveas(gcf, legend( % Phase space plot figure plot(N,P); axis([0 50 0 10]) % Change variables r = 2; a = 1; b = 0.2; d = 0.5; % Time series plots lv = @(t,x)(lv_eq(t,x,r,a,b,d)); [t,NP] = ode45(lv,[t0,tf],[N0 P0]); N = NP(:,1); P = NP(:,2); figure plot(t,N,t,P, axis([0 20 0 50]) xlabel( ylabel( title([ saveas(gcf, legend( % Phase space plot figure plot(N,P); axis([0 50 0 10]) % Change variables r = 0.5; a = 1; b = 0.2; d = 1.5; % Time series plots lv = @(t,x)(lv_eq(t,x,r,a,b,d)); [t,NP] = ode45(lv,[t0,tf],[N0 P0]); N = NP(:,1); P = NP(:,2); figure plot(t,N,t,P, axis([0 20 0 50]) xlabel( ylabel( title([ saveas(gcf, legend( % Phase space plot figure plot(N,P); axis([0 50 0 10]) % FUNCTION being called from external .m file %function dx = lv_eq(t,x,r,a,b,d) %N = x(1); %P = x(2); %dN = r*N-a*P*N; %dP = b*a*P*N-d*P; %dx = [dN;dP];
%% Data t = 0:100; f1 = 0.3; f2 = 0.07; u1 = sin(f1*t); cu1 = u2 = cos(f2*t); cu2 = v1 = 5*u1.^2; cv1 = v2 = 5*u2.^2; cv2 =
%% Method 1 (hold on) figure; plot(t, u1, plot(t, u2, plot(t, v1, plot(t, v2, xlabel( ylabel( legend(
%% Method 2 (subplots) figure; h(1) = subplot(2,1,1); % upper plot plot(t, u1, plot(t, u2, xlabel( ylabel( legend(gca, h(2) = subplot(2,1,2); % lower plot plot(t, v1, plot(t, v2, xlabel( ylabel( legend( linkaxes(h,
%% Method 3 (plotyy) figure; [ax, h1, h2] = plotyy(t,u1,t,v1); set(h1, set(h2, hold(ax(1), hold(ax(2), plot(ax(1), t, u2, plot(ax(2), t, v2, xlabel( ylabel(ax(1), ylabel(ax(2), legend(
function [u,v] = plotode(func,x,t,style) % [u,v] = PLOTODE(func,x,t,[style]) % plots the slope lines ODE defined in func(x,t) % for the vectors x and t % An optional plot style can be given (default is if nargin < 4 style = end; % http: [t,x] = meshgrid(t,x); v = func(x,t); u = ones(size(v)); dw = sqrt(v.^2 + u.^2); quiver(t,x,u./dw,v./dw,0.5,style); xlabel(
logistic = @(x,t)(x.* ( 1-x )); % xdot = f(x,t) t0 = linspace(0,10,20); x0 = linspace(0,2,11); plotode(@logistic,x0,t0,
>> questdlg( Warning: This functionality is no longer supported under the -nodisplay and -noFigureWindows startup options. For more information, see "Changes to -nodisplay and -noFigureWindows Startup Options" in the MATLAB Release Notes. To view the release note in your system browser, run web( > In uitools/private/warnfiguredialog at 19 In dialog at 37 In questdlg at 117 Warning: This functionality is no longer supported under the -nodisplay and -noFigureWindows startup options. For more information, see "Changes to -nodisplay and -noFigureWindows Startup Options" in the MATLAB Release Notes. To view the release note in your system browser, run web( > In uitools/private/warnfiguredialog at 19 In uiwait at 41 In questdlg at 378
» [usejava( ans = 1 1 1 0 » get(0, ans = 1 1 1600 1024 » feature( ans = 1 » questdlg( [works fine] » plot(1:10) [works fine]
» [usejava( ans = 1 1 1 1 » get(0, ans = 1 1 1600 1024 » feature( ans = 0 » questdlg( Warning: This functionality is no longer supported .... » plot(1:10) [no plot]
» [usejava( ans = 1 1 1 0 » get(0, ans = 1 1 1600 1024 » feature( ans = 0 » questdlg( Warning: This functionality is no longer supported .... » plot(1:10) [no plot]
screenSize = get(0, if isequal(screenSize(3:4),[1 1]) % else % end
parfor k=1:N scr = get(0, if isequal(scr(3:4),[1 1]) % text-based version else % GUI version end end
scr = get(0, istext = isequal(scr(3:4),[1 1]); % or istext = ~usejava( parfor k=1:N if istext % text-based version else % GUI version end end
my_array = [1x219 uint16] [ 138] [1x0 uint16] <---- row [1x2 uint16] [1x0 uint16] [] <---- row [ 210] [1x7 uint16] [1x0 uint16] [1x4 uint16] [1x0 uint16] [ 280] [] [] [ 293] [ 295] [1x2 uint16] [ 298] [1x0 uint16] [1x8 uint16] [1x5 uint16]
>> M = magic(4) % M = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1 >> rowIndex = [1 3]; % >> columnIndex = []; % >> subM = M(rowIndex,columnIndex) subM = Empty matrix: 2-by-0
>> a = zeros(1,0); % >> b = zeros(0,1); % >> c = []; %
>> b*a ans = [] % >> a*b ans = 0 % >> a*c ans = Empty matrix: 1-by-0 % >> c*b ans = Empty matrix: 0-by-1 % >> b*c ??? Error using ==> mtimes Inner matrix dimensions must agree. % % % %
>> [ones(1,2);zeros(0,9)] Warning: Concatenation involves an empty array with an incorrect number of columns. This may not be allowed in a future release. ans = 1 1 >> [ones(2,1),zeros(9,0)] Warning: Concatenation involves an empty array with an incorrect number of rows. This may not be allowed in a future release. ans = 1 1
classdef A < handle %A Summary of this class goes here % Detailed explanation goes here properties end methods end end
clear all clc % Try to use the default [] for an array of A objects. my_array = []; my_array(1) = A;
??? The following error occurred converting from A to double: Error using ==> double Conversion to double from A is not possible. Error in ==> main2 at 6 my_array(1) = A;
% Now try to use the class dependent empty for an array of A objects. my_array = A.empty; my_array(1) = A;
for t = 1:size(zeros(0,0),1); % Or simply [] end for t = 1:size(zeros(1,0),1); % Or zeros(0,1) end
for t = [] % 1 end for t = ones(1, 0) % 2 end for t = ones(0, 1) % 3 end
function waitHello disp( pause(3); %pauses 3 seconds disp( quit;
start "MATLAB" %START_WAIT% "%MATLAB_BIN_DIR%\%MATLAB_ARCH%\matlab" %MATLAB_ARGS%
start ["window title"] [/wait] myprogram.exe args ...
) else if (%opt%) == (-wait) ( set START_WAIT=/wait ) else (
from 255 to 160 -> white from 159 to 120 -> pink from 119 to 50 -> brown from 49 to 0 -> dark
R = linspace(0,t(1),50); G = linspace(0,t(2),50); B = linspace(0,t(3),50); T = [R map(1:50, :) = T;
I = linspace(0,1,161); imagesc(I(:, ones(10))) colormap(map)
T = [0, 0, 0 % 101, 67, 33 % 255, 105, 180 % 255, 255, 255 % 255, 255, 255]./255; %
I = linspace(0,1,255); imagesc(I(ones(1,10),:) colormap(map)
function foo(x,y,z) %FOO One-line description goes here % % foo(x,y,z) % % Multi-line paragraphs of descriptive text go here. It % span lines. It % re-wrap lines. In the editor, you can highlight paragraphs, right-click, % and choose "Wrap selected comments" to re-flow the text. % % More detailed help is in the <a href="matlab: help foo>extended_help">extended help</a>. % It % a single screen, and then break out obscure parts to separate sections. % % Examples: % foo(1,2,3) % % See also: % BAR % SOMECLASS/SOMEMETHOD disp(x+y+z); function extended_help %EXTENDED_HELP Some additional technical details and examples % % Here is where you would put additional examples, technical discussions, % documentation on obscure features and options, and so on. error(
function testhelp %TESTHELP is an example (this is the H1 line) % % SYNOPSIS: a=testhelp(b,c) % % INPUT b: some input parameter % c: (opt) some optional input parameter. Default: [] % % OUTPUT a: some output parameter % % REMARKS This is just an example, it won % % SEE ALSO testHelpFunction % % created with MATLAB ver.: 7.11.0.584 (R2010b) on Mac OS X Version: 10.6.4 Build: 10F569 % % created by: Jonas % DATE: 01-Oct-2010 %
% ... % % See also: % this_other_function() % % <author>
% Other formats are supported, refer to documentation. options.format = % I don % However, if providing a demo, turning this on is a fantastic way to embed % figures in the resulting document. options.evalCode = false; % You can run this in a loop over files in the currrent directory if desired. publish(
/your/path/to/matlab/bin/matlab -nosplash -nodisplay -nodesktop -r "runAllMyTests"
function runAllMyTests import matlab.unittest.TestSuite; import matlab.unittest.TestRunner; import matlab.unittest.plugins.TAPPlugin; import matlab.unittest.plugins.ToFile; try % Create the suite and runner suite = TestSuite.fromPackage( runner = TestRunner.withTextOutput; % Add the TAPPlugin directed to a file in the Jenkins workspace tapFile = fullfile(getenv( runner.addPlugin(TAPPlugin.producingOriginalFormat(ToFile(tapFile))); runner.run(suite); catch e; disp(e.getReport); exit(1); end; exit force;
IF EXIST "C:\Program Files (x86)\MATLAB\R2013b\bin\win32\matlab.exe" ( REM WinXP "C:\Program Files (x86)\MATLAB\R2013b\bin\win32\matlab.exe" -r "Run_Tests;exit" -logfile matlab.log ) ELSE ( REM Win7 "C:\Program Files\MATLAB\R2013b\bin\win32\matlab.exe" -r "Run_Tests;exit" -logfile matlab.log )
tic,for t= 1:1e6, x=x; end,toc %This runs very fast, about 0.07 sec y=x; tic,for t= 1:1e6, y=x; end,toc %This runs fast, about 0.11 sec tic,for t= 1:1e6, x; end,toc %This takes over half a second?!
width = p .* d; gradx = m .* cos(g) * width; grady = m .* sin(g) * width; normx = - gradx; normy = - grady; normz = 1; len = sqrt(normx .^ 2 + normy .^ 2 + normz .^ 2); x = normx ./ len; y = normy ./ len; z = normz ./ len;
float2 du float2 dv float D = sample(depthtex, uv) float D1 = sample(depthtex, uv + du) float D2 = sample(depthtex, uv + dv) float3 A = float3(du*width_of_image, 0, D1-D) float3 B = float3(0, dv*height_of_image, D2-D) float3 normal = AXB return normal
float D = sample(depthtex, uv) float D1 = sample(depthtex, uv + du) float D3 = sample(depthtex, uv - du) float dx1 = (D1 - D)/du float dx2 = (D - D3)/du float dxx = (dx2 - dx1)/du
float Sample(const Texture& texture, vector_2d uv){ return texture.data[(int)(uv.x * texture.width + 0.5)][(int)(uv.y * texture.height + 0.5]; }
b = a > 5; % if a = [9,3,5,6], b = [1,0,0,1] a(~b) = 3; c = a > 10; a(b&c) = ...
% MATLAB % A, X and Y are numerics % COND is a logical condition. A = COND.*X + (~COND).*Y ;
function c = conditional(condition , a , b) if condition c = a; else c = b; end end
newvector = vector; for i = 1 : n-1 newvector = [newvector vector]; end
N= 10 ;% ASLO Try for values N= 10, 100, 1000, 10000 % time for tony_trick tic; A=(1:N) B=A(:,ones(N,1)); C=B(:) t_tony=toc; clearvars -except t_tony N % time for repmat tic; A=(1:N); B=repmat(A,1,N); t_repmat=toc; clearvars -except t_tony t_repmat N
function vec = repvec( vec, rows, cols ) %REPVEC Replicates a vector. % Replicates a vector rows times in dim1 and cols times in dim2. % Auto optimization included. % Faster than repmat()!!! % % Copyright 2012 by Marcel Schnirring if ~isscalar(rows) || ~isscalar(cols) error( end if rows == 1 && cols == 1 return % no modification needed end % check parameters if size(vec,1) ~= 1 && size(vec,2) ~= 1 error( end % check type of vector (row/column vector) if size(vec,1) == 1 % set flag isrowvec = 1; % swap rows and cols tmp = rows; rows = cols; cols = tmp; else % set flag isrowvec = 0; end % optimize code -> choose version if rows == 1 version = 2; else version = 1; end % run replication if version == 1 if isrowvec % transform vector vec = vec end % replicate rows if rows > 1 cc = vec(:,ones(1,rows)); vec = cc(:); %indices = 1:length(vec); %c = indices %cc = c(:,ones(rows,1)); %indices = cc(:); %vec = vec(indices); end % replicate columns if cols > 1 %vec = vec(:,ones(1,cols)); indices = (1:length(vec)) indices = indices(:,ones(1,cols)); vec = vec(indices); end if isrowvec % transform vector back vec = vec end elseif version == 2 % calculate indices indices = (1:length(vec)) % replicate rows if rows > 1 c = indices(:,ones(rows,1)); indices = c(:); end % replicate columns if cols > 1 indices = indices(:,ones(1,cols)); end % transform index when row vector if isrowvec indices = indices end % get vector based on indices vec = vec(indices); end end
for i = 1:N ... ... msg = sprintf( display(msg) end
n=0; for ... ... fprintf(repmat( fprintf(msg); n=numel(msg); end
reverseStr = for i = 1:N ... ... msg = sprintf( fprintf([reverseStr, msg]); reverseStr = repmat(sprintf( end
dispstat( dispstat(sprintf( for i = 97:100 dispstat(sprintf( %doing some heavy stuff here end dispstat(
11:25:37 Begining the process... 11:25:37 Progress 100% Finished.
% fprintf( for i=1:10 % % fprintf( % pause(.5) end % fprintf(
for i=1:numel(folders) foldername = folders(i).name; if foldername(1) == continue; end do_something(foldername) end
for i=3:numel(folders) do_something(folders(i).name) end
>> f = dir; >> for k = 1 : length(f), disp(f(k).name), end !hello . ..
function listing = dir2(varargin) if nargin == 0 name = elseif nargin == 1 name = varargin{1}; else error( end listing = dir(name); inds = []; n = 0; k = 1; while n < 2 && k <= length(listing) if any(strcmp(listing(k).name, { inds(end + 1) = k; n = n + 1; end k = k + 1; end listing(inds) = [];
>> f = dir2; >> for k = 1 : length(f), disp(f(k).name), end !hello
listing = dir; for i = 1:length(listing) if ~strcmp(listing(i).name(1), % Do something ... end end
listing = dir(directoryname); listing(1:2)=[]; % here you erase these . and .. items from listing
function d = dir2(folderPath) % DIR2 lists the files in folderPath ignoring the if nargin<1; folderPath = d = dir(folderPath); d = d(~ismember({d.name},{ end
d = dir( d(1:2)=[]; % removing dots d = d([d.isdir]) % [d.isdir] returns a logical array of 1s representing folders and 0s for other entries
str = [name,address] = strtok(str, address = address(2:end);
>> email = email = johndoe@hotmail.com >> email == ans = Columns 1 through 13 0 0 0 0 0 0 0 1 0 0 0 0 0 Columns 14 through 19 0 0 0 0 0 0 >> at = find(email == at = 8 >> email(1:at-1) ans = johndoe >> email(at+1:end) ans = hotmail.com
String a[] = email.split("@"); String def = null; String ghi = null; for(int i=0;i<a.length;i++){ def = a[0]; ghi = a[1]; }
A_1 = [10 200 7 150] A_2 = [0.001 0.450 0.007 0.200]
corr(A_1, A_2); %Returns 0.956766573975184 (Requires stats toolbox)
M = corrcoef([A_1 A_2]): %Returns [1 0.956766573975185; 0.956766573975185 1]; M(2,1); %Returns 0.956766573975184
condition = @(x) (x-mean(x))./std(x); %Function to subtract mean AND normalize standard deviation
[p,err] = polyfit(x,y,1); % First order polynomial y_fit = polyval(p,x,err); % Values on a line y_dif = y - y_fit; % y value difference (residuals) SSdif = sum(y_dif.^2); % Sum square of difference SStot = (length(y)-1)*var(y); % Sum square of y taken from variance rsq = 1-SSdif/SStot; % Correlation
B = A; columnSums = sum(B); for i = 1:numel(columnSums) B(:,i) = B(:,i)./columnSums(i); end
a=[1 4;4 10] a = 1 4 4 10 a*diag(1./sum(a,1)) ans = 0.2000 0.2857 0.8000 0.7143
>>> A = [[1,4],[4,10]] >>> [[float(i)/j for i,j in zip(a,map(sum,zip(*A)))] for a in A] [[0.20000000000000001, 0.2857142857142857], [0.80000000000000004, 0.7142857142857143]]
>>> colsums = map(sum,zip(*A)) >>> [[float(i)/j for i,j in zip(a,colsums)] for a in A] [[0.20000000000000001, 0.2857142857142857], [0.80000000000000004, 0.7142857142857143]]
p.color.red = .2; p.color.green = .4; p.color.blue = .7;
p(1).str = p(1).r = 1; p(1).g = 1; p(1).b = 1; p(2).str = p(2).r = 0; p(2).g = 0; p(2).b = 0;
names = { [p(1:2).str] = names{:}; red = num2cell([1 0]); [p(1:2).r] = red{:};
p.r = [1 0]; p.g = [1 0]; p.b = [1 0]; p.str = { p1 = [p.r(1) p.g(1) p.b(1)];
>> s1 = repmat( struct( >> s2 = struct( >> whos Name Size Bytes Class Attributes s1 1x1000 204192 struct s2 1x1 24372 struct
public Bicycle(int startCadence, int startSpeed, int startGear) { gear = startGear; cadence = startCadence; speed = startSpeed; } public Bicycle(int startCadence, int startSpeed) { gear = 1; cadence = startCadence; speed = startSpeed; }
classdef Bicycle < handle properties (Access=public) gear cadence speed end methods (Access = public) function self = Bicycle(varargin) if nargin>2 self.gear = varargin{3}; else self.gear = 1; end self.cadence = varargin{1}; self.speed = varargin{2}; end end end
methods (Access = public) function self = Bicycle(startCadence, startSpeed, startGear) if nargin>2 self.gear = startGear; else self.gear = 1; end self.cadence = startCadence; self.speed = startSpeed; end end
x = linspace(1, 10, 10); n = 3; y = x(1 : n : end); % => 1 4 7 10 y = x(n : n : end); % => 3 6 9
% load image img8=imread( % downsample downSample=img8(1:2:end,1:2:end); % upsample upSample(1:2:end,1:2:end) = downSample(1:end,1:end)
figure; hold on; plot(0,0, plot(0,0, plot(0,0, leg = legend(
figure; t=linspace(0,10,100); plot(t,sin(t)); %% ADD THE LEGEND OF PLOT ABOVE
figure t=linspace(0,10,100); plot(t,sin(t)); hold on; h = zeros(3, 1); h(1) = plot(NaN,NaN, h(2) = plot(NaN,NaN, h(3) = plot(NaN,NaN, legend(h,
figure t=linspace(0,10,100); plot(t,sin(t)); hold on; h = zeros(3, 1); h(1) = plot(0,0, h(2) = plot(0,0, h(3) = plot(0,0, legend(h,
x = 0:pi/20:2*pi; y = sin(x); plot(x,y) axis tight legend( text(5.7, 0.75, text(5.1, 0.78,
hFig = figure( . . . function closeHandler (src,evnt) CTRL+C <--- I am looking for such a command end
function terminateInCode() hFig = figure( while(1) plot(10*rand,10*rand, pause(0.1); end; function closeHandler (src,evnt) delete(hFig); error( end end
function terminateExecution %terminateExecution Emulates CTRL-C % terminateExecution Stops operation of a program by emulating a % CTRL-C press by the user. % % Running this function % %Example: %for ix = 1:100 % disp(ix) % if ix>20 % terminateExecution; % end %end %1) request focus be transferred to the command window % (H/T http: cmdWindow = com.mathworks.mde.cmdwin.CmdWin.getInstance(); cmdWindow.grabFocus(); %2) Wait for focus transfer to complete (up to 2 seconds) focustransferTimer = tic; while ~cmdWindow.isFocusOwner pause(0.1); %Pause some small interval if (toc(focustransferTimer) > 2) error( end end %3) Use Java robot to execute a CTRL+C in the (now focused) command window. %3.1) Setup a timer to relase CTRL + C in 1 second % Try to reuse an existing timer if possible (this would be a holdover % from a previous execution) t_all = timerfindall; releaseTimer = []; ix_timer = 1; while isempty(releaseTimer) && (ix_timer<= length(t_all)) if isequal(t_all(ix_timer).TimerFcn, @releaseCtrl_C) releaseTimer = t_all(ix_timer); end ix_timer = ix_timer+1; end if isempty(releaseTimer) releaseTimer = timer; releaseTimer.TimerFcn = @releaseCtrl_C; end releaseTimer.StartDelay = 1; start(releaseTimer); %3.2) Press press CTRL+C pressCtrl_C %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% function pressCtrl_C import java.awt.Robot; import java.awt.event.*; SimKey=Robot; SimKey.keyPress(KeyEvent.VK_CONTROL); SimKey.keyPress(KeyEvent.VK_C); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% function releaseCtrl_C(ignore1, ignore2) import java.awt.Robot; import java.awt.event.*; SimKey=Robot; SimKey.keyRelease(KeyEvent.VK_CONTROL); SimKey.keyRelease(KeyEvent.VK_C);
import java.awt.Robot; import java.awt.event.*; SimKey=Robot; SimKey.keyPress(KeyEvent.VK_CONTROL); SimKey.keyPress(KeyEvent.VK_C);
function interrupt import java.awt.event.KeyEvent import java.util.Calendar import java.lang.reflection.* cmdwin = handle(com.mathworks.mde.cmdwin.CmdWin.getInstance().getComponent(0).getComponent(0).getComponent(0), argSig = javaArray( argSig(1) = java.lang.Class.forName( method = cmdwin.getClass().getDeclaredMethod( method.setAccessible(true); cal = Calendar.getInstance(); args = javaArray( args(1) = KeyEvent(cmdwin,KeyEvent.KEY_PRESSED,cal.getTime().getTime(),KeyEvent.CTRL_DOWN_MASK,KeyEvent.VK_C,KeyEvent.CHAR_UNDEFINED); method.invoke(cmdwin,args);
function terminateInCode() hFig = figure( stop=0; while(~stop) plot(10*rand,10*rand, pause(0.1); end; function closeHandler (src,evnt) delete(hFig); stop=1; end end
function [ point ] = PointDoubling( x,y,p,a ) %UNTITLED2 Summary of this function goes here % Detailed explanation goes here if y==0 point= return; end a2=(3*(x^2))+a; b2=(2*y); i=1; while 1 if mod(b2*i,p)==1 break; end i=i+1; end s=mod(a2*i,p); x1=mod(((s^2)-(2*x)),p); y1=mod(((-y)+(s*(x-x1))),p); point=[x1,y1]; end
for c=1:10 g=f(c); % somehow bind value of c seed=1.1; % my guess for the root of the equation root=newton(g,seed); % compute the actual root end
f = @(c,x)( @(x)(x^3+c*x^2+2*x+3) ); for c=1:10 g=f(c); % g is @(x)(x^3+c*x^2+2*x+3) for that c .... end
function y = forwardBackwardFFT(image) F = fft2(image); mag = sqrt(real(F).^2 + imag(F).^2); phase = atan(imag(F)./real(F)); re = sqrt((mag.^2)./(1 + tan(phase).^2)); im = re.*tan(phase); F = re + i*im; f = ifft2(F); subplot(1,2,1); imshow(image); Title( subplot(1,2,2); imshow(f); Title( y = f;
function y = forwardBackwardFFT(image) F = fft2(image); % f = ifft2(F); subplot(1,2,1); imshow(image); title( subplot(1,2,2); imshow(f, []); title( y = f;
mag = sqrt(real(F).^2 + imag(F).^2); phase = atan2(imag(F),real(F)); re = mag .* cos(phase); im = mag .* sin(phase); F = re + 1i*im;
function [Q, R] = Gram_Schmidt(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); v = zeros(n, 1); for j = 1:n v = A(:,j); for i = 1:j-1 R(i,j) = sum( v .* conj( Q(:,i) ) .* w ) / ... sum( Q(:,i) .* conj( Q(:,i) ) .* w ); v = v - R(i,j) * Q(:,i); end R(j,j) = norm(v); Q(:,j) = v / R(j,j); end end
A = complex( rand(360000,100), rand(360000,100)); w = rand(360000, 1); [Q, R] = Gram_Schmidt(A, w);
A = complex( rand( 100, 10), rand( 100, 10)); w = rand( 100, 1); [Q , R ] = Gram_Schmidt( A, w); [Q2, R2] = Gram_Schmidt2( A, w); zeros1 = norm( Q - Q2 ); zeros2 = norm( R - R2 );
function [Q, R] = Gram_Schmidt1(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); for j = 1:n v = A(:,j); QQ = Q(:,1:j-1); QQ = bsxfun(@rdivide, bsxfun(@times, w, conj(QQ)), w. for i = 1:j-1 R(i,j) = (v. v = v - R(i,j) * Q(:,i); end R(j,j) = norm(v); Q(:,j) = v / R(j,j); end end
function [Q, R] = Gram_Schmidt2(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); QQ = complex(zeros(m, n-1)); for j = 1:n if j>1 qj = Q(:,j-1); QQ(:,j-1) = (conj(qj) .* w) ./ (w. end v = A(:,j); for i = 1:j-1 R(i,j) = (v. v = v - R(i,j) * Q(:,i); end R(j,j) = norm(v); Q(:,j) = v / R(j,j); end end
% some random data >> M = 10000; N = 100; >> A = complex(rand(M,N), rand(M,N)); >> w = rand(M,1); % time >> timeit(@() Gram_Schmidt(A,w), 2) % original version ans = 1.2444 >> timeit(@() Gram_Schmidt1(A,w), 2) % first attempt (vectorized) ans = 2.0990 >> timeit(@() Gram_Schmidt2(A,w), 2) % final version ans = 0.4698 % check results >> [Q,R] = Gram_Schmidt(A,w); >> [Q2,R2] = Gram_Schmidt2(A,w); >> norm(Q-Q2) ans = 4.2796e-14 >> norm(R-R2) ans = 1.7782e-12
function [Q, R] = Gram_Schmidt3(A, w) [m, n] = size(A); Q = zeros(m, n, R = zeros(n, n, QQ = zeros(m, n, for j = 1:n v = A(:,j); for i = 1:j-1 R(i,j) = (v. v = v - R(i,j) * Q(:,i); end R(j,j) = norm(v); Q(:,j) = v / R(j,j); QQ(:,j) = (conj(Q(:,j)) .* w) ./ (w. end end
% GPU AA = gpuArray(A); [Q3,R3] = Gram_Schmidt3(AA, w);
A_j1 = Q_j1 * R_1,1 A_j2 = Q_j1 * R_1,2 + Q_j2 * R_2,2 A_j3 = Q_j1 * R_1,3 + Q_j2 * R_2,3 + Q_j3 * R_3,3
A_j1 = ( A_j1 / | A_j1 | ) * | A_j1 | = Q_j1 * R_1,1
R_1,2 = Q_j1 dot Aj2 R_1,3 = Q_j1 dot Aj3 ... R_1,j(j>1) = A_j dot Q_j1
for i = 1,n R_ii = |A_i| A_i is the ith column of A, |A_i| is magnitude of A_i Q_i = A_i / R_ii Q_i is the ith column of Q for j = i, n R_ij = | A_j dot Q_i | A_j = A_j - R_ij * Q_i end end
w = w / | w | for i = 1,n R_ii = |A_i inner product w| Q_i = A_i / R_ii for j = i, n R_ij = | (A_i inner product w) dot Q_i | A_j = A_j - R_ij * Q_i end end
function [Q, R] = Gram_Schmidt_2(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); for j = 1:n aCol = A(:,j); for i = 1:(j-1) R(i,j) = ctranspose(Q(:,j)) * aCol; aCol = aCol - R(i,j) * Q(:,j); end amp_A_col = norm(aCol); R(j,j) = amp_A_col; Q(:,j) = aCol / amp_A_col; end end
function [Q, R] = Gram_Schmidt_2(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); for j = 1:n aCol = A(:,j); for i = 1:(j-1) R(i,j) = sum( aCol .* conj( Q(:,i) ) .* w ) / ... sum( Q(:,i) .* conj( Q(:,i) ) .* w ); aCol = aCol - R(i,j) * Q(:,j); end amp_A_col = norm(aCol); R(j,j) = amp_A_col; Q(:,j) = aCol / amp_A_col; end end
function [Q, R] = Gram_Schmidt_3(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); Q_sw = complex(zeros(m, n)); sw = w .^ 0.5; for j = 1:n aCol = A(:,j); aCol_sw = aCol .* sw; for i = 1:(j-1) numTerm = ctranspose( Q_sw(:,i) ) * aCol_sw; denTerm = ctranspose( Q_sw(:,i) ) * Q_sw(:,i); R(i,j) = numTerm / denTerm; aCol_sw = aCol_sw - R(i,j) * Q_sw(:,i); end aCol = aCol_sw ./ sw; amp_A_col = norm(aCol); R(j,j) = amp_A_col; Q(:,j) = aCol / amp_A_col; Q_sw(:,j) = Q(:,j) .* sw; end end
function [Q, R] = Gram_Schmidt_4(A, w) [m, n] = size(A); Q = complex(zeros(m, n)); R = complex(zeros(n, n)); for j = 1:n aCol = A(:,j); for i = 1:(j-1) cqw = conj(Q(:,i)) .* w; R(i,j) = ( transpose( aCol ) * cqw) ... / (transpose( Q(:,i) ) * cqw); aCol = aCol - R(i,j) * Q(:,i); end amp_A_col = norm(aCol); R(j,j) = amp_A_col; Q(:,j) = aCol / amp_A_col; end end
function Gram_Schmidt_tester_2 nSamples = 360000; nMeas = 100; nMeas = 15; A = complex( rand(nSamples,nMeas), rand(nSamples,nMeas)); w = rand(nSamples, 1); profile on; [Q1, R1] = Gram_Schmidt_basic(A); profile off; data1 = profile ("info"); tData1=data1.FunctionTable(1).TotalTime; approx_zero1 = A - Q1 * R1; max_value1 = max(max(abs(approx_zero1))); profile on; [Q2, R2] = Gram_Schmidt_w_Orig(A, w); profile off; data2 = profile ("info"); tData2=data2.FunctionTable(1).TotalTime; approx_zero2 = A - Q2 * R2; max_value2 = max(max(abs(approx_zero2))); sw=w.^0.5; profile on; [Q3, R3] = Gram_Schmidt_sqrt_w(A, w); profile off; data3 = profile ("info"); tData3=data3.FunctionTable(1).TotalTime; approx_zero3 = A - Q3 * R3; max_value3 = max(max(abs(approx_zero3))); profile on; [Q4, R4] = Gram_Schmidt_4(A, w); profile off; data4 = profile ("info"); tData4=data4.FunctionTable(1).TotalTime; approx_zero4 = A - Q4 * R4; max_value4 = max(max(abs(approx_zero4))); profile on; [Q5, R5] = Gram_Schmidt_5(A, w); profile off; data5 = profile ("info"); tData5=data5.FunctionTable(1).TotalTime; approx_zero5 = A - Q5 * R5; max_value5 = max(max(abs(approx_zero5))); profile on; [Q2a, R2a] = Gram_Schmidt2a(A, w); profile off; data2a = profile ("info"); tData2a=data2a.FunctionTable(1).TotalTime; approx_zero2a = A - Q2a * R2a; max_value2a = max(max(abs(approx_zero2a))); profshow (data1, 6); profshow (data2, 6); profshow (data3, 6); profshow (data4, 6); profshow (data5, 6); profshow (data2a, 6); sprintf( data1.FunctionTable(1).FunctionName, data1.FunctionTable(1).TotalTime, nSamples, nMeas, max_value1) sprintf( data2.FunctionTable(1).FunctionName, data2.FunctionTable(1).TotalTime, nSamples, nMeas, max_value2) sprintf( data3.FunctionTable(1).FunctionName, data3.FunctionTable(1).TotalTime, nSamples, nMeas, max_value3) sprintf( data4.FunctionTable(1).FunctionName, data4.FunctionTable(1).TotalTime, nSamples, nMeas, max_value4) sprintf( data5.FunctionTable(1).FunctionName, data5.FunctionTable(1).TotalTime, nSamples, nMeas, max_value5) sprintf( data2a.FunctionTable(1).FunctionName, data2a.FunctionTable(1).TotalTime, nSamples, nMeas, max_value2a) end
ans = Time for Gram_Schmidt_basic is 0.889 sec with 360000 samples and 15 meas, max value is 1.57009e-16 ans = Time for Gram_Schmidt_w_Orig is 0.952 sec with 360000 samples and 15 meas, max value is 6.36717e-16 ans = Time for Gram_Schmidt_sqrt_w is 0.390 sec with 360000 samples and 15 meas, max value is 6.47366e-16 ans = Time for Gram_Schmidt_4 is 0.452 sec with 360000 samples and 15 meas, max value is 6.47366e-16 ans = Time for Gram_Schmidt_5 is 2.636 sec with 360000 samples and 15 meas, max value is 6.47366e-16 ans = Time for Gram_Schmidt2a is 0.905 sec with 360000 samples and 15 meas, max value is 6.68443e-16
function [Q, R] = Gram_Schmidt5(A, w) Q = A; n_dimensions = size(A, 2); R = zeros(n_dimensions); R(1, 1) = norm(Q(:, 1)); Q(:, 1) = Q(:, 1) ./ R(1, 1); for i = 2 : n_dimensions Qw = (Q(:, i - 1) .* w) R(i - 1, i : end) = Qw(2:end) / Qw(1); %% Surprisingly this loop beats the matrix multiply for j = i : n_dimensions Q(:, j) = Q(:, j) - Q(:, i - 1) * R(i - 1, j); end %% This multiply is slower than above % Q(:, i : end) = ... % Q(:, i : end) - ... % Q(:, i - 1) * R(i - 1, i : end); R(i, i) = norm(Q(:,i)); Q(:, i) = Q(:, i) ./ R(i, i); end
int main() { double x = 0.3; printf("%.40f\n", (x*x*x)); long double y = 0.3; printf("%.40f\n", (double)(y*y*y)); }
0.0269999999999999996946886682280819513835 0.0269999999999999962252417162744677625597
irb> 0.3 ** 3 => 0.026999999999999996 irb> 0.3 * 0.3 * 0.3 => 0.027
octave:13> format hex octave:14> 0.3^3 ans = 3f9ba5e353f7ced8 octave:15> 0.3*0.3*0.3 ans = 3f9ba5e353f7ced9 octave:20> [0.3 0;0 0.3]^3 ans = 3f9ba5e353f7ced9 0000000000000000 0000000000000000 3f9ba5e353f7ced9 octave:21> [0.3 0;0 0.3] * [0.3 0;0 0.3] * [0.3 0;0 0.3] ans = 3f9ba5e353f7ced9 0000000000000000 0000000000000000 3f9ba5e353f7ced9
int main() { double x = .3; int i = 3; long double ix = 1.0, lx = (long double) x; int mask = 1; while(i != 0) { if( i & mask ) { ix *= lx; i -= mask; } mask += mask; lx *= lx; } printf("%.40f\n", (double) ix); }
rng(1) figure() x = 1:50; y = rand(1, 50); plot(x,y) title( xlabel( ylabel(
h1=hgopen( allaxes=get(h1, for a=1:length(allaxes) ax=allaxes(a); allines=get(ax, for l=1:length(allines) lin=allines(l); values=get(lin, subplots{a}{l}=values; end end
classdef Foo > handle methods function o = Foo(file), end function bar(o,file), end end end
<binding name="Foo" ctype="FILE"/> <binding name="bar" ctype="MCOSCLASS FILE"/>
>> a = 1:3; >> N = 3; >> b = kron(a,ones(1,N)) b = 1 1 1 2 2 2 3 3 3
>> b = a(ceil((1:N*numel(a))/N)) b = 1 1 1 2 2 2 3 3 3
a = [1 2 3]; N = 3; b = reshape(repmat(a,N,1), 1, [])
>> n=3; >> a(floor((0:size(a,2)*n-1)/n)+1) ans = 1 1 1 2 2 2 3 3 3
b = a * fliplr(sortrows(repmat(eye(numel(a)),n,1))).
[~, ind] = ind2sub([n 1],1:numel(a)*n); b = a(ind);
% To get b = [1 1 1 2 2 2 3 3 3] N = 3; a = [1 2 3]; temp_a = a(ones(N,1),:); b = reshape(temp_a,1,numel(temp_a)); % To get b = [1 2 3 1 2 3 1 2 3] N = 3; a = [1 2 3]; temp_a = a(ones(N,1),:); b = reshape(temp_a
% x = (1:100000) idx = ( rand(size(x)) < 0.5 ); x(idx) = x(idx) + rand(sum(idx),1); % tic, q1 = ~mod(x, 1); toc tic, q2 = x==double(uint64(x)); toc tic, q3 = x==floor(x); toc % assert( isequal(q1,q2,q3) )
Elapsed time is 0.012253 seconds. Elapsed time is 0.014201 seconds. Elapsed time is 0.005665 seconds.
>> input=1.3; >> assert(abs(round(input)-input)<eps*2, ??? That number is not an integer. >> input=3; >> assert(abs(round(input)-input)<eps*2, >>
function boolResult = fnIsInteger(input) %validate input if isempty(input) error( elseif ~isnumeric(input) error( end boolResult = (imag(input) == 0) & (round(input) == input); end
>> x = rand(100000, 1); >> tic; for ii = 1:100000; ~mod(x(ii), 1); end; toc; Elapsed time is 0.003960 seconds. >> tic; for ii = 1:100000; fnIsInteger(x(ii)); end; toc; Elapsed time is 0.217397 seconds. >> tic; ~mod(x, 1); toc; Elapsed time is 0.000967 seconds. >> tic; fnIsInteger(x); toc; Elapsed time is 0.003195 seconds.
>> double(uint64(21/22)) ans = 1 >> double(uint64(22/22)) ans = 1
floor(22/22)==21.99999999999999999999999999999999999/22
>> mod(22,22) ans = 0 >> (21.99999999999999999999999999999999999/22) ans = 1
>> a=magic(30); >> [r,c]=find(a==min(min(a))) r = 1 c = 8
A = rand(30); % some matrix [minColVal, minColIdx] = min(A); [minRowVal, minRowIdx] = min(minColVal); minVal = minRowVal; minValIdx = [minColIdx(minRowIdx), minRowIdx];
>> min_index = @(matrix) find(matrix == min(reshape(matrix, [1,numel(matrix)]))); >> a=magic(30); >> [r,c]=min_index(a) r = 1 c = 8
plot(x1, y1, color1); hold on; plot(x2, y2, color1); hold on; plot(x3, y3, color2); hold on; plot(x4, y4, color2); hold on; legend({color1, color2})
h1 = plot(x1, y1, color1); hold on; plot(x2, y2, color1); h2 = plot(x3, y3, color2); plot(x4, y4, color2); legend([h1 h2],{
hold on plot([x1 NaN x2], [y1 NaN y2], plot([x3 NaN x4], [y3 NaN y4], legend({ hold off
% Sample data order = -1:2; % number of orders to plot x = (0:0.01:10) % Plot each instance of data in a separate graph for i=1:numel(order) plot(x,besselj(order(i),x)) hold all % Amend legend to include new plot [~,~,~,current_entries] = legend; legend([current_entries {sprintf( end
% Sample data order = -1:2; % number of orders to plot x = (0:0.01:10) % Plot each instance of data in a separate graph for i=1:numel(order) plot(x,besselj(order(i),x)) hold on % Amend legend entries(i) = { sprintf( end % Create legend using the legend(
function repro_incremental_legend %REPRO_INCREMENTAL_LEGEND Demonstrate plots with incrementally updated legend figure; hold on x = 1:5; names = { for i = 1:4 myplot(gca, x, x.*(1/i), names{i}); update_legend(gca); pause(1); % remove in real code end function myplot(ax, x, y, name) %MYPLOT Wrapper for plot() that respects ColorOrder and sets DisplayName h = plot(ax, x, y); % plot before setting color so HOLD state is respected set(h, ColorOrder = get(ax, nLines = numel(get(ax, set(h, function update_legend(ax) %UPDATE_LEGEND Update legend based on current child lines kids = get(ax, kids = kids(end:-1:1); % Legend seems to have the opposite ordering legend(get(kids,
t = 0:.1:2*pi; for k=1:5 offset = k/7; m(:,k) = t+offset end hSLines = plot(t,sin(m), hCLines = plot(t,cos(m), hSGroup = hggroup; hCGroup = hggroup; set(hSLines, set(hCLines, % Include these hggroups in the legend: set(get(get(hSGroup, set(get(get(hCGroup, legend(
% To clean stuff. clc clear close all % Set some nice settings. grid on; format long; % Hold the graphics output until we are good to go. hold all; % To create some random test data. x1 = 0 : 0.1 : 1; y1 = sin( x1 ); y2 = cos( x1 ); y3 = tan( x1 ); % To perform the plotting. Here to start answering the question. plot(x1,y1, legendText(end+1) = { plot(x1,y2, legendText(end+1) = { plot(x1,y3, legendText(end+1) = { % Add the legends to the plotting. legend(legendText, % Flush/display our accumulated plotting until now. hold off;
pointA = [0,0,0]; pointB = [-10,-20,10]; pointC = [10,20,10]; plane1 = cross(pointA-pointB, pointA-pointC)
points=[pointA fill3(points(1,:),points(2,:),points(3,:), grid on alpha(0.3)
normal = cross(pointA-pointB, pointA-pointC); % % x = [pointA(1) pointB(1) pointC(1)]; y = [pointA(2) pointB(2) pointC(2)]; z = [pointA(3) pointB(3) pointC(3)]; %Find all coefficients of plane equation A = normal(1); B = normal(2); C = normal(3); D = -dot(normal,pointA); %Decide on a suitable showing range xLim = [min(x) max(x)]; zLim = [min(z) max(z)]; [X,Z] = meshgrid(xLim,zLim); Y = (A * X + C * Z + D)/ (-B); reOrder = [1 2 4 3]; figure();patch(X(reOrder),Y(reOrder),Z(reOrder), grid on; alpha(0.3);
function [x, y, z] = plane_surf(normal, dist, size) normal = normal / norm(normal); center = normal * dist; tangents = null(normal res(1,1,:) = center + tangents * [-1;-1]; res(1,2,:) = center + tangents * [-1;1]; res(2,2,:) = center + tangents * [1;1]; res(2,1,:) = center + tangents * [1;-1]; x = squeeze(res(:,:,1)); y = squeeze(res(:,:,2)); z = squeeze(res(:,:,3)); end
normal = cross(pointA-pointB, pointA-pointC); dist = dot(normal, pointA) [x, y, z] = plane_surf(normal, dist, 30); surf(x, y, z);
normal = cross(pointA-pointB, pointA-pointC); x = [pointA(1) pointB(1) pointC(1)]; y = [pointA(2) pointB(2) pointC(2)]; z = [pointA(3) pointB(3) pointC(3)]; A = normal(1); B = normal(2); C = normal(3); D = -dot(normal,pointA); zLim = [min(z) max(z)]; yLim = [min(y) max(y)]; [Y,Z] = meshgrid(yLim,zLim); X = (C * Z + B * Y + D)/ (-A); reOrder = [1 2 4 3]; figure();patch(X(reOrder),Y(reOrder),Z(reOrder), grid on; alpha(0.3);
normal = cross(pointA-pointB, pointA-pointC); x = [pointA(1) pointB(1) pointC(1)]; y = [pointA(2) pointB(2) pointC(2)]; z = [pointA(3) pointB(3) pointC(3)]; A = normal(1); B = normal(2); C = normal(3); D = -dot(normal,pointA); xLim = [min(x) max(x)]; yLim = [min(y) max(y)]; [Y,X] = meshgrid(yLim,xLim); Z = (A * X + B * Y + D)/ (-C); reOrder = [1 2 4 3]; figure();patch(X(reOrder),Y(reOrder),Z(reOrder), grid on; alpha(0.3);
function f = divrat(w, C) S=sqrt(diag(diag(C))); s=diag(S); f=sqrt(w
>> foo ans = 1 >> divrat(1,1) ??? Undefined function or method >> which -all divrat c:\work\divrat\private\divrat.m % Private to divrat
function h = uiProgressBar(varargin) %uiProgressBar: A waitbar that can be embedded in a GUI figure. if ishandle(varargin{1}) && size(varargin, 2) > 1 ax = varargin{1}; value = varargin{2}; p = get(ax, x = get(p, x(3:4) = value; set(p, return end bg_color = fg_color = h = axes( patch([0 0 0 0],[0 1 1 0],fg_color,... end
f = figure( progressBar = uiProgressBar(f); for i = 1:10:100 uiProgressBar(progressBar, i/100); pause(.5); end
function MyProgressBar(handle, progress) % progress = 0.00001 .... 1 % 1st panel p = uipanel(handle); % 2n panel as bar bar = uipanel(p); set(bar, x = get(bar, x(3) = progress; % Corresponds to % progress if unit = normalized set(bar, end
f = figure(); set(f, MyProgressBar(f, 0.5); % corresponds to 50% progress
classdef progressbar < handle properties(Access = protected) h_panel % Panel on which everything sits h_ax % The progress range axes h_pbar % The bar representing progress (patch) h_ptext % Percentage label end properties(Access = public, Dependent = true) range % Progress range pvalue % Current value percent % Percentage complete (relative within range) position % Position of the object (panel) ax_tag % Tag of the axes visible % Is the object (panel) visible? end properties(Constant = true) default_color = [.75 .75 .9]; end methods % Initializer function obj = progressbar(fig, pos, range) if nargin < 3 range = [0 1]; end obj.h_panel = uipanel( obj.h_ax = axes( obj.h_pbar = patch([range(1) range(1) range(1) range(1)], [0 0 2 2], ... obj.default_color, obj.h_ptext = text(obj.position(3)/2, obj.position(4)/2, obj.range = range; obj.ax_tag = end % Property Access Methods function set.range(obj, value) % Instead of replotting, just reset the XLim to the % extremities of the input range. If the values are not % increasing, just default to [0 1]. if value(end) > value(1) set(obj.h_ax, else set(obj.h_ax, end % Reset progress. obj.pvalue = value(1); end function value = get.range(obj) value = get(obj.h_ax, end function set.pvalue(obj, value) % Expects a single value to represent progress value and % constructs the selection rectangle from that. If multiple % values are passed in, all are ignored but the last, since the % left edge of the bar is always the first element of the % range. set(obj.h_pbar, set(obj.h_ptext, end function value = get.pvalue(obj) % The progress bar is actually 2D, but we treat as if it is 1D. % Hence the XData is actually an array of four values but we % only consider the second (progress maximum). limits = get(obj.h_pbar, value = limits(2); end function set.percent(obj, value) % Expects a single value between 0 and 1. limits = obj.range; obj.pvalue = value * (limits(2) - limits(1)) + limits(1); end function value = get.percent(obj) limits = obj.range; value = (obj.pvalue - limits(1)) / (limits(2) - limits(1)); end function set.position(obj, value) set(obj.h_panel, end function value = get.position(obj) value = get(obj.h_panel, end function set.ax_tag(obj, value) set(obj.h_ax, end function value = get.ax_tag(obj) value = get(obj.h_ax, end function set.visible(obj, value) if (isnumeric(value) && value >= 1) || strcmp(value, set(obj.h_panel, else set(obj.h_panel, end end function value = get.visible(obj) vis = get(obj.h_panel, value = strcmp(vis, end % Public member functions function increment(obj) % Don obj.pvalue = obj.pvalue + 1; end function display_text(obj, text, color) if nargin == 3 && ~isempty(color) set(obj.h_pbar, end set(obj.h_ptext, end end end
>> get(gca, ans = 0 0 1.0000 0 0.5000 0 1.0000 0 0 0 0.7500 0.7500 0.7500 0 0.7500 0.7500 0.7500 0 0.2500 0.2500 0.2500
>> get(gca, ans = 0 0.4470 0.7410 0.8500 0.3250 0.0980 0.9290 0.6940 0.1250 0.4940 0.1840 0.5560 0.4660 0.6740 0.1880 0.3010 0.7450 0.9330 0.6350 0.0780 0.1840
colours = permute(get(gca, colours_resize = imresize(colours, 50.0, imshow(colours_resize);
%appoint emergency file location emergencysave = char(inputdlg({ %or just emergencysave = %create some GUI element you can cancel times = 10; wbinfo = struct( wb = waitbar(wbinfo.curlength); wbinfo.wb = wb; %attach save() to cancelling anyimportantvariable = []; for i=1:times anyimportantvariable = [anyimportantvariable, i^2]; wbinfo.curlength = i/times; try waitbar(wbinfo.curlength, wb) catch save(emergencysave, return; end
[x, y] = meshgrid(-10:0.1:10); % Create a mesh of x and y points f = x.^3+x.*y+y.^2; % Evaluate f at those points contour(x, y, f, [36 36], xlabel( ylabel( title(
fun=@(x,y,z)(1-x.^8-3.*y.^8-2.*z.^8+5.*x.^4.*z.^2.*y.^2+3.*y.^4.*x.^2.*z.^2) ; [X,Y,Z]=meshgrid(-2:0.1:2,-2:0.1:2,-2:0.1:2); val=fun(X,Y,Z); fv=isosurface(X,Y,Z,val,0); p = patch(fv); isonormals(X,Y,Z,val,p) set(p, set(p, daspect([1,1,1]) view(3); axis tight camlight lighting phong axis off
image=torso; %image padding [Rows, Cols] = size(image); Diagonal = sqrt(Rows^2 + Cols^2); RowPad = ceil(Diagonal - Rows) + 2; ColPad = ceil(Diagonal - Cols) + 2; imagepad = zeros(Rows+RowPad, Cols+ColPad); imagepad(ceil(RowPad/2):(ceil(RowPad/2)+Rows-1),ceil(ColPad/2):(ceil(ColPad/2)+Cols-1)) = image; degree=45; %midpoints midx=ceil((size(imagepad,1)+1)/2); midy=ceil((size(imagepad,2)+1)/2); imagerot=zeros(size(imagepad)); %rotation for i=1:size(imagepad,1) for j=1:size(imagepad,2) x=(i-midx)*cos(degree)-(j-midy)*sin(degree); y=(i-midx)*sin(degree)+(j-midy)*cos(degree); x=round(x)+midx; y=round(y)+midy; if (x>=1 && y>=1) imagerot(x,y)=imagepad(i,j); % k degrees rotated image end end end figure,imagesc(imagerot); colormap(gray(256));
imagerot=zeros(size(imagepad)); % midx and midy same for both for i=1:size(imagerot,1) for j=1:size(imagerot,2) x= (i-midx)*cos(rads)+(j-midy)*sin(rads); y=-(i-midx)*sin(rads)+(j-midy)*cos(rads); x=round(x)+midx; y=round(y)+midy; if (x>=1 && y>=1 && x<=size(imagepad,2) && y<=size(imagepad,1)) imagerot(i,j)=imagepad(x,y); % k degrees rotated image end end end
imagepad = imread( [nrows ncols nslices] = size(imagepad); midx=ceil((ncols+1)/2); midy=ceil((nrows+1)/2); Mr = [cos(pi/4) sin(pi/4); -sin(pi/4) cos(pi/4)]; % e.g. 45 degree rotation % rotate about center [X Y] = meshgrid(1:ncols,1:nrows); XYt = [X(:)-midx Y(:)-midy]*Mr; XYt = bsxfun(@plus,XYt,[midx midy]); xout = round(XYt(:,1)); yout = round(XYt(:,2)); % nearest neighbor! outbound = yout<1 | yout>nrows | xout<1 | xout>ncols; zout=repmat(cat(3,1,2,3),nrows,ncols,1); zout=zout(:); xout(xout<1) = 1; xout(xout>ncols) = ncols; yout(yout<1) = 1; yout(yout>nrows) = nrows; xout = repmat(xout,[3 1]); yout = repmat(yout,[3 1]); imagerot = imagepad(sub2ind(size(imagepad),yout,xout,zout(:))); % lookup imagerot = reshape(imagerot,size(imagepad)); imagerot(repmat(outbound,[1 1 3])) = 0; % set background value to [0 0 0] (black)
image = imread( figure(1), clf, hold on subplot(1,2,1) imshow(image); degree = 45; switch mod(degree, 360) % Special cases case 0 imagerot = image; case 90 imagerot = rot90(image); case 180 imagerot = image(end:-1:1, end:-1:1); case 270 imagerot = rot90(image(end:-1:1, end:-1:1)); % General rotations otherwise % Convert to radians and create transformation matrix a = degree*pi/180; R = [+cos(a) +sin(a); -sin(a) +cos(a)]; % Figure out the size of the transformed image [m,n,p] = size(image); dest = round( [1 1; 1 n; m 1; m n]*R ); dest = bsxfun(@minus, dest, min(dest)) + 1; imagerot = zeros([max(dest) p],class(image)); % Map all pixels of the transformed image to the original image for ii = 1:size(imagerot,1) for jj = 1:size(imagerot,2) source = ([ii jj]-dest(1,:))*R. if all(source >= 1) && all(source <= [m n]) % Get all 4 surrounding pixels C = ceil(source); F = floor(source); % Compute the relative areas A = [... ((C(2)-source(2))*(C(1)-source(1))),... ((source(2)-F(2))*(source(1)-F(1))); ((C(2)-source(2))*(source(1)-F(1))),... ((source(2)-F(2))*(C(1)-source(1)))]; % Extract colors and re-scale them relative to area cols = bsxfun(@times, A, double(image(F(1):C(1),F(2):C(2),:))); % Assign imagerot(ii,jj,:) = sum(sum(cols),2); end end end end subplot(1,2,2) imshow(imagerot);
img=imread( [rowsi,colsi,z]= size(img); angle=45; rads=2*pi*angle/360; %calculating array dimesions such that rotated image gets fit in it exactly. % we are using absolute so that we get positve value in any case ie.,any quadrant. rowsf=ceil(rowsi*abs(cos(rads))+colsi*abs(sin(rads))); colsf=ceil(rowsi*abs(sin(rads))+colsi*abs(cos(rads))); % define an array withcalculated dimensionsand fill the array with zeros ie.,black C=uint8(zeros([rowsf colsf 3 ])); %calculating center of original and final image xo=ceil(rowsi/2); yo=ceil(colsi/2); midx=ceil((size(C,1))/2); midy=ceil((size(C,2))/2); % in this loop we calculate corresponding coordinates of pixel of A % for each pixel of C, and its intensity will be assigned after checking % weather it lie in the bound of A (original image) for i=1:size(C,1) for j=1:size(C,2) x= (i-midx)*cos(rads)+(j-midy)*sin(rads); y= -(i-midx)*sin(rads)+(j-midy)*cos(rads); x=round(x)+xo; y=round(y)+yo; if (x>=1 && y>=1 && x<=size(img,1) && y<=size(img,2) ) C(i,j,:)=img(x,y,:); end end end imshow(C);
img = imread( theta = pi/10; rmat = [ cos(theta) sin(theta) 0 -sin(theta) cos(theta) 0 0 0 1]; mx = size(img,2); my = size(img,1); corners = [ 0 0 1 mx 0 1 0 my 1 mx my 1]; new_c = corners*rmat; T = maketform( img2 = imtransform(img, T, ... subplot(121), imshow(img); subplot(122), imshow(img2);
someVar.member1=myValue1; someVar.member2=myValue2; if (myCondition) for i=1:myTotal someVar(i).member3=myValue3; end; end;
if (myCondition) for i=1:myTotal someVar(i).member3=myValue3; end; end;
-------------------------------------------------------------------------------------------------- MATLAB Version: 7.14.0.739 (R2012a) MATLAB License Number: 161052 Operating System: Linux 3.5.0-23-generic Java Version: Java 1.6.0_17-b04 with Sun Microsystems Inc. Java HotSpot(TM) Client VM mixed mode -------------------------------------------------------------------------------------------------- MATLAB Version 7.14 (R2012a) Simulink Version 7.9 (R2012a) Aerospace Blockset Version 3.9 (R2012a) Aerospace Toolbox Version 2.9 (R2012a) Bioinformatics Toolbox Version 4.1 (R2012a) Communications System Toolbox Version 5.2 (R2012a) Computer Vision System Toolbox Version 5.0 (R2012a) Control System Toolbox Version 9.3 (R2012a) Curve Fitting Toolbox Version 3.2.1 (R2012a) DO Qualification Kit Version 1.6 (R2012a) DSP System Toolbox Version 8.2 (R2012a) Database Toolbox Version 3.11 (R2012a) Datafeed Toolbox Version 4.3 (R2012a) Econometrics Toolbox Version 2.1 (R2012a) Embedded Coder Version 6.2 (R2012a) Filter Design HDL Coder Version 2.9.1 (R2012a) Financial Derivatives Toolbox Version 5.9 (R2012a) Financial Toolbox Version 4.2 (R2012a) Fixed-Income Toolbox Version 2.3 (R2012a) Fixed-Point Toolbox Version 3.5 (R2012a) Fuzzy Logic Toolbox Version 2.2.15 (R2012a) Global Optimization Toolbox Version 3.2.1 (R2012a) HDL Coder Version 3.0 (R2012a) HDL Verifier Version 4.0 (R2012a) IEC Certification Kit Version 2.1 (R2012a) Image Acquisition Toolbox Version 4.3 (R2012a) Image Processing Toolbox Version 8.0 (R2012a) Instrument Control Toolbox Version 3.1 (R2012a) MATLAB Builder JA Version 2.2.4 (R2012a) MATLAB Coder Version 2.2 (R2012a) MATLAB Compiler Version 4.17 (R2012a) MATLAB Distributed Computing Server Version 6.0 (R2012a) MATLAB Report Generator Version 3.12 (R2012a) Mapping Toolbox Version 3.5 (R2012a) Model Predictive Control Toolbox Version 4.1 (R2012a) Neural Network Toolbox Version 7.0.3 (R2012a) Optimization Toolbox Version 6.2 (R2012a) Parallel Computing Toolbox Version 6.0 (R2012a) Partial Differential Equation Toolbox Version 1.0.20 (R2012a) Phased Array System Toolbox Version 1.2 (R2012a) RF Toolbox Version 2.10 (R2012a) Robust Control Toolbox Version 4.1 (R2012a) Signal Processing Toolbox Version 6.17 (R2012a) SimBiology Version 4.1 (R2012a) SimDriveline Version 2.2 (R2012a) SimElectronics Version 2.1 (R2012a) SimEvents Version 4.1 (R2012a) SimHydraulics Version 1.10.1 (R2012a) SimMechanics Version 4.0 (R2012a) SimPowerSystems Version 5.6 (R2012a) SimRF Version 3.2 (R2012a) Simscape Version 3.7 (R2012a) Simulink 3D Animation Version 6.1 (R2012a) Simulink Code Inspector Version 1.1 (R2012a) Simulink Coder Version 8.2 (R2012a) Simulink Control Design Version 3.5 (R2012a) Simulink Design Optimization Version 2.1 (R2012a) Simulink Design Verifier Version 2.2 (R2012a) Simulink Fixed Point Version 7.1 (R2012a) Simulink Report Generator Version 3.12 (R2012a) Simulink Verification and Validation Version 3.3 (R2012a) Stateflow Version 7.9 (R2012a) Statistics Toolbox Version 8.0 (R2012a) Symbolic Math Toolbox Version 5.8 (R2012a) System Identification Toolbox Version 8.0 (R2012a) SystemTest Version 2.6.3 (R2012a) Wavelet Toolbox Version 4.9 (R2012a)
col_size = size(A, 2); ones_row = ones(1, col_size);
A = [ 1 2 3 4 5; 6 7 8 9 0 ]; B = ones(size(A) + [1,0]); % Create an array of ones that is one row longer B(2:end,:) = A; % Replace the elements of B with elements from A
A = [ 1 2 3 4 5; 6 7 8 9 0 ]; B = padarray(A,[1 0],1,
edges = [0.05:0.10:.55]; X = edges == 0.35 edges = 0.0500 0.1500 0.2500 0.3500 0.4500 0.5500 X = 0 0 0 0 0 0
edges = linspace(0.05,0.55,6); % X = edges == 0.35 edges = 0.0500 0.1500 0.2500 0.3500 0.4500 0.5500 X = 0 0 0 1 0 0
n1 = n-1 c = (d2 - d1).*(n1-1) % opposite signs may cause overflow if isinf(c) y = d1 + (d2/n1).*(0:n1) - (d1/n1).*(0:n1) else y = d1 + (0:n1).*(d2 - d1)/n1 end
>> a = 0:pi/1000:10*pi; >> b = linspace(0,10*pi,10001); >> all(a==b) ans = 0 >> max(a-b) ans = 3.5527e-15
%...la da da %...programming away if such && such clear = 1; else clear = 0; end
for index = 1:numel(fruits) [isstr(fruits{index}) iscell(fruits{index})] end for fruit = fruits [isstr(fruit) iscell(fruit)] end
vcell(cellfun(@isnumeric, vcell)) = cellfun(@(x) sprintf(
twoNorm = sqrt(sum(abs(M).^2,1)); % pNorm = sum(abs(M).^p,1).^(1/p); % infNorm = max(M,[],1); %
norm_2 = @(A,dim)sqrt( sum( real(A).*conj(A) , dim) )
function norm_2__ = norm_2 (A_,dim_) norm_2__ = sqrt( sum( real(A_).*conj(A_) , dim_) ) ; end
classdef double_zb < double methods function obj = double_zb(data) if nargin == 0 data = 0; end obj = obj@double(data); % initialize the base class portion end end end
% img = imread( figure,imshow(img) % hold on % p1 = [10,100]; p2 = [100,20]; % % % plot([p1(2),p2(2)],[p1(1),p2(1)],
figure; hold on; imagesc(img); line([x1,x2],[y1,y2], hold off
load clown image(X) colormap(map) c = size(X,2) mid = round(c/2) X(:,mid) = 1 image(X)
%draw a line from point (100,100) to (200,200) on an image saved as nextFrame line = int32([100 100 200 200]); shapeInserter = vision.ShapeInserter( nextFrame = step(shapeInserter, nextFrame, line);
M = [ 1, 2, 3,;... 4, 5, 6,;... ;... ;... 7, 8, 9,;... ];
s1.field1 = [1 2 3]; s1.field2 = {2,3,4,{5,6}}; s2 = s1; isequal(s1,s2) %Returns true (structures match) s1.field3 = [1 2 nan]; s2.field3 = [1 2 nan]; isequal(s1, s2) %Returns false (NaN ~= NaN) isequalwithequalnans(s1, s2) %Returns true (NaN == NaN) s2.field2{end+1}=7; isequal(s1,s2) %Returns false (different structures) isequal(s1,
close all; clear all; clc; % Parameter Setting R = 128; C = 128; Kmax = pi / 2; f = sqrt( 2 ); Delt = 2 * pi; Delt2 = Delt * Delt; % Show the Gabor Wavelets for v = 0 : 4 for u = 1 : 8 GW = GaborWavelet ( R, C, Kmax, f, u, v, Delt2 ); % Create the Gabor wavelets figure( 2 ); subplot( 5, 8, v * 8 + u ),imshow ( real( GW ) ,[]); % Show the real part of Gabor wavelets end figure ( 3 ); subplot( 1, 5, v + 1 ),imshow ( abs( GW ),[]); % Show the magnitude of Gabor wavelets end function GW = GaborWavelet (R, C, Kmax, f, u, v, Delt2) k = ( Kmax / ( f ^ v ) ) * exp( 1i * u * pi / 8 );% Wave Vector kn2 = ( abs( k ) ) ^ 2; GW = zeros ( R , C ); for m = -R/2 + 1 : R/2 for n = -C/2 + 1 : C/2 GW(m+R/2,n+C/2) = ( kn2 / Delt2 ) * exp( -0.5 * kn2 * ( m ^ 2 + n ^ 2 ) / Delt2) * ( exp( 1i * ( real( k ) * m + imag ( k ) * n ) ) - exp ( -0.5 * Delt2 ) ); end end
% if ndims(img) > 2; img = rgb2gray(img); end % img = im2double(img); [m,n] = size(img); [mf,nf] = size(GW); GW = padarray(GW,[n-nf m-mf]/2); GW = ifftshift(GW); imgf = ifft2( fft2(img) .* GW );
img = im2double(rgb2gray(img)); % [m,n] = size(img); % % R = 127; C = 127; % % % pR = (R-1)/2; pC = (C-1)/2; if rem(m,2) ~= 0; pR = pR + 1; end; if rem(n,2) ~= 0; pC = pC + 1; end; img = padarray(img,[pR pC], GW = {}; % for v = 0 : 4 for u = 1 : 8 GW = [GW {GaborWavelet(R, C, Kmax, f, u, v, Delt2)}]; end end % % padsize = size(img) - [R C]; GW = cellfun( ... @(x) padarray(x,padsize/2), ... GW, ... imgFFT = fft2(img); % for i=1:length(GW) filter = fft2( ifftshift( GW{i} ) ); % imgfilt{i} = ifft2( imgFFT .* filter ); % end % imgS = zeros(m,n); for i=1:length(imgfilt) imgS = imgS + imgfilt{i}(pR+1:end,pC+1:end); % end % imagesc(abs(imgS));
% function gaborTest() close all; clear all; clc; % Parameter Setting R = 128; C = 128; Kmax = pi / 2; f = sqrt( 2 ); Delt = 2 * pi; Delt2 = Delt * Delt; % GW_ALL = nan(32, C*R); % Show the Gabor Wavelets for v = 0 : 4 for u = 1 : 8 GW = GaborWavelet ( R, C, Kmax, f, u, v, Delt2 ); % Create the Gabor wavelets figure( 2 ); subplot( 5, 8, v * 8 + u ),imshow ( real( GW ) ,[]); % Show the real part of Gabor wavelets GW_ALL( v*8+u, :) = GW(:); end figure ( 3 ); subplot( 1, 5, v + 1 ),imshow ( abs( GW ),[]); % Show the magnitude of Gabor wavelets end %% Create an Image: t = linspace(-6*pi,6*pi,128); myImg = sin(t) figure(3333); clf subplot(1,3,1); imagesc(myImg); title( axis image %% Get the coefficients of the wavelets and plot: waveletCoefficients = GW_ALL*myImg(:); subplot(1,3,2); stem(abs(waveletCoefficients)); title( %% Try and recreate the image from just a few wavelets. % (we would need C*R wavelets to recreate perfectly) subplot(1,3,3); imagesc(reshape(real(GW_ALL title( axis image
figure(34); subplot(5,8, v * 8 + u ); imagesc(abs(ifft2((fft2(GW).*fft2(myImg))))); axis off
function createFunctionDependencyDotFile(calls) %CREATEFUNCTIONDEPENDENCYDOTFILE Create a GraphViz DOT diagram file from function call list % % Calls (cellstr) is an n-by-2 cell array in format {caller,callee;...}. % % Example: % calls = { % createFunctionDependencyDotFile(calls) baseName = dotFile = [baseName fid = fopen(dotFile, fprintf(fid, for i = 1:size(calls,1) [parent,child] = calls{i,:}; fprintf(fid, end fprintf(fid, fclose(fid); % Render to image imageFile = [baseName % Assumes the GraphViz bin dir is on the path; if not, use full path to dot.exe cmd = sprintf( system(cmd); fprintf(
function [value, remain] = divide(left, right) value = floor(left / right); remain = left / right - value; end
function [inputNames, outputNames] = get_arg_names(filePath) % Open the file: fid = fopen(filePath); % Skip leading comments and empty lines: defLine = while all(isspace(defLine)) defLine = strip_comments(fgets(fid)); end % Collect all lines if the definition is on multiple lines: index = strfind(defLine, while ~isempty(index) defLine = [defLine(1:index-1) strip_comments(fgets(fid))]; index = strfind(defLine, end % Close the file: fclose(fid); % Create the regular expression to match: matchStr = if any(defLine == matchStr = strcat(matchStr, end matchStr = strcat(matchStr, % Parse the definition line (case insensitive): argStruct = regexpi(defLine, matchStr, % Format the input argument names: if isfield(argStruct, inputNames = strtrim(textscan(argStruct.inArgs, else inputNames = {}; end % Format the output argument names: if isfield(argStruct, outputNames = strtrim(textscan(argStruct.outArgs, else outputNames = {}; end % Nested functions: function str = strip_comments(str) if strcmp(strtrim(str), strip_comment_block; str = strip_comments(fgets(fid)); else str = strtok([ end end function strip_comment_block str = strtrim(fgets(fid)); while ~strcmp(str, if strcmp(str, strip_comment_block; end str = strtrim(fgets(fid)); end end end
classdef SomeTempClassName methods function [value, remain] = divide(left, right) % end end end
function [inputNames,outputNames] = getArgNames(functionFile) % fname = tempname; [~,fname] = fileparts(fname); % str = fileread(which(functionFile)); % fid = fopen([fname fprintf(fid, fclose(fid); % % missingEndErrMsg = c = checkcode([fname if ismember(missingEndErrMsg,{c.message}) % append "end" keyword to class file str = fileread([fname fid = fopen([fname fprintf(fid, fclose(fid); end % rehash % m = meta.class.fromName(fname); idx = find(ismember({m.MethodList.Name},functionFile)); inputNames = m.MethodList(idx).InputNames; outputNames = m.MethodList(idx).OutputNames; % delete([fname end
function module = divide_load() module.fn = @my_divide; module.name = module.description = module.param(1).name = module.param(1).description = module.param(1).required_shape = % Etc, etc. function [value, remain] = my_divide(left, right) value = floor(left / right); remain = left / right - value; end end
function [outMAP] = divide(inMAP) outMAP = containers.Map(); outMAP( outMAP( end
t = {... t = cellfun(@(x) [x sprintf( t = horzcat(t{:});
function out = CR() out = char(13); % function out = LF() out = char(10); %
function out = join(glue, strs) strs = strs(:) strs(2,:) = {glue}; strs = strs(:) strs(end) = []; out = cat(2, strs{:});
For improved performance, consider not using CLEAR ALL within a script
if nargout == 1 % Code to calculate "a" only else % Code to calculate other variables
for i = 1:length(arr) arr(i).val = arr(i).val + 3; end
newVals = num2cell([arr.val] + 3); [arr.val] = deal(newVals{:});
[arr.val] = newVals{:}; % achieves the same as deal(newVals{:})
% make a struct array arr = [ struct( % some attempts [arr.val]=arr.val; % fine [arr.val]=arr.val+3; % NOT fine :( % works ! arr2 = arrayfun(@(s) setfield(s,
sin x = x - (x^3)/3! + (x^5)/5! - (x^7)/7! + (x^9)/9! ...
clc x = pi; % or x = pi/2 res = x; factor = -1; for ii=3:2:19 res = res + factor*power(x,ii)/factorial(ii); factor = factor*-1; fprintf ( end res
Results for PI/2 iteration 1 sin(x)=0.9248322292886504 iteration 2 sin(x)=1.0045248555348174 iteration 3 sin(x)=0.9998431013994987 iteration 4 sin(x)=1.0000035425842861 iteration 5 sin(x)=0.9999999437410510 iteration 6 sin(x)=1.0000000006627803 iteration 7 sin(x)=0.9999999999939768 iteration 8 sin(x)=1.0000000000000437 iteration 9 sin(x)=1.0000000000000000 Final Result: 1.0000000000000000 Results for PI iteration 1 sin(x)=-2.0261201264601763 iteration 2 sin(x)=0.5240439134171688 iteration 3 sin(x)=-0.0752206159036231 iteration 4 sin(x)=0.0069252707075051 iteration 5 sin(x)=-0.0004451602382092 iteration 6 sin(x)=0.0000211425675584 iteration 7 sin(x)=-0.0000007727858894 iteration 8 sin(x)=0.0000000224195107 iteration 9 sin(x)=-0.0000000005289183 Final Result: -0.0000000005289183
sin(pi+dx)=sin(pi)+cos(pi)dx+o(dx^2)=-dx+o(dx^2) sin(pi/2+dx)=sin(pi/2)+cos(pi/2)dx+o(dx^2)=1+o(dx^2)
>> methods(table) Methods for class table: classVarNames ismatrixlike table varfun convertColumn renameVarNames unstack
function disp_modified(t) if istable(t) % builtin( else % builtin( end
>> disp(1:5) 1 2 3 4 5 >> disp({1 2 3 [1] [2] [3] >> disp(table(rand(1e3,1)))
pwelch (x, window, noverlap, nfft, fs); spectrogram (x, window, noverlap, F, fs);
a = 1:3; % possible numbers weight = [0.3 0.1 0.2]; % corresponding weights
a = 1:3; % w = [0.3 0.1 0.2]; % N = 10; % R = a( sum( bsxfun(@ge, rand(N,1), cumsum(w./sum(w))), 2) + 1 )
>> tabulate( R ) Value Count Percent 1 511 51.10% 2 160 16.00% 3 329 32.90%
a = 1:3 w = [.3 .1 .2]; N = 10; [~,R] = histc(rand(1,N),cumsum([0;w(:)./sum(w)])); R = a(R) R = 1 1 1 2 2 1 3 1 1 1
a = 1:10000; w = rand(1,10000); N = 1000000; tic [~,R] = histc(rand(1,N),cumsum([0;w(:)./sum(w)])); R = a(R); toc Elapsed time is 0.120879 seconds.
[~, R] = histc(rand(N,1),cumsum([0;w(:)./sum(w)]));
a = 1:3; % possible numbers w = [0.3 0.1 0.2]; % corresponding weights N = 100000000; % number of values to generate w_normalized = w / sum(w) % normalised weights, for indication fprintf( tic R = randsample(a, N, true, w); toc tabulate(R) fprintf( tic R = a( sum( bsxfun(@ge, rand(N,1), cumsum(w./sum(w))), 2) + 1 ); toc tabulate(R) fprintf( tic [~, R] = histc(rand(N,1),cumsum([0;w(:)./sum(w)])); toc tabulate(R)
w_normalized = 0.5000 0.1667 0.3333 randsample: Elapsed time is 2.976893 seconds. Value Count Percent 1 49997864 50.00% 2 16670394 16.67% 3 33331742 33.33% bsxfun: Elapsed time is 2.712315 seconds. Value Count Percent 1 49996820 50.00% 2 16665005 16.67% 3 33338175 33.34% histc: Elapsed time is 2.078809 seconds. Value Count Percent 1 50004044 50.00% 2 16665508 16.67% 3 33330448 33.33%
a = 1:3; % possible numbers w = [0.3 0.1 0.2]; % corresponding weights I = 100000; % number of values to generate w_normalized = w / sum(w) % normalised weights, for indication R=zeros(N,1); fprintf( tic for i=1:I R(i) = randsample(a, 1, true, w); end toc tabulate(R) fprintf( tic for i=1:I R(i) = a( sum( (rand(1) >= cumsum(w./sum(w)))) + 1 ); end toc tabulate(R) fprintf( tic for i=1:I [~, R(i)] = histc(rand(1),cumsum([0;w(:)./sum(w)])); end toc tabulate(R)
0.5000 0.1667 0.3333 randsample: Elapsed time is 3.526473 seconds. Value Count Percent 1 50437 50.44% 2 16149 16.15% 3 33414 33.41% cumsum: Elapsed time is 0.473207 seconds. Value Count Percent 1 50018 50.02% 2 16748 16.75% 3 33234 33.23% histc: Elapsed time is 1.046981 seconds. Value Count Percent 1 50134 50.13% 2 16684 16.68% 3 33182 33.18%
%% Toy example: generate random numbers from an arbitrary PDF a = 1:3; % w = [0.3 0.1 0.2]; % N = 10000; % %Generate using roulette wheel + run length encoding factor = 1 / min(w); %Compute min factor to assign 1 bin to min(PDF) intW = int32(w * factor); %Get replicator indexes for run length encoding idxArr = zeros(1,sum(intW)); %Create index access array idxArr([1 cumsum(intW(1:end-1))+1]) = 1;%Tag sample change indexes sampTable = a(cumsum(idxArr)); %Create lookup table filled with samples len = size(sampTable,2); tic; R = sampTable( uint32(randi([1 len],N,1)) ); toc; tabulate(R);
a ~ 15000, n = 10000 Without table: Elapsed time is 0.006203 seconds. With table: Elapsed time is 0.003308 seconds. ByteSize(sampTable) 796.23 kb a ~ 15000, n = 100000 Without table: Elapsed time is 0.003510 seconds. With table: Elapsed time is 0.002823 seconds. a ~ 35000, n = 10000 Without table: Elapsed time is 0.226990 seconds. With table: Elapsed time is 0.001328 seconds. ByteSize(sampTable) 2.79 Mb a ~ 35000 n = 100000 Without table: Elapsed time is 2.784713 seconds. With table: Elapsed time is 0.003452 seconds. a ~ 35000 n = 1000000 Without table: bsxfun: out of memory With table : Elapsed time is 0.021093 seconds.
A = [10 20 30; 40 50 60; 70 80 90]; % B = A([1 3], [1 2]) %
Ir = logical([1 1 0]); Ic = logical([1 0 1]); B = A(Ir, Ic)
A = magic(6) A = 35 1 6 26 19 24 3 32 7 21 23 25 31 9 2 22 27 20 8 28 33 17 10 15 30 5 34 12 14 16 4 36 29 13 18 11
function f = sub(A,i,j) [m,n] = size(A); row = 1:m; col = 1:n; x = row; x(i) = []; y=col; y(j) = []; f= A(x,y);
function normalized = normalize_var(array, x, y) % Normalize to [0, 1]: m = min(array); range = max(array) - m; array = (array - m) / range; % Then scale to [x,y]: range2 = y - x; normalized = (array*range2) + x;
t = 1:10800; % generate time vector fs = 1; % sampling frequency (seconds) A = 2; % amplitude P = 1000; % period (seconds), the time it takes for the signal to repeat itself f1 = 1/P; % number of cycles per second (i.e. how often the signal repeats itself every second). y1 = A*sin(2*pi*f1*t); % signal 1 phi = 10; % phase shift y2 = A*sin(2*pi*f1*t + phi); % signal 2 phi = 15; % phase shift y3 = A*sin(2*pi*f1*t + phi); % signal 3 YY = [y1 plot(t,YY)
for i = 1:3; [Pxy,Freq] = cpsd(YY(:,1),YY(:,i)); coP = real(Pxy); quadP = imag(Pxy); phase(:,i) = atan2(coP,quadP); end
x1 = sin( 0.1*arange(1024) ) x2 = sin( 0.1*arange(1024) + 0.456) x1h = hilbert(x1) x2h = hilbert(x2) c = inner( x1h, conj(x2h) ) / sqrt( inner(x1h,conj(x1h)) * inner(x2h,conj(x2h)) ) phase_diff = angle(c)
t = 1:10800; % generate time vector fs = 1; % sampling frequency (seconds) A = 2; % amplitude P = 1000; % period (seconds), the time it takes for the signal to repeat itself f1 = 1/P; % number of cycles per second (i.e. how often the signal repeats itself every second). y1 = A*sin(2*pi*f1*t); % signal 1 phi = 10*pi/180; % phase shift in radians y2 = A*sin(2*pi*f1*t + phi); % signal 2 phi = 15*pi/180; % phase shift in radians y3 = A*sin(2*pi*f1*t + phi); % signal 3
>> acos(dot(y1,y2)/(norm(y1)*norm(y2))) >> ans*180/pi ans = 9.9332 >> acos(dot(y1,y3)/(norm(y1)*norm(y3))) ans = 0.25980 >> ans*180/pi ans = 14.885
t = 1:10800; % generate time vector fs = 1; % sampling frequency (seconds) A = 2; % amplitude P = 1000; % period (seconds), the time it takes for the signal to repeat itself f1 = 1/P; % number of cycles per second (i.e. how often the signal repeats itself every second). y1 = A*sin(2*pi*f1*t); % signal 1 phi = deg2rad(10); % phase shift y2 = A*sin(2*pi*f1*t + phi); % signal 2 phi = deg2rad(15); % phase shift y3 = A*sin(2*pi*f1*t + phi); % signal 3 YY = [y1 plot(t,YY)
fft_y1 = fft(y1); fft_y2 = fft(y2); phase_rad = angle(fft_y1(1:end/2)/fft_y2(1:end/2)); phase_deg = rad2deg(angle(fft_y1(1:end/2)/fft_y2(1:end/2)));
fr = 20; % input signal freq timeStep = 1e-4; t = 0:timeStep:50; % time vector y1 = sin(2*pi*t); % reference signal ph = 0.5; % phase difference to be detected in radians y2 = 0.9 * sin(2*pi*t + ph); % signal, the phase of which, is to be measured relative to the reference signal [c,lag]=xcorr(y1,y2); % calc. cross-corel-n [maxC,I]=max(c); % find max PH = (lag(I) * timeStep) * 2 * pi; % calculated phase in radians >> PH PH = 0.4995
>> profile on; % Starts the profiler >> myfunctiontorun( ); % This can be a function, script or block of code >> profile viewer; % Opens the viewer showing you how much time everything took
>> tic; % Start the timer >> myfunctionname( ); >> toc; % End the timer and display elapsed time
>> mytimer = tic; >> myfunctionname( ); >> toc(mytimer);
myImage = yurbuds0x2Dironman; fH = figure; iH = imagesc(myImage); set(gca,
x=randperm(3); s = repmat( s(end)=[]; %Remove trailing comma disp(sprintf([
for k = 1:5 t = clock; pause(uint8(rand * 10)); v = genvarname( eval([v end
bistar = zeros(numdims,numcases); parfor hh=1:nt bistar = bistar + A(:,:,hh)*data(:,:,hh+1) end
Q = 3; % O = 2; % % prior = [1 0 0]; % A = [0.8 0.05 0.15; 0.2 0.6 0.2; 0.2 0.3 0.5]; % B = [0.1 0.9; 0.8 0.2; 0.3 0.7];
num = 20; % T = 10; % [seqs,states] = dhmm_sample(prior, A, B, num, T);
>> seqs(5,:) % ans = 2 2 1 2 1 1 1 2 2 2 >> states(5,:) % ans = 1 1 1 3 2 2 2 1 1 1
dhmm_logprob(seqs(5,:), prior, A, B) dhmm_logprob_path(prior, A, B, states(5,:))
vPath = viterbi_path(prior, A, multinomial_prob(seqs(5,:),B))
% prior_hat = normalise(rand(Q,1)); A_hat = mk_stochastic(rand(Q,Q)); B_hat = mk_stochastic(rand(Q,O)); % [LL,prior_hat,A_hat,B_hat] = dhmm_em(seqs, prior_hat,A_hat,B_hat, % plot(LL), xlabel(
>> p = [2 3 1]; % >> prior, prior_hat(p) prior = 1 0 0 ans = 0.97401 7.5499e-005 0.02591 >> A, A_hat(p,p) A = 0.8 0.05 0.15 0.2 0.6 0.2 0.2 0.3 0.5 ans = 0.75967 0.05898 0.18135 0.037482 0.77118 0.19134 0.22003 0.53381 0.24616 >> B, B_hat(p,[1 2]) B = 0.1 0.9 0.8 0.2 0.3 0.7 ans = 0.11237 0.88763 0.72839 0.27161 0.25889 0.74111
if isa(f, % f is a handle else % f is not a handle end
f = @(x)x+1 f = @(x)x+1 >> class(f) ans = function_handle
for n=1:5 %generate sample cell array mycellarray{n}=1; end mycellarray{2}=[] %remove one value for testing
for n=1:length(mycellarray) if isempty(mycellarray{n}) mycellarray{n}=0; end end mylogicalarray=logical(cell2mat(mycellarray));
mylogicalarray = ~cellfun(@isempty, mycellarray); % Or the faster option (see comments)... mylogicalarray = ~cellfun(
emptyIndex = cellfun( mycellarray(emptyIndex) = {0}; % Fill empty cells with 0 mylogicalarray = logical(cell2mat(mycellarray)); % Convert the cell array
mycellarray( cellfun(@isempty, mycellarray) ) = {0}; mylogicalarray = logical(cell2mat(mycellarray));
clf; figure( hold on; ylim([-100, 100]); figure( a = 0; b = []; for i = 1:100 a = a + 1; b = [b, -i]; c = b; xlim([0, i]); plot(i, a, plot(i, b(i), drawnow; end
figure(1) plot(x,y) % this will go on figure 1 figure(2) plot(z,w) % this will go on another figure
figure hAx1 = axes; plot(hAx1, 1, 1, hold on figure hAx2 = axes; plot(hAx2, 2, 1, hold on plot(hAx2, 3, 4, plot(hAx1, 3, 3,
figure plot(1,1) hAx1 = gca; hold on figure plot(2,2) plot(hAx1, 3, 3)
% function array_of_numbers = eval_and_loops_solution(list_of_words) n_numbers = 1 + sum(list_of_words{1}== n_words = numel(list_of_words); array_of_numbers = zeros(n_numbers, n_words); for k = 1:n_words temp = [ temp(temp== array_of_numbers(:,k) = eval(temp); end; % array_of_numbers = transpose(array_of_numbers / 1000); end
% function array_of_numbers = single_sscanf_solution(list_of_words) N = 1 + sum(list_of_words{1}== lens = cellfun(@numel,list_of_words); tlens = sum(lens); idx(1,tlens)=0; idx(cumsum(lens(1:end-1))+1)=1; idx2 = (1:tlens) + cumsum(idx); one_str(1:max(idx2)+1)= one_str(idx2) = [list_of_words{:}]; delim = repmat( array_of_numbers = reshape(sscanf(one_str, delim),N,[]) end
% function list_of_words = referee_test_case(n_words) NUM_PER_WORD = 10; NUM_MAX = 9999; word_format = [repmat( list_of_words = cell(n_words,1); fprintf( for k = 1:n_words list_of_words{k} = sprintf(word_format, randi(NUM_MAX, [1, NUM_PER_WORD])); end; end
% function referee_timing(test_case, varargin) % % % % % % % % fprintf( for k = 1:numel(varargin) try t = timeit(@() varargin{k}(test_case)); fprintf( catch ME fprintf( end; end; end
% clc; feature accel on; % % referee_timing( ... referee_test_case(10^4), ... @eval_and_loops_solution, ... @single_sscanf_solution ... % ); % referee_timing( ... referee_test_case(10^5), ... @eval_and_loops_solution, ... @single_sscanf_solution ... % ); % referee_timing( ... referee_test_case(10^6), ... @eval_and_loops_solution, ... @single_sscanf_solution ... % );
function out = solution_cumsum_bsxfun(list_of_words) N = 1 + sum(list_of_words{1}== lens = cellfun( tlens = sum(lens); % cumlens = cumsum(lens); % % % % startpos_newcell(1,tlens)=0; startpos_newcell(cumlens(1:end-1)+1)=1; % % newpos = (1:tlens) + cumsum(startpos_newcell); % % one_str(newpos) = [list_of_words{:}]; one_str(cumlens + [1:numel(cumlens)] pos_us = find(one_str== wordend_idx = pos_us - [1:numel(pos_us)]; % wordlens = [wordend_idx(1) diff(wordend_idx)]; % max_wordlens = max(wordlens); % % mask = bsxfun(@ge,[1:max_wordlens] % % num1(max_wordlens,size(mask,2)) = 0; num1(mask) = one_str(one_str~= % % out = reshape(10.^(max_wordlens-4:-1:-3)*num1,N,[]). return;
function out = solution_sprintf_bsxfun(list_of_words) N = 1 + sum(list_of_words{1}== % % one_str = sprintf( pos_us = find(one_str== wordend_idx = pos_us - [1:numel(pos_us)]; % wordlens = [wordend_idx(1) diff(wordend_idx)]; % max_wordlens = max(wordlens); % % mask = bsxfun(@ge,[1:max_wordlens] % % num1(max_wordlens,size(mask,2)) = 0; num1(mask) = one_str(one_str~= % % out = reshape(10.^(max_wordlens-4:-1:-3)*num1,N,[]). return;
function out = solution_bytstrm_bsxfun(list_of_words) allchars = [list_of_words{:}]; digits_array = getByteStreamFromArray(allchars); % % digits_array = digits_array(65:65+numel(allchars)-1) - 48; % -------------------------------------------------------------------- N = 1 + sum(list_of_words{1}== lens = cellfun( cumlens = cumsum(lens) % ---------------------------------------------------------- pos_us = find(digits_array==47); starts = [[1 cumlens(1:end-1)+1];reshape(pos_us+1,N-1,[])]; ends = [reshape(pos_us-1,N-1,[]) ; cumlens]; gaps = ends(:) - starts(:) + 1; maxg = max(gaps); mask1 = bsxfun(@lt,maxg-gaps num_array(maxg,numel(lens)*N)=0; num_array(mask1) = digits_array(digits_array~=47); out = reshape(10.^(maxg-4:-1:-3)*num_array,N,[]). return;
function out = soln_sprintf_bsxfun_gpu(list_of_words) N = 1 + sum(list_of_words{1}== % % % % digits_array = gpuArray(single(sprintf( digits_array = digits_array - 48; mask_us = digits_array==47; % pos_us = find(mask_us); wordend_idx = pos_us - gpuArray.colon(1,numel(pos_us)); % wordlens = [wordend_idx(1) diff(wordend_idx)]; % max_wordlens = max(wordlens); % % % num1 = single(zeros(max_wordlens,numel(pos_us), num1(bsxfun(@ge,gpuArray.colon(1,max_wordlens) max_wordlens+1-single(wordlens))) = digits_array(~mask_us); % % % outg = reshape(10.^(max_wordlens-4:-1:-3)*num1,N,[]). out = gather(outg);
function out = soln_bytstrm_bsxfun_gpu(list_of_words) us_ascii_num = 95; allchars = [list_of_words{:}]; % % alldigits = getByteStreamFromArray(allchars); digits_array1 = gpuArray(alldigits(65:65+numel(allchars)-1)); % -------------------------------------------------------------------- lens = cellfun( N = sum(digits_array1(1:lens(1))==us_ascii_num)+1; % lens = gpuArray(lens); cumlens = cumsum(lens) % ---------------------------------------------------------- mask_us = digits_array1==us_ascii_num; % pos_us = find(mask_us); starts = [[1 cumlens(1:end-1)+1];reshape(pos_us+1,N-1,[])]; ends = [reshape(pos_us-1,N-1,[]) ; cumlens]; gaps = ends(:) - starts(:) + 1; maxg = max(gaps); mask1 = bsxfun(@lt,maxg-gaps num_array = zeros(maxg,numel(lens)*N, num_array(mask1) = digits_array1(~mask_us)-48; out = reshape(10.^(maxg-4:-1:-3)*num_array,N,[]). out = gather(out); return;
function M = func_eval_strjoin(C) M = eval([ end function M = func_eval_sprintf(C) C = strrep(C, M = eval([ end function M = func_eval_cellfun(C) M = cell2mat(cellfun(@eval, strcat( end function M = func_eval_loop(C) M = zeros(numel(C),nnz(C{1}== for i=1:numel(C) M(i,:) = eval([ end end
function M = func_str2num_strjoin(C) M = reshape(str2num(strjoin(strrep(C. end function M = func_str2num_sprintf(C) C = strrep(C, M = reshape(str2num(sprintf( end function M = func_str2num_cellfun(C) M = cell2mat(cellfun(@str2num, strrep(C, end function M = func_str2num_loop(C) M = zeros(numel(C),nnz(C{1}== for i=1:numel(C) M(i,:) = str2num(strrep(C{i}, end end
function M = func_sscanf_strjoin(C) M = reshape(sscanf(strjoin(C end function M = func_sscanf_sprintf(C) M = reshape(sscanf(sprintf( end function M = func_sscanf_cellfun(C) M = cell2mat(cellfun(@(c) sscanf(c, end function M = func_sscanf_loop(C) M = zeros(numel(C),nnz(C{1}== for i=1:numel(C) M(i,:) = sscanf(C{i}, end end
function M = func_textscan_strjoin(C) M = textscan(strjoin(C M = reshape(M{1}, [], numel(C)). end function M = func_textscan_sprintf(C) M = textscan(sprintf( M = reshape(M{1}, [], numel(C)). end function M = func_textscan_cellfun(C) M = cell2mat(cellfun(@(str) textscan(str, end function M = func_textscan_loop(C) M = zeros(numel(C),nnz(C{1}== for i=1:numel(C) x = textscan(C{i}, M(i,:) = x{1}; end end
function M = func_str2double_strsplit_strjoin(C) M = reshape(str2double(strsplit(strjoin(C end function M = func_str2double_strsplit_sprintf(C) M = strsplit(sprintf( M = reshape(str2double(M(1:end-1)), [], numel(C)). end function M = func_str2double_strsplit(C) M = cellfun(@(c) strsplit(c, M = str2double(cat(1,M{:})); end function M = func_str2double_strsplit_cellfun(C) M = cell2mat(cellfun(@(c) str2double(strsplit(c, end function M = func_str2double_strsplit_loop(C) M = zeros(numel(C),nnz(C{1}== for i=1:numel(C) M(i,:) = str2double(strsplit(C{i}, end end function M = func_str2double_regex_split_strjoin(C) M = reshape(str2double(regexp(strjoin(C. end function M = func_str2double_regex_split_sprintf(C) M = regexp(sprintf( M = reshape(str2double(M(1:end-1)), [], numel(C)). end function M = func_str2double_regex_split(C) M = regexp(C, M = reshape(str2double([M{:}]), [], numel(C)). end function M = func_str2double_regex_split_cellfun(C) M = cell2mat(cellfun(@str2double, regexp(C, end function M = func_str2double_regex_split_loop(C) M = zeros(numel(C),nnz(C{1}== for i=1:numel(C) M(i,:) = str2double(regexp(C{i}, end end
function M = func_str2double_regex_tokens_strjoin_1(C) M = reshape(cellfun(@str2double, regexp(strjoin(C. end function M = func_str2double_regex_tokens_strjoin_2(C) M = regexp(strjoin(C. M = reshape(str2double([M{:}]), [], numel(C)). end function M = func_str2double_regex_tokens_sprintf_1(C) M = reshape(cellfun(@str2double, regexp(sprintf( end function M = func_str2double_regex_tokens_sprintf_2(C) M = regexp(sprintf( M = reshape(str2double([M{:}]), [], numel(C)). end function M = func_str2double_regex_tokens(C) M = regexp(C, M = cat(1,M{:}); M = reshape(str2double([M{:}]), size(M)); end function M = func_str2double_regex_tokens_cellfun(C) M = regexp(C, M = cellfun(@str2double, cat(1,M{:})); end function M = func_str2double_regex_tokens_loop(C) M = zeros(numel(C),nnz(C{1}== for i=1:numel(C) x = regexp(C{i}, M(i,:) = str2double([x{:}]); end end
>> gpuDevice ans = CUDADevice with properties: Name: Index: 1 ComputeCapability: SupportsDouble: 1 DriverVersion: 5.5000 ToolkitVersion: 5.5000 MaxThreadsPerBlock: 1024 MaxShmemPerBlock: 49152 MaxThreadBlockSize: [1024 1024 64] MaxGridSize: [65535 65535 65535] SIMDWidth: 32 TotalMemory: 2.1475e+09 FreeMemory: 2.0453e+09 MultiprocessorCount: 2 ClockRateKHz: 950000 ComputeMode: GPUOverlapsTransfers: 1 KernelExecutionTimeout: 1 CanMapHostMemory: 1 DeviceSupported: 1 DeviceSelected: 1
>> t t = func nrows ncols time ________________________________________ _____ _____ __________
for (mwIndex idx=0, i=0; idx<n_words; ++idx) { std::string str = getString(cellstr, idx); std::string::const_iterator istr = str.cbegin(); for (; istr != str.cend(); ++istr) { if (*istr < { ++i; continue; } out[i] *= 10; out[i] += *istr - } ++i; }
>> t t = func nrows ncols time ____________________________________ _____ _____ __________
function array_of_numbers = char_and_sscanf_solution(list_of_words) s = char(list_of_words); s(s==95) = 32; % s = [ s repmat(32, numel(list_of_words), 1) ]; array_of_numbers = reshape(sscanf(s.
Generating 10000-words test case... Timing 10000-words test case... eval_and_loops_solution: 0.190642[s] single_sscanf_solution: 0.234413[s] approach1: 0.073901[s] char_and_sscanf_solution: 0.068311[s] Generating 100000-words test case... Timing 100000-words test case... eval_and_loops_solution: 1.957728[s] single_sscanf_solution: 2.426764[s] approach1: 0.766020[s] char_and_sscanf_solution: 0.706387[s] Generating 1000000-words test case... Timing 1000000-words test case... eval_and_loops_solution: 18.975746[s] char_and_sscanf_solution: 7.147229[s]
function M = extractIntsSprintfTextScan(list_of_words) % optimized lines, see below for explanation of each op M = textscan(sprintf( M = reshape(M{1}, [], numel(C)). % cell to string, adding _ suffix % s = sprintf( % extract integers given _ as delimiter % C = textscan(s, % C = textscan(s, % matrix form % M = reshape(C{1},[],numel(list_of_words)). end
function array_of_numbers = mex_solution(list_of_words) array_of_numbers = solution_mex(list_of_words). end
% compile with MinGW-w64 >> mex -largeArrayDims -f mingwopts.bat solution_mex.cpp -output solution_mex_gcc % set appropriate number of threads >> setenv( % quick benchmark >> timeit(@() solution_mex_gcc(repmat({ ans = 0.6658
% function array_of_numbers = all_loops(list_of_words) % n_numbers = 1 + sum(list_of_words{1}== n_words = numel(list_of_words); % array_of_numbers = zeros(n_numbers, n_words); slice_of_numbers = zeros(n_numbers, 1); % for k = 1:n_words str = list_of_words{k}; pos_max = size(str, 2); value = 0; index = 1; for pos = 1:pos_max if str(pos) == slice_of_numbers(index) = value; value = 0; index = index + 1; else value = 10*value + (str(pos) - end; slice_of_numbers(index) = value; % end; array_of_numbers(:, k) = slice_of_numbers; end; % array_of_numbers = transpose(array_of_numbers / 1000); end
MATLAB configuration information CPU: x86 Family 6 Model 58 Stepping 9, GenuineIntel This data was gathered on: 24-Oct-2014 14:19:31 The measured CPU speed is: 2600 MHz MATLAB version: 7.14.0.739 (R2012a) Number of processors: 4 MATLAB root: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx RAM: 3289 MB MATLAB accelerator enabled Swap space: 6576 MB MATLAB JIT: enabled Microsoft Windows 7 MATLAB assertions: disabled Number of cores: 2 MATLAB Desktop: enabled Number of threads: 2
Generating 10000-words test case... Timing 1000000-words test case... approach4: Error - Out of memory. Type HELP MEMORY for your options. approach1: Error - Out of memory. Type HELP MEMORY for your options. single_sscanf_solution: Error - Out of memory. Type HELP MEMORY for your options. char_and_sscanf_solution: 5.076296[s] extractIntsSprintfTextScan: 4.328066[s] all_loops: 1.795730[s] eval_and_loops_solution: 10.027541[s] Generating 100000-words test case... Timing 100000-words test case... approach4: 0.252107[s] approach1: 0.370727[s] single_sscanf_solution: 1.364936[s] char_and_sscanf_solution: 0.515599[s] extractIntsSprintfTextScan: 0.444586[s] all_loops: 0.179575[s] eval_and_loops_solution: 1.010240[s] Generating 10000-words test case... Timing 10000-words test case... approach4: 0.026642[s] approach1: 0.039550[s] single_sscanf_solution: 0.136711[s] char_and_sscanf_solution: 0.049708[s] extractIntsSprintfTextScan: 0.042608[s] all_loops: 0.017636[s] eval_and_loops_solution: 0.099111[s]
func nrows ncols time __________________________ _____ _____ ________
MATLAB Version: 8.3.0.532 (R2014a) Operating System: Ubuntu 14.04 LTS 64-bit RAM: 4GB CPU Model: Intel® Pentium® Processor E5400 (2M Cache, 2.70 GHz) GPU Model: GTX 750Ti 2GB
MATLAB accelerator enabled MATLAB JIT: enabled MATLAB assertions: disabled MATLAB Desktop: enabled Java JVM: enabled CPU: x86 Family 6 Model 23 Stepping 10, GenuineIntel Number of processors: 2 CPU speed is: 2700 MHz RAM: 4046992 kB Swap space: 9760764 kB Number of cores: 2 Number of threads: 2
function M = func_voigt_loop(C) S = sprintf( digitpos = [find(S(2:end) == M = zeros(size(digitpos)); place = 1; while 1 digits = S(digitpos); mask = double(digits ~= M = M + mask.*(digits - place = place * 10; digitpos = digitpos - mask; if ~any(mask); break; end end M = reshape(M, [], numel(C)) end
optimization finished, nu = 0.612233 obj = -90.291046, rho = -0.367013 nSV = 165, nBSV = 128 Total nSV = 165 Cross Validation Accuracy = 98.1273%
bestcv = 0; for log2c = -6:10, for log2g = -6:3, cmd = [ cv = svmtrain(TrainLabel,TrainVec, cmd); if (cv >= bestcv), bestcv = cv; bestc = 2^log2c; bestg = 2^log2g; end fprintf( end end
% [labels,data] = libsvmread( % folds = 5; [C,gamma] = meshgrid(-5:2:15, -15:2:3); % cv_acc = zeros(numel(C),1); for i=1:numel(C) cv_acc(i) = svmtrain(labels, data, ... sprintf( end % [~,idx] = max(cv_acc); % contour(C, gamma, reshape(cv_acc,size(C))), colorbar hold on plot(C(idx), gamma(idx), text(C(idx), gamma(idx), sprintf( hold off xlabel( % best_C = 2^C(idx); best_gamma = 2^gamma(idx); %
%%%%%%%%%%%%%% StructVsCell.m %%%%%%%%%%%%%%% clear all M = 100; % number of repetitions N = 2^10; % size of cell array and struct for m = 1:M % Fill up a template cell array with % lists of randomly sized matrices with % random elements. template{N} = 0; for n = 1:N r1 = round(24*rand()); r2 = round(24*rand()); r3 = rand(round(r2*rand),round(r1*rand())); template{N} = r3; end % Make a cell array equivalent % to the template. cell_array = template; % Create a struct with the % same data. structure = struct( for n = 1:N structure(n).data = template{n}; end % Time cell array tic; for n = 1:N data = cell_array{n}; cell_array{n} = data end cell_time(m) = toc; % Time struct tic; for n = 1:N data = structure(n).data; structure(n).data = data end struct_time(m) = toc; end str = sprintf( disp(str); str = sprintf( disp(str); str = sprintf( disp(str); % Check memory use whos %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
vec = 1:5; % A sample vector of values fcnList = {@max, @min, @mean}; % Functions to apply to the vector nFcns = numel(fcnList); % Number of functions to evaluate result = zeros(1, nFcns); % Variable to store the results for iFcn = 1:nFcns result(iFcn) = fcnList{iFcn}(vec); % Get the handle and evaluate it end
ABC,51.9358183333333,4.183255 ABC,51.9353866666667,4.1841 ABC,51.9351716666667,4.184565 ABC,51.9343083333333,4.186425 ABC,51.9343083333333,4.186425 ABC,51.9340916666667,4.18688333333333
>> [numData,textData,rawData] = xlsread( numData = % An array of the numeric values from the file 51.9358 4.1833 51.9354 4.1841 51.9352 4.1846 51.9343 4.1864 51.9343 4.1864 51.9341 4.1869 textData = % A cell array of strings for the text values from the file rawData = % All the data from the file (numeric and text) in a cell array
index = sqrt(sum(numData.^2,2)) >= 50; % Find the rows where the point is % at a distance of 50 or greater % from the origin xlswrite(
fid1 = fopen( fid2 = fopen( while ~feof(fid1) line = fgets(fid1); % A = sscanf(line, if A(2)<4.185 % fprintf(fid2, end end fclose(fid1); fclose(fid2);
function cost = computeCost(x, y, theta) htheta = sigmoid(x*theta); cost = sum(-y .* log(htheta) - (1-y) .* log(1-htheta)); end
function [theta,cost_history] = batchGD(x,y,theta,alpha) cost_history = zeros(1000,1); for iter=1:1000 htheta = sigmoid(x*theta); new_theta = zeros(size(theta,1),1); for feature=1:size(theta,1) new_theta(feature) = theta(feature) - alpha * sum((htheta - y) .*x(:,feature)) end theta = new_theta; cost_history(iter) = computeCost(x,y,theta); end end
mX = mean(x,1); mX(1) = 0; sX = std(x,[],1); sX(1) = 1; xnew = bsxfun(@rdivide, bsxfun(@minus, x, mX), sX);
xxnew = bsxfun(@rdivide, bsxfun(@minus, xx, mX), sX);
cost = sum(-y .* log(htheta) - (1-y) .* log(1-htheta));
y_logical = y == 1; cost = sum(-log(htheta(y_logical))) + sum( - log(1 - htheta(~y_logical)));
text(0.5, 0.8, text(0.5, 0.7, text(0.5, 0.6, text(0.5, 0.5,
/usr/share/texmf/fonts/opentype/public/lm/lmroman10-bold.otf: Latin Modern Roman,LM Roman 10:style=10 Bold,Bold /usr/share/texmf/fonts/opentype/public/lm/lmroman7-italic.otf: Latin Modern Roman,LM Roman 7:style=7 Italic,Italic ... etc etc...
A = cellfun( @(X)( randn( 5,5 ) ), cell( 5,1 ), B = cellfun( @(X)( randn( 5,5 ) ), cell( 5,1 ), %# % % %# % % C = cellfun( @(X,Y)( X + Y ), A, B, %# % % D = cellfun( @(X,Y)( X .* Y ), A, B, %# % % E = cellfun( @(X,Y)( X * Y ), A, B,
temp1 = cellfun( @(X)( c1*X ), A ); temp2 = cellfun( @(X)( c2*X ), B ); Z = cellfun( @plus, temp1, temp2 );
>> methods cell Methods for class cell: aa2nt issorted regexptranslate strfind accumarray newdepfun reshape strjust cell2struct nt2aa rna2dna strmatch ctranspose nwalign seq2regexp strtok display permute setdiff transpose dna2rna regexp setxor union intersect regexpi sort unique ismember regexprep strcat
>> A = {[1 2 3] [4 5] 6}; % >> B = {5 [4 5] 2}; % >> C = A+B; % >> C{:} % ans = 6 7 8 ans = 8 10 ans = 8
N = 100000; x = rand(N,1); y = rand(N,1); C = sin(2*x)+y; cdivs = 10; [~, edges] = hist(C,cdivs-1); edges = [-Inf edges Inf]; % to include all points [Nk, bink] = histc(C,edges); figure; hold on; cmap = jet(cdivs); for ii=1:cdivs idx = bink==ii; plot(x(idx),y(idx), end colormap(cmap) caxis([min(C) max(C)]) colorbar
tic P=rand(1e5,2); Edge=.01; X=[P(:,1) Y=[P(:,2) figure; h=patch(X,Y, set(h, drawnow toc
function foo(x) if isnumeric(x) disp( elseif ischar(x) disp( end end
function goo(varargin) if nargin == 2 disp( elseif nargin == 3 disp( end end
function makeSandwiches(amount, varargin) % % % % % % % p = inputParser(); % p.addRequired( p.addOptional( p.addOptional( @(x) strcmp(x, p.addOptional( p.parse(amount, varargin{:}); % % % if p.Results.amount == 1 stringAmount = else stringAmount = sprintf( end if p.Results.butter stringButter = else stringButter = end % fprintf([ stringAmount, stringButter, p.Results.breadType, p.Results.toppings); end
try <funktion from specific toolbox> <do this if it is available> catch <do this if it is not end
fprintf( for i = 1:5 fprintf( % do some work on that pass... end fprintf(
>> uint8(2) - uint8(1) ans = 1 >> uint8(2) - uint8(2) ans = 0 >> uint8(2) - uint8(3) ans = 0
N = 512; it = 400; im = zeros(N); % [ind_x,ind_y] = ndgrid(1:2:N,1:2:N); index = sub2ind(size(im),ind_x,ind_y); tic for i=1:it im(index) = im(index) + 1; end toc % % x = 1:2:N; y = 1:2:N; tic for i=1:it im(x,y) = im(x,y) +1; end toc % % % index = uint32(index); tic for i=1:it im(index) = im(index) +1; end toc% % x = uint32(1:2:N); y = uint32(1:2:N); tic for i=1:it im(x,y) = im(x,y) +1; end toc% %% /*********************comparison with others*****************/ % tic for i=1:it for j=1:2:N for k=1:2:N im(j,k) = im(j,k)+1; end end end toc%
LOOPED subs assignment: 0.2878s linear assignment: 0.0812s VECTORIZED subs assignment: 0.0302s linear assignment: 0.0862s
function B = subscriptedIndexing(A,row,col) n = numel(row); B = zeros(n); for r = 1:n for c = 1:n B(r,c) = A(row(r),col(c)); end end end function B = linearIndexing(A,index) B = zeros(size(index)); for ii = 1:numel(index) B(ii) = A(index(ii)); end end
function B = subscriptedIndexingVect(A,row,col) n = numel(row); B = zeros(n); B = A(row,col); end function B = linearIndexingVect(A,index) B = zeros(size(index)); B = A(index); end
function testFun(N) A = magic(N); row = 1:2:N; col = 1:2:N; [ind_x,ind_y] = ndgrid(row,col); index = sub2ind(size(A),ind_x,ind_y); % isequal(linearIndexing(A,index), subscriptedIndexing(A,row,col)) % isequal(linearIndexingVect(A,index), subscriptedIndexingVect(A,row,col)) fprintf( fprintf( fprintf( fprintf( fprintf( fprintf( end
feature accel off testFun(5e3) ... VECTORIZED subs assignment: 0.0303s linear assignment: 0.0873s feature accel on testFun(5e3) ... VECTORIZED subs assignment: 0.0303s linear assignment: 0.0871s
feature accel off testFun(5e3) LOOPED subs assignment: 7.8915s linear assignment: 6.4418s VECTORIZED subs assignment: 0.0295s linear assignment: 0.0878s
it = 400; im = zeros(512*512,1); x = 1:2:size(im,1); y = 1:2:size(im,2); % [ind_x,ind_y] = ndgrid(x,y); index = sub2ind(size(im),ind_x,ind_y); tic for i=1:it im(index) = im(index) + 1; end toc % tic for i=1:it im(x,y) = im(x,y) +1; end toc
N = 512; it = 400; im = zeros(N); % x = 1:2:N; y = 1:2:N; tic for i=1:it im(x,y) = im(x,y) +1; end toc % % [ind_x,ind_y] = ndgrid(1:2:N,1:2:N); index = sub2ind(size(im),ind_x,ind_y); tic for i=1:it im(index) = im(index) + 1; end toc %
N = 512; it = 400; im1 = zeros(N); im2 = zeros(N); % x = 1:2:N; y = 1:2:N; tic for i=1:it im1(x,y) = im1(x,y) + 1; end toc % % [ind_x,ind_y] = ndgrid(1:2:N,1:2:N); index = sub2ind(size(im2),ind_x,ind_y); tic for i=1:it im2(index) = im2(index) + 1; end toc %
N = 512; it = 400; im = zeros(N); % tic for i=1:N^2 im(i) = im(i) +1; end toc % x = 1:2:N; y = 1:2:N; tic for i=1:it im(x,y) = im(x,y) +1; end toc % % [ind_x,ind_y] = ndgrid(1:2:N,1:2:N); index = sub2ind(size(im),ind_x,ind_y); tic for i=1:it im(index) = im(index) + 1; end toc %
plot(1:10) % get handle to current axes a = gca; % set box property to off and remove background color set(a, % create new, empty axes with box but without ticks b = axes( % set original axes as active axes(a) % link axes in case of zooming linkaxes([a b])
figure hold on box off plot(1:10) plot([1,10],[10, 10], plot([10,10],[1,10],
s = 12000; D = rand(s); cols = sort(randsample(s,2)) rows = sort(randsample(s,2)) A = D; tic A(rows,:) = []; A(:,cols) = []; toc % Elapsed time is 54.982124 seconds.
A = zeros(size(D) - [numel(rows) numel(cols)]); r = true(size(D,1),1); c = true(size(D,2),1); r(rows) = false; c(cols) = false; tic A = D(r,c); toc % Elapsed time is 20.083072 seconds.
s = 8000; D = rand(s); D1 = D(1:s/2,:); D2 = D((s/2 + 1):end,:); cols = sort(randsample(s,2)); rows = sort(randsample(s,2)); A1 = D1; A2 = D2; tic A1(rows(rows <= s/2),:) = []; A2(rows(rows > s/2) - s/2,:) = []; A1(:,cols) = []; A2(:,cols) = []; toc A = D; tic A(rows,:) = []; A(:,cols) = []; toc Elapsed time is 2.317080 seconds. Elapsed time is 140.771632 seconds.
A = D(randsample(s,2), randsample(s,2)); clear D; % Use A
plot(-2:5, (-2:5).^2-1) % hx = graph2d.constantline(0, changedependvar(hx, % hy = graph2d.constantline(0, changedependvar(hy,
x=-2:5; y=x.^2-1; figure() plot(x,y); xlim = get(gca, hold on plot([xlim(1) xlim(2)],[0 0],
% isequalAbs = @(x,y,tol) ( abs(x-y) <= tol ); % isequalRel = @(x,y,tol) ( abs(x-y) <= ( tol*max(abs(x),abs(y)) + eps) );
% x == y isequalAbs(x, y, 1e-6) isequalRel(x, y, 1e-6)
clf figure(1) for g = 0:.2:2 for i = 0:.2:2 plot3([g g], [0 2], [i, i]) hold on end end for g = 0:.2:2 for i = 0:.2:2 plot3([0 2], [g g], [i, i]) hold on end end for g = 0:.2:2 for i = 0:.2:2 plot3([i i], [g g], [0 2]) hold on end end
% x = -8:2:8; y = -8:2:8; z = -8:2:8; [X1 Y1 Z1] = meshgrid(x([1 end]),y,z); X1 = permute(X1,[2 1 3]); Y1 = permute(Y1,[2 1 3]); Z1 = permute(Z1,[2 1 3]); X1(end+1,:,:) = NaN; Y1(end+1,:,:) = NaN; Z1(end+1,:,:) = NaN; [X2 Y2 Z2] = meshgrid(x,y([1 end]),z); X2(end+1,:,:) = NaN; Y2(end+1,:,:) = NaN; Z2(end+1,:,:) = NaN; [X3 Y3 Z3] = meshgrid(x,y,z([1 end])); X3 = permute(X3,[3 1 2]); Y3 = permute(Y3,[3 1 2]); Z3 = permute(Z3,[3 1 2]); X3(end+1,:,:) = NaN; Y3(end+1,:,:) = NaN; Z3(end+1,:,:) = NaN; % h = line([X1(:);X2(:);X3(:)], [Y1(:);Y2(:);Y3(:)], [Z1(:);Z2(:);Z3(:)]); set(h, % % % axis off view(3), axis vis3d camproj perspective, rotate3d on
i = 0:0.2:2; [X Y] = meshgrid(i,i); x = [X(:) X(:)] y = [Y(:) Y(:)] z = [repmat(i(1),1,length(x)); repmat(i(end),1,length(x))]; col = hold on; plot3(x,y,z,col); plot3(y,z,x,col); plot3(z,x,y,col);
cellfun(@patch,XYZ{1},XYZ{2},XYZ{3},... repmat({clr},6,1),... repmat({ repmat({alpha},6,1),... repmat({ repmat({0.2},6,1),... % Set this value to whatever you want; even a variable / matrix repmat({ repmat({ );
function plotcube(varargin) % PLOTCUBE - Display a 3D-cube in the current axes % % PLOTCUBE(EDGES,ORIGIN,ALPHA,COLOR) displays a 3D-cube in the current axes % with the following properties: % * EDGES : 3-elements vector that defines the length of cube edges % * ORIGIN: 3-elements vector that defines the start point of the cube % * ALPHA : scalar that defines the transparency of the cube faces (from 0 % to 1) % * COLOR : 3-elements vector that defines the faces color of the cube % % Example: % >> plotcube([5 5 5],[ 2 2 2],.8,[1 0 0]); % >> plotcube([5 5 5],[10 10 10],.8,[0 1 0]); % >> plotcube([5 5 5],[20 20 20],.8,[0 0 1]); % Default input arguments inArgs = { ... [10 56 100] , ... % Default edge sizes (x,y and z) [10 10 10] , ... % Default coordinates of the origin point of the cube .7 , ... % Default alpha value for the cube [1 0 0] ... % Default Color for the cube }; % Replace default input arguments by input values inArgs(1:nargin) = varargin; % Create all variables [edges,origin,alpha,clr] = deal(inArgs{:}); XYZ = { ... [0 0 0 0] [0 0 1 1] [0 1 1 0] ; ... [1 1 1 1] [0 0 1 1] [0 1 1 0] ; ... [0 1 1 0] [0 0 0 0] [0 0 1 1] ; ... [0 1 1 0] [1 1 1 1] [0 0 1 1] ; ... [0 1 1 0] [0 0 1 1] [0 0 0 0] ; ... [0 1 1 0] [0 0 1 1] [1 1 1 1] ... }; XYZ = mat2cell(... cellfun( @(x,y,z) x*y+z , ... XYZ , ... repmat(mat2cell(edges,1,[1 1 1]),6,1) , ... repmat(mat2cell(origin,1,[1 1 1]),6,1) , ... 6,[1 1 1]); cellfun(@patch,XYZ{1},XYZ{2},XYZ{3},... repmat({clr},6,1),... repmat({ repmat({alpha},6,1)... ); view(3);
clear all close all clc Nx=11; Ny=11; Nz=11; clf hold on [i,j]=meshgrid(1:Nx,1:Ny); k=zeros(Ny,Nx)+Nz; surf(i,j,k) [i,k]=meshgrid(1:Nx,1:Nz); j=zeros(Nz,Nx)+Ny; surf(i,j,k) [j,k]=meshgrid(1:Ny,1:Nz); i=zeros(Nz,Ny)+Nx; surf(i,j,k) [i,j]=meshgrid(1:Nx,1:Ny); k=zeros(Ny,Nx)+1; surf(i,j,k) [i,k]=meshgrid(1:Nx,1:Nz); j=zeros(Nz,Nx)+1; surf(i,j,k) [j,k]=meshgrid(1:Ny,1:Nz); i=zeros(Nz,Ny)+1; surf(i,j,k) view(30,30)
>> x = [1; 1.1; 1.05]; % elements need not be sorted >> builtin( ans = 1.0000 1.0500 1.1000
>> builtin( ans = 1.0000 % first of [1, 1.05] since abs(1 - 1.05) < 0.1 1.1000 >> builtin( ans = 1.0250 % average of [1, 1.05] 1.1000 >> builtin( ans = 1.0500 % average of [1, 1.1, 1.05]
>> x = [1 2; 1.06 2; 1.1 2; 1.1 2.03] x = 1.0000 2.0000 1.0600 2.0000 1.1000 2.0000 1.1000 2.0300
>> xMerged = builtin( xMerged = 1.0000 2.0000 1.0600 2.0000 1.1000 2.0000 1.1000 2.0300
>> xMerged = builtin( xMerged = 1.0000 2.0000 1.0600 2.0000 1.1000 2.0000 % first of rows 3 and 4 >> xMerged = builtin( xMerged = 1.0000 2.0000 1.0600 2.0000 1.1000 2.0150 % average of rows 3 and 4
>> xMerged = builtin( xMerged = 1.0533 2.0000 % average of rows 1 to 3 1.1000 2.0300 >> xMerged = builtin( xMerged = 1.0000 2.0000 1.0800 2.0000 % average of rows 2 and 3 1.1000 2.0300 % row 4 not merged because of second dimension
>> xMerged = builtin( xMerged = 1.0000 2.0000 1.0867 2.0100 % average of rows 2 to 4
r = rand(100,1); % some random data roundedData = round(r*1e6)/1e6; % round to 1e-6 uniqueValues = unique(roundedData);
r = rand(100,1); % create 100 random values between 0 and 1 grid = 0:0.001:1; % creates a vector of uniquely spaced values counts = hist(r,grid); % now you know for each element in uniqueValues = grid(counts>0); % and these are the uniques
tol = 0.001 [Y I] = sort(items(:)); uni_mask = diff([0; Y]) > tol; %if you just want the unique items: uni_items = Y(uni_mask); %in sorted order uni_items = items(I(uni_mask)); % in the original order
NUM = round(numel(items) / 10); % a rough guess bins = linspace(min(items), max(items), NUM); counts = histc(items, bins); unit_items = bins(counts > 0);
load fisheriris x = meas(:,3:4); gscatter(x(:,1),x(:,2),species) newpoint = [5 1.45]; [n,d] = knnsearch(x,newpoint, line(x(n,1),x(n,2),
N = size(x,1); dists = zeros(N,1); for idx = 1 : N dists(idx) = sqrt(sum((x(idx,:) - newpoint).^2)); end
N = size(x,1); dists = zeros(N,1); for idx = 1 : N dists(idx) = sum(abs(x(idx,:) - newpoint)); end
N = size(x, 1); dists = sqrt(sum((x - repmat(newpoint, N, 1)).^2, 2));
N = size(x, 1); dists = sum(abs(x - repmat(newpoint, N, 1)), 2);
dists = sqrt(sum(bsxfun(@minus, x, newpoint).^2, 2));
ind_closest = ind(1:k); x_closest = x(ind_closest,:);
dists = sqrt(sum(bsxfun(@minus, x, newpoint).^2, 2)); % % dists = sum(abs(bsxfun(@minus, x, newpoint)), 2); [d,ind] = sort(dists); ind_closest = ind(1:k); x_closest = x(ind_closest,:);
load fisheriris x = meas(:,3:4); newpoint = [5 1.45]; k = 10; % dists = sqrt(sum(bsxfun(@minus, x, newpoint).^2, 2)); [d,ind] = sort(dists); ind_closest = ind(1:k); x_closest = x(ind_closest,:);
>> ind_closest ind_closest = 120 53 73 134 84 77 78 51 64 87 >> x_closest x_closest = 5.0000 1.5000 4.9000 1.5000 4.9000 1.5000 5.1000 1.5000 5.1000 1.6000 4.8000 1.4000 5.0000 1.7000 4.7000 1.4000 4.7000 1.4000 4.7000 1.5000
% load fisheriris; x = meas(:,3:4); newpoints = [5 1.45; 7 2; 4 2.5; 2 3.5]; % Q = size(newpoints, 1); M = size(x, 2); k = 10; x_closest = zeros(k, M, Q); ind_closest = zeros(Q, k); % for ii = 1 : Q % newpoint = newpoints(ii, :); % dists = sqrt(sum(bsxfun(@minus, x, newpoint).^2, 2)); [d,ind] = sort(dists); % ind_closest(ii, :) = ind(1 : k). x_closest(:, :, ii) = x(ind_closest(ii, :), :); end
nA = sum(A.^2, 2); % nB = sum(B.^2, 2); % D = bsxfun(@plus, nA, nB. D = sqrt(D); %
% load fisheriris; x = meas(:,3:4); newpoints = [5 1.45; 7 2; 4 2.5; 2 3.5]; % k = 10; Q = size(newpoints, 1); M = size(x, 2); nA = sum(newpoints.^2, 2); % nB = sum(x.^2, 2); % D = bsxfun(@plus, nA, nB. D = sqrt(D); % % [d, ind] = sort(D, 2); % ind_closest = ind(:, 1:k); % x_closest = permute(reshape(x(ind_closest(:), :).
row_indices = repmat((1:Q). linear_ind = sub2ind(size(d), row_indices, ind_closest); dist_sorted = D(linear_ind);
>> ind_closest ind_closest = 120 134 53 73 84 77 78 51 64 87 123 119 118 106 132 108 131 136 126 110 107 62 86 122 71 127 139 115 60 52 99 65 58 94 60 61 80 44 54 72 >> x_closest x_closest(:,:,1) = 5.0000 1.5000 6.7000 2.0000 4.5000 1.7000 3.0000 1.1000 5.1000 1.5000 6.9000 2.3000 4.2000 1.5000 3.6000 1.3000 4.9000 1.5000 6.7000 2.2000 x_closest(:,:,2) = 4.5000 1.6000 3.3000 1.0000 4.9000 1.5000 6.6000 2.1000 4.9000 2.0000 3.3000 1.0000 5.1000 1.6000 6.4000 2.0000 4.8000 1.8000 3.9000 1.4000 x_closest(:,:,3) = 4.8000 1.4000 6.3000 1.8000 4.8000 1.8000 3.5000 1.0000 5.0000 1.7000 6.1000 1.9000 4.8000 1.8000 3.5000 1.0000 4.7000 1.4000 6.1000 2.3000 x_closest(:,:,4) = 5.1000 2.4000 1.6000 0.6000 4.7000 1.4000 6.0000 1.8000 3.9000 1.4000 4.0000 1.3000 4.7000 1.5000 6.1000 2.5000 4.5000 1.5000 4.0000 1.3000 >> dist_sorted dist_sorted = 0.0500 0.1118 0.1118 0.1118 0.1803 0.2062 0.2500 0.3041 0.3041 0.3041 0.3000 0.3162 0.3606 0.4123 0.6000 0.7280 0.9055 0.9487 1.0198 1.0296 0.9434 1.0198 1.0296 1.0296 1.0630 1.0630 1.0630 1.1045 1.1045 1.1180 2.6000 2.7203 2.8178 2.8178 2.8320 2.9155 2.9155 2.9275 2.9732 2.9732
% id = cumsum(cut)+1 % mask = cut==0 % out = accumarray(id(mask).
N = 100000; % vec = randi(100,1,N); % cut = randi(2,1,N)-1; disp( tic id = cumsum(cut)+1; mask = cut==0; out = accumarray(id(mask). toc disp( tic N = numel(vec); ind = find(cut); ind_before = [ind-1 N]; ind_before(ind_before < 1) = 1; ind_after = [1 ind+1]; ind_after(ind_after > N) = N; out = arrayfun(@(x,y) vec(x:y), ind_after, ind_before, toc disp( tic cutsum = cumsum(cut); cutsum(cut == 1) = NaN; %Don sumvals = unique(cutsum); % Find the values to use in indexing vec for the output sumvals(isnan(sumvals)) = []; %Remove NaN values from sumvals output = arrayfun(@(val) vec(cutsum == val), sumvals, toc
-------------------- With CUMSUM + ACCUMARRAY Elapsed time is 0.068102 seconds. -------------------- With FIND + ARRAYFUN Elapsed time is 0.117953 seconds. -------------------- With CUMSUM + ARRAYFUN Elapsed time is 12.560973 seconds.
% mask = cut==0 % id = cumsum(cut)+1 [~,~,id] = unique(id(mask)) % out = accumarray(id(:),vec(mask).
>> vec vec = 1 2 3 4 5 6 7 8 9 10 >> cut cut = 1 0 0 1 1 0 0 0 1 0 >> celldisp(out) out{1} = 2 3 out{2} = 6 7 8 out{3} = 10
vec = [1 2 3 4 5 6 7 8 9 10]; cut = [0 0 0 1 0 0 0 0 1 0]; cutsum = cumsum(cut); cutsum(cut == 1) = NaN; %Don sumvals = unique(cutsum); % Find the values to use in indexing vec for the output sumvals(isnan(sumvals)) = []; %Remove NaN values from sumvals output = {}; for i=1:numel(sumvals) output{i} = vec(cutsum == sumvals(i)); % end
output = arrayfun(@(val) vec(cutsum == val), sumvals,
output{1} = 1 2 3 output{2} = 5 6 7 8 output{3} = 10
vec = [1 2 3 4 5 6 7 8 9 10 11 12 13 14]; cut = [1 0 0 1 1 0 0 0 0 1 0 0 0 1];
output{1} = 2 3 output{2} = 6 7 8 9 output{3} = 11 12 13
vec = [1 2 3 4 5 6 7 8 9 10]; N = numel(vec); cut = [0 0 0 1 0 0 0 0 1 0]; ind = find(cut); ind_before = [ind-1 N]; ind_before(ind_before < 1) = 1; ind_after = [1 ind+1]; ind_after(ind_after > N) = N; out = arrayfun(@(x,y) vec(x:y), ind_after, ind_before,
>> celldisp(out) out{1} = 1 2 3 out{2} = 5 6 7 8 out{3} = 10
vec = [1 2 3 4 5 6 7 8 9 10]; cut = [1 0 0 1 0 0 0 1 0 1];
>> celldisp(out) out{1} = 1 out{2} = 2 3 out{3} = 5 6 7 out{4} = 9 out{5} = 10
lengths = diff(find([1 cut 1])) - 1; % assuming a row vector lengths = lengths(lengths > 0); data = vec(~cut); result = mat2cell(data, 1, lengths); % also assuming a row vector
-------------------- With CUMSUM + ACCUMARRAY Elapsed time is 0.272810 seconds. -------------------- With FIND + ARRAYFUN Elapsed time is 0.436276 seconds. -------------------- With CUMSUM + ARRAYFUN Elapsed time is 17.112259 seconds. -------------------- With mat2cell Elapsed time is 0.084207 seconds.
function spl = Splitting(vec,cut) n=1; j=1; for i=1:1:length(b) if cut(i)==0 spl{n}(j)=vec(i); j=j+1; else n=n+1; j=1; end end end
-------------------- With CUMSUM + ACCUMARRAY Elapsed time is 0.264428 seconds. -------------------- With FIND + ARRAYFUN Elapsed time is 0.407963 seconds. -------------------- With CUMSUM + ARRAYFUN Elapsed time is 18.337940 seconds. -------------------- SIMPLE Elapsed time is 0.271942 seconds.
pos_of_one = 0; % The loop finds the split points and puts their positions into a vector. for kk = 1 : length(cut) if cut(1,kk) == 1 pos_of_one = pos_of_one + 1; A(1,one_pos) = kk; end end F = vec(1 : A(1,1) - 1); G = vec(A(1,1) + 1 : A(1,2) - 1); H = vec(A(1,2) + 1 : end);
current_point = [1 2 3 ...]; % A 1-by-n array of subscripts subCell = num2cell(current_point); % A 1-by-n cell array of subscripts output_matrix(subCell{:}) = val; % Update the matrix point
A=magic(4) A = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1 selectElement={2,3}; % indx=sub2ind(size(A),selectElement{:}); A(indx) ans = 10
img = imread( scatter(rand(1,20)-0.5,rand(1,20)-0.5); % hold on; % image([-0.1 0.1],[0.1 -0.1],img); %
[xSphere,ySphere,zSphere] = sphere(16); % scatter3(xSphere(:),ySphere(:),zSphere(:), axis equal; % hold on; % xlabel( ylabel( zlabel( img = imread( xImage = [-0.5 0.5; -0.5 0.5]; % yImage = [0 0; 0 0]; % zImage = [0.5 0.5; -0.5 -0.5]; % surf(xImage,yImage,zImage,... %
CHECK_EVERY = 10; % tic i = 1; % while true % if rem(i,CHECK_EVERY) == 0 && exist( fprintf( keyboard tic end % i = i + 1; end
hFig = figure; drawnow while true if ~ishandle(hFig) keyboard hFig = figure; drawnow end % pause(0.5) end
for t = 1:10 pause(3) %Doing some calculations str = waitinput( if ~isnan(str) keyboard; % Enter dbcont if you want to continue from here end [ pause(3) %Doing some more calculations end
hSurface = surf(...your arguments to create the surface object...); set(hSurface,
x = rand(1,20); y = rand(1,20); z = rand(1,20); [X,Y] = meshgrid(linspace(0,1,10),linspace(0,1,10)); Z = rand(10)*0.1; clf plot3(x,y,z, hold on h = surf(X,Y,Z) hold off %% This will change the color colormap(copper) %% This will remove colordata set(h, %% This will make transparent alpha(0.5)
hSurface = surf(...your arguments to create the surface object...); set(hSurface,
function y = fun(x) colons = repmat({ % repeated the required number of times y = x(1,colons{:}).*x(2,colons{:}) + x(3,colons{:});
function y = fun(x, dim) % Input argument dim is the dimension along which to index colons_pre = repmat({ colons_post = repmat({ y = x(colons_pre{:}, 1, colons_post{:}) ... .*x(colons_pre{:}, 2, colons_post{:}) ... + x(colons_pre{:}, 3, colons_post{:});
function y = fun(x) xs = num2cell(x, [2:ndims(x)]); % x split along the first dimension y = xs{1}.*xs{2} + xs{3};
function y = fun(x, dim) xs = num2cell(x, [1:dim-1 dim+1:ndims(x)]); % x split along dimension dim y = xs{1}.*xs{2} + xs{3};
function y = MyMultiDimensional(x) x_size = size(x); % Get input size yflat = x(1,:) .* x(2,:) + x(3,:); % Calculate "flattened" 2D function y = reshape(yflat, [1 x_size(2:end)]); % Reshape output back to original size end
function y = MyMultiDimensional(x,n) x_size = size(x); % Get input size Order = 1:numel(x_size); Order(n)=[]; % Remove n-th dimension Order2 = [n, Order]; % Prepend n-th dimension xPermuted = permute(x,Order2); % permute the n-th dimension to the front yTmp = xPermuted (1,:) .* xPermuted (2,:) + xPermuted (3,:); % Calculate "flattened" 2D function y = reshape(yTmp, x_size(Order)); % Reshape output back to original size end
>> M = magic(3) M = 8 1 6 3 5 7 4 9 2 >> M(:) ans = 8 3 4 1 5 9 6 7 2
while(true) %code if condition==false break; end end
do = true; while(do || condition) % things to do... do = false; end
fib = ones (1, 10); i = 2; do i++; fib (i) = fib (i-1) + fib (i-2); until (i == 10)
try matStart(MatObj); catch err msgbox( fprintf(2,err.message); sprintf( display(err.message); end
try matStart(MatObj); catch err msgbox( disp(getReport(err, end
% display one channel only clear all; im=imread( im_red = im; im_green = im; im_blue = im; % Red channel only im_red(:,:,2) = 0; im_red(:,:,3) = 0; figure, imshow(im_red); % Green channel only im_green(:,:,1) = 0; im_green(:,:,3) = 0; figure, imshow(im_green); % Blue channel only im_blue(:,:,1) = 0; im_blue(:,:,2) = 0; figure, imshow(im_blue);
I = imread( %Red component R = I(:,:,1); image(R), colormap([[0:1/255:1] %Green Component G = I(:,:,2); figure; image(G), colormap([zeros(256,1),[0:1/255:1] %Blue component B = I(:,:,3); figure; image(B), colormap([zeros(256,1), zeros(256,1), [0:1/255:1]
im=imread( im_red=im(:,:,1); im_gray=rgb2gray(im); im_diff=imsubtract(im_red,im_gray); imshow(im_diff);
imagesc(im(:,:,1) ./ (im(:,:,1) + im(:,:,2) + im(:,:,3)))
function y = reshape2(x, m, n) y = zeros(m, n); ix = 0; for i = 1:m for j = 1:n ix = ix + 1; y(i, j) = x(ix); end end end
c=reshape(A B=reshape(c,k,p) example: m=3 n=4 , p=6, q=2 A=[1 2 3 4; 5 6 7 8; 9 10 11 12] c=[1 2 3 4 5 6 7 8 9 10 11 12] B=[1 2 ; 3 4; 5 6; 7 8; 9 10; 11 12]
figure(1); clf x = linspace(0,1,100); y = exp(-x); hold on; semilogy(x, y); semilogy(x, 2*y); hold off;
figure(1); clf x = linspace(0,1,100); y = exp(-x); semilogy(x, y); hold on; semilogy(x, 2*y); hold off;
% vec = randn(10,1); % maxVec = max(vec); minVec = min(vec); % vecN = ((vec-minVec)./(maxVec-minVec) - 0.5 ) *2; % vecD = (vecN./2+0.5) * (maxVec-minVec) + minVec
function [vecN, vecD] = normVec(vec,varargin) % Returns a normalize vector (vecN) and "de-nomralized" vector (vecD). The % function detects if both positive and negative values are present or not % and automatically normalizes between the appropriate range (i.e., [0,1], % [-1,0], or [-1,-1]. % Optional argument allows control of normalization range: % normVec(vec,0) => sets range based on positive/negative value detection % normVec(vec,1) => sets range to [0,1] % normVec(vec,2) => sets range to [-1,0] % normVec(vec,3) => sets range to [-1,1] %% Default Input Values % Check for proper length of input arguments numvarargs = length(varargin); if numvarargs > 1 error( end % Set defaults for optional inputs optargs = {0}; % Overwrite default values if new values provided optargs(1:numvarargs) = varargin; % Set input to variable names [setNorm] = optargs{:}; %% Normalize input vector % get max and min maxVec = max(vec); minVec = min(vec); if setNorm == 0 % Automated normalization if minVec >= 0 % Normalize between 0 and 1 vecN = (vec - minVec)./( maxVec - minVec ); vecD = minVec + vecN.*(maxVec - minVec); elseif maxVec <= 0 % Normalize between -1 and 0 vecN = (vec - maxVec)./( maxVec - minVec ); vecD = maxVec + vecN.*(maxVec - minVec); else % Normalize between -1 and 1 vecN = ((vec-minVec)./(maxVec-minVec) - 0.5 ) *2; vecD = (vecN./2+0.5) * (maxVec-minVec) + minVec; end elseif setNorm == 1 % Normalize between 0 and 1 vecN = (vec - minVec)./( maxVec - minVec ); vecD = minVec + vecN.*(maxVec - minVec); elseif setNorm == 2 % Normalize between -1 and 0 vecN = (vec - maxVec)./( maxVec - minVec ); vecD = maxVec + vecN.*(maxVec - minVec); elseif setNorm == 3 % Normalize between -1 and 1 vecN = ((vec-minVec)./(maxVec-minVec) - 0.5 ) *2; vecD = (vecN./2+0.5) * (maxVec-minVec) + minVec; else error( end
% Define vector x=linspace(0,4*pi,25); y = sin(x); ya=sin(x); yb=y+10; yc=y-10; % Normalize vector ya0=normVec(ya); yb0=normVec(yb); yc0=normVec(yc); ya1=normVec(ya,1); yb1=normVec(yb,1); yc1=normVec(yc,1); ya2=normVec(ya,2); yb2=normVec(yb,2); yc2=normVec(yc,2); ya3=normVec(ya,3); yb3=normVec(yb,3); yc3=normVec(yc,3); % Plot results figure(1) subplot(2,2,1) plot(x,ya0, title( subplot(2,2,2) plot(x,ya1, title( subplot(2,2,3) plot(x,ya2, title( subplot(2,2,4) plot(x,ya3, title(
maxA = max(A(:)); minA = min(A(:)); A = rescale(A, -1, 1); % use the normalised A A = rescale(A, minA, maxA);
x1 = [1 2 4; 1 1 1; 3 2 2; 0 0 0] [y1,PS] = mapminmax(x1)
function pval = spiegel_test(x) % compute pvalue under null of x normally distributed; % x should be a vector; xm = mean(x); xs = std(x); xz = (x - xm) ./ xs; xz2 = xz.^2; N = sum(xz2 .* log(xz2)); n = numel(x); ts = (N - 0.73 * n) / (0.8969 * sqrt(n)); %under the null, ts ~ N(0,1) pval = 1 - abs(erf(ts / sqrt(2))); %2-sided test.
pvals = nan(10000,1); for j=1:numel(pvals); pvals(j) = spiegel_test(randn(300,1)); end nnz(pvals < 0.05) ./ numel(pvals)
>> A = rand(1000); % >> save( >> whos -file savetest.mat % Name Size Bytes Class Attributes A 1000x1000 8000000 double
>> A = []; % >> save( >> whos -file savetest.mat % Name Size Bytes Class Attributes A 0x0 0 double
function replace_vars_in_matfile x = 1; % Random dummy data; zeros would compress really well and throw off results y = randi(intmax( tic; save test.mat x y; toc; x = 2; tic; save -append test.mat x; toc; y = y + 1; tic; save -append test.mat y; toc;
Read (MB) Write (MB) Time (sec) before any write: 25 0 first write: 25 105 3.7 append x: 235 315 3.6 append y: 235 420 3.8
function dsave(file, varargin) %DSAVE Like save, but each var in its own file % % dsave filename var1 var2 var3... if nargin < 1 || isempty(file); file = [tfStruct,loc] = ismember({ args = varargin; args(loc(tfStruct)) = []; if ~all(cellfun(@isvarname, args)) error( end if tfStruct structVarName = args{1}; s = evalin( else varNames = args; if isempty(args) w = evalin( varNames = { w.name }; end captureExpr = [ join( s = evalin( end % Use Java checks to avoid partial path ambiguity jFile = java.io.File(file); if ~jFile.exists() ok = mkdir(file); if ~ok; error( end elseif ~jFile.isDirectory() error( end names = fieldnames(s); for i = 1:numel(names) varFile = fullfile(file, [names{i} varStruct = struct(names{i}, {s.(names{i})}); save(varFile, end function out = join(Glue, Strings) Strings = cellstr(Strings); if length( Strings ) == 0 out = elseif length( Strings ) == 1 out = Strings{1}; else Glue = sprintf( Glue ); % Support escape sequences out = strcat( Strings(1:end-1), { Glue } ); out = [ out{:} Strings{end} ]; end
function out = dload(file,varargin) %DLOAD Like load, but each var in its own file if nargin < 1 || isempty(file); file = varNames = varargin; if ~exist(file, error( end if isempty(varNames) d = dir(file); varNames = regexprep(setdiff(ls(file), { end out = struct; for i = 1:numel(varNames) name = varNames{i}; tmp = load(fullfile(file, [name out.(name) = tmp.(name); end if nargout == 0 for i = 1:numel(varNames) assignin( end clear out end
function out = dwhos(file) %DWHOS List variable names in a dsave dir if nargin < 1 || isempty(file); file = out = regexprep(setdiff(ls(file), {
function ddelete(file,varargin) %DDELETE Delete variables from a dsave dir if nargin < 1 || isempty(file); file = varNames = varargin; for i = 1:numel(varNames) delete(fullfile(file, [varNames{i} end
S = load(filename, save(newFilename, % delete(filename)
% plot([0 5 0 5], [0 10 10 0]), axis tight set(gca, % set(gcf, % % % set(gcf, % print -dtiff -r0 out.tiff
function varargout = deal_array(arr) s = numel(arr); n = nargout; if n > s error( elseif n == 0 return; end for i = 1:n varargout(i) = {arr(i)}; % end end
funList = {@fun1,@fun2,@fun3}; dataList = {data1,data2,data3}; % matlabpool open parfor i=1:length(funList) % funList{i}(dataList{i}); end
temp0 = theta(1,1) - (alpha/m)*sum((X*theta-y).*X(:,1)); temp1 = theta(2,1) - (alpha/m)*sum((X*theta-y).*X(:,2)); theta(1,1) = temp0; theta(2,1) = temp1;
Error = X * theta - y; for i = 1:2 S(i) = sum(Error.*X(:,i)); end theta = theta - alpha * (1/m) * S'
% @double/display.m function display(v) % DISPLAY Display a variable, limiting the number of elements shown. name = inputname(1); if isempty(name) name = end maxElementsShown = 500; newlines = repmat( if numel(v)>maxElementsShown, warning( % OR show the first N=maxElementsShown elements % builtin( elseif numel(v)>0, fprintf([newlines builtin( end end
>> xx=1:10 xx = 1 2 3 4 5 6 7 8 9 10 >> xx=1:1e4 Warning: Data not displayed because of length. > In double.display at 17
probabilities = cellfun(@(u,v)ttest2(u,v)%take only second output%,cellArray1,cellArray2)
>> data = [1 3 2 5 4]; % >> fcn = @(x) max(x); % >> [maxValue,maxIndex] = fcn(data) % maxValue = 5 % maxIndex = 4 %
[junk,probabilities] = cellfun(@ttest2,cellArray1,cellArray2);
function varargout = getOutput(func,outputNo,varargin) varargout = cell(max(outputNo),1); [varargout{:}] = func(varargin{:}); varargout = varargout(outputNo); end
probabilities = cellfun(@(u,v)getOutput(@ttest2,2,u,v)...
for p = 1:length(array) if array(p) == 1 % % % end; end;
for p = 1:length(array) if array(p) ~= 1 % continue; % end; % % end;
function tests() V = ver; sz = round(linspace(100, 10000,100)); hfig = figure( % feature( runtests(sz, 1, [ % feature( runtests(sz, 2, [ % ax = findall(hfig, ylims = get(ax, ylims = cat(1, ylims{:}); set(ax, end function out = runtests(sz, n, label) times1 = zeros(numel(sz), 1); times2 = zeros(numel(sz), 1); for k = 1:numel(sz) p = mod(randperm(sz(k)),2); times1(k) = timeit(@()continueit(p)); p = mod(randperm(sz(k)),2); times2(k) = timeit(@()ifit(p)); end subplot(1,2,n) plots(sz, cat(2, times1, times2)) title(label) end function plots(sz, times) plot(sz, times * 1000) legend({ xlabel( ylabel( end function continueit(p) c = 1; for k = 1:numel(p) if p(k) ~= 1 continue; end c = c * k; end end function ifit(p) c = 1; for k = 1:numel(p) if p(k) == 1 c = c * k; end end end
classdef stree < handle % A class for a tree object that acts like a reference % parameter. % The tree can be traversed in both directions by using the parent % and children information. % New nodes can be added to the tree. The object will automatically % keep track of the number of nodes in the tree and increment the % storage space as necessary. properties (SetAccess = private) % Hold the data at each node Node = { [] }; % Index of the parent node. The root of the tree as a parent index % equal to 0. Parent = 0; num_nodes = 0; size_increment = 1; maxSize = 1; end methods function [obj, root_ID] = stree(data, init_siz) % New object with only root content, with specified initial % size obj.Node = repmat({ data },init_siz,1); obj.Parent = zeros(init_siz,1); root_ID = 1; obj.num_nodes = 1; obj.size_increment = init_siz; obj.maxSize = numel(obj.Parent); end function ID = addnode(obj, parent, data) % Add child node to specified parent if obj.num_nodes < obj.maxSize % still have room for data idx = obj.num_nodes + 1; obj.Node{idx} = data; obj.Parent(idx) = parent; obj.num_nodes = idx; else % all preallocated elements are in use, reserve more memory obj.Node = [ obj.Node repmat({data},obj.size_increment,1) ]; obj.Parent = [ obj.Parent parent zeros(obj.size_increment-1,1)]; obj.num_nodes = obj.num_nodes + 1; obj.maxSize = numel(obj.Parent); end ID = obj.num_nodes; end function content = get(obj, ID) %% GET Return the contents of the given node IDs. content = [obj.Node{ID}]; end function obj = set(obj, ID, content) %% SET Set the content of given node ID and return the modifed tree. obj.Node{ID} = content; end function IDs = getchildren(obj, ID) % GETCHILDREN Return the list of ID of the children of the given node ID. % The list is returned as a line vector. IDs = find( obj.Parent(1:obj.num_nodes) == ID ); IDs = IDs end function n = nnodes(obj) % NNODES Return the number of nodes in the tree. % Equal to root + those whose parent is not root. n = 1 + sum(obj.Parent(1:obj.num_nodes) ~= 0); assert( obj.num_nodes == n); end function flag = isleaf(obj, ID) % ISLEAF Return true if given ID matches a leaf node. % A leaf node is a node that has no children. flag = ~any( obj.Parent(1:obj.num_nodes) == ID ); end function depth = depth(obj,ID) % DEPTH return depth of tree under ID. If ID is not given, use % root. if nargin == 1 ID = 0; end if obj.isleaf(ID) depth = 0; else children = obj.getchildren(ID); NC = numel(children); d = 0; % Depth from here on out for k = 1:NC d = max(d, obj.depth(children(k))); end depth = 1 + d; end end end end
function T = benchmark(Nd, Ns) % Tree benchmark. Nd: tree depth, Ns: number of nodes per layer % Initialize tree T = stree(rand, 10000); add_layers(1, Nd); function add_layers(node_id, num_layers) if num_layers == 0 return; end child_id = zeros(Ns,1); for s = 1:Ns % add child to current node child_id(s) = T.addnode(node_id, rand); % recursively increase depth under child_id(s) add_layers(child_id(s), num_layers-1); end end end
obj.Node = [obj.Node; data; cell(obj.size_increment - 1,1)];
table = cell(n,1) % n bigger then expected value end_pointer = 1 % simple pointer to the first free value function insert(data,parent_ID) if end_pointer < numel(table) content.data = data; content.parent = parent_ID; table{end_pointer} = content; end_pointer = end_pointer + 1; else % need more space, make sure its enough this time table = [table cell(end_pointer,1)]; insert(data,parent_ID); end end function content = get_value(ID) content = table(ID); end
classdef node < handle % A node for a tree in a MCTS properties state = {}; %some state of the search space that identifies the node score = 0; childs = cell(50,1); num_childs = 0; end methods function obj = node(state) % for a new node simulate a score using MC obj.score = simulate_from(state); % TODO implement simulation state -> finish obj.state = state; end function value = update(obj) % update the this node using MC recursively if obj.num_childs == numel(obj.childs) % there are to many childs, we have to expand the table obj.childs = [obj.childs cell(obj.num_childs,1)]; end if obj.do_exploration() || obj.num_childs == 0 % explore a potential state state_to_explore = obj.explore(); %check if state has already been visited terminate = false; idx = 1; while idx <= obj.num_childs && ~terminate if obj.childs{idx}.state_equals(state_to_explore) terminate = true; end idx = idx + 1; end %preform the according action based on search if idx > obj.num_childs % state has never been visited % this action terminates the update recursion % and creates a new leaf obj.num_childs = obj.num_childs + 1; obj.childs{obj.num_childs} = node(state_to_explore); value = obj.childs{obj.num_childs}.calculate_value(); obj.update_score(value); else % state has been visited at least once value = obj.childs{idx}.update(); obj.update_score(value); end else % exploit what we know already best_idx = 1; for idx = 1:obj.num_childs if obj.childs{idx}.score > obj.childs{best_idx}.score best_idx = idx; end end value = obj.childs{best_idx}.update(); obj.update_score(value); end value = obj.calculate_value(); end function state = explore(obj) %select a next state to explore, that may or may not be visited %TODO end function bool = do_exploration(obj) % decide if this node should be explored or exploited %TODO end function bool = state_equals(obj, test_state) % returns true if the nodes state is equal to test_state %TODO end function update_score(obj, value) % updates the score based on some value %TODO end function calculate_value(obj) % returns the value of this node to update previous nodes %TODO end end end
obj.Node = [obj.Node; data; cell(q * obj.num_nodes,1)];
import javax.swing.tree.DefaultMutableTreeNode % Let top = DefaultMutableTreeNode([11,21]) n1 = DefaultMutableTreeNode([7,10]) top.add(n1) n2 = DefaultMutableTreeNode([2,4]) n1.add(n2) n2 = DefaultMutableTreeNode([5,6]) n1.add(n2) n3 = DefaultMutableTreeNode([2,3]) n2.add(n3) n3 = DefaultMutableTreeNode([3,3]) n2.add(n3) n1 = DefaultMutableTreeNode([4,8]) top.add(n1) n2 = DefaultMutableTreeNode([1,2]) n1.add(n2) n2 = DefaultMutableTreeNode([2,3]) n1.add(n2) n2 = DefaultMutableTreeNode([2,3]) n1.add(n2) n1 = DefaultMutableTreeNode([0,3]) top.add(n1) % Element to look for, your implementation will be recursive searching = [0 1 1]; idx = 1; node(idx) = top; for item = searching, % Java transposes the matrices, remember to transpose back when you are reading node(idx).getUserObject()' node(idx+1) = node(idx).getChildAt(item); idx = idx + 1; end node(idx).getUserObject()' % We made a new test... newdata = [0, 1] newnode = DefaultMutableTreeNode(newdata) % ...so we expand our tree at the last node we searched node(idx).add(newnode) % The change has to be propagated (this is where your recursion returns) for it=length(node):-1:1, itnode=node(it); val = itnode.getUserObject()' newitemdata = val + newdata itnode.setUserObject(newitemdata) end % Let searching = [0 1 1 0]; idx = 1; node(idx) = top; for item = searching, node(idx).getUserObject()' node(idx+1) = node(idx).getChildAt(item); idx = idx + 1; end node(idx).getUserObject()'
FV = mexLongProcessInAnotherThread(); try while ~mexIsDone(FV); java.lang.Thread.sleep(100); %pause has a memory leak drawnow; %allow stdout/err from mex to display in command window end catch mexCancel(FV); end
if (toc > timeRequiredToBreakOff) % time conditional break off return; % other options may be: % 1. display intermediate values with pause; % 2. exit; % in some cases, extreme : kill/ quit matlab end
Formula: dxt = asin( sin(δ13) ⋅ sin(θ13−θ12) ) ⋅ R where: δ13 is (angular) distance from start point to third point θ13 is (initial) bearing from start point to third point θ12 is (initial) bearing from start point to end point R is the earth’s radius
function [ dxa ] = crossarc( lat1,lon1,lat2,lon2,lat3,lon3 ) % % % lat1=deg2rad(lat1); lat2=deg2rad(lat2); lat3=deg2rad(lat3); lon1=deg2rad(lon1); lon2=deg2rad(lon2); lon3=deg2rad(lon3); R=6371000; % % bear12 = bear(lat1,lon1,lat2,lon2); bear13 = bear(lat1,lon1,lat3,lon3); dis13 = dis(lat1,lon1,lat3,lon3); % if abs(bear13-bear12)>(pi/2) dxa=dis13; else % dxt = asin( sin(dis13/R)* sin(bear13 - bear12) ) * R; % dis12 = dis(lat1,lon1,lat2,lon2); dis14 = acos( cos(dis13/R) / cos(dxt/R) ) * R; if dis14>dis12 dxa=dis(lat2,lon2,lat3,lon3); else dxa=abs(dxt); end end end function [ d ] = dis( latA, lonA, latB, lonB ) %DIS Finds the distance between two lat/lon points. R=6371000; d = acos( sin(latA)*sin(latB) + cos(latA)*cos(latB)*cos(lonB-lonA) ) * R; end function [ b ] = bear( latA,lonA,latB,lonB ) %BEAR Finds the bearing from one lat/lon point to another. b=atan2( sin(lonB-lonA)*cos(latB) , ... cos(latA)*sin(latB) - sin(latA)*cos(latB)*cos(lonB-lonA) ); end
>> crossarc(-10.1,-55.5,-15.2,-45.1,-10.5,-62.5) ans = 7.6709e+05 >> crossarc(40.5,60.5,50.5,80.5,51,69) ans = 4.7961e+05 >> crossarc(21.72,35.61,23.65,40.7,25,42) ans = 1.9971e+05
/** * Calculates the euclidean distance from a point to a line segment. * * @param v the point * @param a start of line segment * @param b end of line segment * @return an array of 2 doubles: * [0] distance from v to the closest point of line segment [a,b], * [1] segment coeficient of the closest point of the segment. * Coeficient values < 0 mean the closest point is a. * Coeficient values > 1 mean the closest point is b. * Coeficient values between 0 and 1 mean how far along the segment the closest point is. * * @author Afonso Santos */ public static double[] distanceToSegment( final R3 v, final R3 a, final R3 b ) { double[] results = new double[2] ; final R3 ab_ = b.sub( a ) ; final double ab = ab_.modulus( ) ; final R3 av_ = v.sub( a ) ; final double av = av_.modulus( ) ; if (ab == 0.0) { results[0] = av ; results[1] = 0.0 ; } else { final double avScaProjAb = av_.dot(ab_) / ab ; final double abCoeficient = results[1] = avScaProjAb / ab ; if (abCoeficient <= 0.0) results[0] = av ; else if (abCoeficient >= 1.0) results[0] = v.sub( b ).modulus() ; else { if (avScaProjAb >= av) results[0] = 0.0 ; else results[0] = Math.sqrt( av * av - avScaProjAb * avScaProjAb ) ; } } return results ; }
/** * Calculate 3D vector (from center of earth). * * @param latDeg latitude (degrees) * @param lonDeg longitude (degrees) * @param eleMtr elevation (meters) * @return 3D cartesian vector (from center of earth). * * @author Afonso Santos */ public static R3 cartesian( final double latDeg, final double lonDeg, final double eleMtr ) { return versor( latDeg, lonDeg ).scalar( EARTHMEANRADIUS_MTR + eleMtr ) ; }
a=rand(2^12); tic for j=1:1e5 a ; end toc tic for j=1:1e5 a(:) ; end toc tic for j=1:1e5 a() ; end toc
Elapsed time is 0.047250 seconds. Elapsed time is 0.022260 seconds. Elapsed time is 0.011925 seconds.
%% Transform perspective img = imread( R = R_z(yaw_angle)*R_y(pitch_angle)*R_x(roll_angle); tform = projective2d(R); outputImage = imwarp(img,tform); figure(1), imshow(outputImage);
%% Transform perspective function [] = main() img = imread( R = R_z(0)*R_y(0)*R_x(10); tform = projective2d(R); outputImage = imwarp(img,tform); figure(1), imshow(outputImage); end %% Matrix for Yaw-rotation about the Z-axis function [R] = R_z(psi) R = [cosd(psi) -sind(psi) 0; sind(psi) cosd(psi) 0; 0 0 1]; end %% Matrix for Pitch-rotation about the Y-axis function [R] = R_y(theta) R = [cosd(theta) 0 sind(theta); 0 1 0 ; -sind(theta) 0 cosd(theta) ]; end %% Matrix for Roll-rotation about the X-axis function [R] = R_x(phi) R = [1 0 0; 0 cosd(phi) -sind(phi); 0 sind(phi) cosd(phi)]; end
Roll: -10 Pitch: -30 Yaw: 166 (angular deviation from north)
R_rotation = R_y(-60)*R_x(10); R_2d = [ R_rot(1,1) R_rot(1,2) 0; R_rot(2,1) R_rot(2,2) 0; 0 0 1 ]
R_rotation = R_y(-60)*R_x(10)*R_z(some_heading); R_2d = [ R_rot(1,1) R_rot(1,2) 0; R_rot(2,1) R_rot(2,2) 0; 0 0 1 ]
% Load image img = imread( % Full rotation matrix. Z-axis included, but not used. R_rot = R_y(-60)*R_x(10)*R_z(0); % Strip the values related to the Z-axis from R_rot R_2d = [ R_rot(1,1) R_rot(1,2) 0; R_rot(2,1) R_rot(2,2) 0; 0 0 1 ]; % Generate transformation matrix, and warp (matlab syntax) tform = affine2d(R_2d); outputImage = imwarp(img,tform); % Display image figure(1), imshow(outputImage); %*** Rotation Matrix Functions ***% %% Matrix for Yaw-rotation about the Z-axis function [R] = R_z(psi) R = [cosd(psi) -sind(psi) 0; sind(psi) cosd(psi) 0; 0 0 1]; end %% Matrix for Pitch-rotation about the Y-axis function [R] = R_y(theta) R = [cosd(theta) 0 sind(theta); 0 1 0 ; -sind(theta) 0 cosd(theta) ]; end %% Matrix for Roll-rotation about the X-axis function [R] = R_x(phi) R = [1 0 0; 0 cosd(phi) -sind(phi); 0 sind(phi) cosd(phi)]; end
close all file= I=imread(file); R_rot = R_x(-10)*R_y(-30)*R_z(166); R_rot = inv(R_rot); R_2d = [ R_rot(1,1) R_rot(1,2) 0; R_rot(2,1) R_rot(2,2) 0; 0 0 1 ]; T = maketform( transformedI = imtransform(I,T); figure, imshow(I), figure, imshow(transformedI)
clear all; im = im2double(imread( im = double(im); [nr,nc]=size(im); [dx,dy] = gradient(im); [x y] = meshgrid(1:nc,1:nr); u = x; v = y; quiver(x,y,u,v)
clear all; im = imread( [nr,nc]=size(im); [dx,dy] = gradient(double(im)); [x y] = meshgrid(1:nc,1:nr); u = dx; v = dy; imshow(im); hold on quiver(x,y,u,v)
%function test clear rng( a=sprand(3000,3000,0.1); b=rand(3000,3000); a=gpuArray(a); b=gpuArray(b); tic; c1=gather(transpose(transpose(a)*transpose(a*b))); disp([ clearvars -except c1 rng( rng(1) a=sprand(3000,3000,0.1); b=rand(3000,3000); a=gpuArray(a); b=gpuArray(b); tic; c2=gather(a*b*a); disp([ disp([ %end
>> test time for (a time for a*b*a: 1.7175s error = 2.0009e-11
>> test time for (a time for a*b*a: 1.7153s error = 1.0914e-11
str={ for ii=1:2 rng(1); a=sprand(3000,3000,0.1); b=sprand(3000,3000,0.1); if ii==2 b=full(b); end a=gpuArray(a); b=gpuArray(b); tic c=a*b; disp([ end
str={ for ii=1:2 %rng( rng(1) a=sprand(3000,3000,0.1); b=rand(3000,3000); rng(1) c=sprand(3000,3000,0.1); if ii==2 c=full(c); end a=gpuArray(a); b=gpuArray(b); c=gpuArray(c); tic; c1{ii}=a*b*c; disp([ end disp([
n = 2000; a=gpuArray(sprand(n,n,0.01)); b=gpuArray(rand(n)); tic;res1=a*b*a;wait(gpuDevice);toc % Elapsed time is 0.884099 seconds. tic;res2=transpose(transpose(a)*transpose(a*b));wait(gpuDevice);toc % Elapsed time is 0.068855 seconds.
tic;i1=transpose(a);i2=transpose(a*b);res3=transpose(i1*i2);wait(gpuDevice);toc % Elapsed time is 0.066446 seconds.
b=gpuArray(rand(n)); tic; res1=a*b*a; wait(gpuDevice); toc
b=gpuArray(rand(n)); wait(gpuDevice); tic; res1=a*b*a; wait(gpuDevice); toc
%testscript2.m n = 2000; a = gpuArray(sprand(n, n, 0.01)); b = gpuArray(rand(n)); gputimeit(@()transpose_mult_fun(a, b)) gputimeit(@()transpose_mult_fun_2(a, b)) function out = transpose_mult_fun(in1, in2) i1 = transpose(in1); i2 = transpose(in1*in2); out = transpose(i1*i2); end function out = transpose_mult_fun_2(in1, in2) out = transpose(transpose(in1)*transpose(in1*in2)); end
function test_v2 clear %% transposed expression n = 2000; rng( a = sprand(n, n, 0.1); b = rand(n, n); a = gpuArray(a); b = gpuArray(b); tic; c1 = gather(transpose( transpose(a) * transpose(a * b) )); disp([ clearvars -except c1 %% non-transposed expression rng( rng(1) n = 2000; a = sprand(n, n, 0.1); b = rand(n, n); a = gpuArray(a); b = gpuArray(b); tic; c2 = gather(a * b * a); disp([ disp([ %% sliced equivalent rng( rng(1) n = 2000; a = sprand(n, n, 0.1); b = rand(n, n); a = gpuArray(a); b = gpuArray(b); tic; intermediate1 = transpose(a); intermediate2 = transpose(a * b); c3 = gather(transpose( intermediate1 * intermediate2 )); disp([ disp([ end
x = rand(10,1); % y = rand(10,1); % dt = DelaunayTri(x,y); % edgeIndex = edges(dt); % midpts = [mean(x(edgeIndex),2) ... % mean(y(edgeIndex),2)]; nearIndex = nearestNeighbor(dt,midpts); % keepIndex = (nearIndex == edgeIndex(:,1)) | ... % (nearIndex == edgeIndex(:,2)); % % % edgeIndex = edgeIndex(keepIndex,:); %
triplot(dt, hold on; % plot(x(edgeIndex). voronoi(dt, plot(midpts(:,1),midpts(:,2),
data(1, :) = [1, -1, -1, -1, -1, -1, -1, -1, 1, -1];
shuffle = randperm(size(data)); data_shuffled = data(shuffle, :); base = data_shuffled(1:30000, :); pool = data_shuffled(30001:end, :); best_mean = mean(abs(sum(base, 1))); best_matrix = base; n = 100000; for k = 1:20 for i = 1:size(pool, 1) temp = pool (i, :); if(~isnan(temp(1))) temp_sum = sum(temp, 1); new_sum = temp_sum + sum(best, 1); temp_mean = mean(abs(new_sum)); if(temp_mean < best_mean) best_mean = temp_mean; best_matrix = vertcat(best_matrix, temp); pool(i, :) = NaN(1, 10); end end end if(size(best_matrix, 1) > n) return end end
function accum=mat2accum(data) [~,n]=size(data); indexes=bin2dec(num2str((data+1)/2))+1; accum=accumarray(indexes,1,[2^n 1]);
data(1,:)=[-1 1 -1 1 -1 1 -1 1 -1 1] -> data(2,:)=[1 -1 1 -1 1 -1 1 -1 1 -1] ->
function [accumpairs, accumleft]=getpairs(accum) accumpairs=min([accum,accum(end:-1:1)],[],2); accumleft=accum-accumpairs;
function [accumlast,accumleft]=resto(accum,m) [N,~]=size(accum); columns=log2(N); indexes=randperm(N) [~,I]=sort(sum((double(dec2bin(indexes-1,columns))-48),2)); accumlast=zeros(N,1); for k=indexes(I) accumlast(k)=accum(k); if sum(accumlast)>=m break end end accumleft=accum-accumlast;
function [accumout,accumleft]=getseparated(accum, bigcol, smallcol, m) data=accum2mat(accum); bigindex=bin2dec(num2str((data(:,bigcol)+1)/2))+1; [~,bn]=size(bigcol); [~,sn]=size(smallcol); b_ind=randperm(2^bn) [~,I]=sort(sum((double(dec2bin(b_ind-1,bn))-48),2)); temp=zeros(2^bn,4+sn); w=waitbar(0, for k=1:2^bn; small_data=data(bigindex==b_ind(I(k)),smallcol); if small_data small_accum=mat2accum(small_data); [small_accumpairs, small_accum]=getpairs(small_accum); n_pairs=sum(small_accumpairs); n_non_pairs=sum(small_accum); sum_non_pairs=sum(accum2mat(small_accum)); else n_pairs=0; n_non_pairs=0; sum_non_pairs=zeros(1,sn); end ham_weight=sum((double(dec2bin(b_ind(I(k))-1,bn))-48),2); temp(k,:)=[b_ind(I(k)) n_pairs n_non_pairs ham_weight sum_non_pairs]; waitbar(k/2^bn); end close(w) pair_ind=1; nonpair_ind=1; runningsum=[0 0 0 0 0 0 0 0 0 0]; temp2=zeros(2^bn,2); while sum(sum(temp2))<=m if pair_ind<=2^bn pairsum=[(((double(dec2bin((temp(pair_ind,1)-1),bn))-48)*2)-1)*temp(pair_ind,2) zeros(1,sn)]; end if nonpair_ind<=2^bn nonpairsum=[(((double(dec2bin((temp(nonpair_ind,1)-1),bn))-48)*2)-1)*temp(nonpair_ind,3) temp(nonpair_ind,5:5+sn-1)]; end if nonpair_ind==(2^bn)+1 temp2(pair_ind,1)=temp(pair_ind,2); runningsum=runningsum+pairsum; pair_ind=pair_ind+1; elseif pair_ind==(2^bn)+1 temp2(nonpair_ind,2)=temp(nonpair_ind,3); runningsum=runningsum+nonpairsum; nonpair_ind=nonpair_ind+1; elseif sum(abs(runningsum+pairsum))<=sum(abs(runningsum+nonpairsum)) temp2(pair_ind,1)=temp(pair_ind,2); runningsum=runningsum+pairsum; pair_ind=pair_ind+1; elseif sum(abs(runningsum+pairsum))>sum(abs(runningsum+nonpairsum)) temp2(nonpair_ind,2)=temp(nonpair_ind,3); runningsum=runningsum+nonpairsum; nonpair_ind=nonpair_ind+1; end end accumout=zeros(2^(bn+sn),1); for k=1:2^bn if temp2(k,:) small_data=data(bigindex==temp(k,1),smallcol); if small_data small_accum=mat2accum(small_data); [small_accumpairs, small_accum]=getpairs(small_accum); pairs=accum2mat(small_accumpairs); non_pairs=accum2mat(small_accum); else pairs=zeros(1,sn); non_pairs=zeros(1,sn); end if temp2(k,1) datatemp=zeros(temp2(k,1),sn+bn); datatemp(:,bigcol)=((double(dec2bin(ones(temp2(k,1),1)*(temp(k,1)-1),bn))-48)*2)-1; datatemp(:,smallcol)=pairs; accumout=accumout+mat2accum(datatemp); end if temp2(k,2) datatemp=zeros(temp2(k,2),sn+bn); datatemp(:,bigcol)=((double(dec2bin(ones(temp2(k,2),1)*(temp(k,1)-1),bn))-48)*2)-1; datatemp(:,smallcol)=non_pairs; accumout=accumout+mat2accum(datatemp); end end end accumleft=accum-accumout;
% Generate data set as vector of length order with elements in set {1,-1}. tic(); rows = 250000; order = 10; rowFraction = 0.1; maxRowsToRemove = rows * rowFraction; data = rand( rows, order); data( data >= 0.5) = 1; data( data < 0.5) = -1; % Convert data to an index to one of 2^order vectors of 1 or -1. % We set the -1 values to 0 and get the binary representation of the % vector of binary values. a = data; a( a==-1)=0; ndx = zeros(1,length(a)); ndx(:) = a(:,1)*2^9+a(:,2)*2^8+a(:,3)*2^7+a(:,4)*2^6+a(:,5)*2^5+... a(:,6)*2^4+a(:,7)*2^3+a(:,8)*2^2+a(:,9)*2+a(:,10) + 1; % Determine how many of each index we have in data pool. bins = zeros( 1, 2^order); binsRemoved = zeros( 1, 2^order); for ii = 1:length( ndx) bins( ndx(ii)) = bins( ndx(ii)) + 1; end colSum = sum(data,1); sumOfColSum = sum(abs(colSum)); absSum = sumOfColSum; lut = genLutForNdx( order); nRemoved = 0; curSum = colSum; for ii = 1:maxRowsToRemove if ( absSum == 0) disp( sprintf( break; end ndxR = findNdxToRemove( curSum, bins, lut); if ndxR > 0 bins( ndxR) = bins( ndxR) - 1; binsRemoved( ndxR) = binsRemoved( ndxR) + 1; curSum = curSum - lut( ndxR, :); nRemoved = nRemoved + 1; absSum = sum( abs( curSum)); else disp( sprintf( break; end end stat1 = sprintf( ... sumOfColSum, absSum, nRemoved); stat2 = sprintf( ... disp( stat1); disp( stat2); % Show list of indicies removed along with the number of each removed. binRndx = find( binsRemoved != 0); ndxRemovedHist = [binRndx disp( sprintf( for ii = 1: length( ndxRemovedHist) disp( sprintf( end % Generate the modified data array from the list of removed elements. modData = data; lr = []; for ii = 1: length( ndxRemovedHist) sr = find( ndx==ndxRemovedHist(ii,1)); lr = [lr, sr(1:ndxRemovedHist(ii,2))]; end modData( lr, :) = []; disp( sprintf( % **************************************************** % Generate data set as vector of length order with elements in set {1,-1}. tic(); rows = 250000; order = 10; rowFraction = 0.1; maxRowsToRemove = rows * rowFraction; data = rand( rows, order); data( data >= 0.5) = 1; data( data < 0.5) = -1; % Convert data to an index to one of 2^order vectors of 1 or -1. % We set the -1 values to 0 and get the binary representation of the % vector of binary values. a = data; a( a==-1)=0; ndx = zeros(1,length(a)); ndx(:) = a(:,1)*2^9+a(:,2)*2^8+a(:,3)*2^7+a(:,4)*2^6+a(:,5)*2^5+... a(:,6)*2^4+a(:,7)*2^3+a(:,8)*2^2+a(:,9)*2+a(:,10) + 1; % Determine how many of each index we have in data pool. bins = zeros( 1, 2^order); binsRemoved = zeros( 1, 2^order); for ii = 1:length( ndx) bins( ndx(ii)) = bins( ndx(ii)) + 1; end colSum = sum(data,1); sumOfColSum = sum(abs(colSum)); absSum = sumOfColSum; lut = genLutForNdx( order); nRemoved = 0; curSum = colSum; for ii = 1:maxRowsToRemove if ( absSum == 0) disp( sprintf( break; end ndxR = findNdxToRemove( curSum, bins, lut); if ndxR > 0 bins( ndxR) = bins( ndxR) - 1; binsRemoved( ndxR) = binsRemoved( ndxR) + 1; curSum = curSum - lut( ndxR, :); nRemoved = nRemoved + 1; absSum = sum( abs( curSum)); else disp( sprintf( break; end end stat1 = sprintf( ... sumOfColSum, absSum, nRemoved); stat2 = sprintf( ... disp( stat1); disp( stat2); % Show list of indicies removed along with the number of each removed. binRndx = find( binsRemoved != 0); ndxRemovedHist = [binRndx disp( sprintf( for ii = 1: length( ndxRemovedHist) disp( sprintf( end % Generate the modified data array from the list of removed elements. modData = data; lr = []; for ii = 1: length( ndxRemovedHist) sr = find( ndx==ndxRemovedHist(ii,1)); lr = [lr, sr(1:ndxRemovedHist(ii,2))]; end modData( lr, :) = []; disp( sprintf( % **************************************************** function ndx = findNdxToRemove( curSum, bins, lut) % See if ideal index to remove exists in current bin set. We look at the % sign of each element of the current sum to determine index to remove aa = zeros( size( curSum)); if (isempty( find( curSum == 0))) aa( curSum < 0) = 0; aa( curSum > 0) = 1; ndx = aa(1)*2^9+aa(2)*2^8+aa(3)*2^7+aa(4)*2^6+aa(5)*2^5+... aa(6)*2^4+aa(7)*2^3+aa(8)*2^2+aa(9)*2+aa(10) + 1; if( bins(ndx) > 0) % Optimal row to remove was found directly. return; end end % Serach through all the non-empty indices that remain for best to remove. delta = 0; ndx = -1; minSum = sum( abs( curSum)); minSumOrig = minSum; bestNdx = -1; firstFound = 1; for ii = 1:length( bins) if ( bins(ii) > 0) tmp = sum( abs( curSum - lut( ii,:))); if ( firstFound) minSum = tmp; bestNdx = ii; firstFound = 0; elseif ( tmp < minSum) minSum = tmp; bestNdx = ii; end end end ndx = bestNdx;
{ "cmd": ["matlab", "-r", "-nodesktop", "-nosplash", "$file_name"], "selector": "source.m", "path": "/usr/local/MATLAB/R2012a/bin" }
/usr/local/MATLAB/R2012a/bin/matlab: 1: /usr/local/MATLAB/R2012a/bin/matlab: awk: not found /usr/local/MATLAB/R2012a/bin/matlab: 1: /usr/local/MATLAB/R2012a/bin/matlab: expr: not found Internal error 2: Could not determine the path of the MATLAB root directory. original command path = /usr/local/MATLAB/R2012a/bin/matlab current command path = /usr/local/MATLAB/R2012a/bin/matlab Please contact: MathWorks Technical Support for further assistance. [Finished in 0.1s with exit code 1]
{ "cmd": ["/usr/local/MATLAB/R2012a/bin/matlab", "-nosplash", "<$file_name"], "selector": "source.m" }
img = doImageConversion(); imshow(img); pause; img = doAnotherImageConversion(); imshow(img); pause;
{ "cmd": ["xterm", "-e", "matlab", "-nosplash", "-nodesktop", "-r", "run $file_name; quit;"], "selector": "source.m" }
{ "cmd": ["/Applications/MATLAB_R2014b.app/bin/matlab","-nosplash", "-nojvm", "-r", "cd $file_dir; try run $file_name; catch varException; display(varException); end; quit;"], "selector": "source.m" }
{ "cmd": ["/Applications/MATLAB_R2014b.app/bin/matlab","-nosplash", "-nojvm", "-r", "cd $file_dir; try run $file_name; catch varException; display(varException.message);display(varException.cause);display(varException.stack(1)); end; quit;"], "selector": "source.m" }
{ "cmd": ["/Applications/MATLAB_R2014b.app/bin/matlab","-nosplash", "-nojvm", "-r", "cd $file_dir; try run $file_name; catch varException; display(varException.message); display(varException.cause);for i = length(varException.stack):-1:1; display(varException.stack(i)); end; end; quit;"], "selector": "source.m" }
num_of_iters = 10; K = 200; for iter = 1:num_of_iters parfor j = 1:K R = make_random_R(iter,j,.....); % Do something end end
function [R] = make_random_R(iter,j,n,K,p,R_type) % Data as code % R_type: % 1 <= iter <= 100 % 1 <= j <= K % K: Number of classifiers % n: Number of observations assert(strcmp(R_type, assert(iter >= 1, assert((1 <= j) && (j <= K), assert(K > 0, globalStream = RandStream.getGlobalStream; globalState = globalStream.State; stream=RandStream( substream_id = (iter - 1) * K + j; stream.Substream = substream_id; RandStream.setGlobalStream(stream); switch R_type case q0=ceil(2*log(n)/0.25^2)+1; if (q0 < p) q = q0; else q = ceil(p/2); end R = randi([0 1],p,q); R(R == 0) = -1; case q = 2*ceil(log2(p)); R = normrnd(0,1,[p,q]); end RandStream.setGlobalStream(globalStream); globalStream.State = globalState; end
>> iter = 2; >> j = 3; >> n=100; >> K=10; >> p=6; >> R_type = >> for j=1:K j make_ran >> parfor j=1:K j make_random_R(iter,j,n,K,p,R_type) end Starting parallel pool (parpool) using the ans = 7 ans = -0.3660 0.8816 1.1754 -0.4987 -1.8612 -0.3683 0.9504 -0.3067 -0.5156 -0.2383 -1.1661 0.3622 2.0743 -0.4195 0.5021 0.3954 0.2415 -0.4552 -0.0474 -0.1645 -0.1725 -0.4938 -0.2559 0.2188 1.0735 0.3660 0.1043 0.4403 -0.3166 1.1241 -1.0421 -1.4528 -0.4976 -0.7166 -1.1328 -2.0260 ans = 2 ans = -1.6629 0.0213 -1.8138 -0.4375 0.3575 -0.0353 0.6653 -1.2662 -0.3977 -0.6540 -1.2131 0.4858 0.3421 1.1266 -0.6066 -1.2095 1.5496 -0.9341 0.2145 0.7192 -2.2087 0.7597 -0.0110 -1.1282 -0.3511 -0.7305 -0.1143 0.0242 0.2431 -0.8612 0.5875 1.2665 -2.1943 -0.4879 0.0120 -1.1539 ans = 1 ans = -0.5300 2.4077 -0.3478 1.8695 -1.1327 -1.0734 -0.2540 -1.1265 0.3152 0.4265 1.2777 0.0959 0.5005 -0.7557 0.6194 1.5873 0.0961 -1.9216 0.7275 0.5420 -0.6237 -0.2228 0.8915 0.4644 0.8131 -0.1492 0.9232 0.8410 -0.0637 2.1163 -1.1995 0.2338 -1.3726 0.1604 -0.1855 1.3826 ans = 8 ans = -0.5146 2.2106 2.7200 -1.2136 1.0004 1.3089 0.7225 0.2746 -0.8798 0.2978 -0.8490 1.6744 1.1998 -0.0363 1.9105 -0.7747 -0.8707 -0.6823 0.6801 1.3194 -0.0685 0.5944 1.5078 -1.6821 0.0876 1.2150 -0.0747 0.0324 -1.1552 0.0966 -0.0624 -0.3874 -0.5356 0.6353 1.4090 -1.1014 ans = 6 ans = 0.5866 -1.0222 -0.2168 0.8582 1.4360 0.0699 2.0677 -0.4740 -0.8763 1.7827 0.1930 -1.2167 -0.3941 -0.5441 0.3719 -0.0609 0.7138 -1.0920 0.3622 -0.0459 -0.0221 0.2030 -0.7695 -0.8963 -0.1986 -0.2560 0.6666 0.4831 -1.2028 -0.9423 0.1656 1.2006 -1.1131 0.7704 -0.6906 -1.3143 ans = 5 ans = -0.5782 -0.3634 1.5381 -1.3173 -0.9493 0.8480 1.5921 -0.4069 0.7795 -0.3390 -0.1071 0.4201 -0.0184 0.2865 -0.1139 -0.1171 0.2288 0.5511 0.1787 0.7583 0.3994 1.0457 0.3291 -0.9150 0.3641 -0.6420 -0.2096 0.7761 0.4022 -0.7478 0.1165 0.7142 0.7029 -1.1195 0.0905 0.6810 ans = 4 ans = 0.1246 -0.3173 0.8068 0.6485 -0.8572 0.2275 0.3674 -0.0507 -0.9196 0.6161 -0.5821 -0.4291 -1.0142 -1.1614 -2.5438 1.5915 2.0356 0.4535 -0.2111 -0.3974 0.0376 0.3825 -1.9702 1.5318 -0.3890 0.9210 -0.0635 0.3248 1.8666 -0.0160 1.3908 -0.7204 -0.6772 -0.0713 0.0569 0.5929 ans = 3 ans = -0.1602 0.6891 0.4725 0.0277 -2.0510 -2.2440 -0.7497 1.8225 -0.4433 0.4090 0.9021 -1.6683 0.0659 0.3909 0.2043 0.9065 1.4630 0.3091 -0.3886 0.6715 -0.9742 -0.5468 0.2890 0.5625 -0.4558 0.4770 -0.1888 -0.6504 0.3281 1.3767 0.3983 0.5834 0.9360 0.8604 -0.9776 0.6755 ans = 10 ans = -0.4843 -0.4512 0.7544 0.7585 -0.4417 -0.0208 1.8537 -1.6935 -2.7067 -0.5077 0.9616 -1.7904 -1.6943 -1.0988 0.1208 -0.8100 1.8778 1.1654 1.1759 -0.7087 -1.2673 -0.1381 -0.0710 0.5343 0.2589 -0.5128 -0.3970 0.6737 0.8097 2.7024 -0.8933 0.2810 0.8117 -0.5428 -0.8782 1.1746 ans = 9 ans = 0.0254 -0.7993 1.5164 1.2921 -1.1013 1.8556 -0.6280 0.9374 -0.1962 0.1685 -0.5079 0.4333 -0.3962 -0.9977 0.6971 -1.0310 -1.1997 -2.1391 0.7179 1.0177 -0.8874 -0.6732 0.7295 1.4448 -1.1793 -1.3210 1.5292 0.2280 1.9337 1.0901 -0.0926 0.1798 -1.1740 0.3447 2.4578 0.4170
rng( rand(1,5) ans= 0.8147 0.9058 0.1270 0.9134 0.6324
rng( rand(1,5) ans= 0.8147 0.9058 0.1270 0.9134 0.6324
s=rng; rand(1,5) ans= 0.0975 0.2785 0.5469 0.9575 0.9649
rng(s); rand(1,5) ans= 0.0975 0.2785 0.5469 0.9575 0.9649
>> parfor i=1:3 rng(3, rand(1,5) i end ans = 0.5508 0.7081 0.2909 0.5108 0.8929 ans = 3 ans = 0.5508 0.7081 0.2909 0.5108 0.8929 ans = 1 ans = 0.5508 0.7081 0.2909 0.5108 0.8929 ans = 2
filter = (fLog > .7*max(fLog(:)) ) | (fLog < .25*max(fLog(:)) ) where fLog is the log(1+abs(Fourier image)) and .7 and .25 are the corresponding interval percentages.
I = imread( % convert to grayscale I = rgb2gray(I); % normalize the image and conver to doubleI I = double(mat2gray(I)); % Resize the image I = imresize(I, [256 256]); % get the size of the image [rows,cols] = size(I); % apply FFT f = fftshift(fft2(I)); % used to plot the image fLog = log(1 + abs(f)); % filter by a range based on fLog filter = (fLog > .7*max(fLog(:)) ) | (fLog < .25*max(fLog(:)) ); B = abs(ifft2(f.*filter)); colormap(gray) subplot(2,2,1),imagesc(I); title( subplot(2,2,2),imagesc(fLog); title( subplot(2,2,3),imagesc(filter); title( subplot(2,2,4),imagesc(B); title( annotation(
I=I-mean(I(:)); f = fftshift(fft2(I)); fabs=abs(f); roi=3;thresh=400; local_extr = ordfilt2(fabs, roi^2, ones(roi)); % find local maximum within 3*3 range result = (fabs == local_extr) & (fabs > thresh); [r, c] = find(result); for i=1:length(r) if (r(i)-128)^2+(c(i)-128)^2>400 % periodic noise locates in the position outside the 20-pixel-radius circle f(r(i)-2:r(i)+2,c(i)-2:c(i)+2)=0; % zero the frequency components end end Inew=ifft2(fftshift(f)); imagesc(real(Inew)),colormap(gray),
I = imread( I = imresize(I, [256 256]); %resize image [m,n] = size(I);%get size of image as m and n [X,Y]=meshgrid(1:256,1:256); % it is a meshgrid for circle mask filter=ones(m,n); % filter initially only ones in it %according to notch filter equation it will find point on image is on imaginary circle.i found circle coordinates. for i=1:m-1 for j=1:n-1 d0 = i-130)^2 + (j-130)^2 <= 32^2 && (i-130)^2 + (j-130)^2 >=20^2; if d0 filter(i,j)=0; else filter(i,j)=1; end end end f = fftshift(fft2(I)); G = abs(ifft2(f.*filter)); figure(1),imshow(G,[]);
% Calculate cumsumed values of runLengths. % We would need this to initialize zeros array and find key positions later on. clens = cumsum(runlens) % Initalize zeros array array = zeros(1,(clens(end))) % Find key positions/indices key_pos = [1 clens(1:end-1)+1] % Find appropriate values app_vals = diff([0 vals]) % Map app_values at key_pos on array array(pos) = app_vals % cumsum array for final output output = cumsum(array)
array(clens(end)) = 0; % instead of array = zeros(1,(clens(end)))
function out = rle_cumsum_diff(vals,runlens) clens = cumsum(runlens); idx(clens(end))=0; idx([1 clens(1:end-1)+1]) = diff([0 vals]); out = cumsum(idx); return;
datasizes = [reshape(linspace(10,70,4). fcns = { for k1 = 1:numel(datasizes) n = datasizes(k1); % Create random inputs vals = randi(200,1,n); runs = [5000 randi(200,1,n-1)]; % 5000 acts as an aberration for k2 = 1:numel(fcns) % Time approaches tsec(k2,k1) = timeit(@() feval(fcns{k2}, vals,runs), 1); end end figure, % Plot runtimes loglog(datasizes,tsec(1,:), loglog(datasizes,tsec(2,:), set(gca, xlabel( legend(upper(strrep(fcns, figure, % Plot speedups semilogx(datasizes,tsec(1,:)./tsec(2,:), set(gca, legend(
function out = rld_cumsum(vals,runlens) index = zeros(1,sum(runlens)); index([1 cumsum(runlens(1:end-1))+1]) = 1; out = vals(cumsum(index)); return;
index = zeros(1,sum(b)); index([1 cumsum(b(1:end-1))+1]) = 1; c = a(cumsum(index));
index = [1 0 1 0 1 1 0 0] cumsum(index) = [1 1 2 2 3 4 4 4] c = [1 1 3 3 2 5 5 5]
>> a=[1,3,2,5] a = 1 3 2 5 >> b=[2,2,1,3] b = 2 2 1 3 >> repelem(a,b) ans = 1 1 3 3 2 5 5 5
??? Error using ==> iptcheckinput Function IMHIST expected its first input, I or X, to be two-dimensional. Error in ==> imhist>parse_inputs at 275 iptcheckinput(a, { Error in ==> imhist at 57 [a, n, isScaled, top, map] = parse_inputs(varargin{:});
hist(reshape(input,[],3),1:max(input(:))); colormap([1 0 0; 0 1 0; 0 0 1]);
%Split into RGB Channels Red = image(:,:,1); Green = image(:,:,2); Blue = image(:,:,3); %Get histValues for each channel [yRed, x] = imhist(Red); [yGreen, x] = imhist(Green); [yBlue, x] = imhist(Blue); %Plot them together in one plot plot(x, yRed,
input = imread ( input=rgb2gray(input); imhist(input); imshow(input);
img1=imread( img1=rgb2gray(img1); subplot(2,2,1); imshow(img1); title( grayImg=mat2gray(img1); subplot(2,2,2); imhist(grayImg); title(
countElA=histc(A,unqA); % relFreq=countElA/numel(A);
[uniqueValues,~,uniqueIndex] = unique(vector); frequency = accumarray(uniqueIndex(:),1)./numel(vector);
vector = [ 2 2 2 2 1 1 1 2 2 1 1 1 2 2 2 2 1 2 ]; tabulate(vector); Value Count Percent 1 7 38.89% 2 11 61.11%
unqV = unique(vector); y = zeros(size(unqV)); for i = 1:length(unqV) y(i) = sum(unqV(i)==vector); end
function idetitle(Title) %IDETITLE Set Window title of the Matlab IDE % % Examples: % idetitle( % idetitle(sprintf( win = appwin(); if ~isempty(win) win.setTitle(Title); end function out = appwin() %APPWIN Get main application window wins = java.awt.Window.getOwnerlessWindows(); for i = 1:numel(wins) if isa(wins(i), out = wins(i); return end end out = [];
myPointMatrix = 0; for x=0:limit for y=0:limit for z=0:limit tempPoint = [x y z]; if (length(myPointMatrix) == 1) myPointMatrix = tempPoint; else myPointMatrix = [myPointMatrix; tempPoint]; end end end end
n = 10000; tic A = []; for i = 1:n Ai = rand(1,3); A = [A;Ai]; end toc Elapsed time is 9.537194 seconds.
tic,rand(n,3);toc Elapsed time is 0.008036 seconds.
A = []; A(end+1,:) = rand(1,3); A A = 0.91338 0.63236 0.09754
A = zeros(10000,3); B = zeros(3,10000); tic,for i = 1:100,A(end+1,:) = rand(1,3);end,toc Elapsed time is 0.124814 seconds. tic,for i = 1:100,B(:,end+1) = rand(3,1);end,toc Elapsed time is 0.116209 seconds.
tic A = zeros(n,3); for i = 1:n A(i,:) = rand(1,3); end toc Elapsed time is 0.156826 seconds.
tic C = {}; for i = 1:n C{end+1} = rand(1,3); end A = cat(1,C{:}); toc Elapsed time is 3.042742 seconds.
tic Ahandle = growdata2; for i = 1:n Ahandle(rand(1,3)) end % unpack the object into a normal array A = Ahandle(); toc Elapsed time is 1.572798 seconds.
tic growdata for i = 1:n growdata(rand(1,3)) end A = growdata; toc Elapsed time is 2.048584 seconds.
limit = 9; myPointMatrix = nan((limit+1)^3,3); loopVar = 1; for x=0:limit for y=0:limit for z=0:limit myPointMatrix(loopVar,:) = [x y z]; loopVar = loopVar + 1; end end end
myPointMatrix=[]; for x=0:limit for y=0:limit for x=0:limit myPointMatrix(:,end+1)=[x y z]; end end end
myPointMatrix=[]; myPointMatrix(1,:)=kron([1:limit],ones(1,limit^2)); myPointMatrix(2,:)=kron([1:limit^2],ones(1,limit)); myPointMatrix(3,:)=kron(ones(1,limit^2),[1:limit]);
%appending to matlab array "f": lfg=[697 770 852 941]; hfg=[1209 1336 1477]; f=[]; for i=1:4, for j=1:3, %f = [ f [lfg(i);hfg(j)] ]; append( f , [lfg(i);hfg(j)] ); end end f
I = imread(...) kernel = ones(3, 3) / 9; % 3x3 mean kernel J = conv2(I, kernel,
I = imread( H = fspecial( I = imfilter(I, H); imshow(I)
f=imread(...); h=fspecial( g= imfilter(f, h); imshow(g);
import cv2 import numpy as np img = cv2.imread( gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) gray = cv2.medianBlur(gray,5) thresh = cv2.adaptiveThreshold(gray,255,1,1,11,2) thresh_color = cv2.cvtColor(thresh,cv2.COLOR_GRAY2BGR) thresh = cv2.dilate(thresh,None,iterations = 3) thresh = cv2.erode(thresh,None,iterations = 2) contours,hierarchy = cv2.findContours(thresh,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE) for cnt in contours: x,y,w,h = cv2.boundingRect(cnt) cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2) cv2.rectangle(thresh_color,(x,y),(x+w,y+h),(0,255,0),2) cv2.imshow( cv2.imshow( cv2.waitKey(0) cv2.destroyAllWindows()
[code that does not change the question snipped] M = M
pw=java.io.PrintWriter(java.io.FileWriter( line=num2str(0:size(data,2)-1); pw.println(line); for index=1:length(data) disp(index); line=num2str(full(data(index,:))); pw.println(line); end pw.flush(); pw.close();
idcs = find(data); vals = data(idcs); ...save the index vector and value vector in whatever format you want...
for i=1:10 [xO, yO, xA, yA, xB, yB, xC, yC] = DoSomething(i); line([xO,xA,xB,xC],[yO,yA,yB,yC]); pause(0.1); end
% "Buffer" size, number of historic lines to keep, and governs the % corresponding fade increments. nFade = 100; % Set up some demo values for plotting around a circle dt = 0.05; a = 0:dt:2*pi+(dt*nFade); n = numel(a); b = a.*4; [x1,y1] = pol2cart( a, ones(1,n) ); [x2,y2] = pol2cart( b, 0.4*ones(1,n) ); x = [zeros(1,n); x1; x1+x2]; y = [zeros(1,n); y1; y1+y2]; % Initialise the figure, set up axes etc f = figure(1); clf; xlim([-1.5,1.5]); ylim([-1.5,1.5]); % Draw all of the lines, initially not showing because NaN vs NaN lines = arrayfun( @(x)line(NaN,NaN), 1:nFade, % Set up shorthand for recolouring all the lines recolour = @(lines) arrayfun( @(x) set( lines{x}, for ii = 1:n % Shift the lines around so newest is at the start lines = [ lines(end), lines(1:end-1) ]; % Overwrite x/y data for oldest line to be newest line set( lines{1}, % Update all colours recolour( lines ); % Pause for animation pause(0.01); end
% Set up some demo values for plotting around a circle a = 0:0.1:2*pi; n = numel(a); [x,y] = pol2cart( a, ones(1,n) ); % Initialise the figure, set up axes etc f = figure(1); clf; xlim([-1,1]); ylim([-1,1]); % Array of graphics objects to store the lines. Could use a cell array. lines = gobjects( 1, n ); % "Buffer" size, number of historic lines to keep, and governs the % corresponding fade increments. nFade = 10; % Main plotting loop for ii = 1:n % Plot the line lines(ii) = line( [0,x(ii)], [0,y(ii)] ); % Loop over past lines. % Note that we only need to go back as far as ii-nFade, earlier lines % will already by transparent with this method! for ip = max(1,ii-nFade):ii % Set the 4th Color attribute value (the alpha) as a percentage % from the current index. Could do this various ways. lines(ip).Color(4) = max( 0, 1 - (ii-ip)/nFade ); end % Delay for animation pause(0.1); end
if lines(ii).Color(4) < 0.01 delete(lines(ii)); end
% init the figure figure(); axes(); hold on; xlim([-1 0.5]); ylim([0 1]); % set fraction of alpha value to take alpha_fraction = 0.7; n_iterations = 200; % looping variable to prevent deleting and calling already deleted lines % i.e. to keep track of which lines are already deleted delete_from = 1; for i=1:n_iterations % your x, y data [x, y] = doSomething(i); % create line with transparency using patchline p(i) = patchline(x,y, % set alpha of line to fraction of previous alpha value % only do when first line is already plotted if i > 1 % loop over all the previous created lines up till this iteration % when it still exists (delete from that index) for j = delete_from:i-1 % Update the alpha to be a fraction of the previous alpha value p(j).EdgeAlpha = p(j).EdgeAlpha*alpha_fraction; % delete barely visible lines if p(j).EdgeAlpha < 0.01 && delete_from > j delete(p(j)); % exclude deleted line from loop, so edgealpha is not % called again delete_from = j; end end end % pause and behold your mechanism pause(0.1); end
I have tried print and saveas commands: saveas(h, print(
% x = 2.^(0:10); y = rand(size(x)); plot(log2(x), y) % set(gca, xt = get(gca, yl = get(gca, str = cellstr( num2str(xt(:), hTxt = text(xt, yl(ones(size(xt))), str, ... %
xticks = 10:25; set(gca, for j = 1:length(xticks) xtl{j} = [ end set(gca,
NaN*(1+i) % This will give NaN + NaNi x = NaN*i % This will give 0 + NaNi
real(x) % This will give 0 imag(x) % This will give NaN
B=imread( B=rgb2gray(B); doubleB=double(B); %read the image and store it as matrix B, convert the image to a grayscale photo and convert the matrix to a class [U,S,V]=svd(doubleB);
B=imread( B=rgb2gray(B); doubleB=im2double(B);% %read the image and store it as matrix B, convert the image to a grayscale %photo and convert the image to a class [U,S,V]=svd(doubleB); C=S; for N=[5,10,25,50,100] C(N+1:end,:)=0; C(:,N+1:end)=0; D=U*C*V %Use singular value decomposition on the image doubleB, create a new matrix %C (for Compression diagonal) and zero out all entries above N, (which in %this case is 100). Then construct a new image, D, by using the new %diagonal matrix C. imshow(D); error=C-D; end
close all clear all clc %reading and converting the image inImage=imread( inImage=rgb2gray(inImage); inImageD=double(inImage); % decomposing the image using singular value decomposition [U,S,V]=svd(inImageD); % Using different number of singular values (diagonal of S) to compress and % reconstruct the image dispEr = []; numSVals = []; for N=5:25:300 % store the singular values in a temporary var C = S; % discard the diagonal values not required for compression C(N+1:end,:)=0; C(:,N+1:end)=0; % Construct an Image using the selected singular values D=U*C*V % display and compute error figure; buffer = sprintf( imshow(uint8(D)); title(buffer); error=sum(sum((inImageD-D).^2)); % store vals for display dispEr = [dispEr; error]; numSVals = [numSVals; N]; end % dislay the error graph figure; title( plot(numSVals, dispEr); grid on xlabel( ylabel(
% open Lena image and convert from uint8 to double Lena = double(imread( % perform SVD on Lena [U,S,V] = svd(Lena); % extract singular values singvals = diag(S); % find out where to truncate the U, S, V matrices indices = find(singvals >= 0.01 * singvals(1)); % reduce SVD matrices U_red = U(:,indices); S_red = S(indices,indices); V_red = V(:,indices); % construct low-rank approximation of Lena Lena_red = U_red * S_red * V_red % print results to command window r = num2str(length(indices)); m = num2str(length(singvals)); disp([ % save reduced Lena imwrite(uint8(Lena_red),
p = rand(10,2); scatter(p(:,1), p(:,2), axis([0 1 0 1]) labels = num2str((1:size(p,1)) text(p(:,1), p(:,2), labels,
% Close all figures including those with hidden handles close all hidden; % Store all the currently set breakpoints in a variable temporaryBreakpointData=dbstatus( % Clear functions and their persistent variables (also clears breakpoints % set in functions) clear functions; % Restore the previously set breakpoints dbstop(temporaryBreakpointData); % Clear global variables clear global; % Clear variables (including the temporary one used to store breakpoints) clear variables;
s=dbstatus( save( % % % clear classes load( dbstop(s); % clear s delete(
setpref( clear all; clear import; clear java; dbstop(getpref(
a = [1:100]; for i=1:100, plot([1:i], a(1:i)); drawnow end
set(fig_handle, set(fig_handle, refreshdata drawnow
set(fig_handle, set(fig_handle, %call this whenever xdata_array and ydata_array are assigned new values to see it updated in the plot refreshdata drawnow
a=[1:100]; figure; h=plot(1,a(1)); for i=2:100 set(h, set(h, refreshdata drawnow end
t = 0:.01:2*pi; x = cos(2*t).*(cos(t).^2); y = sin(2*t).*(sin(t).^2); comet(x,y);
classdef object < handle properties ( GetAccess = id end methods ( Access = function obj = object() obj.id = object.increment(); end end methods ( Static, Access = function result = increment() persistent stamp; if isempty( stamp ) stamp = 0; end stamp = stamp + uint32(1); result = stamp; end end end
classdef StaticVarClass methods (Static = true) function val = staticVar(newval) persistent currentval; if nargin >= 1 currentval = newval; end val = currentval; end end end
>> StaticVarClass.staticVar ans = [] >> StaticVarClass.staticVar( ans = foobar >> StaticVarClass.staticVar ans = foobar >>
classdef StaticVarClass methods (Access = private, Static = true) function val = staticVar(newval) persistent currentval; if nargin >= 1 currentval = newval; end val = currentval; end end methods function this = setStatic(this, newval) StaticVarClass.staticVar(newval); end function v = getStatic(this) v = StaticVarClass.staticVar; end end end
>> x = StaticVarClass x = StaticVarClass with no properties. Methods >> x.getStatic ans = [] >> x.setStatic( ans = StaticVarClass with no properties. Methods >> x.getStatic ans = foobar >>
classdef car<handle properties static_data:STATIC_DATA_HOLDER; end end classdef STATIC_DATA_HOLDER<handle properties data end end
classdef foo properties stuff = some_function() end end
classdef ClassWithStaticMembers properties classvars = StaticVarContainer( othervar end methods function obj=ClassWithStaticMembers(var) obj.othervar = var; end end end classdef StaticVarContainer < dynamicprops methods function obj=StaticVarContainer(varargin) for i=1:2:numel(varargin) obj.addprop(varargin{i}); obj.(varargin{i}) = varargin{i+1}; end end end end
obj1 = ClassWithStaticMembers(3); obj2 = ClassWithStaticMembers(5); obj1.classvars.foo = [2,3]; obj1.othervar obj1.classvars obj2.othervar obj2.classvars
classdef ClassWithCounter properties (Constant) static = StaticVarContainer( end methods function obj=ClassWithCounter() obj.static.counter = obj.static.counter + 1; end end end clear all obj1 = ClassWithCounter(); obj2 = ClassWithCounter(); obj3 = ClassWithCounter(); ClassWithCounter.static.counter
x = 1:20; y = randn(size(x)); plot(x, y, xlabel( h = axes( bar(x,y), title( axis(h,
[status adjustedAngle] = myOtherScript(angle, bias);
for i = 1:numel(biscs{c}) figure(i) imshow(biscs{c}{i}.Image) end
fun = @(i,c){figure(i),imshow(imshow(biscs{c}{i}.Image)}
sa = @(c)arrayfun(@(i){figure(i),imshow(biscs{c}{i}.Image)},... 1:numel(biscs{c}),
ButtonDownFilter ActionPreCallback ActionPostCallback
hax = handle(ax); hprop = findprop(hax, h = handle.listener(hax,hprop, set(ax,
im=rand(2,3,4); %% input image ny=3;nx=3;nz=5; %% desired output dimensions [y x z]=... ndgrid(linspace(1,size(im,1),ny),... linspace(1,size(im,2),nx),... linspace(1,size(im,3),nz)); imOut=interp3(im,x,y,z);
function mat_rs = resize(varargin) %RESIZE Resize a matrix. % DESCRIPTION: % Resize a matrix to a given size using interp2 (2D) or interp3 % (3D). % Use interpolation to redivide the [0,1] interval into Nx, Ny, Nz % voxels, where 0 is the center of first voxel, and 1 is the center % of the last one. % % USAGE: % mat_rs = resize(mat, new_size) % mat_rs = resize(mat, new_size, interp_mode) % % INPUTS: % mat - matrix to resize % new_size - desired matrix size in elements given by [Nx, Ny] in % 2D and [Nx, Ny, Nz] in 3D. Here Nx is the number of % elements in the row direction, Ny is the number of % elements in the column direction, and Nz is the % number of elements in the depth direction. % % OPTIONAL INPUTS: % interp_mode - interpolation mode used by interp2 and interp3 % (default = % % OUTPUTS: % mat_rs - resized matrix % check the inputs for release B.0.2 compatability if length(varargin{2}) == 1 && nargin >= 3 && length(varargin{3}) == 1 % display warning message disp( disp( % recursively call resize with the correct inputs if nargin == 3 mat_rs = resize(varargin{1}, [varargin{2}, varargin{3}]); else mat_rs = resize(varargin{1}, [varargin{2}, varargin{3}], varargin{4}); end return end % update command line status disp( % assign the matrix input mat = varargin{1}; % check for interpolation mode input if nargin == 2 interp_mode = elseif nargin ~= 3 error( else interp_mode = varargin{3}; end % check inputs if numDim(mat) ~= length(varargin{2}) error( end switch numDim(mat) case 2 % extract the original number of pixels from the size of the matrix [Nx_input, Ny_input] = size(mat); % extract the desired number of pixels Nx_output = varargin{2}(1); Ny_output = varargin{2}(2); % update command line status disp([ disp([ % check the size is different to the input size if Nx_input ~= Nx_output || Ny_input ~= Ny_output % resize the input matrix to the desired number of pixels mat_rs = interp2(0:1/(Ny_input - 1):1, (0:1/(Nx_input - 1):1) else mat_rs = mat; end case 3 % extract the original number of pixels from the size of the matrix [Nx_input, Ny_input, Nz_input] = size(mat); % extract the desired number of pixels Nx_output = varargin{2}(1); Ny_output = varargin{2}(2); Nz_output = varargin{2}(3); % update command line status disp([ disp([ % create normalised plaid grids of current discretisation [x_mat, y_mat, z_mat] = ndgrid((0:Nx_input-1)/(Nx_input-1), (0:Ny_input-1)/(Ny_input-1), (0:Nz_input-1)/(Nz_input-1)); % create plaid grids of desired discretisation [x_mat_interp, y_mat_interp, z_mat_interp] = ndgrid((0:Nx_output-1)/(Nx_output-1), (0:Ny_output-1)/(Ny_output-1), (0:Nz_output-1)/(Nz_output-1)); % compute interpolation; for a matrix indexed as [M, N, P], the % axis variables must be given in the order N, M, P mat_rs = interp3(y_mat, x_mat, z_mat, mat, y_mat_interp, x_mat_interp, z_mat_interp, interp_mode); otherwise error( end
T = maketform( R = makeresampler({ ImageScaled = tformarray(Image,T,R,[1 2 3],[1 2 3], round(size(Image)*x),[],0);
theta = linspace(0,2*pi,100); r = sin(2*theta) .* cos(2*theta); r_max = 1; h_fake = polar(theta,r_max*ones(size(theta))); hold on; h = polar(theta, r); set(h_fake,
fake=100; polar(0,fake, hold on; real=10; polar(0,real,
function h = imagesc4pdf(C) [ny nx] = size(C); px = bsxfun(@plus, [-0.5; 0.5; 0.5; -0.5], reshape(1:nx, [1 1 nx])); py = bsxfun(@plus, [-0.5; -0.5; 0.5; 0.5], 1:ny); n = numel(C); px = reshape(repmat(px, [1 ny 1]), 4, n); py = reshape(repmat(py, [1 1 nx]), 4, n); h = patch(px, py, reshape(C,1,n), xlim([.5 nx+.5]); ylim([.5 ny+.5]); set(gca,
$ brew cask install xquartz $ brew cask install aquaterm $ brew uninstall gnuplot $ brew install gnuplot --with-aquaterm --with-x11 --with-qt
A = rand(10,1); B = cell(10,1); for i=1:10 B{i} = A(i); end B = [0.6221] [0.3510] [0.5132] [0.4018] [0.0760] [0.2399] [0.1233] [0.1839] [0.2400] [0.4173]
rgb = imread( hsv = rgb2hsv(rgb); openimg = imopen(hsv(:, :, 3), strel( mask = imregionalmin(openimg); imshow(rgb); hold on; [r, c] = find(mask); plot(c, r,
im0=imread( im=(abs(255-im0)); d=rgb2gray(im); filter=fspecial( p=FastPeakFind(d,0,filter); imagesc(im0); hold on plot(p(1:2:end),p(2:2:end),
%creating a dummy image with a bunch of small white crosses im = zeros(100,100); numPoints = 10; % randomly chose the location to put those crosses points = randperm(numel(im)); % keep only certain number of points points = points(1:numPoints); % get the row and columns (x,y) [xVals,yVals] = ind2sub(size(im),points); for ii = 1:numel(points) x = xVals(ii); y = yVals(ii); try % create the crosses, try statement is here to prevent index out of bounds % not necessarily the best practice but whatever, it is only for demonstration im(x,y) = 1; im(x+1,y) = 1; im(x-1,y) = 1; im(x,y+1) = 1; im(x,y-1) = 1; catch err end end % display the randomly generated image imshow(im) % create a simple cross filter filter = [0,1,0;1,1,1;0,1,0]; figure; imshow(filter) % perform convolution of the random image with the cross template result = conv2(im,filter, % get the number of white pixels in filter filSum = sum(filter(:)); % look for all points in the convolution results that matched identically to the filter matches = find(result == filSum); %validate all points found sort(matches(:)) == sort(points(:)) % get x and y coordinate matches [xMatch,yMatch] = ind2sub(size(im),matches);
a = [ 0.001 .. 0.011]; b = [1, .. 10]; c = [ -.304860225, .. .379710865];
% some 3d points data = mvnrnd([0 0 0], [1 -0.5 0.8; -0.5 1.1 0; 0.8 0 1], 50);
% best-fit plane C = [data(:,1) data(:,2) ones(size(data,1),1)] \ data(:,3); % coefficients % evaluate it on a regular grid covering the domain of the data [xx,yy] = meshgrid(-3:.5:3, -3:.5:3); zz = C(1)*xx + C(2)*yy + C(3); % or expressed using matrix/vector product %zz = reshape([xx(:) yy(:) ones(numel(xx),1)] * C, size(xx));
% plot points and surface figure( line(data(:,1), data(:,2), data(:,3), surface(xx, yy, zz, ... grid on; axis tight equal; view(9,9); xlabel x; ylabel y; zlabel z; colormap(cool(64))
% best-fit quadratic curve C = [ones(50,1) data(:,1:2) prod(data(:,1:2),2) data(:,1:2).^2] \ data(:,3); zz = [ones(numel(xx),1) xx(:) yy(:) xx(:).*yy(:) xx(:).^2 yy(:).^2] * C; zz = reshape(zz, size(xx));
C = x2fx(data(:,1:2), zz = x2fx([xx(:) yy(:)], zz = reshape(zz, size(xx));
model = polyfitn(data(:,1:2), data(:,3), 2); zz = polyvaln(model, [xx(:) yy(:)]); zz = reshape(zz, size(xx));
x = a(:); %make column vectors y = b(:); z = c(:); %first order fit M = [ones(size(x)), x, y]; k1 = M\z; %least square solution of z = M * k1, so z = k1(1) + k1(2) * x + k1(3) * y
%second order fit M = [ones(size(x)), x, y, x.^2, x.*y, y.^2]; k2 = M\z;
ngrid = 20; [A,B] = meshgrid(linspace(min(a), max(a), ngrid), ... linspace(min(b), max(b), ngrid)); M = [ones(numel(A),1), A(:), B(:), A(:).^2, A(:).*B(:), B(:).^2]; C2_fit = reshape(M * k2, size(A)); % = k2(1) + k2(2)*A + k2(3)*B + k2(4)*A.^2 + ... %plot to compare fit with original data surfl(A,B,C2_fit);shading flat;colormap gray hold on plot3(a,b,c,
transfer_function = activation function + output function
function Interact() % Interactive stuff here figure(); hold on; axis([0 7 0 5]) DrawLagrange([1,1; 3,4; 6,2]) function DrawLagrange(P) plot(P(:,1), P(:,2), t = 0:.1:2; Lagrange = [.5*t.^2 - 1.5*t + 1; -t.^2 + 2*t; .5*t.^2 - .5*t]; CurveX = P(1,1)*Lagrange(1,:) + P(2,1)*Lagrange(2,:) + P(3,1)*Lagrange(3,:); CurveY = P(1,2)*Lagrange(1,:) + P(2,2)*Lagrange(2,:) + P(3,2)*Lagrange(3,:); plot(CurveX, CurveY);
% ------------------------------------------------- % This file needs the Image Processing Toolbox! % ------------------------------------------------- function Interact(Pos) % This part is executed when you run it for the first time. % In that case, the number of input arguments (nargin) == 0. if nargin == 0 close all; clear all; clc; figure(); hold on; axis([0 7 0 5]) % I do not know how to do this without global variables? global P0 P1 P2 % GCA = Get handle for Current Axis P0 = ImPoint(gca,1,1); setString(P0, P1 = ImPoint(gca,2,4); setString(P1, P2 = ImPoint(gca,6,2); setString(P2, % Call subfunction DrawLagrange(P0,P1,P2) % Add callback to each point addNewPositionCallback(P0,@Interact); addNewPositionCallback(P1,@Interact); addNewPositionCallback(P2,@Interact); else % If there _is_ some input argument, it has to be the updated % position of a moved point. global H1 H2 P0 P1 P2 % Display X and Y coordinates of moved point Pos % Important: remove old plots! Otherwise the graph will get messy. delete(H1) delete(H2) DrawLagrange(P0,P1,P2) end function DrawLagrange(P0,P1,P2) P = zeros(3,2); % Get X and Y coordinates for the 3 points. P(1,:) = getPosition(P0); P(2,:) = getPosition(P1); P(3,:) = getPosition(P2); global H1 H2 H1 = plot(P(:,1), P(:,2), t = 0:.1:2; Lagrange = [.5*t.^2 - 1.5*t + 1; -t.^2 + 2*t; .5*t.^2 - .5*t]; CurveX = P(1,1)*Lagrange(1,:) + P(2,1)*Lagrange(2,:) + P(3,1)*Lagrange(3,:); CurveY = P(1,2)*Lagrange(1,:) + P(2,2)*Lagrange(2,:) + P(3,2)*Lagrange(3,:); H2 = plot(CurveX, CurveY);
%minimum absolute differences kick in again xx = 1:10; %xdata yy = exp(xx); plot(xx,yy); [xm ym] = ginput(1); %xmouse, ymouse %Engine [~, xidx] = min(abs(xx-xm)); %closest index [~, yidx] = min(abs(yy-ym)); x_closest = xx(xidx) %extract y_closest = yy(yidx)
y1 = tansig(net.IW{1} * input + net.b{1}); Results = tansig(net.LW{2} * y1 + net.b{2});
function net = create_pr_net(inputs,targets) %CREATE_PR_NET Creates and trains a pattern recognition neural network. % % NET = CREATE_PR_NET(INPUTS,TARGETS) takes these arguments: % INPUTS - RxQ matrix of Q R-element input samples % TARGETS - SxQ matrix of Q S-element associated target samples, where % each column contains a single 1, with all other elements set to 0. % and returns these results: % NET - The trained neural network % % For example, to solve the Iris dataset problem with this function: % % load iris_dataset % net = create_pr_net(irisInputs,irisTargets); % irisOutputs = sim(net,irisInputs); % % To reproduce the results you obtained in NPRTOOL: % % net = create_pr_net(trainingSetInput,trainingSetOutput); % Create Network numHiddenNeurons = 20; % Adjust as desired net = newpr(inputs,targets,numHiddenNeurons); net.divideParam.trainRatio = 75/100; % Adjust as desired net.divideParam.valRatio = 15/100; % Adjust as desired net.divideParam.testRatio = 10/100; % Adjust as desired % Train and Apply Network [net,tr] = train(net,inputs,targets); outputs = sim(net,inputs); % Plot plotperf(tr) plotconfusion(targets,outputs)
net.inputs{1}.processFcns = {}; net.outputs{2}.processFcns = {};
function [ Results ] = classify( net, input ) y1 = tansig(net.IW{1} * input + net.b{1}); Results = tansig(net.LW{2} * y1 + net.b{2}); end
>> sim(net, input(:, 1)) ans = 0.9759 -0.1867 -0.1891 >> classify(net, input(:, 1)) ans = 0.9759 -0.1867 -0.1891
Results = tansig(net.LW{2} * y1 + net.b{2}); -> Results = net.LW{2} * y1 + net.b{2};
xmax = net.inputs{1}.processSettings{1}.xmax xmin = net.inputs{1}.processSettings{1}.xmin
xmax = net.outputs{2}.processSettings{1}.xmax xmin = net.outputs{2}.processSettings{1}.xmin Results = (ymax-ymin)*(Results-xmin)/(xmax-xmin) + ymin; -> Results = (Results-ymin)*(xmax-xmin)/(ymax-ymin) + xmin;
y1 = purelin ( net.LW{2} * tansig(net.iw{1}* p2 + net.b{1}) + net.b{2})
[m n] = size(input); ymax = 1; ymin = -1; for i=1:m xmax = max(input(i,:)); xmin = min(input(i,:)); for j=1:n input(i,j) = (ymax-ymin)*(input(i,j)-xmin)/(xmax-xmin) + ymin; end end
ymax = 1; ymin = 0; xmax = 1; xmin = -1; Results = (ymax-ymin)*(Results-xmin)/(xmax-xmin) + ymin;
Mat mapminmax_apply(Mat x, Mat settings_gain, Mat settings_xoffset, double settings_ymin){ Mat y; subtract(x, settings_xoffset, y); multiply(y, settings_gain, y); add(y, settings_ymin, y); return y; /* MATLAB CODE y = x - settings_xoffset; y = y .* settings_gain; y = y + settings_ymin; */ } Mat transig_apply(Mat n){ Mat tempexp; exp(-2*n, tempexp); Mat transig_apply_result = 2 /(1 + tempexp) - 1; return transig_apply_result; } Mat mapminmax_reverse(Mat y, Mat settings_gain, Mat settings_xoffset, double settings_ymin){ Mat x; subtract(y, settings_ymin, x); divide(x, settings_gain, x); add(x, settings_xoffset, x); return x; /* MATLAB CODE function x = mapminmax_reverse(y,settings_gain,settings_xoffset,settings_ymin) x = y - settings_ymin; x = x ./ settings_gain; x = x + settings_xoffset; end */ } Mat getNNParameter (Mat x1) { Mat x1_step1_xoffsetM = Mat(1, 48, CV_64FC1, x1_step1_xoffset).t(); Mat x1_step1_gainM = Mat(1, 48, CV_64FC1, x1_step1_gain).t(); double x1_step1_ymin = -1; Mat b1M = Mat(1, 25, CV_64FC1, b1).t(); Mat IW1_1M = Mat(48, 25, CV_64FC1, IW1_1).t(); Mat b2M = Mat(1, 48, CV_64FC1, b2).t(); Mat LW2_1M = Mat(25, 48, CV_64FC1, LW2_1).t(); Mat y1_step1_gainM = Mat(1, 48, CV_64FC1, y1_step1_gain).t(); Mat y1_step1_xoffsetM = Mat(1, 48, CV_64FC1, y1_step1_xoffset).t(); double y1_step1_ymin = -1; Mat xp1 = mapminmax_apply(x1, x1_step1_gainM, x1_step1_xoffsetM, x1_step1_ymin); Mat temp = b1M + IW1_1M*xp1; Mat a1M = transig_apply(temp); Mat a2M = b2M + LW2_1M*a1M; Mat y1M = mapminmax_reverse(a2M, y1_step1_gainM, y1_step1_xoffsetM, y1_step1_ymin); return y1M; }
static double b2[1][48] = { {-0.19879, 0.78254, -0.87674, -0.5827, -0.017464, 0.13143, -0.74361, 0.4645, 0.25262, 0.54249, -0.22292, -0.35605, -0.42747, 0.044744, -0.14827, -0.27354, 0.77793, -0.4511, 0.059346, 0.29589, -0.65137, -0.51788, 0.38366, -0.030243, -0.57632, 0.76785, -0.36374, 0.19446, 0.10383, -0.57989, -0.82931, 0.15301, -0.89212, -0.17296, -0.16356, 0.18946, -1.0032, 0.48846, -0.78148, 0.66608, 0.14946, 0.1972, -0.93501, 0.42523, -0.37773, -0.068266, -0.27003, 0.1196}};
% Export IT exported_ann_structure = my_ann_exporter(trained_ann); % Run and Compare % Works only for single INPUT vector % Please extend it to MATRIX version by yourself input = [12 3 5 100]; res1 = trained_ann(input res2 = my_ann_evaluation(exported_ann_structure, input
function [ my_ann_structure ] = my_ann_exporter(trained_netw) % Just for extracting as Structure object my_ann_structure.input_ymax = trained_netw.inputs{1}.processSettings{1}.ymax; my_ann_structure.input_ymin = trained_netw.inputs{1}.processSettings{1}.ymin; my_ann_structure.input_xmax = trained_netw.inputs{1}.processSettings{1}.xmax; my_ann_structure.input_xmin = trained_netw.inputs{1}.processSettings{1}.xmin; my_ann_structure.IW = trained_netw.IW{1}; my_ann_structure.b1 = trained_netw.b{1}; my_ann_structure.LW = trained_netw.LW{2}; my_ann_structure.b2 = trained_netw.b{2}; my_ann_structure.output_ymax = trained_netw.outputs{2}.processSettings{1}.ymax; my_ann_structure.output_ymin = trained_netw.outputs{2}.processSettings{1}.ymin; my_ann_structure.output_xmax = trained_netw.outputs{2}.processSettings{1}.xmax; my_ann_structure.output_xmin = trained_netw.outputs{2}.processSettings{1}.xmin; end
function [ res ] = my_ann_evaluation(my_ann_structure, input) % Works with only single INPUT vector % Matrix version can be implemented ymax = my_ann_structure.input_ymax; ymin = my_ann_structure.input_ymin; xmax = my_ann_structure.input_xmax; xmin = my_ann_structure.input_xmin; input_preprocessed = (ymax-ymin) * (input-xmin) ./ (xmax-xmin) + ymin; % Pass it through the ANN matrix multiplication y1 = tanh(my_ann_structure.IW * input_preprocessed + my_ann_structure.b1); y2 = my_ann_structure.LW * y1 + my_ann_structure.b2; ymax = my_ann_structure.output_ymax; ymin = my_ann_structure.output_ymin; xmax = my_ann_structure.output_xmax; xmin = my_ann_structure.output_xmin; res = (y2-ymin) .* (xmax-xmin) /(ymax-ymin) + xmin; end
function [varargout]=funeval(fun,varargin) % INPUT: % fun: (char) full path to function file curdir=cd; [fundir,funname]=fileparts(fun); cd(fundir); [varargout{1:nargout}] =feval(funname,varargin{:}) cd(curdir);
function [varargout]=funeval(FunctionHandle, FunctionPath, varargin) % INPUT: % FunctionHandle: handle to the function to be called; eg @MyFunction % FunctionPath: the path to that function % varargin: the arguments to be passed to Myfunction curdir=cd; cd(FunctionPath) [varargout{1:nargout}] = FunctionHandle(varargin{:}); cd(curdir); end
A = [ 0 0.89287 1.54987 0 0.69933 1.81970 0 0.84022 1.28598 0 0.79523 1.16012 0 0.61266 1.12835 0 0.39950 0.37942 0 0.54807 1.66173 0 0.50882 1.43175 0 0.68840 1.58589 0 0.59572 1.29311 1 1.00787 1.09905 1 1.23724 0.98834 1 1.02175 0.67245 1 0.88458 0.36003 1 0.66582 1.22097 1 1.24408 0.59735 1 1.03421 0.88595 1 1.66279 0.84183 ]; gscatter(A(:,2),A(:,3),A(:,1))
% num = 50; X = [ mvnrnd([0.5 1.5], [0.025 0.03 ; 0.03 0.16], num) ; ... mvnrnd([1 1], [0.09 -0.01 ; -0.01 0.08], num) ]; G = [1*ones(num,1) ; 2*ones(num,1)]; gscatter(X(:,1), X(:,2), G) axis equal, hold on for k=1:2 % idx = ( G == k ); % Mu = mean( X(idx,:) ); X0 = bsxfun(@minus, X(idx,:), Mu); % [V D] = eig( X0 [D order] = sort(diag(D), D = diag(D); V = V(:, order); t = linspace(0,2*pi,100); e = [cos(t) ; sin(t)]; % VV = V*sqrt(D); % e = bsxfun(@plus, VV*e, Mu % plot(e(1,:), e(2,:), % % end
STD = 2; % conf = 2*normcdf(STD)-1; % scale = chi2inv(conf,2); % Cov = cov(X0) * scale; [V D] = eig(Cov);
Center = mean(B,1); Centered_data = bsxfun(@minus,B,Center); [AX,MAG] = eig(Centered_data
get(Hfig, Error using get Ambiguous property found. Object Name: figure Property Name:
v = randn(10000,3); v = bsxfun(@rdivide,v,sqrt(sum(v.^2,2))); plot3(v(:,1),v(:,2),v(:,3), axis equal
function s = mySilhouette(X, IDX) % % % N = size(X,1); % K = numel(unique(IDX)); % % D = squareform( pdist(X, % kIndices = accumarray(IDX, 1:N, [K 1], @(x){sort(x)}); % % % a = zeros(N,1); b = zeros(N,1); for i=1:N ind = kIndices{IDX(i)}; ind = ind(ind~=i); a(i) = mean( D(i,ind) ); b(i) = min( cellfun(@(ind) mean(D(i,ind)), kIndices([1:K]~=IDX(i))) ); end s = (b-a) ./ max(a,b); end
% load fisheriris X = meas; N = size(X,1); % K = 3; [IDX,C] = kmeans(X, K, s = mySilhouette(X, IDX); % [~,ord] = sortrows([IDX s],[1 -2]); indices = accumarray(IDX(ord), 1:N, [K 1], @(x){sort(x)}); ytick = cellfun(@(ind) (min(ind)+max(ind))/2, indices); ytickLabels = num2str((1:K) h = barh(1:N, s(ord), set(h, set(gca, set(gca, xlabel( % figure, silhouette(X,IDX)
from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm from matplotlib.ticker import LinearLocator, FormatStrFormatter import matplotlib.pyplot as plt import numpy as np from scipy.special import erf fig = plt.figure() ax = fig.gca(projection= X = np.arange(0, 6, 0.25) Y = np.arange(0, 6, 0.25) X, Y = np.meshgrid(X, Y) Z1 = np.zeros_like(X) Z2 = np.ones_like(X) for i in range(len(X)): for j in range(len(X[0])): Z1[i,j] = 0.5*(erf((X[i,j]+Y[i,j]-4.5)*0.5)+1) Z2[i,j] = 0.5*(erf((-X[i,j]-Y[i,j]+4.5)*0.5)+1) alpha = 0.25 surf1 = ax.plot_surface(X, Y, Z1, cstride=2, rstride=1, cmap=cm.Oranges, linewidth=0, antialiased=False, alpha=alpha) surf2 = ax.plot_surface(X, Y, Z2, cstride=2, rstride=1, cmap=cm.Blues, linewidth=0, antialiased=False, alpha=alpha) ax.zaxis.set_major_locator(LinearLocator(10)) ax.zaxis.set_major_formatter(FormatStrFormatter( fig.colorbar(surf1, shrink=0.5, aspect=5) fig.colorbar(surf2, shrink=0.5, aspect=5) plt.show()
from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import numpy as np from scipy.special import erf fig = plt.figure() ax = fig.gca(projection= X = np.arange(0, 6, 0.25) Y = np.arange(0, 6, 0.25) X, Y = np.meshgrid(X, Y) Z1 = np.empty_like(X) Z2 = np.empty_like(X) C1 = np.empty_like(X, dtype=object) C2 = np.empty_like(X, dtype=object) for i in range(len(X)): for j in range(len(X[0])): z1 = 0.5*(erf((X[i,j]+Y[i,j]-4.5)*0.5)+1) z2 = 0.5*(erf((-X[i,j]-Y[i,j]+4.5)*0.5)+1) Z1[i,j] = z1 Z2[i,j] = z2 C1[i,j] = plt.get_cmap("Oranges")(z1) C2[i,j] = plt.get_cmap("Blues")(z2) X_bridge = np.vstack([X[-1,:],X[-1,:]]) Y_bridge = np.vstack([Y[-1,:],Y[-1,:]]) Z_bridge = np.vstack([Z1[-1,:],Z2[-1,:]]) color_bridge = np.empty_like(Z_bridge, dtype=object) color_bridge.fill((1,1,1,0)) X_full = np.vstack([X, X_bridge, np.flipud(X)]) Y_full = np.vstack([Y, Y_bridge, np.flipud(Y)]) Z_full = np.vstack([Z1, Z_bridge, np.flipud(Z2)]) color_full = np.vstack([C1, color_bridge, np.flipud(C2)]) surf_full = ax.plot_surface(X_full, Y_full, Z_full, rstride=1, cstride=1, facecolors=color_full, linewidth=0, antialiased=False) plt.show()
from mpl_toolkits.mplot4d import Axes3D import matplotlib.pyplot as plt import numpy as np fig = plt.figure() ax = fig.gca(projection= X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) R = (X+Y) Z1 = R/R.max() Z2 = -R/R.max() surfA_bottom = ax.plot_surface(X, Y, np.where(Z1<=Z2,Z1, np.nan), rstride=1, cstride=1, color= surfB = ax.plot_surface(X, Y, Z2, rstride=1, cstride=1, color= surfA_top = ax.plot_surface(X, Y, np.where(Z1>=Z2,Z1, np.nan), rstride=1, cstride=1, color= ax.set_zlim3d(-1, 1) ax.set_ylim(-5,5) ax.set_xlim(-5,5) plt.show()
from mpl_toolkits.mplot4d import Axes3D import matplotlib.pyplot as plt import numpy as np fig = plt.figure() ax = fig.gca(projection= X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) Z1 = np.sin(np.sqrt(X**2+Y**2)) Z2 = np.ones_like(Z1)*0.6 C1 = np.empty_like(X, dtype=str) C1.fill( C2 = C1.copy() C2.fill( X3 = np.vstack([X,X]) Y3 = np.vstack([Y,Y]) Z3 = np.vstack([Z1,Z2]) C3 = np.vstack([C1,C2]) surf3 = ax.plot_surface(X3, Y3, Z3, rstride=1, cstride=1, facecolors=C3, linewidth=0, antialiased=False, alpha=0.5) ax.set_zlim3d(-1, 2) plt.show()
from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import numpy as np fig = plt.figure() ax = fig.gca(projection= X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) Z1 = np.sin(np.sqrt(X**2+Y**2)) Z2 = np.ones_like(Z1)*0.6 color1 = np.empty_like(X, dtype=str) color1.fill( color2 = np.empty_like(X, dtype=str) color2.fill( X_bridge = np.vstack([X[-1,:],X[0,:]]) Y_bridge = np.vstack([Y[-1,:],Y[0,:]]) Z_bridge = np.vstack([Z1[-1,:],Z2[0,:]]) color_bridge = np.empty_like(Z_bridge, dtype=object) color_bridge.fill((1,1,1,0)) X_full = np.vstack([X, X_bridge, X]) Y_full = np.vstack([Y, Y_bridge, Y]) Z_full = np.vstack([Z1, Z_bridge, Z2]) color_full = np.vstack([color1, color_bridge, color2]) surf_full = ax.plot_surface(X_full, Y_full, Z_full, rstride=1, cstride=1, facecolors=color_full, linewidth=0, antialiased=False) ax.set_zlim3d(-1, 2) ax.set_ylim(-5,5) ax.set_xlim(-5,5) plt.show()
>> Z = zeros(628000000, 1, >> Z(364000000:end) = []; Out of memory. Type HELP MEMORY for your options.
% truncTest.m N = 628000000; M = 364000000; clear Z Z = zeros(N,1, Z(M:end) = []; Z(1) % just because clear Z Z = zeros(N,1, Z = Z(1:M); Z(1)
>> tic; feature mtic; Z=Z(1:M-1); feature mtoc, toc ans = TotalAllocated: 808011592 TotalFreed: 916009628 LargestAllocated: 403999996 NumAllocs: 86 NumFrees: 77 Peak: 808002024 Elapsed time is 0.951283 seconds.
>> tic; feature mtic; Z(M:end) = []; feature mtoc, toc ans = TotalAllocated: 1428019588 TotalFreed: 1536018372 LargestAllocated: 512000000 NumAllocs: 164 NumFrees: 157 Peak: 1320001404 Elapsed time is 4.533953 seconds.
figH = figure( % Plot something % save the plot as an image with same size as the plot close(figH) ;
figure, close plot(1:10) print file saveas(gcf, exit
figure, close plot(1:10) set(gcf, print -deps2c -r0 file.eps exit
fig(1) = myFunkyFigure(dataSet1); fig(2) = myFunkyFigure(dataSet2);
subplot(2,1,1); myFunkyFigure(dataSet1); subplot(2,1,2); myFunkyFigure(dataSet2);
hSub1 = subplot(2,1,1); % myFunkyFigure(dataSet1,hSub1); % hSub2 = subplot(2,1,2); % myFunkyFigure(dataSet2,hSub2); %
hFigure = figure(); % hTemp = subplot(2,1,1, newPos = get(hTemp, delete(hTemp); % set(fig(1), % hTemp = subplot(2,1,2, %
Error using copyobj Object figure[1] can not be a child of parent figure[1]
function []= move_to_subplots(ax,a,b) % % % Inputs: % inputname: % Outputs: % name: description type units % saved data: (does this overwrite a statically named file?) % plots: % % Standard call: % % % Written by C. Hogg Date 2012_06_01 % % debugmode=0; hFigure=figure(); if ~exist( a=ceil(sqrt(length(ax))); end if ~exist( b=1; end if a*b<length(ax)|~exist( disp( b=ceil(length(ax)/a); end for i=1:length(ax) hTemp = subplot(a,b,i, newPos = get(hTemp, delete(hTemp); hNew = copyobj(ax(i),hFigure); set(hNew, end %% Debug. Break point here. if debugmode==1; dbstop tic; tic; dbclear all;end end
classdef foo < handle properties bar = randn(1000); end
f = foo(); origWarn = warning(); warning off s = builtin( warning(origWarn);
>> whos Name Size Bytes Class Attributes f 1x1 60 foo s 1x1 8000124 struct
x = NaN(1,10000); s.x = x; s.y = x; s.z = x; >> whos Name Size Bytes Class Attributes s 1x1 240372 struct x 1x10000 80000 double
function total_mem = get_mem(obj) % props = properties(obj); total_mem = 0; % for ii=1:length(props) % curr_prop = obj.(props{ii}); % % s = whos( % total_mem = total_mem + s.bytes; end end
idx1=1; idx2=5; values=idx1:idx2 % Result % values = % % 1 2 3 4 5
step = 1; idx1 = [5, 9]; idx2 = [9, 11]; values = arrayfun(@(x,y)colon(x, step, y), idx1, idx2, values=vertcat(cell2mat(values));
function x = coloncatrld(start, stop) % COLONCAT Concatenate colon expressions % X = COLONCAT(START,STOP) returns a vector containing the values % [START(1):STOP(1) START(2):STOP(2) START(END):STOP(END)]. % Based on Peter Acklam len = stop - start + 1; % keep only sequences whose length is positive pos = len > 0; start = start(pos); stop = stop(pos); len = len(pos); if isempty(len) x = []; return; end % expand out the colon expressions endlocs = cumsum(len); incr = ones(1, endlocs(end)); jumps = start(2:end) - stop(1:end-1); incr(endlocs(1:end-1)+1) = jumps; incr(1) = start(1); x = cumsum(incr);
load ( val = (val - 1024)/200; % you have to remove "base" and "gain" ECGsignal = val(1,1:1000); % select the lead (Lead I) Fs = 360; % sampling frequecy t = (0:length(ECGsignal)-1)/Fs; % time plot(t,ECGsignal)
val = val/2047 % (2047 is the max volt range of signals)
lowpass = scipy.signal.butter(1, highfreq/(rate/2.0), highpass = scipy.signal.butter(1, lowfreq/(rate/2.0), ecg_low = scipy.signal.filtfilt(*lowpass, x=ecg) ecg_band = scipy.signal.filtfilt(*highpass, x=ecg_low)
A=input( load(A); a=(val(1,:)); b=fir1(100,[0.1,0.25], y2=filter(b,1,a); figure; plot(y2);
% rawUnits % A 1x1 integer (default: 0). Returns tm and signal as vectors % according to the following values: % rawUnits=0 - Uses Java Native Interface to directly fetch data, returning signal in physical units with double precision. % rawUnits=1 -returns tm ( millisecond precision only! ) and signal in physical units with 64 bit (double) floating point precision % rawUnits=2 -returns tm ( millisecond precision only! ) and signal in physical units with 32 bit (single) floating point precision % rawUnits=3 -returns both tm and signal as 16 bit integers (short). Use Fs to convert tm to seconds. % rawUnits=4 -returns both tm and signal as 64 bit integers (long). Use Fs to convert tm to seconds.
load( val = (val - 1024)/200; % you have to remove "base" and "gain" ECGsignal = val(1,16:950); % select the lead (Lead I)
Source: record mitdb/201 Start: [00:02:10.000] val has 2 rows (signals) and 3600 columns (samples/signal) Duration: 0:10 Sampling frequency: 360 Hz Sampling interval: 0.002777777778 sec Row Signal Gain Base Units 1 MLII 200 1024 mV 2 V1 200 1024 mV To convert from raw units to the physical units shown above, subtract
load( val = (val - 1024)/200; % you have to remove "base" and "gain" ECGsignal = val(1,16:950); % select the lead (Lead I) load( ECGsignal2 = val(1,16:950); imshow(imoverlay(ECGsignal, ECGsignal2, uint8([255,0,0])))
T = 360; % number of time periods (i.e. rows) in X n = 15000; % number of time series (i.e. columns) in X T_subsample = 72; % desired length of sample (i.e. rows of newX) % number of possible starting points for series of length T_subsample nancount_periods = T - T_subsample + 1; nancount = zeros(n, nancount_periods, X_isnan = int32(isnan(X)); nancount(:,1) = sum(X_isnan(1:T_subsample, :)) % We need to obtain a count of nans in T_subsample sized window for each % possible time period j = 1; for i=T_subsample + 1:T % One pass: add new period in the window and subtract period no longer in the window nancount(:,j+1) = nancount(:,j) + X_isnan(i,:) j = j + 1; end indicator = nancount==0; % indicator of whether starting_period, series % has no NaNs % number of nonan series of length T_subsample by starting period max_subsample_size_by_starting_period = sum(indicator); max_subsample_size = max(max_subsample_size_by_starting_period); % find the best starting period starting_period = find(max_subsample_size_by_starting_period==max_subsample_size, 1); ending_period = starting_period + T_subsample - 1; columns_mask = indicator(:,starting_period); columns = find(columns_mask); %holds the column ids we are using newX = X(starting_period:ending_period, columns_mask);
data = rand(360,15e3); data(abs(data) <= 0.02) = NaN; %% sort and chop data based on amount of consecutive non-NaN values binary_data = ~isnan(data); % find edges, denote their type and calculate the biggest chunk in each % column edges = [2*binary_data(1,:)-1; diff(binary_data, 1)]; chunk_size = diff(find(edges)); chunk_size(end+1) = numel(edges)-sum(chunk_size); [row, ~, id] = find(edges); num_row_elements = diff(find(row == 1)); num_row_elements(end+1) = numel(chunk_size) - sum(num_row_elements); %a chunk of NaN has a -1 in id, a chunk of non-NaN a 1 chunks_per_row = mat2cell(chunk_size .* id,num_row_elements,1); % sort by largest consecutive block of non-NaNs max_size = cellfun(@max, chunks_per_row); [max_size_sorted, idx] = sort(max_size, data_sorted = data(:,idx); % remove all elements that only have block sizes smaller then some number some_number = 20; data_sort_chop = data_sorted(:,max_size_sorted >= some_number);
%do not use, instead use: http: function [stack,map,transparent]=transparentGifRead(filename) if ~exist(filename, error( end info=imfinfo(filename); %Check if color map for all frames is the same if any(any(any(diff(cat(3,info.ColorTable),[],3)))) error( else map=info(1).ColorTable; end %Check if transparent color for all frames is the same if any(diff([info.TransparentColor])) error( else transparent=info(1).TransparentColor-1; end import java.io.* str = javax.imageio.ImageIO.createImageInputStream(java.io.File(filename)); t = javax.imageio.ImageIO.getImageReaders(str); reader = t.next(); reader.setInput(str); numframes = reader.getNumImages(true); for imageix = 1:numframes data = reader.read(imageix-1).getData(); height = data.getHeight(); width = data.getWidth(); data2 = reader.read(imageix-1).getData().getPixels(0,0,width,height,[]); if imageix == 1 stack=zeros(height,width,1,numframes, end %row major vs column major fix stack(:,:,1,imageix) = reshape(data2,[width height]). end str.close(); end
[stack,map,transparent]=transparentGifRead( map(transparent+1,:)=[0,1,0] %offset 1 because uint8 starts at 0 but indices at 1 for frame=1:size(stack,ndims(stack)) imshow(stack(:,:,frame),map); pause(1/25); end
im1 = imread( im2 = imread( Red1 = im1(:, :, 1); Green1 = im1(:, :, 2); Blue1 = im1(:, :, 3); . . . Red2 = im2(:, :, 1); Green2 = im2(:, :, 2); Blue2 = im2(:, :, 3); red2n = histeq(Red2,HnRed1); green2n = histeq(Green2,HnGreen1); blue2n = histeq(Blue2,HnBlue1);
%classic instruction for searching feature [fa,da] = vl_sift((Ia_f), % with the same line I obtain %fa are features in the current left image (da are descriptors) %fb are features in the current right image (db... ) %fa_old are features in the previous left image %fb_old are features in the previous right image %code from tutorials (find the feature) [matches, scores] = vl_ubcmatch(da,db,thresh_SIFT) ; [drop, perm] = sort(scores, matches = matches(:, perm); %my code figure(1) ; %clf ; axis equal; %prepare the image imshow(cat(1,(cat(2, Ia_v_old, Ib_v_old)),cat(2,Ia_v,Ib_v))); %matching between the left frames (current and previous) [matches_prev, scores_prev] = vl_ubcmatch(da,da_old,thresh_SIFT) ; [drop_prev, perm_prev] = sort(scores_prev, matches_prev = matches_prev(:, perm_prev) ; %find index of descriptors in common, write them in order I = intersect(matches(1,:), matches_prev(1,:), MI_1 = arrayfun(@(x)find(matches(1,:)==x,1),I); MI_2 = arrayfun(@(x)find(matches_prev(1,:)==x,1),I); matches_M = matches(:,MI_1(:)); matches_prev_M = matches_prev(:,MI_2(:)); %features coordinates in the current images (bottom) xa = fa(1,matches_M(1,:)) + offset_column ; xb = fb(1,matches_M(2,:)) + size(Ia,2); %+offset_column-offset_column ; ya = fa(2,matches_M(1,:)) + offset_row + size(Ia,1); yb = fb(2,matches_M(2,:)) + offset_row + size(Ia,1); %matching "in space" (blue lines) space_corr = line([xa ; xb], [ya ; yb]) ; set(space_corr, %plotting features fa(1,:) = fa(1,:) + offset_column ; fa(2,:) = fa(2,:) + offset_row + size(Ia,1); vl_plotframe(fa(:,matches_M(1,:))) ; fb(1,:) = fb(1,:) + size(Ia,2) ; fb(2,:) = fb(2,:) + offset_row + size(Ia,1); vl_plotframe(fb(:,matches_M(2,:))) ; %matching "in time" %corrx and coor y are corrected offsets xa2 = fa_old(1,matches_prev_M(2,:)) + corrx; %coordinate per display ya2 = fa_old(2,matches_prev_M(2,:)) - size(Ia,1) + corry; fa_old(1,:) = fa_old(1,:) + corrx; fa_old(2,:) = fa_old(2,:) - size(Ia,1) + corry; fb_old(1,:) = fb_old(1,:) + corrx ; fb_old(2,:) = fb_old(2,:) - size(Ia,1) + corry; %plot red lines time_corr = line([xa ; xa2], [ya ; ya2]) ; set(time_corr, %plot feature in top left image vl_plotframe(fa_old(:,matches_prev_M(2,:))) ; %plot feature in top right image vl_plotframe(fb_old(:,matches_ex_M(2,:))) ;
% one of many tries (all wrong) [matches_ex, scores_ex] = vl_ubcmatch(da_old,db_old,thresh_SIFT) ; [drop_ex, perm_ex] = sort(scores_ex, matches_ex = matches_ex(:, perm_ex); Ib = intersect(matches_prev_M(2,:), matches_ex(1,:), MIb_2 = arrayfun(@(x)find(matches_ex(1,:)==x,1),Ib); matches_ex_M = matches_ex(:,MIb_2(:));
n=100; x=linspace(-3,3,n); y=linspace(-3,3,n); z=linspace(-3,3,n); [X,Y,Z]=ndgrid(x,y,z); F=((-(X.^2) .* (Z.^3) -(9/80).*(Y.^2).*(Z.^3)) + ((X.^2) + (9/4).* (Y.^2) + (Z.^2)-1).^3); isosurface(F,0) lighting phong caxis axis equal colormap( view([55 34]);
function heart % Initialize the volume data, figure, and axes: [X,Y,Z] = meshgrid(linspace(-3,3,101)); F = -X.^2.*Z.^3-(9/80).*Y.^2.*Z.^3+(X.^2+(9/4).*Y.^2+Z.^2-1).^3; hFigure = figure( hAxes = axes( view([-39 30]); % Create and plot contours in the y-z plane: for iX = [35 38 41 45 48 51 54 57 61 64 67] plane = reshape(F(:,iX,:),101,101); cData = contourc(plane,[0 0]); xData = iX.*ones(1,cData(2,1)); plot3(hAxes,xData,cData(2,2:end),cData(1,2:end), end % Create and plot contours in the x-z plane: for iY = [41 44 47 51 55 58 61] plane = reshape(F(iY,:,:),101,101); cData = contourc(plane,[0 0]); yData = iY.*ones(1,cData(2,1)); plot3(hAxes,cData(2,2:end),yData,cData(1,2:end), end % Create and plot contours in the x-y plane: for iZ = [36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 69 71] plane = F(:,:,iZ); cData = contourc(plane,[0 0]); startIndex = 1; if size(cData,2) > (cData(2,1)+1) startIndex = cData(2,1)+2; zData = iZ.*ones(1,cData(2,1)); plot3(hAxes,cData(1,2:(startIndex-1)),... cData(2,2:(startIndex-1)),zData, end zData = iZ.*ones(1,cData(2,startIndex)); plot3(hAxes,cData(1,(startIndex+1):end),... cData(2,(startIndex+1):end),zData, end % Fill the inside of the mesh with an isosurface to % block rendering of the back side of the heart: p = patch(isosurface(F,-0.001)); set(p, end
function I_Heart_Math % Initialize heart plot and adjust figure and axes settings: heart; set(gcf, offset = get(gca, offset = 35.*offset./norm(offset); set(gca, % Create the axes and labels, offsetting them in front of the % heart to give the appearance they are passing through it: arrowStarts = [81 51 51; 51 86 51; 51 51 32]+repmat(offset,3,1); arrowEnds = [21 51 51; 51 16 51; 51 51 81]+repmat(offset,3,1); arrow(arrowStarts,arrowEnds,5,40,40); text( text( text( % Create the equation text: text( % Create the large-type text: hI = text( hM = text( % Create an anti-aliased version of the figure too (the larger % fonts need some adjustment to do this... not sure why): set(hI, set(hM, myaa; set(hI, set(hM, set(gcf, end
% volume data [X,Y,Z] = meshgrid(linspace(-3,3,101)); F = -X.^2.*Z.^3 - (9/80).*Y.^2.*Z.^3 + (X.^2 + (9/4).*Y.^2 + Z.^2 - 1).^3; % initialize figure hFig = figure( pos = get(hFig, set(hFig, % initialize axes hAxes = axes( view(-39,30); axis off % Fill the inside of the mesh with an isosurface to % block rendering of the back side of the heart patch(isosurface(F,-1e-3), hidden on % hidden surface removal % contours in the y-z plane for iX = [35 38 41 45 48 51 54 57 61 64 67] plane = reshape(F(:,iX,:), [101 101]); cData = contourc(plane, [0 0]); xData = iX.*ones(1,cData(2,1)); line(xData, cData(2,2:end), cData(1,2:end), ... pause(.1) end % contours in the x-z plane for iY = [41 44 47 51 55 58 61] plane = reshape(F(iY,:,:), [101 101]); cData = contourc(plane, [0 0]); yData = iY.*ones(1,cData(2,1)); line(cData(2,2:end), yData, cData(1,2:end), ... pause(.1) end % contours in the x-y plane for iZ = [36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 69 71] plane = F(:,:,iZ); cData = contourc(plane, [0 0]); startIndex = 1; if size(cData,2) > (cData(2,1)+1) startIndex = cData(2,1)+2; zData = iZ.*ones(1,cData(2,1)); line(cData(1,2:(startIndex-1)), cData(2,2:(startIndex-1)), zData, ... end zData = iZ.*ones(1,cData(2,startIndex)); line(cData(1,(startIndex+1):end), cData(2,(startIndex+1):end), zData, ... pause(.1) end % text props = { pause(.2) text(7,50,70, pause(.5) text(80,50,43, pause(.2) % xyz axes line([20 80], [50 50], [52.5 52.5], line([50 50], [20 80], [52.5 52.5], line([50 50], [50 50], [30 80], text(20,50,50, text(48,20,50, text(45,50,80, drawnow % equation props = { text(20,65,30, text(30,45,30, drawnow
% volume data step = 0.05; [X,Y,Z] = meshgrid(-3:step:3, -3:step:3, -3:step:3); F = (-(X.^2).*(Z.^3)-(9/80).*(Y.^2).*(Z.^3))+((X.^2)+(9/4).*(Y.^2)+(Z.^2)-1).^3; % shaded surface isosurface(X,Y,Z,F,0) lighting phong axis equal view(-39,30) set(gcf, colormap flag
% volume data step = 0.05; [X,Y,Z] = meshgrid(-3:step:3, -3:step:3, -3:step:3); F = (-(X.^2).*(Z.^3)-(9/80).*(Y.^2).*(Z.^3))+((X.^2)+(9/4).*(Y.^2)+(Z.^2)-1).^3; % wireframe patch(isosurface(X,Y,Z,F,0), daspect([1 1 1]) view(3) axis tight equal set(gcf,
nums = rand(1,3) output = zeros(1,2*numel(nums)); output(2:2:end) = nums
nums = 0.9134 0.6324 0.0975 output = 0 0.9134 0 0.6324 0 0.0975
nums = rand(1,3); reshape([zeros(size(nums));nums],1,[])
ar = a(:). br = b(:). A = [ar;br]; % concatenate them vertically c = A(:); % flatten the result
a = [9 8 7]; b = [1 2 3]; output = kron(a, [1 0]) + kron(b, [0 1]);
A = [1 2; 3 4] B = [5 6;7 8] C = interleave2(A, B, C = [1 2 5 6 3 4 7 8]
A = [1 2 3 4] B = [5 6 7 8 9] C = interleave2(A, B) C = [1 5 2 6 3 7 4 8 9]'
A = [1 2;3 4] B = [5 6;7 8] C = [9 10;11 12] D = [13 14;15 16] E = interleave2(A, B, C, D, E = [1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16]
A = [1 2;3 4] B = [5 6 7 8;9 10 11 12] C = interleave2(A, B, C = [1 5 2 6 7 8 3 9 4 10 11 12]
A = [1 2 3 4] B = [5 6 7] C = [8 9 10 11 12 13] D = interleave2(A, B, C) D = [1 5 8 2 6 9 3 7 10 4 11 12 13]
0.0677 0 0 0 0 0 0.0584 0 0 0 0 0 0.0487 0 0 0 0 0 0.0453 0 0 0 0 0 0.0394
n = length(vec); D = zeros(n); D(cumsum([1,repmat(n+1,1,n-1)])) = vec;
D = zeros(numel(vec)); [I,J] = ind2sub(size(D),1:numel(D)); ind = [I(:) J(:)]; ind = find(ind(:,1)==ind(:,2)); D(ind) = vec;
vector;%Your vector vec_length = length(vector); A = zeros(vec_length); for i=1:vec_length A(i,i) = vector(i); end;
for w=1:100 for p=1:9 A{p}=randn(100,1); end baseA_.A=A; eval([ end save(sprintf(
clear all load prova tic parfor w=1:100 indA=sprintf( Aarr=baseA.(indA).A; Boot=[]; for p=1:9 C=randn(100,1).*Aarr{p}; Boot=[Boot; C]; end D{w}=Boot; end toc
gcp; % Opens a parallel pool using your current settings
n = 1000; % Iteration number EigenValues = cell(n,1); % Prepare to store the data Time = zeros(n,1); for ii = 1:n tic EigenValues{ii,1} = eig(magic(1e3)); % Might want to lower the magic if it takes too long Time(ii,1) = toc; % Collect time after each iteration end figure; % Create a plot of results plot(1:n,t) title ylabel xlabel
ngroups = 1000; nrows = 1e6; data = [randi(ngroups,[nrows,1]), randn(nrows,1)]; data(1:5,:) ans = 620 -0.10696 586 -1.1771 625 2.2021 858 0.86064 78 1.7456
ngroups = 1000; nrows = 1e7; data = [randi(ngroups,[nrows,1]), randn(nrows,1)]; % Simple for [out,t] = deal(NaN(ngroups,1)); overall = tic; for ii = 1:ngroups tic idx = data(:,1) == ii; out(ii) = sum(data(idx,2)); t(ii) = toc; end s.OverallFor = toc(overall); s.TimeFor = t; s.OutFor = out; % Parfor try parpool(4); catch, end [out,t] = deal(NaN(ngroups,1)); overall = tic; parfor ii = 1:ngroups tic idx = data(:,1) == ii; out(ii) = sum(data(idx,2)); t(ii) = toc; end s.OverallParfor = toc(overall); s.TimeParfor = t; s.OutParfor = out; % Sliced parfor [out,t] = deal(NaN(ngroups,1)); overall = tic; c = cache2cell(data,data(:,1)); s.TimeDataSlicing = toc(overall); parfor ii = 1:ngroups tic out(ii) = sum(c{ii}(:,2)); t(ii) = toc; end s.OverallParforSliced = toc(overall); s.TimeParforSliced = t; s.OutParforSliced = out; x = 1:ngroups; h = plot(x, s.TimeFor, set(h, title ylabel xlabel legend({sprintf( sprintf( sprintf(
data(1:5,:) ans = 620 -0.10696 586 -1.1771 625 2.2021 858 0.86064 78 1.7456
c(1:5) ans = [ 969x2 double] [ 970x2 double] [ 949x2 double] [ 986x2 double] [1013x2 double]
c{1}(1:5,:) ans = 1 0.58205 1 0.80183 1 -0.73783 1 0.79723 1 1.0414
methods = [None, grid = np.random.rand(4,4) fig, ax = plt.subplots(3,6,figsize=(12,6), subplot_kw={ fig.subplots_adjust(hspace=0.3, wspace=0.05) ax = ax.ravel() for n, interp in enumerate(methods): ax[n].imshow(grid, interpolation=interp) ax[n].set_title(interp)
x = yourXdata; y = yourYdata; labels = { plot(x, y); set(gca,
%% 50% Day T1wSI=[54.17 115]; T2wSI=[53.5 112]; T3wSI=[52.2 110]; T4wSI=[51.2 108]; T1oSI=[50.25 94]; T2oSI=[49.18 92]; T3oSI=[48.2 90]; T4oSI=[46.1 84]; table1=[T1wSI;T2wSI;T3wSI;T4wSI;T1oSI;T2oSI;T3oSI;T4oSI ]; season2012=table1(:,1); season2013=table1(:,2); Tr1=[1 2 3 4]; Treatment1 =[ %Tre1=[ %set(gca, figure(1) set(gca, plot(Tr1,table1(1:4,1), hold on; plot(Tr1,table1(1:4,2), plot(Tr1,table1(5:8,1), plot(Tr1,table1(5:8,2), set(gca, xlim=[1 5]; xlabel( ylabel( legend(
03/09/2013 23:55:12,129.32,129.33 03/09/2013 23:55:52,129.32,129.33 03/09/2013 23:56:02,129.32,129.33
Error using dlmread (line 139) Mismatch between file and format string. Trouble reading number from file (row 1u, field 2u) ==> /09/2013 23:55:12,129.32,129.33\n Error in csvread (line 48) m=dlmread(filename,
fid = fopen( out = textscan(fid, fclose(fid); date = datevec(out{1}); col1 = out{2}; col2 = out{3};
fid = fopen( out = textscan(fid, fclose(fid) [date, col1, col2] = deal(out{:});
dataTable = readtable( dataTable.Properties.VariableNames = { dataTable = 3×3 table date col1 col2 ___________________ ______ ______ 03/09/2013 23:55:12 129.32 129.33 03/09/2013 23:55:52 129.32 129.33 03/09/2013 23:56:02 129.32 129.33
>> a = 0:0.1:1; >> b = linspace(0,1,11); >> a-b ans = 1.0e-016 * Columns 1 through 8 0 0 0 0.5551 0 0 0 0 Columns 9 through 11 0 0 0
%averaging of images im = D{1}(:,:); for i = 2:100 im = imadd(im,D{i}(:,:)); end im = im/100; imshow(im,[]); for i=1:100 SD{i}(:,:)=imsubtract(D{i}(:,:),im(:,:)) end
im = imread( imFiltered = im; % The filtered image will end up here imChanged = false(size(im));% To document the filter performance % 1) % Compute the histgrams for each column in the lower part of the image % (where the columns are most clear) and compute the mean and std each % bin in the histogram. histograms = hist(double(im(501:520,:)),0:255); colMean = mean(histograms,2); colStd = std(histograms,0,2); % 2) % Now loop though each gray level above zero and... for grayLevel = 1:255 % Find the columns where the number of % mean_n_graylevel + 3*std_n_graylevel). - That is columns that contains % statistically lineColumns = find(histograms(grayLevel+1,:)>colMean(grayLevel+1)+3*colStd(grayLevel+1)); % Now remove all graylevel pixels in lineColumns in the original image if(~isempty(lineColumns)) for col = lineColumns imFiltered(:,col) = im(:,col).*uint8(~(im(:,col)==grayLevel)); imChanged(:,col) = im(:,col)==grayLevel; end end end imshow(imChanged) figure,imshow(imFiltered)
% take the mean; convert to double for safety reasons meanImg = mean( double( cat(3,D{:}) ), 3); % then you cans subtract the mean from the original (non-dark-frame) image correctedImage = rawImage - meanImg; %(maybe you need to re-cast the meanImg first)
img = imread( SE = strel( img2 = imdilate(imerode(img,SE),SE); subplot(121), imshow(img) subplot(122), imshow(img2)
for each bad column for each pixel (x, y) on the bad column pixel(x, y) = Average(pixel(x+1,y),pixel(x+1,y-1),pixel(x+1,y+1), pixel(x-1,y),pixel(x-1,y-1),pixel(x-1,y+1))
debug_disp = @(str) disp(str); debug_disp( ... debug_disp = @(str) disp([]); % diagnostics are now hidden
function NOP(varargin) %NOP Do nothing % % NOP( ... ) % % A do-nothing function for use as a placeholder when working with callbacks % or function handles. % Intentionally does nothing
headWidth = 8; headLength = 8; LineLength = 0.08; %some data [x,y] = meshgrid(0:0.2:2,0:0.2:2); u = cos(x).*y; v = sin(x).*y; %quiver plots figure( hax_1 = subplot(1,2,1); hq = quiver(x,y,u,v); %get the handle of quiver title( %get the data from regular quiver U = hq.UData; V = hq.VData; X = hq.XData; Y = hq.YData; %right version (with annotation) hax_2 = subplot(1,2,2); %hold on; for ii = 1:length(X) for ij = 1:length(X) headWidth = 5; ah = annotation( set(ah, set(ah, end end %axis off; title( linkaxes([hax_1 hax_2],
%some data [x,y] = meshgrid(0:0.2:2,0:0.2:2); u = cos(x).*y; v = sin(x).*y; %quiver plots figure( hax_1 = subplot(1,2,1); %left version (regular) hq1 = quiver(x,y,u,v); %get the line position (first handle) hkid = get(hq1, X = get(hkid(1), Y = get(hkid(1), axis off; title( %right version (with annotation) hax_2 = subplot(1,2,2); cmap = jet(116); %colormap, 116 because angles goes up to 115 degrees for ii = 1:3:length(X)-1 headWidth = 200 * sqrt((X(ii+1)-X(ii)).^2 + (Y(ii+1)-Y(ii)).^2); % set the headWidth, function of length of arrow angled = floor(atan2(Y(ii+1)-Y(ii),X(ii+1)-X(ii))*180/pi) + 1; %get the angle ah = annotation( set(ah, set(ah, end axis off; title( linkaxes([hax_1 hax_2],
[x,y] = meshgrid(-2:.2:2,-1:.15:1); z = x .* exp(-x.^2 - y.^2); [px,py] = gradient(z,.2,.15); quiver(x,y,px,py), hold off, axis image
x = linspace(-3,3,50); y = linspace(-5,5,50); [X Y]=meshgrid(x,y); Z = exp(-X.^2-Y.^2/2).*cos(4*X) + exp(-3*((X+0.5).^2+Y.^2/2)); Z(Z>0.001)=0.001; Z(Z<-0.001)=-0.001; surf(X,Y,Z); colormap(flipud(cool)) view([1 -1.5 2])
[x y] = meshgrid( linspace(-3,3,50), linspace(-5,5,50) ); z = exp(-x.^2-0.5*y.^2).*cos(4*x) + exp(-3*((x+0.5).^2+0.5*y.^2)); idx = ( abs(z)>0.001 ); z(idx) = 0.001 * sign(z(idx)); figure( patch(surf2patch(surf(x,y,z)), set(gca, title( view(35,65) colormap( [flipud(cool);cool] ) camlight headlight, lighting phong
>> A = randi([10,60],100,100); >> colormap( >> imagesc(A) >> colorbar
hold on; % make sure no new plot window is created on every plot command axes(); % produce plot window with axes plot(% whatever your plot command is); plot([0 10], [0 0],
x=-3:0.1:3; y = x.^3; plot(x,y), hold on plot([-3 3], [0 0], hold off
figure, plot ((1:10),cos(rand(1,10))-0.75, hold on plot ((1:10),zeros(1,10), text([1:10]-0.09,ones(1,10).*-0.015,[{ set(gca, box off
x = linspace(-2,2,101); plot(x,2*x.^3-3*x+1); axes0
test = int32(2^30); while (test > 0) test = test + int32(1); end
function C = plus(A,B) % % % % if (A > 0) && (B > (intmax-A)) % C = builtin( B-(intmax-A)-1); % elseif (A < 0) && (B < (intmin-A)) % C = builtin( B-(intmin-A-1)); % else C = builtin( end end
>> A = int32(2147483642); % >> for i = 1:10, A = A+1; disp(A); end 2147483643 2147483644 2147483645 2147483646 2147483647 % -2147483648 % -2147483647 -2147483646 -2147483645 -2147483644
/* c_plus.c - MEX function: C-style (not Matlab-style) "+" operation */ void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] ) { mxArray *out; /* In production code, input/output type and bounds checks would go here. */ const mxArray *a = prhs[0]; const mxArray *b = prhs[1]; int i, n; int *a_int32, *b_int32, *out_int32; short *a_int16, *b_int16, *out_int16; mxClassID datatype = mxGetClassID(a); int n_a = mxGetNumberOfElements(a); int n_b = mxGetNumberOfElements(b); int a_is_scalar = n_a == 1; int b_is_scalar = n_b == 1; n = n_a >= n_b ? n_a : n_b; out = mxCreateNumericArray(mxGetNumberOfDimensions(a), mxGetDimensions(a), datatype, mxIsComplex(a)); switch (datatype) { case mxINT32_CLASS: a_int32 = (int*) mxGetData(a); b_int32 = (int*) mxGetData(b); out_int32 = (int*) mxGetData(out); for (i=0; i<n; i++) { if (a_is_scalar) { out_int32[i] = a_int32[i] + b_int32[i]; } else if (b_is_scalar) { out_int32[i] = a_int32[i] + b_int32[0]; } else { out_int32[i] = a_int32[i] + b_int32[i]; } } break; case mxINT16_CLASS: a_int16 = (short*) mxGetData(a); b_int16 = (short*) mxGetData(b); out_int16 = (short*) mxGetData(out); for (i=0; i<n; i++) { if (a_is_scalar) { out_int16[i] = a_int16[0] + b_int16[i]; } else if (b_is_scalar) { out_int16[i] = a_int16[i] + b_int16[0]; } else { out_int16[i] = a_int16[i] + b_int16[i]; } } break; default: mexErrMsgTxt("Unsupported array type"); break; } plhs[0] = out; }
classdef cnumeric properties x % the underlying Matlab numeric array end methods function obj = cnumeric(x) obj.x = x; end function out = plus(a,b) [a,b] = promote(a, b); % for convenience, and to mimic Matlab implicit promotion if ~isequal(class(a.x), class(b.x)) error( end out_x = c_plus(a.x, b.x); out = cnumeric(out_x); end % You % Matlab behavior on, too function out = minus(a,b) [a,b] = promote(a, b); out = cnumeric(a.x - b.x); end function display(obj) fprintf( end function [a,b] = promote(a,b) %PROMOTE Implicit promotion of numeric to cnumeric and doubles to int if isnumeric(a); a = cnumeric(a); end if isnumeric(b); b = cnumeric(b); end if isinteger(a.x) && isa(b.x, b.x = cast(b.x, class(a.x)); end if isinteger(b.x) && isa(a.x, a.x = cast(a.x, class(b.x)); end end end end
>> cnumeric(int32(intmax)) ans = cnumeric: 2147483647 >> cnumeric(int32(intmax)) - 1 ans = cnumeric: 2147483646 >> cnumeric(int32(intmax)) + 1 ans = cnumeric: -2147483648 >> cnumeric(int16(intmax( ans = cnumeric: 32767 >> cnumeric(int16(intmax( ans = cnumeric: -32768
test = int32(2^31-12); for i = 1:24 test = test + int32(1) end
function ret = overflow_sg(arg,bw) % remove possible rounding errors, and prepare returnvalue (if number is inside boundaries, nothing will happen) ret = round(arg); argsize = size(ret); for i = 1:argsize(1) for j = 1:argsize(2) ret(i,j) = flow_sg(ret(i,j),bw); end end end%function %--- function ret = flow_sg(arg,bw) ret = arg; while (ret < (-2^(bw-1))) ret = ret + 2^bw; end % Check for overflows: while (ret > (2^(bw-1)-1)) ret = ret - 2^bw; end end%function
function ret = overflow_sg(arg,bw) mask = int64(0); for i=1:round(bw) mask = bitset(mask,i); end topbit = bitshift(int64(1),round(bw-1)); subfrom = double(bitshift(topbit,1)) ret = bitand( int64(arg) , mask ); i = (ret >= topbit); ret(i) = int64(double(ret(i))-subfrom); if (bw<=32) ret = int32(ret); end end
double(java.lang.Short(hex2dec( <br>ans = 32767 double(java.lang.Short(hex2dec( <br>ans = -32768 double(java.lang.Short(double(intmax( <br>ans = -32768 double(java.lang.Integer(hex2dec( <br>ans = 32768
w = 0; while ( bits > 0 ) bits = bitand( bits, bits-1 ); w = w + 1; end
w=0; for i=1:32 if bitget( val, i ) == 1 w = w + 1; end end
function w=computeWeight( val ) w = val; w = bitand(bitshift(w, -1), uint32(1431655765)) + ... bitand(w, uint32(1431655765)); w = bitand(bitshift(w, -2), uint32(858993459)) + ... bitand(w, uint32(858993459)); w = bitand(bitshift(w, -4), uint32(252645135)) + ... bitand(w, uint32(252645135)); w = bitand(bitshift(w, -8), uint32(16711935)) + ... bitand(w, uint32(16711935)); w = bitand(bitshift(w, -16), uint32(65535)) + ... bitand(w, uint32(65535));
function r = count_bits(n) shifts = [-1, -2, -4, -8, -16]; masks = [1431655765, 858993459, 252645135, 16711935, 65535]; r = n; for i=1:5 r = bitand(bitshift(r, shifts(i)), masks(i)) + ... bitand(r, masks(i)); end
numArray = ...your 4096-by-4096 matrix of uint32 values... w = zeros(4096,4096, for iBit = 1:32, w = w+bitget(numArray,iBit); end
function w = Ham(w) % Input uint32 % Output vector of Ham wts for i=1:32768:length(w) w(i:i+32767)=Ham_seg(w(i:i+32767)); end end % Segmentation gave reduced time by 50% function w=Ham_seg(w) %speed b1=uint32(1431655765); b2=uint32(858993459); b3=uint32(252645135); b7=uint32(63); % working orig binary mask w = bitand(bitshift(w, -1), b1) + bitand(w, b1); w = bitand(bitshift(w, -2), b2) + bitand(w, b2); w =bitand(w+bitshift(w, -4),b3); w =bitand(bitshift(w,-24)+bitshift(w,-16)+bitshift(w,-8)+w,b7); end
function w = Ham(w) % Input uint32 % Output vector of Ham wts b1=uint32(1431655765); % evaluating saves 15% of time 1.30 to 1.1 sec b2=uint32(858993459); b3=uint32(252645135); b4=uint32(16711935); b5=uint32(65535); for i=1:4096:length(w) w(i:i+4095)=Ham_seg(w(i:i+4095),b1,b2,b3,b4,b5); end end % Segmentation reduced time by 50% function w=Ham_seg(w,b1,b2,b3,b4,b5) % Passing variables or could evaluate b1:b5 here w = bitand(bitshift(w, -1), b1) + bitand(w, b1); w = bitand(bitshift(w, -2), b2) + bitand(w, b2); w = bitand(bitshift(w, -4), b3) + bitand(w, b3); w = bitand(bitshift(w, -8), b4) + bitand(w, b4); w = bitand(bitshift(w, -16), b5) + bitand(w, b5); end vt=randi(2^32,[4096*4096,1])-1; % for vt being uint32 the floor function gives unexpected values tic v=num_ones(mod(vt,65536)+1)+num_ones(floor(vt/65536)+1); % 0.85 sec toc % a corrected method is v=num_ones(mod(vt,65536)+1)+num_ones(floor(double(vt)/65536)+1); toc
num_ones=uint8(zeros(intmax( % one time load of array not implemented here tic for i=1:4096*4096 %v=num_ones(rem(i,64)+1)+num_ones(floor(i/64)+1); % 1.24 sec v=num_ones(mod(i,64)+1)+num_ones(floor(i/64)+1); % 1.20 sec end toc tic num_ones=uint8(zeros(65536,1)); for i=0:65535 num_ones(i+1)=length( find( bitget( i, 1:32 ) ) ) ; end toc % 0.43 sec to load % smaller array to initialize % one time load of array tic for i=1:4096*4096 v=num_ones(mod(i,65536)+1)+num_ones(floor(i/65536)+1); % 0.95 sec %v=num_ones(mod(i,65536)+1)+num_ones(bitshift(i,-16)+1); % 16 sec for 4K*1K end toc %vectorized tic num_ones=uint8(zeros(65536,1)); for i=0:65535 num_ones(i+1)=length( find( bitget( i, 1:32 ) ) ) ; end % 0.43 sec toc vt=randi(2^32,[4096*4096,1])-1; tic v=num_ones(mod(vt,65536)+1)+num_ones(floor(vt/65536)+1); % 0.85 sec toc
>> A = int16(fread(fid,count,precision,machineFormat));
function betas=NSS_betas(lambda,data) mats=data.mats2 lambda=lambda; yM=data.y2 nObs=size(yM,1); G= [ones(nObs,1) (1-exp(-mats./lambda(1)))./(mats./lambda(1)) ((1-exp(-mats./lambda(1)))./(mats./lambda(1))-exp(-mats./lambda(1))) ((1-exp(-mats./lambda(2)))./(mats./lambda(2))-exp(-mats./lambda(2)))]; betas=G\yM; r=rcond(G); end
if (~isinf(G)) r=rank(G); r2=rcond(G); r3=min(svd(G)); end
$ matlab -nosplash -nodesktop -nodisplay -r test Warning: No window system found. Java option < M A T L A B (R) > Copyright 1984-2008 The MathWorks, Inc. Version 7.7.0.471 (R2008b) September 17, 2008 To get started, type one of these: helpwin, helpdesk, or demo. For product information, visit www.mathworks.com. ans = 0.8147 0.9134 0.2785 0.9649 0.9058 0.6324 0.5469 0.1576 0.1270 0.0975 0.9575 0.9706
$ matlab -nosplash -nodesktop -nodisplay -r test | tail +10
function test(ppid) outfile = sprintf( fh = fopen(outfile, myvar = rand(3,4); str = evalc( fprintf(fh, fclose(fh);
% matlab -nosplash -nodisplay -r "test($$)" -logfile matlab-log-$$.tmp
-logfile log - Make a copy of any output to the command window in file log. This includes all crash reports.
matlab.exe -nosplash -nodesktop -nojvm -logfile out.log -r sed
-wait - MATLAB is started by a separate starter program which normally launches MATLAB and then immediately quits. Using the -wait option tells the starter program not to quit until MATLAB has terminated. This option is useful when you need to process the the results from MATLAB in a script. The call to MATLAB with this option will block the script from continuing until the results are generated.
a = 6; b.c.d = 7; b.c.e = save f1 f = a; clear a b.c.e = save f2 visdiff(
Opened "f1.mat" with sec2 driver. / Group Location: 1:96 Links: 1 /a Dataset {1/1, 1/1} Attribute: MATLAB_class scalar Type: 6-byte null-terminated ASCII string Data: "double" Location: 1:2576 Links: 1 Storage: 8 logical bytes, 8 allocated bytes, 100.00% utilization Type: native double /b Group Attribute: MATLAB_class scalar Type: 6-byte null-terminated ASCII string Data: "struct" Location: 1:800 Links: 1 /b/c Dataset {5/5, 1/1} Attribute: H5PATH scalar Type: 2-byte null-terminated ASCII string Data: "/b" Attribute: MATLAB_class scalar Type: 4-byte null-terminated ASCII string Data: "char" Attribute: MATLAB_int_decode scalar Type: native int Data: 2 Location: 1:1832 Links: 1 Storage: 10 logical bytes, 10 allocated bytes, 100.00% utilization Type: native unsigned short
/ Group /a Dataset {1, 1} Data: (0,0) 6 /b Group /b/c Dataset {5, 1} Data: (0,0) 104, 101, 108, 108, 111
dataset: </a> and </a> size: [1x1] [1x1] position a a difference ------------------------------------------------------------ [ 0 0 ] 6 7 1 1 differences found attribute: <MATLAB_class of </a>> and <MATLAB_class of </a>> 0 differences found
a = 6; b.c.d = 7; b.c.e = Simulink.saveVars( f = a; clear a b.c.e = Simulink.saveVars( visdiff(
wList=who; for iLoop = 1:numel(wList) eval([ for jLoop = 1:numel(eval([ eval([ end end
clear load f1 myStruct1 = ws2struct; save myStruct1 myStruct1 clear load f2 myStruct2 = ws2struct; save myStruct2 myStruct2 clear load myStruct1 load myStruct2
for i=1:520 for j=1:368 ts = []; for k=1:600 ts = [ts D{k}(i,j)]; %%% kth image pixel i,j --- ts is time series end ts = double(ts); temp = mean(ts); if (temp==0) for l=1:10 filtImag1{l}(i,j)=0; end continue; end ts = ts-temp; ts = ts/temp; N = 5; % filter order W = [0.0 0.10;0.10 0.20;0.20 0.30;0.30 0.40;0.40 0.50;0.50 0.60 ;0.60 0.70;0.70 0.80 ;0.80 0.90;0.90 1.0]; [B,A]=butter(N,0.10, ts_f(1,:) = filter(B,A,ts); N1 = 5; for ind = 2:9 Wn = W(ind,:); [B,A] = butter(N1,Wn); ts_f(ind,:) = filter(B,A,ts); end [B,A]=butter(N,0.90, ts_f(10,:) = filter(B,A,ts); for ind=1:10 %Following Paper Suggestion filtImag1{ind}(i,j) =sum(ts_f(ind,:).^2); end end end for i=1:10 figure,imshow(filtImag1{i}); colorbar end pre_max = max(filtImag1{1}(:)); for i=1:10 new_max = max(filtImag1{i}(:)); if (pre_max<new_max) pre_max=max(filtImag1{i}(:)); end end new_max = pre_max; pre_min = min(filtImag1{1}(:)); for i=1:10 new_min = min(filtImag1{i}(:)); if (pre_min>new_min) pre_min = min(filtImag1{i}(:)); end end new_min = pre_min; %normalize for i=1:10 temp_imag = filtImag1{i}(:,:); x=isnan(temp_imag); temp_imag(x)=0; t_max = max(max(temp_imag)); t_min = min(min(temp_imag)); temp_imag = (double(temp_imag-t_min)).*((double(new_max)-double(new_min))/double(t_max-t_min))+(double(new_min)); %median filter %temp_imag = medfilt2(temp_imag); imag_test2{i}(:,:) = temp_imag; end for i=1:10 figure,imshow(imag_test2{i}); colorbar end for i=1:10 A=imag_test2{i}(:,:); B=A/max(max(A)); B=histeq(A); figure,imshow(B); colorbar imag_test2{i}(:,:)=B; end
img = ( img - min(img(:)) ) ./ ( max(img(:)) - min(img(:)) );
% fnames = dir( fullfile( fnames = {fnames.name}; N = numel(fnames); % Fs = 1; % sz = [209 278]; % T = zeros([sz N], for i=1:N T(:,:,i) = imread( fullfile( end % T = reshape(T, [prod(sz) N]) T = double(T); % % mn = mean(T,1); T = bsxfun(@rdivide, T, mn+(mn==0)); % % numBanks = 10; order = 5; % butterworth filter order fCutoff = linspace(0, Fs/2, numBanks+1) W = [fCutoff(1:end-1) fCutoff(2:end)] ./ (Fs/2); % normalized frequency bands W(1,1) = W(1,1) + 1e-5; % adjust first freq W(end,end) = W(end,end) - 1e-5; % adjust last freq % Tf = cell(numBanks,1); % for i=1:numBanks [b,a] = butter(order, W(i,:)); % Tf{i} = filter(b,a,T); % end clear T % % Tf = cellfun(@(x)sum(x.^2,1), Tf, % Tf = cellfun(@(x)reshape((x-min(x))./range(x),sz), Tf, % for i=1:numBanks subplot(4,3,i), imshow(Tf{i}) title( sprintf( end colormap(gray)
y_vec = zeros(m, num_labels); for i = 1:m y_vec(i, y(i)) = 1; end
y = [1 1 3]; m = length(y); num_labels = max(y); % y_vec = zeros(m,num_labels); % idx = sub2ind(size(y_vec),1:m,y); % y_vec(idx) = 1;
return max(abs(result(:) - expected(:))) < tolerance
return sum( (abs(result(:) - expected(:))) < tolerance )
return norm(result(:) - expected(:)) < rmsTolerance
octave:27> X=rand(3) X = 0.46749 0.41187 0.26832 0.91106 0.63567 0.97302 0.71809 0.55269 0.84742
absTol = 1e-3; % You choose this value to be what you want! relTol = 0.05; % This one too! absError = x(:)-y(:); relError = absError./x(:); relError(~isfinite(relError)) = 0; % Sets Inf and NaN to 0 same = all( (abs(absError) < absTol) & (abs(relError) < relTol) );
function same = tol( x, y ) absTol = 1e-3; relTol = 0.05; errVec = abs( x(:) - y(:) ); same = all( (errVec < absTol) | (errVec./x(:) < relTol) );
which max built-in (C:\Program Files\MATLAB\R2014b\toolbox\matlab\datafun\@logical\max) % logical method
my_function(x) Undefined function or variable Error in my_function (line 2) t = x*y; >> which y y is a variable.
A = [51 228; 51 127; 191 127; 191 228]; B = [152 57; 219 191; 62 240; 92 109]; X = imread( info = imfinfo( T = cp2tform(A,B,
H = T.tdata.T; > [51 228 1]*H ans = -248.2186 -93.0820 -1.6330 > [51 228 1]*H/ -1.6330 ans = 152.0016 57.0006 1.0000
% initial control points A = [51 228; 51 127; 191 127; 191 228]; B = [152 57; 219 191; 62 240; 92 109]; A = circshift(A, [-1 0]); % fix the order of points to match the picture % input image %I = imread( I = im2uint8(checkerboard(32,5,7)); [h,w,~] = size(I); % adapt control points to image size % (basically we estimate an affine transform from 3 corner points) aff = cp2tform(A(1:3,:), [1 1; w 1; w h], A = tformfwd(aff, A); B = tformfwd(aff, B); % estimate homography between A and B T = cp2tform(B, A, T = fliptform(T); H = T.tdata.Tinv
>> H H = -0.3268 0.6419 -0.0015 -0.4871 0.4667 0.0009 324.0851 -221.0565 1.0000
% check by transforming A points into B %{ BB = [A ones(size(A,1),1)] * H; % convert to homogeneous coords BB = bsxfun(@rdivide, BB, BB(:,end)); % convert from homogeneous coords %} BB = tformfwd(T, A(:,1), A(:,2)); fprintf( % visually check by plotting control points and transformed A figure(1) subplot(121) plot(A([1:end 1],1), A([1:end 1],2), line(BB([1:end 1],1), BB([1:end 1],2), text(A(:,1), A(:,2), num2str((1:4) title( subplot(122) plot(B([1:end 1],1), B([1:end 1],2), text(B(:,1), B(:,2), num2str((1:4) title(
% transform input image and show result J = imtransform(I, T); figure(2) subplot(121), imshow(I), title( subplot(122), imshow(J), title(
[U,V] = tformfwd(T, A(:,1), A(:,2)); Z = imtransform(X,T,
points = rand(100,3); plot3(points(:,1),points(:,2),points(:,3), grid on set(gca, saveas(gcf, saveas(gcf, print(gcf,
function [things] = myfunc(data) [stuff] = mysubfunc(data) things = mean(stuff); end
function things = myfunc(data) if nargin == 0 % If data is not specified... things = {@mysubfunc @myothersubfunc}; % Return a cell array of % function handles return % Return from the function end % The normal processing for myfunc... stuff = mysubfunc(data); things = mean(stuff); end function mysubfunc % One subfunction end function myothersubfunc % Another subfunction end
function [things] = myfunc(data) global TESTING if TESTING == 1 unittests() else [stuff] = mysubfunc(data); things = mean(stuff); end end function unittests() %%Test one tdata = 1; assert(mysubfunc(tdata) == 3) end function [stuff] = mysubfunc(data) stuff = data + 1; end
>> global TESTING; TESTING = 1; myfunc(1) ??? Error using ==> myfunc>unittests at 19 Assertion failed. Error in ==> myfunc at 6 unittests() >> TESTING = 0; myfunc(1) ans = 2 >>
function varargout=foo(varargin) if nargin > 1 && ischar(varargin{1}) && ~strncmp( varargin{1}, if nargout > 0 varargout = feval( varargin{:} ); else feval = ( varargout{:} ); else init(); end
classdef fooUtil methods (Static) function [things] = myfunc(data) [stuff] = mysubfunc(data); things = mean(stuff); end function out = getLocalFunctionHandlesForTesting() onlyAllowThisInsideUnitTest(); out.mysubfunc = @mysubfunc; out.sub2 = @sub2; end end end % Functions local to the class function out = mysubfunc(x) out = x .* 2; % example dummy logic end function sub2() % ... end function onlyAllowThisInsideUnitTest() %ONLYALLOWTHISINSIDEUNITTEST Make sure prod code does not depend on this encapsulation-breaking feature isUnitTestRunning = true; % This should actually be some call to xUnit to find out if a test is active assert(isUnitTestRunning, end
classdef fooUtil methods (Static) function [things] = myfunc(data) [stuff] = fooUtil.mysubfunc(data); things = mean(stuff); end function out = mysubfunc(x) out = x .* 2; % example dummy logic end function sub2() % ... end end end
>> C1 = {[1 2 3], [4 5 6]}; >> [C2, index] = cellfun(@(x) unique(x), C1, C2 = 1×2 cell array [1×3 double] [1×3 double] index = 1×2 cell array [3×1 double] [3×1 double]
>> [C2, index] = cellfun(@(x) {unique(x)}, C1) Output argument "varargout{2}" (and maybe others) not assigned during call to "@(x){unique(x)}".
>> C1 = {[1 2 3], [4 5 6]}; >> cellfun(@(x) disp(x), C1, 1 2 3 4 5 6 >> cellfun(@(x) {disp(x)}, C1); Error using disp Too many output arguments. Error in @(x){disp(x)}
classdef (Abstract) Shape < handle methods (Abstract) Draw(obj); end end
classdef Circle < Shape methods function obj = Draw(obj) disp( end end end
classdef Rectangle < Shape methods function obj = Draw(obj) disp( end end end
shapes = Shape.empty(); myrect = Rectangle(); mycirc = Circle(); shapes(end + 1) = myrect; shapes(end + 1) = mycirc; for i = 1:size(shapes,1) shapes(i).Draw(); end
Error using Shape.empty Abstract classes cannot be instantiated. Class and/or properties. Error in test (line 1) shapes = Shape.empty();
classdef (Abstract) Shape < handle & matlab.mixin.Heterogeneous
>> shapes shapes = 1x2 heterogeneous Shape (Rectangle, Circle) array with no properties. >> shapes(1) ans = Rectangle with no properties. >> shapes(2) ans = Circle with no properties.
methods (Static, Sealed, Access = protected) function default_object = getDefaultScalarElement default_object = Circle; end end
>> clear r >> r(2) = Rectangle r = 1x2 heterogeneous Shape (Circle, Rectangle) array with no properties. >> r(1) ans = Circle with no properties. >> r(2) ans = Rectangle with no properties.
abstract class — A class that cannot be instantiated, but that defines class components used by subclasses.
>> objects(1) = Foo(); >> objects(2) = FooBar(); The following error occurred converting from FooBar to Foo: Error using Foo Too many input arguments. >> FooBar ans = FooBar handle with no properties. Methods, Events, Superclasses Superclasses for class FooBar: Foo handle
3.65E+06 -2.09E+06 0 YY = -2.09E+06 2.45E+06 0 0 0 0 [U,S,V] = svd(YY); -0.798728902689475 0.601691066917623 0 V = 0.601691066917623 0.798728902689475 0 0 0 1 cv::SVD::compute(YY, S, U, V); 0.798839 -0.601544 0 V = 0.601544 0.798839 0 0 0 1
img = imread( x = [10 240]; % x coordinates y = [10 120]; % y coordinates nPoints = max(abs(diff(x)), abs(diff(y)))+1; % Number of points in line rIndex = round(linspace(y(1), y(2), nPoints)); % Row indices cIndex = round(linspace(x(1), x(2), nPoints)); % Column indices index = sub2ind(size(img), rIndex, cIndex); % Linear indices img(index) = 255; % Set the line points to white imshow(img); % Display the image
% distances according to both axes xn = abs(x2-x1); yn = abs(y2-y1); % interpolate against axis with greater distance between points; % this guarantees statement in the under the first point! if (xn > yn) xc = x1 : sign(x2-x1) : x2; yc = round( interp1([x1 x2], [y1 y2], xc, else yc = y1 : sign(y2-y1) : y2; xc = round( interp1([y1 y2], [x1 x2], yc, end % 2-D indexes of line are saved in (xc, yc), and % 1-D indexes are calculated here: ind = sub2ind( size(img), yc, xc ); % draw line on the image (change value of img(ind) = 255;
function img = drawLine(img, x1, y1, x2, y2) x1=int16(x1); x2=int16(x2); y1=int16(y1); y2=int16(y2); % distances according to both axes xn = double(x2-x1); yn = double(y2-y1); % interpolate against axis with greater distance between points; % this guarantees statement in the under the first point! if (abs(xn) > abs(yn)) xc = x1 : sign(xn) : x2; if yn==0 yc = y1+zeros(1, abs(xn)+1, else yc = int16(double(y1):abs(yn/xn)*sign(yn):double(y2)); end else yc = y1 : sign(yn) : y2; if xn==0 xc = x1+zeros(1, abs(yn)+1, else xc = int16(double(x1):abs(xn/yn)*sign(xn):double(x2)); end end % 2-D indexes of line are saved in (xc, yc), and % 1-D indexes are calculated here: ind = sub2ind(size(img), yc, xc); % draw line on the image (change value of img(ind) = 255; end
classdef myHandle < handle properties data moreData end methods end end
>> x = myHandle x = myHandle handle Properties: data: [] moreData: [] Methods, Events, Superclasses
>> y.data = [33 44 55 66]; >> disp(x) x = myHandle handle Properties: data: [33 44 55 66] moreData: Methods, Events, Superclasses
execute execute noremap <C-CR> :?%%?;/%%/w !matlab -nojvm
function! MatRun() let @+="run(\ let @*="run(\ :call system( !wmctrl -a MAT endfunction map <F5> :call MatRun() <cr><cr>
function! MatRun() normal mm " mark current cursor in mark m" let @+="cd( call system( call system( normal `m "go back to cursor location" !wmctrl -a MATLAB endfunction map ,m :call MatRun() <cr><cr>
function! MatRunCell() normal mm "remember cursor" :?%%\|\%^?;/%%\|\%$/w !xclip -selection c "pipe the cell to xclip" normal `m "go back to cursor location" !wmctrl -a MATLAB "go to matlab window" endfunction map ,k :call MatRunCell() <cr><cr>
function! MatRunCellAdvanced() execute "!echo \"cd(\ normal mm :?%%\|\%^?;/%%\|\%$/w>> /tmp/buff execute "!echo \"edit ".expand("%:f")."\">>/tmp/buff" !cat /tmp/buff|xclip -selection c !cat /tmp/buff|xclip normal `m !wmctrl -a MATLAB endfunction map ,n :call MatRunCellAdvanced() <cr><cr>
function! MatRunLine() " write current line and pipe to xclip " :.w !xclip -selection c !wmctrl -a MATLAB endfunction map ,l :call MatRunLine() <cr><cr>
function! MatRunSelect() normal mm !rm -f /tmp/buff :redir > /tmp/buff :echo @* :redir END execute "!echo \" \">>/tmp/buff" execute "!echo \"edit ".expand("%:p")."\">>/tmp/buff" !cat /tmp/buff|xclip -selection c normal `m !wmctrl -a MATLAB endfunction
highlight MATCELL cterm=bold term=bold gui=bold match MATCELL /%%.*$/
^l:: ; execute line or current selection in Matlab IfWinActive, ahk_class Vim { ; CTRL-E is mapped to a Vim shortcut to yank the text you want Send, ^e WinActivate, ahk_class SunAwtFrame Send, ^0^v{Enter} WinActivate, ahk_class ahk_class Vim } else if WinActive, ahk_class SunAwtFrame { Send, ^0^v{Enter} } Return
(className):(parentFunction):functionWhereErrorOccurs:descriptiveMnemonic
classdef myclassexample properties data end methods function obj = procData(obj) if numel(obj)>1 for i = 1:numel(obj) obj(i) = obj(i).procData; end return end %do some processing obj.data = abs(obj.data); end end end
A = myclassexample; A(1).data= - -1; A(2).data = -2;
>> A = MyClass; >> A.procData.data % or A.procData().data ans = [] >> procData(A).data Undefined variable "procData" or class "procData".
>> B = procData(A): % or: B = A.pocData; >> [B.data]
% a function that works on structure scalar/arrays function s = procStruct(s) if numel(s) > 1 for i=1:numel(s) s(i) = procStruct(s(i)); end else s.data = abs(s.data); end end
% 1x2 struct array >> s = struct( >> procStruct(s).data Undefined variable "procStruct" or class "procStruct". >> procStruct(s([1 2])).data Undefined variable "procStruct" or class "procStruct". >> feval( Undefined variable "feval" or class "feval". >> f=@procStruct; f(s([1 2])).data Improper index matrix reference.
function x = f(n) if nargin == 0, n=3; end x = magic(n); end
>> [mx,idx] = max(magic(3)) mx = 8 9 7 idx = 1 3 2 >> [mx,idx] = max(magic(3))(4) % now what?
>> A = [1 2 3 4 5]; >> B = [1 2 3 4 5]; >> A == B ans = 1 1 1 1 1
>> if ( abs( (.1+.1+.1) - .3 ) < 1e-10 ); disp( Values are pretty close although not necessarily bit equal >>
function out=mtest() out = ones(1e3,1e3,1e3); % Caution, 8Gb out=permute(out,[3 1 2]); end
function out = mtest() out = rand([1e3,5e2,5e2]); % about 1.8 GB = 1e3*5e2*5e2*8/2^30 out = permute(out, [3 2 1]); end
permute(..., [4 2 3 1]) % permute(..., [1 4 3 2]) % permute(..., [1 2 4 3]) %
M = [1007 1007 4044 1007 4044 1007 5002 5002 5002 622 622; 552 552 300 552 300 552 431 431 431 124 124; 2010 2010 1113 2010 1113 2010 1100 1100 1100 88 88; 7 12 25 15 12 30 2 10 55 32 12];
A = [1007 4044 5002 622; 552 300 431 124; 2010 1113 1100 88];
X = {[2 5 68 44],[2 10 55 9 17],[1 55 6 7 8 9],[32 12]}; [~, ~, subs] = unique(M(1:3,:) A4 = accumarray(subs(:),M(4,:). % idxC(length(A4)) = false; for ii = 1:length(A4) idxC(ii) = ~any(cellfun(@(x) all(ismember(A4{ii},x)), X)); end
M = [1007 4044 1007 4044 1007 5002 5002 5002 622 622 1007 1007 1007; 552 300 552 300 552 431 431 431 124 124 552 11 11; 2010 1113 2010 1113 2010 1100 1100 1100 88 88 2010 20 20; 12 25 15 12 30 2 10 55 32 12 7 12 7]; X = {[2 5 68 44],[2 10 55 9 17],[1 55 6 7 8 9],[32 12]}; A = [1007 4044 5002 622 1077; 552 300 431 124 11; 2010 1113 1100 88 20];
%row vector for i = 1:3 disp( end foo foo foo %column vector for i = (1:3).' disp( end foo
[C, ~, subs] = unique(M(1:3,:) %% rather than [~, ~, subs] = unique(M(1:3,:)
>> out = C(idxC,:).' out = 1007 4044 552 300 2010 1113
idxC = true(size(A4)); NX = numel(X); for ii = 1:length(A4) for jj = 1:NX xj = X{jj}; issubset = true; for A4i=A4{ii} if ~ismember(A4i, xj) issubset = false; break; end; end; if issubset idxC(ii) = false; break; end; end; end;
function out = shot1_func(M,X) % [unqrows, ~, subs_idx] = unique(M(1:3,:) unqcols = unqrows. counts = accumarray(subs_idx(:),1); % % X1 = cellfun(@(x) subs_idx(ismember(M(4,:),x)),X, lensX = cellfun( Xn = vertcat(X1{:}); % N = max(subs_idx); % % sums = cumsum(bsxfun(@eq,Xn,1:N),1); cumsums_at_shifts = sums(cumsum(lensX),:); mask1 = any(bsxfun(@eq,diff(cumsums_at_shifts,[],1),counts(:). decision_mask = mask1 | cumsums_at_shifts(1,:) == counts(:). out = unqcols(:,~decision_mask); return
% [unqrows, ~, subs_idx] = unique(M(1:3,:) unqcols = unqrows. counts = accumarray(subs_idx,1); % lX = cellfun( X_id = zeros(1,sum(lX)) X_id([1 cumsum(lX(1:end-1)) + 1]) = 1 X_id = cumsum(X_id) Xr = cellfun(@(x) x(:). X1 = [Xr{:}] % % [valid,idx1] = ismember(M(4,:),X1) p1v = ~ismember(1:max(X_id),unique(X_id(accumarray(idx1(valid). X_part1 = Xr(p1v) X_part2 = Xr(~p1v) % N = size(unqcols,2); dm1 = first_pass(X_part1,M(4,:),subs_idx,counts,N) dm2 = second_pass(X_part2,M(4,:),subs_idx,counts) out = unqcols(:,~dm1 & ~dm2)
function decision_mask = first_pass(X,M4,subs_idx,counts,N) lensX = cellfun( X1 = [X{:}]; % % vals = changem(X1,subs_idx,M4) .* ismember(X1,M4); sums = cumsum(bsxfun(@eq,vals(:),1:N),1); cumsums_at_shifts = sums(cumsum(lensX),:); mask1 = any(bsxfun(@eq,diff(cumsums_at_shifts,[],1),counts(:). decision_mask = mask1 | cumsums_at_shifts(1,:) == counts(:). return function decision_mask = second_pass(X,M4,subs_idx,counts) % X1 = cellfun(@(x) subs_idx(ismember(M4,x)),X, lensX = cellfun( Xn = vertcat(X1{:}); % N = max(subs_idx); % % sums = cumsum(bsxfun(@eq,Xn,1:N),1); cumsums_at_shifts = sums(cumsum(lensX),:); mask1 = any(bsxfun(@eq,diff(cumsums_at_shifts,[],1),counts(:). decision_mask = mask1 | cumsums_at_shifts(1,:) == counts(:). return
% load( X = cellfun(@(x) unique(x). out = shot1_func(M,X); % % [unqrows, ~, subs] = unique(M(1:3,:) unqcols = unqrows. M4 = accumarray(subs(:),M(4,:). M4 = cellfun(@(x) unique(x),M4, % [unqcols_idx,~] = find(pdist2(unqcols. % for ii = 1:numel(unqcols_idx) for jj = 1:numel(X) if all(ismember(M4{unqcols_idx(ii)},X{jj})) error( end end end disp(
idxC = cellfun(@(a) ~any(cellfun(@(x) all(ismember(a,x)), X)), A4, idxC = cell2mat(idxC); out = A(:,idxC)
dmap = zeros(height, width); % height, width: scalar with default value = 32 for ii = 0: height - 1 % 32 iterations of this loop yi = limits(3) + ii * deltay + deltay/2; % limits(3) & deltay: scalars for jj = 0 : width - 1 % 32 iterations of this loop xi = limits(1) + jj * deltax + deltax/2; % limits(1) & deltax: scalars dd = 0; for kk = 1: length(x) % up to 500,000 iterations in this loop dist2 = (x(kk) - xi)^2 + (y(kk) - yi)^2; dd = dd + 1 / ( dist2 + fudge); % fudge is a scalar end dmap(ii+1,jj+1) = dd; end end
dmap = zeros(height, width); for ii = 0: height - 1 yi = limits(3) + ii * deltay + deltay/2; for jj = 0 : width - 1 xi = limits(1) + jj * deltax + deltax/2; dist2 = (x - xi) .^ 2 + (y - yi) .^ 2; dmap(ii + 1, jj + 1) = sum(1 ./ (dist2 + fudge)); end end
yi = limits(3) + deltay * ( 1:height ) - .5 * deltay; xi = limits(1) + deltax * ( 1:width ) - .5 * deltax; dx = bsxfun( @minus, x(:), xi ) .^ 2; dy = bsxfun( @minus, y(:), yi ) .^ 2; dist2 = bsxfun( @plus, permute( dy, [2 3 1] ), permute( dx, [3 2 1] ) ); dmap = sum( 1./(dist2 + fudge ) , 3 );
blockSize = 50000; % process up to XX elements at once dmap = 0; yi = limits(3) + deltay * ( 1:height ) - .5 * deltay; xi = limits(1) + deltax * ( 1:width ) - .5 * deltax; bi = 1; while bi <= numel(x) % take a block of x and y bx = x( bi:min(end, bi + blockSize - 1) ); by = y( bi:min(end, bi + blockSize - 1) ); dx = bsxfun( @minus, bx(:), xi ) .^ 2; dy = bsxfun( @minus, by(:), yi ) .^ 2; dist2 = bsxfun( @plus, permute( dy, [2 3 1] ), permute( dx, [3 2 1] ) ); dmap = dmap + sum( 1./(dist2 + fudge ) , 3 ); bi = bi + blockSize; end
dmap = zeros(height, width); yi = limits(3) + deltay*(1:height) - .5*deltay; matlabpool 8 parfor ii = 1: height for jj = 1: width xi = limits(1) + (jj-1) * deltax + deltax/2; dist2 = (x - xi) .^ 2 + (y - yi(ii)) .^ 2; dmap(ii, jj) = sum(1 ./ (dist2 + fudge)); end end matlabpool close
N = 500000; data = [randn(N,2); rand(N,1)+3.5, randn(N,1);]; % 2 overlaid distrib tic; [bandwidth,density,X,Y] = kde2d(data); toc; imagesc(density);
Out of Windows Resources: Allocation of bitmap failed. Disabling backingstore for current figure.
h1 = plot([1 1],[0 1], hold on; h2 = plot([1 1],[0 1], hVector = [h1 h2]; % set(hVector,
function motionFcn(hMoving) % hOther = get(hMoving, set(hOther, end
draggable(h1,@motionFcn); draggable(h2,@motionFcn);
currentEditor = matlab.desktop.editor.getActive; originalSelection = currentEditor.Selection; assert(originalSelection(1)==originalSelection(3)); currentEditor.Selection = [originalSelection(1) 1 originalSelection(1) Inf]; disp(currentEditor.SelectedText); eval(currentEditor.SelectedText); currentEditor.Selection = originalSelection + [1 0 1 0];
currentEditor = matlab.desktop.editor.getActive; originalSelection = currentEditor.Selection; currentEditor.Selection = [originalSelection(1) 1 originalSelection(3) Inf]; disp(currentEditor.SelectedText); eval(currentEditor.SelectedText); currentEditor.Selection = [originalSelection(3),0,originalSelection(3),0]+[1,0,0,0];
>> loglog(2.^[1:20]*1e10,(2.^[1:20]).^2) >> axis equal
loglog(2.^[1:20]*1e10,(2.^[1:20]).^2); % xLimits = [1e10 1e16]; % yLimits = [1 1e12]; % logScale = diff(yLimits)/diff(xLimits); % powerScale = diff(log10(yLimits))/... % diff(log10(xLimits)); set(gca, set(gca,
function decades_equal(hAxes,xLimits,yLimits) if (nargin < 2) || isempty(xLimits) xLimits = get(hAxes, end if (nargin < 3) || isempty(yLimits) yLimits = get(hAxes, end logScale = diff(yLimits)/diff(xLimits); powerScale = diff(log10(yLimits))/diff(log10(xLimits)); set(hAxes, end
loglog(2.^[1:20]*1e10,(2.^[1:20]).^2); % decades_equal(gca); %
yDecade = diff(yLimits)/diff(log10(yLimits)); % xDecade = diff(xLimits)/diff(log10(xLimits)); % set(gca,
% Figure handles.figure_window = figure(... % Buttons handles.tab_panel = uibuttongroup(... handles.tab_a = uicontrol(... handles.tab_b = uicontrol(... % Panel A handles.panel_a = uipanel(... handles.panel_a_text = uicontrol(... % Panel B handles.panel_b = uipanel(... handles.panel_b_text = uicontrol(... guidata(handles.figure_window, handles);
function tab_example_callback(hObject,eventdata,handles) switch get(get(hObject, case case end guidata(handles.figure_window, handles); end
function test(N) % N is the number of tabs if nargin == 0 N = 3; end % Figure handles.figure_window = figure(... % Buttons handles.tab_panel = uibuttongroup(... alpha = for i_tab=1:N % button handles.tabs(i_tab) = uicontrol(... % Panel i handles.panels(i_tab) = uipanel(... handles.panel_a_text = uicontrol(... end % set callback for all buttons set(handles.tabs, % choose tab 1 as active set(handles.panels(1), guidata(handles.figure_window, handles); function tab_example_callback(hObject,eventdata,handles) % set everything invisible set(handles.panels, % turn on selected panel set(handles.panels(handles.tabs == hObject), guidata(handles.figure_window, handles);
function [outputs] = myFunction(input1, input2) isPublishing = (nargin == 1) && strcmp(input1, if (nargin == 0) || isPublishing % Set up default values input1 = input2 = end ... end
%% Controlling what code gets published % Here %% Showing results without code % If you set the % <https: % *Include code* option> to |false|, you will see the plot but not the code % that made it: surf(peaks); % I %% But what if you want some of the code to show? % The *Include code* setting affects the whole document, so all evaluated % code will be hidden. If you want some code to show, you can use % <https: % syntax highlighted sample code>. This does mean you have to have duplicate % sections of code (one is evaluated, one is displayed), but it % option thus far: %% % % surf(peaks); % surf(peaks); % You can
mex CC="gcc" CFLAGS="\$CFLAGS -msse -msse2 -msse3 -ffast-math -ftree-vectorize" LDFLAGS="\$LDFLAGS -msse2 -msse3 -ffast-math -ftree-vectorize" -I/usr/local/include -L/usr/local/lib -lsundials_cvode -lsundials_nvecserial -v -o kry_new.mexmaci64 mex_main.c
kry_new(param,init,0:60:240,abstol,rtol,1) ??? Invalid MEX-file dlopen(/Users/Andrew/Documents/MATLAB/het_optim/kry_new.mexmaci64, 1): Library not loaded: /usr/local/lib/libsundials_cvode.1.dylib Referenced from: /Users/Andrew/Documents/MATLAB/het_optim/kry_new.mexmaci64 Reason: Incompatible library version: kry_new.mexmaci64 requires version 2.0.0 or later, but libsundials_cvode.1.dylib provides version 1.0.0.
$ otool -L kry_new.mexmaci64 kry_new.mexmaci64: /usr/local/lib/libsundials_cvode.1.dylib (compatibility version 2.0.0, current version 2.0.0) @loader_path/libsundials_nvecserial.0.0.2.dylib (compatibility version 0.0.0, current version 0.0.2) @loader_path/libmx.dylib (compatibility version 0.0.0, current version 0.0.0) @loader_path/libmex.dylib (compatibility version 0.0.0, current version 0.0.0) @loader_path/libmat.dylib (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libstdc++.6.dylib (compatibility version 7.0.0, current version 7.4.0) /usr/lib/libgcc_s.1.dylib (compatibility version 1.0.0, current version 1.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 111.1.4)
sudo mv libsundials_cvode.1.0.0.dylib libsundials_cvode.2.0.0.dylib
w125-244:sundials-2.4.0 stevemoss$ ls -al /usr/local/lib/libsundials_cvode* -rwxr-xr-x 1 root staff 4136 28 Apr 16:07 /usr/local/lib/libsundials_cvode.1.0.0.dylib lrwxr-xr-x 1 root staff 29 28 Apr 16:07 /usr/local/lib/libsundials_cvode.1.dylib -> libsundials_cvode.1.0.0.dylib -rw-r--r-- 1 root staff 512704 28 Apr 16:07 /usr/local/lib/libsundials_cvode.a lrwxr-xr-x 1 root staff 29 28 Apr 16:07 /usr/local/lib/libsundials_cvode.dylib -> libsundials_cvode.1.0.0.dylib -rwxr-xr-x 1 root staff 878 28 Apr 16:07 /usr/local/lib/libsundials_cvode.la -rwxr-xr-x 1 root staff 4136 28 Apr 16:07 /usr/local/lib/libsundials_cvodes.2.0.0.dylib lrwxr-xr-x 1 root staff 30 28 Apr 16:07 /usr/local/lib/libsundials_cvodes.2.dylib -> libsundials_cvodes.2.0.0.dylib -rw-r--r-- 1 root staff 926048 28 Apr 16:07 /usr/local/lib/libsundials_cvodes.a lrwxr-xr-x 1 root staff 30 28 Apr 16:07 /usr/local/lib/libsundials_cvodes.dylib -> libsundials_cvodes.2.0.0.dylib -rwxr-xr-x 1 root staff 885 28 Apr 16:07 /usr/local/lib/libsundials_cvodes.la
w125-244:sundials-2.4.0 stevemoss$ otool -L /usr/local/lib/libsundials_cvode.dylib /usr/local/lib/libsundials_cvode.dylib: /usr/local/lib/libsundials_cvode.1.dylib (compatibility version 2.0.0, current version 2.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 125.2.10)
x = rand(10, 3); plot3(x(:, 1), x(:, 2), x(:, 3), for ii = 1:360 camorbit(1, 10*cos(ii/90*pi)*pi/45) drawnow pause(0.01) end
ax = axes; x = rand(9, 3); plot3(ax,x(:, 1), x(:, 2), x(:, 3), % Hide rulers and background color ax.Color = [1 1 1 0]; ax.XAxis.Visible = ax.YAxis.Visible = ax.ZAxis.Visible =
=========================================================================== imageDim = 30; % image dimension imageChannels = 3; % number of channels (rgb, so 3) patchDim = 10; % patch dimension numPatches = 100000; % number of patches visibleSize = patchDim * patchDim * imageChannels; % number of input units outputSize = visibleSize; % number of output units hiddenSize = 400; % number of hidden units epsilon = 0.1; % epsilon for ZCA whitening poolDim = 10; % dimension of pooling region optTheta = zeros(2*hiddenSize*visibleSize+hiddenSize+visibleSize, 1); ZCAWhite = zeros(visibleSize, visibleSize); meanPatch = zeros(visibleSize, 1); load patches_16_1 =========================================================================== % Display and check to see that the features look good W = reshape(optTheta(1:visibleSize * hiddenSize), hiddenSize, visibleSize); b = optTheta(2*hiddenSize*visibleSize+1:2*hiddenSize*visibleSize+hiddenSize); displayColorNetwork( (W*ZCAWhite)); stepSize = 100; assert(mod(hiddenSize, stepSize) == 0, stepSize should divide hiddenSize); load train.mat % loads numTrainImages, trainImages, trainLabels load train.mat % loads numTestImages, testImages, testLabels % size 30x30x3x8862 numTestImages = 8862; numTrainImages = 8862; pooledFeaturesTrain = zeros(hiddenSize, numTrainImages, floor((imageDim - patchDim + 1) / poolDim), floor((imageDim - patchDim + 1) / poolDim) ); pooledFeaturesTest = zeros(hiddenSize, numTestImages, ... floor((imageDim - patchDim + 1) / poolDim), ... floor((imageDim - patchDim + 1) / poolDim) ); tic(); testImages = trainImages; for convPart = 1:(hiddenSize / stepSize) featureStart = (convPart - 1) * stepSize + 1; featureEnd = convPart * stepSize; fprintf( Wt = W(featureStart:featureEnd, :); bt = b(featureStart:featureEnd); fprintf( convolvedFeaturesThis = cnnConvolve(patchDim, stepSize, ... trainImages, Wt, bt, ZCAWhite, meanPatch); pooledFeaturesThis = cnnPool(poolDim, convolvedFeaturesThis); pooledFeaturesTrain(featureStart:featureEnd, :, :, :) = pooledFeaturesThis; toc(); clear convolvedFeaturesThis pooledFeaturesThis; fprintf( convolvedFeaturesThis = cnnConvolve(patchDim, stepSize, ... testImages, Wt, bt, ZCAWhite, meanPatch); pooledFeaturesThis = cnnPool(poolDim, convolvedFeaturesThis); pooledFeaturesTest(featureStart:featureEnd, :, :, :) = pooledFeaturesThis; toc(); clear convolvedFeaturesThis pooledFeaturesThis; end
pooledFeaturesTrain = zeros(hiddenSize, numTrainImages, floor((imageDim - patchDim + 1) / poolDim), floor((imageDim - patchDim + 1) / poolDim) );
pooledFeaturesTrain(featureStart:featureEnd, :, :, :) = pooledFeaturesThis;
pooledFeaturesTrain{n}(:, :, :) = pooledFeaturesThis;
M = randi(100, [3 4]); % ind = reshape(1:numel(M), size(M)); % ind = fliplr( spdiags( fliplr(ind) ) ); % ind(:,1:2:end) = flipud( ind(:,1:2:end) ); % ind(ind==0) = []; % M(ind) %
» M M = 17 35 26 96 12 59 51 55 50 23 70 14 96 76 90 15 » M(ind) ans = 17 35 12 50 59 26 96 51 23 96 76 70 55 14 90 15
M = 69 9 16 100 75 23 83 8 46 92 54 45 ans = 69 9 75 46 23 16 100 83 92 54 8 45
X = randn(500,2000); % [r, c] = size(X); M = bsxfun(@plus, (1:r). M = M + bsxfun(@times, (1:r). [~, ind] = sort(M(:)); y = X(ind).
% function y = zigzag_Amro(M) ind = reshape(1:numel(M), size(M)); ind = fliplr( spdiags( fliplr(ind) ) ); ind(:,1:2:end) = flipud( ind(:,1:2:end) ); ind(ind==0) = []; y = M(ind); % function y = zigzag_Luis(X) [r, c] = size(X); M = bsxfun(@plus, (1:r). M = M + bsxfun(@times, (1:r). [~, ind] = sort(M(:)); y = X(ind). % S = [10 30 100 300 1000 3000]; % f = [1 1]; % % % t_Amro = NaN(size(S)); t_Luis = NaN(size(S)); for n = 1:numel(S) X = rand(f(1)*S(n), f(2)*S(n)); f_Amro = @() zigzag_Amro(X); f_Luis = @() zigzag_Luis(X); t_Amro(n) = timeit(f_Amro); t_Luis(n) = timeit(f_Luis); end loglog(S.^2*prod(f), t_Amro, hold on loglog(S.^2*prod(f), t_Luis, xlabel( ylabel(
function [M,index] = zig_zag(M) [r,c] = size(M); checker = rem(hankel(1:r,r-1+(1:c)),2); [rEven,cEven] = find(checker); [cOdd,rOdd] = find(~checker. rTotal = [rEven; rOdd]; cTotal = [cEven; cOdd]; [junk,sortIndex] = sort(rTotal+cTotal); rSort = rTotal(sortIndex); cSort = cTotal(sortIndex); index = sub2ind([r c],rSort,cSort); M = M(index); end
>> M = [magic(4) zeros(4,1)]; M = 16 2 3 13 0 5 11 10 8 0 9 7 6 12 0 4 14 15 1 0 >> newM = zig_zag(M) % newM = 16 2 5 9 11 3 13 10 7 4 14 6 8 0 0 12 15 1 0 0
% for a 3x3 array n=3; numElementsPerDiagonal = [1:n,n-1:-1:1]; hadaRC = cumsum([0,numElementsPerDiagonal(1:end-1)]); array2add = fliplr(hankel(hadaRC(1:n),hadaRC(end-n+1:n))); % loop through the hankel array and add numbers counting either up or down % if they are even or odd for d = 1:(2*n-1) if floor(d/2)==d/2 % even, count down array2add = array2add + diag(1:numElementsPerDiagonal(d),d-n); else % odd, count up array2add = array2add + diag(numElementsPerDiagonal(d):-1:1,d-n); end end % now flip to get the result indexMatrix = fliplr(array2add) result = 1 2 6 3 5 7 4 8 9
indexMatrixT = indexMatrix [dummy,sortedIdx] = sort(indexMatrixT(:)); sortedIdx = 1 2 4 7 5 3 6 8 9
[m,n] = size(X); nlim = m*n; n = n+mod(n-m,2); mask = bsxfun(@le,[1:m] start_vec = m:m-1:m*(m-1)+1; a = bsxfun(@plus,start_vec offset_startcol = 2- mod(m+1,2); [~,idx] = min(mask,[],1); idx = idx - 1; idx(idx==0) = m; end_ind = a([0:n-1]*m + idx); offsets = a(1,offset_startcol:2:end) + end_ind(offset_startcol:2:end); a(:,offset_startcol:2:end) = bsxfun(@minus,offsets,a(:,offset_startcol:2:end)); out = a(mask); out2 = m*n+1 - out(end:-1:1+m*(n-m+1)); result = X([out2 ; out(out<=nlim)]);
Datasize: 500 x 2000 ------------------------------------- With Proposed Approach Elapsed time is 0.037145 seconds. ------------------------------------- With Luis Approach Elapsed time is 0.045900 seconds. Datasize: 5000 x 20000 ------------------------------------- With Proposed Approach Elapsed time is 3.947325 seconds. ------------------------------------- With Luis Approach Elapsed time is 6.370463 seconds.
[~,I] = sort (idx(:)); %sort the 1D indices of the image into ascending order according to idx reorderedim = im(I);
>> A = magic(4) A = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1
>>A(:,[1 3]) = A(:,[3 1]) A = 3 2 16 13 10 11 5 8 6 7 9 12 15 14 4 1
function matrix = swap(matrix,dimension,idx_a,idx_b) if dimension == 1 row_a = matrix(idx_a,:); matrix(idx_a,:) = matrix(idx_b,:); matrix(idx_b,:) = row_a; elseif dimension == 2 col_a = matrix(:,idx_a); matrix(:,idx_a) = matrix(:,idx_b); matrix(:,idx_b) = col_a; end
>> A = rand(6,4) A = 0.8350 0.5118 0.9521 0.9971 0.1451 0.3924 0.7474 0.3411 0.7925 0.8676 0.7001 0.0926 0.4749 0.4040 0.1845 0.5406 0.1285 0.0483 0.5188 0.2462 0.2990 0.6438 0.1442 0.2940 >> swap(A,2,1,3) ans = 0.9521 0.5118 0.8350 0.9971 0.7474 0.3924 0.1451 0.3411 0.7001 0.8676 0.7925 0.0926 0.1845 0.4040 0.4749 0.5406 0.5188 0.0483 0.1285 0.2462 0.1442 0.6438 0.2990 0.2940 >> tic;A = swap(rand(1000),1,132,234);toc; Elapsed time is 0.027228 seconds. >>
clear all im = imread( im = im2bw(im); [sy,sx] = size(im); im = imcomplement(im); im(150:200,100:150) = 0; % let some dots missing! im = imclearborder(im); st = regionprops(im, imshow(im) hold on; for j = 1:numel(st) px = round(st(j).Centroid(1,1)); py = round(st(j).Centroid(1,2)); plot(px,py, end
m=double(imread( m=abs(m-max(m(:))); % optional line if you want to look on the black square as "signal" H=fspecial( m2=conv2(m,H,
delta=1; N=size(m,1); df=1/(N*delta); % the frequency resolution (df=1/max_T) f_vector= df*((1:N)-1-N/2); % frequency vector freq_vec=f_vector; fft_vecx=fftshift(fft(sum(m2))); fft_vecy=fftshift(fft(sum(m2 plot(freq_vec,abs(fft_vecx),freq_vec,abs(fft_vecy))
ml= log( abs( fftshift (fft2(m2)))+1); imagesc(ml) colormap(bone)
% img = imread( img = imfilter(img, fspecial( BW = imcomplement(im2bw(img)); BW = imclearborder(BW); BW(150:200,100:150) = 0; % % st = regionprops(BW, c = vertcat(st.Centroid); % [H,T,R] = hough(BW); P = houghpeaks(H, 25); L = houghlines(BW, T, R, P); % I = imoverlay(img, BW, [0.9 0.1 0.1]); imshow(I, line(c(:,1), c(:,2), for k = 1:length(L) xy = [L(k).point1; L(k).point2]; plot(xy(:,1), xy(:,2), end hold off
% % LL = L( abs([L.theta]) < 30 ); % slopes = vertcat(LL.point2) - vertcat(LL.point1); slopes = atan2(slopes(:,2),slopes(:,1)); r = mean(slopes); % tform = maketform( img_align = imtransform(img, fliptform(tform)); imshow(img_align)
n=40; a=0; b=2*pi; c=0; d=2*pi; for i=1:n u=a+(b-a)*(i-1)/(n-1); for j=1:m v=a+(d-c)*(j-1)/(m-1); x(i,j)=sin(u)*cos(v); y(i,j)=sin(u)*sin(v); z(i,j)=cos(u); end end mesh(x,y,z);
x(theta) = a0 + ax*sin(theta) + bx*cos(theta) y(theta) = b0 + ay*sin(theta) + by*cos(theta)
(a0,b0) is the center of the ellipse (ax,ay) vector representing the major axis (bx,by) vector representing the minor axis
function [X,Y] = calculateEllipse(x, y, a, b, angle, steps) % %# % % % % % %# narginchk(5, 6); if nargin<6, steps = 36; end beta = -angle * (pi / 180); sinbeta = sin(beta); cosbeta = cos(beta); alpha = linspace(0, 360, steps) sinalpha = sin(alpha); cosalpha = cos(alpha); X = x + (a * cosalpha * cosbeta - b * sinalpha * sinbeta); Y = y + (a * cosalpha * sinbeta + b * sinalpha * cosbeta); if nargout==1, X = [X Y]; end end
% % % p = calculateEllipse(0, 0, 20, 10, 50); plot(p(:,1), p(:,2),
function plotEllipse(a,b,C) % range to plot over %------------------------------------ N = 50; theta = 0:1/N:2*pi+1/N; % Parametric equation of the ellipse %---------------------------------------- state(1,:) = a*cos(theta); state(2,:) = b*sin(theta); % Coordinate transform (since your ellipse is axis aligned) %---------------------------------------- X = state; X(1,:) = X(1,:) + C(1); X(2,:) = X(2,:) + C(2); % Plot %---------------------------------------- plot(X(1,:),X(2,:)); hold on; plot(C(1),C(2), axis equal; grid; end
axis equal; % view([-36 18]); % xlabel( ylabel( zlabel(
xNew = get(hMesh, yNew = get(hMesh, zNew = get(hMesh,
function [X,Y] = calculateEllipse(cx, cy, a, b, rotAngle) % %# % % % % % % % %# steps = 30; angle = linspace(0, 2*pi, steps); % Parametric equation of the ellipse X = a * cos(angle); Y = b * sin(angle); % rotate by rotAngle counter clockwise around (0,0) xRot = X*cosd(rotAngle) - Y*sind(rotAngle); yRot = X*sind(rotAngle) + Y*cosd(rotAngle); X = xRot; Y = yRot; % Coordinate transform X = X + cx; Y = Y + cy; end
[X,Y] = calculateEllipse(0, 0, 20, 10, 0); plot(X, Y, [X,Y] = calculateEllipse(0, 0, 20, 10, 45); plot(X, Y, [X,Y] = calculateEllipse(30, 30, 20, 10, 135); plot(X, Y, grid on;
im = imread( im(1,1,1) = 255; % Change the red value for the first pixel im(1,1,2) = 0; % Change the green value for the first pixel im(1,1,3) = 0; % Change the blue value for the first pixel imwrite(im,
% you so far im = imread( imshow(im); rectangle( % now you use "getframe" and "frame2im" f = getframe(gca); im = frame2im(f); imwrite(im,
im = imread( f = figure, imshow(im, rectangle( print(f,
>> im = imread( >> f = figure, imshow(im); >> r=rectangle( >> set(r, >> set(f, >> set(f, >> set(gca, >> print(f,
im = imread( im(100:110,100)=0; im(100:110,110)=0; im(100,100:110)=0; im(110,100:110)=0; imshow(im); imwrite(im,
close all; clear; clc; r = 240 ; c = 320; fig = figure( imshow( zeros(r,c) ); hold on; plot([c-fix(c/2),c-fix(c/2)],[r-fix(r/2),r-fix(r/2)], % Sets position and size of figure on the screen set(fig, % Sets axes to fill the figure space set(gca, % Sets print properties; Looks like 1 pixel = (3/4)th of a point set(fig, set(fig, print( fig, sprintf( im = imread( figure; imshow(im);
if ~issorted(diag(D)) [V,D] = eig(A); [D,I] = sort(diag(D)); V = V(:, I); end
function [out] = bilinearInterpolation(im, out_dims) % in_rows = size(im,1); in_cols = size(im,2); out_rows = out_dims(1); out_cols = out_dims(2); % S_R = in_rows / out_rows; % S_C = in_cols / out_cols; % % [cf, rf] = meshgrid(1 : out_cols, 1 : out_rows); % % rf = rf * S_R; cf = cf * S_C; % r = floor(rf); c = floor(cf); % r(r < 1) = 1; c(c < 1) = 1; r(r > in_rows - 1) = in_rows - 1; c(c > in_cols - 1) = in_cols - 1; % delta_R = rf - r; delta_C = cf - c; % % % in1_ind = sub2ind([in_rows, in_cols], r, c); in2_ind = sub2ind([in_rows, in_cols], r+1,c); in3_ind = sub2ind([in_rows, in_cols], r, c+1); in4_ind = sub2ind([in_rows, in_cols], r+1, c+1); % % % out = zeros(out_rows, out_cols, size(im, 3)); out = cast(out, class(im)); for idx = 1 : size(im, 3) chan = double(im(:,:,idx)); % % tmp = chan(in1_ind).*(1 - delta_R).*(1 - delta_C) + ... chan(in2_ind).*(delta_R).*(1 - delta_C) + ... chan(in3_ind).*(1 - delta_R).*(delta_C) + ... chan(in4_ind).*(delta_R).*(delta_C); out(:,:,idx) = cast(tmp, class(im)); end
im = imread( out = bilinearInterpolation(im, [270 396]); figure; imshow(im); figure; imshow(out);
im = imread( out = bilinearInterpolation(im, [68 99]); figure; imshow(im); figure; imshow(out);
for k = 1:length(vector) newVector = vector( exluding index k); <---- what mask should I use? % other operations to do with the newVector end
>> vector=1:10; >> k=6; >> vector(setdiff(1:end,k)) ans = 1 2 3 4 5 7 8 9 10 >> setdiff(1:end,k) Error using setdiff (line 81) Not enough input arguments.
%create a logic vector of same size: l=ones(size(vector))==1; l(k)=false; vector(l);
result = 1.0000 0.7500 1.0000 0.8500 1.0000 0.9500 5.0000 0.7500 5.0000 0.8500 5.0000 0.9500 10.0000 0.7500 10.0000 0.8500 10.0000 0.9500
function C = cartesian(varargin) args = varargin; n = nargin; [F{1:n}] = ndgrid(args{:}); for i=n:-1:1 G(:,i) = F{i}(:); end C = unique(G , end
cartesian([ ans = 99 1 50 99 1 70 99 2 50 99 2 70 100 1 50 100 1 70 100 2 50 100 2 70 101 1 50 101 1 70 101 2 50 101 2 70
vector = zeros(1,10) %the "1" represents a function that returns a scalar if 1 && vector == 0 %this comparision won end
vector = zeros(1,10) if 1 && all(vector == 0) %this comparision will work end
test = [0 0 0 0 0 0]; ~test ans = 1 1 1 1 1 1 1 test = [1 0 0 1 0 1 0 0 0]; ~test ans = 0 1 1 0 1 0 1 1 1
The right hand side of this assignment has too few values to satisfy the left hand side.
a = cell(10,1); % cell array b = rand(1,10)>0.5; % vector with logicals myString = a(b) = {myString};
a = cell(10,1); % cell array b = rand(1,10)>0.5; % vector with logicals myString = [a{b}] = deal(myString);
v = [ 6 7 8 12 13 14 15 26 27 28 29 30 55 56]; x = [0 cumsum(diff(v)~=1)]; v(x==mode(x))
vector = [6 7 8 12 13 14 15 26 27 28 29 30 55 56] d = [diff(vector) 0] maxSequence = 0; maxSequenceIdx = 0; lastIdx = 1; while lastIdx~=find(d~=1, 1, idx = find(d~=1, 1); if idx-lastIdx > maxSequence maxSequence = idx-lastIdx; maxSequenceIdx = lastIdx; end d(idx) = 1; lastIdx=idx; end output = vector(1+maxSequenceIdx:maxSequenceIdx+maxSequence)
vector = [6 7 8 12 13 14 15 26 27 28 29 30 55 56]; seqGroups = [1 find([1 diff(vector)]~=1) numel(vector)+1]; % beginning of group [~, groupIdx] = max( diff(seqGroups)); % bigger group index output = vector( seqGroups(groupIdx):seqGroups(groupIdx+1)-1)
temp = find ( ([(vector(2:end) - vector(1:end-1))==1 0])==0); [len,ind]=max(temp(2:end)-temp(1:end-1)); vec_out = vector(temp(ind)+1:temp(ind)+len)
array = [1, 2, 3; 6, 2, 1; 4, 1, 5]; [max_value max_index] = max(array, [], 2) %3, 3 %6, 1 %5, 3
strs = { strs_spaces = sprintf( trimmed = strtrim(strs_spaces);
str = strjoin(C) example str = strjoin(C,delimiter)
>> strCell = { >> nCells = numel(strCell); >> strCell(1:nCells-1) = strcat(strCell(1:nCells-1),{ >> fullString = [strCell{:}] fullString = a b c d e
>> C = { >> join(C) %same result as: >> join(C, ans = string "one two three" >> join(C, ans = string "one, and-ah two, and-ah three"
%% Read in the file clearvars; close all; [f,fs] = audioread(
%% Play original file pOrig = audioplayer(f,fs); pOrig.play;
%% Plot both audio channels N = size(f,1); % Determine total number of samples in audio file figure; subplot(2,1,1); stem(1:N, f(:,1)); title( subplot(2,1,2); stem(1:N, f(:,2)); title(
%% Plot the spectrum df = fs / N; w = (-(N/2):(N/2)-1)*df; y = fft(f(:,1), N) / N; % For normalizing, but not needed for our analysis y2 = fftshift(y); figure; plot(w,abs(y2));
%% Design a bandpass filter that filters out between 700 to 12000 Hz n = 7; beginFreq = 700 / (fs/2); endFreq = 12000 / (fs/2); [b,a] = butter(n, [beginFreq, endFreq],
%% Filter the signal fOut = filter(b, a, f); %% Construct audioplayer object and play p = audioplayer(fOut, fs); p.play;
function results = B(parameters) % some code otherResults = A(otherParameters)
function results = A(paramters) % some code function results = C(parameters) % code of function C end end function results = D(parameters) % code of function D end
function results = D(parameters) % code of function D end
function result = ackermann(m,n) if m == 0 result = n + 1; elseif m > 0 if n == 0 result = ackermann(m-1,1); elseif n > 0 result = ackermann(m-1,ackermann(m,n-1)); else error( end else error( end end
mat = [ 1 2 ; 3 4 ] ; % disp([ % desired ouput: Error in var: mat (and NOT 1 2 ; 3 4!)
function disp_msg_var(msg, v) disp([msg inputname(2)]); end
function test a = 1; b = 2; varNames = who(); disp(sprintf( c = 3; d = 4; varNames = who(); disp(sprintf( end
>> test Variables are: a b Variables are: a b c d varNames
function [J, grad] = costFunction(theta, X, y) m = length(y); % number of training examples thetas = size(theta,1); features = size(X,2); steps = 100; alpha = 0.1; J = 0; grad = zeros(size(theta)); sums = []; result = 0; for i=1:m % sums = [sums; (y(i))*log10(sigmoid(X(i,:)*theta))+(1-y(i))*log10(1-sigmoid(X(i,:)*theta))] sums = [sums; -y(i)*log(sigmoid(theta %use log simple not log10, mistake end result = sum(sums); J = (1/m)* result; %gradient one step tempo = []; thetas_update = 0; temp_thetas = []; grad = temp_thetas; for i = 1:size(theta) for j = 1:m tempo(j) = (sigmoid(theta end temp_thetas(i) = sum(tempo); tempo = []; end grad = (1/m).*temp_thetas; % ============================================================= end
function [J, grad] = costFunction(theta, X, y) hx = sigmoid(X * theta); m = length(X); J = (-y grad = X end
hx = sigmoid(X m = length(X); J = sum(-y * log(hx) - (1 - y)*log(1 - hx)) / m; grad = X end
% Load and plot the image data: imageData = imread( subplot(221); imshow(imageData); title( % Gaussian-filter the image: gaussFilter = fspecial( filteredData = imfilter(imageData, gaussFilter); subplot(222); imshow(filteredData); title( % Perform a morphological close operation: closeElement = strel( closedData = imclose(filteredData, closeElement); subplot(223); imshow(closedData); title( % Find the regions where local maxima occur: maxImage = imregionalmax(closedData); maxImage = imdilate(maxImage, strel( % them better on the plot subplot(224); imshow(maxImage); title(
sat[x, y] = img[x, y] + sat[x-1, y] + sat[x, y-1] - sat[x-1, y-1]
img sat 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 0 0 0 0 0 2 2 2 0 1 1 1 0 0 0 1 2 5 5 5 0 1 0 0 0 0 0 2 3 6 6 6 0 0 0 0 0 0 0 2 3 6 6 6
img sat window 0 0 0 1 0 0 0 0 0 1 1 1 0 A-----B 1 0 0 0 1 0 0 0 0 0 2 2 2 0 | 0 2 | 2 0 1 1 1 0 0 0 1 2 5 5 5 0 | 2 5 | 5 0 1 0 0 0 0 0 2 3 6 6 6 0 | 3 6 | 6 0 0 0 0 0 0 0 2 3 6 6 6 0 D-----C 6
function [hours, mins, secs] = sec2hms(t) hours = floor(t / 3600); t = t - hours * 3600; mins = floor(t / 60); secs = t - mins * 60; end
function hms = sec2hms(t) hours = floor(t / 3600); t = t - hours * 3600; mins = floor(t / 60); secs = t - mins * 60; hms = sprintf( end sec2hms(69.9904) ans = 00:01:09.99
seconds = 5000; hms = fix(mod(seconds, [0, 3600, 60]) ./ [3600, 60, 1]) hms = 1 23 20
nIterations = 10000; tic for i = 1:nIterations hms = fix(mod(seconds, [0, 3600, 60])./[3600, 60, 1]); end sprintf(
tic for i = 1:nIterations datestr(seconds/24/3600, end sprintf(
function push_workspace() c = getappdata(0, if isempty(c) c = {}; end % Grab workspace w = evalin( names = {w.name}; s = struct; for i = 1:numel(w) s.(names{i}) = evalin( end % Push it on the stack c{end+1} = s; setappdata(0, function pop_workspace() % Pop last workspace off stack c = getappdata(0, if isempty(c) warning( return; end s = c{end}; c(end) = []; setappdata(0, % Do this if you want a blank slate for your workspace evalin( % Stick vars back in caller names = fieldnames(s); for i = 1:numel(names) assignin( end
save workspace_1.mat % % clear % load workspace_2.mat % %
pop_workspace(keep_current) % keep_current: bool: if true, current vars retained after pop . . . if (~keep_current) evalin( end
function pull_workspace(names) % pulls variablesin cell array names{} into workspace from stack without % popping the workspace stack % % pulled variable will be a local copy of the stack % so modifying it will leave the stack % if (~exist( pull_all = true; else pull_all = false; % if names is not a cell array, then user gave us % just 1 var name as a string. make it a cell array. if (~iscell(names)) names = {names}; end end % Peek at last workspace on stack c = getappdata(0, if isempty(c) warning( return; end s = c{end}; % Stick vars back in caller if (pull_all) names = fieldnames(s); end for i = 1:numel(names) assignin( end end
k = 4; N = 10; result = [1 1]; % while any(diff(result)<=1) % result = sort(randsample(N, k). end
>>> class NonConsecutiveSampler(object): def __init__(self,N): import random self.num = N def get_samples(self,k): possibilities = [i for i in range(1,self.num + 1)] samples = [] while len(samples) < k: r = random.sample(possibilities,1)[0] samples.append(r) for i in range(r - 1, r + 2): if i in possibilities: possibilities.remove(i) samples.sort() return samples >>> n = NonConsecutiveSampler(10) >>> n.get_samples(4) [2, 5, 8, 10] >>> n.get_samples(4) [1, 5, 7, 10] >>> n.get_samples(4) [3, 6, 8, 10] >>> n.get_samples(4) [1, 3, 5, 8]
vec= randi(100,1,1); for j = 2:50, while(abs(vec(j)-vec(j-1)<2) vec(j)= randi(100,1,1);end; end
vec = rand(100,100,1); badindex = find(abs(vec(1:99)-vec(2:100) < 1)); vec(badindex) = vec(badindex-1)+vec(badindex+1); % if you don vec(vec>100) = vec (vec>100) -100; % to ensure, I hope, that neighbors
N=10; k=4; increments = floor(rand(1,k)*(N-2))+2 % out = mod(cumsum(increments), N)+1 %
from numpy import cumsum, floor, mod, random N=5 k=100 increments = floor(random.rand(1,k)*(N-2))+2 out = mod(cumsum(increments), N)+1 print(out) [ 5. 3. 1. 5. 2. 4. 3. 2. 4. 2. 4. 3. 1. 5. 4. 3. 5. 4. 2. 5. 4. 2. 5. 2. 4. 1. 5. 4. 1. 5. 3. 1. 3. 2. 4. 1. 5. 4. 1. 3. 5. 4. 3. 5. 2. 1. 3. 2. 4. 3. 1. 4. 2. 1. 3. 2. 1. 4. 3. 2. 1. 3. 5. 3. 5. 4. 2. 4. 2. 1. 3. 2. 1. 3. 5. 2. 5. 4. 3. 1. 4. 1. 4. 3. 5. 4. 2. 1. 5. 2. 1. 5. 4. 2. 4. 3. 5. 2. 4. 1.]
N = 10; k = 4; out = zeros(1,k); vec = 1 : N; for idx = 1 : k ind = randi(numel(vec), 1); left = max(ind-1, 1); right = min(numel(vec), ind+1); out(idx) = vec(ind); to_remove = ind; if vec(left) == vec(ind)-1 to_remove = [to_remove left]; end if vec(right) == vec(ind)+1 to_remove = [to_remove right]; end vec(to_remove) = []; end
>> out out = 9 7 1 5 >> out out = 7 1 4 10 >> out out = 10 8 1 6 >> out out = 10 4 8 1
def nonseq(n, k): out = [random.randint(0, n)] while len(out) < k: x = random.randint(0, n) if abs(x - out[-1]) > 1: out.append(x) return out
import random def myFunc(N,k): if k>(N+1)/2: return "k to big for N" returnValue = sorted(random.sample(range(1,N+1),k)) toTest = [x - returnValue[i - 1] for i, x in enumerate(returnValue)][1:] if 1 in toTest: return myFunc(N,k) else: return returnValue print myFunc(10,4)
def ncsample(population, k): import random if k > 0: i = random.randrange(0, len(population) - 2*(k-1)) return [population[i]] + ncsample(population[i+2:], k-1) else: return []
function r = ncsample(population, k) if k > 0 i = randi(length(population) - 2*(k-1)); r = [population(i) ncsample(population((i+2):end), k-1)]; else r = []; end end
>> for i=1:10; fprintf( 1 5 7 9 3 5 8 10 3 5 8 10 4 6 8 10 2 6 8 10 1 4 8 10 1 4 7 9 3 6 8 10 1 6 8 10 2 4 7 9
>> nargin(@feature) ans = 2 >> nargout(@feature) ans = 1
[x,y] = deal( cell(4,8) ); >> [a,b,c] = deal( 42 ) a = 42 b = 42 c = 42
A = 1:50; % matrix to draw colormap( imagesc(A); % draw image and scale colormap to values range colorbar; % show color scale
x=1+2+3 ... optional comments for each line ... * factorA ... can be inserted here * factorB ... +4;
% Percent. The percent symbol is used to begin comments. Logically, it serves as an end-of-line character. Any following text on the line is ignored or printed by the HELP system.
a = log10([30 40 0 60]) => [1.4771 1.6021 -Inf 1.7782]
>> a = log10([30 40 0 60]) a = 1.477 1.602 -Inf 1.778 >> a(~isfinite(a))=0 a = 1.477 1.602 0 1.778
A^{-1} = (I - (I-A))^{-1} = 1 + (I-A) + (I-A)^2 + ...
plot(rand(1, 10)); % Plot some random data ylabel(gca, set(gca, axesPosition = get(gca, hNewAxes = axes( ylabel(hNewAxes,
yyaxis right ylabel( plot(x,y1) % plot your right axis graph
hold all for ind=1:3 x=[0:0.1:10]; plot(x, sin(x)+ind, end legend(gca,
legendStrings = { h_legend = legend(legendStrings{:}); % ... computations, hold on and additional plot on axis delete(h_legend); legendStrings{end+1} = h_legend = legend(legendStrings{:}); % rinse and repeat...
hold all; p1=plot(1:10,1:10); legend(p1, p2=plot(1:10,11:20); % different data set legend(p2, legend(gca, legend(
plot(points,expdata1, plot(points,expdata2, plot(points,expdata3, legend( drawnow h_old=plot(0,250);
h(1)=plot(points,modeldata1, h(2)=plot(points,modeldata2, h(3)=plot(points,modeldata3, delete(h_old); h_old = h; drawnow
plot(x,y); legend( hold on; plot(x,z); hold off; % Now add a new item to the legend h = legend(); newleg = h.String; newleg{end+1} = legend(newleg);
valueSet = {[-1, 1], [2, 3], [1,5], [1,8]}; keySet = { Joints = containers.Map(keySet,valueSet); Joints( ans = -1 1
values(Joints) ans = [1x2 double] [1x2 double] [1x2 double] [1x2 double] keys(Joints) ans =
Joints.left_knee = [100 200]; Joints.head = [-1 -100];
Joints(1).left_knee = [100 200]; Joints(1).head = [-1 -100]; Joints(2).left_knee = [200 450]; Joints(2).head = [-10 -189]; Joints(3).left_knee = [-118 264]; Joints(3).head = [+33 78];
>> someVar = >> Joints.(someVar) % will be expanded cell-array, 1 entry for each dimension ans = -1 -100 ans = -10 -189 ans = 33 78 >> [Joints.(someVar)] % will collect those data in regular array ans = -1 -100 -10 -189 33 78 >> {Joints.(someVar)} % will collect those data in cell array ans = [1x2 double] [1x2 double] [1x2 double] >> [A,B,C] = deal(Joints.(someVar)); % will assign data to 3 separate vars A = -1 -100 B = -10 -189 C = 33 78
idx.left_knee = 1; idx.right_knee = idx.left_knee + 1; idx.left_elbow = idx.right_knee+ 1; idx.right_elbow= idx.left_elbow+ 1; joint_pos = rand(4,8); t = linspace(0,1,8); joint_vel = diff(joint_pos,2)./diff(t); joint_vel(idx.right_knee,:)
>> profile on -history; MyCode; profile viewer >> p = profile(
profile on -history plot(magic(4)); p = profile( for n = 1:size(p.FunctionHistory,2) if p.FunctionHistory(1,n)==0 str = else str = end disp([str p.FunctionTable(p.FunctionHistory(2,n)).FunctionName]) end
mdot( !dot -Tps m2html.dot -o m2html.ps !neato -Tps m2html.dot -o m2html.ps
A = rand(3,3) A = 0.185987 0.192125 0.046346 0.140710 0.351007 0.236889 0.155899 0.107302 0.300623 pinv(A) == inv(A) ans = 0 0 0 0 0 0 0 0 0
ans = 1.0000e+00 6.1062e-16 -3.0809e-15 -5.8877e-15 1.0000e+00 6.3942e-15 2.4425e-15 -3.0184e-16 1.0000e+00
>>> (1/48)*48==(1/49)*49 ans = 0 >>> (1/48)*48-(1/49)*49 ans = 1.1102e-16 >>>
dx = diff(x); % dy = diff(y); den = dx(1)*dy(2)-dy(1)*dx(2); % ua = (dx(2)*(y(1)-y(3))-dy(2)*(x(1)-x(3)))/den; ub = (dx(1)*(y(1)-y(3))-dy(1)*(x(1)-x(3)))/den;
isInSegment = all(([ua ub] >= 0) & ([ua ub] <= 1));
0 = 0*m + 1*b % Using the first point x=y=0 into y=m*x+b 6 = 6*m + 1*b % Using the second point x=y=6
I = inv([m_1 -1; m_2 -1])*[-b_1;-b_2]; % I is the intersection.
y - y1 = (y2 - y1) / (x2 - x1) * (x - x1) y - y1 = (y2 - y1) / (x2 - x1) * x - (y2 - y1) / (x2 - x1) * x1 (y1 - y2) / (x2 - x1) * x + y - y1 = (y1 - y2) / (x2 - x1) * x1 (y1 - y2) / (x2 - x1) * x + y = (y1 - y2) / (x2 - x1) * x1 + y1 (y1 - y2) * x + (x2 - x1) * y = (y1 - y2) * x1 + (x2 - x1) * y1 A = (y1 - y2) B = (x2 - x1) C = (y1 - y2) * x1 + (x2 - x1) * y1 = A * x1 + B * y1
x1 = 0, x2 = 6, y1 = 0, y2 = 6 A1 = (0 - 6) = -6 B1 = (6 - 0) = 6 C1 = A1 * 0 + B1 * 0 = 0 x1 = 0, x2 = 6, y1 = 6, y2 = 0 A2 = (6 - 0) = 6 B2 = (6 - 0) = 6 C2 = A2 * 0 + B2 * 6 = 6 * 6 = 36
dim = 2; % Do other stuff, ending with rref(matrix) if (matrix(:,1:dim) == eye(dim)) % Matrix has unique solution. solution = (matrix(:,dim+1))' else % No unique solution. end
% Let each point be def as a 3x1 array % Let points defining first line be : p1, q1 % Let points defining second line be : p2, q2 L = p1-p2; M = p1-q1; N = p2-q2; A = [M N]; T = pinv(A)*L; h = p1-T(1)*(p1-q1); % h is a 3x1 array representing the actual pt of intersection
% Let each point be def as a 3x1 array % Let points defining first line be : p1, q1 % Let points defining second line be: p2, q2 % There are two conditions that prevent intersection of line segments/lines % in L3 space. 1. parallel 2. skew-parallel (two lines on parallel planes do not intersect) % Both conditions need to be identified and handled in a general algorithm. % First check that lines are not parallel, this is done by comparing DCS of % the line vectors % L, M, N ARE DIRECTION VECTORS. L = p1-p2; M = p1-q1; N = p2-q2; % Calculate a normalized DCS for comparison. If equal, it means lines are parallel. MVectorMagnitude = sqrt(sum(M.*M,2)); % The rowsum is just a generalization for N-D vectors. NVectorMagnitude=sqrt(sum(N.*N,2)); % The rowsum is just a generalization for N-D vectors. if isequal(M/MVectorMagnitude,N/NVectorMagnitude) % Compare the DCS for equality fprintf( end; % Now check that lines do not exist on parallel planes % This is done by checking the minimum distance between the two lines. If there a1 = dot(M,L); b1 = dot(M,M); c1 = dot(M,N); a2 = dot(N,L); b2 = dot(N,M); c2 = dot(N,N); s1 = -(a1*c2 - a2*c1)/(b1*c2-b2*c1); s2 = -(a1*b2 - a2*b1)/(b1*c2-b2*c1); Sm = (L + s1*M - s2*N); s = sqrt(sum(Sm.*Sm,2)); if ~isequal(s,0) % If the minimum distance between two lines is not zero, then the lines do not intersect fprintf( end; % Here A = [M N]; T = pinv(A)*L; h = p1-T(1)*(p1-q1); % h is a 3x1 array representing the actual pt of intersection.
theta = pi/9; r = 3; % magnitude (length) of arrow to plot x = 4; y = 5; u = r * cos(theta); % convert polar (theta,r) to cartesian v = r * sin(theta); h = quiver(x,y,u,v); set(gca,
x = 1; % X coordinate of arrow start y = 2; % Y coordinate of arrow start theta = pi/4; % Angle of arrow, from x-axis L = 2; % Length of arrow xEnd = x+L*cos(theta); % X coordinate of arrow end yEnd = y+L*sin(theta); % Y coordinate of arrow end points = linspace(0, theta); % 100 points from 0 to theta xCurve = x+(L/2).*cos(points); % X coordinates of curve yCurve = y+(L/2).*sin(points); % Y coordinates of curve plot(x+[-L L], [y y], hold on; % Add subsequent plots to the current axes axis([x+[-L L] y+[-L L]]); % Set axis limits axis equal; % Make tick increments of each axis equal arrow([x y], [xEnd yEnd]); % Plot arrow plot(xCurve, yCurve, plot(x, y,
A=rand(128,1024,1024); tic;B=reshape(A,1024,128,1024);toc Elapsed time is 0.000011 seconds.
>> tic;for i=1:1000;B=reshape(A,1024,128,1024);end;toc Elapsed time is 0.000724 seconds. >> tic;for i=1:1000;B=A;end;toc Elapsed time is 0.000307 seconds.
FILES = ls( for i = 1:size(FILES, 1); STRU = pdbread(FILES{i}); end
C:\Documents and Settings\My Documents\MATLAB\asd.pdb C:\Documents and Settings\My Documents\MATLAB\asd.pdb
fid = fopen( FILES = textscan(fid, FILES = FILES{1}; fclose(fid);
for i = 1:size(FILES, 1) PDB = pdbread(char(FILES{i}));
for i = 1:n str = strcat( data = load(matfiles(i).name); % use our logic here % before proceeding to the next file end
% copy-paste the following into your command window or your function % first, you have to find the folder folder = uigetdir; % check the help for uigetdir to see how to specify a starting path, which makes your life easier % get the names of all files. dirListing is a struct array. dirListing = dir(folder); % loop through the files and open. Note that dir also lists the directories, so you have to check for them. for d = 1:length(dirListing) if ~dirListing(1).isdir fileName = fullfile(folder,dirListing(d).name); % use full path because the folder may not be the active path % open your file here fopen(fileName) % do something end % if-clause end % for-loop
??? Undefined function or method arguments of type Error in ==> chk at 15 words=strsplit(newline{i})
??? Error using ==> cellfun Non-scalar in Uniform output, at index 1, output 1. Set
A1=I(1:128, 1:128); A2=I(129:256, 1:128); A3=I(1:128, 129:256); A4=I(129:256, 129:256);
image_top_left = myImage(1:128,1:128); image_top_right = myImage(1:128,129:256); image_bottom_left = myImage(129:256,1:128); image_bottom_right = myImage(129:256,129:256);
function V = runLengthDecode(runLengths, values) [~,V] = histc(1:sum(runLengths), cumsum([1,runLengths(:). if nargin>1 V = reshape(values(V), 1, []); end V = shiftdim(V, ~isrow(runLengths)); end
runLengthDecode([0,1,0,2]) runLengthDecode([0,1,0,4], [1,2,4,5]. runLengthDecode([0,1,0,2]. runLengthDecode([0,3,1,0], {
>> runLengthDecode([0,1,0,2]) ans = 2 4 4 >> runLengthDecode([0,1,0,4], [1,2,4,5]. ans = 2 5 5 5 5 >> runLengthDecode([0,1,0,2]. ans = 20 40 40 >> runLengthDecode([0,3,1,0],{ ans =
function theLastRunLengthDecodingComputationComparisonYoullEverNeed() Funcs = {@knedlsepp0, ... @LuisMendo1bsxfun, ... @LuisMendo2cumsum, ... @gnovice3cumsum, ... @Divakar4replicate_bsxfunmask, ... @knedlsepp5cumsumaccumarray }; %% Growing number of runs, low maximum sizes in runLengths ns = 2.^(1:25); paramGenerators{1} = arrayfun(@(n) @(){randi(200,n,1)}, ns, paramGenerators{2} = arrayfun(@(n) @(){[2000;randi(200,n,1)]}, ns, for i = 1:2 times = compareFunctions(Funcs, paramGenerators{i}, 0.5); finishedComputations = any(~isnan(times),2); h = figure( loglog(ns(finishedComputations), times(finishedComputations,:)); legend(cellfun(@func2str,Funcs, title( xlabel( print([ end end function times = compareFunctions(Funcs, paramGenerators, timeLimitInSeconds) if nargin<3 timeLimitInSeconds = Inf; end times = zeros(numel(paramGenerators),numel(Funcs)); for i = 1:numel(paramGenerators) Params = feval(paramGenerators{i}); for j = 1:numel(Funcs) if max(times(:,j))<timeLimitInSeconds times(i,j) = timeit(@()feval(Funcs{j},Params{:})); else times(i,j) = NaN; end end end end %% %% %% function V = knedlsepp0(runLengths, values) [~,V] = histc(1:sum(runLengths), cumsum([1,runLengths(:). if nargin>1 V = reshape(values(V), 1, []); end V = shiftdim(V, ~isrow(runLengths)); end %% function V = LuisMendo1bsxfun(runLengths, values) nn = 1:numel(runLengths); if nargin==1 % values = nn; end V = values(nonzeros(bsxfun(@times, nn,... bsxfun(@le, (1:max(runLengths)). if size(runLengths,1)~=size(values,1) % V = V. end end %% function V = LuisMendo2cumsum(runLengths, values) if nargin==1 % values = 1:numel(runLengths); end [ii, ~, jj] = find(runLengths(:)); V(cumsum(jj(end:-1:1))) = 1; V = values(ii(cumsum(V(end:-1:1)))); if size(runLengths,1)~=size(values,1) % V = V. end end %% function V = gnovice3cumsum(runLengths, values) isColumnVector = size(runLengths,1)>1; if nargin==1 % values = 1:numel(runLengths); end values = reshape(values(runLengths~=0),1,[]); if isempty(values) % V = []; return; end runLengths = nonzeros(runLengths(:)); index = zeros(1,sum(runLengths)); index(cumsum([1;runLengths(1:end-1)])) = 1; V = values(cumsum(index)); if isColumnVector % V = V. end end %% function V = Divakar4replicate_bsxfunmask(runLengths, values) if nargin==1 % values = 1:numel(runLengths); end % if size(values,1) > 1 values = values. end if size(runLengths,1) > 1 yes_transpose_output = false; runLengths = runLengths. else yes_transpose_output = true; end maxlen = max(runLengths); all_values = repmat(values,maxlen,1); % V = all_values(bsxfun(@le,(1:maxlen) % if yes_transpose_output V = V. end end %% function V = knedlsepp5cumsumaccumarray(runLengths, values) isRowVector = size(runLengths,2)>1; % V = cumsum(accumarray(cumsum([1; runLengths(:)]), 1)); V = V(1:end-1); % if nargin>1 V = reshape(values(V),[],1); end % if isRowVector V = V. end end
function V = runLengthDecode(runLengths, values) if nargin<2 values = 1:numel(runLengths); end V = repelem(values, runLengths); end
function V = runLengthDecode(runLengths, values) % V = cumsum(accumarray(cumsum([1; runLengths(:)]), 1)); V = V(1:end-1); % if nargin>1 V = reshape(values(V),[],1); end % if size(runLengths,2)>1 V = V. end end
function V = runLengthDecode(runLengths, values) nn = 1:numel(runLengths); if nargin==1 % values = nn; end V = values(nonzeros(bsxfun(@times, nn,... bsxfun(@le, (1:max(runLengths)). if size(runLengths,1)~=size(values,1) % V = V. end
function V = runLengthDecode2(runLengths, values) if nargin==1 % values = 1:numel(runLengths); end [ii, ~, jj] = find(runLengths(:)); V(cumsum(jj(end:-1:1))) = 1; V = values(ii(cumsum(V(end:-1:1)))); if size(runLengths,1)~=size(values,1) % V = V. end
function V = replicate_bsxfunmask(runLengths, values) if nargin==1 % values = 1:numel(runLengths); end % if size(values,1) > 1 values = values. end if size(runLengths,1) > 1 yes_transpose_output = false; runLengths = runLengths. else yes_transpose_output = true; end maxlen = max(runLengths); all_values = repmat(values,maxlen,1); % V = all_values(bsxfun(@le,(1:maxlen) % if yes_transpose_output V = V. end return;
function out = replicate_bsxfunmask_v2(runLengths, values) if nargin==1 % values = 1:numel(runLengths); end if size(values,1) > 1 values = values. end if size(runLengths,1) > 1 yes_transpose_output = true; runLengths = runLengths. else yes_transpose_output = false; end % values = values(runLengths>0); runLengths = runLengths(runLengths>0); % thresh = 200; % crunLengths = cumsum(runLengths); %% mask = runLengths >= thresh; % starts = [1 crunLengths(1:end-1)+1]; % mask_ind = find(mask); % post_mark = starts(mask); negt_mark = crunLengths(mask)+1; if ~isempty(negt_mark) && negt_mark(end) > crunLengths(end) negt_mark(end) = []; end % marked_out = zeros(1,crunLengths(end)); marked_out(post_mark) = mask_ind; marked_out(negt_mark) = marked_out(negt_mark) -1*mask_ind(1:numel(negt_mark)); % out = cumsum(marked_out); % thresh_mask = out~=0; % out(thresh_mask) = values(out(thresh_mask)); values = values(~mask); runLengths = runLengths(~mask); maxlen = max(runLengths); all_values = repmat(values,maxlen,1); out(~thresh_mask) = all_values(bsxfun(@le,(1:maxlen) if yes_transpose_output out = out. end return;
featureDist = Columns 1 through 8 48.4766 47.3743 59.5736 59.7450 55.0489 58.2620 63.3865 50.1101
function [smallestNElements smallestNIdx] = getNElements(A, n) [ASorted AIdx] = sort(A); smallestNElements = ASorted(1:n); smallestNIdx = AIdx(1:n); end
B = [48.4766 47.3743 59.5736 59.7450 55.0489 58.2620 63.3865 50.1101]; [Bsort Bidx] = getNElements(B, 4);
BSort = 47.3743 48.4766 50.1101 55.0489 Bidx = 2 1 8 5
set(hline(1), set(hline(2:3), idx = [4 5]; set(hline(idx),
x = 0:0.1:2; plot(x,sin(x)); fig = gcf % get a handle to the current figure % get handles to the children of that figure: the axes in this case ax = get(fig, % get handles to the elements in the axes: a single line plot here h = get(ax, % manipulate desired properties of the line, e.g. line width set(h,
hline: 1 : 5 th line (mistical) 2 : 5 th line (in legend) 3 : 4 th line (mistical) 4 : 4 th line (in legend) 5 : 3 th line (mistical) 6 : 3 th line (in legend) 7 : 2 th line (mistical) 8 : 2 th line (in legend) 9 : 1 th line (mistical) 10: 1 th line (in legend) 11: 5 th line (in plot) 12: 4 th line (in plot) 13: 3 th line (in plot) 14: 2 th line (in plot) 15: 1 th line (in plot)
hline = findobj(gcf, isThereLegend=(~isempty(findobj(gcf, if(isThereLegend) nLines=length(hline)/3 else nLines=length(hline) end
for iterLine=1:nLines mInd=nLines-iterLine+1 if(isThereLegend) set(hline([(mInd*2-1) (mInd*2) (2*nLines+mInd)]), else set(hline(mInd), end end
legend off hline = findobj(gcf, nLines=length(hline) for iterLine=1:nLines mInd=nLines-iterLine+1 set(hline(mInd), end legend show
>> myMatrix2 = double(myMatrix); >> save myFile.txt myMatrix2 -ASCII
yLimits = get(gca, yTicks = yLimits(2)-get(gca, % set(gca, %
Im = imread( Im = flipdim(Im ,1); % vertical flip the image. axis xy; %set the xy to be at (0,0), this flips the image back again.
yTicks = get(gca, yTicks_reverse = sort(yTicks,2, set(gca,
x = [ 1 1 2 2 3 3 4 4 2 2 3 3 3 3 ]; [u,I,J] = unique(x, hasDuplicates = size(u,1) < size(x,1) ixDupRows = setdiff(1:size(x,1), I) dupRowValues = x(ixDupRows,:)
>> mat = [1 2 3; 4 5 6; 7 8 9; 7 8 9; 1 2 3]; % >> [newmat,index] = unique(mat, >> repeatedIndex = setdiff(1:size(mat,1),index) % repeatedIndex = 4 5
[S,idx1] = sortrows(M); idx2 = find(all(diff(S,1) == 0,2)); out = unique(idx1([idx2;idx2+1]));
d = 4; % dimension numA = 100; % number of set 1 points numB = 200; % number of set 2 points A = rand(numA,d); % set 1 given as matrix A B = rand(numB,d); % set 2 given as matrix B
helpA = zeros(numA,3*d); helpB = zeros(numB,3*d); for idx = 1:d helpA(:,3*idx-2:3*idx) = [ones(numA,1), -2*A(:,idx), A(:,idx).^2 ]; helpB(:,3*idx-2:3*idx) = [B(:,idx).^2 , B(:,idx), ones(numB,1)]; end distMat = helpA * helpB
helpA(:,3*idx-2:3*idx) = [ones(numA,1), -2*A(:,1), A(:,1).^2, ... % d == 2 ones(numA,1), -2*A(:,2), A(:,2).^2 ]; % etc.
%% create some points d = 2; % dimension numA = 20000; numB = 20000; A = rand(numA,d); B = rand(numB,d); %% pairwise distance matrix % proposed method: tic; helpA = zeros(numA,3*d); helpB = zeros(numB,3*d); for idx = 1:d helpA(:,3*idx-2:3*idx) = [ones(numA,1), -2*A(:,idx), A(:,idx).^2 ]; helpB(:,3*idx-2:3*idx) = [B(:,idx).^2 , B(:,idx), ones(numB,1)]; end distMat = helpA * helpB toc; % compare to pdist2: tic; pdist2(A,B).^2; toc; % compare to [1]: tic; bsxfun(@plus,dot(A,A,2),dot(B,B,2) toc; % Another method: added 07/2014 % compare to ndgrid method (cf. Dan tic; [idxA,idxB] = ndgrid(1:numA,1:numB); distMat = zeros(numA,numB); distMat(:) = sum((A(idxA,:) - B(idxB,:)).^2,2); toc;
Elapsed time is 1.796201 seconds. Elapsed time is 5.653246 seconds. Elapsed time is 3.551636 seconds. Elapsed time is 22.461185 seconds.
help = zeros(numA,numB,d); for idx = 1:d help(:,:,idx) = [ones(numA,1), A(:,idx) ] * ... [B(:,idx) end distMat = sum(ANYFUNCTION(help),3);
nA = sum( A.^2, 2 ); % nB = sum( B.^2, 2 ); % distMat = bsxfun( @plus, nA, nB
arglist = [arg1, arg2, arg3, arg4]; parfor ii = 1:size(arglist, 2) myfun(arglist(ii)); end
prevlength = 0; for ii = 1:tot_iter % Some calculations here msg = sprintf( fprintf(repmat( fprintf(msg); prevlength = numel(msg); end
Working on 127 of 10000, 1.27 percent done Working on 259 of 10000, 2.59 percent done Working on 3895 of 10000, 38.95 percent done Working on 1347 of 10000, 13.47 percent done
Sim 1: 1.27% Sim 2: 2.59% Sim 3: 38.95% Sim 4: 13.47%
function parfor_progress_test() cpus = feature( matlabpool( cleaner = onCleanup(@mycleaner); args = [1000, 1000, 1000, 1000]; m = sum(args); parfor_progress(m); parfor ii = 1:size(args,2) my_fun(args(ii)); end parfor_progress(0); end function my_fun(N) for ii = 1:N pause(rand*0.01); parfor_progress; end end function mycleaner matlabpool close; fclose all; end
arglist = [arg1, arg2, arg3, arg4]; parfor_progress(size(arglist, 2)); % Set the total number of iterations parfor ii = 1:size(arglist, 2) myfun(arglist(ii)); parfor_progress; % Increment the progress counter end parfor_progress(0); % Reset the progress counter
fprintf( showTimeToCompletion; startTime=tic; len=1e2; p = parfor_progress( len ); parfor i = 1:len pause(1); p = parfor_progress; showTimeToCompletion( p/100, [], [], startTime ); end
Completion: 31.00% Remaining: 00:00:23 Total: 00:00:33 Expected Finish: 3:30:07PM 14-Nov-2017
if isempty(gcp( parpool( end dq = parallel.pool.DataQueue; N = 10; wb = waitbar(0, % Use the waitbar wb.UserData = [0 N]; afterEach(dq, @(varargin) iIncrementWaitbar(wb)); afterEach(dq, @(idx) fprintf( parfor idx = 1:N pause(rand()); send(dq, idx); end close(wb); function iIncrementWaitbar(wb) ud = wb.UserData; ud(1) = ud(1) + 1; waitbar(ud(1) / ud(2), wb); wb.UserData = ud; end
N = 100; for idx = N:-1:1 % Compute the rank of N magic squares F(idx) = parfeval(@rank, 1, magic(idx)); end % Build a waitbar to track progress h = waitbar(0, results = zeros(1, N); for idx = 1:N [completedIdx, thisResult] = fetchNext(F); % store the result results(completedIdx) = thisResult; % update waitbar waitbar(idx/N, h, sprintf( end % Clean up delete(h)
function out = hslice(ndarray, d, i) sz = size(ndarray); pfx = sz(1:d-1); % dimensions before d sfx = sz(d+1:end); % dimensions after d tmp = reshape(ndarray, prod(pfx), sz(d), prod(sfx)); out = reshape(tmp(:, i, :), [pfx 1 sfx]); end
function out = slice(A, ix, dim) subses = repmat({ subses{dim} = ix; out = A(subses{:});
function A = slice_assign(A, ix, dim, B) %SLICE_ASSIGN Assign new values to a "slice" of A subses = repmat({ subses{dim} = ix; A(subses{:}) = B;
function out = slice_subs(A, ix, dim) subses = repmat({ subses{dim} = ix; out = subses;
function out = hslice(ndarray, d, i) subdims = setdiff(1:ndims(ndarray),d); sz = size(ndarray); outsz = sz(subdims); order = [d subdims]; ndarray = permute(ndarray,order); out = reshape(ndarray(i,:),outsz); end
d = 3; i = 2; nd = randi(23,3,3,3,2); out = hslice(nd,d,i); % out = squeeze(nd(:,:,i,:)) for d=3
>> X = hpf( X = 1.2 >> X^723 - 2 ans = 1770275636625441478440184064843963160282702377364043536065.674784028 335311702907341138106304578079399191891193908698215227428501441099262538 4031886249461115861966367898404170725299823585166135087107488
>> DefaultNumberOfDigits 200 >> hpf( ans = 3.141592653589793238462643383279502884197169399375105820974944592307 816406286208998628034825342117067982148086513282306647093844609550582231 7253594081284811174502841027019385211055596446229489549303819
>> tic,sin(hpf( ans = 0 Elapsed time is 0.201679 seconds.
... catch exception failedFiles = [failedFiles; { continue end
[x, y, z] = ellipsoid(0, 0, 0, 4, 1, 1); % Make an ellipsoid shape hMesh = mesh(x, y, z); % Plot the shape as a mesh axis equal % Change the axis scaling for longAxis = 4:-0.1:1 [x, y, z] = ellipsoid(0, 0, 0, longAxis, 1, 1); % Make a new ellipsoid set(hMesh, pause(0.25); % Pause for 1/4 second end
function timer_fcn(obj,event,hMesh) n = get(obj, % timer has fired already [x, y, z] = ellipsoid(0, 0, 0, 4-(3*n/40), 1, 1); % Make a new ellipsoid set(hMesh, drawnow; % Force the display to update end
[x, y, z] = ellipsoid(0, 0, 0, 4, 1, 1); % Make an ellipsoid shape hMesh = mesh(x, y, z); % Plot the shape as a mesh axis equal % Change the axis scaling animationTimer = timer( start(animationTimer); % Start timer, which runs on its own until it ends
% [xs,ys,zs] = sphere; % % [xe,ye,ze] = ellipsoid(0,0,0,4,1,1); % anymate(@surf,{cat(3,xe,xs) cat(3,ye,ys) cat(3,ze,zs)}); % colormap(jet); % axis equal
load sumsin; s = sumsin+10; % example data series time = linspace(0,5*24,1000); figure(1); subplot(311); plot(time,s, subplot(312); plot(time,s, hold on; [s_denoised,~, ~] = wden(s, plot(time,s_denoised, subplot(313); plot(time,s, hold on; plot(time,s_denoised, xlim([20 40]);
t = linspace(0, 120, 1000); s_denoised = sin(t / 2); s = s_denoised + 0.2 * randn(size(s_denoised)); subplot(3, 1, 1), plot(t, s, subplot(3, 1, 2), plot(t, s, subplot(3, 1, 3), plot(t, s,
annotation( annotation( annotation( annotation( annotation(
classdef CacheableFunction < handle properties exeFun hashFun cacheMap nOutputs zipOutput end methods function obj = CacheableFunction(exeFun, hashFun, nOutputs) obj.exeFun = exeFun; obj.hashFun = hashFun; obj.cacheMap = containers.Map; obj.nOutputs = nOutputs; obj.zipOutput = []; end function [result] = evaluate(obj, varargin) thisKey = obj.hashFun(varargin); if isKey(obj.cacheMap, thisKey) if obj.zipOutput result = cellfun(@(x) dunzip(x), obj.cacheMap(thisKey), else result = obj.cacheMap(thisKey); end else [result{1:obj.nOutputs}] = obj.exeFun(varargin); if isempty(obj.zipOutput) obj.zipCheck(result); end if obj.zipOutput obj.cacheMap(thisKey) = cellfun(@(x) dzip(x), result, else obj.cacheMap(thisKey) = result; end end end function [] = zipCheck(obj,C) obj.zipOutput = all(cellfun(@(x) isreal(x) & ~issparse(x) & any(strcmpi(class(x), ... { end end end
function [] = test_caching_perf() A = CacheableFunction(@(x) long_annoying_function(x{:}), @(x) DataHash(x), 3); B = rand(50, 50); C = rand(50, 50); D = rand(50, 50); tic; myOutput = A.evaluate(B, C, D); toc tic; myOutput2 = A.evaluate(B, C, D); toc cellfun(@(x, y) all(x(:) == y(:)), myOutput, myOutput2) end function [A, B, C] = long_annoying_function(A, B, C) for ii = 1:5000000 A = A+1; B = B+2; C = C+3; end end
>> test_caching_perf Elapsed time is 16.781889 seconds. Elapsed time is 0.011116 seconds. ans = 1 1 1
[maxValue,indexMax] = max(abs(fft(signal-mean(signal))));
clear all clc close all Fs = 1; T = 11 % Note this T is deliberately chosen , so that we have about 1.7 cycle of cosine singal t = 0:Fs:T; % T seconds L = length(t); % L is the length of sample sequence bias = 4 signal = sin(t) + bias; [maxValue,indexMax] = max(abs(fft(signal-mean(signal)))); frequency_method1 = (indexMax-1) * Fs / (L-1); frequency_method2 = (indexMax-1) * Fs / L; number_of_cycles_method1 = frequency_method1*T number_of_cycles_method2 = frequency_method2*T subplot(2,1,1) plot(t,signal, legend( subplot(2,1,2) plot(abs(fft(signal-mean(signal))), legend( number_of_cycles_method1 = 2 number_of_cycles_method2 = 1.8333
clear; theta=linspace(0,2*pi,31);theta=theta(1:end-1); [x,y]=pol2cart(theta,1);
links=triu(round(rand(length(theta))));% [ind1,ind2]=ind2sub(size(links),find(links(:)));
h=figure(1);clf(h); plot(x,y, arrayfun(@(p,q)line([x(p),x(q)],[y(p),y(q)]),ind1,ind2); axis equal off
% A = bucky(); N = length(A); % r = 1; theta = linspace(0,2*pi,N+1) xy = r .* [cos(theta) sin(theta)]; % txt = cellstr(num2str((1:N) % line(xy(:,1), xy(:,2), hold on gplot(A, xy, axis([-1 1 -1 1]); axis equal off hold off % h = text(xy(:,1).*1.05, xy(:,2).*1.05, txt, set(h, {
primes = [2,3,5,7,11,13]; if primes(primes==3) disp( else disp( end
>> b = 1:1000000; >> tic; for i=1:100000, any(b==i);; end; toc Elapsed time is 125.925922 seconds. s = java.util.HashSet(); >> for i=1:1000000, s.add(i); end >> tic; for i=1:100000, s.contains(i); end; toc Elapsed time is 25.618276 seconds. >> m = containers.Map(1:1000000,ones(1,1000000)); >> tic; for i=1:100000, m(i); end; toc Elapsed time is 2.715635 seconds
>> m = java.util.HashMap; >> m.put(1, >> m.get(1) ans = hello, world
>> m = containers.Map( >> m(1) = 3.14; >> m(1) ans = 3.14
>> s = java.util.HashSet; >> s.put(1); >> s.contains(1) ans = 1 >> s.contains(2) ans = 0
>> biglist = 1:100000; >> tic;for i=1:10000 find(biglist==i,1, end toc Elapsed time is 1.055928 seconds. >> tic;for i=1:10000 any(biglist==i); end toc Elapsed time is 1.054392 seconds.
% If m is known (m = 3 here), you could write it out all at once yy = [y == 1; y== 2; y == 3]; yy = reshape(yy, n, 3);
% if m is not known ahead of time yy = [ y == 1 ]; for i = 2:m; yy = [ yy; y == i ]; end yy = reshape(yy, n, m);
% A n-dimensional vector y, with values in some range 1..m m = 4; n = 7; y = randi([1 m], n, 1); % Preallocating a n by m matrix of zeros nXm = zeros(n, m); % In each pass of this loop a single column of nXm is updated, where % for each column index j in nXm, if y(i) = j then nXm(i,j) = 1 for j = 1:m; nXm(:,j) = (y == j); end
>> A = randn(10,3) A = 0.8884 -0.10224 -0.86365 -1.1471 -0.24145 0.077359 -1.0689 0.31921 -1.2141 -0.8095 0.31286 -1.1135 -2.9443 -0.86488 -0.0068493 1.4384 -0.030051 1.5326 0.32519 -0.16488 -0.76967 -0.75493 0.62771 0.37138 1.3703 1.0933 -0.22558 -1.7115 1.1093 1.1174 >> [maxVal maxInd] = max(A) maxVal = 1.4384 1.1093 1.5326 maxInd = 6 10 6
% A = magic(4) A = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1 % [maxValue, rowIdx] = max(A(:,3),[],1) maxValue = 15 rowIdx = 4
local_mean = imfilter(X, filt, local_std = sqrt(imfilter(X .^ 2, filt, X_bin = X >= (local_mean + k_threshold * local_std);
function Example() semkey=1234; semaphore( funList = {@fun,@fun,@fun}; parfor i=1:length(funList) funList{i}(semkey); end end function fun(semkey) semaphore( disp( semaphore( end
imwrite(fileName); movefile(fileName, completedFileName);
wordApplication = actxserver( wordApplication.Visible = 1; wordApplication.Documents.Add; selection = wordApplication.Selection; umbrella = char(9730); disp(umbrella) selection.TypeText(umbrella)
% Define a string to send with a non-ASCII character. umbrella = char(9730); toSend = [ disp(toSend) % Open a new Word document. wordApplication = actxserver( wordApplication.Visible = 1; wordApplication.Documents.Add; % Send the text. selection = wordApplication.Selection; selection.TypeText(toSend)
wordApplication = actxserver( wordApplication.Visible = 1; wordApplication.Documents.Add; disp(wordApplication.ActiveDocument.TextEncoding) wordApplication.ActiveDocument.TextEncoding = 65001; disp(wordApplication.ActiveDocument.TextEncoding) selection = wordApplication.Selection; toSend = sprintf( selection.TypeText(toSend)
umbrella = 9730; % selection.InsertSymbol(umbrella,
umbrella = 9730; % selection.TypeText(dec2hex(umbrella)); selection.ToggleCharacterCode;
umbrella = char(9730); toSend = [ clipboard( selection.Paste %
csc.exe /nologo /target:library /out:MyOfficeInterop.dll /reference:"C:\Program Files (x86)\Microsoft Visual Studio 12.0\Visual Studio Tools for Office\PIA\Office15\Microsoft.Office.Interop.Word.dll" MSWord.cs
% NET.addAssembly( % fname = fullfile(pwd, fclose(fopen(fname, % str = [ % word = MyOfficeInterop.MSWord(); word.AppendTextToDocument(fname, str);
% fnameTXT = fullfile(pwd, fnameDOCX = fullfile(pwd, str = [ % bytes = unicode2native(str, fid = fopen(fnameTXT, fwrite(fid, bytes); fclose(fid); % msoEncodingUTF8 = int32(hex2dec( wdOpenFormatUnicodeText = int32(hex2dec( wdFormatDocumentDefault = int32(hex2dec( wdDoNotSaveChanges = int32(hex2dec( % Word = actxserver( %Word.Visible = true; % doc = Word.Documents.Open(... fnameTXT, ... % FileName [], ... % ConfirmConversions [], ... % ReadOnly [], ... % AddToRecentFiles [], ... % PasswordDocument [], ... % PasswordTemplate [], ... % Revert [], ... % WritePasswordDocument [], ... % WritePasswordTemplate wdOpenFormatUnicodeText, ... % Format msoEncodingUTF8, ... % Encoding [], ... % Visible [], ... % OpenAndRepair [], ... % DocumentDirection [], ... % NoEncodingDialog []); % XMLTransform % doc.SaveAs2(... fnameDOCX, ... % FileName wdFormatDocumentDefault, ... % FileFormat [], ... % LockComments [], ... % Password [], ... % AddToRecentFiles [], ... % WritePassword [], ... % ReadOnlyRecommended [], ... % EmbedTrueTypeFonts [], ... % SaveNativePictureFormat [], ... % SaveFormsData [], ... % SaveAsAOCELetter msoEncodingUTF8, ... % Encoding [], ... % InsertLineBreaks [], ... % AllowSubstitutions [], ... % LineEnding [], ... % AddBiDiMarks []), % CompatibilityMode % doc.Close(wdDoNotSaveChanges, [], []) Word.Quit() clear doc Word
m = 500; n = 10; % setting parameters A = ((1:m) idxs1 = squareform(tril(A idxs2 = squareform(tril(A, -1)) all_pairs = [idxs1, idxs2]; % this contains all possible pairs idx_to_use = randperm( size(all_pairs, 1), n ); % choosing random n pairs pairs = all_pairs(idx_to_use, :) pairs = 254 414 247 334 111 146 207 297 45 390 229 411 9 16 75 395 12 338 25 442
{[1,2], [1,3], [2,3], [1,4], [2,4], [3,4], ..., [m-1,m]}
q = floor(sqrt(8*(k-1) + 1)/2 + 1/2); p = k - q.*(q-1)/2;
k = 1:21; q = floor(sqrt(8*(k-1) + 1)/2 + 3/2); p = k - (q-1).*(q-2)/2; [k;p;q]' ans = 1 1 2 2 1 3 3 2 3 4 1 4 5 2 4 6 3 4 7 1 5 8 2 5 9 3 5 10 4 5 11 1 6 12 2 6 13 3 6 14 4 6 15 5 6 16 1 7 17 2 7 18 3 7 19 4 7 20 5 7 21 6 7
m = 5; n = 10; k = randperm(m/2*(m-1),n); q = floor(sqrt(8*(k-1) + 1)/2 + 3/2); p = k - (q-1).*(q-2)/2; sortrows([p;q] ans = 1 2 1 3 2 3 1 4 2 4 3 4 1 5 2 5 3 5 4 5
tic m = 1e6; n = 100000; k = randperm(m/2*(m-1),n); q = floor(sqrt(8*(k-1) + 1)/2 + 3/2); p = k - (q-1).*(q-2)/2; toc Elapsed time is 0.014689 seconds.
x[n] = rand() x[n + 1] = x[n] + rand() %% where rand can be equal to 0.
n = 10000; m = 500; my_list = unique(sort(round(rand(n,2)*m),2), my_list = my_list(find((my_list(:,1)==my_list(:,2))==0),:); %temp = my_list; %In case you want to check what you initially generated. while(size(my_list,1)~=n) %my_list = unique([my_list;sort(round(rand(1,2)*m),2)], %Changed as per @jucestain my_list = unique([my_list;sort(round(rand((n-size(my_list,1)),2)*m),2)], my_list = my_list(find((my_list(:,1)==my_list(:,2))==0),:); end
classdef myClass properties % some properties here... end methods ( Access = function obj = myClass() % constructor... end function obj = delete( obj ) % suppose to be destructor... fprintf(1, end end % public methods end
classdef myTestClass properties % some properties here... end properties (Hidden) cleanup end methods ( Access = function obj = myTestClass() % constructor... obj.cleanup = onCleanup(@()delete(obj)); end end methods ( Access = % % function obj = delete( obj ) fprintf(1, end end % public methods end
0 0 0.0070 0.0080 0.0030 0.0010 0 0.0030 -0.0460 0.0400 -0.0930 0.1800 0.0010 -0.0530 -0.0140 -0.0620 0.0790 -1.2360 0.0020 0.0009 -0.0032 0.0016 0.0023 -1.4180 0.0070 -0.0000 -0.0006 -0.0000 0 0
y = cool(7); % ah = axes; % bar3(ah,y*1E6, tick2text(ah,
y = cool(7); bar3(y*1e6, offset = 0.25; Xl=get(gca, t = text(Xl(ones(size(Zt))),Yl(ones(size(Zt)))-offset,Zt, num2str(Zt set(t, set(gca,
scale = 10^floor(log10(max(y))); % plot(x,y./scale); % yTicks = get(gca, set(gca,
M = logical(round(rand(3,3))); % mask D = randn(3,3,2); % data % try getting x,y pairs of elements to be masked [x,y] = ind2sub(size(M),find(M == 0)); D_masked = D; D_masked(x,y,:) = NaN; % does not work! % do it the old-fashioned way D_masked = D; for iX = 1:size(M,1) for iY = 1:size(M,2) if ~M(iX,iY), D_masked(iX,iY,:) = NaN; end end end
D_masked = D; D_masked(repmat(~M,[1 1 size(D,3)])) = NaN;
D_masked = D; index = bsxfun(@plus,find(~M),(0:(size(D,3)-1)).*numel(M)); D_masked(index) = NaN;
B = zeros(size(A)); % for i=1:size(A,1) for j=1:size(A,2) H = ... % B(i,j) = computeSth(H); % end end
[X Y] = meshgrid(10:50); Z = X.*Y; Z(10:30,10:30) = NaN; figure imshow(uint8(repmat(1:4:240,[60,1,3]))); hold on; contourf(X,Y,Z); colormap jet;
[X Y] = meshgrid(10:0.1:50); Z = X.*Y; Z(100:300,100:300) = NaN; figure hold on; h = pcolor(X,Y,round(Z/500)*500); set(h, colormap jet; set(gca,
[X Y] = meshgrid(10:50); Z = X.*Y; Z(10:30,10:30) = NaN; figure imshow(uint8(repmat(1:4:240,[60,1,3]))); hold on; h = pcolor(X,Y,Z) set(h, colormap jet;
x=0:.1:10; y=sin(x); figure pos=get(gca, pos(3)=.5; % set(gca, plot(x,y)
% x=0:.1:10; y=sin(x); hAx1 = axes( hAx2 = axes( hAx3 = axes( % h = legend(hAx2, set(h,
fps = zeros(1, 100); for i=1:100 t = tic I = fetch_image_from_source(); % function to get image fps(i) = 1./ toc(t); end plot(fps);
fps = zeros(1, 100); figure; for i=1:100 t = tic I = fetch_image_from_source(); % function to get image fps(i) = 1./ toc(t); imshow(I); drawnow; end plot(fps);
(1) for ii=1:100 t = tic; %single tic/toc fps(ii,2) = 1./toc(t); rand(1000); %extra function outside tic/toc end
(2) for ii=1:100 t = tic; %first tic/toc fps(ii,2) = 1./toc(t); t = tic; %second tic/toc fps(ii,2) = 1./toc(t); rand(1000); %extra function outside tic/toc end
(3) for ii=1:100 t = tic; %first tic/toc fps(ii,2) = 1./toc(t); for ij = 1:10000 %10,000 extra tic/toc tic; tmp = toc; end end
(4) for ii=1:100 %first tic/toc block t = tic; fps(ii,1) = 1./toc(t); end for ii=1:100 %second tic/toc block t = tic; fps(ii,2) = 1./toc(t); end
%% EXTRA FUNCTION (single call) fps = zeros(2, 100); % first case: 100 tic/toc for ii=1:100 t = tic; fps(ii,1) = 1./toc(t); end %second case: 100 tic/toc + additional function for ii=1:100 t = tic; fps(ii,2) = 1./toc(t); % graph or scalar functions (uncomment to test) %drawnow; %plot(1:10) rand(1000); %ones(1000, 1000); %sum(1:1000000); %diff(1:1000000); end h = figure( subplot(4,1,1); plot(fps); legend({ ylabel( title( set(gca, %% EXTRA FUNCTION (double call) fps = zeros(2, 100); % first case: 100 tic/toc for ii=1:100 t = tic; fps(ii,1) = 1./toc(t); end %second case: 100 tic/toc + additional function (except tic/toc) for ii=1:100 %first call t = tic; fps(ii,2) = 1./toc(t); %second call (identical to first) t = tic; fps(ii,2) = 1./toc(t); rand(1000); end subplot(4,1,2); plot(fps); legend({ ylabel( title( set(gca, %% EXTRA FUNCTION (double call) fps = zeros(2, 100); % first case: 100 tic/toc for ii=1:100 t = tic; fps(ii,1) = 1./toc(t); end %second case: 100 tic/toc + 10000 tic/toc for ii=1:100 t = tic; fps(ii,2) = 1./toc(t); for ij = 1:10000 tic; tmp = toc; end end subplot(4,1,3); plot(fps); legend({ ylabel( title( set(gca, %% TIC/TOC call twice fps = zeros(2, 100); % first case: 100 tic/toc for ii=1:100 t = tic; fps(ii,1) = 1./toc(t); end for ii=1:100 t = tic; fps(ii,2) = 1./toc(t); end subplot(4,1,4); plot(fps); legend({ ylabel( title( set(gca,
for i = 1:size(w_prime,1) indY = dY == i; for j = 1:size(w_prime,2) indX = dX == j; w_prime(ind) = mean( w( indY & indX ) ); end end
nx = max(dX(:)); ny = max(dY(:)); w_prime = accumarray([dX(:),dY(:)],w(:),[nx,ny],@mean,NaN)
10:03:12 AM Friday, October 30, 2015: ------------------------------------------------------------------------------------------------- 10:03:12 AM Friday, October 30, 2015: [SDKSetup:Info] Begin 10:03:12 AM Friday, October 30, 2015: [SDKSetup:Info] SDKSetup Version 7.1.7600.30111 10:03:16 AM Friday, October 30, 2015: [SDKSetup:Info] SDKSetupDll_DoTasks: Starting 10:03:16 AM Friday, October 30, 2015: [SDKSetup:Info] SDKSetupDll_DoTasksWithGUI: Starting 10:03:17 AM Friday, October 30, 2015: [SDKSetup:Info] Config_OS_Detect: Operating system installation (detected) 10:03:18 AM Friday, October 30, 2015: [SDKSetup:Info] Config_MSI_Detect: Windows Installer Setup (detected) 10:03:18 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineProductState_Begin: Product: Microsoft Windows SDK for Windows 7 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineProductState_End: Product: Microsoft Windows SDK for Windows 7 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: NativeDev 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: NativeDev; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: NativeDev 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: ManagedDev 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: ManagedDev; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: ManagedDev 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: CommonTools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: CommonTools; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: CommonTools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: RedistComponents 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: RedistComponents; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: RedistComponents 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_WinSDK 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_WinSDK; Installed: Absent; Request: Local; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_WinSDK 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_SFX 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_SFX; Installed: Absent; Request: Local; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_SFX 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_WinSDK_VC_Integration 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_WinSDK_VC_Integration; Installed: Absent; Request: Local; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_WinSDK_VC_Integration 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKBuild_WinSDKBuild 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKBuild_WinSDKBuild; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKBuild_WinSDKBuild 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKTools_WinSDK_BIN_DevTools_Desktop 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKTools_WinSDK_BIN_DevTools_Desktop; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKTools_WinSDK_BIN_DevTools_Desktop 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_WinSDK_BIN 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_WinSDK_BIN; Installed: Absent; Request: Local; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_WinSDK_BIN 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKBuild_VistaHeadersLibs_VistaHeaders 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKBuild_VistaHeadersLibs_VistaHeaders; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKBuild_VistaHeadersLibs_VistaHeaders 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_X86 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_X86; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_X86 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_X64 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_X64; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_X64 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_IA64 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_IA64; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKBuild_VistaHeadersLibs_VistaLibs_IA64 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKCompiler_WinSDKCompiler_X64_Compilers 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKCompiler_WinSDKCompiler_X64_Compilers; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKCompiler_WinSDKCompiler_X64_Compilers 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_WinSDK_RDC_X86_CRT 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_WinSDK_RDC_X86_CRT; Installed: Absent; Request: Local; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_WinSDK_RDC_X86_CRT 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_WinSDK_RDC_X64_CRT 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_WinSDK_RDC_X64_CRT; Installed: Absent; Request: Local; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_WinSDK_RDC_X64_CRT 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_WinSDK_RDC_IA64_CRT 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_WinSDK_RDC_IA64_CRT; Installed: Absent; Request: Local; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_WinSDK_RDC_IA64_CRT 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKNetFx40Tools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKNetFx40Tools; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKNetFx40Tools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKInterop_Headers 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKInterop_Headers; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKInterop_Headers 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKInterop_X64Libs 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKInterop_X64Libs; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKInterop_X64Libs 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKInterop_x86Libs 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKInterop_x86Libs; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKInterop_x86Libs 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKInterop_IA64Libs 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKInterop_IA64Libs; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKInterop_IA64Libs 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: F_NetFx_DTP 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: F_NetFx_DTP; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: F_NetFx_DTP 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: IntellisenseNFX 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: IntellisenseNFX; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: IntellisenseNFX 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_WinSDK_SMP_Win32 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_WinSDK_SMP_Win32; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_WinSDK_SMP_Win32 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKBuild_VistaHeadersLibs 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKBuild_VistaHeadersLibs; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKBuild_VistaHeadersLibs 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKWin32Tools_WinSDKWin32Tools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKWin32Tools_WinSDKWin32Tools; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKWin32Tools_WinSDKWin32Tools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKCompiler_WinSDKCompiler 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKCompiler_WinSDKCompiler; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKCompiler_WinSDKCompiler 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: Intellisense_RefAssy 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: Intellisense_RefAssy; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: Intellisense_RefAssy 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKInterop_WinSDKInterop 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKInterop_WinSDKInterop; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKInterop_WinSDKInterop 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKNetFxTools_WinSDKNetFxTools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKNetFxTools_WinSDKNetFxTools; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKNetFxTools_WinSDKNetFxTools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKHelp 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKHelp; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKHelp 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKApplicationVerifier 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKApplicationVerifier; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKApplicationVerifier 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKPerformanceToolkit 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKPerformanceToolkit; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKPerformanceToolkit 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKDebuggingTools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKDebuggingTools; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKDebuggingTools 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDK_WinSDK_RDC 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDK_WinSDK_RDC; Installed: Absent; Request: Local; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDK_WinSDK_RDC 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: AppVerifierRedistComponents 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: AppVerifierRedistComponents; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: AppVerifierRedistComponents 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: DebuggingToolsRedistComponents 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: DebuggingToolsRedistComponents; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: DebuggingToolsRedistComponents 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_Begin: Feature: WinSDKRedistComponents 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState: Feature: WinSDKRedistComponents; Installed: Absent; Request: None; 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Info] Config_Products_DetermineFeatureState_End: Feature: WinSDKRedistComponents 10:53:42 AM Friday, October 30, 2015: [SDKSetup:Error] Config_Products_Detect: Windows SDK installation (User Cancelled): [SDKSetup:Error] The user cancelled the current operation. Stack: at SDKSetup.ConfigProducts.DoCurrentTask(TaskMode Task)
%get corner pixel coords from base image p1=[33;150;1]; p2=[316;136;1]; p3=[274;22;1]; p4=[63;34;1]; por=[p1 p2 p3 p4]; por=[0 1 0;1 0 0;0 0 1]*por; %swap x-y <-------------------- %calculate target image coordinates in world frame % rig is 9x7 (X,Y) with 27.5mm box edges XXw=[[0;0;0] [0;27.5*9;0] [27.5*7;27.5*9;0] [27.5*7;0;0]]; Rtarget=[0 1 0;1 0 0;0 0 -1]; %Rotation matrix of target camera (vertical pose) XXc=Rtarget*XXw+Tc_ext*ones(1,4); %go from world frame to camera frame xn=XXc./[XXc(3,:);XXc(3,:);XXc(3,:)]; %calculate normalized coords xpp=KK*xn; %calculate target pixel coords % get homography matrix from original to target image HH=homography2d(por,xpp); %do perspective transformation to validate homography pnew=HH*por./[HH(3,:)*por;HH(3,:)*por;HH(3,:)*por];
% corner coords in pixels p1=[33;150;1]; p2=[316;136;1]; p3=[274;22;1]; p4=[63;34;1]; pmat=[p1 p2 p3 p4]; pmat=[0 1 0;1 0 0;0 0 1]*pmat; %swap x-y R=[0 1 0;1 0 0;0 0 1]; %rotation matrix of final camera pose Rmat=Rc_ext H=KK*Rmat*inv_KK; %homography matrix pnew=H*pmat./[H(3,:)*pmat;H(3,:)*pmat;H(3,:)*pmat]; %do perspective transformation H2=[0 1 0;-1 0 0;0 0 1]*H; %swap x-y in the homography matrix to apply in image
KK = [fc(1) fc(1)*alpha_c cc(1);0 fc(2) cc(2); 0 0 1]; H = KK * [R(:,1) R(:,2) Tc]; % where R is your extrinsic rotation matrix and Tc the translation matrix H = H / H(3,3);
[X, Y] = meshgrid(0:size(I,2)-1, 0:size(I,1)-1); im_coord = [X(:), Y(:), ones(prod(size(I_1)))] % Insert projection here for X and Y to XI and YI ZI = interp2(X,Y,Z,XI,YI);
% Solve an Autoregression Time-Series Problem with a NAR Neural Network % Script generated by NTSTOOL % Created Tue Mar 05 22:09:39 EST 2013 % % This script assumes this variable is defined: % % close_data - feedback time series. targetSeries = tonndata(close_data_short,false,false); % Create a Nonlinear Autoregressive Network feedbackDelays = 1:3; hiddenLayerSize = 10; net = narnet(feedbackDelays,hiddenLayerSize); % Choose Feedback Pre/Post-Processing Functions % Settings for feedback input are automatically applied to feedback output % For a list of all processing functions type: help nnprocess net.inputs{1}.processFcns = { % Prepare the Data for Training and Simulation % The function PREPARETS prepares timeseries data for a particular network, % shifting time by the minimum amount to fill input states and layer states. % Using PREPARETS allows you to keep your original time series data unchanged, while % easily customizing it for networks with differing numbers of delays, with % open loop or closed loop feedback modes. [inputs,inputStates,layerStates,targets] = preparets(net,{},{},targetSeries); % Setup Division of Data for Training, Validation, Testing % For a list of all data division functions type: help nndivide net.divideFcn = net.divideMode = net.divideParam.trainRatio = 70/100; net.divideParam.valRatio = 15/100; net.divideParam.testRatio = 15/100; % Choose a Training Function % For a list of all training functions type: help nntrain net.trainFcn = % Choose a Performance Function % For a list of all performance functions type: help nnperformance net.performFcn = % Choose Plot Functions % For a list of all plot functions type: help nnplot net.plotFcns = { % Train the Network [net,tr] = train(net,inputs,targets,inputStates,layerStates); % Test the Network outputs = net(inputs,inputStates,layerStates); errors = gsubtract(targets,outputs); performance = perform(net,targets,outputs) % Recalculate Training, Validation and Test Performance trainTargets = gmultiply(targets,tr.trainMask); valTargets = gmultiply(targets,tr.valMask); testTargets = gmultiply(targets,tr.testMask); trainPerformance = perform(net,trainTargets,outputs) valPerformance = perform(net,valTargets,outputs) testPerformance = perform(net,testTargets,outputs) % View the Network view(net) % Plots % Uncomment these lines to enable various plots. %figure, plotperform(tr) %figure, plottrainstate(tr) %figure, plotresponse(targets,outputs) %figure, ploterrcorr(errors) %figure, plotinerrcorr(inputs,errors) % Closed Loop Network % Use this network to do multi-step prediction. % The function CLOSELOOP replaces the feedback input with a direct % connection from the outout layer. netc = closeloop(net); [xc,xic,aic,tc] = preparets(netc,{},{},targetSeries); yc = netc(xc,xic,aic); perfc = perform(net,tc,yc) % Early Prediction Network % For some applications it helps to get the prediction a timestep early. % The original network returns predicted y(t+1) at the same time it is given y(t+1). % For some applications such as decision making, it would help to have predicted % y(t+1) once y(t) is available, but before the actual y(t+1) occurs. % The network can be made to return its output a timestep early by removing one delay % so that its minimal tap delay is now 0 instead of 1. The new network returns the % same outputs as the original network, but outputs are shifted left one timestep. nets = removedelay(net); [xs,xis,ais,ts] = preparets(nets,{},{},targetSeries); ys = nets(xs,xis,ais); closedLoopPerformance = perform(net,tc,yc)
inputs = X; %define input and target targets = y; hiddenLayerSize = 10; net = patternnet(hiddenLayerSize); % Set up Division of Data for Training, Validation, Testing net.divideParam.trainRatio = 70/100; net.divideParam.valRatio = 15/100; net.divideParam.testRatio = 15/100; [net,tr] = train(net,inputs,targets); outputss(x,:) = net(inputs); errors = gsubtract(targets,outputss); mse(errors)
date = datestr(unix_time/86400 + datenum(1970,1,1))
date = datestr(unix_time/86400/1000 + datenum(1970,1,1))
function dn = unixtime_to_datenum( unix_time ) dn = unix_time/86400 + 719529; % end function dn = unixtime_in_ms_to_datenum( unix_time_ms ) dn = unix_time_ms/86400000 + 719529; % end datestr( unixtime_to_datenum( unix_time ) )
dirName = files = dir( fullfile(dirName, files = {files.name} data = cell(numel(files),1); % for i=1:numel(files) fname = fullfile(dirName,files{i}); % data{i} = myLoadFunction(fname); % end
dirName = [sub,fls] = subdir(dirName); D = []; j = 1; for i=1:length(sub), files{i} = dir( fullfile(sub{i}, if length(files{i})==1 D(j) = i; files_s{j} = sub{i}; j=j+1; end end
hLine = plot(nan); % Initialize a plot line (which isn % because the values are NaN) for i = 1:N % Loop N times ... % Compute m here ... set(hLine, drawnow % Force the graphics to update immediately end
for i = 1:length(DATASET1) pause(0.1) plot(DATASET1(i),DATASET2(i)) draw on end
% x = 1:1000; y = x.^2; % figure,hold on % xlim([min(x(:)) max(x(:))]) ylim([min(y(:)) max(y(:))]) % for k = 1:numel(x) plot(x(k),y(k), % %% pause(0.001); end
h = plot(NaN,NaN); % axis([min(DATASET1) max(DATASET1) min(DATASET2) max(DATASET2)]); % % for ii = 1:length(DATASET1) pause(0.01) set(h, drawnow % end
frame = getframe(1); im = frame2im(frame); [imind,cm] = rgb2ind(im,256); if ii == 1; imwrite(imind,cm,filename, else imwrite(imind,cm,filename, end
h = animatedline; axis([0,4*pi,-1,1]) x = linspace(0,4*pi,1000); y = sin(x); for k = 1:length(x) addpoints(h,x(k),y(k)); drawnow end
theta(i) = theta(i) - (alpha/m)*sum((X*theta-y).*X(:,i))
a=[1,2,3;1,3,5;2,2,2] ind_plain = find(a == 2) [row_indx col_indx] = ind2sub(size(a), ind_plain) for el_id=1:length(row_indx) a(row_indx(el_id),col_indx(el_id)) = -5; end
function mapout = changem(Z, newcode, oldcode) % Idential to the Mapping Toolbox % Note the weird order: newcode, oldcode. I left it unchanged from Matlab. if numel(newcode) ~= numel(oldcode) error( end mapout = Z; for ii = 1:numel(oldcode) mapout(Z == oldcode(ii)) = newcode(ii); end end
Q = [ 1 2 3 ; 4 2 3 ; 5 6 7 ; 1 2 3 ; 1 2 3 ; 1 2 5 ]; r = [ 1 2 3 ];
>> bsxfun(@eq, r, Q) ans = 1 1 1 0 1 1 0 0 0 1 1 1 1 1 1 1 1 0
a = [1 1 1; 2 2 2; 3 3 3]; b = a(1:2,;); [temp locb] = ismember(a,b, b(locb(locb~=0),:) ans = 1 1 1 2 2 2
a = [1 2 3; 4 5 6; 7 8 9]; t = [4 5 6]; [x,y] = size(a); r = all(a==repmat(t,y,1), 2)'
/usr/lib/gcc/i686-linux-gnu/4.7/cc1plus: /usr/local/MATLAB/R2012a/sys/os/glnx86/libstdc++.so.6: version `GLIBCXX_3.4.15 (required by /usr/lib/i386-linux-gnu/libppl_c.so.4) /usr/lib/gcc/i686-linux-gnu/4.7/cc1plus: /usr/local/MATLAB/R2012a/sys/os/glnx86/libstdc++.so.6: version `GLIBCXX_3.4.15 (required by /usr/lib/i386-linux-gnu/libppl.so.9)
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/libstdc++.so.6 ./matlab
cd /usr/local/matlab/sys/os/glnxa64 mv libstdc++.so.6 libstdc++.so.6.bak ln -s /usr/lib64/libstc++.so.6 libstc++.so.6 cd /usr/local/src/matlab/bin/glnxa64/ mv libstdc++.so.6 libstdc++.so.6.bak ln -s /usr/lib64/libstc++.so.6 libstc++.so.6
classdef Packet properties HeaderLength PayloadLength PacketType end end
classdef Packet properties HeaderLength@uint16 PayloadLength@uint16 = uint16(0); PacketType@char end end
>> p = Packet; >> p.PacketType = >> p.HeaderLength = 100; While setting the Value must be
classdef Packet properties HeaderLength uint16 PayloadLength uint16 = uint16(0); PacketType char end end
classdef MyPropClass1 methods % The following method is only used in R2016a case function obj=MyPropClass1(val) end end end ------------------------------------------------------------ classdef MyPropClass2 < MyPropClass1 end ------------------------------------------------------------ classdef MyObjClass properties someprop@MyPropClass1 end end ------------------------------------------------------------ myObj = MyObjClass(); myObj.someprop = MyPropClass2; % The following displays "MyPropClass1" in R2016a, and "MyPropClass2" in R2015b disp(class(myObj.someprop));
classdef MyObjClass2 < MyObjClass properties someprop@MyPropClass2 end end
classdef myClass properties myProperty = uint16(23); % end methods function obj = set.myProperty(obj,val) if ~isa(val, error( end % obj.myProperty = val; end end end
octave:1> X = [1 2; 3 4] X [2x2] = 1 2 3 4 octave:2> X(1,:) ans [1x2] = 1 2
function display(v) name = inputname(1); if isempty(name) name = end s = num2cell(size(v)); fprintf( builtin( end
>> A=ones(2,2,2) A [2x2x2] = (:,:,1) = 1 1 1 1 (:,:,2) = 1 1 1 1
dispf = @(x)fprintf( regexprep([inputname(1), disp(x));
dispf = @(x)fprintf( regexprep([inputname(1), strrep(mat2str(size(x)), disp(x));
dispf = @(x)fprintf( regexprep([inputname(1), strrep(mat2str(size(x)), disp(x)); A = [1 2; 3 4]; dispf(A) dispf(A(1, :))
>> format debug >> X = [1 2; 3 4] X = Structure address = 7d19498 m = 2 n = 2 pr = 373bafa0 pi = 0 1 2 3 4
function show(s) t = regexp(s, if any(t) evalin( else evalin( end
function display(x) % determine whether format is loose or compect loose = strcmp(get(0, % print name or ans name = inputname(1); if isempty(name), name = if loose, disp( disp([name if loose, disp( % print size sz = size(x); if length(sz) == 2 fprintf( elseif length(sz) == 3 fprintf( else fprintf( end if loose, disp( % print array disp(x); end
>> format compact; >> x = magic(5); >> display(x) x = double: 5-by-5 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9
function importfile(fileToRead1) % % % DELIMITER = HEADERLINES = 0; % rawData1 = importdata(fileToRead1, DELIMITER, HEADERLINES); % % % [~,name] = fileparts(fileToRead1); newData1.(genvarname(name)) = rawData1; % vars = fieldnames(newData1); for i = 1:length(vars) assignin( end
14 -0,158935550000000 15 -0,242218020000000 16 0,184783940000000
function output_txt = myfunction(obj, event_obj) % Display the position of the data cursor % obj Currently not used (empty) % event_obj Handle to event object % output_txt Data cursor text string (string or cell array of strings). pos = get(event_obj, output_txt = {[ [ % If there is a Z-coordinate in the position, display it as well if length(pos) > 2 output_txt{end+1} = [ end
plot(1:10, rand(1, 10)); % Plot some sample data dcmObj = datacursormode; % Turn on data cursors and return the % data cursor mode object set(dcmObj, % function so it uses updateFcn.m
A = [ x1 x2 x3 x4 x5 .... ] B = [ y1 y2 y3 y4 y5 .... ]
diff = A - B sum = 0 for column = 1:len sum += diff(1, column)^2 distance = sqrt(sum)
intersectionArea = rectint(gt,pr); %If you don unionArea = (width_g*height_g)+(width_p*height_p)-intersectionArea; overlapArea = intersectionArea/unionArea; %This should be greater than 0.5 to consider it as a valid detection.
from collections import namedtuple import numpy as np import cv2 Detection = namedtuple("Detection", ["image_path", "gt", "pred"]) def bb_intersection_over_union(boxA, boxB): xA = max(boxA[0], boxB[0]) yA = max(boxA[1], boxB[1]) xB = min(boxA[2], boxB[2]) yB = min(boxA[3], boxB[3]) interArea = (xB - xA + 1) * (yB - yA + 1) boxAArea = (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1) boxBArea = (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1) iou = interArea / float(boxAArea + boxBArea - interArea) return iou
rect1 = [x1,y1,w1,h1]; rect2 = [x2,y2,w2,h2]; intersectionArea = rectint(rect1,rect2); unionArea = w1*h1 + w2*h2 - intersectionArea; overlap = intersectionArea/unionArea;
function [IoU, match] = rectIoU(R1, R2, treshold) I = rectint(R1, R2); A1 = R1(:, 3).*R1(:, 4); A2 = R2(:, 3).*R2(:, 4); U = bsxfun(@plus, A1, A2 IoU = I./U; if nargout > 1 if nargin<3 treshold = 0.5; end match = IoU>treshold; end end
R1 = [0 0 1 1; 2 1 1 1]; R2 = [-.5 2 1 1; flipud(R1)]; R2 = R2+rand(size(R2))*.4-.2; [IoU, match] = rectIoU(R1, R2, 0.4)
function result= overlap_matrix(box1,box2) [m,y1]=size(box1); [n,y2]=size(box2); result=zeros(m,n, for i = 1:m for j=1:n gt=box1(i,:); pr=box2(j,:); x_g=box1(i,1); y_g=box1(i,2); width_g=box1(i,3); height_g=box1(i,4); x_p=box2(j,1); y_p=box2(j,2); width_p=box2(j,3); height_p=box2(j,4); intersectionArea=rectint(gt,pr); unionCoords=[min(x_g,x_p),min(y_g,y_p),max(x_g+width_g-1,x_p+width_p-1),max(y_g+height_g-1,y_p+height_p-1)]; unionArea=(unionCoords(3)-unionCoords(1)+1)*(unionCoords(4)-unionCoords(2)+1); overlapArea=intersectionArea/unionArea; result(i,j)=overlapArea; end end
function foo(myParam) if nargin<1 myParam = end % if end % function
if (nargin<1) || isempty(myparam) myparam = defaultvalue; elseif ... end
function x = myfcn( arg1, opt_arg2 ) if nargin < 2 arg2 = else arg2 = opt_arg2; end
function outArgs = my_fcn(inArg1,inArg2,inArg3) switch nargin, case 0, % No input case error( case 1, % Set last 2 inputs to default inArg2 = inArg3 = case 2, % Set last input to default inArg3 = end ... % Checking of variable types and values would go here! ... end
function AbCdEfGhIj(ffff, ggggg, varargin) opts = inputParser; opts.addRequired( opts.addRequired( opts.addOptional( opts.addOptional( opts.parse(ffff, ggggg, varargin{:}); opts = opts.Results; if isempty(opts.IncludeFullPath), opts.IncludeFullPath = iscell(opts.fffff) || opts.Recursive; end
[model, accuracy] = epicModelingFunction (dataMatrix, responseVector, indicatorForCategoricalVariables, optionsForInternalFunctions, typeOfDistanceCalculation, notationForMissingValues, isClassificationAndNotRegression, scalingMethod, shouldPlotAllIntermediateStuff) % EPICMODELINGFUNCTION is actually a horrible function to read and not epic at all % ...
function testExist(C) if exist( disp( elseif exist( disp( else disp( end end
if nargin<1, % code end if isError, % code end try, % code while 1, % even more code end catch, % code end
>> mlint comma_test.m L 1 (C 4): Extra comma is unnecessary.
try % your code here catch err %open file fid = fopen( % write the error to file % first line: message fprintf(fid, % following lines: stack for e=1:length(err.stack) fprintf(fid, end % close file fclose(fid) end
% % try my_code(); catch ME % end % % my_code(); ME = MException.last; %
msgString = getReport(ME, msgString = getReport(ME,
try % your code here catch err fid = fopen( fprintf(fid, fclose(fid) end
rep = getReport(exception, name = strcat( fid = fopen(name, fprintf(fid, fprintf(fid, fclose(
02, 04, 06, 08, 10, 2 07, 14, 21, 28, 35, 2 11, 22, 33, 44, 55, 0 15, 14, 21, 28, 35, 2
02, 04, 06, 08, 10, 2 07, 14, 21, 28, 35, 2 15, 14, 21, 28, 35, 2
02, 04, Some String, 08, 10, 2 07, 14, Some String1, 28, 35, 2 11, 22, Some String1, 44, 55, 0 15, 14, Some String, 28, 35, 2
def clockwise(points): x = points[0,:] y = points[1,:] cx = np.mean(x) cy = np.mean(y) a = np.arctan2(y - cy, x - cx) order = a.ravel().argsort() x = x[order] y = y[order] return np.vstack([x,y])
In [281]: pts Out[281]: array([[7, 2, 2, 7], [5, 1, 5, 1]]) In [282]: clockwise(pts) Out[282]: array([[2, 7, 7, 2], [1, 1, 5, 5]])
cx = mean(x); cy = mean(y); a = atan2(y - cy, x - cx); [~, order] = sort(a, x = x(order); y = y(order);
import numpy as np def clockwise(points): x = points[0,:] y = points[1,:] cx = np.mean(x) cy = np.mean(y) a = np.arctan2(y - cy, x - cx) order = a.ravel().argsort()[::-1] x = x[order] y = y[order] return np.vstack([x,y]) pts = np.array([[7, 2, 2, 7], [5, 1, 5, 1]]) clockwise(pts) pts = np.array([[1.0, 1.0], [-1.0, -1.0], [1.0, -1.0], [-1.0, 1.0]]).transpose() clockwise(pts)
[[7 2 2 7] [5 1 5 1]] [[2 7 7 2] [5 5 1 1]] [[ 1. -1. 1. -1.] [ 1. -1. -1. 1.]] [[-1. 1. 1. -1.] [ 1. 1. -1. -1.]]
myfilteredimage = imfilter(unfilteredimage, myfilter,
mask = find(~isnan(A)); [rows,~] = ind2sub(size(A),mask) A(mask) = rows;
[n,m] = size(A); B = ndgrid(1:n,1:m); B(isnan(A)) = NaN;
A = [ 2 NaN 5 8; 14 NaN 23 NaN]; out=repmat([1:size(A,2)],size(A,1),1); % out contains indexes of all the values out(isnan(A))= NaN % Replacing the indexes where NaN exists with NaN
A = [2 NaN 5 8; 14 NaN 23 NaN]. out = A*0 + kron((1:size(A,1)). out = 1 1 NaN NaN 3 3 4 NaN
classdef Test < handle methods function myFunction(obj) end end end
T = Test() T = Test handle with no properties. Methods, Events, Superclasses
Methods for class Test: Test delete findobj ge isvalid lt ne addlistener eq findprop gt le myFunction notify
classdef handle_light < handle methods(Hidden) function lh = addlistener(varargin) lh = addlistener@handle(varargin{:}); end function notify(varargin) notify@handle(varargin{:}); end function delete(varargin) delete@handle(varargin{:}); end function Hmatch = findobj(varargin) Hmatch = findobj@handle(varargin{:}); end function p = findprop(varargin) p = findprop@handle(varargin{:}); end function TF = eq(varargin) TF = eq@handle(varargin{:}); end function TF = ne(varargin) TF = ne@handle(varargin{:}); end function TF = lt(varargin) TF = lt@handle(varargin{:}); end function TF = le(varargin) TF = le@handle(varargin{:}); end function TF = gt(varargin) TF = gt@handle(varargin{:}); end function TF = ge(varargin) TF = ge@handle(varargin{:}); end function TF = isvalid(varargin) TF = isvalid@handle(varargin{:}); end end end
Methods for class handle_light: handle_light isvalid
classdef Test < handle_light methods function myFunction(obj) end end end
inp = input( if validateInput(inp) %do you stuff here or call your main function else fprintf( end
function [ output ] = test(input) Bmat = [ 1 1 1 ] % Some matrix try input*B; catch ME disp(ME.message) return; % This is the statement that exits your function end end
tStart = tic; % Do some things... tEnd = toc(tStart); fprintf(
tic % Do something time_str = SECS2HMS(toc) disp(time_str)
tic %Do something t=toc; disp(datestr(datenum(0,0,0,0,0,t),
x = 1:100; N = 1:10; Solution = repmat(x,[length(N)+1 1]).^repmat(([0 N])
Solution = [ones(size(x)); cumprod(repmat(x,[length(N) 1]),1)];
bsxfun(@power, cumsum(ones(100,10),2), cumsum(ones(100,10),1))
xn = 100; N=10; solution = [ones(1,xn); bsxfun(@power, cumsum(ones(N,xn),2), cumsum(ones(N,xn),1))];
c = [1:10] for i = 1:4; %loop to 10 for full scale problem M(:,i) = c.^(i-1) end
v = setdiff(1:10, b); x = v(ceil(numel(v) * rand));
[X,Y]=meshgrid(0:0.01:1,0:0.01:1); % Make a grid of points between 0 and 1 p1=0.1; p2=0.2; % Choose some parameters ineq1 = Y<p2*(1-p1); ineq2 = X<p1*(1-(Y./(1-p1))); colors = zeros(size(X))+ineq1+ineq2; scatter(X(:),Y(:),3,colors(:),
[X, Y] = meshgrid((0:999) / 1000, (0:999) / 1000); p = rand(2, 1); % ineq1 = Y < p(2) * (1 - p(1)); % ineq2 = X < p(1) * (1 - (Y / (1 - p(1)))); % both = ineq1 & ineq2; % figure, hold on c = 1:3; % contourf(c(1) * ineq1, [c(1), c(1)], contourf(c(2) * ineq2, [c(2), c(2)], contourf(c(3) * both, [c(3), c(3)], legend( set(gca, ... %
v = -5:0.1:5; p1 = 0.1; p2 = 0.2; [x,y] = meshgrid(v); ineq1 = y<p2*(1-p1); ineq2 = x<p1*(1-(y./(1-p1))); ineq = double(ineq1 & ineq2); % intersection of the inequalities surf(x,y,ineq); view(0,90) % rotate surface plot to top view
% I = imread( I = I(:,1:end-3,:); % % BW = edge(rgb2gray(I), % [H T R] = hough(BW); P = houghpeaks(H, 4, lines = houghlines(BW, T, R, P); % slopes = vertcat(lines.point2) - vertcat(lines.point1); slopes = slopes(:,2) ./ slopes(:,1); TFORM = maketform( II = imtransform(I, TFORM);
% figure, imshow(BW) % figure, imshow(imadjust(mat2gray(H)), [], xlabel( hold on, plot(T(P(:,2)), R(P(:,1)), axis on, axis normal % figure subplot(121), imshow(I), hold on for k = 1:length(lines) xy = [lines(k).point1; lines(k).point2]; plot(xy(:,1), xy(:,2), end, hold off subplot(122), imshow(II)
function checkin(infile, comments) file = which(infile); if ~exist(file, error( end cmd = sprintf(
stem(M(:, 1) .* 3.6, M(:, 3)); grid on xlabel( ylabel(
% experimental data M(:,1) = [ 0, 1, 2, 3, 4, 5]; M(:,3) = [12, 10, 15, 12, 11, 13]; % get bounds xmaxa = max(M(:,1))*3.6; % km/h xmaxb = max(M(:,1)); % m/s figure; % axis for m/s b=axes( set(b, set(b, % axis for km/h with stem-plot a=axes( set(a, stem(a,M(:,1).*3.6, M(:,3)); % set limits and labels set(a, set(b, xlabel(a, xlabel(b, ylabel(a, title(a,
clear clc close all x = 1:10; x2 = x/3.6; y = rand(size(x)); hP1 = plot(x,y); a1Pos = get(gca, % ax2 = axes( % xlim([min(x2(:)) max(x2(:))]) text(2.85,0 , text(2.85,.05 ,
subplot(100, 1, 1:99) plot(... subplot(100, 1, 100) plot(...) b = axis() axis([b(1:2), 0, 0])
function foo() if false fprintf = 1; else % do nothing end fprintf(
function foo() if false fprintf = 1; else % do nothing end clear( fprintf(
ans = 5 built-in (C:\Program Files\MATLAB\R2012a\toolbox\matlab\iofun\fprintf)
% In C.m, saved in the current directory classdef C properties (Constant) x = 100; end end % In Command window C.x = 1; C.x % 100 C.x % 1 (Note the space) C.x*C.x % 1 disp(C.x) % 1
Function [returnValue]=optimizer(@myfunction) %function definition End
s = length(vector); matrix= zeros(s); matrix(round(s/2),:) = vector; matrix(:, round(s/2)) = vector
function out=pyramid_hankel(v) %I suggest checking v here %it should be odd in length and a palindrome i0=ceil(length(v)/2); v2=v(i0:end); Mtmp=hankel(v2); out=zeros(length(v)); out(i0:end,i0:end)=Mtmp; out(1:i0-1,i0:end)=flipud(Mtmp(2:end,:)); out(:,1:i0-1)=fliplr(out(:,i0+1:end));
>> pyramid_hankel([1 2 3 2 1]) ans = 0 0 1 0 0 0 1 2 1 0 1 2 3 2 1 0 1 2 1 0 0 0 1 0 0
function out = pyramid(v) hlen = (numel(v)+1)/2; updown_vec = [1:(numel(v)+1)/2 (numel(v)-1)/2:-1:1]; upper_part = cumsum(bsxfun(@le,(hlen:-1:1) out = [upper_part ; flipud(upper_part(1:end-1,:))]; out = changem(out,v,updown_vec);
function out = pyramid_v2(v) hlen = (numel(v)+1)/2; updown_vec = [1:(numel(v)+1)/2 (numel(v)-1)/2:-1:1]; mask = bsxfun(@le,([hlen:-1:1 2:hlen]) M = double(mask); M(hlen+1:end,:) = -1; out = changem(cumsum(M).*mask,v,updown_vec);
>> v = [1 2 3 2 1]; >> pyramid(v) ans = 0 0 1 0 0 0 1 2 1 0 1 2 3 2 1 0 1 2 1 0 0 0 1 0 0 >> v = [3 5 3]; >> pyramid(v) ans = 0 3 0 3 5 3 0 3 0 >> v = [99,3,78,55,78,3,99]; >> pyramid(v) ans = 0 0 0 99 0 0 0 0 0 99 3 99 0 0 0 99 3 78 3 99 0 99 3 78 55 78 3 99 0 99 3 78 3 99 0 0 0 99 3 99 0 0 0 0 0 99 0 0 0
v = [1 2 3 2 1]; % m = (numel(v)-1)/2; w = [0 v(1:m+1)]; t = abs(-m:m); result = w(max(m+2-bsxfun(@plus, t, t.
>> nf = java.text.DecimalFormat; >> str = char(nf.format(1234567.890123)) str = 1,234,567.89
% x = 12345678; str = sprintf( str = 12345678.0000 % % % % % % % % % str = fliplr(regexprep(fliplr(str), str = 12,345,678.0000
set(gcf, x=0:0.01:10; plot(x, sin(x)) set(gca, export_fig
% n = 100; x = linspace(0,3*pi,n); y = sin(x) + rand(1,n)/5; % delta = 0.5; [ymaxtab, ymintab] = peakdet(y, delta, x); [ymaxtab2, ymintab2] = peakdet(y(end:-1:1), delta, x(end:-1:1)); ymaxtab = unique([ymaxtab; ymaxtab2], ymintab = unique([ymintab; ymintab2], % plot(x,y) hold on if size(ymaxtab,1) == 2 && size(ymintab,1) == 1 % plot(ymintab(:,1),ymintab(:,2), elseif size(ymaxtab,1) == 1 && size(ymintab,1) == 0 % plot(ymaxtab(:,1),ymaxtab(:,2), else % plot(ymintab(:,1),ymintab(:,2), plot(ymaxtab(:,1),ymaxtab(:,2), end hold off
firstPoint = find(dP==-1,1, lastPoint = find(dP==1,2, lastPoint = lastPoint(end);
x = 0:.1:4*pi; y = sin(x); plot(x,y) diffy = diff(y); localMin = find(diffy(1:end-1)<=0 & diffy(2:end) > 0)+1; localMax = find(diffy(1:end-1)>=0 & diffy(2:end) < 0)+1; hold on plot(x(localMin),y(localMin), plot(x(localMax),y(localMax),
if numel(localMax) == 1 fprintf( elseif numel(localMax > 1) betweenPeaksIndex = localMin(localMin > localMax(1) & localMin <localMax(2)); fprintf( else fprintf( end
function runExtended(script,varargin) cur = cd; if isempty(script), return, end if ispc, script(script== [p,s,ext] = fileparts(script); if ~isempty(p), if exist(p, cd(p) w = which(s); if ~isempty(w), % Check to make sure everything matches [wp,ws,wext] = fileparts(w); % Allow users to choose the .m file and run a .p if strcmp(wext, wext = end if ispc cont = ~strcmpi(wp,pwd) | ~strcmpi(ws,s) | ... (~isempty(ext) & ~strcmpi(wext,ext)); else cont = ~isequal(wp,pwd) | ~isequal(ws,s) | ... (~isempty(ext) & ~isequal(wext,ext)); end if cont if exist([s ext], cd(cur) rehash; error( else cd(cur) rehash; error( end end try feval(s,varargin{:}); % evalin( catch e cd(cur); rethrow(e); end else cd(cur) rehash; error( end cd(cur) rehash; else error( end else if exist(script, evalin( else error( end end end
libpath = % move mylib to the end of the path addpath(libpath, % now call some built-in functions that mylib overwrites reshape(rand(100),10,10); % return mylib to the top addpath(libpath)
function functionHandle = getFunctionHandleFromFile( fullFileName ) [pathstr, name, ext] = fileparts(fullFileName); prevDir = pwd; cd(pathstr); functionHandle = str2func(name); cd(prevDir);
x = [1e-9 1e-8 1e-7 1e-6 1e-5 1e-4 1e-3 1e-2] y1 = linspace(20, 90, 8); y2 = y1.^2; y3 = y1./y2+5; % plotte: http: myfig = figure( p1 = semilogx(x,y1, ax1 = gca; set(ax1, xlim([0 max(x)]); ylim([0 max([max(y1) max(y2)])]); col=.85*[1 1 1]; % ax2 = axes( % set(ax1, % linkaxes([ax1 ax2],
% plot(rand(10,1)) hAx1 = gca; % hAx2 = axes( % % % x = get(hAx1, y = get(hAx1, line([x([1 2]) nan x([2 1])],[y([1 1]) nan y([2 2])], line([x([1 1]) nan x([2 2])],[y([1 2]) nan y([2 1])],
% plot(11:20, rand(10,1)*5) hAx1 = gca; % % hAx2 = axes( % set(hAx1, % linkaxes([hAx1 hAx2], % legend(hAx1, title(
% semilogx(logspace(0,5,100), cumsum(rand(100,1)-0.5)) xlabel( legend( % hFig = gcf; hAx1 = gca; % hAx2 = copyobj(hAx1,hFig); delete( get(hAx2, set(hAx2, % % set(hAx1, xlabel(hAx1, % linkaxes([hAx1 hAx2], % %
for dir= ticks = get(gca, [dir lim = get(gca, [dir for ii=1:length(ticks) coord = ticks(ii); for jj=1:9, if jj==1 % major grid properties color = [1 1 1]*0.9; weight = 2; else % minor grid properties color = [1 1 1]*0.9; weight = 1; end if jj*coord > lim(2) continue end if dir== L = line((jj*coord)*[1 1], get(gca, else L = line(get(gca, end uistack(L, end end end
plot(rand(10,1)) xTicks=get(gca, yTicks=get(gca, set(gca, h2=axes; set(h2,
function gridcolor(majorX, majorY, minorX, minorY) ax1 = gca; % % ax2 = copyobj(ax1,gcf); ax3 = copyobj(ax1,gcf); delete(get(ax2, delete(get(ax3, set(ax2, set(ax3, set(ax1, handles = [ax3; ax2; ax1]; c = get(gcf, for i=1:length(handles) c = c(find(c ~= handles(i))); end set(gcf, linkaxes([ax1 ax2 ax3]); end subplot(211);semilogx([1:4000]);gridcolor( subplot(212);semilogx(([1:4000]).^-1);gridcolor(
$ echo something very long $ $ (reverse-i-search)`ec
<code> global name last_name var1 = findobj(gcbf, var2 = findobj(gcbf, data1 = char(name); data2 = char(last_name); set (var1, set (var2, </code>
%stage 1: skin detection - Adrian Rosebrock solution im = imread(<path to input image>); hsb = rgb2hsv(im)*255; skinMask = hsb(:,:,1) > 0 & hsb(:,:,1) < 20; skinMask = skinMask & (hsb(:,:,2) > 48 & hsb(:,:,2) < 255); skinMask = skinMask & (hsb(:,:,3) > 80 & hsb(:,:,3) < 255); skinMask = imclose(skinMask,strel( %stage 2: calculate top, left and right centroid from the different connected %components of the skin stats = regionprops(skinMask, topCentroid = stats(1).Centroid; rightCentroid = stats(1).Centroid; leftCentroid = stats(1).Centroid; for x = 1 : length(stats) centroid = stats(x).Centroid; if topCentroid(2)>centroid(2) topCentroid = centroid; elseif centroid(1)<leftCentroid(1) leftCentroid = centroid; elseif centroid(1)>rightCentroid(1) rightCentroid = centroid; end end %first seed - the average of the most left and right centroids. centralSeed = int16((rightCentroid+leftCentroid)/2); %second seed - a pixel which is right below the face centroid. faceSeed = int16(topCentroid); faceSeed(2) = faceSeed(2)+40; %stage 3: std filter varIm = stdfilt(rgb2gray(im)); %stage 4 - region growing on varIm using faceSeed and centralSeed res1=regiongrowing(varIm,centralSeed(2),centralSeed(1),8); res2=regiongrowing(varIm,faceSeed(2),faceSeed(1),8); res = res1|res2; %noise reduction res = imclose(res,strel( res = imopen(res,strel(
a = [ 1; 2]; % column vector b = [ 3 4]; % row vector a*b ans = 3 4 6 8
function bla(x) if(nargin == 0 && exist( x = fetchin( end % ... end
existStr=sprintf( isVarExist=evalin(ws, existStr); if isVarExist valVar=evalin(ws, varNames{iVar}); else valVar=[]; end
mat = [1 1 0 1; 0 0 1 0; 1 1 0 1; 1 0 0 0]; % Your sample matrix [r, c] = size(mat); % Get the matrix size imagesc((1:c)+0.5, (1:r)+0.5, mat); % Plot the image colormap(gray); % Use a gray colormap axis equal % Make axes grid sizes equal set(gca,
A = [ 1 1 0; 1 0 1; 1 1 1 ]; colormap([0 0 0; 1 1 1 ]); image(A .* 255);
i = [i; new_i]; j = [j; new_j]; s = [s; new_s]; S = sparse(i,j,s,m,n);
[i, j, s] = find(S); i = [i; new_i]; j = [j; new_j]; s = [s; new_s]; S = sparse(i,j,s,m,n);
Ssize = 10000; NumIterations = 100; NumInsertions = round(logspace(0, 4, 10)); NumInitialNZ = round(logspace(1, 4, 4)); NumTests = numel(NumInsertions) * numel(NumInitialNZ); TimeDirect = zeros(numel(NumInsertions), numel(NumInitialNZ)); TimeIndices = zeros(numel(NumInsertions), 1); %% Single insertion operation (non-incremental) % Method A: Direct insertion for iInitialNZ = 1:numel(NumInitialNZ) disp([ for iInsertions = 1:numel(NumInsertions) tSum = 0; for jj = 1:NumIterations S = spalloc(Ssize, Ssize, NumInitialNZ(iInitialNZ)); r = randi(Ssize, NumInsertions(iInsertions), 1); c = randi(Ssize, NumInsertions(iInsertions), 1); tic S(r,c) = 1; tSum = tSum + toc; end disp([num2str(NumInsertions(iInsertions)) TimeDirect(iInsertions, iInitialNZ) = tSum; end end % Method B: Rebuilding from index vectors for iInsertions = 1:numel(NumInsertions) tSum = 0; for jj = 1:NumIterations i = []; j = []; s = []; r = randi(Ssize, NumInsertions(iInsertions), 1); c = randi(Ssize, NumInsertions(iInsertions), 1); s_ones = ones(NumInsertions(iInsertions), 1); tic i_new = [i; r]; j_new = [j; c]; s_new = [s; s_ones]; S = sparse(i_new, j_new ,s_new , Ssize, Ssize); tSum = tSum + toc; end disp([num2str(NumInsertions(iInsertions)) TimeIndices(iInsertions) = tSum; end SingleOperation.TimeDirect = TimeDirect; SingleOperation.TimeIndices = TimeIndices; %% Incremental insertion for iInitialNZ = 1:numel(NumInitialNZ) disp([ % Method A: Direct insertion for iInsertions = 1:numel(NumInsertions) tSum = 0; for jj = 1:NumIterations S = spalloc(Ssize, Ssize, NumInitialNZ(iInitialNZ)); r = randi(Ssize, NumInsertions(iInsertions), 1); c = randi(Ssize, NumInsertions(iInsertions), 1); tic for ii = 1:NumInsertions(iInsertions) S(r(ii),c(ii)) = 1; end tSum = tSum + toc; end disp([num2str(NumInsertions(iInsertions)) TimeDirect(iInsertions, iInitialNZ) = tSum; end end % Method B: Rebuilding from index vectors for iInsertions = 1:numel(NumInsertions) tSum = 0; for jj = 1:NumIterations i = []; j = []; s = []; r = randi(Ssize, NumInsertions(iInsertions), 1); c = randi(Ssize, NumInsertions(iInsertions), 1); tic for ii = 1:NumInsertions(iInsertions) i = [i; r(ii)]; j = [j; c(ii)]; s = [s; 1]; S = sparse(i, j ,s , Ssize, Ssize); end tSum = tSum + toc; end disp([num2str(NumInsertions(iInsertions)) TimeIndices(iInsertions) = tSum; end IncremenalInsertion.TimeDirect = TimeDirect; IncremenalInsertion.TimeIndices = TimeIndices; %% Plot results % Single insertion figure; loglog(NumInsertions, SingleOperation.TimeIndices); cellLegend = { hold all; for iInitialNZ = 1:numel(NumInitialNZ) loglog(NumInsertions, SingleOperation.TimeDirect(:, iInitialNZ)); cellLegend = [cellLegend; {[ end hold off; title( xlabel( legend(cellLegend, grid on; % Incremental insertions figure; loglog(NumInsertions, IncremenalInsertion.TimeIndices); cellLegend = { hold all; for iInitialNZ = 1:numel(NumInitialNZ) loglog(NumInsertions, IncremenalInsertion.TimeDirect(:, iInitialNZ)); cellLegend = [cellLegend; {[ end hold off; title( xlabel( legend(cellLegend, grid on;
function name = packagename % Get full path of calling function: callerPath = evalin( % Parse the path string to get package directories: name = regexp(callerPath, % Format the output: name = strcat([name{:}], [repmat({ name = [name{:}]; end
+mypackage\intfc1.m +mypackage\intfc2.m +mypackage\private\foo1.m +mypackage\private\foo2.m +mypackage\private\foo3.m
+mypackage\foo1.m <--- new interface layer wraps private foo1 +mypackage\private\foo1.m <--- original function
function answer = foo1(some_parameter) answer = foo1(some_parameter); % calls private function, not itself end
D=20000 M=25 A = floor(rand(D,M)*10); B = floor(rand(1,D)*10); for i=1:D for j=1:M result(i,j) = A(i,j) * B(1,j); end end manual = result * A auto = A*diag(B)*A isequal(manual,auto)
D = 20000; M = 25; A = floor(rand(D,M).*10); % diagB = rand(1,D).*10; % B = sparse(1:D,1:D,diagB); % result = (A.
img = imread( fft = fft2(img); inv = ifft2(fft); imshow(inv);
>> img = imread( >> fft = fft2(img); % Get the Fourier transform >> inv = ifft2(fft); % Get the inverse Fourier transform >> inv = uint8(inv); % Convert to uint8 >> imshow(inv); % Show the image >> isequal(img, inv) % Test if inv matches the original image img ans = 1 % It does!
function mytestfunction() f=figure; set(f, function mytestcallback(hObject,~) pos=get(hObject, disp([
x = [1,3,5] res = zeros(1,size(x,2)); for i=1:size(x,2); res(i) = foo(x(i); end;
A=randn(4,50,100); B=squeeze(A(1,:,:)); size(B) ans = 50 100
[m2_array, ~ , ~] = F_readBin( amb = m2_array(:,:,lat); surfc(light, ylim([1 24]); xlim([1 size(light,2)]); title([ xticks([0:50:size(m2_array,2)]); labels=cellstr(num2str((day_start:50:day_end) xlabel( [\mumol m^2 s^-^1] colormap winter;
clear; close all; clc % Dummy data from matlab example [X,Y,Z] = peaks(25); % Primary axes with some arbitrary viewpoint and labels hs = surf(X,Y,Z); % Get surface object ha = hs.Parent; % Get parent Axes ha.View = [25, 40]; % Set arbitrary view point xlabel ylabel zlabel grid on % Secondary axes on top of primary, using same view point hb = axes( hb.ZLim = [0 7]; % Arbitrary axis limits zlabel % Hide secondary background and x and y rulers hb.Color = hb.XAxis.Visible = hb.YAxis.Visible = % Move z-ruler to opposite corner (from undocumentedmatlab) hb.ZAxis.FirstCrossoverValue = 1; % x-location of z-ruler [normalized] hb.ZAxis.SecondCrossoverValue = 1; % y-location of z-ruler [normalized]
function add_scale(hAxes, axisStr, newLimits, newColor, newLabel) % Get axis ruler to modify: axisStr = upper(axisStr); hRuler = get(hAxes, [axisStr % Create TeX color modification strings: labelColor = [ tickColor = [ newColor = [ % Compute tick values for new axis scale: tickValues = hRuler.TickValues; limits = hRuler.Limits; newValues = newLimits(1)+... diff(newLimits).*(tickValues-limits(1))./diff(limits); % Create new tick labels: formatString = [ newColor hRuler.TickLabelFormat newTicks = strsplit(sprintf(formatString, [tickValues; newValues]), % Update tick and axis labels: hRuler.Label.String = {[labelColor hRuler.Label.String]; ... [newColor newLabel]}; hRuler.TickLabels = newTicks(1:(end-1)); end
[X, Y, Z] = peaks(25); hSurf = surfc(Z); hAxes = gca; ylabel( add_scale(hAxes,
profile -memory on profile clear % my code profile report
function A() foo = B(); clear foo end function foo = B() foo = rand(10000,10000); end
maxMemFrac = 0.8; % numElements = 3 * (m * 3 * t) + 5 * (m * t); numBytesNeeded = numElements * 8; % % [~,memStats] = memory; if numBytesNeeded > memStats.PhysicalMemory.Available * maxMemFrac error( end
TrainLabel;TrainVec;TestVec;TestLaBel; u=unique(TrainLabel); N=length(u); if(N>2) itr=1; classes=0; while((classes~=1)&&(itr<=length(u))) c1=(TrainLabel==u(itr)); newClass=c1; model = svmtrain(TrainLabel, TrainVec, [predict_label, accuracy, dec_values] = svmpredict(TestLabel, TestVec, model); itr=itr+1; end itr=itr-1; end
% load fisheriris [~,~,labels] = unique(species); % data = zscore(meas); % numInst = size(data,1); numLabels = max(labels); % idx = randperm(numInst); numTrain = 100; numTest = numInst - numTrain; trainData = data(idx(1:numTrain),:); testData = data(idx(numTrain+1:end),:); trainLabel = labels(idx(1:numTrain)); testLabel = labels(idx(numTrain+1:end)); % model = cell(numLabels,1); for k=1:numLabels model{k} = svmtrain(double(trainLabel==k), trainData, end % prob = zeros(numTest,numLabels); for k=1:numLabels [~,~,p] = svmpredict(double(testLabel==k), testData, model{k}, prob(:,k) = p(:,model{k}.Label==1); % end % [~,pred] = max(prob,[],2); acc = sum(pred == testLabel) ./ numel(testLabel) % C = confusionmat(testLabel, pred) %
[~,~,d] = svmpredict(double(testLabel==k), testData, model{k}); prob(:,k) = d * (2 * model{i}.Label(1) - 1);
[x,y,z] = peaks(50); figure; subplot(5,1,1:4); pcolor(x,y,z); shading flat; colorbar; subplot(5,1,5); plot(x(end/2,:), z(end/2,:));
[x,y,z] = peaks(50); figure; ah1 = subplot(5,1,1:4); % pcolor(x,y,z); shading flat; colorbar; ah2 = subplot(5,1,5); % plot(x(end/2,:), z(end/2,:)); % pos2 = get(ah2, pos1 = get(ah1, % pos2(3) = pos1(3); set(ah2,
antsNumber = 5; for counter = 1: antsNumber ant(counter) = TAnt(source, target); end
function [mc_list,subcls_list] = q37829489(includeBulkFiles,includePackages) %% Input handling if nargin < 2 || isempty(includePackages) includePackages = false; mp_list = meta.package.empty; end if nargin < 1 || isempty(includeBulkFiles) includeBulkFiles = false; mb_list = meta.class.empty; % % `mb_list` is always overwritten by the output of meta.class.getAllClasses; end %% Output checking if nargout < 2 warning( end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %% Get classes list from bulk files "laying around" the MATLAB path: if includeBulkFiles % Obtain MATLAB path: p = strsplit(path,pathsep). if ~ismember(pwd,p) p = [pwd;p]; end nPaths = numel(p); s = what; s = repmat(s,nPaths+20,1); % Preallocation; +20 is to accomodate rare cases s_pos = 1; % where "what" returns a 2x1 struct. for ind1 = 1:nPaths tmp = what(p{ind1}); s(s_pos:s_pos+numel(tmp)-1) = tmp; s_pos = s_pos + numel(tmp); end s(s_pos:end) = []; % truncation of placeholder entries. clear p nPaths s_pos tmp %% Generate a list of classes: % from .m files: m_files = vertcat(s.m); % from .p files: p_files = vertcat(s.p); % get a list of potential class names: [~,name,~] = cellfun(@fileparts,[m_files;p_files], % get listed classes: listed_classes = s.classes; % combine all potential class lists into one: cls_list = vertcat(name,listed_classes); % test which ones are actually classes: isClass = cellfun(@(x)exist(x, %[u,ia,ic] = unique(ext(isClass(1:numel(ext)))); %DEBUG: % for valid classes, get metaclasses from name; if a classdef contains errors, % will cause cellfun to print the reason using ErrorHandler. [~] = cellfun(@meta.class.fromName,cls_list(isClass), @(ex,in)meta.class.empty(0*fprintf(1, , in, ex.message))); % The result of the last computation used to be assigned into mc_list, but this % is no longer required as the same information (and more) is returned later % by calling "mb_list = meta.class.getAllClasses" since these classes are now cached. clear cls_list isClass ind1 listed_classes m_files p_files name s end %% Get class list from classes belonging to packages (takes long!): if includePackages % Get a list of all package classes: mp_list = meta.package.getAllPackages; mp_list = vertcat(mp_list{:}); % see http: % Recursively flatten package list: mp_list = flatten_package_list(mp_list); % Extract classes out of packages: mp_list = vertcat(mp_list.ClassList); end %% Combine lists: % Get a list of all classes that are in memory: mb_list = meta.class.getAllClasses; mc_list = union(vertcat(mb_list{:}), mp_list); %% Map relations: try [subcls_list,discovered_classes] = find_superclass_relations(mc_list); while ~isempty(discovered_classes) mc_list = union(mc_list, discovered_classes); [subcls_list,discovered_classes] = find_superclass_relations(mc_list); end catch ex % Turns out this helps.... disp([ [mc_list,subcls_list] = q37829489; end end function [subcls_list,discovered_classes] = find_superclass_relations(known_metaclasses) %% Build hierarchy: sup_list = {known_metaclasses.SuperclassList}. % Count how many superclasses each class has: n_supers = cellfun(@numel,sup_list); % Preallocate a Subclasses container: subcls_list = cell(numel(known_metaclasses),1); % should be meta.MetaData % Iterate over all classes and % discovered_classes = meta.class.empty(1,0); % right type, but causes segfault discovered_classes = meta.class.empty; for depth = max(n_supers):-1:1 % The function of this top-most loop was initially to build a hierarchy starting % from the deepest leaves, but due to lack of ideas on "how to take it from here", % it only serves to save some processing by skipping classes with "no parents". tmp = known_metaclasses(n_supers == depth); for ind1 = 1:numel(tmp) % Fortunately, SuperclassList only shows *DIRECT* supeclasses. Se we % only need to find the superclasses in the known classees list and add % the current class to that list. curr_cls = tmp(ind1); % It % bsxfun(@eq,mc_list,tmp(ind1).SuperclassList. for ind2 = 1:numel(curr_cls.SuperclassList) pos = find(curr_cls.SuperclassList(ind2) == known_metaclasses,1); % Did we find the superclass in the known classes list? if isempty(pos) discovered_classes(end+1,1) = curr_cls.SuperclassList(ind2); % % disp([curr_cls.SuperclassList(ind2).Name continue end subcls_list{pos} = [subcls_list{pos} curr_cls]; end end end end % The full flattened list for MATLAB R2016a contains about 20k classes. function flattened_list = flatten_package_list(top_level_list) flattened_list = top_level_list; for ind1 = 1:numel(top_level_list) flattened_list = [flattened_list;flatten_package_list(top_level_list(ind1).PackageList)]; end end
hRoot = meta.class.fromName( subcls_list{mc_list==hRoot} ans = class with properties: Name: Description: DetailedDescription: Hidden: 0 Sealed: 0 Abstract: 0 Enumeration: 0 ConstructOnLoad: 0 HandleCompatible: 0 InferiorClasses: {0x1 cell} ContainingPackage: [0x0 meta.package] PropertyList: [9x1 meta.property] MethodList: [18x1 meta.method] EventList: [0x1 meta.event] EnumerationMemberList: [0x1 meta.EnumeratedValue] SuperclassList: [1x1 meta.class] subcls_list{mc_list==subcls_list{mc_list==hRoot}} % simulate recursion ans = class with properties: Name: Description: DetailedDescription: Hidden: 0 Sealed: 0 Abstract: 0 Enumeration: 0 ConstructOnLoad: 0 HandleCompatible: 0 InferiorClasses: {0x1 cell} ContainingPackage: [0x0 meta.package] PropertyList: [9x1 meta.property] MethodList: [18x1 meta.method] EventList: [0x1 meta.event] EnumerationMemberList: [0x1 meta.EnumeratedValue] SuperclassList: [1x1 meta.class]
subcls_list{mc_list==meta.class.fromName( ans = 1x4059 heterogeneous class (NETInterfaceCustomMetaClass, MetaClassWithPropertyType, MetaClass, ...) array with properties: Name Description DetailedDescription Hidden Sealed Abstract Enumeration ConstructOnLoad HandleCompatible InferiorClasses ContainingPackage PropertyList MethodList EventList EnumerationMemberList SuperclassList
Warning: Possible deprecated use of set on a Java callback. > In setPrompt at 115
>> [~,systemString] = system( >> setPrompt([deblank(systemString) P11-4504>>
a = [1 1 2 2]; lin_idx = 1:4; out = arrayfun(@(x,y)x*y,a,lin_idx);
S = spdiags([1:4] lin_idx = find(S); out = spones(S); out(lin_idx) = arrayfun(@(x,y)x*y,full(S(lin_idx)),lin_idx); % out(lin_idx) = S(lin_idx) .* lin_idx;
function tailtest(n) if n==0; feature memstats; return; end tailtest(n-1); end
for iCol = 1:nCols means(:,iCol) = accumarray(labels end
labels = [repmat(labels(:),nCols,1) ... % Replicate the row indices kron(1:nCols,ones(1,numel(labels))). totals = accumarray(labels,X(:)); % I used "totals" instead of "means"
labels = [3; 1; 1]; X = [1 2 3; ... 4 5 6; ... 7 8 9]; nCols = 3
labels = 3 1 X(:) = 1 totals = 11 13 15 1 1 4 0 0 0 1 1 7 1 2 3 3 2 2 1 2 5 1 2 8 3 3 3 1 3 6 1 3 9
[xx, yy] = ndgrid(labels,1:size(X, 1)); totals = accumarray([yy(:) xx(:) ], reshape(X.
[xx, yy] = ndgrid(labels,1:size(X, 2)); totals = accumarray([xx(:) yy(:)], X(:));
test=zeros(1e7,1); >> tic;any(test);toc Elapsed time is 2.444690 seconds. >> test(2)=1; >> tic;any(test);toc Elapsed time is 0.000034 seconds.
test=ones(1e7,1); test(1:end)=0; tic;any(test);toc Elapsed time is 0.642413 seconds. >> test(2)=1; >> tic;any(test);toc Elapsed time is 0.000021 seconds.
test=zeros(1e7,1); for ii=1:1e7 test(ii)=1; if ii==1e7/2 pause end end
function visited = procedure_explore( u, adj_mat, visited ) visited(u) = 1; neighbours = find(adj_mat(u,:)); for ii = 1:length(neighbours) if (visited(neighbours(ii)) == 0) visited = procedure_explore( neighbours(ii), adj_mat, visited ); end end end
function visited = procedure_explore_vec( u, adj_mat, visited ) visited(u) = 1; neighbours = find(adj_mat(u,:)); len_neighbours=length(neighbours); visited_neighbours_zero=visited(neighbours(1:len_neighbours)) == 0; if(~isempty(visited_neighbours_zero)) visited = procedure_explore_vec( neighbours(visited_neighbours_zero), adj_mat, visited ); end end
function main adj_mat=[0 0 0 0; 1 0 1 1; 1 0 0 0; 1 0 0 1]; u=2; visited=zeros(size(adj_mat,1)); tic visited = procedure_explore( u, adj_mat, visited ) toc visited=zeros(size(adj_mat,1)); tic visited = procedure_explore_vec( u, adj_mat, visited ) toc end
Speed up between original and logical methods is 0.39672 Speed up between original and nearest methods is 0.0042583
function main_recersive adj_mat=[0 0 0 0; 1 0 1 1; 1 0 0 0; 1 0 0 1]; u=2; visited=zeros(size(adj_mat,1)); f_original=@()(procedure_explore( u, adj_mat, visited )); t_original=timeit(f_original); f_logical=@()(procedure_explore_logical( u, adj_mat )); t_logical=timeit(f_logical); f_nearest=@()(procedure_explore_nearest( u, adj_mat,visited )); t_nearest=timeit(f_nearest); disp([ disp([ end function visited = procedure_explore( u, adj_mat, visited ) visited(u) = 1; neighbours = find(adj_mat(u,:)); for ii = 1:length(neighbours) if (visited(neighbours(ii)) == 0) visited = procedure_explore( neighbours(ii), adj_mat, visited ); end end end function visited = procedure_explore_nearest( u, adj_mat, visited ) % add u since your function also includes it. nodeIDs = [nearest(digraph(adj_mat),u,inf) ; u]; % transform to output format of your function visited = zeros(size(adj_mat,1)); visited(nodeIDs) = 1; end function visited = procedure_explore_logical( u, adj_mat ) visited = false(1, size(adj_mat, 1)); visited(u) = true; new_visited = visited; while any(new_visited) visited = any([visited; new_visited], 1); new_visited = any(adj_mat(new_visited, :), 1); new_visited = and(new_visited, ~visited); end end
function visited = procedure_explore_logical( u, adj_mat ) visited = false(1, size(adj_mat, 1)); visited(u) = true; new_visited = visited; while any(new_visited) visited = any([visited; new_visited], 1); new_visited = any(adj_mat(new_visited, :), 1); new_visited = and(new_visited, ~visited); end end
adj_mat + adj_mat^2 + adj_mat^3 ans = 0 0 0 0 4 0 1 3 1 0 0 0 3 0 0 3
A2 = A^2; A3 = A2*A A4 = A2^2; A5 = A4*A; allWalks= A + A2 + A3 + A4 + A5;
% add u since your function also includes it. nodeIDs = [nearest(digraph(adj_mat),u,inf) ; u]; % transform to output format of your function visited = zeros(size(adj_mat,1)); visited(nodeIDs) = 1;
classdef visited_class < handle properties visited end methods function obj = visited_class(adj_mat) obj.visited = zeros(1, size(adj_mat,1)); end end end
function procedure_explore_handle( u, adj_mat,visited_handle ) visited_handle.visited(u) = 1; neighbours = find(adj_mat(u,:)); for n = neighbours if (visited_handle.visited(n) == 0) procedure_explore_handle( n, adj_mat , visited_handle ); end end end
adj_mat=[0 0 0 0; 1 0 1 1; 1 0 0 0; 1 0 0 1]; visited_handle = visited_class(adj_mat); u = 2;
procedure_explore_handle( u, adj_mat,visited_handle );
adj_mat2=adj_mat^2; % allowed to use 2 steps while (adj_mat2 ~= adj_mat) % check if new points were reached adj_mat=adj_mat2; % current set of reachable points adj_mat2=(adj_mat^2)>0; % allowed all steps again: power method end
function visited = procedure_explore_vec(u, adj_mat) connectivity_matrix = polyvalm(ones(size(adj_mat,1),1),adj_mat)>0; visited = connectivity_matrix(u,:); end
% first plot f1 = figure; p1 = plot(1:10); datacursormode on; % enable datatip mode c1 = datacursormode(f1); % get the cursor mode d1 = c1.createDatatip(p1); % create a new datatip % second plot f2 = figure; p2 = plot(1:10); datacursormode on; c2 = datacursormode(f2); d2 = c2.createDatatip(p2); % register the function to execute when the datatip changes. set(d1, set(d2, % callback function when the datatip changes function displayText = onDataTipUpdate(cursorMode,eventData, d) pos = get(eventData, displayText = {[ [ d.Position(1) = pos(1); % update the location of the other datatip. end
using namespace cv; using namespace std; int main() { Mat img = imread("test.jpg"); uchar pb = img.at<Vec3b>(0, 0).val[0]; uchar pg = img.at<Vec3b>(0, 0).val[1]; uchar pr = img.at<Vec3b>(0, 0).val[2]; int d = img.depth(); int t = img.type(); }
ans(:,:,1) = 148 ans(:,:,2) = 174 ans(:,:,3) = 201 Name Size Bytes Class Attributes img 1920x2560x3 14745600 uint8
int main() { auto img = cv::imread("test2.jpg"); auto pixel = img.at<cv::Vec3b>(85, 85); std::cout << (int)pixel[0] << "\t" << (int)pixel[1] << "\t" << (int)pixel[2] << std::endl; }
while true % ref. comment Simon W Oct 1 at 11:29 [ isStillProcessingDotNET, ... % a FLAG from .NET reader function aDotNET_RowOfVALUEs ... % a ROW from .NET reader function ] = GetDataFromDotNET( aDtPT ) % .NET reader if ( isStillProcessingDotNET ) % Yes, more rows are still to come ... aRowCOUNT = aRowCOUNT + 1; % keep .INC for aRowCOUNT ( mean() ) for i = 1:size( aDotNET_RowOfVALUEs )(2) % stepping across each column aValue = aDotNET_RowOfVALUEs(i); % anIncrementalSumInCOLUMN(i) = ... anIncrementalSumInCOLUMN(i) + aValue; % keep .SUM for each column ( mean() ) if ( aMaxInCOLUMN(i) < aValue ) % retest for a "max.update()" aMaxInCOLUMN(i) = aValue; % .STO a just found "new" max end endfor continue % force re-loop else break endif end %------------------------------------------------------------------------------------------- % FINALLY: % all results are pre-calculated right at the end of .NET reading phase: % % ------------------------------- % BILL OF ALL COMPUTATIONAL COSTS ( for given scales of 1E5 columns x 1E6 rows ): % ------------------------------- % HDD.IO: **ZERO** % IN-RAM STORAGE: % Attr Name Size Bytes Class % ==== ==== ==== ===== ===== % aMaxInCOLUMNs 1x100000 800000 double % anIncrementalSumInCOLUMNs 1x100000 800000 double % aRowCOUNT 1x1 8 double % % DATA PROCESSING: % % 1.000.000x .NET row-oriented reads ( same for both the OP and this, smarter BigDATA approach ) % 1x INT in aRowCOUNT, %% 1E6 .INC-s % 100.000x FLOATs in aMaxInCOLUMN[] %% 1E5 * 1E6 .CMP-s % 100.000x FLOATs in anIncrementalSumInCOLUMN[] %% 1E5 * 1E6 .ADD-s % ----------------- % about 15 sec per COLUMN of 1E6 rows % ----------------- % --> mean()s are anIncrementalSumInCOLUMN./aRowCOUNT %------------------------------------------------------------------------------------------- % PIPE-LINE-d processing takes in TimeDOMAIN "nothing" more than the .NET-reader process %-------------------------------------------------------------------------------------------
clear all; close all; clc; % functions fn1 = @(x) x^2; fn2 = @(x) double(x^2); % variables x = linspace(-100,100,100000); N = length(x); %% anonymous function y = zeros(1,N); t = tic; for i=1:N y(i) = fn1(x(i)); end tm.anonymous_1 = toc(t); %% anonymous function (modified) y = zeros(1,N); t = tic; for i=1:N y(i) = fn2(x(i)); end tm.anonymous_2 = toc(t); %% print tm
fn2 = @(x) 1 * x^2; fn2 = @(x) 0 + x^2; fn2 = @(x) abs(x^2); fn2 = @(x) x*x;
>> set(gcf, ans = 22×1 graphics array: Figure (1) ContextMenu AnnotationPane Axes AxesToolbar Text Text Text ToolbarStateButton (Brush/Select Data) ToolbarStateButton (Data Tips) ToolbarStateButton (Rotate 3-D) ToolbarStateButton (Pan) ToolbarStateButton (Zoom In) ToolbarStateButton (Zoom Out) ToolbarPushButton (Restore View) Button Button Button Button Button Button Button
MATLAB/R2018b/java/jar/hg.jar!/com/mathworks/hg/util/InfoPanel.class
com.mathworks.hg.util.InfoPanel.addBannerPanel( figure(randi(1E4)) );
jIP = com.mathworks.hg.util.InfoPanel; jIP.setBackground(java.awt.Color(0.8, 0.7, 0.1)); com.mathworks.hg.util.InfoPanel.addBannerPanel( figure(randi(1E4)), jIP );
sys/tex/tfm/cmr10.tfm sys/fonts/ttf/cm/cmr10.ttf sys/fonts/type1/cm/cmr10.pfb sys/fonts/type1/cm/cmr10.pfm
sys/tex/tfm/cmr10.tfm sys/fonts/ttf/cm/mwa_cmr10.ttf sys/fonts/ttf/cm/mwb_cmr10.ttf sys/fonts/type1/cm/mwa_cmr10.pfb sys/fonts/type1/cm/mwb_cmr10.pfb
function [dviout,errout,auxout] = tex(varargin) fid = fopen( dviout = fread(fid, dviout = uint8(dviout); fclose(fid); errout = []; auxout = []; end
\documentclass{article} \setlength\topmargin{-0.5in} \setlength\oddsidemargin{0in} \DeclareFontFamily{T1}{myfont}{} \DeclareFontShape{T1}{myfont}{m}{n}{<-> [1.2] AuriocusKalligraphicus}{} \begin{document}% \setbox0=\hbox{\usefont{T1}{myfont}{m}{n}Some text with a distinct font $\alpha$}% \copy0\special{bounds: \the\wd0 \the\ht0 \the\dp0}% \end{document}%
>> text(0.0, 0.5, Warning: Font AuriocusKalligraphicus10 is not supported. Warning: Font AuriocusKalligraphicus10 is not supported.
rng(0, n = 1000; r = linspace(-10,10,n) x = 1 + r*5e-2 + sin(r)./r + 0.2*randn(n,1);
n = 1000; r = sort(-10 + 20*rand(n,1)); xtest = 1 + r*5e-2 + sin(r)./r + 0.4*randn(n,1);
[eigvector,eigmatrix] = eig(corr(A)); [~,ind] = sort(diag(eigmatrix), eigmatrix = eigmatrix(ind,ind); eigvector = eigvector(:,ind); eigvalues = diag(eigmatrix); % Eigeinvalues loadings = eigvector*sqrt(eigmatrix); loadings = loadings(:,1:2) % Extract only 2 factors
FACTOR /VARIABLES A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 /MISSING LISTWISE /ANALYSIS A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 /PRINT INITIAL EXTRACTION ROTATION /CRITERIA FACTORS(2) ITERATE(25) /EXTRACTION PC /CRITERIA ITERATE(25) DELTA(0) /ROTATION OBLIMIN /METHOD=CORRELATION.
[B,T]=rotatefactors(loadings, % Your pattern matrix is in B, to get the structure matrix, you can do : S=B*inv(T
B = -0.0178 0.9765 -0.9528 0.0563 -0.0305 -1.0124 0.9442 -0.0602 0.9897 -0.0155 -0.7625 0.1992 -0.8823 0.0333 -0.9776 -0.1919 -0.7797 0.0719 0.9950 0.0767
S = -0.5740 0.9867 -0.9849 0.5990 0.5461 -0.9950 0.9785 -0.5980 0.9985 -0.5791 -0.8760 0.6335 -0.9013 0.5358 -0.8683 0.3649 -0.8206 0.5160 0.9513 -0.4899
%% u_path1 = native2unicode([107, 97, 116, 111, 95, 111, 117, 116, 111, 117], u_path2 = native2unicode([233 129 142, 230 184 161, 229 191 156, 231 173 148], mkdir(u_path1); mkdir(u_path2);
function listing = dir(folder); function [status,message,messageid] = mkdir(folder1,folder2); function [status,message,messageid] = movefile(source,destination,flag); function [status,message,messageid] = copyfile(source,destination,flag); function [fileID, message] = fopen(filename, permission, machineformat, encoding); function status = fclose(fileID); function [A, count] = fread(fileID, sizeA, precision, skip, machineformat); function count = fwrite(fileID, A, precision, skip, machineformat); function status = feof(fileID); function status = fseek(fileID, offset, origin); function [C,position] = textscan(fileID, varargin); %
java.io.File(fullfile(pwd,native2unicode(... [255 254 234 5 217 5 231 5 217 5 212 5],
mkdir(native2unicode([255 254 234 5 217 5 231 5 217 5 212 5], mkdir(native2unicode([215,170,215,153,215,167,215,153,215,148],
fid = fopen([native2unicode([255,254,231,5,213,5,209,5,229,5], txt = textscan(fid,
%parameters n=5; theta = .5; u0 = 0.02; h = .1; limit = 2000; %init u u=zeros(n,n); uinit = -u0/2*log(n-1); %p94 uINIT = - u0/2 * ln(n-1) for i=1:n for j=1:n u(i,j) = uinit * (1+rand()*0.2-0.1); %add noise [-0.1*uInit 0.1*uINIT] end end %loop for index=1:limit i = ceil(rand()*n); k = ceil(rand()*n); %runge kutta k1 = h*du(u,i,k,0); k2 = h*du(u,i,k, k1/2); k3 = h*du(u,i,k, k2/2); k4 = h*du(u,i,k, k3); u(i,k) = u(i,k) + (k1 + 2*k2 + 2*k3 + k4)/6; end Vfinal = hardlim(V(u)-theta)
function out=du(u,X,i,c) dist = [0, 41, 45, 32, 32; 41, 0, 36, 64, 54; 45, 36, 0, 76, 32; 32, 64, 76, 0, 60; 32, 54, 32, 60, 0]; t = 1; n = 5; A = 10; B = 10; C = 10; D = .0001; AComp = A*sum(V(u(X,:))) - A*V(u(X,i)); BComp = B*sum(V(u(:,i))) - B*V(u(X,i)); CComp = C*(sum(sum(V(u)))-n); DComp = 0; before = i-1; after = i+1; if before == 0 before = 5; end if after == 6 after = 1; end for Y=1:5 DComp = DComp + dist(X,Y) * (V(u(Y,after)) + V(u(Y,before))); end DComp = DComp * D; out = -1*(u(X,i)+c)/t - AComp - BComp - CComp - DComp;
function out=V(u) u0 = 0.02; out = (1 + tanh(u/u0))/2;
vert = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1]; fac = [1 2 6 5;2 3 7 6;3 4 8 7;4 1 5 8;1 2 3 4;5 6 7 8];
classdef Kennel < handle properties id yardListener end events RollCall end methods function obj = Kennel(yard,id) obj.yardListener = event.listener(yard, obj.id = id; end function Report(obj,~,~) fprintf( notify(obj, end end end
classdef Dog properties name kennel kennelListener end methods function obj = Dog(name,kennel) obj.name = name; obj.kennel = kennel; obj.kennelListener = event.listener(kennel, end function Report(obj,kennel,~) fprintf( end end end
Y = Yard; % Construct two Dog objects, in each case constructing a new Kennel object to pass to the constructor dogs = [Dog( % Construct a third Dog, reusing the Kennel object assigned to dog(1) dogs(3) = Dog(
Kennel 2 is in the yard Rex is in kennel 2 Kennel 1 is in the yard Rover is in kennel 1 Fido is in kennel 1
classdef MyClass < handle properties listener % listeners are themselves handle objects end methods %% Class constructor creates a listener %% Class methods function delete(obj) % do this for all handle object properties % Also, avoid calling constructors for handle objects in % the properties block. That can create references to handle % objects which can only be cleared by a restart if ishandle(obj.listener) delete(obj.listener) end end end end
%% build gui in hg set(hg, h = uicontrol(hg, function myCallback(h,varargin) % So now there is a reference to handleOBJ % It will persist forever, even if cleared in the caller % workspace, thus we clear it when the containing graphics % object delete callback is triggered. if isvalid(handleOBJ) set(h, else set(h, end end function deleteCallBack(varargin) % calling clear on handleOBJ clears it from the scope of the % GUI function % also call clear on the containing function clear handleOBJ clear(mfilename) end
clearvars -except data colheaders bw4 close all clc %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%% CHANGE DATA FOR EACH SAMPLE %%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% cd data=xlsread( cd %data=Sample121res; % Data name imax=length(data); % Numbers of rows in data sheet y=11900; % Number of pixels in the y on image j %% data(:,15)=data(:,9)*pi/180; % Convers Column 9 (angle of rotation) in rads data(:,16)=y-data(:,6); % Reset the Y coordinate axis to bottom left delta = 0 : 0.01 : 2*pi; % Angle in paramteric equations theta=45*pi/180; % Sample cutting angle in rads %AA=[data(:,5) % Define colors beta=acos(data(1:imax,8)./data(1:imax,7));%./acos(0); phi=atan(sin(beta).*cos(data(1:imax,15))./(sin(theta)*sin(beta).*sin(data(1:imax,15))+cos(theta)*cos(beta)))/(pi/2); phi2=phi/2+1/2; % Scales in plane angle phi between 0 and 1 gamma=atan((cos(theta)*sin(beta).*sin(data(1:imax,15))-sin(theta)*cos(beta))./... (sin(theta)*sin(beta).*sin(data(1:imax,15))+cos(theta)*cos(beta)))/(pi/2); gamma2=gamma+1/2; % Scales out of plane angle gamma between 0 and 1 %% %%%%%%%%%%%%%%%%%%%%%%%%%%% %%% MESHGRID AND COLOURMAP %%% %%%%%%%%%%%%%%%%%%%%%%%%%%% x1=data(1:imax,5); y1=data(1:imax,16); z1=phi*90; z2=gamma*90; n=300; %Create regular grid across data space [X,Y] = meshgrid(linspace(min(x1),max(x1),n), linspace(min(y1),max(y1),n)); % Creating a colormap with 10 degree constant colors map4=[0 0 1;0 1/3 1;0 2/3 1; 0 1 1;0 1 2/3;0 1 1/3;0 1 0;1/3 1 0;2/3 1 0;1 1 0;1 0.75 0;1 0.5 0;1 0.25 0;1 0 0;0.75 0 0.25;0.5 0 0.5;0.25 0 0.75; 0 0 1]; Colormap4=colormap(map4); h=colorbar; caxis([-90 90]) set(h, %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%% PLOT USING SCATTER - ISOLATE SOME REGIONS %%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% a=-10; % Lower boundary for angle interval b=10; % Upper boundary for angle interval c=z1>a & z1 < b; c=c.*1; %j=1; y1=(y1-min(y1)+1); y2=max(y1)-y1+1; [X1,Y1]=meshgrid(1:500,1:500); griddata(x1,y2,c,X1,Y1); clear c1 for i=1:imax if z1(i)< b && z1(i)> a %&& bw4(round(y1(i)),round(x1(i))) == 0 c(i) = 1; c1(round(y2(i)),round(x1(i)))=1; else c(i)= 0; c1(round(y2(i)),round(x1(i)))=0; end end C=[c c c]; %c(find(c==0)) = NaN; %contourf(X,Y,griddata(x1,y1,c,X,Y),100, figure(1), scatter(x1,y1,3,z1, axis equal axis ([0 8000 0 12000]) axis off figure(2), scatter(x1,y1,3,C, axis equal axis ([0 8000 0 12000]) axis off se=strel( bw2=imdilate(c1,se); bw4=bwlabel(bw2); bw3=imfill(bw4, max(bw4(:)); figure(3),imshow(c1, figure(4), imshow(bw2, figure(5), imshow(bw3, figure(6),imshow(label2rgb(bw4), k=ones(max(bw4(:)),1); clear bw5 for i=1:length(x1) if bw3(round(y2(i)),round(x1(i))) ~= 0 m=bw3(round(y2(i)),round(x1(i))); bw5{m}(k(m),1)=x1(i); bw5{m}(k(m),2)=y2(i); k(m)=k(m)+1; end end figure(7), imshow(~c1, hold on for i=1:max(bw4(:)) %scatter(bw5{i}(:,1),bw5{i}(:,2)) j = boundary(bw5{i}(:,1),bw5{i}(:,2),0.5); %poly=convhull(bw5{i}(:,1),bw5{i}(:,2)); %plot(bw5{i}(poly,1),bw5{i}(poly,2)), title( if polyarea(bw5{i}(j,1),bw5{i}(j,2))> 10^5; patch(bw5{i}(j,1),bw5{i}(j,2), indexminy(i)=find(min(bw5{i}(:,2)) == bw5{i}(:,2)); indexminx(i)=find(min(bw5{i}(:,1)) == bw5{i}(:,1)); indexmaxy(i)=find(max(bw5{i}(:,2)) == bw5{i}(:,2)); indexmaxx(i)=find(max(bw5{i}(:,1)) == bw5{i}(:,1)); %xmin = bw5{i}(indexminx); xmax = bw5{i}(indexmaxx); %ymin = bw5{i}(indexminy); ymax = bw5{i}(indexmaxy); str=[(indexminx(i)+indexmaxx(i))/2,(indexminy(i)+indexmaxy(i))/2, text((min(x1(i))+max(x1(i)))/2,(min(y1(i))+max(y1(i)))/2,str) polya(i)=polyarea(bw5{i}(j,1),bw5{i}(j,2)); end end spolya=sum(polya(:)) print -dpng -r500 B
this_png = rgb2gray(imread(current_png_path))>threshold;
already_taken = already_taken | this_png; % You might need to check if you need a single | or a double ||
[1] Intel C++ 13.0 (with Microsoft Software Development Kit (SDK) linker) [2] Intel C++ 13.0 (with Microsoft Visual C++ 2010 linker) [3] Intel C++ 13.0 (with Microsoft Visual C++ 2012 linker) [4] Intel C++ 12.0 (with Microsoft Software Development Kit (SDK) linker) [5] Intel C++ 12.0 (with Microsoft Visual C++ 2008 SP1 linker) [6] Intel C++ 12.0 (with Microsoft Visual C++ 2010 linker) [7] Intel C++ 11.1 (with Microsoft Visual C++ 2008 SP1 linker) [8] Intel Visual Fortran 13 (with Microsoft Software Development Kit (SDK) linker) [9] Intel Visual Fortran 13.0 (with Microsoft Visual C++ 2010 linker) [10] Intel Visual Fortran 13.0 (with Microsoft Visual C++ 2012 linker) [11] Intel Visual Fortran 12 (with Microsoft Software Development Kit (SDK) linker) [12] Intel Visual Fortran 12.0 (with Microsoft Visual C++ 2008 SP1 linker) [13] Intel Visual Fortran 12.0 (with Microsoft Visual C++ 2008 Shell linker) [14] Intel Visual Fortran 12.0 (with Microsoft Visual C++ 2010 linker) [15] Intel Visual Fortran 11.1 (with Microsoft Visual C++ 2008 SP1 linker) [16] Intel Visual Fortran 11.1 (with Microsoft Visual C++ 2008 Shell linker) [17] Microsoft Software Development Kit (SDK) 7.1 [18] Microsoft Visual C++ 2005 SP1 [19] Microsoft Visual C++ 2008 SP1 [20] Microsoft Visual C++ 2010 [21] Microsoft Visual C++ 2012
The default location for Microsoft Software Development Kit (SDK) compiler is: "C:\Program Files (x86)\Microsoft Visual Studio 10.0" but either that directory does not exist or the configuration is invalid.
Use C:\Program Files (x86)\Microsoft Visual Studio 10.0 anyway [y]/n?
Error: The Microsoft Windows Software Development Kit (SDK) installation is incomplete. Please be sure that the .NET Framework is installed correctly before attempting to reinstall the SDK.
Would you like mex to locate installed compilers [y]/n? [1] Microsoft Software Development Kit (SDK) 7.1 in C:\Program Files (x86)\Microsoft Visual Studio 10.0
mex: No compiler selected. No action taken. ************************************************************************** Warning: The MATLAB C and Fortran API has changed to support MATLAB variables with more than 2^32-1 elements. In the near future you will be required to update your code to utilize the new API. You can find more information about this at: httpx: Building with the -largeArrayDims option enables the new API. ************************************************************************** Error using mex (line 206) Unable to complete successfully.
*************************************************************************** Warning: MEX-files generated using Microsoft Windows Software Development Kit (SDK) require that Microsoft Visual Studio 2010 run-time libraries be available on the computer they are run on. If you plan to redistribute your MEX-files to other MATLAB users, be sure that they have the run-time libraries. *************************************************************************** Trying to update options file: C:\Users\Gebruiker\AppData\Roaming\MathWorks\MATLAB\R2013a\mexopts.bat From template: C:\PROGRA~1\MATLAB\R2013a\bin\win64\mexopts\mssdk71opts.bat Done . . . ************************************************************************** Warning: The MATLAB C and Fortran API has changed to support MATLAB variables with more than 2^32-1 elements. In the near future you will be required to update your code to utilize the new API. You can find more information about this at: httpx: Building with the -largeArrayDims option enables the new API. ************************************************************************** Error using mex (line 206) Unable to complete successfully.
"Perl Command Line Interpreter has stopped working"
Can Error using mex (line 206) Unable to complete successfully.
operable program or batch file. Error using mex (line 206) Unable to complete successfully.
imagePath = try im = imread(imagePath); catch exception if strcmp(exception.identifier, fprintf( im = []; else fprintf( exception.identifier, exception.message); throw(exception); end end
% Add the constraint x(4) == 3.14159 extraRow = zeros(1,m); extraRow(4) = 1.0; C = [A; extraRow]; % Add to the matrix A d = [b; 3.14159]; % Add to the RHS vector, b % Solve C*y = d for y y = C \ d;
subroutine solveSparseMatrixEqnViaSuiteSparse( m, n, nnz, i, j, v, x ) implicit none integer, intent(in) :: m ! sparse matrix rows integer, intent(in) :: n ! sparse matrix columns integer, intent(in) :: nnz ! number of nonzero entries integer, dimension(1:nnz), intent(in) :: i ! row indices of nonzero entries integer, dimension(1:nnz), intent(in) :: j ! column indices of nonzero entries real*8, dimension(1:nnz), intent(in) :: v ! values of nonzero entries real*8, dimension(1:n), intent(out) :: x ! solution vector ! I have no idea what to do next! end function solveSparseMatrixEqnViaSuiteSparse
T = permute(reshape(permute(reshape(A, size(A, 1), n, []), [2 1 3]), n, m, []), [2 1 3])
T = permute(reshape(A, size(A, 1), n, []), [2 1 3]); T = permute(reshape(T, n, m, [], size(T, 3)), [2 1 3 4]);
cellOf20x20matrices = mat2cell(matrix, ones(1,20)*20, ones(1,20)*20)
[x,y] = size(M); for i = 1:20:x for j = 1:20:y tmp = M(i:(i+19), j:(j+19)); % Do something interesting with "tmp" here. end end
A = imread( nCol = 4; % nRow = 2; % m = size(A,1)/nRow; % n = size(A,2)/nCol; % imshow(A); % out1 = reshape(permute(A,[2 1 4 3]),size(A,2),m,[],size(A,3)); out2 = permute(reshape(permute(out1,[2 1 3 4]),m,n,[],size(A,3)),[1 2 4 3]); figure; for i = 1:nCol*nRow subplot(nRow,nCol,i); imshow(out2(:,:,:,i)); end
function T = split_by_reshape_permute (A, m, n) T = permute (reshape (permute (reshape (A, size (A, 1), n, []), [2 1 3]), n, m, []), [2 1 3]); endfunction function T = split_by_mat2cell (A, m, n) l = size (A) ./ [m n]; T = mat2cell (A, repmat (m, l(1), 1), repmat (n, l (2), 1)); endfunction function t = time_it (f, varargin) t = cputime (); for i = 1:100 f(varargin{:}); endfor t = cputime () - t; endfunction Asizes = [30 50 80 100 300 500 800 1000 3000 5000 8000 10000]; Tsides = [2 5 10]; As = arrayfun (@rand, Asizes, "UniformOutput", false); for d = Tsides figure (); t1 = t2 = []; for A = As A = A{1}; s = rows (A) /d; t1(end+1) = time_it (@split_by_reshape_permute, A, s, s); t2(end+1) = time_it (@split_by_mat2cell, A, s, s); endfor semilogy (Asizes, [t1(:) t2(:)]); title (sprintf ("Splitting in %i", d)); legend ("reshape-permute", "mat2cell"); xlabel ("Length of matrix side (all squares)"); ylabel ("log (CPU time)"); endfor
function T = split_by_mat2cell (A, m, n) l = size (A) ./ [m n]; T = mat2cell (A, repmat (m, l(1), 1), repmat (n, l (2), 1), 1); T = reshape (cell2mat (T(:) endfunction
function T = split_by_mat2cell (A, lengths) dl = arrayfun (@(l, s) repmat (l, s, 1), lengths, size (A) ./ lengths, "UniformOutput", false); T = mat2cell (A, dl{:}); endfunction
[x,y] = size(matrix) k=1; % counter for i = 1:20:x for j = 1:20:y subMatrix=Matrix(i:i+19, j:j+19); subMatrixCell{k}=subMatrix; % if you want to save all the % submatrices into a cell array k=k+1; end end
for j=1:3, for i=j:3, A(i,:) = A(i,:)+A(j+1,:)+A(j+2,:) end end
>> A = rand(20000); >> tic; B=sum(A(:)); toc; tic; C=sum(sum(A)); toc Elapsed time is 0.407980 seconds. Elapsed time is 0.322624 seconds.
total = 0; for i=1:size(A,1) for j=1:size(A,2) total = total + A(i,j); end end
total = 0; for i = 1:numel(A) total = total+A(i); end
% Sum all elements under 45 in the matrix sum ( sum ( A *. ( A < 45 ) )
Size 100x100 sum(A(:)) Elapsed time is 0.000025 seconds. sum(sum(A)) Elapsed time is 0.000018 seconds. Size 10000x1 sum(A(:)) Elapsed time is 0.000014 seconds. sum(A) Elapsed time is 0.000013 seconds. Size 1000x1000 sum(A(:)) Elapsed time is 0.001641 seconds. sum(A) Elapsed time is 0.001561 seconds. Size 1000000 sum(A(:)) Elapsed time is 0.002439 seconds. sum(A) Elapsed time is 0.001697 seconds. Size 10000x10000 sum(A(:)) Elapsed time is 0.148504 seconds. sum(A) Elapsed time is 0.155160 seconds. Size 100000000 Error using rand Out of memory. Type HELP MEMORY for your options. Error in test27 (line 70) A=rand(100000000,1);
Size 100x100 The cputime for sum(A(:)) in seconds is 0 The cputime for sum(sum(A)) in seconds is 0 Size 10000x1 The cputime for sum(A(:)) in seconds is 0 The cputime for sum(sum(A)) in seconds is 0 Size 1000x1000 The cputime for sum(A(:)) in seconds is 0 The cputime for sum(sum(A)) in seconds is 0 Size 1000000 The cputime for sum(A(:)) in seconds is 0 The cputime for sum(sum(A)) in seconds is 0 Size 10000x10000 The cputime for sum(A(:)) in seconds is 0.312 The cputime for sum(sum(A)) in seconds is 0.312 Size 100000000 Error using rand Out of memory. Type HELP MEMORY for your options. Error in test27_2 (line 70) A=rand(100000000,1);
Size 10000x10000 sum(A(:)) Elapsed time is 0.151256 seconds. sum(A) Elapsed time is 0.143937 seconds. Size 10000x10000 sum(A(:)) Elapsed time is 0.149802 seconds. sum(A) Elapsed time is 0.145227 seconds. Size 10000x10000 The cputime for sum(A(:)) in seconds is 0.2808 The cputime for sum(sum(A)) in seconds is 0.312 Size 10000x10000 The cputime for sum(A(:)) in seconds is 0.312 The cputime for sum(sum(A)) in seconds is 0.312 Size 10000x10000 The cputime for sum(A(:)) in seconds is 0.312 The cputime for sum(sum(A)) in seconds is 0.312
input_lengths = [ 1 1 1 4 3 2 1 ] result = [ 1 2 3 4 4 4 4 5 5 5 6 6 7 ]
result = ones(1, sum(input_lengths )); counter = 1; for i = 1:length(input_lengths) start_index = counter; end_index = counter + input_lengths (i) - 1; result(start_index:end_index) = i; counter = end_index + 1; end
cell_result = arrayfun(@(x) repmat(x, 1, input_lengths(x)), 1:length(input_lengths), cell_result : {[1], [2], [3], [4 4 4 4], [5 5 5], [6 6], [7]} result = [cell_result{:}]; result : [ 1 2 3 4 4 4 4 5 5 5 6 6 7 ]
result = zeros(1,sum(input_lengths)); result(cumsum([1 input_lengths(1:end-1)])) = 1; result = cumsum(result);
result = zeros(1,sum(input_lengths)); result(1) = 1; result(1+cumsum(input_lengths(1:end-1))) = 1; result = cumsum(result);
selector=bsxfun(@le,[1:max(input_lengths)] V=repmat([1:size(selector,2)],size(selector,1),1); result=V(selector);
input_lengths = round(-log(1-rand(1,ILen(i)))/poisson_alpha)+1;
N 10 20 50 100 200 500 1e+03 2e+03 ------------------------------------------------------------------------------------------------------------- OP OP Daniel 0.000132 0.000132 0.000148 0.000118 0.000126 0.000325 0.000397 0.000651 Divakar 0.00012 0.000114 0.000132 0.000106 0.000115 0.000292 0.000367 0.000641 David David Luis Mendo 4.15e-05 4.37e-05 4.66e-05 3.49e-05 3.36e-05 4.37e-05 5.87e-05 0.000108 Bentoy13 Bentoy13 Luis Mendo N 5e+03 1e+04 2e+04 5e+04 1e+05 2e+05 5e+05 1e+06 ------------------------------------------------------------------------------------------------------------- OP OP Daniel 0.00105 0.0021 0.00461 0.0138 0.0242 0.0504 0.126 0.264 Divakar 0.00127 0.00284 0.00655 0.0203 0.0335 0.0684 0.185 0.396 David David Luis Mendo 0.000236 0.000446 0.000863 0.00221 0.0049 0.0118 0.0299 0.0637 Bentoy13 Bentoy13 Luis Mendo
result = zeros(1,sum(input_lengths)); result(1) = 1; result(1+cumsum(input_lengths(1:end-1))) = 1; result = cumsum(result);
Solution: With JIT Without JIT Sam for 0.74 1.22 Sam arrayfun 2.85 2.85 My for 0.62 2.57 My arrayfun 1.27 3.81 Divakar 0.26 0.28 Bentoy 0.07 0.06 Daniel 0.15 0.16 Luis Mendo 0.07 0.06
clc,clear input_lengths = randi(20,[1 10000]); % My for loop tic() C=cumsum(input_lengths); D=diff(C); results=zeros(1,C(end)); results(1,1:C(1))=1; for i=2:length(input_lengths) results(1,C(i-1)+1:C(i))=i*ones(1,D(i-1)); end toc() tic() A=arrayfun(@(i) i*ones(1,input_lengths(i)),1:length(input_lengths), R=[A{:}]; toc()
selector=bsxfun(@le,[1:max(input_lengths)] V = bsxfun(@times,selector,1:numel(input_lengths)); result = V(V~=0)
result = nonzeros(bsxfun(@times,bsxfun(@le,[1:max(input_lengths)]
fliplr(sum(input_lengths)+1-cumsum(fliplr(input_lengths))) ans = 1 2 3 4 8 11 13
idx_begs = fliplr(sum(input_lengths)+1-cumsum(fliplr(input_lengths))); result = zeros(1,sum(input_lengths)); result(idx_begs) = 1; result = cumsum(result);
result = cumsum( full(sparse(cumsum([1,input_lengths(1:end-1)]), ... ones(1,length(input_lengths)), 1, sum(input_lengths),1)) );
tolerance = 0.0001; % Choose a threshold for "close enough to zero" x(abs(x) <= tolerance) = [];
x = round(rand(1,15000)); y = x; tic,y(y==0) = [];toc Elapsed time is 0.004398 seconds. y = x; tic,y = y(y~=0);toc Elapsed time is 0.001759 seconds. y = x; tic,y = y(find(y));toc Elapsed time is 0.003579 seconds.
x = [0 0 0 1 1 0 5 0 7 0] y = [0 2 0 1 1 2 5 2 7 0]
x2=x(~(x==0 & y==0)) y2=y(~(x==0 & y==0)) x2 = [0 1 1 0 5 0 7] y2 = [2 1 1 2 5 2 7]
figure; rng(10); % subplot(2,3,1); x = rand(100,1); y = rand(100,1); plot(x,y, title( subplot(2,3,2); x = rand(100,1); y = rand(100,1); plot(x,y, title( subplot(2,3,3); x = rand(100,1); y = rand(100,1); plot(x,y, title( subplot(2,3,4); x = rand(100,1); y = rand(100,1); plot(x,y, title( subplot(2,3,5); x = rand(100,1); y = rand(100,1); plot(x,y, title( subplot(2,3,6); x = rand(100,1); y = rand(100,1); plot(x,y, title(
figure; rng(10); % subplot(2,3,1:3); x = rand(100,1); y = rand(100,1); plot(x,y, title( subplot(2,3,4:5); x = rand(100,1); y = rand(100,1); plot(x,y, title( subplot(2,3,6); x = rand(100,1); y = rand(100,1); plot(x,y, title(
hFig = findobj(...your property/value pairs here...);
>> close all >> get(0, ans = Empty matrix: 0-by-1 >> figure(1) >> get(0, ans = 1 >> figure(3) >> get(0, ans = 3 1
function [] = myMethod() if ishandle(myFigure) % will fault, cant find variable myFigure close(myFigure) % will fault delete(myFigure) % will fault end myFigure = figure() end
function [] = createMyFigure() recoveredHandle = findobj( close(recoveredHandle) delete(recoveredHandle) ishandle(recoveredHandle) myFigure = figure( end
for f=1:numel(findobj( close(figure(f)); end clear(
A(:, [list of columns]) % for whole columns A([list of rows], :) % for whole rows
A([2 4], [3 4 5 7]) . . C C C . C R R X X X R X . . C C C . C R R X X X R X
temp = a(:) % convert matrix x = temp([1 3]) % get the 1st and 3rd elements of
>> plot3(f, t, real(Y), imag(Y)) Error using plot3 Vectors must be the same lengths.
f = figure( top = subplot(2, 1, 1); bot = subplot(2, 1, 2);
f1 = figure; imshow(image1); f2 = figure; imshow(image2); % edit image 1 figure(f1); text(2,3,
get(gca) % for axis properties get(gcf) % for figure properties
% load carsmall % vars = { x = [MPG Cylinders Horsepower Model_Year]; % y = cellstr(Origin); % % t = classregtree(x, y, view(t) % yPredicted = eval(t, x); cm = confusionmat(y,yPredicted); % N = sum(cm(:)); err = ( N-sum(diag(cm)) ) / N; % % tt = prune(t, view(tt) % inst = [33 4 78 NaN]; prediction = eval(tt, inst) %
t = fitctree(x, y, view(t, y_hat = predict(t, x); cm = confusionmat(y,y_hat); tt = prune(t, view(tt) predict(tt, [33 4 78 NaN])
Warning: Matrix is close to singular or badly scaled. Results may be inaccurate. RCOND = 1.156482e-018.
A = [5/2 1/2 -1 0 0 -1/2 -1/2 0 0 1/2 1/2 0 0 0 -1/2 -1/2 0 0 -1 0 5/2 -1/2 -1 0 0 -1/2 1/2 0 0 -1/2 1/2 0 0 0 1/2 -1/2 0 0 -1 0 3/2 -1/2 1/2 0 0 -1/2 -1/2 0 0 -1/2 2 0 -1 0 -1/2 -1/2 0 0 1/2 0 1 0 0 0 0 -1/2 1/2 0 -1 0 2 0 0 0 1/2 -1/2 0 0 0 0 1]
B = [5 1 -2 0 0 -1 -1 0 0; 1 1 0 0 0 -1 -1 0 0; -2 0 5 -1 -2 0 0 -1 1; 0 0 -1 1 0 0 0 1 -1; 0 0 -2 0 3 -1 1 0 0; -1 -1 0 0 -1 4 0 -2 0; -1 -1 0 0 1 0 2 0 0; 0 0 -1 1 0 -2 0 4 0; 0 0 1 -1 0 0 0 0 2]; A = B/2; size(A) % = [9 9] det(A) % = -1.38777878078145e-17 rank(A) % = 8 C = vpa(A); det(C) % = 0.0 rank(C) % = 8
B = [5 1 -2 0 0 -1 -1 0 0; 1 1 0 0 0 -1 -1 0 0; -2 0 5 -1 -2 0 0 -1 1; 0 0 -1 1 0 0 0 1 -1; 0 0 -2 0 3 -1 1 0 0; -1 -1 0 0 -1 4 0 -2 0; -1 -1 0 0 1 0 2 0 0; 0 0 -1 1 0 -2 0 4 0; 0 0 1 -1 0 0 0 0 2] det(B) 0
edges(1000000) = struct( for i=1:1000000; edges(i).weight=1.0; end;
n=100000; edges(n)=struct( m=mat2cell(rand(n,1),ones(n,1),1); [edges(:).weight]=deal(m{:});
N=10000; edge(N) = struct( values = rand(1,N); % set the values as a vector W = mat2cell(values, 1,ones(1,N)); % convert values to a cell [edge(:).weight] = W{:};
edges.weights = weights; edges.matrices = matrices;
% Using repmat and full assignment edges = repmat(struct( % Using indexing % NOTE: Only correct if variable is uninitialized!!! edges(1:1000) = struct(
101 102 103 104 105 102 103 104 105 0 103 104 105 0 0 104 105 0 0 0 105 0 0 0 0
101 102 103 104 105 0 101 102 103 104 0 0 101 102 103 0 0 0 101 102 0 0 0 0 101
vec = 101:105; A = full(spdiags(repmat(vec,5,1),0:4,5,5)); % The second matrix B = fliplr(full(spdiags(repmat(fliplr(vec),5,1),0:4,5,5))); % The first matrix
[output1,output2,output3]=calltoafunctionwithlotsofinputs(... intput1, input2, input3, input4, input5, ...
y = rand(1,10); subplot(211) plot(1:10,y) xlabel( ylabel( view([-90 90]) subplot(212) plot(1:10,y) xlabel( ylabel( camroll(90)
A=[ ... 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
>> n = 10; >> shift = 1; >> A = diag(ones(n-abs(shift),1),shift) A = 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
A = 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0
n = 10 shift = 1 A = full(sparse(1:n-shift,1+shift:n,1,n,n))
>> shift = 1; >> N=10; >> A=circshift(diag(1:N>shift),-shift) A = 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
n=10; shift = 1; c = repmat(1-shift:n-shift,n,1,1); r = repmat((1:n). out = r == c
rot90(blkdiag(zeros(abs(shift)),rot90(eye(n))),sign(shift))
symbols = [ MAX_ST_LENGTH = 50; stLength = randi(MAX_ST_LENGTH); nums = randi(numel(symbols),[1 stLength]); st = symbols (nums);
length = 10; random_string = char(floor(94*rand(1, length)) + 32);
temp_name = tempname [temp1, rand_string] = fileparts(temp_name)
function a=addxy(x,y) a=x+y; function b=mxy(x,y) b=x*y; function c=dxy(x,y) c=x/y;
function [d e f]=answer(x,y) d=addxy(x,y); e=mxy(x,y); f=dxy(x,y); z=[d e f]
x = 2; y = 2; [d e f] = answer(x,y); fprintf( fprintf( fprintf(
function result=answer(x,y) result(1)=addxy(x,y); result(2)=mxy(x,y); result(3)=dxy(x,y);
classdef foo methods function obj = foo(arg1, arg2) %foo constructor end end end
>> m = str2func( m = @containers.Map >> x = m({ x = containers.Map handle Package: containers Properties: Count: 2 KeyType: ValueType: Methods, Events, Superclasses
% pathName = fullfile(pwd, % p = textscan(path, if ~any(ismember(p,pathName)) addpath(pathName) end % w = what(pathName); % fNames = cellfun(@(s) s(1:end-2), w.m, fNames = [fNames ; w.classes]; % % mt = cellfun(@meta.class.fromName, fNames, mt = mt( ~cellfun(@isempty,mt) ); % % objects = cell(numel(mt),1); for i=1:numel(mt) % ctorMT = findobj(mt{i}.MethodList, % numArgs = numel(ctorMT.InputNames); % args = repmat({0}, [numArgs 1]); % try obj = feval(ctorMT.Name,args{:}); catch ME warning(ME.identifier, ME.message) obj = []; end % objects{i} = obj; end
classdef hello properties name = end methods function this = hello() this.name = end function val = get.name(obj) val = obj.name; end function obj = set.name(obj,val) obj.name = val; end function say(obj) fprintf( end end end
classdef hello2 properties name end methods function this = hello2(val) this.name = val; end function val = get.name(obj) val = obj.name; end function obj = set.name(obj,val) obj.name = val; end end methods say(obj) end end
function f = rtfib(n) if (n==1) f= 1; elseif (n == 2) f = 2; else f =rtfib(n-1) + rtfib(n-2); end
tic; rtfib(20), toc ans = 10946 Elapsed time is 0.134947 seconds. tic; rtfib(30), toc ans = 1346269 Elapsed time is 16.6724 seconds.
function f = fib(n) if (n == 1) f = 1; elseif (n == 2) f = 2; else fOld = 2; fOlder = 1; for i = 3 : n f = fOld + fOlder; fOlder = fOld; fOld = f; end end end
function [] = fib(n) fL = uint64(0); fH = uint64(0); MaxNum = uint64(1e19); if (n == 1) fL = 1; elseif (n == 2) fL = 2; else fOldH = uint64(0); fOlderH = uint64(0); fOldL = uint64(2); fOlderL = uint64(1); for i = 3 : n [fL q] = LongSum (fOldL , fOlderL , MaxNum); fH = fOldH + fOlderH + q; fOlderL = fOldL; fOlderH = fOldH; fOldL = fL; fOldH = fH; end end sprintf( end
function [s q] = LongSum (a, b, MaxNum) if a + b >= MaxNum q = 1; if a >= MaxNum s = a - MaxNum; s = s + b; elseif b >= MaxNum s = b - MaxNum; s = s + a; else s = MaxNum - a; s = b - s; end else q = 0; s = a + b; end
sqrt5 = sqrt(5); alpha = (1 + sqrt5)/2; % fibs = round( alpha.^n ./ sqrt5 )
>> fib = @(n) evalin(symengine, [ >> fib(274) ans = 818706854228831001753880637535093596811413714795418360007
% see if you can beat that! >> tic >> x = fib(100000); >> toc % Elapsed time is 0.004621 seconds. % result has more than 20 thousand digits! >> length(char(x)) % 20899
syms x y % z = x + y; % xval = yval = for n = 2:300 zval = subs(z, [x y], {xval yval}); % disp([ disp(zval) xval = yval; % yval = zval; end
class Fib: def __init__(self,n): self.n=n self.fibList=[None]*(self.n+1) self.populateFibList() def populateFibList(self): for i in range(len(self.fibList)): if i==0: self.fibList[i]=0 if i==1: self.fibList[i]=1 if i>1: self.fibList[i]=self.fibList[i-1]+self.fibList[i-2] def getFib(self): print( for i in range(len(self.fibList)): print(i, return self.fibList[self.n] def isNonnegativeInt(value): try: if int(value)>=0: return True else: return False except: return False n=input( while isNonnegativeInt(n)==False: n=input( n=int(n) print( print(
for j = 1: 1: 24 % LABEL start a = a + j; if a > 10 goto( return else a = a + 1; end end
q = quiver(1:5, 1:5, 1:5, 1:5); handles = findall(q,
q = quiver(1, 1, 1, 1); headLineStrip = q.Head; tailLineStrip = q.Tail;
mags = sqrt(sum(cat(2, q.UData(:), q.VData(:), ... reshape(q.WData, numel(q.UData), [])).^2, 2));
% Get the current colormap currentColormap = colormap(gca); % Now determine the color to make each arrow using a colormap [~, ~, ind] = histcounts(mags, size(currentColormap, 1)); % Now map this to a colormap cmap = uint8(ind2rgb(ind(:), currentColormap) * 255);
% x = 1:10; y = 1:10; [X,Y] = meshgrid(x, y); Z = zeros(size(X)); U = zeros(size(X)); V = zeros(size(X)); W = sqrt(X.^2 + Y.^2); q = quiver3(X, Y, Z, U, V, W); % mags = sqrt(sum(cat(2, q.UData(:), q.VData(:), ... reshape(q.WData, numel(q.UData), [])).^2, 2)); % currentColormap = colormap(gca); % [~, ~, ind] = histcounts(mags, size(currentColormap, 1)); % cmap = uint8(ind2rgb(ind(:), currentColormap) * 255); cmap(:,:,4) = 255; cmap = permute(repmat(cmap, [1 3 1]), [2 1 3]); % set(q.Head, ... % set(q.Tail, ...
clims = num2cell(get(gca, [~, ~, ind] = histcounts(mags, linspace(clims{:}, size(currentColormap, 1)));
figure [x,y] = meshgrid(-2:.5:2,-1:.5:1); z = x .* exp(-x.^2 - y.^2); [u,v,w] = surfnorm(x,y,z); h=quiver3(x,y,z,u,v,w); s = size(x); nPoints = s(1)*s(2); % create a colour map cmap = parula(nPoints); % x2 because each point has 2 points, a start and an end. cd = uint8(repmat([255 0 0 255] count = 0; % we need to assign a colour per point for ii=1:nPoints % and we need to assign a colour to the start and end of the % line. for jj=1:2 count = count + 1; cd(1:3,count) = uint8(255*cmap(ii,:) end end % set the colour binding method and the colour data of the tail set(h.Tail, % create a color matrix for the heads cd = uint8(repmat([255 0 0 255] count = 0; % we need to assign a colour per point for ii=1:nPoints % and we need to assign a colour to the all the points % at the head of the arrow for jj=1:3 count = count + 1; cd(1:3,count) = uint8(255*cmap(ii,:) end end % set the colour binding method and the colour data of the head set(h.Head,
f = @(x) nchoosek(5,x)*0.1.^x*0.9.^(5-x) sum(f([0:5]))
error: called from: error: /usr/share/octave/3.6.4/m/help/print_usage.m at line 87, column 5 error: /usr/share/octave/3.6.4/m/specfun/nchoosek.m at line 95, column 5 error: at line -1, column -1 error: evaluating argument list element number 1
f = @(x) nchoosek(5,x)*0.1.^x*0.9.^(5-x) sum(arrayfun(f,[0:5]))
matlab -nodisplay -r "try, myFunction(); catch e, disp(getReport(e)), exit(7), end, exit()"
A = sprand(2000,2000,0.25); tic,B = A*A;toc Elapsed time is 1.771668 seconds. Af = full(A); tic,B = Af*Af;toc Elapsed time is 0.499045 seconds.
A = sprand(2000,2000,0.005); Af = full(A); tic,B = A*A;toc Elapsed time is 0.037763 seconds. tic,B = Af*Af;toc Elapsed time is 0.446680 seconds.
function left = remove(cells, item); left = cells{cellfun(@(i) ~isequal(item, i), cells)};
function left = remove(cells, item) left = cells(cellfun(@(i) ~isequal(item, i), cells));
left = {cells{cellfun(@(i) ~isequal(item, i), cells)}};
function y = boolean(x) %BOOLEAN Creates a boolean vector. % This function is typically used in Simulink parameter dialogs, such as % the Constant block dialog. This function generates a logical vector, % which is treated as a boolean value in Simulink. Now that logical is a % MATLAB type, this function is essentially just an alias. % % Y = BOOLEAN(X) Converts the vector X into a boolean vector. % % Example: % boolean([0 1 1]) returns [0 1 1] % % See also LOGICAL. % Copyright 1990-2012 The MathWorks, Inc. narginchk(1,1); if ~isreal(x) DAStudio.error( end y = logical(x);
>> cast(a, Error using cast Unsupported class for conversion.
>> hold(gca) Current plot released >> hold(gca) Current plot held
clear all; close all; template = rgb2gray(imread( background = rgb2gray(imread( %% calculate padding bx = size(background, 2); by = size(background, 1); tx = size(template, 2); % used for bbox placement ty = size(template, 1); %% fft c = real(ifft2(fft2(background) .* fft2(template, by, bx))); %% find peak correlation [max_c, imax] = max(abs(c(:))); [ypeak, xpeak] = find(c == max(c(:))); figure; surf(c), shading flat; % plot correlation %% display best match hFig = figure; hAx = axes; position = [xpeak(1)-tx, ypeak(1)-ty, tx, ty]; imshow(background, imrect(hAx, position);
clear all; close all; template = rgb2gray(imread( background = rgb2gray(imread( %% calculate padding bx = size(background, 2); by = size(background, 1); tx = size(template, 2); % used for bbox placement ty = size(template, 1); %% fft %c = real(ifft2(fft2(background) .* fft2(template, by, bx))); % Ga = fft2(background); Gb = fft2(template, by, bx); c = real(ifft2((Ga.*conj(Gb))./abs(Ga.*conj(Gb)))); %% find peak correlation [max_c, imax] = max(abs(c(:))); [ypeak, xpeak] = find(c == max(c(:))); figure; surf(c), shading flat; % plot correlation %% display best match hFig = figure; hAx = axes; % % position = [xpeak(1), ypeak(1), tx, ty]; imshow(background, imrect(hAx, position);
sum( A(n,:) .* 2.^(size(A,2)-1:-1:0) ) % for big endian sum( A(n,:) .* 2.^(0:size(A,2)-1) ) % for little endian
A_bin=bsxfun(@(a,i)logical(bitget(a,i)),A_dec,10:-1:1);
>> whos foo bar Name Size Bytes Class Attributes bar 1x1 8 double foo 1x1 1 uint8
>> whos foo bar Name Size Bytes Class Attributes bar 1x1 8 double foo 1x1 1 uint8
>> whos foo bar Name Size Bytes Class Attributes bar 1x1 8 uint8 foo 1x1 1 uint8
set(gcf, plot((1:10),(1:10).^2); print -dpng c:\chris.png % or whatever your print command is
>> A = magic(6) % A = 35 1 6 26 19 24 3 32 7 21 23 25 31 9 2 22 27 20 8 28 33 17 10 15 30 5 34 12 14 16 4 36 29 13 18 11 >> B = nlfilter(A,[3 3],@(b) b(5)*all(b(5) >= b([2 4 6 8]))) B = 35 0 0 26 0 0 0 32 0 0 0 25 31 0 0 0 27 0 0 0 0 0 0 0 30 0 34 0 0 16 0 36 0 0 18 0
array = magic(6); % msk = [0 1 0;1 0 1;0 1 0]; % % % maxNeighbour = imdilate(array,msk); % array(array<maxNeighbour) = 0; array = 35 0 0 26 0 0 0 32 0 0 0 25 31 0 0 0 27 0 0 0 0 0 0 0 30 0 34 0 0 16 0 36 0 0 18 0
nRows = size(start,1); finish = cell(nRows,1); for r = 1:nRows finish{r} = [start{r,:}]; end
>> finish = num2cell(start,1); >> finish = strcat(finish{:}) finish =
im = rgb2gray(imread( % normalize the image to be between 0 and 1 im = im/max(max(im));
[x_p, y_p] = find (points); [x, y] = meshgrid(1:size(im,1), 1:size(im,2)) r = 5; circles = zeros(size(im)); for k = 1:length(x_p) circles = circles + (floor((x - x_p(k)).^2 + (y - y_p(k)).^2) == r); end % normalize circles circles = circles/max(max(circles)); output = im + circles; imshow(output)
[x_p,y_p] = find(points); imshow(im); % hold on; % plot(y_p,x_p, hold off; %
%---------------------------------------------------------------- % H=CIRCLE(CENTER,RADIUS,NOP,STYLE) % This routine draws a circle with center defined as % a vector CENTER, radius as a scaler RADIS. NOP is % the number of points on the circle. As to STYLE, % use it the same way as you use the rountine PLOT. % Since the handle of the object is returned, you % use routine SET to get the best result. % % Usage Examples, % % circle([1,3],3,1000, % circle([2,4],2,1000, % % Zhenhai Wang <zhenhai@ieee.org> % Version 1.00 % December, 2002 %----------------------------------------------------------------
imshow(im) hold on [y, x] = find(points); for ii=1:length(x) pos = [x(ii),y(ii)]; pos = [pos-0.5,1,1]; rectangle( end
k = convhull(x,y); figure; imshow(image); % hold on; % plot(x,y, hold off; %
yellow = uint8([255 255 0]); % shapeInserter = vision.ShapeInserter( I = imread( circles = int32([30 30 20; 80 80 25]); % RGB = repmat(I,[1,1,3]); % J = step(shapeInserter, RGB, circles); imshow(J);
% Plot 5 circles at random locations X = rand(5,1); Y = rand(5,1); % Keep the radius 0.1 for all of them R = 0.1*ones(5,1); % Make them blue viscircles([X,Y],R,
% Read the image into the workspace and display it. A = imread( imshow(A) % Find all the circles with radius r such that 15 ≤ r ≤ 30. [centers, radii, metric] = imfindcircles(A,[15 30]); % Retain the five strongest circles according to the metric values. centersStrong5 = centers(1:5,:); radiiStrong5 = radii(1:5); metricStrong5 = metric(1:5); % Draw the five strongest circle perimeters. viscircles(centersStrong5, radiiStrong5,
[x_p, y_p] = find (points); % convert the subscripts to indicies, but transposed into a row vector a = sub2ind(size(im), x_p, y_p) % assign all the values in the image that correspond to the points to a value of zero im([a]) = 0; % show the new image imshow(im)
classdef RefValue < handle properties data = []; end end
x = RefValue; x.data = 1; y = x; x.data = 10; disp(y.data) %Displays 10.
x = 1; y = @(x) x; y(x) % displays 1 x = 10; y(x) % displays 10
import re, sys def startswith(line=""): ctrlstart = ctrlcont = ctrlend = match = re.match(ctrlstart, line) if ( match != None ) : return [ match=re.match(ctrlcont, line) if ( match!=None ) : return [ match=re.match(ctrlend, line) if ( match!=None ) : return [ else : return [False, None] def main( filelist = list() ) : for filename in filelist: nextindent = 0 indentmult = 2 file = open(filename, filelines = file.readlines() for ind in range(0, len(filelines)) : indentlevel = nextindent match = startswith(filelines[ind]) if match[0] == nextindent += 1 elif match[0] == indentlevel -= 1 elif match[0] == indentlevel -= 1 nextindent -= 1 elif match[0] == False : nextindent = indentlevel filelines[ind] = outfile = open(filename + outfile.writelines(filelines) file.close() outfile.close() args = [] for arg in sys.argv[1:] : args += [str(arg)] main(args)
% fileName = mlintID = mlintData = mlint(fileName, index = strcmp({mlintData.id},mlintID); % lineNumbers = [mlintData(index).line]; % % fid = fopen(fileName, linesOfCode = textscan(fid, fclose(fid); % linesOfCode = linesOfCode{1}; % linesOfCode(lineNumbers) = strcat(linesOfCode(lineNumbers), % fid = fopen(fileName, fprintf(fid, fprintf(fid, fclose(fid);
% ed = matlab.desktop.editor.getActive().JavaEditor.getTextComponent(); % msgs = com.mathworks.widgets.text.mcode.MLint.getMessages(ed.getText(),ed.getFilename()) % % % for i = msgs.size-1:-1:0 if msgs.get(i).hasAutoFix() com.mathworks.widgets.text.mcode.analyzer.CodeAnalyzerUtils.applyAutoFixes(ed,msgs.get(i).getAutoFixChanges); end end
>> checkcode(matlab.desktop.editor.getActiveFilename(), L 2 (C 3): Terminate statement with semicolon to suppress output (in functions). (CAN FIX) ----FIX MESSAGE <Add a semicolon.> ----CHANGE MESSAGE L 2 (C 13); L 2 (C 12): <;> L 30 (C 52-53): Input argument ----FIX MESSAGE <Replace name by ~.> ----CHANGE MESSAGE L 30 (C 52); L 30 (C 53): <~>
function str = applyAutoFixes(filepath) msgs = checkcode(filepath, fid = fopen(filepath, iiLine = 1; lines = cell(0); line = fgets(fid); while ischar(line) lines{iiLine} = line; iiLine = iiLine+1; line = fgets(fid); end fclose(fid); pos = [0 cumsum(cellfun( str = [lines{:}]; fixes = msgs([msgs.fix] == 4); % % % for fix = fliplr(fixes(:) % change_start = pos(fix.line(1)) + fix.column(1,1); change_end = pos(fix.line(2)) + fix.column(2,1); if change_start >= change_end % str = [str(1:change_start) fix.message str(change_start+1:end)]; else % str = [str(1:change_start-1) fix.message str(change_end+1:end)]; end end
function [] = add_semicolon(fileName) % mlintIDinScript = mlintIDinFunction = mlintData = mlint(fileName, index = strcmp({mlintData.id},mlintIDinScript) | strcmp({mlintData.id},mlintIDinFunction); % lineNumbers = [mlintData(index).line]; % if isempty(lineNumbers) return; end; % fid = fopen(fileName, %linesOfCode = textscan(fid, lineNo = 0; tline = fgetl(fid); while ischar(tline) lineNo = lineNo + 1; linesOfCode{lineNo} = tline; tline = fgetl(fid); end fclose(fid); % %linesOfCode = linesOfCode{1}; % linesOfCode(lineNumbers) = strcat(linesOfCode(lineNumbers), % fim = fopen(fileName, fprintf(fim, fprintf(fim, fclose(fim);
function moveLabel(ax,offset,hFig,hAxes) % get figure position posFig = get(hFig, % get axes position in pixels set(hAxes, posAx = get(hAxes, % get label position in pixels if ax== set(get(hAxes, posLabel = get(get(hAxes, else set(get(hAxes, posLabel = get(get(hAxes, end % resize figure if ax== posFigNew = posFig + [0 -offset 0 offset]; else posFigNew = posFig + [-offset 0 offset 0]; end set(hFig, % move axes if ax== set(hAxes, else set(hAxes, end % move label if ax== set(get(hAxes, else set(get(hAxes, end % set units back to set(hAxes, if ax== set(get(hAxes, else set(get(hAxes, end end
figure plot(rand(1,10)) set(gca, pos = get(gca, offset = 0.1; set(gca, ... h = xlabel( set(h, pos = get(h, set(h,
relative_offset = 1.5; close all; figure(99);clf plot(rand(1,10)) xlabel( xh = get(gca, pause(0.2) set(xh, pause(0.2) pos = get(xh, set(xh,
hold on plot(t1,Dx1, xlabel( ylabel( plot(t1,Dy1, plot(t1,Dz1, hold off
function []=TickFixExample() figure %this one works myRenderer= set(gcf, axesh = axes(); set(gca, title(myRenderer) ticklabelformat(gca, figure %this one doesn’t work myRenderer= set(gcf, axesh = axes(); set(gca, title(myRenderer) ticklabelformat(gca,
tickLabels = arrayfun(@(x)(FormatNumberScalarInputStrOutput`(x,format)),tickValues,
tickLabels = arrayfun(@(x)(sprintf(format,x)),tickValues,
function y = FormatNumberScalarInputStrOutput(Number ,FormatPattern) % adapted 12-2012 by D. Bourgoyne from NUMBERFORMATTER by S. Lienhard % % The pound sign ( % grouping separator, and the period is a placeholder for the decimal % separator. % The pattern specifies leading and trailing zeros, because the 0 % character is used instead of the pound sign ( % % Examples: % NumberFormatter(rand(5), % NumberFormatter(rand(5)*100, import java.text.* v = DecimalFormat(FormatPattern); y = char(v.format(Number));
x = 0:0.1:10; y = 1000*x.^2; %Plot with default notation: subplot(1,2,1) plot(x,y) %Plot without exponent: subplot(1,2,2) plot(x,y) ax = gca ax.YAxis.Exponent = 0;
ytick = get(gca, for i = 1:length(ytick) yticklabel{i} = sprintf(y_formatstring, ytick(i)); end set(gca,
matlabpool open try parfor … finally matlabpool close end
function doSomething matlabpool open cleaner = onCleanup(@() matlabpool( parfor ... %
A = 1:16; for ii = 1:8 data{ii} = A(2*ii-1:2*ii); end
output = cell(1,8); parfor ii = 1:8 output{ii} = data{ii}; end
poolObj = parpool(workerCnt); jobCnt = length(data); % number of jobs output = cell(jobCnt,1); for jobNo = 1:jobCnt future(jobNo) = parfeval(poolObj,@getOutput,... nargout( end doneJobs = false(jobCnt,1); while ~all(doneJobs) [idx,result] = fetchnext(future); output{idx} = result; doneJobs(idx) = true; end
poolObj = parpool(workerCnt); jobCnt = length(data); % number of jobs output = cell(jobCnt,1); for jobNo = 1:jobCnt future(jobNo) = parfeval(poolObj,@getOutput,... nargout( end doneJobs = false(jobCnt,1); while ~all(doneJobs) [idx,result] = fetchnext(future); furure(idx) = []; % remove the done future object oldIdx = 0; % find the index offset and correct index accordingly while oldIdx ~= idx doneJobsInIdxRange = sum(doneJobs((oldIdx + 1):idx)); oldIdx = idx idx = idx + doneJobsInIdxRange; end output{idx} = result; doneJobs(idx) = true; end
%{ ... Block of COMMENTS HERE ... ... %} %CODE GOES HERE plot(1:10)
m1=[1:2, 1:2] ... m5=[9:10, 9:10] m6=[10:11, 10:-1:9] ... m10=[19:20, 2:-1:1]
m = rand(10,2); %Generate data x = m(:,1); %split into x and y y = m(:,2); topEdge = 1; % define limits botEdge = 0; % define limits numBins = 2; % define number of bins binEdges = linspace(botEdge, topEdge, numBins+1); [h,whichBin] = histc(x, binEdges); for i = 1:numBins flagBinMembers = (whichBin == i); binMembers = y(flagBinMembers); binMean(i) = mean(binMembers); end
01 02 02 01 01 02 01 01 02 02 02 03 04 04 03 01 02 06 10 05 02 02 08 09 05
% conv2_out = conv2(A,ones(2,2), % [~,idx] = max(conv2_out(:)) [R,C] = ind2sub(size(A),idx) % max_window = A(R:R+1,C:C+1) % out = mean2(max_window)
A = 1 2 2 1 1 2 1 1 2 2 2 3 4 4 3 1 2 6 10 5 2 2 8 9 5 conv2_out = 6 6 6 6 3 8 9 11 11 5 8 15 24 22 8 7 18 33 29 10 4 10 17 14 5 idx = 14 R = 4 C = 3 max_window = 6 10 8 9 out = 8.25
% conv_out = convn(A,ones(2,2), % [~,idx] = max(reshape(conv_out,[],size(conv_out,3)),[],1) max_avg_vals = conv_out([0:size(A,3)-1]*numel(A(:,:,1)) + idx)/4 % nrows = size(A,1) start_idx = [0:size(A,3)-1]*numel(A(:,:,1)) + idx all_idx = bsxfun(@plus,permute(start_idx(:),[3 2 1]),[0 nrows;1 nrows+1]) max_window = A(all_idx)
>> A A(:,:,1) = 4 1 9 9 3 7 5 5 9 6 1 6 7 1 1 5 4 2 2 1 A(:,:,2) = 9 4 2 2 3 6 4 5 3 9 1 1 6 6 8 8 5 3 6 4 A(:,:,3) = 5 5 7 7 6 1 9 9 7 7 5 4 4 1 3 7 1 9 3 1 >> max_window max_window(:,:,1) = 9 9 5 5 max_window(:,:,2) = 8 8 6 4 max_window(:,:,3) = 7 7 9 9 >> max_avg_vals max_avg_vals = 7 6.5 8
A = [01 02 02 01 01 02 01 01 02 02 02 03 04 04 03 01 02 06 10 05 02 02 08 09 05]; B = [1 1;1 1] / 4 ; % C = conv2(A,B,
C = 1.5 1.5 1.5 1.5 2 2.25 2.75 2.75 2 3.75 6 5.5 1.75 4.5 8.25 7.25
% cols = im2col(A,[2 2], % C = reshape(mean(cols),size(A,1)-1,[]); % [B,i] = max(mean(cols)); % mat = reshape(cols(:,i),2,2);
>> mat mat = 6 10 8 9 >> C C = 1.5000 1.5000 1.5000 1.5000 2.0000 2.2500 2.7500 2.7500 2.0000 3.7500 6.0000 5.5000 1.7500 4.5000 8.2500 7.2500 >> B B = 8.2500
b=surf(x,y,z); colormap(topobathy); cbar1=colorbar; set(get(cbar1, hold on; s=surf(x,y,z1, hold on; change=z-z0; c=pcolor(x,y,change) set(c, colormap(redwhitegreen)`
h = colorbar; ticks = [1 16:16:64 64:16:128]; ticks(5:6) = [62 66]; set(h, labels = num2str(repmat(linspace(min(Z(:)), max(Z(:)), 5), 1, 2) set(h,
data2 = data2 - lower_limit; data2 = double(data2./(upper_limit2 - lower_limit2)) + 1;
pcolor(handle_axes1, x_axis, y_axis, data1); shading(handle_axes1, caxis(handle_axes1, [0 2]); % Colorbar h_colorbar = colorbar( set(h_colorbar, labels = num2str(linspace(lower_limit1, upper_limit1, 6) set(h_colorbar, set(h_colorbar,
pcolor(handle_axes2, x_axis, y_axis, data2); shading(handle_axes2, caxis(handle_axes2, [0 2]); % Colorbar h_colorbar2 = colorbar( set(h_colorbar2, labels = num2str(linspace(lower_limit2, upper_limit2, 6) set(h_colorbar2, set(h_colorbar2,
im1 = load( im2 = load( ax1 = subplot(1,2,1); imagesc(im1.X) axis(ax1, ax2 = subplot(1,2,2); imagesc(im2.X) axis(ax2,
CmLength = length(colormap); % Colormap length BeginSlot1 = 1; % Beginning slot EndSlot1 = length(im1.map); % Ending slot BeginSlot2 = EndSlot1 + 1; EndSlot2 = CmLength; CLim1 = get(ax1, CLim2 = get(ax2,
function CLim = newclim(BeginSlot,EndSlot,CDmin,CDmax,CmLength) % Convert slot number and range % to percent of colormap PBeginSlot = (BeginSlot - 1) / (CmLength - 1); PEndSlot = (EndSlot - 1) / (CmLength - 1); PCmRange = PEndSlot - PBeginSlot; % Determine range and min and max % of new CLim values DataRange = CDmax - CDmin; ClimRange = DataRange / PCmRange; NewCmin = CDmin - (PBeginSlot * ClimRange); NewCmax = CDmax + (1 - PEndSlot) * ClimRange; CLim = [NewCmin,NewCmax]; end
global hidden_var hidden_var = 1; clear global hidden_var hidden_var
