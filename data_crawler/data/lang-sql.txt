INSERT INTO Table (col1, col2, col3) SELECT col1, col2, col3 FROM other_table WHERE sql =
UPDATE Table SET col1, col2 SELECT col1, col2 FROM other_table WHERE sql = WHERE Table.id = other_table.id
UPDATE Table_A SET Table_A.col1 = Table_B.col1, Table_A.col2 = Table_B.col2 FROM Some_Table AS Table_A INNER JOIN Other_Table AS Table_B ON Table_A.id = Table_B.id WHERE Table_A.col3 =
MERGE INTO YourTable T USING other_table S ON T.id = S.id AND S.tsql = WHEN MATCHED THEN UPDATE SET col1 = S.col1, col2 = S.col2;
MERGE INTO YourTable T USING ( SELECT id, col1, col2 FROM other_table WHERE tsql = ) S ON T.id = S.id WHEN MATCHED THEN UPDATE SET col1 = S.col1, col2 = S.col2;
UPDATE table SET Col1 = i.Col1, Col2 = i.Col2 FROM ( SELECT ID, Col1, Col2 FROM other_table) i WHERE i.ID = table.ID
UPDATE Table SET Table.col1 = other_table.col1, Table.col2 = other_table.col2 FROM Table INNER JOIN other_table ON Table.id = other_table.id WHERE Table.col1 != other_table.col1 OR Table.col2 != other_table.col2 OR ( other_table.col1 IS NOT NULL AND Table.col1 IS NULL ) OR ( other_table.col2 IS NOT NULL AND Table.col2 IS NULL )
UPDATE t SET t.col1 = o.col1, t.col2 = o.col2 FROM other_table o JOIN t ON t.id = o.id WHERE o.sql =
;WITH CTE AS (SELECT T1.Col1, T2.Col1 AS _Col1, T1.Col2, T2.Col2 AS _Col2 FROM T1 JOIN T2 ON T1.id = T2.id WHERE EXISTS(SELECT T1.Col1, T1.Col2 EXCEPT SELECT T2.Col1, T2.Col2)) UPDATE CTE SET Col1 = _Col1, Col2 = _Col2
UPDATE first_table, second_table SET first_table.color = second_table.color WHERE first_table.id = second_table.foreign_id
UPDATE t SET t.col1 = o.col1 FROM table1 AS t INNER JOIN table2 AS o ON t.id = o.id
UPDATE table_to_update, table_info SET table_to_update.col1 = table_info.col1, table_to_update.col2 = table_info.col2 WHERE table_to_update.ID = table_info.ID
update Table set Table.example = a.value from TableExample a where Table.field = *key value* -- finds the row in Table AND a.field = *key value* -- finds the row in TableExample a
UPDATE suppliers SET supplier_name = (SELECT customers.name FROM customers WHERE customers.customer_id = suppliers.supplier_id) WHERE EXISTS (SELECT customers.name FROM customers WHERE customers.customer_id = suppliers.supplier_id);
UPDATE Table SET Table.col1 = other_table.col1, Table.col2 = other_table.col2 --select Table.col1, other_table.col,Table.col2,other_table.col2, * FROM Table INNER JOIN other_table ON Table.id = other_table.id
UPDATE Table1 INNER JOIN Table2 ON Table1.id = Table2.id SET Table1.col1 = Table2.col1, Table1.col2 = Table2.col2
update t1 -- just reference table alias here set t1.somevalue = t2.somevalue from table1 t1 -- these rows will be the targets inner join table1 t2 -- these rows will be used as source on .................. -- the join clause is whatever suits you
UPDATE x SET x.col1 = x.newCol1, x.col2 = x.newCol2 FROM (SELECT t.col1, t2.col1 AS newCol1, t.col2, t2.col2 AS newCol2 FROM [table] t JOIN other_table t2 ON t.ID = t2.ID) x
;WITH cte AS (SELECT col1,col2,id FROM other_table WHERE sql = UPDATE A SET A.col1 = B.col1, A.col2 = B.col2 FROM table A INNER JOIN cte B ON A.id = B.id
UPDATE Table1 SET Table1.col1 = Table2.col1, Table1.col2 = Table2.col2 FROM Table2 WHERE Table1.id = Table2.id
UPDATE t SET t.col1 = a.col1 ,t.col2 = a.col2 FROM ( SELECT id, col1, col2 FROM @tbl2) a INNER JOIN @tbl1 t ON t.id = a.id
DECLARE @tbl1 TABLE (id INT, col1 VARCHAR(10), col2 VARCHAR(10)) DECLARE @tbl2 TABLE (id INT, col1 VARCHAR(10), col2 VARCHAR(10)) INSERT @tbl1 SELECT 1, INSERT @tbl2 SELECT 1, UPDATE t SET t.col1 = a.col1 ,t.col2 = a.col2 FROM ( SELECT id, col1, col2 FROM @tbl2) a INNER JOIN @tbl1 t ON t.id = a.id SELECT * FROM @tbl1 SELECT * FROM @tbl2
UPDATE TQ SET TQ.IsProcessed = 1, TQ.TextName = FROM TableQueue TQ INNER JOIN TableComment TC ON TC.ID = TQ.TCID WHERE TQ.IsProcessed = 0
SELECT TQ.IsProcessed, 1 AS NewValue1, TQ.TextName, FROM TableQueue TQ INNER JOIN TableComment TC ON TC.ID = TQ.TCID WHERE TQ.IsProcessed = 0
drop table uno drop table dos create table uno ( uid int, col1 char(1), col2 char(2) ) create table dos ( did int, col1 char(1), col2 char(2), [sql] char(4) ) insert into uno(uid) values (1) insert into uno(uid) values (2) insert into dos values (1, insert into dos values (2, select * from uno select * from dos
update uno set col1 = (select col1 from dos where uid = did and [sql]= col2 = (select col2 from dos where uid = did and [sql]=
update uno set col1=d.col1,col2=d.col2 from uno inner join dos d on uid=did where [sql]= select * from uno select * from dos
update uno set col1 = (select col1 from dos d where uno.[id] = d.[id] and [sql]= col2 = (select col2 from dos d where uno.[id] = d.[id] and [sql]=
UPDATE table1 a , table2 b SET a.columname = WHERE b.columnname IS NULL ;
SET Table_A.col1 = Table_B.col1, Table_A.col2 = Table_B.col2
UPDATE A SET A.col = A.col,B.col1 = B.col1 FROM first_Table AS A INNER JOIN second_Table AS B ON A.id = B.id WHERE A.col2 =
UPDATE table AS a INNER JOIN table2 AS b ON a.col1 = b.col1 INNER JOIN ... AS ... ON ... = ... SET ... WHERE ...
CREATE TABLE [dbo].[Product]( [Id] [int] IDENTITY(1, 1) NOT NULL, [Name] [nvarchar](100) NOT NULL, [Description] [nvarchar](100) NULL ) ON [PRIMARY]
CREATE TABLE [dbo].[Product_BAK]( [Id] [int] IDENTITY(1, 1) NOT NULL, [Name] [nvarchar](100) NOT NULL, [Description] [nvarchar](100) NULL ) ON [PRIMARY]
update P1 set Name = P2.Name from Product P1 inner join Product_Bak P2 on p1.id = P2.id where p1.id = 2
; With CTE as ( select id, name from Product_Bak where id = 2 ) update P set Name = P2.name from product P inner join CTE P2 on P.id = P2.id where P2.id = 2
Merge into product P1 using Product_Bak P2 on P1.id = P2.id when matched then update set p1.[description] = p2.[description], p1.name = P2.Name;
Merge into product P1 using Product_Bak P2 on P1.id = P2.id; when matched then update set p1.[description] = p2.[description], p1.name = P2.Name; WHEN NOT MATCHED THEN insert (name, description) values(p2.name, P2.description);
UPDATE T1 SET T1.col1 = T2.col1, T1.col2 = T2.col2 FROM Table1 AS T1 INNER JOIN Table2 AS T2 ON T1.id = T2.id WHERE T1.col3 =
declare @tblStudent table (id int,name varchar(300)) declare @tblMarks table (std_id int,std_name varchar(300),subject varchar(50),marks int) insert into @tblStudent Values (1, insert into @tblStudent Values(2, insert into @tblMarks Values(1, insert into @tblMarks Values(1, insert into @tblMarks Values(2, insert into @tblMarks Values(2, select * from @tblMarks update m set m.std_name=s.name from @tblMarks as m left join @tblStudent as s on s.id=m.std_id select * from @tblMarks
UPDATE Table SET col1, col2 FROM table inner join other_table Table.id = other_table.id WHERE sql =
IF EXISTS(SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = AND COLUMN_NAME =
IF EXISTS(SELECT 1 FROM sys.columns WHERE Name = N AND Object_ID = Object_ID(N BEGIN -- Column Exists END
if not exists (select column_name from INFORMATION_SCHEMA.columns where table_name = and column_name = alter table MyTable add MyColumn int
IF NOT EXISTS( SELECT TOP 1 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE [TABLE_NAME] = AND [COLUMN_NAME] = BEGIN ALTER TABLE [Employees] ADD [EmployeeID] INT NULL END
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ORDER BY ORDINAL_POSITION
IF NOT EXISTS ( SELECT * FROM syscolumns WHERE id = OBJECT_ID( AND name = ALTER TABLE Client ADD Name VARCHAR(64) NULL
CREATE FUNCTION ColumnExists(@TableName varchar(100), @ColumnName varchar(100)) RETURNS varchar(1) AS BEGIN DECLARE @Result varchar(1); IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.Columns WHERE TABLE_NAME = @TableName AND COLUMN_NAME = @ColumnName) BEGIN SET @Result = END ELSE BEGIN SET @Result = END RETURN @Result; END GO GRANT EXECUTE ON [ColumnExists] TO [whoever] GO
IF ColumnExists( BEGIN ALTER TABLE xxx ADD yyyyy varChar(10) NOT NULL END GO
ALTER TABLE Table_name DROP COLUMN IF EXISTS Column_name
declare @myColumn as nvarchar(128) set @myColumn = if not exists ( select 1 from information_schema.columns columns where columns.table_catalog = and columns.table_schema = and columns.table_name = and columns.column_name = @myColumn ) begin exec( + end
IF (OBJECT_ID(N COLUMNPROPERTY( OBJECT_ID(N BEGIN SELECT END
IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = AND column_name = ) BEGIN ... END
SELECT COLUMNS.* FROM INFORMATION_SCHEMA.COLUMNS COLUMNS, INFORMATION_SCHEMA.TABLES TABLES WHERE COLUMNS.TABLE_NAME = TABLES.TABLE_NAME AND Upper(COLUMNS.COLUMN_NAME) = Upper(
if exists ( select * from sysobjects, syscolumns where sysobjects.id = syscolumns.id and sysobjects.name = and syscolumns.name =
if exists (select * from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME= begin print end else begin print end
IF NOT EXISTS( SELECT NULL FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = AND table_schema = AND column_name = ALTER TABLE `TableName` ADD `ColumnName` int(1) NOT NULL default END IF;
select distinct object_name(sc.id) from syscolumns sc,sysobjects so where sc.name like
if (exists(select 1 from tempdb.sys.columns where Name = and Object_ID = object_id( begin ... end
select * from Information_Schema.Columns where Table_Catalog = and Table_Schema = and Table_Name = and Column_Name =
IF COL_LENGTH( BEGIN -- Column Not Exists, implement your logic END ELSE BEGIN -- Column Exists, implement your logic END
IF NOT EXISTS ( SELECT * FROM sys.Columns WHERE Name = N AND Object_Id = Object_Id(N ) BEGIN ALTER TABLE Driver ADD QbId NVARCHAR(20) NULL END ELSE BEGIN PRINT END
IF EXISTS( SELECT NULL FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = AND COLUMN_NAME = )
IF EXISTS (SELECT BEGIN SELECT END ELSE BEGIN ALTER TABLE <YourTableName> ADD <YourColumnName> <DataType>[Size] END
SELECT Count(*) AS existFlag FROM sys.columns WHERE [name] = N
|--Compute Scalar(DEFINE:([Expr1004]=CONVERT(varchar(30),[TEST].[dbo].[DatesTable].[MyDate],101))) |--Table Scan(OBJECT:([TEST].[dbo].[DatesTable]))
|--Compute Scalar(DEFINE:([Expr1004]=dateadd(day,(0),CONVERT_IMPLICIT(datetime,datediff(day, |--Table Scan(OBJECT:([TEST].[dbo].[DatesTable]))
SELECT CONVERT(datetime, CONVERT(varchar, GETDATE(), 101))
CONVERT ( data_type [ ( length ) ] , expression [ , style ] )
SELECT CAST(FLOOR(CAST(GETDATE() AS FLOAT)) AS DATETIME)
SELECT CONVERT(VARCHAR,DATEADD(DAY,-1,GETDATE()),103) --21/09/2011 SELECT CONVERT(VARCHAR,DATEADD(DAY,-1,GETDATE()),101) --09/21/2011 SELECT CONVERT(VARCHAR,DATEADD(DAY,-1,GETDATE()),111) --2011/09/21 SELECT CONVERT(VARCHAR,DATEADD(DAY,-1,GETDATE()),107) --Sep 21, 2011
SELECT DATEADD(DD, DATEDIFF(DD, 0, GETDATE()), 0) SELECT DATEADD(DAY, 0, DATEDIFF(DAY,0, GETDATE())) SELECT CONVERT(DATETIME, CONVERT(VARCHAR(10), GETDATE(), 101))
SELECT CONVERT(DATE, GETDATE()) --2014-03-26 SELECT CONVERT(VARCHAR(10), GETDATE(), 111) --2014/03/26
DECLARE @OnlyDate DATETIME SET @OnlyDate = DATEDIFF(DD, 0, GETDATE()) SELECT @OnlyDate AS OnlyDate
2009-06-15T13:45:30 -> 6/15/2009 (en-US) 2009-06-15T13:45:30 -> 15/06/2009 (fr-FR) 2009-06-15T13:45:30 -> 2009/06/15 (ja-JP)
2009-06-15T13:45:30 -> Monday, June 15, 2009 (en-US) 2009-06-15T13:45:30 -> 15 июня 2009 г. (ru-RU) 2009-06-15T13:45:30 -> Montag, 15. Juni 2009 (de-DE)
DECLARE @d DATETIME = SELECT FORMAT ( @d, ,FORMAT ( @d, ,FORMAT ( @d, ,FORMAT ( @d, SELECT FORMAT ( @d, ,FORMAT ( @d, ,FORMAT ( @d, ,FORMAT ( @d, US English Result Great Britain English Result German Result Simplified Chinese (PRC) Result ---------------- ----------------------------- ------------- ------------------------------------- 10/1/2011 01/10/2011 01.10.2011 2011/10/1 US English Result Great Britain English Result German Result Chinese (Simplified PRC) Result ---------------------------- ----------------------------- ----------------------------- --------------------------------------- Saturday, October 01, 2011 01 October 2011 Samstag, 1. Oktober 2011 2011年10月1日
Convert(nvarchar(10), getdate(), 101) ---> 5/12/14 Convert(nvarchar(12), getdate(), 101) ---> 5/12/2014
DECLARE @Date DATE = GETDATE() SELECT @Date --> 2017-05-03
CONVERT(VARCHAR(10),Person.DateOfBirth,111) AS BirthDate
SELECT CAST(FLOOR(CAST(GETDATE() AS FLOAT)) as DATETIME)
1) Date/time in format MON DD YYYY HH:MI AM (OR PM): Feb 27 2015 1:14PM 2) Date/time in format MM-DD-YY: 02-27-15 3) Date/time in format MM-DD-YYYY: 02-27-2015 4) Date/time in format DD MON YYYY: 27 Feb 2015 5) Date/time in format DD MON YY: 27 Feb 15 6) Date/time in format DD MON YYYY HH:MM:SS:MMM(24H): 27 Feb 2015 13:14:46:630
DECLARE @yourdate DATETIME = SELECT CONVERT(DATE, @yourdate)
DATEFROMPARTS(DATEPART(yyyy, @mydatetime), DATEPART(mm, @mydatetime), DATEPART(dd, @mydatetime))
CAST( ( STR( YEAR( GETDATE() ) ) + STR( MONTH( GETDATE() ) ) + STR( DAY( GETDATE() ) ) ) AS DATETIME)
SELECT CONVERT(DATETIME,CONVERT(DATE,((GETDATE()))))
SELECT CONVERT(date, getdate()) SELECT DATEADD(dd, 0, DATEDIFF(dd, 0, @your_date)) SELECT DATEADD(dd, 0, DATEDIFF(dd, 0, GETDATE()))
INSERT INTO MyTable VALUES ("John", 123, "Lloyds Office"); INSERT INTO MyTable VALUES ("Jane", 124, "Lloyds Office"); INSERT INTO MyTable VALUES ("Billy", 125, "London Office"); INSERT INTO MyTable VALUES ("Miranda", 126, "Bristol Office");
INSERT INTO MyTable ( Column1, Column2 ) VALUES ( Value1, Value2 ), ( Value1, Value2 )
INSERT INTO MyTable ( Column1, Column2, Column3 ) VALUES ( ( ( (
INSERT INTO MyTable (FirstCol, SecondCol) SELECT UNION ALL SELECT UNION ALL SELECT ...
INSERT INTO tbl_name (a,b,c) VALUES(1,2,3),(4,5,6),(7,8,9);
select * into tmpBusLine from exec getBusinessLineHistory
CREATE PROC getBusinessLineHistory AS BEGIN SELECT * FROM sys.databases END GO sp_configure GO RECONFIGURE GO sp_configure GO RECONFIGURE GO SELECT * INTO SELECT * FROM
CREATE TABLE ( COL1 INT, COL2 INT ) INSERT INTO Exec SpGetRecords
--INSERT...EXECUTE procedure example INSERT author_sales EXECUTE get_author_sales
CREATE FUNCTION CustomersByRegion ( @RegionID int ) RETURNS TABLE AS RETURN SELECT * FROM customers WHERE RegionID = @RegionID GO
CREATE PROCEDURE uspCustomersByRegion ( @regionID int ) AS BEGIN SELECT * FROM CustomersbyRegion(@regionID); END GO
EXEC sp_serveroption SELECT * INTO FROM OPENQUERY(YOURSERVERNAME,
declare @temp table ( name varchar(255), field varchar(255), filename varchar(255), filegroup varchar(255), size varchar(255), maxsize varchar(255), growth varchar(255), usage varchar(255) ); INSERT @temp Exec sp_helpfile; select * from @temp;
with temp as ( select * from dbo.fnFunctionName(10, 20) ) select col1, col2 from temp
with temp1020 as ( select id from dbo.fnFunctionName(10, 20) ), temp2030 as ( select id from dbo.fnFunctionName(20, 30) ) select * from temp1020 where id not in (select id from temp2030)
DECLARE @t TABLE ( --these columns were copied from sp_help COL1 INT, COL2 INT ) INSERT INTO @t Exec spMyProc
declare @locCompanyId varchar(8) declare @locDateOne datetime declare @locDateTwo datetime set @locDateOne = set @locDateTwo = getdate() --Build temporary table (based on bogus variable values) --because we just want the table definition and --since openquery does not allow variable definitions... --I am going to use bogus variables to get the table defintion. select * into FROM OPENQUERY(DBASESERVER, set @locCompanyId = insert into EXEC DATABASE.dbo.Proc_MyStoredProc @locCompanyId,@locDateOne,@locDateTwo set @locCompanyId = insert into EXEC DATABASE.dbo.Proc_MyStoredProc @locCompanyId,@locDateOne,@locDateTwo select * from drop table
CREATE PROCEDURE dbo.usp_GetStoredProcTableDefinition( @ProcedureName nvarchar(128), @TableName nvarchar(128), @SQL nvarchar(max) OUTPUT ) AS SET @SQL = SELECT @SQL = @SQL + FROM sys.dm_exec_describe_first_result_set_for_object ( OBJECT_ID(@ProcedureName), NULL ); --Remove trailing comma SET @SQL = SUBSTRING(@SQL,0,LEN(@SQL)) SET @SQL = @SQL +
DECLARE @SQL NVARCHAR(MAX) exec dbo.usp_GetStoredProcTableDefinition @ProcedureName= @TableName= INSERT INTO EXEC [dbo].usp_YourProcedure select * from
CREATE PROCEDURE [dbo].[ExecIntoTable] ( @tableName NVARCHAR(256), @storedProcWithParameters NVARCHAR(MAX) ) AS BEGIN DECLARE @driver VARCHAR(10) DECLARE @connectionString NVARCHAR(600) DECLARE @sql NVARCHAR(MAX) DECLARE @rowsetSql NVARCHAR(MAX) SET @driver = SET @connectionString = CAST(SERVERPROPERTY( COALESCE( SET @rowsetSql = SET @sql = ' SELECT * INTO FROM OPENROWSET( EXEC (@sql) END GO
declare @procname nvarchar(255) = @sql nvarchar(max) set @sql = begin select @sql = @sql + from sys.procedures AS p cross apply sys.dm_exec_describe_first_result_set_for_object(p.object_id, 0) AS r where p.name = @procname set @sql = substring(@sql,1,len(@sql)-1) + execute (@sql) execute( end
SELECT p.name, r.* FROM sys.procedures AS p CROSS APPLY sys.dm_exec_describe_first_result_set_for_object(p.object_id, 0) AS r;
smalldatetime nvarchar(max) uniqueidentifier nvarchar(1000) real smalldatetime decimal(18,2)
CREATE TABLE [dbo].[tblTestingTree]( [Id] [int] IDENTITY(1,1) NOT NULL, [ParentId] [int] NULL, [IsLeft] [bit] NULL, [IsRight] [bit] NULL, CONSTRAINT [PK_tblTestingTree] PRIMARY KEY CLUSTERED ( [Id] ASC ) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] GO SET IDENTITY_INSERT [dbo].[tblTestingTree] ON INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (1, NULL, NULL, NULL) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (2, 1, 1, NULL) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (3, 1, NULL, 1) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (4, 2, 1, NULL) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (5, 2, NULL, 1) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (6, 3, 1, NULL) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (7, 3, NULL, 1) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (8, 4, 1, NULL) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (9, 4, NULL, 1) INSERT [dbo].[tblTestingTree] ([Id], [ParentId], [IsLeft], [IsRight]) VALUES (10, 5, 1, NULL) SET IDENTITY_INSERT [dbo].[tblTestingTree] OFF
create procedure GetDate as begin select Id,ParentId from tblTestingTree end create table tbltemp ( id int, ParentId int ) insert into tbltemp exec GetDate select * from tbltemp;
CREATE TABLE ( col1 INT NOT NULL, col2 NCHAR(50) NOT NULL, col3 TEXT NOT NULL, col4 DATETIME NULL, col5 NCHAR(50) NULL, col6 CHAR(2) NULL, col6 NCHAR(100) NULL, col7 INT NULL, col8 NCHAR(50) NULL, col9 DATETIME NULL, col10 DATETIME NULL ) DECLARE @Para1 int DECLARE @Para2 varchar(32) DECLARE @Para3 varchar(100) DECLARE @Para4 varchar(15) DECLARE @Para5 varchar (12) DECLARE @Para6 varchar(1) DECLARE @Para7 varchar(1) SET @Para1 = 1025 SET @Para2 = N SET @Para3 = N SET @Para4 = N SET @Para5 = N SET @Para6 = N SET @Para7 = N INSERT INTO ( col1, col2, col3, col4, col5, col6, col6, col7, col8, col9, col10, ) EXEC [dbo].[usp_ProcedureName] @Para1, @Para2, @Para3, @Para4, @Para5, @Para6, @Para6
DECLARE @abc TABLE( RequisitionTypeSourceTypeID INT , RequisitionTypeID INT , RequisitionSourcingTypeID INT , AutoDistOverride INT , AllowManagerToWithdrawDistributedReq INT , ResumeRequired INT , WarnSupplierOnDNRReqSubmission INT , MSPApprovalReqd INT , EnableMSPSupplierCounterOffer INT , RequireVendorToAcceptOffer INT , UseCertification INT , UseCompetency INT , RequireRequisitionTemplate INT , CreatedByID INT , CreatedDate DATE , ModifiedByID INT , ModifiedDate DATE , UseCandidateScheduledHours INT , WeekEndingDayOfWeekID INT , AllowAutoEnroll INT ) INSERT INTO @abc EXEC [dbo].[usp_MySp] 726,3 SELECT * FROM @abc
DECLARE @sql varchar(max) = @tmp_global_table varchar(255) = SET @sql = @sql + EXEC(@sql) EXEC(
GO create procedure as begin declare @tableName varchar(max) = (select name from tempdb.sys.tables where object_id = @tableId ); declare @tsql nvarchar(max); declare @tempId nvarchar(max) = newid(); set @tsql = declare @drop nvarchar(max) = (select + from tempdb.sys.columns c where c.object_id = cast(@tableId as varchar(max)) + for xml path( ) alter table tempdb.dbo. exec sp_executeSQL @drop; declare @add nvarchar(max) = ( select + + + case when d.is_nullable=1 then + char(10) from sys.dm_exec_describe_first_result_set_for_object( + cast(@procedureId as varchar(max)) + order by column_ordinal for xml path( execute sp_executeSQL @add; alter table execute sp_executeSQL @tsql; end GO create table declare @tableId int = object_Id( declare @procedureId int = object_id( exec insert into exec examplestoredProcedure
DECLARE @storeProcname NVARCHAR(MAX) = SET @storeProcname = DECLARE @strSQL AS VARCHAR(MAX) = SELECT @strSQL = @strSQL+STUFF(( SELECT FROM sys.dm_exec_describe_first_result_set_for_object (OBJECT_ID(@storeProcname),0) FOR XML PATH( ),1,1, EXEC (@strSQL) INSERT INTO myTableName EXEC ( SELECT * FROM myTableName DROP TABLE myTableName
<join_type> ::= [ { INNER | { { LEFT | RIGHT | FULL } [ OUTER ] } } [ <join_hint> ] ] JOIN
A LEFT JOIN B A LEFT OUTER JOIN B A RIGHT JOIN B A RIGHT OUTER JOIN B A FULL JOIN B A FULL OUTER JOIN B A INNER JOIN B A JOIN B
Table A | Table B Table A | Table B Table A | Table B Table A | Table B 1 | 5 1 | 1 1 | 1 1 | 1 2 | 1 2 | 2 2 | 2 2 | 2 3 | 6 3 | null 3 | null - | - 4 | 2 4 | null 4 | null - | - null | 5 - | - null | 5 null | 6 - | - null | 6 OUTER JOIN (FULL) LEFT OUTER (partial) RIGHT OUTER (partial)
LEFT OUTER JOIN => LEFT JOIN RIGHT OUTER JOIN => RIGHT JOIN FULL OUTER JOIN => FULL JOIN
There are three type of outer join 1) Left Outer Join = Left Join 2) Right Outer Join = Right Join 3) Full Outer Join = Full Join
SELECT CAST( CASE WHEN Obsolete = THEN 1 ELSE 0 END AS bit) as Saleable, * FROM Product
SELECT CASE WHEN Obsolete = THEN 1 ELSE 0 END as Saleable, * FROM Product
SELECT CASE <variable> WHEN <value> THEN <returnvalue> WHEN <othervalue> THEN <returnthis> ELSE <returndefaultcase> END AS <newcolumnname> FROM <table>
SELECT CASE WHEN <test> THEN <returnvalue> WHEN <othertest> THEN <returnthis> ELSE <returndefaultcase> END AS <newcolumnname> FROM <table>
IF @IncludeExtendedInformation = 1 BEGIN SELECT A,B,C,X,Y,Z FROM T END ELSE BEGIN SELECT A,B,C FROM T END
SELECT FirstName, LastName, Salary, DOB, CASE Gender WHEN WHEN END FROM Employees
SELECT (CASE WHEN (Obsolete = ELSE END) as Salable , * FROM Product
SELECT CASE WHEN OBSOLETE = ELSE END AS Salable, * FROM PRODUCT
IF EXISTS(SELECT * FROM Northwind.dbo.Customers WHERE CustomerId = PRINT ELSE PRINT IF EXISTS(SELECT * FROM Northwind.dbo.Customers WHERE CustomerId = PRINT ELSE PRINT
DECLARE @val INT; SET @val = 15; IF @val < 25 PRINT ELSE PRINT GO
DECLARE @val INT; SET @val = 15; IF @val < 25 PRINT ELSE BEGIN IF @val < 50 PRINT ELSE PRINT END; GO
SELECT CASE WHEN (Obsolete = THEN ELSE END as Available etc...
DECLARE @Product TABLE ( id INT PRIMARY KEY IDENTITY NOT NULL ,Obsolote CHAR(1) ,Instock CHAR(1) ) INSERT INTO @Product ([Obsolote], [Instock]) VALUES ( ; WITH cte AS ( SELECT , ,* FROM @Product AS p ) SELECT ,* FROM [cte] c
for true: ISNULL(NULLIF(p.[Instock], for false: ISNULL(NULLIF(p.[Instock],
SELECT 1 AS Saleable, * FROM @Product WHERE ( Obsolete = UNION SELECT 0 AS Saleable, * FROM @Product WHERE NOT ( Obsolete =
SELECT CASE WHEN profile.nrefillno = 0 THEN From profile
case statement some what similar to if in SQL server SELECT CASE WHEN Obsolete = THEN 1 ELSE 0 END as Saleable, * FROM Product
CASE orweb2.dbo.Inventory.RegulatingAgencyName WHEN THEN orweb2.dbo.CountyStateAgContactInfo.ContactState WHEN THEN orweb2.dbo.CountyStateAgContactInfo.ContactState WHEN THEN orweb2.dbo.CountyStateAgContactInfo.ContactState WHEN THEN orweb2.dbo.CountyStateAgContactInfo.ContactAg ELSE ( CASE orweb2.dbo.CountyStateAgContactInfo.IsContract WHEN 1 THEN orweb2.dbo.CountyStateAgContactInfo.ContactCounty ELSE orweb2.dbo.CountyStateAgContactInfo.ContactState END ) END AS [County Contact Name]
INSERT INTO customers (last_name, first_name, city) SELECT WHERE NOT EXISTS (SELECT where last_name = and first_name = and city =
DECLARE @Product TABLE (ID INT, Obsolete VARCHAR(10), InStock VARCHAR(10)) INSERT INTO @Product VALUES (1, (2, (3, (4, SELECT P.* , ISNULL(Stmt.Saleable,0) Saleable FROM @Product P LEFT JOIN ( VALUES ( ) Stmt (Obsolete, InStock, Saleable) ON P.InStock = Stmt.InStock OR P.Obsolete = Stmt.Obsolete
ID Obsolete InStock Saleable ----------- ---------- ---------- ----------- 1 N Y 1 2 A B 0 3 N B 1 4 A Y 1
SELECT CASE WHEN Obsolete = END AS Saleable, * FROM Product
RowID int not null identity(1,1) primary key, Col1 varchar(20) not null, Col2 varchar(2048) not null, Col3 tinyint not null
DELETE FROM MyTable LEFT OUTER JOIN ( SELECT MIN(RowId) as RowId, Col1, Col2, Col3 FROM MyTable GROUP BY Col1, Col2, Col3 ) as KeepRows ON MyTable.RowId = KeepRows.RowId WHERE KeepRows.RowId IS NULL
CONVERT(uniqueidentifier, MIN(CONVERT(char(36), MyGuidColumn)))
; --Ensure that any immediately preceding statement is terminated with a semicolon above WITH cte AS (SELECT ROW_NUMBER() OVER (PARTITION BY Col1, Col2, Col3 ORDER BY ( SELECT 0)) RN FROM DELETE FROM cte WHERE RN > 1;
DELETE dupes FROM MyTable dupes, MyTable fullTable WHERE dupes.dupField = fullTable.dupField AND dupes.secondDupField = fullTable.secondDupField AND dupes.uniqueField > fullTable.uniqueField
DELETE FROM TableName WHERE ID NOT IN (SELECT MAX(ID) FROM TableName GROUP BY Column1, Column2, Column3 /*Even if ID is not null-able SQL Server treats MAX(ID) as potentially nullable. Because of semantics of NOT IN (NULL) including the clause below can simplify the plan*/ HAVING MAX(ID) IS NOT NULL)
SELECT YourColumnName, COUNT(*) TotalCount FROM YourTableName GROUP BY YourColumnName HAVING COUNT(*) > 1 ORDER BY COUNT(*) DESC
delete t1 from table t1, table t2 where t1.columnA = t2.columnA and t1.rowid>t2.rowid
delete from table t1 using table t2 where t1.columnA = t2.columnA and t1.rowid > t2.rowid
DELETE LU FROM (SELECT *, Row_number() OVER ( partition BY col1, col1, col3 ORDER BY rowid DESC) [Row] FROM mytable) LU WHERE [row] > 1
DELETE FROM Mytable WHERE RowID NOT IN ( SELECT MIN(RowID) FROM Mytable GROUP BY Col1, Col2, Col3 )
WITH CTE AS ( SELECT *,ROW_NUMBER() OVER (PARTITION BY col1,col2,col3 ORDER BY col1,col2,col3) AS RN FROM MyTable ) DELETE FROM CTE WHERE RN<>1
WITH CTE AS (SELECT *,R=RANK() OVER (ORDER BY col1,col2,col3) FROM MyTable) DELETE CTE WHERE R IN (SELECT R FROM CTE GROUP BY R HAVING COUNT(*)>1)
select distinct * into t2 from t1; delete from t1; insert into t1 select * from t2; drop table t2;
--DELETE FROM table1 --WHERE id IN ( SELECT MIN(id) FROM table1 GROUP BY col1, col2, col3 -- could add a WHERE clause here to further filter HAVING count(*) > 1 --)
SELECT name, email, COUNT(*) FROM users GROUP BY name, email HAVING COUNT(*) > 1
DELETE users WHERE rowid NOT IN (SELECT MIN(rowid) FROM users GROUP BY name, email);
SELECT DISTINCT * INTO tempdb.dbo.tmpTable FROM myTable TRUNCATE TABLE myTable INSERT INTO myTable SELECT * FROM tempdb.dbo.tmpTable DROP TABLE tempdb.dbo.tmpTable
begin transaction -- create temp table with identical structure as source table Select * Into -- insert distinct values into temp insert into select distinct * from tableName -- delete from source delete from tableName -- insert into source from temp insert into tableName select * from rollback transaction -- if this works, change rollback to commit and execute again to keep you changes!!
;with cte as ( select min(PrimaryKey) as PrimaryKey UniqueColumn1, UniqueColumn2 from dbo.DuplicatesTable group by UniqueColumn1, UniqueColumn1 having count(*) > 1 ) delete d from dbo.DuplicatesTable d inner join cte on d.PrimaryKey > cte.PrimaryKey and d.UniqueColumn1 = cte.UniqueColumn1 and d.UniqueColumn2 = cte.UniqueColumn2;
EMPLOYEE_ID ATTENDANCE_DATE A001 2011-01-01 A001 2011-01-01 A002 2011-01-01 A002 2011-01-01 A002 2011-01-01 A003 2011-01-01
ALTER TABLE dbo.ATTENDANCE ADD AUTOID INT IDENTITY(1,1)
DELETE FROM dbo.ATTENDANCE WHERE AUTOID NOT IN (SELECT MIN(AUTOID) _ FROM dbo.ATTENDANCE GROUP BY EMPLOYEE_ID,ATTENDANCE_DATE)
DELETE tbl FROM MyTable tbl WHERE EXISTS ( SELECT * FROM MyTable tbl2 WHERE tbl2.SameValue = tbl.SameValue AND tbl.IdUniqueValue < tbl2.IdUniqueValue )
DELETE FROM MyTable WHERE NOT RowID IN (SELECT (SELECT TOP 1 RowID FROM MyTable mt2 WHERE mt2.Col1 = mt.Col1 AND mt2.Col2 = mt.Col2 AND mt2.Col3 = mt.Col3) FROM MyTable mt)
DELETE FROM myTable WHERE RowID IN ( SELECT MIN(RowID) AS IDNo FROM myTable GROUP BY Col1, Col2, Col3 HAVING COUNT(*) = 2 )
WITH tblTemp as ( SELECT ROW_NUMBER() Over(PARTITION BY Name,Department ORDER BY Name) As RowNumber,* FROM <table_name> ) DELETE FROM tblTemp where RowNumber >1
DELETE FROM testing WHERE empno not IN (SELECT empno FROM (SELECT empno, ROW_NUMBER() OVER (PARTITION BY empno ORDER BY empno) AS [ItemNumber] FROM testing) a WHERE ItemNumber > 1) or empname not in (select empname from (select empname,row_number() over(PARTITION BY empno ORDER BY empno) AS [ItemNumber] FROM testing) a WHERE ItemNumber > 1)
INSERT INTO tc_category1 SELECT * FROM tc_category GROUP BY category_id, application_id HAVING count(*) > 1
INSERT INTO tc_category1 SELECT * FROM tc_category GROUP BY category_id, application_id HAVING count(*) = 1
DELETE FROM tblemp WHERE id IN ( SELECT MIN(id) FROM tblemp GROUP BY title HAVING COUNT(id)>1 )
SET ROWCOUNT 1 -- or set to number of rows to be deleted delete from myTable where RowId = DuplicatedID SET ROWCOUNT 0
-- given a table stories(story_id int not null primary key, story varchar(max) not null) CREATE TRIGGER prevent_plagiarism ON stories after INSERT, UPDATE AS DECLARE @cnt AS INT SELECT @cnt = Count(*) FROM stories INNER JOIN inserted ON ( stories.story = inserted.story AND stories.story_id != inserted.story_id ) IF @cnt > 0 BEGIN RAISERROR( ROLLBACK TRANSACTION END
DELETE FROM table_name T1 WHERE rowid > ( SELECT min(rowid) FROM table_name T2 WHERE T1.column_name = T2.column_name );
CREATE TABLE car(Id int identity(1,1), PersonId int, CarId int) INSERT INTO car(PersonId,CarId) VALUES(1,2),(1,3),(1,2),(2,4) --SELECT * FROM car ;WITH CTE as( SELECT ROW_NUMBER() over (PARTITION BY personid,carid order by personid,carid) as rn,Id,PersonID,CarId from car) DELETE FROM car where Id in(SELECT Id FROM CTE WHERE rn>1)
with MYCTE as ( SELECT ROW_NUMBER() OVER ( PARTITION BY DuplicateKey1 ,DuplicateKey2 -- optional ORDER BY CreatedAt -- the first row among duplicates will be kept, other rows will be removed ) RN FROM MyTable ) DELETE FROM MYCTE WHERE RN > 1
DELETE FROM MyTable WHERE NOT EXISTS ( SELECT min(RowID) FROM Mytable WHERE (SELECT RowID FROM Mytable GROUP BY Col1, Col2, Col3 )) );
update ud set assid = ( select sale.assid from sale where sale.udid = ud.id ) where exists ( select * from sale where sale.udid = ud.id );
update ud u inner join sale s on u.id = s.udid set u.assid = s.assid
update u set u.assid = s.assid from ud u inner join sale s on u.id = s.udid
update (select u.assid as new_assid, s.assid as old_assid from ud u inner join sale s on u.id = s.udid) up set up.new_assid = up.old_assid
update ud set assid = ( select sale.assid from sale where sale.udid = ud.id ) where RowID in ( select RowID from ud where sale.udid = ud.id );
update ud set assid = sale.assid from sale where sale.udid = id
UPDATE table1 SET COLUMN = value FROM table2, table3 WHERE table1.column_id = table2.id AND table1.column_id = table3.id AND table1.COLUMN = value AND table2.COLUMN = value AND table3.COLUMN = value
UPDATE ud SET assid = (SELECT assid FROM sale s WHERE ud.id=s.id)
UPDATE ud SET assid = s.assid FROM ud u JOIN sale s ON u.id=s.id
CREATE TABLE ud (id integer, assid integer); CREATE TABLE sales (id integer, udid integer, assid integer); UPDATE ud SET assid = sales.assid FROM sales WHERE sales.id = ud.id;
UPDATE first_table ft JOIN second_table st ON st.some_id = ft.some_id JOIN third_table tt ON tt.some_id = st.some_id ..... SET ft.some_column = some_value WHERE ft.some_column = 123456 AND st.some_column = 123456
update ud, sale set ud.assid = sale.assid where sale.udid = ud.id;
UPDATE [LOW_PRIORITY] [IGNORE] table_references SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ... [WHERE where_condition]
MERGE INTO ud --what trable should be updated USING sale -- from what table/relation update info should be taken ON ud.id = sale.udid --join condition WHEN MATCHED THEN UPDATE SET ud.assid = sale.assid; -- how to update
update ud set u.assid = s.assid from ud u inner join sale s on u.id = s.udid
UPDATE users set users.DivisionId=divisions.DivisionId from divisions join users on divisions.Name=users.Division
UPDATE users User INNER JOIN blacklist_users BlacklistUser ON ( User.username = BlacklistUser.account_ref OR User.email = BlacklistedUser.account_ref OR User.phone_number = BlacklistUser.account_ref AND User.is_active = 1 AND BlacklistUser.has_run = 0 ) SET User.is_active = 0, BlacklistUser.has_run = 1;
UPDATE tblAppraisalBasicData SET tblAppraisalBasicData.ISCbo=1 FROM tblAppraisalBasicData SI INNER JOIN aaa_test RAN ON SI.EmpID = RAN.ID
UPDATE ud INNER JOIN sale ON ud.id = sale.udid SET ud.assid = sale.assid;
update Table set column = where RowID = (select t1.RowID from Table t1 join Table2 t2 on t1.JoinField = t2.JoinField where t2.SelectValue =
update ud set ud.assid = sale.assid from ud Inner join sale on ud.id = sale.udid where sale.udid is not null
UPDATE [Table] SET [Column]=0 WHERE [Column] IS NULL
ALTER TABLE [Table] ALTER COLUMN [Column] INTEGER NOT NULL
ALTER TABLE [Table] ADD CONSTRAINT [Constraint] DEFAULT 0 FOR [Column];
UPDATE MyTable SET MyNullableColumn = 0 WHERE MyNullableColumn IS NULL
ALTER TABLE MyTable ALTER COLUMN MyNullableColumn MyNullableColumnDatatype NOT NULL
ALTER TABLE tablename MODIFY columnname datatype NOT NULL;
ALTER TABLE [Table] Alter COLUMN [Column] VARCHAR(50) not null;
UPDATE table set columnName = 0 where columnName is null
ALTER TABLE [Table] ALTER [Column] NUMBER DEFAULT 0 NOT NULL;
ALTER TABLE table_name CHANGE COLUMN column_name column_name VARCHAR(200) NOT NULL DEFAULT
EXEC sp_msforeachtable "ALTER TABLE ? NOCHECK CONSTRAINT all"
RUN UPDATE COMMAND (as mentioned in above comments) RUN ALTER COMMAND (as mentioned in above comments)
alter table [table name] alter column [column name] not null;
ALTER TABLE mytable modify mycolumn datatype NOT NULL;
SELECT t.NAME AS TableName, s.Name AS SchemaName, p.rows AS RowCounts, SUM(a.total_pages) * 8 AS TotalSpaceKB, CAST(ROUND(((SUM(a.total_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS TotalSpaceMB, SUM(a.used_pages) * 8 AS UsedSpaceKB, CAST(ROUND(((SUM(a.used_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS UsedSpaceMB, (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB, CAST(ROUND(((SUM(a.total_pages) - SUM(a.used_pages)) * 8) / 1024.00, 2) AS NUMERIC(36, 2)) AS UnusedSpaceMB FROM sys.tables t INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id LEFT OUTER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE t.NAME NOT LIKE AND t.is_ms_shipped = 0 AND i.OBJECT_ID > 255 GROUP BY t.Name, s.Name, p.Rows ORDER BY t.Name
create table Name varchar(255), [rows] int, reserved varchar(255), data varchar(255), index_size varchar(255), unused varchar(255)) create table Name varchar(255), [rows] int, reservedKb int, dataKb int, reservedIndexSize int, reservedUnused int) EXEC sp_MSforeachtable @command1="insert into EXEC sp_spaceused insert into select name, [rows], SUBSTRING(reserved, 0, LEN(reserved)-2), SUBSTRING(data, 0, LEN(data)-2), SUBSTRING(index_size, 0, LEN(index_size)-2), SUBSTRING(unused, 0, LEN(unused)-2) from select * from order by reservedKb desc drop table drop table
SELECT OBJECT_NAME(i.OBJECT_ID) AS TableName, i.name AS IndexName, i.index_id AS IndexID, 8 * SUM(a.used_pages) AS FROM sys.indexes AS i JOIN sys.partitions AS p ON p.OBJECT_ID = i.OBJECT_ID AND p.index_id = i.index_id JOIN sys.allocation_units AS a ON a.container_id = p.partition_id where [i].[is_primary_key] = 0 -- fix for size discrepancy GROUP BY i.OBJECT_ID, i.index_id, i.name ORDER BY OBJECT_NAME(i.OBJECT_ID), i.index_id
;with cte as ( SELECT t.name as TableName, SUM (s.used_page_count) as used_pages_count, SUM (CASE WHEN (i.index_id < 2) THEN (in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) ELSE lob_used_page_count + row_overflow_used_page_count END) as pages FROM sys.dm_db_partition_stats AS s JOIN sys.tables AS t ON s.object_id = t.object_id JOIN sys.indexes AS i ON i.[object_id] = t.[object_id] AND s.index_id = i.index_id GROUP BY t.name ) select cte.TableName, cast((cte.pages * 8.)/1024 as decimal(10,3)) as TableSizeInMB, cast(((CASE WHEN cte.used_pages_count > cte.pages THEN cte.used_pages_count - cte.pages ELSE 0 END) * 8./1024) as decimal(10,3)) as IndexSizeInMB from cte order by 2 desc
SELECT a2.name AS [tablename], a1.rows as row_count, (a1.reserved + ISNULL(a4.reserved,0))* 8 AS reserved, a1.data * 8 AS data, (CASE WHEN (a1.used + ISNULL(a4.used,0)) > a1.data THEN (a1.used + ISNULL(a4.used,0)) - a1.data ELSE 0 END) * 8 AS index_size, (CASE WHEN (a1.reserved + ISNULL(a4.reserved,0)) > a1.used THEN (a1.reserved + ISNULL(a4.reserved,0)) - a1.used ELSE 0 END) * 8 AS unused FROM (SELECT ps.object_id, SUM ( CASE WHEN (ps.index_id < 2) THEN row_count ELSE 0 END ) AS [rows], SUM (ps.reserved_page_count) AS reserved, SUM ( CASE WHEN (ps.index_id < 2) THEN (ps.in_row_data_page_count + ps.lob_used_page_count + ps.row_overflow_used_page_count) ELSE (ps.lob_used_page_count + ps.row_overflow_used_page_count) END ) AS data, SUM (ps.used_page_count) AS used FROM sys.dm_db_partition_stats ps WHERE ps.object_id NOT IN (SELECT object_id FROM sys.tables WHERE is_memory_optimized = 1) GROUP BY ps.object_id) AS a1 LEFT OUTER JOIN (SELECT it.parent_id, SUM(ps.reserved_page_count) AS reserved, SUM(ps.used_page_count) AS used FROM sys.dm_db_partition_stats ps INNER JOIN sys.internal_tables it ON (it.object_id = ps.object_id) WHERE it.internal_type IN (202,204) GROUP BY it.parent_id) AS a4 ON (a4.parent_id = a1.object_id) INNER JOIN sys.all_objects a2 ON ( a1.object_id = a2.object_id ) INNER JOIN sys.schemas a3 ON (a2.schema_id = a3.schema_id) WHERE a2.type <> N ORDER BY a3.name, a2.name
-- Show the size of all the tables in a database sort by data size descending SET NOCOUNT ON DECLARE @TableInfo TABLE (tablename varchar(255), rowcounts int, reserved varchar(255), DATA varchar(255), index_size varchar(255), unused varchar(255)) DECLARE @cmd1 varchar(500) SET @cmd1 = INSERT INTO @TableInfo (tablename,rowcounts,reserved,DATA,index_size,unused) EXEC sp_msforeachtable @command1=@cmd1 SELECT * FROM @TableInfo ORDER BY Convert(int,Replace(DATA,
SELECT t.NAME AS TableName, s.Name AS SchemaName, p.rows AS RowCounts, SUM(a.total_pages) * 8 AS TotalSpaceKB, SUM(a.used_pages) * 8 AS UsedSpaceKB, (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB FROM sys.tables t INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id LEFT OUTER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE t.NAME NOT LIKE AND t.is_ms_shipped = 0 AND i.OBJECT_ID > 255 GROUP BY t.Name, s.Name, p.Rows ORDER BY --p.rows DESC --Uncomment to order by amount rows instead of size in KB. SUM(a.total_pages) DESC
SELECT a2.name AS TableName, a1.rows as [RowCount], --(a1.reserved + ISNULL(a4.reserved,0)) * 8 AS ReservedSize_KB, --a1.data * 8 AS DataSize_KB, --(CASE WHEN (a1.used + ISNULL(a4.used,0)) > a1.data THEN (a1.used + ISNULL(a4.used,0)) - a1.data ELSE 0 END) * 8 AS IndexSize_KB, --(CASE WHEN (a1.reserved + ISNULL(a4.reserved,0)) > a1.used THEN (a1.reserved + ISNULL(a4.reserved,0)) - a1.used ELSE 0 END) * 8 AS UnusedSize_KB, CAST(ROUND(((a1.reserved + ISNULL(a4.reserved,0)) * 8) / 1024.00, 2) AS NUMERIC(36, 2)) AS ReservedSize_MB, CAST(ROUND(a1.data * 8 / 1024.00, 2) AS NUMERIC(36, 2)) AS DataSize_MB, CAST(ROUND((CASE WHEN (a1.used + ISNULL(a4.used,0)) > a1.data THEN (a1.used + ISNULL(a4.used,0)) - a1.data ELSE 0 END) * 8 / 1024.00, 2) AS NUMERIC(36, 2)) AS IndexSize_MB, CAST(ROUND((CASE WHEN (a1.reserved + ISNULL(a4.reserved,0)) > a1.used THEN (a1.reserved + ISNULL(a4.reserved,0)) - a1.used ELSE 0 END) * 8 / 1024.00, 2) AS NUMERIC(36, 2)) AS UnusedSize_MB, -- CAST(ROUND(((a1.reserved + ISNULL(a4.reserved,0)) * 8) / 1024.00 / 1024.00, 2) AS NUMERIC(36, 2)) AS ReservedSize_GB, CAST(ROUND(a1.data * 8 / 1024.00 / 1024.00, 2) AS NUMERIC(36, 2)) AS DataSize_GB, CAST(ROUND((CASE WHEN (a1.used + ISNULL(a4.used,0)) > a1.data THEN (a1.used + ISNULL(a4.used,0)) - a1.data ELSE 0 END) * 8 / 1024.00 / 1024.00, 2) AS NUMERIC(36, 2)) AS IndexSize_GB, CAST(ROUND((CASE WHEN (a1.reserved + ISNULL(a4.reserved,0)) > a1.used THEN (a1.reserved + ISNULL(a4.reserved,0)) - a1.used ELSE 0 END) * 8 / 1024.00 / 1024.00, 2) AS NUMERIC(36, 2)) AS UnusedSize_GB FROM (SELECT ps.object_id, SUM (CASE WHEN (ps.index_id < 2) THEN row_count ELSE 0 END) AS [rows], SUM (ps.reserved_page_count) AS reserved, SUM (CASE WHEN (ps.index_id < 2) THEN (ps.in_row_data_page_count + ps.lob_used_page_count + ps.row_overflow_used_page_count) ELSE (ps.lob_used_page_count + ps.row_overflow_used_page_count) END ) AS data, SUM (ps.used_page_count) AS used FROM sys.dm_db_partition_stats ps --===Remove the following comment for SQL Server 2014+ --WHERE ps.object_id NOT IN (SELECT object_id FROM sys.tables WHERE is_memory_optimized = 1) GROUP BY ps.object_id) AS a1 LEFT OUTER JOIN (SELECT it.parent_id, SUM(ps.reserved_page_count) AS reserved, SUM(ps.used_page_count) AS used FROM sys.dm_db_partition_stats ps INNER JOIN sys.internal_tables it ON (it.object_id = ps.object_id) WHERE it.internal_type IN (202,204) GROUP BY it.parent_id) AS a4 ON (a4.parent_id = a1.object_id) INNER JOIN sys.all_objects a2 ON ( a1.object_id = a2.object_id ) INNER JOIN sys.schemas a3 ON (a2.schema_id = a3.schema_id) WHERE a2.type <> N --AND a2.name = --ORDER BY a3.name, a2.name ORDER BY ReservedSize_MB DESC
set ANSI_NULLS ON set QUOTED_IDENTIFIER ON GO -- Get a list of tables and their sizes on disk ALTER PROCEDURE [dbo].[sp_Table_Sizes] AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; DECLARE @table_name VARCHAR(500) DECLARE @schema_name VARCHAR(500) DECLARE @tab1 TABLE( tablename VARCHAR (500) collate database_default ,schemaname VARCHAR(500) collate database_default ) CREATE TABLE tablename sysname ,row_count INT ,reserved VARCHAR(50) collate database_default ,data VARCHAR(50) collate database_default ,index_size VARCHAR(50) collate database_default ,unused VARCHAR(50) collate database_default ) INSERT INTO @tab1 SELECT Table_Name, Table_Schema FROM information_schema.tables WHERE TABLE_TYPE = DECLARE c1 CURSOR FOR SELECT Table_Schema + FROM information_schema.tables t1 WHERE TABLE_TYPE = OPEN c1 FETCH NEXT FROM c1 INTO @table_name WHILE @@FETCH_STATUS = 0 BEGIN SET @table_name = REPLACE(@table_name, SET @table_name = REPLACE(@table_name, -- make sure the object exists before calling sp_spacedused IF EXISTS(SELECT id FROM sysobjects WHERE id = OBJECT_ID(@table_name)) BEGIN INSERT INTO END FETCH NEXT FROM c1 INTO @table_name END CLOSE c1 DEALLOCATE c1 SELECT t1.* ,t2.schemaname FROM INNER JOIN @tab1 t2 ON (t1.tablename = t2.tablename ) ORDER BY schemaname,t1.tablename; DROP TABLE END
with fs as ( select i.object_id, p.rows AS RowCounts, SUM(a.total_pages) * 8 AS TotalSpaceKb from sys.indexes i INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id WHERE i.OBJECT_ID > 255 GROUP BY i.object_id, p.rows ) SELECT t.NAME AS TableName, fs.RowCounts, fs.TotalSpaceKb, t.create_date, t.modify_date, ( select COUNT(1) from sys.columns c where c.object_id = t.object_id ) TotalColumns FROM sys.tables t INNER JOIN fs ON t.OBJECT_ID = fs.object_id WHERE t.NAME NOT LIKE AND t.is_ms_shipped = 0 ORDER BY t.Name
OSQL -E -d <*databasename*> -Q "exec sp_msforeachtable
exec sp_spaceused table1 exec sp_spaceused table2 exec sp_spaceused table3 exec sp_spaceused table4 exec sp_spaceused table5
CREATE PROCEDURE [dbo].[usp_getAllDBTableSizes] AS BEGIN SET NOCOUNT OFF CREATE TABLE CREATE TABLE DECLARE @SQL nvarchar(4000) SET @SQL= INSERT INTO EXECUTE sp_msforeachdb @Command1=@SQL DECLARE AllDatabaseTables CURSOR LOCAL READ_ONLY FOR SELECT TableName FROM DECLARE AllDatabaseNames CURSOR LOCAL READ_ONLY FOR SELECT DBName FROM DECLARE @DBName sysname OPEN AllDatabaseNames DECLARE @TName sysname OPEN AllDatabaseTables WHILE 1=1 BEGIN FETCH NEXT FROM AllDatabaseNames INTO @DBName FETCH NEXT FROM AllDatabaseTables INTO @TName IF @@FETCH_STATUS<>0 BREAK INSERT INTO EXEC ( END --http: INSERT INTO rsp_DatabaseTableSizes (DatabaseName, name, [rows], data) SELECT [dbname], name, [rows], data FROM INNER JOIN ON GROUP BY [dbname] , name, [rows], data ORDER BY [dbname] --To be honest, I have no idea what exact duplicates we are dropping -- but in my case a near enough approach has been good enough. DELETE FROM [rsp_DatabaseTableSizes] WHERE name IN ( SELECT name FROM [rsp_DatabaseTableSizes] GROUP BY name HAVING COUNT(*) > 1 ) DROP TABLE DROP TABLE CLOSE AllDatabaseTables DEALLOCATE AllDatabaseTables CLOSE AllDatabaseNames DEALLOCATE AllDatabaseNames END --EXEC [dbo].[usp_getAllDBTableSizes]
CREATE TABLE [dbo].[rsp_DatabaseSizes]( [DatabaseName] [varchar](1000) NULL, [dbSize] [decimal](15, 2) NULL, [DateUpdated] [smalldatetime] NULL ) ON [PRIMARY] GO
SELECT * FROM ( SELECT t.NAME AS TableName, s.Name AS SchemaName, p.rows AS RowCounts, COUNT(DISTINCT c.COLUMN_NAME) as ColumnCount, SUM(a.total_pages) * 8 AS TotalSpaceKB, (SUM(a.used_pages) * 8) AS UsedSpaceKB, (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB FROM sys.tables t INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON t.NAME = c.TABLE_NAME LEFT OUTER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE t.NAME NOT LIKE AND t.is_ms_shipped = 0 AND i.OBJECT_ID > 255 GROUP BY t.Name, s.Name, p.Rows ) AS Result WHERE RowCounts > 1000 AND ColumnCount > 10 ORDER BY UsedSpaceKB DESC
SET NOCOUNT ON DECLARE @TableInfo TABLE (tablename varchar(255), rowcounts int, reserved varchar(255), DATA varchar(255), index_size varchar(255), unused varchar(255)) DECLARE @cmd1 varchar(500) SET @cmd1 = INSERT INTO @TableInfo (tablename,rowcounts,reserved,DATA,index_size,unused) EXEC sp_msforeachtable @command1=@cmd1 SELECT * FROM @TableInfo ORDER BY Convert(int,Replace(DATA,
SELECT c.name AS ,t.name AS FROM sys.columns c JOIN sys.tables t ON c.object_id = t.object_id WHERE c.name LIKE ORDER BY TableName ,ColumnName;
SELECT COLUMN_NAME AS ,TABLE_NAME AS FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE ORDER BY TableName ,ColumnName;
select * from INFORMATION_SCHEMA.COLUMNS where COLUMN_NAME like order by TABLE_NAME
SQL Server: SELECT Table_Name, Column_Name FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_CATALOG = AND COLUMN_NAME LIKE Oracle: SELECT owner, table_name, column_name FROM all_tab_columns WHERE column_name like AND OWNER in (
SELECT name FROM sysobjects WHERE id IN ( SELECT id FROM syscolumns WHERE name like
select s.[name] t.[name] c.[name] d.[name] d.[max_length] d.[precision] c.[is_identity] c.[is_nullable] c.[is_computed] d.[is_user_defined] t.[modify_date] t.[create_date] from sys.schemas s inner join sys.tables t on s.schema_id = t.schema_id inner join sys.columns c on t.object_id = c.object_id inner join sys.types d on c.user_type_id = d.user_type_id where c.name like
Select * from INFORMATION_SCHEMA.COLUMNS where COLUMN_NAME LIKE
select object_name(object_id) from sys.columns where name like
select OBJECT_SCHEMA_NAME(object_id),object_name(object_id) from sys.columns where name like
select concat(OBJECT_SCHEMA_NAME(object_id), where name like
CREATE PROCEDURE usp_tablecheck --Scan through all tables to identify all tables with columns that have the provided string --Stephen B @name nvarchar(200) AS SELECT CONCAT(OBJECT_SCHEMA_NAME(object_id), WHERE name LIKE CONCAT( ORDER BY [Table Name] ASC, [Column] ASC GO
CREATE PROCEDURE [dbo].[usp_tablecheck] --Scan through all tables to identify all tables in the specified database with columns that have the provided string --Stephen B @name nvarchar(200) ,@db nvarchar(200) = AS DECLARE @sql nvarchar(4000) = CONCAT(' SELECT concat(OBJECT_SCHEMA_NAME(col.object_id,DB_ID( ,col.name AS [Column] FROM LEFT JOIN ON ob.object_id = col.object_id WHERE col.name LIKE CONCAT( AND ob.type = ORDER BY [Table Name] ASC ,[Column] ASC EXECUTE (@sql) GO
USE AdventureWorks GO SELECT t.name AS table_name, SCHEMA_NAME(schema_id) AS schema_name, c.name AS column_name FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID WHERE c.name LIKE ORDER BY schema_name, table_name;
Select DISTINCT TABLE_NAME as TableName,COLUMN_NAME as ColumnName From INFORMATION_SCHEMA.COLUMNS Where column_name like
SELECT COLUMN_NAME, TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE
SELECT [TABLE_NAME] , [INFORMATION_SCHEMA].COLUMNS.COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE INFORMATION_SCHEMA.COLUMNS.COLUMN_NAME LIKE
SELECT distinct(TABLE_NAME) FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE
SELECT COLUMN_NAME, TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE
USE YourDatabseName GO SELECT t.name AS table_name, SCHEMA_NAME(schema_id) AS schema_name, c.name AS column_name FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID WHERE c.name LIKE ORDER BY schema_name, table_name;
DECLARE @columnName as varchar(100) SET @columnName = SELECT t.name AS Table, c.name AS Column, ty.name AS Type, c.max_length AS Length FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID INNER JOIN sys.types ty ON c.system_type_id = ty.system_type_id WHERE c.name LIKE @columnName ORDER BY t.name, c.name
select * from INFORMATION_SCHEMA.COLUMNS where TABLE_CATALOG= and COLUMN_NAME like
SELECT FROM sys.columns c, c.name as ColName, t.name as TableName JOIN sys.tables t ON c.object_id = t.object_id WHERE c.name LIKE
SELECT FROM sys.columns c, c.name as ColName, t.name as TableName JOIN sys.tables t ON c.object_id = t.object_id WHERE c.name LIKE
SELECT t.name AS table_name, SCHEMA_NAME(schema_id) AS schema_name, c.name AS column_name FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID WHERE c.name LIKE ORDER BY schema_name, table_name;
select table_name, column_name from user_tab_columns where column_name like
select owner, table_name, column_name from all_tab_columns where column_name like
DECLARE @COLUMNNAME AS VARCHAR(100); SET @COLUMNNAME = SELECT CASE WHEN [T].[NAME] IS NULL THEN WHEN [T].[NAME] = THEN ELSE END AS [TYPE], WHEN [T].[NAME] IS NULL THEN [V].[NAME] WHEN [T].[NAME] = THEN [V].[NAME] ELSE [T].[NAME] END + FROM [SYS].[SCHEMAS] AS [S] LEFT JOIN [SYS].[TABLES] AS [T] ON [S].SCHEMA_ID = [T].SCHEMA_ID LEFT JOIN [SYS].[VIEWS] AS [V] ON [S].SCHEMA_ID = [V].SCHEMA_ID INNER JOIN [SYS].[COLUMNS] AS [C] ON [T].OBJECT_ID = [C].OBJECT_ID OR [V].OBJECT_ID = [C].OBJECT_ID INNER JOIN [SYS].[TYPES] AS [TY] ON [C].[SYSTEM_TYPE_ID] = [TY].[SYSTEM_TYPE_ID] WHERE [C].[NAME] LIKE @COLUMNNAME GROUP BY WHEN [T].[NAME] IS NULL THEN [V].[NAME] WHEN [T].[NAME] = THEN [V].[NAME] ELSE [T].[NAME] END + ORDER BY WHEN [T].[NAME] IS NULL THEN [V].[NAME] WHEN [T].[NAME] = THEN [V].[NAME] ELSE [T].[NAME] END + WHEN [T].[NAME] IS NULL THEN WHEN [T].[NAME] = THEN ELSE END, [T].[NAME], [C].[NAME];
Select * From [INFORMATION_SCHEMA].[COLUMNS] Where COLUMN_NAME like
USE AdventureWorks GO SELECT t.name AS table_name, SCHEMA_NAME(schema_id) AS schema_name, c.name AS column_name FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID WHERE c.name LIKE
select table_name, column_name from user_tab_columns where column_name like
Create table DBaseName varchar(100), TableSchema varchar(50), TableName varchar(100), ColumnName varchar(100), DataType varchar(100), CharMaxLength varchar(100)) EXEC sp_MSForEachDB @command1= INSERT INTO Table_Catalog ,Table_Schema ,Table_Name ,Column_Name ,Data_Type ,Character_Maximum_Length FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME like select * from Drop table
SELECT col.Name AS ColumnName, tab.Name AS TableName FROM sys.columns col JOIN sys.tables tab ON col.Object_id = tab.Object_id WHERE col.Name LIKE
select t.table_name, c.column_name from systab as t key join systabcol as c where c.column_name =
SELECT C.NAME Column_Name, T.NAME Table_Name FROM SYS.COLUMNS C INNER JOIN SYS.TABLES T ON C.OBJECT_ID = T.OBJECT_ID WHERE C.NAME LIKE
declare @ColumnName nvarchar(max)= Select b.Name as TableName from Sys.Columns a Join Sys.Tables b on a.Object_Id=b.Object_Id where a.Name=@ColumnName
IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE= AND TABLE_NAME= SELECT 1 AS res ELSE SELECT 0 AS res;
IF OBJECT_ID (N SELECT 1 AS res ELSE SELECT 0 AS res;
IF (EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = AND TABLE_NAME = BEGIN --Do Stuff END
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = N BEGIN PRINT END
IF EXISTS(SELECT 1 FROM sys.Objects WHERE Object_id = OBJECT_ID(N BEGIN PRINT END
IF EXISTS(SELECT 1 FROM sys.Tables WHERE Name = N BEGIN PRINT END
IF EXISTS(SELECT name FROM sys.sysobjects WHERE Name = N BEGIN PRINT END
if exists (select * from MyOtherDatabase.sys.tables where name = print
IF EXISTS (SELECT 1 FROM [database].INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE= AND TABLE_NAME= SELECT 1 AS res ELSE SELECT 0 AS res;
IF OBJECT_ID (N SELECT 1 AS res ELSE SELECT 0 AS res;
IF OBJECT_ID (N SELECT 1 AS res ELSE SELECT 0 AS res;
IF EXISTS ( SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N AND type in (N ) BEGIN -- Do whatever you need to here. END
DECLARE @Catalog VARCHAR(255) SET @Catalog = DECLARE @Schema VARCHAR(255) SET @Schema = DECLARE @Table VARCHAR(255) SET @Table = IF (EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_CATALOG = @Catalog AND TABLE_SCHEMA = @Schema AND TABLE_NAME = @Table)) BEGIN --do stuff END
create procedure Table_Exists @tbl varchar(50) as return (select count(*) from sysobjects where type = go
the_name object_id the_schema the_table the_type [Facts].[FactBackOrder] 758293761 Facts FactBackOrder Table
PRINT --select db_name() PRINT PRINT GO SET NOCOUNT ON GO --=================================================================================== -- @TableName is the parameter -- the object we want to deal with (it might be an indexed view or a table) -- the schema might or might not be specified -- when not specified it is DBO --=================================================================================== DECLARE @TableName SYSNAME SELECT @TableName = --=================================================================================== --=================================================================================== DECLARE @Schema SYSNAME DECLARE @I INT DECLARE @Z INT SELECT @TableName = LTRIM(RTRIM(@TableName)) SELECT @Z = LEN(@TableName) IF (@Z = 0) BEGIN RAISERROR( END SELECT @I = CHARINDEX( --SELECT @TableName ,@I IF @I > 0 BEGIN --=================================================================================== -- a schema and table name have been passed -- example Facts.FactBackOrder -- @Schema = Fact -- @TableName = FactBackOrder --=================================================================================== SELECT @Schema = SUBSTRING(@TABLENAME,1,@I-1) SELECT @TableName = SUBSTRING(@TABLENAME,@I+1,@Z-@I) END ELSE BEGIN --=================================================================================== -- just a table name have been passed -- so the schema will be dbo -- example Orders -- @Schema = dbo -- @TableName = Orders --=================================================================================== SELECT @Schema = END --=================================================================================== -- Check whether the @SchemaName is valid in the current database --=================================================================================== IF NOT EXISTS ( SELECT * FROM INFORMATION_SCHEMA.SCHEMATA K WHERE K.[SCHEMA_NAME] = @Schema ) BEGIN RAISERROR( END --SELECT @Schema as [@Schema] -- ,@TableName as [@TableName] DECLARE @R1 TABLE ( THE_NAME SYSNAME ,THE_SCHEMA SYSNAME ,THE_TABLE SYSNAME ,OBJECT_ID INT ,THE_TYPE SYSNAME ,PRIMARY KEY CLUSTERED (THE_SCHEMA,THE_NAME) ) ;WITH RADHE_01 AS ( SELECT QUOTENAME(SCHEMA_NAME(O.schema_id)) + ,the_schema=SCHEMA_NAME(O.schema_id) ,the_table=O.NAME ,object_id =o.object_id ,[the_type]= CASE WHEN O.TYPE = from sys.objects O where O.is_ms_shipped = 0 AND O.TYPE IN ( ) INSERT INTO @R1 ( THE_NAME ,THE_SCHEMA ,THE_TABLE ,OBJECT_ID ,THE_TYPE ) SELECT the_name ,the_schema ,the_table ,object_id ,the_type FROM RADHE_01 WHERE the_schema = @Schema AND the_table = @TableName IF (@@ROWCOUNT = 0) BEGIN RAISERROR( END ELSE BEGIN SELECT THE_NAME ,THE_SCHEMA ,THE_TABLE ,OBJECT_ID ,THE_TYPE FROM @R1 END
IF EXISTS(SELECT 1 FROM sysobjects WHERE type = BEGIN SELECT 1 AS END
IF EXISTS ( SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = AND TABLE_NAME = )
IF OBJECT_ID (N BEGIN print drop table t END else begin print end Create table t (id int identity(1,1) not null, name varchar(30) not null, lastname varchar(25) null) insert into t( name, lastname) values( insert into t( name, lastname) values( Select * from t 1 john doe 2 rose NULL -- clean drop table t
$sql = "SELECT 1 FROM `db_name`.`table_name` LIMIT 1;"; $result = mysql_query($sql); if( $result == false ) echo "table DOES NOT EXIST"; else echo "table exists";
IF EXISTS ( SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N BEGIN SELECT * FROM dbo.TableName; END GO
let oSchema = sys.Schemas.FirstOrDefault(s=>s.Name==a.schema ) where oSchema !=null let o=oSchema!=null?sys.Objects.FirstOrDefault (o => o.Name==a.item && o.Schema_id==oSchema.Schema_id):null where o!=null
if exists (select * from REMOTE_SERVER.MyOtherDatabase.sys.tables where name = print
DELIMITER $$ DROP PROCEDURE IF EXISTS `checkIfTableExists`; CREATE PROCEDURE checkIfTableExists( IN databaseName CHAR(255), IN tableName CHAR(255), OUT boolExistsOrNot CHAR(40) ) BEGIN SELECT count(*) INTO boolExistsOrNot FROM information_schema.TABLES WHERE (TABLE_SCHEMA = databaseName) AND (TABLE_NAME = tableName); END $$ DELIMITER ;
USE AdventureWorks2008R2; GO DECLARE @MyTableVar table( NewScrapReasonID smallint, Name varchar(50), ModifiedDate datetime); INSERT Production.ScrapReason OUTPUT INSERTED.ScrapReasonID, INSERTED.Name, INSERTED.ModifiedDate INTO @MyTableVar VALUES (N --Display the result set of the table variable. SELECT NewScrapReasonID, Name, ModifiedDate FROM @MyTableVar; --Display the result set of the table. SELECT ScrapReasonID, Name, ModifiedDate FROM Production.ScrapReason; GO
create table TableWithIdentity ( IdentityColumnName int identity(1, 1) not null primary key, ... ) -- type of this table -- identity column of the table you declare @IdentityOutput table ( ID int ) insert TableWithIdentity ( ... ) output inserted.IdentityColumnName into @IdentityOutput values ( ... ) select @IdentityValue = (select ID from @IdentityOutput)
DECLARE @generated_keys table([Id] uniqueidentifier) INSERT INTO TurboEncabulators(StatorSlots) OUTPUT inserted.TurboEncabulatorID INTO @generated_keys VALUES( SELECT t.[TurboEncabulatorID ] FROM @generated_keys AS g JOIN dbo.TurboEncabulators AS t ON g.Id = t.TurboEncabulatorID WHERE @@ROWCOUNT > 0
INSERT INTO MyTable OUTPUT INSERTED.ID VALUES (...)
INSERT INTO MyTable OUTPUT INSERTED.ID VALUES (...), (...), (...)
create table Company ( companyId int identity(1,1) , companyName varchar(100) , zipcode varchar(10) , constraint PK_Company primary key (companyId) ) GO create table Person ( personId int identity(1,1) , personName varchar(100) , companyId int , constraint FK_Person_CompanyId foreign key (companyId) references dbo.Company(companyId) , constraint PK_Person primary key (personId) ) GO insert Company select select select insert Person select select select select select select select select select select * from Person p cross apply ( select * from Company c where p.companyid = c.companyId ) Czip select * from Person p inner join Company c on p.companyid = c.companyId
SELECT t1.*, t2o.* FROM t1 CROSS APPLY ( SELECT TOP 3 * FROM t2 WHERE t2.t1_id = t1.id ORDER BY t2.rank DESC ) t2o
WITH t2o AS ( SELECT t2.*, ROW_NUMBER() OVER (PARTITION BY t1_id ORDER BY rank) AS rn FROM t2 ) SELECT t1.*, t2o.* FROM t1 INNER JOIN t2o ON t2o.t1_id = t1.id AND t2o.rn <= 3
WITH q AS ( SELECT *, ROW_NUMBER() OVER (ORDER BY id) AS rn FROM master ), t AS ( SELECT 1 AS id UNION ALL SELECT 2 ) SELECT * FROM t JOIN q ON q.rn <= t.id
WITH t AS ( SELECT 1 AS id UNION ALL SELECT 2 ) SELECT * FROM t CROSS APPLY ( SELECT TOP (t.id) m.* FROM master m ORDER BY id ) q
select F.* from sys.objects O inner join dbo.myTableFun(O.name) F on F.schema_id= O.schema_id
select F.* from sys.objects O cross apply ( select * from dbo.myTableFun(O.name) ) F where F.schema_id= O.schema_id
select F.* from sys.objects O cross apply dbo.myTableFun(O.name) F where F.schema_id= O.schema_id
x------x--------------------x | Id | Name | x------x--------------------x | 1 | A | | 2 | B | | 3 | C | x------x--------------------x
x------x--------------------x-------x | Id | PERIOD | QTY | x------x--------------------x-------x | 1 | 2014-01-13 | 10 | | 1 | 2014-01-11 | 15 | | 1 | 2014-01-12 | 20 | | 2 | 2014-01-06 | 30 | | 2 | 2014-01-08 | 40 | x------x--------------------x-------x
SELECT M.ID,M.NAME,D.PERIOD,D.QTY FROM MASTER M INNER JOIN ( SELECT TOP 2 ID, PERIOD,QTY FROM DETAILS D ORDER BY CAST(PERIOD AS DATE)DESC )D ON M.ID=D.ID
x------x---------x--------------x-------x | Id | Name | PERIOD | QTY | x------x---------x--------------x-------x | 1 | A | 2014-01-13 | 10 | | 1 | A | 2014-01-12 | 20 | x------x---------x--------------x-------x
SELECT M.ID,M.NAME,D.PERIOD,D.QTY FROM MASTER M CROSS APPLY ( SELECT TOP 2 ID, PERIOD,QTY FROM DETAILS D WHERE M.ID=D.ID ORDER BY CAST(PERIOD AS DATE)DESC )D
x------x---------x--------------x-------x | Id | Name | PERIOD | QTY | x------x---------x--------------x-------x | 1 | A | 2014-01-13 | 10 | | 1 | A | 2014-01-12 | 20 | | 2 | B | 2014-01-08 | 40 | | 2 | B | 2014-01-06 | 30 | x------x---------x--------------x-------x
SELECT M.ID,M.NAME,C.PERIOD,C.QTY FROM MASTER M CROSS APPLY dbo.FnGetQty(M.ID) C
CREATE FUNCTION FnGetQty ( @Id INT ) RETURNS TABLE AS RETURN ( SELECT ID,PERIOD,QTY FROM DETAILS WHERE ID=@Id )
x------x---------x--------------x-------x | Id | Name | PERIOD | QTY | x------x---------x--------------x-------x | 1 | A | 2014-01-13 | 10 | | 1 | A | 2014-01-11 | 15 | | 1 | A | 2014-01-12 | 20 | | 2 | B | 2014-01-06 | 30 | | 2 | B | 2014-01-08 | 40 | x------x---------x--------------x-------x
x------x-------------x--------------x | Id | FROMDATE | TODATE | x------x-------------x--------------x | 1 | 2014-01-11 | 2014-01-13 | | 1 | 2014-02-23 | 2014-02-27 | | 2 | 2014-05-06 | 2014-05-30 | | 3 | NULL | NULL | x------x-------------x--------------x
SELECT DISTINCT ID,DATES FROM MYTABLE CROSS APPLY(VALUES (FROMDATE),(TODATE)) COLUMNNAMES(DATES)
x------x-------------x | Id | DATES | x------x-------------x | 1 | 2014-01-11 | | 1 | 2014-01-13 | | 1 | 2014-02-23 | | 1 | 2014-02-27 | | 2 | 2014-05-06 | | 2 | 2014-05-30 | | 3 | NULL | x------x-------------x
<root> <subnode1> <some_node value="1" /> <some_node value="2" /> <some_node value="3" /> <some_node value="4" /> </subnode1> </root>
SELECT id as [xt_id] ,xmlfield.value( ,node_attribute_value = [some_node].value( ,lt.lt_name FROM dbo.table_with_xml xt CROSS APPLY xmlfield.nodes( LEFT OUTER JOIN dbo.lookup_table lt ON [some_node].value(
xt_id root_attribute_value node_attribute_value lt_name ---------------------------------------------------------------------- 1 test1 1 Benefits 1 test1 4 FINRPTCOMPANY
select * from person p where p.companyId in(select c.companyId from company c where c.companyname like
select P.*,T.CompanyName from Person p cross apply ( select * from Company C where p.companyid = c.companyId and c.CompanyName like ) T
CREATE FUNCTION dbo.fn_GetAllEmployeeOfADepartment(@DeptID AS INT) RETURNS TABLE AS RETURN ( SELECT * FROM Employee E WHERE E.DepartmentID = @DeptID ) GO SELECT * FROM Department D CROSS APPLY dbo.fn_GetAllEmployeeOfADepartment(D.DepartmentID)
Create PROCEDURE [dbo].[Message_FindHighestMatches] -- Declare the Topical Neighborhood @TopicalNeighborhood nchar(255)
-- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON Create table ( MessageID int, Subjects nchar(255), SubjectsCount int ) Insert into Select Top 20 MessageID, Subjects, SubjectsCount, (t.cnt * 100)/t3.inputvalues as MatchPercentage From cross apply (select count(*) as cnt from dbo.Split(Subjects, join dbo.Split(@TopicalNeighborhood, on t1.value = t2.value) as t cross apply (select count(*) as inputValues from dbo.Split(@TopicalNeighborhood, Order By MatchPercentage desc drop table
SELECT * FROM Customer CROSS APPLY ( SELECT TOP 1 * FROM Order WHERE Order.CustomerId = Customer.CustomerId ORDER BY OrderDate DESC ) T
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE=
SELECT TABLE_NAME FROM <DATABASE_NAME>.INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE =
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = AND TABLE_CATALOG=
SELECT sobjects.name FROM sysobjects sobjects WHERE sobjects.xtype =
SELECT * FROM information_schema.tables where TABLE_TYPE =
SELECT name FROM sysobjects WHERE xtype= ORDER BY name;
SELECT sobjects.name FROM sysobjects sobjects WHERE sobjects.xtype =
select * from sys.objects where type = and is_ms_shipped = 0 -- Exclude system tables
SELECT [TABLE_CATALOG] + FROM MyDatabase.INFORMATION_SCHEMA.Tables WHERE [TABLE_TYPE] = ORDER BY [TABLE_SCHEMA], [TABLE_NAME]
SELECT SYSSCHEMA.NAME, SYSTABLE.NAME FROM SYS.tables SYSTABLE INNER JOIN SYS.SCHEMAS SYSSCHEMA ON SYSTABLE.SCHEMA_ID = SYSSCHEMA.SCHEMA_ID
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE= ORDER BY TABLE_NAME
select * from dbo.sysobjects o join sys.all_objects syso on o.id = syso.object_id where OBJECTPROPERTY(o.id, and o.category & 2 = 0
--for oracle select tablespace_name, table_name from all_tables;
-- disable all constraints EXEC sp_MSforeachtable "ALTER TABLE ? NOCHECK CONSTRAINT all"
-- enable all constraints exec sp_MSforeachtable @command1="print
-- Disable all table constraints ALTER TABLE MyTable NOCHECK CONSTRAINT ALL -- Enable all table constraints ALTER TABLE MyTable WITH CHECK CHECK CONSTRAINT ALL -- Disable single constraint ALTER TABLE MyTable NOCHECK CONSTRAINT MyConstraint -- Enable single constraint ALTER TABLE MyTable WITH CHECK CHECK CONSTRAINT MyConstraint
ALTER TABLE [TABLE_NAME] NOCHECK CONSTRAINT [ALL|CONSTRAINT_NAME]
ALTER TABLE [TABLE_NAME] WITH CHECK CHECK CONSTRAINT [ALL|CONSTRAINT_NAME]
SELECT (CASE WHEN OBJECTPROPERTY(CONSTID, ELSE END) AS STATUS, OBJECT_NAME(CONSTID) AS CONSTRAINT_NAME, OBJECT_NAME(FKEYID) AS TABLE_NAME, COL_NAME(FKEYID, FKEY) AS COLUMN_NAME, OBJECT_NAME(RKEYID) AS REFERENCED_TABLE_NAME, COL_NAME(RKEYID, RKEY) AS REFERENCED_COLUMN_NAME FROM SYSFOREIGNKEYS ORDER BY TABLE_NAME, CONSTRAINT_NAME,REFERENCED_TABLE_NAME, KEYNO
PRINT N SET NOCOUNT ON; SELECT ' PRINT N GO ALTER TABLE ADD CONSTRAINT ) REFERENCES GO' FROM ( SELECT QUOTENAME(fk.NAME) AS [const_name] ,QUOTENAME(schParent.NAME) + ,STUFF(( SELECT FROM sys.foreign_key_columns AS fcP WHERE fcp.constraint_object_id = fk.object_id FOR XML path( ), 1, 1, ,QUOTENAME(schRef.NAME) + ,STUFF(( SELECT FROM sys.foreign_key_columns AS fcR WHERE fcR.constraint_object_id = fk.object_id FOR XML path( ), 1, 1, FROM sys.foreign_key_columns AS fkc INNER JOIN sys.foreign_keys AS fk ON fk.object_id = fkc.constraint_object_id INNER JOIN sys.objects AS oParent ON oParent.object_id = fkc.parent_object_id INNER JOIN sys.schemas AS schParent ON schParent.schema_id = oParent.schema_id INNER JOIN sys.objects AS oRef ON oRef.object_id = fkc.referenced_object_id INNER JOIN sys.schemas AS schRef ON schRef.schema_id = oRef.schema_id GROUP BY fkc.parent_object_id ,fkc.referenced_object_id ,fk.NAME ,fk.object_id ,schParent.NAME ,schRef.NAME ) AS const ORDER BY const.const_name
PRINT N SET NOCOUNT ON; SELECT ' PRINT N GO ALTER TABLE [ GO' FROM sys.foreign_keys AS fk INNER JOIN sys.schemas AS sch ON sch.schema_id = fk.schema_id ORDER BY fk.NAME
--Drop and Recreate Foreign Key Constraints SET NOCOUNT ON DECLARE @table TABLE( RowId INT PRIMARY KEY IDENTITY(1, 1), ForeignKeyConstraintName NVARCHAR(200), ForeignKeyConstraintTableSchema NVARCHAR(200), ForeignKeyConstraintTableName NVARCHAR(200), ForeignKeyConstraintColumnName NVARCHAR(200), PrimaryKeyConstraintName NVARCHAR(200), PrimaryKeyConstraintTableSchema NVARCHAR(200), PrimaryKeyConstraintTableName NVARCHAR(200), PrimaryKeyConstraintColumnName NVARCHAR(200) ) INSERT INTO @table(ForeignKeyConstraintName, ForeignKeyConstraintTableSchema, ForeignKeyConstraintTableName, ForeignKeyConstraintColumnName) SELECT U.CONSTRAINT_NAME, U.TABLE_SCHEMA, U.TABLE_NAME, U.COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE U INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS C ON U.CONSTRAINT_NAME = C.CONSTRAINT_NAME WHERE C.CONSTRAINT_TYPE = UPDATE @table SET PrimaryKeyConstraintName = UNIQUE_CONSTRAINT_NAME FROM @table T INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS R ON T.ForeignKeyConstraintName = R.CONSTRAINT_NAME UPDATE @table SET PrimaryKeyConstraintTableSchema = TABLE_SCHEMA, PrimaryKeyConstraintTableName = TABLE_NAME FROM @table T INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS C ON T.PrimaryKeyConstraintName = C.CONSTRAINT_NAME UPDATE @table SET PrimaryKeyConstraintColumnName = COLUMN_NAME FROM @table T INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE U ON T.PrimaryKeyConstraintName = U.CONSTRAINT_NAME --SELECT * FROM @table --DROP CONSTRAINT: SELECT ' ALTER TABLE [ DROP CONSTRAINT GO' FROM @table --ADD CONSTRAINT: SELECT ' ALTER TABLE [ ADD CONSTRAINT GO' FROM @table GO
SET NOCOUNT ON DECLARE @table TABLE( RowId INT PRIMARY KEY IDENTITY(1, 1), ForeignKeyConstraintName NVARCHAR(200), ForeignKeyConstraintTableSchema NVARCHAR(200), ForeignKeyConstraintTableName NVARCHAR(200), ForeignKeyConstraintColumnName NVARCHAR(200), PrimaryKeyConstraintName NVARCHAR(200), PrimaryKeyConstraintTableSchema NVARCHAR(200), PrimaryKeyConstraintTableName NVARCHAR(200), PrimaryKeyConstraintColumnName NVARCHAR(200), UpdateRule NVARCHAR(100), DeleteRule NVARCHAR(100) ) INSERT INTO @table(ForeignKeyConstraintName, ForeignKeyConstraintTableSchema, ForeignKeyConstraintTableName, ForeignKeyConstraintColumnName) SELECT U.CONSTRAINT_NAME, U.TABLE_SCHEMA, U.TABLE_NAME, U.COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE U INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS C ON U.CONSTRAINT_NAME = C.CONSTRAINT_NAME WHERE C.CONSTRAINT_TYPE = UPDATE @table SET T.PrimaryKeyConstraintName = R.UNIQUE_CONSTRAINT_NAME, T.UpdateRule = R.UPDATE_RULE, T.DeleteRule = R.DELETE_RULE FROM @table T INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS R ON T.ForeignKeyConstraintName = R.CONSTRAINT_NAME UPDATE @table SET PrimaryKeyConstraintTableSchema = TABLE_SCHEMA, PrimaryKeyConstraintTableName = TABLE_NAME FROM @table T INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS C ON T.PrimaryKeyConstraintName = C.CONSTRAINT_NAME UPDATE @table SET PrimaryKeyConstraintColumnName = COLUMN_NAME FROM @table T INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE U ON T.PrimaryKeyConstraintName = U.CONSTRAINT_NAME --SELECT * FROM @table SELECT ' BEGIN TRANSACTION BEGIN TRY' --DROP CONSTRAINT: SELECT ' ALTER TABLE [ DROP CONSTRAINT ' FROM @table SELECT ' END TRY BEGIN CATCH ROLLBACK TRANSACTION RAISERROR( END CATCH IF(@@TRANCOUNT != 0) BEGIN COMMIT TRANSACTION RAISERROR( END ' --ADD CONSTRAINT: SELECT ' BEGIN TRANSACTION BEGIN TRY' SELECT ' ALTER TABLE [ ADD CONSTRAINT ' FROM @table SELECT ' END TRY BEGIN CATCH ROLLBACK TRANSACTION RAISERROR( END CATCH IF(@@TRANCOUNT != 0) BEGIN COMMIT TRANSACTION RAISERROR( END' GO
---------------------------------------------------------------------------- 1) DECLARE @schema_name SYSNAME; DECLARE @table_name SYSNAME; DECLARE @constraint_name SYSNAME; DECLARE @constraint_object_id INT; DECLARE @referenced_object_name SYSNAME; DECLARE @is_disabled BIT; DECLARE @is_not_for_replication BIT; DECLARE @is_not_trusted BIT; DECLARE @delete_referential_action TINYINT; DECLARE @update_referential_action TINYINT; DECLARE @tsql NVARCHAR(4000); DECLARE @tsql2 NVARCHAR(4000); DECLARE @fkCol SYSNAME; DECLARE @pkCol SYSNAME; DECLARE @col1 BIT; DECLARE @action CHAR(6); DECLARE @referenced_schema_name SYSNAME; --------------------------------Generate scripts to drop all foreign keys in a database -------------------------------- IF OBJECT_ID( DROP TABLE sync_dropFK CREATE TABLE sync_dropFK ( ID INT IDENTITY (1,1) NOT NULL , Script NVARCHAR(4000) ) DECLARE FKcursor CURSOR FOR SELECT OBJECT_SCHEMA_NAME(parent_object_id) , OBJECT_NAME(parent_object_id) , name FROM sys.foreign_keys WITH (NOLOCK) ORDER BY 1,2; OPEN FKcursor; FETCH NEXT FROM FKcursor INTO @schema_name , @table_name , @constraint_name WHILE @@FETCH_STATUS = 0 BEGIN SET @tsql = + QUOTENAME(@schema_name) + + QUOTENAME(@table_name) + + QUOTENAME(@constraint_name) + --PRINT @tsql; INSERT sync_dropFK ( Script ) VALUES ( @tsql ) FETCH NEXT FROM FKcursor INTO @schema_name , @table_name , @constraint_name ; END; CLOSE FKcursor; DEALLOCATE FKcursor; ---------------Generate scripts to create all existing foreign keys in a database -------------------------------- ---------------------------------------------------------------------------------------------------------- IF OBJECT_ID( DROP TABLE sync_createFK CREATE TABLE sync_createFK ( ID INT IDENTITY (1,1) NOT NULL , Script NVARCHAR(4000) ) IF OBJECT_ID( DROP TABLE sync_createCHECK CREATE TABLE sync_createCHECK ( ID INT IDENTITY (1,1) NOT NULL , Script NVARCHAR(4000) ) DECLARE FKcursor CURSOR FOR SELECT OBJECT_SCHEMA_NAME(parent_object_id) , OBJECT_NAME(parent_object_id) , name , OBJECT_NAME(referenced_object_id) , OBJECT_ID , is_disabled , is_not_for_replication , is_not_trusted , delete_referential_action , update_referential_action , OBJECT_SCHEMA_NAME(referenced_object_id) FROM sys.foreign_keys WITH (NOLOCK) ORDER BY 1,2; OPEN FKcursor; FETCH NEXT FROM FKcursor INTO @schema_name , @table_name , @constraint_name , @referenced_object_name , @constraint_object_id , @is_disabled , @is_not_for_replication , @is_not_trusted , @delete_referential_action , @update_referential_action , @referenced_schema_name; WHILE @@FETCH_STATUS = 0 BEGIN BEGIN SET @tsql = + QUOTENAME(@schema_name) + + QUOTENAME(@table_name) + CASE @is_not_trusted WHEN 0 THEN ELSE END + + QUOTENAME(@constraint_name) + SET @tsql2 = DECLARE ColumnCursor CURSOR FOR SELECT COL_NAME(fk.parent_object_id , fkc.parent_column_id) , COL_NAME(fk.referenced_object_id , fkc.referenced_column_id) FROM sys.foreign_keys fk WITH (NOLOCK) INNER JOIN sys.foreign_key_columns fkc WITH (NOLOCK) ON fk.[object_id] = fkc.constraint_object_id WHERE fkc.constraint_object_id = @constraint_object_id ORDER BY fkc.constraint_column_id; OPEN ColumnCursor; SET @col1 = 1; FETCH NEXT FROM ColumnCursor INTO @fkCol, @pkCol; WHILE @@FETCH_STATUS = 0 BEGIN IF (@col1 = 1) SET @col1 = 0; ELSE BEGIN SET @tsql = @tsql + SET @tsql2 = @tsql2 + END; SET @tsql = @tsql + QUOTENAME(@fkCol); SET @tsql2 = @tsql2 + QUOTENAME(@pkCol); --PRINT --PRINT FETCH NEXT FROM ColumnCursor INTO @fkCol, @pkCol; --PRINT --PRINT END; CLOSE ColumnCursor; DEALLOCATE ColumnCursor; SET @tsql = @tsql + + QUOTENAME(@referenced_schema_name) + + QUOTENAME(@referenced_object_name) + + @tsql2 + SET @tsql = @tsql + + CASE @update_referential_action WHEN 0 THEN WHEN 1 THEN WHEN 2 THEN ELSE END + + CASE @delete_referential_action WHEN 0 THEN WHEN 1 THEN WHEN 2 THEN ELSE END + CASE @is_not_for_replication WHEN 1 THEN ELSE END + END; -- PRINT @tsql INSERT sync_createFK ( Script ) VALUES ( @tsql ) -------------------Generate CHECK CONSTRAINT scripts for a database ------------------------------ ---------------------------------------------------------------------------------------------------------- BEGIN SET @tsql = + QUOTENAME(@schema_name) + + QUOTENAME(@table_name) + CASE @is_disabled WHEN 0 THEN ELSE END + + QUOTENAME(@constraint_name) + --PRINT @tsql; INSERT sync_createCHECK ( Script ) VALUES ( @tsql ) END; FETCH NEXT FROM FKcursor INTO @schema_name , @table_name , @constraint_name , @referenced_object_name , @constraint_object_id , @is_disabled , @is_not_for_replication , @is_not_trusted , @delete_referential_action , @update_referential_action , @referenced_schema_name; END; CLOSE FKcursor; DEALLOCATE FKcursor; --SELECT * FROM sync_DropFK --SELECT * FROM sync_CreateFK --SELECT * FROM sync_CreateCHECK --------------------------------------------------------------------------- 2.) ----------------------------------------------------------------------------------------------------------------- ----------------------------execute Drop FK Scripts -------------------------------------------------- DECLARE @scriptD NVARCHAR(4000) DECLARE DropFKCursor CURSOR FOR SELECT Script FROM sync_dropFK WITH (NOLOCK) OPEN DropFKCursor FETCH NEXT FROM DropFKCursor INTO @scriptD WHILE @@FETCH_STATUS = 0 BEGIN --PRINT @scriptD EXEC (@scriptD) FETCH NEXT FROM DropFKCursor INTO @scriptD END CLOSE DropFKCursor DEALLOCATE DropFKCursor -------------------------------------------------------------------------------- 3.) ------------------------------------------------------------------------------------------------------------------ ----------------------------Truncate all tables in the database other than our staging tables -------------------- ------------------------------------------------------------------------------------------------------------------ EXEC sp_MSforeachtable ( ISNULL(OBJECT_ID( ISNULL(OBJECT_ID( ISNULL(OBJECT_ID( ) BEGIN TRY TRUNCATE TABLE ? END TRY BEGIN CATCH PRINT END CATCH; GO ------------------------------------------------------------------------------- ------------------------------------------------------------------------------------------------- ----------------------------execute Create FK Scripts and CHECK CONSTRAINT Scripts--------------- ----------------------------tack me at the end of the ETL in a SQL task------------------------- ------------------------------------------------------------------------------------------------- DECLARE @scriptC NVARCHAR(4000) DECLARE CreateFKCursor CURSOR FOR SELECT Script FROM sync_createFK WITH (NOLOCK) OPEN CreateFKCursor FETCH NEXT FROM CreateFKCursor INTO @scriptC WHILE @@FETCH_STATUS = 0 BEGIN --PRINT @scriptC EXEC (@scriptC) FETCH NEXT FROM CreateFKCursor INTO @scriptC END CLOSE CreateFKCursor DEALLOCATE CreateFKCursor ------------------------------------------------------------------------------------------------- DECLARE @scriptCh NVARCHAR(4000) DECLARE CreateCHECKCursor CURSOR FOR SELECT Script FROM sync_createCHECK WITH (NOLOCK) OPEN CreateCHECKCursor FETCH NEXT FROM CreateCHECKCursor INTO @scriptCh WHILE @@FETCH_STATUS = 0 BEGIN --PRINT @scriptCh EXEC (@scriptCh) FETCH NEXT FROM CreateCHECKCursor INTO @scriptCh END CLOSE CreateCHECKCursor DEALLOCATE CreateCHECKCursor
ALTER TABLE MyTable WITH CHECK CHECK CONSTRAINT MyConstraint;
SELECT * FROM sys.foreign_keys WHERE is_not_trusted = 1;
SELECT * FROM sys.foreign_keys WHERE referenced_object_id = object_id(
SELECT FROM sys.foreign_keys WHERE referenced_object_id = object_id(
Alter table MyTable nocheck constraint FK_ForeignKeyConstraintName
Alter table Locations nocheck constraint FK_LocationsEmployeesLocationIdEmployeeId
select from sys.sysconstraints where status & 0x4813 = 0x813 order by object_name(id)
select from sys.sysconstraints where status & 0x4813 = 0x813 order by object_name(id)
declare @schema nvarchar(max) = declare @deletiontables nvarchar(max) = declare @truncateclause nvarchar(max) = @schema + declare @deleteclause nvarchar(max) = @schema + exec sp_MSforeachtable exec sp_MSforeachtable exec sp_MSforeachtable exec sp_MSforeachtable
DECLARE @sql AS NVARCHAR(max)= select @sql = @sql + from sys.tables t where type= select @sql = @sql + from sys.key_constraints i join sys.tables t on i.parent_object_id=t.object_id where i.type= exec dbo.sp_executesql @sql; go
DECLARE @sql AS NVARCHAR(max)= select @sql = @sql + from sys.tables t where type= exec dbo.sp_executesql @sql; go
/****** Object: UserDefinedTableType [util].[typ_objects_for_managing] Script Date: 03/04/2016 16:42:55 ******/ CREATE TYPE [util].[typ_objects_for_managing] AS TABLE( [schema] [sysname] NOT NULL, [object] [sysname] NOT NULL ) GO create procedure [util].[truncate_table_with_constraints] @objects_for_managing util.typ_objects_for_managing readonly --@schema sysname --,@table sysname as --select -- @table = -- @schema = declare @exec_table as table (ordinal int identity (1,1), statement nvarchar(4000), primary key (ordinal)); --print insert into @exec_table (statement) select from sys.foreign_keys fk inner join sys.objects o on fk.parent_object_id = o.object_id where exists ( select * from @objects_for_managing chk where chk.[schema] = SCHEMA_NAME(o.schema_id) and chk.[object] = o.name ) ; --o.name = @table and --SCHEMA_NAME(o.schema_id) = @schema insert into @exec_table (statement) select from @objects_for_managing src ; --print insert into @exec_table (statement) select REFERENCES [ from sys.foreign_key_columns fkc inner join sys.foreign_keys fk on fkc.constraint_object_id = fk.object_id inner join sys.objects o on fk.parent_object_id = o.object_id inner join sys.columns c on fkc.parent_column_id = c.column_id and o.object_id = c.object_id inner join sys.objects refob on fkc.referenced_object_id = refob.object_id inner join sys.columns refcol on fkc.referenced_column_id = refcol.column_id and fkc.referenced_object_id = refcol.object_id where exists ( select * from @objects_for_managing chk where chk.[schema] = SCHEMA_NAME(o.schema_id) and chk.[object] = o.name ) ; --o.name = @table and --SCHEMA_NAME(o.schema_id) = @schema declare @looper int , @total_records int, @sql_exec nvarchar(4000) select @looper = 1, @total_records = count(*) from @exec_table; while @looper <= @total_records begin select @sql_exec = (select statement from @exec_table where ordinal =@looper) exec sp_executesql @sql_exec print @sql_exec set @looper = @looper + 1 end
DECLARE @my_table TABLE ( [value] VARCHAR(200) ) INSERT INTO @my_table VALUES ( SELECT * FROM @my_table
SET QUOTED_IDENTIFIER OFF; UPDATE TABLE SET NAME = REPLACE(NAME, " SET QUOTED_IDENTIFIER ON; -- set OFF then ON again
DECLARE @singleQuote CHAR SET @singleQuote = CHAR(39) insert into my_table values(
UPDATE table1 a INNER JOIN table2 b ON a.commonfield = b.[common field] SET a.CalculatedColumn= b.[Calculated Column] WHERE b.[common field]= a.commonfield AND a.BatchNO =
UPDATE t1 SET t1.CalculatedColumn = t2.[Calculated Column] FROM dbo.Table1 AS t1 INNER JOIN dbo.Table2 AS t2 ON t1.CommonField = t2.[Common Field] WHERE t1.BatchNo =
;WITH t2 AS ( SELECT [key], CalculatedColumn = SUM(some_column) FROM dbo.table2 GROUP BY [key] ) UPDATE t1 SET t1.CalculatedColumn = t2.CalculatedColumn FROM dbo.table1 AS t1 INNER JOIN t2 ON t1.[key] = t2.[key];
begin tran UPDATE a SET a.CalculatedColumn= b.[Calculated Column] FROM table1 a INNER JOIN table2 b ON a.commonfield = b.[common field] WHERE a.BatchNO = commit tran
UPDATE a SET a.CalculatedColumn = b.[Calculated Column] FROM Table1 AS a INNER JOIN Table2 AS b ON a.CommonField = b.[Common Field] WHERE a.BatchNo =
update t set t.name = from tableName t where t.id = 1
MERGE table1 T USING table2 S ON T.CommonField = S."Common Field" AND T.BatchNo = WHEN MATCHED THEN UPDATE SET CalculatedColumn = S."Calculated Column";
UPDATE a SET a.CalculatedColumn= b.[Calculated Column] FROM table1 a, table2 b WHERE b.[common field]= a.commonfield AND a.BatchNO =
UPDATE mytable SET myfield = CASE other_field WHEN 1 THEN WHEN 2 THEN WHEN 3 THEN END From mytable Join otherTable on otherTable.id = mytable.id Where othertable.somecolumn =
DECLARE @expense_report_id AS INT SET @expense_report_id = 1027 --UPDATE expense_report_detail_distribution --SET service_bill_id = 9 SELECT * FROM expense_report_detail_distribution erdd INNER JOIN expense_report_detail erd INNER JOIN expense_report er ON er.expense_report_id = erd.expense_report_id ON erdd.expense_report_detail_id = erd.expense_report_detail_id WHERE er.expense_report_id = @expense_report_id
;WITH cteTable1(CalculatedColumn, CommonField) AS ( select CalculatedColumn, CommonField from Table1 Where BatchNo = ) MERGE cteTable1 AS target USING (select "Calculated Column", "Common Field" FROM dbo.Table2) AS source ("Calculated Column", "Common Field") ON (target.CommonField = source."Common Field") WHEN MATCHED THEN UPDATE SET target.CalculatedColumn = source."Calculated Column";
select tb1.col1, tb1.col2, tb1.col3 , ( select where tbl1.col1 = tbl2.col1 and tab1.col2 = tbl2.col2 ) from myTable as tbl1
UPDATE table1 SET CalculatedColumn = ( SELECT [Calculated Column] FROM table2 WHERE table1.commonfield = [common field]) WHERE BatchNO =
SELECT * FROM dbo.MyTable WHERE col1 = dbo.MyFunction(col2)
CREATE FUNCTION MyFunction (@someValue INTEGER) RETURNS INTEGER AS BEGIN DECLARE @retval INTEGER SELECT localValue FROM dbo.localToNationalMapTable WHERE nationalValue = @someValue RETURN @retval END
STORE PROCEDURE FUNCTION (USER DEFINED FUNCTION) * Procedure can return 0, single or | * Function can return only single value multiple values. | | * Procedure can have input, output | * Function can have only input parameters. | parameters. | * Procedure cannot be called from | * Functions can be called from function. | procedure. | * Procedure allows select as well as | * Function allows only select statement DML statement in it. | in it. | * Exception can be handled by | * Try-catch block cannot be used in a try-catch block in a procedure. | function. | * We can go for transaction management| * We can in procedure. | management in function. | * Procedure cannot be utilized in a | * Function can be embedded in a select select statement | statement. | * Procedure can affect the state | * Function can not affect the state of database means it can perform | of database means it can not CRUD operation on database. | perform CRUD operation on | database. | * Procedure can use temporary tables. | * Function can not use temporary tables | temporary tables. | * Procedure can alter the server | * Function can not alter the environment parameters. | environment parameters. | * Procedure can use when we want | * Function can use when we want instead is to group a possibly- | to compute and return a value complex set of SQL statements. | for use in other SQL statements.
declare @d1 datetime = declare @d2 datetime2 = declare @d3 datetime = select @d1 as
DECLARE @temp TABLE ( sdt smalldatetime, dt datetime, dt20 datetime2(0), dt27 datetime2(7) ) INSERT @temp SELECT getdate(),getdate(),getdate(),getdate() SELECT sdt,DATALENGTH(sdt) as sdt_bytes, dt,DATALENGTH(dt) as dt_bytes, dt20,DATALENGTH(dt20) as dt20_bytes, dt27, DATALENGTH(dt27) as dt27_bytes FROM @temp
sdt sdt_bytes dt dt_bytes dt20 dt20_bytes dt27 dt27_bytes 2015-09-11 11:26:00 4 2015-09-11 11:25:42.417 8 2015-09-11 11:25:42 6 2015-09-11 11:25:42.4170000 8
set dateformat dmy declare @d datetime, @d2 datetime2 select @d = select @d, @d2
Execution Timeout Expired. The timeout period elapsed prior to completion of the operation or the server is not responding.
OrderGUID OrderNumber ========= ============ {FFB2...} STL-7442-1 {3EC6...} MPT-9931-8A
LineItemGUID Order ID Quantity Description ============ ======== ======== ================================= {098FBE3...} 1 7 prefabulated amulite {1609B09...} 2 32 spurving bearing
LineItemID Order ID Quantity Description ========== ======== ======== ================================= {A58A1...} 6,784,329 5 pentametric fan {0E9BC...} 6,784,329 5 differential girdlespring
SELECT Orders.OrderNumber, LineItems.Quantity, LineItems.Description FROM Orders INNER JOIN LineItems ON Orders.OrderID = LineItems.OrderID
OrderNumber Quantity Description =========== ======== ==================== STL-7442-1 7 prefabulated amulite MPT-9931-8A 32 spurving bearing KSG-0619-81 5 panametric fan KSG-0619-81 5 differential girdlespring
OrderNumber Quantity Description =========== ======== ==================== STL-7442-1 7 prefabulated amulite MPT-9931-8A 32 differential girdlespring KSG-0619-81 5 panametric fan
OrderNumber Quantity Description =========== ======== ==================== STL-7442-1 7 prefabulated amulite MPT-9931-8A 32 differential girdlespring KSG-0619-81 5 panametric fan, ...
SELECT Orders.OrderNumber, LineItems.Quantity, LineItems.Description FROM Orders INNER JOIN ( SELECT TOP 1 LineItems.Quantity, LineItems.Description FROM LineItems WHERE LineItems.OrderID = Orders.OrderID) LineItems2 ON 1=1
SELECT Orders.OrderNumber, LineItems.Quantity, LineItems.Description FROM Orders JOIN LineItems ON LineItems.LineItemGUID = ( SELECT TOP 1 LineItemGUID FROM LineItems WHERE OrderID = Orders.OrderID )
SELECT Orders.OrderNumber, LineItems2.Quantity, LineItems2.Description FROM Orders CROSS APPLY ( SELECT TOP 1 LineItems.Quantity, LineItems.Description FROM LineItems WHERE LineItems.OrderID = Orders.OrderID ) LineItems2
SELECT Orders.OrderNumber, LineItems.Quantity, LineItems.Description FROM Orders INNER JOIN ( SELECT Orders.OrderNumber, Max(LineItem.LineItemID) AS LineItemID FROM Orders INNER JOIN LineItems ON Orders.OrderNumber = LineItems.OrderNumber GROUP BY Orders.OrderNumber ) AS Items ON Orders.OrderNumber = Items.OrderNumber INNER JOIN LineItems ON Items.LineItemID = LineItems.LineItemID
SELECT Orders.OrderNumber, LineItems.Quantity, LineItems.Description FROM Orders INNER JOIN LineItems ON Orders.OrderID = LineItems.OrderID WHERE LineItems.LineItemID = ( SELECT MIN(LineItemID) FROM LineItems WHERE OrderID = Orders.OrderID )
SELECT Orders.OrderNumber, LineItems2.Quantity, LineItems2.Description FROM Orders LEFT JOIN ( SELECT LineItems.Quantity, LineItems.Description, OrderId, ROW_NUMBER() OVER (PARTITION BY OrderId ORDER BY (SELECT NULL)) AS RowNum FROM LineItems ) LineItems2 ON LineItems2.OrderId = Orders.OrderID And RowNum = 1
with firstOnly as ( select Orders.OrderNumber, LineItems.Quantity, LineItems.Description, ROW_NUMBER() over (partiton by Orders.OrderID order by Orders.OrderID) lp FROM Orders join LineItems on Orders.OrderID = LineItems.OrderID ) select * from firstOnly where lp = 1
select * from Orders o cross apply ( select CAST((select l.Description + from LineItems l where l.OrderID = s.OrderID for xml path( ) lines
select * from users join widgets on widgets.id = ( select id from widgets where widgets.user_id = users.id order by created_at desc limit 1 )
SELECT Orders.OrderNumber , LineItems.Quantity , LineItems.Description FROM ( SELECT Orders.OrderID , Orders.OrderNumber , FirstLineItemID = ( SELECT TOP 1 LineItemID FROM LineItems WHERE LineItems.OrderID = Orders.OrderID ORDER BY LineItemID -- or whatever else ) FROM Orders ) Orders JOIN LineItems ON LineItems.OrderID = Orders.OrderID AND LineItems.LineItemID = Orders.FirstLineItemID
SELECT Orders.OrderNumber, LineItems.Quantity, LineItems.Description FROM Orders LEFT JOIN LineItems ON Orders.OrderID = LineItems.OrderID GROUP BY Orders.OrderNumber
Orders LineItems +-------------+ +---------+----------+---------------+ | OrderNumber | | OrderID | Quantity | Description | +-------------+ +---------+----------+---------------+ | 22586 | | 22586 | 17 | Trunion | +-------------+ | 22586 | 3 | Girdle Spring | +---------+----------+---------------+
OrderNumber Quantity Description ----------- -------- ------------- 22586 17 Trunion 22586 3 Girdle Spring 2 row(s) affected
OrderNumber Quantity Description ----------- -------- ------------- 22586 17 Trunion 1 row(s) affected
select o.OrderNumber, li.Quantity, li.Description from Orders as o inner join LineItems as li on li.OrderID = o.OrderID where not exists ( select 1 from LineItems as li_later where li_later.OrderID = o.OrderID and li_later.LineItemGUID > li.LineItemGUID )
SELECT DISTINCT o.OrderNumber , FIRST_VALUE(li.Quantity) OVER ( PARTITION BY o.OrderNumber ORDER BY li.Description ) AS Quantity , FIRST_VALUE(li.Description) OVER ( PARTITION BY o.OrderNumber ORDER BY li.Description ) AS Description FROM Orders AS o INNER JOIN LineItems AS li ON o.OrderID = li.OrderID
SELECT Orders.OrderNumber, max(LineItems.Quantity), max(LineItems.Description) FROM Orders INNER JOIN LineItems ON Orders.OrderID = LineItems.OrderID Group by Orders.OrderNumber
select t.name as TableWithForeignKey, fk.constraint_column_id as FK_PartNo, c. name as ForeignKeyColumn from sys.foreign_key_columns as fk inner join sys.tables as t on fk.parent_object_id = t.object_id inner join sys.columns as c on fk.parent_object_id = c.object_id and fk.parent_column_id = c.column_id where fk.referenced_object_id = (select object_id from sys.tables where name = order by TableWithForeignKey, FK_PartNo
select distinct name from sys.objects where object_id in ( select fk.constraint_object_id from sys.foreign_key_columns as fk where fk.referenced_object_id = (select object_id from sys.tables where name = )
SELECT obj.name AS FK_NAME, sch.name AS [schema_name], tab1.name AS [table], col1.name AS [column], tab2.name AS [referenced_table], col2.name AS [referenced_column] FROM sys.foreign_key_columns fkc INNER JOIN sys.objects obj ON obj.object_id = fkc.constraint_object_id INNER JOIN sys.tables tab1 ON tab1.object_id = fkc.parent_object_id INNER JOIN sys.schemas sch ON tab1.schema_id = sch.schema_id INNER JOIN sys.columns col1 ON col1.column_id = parent_column_id AND col1.object_id = tab1.object_id INNER JOIN sys.tables tab2 ON tab2.object_id = fkc.referenced_object_id INNER JOIN sys.columns col2 ON col2.column_id = referenced_column_id AND col2.object_id = tab2.object_id
select O.name as [Object_Name], C.text as [Object_Definition] from sys.syscomments C inner join sys.all_objects O ON C.id = O.object_id where C.text like
SELECT FROM sys.foreign_key_columns fk JOIN sys.tables referencingTable ON fk.parent_object_id = referencingTable.object_id JOIN sys.schemas sch ON referencingTable.schema_id = sch.schema_id JOIN sys.objects foreignKey ON foreignKey.object_id = fk.constraint_object_id JOIN sys.tables referencedTable ON fk.referenced_object_id = referencedTable.object_id WHERE referencedTable.name =
[DropCommand] ALTER TABLE [dbo].[OtherTable1] DROP CONSTRAINT [FK_OtherTable1_MyTable] ALTER TABLE [dbo].[OtherTable2] DROP CONSTRAINT [FK_OtherTable2_MyTable]
SELECT PKTABLE_QUALIFIER = CONVERT(SYSNAME,DB_NAME()), PKTABLE_OWNER = CONVERT(SYSNAME,SCHEMA_NAME(O1.SCHEMA_ID)), PKTABLE_NAME = CONVERT(SYSNAME,O1.NAME), PKCOLUMN_NAME = CONVERT(SYSNAME,C1.NAME), FKTABLE_QUALIFIER = CONVERT(SYSNAME,DB_NAME()), FKTABLE_OWNER = CONVERT(SYSNAME,SCHEMA_NAME(O2.SCHEMA_ID)), FKTABLE_NAME = CONVERT(SYSNAME,O2.NAME), FKCOLUMN_NAME = CONVERT(SYSNAME,C2.NAME), -- Force the column to be non-nullable (see SQL BU 325751) --KEY_SEQ = isnull(convert(smallint,k.constraint_column_id), sysconv(smallint,0)), UPDATE_RULE = CONVERT(SMALLINT,CASE OBJECTPROPERTY(F.OBJECT_ID, WHEN 1 THEN 0 ELSE 1 END), DELETE_RULE = CONVERT(SMALLINT,CASE OBJECTPROPERTY(F.OBJECT_ID, WHEN 1 THEN 0 ELSE 1 END), FK_NAME = CONVERT(SYSNAME,OBJECT_NAME(F.OBJECT_ID)), PK_NAME = CONVERT(SYSNAME,I.NAME), DEFERRABILITY = CONVERT(SMALLINT,7) -- SQL_NOT_DEFERRABLE FROM SYS.ALL_OBJECTS O1, SYS.ALL_OBJECTS O2, SYS.ALL_COLUMNS C1, SYS.ALL_COLUMNS C2, SYS.FOREIGN_KEYS F INNER JOIN SYS.FOREIGN_KEY_COLUMNS K ON (K.CONSTRAINT_OBJECT_ID = F.OBJECT_ID) INNER JOIN SYS.INDEXES I ON (F.REFERENCED_OBJECT_ID = I.OBJECT_ID AND F.KEY_INDEX_ID = I.INDEX_ID) WHERE O1.OBJECT_ID = F.REFERENCED_OBJECT_ID AND O2.OBJECT_ID = F.PARENT_OBJECT_ID AND C1.OBJECT_ID = F.REFERENCED_OBJECT_ID AND C2.OBJECT_ID = F.PARENT_OBJECT_ID AND C1.COLUMN_ID = K.REFERENCED_COLUMN_ID AND C2.COLUMN_ID = K.PARENT_COLUMN_ID
SELECT f.name AS OBJECT_NAME(f.parent_object_id) AS COL_NAME(fc.parent_object_id,fc.parent_column_id) AS OBJECT_NAME(t.object_id) AS COL_NAME(t.object_id,fc.referenced_column_id) AS f.name + COL_NAME(t.object_id,fc.referenced_column_id) + -- , delete_referential_action_desc AS FROM sys.foreign_keys AS f, sys.foreign_key_columns AS fc, sys.tables t WHERE f.OBJECT_ID = fc.constraint_object_id AND t.OBJECT_ID = fc.referenced_object_id AND OBJECT_NAME(t.object_id) = ORDER BY 2
ALTER TABLE [dbo].[Employees] WITH NOCHECK ADD CONSTRAINT [FK_Employees_Employees] FOREIGN KEY([ReportsTo]) REFERENCES [dbo].[Employees] ([EmployeeID])
ALTER TABLE [Employees] DROP CONSTRAINT [FK_Employees_Employees]
ALTER TABLE [Employees] WITH NOCHECK ADD CONSTRAINT [FK_Employees_Employees] FOREIGN KEY([ReportsTo]) REFERENCES [Employees] ([EmployeeID])
SELECT object_name(parent_object_id), object_name(referenced_object_id), name FROM sys.foreign_keys WHERE parent_object_id = object_id(
SELECT ccu.table_name AS SourceTable ,ccu.constraint_name AS SourceConstraint ,ccu.column_name AS SourceColumn ,kcu.table_name AS TargetTable ,kcu.column_name AS TargetColumn FROM INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc ON ccu.CONSTRAINT_NAME = rc.CONSTRAINT_NAME INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON kcu.CONSTRAINT_NAME = rc.UNIQUE_CONSTRAINT_NAME ORDER BY ccu.table_name
SELECT OBJECT_NAME(fkeys.constraint_object_id) foreign_key_name ,OBJECT_NAME(fkeys.parent_object_id) referencing_table_name ,COL_NAME(fkeys.parent_object_id, fkeys.parent_column_id) referencing_column_name ,OBJECT_SCHEMA_NAME(fkeys.parent_object_id) referencing_schema_name ,OBJECT_NAME (fkeys.referenced_object_id) referenced_table_name ,COL_NAME(fkeys.referenced_object_id, fkeys.referenced_column_id) referenced_column_name ,OBJECT_SCHEMA_NAME(fkeys.referenced_object_id) referenced_schema_name FROM sys.foreign_key_columns AS fkeys
WHERE OBJECT_NAME(fkeys.parent_object_id) = OBJECT_SCHEMA_NAME(fkeys.parent_object_id) =
--setup variables. Just change declare @objid int, @objname nvarchar(776) select @objname = select @objid = object_id(@objname) if exists (select * from sys.foreign_keys where referenced_object_id = @objid) select db_name() + + rtrim(schema_name(ObjectProperty(parent_object_id, + + from sys.foreign_keys where referenced_object_id = @objid order by 1
SELECT OBJECT_NAME(parent_object_id) c.NAME OBJECT_NAME(referenced_object_id) cref.NAME FROM sys.foreign_key_columns fkc INNER JOIN sys.columns c ON fkc.parent_column_id = c.column_id AND fkc.parent_object_id = c.object_id INNER JOIN sys.columns cref ON fkc.referenced_column_id = cref.column_id AND fkc.referenced_object_id = cref.object_id where OBJECT_NAME(parent_object_id) =
SELECT OBJECT_NAME(fk.parent_object_id) as ReferencingTable, OBJECT_NAME(fk.constraint_object_id) as [FKContraint] FROM sys.foreign_key_columns as fk WHERE fk.referenced_object_id = OBJECT_ID(
SELECT OBJECT_NAME(object_id) from sys.columns where name like
SELECT t.name AS TableWithForeignKey, fk.constraint_column_id AS FK_PartNo, c.name AS ForeignKeyColumn, o.name AS FK_Name FROM sys.foreign_key_columns AS fk INNER JOIN sys.tables AS t ON fk.parent_object_id = t.object_id INNER JOIN sys.columns AS c ON fk.parent_object_id = c.object_id AND fk.parent_column_id = c.column_id INNER JOIN sys.objects AS o ON fk.constraint_object_id = o.object_id WHERE fk.referenced_object_id = (SELECT object_id FROM sys.tables WHERE name = ORDER BY TableWithForeignKey, FK_PartNo;
WITH ALL_KEYS_IN_TABLE (CONSTRAINT_NAME,CONSTRAINT_TYPE,PARENT_TABLE_NAME,PARENT_COL_NAME,PARENT_COL_NAME_DATA_TYPE,REFERENCE_TABLE_NAME,REFERENCE_COL_NAME) AS ( SELECT CONSTRAINT_NAME= CAST (PKnUKEY.name AS VARCHAR(30)) , CONSTRAINT_TYPE=CAST (PKnUKEY.type_desc AS VARCHAR(30)) , PARENT_TABLE_NAME=CAST (PKnUTable.name AS VARCHAR(30)) , PARENT_COL_NAME=CAST ( PKnUKEYCol.name AS VARCHAR(30)) , PARENT_COL_NAME_DATA_TYPE= oParentColDtl.DATA_TYPE, REFERENCE_TABLE_NAME= REFERENCE_COL_NAME= FROM sys.key_constraints as PKnUKEY INNER JOIN sys.tables as PKnUTable ON PKnUTable.object_id = PKnUKEY.parent_object_id INNER JOIN sys.index_columns as PKnUColIdx ON PKnUColIdx.object_id = PKnUTable.object_id AND PKnUColIdx.index_id = PKnUKEY.unique_index_id INNER JOIN sys.columns as PKnUKEYCol ON PKnUKEYCol.object_id = PKnUTable.object_id AND PKnUKEYCol.column_id = PKnUColIdx.column_id INNER JOIN INFORMATION_SCHEMA.COLUMNS oParentColDtl ON oParentColDtl.TABLE_NAME=PKnUTable.name AND oParentColDtl.COLUMN_NAME=PKnUKEYCol.name UNION ALL SELECT CONSTRAINT_NAME= CAST (oConstraint.name AS VARCHAR(30)) , CONSTRAINT_TYPE= PARENT_TABLE_NAME=CAST (oParent.name AS VARCHAR(30)) , PARENT_COL_NAME=CAST ( oParentCol.name AS VARCHAR(30)) , PARENT_COL_NAME_DATA_TYPE= oParentColDtl.DATA_TYPE, REFERENCE_TABLE_NAME=CAST ( oReference.name AS VARCHAR(30)) , REFERENCE_COL_NAME=CAST (oReferenceCol.name AS VARCHAR(30)) FROM sys.foreign_key_columns FKC INNER JOIN sys.sysobjects oConstraint ON FKC.constraint_object_id=oConstraint.id INNER JOIN sys.sysobjects oParent ON FKC.parent_object_id=oParent.id INNER JOIN sys.all_columns oParentCol ON FKC.parent_object_id=oParentCol.object_id AND FKC.parent_column_id=oParentCol.column_id INNER JOIN sys.sysobjects oReference ON FKC.referenced_object_id=oReference.id INNER JOIN INFORMATION_SCHEMA.COLUMNS oParentColDtl ON oParentColDtl.TABLE_NAME=oParent.name AND oParentColDtl.COLUMN_NAME=oParentCol.name INNER JOIN sys.all_columns oReferenceCol ON FKC.referenced_object_id=oReferenceCol.object_id AND FKC.referenced_column_id=oReferenceCol.column_id ) select * from ALL_KEYS_IN_TABLE where PARENT_TABLE_NAME in ( or REFERENCE_TABLE_NAME in ( ORDER BY PARENT_TABLE_NAME,CONSTRAINT_NAME;
-->>SPECIFY THE DESIRED DB USE ??? GO /********************************************************************************************* LIST OUT ALL PRIMARY AND FOREIGN KEY CONSTRAINTS IN A DB OR FOR A SPECIFIED TABLE *********************************************************************************************/ DECLARE @tblName VARCHAR(255) /*******************/ SET @tblName = NULL-->NULL will return all PK/FK constraints for every table in the database /*******************/ SELECT PKTABLE_QUALIFIER = CONVERT(SYSNAME,DB_NAME()), PKTABLE_OWNER = CONVERT(SYSNAME,SCHEMA_NAME(O1.schema_id)), PKTABLE_NAME = CONVERT(SYSNAME,O1.name), PKCOLUMN_NAME = CONVERT(SYSNAME,C1.name), FKTABLE_QUALIFIER = CONVERT(SYSNAME,DB_NAME()), FKTABLE_OWNER = CONVERT(SYSNAME,SCHEMA_NAME(O2.schema_id)), FKTABLE_NAME = CONVERT(SYSNAME,O2.name), FKCOLUMN_NAME = CONVERT(SYSNAME,C2.name), -- Force the column to be non-nullable (see SQL BU 325751) KEY_SEQ = isnull(convert(smallint,K.constraint_column_id),0), UPDATE_RULE = CONVERT(SMALLINT,CASE OBJECTPROPERTY(F.object_id, WHEN 1 THEN 0 ELSE 1 END), DELETE_RULE = CONVERT(SMALLINT,CASE OBJECTPROPERTY(F.object_id, WHEN 1 THEN 0 ELSE 1 END), FK_NAME = CONVERT(SYSNAME,OBJECT_NAME(F.object_id)), PK_NAME = CONVERT(SYSNAME,I.name), DEFERRABILITY = CONVERT(SMALLINT,7) -- SQL_NOT_DEFERRABLE FROM sys.all_objects O1, sys.all_objects O2, sys.all_columns C1, sys.all_columns C2, sys.foreign_keys F INNER JOIN sys.foreign_key_columns K ON (K.constraint_object_id = F.object_id) INNER JOIN sys.indexes I ON (F.referenced_object_id = I.object_id AND F.key_index_id = I.index_id) WHERE O1.object_id = F.referenced_object_id AND O2.object_id = F.parent_object_id AND C1.object_id = F.referenced_object_id AND C2.object_id = F.parent_object_id AND C1.column_id = K.referenced_column_id AND C2.column_id = K.parent_column_id AND ( O1.name = @tblName OR O2.name = @tblName OR @tblName IS null) ORDER BY PKTABLE_NAME,FKTABLE_NAME
DECLARE @dbTableName varchar(max) = DECLARE @dbRowId uniqueidentifier = DECLARE @FK_ROWCOUNT int DECLARE @SQL nvarchar(max) DECLARE @PKTABLE_QUALIFIER sysname DECLARE @PKTABLE_OWNER sysname DECLARE @PKTABLE_NAME sysname DECLARE @PKCOLUMN_NAME sysname DECLARE @FKTABLE_QUALIFIER sysname DECLARE @FKTABLE_OWNER sysname DECLARE @FKTABLE_NAME sysname DECLARE @FKCOLUMN_NAME sysname DECLARE @UPDATE_RULE smallint DECLARE @DELETE_RULE smallint DECLARE @FK_NAME sysname DECLARE @PK_NAME sysname DECLARE @DEFERRABILITY sysname IF OBJECT_ID( DROP TABLE CREATE TABLE PKTABLE_QUALIFIER sysname, PKTABLE_OWNER sysname, PKTABLE_NAME sysname, PKCOLUMN_NAME sysname, FKTABLE_QUALIFIER sysname, FKTABLE_OWNER sysname, FKTABLE_NAME sysname, FKCOLUMN_NAME sysname, UPDATE_RULE smallint, DELETE_RULE smallint, FK_NAME sysname, PK_NAME sysname, DEFERRABILITY sysname, FK_ROWCOUNT int ); DECLARE FK_Counter_Cursor CURSOR FOR SELECT PKTABLE_QUALIFIER = CONVERT(SYSNAME,DB_NAME()), PKTABLE_OWNER = CONVERT(SYSNAME,SCHEMA_NAME(O1.SCHEMA_ID)), PKTABLE_NAME = CONVERT(SYSNAME,O1.NAME), PKCOLUMN_NAME = CONVERT(SYSNAME,C1.NAME), FKTABLE_QUALIFIER = CONVERT(SYSNAME,DB_NAME()), FKTABLE_OWNER = CONVERT(SYSNAME,SCHEMA_NAME(O2.SCHEMA_ID)), FKTABLE_NAME = CONVERT(SYSNAME,O2.NAME), FKCOLUMN_NAME = CONVERT(SYSNAME,C2.NAME), -- Force the column to be non-nullable (see SQL BU 325751) --KEY_SEQ = isnull(convert(smallint,k.constraint_column_id), sysconv(smallint,0)), UPDATE_RULE = CONVERT(SMALLINT,CASE OBJECTPROPERTY(F.OBJECT_ID, WHEN 1 THEN 0 ELSE 1 END), DELETE_RULE = CONVERT(SMALLINT,CASE OBJECTPROPERTY(F.OBJECT_ID, WHEN 1 THEN 0 ELSE 1 END), FK_NAME = CONVERT(SYSNAME,OBJECT_NAME(F.OBJECT_ID)), PK_NAME = CONVERT(SYSNAME,I.NAME), DEFERRABILITY = CONVERT(SMALLINT,7) -- SQL_NOT_DEFERRABLE FROM SYS.ALL_OBJECTS O1, SYS.ALL_OBJECTS O2, SYS.ALL_COLUMNS C1, SYS.ALL_COLUMNS C2, SYS.FOREIGN_KEYS F INNER JOIN SYS.FOREIGN_KEY_COLUMNS K ON (K.CONSTRAINT_OBJECT_ID = F.OBJECT_ID) INNER JOIN SYS.INDEXES I ON (F.REFERENCED_OBJECT_ID = I.OBJECT_ID AND F.KEY_INDEX_ID = I.INDEX_ID) WHERE O1.OBJECT_ID = F.REFERENCED_OBJECT_ID AND O2.OBJECT_ID = F.PARENT_OBJECT_ID AND C1.OBJECT_ID = F.REFERENCED_OBJECT_ID AND C2.OBJECT_ID = F.PARENT_OBJECT_ID AND C1.COLUMN_ID = K.REFERENCED_COLUMN_ID AND C2.COLUMN_ID = K.PARENT_COLUMN_ID AND O1.NAME = @dbTableName OPEN FK_Counter_Cursor; FETCH NEXT FROM FK_Counter_Cursor INTO @PKTABLE_QUALIFIER, @PKTABLE_OWNER, @PKTABLE_NAME, @PKCOLUMN_NAME, @FKTABLE_QUALIFIER, @FKTABLE_OWNER, @FKTABLE_NAME, @FKCOLUMN_NAME, @UPDATE_RULE, @DELETE_RULE, @FK_NAME, @PK_NAME, @DEFERRABILITY; WHILE @@FETCH_STATUS = 0 BEGIN SET @SQL = EXECUTE sp_executesql @SQL, N INSERT INTO FETCH NEXT FROM FK_Counter_Cursor INTO @PKTABLE_QUALIFIER, @PKTABLE_OWNER, @PKTABLE_NAME, @PKCOLUMN_NAME, @FKTABLE_QUALIFIER, @FKTABLE_OWNER, @FKTABLE_NAME, @FKCOLUMN_NAME, @UPDATE_RULE, @DELETE_RULE, @FK_NAME, @PK_NAME, @DEFERRABILITY; END; CLOSE FK_Counter_Cursor; DEALLOCATE FK_Counter_Cursor; GO SELECT * FROM GO
--Eliminar las llaves foraneas declare @query varchar(8000) declare cursorRecorrerTabla cursor for SELECT FROM PoaComFinH.sys.foreign_key_columns fk JOIN PoaComFinH.sys.tables referencingTable ON fk.parent_object_id = referencingTable.object_id JOIN PoaComFinH.sys.schemas sch ON referencingTable.schema_id = sch.schema_id JOIN PoaComFinH.sys.objects foreignKey ON foreignKey.object_id = fk.constraint_object_id JOIN PoaComFinH.sys.tables referencedTable ON fk.referenced_object_id = referencedTable.object_id --3ro. abrir el cursor. open cursorRecorrerTabla fetch next from cursorRecorrerTabla into @query while @@fetch_status = 0 begin --inicio cuerpo del cursor print @query exec(@query) --fin cuerpo del cursor fetch next from cursorRecorrerTabla into @query end --cerrar cursor close cursorRecorrerTabla deallocate cursorRecorrerTabla
declare @tablename as varchar(MAX) SET @tablename = SELECT name FROM YOURDATABASE.sys.objects WHERE type_desc =
SELECT name FROM YOURDATABASE_PROD.sys.objects WHERE type_desc = name NOT LIKE
SELECT * INTO FROM YourTable ALTER TABLE DROP COLUMN ColumnToDrop SELECT * FROM DROP TABLE
declare @cols varchar(max), @query varchar(max); SELECT @cols = STUFF ( ( SELECT DISTINCT FROM sys.columns where object_id = ( select top 1 object_id from sys.objects where name = ) and name not in ( FOR XML PATH( ), 1, 2, ) + SELECT @query = EXEC (@query);
CREATE TABLE contact (contactid int, name varchar(100), dob datetime) INSERT INTO contact SELECT 1, DECLARE @columns varchar(8000) SELECT @columns = ISNULL(@columns + FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ORDER BY ORDINAL_POSITION EXEC (
DECLARE @SQL VARCHAR(max), @TableName sysname = SELECT @SQL = COALESCE(@SQL + FROM sys.columns WHERE OBJECT_ID = OBJECT_ID(@TableName) AND name NOT IN ( SELECT @SQL = EXEC (@SQL)
CREATE PROCEDURE [usp_select_without] @schema_name sysname = N @table_name sysname, @list_of_columns_excluded nvarchar(max), @separator nchar(1) = N AS BEGIN DECLARE @SQL nvarchar(max), @full_table_name nvarchar(max) = CONCAT(@schema_name, N SELECT @SQL = COALESCE(@SQL + FROM sys.columns sc LEFT JOIN STRING_SPLIT(@list_of_columns_excluded, @separator) ss ON sc.[name] = ss.[value] WHERE sc.OBJECT_ID = OBJECT_ID(@full_table_name, N AND ss.[value] IS NULL; SELECT @SQL = N EXEC(@SQL) END
EXEC [usp_select_without] @table_name = N @list_of_columns_excluded = N
SELECT LISTAGG((column_name), INTO var_list_of_columns FROM ALL_TAB_COLUMNS WHERE table_name = AND column_name NOT IN (
example mysql> SELECT * FROM calls; +----+------------+---------+ | id | date | user_id | +----+------------+---------+ | 1 | 2016-06-22 | 1 | | 2 | 2016-06-22 | NULL | | 3 | 2016-06-22 | NULL | | 4 | 2016-06-23 | 2 | | 5 | 2016-06-23 | 1 | | 6 | 2016-06-23 | 1 | | 7 | 2016-06-23 | NULL | +----+------------+---------+ 7 rows in set (0.06 sec) mysql> CREATE VIEW C_VIEW AS -> SELECT id,date from calls; Query OK, 0 rows affected (0.20 sec) mysql> select * from C_VIEW; +----+------------+ | id | date | +----+------------+ | 1 | 2016-06-22 | | 2 | 2016-06-22 | | 3 | 2016-06-22 | | 4 | 2016-06-23 | | 5 | 2016-06-23 | | 6 | 2016-06-23 | | 7 | 2016-06-23 | +----+------------+ 7 rows in set (0.00 sec)
declare @colnames varchar(max)= select @colnames=@colnames+ SET @colnames=RIGHT(@colnames,LEN(@colnames)-1)
Dim da As New SqlDataAdapter("select * from table", cn) da.FillSchema(dt, SchemaType.Source) Dim fieldlist As String = "" For Each DC As DataColumn In DT.Columns If DC.ColumnName.ToLower <> excludefield Then fieldlist = fieldlist & DC.Columnname & "," End If Next
$i=0; $row_array = array(); while($row = mysqli_fetch_assoc($result)){ $row_array[$i]=$row; unset($row_array[$i][ $i++; }
SET @dyn_colums = (SELECT REPLACE( GROUP_CONCAT(`COLUMN_NAME`), FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE `TABLE_SCHEMA`= SET @sql = CONCAT("SELECT ", @dyn_colums, " FROM table_name"); PREPARE statement FROM @sql; EXECUTE statement;
select im.itemid ,im.sku as iSku ,gm.SKU as GSKU ,mm.ManufacturerId as ManuId ,mm.ManufacturerName ,im.mf_item_number ,mm.ManufacturerID from item_master im, group_master gm, Manufacturer_Master mm where im.mf_item_number like and im.sku=gm.sku and gm.ManufacturerID = mm.ManufacturerID and gm.manufacturerID=34
UPDATE im SET mf_item_number = gm.SKU --etc FROM item_master im JOIN group_master gm ON im.sku = gm.sku JOIN Manufacturer_Master mm ON gm.ManufacturerID = mm.ManufacturerID WHERE im.mf_item_number like gm.manufacturerID = 34
UPDATE A SET foo = B.bar FROM TableA A JOIN TableB B ON A.col1 = B.colx WHERE ...
with cte as ( select im.itemid ,im.sku as iSku ,gm.SKU as GSKU ,mm.ManufacturerId as ManuId ,mm.ManufacturerName ,im.mf_item_number ,mm.ManufacturerID , <your other field> from item_master im, group_master gm, Manufacturer_Master mm where im.mf_item_number like and im.sku=gm.sku and gm.ManufacturerID = mm.ManufacturerID and gm.manufacturerID=34) update cte set mf_item_number = <your other field>
UPDATE item_master im JOIN group_master gm ON im.sku=gm.sku JOIN Manufacturer_Master mm ON gm.ManufacturerID=mm.ManufacturerID SET im.mf_item_number = gm.SKU --etc WHERE im.mf_item_number like AND gm.manufacturerID=34
UPDATE p SET p.category = c.category FROM products p INNER JOIN prodductcatagories pg ON p.productid = pg.productid INNER JOIN categories c ON pg.categoryid = c.cateogryid WHERE c.categories LIKE
update item_master set mf_item_number = (some value) from group_master as gm join Manufacturar_Master as mm ON ........ where .... (your conditions here)
MySQL: In general, make necessary changes par your requirement: UPDATE shopping_cart sc LEFT JOIN package pc ON sc. package_id = pc.id SET sc. amount = pc.amount
Update t1.Column1 = value from tbltemp as t1 inner join tblUser as t2 on t2.ID = t1.UserID where t1.[column1]=value and t2.[Column1] = value;
USE tempdb; GO IF(OBJECT_ID( IF(OBJECT_ID( CREATE TABLE dbo.Target ( EmployeeID INT , EmployeeName VARCHAR(100) , CONSTRAINT Target_PK PRIMARY KEY ( EmployeeID ) ); CREATE TABLE dbo.Source ( EmployeeID INT , EmployeeName VARCHAR(100) , CONSTRAINT Source_PK PRIMARY KEY ( EmployeeID ) ); GO INSERT dbo.Target ( EmployeeID, EmployeeName ) VALUES ( 100, INSERT dbo.Target ( EmployeeID, EmployeeName ) VALUES ( 101, INSERT dbo.Target ( EmployeeID, EmployeeName ) VALUES ( 102, GO INSERT dbo.Source ( EmployeeID, EmployeeName ) VALUES ( 100, INSERT dbo.Source ( EmployeeID, EmployeeName ) VALUES ( 104, GO SELECT * FROM dbo.Source SELECT * FROM dbo.Target MERGE Target AS T USING Source AS S ON ( T.EmployeeID = S.EmployeeID ) WHEN MATCHED THEN UPDATE SET T.EmployeeName = S.EmployeeName + GO SELECT SELECT * FROM dbo.Source SELECT * FROM dbo.Target
UPDATE im SET mf_item_number = (some value) FROM item_master im JOIN group_master gm ON im.sku = gm.sku JOIN Manufacturer_Master mm ON gm.ManufacturerID = mm.ManufacturerID WHERE im.mf_item_number like gm.manufacturerID = 34 `sql`
SELECT * FROM Northwind.INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N
SELECT * FROM sys.columns WHERE object_id = OBJECT_ID(
SELECT o.Name, c.Name FROM sys.columns c JOIN sys.objects o ON o.object_id = c.object_id WHERE o.type = ORDER BY o.Name, c.Name
select * from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME=
select Column_name from Information_schema.columns where Table_name like
SELECT o.Name as Table_Name , c.Name as Field_Name , t.Name as Data_Type , t.length as Length_Size , t.prec as Precision_ FROM syscolumns c INNER JOIN sysobjects o ON o.id = c.id LEFT JOIN systypes t on t.xtype = c.xtype WHERE o.type = ORDER BY o.Name, c.Name
SELECT name FROM sys.columns WHERE object_id = OBJECT_ID(
SELECT column_name, data_type, character_maximum_length, table_name,ordinal_position, is_nullable FROM information_schema.COLUMNS WHERE table_name LIKE ORDER BY ordinal_position
-- List down all columns of table select * from sys.all_columns where object_id = OBJECT_ID(
SELECT T.TABLE_NAME AS C.COLUMN_NAME AS FROM INFORMATION_SCHEMA.TABLES T INNER JOIN INFORMATION_SCHEMA.COLUMNS C ON T.TABLE_NAME=C.TABLE_NAME WHERE T.TABLE_TYPE= AND T.TABLE_NAME LIKE
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME like N
SELECT c.Name FROM sys.columns c JOIN sys.objects o ON o.object_id = c.object_id WHERE o.object_id = OBJECT_ID( ORDER BY c.Name
SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =
SELECT [name] FROM sys.columns WHERE object_id = OBJECT_ID(
CREATE TABLE People ( Id INT CONSTRAINT PK_MyTable PRIMARY KEY IDENTITY, Name NVARCHAR(250) NOT NULL, LibraryCardId UNIQUEIDENTIFIER NULL, CONSTRAINT UQ_People_LibraryCardId UNIQUE (LibraryCardId) )
-- This works fine: INSERT INTO People (Name, LibraryCardId) VALUES ( -- This also works fine, obviously: INSERT INTO People (Name, LibraryCardId) VALUES ( -- This would *correctly* fail: --INSERT INTO People (Name, LibraryCardId) --VALUES ( -- This works fine this one first time: INSERT INTO People (Name, LibraryCardId) VALUES ( -- THE PROBLEM: This fails even though I INSERT INTO People (Name, LibraryCardId) VALUES (
CREATE UNIQUE NONCLUSTERED INDEX idx_yourcolumn_notnull ON YourTable(yourcolumn) WHERE yourcolumn IS NOT NULL;
CREATE UNIQUE NONCLUSTERED INDEX UQ_Party_SamAccountName ON dbo.Party(SamAccountName) WHERE SamAccountName IS NOT NULL;
ALTER TABLE dbo.Party ADD SamAccountNameUnique AS (Coalesce(SamAccountName, Convert(varchar(11), PartyID))) ALTER TABLE dbo.Party ADD CONSTRAINT UQ_Party_SamAccountName UNIQUE (SamAccountNameUnique)
ALTER TABLE dbo.Issue ADD TicketUnique AS (CASE WHEN TicketID IS NULL THEN IssueID END); ALTER TABLE dbo.Issue ADD CONSTRAINT UQ_Issue_Ticket_AllowNull UNIQUE (TicketID, TicketUnique);
CREATE UNIQUE NONCLUSTERED INDEX idx_badgeid_notnull ON employee(badgeid) WHERE badgeid IS NOT NULL;
CREATE VIEW myview AS SELECT * FROM mytable WHERE mycolumn IS NOT NULL CREATE UNIQUE INDEX ux_myview_mycolumn ON myview (mycolumn)
CREATE TRIGGER trg_mytable_insert ON mytable INSTEAD OF INSERT AS BEGIN INSERT INTO myview SELECT * FROM inserted END
CREATE VIEW dbo.VIEW_OfYourTable WITH SCHEMABINDING AS SELECT YourUniqueColumnWithNullValues FROM dbo.YourTable WHERE YourUniqueColumnWithNullValues IS NOT NULL;
CREATE UNIQUE CLUSTERED INDEX UIX_VIEW_OFYOURTABLE ON dbo.VIEW_OfYourTable(YourUniqueColumnWithNullValues)
CREATE TABLE [Orders] ( [OrderId] INT IDENTITY(1,1) NOT NULL, [TrackingId] varchar(11) NULL, ... [ComputedUniqueTrackingId] AS ( CASE WHEN [TrackingId] IS NULL THEN ELSE [TrackingId_Unique] END ), CONSTRAINT [UQ_TrackingId] UNIQUE ([ComputedUniqueTrackingId]) )
CREATE TRIGGER PONY.trg_pony_unique_name ON PONY.tbl_pony INSTEAD OF INSERT, UPDATE AS BEGIN IF EXISTS( SELECT TOP (1) 1 FROM inserted i GROUP BY i.pony_name HAVING COUNT(1) > 1 ) OR EXISTS( SELECT TOP (1) 1 FROM PONY.tbl_pony t INNER JOIN inserted i ON i.pony_name = t.pony_name ) THROW 911911, ELSE INSERT INTO PONY.tbl_pony (pony_name, stable_id, pet_human_id) SELECT pony_name, stable_id, pet_human_id FROM inserted END
CREATE TRIGGER [dbo].[OnInsertMyTableTrigger] ON [dbo].[MyTable] INSTEAD OF INSERT AS BEGIN SET NOCOUNT ON; DECLARE @Column1 INT; DECLARE @Column2 INT; -- allow nulls on this column SELECT @Column1=Column1, @Column2=Column2 FROM inserted; -- Check if an existing record already exists, if not allow the insert. IF NOT EXISTS(SELECT * FROM dbo.MyTable WHERE Column1=@Column1 AND Column2=@Column2 @Column2 IS NOT NULL) BEGIN INSERT INTO dbo.MyTable (Column1, Column2) SELECT @Column2, @Column2; END ELSE BEGIN RAISERROR( ROLLBACK TRANSACTION; END END
CREATE UNIQUE NONCLUSTERED INDEX [UIX_COLUMN_NAME] ON [dbo].[Employee]([Username] ASC) WHERE ([Username] IS NOT NULL) WITH (ALLOW_PAGE_LOCKS = ON, ALLOW_ROW_LOCKS = ON, PAD_INDEX = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, IGNORE_DUP_KEY = OFF, STATISTICS_NORECOMPUTE = OFF, ONLINE = OFF, MAXDOP = 0) ON [PRIMARY];
CREATE UNIQUE NONCLUSTERED INDEX [IX_tableName_Column] ON [dbo].[tableName]([columnName] ASC) WHERE [columnName] !=`
CASE ebv.db_no WHEN 22978 OR 23218 OR 23219 THEN ELSE END as wecs_system
CASE ebv.db_no WHEN 22978 THEN WHEN 23218 THEN WHEN 23219 THEN ELSE END as wecs_system
CASE WHEN ebv.db_no IN (22978, 23218, 23219) THEN ELSE END as wecs_system
CASE WHEN ebv.db_no = 22978 OR ebv.db_no = 23218 OR ebv.db_no = 23219 THEN ELSE END as wecs_system
CASE WHEN ebv.db_no IN (22978, 23218, 23219) THEN ELSE END as wecs_system
CASE WHEN ListPrice = 0 THEN WHEN ListPrice < 50 THEN WHEN ListPrice >= 50 and ListPrice < 250 THEN WHEN ListPrice >= 250 and ListPrice < 1000 THEN ELSE END
CASE expression WHEN expression1 THEN Result1 WHEN expression2 THEN Result2 ELSE ResultN END
CASE WHEN Boolean_expression1 THEN Result1 WHEN Boolean_expression2 THEN Result2 ELSE ResultN END
--Simple CASE expression: SELECT FirstName, State=(CASE StateCode WHEN WHEN WHEN ELSE NULL END), PayRate FROM dbo.Customer -- Searched CASE expression: SELECT FirstName,State=(CASE WHEN StateCode = WHEN StateCode = WHEN StateCode = ELSE NULL END), PayRate FROM dbo.Customer
-- Simple CASE expression: UPDATE Customer SET StateCode = CASE StateCode WHEN WHEN WHEN ELSE NULL END -- Simple CASE expression: UPDATE Customer SET StateCode = CASE WHEN StateCode = WHEN StateCode = WHEN StateCode = ELSE NULL END
-- Simple CASE expression: SELECT * FROM dbo.Customer ORDER BY CASE Gender WHEN CASE Gender WHEN -- Searched CASE expression: SELECT * FROM dbo.Customer ORDER BY CASE WHEN Gender= CASE WHEN Gender=
-- Simple CASE expression: SELECT FirstName ,StateCode,Gender, Total=MAX(PayRate) FROM dbo.Customer GROUP BY StateCode,Gender,FirstName HAVING (MAX(CASE Gender WHEN THEN PayRate ELSE NULL END) > 180.00 OR MAX(CASE Gender WHEN THEN PayRate ELSE NULL END) > 170.00) -- Searched CASE expression: SELECT FirstName ,StateCode,Gender, Total=MAX(PayRate) FROM dbo.Customer GROUP BY StateCode,Gender,FirstName HAVING (MAX(CASE WHEN Gender = THEN PayRate ELSE NULL END) > 180.00 OR MAX(CASE WHEN Gender = THEN PayRate ELSE NULL END) > 170.00)
SELECT Store_Name, CASE Store_Name WHEN WHEN ELSE Sales END AS "New Sales", Txn_Date FROM Store_Information;
UPDATE table_name SET column_name=CASE WHEN column_name in ( THEN WHEN column_name in ( THEN END
select id,phno,case gender when when else end as gender from contacts
Select s.stock_code,s.stock_desc,s.stock_desc_ar, mc.category_name,s.sel_price, case when s.allow_discount=0 then item From tbl_stock s inner join tbl_stock_category c on s.stock_id=c.stock_id inner join tbl_category mc on c.category_id=mc.category_id where mc.category_id=2 and s.isSerialBased=0
INSERT INTO dbo.MyTable (ID, Name) VALUES (123, (124, (125,
DECLARE @blah TABLE ( ID INT NOT NULL PRIMARY KEY, Name VARCHAR(100) NOT NULL ) INSERT INTO @blah (ID, Name) VALUES (123, VALUES (124, VALUES (125, SELECT * FROM @blah
INSERT INTO dbo.MyTable (ID, Name) SELECT 123, UNION ALL SELECT 124, UNION ALL SELECT 125,
CREATE TABLE MyTable (id int, name char(10)); INSERT INTO MyTable (id, name) VALUES (1, SELECT * FROM MyTable; id | name ---+--------- 1 | Bob 2 | Peter 3 | Joe
INSERT INTO MyTable(ID, Name) SELECT ID, NAME FROM OtherTable
INSERT INTO dbo.Mytable(ID, Name) SELECT ID, Name FROM ( VALUES (1, (2, --... -- more than 1000 rows )sub (ID, Name);
INSERT INTO dbo.MyTable (ID, Name) select * from ( select 123, union all select 124, union all select 125, ... ) x
INSERT INTO dbo.MyTable (ID, Name) SELECT ID, Name FROM ( SELECT 123, UNION ALL SELECT 124, UNION ALL SELECT 125, ) AS X (ID, Name)
INSERT INTO dbo.MyTable (ID, Name) VALUES (123, VALUES (124, VALUES (125,
INSERT INTO dbo.MyTable (ID, Name) VALUES (123, INSERT INTO dbo.MyTable (ID, Name) VALUES (124, INSERT INTO dbo.MyTable (ID, Name) VALUES (125,
declare @test nvarchar(max) set @test = <comment>comment 1</comment> </dialog> <dialog id="2" answerId="42" > <comment>comment 2</comment> </dialog> <dialog id="3" answerId="43" > <comment>comment 3</comment> </dialog> </topic>' declare @testxml xml set @testxml = cast(@test as xml) declare @answerTemp Table(dialogid int, answerid int, comment varchar(1000)) insert @answerTemp SELECT ParamValues.ID.value( ParamValues.ID.value( ParamValues.ID.value( FROM @testxml.nodes(
USE YourDB GO INSERT INTO MyTable (FirstCol, SecondCol) SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT GO
INSERT INTO MyTable (FirstCol, SecondCol) VALUES ( ( ( ( (
INSERT INTO [TableName] (ID, Name) values (NEWID(), NEWID()) GO 10
CREATE TABLE [dbo].[Sample]( [a] [int] NULL, [b] [int] NULL, [c] [varchar](50) COLLATE SQL_Latin1_General_CP1_CI_AS NULL, [D] [int] NULL )
DECLARE @LIST VARCHAR(MAX) SET @LIST= SELECT 2,2, SELECT 3,3, SELECT 4,4, INSERT SAMPLE (a, b, c,d) EXEC(@LIST)
DataTable dt = new DataTable(); dt.Columns.Add("a"); dt.Columns.Add("b"); dt.Columns.Add("c"); dt.Columns.Add("d"); for (int i = 0; i < 10; i++) { DataRow dr = dt.NewRow(); dr["a"] = 1; dr["b"] = 2; dr["c"] = "Charan"; dr["d"] = 4; dt.Rows.Add(dr); } SqlConnection con = new SqlConnection("Connection String"); using (SqlBulkCopy bulkcopy = new SqlBulkCopy(con)) { con.Open(); bulkcopy.DestinationTableName = "Sample"; bulkcopy.WriteToServer(dt); con.Close(); }
INSERT INTO table1 (ID, Name) VALUES (123, (124, (125,
INSERT INTO table1 (ID, Name) SELECT ID, Name FROM table2
INSERT INTO table1 (column2, column3) SELECT t2.column, t3.column FROM table2 t2 INNER JOIN table3 t3 ON t2.ID = t3.ID
DELETE FROM TableA FROM TableA a INNER JOIN TableB b ON b.BId = a.BId AND [my filter condition]
DELETE FROM TableA WHERE BId IN (SELECT BId FROM TableB WHERE [my filter condition])
DELETE TableA FROM TableA a INNER JOIN TableB b ON b.Bid = a.Bid AND [my filter condition]
Delete a from TableA a Inner Join TableB b on a.BId = b.BId WHERE [filter condition]
DELETE TableA FROM TableA AS a INNER JOIN TableB AS b ON a.BId = b.BId WHERE [filter condition]
DELETE a.* FROM TableA AS a INNER JOIN TableB AS b ON a.BId = b.BId WHERE [filter condition]
DELETE a FROM TableA AS a INNER JOIN TableB AS b ON a.BId = b.BId WHERE [filter condition]
DELETE FROM TableA a WHERE [filter condition on TableA] AND (a.BId IN (SELECT a.BId FROM TableB b JOIN TableA a ON a.BId = b.BId WHERE [filter condition on TableB]))
DELETE TableA FROM TableA a INNER JOIN TableB b on b.Bid = a.Bid AND [condition]
Declare @TableA Table ( aId INT, aName VARCHAR(50), bId INT ) Declare @TableB Table ( bId INT, bName VARCHAR(50) ) Declare @TableC Table ( cId INT, cName VARCHAR(50), dId INT ) Declare @TableD Table ( dId INT, dName VARCHAR(50) ) DECLARE @StartTime DATETIME; SELECT @startTime = GETDATE(); DECLARE @i INT; SET @i = 1; WHILE @i < 1000000 BEGIN INSERT INTO @TableB VALUES(@i, INSERT INTO @TableA VALUES(@i+5, SET @i = @i + 1; END SELECT @startTime = GETDATE() DELETE a --SELECT * FROM @TableA a Inner Join @TableB b ON a.BId = b.BId WHERE a.aName LIKE SELECT Duration = DATEDIFF(ms,@StartTime,GETDATE()) SET @i = 1; WHILE @i < 1000000 BEGIN INSERT INTO @TableD VALUES(@i, INSERT INTO @TableC VALUES(@i+5, SET @i = @i + 1; END SELECT @startTime = GETDATE() DELETE c --SELECT * FROM @TableC c Inner Join @TableD d ON c.DId = d.DId AND c.cName LIKE SELECT Duration = DATEDIFF(ms,@StartTime,GETDATE())
delete from Dependents where EmpID in ( select d.EmpID from Employees e right join Dependents d on e.EmpID = d.EmpID where e.EmpID is null)
Delete from TableA from TableA a, TableB b where a.Bid=b.Bid AND [my filter condition]
DELETE TableA FROM TableB WHERE TableA.ID = TableB.ID
a) select DATEADD(dd, DATEDIFF(dd, 0, getdate()), 0)
b) select cast(convert(char(11), getdate(), 113) as datetime)
a) select DATEADD(dd, DATEDIFF(dd, 0, getdate()), 0)
DECLARE @datetime2value datetime2 = DECLARE @datetime2epoch datetime2 = select DATEADD(dd, DATEDIFF(dd, @datetime2epoch, @datetime2value), @datetime2epoch)
SELECT CAST(FLOOR(CAST(getdate() AS FLOAT)) AS DATETIME)
SELECT CAST(CAST(getutcdate() - 0.50000004 AS int) AS datetime)
DATEADD MAGIC FLOAT 500 453 453 360 375 375 406 360
CAST( FLOOR( CAST( GETDATE() AS FLOAT ) ) AS DATETIME )
CAST(round(cast(getdate()as real),0,1) AS datetime)
SELECT CONVERT(DATETIME, FLOOR(CONVERT(FLOAT,GETDATE())));
create function dateonly ( @dt datetime ) returns datetime as begin return cast(floor(cast(@dt as float))as int) end
select convert(datetime,convert(int,convert(float,[Modified])))
select convert(datetime,ROUND(convert(float,[Modified]),0))
[Microsoft.SqlServer.Server.SqlFunction] public static SqlDateTime DateOnly(SqlDateTime input) { if (!input.IsNull) { SqlDateTime dt = new SqlDateTime(input.Value.Year, input.Value.Month, input.Value.Day, 0, 0, 0); return dt; } else return SqlDateTime.Null; }
Declare @products varchar(200) = Declare @individual varchar(20) = null WHILE LEN(@products) > 0 BEGIN IF PATINDEX( BEGIN SET @individual = SUBSTRING(@products, 0, PATINDEX( SELECT @individual SET @products = SUBSTRING(@products, LEN(@individual + LEN(@products)) END ELSE BEGIN SET @individual = @products SET @products = NULL SELECT @individual END END
create function dbo.SplitString ( @str nvarchar(4000), @separator char(1) ) returns table AS return ( with tokens(p, a, b) AS ( select 1, 1, charindex(@separator, @str) union all select p + 1, b + 1, charindex(@separator, @str, b + 1) from tokens where b > 0 ) select p-1 zeroBasedOccurance, substring( @str, a, case when b > 0 then b-a ELSE 4000 end) AS s from tokens ) GO
select s from dbo.SplitString( where zeroBasedOccurance=1
create function dbo.SplitString ( @str nvarchar(max), @separator char(1) ) returns table AS return ( with tokens(p, a, b) AS ( select cast(1 as bigint), cast(1 as bigint), charindex(@separator, @str) union all select p + 1, b + 1, charindex(@separator, @str, b + 1) from tokens where b > 0 ) select p-1 ItemIndex, substring( @str, a, case when b > 0 then b-a ELSE LEN(@str) end) AS s from tokens ); GO
CREATE FUNCTION [dbo].[SplitString] ( @List NVARCHAR(MAX), @Delim VARCHAR(255) ) RETURNS TABLE AS RETURN ( SELECT [Value] FROM ( SELECT [Value] = LTRIM(RTRIM(SUBSTRING(@List, [Number], CHARINDEX(@Delim, @List + @Delim, [Number]) - [Number]))) FROM (SELECT Number = ROW_NUMBER() OVER (ORDER BY name) FROM sys.all_objects) AS x WHERE Number <= LEN(@List) AND SUBSTRING(@Delim + @List, [Number], LEN(@Delim)) = @Delim ) AS y );
create table dbo.Numbers (N int primary key); insert into dbo.Numbers select top 1000 row_number() over(order by number) from master..spt_values go
create function [dbo].[ufn_ParseArray] ( @Input nvarchar(4000), @Delimiter char(1) = @BaseIdent int ) returns table as return ( select row_number() over (order by n asc) + (@BaseIdent - 1) [i], substring(@Input, n, charindex(@Delimiter, @Input + @Delimiter, n) - n) s from dbo.Numbers where n <= convert(int, len(@Input)) and substring(@Delimiter + @Input, n, 1) = @Delimiter ) go
select * from cross apply dbo.ufn_ParseArray(array,
drop table dbo.Numbers; drop function [dbo].[ufn_ParseArray]
CREATE FUNCTION SplitString ( -- Add the parameters for the function here @myString varchar(500), @deliminator varchar(10) ) RETURNS @ReturnTable TABLE ( -- Add the column definitions for the TABLE variable here [id] [int] IDENTITY(1,1) NOT NULL, [part] [varchar](50) NULL ) AS BEGIN Declare @iSpaces int Declare @part varchar(50) --initialize spaces Select @iSpaces = charindex(@deliminator,@myString,0) While @iSpaces > 0 Begin Select @part = substring(@myString,0,charindex(@deliminator,@myString,0)) Insert Into @ReturnTable(part) Select @part Select @myString = substring(@mystring,charindex(@deliminator,@myString,0)+ len(@deliminator),len(@myString) - charindex( Select @iSpaces = charindex(@deliminator,@myString,0) end If len(@myString) > 0 Insert Into @ReturnTable Select @myString RETURN END GO
CREATE FUNCTION [dbo].[split]( @delimited NVARCHAR(MAX), @delimiter NVARCHAR(100) ) RETURNS @t TABLE (id INT IDENTITY(1,1), val NVARCHAR(MAX)) AS BEGIN DECLARE @xml XML SET @xml = N INSERT INTO @t(val) SELECT r.value( FROM @xml.nodes( RETURN END
DECLARE @dlmt NVARCHAR(10)=N DECLARE @pos INT = 2; SELECT CAST(N
DECLARE @str VARCHAR(100)= SELECT [value] FROM OPENJSON( WHERE [key]=1 --zero-based!
using System; using System.Data; using System.Data.SqlClient; using System.Data.SqlTypes; using Microsoft.SqlServer.Server; using System.Collections.Generic; public partial class UserDefinedFunctions { [SqlFunction] public static SqlString SearchString(string Search) { List<string> SearchWords = new List<string>(); foreach (string s in Search.Split(new char[] { if (!s.ToLower().Equals("or") && !s.ToLower().Equals("and")) { SearchWords.Add(s); } } return new SqlString(string.Join(" OR ", SearchWords.ToArray())); } };
DECLARE @str varchar(max) SET @str = DECLARE @separator varchar(max) SET @separator = DECLARE @Splited TABLE(id int IDENTITY(1,1), item varchar(max)) SET @str = REPLACE(@str, @separator, SET @str = INSERT INTO @Splited EXEC(@str) SELECT * FROM @Splited
sys.message.1234.warning.A45 sys.message.1235.error.O98 ....
SELECT Source = q.value( RecordType = q.value( RecordNumber = q.value( Status = q.value( FROM ( SELECT q = Convert(xml, FROM some_TABLE ) Q
DECLARE @str varchar(max) SET @str = DECLARE @separator varchar(max) SET @separator = DECLARE @Splited table(id int IDENTITY(1,1), item varchar(max)) SET @str = REPLACE(@str, @separator, SET @str = INSERT INTO @Splited EXEC(@str) SELECT * FROM @Splited
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE FUNCTION [dbo].[Split](@String VARCHAR(8000), @Delimiter CHAR(1)) RETURNS @temptable TABLE (items VARCHAR(8000)) AS BEGIN DECLARE @idx INT DECLARE @slice VARCHAR(8000) SELECT @idx = 1 IF len(@String)<1 OR @String IS NULL RETURN WHILE @idx!= 0 BEGIN SET @idx = charindex(@Delimiter,@String) IF @idx!=0 SET @slice = LEFT(@String,@idx - 1) ELSE SET @slice = @String IF(len(@slice)>0) INSERT INTO @temptable(Items) VALUES(@slice) SET @String = RIGHT(@String,len(@String) - @idx) IF len(@String) = 0 break END RETURN END
create function GetStringPartByDelimeter ( @value as nvarchar(max), @delimeter as nvarchar(max), @position as int ) returns NVARCHAR(MAX) AS BEGIN declare @startPos as int declare @endPos as int set @endPos = -1 while (@position > 0 and @endPos != 0) begin set @startPos = @endPos + 1 set @endPos = charindex(@delimeter, @value, @startPos) if(@position = 1) begin if(@endPos = 0) set @endPos = len(@value) + 1 return substring(@value, @startPos, @endPos - @startPos) end set @position = @position - 1 end return null end
SELECT value FROM STRING_SPLIT( ORDER BY (SELECT NULL) OFFSET N ROWS FETCH NEXT 1 ROWS ONLY
SELECT compatibility_level FROM sys.databases WHERE name =
CREATE function [SplitWordList] ( @list varchar(8000) ) returns @t table ( Word varchar(50) not null, Position int identity(1,1) not null ) as begin declare @pos int, @lpos int, @item varchar(100), @ignore varchar(100), @dl int, @a1 int, @a2 int, @z1 int, @z2 int, @n1 int, @n2 int, @c varchar(1), @a smallint select @a1 = ascii( @a2 = ascii( @z1 = ascii( @z2 = ascii( @n1 = ascii( @n2 = ascii( set @ignore = set @pos = 1 set @dl = datalength(@list) set @lpos = 1 set @item = while (@pos <= @dl) begin set @c = substring(@list, @pos, 1) if (@ignore not like set @a = ascii(@c) if ((@a >= @a1) and (@a <= @z1)) or ((@a >= @a2) and (@a <= @z2)) or ((@a >= @n1) and (@a <= @n2)) begin set @item = @item + @c end else if (@item > insert into @t values (@item) set @item = end end set @pos = @pos + 1 end if (@item > insert into @t values (@item) end return end
CREATE FUNCTION dbo.SplitStrings_CTE(@List nvarchar(max), @Delimiter nvarchar(1)) RETURNS @returns TABLE (val nvarchar(max), [level] int, PRIMARY KEY CLUSTERED([level])) AS BEGIN ;WITH cte AS ( SELECT SUBSTRING(@List, 0, CHARINDEX(@Delimiter, @List + @Delimiter)) AS val, CAST(STUFF(@List + @Delimiter, 1, CHARINDEX(@Delimiter, @List + @Delimiter), 1 AS [level] UNION ALL SELECT SUBSTRING(stval, 0, CHARINDEX(@Delimiter, stval)), CAST(STUFF(stval, 1, CHARINDEX(@Delimiter, stval), [level] + 1 FROM cte WHERE stval != ) INSERT @returns SELECT REPLACE(val, FROM cte WHERE val > RETURN END
Alter Function dbo.fn_Split ( @Expression nvarchar(max), @Delimiter nvarchar(20) = @Qualifier char(1) = Null ) RETURNS @Results TABLE (id int IDENTITY(1,1), value nvarchar(max)) AS BEGIN /* USAGE Select * From dbo.fn_Split( Select * From dbo.fn_Split( Select * From dbo.fn_Split( */ -- Declare Variables DECLARE @X xml, @Temp nvarchar(max), @Temp2 nvarchar(max), @Start int, @End int -- HTML Encode @Expression Select @Expression = (Select @Expression For XML Path( -- Find all occurences of @Delimiter within @Qualifier and replace with |||***||| While PATINDEX( BEGIN Select -- Starting character position of @Qualifier @Start = PATINDEX( -- @Expression starting at the @Start position @Temp = SubString(@Expression, @Start + 1, LEN(@Expression)-@Start+1), -- Next position of @Qualifier within @Expression @End = PATINDEX( -- The part of Expression found between the @Qualifiers @Temp2 = Case When @End < 0 Then @Temp Else Left(@Temp, @End) End, -- New @Expression @Expression = REPLACE(@Expression, @Qualifier + @Temp2 + Case When @End < 0 Then Replace(@Temp2, @Delimiter, ) END -- Replace all occurences of @Delimiter within @Expression with -- And convert it to XML so we can select from it SET @X = Cast( Replace(@Expression, @Delimiter, -- Insert into our returnable table replacing INSERT @Results SELECT "Value" = LTRIM(RTrim(Replace(C.value( FROM @X.nodes( -- Return our temp table RETURN END
select SUBSTRING(column_name,1,CHARINDEX( ,SUBSTRING(SUBSTRING(column_name,CHARINDEX( ,1 ,CHARINDEX( ,SUBSTRING(SUBSTRING(column_name,CHARINDEX( ,CHARINDEX( ,LEN(column_name)) from table_name
SET NOCOUNT ON -- You will want to change nvarchar(MAX) to nvarchar(50), varchar(50) or whatever matches exactly with the string column you will be searching against DECLARE @SplitStringTable TABLE (Value nvarchar(MAX) NOT NULL) DECLARE @StringToSplit nvarchar(MAX) = DECLARE @SplitEndPos int DECLARE @SplitValue nvarchar(MAX) DECLARE @SplitDelim nvarchar(1) = DECLARE @SplitStartPos int = 1 SET @SplitEndPos = CHARINDEX(@SplitDelim, @StringToSplit, @SplitStartPos) WHILE @SplitEndPos > 0 BEGIN SET @SplitValue = SUBSTRING(@StringToSplit, @SplitStartPos, (@SplitEndPos - @SplitStartPos)) INSERT @SplitStringTable (Value) VALUES (@SplitValue) SET @SplitStartPos = @SplitEndPos + 1 SET @SplitEndPos = CHARINDEX(@SplitDelim, @StringToSplit, @SplitStartPos) END SET @SplitValue = SUBSTRING(@StringToSplit, @SplitStartPos, 2147483647) INSERT @SplitStringTable (Value) VALUES(@SplitValue) SET NOCOUNT OFF -- You can select or join with the values in @SplitStringTable at this point.
DECLARE @bla varchar(MAX) SET @bla = -- http: SELECT x.XmlCol.value( FROM ( SELECT CAST( ) AS b CROSS APPLY b.RawXml.nodes(
DECLARE @bla NVARCHAR(MAX) SET @bla = -- http: SELECT x.XmlCol.value( FROM ( SELECT CAST( ) AS b CROSS APPLY b.RawXml.nodes(
create function [dbo].[SplitStringToResultSet] (@value varchar(max), @separator char(1)) returns table as return with r as ( select value, cast(null as varchar(max)) [x], -1 [no] from (select rtrim(cast(@value as varchar(max))) [value]) as j union all select right(value, len(value)-case charindex(@separator, value) when 0 then len(value) else charindex(@separator, value) end) [value] , left(r.[value], case charindex(@separator, r.value) when 0 then len(r.value) else abs(charindex(@separator, r.[value])-1) end ) [x] , [no] + 1 [no] from r where value > select ltrim(x) [value], [no] [index] from r where x is not null; go
select * from [dbo].[SplitStringToResultSet]( where [index] = 1;
DECLARE @string varchar(100) = SELECT value FROM string_split(@string,
DECLARE @string varchar(100) = SELECT ROW_NUMBER() OVER (ORDER BY value) AS RowNr, value FROM string_split(@string,
CREATE FUNCTION [dbo].[SplitString] ( @List NVARCHAR(MAX), @Delim VARCHAR(255) ) RETURNS TABLE AS RETURN ( SELECT [Value] FROM ( SELECT [Value] = LTRIM(RTRIM(SUBSTRING(@List, [Number], CHARINDEX(@Delim, @List + @Delim, [Number]) - [Number]))) FROM (SELECT Number = ROW_NUMBER() OVER (ORDER BY name) FROM sys.all_objects) AS x WHERE Number <= LEN(@List) AND SUBSTRING(@Delim + @List, [Number], LEN(@Delim+ ) AS y );
CREATE FUNCTION [dbo].[SplitString] ( @List VARCHAR(MAX), @Delimiter VARCHAR(255), @ElementNumber INT ) RETURNS VARCHAR(MAX) AS BEGIN DECLARE @inp VARCHAR(MAX) SET @inp = (SELECT REPLACE(@List,@Delimiter, DECLARE @xml XML SET @xml = DECLARE @ret VARCHAR(MAX) SET @ret = (SELECT el = split.el.value( FROM @xml.nodes( RETURN @ret END
DECLARE @Name varchar(10) = -- Get First Name SELECT SUBSTRING(@Name, 0, (SELECT CHARINDEX( -- Get Last Name SELECT SUBSTRING(@Name, (SELECT CHARINDEX(
-- i.e. Get First and Last Name from a table of Full Names SELECT SUBSTRING(FullName, 0, (SELECT CHARINDEX( SUBSTRING(FullName, (SELECT CHARINDEX( From FullNameTable
-- Create temporary table to parse the list of accounting cycles. DECLARE @tblAccountingCycles table ( AccountingCycle varchar(10) ) DECLARE @vchAccountingCycle varchar(10) DECLARE @intPosition int SET @vchAccountingCycleIDs = LTRIM(RTRIM(@vchAccountingCycleIDs)) + SET @intPosition = CHARINDEX( IF REPLACE(@vchAccountingCycleIDs, BEGIN WHILE @intPosition > 0 BEGIN SET @vchAccountingCycle = LTRIM(RTRIM(LEFT(@vchAccountingCycleIDs, @intPosition - 1))) IF @vchAccountingCycle <> BEGIN INSERT INTO @tblAccountingCycles (AccountingCycle) VALUES (@vchAccountingCycle) END SET @vchAccountingCycleIDs = RIGHT(@vchAccountingCycleIDs, LEN(@vchAccountingCycleIDs) - @intPosition) SET @intPosition = CHARINDEX( END END
CREATE FUNCTION dbo.SplitStrings_Moden ( @List NVARCHAR(MAX), @Delimiter NVARCHAR(255) ) RETURNS TABLE WITH SCHEMABINDING AS RETURN WITH E1(N) AS ( SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1), E2(N) AS (SELECT 1 FROM E1 a, E1 b), E4(N) AS (SELECT 1 FROM E2 a, E2 b), E42(N) AS (SELECT 1 FROM E4 a, E2 b), cteTally(N) AS (SELECT 0 UNION ALL SELECT TOP (DATALENGTH(ISNULL(@List,1))) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E42), cteStart(N1) AS (SELECT t.N+1 FROM cteTally t WHERE (SUBSTRING(@List,t.N,1) = @Delimiter OR t.N = 0)) SELECT Item = SUBSTRING(@List, s.N1, ISNULL(NULLIF(CHARINDEX(@Delimiter,@List,s.N1),0)-s.N1,8000)) FROM cteStart s;
create FUNCTION dbo.getToken ( @List NVARCHAR(MAX), @Delimiter NVARCHAR(255), @Pos int ) RETURNS varchar(max) as begin declare @returnValue varchar(max); select @returnValue = tbl.Item from ( select ROW_NUMBER() over (order by (select null)) as id, * from dbo.SplitStrings_Moden(@List, @Delimiter) ) as tbl where tbl.id = @Pos return @returnValue end
|ID| DocumentID | Status | DateCreated | | 2| 1 | S1 | 7/29/2011 | | 3| 1 | S2 | 7/30/2011 | | 6| 1 | S1 | 8/02/2011 | | 1| 2 | S1 | 7/28/2011 | | 4| 2 | S2 | 7/30/2011 | | 5| 2 | S3 | 8/01/2011 | | 6| 3 | S1 | 8/02/2011 |
| DocumentID | Status | DateCreated | | 1 | S1 | 8/02/2011 | | 2 | S3 | 8/01/2011 | | 3 | S1 | 8/02/2011 |
SELECT DocumentID, GetOnlyTheTop(Status), GetOnlyTheTop(DateCreated) FROM DocumentStatusLogs GROUP BY DocumentID ORDER BY DateCreated DESC
| DocumentID | Title | Content | DateCreated | | 1 | TitleA | ... | ... | | 2 | TitleB | ... | ... | | 3 | TitleC | ... | ... |
| DocumentID | Title | Content | DateCreated | CurrentStatus | | 1 | TitleA | ... | ... | s1 | | 2 | TitleB | ... | ... | s3 | | 3 | TitleC | ... | ... | s1 |
;WITH cte AS ( SELECT *, ROW_NUMBER() OVER (PARTITION BY DocumentID ORDER BY DateCreated DESC) AS rn FROM DocumentStatusLogs ) SELECT * FROM cte WHERE rn = 1
select d.DocumentID, ds.Status, ds.DateCreated from Documents as d cross apply (select top 1 Status, DateCreated from DocumentStatusLogs where DocumentID = d.DocumentId order by DateCreated desc) as ds
Query Time for 6500 (ms) Time for 137M(ms) CROSS APPLY 17.9 17.9 SELECT WHERE col = (SELECT MAX(COL)…) 6.6 854.4 DENSE_RANK() OVER PARTITION 6.6 907.1
SELECT * FROM DocumentStatusLogs JOIN ( SELECT DocumentID, MAX(DateCreated) DateCreated FROM DocumentStatusLogs GROUP BY DocumentID ) max_date USING (DocumentID, DateCreated)
ON DocumentStatusLogs.DocumentID = max_date.DocumentID AND DocumentStatusLogs.DateCreated = max_date.DateCreated
SELECT * FROM DocumentStatusLogs D WHERE DateCreated = (SELECT MAX(DateCreated) FROM DocumentStatusLogs WHERE ID = D.ID)
select top 1 with ties DocumentID ,Status ,DateCreated from DocumentStatusLogs order by row_number() over (partition by DocumentID order by DateCreated desc)
SELECT [Limit1].[DocumentID] AS [DocumentID], [Limit1].[Status] AS [Status], [Limit1].[DateCreated] AS [DateCreated] FROM (SELECT DISTINCT [Extent1].[DocumentID] AS [DocumentID] FROM [dbo].[DocumentStatusLogs] AS [Extent1]) AS [Distinct1] OUTER APPLY (SELECT TOP (1) [Project2].[ID] AS [ID], [Project2].[DocumentID] AS [DocumentID], [Project2].[Status] AS [Status], [Project2].[DateCreated] AS [DateCreated] FROM (SELECT [Extent2].[ID] AS [ID], [Extent2].[DocumentID] AS [DocumentID], [Extent2].[Status] AS [Status], [Extent2].[DateCreated] AS [DateCreated] FROM [dbo].[DocumentStatusLogs] AS [Extent2] WHERE ([Distinct1].[DocumentID] = [Extent2].[DocumentID]) ) AS [Project2] ORDER BY [Project2].[ID] DESC) AS [Limit1]
select distinct DocumentID , first_value(status) over (partition by DocumentID order by DateCreated Desc) as Status , first_value(DateCreated) over (partition by DocumentID order by DateCreated Desc) as DateCreated From DocumentStatusLogs
SELECT o.* FROM `DocumentStatusLogs` o LEFT JOIN `DocumentStatusLogs` b ON o.DocumentID = b.DocumentID AND o.DateCreated < b.DateCreated WHERE b.DocumentID is NULL ;
IF (OBJECT_ID( CREATE TABLE [ID] int NOT NULL, [DocumentID] int NOT NULL, [Status] varchar(20), [DateCreated] datetime ) INSERT INTO INSERT INTO INSERT INTO INSERT INTO INSERT INTO INSERT INTO INSERT INTO
SELECT [Extent1].[ID], [Extent1].[DocumentID], [Extent1].[Status], [Extent1].[DateCreated] FROM OUTER APPLY ( SELECT TOP 1 [Extent2].[ID], [Extent2].[DocumentID], [Extent2].[Status], [Extent2].[DateCreated] FROM WHERE [Extent1].[DocumentID] = [Extent2].[DocumentID] ORDER BY [Extent2].[DateCreated] DESC, [Extent2].[ID] DESC ) AS [Project2] WHERE ([Project2].[ID] IS NULL OR [Project2].[ID] = [Extent1].[ID])
SELECT [Limit1].[DocumentID] AS [ID], [Limit1].[DocumentID] AS [DocumentID], [Limit1].[Status] AS [Status], [Limit1].[DateCreated] AS [DateCreated] FROM ( SELECT DISTINCT [Extent1].[DocumentID] AS [DocumentID] FROM ) AS [Distinct1] OUTER APPLY ( SELECT TOP (1) [Project2].[ID] AS [ID], [Project2].[DocumentID] AS [DocumentID], [Project2].[Status] AS [Status], [Project2].[DateCreated] AS [DateCreated] FROM ( SELECT [Extent2].[ID] AS [ID], [Extent2].[DocumentID] AS [DocumentID], [Extent2].[Status] AS [Status], [Extent2].[DateCreated] AS [DateCreated] FROM WHERE [Distinct1].[DocumentID] = [Extent2].[DocumentID] ) AS [Project2] ORDER BY [Project2].[ID] DESC ) AS [Limit1]
ID DocumentID Status DateCreated 6 1 S1 8/2/11 3:00 5 2 S3 8/1/11 6:00 6 3 S1 8/2/11 7:00
ID DocumentID Status DateCreated 6 1 S1 8/2/11 3:00 5 2 S3 8/1/11 6:00 6 3 S1 8/2/11 7:00
select ds.DocumentID, ds.Status, ds.DateCreated from DocumentStatusLogs ds left join DocumentStatusLogs filter ON ds.DocumentID = filter.DocumentID -- Match any row that has another row that was created after it. AND ds.DateCreated < filter.DateCreated -- then filter out any rows that matched where filter.DocumentID is null
select ds.DocumentID, ds.Status, ds.DateCreated from DocumentStatusLogs ds WHERE ds.ID NOT IN ( SELECT filter.ID FROM DocumentStatusLogs filter WHERE ds.DocumentID = filter.DocumentID AND ds.DateCreated < filter.DateCreated)
SELECT [DocumentID], [tmpRez].value( [tmpRez].value( FROM ( SELECT [DocumentID], cast( +cast([DateCreated] as varchar(20)))+ FROM DocumentStatusLogs GROUP by DocumentID) as [tmpQry]
SELECT doc_id,status,date_created FROM ( SELECT a.*,Row_Number() OVER(PARTITION BY doc_id ORDER BY date_created DESC ) AS rnk FROM doc a) WHERE rnk=1;
SELECT * FROM DocumentStatusLogs D1 JOIN ( SELECT DocumentID,MAX(DateCreated) AS MaxDate FROM DocumentStatusLogs GROUP BY DocumentID ) D2 ON D2.DocumentID=D1.DocumentID AND D2.MaxDate=D1.DateCreated
SELECT MAX(DateCreated), * FROM DocumentStatusLogs GROUP BY DocumentID
select count(field1,field2,field3) from table where the combination of field1, field2, field3 occurs multiple times
select field1,field2,field3, count(*) from table_name group by field1,field2,field3 having count(*) > 1
SELECT A.ID, A.field1, A.field2, A.field3 FROM myTable A WHERE EXISTS (SELECT B.ID FROM myTable B WHERE B.field1 = A.field1 AND B.field2 = A.field2 AND B.field3 = A.field3 AND B.ID < A.ID)
SELECT id , field1 , field2 , field3 FROM ( SELECT id , field1 , field2 , field3 , RANK() OVER (PARTITION BY field1, field2, field3 ORDER BY id ASC) AS [rank] FROM table_name ) a WHERE [rank] > 1
with MYCTE as ( select row_number() over ( partition by name order by name) rown, * from tmptest ) select * from MYCTE where rown <=1
create table Table1 ( Field1 int, Field2 int, Field3 int, Field4 int ) insert Table1 values (1,1,1,1) , (1,1,1,2) , (1,1,1,3) , (2,2,2,1) , (3,3,3,1) , (3,3,3,2) , (null, null, 2, 1) , (null, null, 2, 3) select * from (select Field1 , Field2 , Field3 , Field4 , row_number() over (partition by Field1 , Field2 , Field3 order by Field4) as occurrence from Table1) x where occurrence > 1
CREATE TABLE ( sizeId Varchar(MAX) ) INSERT VALUES ( ( ( ( ( ( ( SELECT * FROM DECLARE @SqlStr VARCHAR(MAX) SELECT @SqlStr = STUFF((SELECT FROM ORDER BY sizeId FOR XML PATH( SELECT TOP 1 * FROM ( select items, count(*)AS Occurrence FROM dbo.Split(@SqlStr, group by items having count(*) > 1 )K ORDER BY K.Occurrence DESC
Declare @tablevar table(col1 col1Type,.. insert into @tablevar(col1,..) exec MyStoredProc SELECT col1, col2 FROM @tablevar
CREATE TABLE ( ID int, Name varchar(500), Revenue money ) INSERT SELECT * FROM DROP TABLE
SELECT name, current_execution_status FROM OPENQUERY (MYSERVER,
DECLARE @innerSql varchar(1000); DECLARE @outerSql varchar(1000); -- Set up the original stored proc definition. SET @innerSql = -- Handle quotes. SET @innerSql = REPLACE(@innerSql, -- Set up the OPENQUERY definition. SET @outerSql = FROM OPENQUERY (MYSERVER, -- Execute. EXEC (@outerSql);
CREATE PROCEDURE sp_GetDiffDataExample @columnsStatement NVARCHAR(MAX) -- required columns statement (e.g. "field1, field2") AS BEGIN DECLARE @query NVARCHAR(MAX) SET @query = N EXEC sp_executeSql @query SELECT * FROM DROP TABLE END
CREATE PROCEDURE [dbo].[MySproc] @Column_Name AS VARCHAR(50) AS BEGIN IF (@Column_Name = BEGIN SELECT @ColumnItem1 as END ELSE BEGIN SELECT @ColumnItem1 as END END
DataTable table = MyStoredProc (param1, param2).Tables[0]; (from row in table.AsEnumerable() select new { Col1 = row.Field<string>("col1"), Col2 = row.Field<string>("col2"), }).Dump();
DECLARE @temp TABLE (firstname NVARCHAR(30), lastname nvarchar(50)); INSERT INTO @temp EXEC dbo.GetPersonName @param1,@param2; -- assumption is that dbo.GetPersonName returns a table with firstname / lastname columns SELECT * FROM @temp;
use mydatabase create procedure sp_onetwothree as select 1 as go SELECT a.[1], a.[2] FROM OPENROWSET( GO
sp_configure GO RECONFIGURE GO sp_configure GO RECONFIGURE GO
DECLARE @spName VARCHAR(MAX) = DECLARE @tempTableName VARCHAR(MAX) = -- might need to update this if your param value is a string and you need to escape quotes DECLARE @insertCommand VARCHAR(MAX) = DECLARE @createTableCommand VARCHAR(MAX) -- update this to select the columns you want DECLARE @selectCommand VARCHAR(MAX) = DECLARE @dropCommand VARCHAR(MAX) = -- Generate command to create temp table SELECT @createTableCommand = STUFF ( ( SELECT FROM sys.dm_exec_describe_first_result_set_for_object ( OBJECT_ID(@spName), NULL ) FOR XML PATH( ) ,1 ,1 , ) + EXEC( @createTableCommand +
-- Delete all records DELETE FROM [TableName] -- Set current ID to "1" -- If table already contains data, use "0" -- If table is empty and never insert data, use "1" -- Use SP https: DBCC CHECKIDENT ([TableName], RESEED, [0|1])
CREATE PROCEDURE [dbo].[truncate_non_empty_table] @TableToTruncate VARCHAR(64) AS BEGIN SET NOCOUNT ON -- GLOBAL VARIABLES DECLARE @i int DECLARE @Debug bit DECLARE @Recycle bit DECLARE @Verbose bit DECLARE @TableName varchar(80) DECLARE @ColumnName varchar(80) DECLARE @ReferencedTableName varchar(80) DECLARE @ReferencedColumnName varchar(80) DECLARE @ConstraintName varchar(250) DECLARE @CreateStatement varchar(max) DECLARE @DropStatement varchar(max) DECLARE @TruncateStatement varchar(max) DECLARE @CreateStatementTemp varchar(max) DECLARE @DropStatementTemp varchar(max) DECLARE @TruncateStatementTemp varchar(max) DECLARE @Statement varchar(max) -- 1 = Will not execute statements SET @Debug = 0 -- 0 = Will not create or truncate storage table -- 1 = Will create or truncate storage table SET @Recycle = 0 -- 1 = Will print a message on every step set @Verbose = 1 SET @i = 1 SET @CreateStatement = SET @DropStatement = SET @TruncateStatement = -- Drop Temporary tables IF OBJECT_ID( DROP TABLE -- GET FKs SELECT ROW_NUMBER() OVER (ORDER BY OBJECT_NAME(parent_object_id), clm1.name) as ID, OBJECT_NAME(constraint_object_id) as ConstraintName, OBJECT_NAME(parent_object_id) as TableName, clm1.name as ColumnName, OBJECT_NAME(referenced_object_id) as ReferencedTableName, clm2.name as ReferencedColumnName INTO FROM sys.foreign_key_columns fk JOIN sys.columns clm1 ON fk.parent_column_id = clm1.column_id AND fk.parent_object_id = clm1.object_id JOIN sys.columns clm2 ON fk.referenced_column_id = clm2.column_id AND fk.referenced_object_id= clm2.object_id --WHERE OBJECT_NAME(parent_object_id) not in ( WHERE OBJECT_NAME(referenced_object_id) = @TableToTruncate ORDER BY OBJECT_NAME(parent_object_id) -- Prepare Storage Table IF Not EXISTS(SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = BEGIN IF @Verbose = 1 PRINT -- CREATE STORAGE TABLE IF IT DOES NOT EXISTS CREATE TABLE [Internal_FK_Definition_Storage] ( ID int not null identity(1,1) primary key, FK_Name varchar(250) not null, FK_CreationStatement varchar(max) not null, FK_DestructionStatement varchar(max) not null, Table_TruncationStatement varchar(max) not null ) END ELSE BEGIN IF @Recycle = 0 BEGIN IF @Verbose = 1 PRINT -- TRUNCATE TABLE IF IT ALREADY EXISTS TRUNCATE TABLE [Internal_FK_Definition_Storage] END ELSE PRINT END IF @Recycle = 0 BEGIN IF @Verbose = 1 PRINT -- Fetch and persist FKs WHILE (@i <= (SELECT MAX(ID) FROM BEGIN SET @ConstraintName = (SELECT ConstraintName FROM SET @TableName = (SELECT TableName FROM SET @ColumnName = (SELECT ColumnName FROM SET @ReferencedTableName = (SELECT ReferencedTableName FROM SET @ReferencedColumnName = (SELECT ReferencedColumnName FROM SET @DropStatementTemp = REPLACE(REPLACE(@DropStatement, SET @CreateStatementTemp = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@CreateStatement, SET @TruncateStatementTemp = REPLACE(@TruncateStatement, INSERT INTO [Internal_FK_Definition_Storage] SELECT @ConstraintName, @CreateStatementTemp, @DropStatementTemp, @TruncateStatementTemp SET @i = @i + 1 IF @Verbose = 1 PRINT END END ELSE PRINT IF @Verbose = 1 PRINT -- DROP FOREING KEYS SET @i = 1 WHILE (@i <= (SELECT MAX(ID) FROM [Internal_FK_Definition_Storage])) BEGIN SET @ConstraintName = (SELECT FK_Name FROM [Internal_FK_Definition_Storage] WHERE ID = @i) SET @Statement = (SELECT FK_DestructionStatement FROM [Internal_FK_Definition_Storage] WITH (NOLOCK) WHERE ID = @i) IF @Debug = 1 PRINT @Statement ELSE EXEC(@Statement) SET @i = @i + 1 IF @Verbose = 1 PRINT END IF @Verbose = 1 PRINT -- TRUNCATE TABLES -- SzP: commented out as the tables to be truncated might also contain tables that has foreign keys -- to resolve this the stored procedure should be called recursively, but I dont have the time to do it... /* SET @i = 1 WHILE (@i <= (SELECT MAX(ID) FROM [Internal_FK_Definition_Storage])) BEGIN SET @Statement = (SELECT Table_TruncationStatement FROM [Internal_FK_Definition_Storage] WHERE ID = @i) IF @Debug = 1 PRINT @Statement ELSE EXEC(@Statement) SET @i = @i + 1 IF @Verbose = 1 PRINT END */ IF @Verbose = 1 PRINT IF @Debug = 1 PRINT ELSE EXEC( IF @Verbose = 1 PRINT -- CREATE FOREING KEYS SET @i = 1 WHILE (@i <= (SELECT MAX(ID) FROM [Internal_FK_Definition_Storage])) BEGIN SET @ConstraintName = (SELECT FK_Name FROM [Internal_FK_Definition_Storage] WHERE ID = @i) SET @Statement = (SELECT FK_CreationStatement FROM [Internal_FK_Definition_Storage] WHERE ID = @i) IF @Debug = 1 PRINT @Statement ELSE EXEC(@Statement) SET @i = @i + 1 IF @Verbose = 1 PRINT END IF @Verbose = 1 PRINT END
SET NOCOUNT ON -- GLOBAL VARIABLES DECLARE @i int DECLARE @Debug bit DECLARE @Recycle bit DECLARE @Verbose bit DECLARE @TableName varchar(80) DECLARE @ColumnName varchar(80) DECLARE @ReferencedTableName varchar(80) DECLARE @ReferencedColumnName varchar(80) DECLARE @ConstraintName varchar(250) DECLARE @CreateStatement varchar(max) DECLARE @DropStatement varchar(max) DECLARE @TruncateStatement varchar(max) DECLARE @CreateStatementTemp varchar(max) DECLARE @DropStatementTemp varchar(max) DECLARE @TruncateStatementTemp varchar(max) DECLARE @Statement varchar(max) -- 1 = Will not execute statements SET @Debug = 0 -- 0 = Will not create or truncate storage table -- 1 = Will create or truncate storage table SET @Recycle = 0 -- 1 = Will print a message on every step set @Verbose = 1 SET @i = 1 SET @CreateStatement = SET @DropStatement = SET @TruncateStatement = -- Drop Temporary tables DROP TABLE -- GET FKs SELECT ROW_NUMBER() OVER (ORDER BY OBJECT_NAME(parent_object_id), clm1.name) as ID, OBJECT_NAME(constraint_object_id) as ConstraintName, OBJECT_NAME(parent_object_id) as TableName, clm1.name as ColumnName, OBJECT_NAME(referenced_object_id) as ReferencedTableName, clm2.name as ReferencedColumnName INTO FROM sys.foreign_key_columns fk JOIN sys.columns clm1 ON fk.parent_column_id = clm1.column_id AND fk.parent_object_id = clm1.object_id JOIN sys.columns clm2 ON fk.referenced_column_id = clm2.column_id AND fk.referenced_object_id= clm2.object_id WHERE OBJECT_NAME(parent_object_id) not in ( ORDER BY OBJECT_NAME(parent_object_id) -- Prepare Storage Table IF Not EXISTS(SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = BEGIN IF @Verbose = 1 PRINT -- CREATE STORAGE TABLE IF IT DOES NOT EXISTS CREATE TABLE [Internal_FK_Definition_Storage] ( ID int not null identity(1,1) primary key, FK_Name varchar(250) not null, FK_CreationStatement varchar(max) not null, FK_DestructionStatement varchar(max) not null, Table_TruncationStatement varchar(max) not null ) END ELSE BEGIN IF @Recycle = 0 BEGIN IF @Verbose = 1 PRINT -- TRUNCATE TABLE IF IT ALREADY EXISTS TRUNCATE TABLE [Internal_FK_Definition_Storage] END ELSE PRINT END IF @Recycle = 0 BEGIN IF @Verbose = 1 PRINT -- Fetch and persist FKs WHILE (@i <= (SELECT MAX(ID) FROM BEGIN SET @ConstraintName = (SELECT ConstraintName FROM SET @TableName = (SELECT TableName FROM SET @ColumnName = (SELECT ColumnName FROM SET @ReferencedTableName = (SELECT ReferencedTableName FROM SET @ReferencedColumnName = (SELECT ReferencedColumnName FROM SET @DropStatementTemp = REPLACE(REPLACE(@DropStatement, SET @CreateStatementTemp = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@CreateStatement, SET @TruncateStatementTemp = REPLACE(@TruncateStatement, INSERT INTO [Internal_FK_Definition_Storage] SELECT @ConstraintName, @CreateStatementTemp, @DropStatementTemp, @TruncateStatementTemp SET @i = @i + 1 IF @Verbose = 1 PRINT END END ELSE PRINT IF @Verbose = 1 PRINT -- DROP FOREING KEYS SET @i = 1 WHILE (@i <= (SELECT MAX(ID) FROM [Internal_FK_Definition_Storage])) BEGIN SET @ConstraintName = (SELECT FK_Name FROM [Internal_FK_Definition_Storage] WHERE ID = @i) SET @Statement = (SELECT FK_DestructionStatement FROM [Internal_FK_Definition_Storage] WITH (NOLOCK) WHERE ID = @i) IF @Debug = 1 PRINT @Statement ELSE EXEC(@Statement) SET @i = @i + 1 IF @Verbose = 1 PRINT END IF @Verbose = 1 PRINT -- TRUNCATE TABLES SET @i = 1 WHILE (@i <= (SELECT MAX(ID) FROM [Internal_FK_Definition_Storage])) BEGIN SET @Statement = (SELECT Table_TruncationStatement FROM [Internal_FK_Definition_Storage] WHERE ID = @i) IF @Debug = 1 PRINT @Statement ELSE EXEC(@Statement) SET @i = @i + 1 IF @Verbose = 1 PRINT END IF @Verbose = 1 PRINT -- CREATE FOREING KEYS SET @i = 1 WHILE (@i <= (SELECT MAX(ID) FROM [Internal_FK_Definition_Storage])) BEGIN SET @ConstraintName = (SELECT FK_Name FROM [Internal_FK_Definition_Storage] WHERE ID = @i) SET @Statement = (SELECT FK_CreationStatement FROM [Internal_FK_Definition_Storage] WHERE ID = @i) IF @Debug = 1 PRINT @Statement ELSE EXEC(@Statement) SET @i = @i + 1 IF @Verbose = 1 PRINT END IF @Verbose = 1 PRINT
EXEC sp_MSForEachTable EXEC sp_MSForEachTable -- EXEC sp_MSForEachTable EXEC sp_MSForEachTable EXEC sp_MSForEachTable
ALTER TABLE TABLE_OWNING_CONSTRAINT DROP CONSTRAINT FK_PROBLEM_REASON
ALTER TABLE TABLE_OWNING_CONSTRAINT ADD CONSTRAINT FK_PROBLEM_REASON FOREIGN KEY(ID) REFERENCES TABLE_TO_TRUNCATE (ID)
SET NOCOUNT ON GO DECLARE @table TABLE( RowId INT PRIMARY KEY IDENTITY(1, 1), ForeignKeyConstraintName NVARCHAR(200), ForeignKeyConstraintTableSchema NVARCHAR(200), ForeignKeyConstraintTableName NVARCHAR(200), ForeignKeyConstraintColumnName NVARCHAR(200), PrimaryKeyConstraintName NVARCHAR(200), PrimaryKeyConstraintTableSchema NVARCHAR(200), PrimaryKeyConstraintTableName NVARCHAR(200), PrimaryKeyConstraintColumnName NVARCHAR(200) ) INSERT INTO @table(ForeignKeyConstraintName, ForeignKeyConstraintTableSchema, ForeignKeyConstraintTableName, ForeignKeyConstraintColumnName) SELECT U.CONSTRAINT_NAME, U.TABLE_SCHEMA, U.TABLE_NAME, U.COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE U INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS C ON U.CONSTRAINT_NAME = C.CONSTRAINT_NAME WHERE C.CONSTRAINT_TYPE = UPDATE @table SET PrimaryKeyConstraintName = UNIQUE_CONSTRAINT_NAME FROM @table T INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS R ON T.ForeignKeyConstraintName = R.CONSTRAINT_NAME UPDATE @table SET PrimaryKeyConstraintTableSchema = TABLE_SCHEMA, PrimaryKeyConstraintTableName = TABLE_NAME FROM @table T INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS C ON T.PrimaryKeyConstraintName = C.CONSTRAINT_NAME UPDATE @table SET PrimaryKeyConstraintColumnName = COLUMN_NAME FROM @table T INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE U ON T.PrimaryKeyConstraintName = U.CONSTRAINT_NAME --DROP CONSTRAINT: DECLARE @dynSQL varchar(MAX); DECLARE cur CURSOR FOR SELECT ' ALTER TABLE [ DROP CONSTRAINT ' FROM @table OPEN cur FETCH cur into @dynSQL WHILE @@FETCH_STATUS = 0 BEGIN exec(@dynSQL) print @dynSQL FETCH cur into @dynSQL END CLOSE cur DEALLOCATE cur --------------------- --HERE GOES YOUR TRUNCATES!!!!! --HERE GOES YOUR TRUNCATES!!!!! --HERE GOES YOUR TRUNCATES!!!!! truncate table your_table --HERE GOES YOUR TRUNCATES!!!!! --HERE GOES YOUR TRUNCATES!!!!! --HERE GOES YOUR TRUNCATES!!!!! --------------------- --ADD CONSTRAINT: DECLARE cur2 CURSOR FOR SELECT ' ALTER TABLE [ ADD CONSTRAINT ' FROM @table OPEN cur2 FETCH cur2 into @dynSQL WHILE @@FETCH_STATUS = 0 BEGIN exec(@dynSQL) print @dynSQL FETCH cur2 into @dynSQL END CLOSE cur2 DEALLOCATE cur2
SET FOREIGN_KEY_CHECKS = 0; truncate table "yourTableName"; SET FOREIGN_KEY_CHECKS = 1;
EXEC ( IF EXISTS (Select * from sys.identity_columns where object_name(object_id) = BEGIN EXEC ( END
PRINT DECLARE @foreign_key_name varchar(255) DECLARE @keycnt int DECLARE @foreign_table varchar(255) DECLARE @foreign_column_1 varchar(255) DECLARE @foreign_column_2 varchar(255) DECLARE @primary_table varchar(255) DECLARE @primary_column_1 varchar(255) DECLARE @primary_column_2 varchar(255) DECLARE @TablN varchar(255) -->> Type the primary table name SET @TablN = --------------------------------------------------------------------------------------- ------------------------------ --Here will be created the temporary table with all reference FKs --------------------------------------------------------------------------------------------------------------------- PRINT select cast(f.name as varchar(255)) as foreign_key_name , r.keycnt , cast(c.name as varchar(255)) as foreign_table , cast(fc.name as varchar(255)) as foreign_column_1 , cast(fc2.name as varchar(255)) as foreign_column_2 , cast(p.name as varchar(255)) as primary_table , cast(rc.name as varchar(255)) as primary_column_1 , cast(rc2.name as varchar(255)) as primary_column_2 into from sysobjects f inner join sysobjects c on f.parent_obj = c.id inner join sysreferences r on f.id = r.constid inner join sysobjects p on r.rkeyid = p.id inner join syscolumns rc on r.rkeyid = rc.id and r.rkey1 = rc.colid inner join syscolumns fc on r.fkeyid = fc.id and r.fkey1 = fc.colid left join syscolumns rc2 on r.rkeyid = rc2.id and r.rkey2 = rc.colid left join syscolumns fc2 on r.fkeyid = fc2.id and r.fkey2 = fc.colid where f.type = ORDER BY cast(p.name as varchar(255)) --------------------------------------------------------------------------------------------------------------------- --Cursor, below, will drop all reference FKs --------------------------------------------------------------------------------------------------------------------- DECLARE @CURSOR CURSOR PRINT SET @CURSOR = CURSOR SCROLL FOR select foreign_key_name , keycnt , foreign_table , foreign_column_1 , foreign_column_2 , primary_table , primary_column_1 , primary_column_2 from OPEN @CURSOR FETCH NEXT FROM @CURSOR INTO @foreign_key_name, @keycnt, @foreign_table, @foreign_column_1, @foreign_column_2, @primary_table, @primary_column_1, @primary_column_2 WHILE @@FETCH_STATUS = 0 BEGIN EXEC ( FETCH NEXT FROM @CURSOR INTO @foreign_key_name, @keycnt, @foreign_table, @foreign_column_1, @foreign_column_2, @primary_table, @primary_column_1, @primary_column_2 END CLOSE @CURSOR PRINT --------------------------------------------------------------------------------------------------------------------- --Here you should provide the chainging script for the primary table --------------------------------------------------------------------------------------------------------------------- PRINT TRUNCATE TABLE table_name PRINT --------------------------------------------------------------------------------------------------------------------- --Cursor, below, will add again all reference FKs -------------------------------------------------------------------------------------------------------------------- PRINT SET @CURSOR = CURSOR SCROLL FOR select foreign_key_name , keycnt , foreign_table , foreign_column_1 , foreign_column_2 , primary_table , primary_column_1 , primary_column_2 from OPEN @CURSOR FETCH NEXT FROM @CURSOR INTO @foreign_key_name, @keycnt, @foreign_table, @foreign_column_1, @foreign_column_2, @primary_table, @primary_column_1, @primary_column_2 WHILE @@FETCH_STATUS = 0 BEGIN EXEC ( REFERENCES [ EXEC ( FETCH NEXT FROM @CURSOR INTO @foreign_key_name, @keycnt, @foreign_table, @foreign_column_1, @foreign_column_2, @primary_table, @primary_column_1, @primary_column_2 END CLOSE @CURSOR PRINT --------------------------------------------------------------------------------------------------------------------- PRINT drop table PRINT
ALTER TABLE Orders NOCHECK CONSTRAINT [FK_dbo.Orders_dbo.Customers_Customer_Id] GO TRUNCATE TABLE Customers GO ALTER TABLE Orders WITH CHECK CHECK CONSTRAINT [FK_dbo.Orders_dbo.Customers_Customer_Id] GO
USE [YourDB]; DECLARE @TransactionName varchar(20) = BEGIN TRAN @TransactionName; set xact_abort on; /* automatic rollback https: -- ===== DO WORK -- dynamic sql placeholder DECLARE @SQL varchar(300); -- LOOP: https: -- list of things to loop DECLARE @delim char = DECLARE @foreach varchar(MAX) = DECLARE @token varchar(MAX); WHILE len(@foreach) > 0 BEGIN -- set current loop token SET @token = left(@foreach, charindex(@delim, @foreach+@delim)-1) -- ======= DO WORK -- dynamic sql (parentheses are required): https: SET @SQL = PRINT @SQL; EXEC (@SQL); -- ======= -- continue loop, chopping off token SET @foreach = stuff(@foreach, 1, charindex(@delim, @foreach+@delim), END -- ===== -- review and commit SELECT @@TRANCOUNT as TransactionsPerformed, @@ROWCOUNT as LastRowsChanged; COMMIT TRAN @TransactionName;
--------------------------------------------------------------- ------------------- Just Fill Parameters Value ---------------- --------------------------------------------------------------- DECLARE @DbName AS NVARCHAR(30) = DECLARE @Schema AS NVARCHAR(30) = DECLARE @TableName AS NVARCHAR(30) = ------------------ /Just Fill Parameters Value ---------------- DECLARE @Query AS NVARCHAR(500) = EXECUTE sp_executesql @Query SET @Query=@DbName+ DBCC CHECKIDENT (@Query,RESEED, 0)
-- Book Student -- -- | BookId | Field1 | | StudentId | BookId | -- --------------------- ------------------------ -- | 1 | A | | 2 | 1 | -- | 2 | B | | 1 | 1 | -- | 3 | C | | 2 | 3 | --------------------------------------------------------------- ------------------- Just Fill Parameters Value ---------------- --------------------------------------------------------------- DECLARE @DbName AS NVARCHAR(30) = DECLARE @Schema AS NVARCHAR(30) = DECLARE @TableName_ToTruncate AS NVARCHAR(30) = DECLARE @TableName_OfOwnerOfConstraint AS NVARCHAR(30) = DECLARE @Ref_ColumnName_In_TableName_ToTruncate AS NVARCHAR(30) = DECLARE @FK_ColumnName_In_TableOfOwnerOfConstraint AS NVARCHAR(30) = DECLARE @FK_ConstraintName AS NVARCHAR(30) = ------------------ /Just Fill Parameters Value ---------------- DECLARE @Query AS NVARCHAR(2000) SET @Query= EXECUTE sp_executesql @Query SET @Query= EXECUTE sp_executesql @Query SET @Query= EXECUTE sp_executesql @Query
ALTER TABLE CHILD_TABLE DISABLE CONSTRAINT child_par_ref; TRUNCATE TABLE CHILD_TABLE; TRUNCATE TABLE PARENT_TABLE; ALTER TABLE CHILD_TABLE ENABLE CONSTRAINT child_par_ref;
SET FOREIGN_KEY_CHECKS=0; TRUNCATE table1; TRUNCATE table2; SET FOREIGN_KEY_CHECKS=1;
SELECT O.Id, O.Name as Organization FROM Organizations O JOIN OrganizationsHierarchy OH ON O.Id=OH.OrganizationsId where OH.Hierarchy like
from c in dc.Organization where SqlMethods.Like(c.Hierarchy, "%/12/%") select *;
from o in dc.Organization join oh in dc.OrganizationsHierarchy on o.Id equals oh.OrganizationsId where oh.Hierarchy.Contains(@"/12/") select new { o.Id, o.Name }
from o in dc.Organization where o.OrganizationsHierarchy.Hierarchy.Contains(@"/12/") select new { o.Id, o.Name }
var result = from c in SampleList where c.LongName.IndexOf(SearchQuery) >= 0 select c;
try { using (DatosDataContext dtc = new DatosDataContext()) { var query = from pe in dtc.Personal_Hgo where SqlMethods.Like(pe.nombre, "%" + txtNombre.Text + "%") select new { pe.numero , pe.nombre }; dgvDatos.DataSource = query.ToList(); } } catch (Exception ex) { string mensaje = ex.Message; }
.Where(oh => oh.Hierarchy.ToUpper().Contains(mySearchString.ToUpper()))
from record in context.Organization where record.Hierarchy.Contains(12) select record;
from h in OH where h.Hierarchy.Contains("/12/") select h
System.Data.Linq.SqlClient.SqlMethods.Like("mystring", "%string")
var result= Organizations.Join(OrganizationsHierarchy.Where(s=>s.Hierarchy.Contains("/12/")),s=>s.Id,s=>s.OrganizationsId,(org,orgH)=>new {org,orgH});
déjà => d[éèêëeÉÈÊËE]j[aàâäAÀÂÄ] montreal => montr[éèêëeÉÈÊËE][aàâäAÀÂÄ]l montréal => montr[éèêëeÉÈÊËE][aàâäAÀÂÄ]l
var city = "montr[éèêëeÉÈÊËE][aàâäAÀÂÄ]l"; var data = (from loc in _context.Locations where SqlFunctions.PatIndex(city, loc.City) > 0 select loc.City).ToList();
public static class SqlServerHelper { private static readonly List<KeyValuePair<string, string>> Diacritics = new List<KeyValuePair<string, string>>() { new KeyValuePair<string, string>("A", "aàâäAÀÂÄ"), new KeyValuePair<string, string>("E", "éèêëeÉÈÊËE"), new KeyValuePair<string, string>("U", "uûüùUÛÜÙ"), new KeyValuePair<string, string>("C", "cçCÇ"), new KeyValuePair<string, string>("I", "iîïIÎÏ"), new KeyValuePair<string, string>("O", "ôöÔÖ"), new KeyValuePair<string, string>("Y", "YŸÝýyÿ") }; public static string EnumarateDiacritics(this string stringToDiatritics) { if (string.IsNullOrEmpty(stringToDiatritics.Trim())) return stringToDiatritics; var diacriticChecked = string.Empty; foreach (var c in stringToDiatritics.ToCharArray()) { var diac = Diacritics.FirstOrDefault(o => o.Value.ToCharArray().Contains(c)); if (string.IsNullOrEmpty(diac.Key)) continue; if (diacriticChecked.Contains(diac.Key)) continue; diacriticChecked += diac.Key; stringToDiatritics = stringToDiatritics.Replace(c.ToString(), "[" + diac.Value + "]"); } stringToDiatritics = "%" + stringToDiatritics + "%"; return stringToDiatritics; } }
-- ============================================= -- Description: TRIMs a string -- and replaces ASCII-char -- form-feed, & carriage-return (respectively), with a whitespace -- (and then trims that off if it -- ============================================= CREATE FUNCTION [fn_CleanAndTrim] ( @Str nvarchar(max) ) RETURNS nvarchar(max) AS BEGIN DECLARE @Result nvarchar(max) SET @Result = LTRIM(RTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( LTRIM(RTRIM(@Str)), CHAR(9), RETURN @Result END
IF OBJECT_ID( EXEC ( GO -- ============================================= -- Author: Nate Johnson -- Source: http: -- Description: TRIMs a string -- and replaces ASCII-char -- & carriage-return (respectively), with a whitespace or specified character(s). -- Option "@PurgeReplaceCharsAtEnds" determines whether or not to remove extra head/tail -- replacement-chars from the string after doing the initial replacements. -- This is only truly useful if you -- **OTHER** than a space, because plain LTRIM/RTRIM will have already removed those. -- ============================================= ALTER FUNCTION dbo.[fn_CleanAndTrim] ( @Str NVARCHAR(MAX) , @ReplaceTabWith NVARCHAR(5) = , @ReplaceNewlineWith NVARCHAR(5) = , @PurgeReplaceCharsAtEnds BIT = 1 ) RETURNS NVARCHAR(MAX) AS BEGIN DECLARE @Result NVARCHAR(MAX) --The main work (trim & initial replacements) SET @Result = LTRIM(RTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( LTRIM(RTRIM(@Str)) --Basic trim , NCHAR(9), @ReplaceTabWith), NCHAR(11), @ReplaceTabWith) --Replace tab & vertical-tab , (NCHAR(13) + NCHAR(10)), @ReplaceNewlineWith) --Replace "Windows" linebreak (CR+LF) , NCHAR(10), @ReplaceNewlineWith), NCHAR(12), @ReplaceNewlineWith), NCHAR(13), @ReplaceNewlineWith))) --Replace other newlines --If asked to trim replacement-char IF (@PurgeReplaceCharsAtEnds = 1 AND NOT (@ReplaceTabWith = N BEGIN --Purge from head of string (beginning) WHILE (LEFT(@Result, DATALENGTH(@ReplaceTabWith)/2) = @ReplaceTabWith) SET @Result = SUBSTRING(@Result, DATALENGTH(@ReplaceTabWith)/2 + 1, DATALENGTH(@Result)/2) WHILE (LEFT(@Result, DATALENGTH(@ReplaceNewlineWith)/2) = @ReplaceNewlineWith) SET @Result = SUBSTRING(@Result, DATALENGTH(@ReplaceNewlineWith)/2 + 1, DATALENGTH(@Result)/2) --Purge from tail of string (end) WHILE (RIGHT(@Result, DATALENGTH(@ReplaceTabWith)/2) = @ReplaceTabWith) SET @Result = SUBSTRING(@Result, 1, DATALENGTH(@Result)/2 - DATALENGTH(@ReplaceTabWith)/2) WHILE (RIGHT(@Result, DATALENGTH(@ReplaceNewlineWith)/2) = @ReplaceNewlineWith) SET @Result = SUBSTRING(@Result, 1, DATALENGTH(@Result)/2 - DATALENGTH(@ReplaceNewlineWith)/2) END RETURN @Result END GO
REPLACE(REPLACE(REPLACE(MyField, CHAR(13) + CHAR(10),
SELECT REPLACE(REPLACE(cast(@str as nvarchar(max)), CHAR(13),
WHILE EXISTS (SELECT * FROM @ReportSet WHERE ASCII(right(addr_3,1)) = 10 OR ASCII(right(addr_3,1)) = 13 OR ASCII(right(addr_3,1)) = 32) BEGIN UPDATE @ReportSet SET addr_3 = LEFT(addr_3,LEN(addr_3)-1) WHERE ASCII(right(addr_3,1)) = 10 OR ASCII(right(addr_3,1)) = 13 OR ASCII(right(addr_3,1)) = 32 END
SELECT name FROM table2 -- that are not in table1 already
SELECT t1.name FROM table1 t1 LEFT JOIN table2 t2 ON t2.name = t1.name WHERE t2.name IS NULL
SELECT name FROM table2 WHERE name NOT IN (SELECT name FROM table1)
SELECT name FROM table2 WHERE NOT EXISTS (SELECT * FROM table1 WHERE table1.name = table2.name)
SELECT name FROM table2 WHERE name NOT IN (SELECT name FROM table1)
select id, name from table1 minus select id, name from table2
SELECT name FROM table2 WHERE name NOT IN (SELECT ISNULL(name , FROM table1)
SELECT * FROM @T1 EXCEPT SELECT a.* FROM @T1 a JOIN @T2 b ON a.ID = b.ID
SELECT * FROM [dbo].[table1] t1 LEFT JOIN [dbo].[table2] t2 ON t1.[t1_ID] = t2.[t2_ID] WHERE t2.[t2_ID] IS NULL
SELECT <column_list> FROM TABLEA a LEFTJOIN TABLEB b ON a.Key = b.Key WHERE b.Key IS NULL;
SELECT temp_table_1.name FROM original_table_1 temp_table_1 LEFT JOIN original_table_2 temp_table_2 ON temp_table_2.name = temp_table_1.name WHERE temp_table_2.name IS NULL
SELECT col1, col2 INTO dbo.TableTwo FROM dbo.TableOne WHERE col3 LIKE @search_key
INSERT INTO dbo.TABLETWO SELECT col1, col2 FROM dbo.TABLEONE WHERE col3 LIKE @search_key
INSERT INTO dbo.TABLETWO (col1, col2) SELECT col1, col2 FROM dbo.TABLEONE WHERE col3 LIKE @search_key
----Create testable CREATE TABLE TestTable (FirstName VARCHAR(100), LastName VARCHAR(100)) ----INSERT INTO TestTable using SELECT INSERT INTO TestTable (FirstName, LastName) SELECT FirstName, LastName FROM Person.Contact WHERE EmailPromotion = 2 ----Verify that Data in TestTable SELECT FirstName, LastName FROM TestTable ----Clean Up Database DROP TABLE TestTable
----Create a new table and insert into table using SELECT INSERT SELECT FirstName, LastName INTO TestTable FROM Person.Contact WHERE EmailPromotion = 2 ----Verify that Data in TestTable SELECT FirstName, LastName FROM TestTable ----Clean Up Database DROP TABLE TestTable
insert into Gengl_Del Select Tdate,DocNo,Book,GlCode,OpGlcode,Amt,Narration from Gengl where BOOK=
select * into existing table database..existingtable from database..othertables....
SELECT DISTINCT COUNT(*) AS Count, program_type AS [Type] FROM cm_production WHERE push_number=@push_number GROUP BY program_type
SELECT COUNT(DISTINCT program_name) AS Count, program_type AS [Type] FROM cm_production WHERE push_number=@push_number GROUP BY program_type
SELECT Region, count(*) FROM item WHERE Region is not null GROUP BY Region
SELECT COUNT(*) FROM (SELECT DISTINCT column1,column2 FROM tablename WHERE condition ) as dt
SELECT COUNT(program_name) AS [Count],program_type AS [Type] FROM (SELECT DISTINCT program_name,program_type FROM cm_production WHERE push_number=@push_number ) dt GROUP BY program_type
SELECT COUNT(DISTINCT program_name) AS Count, program_type AS [Type] FROM cm_production WHERE push_number=@push_number GROUP BY program_type
SELECT DISTINCT RIGHT (address, 6), count(*) AS count FROM datafile WHERE address IS NOT NULL GROUP BY RIGHT (address, 6)
select count (distinct NumTar), from ATM_TRANe with (nolock) where Fecha>= AND Fecha<= and SystemCodResp=0 group by NetDestino union select sum (contar), from ( select count(distinct NumTar) as contar from ATM_TRANe with (nolock) where Fecha>= AND Fecha<= and NetDestino!=0 and SystemCodResp=0 group by NetDestino )dt
-- wait for 1 minute WAITFOR DELAY -- wait for 1 second WAITFOR DELAY
CREATE FUNCTION [dbo].[ufn_DelayFor_MaxTimeIs24Hours] ( @sec int ) RETURNS nvarchar(4) AS BEGIN declare @hours int = @sec / 60 / 60 declare @mins int = (@sec / 60) - (@hours * 60) declare @secs int = (@sec - ((@hours * 60) * 60)) - (@mins * 60) IF @hours > 23 BEGIN select @hours = 23 select @mins = 59 select @secs = 59 -- END declare @sql nvarchar(24) = exec sp_executesql @sql return END
Declare @Days int = 5 Declare @CurrentDay int = 1 WHILE @CurrentDay <= @Days BEGIN --24 hours, function will run for 23 hours, 59 minutes, 59 seconds per run. [ufn_DelayFor_MaxTimeIs24Hours] 86400 SELECT @CurrentDay = @CurrentDay + 1 END
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Data.SqlClient; namespace ConsoleApplication1 { class Program { static void Main(string[] args) { var builder = new SqlConnectionStringBuilder(); builder.DataSource = "localhost"; builder.IntegratedSecurity = true; builder.InitialCatalog = "master"; var connectionString = builder.ConnectionString; using (var connection = new SqlConnection(connectionString)) { connection.Open(); using (var command = connection.CreateCommand()) { command.CommandText = "WAITFOR DELAY command.CommandTimeout = 1; command.ExecuteNonQuery(); } } } } }
SELECT CASE WHEN Date1 >= Date2 AND Date1 >= Date3 THEN Date1 WHEN Date2 >= Date1 AND Date2 >= Date3 THEN Date2 WHEN Date3 >= Date1 AND Date3 >= Date2 THEN Date3 ELSE Date1 END AS MostRecentDate
SELECT [Other Fields], (SELECT Max(v) FROM (VALUES (date1), (date2), (date3),...) AS value(v)) as [MaxDate] FROM [YourTableName]
CREATE TABLE dates ( number INT PRIMARY KEY , date1 DATETIME , date2 DATETIME , date3 DATETIME , cost INT ) INSERT INTO dates VALUES ( 1, INSERT INTO dates VALUES ( 2, INSERT INTO dates VALUES ( 3, INSERT INTO dates VALUES ( 4, GO
SELECT number , MAX(dDate) maxDate , cost FROM dates UNPIVOT ( dDate FOR nDate IN ( Date1, Date2, Date3 ) ) as u GROUP BY number , cost GO
SELECT number , ( SELECT MAX(dDate) maxDate FROM ( SELECT d.date1 AS dDate UNION SELECT d.date2 UNION SELECT d.date3 ) a ) MaxDate , Cost FROM dates d GO
;WITH maxD AS ( SELECT number , MAX(CASE rn WHEN 1 THEN Date1 WHEN 2 THEN date2 ELSE date3 END) AS maxDate FROM dates a CROSS JOIN ( SELECT 1 AS rn UNION SELECT 2 UNION SELECT 3 ) b GROUP BY Number ) SELECT dates.number , maxD.maxDate , dates.cost FROM dates INNER JOIN MaxD ON dates.number = maxD.number GO DROP TABLE dates GO
SELECT MAX(date_columns) AS max_date FROM ( (SELECT date1 AS date_columns FROM data_table ) UNION ( SELECT date2 AS date_columns FROM data_table ) UNION ( SELECT date3 AS date_columns FROM data_table ) ) AS date_query
SELECT MAX(MostRecentDate) FROM ( SELECT CASE WHEN date1 >= date2 AND date1 >= date3 THEN date1 WHEN date2 >= date1 AND date2 >= date3 THEN date2 WHEN date3 >= date1 AND date3 >= date2 THEN date3 ELSE date1 END AS MostRecentDate FROM data_table ) AS date_query
CREATE FUNCTION dbo.Get_Min_Max_Date ( @Date1 datetime, @Date2 datetime, @Date3 datetime, @Date4 datetime, @Date5 datetime, @Date6 datetime, @Date7 datetime, @Date8 datetime, @Date9 datetime, @Date10 datetime ) RETURNS TABLE AS RETURN ( SELECT Max(DateValue) Max_Date, Min(DateValue) Min_Date FROM ( VALUES (@Date1), (@Date2), (@Date3), (@Date4), (@Date5), (@Date6), (@Date7), (@Date8), (@Date9), (@Date10) ) AS Dates(DateValue) )
DECLARE @TableName TABLE (Number INT, Date1 DATETIME, Date2 DATETIME, Date3 DATETIME, Cost MONEY) INSERT INTO @TableName SELECT 1, SELECT 2, SELECT Number, Cost , (SELECT MAX([Date]) FROM (SELECT Date1 AS [Date] UNION ALL SELECT Date2 UNION ALL SELECT Date3 ) D ) [Most Recent Date] FROM @TableName
SELECT (SELECT MAX(MyMaxName) FROM ( VALUES (MAX(iSortCode)), (MAX(Field2)) ) MyAlias(MyMaxName) ) FROM MyTable1
SELECT CASE WHEN Date1 >= Date2 AND Date1 >= Date3 THEN Date1 WHEN Date2 >= Date3 THEN Date2 ELSE Date3 END AS MostRecentDate
DECLARE @v1 INT , @v2 INT , @v3 INT --SET @v1 = 1 --Comment out SET statements to experiment with --various combinations of NULL values SET @v2 = 2 SET @v3 = 3 SELECT ( SELECT MAX(Vals) FROM ( SELECT v1 AS Vals UNION SELECT v2 UNION SELECT v3 ) tmp WHERE Vals IS NOT NULL -- This eliminates NULL warning ) AS MaxVal FROM ( SELECT @v1 AS v1 ) t1 CROSS JOIN ( SELECT @v2 AS v2 ) t2 CROSS JOIN ( SELECT @v3 AS v3 ) t3
[MinRateValue] = CASE WHEN ISNULL(FitchRating.RatingValue, 100) < = ISNULL(MoodyRating.RatingValue, 99) AND ISNULL(FitchRating.RatingValue, 100) < = ISNULL(StandardPoorsRating.RatingValue, 99) THEN FitchgAgency.RatingAgencyName WHEN ISNULL(MoodyRating.RatingValue, 100) < = ISNULL(StandardPoorsRating.RatingValue , 99) THEN MoodyAgency.RatingAgencyName ELSE ISNULL(StandardPoorsRating.RatingValue, END
create table dates ( number int, date1 datetime, date2 datetime, date3 datetime ) insert into dates values (1, insert into dates values (1, insert into dates values (1, insert into dates values (1, select max(dateMaxes) from ( select (select max(date1) from dates) date1max, (select max(date2) from dates) date2max, (select max(date3) from dates) date3max ) myTable unpivot (dateMaxes For fieldName In (date1max, date2max, date3max)) as tblPivot drop table dates
SELECT MostRecentDate FROM SourceTable CROSS APPLY (SELECT MAX(d) MostRecentDate FROM (VALUES (Date1), (Date2), (Date3)) AS a(d)) md
DECLARE @Date1 DATE= DECLARE @Date2 DATE= DECLARE @Date3 DATE= SELECT IIF(@Date1>@Date2, IIF(@Date1>@Date3,@Date1,@Date3), IIF(@Date2>@Date3,@Date2,@Date3)) AS MostRecentDate
SELECT MAX(MaxDt) MaxDt FROM tbl UNPIVOT (MaxDt FOR E IN (Date1, Date2, Date3) )AS unpvt;
declare @MostRecent smalldatetime set @MostRecent= if @Date1>@MostRecent begin set @MostRecent=@Date1 end if @Date2>@MostRecent begin set @MostRecent=@Date2 end if @Date3>@MostRecent begin set @MostRecent=@Date3 end RETURN @MostRecent
SELECT CASE true WHEN max(row1) >= max(row2) THEN CASE true WHEN max(row1) >= max(row3) THEN max(row1) ELSE max(row3) end ELSE CASE true WHEN max(row2) >= max(row3) THEN max(row2) ELSE max(row3) END END FROM yourTable
CREATE function [dbo].[inLineMax] (@v1 float,@v2 float,@v3 float,@v4 float) returns float as begin declare @val float set @val = 0 declare @TableVal table (value float ) insert into @TableVal select @v1 insert into @TableVal select @v2 insert into @TableVal select @v3 insert into @TableVal select @v4 select @val= max(value) from @TableVal return @val end
declare @userData TABLE( name varchar(30) NOT NULL, oldlocation varchar(30) NOT NULL ) SELECT name, location INTO @userData FROM myTable INNER JOIN otherTable ON ... WHERE age > 30
DECLARE @userData TABLE( name varchar(30) NOT NULL, oldlocation varchar(30) NOT NULL ); INSERT INTO @userData (name, oldlocation) SELECT name, location FROM myTable INNER JOIN otherTable ON ... WHERE age > 30;
INSERT INTO MyTable (PriKey, Description) SELECT ForeignKey, Description FROM SomeView
WITH userData (name, oldlocation) AS ( SELECT name, location FROM myTable INNER JOIN otherTable ON ... WHERE age>30 ) SELECT * FROM userData -- you can also reuse the recordset in subqueries and joins
SELECT name, location INTO INNER JOIN otherTable ON ... WHERE age>30
DECLARE @userData TABLE( name varchar(30) NOT NULL, oldlocation varchar(30) NOT NULL ); INSERT INTO @userData SELECT name, location FROM myTable INNER JOIN otherTable ON ... WHERE age > 30;
create table Name varchar(100), Age Int , RollNumber bigint )
declare @tblOm_Variable table( Name Varchar(100), Age int, RollNumber bigint )
SELECT IDENTITY(INT,1,1) AS Id, name INTO FROM (SELECT name FROM AnotherTable) AS t
SET SHOWPLAN_TEXT ON SET SHOWPLAN_ALL ON SET SHOWPLAN_XML ON SET STATISTICS PROFILE ON SET STATISTICS XML ON -- The is the recommended option to use
SELECT UseCounts, Cacheobjtype, Objtype, TEXT, query_plan FROM sys.dm_exec_cached_plans CROSS APPLY sys.dm_exec_sql_text(plan_handle) CROSS APPLY sys.dm_exec_query_plan(plan_handle)
DECLARE @TraceID INT EXEC StartCapture @@SPID, @TraceID OUTPUT EXEC sp_help EXEC StopCapture @TraceID
CREATE PROCEDURE StartCapture @Spid INT, @TraceID INT OUTPUT AS DECLARE @maxfilesize BIGINT = 5 DECLARE @filepath NVARCHAR(200) = N EXEC sp_trace_create @TraceID OUTPUT, 0, @filepath, @maxfilesize, NULL exec sp_trace_setevent @TraceID, 122, 1, 1 exec sp_trace_setevent @TraceID, 122, 22, 1 exec sp_trace_setevent @TraceID, 122, 34, 1 exec sp_trace_setevent @TraceID, 122, 51, 1 exec sp_trace_setevent @TraceID, 122, 12, 1 -- filter for spid EXEC sp_trace_setfilter @TraceID, 12, 0, 0, @Spid -- start the trace EXEC sp_trace_setstatus @TraceID, 1
CREATE PROCEDURE StopCapture @TraceID INT AS WITH XMLNAMESPACES ( CTE as (SELECT CAST(TextData AS VARCHAR(MAX)) AS TextData, ObjectID, ObjectName, EventSequence, MAX(EstimatedTotalSubtreeCost) AS EstimatedTotalSubtreeCost FROM fn_trace_getinfo(@TraceID) fn CROSS APPLY fn_trace_gettable(CAST(value AS NVARCHAR(200)), 1) CROSS APPLY (SELECT CAST(TextData AS XML) AS xPlan) x CROSS APPLY (SELECT T.relop.value( FROM xPlan.nodes( WHERE property = 2 AND TextData IS NOT NULL AND ObjectName not in ( GROUP BY CAST(TextData AS VARCHAR(MAX)), ObjectID, ObjectName, EventSequence) SELECT ObjectName, SUM(EstimatedTotalSubtreeCost) AS EstimatedTotalSubtreeCost FROM CTE GROUP BY ObjectID, ObjectName -- Stop the trace EXEC sp_trace_setstatus @TraceID, 0 -- Close and delete the trace EXEC sp_trace_setstatus @TraceID, 2 GO
CREATE EVENT SESSION [GetExecutionPlan] ON SERVER ADD EVENT sqlserver.query_post_execution_showplan( ACTION(package0.event_sequence,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack)), /* Remove any of the following events (or include additional events) as desired. */ ADD EVENT sqlserver.error_reported( ACTION(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) WHERE ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) AND [package0].[equal_boolean]([sqlserver].[is_system],(0)))), ADD EVENT sqlserver.module_end(SET collect_statement=(1) ACTION(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) WHERE ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) AND [package0].[equal_boolean]([sqlserver].[is_system],(0)))), ADD EVENT sqlserver.rpc_completed( ACTION(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) WHERE ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) AND [package0].[equal_boolean]([sqlserver].[is_system],(0)))), ADD EVENT sqlserver.sp_statement_completed(SET collect_object_name=(1) ACTION(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) WHERE ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) AND [package0].[equal_boolean]([sqlserver].[is_system],(0)))), ADD EVENT sqlserver.sql_batch_completed( ACTION(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) WHERE ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) AND [package0].[equal_boolean]([sqlserver].[is_system],(0)))), ADD EVENT sqlserver.sql_statement_completed( ACTION(package0.event_sequence,sqlserver.client_app_name,sqlserver.database_id,sqlserver.plan_handle,sqlserver.query_hash,sqlserver.query_plan_hash,sqlserver.session_id,sqlserver.sql_text,sqlserver.tsql_frame,sqlserver.tsql_stack) WHERE ([package0].[greater_than_uint64]([sqlserver].[database_id],(4)) AND [package0].[equal_boolean]([sqlserver].[is_system],(0)))) ADD TARGET package0.ring_buffer WITH (MAX_MEMORY=4096 KB,EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,MAX_DISPATCH_LATENCY=30 SECONDS,MAX_EVENT_SIZE=0 KB,MEMORY_PARTITION_MODE=NONE,TRACK_CAUSALITY=ON,STARTUP_STATE=OFF) GO
USE AdventureWorks; GO SELECT p.Name AS ProductName, NonDiscountSales = (OrderQty * UnitPrice), Discounts = ((OrderQty * UnitPrice) * UnitPriceDiscount) FROM Production.Product AS p INNER JOIN Sales.SalesOrderDetail AS sod ON p.ProductID = sod.ProductID ORDER BY ProductName DESC; GO
SELECT p.query_plan FROM sys.dm_exec_requests AS r OUTER APPLY sys.dm_exec_text_query_plan( r.plan_handle, r.statement_start_offset, r.statement_end_offset) AS p
SELECT Tag = 1, Parent = NULL, [ShowPlanXML!1!!XMLTEXT] = query_plan FROM sys.dm_exec_text_query_plan( -- set these variables or copy values -- from the results of the above query @plan_handle, @statement_start_offset, @statement_end_offset) FOR XML EXPLICIT
select count(case when Position = count(case when Position = count(case when Position = from ...
SELECT SUM(CASE WHEN Position = SUM(CASE WHEN Position = FROM SomeTable
SELECT * FROM @Users PIVOT ( COUNT(Position) FOR Position IN (Manager, CEO, Employee) ) as p
DECLARE @Users TABLE (Position VARCHAR(10)) INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES( INSERT INTO @Users (Position) VALUES(
DECLARE @tbl TABLE ( id [int] NOT NULL, field [varchar](50) NOT NULL) INSERT INTO @tbl (id, field) SELECT 1, UNION SELECT 2, UNION SELECT 3, UNION SELECT 4, UNION SELECT 5, UNION SELECT 6, UNION SELECT 7, UNION SELECT 8, UNION SELECT 9, SELECT * FROM @tbl SELECT COUNT(1) AS [total] ,COUNT(1) - COUNT(NULLIF([field], ,COUNT(NULLIF([field], ,(COUNT(1) - COUNT(NULLIF([field], FROM @tbl
Select Position, count(*) as from your_table group by Position
ALTER TABLE Employee ALTER COLUMN CityBorn SET DEFAULT
ALTER TABLE Employee ADD CONSTRAINT DF_SomeName DEFAULT N
ALTER TABLE [table name] ADD DEFAULT [DEFAULT VALUE] FOR [NAME OF COLUMN]
IF EXISTS(SELECT * FROM information_schema.columns WHERE table_name= AND Table_schema= BEGIN ALTER TABLE [myDBO].[myTable] ADD DEFAULT 0 FOR [myColumn] --Hoodaticus END
create table table_name ( column_name datatype default );
update orders set BasicHours=0 where BasicHours is null alter table orders add default(0) for BasicHours alter table orders alter column CleanBasicHours decimal(7,2) not null
ALTER TABLE Person11 ADD CONSTRAINT col_1_def DEFAULT
IF object_id( Print ALTER TABLE Employee ADD CONSTRAINT DF_SomeName DEFAULT N END
DECLARE @ConstraintName nvarchar(200) SELECT @ConstraintName = Name FROM SYS.DEFAULT_CONSTRAINTS WHERE PARENT_OBJECT_ID = OBJECT_ID( AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = N AND object_id = OBJECT_ID(N IF @ConstraintName IS NOT NULL EXEC(
ALTER TABLE [table name] ADD DEFAULT [default value] FOR [column name]
-- Drop existing default constraint on Employee.CityBorn DECLARE @default_name varchar(256); SELECT @default_name = [name] FROM sys.default_constraints WHERE parent_object_id=OBJECT_ID( EXEC( -- Add default constraint on Employee.CityBorn ALTER TABLE Employee ADD CONSTRAINT df_employee_1 DEFAULT
select s.name, t.name, i.name, c.name from sys.tables t inner join sys.schemas s on t.schema_id = s.schema_id inner join sys.indexes i on i.object_id = t.object_id inner join sys.index_columns ic on ic.object_id = t.object_id inner join sys.columns c on c.object_id = t.object_id and ic.column_id = c.column_id where i.index_id > 0 and i.type in (1, 2) -- clustered & nonclustered only and i.is_primary_key = 0 -- do not include PK indexes and i.is_unique_constraint = 0 -- do not include UQ and i.is_disabled = 0 and i.is_hypothetical = 0 and ic.key_ordinal > 0 order by ic.key_ordinal
SELECT TableName = t.name, IndexName = ind.name, IndexId = ind.index_id, ColumnId = ic.index_column_id, ColumnName = col.name, ind.*, ic.*, col.* FROM sys.indexes ind INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id and ind.index_id = ic.index_id INNER JOIN sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id INNER JOIN sys.tables t ON ind.object_id = t.object_id WHERE ind.is_primary_key = 0 AND ind.is_unique = 0 AND ind.is_unique_constraint = 0 AND t.is_ms_shipped = 0 ORDER BY t.name, ind.name, ind.index_id, ic.index_column_id;
-- KDF9 -- includes schemas and primary keys, in easy to read format -- with unique, clustered, and all ascending/descendings in a single column -- Needs simple manual add or delete to change maximum number of key columns -- but is easy to understand and modify, with no UDFs or complex logic -- SELECT schema_name(schema_id) as SchemaName, OBJECT_NAME(si.object_id) as TableName, si.name as IndexName, (CASE is_primary_key WHEN 1 THEN (CASE is_unique WHEN 1 THEN (CASE si.type WHEN 1 THEN (CASE INDEXKEY_PROPERTY(si.object_id,index_id,1, (CASE INDEXKEY_PROPERTY(si.object_id,index_id,2, (CASE INDEXKEY_PROPERTY(si.object_id,index_id,3, (CASE INDEXKEY_PROPERTY(si.object_id,index_id,4, (CASE INDEXKEY_PROPERTY(si.object_id,index_id,5, (CASE INDEXKEY_PROPERTY(si.object_id,index_id,6, INDEX_COL(schema_name(schema_id)+ INDEX_COL(schema_name(schema_id)+ INDEX_COL(schema_name(schema_id)+ INDEX_COL(schema_name(schema_id)+ INDEX_COL(schema_name(schema_id)+ INDEX_COL(schema_name(schema_id)+ FROM sys.indexes as si LEFT JOIN sys.objects as so on so.object_id=si.object_id WHERE index_id>0 -- omit the default heap and OBJECTPROPERTY(si.object_id, and not (schema_name(schema_id)= ORDER BY SchemaName,TableName,IndexName ------------------------------------------------------------------- -- or to generate creation scripts put a simple wrapper around that SELECT SchemaName, TableName, IndexName, (CASE pk WHEN (CASE substring(Type,3,1) WHEN ELSE (CASE substring(Type,1,1) WHEN (CASE substring(Type,3,1) WHEN END)+ (CASE WHEN Key1 is null THEN (CASE WHEN Key2 is null THEN (CASE WHEN Key3 is null THEN (CASE WHEN Key4 is null THEN (CASE WHEN Key5 is null THEN (CASE WHEN Key6 is null THEN FROM ( ... ...listing SQL same as above minus the ORDER BY... ... ) as indexes ORDER BY SchemaName,TableName,IndexName ---------------------------------------------------------- -- For SQL Server 2000 the following should work -- change table names to sysindexes and sysobjects (no dots) -- change object_id => id, index_id => indid, -- change is_primary_key => (select count(constid) from sysconstraints as sc where sc.id=si.id and sc.status&15=1) -- change is_unique => INDEXPROPERTY(si.id,si.name, -- change si.type => INDEXPROPERTY(si.id,si.name, -- remove all references to schemas including schema name qualifiers, and the XML type -- add select where indid<255 and si.status&64=0 (to omit the text/image index and autostats)
SELECT OBJECT_SCHEMA_NAME(T.[object_id],DB_ID()) AS [Schema], T.[name] AS [table_name], I.[name] AS [index_name], AC.[name] AS [column_name], I.[type_desc], I.[is_unique], I.[data_space_id], I.[ignore_dup_key], I.[is_primary_key], I.[is_unique_constraint], I.[fill_factor], I.[is_padded], I.[is_disabled], I.[is_hypothetical], I.[allow_row_locks], I.[allow_page_locks], IC.[is_descending_key], IC.[is_included_column] FROM sys.[tables] AS T INNER JOIN sys.[indexes] I ON T.[object_id] = I.[object_id] INNER JOIN sys.[index_columns] IC ON I.[object_id] = IC.[object_id] INNER JOIN sys.[all_columns] AC ON T.[object_id] = AC.[object_id] AND IC.[column_id] = AC.[column_id] WHERE T.[is_ms_shipped] = 0 AND I.[type_desc] <> ORDER BY T.[name], I.[index_id], IC.[key_ordinal]
SELECT S.NAME SCHEMA_NAME,T.NAME TABLE_NAME,I.NAME INDEX_NAME,C.NAME COLUMN_NAME FROM SYS.TABLES T INNER JOIN SYS.SCHEMAS S ON T.SCHEMA_ID = S.SCHEMA_ID INNER JOIN SYS.INDEXES I ON I.OBJECT_ID = T.OBJECT_ID INNER JOIN SYS.INDEX_COLUMNS IC ON IC.OBJECT_ID = T.OBJECT_ID INNER JOIN SYS.COLUMNS C ON C.OBJECT_ID = T.OBJECT_ID **AND IC.INDEX_ID = I.INDEX_ID** AND IC.COLUMN_ID = C.COLUMN_ID WHERE 1=1 ORDER BY I.NAME,I.INDEX_ID,IC.KEY_ORDINAL
select T.name as TableName, I.name as IndexName, AC.Name as ColumnName, I.type_desc as IndexType from sys.tables as T inner join sys.indexes as I on T.[object_id] = I.[object_id] inner join sys.index_columns as IC on IC.[object_id] = I.[object_id] and IC.[index_id] = I.[index_id] inner join sys.all_columns as AC on IC.[object_id] = AC.[object_id] and IC.[column_id] = AC.[column_id] order by T.name, I.name
SELECT INX.[name] AS [Index Name] ,TBL.[name] AS [Table Name] ,DS1.[IndexColumnsNames] ,DS2.[IncludedColumnsNames] FROM [sys].[indexes] INX INNER JOIN [sys].[tables] TBL ON INX.[object_id] = TBL.[object_id] CROSS APPLY ( SELECT STUFF ( ( SELECT FROM [sys].[index_columns] INXCLS INNER JOIN [sys].[columns] CLS ON INXCLS.[object_id] = CLS.[object_id] AND INXCLS.[column_id] = CLS.[column_id] WHERE INX.[object_id] = INXCLS.[object_id] AND INX.[index_id] = INXCLS.[index_id] AND INXCLS.[is_included_column] = 0 FOR XML PATH( ) ,1 ,1 , ) ) DS1 ([IndexColumnsNames]) CROSS APPLY ( SELECT STUFF ( ( SELECT FROM [sys].[index_columns] INXCLS INNER JOIN [sys].[columns] CLS ON INXCLS.[object_id] = CLS.[object_id] AND INXCLS.[column_id] = CLS.[column_id] WHERE INX.[object_id] = INXCLS.[object_id] AND INX.[index_id] = INXCLS.[index_id] AND INXCLS.[is_included_column] = 1 FOR XML PATH( ) ,1 ,1 , ) ) DS2 ([IncludedColumnsNames])
DECLARE @IndexInfo TABLE (index_name varchar(250) ,index_description varchar(250) ,index_keys varchar(250) ) INSERT INTO @IndexInfo exec sp_msforeachtable select * from @IndexInfo
DECLARE @IndexInfoTemp TABLE (index_name varchar(250) ,index_description varchar(250) ,index_keys varchar(250) ) DECLARE @IndexInfo TABLE (table_name sysname ,index_name varchar(250) ,index_description varchar(250) ,index_keys varchar(250) ) DECLARE @Tables Table (RowID int not null identity(1,1) ,TableName sysname ) DECLARE @MaxRow int DECLARE @CurrentRow int DECLARE @CurrentTable sysname INSERT INTO @Tables SELECT DISTINCT t.name FROM sys.indexes i INNER JOIN sys.tables t ON i.object_id = t.object_id WHERE i.Name IS NOT NULL SELECT @MaxRow=@@ROWCOUNT,@CurrentRow=1 WHILE @CurrentRow<=@MaxRow BEGIN SELECT @CurrentTable=TableName FROM @Tables WHERE RowID=@CurrentRow INSERT INTO @IndexInfoTemp exec sp_helpindex @CurrentTable INSERT INTO @IndexInfo (table_name , index_name , index_description , index_keys) SELECT @CurrentTable , index_name , index_description , index_keys FROM @IndexInfoTemp DELETE FROM @IndexInfoTemp SET @CurrentRow=@CurrentRow+1 END --WHILE SELECT * from @IndexInfo
SELECT * FROM @IndexInfo WHERE index_description NOT LIKE SELECT * FROM @IndexInfo WHERE index_description NOT LIKE SELECT * FROM @IndexInfo WHERE index_description LIKE
with connect(schema_name,table_name,index_name,index_column_id,column_name) as ( select s.name schema_name, t.name table_name, i.name index_name, index_column_id, cast(c.name as varchar(max)) column_name from sys.tables t inner join sys.schemas s on t.schema_id = s.schema_id inner join sys.indexes i on i.object_id = t.object_id inner join sys.index_columns ic on ic.object_id = t.object_id and ic.index_id=i.index_id inner join sys.columns c on c.object_id = t.object_id and ic.column_id = c.column_id where index_column_id=1 union all select s.name schema_name, t.name table_name, i.name index_name, ic.index_column_id, cast(connect.column_name + from sys.tables t inner join sys.schemas s on t.schema_id = s.schema_id inner join sys.indexes i on i.object_id = t.object_id inner join sys.index_columns ic on ic.object_id = t.object_id and ic.index_id=i.index_id inner join sys.columns c on c.object_id = t.object_id and ic.column_id = c.column_id join connect on connect.index_column_id+1 = ic.index_column_id and connect.schema_name = s.name and connect.table_name = t.name and connect.index_name = i.name) select connect.schema_name,connect.table_name,connect.index_name,connect.column_name from connect join (select schema_name,table_name,index_name,MAX(index_column_id) index_column_id from connect group by schema_name,table_name,index_name) mx on connect.schema_name = mx.schema_name and connect.table_name = mx.table_name and connect.index_name = mx.index_name and connect.index_column_id = mx.index_column_id order by 1,2,3
SELECT ,+ i.NAME AS ,LOWER(i.type_desc) + CASE WHEN i.is_unique = 1 THEN ELSE END + CASE WHEN i.is_primary_key = 1 THEN ELSE END AS ,STUFF(( SELECT FROM syscolumns AS sc INNER JOIN sys.index_columns AS ic ON ic.object_id = sc.id AND ic.column_id = sc.colid WHERE sc.id = so.object_id AND ic.index_id = i1.indid AND ic.is_included_column = 0 ORDER BY key_ordinal FOR XML PATH( ), 1, 2, ,STUFF(( SELECT FROM syscolumns AS sc INNER JOIN sys.index_columns AS ic ON ic.object_id = sc.id AND ic.column_id = sc.colid WHERE sc.id = so.object_id AND ic.index_id = i1.indid AND ic.is_included_column = 1 FOR XML PATH( ), 1, 2, FROM sysindexes AS i1 INNER JOIN sys.indexes AS i ON i.object_id = i1.id AND i.index_id = i1.indid INNER JOIN sysobjects AS o ON o.id = i1.id INNER JOIN sys.objects AS so ON so.object_id = o.id AND is_ms_shipped = 0 INNER JOIN sys.schemas AS s ON s.schema_id = so.schema_id WHERE so.type = AND i1.indid < 255 AND i1.STATUS & 64 = 0 --index with duplicates AND i1.STATUS & 8388608 = 0 --auto created index AND i1.STATUS & 16777216 = 0 --stats no recompute AND i.type_desc <> AND so.NAME <> ORDER BY table_name ,index_name;
SELECT QUOTENAME(t.name) AS TableName, QUOTENAME(i.name) AS IndexName, i.is_primary_key, i.is_unique, i.is_unique_constraint, STUFF(REPLACE(REPLACE(( SELECT QUOTENAME(c.name) + CASE WHEN ic.is_descending_key = 1 THEN FROM sys.index_columns AS ic INNER JOIN sys.columns AS c ON ic.object_id = c.object_id AND ic.column_id = c.column_id WHERE ic.object_id = i.object_id AND ic.index_id = i.index_id AND ic.is_included_column = 0 ORDER BY ic.key_ordinal FOR XML PATH ), STUFF(REPLACE(REPLACE(( SELECT QUOTENAME(c.name) AS [data()] FROM sys.index_columns AS ic INNER JOIN sys.columns AS c ON ic.object_id = c.object_id AND ic.column_id = c.column_id WHERE ic.object_id = i.object_id AND ic.index_id = i.index_id AND ic.is_included_column = 1 ORDER BY ic.index_column_id FOR XML PATH ), u.user_seeks, u.user_scans, u.user_lookups, u.user_updates FROM sys.tables AS t INNER JOIN sys.indexes AS i ON t.object_id = i.object_id LEFT JOIN sys.dm_db_index_usage_stats AS u ON i.object_id = u.object_id AND i.index_id = u.index_id WHERE t.is_ms_shipped = 0 AND i.type <> 0
SET NOCOUNT ON USE pubs DBCC SHOWCONTIG WITH ALL_INDEXES GO
SET NOCOUNT ON USE pubs DBCC SHOWCONTIG (authors) WITH ALL_INDEXES GO
SET NOCOUNT ON USE pubs DBCC SHOWCONTIG (authors,aunmind) GO
SELECT OBJECT_SCHEMA_NAME(t.[object_id],DB_ID()) AS [Schema], t.[name] AS [TableName], ind.[name] AS [IndexName], col.[name] AS [ColumnName], ic.column_id AS [ColumnId], ind.[type_desc] AS [IndexTypeDesc], col.is_identity AS [IsIdentity], ind.[is_unique] AS [IsUnique], ind.[is_primary_key] AS [IsPrimaryKey], ic.[is_descending_key] AS [IsDescendingKey], ic.[is_included_column] AS [IsIncludedColumn] FROM sys.indexes ind INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id AND ind.index_id = ic.index_id INNER JOIN sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id INNER JOIN sys.tables t ON ind.object_id = t.object_id WHERE t.is_ms_shipped = 0 --ind.is_primary_key = 1 -- include or not pks, etc --AND ind.is_unique = 0 --AND ind.is_unique_constraint = 0 ORDER BY [Schema], TableName, IndexName, [ColumnId], ColumnName
select tab.[name] as [table_name], idx.[name] as [index_name], allc.[name] as [column_name], idx.[type_desc], idx.[is_unique], idx.[data_space_id], idx.[ignore_dup_key], idx.[is_primary_key], idx.[is_unique_constraint], idx.[fill_factor], idx.[is_padded], idx.[is_disabled], idx.[is_hypothetical], idx.[allow_row_locks], idx.[allow_page_locks], idxc.[is_descending_key], idxc.[is_included_column], idxc.[index_column_id] from sys.[tables] as tab inner join sys.[indexes] idx on tab.[object_id] = idx.[object_id] inner join sys.[index_columns] idxc on idx.[object_id] = idxc.[object_id] and idx.[index_id] = idxc.[index_id] inner join sys.[all_columns] allc on tab.[object_id] = allc.[object_id] and idxc.[column_id] = allc.[column_id] where tab.[name] Like and idx.[name] Like order by tab.[name], idx.[index_id], idxc.[index_column_id]
select o.name as ObjectName, i.name as IndexName, i.is_primary_key as [PrimaryKey], SUBSTRING(i.[type_desc],0,6) as IndexType, i.is_unique as [Unique], Columns.[Normal] as IndexColumns, Columns.[Included] as IncludedColumns from sys.indexes i join sys.objects o on i.object_id = o.object_id cross apply ( select substring ( ( select from sys.index_columns ic join sys.columns co on co.object_id = i.object_id and co.column_id = ic.column_id where ic.object_id = i.object_id and ic.index_id = i.index_id and ic.is_included_column = 0 order by ic.key_ordinal for xml path( ) , 3 , 10000 ) as [Normal] , substring ( ( select from sys.index_columns ic join sys.columns co on co.object_id = i.object_id and co.column_id = ic.column_id where ic.object_id = i.object_id and ic.index_id = i.index_id and ic.is_included_column = 1 order by ic.key_ordinal for xml path( ) , 3 , 10000 ) as [Included] ) Columns where o.[type] = order by o.[name], i.[name], i.is_primary_key desc
select CONNECYBY.SCHEMA_NAME,CONNECYBY.TABLE_NAME,CONNECYBY.INDEX_NAME,CONNECYBY.COLUMN_NAME from ( select TABLE_OWNER SCHEMA_NAME,TABLE_NAME,INDEX_NAME,COLUMN_POSITION,trim( from DBA_IND_COLUMNS start with COLUMN_POSITION = 1 connect by TABLE_OWNER = prior TABLE_OWNER and TABLE_NAME = prior TABLE_NAME and INDEX_NAME = prior INDEX_NAME and COLUMN_POSITION = prior COLUMN_POSITION + 1) CONNECYBY join ( select TABLE_OWNER SCHEMA_NAME,TABLE_NAME,INDEX_NAME,max(COLUMN_POSITION) COLUMN_POSITION from DBA_IND_COLUMNS group by TABLE_OWNER,TABLE_NAME,INDEX_NAME) MAX_CONNECYBY on ( CONNECYBY.SCHEMA_NAME = MAX_CONNECYBY.SCHEMA_NAME and CONNECYBY.TABLE_NAME = MAX_CONNECYBY.TABLE_NAME and CONNECYBY.INDEX_NAME = MAX_CONNECYBY.INDEX_NAME and CONNECYBY.COLUMN_POSITION = MAX_CONNECYBY.COLUMN_POSITION) order by CONNECYBY.SCHEMA_NAME,CONNECYBY.TABLE_NAME,CONNECYBY.INDEX_NAME
CONNECTBY(SCHEMA_NAME,TABLE_NAME,INDEX_NAME,INDEX_COLUMN_ID,COLUMN_NAME) as ( select SCHEMAS.NAME SCHEMA_NAME , TABLES.NAME TABLE_NAME , INDEXES.NAME INDEX_NAME , INDEX_COLUMNS.INDEX_COLUMN_ID INDEX_COLUMN_ID , cast(COLUMNS.NAME AS VARCHAR(MAX)) COLUMN_NAME from SYS.INDEXES join SYS.TABLES on (INDEXES.OBJECT_ID = TABLES.OBJECT_ID) join SYS.SCHEMAS on (TABLES.SCHEMA_ID = SCHEMAS.SCHEMA_ID) join SYS.INDEX_COLUMNS on ( INDEXES.OBJECT_ID = INDEX_COLUMNS.OBJECT_ID and INDEX_COLUMNS.INDEX_ID = INDEXES.INDEX_ID) join SYS.COLUMNS on ( INDEXES.OBJECT_ID = COLUMNS.OBJECT_ID and INDEX_COLUMNS.COLUMN_ID = COLUMNS.COLUMN_ID) where INDEX_COLUMNS.INDEX_COLUMN_ID = 1 union all select SCHEMAS.NAME SCHEMA_NAME , TABLES.NAME TABLE_NAME , INDEXES.NAME INDEX_NAME , INDEX_COLUMNS.INDEX_COLUMN_ID INDEX_COLUMN_ID , cast(PRIOR.COLUMN_NAME + from SYS.INDEXES join SYS.TABLES on (INDEXES.OBJECT_ID = TABLES.OBJECT_ID) join SYS.SCHEMAS on (TABLES.SCHEMA_ID = SCHEMAS.SCHEMA_ID) join SYS.INDEX_COLUMNS on ( INDEXES.OBJECT_ID = INDEX_COLUMNS.OBJECT_ID and INDEX_COLUMNS.INDEX_ID = INDEXES.INDEX_ID) join SYS.COLUMNS on ( INDEXES.OBJECT_ID = COLUMNS.OBJECT_ID and INDEX_COLUMNS.COLUMN_ID = COLUMNS.COLUMN_ID) join CONNECTBY as PRIOR on (SCHEMAS.NAME = PRIOR.SCHEMA_NAME and TABLES.NAME = PRIOR.TABLE_NAME and INDEXES.NAME = PRIOR.INDEX_NAME and INDEX_COLUMNS.INDEX_COLUMN_ID = PRIOR.INDEX_COLUMN_ID + 1)) select CONNECTBY.SCHEMA_NAME,CONNECTBY.TABLE_NAME,CONNECTBY.INDEX_NAME,CONNECTBY.COLUMN_NAME from CONNECTBY join ( select SCHEMA_NAME , TABLE_NAME , INDEX_NAME , MAX(INDEX_COLUMN_ID) INDEX_COLUMN_ID from CONNECTBY group by SCHEMA_NAME,TABLE_NAME,INDEX_NAME) MAX_CONNECTBY on (CONNECTBY.SCHEMA_NAME = MAX_CONNECTBY.SCHEMA_NAME and CONNECTBY.TABLE_NAME = MAX_CONNECTBY.TABLE_NAME and CONNECTBY.INDEX_NAME = MAX_CONNECTBY.INDEX_NAME and CONNECTBY.INDEX_COLUMN_ID = MAX_CONNECTBY.INDEX_COLUMN_ID) order by CONNECTBY.SCHEMA_NAME,CONNECTBY.TABLE_NAME,CONNECTBY.INDEX_NAME
SELECT s.[name] AS [schema_name] , t.[name] AS [table_name] , i.[name] AS [index_name] , dbo.Concatenate(CASE WHEN ic.[key_ordinal] > 0 AND ic.[is_descending_key] = 1 THEN c.[name] + , dbo.Concatenate(CASE WHEN ic.[is_included_column] = 1 THEN c.[name] ELSE NULL END, FROM sys.tables t INNER JOIN sys.schemas s ON t.[schema_id] = s.[schema_id] INNER JOIN sys.indexes i ON i.[object_id] = t.[object_id] INNER JOIN sys.index_columns ic ON ic.[object_id] = t.[object_id] AND ic.index_id = i.index_id INNER JOIN sys.columns c ON c.[object_id] = t.[object_id] AND ic.column_id = c.column_id GROUP BY s.[name] , t.[name] , i.[name] ORDER BY s.[name] , t.[name] , i.[name]
select s.name, t.name, i.name, i.index_id,c.name,c.column_id from sys.schemas s inner join sys.tables t on t.schema_id = s.schema_id inner join sys.indexes i on i.object_id = t.object_id inner join sys.index_columns ic on ic.object_id = t.object_id and ic.index_id=i.index_id inner join sys.columns c on c.object_id = t.object_id and ic.column_id = c.column_id where i.object_id = object_id( order by index_id,column_id
SELECT I.name as IndexName, CASE WHEN I.is_unique = 1 THEN I.type_desc COLLATE DATABASE_DEFAULT as Index_Type, STUFF((SELECT FROM sys.index_columns IC INNER JOIN sys.columns C ON IC.object_id = C.object_id AND IC.column_id = C.column_id WHERE IC.is_included_column = 0 AND IC.object_id = I.object_id AND IC.index_id = I.Index_id FOR XML PATH( Included_Columns, I.filter_definition, CASE WHEN I.is_padded = 1 THEN CASE WHEN ST.no_recompute = 0 THEN CONVERT(VARCHAR(5), CASE WHEN I.fill_factor = 0 THEN 100 ELSE I.fill_factor END) as [Fillfactor], CASE WHEN I.ignore_dup_key = 1 THEN CASE WHEN I.allow_row_locks = 1 THEN CASE WHEN I.allow_page_locks = 1 THEN FROM sys.indexes I INNER JOIN sys.tables T ON T.object_id = I.object_id INNER JOIN sys.stats ST ON ST.object_id = I.object_id AND ST.stats_id = I.index_id INNER JOIN sys.data_spaces DS ON I.data_space_id = DS.data_space_id INNER JOIN sys.filegroups FG ON I.data_space_id = FG.data_space_id LEFT OUTER JOIN (SELECT * FROM (SELECT IC2.object_id, IC2.index_id, STUFF((SELECT sys.columns C ON C.object_id = IC1.object_id AND C.column_id = IC1.column_id AND IC1.is_included_column = 1 WHERE IC1.object_id = IC2.object_id AND IC1.index_id = IC2.index_id GROUP BY IC1.object_id, C.name, index_id FOR XML PATH( ), 1, 2, FROM sys.index_columns IC2 GROUP BY IC2.object_id, IC2.index_id) tmp1 WHERE Included_Columns IS NOT NULL ) tmp2 ON tmp2.object_id = I.object_id AND tmp2.index_id = I.index_id WHERE I.is_primary_key = 0 AND I.is_unique_constraint = 0;
SELECT I.name as IndexName, -- Uncommnent line below to include checking for index exists as part of the script -- I.type_desc COLLATE DATABASE_DEFAULT + I.name + (SELECT FROM sys.index_columns IC INNER JOIN sys.columns C ON IC.object_id = C.object_id AND IC.column_id = C.column_id WHERE IC.is_included_column = 0 AND IC.object_id = I.object_id AND IC.index_id = I.Index_id FOR XML PATH( ISNULL( ISNULL( CHAR(13) + CHAR(10) + FROM sys.indexes I INNER JOIN sys.tables T ON T.object_id = I.object_id INNER JOIN sys.stats ST ON ST.object_id = I.object_id AND ST.stats_id = I.index_id INNER JOIN sys.data_spaces DS ON I.data_space_id = DS.data_space_id INNER JOIN sys.filegroups FG ON I.data_space_id = FG.data_space_id LEFT OUTER JOIN (SELECT * FROM (SELECT IC2.object_id, IC2.index_id, STUFF((SELECT sys.columns C ON C.object_id = IC1.object_id AND C.column_id = IC1.column_id AND IC1.is_included_column = 1 WHERE IC1.object_id = IC2.object_id AND IC1.index_id = IC2.index_id GROUP BY IC1.object_id, C.name, index_id FOR XML PATH( ), 1, 2, FROM sys.index_columns IC2 GROUP BY IC2.object_id, IC2.index_id) tmp1 WHERE IncludedColumns IS NOT NULL ) tmp2 ON tmp2.object_id = I.object_id AND tmp2.index_id = I.index_id WHERE I.is_primary_key = 0 AND I.is_unique_constraint = 0
SELECT sys.tables.object_id, sys.tables.name as table_name, sys.columns.name as column_name, sys.indexes.name as index_name, sys.indexes.is_unique, sys.indexes.is_primary_key FROM sys.tables, sys.indexes, sys.index_columns, sys.columns WHERE (sys.tables.object_id = sys.indexes.object_id AND sys.tables.object_id = sys.index_columns.object_id AND sys.tables.object_id = sys.columns.object_id AND sys.indexes.index_id = sys.index_columns.index_id AND sys.index_columns.column_id = sys.columns.column_id) AND sys.tables.name =
select t.name TableName, i.name IdxName, c.name ColName , ic.index_column_id ColPosition , i.type_desc Type , case when i.is_primary_key = 1 then , case when i.is_unique = 1 then , case when ic.is_included_column = 0 then , , ic.*, , t.*, from sys.index_columns ic join sys.tables t on t.object_id = ic.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = ic.column_id join sys.indexes i on i.object_id = t.object_id and i.index_id = ic.index_id order by TableName, IdxName, ColPosition
SELECT TableName = t.name, ColumnId = col.column_id, ColumnName = col.name, DataType = ty.name, MaxSize = ty.max_length, IsNullable = CASE WHEN (col.is_nullable = 1) THEN IsIdentity = CASE WHEN (col.is_identity = 1) THEN IsPrimaryKey = CASE WHEN (ic.column_id = col.column_id) THEN IsForeignKey = CASE WHEN (fkc.parent_column_id = col.column_id) THEN IsDefault = CASE WHEN (dc.parent_column_id = col.column_id) THEN FROM sys.tables t INNER JOIN sys.columns col ON t.object_id = col.object_id LEFT JOIN sys.indexes ind ON t.object_id = ind.object_id LEFT JOIN sys.index_columns ic ON ic.index_id=ind.index_id AND ic.object_id = col.object_id and ic.column_id = col.column_id LEFT JOIN sys.foreign_key_columns fkc ON fkc.parent_object_id = col.object_id AND fkc.parent_column_id=col.column_id LEFT JOIN sys.default_constraints dc ON dc.parent_object_id = col.object_id AND dc.parent_column_id=col.column_id LEFT JOIN sys.types ty on ty.user_type_id = col.user_type_id WHERE --t.name= t.schema_id = 10 --SCHEMA ID AND ind.is_primary_key=1 ORDER BY t.name, ColumnId
sELECT TableName = t.name, IndexName = ind.name, --IndexId = ind.index_id, ColumnId = ic.index_column_id, ColumnName = col.name, key_ordinal, ind.type_desc --ind.*, --ic.*, --col.* FROM sys.indexes ind INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id and ind.index_id = ic.index_id INNER JOIN sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id INNER JOIN sys.tables t ON ind.object_id = t.object_id WHERE ind.is_primary_key = 0 AND ind.is_unique = 0 AND ind.is_unique_constraint = 0 AND t.is_ms_shipped = 0 and t.name= and key_ordinal>0 ORDER BY t.name, ind.name, ind.index_id, ic.index_column_id
ALTER TABLE TableName ALTER COLUMN ColumnName NVARCHAR(200) [NULL | NOT NULL]
ALTER TABLE <schemaName>.<tableName> ALTER COLUMN <columnName> nvarchar(200) [NULL|NOT NULL]
Alter table TableName Alter Column ColumnName nvarchar(100)
ALTER TABLE table_name ALTER COLUMN column_name column_type;
ALTER TABLE employees ALTER COLUMN last_name VARCHAR(75) NOT NULL;
alter table table_name alter column column_name datatype [NULL|NOT NULL]
ALTER TABLE table_name ADD CONSTRAINT PK_MyTable PRIMARY KEY (column_name)
ALTER TABLE "table_name" MODIFY "column_name" "New Data Type";
CONVERT(SomeType, SomeReallyLongExpression + ThatMayEvenSpan + MultipleLines )
CAST(SomeReallyLongExpression + ThatMayEvenSpan + MultipleLines AS SomeType )
create view MyView1 as select Id,Name from table1 go create view MyView2 as select Id,Name from table1 go select * from MyView1 select * from MyView2
Select * from employees; GO -- GO 1 update employees set empID=21 where empCode=123; GO -- GO 2
DECLARE @myInt INT = 1; -- One way using a standard numeric format string PRINT FORMAT(@myInt, -- Other way using a custom numeric format string PRINT FORMAT(@myInt,
declare @x int = 123 -- value to be padded declare @width int = 25 -- desired width declare @pad char(1) = select right_justified = replicate( @pad , @width-len(convert(varchar(100),@x)) ) + convert(varchar(100),@x)
declare @x float = -1.234 declare @width int = 20 declare @pad char(1) = select right_justified = stuff( convert(varchar(99),@x) , -- source string (converted from numeric value) case when @x < 0 then 2 else 1 end , -- insert position 0 , -- count of characters to remove from source string replicate(@pad,@width-len(convert(varchar(99),@x)) ) -- text to be inserted )
CREATE FUNCTION dbo.fnNumPadLeft (@input INT, @pad tinyint) RETURNS VARCHAR(250) AS BEGIN DECLARE @NumStr VARCHAR(250) SET @NumStr = LTRIM(@input) IF(@pad > LEN(@NumStr)) SET @NumStr = REPLICATE( RETURN @NumStr; END
SELECT [dbo].[fnNumPadLeft] (2016,10) -- returns 0000002016 SELECT [dbo].[fnNumPadLeft] (2016,5) -- returns 02016 SELECT [dbo].[fnNumPadLeft] (2016,2) -- returns 2016 SELECT [dbo].[fnNumPadLeft] (2016,0) -- returns 2016
declare @charInput as char(50) = --always handle NULL :) set @charInput = isnull(@charInput, declare @actualLength as int = len(@charInput) declare @pattern as char(50) = declare @prefLength as int = len(@pattern) if @prefLength > @actualLength select Left(Left(@pattern, @prefLength-@actualLength) + @charInput, @prefLength) else select @charInput
declare @value as nvarchar(50) = 23 select REPLACE(STR(CAST(@value AS INT) + 1,4), SPACE(1),
declare @val varchar(5) declare @maxSpaces int set @maxSpaces = 3 set @val = select concat(REPLICATE(
col1 col2 col3 col4 col5 col6 col7 john 1 1 1 1 1 1 john 1 1 1 1 1 1 sally 2 2 2 2 2 2 sally 2 2 2 2 2 2
DELETE FROM table WHERE col1 IN ( SELECT id FROM table GROUP BY id HAVING ( COUNT(col1) > 1 ) )
WITH CTE AS( SELECT [col1], [col2], [col3], [col4], [col5], [col6], [col7], RN = ROW_NUMBER()OVER(PARTITION BY col1 ORDER BY col1) FROM dbo.Table1 ) DELETE FROM CTE WHERE RN > 1
COL1 COL2 COL3 COL4 COL5 COL6 COL7 john 1 1 1 1 1 1 sally 2 2 2 2 2 2
ROW_NUMBER()OVER(PARTITION BY Col1, Col2, ... ORDER BY OrderColumn)
WITH CTE AS ( SELECT *,ROW_NUMBER() OVER (PARTITION BY col1,col2,col3 ORDER BY col1,col2,col3) AS RN FROM MyTable ) DELETE FROM CTE WHERE RN<>1
WITH CTE AS (SELECT *,R=RANK() OVER (ORDER BY col1,col2,col3) FROM MyTable) DELETE CTE WHERE R IN (SELECT R FROM CTE GROUP BY R HAVING COUNT(*)>1)
DELETE FROM MyDuplicateTable WHERE ID NOT IN ( SELECT MAX(ID) FROM MyDuplicateTable GROUP BY DuplicateColumn1, DuplicateColumn2, DuplicateColumn3)
DELETE from search where id not in ( select min(id) from search group by url having count(*)=1 union SELECT min(id) FROM search group by url having count(*) > 1 )
SET rowcount 1; DELETE FROM t1 WHERE myprimarykey=1;
Declare @table table (col1 varchar(10),col2 int,col3 int, col4 int, col5 int, col6 int, col7 int) Insert into @table values ( ( ( (
Delete aliasName from ( Select *, ROW_NUMBER() over (Partition by col1,col2,col3,col4,col5,col6,col7 order by col1) as rowNumber From @table) aliasName Where rowNumber > 1 Select * from @table
While ((@PageNumber - 1) * @RowspPage < @TotalRows ) Begin begin transaction tran_inner ; with cte as ( SELECT * FROM LargeSourceTable_TEMP ORDER BY ID OFFSET ((@PageNumber) * @RowspPage) ROWS FETCH NEXT @RowspPage ROWS ONLY ) INSERT INTO LargeSourceTable ( ID ,[CreateDate] ,[Column1] ,[Column2] ,[Column3] ) select ID ,[CreateDate] ,[Column1] ,[Column2] ,[Column3] from cte commit transaction tran_inner PRINT PRINT PRINT SELECT @dt = convert(varchar(19), getdate(), 121) RAISERROR( SET @PageNumber = @PageNumber + 1 End
-- this query will keep only one instance of a duplicate record. ;WITH cte AS (SELECT ROW_NUMBER() OVER (PARTITION BY col1, col2, col3-- based on what? --can be multiple columns ORDER BY ( SELECT 0)) RN FROM Mytable) delete FROM cte WHERE RN > 1
with myCTE as ( select productName,ROW_NUMBER() over(PARTITION BY productName order by slno) as Duplicate from productDetails ) Delete from myCTE where Duplicate>1
ALTER TABLE dbo.DUPPEDTABLE ADD RowID INT NOT NULL IDENTITY(1,1)
DELETE b FROM dbo.DUPPEDTABLE b WHERE b.RowID NOT IN ( SELECT MIN(RowID) AS RowID FROM dbo.DUPPEDTABLE a WITH (NOLOCK) GROUP BY a.ITEM_NUMBER, a.CHARACTERISTIC, a.INTVALUE, a.FLOATVALUE, a.STRINGVALUE );
SELECT a.ITEM_NUMBER, a.CHARACTERISTIC, a.INTVALUE, a.FLOATVALUE, a.STRINGVALUE, COUNT(*)--MIN(RowID) AS RowID FROM dbo.DUPPEDTABLE a WITH (NOLOCK) GROUP BY a.ITEM_NUMBER, a.CHARACTERISTIC, a.INTVALUE, a.FLOATVALUE, a.STRINGVALUE ORDER BY COUNT(*) DESC
delete from dublicated_table t1 (nolock) join ( select t2.dublicated_field , min(len(t2.field_kept)) as min_field_kept from dublicated_table t2 (nolock) group by t2.dublicated_field having COUNT(*)>1 ) t3 on t1.dublicated_field=t3.dublicated_field and len(t1.field_kept)=t3.min_field_kept
SET rowcount n-1 DELETE FROM your_table WHERE (spacial condition)
DELETE FROM table WHERE col1 IN ( SELECT MAX(id) FROM table GROUP BY id HAVING ( COUNT(col1) > 1 ) )
select * from DatabaseName.information_schema.routines where routine_type =
select * from master.information_schema.routines where routine_type = and Left(Routine_Name, 3) NOT IN (
SELECT name, type FROM dbo.sysobjects WHERE (type =
select * from information_schema.routines where routine_type =
SELECT name, type FROM dbo.sysobjects WHERE type IN ( ) ORDER BY type, name
select * from sys.procedures where is_ms_shipped = 0
SELECT * FROM information_schema.routines WHERE ROUTINE_TYPE =
CREATE TABLE ( DBName varchar(100), [OBJECT_ID] INT, SPName varchar(100) ) EXEC sp_msforeachdb SELECT * FROM
select name,type,type_desc from sys.objects where type in ( order by name,type
SELECT * FROM sys.objects WHERE objectproperty(object_id, N AND objectproperty(object_id, N
select * from dbo.sysobjects where xtype = and status > 0
Use [YourDataBase] EXEC sp_tables @table_type = " EXEC sp_tables @table_type = " EXEC sp_tables @table_type = "
SELECT * FROM information_schema.tables SELECT * FROM information_schema.VIEWS
use << database name >> go declare @aQuery nvarchar(1024); declare @spName nvarchar(64); declare allSP cursor for select p.name from sys.procedures p where p.type_desc = open allSP; fetch next from allSP into @spName; while (@@FETCH_STATUS = 0) begin set @aQuery = exec sp_executesql @aQuery; fetch next from allSP; end; close allSP; deallocate allSP;
select specific_name from information_schema.routines where routine_type =
use <<databasename>> go declare @aQuery nvarchar(1024); declare @spName nvarchar(64); declare allSP cursor for select p.name from sys.procedures p where p.type_desc = and LEFT(p.name,3) NOT IN ( order by p.name; open allSP; fetch next from allSP into @spName; while (@@FETCH_STATUS = 0) begin set @aQuery = exec sp_executesql @aQuery; fetch next from allSP into @spName; end; close allSP; deallocate allSP;
SELECT SPECIFIC_NAME FROM YOUR_DB_NAME.information_schema.routines WHERE routine_type =
Select * FROM sys.procedures where [type] = AND is_ms_shipped = 0 AND [name] not like
select * from DatabaseName.INFORMATION_SCHEMA.ROUTINES where routine_type = select * from DatabaseName.INFORMATION_SCHEMA.ROUTINES where routine_type = SELECT name, type FROM dbo.sysobjects WHERE (type =
SELECT o. object_id,o.name AS name,o.type_desc,m.definition,schemas.name scheamaName FROM sys.sql_modules m INNER JOIN sys.objects o ON m.object_id=o.OBJECT_ID INNER JOIN sys.schemas ON schemas.schema_id = o.schema_id WHERE [TYPE]=
USE DBNAME select ROUTINE_NAME from information_schema.routines where routine_type = GO
select customerId, count(*) as orderCount from Orders group by customerId
select row_number() over (partition by customerId order by orderId) as OrderNumberForThisCustomer from Orders
id firstname lastname Mark ------------------------------------------------------------------- 1 arun prasanth 40 2 ann antony 45 3 sruthy abc 41 6 new abc 47 1 arun prasanth 45 1 arun prasanth 49 2 ann antony 49
SELECT expression1, expression2, ... expression_n, aggregate_function (aggregate_expression) FROM tables WHERE conditions GROUP BY expression1, expression2, ... expression_n;
select SUM(Mark)marksum,firstname from TableA group by id,firstName
marksum firstname ---------------- 94 ann 134 arun 47 new 41 sruthy
select SUM(Mark) OVER (PARTITION BY id) AS marksum, firstname from TableA
marksum firstname ------------------- 134 arun 134 arun 134 arun 94 ann 94 ann 41 sruthy 47 new
select name,count(*) as totalcount from person where name=
select row_number() over (partition by name) as total from person where name =
-- BELOW IS A SAMPLE WHICH OUTLINES THE SIMPLE DIFFERENCES -- READ IT AND THEN EXECUTE IT -- THERE ARE THREE ROWS OF EACH COLOR INSERTED INTO THE TABLE -- CREATE A database called testDB -- use testDB USE [TestDB] GO -- create Paints table CREATE TABLE [dbo].[Paints]( [Color] [varchar](50) NULL, [glossLevel] [varchar](50) NULL ) ON [PRIMARY] GO -- Populate Table insert into paints (color, glossLevel) select union select union select union select union select union select union select union select union select union select union select union select union select union select union select union select union select union select union select union select union select /* COMPARE -- GROUP BY Color -- row quantity defined by group by -- aggregate (count(*)) defined by group by select count(*) from paints group by color -- OVER (PARTITION BY... Color -- row quantity defined by main query -- aggregate defined by OVER-PARTITION BY select color , glossLevel , count(*) OVER (Partition by color) from paints /* COMPARE -- GROUP BY Color, GlossLevel -- row quantity defined by GROUP BY -- aggregate (count(*)) defined by GROUP BY select count(*) from paints group by color, glossLevel -- Partition by Color, GlossLevel -- row quantity defined by main query -- aggregate (count(*)) defined by OVER-PARTITION BY select color , glossLevel , count(*) OVER (Partition by color, glossLevel) from paints
WHERE something LIKE OR something LIKE OR something LIKE
SQL> create table mytable (something) 2 as 3 select 4 select 5 select 6 select 7 select 8 / Table created.
SQL> select something 2 from mytable 3 where something like 4 or something like 5 or something like 6 / SOMETH ------ blabla ofooof batzzz 3 rows selected.
SQL> select something 2 from mytable 3 where regexp_like (something, 4 / SOMETH ------ blabla ofooof batzzz 3 rows selected.
WHERE something LIKE OR something LIKE OR something LIKE
FROM YourTable y INNER JOIN YourTempTable t On y.something LIKE t.something
declare @x table (x varchar(10)) declare @y table (y varchar(10)) insert @x values ( insert @x values ( insert @x values ( insert @y values ( insert @y values ( select distinct * FROM @x x WHERE x.x LIKE or x.x LIKE select distinct x.* FROM @x x INNER JOIN @y y On x.x LIKE y.y
x ---------- abcdefg abc (2 row(s) affected) x ---------- abc abcdefg (2 row(s) affected)
SELECT Fish.* from Fish JOIN dbo.Split( on Name like Splits.items
WHERE EXISTS (SELECT 1 FROM (SELECT SELECT SELECT WHERE something LIKE pattern)
SELECT ... FROM SomeTable JOIN (SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT ) AS Patterns ON SomeTable.SomeColumn LIKE Patterns.Pattern
CREATE FUNCTION [dbo].[fn_Split](@text varchar(8000), @delimiter varchar(20)) RETURNS @Strings TABLE ( position int IDENTITY PRIMARY KEY, value varchar(8000) ) AS BEGIN DECLARE @index int SET @index = -1 WHILE (LEN(@text) > 0) BEGIN SET @index = CHARINDEX(@delimiter , @text) IF (@index = 0) AND (LEN(@text) > 0) BEGIN INSERT INTO @Strings VALUES (@text) BREAK END IF (@index > 1) BEGIN INSERT INTO @Strings VALUES (LEFT(@text, @index - 1)) SET @text = RIGHT(@text, (LEN(@text) - @index)) END ELSE SET @text = RIGHT(@text, (LEN(@text) - @index)) END RETURN END
select * from my_table inner join (select value from fn_split( as split_table on my_table.column_name like
Select * from TB_YOUR T1 Where SUBSTRING(T1.Something, 1,3) IN (
select * from database.table where lower(drug_name) like any (
-- @gender is nchar(1), @birthDate is date declare @sql nvarchar(MAX), @subWhere nvarchar(MAX) @params nvarchar(MAX) -- prepare the where sub-clause to cover LIKE IN (...) -- it will actually generate where clause PersonName Like set @subWhere = STUFF( ( SELECT FROM [NamesToSelect] t FOR XML PATH( ), 1, 4, -- create the dynamic SQL set @sql = PersonName ,Gender ,BirstDate -- and other field here from [Persons] where Gender = @gender AND BirthDate = @birthDate AND ( set @params = @birthDate Date EXECUTE sp_executesql @sql, @params, @gender, @birthDate
WHERE EXISTS (SELECT 1 FROM TABLE(ku$_vcnt( WHERE something LIKE column_value)
CREATE TYPE my_collection AS TABLE OF VARCHAR2(4000);
SELECT [name] ,[userID] ,[name] ,[town] ,[email] FROM usr join (values (
┌──────────────────────────────┬────────────────────────────────────┐ │ THIS expression … │ IS equivalent to this expression … │ ├──────────────────────────────┼────────────────────────────────────┤ │ x LIKE ALL ( │ │ AND x LIKE │ │ AND x LIKE │ │ │ │ x LIKE ANY ( │ │ OR x LIKE │ │ OR x LIKE └──────────────────────────────┴────────────────────────────────────┘
DECLARE @ARC_CHECKNUM VARCHAR(MAX) SET @ARC_CHECKNUM = SELECT
SELECT FROM dual WHERE REGEXP_LIKE( RESULT --------------------------------- Success !!! 1 row selected.
three=one OR three=two OR three=three OR three=four OR three=five
SELECT FROM dual WHERE REGEXP_LIKE( no rows selected
DECLARE @dashboard nvarchar(50) SET @dashboard = SELECT * from Project p JOIN STRING_SPLIT(@dashboard,
--=========== -- CHECK ONE --=========== SELECT * FROM Random_Table A WHERE (Lower(A.TRAN_1_DSC) LIKE ( OR Lower(A.TRAN_1_DSC) LIKE ( OR Lower(A.TRAN_1_DSC) LIKE ( ; --=========== -- CHECK TWO --=========== SELECT * FROM Random_Table A WHERE Lower(A.TRAN_1_DSC) LIKE ANY (
SELECT table_name, RAND() magic_number FROM information_schema.tables
SELECT table_name, 1.0 + floor(14 * RAND(convert(varbinary, newid()))) magic_number FROM information_schema.tables
select CAST(CRYPT_GEN_RANDOM(8) AS bigint) % 1000000000 / 1000000000.0
SELECT ABS(CAST(CAST(NEWID() AS VARBINARY) AS INT)) AS [RandomNumber]
if object_id( begin drop view cr_sample_randView end go create view cr_sample_randView as select rand() as random_number go
if object_id( begin drop function cr_sample_fnPerRowRand end go create function cr_sample_fnPerRowRand() returns float as begin declare @returnValue float select @returnValue = random_number from cr_sample_randView return @returnValue end go
select rand(200); -- see the rand() function with cte(id) as (select row_number() over(order by object_id) from sys.all_objects) select id, dbo.cr_sample_fnPerRowRand() from cte where id <= 1000 -- limit the results to 1000 random numbers
SELECT table_name, newid() magic_number FROM information_schema.tables
SELECT table_name, ntile(14) over(order by newId()) randomNumber FROM information_schema.tables
select randomNumber, count(*) ct from group by randomNumber
select ABS(CAST(CAST(NEWID() AS VARBINARY) AS INT)) as [Randomizer]
DROP VIEW IF EXISTS vwGetNewNumber; GO Create View vwGetNewNumber as Select CAST(RAND(CHECKSUM(NEWID())) * 62 as INT) + 1 as NextID, ---------------CTDE_GENERATE_PUBLIC_KEY ----------------- DROP FUNCTION IF EXISTS CTDE_GENERATE_PUBLIC_KEY; GO create function CTDE_GENERATE_PUBLIC_KEY() RETURNS NVARCHAR(32) AS BEGIN DECLARE @private_key NVARCHAR(32); set @private_key = dbo.CTDE_GENERATE_32_BIT_KEY(); return @private_key; END; go ---------------CTDE_GENERATE_32_BIT_KEY ----------------- DROP FUNCTION IF EXISTS CTDE_GENERATE_32_BIT_KEY; GO CREATE function CTDE_GENERATE_32_BIT_KEY() RETURNS NVARCHAR(32) AS BEGIN DECLARE @public_key NVARCHAR(32); DECLARE @alpha_num NVARCHAR(62); DECLARE @start_index INT = 0; DECLARE @i INT = 0; select top 1 @alpha_num = alpha_num from vwGetNewNumber; WHILE @i < 32 BEGIN select top 1 @start_index = NextID from vwGetNewNumber; set @public_key = concat (substring(@alpha_num,@start_index,1),@public_key); set @i = @i + 1; END; return @public_key; END; select dbo.CTDE_GENERATE_PUBLIC_KEY() public_key;
CREATE TABLE R ( Number int ) DECLARE @rv FLOAT; SELECT @rv = rand(); INSERT INTO dbo.R (Number) values((@rv * 100)); SELECT * FROM R
DECLARE @name VARCHAR(128) DECLARE @SQL VARCHAR(254) SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = WHILE @name is not null BEGIN SELECT @SQL = EXEC (@SQL) PRINT SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = END GO DECLARE @name VARCHAR(128) DECLARE @SQL VARCHAR(254) SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = WHILE @name IS NOT NULL BEGIN SELECT @SQL = EXEC (@SQL) PRINT SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = END GO DECLARE @name VARCHAR(128) DECLARE @SQL VARCHAR(254) SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] IN (N WHILE @name IS NOT NULL BEGIN SELECT @SQL = EXEC (@SQL) PRINT SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] IN (N END GO DECLARE @name VARCHAR(128) DECLARE @constraint VARCHAR(254) DECLARE @SQL VARCHAR(254) SELECT @name = (SELECT TOP 1 TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = WHILE @name is not null BEGIN SELECT @constraint = (SELECT TOP 1 CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = WHILE @constraint IS NOT NULL BEGIN SELECT @SQL = EXEC (@SQL) PRINT SELECT @constraint = (SELECT TOP 1 CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = END SELECT @name = (SELECT TOP 1 TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = END GO DECLARE @name VARCHAR(128) DECLARE @constraint VARCHAR(254) DECLARE @SQL VARCHAR(254) SELECT @name = (SELECT TOP 1 TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = WHILE @name IS NOT NULL BEGIN SELECT @constraint = (SELECT TOP 1 CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = WHILE @constraint is not null BEGIN SELECT @SQL = EXEC (@SQL) PRINT SELECT @constraint = (SELECT TOP 1 CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = END SELECT @name = (SELECT TOP 1 TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = END GO DECLARE @name VARCHAR(128) DECLARE @SQL VARCHAR(254) SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = WHILE @name IS NOT NULL BEGIN SELECT @SQL = EXEC (@SQL) PRINT SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = END GO
declare @n char(1) set @n = char(10) declare @stmt nvarchar(max) -- procedures select @stmt = isnull( @stmt + @n, from sys.procedures -- check constraints select @stmt = isnull( @stmt + @n, from sys.check_constraints -- functions select @stmt = isnull( @stmt + @n, from sys.objects where type in ( -- views select @stmt = isnull( @stmt + @n, from sys.views -- foreign keys select @stmt = isnull( @stmt + @n, from sys.foreign_keys -- tables select @stmt = isnull( @stmt + @n, from sys.tables -- user defined types select @stmt = isnull( @stmt + @n, from sys.types where is_user_defined = 1 exec sp_executesql @stmt
PRINT GO ------------------------------------------ -- Drop constraints ------------------------------------------ DECLARE @Sql NVARCHAR(500) DECLARE @Cursor CURSOR SET @Cursor = CURSOR FAST_FORWARD FOR SELECT DISTINCT sql = FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc1 LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc2 ON tc2.CONSTRAINT_NAME =rc1.CONSTRAINT_NAME OPEN @Cursor FETCH NEXT FROM @Cursor INTO @Sql WHILE (@@FETCH_STATUS = 0) BEGIN PRINT @Sql Exec (@Sql) FETCH NEXT FROM @Cursor INTO @Sql END CLOSE @Cursor DEALLOCATE @Cursor GO ------------------------------------------ -- Drop views ------------------------------------------ DECLARE @sql VARCHAR(MAX) = , @crlf VARCHAR(2) = CHAR(13) + CHAR(10) ; SELECT @sql = @sql + FROM sys.views v PRINT @sql; EXEC(@sql); GO ------------------------------------------ -- Drop procs ------------------------------------------ PRINT GO DECLARE @sql VARCHAR(MAX) = , @crlf VARCHAR(2) = CHAR(13) + CHAR(10) ; SELECT @sql = @sql + FROM [sys].[procedures] p PRINT @sql; EXEC(@sql); GO ------------------------------------------ -- Drop tables ------------------------------------------ PRINT GO EXEC sp_MSForEachTable GO ------------------------------------------ -- Drop sequences ------------------------------------------ PRINT GO DECLARE @DropSeqSql varchar(1024) DECLARE DropSeqCursor CURSOR FOR SELECT DISTINCT FROM INFORMATION_SCHEMA.SEQUENCES s OPEN DropSeqCursor FETCH NEXT FROM DropSeqCursor INTO @DropSeqSql WHILE ( @@FETCH_STATUS <> -1 ) BEGIN PRINT @DropSeqSql EXECUTE( @DropSeqSql ) FETCH NEXT FROM DropSeqCursor INTO @DropSeqSql END CLOSE DropSeqCursor DEALLOCATE DropSeqCursor GO ------------------------------------------ -- Drop Schemas ------------------------------------------ DECLARE @schemas as varchar(1000) = DECLARE @schemasXml as xml = cast(( DECLARE @Sql NVARCHAR(500) DECLARE @Cursor CURSOR SET @Cursor = CURSOR FAST_FORWARD FOR SELECT sql = (SELECT CAST(T.schemaName.query( JOIN information_schema.schemata S on S.schema_name = X.schemaName OPEN @Cursor FETCH NEXT FROM @Cursor INTO @Sql WHILE (@@FETCH_STATUS = 0) BEGIN PRINT @Sql Exec (@Sql) FETCH NEXT FROM @Cursor INTO @Sql END CLOSE @Cursor DEALLOCATE @Cursor GO
DECLARE mycur CURSOR FOR select O.type_desc,schema_id,O.name from sys.objects O LEFT OUTER JOIN sys.extended_properties E ON O.object_id = E.major_id WHERE O.name IS NOT NULL AND ISNULL(O.is_ms_shipped, 0) = 0 AND ISNULL(E.name, AND ( O.type_desc = ORDER BY O.type_desc,O.name; OPEN mycur; DECLARE @schema_id int; DECLARE @fname varchar(256); DECLARE @sname varchar(256); DECLARE @ftype varchar(256); FETCH NEXT FROM mycur INTO @ftype, @schema_id, @fname; WHILE @@FETCH_STATUS = 0 BEGIN SET @sname = SCHEMA_NAME( @schema_id ); IF @ftype = EXEC( IF @ftype = EXEC( FETCH NEXT FROM mycur INTO @ftype, @schema_id, @fname; END CLOSE mycur DEALLOCATE mycur GO
DECLARE @name VARCHAR(128) DECLARE @SQL VARCHAR(254) SELECT @name = (SELECT TOP 1 [name] FROM sys.types where is_user_defined = 1 ORDER BY [name]) WHILE @name IS NOT NULL BEGIN SELECT @SQL = EXEC (@SQL) PRINT SELECT @name = (SELECT TOP 1 [name] FROM sys.types where is_user_defined = 1 AND [name] > @name ORDER BY [name]) END GO
declare @procName varchar(500) declare cur cursor for select [name] from sys.objects where type = open cur fetch next from cur into @procName while @@fetch_status = 0 begin exec( fetch next from cur into @procName end close cur deallocate cur
DECLARE @name VARCHAR(128) DECLARE @SQL VARCHAR(254) SELECT @name = (select TOP 1 [name] from sys.types where is_user_defined = 1) WHILE @name IS NOT NULL BEGIN SELECT @SQL = EXEC (@SQL) PRINT SELECT @name = (select TOP 1 [name] from sys.types where is_user_defined = 1) END GO
DECLARE @name VARCHAR(255) DECLARE @type VARCHAR(10) DECLARE @prefix VARCHAR(255) DECLARE @sql VARCHAR(255) DECLARE curs CURSOR FOR SELECT [name], xtype FROM sysobjects WHERE xtype IN ( ORDER BY name OPEN curs FETCH NEXT FROM curs INTO @name, @type WHILE @@FETCH_STATUS = 0 BEGIN -- Configuration point 2 SET @prefix = CASE @type WHEN WHEN WHEN WHEN WHEN WHEN WHEN END SET @sql = @prefix + PRINT @sql EXEC(@sql) FETCH NEXT FROM curs INTO @name, @type END CLOSE curs DEALLOCATE curs
EXEC sp_MSforeachtable @command1="ALTER TABLE ? NOCHECK CONSTRAINT ALL" EXEC sp_MSforeachtable @command1="ALTER TABLE ? DISABLE TRIGGER ALL"
DECLARE CURSOR IX IS SELECT * FROM ALL_OBJECTS WHERE OBJECT_TYPE = AND OWNER= CURSOR IY IS SELECT * FROM ALL_OBJECTS WHERE OBJECT_TYPE IN ( CURSOR IZ IS SELECT * FROM ALL_OBJECTS WHERE OBJECT_TYPE IN ( BEGIN FOR X IN IX LOOP EXECUTE IMMEDIATE( END LOOP; FOR Y IN IY LOOP EXECUTE IMMEDIATE( END LOOP; FOR Z IN IZ LOOP EXECUTE IMMEDIATE( END LOOP; END; /
SELECT union ALL select where object_type in ( union ALL SELECT ||object_type || || object_name || FROM user_objects WHERE object_type IN (
USE DATABASE GO DECLARE @tname VARCHAR(150) DECLARE @strsql VARCHAR(300) SELECT @tname = (SELECT TOP 1 [name] FROM sys.objects WHERE [type] = WHILE @tname IS NOT NULL BEGIN SELECT @strsql = EXEC (@strsql) PRINT SELECT @tname = (SELECT TOP 1 [name] FROM sys.objects WHERE [type] = END
SELECT ROUTINE_NAME, ROUTINE_DEFINITION FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_DEFINITION LIKE AND ROUTINE_TYPE=
SELECT OBJECT_NAME(id) FROM SYSCOMMENTS WHERE [text] LIKE AND OBJECTPROPERTY(id, GROUP BY OBJECT_NAME(id)
SELECT OBJECT_NAME(object_id) FROM sys.sql_modules WHERE OBJECTPROPERTY(object_id, AND definition LIKE
DECLARE @SearchText varchar(1000) = SELECT DISTINCT SPName FROM ( (SELECT ROUTINE_NAME SPName FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_DEFINITION LIKE AND ROUTINE_TYPE= UNION ALL (SELECT OBJECT_NAME(id) SPName FROM SYSCOMMENTS WHERE [text] LIKE AND OBJECTPROPERTY(id, GROUP BY OBJECT_NAME(id)) UNION ALL (SELECT OBJECT_NAME(object_id) SPName FROM sys.sql_modules WHERE OBJECTPROPERTY(object_id, AND definition LIKE ) AS T ORDER BY T.SPName
SELECT ROUTINE_NAME, ROUTINE_DEFINITION FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_DEFINITION LIKE AND ROUTINE_TYPE=
SELECT DISTINCT SCHEMA_NAME(o.schema_id),o.name,[text] FROM syscomments AS c INNER JOIN sys.objects AS o ON c.id = o.[object_id] INNER JOIN sys.schemas AS s ON o.schema_id = s.schema_id WHERE text LIKE ORDER BY SCHEMA_NAME(o.schema_id),o.name
SELECT SCHEMA_NAME(O.SCHEMA_ID) [SCHEMA_NAME], O.NAME, OBJECT_DEFINITION(OBJECT_ID) TEXT FROM SYSCOMMENTS AS C INNER JOIN SYS.OBJECTS AS O ON C.ID = O.[OBJECT_ID] INNER JOIN SYS.SCHEMAS AS S ON O.SCHEMA_ID = S.SCHEMA_ID WHERE OBJECT_DEFINITION(OBJECT_ID) LIKE ORDER BY SCHEMA_NAME(O.SCHEMA_ID), O.NAME
select * from sys.procedures p join sys.syscomments s on p.object_id = s.id where text like
select * from YOUR_DATABASE_NAME.INFORMATION_SCHEMA.ROUTINES where ROUTINE_DEFINITION like
SELECT object_name = OBJECT_NAME(sm.object_id), o.type_desc, sm.definition FROM sys.sql_modules AS sm JOIN sys.objects AS o ON sm.object_id = o.object_id WHERE sm.definition like ORDER BY o.type, o.name, o.object_id
Select o.id, c.number, o.name, c.text from syscomments c inner join sysobjects o on o.id = c.id where c.encrypted = 0 and o.type = and c.id in (Select id from syscomments where text like order by objecttype, o.name, o.id, c.number, c.colid
SELECT name FROM sys.procedures WHERE Object_definition(object_id) LIKE
create Procedure [dbo].[TextFinder] (@Text varchar(500),@Type varchar(2)=NULL) AS BEGIN SELECT DISTINCT o.name AS ObjectName, CASE o.xtype WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN ELSE o.xtype END AS ObjectType, ISNULL( p.Name, FROM syscomments c INNER JOIN sysobjects o ON c.id=o.id LEFT JOIN sysobjects p ON o.Parent_obj=p.id WHERE c.text LIKE o.xtype = case when @Type IS NULL then o.xtype else @Type end ORDER BY Location, ObjectName END
SELECT OBJECT_NAME(id) FROM SYSCOMMENTS WHERE [text] LIKE AND OBJECTPROPERTY(id, GROUP BY OBJECT_NAME(id)
SELECT s.name + , c.text ProcedureSteps FROM sys.syscomments c INNER JOIN sys.objects o ON c.id = o.object_id INNER JOIN sys.schemas s ON o.schema_id = s.schema_id WHERE o.type = AND c.text LIKE N ORDER BY s.name + , c.colid
create Procedure [dbo].[TextFinder] (@Text varchar(500),@Type varchar(2)=NULL) AS BEGIN SELECT DISTINCT o.name AS ObjectName, CASE o.xtype WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN ELSE o.xtype END AS ObjectType, ISNULL( p.Name, FROM syscomments c INNER JOIN sysobjects o ON c.id=o.id LEFT JOIN sysobjects p ON o.Parent_obj=p.id WHERE c.text LIKE o.xtype = case when @Type IS NULL then o.xtype else @Type end ORDER BY Location, ObjectName END
SELECT OBJECT_NAME(id) FROM syscomments WHERE [text] LIKE AND OBJECTPROPERTY(id, GROUP BY OBJECT_NAME(id)
--------------------------------------------- -------------- Start FINDTEXT ---------- --------------------------------------------- SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED SET NOCOUNT ON GO DECLARE @SearchString VARCHAR(MAX) SET @SearchString = DECLARE @OverrideSearchStringWith VARCHAR(MAX) -- -- Use Escape chars in Brackets [] like [%] to find percent char. -- DECLARE @ReturnLen INT SET @ReturnLen = 50; with lastrun as (select DEPS.OBJECT_ID ,MAX(last_execution_time) as LastRun from sys.dm_exec_procedure_stats DEPS group by deps.object_id ) SELECT OL.Type ,OBJECT_NAME(OL.Obj_ID) AS ,LTRIM(RTRIM(REPLACE(SUBSTRING(REPLACE(OBJECT_DEFINITION(OL.Obj_ID), NCHAR(0x001F), ,CAST(REPLACE(REPLACE(REPLACE(REPLACE(CONVERT(VARCHAR(MAX), REPLACE(OBJECT_DEFINITION(OL.Obj_ID), NCHAR(0x001F), ,(SELECT [processing-instruction(A)] = REPLACE(OBJECT_DEFINITION(OL.Obj_ID), NCHAR(0x001F), FOR XML PATH( ,TYPE ) AS ,Modded AS Modified ,LastRun as LastRun FROM (SELECT CASE P.type WHEN WHEN WHEN ELSE END AS ,P.OBJECT_ID AS OBJ_id ,P.modify_Date AS modded ,LastRun.LastRun FROM sys.Objects P WITH (NOLOCK) LEFT join lastrun on P.object_id = lastrun.object_id WHERE OBJECT_DEFINITION(p.OBJECT_ID) LIKE AND type IN ( -- AND lastrun.LastRun IS NOT null ) OL OPTION (FAST 10) --------------------------------------------- ---------------- END ----------------- --------------------------------------------- ---------------------------------------------
DECLARE @SearchText varchar(1000) = SELECT DISTINCT sc.SPECIFIC_SCHEMA as FROM ( (SELECT ROUTINE_NAME SPName FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_DEFINITION LIKE AND ROUTINE_TYPE= UNION ALL (SELECT OBJECT_NAME(id) SPName FROM SYSCOMMENTS WHERE [text] LIKE AND OBJECTPROPERTY(id, GROUP BY OBJECT_NAME(id)) UNION ALL (SELECT OBJECT_NAME(object_id) SPName FROM sys.sql_modules WHERE OBJECTPROPERTY(object_id, AND definition LIKE ) AS sp CROSS APPLY (select SPECIFIC_SCHEMA from INFORMATION_SCHEMA.ROUTINES r where r.ROUTINE_NAME = sp.SPName) sc ORDER BY 1
create table tblStagingTable ( pkID BIGINT (IDENTITY,1,1), CustomerFirstName varchar(30), CustomerLastName varchar(30), CustomerCityStateZip varchar(100), CustomerCurrentBalance money ) insert into tblStagingTable (CustomerFirstName,CustomerLastName, CustomerCityStateZip) ( create view vwStagingTable AS SELECT CustomerFirstName = CAST(CustomerFirstName as CHAR(30)), CustomerLastName = CAST(CustomerLastName as CHAR(30)), CustomerCityStateZip = CAST(CustomerCityStateZip as CHAR(100)), CustomerCurrentBalance = CAST(CAST(CustomerCurrentBalance as NUMERIC(9,2)) AS CHAR(10)) SELECT * from vwStagingTable
CREATE FUNCTION List(@Status AS CHAR(1) = RETURNS TABLE AS RETURN SELECT * FROM TEST WHERE Status LIKE
CREATE PROCEDURE <owner>.<procedure name> <Param> <datatype> AS <Body>
CREATE PROCEDURE Users_GetUserInfo @login nvarchar(30)=null AS SELECT * from [Users] WHERE ISNULL(@login,login)=login
Employee ID Name Age Mobile --------------------------------------- 001 Sidheswar 25 9938885469 002 Pritish 32 9178542436
Create Procedure Employee details As Begin Select * from Employee End
Execute Employee details --- (Employee details is a user defined name, give a name as you want)
Create Procedure employee_insert (@EmployeeID int, @Name Varchar(30), @Age int, @Mobile int) As Begin Insert Into Employee Values (@EmployeeID, @Name, @Age, @Mobile) End
Execute employee_insert 003,’xyz’,27,1234567890 --(Parameter size must be same as declared column size)
CREATE PROCEDURE test_display AS SELECT FirstName, LastName FROM tb_test; EXEC test_display;
-- a name CREATE PROCEDURE spGetPerson -- parameters CREATE PROCEDURE spGetPerson(@PersonID int) -- a body CREATE PROCEDURE spGetPerson(@PersonID int) AS SELECT FirstName, LastName .... FROM People WHERE PersonID = @PersonID
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE PROCEDURE GetEmployee @EmployeeID int = 0 AS BEGIN SET NOCOUNT ON; SELECT FirstName, LastName, BirthDate, City, Country FROM Employees WHERE EmployeeID = @EmployeeID END GO
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER PROCEDURE GetEmployee @EmployeeID int = 0 AS BEGIN SET NOCOUNT ON; SELECT FirstName, LastName, BirthDate, City, Country FROM Employees WHERE EmployeeID = @EmployeeID END GO
CREATE Procedure FirstTest ( @InputA INT ) AS BEGIN SELECT END GO CREATE Procedure FirstTest;2 ( @InputA INT, @InputB INT ) AS BEGIN SELECT END GO
CREATE Procedure SecondTest;2 ( @InputA INT, @InputB INT ) AS BEGIN SELECT END GO
CREATE PROCEDURE dorepeat(p1 INT) BEGIN SET @x = 0; REPEAT SET @x = @x + 1; UNTIL @x > p1 END REPEAT; END;
> create procedure HumanResources.uspFindEmployee `*<<<---Store procedure name`* @businessEntityID `<<<----parameter` as begin SET NOCOUNT ON; Select businessEntityId, <<<----select statement to return one employee row NationalIdNumber, LoginID, JobTitle, HireData, From HumanResources.Employee where businessEntityId =@businessEntityId <<<---parameter used as criteria end
create procedure_name (para1 int,para2 decimal) as select * from TableName
declare @var varchar(20) set @var = set @var = (select name from master.sys.tables where name = select @var set @var = select @var = name from master.sys.tables where name = select @var
DECLARE @A INT = 2 SELECT @A = TBL.A FROM ( SELECT 1 A ) TBL WHERE 1 = 2 SELECT @A --------------------------------------------------------------- DECLARE @A INT = 2 SET @A = ( SELECT TBL.A FROM ( SELECT 1 A) TBL WHERE 1 = 2 ) SELECT @A
Declare @DayOfMonth TinyInt Set @DayOfMonth = 13 Declare @Month TinyInt Set @Month = 6 Declare @Year Integer Set @Year = 2006 -- ------------------------------------ Select DateAdd(day, @DayOfMonth - 1, DateAdd(month, @Month - 1, DateAdd(Year, @Year-1900, 0)))
Select DateAdd(yy, @Year-1900, DateAdd(m, @Month - 1, @DayOfMonth - 1))
select dateadd(month, @Month - 1, dateadd(year, @Year-1900, @DayOfMonth - 1));
DECLARE @day int, @month int, @year int SELECT @day = 4, @month = 3, @year = 2011 SELECT dateadd(mm, (@year - 1900) * 12 + @month - 1 , @day - 1)
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N DROP FUNCTION [dbo].[func_DateFromParts] GO CREATE FUNCTION [dbo].[func_DateFromParts] ( @Year INT, @Month INT, @DayOfMonth INT, @Hour INT = 0, -- based on 24 hour clock (add 12 for PM :) @Min INT = 0, @Sec INT = 0 ) RETURNS DATETIME AS BEGIN RETURN DATEADD(second, @Sec, DATEADD(minute, @Min, DATEADD(hour, @Hour, DATEADD(day, @DayOfMonth - 1, DATEADD(month, @Month - 1, DATEADD(Year, @Year-1900, 0)))))) END GO
SELECT dbo.func_DateFromParts(2013, 10, 4, 15, 50, DEFAULT)
select DATEFROMPARTS(year, month, day) as ColDate, Col2, Col3 From MyTable Where DATEFROMPARTS(year, month, day) Between @DateIni and @DateEnd
create function dbo.fnDateTime2FromParts(@Year int, @Month int, @Day int, @Hour int, @Minute int, @Second int, @Nanosecond int) returns datetime2 as begin -- Note! SQL Server 2012 includes datetime2fromparts() function declare @output datetime2 = set @output = dateadd(year , @Year - 1900 , @output) set @output = dateadd(month , @Month - 1 , @output) set @output = dateadd(day , @Day - 1 , @output) set @output = dateadd(hour , @Hour , @output) set @output = dateadd(minute , @Minute , @output) set @output = dateadd(second , @Second , @output) set @output = dateadd(ns , @Nanosecond , @output) return @output end
DECLARE @Day int, @Month int, @Year int SELECT @Day = 1, @Month = 2, @Year = 2008 SELECT DateAdd(dd, @Day-1, DateAdd(mm, @Month -1, DateAdd(yy, @Year - 2000,
select dateadd(month, (@Year -1900)*12 + @Month -1, @DayOfMonth -1) + dateadd(ss, @Hour*3600 + @Minute*60 + @Second, 0) + dateadd(ms, @Millisecond, 0)
-- 26 February 2015 SET DATEFORMAT dmy SELECT CAST( SET DATEFORMAT ymd SELECT CAST(
SELECT SUBSTRING(CONVERT(VARCHAR,JOINGDATE,103),7,4)AS YEAR,SUBSTRING(CONVERT(VARCHAR,JOINGDATE,100),1,2)AS MONTH,SUBSTRING(CONVERT(VARCHAR,JOINGDATE,100),4,3)AS DATE FROM EMPLOYEE1
2014 Ja 1 2015 Ja 1 2014 Ja 1 2015 Ja 1 2012 Ja 1 2010 Ja 1 2015 Ja 1
--2012 and above SELECT CONCAT ( RIGHT(REPLACE(@date, , ,RIGHT(CONCAT( , ,RIGHT(CONCAT( ) --2008 and below SELECT RIGHT(REPLACE(@date, + +RIGHT( + +RIGHT(
DECLARE @Table TABLE (ID INT IDENTITY(1000,1), DateString VARCHAR(50), DateColumn DATE) INSERT INTO @Table SELECT UNION SELECT UNION SELECT UNION SELECT UNION SELECT UPDATE @Table SET DateColumn = CONCAT ( RIGHT(REPLACE(DateString, , ,RIGHT(CONCAT( , ,RIGHT(CONCAT( ) SELECT ID,DateString,DateColumn FROM @Table
CREATE VIEW dbo.myTESTview WITH SCHEMABINDING AS SELECT ID, Quantity FROM dbo.MyTestTable; UPDATE dbo.myTESTview SET Quantity = 7 WHERE ID = 1
ALTER SCHEMA TargetSchema TRANSFER SourceSchema.TableName;
exec sp_MSforeachtable "ALTER SCHEMA TargetSchema TRANSFER ?"
ALTER SCHEMA new_schema TRANSFER old_schema.table_name
ALTER SCHEMA schema_name TRANSFER [ Object | Type | XML Schema Collection ] securable_name [;]
SELECT convert(varchar, getdate(), 100) -- mon dd yyyy hh:mmAM SELECT convert(varchar, getdate(), 101) -- mm/dd/yyyy – 10/02/2008 SELECT convert(varchar, getdate(), 102) -- yyyy.mm.dd – 2008.10.02 SELECT convert(varchar, getdate(), 103) -- dd/mm/yyyy SELECT convert(varchar, getdate(), 104) -- dd.mm.yyyy SELECT convert(varchar, getdate(), 105) -- dd-mm-yyyy SELECT convert(varchar, getdate(), 106) -- dd mon yyyy SELECT convert(varchar, getdate(), 107) -- mon dd, yyyy SELECT convert(varchar, getdate(), 108) -- hh:mm:ss SELECT convert(varchar, getdate(), 109) -- mon dd yyyy hh:mm:ss:mmmAM (or PM) SELECT convert(varchar, getdate(), 110) -- mm-dd-yyyy SELECT convert(varchar, getdate(), 111) -- yyyy/mm/dd SELECT convert(varchar, getdate(), 112) -- yyyymmdd SELECT convert(varchar, getdate(), 113) -- dd mon yyyy hh:mm:ss:mmm SELECT convert(varchar, getdate(), 114) -- hh:mm:ss:mmm(24h) SELECT convert(varchar, getdate(), 120) -- yyyy-mm-dd hh:mm:ss(24h) SELECT convert(varchar, getdate(), 121) -- yyyy-mm-dd hh:mm:ss.mmm SELECT convert(varchar, getdate(), 126) -- yyyy-mm-ddThh:mm:ss.mmm
select convert(varchar,getDate(),120) select convert(varchar(10),getDate(),120)
SELECT convert(varchar, getdate(), 120) -- yyyy-mm-dd hh:mm:ss(24h) SELECT convert(varchar, getdate(), 121) -- yyyy-mm-dd hh:mm:ss.mmm SELECT convert(varchar, getdate(), 126) -- yyyy-mm-ddThh:mm:ss.mmm --example -- 2008-10-02T10:52:47.513
select convert(datetime,CONVERT(char(10), GetDate(),126))
SELECT Code,Description FROM TABLE -- This will Include only date part of 14th March 2010. Any date with date companents will not be considered. WHERE ID= 1 AND FromDate >= CONVERT(DATETIME, -- This will Include the whole day of 14th March 2010 --WHERE ID= 1 AND FromDate >= CONVERT(DATETIME,
SELECT CAST(getdate() AS DATE) SELECT LEFT(CAST(getdate() AS DATE), 7)
SELECT issueDate_dat, CONVERT(varchar, DATEPART(yyyy, issuedate_dat)) AS issueDateYYYY , CASE WHEN (len(CONVERT(varchar, DATEPART(mm, issuedate_dat))) < 2) THEN , CASE WHEN (len(CONVERT(varchar, DATEPART(dd, issuedate_dat))) <2) THEN FROM tableXXXXY
CONVERT(NVARCHAR(MAX), CAST(GETDATE() as date), 120)
select convert(nvarchar(50),year(a.messedupDate))+ (case when len(convert(nvarchar(50),month(a.messedupDate)))=1 then else convert(nvarchar(50),month(a.messedupDate)) end)+ (case when len(convert(nvarchar(50),day(a.messedupDate)))=1 then else convert(nvarchar(50),day(a.messedupDate)) end) from messytable a
IFormatProvider culture = new System.Globalization.CultureInfo("fr-FR", true); cmdGetPaymentStatement.Parameters.AddWithValue("@pStartDate", DateTime.Parse("22/12/2017", culture, System.Globalization.DateTimeStyles.AssumeLocal)).IsNullable = true;
CREATE TYPE dbo.IDList AS TABLE ( ID INT ); GO CREATE PROCEDURE dbo.DoSomethingWithEmployees @List AS dbo.IDList READONLY AS BEGIN SET NOCOUNT ON; SELECT ID FROM @List; END GO
CREATE FUNCTION dbo.SplitInts ( @List VARCHAR(MAX), @Delimiter VARCHAR(255) ) RETURNS TABLE AS RETURN ( SELECT Item = CONVERT(INT, Item) FROM ( SELECT Item = x.i.value( FROM ( SELECT [XML] = CONVERT(XML, + REPLACE(@List, @Delimiter, ) AS a CROSS APPLY [XML].nodes( WHERE Item IS NOT NULL ); GO
CREATE PROCEDURE dbo.DoSomethingWithEmployees @List VARCHAR(MAX) AS BEGIN SET NOCOUNT ON; SELECT EmployeeID = Item FROM dbo.SplitInts(@List, END GO
CREATE PROCEDURE [dbo].[GetArrivalsReport] @DateTimeFrom AS DATETIME, @DateTimeTo AS DATETIME, @HostIds AS XML(xsdArrayOfULong) AS BEGIN DECLARE @hosts TABLE (HostId BIGINT) INSERT INTO @hosts SELECT arrayOfUlong.HostId.value( FROM @HostIds.nodes(
IF NOT EXISTS (SELECT * FROM sys.xml_schema_collections WHERE name = BEGIN CREATE XML SCHEMA COLLECTION [dbo].[xsdArrayOfULong] AS N <xs:element name="arrayOfUlong"> <xs:complexType> <xs:sequence> <xs:element maxOccurs="unbounded" name="u" type="xs:unsignedLong" /> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> END GO
SELECT DATEADD(month, DATEDIFF(month, 0, @mydate), 0) AS StartOfMonth
SELECT DATEFROMPARTS(YEAR(@mydate),MONTH(@mydate),1)
DECLARE @Date DATETIME SELECT DATEADD(mm, DATEDIFF(mm,0,@Date), 0)
SELECT DATEADD(m, DATEDIFF(m, 0, GETDATE()), 0) -- Instead of GetDate you can put any date.
CREATE FUNCTION [dbo].[GetFirstDayOfMonth] ( @InputDate DATETIME ) RETURNS DATETIME BEGIN RETURN CAST(CAST(YEAR(@InputDate) AS VARCHAR(4)) + CAST(MONTH(@InputDate) AS VARCHAR(2)) + END GO
SELECT DATEADD(DAY,(DATEPART(DAY,@mydate)-1)*(-1),@mydate) AS FirstOfMonth
select date_sub(ref_date, interval day(ref_date)-1 day) as day1;
SELECT DATEADD(day, 1, EOMONTH(DATEADD(month, -1, GETDATE()))) as firstdateofmonth
SELECT DATEADD(MONTH, -1, DATEADD(DAY, 1, EOMONTH(GETDATE())))
DECLARE @startofmonth date SET @startofmonth = DATEADD(dd,1,EOMONTH(Getdate(),-2))
DECLARE @startofmonth date SET @startofmonth = DATEADD(dd,1,EOMONTH(@mydate,-1))
----Last Day of Previous Month SELECT DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,GETDATE()),0)) LastDay_PreviousMonth ----Last Day of Current Month SELECT DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,GETDATE())+1,0)) LastDay_CurrentMonth ----Last Day of Next Month SELECT DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,GETDATE())+2,0)) LastDay_NextMonth
SELECT DATEADD (DAY, -1 * (DAY(GETDATE()) - 1), GETDATE())
SELECT CONVERT (DATETIME, CONVERT (DATE, DATEADD (DAY, -1 * (DAY(GETDATE()) - 1), GETDATE())))
select getdate()-DATEPART(day, getdate())+1 select DATEADD(Month,1,getdate())-DATEPART(day, getdate())
declare @ModelID uniqueidentifer Select @ModelID = select modelid from models where areaid =
SELECT @ModelID = m.modelid FROM MODELS m WHERE m.areaid =
SET @ModelID = (SELECT m.modelid FROM MODELS m WHERE m.areaid =
SELECT @ModelID = modelid FROM Models WHERE areaid =
declare @ModelID uniqueidentifer --make sure to use brackets set @ModelID = (select modelid from models where areaid = select @ModelID
DECLARE @ModelID uniqueidentifer = (SELECT modelid FROM models WHERE areaid =
SELECT TOP 1 @ModelID = m.modelid FROM MODELS m WHERE m.areaid =
Select @ModelID =m.modelid From MODELS m Where m.areaid =
SELECT * FROM MyTable WHERE MyColumn != NULL (0 Results) SELECT * FROM MyTable WHERE MyColumn <> NULL (0 Results) SELECT * FROM MyTable WHERE MyColumn IS NOT NULL (568 Results)
SELECT CASE WHEN NOT (1 = null or (1 is null and null is null)) THEN 1 ELSE 0 end
where a != b OR (a is null and b IS not null) OR (a IS not null and b IS null)
CREATE FUNCTION [dbo].[ufn_equal_with_nulls] ( @i sql_variant, @d sql_variant ) RETURNS bit AS BEGIN DECLARE @in bit = 0, @dn bit = 0 if @i is null set @in = 1 if @d is null set @dn = 1 if @in <> @dn return 0 if @in = 1 and @dn = 1 return 1 if @in = 0 and @dn = 0 and @i = @d return 1 return 0 END
declare @tmp table (a int, b int) insert into @tmp values (1,1), (1,2), (1,null), (null,1), (null,null) ---- in select ---- select *, [dbo].[ufn_equal_with_nulls](a,b) as [=] from @tmp ---- where equal ---- select *, ---- where not equal ---- select *,
---- in select ---- a b = 1 1 1 1 2 0 1 NULL 0 NULL 1 0 NULL NULL 1 ---- where equal ---- 1 1 equal NULL NULL equal ---- where not equal ---- 1 2 not equal 1 NULL not equal NULL 1 not equal
DROP { [CONSTRAINT] constraint_name | COLUMN column_name }
DROP { [ CONSTRAINT ] constraint_name | COLUMN column } [ ,...n ]
ALTER TABLE table_name DROP (column_name1, column_name2);
ALTER TABLE table_name DROP COLUMN column_name1, column_name2
ALTER TABLE table_name DROP column_name1, DROP column_name2;
ALTER TABLE table_name DROP COLUMN column_name1, DROP COLUMN column_name2;
create table test (a int, b int , c int, d int); alter table test drop column b, d;
alter table tablename drop column col1, drop column col2 , drop column col3 ....
DROP { [ CONSTRAINT ] { constraint_name [ WITH ( <drop_clustered_constraint_option> [ ,...n ] ) ] } [ ,...n ] | COLUMN { column_name } [ ,...n ] } [ ,...n ]
ALTER TABLE TableName DROP COLUMN Column1, Column2, Column3
ALTER TABLE TableName DROP COLUMN Column1, COLUMN Column2, COLUMN Column3
ALTER TBALE TableName DROP CONSTRAINT DF_TableName_Column1, COLUMN Column1;
mysql> alter table test2 drop column (c1,c2,c3); ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near mysql> alter table test2 drop column c1,c2,c3; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near mysql> alter table test2 drop column c1, drop column c2, drop c3; Query OK, 0 rows affected (0.64 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql>
alter table tablename drop (column1, column2, column3......);
ALTER TABLE table_name DROP COLUMN column1,column2,column3;
ALTER TABLE Student DROP COLUMN Name, Number, City;
create table test(a int,B int,C int); alter table test drop(a,B);
ALTER table table_name Drop column column1, Drop column column2,Drop column column3;
ALTER table table_name Drop column column1, ADD column column2 AFTER column7;
ID SKU PRODUCT ======================= 1 FOO-23 Orange 2 BAR-23 Orange 3 FOO-24 Apple 4 FOO-25 Orange
SELECT [ID],[SKU],[PRODUCT] FROM [TestData] WHERE ([PRODUCT] = (SELECT DISTINCT [PRODUCT] FROM [TestData] WHERE ([SKU] LIKE ORDER BY [ID]
SELECT * FROM (SELECT ID, SKU, Product, ROW_NUMBER() OVER (PARTITION BY PRODUCT ORDER BY ID) AS RowNumber FROM MyTable WHERE SKU LIKE WHERE a.RowNumber = 1
SELECT * FROM [TestData] WHERE [ID] IN ( SELECT MIN([ID]) FROM [TestData] WHERE [SKU] LIKE GROUP BY [PRODUCT] )
SELECT t.* FROM TestData t INNER JOIN (SELECT MIN(ID) as MinID FROM TestData WHERE SKU LIKE ) dt ON t.ID=dt.MinID
declare @TestData table (ID int, sku char(6), product varchar(15)) insert into @TestData values (1 , insert into @TestData values (2 , insert into @TestData values (3 , insert into @TestData values (4 , --basically the same as @Aaron Alton SELECT dt.ID, dt.SKU, dt.Product FROM (SELECT ID, SKU, Product, ROW_NUMBER() OVER (PARTITION BY PRODUCT ORDER BY ID) AS RowID FROM @TestData WHERE SKU LIKE ) AS dt WHERE dt.RowID=1 ORDER BY dt.ID
DECLARE @TestData TABLE([ID] int, [SKU] char(6), [Product] varchar(15)) INSERT INTO @TestData values (1 , INSERT INTO @TestData values (2 , INSERT INTO @TestData values (3 , INSERT INTO @TestData values (4 , SELECT DISTINCT [ID] = ( SELECT TOP 1 [ID] FROM @TestData Y WHERE Y.[Product] = X.[Product]) ,[SKU]= ( SELECT TOP 1 [SKU] FROM @TestData Y WHERE Y.[Product] = X.[Product]) ,[PRODUCT] FROM @TestData X
SELECT min (id) AS FROM TestData WHERE sku LIKE GROUP BY product ORDER BY
WITH cte AS ( SELECT[foo], [bar], row_number() OVER(PARTITION BY foo, bar ORDER BY baz) AS [rn] FROM TABLE ) DELETE cte WHERE [rn] > 1
DELETE FROM Table WHERE ID NOT IN ( SELECT MIN(ID) FROM Table GROUP BY Field1, Field2, Field3, ... )
DECLARE @SampleData AS TABLE (Id int, Duplicate varchar(20)) INSERT INTO @SampleData SELECT 1, SELECT 2, SELECT 3, SELECT 4, SELECT 5, DELETE FROM @SampleData WHERE Id IN ( SELECT Id FROM ( SELECT Id ,ROW_NUMBER() OVER (PARTITION BY [Duplicate] ORDER BY Id) AS [ItemNumber] -- Change the partition columns to include the ones that make the row distinct FROM @SampleData ) a WHERE ItemNumber > 1 -- Keep only the first unique item ) SELECT * FROM @SampleData
Id Duplicate ----------- --------- 1 ABC 3 LMN 4 XYZ
IF EXISTS (SELECT * FROM sys.objects WHERE type = DROP PROCEDURE MyProc GO CREATE PROCEDURE MyProc ...
BEGIN DECLARE @myvar INT SELECT * FROM mytable WHERE @myvar ... END
IF EXISTS ( SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N AND type IN ( N DROP … CREATE …
IF EXISTS ( SELECT * FROM sysobjects WHERE id = object_id(N and OBJECTPROPERTY(id, N BEGIN DROP PROCEDURE [dbo].[MyProc] END
IF NOT EXISTS (SELECT * FROM sys.objects WHERE type = exec( GO ALTER PROCEDURE [dbo].[MyProc] AS ....
create or alter procedure procTest as begin print (1) end; go
IF NOT EXISTS (SELECT * FROM sysobjects WHERE name= print END ELSE BEGIN print END
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE -- view procedure function or anything you want ...
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID( BEGIN DROP PROCEDURE my_procedure END SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE PROCEDURE [dbo].my_procedure ...
IF NOT EXISTS (select ss.name as SchemaName, sp.name as StoredProc from sys.procedures sp join sys.schemas ss on sp.schema_id = ss.schema_id where ss.name = BEGIN DECLARE @sql NVARCHAR(MAX) -- Not so aesthetically pleasing part. The actual proc definition is stored -- in our variable and then executed. SELECT @sql = ( @MyParam int ) AS SELECT @MyParam' EXEC sp_executesql @sql END
Use DatabaseName go If Object_Id( begin drop procedure schema.storedprocname end go create procedure schema.storedprocname as begin end
IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = AND ROUTINE_TYPE =
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID (N BEGIN DROP PROCEDURE [Schema].[Procedure_Name] Print( END
IF NOT EXISTS ( SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N ) BEGIN EXEC sp_executesql N END GO ALTER PROCEDURE [dbo].[uspMyProcedure] @variable1 INTEGER AS BEGIN -- Stored procedure logic END
IF EXISTS(SELECT * FROM sys.procedures WHERE NAME LIKE BEGIN DROP PROCEDURE uspBlackListGetAll END GO CREATE Procedure uspBlackListGetAll
GO create procedure [dbo].[spAddNewClass] @ClassName varchar(20),@ClassFee int as begin insert into tblClass values (@ClassName,@ClassFee) end GO create procedure [dbo].[spAddNewSection] @SectionName varchar(20),@ClassID int as begin insert into tblSection values(@SectionName,@ClassID) end Go create procedure test as begin select * from tblstudent end
select Date,TotalAllowance from Calculation where EmployeeId=1 and Date between 2011/02/25 and 2011/02/27
select Date, TotalAllowance from Calculation where EmployeeId = 1 and Date between
select Date, TotalAllowance from Calculation where EmployeeId = 1 and Date >=
select Date,TotalAllowance from Calculation where EmployeeId=1 and Date between
select Date,TotalAllowance from Calculation where EmployeeId=1 and Date >=
select Date,TotalAllowance from Calculation where EmployeeId=1 and Date >=
select Date,TotalAllowance from Calculation where EmployeeId=1 and Date between
select Date,TotalAllowance from Calculation where EmployeeId=1 and [Date] between
select * from table_name where col_Date between AND DATEADD(s,-1,DATEADD(d,1,
SELECT * FROM tableName WHERE columName BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 3 DAY)
select * from test where CAST(AddTime as datetime) between
"SELECT FirstName FROM Students WHERE DoB >= " & myDate.ToString("d MMM yyyy")
select Date,TotalAllowance from Calculation where EmployeeId=1 and convert(varchar(10),Date,111) between
select Date,TotalAllowance from Calculation where EmployeeId=1 and Date BETWEEN DATE_SUB(CURDATE(), INTERVAL 3 DAY) AND CURDATE()
select Date,TotalAllowance from Calculation where EmployeeId=1 and Date BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 3 DAY)
declare @Approval_date datetime set @Approval_date =getdate() Approval_date between @Approval_date +
select * from tblUser Where convert(varchar(10),CreatedDate,111) between
select * from tblUser Where (CAST(CreatedDate AS DATETIME) between CAST(
select * from tblUser Where (YEAR(CreatedDate) between YEAR(
select * from tblUser Where Convert(Varchar(10),CreatedDate,111) >= Convert(Varchar(10), select * from tblUser Where (Convert(Varchar(10),CreatedDate,111) between Convert(Varchar(10),
Select * from Calculation where EmployeeId=1 and Date between
qry = "SELECT * FROM [calender] WHERE datediff(day,
select Date,TotalAllowance from Calculation where EmployeeId=1 and Date >=
select Date, ... from ... where Date >= $start_month_day_1 and Date < DATEADD(m, 1, $end_month_day_1)
CREATE PROCEDURE dbo.Get_Data_By_Dates ( @EmployeeId INT = 1, @Start_Date DATE, @End_Date Date ) AS Select * FROM Calculation where EmployeeId=@EmployeeId AND Test_Date BETWEEN @Start_Date AND @End_Date RETURN
SELECT Date, TotalAllowance FROM Calculation WHERE EmployeeId = 1 AND Date BETWEEN to_date( AND to_date (
DECLARE @dbname nvarchar(128) SET @dbname = N IF (EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE ( OR name = @dbname))) -- code mine :) PRINT
IF EXISTS (SELECT name FROM master.sys.databases WHERE name = N Do your thing...
CREATE FUNCTION dbo.DatabaseExists(@dbname nvarchar(128)) RETURNS bit AS BEGIN declare @result bit = 0 SELECT @result = CAST( CASE WHEN db_id(@dbname) is not null THEN 1 ELSE 0 END AS BIT) return @result END GO
select [dbo].[DatabaseExists]( select [dbo].[DatabaseExists](
IF EXISTS ( SELECT name FROM master.dbo.sysdatabases WHERE name = N ) BEGIN SELECT END ELSE BEGIN CREATE DATABASE [New_Database] SELECT END
drop table exams; drop table question_bank; drop table anwser_bank; create table exams ( exam_id uniqueidentifier primary key, exam_name varchar(50), ); create table question_bank ( question_id uniqueidentifier primary key, question_exam_id uniqueidentifier not null, question_text varchar(1024) not null, question_point_value decimal, constraint question_exam_id foreign key references exams(exam_id) ); create table anwser_bank ( anwser_id uniqueidentifier primary key, anwser_question_id uniqueidentifier, anwser_text varchar(1024), anwser_is_correct bit );
create table question_bank ( question_id uniqueidentifier primary key, question_exam_id uniqueidentifier not null, question_text varchar(1024) not null, question_point_value decimal, constraint fk_questionbank_exams foreign key (question_exam_id) references exams (exam_id) );
alter table MyTable add constraint MyTable_MyColumn_FK FOREIGN KEY ( MyColumn ) references MyOtherTable(PKColumn)
CONSTRAINT your_name_here FOREIGN KEY (question_exam_id) REFERENCES EXAMS (exam_id)
alter table MyTable add constraint MyTable_MyColumn_FK FOREIGN KEY ( MyColumn ) references MyOtherTable(PKColumn)
alter table MyTable add constraint MyTable_MyColumn_FK FOREIGN KEY ( MyColumn ) references MyOtherTable(PKColumn) on update cascade on delete cascade
create table ProductCategories ( Id int identity primary key, ProductId int references Products(Id) on update cascade on delete cascade CategoryId int references Categories(Id) on update cascade on delete cascade )
create table question_bank ( question_id uniqueidentifier primary key, question_exam_id uniqueidentifier not null constraint fk_exam_id foreign key references exams(exam_id), question_text varchar(1024) not null, question_point_value decimal );
ALTER TABLE [SCHEMA].[TABLENAME] ADD FOREIGN KEY (COLUMNNAME) REFERENCES [TABLENAME](COLUMNNAME) EXAMPLE ALTER TABLE [dbo].[UserMaster] ADD FOREIGN KEY (City_Id) REFERENCES [dbo].[CityMaster](City_Id)
Alter table Foreign_Key_Table_name add constraint Foreign_Key_Table_name_Columnname_FK Foreign Key (Column_name) references Another_Table_name(Another_Table_Column_name)
create table exams ( exam_id int primary key, exam_name varchar(50), ); create table question_bank ( question_id int primary key, question_exam_id int not null, question_text varchar(1024) not null, question_point_value decimal, constraint question_exam_id_fk foreign key references exams(exam_id) ON DELETE CASCADE );
-- First, chech if the table exists... IF 0 < ( SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = AND TABLE_SCHEMA = AND TABLE_NAME = ) BEGIN -- Check for NULL values in the primary-key column IF 0 = (SELECT COUNT(*) FROM T_SYS_Language_Forms WHERE LANG_UID IS NULL) BEGIN ALTER TABLE T_SYS_Language_Forms ALTER COLUMN LANG_UID uniqueidentifier NOT NULL -- No, don -- Drop PK if exists -- ALTER TABLE T_SYS_Language_Forms DROP CONSTRAINT pk_constraint_name --DECLARE @pkDropCommand nvarchar(1000) --SET @pkDropCommand = N --WHERE CONSTRAINT_TYPE = --AND TABLE_SCHEMA = --AND TABLE_NAME = ----AND CONSTRAINT_NAME = --)) ---- PRINT @pkDropCommand --EXECUTE(@pkDropCommand) -- Instead do -- EXEC sp_rename -- Check if they keys are unique (it is very possible they might not be) IF 1 >= (SELECT TOP 1 COUNT(*) AS cnt FROM T_SYS_Language_Forms GROUP BY LANG_UID ORDER BY cnt DESC) BEGIN -- If no Primary key for this table IF 0 = ( SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE CONSTRAINT_TYPE = AND TABLE_SCHEMA = AND TABLE_NAME = -- AND CONSTRAINT_NAME = ) ALTER TABLE T_SYS_Language_Forms ADD CONSTRAINT PK_T_SYS_Language_Forms PRIMARY KEY CLUSTERED (LANG_UID ASC) ; -- Adding foreign key IF 0 = (SELECT COUNT(*) FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS WHERE CONSTRAINT_NAME = ALTER TABLE T_ZO_SYS_Language_Forms WITH NOCHECK ADD CONSTRAINT FK_T_ZO_SYS_Language_Forms_T_SYS_Language_Forms FOREIGN KEY(ZOLANG_LANG_UID) REFERENCES T_SYS_Language_Forms(LANG_UID); END -- End uniqueness check ELSE PRINT END -- End NULL check ELSE PRINT END
DELETE FROM (table) OUTPUT deleted.ID, deleted.Description WHERE (condition)
INSERT INTO MyTable(Field1, Field2) OUTPUT inserted.ID VALUES (Value1, Value2)
UPDATE (table) SET field1 = value1, field2 = value2 OUTPUT inserted.ID, deleted.field1, inserted.field1 WHERE (condition)
exec sp_msforeachtable @Command1 = @Command2 = @Command3 =
-- Return rows in a random order SELECT SomeColumn FROM SomeTable ORDER BY CHECKSUM(NEWID())
INSERT INTO Colors (id, Color) VALUES (1, (2, (3, (4,
select * from sys.dm_exec_query_stats order by execution_count desc
Use Master Go Declare @dbname sysname Set @dbname = Declare @spid int Select @spid = min(spid) from master.dbo.sysprocesses where dbid = db_id(@dbname) While @spid Is Not Null Begin Execute ( Select @spid = min(spid) from master.dbo.sysprocesses where dbid = db_id(@dbname) and spid > @spid End
Select CheckSum_Agg(Binary_CheckSum(*)) From Table With (NOLOCK)
Select CheckSum_Agg(Binary_CheckSum(*)) From Table With (NOLOCK) Where Column = Value
DECLARE @nvcConcatonated nvarchar(max) SET @nvcConcatonated = SELECT @nvcConcatonated = @nvcConcatonated + C.CompanyName + FROM tblCompany C WHERE C.CompanyID IN (1,2,3) SELECT @nvcConcatonated
SELECT ( ROW_NUMBER() OVER (ORDER BY OrderId) ) AS RowNumber, GrandTotal, CustomerId, PurchaseDate FROM Orders
DECLARE @filename varchar (20), @message varchar (20) EXEC xp_sscanf @filename OUTPUT, @message OUTPUT SELECT @filename, @message
-------------------- -------------------- products10.tmp random
Select Cast(Floor(Cast(Getdate() As Float))As Datetime)
Select DateAdd(Day, 0, DateDiff(Day, 0, Getdate()))
SELECT OBJECT_NAME(OBJECT_ID) AS DatabaseName, last_user_update,* FROM sys.dm_db_index_usage_stats WHERE database_id = DB_ID( AND OBJECT_ID=OBJECT_ID(
where dateadd( week, datediff( week, 0, TransDate ), 0 ) = dateadd( week, datediff( week, 0, getdate() ), 0 )
where dateadd( week, datediff( week, 0, TransDate ), 0 ) = dateadd( week, datediff( week, 0, getdate() ) - 1, 0 )
select dateadd( week, datediff( week, 0, getdate() ), 0 )
select dateadd( week, datediff( week, 0, getdate() ) - 1, 0 )
select row_number() over (order by (select 1)), * from dbo.Table as t
3 = 1 or 3 = 2 or 3 = 3 or 3 = null which is: FALSE or FALSE or TRUE or UNKNOWN which evaluates to TRUE
3 <> 1 and 3 <> 2 and 3 <> null which evaluates to: TRUE and TRUE and UNKNOWN which evaluates to: UNKNOWN
DECLARE @T TABLE ( true CHAR(4) DEFAULT CHECK ( 3 IN (1, 2, 3, NULL )), CHECK ( 3 NOT IN (1, 2, NULL )) ); INSERT INTO @T VALUES ( SELECT COUNT(*) AS tally FROM @T;
SELECT blah FROM t WHERE blah NOT IN (SELECT someotherBlah FROM t2 WHERE someotherBlah IS NOT NULL )
WITH sp AS ( SELECT * FROM ( VALUES ( ( ( AS T ( sno, pno, qty ) ) SELECT DISTINCT spx.sno FROM sp spx WHERE spx.pno = AND 1000 NOT IN ( SELECT spy.qty FROM sp spy WHERE spy.sno = spx.sno AND spy.pno = );
WITH sp AS ( SELECT * FROM ( VALUES ( ( ( AS T ( sno, pno, qty ) ) SELECT DISTINCT spx.sno FROM sp spx WHERE spx.pno = AND NOT EXISTS ( SELECT * FROM sp spy WHERE spy.sno = spx.sno AND spy.pno = AND spy.qty = 1000 );
WITH sp AS ( SELECT * FROM ( VALUES ( ( ( AS T ( sno, pno ) ), spq AS ( SELECT * FROM ( VALUES ( ( AS T ( sno, pno, qty ) ) SELECT sno FROM spq WHERE pno = EXCEPT SELECT sno FROM spq WHERE pno = AND qty = 1000;
select party_code from abc as a where party_code not in (select party_code from xyz where party_code = a.party_code);
CREATE PROCEDURE [dbo].[Item_AddItem] @CustomerId uniqueidentifier, @Description nvarchar(100), @Type int, @Username nvarchar(100), AS BEGIN DECLARE @TopRelatedItemId uniqueidentifier; SET @TopRelatedItemId = ( SELECT top(1) RelatedItemId FROM RelatedItems WHERE CustomerId = @CustomerId ) DECLARE @TempItem TABLE ( ItemId uniqueidentifier, CustomerId uniqueidentifier, Description nvarchar(100), Type int, Username nvarchar(100), TimeStamp datetime ); INSERT INTO Item OUTPUT INSERTED.* INTO @TempItem SELECT NEWID(), @CustomerId, @Description, @Type, @Username, GETDATE() SELECT ItemId, CustomerId, @TopRelatedItemId, Description, Type, Username, TimeStamp FROM @TempItem END GO
DECLARE @TempCustomer TABLE ( CustomerId uniqueidentifier, FirstName nvarchar(100), LastName nvarchar(100), Email nvarchar(100) ); SELECT CustomerId, FirstName, LastName, Email INTO @TempCustomer FROM Customer WHERE CustomerId = @CustomerId
DECLARE @TempCustomer TABLE ( CustomerId uniqueidentifier, FirstName nvarchar(100), LastName nvarchar(100), Email nvarchar(100) ); INSERT INTO @TempCustomer SELECT CustomerId, FirstName, LastName, Email FROM Customer WHERE CustomerId = @CustomerId
declare @var1 int,@var2 int,@var3 int; select @var1 = field1, @var2 = field2, @var3 = field3 from table where condition
SELECT CustomerId, FirstName, LastName, Email INTO FROM Customer WHERE CustomerId = @CustomerId
DECLARE @TempCustomer TABLE ( CustomerId uniqueidentifier, FirstName nvarchar(100), LastName nvarchar(100), Email nvarchar(100) ); INSERT @TempCustomer SELECT CustomerId, FirstName, LastName, Email FROM Customer WHERE CustomerId = @CustomerId
"SELECT * INTO @TempCustomer FROM Customer WHERE CustomerId = @CustomerId"
declare @databases table ( DatabaseID int, Name varchar(15), Server varchar(15) ) -- insert a bunch rows into @databases
Declare @Id int While (Select Count(*) From ATable Where Processed = 0) > 0 Begin Select Top 1 @Id = Id From ATable Where Processed = 0 --Do some processing here Update ATable Set Processed = 1 Where Id = @Id End
Select * Into From ATable Declare @Id int While (Select Count(*) From Begin Select Top 1 @Id = Id From --Do some processing here Delete End
declare @RowNum int, @CustId nchar(5), @Name1 nchar(25) select @CustId=MAX(USERID) FROM UserIDs --start with the highest ID Select @RowNum = Count(*) From UserIDs --get total number of records WHILE @RowNum > 0 --loop until no more records BEGIN select @Name1 = username1 from UserIDs where USERID= @CustID --get other info from that row print cast(@RowNum as char(12)) + select top 1 @CustId=USERID from UserIDs where USERID < @CustID order by USERID desc--get the next one set @RowNum = @RowNum - 1 --decrease count END
declare @databases table ( RowID int not null identity(1,1) primary key, DatabaseID int, Name varchar(15), Server varchar(15) ) -- insert a bunch rows into @databases
declare @i int select @i = min(RowID) from @databases declare @max int select @max = max(RowID) from @databases while @i <= @max begin select DatabaseID, Name, Server from @database where RowID = @i --do some stuff set @i = @i + 1 end
Select Identity(int, 1,1) AS PK, DatabaseID Into From @databases Declare @maxPK int;Select @maxPK = MAX(PK) From Declare @pk int;Set @pk = 1 While @pk <= @maxPK Begin -- Get one record Select DatabaseID, Name, Server From @databases Where DatabaseID = (Select DatabaseID From --Do some processing here -- Select @pk = @pk + 1 End
declare @databases table ( PK int IDENTITY(1,1), DatabaseID int, Name varchar(15), Server varchar(15) ) -- insert a bunch rows into @databases --/* INSERT INTO @databases (DatabaseID, Name, Server) SELECT 1, INSERT INTO @databases (DatabaseID, Name, Server) SELECT 1, --*/ Declare @maxPK int;Select @maxPK = MAX(PK) From @databases Declare @pk int;Set @pk = 1 While @pk <= @maxPK Begin /* Get one record (you can read the values into some variables) */ Select DatabaseID, Name, Server From @databases Where PK = @pk Select @pk = @pk + 1 End
DECLARE @rowCount int = 0 ,@currentRow int = 1 ,@databaseID int ,@name varchar(15) ,@server varchar(15); SELECT @rowCount = COUNT(*) FROM @databases; WHILE (@currentRow <= @rowCount) BEGIN SELECT TOP 1 @databaseID = rt.[DatabaseID] ,@name = rt.[Name] ,@server = rt.[Server] FROM ( SELECT ROW_NUMBER() OVER ( ORDER BY t.[DatabaseID], t.[Name], t.[Server] ) AS [RowNumber] ,t.[DatabaseID] ,t.[Name] ,t.[Server] FROM @databases t ) rt WHERE rt.[RowNumber] = @currentRow; EXEC [your_stored_procedure] @databaseID, @name, @server; SET @currentRow = @currentRow + 1; END
-- [PO_RollBackOnReject] alter procedure PO_RollBackOnReject @CaseID nvarchar(100) AS Begin SELECT * INTO FROM PO_InvoiceItems where CaseID = @CaseID Declare @Id int Declare @PO_No int Declare @Current_Balance Money While (Select ROW_NUMBER() OVER(ORDER BY PO_LineNo DESC) From Begin Select Top 1 @Id = PO_LineNo, @Current_Balance = Current_Balance, @PO_No = PO_No From update PO_Details Set Current_Balance = Current_Balance + @Current_Balance, Previous_App_Amount= Previous_App_Amount + @Current_Balance, Is_Processed = 0 Where PO_LineNumber = @Id AND PO_No = @PO_No update PO_InvoiceItems Set IsVisible = 0, Is_Processed= 0 ,Is_InProgress = 0 , Is_Active = 0 Where PO_LineNo = @Id AND PO_No = @PO_No End End
Declare @id int = 0, @anything nvarchar(max) WHILE(1=1) BEGIN Select Top 1 @anything=[Anything],@id=@id+1 FROM Table WHERE ID>@id if(@@ROWCOUNT=0) break; --Process @anything END
While (Select Count(*) From Begin Insert Into @Databases... Delete From End
declare @databases table ( DatabaseID int, Name varchar(15), Server varchar(15) ) --; Insert records into @databases... --; Recurse through @databases ;with DBs as ( select * from @databases where DatabaseID = 1 union all select A.* from @databases A inner join DBs B on A.DatabaseID = B.DatabaseID + 1 ) select * from DBs
insert @databases (DatabaseID, Name, Server) select DatabaseID, Name, Server From ... (Use whatever query you would have used in the loop or cursor)
DECLARE @databases TABLE ( DatabaseID int, Name varchar(15), Server varchar(15), fUsed BIT DEFAULT 0 ) -- insert a bunch rows into @databases DECLARE @DBID INT SELECT TOP 1 @DBID = DatabaseID from @databases where fUsed = 0 WHILE @@ROWCOUNT <> 0 and @DBID IS NOT NULL BEGIN -- Perform your processing here --Update the record to "used" UPDATE @databases SET fUsed = 1 WHERE DatabaseID = @DBID --Get the next record SELECT TOP 1 @DBID = DatabaseID from @databases where fUsed = 0 END
declare @Rowcount int select @Rowcount=count(*) from AddressTable; while( @Rowcount>0) begin select @Rowcount=@Rowcount-1; SELECT * FROM AddressTable order by AddressId desc OFFSET @Rowcount ROWS FETCH NEXT 1 ROWS ONLY; end
DECLARE @databases TABLE ( DatabaseID int, Name varchar(15), Server varchar(15) ) -- insert a bunch rows into @databases DECLARE @CurrID INT SELECT @CurrID = MIN(DatabaseID) FROM @databases WHILE @CurrID IS NOT NULL BEGIN -- Do stuff for @CurrID SELECT @CurrID = MIN(DatabaseID) FROM @databases WHERE DatabaseID > @CurrID END
DECLARE @TableVariable (ID int, Name varchar(50)); DECLARE @RecordCount int; SELECT @RecordCount = COUNT(*) FROM @TableVariable; WHILE @RecordCount > 0 BEGIN SELECT ID, Name FROM @TableVariable ORDER BY ID OFFSET @RecordCount - 1 FETCH NEXT 1 ROW; SET @RecordCount = @RecordCount - 1; END
insert into @tabela values (1, insert into @tabela values (2, insert into @tabela values (3, insert into @tabela values (4, return;
DECLARE @cod int, @nome varchar(10); DECLARE curLoop CURSOR STATIC LOCAL FOR SELECT cod ,nome FROM dbo.f_teste_loop(); OPEN curLoop; FETCH NEXT FROM curLoop INTO @cod, @nome; WHILE (@@FETCH_STATUS = 0) BEGIN PRINT @nome; FETCH NEXT FROM curLoop INTO @cod, @nome; END CLOSE curLoop; DEALLOCATE curLoop;
declare @databases table ( DatabaseID int, [Name] varchar(15), [Server] varchar(15) ); -- Populate the [@databases] table with test data. insert into @databases (DatabaseID, [Name], [Server]) select X.DatabaseID, X.[Name], X.[Server] from (values (1, (5, (8675309, ) X (DatabaseID, [Name], [Server]) -- Create an infinite loop & ensure that a break condition is reached in the loop code. declare @databaseId int; while (1=1) begin -- Get the next database ID. select top(1) @databaseId = DatabaseId from @databases where DatabaseId > isnull(@databaseId, 0); -- If no rows were found by the preceding SQL query, you if (@@ROWCOUNT = 0) break; -- Otherwise, do whatever you need to do with the current [@databases] table row here. print end
if object_ID( select + ,ROW_NUMBER() over (order by table_NAMe) as into from INFORMATION_SCHEMA.COLUMNS where (COLUMN_NAME like and TABLE_SCHEMA= declare @loopcntr int declare @ROW int declare @String nvarchar(1000) set @loopcntr=(select count(*) from set @ROW=1 while (@ROW <= @loopcntr) begin select top 1 @String=a.Field from where a.ROWNMBR = @ROW execute sp_executesql @String set @ROW = @ROW + 1 end
select eno,ename,eaddress,mobno int,row_number() over(order by eno desc) as rno into
while @rownumber>0 begin set @rno=@rownumber select @ename=ename from set @rownumber=@rownumber-1 print @ename ** end
SELECT trigger_name = name, trigger_owner = USER_NAME(uid),table_schema = , table_name = OBJECT_NAME(parent_obj), isupdate = OBJECTPROPERTY( id, isinsert = OBJECTPROPERTY( id, isinsteadof = OBJECTPROPERTY( id, [disabled] = OBJECTPROPERTY(id, FROM sysobjects INNER JOIN sysusers ON sysobjects.uid = sysusers.uid WHERE type =
SELECT sysobjects.name AS trigger_name ,USER_NAME(sysobjects.uid) AS trigger_owner ,s.name AS table_schema ,OBJECT_NAME(parent_obj) AS table_name ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY(id, FROM sysobjects INNER JOIN sysusers ON sysobjects.uid = sysusers.uid INNER JOIN sys.tables t ON sysobjects.parent_obj = t.object_id INNER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE sysobjects.type =
SELECT sysobjects.name AS trigger_name ,USER_NAME(sysobjects.uid) AS trigger_owner ,s.name AS table_schema ,OBJECT_NAME(parent_obj) AS table_name ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY(id, FROM sysobjects INNER JOIN sys.tables t ON sysobjects.parent_obj = t.object_id INNER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE sysobjects.type =
SELECT o.name AS trigger_name , /*USER_NAME(o.uid)*/ ,s.name AS table_schema ,OBJECT_NAME(o.parent_obj) AS table_name ,OBJECTPROPERTY(o.id, ,OBJECTPROPERTY(o.id, ,OBJECTPROPERTY(o.id, ,OBJECTPROPERTY(o.id, ,OBJECTPROPERTY(o.id, ,OBJECTPROPERTY(o.id, FROM sysobjects AS o INNER JOIN sysobjects AS o2 ON o.parent_obj = o2.id INNER JOIN sysusers AS s ON o2.uid = s.uid WHERE o.type =
SELECT [so].[name] AS [trigger_name], USER_NAME([so].[uid]) AS [trigger_owner], USER_NAME([so2].[uid]) AS [table_schema], OBJECT_NAME([so].[parent_obj]) AS [table_name], OBJECTPROPERTY( [so].[id], OBJECTPROPERTY( [so].[id], OBJECTPROPERTY( [so].[id], OBJECTPROPERTY( [so].[id], OBJECTPROPERTY( [so].[id], OBJECTPROPERTY([so].[id], FROM sysobjects AS [so] INNER JOIN sysobjects AS so2 ON so.parent_obj = so2.Id WHERE [so].[type] =
Select [tgr].[name] as [trigger name], [tbl].[name] as [table name] from sysobjects tgr join sysobjects tbl on tgr.parent_obj = tbl.id WHERE tgr.xtype =
SELECT o.[name], c.[text] FROM sys.objects AS o INNER JOIN sys.syscomments AS c ON o.object_id = c.id WHERE o.[type] =
SELECT ServerName = @@servername, DatabaseName = db_name(), SchemaName = isnull( s.name, TableName = isnull( o.name, TriggerName = t.name, Defininion = object_definition( t.object_id ) FROM sys.triggers t LEFT JOIN sys.all_objects o ON t.parent_id = o.object_id LEFT JOIN sys.schemas s ON s.schema_id = o.schema_id ORDER BY SchemaName, TableName, TriggerName
SELECT OBJECT_NAME(parent_id) as Table_Name, * FROM [Database_Name].sys.triggers
SELECT OBJECT_NAME(parent_id) Table_or_ViewNM, name TriggerNM, is_instead_of_trigger, is_disabled FROM sys.triggers WHERE parent_class_desc = ORDER BY OBJECT_NAME(parent_id), Name ;
SELECT sysobjects.name AS trigger_name ,OBJECT_NAME(parent_obj) AS table_name ,s.name AS table_schema ,USER_NAME(sysobjects.uid) AS trigger_owner ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY( id, ,OBJECTPROPERTY(id, FROM sysobjects INNER JOIN sysusers ON sysobjects.uid = sysusers.uid INNER JOIN sys.tables t ON sysobjects.parent_obj = t.object_id INNER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE sysobjects.type =
SELECT DB_NAME() AS DataBaseName, S.Name AS SchemaName, T.name AS TableName, dbo.SysObjects.Name AS TriggerName, dbo.sysComments.Text AS SqlContent, FROM dbo.SysObjects INNER JOIN dbo.sysComments ON dbo.SysObjects.ID = dbo.sysComments.ID INNER JOIN sys.tables AS T ON sysobjects.parent_obj = t.object_id INNER JOIN sys.schemas AS S ON t.schema_id = s.schema_id WHERE dbo.SysObjects.xType = AND dbo.SysObjects.Name LIKE
SELECT DISTINCT o.[name] AS [Table] FROM [sysobjects] o JOIN [sysobjects] tr ON o.[id] = tr.[parent_obj] WHERE tr.[type] = ORDER BY [Table] Get a list of tables and all their triggers. SELECT DISTINCT o.[name] AS [Table], tr.[name] AS [Trigger] FROM [sysobjects] o JOIN [sysobjects] tr ON o.[id] = tr.[parent_obj] WHERE tr.[type] = ORDER BY [Table], [Trigger]
Select [Parent] = Left((Case When Tr.Parent_Class = 0 Then [Schema] = Left(Coalesce(Object_Schema_Name(Tr.Object_ID), [Trigger name] = Left(Tr.Name, 32), [Type] = Left(Tr.Type_Desc, 3), -- SQL or CLR [MS?] = (Case When Tr.Is_MS_Shipped = 1 Then [On?] = (Case When Tr.Is_Disabled = 0 Then [Repl?] = (Case When Tr.Is_Not_For_Replication = 0 Then [Event] = Left((Case When Tr.Parent_Class = 0 Then (Select Top 1 Left(Te.Event_Group_Type_Desc, 40) From Sys.Trigger_Events As Te Where Te.Object_ID = Tr.Object_ID) Else ((Case When Tr.Is_Instead_Of_Trigger = 1 Then SubString(Cast((Select [text()] = (Case When Te.Is_First = 1 Then From Sys.Trigger_Events As Te Where Te.Object_ID = Tr.Object_ID Order By Te.[Type] For Xml Path ( -- If you like: -- , [Get text with] = From Sys.Triggers As Tr Order By Tr.Parent_Class, -- database triggers first Parent -- alphabetically by parent
Parent Schema Trigger name Type MS? On? Repl? Event -------------------------------- ---------------- -------------------------------- ---- ---- ---- ----- ----------------------------------------- (Database) (None) ddlDatabaseTriggerLog SQL X DDL_DATABASE_LEVEL_EVENTS Employee HumanResources dEmployee SQL X Instead Of Delete Person Person iuPerson SQL X After Insert, Update PurchaseOrderDetail Purchasing iPurchaseOrderDetail SQL X X After Insert PurchaseOrderDetail Purchasing uPurchaseOrderDetail SQL X X After Update PurchaseOrderHeader Purchasing uPurchaseOrderHeader SQL X X After Update SalesOrderDetail Sales iduSalesOrderDetail SQL X X After Insert, Update, Delete SalesOrderHeader Sales uSalesOrderHeader SQL X After Update (First) Vendor Purchasing dVendor SQL X Instead Of Delete WorkOrder Production iWorkOrder SQL X X After Insert WorkOrder Production uWorkOrder SQL X X After Update
SELECT tbl.name as Table_Name,trig.name as Trigger_Name,trig.is_disabled FROM [sys].[triggers] as trig inner join sys.tables as tbl on trig.parent_id = tbl.object_id
SELECT sysobjects.name AS trigger_name --,USER_NAME(sysobjects.uid) AS trigger_owner --,s.name AS table_schema --,OBJECT_NAME(parent_obj) AS table_name --,OBJECTPROPERTY( id, --,OBJECTPROPERTY( id, --,OBJECTPROPERTY( id, --,OBJECTPROPERTY( id, --,OBJECTPROPERTY( id, --,OBJECTPROPERTY(id, FROM sysobjects INNER JOIN sys.tables t ON sysobjects.parent_obj = t.object_id INNER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE sysobjects.type = EXCEPT SELECT OBJECT_NAME(parent_id) as Table_Name FROM sys.triggers
SELECT obj.NAME AS TBL,trg.name,sm.definition, FROM SYS.OBJECTS obj LEFT JOIN (SELECT trg1.object_id,trg1.parent_object_id,trg1.name FROM sys.objects trg1 WHERE trg1.type= ON obj.object_id=trg.parent_object_id LEFT JOIN (SELECT sm1.object_id,sm1.definition FROM sys.sql_modules sm1 where sm1.definition like WHERE obj.type= ORDER BY obj.name;
CREATE TABLE [dbo].[VERSIONS]( [ID] [uniqueidentifier] NOT NULL, [DATE] [varchar](100) NULL, [SERVER] [varchar](100) NULL, [DATABASE] [varchar](100) NULL, [USER] [varchar](100) NULL, [OBJECT] [varchar](100) NULL, [ACTION] [varchar](100) NULL, [CODE] [varchar](max) NULL, CONSTRAINT [PK_VERSIONS] PRIMARY KEY CLUSTERED ( [ID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY] GO ALTER TABLE [dbo].[VERSIONS] ADD CONSTRAINT [DF_VERSIONS_ID] DEFAULT (newid()) FOR [ID] GO DROP TRIGGER [DB_VERSIONS_TRIGGER] ON ALL SERVER CREATE TRIGGER [DB_VERSIONS_TRIGGER] ON ALL SERVER FOR CREATE_PROCEDURE, ALTER_PROCEDURE, DROP_PROCEDURE, CREATE_TRIGGER, ALTER_TRIGGER, DROP_TRIGGER, CREATE_FUNCTION, ALTER_FUNCTION, DROP_FUNCTION, CREATE_VIEW, ALTER_VIEW, DROP_VIEW, CREATE_TABLE, ALTER_TABLE, DROP_TABLE AS SET NOCOUNT ON SET XACT_ABORT OFF; BEGIN TRY DECLARE @DATA XML = EVENTDATA() DECLARE @SERVER VARCHAR(100) = @DATA.value( DECLARE @DATABASE VARCHAR(100) = @DATA.value( DECLARE @USER VARCHAR(100) = @DATA.value( DECLARE @OBJECT VARCHAR(100) = @DATA.value( DECLARE @ACTION VARCHAR(100) = @DATA.value( DECLARE @CODE VARCHAR(MAX) = @DATA.value( IF OBJECT_ID( BEGIN INSERT INTO [DB_VERSIONS].[dbo].[VERSIONS]([SERVER], [DATABASE], [USER], [OBJECT], [ACTION], [DATE], [CODE]) VALUES (@SERVER, @DATABASE, @USER, @OBJECT, @ACTION, getdate(), ISNULL(@CODE, END END TRY BEGIN CATCH END CATCH RETURN
DECLARE @str VARCHAR(255) SET @str = IF (@str LIKE PRINT ELSE PRINT
-- BEGIN TRANSACTION (HOW TO DO?) UPDATE Bookings SET TicketsBooked = TicketsBooked + @TicketsToBook WHERE FlightId = @Id AND TicketsMax < (TicketsBooked + @TicketsToBook) -- Here I need to insert only if the row doesn -- If the row exists but the condition TicketsMax is violated, I must not insert -- the row and return FALSE IF @@ROWCOUNT = 0 BEGIN INSERT INTO Bookings ... (omitted) END -- END TRANSACTION (HOW TO DO?) -- Return TRUE (How to do?)
if exists(select 1 from INFORMATION_SCHEMA.TABLES T where T.TABLE_NAME = begin drop table Bookings end GO create table Bookings( FlightID int identity(1, 1) primary key, TicketsMax int not null, TicketsBooked int not null ) GO insert Bookings(TicketsMax, TicketsBooked) select 1, 0 insert Bookings(TicketsMax, TicketsBooked) select 2, 2 insert Bookings(TicketsMax, TicketsBooked) select 3, 1 GO select * from Bookings
declare @FlightID int = 1 declare @TicketsToBook int = 2 --; This should add a new record merge Bookings as T using (select @FlightID as FlightID, @TicketsToBook as TicketsToBook) as S on T.FlightID = S.FlightID and T.TicketsMax > (T.TicketsBooked + S.TicketsToBook) when matched then update set T.TicketsBooked = T.TicketsBooked + S.TicketsToBook when not matched then insert (TicketsMax, TicketsBooked) values(S.TicketsToBook, S.TicketsToBook); select * from Bookings
IF EXISTS (SELECT * FROM Bookings WHERE FLightID = @Id) BEGIN --UPDATE HERE END ELSE BEGIN -- INSERT HERE END
begin tran if not exists (select * from Table with (updlock, rowlock, holdlock) where ...) else commit
INSERT INTO TableName (col1,col2) SELECT @par1, @par2 WHERE NOT EXISTS (SELECT col1,col2 FROM TableName WHERE col1=@par1 AND col2=@par2)
INSERT INTO Members (username) SELECT WHERE NOT EXISTS (SELECT username FROM Members WHERE username=
set ANSI_NULLS ON set QUOTED_IDENTIFIER ON GO ALTER PROCEDURE [dbo].[cjso_UpdateCustomerLogin] ( @CustomerID AS INT, @UserName AS VARCHAR(25), @Password AS BINARY(16) ) AS BEGIN IF ISNULL((SELECT CustomerID FROM tblOnline_CustomerAccount WHERE CustomerID = @CustomerID), 0) = 0 BEGIN INSERT INTO [tblOnline_CustomerAccount] ( [CustomerID], [UserName], [Password], [LastLogin] ) VALUES ( @CustomerID, /* UserName - varchar(25) */ @UserName, /* Password - binary(16) */ @Password, NULL ) END ELSE BEGIN UPDATE [tblOnline_CustomerAccount] SET UserName = @UserName, Password = @Password WHERE CustomerID = @CustomerID END END
INSERT INTO table ( column1, column2, column3 ) ( SELECT $column1, $column2, $column3 WHERE NOT EXISTS ( SELECT 1 FROM table WHERE column1 = $column1 AND column2 = $column2 AND column3 = $column3 ) )
declare @rowCount int select @rowCount=@@RowCount if @rowCount=0 begin --insert....
declare @mystat6 bigint declare @mystat6p varchar(50) declare @mystat6b bigint DECLARE mycur1 CURSOR for select result1,picture,bittot from all_Tempnogos2results11 OPEN mycur1 FETCH NEXT FROM mycur1 INTO @mystat6, @mystat6p , @mystat6b WHILE @@Fetch_Status = 0 BEGIN begin tran if not exists (select * from all_Tempnogos2results11_uniq with (updlock, rowlock, holdlock) where all_Tempnogos2results11_uniq.result1 = @mystat6 and all_Tempnogos2results11_uniq.bittot = @mystat6b ) insert all_Tempnogos2results11_uniq values (@mystat6 , @mystat6p , @mystat6b) --else -- commit FETCH NEXT FROM mycur1 INTO @mystat6 , @mystat6p , @mystat6b END CLOSE mycur1 DEALLOCATE mycur1 go
INSERT INTO [DatabaseName1].dbo.[TableName1] SELECT * FROM [DatabaseName2].dbo.[TableName2] WHERE [YourPK] not in (select [YourPK] from [DatabaseName1].dbo.[TableName1])
INSERT INTO table ( column1, column2, column3 ) SELECT $column1, $column2, $column3 EXCEPT SELECT column1, column2, column3 FROM table
ALTER TABLE [Employee] ALTER COLUMN [Salary] NUMERIC(22,5) NOT NULL
alter table Employee alter column salary numeric(22,5)
IF COLUMNPROPERTY(OBJECT_ID( ALTER TABLE [Employee] ALTER COLUMN [Salary] NUMERIC(22,5) NOT NULL ELSE ALTER TABLE [Employee] ALTER COLUMN [Salary] NUMERIC(22,5) NULL
ALTER TABLE [table_name] ALTER COLUMN [column_name] varchar(150)
USE [Database Name] SELECT COLUMN_NAME,* FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =
select syscolumns.name as [Column], syscolumns.xusertype as [Type], sysobjects.xtype as [Objtype] from sysobjects inner join syscolumns on sysobjects.id = syscolumns.id where sysobjects.xtype = and sysobjects.name = order by syscolumns.name
IF EXISTS ( SELECT * FROM syscolumns WHERE id=OBJECT_ID( AND name= ) BEGIN PRINT END
SELECT st.NAME, sc.NAME, sc.system_type_id FROM sys.tables st INNER JOIN sys.columns sc ON st.object_id = sc.object_id WHERE st.name LIKE
SELECT COLUMN_NAME FROM YOUR_DB_NAME.INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =
CREATE PROCEDURE [dbo].[Usp_GetColumnName] @TableName varchar(50) AS BEGIN BEGIN SET NOCOUNT ON IF (@TableName IS NOT NULL) select ORDINAL_POSITION OrderPosition,COLUMN_NAME ColumnName from information_schema.columns where table_name =@TableName order by ORDINAL_POSITION END END
select syscolumns.name, syscolumns.colid from sysobjects, syscolumns where sysobjects.id = syscolumns.id and sysobjects.xtype = sysobjects.name = order by syscolumns.colid
declare @Result varchar(max)=' ' select @Result=@Result+ ' from ( select replace(col.name, column_id ColumnId from sys.columns col join sys.types typ on col.system_type_id = typ.system_type_id AND col.user_type_id = typ.user_type_id where object_id = object_id( ) t order by ColumnId print @Result
declare @TableName sysname = declare @Result varchar(max) = {' select @Result = @Result + ' public static string ' from ( select replace(col.name, column_id ColumnId from sys.columns col join sys.types typ on col.system_type_id = typ.system_type_id AND col.user_type_id = typ.user_type_id where object_id = object_id(@TableName) ) t order by ColumnId set @Result = @Result + ' }' print @Result
public class tblPracticeTestSections { public static string column1 { get { return "column1"; } } public static string column2{ get { return "column2"; } } public static string column3{ get { return "column3"; } } public static string column4{ get { return "column4"; } } }
SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =
SELECT COLUMN_NAME, * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N
Select ObjectName = Object_Name(Object_ID) ,T.Name ,C.* ,T.* From Sys.All_Columns C Inner Join Sys.Types T On T.User_Type_Id = C.User_Type_Id Where [Object_ID] = Object_ID( --Order By Name Asc
DECLARE @col NVARCHAR(MAX); SELECT @col= COALESCE(@col, FROM INFORMATION_SCHEMA.COLUMNS WHERE Table_name = SELECT @col;
-- Replace PRINT function DECLARE @strMsg NVARCHAR(100) SELECT @strMsg = RAISERROR (@strMsg, 0, 1) WITH NOWAIT
IF EXISTS(SELECT 1 FROM sys.objects WHERE OBJECT_ID = OBJECT_ID(N go
ALTER TABLE [dbo].[TableName] WITH CHECK ADD CONSTRAINT [FK_TableName_TableName2] FOREIGN KEY([FK_Name]) REFERENCES [dbo].[TableName2] ([ID]) go
IF EXISTS (SELECT * FROM sys.foreign_keys WHERE object_id = OBJECT_ID(N AND parent_object_id = OBJECT_ID(N ) ALTER TABLE [dbo.TableName] DROP CONSTRAINT [FK_TableName_TableName2]
IF (OBJECT_ID( BEGIN ALTER TABLE dbo.TableName DROP CONSTRAINT FK_ConstraintName END
C = CHECK constraint D = DEFAULT (constraint or stand-alone) F = FOREIGN KEY constraint PK = PRIMARY KEY constraint UQ = UNIQUE constraint
AF = Aggregate function (CLR) C = CHECK constraint D = DEFAULT (constraint or stand-alone) F = FOREIGN KEY constraint FN = SQL scalar function FS = Assembly (CLR) scalar-function FT = Assembly (CLR) table-valued function IF = SQL inline table-valued function IT = Internal table P = SQL Stored Procedure PC = Assembly (CLR) stored-procedure PG = Plan guide PK = PRIMARY KEY constraint R = Rule (old-style, stand-alone) RF = Replication-filter-procedure S = System base table SN = Synonym SO = Sequence object
SQ = Service queue TA = Assembly (CLR) DML trigger TF = SQL table-valued-function TR = SQL DML trigger TT = Table type U = Table (user-defined) UQ = UNIQUE constraint V = View X = Extended stored procedure
CREATE TABLE t(id int primary key, parentid int constraint tpartnt foreign key references t(id)) GO ALTER TABLE t DROP CONSTRAINT IF EXISTS tpartnt GO DROP TABLE IF EXISTS t
create function fnGetForeignKeyName ( @ParentTableName nvarchar(255), @ParentColumnName nvarchar(255), @ReferencedTableName nvarchar(255), @ReferencedColumnName nvarchar(255) ) returns nvarchar(255) as begin declare @name nvarchar(255) select @name = fk.name from sys.foreign_key_columns fc join sys.columns pc on pc.column_id = parent_column_id and parent_object_id = pc.object_id join sys.columns rc on rc.column_id = referenced_column_id and referenced_object_id = rc.object_id join sys.objects po on po.object_id = pc.object_id join sys.objects ro on ro.object_id = rc.object_id join sys.foreign_keys fk on fk.object_id = fc.constraint_object_id where po.object_id = object_id(@ParentTableName) and ro.object_id = object_id(@ReferencedTableName) and pc.name = @ParentColumnName and rc.name = @ReferencedColumnName return @name end go declare @name nvarchar(255) declare @sql nvarchar(4000) -- hunt for the constraint name on select @name = dbo.fnGetForeignKeyName( -- if we find it, the name will not be null if @name is not null begin set @sql = exec (@sql) end
IF (OBJECT_ID( BEGIN ALTER TABLE [dbo].[tableName] DROP CONSTRAINT DF_Constraint END
ALTER TABLE [dbo].[TableName] DROP CONSTRAINT FK_TableName_TableName2
Declare @FKeyRemoveQuery NVarchar(max) IF EXISTS(SELECT 1 FROM sys.foreign_keys WHERE parent_object_id = OBJECT_ID(N BEGIN SELECT @FKeyRemoveQuery= FROM sys.foreign_keys WHERE parent_object_id = OBJECT_ID(N EXECUTE Sp_executesql @FKeyRemoveQuery END
DECLARE @ConstraintName nvarchar(200) SELECT @ConstraintName = KCU.CONSTRAINT_NAME FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU ON KCU.CONSTRAINT_CATALOG = RC.CONSTRAINT_CATALOG AND KCU.CONSTRAINT_SCHEMA = RC.CONSTRAINT_SCHEMA AND KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME WHERE KCU.TABLE_NAME = KCU.COLUMN_NAME = IF @ConstraintName IS NOT NULL EXEC(
Declare @SchemaName VarChar(200) = Declare @TableName VarChar(200) = -- Find FK in This table. SELECT + + OBJECT_NAME(FK.parent_object_id) + , S.name , O.name, OBJECT_NAME(FK.parent_object_id) FROM sys.foreign_keys AS FK INNER JOIN Sys.objects As O ON (O.object_id = FK.parent_object_id ) INNER JOIN SYS.schemas AS S ON (O.schema_id = S.schema_id) WHERE O.name = @TableName And S.name = @SchemaName -- Find the FKs in the tables in which this table is used SELECT + + OBJECT_NAME(FK.parent_object_id) + , S.name , O.name, OBJECT_NAME(FK.parent_object_id) FROM sys.foreign_keys AS FK INNER JOIN Sys.objects As O ON (O.object_id = FK.referenced_object_id ) INNER JOIN SYS.schemas AS S ON (O.schema_id = S.schema_id) WHERE O.name = @TableName And S.name = @SchemaName
IF (select object_id from sys.foreign_keys where [name] = BEGIN ALTER TABLE dbo.TableName DROP CONSTRAINT FK_TableName_TableName2 END
SET STATISTICS TIME ON select FORMAT(N, SET STATISTICS TIME OFF
SET STATISTICS TIME ON select right( SET STATISTICS TIME OFF
@padstr = REPLICATE(@padchar, @len) -- this can be cached, done only once SELECT RIGHT(@padstr + @str, @len)
ALTER Function [dbo].[fsPadLeft](@var varchar(200),@padChar char(1)= returns varchar(300) as Begin return replicate(@PadChar,@len-Len(@var))+@var end
ALTER function [dbo].[fsPadRight](@var varchar(200),@padchar char(1)= Begin --select @padChar= return @var+replicate(@PadChar,@len-Len(@var)) end
DECLARE @pad_characters VARCHAR(10) SET @pad_characters = SELECT RIGHT(@pad_characters + @str, 10)
CREATE FUNCTION [dbo].[f_pad_before](@string VARCHAR(255), @desired_length INTEGER, @pad_character CHAR(1)) RETURNS VARCHAR(255) AS BEGIN -- Prefix the required number of spaces to bulk up the string and then replace the spaces with the desired character RETURN ltrim(rtrim( CASE WHEN LEN(@string) < @desired_length THEN REPLACE(SPACE(@desired_length - LEN(@string)), ELSE @string END )) END
create function PadLeft( @String varchar(8000) ,@NumChars int ,@PadChar char(1) = returns varchar(8000) as begin return stuff(@String, 1, 0, replicate(@PadChar, @NumChars - len(@String))) end
select right(replicate(@padchar, @len) + @str, @len)
DECLARE @value = 20.1 SET @value = ROUND(@value,2) * 100 PRINT LEFT(CAST(@value AS VARCHAR(20)), LEN(@value)-2) +
CREATE FUNCTION [dbo].[svfn_AMS_PAD_STRING] ( @MyStr VARCHAR(25), @LENGTH INT, @PadChar CHAR(1) = NULL ) RETURNS VARCHAR(25) AS BEGIN SET @PadChar = ISNULL(@PadChar, DECLARE @Result VARCHAR(25); SELECT @Result = RIGHT(SUBSTRING(REPLICATE( (@LENGTH + 1) - LEN(RTRIM(@MyStr))) + RTRIM(@MyStr), @LENGTH) RETURN @Result END
--[@charToPadStringWith] is the character you want to pad the string with. declare @charToPadStringWith char(1) = -- Generate a table of values to test with. declare @stringValues table (RowId int IDENTITY(1,1) NOT NULL PRIMARY KEY, StringValue varchar(max) NULL); insert into @stringValues (StringValue) values (null), ( -- Generate a table to store testing results in. declare @testingResults table (RowId int IDENTITY(1,1) NOT NULL PRIMARY KEY, StringValue varchar(max) NULL, PaddedStringValue varchar(max) NULL); -- Get the length of the longest string, then pad all strings based on that length. declare @maxLengthOfPaddedString int = (select MAX(LEN(StringValue)) from @stringValues); declare @longestStringValue varchar(max) = (select top(1) StringValue from @stringValues where LEN(StringValue) = @maxLengthOfPaddedString); select [@longestStringValue]=@longestStringValue, [@maxLengthOfPaddedString]=@maxLengthOfPaddedString; -- Loop through each of the test string values, apply padding to it, and store the results in [@testingResults]. while (1=1) begin declare @stringValueRowId int, @stringValue varchar(max); -- Get the next row in the [@stringLengths] table. select top(1) @stringValueRowId = RowId, @stringValue = StringValue from @stringValues where RowId > isnull(@stringValueRowId, 0) order by RowId; if (@@ROWCOUNT = 0) break; -- Here is where the padding magic happens. declare @paddedStringValue varchar(max) = RIGHT(REPLICATE(@charToPadStringWith, @maxLengthOfPaddedString) + @stringValue, @maxLengthOfPaddedString); -- Added to the list of results. insert into @testingResults (StringValue, PaddedStringValue) values (@stringValue, @paddedStringValue); end -- Get all of the testing results. select * from @testingResults;
DECLARE @i int = 0 WHILE @i < 20 BEGIN SET @i = @i + 1 END
DECLARE @intFlag INT SET @intFlag = 1 WHILE (@intFlag <=5) BEGIN PRINT @intFlag SET @intFlag = @intFlag + 1 END GO
DECLARE @i INT = 0; SELECT @count= Count(*) FROM TABLE WHILE @i <= @count BEGIN SELECT * FROM TABLE ORDER BY COLUMN OFFSET @i ROWS FETCH NEXT 1 ROWS ONLY SET @i = @i + 1; END
DECLARE @a INT = 10 WHILE @a <= 20 BEGIN PRINT @a SET @a = @a + 1 END
DECLARE @a INT = 10 a: PRINT @a SET @a = @a + 1 IF @a < = 20 BEGIN GOTO a END
DECLARE @cnt INT = 0; WHILE @cnt < 10 BEGIN PRINT SET @cnt = @cnt + 1; END; PRINT
DECLARE @X INT=1; WAY: --> Here the DO statement PRINT @X; SET @X += 1; IF @X<=10 GOTO WAY;
DECLARE @X INT = 1; WAY: -- Here the REPEAT statement PRINT @X; SET @X += 1; IFNOT(@X > 10) GOTO WAY;
DECLARE @Today DATE= GETDATE() , @StartOfMonth DATE , @EndOfMonth DATE; DECLARE @DateList TABLE ( DateLabel VARCHAR(10) ); SET @EndOfMonth = EOMONTH(GETDATE()); SET @StartOfMonth = DATEFROMPARTS(YEAR(@Today), MONTH(@Today), 1); WHILE @StartOfMonth <= @EndOfMonth BEGIN INSERT INTO @DateList VALUES ( @StartOfMonth ); SET @StartOfMonth = DATEADD(DAY, 1, @StartOfMonth); END; SELECT DateLabel FROM @DateList;
SELECT first_name + CASE last_name WHEN null THEN FROM dbo.person
SELECT first_name + CASE last_name WHEN null THEN FROM dbo.person
SELECT CASE WHEN last_name is NULL THEN first_name ELSE first_name +
SELECT CASE LEN(ISNULL(last_name, WHEN 0 THEN ELSE END AS newlastName
SELECT CASE LENGTH(IFNULL(last_name, WHEN 0 THEN ELSE END AS newlastName
SELECT CASE LENGTH(NVL(last_name, WHEN 0 THEN ELSE END AS newlastName
CASE LEN(ISNULL(last_Name, WHEN 0 THEN ELSE END AS newlastName
DECLARE @last_Name varchar(50) = NULL SELECT CASE LEN(ISNULL(@last_Name, WHEN 0 THEN ELSE END AS newlastName SET @last_Name = SELECT CASE LEN(ISNULL(@last_Name, WHEN 0 THEN ELSE END AS newlastName
select isnull(rtrim(ltrim([FirstName]))+ isnull(rtrim(ltrim([SecondName]))+ isnull(rtrim(ltrim([Surname]))+ isnull(rtrim(ltrim([SecondSurname])), from TableDat
CASE WHEN LEN(CAST(field_value AS VARCHAR(MAX))) = 0 THEN DO THIS END AS field
WITH CTE AS ( Select Question_Text, (SELECT Count(*) FROM Answers A WHERE A.Question_ID = Q.ID) AS Number_Of_Answers FROM Questions Q ) SELECT * FROM CTE WHERE Number_Of_Answers > 0
WITH cte AS ( SELECT [Quiz_ID] ,[ID] AS Question_Id ,null AS Answer_Id ,[Question_Text] ,null AS Answer ,1 AS Is_Question FROM [Questions] UNION ALL SELECT Q.[Quiz_ID] ,[Question_ID] ,A.[ID] AS Answer_Id ,Q.Question_Text ,[Answer] ,0 AS Is_Question FROM [Answers] A INNER JOIN [Questions] Q ON Q.Quiz_ID = A.Quiz_ID AND Q.Id = A.Question_Id ) SELECT Quiz_Id, Question_Id, Is_Question, (CASE WHEN Answer IS NULL THEN Question_Text ELSE Answer END) as Name FROM cte GROUP BY Quiz_Id, Question_Id, Answer_id, Question_Text, Answer, Is_Question order by Quiz_Id, Question_Id, Is_Question Desc, Name
WITH CTE AS( SELECT myTable.* , RN = ROW_NUMBER()OVER(PARTITION BY patientID ORDER BY ID) FROM myTable ) SELECT * FROM CTE WHERE RN = 1
WITH [cte_example] AS ( SELECT 1 AS [myNum], UNION ALL SELECT [myNum]+1,[label] FROM [cte_example] WHERE [myNum] <= 10 ) SELECT * FROM [cte_example] UNION SELECT SUM([myNum]), UNION SELECT SUM([myNum]), UNION SELECT SUM([myNum]),
with [Name of CTE] as ( Body of common table expression )
CREATE TABLE Employee([EID] [int] IDENTITY(10,5) NOT NULL,[Name] [varchar](50) NULL) insert into Employee(Name) values( insert into Employee(Name) values( insert into Employee(Name) values( insert into Employee(Name) values( insert into Employee(Name) values( CREATE TABLE DEPT(EID INT,DEPTNAME VARCHAR(100)) insert into dept values(10, insert into dept values(15, insert into dept values(20, insert into dept values(25, insert into dept values(10,
With CTE_Example(EID,Name,DeptName) as ( select Employee.EID,Name,DeptName from Employee inner join DEPT on Employee.EID =DEPT.EID ) select * from CTE_Example
With CTE_Example(EID,DeptName) as ( select EID,DeptName from DEPT ) delete from CTE_Example where EID=10 and DeptName =
WITH cte AS ( SELECT TOP(5000) message_compressed, message, exception_compressed, exception FROM logs WHERE Id >= 5519694 ORDER BY Id ) UPDATE cte SET message_compressed = COMPRESS(message), exception_compressed = COMPRESS(exception)
;with cte as ( Select Department, Max(salary) as MaxSalary from test group by department ) select t.* from test t join cte c on c.department=t.department where t.salary=c.MaxSalary;
SELECT columns FROM table WHERE column LIKE -- or SELECT columns FROM table WHERE column LIKE
String FormattedString = "UserString".Replace("ð","ðð").Replace("_", "ð_").Replace("%", "ð%").Replace("[", "ð[");
SELECT DATENAME(month, DATEADD(month, @mydate-1, CAST(
Select DateName( month , DateAdd( month , @MonthNumber , 0 ) - 1 )
Select DateName( month , DateAdd( month , @MonthNumber , -1 ) )
Select DateName( month , DateAdd( month , @MonthNumber , -1 ))
DECLARE @integer int; SET @integer = 6; SELECT DATENAME(m, str(@integer) +
SELECT DATENAME(month, STR(YEAR(GETDATE()), 4) + REPLACE(STR(@month, 2),
select CONVERT(varchar(3), Date, 100) as Month from MyTable.
SELECT CONVERT(CHAR(3), DATENAME(MONTH, GETDATE()))
print datename(month,dateadd(month,-month(getdate()) + 9,getdate()))
declare @month smallint = 1 select DateName(mm,DATEADD(mm,@month - 1,0))
@MetricMonthNumber (some number) SELECT (DateName( month , DateAdd( month , @MetricMonthNumber - 1 , FROM TableName
Declare @MonthNumber int SET @MonthNumber=DatePart(Month,GETDATE()) Select DateName( month , DateAdd( month , @MonthNumber , 0 ) - 1 )
SELECT MONTHNAME(<fieldname>) AS "Month Name" FROM <tablename> WHERE <condition>
id name created_at 1 abc 2017-09-16 2 xyz 2017-06-10
select year(created_at), monthname(created_at) from users;
+-----------+-------------------------------+ | year(created_at) | monthname(created_at) | +-----------+-------------------------------+ | 2017 | september | | 2017 | june |
SELECT DATENAME(MONTH,dateadd(month, -3,getdate()))
CREATE FUNCTION fn_month_num_to_name ( @month_num tinyint ) RETURNS varchar(20) AS BEGIN RETURN FORMAT(DATEFROMPARTS(1900, @month_num, 1), END
DECLARE @date datetime SET @date= SELECT CAST(DATENAME(month,@date ) AS CHAR(3))AS
datename(month,dateadd(month,datepart(month,Help_HelpMain.Ticket_Closed_Date),-1)) as monthname
--Create the user-defined function CREATE FUNCTION getmonth (@num int) RETURNS varchar(9) --since AS BEGIN DECLARE @intMonth Table (num int PRIMARY KEY IDENTITY(1,1), month varchar(9)) INSERT INTO @intMonth VALUES ( , ( , ( RETURN (SELECT I.month FROM @intMonth I WHERE I.num = @num) END GO --Use the function for various months SELECT dbo.getmonth(4) AS [Month] SELECT dbo.getmonth(5) AS [Month] SELECT dbo.getmonth(6) AS [Month]
/****** Object: UserDefinedFunction [dbo].[fn_GetMonthFromDate] Script Date: 11/16/2018 10:26:33 AM ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE FUNCTION [dbo].[fn_GetMonthFromDate] (@date datetime) RETURNS varchar(50) AS BEGIN DECLARE @monthPart int SET @monthPart = MONTH(@date) IF @monthPart = 1 BEGIN RETURN END ELSE IF @monthPart = 2 BEGIN RETURN END ELSE IF @monthPart = 3 BEGIN RETURN END ELSE IF @monthPart = 4 BEGIN RETURN END ELSE IF @monthPart = 5 BEGIN RETURN END ELSE IF @monthPart = 6 BEGIN RETURN END ELSE IF @monthPart = 7 BEGIN RETURN END ELSE IF @monthPart = 8 BEGIN RETURN END ELSE IF @monthPart = 9 BEGIN RETURN END ELSE IF @monthPart = 10 BEGIN RETURN END ELSE IF @monthPart = 11 BEGIN RETURN END ELSE IF @monthPart = 12 BEGIN RETURN END RETURN NULL END
-- disable all constraints EXEC sp_MSForEachTable "ALTER TABLE ? NOCHECK CONSTRAINT all" -- delete data in all tables EXEC sp_MSForEachTable "DELETE FROM ?" -- enable all constraints exec sp_MSForEachTable "ALTER TABLE ? WITH CHECK CHECK CONSTRAINT all"
SET QUOTED_IDENTIFIER ON; EXEC sp_MSforeachtable EXEC sp_MSforeachtable EXEC sp_MSforeachtable EXEC sp_MSforeachtable EXEC sp_MSforeachtable EXEC sp_MSforeachtable IF NOT EXISTS ( SELECT * FROM SYS.IDENTITY_COLUMNS JOIN SYS.TABLES ON SYS.IDENTITY_COLUMNS.Object_ID = SYS.TABLES.Object_ID WHERE SYS.TABLES.Object_ID = OBJECT_ID( ) AND OBJECTPROPERTY( OBJECT_ID( DBCC CHECKIDENT (
declare @LastObjectID int = 0 declare @TableName nvarchar(100) = set @LastObjectID = (select top 1 [object_id] from sys.tables where [object_id] > @LastObjectID order by [object_id]) while(@LastObjectID is not null) begin set @TableName = (select top 1 [name] from sys.tables where [object_id] = @LastObjectID) if(@TableName not in ( begin exec( end set @LastObjectID = (select top 1 [object_id] from sys.tables where [object_id] > @LastObjectID order by [object_id]) end
DECLARE @myTempTable TABLE (tableName varchar(200)) INSERT INTO @myTempTable(tableName) VALUES ( ( ( -- DROP FK Contraints SELECT FROM sys.objects ob INNER JOIN sys.foreign_keys fk ON fk.parent_object_id = ob.object_id WHERE fk.referenced_object_id IN ( SELECT so.object_id FROM sys.objects so JOIN sys.schemas sc ON so.schema_id = sc.schema_id WHERE so.name IN (SELECT * FROM @myTempTable) AND sc.name=N -- CREATE FK Contraints SELECT REFERENCES [PIMSUser].[dbo].[ FROM sysobjects f INNER JOIN sys.sysobjects c ON f.parent_obj = c.id INNER JOIN sys.sysreferences r ON f.id = r.constid INNER JOIN sys.sysobjects p ON r.rkeyid = p.id INNER JOIN sys.syscolumns rc ON r.rkeyid = rc.id and r.rkey1 = rc.colid INNER JOIN sys.syscolumns fc ON r.fkeyid = fc.id and r.fkey1 = fc.colid WHERE f.type = AND cast(p.name as varchar(255)) IN (SELECT * FROM @myTempTable)
/* CREATE TABLE _ScriptLog ( ID Int NOT NULL Identity(1,1) , DateAdded DateTime2 NOT NULL DEFAULT GetDate() , Script NVarChar(4000) NOT NULL ) CREATE UNIQUE CLUSTERED INDEX IX_ScriptLog_DateAdded_ID_U_C ON _ScriptLog ( DateAdded , ID ) CREATE TABLE _TruncateList ( TableName SysName PRIMARY KEY ) */ IF OBJECT_ID( DROP TABLE END IF OBJECT_ID( DROP TABLE END IF OBJECT_ID( DROP TABLE END SELECT Scripts = INTO FROM .sys.foreign_keys AS f INNER JOIN .sys.foreign_key_columns AS fc ON f.OBJECT_ID = fc.constraint_object_id SELECT TableName INTO FROM _TruncateList SELECT Scripts = ADD CONSTRAINT ) REFERENCES ' INTO FROM ( SELECT QUOTENAME(fk.NAME) AS [const_name] ,QUOTENAME(schParent.NAME) + ,STUFF(( SELECT FROM sys.foreign_key_columns AS fcP WHERE fcp.constraint_object_id = fk.object_id FOR XML path( ), 1, 1, ,QUOTENAME(schRef.NAME) + ,STUFF(( SELECT FROM sys.foreign_key_columns AS fcR WHERE fcR.constraint_object_id = fk.object_id FOR XML path( ), 1, 1, FROM sys.foreign_key_columns AS fkc INNER JOIN sys.foreign_keys AS fk ON fk.object_id = fkc.constraint_object_id INNER JOIN sys.objects AS oParent ON oParent.object_id = fkc.parent_object_id INNER JOIN sys.schemas AS schParent ON schParent.schema_id = oParent.schema_id INNER JOIN sys.objects AS oRef ON oRef.object_id = fkc.referenced_object_id INNER JOIN sys.schemas AS schRef ON schRef.schema_id = oRef.schema_id GROUP BY fkc.parent_object_id ,fkc.referenced_object_id ,fk.NAME ,fk.object_id ,schParent.NAME ,schRef.NAME ) AS const ORDER BY const.const_name INSERT INTO _ScriptLog (Script) SELECT Scripts FROM DECLARE @Cmd NVarChar(4000) , @TableName SysName WHILE 0 < (SELECT Count(1) FROM SELECT TOP 1 @Cmd = Scripts FROM EXEC (@Cmd) DELETE END WHILE 0 < (SELECT Count(1) FROM SELECT TOP 1 @Cmd = N , @TableName = TableName FROM EXEC (@Cmd) DELETE END WHILE 0 < (SELECT Count(1) FROM SELECT TOP 1 @Cmd = Scripts FROM EXEC (@Cmd) DELETE END
declare @top int set @top = 5 select top @top * from tablename
SELECT TOP (@foo) a FROM table ORDER BY a SELECT TOP (SELECT COUNT(*) FROM somewhere else) a FROM table ORDER BY a SELECT TOP (@foo + 5 * 4 / 2) a FROM table ORDER BY a
-- Works in all versions SELECT TOP 10 -- Does not work on 2000 SELECT TOP (10) SELECT TOP (@rows) -- Works in both 2ooo and 2oo5 SET ROWCOUNT @max SELECT * FROM ... SET ROWCOUNT 0
BEGIN TRY BEGIN TRAN SELECT 1/0 AS CauseAnException COMMIT END TRY BEGIN CATCH SELECT ERROR_MESSAGE() THROW END CATCH
BEGIN TRY BEGIN TRAN SELECT 1/0 AS CauseAnException; COMMIT END TRY BEGIN CATCH SELECT ERROR_MESSAGE(); THROW END CATCH
Semicolons are optional Semicolons are optional Semicolons are optional Semicolons are optional
DECLARE @Test varchar(35); SELECT @Test= (SELECT (SELECT (SELECT SELECT @Test Test;
Msg 102, Level 15, State 1, Line 5 Incorrect syntax near
DECLARE @Test varchar(35) SELECT @Test= (SELECT (SELECT (SELECT SELECT @Test Test
Test ----------------------------------- Semicolons do not always work fine. (1 row(s) affected)
;WITH Numbers AS ( SELECT n = 1 UNION ALL SELECT n + 1 FROM Numbers WHERE n+1 <= 10 ) SELECT n FROM Numbers
| SomeID | OtherID | Data +----------------+-------------+------------------- | abcdef-..... | cdef123-... | 18,20,22 | abcdef-..... | 4554a24-... | 17,19 | 987654-..... | 12324a2-... | 13,19,20
| OtherID | SplitData +-------------+------------------- | cdef123-... | 18 | cdef123-... | 20 | cdef123-... | 22 | 4554a24-... | 17 | 4554a24-... | 19
CREATE TABLE Testdata ( SomeID INT, OtherID INT, String VARCHAR(MAX) ) INSERT Testdata SELECT 1, 9, INSERT Testdata SELECT 2, 8, INSERT Testdata SELECT 3, 7, INSERT Testdata SELECT 4, 6, INSERT Testdata SELECT 9, 11,
;WITH tmp(SomeID, OtherID, DataItem, String) AS ( SELECT SomeID, OtherID, LEFT(String, CHARINDEX( STUFF(String, 1, CHARINDEX( FROM Testdata UNION all SELECT SomeID, OtherID, LEFT(String, CHARINDEX( STUFF(String, 1, CHARINDEX( FROM tmp WHERE String > ) SELECT SomeID, OtherID, DataItem FROM tmp ORDER BY SomeID -- OPTION (maxrecursion 0) -- normally recursion is limited to 100. If you know you have very long -- strings, uncomment the option
SomeID | OtherID | DataItem --------+---------+---------- 1 | 9 | 18 1 | 9 | 20 1 | 9 | 22 2 | 8 | 17 2 | 8 | 19 3 | 7 | 13 3 | 7 | 19 3 | 7 | 20 4 | 6 | 9 | 11 | 1 9 | 11 | 2 9 | 11 | 3 9 | 11 | 4
select OtherID, cs.Value --SplitData from yourtable cross apply STRING_SPLIT (Data,
CREATE FUNCTION [dbo].[DelimitedSplit8K] (@pString VARCHAR(8000), @pDelimiter CHAR(1)) RETURNS TABLE WITH SCHEMABINDING AS RETURN --===== "Inline" CTE Driven "Tally Table" produces values from 0 up to 10,000... -- enough to cover NVARCHAR(4000) WITH E1(N) AS ( SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 ), --10E+1 or 10 rows E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max cteTally(N) AS (--==== This provides the "base" CTE and limits the number of rows right up front -- for both a performance gain and prevention of accidental "overruns" SELECT TOP (ISNULL(DATALENGTH(@pString),0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4 ), cteStart(N1) AS (--==== This returns N+1 (starting position of each "element" just once for each delimiter) SELECT 1 UNION ALL SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@pString,t.N,1) = @pDelimiter ), cteLen(N1,L1) AS(--==== Return start and length (for use in substring) SELECT s.N1, ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,8000) FROM cteStart s ) --===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found. SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1), Item = SUBSTRING(@pString, l.N1, l.L1) FROM cteLen l ;
SELECT A.OtherID, Split.a.value( FROM ( SELECT OtherID, CAST ( FROM Table1 ) AS A CROSS APPLY Data.nodes (
select t.OtherID,x.Kod from testData t cross apply (select Code from dbo.Split(t.Data,
CREATE FUNCTION dbo.Split ( @Line nvarchar(MAX), @SplitOn nvarchar(5) = ) RETURNS @RtnValue table ( Id INT NOT NULL IDENTITY(1,1) PRIMARY KEY CLUSTERED, Data nvarchar(100) NOT NULL ) AS BEGIN IF @Line IS NULL RETURN DECLARE @split_on_len INT = LEN(@SplitOn) DECLARE @start_at INT = 1 DECLARE @end_at INT DECLARE @data_len INT WHILE 1=1 BEGIN SET @end_at = CHARINDEX(@SplitOn,@Line,@start_at) SET @data_len = CASE @end_at WHEN 0 THEN LEN(@Line) ELSE @end_at-@start_at END INSERT INTO @RtnValue (data) VALUES( SUBSTRING(@Line,@start_at,@data_len) ); IF @end_at = 0 BREAK; SET @start_at = @end_at + @split_on_len END RETURN END
create function dbo.splitString(@input Varchar(max), @Splitter VarChar(99)) returns table as Return SELECT Split.a.value( ( SELECT CAST ( ) AS A CROSS APPLY Data.nodes (
create function dbo.splitString(@input Varchar(max), @Splitter Varchar(99)) returns table as Return with tmp (DataItem, ix) as ( select @input , CHARINDEX( union all select Substring(@input, ix+1,ix2-ix-1), ix2 from (Select *, CHARINDEX(@Splitter,@Input+@Splitter,ix+1) ix2 from tmp) x where ix2<>0 ) select DataItem from tmp where ix<>0
Create table TEST_X (A int, CSV Varchar(100)); Insert into test_x select 1, Insert into test_x select 2, Select A,data from TEST_X x cross apply dbo.splitString(x.CSV, Drop table TEST_X
DECLARE @id_list VARCHAR(MAX) = DECLARE @table TABLE ( id VARCHAR(50) ) DECLARE @x INT = 0 DECLARE @firstcomma INT = 0 DECLARE @nextcomma INT = 0 SET @x = LEN(@id_list) - LEN(REPLACE(@id_list, WHILE @x > 0 BEGIN SET @nextcomma = CASE WHEN CHARINDEX( THEN LEN(@id_list) + 1 ELSE CHARINDEX( END INSERT INTO @table VALUES ( SUBSTRING(@id_list, @firstcomma + 1, (@nextcomma - @firstcomma) - 1) ) SET @firstcomma = CHARINDEX( SET @x = @x - 1 END SELECT * FROM @table
CREATE FUNCTION dbo.udf_ConvertTextToXML (@Text varchar(MAX)) RETURNS varchar(MAX) AS BEGIN SET @Text = REPLACE(@Text,CHAR(10), SET @Text = REPLACE(@Text,CHAR(13), SET @Text = REPLACE(@Text, SET @Text = REPLACE(@Text, SET @Text = REPLACE(@Text, SET @Text = REPLACE(@Text, SET @Text = REPLACE(@Text, RETURN @Text END CREATE FUNCTION dbo.udf_ConvertTextFromXML (@Text VARCHAR(MAX)) RETURNS VARCHAR(max) AS BEGIN SET @Text = REPLACE(@Text, SET @Text = REPLACE(@Text, SET @Text = REPLACE(@Text, SET @Text = REPLACE(@Text, SET @Text = REPLACE(@Text, RETURN @Text END
CREATE FUNCTION dbo.SplitToRows (@column varchar(100), @separator varchar(10)) RETURNS @rtnTable TABLE ( ID int identity(1,1), ColumnA varchar(max) ) AS BEGIN DECLARE @position int = 0 DECLARE @endAt int = 0 DECLARE @tempString varchar(100) set @column = ltrim(rtrim(@column)) WHILE @position<=len(@column) BEGIN set @endAt = CHARINDEX(@separator,@column,@position) if(@endAt=0) begin Insert into @rtnTable(ColumnA) Select substring(@column,@position,len(@column)-@position) break; end set @tempString = substring(ltrim(rtrim(@column)),@position,@endAt-@position) Insert into @rtnTable(ColumnA) select @tempString set @position=@endAt+1; END return END
DECLARE @column varchar(max)= DECLARE @separator varchar(10) = DECLARE @position int = 0 DECLARE @endAt int = 0 DECLARE @tempString varchar(100) set @column = ltrim(rtrim(@column)) WHILE @position<=len(@column) BEGIN set @endAt = CHARINDEX(@separator,@column,@position) if(@endAt=0) begin Select substring(@column,@position,len(@column)-@position) break; end set @tempString = substring(ltrim(rtrim(@column)),@position,@endAt-@position) select @tempString set @position=@endAt+1; END
;WITH tmp(SomeID, OtherID, DataItem, Data) as ( SELECT SomeID, OtherID, LEFT(Data, CHARINDEX( STUFF(Data, 1, CHARINDEX( FROM Testdata WHERE Data > ) SELECT SomeID, OtherID, Data FROM tmp ORDER BY SomeID
select *, ROW_NUMBER() OVER(order by items) as row from ( select 134 myColumn1, 34 myColumn2, cross apply SPLIT (rtrim(comaSeperatedColumn),
DECLARE @stringValue NVARCHAR(400) = DECLARE @separator CHAR = SELECT [value] As Colour FROM STRING_SPLIT(@stringValue, @separator);
SELECT ColumnID, Column1, value --Do not change FROM tbl_Sample CROSS APPLY STRING_SPLIT(Tags,
ColumnID| Column1 | Tags --------|-----------|------------- 1 | ABC | 10,11,12 2 | PQR | 20,21,22
ColumnID| Column1 | value --------|-----------|----------- 1 | ABC | 10 1 | ABC | 11 1 | ABC | 12 2 | PQR | 20 2 | PQR | 21 2 | PQR | 22
IF EXISTS(SELECT * FROM sysconstraints WHERE id=OBJECT_ID( AND COL_NAME(id,colid)= AND OBJECTPROPERTY(constid, ALTER TABLE SomeTable DROP CONSTRAINT DF_SomeTable_ColName
declare @schema_name nvarchar(256) declare @table_name nvarchar(256) declare @col_name nvarchar(256) declare @Command nvarchar(1000) set @schema_name = N set @table_name = N set @col_name = N select @Command = from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and t.schema_id = schema_id(@schema_name) and c.name = @col_name --print @Command execute (@Command)
declare @table_name nvarchar(256) declare @col_name nvarchar(256) set @table_name = N set @col_name = N select t.name, c.name, d.name, d.definition from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name = @col_name
DECLARE @ObjectName NVARCHAR(100) SELECT @ObjectName = OBJECT_NAME([default_object_id]) FROM SYS.COLUMNS WHERE [object_id] = OBJECT_ID( EXEC(
declare @table_name nvarchar(256) declare @Command nvarchar(max) = set @table_name = N select @Command = @Command + from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name in ( --print @Command execute (@Command)
-- Drop default contstraint for SchemaName.TableName.ColumnName DECLARE @schema_name NVARCHAR(256) DECLARE @table_name NVARCHAR(256) DECLARE @col_name NVARCHAR(256) DECLARE @Command NVARCHAR(1000) set @schema_name = N set @table_name = N set @col_name = N SELECT @Command = FROM sys.tables t JOIN sys.default_constraints d ON d.parent_object_id = t.object_id JOIN sys.schemas s ON s.schema_id = t.schema_id JOIN sys.columns c ON c.object_id = t.object_id AND c.column_id = d.parent_column_id WHERE t.name = @table_name AND s.name = @schema_name AND c.name = @col_name EXECUTE (@Command)
declare @table_name nvarchar(128) declare @column_name nvarchar(128) declare @df_name nvarchar(128) declare @cmd nvarchar(128) declare table_names cursor for SELECT t.name TableName, c.name ColumnName FROM sys.columns c INNER JOIN sys.tables t ON c.object_id = t.object_id INNER JOIN sys.schemas s ON t.schema_id = s.schema_id ORDER BY T.name, c.name open table_names fetch next from table_names into @table_name , @column_name while @@fetch_status = 0 BEGIN if exists (SELECT top(1) d.name from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name = @column_name) BEGIN SET @df_name = (SELECT top(1) d.name from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name = @column_name) select @cmd = print @cmd EXEC sp_executeSQL @cmd; END fetch next from table_names into @table_name , @column_name END close table_names deallocate table_names
Declare @Const NVARCHAR(256) SET @Const = ( SELECT TOP 1 FROM Sys.default_constraints A JOIN sysconstraints B on A.parent_object_id = B.id WHERE id = OBJECT_ID( AND COL_NAME(id, colid)= AND OBJECTPROPERTY(constid, ) EXEC (@Const)
CREATE PROCEDURE [dbo].[RemoveDefaultConstraints] @table_name nvarchar(256), @column_name nvarchar(256) AS BEGIN DECLARE @ObjectName NVARCHAR(100) START: --Start of loop SELECT @ObjectName = OBJECT_NAME([default_object_id]) FROM SYS.COLUMNS WHERE [object_id] = OBJECT_ID(@table_name) AND [name] = @column_name; -- Don IF @ObjectName IS NOT NULL BEGIN EXEC ( GOTO START; --Used to loop in case of multiple default constraints END END GO -- How to run the stored proc. This removes the default constraint(s) for the enabled column on the User table. EXEC [dbo].[RemoveDefaultConstraints] N GO -- If you hate the proc, just get rid of it DROP PROCEDURE [dbo].[RemoveDefaultConstraints] GO
declare @table_name nvarchar(128) declare @column_name nvarchar(128) declare @constraint_name nvarchar(128) declare @constraint_definition nvarchar(512) declare @df_name nvarchar(128) declare @cmd nvarchar(128) PRINT declare constraints cursor for select t.name TableName, c.name ColumnName, d.name ConstraintName, d.definition ConstraintDefinition from sys.tables t join sys.check_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = N open constraints fetch next from constraints into @table_name , @column_name, @constraint_name, @constraint_definition while @@fetch_status = 0 BEGIN print select @cmd = print @cmd EXEC sp_executeSQL @cmd; fetch next from constraints into @table_name , @column_name, @constraint_name, @constraint_definition END close constraints deallocate constraints
ALTER TABLE yourTableName DROP CONSTRAINT DF__YourTa__NewCo__47127295;
declare @ery nvarchar(max) declare @tab nvarchar(max) = declare @qu nvarchar(max) = select @ery = (select bj.name from sys.tables as tb inner join sys.objects as bj on tb.object_id = bj.parent_object_id where tb.name = @tab and bj.type = exec(@qu+@ery) **Take a look**
select from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where c.name in ( order by t.name
CREATE FUNCTION MyNS.GetUnshippedOrders() RETURNS TABLE AS RETURN SELECT a.SaleId, a.CustomerID, b.Qty FROM Sales.Sales a INNER JOIN Sales.SaleDetail b ON a.SaleId = b.SaleId INNER JOIN Production.Product c ON b.ProductID = c.ProductID WHERE a.ShipDate IS NULL GO
CREATE FUNCTION MyNS.GetLastShipped(@CustomerID INT) RETURNS @CustomerOrder TABLE (SaleOrderID INT NOT NULL, CustomerID INT NOT NULL, OrderDate DATETIME NOT NULL, OrderQty INT NOT NULL) AS BEGIN DECLARE @MaxDate DATETIME SELECT @MaxDate = MAX(OrderDate) FROM Sales.SalesOrderHeader WHERE CustomerID = @CustomerID INSERT @CustomerOrder SELECT a.SalesOrderID, a.CustomerID, a.OrderDate, b.OrderQty FROM Sales.SalesOrderHeader a INNER JOIN Sales.SalesOrderHeader b ON a.SalesOrderID = b.SalesOrderID INNER JOIN Production.Product c ON b.ProductID = c.ProductID WHERE a.OrderDate = @MaxDate AND a.CustomerID = @CustomerID RETURN END GO
CREATE FUNCTION MyNS.GetLastShipped() RETURNS @CustomerOrder TABLE ( SaleOrderID INT NOT NULL, CustomerID INT NOT NULL, OrderDate DATETIME NOT NULL, OrderQty INT NOT NULL ) AS BEGIN INSERT @CustomerOrder SELECT a.SalesOrderID, a.CustomerID, a.OrderDate, b.OrderQty FROM Sales.SalesOrderHeader a INNER JOIN Sales.SalesOrderHeader b ON a.SalesOrderID = b.SalesOrderID INNER JOIN Production.Product c ON b.ProductID = c.ProductID WHERE a.OrderDate = ( Select Max(SH1.OrderDate) FROM Sales.SalesOrderHeader As SH1 WHERE SH1.CustomerID = A.CustomerId ) RETURN END GO
SELECT a.*,b.* FROM AAAA a INNER JOIN MyNS.GetUnshippedOrders() b ON a.z=b.z
SELECT x.a,x.b,x.c,(SELECT OrderQty FROM MyNS.GetLastShipped(x.CustomerID)) AS Qty FROM xxxx x
select cast((123.456-(123.456%.001)) as decimal (18,2))
Select round(123.456, 2, 1) will = 123.45 Select round(123.456, 2, 0) will = 123.46
Convert 71.950005666 to a single decimal place number (71.9) 1) 71.950005666 * 10.0 = 719.50005666 2) Floor(719.50005666) = 719.0 3) 719.0 / 10.0 = 71.9 select Floor(71.950005666 * 10.0) / 10.0
declare @num decimal(9,5) = 123.456 select round(@num-.005,2)
declare @val decimal (8, 2) select @val = 123.456 select @val = @val select @val
declare @val decimal (8, 3) SET @val = 123.456 SELECT @val - ROUND(@val,0,1)
DECLARE @value DECIMAL(18,3) =123.456; SELECT @value AS val, {fn TRUNCATE(@value, 2)} AS result
╔═════════╦═════════╗ ║ val ║ result ║ ╠═════════╬═════════╣ ║ 123,456 ║ 123,450 ║ ╚═════════╩═════════╝
BEGIN TRANSACTION [Tran1] INSERT INTO [Test].[dbo].[T1] ([Title], [AVG]) VALUES ( UPDATE [Test].[dbo].[T1] SET [Title] = N WHERE [dbo].[T1].[Title] = N COMMIT TRANSACTION [Tran1] GO
BEGIN TRANSACTION [Tran1] BEGIN TRY INSERT INTO [Test].[dbo].[T1] ([Title], [AVG]) VALUES ( UPDATE [Test].[dbo].[T1] SET [Title] = N WHERE [dbo].[T1].[Title] = N COMMIT TRANSACTION [Tran1] END TRY BEGIN CATCH ROLLBACK TRANSACTION [Tran1] END CATCH
CREATE TABLE T ( C [nvarchar](100) NOT NULL UNIQUE, ); SET XACT_ABORT ON -- Turns on rollback if T-SQL statement raises a run-time error. SELECT * FROM T; -- Check before. BEGIN TRAN INSERT INTO T VALUES ( INSERT INTO T VALUES ( INSERT INTO T VALUES ( INSERT INTO T VALUES ( COMMIT TRAN SELECT * FROM T; -- Check after. DELETE T;
alter table company add CountryID varchar(3); alter table company add constraint Company_CountryID_FK foreign key(CountryID) references Country;
alter table company drop foreign key Company_CountryID_FK; alter table company drop column CountryID;
alter table company drop constraint Company_CountryID_FK alter table company drop column CountryID
ALTER TABLE [dbo].[company] DROP CONSTRAINT [Company_CountryID_FK]
DECLARE @ConstraintName nvarchar(200) SELECT @ConstraintName = KCU.CONSTRAINT_NAME FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU ON KCU.CONSTRAINT_CATALOG = RC.CONSTRAINT_CATALOG AND KCU.CONSTRAINT_SCHEMA = RC.CONSTRAINT_SCHEMA AND KCU.CONSTRAINT_NAME = RC.CONSTRAINT_NAME WHERE KCU.TABLE_NAME = KCU.COLUMN_NAME = IF @ConstraintName IS NOT NULL EXEC(
if exists (select 1 from sys.objects where name = begin alter table company drop constraint Company_CountryID_FK end
alter table company drop constraint Company_CountryID_FK
alter table company drop **constraint** Company_CountryID_FK;
alter table company drop constraint Company_CountryID_FK
ALTER DATABASE failed because a lock could not be placed on database ALTER DATABASE statement failed. Cannot drop database "MyDB" because it is currently in use.
ALTER DATABASE MyDB SET RESTRICTED_USER WITH ROLLBACK IMMEDIATE
USE [master]; DECLARE @kill varchar(8000) = SELECT @kill = @kill + FROM sys.dm_exec_sessions WHERE database_id = db_id( EXEC(@kill);
USE master; DECLARE @kill varchar(8000); SET @kill = SELECT @kill = @kill + FROM master..sysprocesses WHERE dbid = db_id( EXEC(@kill);
USE master GO ALTER DATABASE database_name SET OFFLINE WITH ROLLBACK IMMEDIATE GO
USE [master] GO ALTER DATABASE [YourDatabaseName] SET SINGLE_USER WITH ROLLBACK IMMEDIATE GO USE [master] GO DROP DATABASE [YourDatabaseName] GO
USE [master]; GO DECLARE @Kill VARCHAR(8000) = SELECT @Kill = @Kill + FROM sys.dm_exec_sessions WHERE database_id = DB_ID( EXEC sys.sp_executesql @Kill;
USE [master]; GO DECLARE @DatabaseID SMALLINT = DB_ID(N DECLARE @SQL NVARCHAR(10); WHILE EXISTS ( SELECT 1 FROM sys.dm_exec_sessions WHERE database_id = @DatabaseID ) BEGIN; SET @SQL = ( SELECT TOP 1 N FROM sys.dm_exec_sessions WHERE database_id = @DatabaseID ); EXEC sys.sp_executesql @SQL; END;
USE master; GO DECLARE @kill varchar(max) = SELECT @kill = @kill + EXEC (@kill)
DECLARE @kill varchar(8000); set @kill = select @kill = @kill + where login_name = and datediff(hh,login_time,getdate()) > 1 --and session_id in (311,266) exec(@kill)
USE master GO DECLARE @SQL AS VARCHAR(255) DECLARE @SPID AS SMALLINT DECLARE @Database AS VARCHAR(500) SET @Database = DECLARE Murderer CURSOR FOR SELECT spid FROM sys.sysprocesses WHERE DB_NAME(dbid) = @Database OPEN Murderer FETCH NEXT FROM Murderer INTO @SPID WHILE @@FETCH_STATUS = 0 BEGIN SET @SQL = EXEC (@SQL) PRINT FETCH NEXT FROM Murderer INTO @SPID END CLOSE Murderer DEALLOCATE Murderer
SELECT spid, sp.[status], loginame [Login], hostname, blocked BlkBy, sd.name DBName, cmd Command, cpu CPUTime, memusage Memory, physical_io DiskIO, lastwaittype LastWaitType, [program_name] ProgramName, last_batch LastBatch, login_time LoginTime, FROM master.dbo.sysprocesses sp JOIN master.dbo.sysdatabases sd ON sp.dbid = sd.dbid WHERE sd.name NOT IN ( --AND sd.name = --AND hostname like --AND loginame like ORDER BY spid /* If a service connects continously. You can automatically execute kill process then run your script: DECLARE @sqlcommand nvarchar (500) SELECT @sqlcommand = FROM master.dbo.sysprocesses sp JOIN master.dbo.sysdatabases sd ON sp.dbid = sd.dbid WHERE sd.name NOT IN ( --AND sd.name = --AND hostname like --AND loginame like --SELECT @sqlcommand EXEC sp_executesql @sqlcommand */
USE [master] GO ALTER DATABASE [YourDatabaseName] SET SINGLE_USER WITH ROLLBACK IMMEDIATE GO
CREATE PROCEDURE spDoSearch @FirstName varchar(25) = null, @LastName varchar(25) = null, @Title varchar(25) = null AS BEGIN SELECT ID, FirstName, LastName, Title FROM tblUsers WHERE FirstName = ISNULL(@FirstName, FirstName) AND LastName = ISNULL(@LastName, LastName) AND Title = ISNULL(@Title, Title) END
CREATE PROCEDURE spDoSearch @FirstName varchar(25) = null, @LastName varchar(25) = null, @Title varchar(25) = null AS BEGIN SELECT ID, FirstName, LastName, Title FROM tblUsers WHERE (@FirstName IS NULL OR (FirstName = @FirstName)) AND (@LastName IS NULL OR (LastName = @LastName )) AND (@Title IS NULL OR (Title = @Title )) OPTION (RECOMPILE) ---<<<<use if on for SQL 2008 SP1 CU5 (10.0.2746) and later END
CREATE PROCEDURE spDoSearch @FirstName varchar(25) = null, @LastName varchar(25) = null, @Title varchar(25) = null AS BEGIN IF (@FirstName IS NOT NULL AND @LastName IS NULL AND @Title IS NULL) -- Search by first name only SELECT ID, FirstName, LastName, Title FROM tblUsers WHERE FirstName = @FirstName ELSE IF (@FirstName IS NULL AND @LastName IS NOT NULL AND @Title IS NULL) -- Search by last name only SELECT ID, FirstName, LastName, Title FROM tblUsers WHERE LastName = @LastName ELSE IF (@FirstName IS NULL AND @LastName IS NULL AND @Title IS NOT NULL) -- Search by title only SELECT ID, FirstName, LastName, Title FROM tblUsers WHERE Title = @Title ELSE IF (@FirstName IS NOT NULL AND @LastName IS NOT NULL AND @Title IS NULL) -- Search by first and last name SELECT ID, FirstName, LastName, Title FROM tblUsers WHERE FirstName = @FirstName AND LastName = @LastName ELSE -- Search by any other combination SELECT ID, FirstName, LastName, Title FROM tblUsers WHERE (@FirstName IS NULL OR (FirstName = @FirstName)) AND (@LastName IS NULL OR (LastName = @LastName )) AND (@Title IS NULL OR (Title = @Title )) END
CREATE PROCEDURE spDoSearch @FirstName varchar(25) = null, @LastName varchar(25) = null, @Title varchar(25) = null AS BEGIN SELECT ID, FirstName, LastName, Title FROM tblUsers WHERE (@FirstName IS NULL OR FirstName = @FirstName) AND (@LastNameName IS NULL OR LastName = @LastName) AND (@Title IS NULL OR Title = @Title) END
WHERE (FirstName = ISNULL(@FirstName, FirstName) OR COALESCE(@FirstName, FirstName, AND (LastName = ISNULL(@LastName, LastName) OR COALESCE(@LastName, LastName, AND (Title = ISNULL(@Title, Title) OR COALESCE(@Title, Title,
-- drop table Person create table Person ( PersonId INT NOT NULL IDENTITY(1, 1) CONSTRAINT PK_Person PRIMARY KEY, FirstName NVARCHAR(64) NOT NULL, LastName NVARCHAR(64) NOT NULL, Title NVARCHAR(64) NULL ) GO INSERT INTO Person (FirstName, LastName, Title) VALUES ( ( ( ( ( GO
ALTER PROCEDURE spDoSearch @FirstName varchar(64) = null, @LastName varchar(64) = null, @Title varchar(64) = null, @TopCount INT = 100 AS BEGIN DECLARE @SQL NVARCHAR(4000) = ' SELECT TOP FROM Person WHERE 1 = 1' PRINT @SQL IF (@FirstName IS NOT NULL) SET @SQL = @SQL + IF (@LastName IS NOT NULL) SET @SQL = @SQL + IF (@Title IS NOT NULL) SET @SQL = @SQL + EXEC sp_executesql @SQL, N @TopCount, @FirstName, @LastName, @Title END GO
exec spDoSearch @TopCount = 3 exec spDoSearch @FirstName =
public IList<SomeServiceModel> GetServiceModels(CustomFilter filters) { var query = DataAccess.SomeRepository.AllNoTracking; if (!string.IsNullOrWhiteSpace(filters.SomeName)) query = query.Where(item => item.SomeName.IndexOf(filters.SomeName, StringComparison.OrdinalIgnoreCase) != -1); if ((filters.CreatedByList?.Count ?? 0) > 0) query = query.Where(item => filters.CreatedByList.Contains(item.CreatedById)); if (filters.EnabledOnly) query = query.Where(item => item.IsEnabled); var modelList = query.ToList(); var serviceModelList = MappingService.MapEx<SomeDataModel, SomeServiceModel>(modelList); return serviceModelList; }
... WHERE (FirstName IS NULL OR FirstName = ISNULL(@FirstName, FirstName)) AND (LastName IS NULL OR LastName = ISNULL(@LastName, LastName)) AND (Title IS NULL OR Title = ISNULL(@Title, Title))
GROUP BY DATEADD(day, DATEDIFF(day, 0, MyDateTimeColumn), 0)
select count(convert(CHAR(10), dtcreatedate, 103) ),convert(char(10), dtcreatedate, 103) FROM dbo.tbltobecounted GROUP BY CONVERT(CHAR(10),dtcreatedate,103) ORDER BY CONVERT(CHAR(10),dtcreatedate,103)
WHERE IF IsNumeric(@OrderNumber) = 1 OrderNumber = @OrderNumber ELSE OrderNumber LIKE
WHERE OrderNumber LIKE CASE WHEN IsNumeric(@OrderNumber) = 1 THEN @OrderNumber ELSE END
WHERE (IsNumeric(@OrderNumber) AND (CAST OrderNumber AS VARCHAR) = (CAST @OrderNumber AS VARCHAR) OR (NOT IsNumeric(@OrderNumber) AND OrderNumber LIKE (
WHERE (IsNumeric(@OrderNumber) = 1 AND OrderNumber = @OrderNumber) OR (IsNumeric(@OrderNumber) = 0 AND OrderNumber LIKE
WHERE OrderNumber = CASE WHEN (IsNumeric(@OrderNumber) = 1) THEN CONVERT(INT, @OrderNumber) ELSE -9999 -- Some numeric value that just cannot exist in the column END OR FirstName LIKE CASE WHEN (IsNumeric(@OrderNumber) = 0) THEN ELSE END
IF (IsNumeric(@OrderNumber)) = 1 BEGIN SELECT * FROM Table WHERE @OrderNumber = OrderNumber END ELSE BEGIN SELECT * FROM Table WHERE OrderNumber LIKE END
WHERE OrderNumber LIKE CASE WHEN IsNumeric(@OrderNumber)=1 THEN @OrderNumber ELSE
CREATE PROCEDURE sp_Case @bool bit AS SELECT Person.Hobbies FROM Person WHERE Person.ID = case @bool when 0 then 30 when 1 then 42 end;
USE AdventureWorks2012; GO DECLARE @AvgWeight decimal(8,2), @BikeCount int IF (SELECT COUNT(*) FROM Production.Product WHERE Name LIKE BEGIN SET @BikeCount = (SELECT COUNT(*) FROM Production.Product WHERE Name LIKE SET @AvgWeight = (SELECT AVG(Weight) FROM Production.Product WHERE Name LIKE PRINT PRINT END ELSE BEGIN SET @AvgWeight = (SELECT AVG(Weight) FROM Production.Product WHERE Name LIKE PRINT END ; GO
DECLARE @Number int SET @Number = 50 IF @Number > 100 PRINT ELSE BEGIN IF @Number < 10 PRINT ELSE PRINT END ; GO
If @LstTransDt is Null begin Set @OpenQty=0 end else begin Select @OpenQty=IsNull(Sum(ClosingQty),0) From ProductAndDepotWiseMonitoring Where Pcd=@PCd And PtpCd=@PTpCd And TransDt=@LstTransDt end
USE AdventureWorks2012; GO IF (SELECT COUNT(*) FROM Production.Product WHERE Name LIKE PRINT ELSE PRINT GO
Alter table TableName alter column dbo.TableName.Date default getutcdate()
alter table TableName add constraint df_ConstraintNAme default getutcdate() for [Date]
create table bla (id int) alter table bla add constraint dt_bla default 1 for id insert bla default values select * from bla
-- Update default to be a date. exec [dbo].[AlterDefaultForColumn] -- Update default to be a number. exec [dbo].[AlterDefaultForColumn] -- Update default to be a string. Note extra quotes, as this is not a function. exec [dbo].[AlterDefaultForColumn]
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO -- Sample function calls: --exec [dbo].[AlterDefaultForColumn] --exec [dbol].[AlterDefaultForColumn] --exec [dbo].[AlterDefaultForColumn] create PROCEDURE [dbo].[ColumnDefaultUpdate] ( -- Table name, including schema, e.g. @TABLE_NAME VARCHAR(100), -- Column name, e.g. @COLUMN_NAME VARCHAR(100), -- New default, e.g. -- Note that if you want to set it to a string constant, the contents -- must be surrounded by extra quotes, e.g. @NEW_DEFAULT VARCHAR(100) ) AS BEGIN -- Trim angle brackets so things work even if they are included. set @COLUMN_NAME = REPLACE(@COLUMN_NAME, set @COLUMN_NAME = REPLACE(@COLUMN_NAME, print print DECLARE @ObjectName NVARCHAR(100) SELECT @ObjectName = OBJECT_NAME([default_object_id]) FROM SYS.COLUMNS WHERE [object_id] = OBJECT_ID(@TABLE_NAME) AND [name] = @COLUMN_NAME; IF @ObjectName <> begin print --print( EXEC( end EXEC( --print( print END
-- Using the stored procedure eliminates this error: Msg 1781, Level 16, State 1, Line 1 Column already has a DEFAULT bound to it. Msg 1750, Level 16, State 0, Line 1 Could not create constraint. See previous errors.
drop table ABC_table create table ABC_table ( names varchar(20), age int ) ALTER TABLE ABC_table ADD CONSTRAINT MyConstraintName DEFAULT insert into ABC(age) values(10) select * from ABC
SELECT CAST( CASE WHEN EXISTS(SELECT * FROM theTable where theColumn like ELSE 0 END AS BIT)
SELECT CASE WHEN EXISTS( SELECT 1 FROM theTable WHERE theColumn LIKE THEN 1 ELSE 0 END
SELECT CAST(COUNT(*) AS bit) FROM MyTable WHERE theColumn like
SELECT TOP 1 CAST(NumberKeyCOlumn AS bit) FROM MyTable WHERE theColumn like
declare @t table (name nvarchar(16)) declare @b bit insert @t select N select @b = isnull((select top 1 1 from @t where name = N select @b whenTrue select @b = isnull((select top 1 1 from @t where name = N select @b whenFalse
SELECT CAST(IIF(EXISTS(SELECT * FROM theTable where theColumn like
SELECT DISTINCT 1 FROM theTable WHERE theColumn LIKE
SELECT IIF(EXISTS(SELECT * FROM theTable WHERE theColumn LIKE
SELECT ISNULL((SELECT TOP 1 1 FROM theTable where theColumn like
create table table1 (col1 int null) go select go insert into table1 (col1) values (1) go select go insert into table1 (col1) values (2) go select go insert into table1 (col1) values (3) go drop table table1 go
Use <database> SELECT execquery.last_execution_time AS [Date Time], execsql.text AS [Script] FROM sys.dm_exec_query_stats AS execquery CROSS APPLY sys.dm_exec_sql_text(execquery.sql_handle) AS execsql ORDER BY execquery.last_execution_time DESC
C:\Documents and Settings\YourUsername\My Documents\SQL Server Management Studio\Backup Files\
C:\Users\YourUsername\Documents\SQL Server Management Studio\Backup Files
C:\Users\<YourUserName>\Documents\SQL Server Management Studio\Backup Files\Solution1
C:\Users\YourUsername\Documents\SQL Server Management Studio\Backup Files
C:\Windows\System32\SQL Server Management Studio\Backup Files\Solution1
C:\Users\<yourusername>\Documents\SQL Server Management Studio\Backup Files\Solution1
select CHARINDEX( ----------- 8 (1 row(s) affected)
select CHARINDEX( ----------- 3 (1 row(s) affected)
date category amount 1/1/2012 ABC 1000.00 2/1/2012 DEF 500.00 2/1/2012 GHI 800.00 2/10/2012 DEF 700.00 3/1/2012 ABC 1100.00
date ABC DEF GHI 1/1/2012 1000.00 2/1/2012 500.00 2/1/2012 800.00 2/10/2012 700.00 3/1/2012 1100.00
create table temp ( date datetime, category varchar(3), amount money ) insert into temp values ( insert into temp values ( insert into temp values ( insert into temp values ( insert into temp values ( DECLARE @cols AS NVARCHAR(MAX), @query AS NVARCHAR(MAX); SET @cols = STUFF((SELECT distinct FROM temp c FOR XML PATH( ).value( ,1,1, set @query = ( select date , amount , category from temp ) x pivot ( max(amount) for category in ( ) p ' execute(@query) drop table temp
Date ABC DEF GHI 2012-01-01 00:00:00.000 1000.00 NULL NULL 2012-02-01 00:00:00.000 NULL 500.00 800.00 2012-02-10 00:00:00.000 NULL 700.00 NULL 2012-03-01 00:00:00.000 1100.00 NULL NULL
create table ( date datetime, category varchar(3), amount money ) insert into insert into insert into insert into insert into DECLARE @cols AS NVARCHAR(MAX)= DECLARE @query AS NVARCHAR(MAX)= SELECT @cols = @cols + QUOTENAME(category) + select @cols = substring(@cols, 0, len(@cols)) --trim "," at end set @query = ( select date, amount, category from ) src pivot ( max(amount) for category in ( ) piv' execute(@query) drop table
date ABC DEF GHI 2012-01-01 00:00:00.000 1000.00 NULL NULL 2012-02-01 00:00:00.000 NULL 500.00 800.00 2012-02-10 00:00:00.000 NULL 700.00 NULL 2012-03-01 00:00:00.000 1100.00 NULL NULL
create PROCEDURE [dbo].[USP_DYNAMIC_PIVOT] ( @STATIC_COLUMN VARCHAR(255), @PIVOT_COLUMN VARCHAR(255), @VALUE_COLUMN VARCHAR(255), @TABLE VARCHAR(255), @AGGREGATE VARCHAR(20) = null ) AS BEGIN SET NOCOUNT ON; declare @AVAIABLE_TO_PIVOT NVARCHAR(MAX), @SQLSTRING NVARCHAR(MAX), @PIVOT_SQL_STRING NVARCHAR(MAX), @TEMPVARCOLUMNS NVARCHAR(MAX), @TABLESQL NVARCHAR(MAX) if isnull(@AGGREGATE, begin SET @AGGREGATE = end SET @PIVOT_SQL_STRING = FROM WHERE ISNULL( FOR XML PATH( .value( from ORDER BY declare @TAB AS TABLE(COL NVARCHAR(MAX) ) INSERT INTO @TAB EXEC SP_EXECUTESQL @PIVOT_SQL_STRING, @AVAIABLE_TO_PIVOT SET @AVAIABLE_TO_PIVOT = (SELECT * FROM @TAB) SET @TEMPVARCOLUMNS = (SELECT replace(@AVAIABLE_TO_PIVOT, SET @SQLSTRING = INSERT INTO @RETURN_TABLE( select * from ( SELECT PIVOT ( FOR ) piv SELECT * FROM @RETURN_TABLE' EXEC SP_EXECUTESQL @SQLSTRING END
create table temp ( date datetime, category varchar(3), amount money ) insert into temp values ( insert into temp values ( insert into temp values ( insert into temp values ( insert into temp values ( insert into temp values ( insert into temp values ( insert into temp values (
exec [dbo].[USP_DYNAMIC_PIVOT] exec [dbo].[USP_DYNAMIC_PIVOT] exec [dbo].[USP_DYNAMIC_PIVOT] exec [dbo].[USP_DYNAMIC_PIVOT]
DECLARE @cols AS NVARCHAR(MAX), @maxcols AS NVARCHAR(MAX), @query AS NVARCHAR(MAX) select @cols = STUFF((SELECT from PO_FormasPago order by CodigoFormaPago FOR XML PATH( ).value( ,1,1, select @maxcols = STUFF((SELECT from PO_FormasPago order by CodigoFormaPago FOR XML PATH( ).value( ,1,1, set @query = FROM ( SELECT CodigoProducto, DenominacionProducto, ( SELECT p.CodigoProducto as CodigoProducto, p.DenominacionProducto as DenominacionProducto, fpp.CantidadCuotas as CantidadCuotas, fpp.IdFormaPago as IdFormaPago, fp.CodigoFormaPago as CodigoFormaPago FROM PR_Producto p LEFT JOIN PR_FormasPagoProducto fpp ON fpp.IdProducto = p.IdProducto LEFT JOIN PO_FormasPago fp ON fpp.IdFormaPago = fp.IdFormaPago ) xp pivot ( MAX(CantidadCuotas) for CodigoFormaPago in ( ) p ) xx GROUP BY CodigoProducto, DenominacionProducto' t @query; execute(@query);
create table test_table ( date nvarchar(10), category char(3), amount money ) insert into test_table values ( insert into test_table values ( insert into test_table values ( insert into test_table values ( insert into test_table values (
DECLARE @DynamicPivotQuery AS NVARCHAR(MAX), @PivotColumnNames AS NVARCHAR(MAX), @PivotSelectColumnNames AS NVARCHAR(MAX) --Get distinct values of the PIVOT Column SELECT @PivotColumnNames= ISNULL(@PivotColumnNames + + QUOTENAME(category) FROM (SELECT DISTINCT category FROM test_table) AS cat --Get distinct values of the PIVOT Column with isnull SELECT @PivotSelectColumnNames = ISNULL(@PivotSelectColumnNames + + + QUOTENAME(category) FROM (SELECT DISTINCT category FROM test_table) AS cat --Prepare the PIVOT query using the dynamic SET @DynamicPivotQuery = N FROM test_table pivot(sum(amount) for category in ( --Execute the Dynamic Pivot Query EXEC sp_executesql @DynamicPivotQuery
select t.range as [score range], count(*) as [number of occurences] from ( select case when score between 0 and 9 then when score between 10 and 19 then else from scores) t group by t.range
select t.range as [score range], count(*) as [number of occurences] from ( select user_id, case when score >= 0 and score< 10 then when score >= 10 and score< 20 then else from scores) t group by t.range
Select Range as [Score Range], Count(*) as [Number of Occurences] from Ranges r inner join Scores s on s.Score between r.LowerLimit and r.UpperLimit group by Range
select t.range as [score range], count(*) as [number of occurences] from ( select case when score between 0 and 9 then when score between 10 and 19 then when score between 20 and 29 then ... else from scores) t group by t.range
select (score/10)*10 || from scores group by score/10 order by 1
scorerange | count ------------+------- 0-9 | 11 10-19 | 14 20-29 | 3 30-39 | 2
SELECT [score range] = CAST((Score/10)*10 AS VARCHAR) + [number of occurrences] = COUNT(*) FROM GROUP BY Score/10 ORDER BY Score/10
create table scores ( user_id int, score int ) select t.range as [score range], count(*) as [number of occurences] from ( select user_id, case when score >= 0 and score < 10 then case when score >= 10 and score < 20 then ... else from scores) t group by t.range
select cast(score/10 as varchar) + count(*) from scores group by score/10
SELECT CONCAT(range, FROM ( SELECT score - (score % 10) as range FROM scores )
select t.range as [score range], count(*) as [number of occurences] from ( select FLOOR(score/10) as range from scores) t group by t.range
declare @RangeWidth int set @RangeWidth = 10 select Floor(Score/@RangeWidth) as LowerBound, Floor(Score/@RangeWidth)+@RangeWidth as UpperBound, Count(*) From ScoreTable group by Floor(Score/@RangeWidth)
select t.blah as [score range], count(*) as [number of occurences] from ( select case when score between 0 and 9 then when score between 10 and 19 then when score between 20 and 29 then ... else from scores) t group by t.blah
SELECT t.range AS ScoreRange, COUNT(*) AS NumberOfOccurrences FROM (SELECT CASE WHEN score BETWEEN 0 AND 9 THEN WHEN score BETWEEN 10 AND 19 THEN ELSE END AS Range FROM Scores) t GROUP BY t.Range
SELECT t.range AS ScoreRange, COUNT(*) AS NumberOfOccurrences FROM (SELECT CASE WHEN score BETWEEN 0 AND 9 THEN WHEN score BETWEEN 10 AND 19 THEN WHEN score BETWEEN 20 AND 99 THEN ELSE END AS Range FROM Scores) t GROUP BY t.Range
SELECT (str(range) + "-" + str(range + 9) ) AS [Score range], COUNT(score) AS [number of occurances] FROM (SELECT score, int(score / 10 ) * 10 AS range FROM scoredata ) GROUP BY range;
UPDATE Table1, Table2 SET Table1.LastName= Table2.WAprrs= FROM Table1 T1, Table2 T2 WHERE T1.id = T2.id AND T1.id =
BEGIN TRANSACTION; UPDATE Table1 SET Table1.LastName = FROM Table1 T1, Table2 T2 WHERE T1.id = T2.id and T1.id = UPDATE Table2 SET Table2.WAprrs = FROM Table1 T1, Table2 T2 WHERE T1.id = T2.id and T1.id = COMMIT;
DECLARE @ids TABLE (id int); BEGIN TRANSACTION UPDATE Table1 SET Table1.LastName = OUTPUT INSERTED.id INTO @ids WHERE T1.field = UPDATE Table2 SET Table2.WAprrs = FROM Table2 JOIN @ids i on i.id = Table2.id; COMMIT;
UPDATE Table1 t1, Table2 t2 SET t2.field = t2.field+2, t1.field = t1.field+2 WHERE t1.id = t2.foreign_id and t2.id =
UPDATE Table1 T1 join Table2 T2 on T1.id = T2.id SET T1.LastName= T2.WAprrs= WHERE T1.id =
DECLARE @TEMPTABLE TABLE ( [ID] [int] NOT NULL PRIMARY KEY ,[Name] [nvarchar] (255) COLLATE DATABASE_DEFAULT NULL )
DECLARE @T TABLE ( C1 INT INDEX IX1 CLUSTERED, C2 INT INDEX IX2 NONCLUSTERED, INDEX IX3 NONCLUSTERED(C1,C2) );
DECLARE @T TABLE ( c1 INT NULL INDEX ix UNIQUE WHERE c1 IS NOT NULL )
DECLARE @TEMPTABLE TABLE ( [ID] [INT] NOT NULL PRIMARY KEY, [Name] [NVARCHAR] (255) COLLATE DATABASE_DEFAULT NULL, UNIQUE NONCLUSTERED ([Name], [ID]) )
DECLARE @T TABLE ( A INT NULL UNIQUE CLUSTERED, B INT NOT NULL PRIMARY KEY NONCLUSTERED )
+-------------------------------------+-------------------------------------+ | Index Type | Can be created on a table variable? | +-------------------------------------+-------------------------------------+ | Unique Clustered Index | Yes | | Nonunique Clustered Index | | | Unique NCI on a heap | Yes | | Non Unique NCI on a heap | | | Unique NCI on a clustered index | Yes | | Non Unique NCI on a clustered index | Yes | +-------------------------------------+-------------------------------------+
DECLARE @T TABLE ( A INT NULL, B INT NULL, C INT NULL, Uniqueifier INT NOT NULL IDENTITY(1,1), UNIQUE CLUSTERED (A,Uniqueifier) )
ALTER TABLE Test NOCHECK CONSTRAINT ALL set identity_insert ID ON
CREATE TABLE Test ( ID INT IDENTITY(1,1) PRIMARY KEY, X VARCHAR(10) ) INSERT INTO Test OUTPUT INSERTED.* SELECT SELECT SELECT
CREATE TABLE Temp ( ID INT PRIMARY KEY, X VARCHAR(10) ) ALTER TABLE Test SWITCH TO Temp; UPDATE Temp SET ID = ID + 1; ALTER TABLE Temp SWITCH TO Test; SELECT * FROM Test IF NOT EXISTS(SELECT * FROM Temp) DROP TABLE Temp
CREATE SEQUENCE Seq AS INT START WITH 1 INCREMENT BY 1 CREATE TABLE Test2 ( ID INT DEFAULT NEXT VALUE FOR Seq NOT NULL PRIMARY KEY, X VARCHAR(10) ) INSERT INTO Test2(X) SELECT SELECT SELECT UPDATE Test2 SET ID+=1
alter table test nocheck constraint all; alter table foreign_table1 nocheck constraint all; alter table foreign_table2 nocheck constraint all; set identity_insert test on; select id + 1 as id, column2, column3 into test_copy from test v; delete from test; insert into test(id, column2, column3) select id, column2, column3 from test_copy alter table test check constraint all; alter table foreign_table1 check constraint all; alter table foreign_table2 check constraint all; set identity_insert test off; drop table test_copy;
SET IDENTITY_INSERT [PersonApiLogin] ON INSERT INTO [PersonApiLogin]( [Id] ,[PersonId] ,[ApiId] ,[Hash] ,[Password] ,[SoftwareKey] ,[LoggedIn] ,[LastAccess]) SELECT [PersonId] ,[PersonId] ,[ApiId] ,[Hash] ,[Password] ,[SoftwareKey] ,[LoggedIn] ,[LastAccess] FROM [db304].[dbo].[PersonApiLogin] GO DELETE FROM [PersonApiLogin] WHERE [PersonId] <> ID GO SET IDENTITY_INSERT [PersonApiLogin] OFF GO
use [Name.Database] go set identity_insert [Test] ON insert into [dbo].[Test] ([Id]) VALUES (2) set identity_insert [Test] OFF
use [Name.Database] go set identity_insert [Test] ON BULK INSERT [Test] FROM WITH (FIELDTERMINATOR = ROWTERMINATOR = KEEPIDENTITY) set identity_insert [Test] OFF
SET IDENTITY_INSERT Emp_tb_gb_Menu ON INSERT Emp_tb_gb_Menu(MenuID) VALUES (68) SET IDENTITY_INSERT Emp_tb_gb_Menu OFF
DECLARE @retval int DECLARE @sSQL nvarchar(500); DECLARE @ParmDefinition nvarchar(500); DECLARE @tablename nvarchar(50) SELECT @tablename = N SELECT @sSQL = N SET @ParmDefinition = N EXEC sp_executesql @sSQL, @ParmDefinition, @retvalOUT=@retval OUTPUT; SELECT @retval;
-- Assuming that your SP return 1 value create table insert into select * from
DECLARE @tab AS TABLE (col VARCHAR(10), colu2 varchar(10)) INSERT into @tab EXECUTE sp_executesql N SELECT * FROM @tab
DECLARE @vi INT DECLARE @vQuery VARCHAR(1000) SET @vQuery = EXEC SP_EXECUTESQL @Query = @vQuery , @Params = N , @vi = @vi OUTPUT SELECT @vi
DECLARE @s NVARCHAR(500) DECLARE @i INT; SET @s = EXEC @i = sys.sp_executesql @s SELECT @i AS
DECLARE @sqlstatement2 NVARCHAR(MAX); DECLARE @retText NVARCHAR(MAX); DECLARE @ParmDefinition NVARCHAR(MAX); DECLARE @retIndex INT = 0; SELECT @sqlstatement = SET @ParmDefinition = N exec sp_executesql @sqlstatement, @ParmDefinition, @retIndexOUT=@retIndex OUTPUT, @retTextOUT=@retText OUTPUT;
SELECT @sql = N INSERT INTO @ValueTable EXEC sp_executesql @sql; SET @Value= SET @Value = (SELECT TOP 1 Value FROM @ValueTable) DELETE FROM @ValueTable
DECLARE @SQL NVARCHAR(4000) DECLARE @tbl Table ( Id int, Account varchar(50), Amount int ) -- Lots of code to Create my dynamic sql statement insert into @tbl EXEC sp_executesql @SQL select * from @tbl
DECLARE @BadData TABLE ( ThisID int , ThatID int ); INSERT INTO @BadData ( ThisID , ThatID ) VALUES ( 1, 1 ), ( 1, 2 ), ( 2, 2 ), ( 1, 1 ); IF OBJECT_ID( DROP TABLE CREATE TABLE ThisID int NOT NULL , ThatID int NOT NULL UNIQUE(ThisID, ThatID) ); INSERT INTO SELECT * FROM @BadData; WITH This_CTE AS (SELECT * FROM @BadData) SELECT * FROM This_CTE;
SELECT COUNT(*) FROM (SELECT DISTINCT DocumentId, DocumentSessionId FROM DocumentOutputItems) AS internalQuery
SELECT COUNT(DISTINCT (CHECKSUM(DocumentId,DocumentSessionId)) + CHECKSUM(REVERSE(DocumentId),REVERSE(DocumentSessionId)) ) FROM DocumentOutPutItems
SQL> select distinct deptno, job from emp 2 order by deptno, job 3 / DEPTNO JOB ---------- --------- 10 CLERK 10 MANAGER 10 PRESIDENT 20 ANALYST 20 CLERK 20 MANAGER 30 CLERK 30 MANAGER 30 SALESMAN 9 rows selected. SQL> select count(*) from ( 2 select distinct deptno, job from emp 3 ) 4 / COUNT(*) ---------- 9 SQL>
SQL> select count(distinct concat(deptno,job)) from emp 2 / COUNT(DISTINCTCONCAT(DEPTNO,JOB)) --------------------------------- 9 SQL>
SELECT count(DISTINCT concat(DocumentId, DocumentSessionId)) FROM DocumentOutputItems;
SELECT count(DISTINCT DocumentId, DocumentSessionId) FROM DocumentOutputItems;
SELECT COUNT(DISTINCT DocumentId, DocumentSessionId) FROM DocumentOutputItems
WITH internalQuery (Amount) AS ( SELECT (0) FROM DocumentOutputItems GROUP BY DocumentId, DocumentSessionId ) SELECT COUNT(*) AS NumberOfDistinctRows FROM internalQuery
SELECT COUNT(DISTINCT DocumentID) AS Count1, COUNT(DISTINCT DocumentSessionId) AS Count2 FROM DocumentOutputItems
SELECT COUNT(DISTINCT DocumentId) FROM DocumentOutputItems
SELECT COUNT(DISTINCT convert(varchar(15),DocumentId)+ FROM DocumentOutputItems
SELECT COUNT(*) FROM DocumentOutputItems GROUP BY DocumentId, DocumentSessionId
SELECT COUNT(DISTINCT CHECKSUM(value1, value2, ..., valueN) + CHECKSUM(valueN, value(N-1), ..., value1))
SELECT SUM(DECODE(COUNT(*),1,1,1)) FROM DocumentOutputItems GROUP BY DocumentId, DocumentSessionId;
SELECT SUM(CASE WHEN COUNT(i)=1 THEN 1 ELSE 1 END) FROM DocumentOutputItems i GROUP BY i.DocumentId, i.DocumentSessionId;
Select DocumentId, DocumentSessionId, count(*) as c from DocumentOutputItems group by DocumentId, DocumentSessionId;
SELECT COUNT (DISTINCT DocumentId), COUNT (DISTINCT DocumentSessionId) FROM DocumentOutputItems
select col1, col2, col3, count(*) from table group by col1, col2, col3
SELECT CONVERT(varchar, CAST(987654321 AS money), 1)
REPLACE(CONVERT(varchar(20), (CAST(SUM(table.value) AS money)), 1),
-- FORMAT -- http: -- FORMAT does not do conversion, that -- Only accepts numeric and date/time data types for formatting. -- -- Formatting Types -- http: -- Standard numeric format strings -- http: SELECT -- c => currency -- n => numeric FORMAT(987654321, N , FORMAT(987654321, N , C.culture FROM ( -- Language culture names -- http: VALUES ( , ( , ( , ( , ( ) C (culture);
PRINT FORMATMESSAGE( -- Output The number is: 5,000,000
PRINT FORMATMESSAGE( -- Output The number is: 5,000,000.76
SELECT REPLACE(CONVERT(varchar(20), (CAST(9876543 AS money)), 1),
CREATE FUNCTION [dbo].[fn_FormatWithCommas] ( -- Add the parameters for the function here @value varchar(50) ) RETURNS varchar(50) AS BEGIN -- Declare the return variable here DECLARE @WholeNumber varchar(50) = NULL, @Decimal varchar(10) = IF (@CharIndex > 0) SELECT @WholeNumber = SUBSTRING(@value, 1, @CharIndex-1), @Decimal = SUBSTRING(@value, @CharIndex, LEN(@value)) ELSE SET @WholeNumber = @value IF(LEN(@WholeNumber) > 3) SET @WholeNumber = dbo.fn_FormatWithCommas(SUBSTRING(@WholeNumber, 1, LEN(@WholeNumber)-3)) + -- Return the result of the function RETURN @WholeNumber + @Decimal END
SELECT PARSENAME(CONVERT(varchar, CAST(987654321 AS money), 1), 2)
CREATE FUNCTION dbo.Format(@num int) returns varChar(30) As Begin Declare @out varChar(30) = while @num > 0 Begin Set @out = str(@num % 1000, 3, 0) + Coalesce( Set @num = @num / 1000 End Return @out End
` CREATE FUNCTION dbo.formatAmount ( @amtIn as varchar(20) ) RETURNS varchar(20) AS BEGIN return cast(REPLACE(SUBSTRING(CONVERT(varchar(20), CAST(@amtIn AS money), 1),1, LEN(CONVERT(varchar(20), CAST(@amtIn AS money), 1))-3), + replace(RIGHT(CONVERT(varchar(20), CAST(@amtIn AS money), 1),3), END SELECT [geniki].[dbo].[formatAmount](
CREATE FUNCTION [dbo].[fnNumericWithCommas](@num decimal(38, 18), @decimals int = 4) RETURNS varchar(44) AS BEGIN DECLARE @ret varchar(44) DECLARE @negative bit; SET @negative = CASE WHEN @num < 0 THEN 1 ELSE 0 END SET @num = abs(round(@num, @decimals)) -- round the value to the number of decimals desired DECLARE @decValue varchar(18); SET @decValue = substring(ltrim(@num - round(@num, 0, 1)) + SET @num = round(@num, 0, 1) -- truncate the incoming number of any decimals WHILE @num > 0 BEGIN SET @ret = str(@num % 1000, 3, 0) + isnull( SET @num = round(@num / 1000, 0, 1) END SET @ret = isnull(replace(ltrim(@ret), IF (@negative = 1) SET @ret = RETURN @ret END GO
CREATE FUNCTION [dbo].[fn_FormatNumber] (@number decimal(38,18)) RETURNS varchar(50) BEGIN -- remove minus sign before applying thousands seperator DECLARE @negative bit SET @negative = CASE WHEN @number < 0 THEN 1 ELSE 0 END SET @number = ABS(@number) -- add thousands seperator for every 3 digits to the left of the decimal place DECLARE @pos int, @result varchar(50) = CAST(@number AS varchar(50)) SELECT @pos = CHARINDEX( WHILE @pos > 4 BEGIN SET @result = STUFF(@result, @pos-3, 0, SELECT @pos = CHARINDEX( END -- remove trailing zeros WHILE RIGHT(@result, 1) = SET @result = LEFT(@result, LEN(@result)-1) -- remove decimal place if not required IF RIGHT(@result, 1) = SET @result = LEFT(@result, LEN(@result)-1) IF @negative = 1 SET @result = RETURN @result END
/* */ CREATE FUNCTION [dbo].[fn_nDerecha] ( -- Agregue Argumentos, para personalizar la funcion a su conveniencia @Numero_str varchar(max) ,@Pos_Enteros int ,@Pos_Decimales int ) RETURNS varchar(max) AS BEGIN -- Declare la variable del RETURN aqui, en este caso es RESULT declare @RESULTADO varchar(max) set @RESULTADO = ----------------------------------------------- -- declare @Numero_num numeric(28,12) set @Numero_num = ( case when isnumeric(@Numero_str) = 0 then 0 else round (convert( numeric(28,12), @Numero_str), @Pos_Decimales) end ) -- ----------------------------------------------- -- -- Aumenta @Pos_Enteros de @RESULTADO, -- si las posiciones de Enteros del dato @Numero_str es Mayor... -- declare @Num_Pos_Ent int set @Num_Pos_Ent = len ( convert( varchar, convert(int, abs(@Numero_num) ) ) ) -- declare @Pos_Ent_Mas int set @Pos_Ent_Mas = ( case when @Num_Pos_Ent > @Pos_Enteros then @Num_Pos_Ent - @Pos_Enteros else 0 end ) set @Pos_Enteros = @Pos_Enteros + @Pos_Ent_Mas -- -- ----------------------------------------------- -- declare @p_Signo_ctd int set @p_Signo_ctd = (case when @Numero_num < 1 then 1 else 0 end) -- declare @p_Comas_ctd int set @p_Comas_ctd = ( @Pos_Enteros - 1 ) / 3 -- declare @p_Punto_ctd int set @p_Punto_ctd = (case when @Pos_Decimales > 0 then 1 else 0 end) -- declare @p_input_Longitud int set @p_input_Longitud = ( @p_Signo_ctd + @Pos_Enteros ) + @p_Punto_ctd + @Pos_Decimales -- declare @p_output_Longitud int set @p_output_Longitud = ( @p_Signo_ctd + @Pos_Enteros + @p_Comas_ctd ) + ( @p_Punto_ctd + @Pos_Decimales ) -- -- =================================================================== -- declare @Valor_str varchar(max) set @Valor_str = str(@Numero_num, @p_input_Longitud, @Pos_Decimales) declare @V_Ent_str varchar(max) set @V_Ent_str = (case when @Pos_Decimales > 0 then substring( @Valor_str, 0, charindex( else @Valor_str end) -- declare @V_Dec_str varchar(max) set @V_Dec_str = (case when @Pos_Decimales > 0 then else -- set @V_Ent_str = convert(VARCHAR, convert(money, @V_Ent_str), 1) set @V_Ent_str = substring( @V_Ent_str, 0, charindex( -- set @RESULTADO = @V_Ent_str + @V_Dec_str -- set @RESULTADO = ( replicate( -- -- =================================================================== -
RETURN @RESULTADO END -- =================================================================== --
WITH y AS ( WITH x AS ( SELECT * FROM MyTable ) SELECT * FROM x ) SELECT * FROM y
WITH x AS ( SELECT * FROM MyTable ), y AS ( SELECT * FROM x ) SELECT * FROM y
WITH y AS ( SELECT x, y, z FROM MyTable WHERE [base_condition] UNION ALL SELECT x, y, z FROM MyTable M INNER JOIN y ON M.[some_other_condition] = y.[some_other_condition] ) SELECT * FROM y
WITH y AS ( SELECT * FROM MyTable WHERE [base_condition] ), x AS ( SELECT * FROM y WHERE [something_else] ) SELECT * FROM x
;WITH A AS( ... ), B AS( ... ) SELECT * FROM A UNION ALL SELECT * FROM B
WITH paths AS ( SELECT EmployeeID, CONVERT(VARCHAR(900), CONCAT( FROM EmployeeHierarchyWide WHERE ManagerID IS NULL UNION ALL SELECT ehw.EmployeeID, CONVERT(VARCHAR(900), CONCAT(p.FullPath, ehw.EmployeeID, FROM paths AS p JOIN EmployeeHierarchyWide AS ehw ON ehw.ManagerID = p.EmployeeID ) SELECT * FROM paths order by FullPath
;with cte_data as ( Select * from [HumanResources].[Department] ),cte_data1 as ( Select * from [HumanResources].[Department] ) select * from cte_data,cte_data1
cte_extract as ( select ps.Process as ProcessEvent , ps.ProcessStartDate , ps.ProcessEndDate -- select strt.* from dbo.tbl_some_table ps inner join (select max(ProcessStatusId) ProcessStatusId from dbo.tbl_some_table where Process = and convert(varchar(10), ProcessStartDate, 112) < ) strt on strt.ProcessStatusId = ps.ProcessStatusID ), cte_rls as ( select x.ProcessStartDate, y.ProcessEndDate from ( select 1 as Id, ps.Process as ProcessEvent , ps.ProcessStartDate , ps.ProcessEndDate -- select strt.* from dbo.tbl_some_table ps inner join (select max(ProcessStatusId) ProcessStatusId from dbo.tbl_some_table where Process = and convert(varchar(10), ProcessStartDate, 112) < ) strt on strt.ProcessStatusId = ps.ProcessStatusID ) x left join ( select 1 as Id, ps.Process as ProcessEvent , ps.ProcessStartDate , ps.ProcessEndDate -- select strt.* from dbo.tbl_some_table ps inner join (select max(ProcessStatusId) ProcessStatusId from dbo.tbl_some_table where Process = and convert(varchar(10), ProcessEndDate, 112) < ) enddt on enddt.ProcessStatusId = ps.ProcessStatusID ) y on y.Id = x.Id ),
-- Sample Table create table myTable ( Column1 int not null, Column2 int not null ) GO -- Add Constraint ALTER TABLE myTable ADD CONSTRAINT pk_myConstraint PRIMARY KEY (Column1,Column2) GO
create table my_table ( id_part1 int not null, id_part2 int not null, primary key (id_part1, id_part2) )
create table myTable ( Column1 int not null, Column2 int not null ) GO ALTER TABLE myTable ADD PRIMARY KEY (Column1,Column2) GO
id somedate somevalue -- -------- --------- 45 01/Jan/09 3 23 08/Jan/09 5 12 02/Feb/09 0 77 14/Feb/09 7 39 20/Feb/09 34 33 02/Mar/09 6
id somedate somevalue runningtotal -- -------- --------- ------------ 45 01/Jan/09 3 3 23 08/Jan/09 5 8 12 02/Feb/09 0 8 77 14/Feb/09 7 15 39 20/Feb/09 34 49 33 02/Mar/09 6 55
INSERT INTO @AnotherTbl(id, somedate, somevalue, runningtotal) SELECT id, somedate, somevalue, null FROM TestTable ORDER BY somedate DECLARE @RunningTotal int SET @RunningTotal = 0 UPDATE @AnotherTbl SET @RunningTotal = runningtotal = @RunningTotal + somevalue FROM @AnotherTbl
SELECT somedate, somevalue, SUM(somevalue) OVER(ORDER BY somedate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RunningTotal FROM Table
drop table create table insert -- notice the malicious re-ordering insert insert insert declare @total int set @total = 0 update select * from order by ord ord total running_total ----------- ----------- ------------- 1 10 10 2 20 30 3 10 40 4 1 41
create table set nocount on declare @i int set @i = 0 begin tran while @i < 10000 begin insert set @i = @i +1 end commit
SELECT ord,total, (SELECT SUM(total) FROM WHERE b.ord <= a.ord) AS b FROM -- CPU 11731, Reads 154934, Duration 11135
SELECT a.ord, a.total, SUM(b.total) AS RunningTotal FROM WHERE (b.ord <= a.ord) GROUP BY a.ord,a.total ORDER BY a.ord -- CPU 16053, Reads 154935, Duration 4647
DECLARE @TotalTable table(ord int primary key, total int, running_total int) DECLARE forward_cursor CURSOR FAST_FORWARD FOR SELECT ord, total FROM ORDER BY ord OPEN forward_cursor DECLARE @running_total int, @ord int, @total int SET @running_total = 0 FETCH NEXT FROM forward_cursor INTO @ord, @total WHILE (@@FETCH_STATUS = 0) BEGIN SET @running_total = @running_total + @total INSERT @TotalTable VALUES(@ord, @total, @running_total) FETCH NEXT FROM forward_cursor INTO @ord, @total END CLOSE forward_cursor DEALLOCATE forward_cursor SELECT * FROM @TotalTable -- CPU 359, Reads 30392, Duration 496
declare @total int set @total = 0 update select * from -- CPU 0, Reads 58, Duration 139
select id, somedate, somevalue, sum(somevalue) over(order by somedate rows unbounded preceding) as runningtotal from TestTable
;with CTE_RunningTotal as ( select T.ord, T.total, T.total as running_total from where T.ord = 0 union all select T.ord, T.total, T.total + C.running_total as running_total from CTE_RunningTotal as C inner join ) select C.ord, C.total, C.running_total from CTE_RunningTotal as C option (maxrecursion 0) -- CPU 140, Reads 110014, Duration 132
declare @total int, @ord int select @total = 0, @ord = -1 update @total = @total + total, @ord = case when ord <> @ord + 1 then 1/0 else ord end, ------------------------ running_total = @total select * from -- CPU 0, Reads 58, Duration 139
select t.id , t.somedate , t.somevalue , rt.runningTotal from TestTable t cross apply (select sum(somevalue) as runningTotal from TestTable where somedate <= t.somedate ) as rt order by t.somedate
SELECT TOP 25 amount, (SELECT SUM(amount) FROM time_detail b WHERE b.time_detail_id <= a.time_detail_id) AS Total FROM time_detail a
SELECT somedate, (SELECT SUM(somevalue) FROM TestTable t2 WHERE t2.somedate<=t1.somedate) AS running_total FROM TestTable t1 GROUP BY somedate ORDER BY somedate
SELECT id, somedate, somevalue, (SELECT SUM(somevalue) FROM TestTable t2 WHERE t2.somedate<=t1.somedate) AS running_total FROM TestTable t1 ORDER BY somedate
select testtable.*, sum(somevalue) over(order by somedate) from testtable order by somedate;
SELECT a.SomeDate, a.SomeValue, SUM(b.SomeValue) AS RunningTotal FROM TestTable a CROSS JOIN TestTable b WHERE (b.SomeDate <= a.SomeDate) GROUP BY a.SomeDate,a.SomeValue ORDER BY a.SomeDate,a.SomeValue
Select id ,somedate ,somevalue, LAG(runningtotal) OVER (ORDER BY somedate) + somevalue AS runningtotal From TestTable
SELECT ROW_NUMBER() OVER (ORDER BY SomeDate) AS OrderID ,rt.* INTO FROM ( SELECT 45 AS ID, CAST( UNION ALL SELECT 23, CAST( UNION ALL SELECT 12, CAST( UNION ALL SELECT 77, CAST( UNION ALL SELECT 39, CAST( UNION ALL SELECT 33, CAST( ) rt SELECT t1.ID ,t1.SomeDate ,t1.SomeValue ,SUM(t2.SomeValue) AS RunningTotal FROM JOIN ON t2.OrderID <= t1.OrderID GROUP BY t1.OrderID ,t1.ID ,t1.SomeDate ,t1.SomeValue ORDER BY t1.OrderID DROP TABLE
SELECT a.id, a.value, SUM(b.Value)FROM RunTotalTestData a, RunTotalTestData b WHERE b.id <= a.id GROUP BY a.id, a.value ORDER BY a.id;
Select id, someday, somevalue, (select sum(somevalue) from testtable as t2 where t2.id = t1.id and t2.someday <= t1.someday) as runningtotal from testtable as t1 order by id,someday;
BEGIN TRAN CREATE TABLE INSERT INTO SELECT 45 , SELECT 23 , SELECT 12 , SELECT 77 , SELECT 39 , SELECT 33 , ;WITH CTE ( _Id, id , _somedate , _somevalue ,_totvalue ) AS ( SELECT _Id , id , somedate , somevalue ,somevalue FROM UNION ALL SELECT FROM WHERE ) SELECT * FROM CTE ROLLBACK TRAN
Declare @d datetime select @d = getdate() select @d as OriginalDate, convert(varchar,@d,100) as ConvertedDate, 100 as FormatValue, union all select @d,convert(varchar,@d,101),101, union all select @d,convert(varchar,@d,102),102, union all select @d,convert(varchar,@d,103),103, union all select @d,convert(varchar,@d,104),104, union all select @d,convert(varchar,@d,105),105, union all select @d,convert(varchar,@d,106),106, union all select @d,convert(varchar,@d,107),107, union all select @d,convert(varchar,@d,108),108, union all select @d,convert(varchar,@d,109),109, union all select @d,convert(varchar,@d,110),110, union all select @d,convert(varchar,@d,111),111, union all select @d,convert(varchar,@d,12),12, union all select @d,convert(varchar,@d,112),112, union all select @d,convert(varchar,@d,113),113, union all select @d,convert(varchar,@d,114),114, union all select @d,convert(varchar,@d,120),120, union all select @d,convert(varchar,@d,121),121, union all select @d,convert(varchar,@d,126),126,
DECLARE @d DATETIME = -- returns Oct-13/2008 18:45:19: SELECT FORMAT(@d, N -- returns NULL if the conversion fails: SELECT TRY_PARSE(FORMAT(@d, N -- returns an error if the conversion fails: SELECT PARSE(FORMAT(@d, N
WAITFOR DELAY WAITFOR DELAY WAITFOR DELAY WAITFOR DELAY
--Example 1 DECLARE @Delay1 DATETIME SELECT @Delay1 = WAITFOR DELAY @Delay1 --Example 2 DECLARE @Delay2 DATETIME SELECT @Delay2 = dateadd(SECOND, 2, convert(DATETIME, 0)) WAITFOR DELAY @Delay2
--Example 3 DECLARE @Time1 DATETIME SELECT @Time1 = getdate() WAITFOR DELAY WAITFOR TIME @Time1 --WILL HANG FOREVER
--Example 4 DECLARE @Delay3 DATETIME SELECT @Delay3 = dateadd(SECOND, -1, convert(DATETIME, 0)) WAITFOR DELAY @Delay3 --WILL HANG FOREVER
SELECT ID, [Description], RANK() OVER(PARTITION BY StyleID ORDER BY ID) as SELECT ID, [Description], ROW_NUMBER() OVER(PARTITION BY StyleID ORDER BY ID) as
WITH T(StyleID, ID) AS (SELECT 1,1 UNION ALL SELECT 1,1 UNION ALL SELECT 1,1 UNION ALL SELECT 1,2) SELECT *, RANK() OVER(PARTITION BY StyleID ORDER BY ID) AS ROW_NUMBER() OVER(PARTITION BY StyleID ORDER BY ID) AS DENSE_RANK() OVER(PARTITION BY StyleID ORDER BY ID) AS FROM T
StyleID ID RANK ROW_NUMBER DENSE_RANK ----------- -------- --------- --------------- ---------- 1 1 1 1 1 1 1 1 2 1 1 1 1 3 1 1 2 4 4 2
SELECT DISTINCT v, ROW_NUMBER() OVER (ORDER BY v) row_number FROM t ORDER BY v, row_number
+---+------------+ | V | ROW_NUMBER | +---+------------+ | a | 1 | | a | 2 | | a | 3 | | b | 4 | | c | 5 | | c | 6 | | d | 7 | | e | 8 | +---+------------+
SELECT DISTINCT v, DENSE_RANK() OVER (ORDER BY v) row_number FROM t ORDER BY v, row_number
+---+------------+ | V | ROW_NUMBER | +---+------------+ | a | 1 | | b | 2 | | c | 3 | | d | 4 | | e | 5 | +---+------------+
SELECT v, ROW_NUMBER() OVER (window) row_number, RANK() OVER (window) rank, DENSE_RANK() OVER (window) dense_rank FROM t WINDOW window AS (ORDER BY v) ORDER BY v
+---+------------+------+------------+ | V | ROW_NUMBER | RANK | DENSE_RANK | +---+------------+------+------------+ | a | 1 | 1 | 1 | | a | 2 | 1 | 1 | | a | 3 | 1 | 1 | | b | 4 | 4 | 2 | | c | 5 | 5 | 3 | | c | 6 | 5 | 3 | | d | 7 | 7 | 4 | | e | 8 | 8 | 5 | +---+------------+------+------------+
CREATE TABLE [dbo]. [id] [int] NOT NULL, [create_date] [date] NOT NULL, [info1] [varchar](50) NOT NULL, [info2] [varchar](50) NOT NULL, )
INSERT INTO dbo. VALUES (1, INSERT INTO dbo. VALUES (1, INSERT INTO dbo. VALUES (1, INSERT INTO dbo. VALUES (2, INSERT INTO dbo. VALUES (2, INSERT INTO dbo. VALUES (3, INSERT INTO dbo. VALUES (3,
SELECT Id, create_date, info1, info2, ROW_NUMBER() OVER (PARTITION BY Id ORDER BY create_date DESC) AS RowId, RANK() OVER(PARTITION BY Id ORDER BY create_date DESC) AS [RANK] FROM
select item, name, sold, row_number() over(partition by item order by sold) as row from table_name
+--------+------+-----+----+ |glasses |store1| 30 | 1 | |glasses |store2| 35 | 2 | |glasses |store3| 40 | 3 | |shoes |store2| 10 | 1 | |shoes |store1| 20 | 2 | |shoes |store3| 22 | 3 | +--------+------+-----+----+
SELECT [Date] FROM [FRIIB].[dbo].[ArchiveAnalog] GROUP BY [Date]
SELECT MIN([Date]) AS RecT, AVG(Value) FROM [FRIIB].[dbo].[ArchiveAnalog] GROUP BY (DATEPART(MINUTE, [Date]) / 10) ORDER BY RecT
GROUP BY DATEPART(YEAR, DT.[Date]), DATEPART(MONTH, DT.[Date]), DATEPART(DAY, DT.[Date]), DATEPART(HOUR, DT.[Date]), (DATEPART(MINUTE, DT.[Date]) / 10)
GROUP BY DATEADD(MINUTE, DATEDIFF(MINUTE, 0, date_column) / 10 * 10, 0)
SELECT DATEADD(MINUTE, DATEDIFF(MINUTE, 0, aa.[date]) / 10 * 10, 0) AS [date_truncated], COUNT(*) AS [records_in_interval], AVG(aa.[value]) AS [average_value] FROM [friib].[dbo].[archive_analog] AS aa GROUP BY DATEADD(MINUTE, DATEDIFF(MINUTE, 0, aa.[date]) / 10 * 10, 0) ORDER BY [date_truncated]
SELECT [Date] FROM [FRIIB].[dbo].[ArchiveAnalog] GROUP BY [Date], DATEPART(hh, [Date])
select timeslot, count(*) from ( select datepart( FROM [FRIIB].[dbo].[ArchiveAnalog] ) group by timeslot
SELECT timeslot, COUNT(*) FROM ( SELECT to_char(l_time, FROM ( SELECT l_time FROM mytab ) ) GROUP BY timeslot
GROUP BY DATE(`your_date_field`), HOUR(`your_date_field`), FLOOR( MINUTE(`your_date_field`) / 10);
CREATE FUNCTION [dbo].[fn_MinuteIntervals] ( @startDate SMALLDATETIME , @endDate SMALLDATETIME , @interval INT = 1 ) RETURNS @returnDates TABLE ( [date] SMALLDATETIME PRIMARY KEY NOT NULL ) AS BEGIN DECLARE @counter SMALLDATETIME SET @counter = @startDate WHILE @counter <= @endDate BEGIN INSERT INTO @returnDates VALUES ( @counter ) SET @counter = DATEADD(n, @interval, @counter) END RETURN END
DATEADD(MILLISECOND, -DATEDIFF(MILLISECOND, CAST(time AS DATE), time) % @msPerSlice, time)
AttDate Time == 2011-02-09 13:09:00 13:09 2011-02-09 14:10:00 14:10
select convert(char(5), AttDate, 108) [time] from yourtable
SELECT ..., DATEADD(dd, DATEDIFF(dd, MyDateTimeCol, 0), MyDateTimeCol) FROM ...
select convert(nvarchar,CAST(getdate()as time),100)
SELECT CONVERT(VARCHAR(9),RIGHT(YOURCOLUMN_DATETIME,9),108) FROM YOURTABLE
SELECT LTRIM(RIGHT(CONVERT(VARCHAR(20), GETDATE(), 100), 7)) FROM TABLENAME WHERE ...
SELECT LTRIM(RIGHT(CONVERT(VARCHAR(20), datename, 100), 7)) FROM TABLENAME WHERE ...
DATEPART(YEAR, [date]) DATEPART(MONTH, [date]) DATEPART(DAY, [date]) DATEPART(HOUR, [date]) DATEPART(MINUTE, [date])
datepart ***Abbreviation year ***yy, yyyy quarter ***qq, q month ***mm, m dayofyear ***dy, y day ***dd, d week ***wk, ww weekday ***dw, w hour ***hh minute ***mi, n second ***ss, s millisecond ***ms microsecond ***mcs nanosecond ***ns
select * from table001 where datepart(hh,datetime) like 23
SELECT Run_Time_Hour = CASE DATEPART(HOUR, R.date_schedule) WHEN 0 THEN WHEN 1 THEN WHEN 2 THEN WHEN 3 THEN WHEN 4 THEN WHEN 5 THEN WHEN 6 THEN WHEN 7 THEN WHEN 8 THEN WHEN 9 THEN WHEN 10 THEN WHEN 11 THEN WHEN 12 THEN ELSE CONVERT(varchar, DATEPART(HOUR, R.date_schedule)-12) + END FROM dbo.ARCHIVE_RUN_SCHEDULE R
select case when [am or _pm] = then dateadd(hour,12,time_received) else time_received END from table
SELECT a.* FROM a WHERE col IN ( SELECT col FROM b )
SELECT a.* FROM a JOIN ( SELECT DISTINCT col FROM b ) ON b.col = a.col
SELECT a.* FROM a WHERE EXISTS ( SELECT * FROM b WHERE b.col = a.col )
DECLARE @i int DECLARE @PractitionerId int DECLARE @numrows int DECLARE @Practitioner TABLE ( idx smallint Primary Key IDENTITY(1,1) , PractitionerId int ) INSERT @Practitioner SELECT distinct PractitionerId FROM Practitioner SET @i = 1 SET @numrows = (SELECT COUNT(*) FROM Practitioner) IF @numrows > 0 WHILE (@i <= (SELECT MAX(idx) FROM Practitioner)) BEGIN SET @PractitionerId = (SELECT PractitionerId FROM @Practitioner WHERE idx = @i) --Do something with Id here PRINT @PractitionerId SET @i = @i + 1 END
DECLARE @PractitionerId int DECLARE MY_CURSOR CURSOR LOCAL STATIC READ_ONLY FORWARD_ONLY FOR SELECT DISTINCT PractitionerId FROM Practitioner OPEN MY_CURSOR FETCH NEXT FROM MY_CURSOR INTO @PractitionerId WHILE @@FETCH_STATUS = 0 BEGIN --Do something with Id here PRINT @PractitionerId FETCH NEXT FROM MY_CURSOR INTO @PractitionerId END CLOSE MY_CURSOR DEALLOCATE MY_CURSOR
DECLARE @PractitionerId int = 0 WHILE(1 = 1) BEGIN SELECT @PractitionerId = MIN(PractitionerId) FROM dbo.Practitioner WHERE PractitionerId > @PractitionerId IF @PractitionerId IS NULL BREAK SELECT @PractitionerId END
DECLARE @i int DECLARE @PractitionerId int DECLARE @numrows int DECLARE @Practitioner TABLE ( idx smallint Primary Key IDENTITY(1,1) , PractitionerId int ) INSERT @Practitioner SELECT distinct PractitionerId FROM Practitioner SET @i = 1 SET @numrows = (SELECT COUNT(*) FROM @Practitioner) IF @numrows > 0 WHILE (@i <= (SELECT MAX(idx) FROM @Practitioner)) BEGIN SET @PractitionerId = (SELECT PractitionerId FROM @Practitioner WHERE idx = @i) --Do something with Id here PRINT @PractitionerId SET @i = @i + 1 END
DECLARE @Practitioner TABLE ( idx smallint Primary Key IDENTITY(1,1) , PractitionerId int )
1. create a temp table and put the records you want to iterate in there 2. use WHILE @@ROWCOUNT <> 0 to do the iterating 3. to get one row at a time do, SELECT TOP 1 <fieldnames> b. save the unique ID for that row in a variable 4. Do Stuff, then delete the row from the temp table based on the ID saved at step 3b.
declare @tempPFRunStops TABLE (ProformaRunStopsID int,ProformaRunMasterID int, CompanyLocationID int, StopSequence int ); INSERT @tempPFRunStops (ProformaRunStopsID,ProformaRunMasterID, CompanyLocationID, StopSequence) SELECT ProformaRunStopsID, ProformaRunMasterID, CompanyLocationID, StopSequence from ProformaRunStops WHERE ProformaRunMasterID IN ( SELECT ProformaRunMasterID FROM ProformaRunMaster WHERE ProformaId = 15 ) -- SELECT * FROM @tempPFRunStops WHILE @@ROWCOUNT <> 0 -- << I dont know how this works BEGIN SELECT TOP 1 * FROM @tempPFRunStops -- I could have put the unique ID into a variable here SELECT DELETE @tempPFRunStops WHERE ProformaRunStopsID = (SELECT TOP 1 ProformaRunStopsID FROM @tempPFRunStops) END
alter table [progennet_dev].PROGEN.LE alter column UR_VALUE_3
ALTER TABLE YourTable ALTER COLUMN YourColumn <<new_datatype>> [NULL | NOT NULL]
ALTER TABLE YourTable ALTER COLUMN YourColumn VARCHAR (500) NOT NULL;
ALTER TABLE YourTable ALTER COLUMN YourColumn VARCHAR (500);
ALTER TABLE YourTable ALTER COLUMN YourColumn VARCHAR (500) NULL;
alter table [progennet_dev].PROGEN.LE alter column UR_VALUE_3 varchar(500)
ALTER TABLE `your_table` CHANGE `property` `property` VARCHAR(whatever_you_want) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL;
-- Set Identity insert on so that value can be inserted into this column SET IDENTITY_INSERT YourTable ON GO -- Insert the record which you want to update with new value in identity column INSERT INTO YourTable(IdentityCol, otherCol) VALUES(13, GO -- Delete the old row of which you have inserted a copy (above) (make sure about FK DELETE FROM YourTable WHERE ID=3 GO --Now set the idenetity_insert OFF to back to prevoius track SET IDENTITY_INSERT YourTable OFF
--before running this make sure Foreign key constraints have been removed that reference the ID. --set table to allow identity to be inserted SET IDENTITY_INSERT yourTable ON; GO --insert everything into a temp table SELECT * INTO FROM yourTable --clear your table DELETE FROM yourTable --insert back all the values with the updated ID column INSERT INTO yourTable (IDCol, OtherCols) SELECT ID+1 as updatedID --put any other update logic to the ID here , OtherCols FROM --drop the temp table DROP TABLE --put identity back to normal SET IDENTITY_INSERT yourTable OFF; GO
ALTER TABLE tableName ADD id MEDIUMINT NOT NULL AUTO_INCREMENT KEY
public static string BuildInsertSQLText ( DataTable table ) { StringBuilder sql = new StringBuilder(1000,5000000); StringBuilder values = new StringBuilder ( "VALUES (" ); bool bFirst = true; bool bIdentity = false; string identityType = null; foreach(DataRow myRow in table.Rows) { sql.Append( "\r\nINSERT INTO " + table.TableName + " (" ); foreach ( DataColumn column in table.Columns ) { if ( column.AutoIncrement ) { bIdentity = true; switch ( column.DataType.Name ) { case "Int16": identityType = "smallint"; break; case "SByte": identityType = "tinyint"; break; case "Int64": identityType = "bigint"; break; case "Decimal": identityType = "decimal"; break; default: identityType = "int"; break; } } else { if ( bFirst ) bFirst = false; else { sql.Append ( ", " ); values.Append ( ", " ); } sql.Append ("["); sql.Append ( column.ColumnName ); sql.Append ("]"); if (myRow[column.ColumnName].ToString() == "True") values.Append("1"); else if (myRow[column.ColumnName].ToString() == "False") values.Append("0"); else if(myRow[column.ColumnName] == System.DBNull.Value) values.Append ("NULL"); else if(column.DataType.ToString().Equals("System.String")) { values.Append (" } else values.Append (myRow[column.ColumnName].ToString()); } } sql.Append ( ") " ); sql.Append ( values.ToString () ); sql.Append ( ")" ); if ( bIdentity ) { sql.Append ( "; SELECT CAST(scope_identity() AS " ); sql.Append ( identityType ); sql.Append ( ")" ); } bFirst = true; sql.Append(";"); values = new StringBuilder ( "VALUES (" ); } return sql.ToString (); ; }
insert into MyTable (colA, ColB) select colA, colB from MyTable
SELECT IDENTITY (int, 1, 1) AS id, column1, column2 INTO dbo.NewTable FROM dbo.OldTable
ALTER TABLE tablename add newcolumn int update tablename set newcolumn=existingcolumnname ALTER TABLE tablename DROP COLUMN existingcolumnname; EXEC sp_RENAME update tablename set newcolumnname=value where condition
IF EXISTS (SELECT * FROM sys.types WHERE is_table_type = 1 AND name = --stuff
IF EXISTS(SELECT 1 FROM sys.types WHERE name = DROP TYPE VAB.Person; go CREATE TYPE VAB.Person AS TABLE ( PersonID INT ,FirstName VARCHAR(255) ,MiddleName VARCHAR(255) ,LastName VARCHAR(255) ,PreferredName VARCHAR(255) );
IF TYPE_ID(N CREATE TYPE [dbo].[idType] FROM Bigint NOT NULL go IF not EXISTS (SELECT * FROM sys.types WHERE is_user_defined = 1 AND name = CREATE TYPE [dbo].[idType] FROM Bigint NOT NULL go
IF EXISTS (SELECT * FROM [sys].[table_types] WHERE user_type_id = Type_id(N BEGIN PRINT END
create procedure getDepartments @DepartmentIds varchar(max) as declare @Sql varchar(max) select @Sql = exec(@Sql)
SELECT d.[Name] FROM Department d JOIN dbo.SplitWords(@DepartmentIds) w ON w.Value = d.DepartmentId
IF OBJECT_ID( BEGIN DROP TABLE END SET @DepartmentIDs=REPLACE(@DepartmentIDs, CREATE TABLE DECLARE @DeptID INT IF IsNumeric(@DepartmentIDs)=1 BEGIN SET @DeptID=@DepartmentIDs INSERT INTO END ELSE BEGIN WHILE CHARINDEX( BEGIN SET @DeptID=LEFT(@DepartmentIDs,CHARINDEX( SET @DepartmentIDs=RIGHT(@DepartmentIDs,LEN(@DepartmentIDs)-CHARINDEX( INSERT INTO END END
SELECT Dept.Name FROM Departments JOIN ORDER BY Dept.Name
declare @xmlstring as varchar(100) set @xmlstring = declare @docid int exec sp_xml_preparedocument @docid output, @xmlstring select [id],parentid,nodetype,localname,[text] from openxml(@docid,
id parentid nodetype localname text 0 NULL 1 args NULL 2 0 1 arg NULL 3 2 2 value NULL 5 3 3 4 0 1 arg2 NULL 6 4 3
Declare @XMLList xml SET @XMLList=cast( SELECT x.i.value(
@list_of_params varchar(20) -- value 1, 2, 5, 7, 20 SELECT d.[Name] FROM Department d where @list_of_params like (
declare @t varchar(max) select @t = long_column from table print @t
INSERT INTO dbo.prf_BatchItemAdditionalAPartyNos ( BatchID, AccountNo, APartyNo, SourceRowID ) WITH tab ( -- some query ) SELECT * FROM tab
WITH tab AS ( bla bla ) INSERT INTO dbo.prf_BatchItemAdditionalAPartyNos ( BatchID, AccountNo, APartyNo, SourceRowID ) SELECT * FROM tab
WITH tab ( bla bla ) INSERT INTO dbo.prf_BatchItemAdditionalAPartyNos ( BatchID, AccountNo, APartyNo, SourceRowID) SELECT * FROM tab
WITH x AS (), y AS () INSERT INTO z (a, b, c) SELECT a, b, c FROM y
WITH _INSERT_ AS ( SELECT [BatchID] = blah ,[APartyNo] = blahblah ,[SourceRowID] = blahblahblah FROM Table1 AS t1 ) INSERT Table2 ([BatchID], [SourceRowID], [APartyNo]) SELECT [BatchID], [APartyNo], [SourceRowID] FROM _INSERT_
INSERT Table2 ( [BatchID] ,[SourceRowID] ,[APartyNo] ) SELECT [BatchID] = blah ,[APartyNo] = blahblah ,[SourceRowID] = blahblahblah FROM Table1 AS t1
CREATE TRIGGER dbo.TableName_IUD ON dbo.TableName AFTER INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON; -- -- Check if this is an INSERT, UPDATE or DELETE Action. -- DECLARE @action as char(1); SET @action = IF EXISTS(SELECT * FROM DELETED) BEGIN SET @action = CASE WHEN EXISTS(SELECT * FROM INSERTED) THEN ELSE END END ELSE IF NOT EXISTS(SELECT * FROM INSERTED) RETURN; -- Nothing updated or inserted. ... END
--Determine if this is an INSERT,UPDATE, or DELETE Action or a "failed delete". DECLARE @Action as char(1); SET @Action = (CASE WHEN EXISTS(SELECT * FROM INSERTED) AND EXISTS(SELECT * FROM DELETED) THEN WHEN EXISTS(SELECT * FROM INSERTED) THEN WHEN EXISTS(SELECT * FROM DELETED) THEN ELSE NULL -- Skip. It may have been a "failed delete". END)
CREATE TRIGGER dbo.TR_TableName_TriggerName ON dbo.TableName AFTER INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON; IF NOT EXISTS(SELECT * FROM INSERTED) -- DELETE PRINT ELSE BEGIN IF NOT EXISTS(SELECT * FROM DELETED) -- INSERT PRINT ELSE -- UPDATE PRINT END END;
CREATE TRIGGER [dbo].[INSUPDDEL_MyDataTable] ON [dbo].[MyDataTable] FOR INSERT, UPDATE, DELETE AS -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with caller queries SELECT statements. -- If an update/insert/delete occurs on the main table, the number of records affected -- should only be based on that table and not what records the triggers may/may not -- select. SET NOCOUNT ON; -- -- Variables Needed for this Trigger -- DECLARE @PACKLIST_ID varchar(15) DECLARE @LINE_NO smallint DECLARE @SHIPPED_QTY decimal(14,4) DECLARE @CUST_ORDER_ID varchar(15) -- -- Determine if this is an INSERT,UPDATE, or DELETE Action -- DECLARE @Action as char(1) DECLARE @Count as int SET @Action = SELECT @Count = COUNT(*) FROM DELETED if @Count > 0 BEGIN SET @Action = SELECT @Count = COUNT(*) FROM INSERTED IF @Count > 0 SET @Action = END if @Action = -- This is a DELETE Record Action -- BEGIN SELECT @PACKLIST_ID =[PACKLIST_ID] ,@LINE_NO = [LINE_NO] FROM DELETED DELETE [dbo].[MyDataTable] WHERE [PACKLIST_ID]=@PACKLIST_ID AND [LINE_NO]=@LINE_NO END Else BEGIN -- -- Table INSERTED is common to both the INSERT, UPDATE trigger -- SELECT @PACKLIST_ID =[PACKLIST_ID] ,@LINE_NO = [LINE_NO] ,@SHIPPED_QTY =[SHIPPED_QTY] ,@CUST_ORDER_ID = [CUST_ORDER_ID] FROM INSERTED if @Action = -- This is an Insert Record Action -- BEGIN INSERT INTO [MyChildTable] (([PACKLIST_ID] ,[LINE_NO] ,[STATUS] VALUES (@PACKLIST_ID ,@LINE_NO , ) END else -- This is an Update Record Action -- BEGIN UPDATE [MyChildTable] SET [PACKLIST_ID] = @PACKLIST_ID ,[LINE_NO] = @LINE_NO ,[STATUS]= WHERE [PACKLIST_ID]=@PACKLIST_ID AND [LINE_NO]=@LINE_NO END END
DROP TRIGGER IF EXISTS AFTER_MYTABLE GO CREATE TRIGGER dbo.AFTER_MYTABLE ON dbo.MYTABLE AFTER INSERT, UPDATE, DELETE AS BEGIN --- FILL THE BEGIN/END SECTION FOR YOUR NEEDS. SET NOCOUNT ON; IF EXISTS(SELECT * FROM INSERTED) AND EXISTS(SELECT * FROM DELETED) BEGIN PRINT ELSE IF EXISTS(SELECT * FROM INSERTED) AND NOT EXISTS(SELECT * FROM DELETED) BEGIN PRINT ELSE IF EXISTS(SELECT * FROM DELETED) AND NOT EXISTS(SELECT * FROM INSERTED) BEGIN PRINT ELSE BEGIN PRINT END
Declare @Type varchar(50)= IF EXISTS (SELECT * FROM inserted) and EXISTS (SELECT * FROM deleted) BEGIN SELECT @Type = END ELSE IF EXISTS(SELECT * FROM inserted) BEGIN SELECT @Type = END ElSE IF EXISTS(SELECT * FROM deleted) BEGIN SELECT @Type = END
ALTER TRIGGER ImportacionesGS ON dbo.Compra AFTER INSERT, UPDATE, DELETE AS BEGIN -- idCompra is PK DECLARE @vIdCompra_Ins INT,@vIdCompra_Del INT SELECT @vIdCompra_Ins=Inserted.idCompra FROM Inserted SELECT @vIdCompra_Del=Deleted.idCompra FROM Deleted IF (@vIdCompra_Ins IS NOT NULL AND @vIdCompra_Del IS NULL) Begin -- Todo Insert End IF (@vIdCompra_Ins IS NOT NULL AND @vIdCompra_Del IS NOT NULL) Begin -- Todo Update End IF (@vIdCompra_Ins IS NULL AND @vIdCompra_Del IS NOT NULL) Begin -- Todo Delete End END
DECLARE @action char(1) IF COLUMNS_UPDATED() > 0 -- insert or update BEGIN IF EXISTS (SELECT * FROM DELETED) -- update SET @action = ELSE SET @action = END ELSE -- delete SET @action =
DECLARE @action CHAR(8) IF COLUMNS_UPDATED() <> 0 -- delete or update? BEGIN IF EXISTS (SELECT * FROM deleted) -- updated cols + old rows means action=update SET @action = ELSE SET @action = END ELSE -- delete BEGIN SET @action = END
declare @action varchar(4) IF EXISTS (SELECT * FROM INSERTED) BEGIN IF EXISTS (SELECT * FROM DELETED) SET @action = ELSE SET @action = END ELSE IF EXISTS (SELECT * FROM DELETED) SET @action = else set @action = --print @action
declare @action_type int; select @action_type = case when i.id is not null and d.id is null then 1 -- insert when i.id is not null and d.id is not null then 2 -- update when i.id is null and d.id is not null then 3 -- delete end from inserted i full join deleted d on d.id = i.id
declare @insCount int declare @delCount int declare @action char(1) select @insCount = count(*) from INSERTED select @delCount = count(*) from DELETED if(@insCount > 0 or @delCount > 0)--if something was actually affected, otherwise do nothing Begin if(@insCount = @delCount) set @action = else if(@insCount > 0) set @action = else set @action = --do stuff here End
use tempdb ; create table dbo.TrigAction (asdf int) ; GO create trigger dbo.TrigActionTrig on dbo.TrigAction for INSERT, UPDATE, DELETE as declare @Action tinyint ; -- Create bit map in @Action using bitwise OR "|" set @Action = (-- 1: INSERT, 2: DELETE, 3: UPDATE, 0: No Rows Modified (select case when exists (select * from inserted) then 1 else 0 end) | (select case when exists (select * from deleted ) then 2 else 0 end)) ; -- 21 <- Binary bit values -- 00 -> No Rows Modified -- 01 -> INSERT -- INSERT and UPDATE have the 1 bit set -- 11 -> UPDATE < -- 10 -> DELETE -- DELETE and UPDATE have the 2 bit set raiserror(N ; if (@Action = 0) raiserror(N ; -- do things for INSERT only if (@Action = 1) raiserror(N ; -- do things for UPDATE only if (@Action = 3) raiserror(N ; -- do things for DELETE only if (@Action = 2) raiserror(N ; -- do things for INSERT or UPDATE if (@Action & 1 = 1) raiserror(N ; -- do things for UPDATE or DELETE if (@Action & 2 = 2) raiserror(N ; -- do things for INSERT or DELETE (unlikely) if (@Action in (1,2)) raiserror(N -- if already "return" on @Action = 0, then use @Action < 3 for INSERT or DELETE ; GO set nocount on; raiserror(N' INSERT 0... insert dbo.TrigAction (asdf) select top 0 object_id from sys.objects; raiserror(N' INSERT 3... insert dbo.TrigAction (asdf) select top 3 object_id from sys.objects; raiserror(N' UPDATE 0... update t set asdf = asdf /1 from dbo.TrigAction t where asdf <> asdf; raiserror(N' UPDATE 3... update t set asdf = asdf /1 from dbo.TrigAction t; raiserror(N' DELETE 0... delete t from dbo.TrigAction t where asdf < 0; raiserror(N' DELETE 3... delete t from dbo.TrigAction t; GO drop table dbo.TrigAction ; GO
$select = " SELECT MAX(id) AS maxid FROM [tablename] LIMIT 1 ";
CREATE TRIGGER [dbo].[WO_EXECUTION_TRIU_RECORD] ON [dbo].[WO_EXECUTION] WITH EXECUTE AS CALLER FOR INSERT, UPDATE AS BEGIN select @vars = [column] from inserted IF UPDATE([column]) BEGIN -- do update action base on @vars END ELSE BEGIN -- do insert action base on @vars END END
CREATE TRIGGER [dbo].[insupddel_yourTable] ON [yourTable] FOR INSERT, UPDATE, DELETE AS IF @@ROWCOUNT = 0 return SET NOCOUNT ON; DECLARE @action nvarchar(10) SELECT @action = CASE WHEN COUNT(i.Id) > COUNT(d.Id) THEN WHEN COUNT(i.Id) < COUNT(d.Id) THEN FROM inserted i FULL JOIN deleted d ON i.Id = d.Id
CREATE TRIGGER [dbo].[insupddel_yourTable] ON [yourTable] FOR INSERT, UPDATE, DELETE AS IF @@ROWCOUNT = 0 return SET NOCOUNT ON; DECLARE @action nvarchar(10), @insCount int = (SELECT COUNT(*) FROM inserted), @delCount int = (SELECT COUNT(*) FROM deleted) SELECT @action = CASE WHEN @insCount > @delCount THEN WHEN @insCount < @delCount THEN
DECLARE @INSERTEDCOUNT INT, @DELETEDCOUNT INT SELECT @INSERTEDCOUNT = COUNT([YourColumnName]) FROM inserted SELECT @DELETEDCOUNT = COUNT([YourColumnName]) FROM deleted
declare @columns_count int = ?? -- number of columns in the table, @columns_updated_count int = 0 -- this is kind of long way to get number of actually updated columns -- from columns_updated() mask, it -- or at least function in the real system with cte_columns as ( select @columns_count as n union all select n - 1 from cte_columns where n > 1 ), cte_bitmasks as ( select n, (n - 1) / 8 + 1 as byte_number, power(2, (n - 1) % 8) as bit_mask from cte_columns ) select @columns_updated_count = count(*) from cte_bitmasks as c where convert(varbinary(1), substring(@columns_updated_mask, c.byte_number, 1)) & c.bit_mask > 0 -- actual check if exists (select * from inserted) if exists (select * from deleted) select @operation = else select @operation = else if exists (select * from deleted) select @operation = else if @columns_updated_count = @columns_count select @operation = else if @columns_updated_count > 0 select @operation = else select @operation =
Select Case When @PaidThisMonth < @OwedPast Then @PaidThisMonth Else @OwedPast End PaidForPast
CREATE FUNCTION Minimum (@Param1 Integer, @Param2 Integer) Returns Table As Return(Select Case When @Param1 < @Param2 Then @Param1 Else @Param2 End MinValue)
Select MinValue as PaidforPast From dbo.Minimum(@PaidThisMonth, @OwedPast)
SELECT IIF(first>second, second, first) the_minimal FROM table
SELECT PaidForPast=(SELECT MIN(x) FROM (VALUES (PaidThisMonth),(OwedPast)) AS value(x))
select max(x) from ( select 1 as select 4 as select 3 as select 2 as ) a
@answer = select Max(x) from ( select @NumberA as select @NumberB as select @NumberC as select ( Select Max(score) from TopScores ) as ) a
SELECT GREATEST(A.date0, B.date0) AS date0, LEAST(A.date1, B.date1, B.date2) AS date1 FROM A, B WHERE B.x = A.x
USE AdventureWorks; GO SELECT ProductNumber, Name, CASE WHEN ListPrice = 0 THEN WHEN ListPrice < 50 THEN WHEN ListPrice >= 50 and ListPrice < 250 THEN WHEN ListPrice >= 250 and ListPrice < 1000 THEN ELSE END FROM Production.Product ORDER BY ProductNumber ; GO
CREATE PROCEDURE GetMinSpeed() AS BEGIN CREATE TABLE ' ' INSERT INTO INSERT INTO INSERT INTO SELECT MIN(SPEED) FROM DROP TABLE END
CREATE FUNCTION dbo.MinDate(@Date1 datetime = Null, @Date2 datetime = Null, @Date3 datetime = Null, @Date4 datetime = Null, @Date5 datetime = Null) RETURNS Datetime AS BEGIN --USAGE select dbo.MinDate( DECLARE @Output datetime; WITH Datelist_CTE(DT) AS ( SELECT @Date1 AS DT WHERE @Date1 is not NULL UNION SELECT @Date2 AS DT WHERE @Date2 is not NULL UNION SELECT @Date3 AS DT WHERE @Date3 is not NULL UNION SELECT @Date4 AS DT WHERE @Date4 is not NULL UNION SELECT @Date5 AS DT WHERE @Date5 is not NULL ) Select @Output=Min(DT) FROM Datelist_CTE RETURN @Output END
DECLARE @a INT, @b INT, @c INT = 0 WHILE @c < 100 BEGIN SET @c += 1 SET @a = ROUND(RAND()*100,0)-50 SET @b = ROUND(RAND()*100,0)-50 SELECT @a AS a, @b AS b, @a - ( ABS(@a-@b) + (@a-@b) ) / 2 AS MINab, @a + ( ABS(@b-@a) + (@b-@a) ) / 2 AS MAXab, CASE WHEN (@a <= @b AND @a = @a - ( ABS(@a-@b) + (@a-@b) ) / 2) OR (@a >= @b AND @a = @a + ( ABS(@b-@a) + (@b-@a) ) / 2) THEN END
userTypedTags(userID,commaSeparatedTags) tags(tagID,name)
CREATE FUNCTION dbo.Split (@sep char(1), @s varchar(512)) RETURNS table AS RETURN ( WITH Pieces(pn, start, stop) AS ( SELECT 1, 1, CHARINDEX(@sep, @s) UNION ALL SELECT pn + 1, stop + 1, CHARINDEX(@sep, @s, stop + 1) FROM Pieces WHERE stop > 0 ) SELECT pn, SUBSTRING(@s, start, CASE WHEN stop > 0 THEN stop-start ELSE 512 END) AS s FROM Pieces )
create FUNCTION [dbo].[Split] (@sep VARCHAR(32), @s VARCHAR(MAX)) RETURNS TABLE AS RETURN ( SELECT r.value( FROM (SELECT CONVERT(XML, N CROSS APPLY x.valxml.nodes( )
----------- |I | |---------| |hate | |---------| |bunnies | -----------
CREATE FUNCTION [dbo].[Split] (@sep VARCHAR(32), @s VARCHAR(MAX)) RETURNS TABLE AS RETURN ( SELECT r.value( FROM (SELECT CONVERT(XML, N CROSS APPLY x.valxml.nodes( )
create function [dbo].[Split] ( @string nvarchar(4000), @delimiter nvarchar(10) ) returns @table table ( [Value] nvarchar(4000) ) begin declare @nextString nvarchar(4000) declare @pos int, @nextPos int set @nextString = set @string = @string + @delimiter set @pos = charindex(@delimiter, @string) set @nextPos = 1 while (@pos <> 0) begin set @nextString = substring(@string, 1, @pos - 1) insert into @table ( [Value] ) values ( @nextString ) set @string = substring(@string, @pos + len(@delimiter), len(@string)) set @nextPos = @pos set @pos = charindex(@delimiter, @string) end return end
with testTable AS ( SELECT 1 AS Id, N SELECT 2, N SELECT 3, N SELECT 4, N ) SELECT display_term, COUNT(*) As Cnt FROM testTable CROSS APPLY sys.dm_fts_parser( GROUP BY display_term HAVING COUNT(*) > 1 ORDER BY Cnt DESC
display_term Cnt ------------------------------ ----------- the 3 brown 2 lorry 2 sea 2
create FUNCTION dbo.fn_Split2 (@sep nvarchar(10), @s nvarchar(4000)) RETURNS table AS RETURN ( WITH Pieces(pn, start, stop) AS ( SELECT 1, 1, CHARINDEX(@sep, @s) UNION ALL SELECT pn + 1, stop + (datalength(@sep)/2), CHARINDEX(@sep, @s, stop + (datalength(@sep)/2)) FROM Pieces WHERE stop > 0 ) SELECT pn, SUBSTRING(@s, start, CASE WHEN stop > 0 THEN stop-start ELSE 4000 END) AS s FROM Pieces )
CREATE FUNCTION dbo.Split(@data nvarchar(4000), @delimiter nvarchar(100)) RETURNS @result table (Id int identity(1,1), Data nvarchar(4000)) AS BEGIN DECLARE @pos INT DECLARE @start INT DECLARE @len INT DECLARE @end INT SET @len = LEN( SET @end = LEN(@data) + 1 SET @start = 1 SET @pos = 0 WHILE (@pos < @end) BEGIN SET @pos = CHARINDEX(@delimiter, @data, @start) IF (@pos = 0) SET @pos = @end INSERT @result (data) SELECT SUBSTRING(@data, @start, @pos - @start) SET @start = @pos + @len END RETURN END
using System; using System.Collections; using System.Data.SqlTypes; using System.Text.RegularExpressions; using Microsoft.SqlServer.Server; public class UDF { [SqlFunction(FillRowMethodName="FillRow")] public static IEnumerable RegexSplit(SqlString s, SqlString delimiter) { return Regex.Split(s.Value, delimiter.Value); } public static void FillRow(object row, out SqlString str) { str = new SqlString((string) row); } }
ALTER Function [dbo].[SplitStr] ( @txt text ) Returns @tmp Table ( value varchar(127) ) as BEGIN declare @str varchar(8000) , @Beg int , @last int , @size int set @size=datalength(@txt) set @Beg=1 set @str=substring(@txt,@Beg,8000) IF len(@str)<8000 set @Beg=@size ELSE BEGIN set @last=charindex( set @str=substring(@txt,@Beg,8000-@last) set @Beg=@Beg+8000-@last+1 END declare @workingString varchar(25) , @stringindex int while @Beg<=@size Begin WHILE LEN(@str) > 0 BEGIN SELECT @StringIndex = CHARINDEX( SELECT @workingString = CASE WHEN @StringIndex > 0 THEN SUBSTRING(@str, 1, @StringIndex-1) ELSE @str END INSERT INTO @tmp(value) VALUES (cast(rtrim(ltrim(@workingString)) as varchar(127))) SELECT @str = CASE WHEN CHARINDEX( ELSE END END set @str=substring(@txt,@Beg,8000) if @Beg=@size set @Beg=@Beg+1 else IF len(@str)<8000 set @Beg=@size ELSE BEGIN set @last=charindex( set @str=substring(@txt,@Beg,8000-@last) set @Beg=@Beg+8000-@last+1 END END return END
CREATE FUNCTION [dbo].Split ( @sep VARCHAR(32), @s VARCHAR(MAX) ) RETURNS @result TABLE ( Id INT NULL ) AS BEGIN DECLARE @xml XML SET @XML = N INSERT INTO @result(Id) SELECT DISTINCT r.value( FROM @xml.nodes( RETURN END
create function [dbo].[Split](@string varchar(max), @separator varchar(10)) returns @splited table ( stringPart varchar(max) ) with execute as caller as begin declare @stringPart varchar(max); set @stringPart = while charindex(@separator, @string) > 0 begin set @stringPart = substring(@string, 0, charindex(@separator, @string)); insert into @splited (stringPart) values (@stringPart); set @string = substring(@string, charindex(@separator, @string) + len(@separator), len(@string) + 1); end return; end go
declare @example varchar(max); set @example = select * from [dbo].[Split](@example,
SELECT age FROM person ORDER BY age ASC LIMIT 1 OFFSET 2
SELECT TOP 3 WITH TIES * FROM person ORDER BY age ASC
mysql> SELECT CONVERT_TZ( +-----------------------------------------------------------------+ | CONVERT_TZ( +-----------------------------------------------------------------+ | 2008-04-01 05:00:00 | +-----------------------------------------------------------------+
DECLARE @StartDate DATETIME DECLARE @EndDate DATETIME SET @StartDate = SET @EndDate = SELECT (DATEDIFF(dd, @StartDate, @EndDate) + 1) -(DATEDIFF(wk, @StartDate, @EndDate) * 2) -(CASE WHEN DATENAME(dw, @StartDate) = -(CASE WHEN DATENAME(dw, @EndDate) =
--Changing current database to the Master database allows function to be shared by everyone. USE MASTER GO --If the function already exists, drop it. IF EXISTS ( SELECT * FROM dbo.SYSOBJECTS WHERE ID = OBJECT_ID(N AND XType IN (N ) DROP FUNCTION [dbo].[fn_WorkDays] GO CREATE FUNCTION dbo.fn_WorkDays --Presets --Define the input parameters (OK if reversed by mistake). ( @StartDate DATETIME, @EndDate DATETIME = NULL --@EndDate replaced by @StartDate when DEFAULTed ) --Define the output data type. RETURNS INT AS --Calculate the RETURN of the function. BEGIN --Declare local variables --Temporarily holds @EndDate during date reversal. DECLARE @Swap DATETIME --If the Start Date is null, return a NULL and exit. IF @StartDate IS NULL RETURN NULL --If the End Date is null, populate with Start Date value so will have two dates (required by DATEDIFF below). IF @EndDate IS NULL SELECT @EndDate = @StartDate --Strip the time element from both dates (just to be safe) by converting to whole days and back to a date. --Usually faster than CONVERT. --0 is a date (01/01/1900 00:00:00.000) SELECT @StartDate = DATEADD(dd,DATEDIFF(dd,0,@StartDate), 0), @EndDate = DATEADD(dd,DATEDIFF(dd,0,@EndDate) , 0) --If the inputs are in the wrong order, reverse them. IF @StartDate > @EndDate SELECT @Swap = @EndDate, @EndDate = @StartDate, @StartDate = @Swap --Calculate and return the number of workdays using the input parameters. --This is the meat of the function. --This is really just one formula with a couple of parts that are listed on separate lines for documentation purposes. RETURN ( SELECT --Start with total number of days including weekends (DATEDIFF(dd,@StartDate, @EndDate)+1) --Subtact 2 days for each full weekend -(DATEDIFF(wk,@StartDate, @EndDate)*2) --If StartDate is a Sunday, Subtract 1 -(CASE WHEN DATENAME(dw, @StartDate) = THEN 1 ELSE 0 END) --If EndDate is a Saturday, Subtract 1 -(CASE WHEN DATENAME(dw, @EndDate) = THEN 1 ELSE 0 END) ) END GO
--Changing current database to the Master database allows function to be shared by everyone. USE MASTER GO --If the function already exists, drop it. IF EXISTS ( SELECT * FROM dbo.SYSOBJECTS WHERE ID = OBJECT_ID(N AND XType IN (N ) DROP FUNCTION [dbo].[fn_WorkDays] GO CREATE FUNCTION dbo.fn_WorkDays --Presets --Define the input parameters (OK if reversed by mistake). ( @StartDate DATETIME, @EndDate DATETIME = NULL --@EndDate replaced by @StartDate when DEFAULTed ) --Define the output data type. RETURNS INT AS --Calculate the RETURN of the function. BEGIN --Declare local variables --Temporarily holds @EndDate during date reversal. DECLARE @Swap DATETIME --If the Start Date is null, return a NULL and exit. IF @StartDate IS NULL RETURN NULL --If the End Date is null, populate with Start Date value so will have two dates (required by DATEDIFF below). IF @EndDate IS NULL SELECT @EndDate = @StartDate --Strip the time element from both dates (just to be safe) by converting to whole days and back to a date. --Usually faster than CONVERT. --0 is a date (01/01/1900 00:00:00.000) SELECT @StartDate = DATEADD(dd,DATEDIFF(dd,0,@StartDate), 0), @EndDate = DATEADD(dd,DATEDIFF(dd,0,@EndDate) , 0) --If the inputs are in the wrong order, reverse them. IF @StartDate > @EndDate SELECT @Swap = @EndDate, @EndDate = @StartDate, @StartDate = @Swap --Calculate and return the number of workdays using the input parameters. --This is the meat of the function. --This is really just one formula with a couple of parts that are listed on separate lines for documentation purposes. RETURN ( SELECT --Start with total number of days including weekends (DATEDIFF(dd,@StartDate, @EndDate)+1) --Subtact 2 days for each full weekend -(DATEDIFF(wk,@StartDate, @EndDate)*2) --If StartDate is a Sunday, Subtract 1 -(CASE WHEN DATENAME(dw, @StartDate) = THEN 1 ELSE 0 END) --If EndDate is a Saturday, Subtract 1 -(CASE WHEN DATENAME(dw, @EndDate) = THEN 1 ELSE 0 END) --Subtract all holidays -(Select Count(*) from [DB04\DB04].[Gateway].[dbo].[tblHolidays] where [HolDate] between @StartDate and @EndDate ) ) END GO -- Test Script /* declare @EndDate datetime= dateadd(m,2,getdate()) print @EndDate select [Master].[dbo].[fn_WorkDays] (getdate(), @EndDate) */
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE FUNCTION BDATEDIFF ( @startdate as DATETIME, @enddate as DATETIME ) RETURNS INT AS BEGIN DECLARE @res int SET @res = (DATEDIFF(dd, @startdate, @enddate) + 1) -(DATEDIFF(wk, @startdate, @enddate) * 2) -(CASE WHEN DATEPART(dw, @startdate) = 1 THEN 1 ELSE 0 END) -(CASE WHEN DATEPART(dw, @enddate) = 7 THEN 1 ELSE 0 END) RETURN @res END GO
CREATE FUNCTION [dbo].[fn_GetTotalWorkingDaysUsingLoop] (@DateFrom DATE, @DateTo DATE ) RETURNS INT AS BEGIN DECLARE @TotWorkingDays INT= 0; WHILE @DateFrom <= @DateTo BEGIN IF DATENAME(WEEKDAY, @DateFrom) IN( BEGIN SET @TotWorkingDays = @TotWorkingDays + 1; END; SET @DateFrom = DATEADD(DAY, 1, @DateFrom); END; RETURN @TotWorkingDays; END; GO
select @Result = (..CMS if (@Result < 0) select @Result = 0 RETURN @Result
CREATE TABLE [dbo].[Holiday]( [Id] [int] IDENTITY(1,1) NOT NULL, [Name] [nvarchar](50) NULL, [Date] [datetime] NOT NULL)
CREATE TABLE [dbo].[Plan_Phase]( [Id] [int] IDENTITY(1,1) NOT NULL, [Id_Plan] [int] NOT NULL, [Id_Phase] [int] NOT NULL, [Start_Date] [datetime] NULL, [End_Date] [datetime] NULL, [Work_Days] [int] NULL)
SELECT Start_Date, End_Date, (DATEDIFF(dd, Start_Date, End_Date) + 1) -(DATEDIFF(wk, Start_Date, End_Date) * 2) -(SELECT COUNT(*) From Holiday Where Date >= Start_Date AND Date <= End_Date) -(CASE WHEN DATENAME(dw, Start_Date) = -(CASE WHEN DATENAME(dw, End_Date) = -(CASE WHEN (SELECT COUNT(*) From Holiday Where Start_Date = Date) > 0 THEN 1 ELSE 0 END) -(CASE WHEN (SELECT COUNT(*) From Holiday Where End_Date = Date) > 0 THEN 1 ELSE 0 END) AS Work_Days from Plan_Phase
DECLARE @TotalDays INT,@WorkDays INT DECLARE @ReducedDayswithEndDate INT DECLARE @WeekPart INT DECLARE @DatePart INT SET @TotalDays= DATEDIFF(day, @StartDate, @EndDate) +1 SELECT @ReducedDayswithEndDate = CASE DATENAME(weekday, @EndDate) WHEN WHEN ELSE 0 END SET @TotalDays=@TotalDays-@ReducedDayswithEndDate SET @WeekPart=@TotalDays/7; SET @DatePart=@TotalDays%7; SET @WorkDays=(@WeekPart*5)+@DatePart RETURN @WorkDays
DECLARE @RAWDAYS INT SELECT @RAWDAYS = DATEDIFF(day, @StartDate, @EndDate )--+1 -( 2 * DATEDIFF( week, @StartDate, @EndDate ) ) + CASE WHEN DATENAME(dw, @StartDate) = - CASE WHEN DATENAME(dw, @EndDate) = SELECT @RAWDAYS - COUNT(*) FROM HOLIDAY NumberOfBusinessDays WHERE [Holiday_Date] BETWEEN @StartDate+1 AND @EndDate
DECLARE @StartDate date = @EndDate date = SELECT COUNT(*) As NumberOfWeekDays FROM dbo.Calendar WHERE CalendarDate BETWEEN @StartDate AND @EndDate AND IsWorkDay = 1;
DECLARE @StartDate datetime = @EndDate datetime = SELECT SUM(CASE WHEN DATEPART(dw, DATEADD(dd, Number-1, @StartDate)) BETWEEN 2 AND 6 THEN 1 ELSE 0 END) As NumberOfWeekDays FROM dbo.Numbers WHERE Number <= DATEDIFF(dd, @StartDate, @EndDate) + 1 -- Number table starts at 1, we want a 0 base
datediff(day, <start>, <end>) + 1 - datediff(week, <start>, <end>) * 2 + case when datepart(weekday, <start>) = 8 - @@datefirst then -1 else 0 end + case when datepart(weekday, <end>) = (13 - @@datefirst) % 7 + 1 then -1 else 0 end
datediff(day, <start>, <end>) + 1 - datediff(week, <start>, <end>) * 2 + case when datepart(weekday, dateadd(day, @@datefirst, <start>)) = 1 then -1 else 0 end + case when datepart(weekday, dateadd(day, @@datefirst, <end>)) = 7 then -1 else 0 end
DECLARE @StartDate datetime,@EndDate datetime select @StartDate= DECLARE @TotalDays INT,@WorkDays INT DECLARE @ReducedDayswithEndDate INT DECLARE @WeekPart INT DECLARE @DatePart INT SET @TotalDays= DATEDIFF(day, @StartDate, @EndDate) +1 SELECT @ReducedDayswithEndDate = CASE DATENAME(weekday, @EndDate) WHEN WHEN ELSE 0 END SET @TotalDays=@TotalDays-@ReducedDayswithEndDate SET @WeekPart=@TotalDays/7; SET @DatePart=@TotalDays%7; SET @WorkDays=(@WeekPart*5)+@DatePart SELECT @WorkDays
CREATE FUNCTION x ( @StartDate DATETIME, @EndDate DATETIME ) RETURNS INT AS BEGIN DECLARE @Teller INT SET @StartDate = DATEADD(dd,1,@StartDate) SET @Teller = 0 IF DATEDIFF(dd,@StartDate,@EndDate) <= 0 BEGIN SET @Teller = 0 END ELSE BEGIN WHILE DATEDIFF(dd,@StartDate,@EndDate) >= 0 BEGIN IF DATEPART(dw,@StartDate) < 6 BEGIN SET @Teller = @Teller + 1 END SET @StartDate = DATEADD(dd,1,@StartDate) END END RETURN @Teller END
Create FUNCTION [dbo].[fnGetBusinessDays] ( @PromiseDate date, @ReceivedDate date ) RETURNS integer AS BEGIN DECLARE @days integer SELECT @days = Case when @PromiseDate > @ReceivedDate Then DATEDIFF(d,@PromiseDate,@ReceivedDate) + ABS(DATEDIFF(wk,@PromiseDate,@ReceivedDate)) * 2 + CASE WHEN DATENAME(dw, @PromiseDate) <> WHEN DATENAME(dw, @PromiseDate) = ELSE 0 END + (Select COUNT(*) FROM CompanyHolidays WHERE HolidayDate BETWEEN @ReceivedDate AND @PromiseDate AND DATENAME(dw, HolidayDate) <> Else DATEDIFF(d,@PromiseDate,@ReceivedDate) - ABS(DATEDIFF(wk,@PromiseDate,@ReceivedDate)) * 2 - CASE WHEN DATENAME(dw, @PromiseDate) <> WHEN DATENAME(dw, @PromiseDate) = ELSE 0 END - (Select COUNT(*) FROM CompanyHolidays WHERE HolidayDate BETWEEN @PromiseDate and @ReceivedDate AND DATENAME(dw, HolidayDate) <> End RETURN (@days) END
CREATE TABLE Calendar ( dt SMALLDATETIME PRIMARY KEY, IsWorkDay BIT ); --fill the rows with normal days, weekends and holidays. create function AddWorkingDays (@initialDate smalldatetime, @numberOfDays int) returns smalldatetime as begin declare @result smalldatetime set @result = ( select t.dt from ( select dt, ROW_NUMBER() over (order by dt) as daysAhead from calendar where dt > @initialDate and IsWorkDay = 1 ) t where t.daysAhead = @numberOfDays ) return @result end
SELECT DATEDIFF(day, @StartDate, @EndDate) - DATEDIFF(week, @StartDate, @EndDate) - DATEDIFF(week, DATEADD(day, 1, @StartDate), DATEADD(day, 1, @EndDate))
CREATE FUNCTION [dbo].[fnGetCountWorkingBusinessDays] ( @StartDate as DATETIME, @EndDate as DATETIME ) RETURNS INT AS BEGIN DECLARE @res int SET @StartDate = CASE WHEN DATENAME(dw, @StartDate) = WHEN DATENAME(dw, @StartDate) = ELSE @StartDate END SET @EndDate = CASE WHEN DATENAME(dw, @EndDate) = WHEN DATENAME(dw, @EndDate) = ELSE @EndDate END SET @res = (DATEDIFF(hour, @StartDate, @EndDate) / 24) - (DATEDIFF(wk, @StartDate, @EndDate) * 2) SET @res = CASE WHEN @res < 0 THEN 0 ELSE @res END RETURN @res END GO
CREATE FUNCTION dbo.fn_WorkDays(@StartDate DATETIME, @EndDate DATETIME= NULL ) RETURNS INT AS BEGIN DECLARE @Days int SET @Days = 0 IF @EndDate = NULL SET @EndDate = EOMONTH(@StartDate) --last date of the month WHILE DATEDIFF(dd,@StartDate,@EndDate) >= 0 BEGIN IF DATENAME(dw, @StartDate) <> and DATENAME(dw, @StartDate) <> and Not ((Day(@StartDate) = 1 And Month(@StartDate) = 1)) --New Year and Not ((Day(@StartDate) = 4 And Month(@StartDate) = 7)) --Independence Day. BEGIN SET @Days = @Days + 1 END SET @StartDate = DATEADD(dd,1,@StartDate) END RETURN @Days END
select dbo.fn_WorkDays(StartDate, EndDate) from table1
Create Function dbo.DateDiff_WeekDays ( @StartDate DateTime, @EndDate DateTime ) Returns Int As Begin Declare @Result Int = 0 While @StartDate <= @EndDate Begin If DateName(DW, @StartDate) not in ( Begin Set @Result = @Result +1 End Set @StartDate = DateAdd(Day, +1, @StartDate) End Return @Result
SET DATEFIRST 1 SELECT ,(DATEDIFF(DD, [StartDate], [EndDate])) -(DATEDIFF(wk, [StartDate], [EndDate])) -(DATEDIFF(wk, DATEADD(dd,-@@DATEFIRST,[StartDate]), DATEADD(dd,-@@DATEFIRST,[EndDate]))) AS [WorkingDays] FROM
declare @date1 as datetime = declare @date2 as datetime = select sum(case when DATENAME(DW,currentDate) not in ( from dbo.GetNums(0,DATEDIFF(day,@date1, @date2)-1) as Num cross apply (select DATEADD(day,n,@date1)) as Dates(currentDate)
DECLARE @StartDate DATETIME DECLARE @EndDate DATETIME SET @StartDate = SET @EndDate = SELECT DATEDIFF(Day, @StartDate, @EndDate) -- Total Days - (DATEDIFF(Day, 0, @EndDate)/7 - DATEDIFF(Day, 0, @StartDate)/7) -- Sundays - (DATEDIFF(Day, -1, @EndDate)/7 - DATEDIFF(Day, -1, @StartDate)/7) -- Saturdays
CREATE NONCLUSTERED INDEX MyINDX on Table1 ( MostSelective, SecondMost, Least )
Cols 1 2 3 ------------- | | 1 | | | A |---| | | | 2 | | |---|---| | | | | | | | 1 | 9 | | B | | | | |---| | | | 2 | | | |---| | | | 3 | | |---|---| |
CREATE TABLE Table1(MostSelective char(800), SecondMost TINYINT, Least CHAR(1), Filler CHAR(4000) null); CREATE TABLE Table2(MostSelective char(800), SecondMost TINYINT, Least CHAR(1), Filler CHAR(4000) null); CREATE NONCLUSTERED INDEX MyINDX on Table1(MostSelective,SecondMost,Least); CREATE NONCLUSTERED INDEX MyINDX2 on Table2(Least,SecondMost,MostSelective); INSERT INTO Table1 (MostSelective, SecondMost, Least) output inserted.* into Table2 SELECT TOP 26 REPLICATE(CHAR(number + 65),800), number/5, FROM master..spt_values WHERE type = ORDER BY number;
SELECT * FROM Table1 WHERE MostSelective = REPLICATE( AND SecondMost = 3 AND Least = SELECT * FROM Table2 WHERE MostSelective = REPLICATE( AND SecondMost = 3 AND Least =
SELECT * ... WHERE MostSelective = SELECT * ...WHERE Least =
SELECT MostSelective, SecondMost, Least FROM Table2 WHERE Least = ORDER BY SecondMost, MostSelective
select count(distinct dNum) from myDB.dbo.AQ where A_ID in (SELECT DISTINCT TOP (0.1) PERCENT A_ID, COUNT(DISTINCT dNum) AS ud FROM myDB.dbo.AQ WHERE M > 1 and B = 0 GROUP BY A_ID ORDER BY ud DESC)
Only one expression can be specified in the select list when the subquery is not introduced with EXISTS.`
SELECT * From ThisTable WHERE ThisColumn IN (SELECT ThatColumn FROM ThatTable)
select count(distinct dNum) from myDB.dbo.AQ where A_ID in (SELECT DISTINCT TOP (0.1) PERCENT A_ID FROM myDB.dbo.AQ WHERE M > 1 and B = 0 GROUP BY A_ID ORDER BY COUNT(DISTINCT dNum) DESC)
select * from table1 where Date in (select * from Dates) -- Wrong select * from table1 where Date in (select Column1,Column2 from Dates) -- Wrong select * from table1 where Date in (select Column1 from Dates) -- OK
SELECT count(distinct dNum) FROM myDB.dbo.AQ WHERE A_ID in ( SELECT A_ID FROM (SELECT DISTINCT TOP (0.1) PERCENT A_ID, COUNT(DISTINCT dNum) AS ud FROM myDB.dbo.AQ WHERE M > 1 and B = 0 GROUP BY A_ID ORDER BY ud DESC ) a )
IF (NOT EXISTS (SELECT * FROM sys.schemas WHERE name = BEGIN EXEC ( END
declare @sql varchar(8000), @table varchar(1000), @oldschema varchar(1000), @newschema varchar(1000) set @oldschema = set @newschema = while exists(select * from sys.tables where schema_name(schema_id) = @oldschema) begin select @table = name from sys.tables where object_id in(select min(object_id) from sys.tables where schema_name(schema_id) = @oldschema) set @sql = exec(@sql) end
ALTER SCHEMA NewSchema TRANSFER [OldSchema].[TableName]
USE (yourservername) ALTER SCHEMA exe TRANSFER dbo.Employees
CREATE SCHEMA exe AUTHORIZATION [dbo] GO ALTER SCHEMA exe TRANSFER dbo.Employees GO
-- Brain Fuck interpreter in SQL DECLARE @Code VARCHAR(MAX) = DECLARE @Input VARCHAR(MAX) = -- Creates a "BrainFuck" DataBase. -- CREATE DATABASE BrainFuck; -- Creates the Source code table DECLARE @CodeTable TABLE ( [Id] INT IDENTITY(1,1) PRIMARY KEY NOT NULL, [Command] CHAR(1) NOT NULL ); -- Populate the source code into CodeTable DECLARE @CodeLen INT = LEN(@Code); DECLARE @CodePos INT = 0; DECLARE @CodeChar CHAR(1); WHILE @CodePos < @CodeLen BEGIN SET @CodePos = @CodePos + 1; SET @CodeChar = SUBSTRING(@Code, @CodePos, 1); IF @CodeChar IN ( INSERT INTO @CodeTable ([Command]) VALUES (@CodeChar) END -- Creates the Input table DECLARE @InputTable TABLE ( [Id] INT IDENTITY(1,1) PRIMARY KEY NOT NULL, [Char] CHAR(1) NOT NULL ); -- Populate the input text into InputTable DECLARE @InputLen INT = LEN(@Input); DECLARE @InputPos INT = 0; WHILE @InputPos < @InputLen BEGIN SET @InputPos = @InputPos + 1; INSERT INTO @InputTable ([Char]) VALUES (SUBSTRING(@Input, @InputPos, 1)) END -- Creates the Output table DECLARE @OutputTable TABLE ( [Id] INT IDENTITY(1,1) PRIMARY KEY NOT NULL, [Char] CHAR(1) NOT NULL ); -- Creates the Buffer table DECLARE @BufferTable TABLE ( [Id] INT IDENTITY(1,1) PRIMARY KEY NOT NULL, [Memory] INT DEFAULT 0 NOT NULL ); INSERT INTO @BufferTable ([Memory]) VALUES (0); -- Initialization of temporary variables DECLARE @CodeLength INT = (SELECT COUNT(*) FROM @CodeTable); DECLARE @CodeIndex INT = 0; DECLARE @Pointer INT = 1; DECLARE @InputIndex INT = 0; DECLARE @Command CHAR(1); DECLARE @Depth INT; -- Main calculation cycle WHILE @CodeIndex < @CodeLength BEGIN -- Read the next command. SET @CodeIndex = @CodeIndex + 1; SET @Command = (SELECT [Command] FROM @CodeTable WHERE [Id] = @CodeIndex); -- Increment the pointer. IF @Command = BEGIN SET @Pointer = @Pointer + 1; IF (SELECT [Id] FROM @BufferTable WHERE [Id] = @Pointer) IS NULL INSERT INTO @BufferTable ([Memory]) VALUES (0); END -- Decrement the pointer. ELSE IF @Command = SET @Pointer = @Pointer - 1; -- Increment the byte at the pointer. ELSE IF @Command = UPDATE @BufferTable SET [Memory] = [Memory] + 1 WHERE [Id] = @Pointer; -- Decrement the byte at the pointer. ELSE IF @Command = UPDATE @BufferTable SET [Memory] = [Memory] - 1 WHERE [Id] = @Pointer; -- Output the byte at the pointer. ELSE IF @Command = INSERT INTO @OutputTable ([Char]) (SELECT CHAR([Memory]) FROM @BufferTable WHERE [Id] = @Pointer); -- Input a byte and store it in the byte at the pointer. ELSE IF @Command = BEGIN SET @InputIndex = @InputIndex + 1; UPDATE @BufferTable SET [Memory] = COALESCE((SELECT ASCII([Char]) FROM @InputTable WHERE [Id] = @InputIndex), 0) WHERE [Id] = @Pointer; END -- Jump forward past the matching ] if the byte at the pointer is zero. ELSE IF @Command = BEGIN SET @Depth = 1; WHILE @Depth > 0 BEGIN SET @CodeIndex = @CodeIndex + 1; SET @Command = (SELECT [Command] FROM @CodeTable WHERE [Id] = @CodeIndex); IF @Command = ELSE IF @Command = END END -- Jump backward to the matching [ unless the byte at the pointer is zero. ELSE IF @Command = BEGIN SET @Depth = 1; WHILE @Depth > 0 BEGIN SET @CodeIndex = @CodeIndex - 1; SET @Command = (SELECT [Command] FROM @CodeTable WHERE [Id] = @CodeIndex); IF @Command = ELSE IF @Command = END END END; -- Collects and prints the output DECLARE @Output VARCHAR(MAX); SELECT @Output = COALESCE(@Output, FROM @OutputTable; PRINT @Output; Go
Select Grade, (Count(Grade)* 100 / (Select Count(*) From MyTable)) as Score From MyTable Group By Grade
select Grade, count(*) * 100.0 / sum(count(*)) over() from MyTable group by Grade
select Rate, count(*) * 100.0 / (select count(*) from MyTable) from MyTable group by Rate;
with t(Rate, RateCount) as ( select Rate, count(*) from MyTable group by Rate ) select Rate, RateCount * 100.0/(select sum(RateCount) from t) from t;
select Grade, 100. * count(*) / sum(count(*)) over () from table group by Grade;
WITH Tot(Total) ( SELECT COUNT(*) FROM table ) SELECT Grade, COUNT(*) / Total * 100 --, CONVERT(VARCHAR, COUNT(*) / Total * 100) + --, CONVERT(VARCHAR, ROUND(COUNT(*) / Total * 100, -2)) + FROM table GROUP BY Grade
Select Grade, CountofGrade / sum(CountofGrade) *100 from ( Select Grade, Count(*) as CountofGrade From Grades Group By Grade) as sub Group by Grade
ROUND(CAST((Numerator * 100.0 / Denominator) AS FLOAT), 2) AS Percentage
SELECT grade, ROUND(100.0 * grade_sum / (SELECT COUNT(*) FROM grades), 2) AS pct_of_grades FROM (SELECT grade, COUNT(*) AS grade_sum FROM grades GROUP BY grade ) ORDER BY grade;
grade pct_of_grades CHAR(1) DECIMAL(32,2) A 32.26 B 16.13 C 12.90 D 12.90 E 9.68 F 16.13
CREATE TABLE grades ( id VARCHAR(10) NOT NULL, grade CHAR(1) NOT NULL CHECK (grade MATCHES ); INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES( INSERT INTO grades VALUES(
Select Grade, Count(ID) * 100.0 / ((Select Count(ID) From MyTable) * 1.0) From MyTable Group By Grade
SELECT Grade, GradeCount / SUM(GradeCount) FROM (SELECT Grade, COUNT(*) As GradeCount FROM myTable GROUP BY Grade) Grades
declare @countOfAll decimal(18, 4) select @countOfAll = COUNT(*) from Grades select Grade, COUNT(*) / @countOfAll * 100 from Grades group by Grade
SELECT Grade, COUNT(*) / TotalRows FROM (SELECT Grade, COUNT(*) As TotalRows FROM myTable) Grades GROUP BY Grade, TotalRows
SELECT Grade, SUM(PartialCount) FROM (SELECT Grade, 1/COUNT(*) AS PartialCount FROM myTable) Grades GROUP BY Grade
SELECT Grade, GradeCount / SUM(GradeCount) FROM (SELECT Grade, COUNT(*) As GradeCount FROM myTable GROUP BY Grade) Grades
SELECT COUNT(*) FROM myTable INTO :TotalCount; FOR SELECT Grade, COUNT(*) FROM myTable GROUP BY Grade INTO :Grade, :GradeCount DO BEGIN Percent = :GradeCount / :TotalCount; SUSPEND; END
case when FC.CourseId is not null then 1 else 0 end as IsCoursedBased
case when FC.CourseId is not null then cast(1 as bit) else cast(0 as bit) end as IsCoursedBased
cast ( case when FC.CourseId is not null then 1 else 0 end as bit)
DECLARE @True bit, @False bit; SELECT @True = 1, @False = 0; --can be combined with declare in SQL 2008 SELECT case when FC.CourseId is not null then @True ELSE @False END AS ...
DECLARE VIEW MyView AS SELECT case when FC.CourseId is not null then cast(1 as bit) else cast(0 as bit) end as IsCoursedBased ... SELECT ICourseBased FROM MyView
ISNULL( CAST ( CASE WHEN FC.CourseId IS NOT NULL THEN 1 ELSE 0 END AS BIT) ,0) AS IsCoursedBased
SELECT ..., IsCoursedBased = CAST( CASE WHEN fc.CourseId is not null THEN 1 ELSE 0 END AS BIT ) FROM fc
Msg 443, Level 16, State 14, Procedure ..., Line ... Invalid use of a side-effecting operator
create function dbo.throwError() returns nvarchar(max) as begin return cast( end
Msg 245, Level 16, State 1, Line 1 Conversion failed when converting the varchar value
CREATE FUNCTION [dbo].[Throw] ( @error NVARCHAR(MAX) ) RETURNS BIT AS BEGIN RETURN CAST(@error AS INT) END GO DECLARE @error NVARCHAR(MAX) DECLARE @bit BIT IF `error condition` SET @error = ELSE SET @error = SET @bit = [dbo].[Throw](@error)
-- ============================================= -- Author: AM -- Create date: 03/02/2010 -- Description: Returns the appropriate exchange rate -- based on the input parameters. -- If the rate cannot be found, returns NULL -- (RAISEERROR can -- ============================================= ALTER FUNCTION [dbo].[GetExchangeRate] ( @CurrencyFrom char(3), @CurrencyTo char(3), @OnDate date ) RETURNS decimal(18,4) AS BEGIN DECLARE @ClosingRate as decimal(18,4) SELECT TOP 1 @ClosingRate=ClosingRate FROM [FactCurrencyRate] WHERE FromCurrencyCode=@CurrencyFrom AND ToCurrencyCode=@CurrencyTo AND DateID=dbo.DateToIntegerKey(@OnDate) RETURN @ClosingRate END GO
create table foo ( ID nvarchar(255), Data nvarchar(255) ) go insert into foo (ID, Data) values ( go create function dbo.GetFoo(@aID nvarchar(255)) returns table as return ( select *, 0 as CausesError from foo where ID = @aID --error checking code is embedded within this union --when the ID exists, this second selection is empty due to where clause at end --when ID doesn --case statement is very hack-y, but this was the only way I could get the code to compile --for an inline TVF --simpler approaches were caught at compile time by SQL Server union select top 1 *, case when ((select top 1 ID from foo where ID = @aID) = @aID) then 0 else end from foo where (not exists (select ID from foo where ID = @aID)) ) go --this does not cause an error select * from dbo.GetFoo( go --this does cause an error select * from dbo.GetFoo( go drop function dbo.GetFoo go drop table foo go
CREATE FUNCTION fn() RETURNS @T TABLE (Col CHAR) AS BEGIN DECLARE @i INT = CAST( RETURN END
CREATE FUNCTION dbo.ufn_test (@a TINYINT) RETURNS @returns TABLE(Column1 VARCHAR(10), Value1 TINYINT) BEGIN IF @a>50 -- if @a > 50 - raise an error BEGIN INSERT INTO @returns (Column1, Value1) VALUES( END INSERT INTO @returns (Column1, Value1) VALUES( RETURN; END SELECT Column1, Value1 FROM dbo.ufn_test(1) -- this is okay SELECT Column1, Value1 FROM dbo.ufn_test(51) -- this will raise an error
create procedure throw_error ( in err_msg varchar(255)) begin insert into tbl_throw_error (id, msg) values (null, err_msg); insert into tbl_throw_error (id, msg) values (null, err_msg); end;
UPDATE [Country] SET [CountryCode] = WHERE code = GO UPDATE [Country] SET [CountryCode] = WHERE code =
> drop table tempdb.guest.x1 > create table tempdb.guest.x1 (a int) > go Msg 2714, Level 16, State 1 Server There is already an object named > drop table tempdb.guest.x1 > go > create table tempdb.guest.x1 (a int) > go >
IF OBJECT_ID ( DROP PROCEDURE dbo.uspDoStuff GO CREATE PROCEDURE dbo.uspDoStuff AS SELECT Something From ATable GO GRANT EXECUTE ON dbo.uspDoStuff TO RoleSomeOne GO
CREATE TABLE dbo.TEST (ID INT IDENTITY (1,1), ROWID uniqueidentifier) GO INSERT INTO dbo.TEST (ROWID) VALUES (NEWID()) GO 1000
With DependencedIncidents AS ( SELECT INC.[RecTime],INC.[SQL] AS [str] FROM ( SELECT A.[RecTime] As [RecTime],X.[SQL] As [SQL] FROM [EventView] AS A CROSS JOIN [Incident] AS X WHERE patindex( ) AS INC ) With lalala AS ( SELECT INC.[RecTime],INC.[SQL] AS [str] FROM ( SELECT A.[RecTime] As [RecTime],X.[SQL] As [SQL] FROM [EventView] AS A CROSS JOIN [Incident] AS X WHERE patindex( ) AS INC )
With DependencedIncidents AS ( SELECT INC.[RecTime],INC.[SQL] AS [str] FROM ( SELECT A.[RecTime] As [RecTime],X.[SQL] As [SQL] FROM [EventView] AS A CROSS JOIN [Incident] AS X WHERE patindex( ) AS INC ), lalala AS ( SELECT INC.[RecTime],INC.[SQL] AS [str] FROM ( SELECT A.[RecTime] As [RecTime],X.[SQL] As [SQL] FROM [EventView] AS A CROSS JOIN [Incident] AS X WHERE patindex( ) AS INC )
WITH DependencedIncidents AS ( .... ), lalala AS ( .... )
declare @tablename varchar(50) set @tablename = select * from @tablename
--DECLARE TABLE NAME VARIABLE DYNAMICALLY DECLARE @table_name varchar(max) SET @table_name = (SELECT + DATENAME(YEAR,GETDATE()) + UPPER(DATENAME(MONTH,GETDATE())) ) --DROP THE TABLE IF IT ALREADY EXISTS IF EXISTS(SELECT name FROM sysobjects WHERE name = @table_name AND xtype = BEGIN EXEC( END --CREATES TABLE FROM DYNAMIC VARIABLE AND INSERTS ROWS FROM ANOTHER TABLE EXEC(
DECLARE @sqlCommand varchar(1000) SET @sqlCommand = EXEC (@sqlCommand)
CREATE PROCEDURE [dbo].[GetByName] @TableName NVARCHAR(100) AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; DECLARE @sSQL nvarchar(500); SELECT @sSQL = N EXEC sp_executesql @sSQL END
declare @tablename varchar(50) set @tablename = declare @sql varchar(500) set @sql = exec (@sql)
DECLARE @tbl sysname, @sql nvarchar(4000), @params nvarchar(4000), @count int DECLARE tblcur CURSOR STATIC LOCAL FOR SELECT object_name(id) FROM syscolumns WHERE name = ORDER BY 1 OPEN tblcur WHILE 1 = 1 BEGIN FETCH tblcur INTO @tbl IF @@fetch_status <> 0 BREAK SELECT @sql = N N N SELECT @params = N N N EXEC sp_executesql @sql, @params, PRINT @tbl + END DEALLOCATE tblcur
Declare @fs_e int, @C_Tables CURSOR, @Table varchar(50) SET @C_Tables = CURSOR FOR select name from sysobjects where OBJECTPROPERTY(id, N OPEN @C_Tables FETCH @C_Tables INTO @Table SELECT @fs_e = sdec.fetch_Status FROM sys.dm_exec_cursors(0) as sdec where sdec.name = WHILE ( @fs_e <> -1) BEGIN exec( FETCH @C_Tables INTO @Table SELECT @fs_e = sdec.fetch_Status FROM sys.dm_exec_cursors(0) as sdec where sdec.name = END
SELECT SUSP.Susp_Visits.SuspReason, SUSP.Susp_Visits.SiteID FROM SUSP.Susp_Visits LEFT OUTER JOIN DATA.Dim_Member ON SUSP.Susp_Visits.MemID = DATA.Dim_Member.MembershipNum
Table1 Table2 _______ _________ 1 2 2 2 3 5 4 6 SELECT Table1.Id, Table2.Id FROM Table1 LEFT OUTER JOIN Table2 ON Table1.Id=Table2.Id
SELECT SuspReason, SiteID FROM( SELECT SUSP.Susp_Visits.SuspReason, SUSP.Susp_Visits.SiteID, ROW_NUMBER() OVER(PARTITION BY SUSP.Susp_Visits.SiteID) AS rn FROM SUSP.Susp_Visits LEFT OUTER JOIN DATA.Dim_Member ON SUSP.Susp_Visits.MemID = DATA.Dim_Member.MembershipNum ) AS t WHERE rn=1
SELECT SUSP.Susp_Visits.SuspReason, SUSP.Susp_Visits.SiteID FROM SUSP.Susp_Visits WHERE EXISTS( SELECT DATA.Dim_Member WHERE SUSP.Susp_Visits.MemID = DATA.Dim_Member.MembershipNum )
IF CAST(DateField1 AS DATE) = CAST(DateField2 AS DATE)
--112 is ISO format declare @filterDate char(8) = CONVERT(char(8), GETDATE(), 112) select * from Sales.Orders where CONVERT(char(8), OrderDate, 112) = @filterDate
--112 is ISO format declare @filterDate char(8) = CONVERT(char(8), GETDATE(), 112) select * from Sales.Orders where OrderDate = @filterDate
select case when CONVERT(DATE, GETDATE()) = CONVERT(DATE, else
UPDATE dbo.TestStudents SET LASTNAME = ( CASE WHEN (LASTNAME = WHEN (LASTNAME = WHEN (LASTNAME = ELSE (LASTNAME) END )
UPDATE dbo.TestStudents SET LASTNAME = CASE WHEN LASTNAME = WHEN LASTNAME = WHEN LASTNAME = ELSE LASTNAME END WHERE LASTNAME IN (
UPDATE [dbo].[JobTemplates] SET [CycleId] = CASE [Id] WHEN 1376 THEN 44 --ACE1 FX1 WHEN 1385 THEN 44 --ACE1 FX2 WHEN 1574 THEN 43 --ACE1 ELEM1 WHEN 1576 THEN 43 --ACE1 ELEM2 WHEN 1581 THEN 41 --ACE1 FS1 WHEN 1585 THEN 42 --ACE1 HS1 WHEN 1588 THEN 43 --ACE1 RS1 WHEN 1589 THEN 44 --ACE1 RM1 WHEN 1590 THEN 43 --ACE1 ELEM3 WHEN 1591 THEN 43 --ACE1 ELEM4 WHEN 1595 THEN 44 --ACE1 SSTn ELSE 0 END WHERE [Id] IN (1376,1385,1574,1576,1581,1585,1588,1589,1590,1591,1595)
SELECT [Id] ,[QueueId] ,[BaseDimensionId] ,[ElastomerTypeId] ,CASE [CycleId] WHEN 29 THEN 44 WHEN 30 THEN 43 WHEN 31 THEN 43 WHEN 101 THEN 41 WHEN 102 THEN 43 WHEN 116 THEN 42 WHEN 120 THEN 44 WHEN 127 THEN 44 WHEN 129 THEN 44 ELSE 0 END AS [CycleId] INTO FROM [dbo].[ProductionQueueProcessAutoclaveNominals] WHERE [QueueId] = 3 ORDER BY [BaseDimensionId], [ElastomerTypeId], [Id]; ---- (403 row(s) affected) UPDATE [dbo].[ProductionQueueProcessAutoclaveNominals] SET [CycleId] = X.[CycleId] FROM [dbo].[ProductionQueueProcessAutoclaveNominals] INNER JOIN ( SELECT MIN([Id]) AS [Id],[QueueId],[BaseDimensionId],[ElastomerTypeId],[CycleId] FROM GROUP BY [QueueId],[BaseDimensionId],[ElastomerTypeId],[CycleId] ) AS X ON [dbo].[ProductionQueueProcessAutoclaveNominals].[Id] = X.[Id]; ----(375 row(s) affected)
declare @ToDo table (FromName varchar(10), ToName varchar(10)) insert into @ToDo(FromName,ToName) values ( ( ( update ts set LastName = ToName from dbo.TestStudents ts inner join @ToDo t on ts.LastName = t.FromName
CREATE FUNCTION dbo.CheckIfSFExists(@param1 INT, @param2 BIT = 1 ) RETURNS BIT AS BEGIN IF EXISTS ( bla bla bla ) RETURN 1; RETURN 0; END GO
SET NOCOUNT ON; DECLARE @Table SYSNAME = @Schema SYSNAME = @Rows INT; SELECT dbo.TableRowCount( @Table, @Schema ) SELECT dbo.TableRowCount( @Table, DEFAULT ) EXECUTE @Rows = dbo.TableRowCount @Table SELECT @Rows
IF dbo.CheckIfSFExists( 23, default ) = 0 SET @retValue =
DECLARE @sortCol1 AS varchar(20) DECLARE @sortCol2 AS varchar(20) DECLARE @dir1 AS varchar(20) DECLARE @dir2 AS varchar(20) DECLARE @col1 AS varchar(20) DECLARE @col2 AS varchar(20) SET @col1 = SET @col2 = IF @sort = 1 -- Default sort. BEGIN SET @sortCol1 = @col1; SET @dir1 = SET @sortCol2 = @col2; SET @dir2 = END ELSE IF @sort = 2 -- Reversed order default sort. BEGIN SET @sortCol1 = @col1; SET @dir1 = SET @sortCol2 = @col2; SET @dir2 = END
ORDER BY CASE @dir1 WHEN CASE @sortCol1 WHEN @col1 THEN [storagedatetime] WHEN @col2 THEN [vehicleid] END END DESC, CASE @dir1 WHEN CASE @sortCol1 WHEN @col1 THEN [storagedatetime] WHEN @col2 THEN [vehicleid] END END, CASE @dir2 WHEN CASE @sortCol2 WHEN @col1 THEN [storagedatetime] WHEN @col2 THEN [vehicleid] END END DESC, CASE @dir2 WHEN CASE @sortCol2 WHEN @col1 THEN [storagedatetime] WHEN @col2 THEN [vehicleid] END END
ORDER BY NULL DESC, NULL, [storagedatetime] DESC, blah blah
order by case when @SortExpr = then CustomerName end asc, case when @SortExpr = then CustomerName end desc, ...
SELECT s.* FROM (SELECT CASE @SortCol1 WHEN WHEN ELSE null END as SortCol1, CASE @SortCol2 WHEN WHEN ELSE null END as SortCol2, t.* FROM MyTable t) as s ORDER BY CASE WHEN @dir1 = CASE WHEN @dir1 = CASE WHEN @dir2 = CASE WHEN @dir2 =
create procedure uspCallAndSort ( @sql varchar(2048), --exec dbo.uspSomeProcedure arg1, @sortClause varchar(512) --comma-delimited field list ) AS insert into declare @msql varchar(3000) set @msql = EXEC(@msql) drop table GO
SELECT name_last, name_first, CASE @sortCol WHEN FROM table ORDER BY mySort
declare @o int; set @o = -1; declare @sql nvarchar(2000); set @sql = N cast(abs(@o) as varchar) + case when @o < 0 then exec sp_executesql @sql
declare @cols varchar(100); set @cols = declare @order_by varchar(200) select @order_by = isnull(@order_by + cast(abs(number) as varchar) + case when number < 0 then from dbo.iter_intlist_to_tbl(@cols) order by listpos print @order_by
SELECT logcount, logUserID, maxlogtm , DATEDIFF(day, maxlogtm, GETDATE()) AS daysdiff FROM statslogsummary WHERE daysdiff > 120
SELECT logcount, logUserID, maxlogtm, DATEDIFF(day, maxlogtm, GETDATE()) AS daysdiff FROM statslogsummary WHERE ( DATEDIFF(day, maxlogtm, GETDATE() > 120)
SELECT * FROM ( SELECT logcount, logUserID, maxlogtm, DATEDIFF(day, maxlogtm, GETDATE()) AS daysdiff FROM statslogsummary ) as innerTable WHERE daysdiff > 120
WITH LogDateDiff AS ( SELECT logcount, logUserID, maxlogtm , DATEDIFF(day, maxlogtm, GETDATE()) AS daysdiff FROM statslogsummary ) SELECT logCount, logUserId, maxlogtm, daysdiff FROM LogDateDiff WHERE daysdiff > 120
select s.logcount, s.logUserID, s.maxlogtm, a.daysdiff from statslogsummary as s outer apply (select datediff(day, s.maxlogtm, getdate()) as daysdiff) as a where a.daysdiff > 120
SELECT * from (SELECT logcount, logUserID, maxlogtm , DATEDIFF(day, maxlogtm, GETDATE()) AS daysdiff FROM statslogsummary) as WHERE daysdiff > 120
SELECT logcount, logUserID, maxlogtm , DATEDIFF(day, maxlogtm, GETDATE()) AS daysdiff FROM statslogsummary HAVING daysdiff > 120
SELECT s.logcount, s.logUserID, s.maxlogtm, c.daysdiff FROM statslogsummary s CROSS APPLY (SELECT DATEDIFF(day, s.maxlogtm, GETDATE()) AS daysdiff) c WHERE c.daysdiff > 120;
SELECT SERVERPROPERTY( , SERVERPROPERTY( , SERVERPROPERTY(
DECLARE @ver nvarchar(128) SET @ver = CAST(serverproperty( SET @ver = SUBSTRING(@ver, 1, CHARINDEX( IF ( @ver = SELECT ELSE IF ( @ver = SELECT ELSE IF ( @ver = SELECT ELSE IF ( @ver = SELECT ELSE IF ( @ver = SELECT ELSE IF ( @ver = SELECT ELSE IF ( @ver = SELECT ELSE IF ( @ver = SELECT ELSE SELECT
declare @sqlVers numeric(4,2) select @sqlVers = left(cast(serverproperty(
CREATE FUNCTION dbo.UFN_GET_SQL_SEVER_VERSION ( ) RETURNS sysname AS BEGIN DECLARE @ServerVersion sysname, @ProductVersion sysname, @ProductLevel sysname, @Edition sysname; SELECT @ProductVersion = CONVERT(sysname, SERVERPROPERTY( @ProductLevel = CONVERT(sysname, SERVERPROPERTY( @Edition = CONVERT(sysname, SERVERPROPERTY ( --see: http: SELECT @ServerVersion = CASE WHEN @ProductVersion LIKE WHEN @ProductVersion LIKE WHEN @ProductVersion LIKE WHEN @ProductVersion LIKE WHEN @ProductVersion LIKE WHEN @ProductVersion LIKE END RETURN @ServerVersion + N END GO
declare @isSqlServer2005 bit select @isSqlServer2005 = case when CONVERT(int, SUBSTRING(CONVERT(varchar(15), SERVERPROPERTY( select @isSqlServer2005
SELECT @@SERVERNAME AS ServerName, CASE WHEN LEFT(CAST(serverproperty( WHEN LEFT(CAST(serverproperty( WHEN LEFT(CAST(serverproperty( END AS MajorVersion, SERVERPROPERTY ( SERVERPROPERTY( SERVERPROPERTY (
SELECT SUBSTRING(ver, 1, CHARINDEX( FROM (SELECT CAST(serverproperty(
SELECT @@MICROSOFTVERSION / 0x01000000 AS MajorVersionNumber
select substring(@@version,0,charindex(convert(varchar,SERVERPROPERTY(
--This example uses both Leading and Trailing zero --Avoid losing those Trailing zero --I added a non-whitespace character ("_") to retain trailing zero --Simply remove the RTrim() function call if you want to preserve trailing spaces. --If you treat zero -- then you may skip the Case-Statement entirely and just use CN.CleanNumber . DECLARE @WackadooNumber VarChar(50) = SELECT WN.WackadooNumber, CN.CleanNumber, (CASE WHEN WN.WackadooNumber LIKE FROM (SELECT @WackadooNumber[WackadooNumber]) AS WN OUTER APPLY (SELECT RTRIM(RIGHT(WN.WackadooNumber, LEN(LTRIM(REPLACE(WN.WackadooNumber + --Result: "123ABC D0"
SELECT O.Type, O.Value, Parsed.Value[WrongValue], (CASE WHEN CHARINDEX( AND LEN(Parsed.Value) = 0--And the trimmed length is zero. THEN (CASE WHEN CHARINDEX( AND LEN(Parsed.TrimmedValue) = 0--And the trimmed length is zero. THEN FROM ( VALUES ( ( ( ( ) AS O(Type, Value)--O is for Original. CROSS APPLY ( --This Step is Optional. Use if you also want to remove leading spaces. SELECT LTRIM(RTRIM(O.Value))[Value] ) AS T--T is for Trimmed. CROSS APPLY ( --From @CadeRoux SELECT SUBSTRING(O.Value, PATINDEX( SUBSTRING(T.Value, PATINDEX( ) AS Parsed
DROP FUNCTION [dbo].[FN_StripLeading] GO CREATE FUNCTION [dbo].[FN_StripLeading] (@string VarChar(128), @stripChar VarChar(1)) RETURNS VarChar(128) AS BEGIN -- http: DECLARE @retVal VarChar(128), @pattern varChar(10) SELECT @pattern = SELECT @retVal = CASE WHEN SUBSTRING(@string, PATINDEX(@pattern, @string+ RETURN (@retVal) END GO GRANT EXECUTE ON [dbo].[FN_StripLeading] TO PUBLIC
CASE WHEN PATINDEX( ELSE SUBSTRING(str_col, PATINDEX( END
WITH hier(cnt) AS ( SELECT 1 UNION ALL SELECT cnt + 1 FROM hier WHERE cnt < @n ) SELECT cnt FROM hier
declare @listOfIDs table (id int); insert @listOfIDs(id) values(1),(2),(3); select * from TabA where TabA.ID in (select id from @listOfIDs)
declare @listOfIDs varchar(1000); SET @listOfIDs = select * from TabA where charindex(
CREATE TYPE [dbo].[IntList] AS TABLE( [Value] [int] NOT NULL )
ALTER Procedure [dbo].[GetFooByIds] @Ids [IntList] ReadOnly As
Declare @IDs IntList; Insert Into @IDs Select Id From dbo.{TableThatHasIds} Where Id In (111, 222, 333, 444) Exec [dbo].[GetFooByIds] @IDs
DECLARE @listOfIDs dbo.IntList INSERT INTO @listofIDs VALUES (1),(35),(118);
DECLARE @SQL nvarchar(8000); SET @SQL = EXECUTE (@SQL);
/*List of ids in a comma delimited string Note: the doesn DECLARE @listOfIds VARCHAR(MAX) = --Make sure the temp table was dropped before trying to create it IF OBJECT_ID( --Create example reference table CREATE TABLE ([Id] INT NOT NULL); --Populate the reference table DECLARE @i INT = 1; WHILE(@i <= 10) BEGIN INSERT INTO SELECT @i; SET @i = @i + 1; END SELECT t.[Id] FROM INNER JOIN (SELECT value as [Id] FROM STRING_SPLIT(@listOfIds, WHERE ISNUMERIC(value) = 1 AND ROUND(value,0) = value ) as ids ON t.[Id] = ids.[Id]; --Clean-up DROP TABLE
DECLARE @listOfIDs NVARCHAR(MAX) = DECLARE @query NVARCHAR(MAX) = From TabA Where TabA.ID in ( Exec (@query)
DECLARE @tags NVARCHAR(400) = SELECT value FROM STRING_SPLIT(@tags, WHERE RTRIM(value) <>
SELECT * FROM [dbo].[yourTable] WHERE (strval IN (SELECT value FROM STRING_SPLIT(@tags,
SELECT RIGHT(MyColumn, LEN(MyColumn) - 4) AS MyTrimmedColumn
UPDATE MyTable SET MyColumn = RIGHT(MyColumn, LEN(MyColumn) - 4)
update table YourTable set YourField = substring(YourField, 5, len(YourField)-3);
CREATE TABLE Codes ( code1 varchar(10), code2 varchar(10) ) INSERT INTO Codes (CODE1, CODE2) vALUES ( UPDATE Codes SET code2 = SUBSTRING(Code1, 5, LEN(CODE1) -4)
DECLARE @v varchar(10) SET @v= select STUFF(@v, 1, 1, WHERE LEFT(@v,1)=
substring (ColumnName,<Number of starting Character which u want to remove>,<length of given string>)
UPDATE Table_Name SET RIGHT(column_name, LEN(column_name) - 1)
UPDATE tblInvalidID SET [ColumnName] =stuff(ColumnName, 1, charindex(
Action1 VIEW Action1 EDIT Action2 VIEW Action3 VIEW Action3 EDIT
Action1 VIEW EDIT Action2 VIEW NULL Action3 VIEW EDIT
SELECT Action, MAX( CASE data WHEN MAX( CASE data WHEN FROM t GROUP BY Action
SELECT act AS FROM ( SELECT act, cmd FROM data ) AS src PIVOT ( MAX(cmd) FOR cmd IN ([View], [Edit]) ) AS pvt
CREATE TABLE dbo.tbl ( action VARCHAR(20) NOT NULL, view_edit VARCHAR(20) NOT NULL ); INSERT INTO dbo.tbl (action, view_edit) VALUES ( ( ( ( (
SELECT Action, [View] = (Select view_edit FROM tbl WHERE t.action = action and view_edit = [Edit] = (Select view_edit FROM tbl WHERE t.action = action and view_edit = FROM tbl t GROUP BY Action
SELECT [Action], [View], [Edit] FROM (SELECT [Action], view_edit FROM tbl) AS t1 PIVOT (MAX(view_edit) FOR view_edit IN ([View], [Edit]) ) AS t2
SELECT CUST, PRODUCT, QTY FROM Product) up PIVOT ( SUM(QTY) FOR PRODUCT IN (VEG, SODA, MILK, BEER, CHIPS)) AS pvt) p UNPIVOT (QTY FOR PRODUCT IN (VEG, SODA, MILK, BEER, CHIPS) ) AS Unpvt GO
select distinct a, (select distinct t2.b from t t2 where t1.a=t2.a and t2.b= (select distinct t2.b from t t2 where t1.a=t2.a and t2.b= from t t1
With pivot_data as ( select action, -- grouping column view_edit -- spreading column from tbl ) select action, [view], [edit] from pivot_data pivot ( max(view_edit) for view_edit in ([view], [edit]) ) as p;
DECLARE @String VARCHAR(100) SET @String = -- Chop off the end character SET @String = CASE @String WHEN null THEN null ELSE ( CASE LEN(@String) WHEN 0 THEN @String ELSE LEFT(@String, LEN(@String) - 1) END ) END SELECT @String
DECLARE @String VARCHAR(100) SET @String = SELECT LEFT(@String, LEN(@String) - 1)
SELECT SUBSTRING(@String, 1, NULLIF(DATALENGTH(@String)-1,-1))
CREATE FUNCTION [dbo].[TRUNCRIGHT] (@string NVARCHAR(max), @len int = 1) RETURNS NVARCHAR(max) AS BEGIN IF LEN(@string)<@len RETURN RETURN LEFT(@string, LEN(@string) - @len) END
DECLARE @String VARCHAR(100) SET @String = SELECT LEFT(@String, LEN(@String) - 1) AS MyTrimmedColumn
DECLARE @String VARCHAR(100) SET @String = -- If string is null return null, else if string is empty return as it is, else chop off the end character SET @String = Case @String when null then null else (case LEN(@String) when 0 then @String else LEFT(@String, LEN(@String) - 1) end ) end SELECT @String
SELECT -- Return comma delimited list of all payment reasons for this Visit REVERSE(STUFF(REVERSE(( SELECT DISTINCT CAST(CONVERT(varchar, r1.CodeID) + FROM VisitReason r1 LEFT JOIN ReasonCode c ON c.ID = r1.ReasonCodeID WHERE p.ID = r1.PaymentID FOR XML PATH( )), 1, 2, FROM Payments p
UPDATE tablename SET columnName = LEFT(columnName , LEN(columnName )-N) where clause
DECLARE @String NVARCHAR(100) SET @String = SELECT LEFT(@String, NULLIF(LEN(@String)-1,-1))
declare @string varchar(20)= Select left(@string, len(@string)-1) as Tada
declare @x varchar(20),@y varchar(20) select @x= select case when @x is null then @y when @y is null then @x else @x+ end go declare @x varchar(20),@y varchar(20) select @x= --,@y= DECLARE @listStr VARCHAR(MAX) SELECT @listStr = COALESCE(@x + SELECT left(@listStr,len(@listStr)-1)
ALTER TABLE Employees ADD COLUMN EmployeeID int NOT NULL IDENTITY (1, 1) ALTER TABLE Employees ADD CONSTRAINT PK_Employees PRIMARY KEY CLUSTERED ( EmployeeID ) WITH( STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
ALTER TABLE Employees ADD EmployeeID numeric NOT NULL IDENTITY (1, 1) ALTER TABLE Employees ADD CONSTRAINT PK_Employees PRIMARY KEY CLUSTERED ( EmployeeID ) WITH( STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
ALTER TABLE [Emp] ADD Sr_No Int IDENTITY(1,1) NOT NULL
ALTER TABLE table_name ADD column_name column-definition;
ALTER TABLE Employees ADD EmployeeID int NOT NULL IDENTITY (1, 1)
ALTER TABLE table_name ADD (column_1 column-definition, column_2 column-definition, ... column_n column_definition);
ALTER TABLE table_name ALTER COLUMN column_name column_type;
Declare @string varchar(1000) Set @string = select len(@string) - len(replace(@string,
CREATE FUNCTION dbo.CountOccurrencesOfString ( @searchString nvarchar(max), @searchTerm nvarchar(max) ) RETURNS INT AS BEGIN return (LEN(@searchString)-LEN(REPLACE(@searchString,@searchTerm, END
SELECT * FROM MyTable where dbo.CountOccurrencesOfString(MyColumn,
Declare @string varchar(1000) Set @string = select len(@string) - len(replace(@string,
DECLARE @string VARCHAR(1000) SET @string = SELECT LEN(@string) - LEN(REPLACE(@string,
DECLARE @string VARCHAR(1000) SET @string = SELECT LEN(REPLACE(@string,
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO /* Usage: SELECT t.[YourColumn], c.StringCount FROM YourDatabase.dbo.YourTable t CROSS APPLY dbo.CountOccurrencesOfString( */ CREATE FUNCTION [dbo].[CountOccurrencesOfString] ( @searchTerm nvarchar(max), @searchString nvarchar(max) ) RETURNS TABLE AS RETURN SELECT (DATALENGTH(@searchString)-DATALENGTH(REPLACE(@searchString,@searchTerm,
Declare @string varchar(1000) DECLARE @SearchString varchar(100) Set @string = SET @SearchString = select ((len(@string) - len(replace(@string, @SearchString, len(replace(@string, @SearchString,
Declare @string varchar(1000) Set @string = Set @substring = select (len(@string) - len(replace(@string, @substring,
DECLARE @records varchar(400) SELECT @records = select LEN(@records) as
CREATE FUNCTION dbo.CountOccurrences ( @SearchString VARCHAR(1000), @SearchFor VARCHAR(1000) ) RETURNS TABLE AS RETURN ( SELECT COUNT(*) AS Occurrences FROM ( SELECT ROW_NUMBER() OVER (ORDER BY O.object_id) AS n FROM sys.objects AS O ) AS N JOIN ( VALUES (@SearchString) ) AS S (SearchString) ON SUBSTRING(S.SearchString, N.n, LEN(@SearchFor)) = @SearchFor ); GO --------------------------------------------------------------------------------------- -- Test the function for single and multiple character searches --------------------------------------------------------------------------------------- DECLARE @SearchForComma VARCHAR(10) = @SearchForCharacters VARCHAR(10) = DECLARE @TestTable TABLE ( TestData VARCHAR(30) NOT NULL ); INSERT INTO @TestTable ( TestData ) VALUES ( ( ( SELECT TT.TestData, CO.Occurrences AS CommaOccurrences, CO2.Occurrences AS CharacterOccurrences FROM @TestTable AS TT OUTER APPLY dbo.CountOccurrences(TT.TestData, @SearchForComma) AS CO OUTER APPLY dbo.CountOccurrences(TT.TestData, @SearchForCharacters) AS CO2;
RETURN ( SELECT COUNT(*) AS Occurrences FROM dbo.Nums AS N JOIN ( VALUES (@SearchString) ) AS S (SearchString) ON SUBSTRING(S.SearchString, N.n, LEN(@SearchFor)) = @SearchFor );
CREATE FUNCTION [dbo].[GetSubstringCount] ( @InputString nvarchar(1500), @SubString NVARCHAR(200) ) RETURNS int AS BEGIN declare @K int , @StrLen int , @Count int , @SubStrLen int set @SubStrLen = (select len(@SubString)) set @Count = 0 Set @k = 1 set @StrLen =(select len(@InputString)) While @K <= @StrLen Begin if ((select substring(@InputString, @K, @SubStrLen)) = @SubString) begin if ((select CHARINDEX(@SubString ,@InputString)) > 0) begin set @Count = @Count +1 end end Set @K=@k+1 end return @Count end
CREATE FUNCTION [dbo].[CountOccurrency] ( @Input nvarchar(max), @Search nvarchar(max) ) RETURNS int AS BEGIN declare @SearhLength as int = len( declare @conteinerIndex as int = 255; declare @conteiner as char(1) = char(@conteinerIndex); WHILE ((CHARINDEX(@conteiner, @Search)>0) and (@conteinerIndex>0)) BEGIN set @conteinerIndex = @conteinerIndex-1; set @conteiner = char(@conteinerIndex); END; set @Input = @conteiner + @Input + @conteiner RETURN (len(@Input) - len(replace(@Input, @Search, END
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N DROP PROCEDURE [dbo].[sp_parsedata] GO create procedure sp_parsedata (@cid integer,@st varchar(1000)) as declare @coid integer declare @c integer declare @c1 integer select @c1=len(@st) - len(replace(@st, set @c=0 delete from table1 where complainid=@cid; while (@c<=@c1) begin if (@c<@c1) begin select @coid=cast(replace(left(@st,CHARINDEX( select @st=SUBSTRING(@st,CHARINDEX( end else begin select @coid=cast(@st as integer) end insert into table1(complainid,courtid) values(@cid,@coid) set @c=@c+1 end
CREATE FUNCTION [dbo].[fn_Occurences] ( @pattern varchar(255), @expression varchar(max) ) RETURNS int AS BEGIN DECLARE @Result int = 0; DECLARE @index BigInt = 0 DECLARE @patLen int = len(@pattern) SET @index = CHARINDEX(@pattern, @expression, @index) While @index > 0 BEGIN SET @Result = @Result + 1; SET @index = CHARINDEX(@pattern, @expression, @index + @patLen) END RETURN @Result END
CREATE FUNCTION [dbo].[SDF_SplitString] ( @sString nvarchar(2048), @cDelimiter nchar(1) ) RETURNS @tParts TABLE ( part nvarchar(2048) ) AS BEGIN if @sString is null return declare @iStart int, @iPos int if substring( @sString, 1, 1 ) = @cDelimiter begin set @iStart = 2 insert into @tParts values( null ) end else set @iStart = 1 while 1=1 begin set @iPos = charindex( @cDelimiter, @sString, @iStart ) if @iPos = 0 set @iPos = len( @sString )+1 if @iPos - @iStart > 0 insert into @tParts values ( substring( @sString, @iStart, @iPos-@iStart )) else insert into @tParts values( null ) set @iStart = @iPos+1 if @iStart > len( @sString ) break end RETURN END
DECLARE @xml xml, @str varchar(100), @delimiter varchar(10) SET @str = SET @delimiter = SET @xml = cast(( SELECT C.value(
DECLARE @str varchar(100), @delimiter varchar(10) SET @str = SET @delimiter = ;WITH cte AS ( SELECT 0 a, 1 b UNION ALL SELECT b, CHARINDEX(@delimiter, @str, b) + LEN(@delimiter) FROM CTE WHERE b > a ) SELECT SUBSTRING(@str, a, CASE WHEN b > LEN(@delimiter) THEN b - a - LEN(@delimiter) ELSE LEN(@str) - a + 1 END) value FROM cte WHERE a > 0
CREATE FUNCTION dbo.[String.Split] ( @Text VARCHAR(MAX), @Delimiter VARCHAR(100), @Index INT ) RETURNS VARCHAR(MAX) AS BEGIN DECLARE @A TABLE (ID INT IDENTITY, V VARCHAR(MAX)); DECLARE @R VARCHAR(MAX); WITH CTE AS ( SELECT 0 A, 1 B UNION ALL SELECT B, CONVERT(INT,CHARINDEX(@Delimiter, @Text, B) + LEN(@Delimiter)) FROM CTE WHERE B > A ) INSERT @A(V) SELECT SUBSTRING(@Text,A,CASE WHEN B > LEN(@Delimiter) THEN B-A-LEN(@Delimiter) ELSE LEN(@Text) - A + 1 END) VALUE FROM CTE WHERE A >0 SELECT @R = V FROM @A WHERE ID = @Index + 1 RETURN @R END SELECT dbo.[String.Split](
CREATE FUNCTION [dbo].[split]( @delimited NVARCHAR(MAX), @delimiter NVARCHAR(100) ) RETURNS @t TABLE (id INT IDENTITY(1,1), val NVARCHAR(MAX)) AS BEGIN DECLARE @xml XML SET @xml = N INSERT INTO @t(val) SELECT r.value( FROM @xml.nodes( RETURN END
DECLARE @InputString NVARCHAR(MAX) = , @delimiter varchar(10) = DECLARE @xml AS XML = CAST(( SELECT C.value( FROM @xml.nodes(
create function FnSplitToTableInt ( @param nvarchar(4000) ) returns table as return with Numbers(Number) as ( select 1 union all select Number + 1 from Numbers where Number < 4000 ), Found as ( select Number as PosIdx, convert(int, ltrim(rtrim(convert(nvarchar(4000), substring(@param, Number, charindex(N @param + N from Numbers where Number <= len(@param) and substring(N ) select PosIdx, case when isnumeric(Value) = 1 then convert(int, Value) else convert(int, null) end as Value from Found
select * from FnSplitToTableInt ( ) option (maxrecursion 4000)
Create function [dbo].[udf_split] ( @ListString nvarchar(max), @Delimiter nvarchar(1000), @IncludeEmpty bit) Returns @ListTable TABLE (ID int, ListValue nvarchar(1000)) AS BEGIN Declare @CurrentPosition int, @NextPosition int, @Item nvarchar(max), @ID int, @L int Select @ID = 1, @L = len(replace(@Delimiter, @ListString = @ListString + @Delimiter, @CurrentPosition = 1 Select @NextPosition = Charindex(@Delimiter, @ListString, @CurrentPosition) While @NextPosition > 0 Begin Set @Item = LTRIM(RTRIM(SUBSTRING(@ListString, @CurrentPosition, @NextPosition-@CurrentPosition))) If @IncludeEmpty=1 or LEN(@Item)>0 Begin Insert Into @ListTable (ID, ListValue) Values (@ID, @Item) Set @ID = @ID+1 End Set @CurrentPosition = @NextPosition+@L Set @NextPosition = Charindex(@Delimiter, @ListString, @CurrentPosition) End RETURN END
CREATE FUNCTION Split ( @delimited nvarchar(max), @delimiter nvarchar(100) ) RETURNS @t TABLE ( -- Id column can be commented out, not required for sql splitting string id int identity(1,1), -- I use this column for numbering splitted parts val nvarchar(max) ) AS BEGIN declare @xml xml set @xml = N insert into @t(val) select r.value( from @xml.nodes( RETURN END GO
/* *Object: UserDefinedFunction [dbo].[Split] Script Date: 10/04/2013 18:18:38* */ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER FUNCTION [dbo].[Split] (@List varchar(8000),@SplitOn Nvarchar(5)) RETURNS @RtnValue table (Id int identity(1,1),Value nvarchar(100)) AS BEGIN Set @List = Replace(@List, While (Charindex(@SplitOn,@List)>0) Begin Insert Into @RtnValue (value) Select Value = ltrim(rtrim(Substring(@List,1,Charindex(@SplitOn,@List)-1))) Set @List = Substring(@List,Charindex(@SplitOn,@List)+len(@SplitOn),len(@List)) End Insert Into @RtnValue (Value) Select Value = ltrim(rtrim(@List)) Return END go Select * From [Clv].[Split] ( GO
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE FUNCTION [dbo].[SplitIntoBigints] (@List varchar(MAX), @Splitter char) RETURNS TABLE AS RETURN ( WITH SplittedXML AS( SELECT CAST( ) SELECT x.v.value( FROM SplittedXML CROSS APPLY Splitted.nodes( ) GO
CREATE Function [dbo].[CsvToInt] ( @Array varchar(4000)) returns @IntTable table (IntValue int) AS begin declare @separator char(1) set @separator = declare @separator_position int declare @array_value varchar(4000) set @array = @array + while patindex( begin select @separator_position = patindex( select @array_value = left(@array, @separator_position - 1) Insert @IntTable Values (Cast(@array_value as int)) select @array = stuff(@array, 1, @separator_position, end
CREATE FUNCTION [dbo].[DelimitedSplit8K] (@pString VARCHAR(8000), @pDelimiter CHAR(1)) RETURNS TABLE WITH SCHEMABINDING AS RETURN --===== "Inline" CTE Driven "Tally Table" produces values from 0 up to 10,000... -- enough to cover NVARCHAR(4000) WITH E1(N) AS ( SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 ), --10E+1 or 10 rows E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max cteTally(N) AS (--==== This provides the "base" CTE and limits the number of rows right up front -- for both a performance gain and prevention of accidental "overruns" SELECT TOP (ISNULL(DATALENGTH(@pString),0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4 ), cteStart(N1) AS (--==== This returns N+1 (starting position of each "element" just once for each delimiter) SELECT 1 UNION ALL SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@pString,t.N,1) = @pDelimiter ), cteLen(N1,L1) AS(--==== Return start and length (for use in substring) SELECT s.N1, ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,8000) FROM cteStart s ) --===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found. SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1), Item = SUBSTRING(@pString, l.N1, l.L1) FROM cteLen l ;
DECLARE @csv varchar(max) = --append comma to the list for CTE to work correctly SET @csv = @csv + --remove double commas (empty entries) SET @csv = replace(@csv, WITH CteCsv AS ( SELECT CHARINDEX( UNION ALL SELECT CHARINDEX( WHERE CHARINDEX( ) SELECT [Value] FROM CteCsv
SELECT Movies.CustomerID, Movies.Movie, Customers.Age, Customers.Gender, Customers.[Education Level], Customers.[Internet Connection], Customers.[Marital Status], FROM Customers CROSS JOIN Movies
SELECT Movies.CustomerID, Movies.Movie, Customers.Age, Customers.Gender, Customers.[Education Level], Customers.[Internet Connection], Customers.[Marital Status] FROM Customers INNER JOIN Movies ON Customers.CustomerID = Movies.CustomerID
select * from table1 cross join table2 where table1.id = table2.fk_id
select * from table1 join table2 on table1.id = table2.fk_id
x------------------------x | TchrId | TeacherName | x----------|-------------x | T1 | Mary | | T2 | Jim | x------------------------x
x--------------------------------------x | StudId | TchrId | StudentName | x----------|-------------|-------------x | S1 | T1 | Vineeth | | S2 | T1 | Unni | x--------------------------------------x
SELECT T.TchrId,T.TeacherName,S.StudentName FROM INNER JOIN
x--------------------------------------x | TchrId | TeacherName | StudentName | x----------|-------------|-------------x | T1 | Mary | Vineeth | | T1 | Mary | Unni | x--------------------------------------x
SELECT T.TchrId,T.TeacherName,S.StudentName FROM CROSS JOIN
x--------------------------------------x | TchrId | TeacherName | StudentName | x----------|-------------|-------------x | T2 | Jim | Vineeth | | T2 | Jim | Unni | | T1 | Mary | Vineeth | | T1 | Mary | Unni | x--------------------------------------x
SELECT t1.column_name,t2.column_name FROM table_name1 t1 INNER JOIN table_name2 t2 ON t1.column_name=t2.column_name
SELECT A.F, B.G, C.H FROM TABLE_A A, TABLE_B B, TABLE_C C WHERE A.X = B.X AND B.Y = C.Y
table1 x--------------------------------------x | fieldA | fieldB | fieldC | x----------|-------------|-------------x | A | B | option1 | | A | B1 | option2 | x--------------------------------------x table2 x--------------------------------------x | fieldA | fieldB | fieldC | x----------|-------------|-------------x | A | B | optionB1 | | A1 | B1 | optionB2 | x--------------------------------------x cross join A,B,option1,A,B,optionB1 A,B,option1,A1,B1,optionB2 A,B1,option2,A,B,optionB1 A,B1,option2,A1,B1,optionB2 inner join on field1 (only with the value is the same in both tables) A,B,option1,A,B,optionB1 A,B1,option2,A,B,optionB1 inner join on field1 A,B,option1,A,B,optionB1
CREATE ROLE db_executor GRANT EXECUTE TO db_executor
Wildcard Meaning % Any string of zero or more characters. _ Any single character. [ ] Any single character within the specified range (for example, [a-f]) or set (for example, [abcdef]). [^] Any single character not within the specified range (for example, [^a - f]) or set (for example, [^abcdef]).
CREATE FUNCTION RegexContain(@text NVARCHAR(50), @pattern NVARCHAR(50)) RETURNS smallint AS EXTERNAL NAME CLR_Functions.[CLR_Functions.myFunctions].RegexContain
SELECT * FROM ( SELECT DailyLog.Date, DailyLog.Researcher, DailyLog.team, DailyLog.field, DailyLog.EntityID, DailyLog.[From], DailyLog.[To], dbo.RegexContain(Researcher, FROM [DailyOps].[dbo].[DailyLog] ) AS a WHERE a.[is null values] = 0
EXEC sp_execute_external_script @language = N @script = N OutputDataSet <- RegexWithR[!grepl("([_a-z0-9-]+(\\.[_a-z0-9-]+)*@[a-z0-9-]+(\\.[a-z0-9-]+)*(\\.[a-z]{2,4}))", RegexWithR$EmailAddress), ]; @input_data_1 = N WITH RESULT SETS (([PersonID] INT, [FullName] NVARCHAR(50), [EmailAddress] NVARCHAR(256)))
DECLARE @obj INT, @res INT, @match BIT; DECLARE @pattern varchar(255) = DECLARE @matchstring varchar(8000) = SET @match = 0; -- Create a VB script component object EXEC @res = sp_OACreate -- Apply/set the pattern to the RegEx object EXEC @res = sp_OASetProperty @obj, -- Set any other settings/properties here EXEC @res = sp_OASetProperty @obj, -- Call the method EXEC @res = sp_OAMethod @obj, -- Don EXEC @res = sp_OADestroy @obj;
Begin Transaction -Do some T-SQL queries here. Rollback transaction -- OR commit transaction
USE AdventureWorks; GO BEGIN TRANSACTION; BEGIN TRY -- Generate a constraint violation error. DELETE FROM Production.Product WHERE ProductID = 980; END TRY BEGIN CATCH SELECT ERROR_NUMBER() AS ErrorNumber ,ERROR_SEVERITY() AS ErrorSeverity ,ERROR_STATE() AS ErrorState ,ERROR_PROCEDURE() AS ErrorProcedure ,ERROR_LINE() AS ErrorLine ,ERROR_MESSAGE() AS ErrorMessage; IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION; END CATCH; IF @@TRANCOUNT > 0 COMMIT TRANSACTION; GO
USE AdventureWorks; GO DECLARE @TEST INT = 1--1 is test mode, use zero when you are ready to execute BEGIN TRANSACTION; BEGIN TRY IF @TEST= 1 BEGIN SELECT *FROM Production.Product WHERE ProductID = 980; END -- Generate a constraint violation error. DELETE FROM Production.Product WHERE ProductID = 980; IF @TEST= 1 BEGIN SELECT *FROM Production.Product WHERE ProductID = 980; IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION; END END TRY BEGIN CATCH SELECT ERROR_NUMBER() AS ErrorNumber ,ERROR_SEVERITY() AS ErrorSeverity ,ERROR_STATE() AS ErrorState ,ERROR_PROCEDURE() AS ErrorProcedure ,ERROR_LINE() AS ErrorLine ,ERROR_MESSAGE() AS ErrorMessage; IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION; END CATCH; IF @@TRANCOUNT > 0 AND @TEST = 0 COMMIT TRANSACTION; GO
ALTER TABLE [Production].[ProductCostHistory] WITH CHECK ADD CONSTRAINT [FK_ProductCostHistory_Product_ProductID] FOREIGN KEY([ProductID]) REFERENCES [Production].[Product] ([ProductID]) GO
ALTER TABLE [Production].[ProductCostHistory] CHECK CONSTRAINT [FK_ProductCostHistory_Product_ProductID] GO
ALTER TABLE [Production].[ProductCostHistory] ADD CONSTRAINT [DF_ProductCostHistory_ModifiedDate] DEFAULT (getdate()) FOR [ModifiedDate] GO
CREATE TABLE T1 (ID INT NOT NULL, SomeVal CHAR(1)); ALTER TABLE T1 ADD CONSTRAINT [PK_ID] PRIMARY KEY CLUSTERED (ID); CREATE TABLE T2 (FKID INT, SomeOtherVal CHAR(2)); INSERT T1 (ID, SomeVal) SELECT 1, INSERT T1 (ID, SomeVal) SELECT 2, INSERT T2 (FKID, SomeOtherVal) SELECT 1, INSERT T2 (FKID, SomeOtherVal) SELECT 1, INSERT T2 (FKID, SomeOtherVal) SELECT 2, INSERT T2 (FKID, SomeOtherVal) SELECT 2, INSERT T2 (FKID, SomeOtherVal) SELECT 3, INSERT T2 (FKID, SomeOtherVal) SELECT 3, --Add the FK CONSTRAINT will fail because of existing orphaned records ALTER TABLE T2 ADD CONSTRAINT FK_T2_T1 FOREIGN KEY (FKID) REFERENCES T1 (ID); --fails --Same as ADD above, but explicitly states the intent to CHECK the FK values before creating the CONSTRAINT ALTER TABLE T2 WITH CHECK ADD CONSTRAINT FK_T2_T1 FOREIGN KEY (FKID) REFERENCES T1 (ID); --fails --Add the CONSTRAINT without checking existing values ALTER TABLE T2 WITH NOCHECK ADD CONSTRAINT FK_T2_T1 FOREIGN KEY (FKID) REFERENCES T1 (ID); --succeeds ALTER TABLE T2 CHECK CONSTRAINT FK_T2_T1; --succeeds since the CONSTRAINT is attributed as NOCHECK --Attempt to enable CONSTRAINT fails due to orphans ALTER TABLE T2 WITH CHECK CHECK CONSTRAINT FK_T2_T1; --fails --Remove orphans DELETE FROM T2 WHERE FKID NOT IN (SELECT ID FROM T1); --Enabling the CONSTRAINT succeeds ALTER TABLE T2 WITH CHECK CHECK CONSTRAINT FK_T2_T1; --succeeds; orphans removed --Clean up DROP TABLE T2; DROP TABLE T1;
select * from sys.foreign_keys where is_not_trusted = 1 ; select * from sys.check_constraints where is_not_trusted = 1 ;
ALTER TABLE [Production].[ProductCostHistory] WITH CHECK -- This means "Check the existing data in the table". CHECK CONSTRAINT -- This means "enable the check or foreign key constraint". [FK_ProductCostHistory_Product_ProductID] -- The name of the check or foreign key constraint, or "ALL".
;WITH Untrusted (ConstraintType, ConstraintName, ConstraintTable, ParentTable, IsDisabled, IsNotForReplication, IsNotTrusted, RowIndex) AS ( SELECT , fk.name AS FKName , OBJECT_NAME( fk.parent_object_id) AS FKTableName , OBJECT_NAME( fk.referenced_object_id) AS PKTableName , fk.is_disabled , fk.is_not_for_replication , fk.is_not_trusted , ROW_NUMBER() OVER (ORDER BY OBJECT_NAME( fk.parent_object_id), OBJECT_NAME( fk.referenced_object_id), fk.name) AS RowIndex FROM sys.foreign_keys fk WHERE is_ms_shipped = 0 AND fk.is_not_trusted = 1 UNION ALL SELECT , cc.name AS CKName , OBJECT_NAME( cc.parent_object_id) AS CKTableName , NULL AS ParentTable , cc.is_disabled , cc.is_not_for_replication , cc.is_not_trusted , ROW_NUMBER() OVER (ORDER BY OBJECT_NAME( cc.parent_object_id), cc.name) AS RowIndex FROM sys.check_constraints cc WHERE cc.is_ms_shipped = 0 AND cc.is_not_trusted = 1 ) SELECT u.ConstraintType , u.ConstraintName , u.ConstraintTable , u.ParentTable , u.IsDisabled , u.IsNotForReplication , u.IsNotTrusted , u.RowIndex , + + + + + + FROM Untrusted u CROSS APPLY (SELECT COUNT(*) AS CommandCount FROM Untrusted WHERE ConstraintType = u.ConstraintType) x ORDER BY ConstraintType, ConstraintTable, ParentTable;
with fs as ( select database_id, type, size * 8.0 / 1024 size from sys.master_files ) select name, (select sum(size) from fs where type = 0 and fs.database_id = db.database_id) DataFileSizeMB, (select sum(size) from fs where type = 1 and fs.database_id = db.database_id) LogFileSizeMB from sys.databases db
SELECT DB_NAME(db.database_id) DatabaseName, (CAST(mfrows.RowSize AS FLOAT)*8)/1024 RowSizeMB, (CAST(mflog.LogSize AS FLOAT)*8)/1024 LogSizeMB, (CAST(mfstream.StreamSize AS FLOAT)*8)/1024 StreamSizeMB, (CAST(mftext.TextIndexSize AS FLOAT)*8)/1024 TextIndexSizeMB FROM sys.databases db LEFT JOIN (SELECT database_id, SUM(size) RowSize FROM sys.master_files WHERE type = 0 GROUP BY database_id, type) mfrows ON mfrows.database_id = db.database_id LEFT JOIN (SELECT database_id, SUM(size) LogSize FROM sys.master_files WHERE type = 1 GROUP BY database_id, type) mflog ON mflog.database_id = db.database_id LEFT JOIN (SELECT database_id, SUM(size) StreamSize FROM sys.master_files WHERE type = 2 GROUP BY database_id, type) mfstream ON mfstream.database_id = db.database_id LEFT JOIN (SELECT database_id, SUM(size) TextIndexSize FROM sys.master_files WHERE type = 4 GROUP BY database_id, type) mftext ON mftext.database_id = db.database_id
DatabaseName RowSizeMB LogSizeMB StreamSizeMB TextIndexSizeMB ------------- --------- --------- ------------ --------------- master 4 1.25 NULL NULL model 2.25 0.75 NULL NULL msdb 14.75 8.1875 NULL NULL tempdb 8 0.5 NULL NULL
SELECT D.name, F.Name AS FileType, F.physical_name AS PhysicalFile, F.state_desc AS OnlineStatus, CAST((F.size*8)/1024 AS VARCHAR(26)) + CAST(F.size*8 AS VARCHAR(32)) + FROM sys.master_files F INNER JOIN sys.databases D ON D.database_id = F.database_id ORDER BY D.name
SELECT DB_NAME(db.database_id) DatabaseName, (CAST(mfrows.RowSize AS FLOAT)*8)/1024 RowSizeMB, (CAST(mflog.LogSize AS FLOAT)*8)/1024 LogSizeMB, (CAST(mfrows.RowSize AS FLOAT)*8)/1024/1024+(CAST(mflog.LogSize AS FLOAT)*8)/1024/1024 DBSizeG, (CAST(mfstream.StreamSize AS FLOAT)*8)/1024 StreamSizeMB, (CAST(mftext.TextIndexSize AS FLOAT)*8)/1024 TextIndexSizeMB FROM sys.databases db LEFT JOIN (SELECT database_id, SUM(size) RowSize FROM sys.master_files WHERE type = 0 GROUP BY database_id, type) mfrows ON mfrows.database_id = db.database_id LEFT JOIN (SELECT database_id, SUM(size) LogSize FROM sys.master_files WHERE type = 1 GROUP BY database_id, type) mflog ON mflog.database_id = db.database_id LEFT JOIN (SELECT database_id, SUM(size) StreamSize FROM sys.master_files WHERE type = 2 GROUP BY database_id, type) mfstream ON mfstream.database_id = db.database_id LEFT JOIN (SELECT database_id, SUM(size) TextIndexSize FROM sys.master_files WHERE type = 4 GROUP BY database_id, type) mftext ON mftext.database_id = db.database_id ORDER BY 4 DESC
select d.name, case when m.type = 0 then from sys.master_files m JOIN sys.databases d ON d.database_id = m.database_id
select d.name, m.size * 8 / 1024 from sys.master_files m JOIN sys.databases d ON d.database_id = m.database_id and m.type =0
SELECT DB.name, SUM(CASE WHEN type = 0 THEN MF.size * 8 / 1024 ELSE 0 END) AS DataFileSizeMB, SUM(CASE WHEN type = 1 THEN MF.size * 8 / 1024 ELSE 0 END) AS LogFileSizeMB FROM sys.master_files MF JOIN sys.databases DB ON DB.database_id = MF.database_id GROUP BY DB.name ORDER BY DataFileSizeMB DESC
DECLARE @spacetable table ( database_name varchar(50) , total_size_data int, space_util_data int, space_data_left int, percent_fill_data float, total_size_data_log int, space_util_log int, space_log_left int, percent_fill_log char(50), [total db size] int, [total size used] int, [total size left] int ) insert into @spacetable EXECUTE master.sys.sp_MSforeachdb select x.[DATABASE NAME],x.[total size data],x.[space util],x.[total size data]-x.[space util] [space left data], x.[percent fill],y.[total size log],y.[space util], y.[total size log]-y.[space util] [space left log],y.[percent fill], y.[total size log]+x.[total size data] ,x.[space util]+y.[space util] (y.[total size log]+x.[total size data])-(y.[space util]+x.[space util]) from (select DB_NAME() sum(size*8/1024) ,case when sum(size*8/1024)=0 then substring(cast((sum(FILEPROPERTY(name, from sys.master_files where database_id=DB_ID(DB_NAME()) and type=0 group by type_desc ) as x , (select sum(size*8/1024) ,case when sum(size*8/1024)=0 then substring(cast((sum(FILEPROPERTY(name, from sys.master_files where database_id=DB_ID(DB_NAME()) and type=1 group by type_desc )y' select * from @spacetable order by database_name
SELECT DB_NAME(db.database_id) DatabaseName, (CAST(mfrows.RowSize AS FLOAT)*8)/1024 RowSizeMB, (CAST(mflog.LogSize AS FLOAT)*8)/1024 LogSizeMB FROM sys.databases db LEFT JOIN (SELECT database_id, SUM(size) RowSize FROM sys.master_files WHERE type = 0 GROUP BY database_id, type) mfrows ON mfrows.database_id = db.database_id LEFT JOIN (SELECT database_id, SUM(size) LogSize FROM sys.master_files WHERE type = 1 GROUP BY database_id, type) mflog ON mflog.database_id = db.database_id where DB_NAME(db.database_id) not like and DB_NAME(db.database_id) not like and DB_NAME(db.database_id) not like and DB_NAME(db.database_id) not like and DB_NAME(db.database_id) not like and DB_NAME(db.database_id) not like order by DB_NAME(db.database_id)
select d.name, sum(m0.size*8.0/1024) data_file_size_mb, sum(m1.size*8.0/1024) log_file_size_mb from sys.databases d inner join sys.master_files m0 on m0.database_id = d.database_id inner join sys.master_files m1 on m1.database_id = d.database_id where m0.type = 0 and m1.type = 1 group by d.name, d.database_id order by d.database_id
IF OBJECT_ID( DROP TABLE CREATE TABLE database_id INT PRIMARY KEY , data_used_size DECIMAL(18,2) , log_used_size DECIMAL(18,2) ) DECLARE @SQL NVARCHAR(MAX) SELECT @SQL = STUFF(( SELECT ' USE [ INSERT INTO SELECT DB_ID() , SUM(CASE WHEN [type] = 0 THEN space_used END) , SUM(CASE WHEN [type] = 1 THEN space_used END) FROM ( SELECT s.[type], space_used = SUM(FILEPROPERTY(s.name, FROM sys.database_files s GROUP BY s.[type] ) t;' FROM sys.databases d WHERE d.[state] = 0 FOR XML PATH( EXEC sys.sp_executesql @SQL SELECT d.database_id , d.name , d.state_desc , d.recovery_model_desc , t.total_size , t.data_size , s.data_used_size , t.log_size , s.log_used_size FROM ( SELECT database_id , log_size = CAST(SUM(CASE WHEN [type] = 1 THEN size END) * 8. / 1024 AS DECIMAL(18,2)) , data_size = CAST(SUM(CASE WHEN [type] = 0 THEN size END) * 8. / 1024 AS DECIMAL(18,2)) , total_size = CAST(SUM(size) * 8. / 1024 AS DECIMAL(18,2)) FROM sys.master_files GROUP BY database_id ) t JOIN sys.databases d ON d.database_id = t.database_id LEFT JOIN ORDER BY t.total_size DESC
go declare @Results table ([Name] nvarchar(max), [DataFileSizeMB] int, [LogFileSizeMB] int); declare @QaQuery nvarchar(max) declare @name nvarchar(max) declare MY_CURSOR cursor local static read_only forward_only for select name from master.dbo.sysdatabases where name not in ( open MY_CURSOR fetch next from MY_CURSOR into @name while @@FETCH_STATUS = 0 begin if(len(@name)>0) begin print @name + set @QaQuery = N ,sum(case when type = 0 then size else 0 end) as DataFileSizeMB ,sum(case when type = 1 then size else 0 end) as LogFileSizeMB from [ group by replace(name, insert @Results exec sp_executesql @QaQuery; end fetch next from MY_CURSOR into @name end close MY_CURSOR deallocate MY_CURSOR select * from @Results order by DataFileSizeMB desc go
DECLARE @someInt int INSERT INTO MyTable2(AIntColumn) OUTPUT @SomeInt = Inserted.AIntColumn VALUES(12)
declare @ID table (ID int) insert into MyTable2(ID) output inserted.ID into @ID values (1)
INSERT INTO T_TESTS (TestId, FirstName, LastName, Age) VALUES ( INSERT INTO T_TESTS (TestId, FirstName, LastName, Age) VALUES ( ... INSERT INTO T_TESTS (TestId, FirstName, LastName, Age) VALUES (
INSERT INTO T_TESTS (TestId, FirstName, LastName, Age) VALUES ( ( ... (
+------+----------------+-------------+---------------+---------------+ | Rows | CachedPlanSize | CompileTime | CompileMemory | Duration/Rows | +------+----------------+-------------+---------------+---------------+ | 245 | 528 | 41 | 2400 | 0.167346939 | | 246 | 528 | 40 | 2416 | 0.162601626 | | 247 | 528 | 38 | 2416 | 0.153846154 | | 248 | 528 | 39 | 2432 | 0.157258065 | | 249 | 528 | 39 | 2432 | 0.156626506 | | 250 | 528 | 40 | 2448 | 0.16 | | 251 | 400 | 273 | 3488 | 1.087649402 | | 252 | 400 | 274 | 3496 | 1.087301587 | | 253 | 400 | 282 | 3520 | 1.114624506 | | 254 | 408 | 279 | 3544 | 1.098425197 | | 255 | 408 | 290 | 3552 | 1.137254902 | +------+----------------+-------------+---------------+---------------+
sqlservr.exe!FastDBCSToUnicode() + 0xac bytes sqlservr.exe!nls_sqlhilo() + 0x35 bytes sqlservr.exe!CXVariant::CmpCompareStr() + 0x2b bytes sqlservr.exe!CXVariantPerformCompare<167,167>::Compare() + 0x18 bytes sqlservr.exe!CXVariant::CmpCompare() + 0x11f67d bytes sqlservr.exe!CConstraintItvl::PcnstrItvlUnion() + 0xe2 bytes sqlservr.exe!CConstraintProp::PcnstrUnion() + 0x35e bytes sqlservr.exe!CLogOp_BaseSetOp::PcnstrDerive() + 0x11a bytes sqlservr.exe!CLogOpArg::PcnstrDeriveHandler() + 0x18f bytes sqlservr.exe!CLogOpArg::DeriveGroupProperties() + 0xa9 bytes sqlservr.exe!COpArg::DeriveNormalizedGroupProperties() + 0x40 bytes sqlservr.exe!COptExpr::DeriveGroupProperties() + 0x18a bytes sqlservr.exe!COptExpr::DeriveGroupProperties() + 0x146 bytes sqlservr.exe!COptExpr::DeriveGroupProperties() + 0x146 bytes sqlservr.exe!COptExpr::DeriveGroupProperties() + 0x146 bytes sqlservr.exe!CQuery::PqoBuild() + 0x3cb bytes sqlservr.exe!CStmtQuery::InitQuery() + 0x167 bytes sqlservr.exe!CStmtDML::InitNormal() + 0xf0 bytes sqlservr.exe!CStmtDML::Init() + 0x1b bytes sqlservr.exe!CCompPlan::FCompileStep() + 0x176 bytes sqlservr.exe!CSQLSource::FCompile() + 0x741 bytes sqlservr.exe!CSQLSource::FCompWrapper() + 0x922be bytes sqlservr.exe!CSQLSource::Transform() + 0x120431 bytes sqlservr.exe!CSQLSource::Compile() + 0x2ff bytes
SELECT * FROM (VALUES ( ( ( ORDER BY name, 1/ (ID - ID)
BEGIN TRAN; INSERT INTO T_TESTS (TestId, FirstName, LastName, Age) VALUES ( INSERT INTO T_TESTS (TestId, FirstName, LastName, Age) VALUES ( ... INSERT INTO T_TESTS (TestId, FirstName, LastName, Age) VALUES ( COMMIT TRAN;
Method 1 Method 2 Method 3 Single Insert Multi Insert Joined Inserts Rows 1000 1000 1000 Insert 390 ms 765 ms 270 ms per Row 0.390 ms 0.765 ms 0.27 ms
CREATE FUNCTION ActionState_Preassigned() RETURNS tinyint AS BEGIN RETURN 0 END GO CREATE FUNCTION ActionState_Unassigned() RETURNS tinyint AS BEGIN RETURN 1 END -- etc...
WITH cte1 AS ( SELECT 1 AS id ), cte2 AS ( SELECT 2 AS id ) SELECT * FROM cte1 UNION ALL SELECT * FROM cte2 UNION ALL SELECT * FROM cte1
WITH CategoryAndNumberOfProducts (CategoryID, CategoryName, NumberOfProducts) AS ( SELECT CategoryID, CategoryName, (SELECT COUNT(1) FROM Products p WHERE p.CategoryID = c.CategoryID) as NumberOfProducts FROM Categories c ), ProductsOverTenDollars (ProductID, CategoryID, ProductName, UnitPrice) AS ( SELECT ProductID, CategoryID, ProductName, UnitPrice FROM Products p WHERE UnitPrice > 10.0 ) SELECT c.CategoryName, c.NumberOfProducts, p.ProductName, p.UnitPrice FROM ProductsOverTenDollars p INNER JOIN CategoryAndNumberOfProducts c ON p.CategoryID = c.CategoryID ORDER BY ProductName
select * from Common where common_id not in (select common_id from Table1) and common_id not in (select common_id from Table2)
SELECT * FROM common LEFT JOIN table1 t1 ON t1.common_id = common.common_id WHERE t1.common_id IS NULL
SELECT * FROM common WHERE NOT EXISTS ( SELECT NULL FROM table1 t1 WHERE t1.common_id = common.common_id )
SELECT * FROM common WHERE common_id NOT IN ( SELECT common_id FROM table1 t1 )
common_id = ANY ( SELECT common_id FROM table1 t1 )
common_id not in ( select common_id from Table1 where common_id is not null )
select * from Common where common_id not in (select common_id from Table1 where common_id is not null) and common_id not in (select common_id from Table2 where common_id is not null)
select * from Common c where not exists (select t1.commonid from table1 t1 where t1.commonid = c.commonid) and not exists (select t2.commonid from table2 t2 where t2.commonid = c.commonid)
SELECT T.common_id FROM Common T LEFT JOIN Table1 T1 ON T.common_id = T1.common_id LEFT JOIN Table2 T2 ON T.common_id = T2.common_id WHERE T1.common_id IS NULL AND T2.common_id IS NULL
select c.commonID, t1.commonID, t2.commonID from Common c left outer join Table1 t1 on t1.commonID = c.commonID left outer join Table2 t2 on t2.commonID = c.commonID where t1.commonID is null and t2.commonID is null
select * from Common where 1 not in (2) and 1 not in (3, null)
select * from Common where not (1=2) and not (1=3 or 1=null)
select * from Common where not (false) and not (false or unkown)
select * from Common where not exists (select common_id from Table1 where common_id = Common.common_id) and not exists (select common_id from Table2 where common_id = Common.common_id)
select *, (select COUNT(ID) from ProductMaster where ProductMaster.CatID = CategoryMaster.ID) as coun from CategoryMaster
SELECT (InvoiceTotal - PaymentTotal - CreditTotal) AS BalanceDue FROM Invoices WHERE BalanceDue > 0 --error
SELECT BalanceDue FROM ( SELECT (InvoiceTotal - PaymentTotal - CreditTotal) AS BalanceDue FROM Invoices ) AS x WHERE BalanceDue > 0;
SELECT (InvoiceTotal - PaymentTotal - CreditTotal) AS BalanceDue FROM Invoices WHERE (InvoiceTotal - PaymentTotal - CreditTotal) > 0;
SELECT LEN(name) + column_id AS x FROM sys.all_columns WHERE LEN(name) + column_id > 30; SELECT x FROM ( SELECT LEN(name) + column_id AS x FROM sys.all_columns ) AS x WHERE x > 30; SELECT LEN(name) + column_id AS x FROM sys.all_columns WHERE column_id + LEN(name) > 30; SELECT name, column_id, x FROM ( SELECT name, column_id, LEN(name) + column_id AS x FROM sys.all_columns ) AS x WHERE x > 30; SELECT name, column_id, x FROM ( SELECT name, column_id, LEN(name) + column_id AS x FROM sys.all_columns ) AS x WHERE LEN(name) + column_id > 30;
SELECT c.BalanceDue AS BalanceDue FROM Invoices cross apply (select (InvoiceTotal - PaymentTotal - CreditTotal) as BalanceDue) as c WHERE c.BalanceDue > 0;
SELECT vars.BalanceDue FROM Entity e OUTER APPLY ( SELECT -- variables BalanceDue = e.EntityTypeId, Variable2 = ...some..long..complex..expression..etc... ) vars WHERE vars.BalanceDue > 0
DECLARE @i NVARCHAR(800) SELECT @i = REPLICATE( SELECT @i = PRINT @i EXEC(@i)
attribute_id | attribute_name | attribute_value -------------|-----------------------|----------------------------------- 1 | DBMS_NAME | Microsoft SQL Server 2 | DBMS_VER | Microsoft SQL Server 2012 - 11.0.6020.0 10 | OWNER_TERM | owner 11 | TABLE_TERM | table 12 | MAX_OWNER_NAME_LENGTH | 128 13 | TABLE_LENGTH | 128 14 | MAX_QUAL_LENGTH | 128 15 | COLUMN_LENGTH | 128 16 | IDENTIFIER_CASE | MIXED ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮ ⋮
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N BEGIN CREATE TABLE [dbo].[YourTable]( .... .... .... ) END
IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = N BEGIN CREATE TABLE [SchemaName].[YourTable]( .... .... .... ) END
CREATE DATABASE Test GO USE Test GO CREATE TABLE dbo.tblTest (Id INT, Name NVARCHAR(50))
IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = N BEGIN PRINT END
IF EXISTS (SELECT * FROM Test.INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = N BEGIN PRINT END
IF EXISTS(SELECT 1 FROM sys.Objects WHERE Object_id = OBJECT_ID(N BEGIN PRINT END
IF EXISTS(SELECT 1 FROM sys.Tables WHERE Name = N BEGIN PRINT END
IF EXISTS(SELECT name FROM sys.sysobjects WHERE Name = N BEGIN PRINT END
IF (EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = BEGIN declare @result int set @result=1 select @result as result END
If not exists (select name from sysobjects where name =
if not exists (Select 1 from tableName) create table ...
GO SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON; SET NUMERIC_ROUNDABORT OFF; GO :setvar DatabaseName "MesProduction_Preloaded_KLM_MesSap"
insert into MyTable select * from MyTable where uniqueId = @Id;
insert into MyTable(field1, field2, id_backup) select field1, field2, uniqueId from MyTable where uniqueId = @Id;
SELECT * INTO TempTable FROM MyTable_T WHERE id = 1; ALTER TABLE TempTable DROP COLUMN id; INSERT INTO MyTable_T SELECT * FROM TempTable; DROP TABLE TempTable;
use MyDatabase; SELECT * INTO ALTER TABLE INSERT INTO [MyTable] SELECT * FROM DROP TABLE
INSERT INTO MyTable (FIELD2, FIELD3, ..., FIELD529, PreviousId) SELECT FIELD2, NULL, ..., FIELD529, FIELD1 FROM MyTable WHERE FIELD1 = @Id;
insert into MyTable (uniqueId, column1, column2, referencedUniqueId) select NewGuid(), column1, column2, uniqueId, from MyTable where uniqueId = @Id
insert into MyTable (field1, field2, field3, parentkey) select field1, field2, null, key from MyTable where uniqueId = @Id
INSERT INTO DENI/FRIEN01P SELECT RCRDID+112, PROFESION, NAME, SURNAME, AGE, RCRDTYP, RCRDLCU, RCRDLCT, RCRDLCD FROM FRIEN01P
SQLcolums = "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE (TABLE_NAME = Set GetColumns = Conn.Execute(SQLcolums) Do WHILE not GetColumns.eof colName = GetColumns("COLUMN_NAME")
IF colName = "ORIGINAL-IDENTITY-FIELD-NAME" THEN columnListSOURCE = colName columnListTARGET = "[PreviousId field name]" ELSE columnListSOURCE = columnListSOURCE & colName columnListTARGET = columnListTARGET & colName END IF GetColumns.movenext loop GetColumns.close
SQL = "INSERT INTO TARGET-TABLE-NAME (" & columnListTARGET & ") SELECT " & columnListSOURCE & " FROM SOURCE-TABLE-NAME WHERE (FIELDNAME = FIELDVALUE)" Conn.Execute(SQL)
SELECT * INTO UPDATE INSERT INTO SourceTable SELECT * FROM DELETE
declare @columnsToCopyValues varchar(max), @query varchar(max) SET @columnsToCopyValues = --Get all the columns execpt Identity columns and Other columns to be excluded. Say IndentityColumn, Column1, Column2 Select @columnsToCopyValues = @columnsToCopyValues + [name] + Select @columnsToCopyValues = SUBSTRING(@columnsToCopyValues, 0, LEN(@columnsToCopyValues)) print @columnsToCopyValues Select @query = CONCAT( print @query exec (@query)
Cn.Execute("CREATE TEMPORARY TABLE temprow AS SELECT * FROM product WHERE product_id = Cn.Execute("UPDATE temprow SET product_id = Cn.Execute("INSERT INTO product SELECT * FROM temprow") Cn.Execute("DELETE temprow") Cn.Execute("DROP TABLE temprow")
-- Encode the string "TestData" in Base64 to get "VGVzdERhdGE=" SELECT CAST(N , ) Base64Encoding FROM ( SELECT CAST( ) AS bin_sql_server_temp; -- Decode the Base64-encoded string "VGVzdERhdGE=" to get back "TestData" SELECT CAST( CAST(N , ) AS VARCHAR(MAX) ) ASCIIEncoding ;
DECLARE @EncodeIn VARCHAR(100) = @EncodeOut VARCHAR(500), @DecodeOut VARCHAR(200) SELECT @EncodeOut = CAST(N , ) FROM ( SELECT CAST(@EncodeIn AS VARBINARY(MAX)) AS bin ) AS bin_sql_server_temp; PRINT @EncodeOut SELECT @DecodeOut = CAST( CAST(N , ) AS VARCHAR(MAX) ) FROM ( SELECT CAST(@EncodeOut AS VARCHAR(MAX)) AS bin ) AS bin_sql_server_temp; PRINT @DecodeOut
-- To Base64 string CREATE FUNCTION [dbo].[fn_str_TO_BASE64] ( @STRING VARCHAR(MAX) ) RETURNS VARCHAR(MAX) AS BEGIN RETURN ( SELECT CAST(N , ) Base64Encoding FROM ( SELECT CAST(@STRING AS VARBINARY(MAX)) AS bin ) AS bin_sql_server_temp ) END GO -- From Base64 string CREATE FUNCTION [dbo].[fn_str_FROM_BASE64] ( @BASE64_STRING VARCHAR(MAX) ) RETURNS VARCHAR(MAX) AS BEGIN RETURN ( SELECT CAST( CAST(N AS VARCHAR(MAX) ) UTF8Encoding ) END
DECLARE @Source VARCHAR(50) = DECLARE @Encoded VARCHAR(500) = CONVERT(VARCHAR(500), (SELECT CONVERT(VARBINARY, @Source) FOR XML PATH( DECLARE @Decoded VARCHAR(500) = CONVERT(VARCHAR(500), CONVERT(XML, @Encoded).value( SELECT @Source AS [Source], @Encoded AS [Encoded], @Decoded AS [Decoded]
DECLARE @source varbinary(max), @encoded_base64 varchar(max), @decoded varbinary(max) SET @source = CONVERT(varbinary(max), -- Convert from varbinary to base64 string SET @encoded_base64 = CAST(N ("@source")) -- Convert back from base64 to varbinary SET @decoded = CAST(N ("@encoded_base64")) SELECT CONVERT(varchar(max), @source) AS [Source varchar], @source AS [Source varbinary], @encoded_base64 AS [Encoded base64], @decoded AS [Decoded varbinary], CONVERT(varchar(max), @decoded) AS [Decoded varchar]
SELECT LOWER(SUBSTRING(CONVERT(NVARCHAR(42), CAST( [COLUMN_NAME] as XML ).value(
Select Max(Len(TextCol1)) , Max(Len(TextCol2)) , Max(Len(TextCol3)) , ... From ...
Select Cast(TextCol1 As varchar(...)) , Cast(TextCol2 As varchar(...)) , Cast(TextCol3 As varchar(...)) , ... From ...
SET ANSI_WARNINGS OFF; -- Your insert TSQL here. SET ANSI_WARNINGS ON;
WITH CTE_Dev AS ( SELECT C.column_id ,ColumnName = C.NAME ,C.max_length ,C.user_type_id ,C.precision ,C.scale ,DataTypeName = T.NAME FROM sys.columns C INNER JOIN sys.types T ON T.user_type_id = C.user_type_id WHERE OBJECT_ID = OBJECT_ID( ) ,CTE_Temp AS ( SELECT C.column_id ,ColumnName = C.NAME ,C.max_length ,C.user_type_id ,C.precision ,C.scale ,DataTypeName = T.NAME FROM sys.columns C INNER JOIN sys.types T ON T.user_type_id = C.user_type_id WHERE OBJECT_ID = OBJECT_ID( ) SELECT * FROM CTE_Dev D FULL OUTER JOIN CTE_Temp T ON D.ColumnName = T.ColumnName WHERE ISNULL(D.max_length, 0) < ISNULL(T.max_length, 999)
CREATE PROCEDURE [dbo].[sp_analysetable] ( @tableName varchar(8000), @deep bit = 0 ) AS /* sp_analysetable sp_analysetable */ DECLARE @intErrorCode INT, @errorMSG VARCHAR(500), @tmpQ NVARCHAR(2000), @column_name VARCHAR(50), @isQuery bit SET @intErrorCode=0 IF OBJECT_ID( DROP TABLE END IF OBJECT_ID( DROP TABLE END if CHARINDEX( set @isQuery=1 IF @intErrorCode=0 BEGIN if @isQuery=1 begin --set @tableName = --replace only first occurance. Now multiple froms may exists, but first from will be replaced with into .. from set @tableName=Stuff(@tableName, CharIndex( exec(@tableName) IF OBJECT_ID( set @intErrorCode=1 SET @errorMSG= end else begin set @tableName= end end end IF @intErrorCode=0 BEGIN SET @tmpQ= select c.column_name as [column], cast(sp.value as varchar(1000)) as description, tc_fk.constraint_type, kcu_pk.table_name as fk_table, kcu_pk.column_name as fk_column, c.ordinal_position as pos, c.column_default as [default], c.is_nullable as [null], c.data_type, c.character_maximum_length as length, c.numeric_precision as [precision], c.numeric_precision_radix as radix, cast(null as bit) as [is_unique], cast(null as int) as min_len, cast(null as int) as max_len, cast(null as int) as nulls, cast(null as int) as blanks, cast(null as int) as numerics, cast(null as int) as distincts, cast(null as varchar(500)) as distinct_values, cast(null as varchar(50)) as remarks into if @isQuery=1 begin SET @tmpQ=@tmpQ+ end else begin SET @tmpQ=@tmpQ+' from information_schema.columns c left join sysobjects so on so.name=c.table_name and so.xtype= left join syscolumns sc on sc.name=c.column_name and sc.id =so.id left join sys.extended_properties sp on sp.minor_id = sc.colid AND sp.major_id = sc.id and sp.name= left join information_schema.key_column_usage kcu_fk on kcu_fk.table_name = c.table_name and c.column_name = kcu_fk.column_name left join information_schema.table_constraints tc_fk on kcu_fk.table_name = tc_fk.table_name and kcu_fk.constraint_name = tc_fk.constraint_name left join information_schema.referential_constraints rc on rc.constraint_name = kcu_fk.constraint_name left join information_schema.table_constraints tc_pk on rc.unique_constraint_name = tc_pk.constraint_name left join information_schema.key_column_usage kcu_pk on tc_pk.constraint_name = kcu_pk.constraint_name ' end SET @tmpQ=@tmpQ+ exec(@tmpQ) end IF @intErrorCode=0 AND @deep = 1 BEGIN DECLARE @count_rows int, @count_distinct int, @count_nulls int, @count_blanks int, @count_numerics int, @min_len int, @max_len int, @distinct_values varchar(500) DECLARE curTmp CURSOR LOCAL FAST_FORWARD FOR select [column] from OPEN curTmp FETCH NEXT FROM curTmp INTO @column_name WHILE @@FETCH_STATUS = 0 and @intErrorCode=0 BEGIN set @tmpQ = exec sp_executesql @tmpQ, N @count_distinct int OUTPUT, @count_nulls int OUTPUT, @count_blanks int OUTPUT, @count_numerics int OUTPUT, @min_len int OUTPUT, @max_len int OUTPUT @count_rows OUTPUT, @count_distinct OUTPUT, @count_nulls OUTPUT, @count_blanks OUTPUT, @count_numerics OUTPUT, @min_len OUTPUT, @max_len OUTPUT IF (@count_distinct>10) BEGIN SET @distinct_values= END ELSE BEGIN set @distinct_values=null set @tmpQ = N exec sp_executesql @tmpQ, N @distinct_values OUTPUT END UPDATE is_unique =case when @count_rows=@count_distinct then 1 else 0 end, distincts =@count_distinct, nulls =@count_nulls, blanks =@count_blanks, numerics =@count_numerics, min_len =@min_len, max_len =@max_len, distinct_values=@distinct_values, remarks = case when @count_rows=@count_nulls then case when @count_rows=@count_distinct then case when @count_distinct=0 then case when @min_len=@max_len then case when @count_rows=@count_numerics then WHERE [column]=@column_name FETCH NEXT FROM curTmp INTO @column_name END CLOSE curTmp DEALLOCATE curTmp END IF @intErrorCode=0 BEGIN select * from end IF @intErrorCode=0 BEGIN --Clean up temporary tables IF OBJECT_ID( DROP TABLE END IF OBJECT_ID( DROP TABLE END end IF @intErrorCode<>0 BEGIN RAISERROR(@errorMSG, 12, 1) END RETURN @intErrorCode
select c1.table_name,c1.COLUMN_NAME,c1.DATA_TYPE,c1.CHARACTER_MAXIMUM_LENGTH,c2.table_name,c2.COLUMN_NAME, c2.DATA_TYPE,c2.CHARACTER_MAXIMUM_LENGTH from [INFORMATION_SCHEMA].[COLUMNS] c1 left join [INFORMATION_SCHEMA].[COLUMNS] c2 on c1.COLUMN_NAME=c2.COLUMN_NAME where c1.TABLE_NAME= and c2.TABLE_NAME= --and c1.DATA_TYPE<>c2.DATA_TYPE --and c1.CHARACTER_MAXIMUM_LENGTH <> c2.CHARACTER_MAXIMUM_LENGTH order by c1.COLUMN_NAME
select Table1.[column1] ,Table1.[column2] ,SPACE(10) as column_name into table_you_are_creating from Table1 where ...
CREATE TABLE [dbo].[Department]( [Department_name] char(10) NULL ) INSERT INTO [dbo].[Department]([Department_name]) VALUES ( --error will occur ALTER TABLE [Department] ALTER COLUMN [Department_name] char(50) INSERT INTO [dbo].[Department]([Department_name]) VALUES ( select * from [Department]
EXEC dbo.GetFieldStringTruncate SourceTableName, TargetTableName
DECLARE @strSQL nvarchar(1000) IF NOT EXISTS (SELECT * FROM dbo.sysobjects where id = OBJECT_ID(N BEGIN SET @strSQL = EXEC sys.sp_executesql @strSQL END GO SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO /* ------------------------------------------------------------------------------------------------------------------------ Description: Syntax --------------- dbo.GetFieldStringTruncate(SourceTable, TargetTable) +---------------------------+-----------------------+ | SourceTableName | VARCHAR(255) | +---------------------------+-----------------------+ | TargetTableName | VARCHAR(255) | +---------------------------+-----------------------+ Arguments --------------- SourceTableName The name of the source table. It should be a temporary table using double charp TargetTableName The name of the target table. It is the table that receives the data used in the INSERT INTO stament. Return Type ---------------- Returns a table with a list of all the fields with the type defined as text and performs an evaluation indicating which field would present the problem of string truncation. Remarks ---------------- This stored procedure is oriented to the problem of text truncation when an INSERT SELECT statement is made. The operation of this stored procedure depends on the user previously identifying the INSERT statement with the problem. Then inserting the source data into a global temporary table. The SELECT INTO statement is recommended. You must use the same name of the field of the destination table in the alias of each field of the SELECT statement. Examples ==================================================================================================== --A. Test basic IF EXISTS (SELECT * FROM sys.objects WHERE OBJECT_ID = OBJECT_ID(N DROP TABLE tblDestino CREATE TABLE tblDestino ( Id INT IDENTITY, Field1 VARCHAR(10), Field2 VARCHAR(12), Field3 VARCHAR(11), Field4 VARCHAR(16), Field5 VARCHAR(5), Field6 VARCHAR(1), Field7 VARCHAR(1), Field8 VARCHAR(6), Field9 VARCHAR(6), Field10 VARCHAR(50), Field11 VARCHAR(50), Field12 VARCHAR(50) ) INSERT INTO dbo.tblDestino ( Field1 , Field2 , Field3 , Field4 , Field5 , Field6 , Field7 , Field8 , Field9 , Field10 , Field11 , Field12 ) SELECT GO Result: String or binary data would be truncated *Here you get the truncation error. Then, we proceed to save the information in a global temporary table. *IMPORTANT REMINDER: You must use the same name of the field of the destination table in the alias of each field of the SELECT statement. Process: IF OBJECT_ID( go SELECT [Field1] = [Field2] = [Field3] = [Field4] = [Field5] = [Field6] = [Field7] = [Field8] = [Field9] = [Field10] = [Field11] = [Field12] = INTO Result: (1 row(s) affected) Test: EXEC dbo.GetFieldStringTruncate @SourceTableName = Result: (12 row(s) affected) ORIGEN Nombre Campo ORIGEN Maximo Largo DESTINO Nombre Campo DESTINO Tipo de campo Evaluación -------------------------- -------------------- ------------------------ ----------------------- ------------------------- Field1 9 02 - Field1 VARCHAR(10) Field2 9 03 - Field2 VARCHAR(12) Field3 9 04 - Field3 VARCHAR(11) Field4 9 05 - Field4 VARCHAR(16) Field5 9 06 - Field5 VARCHAR(5) possible field with error Field6 9 07 - Field6 VARCHAR(1) possible field with error Field7 9 08 - Field7 VARCHAR(1) possible field with error Field8 9 09 - Field8 VARCHAR(6) possible field with error Field9 9 10 - Field9 VARCHAR(6) possible field with error Field10 9 11 - Field10 VARCHAR(50) Field11 9 12 - Field11 VARCHAR(50) Field12 9 13 - Field12 VARCHAR(50) ==================================================================================================== ------------------------------------------------------------------------------------------------------------ Responsible: Javier Pardo Date: October 19/2018 WB tests: Javier Pardo ------------------------------------------------------------------------------------------------------------ */ ALTER PROCEDURE dbo.GetFieldStringTruncate ( @SourceTableName AS VARCHAR(255) , @TargetTableName AS VARCHAR(255) ) AS BEGIN BEGIN TRY DECLARE @colsUnpivot AS NVARCHAR(MAX), @colsUnpivotConverted AS NVARCHAR(MAX), @query AS NVARCHAR(MAX) SELECT @colsUnpivot = stuff(( SELECT DISTINCT FROM tempdb.sys.tables tab INNER JOIN tempdb.sys.columns col ON col.object_id = tab.object_id INNER JOIN tempdb.sys.types typ ON col.system_type_id = TYP.system_type_id WHERE tab.NAME = @SourceTableName FOR XML path( ), 1, 1, ,@colsUnpivotConverted = stuff(( SELECT DISTINCT FROM tempdb.sys.tables tab INNER JOIN tempdb.sys.columns col ON col.object_id = tab.object_id INNER JOIN tempdb.sys.types typ ON col.system_type_id = TYP.system_type_id WHERE tab.NAME = @SourceTableName FOR XML path( ), 1, 1, --https: IF OBJECT_ID( set @query = INTO FROM ( SELECT FROM ) T UNPIVOT ( data for d in ( ) u GROUP BY u.d' PRINT @query exec sp_executesql @query; ------------------------------------------------------------------------------------------------------------ SELECT -- --, [ORIGEN Nombre Campo] = tcm.colname , [ORIGEN Maximo Largo] = tcm.maximo_largo , [DESTINO Nombre Campo] = DESTINO.[Nombre de campo] , [DESTINO Tipo de campo] = DESTINO.[Tipo de campo] , [Evaluación] = CASE WHEN DESTINO.maximo_largo < tcm.maximo_largo THEN --, * FROM tempdb.sys.tables tab INNER JOIN tempdb.sys.columns col ON col.object_id = tab.object_id INNER JOIN tempdb.sys.types typ ON col.system_type_id = TYP.system_type_id RIGHT JOIN ( SELECT column_id , [Nombre de campo] = RIGHT( , [Tipo de campo] = ISNULL(CONVERT(VARCHAR,upper(typ.name)), , [maximo_largo] = col.max_length , [colname] = col.name FROM sys.tables tab INNER JOIN sys.columns col ON col.object_id = tab.object_id INNER JOIN sys.types typ ON col.system_type_id = TYP.system_type_id WHERE tab.NAME = @TargetTableName ) AS DESTINO ON col.name = DESTINO.colname INNER JOIN ON tcm.colname = DESTINO.colname WHERE tab.NAME = @SourceTableName AND typ.name LIKE ORDER BY col.column_id END TRY BEGIN CATCH SELECT END CATCH END
Msg 2628, Level 16, State 6, Procedure ProcedureName, Line Linenumber String or binary data would be truncated in table Truncated value:
CustomerID DBColumnName Data -------------------------------------- 1 FirstName Joe 1 MiddleName S 1 LastName Smith 1 Date 12/12/2009 2 FirstName Sam 2 MiddleName S 2 LastName Freddrick 2 Date 1/12/2009 3 FirstName Jaime 3 MiddleName S 3 LastName Carol 3 Date 12/1/2009
CustomerID FirstName MiddleName LastName Date ---------------------------------------------------------------------- 1 Joe S Smith 12/12/2009 2 Sam S Freddrick 1/12/2009 3 Jaime S Carol 12/1/2009
Select CustomerID, Min(Case DBColumnName When Min(Case DBColumnName When Min(Case DBColumnName When Min(Case DBColumnName When From table Group By CustomerId
SELECT [FirstName], [MiddleName], [LastName], [Date] FROM PIVOT ( MIN([Data]) FOR [DBColumnName] IN ([FirstName], [MiddleName], [LastName], [Date]) )AS p
SET @fullsql = @fullsql + SET @fullsql = @fullsql + SET @fullsql = @fullsql + SET @fullsql = @fullsql + SET @fullsql = @fullsql + SET @fullsql = @fullsql + SET @fullsql = @fullsql + SET @fullsql = @fullsql + EXEC (@fullsql)
WITH pivot_data AS ( SELECT customerid, -- Grouping Column dbcolumnname, -- Spreading Column data -- Aggregate Column FROM pivot2 ) SELECT customerid, [firstname], [middlename], [lastname] FROM pivot_data PIVOT (max(data) FOR dbcolumnname IN ([firstname],[middlename],[lastname])) AS p;
SELECT main.CustomerID, f.Data AS FirstName, m.Data AS MiddleName, l.Data AS LastName, d.Data AS Date FROM table main INNER JOIN table f on f.CustomerID = main.CustomerID INNER JOIN table m on m.CustomerID = main.CustomerID INNER JOIN table l on l.CustomerID = main.CustomerID INNER JOIN table d on d.CustomerID = main.CustomerID WHERE f.DBColumnName = AND m.DBColumnName = AND l.DBColumnName = AND d.DBColumnName =
SELECT CUSTOMER_ID, MAX(FIRSTNAME) AS FIRSTNAME, MAX(LASTNAME) AS LASTNAME ... FROM ( SELECT CUSTOMER_ID, CASE WHEN DBCOLUMNNAME= CASE WHEN DBCOLUMNNAME= ... and so on ... GROUP BY CUSTOMER_ID ) TEMP GROUP BY CUSTOMER_ID
select * from (select [CustomerID] ,[Demographic] ,[Data] from [dbo].[pivot] ) as Ter pivot (max(Data) for Demographic in (FirstName, MiddleName, LastName, [Date]))as bro
declare @STR varchar(1000) SELECT @STr = COALESCE(@STr + + QUOTENAME(DateRange) from (select distinct DateRange, ID from
print @STr exec( pivot (avg(SalesAmt) for DateRange IN ( order by Decile
CREATE FUNCTION dbo.TryConvertInt(@Value varchar(18)) RETURNS int AS BEGIN SET @Value = REPLACE(@Value, IF ISNUMERIC(@Value + IF ( CHARINDEX( DECLARE @I bigint = CASE WHEN CHARINDEX( ELSE CONVERT(bigint, @Value) END IF ABS(@I) > 2147483647 RETURN NULL RETURN @I END GO -- Testing DECLARE @Test TABLE(Value nvarchar(50)) -- Result INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT INSERT INTO @Test SELECT SELECT Value, dbo.TryConvertInt(Value) FROM @Test
DECLARE @text AS NVARCHAR(10) SET @text = SELECT CASE WHEN ISNUMERIC(@text) = 1 THEN CAST(@text AS INT) ELSE NULL END -- returns 100 SET @text = SELECT CASE WHEN ISNUMERIC(@text) = 1 THEN CAST(@text AS INT) ELSE NULL END -- returns NULL
-- Incorrectly gives 0: SELECT CASE WHEN ISNUMERIC( -- Error (conversion failure): SELECT CASE WHEN ISNUMERIC( SELECT CASE WHEN ISNUMERIC( SELECT CASE WHEN ISNUMERIC( -- Error (overflow): SELECT CASE WHEN ISNUMERIC(
CREATE FUNCTION TryConvertInt (@text NVARCHAR(MAX)) RETURNS TABLE AS RETURN ( SELECT CASE WHEN ISNUMERIC(@text + CASE WHEN CONVERT(FLOAT, @text) BETWEEN -2147483648 AND 2147483647 THEN CONVERT(INT, @text) END END AS [Result] )
SELECT [Conversion].[Result] FROM ( VALUES ( , ( , ( , ( , ( , ( , ( , ( , ( , ( , ( , ( , ( , ( , ( , ( , ( , ( ) AS [Source] ([Text]) OUTER APPLY TryConvertInt ([Source].[Text]) AS [Conversion]
SELECT CASE WHEN @text NOT LIKE CASE WHEN LEN(@text) BETWEEN 1 AND 9 OR LEN(@text) = 10 AND @text <= THEN CAST (@text AS INT) END END
SELECT CASE WHEN @text NOT LIKE CASE WHEN LEN(@text) BETWEEN 1 AND 9 THEN CAST (@text AS INT) WHEN LEN(@text) >= 10 THEN CASE WHEN LEFT(@text, LEN(@text) - 10) NOT LIKE AND RIGHT(@text, 10) <= THEN CAST (@text AS INT) END END END
SELECT -- Positive integers (or 0): CASE WHEN @text NOT LIKE CASE WHEN LEN(@text) BETWEEN 1 AND 9 THEN CAST (@text AS INT) WHEN LEN(@text) >= 10 THEN CASE WHEN LEFT(@text, LEN(@text) - 10) NOT LIKE AND RIGHT(@text, 10) <= THEN CAST (@text AS INT) END END -- Negative integers: WHEN LEFT(@text, 1) = CASE WHEN RIGHT(@text, LEN(@text) - 1) NOT LIKE CASE WHEN LEN(@text) BETWEEN 2 AND 10 THEN CAST (@text AS INT) WHEN LEN(@text) >= 11 THEN CASE WHEN SUBSTRING(@text, 2, LEN(@text) - 11) NOT LIKE AND RIGHT(@text, 10) <= THEN CAST (@text AS INT) END END END END
dbo.TRY_CAST(Expression, Data_Type, ReturnValueIfErrorCast)
SELECT CASE WHEN dbo.TRY_CAST( THEN ELSE END AS Result;
DECLARE @strSQL NVARCHAR(1000) IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N BEGIN SET @strSQL = EXEC sys.sp_executesql @strSQL END SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO /* ------------------------------------------------------------------------------------------------------------------------ Description: Syntax --------------- dbo.TRY_CAST(Expression, Data_Type, ReturnValueIfErrorCast) +---------------------------+-----------------------+ | Expression | VARCHAR(8000) | +---------------------------+-----------------------+ | Data_Type | VARCHAR(8000) | +---------------------------+-----------------------+ | ReturnValueIfErrorCast | SQL_VARIANT = NULL | +---------------------------+-----------------------+ Arguments --------------- expression The value to be cast. Any valid expression. Data_Type The data type into which to cast expression. ReturnValueIfErrorCast Value returned if cast fails or is not supported. Required. Set the DEFAULT value by default. Return Type ---------------- Returns value cast to SQL_VARIANT type if the cast succeeds; otherwise, returns null if the parameter @pReturnValueIfErrorCast is set to DEFAULT, or that the user indicates. Remarks ---------------- dbo.TRY_CAST function simulates the TRY_CAST function reserved of SQL SERVER 2012 for using in SQL SERVER 2008. dbo.TRY_CAST function takes the value passed to it and tries to convert it to the specified Data_Type. If the cast succeeds, dbo.TRY_CAST returns the value as SQL_VARIANT type; if the cast doesn´t succees, null is returned if the parameter @pReturnValueIfErrorCast is set to DEFAULT. If the Data_Type is unsupported will return @pReturnValueIfErrorCast. dbo.TRY_CAST function requires user make an explicit CAST or CONVERT in ANY statements. This version of dbo.TRY_CAST only supports CAST for INT, DATE, NUMERIC and BIT types. Examples ==================================================================================================== --A. Test TRY_CAST function returns null SELECT CASE WHEN dbo.TRY_CAST( THEN ELSE END AS Result; GO --B. Error Cast With User Value SELECT dbo.TRY_CAST( dbo.TRY_CAST( dbo.TRY_CAST( GO --C. Additional CAST or CONVERT required in any assignment statement DECLARE @IntegerVariable AS INT SET @IntegerVariable = CAST(dbo.TRY_CAST(123, SELECT @IntegerVariable GO IF OBJECT_ID( DROP TABLE CREATE TABLE Id INT IDENTITY , FieldNumeric NUMERIC(3, 1) ) INSERT INTO dbo. SELECT CAST(dbo.TRY_CAST(12.3, SELECT * FROM DROP TABLE GO --D. Supports CAST for INT, DATE, NUMERIC and BIT types. SELECT dbo.TRY_CAST(2147483648, , dbo.TRY_CAST(2147483647, , SQL_VARIANT_PROPERTY(dbo.TRY_CAST(212, SELECT dbo.TRY_CAST( , dbo.TRY_CAST( , SQL_VARIANT_PROPERTY(dbo.TRY_CAST( SELECT dbo.TRY_CAST(1.23, , dbo.TRY_CAST(12.3, , SQL_VARIANT_PROPERTY(dbo.TRY_CAST(12.3, SELECT dbo.TRY_CAST( , dbo.TRY_CAST(1, , SQL_VARIANT_PROPERTY(dbo.TRY_CAST( GO --E. B. TRY_CAST return NULL on unsupported data_types SELECT dbo.TRY_CAST(4, GO ==================================================================================================== ------------------------------------------------------------------------------------------------------------------------ Responsible: Javier Pardo Date: diciembre 29/2016 WB tests: Javier Pardo ------------------------------------------------------------------------------------------------------------------------ Update by: Javier Eduardo Pardo Moreno Date: febrero 16/2017 Id update: JEPM20170216 Description: Fix ISNUMERIC function makes it unreliable. SELECT dbo.TRY_CAST( Level 16, State 5, Line 16 Error converting data type varchar to float. ISNUMERIC() function treats few more characters as numeric, like: – (minus), + (plus), $ (dollar), \ (back slash), (.)dot and (,)comma Collaborator aperiooculus (http: Fix dbo.TRY_CAST( WB tests: Javier Pardo ------------------------------------------------------------------------------------------------------------------------ */ ALTER FUNCTION dbo.TRY_CAST ( @pExpression AS VARCHAR(8000), @pData_Type AS VARCHAR(8000), @pReturnValueIfErrorCast AS SQL_VARIANT = NULL ) RETURNS SQL_VARIANT AS BEGIN -------------------------------------------------------------------------------- -- INT -------------------------------------------------------------------------------- IF @pData_Type = BEGIN IF ISNUMERIC(@pExpression) = 1 AND @pExpression NOT IN ( BEGIN DECLARE @pExpressionINT AS FLOAT = CAST(@pExpression AS FLOAT) IF @pExpressionINT BETWEEN - 2147483648.0 AND 2147483647.0 BEGIN RETURN CAST(@pExpressionINT as INT) END ELSE BEGIN RETURN @pReturnValueIfErrorCast END --FIN IF @pExpressionINT BETWEEN - 2147483648.0 AND 2147483647.0 END ELSE BEGIN RETURN @pReturnValueIfErrorCast END -- FIN IF ISNUMERIC(@pExpression) = 1 END -- FIN IF @pData_Type = -------------------------------------------------------------------------------- -- DATE -------------------------------------------------------------------------------- IF @pData_Type IN ( BEGIN IF ISDATE(@pExpression) = 1 BEGIN DECLARE @pExpressionDATE AS DATETIME = cast(@pExpression AS DATETIME) IF @pData_Type = BEGIN RETURN cast(@pExpressionDATE as DATE) END IF @pData_Type = BEGIN RETURN cast(@pExpressionDATE as DATETIME) END END ELSE BEGIN DECLARE @pExpressionDATEReplaced AS VARCHAR(50) = REPLACE(REPLACE(REPLACE(@pExpression, IF ISDATE(@pExpressionDATEReplaced) = 1 BEGIN IF @pData_Type = BEGIN RETURN cast(@pExpressionDATEReplaced as DATE) END IF @pData_Type = BEGIN RETURN cast(@pExpressionDATEReplaced as DATETIME) END END ELSE BEGIN RETURN @pReturnValueIfErrorCast END END --FIN IF ISDATE(@pExpression) = 1 END --FIN IF @pData_Type = -------------------------------------------------------------------------------- -- NUMERIC -------------------------------------------------------------------------------- IF @pData_Type LIKE BEGIN IF ISNUMERIC(@pExpression) = 1 BEGIN DECLARE @TotalDigitsOfType AS INT = SUBSTRING(@pData_Type,CHARINDEX( , @TotalDecimalsOfType AS INT = SUBSTRING(@pData_Type,CHARINDEX( , @TotalDigitsOfValue AS INT , @TotalDecimalsOfValue AS INT , @TotalWholeDigitsOfType AS INT , @TotalWholeDigitsOfValue AS INT SET @pExpression = REPLACE(@pExpression, SET @TotalDigitsOfValue = LEN(REPLACE(@pExpression, SET @TotalDecimalsOfValue = CASE Charindex( WHEN 0 THEN 0 ELSE Len(Cast(Cast(Reverse(CONVERT(VARCHAR(50), @pExpression, 128)) AS FLOAT) AS BIGINT)) END SET @TotalWholeDigitsOfType = @TotalDigitsOfType - @TotalDecimalsOfType SET @TotalWholeDigitsOfValue = @TotalDigitsOfValue - @TotalDecimalsOfValue -- The total digits can not be greater than the p part of NUMERIC (p, s) -- The total of decimals can not be greater than the part s of NUMERIC (p, s) -- The total digits of the whole part can not be greater than the subtraction between p and s IF (@TotalDigitsOfValue <= @TotalDigitsOfType) AND (@TotalDecimalsOfValue <= @TotalDecimalsOfType) AND (@TotalWholeDigitsOfValue <= @TotalWholeDigitsOfType) BEGIN DECLARE @pExpressionNUMERIC AS FLOAT SET @pExpressionNUMERIC = CAST (ROUND(@pExpression, @TotalDecimalsOfValue) AS FLOAT) RETURN @pExpressionNUMERIC --Returns type FLOAT END else BEGIN RETURN @pReturnValueIfErrorCast END-- FIN IF (@TotalDigitisOfValue <= @TotalDigits) AND (@TotalDecimalsOfValue <= @TotalDecimals) END ELSE BEGIN RETURN @pReturnValueIfErrorCast END --FIN IF ISNUMERIC(@pExpression) = 1 END --IF @pData_Type LIKE -------------------------------------------------------------------------------- -- BIT -------------------------------------------------------------------------------- IF @pData_Type LIKE BEGIN IF ISNUMERIC(@pExpression) = 1 BEGIN RETURN CAST(@pExpression AS BIT) END ELSE BEGIN RETURN @pReturnValueIfErrorCast END --FIN IF ISNUMERIC(@pExpression) = 1 END --IF @pData_Type LIKE -------------------------------------------------------------------------------- -- FLOAT -------------------------------------------------------------------------------- IF @pData_Type LIKE BEGIN IF ISNUMERIC(REPLACE(REPLACE(@pExpression, CHAR(13), BEGIN RETURN CAST(@pExpression AS FLOAT) END ELSE BEGIN IF REPLACE(@pExpression, CHAR(13), BEGIN RETURN 0 END ELSE BEGIN RETURN @pReturnValueIfErrorCast END --IF REPLACE(@pExpression, CHAR(13), END --FIN IF ISNUMERIC(@pExpression) = 1 END --IF @pData_Type LIKE -------------------------------------------------------------------------------- -- Any other unsupported data type will return NULL or the value assigned by the user to @pReturnValueIfErrorCast -------------------------------------------------------------------------------- RETURN @pReturnValueIfErrorCast END
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N DROP FUNCTION [dbo].[TryConvertInt] GO CREATE FUNCTION dbo.TryConvertInt(@Value varchar(18)) RETURNS bigint AS BEGIN DECLARE @IntValue bigint; IF (ISNUMERIC(@Value) = 1) IF (@Value like SET @IntValue = CAST(Cast(@Value as float) as bigint); ELSE SET @IntValue = CAST(CAST(@Value as money) as bigint); ELSE SET @IntValue = NULL; RETURN @IntValue; END
declare @AlpaNumber nvarchar(50) = declare @MyNumber int = 0 begin Try select @MyNumber = case when ISNUMERIC(@AlpaNumber) = 1 then cast(@AlpaNumber as int) else 0 end End Try Begin Catch -- Do nothing End Catch if exists(select * from mytable where mynumber = @MyNumber) Begin print End Else Begin print End
CREATE FUNCTION [dbo].[udfIsInteger] ( -- Add the parameters for the function here @Value nvarchar(max) ) RETURNS int AS BEGIN -- Declare the return variable here DECLARE @Result int = 0 -- Add the T-SQL statements to compute the return value here DECLARE @MinValue nvarchar(11) = DECLARE @MaxValue nvarchar(10) = SET @Value = ISNULL(@Value, IF LEN(@Value)=0 OR ISNUMERIC(@Value)<>1 OR (LEFT(@Value,1)= (LEFT(@Value,1)= (LEFT(@Value,1)<> (LEFT(@Value,1)<> GOTO FINISHED DECLARE @cnt int = 0 WHILE @cnt<LEN(@Value) BEGIN SET @cnt=@cnt+1 IF SUBSTRING(@Value,@cnt,1) NOT IN ( END SET @Result=1 FINISHED: -- Return the result of the function RETURN @Result END
SELECT mf.name ,mf.physical_name ,reverse(left(reverse(physical_name), charindex( from sys.master_files mf
DECLARE @FilePath VARCHAR(50) = DECLARE @FindChar VARCHAR(1) = -- Shows text before last slash SELECT LEFT(@FilePath, LEN(@FilePath) - CHARINDEX(@FindChar,REVERSE(@FilePath))) AS Before -- Shows text after last slash SELECT RIGHT(@FilePath, CHARINDEX(@FindChar,REVERSE(@FilePath))-1) AS After -- Shows the position of the last slash SELECT LEN(@FilePath) - CHARINDEX(@FindChar,REVERSE(@FilePath)) AS LastOccuredAt
DECLARE @FilePath VARCHAR(50) = DECLARE @FindChar VARCHAR(1) = SELECT LEN(@FilePath) - CHARINDEX(@FindChar,REVERSE(@FilePath)) AS LastOccuredAt
REVERSE(SUBSTRING(REVERSE([field]), CHARINDEX(REVERSE(
create function fnLastIndexOf(@text varChar(max),@char varchar(1)) returns int as begin return len(@text) - charindex(@char, reverse(@text)) -1 end
REVERSE(SUBSTRING(REVERSE(ap_description),CHARINDEX(
DECLARE @str CHAR(21), @delim CHAR(1) SELECT @str = @delim = SELECT MAX(n) As FROM dbo._Tally WHERE substring(@str, _Tally.n, 1) = @delim
CREATE FUNCTION [dbo].[LastIndexOf] (@stringToFind varchar(max), @stringToSearch varchar(max)) RETURNS INT AS BEGIN RETURN (LEN(@stringToSearch) - CHARINDEX(@stringToFind,REVERSE(@stringToSearch))) + 1 END GO
declare @stringToSearch varchar(max) = select dbo.LastIndexOf(
CREATE FUNCTION [dbo].[fn_LastIndexOf] (@String NVARCHAR(MAX) , @FindString NVARCHAR(MAX)) RETURNS INT AS BEGIN DECLARE @ReturnVal INT = 0 IF CHARINDEX(@FindString,@String) > 0 SET @ReturnVal = (SELECT LEN(@String) - (CHARINDEX(REVERSE(@FindString),REVERSE(@String)) + LEN(@FindString)) + 2) RETURN @ReturnVal END
DECLARE @TestString NVARCHAR(MAX) = , @TestFindString NVARCHAR(MAX) = SELECT dbo.fn_LastIndexOf(@TestString,@TestFindString)
/* http: DROP FUNCTION dbo.GetLastIndexOf */ CREATE FUNCTION dbo.GetLastIndexOf ( @expressionToFind VARCHAR(MAX) ,@expressionToSearch VARCHAR(8000) ,@Occurrence INT = 1 -- Find the nth last ) RETURNS INT AS BEGIN SELECT @expressionToSearch = REVERSE(@expressionToSearch) DECLARE @LastIndexOf INT = 0 ,@IndexOfPartial INT = -1 ,@OriginalLength INT = LEN(@expressionToSearch) ,@Iteration INT = 0 WHILE (1 = 1) -- Poor man BEGIN SELECT @IndexOfPartial = CHARINDEX(@expressionToFind, @expressionToSearch) IF (@IndexOfPartial = 0) BEGIN IF (@Iteration = 0) -- Need to compensate for dropping out early BEGIN SELECT @LastIndexOf = @OriginalLength + 1 END BREAK; END IF (@Occurrence > 0) BEGIN SELECT @expressionToSearch = SUBSTRING(@expressionToSearch, @IndexOfPartial + 1, LEN(@expressionToSearch) - @IndexOfPartial - 1) END SELECT @LastIndexOf = @LastIndexOf + @IndexOfPartial ,@Occurrence = @Occurrence - 1 ,@Iteration = @Iteration + 1 IF (@Occurrence = 0) BREAK; END SELECT @LastIndexOf = @OriginalLength - @LastIndexOf + 1 -- Invert due to reverse RETURN @LastIndexOf END GO GRANT EXECUTE ON GetLastIndexOf TO public GO
SELECT dbo.GetLastIndexOf( SELECT dbo.GetLastIndexOf( SELECT dbo.GetLastIndexOf( SELECT dbo.GetLastIndexOf(
DECLARE @Fullstring NVARCHAR(30) = DECLARE @Delimiter CHAR(1) = SELECT SUBSTRING(@Fullstring, 1, DATALENGTH(@Fullstring)/2 - CHARINDEX(@Delimiter, REVERSE(@Fullstring)));
create function dbo.lastCharIndex( @needle as varchar(max), @haystack as varchar(max), @offset as bigint=1 ) returns bigint as begin declare @position as bigint if @needle is null or @haystack is null return null set @position=charindex(reverse(@needle),reverse(@haystack),@offset) if @position=0 return 0 return (len(@haystack)-(@position+len(@needle)-1))+1 end go select dbo.lastCharIndex( select dbo.lastCharIndex( select dbo.lastCharIndex( select dbo.lastCharIndex(
-- Drop the function if it already exists IF OBJECT_ID( DROP FUNCTION INSTR GO -- User-defined function to implement Oracle INSTR in SQL Server CREATE FUNCTION INSTR (@str VARCHAR(8000), @substr VARCHAR(255), @start INT, @occurrence INT) RETURNS INT AS BEGIN DECLARE @found INT = @occurrence, @pos INT = @start; WHILE 1=1 BEGIN -- Find the next occurrence SET @pos = CHARINDEX(@substr, @str, @pos); -- Nothing found IF @pos IS NULL OR @pos = 0 RETURN @pos; -- The required occurrence found IF @found = 1 BREAK; -- Prepare to find another one occurrence SET @found = @found - 1; SET @pos = @pos + 1; END RETURN @pos; END GO
DECLARE @FilePath VARCHAR(100) = DECLARE @FindSubstring VARCHAR(5) = -- Shows text before last substing SELECT LEFT(@FilePath, LEN(@FilePath) - CHARINDEX(REVERSE(@FindSubstring), REVERSE(@FilePath)) - LEN(@FindSubstring) + 1) AS Before -- Shows text after last substing SELECT RIGHT(@FilePath, CHARINDEX(REVERSE(@FindSubstring), REVERSE(@FilePath)) -1) AS After -- Shows the position of the last substing SELECT LEN(@FilePath) - CHARINDEX(REVERSE(@FindSubstring), REVERSE(@FilePath)) AS LastOccuredAt
COALESCE(NULL, NULL, NULL, 1, 2, 3) => 1 COALESCE(1, 2, 3, 4, 5, NULL) => 1 COALESCE(NULL, NULL, NULL, 3, 2, NULL) => 3 COALESCE(6, 5, 4, 3, 2, NULL) => 6 COALESCE(NULL, NULL, NULL, NULL, NULL, NULL) => NULL
SELECT Name, Class, Color, ProductNumber, COALESCE(Class, Color, ProductNumber) AS FirstNotNull FROM Production.Product
select * from person where coalesce(addressId, ContactId) is null.
PRINT COALESCE(NULL, ( --PRINT COALESCE(NULL, PRINT COALESCE(NULL, 3, 7.0/2, 1.99) --returns 3.0, works fine as implicit conversion into FLOAT type takes place. PRINT COALESCE(NULL, DECLARE @dt DATE = getdate() PRINT COALESCE(NULL, @dt, --DATE comes before VARCHAR (works): PRINT COALESCE(NULL, @dt, --VARCHAR comes before DATE (does NOT work): PRINT COALESCE(NULL,
SET @randomId = Cast(((@maxValue + 1) - @minValue) * Rand() + @minValue AS tinyint);
Select * from parseJSON( "Person": { "firstName": "John", "lastName": "Smith", "age": 25, "Address": { "streetAddress":"21 2nd Street", "city":"New York", "state":"NY", "postalCode":"10021" }, "PhoneNumbers": { "home":"212 555-1234", "fax":"646 555-4567" } } }
[ { "id" : 2,"name": "John"}, { "id" : 5,"name": "John"} ]
INSERT INTO YourTable (id, Name) SELECT id, name FROM OPENJSON(@pJson) WITH (id int, name nvarchar(max))
CREATE FUNCTION dbo.parseJSON( @JSON NVARCHAR(MAX)) RETURNS @hierarchy TABLE ( element_id INT IDENTITY(1, 1) NOT NULL, sequenceNo [int] NULL, parent_ID INT, Object_ID INT, NAME NVARCHAR(2000), StringValue NVARCHAR(MAX) NOT NULL, ValueType VARCHAR(10) NOT null ) AS BEGIN DECLARE @FirstObject INT, --the index of the first open bracket found in the JSON string @OpenDelimiter INT,--the index of the next open bracket found in the JSON string @NextOpenDelimiter INT,--the index of subsequent open bracket found in the JSON string @NextCloseDelimiter INT,--the index of subsequent close bracket found in the JSON string @Type NVARCHAR(10),--whether it denotes an object or an array @NextCloseDelimiterChar CHAR(1),--either a @Contents NVARCHAR(MAX), --the unparsed contents of the bracketed expression @Start INT, --index of the start of the token that you are parsing @end INT,--index of the end of the token that you are parsing @param INT,--the parameter at the end of the next Object/Array token @EndOfName INT,--the index of the start of the parameter at end of Object/Array token @token NVARCHAR(200),--either a string or object @value NVARCHAR(MAX), -- the value as a string @SequenceNo int, -- the sequence number within a list @name NVARCHAR(200), --the name as a string @parent_ID INT,--the next parent ID to allocate @lenJSON INT,--the current length of the JSON String @characters NCHAR(36),--used to convert hex to decimal @result BIGINT,--the value of the hex symbol being parsed @index SMALLINT,--used for parsing the hex value @Escape INT --the index of the next escape character DECLARE @Strings TABLE ( String_ID INT IDENTITY(1, 1), StringValue NVARCHAR(MAX) ) SELECT--initialise the characters to convert hex to ascii @characters= @SequenceNo=0, --set the sequence no. to something sensible. @parent_ID=0; WHILE 1=1 --forever until there is nothing more to do BEGIN SELECT @start=PATINDEX( IF @start=0 BREAK --no more so drop through the WHILE loop IF SUBSTRING(@json, @start+1, 1)= BEGIN --Delimited Name SET @start=@Start+1; SET @end=PATINDEX( END IF @end=0 --no end delimiter to last string BREAK --no more SELECT @token=SUBSTRING(@json, @start+1, @end-1) --now put in the escaped control characters SELECT @token=REPLACE(@token, FROMString, TOString) FROM (SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT ) substitutions SELECT @result=0, @escape=1 --Begin to take out any hex escape codes WHILE @escape>0 BEGIN SELECT @index=0, --find the next hex escape sequence @escape=PATINDEX( IF @escape>0 --if there is one BEGIN WHILE @index<4 --there are always four digits to a \x sequence BEGIN SELECT --determine its value @result=@result+POWER(16, @index) *(CHARINDEX(SUBSTRING(@token, @escape+2+3-@index, 1), @characters)-1), @index=@index+1 ; END -- and replace the hex sequence by its unicode value SELECT @token=STUFF(@token, @escape, 6, NCHAR(@result)) END END --now store the string away INSERT INTO @Strings (StringValue) SELECT @token -- and replace the string with a token SELECT @JSON=STUFF(@json, @start, @end+1, END -- all strings are now removed. Now we find the first leaf. WHILE 1=1 --forever until there is nothing more to do BEGIN SELECT @parent_ID=@parent_ID+1 --find the first object or list by looking for the open bracket SELECT @FirstObject=PATINDEX( IF @FirstObject = 0 BREAK IF (SUBSTRING(@json, @FirstObject, 1)= SELECT @NextCloseDelimiterChar= ELSE SELECT @NextCloseDelimiterChar= SELECT @OpenDelimiter=@firstObject WHILE 1=1 --find the innermost object or list... BEGIN SELECT @lenJSON=LEN(@JSON+ --find the matching close-delimiter proceeding after the open-delimiter SELECT @NextCloseDelimiter=CHARINDEX(@NextCloseDelimiterChar, @json, @OpenDelimiter+1) --is there an intervening open-delimiter of either type SELECT @NextOpenDelimiter=PATINDEX( RIGHT(@json, @lenJSON-@OpenDelimiter)collate SQL_Latin1_General_CP850_Bin)--object IF @NextOpenDelimiter=0 BREAK SELECT @NextOpenDelimiter=@NextOpenDelimiter+@OpenDelimiter IF @NextCloseDelimiter<@NextOpenDelimiter BREAK IF SUBSTRING(@json, @NextOpenDelimiter, 1)= SELECT @NextCloseDelimiterChar= ELSE SELECT @NextCloseDelimiterChar= SELECT @OpenDelimiter=@NextOpenDelimiter END ---and parse out the list or name/value pairs SELECT @contents=SUBSTRING(@json, @OpenDelimiter+1, @NextCloseDelimiter-@OpenDelimiter-1) SELECT @JSON=STUFF(@json, @OpenDelimiter, @NextCloseDelimiter-@OpenDelimiter+1, WHILE (PATINDEX( BEGIN IF @Type= BEGIN SELECT @SequenceNo=0,@end=CHARINDEX( SELECT @start=PATINDEX( SELECT @token=SUBSTRING( @endofname=PATINDEX( @param=RIGHT(@token, LEN(@token)-@endofname+1) SELECT @token=LEFT(@token, @endofname-1), @Contents=RIGHT( SELECT @name=stringvalue FROM @strings WHERE string_id=@param --fetch the name END ELSE SELECT @Name=null,@SequenceNo=@SequenceNo+1 SELECT @end=CHARINDEX( IF @end=0 SELECT @end=PATINDEX( +1 SELECT @start=PATINDEX( --select @start,@end, LEN(@contents+ SELECT @Value=RTRIM(SUBSTRING(@contents, @start, @End-@Start)), @Contents=RIGHT(@contents+ IF SUBSTRING(@value, 1, 7)= INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, Object_ID, ValueType) SELECT @name, @SequenceNo, @parent_ID, SUBSTRING(@value, 8, 5), SUBSTRING(@value, 8, 5), ELSE IF SUBSTRING(@value, 1, 6)= INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, Object_ID, ValueType) SELECT @name, @SequenceNo, @parent_ID, SUBSTRING(@value, 7, 5), SUBSTRING(@value, 7, 5), ELSE IF SUBSTRING(@value, 1, 7)= INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, ValueType) SELECT @name, @SequenceNo, @parent_ID, stringvalue, FROM @strings WHERE string_id=SUBSTRING(@value, 8, 5) ELSE IF @value IN ( INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, ValueType) SELECT @name, @SequenceNo, @parent_ID, @value, ELSE IF @value= INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, ValueType) SELECT @name, @SequenceNo, @parent_ID, @value, ELSE IF PATINDEX( INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, ValueType) SELECT @name, @SequenceNo, @parent_ID, @value, ELSE INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, ValueType) SELECT @name, @SequenceNo, @parent_ID, @value, if @Contents= END END INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, Object_ID, ValueType) SELECT -- RETURN END GO
Declare @pars varchar(MAX) = "geofenceCategory":"1","color":" "lat":"26.096254906968525","lon":"65.709228515625"} ,{"lat":"28.38173504322308","lon":"66.741943359375"} ,{"lat":"26.765230565697482","lon":"68.983154296875"} ,{"lat":"26.254009699865737","lon":"68.609619140625"} ,{"lat":"25.997549919572112","lon":"68.104248046875"} ,{"lat":"26.843677401113002","lon":"67.115478515625"} ,{"lat":"25.363882272740255","lon":"65.819091796875"}]}]}]}' Select * from parseJSON(@pars) AS MyResult
CREATE PROC [dbo].[spUpdateMarks] @inputJSON VARCHAR(MAX) -- AS BEGIN -- Temp table to hold the parsed data DECLARE @TempTableVariable TABLE( element_id INT, sequenceNo INT, parent_ID INT, [Object_ID] INT, [NAME] NVARCHAR(2000), StringValue NVARCHAR(MAX), ValueType NVARCHAR(10) ) -- Parse JSON string into a temp table INSERT INTO @TempTableVariable SELECT * FROM parseJSON(@inputJSON) END
select count(*) from temptable group by column_1, column_2, column_3, column_4
select count(*) RecordsPerGroup, COUNT(*) OVER () AS TotalRecords from temptable group by column_1, column_2, column_3, column_4
Select Count(*) From ( Select ... From TempTable Group By column_1, column_2, column_3, column_4 ) As Z
Select ... , ( Select Count( Distinct column_1, column_2, column_3, column_4 ) From TempTable ) As CountOfItems From TempTable Group By column_1, column_2, column_3, column_4
select count ( distinct column_1, column_2, column_3, column_4) from temptable
SELECT DISTINCT COUNT(*) OVER () AS TotalRecords FROM temptable GROUP BY column_1, column_2, column_3, column_4
with cte as ( select 1 col1 from temptable group by column_1 ) select COUNT(col1) from cte;
SELECT count(column_1) FROM (SELECT * FROM temptable GROUP BY column_1, column_2, column_3, column_4) AS Records
select sum(counts) total_records from ( select count(*) as counts from temptable group by column_1, column_2, column_3, column_4 ) as tmp
select count(count.counts) from (select count(*) as counts from table group by concept) as count;
SELECT COUNT(COUNT(*)) FROM temptable GROUP BY column_1, column_2, column_3, column_4
select column_group_by,count(*) as Coulm_name_to_be_displayed from Table group by Column; -- For example: select city,count(*) AS Count from people group by city
select top 1 TotalRows = count(*) over () from yourTable group by column1, column2
select * , concat(cast(cast((ThirdTable.Total_Records_in_Group * 100 / ThirdTable.Total_Records_in_baseTable) as DECIMAL(5,2)) as varchar), from ( SELECT FirstTable.FirstField, FirstTable.SecondField, SecondTable.Total_Records_in_baseTable, count(*) Total_Records_in_Group FROM BaseTable FirstTable JOIN ( SELECT FK1, count(*) AS Total_Records_in_baseTable FROM BaseTable GROUP BY FK1 ) SecondTable ON FirstTable.FirstField = SecondTable.FK1 GROUP BY FirstTable.FirstField, FirstTable.SecondField, SecondTable.Total_Records_in_baseTable ORDER BY FirstTable.FirstField, FirstTable.SecondField ) ThirdTable
SELECT {columns you want} , COUNT(ItemID) OVER (PARTITION BY ItemID) as BandedItemCount , {more columns you want}... , FROM {MyTable}
CREATE FUNCTION dbo.fnBinaryIPv4(@ip AS VARCHAR(15)) RETURNS BINARY(4) AS BEGIN DECLARE @bin AS BINARY(4) SELECT @bin = CAST( CAST( PARSENAME( @ip, 4 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 3 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 2 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 1 ) AS INTEGER) AS BINARY(1)) RETURN @bin END go
CREATE FUNCTION dbo.fnDisplayIPv4(@ip AS BINARY(4)) RETURNS VARCHAR(15) AS BEGIN DECLARE @str AS VARCHAR(15) SELECT @str = CAST( CAST( SUBSTRING( @ip, 1, 1) AS INTEGER) AS VARCHAR(3) ) + + CAST( CAST( SUBSTRING( @ip, 2, 1) AS INTEGER) AS VARCHAR(3) ) + + CAST( CAST( SUBSTRING( @ip, 3, 1) AS INTEGER) AS VARCHAR(3) ) + + CAST( CAST( SUBSTRING( @ip, 4, 1) AS INTEGER) AS VARCHAR(3) ); RETURN @str END; go
SELECT dbo.fnBinaryIPv4( --should return 0xC04144C9 go SELECT dbo.fnDisplayIPv4( 0xC04144C9 ) -- should return go
CREATE FUNCTION dbo.itvfBinaryIPv4(@ip AS VARCHAR(15)) RETURNS TABLE AS RETURN ( SELECT CAST( CAST( CAST( PARSENAME( @ip, 4 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 3 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 2 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 1 ) AS INTEGER) AS BINARY(1)) AS BINARY(4)) As bin ) go
SELECT bin FROM dbo.fnBinaryIPv4( --should return 0xC04144C9 go
INSERT INTo myIpTable SELECT {other_column_values,...}, (SELECT bin FROM dbo.itvfBinaryIPv4(
-- SELECT dbo.fn_ConvertIpAddressToBinary( -- SELECT dbo.fn_ConvertIpAddressToBinary( -- SELECT dbo.fn_ConvertIpAddressToBinary( ALTER FUNCTION dbo.fn_ConvertIpAddressToBinary ( @ipAddress VARCHAR(39) ) RETURNS BINARY(16) AS BEGIN DECLARE @bytes BINARY(16), @vbytes VARBINARY(16), @vbzone VARBINARY(2) , @colIndex TINYINT, @prevColIndex TINYINT, @parts TINYINT, @limit TINYINT , @delim CHAR(1), @token VARCHAR(4), @zone VARCHAR(4) SELECT @delim = , @prevColIndex = 0 , @limit = 4 , @vbytes = 0x , @parts = 0 , @colIndex = CHARINDEX(@delim, @ipAddress) IF @colIndex = 0 BEGIN SELECT @delim = , @limit = 8 , @colIndex = CHARINDEX(@delim, @ipAddress) WHILE @colIndex > 0 SELECT @parts = @parts + 1 , @colIndex = CHARINDEX(@delim, @ipAddress, @colIndex + 1) SET @colIndex = CHARINDEX(@delim, @ipAddress) IF @colIndex = 0 RETURN NULL END SET @ipAddress = @ipAddress + @delim WHILE @colIndex > 0 BEGIN SET @token = SUBSTRING(@ipAddress, @prevColIndex + 1, @Colindex - @prevColIndex - 1) IF @delim = BEGIN SET @zone = RIGHT( SELECT @vbzone = CAST( , @vbytes = @vbytes + @vbzone IF @token = WHILE @parts + 1 < @limit SELECT @vbytes = @vbytes + @vbzone , @parts = @parts + 1 END ELSE BEGIN SET @zone = SUBSTRING( SELECT @vbzone = CAST( , @vbytes = @vbytes + @vbzone END SELECT @prevColIndex = @colIndex , @colIndex = CHARINDEX(@delim, @ipAddress, @colIndex + 1) END SET @bytes = CASE @delim WHEN ELSE 0x000000000000000000000000 + @vbytes END RETURN @bytes END
-- SELECT dbo.fn_ConvertBinaryToIpAddress(0x200201FF06C200000000000001FF06C2) -- SELECT dbo.fn_ConvertBinaryToIpAddress(0x0000000000000000000000000A0118FF) ALTER FUNCTION [dbo].[fn_ConvertBinaryToIpAddress] ( @bytes BINARY(16) ) RETURNS VARCHAR(39) AS BEGIN DECLARE @part VARBINARY(2) , @colIndex TINYINT , @ipAddress VARCHAR(39) SET @ipAddress = IF SUBSTRING(@bytes, 1, 12) = 0x000000000000000000000000 BEGIN SET @colIndex = 13 WHILE @colIndex <= 16 SELECT @part = SUBSTRING(@bytes, @colIndex, 1) , @ipAddress = @ipAddress + CAST(CAST(@part AS TINYINT) AS VARCHAR(3)) + CASE @colIndex WHEN 16 THEN , @colIndex = @colIndex + 1 IF @ipAddress = SET @ipAddress = END ELSE BEGIN SET @colIndex = 1 WHILE @colIndex <= 16 BEGIN SET @part = SUBSTRING(@bytes, @colIndex, 2) SELECT @ipAddress = @ipAddress + CAST( + CASE @colIndex WHEN 15 THEN , @colIndex = @colIndex + 2 END END RETURN @ipAddress END
[SqlFunction(DataAccess = DataAccessKind.None, IsDeterministic = true)] public static SqlBytes GetIPAddressBytesFromString (SqlString value) { IPAddress IP; if (IPAddress.TryParse(value.Value, out IP)) { return new SqlBytes(IP.GetAddressBytes()); } else { return new SqlBytes(); } } [SqlFunction(DataAccess = DataAccessKind.None, IsDeterministic = true)] public static SqlString GetIPAddressStringFromBytes(SqlBytes value) { string output; if (value.IsNull) { output = ""; } else { IPAddress IP = new IPAddress(value.Value); output = IP.ToString(); } return new SqlString(output); }
--SELECT -- dbo.varbinaryToIpString(CAST(0x7F000001 AS VARBINARY(4))) IPv4, -- dbo.varbinaryToIpString(CAST(0x20010DB885A3000000008A2E03707334 AS VARBINARY(16))) IPv6 --ALTER CREATE FUNCTION dbo.varbinaryToIpString ( @varbinaryValue VARBINARY(16) ) RETURNS VARCHAR(39) AS BEGIN IF @varbinaryValue IS NULL RETURN NULL IF DATALENGTH(@varbinaryValue) = 4 BEGIN RETURN CONVERT(VARCHAR(3), CONVERT(INT, SUBSTRING(@varbinaryValue, 1, 1))) + CONVERT(VARCHAR(3), CONVERT(INT, SUBSTRING(@varbinaryValue, 2, 1))) + CONVERT(VARCHAR(3), CONVERT(INT, SUBSTRING(@varbinaryValue, 3, 1))) + CONVERT(VARCHAR(3), CONVERT(INT, SUBSTRING(@varbinaryValue, 4, 1))) END IF DATALENGTH(@varbinaryValue) = 16 BEGIN RETURN sys.fn_varbintohexsubstring(0, @varbinaryValue, 1, 2) + sys.fn_varbintohexsubstring(0, @varbinaryValue, 3, 2) + sys.fn_varbintohexsubstring(0, @varbinaryValue, 5, 2) + sys.fn_varbintohexsubstring(0, @varbinaryValue, 7, 2) + sys.fn_varbintohexsubstring(0, @varbinaryValue, 9, 2) + sys.fn_varbintohexsubstring(0, @varbinaryValue, 11, 2) + sys.fn_varbintohexsubstring(0, @varbinaryValue, 13, 2) + sys.fn_varbintohexsubstring(0, @varbinaryValue, 15, 2) END RETURN END
CREATE FUNCTION dbo.fnDisplayIPv4End(@block AS VARCHAR(18)) RETURNS BINARY(4) AS BEGIN DECLARE @bin AS BINARY(4) DECLARE @ip AS VARCHAR(15) DECLARE @size AS INT SELECT @ip = Left(@block, Len(@block)-3) SELECT @size = Right(@block, 2) SELECT @bin = CAST( CAST( PARSENAME( @ip, 4 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 3 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 2 ) AS INTEGER) AS BINARY(1)) + CAST( CAST( PARSENAME( @ip, 1 ) AS INTEGER) AS BINARY(1)) SELECT @bin = CAST(@bin + POWER(2, 32-@size) AS BINARY(4)) RETURN @bin END; go
declare @myList {data type} set @myList = (1,2,3,4) select * from myTable where myColumn in @myList
DECLARE @MyList TABLE (Value INT) INSERT INTO @MyList VALUES (1) INSERT INTO @MyList VALUES (2) INSERT INTO @MyList VALUES (3) INSERT INTO @MyList VALUES (4) SELECT * FROM MyTable WHERE MyColumn IN (SELECT Value FROM @MyList)
DECLARE @mylist TABLE (Id int) INSERT INTO @mylist SELECT id FROM (VALUES (1),(2),(3),(4),(5)) AS tbl(id) SELECT * FROM Mytable WHERE theColumn IN (select id from @mylist)
CREATE function [dbo].[list_to_table] (@list varchar(4000)) returns @tab table (item varchar(100)) begin if CHARINDEX( begin insert into @tab (item) values (@list); return; end declare @c_pos int; declare @n_pos int; declare @l_pos int; set @c_pos = 0; set @n_pos = CHARINDEX( while @n_pos > 0 begin insert into @tab (item) values (SUBSTRING(@list,@c_pos+1,@n_pos - @c_pos-1)); set @c_pos = @n_pos; set @l_pos = @n_pos; set @n_pos = CHARINDEX( end; insert into @tab (item) values (SUBSTRING(@list,@l_pos+1,4000)); return; end;
select * from table_1 a inner join [dbo].[list_to_table] (
SELECT * FROM myTable WHERE myColumn in (SELECT id FROM myIdTable WHERE id > 10)
DECLARE @sql varchar(max) declare @list varchar(256) select @list = SELECT @sql = exec sp_executeSQL @sql
DECLARE @list TABLE (Id INT) INSERT INTO @list(Id) SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 SELECT * FROM myTable JOIN @list l ON myTable.myColumn = l.Id SELECT * FROM myTable WHERE myColumn IN (SELECT Id FROM @list)
DECLARE @myList TABLE (Id BIGINT) INSERT INTO @myList(Id) VALUES (1),(2),(3),(4); select * from myTable where myColumn in(select Id from @myList)
DECLARE @myList varchar(15) SET @myList = SELECT * FROM myTable WHERE @myList LIKE
DECLARE @StatusList varchar(MAX); SET @StatusList= DECLARE @Status SYS_INTEGERS; INSERT INTO @Status SELECT Value FROM dbo.SYS_SPLITTOINTEGERS_FN(@StatusList, SELECT Value From @Status;
DECLARE @MyList TABLE (Value INT) INSERT INTO @MyList VALUES (1),(2),(3),(4) SELECT * FROM MyTable WHERE MyColumn IN (SELECT Value FROM @MyList)
DECLARE @InList varchar(255) = WITH InList (Item) AS ( SELECT value FROM STRING_SPLIT(@InList, ) SELECT * FROM [Table] WHERE [Item] IN (SELECT Tag FROM InList)
declare @myList nvarchar(MAX) set @myList = select * from myTable where myColumn in (select value from STRING_SPLIT(@myList,
SELECT * FROM Cases WHERE cast(created_at as date) BETWEEN
DECLARE @StartDate DATE = @EndDate DATE = SELECT * FROM cases WHERE Datediff(day, created_at, @StartDate) <= 0 AND Datediff(day, created_at, @EndDate) >= 0
SELECT Name FROM sys.procedures WHERE OBJECT_DEFINITION(OBJECT_ID) LIKE
select distinct [Table Name] = o.Name, [Found In] = sp.Name, sp.type_desc from sys.objects o inner join sys.sql_expression_dependencies sd on o.object_id = sd.referenced_id inner join sys.objects sp on sd.referencing_id = sp.object_id and sp.type in ( where o.name = order by sp.Name
SELECT o.name FROM sys.sql_modules sm INNER JOIN sys.objects o ON o.object_id = sm.object_id WHERE sm.definition LIKE
select so.name, text from sysobjects so, syscomments sc where so.id = sc.id and UPPER(text) like
select distinct so.name --, text from sysobjects so, syscomments sc where so.id = sc.id and lower(text) like order by so.name
SELECT DISTINCT OBJECT_NAME(OBJECT_ID), object_definition(OBJECT_ID) FROM sys.Procedures WHERE object_definition(OBJECT_ID) LIKE GO
USE master GO ALTER DATABASE YourDatabaseName SET OFFLINE WITH ROLLBACK IMMEDIATE GO
USE master GO ALTER DATABASE YourDatabaseName SET ONLINE GO
(2 ^ 31 - 1 - 2) / 2 = 1 1 billion, 73 million, 741 thousand and 822 characters to be precise
DECLARE @sqlCommand nvarchar(1000) DECLARE @city varchar(75) SET @city = SET @sqlCommand = EXECUTE sp_executesql @sqlCommand, N
DECLARE @sqlCommand nvarchar(1000) DECLARE @city varchar(75) declare @counts int SET @city = SET @sqlCommand = EXECUTE sp_executesql @sqlCommand, N select @counts as Counts
DECLARE @city varchar(75) DECLARE @count INT SET @city = SELECT @count = COUNT(*) FROM customers WHERE City = @city
DECLARE @sqlCommand nvarchar(1000) DECLARE @city varchar(75) DECLARE @cnt int SET @city = SET @sqlCommand = EXECUTE sp_executesql @sqlCommand, N RETURN @cnt
ALTER PROCEDURE [dbo].[ReseedTableIdentityCol](@p_table varchar(max))-- RETURNS int AS BEGIN -- Declare the return variable here DECLARE @sqlCommand nvarchar(1000) DECLARE @maxVal INT set @sqlCommand = EXECUTE sp_executesql @sqlCommand, N DBCC CHECKIDENT(@p_table, RESEED, @maxVal) END exec dbo.ReseedTableIdentityCol @p_table=
declare @step2cmd nvarchar(200) DECLARE @rcount NUMERIC(18,0) set @step2cmd = EXECUTE @rcount=sp_executesql @step2cmd select @rcount
vMYQUERY := AND OBJECT_NAME = PRINT_STRING(VMYQUERY); EXECUTE IMMEDIATE vMYQUERY INTO VCOUNTTEMP ;
Name, Maths, Science, English Tilak, 90, 40, 60 Raj, 30, 20, 10
Name, Subject, Marks Tilak, Maths, 90 Tilak, Science, 40 Tilak, English, 60
select Name, Marks from studentmarks Unpivot ( Marks for details in (Maths, Science, English) ) as UnPvt
select u.name, u.subject, u.marks from student s unpivot ( marks for subject in (Maths, Science, English) ) u;
select * from ( select name, subject, case subject when when when end as Marks from studentmarks Cross Join (values( )as D where marks is not null;
CREATE PROC DisplayDate (@DateVar DATETIME) AS BEGIN SELECT @DateVar END GO EXEC DisplayDate GETDATE();
DECLARE @tmp DATETIME SET @tmp = GETDATE() EXEC DisplayDate @tmp;
ALTER PROC DisplayDate ( @DateVar DATETIME = NULL ) AS BEGIN set @DateVar=ISNULL(@DateVar,GETDATE()) --the SP stuff here SELECT @DateVar END GO
-- returns name of a column SELECT default_constraints.name FROM sys.all_columns INNER JOIN sys.tables ON all_columns.object_id = tables.object_id INNER JOIN sys.schemas ON tables.schema_id = schemas.schema_id INNER JOIN sys.default_constraints ON all_columns.default_object_id = default_constraints.object_id WHERE schemas.name = AND tables.name = AND all_columns.name =
select * from sysobjects o inner join syscolumns c on o.id = c.cdefault inner join sysobjects t on c.id = t.id where o.xtype = and c.name = and t.name =
SELECT b.name AS TABLE_NAME, d.name AS COLUMN_NAME, a.name AS CONSTRAINT_NAME, c.text AS DEFAULT_VALUE FROM sys.sysobjects a INNER JOIN (SELECT name, id FROM sys.sysobjects WHERE xtype = INNER JOIN sys.syscomments c ON (a.id = c.id) INNER JOIN sys.syscolumns d ON (d.cdefault = a.id) WHERE a.xtype = ORDER BY b.name, a.name
select c.name, col.name from sys.default_constraints c inner join sys.columns col on col.default_object_id = c.object_id inner join sys.objects o on o.object_id = c.parent_object_id inner join sys.schemas s on s.schema_id = o.schema_id where s.name = @SchemaName and o.name = @TableName and col.name = @ColumnName
IF object_id( -- constraint exists, work with it. END
WHILE EXISTS( SELECT * FROM sys.all_columns INNER JOIN sys.tables ST ON all_columns.object_id = ST.object_id INNER JOIN sys.schemas ON ST.schema_id = schemas.schema_id INNER JOIN sys.default_constraints ON all_columns.default_object_id = default_constraints.object_id WHERE schemas.name = AND ST.name = ) BEGIN DECLARE @SQL NVARCHAR(MAX) = N SET @SQL = ( SELECT TOP 1 FROM sys.all_columns INNER JOIN sys.tables ST ON all_columns.object_id = ST.object_id INNER JOIN sys.schemas ON ST.schema_id = schemas.schema_id INNER JOIN sys.default_constraints ON all_columns.default_object_id = default_constraints.object_id WHERE schemas.name = AND ST.name = ) PRINT @SQL EXECUTE sp_executesql @SQL --End if Error IF @@ERROR <> 0 BREAK END
select columns.table_name,columns.column_name,columns.column_default,checks.constraint_name from information_schema.columns columns inner join information_schema.constraint_column_usage usage on columns.column_name = usage.column_name and columns.table_name = usage.table_name inner join information_schema.check_constraints checks on usage.constraint_name = checks.constraint_name where columns.column_default is not null
SELECT t.name AS TableName, c.name AS ColumnName, SC.COLUMN_DEFAULT AS DefaultValue, dc.name AS DefaultConstraintName FROM sys.all_columns c JOIN sys.tables t ON c.object_id = t.object_id JOIN sys.schemas s ON t.schema_id = s.schema_id LEFT JOIN sys.default_constraints dc ON c.default_object_id = dc.object_id LEFT JOIN INFORMATION_SCHEMA.COLUMNS SC ON (SC.TABLE_NAME = t.name AND SC.COLUMN_NAME = c.name) WHERE SC.COLUMN_DEFAULT IS NOT NULL --WHERE t.name =
SELECT so.object_id TableName, ss.name AS TableSchema, cc.name AS Name, cc.object_id AS ObjectID, sc.name AS ColumnName, cc.parent_column_id AS ColumnID, cc.definition AS Defination, CONVERT(BIT, CASE cc.is_system_named WHEN 1 THEN 1 ELSE 0 END) AS IsSystemNamed, cc.create_date AS CreationDate, cc.modify_date AS LastModifiednDate FROM sys.default_constraints cc WITH (NOLOCK) INNER JOIN sys.objects so WITH (NOLOCK) ON so.object_id = cc.parent_object_id LEFT JOIN sys.schemas ss WITH (NOLOCK) ON ss.schema_id = so.schema_id LEFT JOIN sys.columns sc WITH (NOLOCK) ON sc.column_id = cc.parent_column_id AND sc.object_id = cc.parent_object_id ORDER BY so.name, cc.name;
name system_type_id user_type_id schema_id principal_id max_length precision scale collation_name is_nullable is_user_defined is_assembly_type default_object_id rule_object_id nvarchar 231 231 4 NULL 8000 0 0 SQL_Latin1_General_CP1_CI_AS 1 0 0 0 0 sysname 231 256 4 NULL 256 0 0 SQL_Latin1_General_CP1_CI_AS 0 0 0 0 0
create procedure dbo.yyy_test ( @col_one nvarchar(max), @col_two nvarchar(max) = @col_three nvarchar(1), @col_four nvarchar(1) = @col_five nvarchar(128), @col_six nvarchar(128) = @col_seven sysname ) as begin select 1 end
select parm.name AS Parameter, parm.max_length, parm.parameter_id from sys.procedures sp join sys.parameters parm ON sp.object_id = parm.object_id where sp.name = order by parm.parameter_id
parameter max_length parameter_id @col_one -1 1 @col_two -1 2 @col_three 2 3 @col_four 2 4 @col_five 256 5 @col_six 256 6 @col_seven 256 7
select parm.name as parameter, parm.max_length, parm.parameter_id, typ.name as data_type, typ.system_type_id, typ.user_type_id, typ.collation_name, typ.is_nullable from sys.procedures sp join sys.parameters parm ON sp.object_id = parm.object_id join sys.types typ ON parm.system_type_id = typ.system_type_id where sp.name = order by parm.parameter_id
parameter max_length parameter_id data_type system_type_id user_type_id collation_name is_nullable @col_one -1 1 nvarchar 231 231 SQL_Latin1_General_CP1_CI_AS 1 @col_one -1 1 sysname 231 256 SQL_Latin1_General_CP1_CI_AS 0 @col_two -1 2 nvarchar 231 231 SQL_Latin1_General_CP1_CI_AS 1 @col_two -1 2 sysname 231 256 SQL_Latin1_General_CP1_CI_AS 0 @col_three 2 3 nvarchar 231 231 SQL_Latin1_General_CP1_CI_AS 1 @col_three 2 3 sysname 231 256 SQL_Latin1_General_CP1_CI_AS 0 @col_four 2 4 nvarchar 231 231 SQL_Latin1_General_CP1_CI_AS 1 @col_four 2 4 sysname 231 256 SQL_Latin1_General_CP1_CI_AS 0 @col_five 256 5 nvarchar 231 231 SQL_Latin1_General_CP1_CI_AS 1 @col_five 256 5 sysname 231 256 SQL_Latin1_General_CP1_CI_AS 0 @col_six 256 6 nvarchar 231 231 SQL_Latin1_General_CP1_CI_AS 1 @col_six 256 6 sysname 231 256 SQL_Latin1_General_CP1_CI_AS 0 @col_seven 256 7 nvarchar 231 231 SQL_Latin1_General_CP1_CI_AS 1 @col_seven 256 7 sysname 231 256 SQL_Latin1_General_CP1_CI_AS 0
USE Students DECLARE @TABLE_NAME sysname SELECT @TABLE_NAME = SELECT TABLE_SCHEMA FROM INFORMATION_SCHEMA.Tables WHERE TABLE_NAME = @TABLE_NAME
DECLARE @Table sysname; SET @Table = EXEC sp_fkeys @Table; EXEC sp_help @Table;
[ @profile_name = ] Is the name of the profile to send the message from. The profile_name is of type sysname, with a default of NULL. The profile_name must be the name of an existing Database Mail profile. When no profile_name is specified, sp_send_dbmail uses the default private profile for the current user. If the user does not have a default private profile, sp_send_dbmail uses the default public profile for the msdb database. If the user does not have a default private profile and there is no default public profile for the database, @profile_name must be specified.
SELECT padded_id = REPLACE(STR(id, 4), SPACE(1), FROM tableA
SELECT REPLACE(STR(id, (SELECT LEN(MAX(id)) + 4 FROM tableA)), SPACE(1),
declare @T table(id int) insert into @T values (1), (2), (12), (123), (1234) select right( from @T
select FORMAT(1, select FORMAT(2, select FORMAT(12, select FORMAT(123, select FORMAT(1234,
declare @dossierId int = 123 declare @padded_id varchar(7) set @padded_id = REPLACE( SPACE(7 - LEN(@dossierId)) + convert(varchar(7), @dossierId), SPACE(1), SELECT @dossierId as ,SPACE(LEN(@dossierId)) + convert(varchar(7) ,@dossierId) as withSpaces ,@padded_id as
Create FUNCTION [dbo].[PadLeft] ( @Text NVARCHAR(MAX) , @Replace NVARCHAR(MAX) , @Len INT ) RETURNS NVARCHAR(MAX) AS BEGIN DECLARE @var NVARCHAR(MAX) SELECT @var = ISNULL(LTRIM(RTRIM(@Text)) , RETURN RIGHT(REPLICATE(@Replace,@Len)+ @var, @Len) END
CREATE FUNCTION [dbo].[fnPadLeft](@int int, @Length tinyint) RETURNS varchar(255) AS BEGIN DECLARE @strInt varchar(255) SET @strInt = CAST(@int as varchar(255)) RETURN (REPLICATE( END;
select ifnull(repeat( + cast (FIELD as varchar(10)) from TABLE_NAME
declare @minlen int = 6 declare @str varchar(20) set @str = select case when len(@str) < @minlen then REPLICATE( --Ans: 000123 set @str = select case when len(@str) < @minlen then REPLICATE( --Ans: 001234 set @str = select case when len(@str) < @minlen then REPLICATE( --Ans: 123456 set @str = select case when len(@str) < @minlen then REPLICATE( --Ans: 123456789 set @str = select case when len(@str) < @minlen then REPLICATE( --Ans: 123456789 set @str = select case when len(@str) < @minlen then REPLICATE( --Ans: NEFT 123456789
Select id, LEN(id) From TableA Order by 2,1 The result : id ---- 1 2 12 123 1234
CREATE TABLE [dbo].[History]( [ID] [int] NOT NULL, [RequestID] [int] NOT NULL, [EmployeeID] [varchar](50) NOT NULL, [DateStamp] [datetime] NOT NULL, CONSTRAINT [PK_History] PRIMARY KEY CLUSTERED ( [ID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY]
CREATE TABLE [dbo].[History]( [ID] [int] IDENTITY(1,1) NOT NULL, [RequestID] [int] NOT NULL, [EmployeeID] [varchar](50) NOT NULL, [DateStamp] [datetime] NOT NULL, CONSTRAINT [PK_History] PRIMARY KEY CLUSTERED ( [ID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ) ON [PRIMARY]
CREATE TABLE History ( ID int primary key IDENTITY(1,1) NOT NULL, . . .
create table teppp ( id int identity(1,1) primary key, name varchar(10 )unique, addresss varchar(10) ) insert into teppp ( name,addresss) values ( insert into teppp ( name,addresss) values ( insert into teppp ( addresss) values ( select * from teppp null string , address1 NULL,address2 NULL,address3
insert into teppp ( name,addresss) values ( insert into teppp ( name,addresss) values ( insert into teppp ( addresss) values (
ALTER TABLE tblcommodityOHLC ALTER COLUMN CC_CommodityContractID NUMERIC(18,0)
ALTER TABLE tblcommodityOHLC ALTER COLUMN CC_CommodityContractID NUMERIC(18,0), CM_CommodityID NUMERIC(18,0)
ALTER TABLE tblcommodityOHLC alter column CC_CommodityContractID NUMERIC(18,0); ALTER TABLE tblcommodityOHLC alter column CM_CommodityID NUMERIC(18,0);
SELECT TABLE_CATALOG ,TABLE_SCHEMA ,TABLE_NAME ,COLUMN_NAME , FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =
BEGIN TRANSACTION SET QUOTED_IDENTIFIER ON SET ARITHABORT ON SET NUMERIC_ROUNDABORT OFF SET CONCAT_NULL_YIELDS_NULL ON SET ANSI_NULLS ON SET ANSI_PADDING ON SET ANSI_WARNINGS ON COMMIT BEGIN TRANSACTION GO ALTER TABLE dbo.tblDiary DROP CONSTRAINT FK_tblDiary_tblDiary_events GO ALTER TABLE dbo.tblDiary_events SET (LOCK_ESCALATION = TABLE) GO COMMIT BEGIN TRANSACTION GO CREATE TABLE dbo.Tmp_tblDiary ( Diary_ID int NOT NULL IDENTITY (1, 1), Date date NOT NULL, Diary_event_type_ID int NOT NULL, Notes varchar(MAX) NULL, Expected_call_volumes real NULL, Expected_duration real NULL, Skill_affected smallint NULL ) ON T3_Data_2 TEXTIMAGE_ON T3_Data_2 GO ALTER TABLE dbo.Tmp_tblDiary SET (LOCK_ESCALATION = TABLE) GO SET IDENTITY_INSERT dbo.Tmp_tblDiary ON GO IF EXISTS(SELECT * FROM dbo.tblDiary) EXEC( SELECT Diary_ID, Date, Diary_event_type_ID, CONVERT(varchar(MAX), Notes), Expected_call_volumes, Expected_duration, CONVERT(smallint, Skill_affected) FROM dbo.tblDiary WITH (HOLDLOCK TABLOCKX) GO SET IDENTITY_INSERT dbo.Tmp_tblDiary OFF GO DROP TABLE dbo.tblDiary GO EXECUTE sp_rename N GO ALTER TABLE dbo.tblDiary ADD CONSTRAINT PK_tblDiary PRIMARY KEY NONCLUSTERED ( Diary_ID ) WITH( PAD_INDEX = OFF, FILLFACTOR = 86, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON T3_Data_2 GO CREATE UNIQUE CLUSTERED INDEX tblDiary_ID ON dbo.tblDiary ( Diary_ID ) WITH( PAD_INDEX = OFF, FILLFACTOR = 86, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON T3_Data_2 GO CREATE NONCLUSTERED INDEX tblDiary_date ON dbo.tblDiary ( Date ) WITH( PAD_INDEX = OFF, FILLFACTOR = 86, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON T3_Data_2 GO ALTER TABLE dbo.tblDiary WITH NOCHECK ADD CONSTRAINT FK_tblDiary_tblDiary_events FOREIGN KEY ( Diary_event_type_ID ) REFERENCES dbo.tblDiary_events ( Diary_event_ID ) ON UPDATE CASCADE ON DELETE CASCADE GO COMMIT
select CASE WHEN c.is_nullable = 0 THEN from sys.objects o inner join sys.columns c on o.object_id = c.object_id inner join sys.types t on c.system_type_id = t.system_type_id where o.type= and c.name = and t.name = order by OBJECT_NAME(o.object_id)
USE [Table_Name] GO SELECT TABLE_CATALOG ,TABLE_SCHEMA ,TABLE_NAME ,COLUMN_NAME ,DATA_TYPE , ALTER TABLE [ ALTER TABLE [ GO FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME LIKE AND (COLUMN_NAME = AND DATA_TYPE =
ALTER TABLE `tblcommodityOHLC` CHANGE COLUMN `updated_on` `updated_on` DATETIME NULL DEFAULT NULL AFTER `updated_by`, CHANGE COLUMN `delivery_datetime` `delivery_datetime` DATETIME NULL DEFAULT CURRENT_TIMESTAMP AFTER `delivery_status`;
Alter table tablename add (column1 dataype, column2 datatype);
-- create temp table CREATE TABLE temp_table_alter ( column_name varchar(255) ); -- insert those coulmns in temp table for which we nee to alter size of columns INSERT INTO temp_table_alter (column_name) VALUES ( INSERT INTO temp_table_alter (column_name) VALUES ( INSERT INTO temp_table_alter (column_name) VALUES ( INSERT INTO temp_table_alter (column_name) VALUES ( DECLARE @col_name_var varchar(255); DECLARE alter_table_cursor CURSOR FOR select column_name from temp_table_alter ; OPEN alter_table_cursor FETCH NEXT FROM alter_table_cursor INTO @col_name_var WHILE @@FETCH_STATUS = 0 BEGIN PRINT( EXEC ( FETCH NEXT FROM alter_table_cursor INTO @col_name_var END CLOSE alter_table_cursor DEALLOCATE alter_table_cursor -- at the end drop temp table drop table temp_table_alter;
ALTER TABLE tblcommodityOHLC alter ( column CC_CommodityContractID NUMERIC(18,0), CM_CommodityID NUMERIC(18,0) )
SELECT DATEADD(MONTH, DATEDIFF(MONTH, 0, <dateField>), 0) AS [year_month_date_field] FROM <your_table>
SELECT DATEPART(yy, DateVal) SELECT DATEPART(MM, DateVal) SELECT DATENAME(MM, DateVal)
SELECT YEAR(getdate()), MONTH(getdate()), DAY(getdate());
SELECT YEAR(yourDateField), MONTH(yourDateField), DAY(yourDateField);
convert(varchar(7), <date_field>, 120) because 120 results in using varchar(7) will display only year and month example: select convert(varchar(7), <date_field>, 120), COUNT(*) from <some_table> group by convert(varchar(7), <date_field>, 120) order by 1
select [YEAR] = YEAR(getdate()) ,[YEAR] = DATEPART(YY,getdate()) , [MONTH] = month(getdate()) ,[MONTH] = DATEPART(mm,getdate()) ,[MONTH NAME] = DATENAME(mm, getdate())
select [Month.Year] = STUFF(CONVERT(varchar(10), GETDATE(),104),1,3,
SELECT FORMAT(<your-date-field>,"YYYY-MM") AS year-date FROM <your-table>
DECLARE @lcMonth nvarchar(10) DECLARE @lcYear nvarchar(10) SET @lcYear=(SELECT DATEPART(YEAR,@Date)) SET @lcMonth=(SELECT DATEPART(MONTH,@Date))
public static string GetBadgeString(int badgeNum) { return string.Format("{0:000000}", badgeNum); }
SELECT RIGHT(EmployeeId,(LEN(EmployeeId) - PATINDEX(
SELECT FORMAT(EmployeeID, FROM dbo.RequestItems WHERE ID=0
SELECT Right( EmployeeID FROM dbo.RequestItems WHERE ID=0
declare @number int = 1; print right( print right( print right(replicate( print cast(replace(str(@number,4), print format(@number,
SELECT STUFF( AS EmployeeCode FROM dbo.RequestItems WHERE ID=0
SELECT FORMAT(EmployeeID, FROM dbo.RequestItems WHERE ID=0
SELECT cast(replace(str(EmployeeID,6), FROM dbo.RequestItems WHERE ID=0
DECLARE @n money = -3, @length tinyint = 15, @decimals tinyint = 0 SELECT REPLICATE(
CREATE FUNCTION dbo.splitstring ( @stringToSplit VARCHAR(MAX) ) RETURNS @returnList TABLE ([Name] [nvarchar] (500)) AS BEGIN DECLARE @name NVARCHAR(255) DECLARE @pos INT WHILE CHARINDEX( BEGIN SELECT @pos = CHARINDEX( SELECT @name = SUBSTRING(@stringToSplit, 1, @pos-1) INSERT INTO @returnList SELECT @name SELECT @stringToSplit = SUBSTRING(@stringToSplit, @pos+1, LEN(@stringToSplit)-@pos) END INSERT INTO @returnList SELECT @stringToSplit RETURN END
CREATE FUNCTION [dbo].[SplitString] ( @List NVARCHAR(MAX), @Delim VARCHAR(255) ) RETURNS TABLE AS RETURN ( SELECT [Value] FROM ( SELECT [Value] = LTRIM(RTRIM(SUBSTRING(@List, [Number], CHARINDEX(@Delim, @List + @Delim, [Number]) - [Number]))) FROM (SELECT Number = ROW_NUMBER() OVER (ORDER BY name) FROM sys.all_objects) AS x WHERE Number <= LEN(@List) AND SUBSTRING(@Delim + @List, [Number], LEN(@Delim)) = @Delim ) AS y );
DECLARE @String varchar(100) = -- To change DECLARE @Delimiter CHAR = SELECT LTRIM(RTRIM(Split.a.value( FROM ( SELECT CAST ( ) AS A CROSS APPLY Data.nodes (
x---------x | Value | x---------x | String1 | | String2 | | String3 | x---------x
x-----x--------------------------x | Id | Value | x-----x--------------------------x | 1 | String1,String2,String3 | | 2 | String4,String5,String6 | x-----x--------------------------x
-- To change DECLARE @Delimiter CHAR = SELECT ID,LTRIM(RTRIM(Split.a.value( FROM ( SELECT ID,CAST ( FROM TABLENAME ) AS A CROSS APPLY Data.nodes (
x-----x----------x | Id | Value | x-----x----------x | 1 | String1 | | 1 | String2 | | 1 | String3 | | 2 | String4 | | 2 | String5 | | 2 | String6 | x-----x----------x
UPDATE SET ZIPCode = SUBSTRING(ZIPCode, 1, (CHARINDEX( WHERE ZIPCode LIKE
CREATE FUNCTION dbo.splitstring ( @stringToSplit VARCHAR(MAX) ) RETURNS @returnList TABLE ([Name] [nvarchar] (500)) AS BEGIN DECLARE @name NVARCHAR(255) DECLARE @pos INT WHILE LEN(@stringToSplit) > 0 BEGIN SELECT @pos = CHARINDEX( if @pos = 0 SELECT @pos = LEN(@stringToSplit) SELECT @name = SUBSTRING(@stringToSplit, 1, @pos-1) INSERT INTO @returnList SELECT @name SELECT @stringToSplit = SUBSTRING(@stringToSplit, @pos+1, LEN(@stringToSplit)-@pos) END RETURN END
CREATE FUNCTION dbo.SplitStrings ( @List NVARCHAR(MAX), @Delimiter NVARCHAR(255) ) RETURNS TABLE WITH SCHEMABINDING AS RETURN ( SELECT Item = y.i.value( FROM ( SELECT x = CONVERT(XML, + REPLACE(@List, @Delimiter, + ) AS a CROSS APPLY x.nodes( ); GO
CREATE FUNCTION [dbo].[SplitString] ( @string nvarchar(4000) , @delim nvarchar(100) ) RETURNS @result TABLE ( [Value] nvarchar(4000) NOT NULL , [Index] int NOT NULL ) AS BEGIN DECLARE @str nvarchar(4000) , @pos int , @prv int = 1 SELECT @pos = CHARINDEX(@delim, @string) WHILE @pos > 0 BEGIN SELECT @str = SUBSTRING(@string, @prv, @pos - @prv) INSERT INTO @result SELECT @str, @prv SELECT @prv = @pos + LEN(@delim) , @pos = CHARINDEX(@delim, @string, @pos + 1) END INSERT INTO @result SELECT SUBSTRING(@string, @prv, 4000), @prv RETURN END
declare @StringToSplit varchar(100) = declare @SplitChar varchar(10) = with StringToSplit as ( select ltrim( rtrim( substring( @StringToSplit, 1, charindex( @SplitChar, @StringToSplit ) - 1 ) ) ) Head , substring( @StringToSplit, charindex( @SplitChar, @StringToSplit ) + 1, len( @StringToSplit ) ) Tail union all select ltrim( rtrim( substring( Tail, 1, charindex( @SplitChar, Tail ) - 1 ) ) ) Head , substring( Tail, charindex( @SplitChar, Tail ) + 1, len( Tail ) ) Tail from StringToSplit where charindex( @SplitChar, Tail ) > 0 union all select ltrim( rtrim( Tail ) ) Head , from StringToSplit where charindex( @SplitChar, Tail ) = 0 and len( Tail ) > 0 ) select Head from StringToSplit
DECLARE @StringToSeperate VARCHAR(10) SET @StringToSeperate = --SELECT @StringToSeperate IDs INTO DROP TABLE CREATE TABLE DECLARE @CommaSeperatedValue NVARCHAR(255) = DECLARE @Position INT = LEN(@StringToSeperate) --Add Each Value WHILE CHARINDEX( BEGIN SELECT @Position = CHARINDEX( SELECT @CommaSeperatedValue = SUBSTRING(@StringToSeperate, 1, @Position-1) INSERT INTO SELECT @CommaSeperatedValue SELECT @StringToSeperate = SUBSTRING(@StringToSeperate, @Position+1, LEN(@StringToSeperate)-@Position) END --Add Last Value IF (LEN(LTRIM(RTRIM(@StringToSeperate)))>0) BEGIN INSERT INTO SELECT SUBSTRING(@StringToSeperate, 1, @Position) END SELECT * FROM
CREATE FUNCTION dbo.splitstring ( @stringToSplit VARCHAR(MAX) ) RETURNS @returnList TABLE ([numOrder] [tinyint] , [Name] [nvarchar] (500)) AS BEGIN DECLARE @name NVARCHAR(255) DECLARE @pos INT DECLARE @orderNum INT SET @orderNum=0 WHILE CHARINDEX( BEGIN SELECT @orderNum=@orderNum+1; SELECT @pos = CHARINDEX( SELECT @name = SUBSTRING(@stringToSplit, 1, @pos-1) INSERT INTO @returnList SELECT @orderNum,@name SELECT @stringToSplit = SUBSTRING(@stringToSplit, @pos+1, LEN(@stringToSplit)-@pos) END SELECT @orderNum=@orderNum+1; INSERT INTO @returnList SELECT @orderNum, @stringToSplit RETURN END Usage:
DECLARE @s VARCHAR(200) = ;WITH a AS (SELECT i=-1, j=0 UNION ALL SELECT j, CHARINDEX( b AS (SELECT SUBSTRING(@s, i+1, IIF(j>0, j, LEN(@s)+1)-i-1) s FROM a WHERE i >= 0) SELECT * FROM b
DECLARE @s VARCHAR(200) = ;WITH a AS (SELECT n=0, i=-1, j=0 UNION ALL SELECT n+1, j, CHARINDEX( b AS (SELECT n, SUBSTRING(@s, i+1, IIF(j>0, j, LEN(@s)+1)-i-1) s FROM a WHERE i >= 0) SELECT * FROM b;
alter FUNCTION dbo.splitstring ( @stringToSplit VARCHAR(1000), @splitPattern varchar(10) ) RETURNS @returnList TABLE ([Name] [nvarchar] (500)) AS BEGIN DECLARE @name NVARCHAR(255) DECLARE @pos INT WHILE PATINDEX(@splitPattern, @stringToSplit) > 0 BEGIN SELECT @pos = PATINDEX(@splitPattern, @stringToSplit) SELECT @name = SUBSTRING(@stringToSplit, 1, @pos-1) INSERT INTO @returnList SELECT @name SELECT @stringToSplit = SUBSTRING(@stringToSplit, @pos+1, LEN(@stringToSplit)-@pos) END INSERT INTO @returnList SELECT @stringToSplit RETURN END select * from dbo.splitstring(
ALTER FUNCTION [dbo].[CUST_SplitString] ( @String NVARCHAR(4000), @Delimiter NCHAR(1) ) RETURNS TABLE AS RETURN ( WITH Split(stpos,endpos) AS( SELECT 0 AS stpos, CHARINDEX(@Delimiter,@String) AS endpos UNION ALL SELECT endpos+1, CHARINDEX(@Delimiter,@String,endpos+1) FROM Split WHERE endpos > 0 ) SELECT FROM Split )
CREATE FUNCTION uft_DoubleSplitter ( -- Add the parameters for the function here @String VARCHAR(4000), @Splitter1 CHAR, @Splitter2 CHAR ) RETURNS @Result TABLE (Id INT,MId INT,SValue VARCHAR(4000)) AS BEGIN DECLARE @FResult TABLE(Id INT IDENTITY(1, 1), SValue VARCHAR(4000)) DECLARE @SResult TABLE(Id INT IDENTITY(1, 1), MId INT, SValue VARCHAR(4000)) SET @String = @String+@Splitter1 WHILE CHARINDEX(@Splitter1, @String) > 0 BEGIN DECLARE @WorkingString VARCHAR(4000) = NULL SET @WorkingString = SUBSTRING(@String, 1, CHARINDEX(@Splitter1, @String) - 1) --Print @workingString INSERT INTO @FResult SELECT CASE WHEN @WorkingString = ELSE @WorkingString END SET @String = SUBSTRING(@String, LEN(@WorkingString) + 2, LEN(@String)) END IF ISNULL(@Splitter2, BEGIN DECLARE @OStartLoop INT DECLARE @OEndLoop INT SELECT @OStartLoop = MIN(Id), @OEndLoop = MAX(Id) FROM @FResult WHILE @OStartLoop <= @OEndLoop BEGIN DECLARE @iString VARCHAR(4000) DECLARE @iMId INT SELECT @iString = SValue+@Splitter2, @iMId = Id FROM @FResult WHERE Id = @OStartLoop WHILE CHARINDEX(@Splitter2, @iString) > 0 BEGIN DECLARE @iWorkingString VARCHAR(4000) = NULL SET @IWorkingString = SUBSTRING(@iString, 1, CHARINDEX(@Splitter2, @iString) - 1) INSERT INTO @SResult SELECT @iMId, CASE WHEN @iWorkingString = ELSE @iWorkingString END SET @iString = SUBSTRING(@iString, LEN(@iWorkingString) + 2, LEN(@iString)) END SET @OStartLoop = @OStartLoop + 1 END INSERT INTO @Result SELECT MId AS PrimarySplitID, ROW_NUMBER() OVER (PARTITION BY MId ORDER BY Mid, Id) AS SecondarySplitID , SValue FROM @SResult END ELSE BEGIN INSERT INTO @Result SELECT Id AS PrimarySplitID, NULL AS SecondarySplitID, SValue FROM @FResult END RETURN
--FirstSplit SELECT * FROM uft_DoubleSplitter( --Second Split SELECT * FROM uft_DoubleSplitter(
SELECT fn.SValue FROM uft_DoubleSplitter( WHERE fn.mid = 2
DECLARE @Dummy TABLE (ID INT, SomeTextToSplit NVARCHAR(MAX)) INSERT INTO @Dummy VALUES (1,N ,(2,N DECLARE @Delimiter NVARCHAR(10)= WITH Casted AS ( SELECT * ,CAST(N FROM @Dummy ) SELECT Casted.ID ,x.value(N FROM Casted CROSS APPLY SplitMe.nodes(N
ID Part 1 A&B 1 C 1 D 1 E, F 2 "C" & 2 <C> 2 D 2 E, F
DECLARE @IDs VARCHAR(1000); SET @IDs = SELECT me.Value FROM dbo.MyEnum me INNER JOIN dbo.GetIntIdsTableFromDelimitedString(@IDs) ids ON me.PrimaryKey = ids.ID
create function dbo.GetIntIDTableFromDelimitedString ( @IDs VARCHAR(1000) --this parameter must start and end with a comma, eg --all items in list must be perfectly formatted or function will error ) RETURNS TABLE AS RETURN SELECT CAST(SUBSTRING(@IDs,Nums.number + 1,CHARINDEX( FROM [master].[dbo].[spt_values] Nums WHERE Nums.Type = AND Nums.number BETWEEN 1 AND DATALENGTH(@IDs) AND SUBSTRING(@IDs,Nums.number,1) = AND CHARINDEX( GO
ALTER FUNCTION [dbo].func_split_string ( @input as varchar(max), @delimiter as varchar(10) = ";" ) RETURNS @result TABLE ( id smallint identity(1,1), csv_value varchar(max) not null ) AS BEGIN DECLARE @pos AS INT; DECLARE @string AS VARCHAR(MAX) = WHILE LEN(@input) > 0 BEGIN SELECT @pos = CHARINDEX(@delimiter,@input); IF(@pos<=0) select @pos = len(@input) IF(@pos <> LEN(@input)) SELECT @string = SUBSTRING(@input, 1, @pos-1); ELSE SELECT @string = SUBSTRING(@input, 1, @pos); INSERT INTO @result SELECT @string SELECT @input = SUBSTRING(@input, @pos+len(@delimiter), LEN(@input)-@pos) END RETURN END
CREATE FUNCTION SplitString ( @Input NVARCHAR(MAX), @Character CHAR(1) ) RETURNS @Output TABLE ( Item NVARCHAR(1000) ) AS BEGIN DECLARE @StartIndex INT, @EndIndex INT SET @StartIndex = 1 IF SUBSTRING(@Input, LEN(@Input) - 1, LEN(@Input)) <> @Character BEGIN SET @Input = @Input + @Character END WHILE CHARINDEX(@Character, @Input) > 0 BEGIN SET @EndIndex = CHARINDEX(@Character, @Input) INSERT INTO @Output(Item) SELECT SUBSTRING(@Input, @StartIndex, @EndIndex - 1) SET @Input = SUBSTRING(@Input, @EndIndex + 1, LEN(@Input)) END RETURN END GO
CREATE FUNCTION [dbo].[fn_SplitString] (@CSV VARCHAR(MAX), @Delimeter VARCHAR(100) = RETURNS @retTable TABLE ( [value] VARCHAR(MAX) NULL )AS BEGIN DECLARE @vCSV VARCHAR (MAX) = @CSV, @vDelimeter VARCHAR (100) = @Delimeter; IF @vDelimeter = BEGIN SET @vCSV = REPLACE(@vCSV, SET @vDelimeter = REPLACE(@vDelimeter, END; SET @vCSV = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@vCSV, DECLARE @xml XML; SET @xml = INSERT INTO @retTable SELECT x.i.value( FROM @xml.nodes( RETURN; END;
CREATE FUNCTION dbo.splitstring ( --CREATE OR ALTER @stringToSplit NVARCHAR(MAX) ) RETURNS @returnList TABLE ([Item] NVARCHAR (MAX)) AS BEGIN DECLARE @name NVARCHAR(MAX) DECLARE @pos BIGINT SET @stringToSplit = @stringToSplit + WHILE ((LEN(@stringToSplit+ SET @pos = COALESCE(NULLIF(CHARINDEX( SET @name = SUBSTRING(@stringToSplit, 1, @pos-1) --MAX size of string of type nvarchar is 4000 SET @stringToSplit = SUBSTRING(@stringToSplit, @pos+1, 4000) -- With SUBSTRING fn (MS web): "If start is greater than the number of characters in the value expression, a zero-length expression is returned." INSERT INTO @returnList SELECT @name --additional debugging parameters below can be added -- + END RETURN END GO
declare @T table (iden int identity, col1 varchar(100)); insert into @T(col1) values ( , ( , ( , ( , ( declare @split char(1) = select @split as split; with cte as ( select t.iden, case when SUBSTRING(REVERSE(rtrim(t.col1)), 1, 1) = @split then LTRIM(RTRIM(t.col1)) else LTRIM(RTRIM(t.col1)) + @split end as col1, 0 as pos , 1 as cnt from @T t union all select t.iden, t.col1 , charindex(@split, t.col1, t.pos + 1), cnt + 1 from cte t where charindex(@split, t.col1, t.pos + 1) > 0 ) select t1.*, t2.pos, t2.cnt , ltrim(rtrim(SUBSTRING(t1.col1, t1.pos+1, t2.pos-t1.pos-1))) as bingo from cte t1 join cte t2 on t2.iden = t1.iden and t2.cnt = t1.cnt+1 and t2.pos > t1.pos order by t1.iden, t1.cnt;
IF EXISTS (SELECT * FROM sys.objects WHERE type = DROP FUNCTION [dbo].[TF_SplitString] GO -- ============================================= -- Author: AviG -- Amendments: Parameterize the delimeter and included the missing chars in last token - Gemunu Wickremasinghe -- Description: Tabel valued function that Breaks the delimeted string by given delimeter and returns a tabel having split results -- Usage -- select * from [dbo].[TF_SplitString]( -- 969 items should be returned -- select * from [dbo].[TF_SplitString]( -- 2 items should be returned -- ============================================= CREATE FUNCTION dbo.TF_SplitString ( @stringToSplit VARCHAR(MAX) , @delimeter char = ) RETURNS @returnList TABLE ([Name] [nvarchar] (500)) AS BEGIN DECLARE @name NVARCHAR(255) DECLARE @pos INT WHILE LEN(@stringToSplit) > 0 BEGIN SELECT @pos = CHARINDEX(@delimeter, @stringToSplit) if @pos = 0 BEGIN SELECT @pos = LEN(@stringToSplit) SELECT @name = SUBSTRING(@stringToSplit, 1, @pos) END else BEGIN SELECT @name = SUBSTRING(@stringToSplit, 1, @pos-1) END INSERT INTO @returnList SELECT @name SELECT @stringToSplit = SUBSTRING(@stringToSplit, @pos+1, LEN(@stringToSplit)-@pos) END RETURN END
NVL2( field_to_check, value_if_NOT_null, value_if_null )
DELETE t1,t2 FROM table1 AS t1 INNER JOIN table2 t2 ... INNER JOIN table3 t3 ...
begin transaction; declare @deletedIds table ( id int ); delete t1 output deleted.id into @deletedIds from table1 t1 join table2 t2 on t2.id = t1.id join table3 t3 on t3.id = t2.id; delete t2 from table2 t2 join @deletedIds d on d.id = t2.id; delete t3 from table3 t3 ... commit transaction;
-- Transact-SQL extension DELETE FROM Sales.SalesPersonQuotaHistory FROM Sales.SalesPersonQuotaHistory AS spqh INNER JOIN Sales.SalesPerson AS sp ON spqh.BusinessEntityID = sp.BusinessEntityID WHERE sp.SalesYTD > 2500000.00;
BEGIN TRAN -- create temporary table for deleted IDs CREATE TABLE Id INT NOT NULL PRIMARY KEY ) -- save IDs of master table records (you want to delete) to temporary table INSERT INTO SELECT DISTINCT mt.MasterTableId FROM MasterTable mt INNER JOIN ... WHERE ... -- delete from first detail table using join syntax DELETE d FROM DetailTable_1 D INNER JOIN ON D.MasterTableId = X.Id -- delete from second detail table using IN clause DELETE FROM DetailTable_2 WHERE MasterTableId IN ( SELECT X.Id FROM ) -- and finally delete from master table DELETE d FROM MasterTable D INNER JOIN ON D.MasterTableId = X.Id -- do not forget to drop the temp table DROP TABLE COMMIT
DELETE t1,t2 FROM table1 AS t1 INNER JOIN table2 t2 ... INNER JOIN table3 t3 ...
DELETE table1 FROM table1 INNER JOIN table2 t2 ... INNER JOIN table3 t3 ...
--*** To delete from tblMain which JOINs to (has a FK of) tblReferredTo -- i.e. ON tblMain.Refer_FK = tblReferredTo.ID --*** !!! If you -- specific rows in tblReferredTo !!! BEGIN TRAN; --*** Keep the ID DECLARE @tblDeletedRefs TABLE ( ID INT ); --*** DELETE from the referring table first DELETE FROM tblMain OUTPUT DELETED.Refer_FK INTO @tblDeletedRefs -- doesn WHERE ..... -- be careful if filtering, what if other rows -- in tblMain (or elsewhere) also point to the tblReferredTo rows? --*** Now we can remove the referred to rows, even though tblMain no longer refers to them. DELETE tblReferredTo FROM tblReferredTo INNER JOIN @tblDeletedRefs Removed ON tblReferredTo.ID = Removed.ID; COMMIT TRAN;
DELETE TABLE1 LIN FROM TABLE1 LIN INNER JOIN TABLE2 LCS ON CONDITION WHERE CONDITION
[ID] [EntityID] [Indicator1] [Indicator2] [Indicator3] ... [Indicator150]
select id, entityId, indicatorname, indicatorvalue from yourtable unpivot ( indicatorvalue for indicatorname in (Indicator1, Indicator2, Indicator3) ) unpiv;
select id, entityid, indicatorname, indicatorvalue from yourtable cross apply ( select select select select ) c (indicatorname, indicatorvalue);
select id, entityid, indicatorname, indicatorvalue from yourtable cross apply ( values ( ( ( ( ) c (indicatorname, indicatorvalue);
DECLARE @colsUnpivot AS NVARCHAR(MAX), @query AS NVARCHAR(MAX) select @colsUnpivot = stuff((select from information_schema.columns as C where C.table_name = C.column_name like for xml path( set @query = indicatorname, indicatorvalue from yourtable unpivot ( indicatorvalue for indicatorname in ( ) u' exec sp_executesql @query;
;with CTE1 as ( select ID, EntityID, (select t.* for xml raw( from temp1 as t ), CTE2 as ( select C.id, C.EntityID, F.C.value( F.C.value( from CTE1 as c outer apply c.Data.nodes( ) select * from CTE2 where IndicatorName like
SELECT id ,entityId ,indicatorname ,indicatorvalue FROM (VALUES (1, 1, (2, 1, (3, 1, (4, 2, ) AS Category(ID, EntityId, Indicator1, Indicator2, Indicator3) UNPIVOT ( indicatorvalue FOR indicatorname IN (Indicator1, Indicator2, Indicator3) ) UNPIV;
DECLARE @TableName nvarchar(50) DECLARE column_to_row CURSOR FOR --List of tables that we want to unpivot columns as row SELECT DISTINCT t.name FROM sys.tables t JOIN sys.schemas s ON t.schema_id=t.schema_id WHERE t.name like AND s.name= OPEN column_to_row FETCH NEXT FROM column_to_row INTO @TableName WHILE @@FETCH_STATUS = 0 BEGIN DECLARE @script nvarchar(max) = null DECLARE @columns nvarchar(2000) = null -- keep the table select @columns = COALESCE(@columns + join sys.columns c on t.object_id = c.object_id where t.name = @TableName set @script = --print (@script) exec (@script) FETCH NEXT FROM column_to_row INTO @TableName END CLOSE column_to_row DEALLOCATE column_to_row
SELECT insRowTbl.PK, insRowTbl.Username, attr.insRow.value( attr.insRow.value( FROM ( Select i.ID as PK, i.LastModifiedBy as Username, convert(xml, (select i.* for xml raw)) as insRowCol FROM inserted as i ) as insRowTbl CROSS APPLY insRowTbl.insRowCol.nodes(
2007-09-22 15:08 -- nearest minute 2007-09-22 15 -- nearest hour
declare @dt datetime set @dt = select dateadd(mi, datediff(mi, 0, @dt), 0) select dateadd(hour, datediff(hour, 0, @dt), 0)
select dateadd(mi, datediff(mi, 0, dateadd(s, 30, @dt)), 0) select dateadd(hour, datediff(hour, 0, dateadd(mi, 30, @dt)), 0)
declare @days int set @days = datediff(day, 0, @dt)
DECLARE @date As DateTime2 SET @date = SELECT CONVERT(VARCHAR(16), @date, 120) --2007-09-22 15:07 SELECT CONVERT(VARCHAR(13), @date, 120) --2007-09-22 15
CREATE TABLE "attachments" ( "attachment_id" INT NOT NULL, "load_date" SMALLDATETIME NOT NULL, "user" VARCHAR(25) NOT NULL, "file_name" VARCHAR(50) NOT NULL, CONSTRAINT "pk_attachments" PRIMARY KEY ("attachment_id"), CONSTRAINT "fk_users" FOREIGN KEY ("user") REFERENCES "users" ("user"), CONSTRAINT "ch_load_date" CHECK ("load_date" < GETDATE()) )
"load_date" SMALLDATETIME NOT NULL DEFAULT GETDATE()
CONSTRAINT "df_load_date" DEFAULT GETDATE() FOR "load_date"
ALTER TABLE "attachments" ADD CONSTRAINT "df_load_date" DEFAULT GETDATE() FOR "load_date"
CREATE TABLE "attachments" ( "attachment_id" INT NOT NULL, "load_date" SMALLDATETIME NOT NULL, "user" VARCHAR(25) NOT NULL, "file_name" VARCHAR(50) NOT NULL, CONSTRAINT "pk_attachments" PRIMARY KEY ("attachment_id"), CONSTRAINT "fk_users" FOREIGN KEY ("user") REFERENCES "users" ("user"), CONSTRAINT "ch_load_date" CHECK ("load_date" < GETDATE()), CONSTRAINT "df_load_date" DEFAULT GETDATE() FOR "load_date" )
[load_date] SMALLDATETIME NOT NULL CONSTRAINT [df_load_date] DEFAULT GETDATE()
CREATE TABLE Original ( Id INT IDENTITY PRIMARY KEY , Value NVARCHAR(300) ); CREATE NONCLUSTERED INDEX IX_Original_Value ON Original (Value); INSERT INTO Original SELECT UNION ALL SELECT
--create new table with no IDENTITY CREATE TABLE Original2 ( Id INT PRIMARY KEY , Value NVARCHAR(300) ); CREATE NONCLUSTERED INDEX IX_Original_Value2 ON Original2 (Value); --data before switch SELECT FROM Original UNION ALL SELECT FROM Original2; ALTER TABLE Original SWITCH TO Original2; --data after switch SELECT FROM Original UNION ALL SELECT FROM Original2; --clean up DROP TABLE Original; EXEC sys.sp_rename EXEC sys.sp_rename UPDATE Original SET Id = Id + 1; SELECT * FROM Original;
alter table yourTable add tempId int NOT NULL default -1; update yourTable set tempId = id;
SELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_NAME =
ALTER TABLE yourTable DROP CONSTRAINT PK_yourTable_id;
SELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_NAME = alter table otherTable drop constraint fk_otherTable_yourTable; commit; ..
ALTER TABLE yourTable DROP CONSTRAINT PK_yourTable_id; alter table yourTable drop column id; EXEC sp_rename ALTER TABLE yourTable ADD CONSTRAINT PK_yourTable_id PRIMARY KEY (id) commit;
alter table otherTable add constraint fk_otherTable_yourTable foreign key (yourTable_id) references yourTable(id); ..
BEGIN TRAN BEGIN TRY EXEC sp_rename ALTER TABLE [SomeTable] ADD Id int NULL EXEC ( ALTER TABLE [SomeTable] NOCHECK CONSTRAINT ALL ALTER TABLE [SomeTable] DROP CONSTRAINT [PK_constraintName]; ALTER TABLE [SomeTable] DROP COLUMN OldId ALTER TABLE [SomeTable] ALTER COLUMN [Id] INTEGER NOT NULL ALTER TABLE [SomeTable] ADD CONSTRAINT PK_JobInfo PRIMARY KEY (Id) ALTER TABLE [SomeTable] CHECK CONSTRAINT ALL COMMIT TRAN END TRY BEGIN CATCH ROLLBACK TRAN SELECT ERROR_MESSAGE () END CATCH
SELECT t1.* INTO Invoice_DELETED FROM Invoice t1 LEFT JOIN Invoice ON 1 = 0 --WHERE t1.InvoiceID = @InvoiceID
ALTER TABLE tablename add newcolumn int update tablename set newcolumn=existingcolumnname ALTER TABLE tablename DROP COLUMN existingcolumnname; EXEC sp_RENAME
BEGIN TRANSACTION SET QUOTED_IDENTIFIER ON SET ARITHABORT ON SET NUMERIC_ROUNDABORT OFF SET CONCAT_NULL_YIELDS_NULL ON SET ANSI_NULLS ON SET ANSI_PADDING ON SET ANSI_WARNINGS ON COMMIT BEGIN TRANSACTION GO ALTER TABLE dbo.SI_Provider_Profile DROP CONSTRAINT DF_SI_Provider_Profile_SIdtDateTimeStamp GO ALTER TABLE dbo.SI_Provider_Profile DROP CONSTRAINT DF_SI_Provider_Profile_SIbHotelPreLoaded GO CREATE TABLE dbo.Tmp_SI_Provider_Profile ( SI_lProvider_Profile_ID int NOT NULL, SI_lSerko_Integrator_Token_ID int NOT NULL, SI_sSerko_Integrator_Provider varchar(50) NOT NULL, SI_sSerko_Integrator_Profile varchar(50) NOT NULL, SI_dtDate_Time_Stamp datetime NOT NULL, SI_lProvider_ID int NULL, SI_sDisplay_Name varchar(10) NULL, SI_lPurchased_From int NULL, SI_sProvider_UniqueID varchar(255) NULL, SI_bHotel_Pre_Loaded bit NOT NULL, SI_sSiteName varchar(255) NULL ) ON [PRIMARY] GO ALTER TABLE dbo.Tmp_SI_Provider_Profile SET (LOCK_ESCALATION = TABLE) GO ALTER TABLE dbo.Tmp_SI_Provider_Profile ADD CONSTRAINT DF_SI_Provider_Profile_SIdtDateTimeStamp DEFAULT (getdate()) FOR SI_dtDate_Time_Stamp GO ALTER TABLE dbo.Tmp_SI_Provider_Profile ADD CONSTRAINT DF_SI_Provider_Profile_SIbHotelPreLoaded DEFAULT ((0)) FOR SI_bHotel_Pre_Loaded GO IF EXISTS(SELECT * FROM dbo.SI_Provider_Profile) EXEC( SELECT SI_lProvider_Profile_ID, SI_lSerko_Integrator_Token_ID, SI_sSerko_Integrator_Provider, SI_sSerko_Integrator_Profile, SI_dtDate_Time_Stamp, SI_lProvider_ID, SI_sDisplay_Name, SI_lPurchased_From, SI_sProvider_UniqueID, SI_bHotel_Pre_Loaded, SI_sSiteName FROM dbo.SI_Provider_Profile WITH (HOLDLOCK TABLOCKX) GO -- Rename the primary key constraint or unique key In SQL Server constraints such as primary keys or foreign keys are objects in their own right, even though they are dependent upon the "containing" table. EXEC sp_rename GO -- backup old table in case of EXECUTE sp_rename N GO EXECUTE sp_rename N GO ALTER TABLE dbo.SI_Provider_Profile ADD CONSTRAINT PK_SI_Provider_Profile PRIMARY KEY NONCLUSTERED ( SI_lProvider_Profile_ID ) WITH( PAD_INDEX = OFF, FILLFACTOR = 90, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO COMMIT TRANSACTION
SELECT EventId, EventName FROM EventMaster WHERE EventDate BETWEEN
SELECT EventId, EventName FROM EventMaster WHERE EventDate >= AND EventDate <=
Select EventId,EventName from EventMaster where EventDate >=
SELECT EventId, EventName FROM EventMaster WHERE (EventDate >= EventDate <
where transactiondate>= and salestype= and customernumber=customer.idnumber and transactiondate<=
SQL Server 2012 Product Documentation Books Online for SQL Server 2012 Database Engine Transact-SQL Reference (Database Engine) Built-in Functions (Transact-SQL) String Functions (Transact-SQL)
CREATE PROC SearchAllTables ( @SearchStr nvarchar(100) ) AS BEGIN -- Copyright © 2002 Narayana Vyas Kondreddi. All rights reserved. -- Purpose: To search all columns of all tables for a given search string -- Written by: Narayana Vyas Kondreddi -- Site: http: -- Tested on: SQL Server 7.0 and SQL Server 2000 -- Date modified: 28th July 2002 22:50 GMT CREATE TABLE SET NOCOUNT ON DECLARE @TableName nvarchar(256), @ColumnName nvarchar(128), @SearchStr2 nvarchar(110) SET @TableName = SET @SearchStr2 = QUOTENAME( WHILE @TableName IS NOT NULL BEGIN SET @ColumnName = SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = AND QUOTENAME(TABLE_SCHEMA) + AND OBJECTPROPERTY( OBJECT_ID( QUOTENAME(TABLE_SCHEMA) + ), ) = 0 ) WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) BEGIN SET @ColumnName = ( SELECT MIN(QUOTENAME(COLUMN_NAME)) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) AND DATA_TYPE IN ( AND QUOTENAME(COLUMN_NAME) > @ColumnName ) IF @ColumnName IS NOT NULL BEGIN INSERT INTO EXEC ( FROM ) END END END SELECT ColumnName, ColumnValue FROM END
CREATE PROC SearchAllTables ( @SearchStr nvarchar(100) ) AS BEGIN -- Copyright © 2002 Narayana Vyas Kondreddi. All rights reserved. -- Purpose: To search all columns of all tables for a given search string -- Written by: Narayana Vyas Kondreddi -- Site: http: -- Tested on: SQL Server 7.0 and SQL Server 2000 -- Date modified: 28th July 2002 22:50 GMT -- Copyright @ 2012 Gyula Kulifai. All rights reserved. -- Extended By: Gyula Kulifai -- Purpose: To put key values, to exactly determine the position of search -- Resources: Anatoly Lubarsky -- Date extension: 19th October 2012 12:24 GMT -- Tested on: SQL Server 10.0.5500 (SQL Server 2008 SP3) CREATE TABLE SET NOCOUNT ON DECLARE @TableName nvarchar(256), @ColumnName nvarchar(128), @SearchStr2 nvarchar(110) ,@TableShortName nvarchar(256) ,@TableKeys nvarchar(512) ,@SQL nvarchar(3830) SET @TableName = SET @SearchStr2 = QUOTENAME( WHILE @TableName IS NOT NULL BEGIN SET @ColumnName = -- Scan Tables SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = AND QUOTENAME(TABLE_SCHEMA) + AND OBJECTPROPERTY( OBJECT_ID( QUOTENAME(TABLE_SCHEMA) + ), ) = 0 ) Set @TableShortName=PARSENAME(@TableName, 1) -- print @TableName + -- LOOK Key Fields, Set Key Columns SET @TableKeys= SELECT @TableKeys = @TableKeys + FROM syscolumns WHERE [id] IN ( SELECT [id] FROM sysobjects WHERE [name] = @TableShortName) AND colid IN ( SELECT SIK.colid FROM sysindexkeys SIK JOIN sysobjects SO ON SIK.[id] = SO.[id] WHERE SIK.indid = 1 AND SO.[name] = @TableShortName) If @TableKeys<> SET @TableKeys=SUBSTRING(@TableKeys,1,Len(@TableKeys)-8) -- Print @TableName + -- Search in Columns WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) BEGIN SET @ColumnName = ( SELECT MIN(QUOTENAME(COLUMN_NAME)) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) AND DATA_TYPE IN ( AND QUOTENAME(COLUMN_NAME) > @ColumnName ) -- Set ColumnName IF @ColumnName IS NOT NULL BEGIN SET @SQL=' SELECT , , ,LEFT( FROM --Print @SQL -- *** DEBUG LINE *** INSERT INTO Exec (@SQL) END -- IF ColumnName END -- While Table and Column END --While Table SELECT TableName, KeyValues, ColumnName, ColumnValue FROM END
DECLARE @SearchStrTableName nvarchar(255), @SearchStrColumnName nvarchar(255), @SearchStrColumnValue nvarchar(255), @SearchStrInXML bit, @FullRowResult bit, @FullRowResultRows int SET @SearchStrColumnValue = SET @FullRowResult = 1 SET @FullRowResultRows = 3 SET @SearchStrTableName = NULL SET @SearchStrColumnName = NULL SET @SearchStrInXML = 0 IF OBJECT_ID( CREATE TABLE SET NOCOUNT ON DECLARE @TableName nvarchar(256) = SET @QuotedSearchStrColumnValue = QUOTENAME(@SearchStrColumnValue, DECLARE @ColumnNameTable TABLE (COLUMN_NAME nvarchar(128),DATA_TYPE nvarchar(20)) WHILE @TableName IS NOT NULL BEGIN SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = AND TABLE_NAME LIKE COALESCE(@SearchStrTableName,TABLE_NAME) AND QUOTENAME(TABLE_SCHEMA) + AND OBJECTPROPERTY(OBJECT_ID(QUOTENAME(TABLE_SCHEMA) + ) IF @TableName IS NOT NULL BEGIN DECLARE @sql VARCHAR(MAX) SET @sql = FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME( AND TABLE_NAME = PARSENAME( AND DATA_TYPE IN ( AND COLUMN_NAME LIKE COALESCE( INSERT INTO @ColumnNameTable EXEC (@sql) WHILE EXISTS (SELECT TOP 1 COLUMN_NAME FROM @ColumnNameTable) BEGIN PRINT @ColumnName SELECT TOP 1 @ColumnName = COLUMN_NAME,@ColumnType = DATA_TYPE FROM @ColumnNameTable SET @sql = WHEN ELSE FROM WHEN ELSE @ColumnName END + INSERT INTO EXEC(@sql) IF @@ROWCOUNT > 0 IF @FullRowResult = 1 BEGIN SET @sql = WHEN ELSE @ColumnName END + EXEC(@sql) END DELETE FROM @ColumnNameTable WHERE COLUMN_NAME = @ColumnName END END END SET NOCOUNT OFF SELECT TableName, ColumnName, ColumnValue, ColumnType, COUNT(*) AS Count FROM GROUP BY TableName, ColumnName, ColumnValue, ColumnType
CREATE PROC [dbo].[SearchAllTables_Like] ( @SearchStr nvarchar(100) ) AS BEGIN -- Copyright © 2002 Narayana Vyas Kondreddi. All rights reserved. -- Purpose: To search all columns of all tables for a given search string -- Written by: Narayana Vyas Kondreddi -- Site: http: -- Tested on: SQL Server 7.0 and SQL Server 2000 -- Date modified: 28th July 2002 22:50 GMT CREATE TABLE SET NOCOUNT ON DECLARE @TableName nvarchar(256), @ColumnName nvarchar(128), @SearchStr2 nvarchar(110) SET @TableName = SET @SearchStr2 = QUOTENAME( WHILE @TableName IS NOT NULL BEGIN SET @ColumnName = SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = AND QUOTENAME(TABLE_SCHEMA) + AND OBJECTPROPERTY( OBJECT_ID( QUOTENAME(TABLE_SCHEMA) + ), ) = 0 ) WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) BEGIN SET @ColumnName = ( SELECT MIN(QUOTENAME(COLUMN_NAME)) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) AND DATA_TYPE IN ( AND QUOTENAME(COLUMN_NAME) > @ColumnName ) IF @ColumnName IS NOT NULL BEGIN INSERT INTO EXEC ( FROM ) END END END SELECT ColumnName, ColumnValue FROM END
CONVERT(VARCHAR(32), master.sys.fn_repl_hash_binary(@binary_data), 2)
SELECT ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n FROM (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) ones(n), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) tens(n), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) hundreds(n), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) thousands(n) WHERE ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n BETWEEN @userinput1 AND @userinput2 ORDER BY 1
WITH x AS (SELECT n FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) v(n)) SELECT ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n FROM x ones, x tens, x hundreds, x thousands ORDER BY 1
DECLARE @startnum INT=1000 DECLARE @endnum INT=1050 ; WITH gen AS ( SELECT @startnum AS num UNION ALL SELECT num+1 FROM gen WHERE num+1<=@endnum ) SELECT * FROM gen option (maxrecursion 10000)
SELECT DISTINCT n = number FROM master..[spt_values] WHERE number BETWEEN @start AND @end
;WITH Nums AS ( SELECT n = ROW_NUMBER() OVER (ORDER BY [object_id]) FROM sys.all_objects ) SELECT n FROM Nums WHERE n BETWEEN @start AND @end ORDER BY n;
CREATE FUNCTION [dbo].[fn_ConsecutiveNumbers] ( @start int, @end int ) RETURNS TABLE RETURN select x268435456.X | x16777216.X | x1048576.X | x65536.X | x4096.X | x256.X | x16.X | x1.X + @start X from (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15)) as x1(X) join (VALUES (0),(16),(32),(48),(64),(80),(96),(112),(128),(144),(160),(176),(192),(208),(224),(240)) as x16(X) on x1.X <= @end-@start and x16.X <= @end-@start join (VALUES (0),(256),(512),(768),(1024),(1280),(1536),(1792),(2048),(2304),(2560),(2816),(3072),(3328),(3584),(3840)) as x256(X) on x256.X <= @end-@start join (VALUES (0),(4096),(8192),(12288),(16384),(20480),(24576),(28672),(32768),(36864),(40960),(45056),(49152),(53248),(57344),(61440)) as x4096(X) on x4096.X <= @end-@start join (VALUES (0),(65536),(131072),(196608),(262144),(327680),(393216),(458752),(524288),(589824),(655360),(720896),(786432),(851968),(917504),(983040)) as x65536(X) on x65536.X <= @end-@start join (VALUES (0),(1048576),(2097152),(3145728),(4194304),(5242880),(6291456),(7340032),(8388608),(9437184),(10485760),(11534336),(12582912),(13631488),(14680064),(15728640)) as x1048576(X) on x1048576.X <= @end-@start join (VALUES (0),(16777216),(33554432),(50331648),(67108864),(83886080),(100663296),(117440512),(134217728),(150994944),(167772160),(184549376),(201326592),(218103808),(234881024),(251658240)) as x16777216(X) on x16777216.X <= @end-@start join (VALUES (0),(268435456),(536870912),(805306368),(1073741824),(1342177280),(1610612736),(1879048192)) as x268435456(X) on x268435456.X <= @end-@start WHERE @end >= x268435456.X | isnull(x16777216.X, 0) | isnull(x1048576.X, 0) | isnull(x65536.X, 0) | isnull(x4096.X, 0) | isnull(x256.X, 0) | isnull(x16.X, 0) | isnull(x1.X, 0) + @start GO SELECT X FROM fn_ConsecutiveNumbers(5, 500);
SELECT DATEADD(day,X, 0) DayX FROM fn_ConsecutiveNumbers(datediff(day,0, SELECT DATEADD(hour,X, 0) HourX FROM fn_ConsecutiveNumbers(datediff(hour,0,
select TimeRanges.StartTime, TimeRanges.EndTime, DATEADD(minute,X, 0) MinuteX FROM TimeRanges cross apply fn_ConsecutiveNumbers(datediff(hour,0,TimeRanges.StartTime), datediff(hour,0,TimeRanges.EndTime)) ConsecutiveNumbers
DECLARE @min bigint, @max bigint SELECT @Min=919859000000 ,@Max=919859999999 SELECT TOP (@Max-@Min+1) @Min-1+row_number() over(order by t1.number) as N FROM master..spt_values t1 CROSS JOIN master..spt_values t2
select top 50 ROW_NUMBER() over(order by a.name) + 1000 as Rcount from sys.all_objects a
using System; using System.Collections; using System.Data; using System.Data.Sql; using System.Data.SqlTypes; using Microsoft.SqlServer.Server; namespace YourNamespace { public sealed class SequenceGenerator { [SqlFunction(FillRowMethodName = "FillRow")] public static IEnumerable Generate(SqlInt32 start, SqlInt32 end) { int _start = start.Value; int _end = end.Value; for (int i = _start; i <= _end; i++) yield return i; } public static void FillRow(Object obj, out int i) { i = (int)obj; } private SequenceGenerator() { } } }
USE db; CREATE ASSEMBLY SqlUtil FROM WITH permission_set=Safe; CREATE FUNCTION [Seq](@start int, @end int) RETURNS TABLE(i int) AS EXTERNAL NAME [SqlUtil].[YourNamespace.SequenceGenerator].[Generate];
DECLARE @Start INT, @End INT SET @Start = 1000 SET @End = 1050 SELECT TOP (@End - @Start+1) ROW_NUMBER() OVER (ORDER BY S.[object_id])+(@Start - 1) [Numbers] FROM sys.all_objects S WITH (NOLOCK)
declare @initial as int = 1000; declare @final as int =1050; with cte_n as ( select @initial as contador union all select contador+1 from cte_n where contador <@final ) select * from cte_n option (maxrecursion 0)
USE master; declare @min as int; set @min = 1000; declare @max as int; set @max = 1050; --null returns all -- Up to 256 - 2 048 rows depending on SQL Server version select isnull(@min,0)+number.number as number FROM dbo.spt_values AS number WHERE number."type" = and ( @max is null --return all or isnull(@min,0)+number.number <= @max --return up to max ) order by number ; -- Up to 65 536 - 4 194 303 rows depending on SQL Server version select isnull(@min,0)+value1.number+(value2.number*numberCount.numbers) as number FROM dbo.spt_values AS value1 cross join dbo.spt_values AS value2 cross join ( --get the number of numbers (depends on version) select sum(1) as numbers from dbo.spt_values where spt_values."type" = ) as numberCount WHERE value1."type" = and value2."type" = and ( @max is null --return all or isnull(@min,0)+value1.number+(value2.number*numberCount.numbers) <= @max --return up to max ) order by number ;
DECLARE @startNum INT = 1000; DECLARE @endNum INT = 1050; INSERT INTO dbo.Numbers ( Num ) SELECT CASE WHEN MAX(Num) IS NULL THEN @startNum ELSE MAX(Num) + 1 END AS Num FROM dbo.Numbers GO 51
DECLARE @num INT = 1000 WHILE(@num<1050) begin INSERT INTO [dbo].[Codes] ( Code ) VALUES (@num) SET @num = @num + 1 end
DECLARE @startnum INT=1000 DECLARE @endnum INT=1050 DECLARE @size INT=@endnum-@startnum+1 ; WITH numrange (num) AS ( SELECT 1 AS num UNION ALL SELECT num*2 FROM numrange WHERE num*2<=@size UNION ALL SELECT num*2+1 FROM numrange WHERE num*2+1<=@size ) SELECT num+@startnum-1 FROM numrange order by num
SELECT ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS n FROM (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x1(x), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x2(x), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x3(x), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x4(x), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x5(x) ORDER BY n
DECLARE @n1 AS INT = 100; DECLARE @n2 AS INT = 40099; WITH numbers AS ( SELECT ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS n FROM (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x1(x), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x2(x), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x3(x), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x4(x), (VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) x5(x) ) SELECT numbers.n FROM numbers WHERE n BETWEEN @n1 and @n2 ORDER BY n
WITH x AS (SELECT n FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) v(n)) SELECT ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n FROM x ones, x tens, x hundreds, x thousands ORDER BY 1
WITH x AS (SELECT n FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) v(n)) SELECT TOP (1+@Upper-@Lower) @Lower + ones.n + 10*tens.n + 100*hundreds.n + 1000*thousands.n FROM x thousands INNER REMOTE JOIN x hundreds on 1=1 INNER REMOTE JOIN x tens on 1=1 INNER REMOTE JOIN x ones on 1=1
alter function [dbo].[fn_GenerateNumbers] ( @start int, @end int ) returns table return with b0 as (select n from (values (0),(0x00000001),(0x00000002),(0x00000003),(0x00000004),(0x00000005),(0x00000006),(0x00000007),(0x00000008),(0x00000009),(0x0000000A),(0x0000000B),(0x0000000C),(0x0000000D),(0x0000000E),(0x0000000F)) as b0(n)), b1 as (select n from (values (0),(0x00000010),(0x00000020),(0x00000030),(0x00000040),(0x00000050),(0x00000060),(0x00000070),(0x00000080),(0x00000090),(0x000000A0),(0x000000B0),(0x000000C0),(0x000000D0),(0x000000E0),(0x000000F0)) as b1(n)), b2 as (select n from (values (0),(0x00000100),(0x00000200),(0x00000300),(0x00000400),(0x00000500),(0x00000600),(0x00000700),(0x00000800),(0x00000900),(0x00000A00),(0x00000B00),(0x00000C00),(0x00000D00),(0x00000E00),(0x00000F00)) as b2(n)), b3 as (select n from (values (0),(0x00001000),(0x00002000),(0x00003000),(0x00004000),(0x00005000),(0x00006000),(0x00007000),(0x00008000),(0x00009000),(0x0000A000),(0x0000B000),(0x0000C000),(0x0000D000),(0x0000E000),(0x0000F000)) as b3(n)), b4 as (select n from (values (0),(0x00010000),(0x00020000),(0x00030000),(0x00040000),(0x00050000),(0x00060000),(0x00070000),(0x00080000),(0x00090000),(0x000A0000),(0x000B0000),(0x000C0000),(0x000D0000),(0x000E0000),(0x000F0000)) as b4(n)), b5 as (select n from (values (0),(0x00100000),(0x00200000),(0x00300000),(0x00400000),(0x00500000),(0x00600000),(0x00700000),(0x00800000),(0x00900000),(0x00A00000),(0x00B00000),(0x00C00000),(0x00D00000),(0x00E00000),(0x00F00000)) as b5(n)), b6 as (select n from (values (0),(0x01000000),(0x02000000),(0x03000000),(0x04000000),(0x05000000),(0x06000000),(0x07000000),(0x08000000),(0x09000000),(0x0A000000),(0x0B000000),(0x0C000000),(0x0D000000),(0x0E000000),(0x0F000000)) as b6(n)), b7 as (select n from (values (0),(0x10000000),(0x20000000),(0x30000000),(0x40000000),(0x50000000),(0x60000000),(0x70000000)) as b7(n)) select s.n from ( select b7.n | b6.n | b5.n | b4.n | b3.n | b2.n | b1.n | b0.n + @start n from b0 join b1 on b0.n <= @end-@start and b1.n <= @end-@start join b2 on b2.n <= @end-@start join b3 on b3.n <= @end-@start join b4 on b4.n <= @end-@start join b5 on b5.n <= @end-@start join b6 on b6.n <= @end-@start join b7 on b7.n <= @end-@start ) s where @end >= s.n GO
DECLARE @num INT = 8270058 WHILE(@num<8270284) begin INSERT INTO [dbo].[Galleries] (ImagePath) VALUES ( SET @num = @num + 1 end
DECLARE @num INT = 1000 WHILE(@num<1051) begin SELECT @num SET @num = @num + 1 end
-- Generate Numeric Range -- Source: http: CREATE TABLE n int ) DECLARE @MinNum int DECLARE @MaxNum int DECLARE @I int SET NOCOUNT ON SET @I = 0 WHILE @I <= 9 BEGIN INSERT INTO SET @I = @I + 1 END SET @MinNum = 1 SET @MaxNum = 1000000 SELECT num = a.n + (b.n * 10) + (c.n * 100) + (d.n * 1000) + (e.n * 10000) FROM CROSS JOIN CROSS JOIN CROSS JOIN CROSS JOIN WHERE a.n + (b.n * 10) + (c.n * 100) + (d.n * 1000) + (e.n * 10000) BETWEEN @MinNum AND @MaxNum ORDER BY a.n + (b.n * 10) + (c.n * 100) + (d.n * 1000) + (e.n * 10000) DROP TABLE
select top 100 row_number() over (order by dbo.foo.bar) as seq from dbo.foo
create or alter function dbo.fn_range(@start int, @end int) returns table return with u2(n) as ( select n from (VALUES (0),(1),(2),(3)) v(n) ), u8(n) as ( select x0.n | x1.n * 4 | x2.n * 16 | x3.n * 64 as n from u2 x0, u2 x1, u2 x2, u2 x3 ) select @start + s.n as n from ( select x0.n | isnull(x1.n, 0) * 256 | isnull(x2.n, 0) * 65536 as n from u8 x0 left join u8 x1 on @end-@start > 256 left join u8 x2 on @end-@start > 65536 ) s where s.n < @end - @start
declare @s bigint = 10000000 , @e bigint = 20000000 ;WITH Z AS (SELECT 0 z FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15)) T(n)), Y AS (SELECT 0 z FROM Z a, Z b, Z c, Z d, Z e, Z f, Z g, Z h, Z i, Z j, Z k, Z l, Z m, Z n, Z o, Z p), N AS (SELECT ROW_NUMBER() OVER (PARTITION BY 0 ORDER BY z) n FROM Y) SELECT TOP (1+@e-@s) @s + n - 1 FROM N
CREATE FUNCTION [dbo].[Sequence] (@start int, @end int) RETURNS @Result TABLE(ID int) AS begin declare @i int; set @i = @start; while @i <= @end begin insert into @result values (@i); set @i = @i+1; end return; end
SELECT DateAdd(hh,ID, HoursInTheDay 2018-06-20 00:00:00.000 2018-06-20 01:00:00.000 2018-06-20 02:00:00.000 2018-06-20 03:00:00.000 2018-06-20 04:00:00.000 (...)
SELECT count(1) FROM [dbo].[Sequence] ( 1000001 ,2000000) GO
select rownum+1000 from all_objects fetch first 50 rows only;
create database yourdb on ( name = filename = size = 25mb, maxsize = 1500mb, filegrowth = 10mb ) log on ( name = filename = size = 7mb, maxsize = 375mb, filegrowth = 10mb ) COLLATE SQL_Latin1_General_CP1_CI_AS; go
select COLUMN_NAME, TABLE_NAME from INFORMATION_SCHEMA.COLUMNS where COLUMNPROPERTY(object_id(TABLE_SCHEMA+ order by TABLE_NAME
select o.name, c.name from sys.objects o inner join sys.columns c on o.object_id = c.object_id where c.is_identity = 1
IF ((SELECT OBJECTPROPERTY( OBJECT_ID(N PRINT ELSE PRINT
select object_name(object_id), name from sys.columns where is_identity = 1
SELECT sys.objects.name AS table_name, sys.columns.name AS column_name FROM sys.columns JOIN sys.objects ON sys.columns.object_id=sys.objects.object_id WHERE sys.columns.is_identity=1 AND sys.objects.type in (N
DECLARE @threshold DECIMAL(3,2); SET @threshold = .85; CREATE TABLE ( database_name VARCHAR(128) , table_name VARCHAR(128) , column_name VARCHAR(128) , data_type VARCHAR(128) , last_value BIGINT , max_value BIGINT ); DECLARE @dbname sysname; DECLARE @sql nvarchar(4000); -- Use an cursor to iterate through the databases since in 2000 there DECLARE c cursor FAST_FORWARD FOR SELECT name FROM master.dbo.sysdatabases WHERE name NOT IN( OPEN c; FETCH NEXT FROM c INTO @dbname; WHILE @@FETCH_STATUS = 0 BEGIN SET @sql = N Insert Into Select , Object_Name(id.id) As [table_name] , id.name As [column_name] , t.name As [data_type] , IDENT_CURRENT(Object_Name(id.id)) As [last_value] , Case When t.name = When t.name = When t.name = When t.name = End As [max_value] From syscolumns As id Join systypes As t On id.xtype = t.xtype Where id.colstat&1 = 1 -- this identifies the identity columns (as far as I know) EXECUTE sp_executesql @sql; FETCH NEXT FROM c INTO @dbname; END CLOSE c; DEALLOCATE c; SELECT database_name , table_name , column_name , data_type , last_value , CASE WHEN last_value < 0 THEN 100 ELSE (1 - CAST(last_value AS FLOAT(4)) / max_value) * 100 END AS [percentLeft] , CASE WHEN CAST(last_value AS FLOAT(4)) / max_value >= @threshold THEN ELSE END AS [id_status] FROM ORDER BY percentLeft; DROP TABLE
SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE (TABLE_SCHEMA = ORDER BY TABLE_NAME
SELECT CASE WHEN C.autoval IS NOT NULL THEN ELSE AND FROM sysobjects O INNER JOIN syscolumns C ON O.id = C.id WHERE O.NAME = @TableName AND C.NAME = @ColumnName
USE <database_name>; GO SELECT SCHEMA_NAME(schema_id) AS schema_name , t.name AS table_name , c.name AS column_name FROM sys.tables AS t JOIN sys.identity_columns c ON t.object_id = c.object_id ORDER BY schema_name, table_name; GO
DECLARE @Table_Name VARCHAR(100) DECLARE @Column_Name VARCHAR(100) SET @Table_Name = SET @Column_Name = SELECT RowNumber = ROW_NUMBER() OVER ( PARTITION BY T.[Name] ORDER BY T.[Name], C.column_id ) , SCHEMA_NAME(T.schema_id) AS SchemaName , T.[Name] AS Table_Name , C.[Name] AS Field_Name , sysType.name , C.max_length , C.is_nullable , C.is_identity , C.scale , C.precision FROM Sys.Tables AS T LEFT JOIN Sys.Columns AS C ON ( T.[Object_Id] = C.[Object_Id] ) LEFT JOIN sys.types AS sysType ON ( C.user_type_id = sysType.user_type_id ) WHERE ( Type = AND ( C.Name LIKE AND ( T.Name LIKE ORDER BY T.[Name] , C.column_id
SELECT a.name AS TableName, b.name AS IdentityColumn FROM sys.sysobjects a JOIN sys.syscolumns b ON a.id = b.id WHERE is_identity = 1 ORDER BY name;
SELECT a.name AS TableName, b.name AS IdentityColumn FROM [YOUR_SERVER_NAME].[YOUR_DB_NAME].sys.sysobjects a JOIN [YOUR_SERVER_NAME].[YOUR_DB_NAME].sys.syscolumns b ON a.id = b.id WHERE is_identity = 1 ORDER BY name;
select TABLE_NAME tabla,COLUMN_NAME columna from INFORMATION_SCHEMA.COLUMNS where COLUMNPROPERTY(object_id(TABLE_SCHEMA+ order by TABLE_NAME
select TABLE_NAME tabla,COLUMN_NAME columna from INFORMATION_SCHEMA.COLUMNS where COLUMNPROPERTY(object_id(TABLE_SCHEMA+ union all select o.name tabla, c.name columna from sys.objects o inner join sys.columns c on o.object_id = c.object_id where c.is_identity = 1
SELECT ORDINAL_POSITION, COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH , IS_NULLABLE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = SELECT CONSTRAINT_NAME FROM INFORMATION_SCHEMA.CONSTRAINT_TABLE_USAGE WHERE TABLE_NAME = SELECT name, type_desc, is_unique, is_primary_key FROM sys.indexes WHERE [object_id] = OBJECT_ID(
using System; using System.Linq; using Microsoft.SqlServer.Management.Common; using Microsoft.SqlServer.Management.Smo; namespace ViewSource { public class ViewSource { public static void Main(string[] args) { if (args.Length != 6) { Console.Error.WriteLine("Syntax: ViewSource.exe <server>" + " <user> <password> <database> <schema> <table>"); } Script(args[0], args[1], args[2], args[3], args[4], args[5]); } private static void Script(string server, string user, string password, string database, string schema, string table) { new Server(new ServerConnection(server, user, password)) .Databases[database] .Tables[table, schema] .Script(new ScriptingOptions { SchemaQualify = true, DriAll = true }) .Cast<string>() .Select(s => s + "\n" + "GO") .ToList() .ForEach(Console.WriteLine); } } }
--List all tables in DB select * from sysobjects where xtype = --Table Definition sp_help TableName
--Triggers in SQL Table select * from sys.triggers where parent_id = object_id(N
new Server(new ServerConnection(this.Connection.DataSource)) .Databases[this.Connection.Database] .Tables["<table>", "dbo"] ?.Script(new ScriptingOptions { SchemaQualify = true, DriAll = true, })
SELECT ORDINAL_POSITION, COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH , IS_NULLABLE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME =
Import-Module sqlps $serverInstance = "<server>" $database = "<database>" $table = "<table>" $schema = "<schema>" $options = New-Object -TypeName Microsoft.SqlServer.Management.Smo.ScriptingOptions $options.DriAll = $true $options.SchemaQualify = $true $connection = New-Object -TypeName Microsoft.SqlServer.Management.Common.ServerConnection ` -ArgumentList $serverInstance $server = New-Object -TypeName Microsoft.SqlServer.Management.Smo.Server ` -ArgumentList $connection $server.Databases.Item($database).Tables.Item($table, $schema).Script($options) ` | ForEach-Object -Process { $_ + "`nGO"}
Import-Module sqlps $serverInstance = "<server>" $user = "<user>" $password = "<pasword>" $database = "<database>" $table = "<table>" $schema = "<schema>" $options = New-Object -TypeName Microsoft.SqlServer.Management.Smo.ScriptingOptions $options.DriAll = $true $options.SchemaQualify = $true $connection = New-Object -TypeName Microsoft.SqlServer.Management.Common.ServerConnection ` -ArgumentList $serverInstance $connection.LoginSecure = $false $connection.Login = $user $connection.Password = $password $server = New-Object -TypeName Microsoft.SqlServer.Management.Smo.Server ` -ArgumentList $connection $server.Databases.Item($database).Tables.Item($table, $schema).Script($options) ` | ForEach-Object -Process { $_ + "`nGO"}
pg_dump -s -t tablename dbname1 > /tmp/foo.sql psql -e dbname2 < /tmp/foo.sql
DECLARE @SelectedValue int SELECT @SelectedValue = MyIntField FROM MyTable WHERE MyPrimaryKeyField = 1
CREATE PROCEDURE GetMyInt AS SELECT MyIntField FROM MyTable WHERE MyPrimaryKeyField = 1
DECLARE @SelectedValue int SELECT @SelectedValue = EXEC GetMyInt
CREATE PROCEDURE GetMyInt ( @Param int) AS DECLARE @ReturnValue int SELECT @ReturnValue=MyIntField FROM MyTable WHERE MyPrimaryKeyField = @Param RETURN @ReturnValue GO
DECLARE @SelectedValue int ,@Param int SET @Param=1 EXEC @SelectedValue = GetMyInt @Param PRINT @SelectedValue
CREATE PROCEDURE GetMyInt ( @Param int ,@OutValue int OUTPUT) AS SELECT @OutValue=MyIntField FROM MyTable WHERE MyPrimaryKeyField = @Param RETURN 0 GO
DECLARE @SelectedValue int ,@Param int SET @Param=1 EXEC GetMyInt @Param, @SelectedValue OUTPUT PRINT @SelectedValue
CREATE PROCEDURE GetMyInt ( @Param int) AS SELECT MyIntField FROM MyTable WHERE MyPrimaryKeyField = @Param RETURN 0 GO
DECLARE @ResultSet table (SelectedValue int) DECLARE @Param int SET @Param=1 INSERT INTO @ResultSet (SelectedValue) EXEC GetMyInt @Param SELECT * FROM @ResultSet
CREATE PROCEDURE [TestProc] AS BEGIN DECLARE @Temp TABLE ( [Name] VARCHAR(50) ) INSERT INTO @Temp VALUES ( INSERT INTO @Temp VALUES ( INSERT INTO @Temp VALUES ( INSERT INTO @Temp VALUES ( -- Get recordset SELECT * FROM @Temp DECLARE @ReturnValue INT SELECT @ReturnValue = COUNT([Name]) FROM @Temp -- Return count RETURN @ReturnValue END
DECLARE @SelectedValue int EXEC @SelectedValue = [TestProc] SELECT @SelectedValue
DECLARE @SelectedValue int CREATE PROCEDURE GetMyInt (@MyIntField int OUTPUT) AS SELECT @MyIntField = MyIntField FROM MyTable WHERE MyPrimaryKeyField = 1
CREATE NONCLUSTERED INDEX MyIndex ON MyTable(ID) INCLUDE (Name, Address)
SELECT ID, Name, Address FROM MyTable WHERE ID > 1000
Paul | John | Tim | Eric Red 1 5 1 3 Green 8 4 3 5 Blue 2 2 9 1
Red | Green | Blue Paul 1 8 2 John 5 4 2 Tim 1 3 9 Eric 3 5 1
CREATE TABLE yourTable([color] varchar(5), [Paul] int, [John] int, [Tim] int, [Eric] int); INSERT INTO yourTable ([color], [Paul], [John], [Tim], [Eric]) VALUES ( ( (
select name, sum(case when color = sum(case when color = sum(case when color = from ( select color, Paul value, from yourTable union all select color, John value, from yourTable union all select color, Tim value, from yourTable union all select color, Eric value, from yourTable ) src group by name
select name, [Red], [Green], [Blue] from ( select color, name, value from yourtable unpivot ( value for name in (Paul, John, Tim, Eric) ) unpiv ) src pivot ( sum(value) for color in ([Red], [Green], [Blue]) ) piv
DECLARE @colsUnpivot AS NVARCHAR(MAX), @query AS NVARCHAR(MAX), @colsPivot as NVARCHAR(MAX) select @colsUnpivot = stuff((select from sys.columns as C where C.object_id = object_id( C.name <> for xml path( select @colsPivot = STUFF((SELECT + quotename(color) from yourtable t FOR XML PATH( ).value( ,1,1, set @query = from ( select color, name, value from yourtable unpivot ( value for name in ( ) unpiv ) src pivot ( sum(value) for color in ( ) piv' exec(@query)
| NAME | RED | GREEN | BLUE | ----------------------------- | Eric | 3 | 5 | 1 | | John | 5 | 4 | 2 | | Paul | 1 | 8 | 2 | | Tim | 1 | 3 | 9 |
create table tbl ( color varchar(10), Paul int, John int, Tim int, Eric int); insert tbl select
select * from tbl unpivot (value for name in ([Paul],[John],[Tim],[Eric])) up pivot (max(value) for color in ([Red],[Green],[Blue])) p
| NAME | RED | GREEN | BLUE | ----------------------------- | Eric | 3 | 5 | 1 | | John | 5 | 4 | 2 | | Paul | 1 | 8 | 2 | | Tim | 1 | 3 | 9 |
/****** Object: StoredProcedure [dbo].[SQLTranspose] Script Date: 11/10/2015 7:08:02 PM ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO -- ============================================= -- Author: Paco Zarate -- Create date: 2015-11-10 -- Description: SQLTranspose dynamically changes a table to show rows as headers. It needs that all the values are numeric except for the field using for transposing. -- Parameters: @TableName - Table to transpose -- @FieldNameTranspose - Column that will be the new headers -- Usage: exec SQLTranspose <table>, <FieldToTranspose> -- ============================================= ALTER PROCEDURE [dbo].[SQLTranspose] -- Add the parameters for the stored procedure here @TableName NVarchar(MAX) = @FieldNameTranspose NVarchar(MAX) = AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; DECLARE @colsUnpivot AS NVARCHAR(MAX), @query AS NVARCHAR(MAX), @queryPivot AS NVARCHAR(MAX), @colsPivot as NVARCHAR(MAX), @columnToPivot as NVARCHAR(MAX), @tableToPivot as NVARCHAR(MAX), @colsResult as xml select @tableToPivot = @TableName; select @columnToPivot = @FieldNameTranspose select @colsUnpivot = stuff((select from sys.columns as C where C.object_id = object_id(@tableToPivot) and C.name <> @columnToPivot for xml path( set @queryPivot = + quotename( from where FOR XML PATH( exec sp_executesql @queryPivot, N select @colsPivot = STUFF(@colsResult.value( set @query = from ( select from unpivot ( value for name in ( ) unpiv ) src pivot ( sum(value) for ) piv order by rowid' exec(@query) END
with cte as ( select from yourTable union all select from yourTable union all select from yourTable union all select from yourTable ) select Name, [Red], [Green], [Blue] from ( select * from cte ) as src pivot ( max(Value) for color IN ([Red], [Green], [Blue]) ) as Dtpivot;
select @colsUnpivot = stuff((select from sys.columns as C where C.object_id = object_id(@tableToPivot) and C.name <> @columnToPivot and C.system_type_id = 56 --56 = type int for xml path(
select name, system_type_id from sys.types order by name
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO -- ============================================= -- Author: ELD. -- Create date: May, 5 2016. -- Description: Transpose from rows to columns the user split function. -- ============================================= CREATE PROCEDURE TransposeSplit @InputToSplit VARCHAR(8000) ,@Delimeter VARCHAR(8000) = AS BEGIN SET NOCOUNT ON; DECLARE @colsUnpivot AS NVARCHAR(MAX) ,@query AS NVARCHAR(MAX) ,@queryPivot AS NVARCHAR(MAX) ,@colsPivot AS NVARCHAR(MAX) ,@columnToPivot AS NVARCHAR(MAX) ,@tableToPivot AS NVARCHAR(MAX) ,@colsResult AS XML SELECT @tableToPivot = SELECT @columnToPivot = CREATE TABLE col_number INT ,col_value VARCHAR(8000) ) INSERT INTO col_number ,col_value ) SELECT ROW_NUMBER() OVER ( ORDER BY ( SELECT 100 ) ) AS RowNumber ,item FROM [DB].[ESCHEME].[fnSplit](@InputToSplit, @Delimeter) SELECT @colsUnpivot = STUFF(( SELECT FROM [tempdb].sys.columns AS C WHERE C.object_id = object_id( AND C.NAME <> @columnToPivot FOR XML path( ), 1, 1, SET @queryPivot = + quotename( from where FOR XML PATH( EXEC sp_executesql @queryPivot ,N ,@colsResult OUT SELECT @colsPivot = STUFF(@colsResult.value( SET @query = from ( select from unpivot ( value for name in ( ) unpiv ) src pivot ( MAX(value) for ) piv order by rowid' EXEC (@query) DROP TABLE END GO
DECLARE @RC int DECLARE @InputToSplit varchar(MAX) DECLARE @Delimeter varchar(1) set @InputToSplit = set @Delimeter = EXECUTE @RC = [TransposeSplit] @InputToSplit ,@Delimeter GO
Declare @TableName [nvarchar](128) Declare @ExecStr nvarchar(max) Declare @Where nvarchar(max) Set @TableName = --Enter Filtering If Exists Set @Where = --Set @ExecStr = N --Exec(@ExecStr) Drop Table If Exists Create Table (Field_Name nvarchar(128) Not Null ,Field_Value nvarchar(max) Null ) Set @ExecStr = N Select @ExecStr += (Select N from sys.columns as C where (C.object_id = object_id(@TableName)) for xml path( Select @ExecStr = Left(@ExecStr,Len(@ExecStr)-Len( --Print @ExecStr Exec (@ExecStr) Select * From Go
Select * from <table> where <col1> = <value> order by <PrimaryKey>
select * from table where isExternal = @type = 2 ? 1 : 0
select * from table where isExternal = case @type when 2 then 1 else 0 end
SELECT * FROM table WHERE isExternal = IIF(@type = 2, 1, 0)
UPDATE [CMS_DB_test].[dbo].[cms_HtmlText] SET Content = REPLACE(Content, WHERE Content LIKE
UPDATE [CMS_DB_test].[dbo].[cms_HtmlText] SET Content = CAST(REPLACE(CAST(Content as NVarchar(4000)), WHERE Content LIKE
UPDATE [CMS_DB_test].[dbo].[cms_HtmlText] SET Content = CAST(REPLACE(CAST(Content as NVarchar(MAX)), WHERE Content LIKE
select cast(replace(cast(myntext as nvarchar(max)), from myntexttable
WITH cte1 AS ( SELECT * from cdr.Location ) select * from cte1
WITH cte1 as ( SELECT * from cdr.Location ) WITH cte2 as ( SELECT * from cdr.Location ) select * from cte1 union select * from cte2
Msg 156, Level 15, State 1, Line 7 Incorrect syntax near the keyword Msg 319, Level 15, State 1, Line 7 Incorrect syntax near the keyword
Msg 102, Level 15, State 1, Line 5 Incorrect syntax near Msg 102, Level 15, State 1, Line 9 Incorrect syntax near
WITH cte1 as (SELECT * from cdr.Location), cte2 as (SELECT * from cdr.Location) select * from cte1 union select * from cte2
WITH cte1 as (SELECT * from cdr.Location), cte2 as (SELECT * from cdr.Location) select * from cte1 union select * from cte2
WITH cte1 as (SELECT * from cdr.Location), cte2 as (SELECT * from cte1 where val1 = val2) select * from cte1 union select * from cte2
IF EXISTS ( SELECT * FROM sysobjects WHERE id = object_id(N AND xtype IN (N ) DROP FUNCTION function_name GO
DROP FUNCTION [ IF EXISTS ] { [ schema_name. ] function_name } [ ,...n ] [;]
CREATE [ OR ALTER ] FUNCTION [ schema_name. ] function_name
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N AND type in (N DROP FUNCTION functionName GO
IF EXISTS (SELECT * FROM schema.sys.objects WHERE name = DROP FUNCTION [dbo].[func_name] GO
if(object_id(N drop function [dbo].[fn_Nth_Pos]; GO CREATE FUNCTION [dbo].[fn_Nth_Pos] ( @find char, --char to find @search varchar(max), --string to process @nth int --occurrence ) RETURNS int AS BEGIN declare @pos int --position of nth occurrence --init set @pos = 0 while(@nth > 0) begin set @pos = charindex(@find,@search,@pos+1) set @nth = @nth - 1 end return @pos END GO --EXAMPLE declare @files table(name varchar(max)); insert into @files(name) values( insert into @files(name) values( select f.name, dbo.fn_Nth_Pos( dbo.fn_Nth_Pos( dbo.fn_Nth_Pos( dbo.fn_Nth_Pos( from @files f;
IF EXISTS (SELECT TOP 1 1 FROM sys.objects WHERE object_id = OBJECT_ID(N AND type in (N BEGIN DROP FUNCTION [Schema].[function_Name] Print( END GO
IF EXISTS ( SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = N ) DROP FUNCTION [dbo].[FunctionName] GO
Table1 ---------- ID Name 1 A 2 B 3 C Table2 ---------- ID Name 1 Z
INSERT INTO Table2(Id, Name) SELECT Id, Name FROM Table1
IF NOT EXISTS(SELECT 1 FROM Table2 WHERE Id=1) INSERT INTO Table2 (Id, name) SELECT Id, name FROM Table1 ELSE INSERT INTO Table2 (Id, name) SELECT Id, name FROM Table1 WHERE Table1.Id<>1
INSERT INTO TABLE_2 (id, name) SELECT t1.id, t1.name FROM TABLE_1 t1 WHERE NOT EXISTS(SELECT id FROM TABLE_2 t2 WHERE t2.id = t1.id)
INSERT INTO TABLE_2 (id, name) SELECT t1.id, t1.name FROM TABLE_1 t1 WHERE t1.id NOT IN (SELECT id FROM TABLE_2)
INSERT INTO TABLE_2 (id, name) SELECT t1.id, t1.name FROM TABLE_1 t1 LEFT JOIN TABLE_2 t2 ON t2.id = t1.id WHERE t2.id IS NULL
INSERT IGNORE INTO Table2(Id, Name) SELECT Id, Name FROM Table1
INSERT INTO Table2(Id, Name) SELECT DISTINCT Id, Name FROM Table1
In backward compatible syntax , WITH IGNORE_DUP_KEY is equivalent to WITH IGNORE_DUP_KEY = ON.
Insert into Table_2 Select distinct * from Table_1 where table_1.ID >1
INSERT INTO TABLE_2 (name) SELECT t1.name FROM TABLE_1 t1 GROUP BY t1.name
DELETE FROM Table2 WHERE Id = (SELECT Id FROM Table1) INSERT INTO Table2 (Id, name) SELECT Id, name FROM Table1
this is test string. this is test string. this is test string. this is test string.
select case when len(col)>=15 then left(col, 15) + else col end col from yourtable
Declare @name varchar(100); set @name= Select Cast(@name as varchar(10)) as new_name
SELECT col, LEN(col), col2, LEN(col2), col3, LEN(col3) FROM ( SELECT col, LEFT(x.col, 15) + (IIF(len(x.col) > 15, LEFT(x.col, 15) + (CASE WHEN len(x.col) > 15 THEN from ( select UNION SELECT UNION SELECT UNION SELECT NULL AS col UNION SELECT ) x ) y
CASE WHEN col IS NULL THEN ELSE SUBSTRING(col,1,15)+ END AS Col
<guids> <guid>809674df-1c22-46eb-bf9a-33dc78beb44a</guid> <guid>257f537f-9c6b-4f14-a90c-ee613b4287f3</guid> </guids>
SELECT ... FROM Table JOIN ( SELECT x.value(N FROM @values.nodes(N ON Table.guid = guids.guid;
SELECT (LEN(Stripes) - LEN(REPLACE(Stripes, FROM t_Contacts
DECLARE @StringToFind VARCHAR(100) = "Text To Count" SELECT (LEN([Field To Search]) - LEN(REPLACE([Field To Search],@StringToFind, FROM [Table To Search]
declare @v varchar(250) = -- LF ; select len(replace(@v,
SELECT COUNT(DECODE(SUBSTR(UPPER(:main_string),rownum,LENGTH(:search_char)),UPPER(:search_char),1)) search_char_count FROM DUAL connect by rownum <= length(:main_string);
ALTER DATABASE [database_name] SET COMPATIBILITY_LEVEL = 130
--some data DECLARE @table TABLE (col varchar(500)) INSERT INTO @table SELECT INSERT INTO @table SELECT INSERT INTO @table SELECT --string to find DECLARE @string varchar(100) = --select SELECT col , (SELECT COUNT(*) - 1 FROM STRING_SPLIT (REPLACE(REPLACE(col, FROM @table
-- DECLARE field because your table type may be text DECLARE @mmRxClaim nvarchar(MAX) -- Getting Value from table SELECT top (1) @mmRxClaim = mRxClaim FROM RxClaim WHERE rxclaimid_PK =362 -- Main String Value SELECT @mmRxClaim AS MainStringValue -- Count Multiple Character for this number of space will be number of character SELECT LEN(@mmRxClaim) - LEN(REPLACE(@mmRxClaim, -- Count Single Character for this number of space will be one SELECT LEN(@mmRxClaim) - LEN(REPLACE(@mmRxClaim,
ALTER FUNCTION [dbo].[ActualWeightDIMS] ( -- Add the parameters for the function here @ActualWeight int, @Actual_Dims_Lenght int, @Actual_Dims_Width int, @Actual_Dims_Height int ) RETURNS varchar(50) AS BEGIN DECLARE @ActualWeightDIMS varchar(50); --Actual Weight IF (@ActualWeight is not null) SET @ActualWeightDIMS = @ActualWeight; --Actual DIMS IF (@Actual_Dims_Lenght is not null) AND (@Actual_Dims_Width is not null) AND (@Actual_Dims_Height is not null) SET @ActualWeightDIMS= @Actual_Dims_Lenght + RETURN(@ActualWeightDIMS); END
select BA_Adjustment_Detail.ID_Number [ID_Number], BA_Adjustment_Detail.Submit_Date [Submit_Date], BA_Category.Category [category], BA_Type_Of_Request.Request [Type_Of_Request], dbo.ActualWeightDIMS(BA_Adjustment_Detail.ActualWeight,BA_Adjustment_Detail.Actual_Dims_Lenght,BA_Adjustment_Detail.Actual_Dims_Width,BA_Adjustment_Detail.Actual_Dims_Height) [Actual Weight/DIMS], BA_Adjustment_Detail.Notes [Notes], BA_Adjustment_Detail.UPSCustomerNo [UPSNo], BA_Adjustment_Detail.TrackingNo [AirbillNo], BA_Adjustment_Detail.StoreNo [StoreNo], BA_Adjustment_Detail.Download_Date [Download_Date], BA_Adjustment_Detail.Shipment_Date[ShipmentDate], BA_Adjustment_Detail.FranchiseNo [FranchiseNo], BA_Adjustment_Detail.CustomerNo [CustomerNo], BA_Adjustment_Detail.BillTo [BillTo], BA_Adjustment_Detail.Adjustment_Amount_Requested [Adjustment_Amount_Requested] from BA_Adjustment_Detail inner join BA_Category on BA_Category.ID = BA_Adjustment_Detail.CategoryID inner join BA_Type_Of_Request on BA_Type_Of_Request.ID = BA_Adjustment_Detail.TypeOfRequestID
SET @ActualWeightDIMS = CAST(@Actual_Dims_Lenght AS VARCHAR(16)) + CAST(@Actual_Dims_Width AS VARCHAR(16)) + CAST(@Actual_Dims_Height AS VARCHAR(16))
SET @ActualWeightDIMS = Concat(@Actual_Dims_Lenght, , @Actual_Dims_Height)
SET @ActualWeightDIMS= @Actual_Dims_Lenght + @Actual_Dims_Width +
SET @ActualWeightDIMS= CAST(@Actual_Dims_Lenght as varchar(3)) + CAST(@Actual_Dims_Width as varchar(3)) + CAST(@Actual_Dims_Height as varchar(3));
SET @ActualWeightDIMS = CAST(@ActualWeight as varchar(50));
SELECT @ActualWeightDIMS = CAST(@Actual_Dims_Lenght AS varchar(10)) + CAST(@Actual_Dims_Width as varchar(10)) +
SELECT @ActualWeightDIMS = STR(@Actual_Dims_Lenght) + +
with cte as( select ROW_NUMBER() over (order by repairid) as ) update CTE set [RepairProductId]= ISNULL([RepairProductId]+convert(nvarchar(10),RN),0) from cte
SET @ActualWeightDIMS = cast(@Actual_Dims_Lenght as varchar(8)) +
SELECT ... From ... WHERE date > DATEADD(year,-1,GETDATE())
SELECT .... FROM .... WHERE year(*your date column*) = year(DATEADD(year,-1,getdate()))
SELECT ... FROM ... WHERE YEAR(DATE) = YEAR(GETDATE()) - 1
SELECT ... FROM ... WHERE YEAR(DATE) = YEAR(GETDATE()) - 1 AND DATE >
SELECT * FROM TABLE WHERE Date > DATEADD(yy, -1, CONVERT(datetime, CONVERT(varchar, GETDATE(), 101)))
DECLARE @start datetime SET @start = dbo.getdatewithouttime(DATEADD(year, -1, GETDATE())) -- cut time (hours, minutes, ect.) -- getdatewithouttime() function doesn SELECT column1, column2, ..., columnN FROM table WHERE date >= @start
declare @iMonth int declare @sYear varchar(4) declare @sMonth varchar(2) set @iMonth = 0 while @iMonth > -12 begin set @sYear = year(DATEADD(month,@iMonth,GETDATE())) set @sMonth = right( select @sYear + @sMonth set @iMonth = @iMonth - 1 end
SELECT ... FROM ....WHERE CONVERT(datetime,REPLACE(LEFT(LTRIM([MoYr]),2),
select case when left(column,1) = then right(column, (len(column)-1)) else column end
select CASE WHEN ColumnName = substring(ColumnName, patindex( THEN ELSE substring(ColumnName, patindex( END
DECLARE @LeadingZeros VARCHAR(10) = SET @LeadingZeros = CASE WHEN PATINDEX( @LeadingZeros ELSE CAST(CAST(@LeadingZeros AS INT) AS VARCHAR(10)) END SELECT @LeadingZeros
select replace(replace(rtrim(replace(replace(replace(replace(ltrim(replace(replace([COLUMN],
SELECT replace(left(Convert(nvarchar,GETDATE(),101),2),
WHEN left(column, 3) = WHEN left(column, 2) = WHEN left(column, 1) = ELSE
select CASE WHEN TRY_CONVERT(bigint,Mtrl_Nbr) = 0 THEN ELSE substring(Mtrl_Nbr, patindex( END
use tempdb; CREATE TABLE T( id INT IDENTITY(1,1) PRIMARY KEY, number int, name8000 VARCHAR(8000), name500 VARCHAR(500)) INSERT INTO T (number,name8000,name500) SELECT number, name, name FROM master..spt_values SELECT id,name500 FROM T ORDER BY number
SELECT mt.ID, mt.ParentID, ot.MasterID FROM dbo.MainTable AS mt INNER JOIN dbo.OtherTable AS ot ON ot.ParentID = mt.ID OR ot.ID = mt.ParentID
SELECT mt.ID, mt.ParentID, CASE WHEN ot1.MasterID IS NOT NULL THEN ot1.MasterID ELSE ot2.MasterID END AS MasterID FROM dbo.MainTable AS mt LEFT JOIN dbo.OtherTable AS ot1 ON ot1.ParentID = mt.ID LEFT JOIN dbo.OtherTable AS ot2 ON ot2.ID = mt.ParentID WHERE ot1.MasterID IS NOT NULL OR ot2.MasterID IS NOT NULL
SELECT * FROM maintable m JOIN othertable o ON o.parentId = m.id UNION SELECT * FROM maintable m JOIN othertable o ON o.id = m.parentId
Select A.column, B.column FROM TABLE1 A INNER JOIN TABLE2 B ON A.Id = (case when (your condition) then b.Id else (something) END)
SELECT 199.96 - (0.0 * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4)))) -- 200 what the? SELECT 199.96 - (0.0 * FLOOR(1.0 * CAST(199.96 AS DECIMAL(19, 4)))) -- 199.96 SELECT 199.96 - (0.0 * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * 199.96)) -- 199.96 SELECT 199.96 - (CAST(0.0 AS DECIMAL(19, 4)) * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4)))) -- 199.96 SELECT 199.96 - (CAST(0.0 AS DECIMAL(19, 4)) * FLOOR(1.0 * CAST(199.96 AS DECIMAL(19, 4)))) -- 199.96 SELECT 199.96 - (CAST(0.0 AS DECIMAL(19, 4)) * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * 199.96)) -- 199.96 -- It gets weirder... SELECT (0 * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4)))) -- 0 SELECT (0 * FLOOR(1.0 * CAST(199.96 AS DECIMAL(19, 4)))) -- 0 SELECT (0 * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * 199.96)) -- 0 -- so... ... 199.06 - 0 equals 200... ... right??? SELECT 199.96 - 0 -- 199.96 ...NO....
PS.SharePrice - (CAST((@InstallmentCount - 1) AS DECIMAL(19, 4)) * CAST(FLOOR(@InstallmentPercent * PS.SharePrice) AS DECIMAL(19, 4)))) PS.SharePrice DECIMAL(19, 4) @InstallmentCount INT @InstallmentPercent DECIMAL(19, 4)
DECLARE @InstallmentIndex INT = 1 DECLARE @InstallmentCount INT = 1 DECLARE @InstallmentPercent DECIMAL(19, 4) = 1.0 DECLARE @PS TABLE (SharePrice DECIMAL(19, 4)) INSERT INTO @PS (SharePrice) VALUES (599.96) -- 2000 SELECT IIF(@InstallmentIndex < @InstallmentCount, FLOOR(@InstallmentPercent * PS.SharePrice), 1999.96) FROM @PS PS -- 2000 SELECT IIF(@InstallmentIndex < @InstallmentCount, FLOOR(@InstallmentPercent * CAST(599.96 AS DECIMAL(19, 4))), 1999.96) FROM @PS PS -- 1996.96 SELECT IIF(@InstallmentIndex < @InstallmentCount, FLOOR(@InstallmentPercent * 599.96), 1999.96) FROM @PS PS -- Funny enough - with this sample explicitly converting EVERYTHING to DECIMAL(19, 4) - it still doesn -- 2000 SELECT IIF(@InstallmentIndex < @InstallmentCount, FLOOR(@InstallmentPercent * CAST(199.96 AS DECIMAL(19, 4))), CAST(1999.96 AS DECIMAL(19, 4))) FROM @PS PS
-- 2000 SELECT IIF(1 = 2, FLOOR(CAST(1.0 AS decimal(19, 4)) * CAST(199.96 AS DECIMAL(19, 4))), CAST(1999.96 AS DECIMAL(19, 4))) -- 1999.9600 SELECT IIF(1 = 2, CAST(FLOOR(CAST(1.0 AS decimal(19, 4)) * CAST(199.96 AS DECIMAL(19, 4))) AS INT), CAST(1999.96 AS DECIMAL(19, 4)))
-- 1.96 SELECT IIF(1 = 2, CAST(1.0 AS DECIMAL (36, 0)), CAST(1.96 AS DECIMAL(19, 4)) ) -- 2.0 SELECT IIF(1 = 2, CAST(1.0 AS DECIMAL (37, 0)), CAST(1.96 AS DECIMAL(19, 4)) ) -- 2 SELECT IIF(1 = 2, CAST(1.0 AS DECIMAL (38, 0)), CAST(1.96 AS DECIMAL(19, 4)) )
SELECT 199.96 - ( 0.0 * FLOOR( CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4)) ) )
SELECT SQL_VARIANT_PROPERTY (199.96 , SQL_VARIANT_PROPERTY (199.96 , SQL_VARIANT_PROPERTY (199.96 , SELECT SQL_VARIANT_PROPERTY (0.0 * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4))) , SQL_VARIANT_PROPERTY (0.0 * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4))) , SQL_VARIANT_PROPERTY (0.0 * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4))) ,
SELECT 199.96 - ( 0.0 * FLOOR( CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4)) ) )
SELECT CAST( 199.96 - ( 0.0 * FLOOR(1.0 * 199.96) ) AS decimial(19,4))
SELECT 199.96 - (0.0 * FLOOR(CAST(1.0 AS DECIMAL(19, 4)) * CAST(199.96 AS DECIMAL(19, 4))))
Operation | Result precision | Result scale* e1 * e2 | p1 + p2 + 1 | s1 + s2 e1 - e2 | max(s1, s2) + max(p1-s1, p2-s2) + 1 | max(s1, s2)
CREATE FUNCTION [dbo].[CountTables] ( @name sysname ) RETURNS INT AS BEGIN RETURN ( SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @name ); END
SQL71502: Procedure: [Schema].[StoredProc1] has an unresolved reference to object [Schema].[Table1].[Property1].
<TreatTSqlWarningsAsErrors>false</TreatTSqlWarningsAsErrors>
declare @test varchar(100) set @test = while charindex( begin set @test = replace(@test, end select @test
CREATE FUNCTION strip_spaces(@str varchar(8000)) RETURNS varchar(8000) AS BEGIN WHILE CHARINDEX( SET @str = REPLACE(@str, RETURN @str END
CREATE FUNCTION stripDoubleSpaces(@prmSource varchar(max)) Returns varchar(max) AS BEGIN WHILE (PATINDEX( BEGIN SET @prmSource = replace(@prmSource , END RETURN @prmSource END GO -- Unit test -- PRINT dbo.stripDoubleSpaces( single spaces only
update mytable set myfield = replace (myfield, where charindex(
CREATE FUNCTION dbo.RemSpaceFromStr(@str VARCHAR(MAX)) RETURNS VARCHAR(MAX) AS BEGIN RETURN (CASE WHEN CHARINDEX( dbo.RemSpaceFromStr(REPLACE(@str, END
SELECT REPLACE(REPLACE(REPLACE( , --but it remove CHAR(7) (Bell) from string if exists...
SELECT REPLACE(REPLACE(REPLACE( , --but it remove CHAR(7) + CHAR(7) from string
CREATE FUNCTION [dbo].[fnReplaceMultipleSpaces] (@StrVal AS VARCHAR(4000)) RETURNS VARCHAR(4000) AS BEGIN SET @StrVal = Ltrim(@StrVal) SET @StrVal = Rtrim(@StrVal) SET @StrVal = REPLACE(@StrVal, SET @StrVal = REPLACE(@StrVal, SET @StrVal = REPLACE(@StrVal, SET @StrVal = REPLACE(@StrVal, SET @StrVal = REPLACE(@StrVal, RETURN @StrVal END
SELECT REPLACE( REPLACE( REPLACE( LTRIM(RTRIM( , ,CHAR(7)+ ,CHAR(7), where charindex(
declare @value varchar(max) declare @result varchar(max) set @value = set @result = replace(replace(replace(replace(replace(replace(replace( @value, select @result --
DECLARE @testString AS VARCHAR(256) = SELECT REPLACE(REPLACE(REPLACE(@testString,
DECLARE @testString AS VARCHAR(256) = SELECT REPLACE(REPLACE(REPLACE(REPLACE(@testString,
DECLARE @testString AS VARCHAR(256) = WHILE CHARINDEX( SET @testString = REPLACE(@testString, SELECT @testString
update mytable set myfield = replace(myfield, where myfield like
set ANSI_NULLS ON set QUOTED_IDENTIFIER ON SET IDENTITY_INSERT tbl_content ON GO ALTER procedure [dbo].[spInsertDeletedIntoTBLContent] @ContentID int, ...insert command... SET IDENTITY_INSERT tbl_content OFF
ALTER procedure [dbo].[spInsertDeletedIntoTBLContent] @ContentID int, SET IDENTITY_INSERT tbl_content ON ...insert command... SET IDENTITY_INSERT tbl_content OFF GO
set ANSI_NULLS ON set QUOTED_IDENTIFIER ON SET IDENTITY_INSERT tbl_content ON GO ALTER procedure [dbo].[spInsertDeletedIntoTBLContent] @ContentID int, SET IDENTITY_INSERT tbl_content ON ...insert command... SET IDENTITY_INSERT tbl_content OFF
SET IDENTITY_INSERT tbl_content ON ...insert command... SET IDENTITY_INSERT tbl_content OFF GO
SET IDENTITY_INSERT TableA ON SET IDENTITY_INSERT TableB ON ... INSERT ON TableA ... ... INSERT ON TableB ... SET IDENTITY_INSERT TableA OFF SET IDENTITY_INSERT TableB OFF
SET IDENTITY_INSERT TableA ON ... INSERT ON TableA ... SET IDENTITY_INSERT TableA OFF SET IDENTITY_INSERT TableB ON ... INSERT ON TableB ... SET IDENTITY_INSERT TableB OFF
SET IDENTITY_INSERT Genre ON INSERT INTO Genre(Id, Name, SortOrder)VALUES (12,
SET IDENTITY_INSERT Genre ON INSERT INTO Genre(Id, Name, SortOrder)VALUES (12, SET IDENTITY_INSERT Genre OFF
if @somethingBadHappened begin; raiserror( return; end;
-- first lets build a temporary table to hold errors if (object_id( create table -- this will determine if the transaction level of the query to programatically determine if we need to begin a new transaction or create a save point to rollback to declare @tc as int; set @tc = @@trancount; if (@tc = 0) begin transaction; else save transaction myTransaction; -- the code in the try block will be executed begin try declare @return_value = set @return_value = declare @ErrorNumber as int, @ErrorMessage as varchar(400), @ErrorSeverity as int, @ErrorState as int, @ErrorLine as int, @ErrorProcedure as varchar(128); -- assume that this procedure fails... exec @return_value = [dbo].[AssumeThisFails] if (@return_value <> 0) raiserror( -- the error severity of 17 will be considered a system error execution of this query will skip the following statements and resume at the begin catch block if (@tc = 0) commit transaction; return(0); end try -- the code in the catch block will be executed on raiserror("message", 17, 1) begin catch select @ErrorNumber = ERROR_NUMBER(), @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE(), @ErrorProcedure = ERROR_PROCEDURE(); insert values (@ErrorNumber, @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine, @ErrorProcedure); -- if i started the transaction if (@tc = 0) begin if (XACT_STATE() <> 0) begin select * from rollback transaction; insert into [dbo].[Errors] (ErrorNumber, ErrorMessage, ErrorSeverity, ErrorState, ErrorLine, ErrorProcedure) select * from insert [dbo].[Errors] (ErrorNumber, ErrorMessage, ErrorSeverity, ErrorState, ErrorLine, ErrorProcedure) values (@ErrorNumber, @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine, @ErrorProcedure); return(1); end end -- if i didn if (XACT_STATE() = 1) begin rollback transaction myTransaction; if (object_id( insert values (@ErrorNumber, @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine, @ErrorProcedure); else raiserror(@ErrorMessage, @ErrorSeverity, @ErrorState); return(2); end else if (XACT_STATE() = -1) begin rollback transaction; if (object_id( insert values (@ErrorNumber, @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine, @ErrorProcedure); else raiserror(@ErrorMessage, @ErrorSeverity, @ErrorState); return(3); end end catch end
create table T ( Val1 varchar(max) not null ) go declare @KMsg varchar(max) = REPLICATE( declare @MMsg varchar(max) = REPLICATE(@KMsg,1024); declare @GMsg varchar(max) = REPLICATE(@MMsg,1024); declare @GGMMsg varchar(max) = @GMsg + @GMsg + @MMsg; select LEN(@GGMMsg) insert into T(Val1) select @GGMMsg select LEN(Val1) from T
(no column name) 2148532224 (1 row(s) affected) Msg 7119, Level 16, State 1, Line 6 Attempting to grow LOB beyond maximum allowed size of 2147483647 bytes. The statement has been terminated. (no column name) (0 row(s) affected)
DECLARE @y VARCHAR(MAX) = REPLICATE(CAST( SET @y = REPLICATE(@y,92681); SELECT LEN(@y)
select internal_objects_alloc_page_count from sys.dm_db_task_space_usage WHERE session_id = @@spid
internal_objects_alloc_page_co ------------------------------ 2144456
DECLARE @y1 VARCHAR(MAX) = REPLICATE(CAST( SET @y1 = @y1 + @y1; SELECT LEN(@y1), DATALENGTH(@y1) DECLARE @y2 NVARCHAR(MAX) = REPLICATE(CAST( SET @y2 = @y2 + @y2; SELECT LEN(@y2), DATALENGTH(@y2) DECLARE @y3 NVARCHAR(MAX) = @y2 + @y1 SELECT LEN(@y3), DATALENGTH(@y3) SELECT @y1 y1, @y2 y2, @y3 y3 INTO Test
declare @KMsg varchar(max); set @KMsg = REPLICATE( declare @MMsg varchar(max); set @MMsg = REPLICATE(@KMsg,1024); declare @GMsg varchar(max); set @GMsg = REPLICATE(@MMsg,1024); declare @GGMMsg varchar(max); set @GGMMsg = @GMsg + @GMsg + @MMsg; select LEN(@GGMMsg)
SELECT Col.Column_Name from INFORMATION_SCHEMA.TABLE_CONSTRAINTS Tab, INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE Col WHERE Col.Constraint_Name = Tab.Constraint_Name AND Col.Table_Name = Tab.Table_Name AND Constraint_Type = AND Col.Table_Name =
SELECT c.name AS column_name, i.name AS index_name, c.is_identity FROM sys.indexes i inner join sys.index_columns ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id inner join sys.columns c ON ic.object_id = c.object_id AND c.column_id = ic.column_id WHERE i.is_primary_key = 1 and i.object_ID = OBJECT_ID(
select s.name as SchemaName, t.name as TableName, tc.name as ColumnName, ic.key_ordinal as KeyOrderNr from sys.schemas s inner join sys.tables t on s.schema_id=t.schema_id inner join sys.indexes i on t.object_id=i.object_id inner join sys.index_columns ic on i.object_id=ic.object_id and i.index_id=ic.index_id inner join sys.columns tc on ic.object_id=tc.object_id and ic.column_id=tc.column_id where i.is_primary_key=1 order by t.name, ic.key_ordinal ;
SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE OBJECTPROPERTY(OBJECT_ID(CONSTRAINT_SCHEMA+ AND TABLE_NAME =
--List all tables primary keys select * from information_schema.table_constraints where constraint_type =
SELECT TC.TABLE_NAME as [Table_name], TC.CONSTRAINT_NAME as [Primary_Key] FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC INNER JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE CCU ON TC.CONSTRAINT_NAME = CCU.CONSTRAINT_NAME WHERE TC.CONSTRAINT_TYPE = TC.TABLE_NAME IN (SELECT [NAME] AS [TABLE_NAME] FROM SYS.OBJECTS WHERE TYPE =
WITH ALL_KEYS_IN_TABLE (CONSTRAINT_NAME,CONSTRAINT_TYPE,PARENT_TABLE_NAME,PARENT_COL_NAME,PARENT_COL_NAME_DATA_TYPE,REFERENCE_TABLE_NAME,REFERENCE_COL_NAME) AS ( SELECT CONSTRAINT_NAME= CAST (PKnUKEY.name AS VARCHAR(30)) , CONSTRAINT_TYPE=CAST (PKnUKEY.type_desc AS VARCHAR(30)) , PARENT_TABLE_NAME=CAST (PKnUTable.name AS VARCHAR(30)) , PARENT_COL_NAME=CAST ( PKnUKEYCol.name AS VARCHAR(30)) , PARENT_COL_NAME_DATA_TYPE= oParentColDtl.DATA_TYPE, REFERENCE_TABLE_NAME= REFERENCE_COL_NAME= FROM sys.key_constraints as PKnUKEY INNER JOIN sys.tables as PKnUTable ON PKnUTable.object_id = PKnUKEY.parent_object_id INNER JOIN sys.index_columns as PKnUColIdx ON PKnUColIdx.object_id = PKnUTable.object_id AND PKnUColIdx.index_id = PKnUKEY.unique_index_id INNER JOIN sys.columns as PKnUKEYCol ON PKnUKEYCol.object_id = PKnUTable.object_id AND PKnUKEYCol.column_id = PKnUColIdx.column_id INNER JOIN INFORMATION_SCHEMA.COLUMNS oParentColDtl ON oParentColDtl.TABLE_NAME=PKnUTable.name AND oParentColDtl.COLUMN_NAME=PKnUKEYCol.name UNION ALL SELECT CONSTRAINT_NAME= CAST (oConstraint.name AS VARCHAR(30)) , CONSTRAINT_TYPE= PARENT_TABLE_NAME=CAST (oParent.name AS VARCHAR(30)) , PARENT_COL_NAME=CAST ( oParentCol.name AS VARCHAR(30)) , PARENT_COL_NAME_DATA_TYPE= oParentColDtl.DATA_TYPE, REFERENCE_TABLE_NAME=CAST ( oReference.name AS VARCHAR(30)) , REFERENCE_COL_NAME=CAST (oReferenceCol.name AS VARCHAR(30)) FROM sys.foreign_key_columns FKC INNER JOIN sys.sysobjects oConstraint ON FKC.constraint_object_id=oConstraint.id INNER JOIN sys.sysobjects oParent ON FKC.parent_object_id=oParent.id INNER JOIN sys.all_columns oParentCol ON FKC.parent_object_id=oParentCol.object_id AND FKC.parent_column_id=oParentCol.column_id INNER JOIN sys.sysobjects oReference ON FKC.referenced_object_id=oReference.id INNER JOIN INFORMATION_SCHEMA.COLUMNS oParentColDtl ON oParentColDtl.TABLE_NAME=oParent.name AND oParentColDtl.COLUMN_NAME=oParentCol.name INNER JOIN sys.all_columns oReferenceCol ON FKC.referenced_object_id=oReferenceCol.object_id AND FKC.referenced_column_id=oReferenceCol.column_id ) select * from ALL_KEYS_IN_TABLE where PARENT_TABLE_NAME in ( or REFERENCE_TABLE_NAME in ( ORDER BY PARENT_TABLE_NAME,CONSTRAINT_NAME;
SELECT A.Name,Col.Column_Name from INFORMATION_SCHEMA.TABLE_CONSTRAINTS Tab, INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE Col , (select NAME from dbo.sysobjects where xtype= WHERE Col.Constraint_Name = Tab.Constraint_Name AND Col.Table_Name = Tab.Table_Name AND Constraint_Type = AND Col.Table_Name = A.Name
SELECT A.TABLE_NAME as [Table_name], A.CONSTRAINT_NAME as [Primary_Key] FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS A, INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE B WHERE CONSTRAINT_TYPE =
SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME =
SELECT T.TABLE_SCHEMA, T.TABLE_NAME, STUFF(( SELECT FROM INFORMATION_SCHEMA.COLUMNS C WHERE C.TABLE_SCHEMA = T.TABLE_SCHEMA AND T.TABLE_NAME = C.TABLE_NAME FOR XML PATH ( ), 1, 2, STUFF(( SELECT FROM INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE C INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC ON C.TABLE_SCHEMA = TC.TABLE_SCHEMA AND C.TABLE_NAME = TC.TABLE_NAME WHERE C.TABLE_SCHEMA = T.TABLE_SCHEMA AND T.TABLE_NAME = C.TABLE_NAME AND TC.CONSTRAINT_TYPE = FOR XML PATH ( ), 1, 2, FROM INFORMATION_SCHEMA.TABLES T ORDER BY T.TABLE_SCHEMA, T.TABLE_NAME
SELECT DISTINCT CONSTRAINT_NAME AS [Constraint], TABLE_SCHEMA AS [Schema], TABLE_NAME AS TableName FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME =
SELECT t.name AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 1 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 2 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 3 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 4 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 5 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 6 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 7 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 8 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 9 AND k.id = t.id) AS (SELECT c.name FROM syscolumns c INNER JOIN sysindexkeys k ON k.indid = i.indid AND c.colid = k.colid AND c.id = t.id AND k.keyno = 10 AND k.id = t.id) AS FROM sysobjects t INNER JOIN sysindexes i ON i.id = t.id INNER JOIN sysobjects it ON it.parent_obj = t.id AND it.name = i.name WHERE it.xtype = ORDER BY t.name, i.name
SELECT CONSTRAINT_CATALOG AS DataBaseName, CONSTRAINT_SCHEMA AS SchemaName, TABLE_NAME AS TableName, CONSTRAINT_Name AS PrimaryKey FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE CONSTRAINT_TYPE =
DECLARE @TableName VARCHAR(100) = WITH Sysinfo AS (SELECT Kcu.Table_Name , Kcu.Table_Schema AS Schema_Name , Kcu.Column_Name , Kcu.Ordinal_Position FROM [LinkServer].Information_Schema.Key_Column_Usage Kcu JOIN [LinkServer].Information_Schema.Table_Constraints AS Tc ON Tc.Constraint_Name = Kcu.Constraint_Name WHERE Tc.Constraint_Type = SELECT Schema_Name ,Table_Name , STUFF( ( SELECT , REPLACE(Si1.Column_Name, FROM Sysinfo Si1 WHERE Si1.Table_Name = Si2.Table_Name ORDER BY Si1.Table_Name , Si1.Ordinal_Position FOR XML PATH( ), 1, 2, FROM Sysinfo Si2 WHERE Table_Name = CASE WHEN @TableName NOT IN( THEN @TableName ELSE Table_Name END GROUP BY Si2.Table_Name, Si2.Schema_Name;
DECLARE @TableName VARCHAR(100) = WITH Sysinfo AS (SELECT S.Name AS Schema_Name , T.Name AS Table_Name , Tc.Name AS Column_Name , Ic.Key_Ordinal AS Ordinal_Position FROM [LinkServer].Sys.Schemas S JOIN [LinkServer].Sys.Tables T ON S.Schema_Id = T.Schema_Id JOIN [LinkServer].Sys.Indexes I ON T.Object_Id = I.Object_Id JOIN [LinkServer].Sys.Index_Columns Ic ON I.Object_Id = Ic.Object_Id AND I.Index_Id = Ic.Index_Id JOIN [LinkServer].Sys.Columns Tc ON Ic.Object_Id = Tc.Object_Id AND Ic.Column_Id = Tc.Column_Id WHERE I.Is_Primary_Key = 1) SELECT Schema_Name ,Table_Name , STUFF( ( SELECT , REPLACE(Si1.Column_Name, FROM Sysinfo Si1 WHERE Si1.Table_Name = Si2.Table_Name ORDER BY Si1.Table_Name , Si1.Ordinal_Position FOR XML PATH( ), 1, 2, FROM Sysinfo Si2 WHERE Table_Name = CASE WHEN @TableName NOT IN( THEN @TableName ELSE Table_Name END GROUP BY Si2.Table_Name, Si2.Schema_Name;
declare @TableName nvarchar(50)= declare @TypeOfKey nvarchar(50)= SELECT Name FROM sys.objects WHERE type = @TypeOfKey AND parent_object_id = OBJECT_ID (@TableName)
SELECT KEYS.table_schema, KEYS.table_name, KEYS.column_name, KEYS.ORDINAL_POSITION FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE keys INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS CONS ON cons.TABLE_SCHEMA = keys.TABLE_SCHEMA AND cons.TABLE_NAME = keys.TABLE_NAME AND cons.CONSTRAINT_NAME = keys.CONSTRAINT_NAME WHERE cons.CONSTRAINT_TYPE =
SELECT schema_name(t.schema_id) AS [schema_name], t.name AS TableName, COL_NAME(ic.OBJECT_ID,ic.column_id) AS PrimaryKeyColumnName, i.name AS PrimaryKeyConstraintName FROM sys.tables t INNER JOIN sys.indexes AS i on t.object_id=i.object_id INNER JOIN sys.index_columns AS ic ON i.OBJECT_ID = ic.OBJECT_ID AND i.index_id = ic.index_id WHERE OBJECT_NAME(ic.OBJECT_ID) =
SELECT f.name as ForeignKeyConstraintName ,OBJECT_NAME(f.parent_object_id) AS ReferencingTableName ,COL_NAME(fc.parent_object_id, fc.parent_column_id) AS ReferencingColumnName ,OBJECT_NAME (f.referenced_object_id) AS ReferencedTableName ,COL_NAME(fc.referenced_object_id, fc.referenced_column_id) AS ReferencedColumnName ,delete_referential_action_desc AS DeleteReferentialActionDesc ,update_referential_action_desc AS UpdateReferentialActionDesc FROM sys.foreign_keys AS f INNER JOIN sys.foreign_key_columns AS fc ON f.object_id = fc.constraint_object_id --WHERE OBJECT_NAME(f.parent_object_id) = --If you want to know referecing table details WHERE OBJECT_NAME(f.referenced_object_id) = --If you want to know refereced table details ORDER BY f.name
SELECT tc.constraint_name AS IndexName,tc.table_name AS TableName,tc.table_schema AS SchemaName,kc.column_name AS COLUMN_NAME FROM information_schema.table_constraints tc,information_schema.key_column_usage kc WHERE tc.constraint_type = AND kc.constraint_name = tc.constraint_name AND tc.table_schema=
declare @table varchar(100) = with cte as ( select tc.CONSTRAINT_SCHEMA , tc.CONSTRAINT_TYPE , tc.TABLE_NAME , ccu.COLUMN_NAME , IS_NULLABLE , DATA_TYPE , CHARACTER_MAXIMUM_LENGTH , NUMERIC_PRECISION from INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc inner join INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu on tc.TABLE_NAME=ccu.TABLE_NAME and tc.TABLE_SCHEMA=ccu.TABLE_SCHEMA inner join information_schema.COLUMNS c on ccu.COLUMN_NAME=c.COLUMN_NAME and ccu.TABLE_NAME=c.TABLE_NAME and ccu.TABLE_SCHEMA=c.TABLE_SCHEMA where tc.table_name=@table and ccu.CONSTRAINT_NAME=tc.CONSTRAINT_NAME union select TABLE_SCHEMA, and COLUMN_NAME not in (select COLUMN_NAME from INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE where TABLE_NAME = @table) ) select cast(iif(CONSTRAINT_TYPE= ,cast(iif(CONSTRAINT_TYPE= ,cast(iif(CONSTRAINT_TYPE= ,COLUMN_NAME ,cast(iif(is_nullable= , DATA_TYPE , CHARACTER_MAXIMUM_LENGTH , NUMERIC_PRECISION from cte order by case CONSTRAINT_TYPE when when else 3 end , COLUMN_NAME
SELECT L.TABLE_SCHEMA, L.TABLE_NAME, L.COLUMN_NAME, R.TypeName FROM( SELECT COLUMN_NAME, TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE OBJECTPROPERTY(OBJECT_ID(CONSTRAINT_SCHEMA + )L LEFT JOIN ( SELECT OBJECT_NAME(c.OBJECT_ID) TableName ,c.name AS ColumnName ,t.name AS TypeName FROM sys.columns AS c JOIN sys.types AS t ON c.user_type_id=t.user_type_id )R ON L.COLUMN_NAME = R.ColumnName AND L.TABLE_NAME = R.TableName
SELECT * FROM TableA a INNER JOIN TableXRef x ON a.ID = x.TableAID INNER JOIN TableB b ON x.TableBID = b.ID WHERE a.ID = 1
SELECT * FROM TableA a INNER JOIN TableXRef x ON a.ID = x.TableAID AND a.ID = 1 INNER JOIN TableB b ON x.TableBID = b.ID
SET NOCOUNT ON; DECLARE @num INT, @iter INT SELECT @num = 1000, -- Number of records in TableA and TableB, the cross table is populated with a CROSS JOIN from A to B @iter = 1000 -- Number of select iterations to perform DECLARE @a TABLE ( id INT ) DECLARE @b TABLE ( id INT ) DECLARE @x TABLE ( aid INT, bid INT ) DECLARE @num_curr INT SELECT @num_curr = 1 WHILE (@num_curr <= @num) BEGIN INSERT @a (id) SELECT @num_curr INSERT @b (id) SELECT @num_curr SELECT @num_curr = @num_curr + 1 END INSERT @x (aid, bid) SELECT a.id, b.id FROM @a a CROSS JOIN @b b DECLARE @begin_where DATETIME, @end_where DATETIME, @count_where INT, @begin_join DATETIME, @end_join DATETIME, @count_join INT, @curr INT, @aid INT DECLARE @temp TABLE ( curr INT, aid INT, bid INT ) DELETE FROM @temp SELECT @curr = 0, @aid = 50 SELECT @begin_where = CURRENT_TIMESTAMP WHILE (@curr < @iter) BEGIN INSERT @temp (curr, aid, bid) SELECT @curr, aid, bid FROM @a a INNER JOIN @x x ON a.id = x.aid INNER JOIN @b b ON x.bid = b.id WHERE a.id = @aid SELECT @curr = @curr + 1 END SELECT @end_where = CURRENT_TIMESTAMP SELECT @count_where = COUNT(1) FROM @temp DELETE FROM @temp SELECT @curr = 0 SELECT @begin_join = CURRENT_TIMESTAMP WHILE (@curr < @iter) BEGIN INSERT @temp (curr, aid, bid) SELECT @curr, aid, bid FROM @a a INNER JOIN @x x ON a.id = x.aid AND a.id = @aid INNER JOIN @b b ON x.bid = b.id SELECT @curr = @curr + 1 END SELECT @end_join = CURRENT_TIMESTAMP SELECT @count_join = COUNT(1) FROM @temp DELETE FROM @temp SELECT @count_where AS count_where, @count_join AS count_join, DATEDIFF(millisecond, @begin_where, @end_where) AS elapsed_where, DATEDIFF(millisecond, @begin_join, @end_join) AS elapsed_join
SELECT * FROM TableA a LEFT JOIN TableXRef x ON x.TableAID = a.ID AND a.ID = 1 LEFT JOIN TableB b ON x.TableBID = b.ID
SELECT * FROM TableA a LEFT JOIN TableXRef x ON x.TableAID = a.ID LEFT JOIN TableB b ON b.id = x.TableBID WHERE a.id = 1
IF EXISTS (SELECT * FROM TABLE WHERE Columns=@Filters) BEGIN UPDATE TABLE SET ColumnsX=ValuesX WHERE Where Columns=@Filters END
IF EXISTS (SELECT 1 FROM TABLE WHERE Columns=@Filters) BEGIN UPDATE TABLE SET ColumnsX=ValuesX WHERE Columns=@Filters END
SELECT whatever FROM yourtable WHERE EXISTS( SELECT 1/0 FROM someothertable WHERE a_valid_clause )
CREATE TABLE T ( X INT PRIMARY KEY, Y INT, Z CHAR(8000) ) CREATE NONCLUSTERED INDEX NarrowIndex ON T(Y) IF EXISTS (SELECT * FROM T) PRINT
+-------------+----------+---------+---------+--------------+ | Num of Cols | * | 1 | PK | Not Null col | +-------------+----------+---------+---------+--------------+ | 2 | 2043.5 | 2043.25 | 2073.5 | 2067.5 | | 4 | 2038.75 | 2041.25 | 2067.5 | 2067.5 | | 8 | 2015.75 | 2017 | 2059.75 | 2059 | | 16 | 2005.75 | 2005.25 | 2025.25 | 2035.75 | | 32 | 1963.25 | 1967.25 | 2001.25 | 1992.75 | | 64 | 1903 | 1904 | 1936.25 | 1939.75 | | 128 | 1778.75 | 1779.75 | 1799 | 1806.75 | | 256 | 1530.75 | 1526.5 | 1542.75 | 1541.25 | | 512 | 1195 | 1189.75 | 1203.75 | 1198.5 | | 1024 | 694.75 | 697 | 699 | 699.25 | +-------------+----------+---------+---------+--------------+ | Total | 17169.25 | 17171 | 17408 | 17408 | +-------------+----------+---------+---------+--------------+
SET SHOWPLAN_TEXT ON; GO SELECT COUNT(1) FROM master..spt_values
|--Compute Scalar(DEFINE:([Expr1003]=CONVERT_IMPLICIT(int,[Expr1004],0))) |--Stream Aggregate(DEFINE:([Expr1004]=Count(*))) |--Index Scan(OBJECT:([master].[dbo].[spt_values].[ix2_spt_values_nu_nc]))
DECLARE @V int WHILE (1=1) SELECT @V=1 WHERE EXISTS (SELECT 1 FROM
sqlservr.exe!CMEDAccess::GetProxyBaseIntnl() - 0x1e2c79 bytes sqlservr.exe!CMEDProxyRelation::GetColumn() + 0x57 bytes sqlservr.exe!CAlgTableMetadata::LoadColumns() + 0x256 bytes sqlservr.exe!CAlgTableMetadata::Bind() + 0x15c bytes sqlservr.exe!CRelOp_Get::BindTree() + 0x98 bytes sqlservr.exe!COptExpr::BindTree() + 0x58 bytes sqlservr.exe!CRelOp_FromList::BindTree() + 0x5c bytes sqlservr.exe!COptExpr::BindTree() + 0x58 bytes sqlservr.exe!CRelOp_QuerySpec::BindTree() + 0xbe bytes sqlservr.exe!COptExpr::BindTree() + 0x58 bytes sqlservr.exe!CScaOp_Exists::BindScalarTree() + 0x72 bytes ... Lines omitted ... msvcr80.dll!_threadstartex(void * ptd=0x0031d888) Line 326 + 0x5 bytes C kernel32.dll!_BaseThreadStart@8() + 0x37 bytes
CREATE USER blat WITHOUT LOGIN; GO CREATE TABLE dbo.T ( X INT PRIMARY KEY, Y INT, Z CHAR(8000) ) GO GRANT SELECT ON dbo.T TO blat; DENY SELECT ON dbo.T(Z) TO blat; GO EXECUTE AS USER = GO SELECT 1 WHERE EXISTS (SELECT 1 FROM T); GO REVERT; DROP USER blat DROP TABLE T
+-------------+-----------+------------+-----------+--------------+ | Num of Cols | * | 1 | PK | Not Null col | +-------------+-----------+------------+-----------+--------------+ | 2 | 144933.25 | 145292 | 146029.25 | 143973.5 | | 4 | 146084 | 146633.5 | 146018.75 | 146581.25 | | 8 | 143145.25 | 144393.25 | 145723.5 | 144790.25 | | 16 | 145191.75 | 145174 | 144755.5 | 146666.75 | | 32 | 144624 | 145483.75 | 143531 | 145366.25 | | 64 | 145459.25 | 146175.75 | 147174.25 | 146622.5 | | 128 | 145625.75 | 143823.25 | 144132 | 144739.25 | | 256 | 145380.75 | 147224 | 146203.25 | 147078.75 | | 512 | 146045 | 145609.25 | 145149.25 | 144335.5 | | 1024 | 148280 | 148076 | 145593.25 | 146534.75 | +-------------+-----------+------------+-----------+--------------+ | Total | 1454769 | 1457884.75 | 1454310 | 1456688.75 | +-------------+-----------+------------+-----------+--------------+
IF EXISTS (SELECT * FROM my_table WHERE id = @id) BEGIN INSERT INTO Log SELECT @id, DELETE my_table WHERE id = @id END
Msg 111, Level 15, State 1, Line 3 Msg 178, Level 15, State 1, Line 4 A RETURN statement with a return value cannot be used in this context.
Msg 178, Level 15, State 1, Procedure A RETURN statement with a return value cannot be used in this context.
begin transaction go ... test code here ... go rollback transaction
declare @i int set @i = 0 go print @i Msg 137, Level 15, State 2, Line 1 Must declare the scalar variable "@i".
alter table foo add bar varchar(8); -- if you don update foo set bar = -- need a GO here to tell the interpreter to execute this statement, otherwise the Parser will lump it together with all successive statements.
SELECT @NumRowsChanged = @@ROWCOUNT, @ErrorCode = @@ERROR
SELECT @NumRowsChanged = @NumRowsChanged + @@ROWCOUNT, @ErrorCode = @@ERROR
DECLARE @add_a_b_func nvarchar(4000) = N DECLARE @add_a_b_parm nvarchar(500) = N DECLARE @result int; EXEC sp_executesql @add_a_b_func, @add_a_b_parm, 2, 3, @c = @result OUTPUT; PRINT CONVERT(varchar, @result); -- prints
create proc DoStuff as begin declare @sql nvarchar(max) set @sql = ' create function dbo._object_name_twopart (@object_id int) returns nvarchar(517) as begin return quotename(object_schema_name(@object_id))+N quotename(object_name(@object_id)) end ' if object_id( exec (@sql) select object_id, dbo._object_name_twopart(object_id) from sys.objects where type = drop function _object_name_twopart end go
IF OBJECT_ID( GO CREATE PROCEDURE BEGIN SELECT Division = CASE WHEN @Denominator != 0 AND @Denominator is NOT NULL AND @Numerator != 0 AND @Numerator is NOT NULL THEN @Numerator / @Denominator ELSE 0 END RETURN END GO Exec
UPDATE table1 SET field1 = SUM(table2.field2) FROM table1 INNER JOIN table2 ON table1.field3 = table2.field3 GROUP BY table1.field3
UPDATE t1 SET t1.field1 = t2.field2Sum FROM table1 t1 INNER JOIN (select field3, sum(field2) as field2Sum from table2 group by field3) as t2 on t2.field3 = t1.field3
UPDATE table1 SET field1 = (SELECT SUM(t2.field2) FROM TABLE2 t2 WHERE t2.field3 = field2)
UPDATE table1 SET field1 = (SELECT SUM(field2) FROM table2 AS t2 WHERE t2.field3 = t1.field3) FROM table1 AS t1
UPDATE t1 SET t1.field1 = t2.field2Sum FROM table1 t1 CROSS APPLY (SELECT SUM(field2) as field2Sum FROM table2 t2 WHERE t2.field3 = t1.field3) AS t2
UPDATE t1 SET t1.field1 = t2.field2Sum FROM table1 t1 INNER JOIN (...) as t2 on t2.field3 = t1.field3
UPDATE table1 t1 SET t1.field1 = t2.field2Sum FROM (...) as t2 WHERE t2.field3 = t1.field3
select "start_of_week" = dateadd(week, datediff(week, 0, getdate()), 0);
select "start_of_week" = dateadd(week, datediff(week, 0, getdate()), -1);
DECLARE @dt DATE = SELECT [start_of_week] = DATEADD(WEEK, DATEDIFF(WEEK, @dt, CURRENT_TIMESTAMP), @dt);
SELECT DATEADD(DAY, 1-DATEPART(WEEKDAY, CURRENT_TIMESTAMP), CURRENT_TIMESTAMP);
CREATE FUNCTION dbo.StartOfWeek1 -- always a Sunday ( @d DATE ) RETURNS DATE AS BEGIN RETURN (SELECT DATEADD(WEEK, DATEDIFF(WEEK, END GO
CREATE FUNCTION dbo.StartOfWeek2 -- always the DATEFIRST weekday ( @d DATE ) RETURNS DATE AS BEGIN RETURN (SELECT DATEADD(DAY, 1-DATEPART(WEEKDAY, @d), @d)); END GO
Function - client processing time / wait time on server replies / total exec time Gandarez - 330/2029/2359 - 0:23.6 me datefirst - 329/2123/2452 - 0:24.5 me Sunday - 357/2158/2515 - 0:25.2 trailmax - 364/2160/2524 - 0:25.2 Curt - 424/2202/2626 - 0:26.3
Function - client processing time / wait time on server replies / total exec time Curt - 1003/134158/135054 - 2:15 Gandarez - 957/142919/143876 - 2:24 me Sunday - 932/166817/165885 - 2:47 me datefirst - 939/171698/172637 - 2:53 trailmax - 958/173174/174132 - 2:54
SELECT 1 + ((5 + DATEPART(dw, GETDATE()) + @@DATEFIRST) % 7);
SELECT 1 + ((6 + DATEPART(dw, GETDATE()) + @@DATEFIRST) % 7);
create function dbo.F_START_OF_WEEK ( @DATE datetime, -- Sun = 1, Mon = 2, Tue = 3, Wed = 4 -- Thu = 5, Fri = 6, Sat = 7 -- Default to Sunday @WEEK_START_DAY int = 1 ) returns datetime as begin declare @START_OF_WEEK_DATE datetime declare @FIRST_BOW datetime -- Check for valid day of week if @WEEK_START_DAY between 1 and 7 begin -- Find first day on or after 1753/1/1 (-53690) -- matching day of week of @WEEK_START_DAY -- 1753/1/1 is earliest possible SQL Server date. select @FIRST_BOW = convert(datetime,-53690+((@WEEK_START_DAY+5)%7)) -- Verify beginning of week not before 1753/1/1 if @DATE >= @FIRST_BOW begin select @START_OF_WEEK_DATE = dateadd(dd,(datediff(dd,@FIRST_BOW,@DATE)/7)*7,@FIRST_BOW) end end return @START_OF_WEEK_DATE end go
select *, cast(DATEADD(day, -1*(DATEPART(WEEKDAY, YouDate)-1), YourDate) as DATE) as WeekStart From.....
select *, cast(DATEADD(day, -1*(DATEPART(WEEKDAY, YouDate)-2), YourDate) as DATE) as WeekStart From.....
SELECT DATEADD(DD, 1 - DATEPART(DW, GETDATE()), GETDATE())
DECLARE @MYDATE DATETIME SET @MYDATE = SELECT DATEADD(DD, 1 - DATEPART(DW, @MYDATE), @MYDATE)
CREATE FUNCTION [dbo].[GetFirstDayOfWeek] ( @pInputDate DATETIME ) RETURNS DATETIME BEGIN SET @pInputDate = CONVERT(VARCHAR(10), @pInputDate, 111) RETURN DATEADD(DD, 1 - DATEPART(DW, @pInputDate), @pInputDate) END GO
Set DateFirst 1; Select Datepart(wk, TimeByDay) [Week] ,Dateadd(d, CASE WHEN Datepart(dw, TimeByDay) = 1 then 0 WHEN Datepart(dw, TimeByDay) = 2 then -1 WHEN Datepart(dw, TimeByDay) = 3 then -2 WHEN Datepart(dw, TimeByDay) = 4 then -3 WHEN Datepart(dw, TimeByDay) = 5 then -4 WHEN Datepart(dw, TimeByDay) = 6 then -5 WHEN Datepart(dw, TimeByDay) = 7 then -6 END , TimeByDay) as StartOfWeek from TimeByDay_Tbl
/* TAKEN FROM http: First day of the week is 1 -- Monday 2 -- Tuesday 3 -- Wednesday 4 -- Thursday 5 -- Friday 6 -- Saturday 7 (default, U.S. English) -- Sunday */ --Offset is required to compensate for the fact that my @@DATEFIRST setting is 7, the default. DECLARE @offSet int, @testDate datetime SELECT @offSet = 1, @testDate = GETDATE() SELECT CONVERT(DATETIME, CONVERT(INT, @testDate) - (DATEPART(WEEKDAY, @testDate) - @offSet))
ALTER TABLE dbo.EMPLOYEE ADD COLUMN EMP_IS_ADMIN BIT NOT NULL GO -- Necessary, or next line will generate "Unknown column: EMP_IS_ADMIN" UPDATE dbo.EMPLOYEE SET EMP_IS_ADMIN = whatever
IF whatever BEGIN ALTER TABLE dbo.EMPLOYEE ADD COLUMN EMP_IS_ADMIN BIT NOT NULL GO UPDATE dbo.EMPLOYEE SET EMP_IS_ADMIN = whatever END
IF whatever BEGIN ALTER TABLE dbo.EMPLOYEE ADD COLUMN EMP_IS_ADMIN BIT NOT NULL; EXEC ( END
IF not whatever BEGIN SET NOEXEC ON; END ALTER TABLE dbo.EMPLOYEE ADD COLUMN EMP_IS_ADMIN BIT NOT NULL GO UPDATE dbo.EMPLOYEE SET EMP_IS_ADMIN = whatever SET NOEXEC OFF;
BEGIN TRAN DECLARE @statementNo INT BEGIN TRY IF 1=1 BEGIN SET @statementNo = 1 EXEC sp_executesql N ADD COLUMN EMP_IS_ADMIN BIT NOT NULL' SET @statementNo = 2 EXEC sp_executesql N SET EMP_IS_ADMIN = 1' SET @statementNo = 3 EXEC sp_executesql N SET EMP_IS_ADMIN = 1x' END END TRY BEGIN CATCH PRINT + + -- error occurred, so rollback the transaction ROLLBACK END CATCH -- if we were successful, we should still have a transaction, so commit it IF @@TRANCOUNT > 0 COMMIT
END GO ---Automatic replacement of GO keyword, need to recheck IF conditional: IF whatever BEGIN
IF COL_LENGTH( BEGIN BEGIN ALTER TABLE dbo.Employees ADD EMP_IS_ADMIN BIT END BEGIN UPDATE EMPLOYEES SET EMP_IS_ADMIN = 0 END END
declare @b varbinary(max) set @b = 0x5468697320697320612074657374 select cast(@b as varchar(max))
EmployeeName ------------ Anand Anand Anil Dipak Anil Dipak Dipak Anil
delete x from ( select *, rn=row_number() over (partition by EmployeeName order by empId) from Employee ) x where rn > 1;
select * from ( select *, rn=row_number() over (partition by EmployeeName order by empId) from Employee ) x where rn > 1;
delete from Employee where ID not in ( select min(ID) from Employee group by EmployeeName );
delete from GuidEmployees where CAST(ID AS binary(16)) not in ( select min(CAST(ID AS binary(16))) from GuidEmployees group by EmployeeName );
delete T1 from MyTable T1, MyTable T2 where T1.dupField = T2.dupField and T1.uniqueField > T2.uniqueField
DELETE FROM MyTable WHERE ID NOT IN ( SELECT MAX(ID) FROM MyTable GROUP BY DuplicateColumn1, DuplicateColumn2, DuplicateColumn3)
WITH TempUsers (FirstName, LastName, duplicateRecordCount) AS ( SELECT FirstName, LastName, ROW_NUMBER() OVER (PARTITIONBY FirstName, LastName ORDERBY FirstName) AS duplicateRecordCount FROM dbo.Users ) DELETE FROM TempUsers WHERE duplicateRecordCount > 1
WITH CTE AS ( SELECT EmployeeName, ROW_NUMBER() OVER(PARTITION BY EmployeeName ORDER BY EmployeeName) AS R FROM employee_table ) DELETE CTE WHERE R > 1;
DELETE FROM employee WHERE rowid NOT IN (SELECT MAX(rowid) FROM employee GROUP BY EmployeeName);
create table id int not null, name nvarchar(max) not null ) DECLARE @name VARCHAR(MAX); DECLARE @id INT; DECLARE @newid INT; DECLARE @oldid INT; DECLARE OLVTRCCursor CURSOR FOR SELECT id, name FROM Sales_OrderLineVersionChangeReasonCode; OPEN OLVTRCCursor; FETCH NEXT FROM OLVTRCCursor INTO @id, @name; WHILE @@FETCH_STATUS = 0 BEGIN -- determine if it should be replaced (is already in temptable with name) if(exists(select * from -- if it is, finds its id Select top 1 @newid = id from Sales_OrderLineVersionChangeReasonCode where Name = @name -- replace terminationreasoncodeid in olv for the new terminationreasoncodeid update Sales_OrderLineVersion set ChangeReasonCodeId = @newid where ChangeReasonCodeId = @id -- delete the record from the terminationreasoncode delete from Sales_OrderLineVersionChangeReasonCode where Id = @id end else begin -- insert into temp table if new insert into values(@id, @name) end FETCH NEXT FROM OLVTRCCursor INTO @id, @name; END; CLOSE OLVTRCCursor; DEALLOCATE OLVTRCCursor; drop table
if exists (select 1 from sys.all_objects where type= drop table _original declare @startyear int = 2017 declare @endyear int = 2018 declare @iterator int = 1 declare @income money = cast((SELECT round(RAND()*(5000-4990)+4990 , 2)) as money) declare @salesrepid int = cast(floor(rand()*(9100-9000)+9000) as varchar(4)) create table while @iterator<=50000 begin insert select (Select cast(floor(rand()*(@endyear-@startyear)+@startyear) as varchar(4))+ set @salesrepid = cast(floor(rand()*(9100-9000)+9000) as varchar(4)) set @income = cast((SELECT round(RAND()*(5000-4990)+4990 , 2)) as money) set @iterator=@iterator+1 end update set monthyear=replace(monthyear, select * into _original from
create type ColumnNames AS table (Columnnames varchar(max))
create proc delete_dupes (@tablename varchar(max), @columns columnnames readonly) as begin declare @table table (iterator int, name varchar(max), is_identity int) declare @tablepartition table (idx int identity, type varchar(max), value varchar(max)) declare @partitionby varchar(max) declare @iterator int= 1 if exists (select 1 from @columns) begin declare @columns1 table (iterator int, columnnames varchar(max)) insert @columns1 select 1, columnnames from @columns set @partitionby = (select distinct substring((Select From @columns1 t1 Where T1.iterator = T2.iterator ORDER BY T1.iterator For XML PATH ( From @columns1 T2 ) end insert @table select 1, a.name, is_identity from sys.all_columns a join sys.all_objects b on a.object_id=b.object_id where b.name = @tablename declare @identity varchar(max)= (select name from @table where is_identity=1) while @iterator>=0 begin insert @tablepartition Select distinct case when @iterator=1 then substring((Select From @table t1 Where T1.iterator = T2.iterator and is_identity=@iterator ORDER BY T1.iterator For XML PATH ( From @table T2 set @iterator=@iterator-1 end declare @originalpartition varchar(max) if @partitionby is null begin select @originalpartition = replace(b.value+ select @partitionby = a.type+a.value+ end else begin select @originalpartition=b.value + set @partitionby = (select from @tablepartition a cross join @tablepartition b where a.idx=2 and b.idx=1) end exec( exec( left join where b.rownum is null drop table end
declare @table1 as columnnames insert @table1 values ( exec delete_dupes
Declare @Employee table (EmployeeName varchar(10)) Insert into @Employee values ( ( Select * from @Employee
Delete aliasName from ( Select *, ROW_NUMBER() over (Partition by EmployeeName order by EmployeeName) as rowNumber From @Employee) aliasName Where rowNumber > 1 Select * from @Employee
select name from tempdb.sys.procedures where object_id = @@procid
create procedure as select object_name(@@PROCID) as name go exec name -------------------------------------------------------------------------------------------------------------------------------- NULL (1 row affected)
SELECT convert(varchar(25), getdate(), 121) – yyyy-mm-dd hh:mm:ss.mmm
DECLARE @DateTime DATETIME = GETDATE(); --Using Convert SELECT CONVERT(NVARCHAR, @DateTime,120) AS ,CONVERT(NVARCHAR(10), @DateTime, 120) AS ,RIGHT(CONVERT(NVARCHAR, @DateTime, 120),8) AS
SELECT CAST(@DateTime AS DATETIME2) AS ,CAST(@DateTime AS DATETIME2(3)) AS ,CAST(@DateTime AS DATE) AS ,CAST(@DateTime AS TIME) AS ,CAST(@DateTime AS TIME(3)) AS
DECLARE @myDateTime NVARCHAR(20) = CONVERT(NVARCHAR, @DateTime, 120); DECLARE @myDate NVARCHAR(10) = CONVERT(NVARCHAR, @DateTime, 120); SELECT @myDateTime AS ,@myDate AS
DECLARE @DateTime DATETIME2 = SYSDATETIME(); DECLARE @StringResult1 NVARCHAR(100) = FORMAT(@DateTime, DECLARE @StringResult2 NVARCHAR(100) = FORMAT(@DateTime, SELECT @DateTime SELECT @StringResult1, @StringResult2 SELECT PARSE(@StringResult1 AS DATETIME2) SELECT PARSE(@StringResult2 AS DATETIME2 USING
2015-06-17 06:20:09.1320951 6/17/2015 6:20 AM 17/06/2015 06:20 2015-06-17 06:20:00.0000000 2015-06-17 06:20:00.0000000
DECLARE @myDateTime DATETIME SET @myDateTime = -- Convert to string now SELECT LEFT(CONVERT(VARCHAR, @myDateTime, 120), 10)
SELECT CONVERT(varchar, @datetime, 103) --for UK Date format
DECLARE @Script VARCHAR(MAX) SELECT @Script = definition FROM manged.sys.all_sql_modules sq where sq.object_id = (SELECT object_id from managed.sys.objects Where type = Declare @Pos int SELECT @pos=CHARINDEX(CHAR(13)+CHAR(10),@script,7500) PRINT SUBSTRING(@Script,1,@Pos) PRINT SUBSTRING(@script,@pos,8000)
DECLARE @Counter INT SET @Counter = 0 DECLARE @TotalPrints INT SET @TotalPrints = (LEN(@script) / 8000) + 1 WHILE @Counter < @TotalPrints BEGIN -- Do your printing... SET @Counter = @Counter + 1 END
DECLARE @info NVARCHAR(MAX) --SET @info to something big PRINT CAST(@info AS NTEXT)
DECLARE @String NVARCHAR(MAX); DECLARE @CurrentEnd BIGINT; DECLARE @offset tinyint; set @string = replace( replace(@string, char(13) + char(10), char(10)) , char(13), char(10)) WHILE LEN(@String) > 1 BEGIN IF CHARINDEX(CHAR(10), @String) between 1 AND 4000 BEGIN SET @CurrentEnd = CHARINDEX(char(10), @String) -1 set @offset = 2 END ELSE BEGIN SET @CurrentEnd = 4000 set @offset = 1 END PRINT SUBSTRING(@String, 1, @CurrentEnd) set @string = SUBSTRING(@String, @CurrentEnd+@offset, LEN(@String)) END
SELECT [processing-instruction(x)]=@Script FOR XML PATH(
CREATE PROCEDURE [dbo].[Print] @sql varchar(max) AS BEGIN declare @n int, @i int = 0, @s int = 0, -- substring start posotion @l int; -- substring length set @n = ceiling(len(@sql) / 8000.0); while @i < @n begin set @l = 8000 - charindex(char(13), reverse(substring(@sql, @s, 8000))); print substring(@sql, @s, @l); set @i = @i + 1; set @s = @s + @l + 2; -- accumulation + CR/LF end return 0 END
--http: --Kelsey DECLARE @Counter INT SET @Counter = 0 DECLARE @TotalPrints INT SET @TotalPrints = (LEN(@sql) / 4000) + 1 WHILE @Counter < @TotalPrints BEGIN PRINT SUBSTRING(@sql, @Counter * 4000, 4000) SET @Counter = @Counter + 1 END PRINT LEN(@sql)
declare @i int = 1 while Exists(Select(Substring(@Script,@i,4000))) and (@i < LEN(@Script)) begin print Substring(@Script,@i,4000) set @i = @i+4000 end
declare @sqlAll as nvarchar(max) set @sqlAll = print print @sqlAll print print print print declare @i int = 1, @nextspace int = 0, @newline nchar(2) set @newline = nchar(13) + nchar(10) while Exists(Select(Substring(@sqlAll,@i,3000))) and (@i < LEN(@sqlAll)) begin while Substring(@sqlAll,@i+3000+@nextspace,1) <> BEGIN set @nextspace = @nextspace + 1 end print Substring(@sqlAll,@i,3000+@nextspace) set @i = @i+3000+@nextspace set @nextspace = 0 end print print print
EXEC (N WHERE object_id = OBJECT_ID(N AND type in (N DROP PROCEDURE EXEC (N AS BEGIN IF @iInput IS NULL RETURN; DECLARE @ReversedData NVARCHAR(MAX) , @LineBreakIndex INT , @SearchLength INT; SET @SearchLength = 4000; WHILE LEN(@iInput) > @SearchLength BEGIN SET @ReversedData = LEFT(@iInput COLLATE DATABASE_DEFAULT, @SearchLength); SET @ReversedData = REVERSE(@ReversedData COLLATE DATABASE_DEFAULT); SET @LineBreakIndex = CHARINDEX(CHAR(10) + CHAR(13), @ReversedData COLLATE DATABASE_DEFAULT); PRINT LEFT(@iInput, @SearchLength - @LineBreakIndex + 1); SET @iInput = RIGHT(@iInput, LEN(@iInput) - @SearchLength + @LineBreakIndex - 1); END; IF LEN(@iInput) > 0 PRINT @iInput; END;
EXEC (N AS BEGIN IF @iInput IS NULL RETURN; DECLARE @ReversedData NVARCHAR(MAX) , @LineBreakIndex INT , @SearchLength INT; SET @SearchLength = 4000; WHILE LEN(@iInput) > @SearchLength BEGIN SET @ReversedData = LEFT(@iInput COLLATE DATABASE_DEFAULT, @SearchLength); SET @ReversedData = REVERSE(@ReversedData COLLATE DATABASE_DEFAULT); SET @LineBreakIndex = CHARINDEX(CHAR(10) + CHAR(13), @ReversedData COLLATE DATABASE_DEFAULT); PRINT LEFT(@iInput, @SearchLength - @LineBreakIndex + 1); SET @iInput = RIGHT(@iInput, LEN(@iInput) - @SearchLength + @LineBreakIndex - 1); END; IF LEN(@iInput) > 0 PRINT @iInput; END;
CREATE PROCEDURE [Internal].[LongPrint] @msg nvarchar(max) AS BEGIN -- SET NOCOUNT ON reduces network overhead SET NOCOUNT ON; DECLARE @MsgLen int; DECLARE @CurrLineStartIdx int = 1; DECLARE @CurrLineEndIdx int; DECLARE @CurrLineLen int; DECLARE @SkipCount int; -- Normalise line end characters. SET @msg = REPLACE(@msg, char(13) + char(10), char(10)); SET @msg = REPLACE(@msg, char(13), char(10)); -- Store length of the normalised string. SET @MsgLen = LEN(@msg); -- Special case: Empty string. IF @MsgLen = 0 BEGIN PRINT RETURN; END -- Find the end of next substring to print. SET @CurrLineEndIdx = CHARINDEX(CHAR(10), @msg); IF @CurrLineEndIdx BETWEEN 1 AND 4000 BEGIN SET @CurrLineEndIdx = @CurrLineEndIdx - 1 SET @SkipCount = 2; END ELSE BEGIN SET @CurrLineEndIdx = 4000; SET @SkipCount = 1; END -- Loop: Print current substring, identify next substring (a do-while pattern is preferable but TSQL doesn WHILE @CurrLineStartIdx < @MsgLen BEGIN -- Print substring. PRINT SUBSTRING(@msg, @CurrLineStartIdx, (@CurrLineEndIdx - @CurrLineStartIdx)+1); -- Move to start of next substring. SET @CurrLineStartIdx = @CurrLineEndIdx + @SkipCount; -- Find the end of next substring to print. SET @CurrLineEndIdx = CHARINDEX(CHAR(10), @msg, @CurrLineStartIdx); SET @CurrLineLen = @CurrLineEndIdx - @CurrLineStartIdx; -- Find bounds of next substring to print. IF @CurrLineLen BETWEEN 1 AND 4000 BEGIN SET @CurrLineEndIdx = @CurrLineEndIdx - 1 SET @SkipCount = 2; END ELSE BEGIN SET @CurrLineEndIdx = @CurrLineStartIdx + 4000; SET @SkipCount = 1; END END END
DECLARE @Counter INT DECLARE @Counter1 INT SET @Counter = 0 SET @Counter1 = 0 DECLARE @TotalPrints INT SET @TotalPrints = (LEN(@QUERY) / 4000) + 1 print @TotalPrints WHILE @Counter < @TotalPrints BEGIN -- Do your printing... print(substring(@query,@COUNTER1,@COUNTER1+4000)) set @COUNTER1 = @Counter1+4000 SET @Counter = @Counter + 1 END
--http: --Bill Bai SET @SQL=replace(@SQL,char(10),char(13)+char(10)) SET @SQL=replace(@SQL,char(13)+char(13)+char(10),char(13)+char(10) ) DECLARE @Position int WHILE Len(@SQL)>0 BEGIN SET @Position=charindex(char(10),@SQL) PRINT left(@SQL,@Position-2) SET @SQL=substring(@SQL,@Position+1,len(@SQL)) end;
PRINT SUBSTRING(@SQL_InsertQuery, 1, 8000) PRINT SUBSTRING(@SQL_InsertQuery, 8001, 16000)
DECLARE @SQL VARCHAR(100) SET @SQL = EXECUTE sp_executesql @SQL
DECLARE @SQL NVARCHAR(100) SET @SQL = EXECUTE sp_executesql @SQL
DECLARE @SQL NVARCHAR(100) SET @SQL = N EXECUTE sp_executesql @SQL
exec @PreviousBusinessDay = dbo.up_GetBusinessDay @Date, -1
CREATE PROCEDURE YourStoredProcedure ( @Param1 int ,@Param2 varchar(5) ,@Param3 datetime OUTPUT ) AS IF ISNULL(@Param1,0)>5 BEGIN SET @Param3=GETDATE() END ELSE BEGIN SET @Param3= END RETURN 0 GO
DECLARE @OutputParameter datetime ,@ReturnValue int EXEC @ReturnValue=YourStoredProcedure 1,null, @OutputParameter OUTPUT PRINT @ReturnValue PRINT CONVERT(char(23),@OutputParameter ,121)
DECLARE @ResultForPos INT EXEC @ResultForPos = storedprocedureName SELECT @ResultForPos
declare @EventId int CREATE TABLE insert into set @EventId = (select * from drop table
USE AdventureWorks; GO DECLARE @returnstatus nvarchar(15); SET @returnstatus = NULL; EXEC @returnstatus = dbo.ufnGetSalesOrderStatusText @Status = 2; PRINT @returnstatus; GO
SELECT CASE WHEN CAST(date1 AS DATE) <= CAST(date2 AS DATE) ...
WITH dates(date1, date2, date3, date4) AS (SELECT CAST( CAST( CAST( CAST( SELECT CASE WHEN CAST(date1 AS DATE) <= CAST(date2 AS DATE) THEN ELSE END AS COMPARISON_WITH_CAST, CASE WHEN date3 <= date4 THEN ELSE END AS COMPARISON_WITHOUT_CAST FROM dates
SELECT ... FROM ... WHERE DATEDIFF(day, date1, date2) >= 0
BEGIN declare @firstDate datetime declare @secondDate datetime declare @chkDay int set @firstDate = set @secondDate = set @chkDay=Datediff(day,@firstDate ,@secondDate ) if @chkDay=0 Begin Print end else Begin Print end End
BEGIN declare @Date1 datetime declare @Date2 datetime declare @chkYear int declare @chkMonth int declare @chkDay int declare @chkHour int declare @chkMinute int declare @chkSecond int declare @chkMiliSecond int set @Date1= set @Date2= set @chkYear=datediff(yyyy,@Date1,@Date2) set @chkMonth=datediff(mm,@Date1,@Date2) set @chkDay=datediff(dd,@Date1,@Date2) set @chkHour=datediff(hh,@Date1,@Date2) set @chkMinute=datediff(mi,@Date1,@Date2) set @chkSecond=datediff(ss,@Date1,@Date2) set @chkMiliSecond=datediff(ms,@Date1,@Date2) if @chkYear=0 AND @chkMonth=0 AND @chkDay=0 AND @chkHour=0 AND @chkMinute=0 AND @chkSecond=0 AND @chkMiliSecond=0 Begin Print end else Begin Print end End
SELECT iar.Description, iai.Quantity, iai.Quantity * rpl.RegularPrice as iar.Compliance FROM InventoryAdjustmentReason iar LEFT OUTER JOIN InventoryAdjustmentItem iai on (iar.Id = iai.InventoryAdjustmentReasonId) LEFT OUTER JOIN Item i on (i.Id = iai.ItemId) LEFT OUTER JOIN ReportPriceLookup rpl on (rpl.SkuNumber = i.SkuNo) WHERE iar.StoreUse =
SELECT iar.Description, ISNULL(iai.Quantity,0) as Quantity, ISNULL(iai.Quantity * rpl.RegularPrice,0) as iar.Compliance FROM InventoryAdjustmentReason iar LEFT OUTER JOIN InventoryAdjustmentItem iai on (iar.Id = iai.InventoryAdjustmentReasonId) LEFT OUTER JOIN Item i on (i.Id = iai.ItemId) LEFT OUTER JOIN ReportPriceLookup rpl on (rpl.SkuNumber = i.SkuNo) WHERE iar.StoreUse =
SELECT iar.Description, IFNULL(iai.Quantity,0) as Quantity, IFNULL(iai.Quantity * rpl.RegularPrice,0) as iar.Compliance FROM InventoryAdjustmentReason iar LEFT OUTER JOIN InventoryAdjustmentItem iai on (iar.Id = iai.InventoryAdjustmentReasonId) LEFT OUTER JOIN Item i on (i.Id = iai.ItemId) LEFT OUTER JOIN ReportPriceLookup rpl on (rpl.SkuNumber = i.SkuNo) WHERE iar.StoreUse =
SELECT t.id, COALESCE(d.field, FROM table t LEFT JOIN detail d ON t.id = d.item
DECLARE @Village TABLE (CastleType TEXT) INSERT INTO @Village VALUES ( ) SELECT * FROM @Village WHERE [CastleType] LIKE
SELECT * FROM [Village] WHERE CONVERT(VARCHAR, CastleType) =
SELECT * FROM [Village] WHERE CONVERT(VARCHAR(MAX), [CastleType]) =
declare @Space nvarchar(10) declare @Space2 nvarchar(10) set @Space = set @Space2 = if @Space like @Space2 print else print if @Space2 like @Space print else print @Space Not Like @Space2 @Space2 Like @Space
declare @mayvar as varchar(10) set @mayvar = select mykey, myfield from mytable where myfield = @mayvar
select mykey, myfield from mytable where myfield = @mayvar and DATALENGTH(isnull(myfield,
CREATE TABLE data VARCHAR(18), index_size VARCHAR(18), unused VARCHAR(18)) EXEC sp_msforeachtable -- SELECT * FROM -- SELECT name, CONVERT(INT, SUBSTRING(data, 1, LEN(data)-3)) FROM SELECT SUM(CONVERT(INT, SUBSTRING(data, 1, LEN(data)-3))) FROM DROP TABLE
USE [myDatabase] GO SELECT [size] * 8 , [filename] FROM sysfiles
SELECT DB_NAME( dbid ) AS DatabaseName, CAST( ( SUM( size ) * 8 ) / ( 1024.0 * 1024.0 ) AS decimal( 10, 2 ) ) AS DbSizeGb FROM sys.sysaltfiles GROUP BY DB_NAME( dbid )
set ANSI_NULLS ON set QUOTED_IDENTIFIER ON go DECLARE @iCount int, @iMax int, @DatabaseName varchar(200), @SQL varchar (8000) Select NAME, DBID, crdate, filename, version INTO from MAster..SYSDatabASES SELECT @iCount = Count(DBID) FROM Select @SQL= Name varchar(100), vFile varchar (300), AllocatedSpace int NUll, UsedSpace int Null, PercentageFree int Null ) exec (@SQL) Create Table Name varchar(100), vFile varchar (300), AllocatedSpace int NUll, UsedSpace int Null, PercentageFree int Null ) WHILE @iCount>0 BEGIN SELECT @iMax =Max(dbid) FROM Select @DatabaseName = Name FROM SELECT @SQL = EXEC ( Print (@SQL) EXEC (@SQL) SELECT @SQL = EXEC (@SQL) DELETE FROM Select @iCount =@iCount -1 END UPDATE SET AllocatedSpace = (TotalExtents * 64.0 / 1024.0 ), UsedSpace =(USedExtents * 64.0 / 1024.0 ) UPDATE SET PercentageFree = 100-Convert(float,UsedSpace)/Convert(float,AllocatedSpace )* 100 WHERE USEDSPACE>0 CREATE TABLE DBName varchar( 100), LogSize float, PrcntUsed float, status int ) INSERT INTO EXEC ( INSERT INTO select @@ServerName ,DBNAME, from UNION select @@ServerName ,DBNAME, from Select * from select ServerName ,DBNAME, FileType, Sum( AllocatedSpace) as AllocatedSpaceMB from Group By ServerName ,DBNAME, FileType Order By ServerName ,DBNAME, FileType select ServerName ,DBNAME, Sum( AllocatedSpace) as AllocatedSpaceMB from Group By ServerName ,DBNAME Order By ServerName ,DBNAME drop table drop table drop table drop table
SELECT foo From MyTable WHERE ISNUMERIC (foo) = 1 AND CAST(foo AS int) > 100
SELECT foo FROM (SELECT foo From MyTable WHERE ISNUMERIC (foo) = 1) bar WHERE CAST(foo AS int) > 100
SELECT foo FROM (SELECT TOP 100 PERCENT foo From MyTable WHERE ISNUMERIC (foo) = 1 ORDER BY foo) bar WHERE CAST(foo AS int) > 100
CREATE VIEW my_view AS SELECT i.item_id, i.item_description, it.item_type_description FROM ITEMS i JOIN ITEM_TYPES it ON it.item_type_id = i.item_type_id ORDER BY i.item_description
SELECT t.item_id, t.item_description, t.item_type_description FROM my_view t ORDER BY t.item_type_description
SELECT t.item_id, t.item_description, t.item_type_description FROM (SELECT i.item_id, i.item_description, it.item_type_description FROM ITEMS i JOIN ITEM_TYPES it ON it.item_type_id = i.item_type_id ORDER BY i.item_description) t ORDER BY t.item_type_description
SELECT TOP ( SELECT COUNT(foo) From MyTable WHERE ISNUMERIC (foo) = 1) * FROM bar WITH(NOLOCK) ORDER BY foo WHERE CAST(foo AS int) > 100 )
declare @t int set @t=100 select top (@t) percent * from tableOf
CREATE VIEW v_Test AS SELECT name FROM sysobjects ORDER BY name GO
DECLARE @ret_string varchar (255) EXEC xp_sprintf @ret_string OUTPUT, PRINT @ret_string
create function dbo.fnSprintf (@s varchar(MAX), @params varchar(MAX), @separator char(1) = returns varchar(MAX) as begin declare @p varchar(MAX) declare @paramlen int set @params = @params + @separator set @paramlen = len(@params) while not @params = begin set @p = left(@params+@separator, charindex(@separator, @params)-1) set @s = STUFF(@s, charindex( set @params = substring(@params, len(@p)+2, @paramlen) end return @s end
DECLARE @s NVARCHAR(50) = DECLARE @d INT = 123; SELECT FORMATMESSAGE( -- RETURNS
SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE( SELECT FORMATMESSAGE(
create function dbo.Format1 ( @String nvarchar(4000), @Param0 sql_variant ) returns nvarchar(4000) as begin declare @Null nvarchar(4) = N return replace(@String, N end
create function dbo.Format2 ( @String nvarchar(4000), @Param0 sql_variant, @Param1 sql_variant ) returns nvarchar(4000) as begin declare @Null nvarchar(4) = N set @String = replace(@String, N return replace(@String, N end
create function dbo.Format3 ( @String nvarchar(4000), @Param0 sql_variant, @Param1 sql_variant, @Param2 sql_variant ) returns nvarchar(4000) as begin declare @Null nvarchar(4) = N set @String = replace(@String, N set @String = replace(@String, N return replace(@String, N end
declare @Param0 nvarchar(10) = N @Param1 int = 1234567 , @Param2 datetime2(0) = getdate(); select dbo.Format3(N
**>>**IF OBJECT_ID( N DROP FUNCTION [dbo].[FormatString] GO /*************************************************** Object Name : FormatString Purpose : Returns the formatted string. Original Author : Karthik D V http: Sample Call: SELECT dbo.FormatString ( N *******************************************/ CREATE FUNCTION [dbo].[FormatString]( @Format NVARCHAR(4000) , @Parameters NVARCHAR(4000) ) RETURNS NVARCHAR(4000) AS BEGIN --DECLARE @Format NVARCHAR(4000), @Parameters NVARCHAR(4000) select @format= DECLARE @Message NVARCHAR(400), @Delimiter CHAR(1) DECLARE @ParamTable TABLE ( ID INT IDENTITY(0,1), Parameter VARCHAR(1000) ) Declare @startPos int, @endPos int SELECT @Message = @Format, @Delimiter = --handle first parameter set @endPos=CHARINDEX(@Delimiter,@Parameters) if (@endPos=0 and @Parameters is not null) --there is only one parameter insert into @ParamTable (Parameter) values(@Parameters) else begin insert into @ParamTable (Parameter) select substring(@Parameters,0,@endPos) end while @endPos>0 Begin --insert a row for each parameter in the set @startPos = @endPos + LEN(@Delimiter) set @endPos = CHARINDEX(@Delimiter,@Parameters, @startPos) if (@endPos>0) insert into @ParamTable (Parameter) select substring(@Parameters,@startPos,@endPos - @startPos) else insert into @ParamTable (Parameter) select substring(@Parameters,@startPos,4000) End UPDATE @ParamTable SET @Message = REPLACE ( @Message, RETURN @Message END Go grant execute,references on dbo.formatString to public
some string "abcd" some int 100 date 29-Apr-2017 some string "abcd" some int 100 date time 29-Apr-2017 19:40
create function dbo.FormatValue(@param sql_variant) returns nvarchar(100) begin declare @result nvarchar(100) if (SQL_VARIANT_PROPERTY(@param, begin select @result = REPLACE(CONVERT(CHAR(11), @param, 106), end else if (SQL_VARIANT_PROPERTY(@param, begin select @result = REPLACE(CONVERT(CHAR(11), @param, 106), end else begin select @result = cast(@param as nvarchar(100)) end return @result end; create function dbo.FormatString( @format nvarchar(4000) ,@param1 sql_variant = null ,@param2 sql_variant = null ,@param3 sql_variant = null ,@param4 sql_variant = null ,@param5 sql_variant = null ) returns nvarchar(4000) begin /* Tejasvi Hegde, 29-April-2017 select dbo.FormatString( select dbo.FormatString( */ declare @result nvarchar(4000) select @param1 = dbo.formatValue(@param1) ,@param2 = dbo.formatValue(@param2) ,@param3 = dbo.formatValue(@param3) ,@param4 = dbo.formatValue(@param4) ,@param5 = dbo.formatValue(@param5) select @param2 = cast(@param2 as nvarchar) EXEC xp_sprintf @result OUTPUT,@format , @param1, @param2, @param3, @param4, @param5 return @result end;
sp_addmessage @msgnum=50001,@severity=1,@msgText= SELECT FORMATMESSAGE(50001,
IF OBJECT_ID( N DROP FUNCTION [dbo].[FormatString] GO /*************************************************** Object Name : FormatString Purpose : Returns the formatted string. Original Author : Karthik D V http: Sample Call: SELECT dbo.FormatString ( N *******************************************/ CREATE FUNCTION [dbo].[FormatString]( @Format NVARCHAR(4000) , @Parameters NVARCHAR(4000) ) RETURNS NVARCHAR(4000) AS BEGIN --DECLARE @Format NVARCHAR(4000), @Parameters NVARCHAR(4000) select @format= DECLARE @Message NVARCHAR(400), @Delimiter CHAR(1) DECLARE @ParamTable TABLE ( ID INT IDENTITY(0,1), Parameter VARCHAR(1000) ) Declare @startPos int, @endPos int SELECT @Message = @Format, @Delimiter = --handle first parameter set @endPos=CHARINDEX(@Delimiter,@Parameters) if (@endPos=0 and @Parameters is not null) --there is only one parameter insert into @ParamTable (Parameter) values(@Parameters) else begin insert into @ParamTable (Parameter) select substring(@Parameters,0,@endPos) end while @endPos>0 Begin --insert a row for each parameter in the set @startPos = @endPos + LEN(@Delimiter) set @endPos = CHARINDEX(@Delimiter,@Parameters, @startPos) if (@endPos>0) insert into @ParamTable (Parameter) select substring(@Parameters,@startPos,@endPos) else insert into @ParamTable (Parameter) select substring(@Parameters,@startPos,4000) End UPDATE @ParamTable SET @Message = REPLACE ( @Message, RETURN @Message END Go grant execute,references on dbo.formatString to public
print dbo.formatString( --result: hello world... you are good
SELECT employee_id FROM V_EMPLOYEE WHERE row_number() OVER ( ORDER BY employee_id ) > 0 ORDER BY Employee_ID
WITH MyCte AS ( select employee_id, RowNum = row_number() OVER ( order by employee_id ) from V_EMPLOYEE ORDER BY Employee_ID ) SELECT employee_id FROM MyCte WHERE RowNum > 0
SELECT employee_id FROM ( SELECT employee_id, ROW_NUMBER() OVER (ORDER BY employee_id) AS rn FROM V_EMPLOYEE ) q WHERE rn > 0 ORDER BY Employee_ID
Select * from ( Select ROW_NUMBER() OVER ( order by Id) as from tbl_Contact_Us ) as tbl Where tbl.Row_Number = 5
SELECT employee_id FROM (SELECT employee_id, row_number() OVER (order by employee_id) AS FROM V_EMPLOYEE) TableExpressionsMustHaveAnAliasForDumbReasons WHERE rownumber > 0
WITH object_rows AS ( SELECT object_id, ROW_NUMBER() OVER ( ORDER BY object_id) RN FROM sys.objects) SELECT object_id FROM object_rows WHERE RN > 1 SELECT object_id FROM (SELECT object_id, ROW_NUMBER() OVER ( ORDER BY object_id) RN FROM sys.objects) T WHERE RN > 1
WITH employee_rows AS ( SELECT t.employee_id, ROW_NUMBER() OVER ( ORDER BY t.employee_id ) FROM V_EMPLOYEE t) SELECT er.employee_id FROM employee_rows er WHERE er.rownum > 1
SELECT er.employee_id FROM (SELECT t.employee_id, ROW_NUMBER() OVER ( ORDER BY t.employee_id ) FROM V_EMPLOYEE t) er WHERE er.rownum > 1
DECLARE @YourTable table (RowID int not null primary key identity, Value1 int, Value2 int, value3 int) SET NOCOUNT ON INSERT INTO @YourTable VALUES (1,1,1) INSERT INTO @YourTable VALUES (1,1,2) INSERT INTO @YourTable VALUES (1,1,3) INSERT INTO @YourTable VALUES (1,2,1) INSERT INTO @YourTable VALUES (1,2,2) INSERT INTO @YourTable VALUES (1,2,3) INSERT INTO @YourTable VALUES (1,3,1) INSERT INTO @YourTable VALUES (1,3,2) INSERT INTO @YourTable VALUES (1,3,3) INSERT INTO @YourTable VALUES (2,1,1) INSERT INTO @YourTable VALUES (2,1,2) INSERT INTO @YourTable VALUES (2,1,3) INSERT INTO @YourTable VALUES (2,2,1) INSERT INTO @YourTable VALUES (2,2,2) INSERT INTO @YourTable VALUES (2,2,3) INSERT INTO @YourTable VALUES (2,3,1) INSERT INTO @YourTable VALUES (2,3,2) INSERT INTO @YourTable VALUES (2,3,3) INSERT INTO @YourTable VALUES (3,1,1) INSERT INTO @YourTable VALUES (3,1,2) INSERT INTO @YourTable VALUES (3,1,3) INSERT INTO @YourTable VALUES (3,2,1) INSERT INTO @YourTable VALUES (3,2,2) INSERT INTO @YourTable VALUES (3,2,3) INSERT INTO @YourTable VALUES (3,3,1) INSERT INTO @YourTable VALUES (3,3,2) INSERT INTO @YourTable VALUES (3,3,3) SET NOCOUNT OFF DECLARE @PageNumber int DECLARE @PageSize int DECLARE @SortBy int SET @PageNumber=3 SET @PageSize=5 SET @SortBy=1 --SELECT * FROM @YourTable --Method 1 ;WITH PaginatedYourTable AS ( SELECT RowID,Value1,Value2,Value3 ,CASE @SortBy WHEN 1 THEN ROW_NUMBER() OVER (ORDER BY Value1 ASC) WHEN 2 THEN ROW_NUMBER() OVER (ORDER BY Value2 ASC) WHEN 3 THEN ROW_NUMBER() OVER (ORDER BY Value3 ASC) WHEN -1 THEN ROW_NUMBER() OVER (ORDER BY Value1 DESC) WHEN -2 THEN ROW_NUMBER() OVER (ORDER BY Value2 DESC) WHEN -3 THEN ROW_NUMBER() OVER (ORDER BY Value3 DESC) END AS RowNumber FROM @YourTable --WHERE ) SELECT RowID,Value1,Value2,Value3,RowNumber ,@PageNumber AS PageNumber, @PageSize AS PageSize, @SortBy AS SortBy FROM PaginatedYourTable WHERE RowNumber>=(@PageNumber-1)*@PageSize AND RowNumber<=(@PageNumber*@PageSize)-1 ORDER BY RowNumber -------------------------------------------- --Method 2 ;WITH PaginatedYourTable AS ( SELECT RowID,Value1,Value2,Value3 ,ROW_NUMBER() OVER ( ORDER BY CASE @SortBy WHEN 1 THEN Value1 WHEN 2 THEN Value2 WHEN 3 THEN Value3 END ASC ,CASE @SortBy WHEN -1 THEN Value1 WHEN -2 THEN Value2 WHEN -3 THEN Value3 END DESC ) RowNumber FROM @YourTable --WHERE more conditions here ) SELECT RowID,Value1,Value2,Value3,RowNumber ,@PageNumber AS PageNumber, @PageSize AS PageSize, @SortBy AS SortBy FROM PaginatedYourTable WHERE RowNumber>=(@PageNumber-1)*@PageSize AND RowNumber<=(@PageNumber*@PageSize)-1 --AND more conditions here ORDER BY CASE @SortBy WHEN 1 THEN Value1 WHEN 2 THEN Value2 WHEN 3 THEN Value3 END ASC ,CASE @SortBy WHEN -1 THEN Value1 WHEN -2 THEN Value2 WHEN -3 THEN Value3 END DESC
RowID Value1 Value2 Value3 RowNumber PageNumber PageSize SortBy ------ ------ ------ ------ ---------- ----------- ----------- ----------- 10 2 1 1 10 3 5 1 11 2 1 2 11 3 5 1 12 2 1 3 12 3 5 1 13 2 2 1 13 3 5 1 14 2 2 2 14 3 5 1 (5 row(s) affected RowID Value1 Value2 Value3 RowNumber PageNumber PageSize SortBy ------ ------ ------ ------ ---------- ----------- ----------- ----------- 10 2 1 1 10 3 5 1 11 2 1 2 11 3 5 1 12 2 1 3 12 3 5 1 13 2 2 1 13 3 5 1 14 2 2 2 14 3 5 1 (5 row(s) affected)
WITH MyCte AS ( select employee_id, RowNum = row_number() OVER (order by employee_id) from V_EMPLOYEE ) SELECT employee_id FROM MyCte WHERE RowNum > 0 ORDER BY employee_id
select salary from ( select Salary, ROW_NUMBER() over (order by Salary desc) rn from Employee ) t where t.rn = 2
TableA ------ ID, Name TableB ------ ID, SomeColumn, TableA_ID (FK for TableA)
ID Name SomeColumn 1. ABC X, Y, Z (these are three different rows) 2. MNO R, S
SELECT ID, Name, (SELECT SomeColumn FROM TableB WHERE F_ID=TableA.ID) FROM TableA
declare @t table(id int, name varchar(20),somecolumn varchar(MAX)) insert into @t select 1, select 1, select 1, select 2, select 2,
SELECT ID,Name, STUFF((SELECT FROM @T T2 WHERE T1.id = T2.id AND T1.name = T2.name FOR XML PATH( FROM @T T1 GROUP BY id,Name
CREATE FUNCTION CombineValues ( @FK_ID INT -- The foreign key from TableA which is used -- to fetch corresponding records ) RETURNS VARCHAR(8000) AS BEGIN DECLARE @SomeColumnList VARCHAR(8000); SELECT @SomeColumnList = COALESCE(@SomeColumnList + FROM TableB C WHERE C.FK_ID = @FK_ID; RETURN ( SELECT @SomeColumnList ) END
SELECT ID, Name, dbo.CombineValues(FK_ID) FROM TableA
CREATE PROCEDURE GetCombinedValues @FK_ID int As BEGIN DECLARE @SomeColumnList VARCHAR(800) SELECT @SomeColumnList = COALESCE(@SomeColumnList + FROM TableB WHERE FK_ID = @FK_ID Select *, @SomeColumnList as SelectedIds FROM TableA WHERE FK_ID = @FK_ID END
SELECT TableA.ID, TableA.Name, group_concat(TableB.SomeColumn) as SomColumnGroup FROM TableA LEFT JOIN TableB ON TableB.TableA_ID = TableA.ID
ID Name SomeColumn 1 ABC X 1 ABC Y 1 ABC Z 2 MNO R 2 MNO S
SELECT Id, Name From tableA WHERE ... SELECT tableA.Id AS ParentId, Somecolumn FROM tableA INNER JOIN tableB on TableA.Id = TableB.F_Id WHERE ...
ds.Relations.Add("foo", ds.Tables[0].Columns("Id"), ds.Tables[1].Columns("ParentId"));
<asp:DataList ID="Subcategories" DataKeyField="ParentCatId" DataSource= RepeatDirection="Horizontal" ItemStyle-HorizontalAlign="left" ItemStyle-VerticalAlign="top" runat="server" >
SELECT ID, SUBSTRING(( SELECT FROM @T T2 WHERE WHERE T1.id = T2.id FOR XML PATH( FROM @T T1 GROUP BY ID
SELECT GROUP_CONCAT(field_attr_best_weekday_value)as RAVI FROM content_field_attr_best_weekday LEFT JOIN content_type_attraction on content_field_attr_best_weekday.nid = content_type_attraction.nid GROUP BY content_field_attr_best_weekday.nid
SELECT t.ID, t.NAME, (SELECT t1.SOMECOLUMN FROM TABLEB t1 WHERE t1.F_ID = T.TABLEA.ID) FROM TABLEA t;
ID Name SomeColumn 1. ABC ,X,Y Z (these are three different rows) 2. MNO ,R,S
create PROCEDURE [dbo].[util_ScriptTable] @DBName SYSNAME ,@schema sysname ,@TableName SYSNAME ,@IncludeConstraints BIT = 1 ,@IncludeIndexes BIT = 1 ,@NewTableSchema sysname ,@NewTableName SYSNAME = NULL ,@UseSystemDataTypes BIT = 0 ,@script varchar(max) output AS BEGIN try if not exists (select * from sys.types where name = create type TableType as table (ObjectID int)--drop type TableType declare @sql nvarchar(max) DECLARE @MainDefinition TABLE (FieldValue VARCHAR(200)) --DECLARE @DBName SYSNAME DECLARE @ClusteredPK BIT DECLARE @TableSchema NVARCHAR(255) --SET @DBName = DB_NAME(DB_ID()) SELECT @TableName = name FROM sysobjects WHERE id = OBJECT_ID(@TableName) DECLARE @ShowFields TABLE (FieldID INT IDENTITY(1,1) ,DatabaseName VARCHAR(100) ,TableOwner VARCHAR(100) ,TableName VARCHAR(100) ,FieldName VARCHAR(100) ,ColumnPosition INT ,ColumnDefaultValue VARCHAR(100) ,ColumnDefaultName VARCHAR(100) ,IsNullable BIT ,DataType VARCHAR(100) ,MaxLength varchar(10) ,NumericPrecision INT ,NumericScale INT ,DomainName VARCHAR(100) ,FieldListingName VARCHAR(110) ,FieldDefinition CHAR(1) ,IdentityColumn BIT ,IdentitySeed INT ,IdentityIncrement INT ,IsCharColumn BIT ,IsComputed varchar(255)) DECLARE @HoldingArea TABLE(FldID SMALLINT IDENTITY(1,1) ,Flds VARCHAR(4000) ,FldValue CHAR(1) DEFAULT(0)) DECLARE @PKObjectID TABLE(ObjectID INT) DECLARE @Uniques TABLE(ObjectID INT) DECLARE @HoldingAreaValues TABLE(FldID SMALLINT IDENTITY(1,1) ,Flds VARCHAR(4000) ,FldValue CHAR(1) DEFAULT(0)) DECLARE @Definition TABLE(DefinitionID SMALLINT IDENTITY(1,1) ,FieldValue VARCHAR(200)) set @sql= ' use SELECT distinct DB_NAME() ,inf.TABLE_SCHEMA ,inf.TABLE_NAME , ,CAST(inf.ORDINAL_POSITION AS INT) ,inf.COLUMN_DEFAULT ,dobj.name AS ColumnDefaultName ,CASE WHEN inf.IS_NULLABLE = ,inf.DATA_TYPE ,case inf.CHARACTER_MAXIMUM_LENGTH when -1 then ,CAST(inf.NUMERIC_PRECISION AS INT) ,CAST(inf.NUMERIC_SCALE AS INT) ,inf.DOMAIN_NAME ,inf.COLUMN_NAME + , --caso di viste, dà come campo identity ma nn dà i valori, quindi lo ignoro ,CASE WHEN ic.object_id IS not NULL and ic.seed_value is not null THEN 1 ELSE 0 END AS IdentityColumn--CASE WHEN ic.object_id IS NULL THEN 0 ELSE 1 END AS IdentityColumn ,CAST(ISNULL(ic.seed_value,0) AS INT) AS IdentitySeed ,CAST(ISNULL(ic.increment_value,0) AS INT) AS IdentityIncrement ,CASE WHEN c.collation_name IS NOT NULL THEN 1 ELSE 0 END AS IsCharColumn ,cc.definition from (select schema_id,object_id,name from sys.views union all select schema_id,object_id,name from sys.tables)t --sys.tables t join sys.schemas s on t.schema_id=s.schema_id JOIN sys.columns c ON t.object_id=c.object_id --AND s.schema_id=c.schema_id LEFT JOIN sys.identity_columns ic ON t.object_id=ic.object_id AND c.column_id=ic.column_id left JOIN sys.types st ON st.system_type_id=c.system_type_id and st.principal_id=t.object_id--COALESCE(c.DOMAIN_NAME,c.DATA_TYPE) = st.name LEFT OUTER JOIN sys.objects dobj ON dobj.object_id = c.default_object_id AND dobj.type = left join sys.computed_columns cc on t.object_id=cc.object_id and c.column_id=cc.column_id join INFORMATION_SCHEMA.COLUMNS inf on t.name=inf.TABLE_NAME and s.name=inf.TABLE_SCHEMA and c.name=inf.COLUMN_NAME WHERE inf.TABLE_NAME = @TableName and inf.TABLE_SCHEMA=@schema ORDER BY inf.ORDINAL_POSITION ' print @sql INSERT INTO @ShowFields( DatabaseName ,TableOwner ,TableName ,FieldName ,ColumnPosition ,ColumnDefaultValue ,ColumnDefaultName ,IsNullable ,DataType ,MaxLength ,NumericPrecision ,NumericScale ,DomainName ,FieldListingName ,FieldDefinition ,IdentityColumn ,IdentitySeed ,IdentityIncrement ,IsCharColumn ,IsComputed) exec sp_executesql @sql, N @TableName=@TableName,@schema=@schema /* SELECT @DBName--DB_NAME() ,TABLE_SCHEMA ,TABLE_NAME ,COLUMN_NAME ,CAST(ORDINAL_POSITION AS INT) ,COLUMN_DEFAULT ,dobj.name AS ColumnDefaultName ,CASE WHEN c.IS_NULLABLE = ,DATA_TYPE ,CAST(CHARACTER_MAXIMUM_LENGTH AS INT) ,CAST(NUMERIC_PRECISION AS INT) ,CAST(NUMERIC_SCALE AS INT) ,DOMAIN_NAME ,COLUMN_NAME + , ,CASE WHEN ic.object_id IS NULL THEN 0 ELSE 1 END AS IdentityColumn ,CAST(ISNULL(ic.seed_value,0) AS INT) AS IdentitySeed ,CAST(ISNULL(ic.increment_value,0) AS INT) AS IdentityIncrement ,CASE WHEN st.collation_name IS NOT NULL THEN 1 ELSE 0 END AS IsCharColumn FROM INFORMATION_SCHEMA.COLUMNS c JOIN sys.columns sc ON c.TABLE_NAME = OBJECT_NAME(sc.object_id) AND c.COLUMN_NAME = sc.Name LEFT JOIN sys.identity_columns ic ON c.TABLE_NAME = OBJECT_NAME(ic.object_id) AND c.COLUMN_NAME = ic.Name JOIN sys.types st ON COALESCE(c.DOMAIN_NAME,c.DATA_TYPE) = st.name LEFT OUTER JOIN sys.objects dobj ON dobj.object_id = sc.default_object_id AND dobj.type = WHERE c.TABLE_NAME = @TableName ORDER BY c.TABLE_NAME, c.ORDINAL_POSITION */ SELECT TOP 1 @TableSchema = TableOwner FROM @ShowFields INSERT INTO @HoldingArea (Flds) VALUES( INSERT INTO @Definition(FieldValue)VALUES( INSERT INTO @Definition(FieldValue)VALUES( INSERT INTO @Definition(FieldValue) SELECT CHAR(10) + FieldName + --CASE WHEN DomainName IS NOT NULL AND @UseSystemDataTypes = 0 THEN DomainName + CASE WHEN IsNullable = 1 THEN CASE WHEN DomainName IS NOT NULL AND @UseSystemDataTypes = 0 THEN DomainName + CASe WHEN IsNullable = 1 THEN ELSE END ELSE case when IsComputed is null then UPPER(DataType) + CASE WHEN IsCharColumn = 1 THEN ELSE CASE WHEN DataType = ELSE CASE WHEN DataType = ELSE end end END + CASE WHEN IdentityColumn = 1 THEN ELSE END + CASE WHEN IsNullable = 1 THEN ELSE END + CASE WHEN ColumnDefaultName IS NOT NULL AND @IncludeConstraints = 1 THEN ELSE END else end END + CASE WHEN FieldID = (SELECT MAX(FieldID) FROM @ShowFields) THEN ELSE END FROM @ShowFields IF @IncludeConstraints = 1 BEGIN set @sql= ' use SELECT distinct FROM ( SELECT ReferencedObject = OBJECT_NAME(fk.referenced_object_id), ParentObject = OBJECT_NAME(parent_object_id),fk.name , REVERSE(SUBSTRING(REVERSE(( SELECT cp.name + FROM sys.foreign_key_columns fkc JOIN sys.columns cp ON fkc.parent_object_id = cp.object_id AND fkc.parent_column_id = cp.column_id WHERE fkc.constraint_object_id = fk.object_id FOR XML PATH( REVERSE(SUBSTRING(REVERSE(( SELECT cr.name + FROM sys.foreign_key_columns fkc JOIN sys.columns cr ON fkc.referenced_object_id = cr.object_id AND fkc.referenced_column_id = cr.column_id WHERE fkc.constraint_object_id = fk.object_id FOR XML PATH( FROM sys.foreign_keys fk inner join sys.schemas s on fk.schema_id=s.schema_id and s.name=@schema) a WHERE ParentObject = @TableName ' print @sql INSERT INTO @Definition(FieldValue) exec sp_executesql @sql, N @TableName=@TableName,@NewTableName=@NewTableName,@schema=@schema /* SELECT FROM ( SELECT ReferencedObject = OBJECT_NAME(fk.referenced_object_id), ParentObject = OBJECT_NAME(parent_object_id),fk.name , REVERSE(SUBSTRING(REVERSE(( SELECT cp.name + FROM sys.foreign_key_columns fkc JOIN sys.columns cp ON fkc.parent_object_id = cp.object_id AND fkc.parent_column_id = cp.column_id WHERE fkc.constraint_object_id = fk.object_id FOR XML PATH( REVERSE(SUBSTRING(REVERSE(( SELECT cr.name + FROM sys.foreign_key_columns fkc JOIN sys.columns cr ON fkc.referenced_object_id = cr.object_id AND fkc.referenced_column_id = cr.column_id WHERE fkc.constraint_object_id = fk.object_id FOR XML PATH( FROM sys.foreign_keys fk ) a WHERE ParentObject = @TableName */ set @sql= ' use SELECT distinct FROM sys.check_constraints c join sys.schemas s on c.schema_id=s.schema_id and s.name=@schema WHERE OBJECT_NAME(parent_object_id) = @TableName ' print @sql INSERT INTO @Definition(FieldValue) exec sp_executesql @sql, N @TableName=@TableName,@NewTableName=@NewTableName,@schema=@schema /* SELECT WHERE OBJECT_NAME(parent_object_id) = @TableName */ set @sql= ' use SELECT DISTINCT PKObject = cco.object_id FROM sys.key_constraints cco JOIN sys.index_columns cc ON cco.parent_object_id = cc.object_id AND cco.unique_index_id = cc.index_id JOIN sys.indexes i ON cc.object_id = i.object_id AND cc.index_id = i.index_id join sys.schemas s on cco.schema_id=s.schema_id and s.name=@schema WHERE OBJECT_NAME(parent_object_id) = @TableName AND i.type = 1 AND is_primary_key = 1 ' print @sql INSERT INTO @PKObjectID(ObjectID) exec sp_executesql @sql, N @TableName=@TableName,@schema=@schema /* SELECT DISTINCT PKObject = cco.object_id FROM sys.key_constraints cco JOIN sys.index_columns cc ON cco.parent_object_id = cc.object_id AND cco.unique_index_id = cc.index_id JOIN sys.indexes i ON cc.object_id = i.object_id AND cc.index_id = i.index_id WHERE OBJECT_NAME(parent_object_id) = @TableName AND i.type = 1 AND is_primary_key = 1 */ set @sql= ' use SELECT DISTINCT PKObject = cco.object_id FROM sys.key_constraints cco JOIN sys.index_columns cc ON cco.parent_object_id = cc.object_id AND cco.unique_index_id = cc.index_id JOIN sys.indexes i ON cc.object_id = i.object_id AND cc.index_id = i.index_id join sys.schemas s on cco.schema_id=s.schema_id and s.name=@schema WHERE OBJECT_NAME(parent_object_id) = @TableName AND i.type = 2 AND is_primary_key = 0 AND is_unique_constraint = 1 ' print @sql INSERT INTO @Uniques(ObjectID) exec sp_executesql @sql, N @TableName=@TableName,@schema=@schema /* SELECT DISTINCT PKObject = cco.object_id FROM sys.key_constraints cco JOIN sys.index_columns cc ON cco.parent_object_id = cc.object_id AND cco.unique_index_id = cc.index_id JOIN sys.indexes i ON cc.object_id = i.object_id AND cc.index_id = i.index_id WHERE OBJECT_NAME(parent_object_id) = @TableName AND i.type = 2 AND is_primary_key = 0 AND is_unique_constraint = 1 */ SET @ClusteredPK = CASE WHEN @@ROWCOUNT > 0 THEN 1 ELSE 0 END declare @t TableType insert @t select * from @PKObjectID declare @u TableType insert @u select * from @Uniques set @sql= ' use SELECT distinct + FROM sys.key_constraints ccok LEFT JOIN sys.index_columns cc ON ccok.parent_object_id = cc.object_id AND cco.unique_index_id = cc.index_id LEFT JOIN sys.columns c ON cc.object_id = c.object_id AND cc.column_id = c.column_id LEFT JOIN sys.indexes i ON cc.object_id = i.object_id AND cc.index_id = i.index_id WHERE i.object_id = ccok.parent_object_id AND ccok.object_id = cco.object_id order by key_ordinal FOR XML PATH( FROM sys.key_constraints cco inner join sys.schemas s on cco.schema_id=s.schema_id and s.name=@schema LEFT JOIN @U u ON cco.object_id = u.objectID LEFT JOIN @t pk ON cco.object_id = pk.ObjectID WHERE OBJECT_NAME(cco.parent_object_id) = @TableName ' print @sql INSERT INTO @Definition(FieldValue) exec sp_executesql @sql, N @TableName=@TableName,@NewTableName=@NewTableName,@schema=@schema,@t=@t,@u=@u /* SELECT + FROM sys.key_constraints ccok LEFT JOIN sys.index_columns cc ON ccok.parent_object_id = cc.object_id AND cco.unique_index_id = cc.index_id LEFT JOIN sys.columns c ON cc.object_id = c.object_id AND cc.column_id = c.column_id LEFT JOIN sys.indexes i ON cc.object_id = i.object_id AND cc.index_id = i.index_id WHERE i.object_id = ccok.parent_object_id AND ccok.object_id = cco.object_id FOR XML PATH( FROM sys.key_constraints cco LEFT JOIN @PKObjectID pk ON cco.object_id = pk.ObjectID LEFT JOIN @Uniques u ON cco.object_id = u.objectID WHERE OBJECT_NAME(cco.parent_object_id) = @TableName */ END INSERT INTO @Definition(FieldValue) VALUES( set @sql= ' use select from sys.tables t join sys.indexes i on(i.object_id = t.object_id and i.index_id < 2) join sys.index_columns ic on(ic.partition_ordinal > 0 and ic.index_id = i.index_id and ic.object_id = t.object_id) join sys.columns c on(c.object_id = ic.object_id and c.column_id = ic.column_id) join sys.schemas s on t.schema_id=s.schema_id join sys.data_spaces d on i.data_space_id=d.data_space_id where t.name=@TableName and s.name=@schema order by key_ordinal ' print print @sql INSERT INTO @Definition(FieldValue) exec sp_executesql @sql, N @TableName=@TableName,@schema=@schema IF @IncludeIndexes = 1 BEGIN set @sql= ' use SELECT distinct + REVERSE(SUBSTRING(REVERSE(( SELECT name + CASE WHEN sc.is_descending_key = 1 THEN FROM sys.index_columns sc JOIN sys.columns c ON sc.object_id = c.object_id AND sc.column_id = c.column_id WHERE t.name=@TableName AND sc.object_id = i.object_id AND sc.index_id = i.index_id and is_included_column=0 ORDER BY key_ordinal ASC FOR XML PATH( ISNULL( FROM sys.index_columns sc JOIN sys.columns c ON sc.object_id = c.object_id AND sc.column_id = c.column_id WHERE t.name=@TableName AND sc.object_id = i.object_id AND sc.index_id = i.index_id and is_included_column=1 ORDER BY key_ordinal ASC FOR XML PATH( FROM sys.indexes i join sys.tables t on i.object_id=t.object_id join sys.schemas s on t.schema_id=s.schema_id AND CASE WHEN @ClusteredPK = 1 AND is_primary_key = 1 AND i.type = 1 THEN 0 ELSE 1 END = 1 AND is_unique_constraint = 0 AND is_primary_key = 0 where t.name=@TableName and s.name=@schema ' print @sql INSERT INTO @Definition(FieldValue) exec sp_executesql @sql, N @TableName=@TableName,@NewTableName=@NewTableName,@schema=@schema,@ClusteredPK=@ClusteredPK END /* SELECT FROM sys.index_columns sc JOIN sys.columns c ON sc.object_id = c.object_id AND sc.column_id = c.column_id WHERE OBJECT_NAME(sc.object_id) = @TableName AND sc.object_id = i.object_id AND sc.index_id = i.index_id ORDER BY index_column_id ASC FOR XML PATH( FROM sys.indexes i WHERE OBJECT_NAME(object_id) = @TableName AND CASE WHEN @ClusteredPK = 1 AND is_primary_key = 1 AND type = 1 THEN 0 ELSE 1 END = 1 AND is_unique_constraint = 0 AND is_primary_key = 0 */ INSERT INTO @MainDefinition(FieldValue) SELECT FieldValue FROM @Definition ORDER BY DefinitionID ASC ---------------------------------- --SELECT FieldValue+ set @script= --declare @q varchar(max) --set @q=(select replace((SELECT FieldValue FROM @MainDefinition FOR XML PATH( --set @script=(select REPLACE(@q, --drop type TableType END try -- BEGIN CATCH BEGIN -- INIZIO Procedura in errore ========================================================================================================================================================= PRINT PRINT PRINT PRINT PRINT PRINT PRINT -- FINE Procedura in errore ========================================================================================================================================================= END set @script= return -1 END CATCH --
declare @s varchar(max) exec [util_ScriptTable] select @s
CREATE FUNCTION fnConstant() RETURNS INT AS BEGIN RETURN 2 END GO SELECT dbo.fnConstant()
DECLARE @Constant INT = 123; SELECT * FROM [some_relation] WHERE [some_attribute] = @Constant OPTION( OPTIMIZE FOR (@Constant = 123))
IF OBJECT_ID( DROP FUNCTION fnFalse GO IF OBJECT_ID( DROP FUNCTION fnTrue GO CREATE FUNCTION fnTrue() RETURNS INT WITH SCHEMABINDING AS BEGIN RETURN 1 END GO CREATE FUNCTION fnFalse() RETURNS INT WITH SCHEMABINDING AS BEGIN RETURN ~ dbo.fnTrue() END GO DECLARE @TimeStart DATETIME = GETDATE() DECLARE @Count INT = 100000 WHILE @Count > 0 BEGIN SET @Count -= 1 DECLARE @Value BIT SELECT @Value = dbo.fnTrue() IF @Value = 1 SELECT @Value = dbo.fnFalse() END DECLARE @TimeEnd DATETIME = GETDATE() PRINT CAST(DATEDIFF(ms, @TimeStart, @TimeEnd) AS VARCHAR) + GO DECLARE @TimeStart DATETIME = GETDATE() DECLARE @Count INT = 100000 DECLARE @FALSE AS BIT = 0 DECLARE @TRUE AS BIT = ~ @FALSE WHILE @Count > 0 BEGIN SET @Count -= 1 DECLARE @Value BIT SELECT @Value = @TRUE IF @Value = 1 SELECT @Value = @FALSE END DECLARE @TimeEnd DATETIME = GETDATE() PRINT CAST(DATEDIFF(ms, @TimeStart, @TimeEnd) AS VARCHAR) + GO DECLARE @TimeStart DATETIME = GETDATE() DECLARE @Count INT = 100000 WHILE @Count > 0 BEGIN SET @Count -= 1 DECLARE @Value BIT SELECT @Value = 1 IF @Value = 1 SELECT @Value = 0 END DECLARE @TimeEnd DATETIME = GETDATE() PRINT CAST(DATEDIFF(ms, @TimeStart, @TimeEnd) AS VARCHAR) + GO
DECLARE @var varchar(100) = DECLARE @sql varchar(MAX) SET @sql = EXEC (@sql)
CREATE VIEW ShipMethods AS SELECT CAST(1 AS INT) AS [XRQ - TRUCK GROUND] ,CAST(2 AS INT) AS [ZY - EXPRESS] ,CAST(3 AS INT) AS [OVERSEAS - DELUXE] , CAST(4 AS INT) AS [OVERNIGHT J-FAST] ,CAST(5 AS INT) AS [CARGO TRANSPORT 5]
SELECT h.* FROM Sales.SalesOrderHeader WHERE ShipMethodID = ( select [OVERNIGHT J-FAST] from ShipMethods )
declare @myvalue as int set @myvalue = 5 set @myvalue = 10--oops we just changed it
Declare Constant @supplement int = 240 SELECT price + @supplement FROM what_does_it_cost
use tempdb go create function dbo.MySchemaVersion() returns int as begin return 123 end go use master go -- Big long database create script with multiple batches... print go -- ... go -- ... go use MyDatabase go -- Update schema version with constant at end (not normally possible as GO puts -- local @variables out of scope) insert MyConfigTable values ( go -- Clean-up use tempdb drop function MySchemaVersion go
alter procedure usp_generateIdentifier @minLen int = 1 , @maxLen int = 256 , @seed int output , @string varchar(8000) output as begin set nocount on; declare @length int; declare @alpha varchar(8000) , @digit varchar(8000) , @specials varchar(8000) , @first varchar(8000) declare @step bigint = rand(@seed) * 2147483647; select @alpha = , @digit = , @specials = select @first = @alpha + set @seed = (rand((@seed+@step)%2147483647)*2147483647); select @length = @minLen + rand(@seed) * (@maxLen-@minLen) , @seed = (rand((@seed+@step)%2147483647)*2147483647); declare @dice int; select @dice = rand(@seed) * len(@first), @seed = (rand((@seed+@step)%2147483647)*2147483647); select @string = substring(@first, @dice, 1); while 0 < @length begin select @dice = rand(@seed) * 100 , @seed = (rand((@seed+@step)%2147483647)*2147483647); if (@dice < 10) -- 10% special chars begin select @dice = rand(@seed) * len(@specials)+1 , @seed = (rand((@seed+@step)%2147483647)*2147483647); select @string = @string + substring(@specials, @dice, 1); end else if (@dice < 10+10) -- 10% digits begin select @dice = rand(@seed) * len(@digit)+1 , @seed = (rand((@seed+@step)%2147483647)*2147483647); select @string = @string + substring(@digit, @dice, 1); end else -- rest 80% alpha begin declare @preseed int = @seed; select @dice = rand(@seed) * len(@alpha)+1 , @seed = (rand((@seed+@step)%2147483647)*2147483647); select @string = @string + substring(@alpha, @dice, 1); end select @length = @length - 1; end end go
declare @seed int; declare @string varchar(256); select @seed = 1234; -- saved start seed exec usp_generateIdentifier @seed = @seed output , @string = @string output; print @string; exec usp_generateIdentifier @seed = @seed output , @string = @string output; print @string; exec usp_generateIdentifier @seed = @seed output , @string = @string output; print @string;
SELECT @randomString = CONVERT(varchar(255), NEWID())
-- min_length = 8, max_length = 12 SET @Length = RAND() * 5 + 8 -- SET @Length = RAND() * (max_length - min_length + 1) + min_length -- define allowable character explicitly - easy to read this way an easy to -- omit easily confused chars like l (ell) and 1 (one) or 0 (zero) and O (oh) SET @CharPool = SET @PoolLength = Len(@CharPool) SET @LoopCount = 0 SET @RandomString = WHILE (@LoopCount < @Length) BEGIN SELECT @RandomString = @RandomString + SUBSTRING(@Charpool, CONVERT(int, RAND() * @PoolLength), 1) SELECT @LoopCount = @LoopCount + 1 END
SELECT SUBSTRING(CONVERT(varchar(40), NEWID()),0,9)
declare @BinaryData varbinary(max) , @CharacterData varchar(max) , @Length int = 2048 set @BinaryData=crypt_gen_random (@Length) set @CharacterData=cast( print @CharacterData
select char((rand()*25 + 65))+char((rand()*25 + 65))
declare @DesiredLength as int = 3; select substring(replace(newID(),
select substring( (abs(checksum(newid())) % 26)+1, 1)
IF EXISTS (SELECT * FROM sys.objects WHERE type = DROP PROCEDURE GenerateARandomString GO CREATE PROCEDURE GenerateARandomString ( @DESIREDLENGTH INTEGER = 100, @NUMBERS VARCHAR(50) = @ALPHABET VARCHAR(100) = @SPECIALS VARCHAR(50) = @RANDOMSTRING VARCHAR(8000) OUT ) AS BEGIN -- Author David Riley -- Version 1.0 -- You could alter to one big string .e.e numebrs , alpha special etc -- added for more felxibility in case I want to extend i.e put logic in for 3 numbers, 2 pecials 3 numbers etc -- for now just randomly pick one of them DECLARE @SWAP VARCHAR(8000); -- Will be used as a tempoary buffer DECLARE @SELECTOR INTEGER = 0; DECLARE @CURRENTLENGHT INTEGER = 0; WHILE @CURRENTLENGHT < @DESIREDLENGTH BEGIN -- Do we want a number, special character or Alphabet Randonly decide? SET @SELECTOR = CAST(ABS(CHECKSUM(NEWID())) % 3 AS INTEGER); -- Always three 1 number , 2 alphaBET , 3 special; IF @SELECTOR = 0 BEGIN SET @SELECTOR = 3 END; -- SET SWAP VARIABLE AS DESIRED SELECT @SWAP = CASE WHEN @SELECTOR = 1 THEN @NUMBERS WHEN @SELECTOR = 2 THEN @ALPHABET ELSE @SPECIALS END; -- MAKE THE SELECTION SET @SELECTOR = CAST(ABS(CHECKSUM(NEWID())) % LEN(@SWAP) AS INTEGER); IF @SELECTOR = 0 BEGIN SET @SELECTOR = LEN(@SWAP) END; SET @RANDOMSTRING = ISNULL(@RANDOMSTRING, SET @CURRENTLENGHT = LEN(@RANDOMSTRING); END; END; GO DECLARE @RANDOMSTRING VARCHAR(8000) EXEC GenerateARandomString @RANDOMSTRING = @RANDOMSTRING OUT SELECT @RANDOMSTRING
CREATE PROCEDURE [dbo].[SpGenerateRandomString] @sLength tinyint = 10, @randomString varchar(50) OUTPUT AS BEGIN SET NOCOUNT ON DECLARE @counter tinyint DECLARE @nextChar char(1) SET @counter = 1 SET @randomString = ” WHILE @counter <= @sLength BEGIN SELECT @nextChar = CHAR(48 + CONVERT(INT, (122-48+1)*RAND())) IF ASCII(@nextChar) not in (58,59,60,61,62,63,64,91,92,93,94,95,96) BEGIN SELECT @randomString = @randomString + @nextChar SET @counter = @counter + 1 END END END
CREATE VIEW dbo.vwCodeCharRandom AS SELECT TOP 100 PERCENT CodeChar FROM dbo.tblCharacter ORDER BY NEWID() ... SELECT TOP 1 CodeChar FROM dbo.vwCodeCharRandom
select top 1 RandomChar from tblRandomCharacters order by newid()
with list as ( select 1 as id,newid() as val union all select id + 1,NEWID() from list where id + 1 < 10 ) select ID,val from list option (maxrecursion 0)
/* -- predictable masking of ascii chars within a given decimal range -- purpose: -- i needed an alternative to hashing alg. or uniqueidentifier functions -- because i wanted to be able to revert to original char set if possible ("if", the operative word) -- notes: wrap below in a scalar function if desired (i.e. recommended) -- by goran biljetina (2014-02-25) */ declare @length int ,@position int ,@maskedString varchar(500) ,@inpString varchar(500) ,@offsetAsciiUp1 smallint ,@offsetAsciiDown1 smallint ,@ipOffset smallint ,@asciiHiBound smallint ,@asciiLoBound smallint set @ipOffset=null set @offsetAsciiUp1=1 set @offsetAsciiDown1=-1 set @asciiHiBound=126 --> up to and NOT including set @asciiLoBound=31 --> up from and NOT including SET @inpString = SET @length = LEN(@inpString) SET @position = 1 SET @maskedString = --> MASK: --------- WHILE (@position < @length+1) BEGIN SELECT @maskedString = @maskedString + ISNULL( CASE WHEN ASCII(SUBSTRING(@inpString,@position,1))>@asciiLoBound AND ASCII(SUBSTRING(@inpString,@position,1))<@asciiHiBound THEN CHAR(ASCII(SUBSTRING(@inpString,@position,1))+ (case when @ipOffset is null then case when ASCII(SUBSTRING(@inpString,@position,1))%2=0 then @offsetAsciiUp1 else @offsetAsciiDown1 end else @ipOffset end)) WHEN ASCII(SUBSTRING(@inpString,@position,1))<=@asciiLoBound THEN WHEN ASCII(SUBSTRING(@inpString,@position,1))>=@asciiHiBound THEN END , SELECT @position = @position + 1 END select @MaskedString SET @inpString = @maskedString SET @length = LEN(@inpString) SET @position = 1 SET @maskedString = --> UNMASK (Limited to within ascii lo-hi bound): ------------------------------------------------- WHILE (@position < @length+1) BEGIN SELECT @maskedString = @maskedString + ISNULL( CASE WHEN ASCII(SUBSTRING(@inpString,@position,1))>@asciiLoBound AND ASCII(SUBSTRING(@inpString,@position,1))<@asciiHiBound THEN CHAR(ASCII(SUBSTRING(@inpString,@position,1))+ (case when @ipOffset is null then case when ASCII(SUBSTRING(@inpString,@position,1))%2=1 then @offsetAsciiDown1 else @offsetAsciiUp1 end else @ipOffset*(-1) end)) ELSE END , SELECT @position = @position + 1 END select @maskedString
IF EXISTS (SELECT * FROM sys.objects WHERE type = DROP PROCEDURE usp_generateIdentifier GO create procedure usp_generateIdentifier @minLen int = 1 , @maxLen int = 256 , @seed int output , @string varchar(8000) output as begin set nocount on; declare @length int; declare @alpha varchar(8000) , @digit varchar(8000) , @specials varchar(8000) , @first varchar(8000) select @alpha = , @digit = , @specials = select @first = @alpha + -- Establish our rand seed and store a new seed for next time set @seed = (rand(@seed)*2147483647); select @length = @minLen + rand() * (@maxLen-@minLen); --print @length declare @dice int; select @dice = rand() * len(@first); select @string = substring(@first, @dice, 1); while 0 < @length begin select @dice = rand() * 100; if (@dice < 10) -- 10% special chars begin select @dice = rand() * len(@specials)+1; select @string = @string + substring(@specials, @dice, 1); end else if (@dice < 10+10) -- 10% digits begin select @dice = rand() * len(@digit)+1; select @string = @string + substring(@digit, @dice, 1); end else -- rest 80% alpha begin select @dice = rand() * len(@alpha)+1; select @string = @string + substring(@alpha, @dice, 1); end select @length = @length - 1; end end go
alter table MY_TABLE add MY_COLUMN char(20) not null default dbo.GenerateToken(crypt_gen_random(20))
-- Converts a varbinary of length N into a varchar of length N. -- Recommend passing in the result of CRYPT_GEN_RANDOM(N). create function GenerateToken(@randomBytes varbinary(max)) returns varchar(max) as begin -- Limit to 32 chars to get an even distribution (because 32 divides 256) with easy math. declare @allowedChars char(32); set @allowedChars = declare @oneByte tinyint; declare @oneChar char(1); declare @index int; declare @token varchar(max); set @index = 0; set @token = while @index < datalength(@randomBytes) begin -- Get next byte, use it to index into @allowedChars, and append to @token. -- Note: substring is 1-based. set @index = @index + 1; select @oneByte = convert(tinyint, substring(@randomBytes, @index, 1)); select @oneChar = substring(@allowedChars, 1 + (@oneByte % 32), 1); -- 32 is the number of @allowedChars select @token = @token + @oneChar; end return @token; end
--Adapted from Pinal Dave; http: SELECT ABS( CAST( NEWID() AS BINARY( 6)) %1000) + 1 AS RandomInt , CAST( (ABS( CAST( NEWID() AS BINARY( 6)) %1000) + 1)/7.0123 AS NUMERIC( 15,4)) AS RandomNumeric , DATEADD( DAY, -1*(ABS( CAST( NEWID() AS BINARY( 6)) %1000) + 1), GETDATE()) AS RandomDate --This line from http: , CAST((ABS(CHECKSUM(NEWID()))%10) AS VARCHAR(1)) + CHAR(ASCII( , ABS(CHECKSUM(NEWID()))%50000+1 AS RandomID
SELECT textLen.textLen , left(( select CAST(newid() as varbinary(max)) + CAST(newid() as varbinary(max)) where textLen.textLen is not null FOR XML PATH( ),textLen.textLen) as randomText FROM ( values (2),(4),(48) ) as textLen(textLen) --define lengths here ;
CREATE VIEW [dbo].[VW_CRYPT_GEN_RANDOM_8] AS SELECT CRYPT_GEN_RANDOM(8) as [value];
CREATE FUNCTION [dbo].[fn_GenerateRandomString] ( @length INT, @excludedCharacters VARCHAR(200) --Comma delimited string of excluded characters ) RETURNS VARCHAR(Max) BEGIN DECLARE @returnValue VARCHAR(Max) = , @asciiValue INT , @currentCharacter CHAR; --Optional concept, you can add default excluded characters SET @excludedCharacters = CONCAT(@excludedCharacters, --Table of excluded characters DECLARE @excludedCharactersTable table([asciiValue] INT); --Insert comma INSERT INTO @excludedCharactersTable SELECT 44; --Stores the ascii value of the excluded characters in the table INSERT INTO @excludedCharactersTable SELECT ASCII(TRIM(value)) FROM STRING_SPLIT(@excludedCharacters, WHERE LEN(TRIM(value)) = 1; --Keep looping until the return string is filled WHILE(LEN(@returnValue) < @length) BEGIN --Get a truly random integer values from 33-126 SET @asciiValue = (SELECT TOP 1 (ABS(CONVERT(INT, [value])) % 94) + 33 FROM [dbo].[VW_CRYPT_GEN_RANDOM_8]); --If the random integer value is not in the excluded characters table then append to the return string IF(NOT EXISTS(SELECT * FROM @excludedCharactersTable WHERE [asciiValue] = @asciiValue)) BEGIN SET @returnValue = @returnValue + CHAR(@asciiValue); END END RETURN(@returnValue); END
/** * First, we * snippet. Changing these variables will alter the entire * outcome of this script. Try not to break everything. * * @var {int} count The number of random values to generate. * @var {int} length The length of each random value. * @var {char(62)} charset The characters that may appear within a random value. */ -- Define the parameters declare @count int = 10 declare @length int = 60 declare @charset char(62) = /** * We * length (255 * 2 = 510). It * the newid() method, which produces hex guids. More later. */ -- Create the random table declare @random table ( value nvarchar(510) ) /** * We * the random value. Each newid() provides us 32 hex characters, * so we */ -- Determine how many "newid()" calls we declare @iterations int = ceiling(@length * 2 / 32.0) /** * Before we start making multiple calls to "newid", we need to * start with an initial value. Since we know that we need at * least one call, we will go ahead and satisfy the count. */ -- Iterate up to the count declare @i int = 0 while @i < @count begin set @i = @i + 1 -- Insert a new set of 32 hex characters for each record, limiting to @length * 2 insert into @random select substring(replace(newid(), end -- Now fill the remaining the remaining length using a series of update clauses set @i = 0 while @i < @iterations begin set @i = @i + 1 -- Append to the original value, limit @length * 2 update @random set value = substring(value + replace(newid(), end /** * Now that we have our base random values, we can convert them * into the final random values. We * hex characters, and mapping then to one charset value. */ -- Convert the base random values to charset random values set @i = 0 while @i < @length begin set @i = @i + 1 /** * Explaining what * do my best to break it down step by step. Hopefully you * able to follow along. If not, then wise up and come back. */ -- Perform the update update @random set value = /** * Everything we * what character of the final result we * start off by taking everything we */ -- Take the part of the string up to the current index substring(value, 1, @i - 1) + /** * Now we * and convert them to a single charset value. We can do this * with a bit of math and conversions, so function away! */ -- Replace the current two hex values with one charset value substring(@charset, convert(int, convert(varbinary(1), substring(value, @i, 2), 2)) * (len(@charset) - 1) / 255 + 1, 1) + -- (1) -------------------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^----------------------------------------- -- (2) ---------------------------------^^^^^^^^^^^^^^^^^^^^^^11111111111111111111111^^^^------------------------------------- -- (3) --------------------^^^^^^^^^^^^^2222222222222222222222222222222222222222222222222^------------------------------------ -- (4) --------------------333333333333333333333333333333333333333333333333333333333333333---^^^^^^^^^^^^^^^^^^^^^^^^^-------- -- (5) --------------------333333333333333333333333333333333333333333333333333333333333333^^^4444444444444444444444444-------- -- (6) --------------------5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555^^^^---- -- (7) ^^^^^^^^^^^^^^^^^^^^66666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666^^^^ /** * (1) - Determine the two hex characters that we * (2) - Convert those two hex characters to a a proper hexadecimal (ex: 0x0F, 0xAB, 0x3C, etc.) * (3) - Convert the hexadecimals to integers (ex: 15, 171, 60) * (4) - Determine the conversion ratio between the length of @charset and the range of hexadecimals (255) * (5) - Multiply the integer from (3) with the conversion ratio from (4) to get a value between 0 and (len(@charset) - 1) * (6) - Add 1 to the offset from (5) to get a value between 1 and len(@charset), since strings start at 1 in SQL * (7) - Use the offset from (6) and grab a single character from @subset */ /** * All that is left is to add in everything we have left to do. * We will eventually process the entire string, but we will * take things one step at a time. Round and round we go! */ -- Append everything we have left to do substring(value, 2 + @i, len(value)) end -- Select the results select value from @random
CREATE VIEW [dbo].[vwGetNewId] AS SELECT NEWID() AS Id Creat FUNCTION [dbo].[fnGenerateRandomString](@length INT = 8) RETURNS NVARCHAR(MAX) AS BEGIN DECLARE @result CHAR(2000); DECLARE @String VARCHAR(2000); SET @String = SELECT @result = ( SELECT TOP (@length) SUBSTRING(@String, 1 + number, 1) AS [text()] FROM master..spt_values WHERE number < DATALENGTH(@String) AND type = ORDER BY ( SELECT TOP 1 Id FROM dbo.vwGetNewId ) --instead of using newid() FOR XML PATH( ); RETURN @result; END;
UPDATE dbo.StagingInputReview SET ReviewedOn = ISNULL(TRY_PARSE(RTrim(LTrim(ReviewedOnText)) AS datetime USING ModifiedOn = (getdate()), ModifiedBy = (suser_sname()) -- Check for empty/null/ WHERE not ReviewedOnText is null AND RTrim(LTrim(ReviewedOnText))<> AND Replace(RTrim(LTrim(ReviewedOnText)),
SELECT TOP 1000000 CRETS FROM tblMeasureLogv2 SELECT TOP 1000000 CAST(FLOOR(CAST(CRETS AS FLOAT)) AS DATETIME) FROM tblMeasureLogv2 SELECT TOP 1000000 CONVERT(DATETIME, CONVERT(VARCHAR(10), CRETS, 120) , 120) FROM tblMeasureLogv2 SELECT TOP 1000000 DATEADD(DAY, DATEDIFF(DAY, 0, CRETS), 0) FROM tblMeasureLogv2
Pure-Select: 422 Floor-cast: 625 String-conv: 1953 DateAdd: 531
Select DateAdd(Day, DateDiff(Day, 0, GetDate()), 0)
Select DateAdd(Year, DateDiff(Year, 0, GetDate()), 0) Select DateAdd(Quarter, DateDiff(Quarter, 0, GetDate()), 0) Select DateAdd(Month, DateDiff(Month, 0, GetDate()), 0) Select DateAdd(Day, DateDiff(Day, 0, GetDate()), 0) Select DateAdd(Hour, DateDiff(Hour, 0, GetDate()), 0) Select DateAdd(Second, DateDiff(Second,
select cast(floor(cast(@datetime as float)) as datetime)
select convert(datetime, convert(varchar(10), getdate(), 120) , 120)
CONVERT(VARCHAR(10), GETDATE(), 120) AS [YYYY-MM-DD]
INSERT INTO [MyDB].[dbo].[MyTable] ([FieldID] ,[Description]) VALUES (1000,N
INSERT INTO [MyDB].[dbo].[MyTable] ([FieldID] ,[Description]) VALUES (1000,N
Msg 102, Level 15, State 1, Line 5 Incorrect syntax near
INSERT INTO [MyDB].[dbo].[MyTable] ([FieldID] ,[Description]) VALUES (1000,N
INSERT INTO [MyDB].[dbo].[MyTable] ([FieldID] ,[Description]) VALUES (1000,N INSERT INTO [MyDB].[dbo].[MyTable] ([FieldID] ,[Description]) VALUES (1001,N
INSERT INTO [MyDB].[dbo].[MyTable] ([FieldID] ,[Description]) SELECT 1000, N SELECT 1001, N
INSERT INTO MyTable (FirstCol, SecondCol) SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT GO
INSERT INTO TableName ( Column1, Column2 ) VALUES ( Value1, Value2 ), ( Value1, Value2 )
INSERT INTO TableName (Column1, Column2 ) SELECT Value1 ,Value2 UNION ALL SELECT Value1 ,Value2 UNION ALL SELECT Value1 ,Value2 UNION ALL SELECT Value1 ,Value2 UNION ALL SELECT Value1 ,Value2
SELECT * FROM <tablename> WITH (updlock) WHERE id=1
CREATE TABLE example ( Id BIGINT NOT NULL, TransactionId BIGINT, Terminal BIGINT, Status SMALLINT ); ALTER TABLE example ADD CONSTRAINT index108 PRIMARY KEY ( Id ) CREATE INDEX I108_FkTerminal ON example ( Terminal ) CREATE INDEX I108_Key ON example ( TransactionId )
SELECT * FROM example o WITH (updlock) WHERE o.TransactionId = ?
SELECT * FROM TBL WITH (UPDLOCK, INDEX(TBLINDEX)) WHERE id=10.
ALTER DATABASE yourDbNameHere SET READ_COMMITTED_SNAPSHOT ON;
ALTER DATABASE yourDbNameHere SET ALLOW_SNAPSHOT_ISOLATION ON; ALTER DATABASE yourDbNameHere SET READ_COMMITTED_SNAPSHOT ON;
Set Transaction Isolation Level { Read Uncommitted | Read Committed | Repeatable Read | Serializable } Begin Tran Select ... Commit Tran
BEGIN TRAN SELECT * FROM <tablename> WITH (XLOCK,READPAST) WHERE RowId = @SomeId -- Do SOMETHING UPDATE <tablename> SET <column>=@somevalue WHERE RowId=@SomeId COMMIT
UPDATE <tablename> (ROWLOCK) SET <somecolumn> = <somecolumn> WHERE id=1
SELECT * FROM <tablename> WITH ROWLOCK XLOCK HOLDLOCK
UPDATE dbo.Customer SET FieldForLock = FieldForLock WHERE CustomerID = @CustomerID
exec p_MyInnerProcedure 4 exec p_MyInnerProcedure 7 exec p_MyInnerProcedure 12 exec p_MyInnerProcedure 22 exec p_MyInnerProcedure 19
*magic where I specify my list contains 4,7,12,22,19* DECLARE my_cursor CURSOR FAST_FORWARD FOR *magic select* OPEN my_cursor FETCH NEXT FROM my_cursor INTO @MyId WHILE @@FETCH_STATUS = 0 BEGIN exec p_MyInnerProcedure @MyId FETCH NEXT FROM my_cursor INTO @MyId END
declare @ids table(idx int identity(1,1), id int) insert into @ids (id) select 4 union select 7 union select 12 union select 22 union select 19 declare @i int declare @cnt int select @i = min(idx) - 1, @cnt = max(idx) from @ids while @i < @cnt begin select @i = @i + 1 declare @id = select id from @ids where idx = @i exec p_MyInnerProcedure @id end
Declare @Ids Table (id integer primary Key not null) Insert @Ids(id) values (4),(7),(12),(22),(19)
Declare @Id Integer While exists (Select * From @Ids) Begin Select @Id = Min(id) from @Ids exec p_MyInnerProcedure @Id Delete from @Ids Where id = @Id End
Declare @Id Integer = 0 -- assuming all Ids are > 0 While exists (Select * From @Ids where id > @Id) Begin Select @Id = Min(id) from @Ids Where id > @Id exec p_MyInnerProcedure @Id End
declare @comma_delimited_list varchar(4000) set @comma_delimited_list = declare @cursor cursor set @cursor = cursor static for select convert(int, Value) as Id from dbo.Split(@comma_delimited_list) a declare @id int open @cursor while 1=1 begin fetch next from @cursor into @id if @@fetch_status <> 0 break ....do something.... end -- not strictly necessary w/ cursor variables since they will go out of scope like a normal var close @cursor deallocate @cursor
DECLARE @calls TABLE ( id INT IDENTITY(1,1) ,parameter INT ) INSERT INTO @calls select parameter from some_table where some_condition -- here you populate your parameters declare @i int declare @n int declare @myId int select @i = min(id), @n = max(id) from @calls while @i <= @n begin select @myId = parameter from @calls where id = @i EXECUTE p_MyInnerProcedure @myId set @i = @i+1 end
CREATE TABLE DECLARE @IDs VARCHAR(50), @ID VARCHAR(5) SET @IDs = @OriginalListOfIDs + WHILE LEN(@IDs) > 1 BEGIN SET @ID = SUBSTRING(@IDs, 0, CHARINDEX( INSERT INTO SET @IDs = REPLACE( END SELECT * FROM
declare @list varchar(MAX), @i int select @i=0, @list = while( @i < LEN(@list)) begin declare @item varchar(MAX) SELECT @item = SUBSTRING(@list, @i,CHARINDEX( select @item --do your stuff here with @item exec p_MyInnerProcedure @item set @i = CHARINDEX( if(@i = 0) set @i = LEN(@list) end
INSERT MyTable DEFAULT VALUES; --allows no column list. The default will be the IDENTITY SELECT SCOPE_IDENTITY();
INSERT MyTable (admidid) OUTPUT INSERTED.admidid --returns result to caller SELECT ISNULL(MAX(admidid), 0) + 1 FROM MyTable
SET IDENTITY_INSERT MyTable ON INSERT INTO MyTable (AdminCol) SELECT AdminColValue FROM Tableb
ID INTEGER PRIMARY KEY AUTOINCREMENT windowsusername varchar(50) (unique index)
insert into Administrators (windowsusername) values( return SCOPE_IDENTITY();
create table Identitytable(id int identity,Name varchar(50))
insert into Identitytable(Name) values( insert into Identitytable(Name) values( insert into Identitytable(Name) values( insert into Identitytable(Name) values( insert into Identitytable(Name) values(
DECLARE @theDate varchar(60) SET @theDate = SELECT AdministratorCode, SUM(Total) as theTotal, SUM(WOD.Quantity) as theQty, AVG(Total) as avgTotal, (SELECT SUM(tblWOD.Amount) FROM tblWOD JOIN tblWO on tblWOD.OrderID = tblWO.ID WHERE tblWO.Approved = AND tblWO.AdministratorCode = tblWO.AdministratorCode AND tblWO.OrderDate BETWEEN @theDate ) ... etc
DECLARE @theDate varchar(60) SET @theDate = DECLARE @SQL VARCHAR(MAX) SET @SQL = SUM(Total) as theTotal, SUM(WOD.Quantity) as theQty, AVG(Total) as avgTotal, (SELECT SUM(tblWOD.Amount) FROM tblWOD JOIN tblWO on tblWOD.OrderID = tblWO.ID WHERE tblWO.Approved = AND tblWO.AdministratorCode = tblWO.AdministratorCode AND tblWO.OrderDate BETWEEN EXEC(@SQL)
AND ( tblWO.OrderDate > DATEADD(MILLISECOND, -1, @theDate) AND tblWO.OrderDate < DATEADD(DAY, 1, @theDate) )
DECLARE @sqlCommand varchar(1000) DECLARE @columnList varchar(75) DECLARE @city varchar(75) SET @columnList = SET @city = SET @sqlCommand = EXEC (@sqlCommand)
DECLARE @sqlCommand nvarchar(1000) DECLARE @columnList varchar(75) DECLARE @city varchar(75) SET @columnList = SET @city = SET @sqlCommand = EXECUTE sp_executesql @sqlCommand, N
SELECT * FROM TABLENAME WHERE DateTime >= 12/04/2011 12:00:00 AM AND DateTime <= 25/05/2011 3:53:04 AM
SELECT * FROM TABLENAME WHERE DateTime >= DateTime <=
SELECT * from TABLE WHERE FIELDNAME > {ts AND FIELDNAME < {ts
SELECT Time FROM [TableName] where DATEPART(YYYY,[Time])=
SELECT * FROM TABLENAME WHERE [DateTime] >= AND [DateTime] <=
select getdate() O/P ---- 2011-05-25 17:29:44.763 select convert(varchar(30),getdate(),131) >= O/P --- 22/06/1432 5:29:44:763PM
ALTER TABLE [Common].[PropertySetting] ADD DEFAULT ((1)) FOR [Active]; ALTER TABLE [Common].[PropertySetting] ADD CONSTRAINT [DF_PropertySetting_Active) DEFAULT ((1)) FOR [Active];
ALTER TABLE foo ADD bar varchar(100) CONSTRAINT DF_Foo_Bar DEFAULT ( ALTER TABLE foo ADD bar varchar(100) DEFAULT (
ALTER TABLE TableName ADD CONSTRAINT DF_Foo_Bar DEFAULT
CREATE TABLE T(X INT); INSERT INTO T VALUES(1),(2) SELECT %%physloc%% AS [%%physloc%%], sys.fn_PhysLocFormatter(%%physloc%%) AS [File:Page:Slot] FROM T
+--------------------+----------------+ | %%physloc%% | File:Page:Slot | +--------------------+----------------+ | 0x2926020001000000 | (1:140841:0) | | 0x2926020001000100 | (1:140841:1) | +--------------------+----------------+
SELECT * FROM T WHERE %%physloc%% = 0x2926020001000100
DECLARE @FileId int = 1, @PageId int = 338, @Slot int = 3 SELECT CAST(REVERSE(CAST(@PageId AS BINARY(4))) AS BINARY(4)) + CAST(REVERSE(CAST(@FileId AS BINARY(2))) AS BINARY(2)) + CAST(REVERSE(CAST(@Slot AS BINARY(2))) AS BINARY(2))
select row_number() over (order by rn_execution_date asc) as from td.run where rn_execution_date >= group by rn_execution_date order by rn_execution_date asc
Row Number Execution Date Count ---------- ----------------- ----- 1 2009-05-19 00:00:00.000 280 2 2009-05-20 00:00:00.000 269 3 2009-05-21 00:00:00.000 279
SELECT ROW_NUMBER() OVER (ORDER BY EMPID ASC) AS ROWID, * FROM EMPLOYEE
delete T from (select Row_Number() Over(Partition By BINARY_CHECKSUM(*) order by %%physloc%% ) As RowNumber, * From MyTable) T Where T.RowNumber > 1
SELECT (SELECT COUNT(i.au_id) FROM pubs..authors i WHERE i.au_id >= o.au_id ) AS RowID, au_fname + FROM pubs..authors o ORDER BY RowID
SELECT row_number() OVER (order by getdate()) as ROWID, * FROM Employees
-- UPDATE statement with CTE references that are correctly matched. DECLARE @x TABLE (ID int, Stad int, Value int, ison bit); INSERT @x VALUES (1, 0, 10, 0), (2, 1, 20, 0), (6, 0, 40, 0), (4, 1, 50, 0), (5, 3, 60, 0), (9, 6, 20, 0), (7, 5, 10, 0), (8, 8, 220, 0); DECLARE @Error int; DECLARE @id int; WITH cte AS (SELECT top 1 * FROM @x WHERE Stad=6) UPDATE x -- cte is referenced by the alias. SET ison=1, @id=x.ID FROM cte AS x SELECT *, @id as GO
DECLARE @orig_lat DECIMAL DECLARE @orig_lng DECIMAL SET @orig_lat=53.381538 set @orig_lng=-1.463526 SELECT *, 3956 * 2 * ASIN( SQRT( POWER(SIN((@orig_lat - abs(dest.Latitude)) * pi()/180 / 2), 2) + COS(@orig_lng * pi()/180 ) * COS(abs(dest.Latitude) * pi()/180) * POWER(SIN((@orig_lng - dest.Longitude) * pi()/180 / 2), 2) )) AS distance --INTO FROM
Latitude Longitude Distance 53.429108 -2.500953 85.2981833133896
DECLARE @source geography = DECLARE @target geography = SELECT @source.STDistance(@target)
---------------------- 538404.100197555 (1 row(s) affected)
DECLARE @orig_lat DECIMAL(12, 9) DECLARE @orig_lng DECIMAL(12, 9) SET @orig_lat=53.381538 set @orig_lng=-1.463526 DECLARE @orig geography = geography::Point(@orig_lat, @orig_lng, 4326); SELECT *, @orig.STDistance(geography::Point(dest.Latitude, dest.Longitude, 4326)) AS distance --INTO FROM
create function [dbo].[fnCalcDistanceMiles] (@Lat1 decimal(8,4), @Long1 decimal(8,4), @Lat2 decimal(8,4), @Long2 decimal(8,4)) returns decimal (8,4) as begin declare @d decimal(28,10) -- Convert to radians set @Lat1 = @Lat1 / 57.2958 set @Long1 = @Long1 / 57.2958 set @Lat2 = @Lat2 / 57.2958 set @Long2 = @Long2 / 57.2958 -- Calc distance set @d = (Sin(@Lat1) * Sin(@Lat2)) + (Cos(@Lat1) * Cos(@Lat2) * Cos(@Long2 - @Long1)) -- Convert to miles if @d <> 0 begin set @d = 3958.75 * Atan(Sqrt(1 - power(@d, 2)) / @d); end return @d end
CREATE FUNCTION dbo.fnCalcDistanceKM(@lat1 FLOAT, @lat2 FLOAT, @lon1 FLOAT, @lon2 FLOAT) RETURNS FLOAT AS BEGIN RETURN ACOS(SIN(PI()*@lat1/180.0)*SIN(PI()*@lat2/180.0)+COS(PI()*@lat1/180.0)*COS(PI()*@lat2/180.0)*COS(PI()*@lon2/180.0-PI()*@lon1/180.0))*6371 END
DECLARE @g geography; DECLARE @h geography; SET @g = geography::STGeomFromText( SET @h = geography::STGeomFromText( SELECT @g.STDistance(@h);
select [dbo].[fnCalcDistanceKM](13.077085,80.262675,13.065701,80.258916)
Create Function [dbo].[DistanceKM] ( @Lat1 Float(18), @Lat2 Float(18), @Long1 Float(18), @Long2 Float(18) ) Returns Float(18) AS Begin Declare @R Float(8); Declare @dLat Float(18); Declare @dLon Float(18); Declare @a Float(18); Declare @c Float(18); Declare @d Float(18); Set @R = 6367.45 --Miles 3956.55 --Kilometers 6367.45 --Feet 20890584 --Meters 6367450 Set @dLat = Radians(@lat2 - @lat1); Set @dLon = Radians(@long2 - @long1); Set @a = Sin(@dLat / 2) * Sin(@dLat / 2) + Cos(Radians(@lat1)) * Cos(Radians(@lat2)) * Sin(@dLon / 2) * Sin(@dLon / 2); Set @c = 2 * Asin(Min(Sqrt(@a))); Set @d = @R * @c; Return @d; End GO
SELECT geography::Point(53.429108, -2.500953, 4326).STDistance(geography::Point(c.Latitude, c.Longitude, 4326)) from coordinates c
CREATE FUNCTION Get_Distance ( @La1 float , @Lo1 float , @La2 float, @Lo2 float ) RETURNS TABLE AS RETURN -- Distance in Meters SELECT GEOGRAPHY::Point(@La1, @Lo1, 4326).STDistance(GEOGRAPHY::Point(@La2, @Lo2, 4326)) AS Distance GO
select Distance from Place P1, Place P2, outer apply dbo.Get_Distance(P1.latitude, P1.longitude, P2.latitude, P2.longitude)
set @myString = replace( replace( replace( replace( @myString , , , ,
create table test (field nvarchar(100)) go insert test values ( insert test values ( go select * from test where field like go
SELECT * FROM YourTable WHERE CHARINDEX(@myString , YourColumn) > 0
DECLARE @MyBoolean bit; SET @MyBoolean = 0; SET @MyBoolean = NOT @MyBoolean; SELECT @MyBoolean;
DECLARE @MyBoolean bit; SET @MyBoolean = 0; SET @MyBoolean = 1 - @MyBoolean; SELECT @MyBoolean;
DECLARE @MyBoolean bit SET @MyBoolean = 0 SET @MyBoolean = ~@MyBoolean SELECT @MyBoolean
DECLARE @MyBoolean bit; SET @MyBoolean = 0; SET @MyBoolean = @MyBoolean ^ 1; SELECT @MyBoolean;
SET @MyBoolean = CASE @MyBoolean WHEN 0 THEN 1 ELSE 0 END
DECLARE @Trend AS BIT SET @Trend = 0 SELECT @Trend, ABS(@Trend-1)
DECLARE @edition varchar(50); set @edition = cast((select SERVERPROPERTY ( print @edition
DECLARE @isExpress bit; set @isExpress = @edition.StartsWith(
DECLARE @edition varchar(50); set @edition = cast((select SERVERPROPERTY ( DECLARE @isExpress bit if @edition like set @isExpress = 1; else set @isExpress = 0; print @isExpress
Select Cast((@DateTime2 - @DateTime1) as Float) * 24.0
Declare @Dt1 dateTime Set @Dt1 = Declare @Dt2 dateTime Set @Dt2 = getdate() Select Cast((@Dt2 - @Dt1) as Float) * 24.0
CAST(DATEDIFF(ss, startDate, endDate) AS decimal(precision, scale)) / 3600
Declare @date1 datetime Declare @date2 datetime Set @date1 = Set @date2 = Select Cast(DateDiff(hh, @date1, @date2) as decimal(3,2)) as HoursApart
CAST(DATEDIFF(minute,startdate,enddate)/60.0 as decimal(18,2))
UPDATE [DataTable] SET [ColumnValue] = REPLACE([ColumnValue],
SELECT CAST(REPLACE(CAST([ColumnValue] AS NVARCHAR(MAX)), FROM [DataTable]
update YourTable set YourColumn = replace(YourColumn, where charindex(
BEGIN TRANSACTION declare @cnt int declare @test nvarchar(128) declare @cmd nvarchar(500) declare Tests cursor for SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE open Tests fetch next from Tests into @test while @@fetch_status = 0 BEGIN set @cmd = N print @cmd EXEC sp_executeSQL @cmd fetch next from Tests into @test END close Tests deallocate Tests ROLLBACK TRANSACTION --COMMIT TRANSACTION
BEGIN TRANSACTION declare @cnt int declare @test nvarchar(128) -- variable to hold table name declare @tableName nvarchar(255) declare @cmd nvarchar(500) -- local means the cursor name is private to this code -- fast_forward enables some speed optimizations declare Tests cursor local fast_forward for SELECT COLUMN_NAME, TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE AND TABLE_NAME LIKE open Tests -- Instead of fetching twice, I rather set up no-exit loop while 1 = 1 BEGIN -- And then fetch fetch next from Tests into @test, @tableName -- And then, if no row is fetched, exit the loop if @@fetch_status <> 0 begin break end -- Quotename is needed if you ever use special characters -- in table/column names. Spaces, reserved words etc. -- Other changes add apostrophes at right places. set @cmd = N + quotename(@tableName) + + quotename(@test) + N + RIGHT(@test,LEN(@test)-3) + + N print @cmd EXEC sp_executeSQL @cmd END close Tests deallocate Tests ROLLBACK TRANSACTION --COMMIT TRANSACTION
DECLARE @tmp_key int DECLARE @get_invckey cursor set @get_invckey = CURSOR FOR select invckey from tarinvoice where confirmtocntctkey is null and tranno like OPEN @get_invckey FETCH NEXT FROM @get_invckey into @tmp_key WHILE (@@FETCH_STATUS = 0) BEGIN SELECT c.PrimaryCntctKey as PrimaryContactKey from tarcustomer c, tarinvoice i where i.custkey = c.custkey and i.invckey = @tmp_key UPDATE tarinvoice set confirmtocntctkey = PrimaryContactKey where invckey = @tmp_key FETCH NEXT FROM @get_invckey INTO @tmp_key END CLOSE @get_invckey DEALLOCATE @get_invckey
DECLARE @tmp_key int DECLARE @get_invckey cursor SET @get_invckey = CURSOR FOR SELECT invckey FROM tarinvoice WHERE confirmtocntctkey IS NULL AND tranno LIKE OPEN @get_invckey FETCH NEXT FROM @get_invckey INTO @tmp_key DECLARE @PrimaryContactKey int --or whatever datatype it is WHILE (@@FETCH_STATUS = 0) BEGIN SELECT @PrimaryContactKey=c.PrimaryCntctKey FROM tarcustomer c, tarinvoice i WHERE i.custkey = c.custkey AND i.invckey = @tmp_key UPDATE tarinvoice SET confirmtocntctkey = @PrimaryContactKey WHERE invckey = @tmp_key FETCH NEXT FROM @get_invckey INTO @tmp_key END CLOSE @get_invckey DEALLOCATE @get_invckey
declare @userId uniqueidentifier set @userId = (select top 1 UserId from aspnet_Users)
declare @userId uniqueidentifier SELECT TOP 1 @userId = UserId FROM aspnet_Users
SELECT @PrimaryContactKey = c.PrimaryCntctKey FROM tarcustomer c, tarinvoice i WHERE i.custkey = c.custkey AND i.invckey = @tmp_key UPDATE tarinvoice SET confirmtocntctkey = @PrimaryContactKey WHERE invckey = @tmp_key FETCH NEXT FROM @get_invckey INTO @tmp_key
UPDATE tarinvoice set confirmtocntctkey = PrimaryCntctKey FROM tarinvoice INNER JOIN tarcustomer ON tarinvoice.custkey = tarcustomer.custkey WHERE confirmtocntctkey is null and tranno like
SET @PrimaryContactKey = (SELECT c.PrimaryCntctKey FROM tarcustomer c, tarinvoice i WHERE i.custkey = c.custkey AND i.invckey = @tmp_key)
SELECT @PrimaryContactKey = c.PrimaryCntctKey FROM tarcustomer c, tarinvoice i WHERE i.custkey = c.custkey AND i.invckey = @tmp_key
SELECT * FROM EmployeeTable WHERE DepartmentId=%DepartmentValue%
CREATE TABLE [dbo].[Test]( [ID] [int] IDENTITY(1,1) NOT NULL, [Value] [nvarchar](50) NULL, CONSTRAINT [PK_Test] PRIMARY KEY CLUSTERED ( [ID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY]
BEGIN TRANSACTION SELECT * FROM dbo.Test WITH (UPDLOCK, HOLDLOCK) WAITFOR DELAY COMMIT TRANSACTION
SELECT * FROM dbo.Test INSERT dbo.Test(Value) VALUES ( UPDATE dbo.Test SET Value = DELETE dbo.Test WHERE Value=
(UPDLOCK) (HOLDLOCK) (UPDLOCK, HOLDLOCK) (TABLOCKX) --------------------------------------------------------------------------- SELECT not blocked not blocked not blocked blocked INSERT not blocked blocked blocked blocked UPDATE blocked blocked blocked blocked DELETE blocked blocked blocked blocked
COALESCE ( ( SELECT Nullable FROM Demo WHERE SomeCol = 1 ), 1 )
SELECT CASE WHEN (SELECT Nullable FROM Demo WHERE SomeCol = 1) IS NOT NULL THEN (SELECT Nullable FROM Demo WHERE SomeCol = 1) ELSE 1 END
COALESCE ( expression [ ,...n ] ) ISNULL ( check_expression , replacement_value )
select * from SomeTable where IsNull(SomeNullableBitField, -1) != IsNull(SomeOtherNullableBitField, -1);
select * from SomeTable where coalesce(SomeNullableBitField, -1) != coalesce(SomeOtherNullableBitField, -1);
with input as ( select convert(bit, 1) as BitOn, convert(bit, 0) as BitOff, convert(bit, null) as BitNull ) select BitOn, BitOff, BitNull, IsNull(BitOn, -1) IsNullBitOn, -- true IsNull(BitOff, -1) IsNullBitOff, -- false IsNull(BitNull, -1) IsNullBitNull, -- true, converts the -1 to bit coalesce(BitOn, -1) CoalesceBitOn, -- 1 coalesce(BitOff, -1) CoalesceBitOff, -- 0 coalesce(BitNull, -1) CoalesceBitNull -- -1 from input;
DECLARE @X VARCHAR(3) = NULL DECLARE @Y VARCHAR(10) = SELECT ISNULL(@X, @Y) ---> Output is SELECT COALESCE(@X, @Y) ---> Output is
SELECT CASE ("column_name") WHEN "expression 1 is not NULL" THEN "expression 1" WHEN "expression 2 is not NULL" THEN "expression 2" ... [ELSE "NULL"] END FROM "table_name";
DECLARE @x VARCHAR(3) = NULL ,@y VARCHAR(10) = SELECT ISNULL(@x, @y) AS [ISNULL], COALESCE(@x, @y) AS [COALESCE];
DECLARE @x VARCHAR(8) = ,@y INT = 123; SELECT ISNULL(@x, @y) AS [ISNULL]; SELECT COALESCE(@x, @y) AS [COALESCE];
DECLARE @x VARCHAR(3) = NULL ,@y VARCHAR(3) = NULL; DROP TABLE IF EXISTS [dbo].[DataSource01]; SELECT ISNULL(10, 20) AS [C1] ,ISNULL(@x, ,ISNULL(@x, @y) AS [C3] INTO [dbo].[DataSource01]; DROP TABLE IF EXISTS [dbo].[DataSource02]; SELECT COALESCE(10, 20) AS [C1] ,COALESCE(@x, ,COALESCE(@x, @y) AS [C3] INTO [dbo].[DataSource02];
CASE WHEN (<subquery>) IS NOT NULL THEN (<subquery>) ELSE 0 END
DECLARE @Value1 INT, @Value2 INT, @Value3 INT, @Value4 INT SELECT @Value2 = 2, @Value4 = 4 SELECT COALESCE(@Value1, @Value2, @Value3, @Value4) SELECT COALESCE(@Value1, @Value4, @Value3, @Value2)
BEGIN TRANSACTION BEGIN TRY INSERT INTO Tags.tblDomain (DomainName, SubDomainId, DomainCode, Description) VALUES(@DomainName, @SubDomainId, @DomainCode, @Description) COMMIT TRANSACTION END TRY BEGIN CATCH declare @severity int; declare @state int; select @severity=error_severity(), @state=error_state(); RAISERROR(@@Error,@ErrorSeverity,@state); ROLLBACK TRANSACTION END CATCH
catch (SqlException ex) { if ex.number==2627 MessageBox.show("Duplicate value cannot be inserted"); }
Msg 2627, Level 14, State 1, Procedure spOTest_DomainInsert,
begin try begin transaction; ... commit transaction; end try begin catch declare @ErrorMessage nvarchar(max), @ErrorSeverity int, @ErrorState int; select @ErrorMessage = ERROR_MESSAGE() + rollback transaction; raiserror (@ErrorMessage, @ErrorSeverity, @ErrorState); end catch
BEGIN TRY BEGIN TRANSACTION ... COMMIT TRANSACTION END TRY BEGIN CATCH ROLLBACK TRANSACTION; THROW END CATCH
DECLARE @ErrorMessage nvarchar(4000) = ERROR_MESSAGE(), @ErrorNumber int = ERROR_NUMBER(), @ErrorSeverity int = ERROR_SEVERITY(), @ErrorState int = ERROR_STATE(), @ErrorLine int = ERROR_LINE(), @ErrorProcedure nvarchar(200) = ISNULL(ERROR_PROCEDURE(), SELECT @ErrorMessage = N RAISERROR (@ErrorMessage, @ErrorSeverity, 1, @ErrorNumber, @ErrorSeverity, @ErrorState, @ErrorProcedure, @ErrorLine)
DECLARE @Error_Number INT BEGIN TRANSACTION BEGIN TRY INSERT INTO Test(Id, Name) VALUES (newID(), END TRY BEGIN CATCH SELECT ERROR_NUMBER() --RAISERROR (@ErrorMessage,@Severity,@State) ROLLBACK TRAN END CATCH
int errorNumber=(int)command.ExecuteScalar(); if(errorNumber=<SomeNumber>) { MessageBox.Show("Some message"); }
CREATE PROCEDURE usp_Execute_SQL_Within_Transaction ( @SQL nvarchar(max) ) AS SET NOCOUNT ON BEGIN TRY BEGIN TRANSACTION EXEC(@SQL) COMMIT TRANSACTION END TRY BEGIN CATCH DECLARE @ErrorMessage nvarchar(max), @ErrorSeverity int, @ErrorState int SELECT @ErrorMessage = N ROLLBACK TRANSACTION RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState) END CATCH GO -- Test it EXEC usp_Execute_SQL_Within_Transaction @SQL = EXEC usp_Execute_SQL_Within_Transaction @SQL = EXEC usp_Execute_SQL_Within_Transaction @SQL =
SELECT db.name AS DBName, type_desc AS FileType, Physical_Name AS Location FROM sys.master_files mf INNER JOIN sys.databases db ON db.database_id = mf.database_id
Create Table ( DatabaseName sysname, Name sysname, physical_name nvarchar(500), size decimal (18,2), FreeSpace decimal (18,2) ) Exec sp_msforeachdb ' Use [?]; Insert Into Select DB_NAME() AS [DatabaseName], Name, physical_name, Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size, Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) - Cast(FILEPROPERTY(name, From sys.database_files ' Select * From drop table
select db_name(dbid) dbname, filename from sys.sysaltfiles
SELECT db.name AS DBName, (select mf.Physical_Name FROM sys.master_files mf where mf.type_desc = (select mf.Physical_Name FROM sys.master_files mf where mf.type_desc = FROM sys.databases db
DBName DataFile LogFile -------------------------------------------------------------------------------- master C:\....\master.mdf C:\....\mastlog.ldf tempdb C:\....\tempdb.mdf C:\....\templog.ldf model C:\....\model.mdf C:\....\modellog.ldf
IF OBJECT_ID( DROP TABLE CREATE TABLE ( Drive CHAR(1) ,MBFree INT ) INSERT INTO EXEC master..xp_fixeddrives IF OBJECT_ID( DROP TABLE [dbo].[Tmp_tblDatabaseInfo] CREATE TABLE [dbo].[Tmp_tblDatabaseInfo]( [ServerName] [nvarchar](128) NULL ,[DBName] [nvarchar](128) NULL ,[database_id] [int] NULL ,[create_date] datetime NULL ,[CompatibilityLevel] [int] NULL ,[collation_name] [nvarchar](128) NULL ,[state_desc] [nvarchar](60) NULL ,[recovery_model_desc] [nvarchar](60) NULL ,[DataFileLocations] [nvarchar](4000) ,[DataFilesMB] money null ,DataVolumeFreeSpaceMB INT NULL ,[LogFileLocations] [nvarchar](4000) ,[LogFilesMB] money null ,LogVolumeFreeSpaceMB INT NULL ) ON [PRIMARY] INSERT INTO [dbo].[Tmp_tblDatabaseInfo] SELECT @@SERVERNAME AS [ServerName] ,d.name AS DBName ,d.database_id ,d.create_date ,d.compatibility_level ,CAST(d.collation_name AS [nvarchar](128)) AS collation_name ,d.[state_desc] ,d.recovery_model_desc ,(select physical_name + from sys.master_files m WHERE m.type = 0 and m.database_id = d.database_id ORDER BY file_id FOR XML PATH ( ,(select sum(size) from sys.master_files m WHERE m.type = 0 and m.database_id = d.database_id) AS DataFilesMB ,NULL ,(select physical_name + from sys.master_files m WHERE m.type = 1 and m.database_id = d.database_id ORDER BY file_id FOR XML PATH ( ,(select sum(size) from sys.master_files m WHERE m.type = 1 and m.database_id = d.database_id) AS LogFilesMB ,NULL FROM sys.databases d WHERE d.database_id > 4 --Exclude basic system databases UPDATE [dbo].[Tmp_tblDatabaseInfo] SET DataFileLocations = CASE WHEN LEN(DataFileLocations) > 4 THEN LEFT(DataFileLocations,LEN(DataFileLocations)-2) ELSE NULL END ,LogFileLocations = CASE WHEN LEN(LogFileLocations) > 4 THEN LEFT(LogFileLocations,LEN(LogFileLocations)-2) ELSE NULL END ,DataFilesMB = CASE WHEN DataFilesMB > 0 THEN DataFilesMB * 8 / 1024.0 ELSE NULL END ,LogFilesMB = CASE WHEN LogFilesMB > 0 THEN LogFilesMB * 8 / 1024.0 ELSE NULL END ,DataVolumeFreeSpaceMB = (SELECT MBFree FROM ,LogVolumeFreeSpaceMB = (SELECT MBFree FROM select * from [dbo].[Tmp_tblDatabaseInfo]
SELECT db.name AS [Database Name], mf.name AS [Logical Name], mf.type_desc AS [File Type], mf.physical_name AS [Path], CAST( (mf.Size * 8 ) / 1024.0 AS DECIMAL(18, 1)) AS [Initial Size (MB)], mf.is_percent_growth = 1, CAST(mf.growth AS VARCHAR(10))+ (mf.growth * 8 ) / 1024.0 AS DECIMAL(18, 1)))+ IIF(mf.max_size = 0, ( CAST(mf.max_size AS BIGINT) * 8 ) / 1024 AS VARCHAR(30))+ FROM sys.master_files AS mf INNER JOIN sys.databases AS db ON db.database_id = mf.database_id
SELECT db.name AS DBName, db.database_id, mfr.physical_name AS DataFile, mfl.physical_name AS LogFile FROM sys.databases db JOIN sys.master_files mfr ON db.database_id=mfr.database_id AND mfr.type_desc= JOIN sys.master_files mfl ON db.database_id=mfl.database_id AND mfl.type_desc= ORDER BY db.database_id
SELECT CASE WHEN S.Id IS NOT NULL AND S.Status = 1 AND (S.WebUserId = @WebUserId OR S.AllowUploads = 1) THEN 1 ELSE 0 END AS [Value] FROM Sites S WHERE S.Id = @SiteId
SELECT CASE WHEN COUNT(1) > 0 THEN 1 ELSE 0 END AS [Value] FROM Sites S WHERE S.Id = @SiteId and S.Status = 1 AND (S.WebUserId = @WebUserId OR S.AllowUploads = 1)
SELECT ISNULL( (SELECT 1 FROM Sites S WHERE S.Id = @SiteId and S.Status = 1 AND (S.WebUserId = @WebUserId OR S.AllowUploads = 1)), 0)
SELECT S.Status, COUNT(s.id) AS StatusCount FROM Sites S WHERE S.Id = @SiteId GROUP BY s.Status UNION ALL --UNION BACK ON TABLE WITH NOT EXISTS SELECT WHERE NOT EXISTS (SELECT 1 FROM Sites S WHERE S.Id = @SiteId )
if exists (select top 1 * from Sites S where S.Id IS NOT NULL AND S.Status = 1 AND (S.WebUserId = @WebUserId OR S.AllowUploads = 1)) select 1 else select 0
select isnull( (select ASSIGNMENTM1.NAME from dbo.ASSIGNMENTM1 where ASSIGNMENTM1.NAME = ?) ,
select isnull( --sub query either returns a value or returns nothing (no value) (select ASSIGNMENTM1.NAME from dbo.ASSIGNMENTM1 where ASSIGNMENTM1.NAME = ?) --If there is a value it is displayed --If no value, it is perceived as a field with a null value, --so the isnull function can give the desired results ,
SELECT CASE WHEN S.Id IS NOT NULL AND S.Status = 1 AND ...) THEN 1 ELSE 0 END AS [Value] FROM (SELECT @SiteId AS Id) R LEFT JOIN Sites S ON S.Id = R.Id
SELECT CASE WHEN S.Id IS NULL THEN 0 ELSE S.Col1 END AS Col1, S.Col2, ISNULL(S.Col3, 0) AS Col3 FROM (SELECT @Id AS Id) R LEFT JOIN Sites S ON S.Id = R.Id AND S.Status = 1 AND ...
SELECT TOP 1 WITH TIES tbl1.* FROM (SELECT CASE WHEN S.Id IS NOT NULL AND S.Status = 1 AND (S.WebUserId = @WebUserId OR S.AllowUploads = 1) THEN 1 ELSE 0 AS [Value] FROM Sites S WHERE S.Id = @SiteId) as tbl1 ORDER BY tbl1.[Value]
SELECT TOP 1 [Column Name] FROM (SELECT [Column Name] FROM [table] WHERE [conditions] UNION ALL SELECT 0 )A ORDER BY [Column Name] DESC
BuildingName PollNumber ------------ ---------- Foo Centre 12 Foo Centre 13 Foo Centre 14 Bar Hall 15 Bar Hall 16 Baz School 17
BuildingName PollNumbers ------------ ----------- Foo Centre 12, 13, 14 Bar Hall 15, 16 Baz School 17
set nocount on; declare @YourTable table (RowID int, HeaderValue int, ChildValue varchar(5)) insert into @YourTable VALUES (1,1, insert into @YourTable VALUES (2,2, insert into @YourTable VALUES (3,2, insert into @YourTable VALUES (4,3, insert into @YourTable VALUES (5,3, set nocount off SELECT t1.HeaderValue ,STUFF( (SELECT FROM @YourTable t2 WHERE t1.HeaderValue=t2.HeaderValue ORDER BY t2.ChildValue FOR XML PATH( ).value( ,1,2, ) AS ChildValues FROM @YourTable t1 GROUP BY t1.HeaderValue SELECT HeaderValue, STRING_AGG(ChildValue, FROM @YourTable GROUP BY HeaderValue
HeaderValue ----------- ------------- 1 CCC 2 B<&>B, AAA 3 <br>, A & Z (3 rows affected)
--Concatenation with FOR XML and eleminating control/encoded character expansion "& < >" set nocount on; declare @YourTable table (RowID int, HeaderValue int, ChildValue varchar(5)) insert into @YourTable VALUES (1,1, insert into @YourTable VALUES (2,2, insert into @YourTable VALUES (3,2, insert into @YourTable VALUES (4,3, insert into @YourTable VALUES (5,3, set nocount off SELECT t1.HeaderValue ,STUFF( (SELECT FROM @YourTable t2 WHERE t1.HeaderValue=t2.HeaderValue ORDER BY t2.ChildValue FOR XML PATH( ).value( ,1,2, ) AS ChildValues FROM @YourTable t1 GROUP BY t1.HeaderValue
HeaderValue ChildValues ----------- ------------------- 1 CCC 2 AAA, B<&>B 3 <br>, A & Z (3 row(s) affected)
using System; using System.Data.SqlTypes; using System.IO; using System.Text; using Microsoft.SqlServer.Server; [Serializable] [SqlUserDefinedAggregate(Format.UserDefined, IsInvariantToNulls = true, IsInvariantToDuplicates = false, IsInvariantToOrder = false, MaxByteSize = 8000, Name = "Concatenate")] public class Concatenate : IBinarySerialize { private StringBuilder _intermediateResult; internal string IntermediateResult { get { return _intermediateResult.ToString(); } } public void Init() { _intermediateResult = new StringBuilder(); } public void Accumulate(SqlString value) { if (value.IsNull) return; _intermediateResult.Append(value.Value); } public void Merge(Concatenate other) { if (null == other) return; _intermediateResult.Append(other._intermediateResult); } public SqlString Terminate() { var output = string.Empty; if (_intermediateResult != null && _intermediateResult.Length > 0) output = _intermediateResult.ToString(0, _intermediateResult.Length - 1); return new SqlString(output); } public void Read(BinaryReader reader) { if (reader == null) throw new ArgumentNullException("reader"); _intermediateResult = new StringBuilder(reader.ReadString()); } public void Write(BinaryWriter writer) { if (writer == null) throw new ArgumentNullException("writer"); writer.Write(_intermediateResult.ToString()); } }
create table test( id int identity(1,1) not null primary key , class tinyint not null , name nvarchar(120) not null ) insert into test values (1, N (1, N (1, N (1, N (1, N (2, N (3, N (3, N (3, N (3, N (3, N (3, N (3, N (3, N (3, N (3, N select dbo.Concatenate(name + from test group by class drop table test
-- Output -- =================== -- This is just a test -- , -- do not be alarmed , this is just a test
CName | AddressLine ------------------------------- John Smith | 123 Nowheresville Jane Doe | 456 Evergreen Terrace John Smith | 999 Somewhereelse Joe Bloggs | 1 Second Ave
SELECT CName, MIN(AddressLine) FROM MyTable GROUP BY CName
SELECT M.CName, M.AddressLine, FROM ( SELECT CName, MIN(Inserted) AS First FROM MyTable GROUP BY CName ) foo JOIN MyTable M ON foo.CName = M.CName AND foo.First = M.Inserted
;with cte as ( select CName, AddressLine, rank() over (partition by CName order by AddressLine) as [r] from MyTable ) select CName, AddressLine from cte where [r] = 1
select * from mytable where row_number() over(partition by Name order by AddressLine) = 1
select * from ( select * , ROW_NUMBER() OVER(PARTITION BY CName ORDER BY AddressLine) AS row from myTable ) as a where row = 1
(select cname, address from ( select cname,address, rn=row_number() over (partition by cname order by cname) from customeraddresses ) x where rn = 1) order by cname
SELECT NEXT VALUE for <seq>, <other columns> from <table>
ALTER DATABASE [oldname_2017-04-23T09 -17Z] MODIFY NAME = [newname];
Msg 0, Level 20, State 0, Line 0 A severe error occurred on the current command. The results, if any, should be discarded.
SELECT SERVERPROPERTY( SERVERPROPERTY( CASE WHEN SERVERPROPERTY( ELSE SERVERPROPERTY( END AS InstanceName, SUBSTRING ( (SELECT @@VERSION),1, CHARINDEX( SERVERPROPERTY( SERVERPROPERTY( SERVERPROPERTY( SERVERPROPERTY( SERVERPROPERTY( SERVERPROPERTY( CASE SERVERPROPERTY( WHEN 1 THEN WHEN 2 THEN WHEN 3 THEN WHEN 4 THEN WHEN 5 THEN WHEN 6 THEN END AS EngineEdition, CASE SERVERPROPERTY( WHEN 0 THEN WHEN 1 THEN ELSE END AS HadrEnabled, CASE SERVERPROPERTY( WHEN 0 THEN WHEN 1 THEN WHEN 2 THEN ELSE END AS HadrManagerStatus, CASE SERVERPROPERTY( CASE SERVERPROPERTY( WHEN 1 THEN WHEN 0 THEN ELSE END AS IsClustered,
SELECT TOP 1 * FROM YourTable TABLESAMPLE (1000 ROWS) ORDER BY NEWID()
SELECT TOP 1 * FROM table WHERE Id >= @yourrandomid
SELECT * FROM Table1 WHERE (ABS(CAST( (BINARY_CHECKSUM (keycol1, NEWID())) as int)) % 100) < 10
Create Table Insert Into Select street, city, st, zip From tbl_Address (NOLOCK) Where st = @st -- unseeded RAND() will return the same number when called in rapid succession so -- here, I seed it with a guaranteed different number each time. @@ROWCOUNT is the count from the most recent table operation. Set @csr = Ceiling(RAND(convert(varbinary, newid())) * @@ROWCOUNT) Select street, city, st, Right(( From Where id = @csr
DECLARE @Tickets TABLE ( [TicketID] char(5) NOT NULL, [Person] nvarchar(15) NOT NULL ) INSERT INTO @Tickets VALUES ( ( ( ( ( SELECT * FROM @Tickets
SELECT t.TicketID, STUFF(ISNULL((SELECT FROM @Tickets x WHERE x.TicketID = t.TicketID GROUP BY x.Person FOR XML PATH ( ISNULL((SELECT FROM @Tickets x WHERE x.TicketID = t.TicketID GROUP BY x.Person FOR XML PATH ( FROM @Tickets t GROUP BY t.TicketID
select TicketId, GROUP_CONCAT(Person ORDER BY Person SEPARATOR from table group by TicketId
DECLARE @Tickets TABLE ( [TicketID] char(5) NOT NULL, [Person] nvarchar(15) NOT NULL ) INSERT INTO @Tickets VALUES ( ( ( ( ( SELECT * FROM @Tickets Select [TicketID], STUFF((SELECT TicketID=Result.TicketID) FOR XML PATH ( From @Tickets AS Result GROUP BY TicketID
select TicketId, listagg(Person, from table group by TicketId
with data as ( select TicketId, Person, ROW_NUMBER() over (partition by TicketId order by Person) "rownum", COUNT(*) over (partition by TicketId) "count" from Table ) select TicketId, LTRIM(sys_connect_by_path(Person, from data where "rownum" = "count" start with "rownum" = 1 connect by prior TicketId = TicketId and prior "rownum" = "rownum" - 1 order by TicketId
SELECT DISTINCT t.TicketID, STUFF((SELECT FROM @Tickets i WHERE i.TicketID = t.TicketID FOR XML PATH ( FROM @Tickets t
SELECT DISTINCT t.TicketID, STUFF((SELECT FROM @Tickets i WHERE i.TicketID = t.TicketID FOR XML PATH ( FROM @Tickets t
RegEx.IgnoreCase = True RegEx.Global = True RegEx.Pattern = "[^a-z\d\s.]+"
CREATE TABLE GO INSERT INTO INSERT INTO INSERT INTO SELECT * FROM GO DROP TABLE
Imports System Imports System.Data.Sql Imports Microsoft.SqlServer.Server Imports System.Data.SqlTypes Imports System.Runtime.InteropServices Imports System.Text.RegularExpressions Imports System.Collections Namespace SimpleTalk.Phil.Factor Public Class RegularExpressionFunctions <SqlFunction(IsDeterministic:=True, IsPrecise:=True)> _ Public Shared Function RegExIsMatch( _ ByVal pattern As SqlString, _ ByVal input As SqlString, _ ByVal Options As SqlInt32) As SqlBoolean If (input.IsNull OrElse pattern.IsNull) Then Return SqlBoolean.False End If Dim RegExOption As New System.Text.RegularExpressions.RegExOptions RegExOption = Options Return RegEx.IsMatch(input.Value, pattern.Value, RegExOption) End Function End Class End Namespace
sp_configure RECONFIGURE WITH OVERRIDE IF EXISTS ( SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID(N DROP FUNCTION dbo.RegExIsMatch go IF EXISTS ( SELECT 1 FROM sys.assemblies asms WHERE asms.name = N DROP ASSEMBLY [RegExFunction] CREATE ASSEMBLY RegExFunction FROM GO CREATE FUNCTION RegExIsMatch ( @Pattern NVARCHAR(4000), @Input NVARCHAR(MAX), @Options int ) RETURNS BIT AS EXTERNAL NAME RegExFunction.[SimpleTalk.Phil.Factor.RegularExpressionFunctions].RegExIsMatch GO --a few tests ---Is this card a valid credit card? SELECT dbo.RegExIsMatch ( --is there a number in this string SELECT dbo.RegExIsMatch( --Verifies number Returns 1 DECLARE @pattern VARCHAR(255) SELECT @pattern = SELECT dbo.RegExIsMatch (@pattern, dbo.RegExIsMatch (@pattern, dbo.RegExIsMatch (@pattern, dbo.RegExIsMatch (@pattern, dbo.RegExIsMatch (@pattern,
-- MS SQL using VBScript Regex -- select dbo.RegexReplace( -- $$ dollar sign, $1 - $9 back references, $& whole match CREATE FUNCTION [dbo].[RegexReplace] ( -- these match exactly the parameters of RegExp @searchstring varchar(4000), @replacestring varchar(4000), @pattern varchar(4000) ) RETURNS varchar(4000) AS BEGIN declare @objRegexExp int, @objErrorObj int, @strErrorMessage varchar(255), @res int, @result varchar(4000) if( @searchstring is null or len(ltrim(rtrim(@searchstring))) = 0) return null set @result= exec @res=sp_OACreate if( @res <> 0) return exec @res=sp_OASetProperty @objRegexExp, if( @res <> 0) return exec @res=sp_OASetProperty @objRegexExp, if( @res <> 0) return exec @res=sp_OAMethod @objRegexExp, @searchstring, @replacestring if( @res <> 0) return exec @res=sp_OADestroy @objRegexExp return @result END
exec sp_configure go reconfigure; go sp_configure go reconfigure; go sp_configure go reconfigure; go
SELECT * FROM databasename..VersionedFields WHERE Value LIKE
code before iframe <iframe src="yadayada"> </iframe> code after iframe
code before iframe <a>iframe src="yadayada"</a> code after iframe
update VersionedFields set Value = replace(value, update VersionedFields set Value = replace(value,
UPDATE Table SET Column = Replace(Column, WHERE xxx
update VersionedFields set Value = replace(replace(value,
use AdventureWorks create fulltext catalog FullTextCatalog as default select * from sys.fulltext_catalogs
create fulltext index on Production.ProductDescription(Description) key index PK_ProductDescription_ProductDescriptionID
SELECT ID, ProductName FROM [ProductsDB].[dbo].[Products] WHERE [ProductsDB].[dbo].[Products].ProductName LIKE
SELECT * FROM ChartOfAccounts WHERE AccountName LIKE
declare @datetime datetime; set @datetime = getdate(); select @datetime; select dateadd(year,datediff(year,0,@datetime),0); select dateadd(month,datediff(month,0,@datetime),0); select dateadd(day,datediff(day,0,@datetime),0); select dateadd(hour,datediff(hour,0,@datetime),0); select dateadd(minute,datediff(minute,0,@datetime),0); select dateadd(second,datediff(second, select dateadd(week,datediff(week,0,@datetime),-1); --Beginning of week is Sunday select dateadd(week,datediff(week,0,@datetime),0); --Beginning of week is Monday
SELECT CAST(FLOOR(CAST(CURRENT_TIMESTAMP AS float)) AS DATETIME)
IF OBJECT_ID( SET ANSI_NULLS OFF GO SET QUOTED_IDENTIFIER ON GO CREATE FUNCTION [dbo].[fn_FloorDate] ( @Date DATETIME = NULL, @DatePart VARCHAR(6) = ) RETURNS DATETIME AS BEGIN IF (@Date IS NULL) SET @Date = GETDATE(); RETURN CASE WHEN LOWER(@DatePart) = WHEN LOWER(@DatePart) = WHEN LOWER(@DatePart) = WHEN LOWER(@DatePart) = WHEN LOWER(@DatePart) = WHEN LOWER(@DatePart) = ELSE DATEADD(DAY, DATEDIFF(DAY, 0, @Date), 0) END; END
DECLARE @date DATETIME; SET @date = SELECT @date AS [Now],--2008-09-17 12:56:53.430 dbo.fn_FloorDate(@date, dbo.fn_FloorDate(default, default) AS [NoParams],--2013-11-05 00:00:00.000 dbo.fn_FloorDate(@date, default) AS [ShouldBeDay],--2008-09-17 00:00:00.000 dbo.fn_FloorDate(@date, dbo.fn_FloorDate(@date, dbo.fn_FloorDate(@date, dbo.fn_FloorDate(@date, dbo.fn_FloorDate(@date,
select convert(datetime,convert(varchar,CURRENT_TIMESTAMP,101))
----Last Day of Previous Month SELECT DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,GETDATE()),0)) LastDay_PreviousMonth ----Last Day of Current Month SELECT DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,GETDATE())+1,0)) LastDay_CurrentMonth ----Last Day of Next Month SELECT DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,GETDATE())+2,0)) LastDay_NextMonth
OPEN db_cursor FETCH NEXT FROM db_cursor INTO @name WHILE @@FETCH_STATUS = 0 BEGIN --Do Stuff with @name scalar value, then get next row from cursor FETCH NEXT FROM db_cursor INTO @name END
OPEN db_cursor FETCH NEXT FROM db_cursor; WHILE @@FETCH_STATUS = 0 BEGIN SET @myName = db_cursor.name; SET @myAge = db_cursor.age; SET @myFavoriteColor = db_cursor.favoriteColor; --Do stuff with scalar values FETCH NEXT FROM db_cursor; END
DECLARE db_cursor CURSOR FOR SELECT name, age, color FROM table; DECLARE @myName VARCHAR(256); DECLARE @myAge INT; DECLARE @myFavoriteColor VARCHAR(40); OPEN db_cursor; FETCH NEXT FROM db_cursor INTO @myName, @myAge, @myFavoriteColor; WHILE @@FETCH_STATUS = 0 BEGIN --Do stuff with scalar values FETCH NEXT FROM db_cursor INTO @myName, @myAge, @myFavoriteColor; END; CLOSE db_cursor; DEALLOCATE db_cursor;
SELECT contendernum, totals, RANK() OVER (PARTITION BY ContenderNum ORDER BY totals ASC) AS xRank FROM ( SELECT ContenderNum, SUM(Criteria1+Criteria2+Criteria3+Criteria4) AS totals FROM Cat1GroupImpersonation GROUP BY ContenderNum ) AS a
contendernum totals xRank 1 196 1 2 181 1 3 192 1 4 181 1 5 179 1
contendernum totals xRank 1 196 1 2 181 3 3 192 2 4 181 3 5 179 4
RANK() OVER (PARTITION BY ContenderNum ORDER BY totals ASC) AS xRank
create table ( column1 varchar(3), column2 varchar(5), column3 datetime, column4 int ) insert into insert into insert into insert into insert into
with cte as ( select *, rank() over (partition by column2 order by column3) rnk from t ) select * from cte where rnk = 1 order by column3;
COLUMN1 | COLUMN2 | COLUMN3 |COLUMN4 | RNK ------------------------------------------------------------------------------ AAA | SKB | January, 15 2013 00:00:00+0000 |5 | 1 AAA | SKA | January, 31 2013 00:00:00+0000 |15 | 1 AAA | SKC | February, 01 2013 00:00:00+0000 |25 | 1
SELECT contendernum,totals, DENSE_RANK() OVER (ORDER BY totals desc) AS xRank FROM ( SELECT ContenderNum ,SUM(Criteria1+Criteria2+Criteria3+Criteria4) AS totals FROM dbo.Cat1GroupImpersonation GROUP BY ContenderNum ) AS a order by contendernum
create table Cat1GroupImpersonation ( contendernum int, criteria1 int, criteria2 int, criteria3 int, criteria4 int); insert Cat1GroupImpersonation select 1,196,0,0,0 union all select 2,181,0,0,0 union all select 3,192,0,0,0 union all select 4,181,0,0,0 union all select 5,179,0,0,0;
select Name,EmailId,salary,DENSE_RANK() over(order by salary asc) from [dbo].[Employees]
select Name,EmailId,salary,RANK() over(order by salary asc) from [dbo].[Employees]
SELECT contendernum,totals, **DENSE_RANK()** OVER (ORDER BY totals **DESC**) AS xRank FROM ( SELECT ContenderNum ,SUM(Criteria1+Criteria2+Criteria3+Criteria4) AS totals FROM dbo.Cat1GroupImpersonation GROUP BY ContenderNum ) AS a
SELECT contendernum,totals, RANK() OVER (ORDER BY totals ASC) AS xRank FROM ( SELECT ContenderNum ,SUM(Criteria1+Criteria2+Criteria3+Criteria4) AS totals FROM dbo.Cat1GroupImpersonation GROUP BY ContenderNum ) AS a
IF EXISTS(SELECT * FROM MY_TABLE WHERE MY_FIELD1 = @IN_MY_FIELD1 AND MY_FIELD2 = @IN_MY_FIELD2 AND MY_FIELD3 = @IN_MY_FIELD3 AND MY_FIELD4 = @IN_MY_FIELD4 AND MY_FIELD5 = @IN_MY_FIELD5 AND MY_FIELD6 = @IN_MY_FIELD6) BEGIN goto on_duplicate END
IF EXISTS ( SELECT MY_FIELD1, MY_FIELD2, MY_FIELD3, MY_FIELD4, MY_FIELD5, MY_FIELD6 FROM MY_TABLE INTERSECT SELECT @IN_MY_FIELD1, @IN_MY_FIELD2, @IN_MY_FIELD3, @IN_MY_FIELD4, @IN_MY_FIELD5, @IN_MY_FIELD6 ) BEGIN goto on_duplicate END
(Field1 = Field2) OR (ISNULL(Field1, Field2) IS NULL)
WHEN MATCHED AND (Target.Field1 <> Source.Field1 OR ...)
WHEN MATCHED AND ( ( -- Neither is null, values are not equal Target.Field1 IS NOT NULL AND Source.Field1 IS NOT NULL AND Target.Field1 <> Source.Field1 ) OR ( -- Target is null but source is not Target.Field1 IS NULL AND Source.Field1 IS NOT NULL ) OR ( -- Source is null but target is not Target.Field1 IS NOT NULL AND Source.Field1 IS NULL ) -- OR ... Repeat for other columns )
WHEN MATCHED AND ( -- Neither is null, values are not equal NOT (Target.Field1 IS NULL OR Source.Field1 IS NULL) AND Target.Field1 <> Source.Field1 -- Source xor target is null OR (Target.Field1 IS NULL OR Source.Field1 IS NULL) AND NOT (Target.Field1 IS NULL AND Source.Field1 IS NULL) -- OR ... Repeat for other columns )
WHEN MATCHED AND ( ISNULL( NULLIF(Target.Field1, Source.Field1), NULLIF(Source.Field1, Target.Field1) ) IS NOT NULL -- OR ... Repeat for other columns )
IF EXISTS(SELECT * FROM MY_TABLE WHERE (MY_FIELD1 = @IN_MY_FIELD1 or (MY_FIELD1 IS NULL and @IN_MY_FIELD1 is NULL)) AND (MY_FIELD2 = @IN_MY_FIELD2 or (MY_FIELD2 IS NULL and @IN_MY_FIELD2 is NULL)) AND (MY_FIELD3 = @IN_MY_FIELD3 or (MY_FIELD3 IS NULL and @IN_MY_FIELD3 is NULL)) AND (MY_FIELD4 = @IN_MY_FIELD4 or (MY_FIELD4 IS NULL and @IN_MY_FIELD4 is NULL)) AND (MY_FIELD5 = @IN_MY_FIELD5 or (MY_FIELD5 IS NULL and @IN_MY_FIELD5 is NULL)) AND (MY_FIELD6 = @IN_MY_FIELD6 or (MY_FIELD6 IS NULL and @IN_MY_FIELD6 is NULL))) BEGIN goto on_duplicate END
IF EXISTS(SELECT * FROM MY_TABLE WHERE coalesce(MY_FIELD1, ... BEGIN goto on_duplicate END
(Field1 <> Field2) OR (NULLIF(Field1, Field2) IS NOT NULL) OR (NULLIF(Field2, Field1) IS NOT NULL)
((f1 IS NULL AND f2 IS NULL) OR (f1 IS NOT NULL AND f2 IS NOT NULL AND f1 = f2))
NOT ((f1 IS NULL AND f2 IS NULL) OR (f1 IS NOT NULL AND f2 IS NOT NULL AND f1 = f2))
select cast(123.4567 as DECIMAL(9,6)) , cast(cast(123.4567 as DECIMAL(9,6)) as float)
SELECT FORMAT(CAST(15.12 AS DECIMAL(9,6)), SELECT FORMAT(CAST(0.0001575 AS DECIMAL(9,6)), SELECT FORMAT(CAST(2.0 AS DECIMAL(9,6)),
SELECT FORMAT(CAST(15.12 AS FLOAT), SELECT FORMAT(CAST(0.9 AS REAL), SELECT FORMAT(CAST(0.9 AS REAL),
DECLARE @n DECIMAL(9,6) =1.23; SELECT @n --> 1.230000 SELECT FORMAT(@n, --> 1.23
DECLARE @MyNum FLOAT SET @MyNum = 700000 SELECT CAST(PARSENAME(CONVERT(NUMERIC(15,2),@MyNum/10000),2) AS VARCHAR(10)) + SUBSTRING( + REPLACE(RTRIM(REPLACE(CAST(PARSENAME(CONVERT(NUMERIC(15,2),@MyNum/10000),1) AS VARCHAR(2)),
CREATE FUNCTION [dbo].[fn_ConvertToString] ( @value sql_variant ) RETURNS varchar(max) AS BEGIN declare @x varchar(max) set @x= reverse(replace(ltrim(reverse(replace(convert(varchar(max) , @value), --remove "unneeded "dot" if any set @x = Replace(RTRIM(Replace(@x, return @x END
SELECT PARSENAME(2.5500,2) + + REVERSE(CAST(REVERSE(PARSENAME(2.5500,1)) as int))
SELECT REPLACE(TRIM(REPLACE(20.5500, "0", " ")), " ", "0")
select replace(rtrim(replace( replace(rtrim(replace(cast(@value as varchar(40)), ,
BEGIN DECLARE @thisText VARCHAR(255) SET @thisText = REPLACE(RTRIM(REPLACE(@thisData, IF SUBSTRING(@thisText, LEN(@thisText), 1) = RETURN STUFF(@thisText, LEN(@thisText), 1, RETURN @thisText END
case when left(replace(ltrim(rtrim(replace(str(XXX, 38, 10), then else end + replace(ltrim(rtrim(replace(str(XXX, 38, 10), case when right(replace(ltrim(rtrim(replace(str(XXX, 38, 10), then else end
DECLARE @value DECIMAL(23,3) set @value = 1.2000 select @value original_val, SUBSTRING( CAST( @value as VARCHAR(100)), 0, PATINDEX( ) + CASE WHEN ROUND( REVERSE( SUBSTRING( CAST(@value as VARCHAR(100)), PATINDEX( LEN(CAST(@value as VARCHAR(100))) ) ) ,1) > 0 THEN + REVERSE(ROUND(REVERSE(SUBSTRING( CAST(@value as VARCHAR(100)), PATINDEX( LEN(CAST(@value as VARCHAR(100))) ) ),1)) ELSE
DECLARE @num decimal(28,14) = 10.012345000 SELECT PARSENAME(@num,2) + REPLACE(RTRIM(LTRIM(REPLACE(@num-PARSENAME(@num,2), set @num = 0.0123450000 SELECT PARSENAME(@num,2) + REPLACE(RTRIM(LTRIM(REPLACE(@num-PARSENAME(@num,2),
select CAST(123.456700 as float),cast(cast(123.4567 as DECIMAL(9,6)) as float)
select Cast( Cast( (ROUND( 35.457514 , 2) *100) as Int) as float ) /100
-- ============================================= -- Computes and returns the Levenshtein edit distance between two strings, i.e. the -- number of insertion, deletion, and sustitution edits required to transform one -- string to the other, or NULL if @max is exceeded. Comparisons use the case- -- sensitivity configured in SQL Server (case-insensitive by default). -- http: -- -- Based on Sten Hjelmqvist -- at http: -- with some additional optimizations. -- ============================================= CREATE FUNCTION [dbo].[Levenshtein]( @s nvarchar(4000) , @t nvarchar(4000) , @max int ) RETURNS int WITH SCHEMABINDING AS BEGIN DECLARE @distance int = 0 -- return variable , @v0 nvarchar(4000)-- running scratchpad for storing computed distances , @start int = 1 -- index (1 based) of first non-matching character between the two string , @i int, @j int -- loop counters: i for s string and j for t string , @diag int -- distance in cell diagonally above and left if we were using an m by n matrix , @left int -- distance in cell to the left if we were using an m by n matrix , @sChar nchar -- character at index i from s string , @thisJ int -- temporary storage of @j to allow SELECT combining , @jOffset int -- offset used to calculate starting value for j loop , @jEnd int -- ending value for j loop (stopping point for processing a column) -- get input string lengths including any trailing spaces (which SQL Server would otherwise ignore) , @sLen int = datalength(@s) / datalength(left(left(@s, 1) + , @tLen int = datalength(@t) / datalength(left(left(@t, 1) + , @lenDiff int -- difference in length between the two strings -- if strings of different lengths, ensure shorter string is in s. This can result in a little -- faster speed by spending more time spinning just the inner loop during the main processing. IF (@sLen > @tLen) BEGIN SELECT @v0 = @s, @i = @sLen -- temporarily use v0 for swap SELECT @s = @t, @sLen = @tLen SELECT @t = @v0, @tLen = @i END SELECT @max = ISNULL(@max, @tLen) , @lenDiff = @tLen - @sLen IF @lenDiff > @max RETURN NULL -- suffix common to both strings can be ignored WHILE(@sLen > 0 AND SUBSTRING(@s, @sLen, 1) = SUBSTRING(@t, @tLen, 1)) SELECT @sLen = @sLen - 1, @tLen = @tLen - 1 IF (@sLen = 0) RETURN @tLen -- prefix common to both strings can be ignored WHILE (@start < @sLen AND SUBSTRING(@s, @start, 1) = SUBSTRING(@t, @start, 1)) SELECT @start = @start + 1 IF (@start > 1) BEGIN SELECT @sLen = @sLen - (@start - 1) , @tLen = @tLen - (@start - 1) -- if all of shorter string matches prefix and/or suffix of longer string, then -- edit distance is just the delete of additional characters present in longer string IF (@sLen <= 0) RETURN @tLen SELECT @s = SUBSTRING(@s, @start, @sLen) , @t = SUBSTRING(@t, @start, @tLen) END -- initialize v0 array of distances SELECT @v0 = WHILE (@j <= @tLen) BEGIN SELECT @v0 = @v0 + NCHAR(CASE WHEN @j > @max THEN @max ELSE @j END) SELECT @j = @j + 1 END SELECT @jOffset = @max - @lenDiff , @i = 1 WHILE (@i <= @sLen) BEGIN SELECT @distance = @i , @diag = @i - 1 , @sChar = SUBSTRING(@s, @i, 1) -- no need to look beyond window of upper left diagonal (@i) + @max cells -- and the lower right diagonal (@i - @lenDiff) - @max cells , @j = CASE WHEN @i <= @jOffset THEN 1 ELSE @i - @jOffset END , @jEnd = CASE WHEN @i + @max >= @tLen THEN @tLen ELSE @i + @max END WHILE (@j <= @jEnd) BEGIN -- at this point, @distance holds the previous value (the cell above if we were using an m by n matrix) SELECT @left = UNICODE(SUBSTRING(@v0, @j, 1)) , @thisJ = @j SELECT @distance = CASE WHEN (@sChar = SUBSTRING(@t, @j, 1)) THEN @diag --match, no change ELSE 1 + CASE WHEN @diag < @left AND @diag < @distance THEN @diag --substitution WHEN @left < @distance THEN @left -- insertion ELSE @distance -- deletion END END SELECT @v0 = STUFF(@v0, @thisJ, 1, NCHAR(@distance)) , @diag = @left , @j = case when (@distance > @max) AND (@thisJ = @i + @lenDiff) then @jEnd + 2 else @thisJ + 1 end END SELECT @i = CASE WHEN @j > @jEnd + 1 THEN @sLen + 1 ELSE @i + 1 END END RETURN CASE WHEN @distance <= @max THEN @distance ELSE NULL END END
SET QUOTED_IDENTIFIER ON GO SET ANSI_NULLS ON GO CREATE FUNCTION edit_distance_within(@s nvarchar(4000), @t nvarchar(4000), @d int) RETURNS int AS BEGIN DECLARE @sl int, @tl int, @i int, @j int, @sc nchar, @c int, @c1 int, @cv0 nvarchar(4000), @cv1 nvarchar(4000), @cmin int SELECT @sl = LEN(@s), @tl = LEN(@t), @cv1 = WHILE @j <= @tl SELECT @cv1 = @cv1 + NCHAR(@j), @j = @j + 1 WHILE @i <= @sl BEGIN SELECT @sc = SUBSTRING(@s, @i, 1), @c1 = @i, @c = @i, @cv0 = WHILE @j <= @tl BEGIN SET @c = @c + 1 SET @c1 = @c1 - CASE WHEN @sc = SUBSTRING(@t, @j, 1) THEN 1 ELSE 0 END IF @c > @c1 SET @c = @c1 SET @c1 = UNICODE(SUBSTRING(@cv1, @j, 1)) + 1 IF @c > @c1 SET @c = @c1 IF @c < @cmin SET @cmin = @c SELECT @cv0 = @cv0 + NCHAR(@c), @j = @j + 1 END IF @cmin > @d BREAK SELECT @cv1 = @cv0, @i = @i + 1 END RETURN CASE WHEN @cmin <= @d AND @c <= @d THEN @c ELSE -1 END END GO
using System; using System.Data; using Microsoft.SqlServer.Server; using System.Data.SqlTypes; public class HelloWorldProc { [Microsoft.SqlServer.Server.SqlProcedure] public static void HelloWorld(out string text) { SqlContext.Pipe.Send("Hello world!" + Environment.NewLine); text = "Hello world!"; } }
CREATE ASSEMBLY helloworld from CREATE PROCEDURE hello @i nchar(25) OUTPUT AS EXTERNAL NAME helloworld.HelloWorldProc.HelloWorld
CREATE FUNCTION edit_distance(@s1 nvarchar(3999), @s2 nvarchar(3999)) RETURNS int AS BEGIN DECLARE @s1_len int, @s2_len int DECLARE @i int, @j int, @s1_char nchar, @c int, @c_temp int DECLARE @cv0 varbinary(8000), @cv1 varbinary(8000) SELECT @s1_len = LEN(@s1), @s2_len = LEN(@s2), @cv1 = 0x0000, @j = 1, @i = 1, @c = 0 WHILE @j <= @s2_len SELECT @cv1 = @cv1 + CAST(@j AS binary(2)), @j = @j + 1 WHILE @i <= @s1_len BEGIN SELECT @s1_char = SUBSTRING(@s1, @i, 1), @c = @i, @cv0 = CAST(@i AS binary(2)), @j = 1 WHILE @j <= @s2_len BEGIN SET @c = @c + 1 SET @c_temp = CAST(SUBSTRING(@cv1, @j+@j-1, 2) AS int) + CASE WHEN @s1_char = SUBSTRING(@s2, @j, 1) THEN 0 ELSE 1 END IF @c > @c_temp SET @c = @c_temp SET @c_temp = CAST(SUBSTRING(@cv1, @j+@j+1, 2) AS int)+1 IF @c > @c_temp SET @c = @c_temp SELECT @cv0 = @cv0 + CAST(@c AS binary(2)), @j = @j + 1 END SELECT @cv1 = @cv0, @i = @i + 1 END RETURN @c END
select dbo.edit_distance( dbo.edit_distance( dbo.edit_distance( dbo.edit_distance( dbo.edit_distance(
CREATE FUNCTION [dbo].[f_LevenshteinDistance](@s1 nvarchar(3999), @s2 nvarchar(3999)) RETURNS int AS BEGIN DECLARE @s1_len int; DECLARE @s2_len int; DECLARE @i int; DECLARE @j int; DECLARE @s1_char nchar; DECLARE @c int; DECLARE @c_temp int; DECLARE @cv0 varbinary(8000); DECLARE @cv1 varbinary(8000); SELECT @s1_len = LEN(@s1), @s2_len = LEN(@s2), @cv1 = 0x0000 , @j = 1 , @i = 1 , @c = 0 WHILE @j <= @s2_len SELECT @cv1 = @cv1 + CAST(@j AS binary(2)), @j = @j + 1; WHILE @i <= @s1_len BEGIN SELECT @s1_char = SUBSTRING(@s1, @i, 1), @c = @i , @cv0 = CAST(@i AS binary(2)), @j = 1; SET @i = @i + 1; WHILE @j <= @s2_len BEGIN SET @c = @c + 1; IF @j <= @i BEGIN SET @c_temp = CAST(SUBSTRING(@cv1, @j + @j - 1, 2) AS int) + CASE WHEN @s1_char = SUBSTRING(@s2, @j, 1) THEN 0 ELSE 1 END; IF @c > @c_temp SET @c = @c_temp SET @c_temp = CAST(SUBSTRING(@cv1, @j + @j + 1, 2) AS int) + 1; IF @c > @c_temp SET @c = @c_temp; END; SELECT @cv0 = @cv0 + CAST(@c AS binary(2)), @j = @j + 1; END; SET @cv1 = @cv0; END; RETURN @c; END;
DECLARE @a VARCHAR(10) SET @a = PRINT PATINDEX( PRINT PATINDEX(
INSERT INTO TheTable SELECT @primaryKey, @value1, @value2 WHERE NOT EXISTS (SELECT NULL FROM TheTable WHERE PrimaryKey = @primaryKey)
INSERT INTO TheTable WITH (HOLDLOCK, UPDLOCK, ROWLOCK) SELECT @primaryKey, @value1, @value2 WHERE NOT EXISTS (SELECT NULL FROM TheTable WITH (HOLDLOCK, UPDLOCK, ROWLOCK) WHERE PrimaryKey = @primaryKey)
BEGIN TRY INSERT etc END TRY BEGIN CATCH IF ERROR_NUMBER() <> 2627 RAISERROR etc END CATCH
INSERT INTO TheTable SELECT @primaryKey, @value1, @value2 WHERE NOT EXISTS (SELECT 0 FROM TheTable WITH (UPDLOCK, HOLDLOCK) WHERE PrimaryKey = @primaryKey)
MERGE INTO Target USING (VALUES (@primaryKey, @value1, @value2)) Source (key, value1, value2) ON Target.key = Source.key WHEN MATCHED THEN UPDATE SET value1 = Source.value1, value2 = Source.value2 WHEN NOT MATCHED BY TARGET THEN INSERT (Name, ReasonType) VALUES (@primaryKey, @value1, @value2)
BEGIN TRY INSERT etc END TRY BEGIN CATCH IF ERROR_NUMBER() <> 2627 BEGIN DECLARE @ErrorMessage NVARCHAR(4000); DECLARE @ErrorSeverity INT; DECLARE @ErrorState INT; SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(); RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState ); END END CATCH
DECLARE @existing varchar(10) SET @existing = (SELECT primaryKey FROM TABLE WHERE param1field = @param1 AND param2field = @param2) IF @existing is not null BEGIN INSERT INTO Table(param1Field, param2Field) VALUES(param1, param2) END ELSE Return 0 END
DELETE from Table WHERE Date > CAST(GETDATE() as DATE);
DELETE from Table WHERE Date > DATEDIFF(d, 0, GETDATE());
SELECT CONVERT(DATETIME, CONVERT(varchar(10), GETDATE(), 101))
DELETE from Table WHERE Date > CONVERT(VARCHAR, GETDATE(), 101);
create table insert into insert into insert into declare @tmp varchar(250) SET @tmp = select @tmp = @tmp + username + select SUBSTRING(@tmp, 0, LEN(@tmp))
select distinct stuff(( select from users u where u.username = username order by u.username for xml path( ),1,1, from users group by username
DECLARE @categories varchar(200) SET @categories = NULL SELECT @categories = COALESCE(@categories + FROM Production.ProductCategory SELECT @categories
DECLARE @categories varchar(200) SET @categories = SELECT @categories = @categories + FROM Production.ProductCategory SELECT @categories
DECLARE @categories varchar(200) SET @categories = NULL SELECT @categories = COALESCE(@categories + FROM Production.ProductCategory ORDER BY LEN(Name) SELECT @categories
SELECT FROM Production.ProductCategory ORDER BY LEN(Name) FOR XML PATH(
USE tempdb; GO CREATE TABLE t1 (id INT, NAME VARCHAR(MAX)); INSERT t1 values (1, INSERT t1 values (1, INSERT t1 values (1, INSERT t1 values (2, INSERT t1 values (2, GO select id, stuff(( select from t1 t where t.id = t1.id order by t.[name] for xml path( ),1,1, from t1 group by id ;
group, csv --drop table create table insert into insert into insert into select g1.groupname , stuff(( select from where g.groupName = g1.groupname order by g.username for xml path( ),1,2, from group by g1.groupname
DECLARE @test NVARCHAR(max) SELECT @test = COALESCE(@test + SELECT field2 = @test
DECLARE @EmployeeList varchar(100) SELECT @EmployeeList = COALESCE(@EmployeeList + CAST(Emp_UniqueID AS varchar(5)) FROM SalesCallsEmployees WHERE SalCal_UniqueID = 1 SELECT @EmployeeList
CREATE TABLE Beatles (id integer, name string ); INSERT INTO Beatles VALUES (1, "Paul"); INSERT INTO Beatles VALUES (2, "John"); INSERT INTO Beatles VALUES (3, "Ringo"); INSERT INTO Beatles VALUES (4, "George"); SELECT GROUP_CONCAT(name,
select EmployeeID, stuff(( SELECT FROM FPProjectInfo AS t INNER JOIN FPProjectMaster ON t.ProjectID = FPProjectMaster.ProjectID WHERE (t.EmployeeID = FPProjectInfo.EmployeeID) And t.STatusID = 1 ORDER BY t.ProjectID for xml path( ),1,1, from FPProjectInfo group by EmployeeID;
$hQuery = mysql_query("SELECT * FROM users"); while($hRow = mysql_fetch_array($hQuery)) { $hOut .= $hRow[ } $hOut = substr($hOut, 0, strlen($hOut) - 1); echo $hOut;
SELECT CONVERT(varchar, DATEADD(ms, 121.25 * 1000, 0), 114)
SELECT CONVERT(varchar, DATEADD(ms, 24*60*60 * 1000, 0), 114) 00:00:00:000
create function [dbo].[ConvertTimeToHHMMSS] ( @time decimal(28,3), @unit varchar(20) ) returns varchar(20) as begin declare @seconds decimal(18,3), @minutes int, @hours int; if(@unit = set @seconds = @time * 60 * 60; else if(@unit = set @seconds = @time * 60; else if(@unit = set @seconds = @time; else set @seconds = 0; -- unknown time units set @hours = convert(int, @seconds /60 / 60); set @minutes = convert(int, (@seconds / 60) - (@hours * 60 )); set @seconds = @seconds % 60; return convert(varchar(9), convert(int, @hours)) + right( right( end
select dbo.ConvertTimeToHHMMSS(123, select dbo.ConvertTimeToHHMMSS(96.999, select dbo.ConvertTimeToHHMMSS(35791394.999, 0:02:03.000 1:36:59.940 35791394:59:56.400
SELECT CONVERT(varchar, @seconds / 86400 ) + CONVERT(varchar, DATEADD(ms, ( @seconds % 86400 ) * 1000, 0), 114) as "Converted to D:HH:MM:SS.MS"
DECLARE @seconds AS int = 896434; SELECT CONVERT(varchar, (@seconds / 86400)) --Days + CONVERT(varchar, DATEADD(ss, @seconds, 0), 108); --Hours, Minutes, Seconds
declare @Seconds as int = 3600; SELECT CONVERT(time(0), DATEADD(SECOND, @Seconds, 0)) as
declare @OrigValue int; set @OrigValue = 121.25; select replace(str(@OrigValue/3600,len(ltrim(@OrigValue/3600))+abs(sign(@OrigValue/359999)-1)) +
SELECT substring(convert (varchar(23),Dateadd(s,10000,LEFT(getdate(),11)),121),12,8)
DECLARE @TimeinSecond INT SET @TimeinSecond = 340 -- Change the seconds SELECT RIGHT( RIGHT( RIGHT(
declare @time int, @hms varchar(20) set @time = 12345 set @hms = cast(cast((@Time)/3600 as int) as varchar(3)) + + select @hms
DECLARE @Seconds INT = 86200; SELECT CONVERT(VARCHAR(15), CAST(CONVERT(VARCHAR(12), @Seconds / 60 / 60 % 24) + +
create table t1 (id int, EndDate DATETIME) insert t1 (id, EndDate) values (1, GETDATE())
SELECT CONVERT(VARCHAR(10), GETDATE(), 103) -- dd/MM/yyyy format
Select Convert(DateTime, Convert(VarChar, GetDate(), 101))
declare @myDate date set @myDate = getdate() print cast(@myDate as varchar(10))
DECLARE @MyDate datetime -- ... set your datetime DATEADD(d, 1, @MyDate)
DECLARE @date DateTime SET @date = GetDate() SET @date = DateAdd(day, 1, @date) SELECT @date
Select getdate() -- 2010-02-05 10:03:44.527 -- To get all date format select CONVERT(VARCHAR(12),getdate(),100) + union select CONVERT(VARCHAR(10),getdate(),101) + Union select CONVERT(VARCHAR(10),getdate(),102) + Union select CONVERT(VARCHAR(10),getdate(),103) + Union select CONVERT(VARCHAR(10),getdate(),104) + Union select CONVERT(VARCHAR(10),getdate(),105) + Union select CONVERT(VARCHAR(11),getdate(),106) + Union select CONVERT(VARCHAR(12),getdate(),107) + union select CONVERT(VARCHAR(12),getdate(),109) + union select CONVERT(VARCHAR(12),getdate(),110) + union select CONVERT(VARCHAR(10),getdate(),111) + union select CONVERT(VARCHAR(12),getdate(),112) + union select CONVERT(VARCHAR(12),getdate(),113) + SELECT convert(varchar, getdate(), 20) -- 2010-02-05 10:25:14 SELECT convert(varchar, getdate(), 23) -- 2010-02-05 SELECT convert(varchar, getdate(), 24) -- 10:24:20 SELECT convert(varchar, getdate(), 25) -- 2010-02-05 10:24:34.913 SELECT convert(varchar, getdate(), 21) -- 2010-02-05 10:25:02.990 ---================================== -- To get the time select CONVERT(VARCHAR(12),getdate(),108) + select CONVERT(VARCHAR(12),getdate(),114) + SELECT convert(varchar, getdate(), 22) -- 02/05/10 10:23:11 AM ----============================================= SELECT getdate()+1 SELECT month(getdate())+1 SELECT year(getdate())+1
DECLARE @table1 TABLE ( col1 int ) INSERT into @table1 SELECT col1 FROM table2
DECLARE cursor1 CURSOR FOR SELECT col1 FROM table2 OPEN cursor1 FETCH NEXT FROM cursor1
DECLARE @RowsToProcess int DECLARE @CurrentRow int DECLARE @SelectCol1 int DECLARE @table1 TABLE (RowID int not null primary key identity(1,1), col1 int ) INSERT into @table1 (col1) SELECT col1 FROM table2 SET @RowsToProcess=@@ROWCOUNT SET @CurrentRow=0 WHILE @CurrentRow<@RowsToProcess BEGIN SET @CurrentRow=@CurrentRow+1 SELECT @SelectCol1=col1 FROM @table1 WHERE RowID=@CurrentRow --do your thing here-- END
DECLARE @table1 TABLE ( idx int identity(1,1), col1 int ) DECLARE @counter int SET @counter = 1 WHILE(@counter < SELECT MAX(idx) FROM @table1) BEGIN DECLARE @colVar INT SELECT @colVar = col1 FROM @table1 WHERE idx = @counter -- Do your work here SET @counter = @counter + 1 END
DECLARE @RowsToProcess int; DECLARE @table1 TABLE (RowID int not null primary key identity(1,1), col1 int ) INSERT into @table1 (col1) SELECT col1 FROM table2 SET @RowsToProcess = @@ROWCOUNT WHILE @RowsToProcess > 0 -- Countdown BEGIN SELECT * FROM @table1 WHERE RowID=@RowsToProcess --do your thing here-- SET @RowsToProcess = @RowsToProcess - 1; -- Countdown END
DECLARE @vTable TABLE (IdRow int not null primary key identity(1,1),ValueRow int); -------Initialize--------- insert into @vTable select 345; insert into @vTable select 795; insert into @vTable select 565; --------------------------- DECLARE @cnt int = 1; DECLARE @max int = (SELECT MAX(IdRow) FROM @vTable); WHILE @cnt <= @max BEGIN DECLARE @tempValueRow int = (Select ValueRow FROM @vTable WHERE IdRow = @cnt); ---work demo---- print print print -------------- set @cnt = @cnt+1; END
DECLARE @vTable TABLE (ValueRow int); -------Initialize--------- insert into @vTable select 345; insert into @vTable select 795; insert into @vTable select 565; --------------------------- DECLARE @cnt int = 1; DECLARE @max int = (select count(*) from @vTable); WHILE @cnt <= @max BEGIN DECLARE @tempValueRow int = ( select ValueRow from (select ValueRow , ROW_NUMBER() OVER(ORDER BY (select 1)) as RowId from @vTable ) T1 where t1.RowId = @cnt ); ---work demo---- print print print -------------- set @cnt = @cnt+1; END
declare @table1 table(dataKey int, dataCol1 varchar(20), dataCol2 datetime) declare @dataKey int while exists select begin select top 1 @dataKey = dataKey from @table1 order by dataCol2 desc -- do processing delete from @table1 where dataKey = @dataKey end
DECLARE @LoopId int ,@MyData varchar(100) DECLARE @CheckThese TABLE ( LoopId int not null identity(1,1) ,MyData varchar(100) not null ) INSERT @CheckThese (YourData) select MyData from MyTable order by DoesItMatter SET @LoopId = @@rowcount WHILE @LoopId > 0 BEGIN SELECT @MyData = MyData from @CheckThese where LoopId = @LoopId -- Do whatever SET @LoopId = @LoopId - 1 END
DECLARE @table1 TABLE ( col1 int ) INSERT into @table1 SELECT col1 FROM table2 DECLARE cursor1 CURSOR FOR @table1 OPEN cursor1 FETCH NEXT FROM cursor1
DECLARE cursor1 CURSOR FOR SELECT col1 FROM @table1 OPEN cursor1 FETCH NEXT FROM cursor1
declare @id int SELECT @id = min(fPat.PatientID) FROM tbPatients fPat WHERE (fPat.InsNotes is not null AND DataLength(fPat.InsNotes)>0) while @id is not null begin SELECT fPat.PatientID, fPat.InsNotes FROM tbPatients fPat WHERE (fPat.InsNotes is not null AND DataLength(fPat.InsNotes)>0) AND fPat.PatientID=@id SELECT @id = min(fPat.PatientID) FROM tbPatients fPat WHERE (fPat.InsNotes is not null AND DataLength(fPat.InsNotes)>0)AND fPat.PatientID>@id end
CREATE PROCEDURE PrintSequenceSeries -- Add the parameters for the stored procedure here @ComaSeperatedSequenceSeries nVarchar(MAX) AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; DECLARE @SERIES_COUNT AS INTEGER SELECT @SERIES_COUNT = COUNT(*) FROM PARSE_COMMA_DELIMITED_INTEGER(@ComaSeperatedSequenceSeries, DECLARE @CURR_COUNT AS INTEGER SET @CURR_COUNT = 1 DECLARE @SQL AS NVARCHAR(MAX) WHILE @CURR_COUNT <= @SERIES_COUNT BEGIN SET @SQL = PRINT @SQL EXEC SP_EXECUTESQL @SQL SET @CURR_COUNT = @CURR_COUNT + 1 END;
CREATE FUNCTION [dbo].[parse_comma_delimited_integer] ( @LIST VARCHAR(8000), @DELIMITER VARCHAR(10) = ' ) -- TABLE VARIABLE THAT WILL CONTAIN VALUES RETURNS @TABLEVALUES TABLE ( ITEM INT ) AS BEGIN DECLARE @ITEM VARCHAR(255) WHILE (DATALENGTH(@LIST) > 0) BEGIN IF CHARINDEX(@DELIMITER,@LIST) > 0 BEGIN SELECT @ITEM = SUBSTRING(@LIST,1,(CHARINDEX(@DELIMITER, @LIST)-1)) SELECT @LIST = SUBSTRING(@LIST,(CHARINDEX(@DELIMITER, @LIST) + DATALENGTH(@DELIMITER)),DATALENGTH(@LIST)) END ELSE BEGIN SELECT @ITEM = @LIST SELECT @LIST = NULL END -- INSERT EACH ITEM INTO TEMP TABLE INSERT @TABLEVALUES ( ITEM ) SELECT ITEM = CONVERT(INT, @ITEM) END RETURN END
ALTER TABLE [TheTable] DROP CONSTRAINT [TheDefaultConstraint]
SELECT OBJECT_NAME(parent_object_id) AS TableName, name AS ConstraintName FROM sys.default_constraints ORDER BY TableName, ConstraintName
SELECT OBJECT_NAME(id) AS TableName, OBJECT_NAME(constid) AS ConstraintName FROM sysconstraints ORDER BY TableName, ConstraintName
DECLARE @tableName VARCHAR(MAX) = DECLARE @columnName VARCHAR(MAX) = DECLARE @ConstraintName nvarchar(200) SELECT @ConstraintName = Name FROM SYS.DEFAULT_CONSTRAINTS WHERE PARENT_OBJECT_ID = OBJECT_ID(@tableName) AND PARENT_COLUMN_ID = ( SELECT column_id FROM sys.columns WHERE NAME = @columnName AND object_id = OBJECT_ID(@tableName)) IF @ConstraintName IS NOT NULL EXEC(
declare @constraints varchar(4000); declare @sql varchar(4000); with table_id_column_position as ( select object_id table_id, column_id column_position from sys.columns where object_id is not null and object_id = object_id( ) select @constraints = coalesce(@constraints, from sysobjects where ( -- is CHECK constraint type = -- dependeds on the column and id is not null and id in ( select object_id --, object_name(object_id) from sys.sql_dependencies, table_id_column_position where object_id is not null and referenced_major_id = table_id_column_position.table_id and referenced_minor_id = table_id_column_position.column_position ) ) OR ( -- is DEFAULT constraint type = and id is not null and id in ( select object_id from sys.default_constraints, table_id_column_position where object_id is not null and parent_object_id = table_id_column_position.table_id and parent_column_id = table_id_column_position.column_position ) ); set @sql = exec @sql
CREATE PROCEDURE uspParameterSniffingAvoidance @SniffedFormalParameter int AS BEGIN DECLARE @SniffAvoidingLocalParameter int SET @SniffAvoidingLocalParameter = @SniffedFormalParameter --Work w/ @SniffAvoidingLocalParameter in sproc body -- ...
UPDATE q SET country = a.country FROM quantity q JOIN acronym a ON a.acronym = q.country
DECLARE @UTCDateTime DATETIME = GETUTCDATE(); DECLARE @ConvertedZoneDateTime DATETIME; -- SET @ConvertedZoneDateTime = @UTCDateTime AT TIME ZONE SELECT @UTCDateTime AS UTCDATE,@ConvertedZoneDateTime AS IndiaStandardTime -- SET @UTCDateTime = @ConvertedZoneDateTime AT TIME ZONE SELECT @ConvertedZoneDateTime AS IndiaStandardTime,@UTCDateTime AS UTCDATE
DECLARE @utcNow DATETIMEOFFSET = CONVERT(DATETIMEOFFSET, SYSUTCDATETIME()) DECLARE @utcToday DATE = CONVERT(DATE, @utcNow); DECLARE @utcTomorrow DATE = DATEADD(D, 1, @utcNow); SELECT @utcToday [today] ,@utcTomorrow [tomorrow] ,@utcNow [utcNow]
if (typeof Date.fromISOString != Date.fromISOString = function(input) { var date = new Date(input); if (!isNaN(date)) return date; if (typeof input !== "string" || input.length < 10 || input.length > 40) return null; var iso8601Format = /^(\d{4})-(\d{2})-(\d{2})((([T ](\d{2}):(\d{2})(:(\d{2})(\.(\d{1,12}))?)?)?)?)?([Zz]|([-+])(\d{2})\:?(\d{2}))?$/; var input = input.toString().replace(/^\s+/, if (!iso8601Format.test(input)) return null; var d = input.match(iso8601Format); var offset = 0; date = new Date(+d[1], +d[2]-1, +d[3], +d[7] || 0, +d[8] || 0, +d[10] || 0, Math.round(+("0." + (d[12] || 0)) * 1000)); if (d[13] == else if (d[13]) offset = ((parseInt(d[15],10) * 60) + (parseInt(d[16],10)) * ((d[14] == date.setTime(date.getTime() + (offset * 60000)); if (date.getTime() <= new Date(-62135571600000).getTime()) return null; return date; }; }
SELECT Getdate=GETDATE() ,SysDateTimeOffset=SYSDATETIMEOFFSET() ,SWITCHOFFSET=SWITCHOFFSET(SYSDATETIMEOFFSET(),0) ,GetutcDate=GETUTCDATE() GO
Getdate SysDateTimeOffset SWITCHOFFSET GetutcDate 2013-12-06 15:54:55.373 2013-12-06 15:54:55.3765498 -08:00 2013-12-06 23:54:55.3765498 +00:00 2013-12-06 23:54:55.373
WITH NumberedMyTable AS ( SELECT Id, Value, ROW_NUMBER() OVER (ORDER BY Id) AS RowNumber FROM MyTable ) SELECT Id, Value FROM NumberedMyTable WHERE RowNumber BETWEEN @From AND @To
select * from ( select Row_Number() over (order by ClusteredIndexField) as RowNumber, * from MyTable ) as PagedTable where RowNumber between @LowestRowNumber and @HighestRowNumber;
select * from ( select Row_Number() over (order by Field1 asc, Field2 asc, Field3 asc) as RowNumber, ClusteredIndexField from MyTable ) as PagedTable left join MyTable on MyTable.ClusteredIndexField = PagedTable.ClusteredIndexField where RowNumber between @LowestRowNumber and @HighestRowNumber;
-- For a sproc, make these your input parameters declare @PageSize int = 50, @Page int = 15619; -- For a sproc, make these your output parameters declare @RecordCount int = (select count(*) from MyTable); declare @PageCount int = ceiling(convert(float, @RecordCount) / @PageSize); declare @Offset int = (@Page - 1) * @PageSize; declare @LowestRowNumber int = @Offset; declare @HighestRowNumber int = @Offset + @PageSize - 1; select @RecordCount as RecordCount, @PageCount as PageCount, @Offset as Offset, @LowestRowNumber as LowestRowNumber, @HighestRowNumber as HighestRowNumber; select * from ( select Row_Number() over (order by Field1 asc, Field2 asc, Field3 asc) as RowNumber, ClusteredIndexField from MyTable ) as PagedTable left join MyTable on MyTable.ClusteredIndexField = PagedTable.ClusteredIndexField where RowNumber between @LowestRowNumber and @HighestRowNumber;
SELECT * FROM MyTable ORDER BY MyColumn OFFSET @N ROWS FETCH NEXT @M ROWS ONLY;
DECLARE @CurrentSetNumber int = 0; DECLARE @NumRowsInSet int = 2; SELECT * FROM MyTable ORDER BY MyColumn OFFSET @NumRowsInSet * @CurrentSetNumber ROWS FETCH NEXT @NumRowsInSet ROWS ONLY; SET @CurrentSetNumber = @CurrentSetNumber + 1;
select TOP 100 * from TableName where PrimaryKeyField NOT IN(Select TOP 24 PrimaryKeyField from TableName);
select top(M + N - 1) * from TableName except select top(N - 1) * from TableName
SELECT * FROM (SELECT TOP (N) * FROM (SELECT TOP (M + N - 1) FROM Table ORDER BY MyColumn) qasc ORDER BY MyColumn DESC) qdesc ORDER BY MyColumn
-- *some* implementations may support this syntax (mysql?) SELECT Id,Value FROM xxx ORDER BY Id LIMIT 2 , 0 ; -- Separate LIMIT, OFFSET SELECT Id,Value FROM xxx ORDER BY Id LIMIT 2 OFFSET 2 ; -- SQL-2008 syntax SELECT Id,Value FROM xxx ORDER BY Id OFFSET 4 FETCH NEXT 2 ROWS ONLY ;
@start = 3 @records = 2 Select ID, Value From (SELECT ROW_NUMBER() OVER(ORDER BY ID) AS RowNum, ID,Value From MyTable) as sub Where sub.RowNum between @start and @start+@records
SELECT * FROM Sales.SalesOrderDetail ORDER BY SalesOrderDetailID OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY; GO
select * from table order by [some_column] offset 10 rows FETCH NEXT 10 rows only
Select Top N B.PrimaryKeyColumn from (SELECT top M PrimaryKeyColumn FROM MyTable ) A right outer join MyTable B on A.PrimaryKeyColumn = B.PrimaryKeyColumn where A.PrimaryKeyColumn IS NULL
select * from ( select row_number() over(order by (select 0)) rowNum,* from your_table ) tmp where tmp.rowNum between 20 and 30 -- any numbers you need
select * from ( select (((ROW_NUMBER() OVER(ORDER BY MyField) - 1) / 500) + 1) AS PageNum , * from MyTable ) as PagedTable where PageNum = 4;
SELECT TOP numberYouWantToTake [yourColumns...] FROM yourTable WHERE yourIDColumn NOT IN ( SELECT TOP numberYouWantToSkip yourIDColumn FROM yourTable ORDER BY yourOrderColumn ) ORDER BY yourOrderColumn
IEnumerable<yourDataType> yourSelectedData = yourDataInAnIEnumerable.Skip(nubmerYouWantToSkip).Take(numberYouWantToTake);
select top(M+N-1) * from table into temp tmp_final with no log; select top(N-1) * from tmp_final order by id desc;
SELECT * FROM ( SELECT Row_Number() Over (Order by (Select 1)) as RawKey, * FROM [Alzh].[dbo].[DM_THD_TRANS_FY14] ) AS foo WHERE RawKey between 17210400 and 17210500
SELECT orderdetails.sku, orderdetails.mf_item_number, orderdetails.qty, orderdetails.price, supplier.supplierid, supplier.suppliername, supplier.dropshipfees, cost = (SELECT supplier_item.price FROM supplier_item, orderdetails, supplier WHERE supplier_item.sku = orderdetails.sku AND supplier_item.supplierid = supplier.supplierid) FROM orderdetails, supplier, group_master WHERE invoiceid = AND orderdetails.mfr_id = supplier.supplierid AND group_master.sku = orderdetails.sku
select od.Sku, od.mf_item_number, od.Qty, od.Price, s.SupplierId, s.SupplierName, s.DropShipFees, si.Price as cost from OrderDetails od inner join Supplier s on s.SupplierId = od.Mfr_ID inner join Group_Master gm on gm.Sku = od.Sku inner join Supplier_Item si on si.SKU = od.Sku and si.SupplierId = s.SupplierID where od.invoiceid =
ALTER TABLE your_table DISABLE TRIGGER [the_trigger_name] UPDATE your_table SET Gender = WHERE (Gender = ALTER TABLE your_table ENABLE TRIGGER [the_trigger_name]
select column from table where columns_name in ( select column from table where columns_name =
cost = Select Supplier_Item.Price from Supplier_Item,orderdetails,Supplier where Supplier_Item.SKU=OrderDetails.Sku and Supplier_Item.SupplierId=Supplier.SupplierID
SELECT * from ( SELECT count(*) as c, Supplier_Item.SKU FROM Supplier_Item INNER JOIN orderdetails ON Supplier_Item.sku = orderdetails.sku INNER JOIN Supplier ON Supplier_item.supplierID = Supplier.SupplierID GROUP BY Supplier_Item.SKU ) x WHERE c > 1 ORDER BY c DESC
select CompanyName from Customers where CustomerID in ( select CustomerID from Orders where year(OrderDate) =
select CompanyName from Customers where CustomerID = ( select CustomerID from Orders where year(OrderDate) =
(Select Supplier_Item.Price from Supplier_Item,orderdetails,Supplier where Supplier_Item.SKU=OrderDetails.Sku and Supplier_Item.SupplierId=Supplier.SupplierID )
(Select Supplier_Item.Price from Supplier_Item where Supplier_Item.SKU=OrderDetails.Sku and Supplier_Item.SupplierId=Supplier.SupplierID )
select OrderDetails.Sku, OrderDetails.mf_item_number, OrderDetails.Qty, OrderDetails.Price, Supplier.SupplierId, Supplier.SupplierName, Supplier.DropShipFees, Supplier_Item.Price as cost from OrderDetails join Supplier on OrderDetails.Mfr_ID = Supplier.SupplierId join Group_Master on Group_Master.Sku = OrderDetails.Sku join Supplier_Item on Supplier_Item.SKU=OrderDetails.Sku and Supplier_Item.SupplierId=Supplier.SupplierID where invoiceid=
Cannot execute script: Insufficient memory to continue the execution of the program
SQLCMD -S TestSQLServer\SQLEXPRESS -d AdventureWorks2018 -i "d:\document\sql document\script.sql"
SQLCMD -S TestSQLServer\SQLEXPRESS -U sa -P sasa -d AdventureWorks2018 -i "d:\document\sql document\script.sql"
sqlcmd -S PCNAME\SQLEXPRESS -U user -P password -d databanse_name -i C:\script.sql
sqlcmd -S "(localdb)\MSSQLLocalDB" -d dbname -i file.sql
sqlcmd -s Server_name -d Database_name -E -i c:\Temp\Recovery_script.sql -x
Select * from [User] U where convert(varchar(10),U.DateCreated, 120) =
SELECT * FROM [User] U WHERE CAST(U.DateCreated as DATE) =
SELECT * FROM [User] U WHERE CAST(U.DateCreated as DATE) =
SELECT CONVERT(DATE,GETDATE()) OR Select * from [User] U where CONVERT(DATE,U.DateCreated) =
SELECT * FROM [User] U WHERE CONVERT(VARCHAR, U.DateCreated, 120) LIKE
select * from [User] U where convert(varchar(10),U.DateCreated, 120) =
ORDER BY ISNULL(Next_Contact_Date, 0) ORDER BY ISNULL(Next_Contact_Date, 999999999) ORDER BY coalesce(Next_Contact_Date, 99/99/9999)
ORDER BY CASE WHEN Next_Contact_Date IS NULL THEN 1 ELSE 0 END, Next_Contact_Date
SELECT 1 AS Grp, Next_Contact_Date FROM T WHERE Next_Contact_Date IS NOT NULL UNION ALL SELECT 2 AS Grp, Next_Contact_Date FROM T WHERE Next_Contact_Date IS NULL ORDER BY Grp, Next_Contact_Date
ORDER BY CASE WHEN Next_Contact_Date IS NULL THEN 1 ELSE 0 END, Next_Contact_Date;
ORDER BY IIF(Next_Contact_Date IS NULL, 1, 0), Next_Contact_Date;
CREATE TRIGGER FILL_SORTABLE_DATE ON YOUR_TABLE AFTER INSERT,UPDATE AS BEGIN SET NOCOUNT ON; IF (update(Next_Contact_Date)) BEGIN UPDATE YOUR_TABLE SET Next_Contact_Date_Sort=IIF(YOUR_TABLE.Next_Contact_Date IS NULL, 99/99/9999, YOUR_TABLE.Next_Contact_Date_Sort) FROM inserted i WHERE YOUR_TABLE.key1=i.key1 AND YOUR_TABLE.key2=i.key2 END END
ORDER BY Next_Contact_Date IS NULL, Next_Contact_Date
ORDER BY Next_Contact_Date IS NOT NULL, Next_Contact_Date
select * from (select null v union all select 1 v union all select 2 v) t order by -t.v desc
USE mydb GO ALTER ROLE db_datareader ADD MEMBER MYUSER GO ALTER ROLE db_datawriter ADD MEMBER MYUSER GO
use mydb go exec sp_addrolemember db_datareader, MYUSER go exec sp_addrolemember db_datawriter, MYUSER go
GRANT EXECUTE ON dbo.sp_mystoredprocedure TO MYUSER;
use mydb go ALTER ROLE db_datareader ADD MEMBER MYUSER go ALTER ROLE db_datawriter ADD MEMBER MYUSER go
GRANT EXECUTE TO db_SomeExecutor GRANT INSERT TO db_SomeExecutor
string table= "\"" + table.Replace(" string var= "`" + var.Replace(" string index= " " + index.Replace(" string query = "select * from `"+table+"` where name=\""+var+"\" or id="+index
string userPassword= userPassword.Replace(" string userName= userInput.Replace(" userName = substr(userName,0,10) string query = "select * from users where name=
string badValue = ((char)0x02BC).ToString(); badValue = badValue + ";delete from widgets--"; string sql = "SELECT * FROM WIDGETS WHERE ID=" + badValue.Replace(" TestTheSQL(sql);
tabledata: personid 1 firstname "Carl" lastname "Anderson" addressindex 1 personid 2 firstname "Carl Peter" lastname "Anderson" addressindex 1
Row personid addressindex lastname firstname 1 2 1 Anderson Carl Peter 2 1 1 Anderson Carl .....
if object_id( select a.id, ( select top 1 x.id from MyTable x where x.id <> a.id order by dbo.GetSimilarityScore(a.MyField, x.MyField) desc ) as MostSimilarId into from MyTable a select *, dbo.GetSimilarityScore(a.MyField, c.MyField) from MyTable a join join MyTable c on b.MostSimilarId = c.id
<Microsoft.SqlServer.Server.SqlFunction()> _ Public Shared Function ComputeLevenstheinDistance(ByVal string1 As SqlString, ByVal string2 As SqlString) As SqlInt32 If string1.IsNull OrElse string2.IsNull Then Return SqlInt32.Null Dim s1 As String = string1.Value Dim s2 As String = string2.Value Dim n As Integer = s1.Length Dim m As Integer = s2.Length Dim d As Integer(,) = New Integer(n, m) {} If n = 0 Then Return m If m = 0 Then Return n For i As Integer = 0 To n d(i, 0) = i Next For j As Integer = 0 To m d(0, j) = j Next For i As Integer = 1 To n For j As Integer = 1 To m Dim cost As Integer = If((s2(j - 1) = s1(i - 1)), 0, 1) d(i, j) = Math.Min(Math.Min(d(i - 1, j) + 1, d(i, j - 1) + 1), d(i - 1, j - 1) + cost) Next Next Return d(n, m) End Function <Microsoft.SqlServer.Server.SqlFunction()> _ Public Shared Function GetSimilarityScore(string1 As SqlString, string2 As SqlString) As SqlDouble If string1.IsNull OrElse string2.IsNull Then Return SqlInt32.Null Dim s1 As String = string1.Value.ToUpper().TrimEnd(" "c) Dim s2 As String = string2.Value.ToUpper().TrimEnd(" "c) If s1 = s2 Then Return 1.0F Dim flatLevScore As Double = InternalGetSimilarityScore(s1, s2) Dim letterS1 As String = GetLetterSimilarityString(s1) Dim letterS2 As String = GetLetterSimilarityString(s2) Dim letterScore As Double = InternalGetSimilarityScore(letterS1, letterS2) If flatLevScore = 1.0F AndAlso letterScore = 1.0F Then Return 1.0F If flatLevScore = 0.0F AndAlso letterScore = 0.0F Then Return 0.0F Return (flatLevScore * 0.2F) + (letterScore * 0.8F) End Function Private Shared Function InternalGetSimilarityScore(s1 As String, s2 As String) As Double Dim dist As SqlInt32 = ComputeLevenstheinDistance(s1, s2) Dim maxLen As Integer = If(s1.Length > s2.Length, s1.Length, s2.Length) If maxLen = 0 Then Return 1.0F Return 1.0F - Convert.ToDouble(dist.Value) / Convert.ToDouble(maxLen) End Function Private Shared Function GetLetterSimilarityString(s1 As String) As String Dim allChars = If(s1, "").ToUpper().ToCharArray() Array.Sort(allChars) Dim result As New StringBuilder() For Each ch As Char In allChars If Char.IsLetterOrDigit(ch) Then result.Append(ch) End If Next Return result.ToString() End Function Private Shared Function GetWordSimilarityString(s1 As String) As String Dim words As New List(Of String)() Dim curWord As StringBuilder = Nothing For Each ch As Char In If(s1, "").ToUpper() If Char.IsLetterOrDigit(ch) Then If curWord Is Nothing Then curWord = New StringBuilder() End If curWord.Append(ch) Else If curWord IsNot Nothing Then words.Add(curWord.ToString()) curWord = Nothing End If End If Next If curWord IsNot Nothing Then words.Add(curWord.ToString()) End If words.Sort(StringComparer.OrdinalIgnoreCase) Return String.Join(" ", words.ToArray()) End Function
create table person( personid int identity(1,1) primary key, firstname varchar(20), lastname varchar(20), addressindex int, sound varchar(10) )
create trigger trigoninsert for dbo.person on insert as declare @personid int; select @personid=personid from inserted; update person set sound=soundex(firstname) where personid=@personid;
create procedure getfuzzi(@personid int) as declare @sound varchar(10); set @sound=(select sound from person where personid=@personid; select personid,firstname,lastname,addressindex from person where sound=@sound
--WEB LISTING 1: Double Metaphone Script ------------------------------------- IF OBJECT_ID( GO; CREATE FUNCTION fnIsVowel( @c char(1) ) RETURNS bit AS BEGIN IF (@c = BEGIN RETURN 1 END -- RETURN 0 END GO; ----------------------------------------------- IF OBJECT_ID( END GO; CREATE FUNCTION fnSlavoGermanic( @Word char(50) ) RETURNS bit AS BEGIN --Catch NULL also... IF (CHARINDEX( (CHARINDEX( -- -- OR (CHARINDEX( BEGIN RETURN 1 END --ELSE RETURN 0 END GO; --------------------------------------------------------------------------------------------------------------------------------- ---------------------- --Lawrence Philips calls for a length argument, but this has two drawbacks: --1. All target strings must be of the same length --2. It presents an opportunity for subtle bugs, ie fnStringAt( 1, 7, --So I --DEFAULTS suck with UDFs. Have to specify DEFAULT in caller - why bother? IF OBJECT_ID( GO; CREATE FUNCTION fnStringAtDef( @Start int, @StringToSearch varchar(50), @Target1 varchar(50), @Target2 varchar(50) = NULL, @Target3 varchar(50) = NULL, @Target4 varchar(50) = NULL, @Target5 varchar(50) = NULL, @Target6 varchar(50) = NULL ) RETURNS bit AS BEGIN IF CHARINDEX(@Target1,@StringToSearch,@Start) > 0 RETURN 1 --2 Styles, test each optional argument for NULL, nesting further tests --or just take advantage of CHARINDEX behavior with a NULL arg (unless 65 compatibility - code check before CREATE FUNCTION? --Style 1: --IF @Target2 IS NOT NULL --BEGIN -- IF CHARINDEX(@Target2,@StringToSearch,@Start) > 0 RETURN 1 -- (etc.) --END --Style 2: IF CHARINDEX(@Target2,@StringToSearch,@Start) > 0 RETURN 1 IF CHARINDEX(@Target3,@StringToSearch,@Start) > 0 RETURN 1 IF CHARINDEX(@Target4,@StringToSearch,@Start) > 0 RETURN 1 IF CHARINDEX(@Target5,@StringToSearch,@Start) > 0 RETURN 1 IF CHARINDEX(@Target6,@StringToSearch,@Start) > 0 RETURN 1 RETURN 0 END GO; ------------------------------------------------------------------------------------------------- IF OBJECT_ID( GO; CREATE FUNCTION fnStringAt( @Start int, @StringToSearch varchar(50), @TargetStrings varchar(2000) ) RETURNS bit AS BEGIN DECLARE @SingleTarget varchar(50) DECLARE @CurrentStart int DECLARE @CurrentLength int --Eliminate special cases --Trailing space is needed to check for end of word in some cases, so always append comma --loop tests should fairly quickly ignore SET @TargetStrings = @TargetStrings + SET @CurrentStart = 1 --Include terminating comma so spaces don SET @CurrentLength = (CHARINDEX( @CurrentStart) + 1 SET @SingleTarget = SUBSTRING(@TargetStrings,@CurrentStart,@CurrentLength) WHILE LEN(@SingleTarget) > 1 BEGIN IF SUBSTRING(@StringToSearch,@Start,LEN(@SingleTarget)-1) = LEFT(@SingleTarget,LEN(@SingleTarget)-1) BEGIN RETURN 1 END SET @CurrentStart = (@CurrentStart + @CurrentLength) SET @CurrentLength = (CHARINDEX( @CurrentStart) + 1 IF NOT @CurrentLength > 1 --getting trailing comma BEGIN BREAK END SET @SingleTarget = SUBSTRING(@TargetStrings,@CurrentStart,@CurrentLength) END RETURN 0 END GO; ------------------------------------------------------------------------ IF OBJECT_ID( fnDoubleMetaphoneTable END GO; CREATE FUNCTION fnDoubleMetaphoneTable( @Word varchar(50) ) RETURNS @DMP TABLE ( Metaphone1 char(4), Metaphone2 char(4) ) AS BEGIN DECLARE @MP1 varchar(4), @MP2 varchar(4) SET @MP1 = SET @MP2 = DECLARE @CurrentPosition int, @WordLength int, @CurrentChar char(1) SET @CurrentPosition = 1 SET @WordLength = LEN(@Word) IF @WordLength < 1 BEGIN RETURN END --ensure case insensitivity SET @Word = UPPER(@Word) IF dbo.fnStringAt(1, @Word, BEGIN SET @CurrentPosition = @CurrentPosition + 1 END IF BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 1 END WHILE (4 > LEN(RTRIM(@MP1))) OR (4 > LEN(RTRIM(@MP2))) BEGIN IF @CurrentPosition > @WordLength BEGIN BREAK END SET @CurrentChar = SUBSTRING(@Word,@CurrentPosition,1) IF @CurrentChar IN( BEGIN IF @CurrentPosition = 1 BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 1 END ELSE IF @CurrentChar = BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + IF BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END ELSE IF @CurrentChar = BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 1 END ELSE IF @CurrentChar = BEGIN --various germanic IF (@CurrentPosition > 2) AND (dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition-2,1))=0) AND (dbo.fnStringAt(@CurrentPosition-1,@Word, AND ((SUBSTRING(@Word,@CurrentPosition+2,1) <> AND ((SUBSTRING(@Word,@CurrentPosition+2,1) <> (dbo.fnStringAt(@CurrentPosition-2,@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END -- ELSE IF (@CurrentPosition = 1) AND (dbo.fnStringAt(@CurrentPosition,@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END -- ELSE IF dbo.fnStringAt(@CurrentPosition,@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END ELSE IF dbo.fnStringAt(@CurrentPosition,@Word, BEGIN -- Find IF (@CurrentPosition > 1) AND (dbo.fnStringAt(@CurrentPosition,@Word, BEGIN --First instance of alternate encoding SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END --greek roots e.g. ELSE IF (@CurrentPosition = 1) AND (dbo.fnStringAt(2, @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END --germanic, greek, or otherwise ELSE IF ((dbo.fnStringAt(1,@Word, (dbo.fnStringAt(@CurrentPosition- 2,@Word, (dbo.fnStringAt(@CurrentPosition+2,@Word, (((dbo.fnStringAt(@CurrentPosition-1,@Word, OR (@CurrentPosition = 1)) AND (dbo.fnStringAt(@CurrentPosition+2,@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN --is this a given? IF (@CurrentPosition > 1) BEGIN IF (dbo.fnStringAt(1,@Word, BEGIN --eg McHugh SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN --Alternate encoding SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 2 END END --e.g, ELSE IF (dbo.fnStringAt(@CurrentPosition,@Word, (dbo.fnStringAt((@CurrentPosition - 2),@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END --e.g., ELSE IF(dbo.fnStringAt((@CurrentPosition + 1),@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 3 END --double ELSE IF(dbo.fnStringAt(@CurrentPosition,@Word, ((@CurrentPosition = 2) AND (LEFT(@Word,1) = -- IF (dbo.fnStringAt((@CurrentPosition + 2),@Word, (dbo.fnStringAt((@CurrentPosition + 2),@Word, BEGIN -- IF (((@CurrentPosition = 2) AND (SUBSTRING(@Word,@CurrentPosition - 1,1) = OR (dbo.fnStringAt((@CurrentPosition - 1),@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END -- ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 3 END --Pierce ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END ELSE IF (dbo.fnStringAt(@CurrentPosition,@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END ELSE IF (dbo.fnStringAt(@CurrentPosition,@Word, BEGIN --italian vs. english IF (dbo.fnStringAt(@CurrentPosition,@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + --name sent in IF (dbo.fnStringAt((@CurrentPosition + 1),@Word, BEGIN SET @CurrentPosition = @CurrentPosition + 3 END ELSE BEGIN IF (dbo.fnStringAt((@CurrentPosition + 1),@Word, AND (dbo.fnStringAt((@CurrentPosition + 1), 2, BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END END END ELSE IF @CurrentChar = BEGIN IF (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN IF (dbo.fnStringAt((@CurrentPosition + 2),@Word, BEGIN --e.g. SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 3 END ELSE BEGIN --e.g. SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END END ELSE IF (dbo.fnStringAt(@CurrentPosition,@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 1 END END ELSE IF @CurrentChar = BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE IF @CurrentChar = BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN IF (@CurrentPosition > 1) AND (dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition - 1,1)) = 0) BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END -- ELSE IF (@CurrentPosition = 1) BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 2,1) = BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 2 END --Parker ELSE IF (((@CurrentPosition > 2) AND (dbo.fnStringAt((@CurrentPosition - 2),@Word, --e.g., OR ((@CurrentPosition > 3) AND (dbo.fnStringAt((@CurrentPosition - 3),@Word, --e.g., OR ((@CurrentPosition > 4) AND (dbo.fnStringAt((@CurrentPosition - 4),@Word, BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN --e.g., IF ((@CurrentPosition > 3) AND (SUBSTRING(@Word,@CurrentPosition - 1,1) = AND (dbo.fnStringAt((@CurrentPosition - 3),@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN IF ((@CurrentPosition > 1) AND SUBSTRING(@Word,@CurrentPosition - 1,1) <> BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END SET @CurrentPosition = @CurrentPosition + 2 END END ELSE IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN IF ((@CurrentPosition = 2) AND (dbo.fnIsVowel(LEFT(@Word,1))=1) AND (dbo.fnSlavoGermanic(@Word)=0)) BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN --not e.g. IF ((dbo.fnStringAt((@CurrentPosition + 2),@Word, AND (SUBSTRING(@Word,@CurrentPosition + 1,1) <>
BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END SET @CurrentPosition = @CurrentPosition + 2 END -- ELSE IF (dbo.fnStringAt((@CurrentPosition + 1),@Word, (dbo.fnSlavoGermanic(@Word)=0) BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END -- -ges-,-gep-,-gel-, -gie- at beginning -- This call to fnStringAt() is the -- a multi-valued argument would require ten DEFAULT arguments for EP, EB, EL, etc. (assuming the first was not defined with a DEFAULT). ELSE IF ((@CurrentPosition = 1) AND ((SUBSTRING(@Word,@CurrentPosition + 1,1) = OR (dbo.fnStringAt((@CurrentPosition + 1),@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END -- -ger-, -gy- ELSE IF (((dbo.fnStringAt((@CurrentPosition + 1), @Word, (SUBSTRING(@Word,@CurrentPosition + 1,1) = AND (dbo.fnStringAt(1, @Word, AND (dbo.fnStringAt((@CurrentPosition - 1), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END -- italian e.g, ELSE IF (dbo.fnStringAt((@CurrentPosition + 1),@Word, (dbo.fnStringAt((@CurrentPosition - 1),@Word, BEGIN --obvious germanic IF ((dbo.fnStringAt(1,@Word, OR (dbo.fnStringAt((@CurrentPosition + 1),@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN --always soft if french ending IF (dbo.fnStringAt((@CurrentPosition + 1),@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END ELSE IF @CurrentChar = BEGIN --only keep if first & before vowel or btw. 2 vowels IF (((@CurrentPosition = 1) OR (dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition - 1,1))=1)) AND (dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition + 1,1))=1)) BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END --also takes care of ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END ELSE IF @CurrentChar = BEGIN --obvious spanish, IF (dbo.fnStringAt(@CurrentPosition,@Word, (dbo.fnStringAt(1,@Word, BEGIN IF (((@CurrentPosition = 1) AND (SUBSTRING(@Word,@CurrentPosition + 4,1) = BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 1 END ELSE IF ((@CurrentPosition = 1) AND (dbo.fnStringAt(@CurrentPosition,@Word, BEGIN SET @MP1 = @MP1 + --Yankelovich/Jankelowicz SET @MP2 = @MP2 + --it could happen! IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END ELSE BEGIN --spanish pron. of e.g. IF( (dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition - 1,1))=1) AND (dbo.fnSlavoGermanic(@Word)=0) AND ((SUBSTRING(@Word,@CurrentPosition + 1,1) = (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN IF (@CurrentPosition = @WordLength) BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN IF ((dbo.fnStringAt((@CurrentPosition + 1), @Word, AND (dbo.fnStringAt((@CurrentPosition - 1), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END END --it could happen! IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END END ELSE IF @CurrentChar = BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE IF @CurrentChar = BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN --spanish e.g. IF (((@CurrentPosition = (@WordLength - 3)) AND (dbo.fnStringAt((@CurrentPosition - 1),@Word, OR (((dbo.fnStringAt((@WordLength - 1),@Word, OR (dbo.fnStringAt(@WordLength,@Word, AND (dbo.fnStringAt((@CurrentPosition - 1),@Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 2 SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END ELSE IF @CurrentChar = BEGIN -- IF (((dbo.fnStringAt((@CurrentPosition - 1), @Word, AND (((@CurrentPosition + 1) = @WordLength) OR (dbo.fnStringAt((@CurrentPosition + 2),@Word, OR (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE IF @CurrentChar = BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE IF @CurrentChar = BEGIN SET @CurrentPosition = @CurrentPosition + 1 SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE IF @CurrentChar = BEGIN --What about Michelle Pfeiffer, star of Grease 2? Price-Pfister?, Pfizer? --Don --Sorry, Mark Knopfler, I don IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = OR ((@CurrentPosition = 1) AND (SUBSTRING(@Word,@CurrentPosition + 1,1) = (dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition+2,1))=1)) BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END --also account for "campbell", "raspberry" ELSE BEGIN IF (dbo.fnStringAt((@CurrentPosition + 1),@Word, BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END ELSE IF @CurrentChar = BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE IF @CurrentChar = BEGIN --QQ: Will SQL short circuit eval? Otherwise, I could try to read before string begins here... --french e.g. IF ((@CurrentPosition = @WordLength) AND (dbo.fnSlavoGermanic(@Word)=0) AND (dbo.fnStringAt((@CurrentPosition - 2), @Word, AND (dbo.fnStringAt((@CurrentPosition - 4), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END ELSE IF @CurrentChar = BEGIN --special cases IF (dbo.fnStringAt((@CurrentPosition - 1), @Word, BEGIN SET @CurrentPosition = @CurrentPosition + 1 END --special case ELSE IF ((@CurrentPosition = 1) AND (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 1 END ELSE IF (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN --germanic IF (dbo.fnStringAt((@CurrentPosition + 1), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 2 END --italian & armenian ELSE IF (dbo.fnStringAt(@CurrentPosition, @Word, (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN IF (dbo.fnSlavoGermanic(@Word)=0) BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 3 END --german & anglicisations, e.g. --also, -sz- in slavic language altho in hungarian it is pronounced ELSE IF (((@CurrentPosition = 1) AND (dbo.fnStringAt((@CurrentPosition + 1), @Word, OR (dbo.fnStringAt((@CurrentPosition + 1), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + IF (dbo.fnStringAt((@CurrentPosition + 1), @Word, BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END ELSE IF (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN --Schlesinger IF (SUBSTRING(@Word,@CurrentPosition + 2,1) = BEGIN --dutch origin, e.g. IF (dbo.fnStringAt((@CurrentPosition + 3), @Word, BEGIN -- IF (dbo.fnStringAt((@CurrentPosition + 3), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 3 END ELSE BEGIN IF ((@CurrentPosition = 1) AND (dbo.fnIsVowel(SUBSTRING(@Word,3,1))=0) AND (SUBSTRING(@Word,3,1) <> BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 3 END END ELSE IF (dbo.fnStringAt((@CurrentPosition + 2), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 3 END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 3 END END ELSE BEGIN --french e.g. IF ((@CurrentPosition = @WordLength) AND (dbo.fnStringAt((@CurrentPosition - 2), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END IF (dbo.fnStringAt((@CurrentPosition + 1), @Word, BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END END ELSE IF @CurrentChar = BEGIN IF (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 3 END ELSE IF (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN --special case IF (dbo.fnStringAt((@CurrentPosition + 2), @Word, OR (dbo.fnStringAt(1, @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN IF (dbo.fnStringAt((@CurrentPosition + 1), @Word, BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END END ELSE IF @CurrentChar = BEGIN IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE IF @CurrentChar = BEGIN --can also be in middle of word IF (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END ELSE IF ((@CurrentPosition = 1) AND ((dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition + 1,1))=1) OR (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN --Wasserman should match Vasserman IF (dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition + 1,1))=1) BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN --need Uomo to match Womo SET @MP1 = @MP1 + SET @MP2 = @MP2 + END SET @CurrentPosition = @CurrentPosition + 1 END --Arnow should match Arnoff ELSE IF (((@CurrentPosition = @WordLength) AND (dbo.fnIsVowel(SUBSTRING(@Word,@CurrentPosition - 1,1))=1)) OR (dbo.fnStringAt((@CurrentPosition - 1), @Word, OR (dbo.fnStringAt(1, @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 1 END --polish e.g. ELSE IF (dbo.fnStringAt(@CurrentPosition, @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 4 END -- skip it ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END ELSE IF @CurrentChar = BEGIN --french e.g. breaux IF (NOT((@CurrentPosition = @WordLength) AND ((dbo.fnStringAt((@CurrentPosition - 3), @Word, OR (dbo.fnStringAt((@CurrentPosition - 2), @Word, BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END IF (dbo.fnStringAt((@CurrentPosition + 1), @Word, BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END ELSE IF @CurrentChar = BEGIN --chinese pinyin e.g. IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN IF ((dbo.fnStringAt((@CurrentPosition + 1), @Word, OR ((dbo.fnSlavoGermanic(@Word)=1) AND ((@CurrentPosition > 1) AND SUBSTRING(@Word,@CurrentPosition - 1,1) <> BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END ELSE BEGIN SET @MP1 = @MP1 + SET @MP2 = @MP2 + END IF (SUBSTRING(@Word,@CurrentPosition + 1,1) = BEGIN SET @CurrentPosition = @CurrentPosition + 2 END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END END ELSE BEGIN SET @CurrentPosition = @CurrentPosition + 1 END END --only give back 4 char metaphone IF (LEN(@MP1) > 4) BEGIN SET @MP1 = LEFT(@MP1, 4) END IF (LEN(@MP2) > 4) BEGIN SET @MP2 = LEFT(@MP2, 4) END IF @MP2 = @MP1 BEGIN SET @MP2 = END INSERT @DMP(Metaphone1,Metaphone2) VALUES( @MP1, @MP2 ) RETURN END GO; ------------------------------------------------------------------------ IF OBJECT_ID( fnDoubleMetaphoneScalar END GO; CREATE FUNCTION fnDoubleMetaphoneScalar( @MetaphoneType int, @Word varchar(50) ) RETURNS char(4) AS BEGIN RETURN (SELECT CASE @MetaphoneType WHEN 1 THEN Metaphone1 WHEN 2 THEN Metaphone2 END FROM fnDoubleMetaphoneTable( @Word )) END
SELECT Region FROM employees WHERE Region = @region
create table ID int not null, Val1 varchar(10) null ) insert into create table ID int not null, Val1 varchar(10) null ) insert into select * from
SET ANSI_NULLS OFF select * from sys.tables where principal_id = Null
SET ANSI_NULLS ON select * from sys.tables where principal_id = Null
DECLARE @TempVariable VARCHAR(10) SET @TempVariable = NULL SET ANSI_NULLS ON SELECT -- IF ANSI_NULLS ON , RETURNS ZERO ROWS SET ANSI_NULLS OFF SELECT -- IF ANSI_NULLS OFF , THERE WILL BE ROW !
SELECT T.name AS Table_Name , C.name AS Column_Name , P.name AS Data_Type , P.max_length AS Size , CAST(P.precision AS VARCHAR) + FROM sys.objects AS T JOIN sys.columns AS C ON T.object_id = C.object_id JOIN sys.types AS P ON C.system_type_id = P.system_type_id WHERE T.type_desc =
SELECT TABLE_SCHEMA , TABLE_NAME , COLUMN_NAME , ORDINAL_POSITION , COLUMN_DEFAULT , DATA_TYPE , CHARACTER_MAXIMUM_LENGTH , NUMERIC_PRECISION , NUMERIC_PRECISION_RADIX , NUMERIC_SCALE , DATETIME_PRECISION FROM INFORMATION_SCHEMA.COLUMNS;
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE=
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=
Select * From INFORMATION_SCHEMA.COLUMNS Where TABLE_CATALOG Like
Select * From INFORMATION_SCHEMA.COLUMNS Where TABLE_CATALOG Like
PRINT SET NOCOUNT ON DECLARE @tableName VARCHAR(30) DECLARE tableCursor CURSOR LOCAL FAST_FORWARD FOR SELECT T.name AS TableName FROM sys.objects AS T WHERE T.type_desc = ORDER BY T.name OPEN tableCursor FETCH NEXT FROM tableCursor INTO @tableName WHILE @@FETCH_STATUS = 0 BEGIN PRINT PRINT SELECT LEFT(C.name, 30) AS ColumnName, LEFT(ISC.DATA_TYPE, 10) AS DataType, C.max_length AS Size, CAST(P.precision AS VARCHAR(4)) + CASE WHEN C.is_nullable = 1 THEN LEFT(ISNULL(ISC.COLUMN_DEFAULT, CASE WHEN C.is_identity = 1 THEN FROM sys.objects AS T JOIN sys.columns AS C ON T.object_id = C.object_id JOIN sys.types AS P ON C.system_type_id = P.system_type_id JOIN INFORMATION_SCHEMA.COLUMNS AS ISC ON T.name = ISC.TABLE_NAME AND C.name = ISC.COLUMN_NAME WHERE T.type_desc = AND T.name = @tableName ORDER BY T.name, ISC.ORDINAL_POSITION PRINT FETCH NEXT FROM tableCursor INTO @tableName END CLOSE tableCursor DEALLOCATE tableCursor SET NOCOUNT OFF PRINT
Select * from Information_Schema.Columns Where Table_Name =
Select * From INFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA = "<DatabaseName>"
declare @database nvarchar(25) set @database = SELECT cu.table_catalog,cu.VIEW_SCHEMA, cu.VIEW_NAME, cu.TABLE_NAME, cu.COLUMN_NAME,c.DATA_TYPE,c.character_maximum_length from INFORMATION_SCHEMA.VIEW_COLUMN_USAGE as cu JOIN INFORMATION_SCHEMA.COLUMNS as c on cu.TABLE_SCHEMA = c.TABLE_SCHEMA and c.TABLE_CATALOG = cu.TABLE_CATALOG and c.TABLE_NAME = cu.TABLE_NAME and c.COLUMN_NAME = cu.COLUMN_NAME where cu.TABLE_CATALOG = @database order by cu.view_name,c.COLUMN_NAME
SELECT ..., MIN(SomeBitField), ... FROM ... WHERE ... GROUP BY ...
SELECT ..., CAST(MIN(CAST(SomeBitField AS INT)) AS BIT), ... FROM ... WHERE ... GROUP BY ...
SELECT CASE WHEN EXISTS (SELECT 1 FROM ....) THEN 1 ELSE 0 END AS FROM ... WHERE ...
SELECT ..., MIN(case when SomeBitField=1 then 1 else 0 end), MIN(SomeBitField+0)... FROM ... WHERE ... GROUP BY ...
SELECT CASE WHEN MIN(BitField+0) = 1 THEN FROM MyTable
select convert(bit, min(convert(int, somebitfield)))
CONVERT(BIT, MIN(CONVERT(INT, BitField))) as BitField
USE AdventureWorks2012; GO BEGIN TRANSACTION; GO IF @@TRANCOUNT = 0 BEGIN SELECT FirstName, MiddleName FROM Person.Person WHERE LastName = ROLLBACK TRANSACTION; PRINT N END; ROLLBACK TRANSACTION; PRINT N GO
if exists (select * from sys.procedures where name = drop procedure sp_test create procedure sp_test as begin select 1 end
if exists (select * from sys.procedures where name = drop procedure sp_test GO create procedure sp_test as begin select 1 end
INSERT INTO MyTable (...) ... GO 10 -- run all the above 10 times!
create procedure [procedurename] (parameters) as begin select prefname, lastname from people end go grant execute on [procedurename] to [username]
DECLARE @id INT DECLARE @name NVARCHAR(100) DECLARE @getid CURSOR SET @getid = CURSOR FOR SELECT table.id, table.name FROM table OPEN @getid FETCH NEXT FROM @getid INTO @id, @name WHILE @@FETCH_STATUS = 0 BEGIN EXEC stored_proc @varName=@id, @otherVarName= FETCH NEXT FROM @getid INTO @id, @name END CLOSE @getid DEALLOCATE @getid
create procedure test as BEGIN create table ( rn int, id int ) insert into select distinct row_number() over(order by id) as rn, id from table declare @id int declare @totalrows int = (select count(*) from declare @currentrow int = 0 while @currentrow < @totalrows begin set @id = (select id from exec stored_proc @varName=@id, @otherVarName= set @currentrow = @currentrow +1 end END
/********** example 1 **********/ declare @au_id char( 11 ) set rowcount 0 select * into set rowcount 1 select @au_id = au_id from while @@rowcount <> 0 begin set rowcount 0 select * from delete set rowcount 1 select @au_id = au_id from end set rowcount 0 /********** example 2 **********/ declare @au_id char( 11 ) select @au_id = min( au_id ) from authors while @au_id is not null begin select * from authors where au_id = @au_id select @au_id = min( au_id ) from authors where au_id > @au_id end /********** example 3 **********/ set rowcount 0 select NULL mykey, * into set rowcount 1 update while @@rowcount > 0 begin set rowcount 0 select * from delete set rowcount 1 update end set rowcount 0
DECLARE @id INT DECLARE @name NVARCHAR(100) DECLARE @getid CURSOR SET @getid = CURSOR FOR SELECT table.id, table.name FROM table WHILE 1=1 BEGIN FETCH NEXT FROM @getid INTO @id, @name IF @@FETCH_STATUS < 0 BREAK EXEC stored_proc @varName=@id, @otherVarName= END CLOSE @getid DEALLOCATE @getid
declare @i tinyint = 0, @count tinyint, @id int, @name varchar(max) select @count = count(*) from table while (@i < @count) begin select @id = id, @name = name from table order by nr asc offset @i rows fetch next 1 rows only exec stored_proc @varName = @id, @otherVarName = set @i = @i + 1 end
+----+---------+-------------------+-------------+ | id | title | email | commentname | +----+---------+-------------------+-------------+ | 3 | test | rob@hotmail.com | rob | | 4 | i agree | rob@hotmail.com | rob | | 5 | its ok | rob@hotmail.com | rob | | 6 | hey | rob@hotmail.com | rob | | 7 | nice! | simon@hotmail.com | simon | | 8 | yeah | john@hotmail.com | john | +----+---------+-------------------+-------------+
+----+-------+-------------------+-------------+ | id | title | email | commentname | +----+-------+-------------------+-------------+ | 3 | test | rob@hotmail.com | rob | | 7 | nice! | simon@hotmail.com | simon | | 8 | yeah | john@hotmail.com | john | +----+-------+-------------------+-------------+
SELECT a.* FROM emails a INNER JOIN (SELECT email, MIN(id) as id FROM emails GROUP BY email ) AS b ON a.email = b.email AND a.id = b.id;
select id, title, email, commentname from ( select *, row_number() over (partition by email order by id) as RowNbr from YourTable ) source where RowNbr = 1
;WITH ue(id) AS ( SELECT MAX(id) FROM table GROUP BY email ) SELECT * FROM table t INNER JOIN ue ON ue.id = t.id
select Closing_Date, Category, COUNT(Status)TotalCount from MyTable where Closing_Date >= and Defect_Status1 is not null group by Closing_Date, Category
SELECT Closing_Date = DATEADD(MONTH, DATEDIFF(MONTH, 0, Closing_Date), 0), Category, COUNT(Status) TotalCount FROM MyTable WHERE Closing_Date >= AND Closing_Date <= AND Defect_Status1 IS NOT NULL GROUP BY DATEADD(MONTH, DATEDIFF(MONTH, 0, Closing_Date), 0), Category;
SELECT Closing_Year = DATEPART(YEAR, Closing_Date), Closing_Month = DATEPART(MONTH, Closing_Date), Category, COUNT(Status) TotalCount FROM MyTable WHERE Closing_Date >= AND Closing_Date <= AND Defect_Status1 IS NOT NULL GROUP BY DATEPART(YEAR, Closing_Date), DATEPART(MONTH, Closing_Date), Category;
SELECT DATEPART(month, Closing_Date) AS Closing_Month, COUNT(Status) AS TotalCount FROM t GROUP BY DATEPART(month, Closing_Date)
select FORMAT(Closing_Date, , count(*) cc FROM MyTable WHERE Defect_Status1 IS NOT NULL AND Closing_Date >= AND Closing_Date < GROUP BY FORMAT(Closing_Date, ORDER BY Closing_Month
SELECT Closing_Date, Category, COUNT(Status)TotalCount FROM MyTable WHERE Closing_Date >= AND Defect_Status1 IS NOT NULL GROUP BY MONTH(Closing_Date), Category
SELECT to_char(Closing_Date, Category, COUNT(Status) TotalCount FROM MyTable WHERE Closing_Date >= AND Closing_Date <= AND Defect_Status1 IS NOT NULL GROUP BY Category;
select Closing_Date, Category, COUNT(Status)TotalCount from MyTable where Closing_Date >= and Defect_Status1 is not null group by Year(Closing_Date), Month(Closing_Date), Category
SELECT Closing_Date = DATEADD(MONTH, DATEDIFF(MONTH, 0, Closing_Date), 0), Category, COUNT(Status) TotalCount FROM MyTable WHERE Closing_Date >= AND Closing_Date <= AND Defect_Status1 IS NOT NULL GROUP BY DATEADD(MONTH, DATEDIFF(MONTH, 0, Closing_Date), 0), Category;
CREATE TABLE [dbo].[Visualizations] ( VisualizationID int identity (1,1) NOT NULL )
INSERT INTO [Visualizations]; INSERT INTO [Visualizations] () VALUES ();
SELECT * FROM Member WHERE DATEPART(m, date_created) = DATEPART(m, DATEADD(m, -1, getdate())) AND DATEPART(yyyy, date_created) = DATEPART(yyyy, DATEADD(m, -1, getdate()))
WHERE date_created >= @startOfPreviousMonth AND date_created < @startOfCurrentMonth
DATEADD(month, DATEDIFF(month, 0, CURRENT_TIMESTAMP), 0)
DECLARE @startOfCurrentMonth DATETIME SET @startOfCurrentMonth = DATEADD(month, DATEDIFF(month, 0, CURRENT_TIMESTAMP), 0) SELECT * FROM Member WHERE date_created >= DATEADD(month, -1, @startOfCurrentMonth) -- this was originally misspelled AND date_created < @startOfCurrentMonth
DECLARE @StartDate DATETIME, @EndDate DATETIME SET @StartDate = dateadd(mm, -1, getdate()) SET @StartDate = dateadd(dd, datepart(dd, getdate())*-1, @StartDate) SET @EndDate = dateadd(mm, 1, @StartDate) SELECT * FROM Member WHERE date_created BETWEEN @StartDate AND @EndDate
DECLARE @StartDate DATETIME, @EndDate DATETIME SET @StartDate = DATEADD(mm, DATEDIFF(mm,0,getdate())-1, 0) SET @EndDate = DATEADD(mm, 1, @StartDate) SELECT * FROM Member WHERE date_created BETWEEN @StartDate AND @EndDate
select field1, field2, fieldN from TABLE where DATEPART(month, date_created) = 4 and DATEPART(year, date_created) = 2009
select field1, field2, fieldN from TABLE where DATEPART(month, date_created) = (DATEPART(month, GETDATE()) - 1) and DATEPART(year, date_created) = DATEPART(year, DATEADD(m, -1, GETDATE()))
declare @PrevMonth as nvarchar(256) SELECT @PrevMonth = DateName( month,DATEADD(mm, DATEDIFF(mm, 0, getdate()) - 1, 0)) +
SELECT CONVERT(DATE, DATEADD(DAY,-DAY(GETDATE()),GETDATE()))
select * from [member] where DatePart("m", date_created) = DatePart("m", DateAdd("m", -1, getdate())) AND DatePart("yyyy", date_created) = DatePart("yyyy", DateAdd("m", -1, getdate()))
DECLARE @StartDate DATETIME, @EndDate DATETIME SET @StartDate = DATEADD(mm, DATEDIFF(mm, 0, getdate()) - 1, 0) SET @EndDate = dateadd(dd, -1, DATEADD(mm, 1, @StartDate)) SELECT * FROM Member WHERE date_created BETWEEN @StartDate AND @EndDate
WHERE date_created >= DATEADD(MONTH, DATEDIFF(MONTH, 31, CURRENT_TIMESTAMP), 0) AND date_created < DATEADD(MONTH, DATEDIFF(MONTH, 0, CURRENT_TIMESTAMP), 0)
select * from table where trunc(somedatefield, trunc(sysdate -INTERVAL
SELECT * FROM CUSTOMER WHERE MONTH(DATE) = MONTH(CURRENT_TIMESTAMP) AND YEAR(DATE) = YEAR(CURRENT_TIMESTAMP);
SELECT * FROM dbo.member d WHERE CONVERT(DATE, date_created,101)>=CONVERT(DATE,DATEADD(m, datediff(m, 0, current_timestamp)-1, 0)) and CONVERT(DATE, date_created,101) < CONVERT(DATE, DATEADD(m, datediff(m, 0, current_timestamp)-1, 0),101)
select * from tablename where order_date > DateAdd(WEEK, -1, GETDATE()+1) and order_date<=GETDATE()
DECLARE @curDate INT = datepart( Month,GETDATE()) IF (@curDate = 1) BEGIN select * from Featured_Deal where datepart( Month,Created_Date)=12 AND datepart(Year,Created_Date) = (datepart(Year,GETDATE())-1) END ELSE BEGIN select * from Featured_Deal where datepart( Month,Created_Date)=(datepart( Month,GETDATE())-1) AND datepart(Year,Created_Date) = datepart(Year,GETDATE()) END
DECLARE @StartDate DATETIME, @EndDate DATETIME SET @StartDate = dateadd(mm, -1, getdate()) SET @StartDate = dateadd(dd, datepart(dd, getdate())*-1, @StartDate) SET @EndDate = dateadd(mm, 1, @StartDate) set @StartDate = DATEADD(dd, 1 , @StartDate)
Create Trigger dbo.MyTableTrigger ON dbo.MyTable, After Insert, Update As Begin If NOT Exists(select PK from OtherDB.dbo.TableName where PK in (Select FK from inserted) BEGIN -- Handle the Referential Error Here END END
CREATE FUNCTION dbo.fn_db2_schema2_tb_A (@column1 INT) RETURNS BIT AS BEGIN DECLARE @exists bit = 0 IF EXISTS ( SELECT TOP 1 1 FROM DB2.SCHEMA2.tb_A WHERE COLUMN_KEY_1 = @COLUMN1 ) BEGIN SET @exists = 1 END; RETURN @exists END GO ALTER TABLE db1.schema1.tb_S ADD CONSTRAINT CHK_S_key_col1_in_db2_schema2_tb_A CHECK(dbo.fn_db2_schema2_tb_A(key_col1) = 1)
/****** Object: View [dbo].[vProductImages] Script Date: 04/28/2008 16:59:05 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE VIEW [dbo].[vProductImages] AS SELECT dbo.Products_Images.ProductID, dbo.Images.ThumbUrl, dbo.Images.FullImageUrl FROM dbo.Products_Images INNER JOIN dbo.Images ON dbo.Products_Images.ImageID = dbo.Images.ImageID GO EXEC sys.sp_addextendedproperty @name=N Begin DesignProperties = Begin PaneConfigurations = Begin PaneConfiguration = 0 NumPanes = 4 Configuration = "(H (1[40] 4[20] 2[20] 3) )" End Begin PaneConfiguration = 1 NumPanes = 3 Configuration = "(H (1 [50] 4 [25] 3))" End Begin PaneConfiguration = 2 NumPanes = 3 Configuration = "(H (1 [50] 2 [25] 3))" End Begin PaneConfiguration = 3 NumPanes = 3 Configuration = "(H (4 [30] 2 [40] 3))" End Begin PaneConfiguration = 4 NumPanes = 2 Configuration = "(H (1 [56] 3))" End Begin PaneConfiguration = 5 NumPanes = 2 Configuration = "(H (2 [66] 3))" End Begin PaneConfiguration = 6 NumPanes = 2 Configuration = "(H (4 [50] 3))" End Begin PaneConfiguration = 7 NumPanes = 1 Configuration = "(V (3))" End Begin PaneConfiguration = 8 NumPanes = 3 Configuration = "(H (1[56] 4[18] 2) )" End Begin PaneConfiguration = 9 NumPanes = 2 Configuration = "(H (1 [75] 4))" End Begin PaneConfiguration = 10 NumPanes = 2 Configuration = "(H (1[66] 2) )" End Begin PaneConfiguration = 11 NumPanes = 2 Configuration = "(H (4 [60] 2))" End Begin PaneConfiguration = 12 NumPanes = 1 Configuration = "(H (1) )" End Begin PaneConfiguration = 13 NumPanes = 1 Configuration = "(V (4))" End Begin PaneConfiguration = 14 NumPanes = 1 Configuration = "(V (2))" End ActivePaneConfig = 0 End Begin DiagramPane = Begin Origin = Top = 0 Left = 0 End Begin Tables = Begin Table = "Products_Images" Begin Extent = Top = 6 Left = 38 Bottom = 99 Right = 208 End DisplayFlags = 280 TopColumn = 0 End Begin Table = "Images" Begin Extent = Top = 6 Left = 246 Bottom = 116 Right = 416 End DisplayFlags = 280 TopColumn = 0 End End End Begin SQLPane = End Begin DataPane = Begin ParameterDefaults = "" End Begin ColumnWidths = 9 Width = 284 Width = 1500 Width = 1500 Width = 1500 Width = 1500 Width = 1500 Width = 1500 Width = 1500 Width = 1500 End End Begin CriteriaPane = Begin ColumnWidths = 11 Column = 1440 Alias = 900 Table = 1170 Output = 720 Append = 1400 NewValue = 1170 SortType = 1350 SortOrder = 1410 GroupBy = 1350 Filter = 1350 Or = 1350 Or = 1350 Or = 1350 End End End GO EXEC sys.sp_addextendedproperty @name=N GO
select convert(datetime, Msg 242, Level 16, State 3, Line 1 The conversion of a char data type to a datetime data type resulted in an out-of-range datetime value
DECLARE @Date char(8) set @Date= SELECT CONVERT(datetime,RIGHT(@Date,4)+LEFT(@Date,2)+SUBSTRING(@Date,3,2))
----------------------- 2009-12-31 00:00:00.000 (1 row(s) affected)
BEGIN DECLARE @input VARCHAR(8), @mon CHAR(2), @day char(2), @year char(4), @output DATETIME SET @input = SELECT @mon = LEFT(@input, 2), @day = SUBSTRING(@input, 3,2), @year = RIGHT(@input,4) SELECT @output = @year+@mon+@day SELECT @output END
BEGIN DECLARE @input CHAR(8), @output DATETIME SET @input = SELECT @output = RIGHT(@input,4) + SUBSTRING(@input, 3,2) + LEFT(@input, 2) SELECT @output END
declare @date char(8) set @date = select convert(datetime, substring(@date,5,4) + substring(@date,1,2) + substring(@date,3,2),112)
DECLARE @dt VARCHAR(100)= SELECT CONVERT(DATETIME,STUFF(STUFF(@dt,3,0,
DECLARE @DateString VARCHAR(10) = SELECT TRY_CONVERT(DATETIME,@DateString) SET @DateString = SELECT TRY_CONVERT(DATETIME,@DateString)
DECLARE @foo varchar(200) SET @foo = IF NULLIF(@foo, BEGIN -- To fix this line, remove one "E" to read RAISERROR RAISEERROR( RETURN -- This is required otherwise execution will continue! END -- You need the RETURN above or this will execute SELECT Critical_TSqlLine = 1;
SELECT STOVE.Type + STOVE.Version AS , COUNT(*) AS FROM STOVE GROUP BY STOVE.Type + STOVE.Version WITH ROLLUP;
SELECT InvoiceDt , COUNT(InvoiceNbr) AS FROM INVOICE GROUP BY InvoiceDt WITH ROLLUP ORDER BY InvoiceDt ASC;
YEAR, MONTH, DAY YEAR, MONTH YEAR, DAY YEAR MONTH, DAY MONTH DAY ()
SELECT * INTO FROM ( SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT )TAB
SELECT * FROM UNION ALL SELECT PERIOD,NAME,SUM(MARKS) TOTAL FROM GROUP BY NAME,PERIOD WITH ROLLUP HAVING PERIOD IS NULL AND NAME IS NOT NULL
SELECT * FROM UNION ALL SELECT PERIOD,NAME,SUM(MARKS) TOTAL FROM GROUP BY PERIOD,NAME WITH ROLLUP HAVING PERIOD IS NOT NULL AND NAME IS NULL
SELECT PERIOD,NAME,SUM(MARKS) TOTAL FROM GROUP BY NAME,PERIOD WITH CUBE HAVING PERIOD IS NOT NULL OR NAME IS NOT NULL
SELECT CASE WHEN PERIOD IS NULL THEN CASE WHEN NAME IS NULL THEN SUM(MARKS) MARKS INTO FROM GROUP BY NAME,PERIOD WITH CUBE DECLARE @cols NVARCHAR (MAX) SELECT @cols = COALESCE (@cols + FROM (SELECT DISTINCT PERIOD FROM ORDER BY PERIOD DECLARE @query NVARCHAR(MAX) SET @query = ( SELECT * FROM ) x PIVOT ( SUM(MARKS) FOR [PERIOD] IN ( ) p; EXEC SP_EXECUTESQL @query
TRUNCATE TABLE table_name DELETE FROM table_name WHERE some_condition
BEGIN TRANSACTION; BEGIN TRY -- Truncate below will take LCK_M_SCH_S lock for TABLE_A TRUNCATE TABLE TABLE_A -- Lets say the query below takes 5 hours to execute INSERT INTO TABLE_A SELECT * FROM GIANT_TABLE (NOLOCK) END TRY BEGIN CATCH IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION; THROW END CATCH IF @@TRANCOUNT > 0 COMMIT TRANSACTION;
TRUNCATE TABLE table_name; -- Command(s) completed successfully.
$connection = $this->getEntityManager()->getConnection(); $connection->exec("Truncate TABLE <tablename>;");
SELECT * FROM Venue WHERE Name COLLATE Latin1_general_CI_AI Like
SELECT * FROM Venue WHERE Name COLLATE Latin1_General_CI_AI Like
SELECT * FROM Venue WHERE Name COLLATE Latin1_general_CI_AI Like
SELECT * FROM table1, table2 WHERE table1.yr =* table2.yr -1
SELECT * FROM table2 LEFT OUTER JOIN table1 ON table1.yr = table2.yr - 1
SELECT * FROM table1, table2 WHERE table1.yr =* table2.yr -1
SELECT * FROM table2 LEFT OUTER JOIN table1 ON table1.yr = (table2.yr - 1)
SELECT * FROM TableA FULL OUTER JOIN TableB ON TableA.name = TableB.name
SELECT * FROM TableA FULL JOIN TableB ON TableA.name = TableB.name
SELECT * FROM table WHERE Col IN (123,123,222,....)
Select * From table Where Col IN (123,123,222,....) or Col IN (456,878,888,....)
CREATE TYPE IdTable AS TABLE (Id INT NOT NULL PRIMARY KEY)
CREATE PROCEDURE sp__Procedure_Name @OrderIDs IdTable READONLY, AS SELECT * FROM table WHERE Col IN (SELECT Id FROM @OrderIDs)
CREATE TABLE SomeTempTable AS SELECT YourColumn FROM SomeTable WHERE UserPickedMultipleRecordsFromSomeListOrSomething
SELECT * FROM OtherTable WHERE YourColumn IN ( SELECT YourColumn FROM SomeTempTable )
Select * from tbl1 WHERE [TextCol] NOT LIKE OR [TextCol] IS NULL
21 >= 18 -- True 15 >= 18 -- False NULL >= 18 -- Unknown
WHERE CASE WHEN [TextCol] IS NULL THEN ELSE [TextCol] END NOT LIKE
select * from Dest where id in(select id from Source) select * from Dest where id NOT in(select id from Source)
select * from Dest where isnull(id,-2) in(select isnull(id,-1) from Source) select * from Dest where isnull(id,-2) NOT in(select isnull(id,-1) from Source)
ID | TeamID | UserID | ElementID | PhaseID | Effort ----------------------------------------------------- 1 | 1 | 1 | 3 | 5 | 6.74 2 | 1 | 1 | 3 | 6 | 8.25 3 | 1 | 1 | 4 | 1 | 2.23 4 | 1 | 1 | 4 | 5 | 6.8 5 | 1 | 1 | 4 | 6 | 1.5
ElementID | PhaseID1 | PhaseID5 | PhaseID6 -------------------------------------------- 3 | NULL | 6.74 | 8.25 4 | 2.23 | 6.8 | 1.5
create table temp ( id int, teamid int, userid int, elementid int, phaseid int, effort decimal(10, 5) ) insert into temp values (1,1,1,3,5,6.74) insert into temp values (2,1,1,3,6,8.25) insert into temp values (3,1,1,4,1,2.23) insert into temp values (4,1,1,4,5,6.8) insert into temp values (5,1,1,4,6,1.5) select elementid , [1] as phaseid1 , [5] as phaseid5 , [6] as phaseid6 from ( select elementid, phaseid, effort from temp ) x pivot ( max(effort) for phaseid in([1], [5], [6]) )p
DECLARE @cols AS NVARCHAR(MAX), @query AS NVARCHAR(MAX); select @cols = STUFF((SELECT distinct FROM temp c FOR XML PATH( ).value( ,1,1, set @query = ( select elementid, phaseid, effort from temp ) x pivot ( max(effort) for phaseid in ( ) p ' execute(@query)
ELEMENTID PHASEID1 PHASEID5 PHASEID6 3 Null 6.74 8.25 4 2.23 6.8 1.5
SELECT PRODUCT, FRED, KATE FROM ( SELECT CUST, PRODUCT, QTY FROM Product) up PIVOT (SUM(QTY) FOR CUST IN (FRED, KATE)) AS pvt ORDER BY PRODUCT
PRODUCT FRED KATE -------------------- BEER 24 12 MILK 3 1 SODA NULL 6 VEG NULL 5
ALTER DATABASE [dbname] SET COMPATIBILITY_LEVEL = 100
SELECT <non-pivoted column>, [first pivoted column] AS <column name>, [second pivoted column] AS <column name>, ... [last pivoted column] AS <column name> FROM (<SELECT query that produces the data>) AS <alias for the source query> PIVOT ( <aggregation function>(<column being aggregated>) FOR [<column that contains the values that will become column headers>] IN ( [first pivoted column], [second pivoted column], ... [last pivoted column]) ) AS <alias for the pivot table> <optional ORDER BY clause>; USE AdventureWorks2008R2 ; GO SELECT DaysToManufacture, AVG(StandardCost) AS AverageCost FROM Production.Product GROUP BY DaysToManufacture; DaysToManufacture AverageCost 0 5.0885 1 223.88 2 359.1082 4 949.4105 -- Pivot table with one row and five columns SELECT [0], [1], [2], [3], [4] FROM (SELECT DaysToManufacture, StandardCost FROM Production.Product) AS SourceTable PIVOT ( AVG(StandardCost) FOR DaysToManufacture IN ([0], [1], [2], [3], [4]) ) AS PivotTable; Here is the result set. Cost_Sorted_By_Production_Days 0 1 2 3 4 AverageCost 5.0885 223.88 359.1082 NULL 949.4105
SELECT CUST, MILK FROM Product -- FROM (SELECT CUST, Product, QTY FROM PRODUCT) p PIVOT ( SUM(QTY) FOR PRODUCT IN (MILK) ) AS pvt ORDER BY CUST
SELECT CUST, sum(MILK) FROM Product PIVOT ( SUM(QTY) FOR PRODUCT IN (MILK) ) AS pvt GROUP BY CUST ORDER BY CUST GO
BEGIN TRANSACTION DECLARE @errorCode INT SET @errorCode = @@ERROR -- ********************************** -- * Settings -- ********************************** IF @errorCode = 0 BEGIN BEGIN TRY ALTER TABLE Color ADD [CodeID] [uniqueidentifier] NOT NULL DEFAULT ( GO END TRY BEGIN CATCH SET @errorCode = @@ERROR END CATCH END IF @errorCode = 0 BEGIN BEGIN TRY UPDATE Color SET CodeID= WHERE [Name] = END TRY BEGIN CATCH SET @errorCode = @@ERROR END CATCH END -- ********************************** -- * Check @errorCode to issue a COMMIT or a ROLLBACK -- ********************************** IF @errorCode = 0 BEGIN COMMIT PRINT END ELSE BEGIN ROLLBACK PRINT END
:on error exit set xact_abort on; go begin transaction; go if columnproperty(object_id( begin alter table Code add ColorId uniqueidentifier null; end go update Code set ColorId = where ... go commit; go
ALTER TABLE [Table] ADD [Xyz] NVARCHAR(256); DECLARE @sql NVARCHAR(2048) = EXEC sys.sp_executesql @query = @sql;
SET XACT_ABORT ON GO BEGIN TRANSACTION GO IF COLUMNPROPERTY(OBJECT_ID( ALTER TABLE Color ADD CodeID [uniqueidentifier] NULL GO IF XACT_STATE() = 1 UPDATE Color SET CodeID= WHERE [Name] = GO IF XACT_STATE() = 1 COMMIT TRAN --else would be rolled back
DECLARE @LastName varchar(max) SET @LastName = SELECT Employee WHERE LastName LIKE
DECLARE @LastName varchar(max) SET @LastName = SELECT Employee WHERE LastName LIKE
SELECT [Date] from table where [DATe] is null SELECT [Date] from table where [DATe] = SELECT [Date] from table where LEN([date])> 10 SELECT [Date] from table where LEN([date])< 10 SELECT top 100 [Date] , SUBSTRING([date],4,2) from [table where convert(int, SUBSTRING([date],4,2)) < 1 or convert(int, SUBSTRING([date],4,2)) > 12 SELECT top 100 [Date] , SUBSTRING([date],1,2) from table where convert(int, SUBSTRING([date],4,2)) < 1 or convert(int, SUBSTRING([date],4,2)) > 31
Create procedure [dbo].[a] @examdate varchar(10) , @examdate1 varchar(10) AS Select tbl.sno,mark,subject1, Convert(varchar(10),examdate,103) from tbl where (Convert(datetime,examdate,103) >= Convert(datetime,@examdate,103) and (Convert(datetime,examdate,103) <= Convert(datetime,@examdate1,103)))
DECLARE @str varchar(10) SET @str = IF convert(int, substring(@str,4,2)) <= 31 AND convert(int, substring(@str,4,2)) >= 1 PRINT @str+ ELSE PRINT @str+ GO DECLARE @str varchar(10) SET @str = PRINT PRINT GO DECLARE @str varchar(10) SET @str = IF convert(int, substring(@str,4,2)) <= 31 AND convert(int, substring(@str,4,2)) >= 1 PRINT @str+ ELSE PRINT @str+ GO DECLARE @str varchar(10) SET @str = PRINT PRINT GO DECLARE @str varchar(10) SET @str = IF convert(int, substring(@str,4,2)) <= 31 AND convert(int, substring(@str,4,2)) >= 1 PRINT @str+ ELSE PRINT @str+ GO DECLARE @str varchar(10) SET @str = PRINT
--Output --12/10/2012: Passed Test --Number of characters in 12/10/2012 that are not numerals or a slash (0 means the date is valid; all values greater than 0 indicate a problem): 0 --Msg 245, Level 16, State 1, Line 4 --Conversion failed when converting the varchar value --Number of characters in 12/!0/2012 that are not numerals or a slash (0 means the date is valid; all values greater than 0 indicate a problem): 1 --12/ /2012: Failed Test --Number of characters in 12/ /2012 that are not numerals or a slash (0 means the date is valid; all values greater than 0 indicate a problem): 2
CREATE FUNCTION ChangeDateFormatFromUK ( @DateColumn varchar(10) ) RETURNS VARCHAR(10) AS BEGIN DECLARE @Year varchar(4), @Month varchar(2), @Day varchar(2), @Result varchar(10) SET @Year = (SELECT substring(@DateColumn,7,10)) SET @Month = (SELECT substring(@DateColumn,4,5)) SET @Day = (SELECT substring(@DateColumn,1,2)) SET @Result = @Year + RETURN @Result END
SELECT dbo.ChangeDateFormatFromUK([dates]) from table
SELECT CONVERT(DATETIME,dbo.ChangeDateFormatFromUK([dates])) from table
SELECT [dates] from table where CONVERT(DATETIME,dbo.ChangeDateFormatFromUK([dates])) > GetDate() -- or any date
+ this happens because sql sometimes doesn + so we should always check if the input string is a valid date or not and the accordingly convert it to mm/dd/yyyy and so , i have shown below how it can be done, i have created a function to rearrange in mm/dd/yyyy from dd/mm/yyyy select case when isdate( else (select * from dbo.fn_convertdate(yourdate)) Create function dbo.fn_convertdate( @Stringdate nvarchar(29)) RETURNS @output TABLE(splitdata NVARCHAR(MAX) ) Begin Declare @table table(id int identity(1,1), data varchar(255)) Declare @firstpart nvarchar(255) Declare @tableout table(id int identity(1,1), data varchar(255)) Declare @Secondpart nvarchar(255) Declare @Thirdpart nvarchar(255) declare @date datetime insert into @table select * from dbo.fnSplitString(@Stringdate, select @firstpart=data from @table where id=2 select @Secondpart=data from @table where id=1 select @Thirdpart=data from @table where id=3 set @date=@firstpart+ insert into @output(splitdata) values( @date) return End
update report1455062507424 set [Move Time] = substring([Move Time], 7, 4) + substring([Move Time], 12, 5)
RENAME TABLE tbl TO tbl_old; CREATE TABLE tbl LIKE tbl_old; DROP TABLE tbl_old; -- at your leisure
CREATE TABLE dbo.MyTable ( MyDecimalColumn decimal(5,2) ,MyNumericColumn numeric(10,5) ); INSERT INTO dbo.MyTable VALUES (123, 12345.12); SELECT MyDecimalColumn, MyNumericColumn FROM dbo.MyTable;
MyDecimalColumn: 123.00 (p=5, s=2) MyNumericColumn: 12345.12000 (p=10, s=5)
select age, name from users union select age, name from (25,
SELECT age, name FROM users UNION SELECT 25 AS age,
USE Master GO IF EXISTS( SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N AND type in (N DROP PROCEDURE [dbo].[MyBackgroundTask] GO CREATE PROCEDURE MyBackgroundTask AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; -- The interval between cleanup attempts declare @timeToRun nvarchar(50) set @timeToRun = while 1 = 1 begin waitfor time @timeToRun begin execute [MyDatabaseName].[dbo].[MyDatabaseStoredProcedure]; end end END GO -- Run the procedure when the master database starts. sp_procoption @ProcName = @OptionName = @OptionValue = GO
DECLARE @dialog UNIQUEIDENTIFIER; BEGIN DIALOG CONVERSATION @dialog FROM SERVICE [name] TO SERVICE ...;
DECLARE @time INT; BEGIN CONVERSATION TIMER (@dialog) TIMEOUT = @time;
CREATE QUEUE queue_name WITH STATUS = ON, RETENTION = OFF , ACTIVATION (STATUS = ON, PROCEDURE_NAME = <procedure_name> , MAX_QUEUE_READERS = 20, EXECUTE AS N , POISON_MESSAGE_HANDLING (STATUS = ON)
insert into Files (FileId, FileData) values (1, 0x010203040506)
INSERT INTO Files (FileId, FileData) SELECT 1, * FROM OPENROWSET(BULK N
cast(floor(cast(getdate() as float)) as datetime) dateadd(dd,0, datediff(dd,0, getDate()))
WHERE CONVERT(VARCHAR, date1, 101) = CONVERT(VARCHAR, date2, 101)
WHERE CONVERT(VARCHAR(8), date1, 112) = WHERE CONVERT(VARCHAR(8), date2, 112)
select o.name,c.name from sys.columns c inner join sys.objects o on c.object_id=o.object_id order by o.name,c.column_id
SELECT s.name as ColumnName ,sh.name+ ,o.type_desc AS ObjectType ,CASE WHEN t.name IN ( WHEN t.name IN ( WHEN t.name IN ( ELSE t.name END AS DataType ,CASE WHEN s.is_nullable=1 THEN ELSE END AS Nullable ,CASE WHEN ic.column_id IS NULL THEN ELSE END +CASE WHEN sc.column_id IS NULL THEN ELSE END +CASE WHEN cc.object_id IS NULL THEN ELSE END AS MiscInfo FROM sys.columns s INNER JOIN sys.types t ON s.system_type_id=t.user_type_id and t.is_user_defined=0 INNER JOIN sys.objects o ON s.object_id=o.object_id INNER JOIN sys.schemas sh on o.schema_id=sh.schema_id LEFT OUTER JOIN sys.identity_columns ic ON s.object_id=ic.object_id AND s.column_id=ic.column_id LEFT OUTER JOIN sys.computed_columns sc ON s.object_id=sc.object_id AND s.column_id=sc.column_id LEFT OUTER JOIN sys.check_constraints cc ON s.object_id=cc.parent_object_id AND s.column_id=cc.parent_column_id ORDER BY sh.name+
DECLARE @SQL varchar(max) SET @SQL= SELECT @SQL=@SQL+ select from inner join INNER JOIN ' FROM sys.databases d SELECT @SQL=RIGHT(@SQL,LEN(@SQL)-5)+ --print @SQL EXEC (@SQL)
DECLARE @SQL varchar(8000) SET @SQL= SELECT @SQL=@SQL+ select from inner join sysobjects o on c.id=o.id INNER JOIN sysusers sh on o.uid=sh.uid ' FROM master.dbo.sysdatabases d SELECT @SQL=RIGHT(@SQL,LEN(@SQL)-5)+ --print @SQL EXEC (@SQL)
sp_MSforeachdb from sys.columns c inner join ?.sys.objects o on c.object_id=o.object_id --WHERE order by o.name,c.column_id'
SELECT * FROM information_schema.columns WHERE column_name =
sp_MSForEachDB @command1= SELECT Table_Catalog ,Table_Schema ,Table_Name ,Column_Name ,Data_Type ,Character_Maximum_Length FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME like
Declare @Table_Name VarChar(100) ,@Column_Name VarChar(100) Set @Table_Name = Set @Column_Name = Select RowNumber = Row_Number() Over( PARTITION BY T.[Name] Order By T.[Name],C.column_id ), SCHEMA_NAME( T.schema_id ) As SchemaName , T.[Name] As Table_Name , C.[Name] As Field_Name , sysType.name , C.max_length , C.is_nullable , C.is_identity , C.scale , C.precision From Sys.Tables As T Left Join Sys.Columns As C On ( T.[Object_Id] = C.[Object_Id] ) Left Join sys.types As sysType On ( C.user_type_id = sysType.user_type_id ) Where ( Type = And ( C.Name Like And ( T.Name Like
--Declare/Set required variables DECLARE @vchDynamicDatabaseName AS VARCHAR(MAX), @vchDynamicQuery As VARCHAR(MAX), @DatabasesCursor CURSOR SET @DatabasesCursor = Cursor FOR --Select * useful databases on the server SELECT name FROM sys.databases WHERE database_id > 4 ORDER by name --Open the Cursor based on the previous select OPEN @DatabasesCursor FETCH NEXT FROM @DatabasesCursor INTO @vchDynamicDatabaseName WHILE @@FETCH_STATUS = 0 BEGIN --Insert the select statement into @DynamicQuery --This query will select the Database name, all tables/views and their columns (in a comma delimited field) SET @vchDynamicQuery = ( B.table_name AS STUFF((SELECT FROM WHERE A.Table_name = B.Table_Name FOR XML PATH( , 1, 2, FROM WHERE B.TABLE_NAME LIKE AND B.COLUMN_NAME LIKE GROUP BY B.Table_Name Order BY 1 ASC --Print @vchDynamicQuery EXEC(@vchDynamicQuery) FETCH NEXT FROM @DatabasesCursor INTO @vchDynamicDatabaseName END CLOSE @DatabasesCursor DEALLOCATE @DatabasesCursor GO
--------------------------- --- 1st example (works) --- --------------------------- Declare @DBName sysname ,@SQL_String1 nvarchar(4000) ,@SQL_String2 nvarchar(4000) ,@ColumnName nvarchar(200) --set @ColumnName = -------- Like Trick -------- -- IF you want to add more the @ColumnName so it looks like Course_ID,CourseID -- then add an additional pairing of + ---------------------------- set @ColumnName = --select @ColumnName ----- Declare @Column_Info table ( [DatabaseName] nvarchar(128) NULL, [ColumnName] sysname NULL, [ObjectName] nvarchar(257) NOT NULL, [ObjectType] nvarchar(60) NULL, [DataType] nvarchar(151) NULL, [Nullable] varchar(8) NOT NULL, [MiscInfo] nvarchar(MAX) NOT NULL ) -------------- Begin set @SQL_String2 = DB_NAME() as s.name as ColumnName ,sh.name+ ,o.type_desc AS ObjectType ,CASE WHEN t.name IN ( WHEN t.name IN ( WHEN t.name IN ( ELSE t.name END AS DataType ,CASE WHEN s.is_nullable=1 THEN ELSE END AS Nullable ,CASE WHEN ic.column_id IS NULL THEN ELSE END +CASE WHEN sc.column_id IS NULL THEN ELSE END +CASE WHEN cc.object_id IS NULL THEN ELSE END AS MiscInfo into FROM sys.columns s INNER JOIN sys.types t ON s.system_type_id=t.user_type_id and t.is_user_defined=0 INNER JOIN sys.objects o ON s.object_id=o.object_id INNER JOIN sys.schemas sh on o.schema_id=sh.schema_id LEFT OUTER JOIN sys.identity_columns ic ON s.object_id=ic.object_id AND s.column_id=ic.column_id LEFT OUTER JOIN sys.computed_columns sc ON s.object_id=sc.object_id AND s.column_id=sc.column_id LEFT OUTER JOIN sys.check_constraints cc ON s.object_id=cc.parent_object_id AND s.column_id=cc.parent_column_id -------------------------------------------- --- DBA - Hank 12-Feb-2015 added this specific where statement -- where Upper(s.name) like -- where Upper(s.name) in ( -- where Upper(s.name) in ( -- ORDER BY sh.name+ order by 1,2' -------------------- Declare DB_cursor CURSOR FOR SELECT name FROM sys.databases --select * from sys.databases WHERE STATE = 0 -- and Name not IN ( and Name not IN ( Open DB_cursor Fetch next from DB_cursor into @DBName While @@FETCH_STATUS = 0 begin --select @DBName as Set @SQL_String1 = set @SQL_String1 = @SQL_String1 + @SQL_String2 EXEC sp_executesql @SQL_String1; -- insert into @Column_Info select * from drop table Fetch next From DB_cursor into @DBName end CLOSE DB_cursor; Deallocate DB_cursor; --- select * from @Column_Info order by 2,3 ---------------------------- end --------------------------- Below is the Second script.. --------------------------- --- 2nd example (works) --- --------------------------- -- This is by far the best/fastes of the lot for what it delivers. --Select * into dbo.hanktst From Master.INFORMATION_SCHEMA.COLUMNS --FileID: SCRIPT_Get_Column_info_(INFORMATION_SCHEMA.COLUMNS).sql ---------------------------------------- --FileID: SCRIPT_Get_Column_info_(INFORMATION_SCHEMA.COLUMNS).sql -- Utility to find all columns in all databases or find specific with a like statement -- Look at this line to find a: --> set @SQL_String2 = ---------------------------------------- --- SET NOCOUNT ON begin Declare @hanktst TABLE ( [TABLE_CATALOG] NVARCHAR(128) NULL ,[TABLE_SCHEMA] NVARCHAR(128) NULL ,[TABLE_NAME] sysname NOT NULL ,[COLUMN_NAME] sysname NULL ,[ORDINAL_POSITION] INT NULL ,[COLUMN_DEFAULT] NVARCHAR(4000) NULL ,[IS_NULLABLE] VARCHAR(3) NULL ,[DATA_TYPE] NVARCHAR(128) NULL ,[CHARACTER_MAXIMUM_LENGTH] INT NULL ,[CHARACTER_OCTET_LENGTH] INT NULL ,[NUMERIC_PRECISION] TINYINT NULL ,[NUMERIC_PRECISION_RADIX] SMALLINT NULL ,[NUMERIC_SCALE] INT NULL ,[DATETIME_PRECISION] SMALLINT NULL ,[CHARACTER_SET_CATALOG] sysname NULL ,[CHARACTER_SET_SCHEMA] sysname NULL ,[CHARACTER_SET_NAME] sysname NULL ,[COLLATION_CATALOG] sysname NULL ,[COLLATION_SCHEMA] sysname NULL ,[COLLATION_NAME] sysname NULL ,[DOMAIN_CATALOG] sysname NULL ,[DOMAIN_SCHEMA] sysname NULL ,[DOMAIN_NAME] sysname NULL ) Declare @DBName sysname ,@SQL_String2 nvarchar(4000) ,@TempRowCnt varchar(20) ,@Dbug bit = 0 Declare DB_cursor CURSOR FOR SELECT name FROM sys.databases WHERE STATE = 0 -- and Name not IN ( and Name not IN ( Open DB_cursor Fetch next from DB_cursor into @DBName While @@FETCH_STATUS = 0 begin set @SQL_String2 = where UPPER(Column_Name) like ;' if @Dbug = 1 Select @SQL_String2 as EXEC sp_executesql @SQL_String2; insert into @hanktst select * from drop table Fetch next From DB_cursor into @DBName end select * from @hanktst order by 4,2,3 CLOSE DB_cursor; Deallocate DB_cursor; set @TempRowCnt = (select cast(count(1) as varchar(10)) from @hanktst ) Print ( end --------
DECLARE @Query VARCHAR(max) SELECT @Query = sys.columns.name AS ColumnName , sys.tables.name AS TableName , schema_name (sys.tables.schema_Id) AS schemaName FROM sys.columns JOIN sys.tables ON sys.columns.object_id = sys.tables.object_id WHERE sys.columns.name = EXEC SP_MSFOREACHDB @Query
DECLARE @SQL varchar(max)= SELECT @SQL=@SQL+ select from inner join sys.objects o on c.object_id=o.object_id INNER JOIN sys.schemas sh on o.schema_id=sh.schema_id ' FROM sys.databases d SELECT @SQL=RIGHT(@SQL,LEN(@SQL)-5)+ --print @SQL EXEC (@SQL)
DECLARE @columnname nvarchar(150) SET @columnname= DECLARE @SQL varchar(max) SET @SQL= SELECT @SQL=@SQL+ select from inner join INNER JOIN where c.name like ' FROM sys.databases d SELECT @SQL=RIGHT(@SQL,LEN(@SQL)-5)+ --print @SQL EXEC (@SQL)
SELECT DISTINCT column_name FROM INFORMATION_SCHEMA.COLUMNS ORDER BY column_name
SELECT Object_Name(Id) As TableName, Name As ColumnName FROM SysColumns
TableName ColumnName 0 Table1 column11 1 Table1 Column12 2 Table2 Column21 3 Table2 Column22 4 Table3 Column23
CREATE PROCEDURE dbo.Archive_Session @SessionGUID uniqueidentifier AS print raiserror( print return -1 print [snip]
CREATE PROCEDURE dbo.Archive_Session @SessionGUID uniqueidentifier AS print raiserror( print return -1 print
before raiserror Server: Msg 50000, Level 18, State 1, Procedure Archive_Session, Line 5 this is a raised error before return
CREATE PROCEDURE dbo.foo AS INSERT INTO ExistingTable EXECUTE LinkedServer.Database.dbo.SomeProcedure
ALTER PROCEDURE dbo.Archive_Session @SessionGUID int AS BEGIN SET NOCOUNT ON PRINT RAISERROR( IF @@Error != 0 RETURN PRINT RETURN -1 PRINT END go EXECUTE dbo.Archive_Session @SessionGUID = 1
before raiserror Msg 50000, Level 18, State 1, Procedure Archive_Session, Line 7 this is a raised error
ALTER PROCEDURE Procedure AS BEGIN TRY EXEC AnotherProcedure END TRY BEGIN CATCH DECLARE @ErrorMessage NVARCHAR(4000); DECLARE @ErrorSeverity INT; DECLARE @ErrorState INT; SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(); RAISERROR (@ErrorMessage, -- Message text. @ErrorSeverity, -- Severity. @ErrorState -- State. ); RETURN --this forces it out END CATCH --Stuff here that you do not want to execute if the above failed. END --end procedure
NumUsers = COUNT(DISTINCT [UserAccountKey]) OVER (PARTITION BY [Mth])
dense_rank() over (partition by [Mth] order by [UserAccountKey]) + dense_rank() over (partition by [Mth] order by [UserAccountKey] desc) - 1
SELECT datekey, COALESCE(RunningTotal, 0) AS RunningTotal, COALESCE(RunningCount, 0) AS RunningCount, COALESCE(RunningDistinctCount, 0) AS RunningDistinctCount FROM document OUTER APPLY ( SELECT SUM(Amount) AS RunningTotal, COUNT(1) AS RunningCount, COUNT(DISTINCT d2.dateKey) AS RunningDistinctCount FROM Document d2 WHERE d2.DateKey <= document.DateKey ) rt;
SELECT datekey, SUM(Amount) OVER(ORDER BY DateKey) AS RunningTotal FROM document
-- subtract an extra 1 if null was ranked within the partition, -- which only happens if there were rows where [Include] <> dense_rank() over ( partition by [Mth] order by case when [Include] = ) + dense_rank() over ( partition by [Mth] order by case when [Include] = ) - max(case when [Include] = - 1
;WITH baseTable AS ( SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT ) ,CTE AS ( SELECT RM, ADR, DENSE_RANK() OVER(PARTITION BY RM ORDER BY ADR) AS dr FROM baseTable ) SELECT RM ,ADR ,COUNT(CTE.ADR) OVER (PARTITION BY CTE.RM ORDER BY ADR) AS cnt1 ,COUNT(CTE.ADR) OVER (PARTITION BY CTE.RM) AS cnt2 -- Not supported --,COUNT(DISTINCT CTE.ADR) OVER (PARTITION BY CTE.RM ORDER BY CTE.ADR) AS cntDist ,MAX(CTE.dr) OVER (PARTITION BY CTE.RM ORDER BY CTE.RM) AS cntDistEmu FROM CTE
declare @Day int, @Config_Node varchar(50) set @Config_Node = set @Day = @Config_Node
IF OBJECT_ID ( drop function [dbo].[fx_dosomething]; GO create FUNCTION dbo.fx_dosomething ( @x numeric ) returns @t table (debug varchar(100), x2 numeric) as begin declare @debug varchar(100) set @debug = declare @x2 numeric set @x2 = 0.123456; insert into @t values (@debug, @x2) return end go select * from fx_dosomething(0.1)
--Contencates seperate date and time strings and converts to a datetime. Date should be in format 25.03.2012. Time as 9:18:25. ALTER FUNCTION [dbo].[ufn_GetDateTime] (@date nvarchar(11), @time nvarchar(11)) RETURNS datetime AS BEGIN --select dbo.ufn_GetDateTime( declare @datetime datetime declare @day_part nvarchar(3) declare @month_part nvarchar(3) declare @year_part nvarchar(5) declare @point_ix int set @point_ix = charindex( set @day_part = substring(@date, 0, @point_ix) set @date = substring(@date, @point_ix, len(@date) - @point_ix) set @point_ix = charindex( set @month_part = substring(@date, 0, @point_ix) set @date = substring(@date, @point_ix, len(@date) - @point_ix) set @point_ix = charindex( set @year_part = substring(@date, 0, @point_ix) set @datetime = @month_part + @day_part + @year_part + return @datetime END
ALTER FUNCTION [dbo].[ufn_GetDateTime] (@date nvarchar(11), @time nvarchar(11)) RETURNS nvarchar(22) AS BEGIN --select dbo.ufn_GetDateTime( declare @day_part nvarchar(3) declare @point_ix int set @point_ix = charindex( set @day_part = substring(@date, 0, @point_ix) return @day_part END
CREATE INDEX index1 ON table1 (col1, col2, col3) CREATE INDEX index2 ON table1 (col1) INCLUDE (col2, col3)
SELECT * FROM table1 WHERE col1 = x AND col2 = y AND col3 = z
CREATE TABLE [dbo].[Profile]( [EnrollMentId] [int] IDENTITY(1,1) NOT NULL, [FName] [varchar](50) NULL, [MName] [varchar](50) NULL, [LName] [varchar](50) NULL, [NickName] [varchar](50) NULL, [DOB] [date] NULL, [Qualification] [varchar](50) NULL, [Profession] [varchar](50) NULL, [MaritalStatus] [int] NULL, [CurrentCity] [varchar](50) NULL, [NativePlace] [varchar](50) NULL, [District] [varchar](50) NULL, [State] [varchar](50) NULL, [Country] [varchar](50) NULL, [UIDNO] [int] NOT NULL, [Detail1] [varchar](max) NULL, [Detail2] [varchar](max) NULL, [Detail3] [varchar](max) NULL, [Detail4] [varchar](max) NULL, PRIMARY KEY CLUSTERED ( [EnrollMentId] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY] GO SET ANSI_PADDING OFF GO
CREATE Proc [dbo].[InsertIntoProfileTable] As BEGIN SET NOCOUNT ON Declare @currentRow int Declare @Details varchar(Max) Declare @dob Date set @currentRow =1; set @Details = while(@currentRow <=200000) BEGIN insert into dbo.Profile values( set @currentRow +=1; END SET NOCOUNT OFF END GO
CREATE NONCLUSTERED INDEX [NonClusteredIndex-20140216-223309] ON [dbo].[Profile] ( [UIDNO] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO
select UIDNO,FName,DOB, MaritalStatus, Detail1 from dbo.Profile --Takes about 30-50 seconds and return 200,000 results.
select UIDNO,FName,DOB, MaritalStatus, Detail1 from dbo.Profile where DOB between --Takes about 10-15 seconds and return 36,479 records.
CREATE NONCLUSTERED INDEX [NonClusteredIndex-20140216-231011] ON [dbo].[Profile] ( [UIDNO] ASC, [FName] ASC, [DOB] ASC, [MaritalStatus] ASC, [Detail1] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO
CREATE NONCLUSTERED INDEX [NonClusteredIndex-20140216-231811] ON [dbo].[Profile] ( [UIDNO] ASC ) INCLUDE ( [FName], [DOB], [MaritalStatus], [Detail1]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO
select UIDNO,FName,DOB, MaritalStatus, Detail1 from dbo.Profile --Takes about 20-30 seconds and return 200,000 results.
select UIDNO,FName,DOB, MaritalStatus, Detail1 from dbo.Profile where DOB between --Takes about 3-5 seconds and return 36,479 records.
SELECT * FROM tableName WHERE column1 = x AND column1 = y AND column1 = z and column4=n
SELECT column1, column2 FROM tableName WHERE column1 = a
CREATE PROCEDURE [dbo].[GetRadioServiceCodesINGroup] @RadioServiceGroup nvarchar(1000) = NULL AS BEGIN SET NOCOUNT ON; SELECT DISTINCT rsc.RadioServiceCodeId, rsc.RadioServiceCode + FROM sbi_l_radioservicecodes rsc INNER JOIN sbi_l_radioservicecodegroups rscg ON rsc.radioservicecodeid = rscg.radioservicecodeid WHERE rscg.radioservicegroupid IN (select val from dbo.fnParseArray(@RadioServiceGroup, OR @RadioServiceGroup IS NULL ORDER BY rsc.RadioServiceCode,rsc.RadioServiceCodeId,rsc.RadioService END
ORDER BY rsc.RadioServiceCodeId, rsc.RadioServiceCode +
SELECT DISTINCT col1 FROM [table] WHERE col2 > 2 ORDER BY col1, col2
SELECT rsc.RadioServiceCodeId, rsc.RadioServiceCode + FROM sbi_l_radioservicecodes rsc INNER JOIN sbi_l_radioservicecodegroups rscg ON rsc.radioservicecodeid = rscg.radioservicecodeid WHERE rscg.radioservicegroupid IN (SELECT val FROM dbo.fnParseArray(@RadioServiceGroup, OR @RadioServiceGroup IS NULL GROUP BY rsc.RadioServiceCode,rsc.RadioServiceCodeId,rsc.RadioService ORDER BY rsc.RadioServiceCode,rsc.RadioServiceCodeId,rsc.RadioService
--this works SELECT DISTINCT (c.FirstName + from SalesLT.Customer c order by FullName --this works too SELECT DISTINCT (c.FirstName + from SalesLT.Customer c order by 1 -- this doesn SELECT DISTINCT (c.FirstName + from SalesLT.Customer c order by c.FirstName, c.LastName -- the problem the DISTINCT needs an order on the new concatenated column, here I order on the singular column -- this works SELECT DISTINCT (c.FirstName + as FullName, CustomerID from SalesLT.Customer c order by 1, CustomerID -- this doesn SELECT DISTINCT (c.FirstName + from SalesLT.Customer c order by 1, CustomerID
SELECT DISTINCT TEST.* FROM ( SELECT rsc.RadioServiceCodeId, rsc.RadioServiceCode + FROM sbi_l_radioservicecodes rsc INNER JOIN sbi_l_radioservicecodegroups rscg ON rsc.radioservicecodeid = rscg.radioservicecodeid WHERE rscg.radioservicegroupid IN (select val from dbo.fnParseArray(@RadioServiceGroup, OR @RadioServiceGroup IS NULL ORDER BY rsc.RadioServiceCode,rsc.RadioServiceCodeId,rsc.RadioService ) as TEST
select reverse(substring(reverse(columnName), 1, 3))
declare @newdata varchar(30) set @newdata= select REVERSE(substring(reverse(@newdata),0,charindex(
SELECT REVERSE( --4. SUBSTRING( -- 3. REVERSE(<field_name>), 0, CHARINDEX( -- 2. REVERSE(<field_name>) -- 1. ) ) ) FROM <table_name>
CREATE FUNCTION dbo.udf_foo() RETURNS @ret TABLE (col INT) AS BEGIN DECLARE @myvar INT; SELECT @myvar = 1; INSERT INTO @ret SELECT @myvar; RETURN; END; GO SELECT * FROM dbo.udf_foo(); GO
CREATE VIEW MyView AS WITH MyVars (SomeVar, Var2) AS ( SELECT 123 AS ) SELECT * FROM MyTable WHERE x = (SELECT SomeVar FROM MyVars)
SELECT st.Value, Constants.CONSTANT_ONE, Constants.CONSTANT_TWO FROM SomeTable st CROSS APPLY ( SELECT ) Constants
CREATE VIEW vwImportant_Users AS WITH params AS ( SELECT varType= varMinStatus=1) SELECT status, name FROM sys.sysusers, params WHERE status > varMinStatus OR name LIKE varType SELECT * FROM vwImportant_Users
WITH params AS ( SELECT varType= SELECT status, name FROM sys.sysusers INNER JOIN params ON 1=1 WHERE status > varMinStatus OR name LIKE varType
WITH params AS ( SELECT varType= SELECT status, name FROM sys.sysusers CROSS APPLY params WHERE status > varMinStatus OR name LIKE varType
select ActionName from [UserAction] where UserID = @UserID
select idColumn, bitFieldY, bitFieldY ^ 1 as Toggled from tableX
update tableX set bitFieldY = bitFieldY ^ 1 where ...
DECLARE @thebit bit = 1, @theflipbit bit SET @theflipbit = ~ @thebit SELECT @theflipbit
UPDATE tblTest SET MyBitField = CASE WHEN MyBitField = 1 THEN 0 ELSE 1 END
UPDATE tblTest SET MyBitField = CASE WHEN MyBitField = 1 THEN 0 WHEN MyBitField = 0 THEN 1 ELSE NULL -- or 1 or 0 depending on requirements END
Update TableName SET [bitColumnName] = ~[bitColumnName], .... WHERE ....
UPDATE mytable SET somecolumn = CASE WHEN somecolumn = 0 THEN 1 WHEN somecolumn IS NULL THEN NULL WHEN somecolumn = 1 THEN 0 END
select sone_field collate SQL_Latin1_General_CP850_CI_AI from table_1 inner join table_2 on (table_1.field collate SQL_Latin1_General_CP850_CI_AI = table_2.field) where whatever
select sone_field collate DATABASE_DEFAULT from table_1 inner join table_2 on table_1.field collate DATABASE_DEFAULT = table_2.field where whatever
ID Col1 Col2 Col3 -- ---- ---- ---- 1 3 34 76 2 32 976 24 3 7 235 3 4 245 1 792
ID Col1 Col2 Col3 TheMin -- ---- ---- ---- ------ 1 3 34 76 3 2 32 976 24 24 3 7 235 3 3 4 245 1 792 1
with cte (ID, Col1, Col2, Col3) as ( select ID, Col1, Col2, Col3 from TestTable ) select cte.ID, Col1, Col2, Col3, TheMin from cte join ( select ID, min(Amount) as TheMin from cte UNPIVOT (Amount for AmountCol in (Col1, Col2, Col3)) as unpvt group by ID ) as minValues on cte.ID = minValues.ID
Select Id, Case When Col1 < Col2 And Col1 < Col3 Then Col1 When Col2 < Col1 And Col2 < Col3 Then Col2 Else Col3 End As TheMin From YourTableNameHere
SELECT ID, Col1, Col2, Col3, MinValue FROM YourTable CROSS APPLY (SELECT MIN(d) MinValue FROM (VALUES (Col1), (Col2), (Col3)) AS a(d)) A
ID Col Val -- --- --- 1 1 3 1 2 34 1 3 76 2 1 32 2 2 976 2 3 24 3 1 7 3 2 235 3 3 3 4 1 245 4 2 1 4 3 792
ID Col1 Col2 Col3 MinVal -- ---- ---- ---- ------ 1 3 34 76 3 2 32 976 24 24 3 7 235 3 3 4 245 1 792 1
SELECT ID, Col1, Col2, Col3, (SELECT MIN(Col) FROM (VALUES (Col1), (Col2), (Col3)) AS X(Col)) AS TheMin FROM Table
SELECT CASE WHEN Col1 <= Col2 AND Col1 <= Col3 THEN Col1 WHEN Col2 <= Col3 THEN Col2 ELSE Col3 END AS [Min Value] FROM [Your Table]
SELECT CASE WHEN Col1 <= Col2 AND Col1 <= Col3 AND Col1 <= Col4 AND Col1 <= Col5 THEN Col1 WHEN Col2 <= Col3 AND Col2 <= Col4 AND Col2 <= Col5 THEN Col2 WHEN Col3 <= Col4 AND Col3 <= Col5 THEN Col3 WHEN Col4 <= Col5 THEN Col4 ELSE Col5 END AS [Min Value] FROM [Your Table]
create function f_min_int(@a as int, @b as int) returns int as begin return case when @a < @b then @a else coalesce(@b,@a) end end
select col1, col2, col3, dbo.f_min_int(dbo.f_min_int(col1,col2),col3)
select col1, col2, col3, col4, col5, dbo.f_min_int(dbo.f_min_int(dbo.f_min_int(dbo.f_min_int(col1,col2),col3),col4),col5)
Select T.Id, T.Col1, T.Col2, T.Col3, A.TheMin From YourTable T Inner Join ( Select A.Id, Min(A.Col1) As TheMin From ( Select Id, Col1 From YourTable Union All Select Id, Col2 From YourTable Union All Select Id, Col3 From YourTable ) As A Group By A.Id ) As A On T.Id = A.Id
select case when col1 <= col2 and col1 <= col3 then col1 case when col2 <= col1 and col2 <= col3 then col2 case when col3 <= col1 and col3 <= col2 then col3 as end from Table T
select *, case when column1 < columnl2 And column1 < column3 then column1 when columnl2 < column1 And columnl2 < column3 then columnl2 else column3 end As minValue from tbl_example
DECLARE @Foo TABLE (ID INT, Col1 INT, Col2 INT, Col3 INT) INSERT @Foo (ID, Col1, Col2, Col3) VALUES (1, 3, 34, 76), (2, 32, 976, 24), (3, 7, 235, 3), (4, 245, 1, 792) SELECT ID, Col1, Col2, Col3, ( SELECT MIN(T.Col) FROM ( SELECT Foo.Col1 AS Col UNION ALL SELECT Foo.Col2 AS Col UNION ALL SELECT Foo.Col3 AS Col ) AS T ) AS TheMin FROM @Foo AS Foo
;WITH res AS ( SELECT t.YourID , CAST(( SELECT Col1 AS c01 , Col2 AS c02 , Col3 AS c03 , Col4 AS c04 , Col5 AS c05 FROM YourTable AS cols WHERE YourID = t.YourID FOR XML AUTO , ELEMENTS ) AS XML) AS colslist FROM YourTable AS t ) SELECT YourID , colslist.query( colslist.query( colslist.query( FROM res
--==================== this gets minimums and global min if object_id( drop table if object_id( drop table select r.recordid , r.ReferenceNumber, i.InventionTitle, RecordDate, i.ReceivedDate , min(fi.uploaddate) [Min File Upload], min(fi.CorrespondenceDate) [Min File Correspondence] into from record r join Invention i on i.inventionid = r.recordid left join LnkRecordFile lrf on lrf.recordid = r.recordid left join fileinformation fi on fi.fileid = lrf.fileid where r.recorddate > group by r.recordid, recorddate, i.ReceivedDate, r.ReferenceNumber, i.InventionTitle select recordid, recorddate [min date] into from update set [min date] = ReceivedDate from where t1.ReceivedDate < [min date] and t1.ReceivedDate > update set [min date] = t1.[Min File Upload] from where t1.[Min File Upload] < [min date] and t1.[Min File Upload] > update set [min date] = t1.[Min File Correspondence] from where t1.[Min File Correspondence] < [min date] and t1.[Min File Correspondence] > select t1.*, t2.[min date] [LOWEST DATE] from order by t1.recordid
SELECT [ID], ( SELECT MIN([value].[MinValue]) FROM ( VALUES ([Col1]), ([Col1]), ([Col2]), ([Col3]) ) AS [value] ([MinValue]) ) AS [MinValue] FROM Table;
select case when 0 in (PAGE1STATUS ,PAGE2STATUS ,PAGE3STATUS, PAGE4STATUS,PAGE5STATUS ,PAGE6STATUS) then 0 else 1 end FROM CUSTOMERS_FORMS
SELECT CONVERT(VARCHAR(8),GETDATE(),108) AS HourMinuteSecond
CAST(CONVERT(CHAR(8),GETUTCDATE(),114) AS DATETIME)
List = 1/1/2010,2/1/2010,3/1/2010,4/1/2010,5/1/2010 For each x in List do DECLARE @MyVar datetime = x SELECT @MyVar
with cte as (select 1 i union all select i+1 i from cte where i < 5) select dateadd(d, i-1,
DECLARE @MyVar TABLE(Val DATETIME) DECLARE @I INT, @StartDate DATETIME SET @I = 1 SET @StartDate = WHILE @I <= 5 BEGIN INSERT INTO @MyVar(Val) VALUES(@StartDate) SET @StartDate = DATEADD(DAY,1,@StartDate) SET @I = @I + 1 END SELECT * FROM @MyVar
CREATE TABLE DECLARE @I INT, @StartDate DATETIME SET @I = 1 SET @StartDate = WHILE @I <= 5 BEGIN INSERT INTO VALUES(@StartDate) SET @StartDate = DATEADD(DAY,1,@StartDate) SET @I = @I + 1 END SELECT * FROM
declare @num int set @num = 1 declare @results table ( val int ) while (@num < 6) begin insert into @results ( val ) values ( @num ) set @num = @num + 1 end select val from @results
;WITH Numbers (N) AS ( SELECT 1 UNION ALL SELECT 1 + N FROM Numbers WHERE N < 500 ) SELECT N FROM Numbers OPTION (MAXRECURSION 500)
declare @counter as int set @counter = 0 declare @date as varchar(50) set @date = cast(1+@counter as varchar)+ while(@counter < 12) begin select cast(1+@counter as varchar)+ set @counter = @counter + 1 end
[CREATE PROCEDURE [rat].[GetYear] AS BEGIN -- variable for storing start date Declare @StartYear as int -- Variable for the End date Declare @EndYear as int -- Setting the value in strat Date select @StartYear = Value from rat.Configuration where Name = -- Setting the End date select @EndYear = Value from rat.Configuration where Name = -- Creating Tem table with [Years] as ( --Selecting the Year select @StartYear [Year] --doing Union union all -- doing the loop in Years table select Year+1 Year from [Years] where Year < @EndYear ) --Selecting the Year table selec]
DECLARE @MyVar datetime = SELECT @MyVar SELECT DATEADD (DD,NUMBER,@MyVar) FROM master.dbo.spt_values WHERE TYPE= ORDER BY NUMBER
SELECT * FROM Jira.customfieldvalue WHERE CUSTOMFIELD = 12534 AND ISSUE = 19602
SELECT --some process with STRINGVALUE-- FROM Jira.customfieldvalue WHERE CUSTOMFIELD = 12534 AND ISSUE = 19602 Araç Listesi (C2, K1 vb.Belgeler; yoksa Ruhsat Fotokopileri), Min. 5 araç plakası için İnternet Sorgusu, Son 3 Yıla Ait Onaylı Yıl Sonu Bilanço + Gelir Tablosu, Son Yıl (Yıl Sonuna ait) Detay Mizanı, İçinde Bulunduğumuz Yıla ait Ara Dönem Geçici Vergi Beyannamesi, Bayi Yorum E-Maili, Proforma Fatura
DECLARE @combinedString VARCHAR(MAX) SELECT @combinedString = COALESCE(@combinedString + FROM jira.customfieldValue WHERE customfield = 12534 AND ISSUE = 19602 SELECT @combinedString as StringValue
SELECT DISTINCT Issue, Customfield, StringValues FROM Jira.customfieldvalue v1 CROSS APPLY ( SELECT StringValues + FROM jira.customfieldvalue v2 WHERE v2.Customfield = v1.Customfield AND v2.Issue = v1.issue ORDER BY ID FOR XML PATH( WHERE customfield = 12534 AND ISSUE = 19602
SELECT (STUFF(( SELECT FROM Jira.customfieldvalue WHERE CUSTOMFIELD = 12534 AND ISSUE = 19602 FOR XML PATH( ), 1, 2, ) AS StringValue
SELECT CUSTOMFIELD, ISSUE, dbo.GROUP_CONCAT(STRINGVALUE) FROM Jira.customfieldvalue WHERE CUSTOMFIELD = 12534 AND ISSUE = 19602 GROUP BY CUSTOMFIELD, ISSUE
SELECT group_concat(STRINGVALUE) FROM Jira.customfieldvalue WHERE CUSTOMFIELD = 12534 AND ISSUE = 19602
select id, issue, customfield, parentkey, listagg(stingvalue, from jira.customfieldvalue where customfield = 12534 and issue = 19602 group by id, issue, customfield, parentkey
declare @vchar varchar(50) set @vchar = select case when @vchar not like
-- will fail for decimal values, but allow negative values TRY_CAST(@value AS INT) IS NOT NULL -- will fail for non-positive integers; can be used with other examples below as well, or reversed if only negative desired TRY_CAST(@value AS INT) > 0 -- will fail if a $ is used, but allow decimals to the specified precision TRY_CAST(@value AS DECIMAL(10,2)) IS NOT NULL -- will allow valid currency TRY_CAST(@value AS MONEY) IS NOT NULL -- will allow scientific notation to be used like 1.7E+3 TRY_CAST(@value AS FLOAT) IS NOT NULL
declare @MyTable table(MyVar nvarchar(10)); insert into @MyTable (MyVar) values (N , (N , (N , (N , (N , (N , (N , (N -- This shows that Wade73 select * from ( select MyVar , case when MyVar not like N from @MyTable ) t order by IsNumber; -- Notice the addition of "and MyVar not like N select * from ( select MyVar , case when MyVar not like N from @MyTable ) t order by IsNumber;
DECLARE @A nvarchar(100) = IF(ISNUMERIC(@A) = 1) BEGIN PRINT END
declare @MyTable table(MyVar nvarchar(10)); insert into @MyTable (MyVar) values (N , (N , (N , (N , (N , (N , (N , (N , (N ; -- This shows that Neizan select * from ( select MyVar , case when MyVar not like N from @MyTable ) t order by IsNumber; -- Notice the addition of "and MyVar not like select * from ( select MyVar , case when MyVar not like N from @MyTable ) t order by IsNumber;
declare @MyTable table(MyVar nvarchar(10)); insert into @MyTable (MyVar) values (N , (N , (N , (N , (N , (N , (N , (N , (N , (N , (N , (N , (N , (N ; -- This shows that Neizan select * from ( select MyVar , case when MyVar not like N from @MyTable ) t order by IsNumber; -- Notice the addition of "and MyVar not like select * from ( select MyVar , case when MyVar not like N from @MyTable ) t order by IsNumber; --Trying to tweak for negative values and the comma --Modified when comparison select * from ( select MyVar , case when MyVar not like N else 0 end as IsNumber from @MyTable ) t order by IsNumber;
create table1 (field1 int, field2 int default 5557, field3 int default 1337, field4 int default 1337)
INSERT INTO table1 (field1, field3) VALUES (5, 10);
insert into table1 values (5, DEFAULT, 10, DEFAULT)
GO ALTER TABLE Table_name ADD column_name decimal(18, 2) NOT NULL CONSTRAINT Constant_name DEFAULT 0 GO ALTER TABLE Table_name SET (LOCK_ESCALATION = TABLE) GO COMMIT
CREATE PROC SP_EMPLOYEE --By Using TYPE parameter and CASE in Stored procedure (@TYPE INT) AS BEGIN IF @TYPE=1 BEGIN SELECT DESIGID,DESIGNAME FROM GP_DESIGNATION END IF @TYPE=2 BEGIN SELECT ID,NAME,DESIGNAME, case D.ISACTIVE when FROM GP_EMPLOYEEDETAILS ED JOIN GP_DESIGNATION D ON ED.DESIGNATION=D.DESIGID END END
SELECT * FROM [LinkedServer].[RemoteDatabase].[User].[Table]
:Connect server_name[\instance_name] [-l timeout] [-U user_name [-P password]
-- Server one scalar variable DECLARE @SERVER VARCHAR(MAX) --Oracle is the server to which we want to connect EXEC SP_ADDLINKEDSERVER @SERVER=
--DBO is the owner name to know table owner name execute (SP_HELP TABLENAME) SELECT * INTO DESTINATION_TABLE_NAME FROM ORACLE.SOURCE_DATABASENAME.DBO.SOURCE_TABLE
:CONNECT SERVER1 Select * from Table GO enter code here :CONNECT SERVER1 Select * from Table GO
Print GO 1 If not EXISTS ( SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ) BEGIN CREATE TABLE [dbo].[Bedrijf] ( [IDBedrijf] [varchar] (38) NOT NULL , [logo] [varbinary] (max) NULL , [VolledigeHandelsnaam] [varchar] (100) NULL ) ON [PRIMARY]
OSQL.EXE -U Username -P Password -S IPaddress -i C:Bedrijf.txt -o C:Bedrijf.out -d myDatabaseName
SELECT * FROM your_table WHERE ((DATEPART(dw, date_created) + @@DATEFIRST) % 7) NOT IN (0, 1)
SELECT date_created FROM your_table WHERE DATENAME(dw, date_created) NOT IN (
SELECT date_created FROM your_table WHERE DATEPART(dw, date_created) NOT IN (1, 7);
select [date_created] from table where DATENAME(WEEKDAY, [date_created]) <> and DATENAME(WEEKDAY, [date_created]) <>
SELECT [date_created] FROM table WHERE DATEPART(w,[date_created]) NOT IN (7,1)
SELECT [date_created] FROM table WHERE DATEPART(w,[date_created]) NOT IN (6,7)
set identity_insert ABC_1 off insert into ABC_1 select * from ABC set identity_insert ABC_1 on
SET IDENTITY_INSERT DuplicateTable ON INSERT Into DuplicateTable ([Column1], [Column2], [Column3], [Column4],... ) SELECT [Column1], [Column2], [Column3], [Column4],... FROM MainTable SET IDENTITY_INSERT DuplicateTable OFF
select top 0 * into <new_table> from <original_table>
declare @t table ( id int identity primary key, somecol datetime default getdate() ) insert into @t default values select SCOPE_IDENTITY() --returns 1 select @@IDENTITY --returns 1
Create Table id int identity, somedate datetime default getdate() ) insert into output inserted.* default values
DECLARE @Inserted AS TABLE (MyTableId INT); INSERT [MyTable] (MyTableColOne, MyTableColTwo) OUTPUT Inserted.MyTableId INTO @Inserted VALUES ( SELECT MyTableId FROM @Inserted
-- table structure for example: CREATE TABLE MyTable ( MyTableId int NOT NULL IDENTITY (1, 1), MyTableColOne varchar(50) NOT NULL, MyTableColTwo varchar(50) NOT NULL )
Create Table id int identity, somedate datetime default getdate() ) insert into output inserted.* default values
IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = AND ROUTINE_SCHEMA = AND ROUTINE_TYPE = EXEC ( CREATE PROCEDURE dbo.SynchronizeRemoteCatalog AS BEGIN -- body END
IF OBJECT_ID( EXEC( GO ALTER PROCEDURE spCallSomething ... --instead of DROP/CREATE
DROP PROCEDURE IF EXISTS dbo.SynchronizeRemoteCatalog GO CREATE PROCEDURE dbo.SynchronizeRemoteCatalog AS BEGIN BODY: END GO
CREATE OR ALTER PROCEDURE dbo.SynchronizeRemoteCatalog AS BEGIN BODY: END
—- Stored Procedure IF OBJECT_ID( EXEC( EXEC( GO —- Scalar Function IF OBJECT_ID( EXEC( EXEC( GO —- Table-based Function IF OBJECT_ID( EXEC( GO
-- Triggers IF OBJECT_ID( EXEC( GO -- Views IF OBJECT_ID( EXEC( GO
CREATE TRIGGER dbo.ExistingTable ON dbo.AnotherTable FOR UPDATE AS SET NOCOUNT ON GO
Msg 2714, Level 16, State 2, Procedure MetaClass, Line 3 There is already an object named ExistingTable
IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = EXEC (
IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = DROP PROCEDURE dbo.SynchronizeRemoteCatalog
if objectproperty(object_id( exec( end go alter view dbo.myview as -- select * -- from table go
if objectproperty(object_id( exec( end go alter procedure dbo.myproc as set nocount on -- Add the stored proc contents here... go
if objectproperty(object_id( exec( end go alter function dbo.myudf(@s varchar(100)) returns int as begin -- return len(@s) end go
if objectproperty(object_id( exec( end go alter function dbo.myudf(@s varchar(100)) returns @result table ( -- Columns returned by the function id int identity(1, 1) primary key not null ,result varchar(100) null ) begin return end go
IF EXISTS (SELECT name FROM sysobjects WHERE name = DROP PROC dbo.ig_InsertDealer GO CREATE PROCEDURE dbo.ig_InsertDealer ... GO GRANT EXECUTE ON dbo.ig_InsertDealer TO ... GO
--Initial creation: CREATE PROCEDURE dbo.my_proc AS SELECT * FROM dbo.a WHERE i < 10; GO SELECT OBJECT_ID( GO -- Recreating DROP PROCEDURE IF EXISTS dbo.my_proc; GO CREATE PROCEDURE dbo.my_proc AS -- some meaningless comment SELECT * FROM dbo.a WHERE i < 10; GO SELECT OBJECT_ID( GO
-- Initial creation CREATE PROCEDURE dbo.my_proc2 AS SELECT * FROM dbo.a WHERE i < 10; GO SELECT OBJECT_ID( GO -- Altering CREATE OR ALTER PROCEDURE dbo.my_proc2 AS -- some meaningless comment SELECT * FROM dbo.a WHERE i < 10; GO SELECT OBJECT_ID( GO
USE T1; GO -- make sure that Query Store is READ_WRITE IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N BEGIN CREATE TABLE [dbo].[a]( [i] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY, [g] [uniqueidentifier] NULL, [z] VARCHAR(10) ); END GO -- populate table (15k records) INSERT INTO dbo.a(g, z) SELECT NEWID(), number FROM (SELECT CAST([key] AS INT) AS number FROM OPENJSON( ) AS num GO 5 -- initial creation CREATE PROCEDURE dbo.my_proc AS SELECT * FROM dbo.a WHERE z LIKE AND 1 = (SELECT 1); GO -- Clustered Index Scan EXEC dbo.my_proc; EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; GO --dc1 -- creating index CREATE NONCLUSTERED INDEX IX_dbo_a_z ON dbo.a([z] ASC) INCLUDE ([i], [g]); GO -- index seek EXEC dbo.my_proc; EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; -- forcing plan GUI, clustered scan -- dc3 EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; -- dc4 -- Clustered Index Scan EXEC dbo.my_proc; EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; -- dc5 DROP PROCEDURE IF EXISTS dbo.my_proc; GO CREATE PROCEDURE dbo.my_proc AS -- some meaningless comment added by developer SELECT * FROM dbo.a WHERE z LIKE AND 1 = (SELECT 1); GO -- Index Seek EXEC dbo.my_proc; EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; -- object_id in query store is NULL -- is_forced_plan flag is ignored !!!
USE T2; GO -- make sure that Query Store is READ_WRITE IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N BEGIN CREATE TABLE [dbo].[a]( [i] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY, [g] [uniqueidentifier] NULL, [z] VARCHAR(10) ); END GO -- populate table (15k records) INSERT INTO dbo.a(g, z) SELECT NEWID(), number FROM (SELECT CAST([key] AS INT) AS number FROM OPENJSON( ) AS num GO 5 -- initial creation CREATE PROCEDURE dbo.my_proc AS SELECT * FROM dbo.a WHERE z LIKE AND 1 = (SELECT 1); GO -- Clustered Index Scan EXEC dbo.my_proc; EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; -- ca1 GO -- creating index CREATE NONCLUSTERED INDEX IX_dbo_a_z ON dbo.a([z] ASC) INCLUDE ([i], [g]); GO -- index seek EXEC dbo.my_proc; EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; --ca2 -- forcing plan GUI --ca3 EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; --ca4 -- Clustered Index Scan EXEC dbo.my_proc; EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; --ca5 GO CREATE OR ALTER PROCEDURE dbo.my_proc AS -- some meaningless comment added by developer SELECT * FROM dbo.a WHERE z LIKE AND 1 = (SELECT 1); GO -- Clustered Index Scan EXEC dbo.my_proc; EXEC sp_query_store_flush_db; SELECT qsq.query_id, qsq.query_text_id, qsq.context_settings_id, qsq.[object_id], OBJECT_NAME(qsq.[object_id]) AS [object_name], qsp.is_forced_plan, qsqt.query_sql_text, qsrs.count_executions, CAST(qsp.query_plan AS XbML) AS sql_query_plan FROM sys.query_store_query qsq JOIN sys.query_store_query_text qsqt ON qsq.query_text_id = qsqt.query_text_id JOIN sys.query_store_plan qsp ON qsq.query_id= qsp.query_id JOIN sys.query_store_runtime_stats qsrs ON qsrs.plan_id = qsp.plan_id WHERE query_sql_text LIKE AND qsq.[object_id] <> 0 ORDER BY qsq.query_id; -- is_forced_plan is valid
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N EXEC( EXEC( GO ALTER PROCEDURE aaa_test @PAR1 INT, @PAR2 INT=0 AS BEGIN SELECT @PAR1 AS Par1, CASE @PAR2 WHEN 0 THEN END GO
USE master GO CREATE TABLE dbo.silly_logging(id INT IDENTITY(1,1) PRIMARY KEY ,created_date DATETIME DEFAULT GETDATE() ,comment VARCHAR(100)); GO CREATE PROCEDURE dbo.my_procedure AS INSERT INTO dbo.silly_logging(comment) VALUES ( GO -- mark procedure to start at SQL Server instance startup EXEC sp_procoption @ProcName = , @OptionName = , @OptionValue = SELECT name, create_date, modify_date, is_auto_executed FROM master.sys.procedures WHERE is_auto_executed = 1; --name create_date modify_date is_auto_executed --my_procedure 2017-07-28 06:36:21.743 2017-07-28 06:36:24.513 1
DROP PROCEDURE dbo.my_procedure; GO CREATE PROCEDURE dbo.my_procedure AS -- adding meaningless comment INSERT INTO dbo.silly_logging(comment) VALUES ( GO SELECT name, create_date, modify_date, is_auto_executed FROM master.sys.procedures WHERE is_auto_executed = 1; -- empty
ALTER TABLE dbo.MyTable ADD MyColumn text NOT NULL CONSTRAINT DF_MyTable_MyColumn DEFAULT ALTER TABLE dbo.MyTable DROP CONSTRAINT DF_MyTable_MyColumn
ALTER TABLE [Table] ADD [Column] INT NULL GO UPDATE [Table] SET [Column] = <default_value> ALTER TABLE [Table] ALTER COLUMN [Column] INT NOT NULL
CREATE TABLE TestInsertComputedColumn ( FirstName VARCHAR(100), LastName CHAR(50) ); insert into TestInsertComputedColumn(FirstName,LastName) select select * from TestInsertComputedColumn; ALTER TABLE TestInsertComputedColumn ADD FullName As FirstName + LastName PERSISTED NOT NULL; select * from TestInsertComputedColumn; --drop TABLE TestInsertComputedColumn;
SELECT object_definition(object_id) as [Proc Definition] FROM sys.objects WHERE type=
SELECT definition FROM sys.sql_modules WHERE object_id = OBJECT_ID(
USE [test] --Database Name SELECT sch.name+ ob.create_date, ob.modify_date, ob.type_desc, mod.definition FROM sys.objects AS ob LEFT JOIN sys.schemas AS sch ON sch.schema_id = ob.schema_id LEFT JOIN sys.sql_modules AS mod ON mod.object_id = ob.object_id WHERE mod.definition IS NOT NULL --Selects only objects with the definition (code)
select r.name as ResName, a.name as AppName from Resouces as r, Applications as a, ApplicationsResources as ar where ar.app_id = a.id and ar.resource_id = r.id
SELECT r.name, GROUP_CONCAT(a.name SEPARATOR FROM RESOURCES r JOIN APPLICATIONSRESOURCES ar ON ar.resource_id = r.id JOIN APPLICATIONS a ON a.id = ar.app_id GROUP BY r.name
SELECT r.name, STUFF((SELECT FROM APPLICATIONS a JOIN APPLICATIONRESOURCES ar ON ar.app_id = a.id WHERE ar.resource_id = r.id GROUP BY a.name FOR XML PATH( FROM RESOURCES r
SELECT r.name, STRING_AGG(a.name, FROM RESOURCES r JOIN APPLICATIONSRESOURCES ar ON ar.resource_id = r.id JOIN APPLICATIONS a ON a.id = ar.app_id GROUP BY r.name
DECLARE @EmployeeList varchar(100) SELECT @EmployeeList = COALESCE(@EmployeeList + CAST(Emp_UniqueID AS varchar(5)) FROM SalesCallsEmployees WHERE SalCal_UniqueID = 1 SELECT @EmployeeList
SELECT r.ID, r.Name, Resources = STUFF( (SELECT FROM dbo.Applications a INNER JOIN dbo.ApplicationsResources ar ON ar.app_id = a.id WHERE ar.resource_id = r.id FOR XML PATH( FROM dbo.Resources r
CREATE TABLE [dbo].[item_dept]( [ItemName] char(20) NULL, [DepartmentID] int NULL )
SELECT ItemName, STUFF((SELECT FROM item_dept b WHERE a.ItemName = b.ItemName FOR XML PATH( FROM item_dept a GROUP BY ItemName
ItemName DepartmentID item1 21,13,9,36 item2 4,9,44
Create FUNCTION dbo.ufnGetEmployeeMultiple(@DepartmentID int) RETURNS VARCHAR(1000) AS BEGIN DECLARE @Employeelist varchar(1000) SELECT @Employeelist = COALESCE(@Employeelist + FROM humanresources.Employee E Left JOIN humanresources.EmployeeDepartmentHistory H ON E.BusinessEntityID = H.BusinessEntityID INNER JOIN HumanResources.Department D ON H.DepartmentID = D.DepartmentID Where H.DepartmentID = @DepartmentID Return @Employeelist END SELECT D.name as Department, dbo.ufnGetEmployeeMultiple (D.DepartmentID)as Employees FROM HumanResources.Department D SELECT Distinct (D.name) as Department, dbo.ufnGetEmployeeMultiple (D.DepartmentID) as Employees FROM HumanResources.Department D
SELECT r.name, STRING_AGG(a.name, FROM RESOURCES r JOIN APPLICATIONSRESOURCES ar ON ar.resource_id = r.id JOIN APPLICATIONS a ON a.id = ar.app_id GROUP BY r.name
SELECT r.name, GROUP_CONCAT(a.name SEPARATOR FROM RESOURCES r JOIN APPLICATIONSRESOURCES ar ON ar.resource_id = r.id JOIN APPLICATIONS a ON a.id = ar.app_id GROUP BY r.name
SELECT r.name, STUFF((SELECT FROM APPLICATIONS a JOIN APPLICATIONRESOURCES ar ON ar.app_id = a.id WHERE ar.resource_id = r.id GROUP BY a.name FOR XML PATH( FROM RESOURCES r GROUP BY deptno;
SELECT r.name, LISTAGG(a.name SEPARATOR FROM RESOURCES r JOIN APPLICATIONSRESOURCES ar ON ar.resource_id = r.id JOIN APPLICATIONS a ON a.id = ar.app_id GROUP BY r.name;
Select a.name as a_name, r.name as r_name from ApplicationsResource ar, Applications a, Resources r where a.id = ar.app_id and r.id = ar.resource_id order by r.name, a.name;
DECLARE @listStr VARCHAR(MAX) SELECT @listStr = COALESCE(@listStr+ FROM Table SELECT @listStr
create Function FN(@Str varchar(30)) returns @Names table(name varchar(25)) as begin while (charindex( begin insert into @Names values(substring(@str, 1, charindex( set @str = substring(@str, charindex( end insert into @Names values(@str) return end
SELECT * FROM yourFunctionName(parameter1, parameter2)
--DROP SCHEMA [acme] IF (NOT EXISTS (SELECT * FROM sys.schemas WHERE name = BEGIN CREATE SCHEMA [acme] AUTHORIZATION [dbo] END
IF (NOT EXISTS (SELECT * FROM sys.schemas WHERE name = BEGIN EXEC ( END
IF (NOT EXISTS (SELECT * FROM sys.schemas WHERE name = BEGIN EXEC ( END
create table ( building_id varchar(20) ) insert into insert into insert into insert into insert into insert into property.portfolio_property_xref ( portfolio_id , building_id , created_date , last_modified_date ) values ( 34 , ( select building_id from ) , getdate() , null )
INSERT INTO table1 ( column1 ) SELECT col1 FROM table2
insert into property.portfolio_property_xref ( portfolio_id , building_id , created_date , last_modified_date ) select 34, building_id, getdate(), null from
insert into property.portfolio_property_xref ( portfolio_id , building_id , created_date , last_modified_date ) SELECT 34 , building_id, getdate(), null from
Option Explicit Dim arow As Integer Dim acol As Integer Dim lrow As Integer Dim IsCellEmpty As String Dim CustNo As Integer Dim SkuLevel As Integer Sub SkuLevelUpdate() arow = 1 acol = 1 Do IsCellEmpty = Cells(arow, acol).Value arow = arow + 1 Loop Until IsCellEmpty = "" lrow = arow - 1 arow = 2 acol = 5 Do CustNo = Cells(arow, 1) SkuLevel = Cells(arow, 4) Cells(arow, acol) = "INSERT INTO dbo. arow = arow + 1 Loop Until arow = lrow End Sub
insert into property.portfolio_property_xref ( portfolio_id , building_id , created_date , last_modified_date ) Select 34, building_id, GETDATE(), NULL From
MERGE INTO dbo.energydata WITH (HOLDLOCK) AS target USING dbo.temp_energydata AS source ON target.webmeterID = source.webmeterID AND target.DateTime = source.DateTime WHEN MATCHED THEN UPDATE SET target.kWh = source.kWh WHEN NOT MATCHED BY TARGET THEN INSERT (webmeterID, DateTime, kWh) VALUES (source.webmeterID, source.DateTime, source.kWh);
MERGE INTO dbo.energydata WITH (HOLDLOCK) AS target USING dbo.temp_energydata AS source ON target.webmeterID = source.webmeterID AND target.DateTime = source.DateTime WHEN MATCHED THEN UPDATE SET target.kWh = source.kWh WHEN NOT MATCHED BY TARGET THEN INSERT (webmeterID, DateTime, kWh) VALUES (source.webmeterID, source.DateTime, source.kWh) WHEN NOT MATCHED BY SOURCE THEN DELETE;
MERGE INTO dbo.energydata WITH (HOLDLOCK) AS target [...]
WITH target as ( SELECT * FROM dbo.energydate WHERE DateTime > GETDATE() ) MERGE INTO target WITH (HOLDLOCK) USING dbo.temp_energydata AS source ON target.webmeterID = source.webmeterID AND target.DateTime = source.DateTime WHEN MATCHED THEN UPDATE SET target.kWh = source.kWh WHEN NOT MATCHED BY TARGET THEN INSERT (webmeterID, DateTime, kWh) VALUES (source.webmeterID, source.DateTime, source.kWh) WHEN NOT MATCHED BY SOURCE THEN DELETE
UPDATE e SET e.kWh = t.kWh FROM energydata e INNER JOIN temp_energydata t ON e.webmeterID = t.webmeterID AND e.DateTime = t.DateTime
UPDATE ed SET ed.kWh = ted.kWh FROM energydata ed INNER JOIN temp_energydata ted ON ted.webmeterID = ed.webmeterID
Update energydata set energydata.kWh = temp.kWh where energydata.webmeterID = (select webmeterID from temp_energydata as temp)
UPDATE test1 INNER JOIN test2 ON (test1.id = test2.id) SET test1.data = test2.data
(1 row(s) affected) (1 row(s) affected) (1 row(s) affected)
SELECT TOP 50 * FROM(SELECT COALESCE(OBJECT_NAME(s2.objectid), execution_count,s2.objectid, (SELECT TOP 1 SUBSTRING(s2.TEXT,statement_start_offset / 2+1 , ( (CASE WHEN statement_end_offset = -1 THEN (LEN(CONVERT(NVARCHAR(MAX),s2.TEXT)) * 2) ELSE statement_end_offset END)- statement_start_offset) / 2+1)) AS sql_statement, last_execution_time FROM sys.dm_exec_query_stats AS s1 CROSS APPLY sys.dm_exec_sql_text(sql_handle) AS s2 ) x WHERE sql_statement NOT like --and OBJECTPROPERTYEX(x.objectid, ORDER BY last_execution_time DESC
SELECT deqs.last_execution_time AS [Time], dest.TEXT AS [Query] FROM sys.dm_exec_query_stats AS deqs CROSS APPLY sys.dm_exec_sql_text(deqs.sql_handle) AS dest ORDER BY deqs.last_execution_time DESC
declare @h char(32) select @h=HASHBYTES( select @h,LEN(@h)
SELECT DATALENGTH(HASHBYTES( DATALENGTH(HASHBYTES( DATALENGTH(HASHBYTES( DATALENGTH(HASHBYTES( DATALENGTH(HASHBYTES( DATALENGTH(HASHBYTES( DATALENGTH(HASHBYTES(
MD2Length MD4Length MD5Length SHALength SHA1Length SHA2_256Length SHA2_512Length --------- --------- --------- --------- ---------- -------------- -------------- 16 16 16 20 20 32 64
select * into from tMyTable -- some table in your database tempdb..sp_help
select * into from tMyTable -- some table in your database exec tempdb..sp_help drop table
Select * From tempdb.sys.columns Where object_id=OBJECT_ID(
SELECT char(9) + + CASE WHEN c.data_type IN ( THEN isnull( ELSE + CASE WHEN c.IS_NULLABLE = + From tempdb.INFORMATION_SCHEMA.COLUMNS c WHERE TABLE_NAME LIKE
Select * From tempdb.INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME LIKE
string script = SqlServices.GenerateApplicationServicesScripts(true, SqlFeatures.All, _connection.Database); SqlHelper.ExecuteNonQuery(transaction, CommandType.Text, script, ...);
Incorrect syntax near Incorrect syntax near Incorrect syntax near Incorrect syntax near Incorrect syntax near the keyword Incorrect syntax near the keyword Incorrect syntax near The variable name
BEGIN TRANSACTION TransactionWithGos; GO SET XACT_ABORT ON; -- Roll back everything if error occurs in script GO -- do stuff GO COMMIT TRANSACTION TransactionWithGos; GO
private static List<string> getCommands(string testDataSql) { string[] splitcommands = File.ReadAllText(testDataSql).Split(new string[]{"GO\r\n"}, StringSplitOptions.RemoveEmptyEntries); List<string> commandList = new List<string>(splitcommands); return commandList; }
Declare @ID nvarchar(5); set @ID = 5; select @ID GO select @ID
var script = GetScript(databaseName); var conn = new SqlConnection(connectionString.ConnectionString); var svrConnection = new ServerConnection(conn); var server = new Server(svrConnection); server.ConnectionContext.ExecuteNonQuery(script);
private static string FixGoDelimitedSqlScript(string script) { return script.Replace("\r\nGO\r\n", "\r\n;\r\n"); }
SELECT CASE WHEN LastName IS NULL THEN FirstName WHEN LastName IS NOT NULL THEN LastName + END AS FROM customers GROUP BY LastName, FirstName
SELECT LastName + FROM customers GROUP BY LastName +
SELECT FullName FROM ( SELECT LastName + FROM customers ) as sub GROUP BY FullName
SELECT FullName FROM ( SELECT CASE WHEN LastName IS NULL THEN FirstName WHEN LastName IS NOT NULL THEN LastName + END AS FullName FROM customers ) as sub GROUP BY FullName
SELECT LastName + FROM customers GROUP BY LastName +
select x.fullname from ( select lastname + from person ) as x group by x.fullname
select lastname + from person group by lastname, firstname -- no need to put the
SELECT FullName FROM ( SELECT COALESCE(LastName+ FROM customers ) c GROUP BY FullName;
SELECT LastName + FROM customers GROUP BY LastName +
SELECT CASE WHEN LastName IS NULL THEN FirstName WHEN LastName IS NOT NULL THEN LastName + END AS FROM customers GROUP BY LastName, FirstName
SELECT FullName FROM Customers CROSS APPLY (SELECT LastName + GROUP BY FullName
SELECT CASE WHEN LastName IS NULL THEN FirstName WHEN LastName IS NOT NULL THEN LastName + END AS FROM customers GROUP BY 1`
SELECT AccountNumber, Amount AS MyAlias FROM Transactions GROUP BY AccountNumber, ISNULL(Amount, 0)
SELECT AccountNumber, ISNULL(Amount, 0) AS MyAlias FROM Transactions GROUP BY AccountNumber, ISNULL(Amount, 0)
;WITH cte AS ( SELECT 1 as rn, UNION ALL SELECT rn + 1, nm = FROM cte a WHERE rn < 10) SELECT * FROM cte
;with cte as ( select 1 as rn, CAST( union all select rn+1,nm = from cte a where rn<10) select * from cte
;with cte as ( select 1 as rn, CAST( union all select rn+1, nm = CAST( from cte a where rn<10) select * from cte
;with cte as ( select 1 as rn, union all select rn+1,nm = from cte a where rn<10) select * from cte
;WITH cte AS ( SELECT 1 AS rn, CAST( UNION ALL SELECT rn + 1, nm = CAST( FROM cte a WHERE rn < 10) SELECT * FROM cte;
;with tmp1(NewsId,DataItem ,HeaderText) as ( select NewsId, LEFT(HeaderText, CHARINDEX( STUFF(HeaderText, 1, CHARINDEX( from Currentnews union all select NewsId, LEFT(HeaderText, CHARINDEX( STUFF(HeaderText, 1, CHARINDEX( from tmp1 where HeaderText > ) select NewsId, DataItem from tmp1 order by NewsId
DECLARE @Start datetime ,@End datetime DECLARE @AllDates table (@Date datetime) SELECT @Start = --need to fill @AllDates. Trying to avoid looping. -- Surely if a better solution exists.
DECLARE @dCounter datetime SELECT @dCounter = @Start WHILE @dCounter <= @End BEGIN INSERT INTO @AllDates VALUES (@dCounter) SELECT @dCounter=@dCounter+1 END
declare @dt datetime, @dtEnd datetime set @dt = getdate() set @dtEnd = dateadd(day, 100, @dt) select dateadd(day, number, @dt) from (select number from master.dbo.spt_values where [type] = ) n where dateadd(day, number, @dt) < @dtEnd
select distinct number from master.dbo.spt_values where name is null
WITH dates AS ( SELECT CAST( UNION ALL SELECT DATEADD(dd, 1, t.date) FROM dates t WHERE DATEADD(dd, 1, t.date) <= SELECT ... FROM TABLE t JOIN dates d ON d.date = t.date --etc.
SELECT TOP 10000 IDENTITY(int,1,1) AS Number INTO Numbers FROM sys.objects s1 CROSS JOIN sys.objects s2 ALTER TABLE Numbers ADD CONSTRAINT PK_Numbers PRIMARY KEY CLUSTERED (Number)
SELECT @Start+Number-1 FROM Numbers WHERE Number<=DATEDIFF(day,@Start,@End)+1
DECLARE @Start datetime ,@End datetime DECLARE @AllDates table (Date datetime) SELECT @Start = INSERT INTO @AllDates (Date) SELECT @Start+Number-1 FROM Numbers WHERE Number<=DATEDIFF(day,@Start,@End)+1 SELECT * FROM @AllDates
Date ----------------------- 2009-03-01 00:00:00.000 2009-03-02 00:00:00.000 2009-03-03 00:00:00.000 2009-03-04 00:00:00.000 2009-03-05 00:00:00.000 2009-03-06 00:00:00.000 2009-03-07 00:00:00.000 2009-03-08 00:00:00.000 2009-03-09 00:00:00.000 2009-03-10 00:00:00.000 .... 2009-07-25 00:00:00.000 2009-07-26 00:00:00.000 2009-07-27 00:00:00.000 2009-07-28 00:00:00.000 2009-07-29 00:00:00.000 2009-07-30 00:00:00.000 2009-07-31 00:00:00.000 2009-08-01 00:00:00.000 (154 row(s) affected)
DECLARE @Start datetime ,@End datetime DECLARE @AllDates table (Date datetime) SELECT @Start = WITH Nbrs_3( n ) AS ( SELECT 1 UNION SELECT 0 ), Nbrs_2( n ) AS ( SELECT 1 FROM Nbrs_3 n1 CROSS JOIN Nbrs_3 n2 ), Nbrs_1( n ) AS ( SELECT 1 FROM Nbrs_2 n1 CROSS JOIN Nbrs_2 n2 ), Nbrs_0( n ) AS ( SELECT 1 FROM Nbrs_1 n1 CROSS JOIN Nbrs_1 n2 ), Nbrs ( n ) AS ( SELECT 1 FROM Nbrs_0 n1 CROSS JOIN Nbrs_0 n2 ) SELECT @Start+n-1 as Date FROM ( SELECT ROW_NUMBER() OVER (ORDER BY n) FROM Nbrs ) D ( n ) WHERE n <= DATEDIFF(day,@Start,@End)+1 ;
select top 100000 dateadd(d,incr, (select incr = row_number() over (order by object_id, column_id), * from ( select a.object_id, a.column_id from sys.all_columns a cross join sys.all_columns b ) as a ) as b
[Microsoft.SqlServer.Server.SqlFunction( DataAccess = DataAccessKind.None, FillRowMethodName = "fnUtlGetDateRangeInTable_FillRow", IsDeterministic = true, IsPrecise = true, SystemDataAccess = SystemDataAccessKind.None, TableDefinition = "d datetime")] public static IEnumerable fnUtlGetDateRangeInTable(SqlDateTime startDate, SqlDateTime endDate) { int numdays = Math.Min(endDate.Value.Subtract(startDate.Value).Days,366); List<DateTime> res = new List<DateTime>(); for (int i = 0; i <= numdays; i++) res.Add(dtStart.Value.AddDays(i)); return res; } public static void fnUtlGetDateRangeInTable_FillRow(Object row, out SqlDateTime d) { d = (DateTime)row; }
create function dbo.generate_series ( @start bigint , @stop bigint , @step bigint = 1 , @maxResults bigint = 0 --0=unlimitted ) returns @results table(n bigint) as begin --avoid infinite loop (i.e. where we if @step = 0 return if @start > @stop and @step > 0 return if @start < @stop and @step < 0 return --ensure we don set @stop = @stop - @step --treat negatives as unlimited set @maxResults = case when @maxResults < 0 then 0 else @maxResults end --generate output ;with myCTE (n,i) as ( --start at the beginning select @start , 1 union all --increment in steps select n + @step , i + 1 from myCTE --ensure we where (@maxResults=0 or i<@maxResults) and ( (@step > 0 and n <= @stop) or (@step < 0 and n >= @stop) ) ) insert @results select n from myCTE option (maxrecursion 0) --sadly we can --all good return end
declare @start datetime = ,@end datetime = --get dates (midnight) --, rounding <12:00 down to 00:00 same day, >=12:00 to 00:00 next day --, incrementing by 1 day select CAST(n as datetime) from dbo.generate_series(cast(@start as bigint), cast(@end as bigint), default, default) --get dates (start time) --, incrementing by 1 day select CAST(n/24.0 as datetime) from dbo.generate_series(cast(@start as float)*24, cast(@end as float)*24, 24, default) --get dates (start time) --, incrementing by 1 hour select CAST(n/24.0 as datetime) from dbo.generate_series(cast(@start as float)*24, cast(@end as float)*24, default, default)
select DateGenerator.DateValue from ( select DATEADD(day, - (a.a + (10 * b.a) + (100 * c.a) + (1000 * d.a)), CONVERT(DATE, GETDATE()) ) as DateValue from (select a.a from (values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) as a(a)) as a cross join (select b.a from (values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) as b(a)) as b cross join (select c.a from (values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) as c(a)) as c cross join (select d.a from (values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) as d(a)) as d ) DateGenerator WHERE DateGenerator.DateValue BETWEEN ORDER BY DateGenerator.DateValue ASC
SELECT DATE_ADD(@Start, INTERVAL tmp_int DAY) AS the_date FROM int_table;
SELECT * FROM dbo.RangeDate(GETDATE(), DATEADD(d, 365, GETDATE())); -- Generate a range of up to 65,536 contiguous DATES CREATE FUNCTION dbo.RangeDate ( @date1 DATE = NULL , @date2 DATE = NULL ) RETURNS TABLE AS RETURN ( SELECT D = DATEADD(d, A.N, CASE WHEN @date1 <= @date2 THEN @date1 ELSE @date2 END) FROM dbo.RangeSmallInt(0, ABS(DATEDIFF(d, @date1, @date2))) A ); -- Generate a range of up to 65,536 contiguous BIGINTS CREATE FUNCTION dbo.RangeSmallInt ( @num1 BIGINT = NULL , @num2 BIGINT = NULL ) RETURNS TABLE AS RETURN ( WITH Numbers(N) AS ( SELECT N FROM(VALUES (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 16 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 32 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 48 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 64 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 80 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 96 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 112 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 128 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 144 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 160 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 176 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 192 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 208 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 224 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 240 , (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1), (1) -- 256 ) V (N) ) SELECT TOP ( CASE WHEN @num1 IS NOT NULL AND @num2 IS NOT NULL THEN ABS(@num1 - @num2) + 1 ELSE 0 END ) ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) + CASE WHEN @num1 <= @num2 THEN @num1 ELSE @num2 END - 1 FROM Numbers A , Numbers B WHERE ABS(@num1 - @num2) + 1 < 65537 );
Declare @mod_date_from date =getdate(); Declare @mod_date_to date =dateadd(year,1,@mod_date_from); with cte_Dates as ( SELECT @mod_date_from as reqDate UNION ALL SELECT DATEADD(DAY,1,reqDate) FROM cte_Dates WHERE DATEADD(DAY,1,reqDate) < @mod_date_to ) SELECT * FROM cte_Dates OPTION(MAXRECURSION 0);
declare @bd datetime --begin date declare @ed datetime --end date set @bd = GETDATE()-50 set @ed = GETDATE()+5 select DATEADD(dd, 0, DATEDIFF(dd, 0, Data)) --date format without time from ( select (GETDATE()- DATEDIFF(dd,@bd,GETDATE())) --Filter on the begin date -1 + ROW_NUMBER() over (ORDER BY [here_a_field]) AS Data from [Table_With_Lot_Of_Rows] ) a where Data < (@ed + 1) --filter on the end date
Sunday = 1 Monday = 2 Tuesday = 3 Wednesday = 4 Thursday = 5 Friday = 6 Saturday = 7
StartDate = Filter on: 2,4,6 --Monday, Wednesday, Friday dates only
declare @dt datetime, @dtEnd datetime set @dt = getdate() set @dtEnd = dateadd(day, 1095, @dt) select dateadd(day, number, @dt) as Date, DATENAME(DW, dateadd(day, number, @dt)) as Day_Name into from (select distinct number from master.dbo.spt_values where name is null ) n where dateadd(day, number, @dt) < @dtEnd select * from drop table
:r C:\Scripts\Script1.sql :r C:\Scripts\Script2.sql :r C:\Scripts\Script3.sql ...
sqlcmd -S serverName\instanceName -i C:\Scripts\Script1.sql
--Use cursor to run upgrade scripts DECLARE OSQL_cursor CURSOR READ_ONLY FOR SELECT FileName FROM ORDER BY Major, Minor, Release, Build OPEN OSQL_cursor FETCH NEXT FROM OSQL_cursor INTO @name WHILE (@@fetch_status <> -1) BEGIN IF ((@@fetch_status <> -2) AND (@result = 0)) BEGIN SET @CommandString = EXEC @result = master.dbo.xp_cmdshell @CommandString, NO_OUTPUT IF (@result = 0) BEGIN SET @Seconds = DATEDIFF(s, @LastTime, GETDATE()) SET @Minutes = @Seconds / 60 SET @Seconds = @Seconds - (@Minutes * 60) PRINT + SET @LastTime = GETDATE() END ELSE BEGIN SET @errMessage = SET @errMessage = @errMessage + char(13) + SET @errMessage = @errMessage + SET @errMessage = @errMessage + END IF @name = (@UpToVersion + GOTO CleanUpCursor --Quit if the final script specified has been run. END FETCH ENDT FROM OSQL_cursor INTO @name END
DECLARE @SQL varchar(MAX) SELECT @SQL = BulkColumn FROM OPENROWSET ( BULK , SINGLE_BLOB ) AS MYTABLE --PRINT @sql EXEC (@sql)
SELECT A.A, B.B, C.C FROM aaa AS A, bbb AS B, ccc AS C WHERE A.B = B.ID AND B.C = C.ID AND C.ID = @param
SELECT A.A, B.B, C.C FROM aaa AS A JOIN bbb AS B ON A.B = B.ID JOIN ccc AS C ON B.C = C.ID AND C.ID = @param
SELECT Mgt.attrib_a AS attrib_a ,Sta.attrib_b AS attrib_b ,Stb.attrib_c AS attrib_c FROM Main_Grain_Table Mgt ,Surrounding_TabA Sta ,Surrounding_tabB Stb WHERE Mgt.sta_join_col = Sta.sta_join_col AND Mgt.stb_join_col = Stb.stb_join_col AND Mgt.bus_logic_col =
SELECT C.FullName, C.CustomerCode, O.OrderDate, O.OrderTotal, OD.ExtendedShippingNotes FROM Customer C CROSS JOIN Order O INNER JOIN OrderDetail OD ON C.CustomerID = O.CustomerID AND C.CustomerStatus = AND O.OrderTotal > 1000.0 WHERE O.OrderID = OD.OrderID;
SELECT 1 FROM DEPARTMENTS C JOIN EMPLOYEES A JOIN JOBS B ON C.DEPARTMENT_ID = A.DEPARTMENT_ID ON A.JOB_ID = B.JOB_ID
╔══════════╦═══════╗ ║ NAME ║ MARKS ║ ╠══════════╬═══════╣ ║ Narendra ║ 80 ║ ║ Ravi ║ 85 ║ ║ Sanjay ║ 90 ║ ╚══════════╩═══════╝
╔══════════╦═══════╗ ║ NAME ║ MARKS ║ ╠══════════╬═══════╣ ║ Narendra ║ ║ ║ Narendra ║ ║ ║ Narendra ║ ║ ║ Narendra ║ ║ ║ Ravi ║ ║ ║ Ravi ║ ║ ║ Sanjay ║ ║ ╚══════════╩═══════╝
Declare @name varchar(50),@marks varchar(50) Declare @cursorInsert CURSOR set @cursorInsert = CURSOR FOR Select name,marks from tempData OPEN @cursorInsert FETCH NEXT FROM @cursorInsert into @name,@marks WHILE @@FETCH_STATUS = 0 BEGIN UPDATE tempDataView set marks = @marks where name = @name FETCH NEXT FROM @cursorInsert INTO @name,@marks END CLOSE @cursorInsert DEALLOCATE @cursorInsert
UPDATE a SET a.marks = b.marks FROM tempDataView a INNER JOIN tempData b ON a.Name = b.Name
UPDATE tempDataView SET marks = ( SELECT marks FROM tempData b WHERE tempDataView.Name = b.Name )
SELECT * FROM tempDataView a INNER JOIN tempData b ON a.Name = b.Name
UPDATE b SET b.marks = a.marks FROM tempDataView a INNER JOIN tempData b ON a.Name = b.Name
DELETE a FROM tempDataView a INNER JOIN tempData b ON a.Name = b.Name
update [dbName].[dbo].[MyTable] set MyColumn = 1 where ( select count(*) from [dbName].[dbo].[MyTable] mt2 where mt2.ID > [dbName].[dbo].[MyTable].ID and mt2.Category = [dbName].[dbo].[MyTable].Category ) > 0
-- Update contact names in an accounts table to match the currently assigned salesmen: UPDATE accounts SET (contact_first_name, contact_last_name) = (SELECT first_name, last_name FROM salesmen WHERE salesmen.id = accounts.sales_id); -- A similar result could be accomplished with a join: UPDATE accounts SET contact_first_name = first_name, contact_last_name = last_name FROM salesmen WHERE salesmen.id = accounts.sales_id;
UPDATE tempDataView SET (marks) = (SELECT marks FROM tempData WHERE tempDataView.Name = tempData.Name);
Date User Status Notes ------------------------------------------------------- 1/8/2009 12:00pm B.Sisko In Out to lunch 1/8/2009 8:00am B.Sisko In 1/7/2009 5:00pm B.Sisko In 1/7/2009 8:00am B.Sisko In 1/7/2009 8:00am K.Janeway In 1/5/2009 8:00am K.Janeway In 1/1/2009 8:00am J.Picard Out Vacation
Date User Status Notes ------------------------------------------------------- 1/8/2009 12:00pm B.Sisko In Out to lunch 1/7/2009 8:00am K.Janeway In 1/1/2009 8:00am J.Picard Out Vacation
Select Date, User, Status, Notes from [SOMETABLE] inner join ( Select max(Date) as LatestDate, [User] from [SOMETABLE] Group by User ) SubMax on [SOMETABLE].Date = SubMax.LatestDate and [SOMETABLE].User = SubMax.User
select Date, User, Status, Notes from ( select m.*, row_number() over (partition by user order by Date desc) as rn from [SOMETABLE] m ) m2 where m2.rn = 1;
WITH UserStatus (User, Date, Status, Notes, Ord) as ( SELECT Date, User, Status, Notes, ROW_NUMBER() OVER (PARTITION BY User ORDER BY Date DESC) FROM [SOMETABLE] ) SELECT User, Date, Status, Notes from UserStatus where Ord = 1
SELECT Date, User, Status, Notes FROM Test_Most_Recent WHERE Date in ( SELECT MAX(Date) from Test_Most_Recent group by User)
DISABLE TRIGGER { [ schema_name . ] trigger_name [ ,...n ] | ALL } ON { object_name | DATABASE | ALL SERVER } [ ; ]
ENABLE TRIGGER { [ schema_name . ] trigger_name [ ,...n ] | ALL } ON { object_name | DATABASE | ALL SERVER } [ ; ]
sp_msforeachtable "ALTER TABLE ? NOCHECK CONSTRAINT all" sp_msforeachtable "ALTER TABLE ? DISABLE TRIGGER all"
exec sp_msforeachtable @command1="print sp_msforeachtable @command1="print
USE AdventureWorks; GO DISABLE TRIGGER Person.uAddress ON Person.Address; GO ENABLE Trigger Person.uAddress ON Person.Address; GO
create trigger [SomeSchema].[SomeTableIsEditableTrigger] ON [SomeSchema].[SomeTable] for insert, update, delete as declare @isTableTriggerEnabled bit; exec usp_IsTableTriggerEnabled -- Have to use USP instead of UFN for access to @pTriggerProcedureIdOpt = @@procid, @poIsTableTriggerEnabled = @isTableTriggerEnabled out; if (@isTableTriggerEnabled = 0) return; -- Rest of existing trigger go
create proc [usp_IsTableTriggerEnabled] @pTriggerProcedureIdOpt bigint = null, -- Either provide this @pTableNameOpt varchar(300) = null, -- or this @poIsTableTriggerEnabled bit = null out begin set @poIsTableTriggerEnabled = 1; -- default return value (ensure not null) -- Allow a particular session to disable all triggers (since local -- temp tables are session scope limited). -- if (object_id( begin set @poIsTableTriggerEnabled = 0; return; end -- Resolve table name if given trigger procedure id instead of table name. -- Google: "How to get the table name in the trigger definition" -- set @pTableNameOpt = coalesce( @pTableNameOpt, (select object_schema_name(parent_id) + from sys.triggers where object_id = @pTriggerProcedureIdOpt) ); -- Else decide based on logic involving @pTableNameOpt and possibly current session end
ALTER TABLE table_name DISABLE TRIGGER TRIGGER_NAME -- Here your SQL query ALTER TABLE table_name ENABLE TRIGGER TRIGGER_NAME
SELECT SUM(Price) AS TotalPrice FROM Inventory WHERE (DateAdded BETWEEN @StartDate AND @EndDate)
SELECT COALESCE(SUM(Price),0) AS TotalPrice FROM Inventory WHERE (DateAdded BETWEEN @StartDate AND @EndDate)
SELECT coalesce(SUM(column_id),0) AS TotalPrice FROM sys.columns WHERE (object_id BETWEEN -1 AND -2)
SELECT ISNULL(SUM(Price), 0) AS TotalPrice FROM Inventory WHERE (DateAdded BETWEEN @StartDate AND @EndDate)
SELECT 0+COALESCE(SUM(Price),0) AS TotalPrice FROM Inventory WHERE (DateAdded BETWEEN @StartDate AND @EndDate)
SELECT COALESCE( (SELECT SUM(Price) AS TotalPrice FROM Inventory WHERE (DateAdded BETWEEN @StartDate AND @EndDate)) , 0)
SELECT ISNULL(SUM(Price), 0) AS TotalPrice FROM Inventory WHERE (DateAdded BETWEEN @StartDate AND @EndDate)
SELECT NVL(SUM(Price), 0) AS TotalPrice FROM Inventory WHERE (DateAdded BETWEEN @StartDate AND @EndDate)
SELECT Id, Date1, Date2 FROM YourTable ORDER BY CASE WHEN Date1 < Date2 THEN Date1 ELSE Date2 END
SELECT Id, Date1, Date2 FROM YourTable ORDER BY CASE WHEN COALESCE(Date1, ELSE Date2 END
ORDER BY case when date1 < date2 then date1 else date2 end
ORDER BY case when date1 < date2 then date1 else coalesce(date2,date1) end
SELECT ID, Date1, Date2 FROM YourTable ORDER BY (SELECT MIN(v) FROM (VALUES (Date1), (Date2)) AS value(v))
SELECT ID, Date1, Date2 FROM YourTable ORDER BY CASE WHEN Date1 IS NULL AND Date2 IS NULL THEN 0 WHEN Date1 IS NULL THEN 1 WHEN Date2 IS NULL THEN 2 ELSE 3 END, (SELECT MIN(v) FROM (VALUES ([Date1]), ([Date2])) AS value(v))
ORDER BY (DATEDIFF(d, - ABS(DATEDIFF(d,isnull(Startdate,enddate),isnull(EndDate,Startdate))))
Create Table Insert Into Insert Into Insert Into Insert Into Insert Into Insert Into Insert Into
select * from - ABS(DATEDIFF(d,isnull(Startdate,enddate),isnull(EndDate,Startdate))))
SELECT Id, Date1, Date2 FROM (SELECT Id, Date1, Date2 ,CASE WHEN Date1 < Date2 THEN Date1 ELSE Date2 END as MinDate FROM YourTable) as T ORDER BY MinDate
SELECT Id, Date1, Date2 FROM YourTable ORDER BY CASE WHEN Date1 < Date2 OR Date1 IS NULL THEN Date1 ELSE Date2 END
CREATE TABLE INSERT INTO SELECT t.ID, Date1, Date2, MinDate FROM CROSS APPLY (SELECT MIN(d) MinDate FROM (VALUES (Date1), (Date2)) AS a(d)) md ORDER BY MinDate DROP TABLE
SELECT * FROM aTable ORDER BY CASE WHEN date1 < date2 THEN date1 ELSE date2 END, CASE WHEN date1 < date2 THEN date2 ELSE date1 END
date1 | date2 -----------+------------ 2015-04-25 | 2015-04-21 2015-04-26 | 2015-04-21 2015-04-25 | 2015-04-22 2015-04-22 | 2015-04-26
SELECT * FROM aTable ORDER BY CASE WHEN date1 IS NULL THEN NULL WHEN date1 < date2 THEN date1 ELSE date2 END ,CASE WHEN date2 IS NULL THEN date1 WHEN date1 IS NULL THEN date2 WHEN date1 < date2 THEN date2 ELSE date1 END
date1 | date2 -----------+------------ NULL | NULL NULL | 2015-04-22 2015-04-26 | NULL 2015-04-25 | 2015-04-21 2015-04-26 | 2015-04-21 2015-04-25 | 2015-04-22
select ID, x.Date1, x.Date2 from ( select ID, Date1, Date2, SortColumn = case when Date1 < Date2 then Date1 else Date2 end from YourTable ) x order by x.SortColumn
SELECT ID, Date1, Date2 FROM YourTable ORDER BY CASE WHEN Date1 IS NULL AND Date2 IS NULL THEN 0 WHEN Date1 IS NULL THEN 1 WHEN Date2 IS NULL THEN 2 ELSE 3 END, CASE WHEN Date1 < Date2 THEN Date1 ELSE Date2 END
select * from [table] d order by ( select min(q.t) from ( select d.date1 t union select d.date2) q )
select * from [table] order by case when date1 is null then date2 when date2 is null then date1 when date1<date2 then date1 -- surely date1 and date2 are not null here else date2 end
SELECT ID, Date1, Date2 FROM YourTable ORDER BY (SELECT TOP(1) v FROM (VALUES (Date1), (Date2)) AS value(v) ORDER BY v)
CREATE TABLE [dbo].[table1] ( [id] [int] IDENTITY(1,1) NOT NULL, [data] [varchar](255) NOT NULL, CONSTRAINT [PK_table1] PRIMARY KEY CLUSTERED ([id] ASC) ) CREATE TABLE [dbo].[table2] ( [id] [int] IDENTITY(1,1) NOT NULL, [table1_id] [int] NOT NULL, [data] [varchar](255) NOT NULL, CONSTRAINT [PK_table2] PRIMARY KEY CLUSTERED ([id] ASC) )
BEGIN TRANSACTION; DECLARE @id [int]; INSERT INTO [table1] ([data]) VALUES ( SELECT @id = SCOPE_IDENTITY(); INSERT INTO [table2] ([table1_id], [data]) VALUES (@id, COMMIT TRANSACTION;
INSERT INTO [table] ([data]) SELECT [data] FROM [external_table];
insert into [table] ([data]) output inserted.id, inserted.data into table2 select [data] from [external_table]
INSERT INTO [table1] ([data]) OUTPUT [inserted].[id], [external_table].[col2] INTO [table2] SELECT [col1] FROM [external_table]
merge into [table1] as t using [external_table] as s on 1=0 --modify this predicate as necessary when not matched then insert (data) values (s.[col1]) output inserted.id, s.[col2] into [table2] ;
DECLARE @OuterID int DECLARE MY_CURSOR CURSOR LOCAL STATIC READ_ONLY FORWARD_ONLY FOR SELECT ID FROM [external_Table] OPEN MY_CURSOR FETCH NEXT FROM MY_CURSOR INTO @OuterID WHILE @@FETCH_STATUS = 0 BEGIN INSERT INTO [Table] (data) SELECT data FROM [external_Table] where ID = @OuterID INSERT INTO [second_table] (FK,OuterID) VALUES(@OuterID,@@identity) FETCH NEXT FROM MY_CURSOR INTO @OuterID END CLOSE MY_CURSOR DEALLOCATE MY_CURSOR
insert all when loc in ( into dept_east(deptno, dname, loc) values(deptno, dname, loc) when loc in ( into dept_mid(deptno, dname, loc) values(deptno, dname, loc) else into dept_west(deptno, dname, loc) values(deptno, dname, loc) select deptno, dname, loc from dept
BEGIN TRANSACTION; DECLARE @tblMapping table(sourceid int, destid int) INSERT INTO [table1] ([data]) OUTPUT source.id, new.id Select [data] from [external_table] source; INSERT INTO [table2] ([table1_id], [data]) Select map.destid, source.[more data] from [external_table] source inner join @tblMapping map on source.id=map.sourceid; COMMIT TRANSACTION;
CREATE TABLE [dbo].[table1] ( [id] [int] IDENTITY(1,1) NOT NULL, [data] [varchar](255) NOT NULL, CONSTRAINT [PK_table1] PRIMARY KEY CLUSTERED ([id] ASC), JoinGuid UniqueIdentifier NULL ) CREATE TABLE [dbo].[table2] ( [id] [int] IDENTITY(1,1) NOT NULL, [table1_id] [int] NULL, [data] [varchar](255) NOT NULL, CONSTRAINT [PK_table2] PRIMARY KEY CLUSTERED ([id] ASC), JoinGuid UniqueIdentifier NULL ) INSERT INTO Table1.... INSERT INTO Table2.... UPDATE b SET table1_id = a.id FROM Table1 a JOIN Table2 b on a.JoinGuid = b.JoinGuid WHERE b.table1_id IS NULL UPDATE Table1 SET JoinGuid = NULL UPDATE Table2 SET JoinGuid = NULL
CarID CarName ---------------- 1 Porsche 2 Mercedes 3 Ferrari
declare @aa varchar (200) set @aa = select @aa = case when @aa = then CarName else @aa + coalesce( end from Cars print @aa
SELECT LEFT(Car, LEN(Car) - 1) FROM ( SELECT Car + FROM Cars FOR XML PATH ( ) c (Car)
SELECT Stuff( ( SELECT FROM CARS FOR XML PATH( ), 1, 2,
select Id, STUFF( (select ( from OrderDetails od (nolock) where od.Order_Id = o.Id order by od.ProductName FOR XML PATH( ) ProductNames from Orders o (nolock) where o.Customer_Id = 525188 order by o.Id desc
DECLARE @CarList nvarchar(max); SET @CarList = N SELECT @CarList+=CarName+N FROM dbo.CARS; SELECT LEFT(@CarList,LEN(@CarList)-1);
DECLARE @SQL AS VARCHAR(8000) SELECT @SQL = ISNULL(@SQL+ SELECT @SQL
DECLARE @listStr VARCHAR(MAX) SELECT @listStr = COALESCE(@listStr+ FROM Cars SELECT @listStr
CREATE TABLE [dbo].[WorkOut]( [WorkOutID] [bigint] IDENTITY(1,1) NOT NULL, [TimeSheetDate] [datetime] NOT NULL, [DateOut] [datetime] NOT NULL, [EmployeeID] [int] NOT NULL, [IsMainWorkPlace] [bit] NOT NULL, [DepartmentUID] [uniqueidentifier] NOT NULL, [WorkPlaceUID] [uniqueidentifier] NULL, [TeamUID] [uniqueidentifier] NULL, [WorkShiftCD] [nvarchar](10) NULL, [WorkHours] [real] NULL, [AbsenceCode] [varchar](25) NULL, [PaymentType] [char](2) NULL, [CategoryID] [int] NULL, [Year] AS (datepart(year,[TimeSheetDate])), CONSTRAINT [PK_WorkOut] PRIMARY KEY CLUSTERED ( [WorkOutID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] ALTER TABLE [dbo].[WorkOut] ADD CONSTRAINT [DF__WorkOut__IsMainW__2C1E8537] DEFAULT ((1)) FOR [IsMainWorkPlace] ALTER TABLE [dbo].[WorkOut] WITH CHECK ADD CONSTRAINT [FK_WorkOut_Employee_EmployeeID] FOREIGN KEY([EmployeeID]) REFERENCES [dbo].[Employee] ([EmployeeID]) ALTER TABLE [dbo].[WorkOut] CHECK CONSTRAINT [FK_WorkOut_Employee_EmployeeID]
DECLARE @table_name SYSNAME SELECT @table_name = DECLARE @object_name SYSNAME , @object_id INT SELECT @object_name = , @object_id = o.[object_id] FROM sys.objects o WITH (NOWAIT) JOIN sys.schemas s WITH (NOWAIT) ON o.[schema_id] = s.[schema_id] WHERE s.name + AND o.[type] = AND o.is_ms_shipped = 0 DECLARE @SQL NVARCHAR(MAX) = ;WITH index_column AS ( SELECT ic.[object_id] , ic.index_id , ic.is_descending_key , ic.is_included_column , c.name FROM sys.index_columns ic WITH (NOWAIT) JOIN sys.columns c WITH (NOWAIT) ON ic.[object_id] = c.[object_id] AND ic.column_id = c.column_id WHERE ic.[object_id] = @object_id ), fk_columns AS ( SELECT k.constraint_object_id , cname = c.name , rcname = rc.name FROM sys.foreign_key_columns k WITH (NOWAIT) JOIN sys.columns rc WITH (NOWAIT) ON rc.[object_id] = k.referenced_object_id AND rc.column_id = k.referenced_column_id JOIN sys.columns c WITH (NOWAIT) ON c.[object_id] = k.parent_object_id AND c.column_id = k.parent_column_id WHERE k.parent_object_id = @object_id ) SELECT @SQL = SELECT CHAR(9) + CASE WHEN c.is_computed = 1 THEN ELSE UPPER(tp.name) + CASE WHEN tp.name IN ( THEN WHEN tp.name IN ( THEN WHEN tp.name IN ( THEN WHEN tp.name = THEN ELSE END + CASE WHEN c.collation_name IS NOT NULL THEN CASE WHEN c.is_nullable = 1 THEN CASE WHEN dc.[definition] IS NOT NULL THEN CASE WHEN ic.is_identity = 1 THEN END + CHAR(13) FROM sys.columns c WITH (NOWAIT) JOIN sys.types tp WITH (NOWAIT) ON c.user_type_id = tp.user_type_id LEFT JOIN sys.computed_columns cc WITH (NOWAIT) ON c.[object_id] = cc.[object_id] AND c.column_id = cc.column_id LEFT JOIN sys.default_constraints dc WITH (NOWAIT) ON c.default_object_id != 0 AND c.[object_id] = dc.parent_object_id AND c.column_id = dc.parent_column_id LEFT JOIN sys.identity_columns ic WITH (NOWAIT) ON c.is_identity = 1 AND c.[object_id] = ic.[object_id] AND c.column_id = ic.column_id WHERE c.[object_id] = @object_id ORDER BY c.column_id FOR XML PATH( + ISNULL((SELECT CHAR(9) + (SELECT STUFF(( SELECT FROM sys.index_columns ic WITH (NOWAIT) JOIN sys.columns c WITH (NOWAIT) ON c.[object_id] = ic.[object_id] AND c.column_id = ic.column_id WHERE ic.is_included_column = 0 AND ic.[object_id] = k.parent_object_id AND ic.index_id = k.unique_index_id FOR XML PATH(N + FROM sys.key_constraints k WITH (NOWAIT) WHERE k.parent_object_id = @object_id AND k.[type] = + ISNULL((SELECT ( SELECT CHAR(13) + + CASE WHEN fk.is_not_trusted = 1 THEN ELSE END + + STUFF(( SELECT FROM fk_columns k WHERE k.constraint_object_id = fk.[object_id] FOR XML PATH( + + STUFF(( SELECT FROM fk_columns k WHERE k.constraint_object_id = fk.[object_id] FOR XML PATH( + + CASE WHEN fk.delete_referential_action = 1 THEN WHEN fk.delete_referential_action = 2 THEN WHEN fk.delete_referential_action = 3 THEN ELSE END + CASE WHEN fk.update_referential_action = 1 THEN WHEN fk.update_referential_action = 2 THEN WHEN fk.update_referential_action = 3 THEN ELSE END + CHAR(13) + FROM sys.foreign_keys fk WITH (NOWAIT) JOIN sys.objects ro WITH (NOWAIT) ON ro.[object_id] = fk.referenced_object_id WHERE fk.parent_object_id = @object_id FOR XML PATH(N + ISNULL(((SELECT CHAR(13) + + STUFF(( SELECT FROM index_column c WHERE c.is_included_column = 0 AND c.index_id = i.index_id FOR XML PATH( + ISNULL(CHAR(13) + STUFF(( SELECT FROM index_column c WHERE c.is_included_column = 1 AND c.index_id = i.index_id FOR XML PATH( FROM sys.indexes i WITH (NOWAIT) WHERE i.[object_id] = @object_id AND i.is_primary_key = 0 AND i.[type] = 2 FOR XML PATH( ), PRINT @SQL --EXEC sys.sp_executesql @SQL
CREATE TABLE [dbo].[WorkOut] ( [WorkOutID] BIGINT NOT NULL IDENTITY(1,1) , [TimeSheetDate] DATETIME NOT NULL , [DateOut] DATETIME NOT NULL , [EmployeeID] INT NOT NULL , [IsMainWorkPlace] BIT NOT NULL DEFAULT((1)) , [DepartmentUID] UNIQUEIDENTIFIER NOT NULL , [WorkPlaceUID] UNIQUEIDENTIFIER NULL , [TeamUID] UNIQUEIDENTIFIER NULL , [WorkShiftCD] NVARCHAR(10) COLLATE Cyrillic_General_CI_AS NULL , [WorkHours] REAL NULL , [AbsenceCode] VARCHAR(25) COLLATE Cyrillic_General_CI_AS NULL , [PaymentType] CHAR(2) COLLATE Cyrillic_General_CI_AS NULL , [CategoryID] INT NULL , [Year] AS (datepart(year,[TimeSheetDate])) , CONSTRAINT [PK_WorkOut] PRIMARY KEY ([WorkOutID] ASC) ) ALTER TABLE [dbo].[WorkOut] WITH CHECK ADD CONSTRAINT [FK_WorkOut_Employee_EmployeeID] FOREIGN KEY([EmployeeID]) REFERENCES [dbo].[Employee] ([EmployeeID]) ALTER TABLE [dbo].[WorkOut] CHECK CONSTRAINT [FK_WorkOut_Employee_EmployeeID] CREATE NONCLUSTERED INDEX [IX_WorkOut_WorkShiftCD_AbsenceCode] ON [dbo].[WorkOut] ([WorkShiftCD] ASC, [AbsenceCode] ASC) INCLUDE ([WorkOutID], [WorkHours])
Server server = new Server("."); Database northwind = server.Databases["Northwind"]; Table categories = northwind.Tables["Categories"]; StringCollection script = categories.Script(); string[] scriptArray = new string[script.Count]; script.CopyTo(scriptArray, 0);
Use Master GO Create Function sp_ppinTipoLongitud ( @xtype int, @length int, @isnullable int ) Returns Varchar(512) As Begin -- Función que a partir de un tipo de datos y una logitud, devuelve el texto del tipo. -- Por ejemplo: para xtype=varchar y length=10 devolverá "varchar(10)" Declare @ret varchar(512) Set @ret = Select @ret = t.name + Case When name in ( Case @isnullable When 1 Then From systypes t Where t.xtype = @xtype Return @ret End GO Create Procedure sp_ppinScriptLlavesForaneas ( @vchTabla sysname, @vchResultado varchar(8000) output ) AS Begin DECLARE @tmpFK table( TablaF sysname, TablaR sysname, ColF sysname, ColR sysname, FKName sysname) -- obtengo las llaves foraneas en @vchForeign Declare @vchForeign varchar(8000), @FKName sysname, @vchColumnasF varchar(4000), @vchColumnasR varchar(4000), @ColF sysname, @ColR sysname Declare @vchTemp varchar(1000), @TablaR sysname Insert into @tmpFK Select TablaF.name AS TablaF, TablaR.name AS TablaR, ColF.name AS ColF, ColR.name AS ColR, ofk.name AS FKName From sysforeignkeys fk, sysobjects ofk, sysobjects TablaF, sysobjects TablaR, syscolumns ColF, syscolumns ColR Where TablaF.name = @vchTabla And ofk.id = fk.constid And TablaF.id = fk.fkeyid And TablaR.id = fk.rkeyid And ColF.id = TablaF.id And ColF.colid = fk.fkey And ColR.id = TablaR.id And ColR.colid = fk.rkey order by FKName Set @vchForeign = While Exists ( Select * From @tmpFK ) Begin Select Top 1 @FKName = FKName From @tmpFK Set @vchColumnasF = Set @vchColumnasR = While Exists ( Select * From @tmpFK Where FKName = @FKName ) Begin Select Top 1 @ColF = ColF, @ColR = ColR, @TablaR = TablaR From @tmpFK Where FKName = @FKName Delete From @tmpFK Where ColF = @ColF And ColR = @ColR And TablaR = @TablaR And FKName = @FKName Set @vchColumnasF = @vchColumnasF + @ColF + Set @vchColumnasR = @vchColumnasR + @ColR + End Set @vchColumnasF = LEFT(@vchColumnasF, LEN(@vchColumnasF) - 1) Set @vchColumnasR = LEFT(@vchColumnasR, LEN(@vchColumnasR) - 1) Set @vchTemp = Set @vchTemp = @vchTemp + Set @vchForeign = @vchForeign + char(9) + @vchTemp + End Select @vchResultado = Case When Len(@vchForeign) >=2 Then Left(@vchForeign, Len(@vchForeign) - 2) Else @vchForeign End End GO Create Procedure sp_ppinScriptTabla ( @vchTabla sysname ) AS Set nocount on -- Obtengo las foreign keys Declare @foreign varchar(8000) Exec sp_ppinScriptLlavesForaneas @vchTabla, @foreign output -- SELECT que devuelve el script de Create Table de la tabla Select Case o.xtype When @vchTabla + char(13) + From sysobjects o Where o.name = @vchTabla Union all -- Campos + identitys + DEFAULTS select char(9) + c.name + dbo.sp_ppinTipoLongitud(t.xtype, c.length, c.isnullable) + -- Tipo(longitud) Case When c.colstat & 1 = 1 -- Identity (si aplica) Then Else End + Case When not od.name is null -- Defaults (si aplica) Then Else End + from sysobjects o, syscolumns c LEFT OUTER JOIN sysobjects od On od.id = c.cdefault LEFT OUTER join syscomments cd On cd.id = od.id, systypes t where o.id = object_id(@vchTabla) and o.id = c.id and c.xtype = t.xtype Union all -- Primary Keys y Unique keys select char(9) + Case o.xtype When dbo.sp_ppinCamposIndice (db_name(), @vchTabla, i.indid) + from sysobjects o, sysindexes i where o.parent_obj = object_id(@vchTabla) and o.xtype in ( and i.id = o.parent_obj and o.name = i.name Union all -- Check constraints select char(9) + from sysobjects o, syscomments c where o.parent_obj = object_id(@vchTabla) and o.xtype in ( and o.id = c.id Union all -- Foreign keys Select @foreign Union all Select Set nocount off GO
SELECT ISNULL(smsp.definition, ssmsp.definition) AS [Definition] FROM sys.all_objects AS sp LEFT OUTER JOIN sys.sql_modules AS smsp ON smsp.object_id = sp.object_id LEFT OUTER JOIN sys.system_sql_modules AS ssmsp ON ssmsp.object_id = sp.object_id WHERE (sp.type = N
DECLARE @temptable_objectid INT = OBJECT_ID( DECLARE @object_name SYSNAME , @object_id INT SELECT @object_name = , @object_id = o.[object_id] FROM tempdb.sys.objects o WITH (NOWAIT) JOIN tempdb.sys.schemas s WITH (NOWAIT) ON o.[schema_id] = s.[schema_id] WHERE object_id = @temptable_objectid DECLARE @SQL NVARCHAR(MAX) = ;WITH index_column AS ( SELECT ic.[object_id] , ic.index_id , ic.is_descending_key , ic.is_included_column , c.name FROM tempdb.sys.index_columns ic WITH (NOWAIT) JOIN tempdb.sys.columns c WITH (NOWAIT) ON ic.[object_id] = c.[object_id] AND ic.column_id = c.column_id WHERE ic.[object_id] = @object_id ), fk_columns AS ( SELECT k.constraint_object_id , cname = c.name , rcname = rc.name FROM tempdb.sys.foreign_key_columns k WITH (NOWAIT) JOIN tempdb.sys.columns rc WITH (NOWAIT) ON rc.[object_id] = k.referenced_object_id AND rc.column_id = k.referenced_column_id JOIN tempdb.sys.columns c WITH (NOWAIT) ON c.[object_id] = k.parent_object_id AND c.column_id = k.parent_column_id WHERE k.parent_object_id = @object_id ) SELECT @SQL = SELECT CHAR(9) + CASE WHEN c.is_computed = 1 THEN ELSE UPPER(tp.name) + CASE WHEN tp.name IN ( THEN WHEN tp.name IN ( THEN WHEN tp.name IN ( THEN WHEN tp.name = THEN ELSE END + CASE WHEN c.collation_name IS NOT NULL THEN CASE WHEN c.is_nullable = 1 THEN CASE WHEN dc.[definition] IS NOT NULL THEN CASE WHEN ic.is_identity = 1 THEN END + CHAR(13) FROM tempdb.sys.columns c WITH (NOWAIT) JOIN tempdb.sys.types tp WITH (NOWAIT) ON c.user_type_id = tp.user_type_id LEFT JOIN tempdb.sys.computed_columns cc WITH (NOWAIT) ON c.[object_id] = cc.[object_id] AND c.column_id = cc.column_id LEFT JOIN tempdb.sys.default_constraints dc WITH (NOWAIT) ON c.default_object_id != 0 AND c.[object_id] = dc.parent_object_id AND c.column_id = dc.parent_column_id LEFT JOIN tempdb.sys.identity_columns ic WITH (NOWAIT) ON c.is_identity = 1 AND c.[object_id] = ic.[object_id] AND c.column_id = ic.column_id WHERE c.[object_id] = @object_id ORDER BY c.column_id FOR XML PATH( + ISNULL((SELECT CHAR(9) + (SELECT STUFF(( SELECT FROM tempdb.sys.index_columns ic WITH (NOWAIT) JOIN tempdb.sys.columns c WITH (NOWAIT) ON c.[object_id] = ic.[object_id] AND c.column_id = ic.column_id WHERE ic.is_included_column = 0 AND ic.[object_id] = k.parent_object_id AND ic.index_id = k.unique_index_id FOR XML PATH(N + FROM tempdb.sys.key_constraints k WITH (NOWAIT) WHERE k.parent_object_id = @object_id AND k.[type] = + ISNULL((SELECT ( SELECT CHAR(13) + + CASE WHEN fk.is_not_trusted = 1 THEN ELSE END + + STUFF(( SELECT FROM fk_columns k WHERE k.constraint_object_id = fk.[object_id] FOR XML PATH( + + STUFF(( SELECT FROM fk_columns k WHERE k.constraint_object_id = fk.[object_id] FOR XML PATH( + + CASE WHEN fk.delete_referential_action = 1 THEN WHEN fk.delete_referential_action = 2 THEN WHEN fk.delete_referential_action = 3 THEN ELSE END + CASE WHEN fk.update_referential_action = 1 THEN WHEN fk.update_referential_action = 2 THEN WHEN fk.update_referential_action = 3 THEN ELSE END + CHAR(13) + FROM tempdb.sys.foreign_keys fk WITH (NOWAIT) JOIN tempdb.sys.objects ro WITH (NOWAIT) ON ro.[object_id] = fk.referenced_object_id WHERE fk.parent_object_id = @object_id FOR XML PATH(N + ISNULL(((SELECT CHAR(13) + + STUFF(( SELECT FROM index_column c WHERE c.is_included_column = 0 AND c.index_id = i.index_id FOR XML PATH( + ISNULL(CHAR(13) + STUFF(( SELECT FROM index_column c WHERE c.is_included_column = 1 AND c.index_id = i.index_id FOR XML PATH( FROM tempdb.sys.indexes i WITH (NOWAIT) WHERE i.[object_id] = @object_id AND i.is_primary_key = 0 AND i.[type] = 2 FOR XML PATH( ), SELECT @SQL
DROP FUNCTION [dbo].[Get_Table_Script] Go Create Function Get_Table_Script ( @vsTableName varchar(50) ) Returns VarChar(Max) With ENCRYPTION Begin Declare @ScriptCommand varchar(Max) Select @ScriptCommand = + ( Case When TC.Constraint_Name IS NULL Then Else TC.Constraint_Name + End ) From sysobjects As SO Cross Apply ( Select data_type + ( Case data_type When Then When Then When Then Else Coalesce( Case When character_maximum_length = -1 Then Else Cast( character_maximum_length As VarChar ) End + ) End ) + ( Case When Exists ( Select id From syscolumns Where ( object_name(id) = SO.name ) And ( name = column_name ) And ( columnproperty(id,name, ) Then Cast( ident_seed(SO.name) As varchar ) + Cast( ident_incr(SO.name) As varchar ) + Else End ) + ( Case When IS_NULLABLE = Then Else End ) + ( Case When information_schema.columns.COLUMN_DEFAULT IS NOT NULL Then ELse End ) + From information_schema.columns Where ( table_name = SO.name ) Order by ordinal_position FOR XML PATH( Inner Join information_schema.table_constraints As TC On ( ( TC.Table_name = SO.Name ) AND ( TC.Constraint_Type = And ( TC.TABLE_NAME = @vsTableName ) ) Cross Apply ( Select From information_schema.key_column_usage As kcu Where ( kcu.Constraint_Name = TC.Constraint_Name ) Order By ORDINAL_POSITION FOR XML PATH( ) As j (list) Where ( xtype = AND ( Name NOT IN ( Return @ScriptCommand End
ISO 8601 Extended Date 2000-01-14T13:42Z ISO 8601 Basic Date 20090123T105321Z
SELECT CONVERT(VARCHAR(33), DateColumn, 126) FROM MyTable
select convert(char(10), getdate(), 126) -- ISO YYYY-MM-DD select convert(char(8), getdate(), 112) -- ISO YYYYMMDD (safest)
if object_id( exec ( go alter procedure dbo.YourSP as ...
CREATE OR ALTER PROCEDURE dbo.MyProc AS BEGIN SELECT * FROM dbo.MyTable END;
IF EXISTS (SELECT * FROM sysobjects WHERE type = BEGIN DROP PROCEDURE <name> END GO CREATE PROCEDURE <name> ......
EXEC Utils.pAssureExistance GO ALTER PROCECURE Schema.pStoredProc ...
EXEC Utils.pAssureExistance GO ALTER FUNCTION Schema.fFunction ...
IF EXISTS ( SELECT 1 FROM information_schema.routines WHERE routine_schema = AND routine_name = AND routine_type = BEGIN DROP PROCEDURE <PROCNAME> END GO CREATE PROCEDURE <PROCNAME> AS BEGIN END GO GRANT EXECUTE ON <PROCNAME> TO <ROLE> GO
SELECT DateAppr, TimeAppr, TAT, LaserLTR, Permit, LtrPrinter, JobName, JobNumber, JobDesc, ActQty, (ActQty-LtrPrinted) AS L, (ActQty-QtyInserted) AS M, ((ActQty-LtrPrinted)-(ActQty-QtyInserted)) AS N FROM [test].[dbo].[MM] WHERE DateDropped = 0 --This is where i need the conditional clause AND CASE WHEN @JobsOnHold = 1 THEN DateAppr >= 0 ELSE DateAppr != 0 END
SELECT DateAppr, TimeAppr, TAT, LaserLTR, Permit, LtrPrinter, JobName, JobNumber, JobDesc, ActQty, (ActQty-LtrPrinted) AS L, (ActQty-QtyInserted) AS M, ((ActQty-LtrPrinted)-(ActQty-QtyInserted)) AS N FROM [test].[dbo].[MM] WHERE DateDropped = 0 AND ( (ISNULL(@JobsOnHold, 0) = 1 AND DateAppr >= 0) OR (ISNULL(@JobsOnHold, 0) != 1 AND DateAppr != 0) )
WHERE DateDropped = 0 AND ( (ISNULL(@JobsOnHold, 0) = 1 AND DateAppr >= 0) OR (ISNULL(@JobsOnHold, 0) != 1 AND DateAppr != 0) )
WHERE DateDropped = 0 AND CASE WHEN @JobsOnHold = 1 AND DateAppr >= 0 THEN WHEN DateAppr != 0 THEN ELSE END =
WHERE DateDropped = 0 AND ( @JobsOnHold = 1 AND DateAppr >= 0 OR (@JobsOnHold <> 1 OR @JobsOnHold IS NULL) AND DateAppr <> 0 )
rowInt Value Diff 2 23 22 --45-23 3 45 -35 --10-45 9 0 -45 --0-45 17 10 10 -- 10-0 ....
SELECT [current].rowInt, [current].Value, ISNULL([next].Value, 0) - [current].Value FROM sourceTable AS [current] LEFT JOIN sourceTable AS [next] ON [next].rowInt = (SELECT MIN(rowInt) FROM sourceTable WHERE rowInt > [current].rowInt)
SELECT rowInt, Value, COALESCE( ( SELECT TOP 1 Value FROM myTable mi WHERE mi.rowInt > m.rowInt ORDER BY rowInt ), 0) - Value AS diff FROM myTable m ORDER BY rowInt
with T2 as ( select ID = ROW_NUMBER() over (order by rowInt), rowInt, Value from myTable ) select T1.RowInt, T1.Value, Diff = IsNull(T2.Value, 0) - T1.Value from ( SELECT ID = ROW_NUMBER() over (order by rowInt), * FROM myTable ) T1 left join T2 on T1.ID + 1 = T2.ID ORDER BY T1.ID
select * into from ( select 2 as rowint, 23 as Value union select 3, 45 union select 17, 10 union select 9, 0 ) x select rowInt, Value, LEAD(value) over (order by rowInt) - Value from
select rowint, value, value - lag(value) over (order by rowint) diff from myTable order by rowint /
select t1.rowInt,t1.Value,t2.Value-t1.Value as diff from (select * from myTable) as t1, (select * from myTable where rowInt!=1 union all select top 1 rowInt=COUNT(*)+1,Value=0 from myTable) as t2 where t1.rowInt=t2.rowInt-1
SELECT Column name, DATEDIFF( (SELECT MAX(date) FROM table name WHERE Column name < b. Column name), Column name) AS days_since_last FROM table name AS b
E-Mail | Status email1 | Exist email2 | Exist email3 | Not Exist email4 | Exist
SELECT email, CASE WHEN EXISTS(SELECT * FROM Users U WHERE E.email = U.email) THEN ELSE END AS [Status] FROM (VALUES( ( ( (
SELECT email FROM ( VALUES ( , ( , ( ) AS Checking (email) WHERE email NOT IN ( SELECT email FROM Users )
SELECT email , CASE WHEN EXISTS ( SELECT * FROM Users u WHERE u.email = Checking.email ) THEN ELSE END AS status FROM ( VALUES ( , ( , ( ) AS Checking (email)
SELECT E.Email, CASE WHEN U.Email IS NULL THEN FROM EmailsToCheck E LEFT JOIN (SELECT DISTINCT Email FROM Users) U ON E.Email = U.Email
select u.name , u.EMAIL , a.emailadres , case when a.emailadres is null then else end as from users u left join ( select union all select union all select on a.emailadres = u.EMAIL)
name | email | emailadres | existence -----|--------|------------|---------- NULL | NULL | a@b.com | Not exists Jan | j@j.nl | j@j.nl | Exists
SELECT E.AccessCode , CASE WHEN C.AccessCode IS NOT NULL THEN ELSE END AS [Status] FROM ( SELECT UNION ALL SELECT UNION ALL SELECT UNION ALL SELECT ) AS E LEFT OUTER JOIN dbo.Credentials C ON E.AccessCode = c.AccessCode
SELECT U.* FROM USERS AS U Inner Join ( SELECT EMail, [Status] FROM ( Values ( ( ( ( )AS TempTableName (EMail, [Status]) Where TempTableName.EMail IN ( ) As TMP ON U.EMail = TMP.EMail
;WITH OrderedOrders AS --semicolon here ( SELECT SalesOrderID, OrderDate, ROW_NUMBER() OVER (ORDER BY OrderDate) AS FROM Sales.SalesOrderHeader ) SELECT * FROM OrderedOrders WHERE RowNumber BETWEEN 50 AND 60
DECLARE @foo int; WITH OrderedOrders AS ( SELECT SalesOrderID, OrderDate, ...;
DECLARE @foo int ;WITH OrderedOrders AS ( SELECT SalesOrderID, OrderDate, ...;
INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1; UPDATE table SET c=c+1 WHERE a=1;
MERGE INTO MyBigDB.dbo.METER_DATA WITH (HOLDLOCK) AS target USING (SELECT 77748 AS rtu_id , ,56112 AS meter_reading , (rtu_id, meter_id, meter_reading, time_local) ON (target.rtu_id = source.rtu_id AND target.time_local = source.time_local) WHEN MATCHED THEN UPDATE SET meter_id = ,meter_reading = 56112 WHEN NOT MATCHED THEN INSERT (rtu_id, meter_id, meter_reading, time_local) VALUES (77748,
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N AND type in (N DROP PROCEDURE [dbo].[MySP]
declare @procName varchar(500) declare cur cursor for select [name] from sys.objects where type = open cur fetch next from cur into @procName while @@fetch_status = 0 begin exec( fetch next from cur into @procName end close cur deallocate cur
create Procedure [dbo].[DeleteAllProcedures] As declare @schemaName varchar(500) declare @procName varchar(500) declare cur cursor for select s.Name, p.Name from sys.procedures p INNER JOIN sys.schemas s ON p.schema_id = s.schema_id WHERE p.type = ORDER BY s.Name, p.Name open cur fetch next from cur into @schemaName,@procName while @@fetch_status = 0 begin if @procName <> exec( fetch next from cur into @schemaName,@procName end close cur deallocate cur
DECLARE @sql VARCHAR(MAX)= SELECT @sql=@sql+ WHERE type = exec(@sql);
DECLARE @sql VARCHAR(MAX) SET @sql= SELECT @sql=@sql+ WHERE type = exec(@sql);
DECLARE @spname sysname; DECLARE SPCursor CURSOR FOR SELECT SCHEMA_NAME(schema_id) + FROM sys.objects WHERE type = OPEN SPCursor; FETCH NEXT FROM SPCursor INTO @spname; WHILE @@FETCH_STATUS = 0 BEGIN EXEC( FETCH NEXT FROM SPCursor INTO @spname; END CLOSE SPCursor; DEALLOCATE SPCursor;
DECLARE @DeleteProcCommand NVARCHAR(500) DECLARE Syntax_Cursor CURSOR FOR SELECT FROM sys.procedures p OPEN Syntax_Cursor FETCH NEXT FROM Syntax_Cursor INTO @DeleteProcCommand WHILE (@@FETCH_STATUS = 0) BEGIN EXEC (@DeleteProcCommand) FETCH NEXT FROM Syntax_Cursor INTO @DeleteProcCommand END CLOSE Syntax_Cursor DEALLOCATE Syntax_Cursor
DECLARE @sql NVARCHAR(MAX) = N SELECT @sql += N + QUOTENAME(name) + WHERE name LIKE N AND SCHEMA_NAME(schema_id) = N EXEC sp_executesql @sql;
DECLARE @SQL national character varying(MAX) SET @SQL= SELECT @SQL= @SQL+ N FROM INFORMATION_SCHEMA.ROUTINES WHERE (1=1) AND ROUTINE_TYPE = AND ROUTINE_NAME NOT IN ( , , , , , , , , , , , , , , , , , , , ) ORDER BY SPECIFIC_NAME -- PRINT @SQL EXEC(@SQL)
DECLARE @sql NVARCHAR(MAX) = N , @lineFeed NVARCHAR(2) = CHAR(13) + CHAR(10) ; SELECT @sql = @sql + N FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_TYPE = -- AND SPECIFIC_NAME LIKE AND ROUTINE_NAME NOT IN ( SELECT name FROM sys.procedures WHERE is_ms_shipped <> 0 ) ORDER BY SPECIFIC_NAME -- PRINT @sql EXECUTE(@sql)
DECLARE DelAllProcedures CURSOR FOR SELECT name AS procedure_name FROM sys.procedures; OPEN DelAllProcedures DECLARE @ProcName VARCHAR(100) FETCH NEXT FROM DelAllProcedures INTO @ProcName WHILE @@FETCH_STATUS!=-1 BEGIN DECLARE @command VARCHAR(100) SET @command= SET @command=@command+ --DROP PROCEDURE @ProcName EXECUTE (@command) FETCH NEXT FROM DelAllProcedures INTO @ProcName END CLOSE DelAllProcedures DEALLOCATE DelAllProcedures
PRINT ( GO DECLARE @procedure NVARCHAR(max) DECLARE @n CHAR(1) SET @n = CHAR(10) SELECT @procedure = isnull( @procedure + @n, FROM sys.procedures EXEC sp_executesql @procedure PRINT ( GO
declare @procName varchar(500) declare cur cursor for SELECT FROM sys.procedures p open cur fetch next from cur into @procName while @@fetch_status = 0 begin exec( @procName ) fetch next from cur into @procName end close cur deallocate cur
SELECT col1, col2, col3, col4 FROM table GROUP BY col1, col2, col3, col4 HAVING COUNT(*) > 1
PK col1 col2 col3 col4 col5 1 1 2 3 4 6 2 1 3 4 7 7 3 1 3 4 7 10 4 2 3 1 4 5
SELECT *, ROW_NUMBER() OVER (PARTITION BY col1, col2, col3, col4 ORDER BY (SELECT 0)) AS DuplicateRowNumber FROM table
WITH cte AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY col1, col2, col3, col4 ORDER BY (SELECT 0)) AS DuplicateRowNumber FROM table ) DELETE FROM cte WHERE DuplicateRowNumber > 1
SELECT * FROM db WHERE col IN (SELECT col FROM db GROUP BY col HAVING COUNT(*) > 1) ORDER BY col
insert into Transactions values(1, 100) insert into Transactions values(2, -50) insert into Transactions values(3, 100) insert into Transactions values(4, -100) insert into Transactions values(5, 200)
TID amt balance --- ----- ------- 1 100 100 2 -50 50 3 100 150 4 -100 50 5 200 250
SELECT t1.TID, t1.amt, RunningTotal = SUM(t2.amt) FROM dbo.Transactions AS t1 INNER JOIN dbo.Transactions AS t2 ON t1.TID >= t2.TID GROUP BY t1.TID, t1.amt ORDER BY t1.TID;
SELECT TID, amt, RunningTotal = amt + COALESCE( ( SELECT SUM(amt) FROM dbo.Transactions AS i WHERE i.TID < o.TID), 0 ) FROM dbo.Transactions AS o ORDER BY TID;
DECLARE @t TABLE ( TID INT PRIMARY KEY, amt INT, RunningTotal INT ); DECLARE @RunningTotal INT = 0; INSERT @t(TID, amt, RunningTotal) SELECT TID, amt, RunningTotal = 0 FROM dbo.Transactions ORDER BY TID; UPDATE @t SET @RunningTotal = RunningTotal = @RunningTotal + amt FROM @t; SELECT TID, amt, RunningTotal FROM @t ORDER BY TID;
;WITH x AS ( SELECT TID, amt, RunningTotal = amt FROM dbo.Transactions WHERE TID = 1 UNION ALL SELECT y.TID, y.amt, x.RunningTotal + y.amt FROM x INNER JOIN dbo.Transactions AS y ON y.TID = x.TID + 1 ) SELECT TID, amt, RunningTotal FROM x ORDER BY TID OPTION (MAXRECURSION 10000);
;WITH y AS ( SELECT TID, amt, rn = ROW_NUMBER() OVER (ORDER BY TID) FROM dbo.Transactions ), x AS ( SELECT TID, rn, amt, rt = amt FROM y WHERE rn = 1 UNION ALL SELECT y.TID, y.rn, y.amt, x.rt + y.amt FROM x INNER JOIN y ON y.rn = x.rn + 1 ) SELECT TID, amt, RunningTotal = rt FROM x ORDER BY x.rn OPTION (MAXRECURSION 10000);
CREATE TABLE ( rn INT PRIMARY KEY, TID INT, amt INT ); INSERT INTO SELECT ROW_NUMBER() OVER (ORDER BY TID), TID, amt FROM dbo.Transactions; ;WITH x AS ( SELECT TID, rn, amt, rt = amt FROM WHERE rn = 1 UNION ALL SELECT y.TID, y.rn, y.amt, x.rt + y.amt FROM x INNER JOIN ON y.rn = x.rn + 1 ) SELECT TID, amt, RunningTotal = rt FROM x ORDER BY TID OPTION (MAXRECURSION 10000); DROP TABLE
CREATE TABLE ( TID INT PRIMARY KEY, amt INT, rt INT ); INSERT SELECT TID, amt FROM dbo.Transactions ORDER BY TID; DECLARE @rt INT, @tid INT, @amt INT; SET @rt = 0; DECLARE c CURSOR LOCAL STATIC READ_ONLY FORWARD_ONLY FOR SELECT TID, amt FROM OPEN c; FETCH c INTO @tid, @amt; WHILE @@FETCH_STATUS = 0 BEGIN SET @rt = @rt + @amt; UPDATE FETCH c INTO @tid, @amt; END CLOSE c; DEALLOCATE c; SELECT TID, amt, RunningTotal = rt FROM ORDER BY TID; DROP TABLE
SELECT TID, amt, RunningTotal = SUM(amt) OVER (ORDER BY TID ROWS UNBOUNDED PRECEDING) FROM dbo.Transactions ORDER BY TID;
SELECT TID, amt, RunningTotal = SUM(amt) OVER (ORDER BY TID) FROM dbo.Transactions ORDER BY TID; SELECT TID, amt, RunningTotal = SUM(amt) OVER (ORDER BY TID RANGE UNBOUNDED PRECEDING) FROM dbo.Transactions ORDER BY TID;
select *, sum(amt) over (order by Tid) as running_total from Transactions
select *,(select sum(amt) from Transactions where Tid<=t.Tid) as running_total from Transactions as t
DECLARE @RunningBalance int = 0 SELECT Tid, Amt, 0 AS RunningBalance INTO FROM Transactions ORDER BY Tid UPDATE SET @RunningBalance = RunningBalance = @RunningBalance + Amt SELECT * FROM DROP TABLE
SELECT T1.* , T2.RunningSum FROM dbo.Transactions As T1 CROSS APPLY ( SELECT SUM(amt) AS RunningSum FROM dbo.Transactions AS CAT1 WHERE ( CAT1.TId <= T1.TId ) ) AS T2
SELECT * , SUM(T1.amt) OVER ( ORDER BY T1.TId ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS RunningTotal FROM dbo.Transactions AS t1
SELECT Auth_First_Name, Auth_Last_Name, Auth_Favorite_Number FROM Authors
Auth_First_Name is char(25) Auth_Last_Name is char(50) Auth_Favorite_Number is int
SELECT * FROM tempdb.sys.columns WHERE [object_id] = OBJECT_ID(N
CREATE PROCEDURE [fn].[GetQueryResultMetadata] @queryText VARCHAR(MAX) AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. --SET NOCOUNT ON; PRINT @queryText; DECLARE @sqlToExec NVARCHAR(MAX) = + @queryText + + ' SELECT C.Name [ColumnName], TP.Name [ColumnType], C.max_length [MaxLength], C.[precision] [Precision], C.[scale] [Scale], C.[is_nullable] IsNullable FROM tempdb.sys.columns C INNER JOIN tempdb.sys.types TP ON TP.system_type_id = C.system_type_id AND -- exclude custom types TP.system_type_id = TP.user_type_id WHERE [object_id] = OBJECT_ID(N ' EXEC sp_executesql @sqlToExec END
SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH FROM information_schema.columns WHERE TABLE_NAME =
SELECT * INTO your_staging_table FROM enormous_collection_of_views_tables_etc
DECLARE @query nvarchar(max) = EXEC sp_describe_first_result_set @query, null, 0;
select COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME=
SELECT * INTO TMP1 FROM ( SELECT TOP 1 ); SELECT o.name AS obj_name, TYPE_NAME(c.user_type_id) AS type_name, c.* FROM sys.objects AS o JOIN sys.columns AS c ON o.object_id = c.object_id WHERE o.name = DROP TABLE TMP1;
SELECT CAST(FLOOR(CAST(GETDATE() AS float)) as datetime)
SELECT CONVERT(datetime,FLOOR(CONVERT(float,GETDATE())))
SELECT TOP (10000) dbo.Users.Login, dbo.Users.Phone, GeoPhone.Country FROM dbo.Users CROSS APPLY (SELECT TOP 1 Country FROM dbo.GeoPhone WHERE dbo.Users.Phone <= dbo.GeoPhone.[End]) GeoPhone
SELECT TOP (10000) dbo.Users.Login, dbo.Users.Phone, GeoPhone.Country FROM dbo.Users OUTER APPLY (SELECT TOP 1 Country FROM dbo.GeoPhone WHERE dbo.Users.Phone <= dbo.GeoPhone.[End]) GeoPhone
SELECT TOP (10000) dbo.Users.Login, dbo.Users.Phone, GeoPhone.Country FROM dbo.Users CROSS APPLY (SELECT TOP 1 Country FROM dbo.GeoPhone WHERE ISNULL(dbo.Users.Phone, 0) <= dbo.GeoPhone.[End]) GeoPhone
SELECT TOP (10000) dbo.Users.Login, dbo.Users.Phone, GeoPhone.Country FROM dbo.Users CROSS APPLY (SELECT TOP 1 Country FROM dbo.GeoPhone WHERE dbo.Users.Phone <= dbo.GeoPhone.[End]) GeoPhone UNION ALL SELECT TOP (10000) dbo.Users.Login, dbo.Users.Phone, NULL AS Country FROM dbo.Users WHERE dbo.Users.Phone IS NULL
CREATE DATABASE [conformingName] CREATE DATABASE conformingName CREATE DATABASE [This & That | "Other"]
class Program { static void Main(string[] args) { RunTest(null); RunTest(IsolationLevel.Serializable); RunTest(null); Console.ReadKey(); } static void RunTest(IsolationLevel? isolationLevel) { using (var tran = isolationLevel == null ? null : new TransactionScope(0, new TransactionOptions() { IsolationLevel = isolationLevel.Value })) using (var conn = new SqlConnection("Data Source=(local); Integrated Security=true; Initial Catalog=master;")) { conn.Open(); var cmd = new SqlCommand(@" select case transaction_isolation_level WHEN 0 THEN WHEN 1 THEN WHEN 2 THEN WHEN 3 THEN WHEN 4 THEN WHEN 5 THEN end as lvl, @@SPID from sys.dm_exec_sessions where session_id = @@SPID", conn); using (var reader = cmd.ExecuteReader()) { while (reader.Read()) { Console.WriteLine("Isolation Level = " + reader.GetValue(0) + ", SPID = " + reader.GetValue(1)); } } if (tran != null) tran.Complete(); } } }
Isolation Level = ReadCommitted, SPID = 51 Isolation Level = Serializable, SPID = 51 Isolation Level = Serializable, SPID = 51
if not exists ( select * from sys.dm_exec_sessions where session_id = @@SPID and transaction_isolation_level = 2 ) set transaction isolation level read committed
SELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu ON tc.CONSTRAINT_NAME = ccu.Constraint_name WHERE tc.TABLE_NAME =
SELECT schema_name(ta.schema_id) SchemaName ,ta.name TableName ,ind.name ,indcol.key_ordinal Ord ,col.name ColumnName ,ind.type_desc ,ind.fill_factor from sys.tables ta inner join sys.indexes ind on ind.object_id = ta.object_id inner join sys.index_columns indcol on indcol.object_id = ta.object_id and indcol.index_id = ind.index_id inner join sys.columns col on col.object_id = ta.object_id and col.column_id = indcol.column_id where ind.is_primary_key = 1 order by ta.name ,indcol.key_ordinal
SELECT ccu.COLUMN_NAME, ccu.CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS tc INNER JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS ccu ON tc.CONSTRAINT_NAME = ccu.CONSTRAINT_NAME WHERE tc.TABLE_CATALOG = AND tc.TABLE_SCHEMA = AND tc.TABLE_NAME = AND tc.CONSTRAINT_TYPE =
select object_id from sys.objects where parent_object_id = OBJECT_ID(N and [type] = N
SELECT kcu.* FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ON tc.TABLE_NAME = kcu.TABLE_NAME AND tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME ORDER BY tc.TABLE_NAME ,tc.CONSTRAINT_NAME ,kcu.ORDINAL_POSITION
-- Assuming you have schema "Example" and the primary key name is "PK_Item" -- Notice that name of table is irrelevant here but is "Foobar" here IF (OBJECT_ID( BEGIN ALTER TABLE [Example].Foobar ADD CONSTRAINT PK_Item PRIMARY KEY ... END
if isnull(currate.currentrate) then 1 else currate.currentrate
SELECT orderhed.ordernum, orderhed.orderdate, currrate.currencycode, currrate.currentrate FROM orderhed LEFT OUTER JOIN currrate ON orderhed.company = currrate.company AND orderhed.orderdate = currrate.effectivedate
SELECT CASE WHEN currate.currentrate IS NULL THEN 1 ELSE currate.currentrate END FROM ...
SELECT orderhed.ordernum, orderhed.orderdate, currrate.currencycode, coalesce(currrate.currentrate, 1) as currentrate FROM orderhed LEFT OUTER JOIN currrate ON orderhed.company = currrate.company AND orderhed.orderdate = currrate.effectivedate
SELECT orderhed.ordernum, orderhed.orderdate, currrate.currencycode, IsNull(currrate.currentrate, 1) as currentrate FROM orderhed LEFT OUTER JOIN currrate ON orderhed.company = currrate.company AND orderhed.orderdate = currrate.effectivedate
SELECT orderhed.ordernum, orderhed.orderdate, currrate.currencycode, case(currrate.currentrate) when null then 1 else currrate.currentrate end FROM orderhed LEFT OUTER JOIN currrate ON orderhed.company = currrate.company AND orderhed.orderdate = currrate.effectivedate
CASE WHEN currate.currentrate is null THEN 1 ELSE currate.currentrate END as currentrate
SELECT isnull(PartNum,0) AS PartNumber, PartID FROM Part
SELECT (CASE WHEN PartNum IS NULL THEN 0 ELSE 1 END) AS PartNumber, PartID FROM Part
DECLARE @RunScript bit; SET @RunScript = 0; IF @RunScript != 1 BEGIN RAISERROR ( GOTO Skipper -- This will skip over the script and go to Skipper END PRINT PRINT PRINT PRINT Skipper: -- Don
select 1 return go select 2 return select 3 go select 4 return select 5 select 6 go
SET PARSEONLY ON; -- statement between here will not run SELECT GO -- statement below here will run SET PARSEONLY OFF;
if object_id( begin drop table end create table set nocount on insert set nocount off -- Start of first batch if ((select continueScript from print -- Conditionally terminate entire script if (1=1) begin set nocount on update set nocount off return end end go -- Start of second batch if ((select continueScript from print end go
if object_id( begin drop table end create table set nocount on insert set nocount off begin transaction; -- Batch 1 starts here if ((select continueScript from begin try print if (1=0) begin print set nocount on update set nocount off return end print if (1=0) begin print set nocount on update set nocount off return end set nocount on -- use 1/0 to generate an exception here select 1/1 as test set nocount off end try begin catch set nocount on select error_number() as errornumber ,error_severity() as errorseverity ,error_state() as errorstate ,error_procedure() as errorprocedure ,error_line() as errorline ,error_message() as errormessage; print update set nocount off return end catch; end go -- Batch 2 starts here if ((select continueScript from begin try print if (1=0) begin print set nocount on update set nocount off return end print if (1=0) begin print set nocount on update set nocount off return end set nocount on -- use 1/0 to generate an exception here select 1/1 as test set nocount off end try begin catch set nocount on select error_number() as errornumber ,error_severity() as errorseverity ,error_state() as errorstate ,error_procedure() as errorprocedure ,error_line() as errorline ,error_message() as errormessage; print update set nocount off return end catch; end go if @@trancount > 0 begin if ((select continueScript from commit transaction print end else begin rollback transaction; print end end
create proc dbo.prSess_Ins ( @sSessID varchar( 32 ) , @idSess int out ) as begin set nocount on select @id= idSess from tbSess where sSessID = @sSessID if @idSess > 0 return -- exit sproc here begin tran insert tbSess ( sSessID ) values ( @sSessID ) select @idSess= scope_identity( ) commit end
if @idSess is null begin begin tran insert tbSess ( sSessID ) values ( @sSessID ) select @idSess= scope_identity( ) commit end
create function FnGetCompanyIdWithCategories() returns table as return ( select * into a ' etc ' select companyid,Company_MarketSector from )
ALTER FUNCTION FnGetCompanyIdWithCategories() RETURNS @rtnTable TABLE ( -- columns returned by the function ID UNIQUEIDENTIFIER NOT NULL, Name nvarchar(255) NOT NULL ) AS BEGIN DECLARE @TempTable table (id uniqueidentifier, name nvarchar(255)....) insert into @myTable select from your stuff --This select returns data insert into @rtnTable SELECT ID, name FROM @mytable return END
declare @table as table (id int, name nvarchar(50),templateid int,account nvarchar(50)) insert into @table execute industry_getall select * from @table inner join [user] on account=[user].loginname
select * from fn_Industry_GetAll() inner join [user] on account=[user].loginname
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO -- ============================================= -- Author: <Author,,Name> -- Create date: <Create Date,,> -- Description: <Description,,> -- ============================================= CREATE FUNCTION <Table_Function_Name, sysname, FunctionName> ( -- Add the parameters for the function here <@param1, sysname, @p1> <data_type_for_param1, , int>, <@param2, sysname, @p2> <data_type_for_param2, , char> ) RETURNS <@Table_Variable_Name, sysname, @Table_Var> TABLE ( -- Add the column definitions for the TABLE variable here <Column_1, sysname, c1> <Data_Type_For_Column1, , int>, <Column_2, sysname, c2> <Data_Type_For_Column2, , int> ) AS BEGIN -- Fill the table variable with the rows for your result set RETURN END GO
if object_id ( drop function ods.uf_DateHierarchy go create function ods.uf_DateHierarchy ( @DateFrom datetime ,@DateTo datetime ) returns @DateHierarchy table ( DateKey datetime ,DisplayDate varchar (20) ,SemanticDate datetime ,MonthKey int ,DisplayMonth varchar (10) ,FirstDayOfMonth datetime ,QuarterKey int ,DisplayQuarter varchar (10) ,FirstDayOfQuarter datetime ,YearKey int ,DisplayYear varchar (10) ,FirstDayOfYear datetime ) as begin declare @year int ,@quarter int ,@month int ,@day int ,@m1ofqtr int ,@DisplayDate varchar (20) ,@DisplayQuarter varchar (10) ,@DisplayMonth varchar (10) ,@DisplayYear varchar (10) ,@today datetime ,@MonthKey int ,@QuarterKey int ,@YearKey int ,@SemanticDate datetime ,@FirstOfMonth datetime ,@FirstOfQuarter datetime ,@FirstOfYear datetime ,@MStr varchar (2) ,@QStr varchar (2) ,@Ystr varchar (4) ,@DStr varchar (2) ,@DateStr varchar (10) -- === Previous =================================================== -- Special placeholder date of 1/1/1800 used to denote -- so that naive date calculations sort and compare in a sensible -- order. -- insert @DateHierarchy ( DateKey ,DisplayDate ,SemanticDate ,MonthKey ,DisplayMonth ,FirstDayOfMonth ,QuarterKey ,DisplayQuarter ,FirstDayOfQuarter ,YearKey ,DisplayYear ,FirstDayOfYear ) values ( , , ,180001 , , ,18001 , , ,1800 , , ) -- === Calendar Dates ============================================= -- These are generated from the date range specified in the input -- parameters. -- set @today = @Datefrom while @today <= @DateTo begin set @year = datepart (yyyy, @today) set @month = datepart (mm, @today) set @day = datepart (dd, @today) set @quarter = case when @month in (1,2,3) then 1 when @month in (4,5,6) then 2 when @month in (7,8,9) then 3 when @month in (10,11,12) then 4 end set @m1ofqtr = @quarter * 3 - 2 set @DisplayDate = left (convert (varchar, @today, 113), 11) set @SemanticDate = @today set @MonthKey = @year * 100 + @month set @DisplayMonth = substring (convert (varchar, @today, 113), 4, 8) set @Mstr = right ( set @Dstr = right ( set @Ystr = convert (varchar, @year) set @DateStr = @Ystr + set @FirstOfMonth = convert (datetime, @DateStr, 120) set @QuarterKey = @year * 10 + @quarter set @DisplayQuarter = convert (varchar, @year) set @QStr = right ( set @DateStr = @Ystr + set @FirstOfQuarter = convert (datetime, @DateStr, 120) set @YearKey = @year set @DisplayYear = convert (varchar, @year) set @DateStr = @Ystr + set @FirstOfYear = convert (datetime, @DateStr) insert @DateHierarchy ( DateKey ,DisplayDate ,SemanticDate ,MonthKey ,DisplayMonth ,FirstDayOfMonth ,QuarterKey ,DisplayQuarter ,FirstDayOfQuarter ,YearKey ,DisplayYear ,FirstDayOfYear ) values ( @today ,@DisplayDate ,@SemanticDate ,@Monthkey ,@DisplayMonth ,@FirstOfMonth ,@QuarterKey ,@DisplayQuarter ,@FirstOfQuarter ,@YearKey ,@DisplayYear ,@FirstOfYear ) set @today = dateadd (dd, 1, @today) end -- === Specials =================================================== -- -- avoid accidental collisions on -- insert @DateHierarchy ( DateKey ,DisplayDate ,SemanticDate ,MonthKey ,DisplayMonth ,FirstDayOfMonth ,QuarterKey ,DisplayQuarter ,FirstDayOfQuarter ,YearKey ,DisplayYear ,FirstDayOfYear ) values ( , , ,900001 , , ,90001 , , ,9000 , , ) insert @DateHierarchy ( DateKey ,DisplayDate ,SemanticDate ,MonthKey ,DisplayMonth ,FirstDayOfMonth ,QuarterKey ,DisplayQuarter ,FirstDayOfQuarter ,YearKey ,DisplayYear ,FirstDayOfYear ) values ( , ,null ,910001 , ,null ,91001 , ,null ,9100 , ,null ) insert @DateHierarchy ( DateKey ,DisplayDate ,SemanticDate ,MonthKey ,DisplayMonth ,FirstDayOfMonth ,QuarterKey ,DisplayQuarter ,FirstDayOfQuarter ,YearKey ,DisplayYear ,FirstDayOfYear ) values ( , ,null ,920001 , ,null ,92001 , ,null ,9200 , ,null ) return end go
CREATE PROCEDURE name AS SELECT stuff INTO ....... SELECT columns FROM
DECLARE @date datetime, @tmpdate datetime, @years int, @months int, @days int SELECT @date = SELECT @tmpdate = @date SELECT @years = DATEDIFF(yy, @tmpdate, GETDATE()) - CASE WHEN (MONTH(@date) > MONTH(GETDATE())) OR (MONTH(@date) = MONTH(GETDATE()) AND DAY(@date) > DAY(GETDATE())) THEN 1 ELSE 0 END SELECT @tmpdate = DATEADD(yy, @years, @tmpdate) SELECT @months = DATEDIFF(m, @tmpdate, GETDATE()) - CASE WHEN DAY(@date) > DAY(GETDATE()) THEN 1 ELSE 0 END SELECT @tmpdate = DATEADD(m, @months, @tmpdate) SELECT @days = DATEDIFF(d, @tmpdate, GETDATE()) SELECT @years, @months, @days
SELECT CASE WHEN (DATEADD(year,DATEDIFF(year, @datestart ,@dateend) , @datestart) > @dateend) THEN DATEDIFF(year, @datestart ,@dateend) -1 ELSE DATEDIFF(year, @datestart ,@dateend) END
Select cast((DATEDIFF(m, date_of_birth, GETDATE())/12) as varchar) + cast((DATEDIFF(m, date_of_birth, GETDATE())%12) as varchar) +
CREATE PROCEDURE dbo.CalculateAge @dayOfBirth datetime AS DECLARE @today datetime, @thisYearBirthDay datetime DECLARE @years int, @months int, @days int SELECT @today = GETDATE() SELECT @thisYearBirthDay = DATEADD(year, DATEDIFF(year, @dayOfBirth, @today), @dayOfBirth) SELECT @years = DATEDIFF(year, @dayOfBirth, @today) - (CASE WHEN @thisYearBirthDay > @today THEN 1 ELSE 0 END) SELECT @months = MONTH(@today - @thisYearBirthDay) - 1 SELECT @days = DAY(@today - @thisYearBirthDay) - 1 SELECT @years, @months, @days GO
create function [dbo].[Age](@dayOfBirth datetime, @today datetime) RETURNS varchar(100) AS Begin DECLARE @thisYearBirthDay datetime DECLARE @years int, @months int, @days int set @thisYearBirthDay = DATEADD(year, DATEDIFF(year, @dayOfBirth, @today), @dayOfBirth) set @years = DATEDIFF(year, @dayOfBirth, @today) - (CASE WHEN @thisYearBirthDay > @today THEN 1 ELSE 0 END) set @months = MONTH(@today - @thisYearBirthDay) - 1 set @days = DAY(@today - @thisYearBirthDay) - 1 return cast(@years as varchar(2)) + end
declare @now date,@dob date, @now_i int,@dob_i int, @days_in_birth_month int declare @years int, @months int, @days int set @now = set @dob = set @now_i = convert(varchar(8),@now,112) -- iso formatted: 20130228 set @dob_i = convert(varchar(8),@dob,112) -- iso formatted: 20120229 set @years = ( @now_i - @dob_i)/10000 -- (20130228 - 20120229)/10000 = 0 years set @months =(1200 + (month(@now)- month(@dob))*100 + day(@now) - day(@dob))/100 %12 -- (1200 + 0228 - 0229)/100 % 12 = 11 months set @days_in_birth_month = day(dateadd(d,-1,left(convert(varchar(8),dateadd(m,1,@dob),112),6)+ set @days = (sign(day(@now) - day(@dob))+1)/2 * (day(@now) - day(@dob)) + (sign(day(@dob) - day(@now))+1)/2 * (@days_in_birth_month - day(@dob) + day(@now)) -- ( (-1+1)/2*(28 - 29) + (1+1)/2*(29 - 29 + 28)) -- Explain: if the days of now is bigger than the days of birth, then diff the two days -- else add the days of now and the distance from the date of birth to the end of the birth month select @years,@months,@days -- 0, 11, 28
dob now years months days 2012-02-29 2013-02-28 0 11 28 --Days will be 30 if calculated by the approach in accepted answer. 2012-02-29 2016-02-28 3 11 28 --Days will be 31 if calculated by the approach in accepted answer, since the day of birth will be changed to 28 from 29 after dateadd by years. 2012-02-29 2016-03-31 4 1 2 2012-01-30 2016-02-29 4 0 30 2012-01-30 2016-03-01 4 1 2 --Days will be 1 if calculated by the approach in accepted answer, since the day of birth will be changed to 30 from 29 after dateadd by years. 2011-12-30 2016-02-29 4 1 30
set @days = CASE WHEN day(@now) >= day(@dob) THEN day(@now) - day(@dob) ELSE @days_in_birth_month - day(@dob) + day(@now) END
set @years = ( @now_i/100 - @dob_i/100)/100 set @months =(12 + month(@now) - month(@dob))%12 select @years,@months -- 1, 0
create procedure getDatedifference ( @startdate datetime, @enddate datetime ) as begin declare @monthToShow int declare @dayToShow int --set @startdate= --set @enddate=getdate() if (DAY(@startdate) > DAY(@enddate)) begin set @dayToShow=0 if (month(@startdate) > month(@enddate)) begin set @monthToShow= (12-month(@startdate)+ month(@enddate)-1) end else if (month(@startdate) < month(@enddate)) begin set @monthToShow= ((month(@enddate)-month(@startdate))-1) end else begin set @monthToShow= 11 end -- set @monthToShow= convert(int, DATEDIFF(mm,0,DATEADD(dd,DATEDIFF(dd,0,@enddate)- DATEDIFF(dd,0,@startdate),0)))-((convert(int,FLOOR(DATEDIFF(day, @startdate, @enddate) / 365.25))*12))-1 if(@monthToShow<0) begin set @monthToShow=0 end declare @amonthbefore integer set @amonthbefore=Month(@enddate)-1 if(@amonthbefore=0) begin set @amonthbefore=12 end if (@amonthbefore in(1,3,5,7,8,10,12)) begin set @dayToShow=31-DAY(@startdate)+DAY(@enddate) end if (@amonthbefore=2) begin IF (YEAR( @enddate ) % 4 = 0 AND YEAR( @enddate ) % 100 != 0) OR YEAR( @enddate ) % 400 = 0 begin set @dayToShow=29-DAY(@startdate)+DAY(@enddate) end else begin set @dayToShow=28-DAY(@startdate)+DAY(@enddate) end end if (@amonthbefore in (4,6,9,11)) begin set @dayToShow=30-DAY(@startdate)+DAY(@enddate) end end else begin --set @monthToShow=convert(int, DATEDIFF(mm,0,DATEADD(dd,DATEDIFF(dd,0,@enddate)- DATEDIFF(dd,0,@startdate),0)))-((convert(int,FLOOR(DATEDIFF(day, @startdate, @enddate) / 365.25))*12)) if (month(@enddate)< month(@startdate)) begin set @monthToShow=12+(month(@enddate)-month(@startdate)) end else begin set @monthToShow= (month(@enddate)-month(@startdate)) end set @dayToShow=DAY(@enddate)-DAY(@startdate) end SELECT FLOOR(DATEDIFF(day, @startdate, @enddate) / 365.25) as [yearToShow], @monthToShow as monthToShow ,@dayToShow as dayToShow , convert(varchar,FLOOR(DATEDIFF(day, @startdate, @enddate) / 365.25)) + return end
CREATE Function [dbo].[F_Get_Actual_Age](@pi_date1 datetime,@pi_date2 datetime) RETURNS Numeric(7,4) AS BEGIN Declare @l_tmp_date DATETIME ,@l_days1 DECIMAL(9,6) ,@l_days2 DECIMAL(9,6) ,@l_result DECIMAL(10,6) ,@l_years DECIMAL(7,4) --Check to make sure there is a date for both inputs IF @pi_date1 IS NOT NULL and @pi_date2 IS NOT NULL BEGIN IF @pi_date1 > @pi_date2 --Make sure the "older" date is in @pi_date1 BEGIN SET @l_tmp_date = @pi_date2 SET @pi_date2 = @Pi_date1 SET @pi_date1 = @l_tmp_date END --Check IF DATEADD(YYYY,1,@pi_date1) > @pi_date2 BEGIN --How many days between the two dates (numerator) SET @l_days1 = DATEDIFF(dd,@pi_date1, @pi_date2) --subtract 1 year from date2 and calculate days bewteen it and date2 --This is to get the denominator and accounts for leap year (365 or 366 days) SET @l_days2 = DATEDIFF(dd,dateadd(yyyy,-1,@pi_date2),@pi_date2) SET @l_years = @l_days1 / @l_days2 -- Do the math END ELSE --Check --Calculate years bewteen date1 and date2, then add the years to date1, compare dates to see if exactly the same. IF DATEADD(YYYY,DATEDIFF(YYYY,@pi_date1,@pi_date2),@pi_date1) = @pi_date2 SET @l_years = DATEDIFF(YYYY,@pi_date1, @pi_date2) --AS Years, ELSE BEGIN --Check --Check if datediff, returning years, over or under states the years difference SET @l_years = DATEDIFF(YYYY,@pi_date1, @pi_date2) IF DATEADD(YYYY,@l_years,@pi_date1) > @pi_date2 SET @l_years = @l_years -1 --use basicly same logic as in check SET @l_days1 = DATEDIFF(dd,DATEADD(YYYY,@l_years,@pi_date1), @pi_date2) SET @l_days2 = DATEDIFF(dd,dateadd(yyyy,-1,@pi_date2),@pi_date2) SET @l_years = @l_years + @l_days1 / @l_days2 --SELECT @l_years AS Years, END END ELSE SET @l_years = 0 --If either date was null RETURN @l_Years --Return the result as decimal(7,4) END
Declare @BirthDate As DateTime Set @BirthDate = SELECT DATEDIFF(YEAR,@BirthDate,GETDATE()) - (CASE WHEN MONTH(@BirthDate)> MONTH(GETDATE()) THEN 1 WHEN MONTH(@BirthDate)= MONTH(GETDATE()) AND DAY(@BirthDate) > DAY(GETDATE()) THEN 1 Else 0 END)
SELECT CAST(DATEDIFF(hour,Birthdate,CAST(GETDATE() as Date))/8766.0 as INT) AS Age FROM <YourTable>
CREATE FUNCTION dbo.EdadAMD ( @FECHA DATETIME ) RETURNS NVARCHAR(10) AS BEGIN DECLARE @tmpdate DATETIME , @years INT , @months INT , @days INT , @EdadAMD NVARCHAR(10); SELECT @tmpdate = @FECHA; SELECT @years = DATEDIFF(yy, @tmpdate, GETDATE()) - CASE WHEN (MONTH(@FECHA) > MONTH(GETDATE())) OR ( MONTH(@FECHA) = MONTH(GETDATE()) AND DAY(@FECHA) > DAY(GETDATE()) ) THEN 1 ELSE 0 END; SELECT @tmpdate = DATEADD(yy, @years, @tmpdate); SELECT @months = DATEDIFF(m, @tmpdate, GETDATE()) - CASE WHEN DAY(@FECHA) > DAY(GETDATE()) THEN 1 ELSE 0 END; SELECT @tmpdate = DATEADD(m, @months, @tmpdate); IF MONTH(@FECHA) = MONTH(GETDATE()) AND DAY(@FECHA) > DAY(GETDATE()) SELECT @days = DAY(EOMONTH(GETDATE(), -1)) - (DAY(@FECHA) - DAY(GETDATE())); ELSE SELECT @days = DATEDIFF(d, @tmpdate, GETDATE()); SELECT @EdadAMD = CONCAT(@years, RETURN @EdadAMD; END; GO
Select DateDiff(d, Select DateDiff(m, Select DateDiff(yyyy,
select trunc((sysdate -to_date( trunc(mod(( sysdate -to_date( trunc((mod((mod((sysdate -to_date( from dual
declare @birthdate datetime set @birthdate = --age in years - short version print year(getdate() - @birthdate) - year(0) --age in years - visualization declare @mindate datetime declare @span datetime set @mindate = 0 set @span = getdate() - @birthdate print @mindate print @birthdate print getdate() print @span --substract minyear from spanyear to get age in years print year(@span) - year(@mindate) print month(@span) print day(@span)
CREATE FUNCTION DBO.GET_AGE ( @DATE AS DATETIME ) RETURNS VARCHAR(MAX) AS BEGIN DECLARE @YEAR AS VARCHAR(50) = DECLARE @MONTH AS VARCHAR(50) = DECLARE @DAYS AS VARCHAR(50) = DECLARE @RESULT AS VARCHAR(MAX) = SET @YEAR = CONVERT(VARCHAR,(SELECT DATEDIFF(MONTH,CASE WHEN DAY(@DATE) > DAY(GETDATE()) THEN DATEADD(MONTH,1,@DATE) ELSE @DATE END,GETDATE()) / 12 )) SET @MONTH = CONVERT(VARCHAR,(SELECT DATEDIFF(MONTH,CASE WHEN DAY(@DATE) > DAY(GETDATE()) THEN DATEADD(MONTH,1,@DATE) ELSE @DATE END,GETDATE()) % 12 )) SET @DAYS = DATEDIFF(DD,DATEADD(MM,CONVERT(INT,CONVERT(INT,@YEAR)*12 + CONVERT(INT,@MONTH)),@DATE),GETDATE()) SET @RESULT = (RIGHT( RETURN @RESULT END SELECT DBO.GET_AGE(
DECLARE @BirthDate datetime, @AgeInMonths int SET @BirthDate = SET @AgeInMonths -- Determine the age in "months old": = DATEDIFF(MONTH, @BirthDate, GETDATE()) -- .Get the difference in months - CASE WHEN DATEPART(DAY,GETDATE()) -- .If today was the 1st to 4th, < DATEPART(DAY,@BirthDate) -- (or before the birth day of month) THEN 1 ELSE 0 END -- ... don SELECT @AgeInMonths / 12 as AgeYrs -- Divide by 12 months to get the age in years ,@AgeInMonths % 12 as AgeXtraMonths -- Get the remainder of dividing by 12 months = extra months ,DATEDIFF(DAY -- For the extra days, find the difference between, ,DATEADD(MONTH, @AgeInMonths -- 1. Last Monthly Birthday , @BirthDate) -- (if birthdays were celebrated monthly) ,GETDATE()) as AgeXtraDays -- 2. Today
CASE WHEN DateOfBirth< DATEADD(YEAR, (DATEPART(YEAR, GETDATE()) - DATEPART(YEAR, DateOfBirth))*-1, GETDATE()) THEN DATEPART(YEAR, GETDATE()) - DATEPART(YEAR, DateOfBirth) ELSE DATEPART(YEAR, GETDATE()) - DATEPART(YEAR, DateOfBirth) -1 END
select case when cast(getdate() as date) = cast(dateadd(year, (datediff(year, then dateDiff(yyyy, else dateDiff(yyyy, end as MemberAge go
FirstName LastName DOB sai krishnan 1991-11-04 Harish S A 1998-10-11
Select datediff(MONTH,DOB,getdate())/12 as dates from [Organization].[Employee]
declare @StartDate datetime = declare @EndDate datetime = SELECT @StartDate AS [StartDate] ,@EndDate AS [EndDate] ,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END AS [Years] ,DATEDIFF(Month,(DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate)),@EndDate) - CASE WHEN DATEADD(Month, DATEDIFF(Month,DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate),@EndDate) , @StartDate) > @EndDate THEN 1 ELSE 0 END AS [Months] ,DATEDIFF(Day, DATEADD(Month,DATEDIFF(Month, (DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate)),@EndDate) - CASE WHEN DATEADD(Month, DATEDIFF(Month,DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate),@EndDate) , @StartDate) > @EndDate THEN 1 ELSE 0 END ,DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate)) ,@EndDate) - CASE WHEN DATEADD(Day,DATEDIFF(Day, DATEADD(Month,DATEDIFF(Month, (DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate)),@EndDate) - CASE WHEN DATEADD(Month, DATEDIFF(Month,DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate),@EndDate) , @StartDate) > @EndDate THEN 1 ELSE 0 END ,DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate)) ,@EndDate),DATEADD(Month,DATEDIFF(Month, (DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate)),@EndDate) - CASE WHEN DATEADD(Month, DATEDIFF(Month,DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate),@EndDate) , @StartDate) > @EndDate THEN 1 ELSE 0 END ,DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate) - CASE WHEN DATEADD(Year,DATEDIFF(Year,@StartDate,@EndDate), @StartDate) > @EndDate THEN 1 ELSE 0 END,@StartDate))) > @EndDate THEN 1 ELSE 0 END AS [Days]
select DOB as Birthdate, YEAR(GETDATE()) as ThisYear, YEAR(getdate()) - EAR(date1) as Age from TableName
SELECT DOB AS Birthdate , YEAR(GETDATE()) AS ThisYear, YEAR(getdate()) - YEAR(DOB) AS Age FROM tableprincejain
DECLARE @DoB AS DATE = DECLARE @cDate AS DATE = CAST( SELECT --Get Year difference DATEDIFF(YEAR,@DoB,@cDate) - --Cases where year difference will be augmented CASE --If Date of Birth greater than date passed return 0 WHEN YEAR(@DoB) - YEAR(@cDate) >= 0 THEN DATEDIFF(YEAR,@DoB,@cDate) --If date of birth month less than date passed subtract one year WHEN MONTH(@DoB) - MONTH(@cDate) > 0 THEN 1 --If date of birth day less than date passed subtract one year WHEN MONTH(@DoB) - MONTH(@cDate) = 0 AND DAY(@DoB) - DAY(@cDate) > 0 THEN 1 --All cases passed subtract zero ELSE 0 END
SELECT OBJECT_NAME(parent_id) [table_name],[name] [trigger_name],is_disabled FROM sys.triggers
SELECT TOP @topparam * from table1 command.Parameters.Add("@topparam",SqlDbType.VarChar, 10).Value = somevalue.ToString();
DECLARE @iNum INT SET @iNum = 10 SELECT TOP (@iNum) TableColumnID FROM TableName
CREATE PROCEDURE TopNRecords @intTop INTEGER AS SET ROWCOUNT @intTop SELECT * FROM SomeTable SET ROWCOUNT 0 GO
sp_CONFIGURE GO RECONFIGURE GO sp_CONFIGURE GO RECONFIGURE GO
USE msdb GO EXEC sp_send_dbmail @profile_name= @recipients= @subject= @body= Congrates Database Mail Received By you Successfully.'
DECLARE @email_id NVARCHAR(450), @id BIGINT, @max_id BIGINT, @query NVARCHAR(1000) SELECT @id=MIN(id), @max_id=MAX(id) FROM [email_adresses] WHILE @id<=@max_id BEGIN SELECT @email_id=email_id FROM [email_adresses] set @query= @recipients= @subject= @body= Congrates Database Mail Received By you Successfully. EXEC @query SELECT @id=MIN(id) FROM [email_adresses] where id>@id END
EXEC msdb.dbo.sp_send_dbmail @recipients= @subject= @body= @body_format= @from_address= @reply_to=
CREATE TABLE INSERT INSERT INSERT DECLARE @recipients VARCHAR(MAX) SELECT @recipients = COALESCE(@recipients + FROM SELECT @recipients DROP TABLE
AS declare @results varchar(max) declare @subjectText varchar(max) declare @databaseName VARCHAR(255) SET @subjectText = SET @results = -- write the Trigger JOB EXEC msdb.dbo.sp_send_dbmail @profile_name = @recipients = @body = @results, @subject = @subjectText, @exclude_query_output = 1 --Suppress GO
USE database_name GO SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE PROCEDURE mass_email AS declare @email nvarchar (50) declare @body nvarchar (255) declare test_cur cursor for SELECT email from [dbo].[EmailMessageTable] open test_cur fetch next from test_cur into @email while @@fetch_status = 0 begin set @body = (SELECT body from [dbo].[EmailMessageTable] where email = @email) EXEC msdb.dbo.sp_send_dbmail @profile_name = @recipients = @email, @body = @body, @subject = fetch next from test_cur into @email end close test_cur deallocate test_cur
CREATE PROCEDURE [dbo].[insertSomeData] (@myParam int) AS DECLARE @reply varchar(2048) ... Do a bunch of inserts/updates... SET @reply = SELECT @reply GO
WHILE unprocessedRecordsLeft BEGIN SELECT top 1 record from updateTable where Processed = 0 EXEC insertSomeData @param = record_From_UpdateTable END
DECLARE @tmpNewValue TABLE (newvalue int) INSERT INTO @tmpNewValue EXEC ProcedureB
create table while not_done begin select top 1 record from updateTable where processed = 0 insert into end drop table
CREATE PROCEDURE usp_SilentExecutionProc @silentExecution bit = 0 AS BEGIN SET NOCOUNT ON; DECLARE @strSQL VARCHAR(MAX); SET @strSQL = SET @strSQL = IF @silentExecution = 1 SET @strSQL = @strSQL + SET @strSQL = @strSQL + EXEC(@strSQL); END GO
EXEC dbo.usp_SilentExecutionProc @silentExecution = 1; SELECT @@ROWCOUNT;
CREATE PROCEDURE [dbo].[insertSomeData] (@myParam int) AS BEGIN DECLARE @reply varchar(2048) --... Do a bunch of inserts/updates... EXEC SelectOutput END GO CREATE PROCEDURE SelectOutput AS BEGIN SET @reply = SELECT @reply END
var com = myConnection.CreateCommand(); com.CommandText = "exec insertSomeData 1"; var read = com.ExecuteReader();
var com = myConnection.CreateCommand(); com.CommandText = "exec insertSomeData 1"; com.ExecuteNonQuery();
DECLARE @counter INT SET @counter = 10 WHILE @counter > 0 BEGIN -- call a procedure which returns some resultset SELECT @counter-- (simulating the effect of stored proc returning some resultset) SET @counter = @counter - 1 END
create table employee ( EmpId number, EmpName varchar2(10), EmpSSN varchar2(11) ); insert into employee values(1, insert into employee values (2, insert into employee values (3, insert into employee values (4, insert into employee values (5, insert into employee values (6, insert into employee values (1, insert into employee values (4, insert into employee values (5, insert into employee values (6 , insert into employee values (5, insert into employee values (6,
ALTER TABLE Employee ADD EmployeeID int identity(1,1) PRIMARY KEY; WHILE EXISTS (SELECT COUNT(*) FROM Employee GROUP BY EmpID, EmpSSN HAVING COUNT(*) > 1) BEGIN DELETE FROM Employee WHERE EmployeeID IN ( SELECT MIN(EmployeeID) as [DeleteID] FROM Employee GROUP BY EmpID, EmpSSN HAVING COUNT(*) > 1 ) END
DELETE SUB FROM (SELECT ROW_NUMBER() OVER (PARTITION BY EmpId, EmpName, EmpSSN ORDER BY EmpId) cnt FROM Employee) SUB WHERE SUB.cnt > 1
DELETE FROM Employee a WHERE ROW_NUMBER() <> ( SELECT MIN( ROW_NUMBER() ) FROM Employee b WHERE a.EmpID = b.EmpID AND a.EmpSSN = b.EmpSSN )
With duplicates As (Select *, ROW_NUMBER() Over (PARTITION by EmpID,EmpSSN Order by EmpID,EmpSSN) as Duplicate From Employee) delete From duplicates Where Duplicate > 1 ;
select distinct * into newtablename from oldtablename
DELETE DUP FROM ( SELECT ROW_NUMBER() OVER (PARTITION BY Clientid ORDER BY Clientid ) AS Val FROM ClientMaster ) DUP WHERE DUP.Val > 1
declare @ID int while EXISTS(select count(*) from Employee group by EmpId having count(*)> 1) begin select top 1 @ID = EmpId from Employee group by EmpId having count(*) > 1 DELETE TOP(1) FROM Employee WHERE EmpId = @ID end
WITH Dups AS ( SELECT col1,col2,col3, ROW_NUMBER() OVER(PARTITION BY col1,col2,col3 ORDER BY (SELECT 0)) AS rn FROM mytable ) DELETE FROM Dups WHERE rn > 1
select t1.empid, t1.empssn, count(*) from employee as t1 inner join employee as t2 on (t1.empid=t2.empid and t1.empssn = t2.empssn) group by t1.empid, t1.empssn having count(*) > 1
WHILE ( SELECT COUNT(*) FROM TBLEMP WHERE EMPNO IN (SELECT empno from tblemp group by empno having count(empno)>1)) > 1 DELETE top(1) FROM TBLEMP WHERE EMPNO IN (SELECT empno from tblemp group by empno having count(empno)>1)
DELETE FROM dbo.tbl1 WHERE id NOT IN ( Select MIN(Id) AS namecount FROM tbl1 GROUP BY Name )
DELETE FROM [TABLE_NAME] WHERE [Id] IN ( SELECT MAX([Id]) FROM [TABLE_NAME] GROUP BY [TARGET_COLUMN] HAVING COUNT(*) > 1 ) SELECT MAX([Id]),[TABLE_NAME], COUNT(*) AS dupeCount FROM [TABLE_NAME] GROUP BY [TABLE_NAME] HAVING COUNT(*) > 1
select t1.* from employee t1, employee t2 where t1.empid=t2.empid and t1.empname = t2.empname and t1.salary = t2.salary group by t1.empid, t1.empname,t1.salary having count(*) > 1
DELETE FROM USING WHERE test.id>vtable.id and test.common_column=vtable.common_column
DECLARE @Ids varchar(50); SET @Ids = SELECT * FROM sometable WHERE tableid IN (@Ids);
CREATE TABLE Numbers (Number int NOT NULL, CONSTRAINT PK_Numbers PRIMARY KEY CLUSTERED (Number ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] DECLARE @x int SET @x=0 WHILE @x<8000 BEGIN SET @x=@x+1 INSERT INTO Numbers VALUES (@x) END
CREATE FUNCTION [dbo].[FN_ListToTable] ( @SplitOn char(1) --REQUIRED, the character to split the @List string on ,@List varchar(8000) --REQUIRED, the list to split apart ) RETURNS @ParsedList table ( ListValue varchar(500) ) AS BEGIN /** Takes the given @List string and splits it apart based on the given @SplitOn character. A table is returned, one row per split item, with a column name "ListValue". This function workes for fixed or variable lenght items. Empty and null items will not be included in the results set. Returns a table, one row per item in the list, with a column name "ListValue" EXAMPLE: ---------- SELECT * FROM dbo.FN_ListToTable( returns: ListValue ----------- 1 12 123 1234 54321 6 A * ||| B (10 row(s) affected) **/ ---------------- --SINGLE QUERY-- --this will not return empty rows ---------------- INSERT INTO @ParsedList (ListValue) SELECT ListValue FROM (SELECT LTRIM(RTRIM(SUBSTRING(List2, number+1, CHARINDEX(@SplitOn, List2, number+1)-number - 1))) AS ListValue FROM ( SELECT @SplitOn + @List + @SplitOn AS List2 ) AS dt INNER JOIN Numbers n ON n.Number < LEN(dt.List2) WHERE SUBSTRING(List2, number, 1) = @SplitOn ) dt2 WHERE ListValue IS NOT NULL AND ListValue!= RETURN END --Function FN_ListToTable
SELECT Col1, COl2, Col3... FROM YourTable INNER JOIN FN_ListToTable(
Select * from sometable where tableid in(SELECT ListValue FROM dbo.FN_ListToTable(
Declare @Ids varchar(50) Set @Ids = Select * from sometable where Charindex(
Declare @Ids varchar(50) Set @Ids = ‘1,2,3,5,4,6,7,98,234’ DECLARE @XML XML SET @XML = CAST( SELECT * FROM SomeTable INNER JOIN @XML.nodes( ON SomeTable .Id = x.i.value(
select * from someable join Splitfunction(@ids) as splits on sometable.id = splits.id
CREATE FUNCTION [dbo].[FUNC_SplitOrderIDs] ( @OrderList varchar(500) ) RETURNS @ParsedList table ( OrderID int ) AS BEGIN DECLARE @OrderID varchar(10), @Pos int SET @OrderList = LTRIM(RTRIM(@OrderList))+ SET @Pos = CHARINDEX( IF REPLACE(@OrderList, BEGIN WHILE @Pos > 0 BEGIN SET @OrderID = LTRIM(RTRIM(LEFT(@OrderList, @Pos - 1))) IF @OrderID <> BEGIN INSERT INTO @ParsedList (OrderID) VALUES (CAST(@OrderID AS int)) --Use Appropriate conversion END SET @OrderList = RIGHT(@OrderList, LEN(@OrderList) - @Pos) SET @Pos = CHARINDEX( END END RETURN END
(@id as varchar(50)) as Declare @query as nvarchar(max) set @query =' select * from table where id in( EXECUTE sp_executesql @query
DECLARE @Delim char(1) = SET @Ids = @Ids + @Delim; WITH CTE(i, ls, id) AS ( SELECT 1, CHARINDEX(@Delim, @Ids, 1), SUBSTRING(@Ids, 1, CHARINDEX(@Delim, @Ids, 1) - 1) UNION ALL SELECT i + 1, CHARINDEX(@Delim, @Ids, ls + 1), SUBSTRING(@Ids, ls + 1, CHARINDEX(@Delim, @Ids, ls + 1) - CHARINDEX(@Delim, @Ids, ls) - 1) FROM CTE WHERE CHARINDEX(@Delim, @Ids, ls + 1) > 1 ) SELECT t.* FROM yourTable t INNER JOIN CTE c ON t.id = c.id;
**UPDATE [RD].[PurchaseOrderHeader] SET [DispatchCycleNumber] = WHERE OrderNumber in(select * FROM XA.fn_SplitOrderIDs(@InvoiceNumberList))** CREATE FUNCTION [XA].[fn_SplitOrderIDs] ( @OrderList varchar(500) ) RETURNS @ParsedList table ( OrderID int ) AS BEGIN DECLARE @OrderID varchar(10), @Pos int SET @OrderList = LTRIM(RTRIM(@OrderList))+ SET @Pos = CHARINDEX( IF REPLACE(@OrderList, BEGIN WHILE @Pos > 0 BEGIN SET @OrderID = LTRIM(RTRIM(LEFT(@OrderList, @Pos - 1))) IF @OrderID <> BEGIN INSERT INTO @ParsedList (OrderID) VALUES (CAST(@OrderID AS int)) --Use Appropriate conversion END SET @OrderList = RIGHT(@OrderList, LEN(@OrderList) - @Pos) SET @Pos = CHARINDEX( END END RETURN END
CREATE PROCEDURE [dbo].[GetAccounts](@accountIds nvarchar) AS BEGIN SELECT * FROM accountsTable WHERE accountId IN (select * from @accountIds) END CREATE TYPE intListTableType AS TABLE (n int NOT NULL) DECLARE @tvp intListTableType -- inserts each id to one row in the tvp table INSERT @tvp(n) VALUES (16509),(16685),(46173),(42925),(46167),(5511) EXEC GetAccounts @tvp
CREATE FUNCTION [dbo].[fn_SplitList] ( @inString varchar(MAX) = @inDelimiter char(1) = ) RETURNS @tbl_Return table ( Unit varchar(1000) COLLATE Latin1_General_BIN ) AS BEGIN INSERT INTO @tbl_Return SELECT DISTINCT LTRIM(RTRIM(piece.value( FROM ( -- -- Replace any delimiters in the string with the "X" tag. -- SELECT CAST(( FROM ( -- -- Convert the string and delimiter into XML. -- SELECT (SELECT @inString FOR XML PATH( (SELECT @inDelimiter FOR XML PATH( ) AS s0 ) AS s1 CROSS APPLY units.nodes( RETURN END
DECLARE @Ids varchar(50); SET @Ids = SELECT * FROM sometable AS st INNER JOIN fn_SplitList(@ids, ON sl.unit = st.tableid
DECLARE @Ids varchar(50); SET @Ids = SELECT * FROM sometable WHERE
IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N DROP PROCEDURE [dbo].[uspSplitTextList] GO SET QUOTED_IDENTIFIER ON GO SET ANSI_NULLS ON GO -- uspSplitTextList -- -- Description: -- splits a separated list of text items and returns the text items -- -- Arguments: -- @list_text - list of text items -- @Delimiter - delimiter -- -- Notes: -- 02/22/2006 - WSR : use DATALENGTH instead of LEN throughout because LEN doesn -- -- History: -- 02/22/2006 - WSR : revised algorithm to account for items crossing 8000 character boundary -- 09/18/2006 - WSR : added to this project -- CREATE PROCEDURE uspSplitTextList @list_text text, @Delimiter varchar(3) AS SET NOCOUNT ON DECLARE @InputLen integer -- input text length DECLARE @TextPos integer -- current position within input text DECLARE @Chunk varchar(8000) -- chunk within input text DECLARE @ChunkPos integer -- current position within chunk DECLARE @DelimPos integer -- position of delimiter DECLARE @ChunkLen integer -- chunk length DECLARE @DelimLen integer -- delimiter length DECLARE @ItemBegPos integer -- item starting position in text DECLARE @ItemOrder integer -- item order in list DECLARE @DelimChar varchar(1) -- first character of delimiter (simple delimiter) -- create table to hold list items -- actually their positions because we may want to scrub this list eliminating bad entries before substring is applied CREATE TABLE -- process list IF @list_text IS NOT NULL BEGIN -- initialize SET @InputLen = DATALENGTH(@list_text) SET @TextPos = 1 SET @DelimChar = SUBSTRING(@Delimiter, 1, 1) SET @DelimLen = DATALENGTH(@Delimiter) SET @ItemBegPos = 1 SET @ItemOrder = 1 SET @ChunkLen = 1 -- cycle through input processing chunks WHILE @TextPos <= @InputLen AND @ChunkLen <> 0 BEGIN -- get current chunk SET @Chunk = SUBSTRING(@list_text, @TextPos, 8000) -- setup initial variable values SET @ChunkPos = 1 SET @ChunkLen = DATALENGTH(@Chunk) SET @DelimPos = CHARINDEX(@DelimChar, @Chunk, @ChunkPos) -- loop over the chunk, until the last delimiter WHILE @ChunkPos <= @ChunkLen AND @DelimPos <> 0 BEGIN -- see if this is a full delimiter IF SUBSTRING(@list_text, (@TextPos + @DelimPos - 1), @DelimLen) = @Delimiter BEGIN -- insert position INSERT INTO VALUES (@ItemOrder, @ItemBegPos, (@TextPos + @DelimPos - 1) - 1) -- adjust positions SET @ItemOrder = @ItemOrder + 1 SET @ItemBegPos = (@TextPos + @DelimPos - 1) + @DelimLen SET @ChunkPos = @DelimPos + @DelimLen END ELSE BEGIN -- adjust positions SET @ChunkPos = @DelimPos + 1 END -- find next delimiter SET @DelimPos = CHARINDEX(@DelimChar, @Chunk, @ChunkPos) END -- adjust positions SET @TextPos = @TextPos + @ChunkLen END -- handle last item IF @ItemBegPos <= @InputLen BEGIN -- insert position INSERT INTO VALUES (@ItemOrder, @ItemBegPos, @InputLen) END -- delete the bad items DELETE FROM WHERE item_endpos < item_begpos -- return list items SELECT SUBSTRING(@list_text, item_begpos, (item_endpos - item_begpos + 1)) AS item_text, item_order, item_begpos, item_endpos FROM ORDER BY item_order END DROP TABLE RETURN GO SET QUOTED_IDENTIFIER OFF GO SET ANSI_NULLS ON GO
-- declare the variables needed DECLARE @xml as xml,@str as varchar(100),@delimiter as varchar(10) -- The string you want to split SET @str= -- What you want to split on. Can be a single character or a string SET @delimiter = -- Convert it to an XML document SET @xml = cast(( -- Select back from the XML SELECT N.value(
CREATE FUNCTION [dbo].[FN_ListToTable] ( @SplitOn char(1) --REQUIRED, the character to split the @List string on ,@List varchar(8000) --REQUIRED, the list to split apart ) RETURNS @ParsedList table ( ListValue varchar(500) ) AS BEGIN DECLARE @number int = 0 DECLARE @childString varchar(502) = DECLARE @lengthChildString int = 0 DECLARE @processString varchar(502) = @SplitOn + @List + @SplitOn WHILE @number < LEN(@processString) BEGIN SET @number = @number + 1 SET @lengthChildString = CHARINDEX(@SplitOn, @processString, @number + 1) - @number - 1 IF @lengthChildString > 0 BEGIN SET @childString = LTRIM(RTRIM(SUBSTRING(@processString, @number + 1, @lengthChildString))) IF @childString IS NOT NULL AND @childString != BEGIN INSERT INTO @ParsedList(ListValue) VALUES (@childString) SET @number = @number + @lengthChildString - 1 END END END RETURN END
-- select * from dbo.Split_ID( ALTER FUNCTION dbo.Split_ID(@String varchar(8000)) returns @temptable TABLE (ID varchar(8000)) as begin declare @idx int declare @slice varchar(8000) declare @Delimiter char(1) set @Delimiter = select @idx = 1 if len(@String)<1 or @String is null return while @idx!= 0 begin set @idx = charindex(@Delimiter,@String) if @idx!=0 set @slice = left(@String,@idx - 1) else set @slice = @String if(len(@slice)>0) insert into @temptable(ID) values(@slice) set @String = right(@String,len(@String) - @idx) if len(@String) = 0 break end return end
create or replace PROCEDURE UDP_SETBOOKMARK ( P_USERID IN VARCHAR2 , P_BOOKMARK IN VARCHAR2 ) AS BEGIN UPDATE T_ER_Bewertung SET LESEZEICHEN = P_BOOKMARK WHERE STAMM_ID in( select regexp_substr(P_USERID, connect by regexp_substr(P_USERID, and ER_ID = (select max(ER_ID) from T_ER_Bewertung_Kopie); commit; END UDP_SETBOOKMARK;
Error 493: The column used directly. It can only be used with one of the four XML data type methods, exist(), nodes(), query(), and value(), or in IS NULL and IS NOT NULL checks.
Declare @Ids varchar(50) Set @Ids = DECLARE @XML XML SET @XML = CAST( SELECT SomeTable.* FROM SomeTable cross apply @XML.nodes( where SomeTable .Id = x.i.value(
CREATE TABLE t ( id INT, col1 VARCHAR(50) ) INSERT INTO t VALUES (1, INSERT INTO t VALUES (2, INSERT INTO t VALUES (3, INSERT INTO t VALUES (4, INSERT INTO t VALUES (5, DECLARE @params VARCHAR(100) SET @params = SELECT * FROM t WHERE Charindex(
DECLARE @AccumulateKeywordCopy NVARCHAR(2000),@IDDupCopy NVARCHAR(50); SET @AccumulateKeywordCopy = SET @IDDupCopy = SET @IDDup = (SELECT CONVERT(VARCHAR(MAX), <columnName>) FROM <tableName> WHERE <clause>) SET @AccumulateKeywordCopy = SET @IDDupCopy = SET @IDDupCheck = CHARINDEX(@IDDupCopy,@AccumulateKeywordCopy)
use master; GO IF EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE name = N BEGIN DROP DATABASE [test]; END GO CREATE DATABASE [test]; GO use [test]; GO
EXEC sp_who2 --Run kill spid for each process that is using the database to be dropped. kill <<processid>> -- Kill 57
use master GO IF EXISTS (SELECT name FROM master.dbo.sysdatabases WHERE name = N DROP DATABASE [test] GO CREATE DATABASE [test] GO use [test] GO
use master; GO ALTER DATABASE test SET SINGLE_USER WITH ROLLBACK IMMEDIATE; GO .....
select spid, hostname, [program_name], open_tran, hostprocess, cmd from master.dbo.sysprocesses where dbid = db_id(
ALTER DATABASE test1 SET SINGLE_USER WITH ROLLBACK IMMEDIATE ALTER DATABASE test1 SET OFFLINE; DROP DATABASE test1
USE [DatabaseName] GO /****** Object: Table [dbo].[Administrateur] Script Date: 10/11/2016 2:06:04 PM ******/ DROP TABLE [dbo].[Administrateur] GO /****** Object: Table [dbo].[Administrateur] Script Date: 10/11/2016 2:06:04 PM ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE TABLE [dbo].[Administrateur]( [AdministrateurID] [int] IDENTITY(1,1) NOT NULL, [Name] [nvarchar](max) NOT NULL, [Surname] [nvarchar](max) NULL, [Phone] [nvarchar](max) NOT NULL, [Username] [nvarchar](max) NOT NULL, [Password] [nvarchar](max) NOT NULL, [Sexe] [nvarchar](max) NOT NULL, CONSTRAINT [PK_Administrateur] PRIMARY KEY CLUSTERED ( [AdministrateurID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY] GO
USE [DatabaseName] GO /****** Object: Table [dbo].[Administrateur] Script Date: 10/11/2016 2:06:04 PM ******/ DROP TABLE [dbo].[Administrateur] GO /****** Object: Table [dbo].[Administrateur] Script Date: 10/11/2016 2:06:04 PM ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE TABLE [dbo].[Administrateur]( [AdministrateurID] [int] IDENTITY(1,1) NOT NULL, [Name] [nvarchar](max) NOT NULL, [Surname] [nvarchar](max) NULL, [Phone] [nvarchar](max) NOT NULL, [Email] [nvarchar](max) NOT NULL, [Username] [nvarchar](max) NOT NULL, [Password] [nvarchar](max) NOT NULL, [Image] [nvarchar](max) NOT NULL, [Sexe] [nvarchar](max) NOT NULL, [Salt] [nvarchar](max) NOT NULL, CONSTRAINT [PK_Administrateur] PRIMARY KEY CLUSTERED ( [AdministrateurID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY] GO
DECLARE @databaseName VARCHAR(30); DECLARE @resource_type_to_kill VARCHAR(30); DECLARE @processIdToKill INT; SET @databaseName = SET @resource_type_to_kill = DECLARE @TempSession TABLE ( ProcessIdToKill INT, DatabaseName VARCHAR(100), Request_Mode VARCHAR(100), HostName VARCHAR(100), LoginTime VARCHAR(100), LoginName VARCHAR(100), Status VARCHAR(100), Reads VARCHAR(100), Writes VARCHAR(100) ); INSERT @TempSession SELECT DISTINCT session_id, name, request_mode, host_name, login_time, login_name, status, reads, writes FROM sys.dm_exec_sessions LEFT OUTER JOIN sys.dm_tran_locks ON sys.dm_exec_sessions.session_id = sys.dm_tran_locks.request_session_id INNER JOIN sys.databases ON sys.dm_tran_locks.resource_database_id = sys.databases.database_id WHERE resource_type = @resource_type_to_kill AND name = @databaseName ORDER BY name --SELECT * FROM @TempSession --Debugging SELECT @processIdToKill = ProcessIdToKill FROM @TempSession --SELECT @processIdToKill --Debugging --Run kill for the process that is using the database to be dropped. DECLARE @SQL nvarchar(1000) SET @SQL = PRINT EXEC (@SQL) --And then drop the database DECLARE @DropSQL nvarchar(1000) SET @DropSQL = PRINT EXEC (@DropSQL)
UPDATE TOP (10) messages SET status=10 WHERE status=0 ORDER BY priority DESC;
UPDATE messages SET status=10 WHERE ID in (SELECT TOP (10) Id FROM Table WHERE status=0 ORDER BY priority DESC);
WITH q AS ( SELECT TOP 10 * FROM messages WHERE status = 0 ORDER BY priority DESC ) UPDATE q SET status = 10
UPDATE m SET [status]=10 FROM ( Select TOP (10) * FROM messages WHERE [status]=0 ORDER BY [priority] DESC ) m
UPDATE messages SET status=10 WHERE ID in (SELECT TOP (10) Id FROM Table WHERE status=0 ORDER BY priority DESC);
SET ROWCOUNT 10 UPDATE messages SET status = 10 WHERE status = 0 SET ROWCOUNT 0
DECLARE @t TABLE (id INT) INSERT @t (id) SELECT TOP 10 id FROM messages WHERE status = 0 ORDER BY priority DESC UPDATE messages SET status = 10 WHERE id IN (SELECT id FROM @t)
ID MyText 1 some text; some more text 2 text again; even more text
UPDATE MyTable SET MyText = LEFT(MyText, CHARINDEX( WHERE CHARINDEX(
declare @MyTable table ([id] int primary key clustered, MyText varchar(100)) insert into @MyTable ([id], MyText) select 1, union all select 2, union all select 3, union all select 4, null -- test NULLs union all select 5, union all select 6, union all select 7, UPDATE @MyTable SET MyText = LEFT(MyText, CHARINDEX( WHERE CHARINDEX( select * from @MyTable
id MyText -- ------------------------- 1 some text 2 text again 3 text without a semicolon 4 NULL 5 (empty string) 6 test 3 semicolons 7 (empty string)
SELECT CASE WHEN CHARINDEX( LEFT(MyText, CHARINDEX( MyText END FROM MyTable
UPDATE MyTable SET MyText = SUBSTRING(MyText, 1, CHARINDEX( WHERE CHARINDEX(
SELECT [dbo].[RegexReplace] ([MyColumn], FROM [dbo].[MyTable]
using System; using System.IO; using System.Data.SqlTypes; using System.Text.RegularExpressions; using Microsoft.SqlServer.Server; public sealed class RegularExpression { public static string Replace(SqlString sqlInput, SqlString sqlPattern, SqlString sqlReplacement) { string input = (sqlInput.IsNull) ? string.Empty : sqlInput.Value; string pattern = (sqlPattern.IsNull) ? string.Empty : sqlPattern.Value; string replacement = (sqlReplacement.IsNull) ? string.Empty : sqlReplacement.Value; return Regex.Replace(input, pattern, replacement); } }
IF OBJECT_ID(N DROP Function RegexReplace; GO IF EXISTS (SELECT * FROM sys.assemblies WHERE [name] = DROP ASSEMBLY StringUtils; GO DECLARE @SamplePath nvarchar(1024) -- You will need to modify the value of the this variable if you have installed the sample someplace other than the default location. Set @SamplePath = CREATE ASSEMBLY [StringUtils] FROM @SamplePath + WITH permission_set = Safe; GO CREATE FUNCTION [RegexReplace] (@input nvarchar(max), @pattern nvarchar(max), @replacement nvarchar(max)) RETURNS nvarchar(max) AS EXTERNAL NAME [StringUtils].[RegularExpression].[Replace] GO
declare @MyTable table ([id] int primary key clustered, MyText varchar(100)) insert into @MyTable ([id], MyText) select 1, union all select 2, union all select 3, union all select 4, null -- test NULLs union all select 5, union all select 6, union all select 7, SELECT [dbo].[RegexReplace] ([MyText], FROM @MyTable select * from @MyTable
IF EXISTS (SELECT * FROM Table WHERE FieldValue= SELECT TableID FROM Table WHERE FieldValue= ELSE INSERT INTO TABLE(FieldValue) VALUES( SELECT TableID FROM Table WHERE TableID=SCOPE_IDENTITY() END IF
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE BEGIN TRANSACTION DECLARE @id AS INT SELECT @id = tableId FROM table WHERE fieldValue=@newValue IF @id IS NULL BEGIN INSERT INTO table (fieldValue) VALUES (@newValue) SELECT @id = SCOPE_IDENTITY() END SELECT @id COMMIT TRANSACTION
DECLARE @id AS INT SELECT @id = tableID FROM table (NOLOCK) WHERE fieldValue=@newValue IF @id IS NULL BEGIN SET TRANSACTION ISOLATION LEVEL SERIALIZABLE BEGIN TRANSACTION SELECT @id = tableID FROM table WHERE fieldValue=@newValue IF @id IS NULL BEGIN INSERT INTO table (fieldValue) VALUES (@newValue) SELECT @id = SCOPE_IDENTITY() END COMMIT TRANSACTION END SELECT @id
IF EXISTS (SELECT 1 FROM Table WHERE FieldValue= BEGIN SELECT TableID FROM Table WHERE FieldValue= END ELSE BEGIN INSERT INTO TABLE(FieldValue) VALUES( SELECT SCOPE_IDENTITY() AS TableID END
IF EXISTS (SELECT * FROM Table WHERE FieldValue= SELECT TableID FROM Table WHERE FieldValue= ELSE BEGIN INSERT INTO TABLE (FieldValue) VALUES ( SELECT TableID FROM Table WHERE TableID=SCOPE_IDENTITY() END
if exists(select * from Table where FieldValue= select TableID from Table where FieldValue= end else begin insert into Table (FieldValue) values ( select TableID from Table where TableID = scope_identity() end
if not exists(select * from Table where FieldValue= insert into Table (FieldValue) values ( end select TableID from Table where FieldValue=
if exists(select * from Table where FieldValue= select TableID from Table where FieldValue= end else begin insert into Table (FieldValue) values ( select scope_identity() as TableID end
DECLARE @t1 TABLE ( TableID int IDENTITY, FieldValue varchar(20) ) --<< No empty string IF EXISTS ( SELECT * FROM @t1 WHERE FieldValue = ) BEGIN SELECT TableID FROM @t1 WHERE FieldValue= END ELSE BEGIN INSERT INTO @t1 (FieldValue) VALUES ( SELECT SCOPE_IDENTITY() AS TableID END --<< A record with an empty string already exists IF EXISTS ( SELECT * FROM @t1 WHERE FieldValue = ) BEGIN SELECT TableID FROM @t1 WHERE FieldValue= END ELSE BEGIN INSERT INTO @t1 (FieldValue) VALUES ( SELECT SCOPE_IDENTITY() AS TableID END
create schema tableName authorization dbo go IF OBJECT_ID ( drop proc tableName.put_fieldValue go create proc tableName.put_fieldValue(@fieldValue int) as declare @tableid int = 0 select @tableid = tableid from table where fieldValue= if @tableid = 0 begin insert into table(fieldValue) values( select @tableid = scope_identity() end return @tableid go declare @tablid int = 0 exec @tableid = tableName.put_fieldValue(
ID INT NOT NULL IDENTITY(1,1) RecordID INT NOT NULL StartDate DATE NOT NULL EndDate DATE NULL
SELECT recordid, MIN(startdate), MAX(enddate) FROM tmp GROUP BY recordid
RecordId Start End 1 2009-06-19 NULL 2 2012-05-06 NULL 3 2013-01-25 NULL 4 2004-05-06 2009-12-01
SELECT recordid, MIN(startdate), CASE WHEN MAX(CASE WHEN enddate IS NULL THEN 1 ELSE 0 END) = 0 THEN MAX(enddate) END FROM tmp GROUP BY recordid
SELECT RecordId, MIN(StartDate), NULLIF(MAX(COALESCE(EndDate, FROM tmp GROUP BY RecordId
SELECT recordid, MIN(startdate), case when count(enddate) = count(*) then max(enddate) end FROM tmp GROUP BY recordid
SELECT recordid, MIN(startdate), MAX(IsNull(enddate, Getdate())) FROM tmp GROUP BY recordid
WITH cte1 AS ( SELECT recordid, MIN(startdate) as min_start , MAX(enddate) as max_end FROM tmp GROUP BY recordid ) SELECT a.recordid, a.min_start , CASE WHEN b.recordid IS NULL THEN a.max_end END as max_end FROM cte1 a LEFT JOIN tmp b ON (b.recordid = a.recordid AND b.enddate IS NULL)
select case when max(field) keep (dense_rank first order by datfin desc nulls first) is null then 1 else 0 end as flag from MYTABLE;
SELECT CASE WHEN COUNT(*)>0 THEN ( SELECT [Some Column], COUNT(*) TotalCount FROM INCIDENTS WHERE [Some Column] = GROUP BY [Some Column] )
IF EXISTS (SELECT * FROM TABLE WHERE COLUMN = --INSERT SOMETHING ELSE --INSERT SOMETHING ELSE
DECLARE @retVal int SELECT @retVal = COUNT(*) FROM TABLE WHERE COLUMN = IF (@retVal > 0) BEGIN --INSERT SOMETHING END ELSE BEGIN --INSERT SOMETHING ELSE END
IF EXISTS (SELECT 1 FROM INCIDENTS WHERE [Some Column] = BEGIN -- TRUE Procedure END ELSE BEGIN -- FALSE Procedure END
IF exists (select * from table_1 where col1 = BEGIN -- one or more insert into table_1 (col1) values ( END ELSE -- zero insert into table_1 (col1) values (
select case when totalCount >= 0 and totalCount < 11 then when tatalCount > 10 and totalCount < 101 then else from ( SELECT [Some Column], COUNT(*) TotalCount FROM INCIDENTS WHERE [Some Column] = GROUP BY [Some Column] ) A
-- Let -- in our if stmt DECLARE @HasExistingRows int -- I SELECT @HasExistingRows = Count(*) ELSE 0 -- false FROM INCIDENTS WHERE {Your Criteria} GROUP BY {Required Grouping}
-- IF / Else / Begin / END Syntax IF @HasExistingRows = 0 -- No Existing Rows BEGIN {Insert Logic for No Existing Rows} END ELSE -- existing rows are found BEGIN {Insert logic for existing rows} END
IF EXISTS ({SELECT Query}) BEGIN {INSERT Version 1} END ELSE BEGIN {INSERT version 2} END
SELECT CASE WHEN TotalCount >0 THEN ( SELECT [Some Column], COUNT(*) TotalCount FROM INCIDENTS WHERE [Some Column] = GROUP BY [Some Column] ) DerivedTable
DECLARE @TotalCount int SELECT @TotalCount = TotalCount FROM ( SELECT [Some Column], COUNT(*) TotalCount FROM INCIDENTS WHERE [Some Column] = GROUP BY [Some Column] ) DerivedTable IF @TotalCount > 0 -- INSERT STATEMENT 1 GOES HERE ELSE -- INSERT STATEMENT 2 GOES HERE
select MyColumn from MyTable order by case IsNumeric(MyColumn) when 1 then Replicate( else MyColumn end
SELECT ... ORDER BY CASE WHEN ISNUMERIC(value) = 1 THEN CONVERT(INT, value) ELSE 9999999 -- or something huge END, value
select Field1, Field2... from Table1 order by isnumeric(Field1) desc, case when isnumeric(Field1) = 1 then cast(Field1 as int) else null end, Field1
SELECT *, CONVERT(int, your_column) AS your_column_int FROM your_table ORDER BY your_column_int
SELECT *, CAST(your_column AS int) AS your_column_int FROM your_table ORDER BY your_column_int
16079 Customer X 016082 Customer Y 16413 Customer Z
SELECT * FROM Table ORDER BY ISNUMERIC([yourvarchar] + , LEN([yourvarchar]) ASC
SELECT * FROM Table ORDER BY ISNUMERIC([yourvarchar] + , RIGHT(
SELECT * FROM Table ORDER BY ISNUMERIC([yourvarchar] + , CASE WHEN ISNUMERIC([yourvarchar] + THEN RIGHT( ELSE LTRIM(RTRIM([yourvarchar])) END ASC
select your_column from your_table order by case when isnumeric(your_column) = 1 then your_column else 999999999 end, your_column
SELECT FIELD FROM TABLE ORDER BY isnumeric(FIELD) desc, CASE ISNUMERIC(test) WHEN 1 THEN CAST(CAST(test AS MONEY) AS INT) ELSE NULL END, FIELD
SELECT *, (CASE WHEN ISNUMERIC(column_name) = 1 THEN 0 ELSE 1 END) IsNum FROM table_name ORDER BY IsNum, LEN(column_name), column_name;
SELECT *, ROW_NUMBER()OVER(ORDER BY CASE WHEN ISNUMERIC (ID)=1 THEN CONVERT(NUMERIC(20,2),SUBSTRING(Id, PATINDEX( FROM ( SELECT SELECT SELECT SELECT SELECT SELECT SELECT SELECT SELECT SELECT )A ORDER BY CASE WHEN ISNUMERIC (ID)=0 THEN CASE WHEN PATINDEX( THEN LEFT(Id,PATINDEX( ELSE LEFT(Id,PATINDEX( END END DESC
select TABLE_NAME from tempdb.information_schema.tables
declare @id varchar(40) select @id = select * from authors where au_id <> @id select * from authors where au_id != @id select * from authors where not (au_id = @id)
DECLARE @t table (a1 bit, a2 bit, b1 bit, b2 bit) Insert into @t (a1 , a2, b1, b2) values( 0 , 0 , 0 , NULL ) select a1,a2,b1,b2, case when ( (a1=a2 or (a1 is null and a2 is null)) and (b1=b2 or (b1 is null and b2 is null)) ) then end, case when not ( (a1=a2 or (a1 is null and a2 is null)) and (b1=b2 or (b1 is null and b2 is null)) ) then end, case when ( (a1<>a2 or (a1 is null and a2 is not null) or (a1 is not null and a2 is null)) or (b1<>b2 or (b1 is null and b2 is not null) or (b1 is not null and b2 is null)) ) then end from @t
ALTER TABLE dbo.foo ADD CONSTRAINT UQ_bar UNIQUE(bar);
CREATE UNIQUE NONCLUSTERED INDEX IX_UQ_Bar ON dbo.foo ( bar ) INCLUDE (foo_other_column) GO SELECT foo_other_column FROM Foo WHERE bar =
SELECT TABLE_NAME, CONSTRAINT_NAME, COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE;
create table dbo.t (id int constraint my_unique_constraint unique (id)); select [Constraint]=name from sys.key_constraints where parent_object_id = object_id( select name, index_id, type_desc from sys.indexes where object_id = object_id( and index_id > 0;
create table dbo.t2 (id int ); create unique index my_unique_constraint on dbo.t2 (id); select [Constraint]=name from sys.key_constraints where parent_object_id = object_id( select name, index_id, type_desc from sys.indexes where object_id = object_id( and index_id > 0
select * from calls left join users a on calls.assigned_to= a.user_id where a.dept = 4 union select * from calls left join users r on calls.requestor_id= r.user_id where r.dept = 4
select * from calls c join users u on c.assigned_to = u.user_id or c.requestor_id = u.user_id where u.dept = 4
SELECT DISTINCT * FROM ( select * from calls left join users a on calls.assigned_to= a.user_id where a.dept = 4 union select * from calls left join users r on calls.requestor_id= r.user_id where r.dept = 4 )a
;WITH CTE_DocTotal AS ( SELECT SUM(Sale + VAT) AS DocTotal FROM PEDI_InvoiceDetail GROUP BY InvoiceNumber ) UPDATE PEDI_InvoiceDetail SET DocTotal = CTE_DocTotal.DocTotal
;WITH T AS ( SELECT InvoiceNumber, DocTotal, SUM(Sale + VAT) OVER(PARTITION BY InvoiceNumber) AS NewDocTotal FROM PEDI_InvoiceDetail ) UPDATE T SET DocTotal = NewDocTotal
WITH CTE_DocTotal (DocTotal, InvoiceNumber) AS ( SELECT InvoiceNumber, SUM(Sale + VAT) AS DocTotal FROM PEDI_InvoiceDetail GROUP BY InvoiceNumber ) UPDATE PEDI_InvoiceDetail SET PEDI_InvoiceDetail.DocTotal = CTE_DocTotal.DocTotal FROM CTE_DocTotal INNER JOIN PEDI_InvoiceDetail ON ...
UPDATE PEDI_InvoiceDetail SET DocTotal = v.DocTotal FROM PEDI_InvoiceDetail inner join ( SELECT InvoiceNumber, SUM(Sale + VAT) AS DocTotal FROM PEDI_InvoiceDetail GROUP BY InvoiceNumber ) v ON PEDI_InvoiceDetail.InvoiceNumber = v.InvoiceNumber
;WITH CTE_DocTotal AS ( SELECT SUM(Sale + VAT) AS DocTotal_1 FROM PEDI_InvoiceDetail GROUP BY InvoiceNumber ) UPDATE CTE_DocTotal SET DocTotal = CTE_DocTotal.DocTotal_1
DECLARE @day CHAR(2) SET @day = DATEPART(DAY, GETDATE()) PRINT @day
SELECT CONVERT(varchar(2), GETDATE(), 101) AS monthLeadingZero -- Date Style 101 = mm/dd/yyyy ,CONVERT(varchar(2), GETDATE(), 103) AS dayLeadingZero -- Date Style 103 = dd/mm/yyyy
SELECT RIGHT( + CONVERT(VARCHAR(2), Month( column_name )), 2) FROM table
DECLARE @dbName nvarchar(128) = DECLARE @siteId int exec ( select @siteId
Msg 137, Level 15, State 1, Line 1 Must declare the scalar variable "@siteId". (1 row(s) affected)
DECLARE @dbName nvarchar(128) = DECLARE @siteId int DECLARE @SQL nvarchar(max) = N exec sp_executesql @SQL, N select @siteId
DECLARE @dbName nvarchar(128) = DECLARE @siteId TABLE (siteid int) INSERT @siteId exec ( select * FROM @siteId
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO -- ============================================= -- Author: Andrew Foster -- Create date: 28 Mar 2013 -- Description: Allows the dynamic pull of any column value up to 255 chars from regUsers table -- ============================================= ALTER PROCEDURE dbo.PullTableColumn ( @columnName varchar(255), @id int ) AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; DECLARE @columnVal TABLE (columnVal nvarchar(255)); DECLARE @sql nvarchar(max); SET @sql = INSERT @columnVal EXEC sp_executesql @sql; SELECT * FROM @columnVal; END GO
select table_name, column_name, collation_name from INFORMATION_SCHEMA.COLUMNS where table_name = @table_name
CREATE TABLE mytable ( mycolumn VARCHAR(10) ) GO SET NOCOUNT ON INSERT mytable VALUES( GO SELECT mycolumn FROM mytable WHERE mycolumn= SELECT mycolumn FROM mytable WHERE mycolumn= SELECT mycolumn FROM mytable WHERE mycolumn=
SELECT myColumn FROM myTable WHERE myColumn COLLATE Latin1_General_CS_AS = SELECT myColumn FROM myTable WHERE myColumn COLLATE Latin1_General_CS_AS = SELECT myColumn FROM myTable WHERE myColumn COLLATE Latin1_General_CS_AS = -- if myColumn has an index, you will likely benefit by adding -- AND myColumn = SELECT DATABASEPROPERTYEX(
ALTER TABLE mytable ALTER COLUMN mycolumn VARCHAR(10) COLLATE Latin1_General_CS_AS GO SELECT mycolumn FROM mytable WHERE mycolumn= SELECT mycolumn FROM mytable WHERE mycolumn= SELECT mycolumn FROM mytable WHERE mycolumn=
ALTER TABLE mytable ALTER COLUMN mycolumn VARCHAR(10) COLLATE SQL_Latin1_General_CP1_CI_AS
SELECT mycolumn FROM mytable WHERE mycolumn = CAST(mycolumn AS VARBINARY(10)) = CAST( SELECT mycolumn FROM mytable WHERE mycolumn = CAST(mycolumn AS VARBINARY(10)) = CAST( SELECT mycolumn FROM mytable WHERE mycolumn = CAST(mycolumn AS VARBINARY(10)) = CAST( -- if myColumn has an index, you will likely benefit by adding -- AND myColumn =
select table_name, column_name, collation_name from INFORMATION_SCHEMA.COLUMNS where table_name = @table_name
SELECT name FROM customer ORDER BY name COLLATE Latin1_General_CS_AI;
SELECT myColumn FROM myTable WHERE myColumn COLLATE SQL_Latin1_General_CP1_CI_AS =
;WITH collations AS ( SELECT name, CASE WHEN description like WHEN description like END isCaseSensitive FROM sys.fn_helpcollations() ) SELECT * FROM collations WHERE name = CONVERT(varchar, DATABASEPROPERTYEX(
WHERE 5 > ANY (SELECT foo) AND NOT (5 > ALL (SELECT foo))
A xor B = (not A and B) or (A and not B) A B | f = notA and B | g = A and notB | f or g | A xor B ----+----------------+----------------+--------+-------- 0 0 | 0 | 0 | 0 | 0 0 1 | 1 | 0 | 1 | 1 1 0 | 0 | 1 | 1 | 1 1 1 | 0 | 0 | 0 | 0
WHERE (Note is null and ID is not null) OR (Note is not null and ID is null)
where (case when Note is null then 1 else 0 end) <>(case when ID is null then 1 else 0 end)
select name, compatibility_level , version_name = CASE compatibility_level WHEN 65 THEN WHEN 70 THEN WHEN 80 THEN WHEN 90 THEN WHEN 100 THEN WHEN 110 THEN WHEN 120 THEN WHEN 130 THEN WHEN 140 THEN ELSE END from sys.databases
select compatibility_level from sys.databases where name =
65 = SQL Server 6.5 70 = SQL Server 7.0 80 = SQL Server 2000 90 = SQL Server 2005 100 = SQL Server 2008/R2 110 = SQL Server 2012 120 = SQL Server 2014 130 = SQL Server 2016
USE AdventureWorks2012; GO SELECT compatibility_level FROM sys.databases WHERE name = GO
IF NOT EXISTS(SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = BEGIN ALTER TABLE [dbo].[PurchaseOrder] ADD [IsDownloadable] bit NOT NULL DEFAULT 0 UPDATE [dbo].[PurchaseOrder] SET [IsDownloadable] = 1 WHERE [Ref] IS NOT NULL END
IF NOT EXISTS(SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = BEGIN ALTER TABLE [dbo].[PurchaseOrder] ADD [IsDownloadable] bit NOT NULL DEFAULT 0 EXEC sp_executesql N END
IF(COL_LENGTH( BEGIN ALTER TABLE MyTable ADD NewCol VARCHAR(16) NULL; CREATE SYNONYM hack FOR MyTable; UPDATE hack SET NewCol = DROP SYNONYM hack; ALTER TABLE MyTable ALTER COLUMN NewCol VARCHAR(16) NOT NULL; END
-- Create a tempTable if it doesn IF OBJECT_ID( CREATE TABLE -- Create your new column if it doesn IF NOT EXISTS ( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = BEGIN INSERT INTO ALTER TABLE .dbo.targetTable ADD newColumn [SMALLINT] NULL ; END GO -- If the tempTable was inserted into, our new columns were created. IF (EXISTS(SELECT * FROM BEGIN -- Do some data seeding or whatever END -- Clean up - delete the tempTable. IF OBJECT_ID(
declare @doUpdate bit; SELECT @doUpdate = 0; IF NOT EXISTS(SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = BEGIN SELECT @doUpdate=1 END IF @doUpdate<>0 ALTER TABLE [dbo].[PurchaseOrder] ADD [IsDownloadable] bit NOT NULL DEFAULT 0 IF @doUpdate<>0 UPDATE [dbo].[PurchaseOrder] SET [IsDownloadable] = 1 WHERE [Ref]=0 COMMIT TRAN
delete from mytable where datefield = select @@ROWCOUNT
delete from mytable where datefield = output datefield into select count(*) from
delete from mytable where datefield = output deleted.datefield into select count(distinct datefield) from
DECLARE @a VARCHAR(10) = NULL , @b VARCHAR(10) = SELECT CASE WHEN ( ( @a IS NULL AND @b IS NULL ) OR @a = @b ) THEN 1 ELSE 0 END , -- Returns 0 CASE WHEN NOT ( ( @a IS NULL AND @b IS NULL ) OR @a = @b ) THEN 1 ELSE 0 END -- Also returns 0
case when (...) then 1 else 0 end, case when (...) then 0 else 1 end
| T | U | F T | T | T | T U | T | U | U F | T | U | F
SELECT * FROM <Table> WHERE <Column> = null -- 0 rows SELECT * FROM <Table> WHERE NOT (<Column> = null) -- Still 0 rows
DECLARE @a VARCHAR(10) = NULL , @b VARCHAR(10) = SELECT CASE WHEN ( ( @a IS NULL AND @b IS NULL ) OR @a = @b ) THEN 1 ELSE 0 END , -- returns 0 CASE WHEN NOT ( ( @a IS NULL AND @b IS NULL ) OR ISNULL(@a,-1) = ISNULL(@b,-1) ) THEN 1 ELSE 0 END -- also returns 0
DECLARE @a VARCHAR(10) = @b VARCHAR(10) = null SELECT CASE WHEN (@a IS NOT null AND @b IS null) THEN 0 WHEN (@a IS null AND @b IS NOT null) THEN 0 WHEN (@a IS null AND @b IS null) THEN 1 WHEN (@a=@b) THEN 1 ELSE 0 END
DECLARE @combinations TABLE ( a VARCHAR(10),b VARCHAR(10) ) INSERT INTO @combinations SELECT UNION SELECT null, UNION SELECT UNION SELECT null, null UNION SELECT SELECT a, b, CASE WHEN (a IS NOT null AND b IS null) THEN 0 WHEN (a IS null AND b IS NOT null) THEN 0 WHEN (a IS null AND b IS null) THEN 1 WHEN (a=b) THEN 1 ELSE 0 END as result from @combinations order by result
USE AdventureWorks2008R2; GO BEGIN TRANSACTION; GO IF @@TRANCOUNT = 0 BEGIN SELECT FirstName, MiddleName FROM Person.Person WHERE LastName = ROLLBACK TRANSACTION; PRINT N END; ROLLBACK TRANSACTION; PRINT N GO
SET NOCOUNT ON; USE TSQLFundamentals2008; IF OBJECT_ID( CREATE TABLE dbo.Nums(n INT NOT NULL PRIMARY KEY); DECLARE @i AS INT = 1; BEGIN TRAN WHILE @i <= 100000 BEGIN INSERT INTO dbo.Nums VALUES(@i); SET @i = @i + 1; END COMMIT TRAN SET NOCOUNT OFF;
IF @HasWidget = 0x1 BEGIN; SELECT WidgetID FROM tbWidgets; END;
BEGIN { TRAN | TRANSACTION } [ { transaction_name | @tran_name_variable } [ WITH MARK [ ] [ ; ]
BEGIN TRAN T1; UPDATE table1 ...; BEGIN TRAN M2 WITH MARK; UPDATE table2 ...; SELECT * from table1; COMMIT TRAN M2; UPDATE table3 ...; COMMIT TRAN T1;
IF @@TRANCOUNT = 0 BEGIN SELECT FirstName, MiddleName FROM Person.Person WHERE LastName = ROLLBACK TRANSACTION; PRINT N END;
IF Boolean_expression { sql_statement | statement_block } [ ELSE { sql_statement | statement_block } ]
DECLARE @compareprice money, @cost money EXECUTE Production.uspGetList @compareprice OUT, @cost OUTPUT IF @cost <= @compareprice BEGIN PRINT $ END ELSE PRINT $
IF Boolean_expression { sql_statement | statement_block } [ ELSE { sql_statement | statement_block } ]
DECLARE @foo int; IF @foo IS NULL BEGIN WITH Blah AS ( SELECT ) SELECT a FROM Blah; END
DECLARE @foo int; IF @foo IS NULL BEGIN WITH Blah AS ( SELECT ) SELECT a FROM Blah; END WITH Blah2 AS ( SELECT ) SELECT a FROM Blah2;
BEGIN TRY { sql_statement | statement_block } END TRY BEGIN CATCH [ { sql_statement | statement_block } ] END CATCH [ ; ]
BEGIN TRY WITH Blah AS ( SELECT ) SELECT a FROM Blah; END TRY BEGIN CATCH END CATCH
BEGIN TRY; WITH Blah AS ( SELECT ) SELECT a FROM Blah; END TRY BEGIN CATCH END CATCH
BEGIN TRY BEGIN WITH Blah AS ( SELECT ) SELECT a FROM Blah; END END TRY BEGIN CATCH END CATCH
BEGIN TRY BEGIN WITH Blah AS ( SELECT ) SELECT a FROM Blah; END WITH Blah2 AS ( SELECT ) SELECT b FROM Blah2; END TRY BEGIN CATCH END CATCH
SELECT SUBSTRING(CONVERT(nvarchar(6),getdate(), 112),5,2)
SELECT CONVERT(char(2), cast( SELECT CONVERT(char(6), cast(
select case when DATEPART(month, getdate()) between 1 and 9 then
CREATE TABLE `new_table` LIKE `table`; RENAME TABLE `table` TO `old_table`, `new_table` TO `table`;
SELECT DbVendor_SuperFastDeleteAllFunction(tablename, BOZO_BIT) FROM dummy;
Update TableName set ColumntoUpdate=cast(replace(Columnofdirtydata, where Columnofdirtydata like And ColumntoUpdate is Null
DECLARE @textval NVARCHAR(30) SET @textval = SELECT LEFT(SUBSTRING(@textval, PATINDEX( PATINDEX(
declare @table table (DirtyCol varchar(100)) insert into @table values ( ,( ,( ,( ,( ,( ,( ;with tally as (select top (100) N=row_number() over (order by @@spid) from sys.all_columns), data as ( select DirtyCol, Col from @table cross apply ( select (select C + from (select N, substring(DirtyCol, N, 1) C from tally where N<=datalength(DirtyCol)) [1] where C between order by N for xml path( ) p (Col) where p.Col is not NULL ) select DirtyCol, cast(Col as int) IntCol from data
DirtyCol IntCol --------------------- ------- AB ABCDE ABCDE AB: ABC AB AB AB
;with num as (...), data as ( select ColToUpdate, Col from ... ) update data set ColToUpdate = cast(Col as int)
CREATE FUNCTION [dbo].[StripNonNumerics] ( @Temp varchar(255) ) RETURNS varchar(255) AS Begin Declare @KeepValues as varchar(50) Set @KeepValues = While PatIndex(@KeepValues, @Temp) > 0 Set @Temp = Stuff(@Temp, PatIndex(@KeepValues, @Temp), 1, Return @Temp End
SELECT Something, dbo.StripNonNumerics(Something) FROM TableA
--Handles parentheses, commas, spaces, hyphens.. declare @table table (c varchar(256)) insert into @table values ( ( ( ( ( select replace(LEFT(SUBSTRING(replace(replace(replace(replace(replace(c, PATINDEX( from @table
Declare @MainTable table(id int identity(1,1),TextField varchar(100)) INSERT INTO @MainTable (TextField) VALUES ( declare @i int=1 Declare @originalWord varchar(100)= WHile @i<=(Select count(*) from @MainTable) BEGIN Select @originalWord=TextField from @MainTable where id=@i Declare @r varchar(max) = Select @len = len(@originalWord) declare @pn varchar(100)=@originalWord while @x <= @len begin Select @c = SUBSTRING(@pn,@x,1) if(@c!= BEGIN if ISNUMERIC(@c) = 0 and @c <> BEGIN Select @r = cast(@r as varchar) + cast(replace((SELECT ASCII(@c)-64), end ELSE BEGIN Select @r = @r + @c END END Select @x = @x +1 END Select @r Set @i=@i+1 END
declare @table table (id bigint not null identity (1,1), data nvarchar(max)) insert @table (data) values ( ,( ,( ,( ,( ; with NonNumerics as ( select id , data original --the below line replaces all digits with blanks , replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(data, from @table ) --each iteration of the below CTE removes another non-numeric character from the original string, putting the result into the numerics column , Numerics as ( select id , replace(original, substring(nonNumeric,1,1), , replace(nonNumeric, substring(nonNumeric,1,1), , len(replace(nonNumeric, substring(nonNumeric,1,1), from NonNumerics union all select id , replace(numerics, substring(charsToreplace,1,1), , replace(charsToreplace, substring(charsToreplace,1,1), , len(replace(charsToreplace, substring(charsToreplace,1,1), from Numerics where charsRemaining > 0 ) --we select only those strings with `charsRemaining=0`; i.e. the rows for which all non-numeric characters have been removed; there should be 1 row returned for every 1 row in the original data set. select * from Numerics where charsRemaining = 0
Create FUNCTION RemoveCharacters (@text varchar(30)) RETURNS VARCHAR(30) AS BEGIN declare @index as int declare @newtexval as varchar(30) set @index = (select PATINDEX( if (@index =0) begin return @text end else begin set @newtexval = (select STUFF ( @text , @index , 1 , return dbo.RemoveCharacters(@newtexval) end return 0 END GO
DECLARE @t TABLE (tVal VARCHAR(100)) INSERT INTO @t VALUES( INSERT INTO @t VALUES( INSERT INTO @t VALUES( INSERT INTO @t VALUES( ;WITH cte (original, tVal, n) AS ( SELECT t.tVal AS original, LOWER(t.tVal) AS tVal, 65 AS n FROM @t AS t UNION ALL SELECT tVal AS original, CAST(REPLACE(LOWER(tVal), LOWER(CHAR(n)), n + 1 FROM cte WHERE n <= 90 ) SELECT t1.tVal AS OldVal, t.tval AS NewVal FROM ( SELECT original, tVal, ROW_NUMBER() OVER(PARTITION BY tVal + original ORDER BY original) AS Sl FROM cte WHERE PATINDEX( ) t INNER JOIN @t t1 ON t.original = t1.tVal WHERE t.sl = 1
DECLARE @ExampleData AS TABLE (Col VARCHAR(100)) INSERT INTO @ExampleData (Col) VALUES ( DECLARE @Digits AS TABLE (D CHAR(1)) INSERT INTO @Digits (D) VALUES ( ;WITH cteTally AS ( SELECT I = ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM @Digits d10 CROSS APPLY @Digits d100 --add more cross applies to cover longer fields this handles 100 ) SELECT * FROM @ExampleData e OUTER APPLY ( SELECT CleansedPhone = CAST(( SELECT TOP 100 SUBSTRING(e.Col,t.I,1) FROM cteTally t INNER JOIN @Digits d ON SUBSTRING(e.Col,t.I,1) = d.D WHERE I <= LEN(e.Col) ORDER BY t.I FOR XML PATH(
Create function fn_GetNumbersOnly(@pn varchar(100)) Returns varchar(max) AS BEGIN Declare @r varchar(max) = Select @len = len(@pn) while @x <= @len begin Select @c = SUBSTRING(@pn,@x,1) if ISNUMERIC(@c) = 1 and @c <> Select @r = @r + @c Select @x = @x +1 end return @r End
SELECT ProductID, VendorID, ProductName= MAX(ProductName), VendorName = MAX(VendorName), IsActive = MAX(IsActive) FROM ProductVendorAssoc GROUP BY ProductID, VendorID
IsActive = MAX(CASE WHEN IsActive=1 THEN 1 ELSE 0 END)
;With Numbered as ( SELECT *,ROW_NUMBER() OVER ( PARTITION BY ProductID,VendorID ORDER BY newid()) as rn FROM ProductVendorAssoc ) select ProductID, VendorID, ProductName, VendorName, IsActive FROM Numbered where rn=1
select ProductId, VendorId, ProductName, VendorName, IsActive from ( select *, row_number() over (partition by ProductId, VendorId order by ProductId) RowNumber from Production.Product ) tt where RowNumber = 1
DECLARE @str AS VARCHAR(50) SET @str = IF PATINDEX( PRINT ELSE PRINT
declare @result table (rowcount int); insert into @result (rowcount) exec (N declare @rowcount int = (select top (1) rowcount from @result);
CREATE PROC sp_count @CompanyId sysname, @codition sysname AS SET NOCOUNT ON CREATE TABLE ( NumRows int ) DECLARE @intCount int , @vcSQL varchar(255) SELECT @vcSQL = WHERE CompanyId = EXEC (@vcSQL) IF @@ERROR = 0 BEGIN SELECT @intCount = NumRows FROM DROP TABLE RETURN @intCount END ELSE BEGIN DROP TABLE RETURN -1 END GO
DECLARE @SQL VARCHAR(50) DECLARE @Rowcount INT SET @SQL = EXEC(@SQL) SET @Rowcount = @@ROWCOUNT SELECT @Rowcount
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER VIEW VW_Table_Name AS SELECT Col1,Col2,Col3 FROM Table_Name GO CREATE UNIQUE CLUSTERED INDEX Index_Name ON [VW_Table_Name](Col1) GO
CREATE VIEW VW_Table_Name WITH SCHEMABINDING AS SELECT Col1,Col2,Col3 FROM Table_Name GO
alter table TABLE_NAME add [column_name] as (**COLUMN-SQL**)
IF EXISTS(SELECT * FROM table1 WHERE Name= return 1 else return 0
IF EXISTS(SELECT * FROM table1 WHERE Name= return 0
CREATE TYPE [dbo].[StringID] FROM [nvarchar](20) NOT NULL
exec sp_addtype t_myudt_tmp, /* Build a command to alter all the existing columns - cut and ** paste the output, then run it */ select from INFORMATION_SCHEMA.COLUMNS where DOMAIN_NAME = exec sp_droptype t_mydut exec sp_rename
CREATE PROCEDURE [dbo].[RECREATE_TYPE] @schema VARCHAR(100), -- the schema name for the existing type @typ_nme VARCHAR(128), -- the type-name (without schema name) @sql VARCHAR(MAX) -- the SQL to create a type WITHOUT the "CREATE TYPE schema.typename" part AS DECLARE @scid BIGINT, @typ_id BIGINT, @temp_nme VARCHAR(1000), @msg VARCHAR(200) BEGIN -- find the existing type by schema and name SELECT @scid = [SCHEMA_ID] FROM sys.schemas WHERE UPPER(name) = UPPER(@schema); IF (@scid IS NULL) BEGIN SET @msg = RAISERROR (@msg, 1, 0); END; SELECT @typ_id = system_type_id FROM sys.types WHERE UPPER(name) = UPPER(@typ_nme); SET @temp_nme = @typ_nme + -- if the type-to-be-recreated actually exists, then rename it (give it a temporary name) -- if it doesn IF (@typ_id IS NOT NULL) BEGIN exec sp_rename @objname=@typ_nme, @newname= @temp_nme, @objtype= END; -- now create the new type SET @sql = exec sp_sqlexec @sql; -- if we are RE-creating a type (as opposed to just creating a brand-spanking-new type)... IF (@typ_id IS NOT NULL) BEGIN exec recompile_prog; -- then recompile all stored procs (that may have used the type) exec sp_droptype @typename=@temp_nme; -- and drop the temporary type which is now no longer referenced END; END GO CREATE PROCEDURE [dbo].[recompile_prog] AS BEGIN SET NOCOUNT ON; DECLARE @v TABLE (RecID INT IDENTITY(1,1), spname sysname) -- retrieve the list of stored procedures INSERT INTO @v(spname) SELECT FROM (SELECT sp.name, sp.schema_id, sp.is_ms_shipped FROM sys.procedures sp UNION SELECT so.name, so.SCHEMA_ID, so.is_ms_shipped FROM sys.objects so WHERE so.type_desc LIKE INNER JOIN sys.schemas s ON s.schema_id = items.schema_id WHERE is_ms_shipped = 0; -- counter variables DECLARE @cnt INT, @Tot INT; SELECT @cnt = 1; SELECT @Tot = COUNT(*) FROM @v; DECLARE @spname sysname -- start the loop WHILE @Cnt <= @Tot BEGIN SELECT @spname = spname FROM @v WHERE RecID = @Cnt; --PRINT BEGIN TRY -- refresh the stored procedure EXEC sp_refreshsqlmodule @spname END TRY BEGIN CATCH PRINT END CATCH SET @Cnt = @cnt + 1; END; END
SET NOCOUNT ON DECLARE @udt VARCHAR(150) DECLARE @udtschema VARCHAR(150) DECLARE @newudtschema VARCHAR(150) DECLARE @newudtDataType VARCHAR(150) DECLARE @newudtDataSize smallint DECLARE @OtherParameter VARCHAR(50) SET @udt = SET @udtschema = SET @newudtDataType = SET @newudtDataSize = 500 -- Lenght of the new UDDT SET @newudtschema = SET @OtherParameter = DECLARE @Datatype VARCHAR(50), @Datasize SMALLINT DECLARE @varcharDataType VARCHAR(50) DECLARE @Schemaname VARCHAR(50), @TableName VARCHAR(50), @FiledName VARCHAR(50) CREATE TABLE ( Schemaname VARCHAR(50), TableName VARCHAR(50), FiledName VARCHAR(50) ) SELECT TOP 1 @Datatype = Data_type, @Datasize = character_maximum_length FROM INFORMATION_SCHEMA.COLUMNS WHERE Domain_name = @udt AND Domain_schema = @udtschema SET @varcharDataType = @Datatype IF @DataType Like AND @Datasize IS NOT NULL AND ( @newudtDataType <> OR @newudtDataType <> ) BEGIN SET @varcharDataType = @varcharDataType + + CAST(@Datasize AS VARCHAR(50)) + END INSERT INTO SELECT TABLE_SCHEMA, TABLE_NAME, Column_Name FROM INFORMATION_SCHEMA.COLUMNS WHERE Domain_name = @udt AND Domain_schema = @udtschema DECLARE @exec VARCHAR(500) DECLARE alter_cursor CURSOR FOR SELECT Schemaname, TableName, FiledName FROM OPEN alter_cursor FETCH NEXT FROM alter_cursor INTO @Schemaname, @TableName, @FiledName WHILE @@FETCH_STATUS = 0 BEGIN SET @exec = + EXECUTE ( @exec ) FETCH NEXT FROM alter_cursor INTO @Schemaname, @TableName, @FiledName END CLOSE alter_cursor SET @exec = EXEC ( @exec ) SET @varcharDataType = @newudtDataType IF @newudtDataType Like AND @newudtDataSize IS NOT NULL AND ( @newudtDataType <> OR @newudtDataType <> ) BEGIN SET @varcharDataType = @varcharDataType + + CAST(@newudtDataSize AS VARCHAR(50)) + END SET @exec = + @varcharDataType + EXEC ( @exec ) OPEN alter_cursor FETCH NEXT FROM alter_cursor INTO @Schemaname, @TableName, @FiledName WHILE @@FETCH_STATUS = 0 BEGIN SET @exec = + + EXECUTE ( @exec ) FETCH NEXT FROM alter_cursor INTO @Schemaname, @TableName, @FiledName END CLOSE alter_cursor DEALLOCATE alter_cursor SELECT * FROM DROP TABLE
SELECT @SQLStatement = DECLARE @UserId DECLARE users_cursor CURSOR FOR EXECUTE @SQLStatment --Fails here. Doesn OPEN users_cursor FETCH NEXT FROM users_cursor INTO @UserId WHILE @@FETCH_STATUS = 0 BEGIN EXEC asp_DoSomethingStoredProc @UserId END CLOSE users_cursor DEALLOCATE users_cursor
Declare @UserID varchar(100) declare @sqlstatement nvarchar(4000) --move declare cursor into sql to be executed set @sqlstatement = exec sp_executesql @sqlstatement OPEN users_cursor FETCH NEXT FROM users_cursor INTO @UserId WHILE @@FETCH_STATUS = 0 BEGIN Print @UserID EXEC asp_DoSomethingStoredProc @UserId FETCH NEXT FROM users_cursor --have to fetch again within loop INTO @UserId END CLOSE users_cursor DEALLOCATE users_cursor
Declare @UserID varchar(100) create table declare @sqlstatement nvarchar(4000) set @sqlstatement = exec(@sqlstatement) declare users_cursor cursor for Select UserId from OPEN users_cursor FETCH NEXT FROM users_cursor INTO @UserId WHILE @@FETCH_STATUS = 0 BEGIN EXEC asp_DoSomethingStoredProc @UserId FETCH NEXT FROM users_cursor INTO @UserId END CLOSE users_cursor DEALLOCATE users_cursor drop table
ALTER PROCEDURE dbo.spTEST AS SET NOCOUNT ON DECLARE @query NVARCHAR(4000) = N DECLARE @inputList NVARCHAR(4000) = DECLARE @field sysname = DECLARE @my_cur CURSOR EXECUTE SP_EXECUTESQL N SELECT CASE @field WHEN WHEN END FROM dbo.vCard WHERE CASE @field WHEN WHEN END LIKE OPEN @my_cur; N @field = @field, @query = @query, @my_cur = @my_cur OUTPUT FETCH NEXT FROM @my_cur INTO @inputList WHILE @@FETCH_STATUS = 0 BEGIN PRINT @inputList FETCH NEXT FROM @my_cur INTO @inputList END RETURN
select * from a where (a=1 and b=1) union all select * from a where (a=1 and b=2)
DECLARE sampleCursor CURSOR FOR SELECT K.Id FROM TableA K WHERE ....; OPEN sampleCursor FETCH NEXT FROM sampleCursor INTO @Id WHILE @@FETCH_STATUS <> -1 BEGIN UPDATE TableB SET ...
SELECT * FROM table-that-does-not-exist; SELECT * FROM good-table;
SELECT * FROM table-that-does-not-exist GO SELECT * FROM good-table GO
CREATE PROCEDURE SpMyProc @myProcParam VARCHAR(20) AS DECLARE @myOtherParam INT = 5 ;DISABLE TRIGGER ALL ON tMyTable UPDATE tMyTable SET myVar = @myProcParam, mySecondVar = @myOtherParam ;ENABLE TRIGGER OLL ON tMyTable
EXEC sp_addlinkedserver @server= EXEC sp_addlinkedsrvlogin
exec sp_addlinkedserver @server = @srvproduct=N @provider=N
EXEC sp_addlinkedserver @server= @srvproduct=N @provider=N @datasrc=N EXEC sp_addlinkedsrvlogin
SELECT * FROM [SRV_NAME].your_remote_db_name.dbo.your_table
select * from Staging.APARMRE1 as ar where ar.Line like
DECLARE @YourTable table (PK int, col1 varchar(20), col2 varchar(20), col3 varchar(20)) INSERT @YourTable VALUES (1, INSERT @YourTable VALUES (2, INSERT @YourTable VALUES (3, INSERT @YourTable VALUES (4, INSERT @YourTable VALUES (5, char(182)+ INSERT @YourTable VALUES (6, --if you have a Numbers table use that, other wise make one using a CTE ;WITH AllNumbers AS ( SELECT 1 AS Number UNION ALL SELECT Number+1 FROM AllNumbers WHERE Number<1000 ) SELECT pk, FROM @YourTable y INNER JOIN AllNumbers n ON n.Number <= LEN(y.col1) WHERE ASCII(SUBSTRING(y.col1, n.Number, 1))<32 OR ASCII(SUBSTRING(y.col1, n.Number, 1))>127 UNION SELECT pk, FROM @YourTable y INNER JOIN AllNumbers n ON n.Number <= LEN(y.col2) WHERE ASCII(SUBSTRING(y.col2, n.Number, 1))<32 OR ASCII(SUBSTRING(y.col2, n.Number, 1))>127 UNION SELECT pk, FROM @YourTable y INNER JOIN AllNumbers n ON n.Number <= LEN(y.col3) WHERE ASCII(SUBSTRING(y.col3, n.Number, 1))<32 OR ASCII(SUBSTRING(y.col3, n.Number, 1))>127 order by 1 OPTION (MAXRECURSION 1000)
pk BadValueColumn BadValue ----------- -------------- -------------------- 2 Col1 BA¶D 3 Col2 ¶BAD 4 Col3 B¶AD 5 Col1 ¶BAD 5 Col3 ¶BAD 6 Col1 BAD¶ 6 Col2 B¶AD 6 Col3 BAD¶¶¶ (8 row(s) affected)
select line, patindex( substring(line,patindex( ascii(substring(line,patindex( from staging.APARMRE1 where patindex(
declare @str varchar(128) declare @i int set @str = set @i = 32 while @i <= 127 begin set @str = @str + set @i = @i + 1 end select col1 from YourTable where col1 like
declare @UnicodeData table ( data nvarchar(500) ) insert into @UnicodeData values (N ,(N ,(N select data from @UnicodeData where data collate LATIN1_GENERAL_BIN != cast(data as varchar(max))
declare @sql varchar(max) = ,@table sysname = ;with ColumnData as ( select RowId = row_number() over (order by c.COLUMN_NAME) ,c.COLUMN_NAME ,ColumnName = ,TableName = from INFORMATION_SCHEMA.COLUMNS c where c.DATA_TYPE = and c.TABLE_NAME = @table ) select @sql = @sql + from ColumnData c -- check -- print @sql exec (@sql)
select dodgyColumn from myTable fcc WHERE patindex(
select dodgyColumn from myTable fcc INNER JOIN dbo.Numbers32k dn ON dn.number<(len(fcc.dodgyColumn )) WHERE ASCII(SUBSTRING(fcc.dodgyColumn , dn.Number, 1))<32 OR ASCII(SUBSTRING(fcc.dodgyColumn , dn.Number, 1))>127
select dodgyColumn from myTable where dbo.udf_test_ContainsNonASCIIChars(dodgyColumn , 1) = 1
Select * from Staging.APARMRE1 ar where udf_parsealpha(ar.last_name) <> ar.last_name
Select id, case when udf_parsealpha(ar.last_name) <> ar.last_name then when udf_parsealpha(ar.first_name) <> ar.first_name then when udf_parsealpha(ar.Address1) <> ar.last_name then end, case when udf_parsealpha(ar.last_name) <> ar.last_name then ar.last_name when udf_parsealpha(ar.first_name) <> ar.first_name then ar.first_name when udf_parsealpha(ar.Address1) <> ar.last_name then ar.Address1 end from Staging.APARMRE1 ar where udf_parsealpha(ar.last_name) <> ar.last_name or udf_parsealpha(ar.first_name) <> ar.first_name or udf_parsealpha(ar.Address1) <> ar.last_name
select id,fieldname,value from ( Select id, from Staging.APARMRE1 ar Union Select id, from Staging.APARMRE1 ar ---(and repeat unions for each field) ) where udf_parsealpha(value) <> value
create function [dbo].[udf_ContainsNonASCIIChars] ( @string nvarchar(4000), @checkExtendedCharset bit ) returns bit as begin declare @pos int = 0; declare @char varchar(1); declare @return bit = 0; while @pos < len(@string) begin select @char = substring(@string, @pos, 1) if ascii(@char) < 32 or ascii(@char) > 126 begin if @checkExtendedCharset = 1 begin if ascii(@char) not in (9,124,130,138,142,146,150,154,158,160,170,176,180,181,183,184,185,186,192,193,194,195,196,197,199,200,201,202,203,204,205,206,207,209,210,211,212,213,214,216,217,218,219,220,221,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,248,249,250,251,252,253,254,255) begin select @return = 1; select @pos = (len(@string) + 1) end else begin select @pos = @pos + 1 end end else begin select @return = 1; select @pos = (len(@string) + 1) end end else begin select @pos = @pos + 1 end end return @return; end
select Address1 from PropertyFile_English where udf_ContainsNonASCIIChars(Address1, 1) = 1
ORDER BY ISNULL(date_sent, GETDATE()) DESC ORDER BY (CASE WHEN t.setinactive IS NULL THEN 1 ELSE 2 END), t.setinactive DESC ORDER BY -CAST(date_sent as int) ASC
ORDER BY (CASE WHEN [Order] IS NULL THEN 0 ELSE 1 END), [Order]
ORDER BY (case WHEN ColINT IS NULL THEN {maxIntValue} ELSE ColINT END) DESC ORDER BY (case WHEN ColVChar IS NULL THEN {maxVCharValue} ELSE ColVChar END) DESC ORDER BY (case WHEN ColDateT IS NULL THEN {maxDateTValue} ELSE ColDateT END) DESC
ORDER BY (case WHEN ColAnyType IS NULL THEN 1 ELSE 0 END) DESC, ColAnyType DESC
SELECT (CASE WHEN Value1 IS NULL THEN 1 ELSE 0 END) AS ValueIsNull, Value1, Value2, Value3 FROM TableName ORDER BY ValueIsNull DESC, Value1
CREATE FUNCTION dbo.Splitfn(@String varchar(8000), @Delimiter char(1)) returns @temptable TABLE (items varchar(8000)) as begin declare @idx int declare @slice varchar(8000) select @idx = 1 if len(@String)<1 or @String is null return while @idx!= 0 begin set @idx = charindex(@Delimiter,@String) if @idx!=0 set @slice = left(@String,@idx - 1) else set @slice = @String if(len(@slice)>0) insert into @temptable(Items) values(@slice) set @String = right(@String,len(@String) - @idx) if len(@String) = 0 break end return end
ALTER PROCEDURE [dbo].[Employees_Delete] -- Add the parameters for the stored procedure here @Id varchar(50) AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; -- Insert statements for procedure here if exists( select Emp_Id from Employee where Emp_Id=dbo.Splitfn(@Id, begin update Employee set Is_Deleted=1 where Emp_Id=dbo.Splitfn(@Id, select end END
Cannot find either column "dbo" or the user-defined function or aggregate "dbo.Splitfn", or the name is ambiguous.
where Emp_Id IN (SELECT i.items FROM dbo.Splitfn(@Id,
select Emp_Id from Employee E JOIN dbo.Splitfn(@Id,
1 2 4 ------------------ Dave 0 1 1 Charlie 0 1 0 Susan 0 0 1 Nick 1 0 0
1 2 4 ------------------ Dave 0 1 1 Test 0 1 1 Result 0 1 1 (6) Charlie 0 1 0 Test 0 1 1 Result 0 1 0 (2) Susan 0 0 1 Test 0 1 1 Result 0 0 1 (4) Nick 1 0 0 Test 0 1 1 Result 0 0 0 (0)
with test (id, username, roles) AS ( SELECT 1, UNION SELECT 2, UNION SELECT 3, UNION SELECT 4, ) select * from test where (roles & 6) != 0
DECLARE @Mask int SET @Mask = 6 DECLARE @Users TABLE ( ID int, Username varchar(50), Roles int ) INSERT INTO @Users (ID, Username, Roles) SELECT 1, UNION SELECT 2, UNION SELECT 3, UNION SELECT 4, SELECT * FROM @Users WHERE Roles & @Mask > 0
IGrp | Item | Value1 | Value2 A | I11 | 0.52 | 1.18 A | I12 | 1.30 | 0.54 A | I21 | 0.49 | 2.37 B | I22 | 2.16 | 1.12 B | I31 | 1.50 | 0.28
SELECT IGrp, COUNT(Value1>1) AS V1High, COUNT(Value2>1) AS V2High FROM Tbl GROUP BY IGrp
SELECT IGrp, COUNT(CASE WHEN Value1 > 1 THEN 1 ELSE NULL END) AS V1High, COUNT(CASE WHEN Value2 > 1 THEN 1 ELSE NULL END) AS V2High FROM Tbl GROUP BY IGrp
SELECT IGrp, SUM(CASE WHEN Value1>1 THEN 1 ELSE 0 END) AS V1High, SUM(CASE WHEN Value2>1 THEN 1 ELSE 0 END) AS V2High FROM Tbl GROUP BY IGrp
SELECT IGrp, sum(case when isnull(Value1,0)>1 then 1 else 0 end) AS V1High, sum(case when isnull(Value2,0)>1 then 1 else 0 end) AS V2High FROM Tbl GROUP BY IGrp
SELECT IGrp, COUNT(CASE WHEN Value1 = COUNT(CASE WHEN Value1 = FROM Tbl GROUP BY IGrp
CREATE FUNCTION [dbo].[GetAliasesById] ( @userID int ) RETURNS varchar(max) AS BEGIN declare @output varchar(max) select @output = COALESCE(@output + from UserAliases where userid = @userID return @output END GO SELECT UserID, dbo.GetAliasesByID(UserID) FROM UserAliases GROUP BY UserID GO
DECLARE @UserAliases TABLE(UserId INT , Alias VARCHAR(10)) INSERT INTO @UserAliases (UserId,Alias) SELECT 1, UNION ALL SELECT 1, UNION ALL SELECT 2, ;WITH tmp AS ( SELECT DISTINCT UserId FROM @UserAliases ) SELECT LEFT(tmp.UserId, 10) + STUFF( ( SELECT FROM @UserAliases WHERE UserId = tmp.UserId FOR XML PATH( ) , 1, 2, ) AS [UserId/Alias] FROM tmp /* -- OUTPUT UserId/Alias 1/ MrX, MrY, MrA 2/ Abc, Xyz */
DECLARE @Str varchar(500) SELECT @Str=COALESCE(@Str, FROM dbo.fcUser SELECT @Str
declare @result varchar(max) --must "initialize" result for this to work select @result = select @result = @result + alias FROM aliases WHERE username=
SELECT job.name, job.job_id, job.originating_server, activity.run_requested_date, DATEDIFF( SECOND, activity.run_requested_date, GETDATE() ) as Elapsed FROM msdb.dbo.sysjobs_view job JOIN msdb.dbo.sysjobactivity activity ON job.job_id = activity.job_id JOIN msdb.dbo.syssessions sess ON sess.session_id = activity.session_id JOIN ( SELECT MAX( agent_start_date ) AS max_agent_start_date FROM msdb.dbo.syssessions ) sess_max ON sess.agent_start_date = sess_max.max_agent_start_date WHERE run_requested_date IS NOT NULL AND stop_execution_date IS NULL
SELECT job.Name, job.job_ID ,job.Originating_Server ,activity.run_requested_Date ,datediff(minute, activity.run_requested_Date, getdate()) AS Elapsed FROM msdb.dbo.sysjobs_view job INNER JOIN msdb.dbo.sysjobactivity activity ON (job.job_id = activity.job_id) WHERE run_Requested_date is not null AND stop_execution_date is null AND job.name like
-- Microsoft SQL Server 2008 Standard Edition: IF EXISTS(SELECT 1 FROM msdb.dbo.sysjobs J JOIN msdb.dbo.sysjobactivity A ON A.job_id=J.job_id WHERE J.name=N AND A.run_requested_date IS NOT NULL AND A.stop_execution_date IS NULL ) PRINT ELSE PRINT
select job.Name, job.job_ID, job.Originating_Server,activity.run_requested_Date, datediff(minute, activity.run_requested_Date, getdate()) as Elapsed from msdb.dbo.sysjobs_view job inner join msdb.dbo.sysjobactivity activity on (job.job_id = activity.job_id) where run_Requested_date is not null and stop_execution_date is null and job.name like
delete activity from msdb.dbo.sysjobs_view job inner join msdb.dbo.sysjobactivity activity on job.job_id = activity.job_id where activity.run_Requested_date is not null and activity.stop_execution_date is null
CREATE TABLE ( job_id UNIQUEIDENTIFIER NOT NULL , last_run_date INT NOT NULL , last_run_time INT NOT NULL , next_run_date INT NOT NULL , next_run_time INT NOT NULL , next_run_schedule_id INT NOT NULL , requested_to_run INT NOT NULL , request_source INT NOT NULL , request_source_id sysname NULL , running INT NOT NULL , current_step INT NOT NULL , current_retry_attempt INT NOT NULL , job_state INT NOT NULL ); DECLARE @sqluser NVARCHAR(128) , @is_sysadmin INT; SELECT @is_sysadmin = ISNULL(IS_SRVROLEMEMBER(N DECLARE read_sysjobs_for_running CURSOR FOR SELECT DISTINCT SUSER_SNAME(owner_sid)FROM msdb.dbo.sysjobs; OPEN read_sysjobs_for_running; FETCH NEXT FROM read_sysjobs_for_running INTO @sqluser; WHILE @@FETCH_STATUS = 0 BEGIN INSERT INTO EXECUTE master.dbo.xp_sqlagent_enum_jobs @is_sysadmin, @sqluser; FETCH NEXT FROM read_sysjobs_for_running INTO @sqluser; END; CLOSE read_sysjobs_for_running; DEALLOCATE read_sysjobs_for_running; SELECT j.name , WHEN 0 THEN ELSE END , , WHEN a.start_execution_date IS NOT NULL AND a.stop_execution_date IS NULL THEN WHEN h.run_status = 0 THEN WHEN h.run_status = 2 THEN WHEN h.run_status = 3 THEN WHEN h.run_status = 4 THEN WHEN h.run_status = 1 THEN ELSE END , r.current_step , spid = p.session_id , owner = ISNULL(SUSER_SNAME(j.owner_sid), , a.start_execution_date , a.stop_execution_date , t.subsystem , t.step_name FROM msdb.dbo.sysjobs j LEFT OUTER JOIN (SELECT DISTINCT * FROM ON j.job_id = r.job_id LEFT OUTER JOIN msdb.dbo.sysjobactivity a ON j.job_id = a.job_id AND a.start_execution_date IS NOT NULL --AND a.stop_execution_date IS NULL AND NOT EXISTS ( SELECT * FROM msdb.dbo.sysjobactivity at WHERE at.job_id = a.job_id AND at.start_execution_date > a.start_execution_date ) LEFT OUTER JOIN sys.dm_exec_sessions p ON p.program_name LIKE AND j.job_id = SUBSTRING(SUBSTRING(p.program_name, CHARINDEX( LEFT OUTER JOIN msdb.dbo.sysjobhistory h ON j.job_id = h.job_id AND h.instance_id = a.job_history_id LEFT OUTER JOIN msdb.dbo.sysjobsteps t ON t.job_id = j.job_id AND t.step_id = r.current_step ORDER BY 1; DROP TABLE
IF OBJECT_ID ( DROP PROCEDURE usp_getJobStatus; GO CREATE PROCEDURE usp_getJobStatus @JobName NVARCHAR (1000) AS IF OBJECT_ID( CREATE TABLE Last_Run_Date INT NOT NULL, Last_Run_Time INT NOT NULL, Next_Run_date INT NOT NULL, Next_Run_Time INT NOT NULL, Next_Run_Schedule_ID INT NOT NULL, Requested_to_Run INT NOT NULL, Request_Source INT NOT NULL, Request_Source_id SYSNAME COLLATE Database_Default NULL, Running INT NOT NULL, Current_Step INT NOT NULL, Current_Retry_Attempt INT NOT NULL, Job_State INT NOT NULL ) INSERT EXECUTE master.dbo.xp_sqlagent_enum_jobs 1, SELECT job.name AS [Job_Name], ( SELECT MAX(CAST( STUFF(STUFF(CAST(jh.run_date AS VARCHAR),7,0, STUFF(STUFF(REPLACE(STR(jh.run_time,6,0), FROM msdb.dbo.sysjobs AS j INNER JOIN msdb.dbo.sysjobhistory AS jh ON jh.job_id = j.job_id AND jh.step_id = 0 WHERE j.[name] LIKE GROUP BY j.[name] ) AS [Last_Completed_DateTime], ( SELECT TOP 1 start_execution_date FROM msdb.dbo.sysjobactivity WHERE job_id = r.job_id ORDER BY start_execution_date DESC ) AS [Job_Start_DateTime], CASE WHEN r.running = 0 THEN CASE WHEN jobInfo.lASt_run_outcome = 0 THEN WHEN jobInfo.lASt_run_outcome = 1 THEN WHEN jobInfo.lASt_run_outcome = 3 THEN ELSE END WHEN r.job_state = 0 THEN WHEN r.job_state = 4 THEN WHEN r.job_state = 5 THEN WHEN r.job_state = 1 THEN WHEN r.job_state = 2 THEN WHEN r.job_state = 3 THEN WHEN r.job_state = 7 THEN ELSE FROM LEFT OUTER JOIN msdb.dbo.sysjobservers AS jobInfo ON r.job_id = jobInfo.job_id INNER JOIN msdb.dbo.sysjobs AS job ON r.job_id = job.job_id WHERE job.[enabled] = 1 AND job.name LIKE
;WITH CTE_JobStatus AS ( SELECT DISTINCT NAME AS [JobName] ,s.step_id ,s.step_name ,CASE WHEN [Enabled] = 1 THEN ELSE END [JobStatus] ,CASE WHEN SJH.run_status = 0 THEN WHEN SJH.run_status = 1 THEN WHEN SJH.run_status = 2 THEN WHEN SJH.run_status = 3 THEN WHEN SJH.run_status = 4 THEN ELSE END [JobOutcome] ,CONVERT(VARCHAR(8), sjh.run_date) [RunDate] ,CONVERT(VARCHAR(8), STUFF(STUFF(CONVERT(TIMESTAMP, RIGHT( ,RANK() OVER ( PARTITION BY s.step_name ORDER BY sjh.run_date DESC ,sjh.run_time DESC ) AS rn ,SJH.run_status FROM msdb..SYSJobs sj INNER JOIN msdb..SYSJobHistory sjh ON sj.job_id = sjh.job_id INNER JOIN msdb.dbo.sysjobsteps s ON sjh.job_id = s.job_id AND sjh.step_id = s.step_id WHERE (sj.NAME LIKE AND sjh.run_date = CONVERT(CHAR, getdate(), 112) ) SELECT * FROM CTE_JobStatus WHERE rn = 1 AND run_status NOT IN (1,4)
INSERT INTO EXEC master.dbo.xp_sqlagent_enum_jobs 1,dbo
CREATE TABLE (job_id UNIQUEIDENTIFIER NOT NULL, last_run_date INT NOT NULL, last_run_time INT NOT NULL, next_run_date INT NOT NULL, next_run_time INT NOT NULL, next_run_schedule_id INT NOT NULL, requested_to_run INT NOT NULL, -- BOOL request_source INT NOT NULL, request_source_id sysname COLLATE database_default NULL, running INT NOT NULL, -- BOOL current_step INT NOT NULL, current_retry_attempt INT NOT NULL, job_state INT NOT NULL)
SELECT sj.name FROM msdb..sysjobactivity aj JOIN msdb..sysjobs sj on sj.job_id = aj.job_id WHERE aj.stop_execution_date IS NULL -- job hasn AND aj.start_execution_date IS NOT NULL -- job is currently running AND sj.name = AND NOT EXISTS( -- make sure this is the most recent run select 1 from msdb..sysjobactivity new where new.job_id = aj.job_id and new.start_execution_date > aj.start_execution_date ) ) print
select t1.field1,t2.field2 --update t --set field1 = t2.field2 from mytable t1 join myothertable t2 on t1.idfield =t2.idfield where t2.field1 >10 select t1.* --delete t1 from mytable t1 join myothertable t2 on t1.idfield =t2.idfield where t2.field1 =
select t1.field1,t2.field2 update t set field1 = t2.field2 --select t1.field1,t2.field2 from mytable t1 join myothertable t2 on t1.idfield =t2.idfield where t2.field1 >10
CREATE PROC upsert_Table1(@col1 int, @col2 varchar(200), @col3 float, etc.) AS BEGIN UPDATE table1 SET col1 = @col1, col2 = @col2, col3 = @col3, etc. IF @@error <> 0 INSERT Table1 (col1, col2, col3, etc.) VALUES(@col1, @col2, @col3, etc.) END GO CREATE PROC delete_Table1(@col1) AS DELETE FROM Table1 WHERE col1 = @col1
select count(*) from foo1 where ID = union all select count(*) from foo2 where ID = union all select count(*) from foo3 where ID =
SELECT (select count(*) from foo1 where ID = + (select count(*) from foo2 where ID = + (select count(*) from foo3 where ID =
SELECT SUM(c) FROM ( SELECT COUNT(*) AS c FROM foo1 WHERE ID = UNION ALL SELECT COUNT(*) FROM foo2 WHERE ID = UNION ALL SELECT COUNT(*) FROM foo3 WHERE ID = );
select (select count(*) from foo) as foo , (select count(*) from bar) as bar , ...
SELECT (SELECT COUNT(*) FROM MyTable WHERE MyCol = (SELECT COUNT(*) FROM YourTable WHERE MyCol =
SELECT SUM(A) FROM ( SELECT 1 AS A UNION ALL SELECT 1 AS A UNION ALL SELECT 1 AS A UNION ALL SELECT 1 AS A ) AS B
SELECT A, B, C FROM ( your initial query here ) TableAlias
select sum(counts) from ( select count(1) as counts from foo union all select count(1) as counts from bar)
select( select count(*) from foo1 where ID = + select count(*) from foo2 where ID = + select count(*) from foo3 where ID = ) total from dual;
DECLARE @datetime datetime SELECT @datetime = GETDATE() SELECT RIGHT( RIGHT(
declare @dt datetime set @dt = select datepart(hour, @dt) -- returns 8
declare @dt datetime set @dt = select CAST(@dt as time) -- returns 08:25:53
select * from some_table t where convert(time,t.some_datetime_column) =
select convert(datetime,convert(varchar,current_timestamp,112),112)
select start_of_day = t.some_datetime_column - convert(time, t.some_datetime_column ) , from some_table t
select five_pm = dateadd(hour,17, t.some_datetime_column - convert(time,t.some_datetime_column) ) from some_table t
SELECT DATEADD(dd, -DATEDIFF(dd, 0, mydatetime), mydatetime)
select convert(datetime,convert(float, getdate()) - convert(int,getdate())), getdate()
INSERT INTO infoTbl (itDate, itTime) VALUES (GETDATE(),CONVERT(TIME,GETDATE()))
DECLARE @dt TIME SET @dt = CONVERT(TIME,GETDATE()) PRINT @dt
SELECT DISTINCT CONVERT(VARCHAR(17), A.SOURCE_DEPARTURE_TIME, 108) FROM CONSOLIDATED_LIST AS A WHERE CONVERT(VARCHAR(17), A.SOURCE_DEPARTURE_TIME, 108) BETWEEN
SELECT @SomeIds = ( SELECT spro.Id FROM SomeTable as spro INNER JOIN [Address] addr ON addr.Id = spro.Id INNER JOIN City cty ON cty.CityId = addr.CityId WHERE cty.CityId = @CityId ) WHILE @SomeIds IS NOT NULL BEGIN EXEC UpdateComputedFullText @SomeIds END
DECLARE @oneid int -- or the appropriate type DECLARE the_cursor CURSOR FAST_FORWARD FOR SELECT spro.Id FROM SomeTable as spro INNER JOIN [Address] addr ON addr.Id = spro.Id INNER JOIN City cty ON cty.CityId = addr.CityId WHERE cty.CityId = @CityId OPEN the_cursor FETCH NEXT FROM the_cursor INTO @oneid WHILE @@FETCH_STATUS = 0 BEGIN EXEC UpdateComputedFullText @oneid FETCH NEXT FROM the_cursor INTO @oneid END CLOSE the_cursor DEALLOCATE the_cursor
SELECT supt.hostname,supt.scriptname, COUNT(*) FROM Event_Pagehit eph INNER JOIN Symboltable_urlpair supf ON eph.fromPagePair=supf.id INNER JOIN Symboltable_urlpair supt ON supt.id=eph.toPagePair CROSS APPLY dbo.TDFCompanyFormationsUrlClassification(supf.hostname,supf.scriptname) as x CROSS APPLY dbo.TDFCompanyFormationsUrlClassification(supt.hostname,supt.scriptname) as y WHERE x.isCompanyFormations=1 AND y.isCompanyFormations=0 GROUP BY supt.hostname,supt.scriptname ORDER BY COUNT(*) desc
Declare @Keys Table (key integer Primary Key Not Null) Insert @Keys(key) SELECT spro.Id FROM SomeTable as spro JOIN [Address] addr ON addr.Id = spro.Id JOIN City cty ON cty.CityId = addr.CityId WHERE cty.CityId = @CityId -- ------------------------------------------- Declare @Key Integer While Exists (Select * From @Keys) Begin Select @Key = Max(Key) From @Keys EXEC UpdateComputedFullText @Key Delete @Keys Where Key = @Key End
Declare @Key Integer = 0 While Exists (Select * From @Keys Where key > @Key) Begin Select @Key = Min(Key) From @Keys Where key > @Key EXEC UpdateComputedFullText @Key -- Delete @Keys Where Key = @Key No Longer necessary End
DECLARE @id int SELECT top 1 @id = spro.Id FROM SomeTable as spro INNER JOIN [Address] addr ON addr.Id = spro.Id INNER JOIN City cty ON cty.CityId = addr.CityId WHERE cty.CityId = @CityId ORDER BY spro.id WHILE @@ROWCOUNT > 0 BEGIN EXEC UpdateComputedFullText @id SELECT top 1 @id = spro.Id FROM SomeTable as spro INNER JOIN [Address] addr ON addr.Id = spro.Id INNER JOIN City cty ON cty.CityId = addr.CityId WHERE cty.CityId = @CityId and spro.id > @id ORDER BY spro.id END
DECLARE @id int DECLARE cursor_sample CURSOR FOR SELECT spro.Id FROM SomeTable as spro INNER JOIN [Address] addr ON addr.Id = spro.Id INNER JOIN City cty ON cty.CityId = addr.CityId WHERE cty.CityId = @CityId OPEN cursor_sample FETCH NEXT FROM cursor_sample INTO @id WHILE @@FETCH_STATUS = 0 BEGIN EXEC UpdateComputedFullText @id FETCH NEXT FROM cursor_sample INTO @id END CLOSE cursor_sample DEALLOCATE cursor_sample
...declare cursor etc. While 1=1 Fetch ... if @@FETCH_STATUS <> 0 BREAK ... End -- While ..Close cursor etc.
select case when foo = from bar where baz = (some criteria)
SELECT CASE WHEN Foo = FROM bar WHERE baz = @Criteria
SELECT CASE foo WHEN ELSE 0 END AS [col2] FROM bar WHERE baz = (some criteria)
select iif(foo = from bar where baz = (some criteria)
ALTER PROCEDURE dbo.pdpd_DynamicCall @SQLString varchar(4096) = null AS Begin create TABLE insert into execute ( select * from End
DECLARE @sql varchar(max) SET @sql = EXEC(@sql) INSERT INTO SELECT * FROM
DECLARE @sql varchar(max) SET @sql = EXEC(@sql) INSERT INTO SELECT * FROM
DECLARE @TmpGlobalTable varchar(255) = -- select @TmpGlobalTable -- build query SET @Sql = EXEC (@Sql) EXEC ( EXEC ( PRINT
DECLARE @EmpGroup INT =3 , @IsActive BIT=1 DECLARE @tblEmpMaster AS TABLE (EmpCode VARCHAR(20),EmpName VARCHAR(50),EmpAddress VARCHAR(500)) INSERT INTO @tblEmpMaster EXECUTE SPGetEmpList @EmpGroup,@IsActive SELECT * FROM @tblEmpMaster
CREATE PROCEDURE dbo.pdpd_DynamicCall AS DECLARE @SQLString_2 NVARCHAR(4000) SET NOCOUNT ON Begin --- Create global temp table CREATE TABLE SELECT @SQLString_2 = SELECT @SQLString_2 = REPLACE(@SQLString_2, EXEC SP_EXECUTESQL @SQLString_2 --- Test Display records SELECT * FROM --- Drop global temp table IF OBJECT_ID( DROP TABLE End
((a <> b OR a IS NULL OR b IS NULL) AND NOT (a IS NULL AND b IS NULL))
(NOT (a <> b OR a IS NULL OR b IS NULL) OR (a IS NULL AND b IS NULL))
SELECT * FROM TableA A INNER JOIN TableB B ON A.PK = B.PK WHERE NOT EXISTS( SELECT A.Col1, A.Col2, A.Col3 INTERSECT SELECT B.Col1, B.Col2, B.Col3);
a IS DISTINCT FROM b <==> ( ((a) IS NULL AND (b) IS NOT NULL) OR ((a) IS NOT NULL AND (b) IS NULL) OR ((a) <> (b)) ) a IS NOT DISTINCT FROM b <==> ( ((a) IS NULL AND (b) IS NULL) OR ((a) = (b)) )
a IS DISTINCT FROM b <==> COALESCE(a, placeholder) <> COALESCE(b, placeholder) a IS NOT DISTINCT FROM b <==> COALESCE(a, placeholder) = COALESCE(b, placeholder)
WHERE @input = column OR (@input IS NULL AND column IS NULL)
CASE WHEN [a] IS NULL AND [b] IS NULL THEN FALSE WHEN [a] IS NULL AND [b] IS NOT NULL THEN TRUE WHEN [a] IS NOT NULL AND [b] IS NULL THEN TRUE WHEN [a] = [b] THEN FALSE ELSE TRUE END
a IS DISTINCT FROM b <=> EXISTS (SELECT a EXCEPT SELECT b) -- NOT EXISTS (SELECT a INTERSECT SELECT b)
a IS NOT DISTINCT FROM b <=> NOT EXISTS (SELECT a EXCEPT SELECT b) -- EXISTS (SELECT a INTERSECT SELECT b)
SELECT 1 AS PK, 21 AS c, NULL AS b INTO tab1; SELECT 1 AS PK, 21 AS c, 2 AS b INTO tab2; SELECT * FROM tab1 A JOIN tab2 B ON A.PK = B.PK WHERE EXISTS(SELECT A.c, A.B EXCEPT SELECT B.c, B.b);
(a IS NOT NULL AND b IS NOT NULL AND a=b) OR (a IS NULL AND b is NULL)
EXEC sp_change_users_login DECLARE @OrphanedUsers TABLE ( IndexKey Int IDENTITY(1,1) PRIMARY KEY, UserName SysName,--nVarChar(128) UserSID VarBinary(85) ) INSERT INTO @OrphanedUsers EXEC sp_change_users_login DECLARE @CRLF as nVarChar SET @CRLF = CHAR(10) + DECLARE @Sql as nVarChar(MAX) SET @Sql = N DECLARE @IndexKey as Int SET @IndexKey = 1 DECLARE @MaxIndexKey as Int SET @MaxIndexKey = (SELECT COUNT(*) FROM @OrphanedUsers) DECLARE @Count as Int SET @Count = 0 DECLARE @UsersFixed as nVarChar(MAX) SET @UsersFixed = N DECLARE @UserName as SysName--This is an orphaned Database user. WHILE (@IndexKey <= @MaxIndexKey) BEGIN SET @UserName = (SELECT UserName FROM @OrphanedUsers WHERE IndexKey = @IndexKey) IF 1 = (SELECT COUNT(*) FROM sys.server_principals WHERE Name = @UserName)--Look for a match in the Server Logins. BEGIN SET @Sql = @Sql + SET @UsersFixed = @UsersFixed + @UserName + SET @Count = @Count + 1 END SET @IndexKey = @IndexKey + 1 END PRINT @Sql EXEC sp_executesql @Sql PRINT SELECT ( EXEC sp_change_users_login
USE MyDatabaseName DECLARE @login nvarchar(50) DECLARE logins_cursor CURSOR FOR SELECT l.name FROM sys.database_principals u INNER JOIN sys.server_principals l ON u.sid=l.sid OPEN logins_cursor FETCH NEXT FROM logins_cursor INTO @login WHILE @@FETCH_STATUS = 0 BEGIN EXEC sp_help_revlogin @login FETCH NEXT FROM logins_cursor INTO @login END CLOSE logins_cursor DEALLOCATE logins_cursor GO
USE master GO IF OBJECT_ID ( DROP PROCEDURE sp_hexadecimal GO CREATE PROCEDURE sp_hexadecimal @binvalue varbinary(256), @hexvalue varchar(256) OUTPUT AS DECLARE @charvalue varchar(256) DECLARE @i int DECLARE @length int DECLARE @hexstring char(16) SELECT @charvalue = SELECT @i = 1 SELECT @length = DATALENGTH (@binvalue) SELECT @hexstring = WHILE (@i <= @length) BEGIN DECLARE @tempint int DECLARE @firstint int DECLARE @secondint int SELECT @tempint = CONVERT(int, SUBSTRING(@binvalue,@i,1)) SELECT @firstint = FLOOR(@tempint/16) SELECT @secondint = @tempint - (@firstint*16) SELECT @charvalue = @charvalue + SUBSTRING(@hexstring, @firstint+1, 1) + SUBSTRING(@hexstring, @secondint+1, 1) SELECT @i = @i + 1 END SELECT @hexvalue = @charvalue GO IF OBJECT_ID ( DROP PROCEDURE sp_help_revlogin GO CREATE PROCEDURE sp_help_revlogin @login_name sysname = NULL AS DECLARE @name sysname DECLARE @xstatus int DECLARE @binpwd varbinary (256) DECLARE @txtpwd sysname DECLARE @tmpstr varchar (256) DECLARE @SID_varbinary varbinary(85) DECLARE @SID_string varchar(256) IF (@login_name IS NULL) DECLARE login_curs CURSOR FOR SELECT sid, name, xstatus, password FROM master..sysxlogins WHERE srvid IS NULL AND name <> ELSE DECLARE login_curs CURSOR FOR SELECT sid, name, xstatus, password FROM master..sysxlogins WHERE srvid IS NULL AND name = @login_name OPEN login_curs FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @xstatus, @binpwd IF (@@fetch_status = -1) BEGIN PRINT CLOSE login_curs DEALLOCATE login_curs RETURN -1 END SET @tmpstr = PRINT @tmpstr SET @tmpstr = + CONVERT (varchar, GETDATE()) + PRINT @tmpstr PRINT PRINT WHILE (@@fetch_status <> -1) BEGIN IF (@@fetch_status <> -2) BEGIN PRINT SET @tmpstr = PRINT @tmpstr IF (@xstatus & 4) = 4 BEGIN -- NT authenticated account/group IF (@xstatus & 1) = 1 BEGIN -- NT login is denied access SET @tmpstr = PRINT @tmpstr END ELSE BEGIN -- NT login has access SET @tmpstr = PRINT @tmpstr END END ELSE BEGIN -- SQL Server authentication IF (@binpwd IS NOT NULL) BEGIN -- Non-null password EXEC sp_hexadecimal @binpwd, @txtpwd OUT IF (@xstatus & 2048) = 2048 SET @tmpstr = ELSE SET @tmpstr = PRINT @tmpstr EXEC sp_hexadecimal @SID_varbinary,@SID_string OUT SET @tmpstr = + END ELSE BEGIN -- Null password EXEC sp_hexadecimal @SID_varbinary,@SID_string OUT SET @tmpstr = + END IF (@xstatus & 2048) = 2048 -- login upgraded from 6.5 SET @tmpstr = @tmpstr + ELSE SET @tmpstr = @tmpstr + PRINT @tmpstr END END FETCH NEXT FROM login_curs INTO @SID_varbinary, @name, @xstatus, @binpwd END CLOSE login_curs DEALLOCATE login_curs RETURN 0 GO
SELECT CONVERT(varchar(50), (DATEADD(dd, @@DATEFIRST - DATEPART(dw, DATECOL), DATECOL)), 101), CONVERT(varchar(50), (DATEADD(dd, @@DATEFIRST - DATEPART(dw, DATECOL) - 6, DATECOL)), 101)
select datecol, DATEPART(ISOWK, datecol) as week, ((DATEPART(dw, datecol)+5)%7)+1 as weekday, (DATEADD(dd, -((DATEPART(dw, datecol)+5)%7), datecol)) as Monday, (DATEADD(dd, -((DATEPART(dw, datecol)+5)%7)+6, datecol)) as Sunday
SELECT DATECOL - DATEPART(weekday, DATECOL), DATECOL - DATEPART(weekday, DATECOL) + 7
CREATE FUNCTION dbo.fnGetDateFromWeekNo (@weekNo int , @yearNo int) RETURNS smalldatetime AS BEGIN DECLARE @tmpDate smalldatetime set @tmpdate= cast(cast (@yearNo as varchar) + -- jump forward x-1 weeks to save counting through the whole year set @tmpdate=dateadd(wk,@weekno-1,@tmpdate) -- make sure weekno is not out of range if @WeekNo <= datepart(wk,cast(cast (@yearNo as varchar) + BEGIN WHILE (datepart(wk,@tmpdate)<@WeekNo) BEGIN set @tmpdate=dateadd(dd,1,@tmpdate) END END ELSE BEGIN -- invalid weeknumber given set @tmpdate=null END RETURN @tmpDate END
--CHANGE A WEEK NUMBER BACK INTO A DATE FOR THE FIRST DATE OF THE WEEK DECLARE @TaskWeek INT = 17 DECLARE @TaskYear INT = 2013 SELECT DATEADD(WEEK, @TaskWeek - 1,DATEADD(dd, 1 - DATEPART(dw,
dateadd( dd, datepart(wk, @Date)*7, convert(smalldatetime, convert(char,year(max(@Date)))+convert(char, )-1
DECLARE @Year VARCHAR(4) SET @Year= DECLARE @FirstDate DATETIME SET @FirstDate = (SELECT DATEADD(dd,1,(SELECT DATEADD(wk,DATEPART(wk,GETDATE())-1,Convert(DAteTime, ) DECLARE @LastDate DATETIME SET @LastDate =(SELECT DATEADD(dd,4,@FirstDate)) SELECT @FirstDate ,@LastDate
ALTER FUNCTION dbo.DEV_VW_WeekSerial (@YearNum int, @WeekNum int, @DayNum int) RETURNS Date AS BEGIN DECLARE @FirstDayYear As Date; SET @FirstDayYear= RETURN dateadd(d,(@DayNum-datepart(weekday,@FirstDayYear)),dateadd(week, @WeekNum-1,@FirstDayYear)) END
DECLARE @WeekNum INT = 12, @YearNum INT = 2014 ; SELECT DATEADD(wk, DATEDIFF(wk, 6, CAST(RTRIM(@YearNum * 10000 + 1 * 100 + 1) AS DATETIME)) + ( @WeekNum - 1 ), 6) AS [start_of_week], DATEADD(second, -1, DATEADD(day, DATEDIFF(day, 0, DATEADD(wk, DATEDIFF(wk, 5, CAST(RTRIM(@YearNum * 10000 + 1 * 100 + 1) AS DATETIME)) + ( @WeekNum + -1 ), 5)) + 1, 0)) AS [end_of_week] ;
start_of_week end_of_week ----------------------- ----------------------- 2014-03-16 00:00:00.000 2014-03-22 23:59:59.000
Declare @Year int ,@Week int ,@YearText varchar(4) set @Year = 2009 set @Week = 10 set @YearText = @Year print dateadd(day ,1 - datepart(dw, @YearText + + (@Week-1) * 7 ,@YearText +
CASE DATEPART(dw,<YourDateTimeField>) WHEN 1 THEN CONVERT(char(10), DATEADD(DD, -6, <YourDateTimeField>),126) + WHEN 2 THEN CONVERT(char(10), <YourDateTimeField>,126) + WHEN 3 THEN CONVERT(char(10), DATEADD(DD, -1, <YourDateTimeField>),126) + WHEN 4 THEN CONVERT(char(10), DATEADD(DD, -2, <YourDateTimeField>),126) + WHEN 5 THEN CONVERT(char(10), DATEADD(DD, -3, <YourDateTimeField>),126) + WHEN 6 THEN CONVERT(char(10), DATEADD(DD, -4, <YourDateTimeField>),126) + WHEN 7 THEN CONVERT(char(10), DATEADD(DD, -5, <YourDateTimeField>),126) + ELSE END AS Week_Range
DECLARE @Date date = SELECT @WeekNum = DATEPART(WEEK, @Date); SELECT @StartDate = DATEADD(DAY, -(DATEPART(WEEKDAY, DATEADD(YEAR, DATEDIFF(YEAR, 0, @Date), 0)) + 6), DATEADD(YEAR, DATEDIFF(YEAR, 0, @Date), 0)); SELECT CONVERT(nvarchar, CASE WHEN @WeekNum = 1 THEN CAST(DATEADD(YEAR, DATEDIFF(YEAR, 0, @Date), 0) AS date) ELSE DATEADD(DAY, 7 * @WeekNum, @StartDate) END, 101) AS StartOfWeek ,CONVERT(nvarchar, CASE WHEN @WeekNum = DATEPART(WEEK, DATEADD(DAY, -1, DATEADD(YEAR, DATEDIFF(YEAR, 0, @Date) + 1, 0))) THEN DATEADD(DAY, -1, DATEADD(YEAR, DATEDIFF(YEAR, 0, @Date) + 1, 0)) ELSE DATEADD(DAY, 7 * @WeekNum + 6, @StartDate) END, 101) AS EndOfWeek;
SELECT DATEADD(week, @weekNumber - 1, DATEADD(DAY, @@datefirst - DATEPART(weekday, CAST(YEAR(GETDATE()) AS VARCHAR) +
DECLARE @dayval int, @monthval int, @yearval int SET @dayval = 1 SET @monthval = 1 SET @yearval = 2011 DECLARE @dtDateSerial datetime SET @dtDateSerial = DATEADD(day, @dayval-1, DATEADD(month, @monthval-1, DATEADD(year, @yearval-1900, 0) ) ) DECLARE @weekno int SET @weekno = 53 DECLARE @weekstart datetime SET @weekstart = dateadd(day, 7 * (@weekno -1) - datepart (dw, @dtDateSerial), @dtDateSerial) DECLARE @weekend datetime SET @weekend = dateadd(day, 6, @weekstart) SELECT @weekstart, @weekend
select DateAdd(day,-DATEPart(DW,<Date>), <Date>) [FirstDayOfWeek] ,DateAdd(day,-DATEPart(DW,<Date>)+6, <Date>) [LastDayOfWeek] FROM <TABLE>
select convert(varchar(50), dateadd(dd, - datepart(dw, DATECOL) + 1, DATECOL), 101), convert(varchar(50), dateadd(dd, - datepart(dw, DATECOL) + 7, DATECOL), 101)
DECLARE @WeekNum int DECLARE @YearNum char(4) SELECT DATEADD(wk, DATEDIFF(wk, 6, SELECT DATEADD(wk, DATEDIFF(wk, 5,
BEGIN TRAN UPDATE OrderTable WITH ( ROWLOCK ) SET ProcessorID = @PROCID WHERE OrderID IN ( SELECT TOP ( 20 ) OrderID FROM OrderTable WITH ( ROWLOCK ) WHERE ProcessorID = 0) COMMIT TRAN SELECT OrderID, ProcessorID, etc... FROM OrderTable WHERE ProcessorID = @PROCID
UPDATE TOP (20) foo SET ProcessorID = @PROCID FROM OrderTable foo WITH (ROWLOCK, READPAST, UPDLOCK) WHERE ProcessorID = 0
COLUMN = Cat, Dog, Sparrow, Trout, Cow, Seahorse Does COLUMN contain Cat? YES Does COLUMN contain horse? NO Does COLUMN contain Sheep? NO
COLUMN = Mouse Does COLUMN contain Hare? NO Does COLUMN contain Mouse? YES
WHERE MyColumn LIKE OR MyColumn LIKE @search + OR MyColumn LIKE OR MyColumn = @search --single (good point by Cheran S in comment)
SELECT * FROM TABLENAME WHERE FIND_IN_SET(@search, column)
SELECT * FROM TABLENAME WHERE FIND_IN_SET(@search, REPLACE(column,
DECLARE @search VARCHAR(10); SET @search = WITH T(C) AS ( SELECT ) SELECT * FROM T WHERE
CREATE FUNCTION dbo.Split ( @RowData nvarchar(2000), @SplitOn nvarchar(5) ) RETURNS @RtnValue table ( Id int identity(1,1), Data nvarchar(100) ) AS BEGIN Declare @Cnt int Set @Cnt = 1 While (Charindex(@SplitOn,@RowData)>0) Begin Insert Into @RtnValue (data) Select Data = ltrim(rtrim(Substring(@RowData,1,Charindex(@SplitOn,@RowData)-1))) Set @RowData = Substring(@RowData,Charindex(@SplitOn,@RowData)+1,len(@RowData)) Set @Cnt = @Cnt + 1 End Insert Into @RtnValue (data) Select Data = ltrim(rtrim(@RowData)) Return END
select distinct a.id_column from MyTable a cross apply dbo.Split(A.MyCol, where b.Data=
SELECT * FROM TABLE_NAME WHERE ( LOCATE( LOCATE( );
where mylookuptablecolumn IN (myarrayorcommadelimitedarray)
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER FUNCTION [dbo].[DelimitedSplit] --===== Define I/O parameters (@pString NVARCHAR(MAX), @pDelimiter CHAR(1)) RETURNS TABLE WITH SCHEMABINDING AS RETURN --===== "Inline" CTE Driven "Tally Table" produces values from 0 up to 10,000... -- enough to cover VARCHAR(8000) WITH E1(N) AS ( SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 ), --10E+1 or 10 rows E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max cteTally(N) AS (--==== This provides the "base" CTE and limits the number of rows right up front -- for both a performance gain and prevention of accidental "overruns" SELECT TOP (ISNULL(DATALENGTH(@pString),0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4 ), cteStart(N1) AS (--==== This returns N+1 (starting position of each "element" just once for each delimiter) SELECT 1 UNION ALL -- does away with 0 base CTE, and the OR condition in one go! SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@pString,t.N,1) = @pDelimiter ), cteLen(N1,L1) AS(--==== Return start and length (for use in substring) SELECT s.N1, ---ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,8000) ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,50000) FROM cteStart s ) --===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found. SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1), Item = SUBSTRING(@pString, l.N1, l.L1) FROM cteLen l ;
WHERE [fieldname] IN (SELECT LTRIM(RTRIM(Item)) FROM [dbo].[DelimitedSplit](
declare @d varchar(1000)= set @d=replace(@d, print @d declare @d1 varchar(5000)= select union select union select where print @d1 exec (@d1)
alter login <loginname> with default_database = <dbname>;
use <dbname>; create user <username> from login <loginname>;
alter authorization on database::<dbname> to <loginname>;
USE [YourDB] GO CREATE USER [xyx] FOR LOGIN [xyz] GO ALTER USER [xyz] WITH DEFAULT_SCHEMA=[dbo] GO EXEC sp_addrolemember N GO
public static void AddUserToRoles(string Server, string UserID, string Password, string Database, string Role, string UserToRole) { SqlConnection connection = new SqlConnection(); connection.ConnectionString = "SERVER = " + Server + "; DATABASE = " + Database + " ; User ID = " + UserID + "; Pwd = " + Password; string sqlCreateDBQuery = " EXEC sp_addrolemember SqlCommand myCommand = new SqlCommand(sqlCreateDBQuery, connection); try { connection.Open(); myCommand.ExecuteNonQuery(); } catch{} finally { connection.Close(); } return; } public static void CreateUserInDatabase(string Server, string UserID, string Password, string Database, string NewUser, string FromLogin) { SqlConnection connection = new SqlConnection(); connection.ConnectionString = "SERVER = " + Server + "; DATABASE = "+ Database + " ; User ID = " + UserID + "; Pwd = " + Password; string sqlCreateDBQuery = "CREATE USER " + NewUser + " FROM LOGIN " + FromLogin; SqlCommand myCommand = new SqlCommand(sqlCreateDBQuery, connection); try { connection.Open(); myCommand.ExecuteNonQuery(); } catch { } finally { connection.Close(); } return; } public static void CreateLoginInSqlServer(string Server, string UserID, string Password, string NewLoginName, string NewLoginPassword) { SqlConnection connection = new SqlConnection(); connection.ConnectionString = "SERVER = " + Server + "; DATABASE = master; User ID = " + UserID + "; Pwd = " + Password; string sqlCreateDBQuery = "CREATE LOGIN [" + NewLoginName + "] WITH PASSWORD= ", CHECK_POLICY=OFF, DEFAULT_DATABASE=db_crs_0002, DEFAULT_LANGUAGE=[English];"; SqlCommand myCommand = new SqlCommand(sqlCreateDBQuery, connection); try { connection.Open(); myCommand.ExecuteNonQuery(); } catch { } finally { connection.Close(); } return; } public static void CreateNewDatabaseSqlserver(string Server, string NewDatabaseName, string UserID, string Password) { string sqlCreateDBQuery = " CREATE DATABASE " + NewDatabaseName; SqlConnection connection = new SqlConnection(); connection.ConnectionString = "SERVER = " + Server + "; DATABASE = master; User ID = " + UserID + "; Pwd = " + Password; SqlCommand myCommand = new SqlCommand(sqlCreateDBQuery, connection); try { connection.Open(); myCommand.ExecuteNonQuery(); } catch { } finally { connection.Close(); } return; }
SQLserverAPI.CreateNewDatabaseSqlserver("yourServer.cloudapp.net,1433", "databaseName", "AdminAPI", "password*"); SQLserverAPI.CreateLoginInSqlServer("yourServer.cloudapp.net,1433", "AdminAPI", "password*", "My_Login", "password*"); SQLserverAPI.CreateUserInDatabase("yourServer.cloudapp.net,1433", "AdminAPI", "password*", "databaseName", "User1", "My_Login"); SQLserverAPI.AddUserToRoles("yourServer.cloudapp.net,1433", "AdminAPI", "password*", "databaseName", "db_datareader", "User1"); SQLserverAPI.AddUserToRoles("yourServer.cloudapp.net,1433", "AdminAPI", "password*", "databaseName", "db_datawriter", "User1"); SQLserverAPI.AddUserToRoles("yourServer.cloudapp.net,1433", "AdminAPI", "password*", "databaseName", "db_owner", "User1");
Büdingen Aulendiebach Büdingen Büches Büdingen Calbach Büdingen Diebach Büdingen Dudenrod Büdingen Düdelsheim
Aulendiebach Büches Calbach Diebach Dudenrod Düdelsheim
SELECT REPLACE(stringColumnName, cityName, FROM YourTable
SELECT RIGHT (O.Ort, LEN(O.Ort) - LEN(C.CityName)-1) As WithoutCityName FROM tblOrtsteileGeo O JOIN dbo.Cities C ON C.foo = O.foo WHERE O.GKZ =
SELECT SUBSTRING(O.Ort, LEN(C.CityName) + 2, 8000) FROM dbo.tblOrtsteileGeo O JOIN dbo.Cities C ON C.foo = O.foo WHERE O.GKZ =
UPDATE yourtable SET field_or_column =REPLACE ( WHERE 1
select so.name, su.name, so.crdate from sysobjects so join sysusers su on so.uid = su.uid order by so.crdate
SELECT OBJECT_NAME(OBJECT_ID) AS DatabaseName, last_user_update,* FROM sys.dm_db_index_usage_stats WHERE database_id = DB_ID( AND OBJECT_ID=OBJECT_ID(
IF (condition) SELECT ... FROM Person WHERE ... ELSE IF (otherCondition) SELECT ... FROM Person JOIN ... ON ... WHERE ... ELSE IF (moreCondition) SELECT ... FROM Persons JOIN ... JOIN ... WHERE ...
(@group_id is null or g.group_id = @group_id) and (@address_id is null or a.address_id = @address_id)
DECLARE @SQL varchar(max) SET @SQL = IF NULLIF(@ADDRESSID,"") IS NULL SET @SQL = @SQL + " INNER JOIN ADDRESSES A ON P.AddressID = A.AddressID" EXEC sp_executesql @SQL, N
DECLARE @ColorParam varchar(500) SET @ColorParam = declare @Colors table ( Color NVARCHAR(50) PRIMARY KEY ) -- populate @Colors table by parsing the input param, -- table can be empty if there is nothing to parse, i.e.: no condition INSERT @Colors SELECT Value FROM dbo.Splitter(@ColorParam, SELECT m.Col1, c.Color FROM MainTable AS m FULL JOIN -- instead of using CROSS JOIN which won @Colors AS c ON 1 = 1 -- the trick WHERE (@ColorParam IS NULL OR c.Color = m.Color)
IF @AddressParameter IS NOT NULL BEGIN SELECT blah1, blah2 FROM OneTable INNER JOIN AddressTable WHERE .... -more code END ELSE... BEGIN END ...
WHERE Addresses.ID = COALESCE(@AddressID, Addresses.ID) AND Groups.ID = COALESCE(@GroupID, Groups.ID)
SELECT p.* FROM Parent AS p LEFT OUTER JOIN Child AS c ON p.Id = c.ParentId WHERE (@ConditionId IS NULL OR c.ConditionId = @ConditionId)
SELECT Customers.CustomerName, Customers.Country, Orders.OrderID FROM Customers LEFT JOIN Orders ON Customers.CustomerID=Orders.CustomerID WHERE Country= @MyOptionalCountryArg or @MyOptionalCountryArg is null;
SELECT * FROM Foo f INNER JOIN Bar b ON b.BarId = f.BarId; WHERE b.IsApproved = 1;
SELECT * FROM Foo f INNER JOIN Bar b ON (b.IsApproved = 1) AND (b.BarId = f.BarId);
SELECT * FROM Foo f LEFT OUTER JOIN Bar b ON (b.IsApproved = 1) AND (b.BarId = f.BarId);
SELECT * FROM Foo f LEFT OUTER JOIN Bar b ON (b.BarId = f.BarId) WHERE (b.IsApproved = 1);
SELECT * FROM Foo f LEFT OUTER JOIN Bar b ON (b.BarId = f.BarId) WHERE (b.IsApproved IS NULL OR b.IsApproved = 1);
SELECT * FROM Foo f INNER JOIN Bar b ON b.BarId = f.BarId WHERE b.IsApproved = 1;
declare @1 decimal(4,3) select @1 = 2.938 select PARSENAME(@1,1)
select x, ABS(x) - FLOOR(ABS(x)) from ( select 2.938 as x ) a
select x, SUBSTRING(cast(x as varchar(max)), charindex(cast(x as varchar(max)), from ( select 2.938 as x ) a
CASE WHEN 0 = CAST(RIGHT(Myfield, LEN( Myfield)-CHARINDEX(
SELECT FIRST_NAME.ORIGINAL_INPUT_DATA ,FIRST_NAME.TITLE ,FIRST_NAME.FIRST_NAME ,CASE WHEN 0 = CHARINDEX( THEN NULL --no more spaces? assume rest is the last name ELSE SUBSTRING( FIRST_NAME.REST_OF_NAME ,1 ,CHARINDEX( ) END AS MIDDLE_NAME ,SUBSTRING( FIRST_NAME.REST_OF_NAME ,1 + CHARINDEX( ,LEN(FIRST_NAME.REST_OF_NAME) ) AS LAST_NAME FROM ( SELECT TITLE.TITLE ,CASE WHEN 0 = CHARINDEX( THEN TITLE.REST_OF_NAME --No space? return the whole thing ELSE SUBSTRING( TITLE.REST_OF_NAME ,1 ,CHARINDEX( ) END AS FIRST_NAME ,CASE WHEN 0 = CHARINDEX( THEN NULL --no spaces @ all? then 1st name is all we have ELSE SUBSTRING( TITLE.REST_OF_NAME ,CHARINDEX( ,LEN(TITLE.REST_OF_NAME) ) END AS REST_OF_NAME ,TITLE.ORIGINAL_INPUT_DATA FROM ( SELECT --if the first three characters are in this list, --then pull it as a "title". otherwise return NULL for title. CASE WHEN SUBSTRING(TEST_DATA.FULL_NAME,1,3) IN ( THEN LTRIM(RTRIM(SUBSTRING(TEST_DATA.FULL_NAME,1,3))) ELSE NULL END AS TITLE --if you change the list, don --so much for the DRY prinicple... ,CASE WHEN SUBSTRING(TEST_DATA.FULL_NAME,1,3) IN ( THEN LTRIM(RTRIM(SUBSTRING(TEST_DATA.FULL_NAME,4,LEN(TEST_DATA.FULL_NAME)))) ELSE LTRIM(RTRIM(TEST_DATA.FULL_NAME)) END AS REST_OF_NAME ,TEST_DATA.ORIGINAL_INPUT_DATA FROM ( SELECT --trim leading & trailing spaces before trying to process --disallow extra spaces *within* the name REPLACE(REPLACE(LTRIM(RTRIM(FULL_NAME)), ,FULL_NAME AS ORIGINAL_INPUT_DATA FROM ( --if you use this, then replace the following --block with your actual table SELECT UNION SELECT UNION SELECT UNION SELECT UNION SELECT UNION SELECT UNION SELECT UNION SELECT NULL AS FULL_NAME UNION SELECT UNION SELECT UNION SELECT UNION SELECT UNION SELECT UNION SELECT ) RAW_DATA ) TEST_DATA ) TITLE ) FIRST_NAME
SELECT SUBSTR(fullname, 1, CHARINDEX( SUBSTR(fullname, CHARINDEX( FROM YourTable
First name: Jan Olav Middle name: Olsen Last name: Heggelien
First name: Jan Middle name: Olav Last name: Olsen Heggelien
select full_name, parsename(replace(full_name, parsename(replace(full_name, parsename(replace(full_name, from YourTableName
<? /* Name: nameparse.php Version: 0.2a Date: 030507 First: 030407 License: GNU General Public License v2 Bugs: If one of the words in the middle name is Ben (or St., for that matter), or any other possible last-name prefix, the name MUST be entered in last-name-first format. If the last-name parsing routines get ahold of any prefix, they tie up the rest of the name up to the suffix. i.e.: William Ben Carey would yield Carey, William Ben would yield This is a problem inherent in the prefix-parsing routines algorithm, and probably will not be fixed. It odd overlap between various languages. Just don */ function norm_str($string) { return trim(strtolower( str_replace( } function in_array_norm($needle,$haystack) { return in_array(norm_str($needle),$haystack); } function parse_name($fullname) { $titles = array( $prefices = array( $suffices = array( $pieces = explode( $n_pieces = count($pieces); switch($n_pieces) { case 1: $subp = explode( $n_subp = count($subp); for($i = 0; $i < $n_subp; $i++) { $curr = trim($subp[$i]); $next = trim($subp[$i+1]); if($i == 0 && in_array_norm($curr,$titles)) { $out[ continue; } if(!$out[ $out[ continue; } if($i == $n_subp-2 && $next && in_array_norm($next,$suffices)) { if($out[ $out[ } else { $out[ } $out[ break; } if($i == $n_subp-1) { if($out[ $out[ } else { $out[ } continue; } if(in_array_norm($curr,$prefices)) { if($out[ $out[ } else { $out[ } continue; } if($next == if($out[ $out[ } else { $out[ } continue; } if($out[ $out[ continue; } if($out[ $out[ } else { $out[ } } break; case 2: switch(in_array_norm($pieces[1],$suffices)) { case TRUE: $subp = explode( $n_subp = count($subp); for($i = 0; $i < $n_subp; $i++) { $curr = trim($subp[$i]); $next = trim($subp[$i+1]); if($i == 0 && in_array_norm($curr,$titles)) { $out[ continue; } if(!$out[ $out[ continue; } if($i == $n_subp-1) { if($out[ $out[ } else { $out[ } continue; } if(in_array_norm($curr,$prefices)) { if($out[ $out[ } else { $out[ } continue; } if($next == if($out[ $out[ } else { $out[ } continue; } if($out[ $out[ continue; } if($out[ $out[ } else { $out[ } } $out[ break; case FALSE: $subp = explode( $n_subp = count($subp); for($i = 0; $i < $n_subp; $i++) { $curr = trim($subp[$i]); $next = trim($subp[$i+1]); if($i == 0 && in_array_norm($curr,$titles)) { $out[ continue; } if(!$out[ $out[ continue; } if($i == $n_subp-2 && $next && in_array_norm($next,$suffices)) { if($out[ $out[ } else { $out[ } $out[ break; } if($i == $n_subp-1 && in_array_norm($curr,$suffices)) { $out[ continue; } if($out[ $out[ } else { $out[ } } $out[ break; } unset($pieces); break; case 3: $subp = explode( $n_subp = count($subp); for($i = 0; $i < $n_subp; $i++) { $curr = trim($subp[$i]); $next = trim($subp[$i+1]); if($i == 0 && in_array_norm($curr,$titles)) { $out[ continue; } if(!$out[ $out[ continue; } if($out[ $out[ } else { $out[ } } $out[ $out[ break; default: unset($pieces); break; } return $out; } ?>
Select DISTINCT NAMES , SUBSTRING(NAMES , 1, CHARINDEX( RTRIM(LTRIM(REPLACE(REPLACE(NAMES,SUBSTRING(NAMES , 1, CHARINDEX( REVERSE( LEFT( REVERSE(NAMES), CHARINDEX( From TABLENAME
create table parsname (fullname char(50), name1 char(30), name2 char(30), name3 char(30), name4 char(40)); insert into parsname (fullname) select fullname from ImportTable; update parsname set name1 = substring(fullname, 1, locate( fullname = ltrim(substring(fullname, locate( where locate( update parsname set name2 = substring(fullname, 1, locate( fullname = ltrim(substring(fullname, locate( where locate( update parsname set name3 = substring(fullname, 1, locate( fullname = ltrim(substring(fullname, locate( where locate( update parsname set name4 = substring(fullname, 1, locate( fullname = ltrim(substring(fullname, locate( where locate( select fullname as FirstName, union all select name1 as FirstName, name2 as MiddleName, fullname as LastName from parsname where name1 is not null and name3 is null
create procedure [dbo].[import_ParseName] ( @FullName nvarchar(max), @FirstName nvarchar(255) output, @MiddleName nvarchar(255) output, @LastName nvarchar(255) output ) as begin set @FirstName = set @MiddleName = set @LastName = set @FullName = ltrim(rtrim(@FullName)) declare @ReverseFullName nvarchar(max) set @ReverseFullName = reverse(@FullName) declare @lengthOfFullName int declare @endOfFirstName int declare @beginningOfLastName int set @lengthOfFullName = len(@FullName) set @endOfFirstName = charindex( set @beginningOfLastName = @lengthOfFullName - charindex( set @FirstName = case when @endOfFirstName <> 0 then substring(@FullName, 1, @endOfFirstName - 1) else end set @MiddleName = case when (@endOfFirstName <> 0 and @beginningOfLastName <> 0 and @beginningOfLastName > @endOfFirstName) then ltrim(rtrim(substring(@FullName, @endOfFirstName , @beginningOfLastName - @endOfFirstName))) else end set @LastName = case when @beginningOfLastName <> 0 then substring(@FullName, @beginningOfLastName + 1 , @lengthOfFullName - @beginningOfLastName) else end return end
DECLARE @FirstName nvarchar(255), @MiddleName nvarchar(255), @LastName nvarchar(255) EXEC [dbo].[import_ParseName] @FullName = N @FirstName = @FirstName OUTPUT, @MiddleName = @MiddleName OUTPUT, @LastName = @LastName OUTPUT print @FirstName print @MiddleName print @LastName output: Scott The Other Scott Kowalczyk
SELECT SUBSTRING(fullname, SUBSTRING(fullname, COALESCE(SUBSTRING(fullname, FROM public.person
use Text::BibTeX; use Text::BibTeX::Name; $name = "Dr. Mario Luis de Luigi Jr."; $name =~ s/^\s*([dm]rs?.?|miss)\s+ $dr=$1; $n=Text::BibTeX::Name->new($name); print join("\t", $dr, map "@{[ $n->part($_) ]}", qw(first von last jr)), "\n";
CREATE FUNCTION [dbo].[NameParser] ( @name nvarchar(100) ) RETURNS TABLE AS RETURN ( WITH prep AS ( SELECT original = @name, cleanName = REPLACE(REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(@name)), ) SELECT prep.original, aux.prefix, firstName.firstName, middleName.middleName, lastName.lastName, aux.suffix FROM prep CROSS APPLY ( SELECT prefix = CASE WHEN LEFT(prep.cleanName, 3) IN ( THEN LEFT(prep.cleanName, 2) WHEN LEFT(prep.cleanName, 4) IN ( THEN LEFT(prep.cleanName, 3) WHEN LEFT(prep.cleanName, 5) IN ( THEN LEFT(prep.cleanName, 4) ELSE END, suffix = CASE WHEN RIGHT(prep.cleanName, 3) IN ( THEN RIGHT(prep.cleanName, 2) WHEN RIGHT(prep.cleanName, 4) IN ( THEN RIGHT(prep.cleanName, 3) ELSE END ) aux CROSS APPLY ( SELECT baseName = LTRIM(RTRIM(SUBSTRING(prep.cleanName, LEN(aux.prefix) + 1, LEN(prep.cleanName) - LEN(aux.prefix) - LEN(aux.suffix)))), numParts = (SELECT COUNT(1) FROM STRING_SPLIT(LTRIM(RTRIM(SUBSTRING(prep.cleanName, LEN(aux.prefix) + 1, LEN(prep.cleanName) - LEN(aux.prefix) - LEN(aux.suffix)))), ) core CROSS APPLY ( SELECT firstName = CASE WHEN core.numParts <= 1 THEN core.baseName ELSE LEFT(core.baseName, CHARINDEX( END ) firstName CROSS APPLY ( SELECT remainder = CASE WHEN core.numParts <= 1 THEN ELSE LTRIM(SUBSTRING(core.baseName, LEN(firstName.firstName) + 1, 999999)) END ) work1 CROSS APPLY ( SELECT middleName = CASE WHEN core.numParts <= 2 THEN ELSE LEFT(work1.remainder, CHARINDEX( END ) middleName CROSS APPLY ( SELECT lastName = CASE WHEN core.numParts <= 1 THEN ELSE LTRIM(SUBSTRING(work1.remainder, LEN(middleName.middleName) + 1, 999999)) END ) lastName ) GO SELECT * FROM dbo.NameParser( SELECT * FROM dbo.NameParser( SELECT * FROM dbo.NameParser( SELECT * FROM dbo.NameParser( SELECT * FROM dbo.NameParser( SELECT * FROM dbo.NameParser(
SELECT TOP 100 [PRIMARY_NDX_Col1], [NEW_Col], --QUERY EXECUTES SUCCESSFULLY, BUT THIS IS UNDERLINED RED AS AN INVALID COLUMN [Col3] FROM [dbo].[MyTable]
UPDATE [UKiPFS].[ SET [Scope] = 1 FROM [UKiPFS].[ INNER JOIN [UKiPFS].[Scope] AS b ON a.[Flow] = b.[Flow] AND a.Entity = b.Entity WHERE b.In_Scope =
Declare @SumVal int; Select @SumVal=Sum(Amount) From Expense; Print @SumVal;
DECLARE @xmltmp xml = (SELECT * FROM table FOR XML AUTO) PRINT CONVERT(NVARCHAR(MAX), @xmltmp)
DECLARE @name nvarchar(128) DECLARE cur CURSOR FOR SELECT name FROM sys.database_principals OPEN cur FETCH NEXT FROM cur INTO @name; WHILE @@FETCH_STATUS = 0 BEGIN PRINT @name FETCH NEXT FROM cur INTO @name; END CLOSE cur; DEALLOCATE cur;
ALTER procedure [dbo].[PrintSQLResults] @query nvarchar(MAX), @numberToDisplay int = 10, @padding int = 20 as SET NOCOUNT ON; SET ANSI_WARNINGS ON; declare @cols nvarchar(MAX), @displayCols nvarchar(MAX), @sql nvarchar(MAX), @printableResults nvarchar(MAX), @NewLineChar AS char(2) = char(13) + char(10), @Tab AS char(9) = char(9); if exists (select * from tempdb.sys.tables where name = set @query = REPLACE(@query, --print @query exec(@query); select ROW_NUMBER() OVER (ORDER BY (select Null)) AS ID12345XYZ, * into from drop table select name into from tempdb.sys.columns where object_id = object_id( select @cols = stuff(( (select FROM where name != FOR XML PATH( ,1,0, select @displayCols = stuff(( (select space(1) + LEFT(name + space(@padding), @padding) as [text()] FROM where name != FOR XML PATH( ,1,0, DECLARE @tableCount int = (select count(*) from DECLARE @i int = 1, @ii int = case when @tableCount < @numberToDisplay then @tableCount else @numberToDisplay end; print @displayCols -- header While @i <= @ii BEGIN set @sql = N --print @sql execute sp_executesql @sql, N print @printableResults SET @i += 1; END
ALTER procedure [dbo].[PrintSQLResults] @query nvarchar(MAX), @numberToDisplay int = 10, @padding int = 20 as SET NOCOUNT ON; SET ANSI_WARNINGS ON; declare @cols nvarchar(MAX), @displayCols nvarchar(MAX), @sql nvarchar(MAX), @printableResults nvarchar(MAX), @NewLineChar AS char(2) = char(13) + char(10), @Tab AS char(9) = char(9); if exists (select * from tempdb.sys.tables where name = set @query = REPLACE(@query, --print @query exec(@query); select ROW_NUMBER() OVER (ORDER BY (select Null)) AS ID12345XYZ, * into from drop table select name into from tempdb.sys.columns where object_id = object_id( select @cols = stuff(( (select FROM where name != FOR XML PATH( ,1,0, select @displayCols = stuff(( (select space(1) + LEFT(name + space(@padding), @padding) as [text()] FROM where name != FOR XML PATH( ,1,0, DECLARE @tableCount int = (select count(*) from DECLARE @i int = 1, @ii int = case when @tableCount < @numberToDisplay then @tableCount else @numberToDisplay end; print @displayCols -- header While @i <= @ii BEGIN set @sql = N --print @sql execute sp_executesql @sql, N print @printableResults SET @i += 1; END
ALTER procedure [dbo].[PrintSQLResults] @query nvarchar(MAX), @numberToDisplay int = 10, @padding int = 20 as SET NOCOUNT ON; SET ANSI_WARNINGS ON; declare @cols nvarchar(MAX), @displayCols nvarchar(MAX), @sql nvarchar(MAX), @printableResults nvarchar(MAX), @NewLineChar AS char(2) = char(13) + char(10), @Tab AS char(9) = char(9); if exists (select * from tempdb.sys.tables where name = set @query = REPLACE(@query, --print @query exec(@query); select ROW_NUMBER() OVER (ORDER BY (select Null)) AS ID12345XYZ, * into from drop table select name into from tempdb.sys.columns where object_id = object_id( select @cols = stuff(( (select FROM where name != FOR XML PATH( ,1,0, select @displayCols = stuff(( (select space(1) + LEFT(name + space(@padding), @padding) as [text()] FROM where name != FOR XML PATH( ,1,0, DECLARE @tableCount int = (select count(*) from DECLARE @i int = 1, @ii int = case when @tableCount < @numberToDisplay then @tableCount else @numberToDisplay end; print @displayCols -- header While @i <= @ii BEGIN set @sql = N --print @sql execute sp_executesql @sql, N print @printableResults SET @printableResults = null; SET @i += 1; END
DECLARE @PrintVarchar nvarchar(max) = (Select Sum(Amount) From Expense) PRINT DECLARE @PrintInt int = (Select Sum(Amount) From Expense) PRINT @PrintInt
SELECT sj.name , sja.* FROM msdb.dbo.sysjobactivity AS sja INNER JOIN msdb.dbo.sysjobs AS sj ON sja.job_id = sj.job_id WHERE sja.start_execution_date IS NOT NULL AND sja.stop_execution_date IS NULL
SELECT ja.job_id, j.name AS job_name, ja.start_execution_date, ISNULL(last_executed_step_id,0)+1 AS current_executed_step_id, Js.step_name FROM msdb.dbo.sysjobactivity ja LEFT JOIN msdb.dbo.sysjobhistory jh ON ja.job_history_id = jh.instance_id JOIN msdb.dbo.sysjobs j ON ja.job_id = j.job_id JOIN msdb.dbo.sysjobsteps js ON ja.job_id = js.job_id AND ISNULL(ja.last_executed_step_id,0)+1 = js.step_id WHERE ja.session_id = ( SELECT TOP 1 session_id FROM msdb.dbo.syssessions ORDER BY agent_start_date DESC ) AND start_execution_date is not null AND stop_execution_date is null;
/**************************************************************** --This SQL will take a list of SQL Agent jobs (names must match), --start them so they --monitor them, not quitting until all jobs have completed. -- --In essence, it -- --Code from http: -- ****************************************************************/ SET NOCOUNT ON -------- BEGIN ITEMS THAT NEED TO BE CONFIGURED -------- --The amount of time to wait before checking again --to see if the jobs are still running. --Should be in hh:mm:ss format. DECLARE @WaitDelay VARCHAR(8) = --Job timeout. Eg, if the jobs are running longer than this, kill them. DECLARE @TimeoutMinutes INT = 240 DECLARE @JobsToRunTable TABLE ( JobName NVARCHAR(128) NOT NULL, JobID UNIQUEIDENTIFIER NULL, Running INT NULL ) --Insert the names of the SQL jobs here. Last two values should always be NULL at this point. --Names need to match exactly, so best to copy/paste from the SQL Server Agent job name. INSERT INTO @JobsToRunTable (JobName, JobID, Running) VALUES ( INSERT INTO @JobsToRunTable (JobName, JobID, Running) VALUES ( INSERT INTO @JobsToRunTable (JobName, JobID, Running) VALUES ( -------- NOTHING FROM HERE DOWN SHOULD NEED TO BE CONFIGURED -------- DECLARE @ExecutionStatusTable TABLE ( JobID UNIQUEIDENTIFIER PRIMARY KEY, -- Job ID which will be a guid LastRunDate INT, LastRunTime INT, -- Last run date and time NextRunDate INT, NextRunTime INT, -- Next run date and time NextRunScheduleID INT, -- an internal schedule id RequestedToRun INT, RequestSource INT, RequestSourceID VARCHAR(128), Running INT, -- 0 or 1, 1 means the job is executing CurrentStep INT, -- which step is running CurrentRetryAttempt INT, -- retry attempt JobState INT -- 0 = Not idle or suspended, 1 = Executing, 2 = Waiting For Thread, -- 3 = Between Retries, 4 = Idle, 5 = Suspended, -- 6 = WaitingForStepToFinish, 7 = PerformingCompletionActions ) DECLARE @JobNameToRun NVARCHAR(128) = NULL DECLARE @IsJobRunning BIT = 1 DECLARE @AreJobsRunning BIT = 1 DECLARE @job_owner sysname = SUSER_SNAME() DECLARE @JobID UNIQUEIDENTIFIER = null DECLARE @StartDateTime DATETIME = GETDATE() DECLARE @CurrentDateTime DATETIME = null DECLARE @ExecutionStatus INT = 0 DECLARE @MaxTimeExceeded BIT = 0 --Loop through and start every job DECLARE dbCursor CURSOR FOR SELECT JobName FROM @JobsToRunTable OPEN dbCursor FETCH NEXT FROM dbCursor INTO @JobNameToRun WHILE @@FETCH_STATUS = 0 BEGIN EXEC [msdb].[dbo].sp_start_job @JobNameToRun FETCH NEXT FROM dbCursor INTO @JobNameToRun END CLOSE dbCursor DEALLOCATE dbCursor print print print --Debug (if needed) --SELECT * FROM @JobsToRunTable WHILE 1=1 AND @AreJobsRunning = 1 BEGIN --This has to be first with the delay to make sure the jobs --have time to actually start up and are recognized as WAITFOR DELAY @WaitDelay --Reset for each loop iteration SET @AreJobsRunning = 0 --Get the currently executing jobs by our user name INSERT INTO @ExecutionStatusTable EXECUTE [master].[dbo].xp_sqlagent_enum_jobs 1, @job_owner --Debug (if needed) --SELECT --select every job to see if it DECLARE dbCursor CURSOR FOR SELECT x.[Running], x.[JobID], sj.name FROM @ExecutionStatusTable x INNER JOIN [msdb].[dbo].sysjobs sj ON sj.job_id = x.JobID INNER JOIN @JobsToRunTable jtr on sj.name = jtr.JobName OPEN dbCursor FETCH NEXT FROM dbCursor INTO @IsJobRunning, @JobID, @JobNameToRun --Debug (if needed) --SELECT x.[Running], x.[JobID], sj.name -- FROM @ExecutionStatusTable x -- INNER JOIN msdb.dbo.sysjobs sj ON sj.job_id = x.JobID -- INNER JOIN @JobsToRunTable jtr on sj.name = jtr.JobName WHILE @@FETCH_STATUS = 0 BEGIN --bitwise operation to see if the loop should continue SET @AreJobsRunning = @AreJobsRunning | @IsJobRunning UPDATE @JobsToRunTable SET Running = @IsJobRunning, JobID = @JobID WHERE JobName = @JobNameToRun --Debug (if needed) --SELECT SET @CurrentDateTime=GETDATE() IF @IsJobRunning = 1 BEGIN -- Job is running or finishing (not idle) IF DATEDIFF(mi, @StartDateTime, @CurrentDateTime) > @TimeoutMinutes BEGIN print print @JobNameToRun + --Stop the job EXEC [msdb].[dbo].sp_stop_job @job_name = @JobNameToRun END ELSE BEGIN print @JobNameToRun + END END IF @IsJobRunning = 0 BEGIN --Job isn print print @JobNameToRun + END FETCH NEXT FROM dbCursor INTO @IsJobRunning, @JobID, @JobNameToRun END -- WHILE @@FETCH_STATUS = 0 CLOSE dbCursor DEALLOCATE dbCursor --Clear out the table for the next loop iteration DELETE FROM @ExecutionStatusTable print END -- WHILE 1=1 AND @AreJobsRunning = 1 SET @CurrentDateTime = GETDATE() print print CONVERT(VARCHAR(25),DATEDIFF(mi, @StartDateTime, @CurrentDateTime)) +
SELECT top 100 * FROM msdb..sysjobs WHERE job_id IN (0x9DAD1B38EB345D449EAFA5C5BFDC0E45, 0xC00A0A67D109B14897DD3DFD25A50B80, 0xC92C66C66E391345AE7E731BFA68C668)
DECLARE @StepCount INT SELECT @StepCount = COUNT(1) FROM msdb.dbo.sysjobsteps WHERE job_id = SELECT [JobName] ,[JobStepID] ,[JobStepName] ,[JobStepStatus] ,[RunDateTime] ,[RunDuration] FROM ( SELECT j.[name] AS [JobName] ,Jh.[step_id] AS [JobStepID] ,jh.[step_name] AS [JobStepName] ,CASE WHEN jh.[run_status] = 0 THEN WHEN jh.[run_status] = 1 THEN WHEN jh.[run_status] = 2 THEN WHEN jh.[run_status] = 3 THEN WHEN jh.[run_status] = 4 THEN WHEN jh.[run_status] = 5 THEN ELSE END AS [JobStepStatus] ,msdb.dbo.agent_datetime(run_date, run_time) AS [RunDateTime] ,CAST(jh.[run_duration]/10000 AS VARCHAR) + ,ROW_NUMBER() OVER ( PARTITION BY jh.[run_date] ORDER BY jh.[run_date] DESC, jh.[run_time] DESC ) AS [RowNumber] FROM msdb.[dbo].[sysjobhistory] jh INNER JOIN msdb.[dbo].[sysjobs] j ON jh.[job_id] = j.[job_id] WHERE j.[name] = AND jh.[step_id] > 0 AND CAST(RTRIM(run_date) AS DATE) = CAST(GETDATE() AS DATE) --Current Date ) A WHERE [RowNumber] <= @StepCount AND [JobStepStatus] =
select so.name,so.description,so.enabled,CASE WHEN sh.[run_status] = 0 THEN WHEN sh.[run_status] = 1 THEN WHEN sh.[run_status] = 2 THEN WHEN sh.[run_status] = 3 THEN WHEN sh.[run_status] = 4 THEN WHEN sh.[run_status] = 5 THEN ELSE LEFT JOIN msdb.dbo.sysjobs so on sh.job_id = so.job_id where sh.run_status = 0 and sh.run_date = CONVERT(VARCHAR(10), GETDATE(), 112) order by sh.instance_id desc
select id, sales_person_id, product_type, product_id, sale_amount from Sales_Log where 1 = row_number() over(partition by sales_person_id, product_type, product_id order by sale_amount desc)
with Best_Sales as ( select id, sales_person_id, product_type, product_id, sale_amount, row_number() over (partition by sales_person_id, product_type, product_id order by sales_amount desc) rank from Sales_log ) select id, sales_person_id, product_type, product_id, sale_amount from Best_Sales where rank = 1
CREATE TABLE T1 ( col1 CHAR(1) PRIMARY KEY ) INSERT INTO T1 VALUES(
SELECT col1 FROM T1 WHERE ROW_NUMBER() OVER (ORDER BY col1) <= 3 AND col1 >
select id, sales_person_id, product_type, product_id, sale_amount from ( select id, sales_person_id, product_type, product_id, sale_amount, row_number() over(partition by sales_person_id, product_type, product_id order by sale_amount desc) rn from Sales_Log ) sl where rn = 1
CREATE TABLE INSERT INTO SELECT Id FROM WHERE Id = 1002 AND ROW_NUMBER() OVER(ORDER BY Id) = 1;
SELECT Id FROM WHERE Id = 1002 QUALIFY ROW_NUMBER() OVER(ORDER BY Id) = 1;
select row, id, sales_person_id, product_type, product_id, sale_amount from ( select row_number() over(partition by sales_person_id, product_type, product_id order by sale_amount desc) AS row, id, sales_person_id, product_type, product_id, sale_amount from Sales_Log ) a where row = 1
declare @Person table ( PersonID int identity, PersonName varchar(8)); insert into @Person values ( declare @Orders table ( OrderID int identity, PersonID int, OrderName varchar(8)); insert into @Orders values (1, --Select -- p.PersonName --, o.OrderName --, row_number() over(partition by o.PersonID order by o.OrderID) --from @Person p -- join @Orders o on p.PersonID = o.PersonID --where row_number() over(partition by o.PersonID order by o.orderID) = 2 -- yields: --Msg 4108, Level 15, State 1, Line 15 --Windowed functions can only appear in the SELECT or ORDER BY clauses. ; with a as ( Select p.PersonName , o.OrderName , row_number() over(partition by o.PersonID order by o.OrderID) as rnk from @Person p join @Orders o on p.PersonID = o.PersonID ) select * from a where rnk >= 2 -- only orders after the first one.
select * from Sales_Log sl where sl.id = ( Select Top 1 id from Sales_Log sl2 where sales_person_id = sl.sales_person_id and product_type = sl.product_type and product_id = sl.product_id order by sale_amount desc )
SELECT DISTINCT TOP list FROM JOIN ON / APPLY / PIVOT / UNPIVOT WHERE GROUP BY WITH CUBE / WITH ROLLUP HAVING ORDER BY OFFSET-FETCH
----- Relational result 1. FROM 1.1. ON JOIN / APPLY / PIVOT / UNPIVOT 2. WHERE 3. GROUP BY 3.1. WITH CUBE / WITH ROLLUP 4. HAVING ---- After the HAVING step the Underlying Query Result is ready 5. SELECT 5.1. SELECT list 5.2. DISTINCT ----- Relational result ----- Non-relational result (a cursor) 6. ORDER BY 7. TOP / OFFSET-FETCH ----- Non-relational result (a cursor)
Msg 4108, Level 15, State 1, … Windowed functions can only appear in the SELECT or ORDER BY clauses.
CREATE PROCEDURE dbo.KeepsIsolation AS BEGIN PRINT DBCC USEROPTIONS; END GO CREATE PROCEDURE dbo.ChangesIsolation AS BEGIN PRINT SET TRANSACTION ISOLATION LEVEL READ COMMITTED; DBCC USEROPTIONS; END GO SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; DBCC USEROPTIONS; EXEC dbo.KeepsIsolation; DBCC USEROPTIONS; EXEC dbo.ChangesIsolation; -- demonstrates that isolation level restored to REPEATABLE READ after exiting the procedure DBCC USEROPTIONS;
ALTER PROCEDURE [dbo].[AssetLibrary_AssetDelete] ( @AssetID AS uniqueidentifier ) AS SET NOCOUNT ON SET TRANSACTION ISOLATION LEVEL READ COMMITTED EXEC AssetLibrary_AssetDeleteAttributes @AssetID EXEC AssetLibrary_AssetDeleteComponents @AssetID EXEC AssetLibrary_AssetDeleteAgreements @AssetID EXEC AssetLibrary_AssetDeleteMaintenance @AssetID DELETE FROM AssetLibrary_Asset WHERE AssetLibrary_Asset.AssetID = @AssetID RETURN (@@ERROR)
Create Proc SP1 ( @ID int, @Name varchar(40) -- etc parameter list, If you don ) AS BEGIN -- Here we have some opereations -- If there is any Error Before Executing SP2 then SP will stop executing. Exec SP2 @ID,@Name,@SomeID OUTPUT -- ,etc some other parameter also we can use OutPut parameters like -- @SomeID is useful for some other operations for condition checking insertion etc. -- If you have any Error in you SP2 then also it will stop executing. -- If you want to do any other operation after executing SP2 that we can do here. END
ALTER PROCEDURE SP1 AS BEGIN Declare c1 cursor.... open c1 fetch next from c1 ... while @@fetch_status = 0 Begin ... Fetch Next from c1 end close c1 deallocate c1 exec sp2 end
-- ============================================= -- Create inline function (IF) -- ============================================= IF EXISTS (SELECT * FROM sysobjects WHERE name = N DROP FUNCTION <inline_function_name, sysname, test_function> GO CREATE FUNCTION <inline_function_name, sysname, test_function> (<@param1, sysname, @p1> <data_type_for_param1, , int>, <@param2, sysname, @p2> <data_type_for_param2, , char>) RETURNS TABLE AS RETURN SELECT @p1 AS c1, @p2 AS c2 GO -- ============================================= -- Example to execute function -- ============================================= SELECT * FROM <owner, , dbo>.<inline_function_name, sysname, test_function> (<value_for_@param1, , 1>, <value_for_@param2, , GO
Create PROCEDURE MultipleOutParameter @Input int, @Out1 int OUTPUT, @Out2 int OUTPUT AS BEGIN Select @Out1 = @Input + 1 Select @Out2 = @Input + 2 Select , -- Return can be used to get even more (afaik only int) values Return(@Out1+@Out2+@Input) END
DECLARE @GetReturnResult int, @GetOut1 int, @GetOut2 int EXEC @GetReturnResult = MultipleOutParameter @Input = 1, @Out1 = @GetOut1 OUTPUT, @Out2 = @GetOut2 OUTPUT
Select @GetReturnResult as ReturnResult, @GetOut1 as Out_1, @GetOut2 as Out_2
Select MAX(cpe.createdon) As MaxDate, cpe.fmgcms_cpeclaimid from Filteredfmgcms_claimpaymentestimate cpe where cpe.createdon < group by cpe.fmgcms_cpeclaimid
Select MAX(cpe.createdon) As MaxDate, cpe.fmgcms_cpeclaimid, cpe.fmgcms_claimid from Filteredfmgcms_claimpaymentestimate cpe where cpe.createdon < group by cpe.fmgcms_cpeclaimid
create table dbo.some_claims_table ( claim_id int not null , group_id int not null , date_created datetime not null , constraint some_table_PK primary key ( claim_id ) , constraint some_table_AK01 unique ( group_id , claim_id ) , constraint some_Table_AK02 unique ( group_id , date_created ) , )
select group_id , date_created = max( date_created ) from dbo.claims_table group by group_id
select * from dbo.claims_table t join ( select group_id , date_created = max( date_created ) from dbo.claims_table group by group_id ) x on x.group_id = t.group_id and x.date_created = t.date_created
select * from ( select MyPK, fmgcms_cpeclaimid, createdon, Rank() over (Partition BY fmgcms_cpeclaimid order by createdon DESC) as Rank from Filteredfmgcms_claimpaymentestimate where createdon < ) tmp where Rank = 1
SELECT cpe.* FROM Filteredfmgcms_claimpaymentestimate cpe INNER JOIN (yourQuery) AS lookup ON lookup.MaxData = cpe.createdOn AND lookup.fmgcms_cpeclaimid = cpe.fmgcms_cpeclaimid
WITH sequenced_data AS ( SELECT *, ROW_NUMBER() OVER (PARITION BY fmgcms_cpeclaimid ORDER BY CreatedOn DESC) AS sequence_id FROM Filteredfmgcms_claimpaymentestimate WHERE createdon < ) SELECT * FROM sequenced_data WHERE sequence_id = 1
Select cpe1.PK, cpe2.MaxDate, cpe1.fmgcms_cpeclaimid from Filteredfmgcms_claimpaymentestimate cpe1 INNER JOIN ( select MAX(createdon) As MaxDate, fmgcms_cpeclaimid from Filteredfmgcms_claimpaymentestimate group by fmgcms_cpeclaimid ) cpe2 on cpe1.fmgcms_cpeclaimid = cpe2.fmgcms_cpeclaimid and cpe1.createdon = cpe2.MaxDate where cpe1.createdon <
SELECT * FROM SomeTable as ST CROSS JOIN TypeRange as TR WHERE ST.MyNumber BETWEEN TR.IntMin AND TR.IntMax
DECLARE @test DATETIME SET @test = GETDATE() -- or any other date SELECT DATEADD(month, ((YEAR(@test) - 1900) * 12) + MONTH(@test), -1)
dateadd(day, -1, dateadd(month, 1, dateadd(day, 1 - day(date), date)))
SET @dtDate = "your date" DATEADD(s,-1,DATEADD(mm, DATEDIFF(m,0,@dtDate)+1,0))
SELECT DATEADD(MONTH, 1, @x) -- Add a month to the supplied date @x
SELECT DATEADD(DAY, 0 - DAY(@x), @x) -- Get last day of month previous to the supplied date @x
DECLARE @x DATE = SELECT DAY(DATEADD(DAY, 0 - DAY(DATEADD(MONTH, 1, @x)), DATEADD(MONTH, 1, @x)))
dateadd(day, -1, dateadd(month, 1, cast(month( cast(year(
DECLARE @currentDate DATE = GETDATE() SELECT EOMONTH (@currentDate) AS CurrentMonthED
DECLARE @currentDate DATE = GETDATE() SELECT EOMONTH (@currentDate, 1 ) AS NextMonthED
SELECT DATEADD(MONTH,1,GETDATE())- day(DATEADD(MONTH,1,GETDATE()))
Declare @a date =dateadd(mm, Datediff(mm,0,getdate()),0) Print( Print(@a) Print( set @a = dateadd(mm, Datediff(mm,0,getdate())+1,-1) Print( Print(@a) Print( Print( set @a = dateadd(mm, Datediff(mm,0,getdate())-1,0) Print(@a) Print( Print( set @a = dateadd(mm, Datediff(mm,0,getdate()),-1) Print(@a) Print( Print( set @a = dateadd(ww, Datediff(ww,0,getdate()),0) Print(@a) Print( Print( set @a = dateadd(ww, Datediff(ww,0,getdate())+1,-1) Print(@a) Print( Print( set @a = dateadd(ww, Datediff(ww,0,getdate())-1,0) Print(@a) Print( Print( set @a = dateadd(ww, Datediff(ww,0,getdate()),-1) Print(@a)
where DATE01 between dateadd(month,-1,dateadd(day,1,dateadd(day,-day(today()),today()))) and dateadd(day,-day(today()),today())
where month(DATE01) = month(dateadd(month,-1,today())) and year(DATE01) = year(dateadd(month,-1,today()))
Declare @GivenDate datetime SET @GivenDate = GETDATE() Select DATEADD(MM,DATEDIFF(MM, 0, @GivenDate),0) --First day of the month Select DATEADD(MM,DATEDIFF(MM, -1, @GivenDate),-1) --Last day of the month
select DATEADD(DAY,-1,DATEADD(MONTH,1,DATEADD(day,(0-(DATEPART(dd,
select dateadd(dd,-1,dateadd(mm,datediff(mm,0,YOUR_DATE)+1,0))
declare @dt datetime; set @dt = SELECT DATEADD(month, DATEDIFF(month, set @dt = SELECT DATEADD(month, DATEDIFF(month, set @dt = SELECT DATEADD(month, DATEDIFF(month,
CREATE Function [dbo].[fn_GetLastDate] ( @date datetime ) returns datetime as begin declare @result datetime select @result = CHOOSE(month(@date), DATEADD(DAY, 31 -day(@date), @date), IIF(YEAR(@date) % 4 = 0, DATEADD(DAY, 29 -day(@date), @date), DATEADD(DAY, 28 -day(@date), @date)), DATEADD(DAY, 31 -day(@date), @date) , DATEADD(DAY, 30 -day(@date), @date), DATEADD(DAY, 31 -day(@date), @date), DATEADD(DAY, 30 -day(@date), @date), DATEADD(DAY, 31 -day(@date), @date), DATEADD(DAY, 31 -day(@date), @date), DATEADD(DAY, 30 -day(@date), @date), DATEADD(DAY, 31 -day(@date), @date), DATEADD(DAY, 30 -day(@date), @date), DATEADD(DAY, 31 -day(@date), @date)) return convert(date, @result) end
select [dbo].[fn_GetLastDate]( select [dbo].[fn_GetLastDate](GETDATE())
DECLARE @SelectedDate DATE = GETDATE() SELECT DATEADD(DAY, - DAY(@SelectedDate), DATEADD(MONTH, 1 , @SelectedDate)) EndOfMonth
---Start/End of previous Month Declare @StartDate datetime, @EndDate datetime set @StartDate = DATEADD(month, DATEDIFF(month, 0, GETDATE())-1,0) set @EndDate = EOMONTH (DATEADD(month, DATEDIFF(month, 0, GETDATE())-1,0)) SELECT @StartDate,@EndDate
Select MonthEndDate MED, SUM(GrossBalance/1000000) GrossBalance, PortfolioRename PR into testDynamic from Risk_PortfolioOverview Group By MonthEndDate, PortfolioRename
select * from table where DATEADD(ms, -DATEPART(ms, date), date) >
SELECT * FROM table WHERE datetime > CONVERT(DATETIME, CONVERT(VARCHAR(20), CONVERT(DATETIME,
DECLARE @date DATETIME SET @date = GETDATE() SELECT CONVERT(DATETIME, CONVERT(VARCHAR(20), @date, 120))
WHERE ...[Time_stamp] >= CAST(CONCAT(@YYYYMMDDHHTTSS, ...[Time_stamp] <= CAST(CONCAT(@YYYYMMDDHHTTSS,
Declare @MyInt integer Set @MyInt = 123 Declare @StrLen TinyInt Set @StrLen = 8 Select Replace(Str(@MyInt, @StrLen),
DECLARE @iVal int = 1 select REPLACE(STR(@iVal, 8, 0),
CREATE FUNCTION CIntToChar(@intVal Int, @intLen Int) RETURNS nvarchar(24) AS BEGIN IF @intlen > 24 SET @intlen = 24 RETURN REPLICATE( + CONVERT(nvarchar(24),@intVal) END
DECLARE @INT INT DECLARE @UNPADDED VARCHAR(3) DECLARE @PADDED VARCHAR(3) SET @INT = 2 SET @UNPADDED = CONVERT(VARCHAR(3),@INT) SET @PADDED = REPLICATE( SELECT @INT, @UNPADDED, @PADDED
SET @padded = RIGHT( + convert(varchar(30), @myInt), 8)
DECLARE @iVal int set @iVal = -1 select case when @ival >= 0 then right(replicate( else end
declare @_int int set @_int = 1 while @_int < 100 Begin select BldgName + + set @_int = @_int +1 End
declare @int int set @int = 1 declare @string varchar(max) set @string = cast(@int as varchar(max)) declare @length int set @length = len(@string) declare @MAX int set @MAX = 8 if @length < @MAX begin declare @zeros varchar(8) set @zeros = declare @counter int set @counter = 0 while (@counter < (@MAX - @length)) begin set @zeros = @zeros + set @counter = @counter + 1 end set @string = @zeros + @string end print @string
SELECT REPLACE(REVERSE( CONVERT(CHAR(5 ) , REVERSE(CONVERT(VARCHAR(100), @MyInt))) ),
IF @GuidParam = CAST(CAST(0 AS BINARY) AS UNIQUEIDENTIFIER) BEGIN --Guid is empty END
Declare @EmptyGuid uniqueidentifier Set @EmptyGuid =
DECLARE @MyId as UNIQUEIDENTIFIER = (SELECT Id FROM dbo.MyTable WHERE ...) IF @MyId IS NULL BEGIN RAISERROR ( RETURN END
DECLARE @IAMNULL VARCHAR DECLARE @IAMNOTNULL VARCHAR SET @IAMNOTNULL = SELECT ISNULL(@IAMNULL, @IAMNOTNULL) --Output: DECLARE @IAMNULLALSO VARCHAR SELECT COALESCE(@IAMNULL, @IAMNULLALSO, @IAMNOTNULL) --Output:
select COALESCE ( ProgramID , InterimProgramID ) as
SELECT ProgramID FROM a_table WHERE ProgramID IS NOT NULL UNION SELECT InterimProgramID AS ProgramID FROM a_table WHERE ProgramID IS NULL;
DECLARE @p_date DATETIME SET @p_date = CONVERT( DATETIME, SELECT * FROM table1 WHERE column_datetime = @p_date
DECLARE @p_date DATETIME SET @p_date = CONVERT( DATETIME, SELECT * FROM table1 WHERE column_datetime >= @p_date AND column_datetime < DATEADD(d, 1, @p_date)
DECLARE @pDate DATE= SELECT colA, colB FROM table1 WHERE convert(date, colDateTime) = @pDate
Declare @DateToSearch DateTime Set @DateToSearch = SELECT * FROM table1 WHERE Year(column_datetime) = Year(@DateToSearch) AND Month(column_datetime) = Month(@DateToSearch) AND Day(column_datetime) = Day(@DateToSearch)
SELECT * FROM table1 WHERE convert(varchar, column_datetime, 111) =
DECLARE @p_date DATETIME SET @p_date = CONVERT( DATETIME, SELECT * FROM table1 WHERE DATEDIFF( d, column_datetime, @p_date ) = 0
ALTER TABLE "table1" ADD "column_date" AS CONVERT(DATE, "column_datetime") PERSISTED
CREATE NONCLUSTERED INDEX "table1_column_date_nu_nci" ON "table1" ( "column_date" ASC ) GO
DECLARE @p_date DATE SET @p_date = CONVERT( DATE, SELECT * FROM table1 WHERE column_date = @p_date
Select * Table1 Where Cast(Floor(Cast(Column_DateTime As Float)) As DateTime) =
DECLARE @p_date DATETIME SET @p_date = Cast( SELECT * FROM table1 WHERE Cast(Floor(Cast(column_datetime As Float)) As DateTime) = @p_date
DATEADD(dd, DATEDIFF( dd, -1, GetDate() - DAY(GetDate()) ), 0)
DATEADD(m,-12,DATEADD(dd, DATEDIFF( dd, -1, GetDate() - DAY(GetDate()) ), 0))
SELECT * FROM (SELECT *, DATEPART(yy, column_dateTime) as Year, DATEPART(mm, column_dateTime) as Month, DATEPART(dd, column_dateTime) as Day FROM table1) WHERE Year = AND Month = AND Day =
SELECT * FROM table1 WHERE CONVERT(varchar(10),columnDatetime,121) = CONVERT(varchar(10),CONVERT(
DECLARE @strDate VARCHAR(15) SET @strDate = SELECT * FROM table WHERE CONVERT(VARCHAR(15),dtInvoice, 112)>= CONVERT(VARCHAR(15),@strDate , 112)
DECLARE @Dat SELECT * FROM Jai WHERE CONVERT(VARCHAR(2),DATEPART("dd",Date)) + CONVERT(VARCHAR(2),DATEPART("mm",Date)) + CONVERT(VARCHAR(4), DATEPART("yy",Date)) = @Dat
SELECT * FROM table1 WHERE DATE(column_datetime) = @p_date;
SELECT * FROM tablename WHERE CAST(FLOOR(CAST(column_datetime AS FLOAT))AS DATETIME) =
SELECT * FROM tablename where CONVERT(datetime,columnname,103) between
In CONVERT(DATETIME,COLUMNNAME,103) "103" SPECIFIES THE DATE FORMAT as dd/mm/yyyy
DECLARE @p_date DATE SELECT * FROM table1 WHERE column_dateTime=@p_date
CREATE PROCEDURE [dbo].[GetAccounts] @AccountID BIGINT, @Result INT OUT, @ErrorMessage VARCHAR(255) OUT AS BEGIN SET NOCOUNT ON; SET @Result = 0 SET @ErrorMessage = DECLARE @tmp_Accounts TABLE ( AccountId BIGINT, AccountName VARCHAR(50), ... ) INSERT INTO @tmp_Accounts ([AccountId], [AccountName]... ) SELECT AccountID, AccountName FROM Accounts WHERE ... IF @@Rowcount = 0 BEGIN SET @ErrorMessage = SET @Result = 0 RETURN @Result END ELSE BEGIN SET @Result = 1 SELECT * FROM @tmp_Accounts END
SELECT DATALENGTH(imagecol) as imgBytes, DATALENGTH(imagecol) / 1024 as imgKbRounded, DATALENGTH(imagecol) / 1024.0 as imgKb, DATALENGTH(imagecol) / 1024 / 1024 as imgMbRounded, DATALENGTH(imagecol) / 1024.0 / 1024.0 as imgMb FROM table
imgBytes imgKbRounded imgKb imgMbRounded imgMb 68514 66 66.908203 0 0.065340041992
CREATE TYPE [dbo].[FooType] AS TABLE( [Bar] [INT], )
CREATE FUNCTION [dbo].[GetFoos] RETURN @FooTypes TABLE ([Bar] [INT]) INSERT INTO @FooTypes (1) RETURN
CREATE FUNCTION [dbo].[GetFoos] RETURN @FooTypes [FooType] INSERT INTO @FooTypes (1) RETURN
CREATE TYPE dbo.MyCustomUDDT AS TABLE ( FieldOne varchar (512), FieldTwo varchar(1024) )
DECLARE @uddt MyCustomUDDT; DECLARE @Modifieduddt MyCustomUDDT;
INSERT INTO @Modifieduddt SELECT * FROM dbo.MyUDF(@uddt);
CREATE FUNCTION dbo.MyUDF(@localUDDT MyCustomUDDT) RETURNS @tableVar TABLE ( FieldOne varchar (512), FieldTwo varchar(1024) ) AS BEGIN --Modify your variable here RETURN END
SELECT StudentId FROM Student WHERE condition = xyz
DECLARE @result NVARCHAR(MAX) SELECT @result = STUFF( ( SELECT FROM Student WHERE condition = abc FOR xml path( ) , 1 , 1 ,
DECLARE @result varchar(1000) SET @result = SELECT @result = @result + StudentId + select substring(@result, 0, len(@result) - 1) --trim extra "," at end
DECLARE @StudentID VARCHAR(1000) SELECT @StudentID = COALESCE(@StudentID + FROM Student WHERE StudentID IS NOT NULL and Condition= select @StudentID
DECLARE @StudentID VARCHAR(1000) SELECT @StudentID = CONCAT(COALESCE(@StudentID + FROM Student WHERE StudentID IS NOT NULL and Condition= select @StudentID
DECLARE @results VarChar(1000) SELECT @results = CASE WHEN @results IS NULL THEN CONVERT( VarChar(20), [StudentId]) ELSE END FROM Student WHERE condition = abc;
DECLARE @results VARCHAR(1000) = SELECT @results = @results + ISNULL(CASE WHEN LEN(@results) = 0 THEN FROM Student WHERE condition = xyz select @results
DECLARE @results VarChar(1000) SELECT @results = CASE WHEN @results IS NULL THEN CONVERT( VarChar(20), [StudentId]) ELSE @results + END FROM Student WHERE condition = abc;
DECLARE @ElapsedS INT SET @ElapsedS = DATEDIFF(second, @start_date, @end_date)
CREATE FUNCTION [dbo].[udfTimeSpanFromSeconds] ( @Seconds int ) RETURNS varchar(15) AS BEGIN DECLARE --Variable to hold our result @DHMS varchar(15) --Integers for doing the math , @Days int --Integer days , @Hours int --Integer hours , @Minutes int --Integer minutes --Strings for providing the display , @sDays varchar(5) --String days , @sHours varchar(2) --String hours , @sMinutes varchar(2) --String minutes , @sSeconds varchar(2) --String seconds --Get the values using modulos where appropriate SET @Hours = @Seconds/3600 SET @Minutes = (@Seconds % 3600) /60 SET @Seconds = (@Seconds % 3600) % 60 --If we have 24 or more hours, split the @Hours value into days and hours IF @Hours > 23 BEGIN SET @Days = @Hours/24 SET @Hours = (@Hours % 24) END ELSE BEGIN SET @Days = 0 END --Now render the whole thing as string values for display SET @sDays = convert(varchar, @Days) SET @sHours = RIGHT( SET @sMinutes = RIGHT( SET @sSeconds = RIGHT( --Concatenate, concatenate, concatenate SET @DHMS = @sDays + RETURN @DHMS END
SELECT TimeSpan = dbo.udfTimeSpanFromSeconds(@ElapsedS)
Declare @Date1 as Datetime, @Date2 as Datetime Set @Date1 = Set @Date2 = Select CAST(DATEDIFF(Minute,@Date1, @Date2)/60/24 as Varchar(50)) ++ CAST((DATEDIFF(Minute,@Date1, @Date2)/60)-((DATEDIFF(Minute,@Date1, @Date2)/60/24)*24) as Varchar(50)) ++ CAST((DATEDIFF(Minute,@Date1, @Date2)) - (DATEDIFF(HOUR,@Date1, @Date2)*60) as Varchar(50)) ++
DECLARE @FirstDate DATETIME, @SecondDate DATETIME, @result VARCHAR(MAX) SELECT @FirstDate = DECLARE @Day INT,@Month INT,@Hour INT, @Minute INT,@TotalSeconds INT,@Year INT SELECT @TotalSeconds = ABS(DATEDIFF(SECOND,@FirstDate,@SecondDate)) -- Standard values in seconds DECLARE @YearSeconds INT, @MonthSeconds INT, @DaySeconds INT, @HourSeconds INT, @MinuteSeconds INT SELECT @MinuteSeconds = 60 SELECT @HourSeconds = 60 * @MinuteSeconds SELECT @DaySeconds = 24 * @HourSeconds SELECT @MonthSeconds = 30 * @DaySeconds SELECT @YearSeconds = 12 * @MonthSeconds --SELECT @MinuteSeconds AS [Minutes], @HourSeconds AS [Hours], @DaySeconds AS [Day],@MonthSeconds AS [Month],@YearSeconds AS [Year] IF @TotalSeconds < @MinuteSeconds BEGIN SELECT @result = CAST(@TotalSeconds AS NVARCHAR(20)) + END ELSE IF @TotalSeconds < @HourSeconds BEGIN SELECT @result = CAST(ABS(DATEDIFF(MINUTE,@FirstDate,@SecondDate)) AS NVARCHAR(20)) + END ELSE IF @TotalSeconds < @DaySeconds BEGIN SELECT @result = CAST(ABS(DATEDIFF(HOUR,@FirstDate,@SecondDate)) AS NVARCHAR(20)) + END ELSE IF @TotalSeconds < @MonthSeconds BEGIN SELECT @result = CAST(ABS(DATEDIFF(DAY,@FirstDate,@SecondDate)) AS NVARCHAR(20)) + END ELSE IF @TotalSeconds < @YearSeconds BEGIN SELECT @result = CAST(ABS(DATEDIFF(MONTH,@FirstDate,@SecondDate)) AS NVARCHAR(20)) + END ELSE IF @TotalSeconds > @YearSeconds BEGIN SELECT @result = CAST(ABS(DATEDIFF(YEAR,@FirstDate,@SecondDate)) AS NVARCHAR(20)) + END SELECT @result
SELECT Id FROM Table1 WHERE AlertDate IS NULL; UPDATE Table1 SET AlertDate = getutcdate() WHERE AlertDate IS NULL;
UPDATE TOP (10) HumanResources.Employee SET VacationHours = VacationHours * 1.25, ModifiedDate = GETDATE() OUTPUT inserted.BusinessEntityID, deleted.VacationHours, inserted.VacationHours, inserted.ModifiedDate INTO @MyTableVar;
BEGIN TRAN SELECT Id FROM Table1 WITH (UPDLOCK) WHERE AlertDate IS NULL; UPDATE Table1 SET AlertDate = getutcdate() WHERE AlertDate IS NULL; COMMIT TRAN
DECLARE cur1 CURSOR FOR SELECT AlertDate FROM Table1 WHERE AlertDate IS NULL FOR UPDATE; DECLARE @UpdateTime DATETIME SET @UpdateTime = GETUTCDATE() OPEN cur1; FETCH NEXT FROM cur1; WHILE @@FETCH_STATUS = 0 BEGIN UPDATE Table1 AlertDate = @UpdateTime WHERE CURRENT OF cur1; FETCH NEXT FROM cur1; END
DECLARE @UpdatedIDs table (ID int) UPDATE Table1 SET AlertDate = getutcdate() OUTPUT inserted.Id INTO @UpdatedIDs WHERE AlertDate IS NULL;
declare @UpdateTime datetime set @UpdateTime = getutcdate() update Table1 set AlertDate = @UpdateTime where AlertDate is null select ID from Table1 where AlertDate = @UpdateTime
try { entityManager.getTransaction().begin(); int upsert = entityManager.createNativeQuery( "update com.bill.Credit c set c.balance = c.balance - ?1 where c.accountId = ?2 and c.balance >= ?1").executeUpdate(); Credit newCredit = entityManager.find(Credit.class, "id"); entityManager.refresh(newCredit); entityManager.getTransaction().commit(); } finally { entityManager.unwrap(Session.class).close(); }
private Object getLock(final EntityManager entityManager, final String Id){ entityManager.getTransaction().begin(); Object obj_acquire = entityManager.createNativeQuery("SELECT GET_LOCK( entityManager.getTransaction().commit(); return obj_acquire; } private Object releaseLock(final EntityManager entityManager, final String Id){ entityManager.getTransaction().begin(); Object obj_release = entityManager.createNativeQuery("SELECT RELEASE_LOCK( entityManager.getTransaction().commit(); return obj_release; }
update mytable set mydate = sysdate where mydate in (select mydate from mytable where mydate is null);
CREATE UNIQUE NONCLUSTERED INDEX IX_TopicShortName ON DimMeasureTopic(TopicShortName)
SELECT TopicShortName, COUNT(*) FROM DimMeasureTopic GROUP BY TopicShortName HAVING COUNT(*) > 1
SELECT TopicShortName, COUNT(*) FROM DimMeasureTopic GROUP BY TopicShortName HAVING COUNT(*) > 1
set @variableOne = avg(someColumn), @variableTwo = avg(otherColumn) from tblTable
set @variableOne = ( select avg(someColumn) from tblTable ) set @variableTwo = ( select avg(otherColumn) from tblTable )
select @var1 = avg(someColumn), @var2 = avg(otherColumn) from theTable
SELECT @var1 = c.Column1, @var2 = c.Column2, FROM Customers c WHERE c.CustomerID = @CustomerID
SELECT @variableOne = avg(someColumn), @variableTwo = avg(otherColumn) from tblTable
(select case when xyz.something = 1 then else (select case when xyz.somethingelse = 1) then end) (select case when xyz.somethingelseagain = 2) then end) end) [ColumnName],
SELECT CASE WHEN xyz.something = 1 THEN WHEN xyz.somethingelse = 1 THEN WHEN xyz.somethingelseagain = 2 THEN ELSE END AS ColumnName;
declare @n int = 7, @m int = 3; select case when @n = 1 then else case when @m = 1 then when @m = 2 then end end as col1 -- n=1 => returns SOMETEXT regardless of @m -- n=2 and m=1 => returns SOMEOTHERTEXT -- n=2 and m=2 => returns SOMEOTHERTEXTGOESHERE -- n=2 and m>2 => returns null (no else defined for inner case)
CREATE TABLE Employer ( EmployerCode VARCHAR(20) PRIMARY KEY, Address VARCHAR(100) NULL ) CREATE TABLE Employee ( EmployeeID INT PRIMARY KEY, EmployerCode VARCHAR(20) NOT NULL, CONSTRAINT employer_code_fk FOREIGN KEY (EmployerCode) REFERENCES Employer ) CREATE TABLE BankAccount ( BankAccountID INT PRIMARY KEY, EmployerCode VARCHAR(20) NOT NULL, Amount MONEY NOT NULL, CONSTRAINT employer_code_fk FOREIGN KEY (EmployerCode) REFERENCES Employer )
CREATE TABLE BankAccount ( BankAccountID INT PRIMARY KEY, EmployerCode VARCHAR(20) NOT NULL, Amount MONEY NOT NULL, CONSTRAINT FK_BankAccount_Employer FOREIGN KEY (EmployerCode) REFERENCES Employer )
Employers_EMR Employees_EMP BankAccounts_BNA Banks_BNK
SELECT d1.Short_Code FROM domain1 d1 WHERE d1.Short_Code NOT IN ( SELECT d2.Short_Code FROM Domain2 d2 )
SELECT d1.short_code FROM domain1 d1 LEFT JOIN domain2 d2 ON d2.short_code = d1.short_code WHERE d2.short_code IS NULL
SELECT short_code FROM domain1 EXCEPT SELECT short_code FROM domain2
SELECT d1.Short_Code FROM domain1 d1 LEFT JOIN domain2 d2 ON d1.Short_Code = d2.Short_Code WHERE d2.Short_Code IS NULL
SELECT D1.ShortCode FROM Domain1 D1 WHERE NOT EXISTS (SELECT FROM Domain2 D2 WHERE D2.ShortCode = D1.ShortCode )
DECLARE @what sql_variant DECLARE @foo decimal(19,3) = 1, @bar decimal(11,7) = 2 SELECT @what = @foo / @bar SELECT SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what, SELECT @what = @foo + @bar SELECT SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what, SELECT @what = @foo * @bar SELECT SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what, SQL_VARIANT_PROPERTY(@what,
table1 (ID, field1, field2, ...) table2 (ID, table1_ID, fieldA, fieldB,...) -- where table1_ID is a reference to ID of table1
insert into table2(table1_ID) select ID from table1
INSERT INTO table2 ( SELECT field1, field2, field3... FROM table1 )
ALTER table sometable Add somecolumn nchar(1) NOT NULL DEFAULT
alter table sometable alter column somecolumn nchar(1) null
declare @name nvarchar(100) select @name = [name] from sys.objects where type = if (@name is not null) begin exec ( end
DECLARE @ConstraintName nvarchar(200) SELECT @ConstraintName = Name FROM SYS.DEFAULT_CONSTRAINTS WHERE PARENT_OBJECT_ID = OBJECT_ID( AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = N AND object_id = OBJECT_ID(N IF @ConstraintName IS NOT NULL EXEC(
select name from sys.default_constraints where name like
alter table <tablename> drop constraint <constraintname>
SELECT TOP 5 WITH TIES EmpNumber,EmpName FROM Employee Order By EmpNumber DESC
SELECT TOP 5 WITH TIES * FROM MyTable ORDER BY ID DESC;
CREATE FUNCTION sf_RemoveExtraChars (@NAME nvarchar(50)) RETURNS nvarchar(50) AS BEGIN declare @TempString nvarchar(100) set @TempString = @NAME set @TempString = LOWER(@TempString) set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, set @TempString = replace(@TempString, return @TempString END GO
create function [dbo].[RemoveExtraChars] ( @p_OriginalString varchar(50) ) returns varchar(50) as begin declare @i int = 1; -- must start from 1, as SubString is 1-based declare @OriginalString varchar(100) = @p_OriginalString Collate SQL_Latin1_General_CP1253_CI_AI; declare @ModifiedString varchar(100) = while @i <= Len(@OriginalString) begin if SubString(@OriginalString, @i, 1) like begin set @ModifiedString = @ModifiedString + SubString(@OriginalString, @i, 1); end set @i = @i + 1; end return @ModifiedString end
CREATE FUNCTION dbo.fnCharToAscii ( @Char AS VARCHAR ) RETURNS VARCHAR AS BEGIN IF (@Char IS NULL) RETURN -- Process control and DEL chars. IF (ASCII(@Char) < 32) OR (ASCII(@Char) = 127) RETURN -- Return printable 7-bit ASCII chars as is. -- UPDATE TO DELETE NON-ALPHA CHARS. IF (ASCII(@Char) >= 32) AND (ASCII(@Char) < 127) RETURN @Char -- Process 8-bit ASCII chars. RETURN CASE ASCII(@Char) WHEN 128 THEN WHEN 129 THEN WHEN 130 THEN WHEN 131 THEN WHEN 132 THEN WHEN 133 THEN WHEN 134 THEN WHEN 135 THEN WHEN 136 THEN WHEN 137 THEN WHEN 138 THEN WHEN 139 THEN WHEN 140 THEN WHEN 141 THEN WHEN 142 THEN WHEN 143 THEN WHEN 144 THEN WHEN 145 THEN WHEN 146 THEN WHEN 147 THEN WHEN 148 THEN WHEN 149 THEN WHEN 150 THEN WHEN 151 THEN WHEN 152 THEN WHEN 153 THEN WHEN 154 THEN WHEN 155 THEN WHEN 156 THEN WHEN 157 THEN WHEN 158 THEN WHEN 159 THEN WHEN 160 THEN WHEN 161 THEN WHEN 162 THEN WHEN 163 THEN WHEN 164 THEN WHEN 165 THEN WHEN 166 THEN WHEN 167 THEN WHEN 168 THEN WHEN 169 THEN WHEN 170 THEN WHEN 171 THEN WHEN 172 THEN WHEN 173 THEN WHEN 174 THEN WHEN 175 THEN WHEN 176 THEN WHEN 177 THEN WHEN 178 THEN WHEN 179 THEN WHEN 180 THEN WHEN 181 THEN WHEN 182 THEN WHEN 183 THEN WHEN 184 THEN WHEN 185 THEN WHEN 186 THEN WHEN 187 THEN WHEN 188 THEN WHEN 189 THEN WHEN 190 THEN WHEN 191 THEN WHEN 192 THEN WHEN 193 THEN WHEN 194 THEN WHEN 195 THEN WHEN 196 THEN WHEN 197 THEN WHEN 198 THEN WHEN 199 THEN WHEN 200 THEN WHEN 201 THEN WHEN 202 THEN WHEN 203 THEN WHEN 204 THEN WHEN 205 THEN WHEN 206 THEN WHEN 207 THEN WHEN 208 THEN WHEN 209 THEN WHEN 210 THEN WHEN 211 THEN WHEN 212 THEN WHEN 213 THEN WHEN 214 THEN WHEN 215 THEN WHEN 216 THEN WHEN 217 THEN WHEN 218 THEN WHEN 219 THEN WHEN 220 THEN WHEN 221 THEN WHEN 222 THEN WHEN 223 THEN WHEN 224 THEN WHEN 225 THEN WHEN 226 THEN WHEN 227 THEN WHEN 228 THEN WHEN 229 THEN WHEN 230 THEN WHEN 231 THEN WHEN 232 THEN WHEN 233 THEN WHEN 234 THEN WHEN 235 THEN WHEN 236 THEN WHEN 237 THEN WHEN 238 THEN WHEN 239 THEN WHEN 240 THEN WHEN 241 THEN WHEN 242 THEN WHEN 243 THEN WHEN 244 THEN WHEN 245 THEN WHEN 246 THEN WHEN 247 THEN WHEN 248 THEN WHEN 249 THEN WHEN 250 THEN WHEN 251 THEN WHEN 252 THEN WHEN 253 THEN WHEN 254 THEN WHEN 255 THEN END RETURN END
DECLARE @I INT DECLARE @Msg VARCHAR(32) SET @I = 128 WHILE @I < 256 BEGIN SELECT @Msg = CAST(@I AS VARCHAR) + CHAR(@I) + dbo.fnCharToAscii(CHAR(@I)) PRINT @Msg SET @I = @I + 1 END
CREATE FUNCTION dbo.fnStringToAscii ( @Value AS VARCHAR(8000) ) RETURNS VARCHAR(8000) AS BEGIN IF (@Value IS NULL OR DATALENGTH(@Value) = 0) RETURN DECLARE @Index INT DECLARE @Result VARCHAR(8000) SET @Result = SET @Index = 1 WHILE (@Index <= DATALENGTH(@Value)) BEGIN SET @Result = @Result + dbo.fnCharToAscii(SUBSTRING(@Value, @Index, 1)) SET @Index = @Index + 1 END RETURN @Result END GO
DECLARE @s1 NVARCHAR(200), @s2 NVARCHAR(200) SET @s1 = N SET @s2 = N SELECT @s2 = @s2 + no_accent FROM ( SELECT SUBSTRING(@s1, number, 1) AS accent, number FROM master.dbo.spt_values WHERE TYPE = AND number BETWEEN 1 AND LEN(@s1) ) s1 INNER JOIN ( SELECT NCHAR(number) AS no_accent FROM master.dbo.spt_values WHERE type = AND (number BETWEEN 65 AND 90 OR number BETWEEN 97 AND 122) ) s2 ON s1.accent COLLATE LATIN1_GENERAL_CS_AI = s2.no_accent ORDER BY number SELECT @s1 SELECT @s2
public static Dictionary<char, string> NonEnglishLetterMapping = new Dictionary<char, string> { { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { };
declare @TempString varchar(100) set @TempString= select @TempString= replace( replace( replace( replace( replace( replace( replace( replace( replace( replace( replace(@TempString, , , , , , , , , , , select @TempString
CREATE VIEW Sequence AS WITH T1(_) AS (SELECT NULL UNION ALL SELECT NULL), T2(_) AS (SELECT NULL FROM T1 AS L CROSS JOIN T1 AS R), T3(_) AS (SELECT NULL FROM T2 AS L CROSS JOIN T2 AS R), T4(_) AS (SELECT NULL FROM T3 AS L CROSS JOIN T3 AS R), T5(_) AS (SELECT NULL FROM T4 AS L CROSS JOIN T4 AS R) SELECT ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS Number FROM T5;
CREATE TABLE UndiacriticMap ( DiacriticCharacter CHAR(1) NOT NULL PRIMARY KEY, UndiacriticCharacter CHAR(1) NOT NULL ); INSERT INTO UndiacriticMap ( DiacriticCharacter, UndiacriticCharacter ) VALUES ( ( ( ( ( (
CREATE TABLE TestData ( ID INT NOT NULL PRIMARY KEY, String VARCHAR(50) NOT NULL ); INSERT INTO TestData ( ID, String ) VALUES (1, (2,
WITH CharacterWise (ID, Symbol, Position) AS ( SELECT ID, SUBSTRING(TestData.String, Sequence.Number, 1), Sequence.Number FROM TestData INNER JOIN Sequence ON Sequence.Number <= LEN(TestData.String) ), Stripped (ID, Symbol, Position) AS ( SELECT ID, CASE WHEN UndiacriticMap.DiacriticCharacter IS NOT NULL THEN UndiacriticMap.UndiacriticCharacter ELSE CASE WHEN CharacterWise.Symbol LIKE THEN CharacterWise.Symbol ELSE END END, CharacterWise.Position FROM CharacterWise LEFT OUTER JOIN UndiacriticMap ON UndiacriticMap.DiacriticCharacter = CharacterWise.Symbol ) SELECT TestData.ID, TestData.String, ( SELECT Stripped.Symbol AS [text()] FROM Stripped WHERE TestData.ID = Stripped.ID ORDER BY Stripped.Position FOR XML PATH( ) AS StrippedString FROM TestData;
ID String StrippedString ----------- -------------------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1 textàè containing éìòaccentsç 2 aèàç=.32s df aeacsdf
select REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(myfield,
select * From XXX where cast(word as varchar(max)) collate SQL_Latin1_General_CP1253_CI_AI =
create extension unaccent; select unaccent("ąęśłóŻŹŁÓĄĘ");
select * from database_name.table_name where countries LIKE or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like or countries like
select * from [Janus999DB].[dbo].[tblCustomerPlay] where DatePlayed < CURRENT_TIMESTAMP and DatePlayed > (CURRENT_TIMESTAMP-30)
SELECT * FROM [Janus999DB].[dbo].[tblCustomerPlay] WHERE DatePlayed < GetDate() AND DatePlayed > dateadd(minute, -30, GetDate())
--count the number of times more than 1 report was requested in the record select count(*) as cnt from [table] where RequestedReportParams Like
SELECT LEN(RequestedReportParams) - LEN(REPLACE(RequestedReportParams, FROM YourTable WHERE .....
select count(*) as cnt FROM [table] WHERE RequestedReportParams Like
CREATE PROC [dbo].[ImportCompany] ( @CompanyId AS INTEGER ) AS EXEC [dbo].[ImportAddress] @CompanyId = @CompanyId --Import other data CREATE PROC [dbo].[ImportAddress] ( @CompanyId AS INTEGER ) AS CREATE TABLE INSERT INTO SELECT Address as OldAddress, FROM [OldDb].[dbo].[Addresses] WHERE CompanyId = @CompanyId --Do stuff with the transformed data DROP TABLE EXEC [dbo].[ImportCompany] @CompanyId = 12345
DROP TABLE CREATE TABLE LAST_NAME NVARCHAR(30), FRST_NAME NVARCHAR(30)) SELECT LAST_NAME,FRST_NAME INTO
DROP TABLE CREATE TABLE LAST_NAME NVARCHAR(30), FRST_NAME NVARCHAR(30)) INSERT INTO SELECT LAST_NAME,FRST_NAME FROM TBL_PEOPLE
CREATE TABLE LAST_NAME NVARCHAR(30), FRST_NAME NVARCHAR(30)) INSERT INTO SELECT LAST_NAME,FRST_NAME FROM TBL_PEOPLE
declare @userData TABLE( LAST_NAME NVARCHAR(30), FRST_NAME NVARCHAR(30) )
SELECT name FROM sys.server_principals WHERE name =
USE (your database you want to check the user SELECT * FROM sys.database_principals WHERE name =
USE MyDB SELECT sp.name AS ServerLoginName, dp.name AS DBUserName FROM sys.server_principals sp LEFT JOIN sys.database_principals dp ON sp.sid = dp.sid WHERE sp.name =
use SomeDatabase go select database_principal_id( if database_principal_id( drop user go
IF DATABASE_PRINCIPAL_ID( BEGIN CREATE USER [domain\lanid] FOR LOGIN [domain\lanid] WITH DEFAULT_SCHEMA=[dbo] EXEC sp_addrolemember N END
create procedure A as lock table a -- do some stuff unrelated to a to prepare to update a -- update a unlock table a return table b
CREATE PROCEDURE ... AS BEGIN BEGIN TRANSACTION -- lock table "a" till end of transaction SELECT ... FROM a WITH (TABLOCK, HOLDLOCK) WHERE ... -- do some other stuff (including inserting/updating table "a") -- release lock COMMIT TRANSACTION END
select top 1 * from table1 with (tablock, holdlock)
SELECT SUBSTRING(myColumn, 1, CHARINDEX( SUBSTRING(myColumn, CHARINDEX( FROM MyTable
FirstName---LastName John--------Smith Jane--------Doe Steve-------NULL Bob---------Johnson
"Invalid length parameter passed to the LEFT or SUBSTRING function."
SELECT SUBSTRING(myColumn, 1, CASE CHARINDEX( WHEN 0 THEN LEN(myColumn) ELSE CHARINDEX( END) AS FirstName ,SUBSTRING(myColumn, CASE CHARINDEX( WHEN 0 THEN LEN(myColumn) + 1 ELSE CHARINDEX( END, 1000) AS LastName FROM MyTable
DECLARE @tags NVARCHAR(400) = SELECT value FROM STRING_SPLIT(@tags, WHERE RTRIM(value) <>
SELECT SUBSTRING(myColumn, 1, CHARINDEX( SUBSTRING(myColumn, CHARINDEX( FROM MyTable WHERE CHARINDEX(
SELECT SUBSTRING(myColumn, 1, CHARINDEX( SUBSTRING(myColumn, CHARINDEX( FROM MyTable WHERE myColumn LIKE
DECLARE @mytable TABLE ([id] VARCHAR(10), [name] VARCHAR(1000)); INSERT INTO @mytable VALUES ( SELECT P.id, [1] FROM( SELECT A.id, X1.VALUE, ROW_NUMBER() OVER (PARTITION BY A.id ORDER BY A.id) RN FROM @mytable A CROSS APPLY STRING_SPLIT(A.name, ) A PIVOT (MAX(A.[VALUE]) FOR A.RN IN ([1],[2],[3],[4],[5])) P
Insert into SQLServerTable Select * FROM OPENROWSET(
EXEC sp_makewebtask @outputfile = @query = @colheaders =1, @FixedFont=0,@lastupdated=0,@resultstitle=
create procedure proc_generate_excel_with_columns ( @db_name varchar(100), @table_name varchar(100), @file_name varchar(100) ) as --Generate column names as a recordset declare @columns varchar(8000), @sql varchar(8000), @data_file varchar(100) select @columns=coalesce(@columns+ from information_schema.columns where table_name=@table_name select @columns= --Create a dummy file to have actual data select @data_file=substring(@file_name,1,len(@file_name)-charindex( --Generate column names in the passed EXCEL file set @sql= exec(@sql) --Generate data in the dummy file set @sql= exec(@sql) --Copy dummy file to passed EXCEL file set @sql= exec(@sql) --Delete dummy file set @sql= exec(@sql)
sp_configure GO RECONFIGURE; GO sp_configure GO RECONFIGURE; GO
$Server = "TestServer" $Database = "TestDatabase" $Query = "select * from TestTable" $FilePath = "C:\OutputFile.csv" Invoke-Sqlcmd -Query $Query -Database $Database -ServerInstance $Server | Export-Csv $FilePath
CREATE TABLE ( rno int identity(1,1), ccp varchar(50), [col1] INT, [col2] INT, [col3] INT, col4 as [col2]/100.0 ); INSERT INTO (ccp,[col1],[col2],[col3]) VALUES ( ( ( ( ( ( +-----+------+------+------+------+----------+ | rno | ccp | col1 | col2 | col3 | col4 | +-----+------+------+------+------+----------+ | 1 | ccp1 | 15 | 10 | 1100 | 0.100000 | | 2 | ccp1 | 20 | 10 | 1210 | 0.100000 | | 3 | ccp1 | 30 | 10 | 1331 | 0.100000 | | 4 | ccp2 | 10 | 15 | 900 | 0.150000 | | 5 | ccp2 | 15 | 15 | 1000 | 0.150000 | | 6 | ccp2 | 20 | 15 | 1010 | 0.150000 | +-----+------+------+------+------+----------+
1083.500000 --1100 - (15 * (1+0.100000)) 1169.850000 --1210 - ((20 * (1+0.100000)) + (15 * (1+0.100000)* (1+0.100000)) ) 1253.835000 --1331 - ((30 * (1+0.100000)) + (20 * (1+0.100000)* (1+0.100000)) + (15 * (1+0.100000)* (1+0.100000) *(1+0.100000)) ) 888.500000 --900 - (10 * (1+0.150000)) 969.525000 --1000 - ((15 * (1+0.150000)) + (10 * (1+0.150000)* (1+0.150000)) ) 951.953750 --1010 - ((20 * (1+0.150000)) + (15 * (1+0.150000)* (1+0.150000)) + (10 * (1+0.150000)* (1+0.150000) *(1+0.150000)) )
SELECT col3 - ( col1 * ( 1 + col4 ) ) FROM WHERE rno = 1 SELECT rno, col3 - ( ( col1 * Power(( 1 + col4 ), 1) ) + ( Lag(col1, 1) OVER( ORDER BY rno ) * Power(( 1 + col4 ), 2) ) ) FROM WHERE rno IN ( 1, 2 ) SELECT rno, col3 - ( ( col1 * Power(( 1 + col4 ), 1) ) + ( Lag(col1, 1) OVER( ORDER BY rno ) * Power(( 1 + col4 ), 2) ) + ( Lag(col1, 2) OVER( ORDER BY rno ) * Power(( 1 + col4 ), 3) ) ) FROM WHERE rno IN ( 1, 2, 3 )
WITH T AS (SELECT *, ROW_NUMBER() OVER(PARTITION BY CCP ORDER BY RNO) AS RN FROM SELECT T1.RNO, T1.CCP, T1.COL1, T1.COL2, T1.COL3, T1.COL3-SUM(T2.COL1*POWER(1+T1.COL2/100.0,T1.RN-T2.RN+1)) AS RES FROM T T1 JOIN T T2 ON T1.CCP=T2.CCP AND T1.RN>=T2.RN GROUP BY T1.RNO, T1.CCP, T1.COL1, T1.COL2, T1.COL3
SELECT a.*, col3 - res AS Result FROM CROSS apply (SELECT Sum(b.col1 * Power(( 1 + b.COL2 / 100.00 ), new_rn)) AS res FROM (SELECT Row_number() OVER( partition BY ccp ORDER BY rno DESC) new_rn,* FROM WHERE a.ccp = b.ccp AND a.rno >= b.rno)b) cs
+-----+------+------+------+------+----------+-------------+ | rno | ccp | col1 | col2 | col3 | col4 | Result | +-----+------+------+------+------+----------+-------------+ | 1 | ccp1 | 15 | 10 | 1100 | 0.100000 | 1083.500000 | | 2 | ccp1 | 20 | 10 | 1210 | 0.100000 | 1169.850000 | | 3 | ccp1 | 30 | 10 | 1331 | 0.100000 | 1253.835000 | | 4 | ccp2 | 10 | 15 | 900 | 0.150000 | 888.500000 | | 5 | ccp2 | 15 | 15 | 1000 | 0.150000 | 969.525000 | | 6 | ccp2 | 20 | 15 | 1010 | 0.150000 | 951.953750 | +-----+------+------+------+------+----------+-------------+
CREATE TABLE ( rno int identity(1,1), ccp varchar(50), [col1] INT, [col2] INT, [col3] INT, col4 as [col2]/100.0 ); INSERT INTO (ccp,[col1],[col2],[col3]) VALUES ( ( ( ( ( ( ( select t.*, col3-s from( select *, rn = row_number() over(partition by ccp order by rno) from ) t cross apply ( select s=sum(pwr*col1) from( select top(rn) col1, pwr = power(1+col4, rn + 1 - row_number() over(order by rno)) from where t2.ccp=t.ccp order by row_number() over(order by rno) )t3 )t4 order by rno;
;with val as ( select *, (1 + col2 / 100.00) val, row_number() over(partition by ccp order by rno desc) rn from res as ( select v1.rno, --min(v1.ccp) ccp, --min(v1.col1) col1, --min(v1.col2) col2, min(v1.col3) col3, sum(v2.col1 * power(v2.val, 1 + v2.rn - v1.rn)) sum_val from val v1 left join val v2 on v2.ccp = v1.ccp and v2.rno <= v1.rno group by v1.rno) select *, col3 - isnull(sum_val, 0) from res
select *, col3 - sum(col1 * power(1 + col4, row_num)) over (partition by ccp order by col1) from ( select *, row_number() over (partition by ccp order by rno asc) row_num from @Table1 ) a order by 1,2;
CREATE FUNCTION <function name>(parameter datatype) RETURN table AS RETURN ( -- *write your query here* --- )
SELECT Date, ROW_NUMBER() OVER (PARTITION BY Date ORDER By Date, Cat) as ROW, Cat, Qty FROM SOURCE
SELECT Date, ROW_NUMBER() OVER (PARTITION BY Date, Cat ORDER By Date, Cat) as ROW, Cat, Qty FROM SOURCE
CREATE NONCLUSTERED INDEX index_name_here ON dbo.table_name_here (column_to_index_here) INCLUDE (primary_key_column,other_column_here) WITH( STATISTICS_NORECOMPUTE=OFF, IGNORE_DUP_KEY=OFF, --<default junk from SSMS ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] GO
DBCC CHECKIDENT ( table_name, RESEED, new_reseed_value )
DBCC CHECKIDENT (SyncSession, RESEED, 0); --next record should be 0 + increment
DBCC CHECKIDENT (SyncSession, RESEED); --next record should be the seed value
DECLARE @c TABLE (TanvtechId varchar(10),NewTanvtechId Varchar(10)) INSERT INTO @c SELECT TanvtechId , Row_Number() OVER (ORDER BY TanvtechId ) from Tanvtech UPDATE G SET G.TanvtechId =a.NewTanvtechId FROM Tanvtech as G INNER JOIN @c as a ON a.TanvtechId =G.TanvtechId
DECLARE @thisday datetime; DECLARE daycursor CURSOR FOR SELECT DISTINCT DATEADD(day, 0, DATEDIFF(day, 0, TimeCollected)) as thisday FROM computerusedata OPEN daycursor; FETCH NEXT FROM daycursor INTO @thisday; WHILE @@FETCH_STATUS = 0 BEGIN select distinct left(ComputerName,5) as CompGroup,DATEADD(day, 0, DATEDIFF(day, 0, TimeCollected)) as day FROM computerusedata where DATEADD(day, 0, DATEDIFF(day, 0, TimeCollected)) = @thisday order by CompGroup; FETCH NEXT FROM daycursor; END; CLOSE daycursor; DEALLOCATE daycursor;"; select DATEADD(day, 0, DATEDIFF(day, 0, TimeCollected)) as day,left(ComputerName,5) as CompGroup from ComputerUseData group by DATEADD(day, 0, DATEDIFF(day, 0, TimeCollected)),left(ComputerName,5) order by day,CompGroup
create procedure t_insert ( @value varchar(50) = null ) as insert into t (value) values (@value)
insert into t (value) values ( isnull(@value, default) )
if @value is null insert into t (value) values (default) else insert into t (value) values (@value)
CREATE TABLE myTable ( always VARCHAR(50), value1 VARCHAR(50) DEFAULT ( value2 VARCHAR(50) DEFAULT ( value3 VARCHAR(50) DEFAULT ( )
ALTER PROCEDURE t_insert ( @always VARCHAR(50), @value1 VARCHAR(50) = NULL, @value2 VARCHAR(50) = NULL, @value3 VARCAHR(50) = NULL ) AS BEGIN DECLARE @insertpart VARCHAR(500) DECLARE @valuepart VARCHAR(500) SET @insertpart = SET @valuepart = IF @value1 IS NOT NULL BEGIN SET @insertpart = @insertpart + SET @valuepart = @valuepart + END IF @value2 IS NOT NULL BEGIN SET @insertpart = @insertpart + SET @valuepart = @valuepart + END IF @value3 IS NOT NULL BEGIN SET @insertpart = @insertpart + SET @valuepart = @valuepart + END SET @insertpart = @insertpart + SET @valuepart = @valuepart + + --print @insertpart + @valuepart EXEC (@insertpart + @valuepart) END
EXEC t_insert SELECT * FROM myTable EXEC t_insert SELECT * FROM myTable EXEC t_insert SELECT * FROM myTable
CREATE PROCEDURE t_insert ( @value varchar(50) = null ) as DECLARE @sQuery NVARCHAR (MAX); SET @sQuery = N' insert into __t (value) values ( CASE WHEN @value IS NULL THEN EXEC sp_executesql @stmt = @sQuery, @params = N @value = @value; GO
CREATE FUNCTION GetDefaultValue ( @TableName VARCHAR(200), @ColumnName VARCHAR(200) ) RETURNS VARCHAR(200) AS BEGIN -- you -- you go this route RETURN (SELECT TOP 1 REPLACE(REPLACE(REPLACE(COLUMN_DEFAULT, FROM information_schema.columns WHERE table_name = @TableName AND column_name = @ColumnName) END GO
INSERT INTO t (value) VALUES ( ISNULL(@value, SELECT dbo.GetDefaultValue(
CREATE TABLE t ( insValue VARCHAR(50) NULL , selValue AS ISNULL(insValue, ) DECLARE @d VARCHAR(10) INSERT INTO t (insValue) VALUES (@d) -- null SELECT selValue FROM t
CREATE PROCEDURE MyTestProcedure ( @MyParam1 INT, @MyParam2 VARCHAR(20) = ‘ABC’, @MyParam3 INT = NULL) AS BEGIN -- Procedure body here END
`USE [YourTable] GO SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE PROC [dbo].[YourTableName] @Value smallint, @Value1 bigint, @Value2 varchar(50), @Value3 varchar(20), @Value4 varchar(20), @Value5 date, @Value6 varchar(50), @Value7 tinyint, @Value8 tinyint, @Value9 varchar(20), @Value10 varchar(20), @Value11 varchar(250), @Value12 tinyint, @Value13 varbinary(max)
AS --SET NOCOUNT ON IF @Value = 0 BEGIN INSERT INTO YourTableName ( [TableColumn1], [TableColumn2], [TableColumn3], [TableColumn4], [TableColumn5], [TableColumn6], [TableColumn7], [TableColumn8], [TableColumn9], [TableColumn10], [TableColumn11], [TableColumn12], [TableColumn13] ) VALUES ( @Value1, @Value2, @Value3, @Value4, @Value5, @Value6, @Value7, @Value8, @Value9, @Value10, @Value11, @Value12, default ) SELECT SCOPE_IDENTITY() As InsertedID END ELSE BEGIN UPDATE YourTableName SET [TableColumn1] = @Value1, [TableColumn2] = @Value2, [TableColumn3] = @Value3, [TableColumn4] = @Value4, [TableColumn5] = @Value5, [TableColumn6] = @Value6, [TableColumn7] = @Value7, [TableColumn8] = @Value8, [TableColumn9] = @Value9, [TableColumn10] = @Value10, [TableColumn11] = @Value11, [TableColumn12] = @Value12, [TableColumn13] = @Value13 WHERE [TableColumn] = @Value END GO`
IF OBJECT_ID( CREATE TABLE INSERT INTO INSERT INTO UPDATE SELECT * FROM
create trigger dbo.OnInsertIntoT ON TablenameT INSTEAD OF INSERT AS insert into TablenameT select IsNull(column1 ,<default_value>) ,IsNull(column2 ,<default_value>) ... from inserted
-- create initial row with default values insert table1 (col1, col2, col3) values (@col1, @col2, @col3) -- update default values, if supplied update table1 set col4 = isnull(@col4, col4), col5 = isnull(@col5, col5) where col1 = @col1
-- create initial row with default values insert table1 (col1, col2, col3) values (@col1, @col2, @col3) -- create a container to hold the values actually inserted into the table declare @inserted table (col4 datetime, col5 varchar(50)) -- update default values, if supplied update table1 set col4 = isnull(@col4, col4), col5 = isnull(@col5, col5) output inserted.col4, inserted.col5 into @inserted (col4, col5) where col1 = @col1 -- get the values defaulted into the table (optional) select @col4 = col4, @col5 = col5 from @inserted
CREATE TABLE Demo ( MyColumn VARCHAR(10) NOT NULL DEFAULT )
CREATE PROCEDURE InsertDemo @MyColumn VARCHAR(10) = null AS INSERT INTO Demo (MyColumn) VALUES(@MyColumn)
WHERE DATEPART(year, [tstamp]) = DATEPART(year, @dateParam) AND DATEPART(month, [tstamp]) = DATEPART(month, @dateParam) AND DATEPART(day, [tstamp]) = DATEPART(day, @dateParam)
declare @d datetime select @d = where tstamp >= dateadd(dd, datediff(dd, 0, @d)+0, 0) and tstamp < dateadd(dd, datediff(dd, 0, @d)+1, 0)
select dateadd(dd, datediff(dd, 0, getdate())+1, 0) select dateadd(dd, datediff(dd, 0, getdate())+0, 0)
create table d datetime, d2 as cast (datepart(year,d) as varchar(4)) + right( right( ) -- notice a lot of care need to be taken to ensure the format is comparable. (zero padding) insert values (getdate()) create index idx on select d2, count(d2) from where d2 between group by d2 -- index seek is used
declare @d datetimeselect @d = where tstamp BETWEEN dateadd(dd, datediff(dd, 0, @d)+0, 0) AND dateadd(dd, datediff(dd, 0, @d)+1, 0)
DECLARE @startDate DATETIME DECLARE @endDate DATETIME SET @startDate = DATEADD(day, -30, GETDATE()) SET @endDate = GETDATE() SELECT * FROM table WHERE dateColumn >= DATEADD(day, DATEDIFF(day, 0, @startDate), 0) AND dateColumn < DATEADD(day, 1, DATEDIFF(day, 0, @endDate))
CAST(CONVERT(VARCHAR, [tstamp], 102) AS DATETIME) = @dateParam
select getdate(), cast(datepart(year, getdate()) as varchar(4))+cast(datepart(MONTH, getdate()) as varchar(2))
CONVERT(NVARCHAR(10), DATE_OF_DAY, 103) => 15/09/2016 CONVERT(NVARCHAR(10), DATE_OF_DAY, 3) => 15/09/16
SELECT YYYYMM = (YEAR(GETDATE()) * 100) + MONTH(GETDATE())
public static int UpdateFieldCount(int parameterId) { int updatesuccess = 0; string connectionstring = WebConfigurationManager.ConnectionStrings["ConnectionString"].ConnectionString; SqlConnection conn = new SqlConnection(connectionstring); string SQLString = "UPDATE TableName SET TableField + 1 WHERE SomeFilterField = @ParameterID"; SqlCommand sqlcmd = new SqlCommand(SQLString, conn); sqlcmd.Parameters.AddWithValue("@ParameterID", parameterID); conn.Open(); updatesuccess = sqlcmd.ExecuteNonQuery(); conn.Close(); return updatesuccess; }
"UPDATE TableName SET TableField = TableField + 1 WHERE SomeFilterField = @ParameterID"
select * from Reference where reference_dt + 1 month
select * from Reference where reference_dt = DateAdd(month,1,another_date_reference)
select * from Reference where reference_dt = DATEADD(mm, 1, reference_dt)
declare @X datetime set @X = select convert(datetime, convert(char(19), @X, 126))
select dateadd(millisecond, -datepart(millisecond, @X), @X)
convert(datetime, convert(varchar, @datetime_var, 120), 120)
select cast(yourdate as smalldatetime) from yourtable
declare @a datetime declare @x int = 1 declare @mikaelend datetime declare @mikael datetime = getdate() while @x < 5000000 begin select @a = dateadd(millisecond, -datepart(millisecond, getdate()), getdate()) , @x +=1 end set @mikaelend = getdate() set @x = 1 declare @gbnend datetime declare @gbn datetime = getdate() while @x < 5000000 begin select @a = DATEADD(second, DATEDIFF(second, end set @gbnend = getdate() select datediff(ms, @mikael, @mikaelend) mikael, datediff(ms, @gbn, @gbnend) gbn
IF OBJECT_ID( BEGIN PRINT EXEC master.dbo.sp_addlinkedserver @server = N @srvproduct=N END ELSE PRINT
if not exists(select * from sys.servers where name = N
IF NOT EXISTS ( SELECT TOP (1) * FROM sysservers WHERE srvname =
CASE WHEN FieldA > FieldB THEN 1 ELSE 0 END AS [BIT]
Select Convert(Bit, Case When FieldA > FieldB Then 1 Else 0 End) As YourBitColumn
SELECT * FROM sys.dm_db_index_physical_stats (DB_ID(N
database_id object_id index_id partition_number index_type_desc alloc_unit_type_desc index_depth index_level avg_fragmentation_in_percent fragment_count avg_fragment_size_in_pages page_count avg_page_space_used_in_percent record_count ghost_record_count version_ghost_record_count min_record_size_in_bytes max_record_size_in_bytes avg_record_size_in_bytes forwarded_record_count compressed_page_count ----------- ----------- ----------- ---------------- ------------------------------------------------------------ ------------------------------------------------------------ ----------- ----------- ---------------------------- -------------------- -------------------------- -------------------- ------------------------------ -------------------- -------------------- -------------------------- ------------------------ ------------------------ ------------------------ ---------------------- --------------------- 6 1266103551 1 1 CLUSTERED INDEX IN_ROW_DATA 3 0 0.439882697947214 28 24.3571428571429 682 98.8644304423029 31465 0 0 154 195 171.487 NULL 0 6 1266103551 1 1 CLUSTERED INDEX IN_ROW_DATA 3 1 0 2 1 2 54.7442550037064 682 0 0 11 11 11 NULL 0 6 1266103551 1 1 CLUSTERED INDEX IN_ROW_DATA 3 2 0 1 1 1 0.296515937731653 2 0 0 11 11 11 NULL 0 6 1266103551 2 1 NONCLUSTERED INDEX IN_ROW_DATA 2 0 0 4 25.5 102 99.0670990857425 31465 0 0 24 24 24 NULL 0 6 1266103551 2 1 NONCLUSTERED INDEX IN_ROW_DATA 2 1 0 1 1 1 31.4801087225105 102 0 0 23 23 23 NULL 0 6 1266103551 3 1 NONCLUSTERED INDEX IN_ROW_DATA 2 0 0 3 36.3333333333333 109 99.8363355572029 31465 0 0 26 26 26 NULL 0 6 1266103551 3 1 NONCLUSTERED INDEX IN_ROW_DATA 2 1 0 1 1 1 36.3355572028663 109 0 0 25 25 25 NULL 0 6 1266103551 4 1 NONCLUSTERED INDEX IN_ROW_DATA 2 0 0 2 27.5 55 98.9285025945145 31465 0 0 12 12 12 NULL 0 6 1266103551 4 1 NONCLUSTERED INDEX IN_ROW_DATA 2 1 0 1 1 1 11.527057079318 55 0 0 15 15 15 NULL 0 6 1266103551 5 1 NONCLUSTERED INDEX IN_ROW_DATA 2 0 0 2 27.5 55 98.9285025945145 31465 0 0 12 12 12 NULL 0 6 1266103551 5 1 NONCLUSTERED INDEX IN_ROW_DATA 2 1 0 1 1 1 13.5656041512231 55 0 0 18 18 18 NULL 0
SELECT OBJECT_NAME (id) tablename , COUNT (1) nr_columns , SUM (length) maxrowlength FROM syscolumns GROUP BY OBJECT_NAME (id) ORDER BY OBJECT_NAME (id)
SELECT t.NAME AS TableName, s.Name AS SchemaName, p.rows AS RowCounts, SUM(a.total_pages) * 8 AS TotalSpaceKB, CAST(ROUND(((SUM(a.total_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS TotalSpaceMB, SUM(a.used_pages) * 8 AS UsedSpaceKB, CAST(ROUND(((SUM(a.used_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS UsedSpaceMB, (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB, CAST(ROUND(((SUM(a.total_pages) - SUM(a.used_pages)) * 8) / 1024.00, 2) AS NUMERIC(36, 2)) AS UnusedSpaceMB FROM sys.tables t INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id LEFT OUTER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN sysobjects so on t.object_id = so.id INNER JOIN syscolumns SC on (so.id = sc.id) INNER JOIN systypes st on (st.type = sc.type) WHERE t.NAME NOT LIKE AND t.is_ms_shipped = 0 AND i.OBJECT_ID > 255 AND so.type = and st.name IN ( GROUP BY t.Name, s.Name, p.Rows ORDER BY p.rows DESC
SELECT t.NAME AS TableName, s.Name AS SchemaName, p.rows AS RowCounts, SUM(a.total_pages) * 8 AS TotalSpaceKB, CAST(ROUND(((SUM(a.total_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS TotalSpaceMB, SUM(a.used_pages) * 8 AS UsedSpaceKB, CAST(ROUND(((SUM(a.used_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS UsedSpaceMB, (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB, CAST(ROUND(((SUM(a.total_pages) - SUM(a.used_pages)) * 8) / 1024.00, 2) AS NUMERIC(36, 2)) AS UnusedSpaceMB FROM sys.tables t INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id LEFT OUTER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE t.NAME NOT LIKE AND t.is_ms_shipped = 0 AND i.OBJECT_ID > 255 GROUP BY t.Name, s.Name, p.Rows ORDER BY t.Name
DECLARE @times int SET @times = SELECT COUNT(DidWin)as "I Win" FROM thetable WHERE DidWin = 1 AND Playername=
DECLARE @times int SELECT @times = COUNT(DidWin) FROM thetable WHERE DidWin = 1 AND Playername=
DECLARE @wins int, @losses int SELECT @wins = SUM(DidWin), @losses = SUM(DidLose) FROM thetable WHERE Playername=
DECLARE @wins int, @losses int SET (@wins, @losses) = (SELECT SUM(DidWin), SUM(DidLose) FROM thetable WHERE Playername=
DECLARE @times int SELECT @times = COUNT(DidWin) FROM thetable WHERE DidWin = 1 AND Playername=
SET @times = (SELECT COUNT(DidWin)as "I Win" FROM thetable WHERE DidWin = 1 AND Playername=
SELECT @MY_VAR = CAST(MY_FIELD AS INT) FROM MY_TABLE WHERE MY_OTHER_FIELD =
SELECT keycol, string, ISNUMERIC(string) AS is_numeric, CASE WHEN ISNUMERIC(string) = 0 THEN 0 WHEN string LIKE WHEN CAST(string AS NUMERIC(38, 0)) NOT BETWEEN -2147483648. AND 2147483647. THEN 0 ELSE 1 END AS is_int FROM dbo.T1;
SELECT keycol, string, ISNUMERIC(string) AS is_numeric, dbo.fn_IsInt(string) AS is_int FROM dbo.T1;
using System; using System.Data.SqlTypes; public partial class UserDefinedFunctions { [Microsoft.SqlServer.Server.SqlFunction] public static SqlBoolean fn_IsInt(SqlString s) { if (s.IsNull) return SqlBoolean.False; else { Int32 i = 0; return Int32.TryParse(s.Value, out i); } } };
WHERE IsNumeric(MY_FIELD) = 1 AND CAST(MY_FIELD as VARCHAR(5)) NOT LIKE
SELECT * FROM MY_TABLE WHERE CHARINDEX( AND ISNUMERIC(MY_FIELD) = 1 AND CONVERT(FLOAT,MY_FIELD) / 2147483647 <= 1
DECLARE @Converted as INT DECLARE @IsNumeric BIT BEGIN TRY SET @Converted = cast(@ValueToCheck as int) SET @IsNumeric=1 END TRY BEGIN CATCH SET @IsNumeric=0 END CATCH select IIF(@IsNumeric=1,
CASE WHEN ROUND(MY_FIELD,0)=MY_FIELD THEN CAST(MY_FIELD AS INT) ELSE MY_FIELD END as MY_FIELD2
var query = context.Post.Where(p => p.Id == postId).SingleOrDefault();
exec sp_executesql N [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[Slug] AS [Slug], [Extent1].[PubDate] AS [PubDate], [Extent1].[PostContent] AS [PostContent], [Extent1].[Author] AS [Author], [Extent1].[CommentEnabled] AS [CommentEnabled], [Extent1].[AttachmentId] AS [AttachmentId], [Extent1].[IsPublished] AS [IsPublished], [Extent1].[Hits] AS [Hits], [Extent1].[CategoryId] AS [CategoryId] FROM [dbo].[Post] AS [Extent1] WHERE [Extent1].[Id] = @p__linq__0
select substring(mo,charindex(mo, select mo=convert(varchar(2),month(created)) + ,qty=count(convert(varchar(2),month(created)) + from posts group by convert(varchar(2),month(created)) + ) a order by substring(mo,charindex(mo,
var grouped = from p in posts group p by new { month = p.Create.Month,year= p.Create.Year } into d select new { dt = string.Format("{0}/{1}",d.Key.month,d.Key.year), count = d.Count() };
var grouped = (from p in posts group p by new { month = p.Create.Month,year= p.Create.Year } into d select new { dt = string.Format("{0}/{1}",d.Key.month,d.Key.year), count = d.Count()}).OrderByDescending (g => g.dt);
yourCollection .OrderByDescending(x => x.OrderDate) .GroupBy(x => new {x.OrderDate.Year, x.OrderDate.Month}) .Select(x => new SelectListItem { Value = string.Format("{0}|{1}", x.Key.Year, x.Key.Month), Text = string.Format("{0}/{1} (Count: {2})", x.Key.Year, x.Key.Month, x.Count()) }) .ToList();
.Select(x => string.Format("{0}/{1} (Count: {2})", x.Key.Year, x.Key.Month, x.Count()))
from o in yg group o by o.OrderDate.ToString("MMM yyyy") into mg select new { Month = mg.Key, Orders = mg }
from o in yg group o by o.OrderDate.Month into mg select new { Month = mg.Key, Orders = mg }
List<leaveallview> lav = new List<leaveallview>(); lav = dbEntity.leaveallviews.Where(m =>m.created==alldate).ToList(); dynamic lav1 = lav.GroupBy(m=>m.created.Value.GetDateTimeFormats()).FirstOrDefault().ToList();
MERGE dbo.commissions_history AS target USING (SELECT @amount, @requestID) AS source (amount, request) ON (target.request = source.request) WHEN MATCHED THEN UPDATE SET amount = source.amount WHEN NOT MATCHED THEN INSERT (request, amount) VALUES (source.request, source.amount);
| Amount | Request | <other fields> | -------------------------------------------- | 12.00 | 1234 | <other data> | | 14.00 | 1235 | <other data> | | 15.00 | 1236 | <other data> |
DECLARE @Amount Decimal = 18.00; DECLARE @Request Int = 1234; MERGE dbo.commissions_history AS target USING (SELECT @amount, @requestID) AS source (amount, request) ON (target.request = source.request)
| Amount | Request | <other fields> | Source.Amount | Source.Request | ------------------------------------------------------------------------------ | 12.00 | 1234 | <other data> | 18.00 | 1234 | | 14.00 | 1235 | <other data> | null | null | | 15.00 | 1236 | <other data> | null | null |
WHEN MATCHED THEN UPDATE SET amount = source.amount
| Amount | Request | <other fields> | -------------------------------------------- | 18.00 | 1234 | <other data> | | 14.00 | 1235 | <other data> | | 15.00 | 1236 | <other data> |
DECLARE @Amount Decimal = 18.00; DECLARE @Request Int = 1239;
| Amount | Request | <other fields> | Source.Amount | Source.Request | ------------------------------------------------------------------------------ | 12.00 | 1234 | <other data> | null | null | | 14.00 | 1235 | <other data> | null | null | | 15.00 | 1236 | <other data> | null | null | | null | null | null | 18.00 | 1239 |
WHEN NOT MATCHED THEN INSERT (request, amount) VALUES (source.request, source.amount);
| Amount | Request | <other fields> | -------------------------------------------- | 12.00 | 1234 | <other data> | | 14.00 | 1235 | <other data> | | 15.00 | 1236 | <other data> | | 18.00 | 1239 | <other data> |
ts_DateTime |ID |Value|RowFilter|RequiredResult -------------------------- 2013/01/09 09:23:16 |8009 |0 |1 |1 2013/01/09 09:23:16 |8010 |0 |2 |1 2013/01/09 09:23:16 |8026 |0 |3 |1 2013/01/09 09:23:22 |8026 |0 |1 |2 2013/01/09 09:23:28 |8009 |0 |1 |3 2013/01/09 09:23:28 |8010 |0 |2 |3 2013/01/09 09:23:28 |8026 |0 |3 |3 2013/01/09 09:27:03 |8009 |0 |1 |4 2013/01/09 09:27:03 |8010 |0 |2 |4 2013/01/09 09:27:03 |8026 |0 |3 |4 2013/01/09 09:27:09 |8009 |0 |1 |5 2013/01/09 09:27:09 |8010 |0 |2 |5 2013/01/09 09:27:09 |8026 |0 |3 |5 2013/01/09 09:27:15 |8009 |0 |1 |6 2013/01/09 09:27:15 |8010 |0 |2 |6 2013/01/09 09:27:15 |8026 |0 |3 |6
select hl.ts_DateTime, hl.Tagname as [ID], hl.TagValue as [Value], ROW_NUMBER() OVER (PARTITION BY hl.ts_datetime ORDER BY hl.tagname) AS RowFilter from Table1 hl
SELECT hl.ts_DateTime, hl.Tagname as [ID], hl.TagValue as [Value], DENSE_RANK() OVER (ORDER BY ts_datetime) AS RowFilter FROM Table1 hl ORDER BY RowFilter
ROW_NUMBER() OVER (PARTITION BY hl.id ORDER BY hl.ts_DateTime) AS RowFilter
SELECT MyConcat( FROM SomeTable AS T WHERE T.SomeOtherColumn = SomeCondition
SomeTable: Id | TextColumn | SomeOtherColumn ----+------------+---------------- 1 | Qwerty | Y 2 | qwerty | N 3 | azerty | N 4 | Azerty | Y
SQL: SELECT MyConcat( FROM SomeTable AS T WHERE T.SomeOtherColumn = RESULT:
DECLARE @Result VARCHAR(MAX); SELECT @Result = CASE WHEN @Result IS NULL THEN T.TextColumn ELSE @Result + END FROM SomeTable AS T WHERE T.SomeOtherColumn = SELECT @Result
SELECT CAST(TextColumn + FROM SomeTable WHERE SomeOtherColumn = FOR XML PATH (
CREATE PROCEDURE [fooBar] @inputParam INT AS BEGIN IF @inputParam = 1 BEGIN ... END ELSE IF @inputParam = 3 BEGIN ... END ELSE IF @inputParam = 3 BEGIN ... END END
SELECT @Result = CASE @inputParam WHEN 1 THEN 1 WHEN 2 THEN 2 WHEN 3 THEN 1 ELSE 4 END IF @Result = 1 BEGIN ... END IF @Result = 2 BEGIN .... END IF @Result = 4 BEGIN END
CASE expression WHEN value1 THEN result1 WHEN value2 THEN result2 ... WHEN valueN THEN resultN [ ELSE elseResult ] END
SELECT * FROM dbo.[StateFixedTaxesCalculation](3020,16,1,1006)
SELECT * FROM Employee as E INNER JOIN dbo.[StateFixedTaxesCalculation](3020,16,1,1006) as TC ON TC.EmployeeId=E.EmployeeId
select * from Employee as E cross apply dbo.[StateFixedTaxesCalculation](3020, E.EmployeeId, 1, 1006) as TC
select * from Employee as E cross apply ( select TT.* from dbo.[StateFixedTaxesCalculation](3020, E.EmployeeId, 1, 1006) as TT where TT.EmployeeId = E.EmployeeId ) as TC
CREATE PROCEDURE getOrder (@orderId as numeric) AS BEGIN select order_address, order_number from order_table where order_id = @orderId select item, number_of_items, cost from order_line where order_id = @orderId END
CREATE PROCEDURE [dbo].[usp_SF_Read] AS SET NOCOUNT ON; CREATE TABLE , Document_status_definition_uid INT , Document_status_Code VARCHAR(100) , Attachment_count INT , PRIMARY KEY (Document_ID));
Partial Public Class StoredProcedures <Microsoft.SqlServer.Server.SqlProcedure()> _ Public Shared Sub usp_SF_ReadSFIntoTables() End Sub End Class
Dim dataset As DataSet = New DataSet With New SqlDataAdapter(cmd) .Fill(dataset) End With
if (N = -1 or N = 0) select ... if (N = -1 or N = 1) select ...
Example of query file named test.sql: use master; select name, crdate from sysdatabases where xtype= go Example of sqlcmd: sqlcmd -S %computername%\RLH -d play -i "test.sql" -o outfile.sql & notepad outfile.sql
create procedure DummyProc as begin set nocount on ... set nocount off end
declare @str nvarchar(50) = select UPPER(left(datename(mm,cast(@str+
DECLARE @exampleVal NVARCHAR(6) = SELECT CASE SUBSTRING(@exampleVal, 5, 2) WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN WHEN END + SUBSTRING(@exampleVal, 3, 2)
declare @myperiod nvarchar(10) SET @myperiod = SET @myperiod = @myperiod + SELECT UPPER(SUBSTRING(DATENAME(month, CONVERT(datetime, @myperiod)), 1, 3)) + SUBSTRING(CONVERT(varchar, DATEPART(year, CONVERT(datetime, @myperiod))), 3, 4)
DECLARE @STRING VARCHAR(10)= SELECT DATENAME(MONTH,@STRING+
declare @napis varchar(6)= SELECT UPPER(LEFT(DATENAME(month, @napis+
Declare @Period NVarchar (6) = N Declare @Format NVarchar (5) = N Select Upper(Format(DateFromParts(Left(@Period, 4), Right(@Period, 2), 1), @Format))
declare @test nvarchar(max) = select left(DATENAME(month, @test +
DECLARE @Date varchar(6) = SELECT REPLACE(SUBSTRING(CONVERT(char(9), CAST(@Date +
DECLARE @DATE NVARCHAR(6) = SELECT datename(MONTH,CONVERT(DATE,CONVERT(DATE,LEFT(@DATE,4)+
SELECT SUBSTRING(username, 1, CHARINDEX( SUBSTRING(username, CHARINDEX( FROM whereever
SELECT SUBSTRING(FullName, 1, CHARINDEX( REVERSE(SUBSTRING(REVERSE(FullName), 1, CHARINDEX( FROM [PERSON_TABLE]
Select LTRIM(RTRIM(SUBSTRING(FullName, 0, CHARINDEX( , LTRIM(RTRIM(SUBSTRING(FullName, CHARINDEX( FROM TABLE
validate last name is blank SELECT person.fullName, (CASE WHEN 0 = CHARINDEX( then person.fullName ELSE SUBSTRING(person.fullName, 1, CHARINDEX( (CASE WHEN 0 = CHARINDEX( THEN ELSE SUBSTRING(person.fullName,CHARINDEX( FROM person
SELECT CASE WHEN CHARINDEX( WHEN CHARINDEX( ELSE SUBSTRING(name,1, CHARINDEX( END [firstname] ,CASE WHEN CHARINDEX( WHEN CHARINDEX( ELSE SUBSTRING(name,CHARINDEX( END [lastname] FROM [myTable]
CREATE FUNCTION [dbo].[ufn_GetFirstName] ( @FullName varchar(500) ) RETURNS varchar(500) AS BEGIN -- Declare the return variable here DECLARE @RetName varchar(500) SET @FullName = replace( replace( replace( replace( @FullName, SELECT @RetName = CASE WHEN charindex( RETURN @RetName END
CREATE FUNCTION [dbo].[ufn_GetLastName] ( @FullName varchar(500) ) RETURNS varchar(500) AS BEGIN DECLARE @RetName varchar(500) IF(right(ltrim(rtrim(@FullName)), 2) &lt;&gt; BEGIN set @RetName = left( CASE WHEN charindex( replace( replace( replace( replace( replace( replace( @FullName, ) ) ) ) &gt; 0 THEN right( ltrim( rtrim( replace( replace( replace( replace( replace( replace( @FullName, ) ) , charindex( replace( replace( replace( replace( replace( replace( @FullName, ) ) ) ) - 1 ) ELSE , 25 ) END ELSE BEGIN SET @RetName = left( CASE WHEN charindex( replace( replace( replace( replace( replace( replace( replace( @FullName, ) ) ) ) &gt; 0 THEN right( ltrim( rtrim( replace( replace( replace( replace( replace( replace( replace( @FullName, ) ) , charindex( replace( replace( replace( replace( replace( replace( replace( @FullName, ) ) ) ) - 1 ) ELSE , 25 ) END RETURN @RetName END
SELECT dbo.ufn_GetFirstName(Fullname) as FirstName, dbo.ufn_GetLastName(Fullname) as LastName FROM
declare @FullName varchar(100)= Select LTRIM(RTRIM(SUBSTRING(@FullName, 0, CHARINDEX( , LTRIM(RTRIM(SUBSTRING(@FullName, CHARINDEX(
SELECT SUBSTRING(FirstAndSurnameCol, 0, CHARINDEX( SUBSTRING(FirstAndSurnameCol, CHARINDEX(
SELECT RTRIM(LEFT(FullName, CHARINDEX( SUBSTRING(FullName, CHARINDEX( FROM MyNameTable;
SELECT SUBSTRING(Name, 1, CHARINDEX( CASE WHEN LEFT(RIGHT(Name, 2), 1) <> THEN LTRIM(SUBSTRING(Name, CHARINDEX( ELSE LEFT(LTRIM(SUBSTRING(Name, CHARINDEX( LEN(LTRIM(SUBSTRING(Name, CHARINDEX( - 2) END FirstName , CASE WHEN LEFT(RIGHT(Name, 2), 1) = ELSE NULL END MiddleName
sum(cast(datediff(second, IEC.CREATE_DATE, IEC.STATUS_DATE) as float) / 60) TotalSentMinutes
FORMAT(sum(cast(datediff(second, IEC.CREATE_DATE, IEC.STATUS_DATE) as float) / 60),2) TotalSentMinutes
DECLARE @i FLOAT = 6.677756 SELECT ROUND(@i, 2) , FORMAT(@i, , CAST(@i AS DECIMAL(18,2)) , SUBSTRING(PARSENAME(CAST(@i AS VARCHAR(10)), 1), PATINDEX( , FLOOR((@i - FLOOR(@i)) * 100)
DECLARE @i AS FLOAT = 2 SELECT @i / 3 SELECT CAST(@i / 3 AS DECIMAL(18,2))
CAST(sum(cast(datediff(second, IEC.CREATE_DATE, IEC.STATUS_DATE) as float) / 60) AS numeric(10,2)) TotalSentMinutes
DECLARE @i AS FLOAT = 2 SELECT @i / 3 SELECT CAST(@i / 3 AS DECIMAL(18,2))
UserID CaseID Name 1 100 alan 1 101 alan 1 102 amy 1 103 system 1 104 ken 1 105 ken 1 106 system
SELECT COUNT(*), --total SUM(CASE WHEN name = FROM myTable
SELECT userid, COUNT(*) as TotalcaseID, --total SUM(CASE WHEN name = FROM myTable group by userid
select userid, count( count(case when name = from CustomerTable group by userid
SUM(CASE WHEN ColumnName = 1 THEN 1 ELSE 0 END) AS Pass, SUM(CASE WHEN ColumnName = 0 THEN 1 ELSE 0 END) AS Fail
declare @table table (columnName bit) insert into @table values (1) insert into @table values (1) insert into @table values (1) insert into @table values (1) insert into @table values (1) insert into @table values (0) insert into @table values (0) insert into @table values (0) insert into @table values (0) SELECT SUM(CASE WHEN ColumnName = 1 THEN 1 ELSE 0 END) AS True1 , SUM(CASE WHEN ColumnName = 0 THEN 1 ELSE 0 END ) AS False0 from @Table
True1 False0 ----------- ----------- 5 4 (1 row(s) affected)
SELECT Attribute, Class, SUM(CASE BitField WHEN 1 THEN 1 ELSE 0 END) AS [Pass], SUM(CASE BitField WHEN 0 THEN 1 ELSE 0 END) AS [Fail] FROM Table GROUP BY Attribute, Class
SELECT Attribute, Class COUNT(CASE WHEN ColumnName = 1 THEN 1 END) Pass, COUNT(CASE WHEN ColumnName = 0 THEN 1 END) Fail FROM YourTable GROUP BY Attribute, Class
SELECT Attribute, Class, COUNT(BoolColumnName = 1 or NULL) Pass, COUNT(BoolColumnName = 0 or NULL) Fail FROM Table GROUP BY Attribute, Class
Select I.Fee From Item I WHERE GETDATE() - I.DateCreated < 365 days
Select I.Fee From Item I WHERE DATEDIFF(day, GETDATE(), I.DateCreated) < 365
Select I.Fee From Item I WHERE DATEDIFF(day, GETDATE(), I.DateCreated) < 365
---------------------------------- -- Monitor time differences ---------------------------------- CREATE CLUSTERED INDEX dtIDX ON DECLARE @Stopwatch DATETIME SET @Stopwatch = GETDATE() -- SARGABLE SELECT * FROM WHERE MyDate > DATEADD(DAY, -364, PRINT DATEDIFF(MS, @Stopwatch, GETDATE()) SET @Stopwatch = GETDATE() -- NOT SARGABLE SELECT * FROM WHERE DATEDIFF(DAY, MyDate, PRINT DATEDIFF(MS, @Stopwatch, GETDATE())
SELECT I.Fee FROM Item I WHERE I.DateCreated > DATEADD(DAY, -364, GETDATE())
USE tempdb GO IF OBJECT_ID( DECLARE @Stopwatch DATETIME ---------------------------------- -- Build test data: 100000 rows ---------------------------------- ;WITH Base10 (n) AS ( SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 ) ,Base100000 (n) AS ( SELECT 1 FROM Base10 T1, Base10 T3, Base10 T4, Base10 T5, Base10 T6 ) SELECT MyDate = CAST(RAND(CHECKSUM(NEWID()))*3653.0+36524.0 AS DATETIME) INTO FROM Base100000 ---------------------------------- -- Monitor time differences ---------------------------------- SET @Stopwatch = GETDATE() -- NOT SARGABLE SELECT * FROM WHERE DATEDIFF(DAY, MyDate, PRINT DATEDIFF(MS, @Stopwatch, GETDATE()) SET @Stopwatch = GETDATE() -- SARGABLE SELECT * FROM WHERE MyDate > DATEADD(DAY, -364, PRINT DATEDIFF(MS, @Stopwatch, GETDATE())
Select I.Fee From Item I WHERE (days(GETDATE()) - days(I.DateCreated) < 365)
select * from Product if (@sortOrder = then order by name asc if (@sortOrder = then order by created_date asc if (@sortOrder = then order by name desc if (@sortOrder = then order by created_date desc
SELECT column_list_please FROM dbo.Product -- dbo prefix please ORDER BY CASE WHEN @sortDir = CASE WHEN @sortDir = CASE WHEN @sortDir = CASE WHEN @sortDir =
IF @sortDir NOT IN ( OR @sortOrder NOT IN ( BEGIN RAISERROR( RETURN; END DECLARE @sql NVARCHAR(MAX) = N FROM dbo.Product ORDER BY EXEC sp_executesql @sql;
order by (case when @sortOrder = (case when @sortOrder = (case when @sortOrder = (case when @sortOrder =
SELECT * FROM ( SELECT ROW_NUMBER() OVER ( ORDER BY CASE WHEN @sortOrder = END ASC, CASE WHEN @sortOrder = END DESC, CASE WHEN i(@sortOrder = END ASC, CASE WHEN i(@sortOrder = END ASC) RowNum * ) order by RowNum
SELECT sur.* ,MAX(bo.BOOL) FROM SURNAME sur INNER JOIN BOOL bo ON bo.IDPERS = sur.IDPERS
SELECT sur.* ,CAST(MAX(CAST(bo.BOOL as INT)) AS BIT) FROM SURNAME sur INNER JOIN BOOL bo ON bo.IDPERS = sur.IDPERS
SELECT sur.* ,MAX(convert(tinyint,bo.BOOL)) FROM SURNAME sur INNER JOIN BOOL bo ON bo.IDPERS = sur.IDPERS
declare @Surname as Table ( PersId Int, Name VarChar(10) ) insert into @Surname ( PersId, Name ) values ( 1, declare @Bool as Table ( PersId Int, Bool Bit ) insert into @Bool ( PersId, Bool ) values ( 1, 0 ), ( 1, 0 ), ( 2, 0 ), ( 2, 1 ), ( 4, 1 ), ( 4, 0 ), ( 4, 1 ) select Sur.PersId, Sur.Name, Sum( Cast( Bo.Bool as Int ) ) as [Sum], case Sum( Cast( Bo.Bool as Int ) ) when 1 then 1 else 0 end as [Only One] from @Surname as Sur left outer join @Bool as Bo on Bo.PersId = Sur.PersId group by Sur.PersId, Sur.Name order by Sur.Name
SELECT sur.* ,CAST(MAX(1 * bo.BOOL) AS BIT) FROM SURNAME sur INNER JOIN BOOL bo ON bo.IDPERS = sur.IDPERS
declare @tmp TABLE (code varchar(50), mount money) DECLARE @q nvarchar(4000) SET @q = INSERT INTO @tmp (code, mount) EXEC sp_executesql (@q) SELECT * from @tmp
CREATE TABLE DECLARE @q nvarchar(4000) SET @q = INSERT INTO EXEC sp_executesql (@q) SELECT * from
DECLARE @table TABLE (UserID varchar(100)) DECLARE @sql varchar(1000) SET @sql = INSERT INTO @table EXEC(@sql) SELECT * FROM @table
DECLARE @q nvarchar(4000) SET @q = INSERT INTO @tmp ( code, mount ) SELECT coa_code, amount FROM T_Ledger_detail SELECT * FROM @tmp' EXEC sp_executesql @q
delete from tblTable1 insert into tblTable1 select * from tblTable1_Link
Drop table tblTable1 select * into tblTable1 from tblTable1_Link
DECLARE @Table TABLE( Val1 VARCHAR(MAX) ) INSERT INTO @Table SELECT
DECLARE @Table TABLE( Val1 VARCHAR(MAX), Val2 VARCHAR(MAX) ) INSERT INTO @Table SELECT
DECLARE @Table TABLE( Val1 VARCHAR(MAX), Val2 VARCHAR(MAX) ) INSERT INTO @Table (Val1) SELECT
insert into blah (cola, colb, colc) select cola, colb, colc from blah2
create table foo ( field1 as int ,field2 as int ,field12 as field1 + field2 ) create table copyOfFoo ( field1 as int ,field2 as int ,field12 as field1 + field2) --this is the problem, should just be insert into copyOfFoo SELECT * FROM foo
declare @sql nvarchar(max) DECLARE @DB_SPACE TABLE ( [DatabaseName] NVARCHAR(128) NOT NULL, [FILEID] [smallint] NOT NULL, [FILE_SIZE_MB] INT NOT NULL DEFAULT (0), [SPACE_USED_MB] INT NULL DEFAULT (0), [FREE_SPACE_MB] INT NULL DEFAULT (0), [LOGICALNAME] SYSNAME NOT NULL, [DRIVE] NCHAR(1) NOT NULL, [FILENAME] NVARCHAR(260) NOT NULL, [FILE_TYPE] NVARCHAR(260) NOT NULL, [THE_AUTOGROWTH_IN_KB] INT NOT NULL DEFAULT(0) ,filegroup VARCHAR(128) ,maxsize VARCHAR(25) PRIMARY KEY CLUSTERED ([DatabaseName] ,[FILEID] ) ) SELECT @SQL = [FILEID], [FILE_SIZE_MB], [SPACE_USED_MB], [FREE_SPACE_MB], [LOGICALNAME], [DRIVE], [FILENAME], [FILE_TYPE], [THE_AUTOGROWTH_IN_KB] ,filegroup ,maxsize FROM OPENQUERY( exec sp_executesql @sql INSERT INTO @DB_SPACE( [DatabaseName], [FILEID], [FILE_SIZE_MB], [SPACE_USED_MB], [FREE_SPACE_MB], [LOGICALNAME], [DRIVE], [FILENAME], [FILE_TYPE], THE_AUTOGROWTH_IN_KB, [filegroup], maxsize ) EXEC SP_EXECUTESQL @SQL
SET @query = CREATE TABLE ( LogicalName nvarchar(128) ,PhysicalName nvarchar(128) ,[Type] char(1) ,FileGroupName nvarchar(128) ,[Size] numeric(20,0) ,[MaxSize] numeric(20,0) ,FileID bigint ,CreateLSN numeric(25,0) ,DropLSN numeric(25,0) NULL ,UniqueID uniqueidentifier ,ReadOnlyLSN numeric(25,0) ,ReadWriteLSN numeric(25,0) ,BackupSizeInByte bigint ,SourceBlockSize int ,FilegroupID int ,LogGroupGUID uniqueidentifier NULL ,DifferentialBaseLSN numeric(25,0) ,DifferentialbaseGUID uniqueidentifier ,IsReadOnly bit ,IsPresent bit ,TDEThumbprint varbinary(32) -- Added field 01.10.2018 needed from SQL Server 2016 (Azure URL) ,SnapshotURL nvarchar(360) ) INSERT SET @errorstat = @@ERROR if @errorstat <> 0 Begin if @Rueckgabe = 0 SET @Rueckgabe = 6 End Print @Rueckgabe
INSERT INTO destTable SELECT * FROM srcTable WHERE NOT EXISTS(SELECT * FROM destTable)
INSERT INTO destTable SELECT * FROM srcTable WHERE MyKey IN (SELECT MyKey FROM destTable)
INSERT INTO destTable SELECT Field1,Field2,Field3,... FROM srcTable WHERE NOT EXISTS(SELECT * FROM destTable WHERE (srcTable.Field1=destTable.Field1 and SrcTable.Field2=DestTable.Field2...etc.) )
INSERT INTO destTable SELECT s.field1,s.field2,s.field3,... FROM srcTable s LEFT JOIN destTable d ON (d.Key1 = s.Key1 AND d.Key2 = s.Key2 AND...) WHERE d.Key1 IS NULL
INSERT INTO destTable SELECT Distinct field1,field2,field3,... FROM srcTable
INSERT IGNORE INTO destTable SELECT id, field2,field3... FROM origTable
INSERT INTO destTable SELECT s.* FROM srcTable s LEFT JOIN destTable d ON d.Key1 = s.Key1 AND d.Key2 = s.Key2 AND... WHERE d.Key1 IS NULL
INSERT INTO `dTable` (`field1`, `field2`) SELECT field1, field2 FROM `sTable` WHERE `sTable`.`field1` NOT IN (SELECT `field1` FROM `dTable`)
INSERT INTO destTable SELECT DISTINCT * FROM srcTable
insert into tbl2 select field1,field2,... from tbl1 where not exists ( select field1,field2,... from person2 where (tbl1.field1=tbl2.field1 and tbl1.field2=tbl2.field2 and .....) )
SELECT DISTINCT column_name INTO newTable FROM srcTable
public function createTrainingDatabase($p_iRecordnr){ $aStudentcard = $this->fetchUsercardByRecordnr($p_iRecordnr); $iUserNumber = $aStudentcard[0][3]; $sNewDBName = $_SESSION[ $this->sPdoQuery = "CREATE DATABASE `".$sNewDBName."`;"; $this->PdoSqlReturnTrue(); $aTables = array( for ($iIndex = 0; $iIndex < count($aTables); $iIndex++) { $this->sPdoQuery = "CREATE TABLE `".$sNewDBName."`.`".$aTables[$iIndex]."` LIKE `".$_SESSION[ $bSuccess = $this->PdoSqlReturnTrue(); if(!$bSuccess ){echo("Could not create table: ".$aTables[$iIndex]."<BR>");} else{echo("Created the table ".$aTables[$iIndex]."<BR>");} $this->sPdoQuery = "REPLACE `".$sNewDBName."`.`".$aTables[$iIndex]."` SELECT * FROM `".$_SESSION[ $bSuccess = $this->PdoSqlReturnTrue(); if(!$bSuccess ){echo("Could not fill table: ".$aTables[$iIndex]."<BR>");} else{echo("Filled table ".$aTables[$index]."<BR>");} }
INSERT INTO destTable SELECT source.* FROM( SELECT * FROM srcTable EXCEPT SELECT src.* FROM srcTable AS src INNER JOIN destTable AS dest ON dest.SOME_FANCY_MATCH = src.SOME_FANCY_MATCH AND ... ) as source
DISABLE TRIGGER { [ schema_name . ] trigger_name [ ,...n ] | ALL } ON { object_name | DATABASE | ALL SERVER } [ ; ] ENABLE TRIGGER { [ schema_name . ] trigger_name [ ,...n ] | ALL } ON { object_name | DATABASE | ALL SERVER } [ ; ]
USE AdventureWorks; GO -- creating the table in AdventureWorks database IF OBJECT_ID( DROP TABLE dbo.Table1 GO CREATE TABLE dbo.Table1(ID INT) GO -- Creating a trigger CREATE TRIGGER TR_Test ON dbo.Table1 FOR INSERT,UPDATE,DELETE AS DECLARE @Cinfo VARBINARY(128) SELECT @Cinfo = Context_Info() IF @Cinfo = 0x55555 RETURN PRINT -- Actual code goes here -- For simplicity, I did not include any code GO
SET Context_Info 0x55555 INSERT dbo.Table1 VALUES(100)
IF OBJECT_ID( DROP PROCEDURE dbo.TriggerTest GO CREATE PROCEDURE [dbo].[TriggerTest] AS BEGIN TRANSACTION trnInsertTable1s ; DISABLE TRIGGER trg_tblTable1_IU ON tblTable1 ; BEGIN -- Procedure Code PRINT PRINT @@TRANCOUNT -- Do Stuff END -- Procedure Code ; ENABLE TRIGGER trg_tblTable1_IU ON tblTable1 IF @@ERROR <> 0 ROLLBACK TRANSACTION ELSE COMMIT TRANSACTION
ALTER VIEW myView AS SELECT * INTO SELECT * INTO SELECT * FROM UNION ALL SELECT * FROM DROP TABLE DROP TABLE
CREATE VIEW vSalesStaffQuickStats AS WITH SalesBySalesPerson (SalesPersonID, NumberOfOrders, MostRecentOrderDate) AS ( SELECT SalesPersonID, COUNT(*), MAX(OrderDate) FROM Sales.SalesOrderHeader GROUP BY SalesPersonID ) SELECT E.EmployeeID, EmployeeOrders = OS.NumberOfOrders, EmployeeLastOrderDate = OS.MostRecentOrderDate, E.ManagerID, ManagerOrders = OM.NumberOfOrders, ManagerLastOrderDate = OM.MostRecentOrderDate FROM HumanResources.Employee AS E INNER JOIN SalesBySalesPerson AS OS ON E.EmployeeID = OS.SalesPersonID LEFT JOIN SalesBySalesPerson AS OM ON E.ManagerID = OM.SalesPersonID GO
ALTER VIEW [dbo].[VW_PuntosDeControlDeExpediente] AS WITH TEMP (RefLocal, IdPuntoControl, Descripcion) AS ( SELECT EX.RefLocal , PV.IdPuntoControl , PV.Descripcion FROM [dbo].[PuntosDeControl] AS PV INNER JOIN [dbo].[Vertidos] AS VR ON VR.IdVertido = PV.IdVertido INNER JOIN [dbo].[ExpedientesMF] AS MF ON MF.IdExpedienteMF = VR.IdExpedienteMF INNER JOIN [dbo].[Expedientes] AS EX ON EX.IdExpediente = MF.IdExpediente ) SELECT Q1.[RefLocal] , [IdPuntoControl] = ( SELECT MAX(IdPuntoControl) FROM TEMP WHERE [RefLocal] = Q1.[RefLocal] AND [Descripcion] = Q1.[Descripcion] ) , Q1.[Descripcion] FROM TEMP AS Q1 GROUP BY Q1.[RefLocal], Q1.[Descripcion] GO
Table A Col1 Col2 ================ A11 A21 A22 A22 A33 A23 Table B Col1 Col2 Val ================= B11 B21 1 B12 B22 2 B13 B23 3
Select TableA.Col1, TableA.Col2, TableB.Val FROM TableA INNER JOIN TableB ON TableA.Col1 = TableB.Col1 OR TableA.Col2 = TableB.Col2 OR TableA.Col2 = TableB.Col1 OR TableA.Col1 = TableB.Col2
select tA.Col1, tA.Col2, tB.Val from TableA tA join TableB tB on ( tA.Col1 = tB.Col1 OR tA.Col1 = tB.Col2 ) AND ( tA.Col2 = tB.Col1 OR tA.Col2 = tB.Col2 )
Select TableA.Col1, TableA.Col2, TableB.Val FROM TableA, INNER JOIN TableB ON TableA.Col1 = TableB.Col1 OR TableA.Col2 = TableB.Col2
tableB.col1 = tableA.col1 OR tableB.col2 = tableA.col1 OR tableB.col1 = tableA.col2 OR tableB.col1 = tableA.col2
exec (your stored proc name) (and possibly add parameters)
SELECT j.name FROM msdb.dbo.sysjobs AS j WHERE EXISTS ( SELECT 1 FROM msdb.dbo.sysjobsteps AS s WHERE s.job_id = j.job_id AND s.command LIKE );
CREATE PROC [dbo].[restoreDB] @p_strDBNameTo SYSNAME, @p_strDBNameFrom SYSNAME, @p_strFQNRestoreFileName VARCHAR(255) AS DECLARE @v_strDBFilename VARCHAR(100), @v_strDBLogFilename VARCHAR(100), @v_strDBDataFile VARCHAR(100), @v_strDBLogFile VARCHAR(100), @v_strExecSQL NVARCHAR(1000), @v_strExecSQL1 NVARCHAR(1000), @v_strMoveSQL NVARCHAR(4000), @v_strREPLACE NVARCHAR(50), @v_strTEMP NVARCHAR(1000), @v_strListSQL NVARCHAR(4000), @v_strServerVersion NVARCHAR(20) SET @v_strREPLACE = IF exists (select name from sys.databases where name = @p_strDBNameTo) SET @v_strREPLACE = SET @v_strListSQL = SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SELECT @v_strServerVersion = CAST(SERVERPROPERTY ( IF @v_strServerVersion LIKE BEGIN SET @v_strListSQL = @v_strListSQL + --PRINT @v_strServerVersion END SET @v_strListSQL = @v_strListSQL + EXEC (@v_strListSQL) INSERT INTO DECLARE curFileLIst CURSOR FOR SELECT FROM SET @v_strMoveSQL = OPEN curFileList FETCH NEXT FROM curFileList into @v_strTEMP WHILE @@Fetch_Status = 0 BEGIN SET @v_strMoveSQL = @v_strMoveSQL + @v_strTEMP + FETCH NEXT FROM curFileList into @v_strTEMP END CLOSE curFileList DEALLOCATE curFileList PRINT -- Create the sql to kill the active database connections SET @v_strExecSQL = SELECT @v_strExecSQL = @v_strExecSQL + FROM master.dbo.sysprocesses WHERE DB_NAME(dbid) = @p_strDBNameTo AND DBID <> 0 AND spid <> @@spid EXEC (@v_strExecSQL) PRINT PRINT PRINT SET @v_strExecSQL = SET @v_strExecSQL = @v_strExecSQL + SET @v_strExecSQL = @v_strExecSQL + SET @v_strExecSQL = @v_strExecSQL + @v_strMoveSQL SET @v_strExecSQL = @v_strExecSQL + SET @v_strExecSQL = @v_strExecSQL + SET @v_strExecSQL = @v_strExecSQL + @v_strREPLACE --PRINT --PRINT @v_strExecSQL --PRINT EXEC sp_executesql @v_strExecSQL
declare @filelist table (LogicalName nvarchar(128), PhysicalName nvarchar(260), Type char(1), FilegroupName varchar(10), size int, MaxSize bigint, field int, createlsn bit, droplsn bit, uniqueid uniqueidentifier, readonlylsn bit, readwritelsn bit, backupsizeinbytes bigint, sourceblocksize int, filegroupid int, loggroupguid uniqueidentifier, differentialbaselsn bit, differentialbaseguid uniqueidentifier, isreadonly bit, ispresent bit, tdethumbprint varchar(5)); insert into @filelist exec sp_executesql N set @sql = N select @sql = @sql + N from @filelist; set @sql = substring(@sql, 1, len(@sql)-1); -- remove last exec sp_executesql @sql;
DECLARE @FileList TABLE ( LogicalName nvarchar(128) NOT NULL, PhysicalName nvarchar(260) NOT NULL, Type char(1) NOT NULL, FileGroupName nvarchar(120) NULL, Size numeric(20, 0) NOT NULL, MaxSize numeric(20, 0) NOT NULL, FileID bigint NULL, CreateLSN numeric(25,0) NULL, DropLSN numeric(25,0) NULL, UniqueID uniqueidentifier NULL, ReadOnlyLSN numeric(25,0) NULL , ReadWriteLSN numeric(25,0) NULL, BackupSizeInBytes bigint NULL, SourceBlockSize int NULL, FileGroupID int NULL, LogGroupGUID uniqueidentifier NULL, DifferentialBaseLSN numeric(25,0)NULL, DifferentialBaseGUID uniqueidentifier NULL, IsReadOnly bit NULL, IsPresent bit NULL, TDEThumbprint varbinary(32) NULL ); declare @RestoreStatement nvarchar(max), @BackupFile nvarchar(max); set @BackupFile = SET @RestoreStatement = N FROM DISK=N INSERT INTO @FileList EXEC(@RestoreStatement); declare @logical_data nvarchar(max), @logical_log nvarchar(max); set @logical_data = (select LogicalName from @FileList where Type = set @logical_log = (select LogicalName from @FileList where Type =
/* Automate restore w/o needing to know the logical file names. Specify destination database name, database backup source filename and .MDF, .LDF and .NDF directories. I do nightly automated database restores, and I Works for sql server 2008, might work for 2005. Created by wtm 5/27/2010 */ -- BEGIN - MODIFY THIS CODE - create a blank db if not exists(select * from master.sys.databases where [name]= begin create database sc end go -- END - MODIFY THIS CODE - create a blank db declare @strDatabase varchar(130)= declare @strBackupFile varchar(500)= declare @strRestoreMDFFilesTo varchar(500)= declare @strRestoreLDFFilesTo varchar(500)= declare @strRestoreNDFFilesTo varchar(500)= -- other variables used declare @strSQL nvarchar(max) declare @strOriginalPhysicalName varchar(150) declare @strPhysicalName varchar(150) declare @strLogicalName varchar(150) declare @intReturn int -- begin restoring begin try drop table end try begin catch end catch create table LogicalName varchar(64), PhysicalName varchar(130), [Type] varchar(1), FileGroupName varchar(64), Size decimal(20, 0) ,MaxSize decimal(25, 0), FileID bigint, CreateLSN decimal(25,0), DropLSN decimal(25,0), UniqueID uniqueidentifier ,ReadOnlyLSN decimal(25,0), ReadWriteLSN decimal(25,0), BackSizeInBytes decimal(25,0), SourceBlockSize int ,filegroupid int, loggroupguid uniqueidentifier, differentialbaseLSN decimal(25,0), differentialbaseGUID uniqueidentifier ,isreadonly bit, ispresent bit, TDEThumbpr decimal ) if not exists(select * from sc.sys.tables) or exists(select * from sc.sys.tables where [name]= begin print use master exec msdb.dbo.sp_delete_database_backuphistory @database_name = @strDatabase use [master] exec( use [master] exec( insert into exec( set @strSQL= set @strSQL=@strSQL+ set @strSQL=@strSQL+ set @strSQL=@strSQL+ set @strSQL=@strSQL+ while exists(select * from begin select top 1 @strOriginalPhysicalName=PhysicalName, @strLogicalName=LogicalName from set @strPhysicalName=@strOriginalPhysicalName set @strPhysicalName=reverse(@strPhysicalName) set @strPhysicalName=left(@strPhysicalName, charindex( set @strPhysicalName=reverse(@strPhysicalName) set @strPhysicalName=replace(@strPhysicalName, if @strPhysicalName like set @strPhysicalName=@strRestoreMDFFilesTo+@strPhysicalName else if @strPhysicalName like set @strPhysicalName=@strRestoreLDFFilesTo+@strPhysicalName else set @strPhysicalName=@strRestoreNDFFilesTo+@strPhysicalName set @strSQL=@strSQL+ delete from end execute @intReturn=sp_executesql @strSQL end
SET NOCOUNT ON Declare @BackupFiles varchar(500), @data_file_path VARCHAR(512), @log_file_path VARCHAR(512), @RestoreFileList varchar(2000), @RestoreStatement varchar(3000), @MoveFiles varchar(2000), @DBName varchar(150) DECLARE @filelist TABLE (LogicalName NVARCHAR(128) NOT NULL, PhysicalName NVARCHAR(260) NOT NULL, [Type] CHAR(1) NOT NULL, FileGroupName NVARCHAR(120) NULL, Size NUMERIC(20, 0) NOT NULL, MaxSize NUMERIC(20, 0) NOT NULL, FileID BIGINT NULL, CreateLSN NUMERIC(25,0) NULL, DropLSN NUMERIC(25,0) NULL, UniqueID UNIQUEIDENTIFIER NULL, ReadOnlyLSN NUMERIC(25,0) NULL , ReadWriteLSN NUMERIC(25,0) NULL, BackupSizeInBytes BIGINT NULL, SourceBlockSize INT NULL, FileGroupID INT NULL, LogGroupGUID UNIQUEIDENTIFIER NULL, DfferentialBaseLSN NUMERIC(25,0)NULL, DifferentialBaseGUID UNIQUEIDENTIFIER NULL, IsReadOnly BIT NULL, IsPresent BIT NULL, TDEThumbprint VARBINARY(32) NULL) SET @data_file_path = SET @log_file_path = SET @DBName = --Get last full backup: SELECT @BackupFiles=Coalesce(@BackupFiles + FROM msdb..backupset S JOIN msdb..backupmediafamily M ON M.media_set_id=S.media_set_id WHERE backup_set_id = ( SELECT max(backup_set_id) FROM msdb..backupset S JOIN msdb..backupmediafamily M ON M.media_set_id=S.media_set_id WHERE S.database_name = @DBName and Type = SELECT @RestoreFileList= IF (@@microsoftversion / 0x1000000) & 0xff >= 10 --TDE capability Begin INSERT into @filelist (LogicalName,PhysicalName,Type,FileGroupName,Size,MaxSize,FileID,CreateLSN,DropLSN,UniqueID,ReadOnlyLSN,ReadWriteLSN,BackupSizeInBytes,SourceBlockSize,FileGroupID,LogGroupGUID,DfferentialBaseLSN,DifferentialBaseGUID,IsReadOnly,IsPresent,TDEThumbprint) EXEC (@RestoreFileList) End Else Begin INSERT into @filelist (LogicalName,PhysicalName,Type,FileGroupName,Size,MaxSize,FileID,CreateLSN,DropLSN,UniqueID,ReadOnlyLSN,ReadWriteLSN,BackupSizeInBytes,SourceBlockSize,FileGroupID,LogGroupGUID,DfferentialBaseLSN,DifferentialBaseGUID,IsReadOnly,IsPresent) EXEC (@RestoreFileList) End --next version, do a count on filename, any >1 put in alternate data/log location. SELECT @MoveFiles=Coalesce(@MoveFiles + Case When type = when type = Else END + From @filelist SELECT @RestoreStatement= Print @RestoreStatement Exec(@RestoreStatement)
use master -- -- check SQL Server version DECLARE @sql_ver int; CREATE TABLE ( [Index] int, [Name] nvarchar(100), [iVal] int, [cVal] nvarchar(100) ) INSERT INTO IF (SELECT cast(cVal as char(2)) FROM SET @sql_ver = 8; ELSE SET @sql_ver = 9; DROP TABLE -- -- get mdf/ldf names DECLARE @mdf_name varchar(50) DECLARE @ldf_name varchar(50) DECLARE @RestoreFileListOnly_columns varchar(2000) IF (@sql_ver = 8) BEGIN SET @RestoreFileListOnly_columns = ' LogicalName nvarchar(128), PhysicalName nvarchar(260), [Type] char(1), FileGroupName nvarchar(128), [Size] numeric(20,0), [MaxSize] numeric(20,0), ' END ELSE BEGIN SET @RestoreFileListOnly_columns = ' LogicalName nvarchar(128), PhysicalName nvarchar(260), [Type] char(1), FileGroupName nvarchar(128), [Size] numeric(20,0), [MaxSize] numeric(20,0), FileID bigint, CreateLSN numeric(25,0), DropLSN numeric(25,0) NULL, UniqueID uniqueidentifier, ReadOnlyLSN numeric(25,0) NULL, ReadWriteLSN numeric(25,0) NULL, BackupSizeInBytes bigint, SourceBlockSize int, FileGroupID int, LogGroupGUID uniqueidentifier NULL, DifferentialBaseLSN numeric(25,0) NULL, DifferentialBaseGUID uniqueidentifier, IsReadOnly bit, IsPresent bit ' DECLARE @tmp_ver NVARCHAR(20) SELECT @tmp_ver = CAST(SERVERPROPERTY ( IF @tmp_ver LIKE BEGIN SET @RestoreFileListOnly_columns = @RestoreFileListOnly_columns + END END IF EXISTS (SELECT [table_name] FROM information_schema.tables WHERE [table_name] = BEGIN DROP TABLE [tmp_RestoreFileListOnly]; END EXEC ( INSERT INTO tmp_RestoreFileListOnly EXEC( PRINT --IF @@ROWCOUNT <> 2 RETURN SELECT @mdf_name = LogicalName FROM tmp_RestoreFileListOnly WHERE Type = SELECT @ldf_name = LogicalName FROM tmp_RestoreFileListOnly WHERE Type = DROP TABLE tmp_RestoreFileListOnly
-- Use VARCHAR as the restore statement doesn DECLARE @data_file_path VARCHAR(512), @log_file_path VARCHAR(512), @backup_path VARCHAR(512), @backup_extension VARCHAR(4), @mdf_extension VARCHAR(4), @ldf_extension VARCHAR(4) -- ** VARIABLES THAT MUST BE SET **-- SET @data_file_path = SET @log_file_path = SET @backup_path = -- **----------------------------**-- SET @backup_extension = SET @mdf_extension = SET @ldf_extension = DECLARE @DATABASES_TO_RESTORE TABLE (rownum int IDENTITY (1, 1) PRIMARY KEY NOT NULL, backup_name VARCHAR(64), restore_as VARCHAR(64)) -- ** Declare the Databases to be Restored ** -- INSERT INTO @DATABASES_TO_RESTORE SELECT UNION SELECT -- ** -------------------------------------** -- DECLARE @max_rows INT, @row_count INT SET @row_count = 1 SELECT @max_rows=count(*) FROM @DATABASES_TO_RESTORE WHILE @row_count <= @max_rows BEGIN DECLARE @backup_name VARCHAR(32), @restore_as VARCHAR(32), @logical_data_name VARCHAR(64), @logical_log_name VARCHAR(64), @data_file_full_path VARCHAR(512), @log_file_full_path VARCHAR(512), @full_backup_path VARCHAR(MAX) SELECT @backup_name = backup_name, @restore_as = restore_as FROM @DATABASES_TO_RESTORE WHERE rownum = @row_count SET @full_backup_path = @backup_path + @backup_name + @backup_extension DECLARE @filelist TABLE (LogicalName NVARCHAR(128) NOT NULL, PhysicalName NVARCHAR(260) NOT NULL, [Type] CHAR(1) NOT NULL, FileGroupName NVARCHAR(120) NULL, Size NUMERIC(20, 0) NOT NULL, MaxSize NUMERIC(20, 0) NOT NULL, FileID BIGINT NULL, CreateLSN NUMERIC(25,0) NULL, DropLSN NUMERIC(25,0) NULL, UniqueID UNIQUEIDENTIFIER NULL, ReadOnlyLSN NUMERIC(25,0) NULL , ReadWriteLSN NUMERIC(25,0) NULL, BackupSizeInBytes BIGINT NULL, SourceBlockSize INT NULL, FileGroupID INT NULL, LogGroupGUID UNIQUEIDENTIFIER NULL, DfferentialBaseLSN NUMERIC(25,0)NULL, DifferentialBaseGUID UNIQUEIDENTIFIER NULL, IsReadOnly BIT NULL, IsPresent BIT NULL, TDEThumbprint VARBINARY(32) NULL) INSERT into @filelist EXEC ( IF @@ROWCOUNT = 2 BEGIN SELECT @logical_data_name = LogicalName FROM @filelist WHERE [Type] = SELECT @logical_log_name = LogicalName FROM @filelist WHERE [Type] = SET @data_file_full_path = @data_file_path + @restore_as + @mdf_extension SET @log_file_full_path = @log_file_path + @restore_as + @ldf_extension RESTORE DATABASE @restore_as FROM DISK = @full_backup_path WITH FILE = 1, MOVE @logical_data_name TO @data_file_full_path, MOVE @logical_log_name TO @log_file_full_path END ELSE PRINT SELECT @row_count = @row_count + 1 END
SELECT top(1) @v_strRestorePath = physical_name FROM sys.master_files
USE [master] GO SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO IF OBJECT_ID( DROP PROC [dbo].[restoreDB] GO CREATE PROC [dbo].[restoreDB] @p_strDBNameTo SYSNAME, @p_strDBNameFrom SYSNAME, @p_strFQNRestoreFileName VARCHAR(255) AS DECLARE @v_strDBFilename VARCHAR(100), @v_strDBLogFilename VARCHAR(100), @v_strDBDataFile VARCHAR(100), @v_strDBLogFile VARCHAR(100), @v_strExecSQL NVARCHAR(1000), @v_strExecSQL1 NVARCHAR(1000), @v_strMoveSQL NVARCHAR(4000), @v_strREPLACE NVARCHAR(50), @v_strTEMP NVARCHAR(1000), @v_strListSQL NVARCHAR(4000), @v_strServerVersion NVARCHAR(20), @v_strRestorePath varchar(500) SET @v_strREPLACE = IF exists (select name from sys.databases where name = @p_strDBNameTo) SET @v_strREPLACE = SET @v_strListSQL = SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SELECT @v_strServerVersion = CAST(SERVERPROPERTY ( IF @v_strServerVersion LIKE BEGIN SET @v_strListSQL = @v_strListSQL + --PRINT @v_strServerVersion END SET @v_strListSQL = @v_strListSQL + EXEC (@v_strListSQL) -- We want to get the current data path from this server as the backup file paths may not be the same on the server -- especially wehen switching between Express/Standard instances SELECT top(1) @v_strRestorePath = physical_name FROM sys.master_files; set @v_strRestorePath = REPLACE(@v_strRestorePath, RIGHT(@v_strRestorePath, CHARINDEX( --print @v_strRestorePath --' INSERT INTO -- want to see whats in the fillist? --SELECT * FROM DECLARE curFileLIst CURSOR FOR -- Here we restore each file to the current server restore path. Right(...) grabs the file name from the back up SELECT FROM SET @v_strMoveSQL = OPEN curFileList FETCH NEXT FROM curFileList into @v_strTEMP WHILE @@Fetch_Status = 0 BEGIN SET @v_strMoveSQL = @v_strMoveSQL + @v_strTEMP + FETCH NEXT FROM curFileList into @v_strTEMP END CLOSE curFileList DEALLOCATE curFileList PRINT -- Create the sql to kill the active database connections SET @v_strExecSQL = SELECT @v_strExecSQL = @v_strExecSQL + FROM master.dbo.sysprocesses WHERE DB_NAME(dbid) = @p_strDBNameTo AND DBID <> 0 AND spid <> @@spid EXEC (@v_strExecSQL) PRINT PRINT PRINT SET @v_strExecSQL = SET @v_strExecSQL = @v_strExecSQL + SET @v_strExecSQL = @v_strExecSQL + SET @v_strExecSQL = @v_strExecSQL + @v_strMoveSQL SET @v_strExecSQL = @v_strExecSQL + SET @v_strExecSQL = @v_strExecSQL + SET @v_strExecSQL = @v_strExecSQL + @v_strREPLACE --PRINT --PRINT @v_strExecSQL --PRINT --For Some reason the file list hangs when I was debugging remove it. IF (EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = BEGIN DROP TABLE END EXEC sp_executesql @v_strExecSQLter
CREATE PROC [dbo].[restoreDB] @p_strDBNameTo SYSNAME, @p_strDBNameFrom SYSNAME, @p_strBackupDirectory VARCHAR(255), @p_strRestoreDirectory VARCHAR(255), @p_strFQNBackupFileName VARCHAR(255) AS DECLARE @v_strDBFilename VARCHAR(200), @v_strDBLogFilename VARCHAR(200), @v_strDBDataFile VARCHAR(200), @v_strDBLogFile VARCHAR(200), @v_strExecSQL NVARCHAR(MAX), @v_strMoveSQL NVARCHAR(MAX), @v_strREPLACE NVARCHAR(50), @v_strTEMP NVARCHAR(1000), @v_strListSQL NVARCHAR(4000), @v_strServerVersion NVARCHAR(20) SET @v_strREPLACE = IF exists (select name from sys.databases where name = @p_strDBNameTo) SET @v_strREPLACE = SET @v_strListSQL = SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SET @v_strListSQL = @v_strListSQL + SELECT @v_strServerVersion = CAST(SERVERPROPERTY ( IF @v_strServerVersion LIKE BEGIN SET @v_strListSQL = @v_strListSQL + --PRINT @v_strServerVersion END SET @v_strListSQL = @v_strListSQL + EXEC (@v_strListSQL) INSERT INTO DECLARE curFileLIst CURSOR FOR SELECT FROM SET @v_strMoveSQL = cast( OPEN curFileList FETCH NEXT FROM curFileList into @v_strTEMP WHILE @@Fetch_Status = 0 BEGIN SET @v_strMoveSQL = @v_strMoveSQL + cast(@v_strTEMP as nvarchar(max)) + cast( FETCH NEXT FROM curFileList into @v_strTEMP END CLOSE curFileList DEALLOCATE curFileList PRINT -- Create the sql to kill the active database connections SET @v_strExecSQL = SELECT @v_strExecSQL = @v_strExecSQL + FROM master.dbo.sysprocesses WHERE DB_NAME(dbid) = @p_strDBNameTo AND DBID <> 0 AND spid <> @@spid EXEC (@v_strExecSQL) PRINT PRINT PRINT SET @v_strExecSQL = cast( SET @v_strExecSQL = @v_strExecSQL + cast( SET @v_strExecSQL = @v_strExecSQL + cast( SET @v_strExecSQL = @v_strExecSQL + @v_strMoveSQL SET @v_strExecSQL = @v_strExecSQL + cast( SET @v_strExecSQL = @v_strExecSQL + cast( SET @v_strExecSQL = @v_strExecSQL + cast(@v_strREPLACE as nvarchar(max)) --If want to print string need to do in sections due to limitation of print string length PRINT PRINT substring(@v_strExecSQL,0,3999) PRINT substring(@v_strExecSQL,4000,7999) PRINT substring(@v_strExecSQL,8000,11999) PRINT substring(@v_strExecSQL,12000,15999) PRINT substring(@v_strExecSQL,16000,19999) PRINT substring(@v_strExecSQL,20000,23999) PRINT substring(@v_strExecSQL,24000,27999) PRINT substring(@v_strExecSQL,28000,31999) PRINT substring(@v_strExecSQL,32000,35999) EXEC sp_executesql @v_strExecSQL GO
;WITH Query(Result) As ( SELECT SELECT ) SELECT DISTINCT s.* FROM Street s JOIN Query q ON StreetName LIKE q.Result
SELECT DISTINCT s.* FROM Street s JOIN CarStreets cs ON s.StreetName LIKE cs.name + WHERE cs.Streets =
SELECT * FROM Street Where StreetName IN (dbo.FindStreetNameFunction(
CREATE FUNCTION [dbo].[SplitList] ( @list nvarchar(MAX), @delim nvarchar(5) ) RETURNS @splitTable table ( value nvarchar(50) ) AS BEGIN While (Charindex(@delim, @list)>0) Begin Insert Into @splitTable (value) Select ltrim(rtrim(Substring(@list, 1, Charindex(@delim, @list)-1))) Set @list = Substring(@list, Charindex(@delim, @list)+len(@delim), len(@list)) End Insert Into @splitTable (value) Select ltrim(rtrim(@list)) Return END
declare @sql nvarchar(MAX), @subWhere nvarchar(MAX) @params nvarchar(MAX) -- prepare the where sub-clause to cover LIKE IN (...) -- it will actually generate where sub clause StreetName Like option1 or StreetName Like option2 or ... set @subWhere = STUFF( ( --(**) SELECT FOR XML PATH( ), 1, 4, -- create the dynamic SQL set @sql = where ( -- and any additional query params here, if needed, like AND StreetMinHouseNumber = @minHouseNumber AND StreetNumberOfHouses between (@minNumberOfHouses and @maxNumberOfHouses)' set @params = @minNumberOfHouses int, @minNumberOfHouses int EXECUTE sp_executesql @sql, @params, @minHouseNumber, @minNumberOfHouses, @minNumberOfHouses
SELECT * FROM [DatasourceQuery] WHERE Query IN LIKE ( SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES )
create function [splitDelimeter](@str nvarchar(max), @delimeter nvarchar(10)= returns @r table(val nvarchar(max)) as begin declare @x nvarchar(max)=@str set @x= declare @xx xml=cast(@x as xml) insert @r(val) SELECT Tbl.Col.value( FROM @xx.nodes( return end
declare @s nvarchar(max)= select a.* from street a left join gen.splitDelimeter(@s, on a.streetname like b.val where val is not null
SELECT * FROM codes WHERE SUBSTRING(code, 1, 12) IN (
create table Employees (id int identity, Name varchar(50), Password varchar(50)) create table Log (id int identity, EmployeeId int, LogDate datetime, OldName varchar(50)) go create trigger Employees_Trigger_Update on Employees after update as insert into Log (EmployeeId, LogDate, OldName) select id, getdate(), name from deleted go insert into Employees (Name, Password) values ( insert into Employees (Name, Password) values ( update Employees set Name = select * from Log
id EmployeeId LogDate OldName 1 1 2010-07-05 20:11:54.127 Zaphoid
CREATE TRIGGER trgEmployeeUpdate ON dbo.Employees AFTER UPDATE AS INSERT INTO dbo.LogTable(ID, OldValue, NewValue) SELECT i.ID, d.Name, i.Name FROM Inserted i INNER JOIN Deleted d ON i.ID = d.ID
createTRIGGER [dbo].[Table] ON [dbo].[table] FOR UPDATE AS declare @empid int; declare @empname varchar(100); declare @empsal decimal(10,2); declare @audit_action varchar(100); declare @old_v varchar(100) select @empid=i.Col_Name1 from inserted i; select @empname=i.Col_Name2 from inserted i; select @empsal=i.Col_Name2 from inserted i; select @old_v=d.Col_Name from deleted d if update(Col_Name1) set @audit_action= if update(Col_Name2) set @audit_action= insert into Employee_Test_Audit1(Col_name1,Col_name2,Col_name3,Col_name4,Col_name5,Col_name6(Old_values)) values(@empid,@empname,@empsal,@audit_action,getdate(),@old_v); PRINT
SELECT count(ImageId) as [IndividualRemaining], userMaster.empName AS ID CONVERT(DATETIME, folderDetails.folderName, 101) AS FolderDate, batchDetails.batchName AS Batch Client=@ClientName, TotalInloaded = IsNull(@TotalInloaded,0), PendingUnassigned = @PendingUnassigned, InloadedAssigned = IsNull(@TotalAssigned,0), TotalProcessed = @TotalProcessed, Remaining = @Remaining FROM batchDetails Left JOIN folderDetails ON batchDetails.folderId = folderDetails.folderId Left JOIN imageDetails ON batchDetails.batchId = imageDetails.batchId Left JOIN userMaster ON imageDetails.assignedToUser = userMaster.userId WHERE folderDetails.ClientId =@ClientID and verifyflag= and folderDetails.FolderName IN (SELECT convert(VARCHAR,Value) FROM dbo.Split(@Output, and userMaster.empName <> GROUP BY userMaster.empName, folderDetails.folderName, batchDetails.batchName Order BY folderDetails.Foldername asc
SELECT * FROM main_table LEFT JOIN sub_table ON main_table.ID = sub_table.main_table_ID LEFT JOIN sub_sub_table on main_table.ID = sub_sub_table.main_table_ID
Below is the output: Year Quarter 2008 2008-Q1 2007 2007-Q3
SELECT DATENAME(Quarter, CAST(CONVERT(VARCHAR(8), datecolumn) AS DATETIME))
CAST(year(TheDate) AS char(4)) + CAST(CEILING(CAST(month(TheDate) AS decimal(9,2)) / 3) AS char(1))
SELECT convert(char(10), getdate(), 101) AS TheDate, CAST(year(getdate()) AS char(4)) + CAST(CEILING(CAST(month(getdate()) AS decimal(4,2)) / 3) AS char(1)) AS SelectQuarter
TheDate SelectQuarter ---------- ------------- 07/10/2013 2013-Q3
WITH Quarters AS ( SELECT Q = SELECT Q = SELECT Q = SELECT Q = ) SELECT [Year] = DATEPART(yyyy, CONVERT(DATETIME, Dates.[date])), [Quarter] = CONVERT(VARCHAR(4), DATEPART(yyyy, CONVERT(DATETIME, Dates.[date]))) + FROM (VALUES ( ( ) AS Dates ([date]) INNER JOIN Quarters q ON DATEPART(m, CONVERT(DATETIME, Dates.[date])) >= q.MonthBegin AND DATEPART(m, CONVERT(DATETIME, Dates.[date])) <= q.MonthEnd;
Year Quarter ----- ---------- 2008 2008-Q1 2007 2007-Q3
WITH Quarters AS ( SELECT Q = SELECT Q = SELECT Q = SELECT Q = ) SELECT [Year] = DATEPART(yyyy, CONVERT(DATETIME, CONVERT(VARCHAR(8), Dates.[date]))), [Quarter] = CONVERT(VARCHAR(4), DATEPART(yyyy, CONVERT(DATETIME, CONVERT(VARCHAR(8), Dates.[date])))) + FROM (VALUES (20080102), (20070821) ) AS Dates ([date]) INNER JOIN Quarters q ON DATEPART(m, CONVERT(DATETIME, CONVERT(VARCHAR(8), Dates.[date]))) >= q.MonthBegin AND DATEPART(m, CONVERT(DATETIME, CONVERT(VARCHAR(8), Dates.[date]))) <= q.MonthEnd;
declare @date int set @date = 20080102 SELECT Datename(quarter, Cast(left(@date, 4) + + substring(cast(@date as char(8)), 5, 2) + + substring(cast(@date as char(8)), 7, 2) as datetime)) as Quarter
SELECT Datename(quarter, Cast(left(@date, 4) + + substring(cast(@date as char(8)), 5, 2) + + right(@date, 2) as datetime)) as quarter
SELECT left(@date, 4) + + substring(cast(@date as char(8)), 5, 2) + + right(@date, 2) as datetime))) as quarter
create table the_table ( [DateKey] INT, ) insert into the_table values (20120101), (20120102), (20120201), (20130601) WITH myDateCTE(DateKey, Date) as ( SELECT DateKey ,[Date] = CONVERT(DATETIME, CONVERT(CHAR(8),DateKey),112) FROM the_table ) SELECT t.[DateKey] , m.[Date] , [QuarterNumber] = CONVERT(VARCHAR(20),Datepart(qq,Date)) , [QuarterString] = , [Year] = Datepart(yyyy,Date) , [Q-Yr] = CONVERT(VARCHAR(2), FROM the_table t inner join myDateCTE m on t.DateKey = m.DateKey
SELECT Q.DateInQuarter, D.[Year], Quarter = D.Year + + Convert(varchar(1), ((Q.DateInQuarter % 10000 - 100) / 300 + 1)) FROM dbo.QuarterDates Q CROSS APPLY ( VALUES (Convert(varchar(4), Q.DateInQuarter / 10000)) ) D ([Year]) ;
select DatePart(QUARTER, cast(cast(mydate as char(8)) as date))
SELECT CASE WHEN @TODAY BETWEEN @FY_START AND DATEADD(M, 3, @FY_START) THEN WHEN @TODAY BETWEEN DATEADD(M, 3, @FY_START) AND DATEADD(M, 6, @FY_START) THEN WHEN @TODAY BETWEEN DATEADD(M, 6, @FY_START) AND DATEADD(M, 9, @FY_START) THEN WHEN @TODAY BETWEEN DATEADD(M, 9, @FY_START) AND DATEADD(M, 12, @FY_START) THEN END
SET IDENTITY_INSERT [MyDB].[dbo].[Equipment] ON INSERT INTO [MyDB].[dbo].[Equipment] SELECT * FROM [MyDBQA].[dbo].[Equipment] SET IDENTITY_INSERT [MyDB].[dbo].[Equipment] OFF
SET IDENTITY_INSERT [MyDB].[dbo].[Equipment] ON INSERT INTO [MyDB].[dbo].[Equipment] (COL1, COL2) SELECT COL1, COL2 FROM [MyDBQA].[dbo].[Equipment] SET IDENTITY_INSERT [MyDB].[dbo].[Equipment] OFF
SET IDENTITY_INSERT [MyDB].[dbo].[Equipment] ON INSERT INTO [MyDB].[dbo].[Equipment] (Col1, Col2, ...) SELECT Col1, Col2, ... FROM [MyDBQA].[dbo].[Equipment] SET IDENTITY_INSERT [MyDB].[dbo].[Equipment] OFF
sqlQuery = "SET IDENTITY_INSERT dbo.TheTable ON; INSERT INTO dbo.TheTable (Col1, COl2) VALUES (Val1, Val2); SET IDENTITY_INSERT dbo.TheTable OFF;"
CREATE View [dbo].[TopUsersTest] as select u.[DisplayName] , sum(a.AnswerMark) as Marks From Users_Questions us inner join [dbo].[Users] u on u.[UserID] = us.[UserID] inner join [dbo].[Answers] a on a.[AnswerID] = us.[AnswerID] group by [DisplayName] order by Marks desc OFFSET 0 ROWS
CREATE VIEW [dbo].[TopUsersTest] AS SELECT u.[DisplayName], SUM(a.AnswerMark) AS Marks FROM dbo.Users_Questions AS uq INNER JOIN [dbo].[Users] AS u ON u.[UserID] = us.[UserID] INNER JOIN [dbo].[Answers] AS a ON a.[AnswerID] = uq.[AnswerID] GROUP BY u.[DisplayName];
CREATE VIEW dbo.SillyView AS SELECT TOP 100 PERCENT SalesOrderID, OrderDate, CustomerID , AccountNumber, TotalDue FROM Sales.SalesOrderHeader ORDER BY CustomerID; GO SELECT SalesOrderID, OrderDate, CustomerID, AccountNumber, TotalDue FROM dbo.SillyView;
SalesOrderID OrderDate CustomerID AccountNumber TotalDue ------------ ---------- ---------- -------------- ---------- 43659 2005-07-01 29825 10-4020-000676 23153.2339 43660 2005-07-01 29672 10-4020-000117 1457.3288 43661 2005-07-01 29734 10-4020-000442 36865.8012 43662 2005-07-01 29994 10-4020-000227 32474.9324 43663 2005-07-01 29565 10-4020-000510 472.3108
SELECT SalesOrderID, OrderDate, CustomerID, AccountNumber, TotalDue FROM dbo.SillyView ORDER BY CustomerID;
SalesOrderID OrderDate CustomerID AccountNumber TotalDue ------------ ---------- ---------- -------------- ---------- 43793 2005-07-22 11000 10-4030-011000 3756.989 51522 2007-07-22 11000 10-4030-011000 2587.8769 57418 2007-11-04 11000 10-4030-011000 2770.2682 51493 2007-07-20 11001 10-4030-011001 2674.0227 43767 2005-07-18 11001 10-4030-011001 3729.364
SELECT C.CustomerID, C.CustomerName, C.CustomerAge FROM dbo.Customer C ORDER BY CustomerAge OFFSET 0 ROWS;
SELECT TOP(SELECT COUNT(SNO) From MyTable) * FROM bar WITH(NOLOCK) ORDER BY SNO
CREATE VIEW [schema].[VIEWNAME] ( [COLUMN1], [COLUMN2], [COLUMN3], [COLUMN4]) AS SELECT TOP 100 PERCENT alias.[COLUMN1], alias.[COLUMN2], alias.[COLUMN3], alias.[COLUMN4] FROM [schema].[TABLENAME] AS alias ORDER BY alias.COLUMN1 GO
CREATE VIEW [dbo].[SQLSTANDARDS_PSHH] AS SELECT TOP 99999999999999 Column1, Column2 FROM dbo.Table Order by Column1
DELETE FROM Tasks WHERE ID not IN (SELECT TaskID FROM TimeEntries)
DELETE FROM Tasks WHERE ID not IN ( SELECT TaskID FROM TimeEntries WHERE TaskID is not null )
DELETE FROM Tasks WHERE NOT EXISTS (SELECT 1 FROM TimeEntries WHERE TimeEntries.TaskID = Tasks.ID )
MERGE Tasks AS target USING TimeEntries as Source ON (Target.TaskID=Source.TaskID) WHEN NOT MATCHED BY Source THEN DELETE;
DELETE FROM Tasks FROM Tasks LEFT OUTER JOIN TimeEntries ON TimeEntries.TaskID = Tasks.ID WHERE TimeEntries.TaskID IS NULL;
alter table mytable alter column mycolumn set default(now()) --mycolumn is a datetime
ALTER TABLE dbo.mytable ADD CONSTRAINT def_mycolumn DEFAULT GETDATE() FOR mycolumn
ALTER TABLE <TABLE> DROP CONSTRAINT <CONSTRAINT NAME> ALTER TABLE <TABLE> ADD CONSTRAINT <CONSTRAINT NAME> DEFAULT <VALUE> for <COLUMN>
CREATE TABLE [dbo].[Company]( [ID] [int], [CompanyName] [varchar](20) )
EXEC sys.sp_rename @objname = N @newname = @objtype =
create table insert insert insert insert insert select NTILE(2) over(order by Marks),* from order by Marks
StudentID MARKS NTILE S5 93 1 S3 91 1 S2 83 1 S4 83 2 S1 75 2
StudentID MARKS NTILE S5 93 1 S3 91 1 S2 83 2 S4 83 2 S1 75 3
SELECT registrationDate, (SELECT COUNT(*) FROM Articles WHERE userId = Users.userId) as articleNumber, hobbies, ... FROM USERS
SELECT registrationDate, (SELECT COUNT(*) FROM Articles WHERE Articles.userId = Users.userId) as articleNumber, ranking = CASE WHEN articleNumber < 2 THEN WHEN articleNumber < 5 THEN WHEN articleNumber < 7 THEN WHEN articleNumber < 9 THEN WHEN articleNumber < 12 THEN ELSE END, hobbies, etc... FROM USERS
SELECT *, (CASE WHEN articleNumber < 2 THEN WHEN articleNumber < 5 THEN WHEN articleNumber < 7 THEN WHEN articleNumber < 9 THEN WHEN articleNumber < 12 THEN ELSE END) AS ranking FROM( SELECT registrationDate, (SELECT COUNT(*) FROM Articles WHERE Articles.userId = Users.userId) as articleNumber, hobbies, etc... FROM USERS )x
SELECT registrationDate, (SELECT CASE WHEN COUNT(*)< 2 THEN WHEN COUNT(*)< 5 THEN WHEN COUNT(*)< 7 THEN WHEN COUNT(*)< 9 THEN WHEN COUNT(*)< 12 THEN ELSE END as a FROM Articles WHERE Articles.userId = Users.userId) as ranking, (SELECT COUNT(*) FROM Articles WHERE userId = Users.userId) as articleNumber, hobbies, etc... FROM USERS
WITH CTE_A As (SELECT COUNT(*) as articleNumber,A.UserID as UserID FROM Articles A Inner Join Users U on A.userId = U.userId Group By A.userId , U.userId ), B as (Select us.registrationDate, CASE WHEN CTE_A.articleNumber < 2 THEN WHEN CTE_A.articleNumber < 5 THEN WHEN CTE_A.articleNumber < 7 THEN WHEN CTE_A.articleNumber < 9 THEN WHEN CTE_A.articleNumber < 12 THEN ELSE END as Ranking, us.hobbies, etc... FROM USERS Us Inner Join CTE_A on CTE_A.UserID=us.UserID) Select * from B
DECLARE @SQL nvarchar(4000), @Table varchar(20) = @IDColumn varchar(20) = @ID int = 10248 SET @SQL = + @IDColumn + EXEC sp_executesql @SQL, N
WITH q (value) AS ( SELECT NULL UNION ALL SELECT 1 ), p (value) AS ( SELECT NULL UNION ALL SELECT 2 ) SELECT * FROM q WHERE value NOT IN ( SELECT value FROM p )
WITH q (value) AS ( SELECT NULL UNION ALL SELECT 1 ), p (value) AS ( SELECT NULL UNION ALL SELECT 2 ) SELECT * FROM q WHERE NOT EXISTS ( SELECT NULL FROM p WHERE p.value = q.value )
WITH q (value) AS ( SELECT NULL UNION ALL SELECT 1 ), p (value) AS ( SELECT NULL UNION ALL SELECT 2 ) SELECT * FROM q EXCEPT SELECT * FROM p
WITH q (value) AS ( SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 ), rec (value) AS ( SELECT value FROM q UNION ALL SELECT * FROM ( SELECT value FROM q EXCEPT SELECT value FROM rec ) q2 ) SELECT TOP 10 * FROM rec --- 1 2 3 -- original set 1 2 -- everything except the last row of the previous set, that is 3 1 3 -- everything except the last row of the previous set, that is 2 1 2 -- everything except the last row of the previous set, that is 3, etc. 1
alter table MyTable add constraint UK_MyTable_MyUniqueKey unique nonclustered (MyCol)
insert into MyTable (MyCol) values ( insert into MyTable (MyCol) values (
ALTER TABLE mytable ALTER COLUMN mycolumn VARCHAR(10) COLLATE SQL_Latin1_General_CP1_CS_AS
CREATE TABLE tname2 (etc.) INSERT INTO tname2 FROM tname1 DROP TABLE tname1 CREATE TABLE tname1 (with IDENTITY specified) SET IDENTITY_INSERT tname1 ON INSERT INTO tname1 FROM tname2 SET IDENTITY_INSERT tname1 OFF DROP tname2
-- make sure you have the correct CREATE TABLE script ready with IDENTITY SELECT * INTO abcTable_copy FROM abcTable DROP TABLE abcTable CREATE TABLE abcTable -- this time with the IDENTITY column SET IDENTITY_INSERT abcTable ON INSERT INTO abcTable (..specify all columns!) FROM (..specify all columns!) abcTable_copy SET INDENTITY_INSERT abcTable OFF DROP TABLE abcTable_copy -- I would suggest to verify the contents of both tables -- before dropping the copy table
alter table tablename alter column columnname add Identity(100,1)
SELECT DISTINCT TOP 1000 id, uname, tel FROM Users ORDER BY <sort_columns>
SELECT DISTINCT * FROM ( SELECT TOP 1000 id, uname, tel FROM Users ORDER BY <sort_columns> ) u
SELECT DISTINCT * from [order_items] where productid in (SELECT productid FROM [order_items] group by productid having COUNT(*)>0) order by productid
SELECT DISTINCT productid, MAX(id) OVER (PARTITION BY productid) AS LastRowId from [order_items] where productid in (SELECT productid FROM [order_items] group by productid having COUNT(*)>0) order by productid
select distinct result.* from data d cross apply (select top 1 * from data where data.Id = d.Id) result
with org_table as (select 1 id, from dual union select 1, from dual union select 2, from dual union select 2, select id, uname from (select a.id, a.uname, ROW_NUMBER() OVER(PARTITION BY a.id ORDER BY a.id) AS freq from org_table a) where freq = 1
with org_table as (select 1 id, from dual union select 1, from dual union select 2, from dual union select 2, select a.id, (select b.uname from org_table b where b.id = a.id and rownum = 1) from (select distinct id from org_table) a
IF EXISTS(SELECT 1 FROM Contacs WHERE [Type] = 1) UPDATE Contacs SET [Deleted] = 1 WHERE [Type] = 1
-- For each row in source IF EXISTS(<target_expression>) IF @delete_flag = 1 DELETE <target_expression> ELSE UPDATE target SET <target_columns> = <source_values> WHERE <target_expression> ELSE INSERT target (<target_columns>) VALUES (<source_values>)
-- For each row in source BEGIN TRAN UPDATE target SET <target_columns> = <source_values> WHERE <target_expression> IF (@@ROWCOUNT = 0) INSERT target (<target_columns>) VALUES (<source_values>) COMMIT
BEGIN TRAN INSERT target (<target_columns>) SELECT <source_columns> FROM source s WHERE s.id NOT IN (SELECT id FROM target) UPDATE t SET <target_columns> = <source_columns> FROM target t INNER JOIN source s ON t.d = s.id DELETE t FROM target t WHERE t.id NOT IN (SELECT id FROM source) COMMIT
MERGE target USING source ON target.id = source.id WHEN MATCHED THEN UPDATE <target_columns> = <source_columns> WHEN NOT MATCHED THEN INSERT (<target_columns>) VALUES (<source_columns>) WHEN NOT MATCHED BY SOURCE THEN DELETE;
update a set .. where .. if @@rowcount > 0 begin .. end
CREATE TABLE dbo.TwoINTs ( ID INT NOT NULL PRIMARY KEY, i1 INT NOT NULL , i2 INT NOT NULL , version ROWVERSION ) ; GO INSERT INTO dbo.TwoINTs ( ID, i1, i2 ) VALUES ( 1, 0, 0 ) ;
-- hit Ctrl+T to execute in text mode SET NOCOUNT ON ; DECLARE @ID INT ; SET @ID = 0 ; WHILE @ID > -100000 BEGIN ; SET @ID = ( SELECT MIN(ID) FROM dbo.TwoINTs ) - 1 ; BEGIN TRY ; BEGIN TRANSACTION ; IF EXISTS ( SELECT * FROM dbo.TwoINTs WHERE ID = @ID ) BEGIN ; UPDATE dbo.TwoINTs SET i1 = 1 WHERE ID = @ID ; END ; ELSE BEGIN ; INSERT INTO dbo.TwoINTs ( ID, i1, i2 ) VALUES ( @ID, 0, 0 ) ; END ; COMMIT ; END TRY BEGIN CATCH ; ROLLBACK ; SELECT error_message() ; END CATCH ; END ;
IF EXISTS(SELECT 1 FROM mytable WHERE someColumn = someValue)
INSERT Contacs (col1, col2, etc) values (val1, val2, etc) where not exists (select 1 from Contacs where col1 = val1) IF @@rowcount = 0 then <didn
WITH SomeClause1 AS ( SELECT .... ) WITH SomeClause2 AS ( SELECT .... )
;WITH SomeClause1 AS ( SELECT .... ) , SomeClause2 AS ( SELECT .... )
;WITH SomeClause1 AS ( SELECT .... ) ,SomeClause2 AS ( SELECT .... )
CREATE FUNCTION [dbo].[ft_SplitStringOnChar] ( @s varchar(8000), @sep char(1) ) RETURNS TABLE AS RETURN ( WITH Pieces(pn, start, stop) AS ( SELECT 1, 1, CHARINDEX(@sep, @s) UNION ALL SELECT pn + 1, stop + 1, CHARINDEX(@sep, @s, stop + 1) FROM Pieces WHERE stop > 0 ) SELECT pn AS TokenNumber, SUBSTRING(@s, start, CASE WHEN stop > 0 THEN stop-start ELSE 512 END) AS TokenString FROM Pieces ) GO This does not: CREATE FUNCTION [dbo].[ft_SplitStringOnChar] ( @s varchar(8000), @sep char(1) ) RETURNS TABLE AS BEGIN ; RETURN ( WITH Pieces(pn, start, stop) AS ( SELECT 1, 1, CHARINDEX(@sep, @s) UNION ALL SELECT pn + 1, stop + 1, CHARINDEX(@sep, @s, stop + 1) FROM Pieces WHERE stop > 0 ) SELECT pn AS TokenNumber, SUBSTRING(@s, start, CASE WHEN stop > 0 THEN stop-start ELSE 512 END) AS TokenString FROM Pieces ) END GO
Msg 208, Level 16, State 1, Line 27 Invalid object name
DBCC results for There are 13 rows in 1 pages for object "table_name". DBCC execution completed. If DBCC printed error messages, contact your system administrator.
DECLARE @x BIGINT SET @x = 100 SELECT CAST(@x AS VARCHAR(2))
DECLARE @x INT SET @x = 100 SELECT CAST(@x AS VARCHAR(2))
DECLARE @i INT SET @i = 100 SELECT CAST(@i AS VARCHAR(2)) -- result: go DECLARE @i INT SET @i = 100 SELECT CAST(@i AS NVARCHAR(2)) -- result: Arithmetic overflow error
right(str(100+@x),2) -- for a function, same idea: -- create function zeroPad( @yourNum int, @wid int) as begin return right( 1000000+@yourNum), @wid) end
DECLARE @Number int = 1; SELECT RIGHT( --OR SELECT RIGHT(CONVERT(VARCHAR, 100 + @Number), 2) GO
select case when teamId < 10 then else cast(teamId as char(2)) end as * from team
Create function fsPadLeft(@var varchar(200),@padChar char(1)= returns varchar(300) as Begin return replicate(@PadChar,@len-Len(@var))+@var end
declare @value int; set @value =2 select dbo.fsPadLeft(@value,
SELECT RIGHT( SELECT RIGHT( SELECT RIGHT( SELECT RIGHT( SELECT RIGHT(
;with numcte as( select 2 as rn union all select rn+1 from numcte where rn<90)
number 002 003 004 005 006 007 008 009 10 11 12 13 14 15 16 17 18 19 20
CREATE FUNCTION [dbo].[f_convert_int_to_2_digits](@input int) RETURNS varchar(10) AS BEGIN --return value DECLARE @return varchar(10) if @input < 10 begin set @return = end else begin set @return = convert(varchar(10), @input) end -- return result RETURN @return END
Select Table_name as "Table name" From Information_schema.Tables Where Table_type = (Object_id(Table_name),
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME LIKE
select * from information_schema.columns where table_name =
SELECT table_name FROM information_schema.tables WHERE table_name LIKE
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME LIKE
Msg 8152, Level 16, State 14, Line 249 String or binary data would be truncated. The statement has been terminated.
DECLARE @error INT SELECT @error = 0 BEGIN TRANSACTION --** begin import TSQL --** end import TSQL SELECT @error = @@error IF @error != 0 GOTO handle_error COMMIT handle_error: IF @error != 0 BEGIN ROLLBACK END
BEGIN TRANSACTION BEGIN TRY --Run your Statements COMMIT TRANSACTION END TRY BEGIN CATCH ROLLBACK TRANSACTION DECLARE @Msg NVARCHAR(MAX) SELECT @Msg=ERROR_MESSAGE() RAISERROR( END CATCH
ReviewID---ReviewDate---User 1----------12/1/2009----Bob 1----------12/1/2009----Joe 1----------12/1/2009----Frank 2----------12/9/2009----Sue 2----------12/9/2009----Alice
ReviewID---ReviewDate----Users 1----------12/1/2009-----Bob, Joe, Frank 2----------12/9/2009-----Sue, Alice
SELECT p1.CategoryId, ( SELECT ProductName + FROM Northwind.dbo.Products p2 WHERE p2.CategoryId = p1.CategoryId ORDER BY ProductName FOR XML PATH( ) AS Products FROM Northwind.dbo.Products p1 GROUP BY CategoryId;
DECLARE @Reviews TABLE( ReviewID INT, ReviewDate DATETIME ) DECLARE @Reviewers TABLE( ReviewerID INT, ReviewID INT, UserID INT ) DECLARE @Users TABLE( UserID INT, FName VARCHAR(50), LName VARCHAR(50) ) INSERT INTO @Reviews SELECT 1, INSERT INTO @Reviews SELECT 2, INSERT INTO @Users SELECT 1, INSERT INTO @Users SELECT 2, INSERT INTO @Users SELECT 3, INSERT INTO @Users SELECT 4, INSERT INTO @Users SELECT 5, INSERT INTO @Reviewers SELECT 1, 1, 1 INSERT INTO @Reviewers SELECT 2, 1, 2 INSERT INTO @Reviewers SELECT 3, 1, 3 INSERT INTO @Reviewers SELECT 4, 2, 4 INSERT INTO @Reviewers SELECT 5, 2, 5 SELECT *, ( SELECT u.FName + FROM @Users u INNER JOIN @Reviewers rs ON u.UserID = rs.UserID WHERE rs.ReviewID = r.ReviewID FOR XML PATH( ) AS Products FROM @Reviews r
select replace(replace(replace((cast(( select distinct columnName as X from tableName for xml path(
declare @result varchar(1000) select @result = COALESCE(@result+ FROM ( select col1 from [table] ) A select @result
SELECT Reviews.ReviewID, ReviewDate, dbo.StringUtilities.Concat(FName) AS [User] FROM Reviews INNER JOIN Reviewers ON Reviews.ReviewID = Reviewers.ReviewID INNER JOIN Users ON Reviews.UserID = Users.UserID GROUP BY ReviewID, ReviewDate;
select p1.Availability ,COUNT(*), (select name+ p1.Availability=p2.Availability for XML path( as Name from AdventureWorks2008.Production.Location p1 group by Availability
Availability COUNT Name --------------------------------------------------------------------------------- 0.00 7 Tool Crib,Sheet Metal Racks,Paint Shop,Paint Storage,Metal Storage,Miscellaneous Storage,Finished Goods Storage, 80.00 1 Specialized Paint, 96.00 1 Frame Forming, 108.00 1 Frame Welding, 120.00 4 Debur and Polish,Paint,Subassembly,Final Assembly,
SELECT p1.CategoryId, dbo.GetProductNames(p1.CategoryId) FROM Northwind.dbo.Products p1 GROUP BY CategoryId
Declare @Revs Table (RevId int Priimary Key Not Null, RevDt DateTime Null, users varChar(1000) default Insert @Revs (RevId, RevDt) Select Distinct ReviewId, ReviewDate From Reviews Declare @UId Integer Set @Uid = 0 While Exists (Select * From Users Where UserID > @Uid) Begin Update @Revs Set users = users + u.fName + From @Revs R Join Reviewers uR On ur.ReviewId = R.RId Join users u On u.UserId = uR.UserId Where uR.UserId = @UId Select @Uid = Min(UserId) From users Where UserId > @UId End Select * From @Revs
Select R.ReviewID, ReviewDate , (Select FName + from Users where UserID = R.UserID order by FName FOR XML PATH( ) as [Users] from Reviews inner join Reviewers AS R On Reviews.ReviewID = R.ReviewID Group By R.ReviewID, ReviewDate;
SELECT STRING_AGG ( ISNULL(FirstName, FROM Person.Person;
CREATE TABLE ReviewId INT, ReviewDate DATETIME, Reviewer VARCHAR(1000)) INSERT INTO SELECT r.ReviewId, r.ReviewDate, u.FName FROM Reviews r JOIN Reviewers rs ON r.ReviewId = rs.ReviewId JOIN Users u ON u.UserId = rs.UserId SELECT ReviewId, ReviewDate, LEFT(Users, LEN(Users)-1) FROM ( SELECT ReviewId, ReviewDate, ( SELECT Reviewer + FROM WHERE ri2.ReviewId = ri1.ReviewId ORDER BY Reviewer FOR XML PATH( ) AS Users FROM GROUP BY ReviewId, ReviewDate ) a DROP TABLE
select p1.Availability, COUNT(*), ( select name+ from AdventureWorks2008.Production.Location p2 where p1.Availability=p2.Availability for XML path( ).value( from AdventureWorks2008.Production.Location p1 group by Availability
declare @t table (col1 int, col2 varchar) insert into @t VALUES (1, insert into @t VALUES (1, insert into @t VALUES (1, insert into @t VALUES (1, insert into @t VALUES (1, insert into @t VALUES (2, insert into @t VALUES (3, select col1, MAX(CASE seq WHEN 1 THEN col2 ELSE MAX(CASE seq WHEN 2 THEN MAX(CASE seq WHEN 3 THEN MAX(CASE seq WHEN 4 THEN MAX(CASE seq WHEN 5 THEN as col2 from ( select col1, col2, ROW_NUMBER() OVER ( PARTITION BY col1 ORDER BY col2 ) seq from @t group by col1, col2 ) x group by col1
STRING_AGG ( expression, separator ) [ <order_clause> ] <order_clause> ::= WITHIN GROUP ( ORDER BY <order_by_expression_list> [ ASC | DESC ] )
SELECT Name FROM Employees WHERE Salary = ( SELECT DISTINCT TOP (1) Salary FROM Employees WHERE Salary NOT IN (SELECT DISTINCT TOP (1) Salary FROM Employees ORDER BY Salary DESCENDING) ORDER BY Salary DESCENDING)
;WITH T AS ( SELECT *, DENSE_RANK() OVER (ORDER BY Salary Desc) AS Rnk FROM Employees ) SELECT Name FROM T WHERE Rnk=2;
SELECT Name FROM Employees WHERE Salary = (SELECT MIN(Salary) FROM (SELECT DISTINCT TOP (2) Salary FROM Employees ORDER BY Salary DESC) T);
CREATE TABLE Employees ( Name VARCHAR(50), Salary FLOAT ) INSERT INTO Employees SELECT TOP 1000000 s1.name, abs(checksum(newid())) FROM sysobjects s1, sysobjects s2 CREATE NONCLUSTERED INDEX ix ON Employees(Salary) SELECT Name FROM Employees WHERE Salary = (SELECT MIN(Salary) FROM (SELECT DISTINCT TOP (2) Salary FROM Employees ORDER BY Salary DESC) T); WITH T AS (SELECT *, DENSE_RANK() OVER (ORDER BY Salary DESC) AS Rnk FROM Employees) SELECT Name FROM T WHERE Rnk = 2; SELECT Name FROM Employees WHERE Salary = (SELECT DISTINCT TOP (1) Salary FROM Employees WHERE Salary NOT IN (SELECT DISTINCT TOP (1) Salary FROM Employees ORDER BY Salary DESC) ORDER BY Salary DESC) SELECT Name FROM Employees WHERE Salary = (SELECT TOP 1 Salary FROM (SELECT TOP 2 Salary FROM Employees ORDER BY Salary DESC) sel ORDER BY Salary ASC)
SELECT MIN(SALARY) FROM EMP WHERE SALARY in (SELECT DISTINCT TOP 2 SALARY FROM EMP ORDER BY SALARY DESC)
;WITH Salaries AS ( SELECT Name, Salary, DENSE_RANK() OVER(ORDER BY Salary DESC) AS FROM dbo.Employees ) SELECT Name, Salary FROM Salaries WHERE SalaryRank = 2
select * from (select * from (select * from (select * from emp order by sal desc) where rownum<=:N ) order by sal ) where rownum=1;
select * from (select * from (select * from (select distinct(sal) from emp order by 1 desc) where rownum<=:N ) order by sal ) where rownum=1;
select * from ( select tout.sal, id, (select count(*) +1 from (select distinct(sal) distsal from EMPLOYEE ) where distsal >tout.sal) as rank from EMPLOYEE tout ) result order by rank
select * from ( select tout.sal, id, (select count(*) +1 from (select distinct(sal) distsal from EMPLOYEE ) where distsal >tout.sal) as rank from EMPLOYEE tout ) result where rank = N;
select MAX(Salary) from Employee WHERE Salary NOT IN (select MAX(Salary) from Employee );
SELECT MAX(salary) FROM Employee WHERE Salary NOT IN (SELECT Max(Salary) FROM Employee); SELECT MAX(Salary) From Employee WHERE Salary < (SELECT Max(Salary) FROM Employee); SELECT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1; SELECT Salary FROM (SELECT Salary FROM Employee ORDER BY Salary DESC LIMIT 2) AS Emp ORDER BY Salary LIMIT 1;
CREATE TABLE ( Id INT, Name NVARCHAR(12), Salary MONEY ) SELECT x.Name, x.Salary FROM ( SELECT Name, Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) as Rnk FROM ) x WHERE x.Rnk = 2
select * from emp e1 where 2 =(select count(distinct(salary)) from emp e2 where e2.emp >= e1.emp)
select * from emp where salary = ( select salary from (select ROW_NUMBER() over (order by salary) as from emp) t -- Order employees according to salary where rownum = 2 -- Get the second highest salary )
select max(age) from yd where age<(select max(age) from HK) ; SELECT * FROM HK E1 WHERE 1 =(SELECT COUNT(DISTINCT age) FROM HK E2 WHERE E1.age < E2.age); select age from hk e1 where (3-1) = (select count(distinct (e2.age)) from yd e2 where e2.age>e1.age); select max(age) from YD where age not in (select max(age) from YD);
select e2.max(sal), e2.name from emp e2 where (e2.sal <(Select max (Salary) from empo el)) group by e2.name
SELECT * FROM TABLE1 AS A WHERE NTH HIGHEST NO.(SELECT COUNT(ATTRIBUTE) FROM TABLE1 AS B) WHERE B.ATTRIBUTE=A.ATTRIBUTE;
select max(column_name) from table_name where column_name<(select max(column_name) from table_name)
SELECT name FROM employee WHERE salary = (SELECT MIN(salary) FROM (SELECT TOP (2) salary FROM employee ORDER BY salary DESC) )
SELECT employee_name FROM employee WHERE salary = (SELECT max(salary) FROM employee WHERE salary < (SELECT max(salary) FROM employee);
select * from ( select name,salary,ROW_NUMBER() over( order by Salary desc) as rownum from employee ) as t where t.rownum=2
SELECT * FROM emp e1 WHERE 2 = ( SELECT COUNT(salary) FROM emp e2 WHERE e2.salary >= e1.salary )
select * from emp where salary In (select MAX(salary) from emp where salary NOT IN (Select MAX(salary) from emp));
select min(temp.salary) from (select * from emp order by salary desc limit 2) temp;
SELECT Name FROM Employees group BY Salary DESCENDING limit 2;
SELECT * FROM emp WHERE salary = (SELECT max(e1.salary) FROM emp e1 WHERE e1.salary < (SELECT Max(e2.salary) FROM emp e2))**
select name from employee where salary=(select max(salary) from(select salary from employee minus select max(salary) from employee));
SELECT name FROM `emp` WHERE salary = ( SELECT salary FROM emp e ORDER BY salary DESC LIMIT 1 OFFSET 1
declare cntr number :=0; cursor c1 is select salary from employees order by salary desc; z c1%rowtype; begin open c1; fetch c1 into z; while (c1%found) and (cntr <= 1) loop cntr := cntr + 1; fetch c1 into z; dbms_output.put_line(z.salary); end loop; end;
SELECT MAX(Salary) FROM Employee WHERE Salary NOT IN (SELECT MAX(Salary) FROM Employee)
Select top 1 start at 2 salary from employee group by salary order by salary desc;
- Method 1 select max(salary) from Employees where salary< (select max(salary) from Employees) - Method 2 select MAX(salary) from Employees where salary not in(select MAX(salary) from Employees) - Method 3 select MAX(salary) from Employees where salary!= (select MAX(salary) from Employees )
Insert Into Select Union ALL Select Union ALL Select Union ALL Select Union ALL Select
select top 1 * from Where a.id <> (Select top 1 b.id from order by a.Salary desc
SELECT `salary` AS emp_sal, `name` , `id` FROM `employee` GROUP BY `salary` ORDER BY `salary` DESC LIMIT 1 , 1
SELECT CASE @Type WHEN 1 THEN INSERT INTO dbo.Credit ( CompanyName, PhoneNumber, City, State ) VALUES ( @CompanyName, @PhoneNumber, @City, @State) WHEN 2 THEN INSERT INTO dbo.Debit ( CompanyName, PhoneNumber, City, State ) VALUES ( @CompanyName, @PhoneNumber, @City, @State) WHEN 3 THEN --ETC END
If @Type = 1 Begin INSERT INTO dbo.Credit ( CompanyName, PhoneNumber, City, State ) VALUES ( @CompanyName, @PhoneNumber, @City, @State) End Else If @Type = 2 Begin INSERT INTO dbo.Debit ( CompanyName, PhoneNumber, City, State ) VALUES ( @CompanyName, @PhoneNumber, @City, @State) End Else If @Type = 3 Begin --ETC END
SET @SQL = CASE @Type WHEN 1 THEN @SQL1 WHEN 2 THEN @SQL2 ELSE @SQL3 END EXEC(@SQL)
If @Type = 1 EXEC InsertCredit @CompanyName, @PhoneNumber, @City, @State Else If @Type = 2 EXEC InsertDebit @CompanyName, @PhoneNumber, @City, @State Else If @Type = 3 EXEC OtherInsert @CompanyName, @PhoneNumber, @City, @State
INSERT INTO dbo.Credit ( CompanyName, PhoneNumber, City, State ) SELECT @CompanyName, @PhoneNumber, @City, @State WHERE @Type = 1 INSERT INTO dbo.Debit ( CompanyName, PhoneNumber, City, State ) SELECT @CompanyName, @PhoneNumber, @City, @State WHERE @Type = 2
SELECT * FROM sys.columns WHERE is_computed = 1 AND object_id = OBJECT_ID(
SELECT * FROM sys.computed_columns WHERE object_id = OBJECT_ID(
SELECT COLUMNPROPERTY(OBJECT_ID(TABLE_SCHEMA+ AS IS_COMPUTED, * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=
SELECT sysobjects.name AS TableName, syscolumns.name AS ColumnName FROM syscolumns INNER JOIN sysobjects ON syscolumns.id = sysobjects.id AND sysobjects.xtype = WHERE syscolumns.iscomputed = 1
TableName ColumnName ===================== ========== BrinksShipmentDetails Total AdjustmentDetails Total SoftCountDropDetails Total CloserDetails Total OpenerDetails Total TransferDetails Total (6 row(s) affected)
WITH xoutput AS ( SELECT CONVERT(xml, t.requestpayload) FROM TABLE t WHERE t.methodid = 1) SELECT x.requestpayload.query( FROM xoutput x
WITH xoutput AS ( SELECT CONVERT(xml, t.requestpayload) FROM TABLE t WHERE t.methodid = 1) SELECT x.requestpayload.value( FROM xoutput x
SELECT x.requestpayload.value( (/s:validate-student-request/s:student-id)[1] AS studentid FROM xoutput x
SELECT x.requestpayload.query( /s:validate-student-request/s:student-id as studentid FROM xoutput x
SELECT ID FROM tblTenantTransCode WHERE tblTenantTransCode.CheckbookCode = (SELECT ID FROM tblCheckbookCode WHERE Description =
SELECT * FROM tblTransaction WHERE tblTransaction.TransactionCode IN (SELECT ID FROM tblTenantTransCode WHERE tblTenantTransCode.CheckbookCode = (SELECT ID FROM tblCheckbookCode WHERE Description =
select tc.id from tblTenantTransCode tc inner join tblCheckbookCode cc on tc.CheckbookCode = cc.CheckbookCode
select * from tblTransaction t inner join tblTenantTransCode tc on tc.id = t.TransactionCode inner join tblCheckbookCode cc on cc.id = tc.CheckbookCode where cc.description =
SELECT t.* FROM tblTransaction t INNER JOIN tblTenantTransCode c ON t.TransactionCode = c.ID INNER JOIN tblCheckbookCode chk ON c.CheckbookCode = chk.ID WHERE chk.Description =
select id from tblTenantTransCode where tblTenantTransCode.CheckbookCode in (select id from tblCheckbookCode where description =
select ttc.id from tblTenantTransCode as ttc inner join tblCheckbookCode as tcc on ttc.CheckBookId = tcc.id where tcc.description =
SELECT tblTenantTransCode.ID FROM tblCheckbookCode INNER JOIN tblTenantTransCode ON tblCheckbookCode.ID=tblTenantTransCode.CheckbookCode WHERE tblCheckbookCode.Description =
CREATE PROCEDURE CALLWEBSERVICE(@Para1 ,@Para2) AS BEGIN Declare @Object as Int; Declare @ResponseText as Varchar(8000); Exec sp_OACreate Exec sp_OAMethod @Object, Exec sp_OAMethod @Object, Exec sp_OAMethod @Object, Select @ResponseText Exec sp_OADestroy @Object END
EXEC sp_OACreate EXEC sp_OAMethod @Object, EXEC sp_OAMethod @Object, DECLARE @len INT = len(@requestBody)
Alter Procedure yoursprocname @WavName varchar(50), @Dnis char(4) AS BEGIN SET NOCOUNT ON; DECLARE @Object INT; DECLARE @Status INT; DECLARE @requestBody NVARCHAR(MAX) = "WavName": "{WavName}", "Dnis": "{Dnis}" }' SET @requestBody = REPLACE(@requestBody, SET @requestBody = REPLACE(@requestBody, EXEC sp_OACreate EXEC sp_OAMethod @Object, EXEC sp_OAMethod @Object, DECLARE @len INT = len(@requestBody) EXEC sp_OAMethod @Object, EXEC sp_OAMethod @Object, EXEC sp_OAGetProperty @Object, EXEC sp_OADestroy @Object
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE
select object_name(c.object_id) as table_name , schema_name(t.schema_id) as schema_name from sys.columns c join sys.tables t on c.object_id = t.object_id where c.name=N
SELECT objParent.name AS parent, obj.name, col.* FROM sysobjects obj LEFT JOIN syscolumns col ON obj.id = col.id LEFT JOIN sysobjects objParent ON objParent.id = obj.parent_obj WHERE col.name LIKE OR obj.name LIKE
SELECT name FROM sys.procedures WHERE OBJECT_DEFINITION(OBJECT_ID) LIKE
SELECT * FROM INFORMATION_SCHEMA.TABLES where TABLES.TABLE_NAME like
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE columns.COLUMN_NAME like
SELECT t.name AS table_name, SCHEMA_NAME(schema_id) AS schema_name, c.name AS column_name , * FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID Where ( c.name LIKE AND ( t.type =
ALTER DATABASE ip_ent_site SET SINGLE_USER WITH ROLLBACK IMMEDIATE GO sp_rename GO ALTER DATABASE new_db_name SET MULTI_USER GO
ALTER DATABASE [ip_ent_site] SET SINGLE_USER WITH ROLLBACK IMMEDIATE GO ALTER DATABASE [ip_ent_site] MODIFY NAME = [ip_ent_site_new] GO ALTER DATABASE [ip_ent_site_new] SET MULTI_USER; GO
USE master; GO ALTER DATABASE ip_ent_site SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
USE master GO ALTER DATABASE ip_ent_site Modify Name = ip_ent_site1 GO
SELECT, INSERT, UPDATE, or DELETE SELECT @Error=@@ERROR, @Rows=@@ROWCOUNT IF @Rows!=1 OR @Error!=0 BEGIN SET @ErrorMsg= + IF @@TRANCOUNT >0 BEGIN ROLLBACK END SET @LogInfo=ISNULL(@LogInfo, + + + + INSERT INTO MyLogTable (...,Message) VALUES (....,@LogInfo) RETURN 20 END
BEGIN TRANSACTION BEGIN TRY COMMIT TRANSACTION END TRY BEGIN CATCH SELECT ERROR_NUMBER() AS ErrorNumber, ERROR_SEVERITY() AS ErrorSeverity, ERROR_STATE() AS ErrorState, ERROR_PROCEDURE() AS ErrorProcedure, ERROR_LINE() AS ErrorLine, ERROR_MESSAGE() AS ErrorMessage ROLLBACK TRANSACTION END CATCH
SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO SET ANSI_PADDING ON GO CREATE TABLE [dbo].[Phone]( [ID] [int] IDENTITY(1,1) NOT NULL, [Phone_Type_ID] [int] NOT NULL, [Area_Code] [char](3) NOT NULL, [Exchange] [char](3) NOT NULL, [Number] [char](4) NOT NULL, [Extension] [varchar](6) NULL, CONSTRAINT [PK_Phone] PRIMARY KEY CLUSTERED ( [ID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] GO SET ANSI_PADDING OFF GO /**/ CREATE PROCEDURE [dbo].[usp_Phone_INS] @Customer_ID INT ,@Phone_Type_ID INT ,@Area_Code CHAR(3) ,@Exchange CHAR(3) ,@Number CHAR(4) ,@Extension VARCHAR(6) AS BEGIN SET NOCOUNT ON; DECLARE @Err INT, @Phone_ID INT BEGIN TRY INSERT INTO Phone (Phone_Type_ID, Area_Code, Exchange, Number, Extension) VALUES (@Phone_Type_ID, @Area_Code, @Exchange, @Number, @Extension) SET @Err = @@ERROR SET @Phone_ID = SCOPE_IDENTITY() SELECT ISNULL(@Err,-1) AS Err, @Phone_ID END TRY BEGIN CATCH IF (XACT_STATE() <> 0) BEGIN ROLLBACK TRANSACTION END SELECT ERROR_NUMBER() AS Err, ISNULL(@Phone_ID,-1) AS ID END CATCH END
CREATE PROCEDURE [dbo].[AccountExists] @UserName nvarchar(16) AS IF EXISTS (SELECT Id FROM Account WHERE UserName=@UserName) SELECT 1 ELSE SELECT 0
ALTER PROCEDURE [dbo].[AccountExists] @UserName nvarchar(16) AS IF EXISTS (SELECT Id FROM Account WHERE UserName=@UserName) RETURN 1 ELSE RETURN 0
--another procedure to insert or update account DECLARE @exists bit EXEC @exists = [dbo].[AccountExists] @UserName IF @exists=1 --update account ELSE --insert acocunt
CREATE PROC Test(@x INT OUT) AS SELECT * From TestTable SELECT @x = 1
SqlCommand cmd = connection.CreateCommand(); cmd.CommandType = CommandType.StoredProcedure; cmd.CommandText = "Test" cmd.Parameters.Add("@x", SqlDbType.Int).Direction = ParameterDirection.Output; cmd.Parameters.Add("@retval", SqlDbType.Int).Direction = ParameterDirection.ReturnValue; cmd.Execute(); int? x = cmd.Parameters["@x"].Value is DBNull ? null : (int?)cmd.Parameters["@x"].Value;
using (var rdr = cmd.ExecuteReader()) { while (rdr.Read()) MaybeDoSomething; } int? x = cmd.Parameters["@x"].Value is DBNull ? null : (int?)cmd.Parameters["@x"].Value;
Debug.Print "starting at ..." & TimeValue(Now) Dim cn As New ADODB.Connection Dim cmd As New ADODB.Command cn.ConnectionString = "Data Source=[yours];User ID=[youruser];Password=[yourpassword];Initial Catalog=[Yourdb];Provider=sqloledb;Application Name=[yourapp]" cn.Open cmd.ActiveConnection = cn cmd.CommandText = "AccountExists" cmd.CommandType = adCmdStoredProc cmd.Parameters.Append cmd.CreateParameter(, adInteger, adParamReturnValue) cmd.Parameters.Append cmd.CreateParameter("UserName",adVarChar, adParamInput, 16, UserNameInVB) cmd.Execute Debug.Print "Returnval: " & cmd.Parameters(0) cn.Close Set cmd = Nothing Set cn = Nothing Debug.Print "finished at ..." & TimeValue(Now)
Create PROCEDURE CheckExpedite @InputX varchar(10), @InputY int, @HasExpedite int out AS BEGIN Select @HasExpedite = 9 from <Table> where Column2 = @InputX and Column3 = @InputY If @HasExpedite = 9 Return 2 Else Return 3 End
Sub CheckValue() Dim InputX As String: InputX = "6000" Dim InputY As Integer: InputY = 2014 Dim ACon As New Connection ACon.Open ("Provider=SQLOLEDB;Data Source=<SqlServer>;" & _ "Initial Catalog=<Table>;Integrated Security=SSPI") Dim ACmd As New Command Set ACmd.ActiveConnection = ACon ACmd.CommandText = "CheckExpedite" ACmd.CommandType = adCmdStoredProc ACmd.Parameters.Append ACmd.CreateParameter("ReturnValue", adInteger, adParamReturnValue) ACmd.Parameters.Append ACmd.CreateParameter("InputX", adVarChar, adParamInput, 10, InputX) ACmd.Parameters.Append ACmd.CreateParameter("InputY", adInteger, adParamInput, 6, InputY) ACmd.Parameters.Append ACmd.CreateParameter("HasExpedite", adInteger, adParamOutput) Dim RS As Recordset Dim RecordsAffected As Long Call ACmd.Execute(RecordsAffected:=RecordsAffected, Options:=adExecuteNoRecords) Debug.Print "Records affected: " & RecordsAffected Debug.Print "Return value: " & ACmd.Parameters("ReturnValue") Debug.Print "Output param: " & ACmd.Parameters("HasExpedite") If Not RS Is Nothing Then RS.Close ACon.Close End Sub
IF @value IS NULL BEGIN set @value=@value -- or print END
select * from account; | PERIOD | ACCOUNT | VALUE | ---------------------------- | 2000 | Asset | 205 | | 2000 | Equity | 365 | | 2000 | Profit | 524 | | 2001 | Asset | 142 | | 2001 | Equity | 214 | | 2001 | Profit | 421 | | 2002 | Asset | 421 | | 2002 | Equity | 163 | | 2002 | Profit | 325 |
| ACCOUNT | 2000 | 2001 | 2002 | -------------------------------- | Asset | 205 | 142 | 421 | | Equity | 365 | 214 | 163 | | Profit | 524 | 421 | 325 |
SELECT * FROM ( SELECT [Period], [Account], [Value] FROM TableName ) AS source PIVOT ( MAX([Value]) FOR [Period] IN ([2000], [2001], [2002]) ) as pvt
SELECT ACCOUNT, MAX(CASE WHEN Period = MAX(CASE WHEN Period = MAX(CASE WHEN Period = FROM tableName GROUP BY Account
| ACCOUNT | 2000 | 2001 | 2002 | -------------------------------- | Asset | 205 | 142 | 421 | | Equity | 365 | 214 | 163 | | Profit | 524 | 421 | 325 | DECLARE @cols AS NVARCHAR(MAX), @query AS NVARCHAR(MAX) SET @cols = STUFF((SELECT distinct FROM demo c FOR XML PATH( ).value( ,1,1, set @query = ( select account , value , period from demo ) x pivot ( max(value) for period in ( ) p ' execute(@query)
ALTER TABLE MyTable ADD COLUMN NewField int NULL AFTER ID;
CREATE TABLE ( [new_column] [int] NOT NULL, <-- new column has been inserted here! [idx] [bigint] NOT NULL, [name] [nvarchar](30) NOT NULL, [active] [bit] NOT NULL )
CREATE TABLE myTable ( [new_column] [int] NOT NULL, [idx] [bigint] NOT NULL, [name] [nvarchar](30) NOT NULL, [active] [bit] NOT NULL )
INSERT INTO myTable ([new_column],[idx],[name],[active]) SELECT [new_column],[idx],[name],[active] FROM
USE [master] GO /****** Object: StoredProcedure [SP_Set].[TrasferDataAtColumnLevel] Script Date: 8/27/2014 2:59:30 PM ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO CREATE PROCEDURE [SP_Set].[TrasferDataAtColumnLevel] ( @database varchar(100), @table varchar(100), @column varchar(100), @position int, @datatype varchar(20) ) AS BEGIN set nocount on exec (' declare @oldC varchar(200), @oldCDataType varchar(200), @oldCLen int,@oldCPos int create table Test ( dummy int) declare @columns varchar(max) = declare @columnVars varchar(max) = declare @columnsDecl varchar(max) = declare @printVars varchar(max) = DECLARE MY_CURSOR CURSOR LOCAL STATIC READ_ONLY FORWARD_ONLY FOR select column_name, data_type, character_maximum_length, ORDINAL_POSITION from OPEN MY_CURSOR FETCH NEXT FROM MY_CURSOR INTO @oldC, @oldCDataType, @oldCLen, @oldCPos WHILE @@FETCH_STATUS = 0 BEGIN if(@oldCPos = begin exec( end if(@oldCDataType != begin set @columns += @oldC + set @columnVars += if(@oldCLen is null) begin if(@oldCDataType != begin set @printVars += set @columnsDecl += exec( end else begin set @printVars += set @columnsDecl += exec( end end else begin if(@oldCLen < 0) begin set @oldCLen = 4000 end set @printVars += set @columnsDecl += exec( end end if exists (select column_name from INFORMATION_SCHEMA.COLUMNS where table_name = begin alter table Test drop column dummy end FETCH NEXT FROM MY_CURSOR INTO @oldC, @oldCDataType, @oldCLen, @oldCPos END CLOSE MY_CURSOR DEALLOCATE MY_CURSOR set @columns = reverse(substring(reverse(@columns), charindex( set @columnVars = reverse(substring(reverse(@columnVars), charindex( set @columnsDecl = reverse(substring(reverse(@columnsDecl), charindex( set @columns = replace(replace(REPLACE(@columns, set @columnVars = replace(replace(REPLACE(@columnVars, set @columnsDecl = replace(replace(REPLACE(@columnsDecl, set @printVars = REVERSE(substring(reverse(@printVars), charindex( create table query (id int identity(1,1), string varchar(max)) insert into query values ( DECLARE MY_CURSOR CURSOR LOCAL STATIC READ_ONLY FORWARD_ONLY FOR insert into query values ( insert into query values ( insert into query values (@printVars ) insert into query values ( insert into query values (@columns) insert into query values ( insert into query values ( declare @path varchar(100) = declare @query varchar(500) = exec master..xp_cmdshell @query set @query = EXEC xp_cmdshell @query set @query = exec xp_cmdshell @query drop table select * into drop table query drop table Test
RATIO RESULT SCORE GRADE Current Ratio 1.294 60 Good Gearing Ratio 0.3384 70 Good Performance Ratio 0.0427 50 Satisfactory TOTAL NULL 180 Good
SELECT ,[Current Ratio] AS ,[Gearing Ratio] AS ,[Performance Ratio] AS ,[TOTAL] AS FROM ( SELECT RATIO, RESULT FROM GRAND_TOTALS ) AS SREC PIVOT ( MAX(RESULT) FOR RATIO IN ([Current Ratio],[Gearing Ratio], [Performance Ratio], [TOTAL]) ) AS PVT
Ratio Current Ratio Gearing Ratio Performance Ratio Result 1.294 0.3384 0.0427
Ratio Current Ratio Gearing Ratio Performance Ratio TOTAL Result 1.294 0.3384 0.0427 NULL Score 60 70 50 180 Grade Good Good Satisfactory Good
select ratio, col, value from GRAND_TOTALS cross apply ( select select select ) c(col, value)
select ratio = col, [current ratio], [gearing ratio], [performance ratio], total from ( select ratio, col, value from GRAND_TOTALS cross apply ( select select select ) c(col, value) ) d pivot ( max(value) for ratio in ([current ratio], [gearing ratio], [performance ratio], total) ) piv;
| RATIO | CURRENT RATIO | GEARING RATIO | PERFORMANCE RATIO | TOTAL | |--------|---------------|---------------|-------------------|-----------| | grade | Good | Good | Satisfactory | Good | | result | 1.29400 | 0.33840 | 0.04270 | (null) | | score | 60.00000 | 70.00000 | 50.00000 | 180.00000 |
select a.* from tablea a join tableb b on a.id = b.id join tablec c on b.id2 = c.id2 left join tabled d on c.id3 = c.id3 where d.type = 1
select a.* from tablea a join tableb b on a.id = b.id join tablec c on b.id2 = c.id2 left join tabled d on c.id3 = c.id3 where d.type in (1,2,3,4)
WHERE id = 1 OR id = 2 OR id = 3 OR id = 4 OR id = 5
IF (SELECT CURSOR_STATUS( BEGIN IF (SELECT CURSOR_STATUS( BEGIN CLOSE myCursor END DEALLOCATE myCursor END
IF (SELECT CURSOR_STATUS( BEGIN DEALLOCATE myCursor END
select is_local_cursor_default from sys.databases where name =
SELECT CASE CHARINDEX( WHEN 0 THEN @Foo -- empty or single word ELSE SUBSTRING(@Foo, 1, CHARINDEX( END
CREATE FUNCTION [dbo].[FirstWord] (@value varchar(max)) RETURNS varchar(max) AS BEGIN RETURN CASE CHARINDEX( WHEN 0 THEN @value ELSE SUBSTRING(@value, 1, CHARINDEX( END GO -- test: SELECT dbo.FirstWord(NULL) SELECT dbo.FirstWord( SELECT dbo.FirstWord( SELECT dbo.FirstWord( SELECT dbo.FirstWord(
DECLARE @test NVARCHAR(255) SET @test = SELECT SUBSTRING(@test,1,(CHARINDEX(
DECLARE @test NVARCHAR(255) SET @test = SELECT SUBSTRING(LTRIM(@test),1,(CHARINDEX(
DECLARE @string NVARCHAR(50) SET @string = SELECT LEFT(@string,(PATINDEX(
Select race_id, race_description , Case patIndex ( When 0 Then LTrim (race_description) Else substring (LTrim (race_description), 1, patIndex ( End race_abbreviation from tbl_races
race_id race_description race_abbreviation ------- ------------------------- ----------------- 1 White White 2 Black or African American Black 3 Hispanic/Latino Hispanic
Select race_id, race_description , Case patIndex ( When 0 Then LTrim (race_description) Else substring (LTrim (race_description), 1, patIndex ( End race_abbreviation
DECLARE @binvalue binary(4) SET @binvalue = 0x12345678 PRINT CAST(@binvalue AS nvarchar)
select master.sys.fn_varbintohexstr(field) from table`
SELECT CONVERT( varchar(50), CAST(MAX(timestamp) AS varbinary(8)), 1) AS LastTS FROM Users
SELECT CAST( CAST(MAX(timestamp) AS varbinary(8)) AS varchar(50) ) AS LastTS FROM Users
DECLARE @binvalue binary(4) SET @binvalue = 0x61000000 PRINT @binvalue PRINT cast( PRINT cast(0x61 AS varchar)
DECLARE @mybin1 binary(16) DECLARE @s varchar(100) SET @mybin1 = 0x098F6BCD4621D373CADE4E832627B4F6 SET @s = PRINT @s
DECLARE @binvalue binary(4) SET @binvalue = 0x12345678 PRINT PRINT PRINT PRINT print
cast(@binvalue AS nvarchar): 㐒硖 convert(varchar(max), @binvalue, 0): 4Vx convert(varchar(max), @binvalue, 1): 4Vx convert(varchar(max), @binvalue, 2): 4Vx master.sys.fn_varbintohexstr(@binvalue): 0x12345678
cast(@binvalue AS nvarchar): 㐒硖 convert(varchar(max), @binvalue, 0): 4Vx convert(varchar(max), @binvalue, 1): 0x12345678 convert(varchar(max), @binvalue, 2): 12345678 master.sys.fn_varbintohexstr(@binvalue): 0x12345678
SELECT fk.name tp.name cp.name, cp.column_id, tr.name cr.name, cr.column_id FROM sys.foreign_keys fk INNER JOIN sys.tables tp ON fk.parent_object_id = tp.object_id INNER JOIN sys.tables tr ON fk.referenced_object_id = tr.object_id INNER JOIN sys.foreign_key_columns fkc ON fkc.constraint_object_id = fk.object_id INNER JOIN sys.columns cp ON fkc.parent_column_id = cp.column_id AND fkc.parent_object_id = cp.object_id INNER JOIN sys.columns cr ON fkc.referenced_column_id = cr.column_id AND fkc.referenced_object_id = cr.object_id ORDER BY tp.name, cp.column_id
SELECT K_Table = FK.TABLE_NAME, FK_Column = CU.COLUMN_NAME, PK_Table = PK.TABLE_NAME, PK_Column = PT.COLUMN_NAME, Constraint_Name = C.CONSTRAINT_NAME FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS C INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS FK ON C.CONSTRAINT_NAME = FK.CONSTRAINT_NAME INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS PK ON C.UNIQUE_CONSTRAINT_NAME = PK.CONSTRAINT_NAME INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE CU ON C.CONSTRAINT_NAME = CU.CONSTRAINT_NAME INNER JOIN ( SELECT i1.TABLE_NAME, i2.COLUMN_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS i1 INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE i2 ON i1.CONSTRAINT_NAME = i2.CONSTRAINT_NAME WHERE i1.CONSTRAINT_TYPE = ) PT ON PT.TABLE_NAME = PK.TABLE_NAME ---- optional: ORDER BY 1,2,3,4 WHERE PK.TABLE_NAME= WHERE PK.TABLE_NAME IN ( WHERE FK.TABLE_NAME IN (
IF OBJECT_ID( DROP PROC GetForeignKeyRelations GO CREATE PROC GetForeignKeyRelations @Schemaname Sysname = ,@Tablename Sysname ,@WhereClause NVARCHAR(2000) = ,@GenerateDeleteScripts bit = 0 ,@GenerateSelectScripts bit = 0 AS SET NOCOUNT ON DECLARE @fkeytbl TABLE ( ReferencingObjectid int NULL ,ReferencingSchemaname Sysname NULL ,ReferencingTablename Sysname NULL ,ReferencingColumnname Sysname NULL ,PrimarykeyObjectid int NULL ,PrimarykeySchemaname Sysname NULL ,PrimarykeyTablename Sysname NULL ,PrimarykeyColumnname Sysname NULL ,Hierarchy varchar(max) NULL ,level int NULL ,rnk varchar(max) NULL ,Processed bit default 0 NULL ); WITH fkey (ReferencingObjectid,ReferencingSchemaname,ReferencingTablename,ReferencingColumnname ,PrimarykeyObjectid,PrimarykeySchemaname,PrimarykeyTablename,PrimarykeyColumnname,Hierarchy,level,rnk) AS ( SELECT soc.object_id ,scc.name ,soc.name ,convert(sysname,null) ,convert(int,null) ,convert(sysname,null) ,convert(sysname,null) ,convert(sysname,null) ,CONVERT(VARCHAR(MAX), scc.name + ,0 as level ,rnk=convert(varchar(max),soc.object_id) FROM SYS.objects soc JOIN sys.schemas scc ON soc.schema_id = scc.schema_id WHERE scc.name =@Schemaname AND soc.name =@Tablename UNION ALL SELECT sop.object_id ,scp.name ,sop.name ,socp.name ,soc.object_id ,scc.name ,soc.name ,socc.name ,CONVERT(VARCHAR(MAX), f.Hierarchy + ,f.level+1 as level ,rnk=f.rnk + FROM SYS.foreign_key_columns sfc JOIN Sys.Objects sop ON sfc.parent_object_id = sop.object_id JOIN SYS.columns socp ON socp.object_id = sop.object_id AND socp.column_id = sfc.parent_column_id JOIN sys.schemas scp ON sop.schema_id = scp.schema_id JOIN SYS.objects soc ON sfc.referenced_object_id = soc.object_id JOIN SYS.columns socc ON socc.object_id = soc.object_id AND socc.column_id = sfc.referenced_column_id JOIN sys.schemas scc ON soc.schema_id = scc.schema_id JOIN fkey f ON f.ReferencingObjectid = sfc.referenced_object_id WHERE ISNULL(f.PrimarykeyObjectid,0) <> f.ReferencingObjectid ) INSERT INTO @fkeytbl (ReferencingObjectid,ReferencingSchemaname,ReferencingTablename,ReferencingColumnname ,PrimarykeyObjectid,PrimarykeySchemaname,PrimarykeyTablename,PrimarykeyColumnname,Hierarchy,level,rnk) SELECT ReferencingObjectid,ReferencingSchemaname,ReferencingTablename,ReferencingColumnname ,PrimarykeyObjectid,PrimarykeySchemaname,PrimarykeyTablename,PrimarykeyColumnname,Hierarchy,level,rnk FROM fkey SELECT F.Relationshiptree FROM ( SELECT DISTINCT Replicate( ,RNK FROM @fkeytbl ) F ORDER BY F.rnk ASC ------------------------------------------------------------------------------------------------------------------------------- -- Generate the Delete / Select script ------------------------------------------------------------------------------------------------------------------------------- DECLARE @Sql VARCHAR(MAX) DECLARE @RnkSql VARCHAR(MAX) DECLARE @Jointables TABLE ( ID INT IDENTITY ,Object_id int ) DECLARE @ProcessTablename SYSNAME DECLARE @ProcessSchemaName SYSNAME DECLARE @JoinConditionSQL VARCHAR(MAX) DECLARE @Rnk VARCHAR(MAX) DECLARE @OldTablename SYSNAME IF @GenerateDeleteScripts = 1 or @GenerateSelectScripts = 1 BEGIN WHILE EXISTS ( SELECT 1 FROM @fkeytbl WHERE Processed = 0 AND level > 0 ) BEGIN SELECT @ProcessTablename = SELECT @Sql = SELECT @JoinConditionSQL = SELECT @OldTablename = SELECT TOP 1 @ProcessTablename = ReferencingTablename ,@ProcessSchemaName = ReferencingSchemaname ,@Rnk = RNK FROM @fkeytbl WHERE Processed = 0 AND level > 0 ORDER BY level DESC SELECT @RnkSql = DELETE FROM @Jointables INSERT INTO @Jointables EXEC(@RnkSql) IF @GenerateDeleteScripts = 1 SELECT @Sql = IF @GenerateSelectScripts = 1 SELECT @Sql = SELECT @JoinConditionSQL = @JoinConditionSQL + CASE WHEN @OldTablename <> f.PrimarykeyTablename THEN ELSE END + , @OldTablename = CASE WHEN @OldTablename <> f.PrimarykeyTablename THEN f.PrimarykeyTablename ELSE @OldTablename END FROM @fkeytbl f JOIN @Jointables j ON f.Referencingobjectid = j.Object_id WHERE charindex(f.rnk + AND F.level > 0 ORDER BY J.ID DESC SELECT @Sql = @Sql + @JoinConditionSQL IF LTRIM(RTRIM(@WhereClause)) <> SELECT @Sql = @Sql + PRINT @SQL PRINT CHAR(10) UPDATE @fkeytbl SET Processed = 1 WHERE ReferencingTablename = @ProcessTablename AND rnk = @Rnk END IF @GenerateDeleteScripts = 1 SELECT @Sql = IF @GenerateSelectScripts = 1 SELECT @Sql = IF LTRIM(RTRIM(@WhereClause)) <> SELECT @Sql = @Sql + PRINT @SQL END SET NOCOUNT OFF go
SELECT FK.[name] AS ForeignKeyConstraintName ,SCHEMA_NAME(FT.schema_id) + ,STUFF(ForeignColumns.ForeignColumns, 1, 2, ,SCHEMA_NAME(RT.schema_id) + ,STUFF(ReferencedColumns.ReferencedColumns, 1, 2, FROM sys.foreign_keys FK INNER JOIN sys.tables FT ON FT.object_id = FK.parent_object_id INNER JOIN sys.tables RT ON RT.object_id = FK.referenced_object_id CROSS APPLY ( SELECT FROM sys.foreign_key_columns iFKC INNER JOIN sys.columns iFC ON iFC.object_id = iFKC.parent_object_id AND iFC.column_id = iFKC.parent_column_id WHERE iFKC.constraint_object_id = FK.object_id ORDER BY iFC.[name] FOR XML PATH( ) ForeignColumns (ForeignColumns) CROSS APPLY ( SELECT FROM sys.foreign_key_columns iFKC INNER JOIN sys.columns iRC ON iRC.object_id = iFKC.referenced_object_id AND iRC.column_id = iFKC.referenced_column_id WHERE iFKC.constraint_object_id = FK.object_id ORDER BY iRC.[name] FOR XML PATH( ) ReferencedColumns (ReferencedColumns)
select * from information_schema.REFERENTIAL_CONSTRAINTS where UNIQUE_CONSTRAINT_SCHEMA =
-- create a test table create table test ( a text ) -- insert test value insert into test (a) values ( -- the following does not work !!! update test set a = a + -- but this way it works: update test set a = cast ( a as nvarchar(max)) + cast ( -- test result select * from test -- column a contains: this is a text and a new text added
SELECT CODE, CONCAT(Rtrim(FName), " " , TRrim(LName)) as Title FROM MyTable
Table 1 2 columns: ID, Name Table 2 2 columns: ID, Name
Select * from table1 left join table2 on table1.id = table2.id where table2.id is null
select t1.id, t1.name from table1 t1 where not exists(select null from table2 t2 where t2.id = t1.id)
select t1.* from table1 t1 left outer join table2 t2 on t1.id=t2.id where t2.id is null
SELECT Table1.ID, Table1.Name, Table2.ID FROM Table1 LEFT OUTER JOIN Table2 ON Table1.ID = Table2.ID WHERE Table2.ID IS NULL
SELECT * FROM table1 WHERE table2.id NOT IN (SELECT id FROM table2)
SELECT TOP 5 * FROM dbo.SomeTable WHERE SomeColumn = SomeValue
SELECT TOP @param1 * FROM dbo.SomeTable WHERE SomeColumn = SomeValue
SET ROWCOUNT @NumberOfResults SELECT * FROM MyTable SET ROWCOUNT 0
SELECT name FROM sys.databases SELECT name FROM sys.sysdatabases
select database_id, [name] database_name from master.sys.databases WHERE state <> 6 -- skip offline AND database_id > 4 -- skip system dbs AND HAS_DBACCESS([name]) = 1 -- with User Access
WHERE Column1 LIKE WHERE Column1 LIKE WHERE Column1 Like
WHERE RESULTS_I_AM_SEARCHING_FOR IN ITEM 1 ITEM 2 ITEM 3
SELECT post.id, post.title,comment.id,comment.message from post left outer join comment on post.id=comment.post_id
SELECT post.id, post.title, comment.id, comment.message FROM post OUTER APPLY ( SELECT TOP 1 * FROM comment с WHERE c.post_id = post.id ORDER BY date DESC ) comment
SELECT * FROM ( SELECT post.id, post.title, comment.id, comment.message, ROW_NUMBER() OVER (PARTITION BY post.id ORDER BY comment.date DESC) AS rn FROM post LEFT JOIN comment ON comment.post_id = post.id ) q WHERE rn = 1
SELECT p.id, p.title, c.id, c.message FROM post p LEFT join comment c ON c.post_id = p.id AND c.id = (SELECT MAX(c.id) FROM comment c2 WHERE c2.post_id = p.id)
select post.id, post.title. lastpostid, lastcommentmessage from post inner join ( select post.id as lastpostid, max(comment.id) as lastcommentmessage from post inner join comment on commment.post_id = post.id group by post.id ) lastcomment on lastpostid = post.id
SELECT TOP 1 comment.message FROM comment ORDER BY comment.id DESC
SELECT post.id, post.title, comment.id, comment.message FROM post p LEFT OUTER JOIN comment ON comment.id = ( SELECT TOP 1 id FROM comment WHERE p.id = post_id ORDER BY [DateCreated] ASC )
SELECT MAX(a_date) FROM a_table WHERE a_primary_key = 5 GROUP BY event_id
SELECT TOP 1 a_date FROM a_table WHERE a_primary_key = 5 ORDER BY a_date
SELECT MAX(a_date) FROM a_table WHERE a_primary_key = 5 SELECT TOP 1 a_date FROM a_table WHERE a_primary_key = 5 ORDER BY a_date DESC
ALTER TABLE Table1 ADD newGuidId UniqueIdentifier NULL CONSTRAINT DF_Guid Default newid() with values
DECLARE @t table (pkint int IDENTITY(1,1), somevalue nvarchar(50)) INSERT INTO @t (somevalue) VALUES( INSERT INTO @t (somevalue) VALUES( INSERT INTO @t (somevalue) VALUES( SELECT row_number() OVER (ORDER BY pkint), somevalue FROM @t DELETE FROM @t INSERT INTO @t (somevalue) VALUES( SELECT row_number() OVER (ORDER BY pkint), somevalue FROM @t
DBCC CHECKIDENT (yourtableName, reseed, @NewStartSeedValue)
declare @tb table (recid int,lineof int identity(1,1)) insert into @tb(recid) select recid from tabledata delete from @tb where lineof>(select min(lineof) from @tb)+@maxlimit
SELECT Id, Key FROM DataTable WHERE CustomerId = 1234 ORDER BY Key
Row Id Key 1 1 A3231 2 43 C1212 3 243 E1232 4 765 G1232 5 2432 E2325 ... 90 3193 F2312
SELECT t.id, t.key FROM ( SELECT id, key, ROW_NUMBER() OVER (ORDER BY key) AS rownum FROM datatable ) AS t WHERE t.rownum % 30 = 0 -- or % 40 etc ORDER BY t.key
Select ID, LastName, FirstName FROM Users WHERE ID%13 = 0 ORDER BY ID
Select B.name from (Select row_number() over (order by ordering) as row_num, A.name from (Select name, from [dbo].[every_2nd_record] ) A ) B where B.row_num%2=0
select dateadd( hh, -1 * datepart(hh, cast( dateadd( mi, -1 * datepart(mi, cast(
declare @mins int select @mins = datepart(mi, cast( select dateadd(mi, -1 * @mins,
convert( varchar, cast((RouteMileage / @average_speed) as integer))+ dateadd( n, -60 * CAST( (RouteMileage / @average_speed) AS DECIMAL(7,2)), @entry_date) As DepartureTime
DeliveryDate TravelTime DepartureTime 2012-06-02 12:00:00.000 25:49 2012-06-01 10:11:00.000
SELECT CASE WHEN ISNUMERIC(myvarcharcolumn)=1 THEN CONVERT(float, REPLACE(LTRIM(RTRIM(myvarcharcolumn)), ELSE 0 END AS myfloatcolumn
[SqlFunction] public static SqlDouble TryParseDouble(SqlString str) { Double d; bool success = Double.TryParse(str, out d); if (!success) return SqlDouble.Null; return new SqlDouble(d); }
DECLARE @SoMe1 FLOAT = 100.99; DECLARE @SoMe2 VARCHAR(10) = SELECT CASE WHEN TRY_CONVERT(FLOAT, @SoMe1) IS NULL THEN 0 ELSE @SoMe1 END AS Rslt; -- Output will be 100.99 SELECT CASE WHEN TRY_CONVERT(FLOAT, @SoMe2) IS NULL THEN 0 ELSE @SoMe2 END AS Rslt; -- Output will be 0
WITH YourCTE(blubb) AS ( SELECT ) SELECT id, (SELECT blubb FROM YourCTE), name FROM table_name
select id (I want to use CTE here), name from table_name
CREATE VIEW MyCTEView AS ..here comes your CTE-Statement.
select id (select id from MyCTEView), name from table_name
create function dbo.myCTEFunction(@ID int) returns varchar(100) as begin declare @Result varchar(100) -- fill the variable with your CTE here... return @Result end; select t.id, (select dbo.myCTEFunction(t.id)), t.name from table_name t
select iv.invoiceno ,w.warehouse ,iv.invoicedate ,iv.invoicedesc ,iv.status ,iv.billingstart as [BillingFrom] ,iv.billingend as [BillingTo] ,CAST((iv.invoicesubtotal) as NUMERIC(38,2))as [Sub-Total] ,CAST((((iv.invoicesubtotal+iv.invoicetax)-iv.invoicetotal)) as NUMERIC(38,2)) as [Discount] ,CAST((iv.invoicetax) as NUMERIC(38,2)) as [SalesTax] ,CAST((iv.invoicetotal) as NUMERIC(38,2)) as [Total] ,d.deal ,d.dealno ,ivt.orderno ,ivt.rectype ,ivt.rectypedisplay ,RTRIM(ivt.masterno) as [ICode] ,ivt.description as [ICodeDesc] ,ivt.fromdate as [From] ,ivt.todate as [To] ,CAST((ivt.days ) as NUMERIC(38,2)) as [days] ,CAST(ivt.qty as NUMERIC(38,0)) as [qty] ,CAST((ivt.cost) as NUMERIC(38,2)) as [UnitCost] ,CAST((ivt.rate) as NUMERIC(38,2)) as [rate] ,CAST((ivt.daysinwk)as NUMERIC(38,2)) as [D/W] ,CAST((ivt.discountamt)as NUMERIC(38,2)) as [Discount] ,CAST((ivt.extended)as NUMERIC(38,2)) as [extended] ,(CASE WHEN ivt.taxable= ,ivt.category ,(CASE WHEN (ivt.cost > 0 and ivt.rectype= inner join deal d on d.dealid=iv.dealid inner join invoiceitemview ivt on iv.invoiceid=ivt.invoiceid and iv.invoiceno=ivt.invoiceno inner join warehouse w on w.locationid=iv.locationid and w.inactive<> left join category c on c.categoryid=ivt.categoryid left join ordernoteview n on ivt.orderid=n.orderid and n.billing =
select tot.gldate, tot.glno, tot.glacctdesc, tot.debit,tot.credit,tot.glaccountid from invoice ivt cross apply dbo.funcglforinvoice(ivt.invoiceid, null, null) as tot where ivt.invoiceno=
Select iv.invoiceno, iv.invoiceitem,iv.invoiceno from invoice iv inner join deal d on d.dealid=iv.dealid inner join invoiceitemview ivt on iv.invoiceid=ivt.invoiceid and iv.invoiceno=ivt.invoiceno inner join warehouse w on w.locationid=iv.locationid and w.inactive<> left join category c on c.categoryid=ivt.categoryid left join ordernoteview n on ivt.orderid=n.orderid and n.billing = OUTER APPLY dbo.funcglforinvoice(iv.invoiceid, null, null) as tot
pn s ----------- ----------- 1 22351 2 22354 3 22356 4 22357 5 22360
id pn s ----------- ----------- ----------- 22268 1 22351 22268 2 22354 22268 3 22356 22268 4 22357 22268 5 22360 24104 1 22353 24104 2 22355 24104 3 22356 24104 4 22358 24104 5 22360 24104 6 22362 24104 7 22364 . . .
id myColumn ----------- ------------------------------------------- 22268 22351,22354,22356,22357,22360, 24104 22353,22355,22356,22358,22360,22362,22364,
SELECT Stuff.id ,Results.pn ,Results.s FROM stackoverflow_454945 AS Stuff OUTER APPLY dbo.Split( WHERE ISNULL(Results.s,
declare @split varchar(max) set @split = select @split = @split + Coalesce(myColumn + from Stuff WHERE id = 22268 select * from dbo.Split(
select * from A, B join C on C.SomeField = A.SomeField and C.SomeField = B.SomeField
select * from A cross join B join C on C.SomeField = A.SomeField and C.SomeField = B.SomeField
SELECT n, ST_AsEWKT(ST_GeometryN(the_geom, n)) As geomewkt FROM ( VALUES (ST_GeomFromEWKT( ( ST_GeomFromEWKT( ) As foo(the_geom) CROSS JOIN generate_series(1,100) n WHERE n <= ST_NumGeometries(the_geom);
select * from A, B, C, D where B.id = C.id_b and C.id_d = D.id;
select * from A cross join B inner join C on C.id_b = B.id inner join D on D.id = C.id_d;
select . . . from (select getdate() as now) params cross join . . .
select rand(), rand() from (values (1), (2), (3)) v(x);
CREATE PROC TestGetdate ( @CurrentDate DATETIME = NULL ) AS SET CurrentDate = GETDATE()
CREATE FUNCTION [dbo].[Today]() RETURNS date AS BEGIN DECLARE @today date = getdate() RETURN @today End
select "2" from Test -- for illustration purposes only
declare @col1 as varchar(128) declare @col2 as varchar(128) declare @sq1 as varchar(8000) select @col1 = column_name from information_schema.columns where table_name = and ordinal_position = @position select @col2 = column_name from information_schema.columns where table_name = and ordinal_position = @position2 set @sql = exec(@sql)
select NULL as C1, NULL as C2 where 1 = 0 -- Returns empty table with predefined column names union all select * from Test -- There should be exactly 2 columns, but names and data type doesn
select table_name, column_name, ordinal_position, data_type from information_schema.columns order by 1,3
declare @tmp table(field1 sql_variant, field2 int, field3 sql_variant) insert into @tmp select * from Test select field2 from @tmp
SELECT CASE YourColumnNumber WHEN "1" THEN Col1 WHEN "2" THEN Col2 ELSE "?" END AS Result FROM Test
update persons set id=@p_id, name=@p_name, surname=@p_surname where id=@p_id if @@ROWCOUNT = 0 insert into persons(id, name, surname) values (@p_id, @p_name, @p_surname)
if exists (select id from persons where id = @p_id) update persons set id=@p_id, name=@p_name, surname=@p_surname where id=@p_id else insert into persons(id, name, surname) values (@p_id, @p_name, @p_surname)
begin tran insert into persons (id) select @p_id from persons where not exists (select * from persons where id = @p_id) update persons set name=@p_name, surname=@p_surname where id = @p_id commit
UPDATE MyTable SET SomeData = IF @@ROWCOUNT = 0 BEGIN INSERT MyTable SELECT 1, END
DECLARE @CodeNameString varchar(100) SELECT CodeName FROM AccountCodes ORDER BY Sort
DECLARE @CodeNameString varchar(100) SELECT @CodeNameString = STUFF( (SELECT FROM dbo.AccountCodes ORDER BY Sort FOR XML PATH( 1, 1,
DECLARE @CodeNameString varchar(max) SET @CodeNameString= SELECT @CodeNameString=@CodeNameString+CodeName FROM AccountCodes ORDER BY Sort SELECT @CodeNameString
declare @CodeNameString nvarchar(max) set @CodeNameString = null SELECT @CodeNameString = Coalesce(@CodeNameString + select @CodeNameString
declare @CodeNameString nvarchar(max) select @CodeNameString = COALESCE(@CodeNameString + select @CodeNameString
SELECT option_name, Field_M3_name, max(Option_value) AS "Option value", max(Sorting) AS "Sorted" FROM Value_list group by Option_name, Field_M3_name ORDER BY option_name, Field_M3_name
SELECT from1.keys, from1.option_name, from1.Field_M3_name, Stuff((SELECT DISTINCT WHERE COALESCE(from2.Option_name, .value( Stuff((SELECT DISTINCT WHERE COALESCE(from2.Option_name, .value( FROM ((SELECT DISTINCT COALESCE(Option_name, -- WHERE ) from1 ORDER BY keys
SELECT @@servername AS ,@@servicename AS ,DB_NAME() AS ,HOST_NAME() AS
USE DATABASE1 GO CREATE PROC spGetContext AS SELECT DB_NAME() GO USE DATABASE2 GO EXEC DATABASE1..spGetContext
USE MASTER CREATE FUNCTION sp_GetContext AS SELECT DB_NAME() GO EXEC sys.sp_MS_marksystemobject sp_GetContext USE DATABASE2 EXEC sp_GetContext
DECLARE @Sql NVARCHAR(MAX); SET @Sql = from SPCTable with(nolock) where Convert(varchar(10), Date_Tm, 120) Between @Date_From And @Date_To SET @Sql = DECLARE @Date_To VARCHAR(10); SET @Date_From = SET @Date_To = EXECUTE sp_executesql @Sql;
Msg 208, Level 16, State 0, Line 2 Invalid object name
declare @sql varchar(1000) set @sql="select * into set @sql =@sql + "select * from execute SP_EXECUTESQL @sql
declare @sql nvarchar(max) create table set @sql = insert into exec sp_executesql @sql select * from drop table
ALTER INDEX PK_mypk on MyTable SET (IGNORE_DUP_KEY = ON);
ON A warning message will occur when duplicate key values are inserted into a unique index. Only the rows violating the uniqueness constraint will fail. OFF An error message will occur when duplicate key values are inserted into a unique index. The entire INSERT operation will be rolled back.
ALTER TABLE [TableName] REBUILD WITH (IGNORE_DUP_KEY = ON)
CREATE TABLE dbo.foo (bar int PRIMARY KEY WITH (FILLFACTOR=90, IGNORE_DUP_KEY = ON)) GO INSERT dbo.foo VALUES (1) GO INSERT dbo.foo VALUES (1) GO --gives (1 row(s) affected) Duplicate key was ignored. (0 row(s) affected)
ALTER PROCEDURE [dbo].[CONVERT_Q_TO_O] @Q_ID int = NULL, @IDENTITY INT = NULL OUTPUT AS BEGIN SET NOCOUNT ON; DECLARE @EXISTING_RECORD_COUNT [int]; SELECT @EXISTING_RECORD_COUNT = COUNT (*) FROM [dbo].[O] WHERE [Q_ID] = @Q_ID IF @EXISTING_RECORD_COUNT = 0 BEGIN -- DO SOME STUFF HERE -- RETURN NEW ID SELECT @IDENTITY = SCOPE_IDENTITY() END ELSE BEGIN THROW 99001, END END GO
CREATE PROCEDURE dbo.THROW_EXCEPTION @Message VARCHAR(MAX), @Code VARCHAR(MAX) = -1 AS BEGIN DECLARE @BR VARCHAR(MAX) = CHAR(13) + CHAR(10) DECLARE @TAB VARCHAR(MAX) = DECLARE @T TABLE (X BIT) INSERT INTO @T (X) VALUES ( @BR + @TAB + + @BR + @TAB + + @BR) END
EXEC THROW_EXCEPTION -- OR EXEC THROW_EXCEPTION -- OR EXEC THROW_EXCEPTION
BEGIN TRY BEGIN TRAN -- do something IF @foobar IS NULL -- here i want to raise an error to rollback transaction -- do something next COMMIT TRAN END TRY BEGIN CATCH IF @@trancount > 0 ROLLBACK TRAN END CATCH
BEGIN TRY -- RAISERROR with severity 11-19 will cause execution to -- jump to the CATCH block. RAISERROR ( 16, -- Severity. 1 -- State. ); END TRY BEGIN CATCH DECLARE @ErrorMessage NVARCHAR(4000); DECLARE @ErrorSeverity INT; DECLARE @ErrorState INT; SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(); -- Use RAISERROR inside the CATCH block to return error -- information about the original error that caused -- execution to jump to the CATCH block. RAISERROR (@ErrorMessage, -- Message text. @ErrorSeverity, -- Severity. @ErrorState -- State. ); END CATCH;
THROW 50000, THROW <error_number>, <message>, <state>
RAISERROR ( { msg_id | msg_str | @local_variable } { ,severity ,state } [ ,argument [ ,...n ] ] ) [ WITH option [ ,...n ] ]
begin tran select * from foo with (updlock) where tableid = 1 -- notice there is no commit tran
begin tran select * from foo with (updlock, holdlock) where tableid = 1
CREATE TABLE [dbo].[foo]( [tableid] [int] IDENTITY(1,1) NOT NULL, [Col2] [varchar](100) NOT NULL, CONSTRAINT [PK_foo] PRIMARY KEY CLUSTERED ( [tableid] ASC ) )
begin tran select * from foo with (UPDLOCK, HOLDLOCK) where tableid = 1 UPDATE foo SET Col2 = where tableid = 1 commit tran
select * from INFORMATION_SCHEMA.TABLE_CONSTRAINTS where CONSTRAINT_TYPE=
select TC.Constraint_Name, CC.Column_Name from information_schema.table_constraints TC inner join information_schema.constraint_column_usage CC on TC.Constraint_Name = CC.Constraint_Name where TC.constraint_type = order by TC.Constraint_Name
SELECT * FROM sys.indexes i JOIN sys.index_columns ic ON i.index_id = ic.index_id AND i.object_id = ic.object_id WHERE i.is_unique_constraint = 1;
select * from INFORMATION_SCHEMA.TABLE_CONSTRAINTS where CONSTRAINT_TYPE=
select * from INFORMATION_SCHEMA.KEY_COLUMN_USAGE where CONSTRAINT_NAME=
select CONSTRAINT_NAME,COLUMN_NAME,TABLE_NAME from INFORMATION_SCHEMA.KEY_COLUMN_USAGE where CONSTRAINT_NAME=
Address -------------------- Aman Ja%lan% Stree% Ro%ad
declare @var char(1) set @var= select Address from Accomodation where Address like
CREATE TABLE T ( X VARCHAR(50), Y CHAR(3000) NULL ) CREATE NONCLUSTERED INDEX IX ON T(X) INSERT INTO T (X) SELECT TOP (5) FROM master..spt_values UNION ALL SELECT TOP (100000) FROM master..spt_values v1, master..spt_values v2 SET STATISTICS IO ON; SELECT * FROM T WHERE X LIKE SELECT * FROM T WHERE X LIKE
declare @var char(3) set @var= select Address from Accomodation where Address like
SELECT DATEADD(day, -1 - (DATEPART(weekday, GETDATE()) + @@DATEFIRST - 2) % 7, GETDATE() ) AS LastSunday
SELECT DATEADD(wk, DATEDIFF(wk, 6, CURRENT_TIMESTAMP), 6) AS LAST_SUNDAY
SELECT DATEADD(wk, DATEDIFF(wk, 7, CURRENT_TIMESTAMP), 7) AS START_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 6, CURRENT_TIMESTAMP), 6 + 7) AS END_OF_WEEK
START_OF_WEEK ----------------------- 2011-05-02 00:00:00.000 END_OF_WEEK ----------------------- 2011-05-08 00:00:00.000
SELECT DATEADD(wk, DATEDIFF(wk, -2, CURRENT_TIMESTAMP), -2) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, -1, CURRENT_TIMESTAMP), -1) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 0, CURRENT_TIMESTAMP), 0) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 1, CURRENT_TIMESTAMP), 1) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 2, CURRENT_TIMESTAMP), 2) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 3, CURRENT_TIMESTAMP), 3) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 4, CURRENT_TIMESTAMP), 4) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 5, CURRENT_TIMESTAMP), 5) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 6, CURRENT_TIMESTAMP), 6) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 7, CURRENT_TIMESTAMP), 7) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 8, CURRENT_TIMESTAMP), 8) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 9, CURRENT_TIMESTAMP), 9) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 10, CURRENT_TIMESTAMP), 10) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 11, CURRENT_TIMESTAMP), 11) AS DAY_OF_WEEK SELECT DATEADD(wk, DATEDIFF(wk, 12, CURRENT_TIMESTAMP), 12) AS DAY_OF_WEEK etc...
DECLARE @LastSunday DATETIME -- This will get the previous Sunday with time as 23:59:59 SELECT @LastSunday = Dateadd(SECOND, -1, Dateadd(WK, Datediff(WK, 6, CURRENT_TIMESTAMP) , 7)) SELECT @LastSunday -- This gets the monday prior to it and time of 00:00:00 SELECT Dateadd(SECOND, 1, Dateadd(DAY, -7, @LastSunday)) -- This will make you time spans between eg, Monday 16/07/2012 00:00:00 through to Sunday 22/07/2012 23:59:59 -- Then use them in your WHERE clause like this -- SELECT X,Y,Z From SomeTable -- WHERE DateField BETWEEN @PreviousMondayToLastSunday AND @LastSunday
DATEADD(day,- (DATEPART(dw,getdate()) + @@DATEFIRST -1) % 7, getdate())
select max(cal_date) end_of_last_week from calendar where (cal_date < current_date and day_of_week = end_of_last_week -- 2011-05-01
SELECT (DATEADD(DAY, ((DATEPART(dw, @Date) - 1) * -1), @Date))
DECLARE @PREVIOUS int, @dtmStart datetime,@dtmEnd datetime, @NEXT int; SET @dtmStart = SET @dtmEnd = select @PREVIOUS = datepart(dw,@dtmStart) WHILE @PREVIOUS <> 6 BEGIN SET @dtmStart = DATEADD(day , -1 ,@dtmStart) SET @PREVIOUS = datepart(dw,@dtmStart) CONTINUE END select @dtmStart SELECT @NEXT = DATEPART(dw, @dtmEnd) WHILE @NEXT <> 6 BEGIN SET @dtmEnd = DATEADD(day , 1 ,@dtmEnd) SET @NEXT = datepart(dw,@dtmEnd) CONTINUE END select @dtmEnd
declare @lastSaturday date, @today date, @todayName varchar(20); select @todayName = datename(weekday, getdate()), @today = getdate(); select case @todayName when when when when when when when end as LastSaturday;
ALTER TABLE mytable ALTER COLUMN name NVARCHAR(128) NULL
DECLARE @table_id AS INT DECLARE @name_column_id AS INT DECLARE @sql nvarchar(255) -- Find table id SET @table_id = OBJECT_ID( -- Find name column id SELECT @name_column_id = column_id FROM sys.columns WHERE object_id = @table_id AND name = -- Remove default constraint from name column SELECT @sql = FROM sys.default_constraints AS D WHERE D.parent_object_id = @table_id AND D.parent_column_id = @name_column_id EXECUTE sp_executesql @sql
ALTER TABLE <schema_name, sysname, dbo>.<table_name, sysname, table_name> DROP CONSTRAINT <default_constraint_name, sysname, default_constraint_name> GO
-- t-sql scriptlet to drop all constraints on a table DECLARE @database nvarchar(50) DECLARE @table nvarchar(50) set @database = set @table = DECLARE @sql nvarchar(255) WHILE EXISTS(select * from INFORMATION_SCHEMA.TABLE_CONSTRAINTS where constraint_catalog = @database and table_name = @table) BEGIN select @sql = from INFORMATION_SCHEMA.TABLE_CONSTRAINTS where constraint_catalog = @database and table_name = @table exec sp_executesql @sql END
DECLARE @sqlStatement nvarchar(MAX), @tableName nvarchar(50) = @columnName nvarchar(50) = SELECT @sqlStatement = FROM sys.default_constraints AS dc LEFT JOIN sys.columns AS sc ON (dc.parent_column_id = sc.column_id) WHERE dc.parent_object_id = OBJECT_ID(@tableName) AND type_desc = AND sc.name = @columnName PRINT IF(LEN(@sqlStatement)>0)EXEC sp_executesql @sqlStatement
DECLARE @Command NVARCHAR(MAX) declare @table_name nvarchar(256) declare @col_name nvarchar(256) set @table_name = N set @col_name = N select @Command = from sys.tables t join sys.default_constraints d on d.parent_object_id = t.object_id join sys.columns c on c.object_id = t.object_id and c.column_id = d.parent_column_id where t.name = @table_name and c.name = @col_name) + --print @Command exec sp_executesql @Command
ALTER TABLE [dbo].[ProcedureAlerts] ADD DEFAULT((0)) FOR [EmailSent]
CREATE PROCEDURE MyProc @recordCount INT OUTPUT @param1 INT ...
from [table] with (index([clustered columnstore index name]))
insert * from db1/table1 into db2/table2 where rule1 = true
Select * From ServerName.DbName.SchemaName.TableName
EXEC sp_configure GO RECONFIGURE GO EXEC sp_configure GO RECONFIGURE GO SELECT * FROM OPENDATASOURCE( User ID=<SQL User Name>;Password=<SQL password> Go
select columnName1, columnName2, etc from serverName.databaseName.schemaName.tableName
CREATE VIEW newR1 AS SELECT * from OPENQUERY ([INSTANCE_NAME],
* views having columns with derived (i.e., computed) data in the SELECT-list * views that do not contain all columns defined as NOT NULL from the tables from which they were defined
