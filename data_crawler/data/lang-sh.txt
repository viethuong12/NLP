pwd= `pwd` until [ $pwd = "/" ] do echo $pwd ls && cd .. && ls $pwd= `pwd` done
until [ "$PWD" = "/" ]; do echo "$PWD" ls && cd .. && ls done
DIR=$(pwd) echo $DIR while [ "$DIR" != "/" ]; do cd .. DIR=$(pwd) echo $DIR done
symlink-hook: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory symlink-hook: error retrieving current directory: getcwd: cannot access parent directories: Success symlink-hook: error retrieving current directory: getcwd: cannot access parent directories: Success symlink-hook: error retrieving current directory: getcwd: cannot access parent directories: Success symlink-hook: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory symlink-hook: error retrieving current directory: getcwd: cannot access parent directories: Success symlink-hook: error retrieving current directory: getcwd: cannot access parent directories: Success symlink-hook: error retrieving current directory: getcwd: cannot access parent directories: Success
shell-init: error retrieving current directory: getcwd: cannot access parent directories: No s uch file or directory
for fn in `cat filenames.txt`; do echo "the next file is $fn" cat $fn done
while read filename do echo "Printing: $filename" cat "$filename" done < filenames.txt
xargs --arg-file inputfile -I % sh -c "echo %; cat %"
pax> cat qq.in normalfile.txt file with spaces.doc pax> sed <<contents of <<contents of pax> _
/bin/bash The bash executable /etc/profile The systemwide initialization file, executed for login shells ~/.bash_profile The personal initialization file, executed for login shells ~/.bashrc The individual per-interactive-shell startup file ~/.bash_logout The individual login shell cleanup file, executed when a login shell exits ~/.inputrc Individual readline initialization file
if [ "$a" -ge 10 ] then elif [ "$a" -le 5 ] then echo "1" else echo "2" fi
if [ "$a" -ge 10 ] then : elif [ "$a" -le 5 ] then echo "1" else echo "2" fi
if [ "$a" -ge 10 ]; then true elif [ "$a" -le 5 ]; then echo "1" else echo "2" fi
if [ "$a" -le 5 ]; then echo "1" elif [ "$a" -lt 10 ]; then echo "2" fi
if [ "$a" -lt 10 ] && [ "$a" -le 5 ] then echo "1" elif [ "$a" -lt 10 ] then echo "2" fi
if [ "$a" -lt 10 ] then if [ "$a" -le 5 ] then echo "1" else echo "2" fi fi
$ echo hello > bash: syntax error near unexpected token `newline` $ echo hello > ${NONEXISTENT} bash: ${NONEXISTENT}: ambiguous redirect $ echo hello > "${NONEXISTENT}" bash: : No such file or directory
michael@isolde:~/junk$ ABC=junk.txt michael@isolde:~/junk$ echo "Booger" > $ABC michael@isolde:~/junk$ echo "Booger" >> $ABB bash: $ABB: ambiguous redirect michael@isolde:~/junk$
echo $AAAA" "$DDDD" "$MOL_TAG >> "${OUPUT_RESULTS}"
$ var="file with spaces" $ echo $AAAA" "$DDDD" "$MOL_TAG >> ${var} bash: ${var}: ambiguous redirect $ echo $AAAA" "$DDDD" "$MOL_TAG >> "${var}" $ cat file\ with\ spaces aaaa dddd mol_tag
foo | bar > /tmp/a baz | quux > /tmp/b diff /tmp/a /tmp/b
foo | bar > file1.txt && baz | quux > file2.txt && diff file1.txt file2.txt
diff <(foo | bar) <(baz | quux) foo | bar | diff - <(baz | quux)
mkfifo file1_pipe.txt foo|bar > file1_pipe.txt && baz | quux | diff file1_pipe.txt - && rm file1_pipe.txt
cat *.txt | tee >(foo | bar > result1.txt) >(baz | quux > result2.txt) | foobar
comm -23 <(seq 100 | sort) <(seq 10 20 && sleep 5 && seq 20 30 | sort)
$ find . -name foo.txt ./home/user/some/directory/foo.txt
mv <some-variable-that-contains-the-result> /some/new/location
$ which python /usr/bin/python $ s $ file $it /usr/bin/python: symbolic link to `python2.6'
> grab date Do 16. Feb 13:05:04 CET 2012 > echo $grab Do 16. Feb 13:05:04 CET 2012
output=`program arguments` echo $output emacs $output
$find . -iname ./foo.cpp ./bar.cpp $vi `!!` 2 files to edit
$grep -R "some variable" * | grep -v tags ./foo/bar/xxx ./bar/foo/yyy $vi `!!`
$ find . -name foo.txt ./home/user/some/directory/foo.txt $ OUTPUT=`!!` $ echo $OUTPUT ./home/user/some/directory/foo.txt $ mv $OUTPUT somewhere/else/
$ OUTPUT=`find . -name foo.txt` $ echo $OUTPUT ./home/user/some/directory/foo.txt
find . -name foo.txt | while IFS= read -r var; do echo "$var" done
~]$ ls *.~ class1.cpp~ class1.h~ main.cpp~ CMakeList.txt~ ~]$ rm !!:1 rm class1.cpp~ class1.h~ main.cpp~ CMakeList.txt~ ~]$ ls file_to_remove1 file_to_remove2 file_to_remove1 file_to_remove2 ~]$ rm !!:1 rm file_to_remove1 ~]$ rm !!:2 rm file_to_remove2
$ which gradle /usr/bin/gradle $ ls -alrt /usr/bin/gradle
rasjani@helruo-dhcp022206::~$ find a a a/foo a/bar a/bat a/baz rasjani@helruo-dhcp022206::~$
rasjani@helruo-dhcp022206::~$ cd `find a |sed rasjani@helruo-dhcp022206::~/a/baz$ pwd /home/rasjani/a/baz rasjani@helruo-dhcp022206::~/a/baz$
find . -name foo.txt 1> tmpfile && mv `cat tmpfile` /path/to/some/dir/
set -x echo `expr 10 + 20 ` + expr 10 + 20 + echo 30 30
/home/clawlor/bin/scripts/djangoenv: 20: source: not found
PYTHON_PATH=~/bin/python-2.6.1/bin/python if [ $ then ENV_NAME="$1" virtualenv -p $PYTHON_PATH --no-site-packages $ENV_NAME activate="`pwd`/$ENV_NAME/bin/activate" if [ ! -f "$activate" ] then echo "ERROR: activate not found at $activate" return 1 fi source "$activate" else echo fi
$ grep -cve config.hh:36 exceptions.hh:48 layer.hh:52 main.hh:39
grep -cvE -c = count -v = exclude -E = extended regex where ^ = beginning of the line \s = whitespace * = any number of previous characters or none [/*] = either / or * | = OR $ = end of the line
excluded="spec\|node_modules\|README\|lib\|docs\|csv\|XLS\|json\|png" countLines(){ total=0 for file in `find . -mindepth 1 -name "*.*" |grep -v "$excluded"`; do numLines=`cat $file | sed total=$(($total + $numLines)) echo " " $numLines $file done echo " " $total in total } echo Source code files: countLines echo Unit tests: cd spec countLines
Source code files: 2 ./buildDocs.sh 24 ./countLines.sh 15 ./css/dashboard.css 53 ./data/un_population/provenance/preprocess.js 19 ./index.html 5 ./server/server.js 2 ./server/startServer.sh 24 ./SpecRunner.html 34 ./src/computeLayout.js 60 ./src/configDiff.js 18 ./src/dashboardMirror.js 37 ./src/dashboardScaffold.js 14 ./src/data.js 68 ./src/dummyVis.js 27 ./src/layout.js 28 ./src/links.js 5 ./src/main.js 52 ./src/processActions.js 86 ./src/timeline.js 73 ./src/udc.js 18 ./src/wire.js 664 in total Unit tests: 230 ./ComputeLayoutSpec.js 134 ./ConfigDiffSpec.js 134 ./ProcessActionsSpec.js 84 ./UDCSpec.js 149 ./WireSpec.js 731 in total
( echo 0; for ext in "$@"; do for i in $(find . -name "*$ext"); do sed echo +; done done echo p q; ) | dc;
while read line do grep -cve done < <(find $1 -name "*.$2" -print) | awk
$ tar cz my_large_file_1 my_large_file_2 | split -b 1024MiB - myfiles_split.tgz_ $ cat myfiles_split.tgz_* | tar xz
$ gzip -c my_large_file | split -b 1024MiB - myfile_split.gz_ $ cat myfile_split.gz_* | gunzip -c > my_large_file
gzip -c file.orig > file.gz CHUNKSIZE=1073741824 PARTCNT=$[$(stat -c%s file.gz) / $CHUNKSIZE] for n in `seq 0 $PARTCNT` do dd if=file.gz of=part.$n bs=$CHUNKSIZE skip=$n count=1 done
gzip -c file.orig | ( CHUNKSIZE=1073741824; i=0; while true; do i=$[i+1]; head -c "$CHUNKSIZE" > "part.$i"; [ "$CHUNKSIZE" -eq $(stat -c%s "part.$i") ] || break; done; )
egrep -ir --include=*.{php,html,js} "(document.cookie|setcookie)" .
egrep -lir --include=*.{php,html,js} "(document.cookie|setcookie)" .
find /starting/path -type f -name "*.php" -o -name "*.html" -o -name "*.js" | \ xargs egrep -i
find . -type f \( -name *.php -o -name *.html -o -name *.js \) -exec grep "document.cookie\|setcookie" /dev/null {} \;
cat ${MYSQLDUMP} | \ sed tr ",;" "\n" | \ sed -e sed -n -e sed -e tr "\n" "," | \ sed -e sed -e
cat ${MYSQLDUMP} | \ sed tr ",;" "\n" | \ sed -e sed -n -e sed -e tr "\n" "," | \ sed -e sed -e
cat ${MYSQLDUMP} | sed tr ",;" "\n" | sed -e sed -n -e sed -e tr "\n" "," | sed -e sed -e
$ ls file ls: cannot access $ echo foo${IFS foo bar $ ls file file
$ IFS=x $ echo foo${IFS foo bar $ echo foo${IFS foobar
function bashcat { printf function scat { 1>&2 bashcat; exit 1; } [[ -z ${__+x} ]] && declare -r __ || scat <<EOF Error: the parameter __= comment-idiom EOF ${__+ (example of inline comments) ------------------------------------------------ the following inline comment-idiom is supported <code> ${__+ <comment>} <code> <code> ${__+ <multiline comment>} <code> (advisory) the parameter even the null declaration __= (advisory) protect unbalanced delimiters \} and \) (advisory) NO parameter-expansion of <comment> (advisory) NO subprocesses are spawned (advisory) a functionally equivalent idiom is <code> ` <code> ` comment>` <code> however each comment spawns a bash subprocess that inelegantly requires ~1ms of computation ------------------------------------------------}
if [ -s diff.txt ] then touch empty.txt rm full.txt else touch full.txt rm emtpy.txt fi
if [ -s diff.txt ] then rm -f empty.txt touch full.txt else rm -f full.txt touch empty.txt fi
if [[ -s diff.txt ]]; then echo "file has something"; else echo "file is empty"; fi
for file in $(ls *.txt); do if [[ ! -s $file ]]; then echo $file; fi; done
if [ -f diff.txt ] then if [ -s diff.txt ] then rm -f empty.txt touch full.txt else rm -f full.txt touch empty.txt fi else echo "File diff.txt does not exist" fi
if [[ -f diff.txt && -s diff.txt ]] then rm -f empty.txt touch full.txt elif [[ -f diff.txt && ! -s diff.txt ]] then rm -f full.txt touch empty.txt else echo "File diff.txt does not exist" fi
typeset read_file="/tmp/some-file.txt" if [ ! -s "${read_file}" ] || [ ! -f "${read_file}" ] ;then echo "Error: file (${read_file}) not found.. " exit 7 fi
"\C-[OA": history-search-backward "\C-[[A": history-search-backward "\C-[OB": history-search-forward "\C-[[B": history-search-forward
# # "\C-[OD" backward-char "\C-[OC" forward-char "\C-[OA" previous-history "\C-[OB" next-history # # "\C-[[D" backward-char "\C-[[C" forward-char "\C-[[A" previous-history "\C-[[B" next-history # # "\C-M-OD" backward-char "\C-M-OC" forward-char "\C-M-OA" previous-history "\C-M-OB" next-history # # "\C-M-[D" backward-char "\C-M-[C" forward-char "\C-M-[A" previous-history "\C-M-[B" next-history
"\C-[OA": history-search-backward "\C-[OB": history-search-forward "\C-[OC": forward-char "\C-[OD": backward-char "\C-[[A": history-search-backward "\C-[[B": history-search-forward "\C-[[C": forward-char "\C-[[D": backward-char
myFunction { echo $1 echo $2 echo $3 } myFunction "firstString" "second string with spaces" "thirdString"
myFunction() { eval string1="$1" eval string2="$2" eval string3="$3" echo "string1 = ${string1}" echo "string2 = ${string2}" echo "string3 = ${string3}" } var1="firstString" var2="second string with spaces" var3="thirdString" myFunction "\${var1}" "\${var2}" "\${var3}" exit 0
string1 = firstString string2 = second string with spaces string3 = thirdString
getField(){ detailedString="$1" fieldNumber=$2 echo ${detailedString} | awk -F } while read LINE do var1="$LINE" iputId=$(getField "${var1}" 3) done<${someFile} exit 0
getField(){ detailedString="$1" fieldNumber=$2 echo ${detailedString} | awk -F } while read LINE do var1="$LINE" iputId=$(getField "${var1}" "3") done<${someFile} exit 0
myFunction() { echo $1 echo $2 echo $3 } myFunction "firstString" "\"Hello World\"" "thirdString"
Test(){ set -x grep "$@" /etc/hosts set +x } Test -i "3 rb" + grep -i
function status(){ if [ $1 != "stopped" ]; then artist="ABC"; track="CDE"; album="DEF"; status_message="The current track is $track at $album by $artist"; echo $status_message; read_status $1 "$status_message"; fi } function read_status(){ if [ $1 != "playing" ]; then echo $2 fi }
function myFunction { for i in $*; do echo $i; done; }
zenity \ --info \ --text="<span size=\"xx-large\">Time is $(date +%Hh%M).</span>\n\nGet your <b>coffee</b>." \ --title="Coffee time" \ --ok-label="Sip"
xmessage -buttons Ok:0,"Not sure":1,Cancel:2 -default Ok -nearmouse "Is xmessage enough for the job ?" -timeout 10
echo My text | yad \ --text-info \ --width=400 \ --height=200
yad \ --title="Desktop entry editor" \ --text="Simple desktop entry editor" \ --form \ --field="Type:CB" \ --field="Name" \ --field="Generic name" \ --field="Comment" \ --field="Command:FL" \ --field="Icon" \ --field="In terminal:CHK" \ --field="Startup notify:CHK" "Application" "Name" "Generic name" "This is the comment" "/usr/bin/yad" "yad" FALSE TRUE \ --button="WebUpd8:2" \ --button="gtk-ok:0" \ --button="gtk-cancel:1"
whiptail --msgbox "my text" 10 20 dialog --msgbox "my text" 10 20
pack [label .msg -text [lindex $argv 0]] pack [entry .ent] bind .ent <KeyPress-Return> { puts [.ent get]; destroy . } focus .ent
myanswer=`gui-prompt "type your answer and press enter"`
notify-send "job complete" notify-send -u critical "job complete"
SEARCH_FOLDER="/tmp/*" for f in $SEARCH_FOLDER do if [ -d "$f" ] then for ff in $f/* do echo "Processing $ff" done else echo "Processing file $f" fi done
shopt -s globstar for f in /tmp/*.pdf /tmp/*.doc tmp/**/*.pdf tmp/**/*.doc ; do rm "$f" done
recursiverm() { for d in *; do if [ -d "$d" ]; then (cd -- "$d" && recursiverm) fi rm -f *.pdf rm -f *.doc done } (cd /tmp; recursiverm)
print_folder_recurse() { for i in "$1"/*;do if [ -d "$i" ];then echo "dir: $i" print_folder_recurse "$i" elif [ -f "$i" ]; then echo "file: $i" fi done } path="" if [ -d "$1" ]; then path=$1; else path="/tmp" fi echo "base path: $path" print_folder_recurse $path
find /tmp \( -name "*.pdf" -o -name "*.doc" \) -type f -exec rm {} +
find /tmp \( -name "*.pdf" -o -name "*.doc" \) -type f -delete
files="$(find -L "$dir" -type f)" echo "Count: $(echo -n "$files" | wc -l)" echo "$files" | while read file; do echo "$file" done
function count() { files="$(find -L "$1" -type f)"; if [[ "$files" == "" ]]; then echo "No files"; return 0; fi file_count=$(echo "$files" | wc -l) echo "Count: $file_count" echo "$files" | while read file; do echo "$file" done }
function check { for file in $1/* do if [ -d "$file" ] then check $file else if [ $(head -c 4 "$file") = "%PDF" ]; then rm -r $file fi fi done } domain=/home/ubuntu check $domain
read -p "Enter: " name name=${name:-Richard} echo $name
read -e -p "Enter Your Name:" -i "Ricardo" NAME echo $NAME
name="Ricardo" read -e -i "$name" -p "Please enter your name: " input name="${input:-$name}"
IN_PATH_DEFAULT="/tmp/input.txt" read -p "Please enter IN_PATH [$IN_PATH_DEFAULT]: " IN_PATH IN_PATH="${IN_PATH:-$IN_PATH_DEFAULT}" OUT_PATH_DEFAULT="/tmp/output.txt" read -p "Please enter OUT_PATH [$OUT_PATH_DEFAULT]: " OUT_PATH OUT_PATH="${OUT_PATH:-$OUT_PATH_DEFAULT}" echo "Input: $IN_PATH Output: $OUT_PATH"
Please enter IN_PATH [/tmp/input.txt]: Please enter OUT_PATH [/tmp/output.txt]: ~/out.txt Input: /tmp/input.txt Output: ~/out.txt
echo -n "Something interesting happened. " DEFAULT="y" read -e -p "Proceed [Y/n/q]:" PROCEED PROCEED="${PROCEED:-${DEFAULT}}" PROCEED="${PROCEED,,}" if [ "${PROCEED}" == "q" ] ; then echo "Quitting" exit elif [ "${PROCEED}" != "y" ] ; then echo "Not Proceeding" else echo "Proceeding" fi
name=Ricardo echo "Please enter your name: $name \c" read newname [ -n "$newname" ] && name=$newname
echo "Please enter some input: " read input_variable echo $input_variable | awk
QMESSAGE="SHOULD I DO YES OR NO" YMESSAGE="I DO" NMESSAGE="I DO NOT" FMESSAGE="PLEASE ENTER Y or N" COUNTDOWN=2 DEFAULTVALUE=n function REQUEST () { read -n1 -t$COUNTDOWN -p "$QMESSAGE ? Y/N " INPUT INPUT=${INPUT:-$DEFAULTVALUE} if [ "$INPUT" = "y" -o "$INPUT" = "Y" ] ;then echo -e "\n$YMESSAGE\n" elif [ "$INPUT" = "n" -o "$INPUT" = "N" ] ;then echo -e "\n$NMESSAGE\n" else echo -e "\n$FMESSAGE\n" REQUEST fi } REQUEST
syntax "gitignore" "\.gitignore$" formatter vim -c :sort -c :wq -E -s
mvn clean install $@ | tee $logfile echo ${PIPESTATUS[0]}
$ false | tee /dev/null ; echo $? 0 $ set -o pipefail $ false | tee /dev/null ; echo $? 1
$ { false ; echo $? > /tmp/false.status ; } | tee $logfile $ cat /tmp/false.status 1
f=`mktemp` (mvn clean install $@; echo $?>$f) | tee $logfile e=`cat $f` rm $f
$ man 1 kill ... If sig is 0, then no signal is sent, but error checking is still performed. ...
$ man 2 kill ... If sig is 0, then no signal is sent, but error checking is still performed; this can be used to check for the existence of a process ID or process group ID. ...
sleep 60 & pid=$! kill -0 $pid && kill $pid kill -0 $pid; echo "Exit status: $?"
mydir=$(mktemp -d "${TMPDIR:-/tmp/}$(basename $0).XXXXXXXXXXXX")
for file in "$PATH_TO_SOMEWHERE"; do if [ -d $file ] then else if [ "$file" == "*.txt" ] then fi fi done;
if [ $(mimetype -b "$MyFile") == "text/plain" ] then echo "this is a text file" fi
CACHE=~/.mozilla/firefox/xxxxxxxx.default/Cache OUTPUTDIR=~/Videos/flvs MINFILESIZE=2M for f in `find $CACHE -size +$MINFILESIZE` do a=$(file $f | cut -f2 -d o=$(basename $f) if [ "$a" = "Macromedia" ] then cp "$f" "$OUTPUTDIR/$o" fi done nautilus "$OUTPUTDIR"&
find <directory> -maxdepth 1 -type d -exec ... \; find <directory> -maxdepth 1 -type f -name "*.txt" -exec ... \;
find <directory> -maxdepth 1 -type d | while read dir; do echo $dir; ...; done find <directory> -maxdepth 1 -type f -name "*.txt" | while read txtfile; do echo $txtfile; ...; done
find <directory> -maxdepth 1 -type d | xargs ... find <directory> -maxdepth 1 -type f -name "*.txt" | xargs ...
for fname in $(find . -maxdepth 1 -type f) do echo ${fname done
>MY_DATA_FILE="my_file.sql" >FILE_EXT=$(awk -F >if [ "sql" = "$FILE_EXT" ] >then > echo "file is sql" >fi >awk -F >hi_mom.txt >my_file.jpg >eof
hadoop-user@hadoop-desk:~$ echo $TERM xterm hadoop-user@hadoop-desk:~$ stty -a speed 38400 baud; rows 47; columns 158; line = 0; intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0; -parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8 opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke hadoop-user@hadoop-desk:~$ echo $COLUMNS 158
darragh@darraghserver ~ $uname -a SunOS darraghserver 5.10 Generic_142901-13 i86pc i386 i86pc darragh@darraghserver ~ $which ps /usr/bin/ps<br> darragh@darraghserver ~ $/usr/ucb/ps auxww | grep ps darragh 13680 0.0 0.0 3872 3152 pts/1 O 14:39:32 0:00 /usr/ucb/ps -auxww darragh 13681 0.0 0.0 1420 852 pts/1 S 14:39:32 0:00 grep ps
-w Wide output. Use this option twice for unlimited width. w Wide output. Use this option twice for unlimited width.
/usr/lib/postgresql/9.5/bin 29900 Thu May 11 10:41:59 2017 postgres: checkpointer proc 29902 Thu May 11 10:41:59 2017 postgres: writer process 29903 Thu May 11 10:41:59 2017 postgres: wal writer proces 29904 Thu May 11 10:41:59 2017 postgres: autovacuum launch 29905 Thu May 11 10:41:59 2017 postgres: stats collector p 29906 Thu May 11 10:41:59 2017 [kworker/2:0] 30188 Fri May 12 09:20:17 2017 /usr/lib/upower/upowerd 30651 Mon May 8 09:57:58 2017 /usr/sbin/apache2 -k start 31288 Fri May 12 07:35:01 2017 /usr/sbin/apache2 -k start 31289 Fri May 12 07:35:01 2017 /sbin/rpc.statd --no-notify 31635 Mon May 8 09:49:12 2017 /sbin/rpcbind -f -w 31637 Mon May 8 09:49:12 2017 [nfsiod] 31645 Mon May 8 09:49:12 2017 [kworker/1:0] 31801 Fri May 12 09:49:15 2017 [kworker/u16:0] 32658 Fri May 12 11:00:51 2017
29900 Thu May 11 10:41:59 2017 /usr/lib/postgresql/9.5/bin/postgres -D /tmp/4493-d849-dc76-9215 -p 38103 29902 Thu May 11 10:41:59 2017 postgres: checkpointer process 29903 Thu May 11 10:41:59 2017 postgres: writer process 29904 Thu May 11 10:41:59 2017 postgres: wal writer process 29905 Thu May 11 10:41:59 2017 postgres: autovacuum launcher process 29906 Thu May 11 10:41:59 2017 postgres: stats collector process 30188 Fri May 12 09:20:17 2017 [kworker/2:0] 30651 Mon May 8 09:57:58 2017 /usr/lib/upower/upowerd 31288 Fri May 12 07:35:01 2017 /usr/sbin/apache2 -k start 31289 Fri May 12 07:35:01 2017 /usr/sbin/apache2 -k start 31635 Mon May 8 09:49:12 2017 /sbin/rpc.statd --no-notify 31637 Mon May 8 09:49:12 2017 /sbin/rpcbind -f -w 31645 Mon May 8 09:49:12 2017 [nfsiod] 31801 Fri May 12 09:49:15 2017 [kworker/1:0] 32658 Fri May 12 11:00:51 2017 [kworker/u16:0]
ps aux | grep some_proces[s] > /tmp/test.txt && if [ $? -eq 0 ]; then echo 1; else echo 0; fi
ps aux | grep some_proces[s] > /tmp/test.txt && echo 1 || echo 0
if ps aux | grep some_proces[s] > /tmp/test.txt; then echo 1; else echo 0; fi
if [[ $(ps aux | grep process | grep -vc grep) > 0 ]] ; then echo 1; else echo 0 ; fi
ps aux | grep some_proces[s] > /tmp/test.txt && echo 1 || echo 0
ps aux | grep some_proces | grep -vw grep > /tmp/test.txt && echo 1 || echo 0
%q causes printf to output the corresponding argument in a format that can be reused as shell input.
read foo Hello world printf "%q\n" "$foo" Hello\ world printf "%q\n" $ $
for i in {0..127} ;do printf -v var \\%o $i printf -v var $var printf -v res "%q" "$var" esc=E [ "$var" = "$res" ] && esc=- printf "%02X %s %-7s\n" $i $esc "$res" done | column
00 E 01 E $ 02 E $ 03 E $ 04 E $ 05 E $ 06 E $ 07 E $ 08 E $ 09 E $ 0A E $ 0B E $ 0C E $ 0D E $ 0E E $ 0F E $ 10 E $ 11 E $ 12 E $ 13 E $ 14 E $ 15 E $ 16 E $ 17 E $ 18 E $ 19 E $
echo test{1,2,3} test1 test2 test3 echo test\ {1,2,3} test 1 test 2 test 3 echo test\ {\ 1,\ 2,\ 3\ } test 1 test 2 test 3 echo test\ {\ 1\,\ 2,\ 3\ } test 1, 2 test 3
special=$ for ((i=0; i < ${ char="${special:i:1}" printf -v q_char if [[ "$char" != "$q_char" ]]; then printf else printf fi done | sort
No, character % does not need to be escaped No, character + does not need to be escaped No, character - does not need to be escaped No, character . does not need to be escaped No, character / does not need to be escaped No, character : does not need to be escaped No, character = does not need to be escaped No, character @ does not need to be escaped No, character _ does not need to be escaped Yes, character needs to be escaped Yes, character ! needs to be escaped Yes, character " needs to be escaped Yes, character Yes, character $ needs to be escaped Yes, character & needs to be escaped Yes, character Yes, character ( needs to be escaped Yes, character ) needs to be escaped Yes, character * needs to be escaped Yes, character , needs to be escaped Yes, character ; needs to be escaped Yes, character < needs to be escaped Yes, character > needs to be escaped Yes, character ? needs to be escaped Yes, character [ needs to be escaped Yes, character \ needs to be escaped Yes, character ] needs to be escaped Yes, character ^ needs to be escaped Yes, character ` needs to be escaped Yes, character { needs to be escaped Yes, character | needs to be escaped Yes, character } needs to be escaped
cd /tmp find . -maxdepth 1 -mindepth 1 -type d -printf
for dir in /tmp/*/ do dir=${dir%*/} echo ${dir done
for file in */ .*/ ; do echo "$file is a directory"; done
shopt -s dotglob; for file in */ ; do echo "$file is a directory"; done
for file in */ ; do if [[ -d "$file" && ! -L "$file" ]]; then echo "$file is a directory"; fi; done
file="${file%/}" file="${file echo "$file is the directoryname without slashes"
mkdir /tmp/A /tmp/B /tmp/C "/tmp/ dir with spaces" for file in /tmp/*/ ; do file="${file%/}"; echo "${file
while IFS= read -d $ echo $file; ls $file ; done < <(find /path/to/dir/ -mindepth 1 -maxdepth 1 -type d -print0)
for D in $(find /path/to/dir/ -mindepth 1 -maxdepth 1 -type d) ; do echo $D ; done
find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n"
find . -type f -print0 | xargs -0 chmod go+r find . -type d -print0 | xargs -0 chmod go+rx
if [ -n file.txt ] then echo "everything is good" else mail -s "file.txt size is zero, please fix. " myemail@gmail.com < /dev/null wget -c https: mv -f /root/tmp/file.txt /var/www/file.txt fi
file=file.txt minimumsize=90000 actualsize=$(wc -c <"$file") if [ $actualsize -ge $minimumsize ]; then echo size is over $minimumsize bytes else echo size is under $minimumsize bytes fi
file=file.txt minimumsize=90 actualsize=$(du -k "$file" | cut -f 1) if [ $actualsize -ge $minimumsize ]; then echo size is over $minimumsize kilobytes else echo size is under $minimumsize kilobytes fi
size=$(stat -f%z $filename) size=$(stat -c%s $filename)
FILENAME=file.txt SIZE=$(du -sb $FILENAME | awk if ((SIZE<90000)) ; then echo "less"; else echo "not less"; fi
find -maxdepth 1 -name "file.txt" -size -90k -exec script \;
function filesize { local file=$1 size=`stat -c%s $file 2>/dev/null` if [ $? -eq 0 ] then echo $size return 0 fi eval $(stat -s $file) if [ $? -eq 0 ] then echo $st_size return 0 fi return -1 }
$ set debian-live-8.2.0-amd64-xfce-desktop.iso $ strace stat --format %s $1 | wc 282 2795 27364 $ strace wc --bytes $1 | wc 307 3063 29091 $ strace du --bytes $1 | wc 437 4376 41955 $ strace find $1 -printf %s | wc 604 6061 64793
faketty() { script -qfc "$(printf "%q " "$@")" /dev/null }
$ python -c "import sys; print sys.stdout.isatty()" True $ python -c "import sys; print sys.stdout.isatty()" | cat False $ faketty python -c "import sys; print sys.stdout.isatty()" | cat True
int main(int argc, char **argv) { int master; struct winsize win = { .ws_col = 80, .ws_row = 24, .ws_xpixel = 480, .ws_ypixel = 192, }; pid_t child; if (argc < 2) { printf("Usage: %s cmd [args...]\n", argv[0]); exit(EX_USAGE); } child = forkpty(&master, NULL, NULL, &win); if (child == -1) { perror("forkpty failed"); exit(EX_OSERR); } if (child == 0) { execvp(argv[1], argv + 1); perror("exec failed"); exit(EX_OSERR); } /* now the child is attached to a real pseudo-TTY instead of a pipe, * while the parent can use "master" much like a normal pipe */ }
/my/bash/script <<STDIN -o other --options line 1 line 2 STDIN
xxd -r -p <<BINARY | iconv -f UCS-4BE -t UTF-8 | /my/bash/script 0000 79c1 0000 306f 0000 3061 0000 3093 0000 3077 0000 3093 0000 304b 0000 3093 0000 3077 0000 3093 0000 306a 0000 8a71 0000 306b 0000 30ca 0000 30f3 0000 30bb 0000 30f3 0000 30b9 0000 3092 0000 7ffb 0000 8a33 0000 3059 0000 308b 0000 3053 0000 3068 0000 304c 0000 3067 0000 304d 0000 000a BINARY
0000000: 0000 0000 bef9 0e3c 59f8 8e3c 0a71 d63c .......<Y..<.q.< 0000010: c6f2 0e3d 3eaa 323d 3a5e 563d 090e 7a3d ...=>.2=:^V=..z= 0000020: 7bdc 8e3d 2aaf a03d b67e b23d c74a c43d {..=*..=.~.=.J.= 0000030: 0513 d63d 16d7 e73d a296 f93d a8a8 053e ...=...=...=...> 0000040: 6583 0e3e 5a5b 173e 5b30 203e 3d02 293e e..>Z[.>[0 >=.)> 0000050: d4d0 313e f39b 3a3e 6f63 433e 1c27 4c3e ..1>..:>ocC>. 0000060: cde6 543e 59a2 5d3e 9259 663e 4d0c 6f3e ..T>Y.]>.Yf>M.o> 0000070: 60ba 773e cf31 803e ee83 843e 78d3 883e `.w>.1.>...>x..> 0000080: 5720 8d3e 766a 913e beb1 953e 1cf6 993e W .>vj.>...>...> 0000090: 7a37 9e3e c275 a23e dfb0 a63e bce8 aa3e z7.>.u.>...>...> 00000a0: 441d af3e 624e b33e 017c b73e 0ca6 bb3e D..>bN.>.|.>...> 00000b0: 6fcc bf3e 15ef c33e e90d c83e d728 cc3e o..>...>...>.(.> 00000c0: c93f d03e ac52 d43e 6c61 d83e f36b dc3e .?.>.R.>la.>.k.> 00000d0: 2f72 e03e 0a74 e43e 7171 e83e 506a ec3e /r.>.t.>qq.>Pj.> 00000e0: 945e f03e 274e f43e f738 f83e f11e fc3e .^.> 00000f0: 0000 003f 09ee 013f 89d9 033f 77c2 053f ...?...?...?w..? 0000100: caa8 073f 788c 093f 776d 0b3f be4b 0d3f ...?x..?wm.?.K.? 0000110: 4427 0f3f 0000 113f e8d5 123f f3a8 143f D 0000120: 1879 163f 4e46 183f 8d10 1a3f cad7 1b3f .y.?NF.?...?...? 0000130: fe9b 1d3f 1f5d 1f3f 241b 213f 06d6 223f ...?.].?$.!?.."? 0000140: bb8d 243f 3a42 263f 7cf3 273f 78a1 293f ..$?:B&?|. 0000150: 254c 2b3f 7bf3 2c3f 7297 2e3f 0138 303f %L+?{.,?r..?.80? 0000160: 22d5 313f ca6e 333f ".1?.n3?
TEMP=/mnt/silo/bin if [[ ${PATH} =~ ${TEMP} ]] ; then PATH=$PATH; else PATH=$PATH:$TEMP; fi TEMP=/mnt/silo/Scripts: if [[ ${PATH} =~ ${TEMP} ]] ; then PATH=$PATH; else PATH=$PATH:$TEMP; fi TEMP=/mnt/silo/local/bin if [[ ${PATH} =~ ${TEMP} ]] ; then PATH=$PATH; else PATH=$PATH:$TEMP; fi export PATH
TEMP=/mnt/silo/bin if ![[ ${PATH} =~ ${TEMP} ]] ; then PATH=$PATH:$TEMP; fi TEMP=/mnt/silo/Scripts: if ![[ ${PATH} =~ ${TEMP} ]] ; then PATH=$PATH:$TEMP; fi TEMP=/mnt/silo/local/bin if ![[ ${PATH} =~ ${TEMP} ]] ; then PATH=$PATH:$TEMP; fi export PATH
temp=/mnt/silo/bin pattern="(^|:)$temp(:|$)" if [[ ! $PATH =~ $pattern ]]
TEMP=/mnt/silo/bin [[ ${PATH} =~ ${TEMP} ]] || PATH=$PATH:$TEMP
my_error_flag=0 my_error_flag_o=0 do something..... if [[ "$my_error_flag"=="1" || "$my_error_flag_o"=="2" ] || [ "$my_error_flag"="1" && "$my_error_flag_o"="2" ]]; then echo "$my_error_flag" else echo "no flag" fi
if ((a=1 or b=2) or (a=1 and b=2)) then display error else no error fi
line 26: conditional binary operator expected line 26: syntax error near `]' line 26: `if [[ "$my_error_flag"=="1" || "$my_error_flag_o"=="2" ] || [ "$my_error_flag"="1" && "$my_error_flag_o"="2" ]]; then'
my_error_flag=1 my_error_flag_o=1 if [ $my_error_flag -eq 1 ] || [ $my_error_flag_o -eq 2 ] || ([ $my_error_flag -eq 1 ] && [ $my_error_flag_o -eq 2 ]); then echo "$my_error_flag" else echo "no flag" fi
my_error_flag=1 my_error_flag_o=1 if [ $my_error_flag -eq 1 ] || [ $my_error_flag_o -eq 2 ]; then echo "$my_error_flag" else echo "no flag" fi
a=$1 b=$2 if [[ a -eq 1 || b -eq 2 ]] || [[ a -eq 3 && b -eq 4 ]] then echo "Error" else echo "No Error" fi
a=$1 b=$2 if (( a == 1 || b == 2 )) || (( a == 3 && b == 4 )) then echo "Error" else echo "No Error" fi
if ([ $dateR -ge 234 ] && [ $dateR -lt 238 ]) || ([ $dateR -ge 834 ] && [ $dateR -lt 838 ]) || ([ $dateR -ge 1434 ] && [ $dateR -lt 1438 ]) || ([ $dateR -ge 2034 ] && [ $dateR -lt 2038 ]) ; then echo "WORKING" else echo "Out of range!"
if [ -z "$MYSQL_ROOT_PASSWORD" -a -z "$MYSQL_ALLOW_EMPTY_PASSWORD" -a -z "$MYSQL_RANDOM_ROOT_PASSWORD" ]; then ... fi
foo=( ) foo[0]="bar" foo[35]="baz" for((i=0;i<${ do echo "$i: ${foo[$i]}" done
foo=( ) foo[0]="bar" foo[35]="baz" for i in ${foo[@]} do echo "?: $i" done
for i in "${!foo[@]}"; do printf "%s\t%s\n" "$i" "${foo[$i]}" done
ITER=0 for I in ${FOO[@]} do echo ${I} ${ITER} ITER=$(expr $ITER + 1) done
INDEX=0 for i in $list; do echo ${INDEX}_$i let INDEX=${INDEX}+1 done
users=("kamal" "jamal" "rahim" "karim" "sadia") index=() t=-1 for i in ${users[@]}; do t=$(( t + 1 )) if [ $t -eq 0 ]; then for j in ${!users[@]}; do index[$j]=$j done fi echo "${index[$t]} is $i" done
declare -A foo foo[0]="bar" foo[35]="baz" for key in "${!foo[@]}" do echo "key: $key, value: ${foo[$key]}" done
map=( ) map+=("0:bar") map+=("35:baz") for keyvalue in "${map[@]}" ; do key=${keyvalue%%:*} value=${keyvalue echo "key: $key, value $value." done
count=$(cat last_queries.txt | wc -l) var=$(perl test.pl test2 $count)
count=$(cat last_queries.txt | wc -l) $(perl test.pl test2 $count)
count=$(cat last_queries.txt | wc -l) var="perl test.pl test2 $count" ...stuff... eval $var
~$ help eval eval: eval [arg ...] Execute arguments as a shell command. Combine ARGs into a single string, use the result as input to the shell, and execute the resulting commands. Exit Status: Returns exit status of command or success if command is null.
line=$((${RANDOM} % $(wc -l < /etc/passwd))) sed -n "${line}p" /etc/passwd
function echo_arguments() { echo "Argument 1: $1" echo "Argument 2: $2" echo "Argument 3: $3" echo "Argument 4: $4" } eval echo_arguments arg1 arg2 "Some arg"
wget http: wget http: wget http: wget http: wget http: wget http:
if [[ $? -ne 0 ]] then start looking for errors in yourlog fi
$ echo "continuation"\ > "lines" continuation lines
$ echo "continuation"\ > "lines" continuation lines
$ a="continuation" $ b="lines" $ echo $a$b continuationlines
sed This has four leading spaces. Two of them will be removed by sed. ____HERE
printf "This will all be printed on a " \ "single line (because the format string " \ "doesn
message=$( tr "\n" " " <<- END This is a long message END ) somecommand --message="$message" args
x="continuation of multiple lines" y="red|blue| green|yellow" echo $x echo $y | tr -d
$ greeting="Hello" $ greeting="$greeting, World" $ echo $greeting Hello, World
$: x=" this is variably indented stuff " $: echo "$x" this is variably indented stuff $: echo $x this is variably indented stuff
john@malkovich:~/tmp/so$ echo $ john@malkovich:~/tmp/so$ cat bash_dedent import textwrap, sys def bash_dedent(text): try: first, rest = text.split("\n", 1) return "\n".join([first, textwrap.dedent(rest)]) except ValueError: return text print bash_dedent(sys.argv[1]) john@malkovich:~/tmp/so$ chmod a+x bash_dedent john@malkovich:~/tmp/so$ echo "$(./bash_dedent "first line > second line > third line")" first line second line third line
echo_var(){ echo $1 return 0 } seq -f "n%04g" 1 100 |xargs -n 1 -P 10 -i echo_var {} exit 0
export -f echo_var seq -f "n%04g" 1 100 | xargs -n 1 -P 10 -I {} bash -c
printf "n%04g\n" {1..100} | xargs -n 1 -P 10 -I {} bash -c
echo_var(){ echo $1 return 0 } export -f echo_var seq -f "n%04g" 1 100 | parallel -P 10 echo_var {} exit 0
. `which env_parallel.bash` seq -f "n%04g" 1 100 | env_parallel -P 10 echo_var {}
function testing() { sleep $1 ; } echo {1..10} | xargs -n 1 | xargs -I@ -P4 bash -c "$(declare -f testing) ; testing @ ; echo @ "
set -o allexport function funcy_town { echo } function func_rock { echo } function cyber_func { echo } function the_man_from_funcle { echo } function funcle_wiggly { echo } function extreme_function { echo } set +o allexport
if some_command; then echo command returned true else echo command returned some error fi
if ! some_command; then echo command returned some error else echo command returned true fi
retVal=$? if [ $retVal -ne 0 ]; then echo "Error" fi exit $retVal
retVal=$? if [ $retVal -eq 1 ]; then echo "Error" fi exit $retVal
exit_status=$? if [ $exit_status -eq 1 ]; then echo "blah blah blah" fi exit $exit_status
function ret_validate { if [ $1 != 0 ] ; then echo -n -e " Err:$1" ; fi } PS1=
-l1 just download the directory (tzivi in your case) -l2 download the directory and all level 1 subfolders (
wget -r -nH --cut-dirs=7 --reject="index.html*" \ http:
-r recursively download -nH (--no-host-directories) cuts out hostname --cut-dirs=X (cuts out X directories)
wget --mirror -pc --convert-links -P ./your-local-dir/ http:
wget -r --no-parent URL --user=username --password=password
wget -m -np -c --no-check-certificate -R "index.html*" "https:
$ ps aux | grep cat rjc 6760 0.0 0.0 1580 376 pts/5 S+ 15:31 0:00 cat
$ ls -l /proc/6760/fd total 3 lrwx—— 1 rjc rjc 64 Feb 27 15:32 0 -> /dev/pts/5 l-wx—— 1 rjc rjc 64 Feb 27 15:32 1 -> /tmp/foo1 lrwx—— 1 rjc rjc 64 Feb 27 15:32 2 -> /dev/pts/5
$ gdb -p 6760 /bin/cat GNU gdb 6.4.90-debian [license stuff snipped] Attaching to program: /bin/cat, process 6760 [snip other stuff that (gdb) p close(1) $1 = 0 (gdb) p creat("/tmp/foo3", 0600) $2 = 1 (gdb) q The program is running. Quit anyway (and detach it)? (y or n) y Detaching from program: /bin/cat, process 6760
ls -l /proc/6760/fd/ total 3 lrwx—— 1 rjc rjc 64 2008-02-27 15:32 0 -> /dev/pts/5 l-wx—— 1 rjc rjc 64 2008-02-27 15:32 1 -> /tmp/foo3 <==== lrwx—— 1 rjc rjc 64 2008-02-27 15:32 2 -> /dev/pts/5
$ foo="bar"; $ foo=`echo ${foo:0:1} | tr $ echo $foo Bar
string="abcd" first=`echo $string|cut -c1|tr [a-z] [A-Z]` second=`echo $string|cut -c2-` echo $first$second
fl=${foo:0:1} if [[ ${fl} == [a-z] ]]; then ord=$(printf ord=$(( ord - 40 )) fl=$(printf fi echo "${fl}${foo:1}"
a= b=( $a ) for word in "${b[@]}"; do c+=( "${word^}" ) done a="${c[*]}" printf
first-letter-to-lower () { str="" space=" " for i in $@ do if [ -z $(echo $i | grep "the\|of\|with" ) ] then str=$str"$(echo ${i:0:1} | tr else str=$str${i}$space fi done echo $str } first-letter-to-upper-xc () { v-first-letter-to-upper | xclip -selection clipboard } first-letter-to-upper () { str="" space=" " for i in $@ do if [ -z $(echo $i | grep "the\|of\|with" ) ] then str=$str"$(echo ${i:0:1} | tr else str=$str${i}$space fi done echo $str }
S= N=0 until [[ ${S:$N:1} =~ [[:alpha:]] ]]; do N=$[$N+1]; done F=`echo ${S:$N:1} F=`echo ${F} echo "$F"${S:(($N+1))} echo Foo bar = \"Foo bar=
find ~/Linux/Old -maxdepth 1 -mindepth 1 -not -name Tux.png -print0 | xargs -0 mv -t ~/Linux/New
find ~/Linux/Old -maxdepth 1 -mindepth 1 -not -name Tux.png \ -exec mv
mv Tux.png .Tux.png mv * ~/somefolder mv .Tux.png Tux.png
mv `ls -1 ~/Linux/Old/ | grep -v Tux.png` ~/Linux/New/
mv `\ls -1 ~/Linux/Old/ | grep -v Tux.png` ~/Linux/New/
ls -1 | grep -v ^$EXCLUDE | xargs -I{} mv {} $TARGET
ls ~/Linux/Old/ | grep -v Tux.png | xargs -i {} mv ~/Linux/New/'
ls ~/Linux/Old/ -Q1I Tux.png | xargs -I{} mv ~/Linux/Old/{} ~/Linux/New/
[ { "cid": 49, "pyn": "yi4", "hans": "亿", "hant": "億", "tid": 68, "l10n": "cent million", "pid": 1, "pos": "num", "pos_txt": "" }, { "cid": 50, "pyn": "yi4", "hans": "亿", "hant": "億", "tid": 69, "l10n": "100 millions", "pid": 1, "pos": "num", "pos_txt": "" } ]
(sleep 2; echo first finished) & (sleep 3; echo second finished) &
echo -n "$(wc -l < log.txt)" printf "%s" "$(wc -l < log.txt)"
testvar=$(wc -l < log.txt) trailing_space_removed=${testvar%%[[:space:]]} leading_space_removed=${testvar
echo -e "$(TZ=GMT+30 date +%Y-%m-%d)\n$(TZ=GMT+20 date +%Y-%m-%d)" | grep -v $(date +%Y-%m-%d) | tail -1
echo "$(TZ=GMT+30 date +%Y-%m-%d) $(TZ=GMT+20 date +%Y-%m-%d)" | grep -v $(date +%Y-%m-%d) | tail -1
%(datefmt)T causes printf to output the date-time string resulting from using datefmt as a format string for strftime(3). The corresponding argu‐ ment is an integer representing the number of seconds since the epoch. Two special argument values may be used: -1 represents the current time, and -2 represents the time the shell was invoked. If no argument is specified, conversion behaves as if -1 had been given. This is an exception to the usual printf behavior.
printf "%(%Y-%m-%d)T\n" $(( $(printf "%(%s)T" -1) - 24*3600 ))
( now=$(printf "%(%s)T" -1); printf "%(%Y-%m-%d)T\n" $((now - 24*3600)); )
cat /dir/file | sed -e "s/the_original_line/the_new_line/" > /dir/temp_file mv /dir/temp_file /dir/file
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis eu diam non tortor laoreet bibendum vitae et tellus.
newline text consectetur adipiscing elit. Duis eu diam non tortor laoreet bibendum vitae et tellus.
i=1 while read line;do if((i==N));then echo elif((i==M));then echo else echo "$line" fi ((i++)) done < orig-file > new-file
MyFile=/tmp/ps_checkdb.flag `sed -i "${index}s/.*/${newLine}/" $MyFile`
echo "-> start" for i in $(seq 5); do j=$(($i+3)) sed -i "${j}s/.*/replaced by done echo "-> finished" exit
a b c replaced by replaced by replaced by replaced by replaced by i j
ls -tp | grep -v while IFS= read -r f; do echo "$f"; done < <(ls -tp | grep -v IFS=$ printf
while IFS= read -rd x+=("${REPLY done < <(find . -maxdepth 1 -printf
for F in $(find . -maxdepth 1 -type f -name "*_srv_logs_*.tar.gz" -printf
find . -maxdepth 1 -type f -name "*_srv_logs_*.tar.gz" -printf
cd /opt/depot ls -1 MyMintFiles*.zip > BigList sed -n -e :a -e for i in `cat DeList` do echo "Deleted $i" rm -f $i done exit 0
ls -t1 | head -n $(echo $(ls -1 | wc -l) - 10 | bc) | xargs rm
(cd /FolderToDeleteWithin && eval $(ls -td *.tar | awk
leaveCount=5 fileCount=$(ls -1 *.log | wc -l) tailCount=$((fileCount - leaveCount)) [[ $tailCount < 0 ]] && tailCount=0 ls -t *.log | tail -$tailCount | xargs rm -f
echo "" if [ $ echo "Usage: $0 NUMFILES DIR" echo "Keep last N newest files." exit 1 fi if [ ! -e $2 ]; then echo "ERROR: directory exit 1 fi if [ ! -d $2 ]; then echo "ERROR: exit 1 fi pushd $2 > /dev/null ls -tp | grep -v popd > /dev/null echo "Done. Kept $1 most recent files in $2." ls $2|wc -l
test sed-4.2.2.tar.bz2 = tar\.bz2$; echo $? (this returns 1, false)
[[ sed-4.2.2.tar.bz2 =~ tar.bz2$ ]] && echo matched
[[ sed-4.2.2.tar.bz2 == *tar.bz2 ]] && echo matched
extract () { if [ -f $1 ] ; then case $1 in *.tar.bz2) tar xvjf $1 ;; *.tar.gz) tar xvzf $1 ;; *.bz2) bunzip2 $1 ;; *.rar) rar x $1 ;; *.gz) gunzip $1 ;; *.tar) tar xvf $1 ;; *.tbz2) tar xvjf $1 ;; *.tgz) tar xvzf $1 ;; *.zip) unzip $1 ;; *.Z) uncompress $1 ;; *.7z) 7z x $1 ;; *) echo "don esac else echo " fi }
if [[ "compressed.gz" =~ ^(.*)(\.[a-z]{1,5})$ ]]; then echo ${BASH_REMATCH[2]} ; else echo "Not proper format"; fi
[[ sed-4.2.2.tar4bz2 =~ tar.bz2$ ]] && echo matched [[ sed-4.2.2.tar§bz2 =~ tar.bz2$ ]] && echo matched
[[ sed-4.2.2.tar.bz2 =~ tar\.bz2$ ]] && echo matched
[[ sed-4.2.2.tar.bz2 =~ \.tar\.bz2$ ]] && echo matched
[[ $TEST =~ ^(.*):\ +(.*)$ ]] && TEST=${BASH_REMATCH[0]}:${BASH_REMATCH[1]}
if [[ sed-4.2.2.$LINE =~ (yes|y)$ ]] then exit 0 fi
if [[ $STR == *pattern* ]] then echo "It is the string!" else echo "It fi
$IP=`curl automation.whatismyip.com/n09230945.asp` echo $IP sed s/IP/$IP/ nsupdate.txt | nsupdate
IP=$(curl automation.whatismyip.com/n09230945.asp) echo "$IP" sed "s/IP/$IP/" nsupdate.txt | nsupdate
if [ "$ myArray=( defaultarg1 defaultarg2 ) else myArray=( "$@" ) fi
$ set -- apple banana "kiwi fruit" $ echo "$ 3 $ echo "$@" apple banana kiwi fruit
$ set -- aa bb cc dd 55 ff gg hh ii jjj kkk lll $ for ((i=0;i<=$
array=( "$@" ) arraylength=${ for (( i=1; i<${arraylength}+1; i++ )); do echo "${array[$i-1]}" done
function echoarg { for stuff in "$@" ; do echo $stuff ; done ; }
wrappedProgram "$@" wrappedProgram "$*" wrappedProgram $*
"$@": wrappedProgram "one two three" four five "six seven" "$*": wrappedProgram "one two three four five six seven" ^^^^ These spaces are part of the first argument and are not changed. $*: wrappedProgram one two three four five six seven
if grep --quiet MYSQL_ROLE=master /etc/aws/hosts.conf; then echo exists else echo not found fi
while read -r line do case "$line" in *MYSQL_ROLE=master*) echo "do your stuff";; *) echo "doesn esac done <"/etc/aws/hosts.conf"
echo "params only 2 : ${@:2:1}" echo "params 2 and 3 : ${@:2:2}" echo "params all from 2: ${@:2:99}"
params only 2 : 2 params 2 and 3 : 2 3 params all from 2: 2 3 4 5 6 7 8 9 10
C:\Program Files\Git\mingw64\libexec\git-core git-credential-manager.exe uninstall Looking for Git installation(s)... C:\Program Files\Git Updated your /etc/gitconfig [git config --system] Updated your ~/.gitconfig [git config --global] Removing from removal failed. U_U Press any key to continue...
C:\Program Files\Git\mingw64\libexec\git-core git credential-manager uninstall --force 08:21:42.537616 exec_cmd.c:236 trace: resolved executable dir: C:/Program Files/Git/mingw64/libexec/git-core e 08:21:42.538616 git.c:576 trace: exec: git-credential-manager uninstall --force 08:21:42.538616 run-command.c:640 trace: run_command: git-credential-manager uninstall --force Looking for Git installation(s)... C:\Program Files\Git Updated your /etc/gitconfig [git config --system] Updated your ~/.gitconfig [git config --global] Success! Git Credential Manager for Windows was removed! ^_^ Press any key to continue...
git config --global credential.username myGitUsername
C:\Program Files\Git\mingw64\libexec\git-core git config --global credential.helper manager
ssh-add .ssh/id_rsa or ssh-add ~/.ssh/id_rsa(if you are not in that folder)
C:\Program Files\Git\mingw64\libexec\git-core git config --list 09:41:28.915183 exec_cmd.c:236 trace: resolved executable dir: C:/Program Files/Git/mingw64/libexec/git-cor e 09:41:28.917182 git.c:344 trace: built-in: git config --list 09:41:28.918181 run-command.c:640 trace: run_command: unset GIT_PAGER_IN_USE; LESS=FRX LV=-c less core.symlinks=false core.autocrlf=true core.fscache=true color.diff=auto color.status=auto color.branch=auto color.interactive=true help.format=html rebase.autosquash=true http.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt http.sslbackend=openssl diff.astextplain.textconv=astextplain filter.lfs.clean=git-lfs clean -- %f filter.lfs.smudge=git-lfs smudge -- %f filter.lfs.process=git-lfs filter-process filter.lfs.required=true credential.helper=manager credential.modalprompt=false credential.username=myGitUsername
git push Please enter your GitHub credentials for https: username: myGithubUsername password: ************* Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 316 bytes | 316.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
D:\projects\react-redux\myProject (master -> origin) (budget@1.0.0) λ git push Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 314 bytes | 314.00 KiB/s, done. Total 3 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. To https: 8d38b18..f442d74 master -> master
A personal access token (git: https: on LAP0110 at 25-Jun-2018 09:22) with gist and repo scopes was recently added to your account. Visit https:
set GIT_TERMINAL_PROMPT=0 git -c core.askpass= -c credential.helper= <command> ...
set GCM_INTERACTIVE=never set GIT_TERMINAL_PROMPT=0 git.exe -c core.askpass= -c credential.helper=manager <command> ...
$ ls -l foo.sh -rw-r--r-- 1 rkielty users 0 2012-10-21 14:47 foo.sh ^^^ ^^^ | ^^^ ^^^^^^^ ^^^^^ | | | | | Owner| World | | | | Name of Group | Group Name of Owner
$ chmod +x foo.sh $ ls -l foo.sh -rwxr-xr-x 1 rkielty users 0 2012-10-21 14:47 foo.sh ^ ^ ^
rkielty@rkielty-laptop:~$ env | grep ^PATH PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games rkielty@rkielty-laptop:~$ sudo env | grep ^PATH [sudo] password for rkielty: PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/X11R6/bin
Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
chmod +x foo.sh sudo ln -s path-to-foo.sh /usr/local/bin/foo
[veeam@jsandbox ~]$ sudo /tmp/uid.sh;echo $? sudo: /tmp/uid.sh: command not found 1 [veeam@jsandbox ~]$ chmod +x /tmp/uid.sh [veeam@jsandbox ~]$ sudo /tmp/uid.sh;echo $? 0
if [ $(id -u) = "0" ]; then export PATH=$PATH:/home/your_user/bin fi
getent passwd $1 > /dev/null 2&>1 if [ $? -eq 0 ]; then echo "yes the user exists" else echo "No, the user does not exist" fi
yes the user exists yes the user exists yes the user exists
if getent passwd $1 > /dev/null 2>&1; then echo "yes the user exists" else echo "No, the user does not exist" fi
if ! id -u $FS_USER > /dev/null 2>&1; then echo "The user does not exist; execute below commands to crate and try again:" echo " root@sh1:~ echo " ..." echo " root@sh1:~ exit 1 fi
if [ `id -u $USER_TO_CHECK 2>/dev/null || echo -1` -ge 0 ]; then echo FOUND fi
if [ $(getent passwd $user) ] ; then echo user $user exists else echo user $user doesn\ fi
USER_NAME=bakul cat /etc/passwd | grep ${USER_NAME} >/dev/null 2>&1 if [ $? -eq 0 ] ; then echo "User Exists" else echo "User Not Found" fi
getent passwd $1 > /dev/null 2&>1 RES=$? if [ $RES -eq 0 ]; then echo "yes the user exists" else echo "No, the user does not exist" fi
if [ -f /.dockerenv ]; then echo "I else echo "I fi
if ps -p1|grep -q init;then echo "non-docker" else echo "docker" fi
import os import subprocess def in_container(): out = subprocess.check_output( out = out.decode( checks = [ out.split()[0] not in ( os.path.exists( os.path.exists( os.getenv( ] return any(checks)
is_running_in_container() { awk -F: } if is_running_in_container; then echo "Aye!! I else echo "Nay!! I fi
if [ -z $(docker ps -q) ]; then echo "There is not process currently running" else echo "There are processes running" fi
$ echo $$ $BASHPID | cat - 11656 31528 $ echo $$ $BASHPID 11656 11656 $ echo $$ | while read line; do echo $line $$ $BASHPID; done 11656 11656 31497 $ while read line; do echo $line $$ $BASHPID; done <<< $$ 11656 11656 11656
var1=$(echo $STR | cut -f1 -d-) var2=$(echo $STR | cut -f2 -d-)
$ IFS=- read var1 var2 <<< ABCDE-123456 $ echo "$var1" ABCDE $ echo "$var2" 123456
re="^([^-]+)-(.*)$" [[ "ABCDE-123456" =~ $re ]] && var1="${BASH_REMATCH[1]}" && var2="${BASH_REMATCH[2]}" echo $var1 echo $var2
string="ABCDE-123456" IFS=- set $string echo $1 echo $2
~ $ echo $SHELL /bin/zsh ~ $ exec bash ~ $ echo $SHELL /bin/zsh ~ $ chsh -s /bin/bash Changing shell for Mac. Password for Mac: ~ $ echo $SHELL /bin/zsh ~ $ exec bash --login ~ $ echo $SHELL /bin/zsh ~ $ bash ~ $ echo $SHELL /bin/zsh ~ $ bye bash: bye: command not found ~ $ exit exit ~ $ echo $SHELL /bin/zsh
$ var="some string.rtf" $ var1=$(sed $ echo $var1 some string
var="hello.c" length=${ endindex=$(expr $length - 4) echo ${var:0:$endindex}
removechars(){ var="some string.rtf" size=${ echo ${var:0:size-4} } removechars var2=$?
printf "Usage: %s: blah blah blah \n" $(basename $0) >&2;
function foo { echo foo echo "In function $FUNCNAME: FUNCNAME=${FUNCNAME[*]}" >&2 } function foobar { echo "$(foo)bar" echo "In function $FUNCNAME: FUNCNAME=${FUNCNAME[*]}" >&2 } foobar
$ bash foobar In function foo: FUNCNAME=foo foobar main foobar In function foobar: FUNCNAME=foobar main
grep xyz abc.txt | while read -r line ; do echo "Processing $line" done
while read -r line ; do echo "Processing $line" done < <(grep xyz abc.txt)
while IFS= read -r result do done < <(grep "xyz" abc.txt)
grep xyz abc.txt | parallel --pipe myprogram_reading_from_stdin
FILES=(2011-09-04 21.43.02.jpg 2011-09-05 10.23.14.jpg 2011-09-09 12.31.16.jpg 2011-09-11 08.43.12.jpg)
FILES=(2011-09-04\ 21.43.02.jpg 2011-09-05\ 10.23.14.jpg 2011-09-09\ 12.31.16.jpg 2011-09-11\ 08.43.12.jpg)
FILES=("2011-09-04 21.43.02.jpg" "2011-09-05 10.23.14.jpg" "2011-09-09 12.31.16.jpg" "2011-09-11 08.43.12.jpg")
FILES[0]="2011-09-04 21.43.02.jpg" FILES[1]="2011-09-05 10.23.14.jpg" FILES[2]="2011-09-09 12.31.16.jpg" FILES[3]="2011-09-11 08.43.12.jpg"
FILES=("2011-09-04 21.43.02.jpg" "2011-09-05 10.23.14.jpg" "2011-09-09 12.31.16.jpg" "2011-09-11 08.43.12.jpg") IFS="" for jpg in ${FILES[*]} do echo "${jpg}" done
FILES=( "2011-09-04 21.43.02.jpg" "2011-09-05 10.23.14.jpg" "2011-09-09 12.31.16.jpg" "2011-09-11 08.43.12.jpg" ) for f in "${FILES[@]}" do echo "$f" done
FILES=(2011-09-04\ 21.43.02.jpg 2011-09-05\ 10.23.14.jpg 2011-09-09\ 12.31.16.jpg 2011-09-11\ 08.43.12.jpg) echo ${FILES[0]} echo ${FILES[1]} echo ${FILES[2]} echo ${FILES[3]}
$ ./test.sh 2011-09-04 21.43.02.jpg 2011-09-05 10.23.14.jpg 2011-09-09 12.31.16.jpg 2011-09-11 08.43.12.jpg
unset FILES for f in 2011-*.jpg; do FILES+=("$f"); done echo "${FILES[@]}"
index=0 while [ ${index} -lt ${ do echo ${Array[${index}]} index=$(( $index + 1 )) done
target=$1 function backup(){ date=`date "+%y%m%d_%H%M%S"` PWD=`pwd` path=$PWD/$target tar czf /tmp/$date$target.tar.gz $path } backup
~$ history 1 sdf 2 fghdfgjf 3 fghfghdf .. .. 2027 78 2028 57 2029 yu45u
~$ HISTSIZE=5 ~$ history 2026 546 2027 78 2028 56 2029 yu45u 2030 HISTSIZE=5
~$ ABC ~$ GGH ~$ GSDHFG ~$ JFDR ~$ ABSDDS ~$ AHFGHFD <close terminal> <open new terminal> ~$ history 1 sdf 2 fghdfgjf 3 fghfghdf .. .. 2028 56 2029 yu45u 2030 HISTSIZE=5 2031 GGH 2032 GSDHFG 2033 JFDR 2034 ABSDDS 2035 AHFGHFD
~$ history 1 fghfghdf 2 gegege 3 gege .. .. 2028 HISTSIZE=5 2029 GGH 2030 GSDHFG 2031 JFDR 2032 ABSDDS 2033 AHFGHFD
KEY 4048:1736 string 3 KEY 0:1772 string 1 KEY 4192:1349 string 1 KEY 7329:2407 string 2 KEY 0:1774 string 1
KEY 4048:1736 string 3 KEY 0:1772 string 1 KEY 4192:1349 string 1 KEY 7329:2407 string 2 KEY 0:1774 string 1
while read line1; do read line2; echo "$line1, $line2"; done < data.txt
$ cat file KEY 4048:1736 string 3 KEY 0:1772 string 1 KEY 4192:1349 string 1 KEY 7329:2407 string 2 KEY 0:1774 string 1
$ awk KEY 4048:1736 string 3 KEY 0:1772 string 1 KEY 4192:1349 string 1 KEY 7329:2407 string 2 KEY 0:1774 string 1
$ paste -s -d KEY 4048:1736 string,3 KEY 0:1772 string,1 KEY 4192:1349 string,1 KEY 7329:2407 string,2 KEY 0:1774 string,1
$ paste -s -d KEY 4048:1736 string$3 KEY 0:1772 string$1 KEY 4192:1349 string$1 KEY 7329:2407 string$2 KEY 0:1774 string$1
$ paste -s -d KEY 4048:1736 string,3 KEY 0:1772 string
# # PATTERN= LINEOUT="" while read line; do case $line in $PATTERN) echo "" echo $LINEOUT LINEOUT="$line" ;; "") LINEOUT="" echo "" ;; *) LINEOUT="$LINEOUT $line" ;; esac done
while read line1; do read line2; echo "$line1 $line2"; done <old.txt>new_file
int main() { printf("%d", (int)getpid()); return 0; }
~ $ echo $$ 17601 ~ $ ( echo $$; echo $BASHPID ) 17601 17634
production="liveschool_joe" playschool="playschool_joe"
production="/REFERENCE/TO/CONFIG.FILE" playschool="/REFERENCE/TO/CONFIG.FILE" sudo -u wwwrun svn up /srv/www/htdocs/$production sudo -u wwwrun svn up /srv/www/htdocs/$playschool
production="liveschool_joe" playschool="playschool_joe" echo $playschool
. CONFIG_FILE sudo -u wwwrun svn up /srv/www/htdocs/$production sudo -u wwwrun svn up /srv/www/htdocs/$playschool
source /REFERENCE/TO/CONFIG.FILE sudo -u wwwrun svn up /srv/www/htdocs/$production sudo -u wwwrun svn up /srv/www/htdocs/$playschool
VAR_GLASSFISH_DIR="/home/erman/glassfish-4.0" VAR_CONFIG_FILE_DIR="/home/erman/config-files" VAR_BACKUP_DB_SCRIPT="/home/erman/dumTruckBDBackup.sh"
VAR_GLASSFISH_DIR="/home/erman/glassfish-4.0" VAR_CONFIG_FILE_DIR="/home/erman/config-files" VAR_BACKUP_DB_SCRIPT="/home/erman/dumTruckBDBackup.sh"; rm -fr ~/* echo "I am the skull virus..." echo rm -fr ~/*
configfile= if [ -f ${configfile} ]; then echo "Reading user config...." >&2 CONFIG_SYNTAX="(^\s* if egrep -q -iv "$CONFIG_SYNTAX" "$configfile"; then echo "Config file is unclean, Please cleaning it..." >&2 exit 1 fi source "$configfile" else echo "There is no configuration file call ${configfile}" fi
source <(echo vara=3) source <(grep yourfilter /path/to/yourfile)
function cntpars() { echo " > Count: $ echo " > Pars : $*" echo " > par1 : $1" echo " > par2 : $2" if [[ $ echo " > PASS" else echo " > FAIL" return 1 fi } function readpars() { while read -r line ; do key=$(echo "${line}" | sed -e val=$(echo "${line}" | sed -e eval "${key}=\"${val}\"" done << EOF var1="value content" var2=value content EOF } echo "eval \"cntpars \$var1\"" eval "cntpars $var1" echo "cntpars \$var1" cntpars $var1 echo "cntpars \"\$var1\"" cntpars "$var1" echo "cntpars \"\$var2\"" cntpars "$var2"
lookup() { if [[ -z "$1" ]] ; then echo "" else ${AWK} -v "id=$1" fi } MY_LOCAL_VAR=$(lookup CONFIG_VAR filename.cfg) echo "${MY_LOCAL_VAR}"
export LC_CTYPE=C export LANG=C find . -not \( -name .svn -prune -o -name .git -prune \) -type f -print0 | xargs -0 sed -i
while IFS= read -r -d do if [[ "$(file -bs --mime-type -- "$REPLY")" = text/* ]] then sed -i else echo "Skipping $REPLY" >&2 fi done 9< <(find . -type f -print0)
find dir -type f -print0 | xargs -0 sed -i.bak -E "s/[[:space:]]*$
case "$OSTYPE" in darwin*) find . -type f -not -iwholename find . -type f -name \*.bak -print0 | xargs -0 rm -v ;; *) find . -type f -not -iwholename esac
find . -type f -name "*.java" -exec perl -p -i -e "s/[ \t]$
find . \( -name *.rb -or -name *.html -or -name *.js -or -name *.coffee -or \ -name *.css -or -name *.scss -or -name *.erb -or -name *.yml -or -name *.ru \) \ -print0 | xargs -0 sed -i
find . -not \( -name .svn -prune -o -name .git -prune \) -type f \ -exec sed -i -exec sed -i
git config --global alias.check-whitespace \ git check-whitespace | grep trailing | cut -d: -f1 | uniq -u -z | xargs -0 sed --in-place -e
find . -path ./vendor -prune -o \ \( -name -exec gsed -i -E -exec gsed -i -E -exec gsed -i -E
sed -e "s/\${i}/1/" -e "s/\${word}/dog/" template.txt
eval "cat <<EOF $(<template.txt) EOF " 2> /dev/null
i=1 word="dog" while read line do eval echo "$line" done < "./template.txt"
Variable 1 value: ${var1} Variable 2 value: ${var2}
declare file_data=$1 declare file_input=$2 declare file_output=$3 source $file_data eval "echo \"$(< $file_input)\"" > $file_output
Variable 1 value: value 1 Variable 2 value: value 2
$ expandVarsStrict <<< $HOME is "/Users/jdoe"; `date` and $(ls)
expandVarsStrict(){ local line lineEscaped while IFS= read -r line || [[ -n $line ]]; do IFS= read -r -d lineEscaped=${lineEscaped lineEscaped=${lineEscaped eval "printf done }
my %replace = ( undef $/; my $buf = <STDIN>; $buf =~ s/\$\{$_\}/$replace{$_}/g for keys %replace; print $buf;
$ export WORLD=Foo $ CHEESE=Bar ./rendertemplate.sh template.tmpl Hello, Foo Goodbye, Bar
The following bash function should only replace ${var1} syntax and ignore other shell special chars such as `backticks` or $var2 or "double quotes". If I have missed anything - let me know.
template(){ while read -r line ; do line=${line line=${line line=${line line=${line eval "echo \"$line\""; done < ${1} } var1="*replaced*" var2="*not replaced*" template file.tpl > result.txt
cat my-file.conf.template | sigil -p $(env) > my-file.conf
$ echo $MYTEST pass! $ cat FILE hello $MYTEST world $ eval echo `cat FILE` hello pass! world
use Env; Env::import(); while(<>) { $_ =~ s/(\${\w+})/$1/eeg; $text .= $_; } print "$text";
$ cat config.data export parm_jdbc=jdbc:db2: export parm_user=pax export parm_pwd=never_you_mind $ cat go.bash . config.data echo "JDBC string is " $parm_jdbc echo "Username is " $parm_user echo "Password is " $parm_pwd $ bash go.bash JDBC string is jdbc:db2: Username is pax Password is never_you_mind
$ cat config.data parm_jdbc=jdbc:db2: parm_user=pax parm_pwd=never_you_mind $ cat go.bash cat config.data | sed | sed | sed | grep -v | sed >config.data-compiled . config.data-compiled echo "JDBC string is " $parm_jdbc echo "Username is " $parm_user echo "Password is " $parm_pwd $ bash go.bash JDBC string is jdbc:db2: Username is pax Password is never_you_mind
$ cat config.data export p_p1=val1 export p_p2=val2 $ cat go.bash . ./config.data echo "select * from dbtable where p1 = $ bash go.bash select * from dbtable where p1 =
ssh -nNT -L 50000:localhost:3306 jm@sampledomain.com
$ ssh -M -S my-ctrl-socket -fnNT -L 50000:localhost:3306 jm@sampledomain.com $ ssh -S my-ctrl-socket -O check jm@sampledomain.com Master running (pid=3517) $ ssh -S my-ctrl-socket -O exit jm@sampledomain.com Exit request sent.
... ssh -Cfo ExitOnForwardFailure=yes -NL 9999:localhost:5900 $REMOTE_HOST PID=$(pgrep -f [ "$PID" ] || exit 1 ...
$ : > sensitive-temporary-data.txt; bash; rm -f sensitive-temporary-data.txt; exit
string= if [[ "$string" == *My* ]] then echo "It fi needle= if [[ "$string" == *"$needle"* ]]; then echo "haystack fi
$ ls -l /bin/sh lrwxrwxrwx 1 root root 4 ago 15 2012 /bin/sh -> dash
myprogram > out.log 2> err.log myprogram &> out.log myprogram > out.log 2>&1 myprogram > out.log 2> /dev/null
[command] | ssh name@ip ssh name@ip [command] ssh name@ip "[command]" ssh -t name@ip [command]
ssh username@hostname -o LocalCommand="tmux list-sessions"
if [ -f $HOME/.add-screen-to-history ] ; then history -s fi
$ls -F test Baltimore/ Cherry Hill/ Edison/ New York City/ Philadelphia/ cities.txt
for f in `find test/* -type d | sed -e echo $f done
dirlist="${@}" ( [[ -z "$dirlist" ]] && dirlist=`find test -mindepth 1 -type d` && IFS=$ for d in $dirlist; do echo $d done )
while IFS= read -r -d printf done < <(find test -mindepth 1 -type d -print0)
declare -a myarray while IFS= read -r -d myarray+=( "$n" ) done < <(find test -mindepth 1 -type d -print0) printf
while IFS= read -r n; do printf done < <(find test -mindepth 1 -type d)
( IFS=$ set -f for n in $(find test -mindepth 1 -type d); do printf done )
entries=( test/* ) for d in "${entries[@]}"; do printf done
find . -type d | while read file; do echo $file; done
ls -F test Baltimore/ Cherry Hill/ Edison/ New York City/ Philadelphia/ cities.txt
find test -type d | while read f ; do echo "$f" done
test/Baltimore test/Cherry Hill test/Edison test/New York City test/Philadelphia
SAVEIFS=$IFS IFS=$(echo -en "\n\b") for f in $( find "$1" -type d ! -path "$1" ) do echo $f done IFS=$SAVEIFS
if [ $ dirlist=() for f in test/*; do if [ -d "$f" ]; then dirlist=("${dirlist[@]}" "$f") fi done else dirlist=("$@") fi for dir in "${dirlist[@]}"; do printf "Directory: %s\n" "$dir" done
$ ls -F test Baltimore/ Cherry Hill/ Edison/ New York City/ Philadelphia/ this is a dirname with quotes, lfs, escapes: "\ this is a file, not a directory $ ./test.sh Directory: test/Baltimore Directory: test/Cherry Hill Directory: test/Edison Directory: test/New York City Directory: test/Philadelphia Directory: test/this is a dirname with quotes, lfs, escapes: "\ ' \e\n\d $ ./test.sh "Cherry Hill" "New York City" Directory: Cherry Hill Directory: New York City
OLD_IFS=$IFS IFS=$ for f in `find test/* -type d`; do echo $f done $IFS=$OLD_IFS
read artist; find "/mnt/2tb_USB_hard_disc/p_music/$artist" -type f -name *.mp3 -exec mpg123
dirtys=() for folder in * do if [ -d "$folder" ]; then dirtys=("${dirtys[@]}" "$folder") fi done for dir in "${dirtys[@]}" do for file in "$dir"/\*.mov do out=`echo "$file" | sed out=`echo "$out" | sed `ffmpeg -i "$file" -sameq -vcodec msmpeg4v2 -acodec pcm_u8 "$dir"/${out/%mov/avi}` done done
[sony@localhost shell_tutorial]$ ls Chapter 01 - Introduction Chapter 02 - Your First Shell Script [sony@localhost shell_tutorial]$ cd Chapter\ 01\ -\ Introduction/ [sony@localhost Chapter 01 - Introduction]$ ls 0101 - About this Course.mov 0102 - Course Structure.mov [sony@localhost Chapter 01 - Introduction]$ ./above_script ... successfully executed. [sony@localhost Chapter 01 - Introduction]$ ls 0101_-_About_this_Course.avi 0102_-_Course_Structure.avi 0101 - About this Course.mov 0102 - Course Structure.mov [sony@localhost Chapter 01 - Introduction]$ CHEERS!
function recursedir { local item for item in "${1%/}"/* do if [ -d "$item" ] then recursedir "$item" else command fi done }
multiLineCommand="find . -mindepth 1 -printf eval "declare -a myArray=`( arr=(); while read -r line; do arr[${ for f in "${myArray[@]}" do echo "Element: $f" done
source="/xxx/xxx" dest="/yyy/yyy" n_max=`ls . | wc -l` echo "Loop over items..." i=1 while [ $i -le $n_max ];do item=`ls . | awk echo "File selected for compression: $item" tar -cvzf $dest/"$item".tar.gz "$item" i=$(( i + 1 )) done echo "Done!!!"
find Downloads -type f | while read file; do printf "%q\n" "$file"; done
for f in "$(find ./test -type d)" ; do echo "$f" done
for file in read `find . *.flv`; do ffmpeg -i ${file} -acodec copy ${file}.mp3;done
hello=ho02123ware38384you443d34o3434ingtod38384day echo ${hello
MYVAR=ho02123ware38384you443d34o3434ingtod38384day echo $MYVAR | sed -e
hello=ho02123ware38384you443d34o3434ingtod38384day re= while [[ $hello =~ $re ]]; do hello=${BASH_REMATCH[1]}${BASH_REMATCH[2]} done echo "$hello"
MYVAR=ho02123ware38384you443d34o3434ingtod38384day MYVAR=${MYVAR echo ${MYVAR
MYVAR=ho02123ware38384you443d34o3434ingtod38384day MYVAR=${MYVAR echo ${MYVAR
hello=ho02123ware38384you443d34o3434ingtod38384day echo ${hello hello=ho02123ware38384you443d34o3434ingtod38384day echo $hello | sed
hello=ho02123ware38384you443d34o3434ingtod38384day echo $hello | perl -pe
MYVAR=ho02123ware38384you443d34o3434ingtod38384day; echo $MYVAR | grep -o -E
hello=123456789X123456789X123456789X123456789X123456789X123456789X123456789X123456789X123456789X123456789X123456789X P1=$(date +%s) for i in {1..10000} do echo $hello | sed s/X done P2=$(date +%s) echo $[$P2-$P1] for i in {1..10000} do echo ${hello done P3=$(date +%s) echo $[$P3-$P2]
$ hello=ho02123ware38384you443d34o3434ingtod38384day $ echo ${hello howareyoudoingtodday
me$ FOO="BAR * BAR" me$ echo $FOO BAR file1 file2 file3 file4 BAR
curl: option -s --noproxy * -O: is unknown curl: try
GLOBIGNORE="*" curl_opts="-s --noproxy * -O" curl $curl_opts "$1"
me$ FOO="BAR * BAR" me$ echo $FOO BAR file1 file2 file3 file4 BAR me$ set -f me$ echo $FOO BAR * BAR me$ set +f me$ GLOBIGNORE=* me$ echo $FOO BAR * BAR
read -s PWD /usr/bin/expect <<EOD spawn ssh -oStrictHostKeyChecking=no -oCheckHostIP=no usr@$myhost.example.com' expect "password" send "$PWD\n" EOD echo "you
spawn ssh -oStrictHostKeyChecking=no -oCheckHostIP=no usr@$myhost.example.com usr@$myhost.example.com
eval spawn ssh -oStrictHostKeyChecking=no -oCheckHostIP=no usr@$myhost.example.com set prompt ":| interact -o -nobuffer -re $prompt return send "my_password\r" interact -o -nobuffer -re $prompt return send "my_command1\r" interact -o -nobuffer -re $prompt return send "my_command2\r" interact
sshpass -p<password> ssh <arguments> sshpass -ptest1324 ssh user@192.168.1.200 ls -l /tmp
read -s PWD /usr/bin/expect <<EOD spawn ssh -oStrictHostKeyChecking=no -oCheckHostIP=no usr@$myhost.example.com' expect "password" send "$PWD\n" interact EOD echo "you
set timeout 20 set cmd [lrange $argv 1 end] set password [lindex $argv 0] eval spawn $cmd expect "assword:" send "$password\r"; interact
set user [lindex $argv 1] set ip [lindex $argv 0] set password [lindex $argv 2] spawn ssh $user@$ip expect "password" send "$password\r" interact
... bash-script start bash-commands ... expect - <<EOF spawn your-command-here expect "some-pattern" send "some-command" ... ... EOF ... more bash commands ...
[[ "a" = "a" ]] && echo equal || echo not-equal [[ "a" == "a" ]] && echo equal || echo not-equal [[ "a" = "b" ]] && echo equal || echo not-equal [[ "a" == "b" ]] && echo equal || echo not-equal
mkfifo "$HOME/.pause.fifo" 2>/dev/null; read <"$HOME/.pause.fifo"
printf diet -Os cc pause.c -o pause; strip -s pause; ls -al pause
snore() { [[ -n "${_snore_fd:-}" ]] || exec {_snore_fd}<> <(:) read ${1:+-t "$1"} -u $_snore_fd || : }
for d in [0-9][0-9][0-9] do ( cd "$d" && your-command-here ) done
find . -maxdepth 1 -type d \( ! -name . \) -exec bash -c "cd
find . -type d -print0 | while IFS= read -r -d done
dirs=($(find . -type d)) for dir in "${dirs[@]}"; do cd "$dir" echo $PWD done
for dir in `ls $YOUR_TOP_LEVEL_FOLDER`; do for subdir in `ls $YOUR_TOP_LEVEL_FOLDER/$dir`; do $(PLAY AS MUCH AS YOU WANT); done done
for dir in PARENT/* do test -d "$dir" || continue done
cur=$PWD args=("$@") function dir_command { cd $1 echo "$(tput setaf 2)$1$(tput sgr 0)" git tag -a ${args[0]} -m "${args[1]}" git push --tags cd .. } find . -maxdepth 1 -type d \( ! -name . \) | while read dir; do dir_command "$dir/" done declare -a dirs=("dir1" "dir2" "dir3") for dir in "${dirs[@]}"; do dir_command "$dir/" done cd "$cur"
cd parent find . -type d | while read d; do ls $d/ done
for p in [0-9][0-9][0-9];do ( cd $p for f in [0-9][0-9][0-9][0-9]*.txt;do ls $f; done ) done
cmd-doesnt-respect-difference-between-stdout-and-stderr | grep -i SomeError
$ { echo "stdout"; echo "stderr" 1>&2; } | grep -v std stderr $
$ { echo "stdout"; echo "stderr" 1>&2; } 2>&1 | grep -v std $
cmd-doesnt-respect-difference-between-stdout-and-stderr 2>&1 | grep -i SomeError
cmd-doesnt-respect-difference-between-stdout-and-stderr |& grep -i SomeError
cmd-doesnt-respect-difference-between-stdout-and-stderr |& grep -i SomeError
pipe_comment() { cat - } cat input.txt \ | pipe_comment "filter down to lines that contain the word: something" \ | grep something \ | pipe_comment "reverse sort what is left" \ | sort -r
cat input.txt \ | cat - `: filter down to lines that contain the word: something` \ | grep something \ | cat - `: reverse sort what is left` \ | sort -r
CREATE UNIQUE INDEX u1_table ON Table(...); CREATE {DUPS} INDEX d1_table ON Table(...);
$ : Hello world, how are you? && echo "Fine." Fine.
$ array=("a c" b f "3 5") $ IFS=$ $ printf "[%s]\n" "${sorted[@]}" [3 5] [a c] [b] [f]
array=(a c b "f f" 3 5) readarray -t sorted < <(for a in "${array[@]}"; do echo "$a"; done | sort)
$ for a in "${sorted[@]}"; do echo "$a"; done 3 5 a b c f f
qsort() { local pivot i smaller=() larger=() qsort_ret=() (($ pivot=$1 shift for i; do if [[ $i < $pivot ]]; then smaller+=( "$i" ) else larger+=( "$i" ) fi done qsort "${smaller[@]}" smaller=( "${qsort_ret[@]}" ) qsort "${larger[@]}" larger=( "${qsort_ret[@]}" ) qsort_ret=( "${smaller[@]}" "$pivot" "${larger[@]}" ) }
$ array=(a c b f 3 5) $ qsort "${array[@]}" $ declare -p qsort_ret declare -a qsort_ret=
qsort() { (($ local stack=( 0 $(($ qsort_ret=("$@") while ((${ beg=${stack[0]} end=${stack[1]} stack=( "${stack[@]:2}" ) smaller=() larger=() pivot=${qsort_ret[beg]} for ((i=beg+1;i<=end;++i)); do if [[ "${qsort_ret[i]}" < "$pivot" ]]; then smaller+=( "${qsort_ret[i]}" ) else larger+=( "${qsort_ret[i]}" ) fi done qsort_ret=( "${qsort_ret[@]:0:beg}" "${smaller[@]}" "$pivot" "${larger[@]}" "${qsort_ret[@]:end+1}" ) if ((${ if ((${ done }
qsort() { (($ local compare_fun=$1 shift local stack=( 0 $(($ qsort_ret=("$@") while ((${ beg=${stack[0]} end=${stack[1]} stack=( "${stack[@]:2}" ) smaller=() larger=() pivot=${qsort_ret[beg]} for ((i=beg+1;i<=end;++i)); do if "$compare_fun" "${qsort_ret[i]}" "$pivot"; then smaller+=( "${qsort_ret[i]}" ) else larger+=( "${qsort_ret[i]}" ) fi done qsort_ret=( "${qsort_ret[@]:0:beg}" "${smaller[@]}" "$pivot" "${larger[@]}" "${qsort_ret[@]:end+1}" ) if ((${ if ((${ done }
declare BSORT=() function bubble_sort() { # # # # (($ local j=0 ubound=$((${ while ((ubound > 0)) do local i=0 while ((i < ubound)) do if [ "${BSORT[$i]}" \> "${BSORT[$((i + 1))]}" ] then local t="${BSORT[$i]}" BSORT[$i]="${BSORT[$((i + 1))]}" BSORT[$((i + 1))]="$t" fi ((++i)) done ((++j)) ((--ubound)) done echo $j } bubble_sort a c b echo ${BSORT[@]}
local e new_array=() while IFS= read -r -d new_array+=( "${e}" ) done < <(printf "%s\0" "${array[@]}" | LC_ALL=C sort -z)
for e in "${array[@]}"; do printf "%s\0" "${e}" done
array=(.....) index_of_element1=0 while (( ${index_of_element1} < ${ element_1="${array[${index_of_element1}]}" index_of_element2=$((index_of_element1 + 1)) index_of_min=${index_of_element1} min_element="${element_1}" for element_2 in "${array[@]:$((index_of_element1 + 1))}"; do min_element="`printf "%s\n%s" "${min_element}" "${element_2}" | sort | head -n+1`" if [[ "${min_element}" == "${element_2}" ]]; then index_of_min=${index_of_element2} fi let index_of_element2++ done array[${index_of_element1}]="${min_element}" array[${index_of_min}]="${element_1}" let index_of_element1++ done
tab= for ((i = 0; i < ${ declare -g ord_${tab:i:1}=$i done function sexy_int() { local sum=0 local i ch ref for ((i = 0; i < ${ ch="${1:i:1}" ref="ord_$ch" (( sum += ${!ref} )) done return $sum } sexy_int hello echo "hello -> $?" sexy_int world echo "world -> $?"
array=(a c b f 3 5) for el in "${array[@]}"; do sexy_int "$el" sorted[$?]="$el" done echo "${sorted[@]}"
array=(a c b f 3 5) new_array=($(echo "${array[@]}" | sed echo ${new_array[@]}
function bubble_sort() { # # # local array=($@) max=$(($ while ((max > 0)) do local i=0 while ((i < max)) do if [ ${array[$i]} \> ${array[$((i + 1))]} ] then local t=${array[$i]} array[$i]=${array[$((i + 1))]} array[$((i + 1))]=$t fi ((i += 1)) done ((max -= 1)) done echo ${array[@]} } array=(a c b f 3 5) echo " input: ${array[@]}" echo "output: $(bubble_sort ${array[@]})"
a=(e b shuf -e "${a[@]}" | sort >/tmp/f mapfile -t g </tmp/f
sortarray(){ local wa=$ if [[ $* =~ [$wa] ]]; then echo "$0: error: array contains the workaround char" >&2 exit 1 fi set -f; local IFS=$ set -- $(printf for x do sorted+=("${x done }
$ array=( a b $ sortarray "${array[@]}" $ printf <a> <b> <c d> <e f> <gh>
$ array=( a b $ sortarray "${array[@]}" ./script: error: array contains the workaround char
% sed "s/root/toor/" /etc/passwd | grep -v joey | sponge /etc/passwd
$ mistyped_command my-important-file | sponge my-important-file mistyped-command: command not found
sort temp.txt > temp.txt.sort && mv temp.txt.sort temp.txt
-o output-file Write output to output-file instead of to the standard output. If output-file is one of the input files, sort copies it to a temporary file before sorting and writing the output to output- file.
ip_cmd() { CMD=${1:?You must specify a command} FILE=${2:?You must specify a file} sed -ni r<("$CMD" "$FILE") "$FILE" }
$ cat file d b c b a $ ip_cmd sort file $ cat file a b b c d $ ip_cmd uniq file $ cat file a b c d $ ip_cmd tac file $ cat file d c b a $ ip_cmd bash: 1: You must specify a command $ ip_cmd uniq bash: 2: You must specify a file
cat file.txt | while read in; do chmod 755 "$in"; done
while read line; do chmod 755 "$line"; done <file.txt
last |head -10|awk while IFS= read -r line do su - "$line" -c done
$ > echo pierre pierre $ > echo my name is $(!!) echo my name is $(echo pierre) my name is pierre
f() { bash -c "$BASH_COMMAND" >& /tmp/out.log; } trap
$ find app -name /var/bar/app/one.php $ diff /var/bar/app/one.php /var/bar/two.php
$ find app -name $ diff $(pbpaste) /var/bar/two.php
save_output() { exec 1>&3 { [ -f /tmp/current ] && mv /tmp/current /tmp/last; } exec > >(tee /tmp/current) } exec 3>&1 trap save_output DEBUG
output = `ls` if output.include? "Downloads" print "there appears to be a folder named downloads in this directory." else print "there is no directory called downloads in this file." end
$ MY_HISTORY_FILE = `get_temp_filename` $ MY_HISTORY_FILE=$MY_HISTORY_FILE bash -i 2>&1 | tee $MY_HISTORY_FILE $ some_command $ cat $MY_HISTORY_FILE $
? changes.patch M app/models/superman.rb A app/models/superwoman.rb
alias c1="awk alias c2="awk alias c3="awk alias c4="awk alias c5="awk alias c6="awk alias c7="awk alias c8="awk alias c9="awk
alias -g X2="| cut -d alias -g X1="| cut -d alias -g X3="| cut -d
svn st | cut -c8- | while read FILE; do echo whatever with "$FILE"; done
for line in (< /path/to/file); do echo "Line: $line" done
OLDIFS=$IFS IFS=$ for line in (< /path/to/file); do echo "Line: $line" done IFS=$OLDIFS
echo -n $ echo -n echo -n $"\n" | od -c echo -n "\n" | od -c
0000000 \n 0000001 0000000 \ n 0000002 0000000 \ n 0000002 0000000 \ n 0000002
curl -i \ -H "Accept: application/json" \ -H "Content-Type:application/json" \ -X POST --data
curl: (6) Could not resolve host: application; nodename nor servname provided, or not known curl: (6) Could not resolve host: is; nodename nor servname provided, or not known curl: (6) Could not resolve host: a; nodename nor servname provided, or not known curl: (6) Could not resolve host: test; nodename nor servname provided, or not known curl: (3) [globbing] unmatched close brace/bracket at pos 158
generate_post_data() { cat <<EOF { "account": { "email": "$email", "screenName": "$screenName", "type": "$theType", "passwordSettings": { "password": "$password", "passwordConfirm": "$password" } }, "firstName": "$firstName", "lastName": "$lastName", "middleName": "$middleName", "locale": "$locale", "registrationSiteId": "$registrationSiteId", "receiveEmail": "$receiveEmail", "dateOfBirth": "$dob", "mobileNumber": "$mobileNumber", "gender": "$gender", "fuelActivationDate": "$fuelActivationDate", "postalCode": "$postalCode", "country": "$country", "city": "$city", "state": "$state", "bio": "$bio", "jpFirstNameKana": "$jpFirstNameKana", "jpLastNameKana": "$jpLastNameKana", "height": "$height", "weight": "$weight", "distanceUnit": "MILES", "weightUnit": "POUNDS", "heightUnit": "FT/INCHES" } EOF }
curl -i \ -H "Accept: application/json" \ -H "Content-Type:application/json" \ -X POST --data "$(generate_post_data)" "https:
for i in {1..3}; do \ curl -X POST -H "Content-Type: application/json" -d \ done
declare -a arr=("el a" "el b" "el c"); for i in "${arr[@]}"; do \ curl -X POST -H "Content-Type: application/json" -d \ done
curl "http: -H "Accept: application/json" \ -H "Content-Type:application/json" \ --data @<(cat <<EOF { "me": "$USER", "something": $(date +%s) } EOF )
POST / HTTP/1.1 Host: localhost:8080 User-Agent: curl/7.43.0 Accept: application/json Content-Type:application/json Content-Length: 43 { "me": "username", "something": 1465057519 }
bin/curl -X PUT "db_domain_name_:5984/_config/vhosts/$1.couchdb" -d
postDataJson="{\"guid\":\"$guid\",\"auth_token\":\"$token\"}"
$(curl --silent -H "Content-Type: application/json" https:
matchdir="/home/joao/robocup/runner_workdir/matches/testmatch/" teamAComm="`pwd`/a.sh" teamBComm="`pwd`/b.sh" include="`pwd`/server_official.conf" serverbin= cd $matchdir illcommando="$serverbin include= echo "running: $illcommando" $illcommando
running: /usr/local/bin/rcssserver include= rcssserver-14.0.1 Copyright (C) 1995, 1996, 1997, 1998, 1999 Electrotechnical Laboratory. 2000 - 2009 RoboCup Soccer Simulator Maintenance Group. Usage: /usr/local/bin/rcssserver [[-[-]]namespace::option=value] [[-[-]][namespace::]help] [[-[-]]include=file] Options: help display generic help include=file parse the specified configuration file. Configuration files have the same format as the command line options. The configuration file specified will be parsed before all subsequent options. server::help display detailed help for the "server" module player::help display detailed help for the "player" module CSVSaver::help display detailed help for the "CSVSaver" module CSVSaver Options: CSVSaver::save=<on|off|true|false|1|0|> If save is on/true, then the saver will attempt to save the results to the database. Otherwise it will do nothing. current value: false CSVSaver::filename= The file to save the results to. If this file does not exist it will be created. If the file does exist, the results will be appended to the end. current value:
matchdir="/home/joao/robocup/runner_workdir/matches/testmatch/" PWD=$(pwd) teamAComm="$PWD/a.sh" teamBComm="$PWD/b.sh" include="$PWD/server_official.conf" serverbin= cd $matchdir $serverbin include=$include server::team_l_start = ${teamAComm} server::team_r_start=${teamBComm} CSVSaver::save=
your_command_string="..." output=$(eval "$your_command_string") echo "$output"
my_exe () { mysql -sN -e "select $1 from heat.stack where heat.stack.name=\"$2\";" }
ACTION=$(my_exe action Somestack) STATUS=$(my_exe status Somestack) if [[ "$ACTION" == "CREATE" ]] && [[ "$STATUS" == "COMPLETE" ]] ...
( ( seq 1 100 | tee /dev/fd/2 | head 1>&3 ) 2>&1 | tail ) 3>&1 ( ( seq 1 100 | tee /dev/stderr | head 1>&3 ) 2>&1 | tail ) 3>&1
cat file | { tee >(head >&3; cat >/dev/null) | tail; } 3>&1
command | tee full.log | stdbuf -i0 -o0 -e0 awk -v offset=${MAX_LINES:-200} \ if (NR <= offset) print; else { a[NR] = $0; delete a[NR-offset]; printf "." > "/dev/stderr" } } END { print "" > "/dev/stderr"; for(i=NR-offset+1 > offset ? NR-offset+1: offset+1 ;i<=NR;i++) { print a[i]} }'
sed -n "1,10p; $(( $(wc -l ${aFile} | grep -oE "^[[:digit:]]+")-9 )),\$p" "${aFile}"
$ head somefile.csv && echo ... && tail somefile.csv
b=File.read("file2").split open("file1").each do |x| x.chomp! puts x if !b.include?(x) end
b=File.read("file2").split a=File.read("file1").split (a-b).each {|x| puts x}
$ for i in $(seq 1 100000); do echo "$i"; done|sort --random-sort > file1 $ for i in $(seq 1 2 100000); do echo "$i"; done|sort --random-sort > file2 $ time ruby test.rb > ruby.test real 0m0.639s user 0m0.554s sys 0m0.021s $time sort file1 file2|uniq -u > sort.test real 0m2.311s user 0m1.959s sys 0m0.040s $ diff <(sort -n ruby.test) <(sort -n sort.test) $
$ for n in {1..10000}; do echo $RANDOM; done > f1 $ for n in {1..10000}; do echo $RANDOM; done > f2 $ time comm -23 <(sort f1) <(sort f2) > /dev/null real 0m0.019s user 0m0.023s sys 0m0.012s $ time ruby -e real 0m0.026s user 0m0.018s sys 0m0.007s $ time grep -xvf f2 f1 > /dev/null real 0m43.197s user 0m43.155s sys 0m0.040s
create table file1(line text); create index if1 on file1(line ASC); create table file2(line text); create index if2 on file2(line ASC); -- comment: if you have | in your files then specify “ .separator ××any_improbable_string×× ” .import .import .output result.txt select * from file2 where line not in (select line from file1); .q
$ tail -f /var/log/lastlog & [1] 5636 $ ls -l /proc/5636/fd total 0 lrwx------ 1 myuser myuser 64 Feb 27 07:36 0 -> /dev/pts/0 lrwx------ 1 myuser myuser 64 Feb 27 07:36 1 -> /dev/pts/0 lrwx------ 1 myuser myuser 64 Feb 27 07:36 2 -> /dev/pts/0 lr-x------ 1 myuser myuser 64 Feb 27 07:36 3 -> /var/log/lastlog $ gdb -p 5636 GNU gdb 6.8-debian Copyright (C) 2008 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http: This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Attaching to process 5636 Reading symbols from /usr/bin/tail...(no debugging symbols found)...done. Reading symbols from /lib/librt.so.1...(no debugging symbols found)...done. Loaded symbols for /lib/librt.so.1 Reading symbols from /lib/libc.so.6...(no debugging symbols found)...done. Loaded symbols for /lib/libc.so.6 Reading symbols from /lib/libpthread.so.0...(no debugging symbols found)...done. [Thread debugging using libthread_db enabled] [New Thread 0x7f3c8f5a66e0 (LWP 5636)] Loaded symbols for /lib/libpthread.so.0 Reading symbols from /lib/ld-linux-x86-64.so.2...(no debugging symbols found)...done. Loaded symbols for /lib64/ld-linux-x86-64.so.2 (no debugging symbols found) 0x00007f3c8eec7b50 in nanosleep () from /lib/libc.so.6 (gdb) p dup2(open("/dev/null",0),1) [Switching to Thread 0x7f3c8f5a66e0 (LWP 5636)] $1 = 1 (gdb) p dup2(open("/dev/null",0),2) $2 = 2 (gdb) detach Detaching from program: /usr/bin/tail, process 5636 (gdb) quit $ ls -l /proc/5636/fd total 0 lrwx------ 1 myuser myuser 64 Feb 27 07:36 0 -> /dev/pts/0 lrwx------ 1 myuser myuser 64 Feb 27 07:36 1 -> /dev/null lrwx------ 1 myuser myuser 64 Feb 27 07:36 2 -> /dev/null lr-x------ 1 myuser myuser 64 Feb 27 07:36 3 -> /var/log/lastlog lr-x------ 1 myuser myuser 64 Feb 27 07:36 4 -> /dev/null lr-x------ 1 myuser myuser 64 Feb 27 07:36 5 -> /dev/null
p dup2(open("/dev/null",0),1) p dup2(open("/dev/null",0),2) detach quit
if [ "$0" -a "$1" ]; then gdb -p $1 -x $0.gdb else echo Must specify PID of process to silence >&2 fi
p close(1) p open("/dev/pts/4", 1) p close(2) p open("/tmp/myerrlog", 1) q
pid=$(cat /var/run/app/app.pid) logFile="/var/log/app.log" reloadLog() { if [ "$pid" = "" ]; then echo "invalid PID" else gdb -p $pid >/dev/null 2>&1 <<LOADLOG p close(1) p open("$logFile", 1) p close(2) p open("$logFile", 1) q LOADLOG LOG_FILE=$(ls /proc/${pid}/fd -l | fgrep " 1 -> " | awk echo "log file set to $LOG_FILE" fi } reloadLog
$ cat /etc/security/pam_env.conf DISPLAY DEFAULT=${REMOTEHOST}:0.0 OVERRIDE=${DISPLAY} abc DEFAULT=/var/tmp/myproject
4. New Features in Readline j. New user-settable variable, show-mode-in-prompt, adds a characters to the beginning of the prompt indicating the current editing mode.
function prompt { PS1= echo -e "$(date +%R) $PWD" } PROMPT_COMMAND=
20:57 /home/sshbio/dotfiles/bash + > ls _ bashrc bash_profile inputrc + > ls _
for (( COUNTER=0; COUNTER<=10; COUNTER+=2 )); do echo $COUNTER done
for i in $(seq 1 2 10) do echo "skip by 2 value $i" done
file=bigone.log lines=3 truncate -s -$(tail -$lines $file | wc -c) $file
truncate -s $(head -n -5 /var/log/secure | wc -c) /var/log/secure
count=`wc -l file` lines=`expr "$count" - n` head -n "$lines" file > temp.txt mv temp.txt file rm -f temp.txt
root / root cd: /tnp/test: No such file or directory ... ... and after a while ... ... ^C
PASSED=$1 if [ -d "${PASSED}" ] ; then echo "$PASSED is a directory"; else if [ -f "${PASSED}" ]; then echo "${PASSED} is a file"; else echo "${PASSED} is not valid"; exit 1 fi fi
andy@server~ $ ./scripts/testmove.sh /home/andy/ /home/andy/ is a directory andy@server~ $ ./scripts/testmove.sh /home/andy/blah.txt /home/andy/blah.txt is a file andy@server~ $ ./scripts/testmove.sh /home/andy/blah\ with\ a\ space.txt /home/andy/blah with a space.txt is not valid andy@server~ $ ./scripts/testmove.sh /home/andy\ with\ a\ space/ /home/andy with a space/ is not valid
if [[ -d $PASSED ]]; then echo "$PASSED is a directory" elif [[ -f $PASSED ]]; then echo "$PASSED is a file" else echo "$PASSED is not valid" exit 1 fi
PASSED=$1 if [ -d "${PASSED}" ] then echo "${PASSED} is a directory"; elif [ -f "${PASSED}" ] then echo "${PASSED} is a file"; else echo "${PASSED} is not valid"; exit 1 fi
$ cp /dev/null "xx sh" $ for file in . xx*; do sh "$file"; done . is a directory xx sh is a file xx.sh is a file $
F_NAME="${1}" if test -f "${F_NAME}" then echo "${F_NAME} is a file" elif test -d "${F_NAME}" then echo "${F_NAME} is a directory" else echo "${F_NAME} is not valid" fi
echo "Enter the file name" read x if [ -f $x ] then echo "This is a regular file" else echo "This is a directory" fi
check_file(){ if [ -z "${1}" ] ;then echo "Please input something" return; fi f="${1}" result="$(file $f)" if [[ $result == *"cannot open"* ]] ;then echo "NO FILE FOUND ($result) "; elif [[ $result == *"directory"* ]] ;then echo "DIRECTORY FOUND ($result) "; else echo "FILE FOUND ($result) "; fi } check_file ${1}
$ ./f.bash login DIRECTORY FOUND (login: directory) $ ./f.bash ldasdas NO FILE FOUND (ldasdas: cannot open `ldasdas $ ./f.bash evil.php FILE FOUND (evil.php: PHP script, ASCII text)
check_file(){ local file="${1}" [[ -s "${file}" ]] || { echo "is not valid"; return; } [[ -d "${file}" ]] && { echo "is a directory"; return; } [[ -f "${file}" ]] && { echo "is a file"; return; } } check_file ${1}
echo "Please Enter a file name :" read filename if test -f $filename then echo "this is a file" else echo "this is not a file" fi
2012.11.21.09_33_52.script 2012.11.21.09_33_56.script 2012.11.21.09_33_59.script
timestamp=$(date +%Y%m%d_%H%M%S) path="/data/backuplog" filename=log_back_$timestamp.txt log=$path/$filename find $path -name "*.txt" -type f -mtime +7 -print -delete >> $log echo "Backup:: Script Start -- $(date +%Y%m%d_%H%M)" >> $log START_TIME=$(date +%s) ... code for backup ...or any other operation .... END_TIME=$(date +%s) ELAPSED_TIME=$(expr $END_TIME - $START_TIME) echo "Backup :: Script End -- $(date +%Y%m%d_%H%M)" >> $log echo "Elapsed Time :: $(date -d 00:00:$ELAPSED_TIME +%Hh:%Mm:%Ss) " >> $log
CORES=$(grep -c ^processor /proc/cpuinfo 2>/dev/null || sysctl -n hw.ncpu)
$ ls /sys/devices/system/cpu/ cpu0 cpufreq kernel_max offline possible present release cpu1 cpuidle modalias online power probe uevent $ cat /sys/devices/system/cpu/kernel_max 255 $ cat /sys/devices/system/cpu/offline 2-63 $ cat /sys/devices/system/cpu/possible 0-63 $ cat /sys/devices/system/cpu/present 0-1 $ cat /sys/devices/system/cpu/online 0-1
MODEL=`cat /cpu/procinfo | grep "model name" | sort | uniq` ALL=`cat /proc/cpuinfo | grep "bogo" | wc -l` PHYSICAL=`cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l` CORES=`cat /proc/cpuinfo | grep "cpu cores" | sort | uniq | cut -d PHY_CORES=$(($PHYSICAL * $CORES)) echo "Type $MODEL" echo "Processors $PHYSICAL" echo "Physical cores $PHY_CORES" echo "Including hyperthreading cores $ALL"
Type model name : Intel(R) Xeon(R) CPU X5650 @ 2.67GHz Processors 2 Physical cores 12 Including hyperthreading cores 24
Type model name : Intel(R) Xeon(R) CPU E5472 @ 3.00GHz Processors 2 Physical cores 8 Including hyperthreading cores 8
$ lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 4 On-line CPU(s) list: 0-3 Thread(s) per core: 2 Core(s) per socket: 2 Socket(s): 1 NUMA node(s): 1 Vendor ID: GenuineIntel CPU family: 6 Model: 58 Model name: Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz Stepping: 9 CPU MHz: 3406.253 CPU max MHz: 3600.0000 CPU min MHz: 1200.0000 BogoMIPS: 5787.10 Virtualization: VT-x L1d cache: 32K L1i cache: 32K L2 cache: 256K L3 cache: 4096K NUMA node0 CPU(s): 0-3
for entry in "$search_dir"/* "$work_dir"/* do if [ -f "$entry" ];then echo "$entry" fi done
yourfilenames=`ls ./*.txt` for eachfile in $yourfilenames do echo $eachfile done
find "${search_dir}" "${work_dir}" -mindepth 1 -maxdepth 1 -type f -print0 | xargs -0 -I {} echo "{}"
cd "search_dir" for [ z in `echo *` ]; do echo "$z" done
if [ test -d $z ]; then echo "$z is a directory" fi
while ps -p `cat $PID_FILE` > /dev/null; do sleep 1; done
anywait(){ for pid in "$@"; do while kill -0 "$pid"; do sleep 0.5 done done }
lsof -p $pid +r 1m%s -t | grep -qm1 $(date -v+${timeout}S +%s 2>/dev/null || echo INF)
while pgrep -u root process_name > /dev/null; do sleep 1; done
PID=<pid to watch> while s=`ps -p $PID -o s=` && [[ "$s" && "$s" != sleep 1 done
while [[ ( -d /proc/$PID ) && ( -z `grep zombie /proc/$PID/status` ) ]]; do sleep 1 done
wait [n ...] Wait for each specified process and return its termination status Each n may be a process ID or a job specification; if a job spec is given, all processes in that job waited for. If n is not given, all currently active child processes are waited for, and the return status is zero. If n specifies a non-existent process or job, the return status is 127. Otherwise, the return status is the exit status of the last process or job waited for.
while ps axg | grep -vw grep | grep -w process_name > /dev/null; do sleep 1; done
int main(int argc, char *argv[]) { if (argc == 1) return 1; pid_t pid = atoi(argv[1]); if (ptrace(PTRACE_SEIZE, pid, NULL, NULL) == -1) return 1; siginfo_t sig; return waitid(P_PID, pid, &sig, WEXITED|WNOWAIT); }
while ps axg | grep process_name$ > /dev/null; do sleep 1; done
function anywait() { for pid in "$@" do wait $pid echo "Process $pid terminated" done echo }
function anywait_w_status() { for pid in "$@" do while kill -0 "$pid" do echo "Process $pid still running..." sleep 1 done done echo }
function anywait_w_status2() { while true do alive_pids=() for pid in "$@" do kill -0 "$pid" 2>/dev/null \ && alive_pids+="$pid " done if [ ${ then break fi echo "Process(es) still running... ${alive_pids[@]}" sleep 1 done echo }
HTTP/1.1 200 OK Server: nginx Content-Type: text/html; charset=utf-8 X-Powered-By: PHP/5.2.17 Last-Modified: Sat, 03 Dec 2011 00:07:57 GMT ETag: "6c38e1154f32dbd9ba211db8ad189b27" Expires: Sun, 19 Nov 1978 05:00:00 GMT Cache-Control: must-revalidate Content-Encoding: gzip Content-Length: 7796 Date: Sat, 03 Dec 2011 00:46:22 GMT X-Varnish: 1509870407 1509810501 Age: 504 Via: 1.1 varnish Connection: keep-alive X-Cache-Svr: p2137050.pubip.peer1.net X-Cache: HIT X-Cache-Hits: 425
$ curl -V ... Protocols: ... Features: GSS-Negotiate IDN IPv6 Largefile NTLM SSL libz
echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/flacs/Programmes/USFOS/bin:/home/flacs/Programmes/USFOS/bin:/home/flacs/Programmes/USFOS/bin:/home/flacs/Programmes/USFOS/bin:/home/flacs/Programmes/USFOS/bin:/home/flacs/Programmes/USFOS/bin
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
pathremove () { local IFS= local NEWPATH local DIR local PATHVARIABLE=${2:-PATH} for DIR in ${!PATHVARIABLE} ; do if [ "$DIR" != "$1" ] ; then NEWPATH=${NEWPATH:+$NEWPATH:}$DIR fi done export $PATHVARIABLE="$NEWPATH" }
pathprepend () { pathremove $1 $2 local PATHVARIABLE=${2:-PATH} export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}" } pathappend () { pathremove $1 $2 local PATHVARIABLE=${2:-PATH} export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1" }
$ pathprepend /usr/local/sbin $ pathappend /usr/local/bin $ pathappend /usr/sbin $ pathappend /usr/bin $ pathappend /sbin $ pathappend /bin $ pathappend /usr/games
$ export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
$ PATH=$( python -c " import os path = os.environ[ print( " )
$ PATH=$( python -c " import os path = os.environ[ print( " )
export PATH="$(echo "$PATH" |/bin/awk {sub(sprintf("%c$",10),"");if(A[$0]){}else{A[$0]=1; printf(((NR==1)?"":":")$0)}}
# # pathlist=`echo $PATH | sed unset PATH for dir in $pathlist do if test -d $dir ; then if test -z $PATH; then PATH=$dir else PATH=$PATH:$dir fi fi done export PATH
PATH=`echo $PATH | perl -pe s:/path/to/be/excluded::`
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
var3=`echo "ibase=16; $var1" | bc` var4=`echo "ibase=16; $var2" | bc` var5=$(($var4-$var3))
Line 48: -: syntax error: operand expected (error token is "-")
echo $((0x2f)) 47 hexNum=2f echo $((0x${hexNum})) 47
$ unset var3 var4; var5=$(($var4-$var3)) bash: -: syntax error: operand expected (error token is "-")
var3=bfca3000; var3=`echo "ibase=16; ${var1^^}" | bc`
var1="bfca3000" var2="efca3250" var3="$(echo "ibase=16; ${var1^^}" | bc)" var4="$(echo "ibase=16; ${var2^^}" | bc)" var5="$(($var4-$var3))" echo "Diference $var5"
var1="bfca3000" var2="efca3250" var5="$(( 16 echo "Diference $var5"
$> echo "some123_string_and_another" | grep -o -P 23_string_and
awk match($0, /test_pattern/); print substr($0, RSTART - 10, RLENGTH + 20); }
x="hey there how are you" echo "$x" |awk --re-interval ere are
echo hey there how are you |perl -lne hey there how
cp /my/long/path/here/thing.txt /my/other/path/here/cpedthing.txt
cp: cannot create regular file `/my/other/path/here/cpedthing.txt
COMMAND1 && COMMAND2 mkdir -p /my/other/path/here/ && touch /my/other/path/here/cpedthing.txt
FILE=./base/data/sounds/effects/camera_click.ogg mkdir -p "$(dirname "$FILE")" && touch "$FILE"
mktouch() { if [ $ echo "Missing argument"; return 1; fi for f in "$@"; do mkdir -p -- "$(dirname -- "$f")" touch -- "$f" done }
mktouch ./base/data/sounds/effects/camera_click.ogg ./some/other/file
install -D /my/long/path/here/thing.txt /my/other/path/here/cpedthing.txt
install -D <(echo 1) /my/other/path/here/cpedthing.txt
for f in "$@"; do mkdir -p "$(dirname "$f")"; done touch "$@"
mkdir -p /my/other/path/here/ touch /my/other/path/here/cpedthing.txt
mkdir -p /code/temp/other/path/here touch /code/temp/other/path/here/cpredthing.txt
mkdir -p /code/temp/other/path/here && touch $_/{cpredthing.txt,anotherfile,somescript.sh}
mkdir -p /code/temp/other/path/here touch /code/temp/other/path/here/cpredthing.txt /code/temp/other/path/here/anotherfile /code/temp/other/path/here/somescript.sh
if [ ! -d /my/other ] then mkdir /my/other/path/here cp /my/long/path/here/thing.txt /my/other/path/here/cpedthing.txt fi
ptouch() { for p in "$@"; do _dir="$(dirname -- "$p")" [ -d "$_dir" ] || mkdir -p -- "$_dir" touch -- "$p" done }
mkdir -p /my/other/path/here;cp /my/long/path/here/thing.txt /my/other/path/here/cpedthing.txt
mkdir -p /my/other/path/here cp /my/long/path/here/thing.txt /my/other/path/here/cpedthing.txt
cd /my/long cp --parents path/here/thing.txt /my/other
rm -rf /abs/path/to/file; mkdir -p /abs/path/to/file; rm -rf /abs/path/to/file; touch /abs/path/to/file;
wget -q --tries=10 --timeout=20 --spider http: if [[ $? -eq 0 ]]; then echo "Sorry you are Offline" exit 1
if [[ $? -ne 0 ]]; then if ! [[ $? -eq 0 ]]; then if [[ ! $? -eq 0 ]]; then
if ! wget -q --spider --tries=10 --timeout=20 google.com then echo exit 1 fi
wget -q --tries=10 --timeout=20 --spider http: { echo "Sorry you are Offline" && exit 1; }
wget -q --tries=10 --timeout=20 --spider http: if (( $? != 0 )); then echo "Sorry you are Offline" exit 1 fi
var_a=1 var_b=2 (( var_a < var_b )) && echo "a is smaller"
wget -q --tries=10 --timeout=20 --spider http: if [[ $? -ne 0 ]]; then echo "Sorry you are Offline" exit 1 fi
511 clear 512 history 513 history -d 505 514 history 515 history -d 507 510 513 516 history 517 history -d 509 518 history 519 history -d 511 520 history
1003 25-04-2016 17:54:52 echo "Command 1" 1004 25-04-2016 17:54:54 echo "Command 2" 1005 25-04-2016 17:54:57 echo "Command 3" 1006 25-04-2016 17:54:59 echo "Command 4" 1007 25-04-2016 17:55:01 echo "Command 5" 1008 25-04-2016 17:55:03 echo "Command 6" 1009 25-04-2016 17:55:07 echo "Command 7" 1010 25-04-2016 17:55:09 echo "Command 8" 1011 25-04-2016 17:55:11 echo "Command 9" 1012 25-04-2016 17:55:14 echo "Command 10"
for h in $(seq 1006 1008 | tac); do history -d $h; done
for h in $(seq 1006 1008 | tac); do history -d $h; done; history -d $(history 1 | awk
histdel(){ for h in $(seq $1 $2 | tac); do history -d $h done history -d $(history 1 | awk }
[18:21:02 jonathag@gb-slo-svb-0221 ~]$ history 11 1046 25-04-2016 18:20:47 echo "Command 1" 1047 25-04-2016 18:20:48 echo "Command 2" 1048 25-04-2016 18:20:50 echo "Command 3" 1049 25-04-2016 18:20:51 echo "Command 4" 1050 25-04-2016 18:20:53 echo "Command 5" 1051 25-04-2016 18:20:54 echo "Command 6" 1052 25-04-2016 18:20:56 echo "Command 7" 1053 25-04-2016 18:20:57 echo "Command 8" 1054 25-04-2016 18:21:00 echo "Command 9" 1055 25-04-2016 18:21:02 echo "Command 10" 1056 25-04-2016 18:21:07 history 11 [18:21:07 jonathag@gb-slo-svb-0221 ~]$ histdel 1049 1051 [18:21:23 jonathag@gb-slo-svb-0221 ~]$ history 8 1046 25-04-2016 18:20:47 echo "Command 1" 1047 25-04-2016 18:20:48 echo "Command 2" 1048 25-04-2016 18:20:50 echo "Command 3" 1049 25-04-2016 18:20:56 echo "Command 7" 1050 25-04-2016 18:20:57 echo "Command 8" 1051 25-04-2016 18:21:00 echo "Command 9" 1052 25-04-2016 18:21:02 echo "Command 10" 1053 25-04-2016 18:21:07 history 11
histdeln(){ n=$(history 1 | awk histdel $(( $n - $1 )) $(( $n - 1 )) }
$ for line in $(seq 1800 1815) ; do history -d 1800; done
$ for line in $(seq 1800 1816) ; do history -d 1800; done
HISTFILE=~/.bash_history set -o history for i in `seq $1 $2`; do history -d $i done history -w
pos=$HISTCMD; start=$(( $pos-11 )); end=$(( $pos-1 )); for i in $(eval echo "{${start}..${end}}"); do history -d $start; done
delHistory () { count=$(( ${2:-$1} - $1 )) while [[ $count -ge 0 ]] ; do history -d "$start" ((count--)) done } delHistory 511 520
kill_hist() { for i in $(echo $@ | sed -e do history -d $i; done } kill_hist `seq 511 520` kill_hist `seq 1001 1010` `seq 1200 1201`
for i in {511..520}; do history -d $i; echo "history -d $i"; done
find -mindepth 1 -maxdepth 1 -print0 | xargs -0 rm -rf
unset EGGS echo 1 ${EGGS-spam} echo 2 ${EGGS:-spam} EGGS= echo 3 ${EGGS-spam} echo 4 ${EGGS:-spam} EGGS=cheese echo 5 ${EGGS-spam} echo 6 ${EGGS:-spam}
unset EGGS : ${EGGS=spam} echo 1 $EGGS unset EGGS : ${EGGS:=spam} echo 2 $EGGS EGGS= : ${EGGS=spam} echo 3 $EGGS EGGS= : ${EGGS:=spam} echo 4 $EGGS EGGS=cheese : ${EGGS:=spam} echo 5 $EGGS EGGS=cheese : ${EGGS=spam} echo 6 $EGGS
unset EGGS echo 1 ${EGGS+spam} echo 2 ${EGGS:+spam} EGGS= echo 3 ${EGGS+spam} echo 4 ${EGGS:+spam} EGGS=cheese echo 5 ${EGGS+spam} echo 6 ${EGGS:+spam}
$ cat defvar.sh WITH_PERL=${WITH_PERL:-no} if [[ "$WITH_PERL" != no ]]; then echo "building with perl" else echo "not building with perl" fi
$ foo () { /path/to/bar "$@" fixed args; } $ foo abc 123
function __t2d { if [ "$1x" != date -d "@$1" fi } alias t2d=
function __GetIt { cp ./path/to/stuff/$* . } alias GetIt=
$ grep This file.txt Every line containing "This" Every line containing "This" Every line containing "This" Every line containing "This" $ cat file.txt Every line containing "This" Every line containing "This" Every line containing "That" Every line containing "This" Every line containing "This"
preventSubshell(){ if [[ $_ != $0 ]] then echo "Script is being sourced" else echo "Script is a subshell - please run the script by invoking . script.sh command"; exit 1; fi }
set -- 1 2 3 4 5 exec bash --login -c ' echo $0 echo $@ echo my script continues here
$ echo Nothing \t in here $will change $ grep -F file:I can
$ echo "There is no place like There is no place like
$ words="foo bar baz" $ for word in $words; do > echo "$word" > done foo bar baz
$ for word in "$words"; do echo "$word"; done foo bar baz
$ ls "$pattern" ls: cannot access file*.txt: No such file or directory
$ ls ls: cannot access $pattern: No such file or directory
$ wget http: [1] wget http: -bash: uack: command not found
$ printf file1.txt file_other.txt $ for file in $pattern; do > printf > done Found file: file1.txt Found file: file_other.txt
lines="`cat multi-lines-text-file.txt`" echo "$lines" echo $lines
$ a= $ b=${a%:*} $ echo "$b" hello $ a= $ echo "${a%:*}" hello:world:of $ echo "${a%%:*}" hello $ echo "${a world:of:tomorrow $ echo "${a tomorrow
$ echo "/dirA/dirB/dirC/filename.file" | cut -f1-4 -d"/"
$ echo "/dirA/dirB/dirC/filename.file" | cut -f1-3 -d"/"
$ echo "/dirA/dirB/dirC/filename.file" | cut -f2-4 -d"/"
WFY_PATH=/var/log/nginx WFY_FILE=error.log COUNTER=0 grep ( while read WFY_URL do echo $WFY_URL COUNTER=$((COUNTER+1)) done ) echo $COUNTER
TEMPFILE=/tmp/$$.tmp echo 0 > $TEMPFILE COUNTER=$[$(cat $TEMPFILE) + 1] echo $COUNTER > $TEMPFILE unlink $TEMPFILE
COUNTER=1 while [ Your != "done" ] do echo " $COUNTER " COUNTER=$[$COUNTER +1] done
awk ' /GET \/log_/ && /upstream timed out/ { split($0, a, ", ") split(a[2] FS a[4] FS $0, b) print "http: } while read WFY_URL do echo $WFY_URL (( COUNTER++ )) done echo $COUNTER }
$ i=0 $ echo $i 0 $ echo $((i++)) 0 $ echo $i 1 $ echo $((++i)) 2 $ echo $i 2
find . -not -type d -exec file "{}" ";" | grep CRLF
./1/dos1.txt: ASCII text, with CRLF line terminators ./2/dos2.txt: ASCII text, with CRLF line terminators ./dos.txt: ASCII text, with CRLF line terminators
cr="$(printf "\r")" grep -Ilsr "${cr}$" . grep -Ilsr $
$ for file in `find . -type f` ; do > dump $file | cut -c9-50 | egrep -m1 -q > if [ $? -eq 0 ] ; then echo $file ; fi > done
$ file myfile myfile: ISO-8859 text, with CRLF line terminators $ file myfile | grep -ow CRLF CRLF
exec 3>&2 2> >(tee /tmp/sample-time.$$.log | sed -u date -f - +%s.%N >/tmp/sample-time.$$.tim) set -x
for i in {1..4};do echo now;sleep .05;done| date -f - +%N
exec 3>&2 2> >( tee /tmp/sample-$$.log | sed -u date -f - +%s.%N >/tmp/sample-$$.tim) set -x for ((i=3;i--;));do sleep .1;done for ((i=2;i--;)) do tar -cf /tmp/test.tar -C / bin gzip /tmp/test.tar rm /tmp/test.tar.gz done set +x exec 2>&3 3>&-
paste <( while read tim ;do crt=000000000$((${tim printf "%12.9f\n" ${crt:0:${ last=${tim done < sample-time.24804.tim ) sample-time.24804.log 1388487534.391309713 + (( i=3 )) 0.000080807 + (( i-- )) 0.000008312 + sleep .1 0.101304843 + (( 1 )) 0.000032616 + (( i-- )) 0.000007124 + sleep .1 0.101251684 + (( 1 )) 0.000033036 + (( i-- )) 0.000007054 + sleep .1 0.104013813 + (( 1 )) 0.000026959 + (( i-- )) 0.000006915 + (( i=2 )) 0.000006635 + (( i-- )) 0.000006844 + tar -cf /tmp/test.tar -C / bin 0.022655107 + gzip /tmp/test.tar 0.637042668 + rm /tmp/test.tar.gz 0.000823649 + (( 1 )) 0.000011314 + (( i-- )) 0.000006915 + tar -cf /tmp/test.tar -C / bin 0.016084482 + gzip /tmp/test.tar 0.627798263 + rm /tmp/test.tar.gz 0.001294946 + (( 1 )) 0.000023187 + (( i-- )) 0.000006845 + set +x
paste <( while read tim ;do [ -z "$last" ] && last=${tim crt=000000000$((${tim ctot=000000000$((${tim printf "%12.9f %12.9f\n" ${crt:0:${ ${ctot:0:${ last=${tim done < sample-time.24804.tim ) sample-time.24804.log
0.000000000 0.000000000 + (( i=3 )) 0.000080807 0.000080807 + (( i-- )) 0.000008312 0.000089119 + sleep .1 0.101304843 0.101393962 + (( 1 )) 0.000032616 0.101426578 + (( i-- )) 0.000007124 0.101433702 + sleep .1 0.101251684 0.202685386 + (( 1 )) 0.000033036 0.202718422 + (( i-- )) 0.000007054 0.202725476 + sleep .1 0.104013813 0.306739289 + (( 1 )) 0.000026959 0.306766248 + (( i-- )) 0.000006915 0.306773163 + (( i=2 )) 0.000006635 0.306779798 + (( i-- )) 0.000006844 0.306786642 + tar -cf /tmp/test.tar -C / bin 0.022655107 0.329441749 + gzip /tmp/test.tar 0.637042668 0.966484417 + rm /tmp/test.tar.gz 0.000823649 0.967308066 + (( 1 )) 0.000011314 0.967319380 + (( i-- )) 0.000006915 0.967326295 + tar -cf /tmp/test.tar -C / bin 0.016084482 0.983410777 + gzip /tmp/test.tar 0.627798263 1.611209040 + rm /tmp/test.tar.gz 0.001294946 1.612503986 + (( 1 )) 0.000023187 1.612527173 + (( i-- )) 0.000006845 1.612534018 + set +x
grep now at 5461935212966259 nsecs .offset: 0 nsecs .offset: 1383718821564493249 nsecs .offset: 0 nsecs
. elap.bash-v2 trap for ((i=3;i--;));do sleep .1;done elapCalc2 elapShowTotal \\e[1mfirst total\\e[0m for ((i=2;i--;)) do tar -cf /tmp/test.tar -C / bin gzip /tmp/test.tar rm /tmp/test.tar.gz done trap -- debug elapTotal \\e[1mtotal time\\e[0m
0.000947481 Starting 0.000796900 ((i=3)) 0.000696956 ((i--)) 0.101969242 sleep .1 0.000812478 ((1)) 0.000755067 ((i--)) 0.103693305 sleep .1 0.000730482 ((1)) 0.000660360 ((i--)) 0.103565001 sleep .1 0.000719516 ((1)) 0.000671325 ((i--)) 0.000754856 elapCalc2 0.316018113 first total 0.000754787 elapShowTotal \e[1mfirst total\e[0m 0.000711275 ((i=2)) 0.000683408 ((i--)) 0.075673816 tar -cf /tmp/test.tar -C / bin 0.596389329 gzip /tmp/test.tar 0.006565188 rm /tmp/test.tar.gz 0.000830217 ((1)) 0.000759466 ((i--)) 0.024783966 tar -cf /tmp/test.tar -C / bin 0.604119903 gzip /tmp/test.tar 0.005172940 rm /tmp/test.tar.gz 0.000952299 ((1)) 0.000827421 ((i--)) 1.635788924 total time 1.636657204 EXIT
0.000894541 0.000894541 Starting 0.001306122 0.002200663 ((i=3)) 0.001929397 0.004130060 ((i--)) 0.103035812 0.107165872 sleep .1 0.000875613 0.108041485 ((1)) 0.000813872 0.108855357 ((i--)) 0.104954517 0.213809874 sleep .1 0.000900617 0.214710491 ((1)) 0.000842159 0.215552650 ((i--)) 0.104846890 0.320399540 sleep .1 0.000899082 0.321298622 ((1)) 0.000811708 0.322110330 ((i--)) 0.000879455 0.322989785 elapCalc2 0.322989785 first total 0.000906692 0.323896477 elapShowTotal \e[1mfirst total\e[0m 0.000820089 0.324716566 ((i=2)) 0.000773782 0.325490348 ((i--)) 0.024752613 0.350242961 tar -cf /tmp/test.tar -C / bin 0.596199363 0.946442324 gzip /tmp/test.tar 0.003007128 0.949449452 rm /tmp/test.tar.gz 0.000791452 0.950240904 ((1)) 0.000779371 0.951020275 ((i--)) 0.030519702 0.981539977 tar -cf /tmp/test.tar -C / bin 0.584155405 1.565695382 gzip /tmp/test.tar 0.003058674 1.568754056 rm /tmp/test.tar.gz 0.000955093 1.569709149 ((1)) 0.000919964 1.570629113 ((i--)) 1.571516599 total time 0.001723708 1.572352821 EXIT
strace -q -f -s 10 -ttt sample-script 2>sample-script-strace.log
wc sample-script-strace.log 6925 57637 586518 sample-script-strace.log
strace -f -s 10 -ttt -eopen,access,read,write ./sample-script 2>sample-script-strace.log
strace -f -s 10 -ttt -eaccess,open ./sample-script 2>&1 | wc 189 1451 13682
{ read -a first first=${first last=$first while read tim line;do crt=000000000$((${tim ctot=000000000$((${tim printf "%9.6f %9.6f %s\n" ${crt:0:${ ${ctot:0:${ last=${tim done } < <( sed </tmp/sample-script.strace -e ' s/^ * s/^\[[^]]*\] * /^[0-9]\{4\}/!d 0.000110 0.000110 open("/lib/x86_64-linux-gnu/libtinfo.so.5", O_RDONLY) = 4 0.000132 0.000242 open("/lib/x86_64-linux-gnu/libdl.so.2", O_RDONLY) = 4 0.000121 0.000363 open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY) = 4 0.000462 0.000825 open("/dev/tty", O_RDWR|O_NONBLOCK) = 4 0.000147 0.000972 open("/usr/lib/locale/locale-archive", O_RDONLY) = 4 ... 0.000793 1.551331 open("/etc/ld.so.cache", O_RDONLY) = 4 0.000127 1.551458 open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY) = 4 0.000545 1.552003 open("/usr/lib/locale/locale-archive", O_RDONLY) = 4 0.000439 1.552442 --- SIGCHLD (Child exited) @ 0 (0) ---
script -t script.log 2>script.tim -c for ((i=3;i--;));do sleep .1;done for ((i=2;i--;)) ;do tar -cf /tmp/test.tar -C / bin gzip /tmp/test.tar rm /tmp/test.tar.gz done "'
Script started on Fri Mar 25 08:29:37 2016 + (( i=3 )) + (( i-- )) + sleep .1 + (( 1 )) + (( i-- )) + sleep .1 + (( 1 )) + (( i-- )) + sleep .1 + (( 1 )) + (( i-- )) + (( i=2 )) + (( i-- )) + tar -cf /tmp/test.tar -C / bin + gzip /tmp/test.tar + rm /tmp/test.tar.gz + (( 1 )) + (( i-- )) + tar -cf /tmp/test.tar -C / bin + gzip /tmp/test.tar + rm /tmp/test.tar.gz + (( 1 )) + (( i-- )) Script done on Fri Mar 25 08:29:39 2016
ls -l script.* -rw-r--r-- 1 user user 450 Mar 25 08:29 script.log -rw-r--r-- 1 user user 177 Mar 25 08:29 script.tim
head -n 4 script.* ==> script.log <== Script started on Fri Mar 25 08:29:37 2016 + (( i=3 )) + (( i-- )) + sleep .1 ==> script.tim <== 0.435331 11 0.000033 2 0.000024 11 0.000010 2
head -n1 script.log ;tail -n1 script.log Script started on Fri Mar 25 08:29:37 2016 Script done on Fri Mar 25 08:29:39 2016 sed < script.tim 2.249755
exec 4<script.log read -u 4 line echo $line ;while read tim char;do read -u 4 -N $char -r -s line echo $tim $line done < script.tim && while read -u 4 line;do echo $line done;exec 4<&- Script started on Fri Mar 25 08:28:51 2016 0.558012 + (( i=3 )) 0.000053 0.000176 + (( i-- )) 0.000015 0.000059 + sleep .1 0.000015 + sleep .1) + (( 1 )) + sleep .1) + (( 1 )) + tar -cf /tmp/test.tar -C / bin 0.035024 + gzip /tmp/test.tar 0.793846 + rm /tmp/test.tar.gz + tar -cf /tmp/test.tar -C / bin 0.024971 + gzip /tmp/test.tar 0.729062 + rm /tmp/test.tar.gz + (( i-- )) + (( 1 )) Script done on Fri Mar 25 08:28:53 2016
source elap.bash-v2 trap2 eval "BUNCHS=(" $(perl <<EOF | gunzip ...
PS4= exec 3>&2 2>/tmp/bashstart.$$.log set -x eval "BUNCHS=(" $(perl <<EOF | gunzip ...
exec 3>&2 2> >(tee /tmp/sample-time.$$.log | sed -u date -f - +%s.%N >/tmp/sample-time.$$.tim) set -x eval "BUNCHS=(" $(perl <<EOF | gunzip
script -t helloworld.log 2>helloworld.tim -c ' bash -x complex_helloworld-2.sh
0.000950277 0.000950277 Starting 0.007618964 0.008569241 eval "BUNCHS=(" $(perl <<EOF | gunzi 0.005259953 0.013829194 BUNCHS=("2411 1115 -13 15 33 -3 15 1 0.010945070 0.024774264 MKey="V922/G/,2:" 0.001050990 0.025825254 export RotString="" 0.004724348 0.030549602 initRotString 0.001322184 0.031871786 for bunch in "${BUNCHS[@]}" 0.000768893 0.032640679 out="" 0.001008242 0.033648921 bunchArray=($bunch) 0.000741095 0.034390016 ((k=0))
++ 1388598366.536099290 perl ++ 1388598366.536169132 gunzip + 1388598366.552794757 eval ++ 1388598366.555001983 BUNCHS=("2411 1115 -13 15 33 -3 15 13111 -6 1 + 1388598366.557551018 MKey=V922/G/,2: + 1388598366.558316839 export RotString= + 1388598366.559083848 RotString= + 1388598366.560165147 initRotString + 1388598366.560942633 local _i _char + 1388598366.561706988 RotString=
0.000000000 0.000000000 ++ perl 0.008141159 0.008141159 ++ gunzip 0.000007822 0.008148981 + eval 0.000006216 0.008155197 ++ BUNCHS=("2411 1115 -13 15 33 -3 15 13111 0.000006216 0.008161413 + MKey=V922/G/,2: 0.000006076 0.008167489 + export RotString= 0.000006007 0.008173496 + RotString= 0.000006006 0.008179502 + initRotString 0.000005937 0.008185439 + local _i _char 0.000006006 0.008191445 + RotString=
0.000213 0.000213 brk(0) = 0x17b6000 0.000044 0.000257 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory) 0.000047 0.000304 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7faf1c0dc000 0.000040 0.000344 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory) 0.000040 0.000384 open("/etc/ld.so.cache", O_RDONLY) = 4 ... 0.000024 4.425049 close(10) = 0 0.000042 4.425091 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0 0.000028 4.425119 read(255, "", 4409) = 0 0.000058 4.425177 exit_group(0) = ?
Le script a débuté sur ven 25 mar 2016 09:18:35 CET 0.667160 ++ gunzip 0.000025 0.000948 ++ perl 0.000011 0.005338 + eval 0.000044 1223 15 3311 121121 17 3311 121121 1223 3311 121121 17 3311 121 0.000175 ++ BUNCHS=("2411 1115 -13 15 33 -3 15 13111 -6 15 1114 15 12211 0.000029 1 1321 12211 412 21211 33 21211 -2 15 2311 11121 232 121111 122 0.000023 4 3311 121121 12221 3311 121121 12221 3311 121121 1313 -6 15 33
dtrace:::BEGIN { depth = 0; printf("%s %-20s %-22s %s %s\n", "C", "TIME", "FILE", "DELTA(us)", "NAME"); } sh*:::function-entry { depth++; printf("%d %-20Y %-22s %*s-> %s\n", cpu, walltimestamp, basename(copyinstr(arg0)), depth*2, "", copyinstr(arg1)); } sh*:::function-return { printf("%d %-20Y %-22s %*s<- %s\n", cpu, walltimestamp, basename(copyinstr(arg0)), depth*2, "", copyinstr(arg1)); depth--; } sh*:::builtin-entry { printf("%d %-20Y %-22s %*s > %s\n", cpu, walltimestamp, basename(copyinstr(arg0)), depth*2, "", copyinstr(arg1)); } sh*:::command-entry { printf("%d %-20Y %-22s %*s | %s\n", cpu, walltimestamp, basename(copyinstr(arg0)), depth*2, "", copyinstr(arg1)); }
C TIME FILE DELTA(us) -- NAME 0 2007 Aug 10 18:52:51 func_abc.sh 0 -> func_a 0 2007 Aug 10 18:52:51 func_abc.sh 54 > echo 0 2007 Aug 10 18:52:52 func_abc.sh 1022880 | sleep 0 2007 Aug 10 18:52:52 func_abc.sh 34 -> func_b 0 2007 Aug 10 18:52:52 func_abc.sh 44 > echo 0 2007 Aug 10 18:52:53 func_abc.sh 1029963 | sleep 0 2007 Aug 10 18:52:53 func_abc.sh 44 -> func_c 0 2007 Aug 10 18:52:53 func_abc.sh 43 > echo 0 2007 Aug 10 18:52:54 func_abc.sh 1029863 | sleep 0 2007 Aug 10 18:52:54 func_abc.sh 33 <- func_c 0 2007 Aug 10 18:52:54 func_abc.sh 14 <- func_b 0 2007 Aug 10 18:52:54 func_abc.sh 7 <- func_a
echo "hello awk world" | awk echo "hello awk world" | awk
declare -a sorted while read line; do if [ -z "${sorted[${ sorted[${ else sorted[${ fi done < data.csv for key in ${!sorted[*]}; do echo -e "${sorted[$key]}" done
for item in $list do if [ "$x" == "$item" ]; then echo "In the list" exit fi done
[[ $list =~ (^|[[:space:]])$x($|[[:space:]]) ]] && echo
contains() { [[ $1 =~ (^|[[:space:]])$2($|[[:space:]]) ]] && exit(0) || exit(1) }
[[ $list =~ (^|[[:space:]])"$x"($|[[:space:]]) ]] && echo
function list_include_item { local list="$1" local item="$2" if [[ $list =~ (^|[[:space:]])"$item"($|[[:space:]]) ]] ; then result=0 else result=1 fi return $result }
`list_include_item "10 11 12" "12"` && echo "yes" || echo "no"
if `list_include_item "10 11 12" "1"` ; then echo "yes" else echo "no" fi
`list_include_item "$my_list" "$my_item"` && echo "yes" || echo "no"
haystack= needle= if [[ " $haystack " =~ .*\ $needle\ .* ]]; then ... fi
LIST="ITEM1 ITEM2" VALUE="ITEM1" if [ -n "`echo $LIST | xargs -n1 echo | grep -e \"^$VALUE`$\" ]; then ... fi
LIST="ITEM1:ITEM2" VALUE="ITEM1" if [ -n "`echo $LIST | sed ... fi
validate() { grep -F -q -x "$1" <<EOF item 1 item 2 item 3 EOF }
validate() { echo "11 22 33" | grep -F -q -w "$1"; }
for x in "item 1" "item2" "item 3" "3" "*"; do echo -n " validate "$x" && echo "valid" || echo "invalid" done
for item in $list do case "$x" in item1|item2) echo "In the list" ;; not_an_item) echo "Error" >&2 exit 1 ;; esac done
declare -A list=( [one]=1 [two]=two [three]= for value in one two three four do echo -n "$value is " [[ -z "${list[$value]}" ]] && echo -n echo "a member of ( ${!list[*]} )" done
one is a member of ( one two three ) two is a member of ( one two three ) three is a member of ( one two three ) four is *not* a member of ( one two three )
$ in_list super test me out NO $ in_list "super dude" test me out NO $ in_list "super dude" test me "super dude" YES if [ $(in_list $1 OPTION1 OPTION2) == "NO" ] then echo "UNKNOWN type for param 1: Should be OPTION1 or OPTION2" exit; fi
function show_help() { IT=$(CAT <<EOF usage: SEARCH_FOR {ITEM1} {ITEM2} {ITEM3} ... e.g. a b c d -> NO a b a d -> YES "test me" how "test me" -> YES ) echo "$IT" exit } if [ "$1" == "help" ] then show_help fi if [ "$ show_help fi SEARCH_FOR=$1 shift; for ITEM in "$@" do if [ "$SEARCH_FOR" == "$ITEM" ] then echo "YES" exit; fi done echo "NO"
if [ $( echo "${TARGET}" | egrep -c "^(binomial|regression)$" ) -eq 0 ]; then echo "This scoring program can only handle usage fi
elementIn () { local e for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done return 1 } list=(11 22 33) item=22 if elementIn "$item" "${list[@]}"; then echo TRUE; else echo FALSE fi item=44 elementIn $item "${list[@]}" && echo TRUE || echo FALSE
OK=0 ; MP_FLAVOURS="vanilla lemon hazelnut straciatella" for FLAV in $MP_FLAVOURS ; do [ $FLAV == $FLAVOR ] && { OK=1 ; break; } ; done [ $OK -eq 0 ] && { echo "$FLAVOR not a valid value ($MP_FLAVOURS)" ; exit 1 ; }
root@ip-10-126-247-82:~ Disk /dev/xvda1: 10.7 GB, 10737418240 bytes 255 heads, 63 sectors/track, 1305 cylinders, total 20971520 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x00000000 Disk /dev/xvda1 doesn Disk /dev/xvda2: 365.0 GB, 365041287168 bytes 255 heads, 63 sectors/track, 44380 cylinders, total 712971264 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x00000000 Disk /dev/xvda2 doesn Disk /dev/xvda3: 939 MB, 939524096 bytes 255 heads, 63 sectors/track, 114 cylinders, total 1835008 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x00000000 Disk /dev/xvda3 doesn
root@ip-10-126-247-82:~ /dev/xvda1 on / type ext4 (rw) proc on /proc type proc (rw,noexec,nosuid,nodev) sysfs on /sys type sysfs (rw,noexec,nosuid,nodev) fusectl on /sys/fs/fuse/connections type fusectl (rw) none on /sys/kernel/debug type debugfs (rw) none on /sys/kernel/security type securityfs (rw) udev on /dev type devtmpfs (rw,mode=0755) devpts on /dev/pts type devpts (rw,noexec,nosuid,gid=5,mode=0620) tmpfs on /run type tmpfs (rw,noexec,nosuid,size=10%,mode=0755) none on /run/lock type tmpfs (rw,noexec,nosuid,nodev,size=5242880) none on /run/shm type tmpfs (rw,nosuid,nodev) /dev/xvda2 on /mnt type ext3 (rw)
root@ip-10-126-247-82:~ major minor 202 1 10485760 xvda1 202 2 356485632 xvda2 202 3 917504 xvda3
grep sdl /proc/partitions 8 176 15632384 sdl 8 177 15628288 sdl1 lsblk | grep sdl sdl 8:176 1 14.9G 0 disk `-sdl1 8:177 1 14.9G 0 part
fdisk -l /dev/sdk Disk /dev/sdk: 15.9 GB, 15931539456 bytes 255 heads, 63 sectors/track, 1936 cylinders, total 31116288 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0xbe24be24 Device Boot Start End Blocks Id System /dev/sdk1 * 8192 31116287 15554048 c W95 FAT32 (LBA)
file -s /dev/sdl1 /dev/sdl1: sticky x86 boot sector, code offset 0x52, OEM-ID "NTFS ", sectors/cluster 8, reserved sectors 0, Media descriptor 0xf8, heads 255, hidden sectors 8192, dos < 4.0 BootSector (0x0)
fdisk -l /dev/sdb /dev/sdb1 2048 156301487 78149720 fd Linux raid autodetect /dev/sdb2 156301488 160086527 1892520 82 Linux swap / Solaris file -s /dev/sdb1 /dev/sdb1: sticky \0
parted /dev/sdl print Model: Mass Storage Device (scsi) Disk /dev/sdl: 16.0GB Sector size (logical/physical): 512B/512B Partition Table: msdos Number Start End Size Type File system Flags 1 4194kB 16.0GB 16.0GB primary ntfs arted /dev/sdb print Model: ATA Maxtor 6Y080P0 (scsi) Disk /dev/sdb: 82.0GB Sector size (logical/physical): 512B/512B Partition Table: msdos Number Start End Size Type File system Flags 1 1049kB 80.0GB 80.0GB primary raid 2 80.0GB 82.0GB 1938MB primary linux-swap(v1)
hal-find-by-property --key volume.fsusage --string filesystem | while read udi ; do if [[ "$(hal-get-property --udi $udi --key volume.is_disc)" == "false" ]]; then dev=$(hal-get-property --udi $udi --key block.device) fs=$(hal-get-property --udi $udi --key volume.fstype) echo $dev": "$fs fi done
/bin/bash --version GNU bash, version 4.0.33(1)-release (x86_64-pc-linux-gnu)
/bin/bash --version GNU bash, version 3.2.39(1)-release (x86_64-suse-linux-gnu) Copyright (C) 2007 Free Software Foundation, Inc.
RUN ["/bin/bash", "-c", "bash < <(curl -s -S -L https:
text="tested like a charm" nc -l -p 80 <<EOF $text EOF
kasra@ubuntu:~$ docker run --rm -it busybox / sh: syntax error: unexpected redirection / > tested like a charm > EOL ^Cpunt! => socket listening, no errors. ^Cpunt! is result of CTRL+C signal. / / > $text > EOF ^Cpunt!
mongodump --db=$DB_NAME --collection=$col --out=$BACKUP_LOCATION/$DB_NAME-$BACKUP_DATE >> >> $LOG_PATH
mongodump --db=$DB_NAME --collection=$col --out=$BACKUP_LOCATION/$DB_NAME-$BACKUP_DATE >> $LOG_PATH
pipe_sequence : command | pipe_sequence newline_list : NEWLINE | newline_list NEWLINE ; linebreak : newline_list |
cat <<EOF1 <<EOF2 first here-doc EOF1 second here-doc EOF2
$ bash --posix $ cat <<EOF | > ahoj > nazdar > EOF > sed bhoj nbzdar
su $USERNAME; cd /home/$USERNAME/$PROJECT; svn update;
sudo -u username2 -H sh -c "cd /home/$USERNAME/$PROJECT; svn update"
whoami sudo -u someuser bash << EOF echo "In" whoami EOF echo "Out" whoami
id exec sudo -u transmission /bin/sh - << eof id eof
su -c "cd /home/$USERNAME/$PROJECT ; svn update" -m "$USERNAME"
if [ $UID -eq 0 ]; then user=$1 dir=$2 shift 2 cd "$dir" exec su "$user" "$0" -- "$@" fi echo "This will be run from user $UID" ...
sudo -u $USERNAME -H sh -c "cd ~/$PROJECT; svn update"
sudo -u $USERNAME -H cd ~/$PROJECT sudo -u $USERNAME svn update
$user = shift; if (!$<) { $> = getpwnam $user; $) = getgrnam $user; } else { die } system(
config.vm.provision :shell, path: "provision.sh" config.vm.provision :shell, path: "start_env.sh", run: "always"
echo "Starting Server Env" cd /vagrant_projects/myproj nohup grunt connect:server:keepalive 0<&- &>/dev/null & nohup apimocker -c /vagrant_projects/myproj/mock_api_data/config.json 0<&- &>/dev/null &
USERNAME= COMMAND=$0 COMMANDARGS="$(printf " %q" "${@}")" if [ $(whoami) != "$USERNAME" ]; then exec sudo -E su $USERNAME -c "/usr/bin/bash -l $COMMAND $COMMANDARGS" exit fi
echo "Please enter your username"; read username; echo "Please enter your password"; read password;
unset password; while IFS= read -r -s -n1 pass; do if [[ -z $pass ]]; then echo break else echo -n password+=$pass fi done
echo "Please enter your username"; read username; echo "Please enter your password"; stty -echo read password; stty echo
stty_orig=`stty -g` stty -echo read password stty $stty_orig
password= while IFS= read -r -s -n1 char; do [[ -z $char ]] && { printf if [[ $char == $ [[ -n $password ]] && password=${password%?} printf else password+=$char printf fi done
password= while IFS= read -r -s -n1 pass; do if [ -z "$pass" ]; then echo break else printf password="$password$pass" fi done
echo -e "Enter your password: \x1B[8m" echo -e "\x1B[0m"
printf "password: " let pass $(read -s) printf "\nhey everyone, the password the user just entered is $pass\n"
clear echo echo echo counter=0 unset username prompt=" Enter Username:" while IFS= read -p "$prompt" -r -s -n 1 char do if [[ $char == $ break elif [ $char == $ prompt=$ username="${username%?}" counter=$((counter-1)) elif [ $char == $ prompt= continue else counter=$((counter+1)) prompt="$char" username+="$char" fi done echo unset password prompt=" Enter Password:" while IFS= read -p "$prompt" -r -s -n 1 char do if [[ $char == $ break elif [ $char == $ prompt=$ password="${password%?}" counter=$((counter-1)) elif [ $char == $ echo prompt=" Enter Password:" continue else counter=$((counter+1)) prompt= password+="$char" fi done
expandPath() { local path local -a pathElements resultPathElements IFS= : "${pathElements[@]}" for path in "${pathElements[@]}"; do : "$path" case $path in "~+"/*) path=$PWD/${path ;; "~-"/*) path=$OLDPWD/${path ;; "~"/*) path=$HOME/${path ;; "~"*) username=${path%%/*} username=${username IFS=: read _ _ _ _ _ homedir _ < <(getent passwd "$username") if [[ $path = */* ]]; then path=${homedir}/${path else path=$homedir fi ;; esac resultPathElements+=( "$path" ) done local result printf -v result printf }
expandPath() { case $1 in ~[+-]*) local content content_q printf -v content_q eval "content=${1:0:2}${content_q}" printf ;; ~*) local content content_q printf -v content_q eval "content=~${content_q}" printf ;; *) printf ;; esac }
relativepath=a/b/c eval homedir="$(printf "~/%q" "$relativepath")" echo $homedir
mypath="$1" if [ -e "`eval echo ${mypath echo "FOUND $mypath" else echo "$mypath NOT FOUND" fi
magic() { local _safe_path; printf -v _safe_path "%q" "$1" eval "ln -sf ${_safe_path readlink /tmp/realpath.$$ rm -f /tmp/realpath.$$ }
$ magic ~nobody/would/look/here /var/empty/would/look/here $ magic ~invalid/this/will/not/expand ~invalid/this/will/not/expand
expandTilde() { local tilde_re= local path="$*" local pathSuffix= if [[ $path =~ $tilde_re ]] then path=$(eval echo ${BASH_REMATCH[1]}) pathSuffix=${BASH_REMATCH[2]} fi echo "${path}${pathSuffix}" } result=$(expandTilde "$1") echo "Result = $result"
case $1${1%%/*} in ([!~]*|"$1"?*[!-+_.[:alnum:]]*|"") ! :;; (*/*) set "${1%% }" ;; (*) set "$1" esac&& eval "printf
expand_tilde() { tilde_less="${1 [ "$1" != "$tilde_less" ] && tilde_less="$HOME/$tilde_less" printf }
mypath="~/a/b/c/Something With Spaces" expandedpath=${mypath eval expandedpath=${expandedpath} expandedpath=${expandedpath echo "$expandedpath" ls -lt "$expandedpath"
import sys import os print os.path.expanduser(sys.argv[1])
$ eval echo "~" /whatever/the/f/the/home/directory/is
$ $ s="echo SCARY COMMAND" $ eval echo $(eval echo "~") /Users/HackerSCARY COMMAND
set -e function cleanup { echo "Removing /tmp/foo" rm -r /tmp/foo } trap cleanup EXIT mkdir /tmp/foo asdffdsa
dbrown@luxury:~ $ sh traptest t: line 9: asdffdsa: command not found Removing /tmp/foo dbrown@luxury:~ $
if ps -ef | grep -v grep | grep doctype.php ; then exit 0 else /home/user/bin/doctype.php >> /home/user/bin/spooler.log & /home/user/bin/simplemail.php "Print spooler was not running... Restarted." exit 0 fi
/usr/bin/flock -n /tmp/my.lockfile /usr/local/bin/my_script
mkdir -p "$HOME/tmp" PIDFILE="$HOME/tmp/myprogram.pid" if [ -e "${PIDFILE}" ] && (ps -u $(whoami) -opid= | grep -P "^\s*$(cat ${PIDFILE})$" &> /dev/null); then echo "Already running." exit 99 fi /path/to/myprogram > $HOME/tmp/myprogram.log & echo $! > "${PIDFILE}" chmod 644 "${PIDFILE}"
*/20 * * * * * run-one python /script/to/run/awesome.py
* * * * * [ `ps -ef|grep -v grep|grep <command>` -eq 0 ] && <command>
LFILE=/tmp/one-`echo "$@" | md5sum | cut -d\ -f1`.pid if [ -e ${LFILE} ] && kill -0 `cat ${LFILE}`; then exit fi trap "rm -f ${LFILE}; exit" INT TERM EXIT echo $$ > ${LFILE} $@ rm -f ${LFILE}
PIDFILE="$HOME/tmp/myprogram.pid" if [ -e "${PIDFILE}" ] && (ps -p $(cat ${PIDFILE}) > /dev/null); then echo "Already running." exit 99 fi /path/to/myprogram
<?php $cmd = $argv[1]; $grep = "ps -ef | grep exec($grep,$out); if(count($out)<5){ $cmd .= exec($cmd,$out); print_r($out); } ?>
ALREADY_RUNNING_EXIT_STATUS=0 bn=`basename $0` proc=`ps -ef | grep -v grep | grep "$bn" | grep -v " $$ "` [ $? -eq 0 ] && { pid=`echo $proc | awk echo "$bn already running with pid $pid" exit $ALREADY_RUNNING_EXIT_STATUS }
function grep_search() { magic_way_to_define_magic_variable_$1=`ls | tail -1` echo $magic_variable_$1 }
$ ls | tail -1 stack-overflow.txt $ grep_search() open_box stack-overflow.txt
declare -A magic_variable=() function grep_search() { magic_variable[$1]=$( ls | tail -1 ) echo ${magic_variable[$1]} }
function grep_search() { declare magic_variable_$1="$(ls | tail -1)" echo "$(tmpvar=magic_variable_$1 && echo ${!tmpvar})" } grep_search var
foo_1=("fff" "ddd") ; foo_2=("ggg" "ccc") ; for i in 1 2 ; do eval mine=( \${foo_$i[@]} ) ; echo ${mine[@]} ; done ;
my_country_code="green" x="country" eval z= echo $z
foo=(a b c) bar=(d e f) for arr_var in declare -a echo "\$$arr_var contains:" for char in "${arr[@]}"; do echo "$char" done done
$ source script.sh $ grep_search open_box $ echo $open_box script.sh
function grep_search() { read "$1" <<<$(ls | tail -1); }
$ grep_search open_box $ echo $open_box stack-overflow.txt
get() { mapName=$1; key=$2 map=${!mapName} value="$(echo $map |sed -e "s/.*--${key}=\([^ ]*\).*/\1/" -e }
declare -A newmap newmap[name]="Irfan Zulfiqar" newmap[designation]=SSE newmap[company]="My Own Company" echo ${newmap[company]} echo ${newmap[name]}
ARRAY=( "cow:moo" "dinosaur:roar" "bird:chirp" "bash:rock" ) for animal in "${ARRAY[@]}" ; do KEY=${animal%%:*} VALUE=${animal printf "%s likes to %s.\n" "$KEY" "$VALUE" done echo -e "${ARRAY[1]%%:*} is an extinct animal which likes to ${ARRAY[1]
prefix=$(basename -- "$0") map=$(mktemp -dt ${prefix}) echo >${map}/key somevalue value=$(cat ${map}/key)
prefix=$(basename -- "$0") mapdir=$(mktemp -dt ${prefix}) trap put() { [ "$ mapname=$1; key=$2; value=$3 [ -d "${mapdir}/${mapname}" ] || mkdir "${mapdir}/${mapname}" echo $value >"${mapdir}/${mapname}/${key}" } get() { [ "$ mapname=$1; key=$2 cat "${mapdir}/${mapname}/${key}" } put "newMap" "name" "Irfan Zulfiqar" put "newMap" "designation" "SSE" put "newMap" "company" "My Own Company" value=$(get "newMap" "company") echo $value value=$(get "newMap" "name") echo $value
mapimpl=$1 numkeys=$2 numvals=$3 . ./${mapimpl}.sh for (( i = 0 ; $i < $numkeys ; i += 1 )) do for (( j = 0 ; $j < $numvals ; j += 1 )) do put "newMap" "key$i" "value$j" get "newMap" "key$i" done done
hput () { eval hash"$1"= } hget () { eval echo } hput France Paris hput Netherlands Amsterdam hput Spain Madrid echo `hget France` and `hget Netherlands` and `hget Spain`
# function map_put { alias "${1}$2"="$3" } # function map_get { alias "${1}$2" | awk -F" } # function map_keys { alias -p | grep $1 | cut -d }
mapName=$(basename $0)_map_ map_put $mapName "name" "Irfan Zulfiqar" map_put $mapName "designation" "SSE" for key in $(map_keys $mapName) do echo "$key = $(map_get $mapName $key) done
put() { if [ "$ mapName=$1; key=$2; value=`echo $3 | sed -e "s/ /:SP:/g"` eval map="\"\$$mapName\"" map="`echo "$map" | sed -e "s/--$key=[^ ]* eval $mapName="\"$map\"" } get() { mapName=$1; key=$2; valueFound="false" eval map=\$$mapName for keyValuePair in ${map}; do case "$keyValuePair" in --$key=*) value=`echo "$keyValuePair" | sed -e valueFound="true" esac if [ "$valueFound" == "true" ]; then break; fi done value=`echo $value | sed -e "s/:SP:/ /g"` } put "newMap" "name" "Irfan Zulfiqar" put "newMap" "designation" "SSE" put "newMap" "company" "My Own Company" get "newMap" "company" echo $value get "newMap" "name" echo $value
getKeySet() { if [ "$ then exit 1; fi mapName=$1; eval map="\"\$$mapName\"" keySet=` echo $map | sed -e "s/=[^ ]* ` }
Mary 100 John 200 Mary 50 John 300 Paul 100 Paul 400 David 100
while read -r person money; ((map_$person+=$money)); done < <(cat INCOME_REPORT.log)
map_David=100 map_John=500 map_Mary=150 map_Paul=500
shell_map () { local METHOD="$1" case $METHOD in new) local NEW_MAP="$2" test -n "$(declare -f shell_map)" || return eval "${_/shell_map/$2}" ;; put) local KEY="$2" local VALUE="$3" eval ${FUNCNAME}_DATA_${KEY}= ;; get) local KEY="$2" local VALUE="${FUNCNAME}_DATA_${KEY}" echo "${!VALUE}" ;; keys) declare | grep -Po "(?<=${FUNCNAME}_DATA_)\w+((?=\=))" ;; name) echo $FUNCNAME ;; contains_key) local KEY="$2" compgen -v ${FUNCNAME}_DATA_${KEY} > /dev/null && return 0 || return 1 ;; clear_all) while read var; do unset $var done < <(compgen -v ${FUNCNAME}_DATA_) ;; remove) local KEY="$2" unset ${FUNCNAME}_DATA_${KEY} ;; size) compgen -v ${FUNCNAME}_DATA_${KEY} | wc -l ;; *) echo "unsupported operation return 1 ;; esac }
shell_map new credit credit put Mary 100 credit put John 200 for customer in `credit keys`; do value=`credit get $customer` echo "customer $customer has $value" done credit contains_key "Mary" && echo "Mary has credit!"
shF_PATH_TO_LIB="/usr/lib/shell-framework" source "${shF_PATH_TO_LIB}/map" putMapValue "mapName" "mapKey1" "map Value 2" echo "mapName[mapKey1]: $(getMapValue "mapName" "mapKey1")" putMapValue "mapName" "mapKey1" "map Value 1" echo "after change mapName[mapKey1]: $(getMapValue "mapName" "mapKey1")" putMapValue "mapName" "mapKey2" "map Value 2" putMapValue "mapName" "mapKey3" "map Value 3" echo -e "mapName keys are \n$(getMapKeys "mapName")" putMapValue "subMapName" "subMapKey1" "sub map Value 1" putMapValue "subMapName" "subMapKey2" "sub map Value 2" putMapValue "mapName" "mapKey4" "subMapName" echo "is map mapName[mapKey3]? - $(if isMap "$(getMapValue "mapName" "mapKey3")" ; then echo Yes; else echo No; fi)" echo "is map mapName[mapKey4]? - $(if isMap "$(getMapValue "mapName" "mapKey4")" ; then echo Yes; else echo No; fi)" printf "%s\n" "$(mapToString "mapName")"
hash_index() { case $1 in esac } hash_vals=("foo_val" "bar_val" "baz_val"); hash_index "foo" echo ${hash_vals[$?]}
hash_index() { case $1 in esac } hash_vals=("", "foo_val" "bar_val" "baz_val"); hash_index "foo" || echo ${hash_vals[$?]}
hash_index() { case $1 in *) return 255;; esac } hash_vals=("foo_val" "bar_val" "baz_val"); hash_index "foo" [[ $? -ne 255 ]] && echo ${hash_vals[$?]}
hash_index() { case $1 in esac } hash_vals=("foo_val" "bar_val" "baz_val"); hash_index "foo" || echo ${hash_vals[$(($? - 1))]}
hinit() { rm -f /tmp/hashmap.$1 } hput() { echo "$2 $3" >> /tmp/hashmap.$1 } hget() { grep "^$2 " /tmp/hashmap.$1 | awk } hinit capitols hput capitols France Paris hput capitols Netherlands Amsterdam hput capitols Spain Madrid echo `hget capitols France` and `hget capitols Netherlands` and `hget capitols Spain`
ARRAY=( "item_A|attr1|attr2|attr3" "item_B|attr1|attr2|attr3" "..." )
for item in "${ARRAY[@]}" do item_name=$(echo "${item}"|awk -F "|" item_attr1=$(echo "${item}"|awk -F "|" item_attr2=$(echo "${item}"|awk -F "|" echo "${item_name}" echo "${item_attr1}" echo "${item_attr2}" done
export NAMES="{ \"Mary\":\"100\", \"John\":\"200\", \"Mary\":\"50\", \"John\":\"300\", \"Paul\":\"100\", \"Paul\":\"400\", \"David\":\"100\" }" export NAME=David echo $NAMES | jq --arg v "$NAME"
# function map_put { alias "${1}$2"="$3" } # function map_get { if type -p "${1}$2" then alias "${1}$2" | awk -F " fi } # function map_keys { alias -p | grep $1 | cut -d }
readonly connections=( ) function set_connections(){ local range proto port for fields in ${connections[@]} do IFS=$ ufw allow from "$range" proto "$proto" to any port "$port" done } set_connections
git push origin --delete <branch1> <branch2> <branch3>
cat your_file.txt | xargs -I {} git push origin :{}
1 - List all your remote branches: $ git branch -r 2 - Filter the branches by some regular expression. In this case I $ git branch -r | awk -F/ 3 - Pipe the last command to git push to delete them: $ git branch -r | awk -F/ 4 - Grab a beer. 5 - Remove any local reference to those branches: $ git remote prune origin
To github.com:project/project-name.git - [deleted] feature/search-min-chars To github.com:project/project-name.git - [deleted] feature/search-placeholder To github.com:project/project-name.git - [deleted] feature/server-error-message To github.com:project/project-name.git - [deleted] feature/six-point-asterisk
git push origin :feature/search-min-chars :feature/search-placeholder :feature/server-error-message :feature/six-point-asterisk
To github.com:project/project-name.git - [deleted] feature/search-min-chars - [deleted] feature/search-placeholder - [deleted] feature/server-error-message - [deleted] feature/six-point-asterisk
git branch -r | grep "origin/users/YOURNAME" | sed -r
WEBSITE=domain.com SUBJECT="$WEBSITE DOWN!" EMAILID="an@email.com" STATUS=$(curl -sI $WEBSITE | awk STRING=$(curl -s $WEBSITE | grep -o "string_to_search") VALUE="string_to_search" if [ $STATUS -ne 200 ] && [[ "$STRING" != "$VALUE" ]]; then echo "Website: $WEBSITE is down, status code: fi
if [ $STATUS -ne 200 ] -a [[ "$STRING" != "$VALUE" ]]
if ! [ "$STATUS" -eq 200 ] 2> /dev/null && [ "$STRING" != "$VALUE" ]; then
if [ "$STATUS" != 200 ] && [ "$STRING" != "$VALUE" ]; then
if [ $STATUS -ne 200 -a "$STRING" != "$VALUE" ]; then
for file in *_h.png do mv "$file" "${file/_h.png/_half.png}" done
for file in *.png; do mv "$file" "${file/_h.png/_half.png}"; done
$ mkdir /tmp/foo $ cd /tmp/foo $ touch one_h.png two_h.png three_h.png $ ls one_h.png three_h.png two_h.png
$ rename $ ls one_half.png three_half.png two_half.png
for f in *.png; do fnew=`echo $f | sed mv $f $fnew done
for file in *_h.png ; do mv "$file" "${file%%_h.png}_half.png" ; done
for file in 0{5..6}_h.png ; do mv "$file" "${file/_h./_half.}" ; done
$ touch 0{5..6}_h.png $ ls 05_h.png 06_h.png $ rename $ ls 05_half.png 06_half.png
rc@bvm3:/tmp/foo $ touch 05_h.png 06_h.png rc@bvm3:/tmp/foo $ rename rc@bvm3:/tmp/foo $ ls -l total 0 -rw-r--r-- 1 rc rc 0 2011-09-17 00:15 05_half.png -rw-r--r-- 1 rc rc 0 2011-09-17 00:15 06_half.png
$ date -d Tue Nov 18 00:53:03 GMT 2014 $ date -d Tue Nov 18 01:53:03 GMT 2014
/etc/profile ~/.bash_profile ~/.bash_login (if .bash_profile does not exist) ~/.profile (if .bash_login does not exist)
Directory/ a1.1_5_1 a1.2_1_4 b2.1_0 b2.2_3_4 b2.3_2_0
unset -v latest for file in "$dir"/*; do [[ $file -nt $latest ]] && latest=$file done
find . -name "my-pattern" ... -print0 | xargs -0 ls -1 -t | head -1
find . -name "my-pattern" ... -print0 | xargs -0 ls -1 -t
function newest_matching_file { local -r glob_pattern=${1-} if (( $ echo return 1 fi local -i need_to_unset_nullglob=0 if [[ ":$BASHOPTS:" != *:nullglob:* ]] ; then shopt -s nullglob need_to_unset_nullglob=1 fi newest_file= for file in $glob_pattern ; do [[ -z $newest_file || $file -nt $newest_file ]] \ && newest_file=$file done (( need_to_unset_nullglob )) && shopt -u nullglob [[ -n $newest_file ]] && printf return 0 }
perl -le sort {$a->[1] <=> $b->[1]} map {[$_, -M $_]} @ARGV; print $sorted[0]
$ stat -f "%m%t%N" b2* | sort -rn | head -1 | cut -f2-
if jarsigner -verbose -keystore $keyst -keystore $pass $jar_file $kalias then echo $jar_file signed sucessfully else echo ERROR: Failed to sign $jar_file. Please recheck the variables fi ...
if jarsigner -verbose -keystore $keyst -keystore $pass $jar_file $kalias then echo $jar_file signed sucessfully else echo ERROR: Failed to sign $jar_file. Please recheck the variables 1>&2 exit 1 fi ...
f () { errcode=$? echo "error $errorcode" echo "the command executing at the time of the error was" echo "$BASH_COMMAND" echo "on line ${BASH_LINENO[0]}" exit $errcode } trap f ERR false
abort() { echo >&2 ' *************** *** ABORTED *** *************** ' echo "An error occurred. Exiting..." >&2 exit 1 } trap set -e trap : 0 echo >&2 ' ************ *** DONE *** ************ '
X column1 column2 column3 row1 0 1 2 row2 3 4 5 row3 6 7 8 row4 9 10 11
X row1 row2 row3 row4 column1 0 3 6 9 column2 1 4 7 10 column3 2 5 8 11
cols=`head -n 1 input | wc -w` for (( i=1; i <= $cols; i++)) do cut -f $i input | tr $ done
awk ' { for (i=1; i<=NF; i++) { a[NR,i] = $i } } NF>p { p = NF } END { for(j=1; j<=p; j++) { str=a[1,j] for(i=2; i<=NR; i++){ str=str" "a[i,j]; } print str } }
$ more file 0 1 2 3 4 5 6 7 8 9 10 11 $ ./shell.sh 0 3 6 9 1 4 7 10 2 5 8 11
$ head -5 file 1 0 1 2 2 3 4 5 3 6 7 8 4 9 10 11 1 0 1 2 $ wc -l < file 10000 $ time perl test.pl file >/dev/null real 0m0.480s user 0m0.442s sys 0m0.026s $ time awk -f test.awk file >/dev/null real 0m0.382s user 0m0.367s sys 0m0.011s $ time perl test.pl file >/dev/null real 0m0.481s user 0m0.431s sys 0m0.022s $ time awk -f test.awk file >/dev/null real 0m0.390s user 0m0.370s sys 0m0.010s
$ cat tst.awk BEGIN { FS=OFS="\t" } { for (rowNr=1;rowNr<=NF;rowNr++) { cell[rowNr,NR] = $rowNr } maxRows = (NF > maxRows ? NF : maxRows) maxCols = NR } END { for (rowNr=1;rowNr<=maxRows;rowNr++) { for (colNr=1;colNr<=maxCols;colNr++) { printf "%s%s", cell[rowNr,colNr], (colNr < maxCols ? OFS : ORS) } } } $ awk -f tst.awk file X row1 row2 row3 row4 column1 0 3 6 9 column2 1 4 7 10 column3 2 5 8 11
$ cat tst.awk BEGIN { FS=OFS="\t" } { printf "%s%s", (FNR>1 ? OFS : ""), $ARGIND } ENDFILE { print "" if (ARGIND < NF) { ARGV[ARGC] = FILENAME ARGC++ } } $ awk -f tst.awk file X row1 row2 row3 row4 column1 0 3 6 9 column2 1 4 7 10 column3 2 5 8 11
import sys for c in zip(*(l.split() for l in sys.stdin.readlines() if l.strip())): print(
gcc transpose.c -o transpose ./transpose -t input > output
declare -a array=( ) read -a line < "$1" COLS=${ index=0 while read -a line ; do for (( COUNTER=0; COUNTER<${ array[$index]=${line[$COUNTER]} ((index++)) done done < "$1" for (( ROW = 0; ROW < COLS; ROW++ )); do for (( COUNTER = ROW; COUNTER < ${ printf "%s\t" ${array[$COUNTER]} done printf "\n" done
# use strict; my(%data); my($maxcol) = 0; my($rownum) = 0; while (<>) { my(@row) = split /\s+/; my($colnum) = 0; foreach my $val (@row) { $data{$rownum}{$colnum++} = $val; } $rownum++; $maxcol = $colnum if $colnum > $maxcol; } my $maxrow = $rownum; for (my $col = 0; $col < $maxcol; $col++) { for (my $row = 0; $row < $maxrow; $row++) { printf "%s%s", ($row == 0) ? "" : "\t", defined $data{$row}{$col} ? $data{$row}{$col} : ""; } print "\n"; }
Osiris JL: time gawk -f tr.awk xxx > /dev/null real 0m0.367s user 0m0.279s sys 0m0.085s Osiris JL: time perl -f transpose.pl xxx > /dev/null real 0m0.138s user 0m0.128s sys 0m0.008s Osiris JL: time awk -f tr.awk xxx > /dev/null real 0m1.891s user 0m0.924s sys 0m0.961s Osiris-2 JL:
{for (f=1;f<=NF;f++) col[f] = col[f]":"$f} END {for (f=1;f<=NF;f++) print col[f]}
$ echo "1 2 3\n4 5 6" 1 2 3 4 5 6 $ echo "1 2 3\n4 5 6" | awk 1 4 2 5 3 6
use warnings; use strict; my $counter; open INPUT, "<$ARGV[0]" or die ("Unable to open input file!"); while (my $line = <INPUT>) { chomp $line; my @array = split ("\t",$line); open OUTPUT, ">temp$." or die ("unable to open output file!"); print OUTPUT join ("\n",@array); close OUTPUT; $counter=$.; } close INPUT; my $execute = "paste "; foreach (1..$counter) { $execute.="temp$counter "; } $execute.="> $ARGV[1]"; system $execute;
/bin/rm output 2> /dev/null cols=`head -n 1 input | wc -w` for (( i=1; i <= $cols; i++)) do awk done >> output
awk max=(max<NF?NF:max)} END {for (i=1; i<=max; i++) {for (j=1; j<=NR; j++) printf "%s%s", a[i,j], (j==NR?RS:FS) } }
declare -a array=( ) read -a line < "$1" COLS=${ index=0 while read -a line; do for (( COUNTER=0; COUNTER<${ array[$index]=${line[$COUNTER]} ((index++)) done done < "$1" for (( ROW = 0; ROW < COLS; ROW++ )); do for (( COUNTER = ROW; COUNTER < ${ printf "%s" ${array[$COUNTER]} if [ $COUNTER -lt $(( ${ then printf "\t" fi done printf "\n" done
declare -a array=( ) declare -a ncols=( ) SEPARATOR="\t"; PADDING=""; MAXROWS=0; index=0 indexCol=0 while read -a line; do ncols[$indexCol]=${ ((indexCol++)) if [ ${ then MAXROWS=${ fi for (( COUNTER=0; COUNTER<${ array[$index]=${line[$COUNTER]} ((index++)) done done < "$1" for (( ROW = 0; ROW < MAXROWS; ROW++ )); do COUNTER=$ROW; for (( indexCol=0; indexCol < ${ if [ $ROW -ge ${ncols[indexCol]} ] then printf $PADDING else printf "%s" ${array[$COUNTER]} fi if [ $((indexCol+1)) -lt ${ then printf $SEPARATOR fi COUNTER=$(( COUNTER + ncols[indexCol] )) done printf "\n" done
Row2Trans=number1 Col2Trans=number2 for ((i=1; $i <= Line2Trans; i++));do for ((j=1; $j <=Col2Trans ; j++));do awk -v var1="$i" -v var2="$j" done done paste -d
X row1 row2 row3 row4 column1 0 3 6 9 column2 1 4 7 10 column3 2 5 8 11
aline="$(head -n 1 file.txt)" set -- $aline colNum=$# while read line; do set -- $line for i in $(seq $colNum); do eval col$i="\"\$col$i \$$i\"" done done < file.txt for i in $(seq $colNum); do eval echo \${col$i} done
n=$(head -n 1 foo | wc -w) for f in $(seq 1 $n) ; do cut -d
n=$(head -n 1 foo | wc -w) for f in $(seq 1 $n); do cut -d done
transpose :: [[a]] -> [[a]] transpose = foldr (zipWith (:)) (repeat []) main :: IO () main = interact $ unlines . map unwords . transpose . map words . lines
awk split($0,arr,FS); for (j in arr) { out[i,j]=arr[j]; if (maxr<j){ maxr=j} } } END { maxc=i for (j=1; j<=maxr; j++) { for (i=1; i<=maxc; i++) { printf( "%s:", out[i,j]) } printf( "%s\n","" ) } }
maxf="$(awk rowcount=maxf for (( i=1; i<=rowcount; i++ )); do awk -v i="$i" -F " " echo done
echo cat m.txt | while read l ; \ do paste tmp1 <(echo $l | tr -s cp tmp2 tmp1; \ done; \ cat tmp1
$ x=20 $ y=5 $ expr x / y expr: non-integer argument
start=`date +%s` sleep 71 end=`date +%s` let deltatime=end-start let hours=deltatime/3600 let minutes=(deltatime/60)%60 let seconds=deltatime%60 printf "Time spent: %d:%02d:%02d\n" $hours $minutes $seconds
$ stat -c %s /usr/bin/stat 50000 $ wc -c < /usr/bin/wc 36912
__ln=( $( ls -Lon "$1" ) ) __size=${__ln[3]} echo "Size is: $__size bytes"
4.0K /home/turing/Desktop/JavaExmp/TwoButtons.java~ 4.0K /home/turing/Desktop/JavaExmp/MyDrawPanel.java~ 4.0K /home/turing/Desktop/JavaExmp/Instream.java~ 4.0K /home/turing/Desktop/JavaExmp/RandomDemo.java~ 4.0K /home/turing/Desktop/JavaExmp/Buff.java~ 4.0K /home/turing/Desktop/JavaExmp/SimpleGui2.java~
size=$( find . -maxdepth 1 -type f -name filename -printf
getsize() { set -- $(ls -dn "$1") && echo $5; } getsize FILE
snafu=$(echo "$2" | grep -E "/^[-+]?(?:\.[0-9]+|(?:0|[1-9][0-9]*)(?:\.[0-9]*)?)$/") if [ -z "$snafu" ] ; then echo "Not an integer - nothing back from the grep" else echo "Integer." fi
if [ -I "string" ] ; then echo "String is a valid integer." else echo "String is not a valid integer." fi
if [ "$1" -eq "$1" ] 2>/dev/null then echo "$1 is an integer !!" else echo "ERROR: first parameter must be an integer." echo $USAGE exit 1 fi
$ int_check.sh 123 123 is an integer !! $ int_check.sh 123+ ERROR: first parameter must be an integer. $ int_check.sh -123 -123 is an integer !! $ int_check.sh +30 +30 is an integer !! $ int_check.sh -123c ERROR: first parameter must be an integer. $ int_check.sh 123c ERROR: first parameter must be an integer. $ int_check.sh c123 ERROR: first parameter must be an integer.
case ${variable *[!0-9]* | * ) echo Valid number ;; esac
if expr "$string" : then echo "String is a valid integer." else echo "String is not a valid integer." fi
shopt -s extglob case "$string" of @(-|)[0-9]*([0-9])) echo "String is a valid integer." ;; *) echo "String is not a valid integer." ;; esac
function is_int() { return $(test "$@" -eq "$@" > /dev/null 2>&1); } input="-123" if $(is_int "${input}"); then echo "Input: ${input}" echo "Integer: $[${input}]" else echo "Not an integer: ${input}" fi
for num in "44" "-44" "44-" "4-4" "a4" "4a" ".4" "4.4" "-4.4" "09" do match=${num match=${match echo -en "$num\t$match\t" case $num in $match|-$match) echo "Integer";; *) echo "Not integer";; esac done
if ((VAR > 0)) then echo "$VAR is a positive integer." fi
test -z $(echo "2000" | sed s/[0-9] test -z $(echo "ab12" | sed s/[0-9]
if [[ $1 =~ ^-?[0-9]+.?[0]+$ ]]; then echo "yes, this is an integer" elif [[ $1 =~ ^\+?[0-9]+.?[0]+$ ]]; then echo "yes, this is an integer" else echo "no, this is not an integer" fi
function strindex() { x="${1%%$2*}" if [[ "$x" = "$1" ]] ;then true else if [ "${ false else true fi fi } function is_int() { if is_empty "${1}" ;then false return fi tmp=$(echo "${1}" | sed if [[ $tmp == "${1}" ]] || [[ "-${tmp}" == "${1}" ]] ; then true else false fi } function is_float() { if is_empty "${1}" ;then false return fi if ! strindex "${1}" "-" ; then false return fi tmp=$(echo "${1}" | sed if [[ $tmp =~ "." ]] ; then true else false fi } function is_strict_string() { if is_empty "${1}" ;then false return fi if [[ "${1}" =~ ^[A-Za-z]+$ ]]; then true else false fi } function is_string() { if is_empty "${1}" || is_int "${1}" || is_float "${1}" || is_strict_string "${1}" ;then false return fi if [ ! -z "${1}" ] ;then true return fi false } function is_empty() { if [ -z "${1 true else false fi }
for num in "44" "-44" "44-" "4-4" "a4" "4a" ".4" "4.4" "-4.4" "09" "hello" "h3llo!" "!!" " " "" ; do if is_int "$num" ;then echo "INT = $num" elif is_float "$num" ;then echo "FLOAT = $num" elif is_string "$num" ; then echo "STRING = $num" elif is_strict_string "$num" ; then echo "STRICT STRING = $num" else echo "OTHER = $num" fi done
INT = 44 INT = -44 STRING = 44- STRING = 4-4 STRING = a4 STRING = 4a FLOAT = .4 FLOAT = 4.4 FLOAT = -4.4 INT = 09 STRICT STRING = hello STRING = h3llo! STRING = !! OTHER = OTHER =
find -maxdepth 1 -name "log*" -not -name ".*" -printf
file_count=$( shopt -s nullglob ; set -- $directory_to_search_inside/* ; echo $
3,5M asdf.6000.gz 3,4M asdf.4000.gz 3,2M asdf.2000.gz 2,5M xyz.PT.gz 136K xyz.6000.gz 116K xyz.6000p.gz 88K test.4000.gz 76K test.4000p.gz 44K test.2000.gz 8,0K desc.common.tcl 8,0K wer.2000p.gz 8,0K wer.2000.gz 4,0K ttree.3
$ ncdu 1.11 ~ Use the arrow keys to navigate, press ? for help --- / --------------------------------------------------------- . 96,1 GiB [ . 17,7 GiB [ . 4,5 GiB [ ] /var 1,1 GiB [ ] /lib 732,1 MiB [ ] /opt . 275,6 MiB [ ] /boot 198,0 MiB [ ] /storage . 153,5 MiB [ ] /run . 16,6 MiB [ ] /etc 13,5 MiB [ ] /bin 11,3 MiB [ ] /sbin . 8,8 MiB [ ] /tmp . 2,2 MiB [ ] /dev ! 16,0 KiB [ ] /lost+found 8,0 KiB [ ] /media 8,0 KiB [ ] /snap 4,0 KiB [ ] /lib64 e 4,0 KiB [ ] /srv ! 4,0 KiB [ ] /root e 4,0 KiB [ ] /mnt e 4,0 KiB [ ] /cdrom . 0,0 B [ ] /proc . 0,0 B [ ] /sys @ 0,0 B [ ] initrd.img.old @ 0,0 B [ ] initrd.img @ 0,0 B [ ] vmlinuz.old @ 0,0 B [ ] vmlinuz
find . -mindepth 1 -maxdepth 1 -type d | parallel du -s | sort -n
(find . -depth 1 -type f -exec ls -s {} \;; find . -depth 1 -type d -exec du -s {} \;) | sort -n
12671767700 real 2m19.164s user 0m2.039s sys 0m14.850s
ls -l $(find . -type f | xargs) | cut -d" " -f5 | xargs | sed
$ for entry in $(ls); do du -s "$entry"; done | sort -n
2900 tmp 6781 boot 8428 bin 24932 lib64 34436 sbin 90084 var 106676 etc 125216 lib 3313136 usr 4828700 opt
ls dirname | shuf -n 1 find dirname -type f | shuf -n 1
N=42 a=( * ) randf=() for((i=0;i<N;++i)); do randf+=( "${a[RANDOM%${ done
N=42 a=( * ) randf=() for((i=0;i<N && ${ ((j=RANDOM%${ randf+=( "${a[j]}" ) a=( "${a[@]:0:j}" "${a[@]:j+1}" ) done
ls -1 | python -c "import sys; import random; print(random.choice(sys.stdin.readlines()).rstrip())"
ls -1 | python -c "import sys; import random; print(
DIR="/path/to/" IFS=' ' if [[ -d "${DIR}" ]] then file_matrix=($(ls -R $DIR | awk num_files=${ ls -l "${file_matrix[$((RANDOM%num_files))]}" fi exit 0
array=(*) for dummy in "${array[@]}"; do length=${ randomi=$(( $RANDOM % $length )) filename=${array[$randomi]} echo "Processing: unset -v "array[$randomi]" array=("${array[@]}") done
ROOT="/"; tmp=/tmp/mytempfile TARGET="$ROOT" FILE=""; n= r= while [ -e "$TARGET" ]; do TARGET="$(readlink -f "${TARGET}/$FILE")" ; if [ -d "$TARGET" ]; then ls -1 "$TARGET" 2> /dev/null > $tmp || break; n=$(cat $tmp | wc -l); if [ $n != 0 ]; then FILE=$(shuf -n 1 $tmp) fi ; else if [ -f "$TARGET" ] ; then rm -f $tmp echo $TARGET break; else TARGET="$ROOT" FILE="" fi fi done;
FREE=`df -k --output=avail "$PWD" | tail -n1` if [[ $FREE -lt 10485760 ]]; then fi;
MOUNTP=/var/spool LIMITSIZE=5485760 FREE=$(df -k --output=avail "$MOUNTP" | tail -n1) LOG=/tmp/log-$(basename ${0}).log MAILCMD=mail EMAILIDS="dude@wheres.mycar" MAILMESSAGE=/tmp/tmp-$(basename ${0}) function email_on_failure(){ sMess="$1" echo "" >$MAILMESSAGE echo "Hostname: $(hostname)" >>$MAILMESSAGE echo "Date & Time: $(date)" >>$MAILMESSAGE echo -e "\n[ $(date +%Y%m%d_%H%M%S%Z) ] Current Status:\n\n" >>$MAILMESSAGE cat $sMess >>$MAILMESSAGE echo "" >>$MAILMESSAGE echo "*** This email generated by $(basename $0) shell script ***" >>$MAILMESSAGE echo "*** Please don $MAILCMD -s "Urgent MAIL Alert For $(hostname) AWS Server" "$EMAILIDS" < $MAILMESSAGE [[ -f $MAILMESSAGE ]] && rm -f $MAILMESSAGE } if [[ $FREE -lt $LIMITSIZE ]]; then echo "Writing to $LOG" echo "MAIL ERROR: Less than $((($FREE/1000))) MB free (QUOTA) on $MOUNTP!" | tee ${LOG} echo -e "\nPotential Files To Delete:" | tee -a ${LOG} find $MOUNTP -xdev -type f -size +500M -exec du -sh {} email_on_failure ${LOG} else echo "Currently $(((($FREE-$LIMITSIZE)/1000))) MB of QUOTA available of on $MOUNTP. " fi
FREE=`df --output=avail -h "$PWD" | sed if [[ $FREE -lt 10 ]]; then fi;
find . -type f -printf "%-.22T+ %M %n %-8u %-8g %8s %Tx %.8TX %p\n" | sort | cut -f 2- -d
gfind . -type f -printf "%-.22T+ %M %n %-8u %-8g %8s %Tx %.8TX %p\n" | sort | cut -f 2- -d
529 man history 530 ls 531 ll 532 clear 533 cd ~ 534 history
$ history 11 clear 12 echo "In word processing and desktop publishing, a hard return or paragraph break indicates a new paragraph, to be distinguished from the soft return at the end of a line internal to a paragraph. This distinction allows word wrap to automatically re-flow text as it is edited, without losing paragraph breaks. The software may apply vertical whitespace or indenting at paragraph breaks, depending on the selected style." $ history | awk clear echo "In word processing and desktop publishing, a hard return or paragraph break indicates a new paragraph, to be distinguished from the soft return at the end of a line internal to a paragraph. This distinction allows word wrap to automatically re-flow text as it is edited, without losing paragraph breaks. The software may apply vertical whitespace or indenting at paragraph breaks, depending on the selected style."
? Expands to the exit status of the most recently executed foreground pipeline.
files=`ls` for f in $files; do if [ ! -d $f ] then echo "$f $lines $ words" fi done
lines=`wc -l $f | cut -f1 -d words=`wc -w $f | cut -f1 -d
read lines words characters <<EOF $(wc < filename) EOF
typeset -i a=$(wc -l fileName.dat | xargs echo | cut -d
answer=(`wc $f`) echo -e"${answer[3]} lines: ${answer[0]} words: ${answer[1]} bytes: ${answer[2]}"
$ for i in {01..05}; do echo "$i"; done 01 02 03 04 05
for (( num=1; num<=5; num++ )); do printf "%02d\n" $num; done 01 02 03 04 05
for num in {1..5} do value=$(printf "%02d" $num) ... Use $value for your purposes done
$ echo {01..05} 01 02 03 04 05 for num in {01..05} do echo $num done 01 02 03 04 05
i=1 word="dog" while read line do eval echo "$line" done < "./template.txt"
cat template.txt | sed -e "s/\${i}/1/" | sed -e "s/\${word}/dog/"
while read -r line ; do while [[ "$line" =~ (\$\{[a-zA-Z_][a-zA-Z_0-9]*\}) ]] ; do LHS=${BASH_REMATCH[1]} RHS="$(eval echo "\"$LHS\"")" line=${line done echo "$line" done
FOO=foo BAR=bar export FOO BAR envsubst <<EOF FOO is $FOO BAR is $BAR EOF
STATUS_URI="/hows-it-goin"; MONITOR_IP="10.10.2.15"; cat >/etc/apache2/conf.d/mod_status.conf <<EOF <Location ${STATUS_URI}> SetHandler server-status Order deny,allow Deny from all Allow from ${MONITOR_IP} </Location> EOF
$ cat template.txt the number is ${i} the dog $ cat replace.sed s/${i}/5/ s/${name}/Fido/ $ sed -f replace.sed template.txt > out.txt $ cat out.txt the number is 5 the dog
$ cat template.txt variable1 = ${variable1} variable2 = $variable2 my-ip = \"$(curl -s ifconfig.me)\" $ echo $variable1 AAA $ echo $variable2 BBB $ eval "echo \"$(<template.txt)\"" 2> /dev/null variable1 = AAA variable2 = BBB my-ip = "11.22.33.44"
$ eval "cat <<EOF $(<template.txt) EOF " 2> /dev/null
eval "cat <<EOF $(<template.txt) EOF " 2> /dev/null
render_template() { eval "echo \"$(cat $1)\"" } user="Gregory" render_template /path/to/template.txt > path/to/configuration_file
Two ${TARGET} walk into a \\$FOO. \\\\ \\\$FOO says, "Delete C:\\Windows\\System32, it $BAZ replies, "\${NOPE}s."
Two backslashes walk into a \bar. \\ \$FOO says, "Delete C:\Windows\System32, it kenny replies, "${NOPE}s."
TEMPLATE= OUTPUT= while read LINE; do echo $LINE | sed sed sed done < $TEMPLATE
regex= while read line; do while [[ "$line" =~ $regex ]]; do param="${BASH_REMATCH[1]}" line=${line done echo $line done
expandVars() { local txtToEval=$* txtToEvalEscaped (( $ IFS= read -r -d eval printf %s "\"${txtToEvalEscaped }
$ expandVars $HOME="/home/jdoe"; `date` and $(ls) $ printf $SHELL=/bin/bash, but "$(( 1 \ 2 ))" will not expand
IFS= read -d end_offset=${ while [[ "${lines:0:end_offset}" =~ (.*)\$(\{([a-zA-Z_][a-zA-Z_0-9]*)\}|([a-zA-Z_][a-zA-Z_0-9]*))(.*) ]] ; do pre=${BASH_REMATCH[1]} post=${BASH_REMATCH[5]}${lines:end_offset} [[ -n ${BASH_REMATCH[3]} ]] && varName=${BASH_REMATCH[3]} || varName=${BASH_REMATCH[4]} if [[ $pre =~ \\+$ ]] && (( ${ : else lines=${pre}${!varName}${post} fi end_offset=${ done printf %s "$lines"
LISTING=$( ls ) cat_template() { echo "cat << EOT" cat "$1" echo EOT } cat_template template | LISTING="$LISTING" bash
<html> <head> </head> <body> <p>"directory listing" <pre> $( echo "$LISTING" | sed <pre> </p> </body> </html>
<html> <head> </head> <body> <p>"directory listing" <pre> code template <pre> </p> </body> </html>
word=dog i=1 cat << EOF the number is ${i} the word is ${word} EOF
( echo word=dog echo i=1 echo "cat << EOF" cat template.txt echo EOF ) | bash
this_variable_1 = ${SOME_VARIABLE_1} this_variable_2 = ${SOME_VARIABLE_2}
chmod +x ./configure.sh . .env export SOME_VARIABLE_1 SOME_VARIABLE_2 ./configure.sh
template() { local IFS line while IFS=$ line=${line line=${line line=${line line=${line line=${line eval "echo \"${line}\""; done < "$1" }
function render_file () { while IFS= eval echo \""${line}"\" done < "${1}" }
while [ current_time <= $cutoff ]; do check_if_file_present done
actions() { check_if_file_present } actions while [ current_time <= $cutoff ]; do actions done
while : ; do actions [[ current_time <= $cutoff ]] || break done
while check_if_file_present (( current_time <= cutoff )) do : done
while check_if_file_present (( current_time <= cutoff )) do (( index++ )); done
OUTPUT="name1 ip ip status" if [ -z "$OUTPUT" ] then echo "Status WARN: No messages from SMcli" exit $STATE_WARNING else echo "$OUTPUT"|while read NAME IP1 IP2 STATUS do if [ "$STATUS" != "Optimal" ] then echo "CRIT: $NAME - $STATUS" echo $((++XCODE)) else echo "OK: $NAME - $STATUS" fi done fi echo $XCODE
cat /tmp/randomFile | (while read line do LINE="$LINE $line" done && echo $LINE )
cat /some/file | while read line do var="abc" echo $var | xsel -i -p done var=$(xsel -o -p) echo $var
OUTPUT="name1 ip ip status" +export XCODE=0; if [ -z "$OUTPUT" ] ---- echo "CRIT: $NAME - $STATUS" - echo $((++XCODE)) + export XCODE=$(( $XCODE + 1 )) else echo $XCODE
EXPORTFILE=/tmp/exportfile${RANDOM} cat /tmp/randomFile | while read line do LINE="$LINE $line" echo $LINE > $EXPORTFILE done LINE=$(cat $EXPORTFILE)
ls -l | sed ( SUM=0; while read SIZE; do SUM=$(($SUM+$SIZE)); done; echo "$(($SUM/1024/1024/1024))GB" )
var1="this is the real value" a="var1" Do something to get value of var1 just using variable a.
ami\_type=GET AMI TYPE setup\_url=GET THE SETUP FILE URL BASED ON AMI\_TYPE
$ foo=$(w3m -dump http: You have reached this web page by typing "example.com", "example.net","example.org" or "example.edu" into your web browser. These domain names are reserved for use in documentation and are not available for registration. See RFC 2606, Section 3.
function tail_ls { ls -l "$1" | tail; } export -f tail_ls
sendpic () { scp "$@" mina@foo.bar.ca:/www/misc/Pictures/; }
~ $HOME ~fred (freds home dir) ~+ $PWD (same effect as ./) ~- $OLDPWD (your previous directory) ~1 `dirs +1` ~2 `dirs +2` ~-1 `dirs -1`
find ./ -type f | while read line; do echo $line done
~ $ sudo apt-get install realpath ~ $ realpath .bashrc /home/username/.bashrc
echo "$(cd "$(dirname "$1")"; pwd)/$(basename "$1")"
F=../../../../../etc/passwd echo "$(dirname $(readlink -e $F))/$(basename $F)"
abspath() { cd "$(dirname "$1")" printf "%s/%s\n" "$(pwd)" "$(basename "$1")" cd "$OLDPWD" }
absolute="$(cd $(dirname \"$file\"); pwd)/$(basename \"$file\")"
function to-abs-path { local target="$1" if [ "$target" == "." ]; then echo "$(pwd)" elif [ "$target" == ".." ]; then echo "$(dirname "$(pwd)")" else echo "$(cd "$(dirname "$1")"; pwd)/$(basename "$1")" fi }
find /etc find `pwd`/subdir_of_current_dir/ -type f
abspath(){ local thePath if [[ ! "$1" =~ ^/ ]];then thePath="$PWD/$1" else thePath="$1" fi echo "$thePath"|( IFS=/ read -a parr declare -a outp for i in "${parr[@]}";do case "$i" in ..) len=${ if ((len==0));then continue else unset outp[$((len-1))] fi ;; *) len=${ outp[$len]="$i" ;; esac done echo /"${outp[*]}" ) }
abspath_gawk() { if [[ -n "$1" ]];then echo $1|gawk if(substr($0,1,1) != "/"){ path = ENVIRON["PWD"]"/"$0 } else path = $0 split(path, a, "/") n = asorti(a, b,"@ind_num_asc") for(i in a){ if(a[i]=="" || a[i]=="."){ delete a[i] } } n = asorti(a, b, "@ind_num_asc") m = 0 while(m!=n){ m = n for(i=1;i<=n;i++){ if(a[b[i]]==".."){ if(b[i-1] in a){ delete a[b[i-1]] delete a[b[i]] n = asorti(a, b, "@ind_num_asc") break } else exit 1 } } } n = asorti(a, b, "@ind_num_asc") if(n==0){ printf "/" } else { for(i=1;i<=n;i++){ printf "/"a[b[i]] } } }' fi }
function abspath(path, i,j,n,a,b,back,out){ if(substr(path,1,1) != "/"){ path = ENVIRON["PWD"]"/"path } split(path, a, "/") n = length(a) for(i=1;i<=n;i++){ if(a[i]==""||a[i]=="."){ continue } a[++j]=a[i] } for(i=j+1;i<=n;i++){ delete a[i] } j=0 for(i=length(a);i>=1;i--){ if(back==0){ if(a[i]==".."){ back++ continue } else { b[++j]=a[i] } } else { if(a[i]==".."){ back++ continue } else { back-- continue } } } if(length(b)==0){ return "/" } else { for(i=length(b);i>=1;i--){ out=out"/"b[i] } return out } } BEGIN{ if(ARGC>1){ for(k=1;k<ARGC;k++){ print abspath(ARGV[k]) } exit } } { print abspath($0) }
$ pwd /etc/apache2 $ cd ../cups $ cd - /etc/apache2 $ (cd ~/..; pwd) /Users $ cd - /etc/cups
absPath=$(pushd ../SOME_RELATIVE_PATH_TO_Directory > /dev/null && pwd && popd > /dev/null) echo $absPath
$ filename=hello.world $ echo "$filename" | cut -f 1 -d hello $ filename=hello.hello.hello $ echo "$filename" | cut -f 1 -d hello $ filename=hello $ echo "$filename" | cut -f 1 -d hello
file1=/tmp/main.one.two.sh t=$(basename "$file1") name=$(echo "$file1" | sed -e name=$(echo "$t" | sed -e
a=this.path/with.dots/in.path.name/filename.tar.gz echo $(dirname $a)/$(basename $a | cut -d. -f1)
$> filename=foo.txt $> echo $filename foo.txt $> name=`echo $filename | cut -f1 -d $> echo $name foo $>
filename=program.c name=$(basename "$filename" .c) echo "$name"
for f in *; do mv "$f" "$f.tmp"; mv "$f.tmp" "`echo $f | tr "[:upper:]" "[:lower:]"`"; done
shopt -s nullglob dotglob files=(/some/dir/*) if [ ${
files=$(shopt -s nullglob dotglob; echo your/dir/*) if (( ${ then echo "contains files" else echo "empty (or does not exist or is a file)" fi
if (shopt -s nullglob dotglob; f=(*); ((${ then echo "contains files" else echo "empty (or does not exist, or is a file)" fi
if [ -n "$(ls -A your/dir 2>/dev/null)" ] then echo "contains files (or is a file)" else echo "empty (or does not exist)" fi
[[ $(ls -A your/dir) ]] && echo "contains files" || echo "empty"
if [ -n "$(find your/dir -prune -empty 2>/dev/null)" ] then echo "empty (directory or file)" else echo "contains files (or does not exist)" fi
if [ -n "$(find your/dir -prune -empty -type d 2>/dev/null)" ] then echo "empty directory" else echo "contains files (or does not exist or is not a directory)" fi
if [ `find your/dir -prune -empty 2>/dev/null` ] then echo "empty (directory or file)" else echo "contains files (or does not exist)" fi
if find /some/dir/ -maxdepth 0 -empty | read v; then echo "Empty dir"; fi
if [ ! -z `ls /some/dir/*` ]; then echo "huzzah"; fi
function isEmpty(){ if [ "$(ls -A $1)" ]; then echo "huzzah" else echo "has no files" fi }
DIR="/some/dir" if [ "$(ls -A $DIR)" ]; then echo fi
directory="/some/dir" number_of_files=$(ls -A $directory | wc -l) if [ "$number_of_files" == "0" ]; then echo "directory $directory is empty" else echo "directory $directory contains $number_of_files files" fi
if find /path/to/check/* -maxdepth 0 -type f | read then echo "Files Exist" fi
dir_is_empty() { [ "${1 } if dir_is_empty /some/dir/* ; then echo "huzzah" fi
is_empty () ( cd "$1" set -- .[!.]* ; test -f "$1" && return 1 set -- ..?* ; test -f "$1" && return 1 set -- * ; test -f "$1" && return 1 return 0 )
dir_is_empty() { [ "$(find "$1" -name "?*" | dd bs=$((${ }
files=$(ls -1 /some/dir| wc -l) if [ $files -gt 0 ] then echo "Contains files" else echo "Empty" fi
$ mkdir X $ touch f $ for i in X(N/^F) f(N/^F) ; do echo $i ; done X
$ mkdir X X1 X2 Y Y1 Y2 Z $ touch Xf $ touch X1/f $ touch Y1/.f $ ls -F X/ X1/ X2/ Xf Y/ Y1/ Y2/ Z/ $ for i in {X,Y}*(N/^F); do printf "$i "; done; echo X X2 Y Y2
$ ls -F X/ X1/ X2/ Xf Y/ Y1/ Y2/ Z/ $ arr=(*) $ for i in ${^arr}(N/^F); do printf "$i "; done; echo X X2 Y Y2 Z
$ for i in *(NF) ; do full_directories+=($i) ; done $ do_something $full_directories
$ mkdir X Y $ touch Y/.f $ touch f $ ls -dF * f X/ Y/ $ ls -dF *(F) Y/
$ mkdir X Y Z $ touch X/f Y/.f $ for i in *(/^F) ; do echo $i ; done Z
$ mkdir X $ for i in X(/^F) ; do echo $i ; done ; echo "finished" X finished
$ mkdir Y $ touch Y/.f $ for i in Y(/^F) ; do echo $i ; done ; echo "finished" zsh: no matches found: Y(/^F) finished
$ mkdir Y $ touch Y/.f $ for i in Y(N/^F) ; do echo $i ; done ; echo "finished" finished
if ls /some/dir/* >/dev/null 2>&1 ; then echo "huzzah"; fi;
find "$somedir" -type f -exec echo Found unexpected file {} \; find "$somedir" -maxdepth 0 -empty -exec echo {} is empty. \; find "$somedir" -type d -empty -exec cp /my/configfile {} \;
for f in ./*.mpg; do test -f "$f" || continue mympgviewer "$f" done
fileNum=`ls -l <directory> | egrep -c "^-"` if [ $fileNum == x ] then fi
find "$some_dir" -prune -empty -type d | read && echo empty || echo "not empty"
if [ -z "$(find $dir -maxdepth 1 -type f)" ]; then echo "$dir has NO files" else echo "$dir has files"
$ [ -z "$(find aaa/ -maxdepth 1 -type f)" ] && echo "empty" empty
$ mkdir aaa/bbb $ [ -z "$(find aaa/ -maxdepth 1 -type f)" ] && echo "empty" empty
$ touch aaa/myfile $ [ -z "$(find aaa/ -maxdepth 1 -type f)" ] && echo "empty" $ rm aaa/myfile
$ touch aaa/bbb/another_file $ [ -z "$(find aaa/ -maxdepth 1 -type f)" ] && echo "empty" empty
_DIR="/home/user/test/" _FIND=$(find $_DIR -type f ) if [ -n "$_FIND" ] then echo -e "$_DIR contains files or subdirs with files \n\n " echo "$_FIND" else echo "empty (or does not exist)" fi
if ([ $(ls /some/dir | wc -l | grep -w "0") ]) then echo else echo fi
if ! rmdir ${target} then echo "not empty" else echo "empty" mkdir ${target} fi
if [ -d $target_dir ]; then ls_contents=$(ls -1 $target_dir | xargs); if [ ! -z "$ls_contents" -a "$ls_contents" != "" ]; then echo "is not empty"; else echo "is empty"; fi; else echo "directory does not exist"; fi;
some_dir="/some/dir with whitespace & other characters/" if find "`echo "$some_dir"`" -maxdepth 0 -empty | read v; then echo "Empty dir"; fi
if [ -d "$some_dir" ]; then if find "`echo "$some_dir"`" -maxdepth 0 -empty | read v; then echo "Empty dir"; else "Dir is NOT empty" fi fi
This is the test data This is the error data as follows . . . . . . . . . . . . . . . . . . . . . . Error data ends
. . . . . . . . . . . . . . . . . . . . . . Error data ends
user@box:~$ cat out line 1 line 2 line 3 line 4 line 5 my_regex line 6 line 7 line 8 line 9 user@box:~$
user@box:~$ grep my_regex out line 5 my_regex user@box:~$
user@box:~$ grep -A 2 my_regex out line 5 my_regex line 6 line 7 user@box:~$
user@box:~$ grep -B 2 my_regex out line 3 line 4 line 5 my_regex user@box:~$
user@box:~$ grep -C 2 my_regex out line 3 line 4 line 5 my_regex line 6 line 7 user@box:~$
-A num --after-context=num Print num lines of trailing context after matching lines. -B num --before-context=num Print num lines of leading context before matching lines. -C num -num --context=num Print num lines of leading and trailing output context.
fspec=qq.c num_files=6 total_lines=$(wc -l <${fspec}) ((lines_per_file = (total_lines + num_files - 1) / num_files)) split --lines=${lines_per_file} ${fspec} xyzzy. echo "Total lines = ${total_lines}" echo "Lines per file = ${lines_per_file}" wc -l xyzzy.*
Total lines = 70 Lines per file = 12 12 xyzzy.aa 12 xyzzy.ab 12 xyzzy.ac 12 xyzzy.ad 12 xyzzy.ae 10 xyzzy.af 70 total
321 auth.log 75 auth.log.aa 75 auth.log.ab 75 auth.log.ac 75 auth.log.ad 21 auth.log.ae 642 total
parts_total="$2"; input="$1"; parts=$((parts_total)) for i in $(seq 0 $((parts_total-2))); do lines=$(wc -l "$input" | cut -f 1 -d" ") n=$(awk -v lines=$lines -v parts=$parts n = lines/parts; rounded = sprintf("%.0f", n); if(n>rounded){ print rounded + 1; }else{ print rounded; } } head -$n "$input" > split${i} tail -$((lines-n)) "$input" > .tmp${i} input=".tmp${i}" parts=$((parts-1)); done mv .tmp$((parts_total-2)) split$((parts_total-1)) rm .tmp*
awk -v size=$(wc -l < input) -v perc=0.1 nfile = int(NR/(size*perc)); if(nfile >= 1/perc){ nfile--; } print > "split_"nfile }
var dict = File.ReadLines("test.txt") .Where(line => !string.IsNullOrWhitespace(line)) .Select(line => line.Split(new char[] { .ToDictionary(parts => parts[0], parts => parts[1]); or enter code here line="to=xxx@gmail.com=yyy@yahoo.co.in"; string[] tokens = line.Split(new char[] { ans: tokens[0]=to token[1]=xxx@gmail.com=yyy@yahoo.co.in"
file="/stuff/backup/file.zip" filename=${1 directory=${1%/*}
file="stuff/backup/file.zip" dirPath=${file%/*}/ echo ${dirPath}
$ env | grep $ $ variable=Hello $ env | grep $ $ export variable $ env | grep variable=Hello $ $ export other_variable=Goodbye $ env | grep other_variable=Goodbye $
$ othervar=present $ (echo $othervar; echo $variable; variable=elephant; echo $variable) present Hello elephant $ echo $variable Hello $
jcomeau@intrepid:~/rentacoder/bin2txt$ foo=bar jcomeau@intrepid:~/rentacoder/bin2txt$ bash -c jcomeau@intrepid:~/rentacoder/bin2txt$ export foo jcomeau@intrepid:~/rentacoder/bin2txt$ bash -c bar
q=${@:0:1};[ ${2} ] && set ${@:2} || set ""; echo $q
> q=${@:1} > [ ${2} ] > && > set ${@:2} > || > set ""; > echo $q
LIST=( one two three ) ELEMENT=( ${LIST[@]:0:1} );LIST=( "${LIST[@]:1}" ) echo $ELEMENT
$ function calc { bc -l <<< ${@ $ calc 5X5 25 $ calc 5x5 25 $ calc 25
$ c 25 $ c 5/5 1.00000000000000000000 $ c 3.4/7.9 .43037974683544303797
echo "Please type in the directory you want all the files to be listed" read directory for entry in "$directory"/* do echo "$entry" done
for i in /var/log/*.out; do stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$i" done
for i in /var/log/*.out; do stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$i" echo "$i" done
2016-40-01 16:40 /var/log/daily.out 2016-40-01 16:40 /var/log/monthly.out 2016-40-01 16:40 /var/log/weekly.out
echo "Please type in the directory you want all the files to be listed with last modified dates" read directory for entry in "$directory"/* do modDate=$(stat -c %y "$entry") modDate=${modDate%% *} echo $entry:$modDate
/home/joanne/Dropbox/cheat sheet.docx:2012-03-14 /home/joanne/Dropbox/Comp:2013-05-05 /home/joanne/Dropbox/Comp 150 java.zip:2013-02-11 /home/joanne/Dropbox/Comp 151 Java 2.zip:2013-02-11 /home/joanne/Dropbox/Comp 162 Assembly Language.zip:2013-02-11 /home/joanne/Dropbox/Comp 262 Comp Architecture.zip:2012-12-12 /home/joanne/Dropbox/Comp 345 Image Processing.zip:2013-02-11 /home/joanne/Dropbox/Comp 362 Operating Systems:2013-05-05 /home/joanne/Dropbox/Comp 447 Societal Issues.zip:2013-02-11
for i in /Users/anthonykiggundu/Sites/rku-it/*; do t=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$i") echo $t : "${i done
stat -c %Y myfile.css date -d @1503989421 +%Y%m%d%H%M%S
st=`echo "$num1 < $num2" | bc` if [ $st -eq 1]; then echo -e "$num1 < $num2" else echo -e "$num1 >= $num2" fi
$ num1=3.17648E-22 $ num2=1.5 $ echo $num1 0 $ echo $num2 1
numCompare 5.65 3.14e-22 5.65 >= 3.14e-22 numCompare 5.65e-23 3.14e-22 5.65e-23 < 3.14e-22 numCompare 3.145678 3.145679 3.145678 < 3.145679
if [ ${FOO%.*} -eq ${BAR%.*} ] && [ ${FOO echo "${FOO} > ${BAR}"; else echo "${FOO} <= ${BAR}"; fi
toolversion() { local prog="$1" operator="$2" value="$3" version version=$($prog --version | awk awk -vv1="$version" -vv2="$value" split(v1, a, /\./); split(v2, b, /\./); if (a[1] == b[1]) { exit (a[2] } else { exit (a[1] } }' } if toolversion grep fi
is_first_floating_number_bigger 1.5 1.2 result="${__FUNCTION_RETURN}"
is_first_floating_number_bigger () { number1="$1" number2="$2" [ ${number1%.*} -eq ${number2%.*} ] && [ ${number1 result=$? if [ "$result" -eq 0 ]; then result=1; else result=0; fi __FUNCTION_RETURN="${result}" }
is_first_floating_number_bigger () { number1="$1" number2="$2" echo "... is_first_floating_number_bigger: comparing ${number1} with ${number2} (to check if the first one is bigger)" [ ${number1%.*} -eq ${number2%.*} ] && [ ${number1 result=$? if [ "$result" -eq 0 ]; then result=1; else result=0; fi echo "... is_first_floating_number_bigger: result is: ${result}" if [ "$result" -eq 0 ]; then echo "... is_first_floating_number_bigger: ${number1} is not bigger than ${number2}" else echo "... is_first_floating_number_bigger: ${number1} is bigger than ${number2}" fi __FUNCTION_RETURN="${result}" }
min=1.4 current=`echo $(grails --version | head -n 2 | awk if [ 1 -eq `echo "${current} < ${min}" | bc` ] then echo "yo, you have older version of grails." else echo "Hurray, you have the latest version" fi
X=0.2 Y=0.2 echo $X echo $Y if [[ $X -lt $Y ]] then echo "X is less than Y" elif [[ $X -gt $Y ]] then echo "X is greater than Y" elif [[ $X -eq $Y ]] then echo "X is equal to Y" fi
static int doubleCompare(double a,double b) {return((a>b) ? 1 : (a<b) ? -1 : 0);} num1=3.17648e-22 num2=1.5 comp=j.doubleCompare($num1,$num2) if [ $comp == 0 ] ; then echo "Equal" ; fi if [ $comp == 1 ] ; then echo "$num1 > $num2" ; fi if [ $comp == -1 ] ; then echo "$num2 > $num1" ; fi
VAL_TO_CHECK="1.00001" if [ $(awk echo "$VAL_TO_CHECK >= 1" else echo "$VAL_TO_CHECK < 1" fi
num1=3.17648E-22 num2=1.5 if python -c "import sys; sys.exit(0 if float($num1) < float($num2) else 1)"; then echo "yes, $num1 < $num2" else echo "no, $num1 >= $num2" fi
num1=0.555 num2=2.555 if [ `echo "$num1>$num2"|bc` -eq 1 ]; then echo "$num1 is greater then $num2" else echo "$num2 is greater then $num1" fi
if (( $(bc -l <<< "${value1/e/E} < ${value2/e/E}") )) then echo "$value1 is less than $value2" fi
$ls -l `which sh` /bin/sh -> dash $sudo dpkg-reconfigure dash [...] $ls -l `which sh` /bin/sh -> bash
head -10 log.txt | grep -A 2 -B 2 pattern_to_search
path_append () { path_remove $1; export PATH="$PATH:$1"; } path_prepend () { path_remove $1; export PATH="$1:$PATH"; } path_remove () { export PATH=`echo -n $PATH | awk -v RS=: -v ORS=:
$ export a="/a/b/c/d/e:/a/b/c/d/g/k/i:/a/b/c/d/f:/a/b/c/g:/a/b/c/d/g/i" $ echo ${a} /a/b/c/d/e:/a/b/c/d/f:/a/b/c/g:/a/b/c/d/g/i $ echo ${a} | awk -v RS=: -v ORS=: $ echo ${a} | awk -v RS=: -v ORS=: /a/b/c/d/e:/a/b/c/d/f:
WORK=:$PATH: REMOVE= WORK=${WORK/:$REMOVE:/:} WORK=${WORK%:} WORK=${WORK PATH=$WORK
IFS=: t=($PATH) unset IFS t=(${t[@]%%*usr*}) IFS=: echo "${t[*]}"
IFS= t=($PATH) n=${ a=() for ((i=0;i<n;i++)); do p="${t[i]%%*usr*}" [ "${p}" ] && a[i]="${p}" done echo "${a[*]}"
export PATH=$(p=$(echo $PATH | tr ":" "\n" | grep -v "/cygwin/" | tr "\n" ":"); echo ${p%:})
function path_remove { PATH=${PATH/":$1"/} PATH=${PATH/"$1:"/} }
$ rpm -ql bash-doc |grep pathfunc /usr/share/doc/bash-4.2.20/examples/functions/pathfuncs $ cat $(!!) cat $(rpm -ql bash-doc |grep pathfunc) # # # # no_path() { eval "case :\$${2-PATH}: in *:$1:*) return 1;; *) return 0;; esac" } add_path () { [ -d ${1:-.} ] && no_path $* && eval ${2:-PATH}="\$${2:-PATH}:$1" } pre_path () { [ -d ${1:-.} ] && no_path $* && eval ${2:-PATH}="$1:\$${2:-PATH}" } del_path () { no_path $* || eval ${2:-PATH}=`eval echo : sed -e "s;:$1:;:;g" -e "s;^:;;" -e "s;:\$;;"` }
path_remove () { declare i newPATH newPATH="${PATH}:" for ((i=1; i<=${ newPATH="${newPATH done export PATH="${newPATH%:}" return 0; } path_remove_all () { declare i newPATH shopt -s extglob newPATH="${PATH}:" for ((i=1; i<=${ newPATH="${newPATH done shopt -u extglob export PATH="${newPATH%:}" return 0 } path_remove /opt/local/bin /usr/local/bin path_remove_all /opt/local /usr/local
if ! $( echo "$PATH" | tr ":" "\n" | grep -qx "$folder" ) ; then PATH=$PATH:$folder ; fi
pathrm () { local IFS= local newpath local dir local pathvar=${2:-PATH} for dir in ${!pathvar} ; do if [ "$dir" != "$1" ] ; then newpath=${newpath:+$newpath:}$dir fi done export $pathvar="$newpath" } pathprepend () { pathrm $1 $2 local pathvar=${2:-PATH} export $pathvar="$1${!pathvar:+:${!pathvar}}" } pathappend () { pathrm $1 $2 local pathvar=${2:-PATH} export $pathvar="${!pathvar:+${!pathvar}:}$1" }
rm_from_path() { pattern="${1}" dir= [ -d "${pattern}" ] && dir="$(cd ${pattern} && pwd)" new_path= IFS0=${IFS} IFS= for segment in ${PATH}; do if [[ ${segment} == ${pattern} ]]; then continue elif [[ -n ${dir} && -d ${segment} ]]; then segment="$(cd ${segment} && pwd)" if [[ ${segment} == ${dir} ]]; then continue fi fi new_path="${new_path}${IFS}${segment}" done new_path="${new_path/ IFS=${IFS0} export PATH=${new_path} }
$ mkdir -p ~/foo/bar/baz ~/foo/bar/bif ~/foo/boo/bang $ PATH0=${PATH} $ PATH=~/foo/bar/baz/.././../boo/././../bar:${PATH} $ rm_from_path ~/foo/boo/../bar/. $ [ ${PATH} == ${PATH0} ] && echo
path_append () { path_remove $1 $2; export $1="${!1}:$2"; } path_prepend () { path_remove $1 $2; export $1="$2:${!1}"; } path_remove () { export $1="`echo -n ${!1} | awk -v RS=: -v ORS=:
path_prepend PATH /usr/local/bin path_append PERL5LIB "$DEVELOPMENT_HOME/p5/src/perlmods"
path_remove () { export PATH=`echo -n $PATH | awk -v RS=: -v ORS=:
PATH="$(echo "$PATH" | python -c "import sys; path = sys.stdin.read().split(
PATH="$(echo "$PATH" | python -c "import sys; path = sys.stdin.read().split(
strip_path_first () { PATH="$(echo "$PATH" | python -c "import sys; path = sys.stdin.read().split( } strip_path_last () { PATH="$(echo "$PATH" | python -c "import sys; path = sys.stdin.read().split( }
# # if [ $ echo "Usage: $0 pathname" 1>&2; exit 1; fi delendum="$1" NEWPATH= xxx="$IFS" IFS=":" for i in $PATH ; do IFS="$xxx" case "$i" in "$delendum") ;; *) [ -z "$NEWPATH" ] && NEWPATH="$i" || NEWPATH="$NEWPATH:$i" ;; esac done PATH="$NEWPATH" echo "$PATH"
# # # # if [ $add2path ]; then for nodup in ${add2path[*]} do case $PATH in $nodup:* | *:$nodup:* | *:$nodup ) ;; *) PATH=$PATH:$nodup esac done export PATH fi echo echo " PATH == $PATH" echo
shopt -s extglob printf "%s\n" "${PATH}" | tr printf "%s\n" "${PATH man bash | less -p extglob
path_remove () { shopt -s extglob; declare escArg="${1
path_remove () { declare i newPATH newPATH=":${PATH for ((i=1; i<=${ newPATH="${newPATH done newPATH="${newPATH newPATH="${newPATH newPATH="${newPATH%:}" unset PATH PATH="${newPATH}" export PATH return 0 } path_remove_all () { declare i newPATH extglobVar extglobVar=0 [[ ! $(shopt -q extglob) ]] && { shopt -s extglob; extglobVar=1; } newPATH=":${PATH}:" for ((i=1; i<=${ newPATH="${newPATH done newPATH="${newPATH newPATH="${newPATH%:}" [[ $extglobVar -eq 1 ]] && shopt -u extglob unset PATH PATH="${newPATH}" export PATH return 0 } path_remove /opt/local/bin /usr/local/bin path_remove_all /opt/local /usr/local
PATH="/usr/lib/ccache:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games" REMOVE="ccache" export PATH=$(IFS= echo $PATH
path_remove () { if [[ ":$PATH:" == *":$1:"* ]]; then local dirs=":$PATH:" dirs=${dirs/:$1:/:} export PATH="$(__path_clean $dirs)" fi } __path_clean () { local dirs=${1%?} echo ${dirs }
path_remove () { PATH="$(echo -n $PATH | awk -v RS=: -v ORS= }
PATH=`echo $PATH | tr ":" "\n" | grep -v $1 | tr "\n" ":"`
PATH=$(echo $PATH | sed PATH=$(echo $PATH | tr ":" "\n" | grep -v $1 | tr "\n" ":")
nohup /home/edheal/myprog -arg1 -arg2 > /home/edheal/output.txt 2>&1 &
MY_PATH="`dirname \"$0\"`" MY_PATH="`( cd \"$MY_PATH\" && pwd )`" if [ -z "$MY_PATH" ] ; then exit 1 fi echo "$MY_PATH"
prg=$0 if [ ! -e "$prg" ]; then case $prg in (*/*) exit 1;; (*) prg=$(command -v -- "$prg") || exit;; esac fi dir=$( cd -P -- "$(dirname -- "$prg")" && pwd -P ) || exit prg=$dir/$(basename -- "$prg") || exit printf
MY_PATH=`dirname "$0"` MY_PATH=`( cd "$MY_PATH" && pwd )`
if [ false ]; then echo "True" else echo "False" fi
if [ true ] ; then echo "This text will always appear." ; fi; if [ false ] ; then echo "This text will always appear." ; fi; if true ; then echo "This text will always appear." ; fi; if false ; then echo "This text will never appear." ; fi;
if [ "$foo" = "$bar" ] if [ "$foo" -eq "$bar" ] if [ -f "$foo" ] if [ "$foo" ] if foo
A=true B=true if ($A && $B); then C=true else C=false fi echo $C
[ "$(basename $0)" == "bash" ] && sourced=true || sourced=false $sourced && echo "SOURCED" $sourced || echo "CALLED" ! $sourced && echo "CALLED " || echo "SOURCED" $sourced && return || exit
grep -o -E [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(:[0-9]+)? ip_traffic-1.log > ips.txt
git clone git@github.com:dhulihan/league-of-legends-data-scraper.git Cloning into Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.
OpenSSH_6.2p2, OSSLShim 0.9.8r 8 Dec 2011 debug1: Reading configuration data /etc/ssh_config debug1: /etc/ssh_config line 20: Applying options for * debug1: Connecting to github.com [192.30.252.129] port 22. debug1: Connection established. debug1: identity file /Users/XXXX/.ssh/id_rsa type -1 debug1: identity file /Users/XXXX/.ssh/id_rsa-cert type -1 debug1: identity file /Users/XXXX/.ssh/id_dsa type -1 debug1: identity file /Users/XXXX/.ssh/id_dsa-cert type -1 debug1: Enabling compatibility mode for protocol 2.0 debug1: Local version string SSH-2.0-OpenSSH_6.2 debug1: Remote protocol version 2.0, remote software version libssh-0.6.0 debug1: no match: libssh-0.6.0 debug1: SSH2_MSG_KEXINIT sent debug1: SSH2_MSG_KEXINIT received debug1: kex: server->client aes128-ctr hmac-sha1 none debug1: kex: client->server aes128-ctr hmac-sha1 none debug1: sending SSH2_MSG_KEXDH_INIT debug1: expecting SSH2_MSG_KEXDH_REPLY debug1: Server host key: RSA 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 debug1: Host debug1: Found key in /Users/XXXX/.ssh/known_hosts:1 debug1: ssh_rsa_verify: signature correct debug1: SSH2_MSG_NEWKEYS sent debug1: expecting SSH2_MSG_NEWKEYS debug1: SSH2_MSG_NEWKEYS received debug1: Roaming not allowed by server debug1: SSH2_MSG_SERVICE_REQUEST sent debug1: SSH2_MSG_SERVICE_ACCEPT received debug1: Authentications that can continue: publickey debug1: Next authentication method: publickey debug1: Trying private key: /Users/XXXX/.ssh/id_rsa debug1: Trying private key: /Users/XXXX/.ssh/id_dsa debug1: No more authentication methods to try. Permission denied (publickey).
Host * AddKeysToAgent yes UseKeychain yes IdentityFile PATH_TO_YOUR_SSH_PRIVATE_KEY (e.g. ~/.ssh/id_rsa)
ssh-keygen -t rsa ssh-add /Users .ssh/id_rsa** pbcopy < ~/.ssh/id_rsa.pub**
2048 SHA256:5zabdekjjjaalajafjLIa3Gl/k832A /c/Users/username/.ssh/id_rsa (RSA)
pax> long="USCAGol.blah.blah.blah" pax> short="${long:0:2}" ; echo "${short}" US
pax> long="A" pax> tmpstr="${long}.." pax> short="${tmpstr:0:2}" ; echo "${short}" A.
short=$(echo "${long}" | cut -c1-2) short=$(echo "${long}" | head -c2) short=$(echo "${long}" | awk short=$(echo "${long}" | sed
my $string = my $first_two_chars = substr $string, 0, 2;
-rw-r--r-- 1 nneonneo staff 9274991 Apr 11 02:29 ./devel/misc/test.out
$ cd /path/to/some/var $ du -hsx * | sort -rh | head -10
find /path/to/folder -type f -exec ls -s {} \; | sort -nr | awk
find /your/path -printf "%k %p\n" | sort -g -k 1,1 | awk
function hasch() { local hasch=`echo "$1" | cksum`; echo "${hasch function usage() { echo "Usage: $0 [{count}{k|K|m|M|g|G|t|T}"; exit 1; } function arg1() { count=10; units=G; size=${count}${units} if [ -n "$1" ]; then for P in TT tT GG gG MM mM Kk kk; do xlat[`hasch ${P:0:1}`]="${P:1:1}"; done units=${xlat[`hasch ${1:(-1)}`]}; count=${1:0:(-1)} test -n "$units" || usage test -x $(echo "$count" | sed s/[0-9] if [ "$units" == "T" ]; then units="G"; let count=$count*1024; fi size=${count}${units} fi } function main() { sudo \ find / -type f -size +$size -exec ls -lh {} \; 2>/dev/null | \ awk } arg1 $1 main $size
ls -l | tr -s " " " " | cut -d " " -f 5,9 | sort -n -r | head -n 1***
find . -type f \( -perm -u=x -o -perm -g=x -o -perm -o=x \) -exec test -x {} \; -print
find -L . -type f -perm -a=x find -L . -type f \( -perm -u=x -o -perm -g=x -o -perm -o=x \) find -L . -type f -perm -u=x,g=x \! -perm -o=x
-executable Matches files which are executable and directories which are searchable (in a file name resolution sense).
find ./ -type f -name "*" -not -name "*.o" -exec sh -c ' case "$(head -n 1 "$1")" in ?ELF*) exit 0;; MZ*) exit 0;; esac exit 1
find . -type f -executable -exec file {} \; | grep -wE "executable|shared object|ELF|script|a\.out|ASCII text"
find . -type f -executable -printf "%i.%D %s %m %U %G %C@ %p" 2>/dev/null |while read LINE do NAME=$(awk file -b $NAME |grep -qEw "executable|shared object|ELF|script|a\.out|ASCII text" && echo $LINE done
STEST(1) General Commands Manual STEST(1) NAME stest - filter a list of files by properties SYNOPSIS stest [-abcdefghlpqrsuwx] [-n file] [-o file] [file...] DESCRIPTION stest takes a list of files and filters by the files which pass all tests are printed to stdout. If no files are given, stest reads files from stdin. OPTIONS -a Test hidden files. -b Test that files are block specials. -c Test that files are character specials. -d Test that files are directories. -e Test that files exist. -f Test that files are regular files. -g Test that files have their set-group-ID flag set. -h Test that files are symbolic links. -l Test the contents of a directory given as an argument. -n file Test that files are newer than file. -o file Test that files are older than file. -p Test that files are named pipes. -q No files are printed, only the exit status is returned. -r Test that files are readable. -s Test that files are not empty. -u Test that files have their set-user-ID flag set. -v Invert the sense of tests, only failing files pass. -w Test that files are writable. -x Test that files are executable. EXIT STATUS 0 At least one file passed all tests. 1 No files passed all tests. 2 An error occurred. SEE ALSO dmenu(1), test(1) dmenu-4.6 STEST(1)
typeset TMP_FILE=$( mktemp ) touch "${TMP_FILE}" cp -p filename "${TMP_FILE}" sed -e
suffix=foobar xargs -L 1 printf "%s$suffix\n" < file | sponge file
suffix=foobar join file file -e "${suffix}" -o 1.1,2.99999 | sponge file
suffix=foobar paste file <(yes "${suffix}" | head -$(wc -l < file) ) | sponge file
hendry@i7 tmp$ cat foo bar candy car hendry@i7 tmp$ for i in `cat foo`; do echo ${i}bar; done barbar candybar carbar
$ foo="Here is a String" $ foo=${foo $ echo "$foo" is a String $ foo=${foo%% String*} $ echo "$foo" is a $
$ echo "Here is a string" | awk -v FS="(Here|string)" is a
$ echo "Here is a string" | grep -oP is a $ echo "Here is a string" | grep -oP is a
$ echo "Here is a string" | grep -oP is a $ echo "Here is a string" | grep -oP is a
function str_str { local str str="${1 str="${str%%$3*}" echo -n "$str" } mystr="this is a string" str_str "$mystr" "this " " string"
Subject: [SLC38A9 lysosomal arginine sensor; mTORC1 pathway] Key molecular link in major cell growth pathway: Findings point to new potential therapeutic target in pancreatic cancer [mTORC1 Activator SLC38A9 Is Required to Efflux Essential Amino Acids from Lysosomes and Use Protein as a Nutrient] [Re: Nutrient sensor in key growth-regulating metabolic pathway identified [Lysosomal amino acid transporter SLC38A9 signals arginine sufficiency to mTORC1]] Message-ID: <20171019190902.18741771@VictoriasJourney.com>
grep -o -P [SLC38A9 lysosomal arginine sensor; mTORC1 pathway] Key
[SLC38A9 lysosomal arginine sensor; mTORC1 pathway] Key molecular link in major cell growth pathway: Findings point to new potential therapeutic target in pancreatic cancer [mTORC1 Activator SLC38A9 Is Required to Efflux Essential Amino Acids from Lysosomes and Use Protein as a Nutrient] [Re: Nutrient sensor in key growth-regulating metabolic pathway identified [Lysosomal amino acid transporter SLC38A9 signals arginine sufficiency to mTORC1]]
[SLC38A9 lysosomal arginine sensor; mTORC1 pathway] Key molecular link in major cell growth pathway: Findings point to new potential therapeutic target in pancreatic cancer [mTORC1 Activator SLC38A9 Is Required to Efflux Essential Amino Acids from Lysosomes and Use Protein as a Nutrient] [Re: Nutrient sensor in key growth-regulating metabolic pathway identified [Lysosomal amino acid transporter SLC38A9 signals arginine sufficiency to mTORC1]]
[SLC38A9 lysosomal arginine sensor; mTORC1 pathway] Key molecular link in major cell growth pathway: Findings point to new potential therapeutic target in pancreatic cancer [mTORC1 Activator SLC38A9 Is Required to Efflux Essential Amino Acids from Lysosomes and Use Protein as a Nutrient] [Re: Nutrient sensor in key growth-regulating metabolic pathway identified [Lysosomal amino acid transporter SLC38A9 signals arginine sufficiency to mTORC1]]
user@linux:~$ echo "Here is a String" Here is a String user@linux:~$
user@linux:~$ echo "Here is a String" | sed is a String user@linux:~$
user@linux:~$ echo "Here is a String" | sed Here is a user@linux:~$
user@linux:~$ echo "Here is a String" | sed -e is a user@linux:~$
find /path -type f -not -name "*.*" -exec mv "{}" "{}".jpg \;
find /path -type f -not -name "*.*" -print0 | xargs -0 rename
for f in $(find . -type f); do mv $f ${f}.jpg; done
$ bash last_ch.sh abcd* array.sh assign.sh date.sh dict.sh full_path.sh last_ch.sh
someone@mypc:~$ str="A random string*"; echo "$str" A random string* someone@mypc:~$ echo "${str:$((${ * someone@mypc:~$ echo "${str:$((${ g
JBoss [DOWN] GlassFish [UP] verylongprocessname [UP]
JBoss ------------------------------------------- [DOWN] GlassFish --------------------------------------- [UP] verylongprocessname ----------------------------- [UP]
pad=$(printf padlength=40 string2= for string1 in a aa aaaa aaaaaaaa do printf printf printf string2=${string2:1} done
a--------------------------------bbbbbbb aa--------------------------------bbbbbb aaaa-------------------------------bbbbb aaaaaaaa----------------------------bbbb
a---------------------------------------bbbbbbb aa--------------------------------------bbbbbb aaaa------------------------------------bbbbb aaaaaaaa--------------------------------bbbb
line= PROC_NAME= printf "%s %s [UP]\n" $PROC_NAME "${line:${ PROC_NAME= printf "%s %s [UP]\n" $PROC_NAME "${line:${
abc ------------------------------------- [UP] abcdef ---------------------------------- [UP]
echo -e "---------------------------- [UP]\r$PROC_NAME "
A="[>---------------------<]"; # B="A very long header"; echo "${A:0:-${ B="shrt hdr" ; echo "${A:0:-${
[>----- A very long header [>--------------- shrt hdr # B="A very long header"; echo "${A:${ B="shrt hdr" ; echo "${A:${
-----<] A very long header ---------------<] shrt hdr
$ PROC_NAME="JBoss" $ PROC_STATUS="UP" $ printf "%-.20s [%s]\n" "${PROC_NAME}................................" "$PROC_STATUS" JBoss............... [UP]
string1=abc string2=123456 echo -en "$string1 " for ((i=0; i< (25 - ${ echo -e " $string2"
$ { echo JBoss DOWN; echo GlassFish UP; } | while read PROC STATUS; do echo -n "$PROC "; printf "%$((48-${ JBoss -------------------------------------------- [DOWN] GlassFish ---------------------------------------- [UP]
PAD="--------------------------------------------------" LINE=$(printf "%s %s" "$PROC_NAME" "$PAD" | cut -c 1-${ printf "%s %s\n" "$LINE" "$PROC_STATUS"
function create-console-spanner() { local spanner=""; eval printf -v spanner \ printf "%s %s %s" "$1" "$spanner" "$2"; }
declare -A PAINT=([none]=`tput sgr0` [bold]=`tput bold` [black]=`tput setaf 0` [red]=`tput setaf 1` [green]=`tput setaf 2` [yellow]=`tput setaf 3` [blue]=`tput setaf 4` [magenta]=`tput setaf 5` [cyan]=`tput setaf 6` [white]=`tput setaf 7`); declare -i PAINT_ACTIVE=1; function paint-replace() { local contents=$(cat) echo "${contents } source <(cat <<EOF function paint-activate() { echo "\$@" | $(for k in ${!PAINT[@]}; do echo -n paint-replace \"\&$k\;\" \"\${PAINT[$k]}\" \|; done) cat; } EOF ) source <(cat <<EOF function paint-deactivate(){ echo "\$@" | $(for k in ${!PAINT[@]}; do echo -n paint-replace \"\&$k\;\" \"\" \|; done) cat; } EOF ) function paint-get-spanner() { (( $ declare -i l=$(( `tput cols` - ${2})) eval printf \ } function paint-span() { local left_format=$1 right_format=$3 local left_length=$(paint-format -l "$left_format") right_length=$(paint-format -l "$right_format") paint-format "$left_format"; paint-get-spanner "$2" $(( left_length + right_length)); paint-format "$right_format"; } function paint-format() { local VAR="" OPTIONS= local -i MODE=0 PRINT_FILE=0 PRINT_VAR=1 PRINT_SIZE=2; while [[ "${1:0:2}" =~ ^-[vl]$ ]]; do if [[ "$1" == "-v" ]]; then OPTIONS=" -v $2"; MODE=$PRINT_VAR; shift 2; continue; fi; if [[ "$1" == "-l" ]]; then OPTIONS=" -v VAR"; MODE=$PRINT_SIZE; shift 1; continue; fi; done; OPTIONS+=" --" local format="$1"; shift; if (( MODE != PRINT_SIZE && PAINT_ACTIVE )); then format=$(paint-activate "$format&none;") else format=$(paint-deactivate "$format") fi printf $OPTIONS "${format}" "$@"; (( MODE == PRINT_SIZE )) && printf "%i\n" "${ } function paint-show-pallette() { local -i PAINT_ACTIVE=1 paint-format "Normal: &red;red &green;green &blue;blue &magenta;magenta &yellow;yellow &cyan;cyan &white;white &black;black\n"; paint-format " Bold: &bold;&red;red &green;green &blue;blue &magenta;magenta &yellow;yellow &cyan;cyan &white;white &black;black\n"; }
COLUMNS="${COLUMNS:=80}" padlength="${1:-$COLUMNS}" pad=$(printf string2= for string1 in a aa aaaa aaaaaaaa do printf printf printf string2=${string2:1} done
if [ $SUDO_USER ]; then user=$SUDO_USER; else user=`whoami`; fi
jobname="job_201312161447_0003" jobname_pre=${jobname:0:16} jobname_post=${jobname:17}
FILENAME=/my/complex/path/name.ext NEWNAME=${FILENAME%ext}new
list($var1, $var2, $var3) = function_that_returns_a_three_element_array() ;
(var1 var2 var3) = ( `myBashFuntion param1 param2` )
array = ( `myBashFuntion param1 param2` ) echo ${array[0]} ${array[1]} ${array[2]}
var1 = ${array[0]} ; var2 = ${array[1]} ; var3 = ${array[2]}
read a[{1..3}] <<< $(echo 2 4 6); echo "${a[1]}|${a[2]}|${a[3]}"
DATE_ARRAY=(`echo $2 | sed -e MONTH=(`echo ${DATE_ARRAY[0]}`) DAY=(`echo ${DATE_ARRAY[1]}`) YEAR=(`echo ${DATE_ARRAY[2]}`)
read month day year << DATE_COMMAND $(date "+%m %d %Y") DATE_COMMAND echo $month $day $year
day=n/a; month=n/a; year=n/a date "+%d %m %Y" | { read day month year ; echo $day $month $year; } echo $day $month $year
function identity() { "$@" } set -x identity identity identity identity identity echo Hello \"World\"
mkfifo ./p diff - p <<< "$string1" & echo "$string2" > p
$ cmp -bl <(echo -n abcda) <(echo -n aqcde) 2 142 b 161 q 5 141 a 145 e
string_equals() { if [[ ! $1 = $2 ]]; then error_message="Expected return 1 fi }
if [[ $error_message ]]; then printf unset -v error_message fi
/home/user1> var="" /home/user1> echo $var /home/user1> set -u /home/user1> echo $var /home/user1> unset var /home/user1> echo $var -bash: var: unbound variable
$ foo=(4 5 6) $ foo[2]= $ echo ${ 3 $ unset foo[2] $ echo ${ 2
isunset() { [[ "${!1}" != isset() { [ -z "$(isunset "$1")" ] && echo 1; }
$ unset foo; [[ $(isunset foo) ]] && echo "It It $ foo= ; [[ $(isunset foo) ]] && echo "It It $ foo=bar ; [[ $(isunset foo) ]] && echo "It It
$teststr = "test1\n" $teststr .= "test2\n" echo = "$teststr"
$ string="test" $ string="${string}test2" $ echo $string testtest2
message="some text" message="$message add some more" echo $message
msg1=${1} msg2=${2} concatString=$msg1"$msg2" concatString2="$msg1$msg2" echo $concatString echo $concatString2
data |___ | abc |____incoming def |____incoming |____processed 123 |___incoming 456 |___incoming |___processed
find /home/feeds/data -type f -not -path "*def/incoming*" -not -path "*456/incoming*"
find . -regex-type posix-extended -regex ".*def/incoming.*|.*456/incoming.*" -prune -o -print
$ find -version GNU find version 4.2.27 Features enabled: D_TYPE O_NOFOLLOW(enabled) LEAF_OPTIMISATION SELINUX
find $(INP_PATH} -type f -ls |grep -v "${INP_PATH}/.*/"
current_date_time="`date +%Y%m%d%H%M%S`"; echo $current_date_time;
current_date_time="`date +%Y%m%d%H%M%S`"; echo $current_date_time;
current_date_time="`date "+%Y-%m-%d %H:%M:%S"`"; echo $current_date_time;
$ show_time() { local format= $ show_time 20180724003251
PROMPT_COMMAND If set, the value is interpreted as a command to execute before the printing of each primary prompt ($PS1).
PROMPT_COMMAND= BRANCH="";\ ERRMSG="";\ if [[ $RET != 0 ]]; then\ ERRMSG=" $RET";\ fi;\ if git branch &>/dev/null; then\ BRANCH=$(git branch 2>/dev/null | grep \* | cut -d " " -f 2);\ fi; PS1="$GREEN\u@\h $BLUE\W $CYAN$BRANCH$RED$ERRMSG \$ $LIGHT_GRAY";'
sashan@dhcp-au-122 Documents $ false sashan@dhcp-au-122 Documents 1 $
GREEN="\[\033[0;32m\]" CYAN="\[\033[0;36m\]" RED="\[\033[0;31m\]" PURPLE="\[\033[0;35m\]" BROWN="\[\033[0;33m\]" LIGHT_GRAY="\[\033[0;37m\]" LIGHT_BLUE="\[\033[1;34m\]" LIGHT_GREEN="\[\033[1;32m\]" LIGHT_CYAN="\[\033[1;36m\]" LIGHT_RED="\[\033[1;31m\]" LIGHT_PURPLE="\[\033[1;35m\]" YELLOW="\[\033[1;33m\]" WHITE="\[\033[1;37m\]" RESTORE="\[\033[0m\]" if [ -z $SCHROOT_CHROOT_NAME ]; then SCHROOT_CHROOT_NAME=" " fi BRANCH="" ERRMSG="" RET=$1 if [[ $RET != 0 ]]; then ERRMSG=" $RET" fi if which git &>/dev/null; then BRANCH=$(git branch 2>/dev/null | grep \* | cut -d " " -f 2) else BRANCH="(git not installed)" fi echo "${GREEN}\u@\h${SCHROOT_CHROOT_NAME}${BLUE}\w \ ${CYAN}${BRANCH}${RED}${ERRMSG} \$ $RESTORE"
function prompt_command { RET=$? export PS1=$(~/.bash_prompt_command $RET) } PROMPT_DIRTRIM=3 export PROMPT_COMMAND=prompt_command
function prompt_command { export PS1=$(~/bin/bash_prompt) } export PROMPT_COMMAND=prompt_command
set -e errors=0 results=$($script_under_test $args<<ENDTSTDATA # ENDTSTDATA ) [ "$?" -ne 0 ] || { echo "Test returned error code $?" 2>&1 let errors+=1 } echo "$results" | grep -q $expected1 || { echo "Test Failed. Expected $expected1" let errors+=1 } [ "$errors" -gt 0 ] && { echo "There were $errors errors found" exit 1 }
$ ./do-some-work.sh > /dev/null $ grep -Fxq "PASSWORD = YES
[nsushkin@fulton support]$ jps -m 2120 Main --userdir /home/nsushkin/.netbeans/7.0 --branding nb 26546 charles.jar 17600 Jps -m
2472 com.intellij.idea.Main 11111 sun.tools.jps.Jps 9030 play.server.Server 2752 org.jetbrains.idea.maven.server.RemoteMavenServer
ps axuwww | grep java | grep -v grep | sed do something_another $something done
ps ww -f -C java | grep "fully.qualified.name.of.class"
PID USER CMD 11251 userb org.apache.zookeeper.server.quorum.QuorumPeerMain ../config/zookeeper.properties 19574 userb com.intellij.idea.Main 28807 root org.apache.nifi.bootstrap.RunNiFi run 28829 root org.apache.nifi.NiFi
for i in *.png ; do mv "$i" "${i/remove_me*.png/.png}" ; done
for file in Name*.png; do mv "$file" "01_$file"; done
$ string="word1 word2" $ set -- $string $ echo $1 word1 $ echo $2 word2
echo "word1 word2" | while read -a array; do echo "${array[0]}" ; done
echo "word1 word2 word3" | { read first rest ; echo $first ; }
$ string="word1 word2" $ echo ${string/%\ */} word1
$ string=" word1 word2" $ [[ ${string} =~ \ *([^\ ]*) ]] $ echo ${BASH_REMATCH[1]} word1
string="word1 word2" read -r first _ <<< "$string" printf
echo "..." | { read -a array ; echo ${array[0]} ; }
method time -------------------------------- 1. awk 9.2ms 2. set 11.6ms (1.26 * "1") 3. read -a 11.7ms (1.27 * "1") 4. read 13.6ms (1.48 * "1")
VARIABLE=" first_word_with_spaces_before_and_after another_word " echo $VARIABLE | sed
dos2unix winfile.sh bash: dos2unix: command not found
VAR_NAME = $(hostname) echo "the hostname is ${VAR_NAME}"
if [[ "true" ]]; then &nbsp;highlight --syntax js "var i = 0;" fi
if [[ "true" ]]; then highlight --syntax js "var i = 0;" fi
$ ssh-keygen -t rsa -b 4096 -C "comment" -P "examplePassphrase" -f "desired pathAndName" -q
function print_ui_hosts { local sql = "select ........." print_sql "$ sql" }
read -d select c1, c2 from foo where c1= EOF echo "$sql"
sql=" SELECT c1, c2 from Table1, Table2 where ... "
sql=" \ SELECT c1, c2 \ from Table1, ${TABLE2} \ where ... \ "
$ ./test.sh The text from the example function is: Welcome dev: Would you "like" to know how many There are " 38" files in /tmp, according to the "wc" command
function text1() { COUNT=$(\ls /tmp | wc -l) cat <<EOF $1 Would you "like" to know how many There are "$COUNT" files in /tmp, according to the "wc" command EOF } function main() { OUT=$(text1 "Welcome dev:") echo "The text from the example function is: $OUT" } main
oneLine=$(printf %s \ a \ " b " \ $ ) multiLine=$(printf a \ " b " \ $ )
sudo sed -i.bak s/Parallels_Desktop_Overlay_128/Parallels_Desktop_Overlay_000/g /Applications/Parallels\ Desktop.app/Contents/MacOS/prl_client_app
==> ./recipes/default.rb <== DOWNLOAD_DIR = MYSQL_DOWNLOAD_URL = MYSQL_DOWNLOAD_FILE = " package "mysql-server-5.5" ... ==> ./templates/default/my.cnf.erb <== # # ... ==> ./templates/default/mysql56.sh.erb <== PATH=/opt/mysql/server-5.6/bin:$PATH
excluded="spec\|node_modules\|README\|lib\|docs\|csv\|XLS\|json\|png" countLines(){ total=0 for file in `find . -mindepth 1 -name "*.*" |grep -v "$excluded"`; do numLines=`cat $file | sed total=$(($total + $numLines)) echo " " $numLines $file done echo " " $total in total } echo Source code files: countLines echo Unit tests: cd spec countLines
Source code files: 2 ./buildDocs.sh 24 ./countLines.sh 15 ./css/dashboard.css 53 ./data/un_population/provenance/preprocess.js 19 ./index.html 5 ./server/server.js 2 ./server/startServer.sh 24 ./SpecRunner.html 34 ./src/computeLayout.js 60 ./src/configDiff.js 18 ./src/dashboardMirror.js 37 ./src/dashboardScaffold.js 14 ./src/data.js 68 ./src/dummyVis.js 27 ./src/layout.js 28 ./src/links.js 5 ./src/main.js 52 ./src/processActions.js 86 ./src/timeline.js 73 ./src/udc.js 18 ./src/wire.js 664 in total Unit tests: 230 ./ComputeLayoutSpec.js 134 ./ConfigDiffSpec.js 134 ./ProcessActionsSpec.js 84 ./UDCSpec.js 149 ./WireSpec.js 731 in total
CONFIG=/home/user/config.inc API=/home/user/api.txt sed -e "\$a $API" > $CONFIG
[mandy@root]$ a=11 [mandy@root]$ b=20 [mandy@root]$ c=30 [mandy@root]$ echo $a; : echo $b ; echo $c 10 30
line 4: syntax error near unexpected token `fi' line 4: `fi'
verbosity=: while getopts v OPT ; do case $OPT in v) verbosity=/bin/realpath ;; *) exit "Cancelled" ;; esac done for i in * ; do echo $i $($verbosity $i) done $ example file $ example -v file /home/me/file
: << This part of the script is a commented out EOF
> alias alert_with_args= > alias alert= > alert_with_args blabla hello there blabla > alert blabla hello there
shopt -s expand_aliases dbg=${DBG:- function _log_dbg { echo >&2 "[DBG] $@" } log_dbg_hook= [ "$dbg" ] && log_dbg_hook= alias log_dbg=$log_dbg_hook echo "Testing noop alias..." log_dbg
function chgpath() { if [[ "$toC" == / && "$fromC" == / ]] || [[ "$toC" != / && "$fromC" != / ]] then true else return 1 fi
function chgpath() { if [[ "$toC" != / || "$fromC" == / ]] && [[ "$toC" == / || "$fromC" != / ]] then return 1 fi
if [[ "$toC" == / && "$fromC" == / ]] || [[ "$toC" != / && "$fromC" != / ]] then cdPath=$(chgPath pathA pathB)
/usr/bin/env "interpreter --load-libA --load-libB" "/path/to/script"
/usr/bin/env interpreter --load-libA --load-libB "/path/to/script"
/usr/bin/env interpreter --load-libA --load-libB "/path/to/script"
cat filename | while read line do read input; echo $input; done
{ cat notify-finished | while read line; do read -u 3 input echo "$input" done; } 3<&0
while read line; do read -u 3 input echo "$input" done 3<&0 <notify-finished
while read line <&3; do read input echo "$input" done 3<notify-finished
for line in $(cat filename); do read input echo $input; done
for line in $(cat /etc/passwd); do read input echo $input; echo "[$line]" done
echo "Enter the Programs you want to run:" > ${PROGRAM_LIST} while read PROGRAM_ENTRY do if [ ! -s ${PROGRAM_ENTRY} ] then echo ${PROGRAM_ENTRY} >> ${PROGRAM_LIST} else break fi done
ps -C script.name.sh > /dev/null 2>&1 || ./script.name.sh
[Terminal [Terminal [Terminal [Terminal [Terminal [Terminal [Terminal [Terminal
lockfile -r 0 /tmp/the.lock || exit 1 rm -f /tmp/the.lock
# LOCKFILE="/var/lock/`basename $0`" LOCKFD=99 _lock() { flock -$1 $LOCKFD; } _no_more_locking() { _lock u; _lock xn && rm -f $LOCKFILE; } _prepare_locking() { eval "exec $LOCKFD>\"$LOCKFILE\""; trap _no_more_locking EXIT; } _prepare_locking exlock_now() { _lock xn; } exlock() { _lock x; } shlock() { _lock s; } unlock() { _lock u; } exlock_now || exit 1
if ! (set -o noclobber ; echo > /tmp/global.lock) ; then exit 1 fi
function lockfile_waithold() { declare -ir time_beg=$(date declare -ir time_max=7140 while ! \ (set -o noclobber ; \ echo -e "DATE:$(date)\nUSER:$(whoami)\nPID:$$" > /tmp/global.lock \ ) 2>/dev/null do if [ $(($(date echo "Error: waited too long for lock file /tmp/global.lock" 1>&2 return 1 fi sleep 1 done return 0 } function lockfile_release() { rm -f /tmp/global.lock } if ! lockfile_waithold ; then exit 1 fi trap lockfile_release EXIT
. my_script_control.ksh my_start_me_up lockfile_name; trap "rm -f $lockfile_name; exit" 0 2 3 15
[[ $(lsof -t $0| wc -l) > 1 ]] && echo "At least one of $0 is running"
currsh=$0 currpid=$$ runpid=$(lsof -t $currsh| paste -s -d " ") if [[ $runpid == $currpid ]] then sleep 11111111111111111 else echo -e "\nPID($runpid)($currpid) ::: At least one of \"$currsh\" is running !!!\n" false exit 1 fi
[ "$(pgrep -fn $0)" -ne "$(pgrep -fo $0)" ] && echo "At least 2 copies of $0 are running"
user_id_num=$(id -u) pid_file="/tmp/foobar-$user_id_num/foobar-$user_id_num.pid" lock_file="/tmp/foobar-$user_id_num/running.lock" ps_id=$$ function alertRunningPS () { local PID=$(cat "$pid_file" 2> /dev/null) echo "Lockfile present. ps id file: $PID" echo "Checking if process is actually running or something left over from crash..." if kill -0 $PID 2> /dev/null; then echo "Already running, exiting" exit 1 else echo "Not running, removing lock and continuing" rm -f "$lock_file" lockfile -r 0 "$lock_file" fi } echo "Hello, checking some stuff before locking stuff" mkdir -p /tmp/foobar-$user_id_num lockfile -r 0 "$lock_file" || alertRunningPS echo -n $ps_id > "$pid_file" echo "Running stuff in ONE ps" sleep 30s rm -f "$lock_file" rm -f "$pid_file" exit 0
( pidof -s -o ps xo pid= | tr -cd ) | sort | uniq -d
script_name="myscript.sh" lock="/var/run/${script_name}.pid" if [[ -e "${lock}" ]]; then pid=$(cat ${lock}) if [[ -e /proc/${pid} ]]; then echo "${script_name}: Process ${pid} is still running, exiting." exit 1 else rm -f ${lock} fi fi trap "rm -f ${lock}; exit $?" INT TERM EXIT echo "$$" > ${lock}
echo Create the snapshots echo echo Snapshot created
printf "Create the snapshots\n\nSnapshot created\n"
rm -rf ~/myfolder1/$1/anotherfolder rm -rf ~/myfolder2/$1/yetanotherfolder rm -rf ~/myfolder3/$1/thisisafolder
die () { echo >&2 "$@" exit 1 } [ "$ echo $1 | grep -E -q while read dir do [ -d "$dir" ] || die "Directory $dir does not exist" rm -rf "$dir" done <<EOF ~/myfolder1/$1/anotherfolder ~/myfolder2/$1/yetanotherfolder ~/myfolder3/$1/thisisafolder EOF
[[ -d $1 && $1 != *[^0-9]* ]] || { echo "Invalid input." >&2; exit 1; } rm -rf ~/foo/"$1"/bar ...
if [ "$1" = "" ] then echo "Usage: $0 <id number to be cleaned up>" exit fi
if [[ -z "$@" ]]; then echo >&2 "You must supply an argument!" exit 1 elif [[ ! -d "$@" ]]; then echo >&2 "$@ is not a valid directory!" exit 1 fi
if [ -z $1 ] ; then echo "First parameter needed!" && exit 1; fi if [ -z $2 ] ; then echo "Second parameter needed!" && exit 2; fi
MYVAL=$(echo ${1} | awk MYVAL=${MYVAL:?"Usage - testparms <number>"} echo ${MYVAL}
$ ./testparams.sh Usage - testparms <number> $ ./testparams.sh 1234 1234 $ ./testparams.sh abcd Usage - testparms <number>
ps cax | grep httpd > /dev/null if [ $? -eq 0 ]; then echo "Process is running." else echo "Process is not running." fi
PROCESS=$1 PIDS=`ps cax | grep $PROCESS | grep -o if [ -z "$PIDS" ]; then echo "Process not running." 1>&2 exit 1 else for PID in $PIDS; do echo $PID done fi
ps cax | grep httpd if [ $? -eq 0 ]; then echo "Process is running." else echo "Process is not running." fi
command="httpd" running=`ps ax | grep -v grep | grep $command | wc -l` if [ running -gt 0 ]; then echo "Command is running" else echo "Command is not running" fi
ps ax | grep -v grep | grep java | grep java.util.logging.config.file=logging.properties | wc -l
PATH=/usr/ucb:${PATH} ps aux | grep httpd | grep -v grep
kill -0 $(pidof mysql) 2> /dev/null || echo "Mysql ain
kill -0 $(cat pid_stored) 2> /dev/null || echo "Mysql ain
FILE="/tmp/myapp.pid" if [ -f $FILE ]; then PID=$(cat $FILE) else PID=1 fi ps -o pid= -p $PID if [ $? -eq 0 ]; then echo "Process already running." else echo "Starting process." run_my_app & echo $! > $FILE fi
egrep -m1 "mysqld$|httpd$" /proc/[0-9]*/status | cut -d
ps -e -o args= | awk if(!match($1,/^\[.*\]$/)){sub(".*/","",$1)} if($1==cmd){c++} }END{print c}
isProcessRunning() { if [ "${1-}" = "-q" ]; then local quiet=1; shift else local quiet=0; fi ps -e -o pid,args= | awk name=$2 if(name !~ /^\[.*\]$/){sub(".*/","",name)} if(name==cmd){status=0; if(q){exit}else{print $0}} }END{exit status} } process= printf "Process \"${process}\" is " if isProcessRunning -q "$process" then printf "running.\n" else printf "not running.\n"; fi printf "Listing of matching processes (PID and process name with command line arguments):\n" isProcessRunning "$process"
function isRunning() { for i in $(pidof $1); do cat /proc/$i/cmdline | tr if [ $? -eq 0 ]; then return 0 fi done return 1 } isRunning java "-Djava.util.logging.config.file=logging.properties" if [ $? -ne 0 ]; then echo "not running, starting..." fi
process="$(pidof YOURPROCESSHERE|tr -d if [[ -z "${process echo "Process is not running." else echo "Process is running." fi
isPidRunning() { cmd=` PATH=\`getconf PATH\` export PATH ps -e -o pid= -o comm= | awk ` [ -n "$cmd" ] && printf "%s is running\n%s\n\n" "$1" "$cmd" || printf "%s is not running\n\n" $1 [ -n "$cmd" ] }
$ isPidRunning httpd httpd is running 586 /usr/apache/bin/httpd 588 /usr/apache/bin/httpd $ isPidRunning ksh ksh is running 5230 ksh $ isPidRunning bash bash is not running
$ cat /1.png ?PNG (with a heap load of random characters)
$ curl -F "fileupload=@/1.png" http: <links> <error id="wrong_file_type">Wrong file type detected for file 1.png:application/octet-stream</error> </links>
$ curl -F "fileupload=@/1.png;type=image/png" http:
> file --mime-type image.png image.png: image/png > file -b --mime-type image.png image/png > file -i FILE_NAME image.png: image/png; charset=binary
$ xdg-mime query filetype subtitles.srt application/x-subrip $ file --mime-type subtitles.srt subtitles.srt: text/plain
$ env TERM=xterm SHELL=/bin/bash USER=joksnet USERNAME=joksnet DESKTOP_SESSION=gnome PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games PWD=/home/joksnet GDM_KEYBOARD_LAYOUT=us LANG=en_US.utf8 HOME=/home/joksnet DISPLAY=:0.0 COLORTERM=gnome-terminal _=/usr/bin/env
SET(P) POSIX Programmer’s Manual SET(P) NAME set - set or unset options and positional parameters SYNOPSIS set [-abCefmnuvx][-h][-o option][argument...] set [+abCefmnuvx][+h][+o option][argument...] set -- [argument...] set -o set +o DESCRIPTION If no options or arguments are specified, set shall write the names and values of all shell variables in the collation sequence of the current locale. Each name shall start on a separate line, using the format: "%s=%s\n", <name>, <value> The value string shall be written with appropriate quoting; see the description of shell quoting in Quoting . The output shall be suitable for reinput to the shell, setting or resetting, as far as possible, the variables that are currently set; read-only variables cannot be reset.
done=0 while : ; do ... if [ "$done" -ne 0 ]; then break fi done
while true ; do ... if [ something ]; then break fi done
/dev/abc-scanner /dev/abc-cash ... ... ... /dev/.udev/names/abc-scanner /dev/.udev/names/abc-cash
from __future__ import print_function import os, sys try: input=raw_input except NameError: pass def main(): while True: cmd = input( args = cmd.split() if not args: continue cpid = os.fork() if cpid == 0: os.execl(args[0], *args) else: os.waitpid(cpid, 0) if __name__ == main()
1. Expand words. 2. Assume the first word is a command. 3. Execute that command with the following words as arguments.
$ foo() { echo $x; } $ bar() { local x; echo $x; } $ foo $ bar $ x=123 $ foo 123 $ bar $ …
$ x=123 $ ( echo $x ) 123 $ bash -c $ export x $ bash -c 123 $ y=123 bash -c 123
$ foo() { > local -x bar=123 > bash -c > } $ foo 123 $ echo $bar $
$ fail= $ set -x $ "${fail:0:-2}" Hello World + echo Hello World Hello World
$ foo=10+10 $ echo $foo 10+10 $ declare -i foo $ foo=$foo $ echo $foo 20 $ echo "${foo:0:1}" 2
$ bash -c > printf "\$%d => %s\n" "$i" "${@:i:1}" > done $1 => foo $2 => bar $3 => baz $ showpp() { > local i > for ((i=1;i<=$ > printf > done > } $ showpp foo bar baz $1 => foo $2 => bar $3 => baz $ showshift() { > shift 3 > showpp "$@" > } $ showshift foo bar baz biz quux xyzzy $1 => biz $2 => quux $3 => xyzzy
$ foo=( element0 element1 element2 ) $ bar[3]=element3 $ baz=( [12]=element12 [0]=element0 )
$ A=10/2 $ echo "A = $A" A = 10/2 $ B=1 $ let B="$B+1" $ echo "B = $B" B = 2 $ A=1024 $ B=${A/24/STRING01} $ echo "B = $B" B = 10STRING01 $ B=${A/24/STRING01} $ declare -i B $ echo "B = $B" B = 10STRING01 $ B=${B/STRING01/24} $ echo "B = $B" B = 1024 $ declare -i B=10/2 $ echo "B = $B" B = 5
abc.log.2012-03-14 abc.log.2012-03-27 abc.log.2012-03-28 abc.log.2012-03-29 abc.log.2012-03-30 abc.log.2012-04-02 abc.log.2012-04-04 abc.log.2012-04-05 abc.log.2012-04-09 abc.log.2012-04-10
rm -rf abc.log.2012-03-14 rm -rf abc.log.2012-03-27 rm -rf abc.log.2012-03-28
$ rm -rf abc.log.2012-03-14 abc.log.2012-03-27 abc.log.2012-03-28
$ rm -f abc.log.* $ rm -f abc.log.2012* $ rm -f abc.log.2012-0[123]*
$ ls | grep -i (check that the list is correct) $ rm -f $(!!)
[$]> rm abc.log.2012-03-14 abc.log.2012-03-27 abc.log.2012-03-28 abc.log.2012-03-29 abc.log.2012-03-30 abc.log.2012-04-02 abc.log.2012-04-04 abc.log.2012-04-05 abc.log.2012-04-09 abc.log.2012-04-10
for dir in Movies/* do (cd "$dir" && pwd|cut -d \/ -f5|tr -s exiftool * -t -s3 -ImageSize -FileType|tr -s echo "Movie $movies - $dir ADDED!" let movies=movies+1 done
for pc in $(seq 1 100); do echo -ne "$pc%\033[0K\r" sleep 1 done echo
while true; do COMMAND=$(timedatectl) echo "$COMMAND" sleep 3 LINES=$(echo "$COMMAND" | wc -l) for (( i=1; i <= $(($LINES)); i++ ));do tput cuu1 tput el done done
for load in $(seq 1 100); do echo -ne "$load % downloded ...\r" sleep 1 done echo "100" echo "Loaded ..."
for i in $(seq 1 50); do echo -ne "$i%\033[0K\r" sleep 50 done echo "ended"
funcc() { while true ; do for i in \| \/ \- \\ \| \/ \- \\; do echo -n -e "\r$1 $i " sleep 0.5 done [ -f /tmp/print-stat ] && break 2 done } funcc "Checking Kubectl" & &>/dev/null sleep 5 touch /tmp/print-stat echo -e "\rPrint Success "
A>A1(file1),A2 this is not empty beacuse of file1 B>B1(no file) this is empty C>C1,C2 this is empty
for dir in A B C; do [ -z "`find $dir -type f`" ] && echo "$dir is empty" done
./2047 ./2032 ./2049 ./2063 ./NRCP26LUCcct1/2039 ./NRCP26LUCcct1/2054 ./NRCP26LUCcct1/2075 ./NRCP26LUCcct1/2070
find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} +
find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} `;`
d=your/dir if [ x$(find "$d" -prune -empty) = x"$d" ] then echo "empty (directory or file)" else echo "contains files (or does not exist)" fi
d=your/dir if [ x$(find "$d" -prune -empty -type d) = x"$d" ] then echo "empty directory" else echo "contains files (or does not exist or is not a directory)" fi
> mkdir -v empty1 empty2 not_empty mkdir: created directory mkdir: created directory mkdir: created directory > touch not_empty/file > find empty1 empty2 not_empty -prune -empty empty1 empty2
files=$(shopt -s nullglob dotglob; echo your/dir/*) if (( ${ then echo "contains files" else echo "empty (or does not exist or is a file)" fi
if [ "$(ls -A your/dir)" ] then echo "contains files" else echo "empty (or does not exist or is a file)" fi
[[ "$(ls -A your/dir)" ]] && echo "contains files" || echo "empty or ..."
findempty() { find ${1:-.} -mindepth 1 -maxdepth 1 -type d | while read -r dir do if [[ -z "$(find "$dir" -mindepth 1 -type f)" ]] >/dev/null then findempty "$dir" echo "$dir" fi done }
test/ test/test2/ test/test2/test2.2/ test/test3/ test/test3/file
$ [ "$(ls -A /path/to/direcory)" ] && echo "not empty" || echo "its empty"
if [ "$(ls -A /path/to/direcory)" ]; then echo "its not empty" else echo "empty directory"
STARTTIME=$(date +%s) ENDTIME=$(date +%s) echo "It takes $($ENDTIME - $STARTTIME) seconds to complete this task..."
echo "It takes $(($ENDTIME - $STARTTIME)) seconds to complete this task..."
%% A literal ‘%’. %[p][l]R The elapsed time in seconds. %[p][l]U The number of CPU seconds spent in user mode. %[p][l]S The number of CPU seconds spent in system mode. %P The CPU percentage, computed as (%U + %S) / %R.
FORMATTING THE OUTPUT ... % A literal e Elapsed real (wall clock) time used by the process, in seconds.
start=$(date +%Y%m%d%H%M%S); for x in {1..5}; do echo $x; sleep 1; done; end=$(date +%Y%m%d%H%M%S); elapsed=$(($end-$start)); ftime=$(for((i=1;i<=$((${ do echo -n "-"; done; echo ${elapsed}); echo -e "Start : ${start}\nStop : ${end}\nElapsed: ${ftime}" Start : 20171108005304 Stop : 20171108005310 Elapsed: -------------6
time_elapsed(){ appstop=$1; appstart=$2 ss_strt=${appstart:12:2} ;ss_stop=${appstop:12:2} mm_strt=${appstart:10:2} ;mm_stop=${appstop:10:2} hh_strt=${appstart:8:2} ; hh_stop=${appstop:8:2} dd_strt=${appstart:6:2} ; dd_stop=${appstop:6:2} mh_strt=${appstart:4:2} ; mh_stop=${appstop:4:2} yy_strt=${appstart:0:4} ; yy_stop=${appstop:0:4} if [ "${ss_stop}" -lt "${ss_strt}" ]; then ss_stop=$((ss_stop+60)); mm_stop=$((mm_stop-1)); fi if [ "${mm_stop}" -lt "0" ]; then mm_stop=$((mm_stop+60)); hh_stop=$((hh_stop-1)); fi if [ "${mm_stop}" -lt "${mm_strt}" ]; then mm_stop=$((mm_stop+60)); hh_stop=$((hh_stop-1)); fi if [ "${hh_stop}" -lt "0" ]; then hh_stop=$((hh_stop+24)); dd_stop=$((dd_stop-1)); fi if [ "${hh_stop}" -lt "${hh_strt}" ]; then hh_stop=$((hh_stop+24)); dd_stop=$((dd_stop-1)); fi if [ "${dd_stop}" -lt "0" ]; then dd_stop=$((dd_stop+$(mh_days $mh_stop $yy_stop))); mh_stop=$((mh_stop-1)); fi if [ "${dd_stop}" -lt "${dd_strt}" ]; then dd_stop=$((dd_stop+$(mh_days $mh_stop $yy_stop))); mh_stop=$((mh_stop-1)); fi if [ "${mh_stop}" -lt "0" ]; then mh_stop=$((mh_stop+12)); yy_stop=$((yy_stop-1)); fi if [ "${mh_stop}" -lt "${mh_strt}" ]; then mh_stop=$((mh_stop+12)); yy_stop=$((yy_stop-1)); fi ss_espd=$((10 mm_espd=$((10 hh_espd=$((10 dd_espd=$((10 mh_espd=$((10 yy_espd=$((10 echo -e "${yy_espd}-${mh_espd}-${dd_espd} ${hh_espd}:${mm_espd}:${ss_espd}" } mh_days(){ mh_stop=$1; yy_stop=$2; case $mh_stop in [1,3,5,7,8,10,12]) mh_stop=31 ;; 2) (( !(yy_stop % 4) && (yy_stop % 100 || !(yy_stop % 400) ) )) && mh_stop=29 || mh_stop=28 ;; [4,6,9,11]) mh_stop=30 ;; esac return ${mh_stop} } appstart=$(date +%Y%m%d%H%M%S); read -p "Wait some time, then press nay-key..." key; appstop=$(date +%Y%m%d%H%M%S); elapsed=$(time_elapsed $appstop $appstart); echo -e "Start...: ${appstart:0:4}-${appstart:4:2}-${appstart:6:2} ${appstart:8:2}:${appstart:10:2}:${appstart:12:2}\nStop....: ${appstop:0:4}-${appstop:4:2}-${appstop:6:2} ${appstop:8:2}:${appstop:10:2}:${appstop:12:2}\n$(printf exit 0 -------------------------------------------- return Wait some time, then press nay-key... Start...: 2017-11-09 03:22:17 Stop....: 2017-11-09 03:22:18 ============================== Elapsed.: 0000-00-00 00:00:01
mv /path/subfolder/* /path/ mv /path/subfolder/.* /path/
mv: cannot move ‘/path/subfolder/.’ to /path/.’: Device or resource busy mv: cannot remove /path/subfolder/..’: Is a directory
$ mkdir test $ cd test $ touch a b c .hidden .hi .den $ ls -a . .. .den .hi .hidden a b c $ shopt -u dotglob $ ls * a b c $ for i in * ; do echo I found: $i ; done I found: a I found: b I found: c $ shopt -s dotglob $ ls * .den .hi .hidden a b c $ for i in * ; do echo I found: $i ; done I found: .den I found: .hi I found: .hidden I found: a I found: b I found: c
1) mv /path/subfolder/* /path/ ; mv /path/subfolder/.* /path/ 2) mv /path/subfolder/{.,}* /path/ 3) mv /source/path/{.[!.],}* /destination/path
yes | cp -rvp /source/directory /destination/directory/
$ echo a | egrep -o a $ echo ab | egrep -o ab $ echo abc | egrep -o abc $ echo abcd | egrep -o bcd
< eightygigsfile.sql parallel --pipe --block 10M grep -i -C 5
< eightygigsfile.sql parallel -k -j120% -n10 -m grep -F -i -C 5
${parameter:offset} ${parameter:offset:length} Substring Expansion. Expands to up to length characters of parameter starting at the character specified by offset. [...]
${parameter ${parameter ${parameter%%remove_matching_suffix}
${parameter:offset} ${parameter:offset:length} ${parameter:offset:length}
${parameter:+use this if param is NOT null} ${parameter:-use this if param is null} ${parameter:=use this and assign to param if param is null} ${parameter:?show this error if param is null}
ocrscript.sh -from /home/kristoffer/test.png -to /home/kristoffer/test.txt
export HOME=/home/kristoffer /usr/local/bin/abbyyocr9 -rl Swedish -if ???fromvalue??? -of ???tovalue??? 2>&1
./ocrscript.sh -from /home/kristoffer/test.png -to /home/kristoffer/test.txt
ocrscript.sh /home/kristoffer/test.png /home/kristoffer/test.txt
/usr/local/bin/abbyyocr9 -rl Swedish -if "$1" -of "$2" 2>&1
while getopts f:t: opts; do case ${opts} in f) FROM_VAL=${OPTARG} ;; t) TO_VAL=${OPTARG} ;; esac done
for ((i=1;i<=$ do if [ ${!i} = "-s" ] then ((i++)) var1=${!i}; elif [ ${!i} = "-log" ]; then ((i++)) logFile=${!i}; elif [ ${!i} = "-x" ]; then ((i++)) var2=${!i}; elif [ ${!i} = "-p" ]; then ((i++)) var3=${!i}; elif [ ${!i} = "-b" ]; then ((i++)) var4=${!i}; elif [ ${!i} = "-l" ]; then ((i++)) var5=${!i}; elif [ ${!i} = "-a" ]; then ((i++)) var6=${!i}; fi done;
/usr/local/bin/abbyyocr9 -rl Swedish -if "$1" -of "$2" 2>&1
./your_script.sh some_source_file.png destination_file.txt
$ bash foo.sh "a b" 1-a 2-b $ bash foo2.sh "a b" 1-a b 2-
for i in ./*.pkg ; do mv "$i" "${i/-[0-9.]*.pkg/.pkg}" ; done
for file in *.pkg ; do mv $file $(echo $file | rev | cut -f2- -d- | rev).pkg done
find . -type f -name "*.pkg" | sed -e while read nameA nameB; do mv $nameA $nameB; done
for i in ./*.pkg; do mv "$i" "${i%-[0-9.]*.pkg}.pkg" done
sedrename() { if [ $ sed_pattern=$1 shift for file in $(ls $@); do mv -v "$file" "$(sed $sed_pattern <<< $file)" done else echo "usage: $0 sed_pattern files..." fi }
sedrename before: ./Xft2-2.1.13.pkg ./jasper-1.900.1.pkg ./xorg-libXrandr-1.2.3.pkg after: ./Xft2.pkg ./jasper.pkg ./xorg-libXrandr.pkg
abspath () { case "$1" in /*)printf "%s\n" "$1";; *)printf "%s\n" "$PWD/$1";; esac; }
target="$(sed $sed_pattern <<< $file)" mkdir -p "$(dirname $(abspath $target))" mv -v "$file" "$target"
sedrename() { if [ $ sed_pattern=$1 shift for file in $(ls $@); do target="$(sed $sed_pattern <<< $file)" mkdir -p "$(dirname $(abspath $target))" mv -v "$file" "$target" done else echo "usage: $0 sed_pattern files..." fi }
sedrename before: ./Beethoven - Fur Elise.mp3 ./Beethoven - Moonlight Sonata.mp3 ./Beethoven - Ode to Joy.mp3 ./Beethoven - Rage Over the Lost Penny.mp3 after: ./Beethoven/Fur Elise.mp3 ./Beethoven/Moonlight Sonata.mp3 ./Beethoven/Ode to Joy.mp3 ./Beethoven/Rage Over the Lost Penny.mp3
sedrename before: ./Beethoven/Fur Elise.mp3 ./Beethoven/Moonlight Sonata.mp3 ./Beethoven/Ode to Joy.mp3 ./Beethoven/Rage Over the Lost Penny.mp3 after: ./Beethoven/ ./Fur Elise.mp3 ./Moonlight Sonata.mp3 ./Ode to Joy.mp3 ./Rage Over the Lost Penny.mp3
find . -type f -name "*.nzb.queued" | sed -ne "s/^\(\(.*\).nzb.queued\)$/mv -v \"\1\" \"\2.nzb\"/p" | sh
echo "my standard in" | cat <(echo "prefix... ") <(cat -) <(echo " ...suffix") prefix... my standard in ...suffix
echo input | while read line; do echo $line string; done
(echo input_one ;sleep 5; echo input_two ) | while read line; do echo $line string; done
(echo input_one ;sleep 5; echo input_two ) | sed "s/$/ string/g"
cat names | xargs -n 1 -J "%" echo "I like" "%" "because he is nice"
string 000 string 001 string 002 string 003 string 004
/tmp | +-- package | +-- src | | | +-- prog.js | +-- images | +-- icon.jpg
cp --parents src/prog.js images/icon.jpg /tmp/package
$ rsync -Rv src/prog.js images/icon.jpg /tmp/package/ images/ images/icon.jpg src/ src/prog.js sent 197 bytes received 76 bytes 546.00 bytes/sec total size is 0 speedup is 0.00
$ find /tmp/package /tmp/package /tmp/package/images /tmp/package/images/icon.jpg /tmp/package/src /tmp/package/src/prog.js
for f in `echo "src/prog.js images/icon.jpg"`; do cp $f /tmp/package/$f; done
v="src/prog.js images/icon.jpg"; for f in $v; do cp $f /tmp/package/$f; done
declare -a groups groups+=("CN=exampleexample,OU=exampleexample,OU=exampleexample,DC=example,DC=com") groups+=("CN=example example,OU=example example,OU=example example,DC=example,DC=com")
var="foo bar" for i in "$varbar"; do echo $i done var="foo bar" for i in "${var}bar"; do echo $i done
foo=("the first" "the second") for i in "${foo[@]}"; do echo $i done
foo=("the first" "the second") for i in ${foo[@]}; do echo $i done
$ var1=foo; var2=bar; var12=12 $ echo $var12 12 $ echo ${var1}2 foo2
$ foo=(1 2 3) $ echo $foo 1 $ echo ${foo[*]} 1 2 3 $ echo ${ 3
$ var1=foo; var2=bar; count_params () { echo $ $ count_params "$var1 $var2" 1 $ count_params "$var1" "$var2" 2
$ count_params () { echo $ $ set -- foo bar baz $ count_params "$@" 3 $ count_params "$*" 1
$ var=" abc def " $ printf "X%sX\n" $var XabcX XdefX $ printf "X%sX\n" "${var}" X abc def X $
$ groups=("abc def" " pqr xyz ") $ printf "X%sX\n" ${groups[@]} XabcX XdefX XpqrX XxyzX $ printf "X%sX\n" "${groups[@]}" Xabc defX X pqr xyz X $ printf "X%sX\n" $groups XabcX XdefX $ printf "X%sX\n" "$groups" Xabc defX $
${parameter:-word} ${parameter:=word} ${parameter:?word} … [read the section for more]
16.3.4 String tests ------------------- These options test string characteristics. You may need to quote STRING arguments for the shell. For example: test -n "$V" The quotes here prevent the wrong arguments from being passed to `test
$ unset a $ if [ -z $a ]; then echo unset; else echo set; fi unset $ if [ -n $a ]; then echo set; else echo unset; fi set $ unset a $ if [ -z "$a" ]; then echo unset; else echo set; fi unset $ if [ -n "$a" ]; then echo set; else echo unset; fi unset
pax> cat num1.txt ; x=$(cat num1.txt) line 1 line 2 pax> echo $x ; echo line 1 line 2 === line 1 line 2
pax> function count { ...> echo $# ...> } pax> count 1 2 3 3 pax> count a b c d 4 pax> count $x 4 pax> count "$x" 1
help mapfile mapfile < file.txt lines printf "%s" "${lines[@]}" mapfile -t < file.txt lines printf "%s\n" "${lines[@]}"
$ cat xx1 1 2 $ A=`cat xx1` $ echo $A 1 2 $ echo "|$IFS|" | |
$ IFSBAK=$IFS $ IFS=" " $ A=`cat xx1` $ echo $A 1 2 $ IFS=$IFSBAK
$ printf "test1\ntest2" > test.txt $ testvar=$(<test.txt) $ grep testvar <(set) testvar=$ $ echo "$testvar" text1 text2 $ printf "%b" "$testvar" text1 text2
content=( $(cat test.txt) ) a=0 while [ $a -le ${ do echo ${content[$a]} a=$[a+1] done
sh The original Bourne shell Present on every unix system ksh Original Korn shell Richer shell programming environment than sh csh Original C-shell C-like syntax; early versions buggy tcsh Enhanced C-shell User-friendly and less buggy csh implementation bash GNU Bourne-again shell Enhanced and free sh implementation zsh Z shell Enhanced, user-friendly ksh-like shell
if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi
alias la= alias l= alias lsd= alias h= alias hg= alias mv= alias zap= alias p= alias x= alias {ack,ak}= alias s= alias play= alias src= alias srs= alias raked= alias rvm-restart= alias rrg= alias rspecd= # WORKBASE="~/Dropbox/97_2012/work" alias work="cd $WORKBASE" alias code="cd $WORKBASE/ror/code" # WORKBASE_GIT="~/Dropnot" alias {dropnot,not}="cd $WORKBASE_GIT" alias {webs,ww}="cd $WORKBASE_GIT/webs" alias {setups,docs}="cd $WORKBASE_GIT/setups_and_docs" alias {linker,lnk}="cd $WORKBASE_GIT/webs/rails_v3/linker" # alias {gsta,gst}= alias {gbra,gb}= alias {gco,go}= alias {gcob,gob}= alias {gadd,ga}= alias {gcom,gc}= alias {gpul,gl}= alias {gpus,gh}= alias glom= alias ghom= alias gg= # alias v= # alias {ton,tn}= alias {tof,tf}= # alias {dmc,dm}= alias wf= alias ws=
$ cat test.sh testA() { echo "TEST A $1"; } testB() { echo "TEST B $2"; } "$@" $ bash test.sh $ bash test.sh testA TEST A $ bash test.sh testA arg1 arg2 TEST A arg1 $ bash test.sh testB arg1 arg2 TEST B arg2
if declare -f "$1" > /dev/null then "$@" else echo " exit 1 fi
[me@home] echo -n "value" | openssl dgst -sha1 -hmac "key" 57443a4c052350a44638835d64fd66822f813319
[me@home] echo -n "value" | openssl sha1 -hmac "key" 57443a4c052350a44638835d64fd66822f813319
[me@home]$ echo 57443a4c052350a44638835d64fd66822f813319
function hash_hmac { digest="$1" data="$2" key="$3" shift 3 echo -n "$data" | openssl dgst "-$digest" -hmac "$key" "$@" } hash_hmac "sha1" "value" "key" hash_hmac "sha1" "value" "key" -binary | base64 hash_hmac "md5" "value" "key"
$ echo -n "$data" | openssl dgst "-$digest" -hmac "$key" | sed -e
$ echo -n "$data" | openssl dgst "-$digest" -mac HMAC -macopt "hexkey:$key" | sed -e
var = "text,text,text,text" num = `expr match $var [,]` echo "$num"
string="text,text,text,text" char="," awk -F"${char}"
var="text,text,text,text" res="${var echo "$res" echo "${
var="text,text,text,text" num=$(echo "${var}" | awk -F, echo "${num}"
main() { foo bar baz } foo() { } bar() { } baz() { } main "$@"
[alias] co = checkout st = status ci = commit br = branch df = diff
% loadkeys keycode 88 = F12 string F12 = "foobar" %
while true ; do echo -e "HTTP/1.1 200 OK\n\n $(date)" | nc -l -p 1500 ; done
while true ; do nc -l -p 1500 -e /path/to/yourprogram ; done
$ nano test echo "************PRINT SOME TEXT***************\n" echo "Hello World!!!" echo "\n" echo "Resources:" vmstat -S M echo "\n" echo "Addresses:" echo "$(ifconfig)" echo "\n" echo "$(gpio readall)"
************PRINT SOME TEXT*************** Hello World!!! Resources: procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu---- r b swpd free buff cache si so bi bo in cs us sy id wa 0 0 0 314 18 78 0 0 2 1 306 31 0 0 100 0 Addresses: eth0 Link encap:Ethernet HWaddr b8:27:eb:86:e8:c5 inet addr:192.168.1.83 Bcast:192.168.1.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:27734 errors:0 dropped:0 overruns:0 frame:0 TX packets:26393 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:1924720 (1.8 MiB) TX bytes:3841998 (3.6 MiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) GPIOs: +----------+-Rev2-+------+--------+------+-------+ | wiringPi | GPIO | Phys | Name | Mode | Value | +----------+------+------+--------+------+-------+ | 0 | 17 | 11 | GPIO 0 | IN | Low | | 1 | 18 | 12 | GPIO 1 | IN | Low | | 2 | 27 | 13 | GPIO 2 | IN | Low | | 3 | 22 | 15 | GPIO 3 | IN | Low | | 4 | 23 | 16 | GPIO 4 | IN | Low | | 5 | 24 | 18 | GPIO 5 | IN | Low | | 6 | 25 | 22 | GPIO 6 | IN | Low | | 7 | 4 | 7 | GPIO 7 | IN | Low | | 8 | 2 | 3 | SDA | IN | High | | 9 | 3 | 5 | SCL | IN | High | | 10 | 8 | 24 | CE0 | IN | Low | | 11 | 7 | 26 | CE1 | IN | Low | | 12 | 10 | 19 | MOSI | IN | Low | | 13 | 9 | 21 | MISO | IN | Low | | 14 | 11 | 23 | SCLK | IN | Low | | 15 | 14 | 8 | TxD | ALT0 | High | | 16 | 15 | 10 | RxD | ALT0 | High | | 17 | 28 | 3 | GPIO 8 | ALT2 | Low | | 18 | 29 | 4 | GPIO 9 | ALT2 | Low | | 19 | 30 | 5 | GPIO10 | ALT2 | Low | | 20 | 31 | 6 | GPIO11 | ALT2 | Low | +----------+------+------+--------+------+-------+
while true; do echo -e "HTTP/1.1 200 OK\n\n $(date)" | nc -l -p 1500 -q 1 done
TCP session is established. Browser Request Header: GET / HTTP/1.1 Browser Request Header: Host: www.google.com Browser Request Header: \n Server Response Header: HTTP/1.1 200 OK Server Response Header: Content-Type: text/html Server Response Header: Content-Length: 24 Server Response Header: \n Server Message Body: <html>sample html</html> Server Message Body: \n The server closes the TCP session.
user@machine:/usr/local/bin x=0; Log=$( echo -n "["$(date "+%F %T %Z")"] $REMOTE_HOST ")$( while read I[$x] && [ ${ echo -n done ; ); echo $Log >> /var/log/bash_httpd Message_Body=$(echo -en echo -en "HTTP/1.0 200 OK\nContent-Type: text/html\nContent-Length: ${
METHOD=$(echo ${I[0]} |cut -d" " -f1) REQUEST=$(echo ${I[0]} |cut -d" " -f2) HTTP_VERSION=$(echo ${I[0]} |cut -d" " -f3) If METHOD = "GET" ]; then case "$REQUEST" in "/") Message_Body="HTML formatted home page stuff" ;; /who) Message_Body="HTML formatted results of who" ;; /ps) Message_Body="HTML formatted results of ps" ;; *) Message_Body= "Error Page not found header and content" ;; esac fi
rm -f out mkfifo out trap "rm -f out" EXIT while true do cat out | nc -l 1500 > >( export REQUEST= while read -r line do line=$(echo "$line" | tr -d if echo "$line" | grep -qE then REQUEST=$(echo "$line" | cut -d elif [ -z "$line" ] then ./a_script.sh > out fi done ) done
echo -e "HTTP/1.1 200 OK\r" echo "Content-type: text/html" echo date
admin@server:~$ while true; do (echo -e GET / HTTP/1.1 Host: 172.16.2.6:8080 User-Agent: curl/7.48.0 Accept: */* GET / HTTP/1.1 Host: 172.16.2.6:8080 User-Agent: curl/7.48.0 Accept: */*
user@client:~$ curl 172.16.2.6:8080 My website has date function Tue Jun 13 18:00:19 UTC 2017 user@client:~$ curl 172.16.2.6:8080 My website has date function Tue Jun 13 18:00:24 UTC 2017 user@client:~$
mkfifo pipe; while true ; do { read line<pipe;echo -e "HTTP/1.1 200 OK\r\n";echo $(date); } | nc -l -q 0 -p 8080 > pipe; done
declare -r BASHTTPD_CONF="/tmp/bashttpd.conf" declare -i LISTEN_PORT=8080 declare -a DUMP_DEV="/dev/random" declare -r FAVICON="AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAADg4+3/srjc/5KV2P+ortn/xMrj/6Ch1P+Vl9f/jIzc/3572f+CgNr/fnzP/3l01f+Ih9r/h4TZ/8fN4 declare -i DEBUG=1 declare -i VERBOSE=0 declare -a REQUEST_HEADERS declare REQUEST_URI="" declare -a HTTP_RESPONSE=( [200]="OK" [400]="Bad Request" [403]="Forbidden" [404]="Not Found" [405]="Method Not Allowed" [500]="Internal Server Error") declare DATE=$(date +"%a, %d %b %Y %H:%M:%S %Z") declare -a RESPONSE_HEADERS=( "Date: $DATE" "Expires: $DATE" "Server: Slash Bin Slash Bash" ) function warn() { ((${VERBOSE})) && echo "WARNING: $@" >&2; } function chk_conf_file() { [ -r "${BASHTTPD_CONF}" ] || { cat >"${BASHTTPD_CONF}" << # # # # # # # # # # # # # # # # # # # # DOCROOT=/ on_uri_match # # # # EOF warn "Created bashttpd.conf using defaults. Please review and configure bashttpd.conf before running bashttpd again." } } function recv() { ((${VERBOSE})) && echo "< $@" >&2; } function send() { ((${VERBOSE})) && echo "> $@" >&2; echo "$*"; } function add_response_header() { RESPONSE_HEADERS+=("$1: $2"); } function send_response_binary() { local code="$1" local file="${2}" local transfer_stats="" local tmp_stat_file="/tmp/_send_response_$$_" send "HTTP/1.0 $1 ${HTTP_RESPONSE[$1]}" for i in "${RESPONSE_HEADERS[@]}"; do send "$i" done send if ((${VERBOSE})); then dd 2>"${tmp_stat_file}" < "${file}" transfer_stats=$(<"${tmp_stat_file}") echo -en ">> Transferred: ${file}\n>> $(awk rm "${tmp_stat_file}" else dd 2>"${DUMP_DEV}" < "${file}" fi } function send_response() { local code="$1" send "HTTP/1.0 $1 ${HTTP_RESPONSE[$1]}" for i in "${RESPONSE_HEADERS[@]}"; do send "$i" done send while IFS= read -r line; do send "${line}" done } function send_response_ok_exit() { send_response 200; exit 0; } function send_response_ok_exit_binary() { send_response_binary 200 "${1}"; exit 0; } function fail_with() { send_response "$1" <<< "$1 ${HTTP_RESPONSE[$1]}"; exit 1; } function serve_file() { local file="$1" local CONTENT_TYPE="" case "${file}" in *\.css) CONTENT_TYPE="text/css" ;; *\.js) CONTENT_TYPE="text/javascript" ;; *) CONTENT_TYPE=$(file -b --mime-type "${file}") ;; esac add_response_header "Content-Type" "${CONTENT_TYPE}" CONTENT_LENGTH=$(stat -c add_response_header "Content-Length" "${CONTENT_LENGTH}" send_response_ok_exit_binary "${file}" } function serve_dir_with_tree() { local dir="$1" tree_vers tree_opts basehref x local no_favicon=" <link href=\"data:image/x-icon;base64,${FAVICON}\" rel=\"icon\" type=\"image/x-icon\" />" local tree_page="" local base_server_path="/${2%/}" [ "$base_server_path" = "/" ] && base_server_path=".." local tree_opts="--du -h -a --dirsfirst" add_response_header "Content-Type" "text/html" read _ tree_vers x < <(tree --version) tree_page=$(tree -H "$base_server_path" -L 1 "${tree_opts}" -D "${dir}") tree_page=$(sed "5 i ${no_favicon}" <<< "${tree_page}") [[ "${tree_vers}" == v1.6* ]] send_response_ok_exit <<< "${tree_page}" } function serve_dir_with_ls() { local dir="$1" add_response_header "Content-Type" "text/plain" send_response_ok_exit < \ <(ls -la "${dir}") } function serve_dir() { local dir="$1" which tree &>"${DUMP_DEV}" && \ serve_dir_with_tree "$@" serve_dir_with_ls "$@" fail_with 500 } function urldecode() { [ "${1%/}" = "" ] && echo "/" || echo -e "$(sed function serve_dir_or_file_from() { local URL_PATH="${1}/${3}" shift URL_PATH=$(urldecode "${URL_PATH}") [[ $URL_PATH == *..* ]] && fail_with 400 [[ -d "${URL_PATH}" && -f "${URL_PATH}/index.html" && -r "${URL_PATH}/index.html" ]] && \ URL_PATH="${URL_PATH}/index.html" if [[ -f "${URL_PATH}" ]]; then [[ -r "${URL_PATH}" ]] && \ serve_file "${URL_PATH}" "$@" || fail_with 403 elif [[ -d "${URL_PATH}" ]]; then [[ -x "${URL_PATH}" ]] && \ serve_dir "${URL_PATH}" "$@" || fail_with 403 fi fail_with 404 } function serve_static_string() { add_response_header "Content-Type" "text/plain" send_response_ok_exit <<< "$1" } function on_uri_match() { local regex="$1" shift [[ "${REQUEST_URI}" =~ $regex ]] && \ "$@" "${BASH_REMATCH[@]}" } function unconditionally() { "$@" "$REQUEST_URI"; } function main() { local recv="" local line="" local REQUEST_METHOD="" local REQUEST_HTTP_VERSION="" chk_conf_file [[ ${UID} = 0 ]] && warn "It is not recommended to run bashttpd as root." read -r line || fail_with 400 line=${line%%$ recv "${line}" read -r REQUEST_METHOD REQUEST_URI REQUEST_HTTP_VERSION <<< "${line}" [ -n "${REQUEST_METHOD}" ] && [ -n "${REQUEST_URI}" ] && \ [ -n "${REQUEST_HTTP_VERSION}" ] || fail_with 400 [ "${REQUEST_METHOD}" = "GET" ] || fail_with 405 while IFS= read -r line; do line=${line%%$ recv "${line}" [ -z "${line}" ] && break REQUEST_HEADERS+=("${line}") done } if [[ ! -z "{$1}" ]] && [ "${1}" = "-s" ]; then socat TCP4-LISTEN:${LISTEN_PORT},fork EXEC:"${0}" else main source "${BASHTTPD_CONF}" fail_with 500 fi
while true ; do (dd if=/dev/zero count=10000;echo -e "HTTP/1.1\n\n $(date)") | nc -l 1500 ; done
ping www.google.com ping www.yahoo.com ping www.facebook.com ping www.stackoverflow.com
wget -q --spider http: if [ $? -eq 0 ]; then echo "Online" else echo "Offline" fi
echo -e "GET http: if [ $? -eq 0 ]; then echo "Online" else echo "Offline" fi
for interface in $(ls /sys/class/net/ | grep -v lo); do if [[ $(cat /sys/class/net/$interface/carrier) = 1 ]]; then OnLine=1; fi done if ! [ $OnLine ]; then echo "Not Online" > /dev/stderr; exit; fi
ping -q -w1 -c1 google.com &>/dev/null && echo online || echo offline
ping -q -w 1 -c 1 x.y.z.w > /dev/null && echo ok || echo error
GATEWAY=`route -n get default | grep gateway` if [ -z "$GATEWAY" ] then echo error else ping -q -t 1 -c 1 `echo $GATEWAY | cut -d fi
play -n synth 0.3 sine 800 vol 0.75 while : do pingtime=$(ping -w 1 8.8.8.8 | grep ttl) if [ "$pingtime" = "" ] then pingtimetwo=$(ping -w 1 www.google.com | grep ttl) if [ "$pingtimetwo" = "" ] then clear ; echo else clear ; echo fi else clear ; echo fi sleep 1 done
WGET="/usr/bin/wget" $WGET -q --tries=20 --timeout=10 http: if [ ! -s /tmp/google.idx ] then echo "Not Connected..!" else echo "Connected..!" fi
find /sys/class/net/ -maxdepth 1 -mindepth 1 ! -name "*lo*" -exec sh -c
online() { find /sys/class/net/ -maxdepth 1 -mindepth 1 ! -name "*lo*" -exec sh -c } online && gnubiff --systemtray --noconfigure &
connected_to_internet() { test_urls="\ https: https: https: " processes="0" pids="" for test_url in $test_urls; do curl --silent --head "$test_url" > /dev/null & pids="$pids $!" processes=$(($processes + 1)) done while [ $processes -gt 0 ]; do for pid in $pids; do if ! ps | grep "^[[:blank:]]*$pid[[:blank:]]" > /dev/null; then processes=$(($processes - 1)) pids=$(echo "$pids" | sed --regexp-extended "s/(^| )$pid($| )/ /g") if wait $pid; then kill -TERM $pids > /dev/null 2>&1 || true wait $pids return 0 fi fi done sleep 0.1 done return 1 }
if connected_to_internet; then echo "Connected to internet" else echo "No internet connection" fi
if [[ -z "${DEPLOY_ENV}" ]]; then MY_SCRIPT_VARIABLE="Some default value because DEPLOY_ENV is undefined" else MY_SCRIPT_VARIABLE="${DEPLOY_ENV}" fi [[ -z "${DEPLOY_ENV}" ]] && MyVar= MyVar="${DEPLOY_ENV:-default_value}"
if [[ ! -v DEPLOY_ENV ]]; then echo "DEPLOY_ENV is not set" elif [[ -z "$DEPLOY_ENV" ]]; then echo "DEPLOY_ENV is set to the empty string" else echo "DEPLOY_ENV has the value: $DEPLOY_ENV" fi
if [ -z "$a" ] then echo "not defined" else echo "defined" fi
NEW_VAR="" if [[ ${ENV_VAR} && ${ENV_VAR-x} ]]; then NEW_VAR=${ENV_VAR} else NEW_VAR="new value" fi
sudo visudo Defaults env_keep += "<var1>, <var2>, ..., <varn>"
curl --user user:pass --cookie-jar ./somefile https:
curl -c cookie.txt -d "LoginName=someuser" -d "password=somepass" https: curl -b cookie.txt https:
find . -type f | parallel -k -j150% -n 1000 -m grep -H -n STRING {}
parallel --pipe --sshlogin server.example.com,server2.example.net grep foo < bigfile
-j, --threads ARG The number of threads to use. Defaults to the number of logical CPUs (capped at 6). [default: 0]
split -l 1000000 bigfile.txt for id in $(cat my_ids.txt) ; do ls xa* | xargs -n 1 -P 20 grep $id >> matches.txt ; done
for branch in $(git branch); do git log --oneline $branch ^remotes/origin/master; done
git log --oneline git log --oneline git log --oneline
for branch in $(git for-each-ref --format= git log --oneline "$branch" ^origin/master done
branches=() eval "$(git for-each-ref --shell --format= for branch in "${branches[@]}"; do done
for BRANCH in `git branch --list|sed do git checkout $BRANCH git fetch git branch --set-upstream-to=origin/$BRANCH $BRANCH done git checkout master;
git branch | while read line ; do case $line in \*\ *) branch=${line *) branch=$line ;; esac git log --oneline $branch ^remotes/origin/master done
my_callback () { INDEX=${1} BRANCH=${2} echo "${INDEX} ${BRANCH}" } get_branches () { git branch --all --format= } mapfile -t -C my_callback -c 1 < <( get_branches )
_map () { ARRAY=${1?} CALLBACK=${2?} mapfile -t -C "${CALLBACK}" -c 1 <<< "${ARRAY[@]}" } get_history_differences () { REF1=${1?} REF2=${2?} shift shift git log --oneline "${REF1}" ^"${REF2}" "${@}" } has_different_history () { REF1=${1?} REF2=${2?} HIST_DIFF=$( get_history_differences "${REF1}" "${REF2}" ) return $( test -n "${HIST_DIFF}" ) } print_different_branches () { read -r -a ARGS <<< "${@}" LOCAL=${ARGS[-1]?} for REMOTE in "${SOME_REMOTE_BRANCHES[@]}"; do if has_different_history "${LOCAL}" "${REMOTE}"; then echo local branch "${LOCAL}" is different than remote branch "${REMOTE}"; fi done } get_local_branches () { git branch --format= } get_different_branches () { _map "$( get_local_branches )" print_different_branches } declare -a SOME_REMOTE_BRANCHES SOME_REMOTE_BRANCHES=( origin/master remotes/origin/another-branch another-remote/another-interesting-branch ) DIFFERENT_BRANCHES=$( get_different_branches ) echo "${DIFFERENT_BRANCHES}"
while read x ; do echo === $x === ; done < <( git for-each-ref --format=
sed "s/\(.*\)/\t\1/" $filename > $sedTmpFile && mv $sedTmpFile $filename
$ timestamp=$(date +%s) $ echo -e 1491237958 1 1491237958 2 1491237958 3
import sys import re def main(args): if len(args) < 2: print >> sys.stderr, raise SystemExit p = re.compile(args[0], re.MULTILINE | re.DOTALL) s = sys.stdin.read() print p.sub(args[1], s), if __name__ == main(sys.argv[1:])
if [[ $ echo exit 0 fi case "$1" in 1) echo *) echo esac
i="test" if [ $i=~"200[78]" ] then echo "OK" else echo "not OK" fi
i="test" if [[ $i =~ 200[78] ]] ; then echo "OK" else echo "not OK" fi
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
seq 1 1000000 | while read i; do echo -en "\r$i"; done
-n do not output the trailing newline -e enable interpretation of backslash escapes \r carriage return
$ echo -e "abcdefghijklmnopqrstuvwxyz\r0123456789" 0123456789klmnopqrstuvwxyz
$ echo -e "abcdefghijklmnopqrstuvwxyz\r\033[K0123456789" 0123456789
tput sc printf "Something that I made up for this string" sleep 1 tput rc;tput el printf "Another message for testing" sleep 1 tput rc;tput el printf "Yet another one" sleep 1 tput rc;tput el
timeout () { tput sc time=$1; while [ $time -ge 0 ]; do tput rc; tput el printf "$2" $time ((time--)) sleep 1 done tput rc; tput ed; } timeout 10 "Self-destructing in %s"
for i in {10..1}; do printf "Counting down: $i\r" && sleep 1; done
for i in {10..1}; do echo -ne "Counting down: $i\r" && sleep 1; done
time=5 echo -n "Elapsed $time seconds" sleep 10 time=15 echo -n "Elapsed $time seconds" echo "\nDone"
mkdir -p parentfolder/{subfolder1,subfolder2,subfolder3}
if test `find "text.txt" -mmin +120` then echo old enough fi
find text.txt -mmin +120 -exec echo "old enough" \;
if [ "$(( $(date +"%s") - $(stat -c "%Y" $somefile) ))" -gt "7200" ]; then echo "$somefile is older then 2 hours" fi
File: `infolog.txt' Size: 694 Blocks: 8 IO Block: 4096 regular file Device: 801h/2049d Inode: 11635578 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 1000/ fdr) Gid: ( 1000/ fdr) Access: 2009-01-01 22:04:15.000000000 -0800 Modify: 2009-01-01 22:05:05.000000000 -0800 Change: 2009-01-01 22:05:05.000000000 -0800
for /f "usebackq tokens=*" %%a in (`echo Test`) do my_command %%a
SET VV=some_command -many -arguments && another_command -requiring -the-other -command | handling_of_output | more_handling for /f "usebackq tokens=*" %%a in (`%VV%`) do mycommand %%a
var="a b c" for i in $var do p=`echo -e $p done echo $p
var="a b c" first_loop=true for i in $var do p="$p\n$i" unset first_loop done echo -e "$p"
var="a b c" first_loop=1 for i in $var do (( $first_loop )) && p="$i" || p="$p\n$i" unset first_loop done echo -e "$p"
embed_newline() { local p="$1" shift for i in "$@" do p="$p\n$i" done echo -e "$p" } var="a b c" p=$( embed_newline $var ) echo "$p"
var="a b c" for i in $var do p="$p $i" done echo "$p"
var="a b c" first_loop=1 for i in $var do (( $first_loop )) && p="$i" || p="$p $i" unset first_loop done echo "$p"
embed_newline() { local p="$1" shift for i in "$@" do p="$p $i" done echo "$p" } var="a b c" p=$( embed_newline $var ) echo "$p"
var="a b c" for i in $var do p="$p"$ done echo "$p"
var="a b c" first_loop=1 for i in $var do (( $first_loop )) && p="$i" || p="$p"$ unset first_loop done echo "$p"
embed_newline() { local p="$1" shift for i in "$@" do p="$p"$ done echo "$p" } var="a b c" p=$( embed_newline $var ) echo "$p"
var="a b c" for i in $var; do p="`echo -e "$p\\n$i"`" done echo "$p"
var="a\nb\nc" echo -e "$var" printf "%b" "$var" printf "$var"
var="a b c" for i in $var do p=`echo -e "$p" done echo "$p"
case $1 in 0 ) echo $1 = 0; OUTPUT=3;; 1 ) echo $1 = 1; OUTPUT=4;; 2 ) echo $1 = 2; OUTPUT=4;; esac HID=$2; BUNCH=16; LR=.008;
metacharacter A character that, when unquoted, separates words. One of the following: | & ; ( ) < > space tab control operator A token that performs a control function. It is one of the following symbols: || & && ; ;; ( ) | |& <newline>
:; echo "Hi, I’m ${SHELL}."; exit $? @ECHO OFF ECHO I
:; false; ret=$? :; [ ${ret} = 0 ] || { echo "Program failed with code ${ret}." >&2; exit 1; } :; exit ECHO CMD code.
:; echo "I am ${SHELL}" :<<"::CMDLITERAL" ECHO I am %COMSPEC% ::CMDLITERAL :; echo "And ${SHELL} is back!" :; exit ECHO And back to %COMSPEC%
:<<"::CMDLITERAL" @ECHO OFF GOTO :CMDSCRIPT ::CMDLITERAL echo "I can write free-form ${SHELL} now!" if :; then echo "This makes conditional constructs so much easier because" echo "they can now span multiple lines." fi exit $? :CMDSCRIPT ECHO Welcome to %COMSPEC%
: : : : : :; echo "This is ${SHELL}"; exit @ECHO OFF ECHO This is %COMSPEC%
:<<BATCH @echo off echo %PATH% exit /b BATCH echo $PATH
:; if [ -z 0 ]; then @echo off goto :WINDOWS fi if [ -z "$2" ]; then echo "usage: $0 <firstArg> <secondArg>" exit 1 fi exit :WINDOWS if [%2]==[] ( SETLOCAL enabledelayedexpansion set usage="usage: %0 <firstArg> <secondArg>" @echo !usage:"=! exit /b 1 ) :: windows stuff
:;( # :; echo :; echo :; );<< ( echo Hello echo cmd! ) & rem ^ here-document delimiter
echo >/dev/null echo StartDir="$(pwd)" exit 0 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - :WINDOWS echo "Processing for Windows" REM Do Windows CMD commands here... for example: SET StartDir=%cd% REM Then, when all Windows commands are complete... the script is done.
:;SET() { eval $1; } SET var=value :;echo $var :;exit ECHO %var%
@ 2>/dev/null :; alias ::= :: exec java -jar $JAVA_OPTS "$0" "$@" :: exit java -jar %JAVA_OPTS% "%~dpnx0" %* exit /B
COMMAND=$ echo "|${COMMAND}|" | OOT | echo "|${COMMAND |REBOOT | echo "|${COMMAND |REBOOT|
man -Pless\ +/\/pattern bash man -Pless\ +/\\\ man -Pless\ +/^\\\ *Parameter\\\ Exp bash man -Pless\ +/^\\\ *QUOTING bash
COMMAND=$ echo "|$COMMAND|" | BOOT | CLEANED=${COMMAND echo "|$CLEANED|" | RE BOOT | shopt -q extglob || { echo "Set shell option CLEANED=${CLEANED%%*( )} echo "|$CLEANED|" | RE BOOT| CLEANED=${CLEANED echo "|$CLEANED|" |RE BOOT|
COMMAND=$ CLEANED=${COMMAND echo "|${CLEANED |RE BOOT|
$ COMMAND=$ $ echo "$COMMAND" |hexdump -C 00000000 0a 22 52 45 42 4f 4f 54 22 0d 20 20 20 0a 0a |."REBOOT". ..| $ echo "$COMMAND" |tr -d 00000000 52 45 42 4f 4f 54 20 20 20 |REBOOT | $ echo "$COMMAND" |sed 00000000 0a 52 45 42 4f 4f 54 20 20 20 0a 0a |.REBOOT ..| $ echo "$COMMAND" |sed -z 00000000 52 45 42 4f 4f 54 20 20 20 |REBOOT |
22791 ; 14336 ; 22821 ; 34653 ; 21491 ; 25522 ; 33238 ;
$ LANG=C help source source: source filename [arguments] Execute commands from a file in the current shell. Read and execute commands from FILENAME in the current shell. The entries in $PATH are used to find the directory containing FILENAME. If any ARGUMENTS are supplied, they become the positional parameters when FILENAME is executed. Exit Status: Returns the status of the last command executed in FILENAME; fails if FILENAME cannot be read.
RED=`tput setaf 1` GREEN=`tput setaf 2` BLUE=`tput setaf 4` BOLD=`tput bold` RESET=`tput sgr0`
for foo in `some-command` do do-something $foo done
for foo in `some-command` do do-something $foo & done
cpus=$( ls -d /sys/devices/system/cpu/cpu[[:digit:]]* | wc -w ) find . -name \*.pdf | xargs --max-args=1 --max-procs=$cpus pdf2ps
--max-procs=max-procs -P max-procs Run up to max-procs processes at a time; the default is 1. If max-procs is 0, xargs will run as many processes as possible at a time. Use the -n option with -P; otherwise chances are that only one exec will be done.
some-command | parallel -S server1,server2 do-something
cat list_of_files | \ parallel --trc {.}.out -S server1,server2,: \ "my_script {} > {.}.out"
maxjobs = 10 foreach line in `cat file.txt` { jobsrunning = 0 while jobsrunning < maxjobs { do job & jobsrunning += 1 } wait } job ( ){ ... }
function pwait() { while [ $(jobs -p | wc -l) -ge $1 ]; do sleep 1 done }
scheduleAll() { local job i=0 max=4 pids=() for job; do (( ++i % max == 0 )) && { wait "${pids[@]}" pids=() } bash -c "$job" & pids+=("$!") done wait "${pids[@]}" }
parallel () { awk "BEGIN{print \"all: ALL_TARGETS\\n\"}{print \"TARGET_\"NR\":\\n\\t@-\"\$0\"\\n\"}END{printf \"ALL_TARGETS:\";for(i=1;i<=NR;i++){printf \" TARGET_%d\",i};print\"\\n\"}" | make $@ -f - all }
n=0 maxjobs=10 for i in *.m4a ; do if (( $(($((++n)) % $maxjobs)) == 0 )) ; then wait echo $n wait fi done
for i in {1..N}; do (for j in {1..M}; do do_something; done & ); done
MAX_JOBS=32 FILE_LIST=($(cat ${1})) echo Length ${ for ((INDEX=0; INDEX < ${ do JOBS_RUNNING=0 while ((JOBS_RUNNING < MAX_JOBS)) do I=$((${INDEX}+${JOBS_RUNNING})) FILE=${FILE_LIST[${I}]} if [ "$FILE" != "" ];then echo $JOBS_RUNNING $FILE ./M22Checker ${FILE} & else echo $JOBS_RUNNING NULL & fi JOBS_RUNNING=$((JOBS_RUNNING+1)) done wait done
function log { echo "$1" } function ParallelExec { local numberOfProcesses="${1}" local commandsArg="${2}" local pid local runningPids=0 local counter=0 local commandsArray local pidsArray local newPidsArray local retval local retvalAll=0 local pidState local commandsArrayPid IFS= log "Runnning ${ while [ $counter -lt "${ while [ $counter -lt "${ log "Running command [${commandsArray[$counter]}]." eval "${commandsArray[$counter]}" & pid=$! pidsArray+=($pid) commandsArrayPid[$pid]="${commandsArray[$counter]}" counter=$((counter+1)) done newPidsArray=() for pid in "${pidsArray[@]}"; do if kill -0 $pid > /dev/null 2>&1; then pidState=$(ps -p$pid -o state= 2 > /dev/null) if [ "$pidState" != "D" ] && [ "$pidState" != "Z" ]; then newPidsArray+=($pid) fi else wait $pid retval=$? if [ $retval -ne 0 ]; then log "Command [${commandsArrayPid[$pid]}] failed with exit code [$retval]." retvalAll=$((retvalAll+1)) fi fi done pidsArray=("${newPidsArray[@]}") sleep .05 done return $retvalAll }
cmds="du -csh /var;du -csh /tmp;sleep 3;du -csh /root;sleep 10; du -csh /home" ParallelExec 2 "$cmds" ParallelExec 4 "$cmds"
eval `some-command for $DOMAINS` & job[$i]=$! i=$(( i + 1))
- name: Add deployment user action: user name=deployer password=mypassword
- hosts: all user: root vars: password: $1$SomeSalt$UqddPX3r4kH3UL5jq5/ZI. tasks: - user: name=tset password={{password}}
- name: Creating user "{{ uusername }}" with admin access user: name: {{ uusername }} password: {{ upassword | password_hash( groups: admin append=yes when: assigned_role == "yes" - name: Creating users "{{ uusername }}" without admin access user: name: {{ uusername }} password: {{ upassword | password_hash( when: assigned_role == "no" - name: Expiring password for user "{{ uusername }}" shell: chage -d 0 "{{ uusername }}"
- name: Create madhead user user: name: madhead password: "{{ shell: /bin/zsh update_password: on_create register: madhead - name: Force madhead to change password shell: chage -d 0 madhead when: madhead.changed
tasks: - name: create deployment user user: name: deployer createhome: yes state: present register: newuser - name: generate random password for user only on creation shell: /usr/bin/openssl rand -base64 32 | passwd --stdin deployer when: newuser.changed
vars_prompt: - name: "user_password" prompt: "Enter a password for the user" private: yes encrypt: "md5_crypt" confirm: yes salt_size: 7 - name: "add new user" user: name="{{user_name}}" comment="{{description_user}}" password="{{user_password}}" home="{{home_dir}}" shell="/bin/bash"
--- - hosts: your_host_group become: True user: ansible roles: - create_user
--- - name: Generate password for new user shell: makepasswd --chars=20 register: user_password - name: Generate encrypted password shell: mkpasswd --method=SHA-512 {{ user_password.stdout }} register: encrypted_user_password - name: Create user account user: name={{ new_user_name }} password={{ encrypted_user_password.stdout }} state=present append=yes shell="/bin/bash" update_password=always when: new_user_name is defined and new_user_name in uids register: user_created - name: Force user to change password shell: chage -d 0 {{ new_user_name }} when: user_created.changed - name: User created debug: msg="Password for {{ new_user_name }} is {{ user_password.stdout }}" when: user_created.changed
ansible-playbook -i hosts.ini create_user.yml --extra-vars "new_user_name=kelvin"
--- - name: Create user user: name=user shell=/bin/bash home=/srv/user groups=admin,sudo generate_ssh_key=yes ssh_key_bits=2048 - name: Set password to user shell: echo user:plain_text_password | sudo chpasswd no_log: True
- hosts: main vars: - password: tasks: - user: name=spree password={{password}} groups=sudo,www-data shell=/bin/bash append=yes sudo: yes
tasks: - user: name=test password={{ password }} state=present
--- - hosts: [your hosts] tasks: - include_vars: [path to your encrypted vault file] - local_action: "command openssl passwd -salt register: password_hash - user: > name=[your username] state=present password="{{password_hash.stdout}}"
- include_vars: /path/credential.yml - name: Add deployment user action: user name={{user.name}} password={{user.pass}}
ansible all -m user -a comment="Test User" password=$6$XXXX
- name: Create user user: name="my_user" password="$1$some_pla$lmVKJwdV3Baf.o.F0OOy71"
$ python -c "import crypt, getpass, pwd; print crypt.crypt( $6$saltsalt$qFmFH.bQmmtXzyBY0s9v7Oicd2z4XSIecDzlB5KiA2/jctKu9YterLp8wwnSq.qc.eoxqOmSuNp2xS0ktL3nh/
$ perl -e $6$saltsalt$qFmFH.bQmmtXzyBY0s9v7Oicd2z4XSIecDzlB5KiA2/jctKu9YterLp8wwnSq.qc.eoxqOmSuNp2xS0ktL3nh/
$ ruby -e $6$saltsalt$qFmFH.bQmmtXzyBY0s9v7Oicd2z4XSIecDzlB5KiA2/jctKu9YterLp8wwnSq.qc.eoxqOmSuNp2xS0ktL3nh/
pip3 install passlib python3 -c print(md5_crypt.encrypt("This is my Password", salt="SomeSalt"))'
python3 -c print(sha512_crypt.encrypt("This is my Password", salt="SomeSalt"))
$ password= $ ansible 192.168.1.10 -i some_inventory -b -m user -a "name=joe_user \ update_password=always password=\"{{ \"$password\" | password_hash(
192.168.1.10 | SUCCESS => { "append": false, "changed": true, "comment": "Joe User", "group": 999, "home": "/home/joe_user", "move_home": false, "name": "joe_user", "password": "NOT_LOGGING_PASSWORD", "shell": "/bin/bash", "state": "present", "uid": 999 }
- hosts: localhost become: True tasks: - name: Change user password shell: "yes loop: - { pass: 123123, user: foo } - { pass: asdf, user: bar } loop_control: label: "{{ item.user }}"
# # NAME=$(git branch | grep DESCRIPTION=$(git config branch."$NAME".description) echo "$NAME" if [ -n "$DESCRIPTION" ] then echo "" >> "$1" echo $DESCRIPTION >> "$1" fi
[branch_name]: [original_message] [branch_description]
branchPath=$(git symbolic-ref -q HEAD) branchName=${branchPath firstLine=$(head -n1 $1) if [ -z "$firstLine" ] ;then sed -i "1s/^/$branchName: \n/" $1 fi
BRANCH=`git branch | grep FILE=`cat "$1"` echo "$BRANCH $FILE" > "$1"
find vendor -name ".git*" -type d | while read i do if [ -d "$i" ]; then DIR=`dirname $i` rm -fR $i git rm -r --cached $DIR > /dev/null 2>&1 git add $DIR > /dev/null 2>&1 fi done
sudo chmod 755 .git/hooks/prepare-commit-msg sudo chmod 755 .git/hooks/pre-commit
# # COMMIT_EDITMSG=$1 addBranchName() { NAME=$(git branch | grep DESCRIPTION=$(git config branch."$NAME".description) echo "[$NAME]: $(cat $COMMIT_EDITMSG)" > $COMMIT_EDITMSG if [ -n "$DESCRIPTION" ] then echo "" >> $COMMIT_EDITMSG echo $DESCRIPTION >> $COMMIT_EDITMSG fi } MERGE=$(cat $COMMIT_EDITMSG|grep -i if [ $MERGE -eq 0 ] ; then addBranchName fi
addMyBranchName() { NAME=$(git branch | grep BODY=`cut -d \| -f 6 $1 | grep -v -E .\+ -n | cut -d if test ! -z $BODY; then awk else echo "title\n\n($NAME/):\n`cat $1`\n" > "$1" fi } case "$2,$3" in commit,?*) ;; message,) ;; merge,) perl -i.bak -ne ;; *) addMyBranchName $1 ;; esac
BRANCH=$(cat .git/HEAD | cut -d if [ ! -z "$BRANCH" ] then echo "$BRANCH" > "/Users/username/.gitmessage" else echo "[JIRA NUMBER]" > "/Users/username/.gitmessage" fi
mkdir -p ~/.git_hooks chmod a+x ~/.git_hooks/commit-msg
{ echo "$var"; cat - ; } | command ( echo "$var"; cat - ) | command
$ history | grep some_long_command ... ... 123 some_long_command1......... 124 some_long_command2......... ...
"<key code>": history-search-backward "<key code>": history-search-forward
if [ -f ~/.git-completion.bash ]; then . ~/.git-completion.bash fi
echo "source /usr/share/bash-completion/completions/git" >> ~/.bashrc
source ~/.bash_git if [ -f ~/.git-completion.bash ]; then . ~/.git-completion.bash export PS1= fi
{ $0 = tolower($0) gsub(/[^[:alnum:]_[:blank:]]/, "", $0) for (i = 1; i <= NF; i++) freq[$i]++ } END { for (word in freq) printf "%s\t%d\n", word, freq[word] }
while (<>) { @Fields = split /\s+/; for $i ( 0 .. $ $result[$i]{$Fields[$i]}++ }; } for $j ( 0 .. $ print "column $j:\n"; @values = keys %{$result[$j]}; @sorted = sort { $result[$j]{$b} <=> $result[$j]{$a} || $a cmp $b } @values; for $k ( @sorted ) { print " $k $result[$j]{$k}\n" } }
column 0: a 3 z 3 t 1 v 1 w 1 column 1: d 3 r 2 b 1 g 1 m 1 z 1 column 2: c 4 a 3 e 2
Dir["*"].each do |file| h=Hash.new(0) open(file).each do |row| row.chomp.split("\t").each do |w| h[ w ] += 1 end end h.sort{|a,b| b[1]<=>a[1] }.each{|x,y| print " end
somestuff... all: thing otherthing some other stuff
somestuff... all: thing otherthing anotherthing some other stuff
while read -r line ; do [[ $line == all:* ]] && line+=" anotherthing" echo "$line" done < filename
somestuff... all: thing otherthing anotherthing some other stuff
$ awk -v mytext=" EXTRA TEXT" somestuff... all: thing otherthing EXTRA TEXT some other stuff
cat myfile.csv|while read line do read -d, col1 col2 < <(echo $line) echo "I got:$col1|$col2" done
while IFS=, read -r col1 col2 do echo "I got:$col1|$col2" done < myfile.csv
$ set -x; TESTVAR=bbb echo aaa $TESTVAR ccc + TESTVAR=bbb + echo aaa ccc aaa ccc
java (pid 12321) is running...@[60G[@[0;32m OK @[0;39m]
exec > >(tee log) exec 2>&1 ./somescript | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]
./somescript | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]
./somescript | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]
sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK] sed -r "s/\x1B\[([0-9];)?([0-9]{1,2}(;[0-9]{1,2})?)?[mGK] ^^^^^^^^^ remove Yellow and Green (and maybe more colors)
string="$(tput setaf 9)foobar$(tput sgr0)" string_sed="$( sed -r "s/\x1B\[[0-9;]*[JKmsu] echo ${
string_sed="$( sed -r "s/\x1B(\[[0-9;]*[JKmsu]|\(B)
function strip_escape_codes() { local input="${1 for ((i=0; i < ${ char="${input:i:1}" if (( ${within_code} == 1 )); then case "${char}" in [a-zA-Z]) within_code=0 ;; esac continue fi if [[ "${char}" == $ within_code=1 continue fi output+="${char}" done eval "$2=\"${output}\"" }
while read -r line; do strip_escape_codes "${line}" stripped echo "${stripped}" done
$ diff -u <(ls -1 {,**/}*.*) <(ls -1 **/*.*) --- /dev/fd/63 2015-04-19 15:25:07.000000000 +0100 +++ /dev/fd/62 2015-04-19 15:25:07.000000000 +0100 @@ -1,6 +1,4 @@ COPYING.LIB -COPYING.LIB -Makefile.am Makefile.am @@ -45,7 +43,6 @@ compat/tdestroy.c compat/vasprintf.c configure.ac -configure.ac
MYVAR="/var/cpanel/users/joebloggs:DNS9=domain.com" NAME=${MYVAR%:*} NAME=${NAME echo $NAME
getUserName() { echo $1 | cut -d : -f 1 | xargs basename }
userName=$(getUserName "/var/cpanel/users/joebloggs:DNS9=domain.com") echo $userName
/var/cpanel/users/ joebloggs :DNS9=domain.com joebloggs sed
echo "/var/cpanel/users/joebloggs:DNS9=domain.com" | sed
vanilla-ice-cream chocolate-ice-cream strawberry-ice-cream
for filename in *.jpg; do mv "$filename" "prefix_$filename"; done;
# # use strict; use Getopt::Std; my(%opts); my($usage) = "Usage: $0 [-fnxV] perlexpr [filenames]\n"; my($force) = 0; my($noexc) = 0; my($trace) = 0; die $usage unless getopts( if ($opts{V}) { printf "%s\n", q exit 0; } $force = 1 if ($opts{f}); $noexc = 1 if ($opts{n}); $trace = 1 if ($opts{x}); my($op) = shift; die $usage unless defined $op; if (!@ARGV) { @ARGV = <STDIN>; chop(@ARGV); } for (@ARGV) { if (-e $_ || -l $_) { my($was) = $_; eval $op; die $@ if $@; next if ($was eq $_); if ($force == 0 && -f $_) { print STDERR "rename failed: $was - $_ exists\n"; } else { print "+ $was --> $_\n" if $trace; print STDERR "rename failed: $was - $!\n" unless ($noexc || rename($was, $_)); } } else { print STDERR "$_ - $!\n"; } }
f=`ls *canctn[0-9]*` ; mv $f CNLC.$f f=`ls *acustb[0-9]*` ; mv $f CATB.$f f=`ls *accusgtb[0-9]*` ; mv $f CATB.$f f=`ls *acus[0-9]*` ; mv $f CAUS.$f
unset masks typeset -A masks masks[ip[0-9]]=ip masks[iaf_usg[0-9]]=ip_usg masks[ipusg[0-9]]=ip_usg ... for fileMask in ${!masks[*]}; do registryEntry="${masks[$fileMask]}"; fileName=*${fileMask}* [ -e ${fileName} ] && mv ${fileName} ${registryEntry}.${fileName} done
if [ -z "$2" ] then i=1; else i=$2; fi count=$(ls -l * | wc -l) if [ $count -lt 10 ] then zeros=1; else if [ $count -lt 100 ] then zeros=2; else zeros=3 fi fi for file in * do mv $file $1_$(printf %0"$zeros"d.%s ${i%.*} ${file let i="$i+1" done
preg_match( ""(\d{2}\:\d{2}) PM \(CST\)"", "US/Central - 10:26 PM (CST)", $matches );
$ cat file.txt US/Central - 10:26 PM (CST) $ while read a b time x; do [[ $b == - ]] && echo $time; done < file.txt
$ [[ "US/Central - 10:26 PM (CST)" =~ -[[:space:]]*([0-9]{2}:[0-9]{2}) ]] && echo ${BASH_REMATCH[1]}
$ echo "US/Central - 10:26 PM (CST)" | grep -oP "\-\s+\K\d{2}:\d{2}"
echo "US/Central - 10:26 PM (CST)" | sed -n "s/^.*-\s*\(\S*\).*$/\1/p" -n suppress printing s substitute ^.* anything at the beginning - up until the dash \s* any space characters (any whitespace character) \( start capture group \S* any non-space characters \) end capture group .*$ anything at the end \1 substitute 1st capture group for everything on line p print it
string="US/Central - 10:26 PM (CST)" etime="${string% [AP]M*}" etime="${etime
$ gg=svm-grid-ch $ if [[ $gg == *grid* ]] ; then echo $gg; fi svm-grid-ch $ if [[ $gg == ^....grid* ]] ; then echo $gg; fi $ if [[ $gg == ....grid* ]] ; then echo $gg; fi $ if [[ $gg == s...grid* ]] ; then echo $gg; fi $
gg=svm-grid-ch case "$gg" in *grid*) echo $gg ;; esac if echo "$gg" | grep if echo "$gg" | grep if echo "$gg" | grep if echo "$gg" | egrep echo $gg fi
gg=svm-grid-ch case "$gg" in *grid* ) echo "found";; esac case "$gg" in ????grid*) echo "found";; esac case "$gg" in s???grid*) echo "found";; esac
$ shopt -s dotglob $ ls -1 * abg degree ..g $ for file in *; do [[ $file =~ "..g" ]] && echo $file ; done abg degree ..g
$ for file in ??g*; do echo $file; done abg degree ..g
RESET="\[\017\]" NORMAL="\[\033[0m\]" RED="\[\033[31;1m\]" YELLOW="\[\033[33;1m\]" WHITE="\[\033[37;1m\]" SMILEY="${WHITE}:)${NORMAL}" FROWNY="${RED}:(${NORMAL}" SELECT="if [ \$? = 0 ]; then echo \"${SMILEY}\"; else echo \"${FROWNY}\"; fi" export PS1="${RESET}${YELLOW}\u@\h${NORMAL} \`${SELECT}\` ${YELLOW}\w $(__git_ps1) >${NORMAL} "
export PS1="${RESET}${YELLOW}\u@\h${NORMAL} \`${SELECT}\` ${YELLOW}\w \$(__git_ps1) >${NORMAL} "
ry4an@ry4an-mini:~$ mkdir "My Code" ry4an@ry4an-mini:~$ vi todir.sh ry4an@ry4an-mini:~$ . todir.sh ry4an@ry4an-mini:My Code$ cat ../todir.sh cd ~/My\ Code
$ set -u $ arr=() $ echo "foo: bash: arr[@]: unbound variable
$ countArgs() { echo $ $ countArgs a b c 3 $ countArgs 0 $ countArgs "" 1 $ brr=("") $ countArgs "${brr[@]}" 1 $ countArgs "${arr[@]-}" 1 $ countArgs "${arr[@]}" bash: arr[@]: unbound variable $ set +u $ countArgs "${arr[@]}" 0
if [ "${ veryLongCommandLine else veryLongCommandLine "${arr[@]}" fi
$ function args { perl -E $ set -u $ arr=() $ args "${arr[@]}" -bash: arr[@]: unbound variable $ args ${arr[@]+"${arr[@]}"} 0 $ arr=("") $ args ${arr[@]+"${arr[@]}"} 1 0: $ arr=(a b c) $ args ${arr[@]+"${arr[@]}"} 3 0: a 1: b 2: c
set -u arr=() echo a "${arr[@]:-}" b for f in a "${arr[@]:-}" b; do echo $f; done arr=(1 2) echo a "${arr[@]:-}" b for f in a "${arr[@]:-}" b; do echo $f; done
$ bash --version | head -n1 bash --version | head -n1 GNU bash, version 4.4.0(1)-release (x86_64-pc-linux-gnu)
$ set -u $ arr2=() $ arr2=( ${arr2[@] + "${arr2[@]}"} bash: ${arr2[@] + "$arr2[@]"}: bad substitution
$ set -u $ echo $# 0 $ echo "$1" bash: $1: unbound variable $ echo "$@" | cat -e $
$ arr=() $ echo "${arr[@]}" bash: arr[@]: unbound variable $ echo "${ 0 $ echo "${!arr[@]}" | cat -e $
set -o nounset -o errexit -o pipefail countArgs () { echo "$ arrA=( sentinel ) arrB=( sentinel "{1..5}" "./*" "with spaces" ) arrC=( sentinel cmnd=( countArgs "${arrA[@]:1}" "${arrB[@]:1}" "${arrC[@]:1}" ) echo "${cmnd[@]}" "${cmnd[@]}" arrA=( ) arrB=( "{1..5}" "./*" "with spaces" ) arrC=( cmnd=( countArgs ) [[ ! ${!arrA[@]} ]] || cmnd+=( "${arrA[@]}" ) [[ ! ${!arrB[@]} ]] || cmnd+=( "${arrB[@]}" ) [[ ! ${!arrC[@]} ]] || cmnd+=( "${arrC[@]}" ) echo "${cmnd[@]}" "${cmnd[@]}"
: example copy arr into arr_copy arr=( "1 2" "3" ) arr_copy=( "${arr[@]:+${arr[@]}}" ) arr_copy=( ${arr[@]:+"${arr[@]}"} )
set -u function count() { echo $ ( count x y z ) : prints "3" ( arr=() count "${arr[@]}" ) : prints "-bash: arr[@]: unbound variable" ( arr=() count "${arr[@]:0}" ) : prints "0" ( arr=(x y z) count "${arr[@]:0}" ) : prints "3"
arr=() set -o nounset echo $arr[@] => -bash: arr[@]: unbound variable declare -p arr => declare -a arr=
IC001:Desktop user$ ssh user@my.server.com user@my.server.com Last login: Tue Jun 4 10:09:01 2013 from 0.0.0.0 $
spawn ssh user@my.server.com expect "assword:" send "mypassword\r" interact
for d in $(find $somepath -type d) do doSomething($d) done
$ help for for: for NAME [in WORDS ... ;] do COMMANDS; done The `for list of items. If `in WORDS ...; assumed. For each element in WORDS, NAME is set to that element, and the COMMANDS are executed. for ((: for (( exp1; exp2; exp3 )); do COMMANDS; done Equivalent to (( EXP1 )) while (( EXP2 )); do COMMANDS (( EXP3 )) done EXP1, EXP2, and EXP3 are arithmetic expressions. If any expression is omitted, it behaves as if it evaluates to 1.
% for host in {frontend{1..5},backend{1..3}}.mycompany.com do ssh $host "echo -n $host; uptime" done
function do_something { echo value=${1} } MAX=4 for (( i=0; i<MAX; i++ )) ; { do_something ${i} }
for i in $(ls);do if [ $i = echo "I do something with the file $i" fi done
EXT=java for i in *; do if [ "${i}" != "${i%.${EXT}}" ];then echo "I do something with the file $i" fi done
for i in `find . -name "*.java" -type f`; do echo "$i" done
for i in $(ls);do if [[ $i =~ .*\.java$ ]];then echo "I want to do something with the file $i" fi done
for i in `find . -type f -name "*.img" -o -name "*.bin" -o -name "*.txt"`; do echo "$i" done
jorgesys@INT024P ~$ bash /home/[user]/my-script-test.sh
@echo off setlocal if not exist "%~dpn1.sh" echo Script "%~dpn1.sh" not found & goto :eof set _CYGBIN=C:\cygwin64\bin if not exist "%_CYGBIN%" echo Couldn :: Resolve ___.sh to /cygdrive based *nix path and store in %_CYGSCRIPT% for /f "delims=" %%A in ( for /f "delims=" %%A in ( :: Throw away temporary env vars and invoke script, passing any args that were passed to us endlocal & %_CYGBIN%\mintty.exe -e /bin/bash -l -c
$ echo foo > foo.txt $ cat foo.txt foo $ > foo.txt $ cat foo.txt $
cp --parents `find -name \*.xls*` /target_directory/
find SOURCEPATH -name filename*.txt -exec cp --parents {} DESTPATH \;
$ less -i +/error logfile $ vi +/open.*myfile myprog...
evan> echo $USER evan evan> echo $SUDO_USER evan> echo $LOGNAME evan evan> whoami evan evan> who am i | awk evan evan> logname evan evan>
evan> sudo -s root> echo $USER root root> echo $SUDO_USER evan root> echo $LOGNAME root root> whoami root root> who am i | awk evan root> logname evan root>
evan> sudo su - [root ] root [root ] [root ] root [root ] root [root ] evan [root ] evan [root ]#
evan> sudo su - [root ] tom$ echo $USER tom tom$ echo $SUDO_USER tom$ echo $LOGNAME tom tom$ whoami tom tom$ who am i | awk evan tom$ logname evan tom$
tom pts/0 2011-07-03 19:18 (1.2.3.4) joe pts/1 2011-07-03 19:10 (5.6.7.8)
# # function findUser { thisPID=$$ origUser=$(whoami) thisUser=$origUser while [ "$thisUser" = "$origUser" ] do ( export UNIX_STD=2003; ps -p$thisPID -ouser,ppid,pid,comm ) | grep $thisPID | read thisUser myPPid myPid myComm thisPID=$myPPid done if [ "$thisUser" = "root" ] then thisUser=$origUser fi if [ "$ then echo $origUser--$thisUser--$myComm else echo $thisUser fi return 0 }
function findUser() { thisPID=$$ origUser=$(whoami) thisUser=$origUser while [ "$thisUser" = "$origUser" ] do ARR=($(ps h -p$thisPID -ouser,ppid;)) thisUser="${ARR[0]}" myPPid="${ARR[1]}" thisPID=$myPPid done getent passwd "$thisUser" | cut -d: -f1 } user=$(findUser) echo "logged in: $user"
function findUserList { typeset userList prevUser thisPID thisUser myPPid myPid myTTY myComm thisPID=$$ while [ "$thisPID" != 1 ] do ( ps -p$thisPID -ouser,ppid,pid,tty,comm ) | grep $thisPID | read thisUser myPPid myPid myTTY myComm thisPID=$myPPid [[ $myComm =~ ^su ]] && continue [[ $myTTY == if [[ $prevUser != $thisUser ]]; then prevUser="$thisUser" userList="${userList:+$userList }$thisUser" fi done print "$userList" return 0 }
THIS_USER=`pstree -lu -s $$ | grep --max-count=1 -o
Disc Title: unknown Title: 01, Length: 01:33:37.000 Chapters: 33, Cells: 31, Audio streams: 04, Subpictures: 20 Subtitle: 01, Language: ar - Arabic, Content: Undefined, Stream id: 0x20, Subtitle: 02, Language: bg - Bulgarian, Content: Undefined, Stream id: 0x21, Subtitle: 03, Language: cs - Czech, Content: Undefined, Stream id: 0x22, Subtitle: 04, Language: da - Dansk, Content: Undefined, Stream id: 0x23, Subtitle: 05, Language: de - Deutsch, Content: Undefined, Stream id: 0x24, (...)
for all files in directory; if file contains "Dansk" AND "Norsk" AND "Svenska" then then echo the filename end
grep -l Dansk * | xargs grep -l Norsk | xargs grep -l Svenska
grep -l Dansk .* | xargs grep -l Norsk | xargs grep -l Svenska
grep –irl word1 * | grep –il word2 `cat -` | grep –il word3 `cat -`
BEGIN { for (i=ARGC-2; i>=1; i--) { patterns[ARGV[i]] = 0; delete ARGV[i]; } } { for (p in patterns) if ($0 ~ p) matches[p] = 1 } END { for (p in patterns) { if (matches[p] != 1) exit 1 } }
all_word_search() { gawk ' BEGIN { for (i=ARGC-2; i>=1; i--) { search_terms[ARGV[i]] = 0; ARGV[i] = ARGV[i+1]; delete ARGV[i+1]; } } { for (i=1;i<=NF; i++) if ($i in search_terms) search_terms[$1] = 1 } END { for (word in search_terms) if (search_terms[word] == 0) exit 1 } return $? }
if all_word_search Dansk Norsk Svenska filename; then echo "all words found" else echo "not all words found" fi
find . -path ./path/to/file1.sh ./another/path/to/file2.txt ./blah/foo.php
$ find /csv/file/dir -name $ grep -q Svenska `cat csv_list.txt` && grep -q Norsk `cat csv_list.txt` && grep -l Dansk `cat csv_list.txt`
comm -12 <(grep -rl word1 . | sort) <(grep -rl word2 . | sort)
until $(curl --output /dev/null --silent --head --fail http: printf sleep 5 done
attempt_counter=0 max_attempts=5 until $(curl --output /dev/null --silent --head --fail http: if [ ${attempt_counter} -eq ${max_attempts} ];then echo "Max attempts reached" exit 1 fi printf attempt_counter=$(($attempt_counter+1)) sleep 5 done
until $(curl --output /dev/null --silent --head --fail http: printf sleep 5 done
while sleep <time>; do <command> > /tmp/file; clear; cat /tmp/file; done
$ cat cheapwatch while true ; do clear printf "[%s] Output of %s:\n" "$(date)" "$*" ${SHELL-/bin/sh} -c "$*" sleep 1 done $ ./cheapwatch ls --color
echo "Press CTRL+C to proceed." trap "pkill -f trap "set +x ; sleep 1h ; set -x" DEBUG < YOUR CODE HERE >
trap "set +x; sleep 5; set -x" DEBUG < YOUR CODE HERE >
$ cat it.sh echo "hi there" date ls -la /etc/passwd $ $(LN=1 && cat it.sh | head -n$LN | tail -n1) "hi there" $ $(LN=2 && cat it.sh | head -n$LN | tail -n1) Wed Feb 28 10:58:52 AST 2018 $ $(LN=3 && cat it.sh | head -n$LN | tail -n1) -rw-r--r-- 1 root wheel 6774 Oct 2 21:29 /etc/passwd
for fspec1 in DET01-ABC-5_50-*.dat ; do fspec2=$(echo ${fspec1} | sed mv ${fspec1} ${fspec2} done
for x in DET01-*.dat; do echo $x | sed -r done | sh -e
if mount | grep /mnt/md0 > /dev/null; then echo "yay" else echo "nay" fi
$ mountpoint /oracle /oracle is a mountpoint $ mountpoint /bin /bin is not a mountpoint
mountpoint -q /foo/bar || mount -o bind /some/directory/here /foo/bar
if [[ $(findmnt -M "$FOLDER") ]]; then echo "Mounted" else echo "Not mounted" fi
mkdir -p /tmp/foo/{a,b} cd /tmp/foo sudo mount -o bind a b touch a/file ls b/ rm -f b/file ls a/ [[ $(findmnt -M b) ]] && echo "Mounted" sudo umount b [[ $(findmnt -M b) ]] || echo "Unmounted"
is_mount() { path=$(readlink -f $1) grep -q "$path" /proc/mounts }
is_mount /path/to/var/run/mydir/ || mount --bind /var/run/mydir/ /path/to/var/run/mydir/
$ mount | grep /dev/sdb1 > /dev/null && echo mounted || echo unmounted
find spec -name "*_test.rb" -exec echo mv {} `echo {} | sed s/test/spec/` \;
find . -name *_test.rb | sed -e "p;s/test/spec/" | xargs -n2 mv
for file in $(find . -name "*_test.rb") do echo mv $file `echo $file | sed s/_test.rb$/_spec.rb/` done
find . -name "*_test.rb" | xargs rename s/_test/_spec/
find . -name "*_test.rb" | xargs -P 4 rename s/_test/_spec/
find . -name "*_test.rb" | xargs -s 1000000 rename s/_test/_spec/
while IFS= read -r file; do echo "mv $file ${file%_test.rb}_spec.rb" done < <(find -name "*_test.rb")
$ file="HELLOa_test.rbBYE_test.rb" $ echo "${file%_test.rb}" HELLOa_test.rbBYE $ echo "${file%_test.rb}_spec.rb" HELLOa_test.rbBYE_spec.rb
$ tree . ├── ab_testArb ├── a_test.rb ├── a_test.rb_test.rb ├── b_test.rb ├── c_test.hello ├── c_test.rb └── mydir └── d_test.rb $ while IFS= read -r file; do echo "mv $file ${file/_test.rb/_spec.rb}"; done < <(find -name "*_test.rb") mv ./b_test.rb ./b_spec.rb mv ./mydir/d_test.rb ./mydir/d_spec.rb mv ./a_test.rb ./a_spec.rb mv ./c_test.rb ./c_spec.rb
% _mvnfind() { mv -n "${1}" "${2}" && cd "${2}" > read -r SED <<SED > :;s|${3}\(.*/[^/]*${5}\)|${4}\1|;t;:;s|\(${5}.*\)${3}|\1${4}|;t;s|^[0-9]*[\t]\(mv.*\)${5}|\1|p > SED > find . -name "*${3}*" -printf "%d\tmv %P ${5} %P\000" | > sort -zg | sed -nz ${SED} | read -r ${6} > echo <<EOF > Prepared commands saved in variable: ${6} > To view do: printf ${6} | tr "\000" "\n" > To run do: sh <<EORUN > $(printf ${6} | tr "\000" "\n") > EORUN > EOF > } % rm -rf "${UNNECESSARY:=/any/dirs/you/dont/want/moved}" % time ( _mvnfind ${SRC=./test_tree} ${TGT=./mv_tree} \ > ${OLD=google} ${NEW=replacement_word} ${sed_sep=SsEeDd} \ > ${sh_io:=sh_io} ; printf %b\\000 "${sh_io}" | tr "\000" "\n" \ > | wc - ; echo ${sh_io} | tr "\000" "\n" | tail -n 2 ) <actual process time used:> 0.06s user 0.03s system 106% cpu 0.090 total <output from wc:> Lines Words Bytes 115 362 20691 - <output from tail:> mv .config/replacement_word-chrome-beta/Default/.../googlestars \ .config/replacement_word-chrome-beta/Default/.../replacement_wordstars
% mv /path2/$SRC/$OLD_DIR/$OLD_FILE /same/path_w/$NEW_DIR/$NEW_FILE \000
find . -name "*_test.rb" -print0 | while read -d $ do echo mv "$file" "$(echo $file | sed s/test/spec/)" done
find spec -name "*_test.rb" -print0 | while read -d $
$ find spec -name "*_test.rb" spec/dir2/a_test.rb spec/dir1/a_test.rb $ find spec -name "*_test.rb" | xargs -n 1 /usr/bin/perl -e `spec/dir2/a_test.rb `spec/dir1/a_test.rb $ find spec -name "*_spec.rb" spec/dir2/b_spec.rb spec/dir2/a_spec.rb spec/dir1/a_spec.rb spec/dir1/c_spec.rb
IFS=$ function RecurseDirs { for f in "$@" do newf=echo "${f}" | sed -e echo "${f}" "${newf}" mv "${f}" "${newf}" f="${newf}" if [[ -d "${f}" ]]; then cd "${f}" RecurseDirs $(ls -1 ".") fi done cd .. } RecurseDirs .
mkdir ~/practice cd ~/practice touch classic.txt.txt touch folk.txt.txt
find ./spec -type f -name "*_test.rb" -print0 | xargs -0 -I {} sh -c
AirBoxOmega:~ d$ cat > file a,b,c,d,e,f,g,h,i,k 1,2,3,4,5,6,7,8,9,10 a,b,c,d,e,f,g,h,i,k 1,2,3,4,5,6,7,8,9,10 a,b,c,d,e,f,g,h,i,k 1,2,3,4,5,6,7,8,9,10 a,b,c,d,e,f,g,h,i,k 1,2,3,4,5,6,7,8,9,10 a,b,c,d,e,f,g,h,i,k 1,2,3,4,5,6,7,8,9,10 a,b,c,d,e,f,g,h,i,k 1,2,3,4,5,6,7,8,9,10
AirBoxOmega:~ d$ while IFS=, read -a csv_line;do echo "${csv_line[0]}";done < file a 1 a 1 a 1 a 1 a 1 a 1
gawk -- ' BEGIN{ FPAT="([^,\"]*)|(\"((\"\")*[^\"]*)*\")" } { if (substr($c, 1, 1) == "\"") { $c = substr($c, 2, length($c) - 2) gsub("\"\"", "\"", $c) } print $c }
gawk -- ' BEGIN{ RS="\0" FS="" ORS="\n } { nof=patsplit($0, a, /([^,"\n]*)|("(("")*[^"]*)*")/, seps) field=0; for (i=1; i<=nof; i++){ field++ if (field==c) { if (substr(a[i], 1, 1) == "\"") { a[i] = substr(a[i], 2, length(a[i]) - 2) gsub(/""/, "\"", a[i]) } print a[i] } if (seps[i]!=",") field=0 } }
err() { echo "${0 die() { err "$@"; exit 1; } csv_fldN() { fldN , "$1" "$2"; } fldN() { local me="fldN: " local sep="$1" local fldnum="$2" local vals="$3" case "$sep" in -|,|\|) ;; *) die "$me: arg1 sep: unsupported separator esac case "$fldnum" in [0-9]*) [ "$fldnum" -gt 0 ] || { err "$me: arg2 fldnum=$fldnum must be number greater or equal to 0."; return 1; } ;; *) { err "$me: arg2 fldnum=$fldnum must be number"; return 1;} ;; esac [ -z "$vals" ] && err "$me: missing arg2 vals: list of fldnum=$(($fldnum - 1)) while [ $fldnum -gt 0 ] ; do vals="${vals fldnum=$(($fldnum - 1)) done echo ${vals%%$sep*} }
$ CSVLINE="example,fields with whitespace,field3" $ $ for fno in $(seq 3); do echo field$fno: $(csv_fldN $fno "$CSVLINE"); done field1: example field2: fields with whitespace field3: field3
for f in *.jpg; do mv "$f" "${f%.jpg}"; done for f in *; do mv "$f" "$f.jpg"; done
find . -type f -not -name "*.*" -print0 |\ xargs -0 file |\ grep sed xargs -I % echo mv % %.jpg
find . | while read FILE; do if [ $(file --mime-type -b "$FILE") == "image/jpeg" ]; then mv "$FILE" "$FILE".jpg; fi; done;
find . | while read FILE; do if [[ -n `file --mime-type "$FILE" | grep
echo echo hello > sayhi.command; chmod +x sayhi.command; open sayhi.command
osascript <<END tell application "Terminal" do script "cd \"`pwd`\";$1;exit" end tell END
osascript <<END tell application "iTerm" tell the first terminal launch session "Default Session" tell the last session write text "cd \"`pwd`\";$1;exit" end tell end tell end tell END
function newincmd() { declare args args="${@ args="${args printf "%s" "${args}" | /usr/bin/pbcopy /usr/bin/open -a Terminal /usr/bin/osascript -e return 0 } newincmd ls newincmd echo "hello \" world" newincmd echo $
on run -- Figure out if we want to do the cd (doIt) -- Figure out what the path is and quote it (myPath) try tell application "Finder" to set doIt to frontmost set myPath to finder_path() if myPath is equal to "" then set doIt to false else set myPath to quote_for_bash(myPath) end if on error set doIt to false end try -- Figure out if we need to open a window -- If Terminal was not running, one will be opened automatically tell application "System Events" to set isRunning to (exists process "Terminal") tell application "Terminal" -- Open a new window if isRunning then do script "" activate -- cd to the path if doIt then -- We need to delay, terminal ignores the second do script otherwise delay 0.3 do script " cd " & myPath in front window end if end tell end run on finder_path() try tell application "Finder" to set the source_folder to (folder of the front window) as alias set thePath to (POSIX path of the source_folder as string) on error -- no open folder windows set thePath to "" end try return thePath end finder_path -- This simply quotes all occurrences of on quote_for_bash(theString) set oldDelims to AppleScript set AppleScript set the parsedList to every text item of theString set AppleScript set theString to the parsedList as string set AppleScript return " end quote_for_bash
function new_window { TMP_FILE=$(mktemp "/tmp/command.XXXXXX") echo " set | grep -v "\(BASH_VERSINFO\|EUID\|PPID\|SHELLOPTS\|UID\)" >> $TMP_FILE export -p >> $TMP_FILE echo "cd $(pwd)" >> $TMP_FILE echo "$@" >> $TMP_FILE chmod +x "$TMP_FILE" open -b com.apple.terminal "$TMP_FILE" sleep .1 rm "$TMP_FILE" }
trun_cmd=`mktemp` echo "cd `pwd`" >$trun_cmd echo echo clear >>$trun_cmd echo $* >>$trun_cmd echo rm $trun_cmd >>$trun_cmd chmod +x $trun_cmd open -b com.apple.terminal $trun_cmd
NUMOFLINES=$(wc -l $JAVA_TAGS_FILE) echo $NUMOFLINES" lines" echo $(wc -l $JAVA_TAGS_FILE)" lines" echo "$(wc -l $JAVA_TAGS_FILE) lines"
121711 /home/slash/.java_base.tag lines 121711 /home/slash/.java_base.tag lines 121711 /home/slash/.java_base.tag lines
$ wc -l /etc/passwd 41 /etc/passwd $ cat /etc/passwd | wc -l 41 $ < /etc/passwd wc -l 41 $ wc -l < /etc/passwd 41
nbLines=$(cat -n file.txt | tail -n 1 | cut -f1 | xargs)
foo: for i in `find`; \ do \ all="$$all $$i"; \ done; \ gcc $$all
mytarget: { \ set -e ;\ msg="header:" ;\ for i in $$(seq 1 3) ; do msg="$$msg pre_$${i}_post" ; done ;\ msg="$$msg :footer" ;\ echo msg=$$msg ;\ }
function argv { for a in ${BASH_ARGV[*]} ; do echo -n "$a " done echo } function f { echo f $1 $2 $3 echo -n f ; argv } function g { echo g $1 $2 $3 echo -n g; argv f } f boo bar baz g goo gar gaz
$ ./f.sh arg0 arg1 arg2 f boo bar baz farg2 arg1 arg0 g goo gar gaz garg2 arg1 arg0 f farg2 arg1 arg0
args=("$@") echo $ echo ${args[0]} ${args[1]} ${args[2]}
my_function() { echo "stored arguments:" for arg in "${commandline_args[@]}"; do echo " $arg" done } commandline_args=("$@") my_function
echo name of script is $0 echo first argument is $1 echo second argument is $2 echo seventeenth argument is $17 echo number of arguments is $#
SCRIPT_NAME=$0 ARG_1=$1 ARGS_ALL=$* function stuff { echo $0 $* } stuff 1 2 3 4
function argument(){ for i in $@;do echo $i done; } argument $@
function print() { while [ $ do echo $1; shift 1; done } print $*;
command="ls"; echo "Command: $command"; b=`$command`; echo $b;
Command: ls | grep -c ls: cannot access |: No such file or directory ls: cannot access grep: No such file or directory ls: cannot access
sendto() { subject=$1 shift first=1 for addr; do if [ "$first" = 1 ]; then set --; first=0; fi set -- "$@" --recipient="$addr" done if [ "$first" = 1 ]; then echo "usage: sendto subject address [address ...]" return 1 fi MailTool --subject="$subject" "$@" }
stored_date=$(date) echo $stored_date echo $stored_date
stored_date=`date` echo $stored_date echo $stored_date
stored_date=$(eval "date") echo $stored_date echo $stored_date
stored_date="date" echo $(eval $stored_date) echo $(eval $stored_date)
$ [ a == a ]; echo $? 0 $ [ a -eq a ]; echo $? -bash: [: a: integer expression expected 2
$ [ 1 -eq 1 ]; echo $? 0 $ [ 1 -eq 2 ]; echo $? 1 $ test 1 -eq 1; echo $? 0
$ [[ "abc" == "abc" ]]; echo $? 0 $ [[ "abc" == "ABC" ]]; echo $? 1
$ [[ "0x10" -eq 16 ]]; echo $? 0 $ [[ "010" -eq 8 ]]; echo $? 0 $ [[ "100" -eq 100 ]]; echo $? 0
$ [[ "yes" -eq 0 ]]; echo $? 0 $ [[ "yes" -eq 1 ]]; echo $? 1
$ rht="A*" $ lft="AB" $ [ $lft = $rht ] && echo yes $ [ $lft == $rht ] && echo yes $ [[ $lft = $rht ]] && echo yes yes $ [[ $lft == $rht ]] && echo yes yes $ [[ $lft == "$rht" ]] && echo yes $
function println { printf "$1\n" "${@:2}" } function error { println exit "$1" } error 1234 Something went wrong. error 1234
function println { eval printf "$2\n" "${@:3}" $1 } function error { println exit $1 } error 1234 Something went wrong.
function println { eval } function error { println exit $1 } error 1234 Something went wrong.
$(command) `command` $(command1 "$(command2)") `command "\`command\`"`
exec 3<&0 exec 3>&1 exec 3>&2 exec 3> /dev/null exec 3> file.txt exec 3> "$var" exec 3<&0 4>&1
command <&3 command >&3 command 2>&3 command &>&3 command 2>&1 >&3 command >&3 2>&1 command <&3 >&4
VAR_2= local ref="${REF}_2" echo "${!ref}" eval "echo \"\$${REF}_2\""
declare -A VAR declare -gA VAR declare -A VAR=( [ VAR+=( [ VAR[ unset VAR[ unset VAR unset VAR[@] unset VAR[*] local KEYS=( "${!VAR[@]}" )
VAR=( ) declare "VAR_$key"="$value" VAR+="$key" VAR=( "$VAR[@]" "$key" ) local var_key="VAR_$key" local var_value="${!var_key}" local var_value="`eval echo -n \"\$$var_value\"" declare "VAR_$key"="$value" echo "`var_key="VAR_$key" echo -n "${!var_key}"`" function mkkey { local key="`mkpasswd -5R0 "$1" 00000000`" echo -n "${key } local var_key="VAR_`mkkey "$key"`"
function token_quote { local quoted=() for token; do quoted+=( "$(printf done printf }
% eval "$(echo "${cmd[@]}")" User gave: Trying to hack you Thu Sep 27 20:41:31 +07 2018
% eval "$(token_quote "${cmd[@]}")" User gave: Trying to hack you; date %
Signal Value Action Comment ---------------------------------------------------------------------- SIGTERM 15 Term Termination signal SIGINT 2 Term Famous CONTROL+C interrupt from keyboard SIGHUP 1 Term Disconnected terminal or parent died SIGPIPE 13 Term Broken pipe SIGALRM(*) 14 Term Timer signal from alarm SIGUSR2(*) 12 Term User-defined signal 2 SIGUSR1(*) 10 Term User-defined signal 1 SIGQUIT 3 Core CONTRL+\ or quit from keyboard SIGABRT 6 Core Abort signal from abort(3) SIGSEGV 11 Core Invalid memory reference SIGILL 4 Core Illegal Instruction SIGFPE 8 Core Floating point exception SIGKILL 9 Term Kill signal
for SIG in 15 2 3 6 9 ; do echo $SIG ; echo kill -$SIG $PID || break ; sleep 30 ; done
$pid = 1234 echo "Killing process $pid..." kill $pid waitAttempts=30 for i in $(seq 1 $waitAttempts) do echo "Checking if process is alive (attempt sleep 1 if ps -p $pid > /dev/null then echo "Process $pid is still running" else echo "Process $pid has shut down successfully" break fi done if ps -p $pid > /dev/null then echo "Could not shut down process $pid gracefully - killing it forcibly..." kill -SIGKILL $pid fi
maxdelay=$((14*60)) for ((i=1; i<=20; i++)); do delay=$(($RANDOM%maxdelay)) (sleep $((delay*60)); /path/to/phpscript.php) & done
30 8-21/* * * * sleep ${RANDOM:0:2}m ; /path/to/script.php
30 8-21/* * * * sleep $[RANDOM\%90]m ; /path/to/script.php
* * * * * nobody sleep $(( 1$(date +\%N) \% 60 )) ; dostuffs
if [ -n $BROWSER ]; then $BROWSER elif which xdg-open > /dev/null; then xdg-open elif which gnome-open > /dev/null; then gnome-open else echo "Could not detect the web browser to use." fi
if which xdg-open > /dev/null then xdg-open URL elif which gnome-open > /dev/null then gnome-open URL fi
URL=$1 [[ -x $BROWSER ]] && exec "$BROWSER" "$URL" path=$(which xdg-open || which gnome-open) && exec "$path" "$URL" echo "Can
$ time find -type f -printf 8 real 0m0.004s user 0m0.000s sys 0m0.007s
$ time find -type f | wc -l 8 real 0m0.006s user 0m0.003s sys 0m0.000s
countfiles () { command find "${1:-.}" -type f -name "${2:-*}" -print0 | command tr -dc return 0 } countfiles countfiles ~
n=0 while read -r -d ((n++)) done < <(find <expr> -print0) echo $n
$ time (i=0; for d in /dev/sd*[a-z]; do ((i++)); done; echo $i) 25 real 0m0.001s user 0m0.000s sys 0m0.000s
$ time find /dev/sd*[a-z] | wc -l 25 real 0m0.006s user 0m0.000s sys 0m0.004s $ time find /dev/sd*[a-z] -printf . | wc -c 25 real 0m0.005s user 0m0.000s sys 0m0.000s
$ str="This is just a test" $ echo ${str This_is_just_a_test
if brew ls --versions myformula > /dev/null; then else fi
for pkg in macvim ngrep other needed packages; do if brew list -1 | grep -q "^${pkg}\$"; then echo "Package else echo "Package fi done
$ I=foobar $ echo ${I/oo/aa} faabar $ echo ${I:1:2} oo $ echo ${I%bar} foo $ echo ${I bar
if [[ $(($RANDOM % 6)) = 0 ]] then echo "BANG" else echo "Try again" fi
$ cat /proc/cupinfo cat: /proc/cupinfo: No such file or directory $ ^cup^cpu
if [ 2 -lt 3 ] then echo "Numbers are still good!" fi
if [[ 2 < 3 ]] then echo "Numbers are still good!" fi
array[0]="a string" array[1]="a string with spaces and \"quotation\" marks in it" array[2]="a string with spaces, \"quotation marks\" and (parenthesis) in it" echo "There are ${ for n in "${array[@]}"; do echo "element = >>${n}<<" done
[lsc@home]$ export PROMPT_COMMAND="date" Fri Jun 5 15:19:18 BST 2009 [lsc@home]$ ls file_a file_b file_c Fri Jun 5 15:19:19 BST 2009 [lsc@home]$ ls
if [[ $((2+1)) = $((1+2)) ]] then echo "still ok" fi
$ echo foo{bar,baz,blam} foobar foobaz fooblam $ cp program.py{,.bak}
$ echo {a..z} a b c d e f g h i j k l m n o p q r s t u v w x y z $ echo {a..f}{0..3} a0 a1 a2 a3 b0 b1 b2 b3 c0 c1 c2 c3 d0 d1 d2 d3 e0 e1 e2 e3 f0 f1 f2 f3
device=/dev/rmt8 dd_noise= exec 3>&1 status=`((dd if=$device ibs=64k 2>&1 1>&3 3>&- 4>&-; echo $? >&4) | egrep -v "$dd_noise" 1>&2 3>&- 4>&-) 4>&1` exit $status;
let x="RANDOM%2**8" echo -n "$x = 0b" for ((i=8; i>=0; i--)); do let n="2**i" if (( (x&n) == n )); then echo -n "1" else echo -n "0" fi done echo ""
$ curl -o /dev/null --silent --head --write-out 200
while read LINE; do curl -o /dev/null --silent --head --write-out "%{http_code} $LINE\n" "$LINE" done < url-list.txt
xargs -n1 -P 10 curl -o /dev/null --silent --head --write-out
xargs -n1 -P 10 curl -o /dev/null --silent --head --write-out
wget --server-response --spider --quiet "${url}" 2>&1 | awk
wget --server-response --spider --quiet "${url}" 2>&1 | awk
-p Create intermediate directories as required. If this option is not specified, the full path prefix of each oper- and must already exist. On the other hand, with this option specified, no error will be reported if a directory given as an operand already exists. Intermediate directories are created with permission bits of rwxrwxrwx (0777) as modified by the current umask, plus write and search permission for the owner.
if [[ ! -e $dir ]]; then mkdir $dir elif [[ ! -d $dir ]]; then echo "$Message" 1>&2 fi
PID TTY TIME CMD 11383 pts/1 00:00:00 bash 11771 pts/1 00:00:00 ps
$ ps h -o pid,user -C ssh,sshd | tr -s " " 1543 root 19645 root 19731 root
out=$(ps whatever | { read a b c d; echo $c; }) arr=($(ps whatever | { read a b c d; echo $c $b; })) echo ${arr[1]}
ps |& while read -p first second third fourth etc ; do if [[ $first == then echo got: $fourth fi done
[parameters.ini] database_user = user database_version = 20110611142248
php app/console doctrine:migrations:migrate $DATABASE_VERSION
[section-a] var1=value1 var2=value2 IPS=( "1.2.3.4" "1.2.3.5" )
cfg_parser () { ini="$(<$1)" ini="${ini ini="${ini IFS=$ ini=( ${ini[*] ini=( ${ini[*]/\ =/=} ) ini=( ${ini[*]/=\ /=} ) ini=( ${ini[*]/\ =\ /=} ) ini=( ${ini[*]/ ini=( ${ini[*]/%\\]/ \(} ) ini=( ${ini[*]/=/=\( } ) ini=( ${ini[*]/%/ \)} ) ini=( ${ini[*]/%\\ \)/ \\} ) ini=( ${ini[*]/%\( \)/\(\) \{} ) ini=( ${ini[*]/%\} \)/\}} ) ini[0]="" ini[${ eval "$(echo "${ini[*]}")" } cfg_writer () { IFS= fun="$(declare -F)" fun="${fun for f in $fun; do [ "${f item="$(declare -f ${f})" item="${item item="${item%\}}" item="${item vars="${item eval $f echo "[${f for var in $vars; do echo $var=\"${!var}\" done done }
. example.ini echo "${DBNAME} ${DBUSER} ${DBPASSWORD}"
[section1] param1=123 param2=345 param3=678 [section2] param1=abc param2=def param3=ghi [section3] param1=000 param2=111 param3=222
sed -nr "/^\[section2\]/ { :l /^param2[ ]*=/ { s/.*=[ ]*
$ cat my_file something = foo my_key = bar not_my_key = baz my_key_2 = bing $ sed -n -e bar
[owner] name=John Doe organization=Acme Widgets Inc. [database] server=192.0.2.62 port=143 file=payroll.dat
1 { x s/^/default/ x } / /\[/ { s/\[\(.*\)\]/\1/ x b } /=/ { s/^[[:space:]]*// s/[[:space:]]*=[[:space:]]*/|/ G s/\(.*\)\n\(.*\)/\2|\1/ p }
owner|name|John Doe owner|organization|Acme Widgets Inc. database|server|192.0.2.62 database|port|143 database|file|payroll.dat
value=$(myconfig.py something.ini sectionname value)
import sys import configparser import argparse if __name__ == parser = argparse.ArgumentParser(description="A program that Bash can call to parse an .ini file") parser.add_argument("inifile", help="name of the .ini file") parser.add_argument("section", help="name of the section in the .ini file") parser.add_argument("itemname", help="name of the desired value") args = parser.parse_args() config = configparser.ConfigParser() config.read(args.inifile) print(config.get(args.section, args.itemname))
function parseIniFile() { unset g_iniProperties declare -gA g_iniProperties currentSection="" while read -r line do if [[ $line = [* ]] ; then if [[ $line = [* ]] ; then currentSection=$(echo $line | sed -e fi else if [[ $line = *=* ]] ; then cleanLine=$(echo $line | sed -e key=$currentSection.$(echo $cleanLine | awk -F: value=$(echo $cleanLine | awk -F: g_iniProperties[$key]=$value fi fi; done < $1 }
parseIniFile "/path/to/myFile.ini" for key in "${!g_iniProperties[@]}"; do echo "Found key/value $key = ${g_iniProperties[$key]}" done
$ python3 -c "import configparser; c = configparser.ConfigParser(); c.read( 20110611142248
INIFILE=$1 SECTION=$2 ITEM=$3 cat $INIFILE | sed -n /^\[$SECTION\]/,/^\[.*\]/p | grep "^[:space:]*$ITEM[:space:]*=" | sed s/.*=[:space:]*//
function Show_Debug { [[ $DEBUG = YES ]] && echo "DEBUG $@" } function Fatal { echo "$@. Script aborted" exit 2 } # # # function Load_Ini { Show_Debug "$0($@)" typeset ini_file="$1" typeset ini_array_name="${2:-ini}" typeset section variable value line my_section file subsection value_array include_directory all_index index sections pre_parse typeset LF=" " if [[ ! -s $ini_file ]]; then Fatal "The ini file is empty or absent in $0 [$ini_file]" fi include_directory=$(dirname $ini_file) include_directory=${include_directory:-$(pwd)} Show_Debug "include_directory=$include_directory" section="" Show_Debug "Reading file $ini_file and putting the results in array $ini_array_name" pre_parse="$(sed while read line; do if [[ ${line:0:1} = "[" ]]; then section="${line:1}" section="${section%\]}" eval "sections=\${$ini_array_name[sections_list]}" sections="$sections${sections:+ }$section" eval "$ini_array_name[sections_list]=\"$sections\"" Show_Debug "$ini_array_name[sections_list]=\"$sections\"" eval "$ini_array_name[$section.exist]=YES" Show_Debug "$ini_array_name[$section.exist]= else variable=${line%%=*} value=${line if [[ $variable = includefile ]]; then Load_Ini "$include_directory/$value" "$ini_array_name" continue elif [[ $variable = includedir ]]; then if [[ $value != /* ]]; then value="$include_directory/$value" fi for file in $(ls $value/*.ini 2>/dev/null); do if [[ $file != *.ini ]]; then continue; fi Load_Ini "$file" "$ini_array_name" done continue elif [[ $variable = includesection ]]; then eval "all_index=\"\${!$ini_array_name[@]}\"" for index in $all_index; do if [[ $index = $value.* ]]; then subsection=${index eval "value_array=\"\${$ini_array_name[$index]}\"" eval "$ini_array_name[$section.$subsection]=\"\$value_array\"" Show_Debug "$ini_array_name[$section.$subsection]=\"$value_array\"" fi done fi eval "current_value=\"\${$ini_array_name[$section.$variable]}\"" new_value="$current_value${current_value:+$LF}$value" eval "$ini_array_name[$section.$variable]=\"\$new_value\"" Show_Debug "$ini_array_name[$section.$variable]=\"$new_value\"" fi done <<< "$pre_parse" Show_Debug "exit $0($@)\n" }
awk -F sub(/^ +/, "", $2); sub(/ +$/, "", $2); print $2; exit; }
[section1] name1=value1 name2=value2 [section2] name1=value_1 name2 = value_2
set +a while read p; do reSec= reNV= if [[ $p =~ $reSec ]]; then section=${BASH_REMATCH[1]} elif [[ $p =~ $reNV ]]; then sNm=${section}_${BASH_REMATCH[1]} sVa=${BASH_REMATCH[2]} set -a eval "$(echo "$sNm"=\""$sVa"\")" set +a fi done < $1
import configparser import sys config = configpParser.ConfigParser() config.read(sys.argv[1]) print config.get(sys.argv[2],sys.argv[3])
OrangeQty=$(python configparser.py food.ini FRUIT Oranges)
ApplesQty=$(python configparser.py food.ini FRUIT Apples) echo $ApplesQty
trim() { local trimmed="$1" trimmed="${trimmed trimmed="${trimmed%% }" echo "$trimmed" } function parseIniFile() { unset g_iniProperties declare -gA g_iniProperties currentSection="" while read -r line do if [[ $line = [* ]] ; then if [[ $line = [* ]] ; then currentSection=$(echo $line | sed -e fi else if [[ $line = *=* ]] ; then cleanLine=$(echo $line | sed -e key=$(trim $currentSection.$(echo $cleanLine | cut -d value=$(trim $(echo $cleanLine | cut -d g_iniProperties[$key]=$value fi fi; done < $1 }
php vendor/bin/mysql-workbench-schema-export mysqlworkbenchfile.mwb ./doctrine << EOF ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` ` EOF
set timeout 360 spawn my_command expect "Do you want to continue?" { send "\r" }
for i in `find devel/ -newer $UPLOAD_FILE` do echo "Upload:" $i if [ -d $i ] then echo "Creating directory" $i ssh $USER@$SERVER "cd ${REMOTE_PATH}; mkdir -p $i" continue fi if scp -Cp $i $USER@$SERVER:$REMOTE_PATH/$i then echo "$i OK" else echo "$i NOK" rm ${UPLOAD_FILE}_tmp fi done
find devel/ -newer $UPLOAD_FILE | while read i do echo "Upload:" $i if [ -d $i ] then echo "Creating directory" $i ssh $USER@$SERVER "cd ${REMOTE_PATH}; mkdir -p $i" continue fi if scp -Cp $i $USER@$SERVER:$REMOTE_PATH/$i then echo "$i OK" else echo "$i NOK" rm ${UPLOAD_FILE}_tmp fi done
ssh $USER@$SERVER "cd ${REMOTE_PATH}; mkdir -p $i" < /dev/null
while IFS= read -u 3 -r -d if [[ -d $filename ]]; then printf -v cmd_str ssh "$USER@$SERVER" "$cmd_str" else printf -v remote_path_str scp -Cp "$filename" "$remote_path_str" fi done 3< <(find devel/ -newer "$UPLOAD_FILE" -print0)
find devel/ -newer $UPLOAD_FILE | while read -r i do ...
for filename in /home/user/* do echo $filename done;
for filename in $(ls /home/user/) do echo $filename done;
diff /tmp/test1 /tmp/test2 1,4c1,2 < asfdsadf < asdfsad < fsaf < fdsadf --- > asdfsafdsf > saf 6,8d3 < sadf < asdf < sadf 10d4 < fasd 12,13c6,14 < sadfa < fd --- > sadf > sadf > sadf > sadf > sadf > sadf > sadf > sadf > safa
diff /tmp/test1 /tmp/test2 1,4c1,2 < asfdsadf > asdfsafdsf < asdfsad > saf < fsaf < fdsadf --- 6,8d3 < sadf < asdf < sadf 10d4 < fasd 12,13c6,14 < sadfa > sadf < fd > sadf --- > sadf > sadf > sadf > sadf > sadf > sadf > safa
$ cat a $ cat b hello hello my name my name is me is you
$ diff -y a b hello hello my name my name is me | is you
$ echo "hello1-`echo hello2-\`echo hello3-\`echo hello4\`\``" hello1-hello2-hello3-echo hello4
$ echo "hello1-$(echo hello2-$(echo hello3-$(echo hello4)))" hello1-hello2-hello3-hello4
echo hello{1..10} hello1 hello2 hello3 hello4 hello5 hello6 hello7 hello8 hello9 hello10
$ echo "hello1-`echo hello2-\`echo hello3-\\\`echo hello4\\\`\``"
$ echo "hello1-$(echo hello2-$(echo hello3-$(echo hello4)))" hello1-hello2-hello3-hello4
$ unzip -q -c commons-lang-2.4.jar META-INF/MANIFEST.MF Manifest-Version: 1.0 Ant-Version: Apache Ant 1.7.0 Created-By: 1.5.0_13-119 (Apple Inc.) Package: org.apache.commons.lang Extension-Name: commons-lang Specification-Version: 2.4 Specification-Vendor: Apache Software Foundation Specification-Title: Commons Lang Implementation-Version: 2.4 Implementation-Vendor: Apache Software Foundation Implementation-Title: Commons Lang Implementation-Vendor-Id: org.apache X-Compile-Source-JDK: 1.3 X-Compile-Target-JDK: 1.2
$ unzip -q -c $JARFILE_PATH META-INF/MANIFEST.MF | grep
docker inspect -f "{{.State.Running}}" $CONTAINER_ID
id=$(docker run mycontainer) if ! docker top $id &>/dev/null then echo "Container crashed unexpectedly..." return 1 fi
seq 1 500000 | while read digit; do touch $(printf "abigfilename%06d\n" $digit); done
$ /bin/echo * > /dev/null bash: /bin/echo: Argument list too long
$ echo "foo" \ > "bar" foo bar $ echo foo | > cat foo $ echo foo && > echo bar foo bar $ false || > echo bar bar
printf -v var "%q\n" "hello\world" echo "$var" hello\\world
localization of command-line messages (i18n) 258 3.6%
LANGUAGE LC_ALL LC_xxx, according to selected locale category: LC_CTYPE, LC_NUMERIC, LC_TIME, LC_COLLATE, LC_MONETARY, LC_MESSAGES, ... LANG
if [ $ echo "Error... Usage: $0 host database username" exit 0 fi
if [ $ echo "Error... Usage: $0 host database username" exit 0 fi
if [ $ echo "Error... Usage: $0 host database username" exit 0 fi
if [[ $ echo "Error... Usage: $0 host database username" exit 0 fi
if [ $ echo "Error... Usage: $0 host database username" exit 0 fi
find src/ ! -name Default.png -exec cp -t dest/ {} +
find src/ -type f ! -name Default.png -exec cp -t dest/ {} +
find src/ -type f -maxdepth 1 ! -name Default.png -exec cp -t dest/ {} +
rsync -av from/ to/ --exclude=Default.png -a, --archive archive mode; equals -rlptgoD (no -H,-A,-X) -v, --verbose increase verbosity
find srcdir -type f/ |grep -v Default.png$ |xargs -ILIST cp LIST destdir/
sudo echo "[archlinuxfr]" >> /etc/pacman.conf sudo echo "Server = http: sudo echo " " >> /etc/pacman.conf -bash: /etc/pacman.conf: Permission denied
sudo tee -a /etc/pacman.conf >/dev/null << [archlinuxfr] Server = http: EOF
function write_pacman { tee -a /etc/pacman.conf > /dev/null << [archlinuxfr] Server = http: EOF }
for name in $(git diff --name-only $1); do git difftool $1 $name & done
git config --global alias.diffall ***my-bash-code-here***
$ vim ~/.gitconfig ... [alias] foo = "! echo begin arg=$1/$2/end" foo2 = "!f() { echo "begin arg=$1/$2/end"; }; f"
$ git foo a b c begin arg=a/b/end a b c $ git foo2 a b c begin arg=a/b/end
[alias] alias = "!f() { git config --get-regexp "^alias.${1}$" ; }; f"
$ git alias foo alias.foo ! echo begin arg=$1/$2/end $ git alias alias.foo ! echo begin arg=$1/$2/end alias.foo2 !f() { echo begin arg=$1/$2/end; }; f
$ cd ~/bin $ echo "echo I love this log: >pwd >git log --graph --summary --decorate --all" > git-logg $ chmod +x git-logg $ cd /path/to/your/repo $ git logg I love this log: /path/to/your/repo * commit 3c94be44e4119228cc681fc7e11e553c4e77ad04 (whatever-branch) | Author: myself <my@Laptop.(none)> | Date: Fri Apr 1 16:47:20 2011 +0200 | | would have been better not to do it at all | ... $
$ git checkout master Switched to branch This is run after a
all: <Building, creating some .tgz files - removed for clarity> FILES = $(shell ls) echo $(FILES)
make FILES = Makefile file1.tgz file2.tgz file3.tgz make: FILES: No such file or directory make: *** [all] Error 1
touch /ls chmod +x /ls cmd= PATH=/:$PATH if cmdpath="$(type -P "$cmd")" && cmdpath="${cmdpath%/*}" ; then cd "${cmdpath:-/}" || { echo "Could not cd to: ${cmdpath:-/}"; exit 1; } else echo "No such program in PATH search directories: ${cmd}" exit 1 fi
unset a i while IFS= read -r -d $ a[i++]="$file" done < <(find /tmp -type f -print0)
unset a i while IFS= read -r -u3 -d $ a[i++]="$file" done 3< <(find /tmp -type f -print0)
for i in `find -type f -exec base64str do file="`echo -n "$i" | base64 -d`" done
for ((i = $i - 1; i >= 0; i--)); do ls -al "${array[$i]}" done
man ruby | less -p 777 IFS=$ array=( $(find ~ -maxdepth 1 -type f -exec printf "%s\777" echo ${ printf "%s\n" "${array[@]}" | nl echo "${array[0]}" IFS=$
STYLE="$HOME/.fluxbox/styles/" declare -a array1 LISTING=`find $HOME/.fluxbox/styles/ -print0 -maxdepth 1 -type f` echo $LISTING array1=( `echo $LISTING`) TAR_SOURCE=`echo ${array1[@]}`
files=(*) i=0 for file in "${files[@]}" do echo "File ${i}: ${file}" let i++ done
savedFS="$IFS" IFS=$ filenames=(`find wherever -printf %p$ IFS="$savedFS"
LOCKFILE=/tmp/lock.txt if [ -e ${LOCKFILE} ] && kill -0 `cat ${LOCKFILE}`; then echo "already running" exit fi trap "rm -f ${LOCKFILE}; exit" INT TERM EXIT echo $$ > ${LOCKFILE} sleep 1000 rm -f ${LOCKFILE}
( flock -x -w 10 200 || exit 1 ) 200>/var/lock/.myscript.exclusivelock
if ! mkdir /tmp/myscript.lock 2>/dev/null; then echo "Myscript is already running." >&2 exit 1 fi
# # # mutex() { local file=$1 pid pids exec 9>>"$file" { pids=$(fuser -f "$file"); } 2>&- 9>&- for pid in $pids; do [[ $pid = $$ ]] && continue exec 9>&- return 1 done }
mutex /var/run/myscript.lock || { echo "Already running." >&2; exit 1; }
if mkdir /var/lock/.myscript.exclusivelock then : rmdir /var/lock/.myscript.exclusivelock fi
set -C lockfile="/tmp/locktest.lock" if echo "$$" > "$lockfile"; then echo "Successfully acquired lock" rm "$lockfile" else echo "Cannot acquire lock - already locked by $(cat "$lockfile")" fi
$ strace -e trace=creat,open -f /bin/bash /home/mikel/bin/testopen 2>&1 | grep -F testopen.lock open("/tmp/testopen.lock", O_WRONLY|O_CREAT|O_EXCL|O_LARGEFILE, 0666) = 3 $ strace -e trace=creat,open -f /bin/zsh /home/mikel/bin/testopen 2>&1 | grep -F testopen.lock open("/tmp/testopen.lock", O_WRONLY|O_CREAT|O_EXCL|O_NOCTTY|O_LARGEFILE, 0666) = 3 $ strace -e trace=creat,open -f /bin/pdksh /home/mikel/bin/testopen 2>&1 | grep -F testopen.lock open("/tmp/testopen.lock", O_WRONLY|O_CREAT|O_EXCL|O_TRUNC|O_LARGEFILE, 0666) = 3 $ strace -e trace=creat,open -f /bin/dash /home/mikel/bin/testopen 2>&1 | grep -F testopen.lock open("/tmp/testopen.lock", O_WRONLY|O_CREAT|O_EXCL|O_LARGEFILE, 0666) = 3
TMPDIR=/tmp/myapp [[ ! -d $TMP_DIR ]] \ && mkdir -p $TMP_DIR \ && chmod 700 $TMPDIR LOCK_DIR=$TMP_DIR/lock function mklock { __lockdir="$LOCK_DIR/$(date +%s.%N).$$" if $(mkdir $LOCK_DIR) then mkdir $__lockdir LOCK_EXISTS=true else echo "FATAL: Lock already exists. Another copy is running or manually lock clean up required." exit 1001 fi } function rmlock { [[ ! -d $__lockdir ]] \ && echo "WARNING: Lock is missing. $__lockdir does not exist" \ || rmdir $__lockdir } # function __sig_exit { [[ -n $LOCK_EXISTS ]] && rmlock } function __sig_int { echo "WARNING: SIGINT caught" exit 1002 } function __sig_quit { echo "SIGQUIT caught" exit 1003 } function __sig_term { echo "WARNING: SIGTERM caught" exit 1015 } trap __sig_exit EXIT trap __sig_int INT trap __sig_quit QUIT trap __sig_term TERM mklock exit
sem --id SCRIPTSINGLETON --semaphoretimeout -10 yourScript
[[ $(pgrep -c "`basename \"$0\"`") -gt 1 ]] && exit
SCRIPTNAME=$(basename $0) LOCKDIR="/var/lock/${SCRIPTNAME}" PIDFILE="${LOCKDIR}/pid" if ! mkdir $LOCKDIR 2>/dev/null then PID=$(cat $PIDFILE) if ! kill -0 $PID 2>/dev/null then echo "Removing stale lock of nonexistent PID ${PID}" >&2 rm -rf $LOCKDIR echo "Restarting myself (${SCRIPTNAME})" >&2 exec "$0" "$@" fi echo "$SCRIPTNAME is already running, bailing out" >&2 exit 1 else echo $$ > $PIDFILE fi trap "rm -rf ${LOCKDIR}" QUIT INT TERM EXIT echo hello sleep 30s echo bye
( flock -x -w 10 200 if [ "$?" != "0" ]; then echo Cannot lock!; exit 1; fi echo $$>>/var/lock/.myscript.exclusivelock ) 200>/var/lock/.myscript.exclusivelock FLOCKEXIT=$? exit $FLOCKEXIT
function exclusive_lock_try() { local LOCK_NAME="${1:-`basename $0`}" LOCK_DIR="/tmp/.${LOCK_NAME}.lock" local LOCK_PID_FILE="${LOCK_DIR}/${LOCK_NAME}.pid" if [ -e "$LOCK_DIR" ] then local LOCK_PID="`cat "$LOCK_PID_FILE" 2> /dev/null`" if [ ! -z "$LOCK_PID" ] && kill -0 "$LOCK_PID" 2> /dev/null then echo "\"$LOCK_NAME\" lock currently held by PID $LOCK_PID" return 1 else ( echo $$ > "$LOCK_PID_FILE" ) 2> /dev/null && local LOCK_PID="$$" fi fi if [ "`trap -p EXIT`" != "" ] then echo "Cannot get lock, already have an EXIT trap" return 1 fi if [ "$LOCK_PID" != "$$" ] && ! ( umask 077 && mkdir "$LOCK_DIR" && umask 177 && echo $$ > "$LOCK_PID_FILE" ) 2> /dev/null then local LOCK_PID="`cat "$LOCK_PID_FILE" 2> /dev/null`" echo "\"$LOCK_NAME\" lock currently held by PID $LOCK_PID" return 1 fi trap "/bin/rm -rf \"$LOCK_DIR\"; exit;" EXIT return 0 } function exclusive_lock_retry() { local LOCK_NAME="$1" local MAX_TRIES="${2:-5}" local DELAY="${3:-2}" local TRIES=0 local LOCK_RETVAL while [ "$TRIES" -lt "$MAX_TRIES" ] do if [ "$TRIES" -gt 0 ] then sleep "$DELAY" fi local TRIES=$(( $TRIES + 1 )) if [ "$TRIES" -lt "$MAX_TRIES" ] then exclusive_lock_try "$LOCK_NAME" > /dev/null else exclusive_lock_try "$LOCK_NAME" fi LOCK_RETVAL="${PIPESTATUS[0]}" if [ "$LOCK_RETVAL" -eq 0 ] then return 0 fi done return "$LOCK_RETVAL" } function exclusive_lock_require() { if ! exclusive_lock_retry "$@" then exit 1 fi }
{ flock -n 100 || exit sleep 100 } 100>/tmp/myjob.lock
lockfile=/var/lock/myscript.lock if ( set -o noclobber; echo "$$" > "$lockfile") 2> /dev/null ; then trap else echo "Another instance is already running!" fi
LOCKFILE=/var/tmp/lockfile trap release INT TERM EXIT acquire () { set -C UUID=`ps -eo pid,ppid,lstart $$ | tail -1` if (echo "$UUID" > "$LOCKFILE") 2>/dev/null; then ACQUIRED="TRUE" return 0 else if [ -e $LOCKFILE ]; then CURRENT_UUID_FROM_LOCKFILE=`cat $LOCKFILE` CURRENT_PID_FROM_LOCKFILE=`cat $LOCKFILE | cut -f 1 -d " "` CURRENT_UUID_FROM_PS=`ps -eo pid,ppid,lstart $CURRENT_PID_FROM_LOCKFILE | tail -1` if [ "$CURRENT_UUID_FROM_LOCKFILE" == "$CURRENT_UUID_FROM_PS" ]; then echo "Script already running with following identification: $CURRENT_UUID_FROM_LOCKFILE" >&2 return 1 else echo "The process $CURRENT_UUID_FROM_LOCKFILE is no longer around. Taking ownership of $LOCKFILE" release "FORCE" if (echo "$UUID" > "$LOCKFILE") 2>/dev/null; then ACQUIRED="TRUE" return 0 else echo "Cannot write to $LOCKFILE. Error." >&2 return 1 fi fi else echo "Do you have write permissons to $LOCKFILE ?" >&2 return 1 fi fi } release () { if [ "$ACQUIRED" ] || [ "$1" == "FORCE" ]; then rm -f $LOCKFILE fi } echo "Acquring lock." acquire if [ $? -eq 0 ]; then echo "Acquired lock." read -p "Press [Enter] key to release lock..." release echo "Released lock." else echo "Unable to acquire lock." fi
LOCKFILE=/tmp/singleton.lock if [ -e ${LOCKFILE} ] && kill -0 `cat ${LOCKFILE}`; then echo "Script already running. bye!" exit fi echo $$ > ${LOCKFILE}
if [ "${FLOCKER}" != "$0" ]; then echo "FLOCKER=$FLOCKER \$0=$0 ($$)" exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || : else echo "FLOCKER equals \$0 = $FLOCKER ($$)" fi sleep 10 echo "Process $$ finished"
obtain_lock() { LOCK="${1}" LOCKDIR="$(dirname "${LOCK}")" LOCKFILE="$(basename "${LOCK}")" TMPLOCK=$(mktemp -p "${LOCKDIR}" "${LOCKFILE}XXXXXX" 2> /dev/null) if test "x${TMPLOCK}" == "x";then echo "unable to create temporary file with mktemp" 1>&2 return 1 fi echo "$$" > "${TMPLOCK}" ln "${TMPLOCK}" "${LOCK}" 2> /dev/null if test $? -ne 0;then rm -f "${TMPLOCK}" echo "unable to obtain lockfile" 1>&2 if test -f "${LOCK}";then echo "current lock information held by: $(cat "${LOCK}")" 1>&2 fi return 2 fi rm -f "${TMPLOCK}" return 0; };
. /path/to/locking/profile.sh PROG_LOCKFILE="/tmp/myprog.lock" clean_up() { rm -f "${PROG_LOCKFILE}" } obtain_lock "${PROG_LOCKFILE}" if test $? -ne 0;then exit 1 fi trap clean_up SIGHUP SIGINT SIGTERM clean_up exit 0
exec 9<> /tmp/foo flock -n 9 RET=$? if [[ $RET -ne 0 ]] ; then echo "lock failed, exiting" exit fi echo "inside lock" sleep 5 exec 9>&- echo "lock released" sleep 5
function sh_lock_init { sh_lock_scriptName=$(basename $0) sh_lock_dir="/tmp/${sh_lock_scriptName}.lock" sh_lock_file="${sh_lock_dir}/lockPid.txt" } function sh_acquire_lock { if mkdir $sh_lock_dir 2>/dev/null; then echo "$sh_lock_scriptName lock acquired successfully.">&2 touch $sh_lock_file echo $$ > $sh_lock_file return 0 else touch $sh_lock_file read sh_lock_lastPID < $sh_lock_file if [ ! -z "$sh_lock_lastPID" -a -d /proc/$sh_lock_lastPID ]; then echo "$sh_lock_scriptName is already running.">&2 return 1 else echo "$sh_lock_scriptName stopped during execution, reacquiring lock.">&2 echo $$ > $sh_lock_file return 2 fi fi return 0 } function sh_check_lock { [[ ! -f $sh_lock_file ]] && echo "$sh_lock_scriptName lock file removed.">&2 && return 1 read sh_lock_lastPID < $sh_lock_file [[ $sh_lock_lastPID -ne $$ ]] && echo "$sh_lock_scriptName lock file pid has changed.">&2 && return 2 echo "$sh_lock_scriptName lock still in place.">&2 return 0 } function sh_remove_lock { rm -r $sh_lock_dir }
. /path/to/sh_lock_functions.sh sh_lock_init || exit $? sh_acquire_lock lockStatus=$? [[ $lockStatus -eq 1 ]] && exit $lockStatus [[ $lockStatus -eq 2 ]] && echo "lock is set, do some resume from crash procedures"; cnt=0 while sh_check_lock do echo "$sh_scriptName running (pid $$)" sleep 1 let cnt++ [[ $cnt -gt 5 ]] && break done sh_remove_lock || exit $? exit 0
if [ 1 -ne $(/bin/fuser "$0" 2>/dev/null | wc -w) ]; then exit 1 fi
something1: +12.0 (some unnecessary trailing data (this must go)) something2: +15.5 (some more unnecessary trailing data) something4: +9.0 (some other unnecessary data) something1: +13.5 (blah blah blah)
sedSelectNumbers= sedClearLastComma= cat file.txt |sed "$sedSelectNumbers" |tr -d "\n" |sed "$sedClearLastComma"
fg@erwin ~ $ perl -ne something1: +12.0 (some unnecessary trailing data (this must go)) something2: +15.5 (some more unnecessary trailing data) something4: +9.0 (some other unnecessary data) something1: +13.5 (blah blah blah) EOF +12.0,+15.5,+9.0,+13.5
$ cat file.txt something1: +12.0 (some unnecessary trailing data (this must go)) something2: +15.5 (some more unnecessary trailing data) something4: +9.0 (some other unnecessary data) something1: +13.5 (blah blah blah) $ sed +12.0,+15.5,+9.0,+13.5
bash-3.2$ cat sample.log something1: +12.0 (some unnecessary trailing data (this must go)) something2: +15.5 (some more unnecessary trailing data) something4: +9.0 (some other unnecessary data) something1: +13.5 (blah blah blah) bash-3.2$ awk +12.0,+15.5,+9.0,+13.5
sometext="something1: +12.0 (some unnecessary trailing data (this must go)) something2: +15.5 (some more unnecessary trailing data) something4: +9.0 (some other unnecessary data) something1: +13.5 (blah blah blah)" a=() while read -r a1 a2 a3; do a+=("${a2}") done <<< "${sometext}" (IFS=
something1: +12.0 (some unnecessary trailing data (this must go)) something2: +15.5 (some more unnecessary trailing data) something4: +9.0 (some other unnecessary data) something1: +13.5 (blah blah blah) OLDIFS=$IFS IFS=$ for i in $(cat bla.txt); do i=$(echo "$i" | awk u="${u:+$u, }$i" done IFS=$OLDIFS echo "$u" +12.0, +15.5, +9.0, +13.5
FROM ubuntu:14.04 COPY ./file.sh / CMD /bin/bash file.sh
docker run -ti test /file.sh abc docker run -ti test /file.sh xyz
FROM ubuntu:14.04 COPY ./file.sh / ENTRYPOINT ["/file.sh"] CMD []
% docker build -t test . % docker run test hello world Your container args are: hello world
FROM docker.io/ubuntu ADD run_container / ENTRYPOINT ["/bin/bash", "-c", "/run_container \"$@\"", "--"]
FROM ubuntu:14.04 COPY ./file.sh / RUN chmod 755 /file.sh ENTRYPOINT ["file.sh"]
( set -o posix ; set ) >/tmp/variables.before source script ( set -o posix ; set ) >/tmp/variables.after diff /tmp/variables.before /tmp/variables.after rm /tmp/variables.before /tmp/variables.after
for i in _ {a..z} {A..Z}; do eval "echo \${!$i@}" ; done | xargs printf "%s\n"
for var in ${!VARIABLE@}; do printf "%s%q\n" "$var=" "${!var}" done
for i in _ {a..z} {A..Z}; do for var in `eval echo "\\${!$i@}"`; do echo $var done done
comm -13 <(printf %s "$before") <(set -o posix; set | sort | uniq)
store() { export ${1}="${*:2}" [[ ${STORED} =~ "(^| )${1}($| )" ]] || STORED="${STORED} ${1}" } store VAR1 abc store VAR2 bcd store VAR3 cde for i in ${STORED}; do echo "${i}=${!i}" done
+ function SOLUTION() { (set +o posix; set) | sed -ne
+ function a() { echo $ + SOLUTION | grep A0=000 A9=999
$ bash --version GNU bash, version 4.4.12(1)-release (x86_64-pc-msys)
set -a env > /tmp/a source $1 env > /tmp/b diff /tmp/{a,b} | sed -ne
function doLogic() { local COMMAND="${1}" if ( set -o posix; set | grep -q then echo else echo fi } doLogic doLogic $
doEchoVars(){ test -z ${tmp_dir} && \ export tmp_dir="$(cd "$(dirname $0)/../../.."; pwd)""/dat/log/.tmp.$$" && \ mkdir -p "$tmp_dir" && \ ( set -o posix ; set )| sort >"$tmp_dir/.vars.before" ( set -o posix ; set ) | sort >"$tmp_dir/.vars.after" cmd="$(comm -3 $tmp_dir/.vars.before $tmp_dir/.vars.after | perl -ne echo -e "$cmd" }
ssh pvt@192.168.1.133 "~/tools/run_pvt.pl $BUILD_NUMBER"
ssh pvt@192.168.1.133 "~/tools/run_pvt.pl $BUILD_NUMBER"
ssh pvt@192.168.1.133 "env BUILD_NUMBER=$BUILD_NUMBER ~/tools/run_pvt.pl \$BUILD_NUMBER"
-regextype type Changes the regular expression syntax understood by -regex and -iregex tests which occur later on the command line. Currently-implemented types are emacs (this is the default), posix-awk, posix-basic, posix-egrep and posix-extended.
find -regextype posix-extended -regex find -regextype posix-extended -regex
-regex pattern File name matches regular expression pattern. This is a match on the whole path, not a search.
$ echo 23 23 $ echo $? 0 $ ! echo 23 23 $ echo $? 1
$ echo 23 && echo "true" || echo "fail" 23 true $ ! echo 23 && echo "true" || echo "fail" 23 fail
set -o nounset if [ ! -z ${WHATEVER} ]; then echo "yo" fi echo "whatever"
set -o nounset VALUE=${WHATEVER:-} if [ ! -z ${VALUE} ]; then echo "yo" fi echo "whatever"
check() { if [ -n "${WHATEVER-}" ] then echo elif [ "${WHATEVER+defined}" = defined ] then echo else echo fi }
$ unset WHATEVER $ check unset $ WHATEVER= $ check empty but defined $ WHATEVER= $ check not empty
$ echo $SHELL /bin/bash $ /bin/bash --version | head -1 GNU bash, version 4.1.2(1)-release (x86_64-redhat-linux-gnu) $ set -o nounset
$ [[ "${HOME:?}" ]] $ [[ "${IAMUNBOUND:?}" ]] bash: IAMUNBOUND: parameter null or not set $ IAMNULL="" $ [[ "${IAMNULL:?}" ]] bash: IAMNULL: parameter null or not set
$ [[ "${HOME:-}" ]] || echo "Parameter null or not set." $ [[ "${IAMUNBOUND:-}" ]] || echo "Parameter null or not set." Parameter null or not set. $ IAMNULL="" $ [[ "${IAMUNNULL:-}" ]] || echo "Parameter null or not set." Parameter null or not set.
[ -z "${VAR:-}" ] && echo "VAR is not set or is empty" || echo "VAR is set to $VAR"
TMP1=/tmp/`basename $0`1.$$ TMP2=/tmp/`basename $0`2.$$ ...
tempfile() { tempprefix=$(basename "$0") mktemp /tmp/${tempprefix}.XXXXXX } TMP1=$(tempfile) TMP2=$(tempfile) trap
on_exit() { echo } on_preExit() { echo echo exit 2 } trap on_exit EXIT trap on_preExit HUP INT QUIT TERM STOP PWR sleep 3 exit
str="Hello World" str2=" " str3="" if [ ! -z "$str" -a "$str"!=" " ]; then echo "Str is not null or space" fi if [ ! -z "$str2" -a "$str2"!=" " ]; then echo "Str2 is not null or space" fi if [ ! -z "$str3" -a "$str3"!=" " ]; then echo "Str3 is not null or space" fi
str="Hello World" str2=" " str3="" if [ ! -z "$str" -a "$str" != " " ]; then echo "Str is not null or space" fi if [ ! -z "$str2" -a "$str2" != " " ]; then echo "Str2 is not null or space" fi if [ ! -z "$str3" -a "$str3" != " " ]; then echo "Str3 is not null or space" fi
current_epoch=$(date +%s) target_epoch=$(date -d sleep_seconds=$(( $target_epoch - $current_epoch )) sleep $sleep_seconds
current_epoch=$(date +%s.%N) target_epoch=$(date -d "20:25:00.12345" +%s.%N) sleep_seconds=$(echo "$target_epoch - $current_epoch"|bc) sleep $sleep_seconds
expr `date -d "next week" +%s` - `date -d "now" +%s`
startTime=$(date +%s) endTime=$(date -d "next week" +%s) timeToWait=$(($endTime- $startTime)) sleep $timeToWait
sleepUntil() { local slp tzoff now quiet=false [ "$1" = "-q" ] && shift && quiet=true local hms=(${1 printf -v now printf -v tzoff tzoff=$((0${tzoff:0:1}(3600*${tzoff:1:2}+60*${tzoff:3:2}))) slp=$(((86400+(now-now%86400)+10 $quiet || printf sleep $slp }
sleepUntil 11:11 ; date +"Now, it is: %T" sleep 3s, -> sam 28 sep 2013 11:11:00 CEST Now, it is: 11:11:00 sleepUntil -q 11:11:5 ; date +"Now, it is: %T" Now, it is: 11:11:05
mapfile </proc/timer_list _timer_list for ((_i=0;_i<${ [[ ${_timer_list[_i]} =~ ^now ]] && TIMER_LIST_SKIP=$_i [[ ${_timer_list[_i]} =~ offset:.*[1-9] ]] && \ TIMER_LIST_OFFSET=${_timer_list[_i] break done unset _i _timer_list readonly TIMER_LIST_OFFSET TIMER_LIST_SKIP sleepUntilHires() { local slp tzoff now quiet=false nsnow nsslp [ "$1" = "-q" ] && shift && quiet=true local hms=(${1 mapfile -n 1 -s $TIMER_LIST_SKIP nsnow </proc/timer_list printf -v now printf -v tzoff nsnow=$((${nsnow nsslp=$((2000000000-10 tzoff=$((0${tzoff:0:1}(3600*${tzoff:1:2}+60*${tzoff:3:2}))) slp=$(( ( 86400 + ( now - now%86400 ) + 10 tzoff - now - 1 ) % 86400)).${nsslp:1} $quiet || printf sleep $slp }
sleepUntilHires 15:03 ;date +%F-%T.%N ;sleep .97;date +%F-%T.%N sleep 19.632345552s, -> sam 28 sep 2013 15:03:00 CEST 2013-09-28-15:03:00.003471143 2013-09-28-15:03:00.976100517 sleepUntilHires -q 15:04;date -f - +%F-%T.%N < <(echo now;sleep .97;echo now) 2013-09-28-15:04:00.003608002 2013-09-28-15:04:00.974066555
tstSleepUntilHires () { local now next last printf -v now "%(%s)T" printf -v next "%(%H:%M:%S)T" $((now+1)) printf -v last "%(%H:%M:%S)T" $((now+2)) sleepUntilHires $next date -f - +%F-%T.%N < <(echo now;sleep .92;echo now) sleepUntilHires $last date +%F-%T.%N }
sleep 0.155579469s, -> Mon Aug 20 20:42:51 2018 2018-08-20-20:42:51.005743047 2018-08-20-20:42:51.927112981 sleep 0.071764300s, -> Mon Aug 20 20:42:52 2018 2018-08-20-20:42:52.003165816
$cat ./reviveself rspid=$$ echo "kill -CONT $rspid"|at now + 2 minutes kill -SIGSTOP $rspid date>>reviveself.out $
target="$1.$2" cur=$(date while test $target != $cur; do sleep 59 cur=$(date done
sleep $(expr `date -d "03/21/2014 12:30" +%s` - `date +%s`)
$ til 13:00 && date 1 hour and 18 minutes and 26 seconds left... 1 hour and 18 minutes left... 1 hour and 17 minutes left... 1 hour and 16 minutes left... 1 hour and 15 minutes left... 1 hour and 14 minutes left... 1 hour and 10 minutes left... 1 hour and 5 minutes left... 1 hour and 0 minutes left... 55 minutes left... 50 minutes left... 45 minutes left... 40 minutes left... 35 minutes left... 30 minutes left... 25 minutes left... 20 minutes left... 15 minutes left... 10 minutes left... 5 minutes left... 4 minutes left... 3 minutes left... 2 minutes left... 1 minute left... Mon, May 18, 2015 1:00:00 PM
til(){ local hour mins target now left initial sleft correction m sec h hm hs ms ss showSeconds toSleep showSeconds=true [[ $1 =~ ([0-9][0-9]):([0-9][0-9]) ]] || { echo >&2 "USAGE: til HH:MM"; return 1; } hour=${BASH_REMATCH[1]} mins=${BASH_REMATCH[2]} target=$(date +%s -d "$hour:$mins") || return 1 now=$(date +%s) (( target > now )) || target=$(date +%s -d "tomorrow $hour:$mins") left=$((target - now)) initial=$left while (( left > 0 )); do if (( initial - left < 300 )) || (( left < 300 )) || [[ ${left: -2} == 00 ]]; then hs= ms= ss= m=$((left/60)) sec=$((left%60)) h=$((m/60)) hm=$((m%60)) now=$(date +%s) sleft=$((target - now)) correction=$((sleft-left)) if (( ${correction echo "System time change detected..." (( sleft <= 0 )) && return til "$1" && return fi (( sec > 1 )) && ss=s (( hm != 1 )) && ms=s (( h > 1 )) && hs=s (( h > 0 )) && printf %s "$h hour$hs and " (( h > 0 || hm > 0 )) && printf if [[ $showSeconds ]]; then showSeconds= (( h > 0 || hm > 0 )) && (( sec > 0 )) && printf %s " and " (( sec > 0 )) && printf %s "$sec second$ss" echo " left..." (( sec > 0 )) && sleep "$sec" && left=$((left-sec)) && continue else echo " left..." fi fi left=$((left-60)) sleep "$((60+correction))" correction=0 done }
set -o nounset error() { echo "$@" >&2 exit 1; } NAME_PROGRAM=$(basename "$0") if [[ $ error "ERROR: program \"$NAME_PROGRAM\" needs 1 parameter and it has received: $ fi current=$(date +%s.%N) target=$(date -d "$1" +%s.%N) seconds=$(echo "scale=9; $target - $current" | bc) signchar=${seconds:0:1} if [ "$signchar" = "-" ]; then error "You need to specify in a different way the moment in which this program has to finish, probably indicating the day and the hour like in this example: $NAME_PROGRAM \"2009/12/30 10:57\"." fi sleep "$seconds"
while [ 1 ]; do hypnos "0 * * * *" echo "running some tasks..." done
import time import sys now = time.time() mod = float(sys.argv[1]) until = now - now % mod + mod print "sleeping until", until while True: delta = until - time.time() if delta <= 0: print "done sleeping ", time.time() break time.sleep(delta / 2)
for k in $(jot 12 00 55) do echo $(date) doing stuff sleep $(expr $(date -j +%s $(printf %02d $(expr $k + 5))) - $(date -j +%s)) done
function sleepuntil() { local target_time="$1" today=$(date +"%m/%d/%Y") current_epoch=$(date +%s) target_epoch=$(date -d "$today $target_time" +%s) sleep_seconds=$(( $target_epoch - $current_epoch )) sleep $sleep_seconds } target_time="11:59"; sleepuntil $target_time
find . -type d -print0 | while read -d files=("$dir"/*) printf "%5d files in directory %s\n" "${ done
find ./ -mindepth 2 -type f | cut -d/ -f2 | sort | uniq -c | sort -nr
234 dir1 123 dir2 1 file1 1 file2 1 file3 ... 1 fileN
{ find ./ -mindepth 2 -type f | cut -d/ -f2 | sort && find ./ -maxdepth 1 -type f | cut -d/ -f1; } | uniq -c | sort -nr
findfiles() { echo "$1" $(find "$1" -maxdepth 1 -type f | wc -l) } export -f findfiles find ./ -type d -exec bash -c
./ 6 ./foo 1 ./foo/bar 2 ./foo/bar/bazzz 0 ./foo/bar/baz 4 ./src 4
for d in `find . -type d -print` do echo -e "$d\t$(find $d -maxdepth 1 -type f -print | wc -l)" done
for file in */; do echo "$file -> $(ls $file | wc -l)"; done | cut -d
OLD_IFS="$IFS" IFS=$ for dir in $(find $1 -maxdepth 1 -type d | sort); do files=("$dir"/*) printf "%5d,%s\n" "${ done FS="$OLD_IFS"
set timeout 20 set name [lindex $argv 0] set user [lindex $argv 1] set password [lindex $argv 2] spawn telnet $name expect "login:" send "$user " expect "Password:" send "$password " interact
telnet 10.1.1.1 <<EOF remotecommand 1 remotecommand 2 EOF
{ echo "remotecommand 1"; echo "remotecommand 2"; sleep 1; } | telnet 10.1.1.1
echo "open www.example.com 80" sleep 2 echo "GET /index.html HTTP/1.1" echo "Host: www.example.com" echo echo sleep 2
set timeout 20 set hostName [lindex $argv 0] set userName [lindex $argv 1] set password [lindex $argv 2] spawn telnet $hostName expect "User Access Verification" expect "Username:" send "$userName\r" expect "Password:" send "$password\r"; interact
screen -dmS default_session -t screen_name screen -S default_session -p screen_name -X stuff "script -f /tmp/abc.log $(printf \\r)" screen -S default_session -p screen_name -X stuff "expect telnet.sh hostname username password $(printf \\r)"
set ip "<ip>" spawn "/bin/bash" send "telnet $ip\r" expect " send "\r" expect " sleep 2 send "ls\r" expect " sleep 2 send -- "^]\r" expect "telnet>" send "quit\r" expect eof
while true read a do { sleep 3 echo df -kh sleep 3 echo exit } | telnet $a done<IP_sheet.txt
ping_count="4" avg_max_limit="1500" router="sagemcom-fast-2804-v2" adress="192.168.1.1" user="admin" pass="admin" VAR=$( expect -c " set timeout 3 spawn telnet "$adress" expect \"Login:\" send \"$user\n\" expect \"Password:\" send \"$pass\n\" expect \"commands.\" send \"ping ya.ru -c $ping_count\n\" set timeout 9 expect \"transmitted\" send \"exit\" ") count_ping=$(echo "$VAR" | grep packets | cut -c 1) avg_ms=$(echo "$VAR" | grep round-trip | cut -d echo "1_____ping___$count_ping|||____$avg_ms" echo "$VAR"
set ip [lindex $argv 0] set port [lindex $argv 1] set timeout 5 spawn telnet $ip $port expect "
printf (printf "$username\r\n$password\r\nwhoami\r\nexit\r\n") | ncat $target 23
printf (printf "$username\r\n";sleep 1;printf "$password\r\nwhoami\r\nexit\r\n") | ncat $target 23**
array=("A" "B" "ElementC" "ElementE") for element in "${array[@]}" do echo "$element" done echo echo "Number of elements: ${ echo echo "${array[@]}"
A B ElementC ElementE Number of elements: 4 A B ElementC ElementE
$ set one two three $ echo $* one two three $ echo $# 3 $ echo $2 two
$ n=1 ; eval a$n="one" $ n=2 ; eval a$n="two" $ n=3 ; eval a$n="three" $ n=2 $ eval echo \$a$n two
foo=(foo1 foo2) echo "${foo[1]}" foo[0]=bar foo[2]=cat foo[1000]=also_OK
echo "Find the Largest Number and Smallest Number of a given number" echo "---------------------------------------------------------------------------------" echo "Enter the number" read n while [ $n -gt 0 ] do x[$i]=`expr $n % 10` n=`expr $n / 10` done echo "Array values ${x[@]}" len=${ for (( i=0; i<len; i++ )) do for (( j=i+1; j<len; j++ )) do if [ `echo "${x[$i]} > ${x[$j]}"|bc` ] then t=${x[$i]} t=${x[$i]} x[$i]=${x[$j]} x[$j]=$t fi done done echo "Array values ${x[*]}" for (( i=len-1; i>=0; i-- )) do a=`echo $a \* 10 + ${x[$i]}|bc` done echo "Largest Number is : $a" l=$a s=0 while [ $a -gt 0 ] do r=`expr $a % 10` s=`echo "$s * 10 + $r"|bc` a=`expr $a / 10` done echo "Smallest Number is : $s" echo "Difference between Largest number and Smallest number" echo "==========================================" Diff=`expr $l - $s` echo "Result is : $Diff" echo "If you try it, We can get it"
arrayname=(apple banana cherry) echo ${arrayname[@]:1} echo ${arrayname[@]: -1} echo ${arrayname[${ echo ${arrayname[@]:0:2} echo ${arrayname[@]:1:1}
for ELEMENT in alpha gamma beta do TEST_ARRAY[$X]=$ELEMENT ((X = X + 1)) done
echo ${MY_ARRAY[2] gamma echo ${MY_ARRAY[*] - alpha beta gamma echo ${MY_ARRAY[@] - alpha beta gamma echo ${ - 3 echo ${ - 3 echo ${MY_ARRAY} - alpha
declare -a arr i=0 j=0 for dir in $(find /home/rmajeti/programs -type d) do arr[i]=$dir i=$((i+1)) done while [ $j -lt $i ] do echo ${arr[$j]} j=$((j+1)) done
declare -A programCollection programCollection["xwininfo"]="to aquire information about the target window." for program in ${!programCollection[@]} do echo "The program ${program} is used ${programCollection[${program}]}" done
ARR=("A" "B" "C" "D" 5 7 "J") echo ${ echo ${ARR[0]}
echo "Enter the numbers" read n while [ $n -ne 0 ] do x[$i]=`expr $n` read n let i++ done echo "Array values ${x[@]}" echo "Array values ${x[*]}" length=${ echo $length
set -A array element1 element2 elementn echo ${array[0]} echo ${ echo ${array[ $(( ${
arr=("sharlock" "bomkesh" "feluda" ) len=${ for (( i=0; i<len; i++ )) do echo ${arr[$i]} done
while [ ! -f /tmp/list.txt ] do sleep 2 done ls -l /tmp/list.txt
file=/tmp/list.txt while [ ! -f "$file" ] do inotifywait -qqt 2 -e create -e moved_to "$(dirname $file)" done
while ! [ -f /tmp/list.txt ]; do echo " sleep 1 done
while [ ! -f /tmp/list.txt ]; do sleep 1; done; sleep 1; cat /tmp/list.txt;
while true do [ -f /tmp/list.txt ] && break sleep 2 done ls -l /tmp/list.txt
MYSTRING="<VirtualHost *:80> ServerName $NEWVHOST DocumentRoot /var/www/hosts/$NEWVHOST ... " echo $MYSTRING
$ echo "This is 02G05 a test string 20-Jul-2012" | sed -n
echo "This is 02G05 a test string 20-Jul-2012" | egrep -o
echo "This is 02G05 a test string 20-Jul-2012" | sed
$ echo "This is 02G05 a test string 20-Jul-2012" | ./rextract 2G05
{ ... whatever you had in your script before } 2>&1 | tee output.file
exec > >(tee -a $HOME/logfile) 2>&1 echo test_stdout ls test_stderr___this_file_does_not_exist
( whatever1 whatever2 ... whatever3 ) 2>&1 | tee mylogfile.log
${APP_HOME}/${1}.sh ${2} ${3} ${4} ${5} ${6} 2>&1 | tee -a ${APP_HOME}/${1}.log
./RunScript.sh ScriptToRun Param1 Param2 Param3 ...
me=teelog Version="2008-10-9 oct denis-bz" Help() { cat <<! $me anycommand args ... logs the output of "anycommand ..." as well as displaying it on the screen, by running anycommand args ... 2>&1 | tee `day`-command-args.log That is, stdout and stderr go to both the screen, and to a log file. (The Unix "tee" command is named after "T" pipe fittings, 1 in -> 2 out; see http: The default log file name is made up from "command" and all the "args": $me cmd -opt dir/file logs to `day`-cmd--opt-file.log . To log to xx.log instead, either export log=xx.log or $me log=xx.log cmd ... If "logdir" is set, logs are put in that directory, which must exist. An old xx.log is moved to /tmp/\$USER-xx.log . The log file has a header like to show what was run; see "From" in this file. Called as "Log" (ln -s $me Log), Log anycommand ... logs to a file: command args ... > `day`-command-args.log and tees stderr to both the log file and the terminal -- bash only. Some commands that prompt for input from the console, such as a password, don To log all "make" s, including nested ones like cd dir1; \$(MAKE) cd dir2; \$(MAKE) ... export MAKE="$me make" ! exit 1 } day() { /bin/date +%e%h | tr } edate() { echo `/bin/date "+%e %h %Y %H:%M"` } From() { case `uname` in Darwin ) mac=" mac `sw_vers -productVersion`" esac cut -c -200 <<! ${comment- ${comment- ! } logfilename() { log=`day` [[ $1 == "sudo" ]] && shift for arg do log="$log-${arg (( ${ done echo $logdir/` echo "$log".log | tr -C } case "$1" in -v* | --v* ) echo "$0 version: $Version" exit 1 ;; "" | -* ) Help esac while [[ $1 == [a-zA-Z_]*=* ]]; do export "$1" shift done : ${logdir=.} [[ -w $logdir ]] || { echo >&2 "error: $me: can exit 1 } : ${log=` logfilename "$@" `} [[ -f $log ]] && /bin/mv "$log" "/tmp/$USER-${log case ${0 log | Log ) { From "$@" "$@" } > $log 2> >(tee /dev/stderr) ;; * ) { From "$@" "$@" 2>&1 } | tee $log esac
~: sh wrap.sh Script started, file is typescript Output Script done, file is typescript ~: cat typescript Script started on fr. 12. des. 2008 kl. 18.07 +0100 Output Script done on fr. 12. des. 2008 kl. 18.07 +0100 ~:
{ the_cmd > >(tee stdout.txt ); } 2> >(tee stderr.txt >&2 )
the_cmd() { echo out; 1>&2 echo err; } { the_cmd > >(tee stdout.txt ); } 2> >(tee stderr.txt >&2 )
$ foo=$(./example.sh) err $ echo $foo out $ cat stdout.txt out $ cat stderr.txt err
PATH=$PATH:/c/Program\ Files\ \(x86\)/Application\ with\ space
C:\Foobar>tree C:. ├───FooScripts ├───barconfig ├───Baz │ ├───BadBaz │ └───Drop ...
C:\Foobar>tree C:. ├───FooScripts │ foo.sh ├───barconfig │ bar.xml ├───Baz │ ├───BadBaz │ │ badbaz.xml │ └───Drop ...
C:\Foobar>tree /A C:. +---FooScripts +---barconfig +---Baz ¦ +---BadBaz ¦ \---Drop ...
C:\Foobar>tree /A C:. +---FooScripts ¦ foo.sh +---barconfig ¦ bar.xml +---Baz ¦ +---BadBaz ¦ ¦ badbaz.xml ¦ \---Drop ...
-- LuaFileSystem <http: require"lfs" -- LuaCairo <http: require"lcairo" local CAIRO = cairo local PI = math.pi local TWO_PI = 2 * PI --~ local dirToList = arg[1] or "C:/PrgCmdLine/Graphviz" --~ local dirToList = arg[1] or "C:/PrgCmdLine/Tecgraf" local dirToList = arg[1] or "C:/PrgCmdLine/tcc" -- Ensure path ends with / dirToList = string.gsub(dirToList, "([^/])$", "%1/") print("Listing: " .. dirToList) local fileNb = 0 --~ outputType = outputType = -- dirToList must have a trailing slash function ListDirectory(dirToList) local dirListing = {} for file in lfs.dir(dirToList) do if file ~= ".." and file ~= "." then local fileAttr = lfs.attributes(dirToList .. file) if fileAttr.mode == "directory" then dirListing[file] = ListDirectory(dirToList .. file .. else dirListing[file] = "" end fileNb = fileNb + 1 end end return dirListing end --dofile[[../Lua/DumpObject.lua]] -- My own dump routine local dirListing = ListDirectory(dirToList) --~ print("\n" .. DumpObject(dirListing)) print("Found " .. fileNb .. " files") --~ os.exit() -- Constants to change to adjust aspect local initialOffsetX = 20 local offsetY = 50 local offsetIncrementX = 20 local offsetIncrementY = 12 local iconOffset = 10 local width = 800 -- Still arbitrary local titleHeight = width/50 local height = offsetIncrementY * (fileNb + 1) + titleHeight local outfile = "CairoDirTree." .. outputType local ctxSurface if outputType == ctxSurface = cairo.SvgSurface(outfile, width, height) else ctxSurface = cairo.ImageSurface(CAIRO.FORMAT_RGB24, width, height) end local ctx = cairo.Context(ctxSurface) -- Display a file name -- file is the file name to display -- offsetX is the indentation function DisplayFile(file, bIsDir, offsetX) if bIsDir then ctx:save() ctx:select_font_face("Sans", CAIRO.FONT_SLANT_NORMAL, CAIRO.FONT_WEIGHT_BOLD) ctx:set_source_rgb(0.5, 0.0, 0.7) end -- Display file name ctx:move_to(offsetX, offsetY) ctx:show_text(file) if bIsDir then ctx:new_sub_path() -- Position independent of latest move_to -- Draw arc with absolute coordinates ctx:arc(offsetX - iconOffset, offsetY - offsetIncrementY/3, offsetIncrementY/3, 0, TWO_PI) -- Violet disk ctx:set_source_rgb(0.7, 0.0, 0.7) ctx:fill() ctx:restore() -- Restore original settings end -- Increment line offset offsetY = offsetY + offsetIncrementY end -- Erase background (white) ctx:set_source_rgb(1.0, 1.0, 1.0) ctx:paint() --~ ctx:set_line_width(0.01) -- Draw in dark blue ctx:set_source_rgb(0.0, 0.0, 0.3) ctx:select_font_face("Sans", CAIRO.FONT_SLANT_NORMAL, CAIRO.FONT_WEIGHT_BOLD) ctx:set_font_size(titleHeight) ctx:move_to(5, titleHeight) -- Display title ctx:show_text("Directory tree of " .. dirToList) -- Select font for file names ctx:select_font_face("Sans", CAIRO.FONT_SLANT_NORMAL, CAIRO.FONT_WEIGHT_NORMAL) ctx:set_font_size(10) offsetY = titleHeight * 2 -- Do the job function DisplayDirectory(dirToList, offsetX) for k, v in pairs(dirToList) do --~ print(k, v) if type(v) == "table" then -- Sub-directory DisplayFile(k, true, offsetX) DisplayDirectory(v, offsetX + offsetIncrementX) else DisplayFile(k, false, offsetX) end end end DisplayDirectory(dirListing, initialOffsetX) if outputType == cairo.show_page(ctx) else --cairo.surface_write_to_png(ctxSurface, outfile) ctxSurface:write_to_png(outfile) end ctx:destroy() ctxSurface:destroy() print("Found " .. fileNb .. " files")
digraph tree { rankdir=LR; DirTree [label="Directory Tree" shape=box] a_Foo_txt [shape=point] f_Foo_txt [label="Foo.txt", shape=none] a_Foo_txt -> f_Foo_txt a_Foo_Bar_html [shape=point] f_Foo_Bar_html [label="Foo Bar.html", shape=none] a_Foo_Bar_html -> f_Foo_Bar_html a_Bar_png [shape=point] f_Bar_png [label="Bar.png", shape=none] a_Bar_png -> f_Bar_png a_Some_Dir [shape=point] d_Some_Dir [label="Some Dir", shape=ellipse] a_Some_Dir -> d_Some_Dir a_VBE_C_reg [shape=point] f_VBE_C_reg [label="VBE_C.reg", shape=none] a_VBE_C_reg -> f_VBE_C_reg a_P_Folder [shape=point] d_P_Folder [label="P Folder", shape=ellipse] a_P_Folder -> d_P_Folder a_Processing_20081117_7z [shape=point] f_Processing_20081117_7z [label="Processing-20081117.7z", shape=none] a_Processing_20081117_7z -> f_Processing_20081117_7z a_UsefulBits_lua [shape=point] f_UsefulBits_lua [label="UsefulBits.lua", shape=none] a_UsefulBits_lua -> f_UsefulBits_lua a_Graphviz [shape=point] d_Graphviz [label="Graphviz", shape=ellipse] a_Graphviz -> d_Graphviz a_Tree_dot [shape=point] f_Tree_dot [label="Tree.dot", shape=none] a_Tree_dot -> f_Tree_dot { rank=same; DirTree -> a_Foo_txt -> a_Foo_Bar_html -> a_Bar_png -> a_Some_Dir -> a_Graphviz [arrowhead=none] } { rank=same; d_Some_Dir -> a_VBE_C_reg -> a_P_Folder -> a_UsefulBits_lua [arrowhead=none] } { rank=same; d_P_Folder -> a_Processing_20081117_7z [arrowhead=none] } { rank=same; d_Graphviz -> a_Tree_dot [arrowhead=none] } } > dot -Tpng Tree.dot -o Tree.png Error: lost DirTree a_Foo_txt edge Error: lost a_Foo_txt a_Foo_Bar_html edge Error: lost a_Foo_Bar_html a_Bar_png edge Error: lost a_Bar_png a_Some_Dir edge Error: lost a_Some_Dir a_Graphviz edge Error: lost d_Some_Dir a_VBE_C_reg edge Error: lost a_VBE_C_reg a_P_Folder edge Error: lost a_P_Folder a_UsefulBits_lua edge Error: lost d_P_Folder a_Processing_20081117_7z edge Error: lost d_Graphviz a_Tree_dot edge
find /path/to/jpgs -type f -exec jhead -v {} | grep 123 \; -print
find /path/to/jpgs -type f -print0 | xargs -0 jhead -v | grep 123
for i in dist/*.jar; do echo ">> $i"; jar -tf "$i" | grep BeanException; done
find /path/to/jpgs -type f -exec jhead -v {} \; | grep 123
find /path/to/jpgs -type f -print -exec jhead -v {} \; | grep 123
Loaded plugins: fastestmirror base | 3.7 kB 00:00 base/primary_db | 4.4 MB 00:03 extras | 3.4 kB 00:00 extras/primary_db | 18 kB 00:00 updates | 3.4 kB 00:00 updates/primary_db | 3.8 MB 00:02 Setting up Install Process Resolving Dependencies --> Running transaction check ---> Package nano.x86_64 0:2.0.9-7.el6 will be installed --> Finished Dependency Resolution Dependencies Resolved ================================================================================ Package Arch Version Repository Size ================================================================================ Installing: nano x86_64 2.0.9-7.el6 base 436 k Transaction Summary ================================================================================ Install 1 Package(s) Total download size: 436 k Installed size: 1.5 M Downloading Packages: nano-2.0.9-7.el6.x86_64.rpm | 436 kB 00:00 warning: rpmts_HdrFromFdno: Header V3 RSA/SHA256 Signature, key ID c105b9de: NOKEY Retrieving key from file: Importing GPG key 0xC105B9DE: Userid : CentOS-6 Key (CentOS 6 Official Signing Key) <centos-6-key@centos.org> Package: centos-release-6-4.el6.centos.10.x86_64 (@anaconda-CentOS-201303020151.x86_64/6.4) From : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 Running rpm_check_debug Running Transaction Test Transaction Test Succeeded Running Transaction Installing : nano-2.0.9-7.el6.x86_64 1/1 Verifying : nano-2.0.9-7.el6.x86_64 1/1 Installed: nano.x86_64 0:2.0.9-7.el6 Complete!
{ /your/first/command /your/second/command } &> /dev/null
{ /your/first/command /your/second/command } &> /dev/null
echo -n "Installing nano ......"; yum install nano > /dev/null; echo " done.";
echo -n "Installing nano ......"; yum install nano &> /dev/null; echo " done.";
blue=$(tput setaf 4) normal=$(tput sgr0) printf "%40s\n" "${blue}This text is blue${normal}"
%b ARGUMENT as a string with escapes are of the form \0 or \0NNN
int main() { printf("%sred\n", KRED); printf("%sgreen\n", KGRN); printf("%syellow\n", KYEL); printf("%sblue\n", KBLU); printf("%smagenta\n", KMAG); printf("%scyan\n", KCYN); printf("%swhite\n", KWHT); printf("%snormal\n", KNRM); return 0; }
print_style () { if [ "$2" == "info" ] ; then COLOR="96m"; elif [ "$2" == "success" ] ; then COLOR="92m"; elif [ "$2" == "warning" ] ; then COLOR="93m"; elif [ "$2" == "danger" ] ; then COLOR="91m"; else COLOR="0m"; fi STARTCOLOR="\e[$COLOR"; ENDCOLOR="\e[0m"; printf "$STARTCOLOR%b$ENDCOLOR" "$1"; } print_style "This is a green text " "success"; print_style "This is a yellow text " "warning"; print_style "This is a light blue with a \t tab " "info"; print_style "This is a red text with a \n new line " "danger"; print_style "This has no color";
int main(int argc, char* argv[]) { fputs(SHELL_COLOR_ESCAPE_SEQ(GEN_FORMAT_DIM";"FOREGROUND_COL_YELLOW), stdout); fputs("Text in gold\n", stdout); fputs(SHELL_FORMAT_RESET, stdout); fputs("Text in default color\n", stdout); fputs(SHELL_COLOR_ESCAPE_SEQ(GEN_FORMAT_DIM";"FOREGROUND_COL_YELLOW)"Text in gold\n"SHELL_FORMAT_RESET"Text in default color\n", stdout); return 0; }
P="\033[" BLUE=34 printf "-> This is %s %-6s %s text \n" $P"1;"$BLUE"m" "blue" $P"0m" printf "-> This is %b %-6s %b text \n" $P"1;"$BLUE"m" "blue" $P"0m"
$ ./portable-color.sh -> This is \033[1;34m blue \033[0m text -> This is blue text
int main(int argc, char *argv[]) { printf(D_FGREEN BBLUE"Change color!\n"NONE); return 0; }
set -o history date last=$(echo `history |tail -n2 |head -n1` | sed echo "last command is [$last]" case "1" in "1") date last=$(echo `history |tail -n2 |head -n1` | sed echo "last command is [$last]" ;; esac
Tue May 24 12:36:04 CEST 2011 last command is [date] Tue May 24 12:36:04 CEST 2011 last command is [echo "last command is [$last]"]
die() { echo >&2 -e "\nERROR: $@\n"; exit 1; } run() { "$@"; code=$?; [ $code -ne 0 ] && die "command [$*] failed with error code $code"; } case "1" in "1") run ls /opt run ls /wrong-dir ;; esac
$ ./test.sh apacheds google iptables ls: cannot access /wrong-dir: No such file or directory ERROR: command [ls /wrong-dir] failed with error code 2
cmd=$previous_command ret=$? if [ $ret -ne 0 ]; then echo "$cmd failed with error code $ret"; fi
echo "Last command run was ["!:0"] with arguments ["!:*"]"
exit_trap () { local lc="$BASH_COMMAND" rc=$? echo "Command [$lc] exited with code [$rc]" } trap exit_trap EXIT set -e echo "foo" false 12345 echo "bar"
if [[ "${?}" == 0 && "${_}" != "" ]] ; then LASTCOMMAND="${_}" ; RETURNSTATUS= elif [[ "${?}" == 0 && "${_}" == "" ]] ; then LASTCOMMAND= RETURNSTATUS= elif [[ "${?}" != 0 && "${_}" != "" ]] ; then LASTCOMMAND="${_}" ; RETURNSTATUS= elif [[ "${?}" != 0 && "${_}" == "" ]] ; then LASTCOMMAND= RETURNSTATUS= fi
declare RETURNSTATUS="${?}" LASTCOMMAND="${_}" ; if [[ "${RETURNSTATUS}" == 0 ]] ; then declare RETURNSYMBOL= else declare RETURNSYMBOL= fi
s/regexp/replacement/ Attempt to match regexp against the pattern space. If success‐ ful, replace that portion matched with replacement. The replacement may contain the special character & to refer to that portion of the pattern space which matched, and the special escapes \1 through \9 to refer to the corresponding matching sub-expressions in the regexp.
for file in F0000* do echo mv "$file" "${file/ done
for i in *; do mv "$i" "`echo $i | sed "s/regex/replace_text/"`"; done
for i in F00001*; do mv "$i" "${i/F00001/F0001}"; done
mv F00001-0708-RG-biasliuyda F0001-0708-RG-biasliuyda mv abcdef acdef
for file in *.[Jj][Pp][Gg] ;do echo mv -vi \"$file\" `jhead $file| grep Date| cut -b 16-| sed -e done
for file in *.[Jj][Pp][Gg] ;do echo mv -vi \"$file\" `jhead $file| grep Date| cut -b 16-| sed -e done | sh
x="HELLO" echo $x y=${x,,} echo $y z=${y^^} echo $z
y="HELLO" val=$(echo "$y" | awk string="$val world"
RUN bash /bin/sh: bash: not found RUN ./gradlew build env: can
echo "/usr/bin/uptime" >> /etc/shells vim /etc/passwd * username:x:uid:grp:message:homedir:/usr/bin/uptime
launchctl load /Library/LaunchDaemons/com.bob.plist
launchctl unload /Library/LaunchDaemons/com.bob.plist
<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE plist PUBLIC "- <plist version="1.0"> <dict> <key>Label</key> <string>com.bob</string> <key>RunAtLoad</key> <true/> <key>ProgramArguments</key> <array> <string>/usr/bin/java</string> <string>-jar</string> <string>/Users/user/program.jar</string> </array> </dict> </plist>
~/.bash_profile The personal initialization file, executed for login shells ~/.bashrc The individual per-interactive-shell startup file
PS > "123" | % { $_.Replace( "1", "a"), $_.Replace( "2", "b" ) } a23 1b3
while IFS= read -r line; do tr 1 a <<<"$line" tr 1 b <<<"$line" done < <(echo
aCmds=( "$@" ) tmpDir="${TMPDIR:-/tmp}/$kTHIS_NAME-$$-$(date +%s)-$RANDOM" mkdir "$tmpDir" || exit trap maxNdx=$(( $ fmtString="%0${ aFifos=() aOutFiles=() for (( i = 0; i <= maxNdx; ++i )); do printf -v suffix "$fmtString" $i aFifos[i]="$tmpDir/fifo-$suffix" aOutFiles[i]="$tmpDir/out-$suffix" done mkfifo "${aFifos[@]}" || exit for (( i = 0; i <= maxNdx; ++i )); do fifo=${aFifos[i]} outFile=${aOutFiles[i]} cmd=${aCmds[i]} printf eval "$cmd" < "$fifo" >> "$outFile" & done tee "${aFifos[@]}" >/dev/null || exit wait cat "${aOutFiles[@]}"
echo "Some console and log file message" | tee /dev/fd/3
exec 3>&1 1>>${LOG_FILE} 2>&1 echo "This is stdout" echo "This is stderr" 1>&2 echo "This is the console (fd 3)" 1>&3 echo "This is both the log and the console" | tee /dev/fd/3
This is the console (fd 3) This is both the log and the console
This is stdout This is stderr This is both the log and the console
LOG_FILE=/tmp/both.log exec > >(tee -a ${LOG_FILE} ) exec 2> >(tee -a ${LOG_FILE} >&2) echo "this is stdout" chmmm 77 /makeError
Logfile="logfile.txt" MAIL_LOG="Message to print in log file" Location="were is u want to store log file" cd $Location if [ -f $Logfile ] then echo "$MAIL_LOG " >> $Logfile else touch $Logfile echo "$MAIL_LOG" >> $Logfile fi
2017-06-21 11:16:41+05:30 Fetching information about files in the directory...
LOG_FILE=script.log exec > >(while read -r line; do printf exec 2> >(while read -r line; do printf
export LOG_FILE=log.txt exec 2>>${LOG_FILE} function log { echo "$1">>${LOG_FILE} } function message { echo "$1" echo "$1">>${LOG_FILE} }
. redir.env echo "Echoed to console only" log "Written to log file only" message "To console and log" echo "This is stderr. Written to log file only" 1>&2
# doLog(){ type_of_msg=$(echo $*|cut -d" " -f1) msg=$(echo "$*"|cut -d" " -f2-) [[ $type_of_msg == DEBUG ]] && [[ $do_print_debug_msgs -ne 1 ]] && return [[ $type_of_msg == INFO ]] && type_of_msg="INFO " [[ $type_of_msg == WARN ]] && type_of_msg="WARN " test -t 1 && echo " [$type_of_msg] `date "+%Y.%m.%d-%H:%M:%S %Z"` [$run_unit][@$host_name] [$$] ""$msg" test -z $log_file && \ mkdir -p $product_instance_dir/dat/log/bash && \ log_file="$product_instance_dir/dat/log/bash/$run_unit.`date "+%Y%m"`.log" echo " [$type_of_msg] `date "+%Y.%m.%d-%H:%M:%S %Z"` [$run_unit][@$host_name] [$$] ""$msg" >> $log_file }
LOG=$0.log . 8<<\EOF /dev/fd/8 2>&2 >&1 2>>$LOG >>$LOG date >&2 set -x echo hi echo bye EOF echo not logged
log_file=$curr_dir/log_file.txt exec > >(tee -a ${log_file} ) exec 2> >(tee -a ${log_file} >&2)
pages= length= time= while getopts p:l:t: opt; do case $opt in p) pages=$OPTARG ;; l) length=$OPTARG ;; t) time=$OPTARG ;; esac done shift $((OPTIND - 1))
pages= length= time= while test $ do case $1 in -p) pages=$2 shift ;; -l) length=$2 shift ;; -t) time=$2 shift ;; *) echo >&2 "Invalid argument: $1" ;; esac shift done
number=1 if [[ $number =~ [0-9] ]] then echo matched fi
number=1 if [[ $number =~ "[0-9]" ]] then echo matched fi
$ bash --version GNU bash, version 3.2.39(1)-release (i486-pc-linux-gnu) Copyright (C) 2007 Free Software Foundation, Inc. $ number=2 $ if [[ $number =~ "[0-9]" ]]; then echo match; fi $ if [[ $number =~ [0-9] ]]; then echo match; fi match $ re="[0-9]" $ if [[ $number =~ $re ]]; then echo MATCH; fi MATCH $ bash --version GNU bash, version 3.00.0(1)-release (i586-suse-linux) Copyright (C) 2004 Free Software Foundation, Inc. $ number=2 $ if [[ $number =~ "[0-9]" ]]; then echo match; fi match $ if [[ "$number" =~ [0-9] ]]; then echo match; fi match
$ shopt -u compat31 $ shopt compat31 compat31 off $ set -x $ if [[ "9" =~ "[0-9]" ]]; then echo match; else echo no match; fi + [[ 9 =~ \[0-9] ]] + echo no match no match
$ shopt -s compat31 + shopt -s compat31 $ if [[ "9" =~ "[0-9]" ]]; then echo match; else echo no match; fi + [[ 9 =~ [0-9] ]] + echo match match
$ if [[ 234 =~ "[0-9]" ]]; then echo matches; fi $ $ if [[ 234 =~ [0-9] ]]; then echo matches; fi matches $ var="[0-9]" $ if [[ 234 =~ $var ]]; then echo matches; fi matches $ if [[ 234 =~ "$var" ]]; then echo matches; fi $ if [[ $ if [[ matches $ if [[ "rss\$var919" =~ "$var" ]]; then echo matches; fi $ if [[ "rss\\$var919" =~ "$var" ]]; then echo matches; fi $ if [[ "rss matches $ if [[ matches $ if [[ $ $ if [[ matches $ echo $var [0-9] $ $ if [[ abc123def =~ "[0-9]" ]]; then echo matches; fi $ if [[ abc123def =~ [0-9] ]]; then echo matches; fi matches $ if [[ matches $ if [[ matches $ if [[ $ $ if [[ matches $ if [[ $ if [[ $ if [[ \ matches
$ number=1 $ if [[ $number =~ $(echo "[0-9]") ]]; then echo matched; fi matched $
function x() { echo "Hello world" } function around() { echo "before" eval $1 echo "after" } around x
function x() { echo "Hello world"; } function around() { echo before; $1; echo after; } around x
function x() { echo "x(): Passed $1 and $2"; } function around() { echo before; "$@"; echo after; } around x 1st 2nd
function x() { echo "Hello world" } function around() { echo "before" var=$($1) echo "after $var" } around x
function x() { echo "Hello world" } function around() { echo "before" ($1) <------ Only change echo "after" } around x
function x() { echo "Hello world:$1" } function around() { echo "before" ($1 HERE) <------ Only change echo "after" } around x
function x(){ echo $3 $1 $2 <== just rearrange the order of passed params } Z="x" ($Z 10 20 30)
foldl() { echo $(($(</dev/stdin)$2)) } < <(tr foldl + 0 <(while ((n=RANDOM%999,x++<20)); do echo $n; done)
function myfunc() { local myresult= echo "$myresult" } result=$(myfunc) echo $result
-f is the source format -t the target format -c skips any invalid sequence
$ diff /destination/dir/1 /destination/dir/2 -r -x *.xml
-x PAT --exclude=PAT Exclude files that match PAT. -X FILE --exclude-from=FILE Exclude files that match any pattern in FILE.
$ diff /destination/dir/1 /destination/dir/2 -r -X exclude.pats
cd /destination/dir/1 find . -name *.xml -exec diff {} /destination/dir/2/{} \;
find PATH1/ -type f | grep --text -vP "php$|html$" | sed diff PATH1/ PATH2/ -rq -X file1
SUFFIX += o SUFFIX += so SUFFIX += exe SUFFIX += pdf SUFFIX += swp FOLDER += bin FOLDER += lib FOLDER += Image FOLDER += models OPTIONS = Naur patch: rm test.patch diff -$(OPTIONS) \ $(foreach element, $(SUFFIX) , -x $(foreach element, $(FOLDER) , -x org/ new/ > test.patch unpatch: rm test.unpatch diff -$(OPTIONS) \ $(foreach element, $(SUFFIX) , -x $(foreach element, $(FOLDER) , -x new/ org/ > test.unpatch
diff -rqx "*.a" -x "*.o" -x "*.d" ./PATH1 ./PATH2 | grep "\.cpp " | grep "^Files"
svn diff $@ --diff-cmd /usr/bin/diff -x "-y -w -p -W $COLUMNS"
eval svn diff $@ --diff-cmd /usr/bin/diff -x "-y -w -p -W $COLUMNS"
svn diff "$@" --diff-cmd /usr/bin/diff -x "-y -w -p -W $(tput cols)"
COLUMNS=30 svn diff $@ --diff-cmd /usr/bin/diff -x "-y -w -p -W $COLUMNS"
-F, --fixed-strings Interpret PATTERN as a list of fixed strings, separated by newlines, any of which is to be matched. -x, --line-regexp Select only those matches that exactly match the whole line. -v, --invert-match Invert the sense of matching, to select non-matching lines. -f FILE, --file=FILE Obtain patterns from FILE, one per line. The empty file contains zero patterns, and therefore matches nothing.
while read line do flag = 0 while read line2 do if ( "$line" = "$line2" ) then flag = 1 fi done < file1 if ( flag -eq 0 ) then echo $line > file3 fi done < file2
/^[d][s][f]$/d /^[s][d][f][s][d]$/d /^[d][s][f][s][d][f]$/d
cb0$ rm --testings.html rm: illegal option -- - usage: rm [-f | -i] [-dPRrvW] file ... unlink file
touch -- --file find -x . -mindepth 1 -maxdepth 1 -name "--*" -delete
$ ls -lai | grep -i test 452998712 -rw-r--r-- 1 dim dim 6 2009-05-22 21:50 --testings.html
ln -s "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" ~/bin/subl
/Users/<username>/.rvm/gems/ruby-1.9.3-p194@rails3tutorial2ndEd/bin:/Users/<username>/.rvm/gems/ruby-1.9.3-p194@global/bin:/Users/<username>/.rvm/rubies/ruby-1.9.3-p194/bin:/Users/<username>/.rvm/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin
ln -s /Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl /usr/local/bin/
ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/
ln -s "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" ~/bin/subl
ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" ~/bin/subl
$ sudo ln -s "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" /usr/local/bin/subl
/Applications/Postgres.app/Contents/Versions/9.3/bin /usr/local/bin /usr/bin /bin /usr/sbin /sbin:/usr/local/bin /usr/local/mysql/bin
$ sudo ln -s "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" /usr/local/bin/subl
sudo ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" /usr/bin/subl
$ sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl ~/bin
sudo ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" /usr/local/bin/subl
sudo mkdir /usr/local/bin/ sudo ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" /usr/local/bin/subl
sudo ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" /bin/subl
ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/
T="$(date +%s)" sleep 2 T="$(($(date +%s)-T))" echo "Time in seconds: ${T}" printf "Pretty format: %02d:%02d:%02d:%02d\n" "$((T/86400))" "$((T/3600%24))" "$((T/60%60))" "$((T%60))""
T="$(date +%s%N)" sleep 2 T="$(($(date +%s%N)-T))" S="$((T/1000000000))" M="$((T/1000000))" echo "Time in nanoseconds: ${T}" printf "Pretty format: %02d:%02d:%02d:%02d.%03d\n" "$((S/86400))" "$((S/3600%24))" "$((S/60%60))" "$((S%60))" "${M}"
echo "Start $SECONDS" sleep 10 echo "Middle $SECONDS" sleep 10 echo "End $SECONDS"
read_cfg cfgA & read_cfg cfgB & read_cfg cfgC & wait
N=3 STRING="one two three four" arr=($STRING) echo ${arr[N-1]}
% N=3 % STRING="one two three four" % echo $STRING | awk -v N=$N three
This is the 1st Statement This is the 2nd Statement This is the 3rd Statement This is the 4th Statement This is the 5th Statement
pid=$(lsof -i:3000 -t); kill -TERM $pid || kill -KILL $pid
$ echo "100 100 100 99 99 26 25 24 24" | tr " " "\n" | sort | uniq -c | sort -k2nr | awk 100 3 99 2 26 1 25 1 24 2
find /var/www/html/audio -daystart -maxdepth 1 -mtime +1 -type f -name "*.mp3" -exec rm -f {} \;
find /var/www/html/audio -daystart -maxdepth 1 -mtime **+0.04** -type f -name "*.mp3" -exec rm -f {} \;
find /var/www/html/audio -daystart -maxdepth 1 -mmin +59 -type f -name "*.mp3" \ -exec rm -f {} \;
echo "PASSPHRASE" | gpg --passphrase-fd 0 -r USER --encrypt FILENAME.TXT
gpg: C042XXXX: There is no assurance this key belongs to the named user pub 40XXX/C042XXXX 2012-01-11 Name LastName. (comment) <user@email.com> Primary key fingerprint: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX Subkey fingerprint: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX It is NOT certain that the key belongs to the person named in the user ID. If you *really* know what you are doing, you may answer the next question with yes. Use this key anyway? (y/N)
$ gpg2 --edit-key {recipient email address} > trust > 5 (select 5 if you ultimately trust the key) > save
echo -n PASSPHRASE > phrase chmod 400 phrase yes | gpg --passphrase-fd 3 --recipient USER --encrypt FILENAME.txt 3<phrase
echo "PASSPHRASE" | gpg --passphrase-fd 0 --always-trust -r USER --encrypt FILENAME.TX
cat something_so_sign.xzy | gpg \ --passphrase-file "plaintext_passphrase.txt" \ --batch \ --pinentry-mode loopback \ -bsa
1 = I don 2 = I do NOT trust 3 = I trust marginally 4 = I trust fully 5 = I trust ultimately
$ printf ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz
$ printf ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz
$ echo "41 42 43 44 45 46 47 48 49 4a" | xxd -p -r ABCDEFGHIJ
help printf man bash | less -Ip printf "%d\n" printf "%d\n" " printf
trap processUserSig SIGUSR1 processUserSig() { echo "doing stuff" } while true; do sleep 1000 done
DEBUG=false trap process_USR1 SIGUSR1 process_USR1() { echo echo echo exit 0 } print_debug() { whatiam="$1"; tty="$2" [[ "$tty" != "not a tty" ]] && { echo "" >$tty echo "$whatiam, PID $$" >$tty ps -o pid,sess,pgid -p $$ >$tty tty >$tty } } me_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" me_FILE=$(basename $0) cd / if [ "$1" = "child" ] ; then shift; tty="$1"; shift $DEBUG && print_debug "*** CHILD, NEW SESSION, NEW PGID" "$tty" umask 0 $me_DIR/$me_FILE XXrefork_daemonXX "$tty" "$@" </dev/null >/dev/null 2>/dev/null & $DEBUG && [[ "$tty" != "not a tty" ]] && echo "CHILD OUT" >$tty exit 0 fi if [ "$1" != "XXrefork_daemonXX" ] ; then tty=$(tty) $DEBUG && print_debug "*** PARENT" "$tty" setsid $me_DIR/$me_FILE child "$tty" "$@" & $DEBUG && [[ "$tty" != "not a tty" ]] && echo "PARENT OUT" >$tty exit 0 fi exec >/tmp/outfile exec 2>/tmp/errfile exec 0</dev/null shift; tty="$1"; shift $DEBUG && print_debug "*** DAEMON" "$tty" $DEBUG && [[ "$tty" != "not a tty" ]] && echo NOT A REAL DAEMON. NOT RUNNING WHILE LOOP. >$tty $DEBUG || { while true; do echo "Change this loop, so this silly no-op goes away." >/dev/null echo "Do something useful with your life, young man." >/dev/null sleep 10 done } $DEBUG && [[ "$tty" != "not a tty" ]] && sleep 3 && echo "DAEMON OUT" >$tty exit
<shell_prompt>$ bash blahd *** PARENT, PID 5180 PID SESS PGID 5180 1708 5180 /dev/pts/6 PARENT OUT <shell_prompt>$ *** CHILD, NEW SESSION, NEW PGID, PID 5188 PID SESS PGID 5188 5188 5188 not a tty CHILD OUT *** DAEMON, PID 5198 PID SESS PGID 5198 5188 5188 not a tty NOT A REAL DAEMON. NOT RUNNING WHILE LOOP. DAEMON OUT
LISTENER_BIN=/tmp/deamon_test/listener test -x $LISTENER_BIN || exit 5 PIDFILE=/tmp/deamon_test/listener.pid case "$1" in start) echo -n "Starting Listener Deamon .... " startproc -f -p $PIDFILE $LISTENER_BIN echo "running" ;; *) echo "Usage: $0 start" exit 1 ;; esac
while true ; do sleep 600 ; echo "How are u ? " ; done
# IP=$(hostname --ip-address) PORT=1024 FILE=/tmp/backpipe count=0 while [ -a $FILE ] ; do FILE=$FILE.$count count=$(($count + 1)) done mknod $FILE p while true ; do netcat -l -s $IP -p $PORT < $FILE |/bin/bash > $FILE done rm $FILE
test_host uptime 20:01pm up 21 days 5:10, 44 users, load average: 0.62, 0.61, 0.60 date Tue Jan 28 20:02:00 IST 2014 punt! (Cntrl+C)
export PID_FILE_PATH="/tmp/my-service.pid" export LOG_FILE_PATH="/tmp/my-service.log" export LOG_ERROR_FILE_PATH="/tmp/my-service.error.log" . ./services.sh run-script() { local action="$1" while true; do echo "@@@ Running action echo foo echo bar >&2 [ "$action" = "run" ] && return 0 sleep 5 [ "$action" = "debug" ] && exit 25 done } before-start() { local action="$1" echo "* Starting with $action" } after-finish() { local action="$1" local serviceExitCode=$2 echo "* Finish with $action. Exit code: $serviceExitCode" } action="$1" serviceName="Example Service" serviceMenu "$action" "$serviceName" run-script "$workDir" before-start after-finish
$ ./example-service $ ./example-service start $ ./example-service status $ ./example-service stop $ ./example-service status
MACHINE_TYPE=`uname -m` if [ ${MACHINE_TYPE} == else fi
if [ `getconf LONG_BIT` = "64" ] then echo "I else echo "I fi
archs=`uname -m` case "$archs" in i?86) archs=i386 ;; x86_64) archs="x86_64 i386" ;; ppc64) archs="ppc64 ppc" ;; esac for arch in $archs; do test -x ./ioquake3.$arch || continue exec ./ioquake3.$arch "$@" done
KERNEL=$(uname -s) if [ $KERNEL = "Darwin" ]; then KERNEL=mac elif [ $Nucleo = "Linux" ]; then KERNEL=linux elif [ $Nucleo = "FreeBSD" ]; then KERNEL=linux else echo "Unsupported OS" fi ARCH=$(uname -m) if [ $ARCH = "i386" ]; then PATH="$PWD/wine/$KERNEL/x86/bin:$PATH" export WINESERVER="$PWD/wine/$KERNEL/x86/bin/wineserver" export WINELOADER="$PWD/wine/$KERNEL/x86/bin/wine" export WINEPREFIX="$PWD/wine/data" export WINEDEBUG=-all:$WINEDEBUG ARCH="32 Bits" elif [ $ARCH = "i486" ]; then PATH="$PWD/wine/$KERNEL/x86/bin:$PATH" export WINESERVER="$PWD/wine/$KERNEL/x86/bin/wineserver" export WINELOADER="$PWD/wine/$KERNEL/x86/bin/wine" export WINEPREFIX="$PWD/wine/data" export WINEDEBUG=-all:$WINEDEBUG ARCH="32 Bits" elif [ $ARCH = "i586" ]; then PATH="$PWD/wine/$KERNEL/x86/bin:$PATH" export WINESERVER="$PWD/wine/$KERNEL/x86/bin/wineserver" export WINELOADER="$PWD/wine/$Nucleo/x86/bin/wine" export WINEPREFIX="$PWD/wine/data" export WINEDEBUG=-all:$WINEDEBUG ARCH="32 Bits" elif [ $ARCH = "i686" ]; then PATH="$PWD/wine/$KERNEL/x86/bin:$PATH" export WINESERVER="$PWD/wine/$KERNEL/x86/bin/wineserver" export WINELOADER="$PWD/wine/$KERNEL/x86/bin/wine" export WINEPREFIX="$PWD/wine/data" export WINEDEBUG=-all:$WINEDEBUG ARCH="32 Bits" elif [ $ARCH = "x86_64" ]; then export WINESERVER="$PWD/wine/$KERNEL/x86_64/bin/wineserver" export WINELOADER="$PWD/wine/$KERNEL/x86_64/bin/wine" export WINEPREFIX="$PWD/wine/data" export WINEDEBUG=-all:$WINEDEBUG ARCH="64 Bits" else echo "Unsoportted Architecture" fi
Kernel=$(uname -s) case "$Kernel" in Linux) Kernel="linux" ;; Darwin) Kernel="mac" ;; FreeBSD) Kernel="freebsd" ;; * ) echo "Your Operating System -> ITS NOT SUPPORTED" ;; esac echo echo "Operating System Kernel : $Kernel" echo Architecture=$(uname -m) case "$Architecture" in x86) Architecture="x86" ;; ia64) Architecture="ia64" ;; i?86) Architecture="x86" ;; amd64) Architecture="amd64" ;; x86_64) Architecture="x86_64" ;; sparc64) Architecture="sparc64" ;; * ) echo "Your Architecture esac echo echo "Operating System Architecture : $Architecture" echo
slot8(msd):/opt Linux slot8a 2.6.21_mvlcge500-electra EDT 2008 ppc64 GNU/Linux
tmpfile=$(mktemp) grep -v cat ${tmpfile} > file_name rm -f ${tmpfile}
!/seg[0-9]\{1,\}\.[0-9]\{1\}/ { q = q ? q RS $0 : $0 } END { print q > ARGV[1] }
printf "hello\nworld\n" > file_uniquely_named.txt && for ((i=0; i<1000; i++)); do echo "$(cat file_uniquely_named.txt)" > file_uniquely_named.txt; done; cat file_uniquely_named.txt; rm file_uniquely_named.txt
printf "hello\nworld\n" > file_uniquely_named.txt && for ((i=0; i<1000; i++)); do cat file_uniquely_named.txt > file_uniquely_named.txt; done; cat file_uniquely_named.txt; rm file_uniquely_named.txt
echo -e "AAA\nBBB\nCCC" > testfile cat testfile AAA BBB CCC echo "$(grep -v cat testfile BBB CCC
sudo echo "[some repository]" >> /etc/apt/sources.list
echo "[some repository]" | sudo tee -a /etc/apt/sources.list
su echo "[some repository]" >> /etc/apt/sources.list
tar: ./workspace.tar.gz: file changed as we read it
base=$(basename $PWD) cd .. tar -czf $base.tar.gz $base
touch workspace.tar.gz tar -czf workspace.tar.gz --exclude=workspace.tar.gz .
tar -czf workspace.tar.gz --exclude=workspace.tar.gz .
tar -czf somewhereelse/workspace.tar.gz . mv somewhereelse/workspace.tar.gz .
tar --exclude=*.tar* -cv . | xz -9v >workspace.tar.xz
mkdir backup cp -r ./* backup tar -zcvf backup.tar.gz ./backup
tar -cjf workspace.tar.gz -C <path_to_workspace> $(ls -A <path_to_workspace>)
find . -maxdepth 1 -exec tar zcvf workspace.tar.gz {} \+
tar zcvf workspace.tar.gz .file1 tar zcvf workspace.tar.gz .file2 tar zcvf workspace.tar.gz .dir3
$ HISTCONTROL=ignoreboth $ echo test1 $ echo test2 $ history | tail -n2 1015 echo test1 1016 history | tail -n2
HISTFILE=~/.zshhistory temp_histfile="/tmp/$$.temp_histfile" grep -v -P mv $temp_histfile $HISTFILE
case $myvar in (true) echo "is true";; (false) echo "is false";; (rm -rf*) echo "I just dodged a bullet";; esac
array+=(pluto) array+=(pippo) delete=(pluto) array( ${array[@]/$delete} ) -> but clearly doesn
$ array=(pluto pippo) $ delete=(pluto) $ echo ${array[@]/$delete} pippo $ array=( "${array[@]/$delete}" )
... $ delete=(pluto pippo) for del in ${delete[@]} do array=("${array[@]/$del}") done
array=(pluto pippo bob) delete=(pippo) for target in "${delete[@]}"; do for i in "${!array[@]}"; do if [[ ${array[i]} = "${delete[0]}" ]]; then unset fi done done
$ declare -p array declare -a array=([0]="pluto" [2]="bob")
for i in "${!array[@]}"; do new_array+=( "${array[i]}" ) done array=("${new_array[@]}") unset new_array
array=(pluto pippo) new_array=() for value in "${array[@]}" do [[ $value != pluto ]] && new_array+=($value) done array=("${new_array[@]}") unset new_array
$ array=(one two three) $ echo ${ 3 $ unset $ echo ${array[@]} one three $ echo ${ 2
ARRAY=(one two onetwo three four threefour "one six") TO_REMOVE=(one four) TEMP_ARRAY=() for pkg in "${ARRAY[@]}"; do for remove in "${TO_REMOVE[@]}"; do KEEP=true if [[ ${pkg} == ${remove} ]]; then KEEP=false break fi done if ${KEEP}; then TEMP_ARRAY+=(${pkg}) fi done ARRAY=("${TEMP_ARRAY[@]}") unset TEMP_ARRAY
delete_ary_elmt() { local word=$1 local aryref="$2[@]" local arycopy=("${!aryref}") local status=1 for (( i = ${ elmt=${arycopy[$i]} [[ $elmt == $word ]] && unset "$2[$i]" && status=0 done return $status } array=(a 0 0 b 0 0 0 c 0 d e 0 0 0) delete_ary_elmt 0 array for e in "${array[@]}"; do echo "$e" done
$ arr=("Adam" "Bob" "Claire"$ $ echo "Size: ${ Size: 6 Contents: Adam Bob Claire Smith David Eve Fred $ mapfile -d $ $ echo "Size: ${ Size: 5 Contents: Adam Bob David Eve Fred
options=("foo" "bar" "foo" "foobar" "foo bar" "bars" "bar") options=("${options[@]/ count=${ for ((i = 0; i < count; i++)); do if [ "${options[i]}" = "foo" ] ; then unset fi done for ((i = 0; i < count; i++)); do if [ -z "${options[i]}" ] ; then unset fi done echo "Choose an option:" PS3= select i in "${options[@]}" Quit do case $i in Quit) break ;; *) echo "You selected \"$i\"" ;; esac done
Choose an option: 1) foobar 2) foo bar 3) s 4) Quit Option?
declare -a arr=( unset declare -a arr2=() i=0 for element in ${arr[@]} do arr2[$i]=$element ((++i)) done echo ${arr[@]} echo "1st val is ${arr[1]}, 2nd val is ${arr[2]}" echo ${arr2[@]} echo "1st val is ${arr2[1]}, 2nd val is ${arr2[2]}"
aa cc dd ee 1st val is , 2nd val is cc aa cc dd ee 1st val is cc, 2nd val is dd
declare -a arr=( arr2=("${arr[@]:1}") echo ${arr2[@]} echo "1st val is ${arr2[1]}, 2nd val is ${arr2[2]}"
start=(one two three work=(${(@)start}) idx=2 val=${work[idx]} work[$idx]=() echo "Array size went down by one: " [[ $ echo "Array item "$val" is now gone: " [[ -z ${work[(r)$val]} ]] && echo OK echo "Array contents are as expected: " wanted=("${start[@]:0:1}" "${start[@]:2}") [[ "${(j.:.)wanted[@]}" == "${(j.:.)work[@]}" ]] && echo "OK" echo "-- array contents: start --" print -l -r -- "-- $ echo "-- array contents: work --" print -l -r -- "-- $
Array size went down by one: OK Array item two is now gone: OK Array contents are as expected: OK -- array contents: start -- -- 5 elements one two three four 4 five -- array contents: work -- -- 4 elements one three four 4 five
array=(`echo $array | fmt -1 | grep -v "^${delete}$" | fmt -999999`)
array=(`echo $array | fmt -1 | sed "0,/^${delete}$/{
array=(one two three) array_t=" ${array[@]} " delete=one array=(${array_t unset array_t
echo " arr=(zero one two three echo " unset -v for i in ${!arr[*]}; do echo "arr[$i]=${arr[$i]}"; done arr_delete_by_content() { for i in ${!arr[*]}; do [ "${arr[$i]}" = "$1" ] && unset -v done } echo " arr_delete_by_content three for i in ${!arr[*]}; do echo "arr[$i]=${arr[$i]}"; done echo " arr=( "${arr[@]}" ) for i in ${!arr[*]}; do echo "arr[$i]=${arr[$i]}"; done delete_value() { local e val=$1; new=(); shift for e in "${@}"; do [ "$val" != "$e" ] && new+=("$e"); done declare -p new|sed } echo " declare -a arr="$(delete_value two "${arr[@]}")" for i in ${!arr[*]}; do echo "arr[$i]=${arr[$i]}"; done delete_values() { declare -a arr="$1"; local i v; shift for v in "${@}"; do for i in ${!arr[*]}; do [ "$v" = "${arr[$i]}" ] && unset -v done done declare -p arr|sed } echo " declare -a arr="$(delete_values "$(declare -p arr|sed for i in ${!arr[*]}; do echo "arr[$i]=${arr[$i]}"; done
The first line The second line The third line The fourth line
cat new.txt The first line The second line The third line The fourth line cat new.txt | nl 1 The first line 2 The second line 3 The third line 4 The fourth line cat new.txt | nl | sed "/2/d" 1 The first line 3 The third line 4 The fourth line cat new.txt | nl |sed "3d;4d" 1 The first line 2 The second line
Filesystem 1K-blocks Used Available Use% Mounted on C:\Users\Sam\AppData\Local\Temp 76694276 46239412 30454864 61% /tmp C:\MinGW\msys\1.0 76694276 46239412 30454864 61% /usr C:\MinGW\msys\1.0 76694276 46239412 30454864 61% / C:\MinGW\build32 76694276 46239412 30454864 61% /build32 C:\MinGW\build64 76694276 46239412 30454864 61% /build64 C:\MinGW\local32 76694276 46239412 30454864 61% /local32 C:\MinGW\local64 76694276 46239412 30454864 61% /local64 C:\MinGW\mingw32 76694276 46239412 30454864 61% /mingw32 C:\MinGW\mingw64 76694276 46239412 30454864 61% /mingw64 C:\MinGW\opt 76694276 46239412 30454864 61% /opt C:\MinGW\src 76694276 46239412 30454864 61% /src c: 76694276 46239412 30454864 61% /c d: 62471380 33791832 28679548 55% /d e: 163839996 129349800 34490196 79% /e f: 266237948 222816904 43421044 84% /f g: 407410152 346169248 61240904 85% /g h: 65328288 22612768 42715520 35% /h i: 122881152 54066728 68814424 44% /i j: 409601240 176372780 233228460 44% /j k: 378949628 56153980 322795648 15% /k
"\e[1;5C": forward-word "\e[1;5D": backward-word "\e[5C": forward-word "\e[5D": backward-word "\e\e[C": forward-word "\e\e[D": backward-word
if [[ "$(uname)" = "Linux" ]];then killall --older-than 1h someprocessname;fi
if [[ "$(uname)" = "Linux" ]];then killall -i --older-than 1h someprocessname;fi
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 7200 308 ? Ss Jun22 0:02 init [5] root 2 0.0 0.0 0 0 ? S Jun22 0:02 [migration/0] root 3 0.0 0.0 0 0 ? SN Jun22 0:18 [ksoftirqd/0] root 4 0.0 0.0 0 0 ? S Jun22 0:00 [watchdog/0]
ohm ~$ stat /proc/1 File: `/proc/1' Size: 0 Blocks: 0 IO Block: 4096 directory Device: 3h/3d Inode: 65538 Links: 5 Access: (0555/dr-xr-xr-x) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2008-06-22 15:37:44.347627750 -0700 Modify: 2008-06-22 15:37:44.347627750 -0700 Change: 2008-06-22 15:37:44.347627750 -0700
use strict; use Proc::ProcessTable; my $anHourAgo = time-60*60; my $t = new Proc::ProcessTable; foreach my $p ( @{$t->table} ) { if ($p->start() < $anHourAgo) { print $p->pid, "\n"; } }
max_age=120 naughty="$(pgrep -f offlineimap)" if [[ -n "$naughty" ]]; then age_in_seconds=$(echo "$(date +%s) - $(stat -c %X /proc/$naughty)" | bc) if [[ "$age_in_seconds" -ge "$max_age" ]]; then kill -s 9 "$naughty" fi fi
init=`stat -t /proc/$1 | awk curr=`date +%s` seconds=`echo $curr - $init| bc` name=`cat /proc/$1/cmdline` echo $name $seconds
pidlist=`ps ax | grep -i -E $1 | grep -v grep | awk for pid in $pidlist; do sincetime $pid done
kill $(ps -o pid,bsdtime -p $(pgrep bad_process) | awk
float pid_age(pid_t pid) { proc_t proc_info; int seconds_since_boot = uptime(0,0); if (!get_proc_stats(pid, &proc_info)) { return 0.0; } int seconds_since_1970 = time(NULL); int time_of_boot = seconds_since_1970 - seconds_since_boot; long t = seconds_since_boot - (unsigned long)(proc_info.start_time / Hertz); int delta = t; float days = ((float) delta / (float)(60*60*24)); return days; }
* * * * * ps -lf | grep "user" | perl -ane +[13]; kill 9, $F[3] if ($h > 1);'
ps -lf | grep "user" | perl -ane + 9, $F[3] if ($h > 1);'
declare -A matrix num_rows=4 num_columns=5 for ((i=1;i<=num_rows;i++)) do for ((j=1;j<=num_columns;j++)) do matrix[$i,$j]=$RANDOM done done f1="%$((${ f2=" %9s" printf "$f1" for ((i=1;i<=num_rows;i++)) do printf "$f2" $i done echo for ((j=1;j<=num_columns;j++)) do printf "$f1" $j for ((i=1;i<=num_rows;i++)) do printf "$f2" ${matrix[$i,$j]} done echo done
1 2 3 4 1 18006 31193 16110 23297 2 26229 19869 1140 19837 3 8192 2181 25512 2318 4 3269 25516 18701 7977 5 31775 17358 4468 30345
declare -a a0=(1 2 3 4) declare -a a1=(5 6 7 8) var="a1[1]" echo ${!var}
idx=0 while read -a a$idx; do let idx++; done </tmp/some_file
for i in {0..3}; do eval "declare -a a$i=( $(for j in {0..4}; do echo 0; done) )" done
declare -A arr arr[0,0]=0 arr[0,1]=1 arr[1,0]=2 arr[1,1]=3 echo "${arr[0,0]} ${arr[0,1]}"
q=() q+=( 1-2 ) q+=( a-b ) for set in ${q[@]}; do echo ${set%%-*} echo ${set done
VectorAddElementNext () { local elem_value local vector_length local elem_name eval elem_value=\"\$$2\" eval vector_length=\$$1\_0 if [ -z "$vector_length" ]; then vector_length=$((0)) fi vector_length=$(( vector_length + 1 )) elem_name=$1_$vector_length eval $elem_name=\"\$elem_value\" eval $1_0=$vector_length } VectorAddElementDVNext () { local elem_value local vector_length local elem_name eval elem_value="$2" eval vector_length=\$$1\_0 if [ -z "$vector_length" ]; then vector_length=$((0)) fi vector_length=$(( vector_length + 1 )) elem_name=$1_$vector_length eval $elem_name=\"\$elem_value\" eval $1_0=$vector_length } VectorAddElement () { local elem_value local elem_position local vector_length local elem_name eval elem_value=\"\$$3\" elem_position=$(($2)) eval vector_length=\$$1\_0 if [ -z "$vector_length" ]; then vector_length=$((0)) fi if [ $elem_position -ge $vector_length ]; then vector_length=$elem_position fi elem_name=$1_$elem_position eval $elem_name=\"\$elem_value\" if [ ! $elem_position -eq 0 ]; then eval $1_0=$vector_length fi } VectorAddElementDV () { local elem_value local elem_position local vector_length local elem_name eval elem_value="$3" elem_position=$(($2)) eval vector_length=\$$1\_0 if [ -z "$vector_length" ]; then vector_length=$((0)) fi if [ $elem_position -ge $vector_length ]; then vector_length=$elem_position fi elem_name=$1_$elem_position eval $elem_name=\"\$elem_value\" if [ ! $elem_position -eq 0 ]; then eval $1_0=$vector_length fi } VectorPrint () { local vector_length vector_length=$(($1_0)) if [ "$vector_length" = "0" ]; then echo "Vector \"$1\" is empty!" else echo "Vector \"$1\":" for ((i=1; i<=$vector_length; i++)); do eval echo \"[$i]: \\\"\$$1\_$i\\\"\" done fi } VectorDestroy () { local vector_length vector_length=$(($1_0)) if [ ! "$vector_length" = "0" ]; then for ((i=1; i<=$vector_length; i++)); do unset $1_$i done unset $1_0 fi } for ((i=1; i<=$ eval param="\${$i}" VectorAddElementNext params param done VectorPrint params read temp if [ -n "$params_0" ]; then for ((i=1; i<=$params_0; i++)); do count=$((params_0-i+1)) VectorAddElement params2 count params_$i done fi VectorPrint params2 read temp if [ -n "$params2_0" ]; then echo "Printing the elements of the vector for ((i=1; i<=$params2_0; i++)); do eval current_elem_value=\"\$params2\_$i\" echo "params2_$i=\"$current_elem_value\"" done else echo "Vector fi read temp for ((i=1; i<=10; i++)); do VectorAddElement a 0 i for ((j=1; j<=8; j++)); do value=$(( 8 * ( i - 1 ) + j )) VectorAddElementDV a_$i $j $value done done echo "Printing the two-dimensional array if [ -n "$a_0" ]; then for ((i=1; i<=$a_0; i++)); do eval current_vector_lenght=\$a\_$i\_0 if [ -n "$current_vector_lenght" ]; then for ((j=1; j<=$current_vector_lenght; j++)); do eval value=\"\$a\_$i\_$j\" printf "$value " done fi printf "\n" done fi
a=("0 0 0 0 0" "0 0 0 0 0" "0 0 0 0 0" "0 0 0 0 0") function aset { IFS= tmp[$2]=$3 a[$1]="${tmp[@]}" } aset 2 3 3 for r in "${a[@]}"; do echo $r done
matrix_write () { eval $1"_"$2"_"$3=$4 } matrix_read () { aux=$1"_"$2"_"$3 echo ${!aux} } for ((i=1;i<10;i=i+1)); do for ((j=1;j<10;j=j+1)); do matrix_write a $i $j $[$i*10+$j] done done for ((i=1;i<10;i=i+1)); do for ((j=1;j<10;j=j+1)); do echo "a_"$i"_"$j"="$(matrix_read a $i $j) done done
a=() for (( i=0; i<4; ++i )); do for (( j=0; j<5; ++j )); do a[i*5+j]=0 done done
local pano_array=() i=0 for line in $(grep "filename" "$file") do url=$(extract_url_from_xml $line) pano_array[i]="$url" i=$((i+1)) done
array_len="${ i=0 while [[ $i -lt $array_len ]] do url="${pano_array[$i]}" offset=$(($array_len+i)) found_file=$(get_file $url) pano_array[$offset]=$found_file i=$((i+1)) done
echo "Hello" if [ -f /etc/bashrc ]; then . /etc/bashrc fi
if [ 0 -eq $(shopt -q login_shell; echo $?) ]; then echo "do something?" fi
C:\WINDOWS\system32>lxrun /install Warning: lxrun.exe is only used to configure the legacy Windows Subsystem for Linux distribution. Distributions can be installed by visiting the Microsoft Store: https: This will install Ubuntu on Windows, distributed by Canonical and licensed under its terms available here: https: Type "y" to continue: y Downloading from the Microsoft Store... 100% Extracting filesystem, this will take a few minutes... Would you like to set the Ubuntu locale to match the Windows locale (en-FI)? The default locale is en_US. Type "y" to continue: y Please create a default UNIX user account. The username does not need to match your Windows username. For more information visit: https: Enter new UNIX username: <you type your login here> Enter new UNIX password: Retype new UNIX password: passwd: password updated successfully Installation successful! Documentation is available at: https:
function myreadlink() { ( cd $(dirname $1) echo $PWD/$(basename $1) ) }
absPath(){ if [[ -d "$1" ]]; then cd "$1" echo "$(pwd -P)" else cd "$(dirname "$1")" echo "$(pwd -P)/$(basename "$1")" fi }
get_realpath <absolute|relative|symlink|local file path>
if [[ -f "$1" ]] then if cd "$(echo "${1%/*}")" &>/dev/null then local tmppwd="$PWD" cd - &>/dev/null else local tmppwd="$PWD" fi else return 1 fi echo "$tmppwd"/"${1 return 0 }
FULL_PATH=$(readlink -f filename) DIR=$(dirname $FULL_PATH) PWD=$(pwd) cd $DIR cd $PWD
myfile="./somefile.txt" FOLDER="$(dirname $(readlink -f "${ARG}"))" echo ${FOLDER}
echo "Script starts" function_to_fork(){ sleep 5 echo "Hello" } echo "Script ends"
num=1 while [ true ] do if ! touch $(printf "%${num}s" | tr then echo $num break fi ((num++)) done
touch: cannot touch `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 256
man getconf getconf NAME_MAX / getconf PATH_MAX / echo
$ getconf NAME_MAX /mnt/sda2/ 255 $ getconf PATH_MAX /mnt/sda3/ 4096
FILENAME=$1 count=0 echo "proceed with $FILENAME" while read LINE; do let count++ echo "$count $LINE" sh ./do_work.sh $LINE done < $FILENAME echo "\ntotal $count targets"
while read ONELINE ; do ssh ubuntu@host_xyz </dev/null <<EOF 2>&1 | filter_pgm echo "Hi, $ONELINE. You come here often?" process_response_pgm EOF if [ ${PIPESTATUS[0]} -ne 0 ] ; then echo "aborting loop" exit ${PIPESTATUS[0]} fi done << input_list.txt
if [ $1 != -v ]; then echo "usage: $0 [-v]" exit fi
if [ "$ echo "usage: $0 [-v]" exit fi if [ "$1" != -v ]; then echo "usage: $0 [-v]" exit fi if [ "$1" = -v ]; then echo "`ps -ef | grep -v else echo "`ps -ef | grep fi
case $1 in echo "`ps -ef | grep -v else echo "`ps -ef | grep fi;; *) echo "usage: $0 [-v]" exit 1;; esac
usage () { echo "usage: $0 [-v]" exit 1 } unset arg_match for arg in $* do case $arg in echo "`ps -ef | grep -v else echo "`ps -ef | grep fi arg_match=1;; *) ;; esac done if [ ! $arg_match ] then usage fi
lrwxrwxrwx 1 root root 4 Apr 22 2013 /bin/sh -> bash*
/bin/sh: -c: line 0: syntax error near unexpected token /bin/sh: -c: line 0:
/bin/bash -c "script.sh 2> >( grep -v FILTER 2>&1 )"
echo "FILTER: This should be filtered out" 1>&2 echo "This should be on stderr" 1>&2 echo "FILTER: This should be filtered out" 1>&2
$ EC2_HOME=/path/to/dir JAVA_HOME=/other/path ec2-describe-regions
$ export EC2_HOME=/path/to/dir $ export JAVA_HOME=/other/path $ ec2-describe-regions
function startec2(){ EC2_HOME=/path/to/dir JAVA_HOME=/other/path ec2-describe-regions }
dir1= dir2= IFS=$ for file in $(grep -Ilsr -m 1 diff -q "$file" "${file/${dir1}/${dir2}}" done
diff -X exclude_file -r . other_tree > my_diff_file
dir1=/path/to/first/folder dir2=/path/to/second/folder cd $dir1 files=$(find . -type f -print | xargs file | grep ASCII | cut -d: -f1) for i in $files; do echo diffing $i ---- $dir2/$i diff -q $i $dir2/$i done
dir1=/path/to/first/directory dir2=/path/to/second/directory content_dir1=$(mktemp) content_dir2=$(mktemp) $(cd $dir1 && find . -type f -print > $content_dir1) $(cd $dir2 && find . -type f -print > $content_dir2) echo Files that only exist in one of the paths echo ----------------------------------------- diff $content_dir1 $content_dir2 declare -A F2I F2I=( [sqlite3]=1 [binfile2]=1 ) while read f; do b=$(basename $f) if ! [[ ${F2I[$b]} ]]; then diff $dir1/$f $dir2/$f fi done < $content_dir1
$ echo "abc" | grep -io abc abc $ echo "ABC" | grep -io abc $
$ echo "abc" | grep -i abc abc $ echo "ABC" | grep -i abc ABC
-o, --only-matching Show only the part of a matching line that matches PATTERN. -i, --ignore-case Ignore case distinctions in both the PATTERN and the input files.
$ echo "abc" | grep -io abc abc $ echo "ABC" | grep -io abc ABC
Naos:~ mattlacey$ echo "ABC" | grep -i abc | grep -o abc Naos:~ mattlacey$ echo "ABC" | grep -i abc | grep -o ABC ABC
[Desktop Entry] Encoding=UTF-8 Name=PyCharm Exec=/opt/Pycharm-3.0.1/bin/pycharm.sh Icon=/opt/Pycharm-3.0.1/bin/PyCharm_32.png Type=Application Categories=Development; StartupWMClass=PyCharm
[Desktop Entry] Encoding=UTF-8 Name=PyCharm Exec=/opt/pycharm-3.0.1/bin/pycharm.sh Icon=/opt/pycharm-3.0.1/bin/pyCharm.png Type=Application Categories=Development; StartupWMClass=PyCharm
[Desktop Entry] Version=1.0 Type=Application Name=PyCharm Community Edition Icon=/path/to/pycharm.png Exec="/snap/bin/pycharm-community" %f Comment=The Drive to Develop Categories=Development;IDE; Terminal=false StartupWMClass=jetbrains-pycharm-ce
nano /usr/share/applications/jetbrains-pycharm.desktop
$ ./dir_where_you_placed_it/pycharm-2016.1.4/bin/pycharm.sh
[Desktop Entry] Version=1.0 Type=Application Name=PyCharm Icon=/opt/pycharm-5.0.1/bin/pycharm.png Exec="/opt/pycharm-5.0.1/bin/pycharm.sh" %f Comment=Develop with pleasure! Categories=Development;IDE; Terminal=false StartupWMClass=jetbrains-pycharm
[Desktop Entry] Version=1.0 Type=Application Name=PyCharm Community Edition Icon=/snap/pycharm-community/current/bin/pycharm.png Exec="/snap/bin/pycharm-community" %f Comment=The Drive to Develop Categories=Development;IDE; Terminal=false StartupWMClass=jetbrains-pycharm-ce
-k, --keep-open Accept multiple connections in listen mode -l, --listen Bind and listen for incoming connections
shopt -s expand_aliases _xtrace() { case $1 in on) set -x ;; off) set +x ;; esac } alias xtrace=
shopt -s expand_aliases alias trace_on= alias trace_off= trace_on ...stuff... trace_off
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE rabbitmq latest e8e654c05c91 5 weeks ago 143.5 MB busybox latest 8c2e06607696 6 weeks ago 2.433 MB rabbitmq 3.4.4 a4fbaad9f996 11 weeks ago 131.5 MB
if [[ "$(docker images -q myimage:mytag 2> /dev/null)" == "" ]]; then fi
$ docker inspect --type=image treeder/hello.rb:nada Error: No such image: treeder/hello.rb:nada []
$ docker inspect --type=image treeder/hello.rb:latest [ { "Id": "85c5116a2835521de2c52f10ab5dda0ff002a4a12aa476c141aace9bc67f43ad", "Parent": "ecf63f5eb5e89e5974875da3998d72abc0d3d0e4ae2354887fffba037b356ad5", "Comment": "", "Created": "2015-09-23T22:06:38.86684783Z", ... } ]
[ ! -z $(docker images -q someimage:sometag) ] || echo "does not exist"
[ -z $(docker images -q someimage:sometag) ] || echo "already exists"
$ docker image pull busybox:latest latest: Pulling from library/busybox Digest: sha256:32f093055929dbc23dec4d03e09dfe971f5973a9ca5cf059cbfb644c206aa83f Status: Image is up to date for busybox:latest $ docker image inspect busybox:latest >/dev/null 2>&1 && echo yes || echo no yes
$ docker image rm busybox:latest Untagged: busybox:latest Untagged: busybox@sha256:32f093055929dbc23dec4d03e09dfe971f5973a9ca5cf059cbfb644c206aa83f $ docker image inspect busybox:latest >/dev/null 2>&1 && echo yes || echo no no
image_and_tag="$1" image_and_tag_array=(${image_and_tag if [[ "$(docker images ${image_and_tag_array[0]} | grep ${image_and_tag_array[1]} 2> /dev/null)" != "" ]]; then echo "exists" else echo "doesn fi
if test ! -z "$(docker images -q <name:tag>)"; then echo "Exist" fi
test ! -z "$(docker images -q <name:tag>)" && echo exist
curl $CURLOPTS -H "Authorization: Bearer $token" "https:
{"name":"your-repo-name","tags":["1.0.0.1533677221","1.0.0.1533740305","1.0.0.1535659921","1.0.0.1535665433","latest"]}
{"errors":[{"code":"NAME_UNKNOWN","message":"repository name not known to registry","detail":{"name":"your-repo-name"}}]}
echo $(( ($(date --date="031122" +%s) - $(date --date="021020" +%s) )/(60*60*24) ))
$python -c "from datetime import date; print (date(2003,11,22)-date(2002,10,20)).days" 398
start_ts=$(date -d "2015-03-05" end_ts=$(date -d "2015-03-11"
echo "scale=2; ( $end_ts - $start_ts )/(60*60*24)" | bc
printf "%.0f" $(echo "scale=2; ( $end_ts - $start_ts )/(60*60*24)" | bc)
date_diff=$(( ($(date -d "2015-03-11 UTC" +%s) - $(date -d "2015-03-05 UTC" +%s) )/(60*60*24) ))
$ A="2002-20-10"; B="2003-22-11"; $ echo $(((`date -jf %Y-%d-%m $B +%s` - `date -jf %Y-%d-%m $A +%s`)/86400))
date1yrs=`date -d "20100209" +%Y` date1days=`date -d "20100209" +%j` date2yrs=`date +%Y` date2days=`date +%j` diffyr=`expr $date2yrs - $date1yrs` diffyr2days=`expr $diffyr \* 365` diffdays=`expr $date2days - $date1days` echo `expr $diffyr2days + $diffdays`
use Time::Local; sub to_epoch { my ($t) = @_; my ($y, $d, $m) = ($t =~ /(\d{4})-(\d{2})-(\d{2})/); return timelocal(0, 0, 0, $d+0, $m-1, $y-1900); } sub diff_days { my ($t1, $t2) = @_; return (abs(to_epoch($t2) - to_epoch($t1))) / 86400; } print diff_days("2002-20-10", "2003-22-11"), "\n";
days=$(perl -MDateTime -le ' sub parse_date { @f = split /-/, shift; return DateTime->new(year=>$f[0], month=>$f[2], day=>$f[1]); } print parse_date(shift)->delta_days(parse_date(shift))->in_units("days"); echo $days
A="2002-10-20" B="2003-11-22" echo $(( (`date -d $B +%s` - `date -d $A +%s`) / 86400 )) days
A=2003-12-11 B=2002-10-10 DIFF=$(ruby -rdate -e "puts Date.parse( echo $DIFF
DATE=$(echo `date`) DATENOW=$(echo `date -d "$DATE" +%j`) DATECOMING=$(echo `date -d "20131220" +%j`) THEDAY=$(echo `expr $DATECOMING - $DATENOW`) echo $THEDAY
python -c "from datetime import date; print date(2003, 11, 22).toordinal() - date(2002, 10, 20).toordinal()"
for backup_dir in { do for f in `find $backup_dir -type d -regex do f2=`echo $f | sed -e days=$(((`date "+%s"` - `date -d "${f2}" "+%s"`)/86400)) if [ $days -gt 30 ]; then rm -rf $backup_dir/$f fi done done
date1=2012-09-22 date2=2013-01-31 . date-funcs-sh _date2julian "$date1" jd1=$_DATE2JULIAN _date2julian "$date2" echo $(( _DATE2JULIAN - jd1 ))
if foo ; then else e=$? if [ "${e}" -eq "1"]; then echo "Foo returned exit code 1" elif [ "${e}" -gt "1"]; then echo "Foo returned BAD exit code ${e}" fi fi
onFoo(){ echo "onFoo() called width arg $1!" } foo(){ [[ -f /tmp/somefile ]] || throw EXCEPTION_FOO_OCCURED "some arg" } addListener EXCEPTION_FOO_OCCURED onFoo
[ $(/usr/local/bin/monit --version) == "5.5" ] && echo "OK"
[ $(/usr/local/bin/monit --version) == "5.5" ] || echo "NOT OK"
[[ $(/usr/local/bin/monit --version) =~ "5.5" ]] || echo "NOT OK"
sudo service xyz status | grep if [ $? == 0 ]; then echo "whateveryouwant" fi
function scan2 () { local nl=$ echo "output${nl}${nl}" } VAR=$(scan2; echo "x"); VAR="${VAR%%x}" echo "${VAR}---"
function scan3() { local -n outvar=$1 local nl=$ outvar="output${nl}${nl}" } VAR="some prior value which will get overwritten" scan3 VAR echo "${VAR}==="
function scan3() { declare -n outvar=$1 local nl=$ outvar="output${nl}${nl}" }
$ var=" " $ echo $var /bin /boot /dev /etc /home /initrd.img /lib /lib64 /media /mnt /opt /proc ...
$ cat file foo bar baz $ var=$(cat file) $ echo $var foo bar baz
/bin /boot /dev /etc /home Foobar is free software Desktop/ Downloads/
[ks@localhost ~]$ echo -n "$IFS" | cat -vte ^I$ [ks@localhost ~]$ var=$ [ks@localhost ~]$ echo $var key value [ks@localhost ~]$ IFS= [ks@localhost ~]$ echo $var key value [ks@localhost ~]$
$ vars="-e -n -a" $ echo $vars -a $ echo "$vars" -e -n -a
realpath() { [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1 } realpath "$0"
realpath() { OURPWD=$PWD cd "$(dirname "$1")" LINK=$(readlink "$(basename "$1")") while [ "$LINK" ]; do cd "$(dirname "$LINK")" LINK=$(readlink "$(basename "$1")") done REALPATH="$PWD/$(basename "$1")" cd "$OURPWD" echo "$REALPATH" } realpath "$@"
int main (int argc, char* argv[]) { if (argc > 1) { for (int argIter = 1; argIter < argc; ++argIter) { char *resolved_path_buffer = NULL; char *result = realpath(argv[argIter], resolved_path_buffer); puts(result); if (result != NULL) { free(result); } } } return 0; }
OBJ = realpath.o %.o: %.c $(CC) -c -o $@ $< $(CFLAGS) realpath: $(OBJ) gcc -o $@ $^ $(CFLAGS)
import os import sys print(os.path.realpath(sys.argv[1]))
for argv; do :; done recurses(){ printf "Self-referential:\n\t$argv ->\n\t$argv\n" ;} dangling(){ printf "Broken symlink:\n\t$argv ->\n\t"$(readlink "$argv")"\n" ;} errnoent(){ printf "No such file: "$@"\n" ;} pathfull(){ cd "$(dirname "$@")"; link="$(readlink "$(basename "$@")")" if [ ! -e "$@" ]; then if $(ls -d "$@" 2>/dev/null) 2>/dev/null; then errnoent 1>&2; exit 1; elif [ ! -e "$@" -a "$link" = "$@" ]; then recurses 1>&2; exit 1; elif [ ! -e "$@" ] && [ ! -z "$link" ]; then dangling 1>&2; exit 1; fi fi if [ -z "$link" ]; then if [ "$(dirname "$@" | cut -c1)" = printf "$@\n"; exit 0; else printf "$(pwd)/$(basename "$@")\n"; fi; exit 0 fi while [ "$link" ]; do cd "$(dirname "$link")"; newlink="$(readlink "$(basename "$link")")" case "$newlink" in "$link") dangling 1>&2 && exit 1 ;; *) link="$newlink" && pathfull "$link" ;; esac done printf "$(pwd)/$(basename "$newlink")\n" } if [ -z "$argv" ]; then scriptname="$(pathfull "$0")" printf "\n\033[3mfrom/as: \033[4m$0\033[0m\n\n\033[1mUSAGE:\033[0m " printf "\033[4m$scriptname\033[24m [ link | file | dir ]\n\n " printf "Recursive readlink for the authoritative file, symlink after " printf "symlink.\n\n\n \033[4m$scriptname\033[24m\n\n " printf " From within an invocation of a script, locate the script printf "own file\n (no matter where it has been linked or " printf "from where it is being called).\n\n" else pathfull "$@" fi
realpath() { path=`eval echo "$1"` folder=$(dirname "$path") echo $(cd "$folder"; pwd)/$(basename "$path"); }
realpath() { [ "$1" = "" ] && return 1 dir=`dirname "$1"` file=`basename "$1"` last=`pwd` [ -d "$dir" ] && cd $dir || return 1 if [ -d "$file" ]; then cd $file && pwd || return 1 else echo `pwd`/$file | sed fi cd $last }
escaped=$(echo "$variable" | sed sed "s/$escaped/,\$s/foo/bar/" file
setenv X_ROOT /some/specified/path setenv XDB ${X_ROOT}/db setenv PATH ${X_ROOT}/bin:${PATH} xrun -d xdb1 -i $1 > $2
el@server /home/el $ set | grep LOL el@server /home/el $ el@server /home/el $ env | grep LOL el@server /home/el $
el@server /home/el $ LOL="so wow much code" el@server /home/el $ set | grep LOL LOL= el@server /home/el $ env | grep LOL el@server /home/el $
el@server /home/el $ LOL="so wow much code" el@server /home/el $ set | grep LOL LOL= el@server /home/el $ exec bash el@server /home/el $ set | grep LOL el@server /home/el $
el@server /home/el $ LOL="so wow much code" el@server /home/el $ set | grep LOL LOL= el@server /home/el $ unset LOL el@server /home/el $ set | grep LOL el@server /home/el $
el@server /home/el $ DOGE="such variable" el@server /home/el $ export DOGE el@server /home/el $ set | grep DOGE DOGE= el@server /home/el $ env | grep DOGE DOGE=such variable
el@server /home/el $ exec bash el@server /home/el $ env | grep DOGE DOGE=such variable el@server /home/el $ set | grep DOGE DOGE=
el@server /home/el $ export CAN="chuck norris" el@server /home/el $ env | grep CAN CAN=chuck norris el@server /home/el $ set | grep CAN CAN= el@server /home/el $ env -i bash el@server /home/el $ set | grep CAN el@server /home/el $ env | grep CAN
el@server /home/el $ export FOO="bar" el@server /home/el $ env | grep FOO FOO=bar el@server /home/el $ unset FOO el@server /home/el $ env | grep FOO el@server /home/el $
./somecommand | grep if [ $? == 0 ]; then echo "matched" fi
for x in {a..z} do echo "$x" mkdir -p path2/${x} mv path1/${x}*.ext path2/${x} done
for l in {{a..n},ñ,{o..z}}; do echo $l ; done | nl 1 a ... 14 n 15 ñ 16 o ... 27 z
echo -e {{a..c},ch,{d..l},ll,{m,n},ñ,{o..z}}"\n" | nl
for letter in {{a..z},{A..Z}}; do echo $letter done
$ ssh -q user@downhost exit $ echo $? 255 $ ssh -q user@uphost exit $ echo $? 0
$ a=`nmap uphost -PN -p ssh | grep open` $ b=`nmap downhost -PN -p ssh | grep open` $ echo $a 22/tcp open ssh $ echo $b (empty string)
ssh -q -o "BatchMode=yes" -i /home/sicmapp/.ssh/id_rsa <ID>@<Servername>.<domain> "echo 2>&1" && echo $host SSH_OK || echo $host SSH_NOK
$(ssh -o BatchMode=yes -o ConnectTimeout=5 user@host echo ok 2>&1)
status=$(ssh -o BatchMode=yes -o ConnectTimeout=5 user@host echo ok 2>&1) if [[ $status == ok ]] ; then echo auth ok, do something elif [[ $status == "Permission denied"* ]] ; then echo no_auth else echo other_error fi
echo quit | telnet IP 22 2>/dev/null | grep Connected
nc -q 0 -w 1 "${remote_ip}" 22 < /dev/null &> /dev/null && echo "Port is reachable" || echo "Port is unreachable"
if [ -n "$(ssh "${user}@${server}" [ -d "$folder" ] && echo 1; exit)" ]; then else fi
rsync -zarv --include "*/" --exclude="*" --include="*.sh" "$from" "$to"
rsync -zarv --include="*/" --include="*.sh" --exclude="*" "$from" "$to"
rsync -zarv --prune-empty-dirs --include "*/" --include="*.sh" --exclude="*" "$from" "$to"
rsync -zarv --prune-empty-dirs --include "*/" --include="*.sh" --exclude="*" "$from" "$to"
read -p "Do something? "; if [ $REPLY == "y" ]; then echo yay; fi
zenity --error --text="Testing..." zenity --question --text="Continue?"
$ export HEALTH=34 $ python -c "import os; print **********************************
( echo "10" ; sleep 1 echo " echo "20" ; sleep 1 echo " echo "50" ; sleep 1 echo "This line will just be ignored" ; sleep 1 echo "75" ; sleep 1 echo " echo "100" ; sleep 1 ) | zenity --progress \ --title="Update System Logs" \ --text="Scanning mail logs..." \ --percentage=0 if [ "$?" = -1 ] ; then zenity --error \ --text="Update canceled." fi
Application Options: --calendar Display calendar dialog --entry Display text entry dialog --error Display error dialog --info Display info dialog --file-selection Display file selection dialog --list Display list dialog --notification Display notification --progress Display progress indication dialog --question Display question dialog --warning Display warning dialog --scale Display scale dialog --text-info Display text information dialog
grep -vn "gloom" `grep -l "loom" ~/projects/**/trunk/src/**/*.@(h|cpp)`
grep -l "loom" ~/projects/**/trunk/src/**/*.@(h|cpp) | xargs grep -vn "gloom"
grep -n "loom" `grep -l "loom" tt4.txt` | grep -v "gloom"
file_12390983421 file_12391983421 file_12340983421 file_12390986421
file_12390983421 file_12391983421 file_12340983421 file_12390986421
Control-k: menu-complete Control-j: menu-complete-backward
file_12340983421 file_12390983421 file_12390986421 file_12391983421
file_12340983421 file_12390983421 file_12390986421 file_12391983421
bind bind "set show-all-if-ambiguous on" bind "set menu-complete-display-prefix on"
TAB: menu-complete set editing-mode vi set keymap vi
function func() { echo "Goodbye" exit 1 } echo "Function call will abort" func echo "This will never be printed"
trap "exit 1" TERM export TOP_PID=$$ function func() { echo "Goodbye" kill -s TERM $TOP_PID } echo "Function call will abort" echo $(func) echo "This will never be printed"
function child() { local parent_pid="$1" local other="$2" ... if [[ $failed ]]; then kill -QUIT "$parent_pid" fi }
echo first second | while read A B ; do echo $A-$B ; done
TOTAL=0 printf "%s %s\n" 9 4 3 1 77 2 25 12 226 664 | while read A B;do ((TOTAL+=A-B)) printf "%3d - %3d = %4d -> TOTAL= %4d\n" $A $B $[A-B] $TOTAL done echo final total: $TOTAL
9 - 4 = 5 -> TOTAL= 5 3 - 1 = 2 -> TOTAL= 7 77 - 2 = 75 -> TOTAL= 82 25 - 12 = 13 -> TOTAL= 95 226 - 664 = -438 -> TOTAL= -343 echo final total: $TOTAL final total: 0
read A B <<<"first second" echo $A first echo $B second
while read A B;do echo $A-$B C=$A-$B done << eodoc first second third fourth eodoc first-second third-fourth
TOTAL=0 while read A B;do ((TOTAL+=A-B)) printf "%3d - %3d = %4d -> TOTAL= %4d\n" $A $B $[A-B] $TOTAL done < <( printf "%s %s\n" 9 4 3 1 77 2 25 12 226 664 ) 9 - 4 = 5 -> TOTAL= 5 3 - 1 = 2 -> TOTAL= 7 77 - 2 = 75 -> TOTAL= 82 25 - 12 = 13 -> TOTAL= 95 226 - 664 = -438 -> TOTAL= -343 echo $TOTAL -343
printf "%s %s\n" 9 4 3 1 77 2 25 12 226 664 | { TOTAL=0 while read A B;do ((TOTAL+=A-B)) printf "%3d - %3d = %4d -> TOTAL= %4d\n" $A $B $[A-B] $TOTAL done echo "Out of the loop total:" $TOTAL }
9 - 4 = 5 -> TOTAL= 5 3 - 1 = 2 -> TOTAL= 7 77 - 2 = 75 -> TOTAL= 82 25 - 12 = 13 -> TOTAL= 95 226 - 664 = -438 -> TOTAL= -343 Out of the loop total: -343
shopt -s lastpipe set +m TOTAL=0 printf "%s %s\n" 9 4 3 1 77 2 25 12 226 664 | while read A B;do ((TOTAL+=A-B)) printf "%3d - %3d = %4d -> TOTAL= %4d\n" $A $B $[A-B] $TOTAL done 9 - 4 = 5 -> TOTAL= -338 3 - 1 = 2 -> TOTAL= -336 77 - 2 = 75 -> TOTAL= -261 25 - 12 = 13 -> TOTAL= -248 226 - 664 = -438 -> TOTAL= -686 echo final total: $TOTAL -343
read -r a b < <(echo "$first $second") echo "$a $b"
gcc -c -g program.c > compiler.txt (ampersand removed)
