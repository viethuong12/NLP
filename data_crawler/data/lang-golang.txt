s := "" for i := 0; i < 1000; i++ { s += getShortStringFromSomewhere() } return s
package main import ( "bytes" "fmt" ) func main() { var buffer bytes.Buffer for i := 0; i < 1000; i++ { buffer.WriteString("a") } fmt.Println(buffer.String()) }
package main import ( "bytes" "strings" "testing" ) func BenchmarkConcat(b *testing.B) { var str string for n := 0; n < b.N; n++ { str += "x" } b.StopTimer() if s := strings.Repeat("x", b.N); str != s { b.Errorf("unexpected result; got=%s, want=%s", str, s) } } func BenchmarkBuffer(b *testing.B) { var buffer bytes.Buffer for n := 0; n < b.N; n++ { buffer.WriteString("x") } b.StopTimer() if s := strings.Repeat("x", b.N); buffer.String() != s { b.Errorf("unexpected result; got=%s, want=%s", buffer.String(), s) } } func BenchmarkCopy(b *testing.B) { bs := make([]byte, b.N) bl := 0 b.ResetTimer() for n := 0; n < b.N; n++ { bl += copy(bs[bl:], "x") } b.StopTimer() if s := strings.Repeat("x", b.N); string(bs) != s { b.Errorf("unexpected result; got=%s, want=%s", string(bs), s) } } func BenchmarkStringBuilder(b *testing.B) { var strBuilder strings.Builder b.ResetTimer() for n := 0; n < b.N; n++ { strBuilder.WriteString("x") } b.StopTimer() if s := strings.Repeat("x", b.N); strBuilder.String() != s { b.Errorf("unexpected result; got=%s, want=%s", strBuilder.String(), s) } }
import ( "fmt"; "strings"; ) func main() { s := []string{"this", "is", "a", "joined", "string\n"}; fmt.Printf(strings.Join(s, " ")); } $ ./test.bin this is a joined string
package main import ( "strings" "fmt" ) func main() { var str strings.Builder for i := 0; i < 1000; i++ { str.WriteString("a") } fmt.Println(str.String()) }
func (r *record) String() string { buffer := bytes.NewBufferString(""); fmt.Fprint(buffer,"(",r.name,"[") for i := 0; i < len(r.subs); i++ { fmt.Fprint(buffer,"\t",r.subs[i]) } fmt.Fprint(buffer,"]",r.size,")\n") return buffer.String() }
func (r *record) String() string { s := "(\"" + r.name + "\" [" for i := 0; i < len(r.subs); i++ { s += r.subs[i].String() } s += "] " + strconv.FormatInt(r.size,10) + ")\n" return s }
func (r *record) String() string { var parts []string parts = append(parts, "(\"", r.name, "\" [" ) for i := 0; i < len(r.subs); i++ { parts = append(parts, r.subs[i].String()) } parts = append(parts, strconv.FormatInt(r.size,10), ")\n") return strings.Join(parts,"") }
func Append(slice, data[]byte) []byte { l := len(slice); if l + len(data) > cap(slice) { newSlice := make([]byte, (l+len(data))*2); for i, c := range slice { newSlice[i] = c } slice = newSlice; } slice = slice[0:l+len(data)]; for i, c := range data { slice[l+i] = c } return slice; }
var data []byte for i := 0; i < 1000; i++ { data = append(data, getShortStringFromSomewhere()...) } return string(data)
package main import ( "bytes" "strings" "testing" ) const ( sss = "xfoasneobfasieongasbg" cnt = 10000 ) var ( bbb = []byte(sss) expected = strings.Repeat(sss, cnt) ) func BenchmarkCopyPreAllocate(b *testing.B) { var result string for n := 0; n < b.N; n++ { bs := make([]byte, cnt*len(sss)) bl := 0 for i := 0; i < cnt; i++ { bl += copy(bs[bl:], sss) } result = string(bs) } b.StopTimer() if result != expected { b.Errorf("unexpected result; got=%s, want=%s", string(result), expected) } } func BenchmarkAppendPreAllocate(b *testing.B) { var result string for n := 0; n < b.N; n++ { data := make([]byte, 0, cnt*len(sss)) for i := 0; i < cnt; i++ { data = append(data, sss...) } result = string(data) } b.StopTimer() if result != expected { b.Errorf("unexpected result; got=%s, want=%s", string(result), expected) } } func BenchmarkBufferPreAllocate(b *testing.B) { var result string for n := 0; n < b.N; n++ { buf := bytes.NewBuffer(make([]byte, 0, cnt*len(sss))) for i := 0; i < cnt; i++ { buf.WriteString(sss) } result = buf.String() } b.StopTimer() if result != expected { b.Errorf("unexpected result; got=%s, want=%s", string(result), expected) } } func BenchmarkCopy(b *testing.B) { var result string for n := 0; n < b.N; n++ { data := make([]byte, 0, 64) for i := 0; i < cnt; i++ { off := len(data) if off+len(sss) > cap(data) { temp := make([]byte, 2*cap(data)+len(sss)) copy(temp, data) data = temp } data = data[0 : off+len(sss)] copy(data[off:], sss) } result = string(data) } b.StopTimer() if result != expected { b.Errorf("unexpected result; got=%s, want=%s", string(result), expected) } } func BenchmarkAppend(b *testing.B) { var result string for n := 0; n < b.N; n++ { data := make([]byte, 0, 64) for i := 0; i < cnt; i++ { data = append(data, sss...) } result = string(data) } b.StopTimer() if result != expected { b.Errorf("unexpected result; got=%s, want=%s", string(result), expected) } } func BenchmarkBufferWrite(b *testing.B) { var result string for n := 0; n < b.N; n++ { var buf bytes.Buffer for i := 0; i < cnt; i++ { buf.Write(bbb) } result = buf.String() } b.StopTimer() if result != expected { b.Errorf("unexpected result; got=%s, want=%s", string(result), expected) } } func BenchmarkBufferWriteString(b *testing.B) { var result string for n := 0; n < b.N; n++ { var buf bytes.Buffer for i := 0; i < cnt; i++ { buf.WriteString(sss) } result = buf.String() } b.StopTimer() if result != expected { b.Errorf("unexpected result; got=%s, want=%s", string(result), expected) } } func BenchmarkConcat(b *testing.B) { var result string for n := 0; n < b.N; n++ { var str string for i := 0; i < cnt; i++ { str += sss } result = str } b.StopTimer() if result != expected { b.Errorf("unexpected result; got=%s, want=%s", string(result), expected) } }
BenchmarkCopyPreAllocate-8 20000 84208 ns/op 425984 B/op 2 allocs/op BenchmarkAppendPreAllocate-8 10000 102859 ns/op 425984 B/op 2 allocs/op BenchmarkBufferPreAllocate-8 10000 166407 ns/op 426096 B/op 3 allocs/op BenchmarkCopy-8 10000 160923 ns/op 933152 B/op 13 allocs/op BenchmarkAppend-8 10000 175508 ns/op 1332096 B/op 24 allocs/op BenchmarkBufferWrite-8 10000 239886 ns/op 933266 B/op 14 allocs/op BenchmarkBufferWriteString-8 10000 236432 ns/op 933266 B/op 14 allocs/op BenchmarkConcat-8 10 105603419 ns/op 1086685168 B/op 10000 allocs/op
package main import ( "fmt" ) func main() { var str1 = "string1" var str2 = "string2" out := fmt.Sprintf("%s %s ",str1, str2) fmt.Println(out) }
BenchmarkAppendEmpty 50000000 5.0 ns/op BenchmarkAppendPrealloc 50000000 3.5 ns/op BenchmarkCopy 20000000 10.2 ns/op
package performance_test import ( "bytes" "fmt" "testing" ) const ( concatSteps = 100 ) func BenchmarkConcat(b *testing.B) { for n := 0; n < b.N; n++ { var str string for i := 0; i < concatSteps; i++ { str += "x" } } } func BenchmarkBuffer(b *testing.B) { for n := 0; n < b.N; n++ { var buffer bytes.Buffer for i := 0; i < concatSteps; i++ { buffer.WriteString("x") } } }
BenchmarkConcat-4 300000 6869 ns/op BenchmarkBuffer-4 1000000 1186 ns/op
package main import ( "fmt" "strings" ) func main (){ concatenation:= strings.Join([]string{"a","b","c"},"") fmt.Println(concatenation) }
package main import ( "fmt" ) func main() { var str1 = "string1" var str2 = "string2" result := make([]byte, 0) result = append(result, []byte(str1)...) result = append(result, []byte(str2)...) result = append(result, []byte(str1)...) result = append(result, []byte(str2)...) fmt.Println(string(result)) }
go test -bench . -benchmem goos: darwin goarch: amd64 pkg: github.com/hechen0/goexp/exps BenchmarkConcat-8 1000000 60213 ns/op 503992 B/op 1 allocs/op BenchmarkBuffer-8 100000000 11.3 ns/op 2 B/op 0 allocs/op BenchmarkCopy-8 300000000 4.76 ns/op 0 B/op 0 allocs/op BenchmarkStringBuilder-8 1000000000 4.14 ns/op 6 B/op 0 allocs/op PASS ok github.com/hechen0/goexp/exps 70.071s
func JoinBetween(in []string, separator string, startIndex, endIndex int) string { if in == nil { return "" } noOfItems := endIndex - startIndex if noOfItems <= 0 { return EMPTY } var builder strings.Builder for i := startIndex; i < endIndex; i++ { if i > startIndex { builder.WriteString(separator) } builder.WriteString(in[i]) } return builder.String() }
package main import "strings" var intEX = 0 var stringEX = "hello all you " var stringEX2 = " people in here" func main() { strings.Join(stringEX, string(intEX), stringEX2) }
var seconds int var ok bool seconds, ok = timeZone[tz]
package main import "fmt" func main() { dict := map[string]int {"foo" : 1, "bar" : 2} value, ok := dict["baz"] if ok { fmt.Println("value: ", value) } else { fmt.Println("key not found") } }
if value, ok := dict["baz"]; ok { fmt.Println("value: ", value) } else { fmt.Println("key not found") }
_, exists := timeZone[tz] val, exists := timeZone[tz]
var seconds int var ok bool seconds, ok = timeZone[tz]
func offset(tz string) int { if seconds, ok := timeZone[tz]; ok { return seconds } log.Println("unknown time zone:", tz) return 0 }
v, ok = a[x] v, ok := a[x] var v, ok = a[x] var v, ok T = a[x]
m := map[int]string{} s := m[1] var m2 map[int]float64 f := m2[2] fmt.Printf("%q %f", s, f)
m := map[int]string{ 0: "zero", 1: "one", } fmt.Printf("Key 0 exists: %t\nKey 1 exists: %t\nKey 2 exists: %t", m[0] != "", m[1] != "", m[2] != "")
Key 0 exists: true Key 1 exists: true Key 2 exists: false
var empty struct{} var ok bool var m map[string]struct{} m = make(map[string]struct{}) m["somestring"] = empty _, ok = m["somestring"] fmt.Println("somestring exists?", ok) _, ok = m["not"] fmt.Println("not exists?", ok)
package main import ( "fmt" ) func main(){ sampleMap := map[string]int {"key1" : 100, "key2" : 500, "key3" : 999} value, isKeyPresent := sampleMap["key2"] if isKeyPresent { fmt.Println("key present, value = ", value) } else { fmt.Println("key does not exist") } }
`line one line two ` + "`" + `line three line four`
func main(){ multiline := `line by line and line after line` }
func main(){ multiline := `line by line \n and line \n after line` fmt.Print(multiline) }
func main(){ multiline := "line " + "by line " + "and line " + "after line" fmt.Print(multiline) }
func main(){ multiline := "line " + "by line \n" + "and line \n" + "after line" fmt.Print(multiline) }
package main import "fmt" func main() { message := `This is a Multi-line Text String Because it uses the raw-string back ticks instead of quotes. ` fmt.Printf("%s", message) }
package main import "fmt" func main() { testLine := `This is a test line 1 This is a test line 2` fmt.Println(testLine) }
package main import "fmt" func CToGoString(c []byte) string { n := -1 for i, b := range c { if b == 0 { break } n = i } return string(c[:n+1]) } func main() { c := [100]byte{ fmt.Println("C: ", len(c), c[:4]) g := CToGoString(c[:]) fmt.Println("Go:", len(g), g) }
package main import "fmt" func FirstZero(b []byte) int { min, max := 0, len(b) for { if min + 1 == max { return max } mid := (min + max) / 2 if b[mid] == max = mid } else { min = mid } } return len(b) } func main() { b := []byte{1, 2, 3, 0, 0, 0} fmt.Println(FirstZero(b)) }
package main import ( "fmt" "reflect" "unsafe" ) func BytesToString(b []byte) string { bh := (*reflect.SliceHeader)(unsafe.Pointer(&b)) sh := reflect.StringHeader{bh.Data, bh.Len} return *(*string)(unsafe.Pointer(&sh)) } func StringToBytes(s string) []byte { sh := (*reflect.StringHeader)(unsafe.Pointer(&s)) bh := reflect.SliceHeader{sh.Data, sh.Len, 0} return *(*[]byte)(unsafe.Pointer(&bh)) } func main() { b := []byte{ s := BytesToString(b) fmt.Println(s) b = StringToBytes(s) fmt.Println(string(b)) }
buf := make([]byte, 100) n, err := myReader.Read(buf) if n == 0 && err != nil { log.Fatal(err) } consume(buf[:n])
resp, _ := http.Get("https: bytes, _ := ioutil.ReadAll(resp.Body) resp.Body.Close() fmt.Println(string(bytes))
func CToGoString(c []byte, acc string) string { if len(c) == 0 { return acc } else { head := c[0] tail := c[1:] return CToGoString(tail, acc + fmt.Sprintf("%c", head)) } } func main() { b := []byte{some char bytes} fmt.Println(CToGoString(b, "")) }
for i, v := range slice {} for i := range slice {} for _, v := range slice {}
for key, value := range theMap {} for key := range theMap {} for _, value := range theMap {}
func PrintXml (out io.Writer, value interface{}) error { var data []byte var err error for _, action := range []func() { func () { data, err = xml.MarshalIndent(value, "", " ") }, func () { _, err = out.Write([]byte(xml.Header)) }, func () { _, err = out.Write(data) }, func () { _, err = out.Write([]byte("\n")) }} { action(); if err != nil { return err } } return nil; }
package main import ( "fmt" ) func main() { arrayOne := [3]string{"Apple", "Mango", "Banana"} for index,element := range arrayOne{ fmt.Println(index) fmt.Println(element) } }
package main import "fmt" var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { for i, v := range pow { fmt.Printf("2**%d = %d\n", i, v) } for i := range pow { pow[i] = 1 << uint(i) } for _, value := range pow { fmt.Printf("%d\n", value) } }
package main import ( "fmt" ) func main() { for _, element := range [3]string{"a", "b", "c"} { fmt.Print(element) } }
const ( c0 = iota c1 = iota c2 = iota ) const ( a = 1 << iota b = 1 << iota c = 1 << iota ) const ( u = iota * 42 v float64 = iota * 42 w = iota * 42 ) const x = iota const y = iota
const ( bit0, mask0 = 1 << iota, 1<<iota - 1 bit1, mask1 _, _ bit3, mask3 )
package a type base int const ( A base = iota C T G ) type Baser interface { Base() base } func(b base) Base() base { return b } func(b base) OtherMethod() { }
package main import "a" func HandleBasers(b a.Baser) { base := b.Base() base.OtherMethod() } func AorC(condition bool) a.Baser { if condition { return a.A } return a.C }
type MessageType int32 const ( TEXT MessageType = 0 BINARY MessageType = 1 )
package main import ( "fmt" ) var Colors = newColorRegistry() func newColorRegistry() *colorRegistry { return &colorRegistry{ Red: "red", Green: "green", Blue: "blue", } } type colorRegistry struct { Red string Green string Blue string } func main() { fmt.Println(Colors.Red) }
package main import ( "errors" "fmt" ) var Colors = newColorRegistry() type Color struct { StringRepresentation string Hex string } func (c *Color) String() string { return c.StringRepresentation } func newColorRegistry() *colorRegistry { red := &Color{"red", "F00"} green := &Color{"green", "0F0"} blue := &Color{"blue", "00F"} return &colorRegistry{ Red: red, Green: green, Blue: blue, colors: []*Color{red, green, blue}, } } type colorRegistry struct { Red *Color Green *Color Blue *Color colors []*Color } func (c *colorRegistry) List() []*Color { return c.colors } func (c *colorRegistry) Parse(s string) (*Color, error) { for _, color := range c.List() { if color.String() == s { return color, nil } } return nil, errors.New("couldn } func main() { fmt.Printf("%s\n", Colors.List()) }
package main import "fmt" type Enum interface { name() string ordinal() int values() *[]string } type GenderType uint const ( MALE = iota FEMALE ) var genderTypeStrings = []string{ "MALE", "FEMALE", } func (gt GenderType) name() string { return genderTypeStrings[gt] } func (gt GenderType) ordinal() int { return int(gt) } func (gt GenderType) values() *[]string { return &genderTypeStrings } func main() { var ds GenderType = MALE fmt.Printf("The Gender is %s\n", ds.name()) }
package main import ( "fmt" ) const ( UNSPECIFIED Level = iota TRACE INFO WARNING ERROR ) type Level int func SetLogLevel(level Level) { switch level { case TRACE: fmt.Println("trace") return case INFO: fmt.Println("info") return case WARNING: fmt.Println("warning") return case ERROR: fmt.Println("error") return default: fmt.Println("default") return } } func main() { SetLogLevel(INFO) }
package main import ( "strconv" "fmt" ) func main() { t := strconv.Itoa(123) fmt.Println(t) }
n := int64(32) str := strconv.FormatInt(n, 10) fmt.Println(str)
func foo(params ...int) { fmt.Println(len(params)) } func main() { foo() foo(1) foo(1,2,3) }
type Params struct { a, b, c int } func doIt(p Params) int { return p.a + p.b + p.c } doIt(Params{a: 1, c: 9})
func NewFoobar(options ...func(*Foobar) error) (*Foobar, error){ fb := &Foobar{} for _, op := range options{ err := op(fb) if err != nil { return nil, err } } return fb, nil }
func OptionReadonlyFlag(fb *Foobar) error { fb.mutable = false return nil } func OptionTemperature(t Celsius) func(*Foobar) error { return func(fb *Foobar) error { fb.temperature = t return nil } }
package main import ( "bufio" "fmt" "os" ) func main() { fmt.Println(prompt()) } func prompt(params ...string) string { prompt := ": " if len(params) > 0 { prompt = params[0] } reader := bufio.NewReader(os.Stdin) fmt.Print(prompt) text, _ := reader.ReadString( return text }
type myType struct { s string a, b int } func New(s string, err *error) *myType { if s == "" { *err = errors.New( "Mandatory argument `s` must not be empty!") } return &myType{s: s} } func (this *myType) setA (a int, err *error) *myType { if *err == nil { if a == 42 { *err = errors.New("42 is not the answer!") } else { this.a = a } } return this } func (this *myType) setB (b int, _ *error) *myType { this.b = b return this }
func main() { var err error = nil instance := New("hello", &err). setA(1, &err). setB(2, &err) if err != nil { fmt.Println("Failed: ", err) } else { fmt.Println(instance) } }
if _, err := os.Stat("/path/to/whatever"); os.IsNotExist(err) { }
if _, err := os.Stat("/path/to/whatever"); err == nil { } else if os.IsNotExist(err) { } else { }
func Exists(name string) bool { if _, err := os.Stat(name); err != nil { if os.IsNotExist(err) { return false } } return true }
_, err := os.Stat(file) if err == nil { log.Printf("file %s exists", file) } else if os.IsNotExist(err) { log.Printf("file %s not exists", file) } else { log.Printf("file %s stat error: %v", file, err) }
func Exists(name string) bool { _, err := os.Stat(name) return !os.IsNotExist(err) }
func Exists(name string) (bool, error) { err := os.Stat(name) if os.IsNotExist(err) { return false, nil } return err != nil, err }
func file_is_exists(f string) bool { _, err := os.Stat(f) if os.IsNotExist(err) { return false } return err == nil }
if _, err := os.Stat(path/to/file); !os.IsNotExist(err){ }
struct { microsec uint64 "field 1" serverIP6 uint64 "field 2" process string "field 3" }
type User struct { Name string `json:"name" xml:"name"` }
type User struct { Name string `mytag:"MyName"` Email string `mytag:"MyEmail"` } u := User{"Bob", "bob@mycompany.com"} t := reflect.TypeOf(u) for _, fieldName := range []string{"Name", "Email"} { field, found := t.FieldByName(fieldName) if !found { continue } fmt.Printf("\nField: User.%s\n", fieldName) fmt.Printf("\tWhole tag value : %q\n", field.Tag) fmt.Printf("\tValue of }
Field: User.Name Whole tag value : "mytag:\"MyName\"" Value of Field: User.Email Whole tag value : "mytag:\"MyEmail\"" Value of
package main import ( "fmt" "encoding/json" ) type Person struct { FirstName string `json:"first_name"` LastName string `json:"last_name"` MiddleName string `json:"middle_name,omitempty"` } func main() { json_string := ` { "first_name": "John", "last_name": "Smith" }` person := new(Person) json.Unmarshal([]byte(json_string), person) fmt.Println(person) new_json, _ := json.Marshal(person) fmt.Printf("%s\n", new_json) }
cannot use []int literal (type []int) as type int in append
func foo(is ...int) { for i := 0; i < len(is); i++ { fmt.Println(is[i]) } } func main() { foo([]int{9,8,7,6,5}...) }
append(s S, x ...T) S s0 := []int{0, 0} s1 := append(s0, 2) s2 := append(s1, 3, 5, 7) s3 := append(s2, s0...)
slice = append(slice, elem1, elem2) slice = append(slice, anotherSlice...)
a := [10]int{1, 2} fmt.Printf("a: %v\n", a) x, y := a[:2], []int{3, 4} fmt.Printf("x: %v, y: %v\n", x, y) fmt.Printf("cap(x): %v\n", cap(x)) x = append(x, y...) fmt.Printf("x: %v\n", x) fmt.Printf("a: %v\n", a)
a: [1 2 0 0 0 0 0 0 0 0] x: [1 2], y: [3 4] cap(x): 10 x: [1 2 3 4] a: [1 2 3 4 0 0 0 0 0 0]
a := [10]int{1, 2} fmt.Printf("a: %v\n", a) x, y := a[:2:2], []int{3, 4} fmt.Printf("x: %v, y: %v\n", x, y) fmt.Printf("cap(x): %v\n", cap(x)) x = append(x, y...) fmt.Printf("x: %v\n", x) fmt.Printf("a: %v\n", a)
a: [1 2 0 0 0 0 0 0 0 0] x: [1 2], y: [3 4] cap(x): 2 x: [1 2 3 4] a: [1 2 0 0 0 0 0 0 0 0]
package main import ( "fmt" ) func main() { x := []int{1, 2, 3} y := []int{4, 5, 6} z := append([]int{}, append(x, y...)...) fmt.Println(z) }
func Greeting(prefix string, who ...string) Greeting("nobody") Greeting("hello:", "Joe", "Anna", "Eileen")
Hi [name]! Your account is ready, your user name is: [user-name] You have the following roles assigned: [role
const emailTmpl = `Hi {{.Name}}! Your account is ready, your user name is: {{.UserName}} You have the following roles assigned: {{range $i, $r := .Roles}}{{if ne $i 0}}, {{end}}{{.}}{{end}} `
data := map[string]interface{}{ "Name": "Bob", "UserName": "bob92", "Roles": []string{"dbteam", "uiteam", "tester"}, }
t := template.Must(template.New("email").Parse(emailTmpl)) buf := &bytes.Buffer{} if err := t.Execute(buf, data); err != nil { panic(err) } s := buf.String()
Hi Bob! Your account is ready, your user name is: bob92 You have the following roles assigned: dbteam, uiteam, tester
builder := &strings.Builder{} if err := t.Execute(builder, data); err != nil { panic(err) } s := builder.String()
t := template.Must(template.New("email").Parse(emailTmpl)) if err := t.Execute(os.Stdout, data); err != nil { panic(err) }
for e := dlist.Front(); e != nil; e = e.Next() { lines := e.Value fmt.Printf(reflect.TypeOf(lines)) }
package main import ( "fmt" "reflect" ) func main() { tst := "string" tst2 := 10 tst3 := 1.2 fmt.Println(reflect.TypeOf(tst)) fmt.Println(reflect.TypeOf(tst2)) fmt.Println(reflect.TypeOf(tst3)) }
func typeof(v interface{}) string { return fmt.Sprintf("%T", v) }
func typeof(v interface{}) string { return reflect.TypeOf(v).String() }
func typeof(v interface{}) string { switch v.(type) { case int: return "int" case float64: return "float64" default: return "unknown" } }
package main import ( "fmt" "reflect" ) func main() { b := true s := "" n := 1 f := 1.0 a := []string{"foo", "bar", "baz"} fmt.Println(reflect.TypeOf(b)) fmt.Println(reflect.TypeOf(s)) fmt.Println(reflect.TypeOf(n)) fmt.Println(reflect.TypeOf(f)) fmt.Println(reflect.TypeOf(a)) }
package main import ( "fmt" "reflect" ) func main() { b := true s := "" n := 1 f := 1.0 a := []string{"foo", "bar", "baz"} fmt.Println(reflect.ValueOf(b).Kind()) fmt.Println(reflect.ValueOf(s).Kind()) fmt.Println(reflect.ValueOf(n).Kind()) fmt.Println(reflect.ValueOf(f).Kind()) fmt.Println(reflect.ValueOf(a).Index(0).Kind()) }
package main import "fmt" func main(){ types := []interface{} {"a",6,6.0,true} for _,v := range types{ fmt.Printf("%T\n",v) } }
package main import ( "fmt" ) func main() { b := true s := "" n := 1 f := 1.0 a := []string{"foo", "bar", "baz"} fmt.Printf("%T\n", b) fmt.Printf("%T\n", s) fmt.Printf("%T\n", n) fmt.Printf("%T\n", f) fmt.Printf("%T\n", a) }
package main import ( "fmt" "reflect" ) func main() { value1 := "Have a Good Day" value2 := 50 value3 := 50.78 fmt.Println(reflect.TypeOf(value1 )) fmt.Println(reflect.TypeOf(value2)) fmt.Println(reflect.TypeOf(value3)) fmt.Printf("%T",value1) fmt.Printf("%T",value2) fmt.Printf("%T",value3) }
package main import ( "fmt" "reflect" ) type testObject struct { Name string Age int Height float64 } func main() { tstObj := testObject{Name: "yog prakash", Age: 24, Height: 5.6} val := reflect.ValueOf(&tstObj).Elem() typeOfTstObj := val.Type() for i := 0; i < val.NumField(); i++ { fieldType := val.Field(i) fmt.Printf("object field %d key=%s value=%v type=%s \n", i, typeOfTstObj.Field(i).Name, fieldType.Interface(), fieldType.Type()) } }
object field 0 key=Name value=yog prakash type=string object field 1 key=Age value=24 type=int object field 2 key=Height value=5.6 type=float64
var WhatIsThe = AnswerToLife() func AnswerToLife() int { return 42 } func init() { WhatIsThe = 0 } func main() { if WhatIsThe == 0 { fmt.Println("It } }
var ConfigSuccess = configureApplication() func init() { doSomething() } func configureApplication() bool { l4g.Info("Configuring application...") if valid := loadCommandLineFlags(); !valid { l4g.Critical("Failed to load Command Line Flags") return false } return true }
func init() { var ( rwd string tmp string ok bool ) if metapath, ok := Config["fs"]["metapath"].(string); ok { var err error Conn, err = services.NewConnection(metapath + "/metadata.db") if err != nil { panic(err) } } }
package main import ( "fmt" ) func callOut() int { fmt.Println("Outside is beinge executed") return 1 } var test = callOut() func init() { fmt.Println("Init3 is being executed") } func init() { fmt.Println("Init is being executed") } func init() { fmt.Println("Init2 is being executed") } func main() { fmt.Println("Do your thing !") }
$ go run init/init.go Outside is being executed Init3 is being executed Init is being executed Init2 is being executed Do your thing !
package mime import ( "mime" "path/filepath" ) var types = map[string]string{ ".3dm": "x-world/x-3dmf", ".3dmf": "x-world/x-3dmf", ".7z": "application/x-7z-compressed", ".a": "application/octet-stream", ".aab": "application/x-authorware-bin", ".aam": "application/x-authorware-map", ".aas": "application/x-authorware-seg", ".abc": "text/vndabc", ".ace": "application/x-ace-compressed", ".acgi": "text/html", ".afl": "video/animaflex", ".ai": "application/postscript", ".aif": "audio/aiff", ".aifc": "audio/aiff", ".aiff": "audio/aiff", ".aim": "application/x-aim", ".aip": "text/x-audiosoft-intra", ".alz": "application/x-alz-compressed", ".ani": "application/x-navi-animation", ".aos": "application/x-nokia-9000-communicator-add-on-software", ".aps": "application/mime", ".apk": "application/vnd.android.package-archive", ".arc": "application/x-arc-compressed", ".arj": "application/arj", ".art": "image/x-jg", ".asf": "video/x-ms-asf", ".asm": "text/x-asm", ".asp": "text/asp", ".asx": "application/x-mplayer2", ".au": "audio/basic", ".avi": "video/x-msvideo", ".avs": "video/avs-video", ".bcpio": "application/x-bcpio", ".bin": "application/mac-binary", ".bmp": "image/bmp", ".boo": "application/book", ".book": "application/book", ".boz": "application/x-bzip2", ".bsh": "application/x-bsh", ".bz2": "application/x-bzip2", ".bz": "application/x-bzip", ".c++": "text/plain", ".c": "text/x-c", ".cab": "application/vnd.ms-cab-compressed", ".cat": "application/vndms-pkiseccat", ".cc": "text/x-c", ".ccad": "application/clariscad", ".cco": "application/x-cocoa", ".cdf": "application/cdf", ".cer": "application/pkix-cert", ".cha": "application/x-chat", ".chat": "application/x-chat", ".chrt": "application/vnd.kde.kchart", ".class": "application/java", ".com": "text/plain", ".conf": "text/plain", ".cpio": "application/x-cpio", ".cpp": "text/x-c", ".cpt": "application/mac-compactpro", ".crl": "application/pkcs-crl", ".crt": "application/pkix-cert", ".crx": "application/x-chrome-extension", ".csh": "text/x-scriptcsh", ".css": "text/css", ".csv": "text/csv", ".cxx": "text/plain", ".dar": "application/x-dar", ".dcr": "application/x-director", ".deb": "application/x-debian-package", ".deepv": "application/x-deepv", ".def": "text/plain", ".der": "application/x-x509-ca-cert", ".dif": "video/x-dv", ".dir": "application/x-director", ".divx": "video/divx", ".dl": "video/dl", ".dmg": "application/x-apple-diskimage", ".doc": "application/msword", ".dot": "application/msword", ".dp": "application/commonground", ".drw": "application/drafting", ".dump": "application/octet-stream", ".dv": "video/x-dv", ".dvi": "application/x-dvi", ".dwf": "drawing/x-dwf=(old)", ".dwg": "application/acad", ".dxf": "application/dxf", ".dxr": "application/x-director", ".el": "text/x-scriptelisp", ".elc": "application/x-bytecodeelisp=(compiled=elisp)", ".eml": "message/rfc822", ".env": "application/x-envoy", ".eps": "application/postscript", ".es": "application/x-esrehber", ".etx": "text/x-setext", ".evy": "application/envoy", ".exe": "application/octet-stream", ".f77": "text/x-fortran", ".f90": "text/x-fortran", ".f": "text/x-fortran", ".fdf": "application/vndfdf", ".fif": "application/fractals", ".fli": "video/fli", ".flo": "image/florian", ".flv": "video/x-flv", ".flx": "text/vndfmiflexstor", ".fmf": "video/x-atomic3d-feature", ".for": "text/x-fortran", ".fpx": "image/vndfpx", ".frl": "application/freeloader", ".funk": "audio/make", ".g3": "image/g3fax", ".g": "text/plain", ".gif": "image/gif", ".gl": "video/gl", ".gsd": "audio/x-gsm", ".gsm": "audio/x-gsm", ".gsp": "application/x-gsp", ".gss": "application/x-gss", ".gtar": "application/x-gtar", ".gz": "application/x-compressed", ".gzip": "application/x-gzip", ".h": "text/x-h", ".hdf": "application/x-hdf", ".help": "application/x-helpfile", ".hgl": "application/vndhp-hpgl", ".hh": "text/x-h", ".hlb": "text/x-script", ".hlp": "application/hlp", ".hpg": "application/vndhp-hpgl", ".hpgl": "application/vndhp-hpgl", ".hqx": "application/binhex", ".hta": "application/hta", ".htc": "text/x-component", ".htm": "text/html", ".html": "text/html", ".htmls": "text/html", ".htt": "text/webviewhtml", ".htx": "text/html", ".ice": "x-conference/x-cooltalk", ".ico": "image/x-icon", ".ics": "text/calendar", ".icz": "text/calendar", ".idc": "text/plain", ".ief": "image/ief", ".iefs": "image/ief", ".iges": "application/iges", ".igs": "application/iges", ".ima": "application/x-ima", ".imap": "application/x-httpd-imap", ".inf": "application/inf", ".ins": "application/x-internett-signup", ".ip": "application/x-ip2", ".isu": "video/x-isvideo", ".it": "audio/it", ".iv": "application/x-inventor", ".ivr": "i-world/i-vrml", ".ivy": "application/x-livescreen", ".jam": "audio/x-jam", ".jav": "text/x-java-source", ".java": "text/x-java-source", ".jcm": "application/x-java-commerce", ".jfif-tbnl": "image/jpeg", ".jfif": "image/jpeg", ".jnlp": "application/x-java-jnlp-file", ".jpe": "image/jpeg", ".jpeg": "image/jpeg", ".jpg": "image/jpeg", ".jps": "image/x-jps", ".js": "application/javascript", ".json": "application/json", ".jut": "image/jutvision", ".kar": "audio/midi", ".karbon": "application/vnd.kde.karbon", ".kfo": "application/vnd.kde.kformula", ".flw": "application/vnd.kde.kivio", ".kml": "application/vnd.google-earth.kml+xml", ".kmz": "application/vnd.google-earth.kmz", ".kon": "application/vnd.kde.kontour", ".kpr": "application/vnd.kde.kpresenter", ".kpt": "application/vnd.kde.kpresenter", ".ksp": "application/vnd.kde.kspread", ".kwd": "application/vnd.kde.kword", ".kwt": "application/vnd.kde.kword", ".ksh": "text/x-scriptksh", ".la": "audio/nspaudio", ".lam": "audio/x-liveaudio", ".latex": "application/x-latex", ".lha": "application/lha", ".lhx": "application/octet-stream", ".list": "text/plain", ".lma": "audio/nspaudio", ".log": "text/plain", ".lsp": "text/x-scriptlisp", ".lst": "text/plain", ".lsx": "text/x-la-asf", ".ltx": "application/x-latex", ".lzh": "application/octet-stream", ".lzx": "application/lzx", ".m1v": "video/mpeg", ".m2a": "audio/mpeg", ".m2v": "video/mpeg", ".m3u": "audio/x-mpegurl", ".m": "text/x-m", ".man": "application/x-troff-man", ".manifest": "text/cache-manifest", ".map": "application/x-navimap", ".mar": "text/plain", ".mbd": "application/mbedlet", ".mc$": "application/x-magic-cap-package-10", ".mcd": "application/mcad", ".mcf": "text/mcf", ".mcp": "application/netmc", ".me": "application/x-troff-me", ".mht": "message/rfc822", ".mhtml": "message/rfc822", ".mid": "application/x-midi", ".midi": "application/x-midi", ".mif": "application/x-frame", ".mime": "message/rfc822", ".mjf": "audio/x-vndaudioexplosionmjuicemediafile", ".mjpg": "video/x-motion-jpeg", ".mm": "application/base64", ".mme": "application/base64", ".mod": "audio/mod", ".moov": "video/quicktime", ".mov": "video/quicktime", ".movie": "video/x-sgi-movie", ".mp2": "audio/mpeg", ".mp3": "audio/mpeg3", ".mp4": "video/mp4", ".mpa": "audio/mpeg", ".mpc": "application/x-project", ".mpe": "video/mpeg", ".mpeg": "video/mpeg", ".mpg": "video/mpeg", ".mpga": "audio/mpeg", ".mpp": "application/vndms-project", ".mpt": "application/x-project", ".mpv": "application/x-project", ".mpx": "application/x-project", ".mrc": "application/marc", ".ms": "application/x-troff-ms", ".mv": "video/x-sgi-movie", ".my": "audio/make", ".mzz": "application/x-vndaudioexplosionmzz", ".nap": "image/naplps", ".naplps": "image/naplps", ".nc": "application/x-netcdf", ".ncm": "application/vndnokiaconfiguration-message", ".nif": "image/x-niff", ".niff": "image/x-niff", ".nix": "application/x-mix-transfer", ".nsc": "application/x-conference", ".nvd": "application/x-navidoc", ".o": "application/octet-stream", ".oda": "application/oda", ".odb": "application/vnd.oasis.opendocument.database", ".odc": "application/vnd.oasis.opendocument.chart", ".odf": "application/vnd.oasis.opendocument.formula", ".odg": "application/vnd.oasis.opendocument.graphics", ".odi": "application/vnd.oasis.opendocument.image", ".odm": "application/vnd.oasis.opendocument.text-master", ".odp": "application/vnd.oasis.opendocument.presentation", ".ods": "application/vnd.oasis.opendocument.spreadsheet", ".odt": "application/vnd.oasis.opendocument.text", ".oga": "audio/ogg", ".ogg": "audio/ogg", ".ogv": "video/ogg", ".omc": "application/x-omc", ".omcd": "application/x-omcdatamaker", ".omcr": "application/x-omcregerator", ".otc": "application/vnd.oasis.opendocument.chart-template", ".otf": "application/vnd.oasis.opendocument.formula-template", ".otg": "application/vnd.oasis.opendocument.graphics-template", ".oth": "application/vnd.oasis.opendocument.text-web", ".oti": "application/vnd.oasis.opendocument.image-template", ".otm": "application/vnd.oasis.opendocument.text-master", ".otp": "application/vnd.oasis.opendocument.presentation-template", ".ots": "application/vnd.oasis.opendocument.spreadsheet-template", ".ott": "application/vnd.oasis.opendocument.text-template", ".p10": "application/pkcs10", ".p12": "application/pkcs-12", ".p7a": "application/x-pkcs7-signature", ".p7c": "application/pkcs7-mime", ".p7m": "application/pkcs7-mime", ".p7r": "application/x-pkcs7-certreqresp", ".p7s": "application/pkcs7-signature", ".p": "text/x-pascal", ".part": "application/pro_eng", ".pas": "text/pascal", ".pbm": "image/x-portable-bitmap", ".pcl": "application/vndhp-pcl", ".pct": "image/x-pict", ".pcx": "image/x-pcx", ".pdb": "chemical/x-pdb", ".pdf": "application/pdf", ".pfunk": "audio/make", ".pgm": "image/x-portable-graymap", ".pic": "image/pict", ".pict": "image/pict", ".pkg": "application/x-newton-compatible-pkg", ".pko": "application/vndms-pkipko", ".pl": "text/x-scriptperl", ".plx": "application/x-pixclscript", ".pm4": "application/x-pagemaker", ".pm5": "application/x-pagemaker", ".pm": "text/x-scriptperl-module", ".png": "image/png", ".pnm": "application/x-portable-anymap", ".pot": "application/mspowerpoint", ".pov": "model/x-pov", ".ppa": "application/vndms-powerpoint", ".ppm": "image/x-portable-pixmap", ".pps": "application/mspowerpoint", ".ppt": "application/mspowerpoint", ".ppz": "application/mspowerpoint", ".pre": "application/x-freelance", ".prt": "application/pro_eng", ".ps": "application/postscript", ".psd": "application/octet-stream", ".pvu": "paleovu/x-pv", ".pwz": "application/vndms-powerpoint", ".py": "text/x-scriptphyton", ".pyc": "application/x-bytecodepython", ".qcp": "audio/vndqcelp", ".qd3": "x-world/x-3dmf", ".qd3d": "x-world/x-3dmf", ".qif": "image/x-quicktime", ".qt": "video/quicktime", ".qtc": "video/x-qtc", ".qti": "image/x-quicktime", ".qtif": "image/x-quicktime", ".ra": "audio/x-pn-realaudio", ".ram": "audio/x-pn-realaudio", ".rar": "application/x-rar-compressed", ".ras": "application/x-cmu-raster", ".rast": "image/cmu-raster", ".rexx": "text/x-scriptrexx", ".rf": "image/vndrn-realflash", ".rgb": "image/x-rgb", ".rm": "application/vndrn-realmedia", ".rmi": "audio/mid", ".rmm": "audio/x-pn-realaudio", ".rmp": "audio/x-pn-realaudio", ".rng": "application/ringing-tones", ".rnx": "application/vndrn-realplayer", ".roff": "application/x-troff", ".rp": "image/vndrn-realpix", ".rpm": "audio/x-pn-realaudio-plugin", ".rt": "text/vndrn-realtext", ".rtf": "text/richtext", ".rtx": "text/richtext", ".rv": "video/vndrn-realvideo", ".s": "text/x-asm", ".s3m": "audio/s3m", ".s7z": "application/x-7z-compressed", ".saveme": "application/octet-stream", ".sbk": "application/x-tbook", ".scm": "text/x-scriptscheme", ".sdml": "text/plain", ".sdp": "application/sdp", ".sdr": "application/sounder", ".sea": "application/sea", ".set": "application/set", ".sgm": "text/x-sgml", ".sgml": "text/x-sgml", ".sh": "text/x-scriptsh", ".shar": "application/x-bsh", ".shtml": "text/x-server-parsed-html", ".sid": "audio/x-psid", ".skd": "application/x-koan", ".skm": "application/x-koan", ".skp": "application/x-koan", ".skt": "application/x-koan", ".sit": "application/x-stuffit", ".sitx": "application/x-stuffitx", ".sl": "application/x-seelogo", ".smi": "application/smil", ".smil": "application/smil", ".snd": "audio/basic", ".sol": "application/solids", ".spc": "text/x-speech", ".spl": "application/futuresplash", ".spr": "application/x-sprite", ".sprite": "application/x-sprite", ".spx": "audio/ogg", ".src": "application/x-wais-source", ".ssi": "text/x-server-parsed-html", ".ssm": "application/streamingmedia", ".sst": "application/vndms-pkicertstore", ".step": "application/step", ".stl": "application/sla", ".stp": "application/step", ".sv4cpio": "application/x-sv4cpio", ".sv4crc": "application/x-sv4crc", ".svf": "image/vnddwg", ".svg": "image/svg+xml", ".svr": "application/x-world", ".swf": "application/x-shockwave-flash", ".t": "application/x-troff", ".talk": "text/x-speech", ".tar": "application/x-tar", ".tbk": "application/toolbook", ".tcl": "text/x-scripttcl", ".tcsh": "text/x-scripttcsh", ".tex": "application/x-tex", ".texi": "application/x-texinfo", ".texinfo": "application/x-texinfo", ".text": "text/plain", ".tgz": "application/gnutar", ".tif": "image/tiff", ".tiff": "image/tiff", ".tr": "application/x-troff", ".tsi": "audio/tsp-audio", ".tsp": "application/dsptype", ".tsv": "text/tab-separated-values", ".turbot": "image/florian", ".txt": "text/plain", ".uil": "text/x-uil", ".uni": "text/uri-list", ".unis": "text/uri-list", ".unv": "application/i-deas", ".uri": "text/uri-list", ".uris": "text/uri-list", ".ustar": "application/x-ustar", ".uu": "text/x-uuencode", ".uue": "text/x-uuencode", ".vcd": "application/x-cdlink", ".vcf": "text/x-vcard", ".vcard": "text/x-vcard", ".vcs": "text/x-vcalendar", ".vda": "application/vda", ".vdo": "video/vdo", ".vew": "application/groupwise", ".viv": "video/vivo", ".vivo": "video/vivo", ".vmd": "application/vocaltec-media-desc", ".vmf": "application/vocaltec-media-file", ".voc": "audio/voc", ".vos": "video/vosaic", ".vox": "audio/voxware", ".vqe": "audio/x-twinvq-plugin", ".vqf": "audio/x-twinvq", ".vql": "audio/x-twinvq-plugin", ".vrml": "application/x-vrml", ".vrt": "x-world/x-vrt", ".vsd": "application/x-visio", ".vst": "application/x-visio", ".vsw": "application/x-visio", ".w60": "application/wordperfect60", ".w61": "application/wordperfect61", ".w6w": "application/msword", ".wav": "audio/wav", ".wb1": "application/x-qpro", ".wbmp": "image/vnd.wap.wbmp", ".web": "application/vndxara", ".wiz": "application/msword", ".wk1": "application/x-123", ".wmf": "windows/metafile", ".wml": "text/vnd.wap.wml", ".wmlc": "application/vnd.wap.wmlc", ".wmls": "text/vnd.wap.wmlscript", ".wmlsc": "application/vnd.wap.wmlscriptc", ".word": "application/msword", ".wp5": "application/wordperfect", ".wp6": "application/wordperfect", ".wp": "application/wordperfect", ".wpd": "application/wordperfect", ".wq1": "application/x-lotus", ".wri": "application/mswrite", ".wrl": "application/x-world", ".wrz": "model/vrml", ".wsc": "text/scriplet", ".wsrc": "application/x-wais-source", ".wtk": "application/x-wintalk", ".x-png": "image/png", ".xbm": "image/x-xbitmap", ".xdr": "video/x-amt-demorun", ".xgz": "xgl/drawing", ".xif": "image/vndxiff", ".xl": "application/excel", ".xla": "application/excel", ".xlb": "application/excel", ".xlc": "application/excel", ".xld": "application/excel", ".xlk": "application/excel", ".xll": "application/excel", ".xlm": "application/excel", ".xls": "application/excel", ".xlt": "application/excel", ".xlv": "application/excel", ".xlw": "application/excel", ".xm": "audio/xm", ".xml": "text/xml", ".xmz": "xgl/movie", ".xpix": "application/x-vndls-xpix", ".xpm": "image/x-xpixmap", ".xsr": "video/x-amt-showrun", ".xwd": "image/x-xwd", ".xyz": "chemical/x-pdb", ".z": "application/x-compress", ".zip": "application/zip", ".zoo": "application/octet-stream", ".zsh": "text/x-scriptzsh", ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document", ".docm": "application/vnd.ms-word.document.macroEnabled.12", ".dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template", ".dotm": "application/vnd.ms-word.template.macroEnabled.12", ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", ".xlsm": "application/vnd.ms-excel.sheet.macroEnabled.12", ".xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template", ".xltm": "application/vnd.ms-excel.template.macroEnabled.12", ".xlsb": "application/vnd.ms-excel.sheet.binary.macroEnabled.12", ".xlam": "application/vnd.ms-excel.addin.macroEnabled.12", ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation", ".pptm": "application/vnd.ms-powerpoint.presentation.macroEnabled.12", ".ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow", ".ppsm": "application/vnd.ms-powerpoint.slideshow.macroEnabled.12", ".potx": "application/vnd.openxmlformats-officedocument.presentationml.template", ".potm": "application/vnd.ms-powerpoint.template.macroEnabled.12", ".ppam": "application/vnd.ms-powerpoint.addin.macroEnabled.12", ".sldx": "application/vnd.openxmlformats-officedocument.presentationml.slide", ".sldm": "application/vnd.ms-powerpoint.slide.macroEnabled.12", ".thmx": "application/vnd.ms-officetheme", ".onetoc": "application/onenote", ".onetoc2": "application/onenote", ".onetmp": "application/onenote", ".onepkg": "application/onenote", ".xpi": "application/x-xpinstall", } func init() { for ext, typ := range types { mime.AddExtensionType(ext, typ) } } // // // // // func TypeByExtension(fullfilename string) string { ext := filepath.Ext(fullfilename) typ := mime.TypeByExtension(ext) if ext == ".js" && (typ == "text/plain" || typ == "text/plain; charset=utf-8") { if ext == ".js" { typ = "application/javascript" } } return typ }
package demo import ( "some/logs" ) var count int func init() { logs.Debug(count) } func Do() { logs.Debug("dd") }
"printfcoder.com/we/models/demo" func someFunc(){ demo.Do() }
var arr [20]byte str := "abc" for k, v := range []byte(str) { arr[k] = byte(v) }
package main import "fmt" func main() { s := "abc" var a [20]byte copy(a[:], s) fmt.Println("s:", []byte(s), "a:", a) }
s: [97 98 99] a: [97 98 99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
var arr [20]byte copy(arr[:], "abc") fmt.Printf("array: %v (%T)\n", arr, arr)
array: [97 98 99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] ([20]uint8)
package main import "fmt" func main() { str := "abc" mySlice := []byte(str) fmt.Printf("%v -> }
package main func main() { var s string b := []byte(s) }
WriteFile func(filename string, data []byte, perm os.FileMode) error
package main import ( "fmt" "strings" ) func main() { stringSlice := []string{"hello", "world"} stringByte := strings.Join(stringSlice, " ") fmt.Println([]byte(stringByte)) fmt.Println(string([]byte(stringByte))) }
s := "hello" b := *(*[]byte)(unsafe.Pointer((*reflect.SliceHeader)(unsafe.Pointer(&s))))
func byte16PutString(s string) [16]byte { var a [16]byte if len(s) > 16 { copy(a[:], s) } else { copy(a[16-len(s):], s) } return a } var b [16]byte b = byte16PutString("abc") fmt.Printf("%v\n", b)
buf := make([]byte, 10) var arr [10]byte copy(arr[:], buf)
func (file *File) Read(b []byte) (n int, err Error)
package main import ( "io" "os" ) func main() { fi, err := os.Open("input.txt") if err != nil { panic(err) } defer func() { if err := fi.Close(); err != nil { panic(err) } }() fo, err := os.Create("output.txt") if err != nil { panic(err) } defer func() { if err := fo.Close(); err != nil { panic(err) } }() buf := make([]byte, 1024) for { n, err := fi.Read(buf) if err != nil && err != io.EOF { panic(err) } if n == 0 { break } if _, err := fo.Write(buf[:n]); err != nil { panic(err) } } }
package main import ( "bufio" "io" "os" ) func main() { fi, err := os.Open("input.txt") if err != nil { panic(err) } defer func() { if err := fi.Close(); err != nil { panic(err) } }() r := bufio.NewReader(fi) fo, err := os.Create("output.txt") if err != nil { panic(err) } defer func() { if err := fo.Close(); err != nil { panic(err) } }() w := bufio.NewWriter(fo) buf := make([]byte, 1024) for { n, err := r.Read(buf) if err != nil && err != io.EOF { panic(err) } if n == 0 { break } if _, err := w.Write(buf[:n]); err != nil { panic(err) } } if err = w.Flush(); err != nil { panic(err) } }
package main import ( "io/ioutil" ) func main() { b, err := ioutil.ReadFile("input.txt") if err != nil { panic(err) } err = ioutil.WriteFile("output.txt", b, 0644) if err != nil { panic(err) } }
package main import ( "io/ioutil"; ) func main() { contents,_ := ioutil.ReadFile("plikTekstowy.txt") println(string(contents)) ioutil.WriteFile("filename", contents, 0644) }
package main import ( "io" "log" "os" ) func main () { r, err := os.Open("input.txt") if err != nil { panic(err) } defer r.Close() w, err := os.Create("output.txt") if err != nil { panic(err) } defer w.Close() n, err := io.Copy(w, r) if err != nil { panic(err) } log.Printf("Copied %v bytes\n", n) }
package main import ( "fmt"; "os"; ) func main() { inName := "file-rw.bin"; inPerm := 0666; inFile, inErr := os.Open(inName, os.O_RDONLY, inPerm); if inErr == nil { inBufLen := 16; inBuf := make([]byte, inBufLen); n, inErr := inFile.Read(inBuf); for inErr == nil { fmt.Println(n, inBuf[0:n]); n, inErr = inFile.Read(inBuf); } } inErr = inFile.Close(); }
package main import ( "fmt" "io/ioutil" ) func main() { data, err := ioutil.ReadFile("text.txt") if err != nil { return } fmt.Println(string(data)) }
package main import "os" func main() { file, err := os.Create("text.txt") if err != nil { return } defer file.Close() file.WriteString("test\nhello") }
package main import ( "io"; ) func main() { contents,_ := io.ReadFile("filename"); println(string(contents)); io.WriteFile("filename", contents, 0644); }
{ "Users": ["UserA","UserB"], "Groups": ["GroupA"] }
import ( "encoding/json" "os" "fmt" ) type Configuration struct { Users []string Groups []string } file, _ := os.Open("conf.json") defer file.Close() decoder := json.NewDecoder(file) configuration := Configuration{} err := decoder.Decode(&configuration) if err != nil { fmt.Println("error:", err) } fmt.Println(configuration.Users)
Age = 198 Cats = [ "Cauchy", "Plato" ] Pi = 3.14 Perfection = [ 6, 28, 496, 8128 ] DOB = 1987-07-05T05:45:00Z
type Config struct { Age int Cats []string Pi float64 Perfection []int DOB time.Time } var conf Config if _, err := toml.DecodeFile("something.toml", &conf); err != nil { }
type Config struct { Section struct { Name string Flag bool } }
var cfg Config err := gcfg.ReadFileInto(&cfg, "myconfig.gcfg")
package util import ( "code.google.com/p/gcfg" ) type Config struct { Port int Verbose bool AccessLog string ErrorLog string DbDriver string DbConnection string DbTblPrefix string } type configFile struct { Server Config } const defaultConfig = ` [server] port = 8000 verbose = false accessLog = - errorLog = - dbDriver = mysql dbConnection = testuser:TestPasswd9@/test dbTblPrefix = ` func LoadConfiguration(cfgFile string, port int, verbose bool) Config { var err error var cfg configFile if cfgFile != "" { err = gcfg.ReadFileInto(&cfg, cfgFile) } else { err = gcfg.ReadStringInto(&cfg, defaultConfig) } PanicOnError(err) if port != 0 { cfg.Server.Port = port } if verbose { cfg.Server.Verbose = true } return cfg.Server }
config, _ := gonfig.FromJson(myJsonFile) host, _ := config.GetString("service/host", "localhost") port, _ := config.GetInt("service/port", 80) test, _ := config.GetBool("service/testing", false) rate, _ := config.GetFloat("service/rate", 0.0) config.GetAs("service/template", &template)
package cfg import ( "testing" ) func TestCfg(t *testing.T) { c := NewCfg("test.ini") if err := c.Load() ; err != nil { t.Error(err) } c.WriteInt("hello", 42) c.WriteString("hello1", "World") v, err := c.ReadInt("hello", 0) if err != nil || v != 42 { t.Error(err) } v1, err := c.ReadString("hello1", "") if err != nil || v1 != "World" { t.Error(err) } if err := c.Save(); err != nil { t.Error(err) } }
package main import ( "log" "github.com/c4pt0r/ini" ) var conf = ini.NewConf("test.ini") var ( v1 = conf.String("section1", "field1", "v1") v2 = conf.Int("section1", "field2", 0) ) func main() { conf.Parse() log.Println(*v1, *v2) }
m := map[string]string{ "key1":"val1", "key2":"val2" };
for k, v := range m { fmt.Printf("key[%s] value[%s]\n", k, v) }
for k := range m { fmt.Printf("key[%s] value[%s]\n", k, m[k]) }
func Keys(m map[string]interface{}) (keys []string) { for k := range m { keys = append(keys, k) } return keys } func main() { m := map[string]interface{}{ "foo": 1, "bar": true, "baz": "baz", } fmt.Println(Keys(m)) }
goinstall: os: go/build: package could not be found locally goinstall: fmt: go/build: package could not be found locally goinstall: io: go/build: package could not be found locally goinstall: reflect: go/build: package could not be found locally goinstall: math: go/build: package could not be found locally goinstall: rand: go/build: package could not be found locally goinstall: url: go/build: package could not be found locally goinstall: net: go/build: package could not be found locally goinstall: sync: go/build: package could not be found locally goinstall: runtime: go/build: package could not be found locally goinstall: strings: go/build: package could not be found locally goinstall: sort: go/build: package could not be found locally goinstall: strconv: go/build: package could not be found locally goinstall: bytes: go/build: package could not be found locally goinstall: log: go/build: package could not be found locally goinstall: encoding/binary: go/build: package could not be found locally
export GOROOT=$HOME/go export PATH=$PATH:$GOROOT/bin
directory for go related things: ~/programming/go directory for go compiler/tools: ~/programming/go/go-1.4 directory for go software : ~/programming/go/packages
export GOROOT=/home/user/programming/go/go-1.4 export GOPATH=/home/user/programming/go/packages export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
GOPATH="$HOME/my_go_work_space" GOROOT="/usr/local/Cellar/go/1.10/libexec"
$ rpm -ql golang | grep include /usr/lib/golang/include
type MyStruct struct { Val int } func myfunc() MyStruct { return MyStruct{Val: 1} } func myfunc() *MyStruct { return &MyStruct{} } func myfunc(s *MyStruct) { s.Val = 1 }
func myfunc() []MyStruct { return []MyStruct{ MyStruct{Val: 1} } } func myfunc() []*MyStruct { return []MyStruct{ &MyStruct{Val: 1} } } func myfunc(s *[]MyStruct) { *s = []MyStruct{ MyStruct{Val: 1} } } func myfunc(s *[]*MyStruct) { *s = []MyStruct{ &MyStruct{Val: 1} } }
package main import ( "bufio" "fmt" "log" "os" ) func main() { file, err := os.Open("/path/to/file.txt") if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } if err := scanner.Err(); err != nil { log.Fatal(err) } }
package main import ( "bufio" "bytes" "fmt" "io" "os" ) func readFileWithReadString(fn string) (err error) { fmt.Println("readFileWithReadString") file, err := os.Open(fn) defer file.Close() if err != nil { return err } reader := bufio.NewReader(file) var line string for { line, err = reader.ReadString( fmt.Printf(" > Read %d characters\n", len(line)) fmt.Println(" > > " + limitLength(line, 50)) if err != nil { break } } if err != io.EOF { fmt.Printf(" > Failed!: %v\n", err) } return } func readFileWithScanner(fn string) (err error) { fmt.Println("readFileWithScanner - this will fail!") file, err := os.Open(fn) defer file.Close() if err != nil { return err } scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Text() fmt.Printf(" > Read %d characters\n", len(line)) fmt.Println(" > > " + limitLength(line, 50)) } if scanner.Err() != nil { fmt.Printf(" > Failed!: %v\n", scanner.Err()) } return } func readFileWithReadLine(fn string) (err error) { fmt.Println("readFileWithReadLine") file, err := os.Open(fn) defer file.Close() if err != nil { return err } reader := bufio.NewReader(file) for { var buffer bytes.Buffer var l []byte var isPrefix bool for { l, isPrefix, err = reader.ReadLine() buffer.Write(l) if !isPrefix { break } if err != nil { break } } if err == io.EOF { break } line := buffer.String() fmt.Printf(" > Read %d characters\n", len(line)) fmt.Println(" > > " + limitLength(line, 50)) } if err != io.EOF { fmt.Printf(" > Failed!: %v\n", err) } return } func main() { testLongLines() testLinesThatDoNotFinishWithALinebreak() } func testLongLines() { fmt.Println("Long lines") fmt.Println() createFileWithLongLine("longline.txt") readFileWithReadString("longline.txt") fmt.Println() readFileWithScanner("longline.txt") fmt.Println() readFileWithReadLine("longline.txt") fmt.Println() } func testLinesThatDoNotFinishWithALinebreak() { fmt.Println("No linebreak") fmt.Println() createFileThatDoesNotEndWithALineBreak("nolinebreak.txt") readFileWithReadString("nolinebreak.txt") fmt.Println() readFileWithScanner("nolinebreak.txt") fmt.Println() readFileWithReadLine("nolinebreak.txt") fmt.Println() } func createFileThatDoesNotEndWithALineBreak(fn string) (err error) { file, err := os.Create(fn) defer file.Close() if err != nil { return err } w := bufio.NewWriter(file) w.WriteString("Does not end with linebreak.") w.Flush() return } func createFileWithLongLine(fn string) (err error) { file, err := os.Create(fn) defer file.Close() if err != nil { return err } w := bufio.NewWriter(file) fs := 1024 * 1024 * 4 for i := 0; i < fs; i++ { w.WriteRune( } w.WriteRune( w.WriteString("Second line.") w.Flush() return } func limitLength(s string, length int) string { if len(s) < length { return s } return s[:length] }
Long lines readFileWithReadString > Read 4194305 characters > > aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa > Read 12 characters > > Second line. readFileWithScanner - this will fail! > Failed!: bufio.Scanner: token too long readFileWithReadLine > Read 4194304 characters > > aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa > Read 12 characters > > Second line. No linebreak readFileWithReadString > Read 28 characters > > Does not end with linebreak. readFileWithScanner - this will fail! > Read 28 characters > > Does not end with linebreak. readFileWithReadLine > Read 28 characters > > Does not end with linebreak.
func Readln(r *bufio.Reader) (string, error) { var (isPrefix bool = true err error = nil line, ln []byte ) for isPrefix && err == nil { line, isPrefix, err = r.ReadLine() ln = append(ln, line...) } return string(ln),err }
f, err := os.Open(fi) if err != nil { fmt.Printf("error opening file: %v\n",err) os.Exit(1) } r := bufio.NewReader(f) s, e := Readln(r) for e == nil { fmt.Println(s) s,e = Readln(r) }
func scanFile() { f, err := os.OpenFile(logfile, os.O_RDONLY, os.ModePerm) if err != nil { log.Fatalf("open file error: %v", err) return } defer f.Close() sc := bufio.NewScanner(f) for sc.Scan() { _ = sc.Text() } if err := sc.Err(); err != nil { log.Fatalf("scan file error: %v", err) return } }
func readFileLines() { f, err := os.OpenFile(logfile, os.O_RDONLY, os.ModePerm) if err != nil { log.Fatalf("open file error: %v", err) return } defer f.Close() rd := bufio.NewReader(f) for { line, err := rd.ReadString( if err != nil { if err == io.EOF { break } log.Fatalf("read file line error: %v", err) return } _ = line } }
f, err := os.Open(filename) if err != nil { fmt.Println("error opening file ", err) os.Exit(1) } defer f.Close() r := bufio.NewReader(f) for { path, err := r.ReadString(10) if err == io.EOF { break } else if err != nil { return err } }
func readLine(path string) { inFile, err := os.Open(path) if err != nil { fmt.Println(err.Error() + `: ` + path) return } else { defer inFile.Close() } scanner := bufio.NewScanner(inFile) scanner.Split(bufio.ScanLines) for scanner.Scan() { fmt.Println(scanner.Text()) } }
func readline(reader io.Reader) (line []byte, err error) { line = make([]byte, 0, 100) for { b := make([]byte, 1) n, er := reader.Read(b) if n > 0 { c := b[0] if c == break } line = append(line, c) } if er != nil { err = er return } } return }
interests := make([]string, 1) r := bufio.NewReader(os.Stdin) for true { fmt.Print("Give me an interest:") t, _, _ := r.ReadLine() interests = append(interests, string(t)) if len(t) == 0 { break; } } fmt.Println(interests)
import ( "bufio" "os" ) var ( reader = bufio.NewReader(os.Stdin) ) func ReadFromStdin() string{ result, _ := reader.ReadString( witl := result[:len(result)-1] return witl }
package main import ( "bufio" "fmt" "io" "os" ) func main() { f, err := os.Open("archiveName") if err != nil { fmt.Println(err) os.Exit(1) } defer f.Close() r := bufio.NewReader(f) line, err := r.ReadString(10) for err != io.EOF { fmt.Print(line) line, err = r.ReadString(10) } }
type Project struct { Id int64 `json:"project_id"` Title string `json:"title"` Name string `json:"name"` Data Data `json:"data"` Commits Commits `json:"commits"` }
type Response2 struct { Page int `json:"page"` Fruits []string `json:"fruits"` } res2D := &Response2{ Page: 1, Fruits: []string{"apple", "peach", "pear"}} res2B, _ := json.Marshal(res2D) fmt.Println(string(res2B))
type T struct { A int B string } t := T{23, "skidoo"} s := reflect.ValueOf(&t).Elem() typeOfT := s.Type() for i := 0; i < s.NumField(); i++ { f := s.Field(i) fmt.Printf("%d: %s %s = %v\n", i, typeOfT.Field(i).Name, f.Type(), f.Interface()) }
package main import ( "github.com/davecgh/go-spew/spew" ) type Project struct { Id int64 `json:"project_id"` Title string `json:"title"` Name string `json:"name"` Data string `json:"data"` Commits string `json:"commits"` } func main() { o := Project{Name: "hello", Title: "world"} spew.Dump(o) }
(main.Project) { Id: (int64) 0, Title: (string) (len=5) "world", Name: (string) (len=5) "hello", Data: (string) "", Commits: (string) "" }
func prettyPrint(i interface{}) string { s, _ := json.MarshalIndent(i, "", "\t") return string(s) }
package main import "fmt" type Project struct { Id int64 `json:"project_id"` Title string `json:"title"` Name string `json:"name"` } func (p Project) String() string { return fmt.Sprintf("{Id:%d, Title:%s, Name:%s}", p.Id, p.Title, p.Name) } func main() { o := Project{Id: 4, Name: "hello", Title: "world"} fmt.Printf("%+v\n", o) }
p = Project{...} fmt.Printf("%+v", p) fmt.Printf("%
package main import "fmt" import "reflect" func main() { type Book struct { Id int Name string Title string } book := Book{1, "Let us C", "Enjoy programming with practice"} e := reflect.ValueOf(&book).Elem() for i := 0; i < e.NumField(); i++ { fieldName := e.Type().Field(i).Name fmt.Printf("%v\n", fieldName) } }
type Person struct { Name string Age int Parent *Person } litter.Dump(Person{ Name: "Bob", Age: 20, Parent: &Person{ Name: "Jane", Age: 50, }, })
func TestSearch(t *testing.T) { result := DoSearch() actual := litterOpts.Sdump(result) expected, err := ioutil.ReadFile("testdata.txt") if err != nil { if !os.IsNotExist(err) { t.Error(err) } ioutil.Write("testdata.txt", actual, 0644) actual = expected } if expected != actual { t.Errorf("Expected %s, got %s", expected, actual) } }
type customType int type testStruct struct { S string V *map[string]int I interface{} } a := testStruct{ S: "hello", V: &map[string]int{"foo": 0, "bar": 1}, I: customType(42), } fmt.Println("Render test:") fmt.Printf("fmt.Printf: % fmt.Printf("render.Render: %s\n", Render(a))
fmt.Printf: render.testStruct{S:"hello", V:(*map[string]int)(0x600dd065), I:42} render.Render: render.testStruct{S:"hello", V:(*map[string]int){"bar":1, "foo":0}, I:render.customType(42)}
package main import ( fmt github.com/kr/pretty ) func main(){ type Project struct { Id int64 `json:"project_id"` Title string `json:"title"` Name string `json:"name"` Data Data `json:"data"` Commits Commits `json:"commits"` } fmt.Printf("% fmt.Printf("% }
import ( "fmt" ) type T struct { x, y string } func (r T) toString() string { return "Formate as u need :" + r.x + r.y } func main() { r1 := T{"csa", "ac"} fmt.Println("toStringed : ", r1.toString()) }
data, err := json.Marshal(myComplexStruct) fmt.Printf("%s\n", data)
const STRUCTURE_DATA_FMT = "%+v" fmt.Println(commons.STRUCTURE_DATA_FMT, structure variable)
~/projects/ bin/ pkg/ src/ mypack/ foo.go bar.go mypack_test.go
~/projects/src/ myproj/ mypack/ lib.go lib_test.go ... myapp/ main.go
myproj/ main/ mypack.go myextras/ someextra.go mypack.go mysupport.go
myproj.org/ lib/ mysupport.go myextras/ someextra.go main/ mypack.go mypage.go
~/projects/ bin/ pkg/ src/ github.com/ username/ mypack/ foo.go bar.go mypack_test.go mylib/ utillib.go utillib_test.go
~/$GOPATH/ bin/ pkg/ src/ repository_remote/ user_name/ project_name/ internal/ other_pkg/
~/$GOPATH/ bin/ pkg/ src/ repository_remote/ user_name/ project_name/ cmd/ binary_one/ main.go binary_two/ main.go binary_three/ main.go other_pkg/
package github.com/go-sql-driver/mysql: cannot download, $GOPATH not set. For more details see: go help gopath
ubuntu@ip-xxx-x-xx-x:~$ go env GOARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="linux" GOOS="linux" GOPATH="" GORACE="" GOROOT="/usr/lib/go" GOTOOLDIR="/usr/lib/go/pkg/tool/linux_amd64" CC="gcc" GOGCCFLAGS="-g -O2 -fPIC -m64 -pthread" CGO_ENABLED="1"
export GOPATH=$HOME/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
mkdir ~/.go echo "GOPATH=$HOME/.go" >> ~/.bashrc echo "export GOPATH" >> ~/.bashrc echo "PATH=\$PATH:\$GOPATH/bin source ~/.bashrc
export GOROOT=/usr/lib/go export GOPATH=$HOME/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
export PATH=path/to/some/other/place/composer/for/example export GOPATH=path/to/your/gopath/directory export PATH=$PATH:$GOPATH/bin
set -g -x PATH /usr/local/bin $PATH set -g -x GOPATH /usr/share/go
$go env GOARCH="amd64" GOBIN="" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="linux" GOOS="linux" GOPATH="" GORACE="" GOROOT="/usr/lib/go-1.6" GOTOOLDIR="/usr/lib/go-1.6/pkg/tool/linux_amd64" GO15VENDOREXPERIMENT="1" CC="gcc" GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0" CXX="g++" CGO_ENABLED="1"
export GOPATH=/usr/lib/go export PATH=$PATH:$GOPATH/bin
mkdir ~/go export GOPATH=~/go go get github.com/go-sql-driver/mysql
GOPATH=/path/to/a/directory/inside/home/directory GOROOT=/path/to/you/go/library PATH=$PATH:$GOPATH:$GOROOT:$GOROOT/bin
...$ ...$ ***Story continues in vi editor*** GOROOT=$GOROOT:/usr/local/go GOPATH=$GOPATH:/usr/local/go/src ... [your regular PATH stuff here] ...
GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="linux" GOOS="linux" GOPATH="/usr/local/go/src" GORACE="" GOROOT="/usr/local/go"
export GOROOT=/usr/lib/golang export GOPATH=$HOME/go export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
$ cd /path/to/your/download/directory $ tar -xvf gost_linux_amd64.tar.gz
gost goCommand [-p {pathName}] -- [goFlags...] [goArgs...]
$ gost get -p foo -- github.com/go-sql-driver/mysql
func init() { rand.Seed(time.Now().UnixNano()) } var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") func RandStringRunes(n int) string { b := make([]rune, n) for i := range b { b[i] = letterRunes[rand.Intn(len(letterRunes))] } return string(b) }
var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
var letters = []bytes("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" func RandStringBytes(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) }
func RandStringBytesRmndr(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Int63() % int64(len(letterBytes))] } return string(b) }
const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" const ( letterIdxBits = 6 letterIdxMask = 1<<letterIdxBits - 1 ) func RandStringBytesMask(n int) string { b := make([]byte, n) for i := 0; i < n; { if idx := int(rand.Int63() & letterIdxMask); idx < len(letterBytes) { b[i] = letterBytes[idx] i++ } } return string(b) }
const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" const ( letterIdxBits = 6 letterIdxMask = 1<<letterIdxBits - 1 letterIdxMax = 63 / letterIdxBits ) func RandStringBytesMaskImpr(n int) string { b := make([]byte, n) for i, cache, remain := n-1, rand.Int63(), letterIdxMax; i >= 0; { if remain == 0 { cache, remain = rand.Int63(), letterIdxMax } if idx := int(cache & letterIdxMask); idx < len(letterBytes) { b[i] = letterBytes[idx] i-- } cache >>= letterIdxBits remain-- } return string(b) }
var src = rand.NewSource(time.Now().UnixNano()) func RandStringBytesMaskImprSrc(n int) string { b := make([]byte, n) for i, cache, remain := n-1, src.Int63(), letterIdxMax; i >= 0; { if remain == 0 { cache, remain = src.Int63(), letterIdxMax } if idx := int(cache & letterIdxMask); idx < len(letterBytes) { b[i] = letterBytes[idx] i-- } cache >>= letterIdxBits remain-- } return string(b) }
BenchmarkRunes 1000000 1703 ns/op BenchmarkBytes 1000000 1328 ns/op BenchmarkBytesRmndr 1000000 1012 ns/op BenchmarkBytesMask 1000000 1214 ns/op BenchmarkBytesMaskImpr 5000000 395 ns/op BenchmarkBytesMaskImprSrc 5000000 303 ns/op
package main import ( "fmt" "time" "math/rand" ) func init() { rand.Seed(time.Now().UnixNano()) } var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") func randSeq(n int) string { b := make([]rune, n) for i := range b { b[i] = letters[rand.Intn(len(letters))] } return string(b) } func main() { fmt.Println(randSeq(10)) }
const ( letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" letterIdxBits = 6 letterIdxMask = 1<<letterIdxBits - 1 ) func SecureRandomAlphaString(length int) string { result := make([]byte, length) bufferSize := int(float64(length)*1.3) for i, j, randomBytes := 0, 0, []byte{}; i < length; j++ { if j%bufferSize == 0 { randomBytes = SecureRandomBytes(bufferSize) } if idx := int(randomBytes[j%length] & letterIdxMask); idx < len(letterBytes) { result[i] = letterBytes[idx] i++ } } return string(result) } func SecureRandomBytes(length int) []byte { var randomBytes = make([]byte, length) _, err := rand.Read(randomBytes) if err != nil { log.Fatal("Unable to generate random bytes") } return randomBytes }
func SecureRandomString(availableCharBytes string, length int) string { availableCharLength := len(availableCharBytes) if availableCharLength == 0 || availableCharLength > 256 { panic("availableCharBytes length must be greater than 0 and less than or equal to 256") } var bitLength byte var bitMask byte for bits := availableCharLength - 1; bits != 0; { bits = bits >> 1 bitLength++ } bitMask = 1<<bitLength - 1 bufferSize := length + length / 3 result := make([]byte, length) for i, j, randomBytes := 0, 0, []byte{}; i < length; j++ { if j%bufferSize == 0 { randomBytes = SecureRandomBytes(bufferSize) } if idx := int(randomBytes[j%length] & bitMask); idx < availableCharLength { result[i] = availableCharBytes[idx] i++ } } return string(result) }
func randStr(len int) string { buff := make([]byte, len) rand.Read(buff) str := base64.StdEncoding.EncodeToString(buff) return str[:len] }
const encodeURL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" func RandAsciiBytes(n int) []byte { output := make([]byte, n) randomness := make([]byte, n) _, err := rand.Read(randomness) if err != nil { panic(err) } for pos := range output { random := uint8(randomness[pos]) randomPos := random % uint8(len(encodeURL)) output[pos] = encodeURL[randomPos] } return output }
package main import ( "bufio" "fmt" "os" ) func main() { reader := bufio.NewReader(os.Stdin) fmt.Print("Enter text: ") text, _ := reader.ReadString( fmt.Println(text) fmt.Println("Enter text: ") text2 := "" fmt.Scanln(text2) fmt.Println(text2) ln := "" fmt.Sscanln("%v", ln) fmt.Println(ln) }
reader := bufio.NewReader(os.Stdin) fmt.Print("Enter text: ") text, _ := reader.ReadString( fmt.Println(text)
scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Println(scanner.Text()) } if scanner.Err() != nil { }
package main import "fmt" func main() { fmt.Print("Enter text: ") var input string fmt.Scanln(&input) fmt.Print(input) }
package main import ( "fmt" "bufio" "os" ) func main() { scanner := bufio.NewScanner(os.Stdin) var text string for text != "q" { fmt.Print("Enter your text: ") scanner.Scan() text = scanner.Text() if text != "q" { fmt.Println("Your text was: ", text) } } }
Enter your text: Hello world! Your text was: Hello world! Enter your text: Go is awesome! Your text was: Go is awesome! Enter your text: q
package main import ( "bufio" "fmt" "os" ) /* Three ways of taking input 1. fmt.Scanln(&input) 2. reader.ReadString() 3. scanner.Scan() Here we recommend using bufio.NewScanner */ func main() { arr := make([]string, 0) scanner := bufio.NewScanner(os.Stdin) for { fmt.Print("Enter Text: ") scanner.Scan() text := scanner.Text() if len(text) != 0 { fmt.Println(text) arr = append(arr, text) } else { break } } fmt.Println(arr) }
scanner := bufio.NewScanner(os.Stdin) scanner.Scan() text := scanner.Text() fmt.Println(text)
Enter Text: Bob Bob Enter Text: Alice Alice Enter Text: [Bob Alice]
var input string func main() { fmt.Print("Enter Your Name=") fmt.Scanf("%s",&input) fmt.Println("Hello "+input) }
reader := bufio.NewReader(os.Stdin) fmt.Print("Enter text: ") text, _ := reader.ReadString( fmt.Print("Enter More text: ") text2, _ := reader.ReadString( fmt.Printf("Text1: \"%s\", Text2: \"%s\"\n", strings.TrimSpace(text), strings.TrimSpace(text2))
Enter text: Jim Enter More text: Susie Text1: "Jim", Text2: "Susie"
func stringInSlice(a string, list []string) bool { for _, b := range list { if b == a { return true } } return false }
visitedURL := map[string]bool { "http: "https: } if visitedURL[thisSite] { fmt.Println("Already been here.") }
func IsValidCategory(category string) bool { switch category { case "auto", "news", "sport", "music": return true } return false }
files := []string{"Test.conf", "util.go", "Makefile", "misc.go", "main.go"} target := "Makefile" sort.Strings(files) i := sort.Search(len(files), func(i int) bool { return files[i] >= target }) if i < len(files) && files[i] == target { fmt.Printf("found \"%s\" at files[%d]\n", files[i], i) }
files := []string{"Test.conf", "util.go", "Makefile", "misc.go", "main.go"} target := "Makefile" sort.Strings(files) i := sort.SearchStrings(files, target) if i < len(files) && files[i] == target { fmt.Printf("found \"%s\" at files[%d]\n", files[i], i) }
func belongsToMap(lookup string) bool { list := map[string]bool{ "900898296857": true, "900898302052": true, "900898296492": true, "900898296850": true, "900898296703": true, "900898296633": true, "900898296613": true, "900898296615": true, "900898296620": true, "900898296636": true, } if _, ok := list[lookup]; ok { return true } else { return false } } func belongsToList(lookup string) bool { list := []string{ "900898296857", "900898302052", "900898296492", "900898296850", "900898296703", "900898296633", "900898296613", "900898296615", "900898296620", "900898296636", } for _, val := range list { if val == lookup { return true } } return false } func belongsToSwitch(lookup string) bool { switch lookup { case "900898296857", "900898302052", "900898296492", "900898296850", "900898296703", "900898296633", "900898296613", "900898296615", "900898296620", "900898296636": return true } return false }
package main import ( "fmt" "math/rand" ) func main() { var MAX int = 10 m := make(map[int]bool) for i := 0; i <= MAX; i++ { m[rand.Intn(MAX)] = true } for i := 0; i <= MAX; i++ { if _, ok := m[i]; ok { fmt.Printf("%v is in map\n", i) } else { fmt.Printf("%v is not in map\n", i) } } }
func testEq(a, b []Type) bool { if (a == nil) != (b == nil) { return false; } if len(a) != len(b) { return false } for i := range a { if a[i] != b[i] { return false } } return true }
package main import ( "fmt" "reflect" ) func main() { a := []int {4,5,6} b := []int {4,5,6} c := []int {4,5,6,7} fmt.Println(reflect.DeepEqual(a, b)) fmt.Println(reflect.DeepEqual(a, c)) }
package main import ( "fmt" "bytes" ) func main() { a := []byte {1,2,3} b := []byte {1,2,3} c := []byte {1,2,2} fmt.Println(bytes.Equal(a, b)) fmt.Println(bytes.Equal(a, c)) }
package main import ( "encoding/json" "log" "net/http" ) type test_struct struct { Test string } func test(rw http.ResponseWriter, req *http.Request) { req.ParseForm() log.Println(req.Form) var t test_struct for key, _ := range req.Form { log.Println(key) err := json.Unmarshal([]byte(key), &t) if err != nil { log.Println(err.Error()) } } log.Println(t.Test) } func main() { http.HandleFunc("/test", test) log.Fatal(http.ListenAndServe(":8082", nil)) }
func test(rw http.ResponseWriter, req *http.Request) { decoder := json.NewDecoder(req.Body) var t test_struct err := decoder.Decode(&t) if err != nil { panic(err) } log.Println(t.Test) }
package main import ( "encoding/json" "log" "net/http" "io/ioutil" ) type test_struct struct { Test string } func test(rw http.ResponseWriter, req *http.Request) { body, err := ioutil.ReadAll(req.Body) if err != nil { panic(err) } log.Println(string(body)) var t test_struct err = json.Unmarshal(body, &t) if err != nil { panic(err) } log.Println(t.Test) } func main() { http.HandleFunc("/test", test) log.Fatal(http.ListenAndServe(":8082", nil)) }
package main import ( "encoding/json" "fmt" "io" "log" "strings" ) func main() { const jsonStream = ` {"Name": "Ed", "Text": "Knock knock."} {"Name": "Sam", "Text": "Who {"Name": "Ed", "Text": "Go fmt."} {"Name": "Sam", "Text": "Go fmt who?"} {"Name": "Ed", "Text": "Go fmt yourself!"} ` type Message struct { Name, Text string } dec := json.NewDecoder(strings.NewReader(jsonStream)) for { var m Message if err := dec.Decode(&m); err == io.EOF { break } else if err != nil { log.Fatal(err) } fmt.Printf("%s: %s\n", m.Name, m.Text) } }
func test(rw http.ResponseWriter, req *http.Request) { dec := json.NewDecoder(req.Body) for { var t test_struct if err := dec.Decode(&t); err == io.EOF { break } else if err != nil { log.Fatal(err) } log.Printf("%s\n", t.Test) } }
type test_struct struct { Test string `json:"test"` SomeKey string `json:"some-key"` }
package main func main() { var a int a = 0 } notused.go:3: a declared and not used
var index int if val > 0 { index = val } else { index = -val }
func min(a, b int) int { if a <= b { return a } return b } ... value := min(a, b)
a := func() int { if test { return 1 } else { return 2 } }()
func Ternary(statement bool, a, b interface{}) interface{} { if statement { return a } return b } func Abs(n int) int { return Ternary(n >= 0, n, -n).(int) }
index := func() int { if val > 0 { return printPositiveAndReturn(val) } else { return slowlyReturn(-val) } }();
index := printPositiveAndReturn(val); if val <= 0 { index = slowlyReturn(-val); }
var index int if val > 0 { index = printPositiveAndReturn(val) } else { index = slowlyReturn(-val) }
package main import ( "flag" "fmt" "os" "strconv" ) func main() { flag.Parse() s := flag.Arg(0) i, err := strconv.Atoi(s) if err != nil { fmt.Println(err) os.Exit(2) } fmt.Println(s, i) }
flag.Parse() s := flag.Arg(0) if i, err := strconv.Atoi(s); err == nil { fmt.Printf("i=%d, type: %T\n", i, i) } if i, err := strconv.ParseInt(s, 10, 64); err == nil { fmt.Printf("i=%d, type: %T\n", i, i) } var i int if _, err := fmt.Sscan(s, &i); err == nil { fmt.Printf("i=%d, type: %T\n", i, i) }
i=123, type: int i=123, type: int64 i=123, type: int
s := "id:00123" var i int if _, err := fmt.Sscanf(s, "id:%5d", &i); err == nil { fmt.Println(i) }
package main import "fmt" import "strconv" import "testing" var num = 123456 var numstr = "123456" func BenchmarkStrconvParseInt(b *testing.B) { num64 := int64(num) for i := 0; i < b.N; i++ { x, err := strconv.ParseInt(numstr, 10, 64) if x != num64 || err != nil { b.Error(err) } } } func BenchmarkAtoi(b *testing.B) { for i := 0; i < b.N; i++ { x, err := strconv.Atoi(numstr) if x != num || err != nil { b.Error(err) } } } func BenchmarkFmtSscan(b *testing.B) { for i := 0; i < b.N; i++ { var x int n, err := fmt.Sscanf(numstr, "%d", &x) if n != 1 || x != num || err != nil { b.Error(err) } } }
package main import ( "testing" "strconv" ) func Atoi (s string) int { var ( n uint64 i int v byte ) for ; i < len(s); i++ { d := s[i] if v = d - } else if v = d - } else if v = d - } else { n = 0; break } n *= uint64(10) n += uint64(v) } return int(n) } func BenchmarkAtoi(b *testing.B) { for i := 0; i < b.N; i++ { in := Atoi("9999") _ = in } } func BenchmarkStrconvAtoi(b *testing.B) { for i := 0; i < b.N; i++ { in, _ := strconv.Atoi("9999") _ = in } }
Path>go test -bench=. atoi_test.go goos: windows goarch: amd64 BenchmarkAtoi-2 100000000 14.6 ns/op BenchmarkStrconvAtoi-2 30000000 51.2 ns/op PASS ok path 3.293s
foo, bar := someFunc() foo, jazz := someFunc() baz, foo := someFunc()
var foo int = 34 func some() { foo := 42 foo = 314 }
var i int var U, V, W float64 var k = 0 var x, y float32 = -1, -2 i, j := 0, 10 f := func() int { return 7 } ch := make(chan int)
yourTime := rand.Int31n(1000) time.Sleep(time.Duration(yourTime) * time.Millisecond)
time.Duration(int64(time.Millisecond) * int64(rand.Int31n(1000)))
time.Duration(rand.Int31n(1000)) * time.Millisecond
numberOfMilliseconds := 100 someLHS := time.Duration(numberOfMilliseconds) fmt.Println(someLHS) fmt.Println(someLHS*time.Millisecond)
_, filename, _, _ := runtime.Caller(1) f, err := os.Open(path.Join(path.Dir(filename), "data.csv"))
import ( "fmt" "log" "os" "path/filepath" ) func main() { dir, err := filepath.Abs(filepath.Dir(os.Args[0])) if err != nil { log.Fatal(err) } fmt.Println(dir) }
package main import ( "fmt" "os" "path/filepath" ) func main() { ex, err := os.Executable() if err != nil { panic(err) } exPath := filepath.Dir(ex) fmt.Println(exPath) }
package main import ( "fmt" "os" ) func main() { pwd, err := os.Getwd() if err != nil { fmt.Println(err) os.Exit(1) } fmt.Println(pwd) }
package main import ( "github.com/kardianos/osext" "fmt" "log" ) func main() { folderPath, err := osext.ExecutableFolder() if err != nil { log.Fatal(err) } fmt.Println(folderPath) }
dir, err := filepath.Abs(filepath.Dir(os.Args[0])) if err != nil { log.Fatal(err) } fmt.Println(dir)
import( "os" "fmt" "log" ) func main() { dir, err := os.Getwd() if err != nil { log.Fatal(err) } fmt.Println(dir) }
package main import ( "fmt" "os" "path/filepath" ) func main() { var dirAbsPath string ex, err := os.Executable() if err == nil { dirAbsPath = filepath.Dir(ex) fmt.Println(dirAbsPath) return } exReal, err := filepath.EvalSymlinks(ex) if err != nil { panic(err) } dirAbsPath = filepath.Dir(exReal) fmt.Println(dirAbsPath) }
c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) go func(){ for sig := range c { } }()
package main import ( "fmt" "os" "os/signal" "syscall" "time" ) func cleanup() { fmt.Println("cleanup") } func main() { c := make(chan os.Signal) signal.Notify(c, os.Interrupt, syscall.SIGTERM) go func() { <-c cleanup() os.Exit(1) }() for { fmt.Println("sleeping...") time.Sleep(10 * time.Second) } }
c := make(chan os.Signal, 2) signal.Notify(c, os.Interrupt, syscall.SIGTERM) ....
c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) go func() { for sig := range c { log.Printf("captured %v, stopping profiler and exiting..", sig) pprof.StopCPUProfile() os.Exit(1) } }()
package main import ( "fmt" "os" "os/signal" "syscall" ) func main() { _,done1:=doSomething1() _,done2:=doSomething2() println("wait for finish") <-done1 <-done2 fmt.Print("clean up done, can exit safely") } func doSomething1() (error, chan bool) { done:=make(chan bool) c := make(chan os.Signal, 2) signal.Notify(c, os.Interrupt, syscall.SIGTERM) go func() { <-c done<-true }() return nil,done } func doSomething2() (error, chan bool) { done:=make(chan bool) c := make(chan os.Signal, 2) signal.Notify(c, os.Interrupt, syscall.SIGTERM) go func() { <-c done<-true }() return nil,done }
srv := &http.Server{} go_shutdown_hook.ADD(func() { log.Println("shutting down server") srv.Shutdown(nil) log.Println("shutting down server-done") }) l, err := net.Listen("tcp", ":3090") log.Println(srv.Serve(l)) go_shutdown_hook.Wait()
package main import ( "fmt" "strings" ) func main() { stringOne := "merpflakes" stringTwo := " " stringThree := "" if len(strings.TrimSpace(stringOne)) == 0 { fmt.Println("String is empty!") } if len(strings.TrimSpace(stringTwo)) == 0 { fmt.Println("String two is empty!") } if len(stringTwo) == 0 { fmt.Println("String two is still empty!") } if len(strings.TrimSpace(stringThree)) == 0 { fmt.Println("String three is empty!") } }
import "strings" if len(strings.TrimSpace(s)) == 0 { ... }
func empty(s string) bool { return len(strings.TrimSpace(s)) == 0 }
func Strempty(s string) bool { if len(s) == 0 { return true } r := []rune(s) l := len(r) for l > 0 { l-- if !unicode.IsSpace(r[l]) { return false } } return true }
create table User ( ID int primary key identity(1,1), Username text, FullName text, PasswordHash text, PasswordSalt text, IsDisabled bool ) create table UserSession ( SessionKey text primary key, UserID int not null, -- Could have a hard "references User" LoginTime <time type> not null, LastSeenTime <time type> not null )
e.Group("/admin").Use(middleware.BasicAuth(func(username, password string, c echo.Context) (bool, error) { if username == "joe" && password == "secret" { return true, nil } return false, nil }))
package main import ( "encoding/json" "fmt" "github.com/jmcvetta/napping" "log" "net/http" ) func main() { url := "http: fmt.Println("URL:>", url) s := napping.Session{} h := &http.Header{} h.Set("X-Custom-Header", "myvalue") s.Header = h var jsonStr = []byte(` { "title": "Buy cheese and bread for breakfast." }`) var data map[string]json.RawMessage err := json.Unmarshal(jsonStr, &data) if err != nil { fmt.Println(err) } resp, err := s.Post(url, &data, nil, nil) if err != nil { log.Fatal(err) } fmt.Println("response Status:", resp.Status()) fmt.Println("response Headers:", resp.HttpResponse().Header) fmt.Println("response Body:", resp.RawText()) }
func main() { url := "http: fmt.Println("URL:>", url) var jsonStr = []byte(`{"title":"Buy cheese and bread for breakfast."}`) req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonStr)) req.Header.Set("X-Custom-Header", "myvalue") req.Header.Set("Content-Type", "application/json") client := &http.Client{} resp, err := client.Do(req) if err != nil { panic(err) } defer resp.Body.Close() fmt.Println("response Status:", resp.Status) fmt.Println("response Headers:", resp.Header) body, _ := ioutil.ReadAll(resp.Body) fmt.Println("response Body:", string(body)) }
values := map[string]string{"username": username, "password": password} jsonValue, _ := json.Marshal(values) resp, err := http.Post(authAuthenticatorUrl, "application/json", bytes.NewBuffer(jsonValue))
func main() { url := "http: fmt.Println("URL:>", url) request := gorequest.New() titleList := []string{"title1", "title2", "title3"} for _, title := range titleList { resp, body, errs := request.Post(url). Set("X-Custom-Header", "myvalue"). Send(`{"title":"` + title + `"}`). End() if errs != nil { fmt.Println(errs) os.Exit(1) } fmt.Println("response Status:", resp.Status) fmt.Println("response Headers:", resp.Header) fmt.Println("response Body:", body) } }
func newInt1() *int { return new(int) } func newInt2() *int { var i int return &i }
new(Point) &Point{} &Point{2, 3} new(int) &int var i int &i
new(int) --> NEW(*int) new(Point) --> NEW(*Point) new(chan int) --> NEW(*chan int) make([]int, 10) --> NEW([]int, 10) new(Point) new(int)
$ go get -u github.com/motemen/gore $ which gore /Users/ches/src/go/bin/gore $ go clean -i -n github.com/motemen/gore... cd /Users/ches/src/go/src/github.com/motemen/gore rm -f gore gore.exe gore.test gore.test.exe commands commands.exe commands_test commands_test.exe complete complete.exe complete_test complete_test.exe debug debug.exe helpers_test helpers_test.exe liner liner.exe log log.exe main main.exe node node.exe node_test node_test.exe quickfix quickfix.exe session_test session_test.exe terminal_unix terminal_unix.exe terminal_windows terminal_windows.exe utils utils.exe rm -f /Users/ches/src/go/bin/gore cd /Users/ches/src/go/src/github.com/motemen/gore/gocode rm -f gocode.test gocode.test.exe rm -f /Users/ches/src/go/pkg/darwin_amd64/github.com/motemen/gore/gocode.a $ go clean -i github.com/motemen/gore... $ which gore $ tree $GOPATH/pkg/darwin_amd64/github.com/motemen/gore /Users/ches/src/go/pkg/darwin_amd64/github.com/motemen/gore 0 directories, 0 files $ rmdir $GOPATH/pkg/darwin_amd64/github.com/motemen/gore $ rm -rf $GOPATH/src/github.com/motemen/gore
goclean() { local pkg=$1; shift || return 1 local ost local cnt local scr go clean -i $pkg &>/dev/null [[ "$(uname -m)" == "x86_64" ]] \ && ost="$(uname)";ost="${ost,,}_amd64" \ && cnt="${pkg if (("${ rm -rf "${GOPATH%%:*}/src/${pkg%/*}" rm -rf "${GOPATH%%:*}/pkg/${ost}/${pkg%/*}" elif (("${ rm -rf "${GOPATH%%:*}/src/${pkg%/*/*}" rm -rf "${GOPATH%%:*}/pkg/${ost}/${pkg%/*/*}" fi source ~/.bashrc }
github.com/ laike9m/ myproject/ mylib/ mylib.go ... main.go
GO_Directory __MyProject _____ main.go _____ Entites _____ Fiboo _________ Client.go
package Fiboo type Client struct{ ID int name string }
package main import( Fiboo "./Entity/Fiboo" ) var TableClient Fiboo.Client func main(){ TableClient.ID = 1 TableClient.name = }
func saveHandler(w http.ResponseWriter, r *http.Request) { } func main() { r := mux.NewRouter() r.HandleFunc("/save", saveHandler) http.Handle("/", r) http.ListenAndServe(":"+port, nil) }
func saveHandler(w http.ResponseWriter, r *http.Request) { w.Header().Set("Access-Control-Allow-Origin", "*") }
func main() { r := mux.NewRouter() r.HandleFunc("/save", saveHandler) http.Handle("/", &MyServer{r}) http.ListenAndServe(":8080", nil); } type MyServer struct { r *mux.Router } func (s *MyServer) ServeHTTP(rw http.ResponseWriter, req *http.Request) { if origin := req.Header.Get("Origin"); origin != "" { rw.Header().Set("Access-Control-Allow-Origin", origin) rw.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE") rw.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization") } if req.Method == "OPTIONS" { return } s.r.ServeHTTP(rw, req) }
func addDefaultHeaders(fn http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { if origin := r.Header.Get("Origin"); origin != "" { w.Header().Set("Access-Control-Allow-Origin", origin) } w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE") w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token") w.Header().Set("Access-Control-Allow-Credentials", "true") fn(w, r) } }
func addDefaultHeaders(fn http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { w.Header().Set("Access-Control-Allow-Origin", "*") fn(w, r) } }
type Adapter func(http.Handler) http.Handler func Adapt(h http.Handler, adapters ...Adapter) http.Handler { for _, adapter := range adapters { h = adapter(h) } return h }
func EnableCORS() Adapter { return func(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { if origin := r.Header.Get("Origin"); origin != "" { w.Header().Set("Access-Control-Allow-Origin", origin) w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE") w.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization") } if r.Method == "OPTIONS" { return } h.ServeHTTP(w, r) }) } }
mux.Handle("/watcher/{action}/{device}",Adapt(api.SerialHandler(mux), api.EnableCORS(), api.ExpectGET(), ))
accounts := router.Path("/accounts").Subrouter() accounts.Methods("POST").Handler(AccountsCreate) accounts.Methods("OPTIONS").Handler(AccountsCreatePreFlight)
origin := r.Header.Get("Origin") validOrigin, err := validateOrigin(origin) if err != nil { return err } if validOrigin { w.Header().Set("Access-Control-Allow-Origin", origin) w.Header().Set("Access-Control-Allow-Methods", "POST") w.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization") }
.config([ $httpProvider.defaults.useXDomain = true; delete $httpProvider.defaults.headers.common[ }])
... location ~ ^<REGXP MATCHING CORS ROUTES> { add_header Access-Control-Allow-Methods POST ... } ...
i := 0 keys := make([]int, len(mymap)) for k := range mymap { keys[i] = k i++ }
package main func main() { mymap := make(map[int]string) keys := make([]int, 0, len(mymap)) for k := range mymap { keys = append(keys, k) } }
keys := make([]int, len(mymap)) i := 0 for k := range mymap { keys[i] = k i++ }
package main import ( "fmt" "reflect" ) func main() { abc := map[string]int{ "a": 1, "b": 2, "c": 3, } keys := reflect.ValueOf(abc).MapKeys() fmt.Println(keys) }
keys = []int{} for k := range mymap { keys = append(keys, k) }
import ( "database/sql" "fmt" _ "github.com/mattn/go-sqlite3" "log" "os" )
func theVeryFirstFunction() int { log.Println("theVeryFirstFunction") return 6 } var ( Num = theVeryFirstFunction() ) func init() { log.Println("init", Num) }
-X importpath.name=value Set the value of the string variable in importpath named name to value. Note that before Go 1.5 this option took two separate arguments. Now it takes one argument split on the first = sign.
package main import "fmt" var xyz string func main() { fmt.Println(xyz) }
go build -ldflags "-X main.minversion=`date -u +.%Y%m%d.%H%M%S`" service.go
BUILD_DATE := `date +%Y-%m-%d\ %H:%M` VERSIONFILE := cmd/myapp/version.go gensrc: rm -f $(VERSIONFILE) @echo "package main" > $(VERSIONFILE) @echo "const (" >> $(VERSIONFILE) @echo " VERSION = \"1.0\"" >> $(VERSIONFILE) @echo " BUILD_DATE = \"$(BUILD_DATE)\"" >> $(VERSIONFILE) @echo ")" >> $(VERSIONFILE)
flag.Usage = func() { fmt.Fprintf(os.Stderr, "%s version %s\n", os.Args[0], VERSION) fmt.Fprintf(os.Stderr, "built %s\n", BUILD_DATE) fmt.Fprintln(os.Stderr, "usage:") flag.PrintDefaults() }
--- Makefile ---- BINARY=gomake VERSION=`git describe --tags` BUILD=`date +%FT%T%z` LDFLAGS_f1=-ldflags "-w -s -X main.Version=${VERSION} -X main.Build=${BUILD} -X main.Entry=f1" LDFLAGS_f2=-ldflags "-w -s -X main.Version=${VERSION} -X main.Build=${BUILD} -X main.Entry=f2" build: go build ${LDFLAGS_f1} -o ${BINARY}_f1 go build ${LDFLAGS_f2} -o ${BINARY}_f2 install: go install ${LDFLAGS_f1} clean: if [ -f ${BINARY} ] ; then rm ${BINARY} ; fi .PHONY: clean install
package main import ( "fmt" ) var ( Version string Build string Entry string funcs = map[string]func() { "f1":functionOne,"f2":functionTwo, } ) func functionOne() { fmt.Println("This is function one") } func functionTwo() { fmt.Println("This is function two") } func main() { fmt.Println("Version: ", Version) fmt.Println("Build Time: ", Build) funcs[Entry]() }
mab@h2470988:~/projects/go/gomake/3/gomake$ ls -al total 2020 drwxrwxr-x 3 mab mab 4096 Sep 7 22:41 . drwxrwxr-x 3 mab mab 4096 Aug 16 10:00 .. drwxrwxr-x 8 mab mab 4096 Aug 17 16:40 .git -rwxrwxr-x 1 mab mab 1023488 Sep 7 22:41 gomake_f1 -rwxrwxr-x 1 mab mab 1023488 Sep 7 22:41 gomake_f2 -rw-rw-r-- 1 mab mab 399 Aug 16 10:21 main.go -rw-rw-r-- 1 mab mab 810 Sep 7 22:41 Makefile mab@h2470988:~/projects/go/gomake/3/gomake$ ./gomake_f1 Version: 1.0.1-1-gfb51187 Build Time: 2016-09-07T22:41:38+0200 This is function one mab@h2470988:~/projects/go/gomake/3/gomake$ ./gomake_f2 Version: 1.0.1-1-gfb51187 Build Time: 2016-09-07T22:41:39+0200 This is function two
$ go build -ldflags "-X name1=value1 -X name2=value2" -o path/to/output
package main import "fmt" var ( version string date string ) func main() { fmt.Printf("version=%s, date=%s", version, date) }
go build -ldflags "-X main.version=0.0.1 -X main.date=%date:~10,4%-%date:~4,2%-%date:~7,2%T%time:~0,2%:%time:~3,2%:%time:~6,2%"
package main import ( "fmt" ) func main() { i := 1 }
package main import ( _ "fmt" ) func main() { i := 1 _ = i }
$ go get golang.org/x/tools/cmd/goimports $ goimports -w my_file.go
your_mother := "was a hamster" your_father := "smells of elderberries" _, _ = your_mother, your_father
func Use(vals ...interface{}) { for _, val := range vals { _ = val } }
package main func main() { a := "declared and not used" b := "another declared and not used" c := 123 Use(a, b, c) }
import ( "github.com/lunux2008/xulu" ) func main() { xulu.Use(a, b, c) }
type T struct { FieldA int `json:"field_a"` FieldB string `json:"field_b,omitempty"` }
data, err := ioutil.ReadAll(resp.Body) if err == nil && data != nil { err = json.Unmarshal(data, value) }
sudo apt-get install python-software-properties sudo add-apt-repository ppa:duh/golang sudo apt-get update sudo apt-get install golang
sudo apt-get install bison mercurial bash < <(curl -LSs . "$HOME/.gvm/scripts/gvm"
sudo add-apt-repository ppa:ubuntu-lxc/lxd-stable sudo apt-get update sudo apt-get install golang
sudo add-apt-repository ppa:longsleep/golang-backports sudo apt-get update sudo apt-get install golang-go
git clone https: cd update-golang sudo ./update-golang.sh
DOWNLOAD_DIR=${HOME}/Downloads/GoLang INSTALL_DIR=${HOME}/App function install { mkdir -p ${DOWNLOAD_DIR} cd ${DOWNLOAD_DIR} echo "Fetching latest Go version..." typeset VER=`curl -s https: if uname -m | grep 64 > /dev/null; then typeset ARCH=amd64 else typeset ARCH=386 fi typeset FILE=$VER.linux-$ARCH if [[ ! -e ${FILE}.tar.gz ]]; then echo "Downloading wget https: fi echo "Installing ${FILE} ..." tar zxfC ${FILE}.tar.gz ${INSTALL_DIR} echo "Go is installed" } install
export GOROOT=${INSTALL_DIR}/go export GOPATH=<your go path> export PATH=${PATH}:${GOROOT}/bin:${GOPATH}/bin
bash <(curl -s https: ln -vs /usr/local/go/bin/go* /usr/local/bin/
sudo add-apt-repository ppa:longsleep/golang-backports sudo apt-get update sudo apt-get install golang-go
if [ -n "$BASH_VERSION" ]; then if [ -f "$HOME/.bashrc" ]; then . "$HOME/.bashrc" fi fi PATH="$HOME/bin:$HOME/.local/bin:$PATH"
func doit(w http.ResponseWriter, r *http.Request) { notify.Post("my_event", "Hello World!") fmt.Fprint(w, "+OK") }
func handler(w http.ResponseWriter, r *http.Request) { myEventChan := make(chan interface{}) notify.Start("my_event", myEventChan) data := <-myEventChan fmt.Fprint(w, data + "\n") }
$ go run lp.go ./lp.go:15: invalid operation: data + "\n" (mismatched types interface {} and string)
func handler(w http.ResponseWriter, r *http.Request) { myEventChan := make(chan interface{}) notify.Start("my_event", myEventChan) data := <-myEventChan s:= data.(string) + "\n" fmt.Fprint(w, s) }
for _, item := range items { value, ok := item.(T) dosomethingWith(value) }
mySlice1 := make([]int, 0) mySlice2 := []int{} fmt.Println("mySlice1", cap(mySlice1)) fmt.Println("mySlice2", cap(mySlice2))
package main import ( "fmt" ) func main() { var nil_slice []int var empty_slice = []int{} fmt.Println(nil_slice == nil, len(nil_slice), cap(nil_slice)) fmt.Println(empty_slice == nil, len(empty_slice), cap(empty_slice)) }
var nilSlice []int emptySlice1 := make([]int, 0) emptySlice2 := []int{} fmt.Println(nilSlice == nil) fmt.Println(emptySlice1 == nil) fmt.Println(emptySlice2 == nil)
func foo([]interface{}) { } func main() { var a []string = []string{"hello", "world"} foo(a) }
b = make([]interface{}, len(a), len(a)) for i := range a { b[i] = a[i] }
func InterfaceSlice(slice interface{}) []interface{} { s := reflect.ValueOf(slice) if s.Kind() != reflect.Slice { panic("InterfaceSlice() given a non-slice type") } ret := make([]interface{}, s.Len()) for i:=0; i<s.Len(); i++ { ret[i] = s.Index(i).Interface() } return ret }
b := make([]interface{}, len(a)) for i := range a { b[i] = a[i] }
var dataSlice []int = foo() var interfaceSlice []interface{} = make([]interface{}, len(dataSlice)) for i, d := range dataSlice { interfaceSlice[i] = d }
package github.com/jehiah/json2csv: cannot download, $GOPATH not set. For more details see: go help go path
$ brew info go go: stable 1.4.2 (bottled), HEAD Go programming environment https: /usr/local/Cellar/go/1.4.2 (4676 files, 158M) * Poured from bottle From: https: ==> Options --with-cc-all Build with cross-compilers and runtime support for all supported platforms --with-cc-common Build with cross-compilers and runtime support for darwin, linux and windows --without-cgo Build without cgo --without-godoc godoc will not be installed for you --without-vet vet will not be installed for you --HEAD Install HEAD version ==> Caveats As of go 1.2, a valid GOPATH is required to use the `go get` command: https: You may wish to add the GOROOT-based install location to your PATH: export PATH=$PATH:/usr/local/opt/go/libexec/bin
$ export PATH=$PATH:/usr/local/opt/go/libexec/bin $ export GOPATH=/usr/local/opt/go/bin
$ go env GOARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="darwin" GOOS="darwin" GOPATH="/usr/local/opt/go/bin" GORACE="" GOROOT="/usr/local/Cellar/go/1.4.2/libexec" GOTOOLDIR="/usr/local/Cellar/go/1.4.2/libexec/pkg/tool/darwin_amd64" CC="clang" GOGCCFLAGS="-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fno-common" CXX="clang++" CGO_ENABLED="1"
$ $ ls -l $GOPATH/bin total 5248 -rwxr-xr-x 1 sammingolelli staff 2686320 Jun 9 12:28 json2csv
$ type -f json2csv -bash: type: json2csv: not found
$ type -f json2csv json2csv is hashed (/usr/local/opt/go/bin/bin/json2csv)
$ json2csv --help Usage of json2csv: -d=",": delimiter used for output values -i="": /path/to/input.json (optional; default is stdin) -k=[]: fields to output -o="": /path/to/output.json (optional; default is stdout) -p=false: prints header to output -v=false: verbose output (to stderr) -version=false: print version string
export PATH=$PATH:/usr/local/opt/go/libexec/bin export GOPATH=/usr/local/opt/go/bin
export GOROOT=$HOME/go export GOPATH=$GOROOT/bin export PATH=$PATH:$GOPATH
sudo env GOPATH=$HOME/goWorkDirectory glide install
$ cd /path/to/your/download/directory $ tar -xvf gost_linux_amd64.tar.gz
gost goCommand [-p {pathName}] -- [goFlags...] [goArgs...]
$ gost get -p foo -- github.com/go-sql-driver/mysql
import ( "bytes" "encoding/json" "log" "net/http" ) func HandleCSPViolationRequest(w http.ResponseWriter, req *http.Request) { body := App.MustReadBody(req, w) if body == nil { return } var prettyJSON bytes.Buffer error := json.Indent(&prettyJSON, body, "", "\t") if error != nil { log.Println("JSON parse error: ", error) App.BadRequest(w) return } log.Println("CSP Violation:", string(prettyJSON.Bytes())) }
var out io.Writer enc := json.NewEncoder(out) enc.SetIndent("", " ") if err := enc.Encode(data); err != nil { panic(err) }
package main import ( "bytes" "encoding/json" "fmt" ) func prettyprint(b []byte) ([]byte, error) { var out bytes.Buffer err := json.Indent(&out, b, "", " ") return out.Bytes(), err } func main() { b := []byte(`{"hello": "123"}`) b, _ = prettyprint(b) fmt.Printf("%s", b) }
package main import ( "fmt" "github.com/TylerBrock/colorjson" "encoding/json" ) func main() { str := `{ "str": "foo", "num": 100, "bool": false, "null": null, "array": ["foo", "bar", "baz"], "obj": { "a": 1, "b": 2 } }` var obj map[string]interface{} json.Unmarshal([]byte(str), &obj) f := colorjson.NewFormatter() f.Indent = 4 s, _ := f.Marshal(obj) fmt.Println(string(s)) }
import ( "encoding/json" "bytes" ) func jsonPrettyPrint(in string) string { var out bytes.Buffer err := json.Indent(&out, []byte(in), "", "\t") if err != nil { return in } return out.String() }
import ( "bytes" "encoding/json" ) const ( empty = "" tab = "\t" ) func PrettyJson(data interface{}) (string, error) { buffer := new(bytes.Buffer) encoder := json.NewEncoder(buffer) encoder.SetIndent(empty, tab) err := encoder.Encode(data) if err != nil { return empty, err } return buffer.String(), nil }
package main import ( "bytes" "encoding/json" "flag" "fmt" "io/ioutil" "os" ) func main() { indent := flag.String("indent", " ", "indentation string/character for formatter") flag.Parse() src, err := ioutil.ReadAll(os.Stdin) if err != nil { fmt.Fprintf(os.Stderr, "problem reading: %s", err) os.Exit(1) } dst := &bytes.Buffer{} if err := json.Indent(dst, src, "", *indent); err != nil { fmt.Fprintf(os.Stderr, "problem formatting: %s", err) os.Exit(1) } if _, err = dst.WriteTo(os.Stdout); err != nil { fmt.Fprintf(os.Stderr, "problem writing: %s", err) os.Exit(1) } }
var slice []int slice = append(slice, 2) slice = append(slice, 7) slice[len(slice)-1:][0]
-run regexp Run only those tests and examples matching the regular expression.
alias testcases="sed -n go test -v -run $(cat coordinator_test.go | testcases)
func (h handler) ServeHTTP(w http.ResponseWriter, r *http.Request) { ... }
func (s *GracefulServer) BlockingClose() bool { ... }
package main import "fmt" type Mutatable struct { a int b int } func (m Mutatable) StayTheSame() { m.a = 5 m.b = 7 } func (m *Mutatable) Mutate() { m.a = 5 m.b = 7 } func main() { m := &Mutatable{0, 0} fmt.Println(m) m.StayTheSame() fmt.Println(m) m.Mutate() fmt.Println(m)
package main import ( "fmt" "strings" ) func main() { s := "\t Hello, World\n " fmt.Printf("%d %q\n", len(s), s) t := strings.TrimSpace(s) fmt.Printf("%d %q\n", len(t), t) }
package main import ( "fmt" "strings" ) func main() { fmt.Println(strings.TrimSpace(" \t\n Hello, Gophers \n\t\r\n")) }
package main import ( "fmt" "strings" ) func main() { fmt.Println(strings.TrimSpace(" \t\n Hello, Gophers \n\t\r\n")) }
package main type Interface interface {} type Struct struct {} func main() { var ps *Struct var pi *Interface pi = ps _, _ = pi, ps }
prog.go:10: cannot use ps (type *Struct) as type *Interface in assignment: *Interface is pointer to interface, not interface
package main type Interface interface{} type Struct struct{} func main() { var ps *Struct var pi *Interface pi = new(Interface) *pi = ps _, _ = pi, ps }
package main type Interface interface{} type Struct struct{} func main() { ps := new(Struct) pi := Interface(ps) _, _ = pi, ps }
import "strings" startsWith := strings.HasPrefix("prefix", "pre") endsWith := strings.HasSuffix("suffix", "fix")
func SwapRune(r rune) rune { switch { case return r - case return r - default: return r } }
func SwapCase(str string) string { return strings.Map(SwapRune, str) }
package main import "fmt" func SwapRune(r rune) rune { switch { case 97 <= r && r <= 122: return r - 32 case 65 <= r && r <= 90: return r + 32 default: return r } } func main() { fmt.Println(SwapRune( }
package main import ( "fmt" ) func main() { fmt.Println([]byte("Hello")) }
t := time.Now() switch { case t.Hour() < 12: fmt.Println("It default: fmt.Println("It }
t := time.Now() if t.Hour() < 12 { fmt.Println("It } else { fmt.Println("It }
package main import "fmt" func stringAndRuneCompare() { s := "hello你好" fmt.Printf("%s, type: %T, len: %d\n", s, s, len(s)) fmt.Printf("s[%d]: %v, type: %T\n", 0, s[0], s[0]) li := len(s) - 1 fmt.Printf("s[%d]: %v, type: %T\n\n", li, s[li], s[li]) rs := []rune(s) fmt.Printf("%v, type: %T, len: %d\n", rs, rs, len(rs)) } func main() { stringAndRuneCompare() }
hello你好, type: string, len: 11 s[0]: 104, type: uint8 s[10]: 189, type: uint8 [104 101 108 108 111 20320 22909], type: []int32, len: 7
type Attribute struct { Key, Val string } type Node struct { Attr []Attribute }
for _, attr := range n.Attr { if attr.Key == "href" { attr.Val = "something" } }
for i, attr := range n.Attr { if attr.Key == "href" { n.Attr[i].Val = "something" } }
Range expression 1st value 2nd value (if 2nd variable is present) array or slice a [n]E, *[n]E, or []E index i int a[i] E
x := make([]int, 3) x[0], x[1], x[2] = 1, 2, 3 for i, val := range x { println(&x[i], "vs.", &val) }
0xf84000f010 vs. 0x7f095ed0bf68 0xf84000f014 vs. 0x7f095ed0bf68 0xf84000f018 vs. 0x7f095ed0bf68
package main import "fmt" type Attribute struct { Key, Val string } type Node struct { Attr []Attribute } func main() { n := Node{ []Attribute{ {"key", "value"}, {"href", "http: }, } fmt.Println(n) for i := 0; i < len(n.Attr); i++ { attr := &n.Attr[i] if attr.Key == "href" { attr.Val = "something" } } fmt.Println(n) }
{[{key value} {href http: {[{key value} {href something}]}
for i := 0; i < len(n.Attr); i++ { if n.Attr[i].Key == "href" { n.Attr[i].Val = "something" } }
for i, attr := range n.Attr { if attr.Key == "href" { n.Attr[i].Val = "something" } }
package main import "fmt" type Attribute struct { Key, Val string } type Node struct { Attr []*Attribute } func main() { n := Node{[]*Attribute{ &Attribute{"foo", ""}, &Attribute{"href", ""}, &Attribute{"bar", ""}, }} for _, attr := range n.Attr { if attr.Key == "href" { attr.Val = "something" } } for _, v := range n.Attr { fmt.Printf("% } }
main.Attribute{Key:"foo", Val:""} main.Attribute{Key:"href", Val:"something"} main.Attribute{Key:"bar", Val:""}
package main import "fmt" type Attribute struct { Key, Val string } type Node struct { Attr []Attribute } func main() { n := Node{[]Attribute{ {"foo", ""}, {"href", ""}, {"bar", ""}, }} for i := range n.Attr { attr := &n.Attr[i] if attr.Key == "href" { attr.Val = "something" } } for _, v := range n.Attr { fmt.Printf("% } }
main.Attribute{Key:"foo", Val:""} main.Attribute{Key:"href", Val:"something"} main.Attribute{Key:"bar", Val:""}
for i := range n.Attr { if n.Attr[i].Key == "href" { n.Attr[i].Val = "something" } }
package main import ( "bytes" "fmt" "math/rand" "time" ) func main() { fmt.Println(randomString(10)) } func randomString(l int) string { var result bytes.Buffer var temp string for i := 0; i < l; { if string(randInt(65, 90)) != temp { temp = string(randInt(65, 90)) result.WriteString(temp) i++ } } return result.String() } func randInt(min int, max int) int { rand.Seed(time.Now().UTC().UnixNano()) return min + rand.Intn(max-min) }
package main import ( "fmt" "math/rand" "time" ) func main() { rand.Seed(time.Now().UTC().UnixNano()) fmt.Println(randomString(10)) } func randomString(l int) string { bytes := make([]byte, l) for i := 0; i < l; i++ { bytes[i] = byte(randInt(65, 90)) } return string(bytes) } func randInt(min int, max int) int { return min + rand.Intn(max-min) }
var alpha = "abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789" func srand(size int) string { buf := make([]byte, size) for i := 0; i < size; i++ { buf[i] = alpha[rand.Intn(len(alpha))] } return string(buf) }
package main import ( "fmt" "math/rand" "time" ) func main() { rand.Seed( time.Now().UnixNano()) var bytes int for i:= 0 ; i < 10 ; i++{ bytes = rand.Intn(6)+1 fmt.Println(bytes) } }
func randomInt (min int , max int ) int { var bytes int bytes = min + rand.Intn(max) return int(bytes) }
package main import ( "math/rand" "time" ) func init() { rand.Seed(time.Now().UTC().UnixNano()) } func srand(min, max int, readable bool) string { var length int var char string if min < max { length = min + rand.Intn(max-min) } else { length = min } if readable == false { char = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" } else { char = "ABCDEFHJLMNQRTUVWXYZabcefghijkmnopqrtuvwxyz23479" } buf := make([]byte, length) for i := 0; i < length; i++ { buf[i] = char[rand.Intn(len(char)-1)] } return string(buf) } func main() { println(srand(5, 5, true)) println(srand(5, 5, true)) println(srand(5, 5, true)) println(srand(5, 5, false)) println(srand(5, 7, true)) println(srand(5, 10, false)) println(srand(5, 50, true)) println(srand(5, 10, false)) println(srand(5, 50, true)) println(srand(5, 10, false)) println(srand(5, 50, true)) println(srand(5, 10, false)) println(srand(5, 50, true)) println(srand(5, 4, true)) println(srand(5, 400, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) println(srand(6, 5, true)) }
package main import ( "fmt" "math/rand" "time" ) func main(){ rand.Seed(time.Now().UnixNano()) var s string for i:=0;i<10;i++{ s+=fmt.Sprintf("%d ",rand.Intn(7)) } fmt.Printf(s) }
func myFunction() (*MyStructType, error) { var chunk *MyStructType = new(HeaderChunk) ... return chunk, nil } func myFunction() (*MyStructType, error) { var chunk MyStructType ... return &chunk, nil }
type MyStructType struct{} func myFunction1() (*MyStructType, error) { var chunk *MyStructType = new(MyStructType) return chunk, nil } func myFunction2() (MyStructType, error) { var chunk MyStructType return chunk, nil } type bigStruct struct { lots [1e6]float64 } func myFunction3() (bigStruct, error) { var chunk bigStruct return chunk, nil }
--- prog list "myFunction1" --- 0000 (s.go:5) TEXT myFunction1+0(SB),$16-24 0001 (s.go:6) MOVQ $type."".MyStructType+0(SB),(SP) 0002 (s.go:6) CALL ,runtime.new+0(SB) 0003 (s.go:6) MOVQ 8(SP),AX 0004 (s.go:8) MOVQ AX,.noname+0(FP) 0005 (s.go:8) MOVQ $0,.noname+8(FP) 0006 (s.go:8) MOVQ $0,.noname+16(FP) 0007 (s.go:8) RET , --- prog list "myFunction2" --- 0008 (s.go:11) TEXT myFunction2+0(SB),$0-16 0009 (s.go:12) LEAQ chunk+0(SP),DI 0010 (s.go:12) MOVQ $0,AX 0011 (s.go:14) LEAQ .noname+0(FP),BX 0012 (s.go:14) LEAQ chunk+0(SP),BX 0013 (s.go:14) MOVQ $0,.noname+0(FP) 0014 (s.go:14) MOVQ $0,.noname+8(FP) 0015 (s.go:14) RET ,
--- prog list "myFunction3" --- 0016 (s.go:21) TEXT myFunction3+0(SB),$8000000-8000016 0017 (s.go:22) LEAQ chunk+-8000000(SP),DI 0018 (s.go:22) MOVQ $0,AX 0019 (s.go:22) MOVQ $1000000,CX 0020 (s.go:22) REP , 0021 (s.go:22) STOSQ , 0022 (s.go:24) LEAQ chunk+-8000000(SP),SI 0023 (s.go:24) LEAQ .noname+0(FP),DI 0024 (s.go:24) MOVQ $1000000,CX 0025 (s.go:24) REP , 0026 (s.go:24) MOVSQ , 0027 (s.go:24) MOVQ $0,.noname+8000000(FP) 0028 (s.go:24) MOVQ $0,.noname+8000008(FP) 0029 (s.go:24) RET ,
type MyStructType struct{} func myFunction1() (*MyStructType, error) { var chunk *MyStructType = new(MyStructType) return chunk, nil } func myFunction2() (*MyStructType, error) { var chunk MyStructType return &chunk, nil }
--- prog list "myFunction1" --- 0000 (temp.go:9) TEXT myFunction1+0(SB),$8-12 0001 (temp.go:10) MOVL $type."".MyStructType+0(SB),(SP) 0002 (temp.go:10) CALL ,runtime.new+0(SB) 0003 (temp.go:10) MOVL 4(SP),BX 0004 (temp.go:12) MOVL BX,.noname+0(FP) 0005 (temp.go:12) MOVL $0,AX 0006 (temp.go:12) LEAL .noname+4(FP),DI 0007 (temp.go:12) STOSL , 0008 (temp.go:12) STOSL , 0009 (temp.go:12) RET , --- prog list "myFunction2" --- 0010 (temp.go:15) TEXT myFunction2+0(SB),$8-12 0011 (temp.go:16) MOVL $type."".MyStructType+0(SB),(SP) 0012 (temp.go:16) CALL ,runtime.new+0(SB) 0013 (temp.go:16) MOVL 4(SP),BX 0014 (temp.go:18) MOVL BX,.noname+0(FP) 0015 (temp.go:18) MOVL $0,AX 0016 (temp.go:18) LEAL .noname+4(FP),DI 0017 (temp.go:18) STOSL , 0018 (temp.go:18) STOSL , 0019 (temp.go:18) RET ,
func NewThing(someParameter string) *Thing { p := new(Thing) p.Name = someParameter p.Num = 33 return p }
func NewThing(someParameter string) *Thing { return &Thing{someParameter, 33} }
func makeThing(name string) Thing { return Thing{name, 33} }
func NewThing(someParameter string) *Thing { return &Thing{someParameter, 33} }
package main import "fmt" type Thing struct { Name string Num int } func (t *Thing) Init(name string, num int) { t.Name = name t.Num = num } func main() { t := new(Thing) t.Init("Hello", 5) fmt.Printf("%s: %d\n", t.Name, t.Num) }
func New(out io.Writer, prefix string, flag int) * Logger { return &Logger{out: out, prefix: prefix, flag: flag} }
func NewReader(rd io.Reader) * Reader { return NewReaderSize(rd, defaultBufSize) }
func (h Hash) New() hash.Hash { if h > 0 && h < maxHash { f := hashes[h] if f != nil { return f() } } panic("crypto: requested hash function is unavailable") }
package person type Person struct { Name string Old int } func New(name string, old int) *Person { return &Person{ Name: name, } }
type Thing struct { Name string Num int } type Constructor_Thing struct {} func (c CThing) new(<<CONSTRUCTOR ARGS>>) Thing { var thing Thing return thing } var cThing CThing func main(){ var myThing Thing myThing = cThing.new(<<CONSTRUCTOR ARGS>>) }
type SearchResult struct { Date string `json:"date"` IdCompany int `json:"idCompany"` Company string `json:"company"` IdIndustry interface{} `json:"idIndustry"` Industry string `json:"industry"` IdContinent interface{} `json:"idContinent"` Continent string `json:"continent"` IdCountry interface{} `json:"idCountry"` Country string `json:"country"` IdState interface{} `json:"idState"` State string `json:"state"` IdCity interface{} `json:"idCity"` City string `json:"city"` } type SearchResults struct { NumberResults int `json:"numberResults"` Results []SearchResult `json:"results"` }
err := json.NewEncoder(c.ResponseWriter).Encode(&msg)
Field int `json:"-"` Field int `json:"myName"` Field int `json:"myName,omitempty"` Field int `json:",omitempty"`
func fieldSet(fields ...string) map[string]bool { set := make(map[string]bool, len(fields)) for _, s := range fields { set[s] = true } return set } func (s *SearchResult) SelectFields(fields ...string) map[string]interface{} { fs := fieldSet(fields...) rt, rv := reflect.TypeOf(*s), reflect.ValueOf(*s) out := make(map[string]interface{}, rt.NumField()) for i := 0; i < rt.NumField(); i++ { field := rt.Field(i) jsonKey := field.Tag.Get("json") if fs[jsonKey] { out[jsonKey] = rv.Field(i).Interface() } } return out }
package main import ( "encoding/json" "fmt" "log" "github.com/hashicorp/go-version" "github.com/liip/sheriff" ) type User struct { Username string `json:"username" groups:"api"` Email string `json:"email" groups:"personal"` Name string `json:"name" groups:"api"` Roles []string `json:"roles" groups:"api" since:"2"` } func main() { user := User{ Username: "alice", Email: "alice@example.org", Name: "Alice", Roles: []string{"user", "admin"}, } v2, err := version.NewVersion("2.0.0") if err != nil { log.Panic(err) } o := &sheriff.Options{ Groups: []string{"api"}, ApiVersion: v2, } data, err := sheriff.Marshal(o, user) if err != nil { log.Panic(err) } output, err := json.MarshalIndent(data, "", " ") if err != nil { log.Panic(err) } fmt.Printf("%s", output) }
func MarshalOnlyFields(structa interface{}, includeFields map[string]bool) (jsona []byte, status error) { value := reflect.ValueOf(structa) typa := reflect.TypeOf(structa) size := value.NumField() jsona = append(jsona, for i := 0; i < size; i++ { structValue := value.Field(i) var fieldName string = typa.Field(i).Name if marshalledField, marshalStatus := json.Marshal((structValue).Interface()); marshalStatus != nil { return []byte{}, marshalStatus } else { if includeFields[fieldName] { jsona = append(jsona, jsona = append(jsona, []byte(fieldName)...) jsona = append(jsona, jsona = append(jsona, jsona = append(jsona, (marshalledField)...) if i+1 != len(includeFields) { jsona = append(jsona, } } } } jsona = append(jsona, return }
type magic struct { Magic1 int Magic2 string Magic3 [2]int } func main() { var magic = magic{0, "tusia", [2]int{0, 1}} if json, status := MarshalOnlyFields(magic, map[string]bool{"Magic1": true}); status != nil { println("error") } else { fmt.Println(string(json)) } }
type User2 struct { ID int `groups:"id" json:"id,omitempty"` Username string `groups:"username" json:"username,omitempty"` Nickname string `groups:"nickname" json:"nickname,omitempty"` } type User struct { ID int `groups:"private,public" json:"id,omitempty"` Username string `groups:"private" json:"username,omitempty"` Nickname string `groups:"public" json:"nickname,omitempty"` } var ( tagName = "groups" ) func OmitFields(obj interface{}, acTags []string) { sv := reflect.ValueOf(obj).Elem() st := sv.Type() if sv.Kind() == reflect.Struct { for i := 0; i < st.NumField(); i++ { fieldVal := sv.Field(i) if fieldVal.CanSet() { tagStr := st.Field(i).Tag.Get(tagName) if len(tagStr) == 0 { continue } tagList := strings.Split(strings.Replace(tagStr, " ", "", -1), ",") if !ContainsCommonItem(tagList, acTags) { fieldVal.Set(reflect.Zero(fieldVal.Type())) } } } } } func ContainsCommonItem(arr1 []string, arr2 []string) bool { for i := 0; i < len(arr1); i++ { for j := 0; j < len(arr2); j++ { if arr1[i] == arr2[j] { return true } } } return false } func main() { u := User{ID: 1, Username: "very secret", Nickname: "hinzir"} OmitFields(&u, []string{"public"}) bytes, _ := json.Marshal(&u) fmt.Println(string(bytes)) u2 := User2{ID: 1, Username: "very secret", Nickname: "hinzir"} OmitFields(&u2, []string{"id", "nickname"}) bytes, _ = json.Marshal(&u2) fmt.Println(string(bytes)) }
env GOOS=linux GOARCH=arm go build -v github.com/path/to/your/app
sudo GOOS=windows GOARCH=386 CGO_ENABLED=0 ./make.bash --no-clean
GOOS=windows GOARCH=386 go build -o appname.exe appname.go GOOS=linux GOARCH=386 CGO_ENABLED=0 go build -o appname.linux appname.go
docker run --rm -it -v "$GOPATH":/go -w /go/src/github.com/iron-io/ironcli golang:1.4.2-cross sh -c ' for GOOS in darwin linux windows; do for GOARCH in 386 amd64; do echo "Building $GOOS-$GOARCH" export GOOS=$GOOS export GOARCH=$GOARCH go build -o bin/ironcli-$GOOS-$GOARCH done done '
/usr/local/go/src/runtime/cgo/gcc_windows_amd64.c:8:10: fatal error:
cd /usr/local/go/src sudo GOOS=windows GOARCH=amd64 CGO_ENABLED=1 GOROOT_BOOTSTRAP=/Users/Pooya/Documents/go ./make.bash --no-clean sudo GOOS=windows GOARCH=386 CGO_ENABLED=1 GOROOT_BOOTSTRAP=/Users/Pooya/Documents/go ./make.bash --no-clean
GOOS="windows" GOARCH="386" CGO_ENABLED="1" CC="/usr/local/opt/mingw-w64/bin/i686-w64-mingw32-gcc" go build hello.go GOOS="windows" GOARCH="amd64" CGO_ENABLED="1" CC="/usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-gcc" go build hello.go
package=$1 if [[ -z "$package" ]]; then echo "usage: $0 <package-name>" exit 1 fi package_name=$package platforms=( "darwin/386" "dragonfly/amd64" "freebsd/386" "freebsd/amd64" "freebsd/arm" "linux/386" "linux/amd64" "linux/arm" "linux/arm64" "netbsd/386" "netbsd/amd64" "netbsd/arm" "openbsd/386" "openbsd/amd64" "openbsd/arm" "plan9/386" "plan9/amd64" "solaris/amd64" "windows/amd64" "windows/386" ) for platform in "${platforms[@]}" do platform_split=(${platform GOOS=${platform_split[0]} GOARCH=${platform_split[1]} output_name=$package_name if [ $GOOS = "windows" ]; then output_name+= fi env GOOS=$GOOS GOARCH=$GOARCH go build -o $output_name $package if [ $? -ne 0 ]; then echo exit 1 fi done
~/src/go-statsd-client> echo $GOPATH /Users/me/gopath ~/src/go-statsd-client> echo $GOROOT /usr/local/Cellar/go/1.1.1\ ~/src/go-statsd-client> go install go install: no install location for directory /Users/me/src/go-statsd-client outside GOPATH
GOARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="darwin" GOOS="darwin" GOPATH="/Users/me/gopath" GORACE="" GOROOT="/usr/local/Cellar/go/1.1.1" GOTOOLDIR="/usr/local/Cellar/go/1.1.1/pkg/tool/darwin_amd64" CC="gcc" GOGCCFLAGS="-g -O2 -fPIC -m64 -pthread -fno-common" CGO_ENABLED="1"
GOPATH /bin /src /someProgram program.go /someLibrary library.go /pkg
export GOROOT=`go env GOROOT` export GOPATH=/Users/yy/Projects/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN
GOPATH=/home/user/go /home/user/go/ src/ foo/ bar/ (go code in package bar) x.go quux/ (go code in package main) y.go bin/ quux (installed command) pkg/ linux_amd64/ foo/ bar.a (installed package object)
import ( "fmt" "github.com/bradfitz/iter" ) func p(i int) { fmt.Println(i) } func plain() { for i := 0; i < 10; i++ { p(i) } } func with_iter() { for i := range iter.N(10) { p(i) } } func main() { plain() with_iter() }
0035 (/home/ncw/Go/iter.go:14) MOVQ $0,AX 0036 (/home/ncw/Go/iter.go:14) JMP ,38
0037 (/home/ncw/Go/iter.go:14) INCQ ,AX 0038 (/home/ncw/Go/iter.go:14) CMPQ AX,$10 0039 (/home/ncw/Go/iter.go:14) JGE $0,45 0040 (/home/ncw/Go/iter.go:15) MOVQ AX,i+-8(SP) 0041 (/home/ncw/Go/iter.go:15) MOVQ AX,(SP) 0042 (/home/ncw/Go/iter.go:15) CALL ,p+0(SB) 0043 (/home/ncw/Go/iter.go:15) MOVQ i+-8(SP),AX 0044 (/home/ncw/Go/iter.go:14) JMP ,37 0045 (/home/ncw/Go/iter.go:17) RET ,
0052 (/home/ncw/Go/iter.go:20) MOVQ $10,AX 0053 (/home/ncw/Go/iter.go:20) MOVQ $0,~r0+-24(SP) 0054 (/home/ncw/Go/iter.go:20) MOVQ $0,~r0+-16(SP) 0055 (/home/ncw/Go/iter.go:20) MOVQ $0,~r0+-8(SP) 0056 (/home/ncw/Go/iter.go:20) MOVQ $type.[]struct {}+0(SB),(SP) 0057 (/home/ncw/Go/iter.go:20) MOVQ AX,8(SP) 0058 (/home/ncw/Go/iter.go:20) MOVQ AX,16(SP) 0059 (/home/ncw/Go/iter.go:20) PCDATA $0,$48 0060 (/home/ncw/Go/iter.go:20) CALL ,runtime.makeslice+0(SB) 0061 (/home/ncw/Go/iter.go:20) PCDATA $0,$-1 0062 (/home/ncw/Go/iter.go:20) MOVQ 24(SP),DX 0063 (/home/ncw/Go/iter.go:20) MOVQ 32(SP),CX 0064 (/home/ncw/Go/iter.go:20) MOVQ 40(SP),AX 0065 (/home/ncw/Go/iter.go:20) MOVQ DX,~r0+-24(SP) 0066 (/home/ncw/Go/iter.go:20) MOVQ CX,~r0+-16(SP) 0067 (/home/ncw/Go/iter.go:20) MOVQ AX,~r0+-8(SP) 0068 (/home/ncw/Go/iter.go:20) MOVQ $0,AX 0069 (/home/ncw/Go/iter.go:20) LEAQ ~r0+-24(SP),BX 0070 (/home/ncw/Go/iter.go:20) MOVQ 8(BX),BP 0071 (/home/ncw/Go/iter.go:20) MOVQ BP,autotmp_0006+-32(SP) 0072 (/home/ncw/Go/iter.go:20) JMP ,74
0073 (/home/ncw/Go/iter.go:20) INCQ ,AX 0074 (/home/ncw/Go/iter.go:20) MOVQ autotmp_0006+-32(SP),BP 0075 (/home/ncw/Go/iter.go:20) CMPQ AX,BP 0076 (/home/ncw/Go/iter.go:20) JGE $0,82 0077 (/home/ncw/Go/iter.go:20) MOVQ AX,autotmp_0005+-40(SP) 0078 (/home/ncw/Go/iter.go:21) MOVQ AX,(SP) 0079 (/home/ncw/Go/iter.go:21) CALL ,p+0(SB) 0080 (/home/ncw/Go/iter.go:21) MOVQ autotmp_0005+-40(SP),AX 0081 (/home/ncw/Go/iter.go:20) JMP ,73 0082 (/home/ncw/Go/iter.go:23) RET ,
package main import ( "testing" "github.com/bradfitz/iter" ) const loops = 1e6 func BenchmarkForClause(b *testing.B) { b.ReportAllocs() j := 0 for i := 0; i < b.N; i++ { for j = 0; j < loops; j++ { j = j } } _ = j } func BenchmarkRangeIter(b *testing.B) { b.ReportAllocs() j := 0 for i := 0; i < b.N; i++ { for j = range iter.N(loops) { j = j } } _ = j } func N(n int) []struct{} { return make([]struct{}, n) } func BenchmarkIterAllocs(b *testing.B) { b.ReportAllocs() var n []struct{} for i := 0; i < b.N; i++ { n = iter.N(loops) } _ = n }
$ go test -bench=. -run=. testing: warning: no tests to run PASS BenchmarkForClause 2000 1260356 ns/op 0 B/op 0 allocs/op BenchmarkRangeIter 2000 1257312 ns/op 0 B/op 0 allocs/op BenchmarkIterAllocs 20000000 82.2 ns/op 0 B/op 0 allocs/op ok so/test 7.026s $
package main import ( "fmt" "github.com/drgrib/iter" ) func main() { for i := range iter.N(10) { fmt.Println(i) } }
BenchmarkForMany-4 5000 329956 ns/op 0 B/op 0 allocs/op BenchmarkDrgribIterMany-4 5 229904527 ns/op 195 B/op 1 allocs/op BenchmarkBradfitzIterMany-4 5000 337952 ns/op 0 B/op 0 allocs/op BenchmarkFor10-4 500000000 3.27 ns/op 0 B/op 0 allocs/op BenchmarkDrgribIter10-4 500000 2907 ns/op 96 B/op 1 allocs/op BenchmarkBradfitzIter10-4 100000000 12.1 ns/op 0 B/op 0 allocs/op
package main import "fmt" func main() { nums := []int{2, 3, 4} for _, num := range nums { fmt.Println(num, sum) } }
import "github.com/wushilin/stream" stream1 := stream.Range(0, 10) stream1.Each(print) stream2 := stream1.Map(func(i int) int) { return i + 3 }) stream2.Reduce(func(i, j int) int { return i + j }) stream3 := stream.Of(1, 2,3,4,5) stream4 := stream.FromArray(arrayInput) stream3.Filter(func(i int) bool { return i > 2 }).Sum() => Filter stream3, keep only elements that is bigger than
import ( "http" . "launchpad.net/gocheck" "launchpad.net/lpad" "os" )
Import declaration Local name of Sin import "lib/math" math.Sin import M "lib/math" M.Sin import . "lib/math" Sin
package main import ( "fmt" "io/ioutil" "log" ) func main() { files, err := ioutil.ReadDir("./") if err != nil { log.Fatal(err) } for _, f := range files { fmt.Println(f.Name()) } }
package main import ( "fmt" "log" "path/filepath" ) func main() { files, err := filepath.Glob("*") if err != nil { log.Fatal(err) } fmt.Println(files) }
package main import ( "fmt" "io/ioutil" "log" "os" "path/filepath" ) func main() { var ( root string files []string err error ) root := "/home/manigandan/golang/samples" files, err = FilePathWalkDir(root) if err != nil { panic(err) } files, err = IOReadDir(root) if err != nil { panic(err) } files, err = OSReadDir(root) if err != nil { panic(err) } for _, file := range files { fmt.Println(file) } }
func FilePathWalkDir(root string) ([]string, error) { var files []string err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error { if !info.IsDir() { files = append(files, path) } return nil }) return files, err }
func IOReadDir(root string) ([]string, error) { var files []string fileInfo, err := ioutil.ReadDir(root) if err != nil { return files, err } for _, file := range fileInfo { files = append(files, file.Name()) } return files, nil }
func OSReadDir(root string) ([]string, error) { var files []string f, err := os.Open(root) if err != nil { return files, err } fileInfo, err := f.Readdir(-1) f.Close() if err != nil { return files, err } for _, file := range fileInfo { files = append(files, file.Name()) } return files, nil }
func contains(s []int, e int) bool { for _, a := range s { if a == e { return true } } return false }
package main import "fmt" func contains(slice []string, item string) bool { set := make(map[string]struct{}, len(slice)) for _, s := range slice { set[s] = struct{}{} } _, ok := set[item] return ok } func main() { s := []string{"a", "b"} s1 := "a" fmt.Println(contains(s, s1)) }
func HasElem(s interface{}, elem interface{}) bool { arrV := reflect.ValueOf(s) if arrV.Kind() == reflect.Slice { for i := 0; i < arrV.Len(); i++ { if arrV.Index(i).Interface() == elem { return true } } } return false }
type Identifiable interface{ GetIdentity() string } func IsIdentical(this Identifiable, that Identifiable) bool{ return (&this == &that) || (this.GetIdentity() == that.GetIdentity()) } func contains(s []Identifiable, e Identifiable) bool { for _, a := range s { if IsIdentical(a,e) { return true } } return false }
type Foo struct { Field1 string Field2 int } func Test(m Foo) bool { var allItems []Foo return deriveContainsFoo(allItems, m) }
func deriveContainsFoo(list []Foo, item Foo) bool { for _, v := range list { if v == item { return true } } return false }
func Contain(target interface{}, list interface{}) (bool, int) { if reflect.TypeOf(list).Kind() == reflect.Slice || reflect.TypeOf(list).Kind() == reflect.Array { listvalue := reflect.ValueOf(list) for i := 0; i < listvalue.Len(); i++ { if target == listvalue.Index(i).Interface() { return true, i } } } if reflect.TypeOf(target).Kind() == reflect.String && reflect.TypeOf(list).Kind() == reflect.String { return strings.Contains(list.(string), target.(string)), strings.Index(list.(string), target.(string)) } return false, -1 }
func oneWay() { var f func() var t *time.Timer f = func () { fmt.Println("doing stuff") t = time.AfterFunc(time.Duration(5) * time.Second, f) } t = time.AfterFunc(time.Duration(5) * time.Second, f) defer t.Stop() time.Sleep(time.Minute) }
ticker := time.NewTicker(5 * time.Second) quit := make(chan struct{}) go func() { for { select { case <- ticker.C: case <- quit: ticker.Stop() return } } }()
package main import ( "fmt" "time" ) func schedule(what func(), delay time.Duration) chan bool { stop := make(chan bool) go func() { for { what() select { case <-time.After(delay): case <-stop: return } } }() return stop } func main() { ping := func() { fmt.Println(" stop := schedule(ping, 5*time.Millisecond) time.Sleep(25 * time.Millisecond) stop <- true time.Sleep(25 * time.Millisecond) fmt.Println("Done") }
package main import "fmt" import "time" func main() { go heartBeat() time.Sleep(time.Second * 5) } func heartBeat(){ for range time.Tick(time.Second *1){ fmt.Println("Foo") } }
c := cron.New() c.AddFunc("0 30 * * * *", func() { fmt.Println("Every hour on the half hour") }) c.AddFunc("@hourly", func() { fmt.Println("Every hour") }) c.AddFunc("@every 1h30m", func() { fmt.Println("Every hour thirty") }) c.Start()
package main import ( "fmt" "time" ) func main() { now := time.Now() fmt.Println("\nToday:", now) after := now.Add(1 * time.Minute) fmt.Println("\nAdd 1 Minute:", after) for { fmt.Println("test") time.Sleep(10 * time.Second) now = time.Now() if now.After(after) { break } } fmt.Println("done") }
ticker := time.NewTicker(500 * time.Millisecond) go func() { for range ticker.C { fmt.Println("Tick") } }() time.Sleep(1600 * time.Millisecond) ticker.Stop()
tick := time.Tick(500 * time.Millisecond) for range tick { fmt.Println("Tick") }
type Config struct { Host string Port float64 setup bool } func NewConfig(host string, port float64) *Config { return &Config{host, port, true} } func (c *Config) Initialized() bool { return c != nil && c.setup }
package main import "fmt" type Config struct { host string port float64 } func main() { var c1 Config c2 := Config{} c3 := *new(Config) c4 := &Config{} c5 := new(Config) fmt.Println(&c1 == nil) fmt.Println(&c2 == nil) fmt.Println(&c3 == nil) fmt.Println(c4 == nil) fmt.Println(c5 == nil) fmt.Println(c1, c2, c3, c4, c5) }
false false false false false { 0} { 0} { 0} &{ 0} &{ 0}
package main import "fmt" type A struct { Name string } func main() { a := A{"Hello"} var b A if a == (A{}) { fmt.Println("A is empty") } if b == (A{}) { fmt.Println("B is empty") } }
func main() { a := []string{"Hello1", "Hello2", "Hello3"} fmt.Println(a) a = append(a[:0], a[1:]...) fmt.Println(a) }
a = append(a[:i], a[i+1:]...) a = a[:i+copy(a[i:], a[i+1:])]
var na []string for _, v := range a { if v == da { continue } else { na = append(na, v) } } a = na
package main import ( "fmt" "encoding/json" ) type User struct { name string } func main() { user := &User{name:"Frank"} b, err := json.Marshal(user) if err != nil { fmt.Printf("Error: %s", err) return; } fmt.Println(string(b)) }
package main import ( "fmt" "encoding/json" ) type User struct { Name string } func main() { user := &User{Name: "Frank"} b, err := json.Marshal(user) if err != nil { fmt.Println(err) return } fmt.Println(string(b)) }
type Foo struct { Number int `json:"number"` Title string `json:"title"` } foo_marshalled, err := json.Marshal(Foo{Number: 1, Title: "test"}) fmt.Fprint(w, string(foo_marshalled))
var Foo = JSON.parse(data); console.log("number: " + Foo.number); console.log("title: " + Foo.title);
package main import ( "fmt" "io/ioutil" ) func main() { b, err := ioutil.ReadFile("file.txt") if err != nil { fmt.Print(err) } fmt.Println(b) str := string(b) fmt.Println(str) }
buf := bytes.NewBuffer(nil) for _, filename := range filenames { f, _ := os.Open(filename) io.Copy(buf, f) f.Close() } s := string(buf.Bytes())
package main import ( "fmt" "os" "bytes" ) func main() { filerc, err := os.Open("filename") if err != nil{ log.Fatal(err) } defer filerc.Close() buf := new(bytes.Buffer) buf.ReadFrom(filerc) contents := buf.String() fmt.Print(contents) }
func NewKey(c appengine.Context, kind, stringID string, intID int64, parent *Key) *Key
global log 127.0.0.1 local0 maxconn 10000 user haproxy group haproxy daemon defaults log global mode http option httplog option dontlognull retries 3 timeout connect 5000 timeout client 50000 timeout server 50000 frontend http bind :80 acl is_stats hdr(host) -i hastats.myapp.com use_backend stats if is_stats default_backend myapp capture request header Host len 20 capture request header Referer len 50 backend myapp server main 127.0.0.1:4000 backend stats mode http stats enable stats scope http stats scope myapp stats realm Haproxy\ Statistics stats uri / stats auth username:password
start on runlevel [2345] stop on runlevel [!2345] chdir /home/myapp/myapp setgid myapp setuid myapp exec ./myapp start 1>>_logs/stdout.log 2>>_logs/stderr.log
[Unit] Description=My Go App [Service] Type=simple WorkingDirectory=/my/go/app/directory ExecStart=/usr/lib/go run main.go [Install] WantedBy=multi-user.target
systemctl enable my-go-daemon systemctl start my-go-daemon systemctl status my-go-daemon
myproject/ ├── binary1.go ├── binary2.go ├── package1.go └── package2.go
export GO111MODULE=on go mod init go mod vendor go build
myproject/ ├── binary1.go ├── binary2.go ├── package1/ │ └── package1.go └── package2.go
package math func add(n1, n2 int) int { return n1 + n2 }
package math func subtract(n1, n2 int) int { return n1 - n2 }
package math func donothing(n1, n2 int) int { s := add(n1, n2) s = subtract(n1, n2) return s }
src/github.com/GithubUser/myproject/ ├── main.go └───package_name └── whatever_name1.go └── whatever_name2.go
import "github.com/GithubUser/myproject/package_name"
- projects - go.mod - go.sum - project1 - main.go - project2 - main.go - package1 - lib.go - package2 - lib.go
buf := new(bytes.Buffer) buf.ReadFrom(yourReader) s := buf.String()
buf := new(bytes.Buffer) buf.ReadFrom(yourReader) b := buf.Bytes() s := *(*string)(unsafe.Pointer(&b))
if b, err := ioutil.ReadAll(rc); err == nil { return string(b) } ...
data, _ := ioutil.ReadAll(response.Body) fmt.Println(string(data))
func copyToString(r io.Reader) (res string, err error) { var sb strings.Builder if _, err = io.Copy(&sb, r); err == nil { res = sb.String() } return }
package main import "fmt" type convert func(int) string func value(x int) string { return fmt.Sprintf("%v", x) } func quote123(fn convert) string { return fmt.Sprintf("%q", fn(123)) } func main() { var result string result = value(123) fmt.Println(result) result = quote123(value) fmt.Println(result) result = quote123(func(x int) string { return fmt.Sprintf("%b", x) }) fmt.Println(result) foo := func(x int) string { return "foo" } result = quote123(foo) fmt.Println(result) _ = convert(foo) }
package main import "fmt" type fn func(int) func myfn1(i int) { fmt.Printf("\ni is %v", i) } func myfn2(i int) { fmt.Printf("\ni is %v", i) } func test(f fn, val int) { f(val) } func main() { test(myfn1, 123) test(myfn2, 321) }
func square(num int) int { return num * num } func mapper(f func(int) int, alist []int) []int { var a = make([]int, len(alist), len(alist)) for index, val := range alist { a[index] = f(val) } return a } func main() { alist := []int{4, 5, 6, 7} result := mapper(square, alist) fmt.Println(result) }
package main import "fmt" func plusTwo() (func(v int) (int)) { return func(v int) (int) { return v+2 } } func plusX(x int) (func(v int) (int)) { return func(v int) (int) { return v+x } } func main() { p := plusTwo() fmt.Printf("3+2: %d\n", p(3)) px := plusX(3) fmt.Printf("3+3: %d\n", px(3)) }
package main type EmployeeManager struct{ category string city string calculateSalary func() int64 } func NewEmployeeManager() (*EmployeeManager,error){ return &EmployeeManager{ category : "MANAGEMENT", city : "NY", calculateSalary: func() int64 { var calculatedSalary int64 return calculatedSalary }, },nil } func (self *EmployeeManager) emWithSalaryCalculation(){ self.calculateSalary = func() int64 { var calculatedSalary int64 return calculatedSalary } } func updateEmployeeInfo(em EmployeeManager){ } func processEmployee(){ updateEmployeeInfo(struct { category string city string calculateSalary func() int64 }{category: "", city: "", calculateSalary: func() int64 { var calculatedSalary int64 return calculatedSalary }}) }
import ( "fmt" "net/http" "text/template" "html/template" ) func handler_html(w http.ResponseWriter, r *http.Request) { t_html, err := html.template.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`) t_text, err := text.template.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`) }
import ( "text/template" htemplate "html/template" )
package main import ( t "text/template" h "html/template" ) func main() { t.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`) h.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`) }
func get_page(url string) string { get_dl_slot(url) defer free_dl_slot(url) resp, err := http.Get(url) if err != nil { return "" } defer resp.Body.Close() contents, err := ioutil.ReadAll(resp.Body) if err != nil { return "" } return string(contents) } func downloader() { dl_slots = make(chan bool, DL_SLOT_AMOUNT) content := get_page(BASE_URL) links_regexp := regexp.MustCompile(LIST_LINK_REGEXP) matches := links_regexp.FindAllStringSubmatch(content, -1) for _, match := range matches{ go serie_dl(match[1], match[2]) } }
import ( "testing" "net/http" "code.google.com/p/gomock" ) ... func TestDownloader (t *testing.T) { ctrl := gomock.NewController() defer ctrl.Finish() http.MOCK().SetController(ctrl) http.EXPECT().Get(BASE_URL) downloader() }
type PageGetter func(url string) string func downloader(pageGetterFunc PageGetter) { content := pageGetterFunc(BASE_URL) }
func get_page(url string) string { } func main() { downloader(get_page) }
func mock_get_page(url string) string { } func TestDownloader(t *testing.T) { downloader(mock_get_page) }
type PageGetter func(url string) string type Downloader struct { get_page PageGetter } func NewDownloader(pg PageGetter) *Downloader { return &Downloader{get_page: pg} } func (d *Downloader) download() { content := d.get_page(BASE_URL) }
func get_page(url string) string { } func main() { d := NewDownloader(get_page) d.download() }
func mock_get_page(url string) string { } func TestDownloader() { d := NewDownloader(mock_get_page) d.download() }
func TestDownloader(t *testing.T) { get_page = func(url string) string { if url != "expected" { t.Fatal("good message") } return "something" } downloader() }
package main import ( "fmt" ) type URI interface { GetURL() string } type MessageSender interface { SendMessage(message string) error } type API struct { baseURL string endpoint string } func (api *API) GetURL() string { return api.baseURL + api.endpoint } func (api *API) SendMessage(message string) error { return sendMessage(api, message) } func (api *API) SendDataSynchronously(data []string) error { return sendDataSynchronously(api, data) } func sendMessage(uri URI, message string) error { fmt.Println("This function won return nil } func sendDataSynchronously(sender MessageSender, data []string) error { for _, text := range data { err := sender.SendMessage(text) if err != nil { return err } } return nil } type mockedSender struct { err error messages []string } func (sender *mockedSender) SendMessage(message string) error { sender.messages = append(sender.messages, message) return sender.err } func TestSendsAllMessagesSynchronously() { mockedMessages := make([]string, 0) sender := mockedSender{nil, mockedMessages} messagesToSend := []string{"one", "two", "three"} err := sendDataSynchronously(&sender, messagesToSend) if err == nil { fmt.Println("All good here we expect the error to be nil:", err) } expectedMessages := fmt.Sprintf("%v", messagesToSend) actualMessages := fmt.Sprintf("%v", sender.messages) if expectedMessages == actualMessages { fmt.Println("Actual messages are as expected:", actualMessages) } } func main() { TestSendsAllMessagesSynchronously() }
var getPage = get_page func get_page (... func downloader() { dl_slots = make(chan bool, DL_SLOT_AMOUNT) content := getPage(BASE_URL) links_regexp := regexp.MustCompile(LIST_LINK_REGEXP) matches := links_regexp.FindAllStringSubmatch(content, -1) for _, match := range matches{ go serie_dl(match[1], match[2]) } }
func TestDownloader (t *testing.T) { origGetPage := getPage getPage = mock_get_page defer func() {getPage = origGatePage}() } func mock_get_page (....
func (requestCh chan<- Request) GetResponse(data RequestData) Response { reply := make(chan Response) requestCh <- Request{data: data, replyCh: reply} return <-reply }
bin/ streak todo pkg/ linux_amd64/ code.google.com/p/goauth2/ oauth.a github.com/nf/todo/ task.a src/ code.google.com/p/goauth2/ .hg/ oauth/ oauth.go oauth_test.go
camlistore/ cmd/ camget/ main.go cammount/ main.go camput/ main.go camtool/ main.go
adder/ adder.go cmd/ adder/ main.go adder-server/ main.go
$GOPATH/ src/ github.com/ jmcvetta/ useless/ .git/ useless.go useless_test.go README.md uselessd/ .git/ uselessd.go uselessd_test.go README.md
const ascii = "abcdefghijklmnopqrstuvwxyz" const letter_goodness []float32 = { .0817,.0149,.0278,.0425,.1270,.0223,.0202, .0609,.0697,.0015,.0077,.0402,.0241,.0675, .0751,.0193,.0009,.0599,.0633,.0906,.0276, .0098,.0236,.0015,.0197,.0007 } const letter_goodness = { .0817,.0149,.0278,.0425,.1270,.0223,.0202, .0609,.0697,.0015,.0077,.0402,.0241,.0675, .0751,.0193,.0009,.0599,.0633,.0906,.0276, .0098,.0236,.0015,.0197,.0007 } const letter_goodness = []float32 { .0817,.0149,.0278,.0425,.1270,.0223,.0202, .0609,.0697,.0015,.0077,.0402,.0241,.0675, .0751,.0193,.0009,.0599,.0633,.0906,.0276, .0098,.0236,.0015,.0197,.0007 }
var letter_goodness = [...]float32 {.0817, .0149, .0278, .0425, .1270, .0223, .0202, .0609, .0697, .0015, .0077, .0402, .0241, .0675, .0751, .0193, .0009, .0599, .0633, .0906, .0276, .0098, .0236, .0015, .0197, .0007 }
var TestSlice = []float32 {.03, .02} var TestArray = [2]float32 {.03, .02} var TestArray2 = [...]float32 {.03, .02}
var ThisIsPublic = [2]float32 {.03, .02} var thisIsPrivate = [2]float32 {.03, .02}
func main() { type Myint int const i1 Myint = 1 const i2 = Myint(2) fmt.Printf("%T %v\n", i1, i1) fmt.Printf("%T %v\n", i2, i2) }
func GetLetterGoodness() []float32 { return [...]float32 { .0817,.0149,.0278,.0425,.1270,.0223 } }
package main import ( "fmt" "strings" ) func main() { s := strings.Split("127.0.0.1:5432", ":") ip, port := s[0], s[1] fmt.Println(ip, port) }
package main import ( "fmt" "net" ) func main() { host, port, err := net.SplitHostPort("127.0.0.1:5432") fmt.Println(host, port, err) }
package main import ( "fmt" "strings" "errors" ) type PyString string func main() { var py PyString py = "127.0.0.1:5432" ip, port , err := py.Split(":") fmt.Println(ip, port, err) } func (py PyString) Split(str string) ( string, string , error ) { s := strings.Split(string(py), str) if len(s) < 2 { return "" , "", errors.New("Minimum match not found") } return s[0] , s[1] , nil }
import ( "fmt" "net" ) func main() { host1, port, err := net.SplitHostPort("127.0.0.1:5432") fmt.Println(host1, port, err) host2, port, err := net.SplitHostPort("[::1]:2345") fmt.Println(host2, port, err) host3, port, err := net.SplitHostPort("localhost:1234") fmt.Println(host3, port, err) }
127.0.0.1 5432 <nil> ::1 2345 <nil> localhost 1234 <nil>
package main import ( "fmt" "strings" ) func main() { strs := strings.Split("127.0.0.1:5432", ":") ip, port := str[0], str[1] fmt.Println(ip, port) }
// // // func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }
import net package host, port, err := net.SplitHostPort("0.0.0.1:8080") if err != nil { fmt.Println("Error is splitting : "+err.error()); } fmt.Println(host, port)
type ServerDetail struct { Host string Port string err error } ServerDetail = net.SplitHostPort("0.0.0.1:8080")
type ServerDetail struct { Host string Port string } ServerDetail = strings.Split([Your_String], ":")
import "github.com/go-on/queue/q" func SaveUser(w http.ResponseWriter, rq *http.Request) { u := &User{} err := q.Q( ioutil.ReadAll, rq.Body, )( json.Unmarshal, q.V, u, )( u.Validate, )( u.Save, )( ok, w, ).Run() if err != nil { switch err { case *json.SyntaxError: ... } } }
func f() error { handle err { fmt.Println(err); return err } check mayFail() check canFail() }
package main import "github.com/goerr/goerr" import "fmt" func ok(err error) { if err != nil { goerr.Return(err) } } func sequence() error { ok(do_something1()) ok(do_something2()) ok(do_something3()) return nil } func do_something1() error { return nil } func do_something2() error { return fmt.Errorf("2") } func do_something3() error { fmt.Println("DOING 3") return nil } func main() { err_do_something := goerr.OR1(sequence) fmt.Println(err_do_something) }
func Err(err error) { if err!=nil { fmt.Println("Oops", err) os.Exit(1) } } fi, err := os.Open("mmm.txt") Err(err)
type Page struct { PageId string `bson:"pageId"` Meta map[string]interface{} `bson:"meta"` }
type Page struct { PageId string `bson:"pageId",json:"pageId"` Meta map[string]interface{} `bson:"meta",json:"pageId"` }
type Page struct { PageId string `bson:"pageId" json:"pageId"` Meta map[string]interface{} `bson:"meta" json:"meta"` }
type Page struct { PageId string `bson:"pageId",json:"pageId"` Meta map[string]interface{} `bson:"meta",json:"pageId"` }
type Page struct { PageId string `bson:"pageId" json:"pageId"` Meta map[string]interface{} `bson:"meta" json:"pageId"` }
package main import ( "fmt" ) func main() { letters := []string{"a", "b", "c", "d"} fmt.Println(cap(letters)) fmt.Println(len(letters)) letters = letters[:0] fmt.Println(cap(letters)) fmt.Println(len(letters)) }
60 61 func (b *Buffer) Truncate(n int) { 62 b.lastRead = opInvalid 63 switch { 64 case n < 0 || n > b.Len(): 65 panic("bytes.Buffer: truncation out of range") 66 case n == 0: 67 68 b.off = 0 69 } 70 b.buf = b.buf[0 : b.off+n] 71 } 72 73 74 75 func (b *Buffer) Reset() { b.Truncate(0) }
package main import ( "fmt" ) func dump(letters []string) { fmt.Println("letters = ", letters) fmt.Println(cap(letters)) fmt.Println(len(letters)) for i := range letters { fmt.Println(i, letters[i]) } } func main() { letters := []string{"a", "b", "c", "d"} dump(letters) letters = nil dump(letters) letters = append(letters, "e") dump(letters) }
letters = [a b c d] 4 4 0 a 1 b 2 c 3 d letters = [] 0 0 letters = [e] 1 1 0 e
package main import "fmt" type Blah struct { babyKitten int kittenSays *string } func main() { meow := "meow" Blahs := []Blah{} fmt.Printf("Blahs: %v\n", Blahs) Blahs = append(Blahs, Blah{1, &meow}) fmt.Printf("Blahs: %v\n", Blahs) Blahs = append(Blahs, Blah{2, &meow}) fmt.Printf("Blahs: %v\n", Blahs) Blahs = nil meow2 := "nyan" fmt.Printf("Blahs: %v\n", Blahs) Blahs = append(Blahs, Blah{1, &meow2}) fmt.Printf("Blahs: %v\n", Blahs) fmt.Printf("kittenSays: %v\n", *Blahs[0].kittenSays) }
Blahs: [] Blahs: [{1 0x1030e0c0}] Blahs: [{1 0x1030e0c0} {2 0x1030e0c0}] Blahs: [] Blahs: [{1 0x1030e0f0}] kittenSays: nyan
Blahs: [] Blahs: [{1 0x1030e0c0}] Blahs: [{1 0x1030e0c0} {2 0x1030e0c0}] kittenSays: meow Blahs: [] Blahs: [{1 0x1030e0f8}] kittenSays: nyan
type Envelope struct { Body `xml:"soap:"` } type Body struct { Msg interface{} }
package main import ( "fmt" ) type Body struct { Msg interface{} } func main() { b := Body{} b.Msg = "5" fmt.Printf("% b.Msg = 5 fmt.Printf("% }
body := Body{3} fmt.Printf("% body = Body{"anything"} fmt.Printf("% body = Body{body} fmt.Printf("%
type Program struct { } func (p Program) Run() { } func (p Program) Stop() { }
package main import "fmt" func Bar() { fmt.Println("Bar") }
package main import "fmt" import "unicode/utf8" func main() { fmt.Println("Hello, 世界", len("世界"), utf8.RuneCountInString("世界")) }
RuneCount/lenruneslice/ASCII 27.8ns ± 2% 14.5ns ± 3% -47.70% (p=0.000 n=10+10) RuneCount/lenruneslice/Japanese 126ns ± 2% 60ns ± 2% -52.03% (p=0.000 n=10+10) RuneCount/lenruneslice/MixedLength 104ns ± 2% 50ns ± 1% -51.71% (p=0.000 n=10+9)
package main import "fmt" import "golang.org/x/text/unicode/norm" func main() { var ia norm.Iter ia.InitString(norm.NFKD, "école") nc := 0 for !ia.Done() { nc = nc + 1 ia.Next() } fmt.Printf("Number of chars: %d\n", nc) }
package main import "fmt" func main() { russian := "Спутник и погром" english := "Sputnik & pogrom" fmt.Println("count of bytes:", len(russian), len(english)) fmt.Println("count of runes:", len([]rune(russian)), len([]rune(english))) }
package main import ( "regexp" "unicode" "strings" ) func main() { str := "\u0308" + "a\u0308" + "o\u0308" + "u\u0308" str2 := "a" + strings.Repeat("\u0308", 1000) println(4 == GraphemeCountInString(str)) println(4 == GraphemeCountInString2(str)) println(1 == GraphemeCountInString(str2)) println(1 == GraphemeCountInString2(str2)) println(true == IsStreamSafeString(str)) println(false == IsStreamSafeString(str2)) } func GraphemeCountInString(str string) int { re := regexp.MustCompile("\\PM\\pM*|.") return len(re.FindAllString(str, -1)) } func GraphemeCountInString2(str string) int { length := 0 checked := false index := 0 for _, c := range str { if !unicode.Is(unicode.M, c) { length++ if checked == false { checked = true } } else if checked == false { length++ } index++ } return length } func IsStreamSafeString(str string) bool { re := regexp.MustCompile("\\PM\\pM{30,}") return !re.MatchString(str) }
listener, err := net.Listen("tcp", "localhost:https")
func exists(path string) (bool, error) { _, err := os.Stat(path) if err == nil { return true, nil } if os.IsNotExist(err) { return false, nil } return true, err }
if _, err := os.Stat("./conf/app.ini"); err != nil { if os.IsNotExist(err) { } else { } }
path := GetSomePath(); if stat, err := os.Stat(path); err == nil && stat.IsDir() { }
if _, err := os.Stat("/path/to/whatever"); os.IsNotExist(err) { } if _, err := os.Stat("/path/to/whatever"); err == nil { }
if _, err := os.Stat("./conf/app.ini"); err != nil { if os.IsNotExist(err) { ..... } else { ..... } }
t := time.Now() fmt.Println(t.Format("20060102150405"))
import "fmt" import "time" func main() { fmt.Println(time.Now().Format(time.RFC850)) }
t := time.Now() fmt.Println(t.Format("20060102150405"))
import "github.com/golang/protobuf/ptypes" Timestamp, _ = ptypes.TimestampProto(time.Now())
type Stringer interface { String() string } type MyType struct { value string } func (m *MyType) String() string { return m.value }
m := MyType{value: "something"} var s Stringer s = m
type MyType2 struct { MyType } m := MyType{value: "something"} m2 := MyType2{MyType: m} var s Stringer s = m2
type MyType2 struct { *MyType } m := MyType{value: "something"} m2 := MyType2{MyType: &m} var s Stringer s = m2
type MyType2 struct { *MyType } m := MyType{value: "something"} m2 := MyType2{MyType: &m} var s Stringer s = &m2
m := MyType{value: "something"} var i interface{} = m fmt.Println(i.(Stringer))
panic: interface conversion: main.MyType is not main.Stringer: missing method String
m := MyType{value: "something"} fmt.Println(Stringer(m))
package main import "fmt" type Loader interface { Load(src string) string } type WebLoader struct{} func (w *WebLoader) Load(src string) string { return fmt.Sprintf("I loaded this page %s", src) } func main() { webLoader := WebLoader{} loadContent(webLoader) } func loadContent(loader Loader) { loader.Load("google.com") }
type GetterSetter interface { GetVal() int SetVal(x int) int }
type MyTypeA struct { a int } func (m MyTypeA) GetVal() int { return a } func (m *MyTypeA) SetVal(newVal int) int { int oldVal = m.a m.a = newVal return oldVal }
myTypeInstance := MyType{ 7 } ... maybe some code doing other stuff ... var f interface{} = myTypeInstance _, ok := f.(GetterSetter) if !ok { t.Fail() }
myTypeInstance := MyType{ 7 } var f interface{} = &myTypeInstance ...
func SomeStuff(g GetterSetter, x int) int { if x > 10 { return g.GetVal() + 1 } return g.GetVal() }
func (m MyTypeA) OtherThing(x int) { SomeStuff(m, x) }
func (m *MyTypeA) OtherThing(x int) { SomeStuff(m, x) } func (m MyTypeA) OtherThing(x int) { SomeStuff(&m, x) }
for { switch sometest() { case 0: dosomething() case 1: break default: dosomethingelse() } }
loop: for { switch expr { case foo: if condA { doA() break } if condB { doB() break loop } doC() case bar: } A: doX() } B: doY()
package main import "fmt" func main() { myloop:for x := 0; x < 7; x++ { fmt.Printf("%d", x) switch { case x == 1: fmt.Println("start") case x == 5: fmt.Println("stop") break myloop case x > 2: fmt.Println("crunching..") break default: fmt.Println("idling..") } } }
0idling.. 1start 2idling.. 3crunching.. 4crunching.. 5stop Program exited.
for{ x := 1 switch { case x >0: fmt.Println("sjus") case x == 1: fmt.Println("GFVjk") default: fmt.Println("daslkjh") } } }
for{ x := 1 switch { case x >0: fmt.Println("sjus") break case x == 1: fmt.Println("GFVjk") default: fmt.Println("daslkjh") } } }
package main import "fmt" func main() { d: for{ x := 1 switch { case x >0: fmt.Println("sjus") break d case x == 1: fmt.Println("GFVjk") default: fmt.Println("daslkjh") } } }
a := 25 fallThrough := true switch { case a > 10 : fmt.Println("a>10") if fallThrough != true { break } fallthrough case a > 20: fmt.Println("a>20") }
package main import ( "path/filepath" "os" "flag" "fmt" ) func visit(path string, f os.FileInfo, err error) error { fmt.Printf("Visited: %s\n", path) return nil } func main() { flag.Parse() root := flag.Arg(0) err := filepath.Walk(root, visit) fmt.Printf("filepath.Walk() returned %v\n", err) }
$ mkdir -p dir1/dir2 $ touch dir1/file1 dir1/dir2/file2 $ go run walk.go dir1 Visited: dir1 Visited: dir1/dir2 Visited: dir1/dir2/file2 Visited: dir1/file1 filepath.Walk() returned <nil>
package main import ( "path/filepath" "os" "flag" ) type visitor int func (v visitor) VisitDir(path string, f *os.FileInfo) bool { println(path) return true } func (v visitor) VisitFile(path string, f *os.FileInfo) { println(path) } func main() { root := flag.Arg(0) filepath.Walk(root, visitor(0), nil) }
package main import ( "fmt" "os" "path/filepath" ) func main() { dirname := "." + string(filepath.Separator) d, err := os.Open(dirname) if err != nil { fmt.Println(err) os.Exit(1) } defer d.Close() fi, err := d.Readdir(-1) if err != nil { fmt.Println(err) os.Exit(1) } for _, fi := range fi { if fi.Mode().IsRegular() { fmt.Println(fi.Name(), fi.Size(), "bytes") } } }
package main import ( "fmt" "os" "path/filepath" ) func main() { searchDir := "c:/path/to/dir" fileList := []string{} err := filepath.Walk(searchDir, func(path string, f os.FileInfo, err error) error { fileList = append(fileList, path) return nil }) for _, file := range fileList { fmt.Println(file) } }
func searchFiles(dir string) { files, err := ioutil.ReadDir(dir) if err != nil { log.Fatal(err) } for _, file := range files { fmt.Println(file.Name()) } }
// // func ReadDirNumSort(dirname string, reverse bool) ([]os.FileInfo, error) { f, err := os.Open(dirname) if err != nil { return nil, err } list, err := f.Readdir(-1) f.Close() if err != nil { return nil, err } if reverse { sort.Sort(sort.Reverse(byName(list))) } else { sort.Sort(byName(list)) } return list, nil } type byName []os.FileInfo func (f byName) Len() int { return len(f) } func (f byName) Swap(i, j int) { f[i], f[j] = f[j], f[i] } func (f byName) Less(i, j int) bool { nai, err := strconv.Atoi(f[i].Name()) if err != nil { return f[i].Name() < f[j].Name() } naj, err := strconv.Atoi(f[j].Name()) if err != nil { return f[i].Name() < f[j].Name() } return nai < naj }
package main import ( "log" find "github.com/030/go-find/find" ) func main() { path, err := find.File("/home/user/go/src/github.com/030", "find.go") if err != nil { log.Fatal(err) } }
/home/user/go/src/github.com/030/go-find/find/find.go
c1 := make(chan string) c2 := make(chan string) go DoShit(c1, 5) go DoShit(c2, 2) for ; true; { select { case msg1 := <-c1: fmt.Println("received ", msg1) go DoShit(c1, 1) case msg2 := <-c2: fmt.Println("received ", msg2) go DoShit(c2, 9) } }
numChans := 2 var chans = [] chan string{} for i:=0;i<numChans;i++{ tmp := make(chan string); chans = append(chans, tmp); go DoShit(tmp, i + 1) for ; true; { select { case msg1 := <-c1: fmt.Println("received ", msg1) go DoShit(c1, 1) case msg2 := <-c2: fmt.Println("received ", msg2) go DoShit(c2, 9) } }
cases := make([]reflect.SelectCase, len(chans)) for i, ch := range chans { cases[i] = reflect.SelectCase{Dir: reflect.SelectRecv, Chan: reflect.ValueOf(ch)} } chosen, value, ok := reflect.Select(cases) ch := chans[chosen] msg := value.String()
agg := make(chan string) for _, ch := range chans { go func(c chan string) { for msg := range c { agg <- msg } }(ch) } select { case msg <- agg: fmt.Println("received ", msg) }
$ go test dynamic_select_test.go -test.bench=. ... BenchmarkReflectSelect 1 5265109013 ns/op BenchmarkGoSelect 20 81911344 ns/op ok command-line-arguments 9.463s
func Process1(chans []<-chan string, fn func(int, string)) { type item struct { int string } merged := make(chan item) var wg sync.WaitGroup wg.Add(len(chans)) for i, c := range chans { go func(i int, c <-chan string) { // for s := range c { merged <- item{i, s} } wg.Done() }(i, c) } go func() { wg.Wait() close(merged) }() for i := range merged { fn(i.int, i.string) } }
func Process2(chans []<-chan string, fn func(int, string)) { cases := make([]reflect.SelectCase, len(chans)) ids := make([]int, len(chans)) for i, c := range chans { cases[i] = reflect.SelectCase{ Dir: reflect.SelectRecv, Chan: reflect.ValueOf(c), } ids[i] = i } for len(cases) > 0 { i, v, ok := reflect.Select(cases) if !ok { cases = append(cases[:i], cases[i+1:]...) ids = append(ids[:i], ids[i+1:]...) continue } fn(ids[i], v.String()) } }
func main() { numChans := 2 var chans = []chan string{} for i := 0; i < numChans; i++ { tmp := make(chan string) chans = append(chans, tmp) } for true { for i, c := range chans { select { case x = <-c: fmt.Printf("received %d \n", i) go DoShit(x, i) default: continue } } } }
i := 23 i64 := int64(i) fmt.Printf("%T %T", i, i64)
$ cd $GOPATH $ go get github.com/examplesite/myprivaterepo
$ vim scheduler.go $ git add scheduler.go $ git commit $ git push
$ cd $GOPATH $ go get github.com/examplesite/myprivaterepo cd .; git clone https: Cloning into fatal: could not read Username for package github.com/examplesite/myprivaterepo: exit status 128
env GIT_TERMINAL_PROMPT=1 go get github.com/examplesite/myprivaterepo
package main func main() { println("Hello World!"); }
8g HelloWorld.go 8l -o HelloWorld.exe HelloWorld.8 HelloWorld
cannot use nil as type time.Time in return argument
func (Time) IsZero func (t Time) IsZero() bool IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.
func main() { cmd := exec.Command("/path/to/my/child/program") out, err := cmd.StdoutPipe() if err != nil { fmt.Println(err) } err = cmd.Start() if err != nil { fmt.Println(err) } cmd.Wait() }
func main() { cmd := exec.Command("ls", "-l") cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.Run() }
package main import ( "fmt" "io" "log" "os" "os/exec" ) func checkError(err error) { if err != nil { log.Fatalf("Error: %s", err) } } func main() { cmd := exec.Command("ls", "-l") stdout, err := cmd.StdoutPipe() checkError(err) stderr, err := cmd.StderrPipe() checkError(err) err = cmd.Start() checkError(err) defer cmd.Wait() go io.Copy(os.Stdout, stdout) go io.Copy(os.Stderr, stderr) fmt.Printf("Do other stuff here! No need to wait.\n\n") }
package main import "fmt" func main() { i := 5 f := float64(i) fmt.Printf("f is %f\n", f) }
uint8 the set of all unsigned 8-bit integers (0 to 255) uint16 the set of all unsigned 16-bit integers (0 to 65535) uint32 the set of all unsigned 32-bit integers (0 to 4294967295) uint64 the set of all unsigned 64-bit integers (0 to 18446744073709551615) int8 the set of all signed 8-bit integers (-128 to 127) int16 the set of all signed 16-bit integers (-32768 to 32767) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) int64 the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807) float32 the set of all IEEE-754 32-bit floating-point numbers float64 the set of all IEEE-754 64-bit floating-point numbers complex64 the set of all complex numbers with float32 real and imaginary parts complex128 the set of all complex numbers with float64 real and imaginary parts byte alias for uint8 rune alias for int32
package main import "fmt" func main() { var i int fmt.Println("Enter an Integer input: ") fmt.Scanf("%d", &i) f := float64(i) fmt.Printf("The float64 representation of %d is %f\n", i, f) }
>>> Enter an Integer input: >>> 232332 >>> The float64 representation of 232332 is 232332.000000
func ToFloat32(in int) float32 { return float32(in) } func ToFloat64(in int) float64 { return float64(in) }
lock(l); defer unlock(l); for i := 0; i <= 3; i++ { defer fmt.Print(i); }
package main import "fmt" func main() { f() fmt.Println("Returned normally from f.") } func f() { defer func() { if r := recover(); r != nil { fmt.Println("Recovered in f", r) } }() fmt.Println("Calling g.") g(0) fmt.Println("Returned normally from g.") } func g(i int) { if i > 3 { fmt.Println("Panicking!") panic(fmt.Sprintf("%v", i)) } defer fmt.Println("Defer in g", i) fmt.Println("Printing in g", i) g(i+1) }
jurily@jurily ~/workspace/go/euler31 $ 6g euler31.go jurily@jurily ~/workspace/go/euler31 $ cat euler31.6 amd64 exports automatically generated from euler31.go in package "main" import $$ package main var main.coin [9]int func main.howmany (amount int, max int) (? int) func main.main () var main.initdone· uint8 func main.init () $$ type main.dsigddd_1·1 struct { ? int } $$ ! <binary segment>
var a = []int{1,2,3}; for i, v := range a { fmt.Println(i, v); }
type IntArr []int func (a IntArr) each(fn func(index, value int)) { for i, v := range a { fn(i, v); } } func main() { var a = IntArr([]int{2,0,0,9}); var fnPrint = func (i, v int) { fmt.Println(i, ":", v); }; a.each(fnPrint); }
package main import ( "json" "fmt" "http" "os" "strings" ) func die(message string) { fmt.Printf("%s.\n", message); os.Exit(1); } func main() { kinopiko_flair := "https: response, _, err := http.Get(kinopiko_flair) if err != nil { die(fmt.Sprintf("Error getting %s", kinopiko_flair)) } var nr int const buf_size = 0x1000 buf := make([]byte, buf_size) nr, err = response.Body.Read(buf) if err != nil && error != os.EOF { die(fmt.Sprintf("Error reading response: %s", err.String())) } if nr >= buf_size { die ("Buffer overrun") } response.Body.Close() json_text := strings.Split(string(buf), "\000", 2) parsed, ok, errtok := json.StringToJson(json_text[0]) if ! ok { die(fmt.Sprintf("Error parsing JSON %s at %s", json_text, errtok)) } fmt.Printf("Your stackoverflow.com reputation is %s\n", parsed.Get ("reputation")) }
type ByteSize float64 const ( _ = iota; KB ByteSize = 1<<(10*iota) MB GB TB PB YB )
switch { case return c - case return c - case return c - } return 0
if return c- } else if return c - } else if return c - } return 0;
switch i := x.(type) { case nil: printString("x is nil"); case int: printInt(i); case float: printFloat(i); case func(int) float: printFunction(i); case bool, string: printString("type is bool or string"); default: printString("don }
package main import f "fmt" func main() { f.Printf("Hello World\n"); }
func nextInt(b []byte, pos int) (value, nextPos int) {
func ReadFull(r Reader, buf []byte) (n int, err os.Error) { for len(buf) > 0 && err == nil { var nr int; nr, err = r.Read(buf); n += nr; buf = buf[nr:len(buf)]; } return; }
/* * How many different ways can £2 be made using any number of coins? * Now with 100% less semicolons! */ package main import "fmt" /* This line took me over 10 minutes to figure out. * "[...]" means "figure out the size yourself" * If you only specify "[]", it will try to create a slice, which is a reference to an existing array. * Also, ":=" doesn */ var coin = [...]int{0, 1, 2, 5, 10, 20, 50, 100, 200} func howmany(amount int, max int) int { if amount == 0 { return 1 } if amount < 0 { return 0 } if max <= 0 && amount >= 1 { return 0 } return howmany(amount, max-1) + howmany(amount-coin[max], max) } func main() { fmt.Println(howmany(200, len(coin)-1)) }
var numText = "zero one two three four five six seven eight nine ten" var numRoman = "- I II III IV V VI VII IX X" var aText = strings.Split(numText, " ", 0) var aRoman = strings.Split(numRoman, " ", 0) type TextNumber int type RomanNumber int func (n TextNumber) String() string { return aText[n]; } func (n RomanNumber) String() string { return aRoman[n]; } func main() { var i = 5; fmt.Println("Number: ", i, TextNumber(i), RomanNumber(i)); }
func DoublingIterator(input chan int) chan int { outch := make(chan int); go func() { for x := range input { outch <- 2*x; } close(outch); }(); return outch; }
for { v := <-ch; if closed(ch) { break } fmt.Println(v) }
ticker := time.NewTicker(ns); select { case v := <- chan_target: do_something_with_v; case <- ticker.C: handle_timeout; }
TARG=foobar GOFILES=foo.go bar.go CGOFILES=bang.cgo OFILES=a_c_file.$O include $(GOROOT)/src/Make.$(GOARCH) include $(GOROOT)/src/Make.pkg
package main import "fmt"; import "os"; const stack_max = 100; type Stack2 struct { stack [stack_max]string; size int; }; func (s *Stack2) push (pushed_string string) { n := s.size; if n >= stack_max - 1 { fmt.Print ("Oh noes\n"); os.Exit (1); } s.size++; s.stack[n] = pushed_string } func (s *Stack2) pop () string { n := s.size; if n == 0 { fmt.Print ("Underflow\n"); os.Exit (1); } top := s.stack[n-1]; s.size--; return top; } func (s *Stack2) print_all () { n := s.size; fmt.Printf ("Stack size is %d\n", n); for i := 0; i < n; i++ { fmt.Printf ("%d:\t%s\n", i, s.stack[i]); } } func main () { stack := new (Stack2); stack.print_all (); stack.push ("boo"); stack.print_all (); popped := stack.pop (); fmt.Printf ("Stack top is %s\n", popped); stack.print_all (); stack.push ("moo"); stack.push ("zoo"); stack.print_all (); popped2 := stack.pop (); fmt.Printf ("Stack top is %s\n", popped2); stack.print_all (); }
package foo bar( a int32, b string )(c float32 ){ c = 1.3 + float32(a - int32(len(b)) }
void foo·bar(int32 a, String b, float32 c){ c = 1.3 + a - b.len; FLUSH(&c); }
package main import "fmt" import "os" type Stack2 struct { stack [10]string cur []string } func (s *Stack2) push(pushed_string string) { s.cur = append(s.cur, pushed_string) } func (s *Stack2) pop() (popped string) { if len(s.cur) == 0 { fmt.Print("Underflow\n") os.Exit(1) } popped = s.cur[len(s.cur)-1] s.cur = s.cur[0 : len(s.cur)-1] return } func (s *Stack2) print_all() { fmt.Printf("Stack size is %d\n", len(s.cur)) for i, s := range s.cur { fmt.Printf("%d:\t%s\n", i, s) } } func NewStack() (stack *Stack2) { stack = new(Stack2) stack.cur = stack.stack[0:0] return } func main() { stack := NewStack() stack.print_all() stack.push("boo") stack.print_all() popped := stack.pop() fmt.Printf("Stack top is %s\n", popped) stack.print_all() stack.push("moo") stack.push("zoo") stack.print_all() popped2 := stack.pop() fmt.Printf("Stack top is %s\n", popped2) stack.print_all() }
package main import "fmt" func weirdFunc(i int) interface{} { if i == 0 { return "zero" } return i } func main() { var i = 5 var w = weirdFunc(5) if tmp, ok := w.(int); ok { i += tmp } fmt.Println("i =", i) }
package main import "fmt" func weird(i int) interface{} { if i < 0 { return "negative" } return i } func main() { var i = 42 if w, ok := weird(7).(int); ok { i += w } if w, ok := weird(-100).(int); ok { i += w } fmt.Println("i =", i) } Output: i = 49
switch v := myInterface.(type) { case int: fmt.Printf("Integer: %v", v) case float64: fmt.Printf("Float64: %v", v) case string: fmt.Printf("String: %v", v) default: fmt.Printf("I don }
var data map[string]interface {} ... for k, v := range data { fmt.Printf("pair:%s\t%s\n", k, v) switch t := v.(type) { case int: fmt.Printf("Integer: %v\n", t) case float64: fmt.Printf("Float64: %v\n", t) case string: fmt.Printf("String: %v\n", t) case bool: fmt.Printf("Bool: %v\n", t) case []interface {}: for i,n := range t { fmt.Printf("Item: %v= %v\n", i, n) } default: var r = reflect.TypeOf(t) fmt.Printf("Other:%v\n", r) } }
var str = "hello!" var obj = reflect.ValueOf(&str) switch obj.Elem().Interface().(type) { case string: log.Println("obj contains a pointer to a string") default: log.Println("obj contains something else") }
func ToAnonymousType(obj interface{}) AnonymousType { return AnonymousType(reflect.ValueOf(obj)) }
func (a AnonymousType) IsA(typeToAssert reflect.Kind) bool { return typeToAssert == reflect.Value(a).Kind() }
var f float64 = 3.4 anon := ToAnonymousType(f) if anon.IsA(reflect.String) { fmt.Println("Its A String!") } else if anon.IsA(reflect.Float32) { fmt.Println("Its A Float32!") } else if anon.IsA(reflect.Float64) { fmt.Println("Its A Float64!") } else { fmt.Println("Failed") }
package main import ( "log" "net/http" ) func main() { _, err := http.Get("https: if err != nil { log.Fatal(err) } }
package main import ( "fmt" "net/http" "crypto/tls" ) func main() { http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true} _, err := http.Get("https: if err != nil { fmt.Println(err) } }
package main import ( "fmt" "net/http" "crypto/tls" ) func main() { tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, } client := &http.Client{Transport: tr} _, err := client.Get("https: if err != nil { fmt.Println(err) } }
defaultTransport := http.DefaultTransport.(*http.Transport) httpClientWithSelfSignedTLS := &http.Transport{ Proxy: defaultTransport.Proxy, DialContext: defaultTransport.DialContext, MaxIdleConns: defaultTransport.MaxIdleConns, IdleConnTimeout: defaultTransport.IdleConnTimeout, ExpectContinueTimeout: defaultTransport.ExpectContinueTimeout, TLSHandshakeTimeout: defaultTransport.TLSHandshakeTimeout, TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, }
tr := http.DefaultTransport.(*http.Transport) tr.TLSClientConfig.InsecureSkipVerify = true
package main import ( "flag" "fmt" "os" ) func usage() { fmt.Fprintf(os.Stderr, "usage: myprog [inputfile]\n") flag.PrintDefaults() os.Exit(2) } func main() { flag.Usage = usage flag.Parse() args := flag.Args() if len(args) < 1 { fmt.Println("Input file is missing."); os.Exit(1); } fmt.Printf("opening %s\n", args[0]); }
func usage() { fmt.Fprintf(os.Stderr, "usage: %s [inputfile]\n", os.Args[0]) flag.PrintDefaults() os.Exit(2) }
package main import "os" func main() { println("I am ", os.Args[0]) }
package main import "fmt" type Info struct { value string } func main() { table := make(map[string]*Info) for i := 0; i < 10; i++ { str := fmt.Sprintf("%v", i) table[str] = &Info{str} } for key, value := range table { fmt.Printf("deleting %v=>%v\n", key, value.value) delete(table, key) } }
for key := range m { if key.expired() { delete(m, key) } }
package main import ( log "github.com/Sirupsen/logrus" "os/signal" "os" "math/rand" "time" ) func main() { log.Info("=== START ===") defer func() { log.Info("=== DONE ===") }() go func() { m := make(map[string]string) for { k := GenerateRandStr(1024) m[k] = GenerateRandStr(1024*1024) for k2, _ := range m { delete(m, k2) break } } }() osSignals := make(chan os.Signal, 1) signal.Notify(osSignals, os.Interrupt) for { select { case <-osSignals: log.Info("Recieved ^C command. Exit") return } } } func GenerateRandStr(n int) string { rand.Seed(time.Now().UnixNano()) const letterBytes = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Int63() % int64(len(letterBytes))] } return string(b) }
type NetworkInterface struct { Gateway string `json:"gateway"` IPAddress string `json:"ip"` IPPrefixLen int `json:"ip_prefix_len"` MacAddress string `json:"mac"` ... }
n := NetworkInterface{ Gateway : "foo" } json.Marshal(n)
struct { microsec uint64 "field 1" serverIP6 uint64 "field 2" process string "field 3" }
import ("net/http"; "io"; "os") ... out, err := os.Create("output.txt") defer out.Close() ... resp, err := http.Get("http: defer resp.Body.Close() ... n, err := io.Copy(out, resp.Body)
import ( "os" "net/http" "io" ) func downloadFile(filepath string, url string) (err error) { out, err := os.Create(filepath) if err != nil { return err } defer out.Close() resp, err := http.Get(url) if err != nil { return err } defer resp.Body.Close() if resp.StatusCode != http.StatusOK { return fmt.Errorf("bad status: %s", resp.Status) } _, err = io.Copy(out, resp.Body) if err != nil { return err } return nil }
func HTTPDownload(uri string) ([]byte, error) { fmt.Printf("HTTPDownload From: %s.\n", uri) res, err := http.Get(uri) if err != nil { log.Fatal(err) } defer res.Body.Close() d, err := ioutil.ReadAll(res.Body) if err != nil { log.Fatal(err) } fmt.Printf("ReadFile: Size of download: %d\n", len(d)) return d, err } func WriteFile(dst string, d []byte) error { fmt.Printf("WriteFile: Size of download: %d\n", len(d)) err := ioutil.WriteFile(dst, d, 0444) if err != nil { log.Fatal(err) } return err } func DownloadToFile(uri string, dst string) { fmt.Printf("DownloadToFile From: %s.\n", uri) if d, err := HTTPDownload(uri); err == nil { fmt.Printf("downloaded %s.\n", uri) if WriteFile(dst, d) == nil { fmt.Printf("saved %s as %s\n", uri, dst) } } }
ProjectName/folderName1/file_test.go ProjectName/folderName2/file1_test.go ProjectName/folderName3/file2_test.go
ProjectName$ go test -v ./... ProjectName$ go test ./... ProjectName$ go test -cover ./...
ok ProjectName/folderName1 10% ok ProjectName/folerName2 90% ok ProjectName/folerName2 85%
client := &http.Client{} req, _ := http.NewRequest("GET", url, nil) res, _ := client.Do(req)
req, err := http.NewRequest("GET", "http: if err != nil { ... } req.Host = "domain.tld" resp, err := http.Client.Do(req)
func yourHandler(w http.ResponseWriter, r *http.Request) { w.Header().Set("header_name", "header_value") }
package main import ( "fmt" "sync" "time" ) func dosomething(millisecs time.Duration, wg *sync.WaitGroup) { duration := millisecs * time.Millisecond time.Sleep(duration) fmt.Println("Function in background, duration:", duration) wg.Done() } func main() { var wg sync.WaitGroup wg.Add(4) go dosomething(200, &wg) go dosomething(400, &wg) go dosomething(150, &wg) go dosomething(600, &wg) wg.Wait() fmt.Println("Done") }
Function in background, duration: 150ms Function in background, duration: 200ms Function in background, duration: 400ms Function in background, duration: 600ms Done
func main() { var wg sync.WaitGroup wg.Add(1) go dosomething(200, &wg) wg.Add(1) go dosomething(400, &wg) wg.Add(1) go dosomething(150, &wg) wg.Add(1) go dosomething(600, &wg) wg.Wait() fmt.Println("Done") }
func dosomething(millisecs time.Duration, wg *sync.WaitGroup) { wg.Add(1) go func() { duration := millisecs * time.Millisecond time.Sleep(duration) fmt.Println("Function in background, duration:", duration) wg.Done() }() }
func main() { var wg sync.WaitGroup dosomething(200, &wg) dosomething(400, &wg) dosomething(150, &wg) dosomething(600, &wg) wg.Wait() fmt.Println("Done") }
func dosomething(millisecs time.Duration, wg *sync.WaitGroup) { wg.Add(1) go func() { defer wg.Done() duration := millisecs * time.Millisecond time.Sleep(duration) fmt.Println("Function in background, duration:", duration) }() } func main() { var wg sync.WaitGroup dosomething(200, &wg) dosomething(400, &wg) dosomething(150, &wg) dosomething(600, &wg) wg.Wait() fmt.Println("Done") }
$ echo $GOROOT /usr/local/go $ echo $GOPATH /home/mitchell/go $ cat ~/main.go package main import "foobar" func main() { } $ cat /home/mitchell/go/src/foobar.go package foobar $ go build main.go main.go:3:8: import "foobar": cannot find package
func ReadLines(sFileName string, iMinLines int) ([]string, bool) {
func WriteLines(saBuff[]string, sFilename string) (bool) {
package main import ( "bufio" "fmt" "log" "os" ) func readLines(path string) ([]string, error) { file, err := os.Open(path) if err != nil { return nil, err } defer file.Close() var lines []string scanner := bufio.NewScanner(file) for scanner.Scan() { lines = append(lines, scanner.Text()) } return lines, scanner.Err() } func writeLines(lines []string, path string) error { file, err := os.Create(path) if err != nil { return err } defer file.Close() w := bufio.NewWriter(file) for _, line := range lines { fmt.Fprintln(w, line) } return w.Flush() } func main() { lines, err := readLines("foo.in.txt") if err != nil { log.Fatalf("readLines: %s", err) } for i, line := range lines { fmt.Println(i, line) } if err := writeLines(lines, "foo.out.txt"); err != nil { log.Fatalf("writeLines: %s", err) } }
content, err := ioutil.ReadFile(filename) if err != nil { } lines := strings.Split(string(content), "\n")
package main import ( "os" "bufio" "bytes" "io" "fmt" "strings" ) func readLines(path string) (lines []string, err error) { var ( file *os.File part []byte prefix bool ) if file, err = os.Open(path); err != nil { return } defer file.Close() reader := bufio.NewReader(file) buffer := bytes.NewBuffer(make([]byte, 0)) for { if part, prefix, err = reader.ReadLine(); err != nil { break } buffer.Write(part) if !prefix { lines = append(lines, buffer.String()) buffer.Reset() } } if err == io.EOF { err = nil } return } func writeLines(lines []string, path string) (err error) { var ( file *os.File ) if file, err = os.Create(path); err != nil { return } defer file.Close() for _,item := range lines { _, err := file.WriteString(strings.TrimSpace(item) + "\n"); if err != nil { fmt.Println(err) break } } /*content := strings.Join(lines, "\n") _, err = writer.WriteString(content)*/ return } func main() { lines, err := readLines("foo.txt") if err != nil { fmt.Println("Error: %s\n", err) return } for _, line := range lines { fmt.Println(line) } err = writeLines(lines, "foo2.txt") fmt.Println(err) }
package main import ( "os" "bufio" "bytes" "fmt" ) func readLines(path string) (lines []string, err os.Error) { var ( file *os.File part []byte prefix bool ) if file, err = os.Open(path); err != nil { return } reader := bufio.NewReader(file) buffer := bytes.NewBuffer(make([]byte, 1024)) for { if part, prefix, err = reader.ReadLine(); err != nil { break } buffer.Write(part) if !prefix { lines = append(lines, buffer.String()) buffer.Reset() } } if err == os.EOF { err = nil } return } func main() { lines, err := readLines("foo.txt") if err != nil { fmt.Println("Error: %s\n", err) return } for _, line := range lines { fmt.Println(line) } }
func readToDisplayUsingFile1(f *os.File){ defer f.Close() reader := bufio.NewReader(f) contents, _ := ioutil.ReadAll(reader) lines := strings.Split(string(contents), }
func readToDisplayUsingFile1(f *os.File){ defer f.Close() slice := make([]string,0) reader := bufio.NewReader(f) for{ str, err := reader.ReadString( if err == io.EOF{ break } slice = append(slice, str) }
defer resp.Body.Close() if resp.StatusCode != http.StatusOK { log.Println("StatusCode为" + strconv.Itoa(resp.StatusCode)) return } respByte, err := ioutil.ReadAll(resp.Body) if err != nil { log.Println("fail to read response data") return }
type intSlice []int func (slice intSlice) pos(value int) int { for p, v := range slice { if (v == value) { return p } } return -1 }
func SliceIndex(limit int, predicate func(i int) bool) int { for i := 0; i < limit; i++ { if predicate(i) { return i } } return -1 }
xs := []int{2, 4, 6, 8} ys := []string{"C", "B", "K", "A"} fmt.Println( SliceIndex(len(xs), func(i int) bool { return xs[i] == 5 }), SliceIndex(len(xs), func(i int) bool { return xs[i] == 6 }), SliceIndex(len(ys), func(i int) bool { return ys[i] == "Z" }), SliceIndex(len(ys), func(i int) bool { return ys[i] == "A" }))
func indexOf(element string, data []string) (int) { for k, v := range data { if element == v { return k } } return -1 }
package main import ( "sort" "log" ) var ints = [...]int{74, 59, 238, -784, 9845, 959, 905, 0, 0, 42, 7586, -5467984, 7586} func main() { data := ints a := sort.IntSlice(data[0:]) sort.Sort(a) pos := sort.SearchInts(a, -784) log.Println("Sorted: ", a) log.Println("Found at index ", pos) }
2009/11/10 23:00:00 Sorted: [-5467984 -784 0 0 42 59 74 238 905 959 7586 7586 9845] 2009/11/10 23:00:00 Found at index 1
func index(slice []string, item string) int { for i, _ := range slice { if slice[i] == item { return i } } return -1 }
GOPATH=/usr/local/Cellar/go/1.0.2/src/pkg/code.google.com/p/ export GOPATH
mkdir $HOME/Go mkdir -p $HOME/Go/src/github.com/user
export GOPATH=$HOME/Go export GOROOT=/usr/local/opt/go/libexec export PATH=$PATH:$GOPATH/bin export PATH=$PATH:$GOROOT/bin
export GOPATH="${HOME}/.go" export GOROOT="$(brew --prefix golang)/libexec" export PATH="$PATH:${GOPATH}/bin:${GOROOT}/bin" test -d "${GOPATH}" || mkdir "${GOPATH}" test -d "${GOPATH}/src/github.com" || mkdir -p "${GOPATH}/src/github.com"
$ brew install go ==> Downloading https: Already downloaded: /Users/nigel/Library/Caches/Homebrew/go-1.7.1.sierra.bottle.tar.gz ==> Pouring go-1.7.1.sierra.bottle.tar.gz ==> Caveats As of go 1.2, a valid GOPATH is required to use the `go get` command: https: You may wish to add the GOROOT-based install location to your PATH: export PATH=$PATH:/usr/local/opt/go/libexec/bin ==> Summary 🍺 /usr/local/Cellar/go/1.7.1: 6,436 files, 250.6M $ go get golang.org/x/tools/cmd/godoc $ go get github.com/golang/lint/golint $ go get golang.org/x/tour/gotour $ gotour 2016/10/19 12:06:54 Serving content from /Users/nigel/.go/src/golang.org/x/tour 2016/10/19 12:06:54 A browser window should open. If not, please visit http: 2016/10/19 12:06:55 accepting connection from: 127.0.0.1:52958
GOPATH=/usr/local/Cellar/go/1.0.2/src/pkg/code.google.com/p/ export GOPATH
$ gotour 2012/10/11 18:35:50 Serving content from /usr/local/Cellar/go/1.0.2/src/pkg/code.google.com/p/go-tour 2012/10/11 18:35:50 Open your web browser and visit http:
/usr/local/Cellar/go/1.0.2/src/pkg/code.google.com/p/
export GOPATH="${HOME}/.go" export GOROOT="$(brew --prefix golang)/libexec" export PATH="$PATH:${GOPATH}/bin:${GOROOT}/bin" test -d "${GOPATH}" || mkdir "${GOPATH}" test -d "${GOPATH}/src/github.com" || mkdir -p "${GOPATH}/src/github.com"
package main import "os" import "fmt" import "net/http" import "io/ioutil" import "encoding/json" type Tracks struct { Toptracks []Toptracks_info } type Toptracks_info struct { Track []Track_info Attr []Attr_info } type Track_info struct { Name string Duration string Listeners string Mbid string Url string Streamable []Streamable_info Artist []Artist_info Attr []Track_attr_info } type Attr_info struct { Country string Page string PerPage string TotalPages string Total string } type Streamable_info struct { Text string Fulltrack string } type Artist_info struct { Name string Mbid string Url string } type Track_attr_info struct { Rank string } func get_content() { url := "http: res, err := http.Get(url) if err != nil { panic(err.Error()) } body, err := ioutil.ReadAll(res.Body) if err != nil { panic(err.Error()) } var data Tracks json.Unmarshal(body, &data) fmt.Printf("Results: %v\n", data) os.Exit(0) } func main() { get_content() }
var myClient = &http.Client{Timeout: 10 * time.Second} func getJson(url string, target interface{}) error { r, err := myClient.Get(url) if err != nil { return err } defer r.Body.Close() return json.NewDecoder(r.Body).Decode(target) }
type Foo struct { Bar string } func main() { foo1 := new(Foo) getJson("http: println(foo1.Bar) foo2 := Foo{} getJson("http: println(foo2.Bar) }
package main import "fmt" import "net/http" import "io/ioutil" import "encoding/json" type Tracks struct { Toptracks Toptracks_info } type Toptracks_info struct { Track []Track_info Attr Attr_info `json: "@attr"` } type Track_info struct { Name string Duration string Listeners string Mbid string Url string Streamable Streamable_info Artist Artist_info Attr Track_attr_info `json: "@attr"` } type Attr_info struct { Country string Page string PerPage string TotalPages string Total string } type Streamable_info struct { Text string `json: " Fulltrack string } type Artist_info struct { Name string Mbid string Url string } type Track_attr_info struct { Rank string } func perror(err error) { if err != nil { panic(err) } } func get_content() { url := "http: res, err := http.Get(url) perror(err) defer res.Body.Close() decoder := json.NewDecoder(res.Body) var data Tracks err = decoder.Decode(&data) if err != nil { fmt.Printf("%T\n%s\n% switch v := err.(type){ case *json.SyntaxError: fmt.Println(string(body[v.Offset-40:v.Offset])) } } for i, track := range data.Toptracks.Track{ fmt.Printf("%d: %s %s\n", i, track.Artist.Name, track.Name) } } func main() { get_content() }
package main import "os" import "fmt" import "net/http" import "io/ioutil" import "encoding/json" type tracks struct { Toptracks []toptracks_info } type toptracks_info struct { Track []track_info Attr []attr_info } type track_info struct { Name string Duration string Listeners string Mbid string Url string Streamable []streamable_info Artist []artist_info Attr []track_attr_info } type attr_info struct { Country string Page string PerPage string TotalPages string Total string } type streamable_info struct { Text string Fulltrack string } type artist_info struct { Name string Mbid string Url string } type track_attr_info struct { Rank string } func get_content() { url := "http: res, err := http.Get(url) if err != nil { panic(err.Error()) } body, err := ioutil.ReadAll(res.Body) if err != nil { panic(err.Error()) } var data tracks json.Unmarshal(body, &data) fmt.Printf("Results: %v\n", data) os.Exit(0) } func main() { get_content() }
package main import ( "encoding/json" "fmt" "io/ioutil" "net/http" "os" ) type Tracks struct { Toptracks []Toptracks_info } type Toptracks_info struct { Track []Track_info Attr []Attr_info } type Track_info struct { Name string Duration string Listeners string Mbid string Url string Streamable []Streamable_info Artist []Artist_info Attr []Track_attr_info } type Attr_info struct { Country string Page string PerPage string TotalPages string Total string } type Streamable_info struct { Text string Fulltrack string } type Artist_info struct { Name string Mbid string Url string } type Track_attr_info struct { Rank string } func get_content() { url := "http: url += "&limit=1" res, err := http.Get(url) if err != nil { panic(err.Error()) } body, err := ioutil.ReadAll(res.Body) if err != nil { panic(err.Error()) } var data interface{} err = json.Unmarshal(body, &data) if err != nil { panic(err.Error()) } fmt.Printf("Results: %v\n", data) os.Exit(0) } func main() { get_content() }
Results: map[toptracks:map[track:map[name:Get Lucky (feat. Pharrell Williams) listeners:1863 url:http:
package main type Configuration struct { Val string Proxy struct { Address string Port string } } func main() { c := &Configuration{ Val: "test", Proxy: { Address: "addr", Port: "80", }, } }
type Configuration struct { Val string Proxy } type Proxy struct { Address string Port string } func main() { c := &Configuration{ Val: "test", Proxy: Proxy{ Address: "addr", Port: "port", }, } fmt.Println(c) }
c := &Configuration{ Val: "test", Proxy: struct { Address string Port string }{ Address: "addr", Port: "80", }, }
package main import "fmt" type Configuration struct { Val string Proxy struct { Address string Port string } } func main() { c := &Configuration{ Val: "test", } c.Proxy.Address = `127.0.0.1` c.Proxy.Port = `8080` }
type Proxy struct { Address string Port string } type Configuration struct { Val string P Proxy } c := &Configuration{ Val: "test", P: Proxy{ Address: "addr", Port: "80", }, }
type Configuration struct { Val string Proxy } type Proxy struct { Address string Port string } func main() { c := &Configuration{"test", Proxy{"addr", "port"}} fmt.Println(c) }
package animals type otherProps{ Name string Width int } type Duck{ Weight int otherProps }
package main import "github.com/someone/animals" func main(){ var duck animals.Duck duck.Weight = 2 duck.Width = 30 duck.Name = "Henry" }
package main import "fmt" type Address struct { streetNumber int streetName string zipCode int } type Person struct { name string age int address Address } func main() { var p Person p.name = "Vipin" p.age = 30 p.address = Address{ streetName: "Krishna Pura", streetNumber: 14, zipCode: 475110, } fmt.Println("Name: ", p.name) fmt.Println("Age: ", p.age) fmt.Println("StreetName: ", p.address.streetName) fmt.Println("StreeNumber: ", p.address.streetNumber) }
package main import "fmt" type Configuration struct { Val string Proxy struct { Address string Port string } } func main() { c := &Configuration{ Val: "test", Proxy: struct { Address string Port string }{ Address: "127.0.0.1", Port: "8080", }, } fmt.Println(c) }
package main type Configuration struct { Val string Proxy struct { Address string Port string } } func main() { c := new(Configuration) c.Val = "test" c.Proxy.Address = "addr" c.Proxy.Port = "80" }
type TestObject struct { kind string `json:"kind"` id string `json:"id, omitempty"` name string `json:"name"` email string `json:"email"` } func TestCreateSingleItemResponse(t *testing.T) { testObject := new(TestObject) testObject.kind = "TestObject" testObject.id = "f73h5jf8" testObject.name = "Yuri Gagarin" testObject.email = "Yuri.Gagarin@Vostok.com" fmt.Println(testObject) b, err := json.Marshal(testObject) if err != nil { fmt.Println(err) } fmt.Println(string(b[:])) }
[ `go test -test.run="^TestCreateSingleItemResponse$"` | done: 2.195666095s ] {TestObject f73h5jf8 Yuri Gagarin Yuri.Gagarin@Vostok.com} {} PASS
type TestObject struct { Kind string `json:"kind"` Id string `json:"id,omitempty"` Name string `json:"name"` Email string `json:"email"` }
var aName var BigBro var 123abc func (p *Person) SetEmail(email string) { p.email = email } func (p Person) email() string { return p.email }
Formatting control flags: -comments=true Print comments; if false, all comments are elided from the output. -tabs=true Indent with tabs; if false, spaces are used instead. -tabwidth=8 Tab width in spaces.
package main type Employee struct { name string age int } func NewEmployee() *Employee { p := &Employee{} return p } func PrintEmployee (p *Employee) { return "Hello world!" }
curl_easy_setopt(CURL *curl, CURLoption option, ...);
curl_wrapper_easy_setopt_str(CURL *curl, CURLoption option, char* param); curl_wrapper_easy_setopt_long(CURL *curl, CURLoption option, long param);
func (e *Easy)SetOption(option Option, param string) { e.code = Code(C.curl_wrapper_easy_setopt_str(e.curl, C.CURLoption(option), C.CString(param))) } func (e *Easy)SetOption(option Option, param long) { e.code = Code(C.curl_wrapper_easy_setopt_long(e.curl, C.CURLoption(option), C.long(param))) }
func switchboard(w http.ResponseWriter, r *http.Request) { uri := r.URL.RequestURI() if fp, err := os.Open("static" + uri); err == nil { defer fp.Close() staticHandler(w, r, fp) return } }
const html = ` <html> <body>Example embedded HTML content.</body> </html> ` w.Write([]byte(html))
var html = []byte(` <html><body>Example...</body></html> `) w.Write(html)
var html = `<p>This is a back quote followed by a dot: ` + "`" + `.</p>`
imgdata, err := ioutil.ReadFile("someimage.png") if err != nil { panic(err) } fmt.Print("var imgdata = []byte{") for i, v := range imgdata { if i > 0 { fmt.Print(", ") } fmt.Print(v) } fmt.Println("}")
var imgdata = []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}
data, err := ioutil.ReadFile("someimage.png") if err != nil { panic(err) } fmt.Println(base64.StdEncoding.EncodeToString(data))
const imgBase64 = "<insert base64 string here>" data, err := base64.StdEncoding.DecodeString(imgBase64)
data, err := ioutil.ReadFile("someimage.png") if err != nil { panic(err) } fmt.Println(strconv.Quote(string(data))
const imgdata = "\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"
var imgdata = []byte("\x00\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"
var imageArray = []uint8{/*$binfile("./image.png","uint8[]")$*/}
someString := "one two three four " words := strings.Fields(someString) fmt.Println(words, len(words))
s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)
n > 0: at most n substrings; the last substring will be the unsplit remainder. n == 0: the result is nil (zero substrings) n < 0: all substrings
import "regexp" r := regexp.MustCompile("[^\\s]+") r.FindAllString(" word1 word2 word3 word4 ", -1)
const localFileConstant string = "Constant Value with limited scope" const GlobalConstant string = "Everyone can use this"
package main import ( "fmt" "log" "os" ) var errorlog *os.File var logger *log.Logger func init() { errorlog, err := os.OpenFile(logfile, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666) if err != nil { fmt.Printf("error opening file: %v", err) os.Exit(1) } logger = log.New(errorlog, "applog: ", log.Lshortfile|log.LstdFlags) }
package customlogger import ( "log" "os" "sync" ) type logger struct { filename string *log.Logger } var logger *logger var once sync.Once func GetInstance() *logger { once.Do(func() { logger = createLogger("mylogger.log") }) return logger } func createLogger(fname string) *logger { file, _ := os.OpenFile(fname, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777) return &logger{ filename: fname, Logger: log.New(file, "My app Name ", log.Lshortfile), } }
package main import ( "customlogger" "fmt" "net/http" ) func main() { logger := customlogger.GetInstance() logger.Println("Starting") http.HandleFunc("/", sroot) http.ListenAndServe(":8080", nil) } func sroot(w http.ResponseWriter, r *http.Request) { logger := customlogger.GetInstance() fmt.Fprintf(w, "welcome") logger.Println("Starting") }
u := make([]byte, 16) _, err := rand.Read(u) if err != nil { return } u[8] = (u[8] | 0x80) & 0xBF u[6] = (u[6] | 0x40) & 0x4F return hex.EncodeToString(u)
u[8] = (u[8] | 0x80) & 0xBF u[6] = (u[6] | 0x40) & 0x4F
package main import ( "fmt" "log" "os/exec" ) func main() { out, err := exec.Command("uuidgen").Output() if err != nil { log.Fatal(err) } fmt.Printf("%s", out) }
$ go run uuid.go dc9076e9-2fda-4019-bd2c-900a8284b9c4
import "github.com/nu7hatch/gouuid" ... u, err := uuid.NewV4()
package main import ( "crypto/rand" "fmt" ) func pseudo_uuid() (uuid string) { b := make([]byte, 16) _, err := rand.Read(b) if err != nil { fmt.Println("Error: ", err) return } uuid = fmt.Sprintf("%X-%X-%X-%X-%X", b[0:4], b[4:6], b[6:8], b[8:10], b[10:]) return }
import "github.com/gofrs/uuid" u := uuid.Must(uuid.NewV4())
f, _ := os.Open("/dev/urandom") b := make([]byte, 16) f.Read(b) f.Close() uuid := fmt.Sprintf("%x-%x-%x-%x-%x", b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
u[6] = (u[6] | 0x40) & 0x4F u[8] = (u[8] | 0x80) & 0xBF
import "github.com/leonelquinteros/gorand" func main() { uuid, err := gorand.UUID() if err != nil { panic(err.Error()) } println(uuid) }
package main import "io/ioutil" import "fmt" func main() { u, _ := ioutil.ReadFile("/proc/sys/kernel/random/uuid") fmt.Println(string(u)) }
$ go run uuid.go 3ee995e3-0c96-4e30-ac1e-f7f04fd03e44
package main import ( "syscall" "unsafe" ) var ( modrpcrt4 = syscall.NewLazyDLL("rpcrt4.dll") procUuidCreate = modrpcrt4.NewProc("UuidCreate") ) const ( RPC_S_OK = 0 ) func NewUuid() ([]byte, error) { var uuid [16]byte rc, _, e := syscall.Syscall(procUuidCreate.Addr(), 1, uintptr(unsafe.Pointer(&uuid[0])), 0, 0) if int(rc) != RPC_S_OK { if e != 0 { return nil, error(e) } else { return nil, syscall.EINVAL } } return uuid[:], nil }
package util import( "net/http" "github.com/0xor1/gorillaseed/src/server/lib/mux" ) func (r *mux.Route) Subroute(tpl string, h http.Handler) *mux.Route{ return r.PathPrefix("/" + tpl).Subrouter().PathPrefix("/").Handler(h) } func (r *mux.Router) Subroute(tpl string, h http.Handler) *mux.Route{ return r.PathPrefix("/" + tpl).Subrouter().PathPrefix("/").Handler(h) }
type MyRouter mux.Router func (m *MyRouter) F() { ... }
type MyRouter struct { *mux.Router } func (m *MyRouter) F() { ... } ... r := &MyRouter{router} r.F()
type child struct { parent } type MyThing struct { *imported.Thing }
package main import ( "fmt" ) type parent struct { attr string } type childAlias parent type childObjParent struct { parent } type childPointerParent struct { *parent } func (p *parent) parentDo(s string) { fmt.Println(s) } func (c *childAlias) childAliasDo(s string) { fmt.Println(s) } func (c *childObjParent) childObjParentDo(s string) { fmt.Println(s) } func (c *childPointerParent) childPointerParentDo(s string) { fmt.Println(s) } func main() { p := &parent{"pAttr"} c1 := &childAlias{"cAliasAttr"} c2 := &childObjParent{} c3 := &childPointerParent{} c4 := &childPointerParent{&parent{}} c2.attr = "cObjParentAttr" c4.attr = "cPointerParentAttr" fmt.Println(p.attr) fmt.Println(c1.attr) fmt.Println(c2.attr) fmt.Println(c4.attr) p.parentDo("called parentDo on parent") c1.childAliasDo("called childAliasDo on ChildAlias") c2.childObjParentDo("called childObjParentDo on ChildObjParent") c3.childPointerParentDo("called childPointerParentDo on ChildPointerParent") c4.childPointerParentDo("called childPointerParentDo on ChildPointerParent") c2.parentDo("called parentDo on childObjParent") c3.parentDo("called parentDo on childPointerParent") c4.parentDo("called parentDo on childPointerParent") }
import "fmt" func main(){ fmt.Println("Hello world!") }
Function Behavior print prints all arguments; formatting of arguments is implementation-specific println like print but prints spaces between arguments and a newline at the end
ifdef GODEBUG GOPATH="${PWD}" go install github.com/mailgun/godebug GOPATH="${PWD}" ./bin/godebug build -instrument "${GODEBUG}" -o bin/rrdns rrdns
(gdb) print params $1 = (github.com/go-martini/martini.Params) 0x15582 <runtime.reentersyscall+450>
Pycharm -> Preference -> plugins -> search for go current version is Version: 0.10.749 IntelliJ -> Preference -> plugins -> search for go current version is Version: 0.10.749
const romanNumeralDict map[int]string = { 1000: "M", 900 : "CM", 500 : "D", 400 : "CD", 100 : "C", 90 : "XC", 50 : "L", 40 : "XL", 10 : "X", 9 : "IX", 5 : "V", 4 : "IV", 1 : "I", }
var romanNumeralDict = map[int]string{ 1000: "M", 900 : "CM", 500 : "D", 400 : "CD", 100 : "C", 90 : "XC", 50 : "L", 40 : "XL", 10 : "X", 9 : "IX", 5 : "V", 4 : "IV", 1 : "I", }
const myString = "hello" const pi = 3.14 const life int = 42
package main import ( "fmt" ) func romanNumeralDict() func(int) string { innerMap := map[int]string{ 1000: "M", 900: "CM", 500: "D", 400: "CD", 100: "C", 90: "XC", 50: "L", 40: "XL", 10: "X", 9: "IX", 5: "V", 4: "IV", 1: "I", } return func(key int) string { return innerMap[key] } } func main() { fmt.Println(romanNumeralDict()(10)) fmt.Println(romanNumeralDict()(100)) dict := romanNumeralDict() fmt.Println(dict(400)) }
var romanNumeralDict = func() map[int]string { return map[int]string { 1000: "M", 900: "CM", 500: "D", 400: "CD", 100: "C", 90: "XC", 50: "L", 40: "XL", 10: "X", 9: "IX", 5: "V", 4: "IV", 1: "I", } } func printRoman(key int) { fmt.Println(romanNumeralDict()[key]) } func printKeyN(key, n int) { fmt.Println(strings.Repeat(romanNumeralDict()[key], n)) } func main() { printRoman(1000) printRoman(50) printKeyN(10, 3) }
var romanNumeralDict = struct { m map[int]string }{m: map[int]string { 1000: "M", 900: "CM", }} func main() { d := 1000 fmt.Printf("Value of Key (%d): %s", d, romanNumeralDict.m[1000]) }
TEXT .mul(SB),4,$0-48 MOVUPS v1+0(FP), X0 MOVUPS v2+16(FP), X1 MULPS X1, X0 MOVUPS X0, toReturn+32(FP) RET
package simd type Vec4 [4]float32 func (v1 Vec4) Mul(v2 Vec4) Vec4 { return Vec4{v1[0] * v2[0], v1[1] * v2[1], v1[2] * v2[2], v1[3] * v2[3]} } func mul(v1, v2 Vec4) Vec4
package simd import ( "testing" ) func TestMul(t *testing.T) { v1 := Vec4{1, 2, 3, 4} v2 := Vec4{5, 6, 7, 8} res := v1.Mul(v2) res2 := mul(v1, v2) if res != res2 { t.Fatalf("Expected %v; got %v", res, res2) } }
simd.TestMul: call to external function simd.mul simd.TestMul: undefined: simd.mul
for x < 0 { if x > -1e-09 { goto small } z = z / x x = x + 1 } for x < 2 { if x < 1e-09 { goto small } z = z / x x = x + 1 } if x == 2 { return z } x = x - 2 p = (((((x*_gamP[0]+_gamP[1])*x+_gamP[2])*x+_gamP[3])*x+_gamP[4])*x+_gamP[5])*x + _gamP[6] q = ((((((x*_gamQ[0]+_gamQ[1])*x+_gamQ[2])*x+_gamQ[3])*x+_gamQ[4])*x+_gamQ[5])*x+_gamQ[6])*x + _gamQ[7] return z * p / q small: if x == 0 { return Inf(1) } return z / ((1 + Euler*x) * x) }
<< left shift integer << unsigned integer >> right shift integer >> unsigned integer
package main import ( "fmt" ) func main() { var t , i uint t , i = 1 , 1 for i = 1 ; i < 10 ; i++ { fmt.Printf("%d << %d = %d \n", t , i , t<<i) } fmt.Println() t = 512 for i = 1 ; i < 10 ; i++ { fmt.Printf("%d >> %d = %d \n", t , i , t>>i) } }
int main() { int t = 1 ; int i = 1 ; for(i = 1; i < 10; i++) { printf("%d << %d = %d \n", t, i, t << i); } printf("\n"); t = 512; for(i = 1; i < 10; i++) { printf("%d >> %d = %d \n", t, i, t >> i); } return 0; }
$t = $i = 1; for($i = 1; $i < 10; $i++) { printf("%d << %d = %d \n", $t, $i, $t << $i); } print PHP_EOL; $t = 512; for($i = 1; $i < 10; $i++) { printf("%d >> %d = %d \n", $t, $i, $t >> $i); }
1 << 1 = 2 1 << 2 = 4 1 << 3 = 8 1 << 4 = 16 1 << 5 = 32 1 << 6 = 64 1 << 7 = 128 1 << 8 = 256 1 << 9 = 512 512 >> 1 = 256 512 >> 2 = 128 512 >> 3 = 64 512 >> 4 = 32 512 >> 5 = 16 512 >> 6 = 8 512 >> 7 = 4 512 >> 8 = 2 512 >> 9 = 1
var u uint32 = 0x80000000; var i int32 = -2; u >> 1; i >> 1;
x := 10 y := uint(1025) println(x >> y) println(x << y)
{{define "base"}}<html> <head>{{template "head" .}}</head> <body>{{template "body" .}}</body> </html>{{end}} {{define "head"}}<title>index</title>{{end}} {{define "body"}}index{{end}} {{define "head"}}<title>other</title>{{end}} {{define "body"}}other{{end}}
tmpl := make(map[string]*template.Template) tmpl["index.html"] = template.Must(template.ParseFiles("index.html", "base.html")) tmpl["other.html"] = template.Must(template.ParseFiles("other.html", "base.html"))
{{define "base"}} <html> <div class="container"> {{.}} {{template "content" .}} </div> </body> </html> {{end}}
DomainsData := make(map[string]interface{}) DomainsData["domains"] = domains.Domains if err := groupsTemplate.ExecuteTemplate(w, "base", DomainsData); err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) }
<head>{{block "head" .}} Default Title {{end}}</head> <body>{{block "body" .}} default body {{end}}</body>
{{define "head"}}<title>index</title>{{end}} {{define "body"}}index{{end}} {{define "head"}}<title>other</title>{{end}} {{define "body"}}other{{end}}
tmpl["index.html"].ExecuteTemplate(os.Stdout, "base.html", data)
func foo() { } func GetFunctionName(i interface{}) string { } func main() { fmt.Println("name:", GetFunctionName(foo)) }
package main import ( "fmt" "reflect" "runtime" ) func foo() { } func GetFunctionName(i interface{}) string { return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name() } func main() { fmt.Println("name:", GetFunctionName(foo)) }
func Debug(format string, a ...interface{}) { _, file, line, _ := runtime.Caller(1) info := fmt.Sprintf(format, a...) log.Printf("[cgl] debug %s:%d %v", file, line, info)
type Foo struct { More String `json:"more"` Foo struct { Bar string `json:"bar"` Baz string `json:"baz"` } `json:"foo"` }
type A struct { FooBar string FooBaz string More string `json:"more"` } func (a *A) UnmarshalJSON(b []byte) error { var f interface{} json.Unmarshal(b, &f) m := f.(map[string]interface{}) foomap := m["foo"] v := foomap.(map[string]interface{}) a.FooBar = v["bar"].(string) a.FooBaz = v["baz"].(string) return nil }
package main import ( "fmt" "log" "encoding/json" ) type Results struct { Matches []Match } type Match struct { ThreatType string PlatformType string ThreatEntryType string Threat struct { URL string } } func main() { fmt.Println("Hello, playground") jsonResponse := `{"matches":[{"threatType":"MALWARE","platformType":"ANY_PLATFORM","threatEntryType":"URL","threat":{"url":"http: res := &Results{} err := json.Unmarshal([]byte(jsonResponse), res) if(err!=nil) { log.Fatal(err) } fmt.Printf("%v\n",res) fmt.Printf("\tThreat Type: %s\n",res.Matches[0].ThreatType) fmt.Printf("\tPlatform Type: %s\n",res.Matches[0].PlatformType) fmt.Printf("\tThreat Entry Type: %s\n",res.Matches[0].ThreatEntryType) fmt.Printf("\tURL: %s\n",res.Matches[0].Threat.URL) }
type NestedElement struct{ someNumber int `json:"number"` someString string `json:"string"` } type BaseElement struct { NestedElement `json:"bar"` }
package main import ( "encoding/json" "fmt" ) type Object struct { Foo map[string]map[string]string `json:"foo"` More string `json:"more"` } func main(){ someJSONString := []byte(`{"foo":{ "bar": "1", "baz": "2" }, "more": "text"}`) var obj Object err := json.Unmarshal(someJSONString, &obj) if err != nil{ fmt.Println(err) } fmt.Println("jsonObj", obj) }
message Msg { Firstname string = 1 [(gogoproto.jsontag) = "name.firstname"]; PseudoFirstname string = 2 [(gogoproto.jsontag) = "lastname"]; EmbedMsg = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true]; Lastname string = 4 [(gogoproto.jsontag) = "name.lastname"]; Inside string = 5 [(gogoproto.jsontag) = "name.inside.a.b.c"]; } message EmbedMsg{ Opt1 string = 1 [(gogoproto.jsontag) = "opt1"]; }
{ "lastname": "Three", "name": { "firstname": "One", "inside": { "a": { "b": { "c": "goo" } } }, "lastname": "Two" }, "opt1": "var" }
{ "MU": { "symbol": "MU", "title": "micro semiconductor", "share": 400, "purchase_price": 60.5, "target_price": 70 }, "LSCC":{ "symbol": "LSCC", "title": "lattice semiconductor", "share": 200, "purchase_price": 20, "target_price": 30 } }
package main import ( "encoding/json" "fmt" "io/ioutil" "log" "os" ) type Stock struct { Symbol string `json:"symbol"` Title string `json:"title"` Share int `json:"share"` PurchasePrice float64 `json:"purchase_price"` TargetPrice float64 `json:"target_price"` } type Account map[string]Stock func main() { raw, err := ioutil.ReadFile("stock.json") if err != nil { fmt.Println(err.Error()) os.Exit(1) } var account Account log.Println(account) }
timeout := time.Duration(5 * time.Second) client := http.Client{ Timeout: timeout, } client.Get(url)
var timeout = time.Duration(2 * time.Second) func dialTimeout(network, addr string) (net.Conn, error) { return net.DialTimeout(network, addr, timeout) } func main() { transport := http.Transport{ Dial: dialTimeout, } client := http.Client{ Transport: &transport, } resp, err := client.Get("http: }
package httpclient import ( "net" "net/http" "time" ) func TimeoutDialer(cTimeout time.Duration, rwTimeout time.Duration) func(net, addr string) (c net.Conn, err error) { return func(netw, addr string) (net.Conn, error) { conn, err := net.DialTimeout(netw, addr, cTimeout) if err != nil { return nil, err } conn.SetDeadline(time.Now().Add(rwTimeout)) return conn, nil } } func NewTimeoutClient(connectTimeout time.Duration, readWriteTimeout time.Duration) *http.Client { return &http.Client{ Transport: &http.Transport{ Dial: TimeoutDialer(connectTimeout, readWriteTimeout), }, } }
http.DefaultTransport.(*http.Transport).ResponseHeaderTimeout = time.Second * 45
var myTransport http.RoundTripper = &http.Transport{ Proxy: http.ProxyFromEnvironment, ResponseHeaderTimeout: time.Second * 45, } var myClient = &http.Client{Transport: myTransport} resp, err := myClient.Get(url) ...
ctx, cncl := context.WithTimeout(context.Background(), time.Second*3) defer cncl() req, _ := http.NewRequest(http.MethodGet, "https: resp, _ := http.DefaultClient.Do(req.WithContext(ctx))
func Reverse(s string) string { runes := []rune(s) for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 { runes[i], runes[j] = runes[j], runes[i] } return string(runes) }
package main import "fmt" func main() { input := "The quick brown 狐 jumped over the lazy 犬" n := 0 rune := make([]rune, len(input)) for _, r := range input { rune[n] = r n++ } rune = rune[0:n] for i := 0; i < n/2; i++ { rune[i], rune[n-1-i] = rune[n-1-i], rune[i] } output := string(rune) fmt.Println(output) }
func Reverse(s string) (result string) { for _,v := range s { result = string(v) + result } return }
func reverse(s string) string { o := make([]int, utf8.RuneCountInString(s)); i := len(o); for _, c := range s { i--; o[i] = c; } return string(o); }
/* Copyright 2014 Google Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http: Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) }
package main import "fmt" func Reverse(s string) string { n := len(s) runes := make([]rune, n) for _, rune := range s { n-- runes[n] = rune } return string(runes[n:]) } func main() { fmt.Println(Reverse(Reverse("Hello, 世界"))) fmt.Println(Reverse(Reverse("The quick brown 狐 jumped over the lazy 犬"))) }
func Reverse(text string) string { textRunes := []rune(text) textRunesLength := len(textRunes) if textRunesLength <= 1 { return text } i, j := 0, 0 for i < textRunesLength && j < textRunesLength { j = i + 1 for j < textRunesLength && isMark(textRunes[j]) { j++ } if isMark(textRunes[j-1]) { reverse(textRunes[i:j], j-i) } i = j } reverse(textRunes, textRunesLength) return string(textRunes) } func reverse(runes []rune, length int) { for i, j := 0, length-1; i < length/2; i, j = i+1, j-1 { runes[i], runes[j] = runes[j], runes[i] } } func isMark(r rune) bool { return unicode.Is(unicode.Mn, r) || unicode.Is(unicode.Me, r) || unicode.Is(unicode.Mc, r) }
func TestReverse(t *testing.T) { assert.Equal(t, Reverse(""), "") assert.Equal(t, Reverse("X"), "X") assert.Equal(t, Reverse("b\u0301"), "b\u0301") assert.Equal(t, Reverse("😎⚽"), "⚽😎") assert.Equal(t, Reverse("Les Mise\u0301rables"), "selbare\u0301siM seL") assert.Equal(t, Reverse("ab\u0301cde"), "edcb\u0301a") assert.Equal(t, Reverse("This `\xc5` is an invalid UTF8 character"), "retcarahc 8FTU dilavni na si `�` sihT") assert.Equal(t, Reverse("The quick bròwn 狐 jumped over the lazy 犬"), "犬 yzal eht revo depmuj 狐 nwòrb kciuq ehT") }
Benchmark_rmuller-4 100000 19246 ns/op Benchmark_peterSO-4 50000 28068 ns/op Benchmark_russ-4 50000 30007 ns/op Benchmark_ivan-4 50000 33694 ns/op Benchmark_yazu-4 50000 33372 ns/op Benchmark_yuku-4 50000 37556 ns/op Benchmark_simon-4 3000 426201 ns/op
func Reverse(s string) string { size := len(s) buf := make([]byte, size) for start := 0; start < size; { r, n := utf8.DecodeRuneInString(s[start:]) start += n utf8.EncodeRune(buf[size-start:], r) } return string(buf) }
import "strings"; func Reverse( orig string ) string { var c []string = strings.Split( orig, "", 0 ); for i, j := 0, len(c)-1; i < j; i, j = i+1, j-1 { c[i], c[j] = c[j], c[i] } return strings.Join( c, "" ); }
func Reverse( s string ) string { b := make([]byte, len(s)); var j int = len(s) - 1; for i := 0; i <= j; i++ { b[j-i] = s[i] } return string ( b ); }
func Reverse(s string) string { size := len(s) buf := make([]byte, size) for start := 0; start < size; { r, n := utf8.DecodeRuneInString(s[start:]) start += n utf8.EncodeRune(buf[size-start:], r) } return string(buf) } const ( s = "The quick brown 狐 jumped over the lazy 犬" reverse = "犬 yzal eht revo depmuj 狐 nworb kciuq ehT" ) func TestReverse(t *testing.T) { if Reverse(s) != reverse { t.Error(s) } } func BenchmarkReverse(b *testing.B) { for i := 0; i < b.N; i++ { Reverse(s) } }
package main import ( "unicode" "regexp" ) func main() { str := "\u0308" + "a\u0308" + "o\u0308" + "u\u0308" println("u\u0308" + "o\u0308" + "a\u0308" + "\u0308" == ReverseGrapheme(str)) println("u\u0308" + "o\u0308" + "a\u0308" + "\u0308" == ReverseGrapheme2(str)) } func ReverseGrapheme(str string) string { buf := []rune("") checked := false index := 0 ret := "" for _, c := range str { if !unicode.Is(unicode.M, c) { if len(buf) > 0 { ret = string(buf) + ret } buf = buf[:0] buf = append(buf, c) if checked == false { checked = true } } else if checked == false { ret = string(append([]rune(""), c)) + ret } else { buf = append(buf, c) } index += 1 } return string(buf) + ret } func ReverseGrapheme2(str string) string { re := regexp.MustCompile("\\PM\\pM*|.") slice := re.FindAllString(str, -1) length := len(slice) ret := "" for i := 0; i < length; i += 1 { ret += slice[length-1-i] } return ret }
package main import "container/vector"; import "fmt"; import "utf8"; import "bytes"; import "bufio"; func main() { toReverse := "Smørrebrød"; fmt.Println(toReverse); fmt.Println(reverse(toReverse)); } func reverse(str string) string { size := utf8.RuneCountInString(str); output := vector.NewIntVector(size); input := bufio.NewReader(bytes.NewBufferString(str)); for i := 1; i <= size; i++ { rune, _, _ := input.ReadRune(); output.Set(size - i, rune); } return string(output.Data()); }
func reverseStr(str string) (out string) { for _, s := range str { out = string(s) + out } return }
func Reverse(s string) string { b := make([]byte, len(s)); for i, j := len(s)-1, 0; i >= 0; i-- { if utf8.RuneStart(s[i]) { rune, size := utf8.DecodeRuneInString(s[i:len(s)]); utf8.EncodeRune(rune, b[j:j+size]); j += size; } } return string(b); }
func reverse(s string) string { l := len(s) m := make([]rune, l) for _, c := range s { l-- m[l] = c } return string(m) } func main() { str := "the quick brown 狐 jumped over the lazy 犬" fmt.Printf("reverse(%s): [%s]\n", str, reverse(str)) }
package stringutil import "code.google.com/p/go.text/unicode/norm" func Reverse(s string) string { bound := make([]int, 0, len(s) + 1) var iter norm.Iter iter.InitString(norm.NFD, s) bound = append(bound, 0) for !iter.Done() { iter.Next() bound = append(bound, iter.Pos()) } bound = append(bound, len(s)) out := make([]byte, 0, len(s)) for i := len(bound) - 2; i >= 0; i-- { out = append(out, s[bound[i]:bound[i+1]]...) } return string(out) }
func reverse(s string) (ret string) { for _, v := range s { defer func(r rune) { ret += string(r) }(v) } return }
package main import "fmt" func reverse(s string) string { chars := []rune(s) for i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 { chars[i], chars[j] = chars[j], chars[i] } return string(chars) } func main() { fmt.Printf("%v\n", reverse("abcdefg")) }
func Reverse(str string) string { if str != "" { return Reverse(str[1:]) + str[:1] } return "" }
func ReverseStr(s string) string { chars := []rune(s) rev := make([]rune, 0, len(chars)) for i := len(chars) - 1; i >= 0; i-- { rev = append(rev, chars[i]) } return string(rev) }
package main import "fmt" type Runes []rune func (s Runes) Reverse() (cp Runes) { l := len(s); cp = make(Runes, l) for i := 0; i <= l/2; i++ { cp[i], cp[l-1-i] = s[l-1-i], s[i] } return cp } func (s Runes) String() string { return string(s) } func main() { input := "The quick brown 狐 jumped over the lazy 犬 +odd" r := Runes(input) output := r.Reverse() valid := string(output.Reverse()) == input fmt.Println(len(r), len(output), r, output.Reverse(), valid) }
package reverseString import "strings" func ReverseString(s string) string { strLen := len(s) if strLen == 0 { return s } if strLen == 1 { return s } r := []rune(s) rLen := len(r) - 1 rev := []string{} for i := rLen; i >= 0; i-- { rev = append(rev, string(r[i])) } return strings.Join(rev, "") }
package reverseString import ( "fmt" "strings" "testing" ) func TestReverseString(t *testing.T) { s := "GO je úžasné!" r := ReverseString(s) fmt.Printf("Input: %s\nOutput: %s", s, r) revR := ReverseString(r) if strings.Compare(s, revR) != 0 { t.Errorf("Expecting: %s\n. Got: %s\n", s, revR) } }
Input: GO je úžasné! Output: !énsažú ej OG PASS ok github.com/alesr/reverse-string 0.098s
bs := []byte(s) var rs string for len(bs) > 0 { r, size := utf8.DecodeLastRune(bs) rs += fmt.Sprintf("%c", r) bs = bs[:len(bs)-size] }
bs := []byte(s) cs := make([]byte, len(bs)) b1 := 0 for len(bs) > 0 { r, size := utf8.DecodeLastRune(bs) d := make([]byte, size) _ = utf8.EncodeRune(d, r) b1 += copy(cs[b1:], d) bs = bs[:len(bs) - size] }
func reverseString(someString string) string { runeString := []rune(someString) var reverseString string for i := len(runeString)-1; i >= 0; i -- { reverseString += string(runeString[i]) } return reverseString }
...cannot convert val (type interface {}) to type int: need type assertion
var f interface{} err = json.Unmarshal([]byte(jsonStr), &f) if err != nil { utility.CreateErrorResponse(w, "Error: failed to parse JSON data.") return } m := f.(map[string]interface{}) val, ok := m["area_id"] if !ok { utility.CreateErrorResponse(w, "Error: Area ID is missing from submitted data.") return } fmt.Fprintf(w, "Type = %v", val) iAreaId := int(val) testName := "Area_" + iAreaId
fmt.Fprintf(w, "Type = %v", val) var iAreaId int = int(val.(float64))
package main import "fmt" import "strconv" func main() { var v interface{} v = "4" i, errInt := strconv.ParseInt(v.(string), 10, 64) if errInt == nil { fmt.Printf("%d is a int", i) } }
package main import "fmt" func main() { var val interface{} val = 4 var i int switch t := val.(type) { case int: fmt.Printf("%d == %T\n", t, t) i = t case int8: fmt.Printf("%d == %T\n", t, t) i = int(t) case int16: fmt.Printf("%d == %T\n", t, t) i = int(t) case int32: fmt.Printf("%d == %T\n", t, t) i = int(t) case int64: fmt.Printf("%d == %T\n", t, t) i = int(t) case bool: fmt.Printf("%t == %T\n", t, t) case float32: fmt.Printf("%g == %T\n", t, t) i = int(t) case float64: fmt.Printf("%f == %T\n", t, t) i = int(t) case uint8: fmt.Printf("%d == %T\n", t, t) i = int(t) case uint16: fmt.Printf("%d == %T\n", t, t) i = int(t) case uint32: fmt.Printf("%d == %T\n", t, t) i = int(t) case uint64: fmt.Printf("%d == %T\n", t, t) i = int(t) case string: fmt.Printf("%s == %T\n", t, t) default: fmt.Printf("%v == %T\n", t, t) } fmt.Printf("i == %d\n", i) }
js := jonson.New([]interface{}{55.6, 70.8, 10.4, 1, "48", "-90"}) js.SliceMap(func(jsn *jonson.JSON, index int) *jonson.JSON { jsn.MutateToInt() return jsn }).SliceMap(func(jsn *jonson.JSON, index int) *jonson.JSON { if jsn.GetUnsafeInt() > 50{ jsn.MutateToString() } return jsn })
import "fmt" func main() { fmt.Print(addTwoNumbers(5, 6)) } func addTwoNumbers(val1 interface{}, val2 interface{}) int { op1, _ := val1.(int) op2, _ := val2.(int) return op1 + op2 }
package main import "fmt" func foo(a interface{}) { fmt.Println(a.(int)) } func main() { var a int = 10 foo(a) }
package main func main () { var sessions = map[string] chan int{}; delete(sessions, "moo"); }
package main func main () { var sessions = map[string] chan int{}; sessions["moo"] = make (chan int); _, ok := sessions["moo"]; if ok { delete(sessions, "moo"); } }
package main import "fmt" func main() { var sessions = map[string] chan int{} sessions["somekey"] = make(chan int) fmt.Printf ("%d\n", len(sessions)) delete(sessions, "somekey") fmt.Printf ("%d\n", len(sessions)) }
{ "sendMsg":{"user":"ANisus","msg":"Trying to send a message"}, "say":"Hello" }
package main import ( "encoding/json" "fmt" ) type sendMsg struct { user string msg string } type say string func main(){ data := []byte(`{"sendMsg":{"user":"ANisus","msg":"Trying to send a message"},"say":"Hello"}`) objmap, err := json.MapObject(data) fmt.Printf("%v", objmap) }
var objmap map[string]*json.RawMessage err := json.Unmarshal(data, &objmap)
var s sendMsg err = json.Unmarshal(*objmap["sendMsg"], &s)
var str string err = json.Unmarshal(*objmap["say"], &str)
func main() { jsonStr := `{"Status":true,"ErrArr":[],"ObjArr":[{"Name":"My luxury car","ItemArr":[{"Name":"Bag"},{"Name":"Pen"}]}],"ObjMap":{}}` car := NewCar() i := iojson.NewIOJSON() if err := i.Decode(strings.NewReader(jsonStr)); err != nil { fmt.Printf("err: %s\n", err.Error()) } if v, err := i.GetObjFromArr(0, car); err != nil { fmt.Printf("err: %s\n", err.Error()) } else { fmt.Printf("car (original): %s\n", car.GetName()) fmt.Printf("car (returned): %s\n", v.(*Car).GetName()) for k, item := range car.ItemArr { fmt.Printf("ItemArr[%d] of car (original): %s\n", k, item.GetName()) } for k, item := range v.(*Car).ItemArr { fmt.Printf("ItemArr[%d] of car (returned): %s\n", k, item.GetName()) } } }
car (original): My luxury car car (returned): My luxury car ItemArr[0] of car (original): Bag ItemArr[1] of car (original): Pen ItemArr[0] of car (returned): Bag ItemArr[1] of car (returned): Pen
package main import "fmt" import "time" func main() { tm, err := time.Parse("1136239445", "1405544146") if err != nil{ panic(err) } fmt.Println(tm) }
package main import ( "fmt" "time" "strconv" ) func main() { i, err := strconv.ParseInt("1405544146", 10, 64) if err != nil { panic(err) } tm := time.Unix(i, 0) fmt.Println(tm) }
package main import ( "fmt" "time" ) func main() { unixTimeUTC:=time.Unix(1405544146, 0) unitTimeInRFC3339 :=unixTimeUTC.Format(time.RFC3339) fmt.Println("unix time stamp in UTC :--->",unixTimeUTC) fmt.Println("unix time stamp in unitTimeInRFC3339 format :->",unitTimeInRFC3339)
unix time stamp in UTC :---> 2014-07-16 20:55:46 +0000 UTC unix time stamp in unitTimeInRFC3339 format :----> 2014-07-16T20:55:46Z
func GetTimeStamp() string { loc, _ := time.LoadLocation("America/Los_Angeles") t := time.Now().In(loc) return t.Format("20060102150405") } func GetTodaysDate() string { loc, _ := time.LoadLocation("America/Los_Angeles") current_time := time.Now().In(loc) return current_time.Format("2006-01-02") } func GetTodaysDateTime() string { loc, _ := time.LoadLocation("America/Los_Angeles") current_time := time.Now().In(loc) return current_time.Format("2006-01-02 15:04:05") } func GetTodaysDateTimeFormatted() string { loc, _ := time.LoadLocation("America/Los_Angeles") current_time := time.Now().In(loc) return current_time.Format("Jan 2, 2006 at 3:04 PM") } func GetTimeStampFromDate(dtformat string) string { form := "Jan 2, 2006 at 3:04 PM" t2, _ := time.Parse(form, dtformat) return t2.Format("20060102150405") }
i, err := strconv.ParseInt("1405544146", 10, 64) if err != nil { panic(err) } tm := time.Unix(i, 0) fmt.Println(tm.UTC())
package main import ( "fmt" "time" ) func main() { fromString := "Wed, 6 Sep 2017 10:43:01 +0300" t, e := time.Parse("Mon, _2 Jan 2006 15:04:05 -0700", fromString) if e != nil { fmt.Printf("err: %s\n", e) } fmt.Printf("UTC time: %v\n", t.UTC()) }
var minLen uint = ??? var maxLen uint = 0 for _, thing := range sliceOfThings { if minLen > thing.n { minLen = thing.n } if maxLen < thing.n { maxLen = thing.n } } if minLen > maxLen { minLen = 0 }
const MaxUint = ^uint(0) const MinUint = 0 const MaxInt = int(MaxUint >> 1) const MinInt = -MaxInt - 1
uint8 : 0 to 255 uint16 : 0 to 65535 uint32 : 0 to 4294967295 uint64 : 0 to 18446744073709551615 int8 : -128 to 127 int16 : -32768 to 32767 int32 : -2147483648 to 2147483647 int64 : -9223372036854775808 to 9223372036854775807
func printMinMaxValue() { fmt.Printf("max int64 = %+v\n", math.MaxInt64) fmt.Printf("max int32 = %+v\n", math.MaxInt32) fmt.Printf("max int16 = %+v\n", math.MaxInt16) fmt.Printf("min int64 = %+v\n", math.MinInt64) fmt.Printf("min int32 = %+v\n", math.MinInt32) fmt.Printf("max flloat64= %+v\n", math.MaxFloat64) fmt.Printf("max float32= %+v\n", math.MaxFloat32) }
max int64 = 9223372036854775807 max int32 = 2147483647 max int16 = 32767 min int64 = -9223372036854775808 min int32 = -2147483648 max flloat64= 1.7976931348623157e+308 max float32= 3.4028234663852886e+38
const ( MinUint uint = 0 MaxUint = ^MinUint MaxInt = int(MaxUint >> 1) MinInt = ^MaxInt )
var minLen, maxLen uint if len(sliceOfThings) > 0 { minLen = sliceOfThings[0].minLen maxLen = sliceOfThings[0].maxLen for _, thing := range sliceOfThings[1:] { if minLen > thing.minLen { minLen = thing.minLen } if maxLen < thing.maxLen { maxLen = thing.maxLen } } }
func newHandler(w http.ResponseWriter, r *http.Request) { fmt.Println("GET params were:", r.URL.Query()) param1 := r.URL.Query().Get("param1") if param1 != "" { } param1s := r.URL.Query()["param1"] if param1s != nil { } }
package main import ( "io" "net/http" ) func queryParamDisplayHandler(res http.ResponseWriter, req *http.Request) { io.WriteString(res, "name: "+req.FormValue("name")) io.WriteString(res, "\nphone: "+req.FormValue("phone")) } func main() { http.HandleFunc("/example", func(res http.ResponseWriter, req *http.Request) { queryParamDisplayHandler(res, req) }) println("Enter this in your browser: http: http.ListenAndServe(":8080", nil) }
func parseRequest(req *http.Request) error { var err error if err = req.ParseForm(); err != nil { log.Error("Error parsing form: %s", err) return err } _ = req.Form.Get("xxx") return nil }
package main import ( "fmt" "io/ioutil" "path" "path/filepath" "os" "runtime" "time" ) func eachFile(extension string, callback func(file string)) { exeDir := filepath.Dir(os.Args[0]) files, _ := ioutil.ReadDir(exeDir) for _, f := range files { fileName := f.Name() if extension == path.Ext(fileName) { go callback(fileName) } } } func main() { maxProcs := runtime.NumCPU() runtime.GOMAXPROCS(maxProcs) eachFile(".xml", func(fileName string) { fmt.Println(fileName) }) time.Sleep(100 * time.Millisecond) }
package main import ( "net/http" "sync" ) func main() { var wg sync.WaitGroup var urls = []string{ "http: "http: "http: } for _, url := range urls { wg.Add(1) go func(url string) { defer wg.Done() http.Get(url) }(url) } wg.Wait() }
func main() { c := make(chan struct{}) for i := 0; i < 100; i++ { go func() { doSomething() c <- struct{}{} }() } for i := 0; i < 100; i++ { <- c } }
package main import ( "fmt" "sync" "time" ) func wait(seconds int, wg * sync.WaitGroup) { defer wg.Done() time.Sleep(time.Duration(seconds) * time.Second) fmt.Println("Slept ", seconds, " seconds ..") } func main() { var wg sync.WaitGroup for i := 0; i <= 5; i++ { wg.Add(1) go wait(i, &wg) } wg.Wait() }
// type recursionController struct { results chan string children chan int done chan int } func NewRecursionController() recursionController { return recursionController{make(chan string, 1000), make(chan int), make(chan int)} } func (rc recursionController) Add(children int) { rc.children <- children } func (rc recursionController) Done() { rc.done <- 1 } func (rc recursionController) Wait() { fmt.Println("Controller waiting...") var children, done int for { select { case childrenDelta := <-rc.children: children += childrenDelta case <-rc.done: done += 1 default: if done > 0 && children == done { fmt.Printf("Controller exiting, done = %v, children = %v\n", done, children) close(rc.results) return } } } }
type Something struct { Text string DefaultText string } func NewSomething(text string) Something { something := Something{} something.Text = text something.DefaultText = "default text" return something }
package candidate type Candidate interface {} type candidate struct { Name string Votes unit32 } func New(name string) Candidate { return candidate{name, 0} }
func NewFile(fd int, name string) *File { if fd < 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f }
type Config struct { AWSRegion string `default:"us-west-2"` }
package main import "fmt" func main() { myArray :=[...]int{12,14,26} ; fmt.Println(myArray) myArray :=[...]int{11,12,14} fmt.Println(myArray) ; }
package main import "fmt" func main() { a, b := 1, 2 c, b := 3, 4 fmt.Println(a, b, c) }
type job struct { url string depth int } queue := make(chan job) queue <- job{url, depth}
package main import "fmt" func main() { queue := make(chan struct {string; int}) go sendPair(queue) pair := <-queue fmt.Println(pair.string, pair.int) } func sendPair(queue chan struct {string; int}) { queue <- struct {string; int}{"http:...", 3} }
package main import "fmt" type Pair struct { a, b interface{} } func main() { p1 := Pair{"finished", 42} p2 := Pair{6.1, "hello"} fmt.Println("p1=", p1, "p2=", p2) fmt.Println("p1.b", p1.b) s := p1.a.(string) + " now" fmt.Println("p1.a", s) }
func zero(x int) { x = 0 } func main() { x := 5 zero(x) fmt.Println(x) }
func zero(xPtr *int) { *xPtr = 0 } func main() { x := 5 zero(&x) fmt.Println(x) }
type Point struct { x, y int } type LineSegment struct { source, destination Point }
type TreeNode { value int left *TreeNode right *TreeNode }
type TreeNode { value int left *TreeNode right *TreeNode nextFreeNode *TreeNode; } var pool [1024]TreeNode var firstFreeNode *TreeNode = &pool[0] func poolAlloc() *TreeNode { node := firstFreeNode firstFreeNode = firstFreeNode.nextFreeNode return node } func freeNode(node *TreeNode) { node.nextFreeNode = firstFreeNode firstFreeNode = node }
func swap(a *int, b *int) { temp := *a *a = *b *b = temp }
import ( "log" "database/sql" _ "github.com/go-sql-driver/mysql" )
import ( "bufio" "fmt" "os" "path/filepath" ) var _, _, _, _ = fmt.Println, bufio.NewReader, os.Open, filepath.IsAbs
func TestPrintSomething(t *testing.T) { fmt.Println("Say hi") }
func TestPrintSomethingAgain(t *testing.T) { t.Error("Say hi") }
Say hi --- FAIL: TestPrintSomethingAgain (0.00 seconds) foo_test.go:35: Say hi FAIL FAIL command-line-arguments 0.003s gom: exit status 1
package verbose import ( "fmt" "testing" ) func TestPrintSomething(t *testing.T) { fmt.Println("Say hi") t.Log("Say bye") }
go test -v === RUN TestPrintSomething Say hi --- PASS: TestPrintSomething (0.00 seconds) v_test.go:10: Say bye PASS ok so/v 0.002s
-v Verbose output: log all tests as they are run. Also print all text from Log and Logf calls even if the test succeeds.
func DPrintf(format string, a ...interface{}) (n int, err error) { if Debug > 0 { n, err = fmt.Printf(format, a...) } return }
s := []interface{}{"First", "Second", "Third"} fmt.Println(s...)
func Greeting(prefix string, who ...string) Greeting("nobody") Greeting("hello:", "Joe", "Anna", "Eileen")
s := []string{"James", "Jasmine"} Greeting("goodbye:", s...)
git clone git@github.com:you/repo.git $GOPATH/src/github.com/someone/repo
cd $GOPATH mkdir -p {src,bin,pkg} mkdir -p src/github.com/awesome-org/ cd src/github.com/awesome-org/ git clone git@github.com:awesome-you/tool.git cd tool/ go get ./...
go get github.com/my/repo cd ~/go/src/github.com/my/repo git branch enhancement rm -rf . go get github.com/golang/tools/cmd/gomvpkg/… gomvpkg <<oldrepo>> ~/go/src/github.com/my/repo git commit
git commit git checkout enhancement git cherry-pick <<commit_id>>
function gofork() { if [ $ echo echo return fi echo "Go get fork $1 and replace $2 in GOPATH: $GOPATH" go get $1 go get $2 currentDir=$PWD cd $GOPATH/src/$1 remote1=$(git config --get remote.origin.url) cd $GOPATH/src/$2 remote2=$(git config --get remote.origin.url) cd $currentDir rm -rf $GOPATH/src/$2 mv $GOPATH/src/$1 $GOPATH/src/$2 cd $GOPATH/src/$2 git remote add their $remote2 echo Now in $GOPATH/src/$2 origin remote is $remote1 echo And in $GOPATH/src/$2 their remote is $remote2 cd $currentDir } export -f gofork
cd ~/go/src/github.com/myproj mygithubuser=timabell upstreamgithubuser=denisenkom librepo=go-mssqldb git submodule add "git@github.com:$mygithubuser/$librepo" "vendor/$upstreamgithubuser/$librepo"
package bufio: unrecognized import path "bufio" package bytes: unrecognized import path "bytes" package crypto/rand: unrecognized import path "crypto/rand" package crypto/sha1: unrecognized import path "crypto/sha1" package crypto/tls: unrecognized import path "crypto/tls" package encoding/base64: unrecognized import path "encoding/base64" package encoding/binary: unrecognized import path "encoding/binary" package encoding/json: unrecognized import path "encoding/json" package errors: unrecognized import path "errors" package fmt: unrecognized import path "fmt"
GOARCH="amd64" GOBIN="/usr/local/go/bin" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="linux" GOOS="linux" GOPATH="" GORACE="" GOROOT="/home/me/go" GOTOOLDIR="/home/me/go/pkg/tool/linux_amd64" TERM="dumb" CC="gcc" GOGCCFLAGS="-g -O2 -fPIC -m64 -pthread" CXX="g++" CGO_ENABLED="1"
export GOROOT=/usr/local/go export GOPATH=$HOME/go export PATH=$PATH:$GOROOT/bin
dpkg: warning: while removing golang-go, directory dpkg: warning: while removing golang-go.tools, directory
sudo rm -rf /usr/lib/go /usr/lib/go/src sudo apt-get install golang-go golang-go.tools
bash-3.2$ go env GOARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="darwin" GOOS="darwin" GOPATH="/Users/bis/go" GORACE="" GOROOT="/usr/local/go" GOTOOLDIR="/usr/local/go/pkg/tool/darwin_amd64" CC="clang" GOGCCFLAGS="-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fno-common" CXX="clang++" CGO_ENABLED="1
export GOPATH=$HOME/go export PATH=$PATH:$GOROOT/bin
export PATH=$HOME/bin:/usr/local/bin:$PATH export GOPATH=$HOME/go export PATH=$PATH:$GOROOT/bin
$ go get github.com/wilk/uuid@0.0.1 $ go get github.com/wilk/uuid@0.0.2
dep ensure --add github.com/gorilla/websocket@1.2.0
export GOPATH=~/ go get github.com/whateveruser/whateverrepo cd ~/src/github.com/whateveruser/whateverrepo git tag -l git checkout tags/v0.0.2 go run whateverpackage/main.go
# # # # # [[constraint]] name = "github.com/gorilla/websocket" version = "1.2.0"
[[projects]] name = "github.com/gorilla/websocket" packages = ["."] revision = "ea4d1f681babbce9545c9c5f3d5194a789c89f5b" version = "v1.2.0" [solve-meta] analyzer-name = "dep" analyzer-version = 1 inputs-digest = "941e8dbe52e16e8a7dff4068b7ba53ae69a5748b29fbf2bcb5df3a063ac52261" solver-name = "gps-cdcl" solver-version = 1
+ myproject ++ src +++ myproject +++ github.com ++++ submoduled_project of some kind.
type Item struct { Value int Name string } func Get(value int) (Item, error) { return item, nil }
var t = template.Must(template.New("name").Parse("text")) var validID = regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)
func Must(i Item, err error) Item { if err != nil { panic(err) } return i }
func MustGet(value int) Item { i, err := Get(value) if err != nil { panic(err) } return i }
ew := &errWriter{w: fd} ew.write(p0[a:b]) ew.write(p1[c:d]) ew.write(p2[e:f]) if ew.err != nil { return ew.err }
package main import ( "fmt" "errors" ) type Item struct { Value int Name string } var items []Item = []Item{{Value:0, Name:"zero"}, {Value:1, Name:"one"}, {Value:2, Name:"two"}} func main() { var err error v := Get(3, &err).Value if err != nil { fmt.Println(err) return } fmt.Println(v) } func Get(value int, err *error) Item { if value > (len(items) - 1) { *err = errors.New("error") return Item{} } else { return items[value] } }
package main import "fmt" import "strings" func µ(a ...interface{}) []interface{} { return a } type A struct { B string C func()(string) } func main() { a := A { B:strings.TrimSpace(µ(E())[1].(string)), C:µ(G())[0].(func()(string)), } fmt.Printf ("%s says %s\n", a.B, a.C()) } func E() (bool, string) { return false, "F" } func G() (func()(string), bool) { return func() string { return "Hello" }, true }
layout := "2014-09-12T11:45:26.371Z" str := "2014-11-12T11:45:26.371Z" t, err := time.Parse(layout , str)
layout := "2006-01-02T15:04:05.000Z" str := "2014-11-12T11:45:26.371Z" t, err := time.Parse(layout, str) if err != nil { fmt.Println(err) } fmt.Println(t)
str := "2014-11-12T11:45:26.371Z" t, err := time.Parse(time.RFC3339, str) if err != nil { fmt.Println(err) } fmt.Println(t)
package main import ( "fmt" "time" ) func main() { fmt.Println("Time parsing"); dateString := "2014-11-12T11:45:26.371Z" time1, err := time.Parse(time.RFC3339,dateString); if err!=nil { fmt.Println("Error while parsing date :", err); } fmt.Println(time1); }
package main import ( "flag" "fmt" "time" "github.com/apcera/termtables" "github.com/araddon/dateparse" ) var examples = []string{ "May 8, 2009 5:57:51 PM", "Mon Jan 2 15:04:05 2006", "Mon Jan 2 15:04:05 MST 2006", "Mon Jan 02 15:04:05 -0700 2006", "Monday, 02-Jan-06 15:04:05 MST", "Mon, 02 Jan 2006 15:04:05 MST", "Tue, 11 Jul 2017 16:28:13 +0200 (CEST)", "Mon, 02 Jan 2006 15:04:05 -0700", "Thu, 4 Jan 2018 17:53:36 +0000", "Mon Aug 10 15:44:11 UTC+0100 2015", "Fri Jul 03 2015 18:04:07 GMT+0100 (GMT Daylight Time)", "12 Feb 2006, 19:17", "12 Feb 2006 19:17", "03 February 2013", "2013-Feb-03", "3/31/2014", "03/31/2014", "08/21/71", "8/1/71", "4/8/2014 22:05", "04/08/2014 22:05", "4/8/14 22:05", "04/2/2014 03:00:51", "8/8/1965 12:00:00 AM", "8/8/1965 01:00:01 PM", "8/8/1965 01:00 PM", "8/8/1965 1:00 PM", "8/8/1965 12:00 AM", "4/02/2014 03:00:51", "03/19/2012 10:11:59", "03/19/2012 10:11:59.3186369", "2014/3/31", "2014/03/31", "2014/4/8 22:05", "2014/04/08 22:05", "2014/04/2 03:00:51", "2014/4/02 03:00:51", "2012/03/19 10:11:59", "2012/03/19 10:11:59.3186369", "2014年04月08日", "2006-01-02T15:04:05+0000", "2009-08-12T22:15:09-07:00", "2009-08-12T22:15:09", "2009-08-12T22:15:09Z", "2014-04-26 17:24:37.3186369", "2012-08-03 18:31:59.257000000", "2014-04-26 17:24:37.123", "2013-04-01 22:43", "2013-04-01 22:43:22", "2014-12-16 06:20:00 UTC", "2014-12-16 06:20:00 GMT", "2014-04-26 05:24:37 PM", "2014-04-26 13:13:43 +0800", "2014-04-26 13:13:44 +09:00", "2012-08-03 18:31:59.257000000 +0000 UTC", "2015-09-30 18:48:56.35272715 +0000 UTC", "2015-02-18 00:12:00 +0000 GMT", "2015-02-18 00:12:00 +0000 UTC", "2017-07-19 03:21:51+00:00", "2014-04-26", "2014-04", "2014", "2014-05-11 08:20:13,787", "3.31.2014", "03.31.2014", "08.21.71", "20140601", "1332151919", "1384216367189", } var ( timezone = "" ) func main() { flag.StringVar(&timezone, "timezone", "UTC", "Timezone aka `America/Los_Angeles` formatted time-zone") flag.Parse() if timezone != "" { loc, err := time.LoadLocation(timezone) if err != nil { panic(err.Error()) } time.Local = loc } table := termtables.CreateTable() table.AddHeaders("Input", "Parsed, and Output as %v") for _, dateExample := range examples { t, err := dateparse.ParseLocal(dateExample) if err != nil { panic(err.Error()) } table.AddRow(dateExample, fmt.Sprintf("%v", t)) } fmt.Println(table.Render()) }
package main import ( "fmt" "reflect" ) type T struct { X int Y string Z []int M map[string]int } func main() { t1 := T{ X:1, Y:"lei", Z:[]int{1,2,3}, M:map[string]int{ "a":1, "b":2, }, } t2 := T{ X:1, Y:"lei", Z:[]int{1,2,3}, M:map[string]int{ "a":1, "b":2, }, } fmt.Println(t2 == t1) fmt.Println(reflect.ValueOf(t2) == reflect.ValueOf(t1)) fmt.Println(reflect.TypeOf(t2) == reflect.TypeOf(t1)) a1 := []int{1,2,3,4} a2 := []int{1,2,3,4} fmt.Println(a1==a2) m1 := map[string]int{ "a":1, "b":2, } m2 := map[string]int{ "a":1, "b":2, } fmt.Println(m1==m2) }
m1 := map[string]int{ "a":1, "b":2, } m2 := map[string]int{ "a":1, "b":2, } fmt.Println(reflect.DeepEqual(m1, m2))
m1 := map[string]int{ "a": 1, "b": 2, } m2 := map[string]int{ "a": 1, "b": 2, } fmt.Println(cmp.Equal(m1, m2))
func compare(a, b T) bool { if &a == &b { return true } if a.X != b.X || a.Y != b.Y { return false } if len(a.Z) != len(b.Z) || len(a.M) != len(b.M) { return false } for i, v := range a.Z { if b.Z[i] != v { return false } } for k, v := range a.M { if b.M[k] != v { return false } } return true }
func ObjectEqual(a, b interface{}) bool { if a == nil || b == nil { return a == b } return reflect.DeepEqual(a, b) }
func test(i MyInt) { } func main() { anInt := 0 test(anInt) }
type MyFunc func(i int) func (m MyFunc) Run(i int) { m(i) } func run(f MyFunc, i int) { f.Run(i) } func main() { var newfunc func(int) newfunc = func(i int) { fmt.Println(i) } run(newfunc, 10) }
type MyInt int type MyMap map[int]int type MySlice []int type MyFunc func(int)
is := make([]int) m := make(map[int]int) f := func(i int){} func doSlice(input MySlice){...} doSlice(is) func doMap(input MyMap){...} doMap(m) func doFunc(input MyFunc){...} doFunc(f)
import ( "fmt" "reflect" ) type T1 []string type T2 []string func main() { foo0 := []string{} foo1 := T1{} foo2 := T2{} fmt.Println(reflect.TypeOf(foo0)) fmt.Println(reflect.TypeOf(foo1)) fmt.Println(reflect.TypeOf(foo2)) foo1 = foo0 foo0 = foo1 }
package main import ( "bytes" "fmt" "net/http" "net/url" "strconv" ) func main() { apiUrl := "https: resource := "/user/" data := url.Values{} data.Set("name", "foo") data.Add("surname", "bar") u, _ := url.ParseRequestURI(apiUrl) u.Path = resource u.RawQuery = data.Encode() urlStr := fmt.Sprintf("%v", u) client := &http.Client{} r, _ := http.NewRequest("POST", urlStr, nil) r.Header.Add("Authorization", "auth_token=\"XXXXXXX\"") r.Header.Add("Content-Type", "application/x-www-form-urlencoded") r.Header.Add("Content-Length", strconv.Itoa(len(data.Encode()))) resp, _ := client.Do(r) fmt.Println(resp.Status) }
package main import ( "fmt" "net/http" "net/url" "strconv" "strings" ) func main() { apiUrl := "https: resource := "/user/" data := url.Values{} data.Set("name", "foo") data.Set("surname", "bar") u, _ := url.ParseRequestURI(apiUrl) u.Path = resource urlStr := u.String() client := &http.Client{} r, _ := http.NewRequest("POST", urlStr, strings.NewReader(data.Encode())) r.Header.Add("Authorization", "auth_token=\"XXXXXXX\"") r.Header.Add("Content-Type", "application/x-www-form-urlencoded") r.Header.Add("Content-Length", strconv.Itoa(len(data.Encode()))) resp, _ := client.Do(r) fmt.Println(resp.Status) }
package main import ( "fmt" "reflect" ) func main() { type t struct { N int } var n = t{42} fmt.Println(n.N) ps := reflect.ValueOf(&n) s := ps.Elem() if s.Kind() == reflect.Struct { f := s.FieldByName("N") if f.IsValid() { if f.CanSet() { if f.Kind() == reflect.Int { x := int64(7) if !f.OverflowInt(x) { f.SetInt(x) } } } } } fmt.Println(n.N) } Output: 42 7
package main import ( "fmt" "reflect" ) func main() { type t struct { N int } var n = t{42} fmt.Println(n.N) reflect.ValueOf(&n).Elem().FieldByName("N").SetInt(7) fmt.Println(n.N) }
package main import ( "fmt" "reflect" ) type Foo struct { Number int Text string } func main() { foo := Foo{123, "Hello"} fmt.Println(int(reflect.ValueOf(foo).Field(0).Int())) reflect.ValueOf(&foo).Elem().Field(0).SetInt(321) fmt.Println(int(reflect.ValueOf(foo).Field(0).Int())) }
input,_:=src.ReadString( inputFmt:=input[0:len(input)-2]+""
input, _ := src.ReadString( var inputFmt string if len(input) > 0 { inputFmt = input[:len(input)-1] }
package main import "fmt" var p = fmt.Println func main() { value := "address;bar" substring := value[2:len(value)] p(substring) }
package main import "fmt" func main(){ if sumThis(1,2) > sumThis(3,4){ fmt.Println("test") } else { fmt.Println("derp") } } func sumThis(a, b int){ return a+b }
./test4.go:4: sumThis(1, 2) used as value ./test4.go:4: sumThis(3, 4) used as value ./test4.go:11: too many arguments to return
package main import ( "fmt" "flag" ) func main() { flag.Parse() fmt.Println(flag.Args()...) }
./example.go:10: cannot use args (type []string) as type []interface {} in function argument
cannot convert flag.Args() (type []string) to type []interface {}
old := flag.Args() new := make([]interface{}, len(old)) for i, v := range old { new[i] = v } fmt.Println(new...)
package main import ( "fmt" "flag" "strings" ) func main() { flag.Parse() s := strings.Join(flag.Args(), " ") fmt.Println(s) }
package main import ( "fmt" "flag" ) func main() { flag.Parse() fmt.Println(flag.Args()...) }
package main import ( "flag" "fmt" ) func main() { flag.Parse() fmt.Println(flag.Args()) }
$ go build args.go $ ./args arg0 arg1 [arg0 arg1] $
cannot use s (type []string) as type []interface {} in assignment
func main() { flag.Parse() fmt.Println(flag.Args()) }
package main import "fmt" func main() { var x float64 = 5.7 var y int = int(x) fmt.Println(y) }
package main import ( "fmt" ) func main() { nf := []float64{-1.9999, -2.0001, -2.0, 0, 1.9999, 2.0001, 2.0} fmt.Printf("Round : ") for _, f := range nf { fmt.Printf("%d ", round(f)) } fmt.Printf("\n") fmt.Printf("RoundD: ") for _, f := range nf { fmt.Printf("%d ", roundD(f)) } fmt.Printf("\n") fmt.Printf("RoundU: ") for _, f := range nf { fmt.Printf("%d ", roundU(f)) } fmt.Printf("\n") } func roundU(val float64) int { if val > 0 { return int(val+1.0) } return int(val) } func roundD(val float64) int { if val < 0 { return int(val-1.0) } return int(val) } func round(val float64) int { if val < 0 { return int(val-0.5) } return int(val+0.5) }
Round : -2 -2 -2 0 2 2 2 RoundD: -2 -3 -3 0 1 2 2 RoundU: -1 -2 -2 0 2 3 3
package main import ( "fmt" "strconv" ) func main() { floats := []float64{1.9999, 2.0001, 2.0} for _, f := range floats { t := int(f) s := fmt.Sprintf("%.0f", f) if i, err := strconv.Atoi(s); err == nil { fmt.Println(f, t, i) } else { fmt.Println(f, t, err) } } }
import random list = [i for i in range(1, 25)] random.shuffle(list) print(list)
list := rand.Perm(25) for i, _ := range list { list[i]++ }
dest := make([]int, len(src)) perm := rand.Perm(len(src)) for i, v := range perm { dest[v] = src[i] }
for i := range slice { j := rand.Intn(i + 1) slice[i], slice[j] = slice[j], slice[i] }
words := strings.Fields("ink runs from the corners of my mouth") rand.Shuffle(len(words), func(i, j int) { words[i], words[j] = words[j], words[i] }) fmt.Println(words)
for i := len(slice) - 1; i > 0; i-- { j := rand.Intn(i + 1) slice[i], slice[j] = slice[j], slice[i] }
func main() { slice := []int{10, 12, 14, 16, 18, 20} Shuffle(slice) fmt.Println(slice) } func Shuffle(slice []int) { r := rand.New(rand.NewSource(time.Now().Unix())) for n := len(slice); n > 0; n-- { randIndex := r.Intn(n) slice[n-1], slice[randIndex] = slice[randIndex], slice[n-1] } }
import ( "math/rand" ) func Shuffle(array []interface{}, source rand.Source) { random := rand.New(source) for i := len(array) - 1; i > 0; i-- { j := random.Intn(i + 1) array[i], array[j] = array[j], array[i] } }
source := rand.NewSource(time.Now().UnixNano()) array := []interface{}{"a", "b", "c"} Shuffle(array, source)
func Shuffle(slice interface{}) { rv := reflect.ValueOf(slice) swap := reflect.Swapper(slice) length := rv.Len() for i := length - 1; i > 0; i-- { j := rand.Intn(i + 1) swap(i, j) } }
rand.Seed(time.Now().UnixNano()) s := []int{1, 2, 3, 4, 5} Shuffle(s) fmt.Println(s)
ch := make(chan int, 100) go func(){ for { ch <- do_stuff() } }()
package main import "sync" func main() { var wg sync.WaitGroup wg.Add(1) ch := make(chan int) go func() { for { foo, ok := <- ch if !ok { println("done") wg.Done() return } println(foo) } }() ch <- 1 ch <- 2 ch <- 3 close(ch) wg.Wait() }
quit := make(chan bool) go func() { for { select { case <- quit: return default: } } }() quit <- true
package main import ( "launchpad.net/tomb" "time" "fmt" ) type Proc struct { Tomb tomb.Tomb } func (proc *Proc) Exec() { defer proc.Tomb.Done() for { select { case <-proc.Tomb.Dying(): return default: time.Sleep(300 * time.Millisecond) fmt.Println("Loop the loop") } } } func main() { proc := &Proc{} go proc.Exec() time.Sleep(1 * time.Second) proc.Tomb.Kill(fmt.Errorf("Death from above")) err := proc.Tomb.Wait() fmt.Println(err) }
package main import "fmt" import "time" func do_stuff() int { return 1 } func main() { ch := make(chan int, 100) done := make(chan struct{}) go func() { for { select { case ch <- do_stuff(): case <-done: close(ch) return } time.Sleep(100 * time.Millisecond) } }() go func() { time.Sleep(3 * time.Second) done <- struct{}{} }() for i := range ch { fmt.Println("receive value: ", i) } fmt.Println("finish") }
package main import ( "context" "fmt" "time" ) func main() { forever := make(chan struct{}) ctx, cancel := context.WithCancel(context.Background()) go func(ctx context.Context) { for { select { case <-ctx.Done(): forever <- struct{}{} return default: fmt.Println("for loop") } time.Sleep(500 * time.Millisecond) } }(ctx) go func() { time.Sleep(3 * time.Second) cancel() }() <-forever fmt.Println("finish") }
func main() { var i int _, err := fmt.Scanf("%d", &i) }
package main import "fmt" func main() { var i int fmt.Scan(&i) fmt.Println("read number", i, "from stdin") }
package main import ( "io/ioutil" "bufio" "os" "strconv" ) func main() { out := bufio.NewWriter(os.Stdout) ints := getInts() var T int64 T, ints = ints[0], ints[1:] .. out.WriteString(strconv.Itoa(my_num) + "\n") out.Flush() } } func getInts() []int64 { var buf []byte buf, _ = ioutil.ReadAll(os.Stdin) var ints []int64 num := int64(0) found := false for _, v := range buf { if num = 10*num + int64(v - found = true } else if found { ints = append(ints, num) found = false num = 0 } } if found { ints = append(ints, num) found = false num = 0 } return ints }
import ( "fmt" "log" ) var i int if _, err := fmt.Scan(&i); err != nil { log.Print(" Scan for i failed, due to ", err) return } fmt.Println(i)
import ( "fmt" "log" ) var i, j, k int if _, err := fmt.Scan(&i, &j, &k); err != nil { log.Print(" Scan for i, j & k failed, due to ", err) return } fmt.Println(i, j, k)
func main(){ in:=bufio.NewScanner(os.Stdin) in.Scan() int,_:=strconv.Atoi(in.Text()) fmt.Println(int) }
package main import ( "fmt" "os" ) func main() { fmt.Println(len(os.Args), os.Args) }
package main import "flag" import "fmt" func main() { wordPtr := flag.String("word", "foo", "a string") numbPtr := flag.Int("numb", 42, "an int") boolPtr := flag.Bool("fork", false, "a bool") var svar string flag.StringVar(&svar, "svar", "bar", "a string var") flag.Parse() fmt.Println("word:", *wordPtr) fmt.Println("numb:", *numbPtr) fmt.Println("fork:", *boolPtr) fmt.Println("svar:", svar) fmt.Println("tail:", flag.Args()) }
package main import ("fmt" "os" ) func main() { argsWithProg := os.Args argsWithoutProg := os.Args[1:] arg := os.Args[3] fmt.Println(argsWithProg) fmt.Println(argsWithoutProg) fmt.Println(arg) }
[/tmp/go-build162373819/command-line-arguments/_obj/exe/modbus 1 2 3 4 5] [1 2 3 4 5] 3
arr := []int{1, 2, 3} tmp := []int{} copy(tmp, arr) fmt.Println(tmp) fmt.Println(arr)
arr := []int{1, 2, 3} tmp := make([]int, len(arr)) copy(tmp, arr) fmt.Println(tmp) fmt.Println(arr)
arr := []int{1, 2, 3} tmp := []int{0, 0, 0} i := copy(tmp, arr) fmt.Println(i) fmt.Println(tmp) fmt.Println(arr)
t := make([]byte, len(s), (cap(s)+1)*2) copy(t, s) s = t
arr := []int{1, 2, 3} tmp := append([]int(nil), arr...) fmt.Println(tmp) fmt.Println(arr)
A := []int{1, 2, 3} B := make([]int, 3) copy(B, A) C := make([]int, 2) copy(C, A) fmt.Println(A, B, C)
A := []int{1, 2, 3} B := append([]int{}, A...) C := append([]int{}, A[:2]...) fmt.Println(A, B, C)
BenchmarkCopy1-4 50000000 27.0 ns/op BenchmarkCopy10-4 30000000 53.3 ns/op BenchmarkCopy100-4 10000000 229 ns/op BenchmarkCopy1000-4 1000000 1942 ns/op BenchmarkCopy10000-4 100000 18009 ns/op BenchmarkCopy100000-4 10000 220113 ns/op BenchmarkCopy1000000-4 1000 2028157 ns/op BenchmarkCopy10000000-4 100 15323924 ns/op BenchmarkCopy100000000-4 1 1200488116 ns/op BenchmarkAppend1-4 50000000 34.2 ns/op BenchmarkAppend10-4 20000000 60.0 ns/op BenchmarkAppend100-4 5000000 240 ns/op BenchmarkAppend1000-4 1000000 1832 ns/op BenchmarkAppend10000-4 100000 13378 ns/op BenchmarkAppend100000-4 10000 142397 ns/op BenchmarkAppend1000000-4 2000 1053891 ns/op BenchmarkAppend10000000-4 200 9500541 ns/op BenchmarkAppend100000000-4 20 176361861 ns/op
copy(dst, src []T) int copy(dst []byte, src string) int
package main import "fmt" func main() { arr := []int{1, 2, 3} tmp := make([]int, len(arr)) copy(tmp, arr) fmt.Println(tmp) fmt.Println(arr) }
func Filter(s []int, fn func(int) bool) []int { var p []int for _, v := range s { if fn(v) { p = append(p, v) } } return p }
slice := make([]int, 2, 5) fmt.Printf("lenght: %d - capacity %d - content: %d", len(slice), cap(slice), slice)
slice := make([]interface{}, 2, 5) fmt.Printf("lenght: %d - capacity %d - content: %d", len(slice), cap(slice), slice)
package main import ( "fmt" "strings" ) func main() { reg := [...]string {"a","b","c"} fmt.Println(strings.Join(reg,",")) }
import strings stringFiles := strings.Join(fileSlice[:], ",")
import strings fileSlice := strings.Split(stringFiles, ",")
package main import ( "os/user" "fmt" "log" ) func main() { usr, err := user.Current() if err != nil { log.Fatal( err ) } fmt.Println( usr.HomeDir ) }
package main import ( "fmt" "os" "runtime" ) func UserHomeDir() string { if runtime.GOOS == "windows" { home := os.Getenv("HOMEDRIVE") + os.Getenv("HOMEPATH") if home == "" { home = os.Getenv("USERPROFILE") } return home } return os.Getenv("HOME") } func main() { dir := UserHomeDir() fmt.Println(dir) }
import ( "os" ) var home string = os.Getenv("HOME")
package main import ( "fmt" "os" "runtime" ) func UserHomeDir() string { env := "HOME" if runtime.GOOS == "windows" { env = "USERPROFILE" } else if runtime.GOOS == "plan9" { env = "home" } return os.Getenv(env) } func main() { dir := UserHomeDir() fmt.Println(dir) }
package main import ( "fmt" "os" "runtime" ) func userHomeDir() string { if runtime.GOOS == "windows" { home := os.Getenv("HOMEDRIVE") + os.Getenv("HOMEPATH") if home == "" { home = os.Getenv("USERPROFILE") } return home } else if runtime.GOOS == "linux" { home := os.Getenv("XDG_CONFIG_HOME") if home != "" { return home } } return os.Getenv("HOME") } func main() { fmt.Println(userHomeDir()) }
package main import "fmt" func main(){ fmt.Printf("Hello world!") }
$gcc Hello_world.c -o Hello_c $8g Hello_world.go -o Hello_go.8 $8l Hello_go.8 -o Hello_go
$ls -ls ... 5,4K 2010-10-05 11:09 Hello_c ... 991K 2010-10-05 11:17 Hello_go
➜ ls -lh hello -rwxr-xr-x 1 oneofone oneofone 976K May 26 20:49 hello*
➜ ls -lh hello -rwxr-xr-x 1 oneofone oneofone 367K May 26 20:49 hello*
$ go get github.com/pwaller/goupx $ go build -o filename $ goupx filename
2014/12/25 10:10:54 File fixed! File size Ratio Format Name -------------------- ------ ----------- ----------- 16271132 -> 3647116 22.41% linux/ElfAMD filename Packed 1 file.
$ go build hello.go $ ls -lh hello ... 259K ... hello2 $ strip hello $ ls -lh hello ... 162K ... hello2
package main import "fmt" func main(){ fmt.Println("Hello World!") }
$ go build main.go $ ls -lh -rwxr-xr-x-x 1 nil nil 1.8M Oct 27 07:47 main
$ go build -ldflags "-s -w" main.go $ ls -lh -rwxr-xr-x-x 1 nil nil 1.2M Oct 27 08:15 main
$ go version go version go1.8.1 gccgo (GCC) 7.2.0 linux/amd64
$ go build main.go $ ls -lh -rwxr-xr-x 1 nil nil 34K Oct 27 12:18 main
$ go build -gccgoflags "-s -w" main.go -rwxr-xr-x 1 nil nil 23K Oct 27 13:02 main
name old exe-bytes new exe-bytes delta HelloSize 1.60MB ± 0% 1.05MB ± 0% -34.39% (p=0.000 n=30+30) CmdGoSize 16.5MB ± 0% 11.3MB ± 0% -31.76% (p=0.000 n=30+30) [Geo mean] 5.14MB 3.44MB -33.08%
go install: no install location for .go files listed on command line (GOBIN not set)
nate:~/work/src/dir $ go run hello/hello.go hello, world.
nate:~/work/src/dir $ go install hello/hello.go go install: no install location for .go files listed on command line (GOBIN not set) nate:~/work/src/dir $ go install hello can /opt/go/src/hello (from $GOROOT) /home/ubuntu/work/src/hello (from $GOPATH)
nate:~/work/src/dir $ cd hello nate:~/work/src/dir/hello $ go install hello.go go install: no install location for .go files listed on command line (GOBIN not set) nate:~/work/src/dir/hello $ go install hello can /opt/go/src/hello (from $GOROOT) /home/ubuntu/work/src/hello (from $GOPATH)
nate:~/work/src/dir $ go install dir/hello nate:~/work/src/dir $ go install ./hello/ nate:~/work/src/dir/hello $ go install .
$ echo $GOROOT C:\Go\ carl@rainier ~/gocode/src/github.com/user/hello $ echo $GOPATH C:\cygwin64\home\carl\gocode carl@rainier ~/gocode/src/github.com/user/hello $ echo $GOBIN C:\cygwin64\home\carl\gocode\bin
export GOROOT=/usr/local/go export GOPATH=$GOROOT/src export GOBIN=$GOROOT/bin PATH=$PATH:$GOPATH:$GOBIN export PATH
go get github.com:capotej/groupcache-db-experiment.git
go get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]
$ go get -v github.com/capotej/groupcache-db-experiment/... github.com/capotej/groupcache-db-experiment (download) github.com/golang/groupcache (download) github.com/golang/protobuf (download) github.com/capotej/groupcache-db-experiment/api github.com/capotej/groupcache-db-experiment/client github.com/capotej/groupcache-db-experiment/slowdb github.com/golang/groupcache/consistenthash github.com/golang/protobuf/proto github.com/golang/groupcache/lru github.com/capotej/groupcache-db-experiment/dbserver github.com/capotej/groupcache-db-experiment/cli github.com/golang/groupcache/singleflight github.com/golang/groupcache/groupcachepb github.com/golang/groupcache github.com/capotej/groupcache-db-experiment/frontend $
export GOPATH=$HOME/gocode export PATH=$PATH:$GOPATH/bin
GOARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="linux" GOOS="linux" GOPATH="/home/elpsstu/gocode" GORACE="" GOROOT="/home/pravin/go" GOTOOLDIR="/home/pravin/go/pkg/tool/linux_amd64" CC="gcc" GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0" CXX="g++" CGO_ENABLED="1"
go get [-d] [-f] [-fix] [-t] [-u] [build flags] [packages]
func groupClasses(classes []entities.Class) map[string][]entities.Class { classMap := make(map[string][]entities.Class) for _, class := range classes { classMap[class.ClassType.Name] = append(classMap[class.ClassType.Name], class) } return classMap }
map[Pilates:[{102 PILATES ~/mobifit/video/ocen.mpg 169 40 2014-05-03 23:12:12 +0000 UTC 2014-05-03 23:12:12 +0000 UTC 1899-12-30 00:00:00 +0000 UTC {PILATES Pilates 1 2014-01-22 21:46:16 +0000 UTC} {1 leebrooks0@gmail.com password SUPERADMIN Lee Brooks {Male true} {1990-07-11 00:00:00 +0000 UTC true} {1.85 true} {88 true} 2014-01-22 21:46:16 +0000 UTC {0001-01-01 00:00:00 +0000 UTC false} {0001-01-01 00:00:00 +0000 UTC false} {0001-01-01 00:00:00 +0000 UTC false}} [{1 Mat 2014-01-22 21:46:16 +0000 UTC}]} {70 PILATES ~/mobifit/video/ocen.mpg 119 66 2014-03-31 15:12:12 +0000 UTC 2014-03-31 15:12:12 +0000 UTC 1899-12-30 00:00:00 +0000 UTC
{{ range $key, $value := . }} <li><strong>{{ $key }}</strong>: {{ $value }}</li> {{ end }}
{{range $index, $element := .}}{{$index}} {{range $element}}{{.Value}} {{end}} {{end}}
package main import ( "html/template" "os" ) type EntetiesClass struct { Name string Value int32 } var htmlTemplate = `{{range $index, $element := .}}{{$index}} {{range $element}}{{.Value}} {{end}} {{end}}` func main() { data := map[string][]EntetiesClass{ "Yoga": {{"Yoga", 15}, {"Yoga", 51}}, "Pilates": {{"Pilates", 3}, {"Pilates", 6}, {"Pilates", 9}}, } t := template.New("t") t, err := t.Parse(htmlTemplate) if err != nil { panic(err) } err = t.Execute(os.Stdout, data) if err != nil { panic(err) } }
func HandleError(err error) (b bool) { if err != nil { _, fn, line, _ := runtime.Caller(1) log.Printf("[error] %s:%d %v", fn, line, err) b = true } return } func FancyHandleError(err error) (b bool) { if err != nil { pc, fn, line, _ := runtime.Caller(1) log.Printf("[error] in %s[%s:%d] %v", runtime.FuncForPC(pc).Name(), fn, line, err) b = true } return } func main() { if FancyHandleError(fmt.Errorf("it log.Print("stuff") } }
func f(args ...string) { fmt.Println(len(args)) } args := []string{"a", "b"} f(args...)
var args []string = []string{"A", "B", "C"} func Sample(args ...string) { for _, arg := range args { fmt.Println(arg) } } func main() { Sample(args...) }
package main import "fmt" func SampleEllipsis(args ...string) { fmt.Printf("Sample ellipsis : %+v\n",args) } func SampleArray(args []string) { fmt.Println("Sample array ") SampleEllipsis(args...) } func main() { SampleEllipsis([]string{"A", "B", "C"}...) SampleEllipsis("A", "B", "C") SampleEllipsis() SampleArray([]string{"A", "B", "C"}) SampleArray([]string{}) }
Sample ellipsis : [A B C] Sample ellipsis : [A B C] Sample ellipsis : [] Sample array Sample ellipsis : [A B C] Sample array Sample ellipsis : []
$ go test -coverprofile fmt ok fmt 0.060s coverage: 91.4% of statements $
cover () { t="/tmp/go-cover.$$.tmp" go test -coverprofile=$t $@ && go tool cover -html=$t && unlink $t }
$ go tool 6a 6c 6g 6l addr2line api cgo cov dist ebnflint fix gotype nm objdump pack pprof prof vet yacc $ go tool cov -h usage: cov [-lsv] [-g substring] [-m minlines] [6.out args...] -g specifies pattern of interesting functions or files go tool cov: exit status 1 $
f=cover.out; if [ -f $f ]; then rm $f; fi; go test -coverprofile $f && go tool cover -html $f
go get -u github.com/gregoryv/uncover/... go test -coverprofile /tmp/c.out uncover /tmp/c.out
docker run --rm -v "$PWD":$PROJECT_PATH -w $PROJECT_PATH $BUILDER_IMAGE_NAME /go/script/coverage.sh
go test -coverprofile=coverage.out go tool cover -html=coverage.out
go test -v -coverprofile cover.out ./YOUR_CODE_FOLDER/... go tool cover -html=cover.out -o cover.html open cover.html
uid : kasi: cn: Chaithra street: fkmp nandan: cn: Chaithra street: fkmp remya: cn: Chaithra street: fkmp
package main import ( "fmt" "gopkg.in/yaml.v2" ) type T struct { cn string street string } func main() { names := []string{"kasi", "remya", "nandan"} m := make(map[string]map[string]T, len(names)) for _, name := range names { m["uid"][name] = T{cn: "Chaithra", street: "fkmp"} } fmt.Println(m) y, _ := yaml.Marshal(&m) fmt.Println(string(y)) }
panic: runtime error: assignment to entry in nil map
package main import ( "fmt" "time" ) func main() { now := time.Now() fmt.Println("now:", now) then := now.AddDate(0, -1, 0) fmt.Println("then:", then) }
now: 2009-11-10 23:00:00 +0000 UTC then: 2009-10-10 23:00:00 +0000 UTC
package main import ( "fmt" "time" ) func main() { now := time.Now() fmt.Println("now:", now) count := 10 then := now.Add(time.Duration(-count) * time.Minute) fmt.Println("10 minutes ago:", then) }
now: 2009-11-10 23:00:00 +0000 UTC 10 minutes ago: 2009-11-10 22:50:00 +0000 UTC
package main import "fmt" import "time" func main() { test, err := time.Parse("10/15/1983", "10/15/1983") if err != nil { panic(err) } fmt.Println(test) }
test, err := time.Parse("10/15/1983", "10/15/1983")
test, err := time.Parse("01/02/2006", "10/15/1983")
package main import "fmt" import "time" func main() { test, err := time.Parse("01/02/2006", "10/15/1983") if err != nil { panic(err) } fmt.Println(test) }
const ( stdLongMonth = "January" stdMonth = "Jan" stdNumMonth = "1" stdZeroMonth = "01" stdLongWeekDay = "Monday" stdWeekDay = "Mon" stdDay = "2" stdUnderDay = "_2" stdZeroDay = "02" stdHour = "15" stdHour12 = "3" stdZeroHour12 = "03" stdMinute = "4" stdZeroMinute = "04" stdSecond = "5" stdZeroSecond = "05" stdLongYear = "2006" stdYear = "06" stdPM = "PM" stdpm = "pm" stdTZ = "MST" stdISO8601TZ = "Z0700" stdISO8601ColonTZ = "Z07:00" stdNumTZ = "-0700" stdNumShortTZ = "-07" stdNumColonTZ = "-07:00" )
test, err := time.Parse("02/Jan/2006:15:04:05 -0700", "31/Dec/2012:15:32:25 -0800")
package main import ( "github.com/metakeule/fmtdate" "fmt" ) func main() { test, err := fmtdate.Parse("MM/DD/YYYY", "10/15/1983") if err != nil { panic(err) } fmt.Println(test) }
func TestLogging(t *testing.T) { if !FileExists("logfile") { CreateFile("logfile") } f, err := os.Open("logfile") if err != nil { t.Fatalf("error: %v", err) } log.SetOutput(io.MultiWriter(os.Stderr, f)) log.Println("hello, logfile") log.SetOutput(io.Writer(f)) log.Println("hello, logfile") log.SetOutput(f) log.Println("hello, logfile") } func FileExists(name string) bool { if _, err := os.Stat(name); err != nil { if os.IsNotExist(err) { return false } } return true } func CreateFile(name string) error { fo, err := os.Create(name) if err != nil { return err } defer func() { fo.Close() }() return nil }
f, err := os.OpenFile("testlogfile", os.O_RDWR | os.O_CREATE | os.O_APPEND, 0666) if err != nil { log.Fatalf("error opening file: %v", err) } defer f.Close() log.SetOutput(f) log.Println("This is a test log entry")
package logger import ( "flag" "os" "log" "go/build" ) var ( Log *log.Logger ) func init() { var logpath = build.Default.GOPATH + "/src/chat/logger/info.log" flag.Parse() var file, err1 = os.Create(logpath) if err1 != nil { panic(err1) } Log = log.New(file, "", log.LstdFlags|log.Lshortfile) Log.Println("LogFile : " + logpath) }
package main import ( "logger" ) const ( VERSION = "0.13" ) func main() { logger.Log.Printf("Server v%s pid=%d started with processes: %d", VERSION, os.Getpid(),runtime.GOMAXPROCS(runtime.NumCPU())) }
import ( "syscall" "os" ) func main(){ fErr, err = os.OpenFile("Errfile", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600) syscall.Dup2(int(fErr.Fd()), 1) syscall.Dup2(int(fErr.Fd()), 2) }
f, err := os.OpenFile("/tmp/orders.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666) if err != nil { log.Fatalf("error opening file: %v", err) } defer f.Close() wrt := io.MultiWriter(os.Stdout, f) log.SetOutput(wrt) log.Println(" Orders API Called")
package main import ( "log" "os" ) var ( outfile, _ = os.Create("path/to/my.log") l = log.New(outfile, "", 0) ) func main() { l.Println("hello, log!!!") }
import ( "os/exec" ) func main() { exec.Command("/bin/sh", "-c", "echo "+err.Error()+" >> log.log").Run() }
s := []int{5, 4, 3, 2, 1} for i := len(s)-1; i >= 0; i-- { fmt.Println(s[i]) }
s := []int{5, 4, 3, 2, 1} for i := range s { fmt.Println(s[len(s)-1-i]) }
s := []int{5, 4, 3, 2, 1} for i, _ := range s { defer fmt.Println(s[i]) }
package main import ( "fmt" ) func reverse(lst []string) chan string { ret := make(chan string) go func() { for i, _ := range lst { ret <- lst[len(lst)-1-i] } close(ret) }() return ret } func main() { elms := []string{"a", "b", "c", "d"} for e := range reverse(elms) { fmt.Println(e) } }
s := []string{"foo", "bar", "baz"} fmt.Println(strings.Join(s, ", "))
type ToStringConverter interface { ToString() string }
func Join(a []ToStringConverter, sep string) string
package main import "fmt" type bin int func (b bin) String() string { return fmt.Sprintf("%b", b) } func main() { fmt.Println(bin(42)) }
package main import ( "fmt" ) type Color struct { Red int `json:"red"` Green int `json:"green"` Blue int `json:"blue"` } func (c Color) String() string { return fmt.Sprintf("[%d, %d, %d]", c.Red, c.Green, c.Blue) } func main() { c := Color{Red: 123, Green: 11, Blue: 34} fmt.Println(c) }
package types import "fmt" type MyType struct { Id int Name string } func (t MyType) String() string { return fmt.Sprintf( "[%d : %s]", t.Id, t.Name) }
t := types.MyType{ 12, "Blabla" } fmt.Println(t) fmt.Printf("t : %s \n", t) fmt.Println("t : " + t.String())
type StringRef []byte func (s StringRef) String() string { return string(s[:]) } … fmt.Printf("foo=%s\n",StringRef("bar"))
import "bufio" import "bytes" func main() { var b bytes.Buffer foo := bufio.NewWriter(b) }
cannot use b (type bytes.Buffer) as type io.Writer in function argument: bytes.Buffer does not implement io.Writer (Write method has pointer receiver)
import "bufio" import "bytes" func main() { var b bytes.Buffer foo := bufio.NewWriter(&b) }
package main import "bytes" import "io" func main() { var b bytes.Buffer _ = io.Writer(&b) }
func (b *Buffer) Write(p []byte) (n int, err error) { ... } type Writer interface { Write(p []byte) (n int, err error) }
package myfunc_test import ( "github.com/user/myfunc" )
package main import "fmt" func oneRet() interface{} { return "Hello" } func twoRet() (interface{}, error) { return "Hejsan", nil } func main() { str1 := oneRet().(string) fmt.Println("String 1: " + str1) temp, err := twoRet() str2 := temp.(string) fmt.Println("String 2: " + str2 ) if err != nil { panic("unreachable") } }
func silly() (interface{}, error) { return "silly", nil } v, err := silly() if err != nil { } s, ok := v.(string) if !ok { }
switch t := v.(type) { case string: case int : default: }
func must(v interface{}, err error) interface{} { if err != nil { panic(err) } return v } str2 := must(twoRet()).(string)
$ go get -v gitlab.com/secmask/awserver-go Fetching https: https fetch failed. Fetching http: Parsing meta tags from http: import "gitlab.com/secmask/awserver-go": parse http: package gitlab.com/secmask/awserver-go: unrecognized import path "gitlab.com/secmask/awserver-go
[url "ssh: insteadOf = https: $ go get -v gitlab.com/secmask/awserver-go --> not work $ go get -v gitlab.com/secmask/awserver-go.git --> work but I got src/gitlab.com/secmask/awserer-go.git
cd $GOPATH/src/github.com/secmask git clone git@github.com:secmask/awserver-go.git
$ git config --global url.git@github.com:.insteadOf https: $ cat ~/.gitconfig [url "git@github.com:"] insteadOf = https: $ go get github.com/private/repo
$ git config --global http.extraheader "PRIVATE-TOKEN: YOUR_PRIVATE_TOKEN
$ git config --global url."git@gitlab.mycompany.com:".insteadOf "https:
Host github.com HostName github.com User git IdentityFile ~/.ssh/id_github_com
Host domain.com HostName domain.com User admin IdentityFile ~/.ssh/id_domain_com
$ git config --global url."git@github.com:".insteadOf "https:
$ git config --global url."git@bitbucket.org:".insteadOf "https:
if _, err := os.Stat(path); os.IsNotExist(err) { fmt.Printf("%s does not exist\n", path) }
sum := 0 for _, value := range array { sum += value }
c := make(chan struct{}, 0) go func() { time.Sleep(2 * time.Second) <-c }() start := time.Now() c <- struct{}{} elapsed := time.Since(start) fmt.Printf("Elapsed: %v\n", elapsed)
package main import ( "fmt" "time" ) func receiver(ch <-chan int) { time.Sleep(500 * time.Millisecond) msg := <-ch fmt.Printf("receive messages %d from the channel\n", msg) } func main() { start := time.Now() zero_buffer_ch := make(chan int, 0) go receiver(zero_buffer_ch) zero_buffer_ch <- 444 elapsed := time.Since(start) fmt.Printf("Elapsed using zero_buffer channel: %v\n", elapsed) restart := time.Now() non_zero_buffer_ch := make(chan int, 1) go receiver(non_zero_buffer_ch) non_zero_buffer_ch <- 4444 reelapsed := time.Since(restart) fmt.Printf("Elapsed using non zero_buffer channel: %v\n", reelapsed) }
func main() { resp, err := http.Get("http: if err != nil { } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) ioutil.WriteFile("dump", body, 0600) for i:= 0; i < len(body); i++ { fmt.Println( body[i] ) } fmt.Println( reflect.TypeOf(body) ) fmt.Println("done") }
var client http.Client resp, err := client.Get(url) if err != nil { } defer resp.Body.Close() if resp.StatusCode == http.StatusOK { bodyBytes, err2 := ioutil.ReadAll(resp.Body) bodyString := string(bodyBytes) }
body, err := ioutil.ReadAll(resp.Body) bodyString := string(body)
➜ cd $GOROOT/src/pkg/math/ ➜ ls sqrt*s sqrt_386.s sqrt_amd64p32.s sqrt_amd64.s sqrt_arm.s
package main import ( "fmt" "runtime" ) func say(s string) { for i := 0; i < 5; i++ { runtime.Gosched() fmt.Println(s) } } func main() { go say("world") say("hello") }
hello world hello world hello world hello world hello
func main() { runtime.GOMAXPROCS(2) go say("world") say("hello") }
hyperplex /tmp % go run test.go hello hello hello world hello world hello world hyperplex /tmp % go run test.go hello world hello world hello world hello world hello world hyperplex /tmp % go run test.go hello hello hello hello hello hyperplex /tmp % go run test.go hello world hello world hello world hello world hello world
panic: runtime error: invalid memory address or nil pointer dereference [signal 0xb code=0x1 addr=0x38 pc=0x26df] goroutine 1 [running]: main.getBody(0x1cdcd4, 0xf800000004, 0x1f2b44, 0x23, 0xf84005c800, ...) /Users/matt/Dropbox/code/go/scripts/cron/fido.go:65 +0x2bb main.getToken(0xf84005c7e0, 0x10) /Users/matt/Dropbox/code/go/scripts/cron/fido.go:140 +0x156 main.main() /Users/matt/Dropbox/code/go/scripts/cron/fido.go:178 +0x61 goroutine 2 [syscall]: created by runtime.main /usr/local/Cellar/go/1.0.3/src/pkg/runtime/proc.c:221 goroutine 3 [syscall]: syscall.Syscall6() /usr/local/Cellar/go/1.0.3/src/pkg/syscall/asm_darwin_amd64.s:38 +0x5 syscall.kevent(0x6, 0x0, 0x0, 0xf840085188, 0xa, ...) /usr/local/Cellar/go/1.0.3/src/pkg/syscall/zsyscall_darwin_amd64.go:199 +0x88 syscall.Kevent(0xf800000006, 0x0, 0x0, 0xf840085188, 0xa0000000a, ...) /usr/local/Cellar/go/1.0.3/src/pkg/syscall/syscall_bsd.go:546 +0xa4 net.(*pollster).WaitFD(0xf840085180, 0xf840059040, 0x0, 0x0, 0x0, ...) /usr/local/Cellar/go/1.0.3/src/pkg/net/fd_darwin.go:96 +0x185 net.(*pollServer).Run(0xf840059040, 0x0) /usr/local/Cellar/go/1.0.3/src/pkg/net/fd.go:236 +0xe4 created by net.newPollServer /usr/local/Cellar/go/1.0.3/src/pkg/net/newpollserver.go:35 +0x382
package main /* Fido fetches the list of public images from the Glance server, captures the IDs of images with See http: */ import ( "bytes" "encoding/json" "fmt" "io/ioutil" /* "log" "log/syslog" */ "net/http" "os" "os/exec" ) func prefetchImages() error { cmd := exec.Command("glance-cache-prefetcher") err := cmd.Run() if err != nil { return fmt.Errorf("glance-cache-prefetcher failed to execute properly: %v", err) } return nil } func queueImages(hostname string, imageList []string) error { for _, image := range imageList { cmd := exec.Command("glance-cache-manage", "--host=", hostname, "queue-image", image) err := cmd.Run() if err != nil { return fmt.Errorf("glance-cache-manage failed to execute properly: %v", err) } else { fmt.Printf("Image %s queued", image) } } return nil } func getBody(method string, url string, headers map[string]string, body []byte) ([]byte, error) { client := &http.Client{} req, err := http.NewRequest(method, url, bytes.NewReader(body)) if err != nil { return nil, err } for key, value := range headers { req.Header.Add(key, value) } res, err := client.Do(req) defer res.Body.Close() if err != nil { return nil, err } var bodyBytes []byte if res.StatusCode == 200 { bodyBytes, err = ioutil.ReadAll(res.Body) } else if err != nil { return nil, err } else { return nil, fmt.Errorf("The remote end did not return a HTTP 200 (OK) response.") } return bodyBytes, nil } func getImages(authToken string) ([]string, error) { type GlanceDetailResponse struct { Images []struct { Name string `json:"name"` Status string `json:"status"` ID string `json:"id"` } } method := "GET" url := "http: headers := map[string]string{"X-Auth-Token": authToken} bodyBytes, err := getBody(method, url, headers, nil) if err != nil { return nil, fmt.Errorf("unable to retrieve the response body from the Glance API server: %v", err) } var glance GlanceDetailResponse err = json.Unmarshal(bodyBytes, &glance) if err != nil { return nil, fmt.Errorf("unable to parse the JSON response:", err) } imageList := make([]string, 10) for _, image := range glance.Images { if image.Status == "active" { imageList = append(imageList, image.ID) } } return imageList, nil } func getToken() (string, error) { type TokenResponse struct { Auth []struct { Token struct { Expires string `json:"expires"` ID string `json:"id"` } } } method := "POST" url := "http: headers := map[string]string{"Content-type": "application/json"} creds := []byte(`{"auth":{"passwordCredentials":{"username": "glance", "password":"<password>"}, "tenantId":"<tenantkeygoeshere>"}}`) bodyBytes, err := getBody(method, url, headers, creds) if err != nil { return "", err } var keystone TokenResponse err = json.Unmarshal(bodyBytes, &keystone) if err != nil { return "", err } authToken := string((keystone.Auth[0].Token.ID)) return authToken, nil } func main() { /* slog, err := syslog.New(syslog.LOG_ERR, "[fido]") if err != nil { log.Fatalf("unable to connect to syslog: %v", err) os.Exit(1) } else { defer slog.Close() } */ hostname, err := os.Hostname() if err != nil { os.Exit(1) } authToken, err := getToken() if err != nil { os.Exit(1) } imageList, err := getImages(authToken) err = queueImages(hostname, imageList) if err != nil { os.Exit(1) } err = prefetchImages() if err != nil { os.Exit(1) } return }
res, err := client.Do(req) defer res.Body.Close() if err != nil { return nil, err }
res, err := client.Do(req) if err != nil { return nil, err } defer res.Body.Close()
res, err := client.Do(req) defer res.Body.Close() if err != nil { return nil, err }
type AnimalSounder interface { MakeNoise() } type Dog struct { Name string mean bool BarkStrength int } func (dog *Dog) MakeNoise() { }
func ParseInt(s string, base int, bitSize int) (i int64, err error)
package main import ( "fmt" "strconv" ) func main() { i, err := strconv.ParseInt("123456", 10, 8) fmt.Println(i, err) }
func ParseInt(s string, base int, bitSize int) (i int64, err error)
int8 the set of all signed 8-bit integers (-128 to 127) int16 the set of all signed 16-bit integers (-32768 to 32767) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) int64 the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)
package main import ( "fmt" "runtime" "strconv" ) func main() { fmt.Println(runtime.Compiler, runtime.GOARCH, runtime.GOOS) fmt.Println(strconv.IntSize) }
reg, err := regexp.Compile(strings.Replace(s.Name, " ", "[ \\._-]", -1))
for i := 0; i < len(s.Name); i++ { if s.Name[i] == " " { fmt.Fprintf(str, "%s[ \\._-]", str); } else { fmt.Fprintf(str, "%s[%s%s]", str, strings.ToLower(s.Name[i]), strings.ToUpper(s.Name[i])) } }
reg, err := regexp.Compile("(?i)"+strings.Replace(s.Name, " ", "[ \\._-]", -1))
(re) numbered capturing group (?P<name>re) named & numbered capturing group (?:re) non-capturing group (?flags) set flags within current group; non-capturing (?flags:re) set flags during re; non-capturing
i case-insensitive (default false) m multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false) s let . match \n (default false) U ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)
/var/lib/docker/devicemapper/mnt/$CONTAINER_ID/rootfs/
func main() { data := []string{"one","two","three"} test(data) moredata := []int{1,2,3} test(data) } func test(t interface{}) { switch reflect.TypeOf(t).Kind() { case reflect.Slice: for _,value := range t { fmt.Println(value) } } }
package main import "fmt" import "reflect" func main() { data := []string{"one","two","three"} test(data) moredata := []int{1,2,3} test(moredata) } func test(t interface{}) { switch reflect.TypeOf(t).Kind() { case reflect.Slice: s := reflect.ValueOf(t) for i := 0; i < s.Len(); i++ { fmt.Println(s.Index(i)) } } }
package main import "fmt" func main() { loop([]string{"one", "two", "three"}) loop([]int{1, 2, 3}) } func loop(t interface{}) { switch t := t.(type) { case []string: for _, value := range t { fmt.Println(value) } case []int: for _, value := range t { fmt.Println(value) } } }
type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } ... type reverse struct { Interface }
func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) }
func Reverse(data Interface) Interface { return &reverse{data} }
type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } ... type reverse struct { Interface }
func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) }
package main import "fmt" type Stringer interface { String() string } type Struct1 struct { field1 string } func (s Struct1) String() string { return s.field1 } type Struct2 struct { field1 []string dummy bool } func (s Struct2) String() string { return fmt.Sprintf("%v, %v", s.field1, s.dummy) } type StringerContainer struct { Stringer } func main() { fmt.Println(StringerContainer{Struct1{"This is Struct1"}}) fmt.Println(StringerContainer{Struct2{[]string{"This", "is", "Struct1"}, true}}) fmt.Println(StringerContainer{"This is a type that does not implement Stringer"}) }
func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) }
func Reverse(data Interface) Interface { return &reverse{data} }
type T struct { a int } func (tv T) Mv(a int) int { return 0 } func (tp *T) Mp(f float32) float32 { return 1 }
BenchmarkChangePointerReceiver 2000000000 0.36 ns/op BenchmarkChangeItValueReceiver 500000000 3.62 ns/op BenchmarkChangePointerReceiver 2000000000 0.36 ns/op BenchmarkChangeItValueReceiver 2000000000 0.36 ns/op
// func (h extraHeader) Write(w *bufio.Writer) { ... }
type TokenCache struct { cache map[string]map[string]bool } func (c *TokenCache) Add(contract string, token string, authorized bool) { tokens := c.cache[contract] if tokens == nil { tokens = make(map[string]bool) } tokens[token] = authorized c.cache[contract] = tokens }
package rsa func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) ([]byte, error) { return []byte("secret text"), nil } cipherText, err := rsa.EncryptPKCS1v15(rand, pub, keyBlock)
package main import ( "fmt" "sort" ) func main() { m := make(map[int]string) m[1] = "a" m[2] = "c" m[0] = "b" var keys []int for k := range m { keys = append(keys, k) } sort.Ints(keys) for _, k := range keys { fmt.Println("Key:", k, "Value:", m[k]) } }
var m map[keyType]valueType keys := sliceOfKeys(m) for _, k := range keys { v := m[k] }
/* Go apparently doesn /* key) of a map such that any arbitrary type can be substituted at /* run time, so several of these nearly-identical functions might be /* needed for different key/value type combinations. */ func sortedMap<K><T>(m map[<K>]<V>, f func(k <K>, v <V>)) { var keys []<K> for k, _ := range m { keys = append(keys, k) } sort.Strings(keys) for _, k := range keys { v := m[k] f(k, v) } }
package main import ( "fmt" "sort" ) func sortedMapIntString(m map[int]string, f func(k int, v string)) { var keys []int for k, _ := range m { keys = append(keys, k) } sort.Ints(keys) for _, k := range keys { f(k, m[k]) } } func main() { m := make(map[int]string) m[1] = "a" m[2] = "c" m[0] = "b" sortedMapIntString(m, func(k int, v string) { fmt.Println("Key:", k, "Value:", v) }) }
m := make(map[int]string) m[1] = "a" m[2] = "c" m[0] = "b" for i := 0; i < len(m); i++ { fmt.Println("Key:", i, "Value:", m[i]) }
package main import "os/exec" func main() { cmd := exec.Command("zenity", "--info", "--text= cmd.Run() }
package main import ( "os/exec" "strconv" ) func main() { NumEl := 8 for i:=0; i<NumEl; i++ { cmd := exec.Command("zenity", "--info", "--text= cmd.Run() } }
package main import ( "os/exec" "strconv" ) func main() { NumEl := 8 for i:=0; i<NumEl; i++ { go callProg(i) } } func callProg(i int) { cmd := exec.Command("zenity", "--info", "--text= cmd.Run() }
package main import ( "os/exec" "strconv" ) func main() { NumEl := 8 NumCore := 4 c := make(chan bool, NumCore - 1) for i:=0; i<NumEl; i++ { go callProg(i, c) c <- true } } func callProg(i int, c chan bool) { defer func () {<- c}() cmd := exec.Command("zenity", "--info", "--text= cmd.Run() }
package main import ( "os/exec" "strconv" "sync" ) func main() { NumEl := 8 NumCore := 4 c := make(chan bool, NumCore - 1) wg := new(sync.WaitGroup) wg.Add(NumEl) for i:=0; i<NumEl; i++ { go callProg(i, c, wg) c <- true } wg.Wait() close(c) } func callProg(i int, c chan bool, wg *sync.WaitGroup) { defer func () { <- c wg.Done() }() cmd := exec.Command("zenity", "--info", "--text= cmd.Run() }
package main import ( "os/exec" "strconv" "sync" ) func main() { tasks := make(chan *exec.Cmd, 64) var wg sync.WaitGroup for i := 0; i < 4; i++ { wg.Add(1) go func() { for cmd := range tasks { cmd.Run() } wg.Done() }() } for i := 0; i < 10; i++ { tasks <- exec.Command("zenity", "--info", "--text= } close(tasks) wg.Wait() }
package main import ( "sync" ) const maxConcurrency = 4 var throttle = make(chan int, maxConcurrency) func main() { const N = 100 var wg sync.WaitGroup for i := 0; i < N; i++ { throttle <- 1 wg.Add(1) go f(i, &wg, throttle) } wg.Wait() } func f(i int, wg *sync.WaitGroup, throttle chan int) { defer wg.Done() println(i) <-throttle }
limiter := NewConcurrencyLimiter(10) limiter.Execute(func() { zenity(...) }) limiter.Wait()
type Giver interface { Give() int64 } type FiveGiver struct {} func (fg *FiveGiver) Give() int64 { return 5 } type VarGiver struct { number int64 } func (vg *VarGiver) Give() int64 { return vg.number }
func GetSomething(aGiver Giver) { fmt.Println("The Giver gives: ", aGiver.Give()) } func main() { fg := &FiveGiver{} vg := &VarGiver{3} GetSomething(fg) GetSomething(vg) }
type Person interface { Name string Age int64 } type Bob struct implements Person { ... } func PrintName(aPerson Person) { fmt.Println("Person } func main() { b := &Bob{"Bob", 23} PrintName(b) }
type PersonProvider interface { GetPerson() *Person } type Person struct { Name string Age int64 } func (p *Person) GetPerson() *Person { return p } type Bob struct { FavoriteNumber int64 Person }
func DoBirthday(pp PersonProvider) { pers := pp.GetPerson() pers.Age += 1 } func SayHi(pp PersonProvider) { fmt.Printf("Hello, %v!\r", pp.GetPerson().Name) } func main() { b := &Bob{ 5, Person{"Bob", 23}, } DoBirthday(b) SayHi(b) fmt.Printf("You }
var stmt *sql.Stmt var err error stmt, err = db.Prepare(selectStatement) if err != nil { fmt.Printf("db.Prepare error: %v\n",err) return err }
db.Prepare error: pq: SSL is not enabled on the server
db, err := sql.Open("postgres", "user=test password=test dbname=test sslmode=disable")
map[<host>:www.google.de <port>:80 --help:false --version:false]
host := arguments["<host>"] + ":" + arguments["<port>"]
host := arguments["<host>"].(string) + ":" + arguments["<port>"].(string)
host, err := arguments.String("<host>") port, err := arguments.String("<port>") host_port := host + ":" + port
hostAndPort := fmt.Sprintf("%v:%v", arguments["<host>"], arguments["<port>"])
can package project/controllers/account imports project/controllers/base imports project/components/mux imports project/controllers/account import cycle not allowed package project/controllers/account imports project/controllers/base imports project/components/mux imports project/controllers/account import cycle not allowed package project/controllers/account imports project/controllers/base imports project/components/mux imports project/controllers/routes imports project/controllers/base
project/controllers/account ^ \ / \ / \ / \/ project/components/mux <--- project/controllers/base
func my_func(a, b int) (int) { return a + b } func main() { arr := []int{2,4} sum := my_func(arr) }
package main import "fmt" func my_func( args ...int) int { sum := 0 for _,v := range args { sum = sum + v } return sum; } func main() { arr := []int{2,4} sum := my_func(arr...) fmt.Println("Sum is ", sum) }
package main import "fmt" import "reflect" func my_func(a, b int) (int) { return a + b } func main() { arr := []int{2,4} var args []reflect.Value for _, x := range arr { args = append(args, reflect.ValueOf(x)) } fun := reflect.ValueOf(my_func) result := fun.Call(args) sum := result[0].Interface().(int) fmt.Println("Sum is ", sum) }
package main import ( "strconv" "strings" ) func tryIndex(arr []string, index int, def string) string { if index <= len(arr)-1 { return arr[index] } return def } /* * Takes two strings of format "hh:mm:ss" and compares them. * Takes a function to compare individual sections (split by ":"). * Note: strings can actually be formatted like "h", "hh", "hh:m", * "hh:mm", etc. Any missing parts will be added lazily. */ func timeCompare(a, b string, compare func(int, int) (bool, bool)) bool { aArr := strings.Split(a, ":") bArr := strings.Split(b, ":") if (b == a) { return true } for i := range aArr { aI, _ := strconv.Atoi(tryIndex(aArr, i, "00")) bI, _ := strconv.Atoi(tryIndex(bArr, i, "00")) res, flag := compare(aI, bI) if res { return true } else if flag { return false } } return false } func timeGreaterEqual(a, b int) (bool, bool) {return a > b, a < b} func timeLesserEqual(a, b int) (bool, bool) {return a < b, a > b} /* * Returns true for two strings formmated "hh:mm:ss". * Note: strings can actually be formatted like "h", "hh", "hh:m", * "hh:mm", etc. Any missing parts will be added lazily. */ func withinTime(timeRange, time string) bool { rArr := strings.Split(timeRange, "-") if timeCompare(rArr[0], rArr[1], timeLesserEqual) { afterStart := timeCompare(rArr[0], time, timeLesserEqual) beforeEnd := timeCompare(rArr[1], time, timeGreaterEqual) return afterStart && beforeEnd } afterStart := timeCompare(rArr[0], time, timeLesserEqual) beforeEnd := timeCompare(rArr[1], time, timeGreaterEqual) return afterStart || beforeEnd }
function withinTime(start, end, time) { var s = Date.parse("01/01/2011 "+start); var e = Date.parse("01/0"+(end=="24:00:00"?"2":"1")+"/2011 "+(end=="24:00:00"?"00:00:00":end)); var t = Date.parse("01/01/2011 "+time); return s <= t && e >= t; }
package main import ( "fmt" "time" ) func inTimeSpan(start, end, check time.Time) bool { return check.After(start) && check.Before(end) } func main() { start, _ := time.Parse(time.RFC822, "01 Jan 15 10:00 UTC") end, _ := time.Parse(time.RFC822, "01 Jan 16 10:00 UTC") in, _ := time.Parse(time.RFC822, "01 Jan 15 20:00 UTC") out, _ := time.Parse(time.RFC822, "01 Jan 17 10:00 UTC") if inTimeSpan(start, end, in) { fmt.Println(in, "is between", start, "and", end, ".") } if !inTimeSpan(start, end, out) { fmt.Println(out, "is not between", start, "and", end, ".") } }
loc, _ := time.LoadLocation("UTC") createdAt := time.Now().In(loc).Add(1 * time.Hour) expiresAt := time.Now().In(loc).Add(4 * time.Hour) diff := expiresAt.Sub(createdAt) fmt.Printf("Lifespan is %+v", diff)
end = end.Add(time.Duration(23*time.Hour) + time.Duration(59*time.Minute) + time.Duration(59*time.Second)) if now.After(start) && now.Before(end) { ... }
import ( "fmt" "time" ) func main() { value := "Thu, 05/19/11, 10:47PM" layout := "Mon, 01/02/06, 03:04PM" t, _ := time.Parse(layout, value) fmt.Println(t) }
cutOffTime, _ := time.Parse(time.RFC3339, "2017-08-30T13:35:00Z") query := datastore.NewQuery("db").Filter("POSTDATE >=", cutOffTime).
func Lookup(name string) *Profile func (p *Profile) WriteTo(w io.Writer, debug int) error
go func() { log.Println(http.ListenAndServe("localhost:6060", nil)) }()
buf := make([]byte, 1<<16) runtime.Stack(buf, true) fmt.Printf("%s", buf)
if r := recover(); r != nil { log.Printf("Internal error: %v", r)) buf := make([]byte, 1<<16) stackSize := runtime.Stack(buf, true) log.Printf("%s\n", string(buf[0:stackSize])) }
t := time.Now() fmt.Println(t.Format("yyyyMMddHHmmss"))
const ( stdLongMonth = "January" stdMonth = "Jan" stdNumMonth = "1" stdZeroMonth = "01" stdLongWeekDay = "Monday" stdWeekDay = "Mon" stdDay = "2" stdUnderDay = "_2" stdZeroDay = "02" stdHour = "15" stdHour12 = "3" stdZeroHour12 = "03" stdMinute = "4" stdZeroMinute = "04" stdSecond = "5" stdZeroSecond = "05" stdLongYear = "2006" stdYear = "06" stdPM = "PM" stdpm = "pm" stdTZ = "MST" stdISO8601TZ = "Z0700" stdISO8601ColonTZ = "Z07:00" stdNumTZ = "-0700" stdNumShortTZ = "-07" stdNumColonTZ = "-07:00" )
date := jodaTime.Format("YYYY.MM.dd", time.Now()) fmt.Println(date)
func ExampleTime_Format() { const layout = "Jan 2, 2006 at 3:04pm (MST)" t := time.Date(2009, time.November, 10, 15, 0, 0, 0, time.Local) fmt.Println(t.Format(layout)) fmt.Println(t.UTC().Format(layout)) }
package main import ( "encoding/json" "fmt" ) type Product struct { Name string Price float64 } func main() { s := `{"name":"Galaxy Nexus", "price":"3460.00"}` var pro Product err := json.Unmarshal([]byte(s), &pro) if err == nil { fmt.Printf("%+v\n", pro) } else { fmt.Println(err) fmt.Printf("%+v\n", pro) } }
json: cannot unmarshal string into Go value of type float64 {Name:Galaxy Nexus Price:0}
package main import ( "encoding/json" "fmt" ) type Product struct { Name string Price float64 `json:",string"` } func main() { s := `{"name":"Galaxy Nexus", "price":"3460.00"}` var pro Product err := json.Unmarshal([]byte(s), &pro) if err == nil { fmt.Printf("%+v\n", pro) } else { fmt.Println(err) fmt.Printf("%+v\n", pro) } }
package main import ( "encoding/json" "fmt" "strings" ) type Product struct { Name string `json:"name"` Price float64 `json:"price,string"` } func main() { s := `{"name":"Galaxy Nexus","price":"3460.00"}` var pro Product err := json.NewDecoder(strings.NewReader(s)).Decode(&pro) if err != nil { fmt.Println(err) return } fmt.Println(pro) }
package main import ( "encoding/json" "fmt" "strconv" ) type Product struct { Name string Price string PriceFloat float64 } func main() { s := `{"name":"Galaxy Nexus", "price":"3460.00"}` var pro Product err := json.Unmarshal([]byte(s), &pro) if err == nil { pro.PriceFloat, err = strconv.ParseFloat(pro.Price, 64) if err != nil { fmt.Println(err) } fmt.Printf("%+v\n", pro) } else { fmt.Println(err) fmt.Printf("%+v\n", pro) } }
package main import ( "encoding/json" "fmt" "io" "log" "strings" ) func main() { const jsonStream = ` {"Name": "Ed", "Text": "Knock knock."} {"Name": "Sam", "Text": "Who {"Name": "Ed", "Text": "Go fmt."} {"Name": "Sam", "Text": "Go fmt who?"} {"Name": "Ed", "Text": "Go fmt yourself!"} ` type Message struct { Name, Text string } dec := json.NewDecoder(strings.NewReader(jsonStream)) for { var m Message if err := dec.Decode(&m); err == io.EOF { break } else if err != nil { log.Fatal(err) } fmt.Printf("%s: %s\n", m.Name, m.Text) } }
len(s) string type string length in bytes [n]T, *[n]T array length (== n) []T slice length map[K]T map length (number of defined keys) chan T number of elements queued in channel buffer
package main import ( "fmt" "net/url" ) func main() { var Url *url.URL Url, err := url.Parse("http: if err != nil { panic("boom") } Url.Path += "/some/path/or/other_with_funny_characters?_or_not/" parameters := url.Values{} parameters.Add("hello", "42") parameters.Add("hello", "54") parameters.Add("vegetable", "potato") Url.RawQuery = parameters.Encode() fmt.Printf("Encoded URL is %q\n", Url.String()) }
function fixedEncodeURIComponent (str) { return encodeURIComponent(str).replace(/[! }
import "net/url" func UrlEncoded(str string) (string, error) { u, err := url.Parse(str) if err != nil { return "", err } return u.String(), nil }
package main import ( "fmt" "strconv" ) const ( encodePath encoding = 1 + iota encodeHost encodeUserPassword encodeQueryComponent encodeFragment ) type encoding int type EscapeError string func (e EscapeError) Error() string { return "invalid URL escape " + strconv.Quote(string(e)) } func ishex(c byte) bool { switch { case return true case return true case return true } return false } func unhex(c byte) byte { switch { case return c - case return c - case return c - } return 0 } // func shouldEscape(c byte, mode encoding) bool { if return false } if mode == encodeHost { switch c { case return false } } switch c { case return false case switch mode { case encodePath: return c == case encodeUserPassword: return c == case encodeQueryComponent: return true case encodeFragment: return false } } return true } func escape(s string, mode encoding) string { spaceCount, hexCount := 0, 0 for i := 0; i < len(s); i++ { c := s[i] if shouldEscape(c, mode) { if c == spaceCount++ } else { hexCount++ } } } if spaceCount == 0 && hexCount == 0 { return s } t := make([]byte, len(s)+2*hexCount) j := 0 for i := 0; i < len(s); i++ { switch c := s[i]; { case c == t[j] = j++ case shouldEscape(c, mode): t[j] = t[j+1] = "0123456789ABCDEF"[c>>4] t[j+2] = "0123456789ABCDEF"[c&15] j += 3 default: t[j] = s[i] j++ } } return string(t) } func unescape(s string, mode encoding) (string, error) { n := 0 hasPlus := false for i := 0; i < len(s); { switch s[i] { case n++ if i+2 >= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) { s = s[i:] if len(s) > 3 { s = s[:3] } return "", EscapeError(s) } i += 3 case hasPlus = mode == encodeQueryComponent i++ default: i++ } } if n == 0 && !hasPlus { return s, nil } t := make([]byte, len(s)-2*n) j := 0 for i := 0; i < len(s); { switch s[i] { case t[j] = unhex(s[i+1])<<4 | unhex(s[i+2]) j++ i += 3 case if mode == encodeQueryComponent { t[j] = } else { t[j] = } j++ i++ default: t[j] = s[i] j++ i++ } } return string(t), nil } func EncodeUriComponent(rawString string) string{ return escape(rawString, encodeFragment) } func DecodeUriCompontent(encoded string) (string, error){ return unescape(encoded, encodeQueryComponent) } func main() { origin := "äöüHel/lo world" encoded := EncodeUriComponent(origin) fmt.Println(encoded) s, _ := DecodeUriCompontent(encoded) fmt.Println(s) }
/* func UrlEncoded(str string) (string, error) { u, err := url.Parse(str) if err != nil { return "", err } return u.String(), nil } func old_main() { a,err := UrlEncoded("hello world") if err != nil { fmt.Println(err) } fmt.Println(a) s := "postgres: u, err := url.Parse(s) if err != nil { panic(err) } fmt.Println(u.RawQuery) fmt.Println(u.Fragment) fmt.Println(u.String()) m, _ := url.ParseQuery(u.RawQuery) fmt.Println(m) fmt.Println(m["k"][0]) } */
package main import ( "fmt" "net/url" "strings" ) func main() { params := url.Values{ "test_string": {"+!+ } urlEncode := params.Encode() fmt.Println(urlEncode) urlEncode = compatibleRFC3986Encode(urlEncode) fmt.Println("RFC3986", urlEncode) urlEncode = compatibleJSEncodeURIComponent(urlEncode) fmt.Println("JS encodeURIComponent", urlEncode) } func compatibleRFC3986Encode(str string) string { resultStr := str resultStr = strings.Replace(resultStr, "+", "%20", -1) return resultStr } func compatibleJSEncodeURIComponent(str string) string { resultStr := str resultStr = strings.Replace(resultStr, "+", "%20", -1) resultStr = strings.Replace(resultStr, "%21", "!", -1) resultStr = strings.Replace(resultStr, "%27", " resultStr = strings.Replace(resultStr, "%28", "(", -1) resultStr = strings.Replace(resultStr, "%29", ")", -1) resultStr = strings.Replace(resultStr, "%2A", "*", -1) return resultStr }
package main import ( "fmt" ) func main() { m := make(map[int]string) m[1] = "a" m[2] = "b" m[3] = "c" m[4] = "d" v := make([]string, len(m), len(m)) idx := 0 for _, value := range m { v[idx] = value idx++ } fmt.Println(v) }
m := make(map[int]string) m[1] = "a" m[2] = "b" m[3] = "c" m[4] = "d" v := make([]string, 0, len(m)) for _, value := range m { v = append(v, value) }
package main import ( "fmt" ) func main() { m := make(map[int]string) m[1] = "a" ; m[2] = "b" ; m[3] = "c" ; m[4] = "d" ip := 0 /* If the elements of m are not all of fixed length you must use a method like this; * in that case also consider: * bytes.Join() and/or * strings.Join() * They are likely preferable for maintainability over small performance change. for _, v := range m { ip += len(v) } */ ip = len(m) * 1 r := make([]byte, ip, ip) ip = 0 for _, v := range m { ip += copy(r[ip:], v) } fmt.Printf("%s\n", r) }
cannot range over mymap typechecking loop involving for loop
package main import "fmt" func main() { type Map1 map[string]interface{} type Map2 map[string]int m := Map1{"foo": Map2{"first": 1}, "boo": Map2{"second": 2}} fmt.Println("m:", m) for k, v := range m { fmt.Println("k:", k, "v:", v) } }
m: map[boo:map[second:2] foo:map[first:1]] k: boo v: map[second:2] k: foo v: map[first:1]
mymap := map[string]interface{}{"foo": map[string]interface{}{"first": 1}, "boo": map[string]interface{}{"second": 2}} for k, v := range mymap { fmt.Println("k:", k, "v:", v) }
var runIntegrationTests = flag.Bool("integration", false , "Run the integration tests (in addition to the unit tests)")
if !*runIntegrationTests { this.T().Skip("To run this test, use: go test -integration") }
var fooAddr = flag.String(...) func TestToo(t *testing.T) { f, err := foo.Connect(*fooAddr) }
package services import "testing" func TestServiceFunc(t *testing.T) { t.Parallel() ... } func TestInvalidServiceFunc3(t *testing.T) { t.Parallel() ... } func TestPostgresVersionIntegration(t *testing.T) { if testing.Short() { t.Skip("skipping integration test") } ... }
=== RUN TestPostgresVersionIntegration --- SKIP: TestPostgresVersionIntegration (0.00s) service_test.go:138: skipping integration test
package main import ( "flag" "regexp" "testing" ) func TestIntegration(t *testing.T) { if m := flag.Lookup("test.run").Value.String(); m == "" || !regexp.MustCompile(m).MatchString(t.Name()) { t.Skip("skipping as execution was not requested explicitly using go test -run") } t.Parallel() t.Run("HelloWorld", testHelloWorld) t.Run("SayHello", testSayHello) }
If the arguments are a list of .go files, build treats them as a list of source files specifying a single package.
./main.go:xx: cannot use &0 (type *int) as type *int64 in field value
var placeholder int64 placeholder = 0 instance := SomeType{ SomeField: &placeholder, }
helper := int64(2) instance2 := SomeType{ SomeField: &helper, }
instance4 := SomeType{ SomeField: func() *int64 { i := int64(4); return &i }(), }
instance4 := SomeType{ SomeField: func(i int64) *int64 { return &i }(4), }
instance5 := SomeType{ SomeField: &[]int64{5}[0], } fmt.Println(*instance2.SomeField)
instance6 := SomeType{ SomeField: &(&intwrapper{6}).x, }
instance7 := SomeType{ SomeField: &(&struct{ x int64 }{7}).x, }
type myStr struct { url *int64 } func main() { f := func(s int64) *int64 { return &s } myStr{ url: f(12345), } }
package main import "fmt" func main() { c := make(chan int, 100) for i := 0; i < 34; i++ { c <- 0 } fmt.Println(len(c)) }
package main import ( "fmt" "html" "log" "net/http" ) func main() { http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { if r.URL.Path != "/" { http.NotFound(w, r) return } if r.Method == "GET" { fmt.Fprintf(w, "GET, %q", html.EscapeString(r.URL.Path)) } else if r.Method == "POST" { fmt.Fprintf(w, "POST, %q", html.EscapeString(r.URL.Path)) } else { http.Error(w, "Invalid request method.", 405) } }) log.Fatal(http.ListenAndServe(":8080", nil)) }
switch r.Method { case http.MethodGet: case http.MethodPost: case http.MethodPut: case http.MethodDelete: default: }
func main() { r := mux.NewRouter() r.HandleFunc("/", HomeHandler) r.HandleFunc("/products", ProductsHandler) r.HandleFunc("/articles", ArticlesHandler) http.Handle("/", r) }
r.HandleFunc("/products", ProductsHandler). Host("www.domain.com"). Methods("GET"). Schemes("http")
package main import "fmt" func main() { } func demo() { fmt.Println("HI") }
package main import ( L "./lib" ) func main() { L.Demo() }
package lib import "fmt" func Demo() { fmt.Println("HI") }
dst := make(map[K]V, len(src)) for k, v := range src { dst[k] = v }
func MapCopy(dst, src interface{}) { dv, sv := reflect.ValueOf(dst), reflect.ValueOf(src) for _, k := range sv.MapKeys() { dv.SetMapIndex(k, sv.MapIndex(k)) } }
m1 := map[int]string{1: "one", 2: "two"} m2 := map[int]string{} MapCopy(m2, m1) fmt.Println(m2) m3 := map[string]int{"one": 1, "two": 2} m4 := map[string]int{} MapCopy(m4, m3) fmt.Println(m4)
input := map[string]interface{}{ "Key1": 2, "key3": nil, "val": 2, "val2": "str", "val3": 4, } input2 := map[string]interface{}{ "a2": "str", "a3": 4, } input = mapop.Merge(input, input2) input{"Key1": 2, "key3": nil, "val": 2, "val2": "str", "val3": 4, "a2": "str", "a3": 4}
if t, _, err := os.Time(); err == nil { port[5] = int32(t) }
import "time" ... port[5] = int32(time.Now().Unix())
package main import ( "fmt" "strconv" "time" ) func main() { timestamp := strconv.FormatInt(time.Now().UTC().UnixNano(), 10) fmt.Println(timestamp) }
s := map[int]bool{5: true, 2: true} _, ok := s[6] s[8] = true delete(s, 2)
s_union := map[int]bool{} for k, _ := range s1{ s_union[k] = true } for k, _ := range s2{ s_union[k] = true }
s_intersection := map[int]bool{} for k,_ := range s1 { if s2[k] { s_intersection[k] = true } }
func IsInEvenNumbers(n int) bool { if n % 2 == 0 { return true } return false }
func ServeHTTP(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusInternalServerError) w.Write([]byte("500 - Something bad happened!")) }
func yourFuncHandler(w http.ResponseWriter, r *http.Request) { http.Error(w, "my own error message", http.StatusForbidden) http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound) }
w.WriteHeader(http.StatusInternalServerError) w.WriteHeader(http.StatusForbidden)
%v the value in a default format. when printing structs, the plus flag (%+v) adds field names %
s := []string{"foo", "bar", "baz"} fmt.Println(strings.Join(s, ", "))
a := []string{"a", "b"} fmt.Printf(strings.Trim(fmt.Sprintf(a), "[]") fmt.Printf(a)
a := []string{"[a]", "[b]"} fmt.Printf(strings.Trim(fmt.Sprintf(a), "[]") fmt.Printf(a)
func rankByWordCount(wordFrequencies map[string]int) PairList{ pl := make(PairList, len(wordFrequencies)) i := 0 for k, v := range wordFrequencies { pl[i] = Pair{k, v} i++ } sort.Sort(sort.Reverse(pl)) return pl } type Pair struct { Key string Value int } type PairList []Pair func (p PairList) Len() int { return len(p) } func (p PairList) Less(i, j int) bool { return p[i].Value < p[j].Value } func (p PairList) Swap(i, j int){ p[i], p[j] = p[j], p[i] }
package main import ( "fmt" "sort" ) func main() { m := map[string]int{ "something": 10, "yo": 20, "blah": 20, } type kv struct { Key string Value int } var ss []kv for k, v := range m { ss = append(ss, kv{k, v}) } sort.Slice(ss, func(i, j int) bool { return ss[i].Value > ss[j].Value }) for _, kv := range ss { fmt.Printf("%s, %d\n", kv.Key, kv.Value) } }
package main import ( "fmt" "sort" ) func main() { m := map[string]int{"hello": 10, "foo": 20, "bar": 20} n := map[int][]string{} var a []int for k, v := range m { n[v] = append(n[v], k) } for k := range n { a = append(a, k) } sort.Sort(sort.Reverse(sort.IntSlice(a))) for _, k := range a { for _, s := range n[k] { fmt.Printf("%s, %d\n", s, k) } } }
package main import ( "fmt" "io" "os" ) func CopyFile(src, dst string) (err error) { sfi, err := os.Stat(src) if err != nil { return } if !sfi.Mode().IsRegular() { return fmt.Errorf("CopyFile: non-regular source file %s (%q)", sfi.Name(), sfi.Mode().String()) } dfi, err := os.Stat(dst) if err != nil { if !os.IsNotExist(err) { return } } else { if !(dfi.Mode().IsRegular()) { return fmt.Errorf("CopyFile: non-regular destination file %s (%q)", dfi.Name(), dfi.Mode().String()) } if os.SameFile(sfi, dfi) { return } } if err = os.Link(src, dst); err == nil { return } err = copyFileContents(src, dst) return } func copyFileContents(src, dst string) (err error) { in, err := os.Open(src) if err != nil { return } defer in.Close() out, err := os.Create(dst) if err != nil { return } defer func() { cerr := out.Close() if err == nil { err = cerr } }() if _, err = io.Copy(out, in); err != nil { return } err = out.Sync() return } func main() { fmt.Printf("Copying %s to %s\n", os.Args[1], os.Args[2]) err := CopyFile(os.Args[1], os.Args[2]) if err != nil { fmt.Printf("CopyFile failed %q\n", err) } else { fmt.Printf("CopyFile succeeded\n") } }
func Copy(src, dst string) error { in, err := os.Open(src) if err != nil { return err } defer in.Close() out, err := os.Create(dst) if err != nil { return err } defer out.Close() _, err = io.Copy(out, in) if err != nil { return err } return out.Close() }
srcFolder := "copy/from/path" destFolder := "copy/to/path" cpCmd := exec.Command("cp", "-rf", srcFolder, destFolder) err := cpCmd.Run()
import ( "io/ioutil" "log" ) func checkErr(err error) { if err != nil { log.Fatal(err) } } func copy(src string, dst string) { data, err := ioutil.ReadFile(src) checkErr(err) err = ioutil.WriteFile(dst, data, 0644) checkErr(err) }
func Copy(src, dst string) (int64, error) { src_file, err := os.Open(src) if err != nil { return 0, err } defer src_file.Close() src_file_stat, err := src_file.Stat() if err != nil { return 0, err } if !src_file_stat.Mode().IsRegular() { return 0, fmt.Errorf("%s is not a regular file", src) } dst_file, err := os.Create(dst) if err != nil { return 0, err } defer dst_file.Close() return io.Copy(dst_file, src_file) }
package main import ( "os" "log" "io" ) func main() { sFile, err := os.Open("test.txt") if err != nil { log.Fatal(err) } defer sFile.Close() eFile, err := os.Create("test_copy.txt") if err != nil { log.Fatal(err) } defer eFile.Close() _, err = io.Copy(eFile, sFile) if err != nil { log.Fatal(err) } err = eFile.Sync() if err != nil { log.Fatal(err) } }
package utils import ( "syscall" "unsafe" ) var ( modkernel32 = syscall.NewLazyDLL("kernel32.dll") procCopyFileW = modkernel32.NewProc("CopyFileW") ) func CopyFile(src, dst string, failIfExists bool) error { lpExistingFileName, err := syscall.UTF16PtrFromString(src) if err != nil { return err } lpNewFileName, err := syscall.UTF16PtrFromString(dst) if err != nil { return err } var bFailIfExists uint32 if failIfExists { bFailIfExists = 1 } else { bFailIfExists = 0 } r1, _, err := syscall.Syscall( procCopyFileW.Addr(), 3, uintptr(unsafe.Pointer(lpExistingFileName)), uintptr(unsafe.Pointer(lpNewFileName)), uintptr(bFailIfExists)) if r1 == 0 { return err } return nil }
package main import ( "fmt" "strings" ) func main() { fmt.Println(strings.ToLower("Gopher")) }
strings.ToLowerSpecial(unicode.TurkishCase, "Hello, WoRLd")
err := database.QueryRow("select * from users where user_id=?", id).Scan(&ReadUser.ID, &ReadUser.Name, &ReadUser.First, &ReadUser.Last, &ReadUser.Email)
err := database.QueryRow("select * from users where user_id=?", id) \ .Scan(&ReadUser.ID, &ReadUser.Name, &ReadUser.First, &ReadUser.Last, &ReadUser.Email)
err := database.QueryRow("select * from users where user_id=?", id) .Scan(&ReadUser.ID, &ReadUser.Name, &ReadUser.First, &ReadUser.Last, &ReadUser.Email);
err := database.QueryRow( "select * from users where user_id=?", id, ).Scan( &ReadUser.ID, &ReadUser.Name, &ReadUser.First, &ReadUser.Last, &ReadUser.Email, )
err := database. QueryRow("select * from users where user_id=?", id). Scan( &ReadUser.ID, &ReadUser.Name, &ReadUser.First, &ReadUser.Last, &ReadUser.Email, )
type Example struct { a_number uint32 a_string string } r := &Example{(2 << 31) - 1, "...."}: for _, d:= range []interface{}{ r.a_number, r.a_string, } { }
import ( "fmt" "reflect" ) func main() { x := struct{Foo string; Bar int }{"foo", 2} v := reflect.ValueOf(x) values := make([]interface{}, v.NumField()) for i := 0; i < v.NumField(); i++ { values[i] = v.Field(i).Interface() } fmt.Println(values) }
func Pic(dx, dy int) [][]uint8 { pic := make([][]uint8, dy) for i := range pic { pic[i] = make([]uint8, dx) for j := range pic[i] { pic[i][j] = uint8((i+j)/2) } } return pic }
package main import "fmt" func main() { ss := make([][]uint8, 2) fmt.Printf("ss: %T %v %d\n", ss, ss, len(ss)) for i, s := range ss { fmt.Printf("ss[%d]: %T %v %d\n", i, s, s, len(s)) } }
ss: [][]uint8 [[] []] 2 ss[0]: []uint8 [] 0 ss[1]: []uint8 [] 0
map := cmap.NewConcurrentMap() map.Add("foo", "bar") tmp, ok := map.Get("foo") if ok == true { bar := tmp.(string) } map.Remove("foo")
type Map map[string]string var m Value m.Store(make(Map)) read := func(key string) (val string) { m1 := m.Load().(Map) return m1[key] } insert := func(key, val string) { m1 := m.Load().(Map) m2 := make(Map) for k, v := range m1 { m2[k] = v } m2[key] = val m.Store(m2) }
type DataManager struct { /** This contain connection to know dataStore **/ m_dataStores map[string]DataStore /** That channel is use to access the dataStores map **/ m_dataStoreChan chan map[string]interface{} } func newDataManager() *DataManager { dataManager := new(DataManager) dataManager.m_dataStores = make(map[string]DataStore) dataManager.m_dataStoreChan = make(chan map[string]interface{}, 0) go func() { for { select { case op := <-dataManager.m_dataStoreChan: if op["op"] == "getDataStore" { storeId := op["storeId"].(string) op["store"].(chan DataStore) <- dataManager.m_dataStores[storeId] } else if op["op"] == "getDataStores" { stores := make([]DataStore, 0) for _, store := range dataManager.m_dataStores { stores = append(stores, store) } op["stores"].(chan []DataStore) <- stores } else if op["op"] == "setDataStore" { store := op["store"].(DataStore) dataManager.m_dataStores[store.GetId()] = store } else if op["op"] == "removeDataStore" { storeId := op["storeId"].(string) delete(dataManager.m_dataStores, storeId) } } } }() return dataManager } /** * Access Map functions... */ func (this *DataManager) getDataStore(id string) DataStore { arguments := make(map[string]interface{}) arguments["op"] = "getDataStore" arguments["storeId"] = id result := make(chan DataStore) arguments["store"] = result this.m_dataStoreChan <- arguments return <-result } func (this *DataManager) getDataStores() []DataStore { arguments := make(map[string]interface{}) arguments["op"] = "getDataStores" result := make(chan []DataStore) arguments["stores"] = result this.m_dataStoreChan <- arguments return <-result } func (this *DataManager) setDataStore(store DataStore) { arguments := make(map[string]interface{}) arguments["op"] = "setDataStore" arguments["store"] = store this.m_dataStoreChan <- arguments } func (this *DataManager) removeDataStore(id string) { arguments := make(map[string]interface{}) arguments["storeId"] = id arguments["op"] = "removeDataStore" this.m_dataStoreChan <- arguments }
import ( "sync" ) type AtomicMap struct { data map[string]string rwLock sync.RWMutex } func (self *AtomicMap) Get(key string) (string, bool) { self.rwLock.RLock() defer self.rwLock.RUnlock() val, found := self.data[key] return val, found } func (self *AtomicMap) Set(key, val string) { self.rwLock.Lock() defer self.rwLock.Unlock() self.data[key] = val }
tr := &http.Transport{} client := &http.Client{Transport: tr}
r, err := client.Post(url, "application/json", post)
res, _ := client.Do(req) io.Copy(ioutil.Discard, res.Body) res.Body.Close()
package main import ( "bytes" "io/ioutil" "log" "net/http" "time" ) var httpClient *http.Client const ( MaxIdleConnections int = 20 RequestTimeout int = 5 ) func init() { httpClient = createHTTPClient() } func createHTTPClient() *http.Client { client := &http.Client{ Transport: &http.Transport{ MaxIdleConnsPerHost: MaxIdleConnections, }, Timeout: time.Duration(RequestTimeout) * time.Second, } return client } func main() { endPoint := "https: req, err := http.NewRequest("POST", endPoint, bytes.NewBuffer([]byte("Post this data"))) if err != nil { log.Fatalf("Error Occured. %+v", err) } req.Header.Set("Content-Type", "application/x-www-form-urlencoded") response, err := httpClient.Do(req) if err != nil && response == nil { log.Fatalf("Error sending request to API endpoint. %+v", err) } defer response.Body.Close() body, err := ioutil.ReadAll(response.Body) if err != nil { log.Fatalf("Couldn } log.Println("Response Body:", string(body)) }
package main import ( "fmt" "io" "io/ioutil" "net/http" "time" ) func main() { req, err := http.NewRequest(http.MethodGet, "https: if err != nil { fmt.Println(err.Error()) return } client := &http.Client{} i := 0 for { resp, err := client.Do(req) if err != nil { fmt.Println(err.Error()) return } _, _ = readBody(resp.Body) fmt.Println("done ", i) time.Sleep(5 * time.Second) } } func readBody(readCloser io.ReadCloser) ([]byte, error) { defer readCloser.Close() body, err := ioutil.ReadAll(readCloser) if err != nil { return nil, err } return body, nil }
package main import "fmt" func main() { fmt.Print("HELLO"[1]) }
package main import "fmt" func main() { fmt.Println(string("Hello"[1])) fmt.Println(string([]rune("Hello, 世界")[1])) fmt.Println(string([]rune("Hello, 世界")[8])) }
package main import "fmt" func main() { fmt.Print("HELLO"[1:2]) }
package main import "fmt" func main() { var word string = "ZbjTS" fmt.Println(word) yo := string([]rune(word)[0]) fmt.Println(yo) x :=0 for x < len(word){ yo := string([]rune(word)[x]) fmt.Println(yo) x+=1 } }
type UsersSession struct { Userid int Timestamp time.Time Created_date time.Time } type Users struct { Name string Email string Country string Created_date time.Time Id int Hash string IP string }
var usersArray = [][]string{} rows, err := db.Query("SELECT u.id, u.hash, u.name, u.email, u.country, u.IP, u.created_date, us.timestamp, us.created_date FROM usersSession AS us LEFT JOIN users AS u ON u.id = us.userid WHERE us.timestamp + interval 30 minute >= now()") U := Users{} US := UsersSession{} for rows.Next() { err = rows.Scan(&U.Id, &U.Hash, &U.Name, &U.Email, &U.Country, &U.IP, &U.Created_date, &US.Timestamp, &US.Created_date) checkErr(err) userid_string := strconv.Itoa(U.Id) user := []string{userid_string, U.Hash, U.Name, U.Email, U.Country, U.IP, U.Created_date, US.Timestamp, US.Created_date} usersArray = append(usersArray, user) log.Print("usersArray: ", usersArray) }
userCreatedDate := U.Created_date.Format("2006-01-02 15:04:05") userSessionCreatedDate := US.Created_date.Format("2006-01-02 15:04:05") userSessionTimestamp := US.Timestamp.Format("2006-01-02 15:04:05")
t := time.Now() fmt.Println(t.String()) fmt.Println(t.Format("2006-01-02 15:04:05"))
package main import ( "fmt" "time" ) func main() { current := time.Now() fmt.Println("origin : ", current.String()) fmt.Println("mm-dd-yyyy : ", current.Format("01-02-2006")) fmt.Println("yyyy-mm-dd : ", current.Format("2006-01-02")) fmt.Println("yyyy.mm.dd : ", current.Format("2006.01.02")) fmt.Println("yyyy-mm-dd HH:mm:ss : ", current.Format("2006-01-02 15:04:05")) fmt.Println("yyyy-mm-dd HH:mm:ss: ", current.Format("2006-01-02 15:04:05.000000")) fmt.Println("yyyy-mm-dd HH:mm:ss: ", current.Format("2006-01-02 15:04:05.000000000")) }
package main import ( "fmt" "time" ) func main() { t := time.Now() fmt.Printf("%s\n", t) formatedTime := t.Format(time.RFC1123) fmt.Println(formatedTime) }
package main import ( "fmt" "time" "github.com/vigneshuvi/GoDateFormat" ) func main() { fmt.Println("Go Date Format(Today - fmt.Println("Go Date Format(Today - fmt.Println("Go Time Format(NOW - fmt.Println("Go Time Format(NOW - } func GetToday(format string) (todayString string){ today := time.Now() todayString = today.Format(format); return }
package main import ( "fmt" "net/http" "time" ) func serve(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, "Hello, world.") time.Sleep(5 * time.Second) } func main() { http.HandleFunc("/", serve) http.ListenAndServe(":1234", nil) }
func (srv *Server) Serve(l net.Listener) error { for { rw, e := l.Accept() if e != nil { ...... c, err := srv.newConn(rw) if err != nil { continue } c.setState(c.rwc, StateNew) go c.serve() } }
package main import "./utils" func main() { utils.DoSomthing() }
export GOPATH="$HOME/gopath" export PATH="$GOPATH/bin:$PATH"
mkdir -p $GOPATH/src/github.com/myname/myproject cd $GOPATH/src/github.com/myname/myproject git init
ln -s $GOPATH/src/github.com/myname/myproject ~/myproject
git remote add origin git@github.com:myname/myproject.git git push origin master
package main import ( "encoding/json" "fmt" ) type Foo struct { Number int `json:"number"` Title string `json:"title"` } func main() { datas := make(map[int]Foo) for i := 0; i < 10; i++ { datas[i] = Foo{Number: 1, Title: "test"} } jsonString, _ := json.Marshal(datas) fmt.Println(datas) fmt.Println(jsonString) }
map[9:{1 test} 2:{1 test} 7:{1 test} 3:{1 test} 4:{1 test} 5:{1 test} 6:{1 test} 8:{1 test} 0:{1 test} 1:{1 test}] []
jsonString, err := json.Marshal(datas) fmt.Println(err)
datas := make(map[string]Foo, N) for i := 0; i < 10; i++ { datas[fmt.Sprint(i)] = Foo{Number: 1, Title: "test"} } j, err := json.Marshal(datas) fmt.Println(string(j), err)
datas2 := make([]Foo, N) for i := 0; i < 10; i++ { datas2[i] = Foo{Number: 1, Title: "test"} } j, err = json.Marshal(datas2) fmt.Println(string(j), err)
c := make(chan string) for i := 0; i < 5; i++ { go func(i int) { <-c c <- fmt.Sprintf("goroutine %d", i) }(i) } c <- "hi" fmt.Println(<-c)
c := make(chan string) for i := 0; i < 5; i++ { go func(i int) { msg := <-c c <- fmt.Sprintf("%s, hi from %d", msg, i) }(i) } c <- "original" fmt.Println(<-c)
original, hi from 0, hi from 1, hi from 2, hi from 3, hi from 4
c := make(chan string) for i := 1; i <= 5; i++ { go func(i int, co chan<- string) { for j := 1; j <= 5; j++ { co <- fmt.Sprintf("hi from %d.%d", i, j) } }(i, c) } for i := 1; i <= 25; i++ { fmt.Println(<-c) }
c := make(chan int) var w sync.WaitGroup w.Add(5) for i := 1; i <= 5; i++ { go func(i int, ci <-chan int) { j := 1 for v := range ci { time.Sleep(time.Millisecond) fmt.Printf("%d.%d got %d\n", i, j, v) j += 1 } w.Done() }(i, c) } for i := 1; i <= 25; i++ { c <- i } close(c) w.Wait()
package main import "fmt" func main() { c := make(chan int) for i := 1; i <= 5; i++ { go func(i int) { for v := range c { fmt.Printf("count %d from goroutine } }(i) } for i := 1; i <= 25; i++ { c<-i } close(c) }
package main import ( "fmt" "runtime" ) func main() { runtime.GOMAXPROCS(runtime.NumCPU() + 1) fmt.Print(runtime.GOMAXPROCS(0)) c := make(chan string) for i := 0; i < 5; i++ { go func(i int) { msg := <-c c <- fmt.Sprintf("%s, hi from %d", msg, i) }(i) } c <- ", original" fmt.Println(<-c) }
package main import "fmt" func main() { c := make(chan string, 5+1) for i := 0; i < 5; i++ { go func(i int) { msg := <-c c <- fmt.Sprintf("%s, hi from %d", msg, i) }(i) } c <- "original" fmt.Println(<-c) }
group := bcast.NewGroup() go bcast.Broadcasting(0) member := group.Join() member.Send("test message") member1 := group.Join() val := member1.Recv()
package main import ( "fmt" "sync" ) type obj struct { msg string receiver int } func main() { ch := make(chan *obj) var wg sync.WaitGroup receiver := 25 sender := func() { o := &obj { msg: "hello everyone!", receiver: receiver, } ch <- o } recv := func(idx int) { defer wg.Done() o := <-ch fmt.Printf("%d received at %d\n", idx, o.receiver) o.receiver-- if o.receiver > 0 { ch <- o } else { fmt.Printf("last receiver: %d\n", idx) } } go sender() for i:=0; i<reciever; i++ { wg.Add(1) go recv(i) } wg.Wait() }
5 received at 25 24 received at 24 6 received at 23 7 received at 22 8 received at 21 9 received at 20 10 received at 19 11 received at 18 12 received at 17 13 received at 16 14 received at 15 15 received at 14 16 received at 13 17 received at 12 18 received at 11 19 received at 10 20 received at 9 21 received at 8 22 received at 7 23 received at 6 2 received at 5 0 received at 4 1 received at 3 3 received at 2 4 received at 1 last receiver 4
package main import "log" type Planet struct { Name string `json:"name"` Aphelion float64 `json:"aphelion"` Perihelion float64 `json:"perihelion"` Axis int64 `json:"Axis"` Radius float64 `json:"radius"` } func main() { var mars = new(Planet) mars.Name = "Mars" mars.Aphelion = 249.2 mars.Perihelion = 206.7 mars.Axis = 227939100 mars.Radius = 3389.5 var earth = new(Planet) earth.Name = "Earth" earth.Aphelion = 151.930 earth.Perihelion = 147.095 earth.Axis = 149598261 earth.Radius = 6371.0 var venus = new(Planet) venus.Name = "Venus" venus.Aphelion = 108.939 venus.Perihelion = 107.477 venus.Axis = 108208000 venus.Radius = 6051.8 planets := [...]Planet{*mars, *venus, *earth} log.Println(planets) }
slice.Sort(planets[:], func(i, j int) bool { return planets[i].Axis < planets[j].Axis })
sort.Slice(planets, func(i, j int) bool { return planets[i].Axis < planets[j].Axis })
sort.Slice(planets[:], func(i, j int) bool { return planets[i].Axis < planets[j].Axis })
package main import "log" import "sort" type AxisSorter []Planet func (a AxisSorter) Len() int { return len(a) } func (a AxisSorter) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a AxisSorter) Less(i, j int) bool { return a[i].Axis < a[j].Axis } type NameSorter []Planet func (a NameSorter) Len() int { return len(a) } func (a NameSorter) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a NameSorter) Less(i, j int) bool { return a[i].Name < a[j].Name } type Planet struct { Name string `json:"name"` Aphelion float64 `json:"aphelion"` Perihelion float64 `json:"perihelion"` Axis int64 `json:"Axis"` Radius float64 `json:"radius"` } func main() { var mars Planet mars.Name = "Mars" mars.Aphelion = 249.2 mars.Perihelion = 206.7 mars.Axis = 227939100 mars.Radius = 3389.5 var earth Planet earth.Name = "Earth" earth.Aphelion = 151.930 earth.Perihelion = 147.095 earth.Axis = 149598261 earth.Radius = 6371.0 var venus Planet venus.Name = "Venus" venus.Aphelion = 108.939 venus.Perihelion = 107.477 venus.Axis = 108208000 venus.Radius = 6051.8 planets := []Planet{mars, venus, earth} log.Println("unsorted:", planets) sort.Sort(AxisSorter(planets)) log.Println("by axis:", planets) sort.Sort(NameSorter(planets)) log.Println("by name:", planets) }
package main import ( "log" "sort" ) type Planet struct { Name string `json:"name"` Aphelion float64 `json:"aphelion"` Perihelion float64 `json:"perihelion"` Axis int64 `json:"Axis"` Radius float64 `json:"radius"` } type By func(p1, p2 *Planet) bool func (by By) Sort(planets []Planet) { ps := &planetSorter{ planets: planets, by: by, } sort.Sort(ps) } type planetSorter struct { planets []Planet by func(p1, p2 *Planet) bool } func (s *planetSorter) Len() int { return len(s.planets) } func (s *planetSorter) Swap(i, j int) { s.planets[i], s.planets[j] = s.planets[j], s.planets[i] } func (s *planetSorter) Less(i, j int) bool { return s.by(&s.planets[i], &s.planets[j]) }
func main() { planets := []Planet{*mars, *venus, *earth} By(func(p1, p2 *Planet) bool { return p1.Name < p2.Name }).Sort(planets) log.Println(planets) By(func(p1, p2 *Planet) bool { return p1.Axis < p2.Axis }).Sort(planets) log.Println(planets) }
package main import ( "log" "reflect" "sort" ) func test(planets []Planet) { log.Println("Sort Name") By(Prop("Name", true)).Sort(planets) log.Println(planets) log.Println("Sort Aphelion") By(Prop("Aphelion", true)).Sort(planets) log.Println(planets) log.Println("Sort Perihelion") By(Prop("Perihelion", true)).Sort(planets) log.Println(planets) log.Println("Sort Axis") By(Prop("Axis", true)).Sort(planets) log.Println(planets) log.Println("Sort Radius") By(Prop("Radius", true)).Sort(planets) log.Println(planets) } func Prop(field string, asc bool) func(p1, p2 *Planet) bool { return func(p1, p2 *Planet) bool { v1 := reflect.Indirect(reflect.ValueOf(p1)).FieldByName(field) v2 := reflect.Indirect(reflect.ValueOf(p2)).FieldByName(field) ret := false switch v1.Kind() { case reflect.Int64: ret = int64(v1.Int()) < int64(v2.Int()) case reflect.Float64: ret = float64(v1.Float()) < float64(v2.Float()) case reflect.String: ret = string(v1.String()) < string(v2.String()) } if asc { return ret } return !ret } } type Planet struct { Name string `json:"name"` Aphelion float64 `json:"aphelion"` Perihelion float64 `json:"perihelion"` Axis int64 `json:"Axis"` Radius float64 `json:"radius"` } type By func(p1, p2 *Planet) bool func (by By) Sort(planets []Planet) { ps := &planetSorter{ planets: planets, by: by, } sort.Sort(ps) } type planetSorter struct { planets []Planet by func(p1, p2 *Planet) bool } func (s *planetSorter) Len() int { return len(s.planets) } func (s *planetSorter) Swap(i, j int) { s.planets[i], s.planets[j] = s.planets[j], s.planets[i] } func (s *planetSorter) Less(i, j int) bool { return s.by(&s.planets[i], &s.planets[j]) } func main() { test(dataSet()) } func dataSet() []Planet { var mars = new(Planet) mars.Name = "Mars" mars.Aphelion = 249.2 mars.Perihelion = 206.7 mars.Axis = 227939100 mars.Radius = 3389.5 var earth = new(Planet) earth.Name = "Earth" earth.Aphelion = 151.930 earth.Perihelion = 147.095 earth.Axis = 149598261 earth.Radius = 6371.0 var venus = new(Planet) venus.Name = "Venus" venus.Aphelion = 108.939 venus.Perihelion = 107.477 venus.Axis = 108208000 venus.Radius = 6051.8 return []Planet{*mars, *venus, *earth} }
func FillStruct(data map[string]interface{}, result interface{}) { ... } type MyStruct struct { Name string Age int64 } myData := make(map[string]interface{}) myData["Name"] = "Tony" myData["Age"] = 23 result := &MyStruct{} FillStruct(myData, result)
import "github.com/mitchellh/mapstructure" mapstructure.Decode(myData, &result)
func SetField(obj interface{}, name string, value interface{}) error { structValue := reflect.ValueOf(obj).Elem() structFieldValue := structValue.FieldByName(name) if !structFieldValue.IsValid() { return fmt.Errorf("No such field: %s in obj", name) } if !structFieldValue.CanSet() { return fmt.Errorf("Cannot set %s field value", name) } structFieldType := structFieldValue.Type() val := reflect.ValueOf(value) if structFieldType != val.Type() { return errors.New("Provided value type didn } structFieldValue.Set(val) return nil } type MyStruct struct { Name string Age int64 } func (s *MyStruct) FillStruct(m map[string]interface{}) error { for k, v := range m { err := SetField(s, k, v) if err != nil { return err } } return nil } func main() { myData := make(map[string]interface{}) myData["Name"] = "Tony" myData["Age"] = int64(23) result := &MyStruct{} err := result.FillStruct(myData) if err != nil { fmt.Println(err) } fmt.Println(result) }
import "github.com/mitchellh/mapstructure" mapstructure.Decode(myData, &result)
func FillStruct(data map[string]interface{}, result interface{}) { t := reflect.ValueOf(result).Elem() for k, v := range data { val := t.FieldByName(k) val.Set(reflect.ValueOf(v)) } }
package main import ( "fmt" "reflect" ) func SetField(obj interface{}, name string, value interface{}) error { structValue := reflect.ValueOf(obj).Elem() fieldVal := structValue.FieldByName(name) if !fieldVal.IsValid() { return fmt.Errorf("No such field: %s in obj", name) } if !fieldVal.CanSet() { return fmt.Errorf("Cannot set %s field value", name) } val := reflect.ValueOf(value) if fieldVal.Type() != val.Type() { if m,ok := value.(map[string]interface{}); ok { if fieldVal.Kind() == reflect.Struct { return FillStruct(m, fieldVal.Addr().Interface()) } if fieldVal.Kind()==reflect.Ptr && fieldVal.Type().Elem().Kind() == reflect.Struct { if fieldVal.IsNil() { fieldVal.Set(reflect.New(fieldVal.Type().Elem())) } return FillStruct(m, fieldVal.Interface()) } } return fmt.Errorf("Provided value type didn } fieldVal.Set(val) return nil } func FillStruct(m map[string]interface{}, s interface{}) error { for k, v := range m { err := SetField(s, k, v) if err != nil { return err } } return nil } type OtherStruct struct { Name string Age int64 } type MyStruct struct { Name string Age int64 OtherStruct *OtherStruct } func main() { myData := make(map[string]interface{}) myData["Name"] = "Tony" myData["Age"] = int64(23) OtherStruct := make(map[string]interface{}) myData["OtherStruct"] = OtherStruct OtherStruct["Name"] = "roxma" OtherStruct["Age"] = int64(23) result := &MyStruct{} err := FillStruct(myData,result) fmt.Println(err) fmt.Printf("%v %v\n",result,result.OtherStruct) }
package main import ( "fmt" "net/http" ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello world!") } func main() { http.HandleFunc("/", handler) http.ListenAndServe(":3000", nil) }
package main import ( "net/http" ) func main() { http.Handle("/", http.FileServer(http.Dir("./static"))) http.ListenAndServe(":3000", nil) }
package main import ( "net/http" ) func main() { http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./public")))) http.ListenAndServe(":3000", nil) }
func (server *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) { err := server.renderFile(w, r.URL.Path) if err != nil { w.Header().Set("Content-Type", "text/html; charset=utf-8") w.WriteHeader(http.StatusNotFound) server.fn404(w, r) } }
file, err = ioutil.ReadFile(server.MediaPath + filename) if ext != "" { w.Header().Set("Content-Type", mime.TypeByExtension(ext)) }
func Add(num1... int) int { return args } func main() { fmt.Println("Hello, playground") fmt.Println(Add(1, 3, 4, 5,)) }
func Greeting(prefix string, who ...string) Greeting("hello:", "Joe", "Anna", "Eileen")
func Add(nums... int) int { total := 0 for _, v := range nums { total += v } return total } func main() { fmt.Println("Hello, playground") fmt.Println(Add(1, 3, 4, 5,)) }
package main import ( "fmt" ) func sum(nums ...int) { fmt.Println(nums) for _, num := range nums { fmt.Print(num) } } func main() { sum(1, 2, 3, 4, 5, 6) }
package main import "net" import "fmt" import "bufio" func main() { conn, _ := net.Dial("tcp", "irc.freenode.net:6667") reader := bufio.NewReader(conn) go func() { str, err := reader.ReadString( if err != nil { fmt.Println(err) } fmt.Println(str) }() }
:zelazny.freenode.net NOTICE * :*** Looking up your hostname...
package main import "net" import "fmt" import "bufio" func main() { conn, _ := net.Dial("tcp", "irc.freenode.net:6667") reader := bufio.NewReader(conn) ch := make(chan byte, 1) go func() { str, err := reader.ReadString( if err != nil { fmt.Println(err) } fmt.Println(str) ch <- 1 }() <-ch }
package main import "io" import "net/http" import "time" func indexHandler(w http.ResponseWriter, req *http.Request) { expire := time.Now().AddDate(0, 0, 1) cookie := http.Cookie{"test", "tcookie", "/", "www.domain.com", expire, expire.Format(time.UnixDate), 86400, true, true, "test=tcookie", []string{"test=tcookie"}} req.AddCookie(&cookie) io.WriteString(w, "Hello world!") } func main() { http.HandleFunc("/", indexHandler) http.ListenAndServe(":80", nil) }
func ShowAllTasksFunc(w http.ResponseWriter, r *http.Request){ if r.Method == "GET" { context := db.GetTasks("pending") if message != "" { context.Message = message } context.CSRFToken = "abcd" message = "" expiration := time.Now().Add(365 * 24 * time.Hour) cookie := http.Cookie{Name: "csrftoken",Value:"abcd",Expires:expiration} http.SetCookie(w, &cookie) homeTemplate.Execute(w, context) } else { message = "Method not allowed" http.Redirect(w, r, "/", http.StatusFound) } }
Host: 127.0.0.1:8081 User-Agent: ... Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate DNT: 1 Referer: http: Cookie: csrftoken=abcd Connection: keep-alive
Content-Type: text/html; charset=utf-8 Date: Tue, 12 Jan 2016 16:43:53 GMT Set-Cookie: csrftoken=abcd; Expires=Wed, 11 Jan 2017 16:43:53 GMT Transfer-Encoding: chunked <html>...</html>
cookie, _ := r.Cookie("csrftoken") if formToken == cookie.Value {
cookie1 := &http.Cookie{Name: "sample", Value: "sample", HttpOnly: false} http.SetCookie(w, cookie1)
func handleFoo(w http.ResponseWriter, r *http.Request) { expires := time.Now().AddDate(1, 0, 0) ck := http.Cookie{ Name: "JSESSION_ID", Domain: "foo.com", Path: "/", Expires: expires, } ck.Value = "value of this awesome cookie" http.SetCookie(w, &ck) }
expire := time.Now().Add(20 * time.Minute) cookie := http.Cookie{Name: "username", Value: "nonsecureuser", Path: "/", Expires: expire, MaxAge: 86400} http.SetCookie(w, &cookie) cookie = http.Cookie{Name: "secureusername", Value: "secureuser", Path: "/", Expires: expire, MaxAge: 86400, HttpOnly: true, Secure: true} http.SetCookie(w, &cookie)
expire := time.Now().Add(10 * time.Minute) cookie := http.Cookie{Name: "User", Value: "John", Path: "/", Expires: expire, MaxAge: 90000} http.SetCookie(w, &cookie)
http.HandleFunc("/smth", smthPage) http.HandleFunc("/", homePage)
func main() { r := mux.NewRouter() r.NotFoundHandler = http.HandlerFunc(notFound) }
package main import ( "fmt" "net/http" ) func main() { http.HandleFunc("/", homeHandler) http.HandleFunc("/smth/", smthHandler) http.ListenAndServe(":12345", nil) } func homeHandler(w http.ResponseWriter, r *http.Request) { if r.URL.Path != "/" { errorHandler(w, r, http.StatusNotFound) return } fmt.Fprint(w, "welcome home") } func smthHandler(w http.ResponseWriter, r *http.Request) { if r.URL.Path != "/smth/" { errorHandler(w, r, http.StatusNotFound) return } fmt.Fprint(w, "welcome smth") } func errorHandler(w http.ResponseWriter, r *http.Request, status int) { w.WriteHeader(status) if status == http.StatusNotFound { fmt.Fprint(w, "custom 404") } }
type hijack404 struct { http.ResponseWriter R *http.Request Handle404 func (w http.ResponseWriter, r *http.Request) bool } func (h *hijack404) WriteHeader(code int) { if 404 == code && h.Handle404(h.ResponseWriter, h.R) { panic(h) } h.ResponseWriter.WriteHeader(code) } func Handle404(handler http.Handler, handle404 func (w http.ResponseWriter, r *http.Request) bool) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){ hijack := &hijack404{ ResponseWriter:w, R: r, Handle404: handle404 } defer func() { if p:=recover(); p!=nil { if p==hijack { return } panic(p) } }() handler.ServeHTTP(hijack, r) }) } func fire404(res http.ResponseWriter, req *http.Request) bool{ fmt.Fprintf(res, "File not found. Please check to see if your URL is correct."); return true; } func main(){ handler_statics := http.StripPrefix("/static/", http.FileServer(http.Dir("/Path_To_My_Static_Files"))); var v_blessed_handler_statics http.Handler = Handle404(handler_statics, fire404); http.Handle("/static/", v_blessed_handler_statics); if err := http.ListenAndServe(":8080", nil); err != nil{ log.Fatal("ListenAndServe: ", err); } }
func main(){ handler_statics := http.StripPrefix("/static/", http.FileServer(http.Dir("/Path_To_My_Static_Files"))); var v_blessed_handler_statics http.Handler = Handle404(handler_statics, fire404); r := mux.NewRouter(); r.PathPrefix("/static/").Handler(v_blessed_handler_statics); http.Handle("/", r); log.Fatal(http.ListenAndServe(":8080", nil)); }
package main import ( "net/http" ) func init() { http.HandleFunc("/", handler) } type HeaderWriter struct { original http.ResponseWriter done bool } func (hw *HeaderWriter) Header() http.Header { return hw.original.Header() } func (hw *HeaderWriter) Write(b []byte) (int, error) { if hw.done { return len(b), nil } return hw.original.Write(b) } func (hw *HeaderWriter) WriteHeader(s int) { if hw.done { return } if s < 400 { hw.original.Header().Set("Cache-Control", "max-age=60, s-maxage=2592000, public") } hw.original.WriteHeader(s) if s == 404 { hw.done = true hw.original.Write([]byte("This be custom 404...")) } } func handler(w http.ResponseWriter, r *http.Request) { urls := map[string]string{ "/example-post-1.html": "https: "/example-post-2.html": "https: "/example-post-3.html": "https: } w.Header().Set("Strict-Transport-Security", "max-age=15768000") if value, ok := urls[r.URL.Path]; ok { http.Redirect(&HeaderWriter{original: w}, r, value, 301) } else { http.ServeFile(&HeaderWriter{original: w}, r, "static/"+r.URL.Path) } }
package main import ( "fmt" "os" "log" ) func main() { file, err := os.Open("file.txt") if err != nil { log.Fatal(err) } fmt.Print(file) }
package main import ( "fmt" "io/ioutil" ) func main() { b, err := ioutil.ReadFile("file.txt") if err != nil { fmt.Print(err) } fmt.Println(b) str := string(b) fmt.Println(str) }
package main import ( "fmt" "os" "log" ) func main() { file, err := os.Open("file.txt") if err != nil { log.Fatal(err) } defer file.Close() b, err := ioutil.ReadAll(file) fmt.Print(b) }
func main() { file, err := os.Open("file.txt") if err != nil { log.Fatal(err) } defer file.Close() buf := make([]byte, 32*1024) for { n, err := file.Read(buf) if n > 0 { fmt.Print(buf[:n]) } if err == io.EOF { break } if err != nil { log.Printf("read %d bytes: %v", n, err) break } } }
package main import ( "fmt" "os" "log" "bufio" ) func main() { file, err := os.Open("file.txt") if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) fmt.Println(scanner.Bytes()) } }
type Session struct { playerId string beehive string timestamp time.Time }
if (Session{}) == session { fmt.Println("is zero value") }
if session.playerId == "" { fmt.Println("is zero value") }
type Session struct { ready bool playerId string beehive string timestamp time.Time }
func (s Session) isEmpty() bool { return s.playerId == "" }
package main import "fmt" import "time" import "reflect" type Session struct { playerId string beehive string timestamp time.Time } func (s Session) IsEmpty() bool { return reflect.DeepEqual(s,Session{}) } func main() { x := Session{} if x.IsEmpty() { fmt.Print("is empty") } }
session := &Session{} if (Session{}) == *session { fmt.Println("session is empty") }
session := Session{} switch { case Session{} == session: fmt.Println("zero") default: fmt.Println("not zero") }
package main import "fmt" import "time" type Session struct { playerId string beehive string timestamp time.Time } func (s Session) Equal(o Session) bool { if(s.playerId != o.playerId) { return false } if(s.beehive != o.beehive) { return false } if(s.timestamp != o.timestamp) { return false } return true } func (s Session) IsEmpty() bool { return s.Equal(Session{}) } func main() { x := Session{} if x.IsEmpty() { fmt.Print("is empty") } }
hc := http.Client{} req, err := http.NewRequest("POST", APIURL, nil) form := url.Values{} form.Add("ln", c.ln) form.Add("ip", c.ip) form.Add("ua", c.ua) req.PostForm = form req.Header.Add("Content-Type", "application/x-www-form-urlencoded") glog.Info("form was %v", form) resp, err := hc.Do(req)
req, err := http.NewRequest("POST", url, strings.NewReader(form.Encode()))
response, err := http.PostForm(APIURL, url.Values{ "ln": {c.ln}, "ip": {c.ip}, "ua": {c.ua}}) if err != nil { } defer response.Body.Close() body, err := ioutil.ReadAll(response.Body) if err != nil { } fmt.Printf("%s\n", string(body))
func IfThenElse(condition bool, a interface{}, b interface{}) interface{} { if condition { return a } return b }
func TestIfThenElse(t *testing.T) { assert.Equal(t, IfThenElse(1 == 1, "Yes", false), "Yes") assert.Equal(t, IfThenElse(1 != 1, nil, 1), 1) assert.Equal(t, IfThenElse(1 < 2, nil, "No"), nil) }
IfThen(1 == 1, "Yes") IfThen(1 != 1, "Woo") IfThen(1 < 2, "Less") IfThenElse(1 == 1, "Yes", false) IfThenElse(1 != 1, nil, 1) IfThenElse(1 < 2, nil, "No") DefaultIfNil(nil, nil) DefaultIfNil(nil, "") DefaultIfNil("A", "B") DefaultIfNil(true, "B") DefaultIfNil(1, false) FirstNonNil(nil, nil) FirstNonNil(nil, "") FirstNonNil("A", "B") FirstNonNil(true, "B") FirstNonNil(1, false) FirstNonNil(nil, nil, nil, 10) FirstNonNil(nil, nil, nil, nil, nil) FirstNonNil()
type MyStruct struct { field1 string field2 string } var myObj *MyStruct myObj = nil myField := map[bool]string{true: myObj.field1, false: "empty!"}[myObj != nil}
a, b = 4, 8 c := func() int { if a >b { return a } return b } ()
**if <statement>; <evaluation> { [statements ...] } else { [statements ...] }*
if path,err := os.Executable(); err != nil { log.Println(err) } else { log.Println(path) }
func doif(b bool, f1, f2 func()) { switch{ case b: f1() case !b: f2() } } func dothis() { fmt.Println("Condition is true") } func dothat() { fmt.Println("Condition is false") } func main () { condition := true doif(condition, func() { dothis() }, func() { dothat() }) }
func doif(b bool, f1, f2 func()) { switch{ case b: f1() case !b: f2() } } func dothis() { fmt.Println("Condition is true") } func dothat() { fmt.Println("Condition is false") } func main () { condition := true doif(condition, dothis, dothat) }
http.HandleFunc("/groups/*/people", peopleInGroupHandler)
type route struct { pattern *regexp.Regexp handler http.Handler } type RegexpHandler struct { routes []*route } func (h *RegexpHandler) Handler(pattern *regexp.Regexp, handler http.Handler) { h.routes = append(h.routes, &route{pattern, handler}) } func (h *RegexpHandler) HandleFunc(pattern *regexp.Regexp, handler func(http.ResponseWriter, *http.Request)) { h.routes = append(h.routes, &route{pattern, http.HandlerFunc(handler)}) } func (h *RegexpHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { for _, route := range h.routes { if route.pattern.MatchString(r.URL.Path) { route.handler.ServeHTTP(w, r) return } } http.NotFound(w, r) }
package main import ( "github.com/gorilla/mux" "log" "net/http" ) func main() { rtr := mux.NewRouter() rtr.HandleFunc("/user/{name:[a-z]+}/profile", profile).Methods("GET") http.Handle("/", rtr) log.Println("Listening...") http.ListenAndServe(":3000", nil) } func profile(w http.ResponseWriter, r *http.Request) { params := mux.Vars(r) name := params["name"] w.Write([]byte("Hello " + name)) }
package main import ( "fmt" "github.com/julienschmidt/httprouter" "net/http" "log" ) func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) { fmt.Fprint(w, "Welcome!\n") } func Hello(w http.ResponseWriter, r *http.Request, ps httprouter.Params) { fmt.Fprintf(w, "hello, %s!\n", ps.ByName("name")) } func main() { router := httprouter.New() router.GET("/", Index) router.GET("/hello/:name", Hello) log.Fatal(http.ListenAndServe(":8080", router)) }
uuid := `[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}` router.AddRegex(":uuid") router.HandleFunc("/test/:uuid/:uuid", handleUUID, "GET,HEAD")
http: \______/\___/\________/ | | | static | dynamic
router.AddRegex(":ip", `^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$`) router.HandleFunc("/command/ping/:ip", ipHandler, "GET")
router.HandleFunc("/command/ping/*", anyHandler, "GET, HEAD")
package main type Entity interface { a() string } type PhysEntity interface { Entity b() string } type BaseEntity struct { } func (e *BaseEntity) a() string { return "Hello " } type BasePhysEntity struct { BaseEntity } func (e *BasePhysEntity) b() string { return " World!" } func main() { physEnt := PhysEntity(new(BasePhysEntity)) entity := Entity(physEnt) print(entity.a()) original := PhysEntity(entity) println(original.b()) }
original, ok := entity.(PhysEntity) if ok { println(original.b()) }
func f(t *testing.T) { defer func() { if r := recover(); r != nil { fmt.Println("Recovered in f", r) } }() OtherFunctionThatPanics() t.Errorf("The code did not panic") }
func TestPanic(t *testing.T) { defer func() { if r := recover(); r == nil { t.Errorf("The code did not panic") } }() OtherFunctionThatPanics() }
func TestPanic(t *testing.T) { assertPanic(t, OtherFunctionThatPanics) } func assertPanic(t *testing.T, f func()) { defer func() { if r := recover(); r == nil { t.Errorf("The code did not panic") } }() f() }
func TestOtherFunctionThatPanics(t *testing.T) { assert.Panics(t, OtherFunctionThatPanics, "The code did not panic") }
func TestOtherFunctionThatPanics(t *testing.T) { assert.Panics(t, func() { OtherFunctionThatPanics(arg) }, "The code did not panic") }
package main import ( "reflect" "testing" ) func TestYourFunc(t *testing.T) { type args struct { arg1 int arg2 int arg3 int } tests := []struct { name string args args want []int wantErr bool wantPanic bool }{ } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { defer func() { r := recover() if (r != nil) != tt.wantPanic { t.Errorf("SequenceInt() recover = %v, wantPanic = %v", r, tt.wantPanic) } }() got, err := YourFunc(tt.args.arg1, tt.args.arg2, tt.args.arg3) if (err != nil) != tt.wantErr { t.Errorf("YourFunc() error = %v, wantErr %v", err, tt.wantErr) return } if !reflect.DeepEqual(got, tt.want) { t.Errorf("YourFunc() = %v, want %v", got, tt.want) } }) } }
func TestIsAheadComparedToPanicsWithDifferingStreams(t *testing.T) { defer func() { err := recover().(error) if err.Error() != "Cursor: cannot compare cursors from different streams" { t.Fatalf("Wrong panic message: %s", err.Error()) } }() c1 := CursorFromserializedMust("/foo:0:0") c2 := CursorFromserializedMust("/bar:0:0") c1.IsAheadComparedTo(c2) }
package main import "fmt" func explode() { panic("WRONG") } func explode1() { panic("WRONG1") } func main() { defer func() { if r := recover(); r != nil { var ok bool err, ok := r.(error) if !ok { err = fmt.Errorf("pkg: %v", r) fmt.Println(err) } } }() explode() fmt.Println("Everything fine") }
func handle(w http.ResponseWriter, r *http.Request) {}
type jsonData struct { Field1 string Field2 string } type JsonData struct { jsonData } func (d *JsonData) UnmarshalJSON(b []byte) error { return json.Unmarshal(b, &d.jsonData) } func (d *JsonData) Field1() string { return d.jsonData.Field1 }
type Whatever struct { SomeField int `json:"some_field"` }
type Whatever struct { someField int } func (w Whatever) MarshalJSON() ([]byte, error) { return json.Marshal(struct{ SomeField int `json:"some_field"` }{ SomeField: w.someField, }) }
func (w Whatever) MarshalJSON() ([]byte, error) { return json.Marshal(map[string]interface{}{ "some_field": w.SomeField, }) }
package main import ( "log" "io" "time" "net/http" ) func startHttpServer() *http.Server { srv := &http.Server{Addr: ":8080"} http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { io.WriteString(w, "hello world\n") }) go func() { if err := srv.ListenAndServe(); err != http.ErrServerClosed { log.Fatalf("ListenAndServe(): %s", err) } }() return srv } func main() { log.Printf("main: starting HTTP server") srv := startHttpServer() log.Printf("main: serving for 10 seconds") time.Sleep(10 * time.Second) log.Printf("main: stopping HTTP server") if err := srv.Shutdown(nil); err != nil { panic(err) } log.Printf("main: done. exiting") }
server := &http.Server{Addr: ":8080", Handler: handler} go func() { if err := server.ListenAndServe(); err != nil { } } stop := make(chan os.Signal, 1) signal.Notify(stop, os.Interrupt) <-stop ctx, _ := context.WithTimeout(context.Background(), 5*time.Second) if err := server.Shutdown(ctx); err != nil { }
func ListenAndServeWithClose(addr string, handler http.Handler) (io.Closer,error) { var ( listener net.Listener srvCloser io.Closer err error ) srv := &http.Server{Addr: addr, Handler: handler} if addr == "" { addr = ":http" } listener, err = net.Listen("tcp", addr) if err != nil { return nil, err } go func() { err := srv.Serve(tcpKeepAliveListener{listener.(*net.TCPListener)}) if err != nil { log.Println("HTTP Server Error - ", err) } }() srvCloser = listener return srvCloser, nil }
go func() { httpError := srv.ListenAndServe(address, handler) if httpError != nil { log.Println("While serving HTTP: ", httpError) } }() srv.Shutdown(context)
l, err := net.Listen("tcp", fmt.Sprintf(":%d", service.Port())) if err != nil { log.Fatal(err) }
func ListenAndServe(addr string, handler Handler) error { server := &Server{Addr: addr, Handler: handler} return server.ListenAndServe() }
type ServeReqs func(ctx context.Context, cfg Config, deps ReqHandlersDependencies) error var ServeReqsImpl = func(ctx context.Context, cfg Config, deps ReqHandlersDependencies) error { http.Handle(pingRoute, decorateHttpRes(pingHandlerImpl(deps.pingRouteResponseMessage), addJsonHeader())) server := &http.Server{Addr: fmt.Sprintf(":%d", cfg.port), Handler: nil} go func() { <-ctx.Done() fmt.Println("Shutting down the HTTP server...") server.Shutdown(ctx) }() err := server.ListenAndServeTLS( cfg.certificatePemFilePath, cfg.certificatePemPrivKeyFilePath, ) if err == http.ErrServerClosed { return nil } return err }
ctx, closeServer := context.WithCancel(context.Background()) err := ServeReqs(ctx, etc) closeServer()
package gracefull_shutdown_server import ( "net/http" "log" "os" "os/signal" "time" "context" "fmt" ) func startHttpServer() *http.Server{ mux:=http.NewServeMux() mux.HandleFunc("/",defaultRoute) srv:=&http.Server{ Addr:":8080", Handler:mux, } go func() { if err:=srv.ListenAndServe();err != http.ErrServerClosed{ log.Fatalf("ListenAndServe(): %s",err) } }() return srv } func defaultRoute(w http.ResponseWriter, r *http.Request){ time.Sleep(time.Second*30) w.Write([]byte("it } func MainStartHttpServer() { srv:=startHttpServer() stop:= make(chan os.Signal) signal.Notify(stop,os.Interrupt) select { case <-stop: fmt.Println("server going to shut down") ctx,cancel:=context.WithTimeout(context.Background(),time.Second*5) defer cancel() err:=srv.Shutdown(ctx) if err!=nil{ fmt.Println(err) } } }
http.HandleFunc("/shutdown", func(w http.ResponseWriter, r *http.Request) { if <credentials check passes> { fmt.Fprint(w, "Goodbye!\n") os.Exit(0) } })
package main import ("fmt" ; "container/list") func main() { var x list.List x.PushBack(1) x.PushBack(2) x.PushBack(3) for e := x.Front(); e != nil; e=e.Next() { fmt.Println(e.Value.(int)) } }
There are ways to mitigate the deletion problem -- e.g. the swap trick you mentioned or just marking the elements as logically deleted. But it
package main import ( "fmt" "github.com/julienschmidt/httprouter" "net/http" "log" "encoding/json" ) type Payload struct { Stuff Data } type Data struct { Fruit Fruits Veggies Vegetables } type Fruits map[string]int type Vegetables map[string]int func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) { response, err := getJsonResponse(); if err != nil { panic(err) } fmt.Fprintf(w, string(response)) } func main() { router := httprouter.New() router.GET("/", Index) log.Fatal(http.ListenAndServe(":8080", router)) } func getJsonResponse()([]byte, error) { fruits := make(map[string]int) fruits["Apples"] = 25 fruits["Oranges"] = 10 vegetables := make(map[string]int) vegetables["Carrats"] = 10 vegetables["Beets"] = 0 d := Data{fruits, vegetables} p := Payload{d} return json.MarshalIndent(p, "", " ") }
func SomeHandler(w http.ResponseWriter, r *http.Request) { data := SomeStruct{} w.Header().Set("Content-Type", "application/json") w.WriteHeader(http.StatusCreated) json.NewEncoder(w).Encode(data) }
jData, err := json.Marshal(Data) if err != nil { } w.Header().Set("Content-Type", "application/json") w.Write(jData)
user := &models.User{} if c.Request().Header.Get("Content-type") == "application/json" { return c.Render(200, r.JSON(user)) } else { c.Set("user", user) return c.Render(200, r.HTML("users/show.html")) }
type Result struct { Data MyStruct `json:"data,omitempty"` Status string `json:"status,omitempty"` Reason string `json:"reason,omitempty"` }
type Result struct { Data *MyStruct `json:"data,omitempty"` Status string `json:"status,omitempty"` Reason string `json:"reason,omitempty"` }
type Result struct { Data MyStruct Status string Reason string } func (r Result) MarshalJSON() ([]byte, error) { return json.Marshal(struct { Data *MyStruct `json:"data,omitempty"` Status string `json:"status,omitempty"` Reason string `json:"reason,omitempty"` }{ Data: &r.Data, Status: r.Status, Reason: r.Reason, }) } func (r *Result) UnmarshalJSON(b []byte) error { decoded := new(struct { Data *MyStruct `json:"data,omitempty"` Status string `json:"status,omitempty"` Reason string `json:"reason,omitempty"` }) err := json.Unmarshal(b, decoded) if err == nil { r.Data = decoded.Data r.Status = decoded.Status r.Reason = decoded.Reason } return err }
func (_ MyStruct) MarshalJSON() ([]byte, error) { if empty { return nil, nil } }
type point struct { x, y int } func newPoint() *point { return &point{10, 20} }
import "sync" type SyncMap struct { lock *sync.RWMutex hm map[string]string } func (m *SyncMap) Put (k, v string) { m.lock.Lock() defer m.lock.Unlock() m.hm[k] = v, true }
func (m *SyncMap) Init() { m.hm = make(map[string]string) m.lock = new(sync.RWMutex) }
func NewSyncMap() *SyncMap { return &SyncMap{hm: make(map[string]string)} }
func NewSyncMap() *SyncMap { sm := SyncMap{ hm: make(map[string]string), foo: "Bar", } runtime.SetFinalizer(sm, (*SyncMap).stop) go sm.backend() return &sm }
package main import "sync" type SyncMap struct { lock *sync.RWMutex hm map[string]string } func NewSyncMap() *SyncMap { return &SyncMap{lock: new(sync.RWMutex), hm: make(map[string]string)} } func (m *SyncMap) Put (k, v string) { m.lock.Lock() defer m.lock.Unlock() m.hm[k] = v } func main() { sm := NewSyncMap() sm.Put("Test", "Test") }
func main() { inc := func(x int) int { return x+1; } }
func main() { func inc(x int) int { return x+1; } }
func main() { inc := func(x int) int { return x+1; } }
package main import "fmt" func main() { nested := func() { fmt.Println("I am nested") deeplyNested := func() { fmt.Println("I am deeply nested") } deeplyNested() } nested() }
func main() { func inc(x int) int { return x+1; }() }
func outerFunction(iterations int, s1, s2 string) int { someState := 0 innerFunction := func(param string) int { totalLength := 0 for i := 0; i < iterations; i++) { totalLength += len(param) } return totalLength } someState = innerFunction(s1) someState += innerFunction(s2) return someState } myVar := outerFunction(100, "blah", "meh")
func outerFunction(...) { innerFunction := func(...) { ... } go innerFunction(...) }
var a map[string]string var b map[string]string func main() { a = make(map[string]string) b=a a["hello"]="world" a = nil fmt.Println(b["hello"]) }
a := map[string]string{"hello": "world"} a = make(map[string]string)
a := map[string]string{"hello": "world"} b := a a = make(map[string]string)
for i:=0; i<2; i++ { animalNames := make(map[string]string) switch i { case 0: animalNames["cat"] = "Patches" case 1: animalNames["dog"] = "Spot"; } fmt.Println("For map instance", i) for key, value := range animalNames { fmt.Println(key, value) } fmt.Println("-----------\n") }
$ go run maptests.go For map instance 0 cat Patches ----------- For map instance 1 dog Spot -----------
func Atoi(s string) (i int, err error) { i64, err := ParseInt(s, 10, 0) return int(i64), err }
func ParseInt(s string, base int, bitSize int) (i int64, err error){ }
var s string = "9223372036854775807" i, err := strconv.ParseInt(s, 10, 64) if err != nil { panic(err) } fmt.Printf("Hello, %v with type %s!\n", i, reflect.TypeOf(i))
set rtp+=$GOROOT/misc/vim filetype plugin indent on syntax on
" Some Linux distributions set filetype in /etc/vimrc. " Clear filetype flags before changing runtimepath to force Vim to reload them. filetype off filetype plugin indent off set runtimepath+=$GOROOT/misc/vim filetype plugin indent on syntax on
sudo apt-get install vim-gocomplete gocode vim-syntax-go vim-addon-manager install go-syntax vim-addon-manager install gocode
mkdir $HOME/.vim/ftdetect mkdir $HOME/.vim/syntax mkdir $HOME/.vim/autoload mkdir $HOME/.vim/autoload/go mkdir $HOME/.vim/ftplugin mkdir $HOME/.vim/ftplugin/go mkdir $HOME/.vim/indent mkdir $HOME/.vim/compiler mkdir $HOME/.vim/plugin mkdir $HOME/.vim/plugin/godoc ln -s $HOME/.vim/bundle/vim-golang/ftdetect/gofiletype.vim $HOME/.vim/ftdetect ln -s $HOME/.vim/bundle/vim-golang/syntax/go.vim $HOME/.vim/syntax/ ln -s $HOME/.vim/bundle/vim-golang/autoload/go/complete.vim $HOME/.vim/autoload/go/ ln -s $HOME/.vim/bundle/vim-golang/ftplugin/go.vim $HOME/.vim/ftplugin/ ln -s $HOME/.vim/bundle/vim-golang/ftplugin/go/*.vim $HOME/.vim/ftplugin/go/ ln -s $HOME/.vim/bundle/vim-golang/indent/go.vim $HOME/.vim/indent/ ln -s $HOME/.vim/bundle/vim-golang/compiler/go.vim $HOME/.vim/compiler/ ln -s $HOME/.vim/bundle/vim-golang/plugin/godoc/godoc.vim $HOME/.vim/plugin/godoc/ ln -s $HOME/.vim/bundle/vim-golang/syntax/godoc.vim $HOME/.vim/syntax/
Place $GOROOT/misc/vim/syntax/go.vim in ~/.vim/syntax/ and put the following in ~/.vim/ftdetect/go.vim: au BufRead,BufNewFile *.go set filetype=go
f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0600) if err != nil { panic(err) } defer f.Close() if _, err = f.WriteString(text); err != nil { panic(err) }
f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644) n, err := f.WriteString(text) f.Close()
package main import ( "log" "os" ) func main() { f, err := os.OpenFile("access.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } if _, err := f.Write([]byte("appended some data\n")); err != nil { log.Fatal(err) } if err := f.Close(); err != nil { log.Fatal(err) } }
f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0600) if err != nil { panic(err) } defer f.Close() fmt.Fprintf(f, "%s", text)
cmd := exec.Command("sleep", "5") err := cmd.Start() if err != nil { log.Fatal(err) } log.Printf("Waiting for command to finish...") err = cmd.Wait() log.Printf("Command finished with error: %v", err)
cmd := exec.Command("sleep", "5") if err := cmd.Start(); err != nil { log.Fatal(err) } if err := cmd.Process.Kill(); err != nil { log.Fatal("failed to kill process: ", err) }
cmd := exec.Command("sleep", "5") if err := cmd.Start(); err != nil { log.Fatal(err) } done := make(chan error, 1) go func() { done <- cmd.Wait() }() select { case <-time.After(3 * time.Second): if err := cmd.Process.Kill(); err != nil { log.Fatal("failed to kill process: ", err) } log.Println("process killed as timeout reached") case err := <-done: if err != nil { log.Fatalf("process finished with error = %v", err) } log.Print("process finished successfully") }
func main() { cmd := exec.Command("cat", "/dev/urandom") cmd.Start() timer := time.AfterFunc(1*time.Second, func() { err := cmd.Process.Kill() if err != nil { panic(err) } }) err := cmd.Wait() timer.Stop() fmt.Println(err) }
func main() { cmd := exec.Command("cat", "/dev/urandom") cmd.Start() go func(){ time.Sleep(timeout) cmd.Process.Kill() }() return cmd.Wait() }
abstract class BankAccount { int balance; void Deposit(int money) { balance += money; } void withdraw(int money) { if(money > maxAllowedWithdrawl()) throw new NotEnoughMoneyException(); balance -= money; } abstract int maxAllowedWithdrawl(); } class Account extends BankAccount { int maxAllowedWithdrawl() { return balance; } } class OverdraftAccount extends BankAccount { int overdraft; int maxAllowedWithdrawl() { return balance + overdraft; } }
// type Account interface { AddToBalance(int) MaxWithdraw() int } func Deposit(account Account, amount int) { account.AddToBalance(amount) } func Withdraw(account Account, amount int) error { if account.MaxWithdraw() < amount { return errors.New("Overdraft!") } account.AddToBalance(-amount) return nil } type BankAccount { balance int } func (account *BankAccount) AddToBalance(amount int) { account.balance += amount; } type RegularAccount { *BankAccount } func (account *RegularAccount) MaxWithdraw() int { return account.balance } type OverdraftAccount { *BankAccount overdraft int } func (account *OverdraftAccount) MaxWithdraw() int { return account.balance + account.overdraft }
package main import ( "encoding/json" "fmt" "io/ioutil" "log" "net/http" "time" ) type twitterResult struct { Results []struct { Text string `json:"text"` Ids string `json:"id_str"` Name string `json:"from_user_name"` Username string `json:"from_user"` UserId string `json:"from_user_id_str"` } } var ( twitterUrl = "http: pauseDuration = 5 * time.Second ) func retrieveTweets(c chan<- *twitterResult) { for { resp, err := http.Get(twitterUrl) if err != nil { log.Fatal(err) } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) r := new(twitterResult) err = json.Unmarshal(body, &r) if err != nil { log.Fatal(err) } c <- r time.Sleep(pauseDuration) } } func displayTweets(c chan *twitterResult) { tweets := <-c for _, v := range tweets.Results { fmt.Printf("%v:%v\n", v.Username, v.Text) } } func main() { c := make(chan *twitterResult) go retrieveTweets(c) for { displayTweets(c) } }
var request = struct { path, query string contenttype, body string }{ path: "/search.json?", query: "q=%23Kenya", contenttype: "application/json", body: twitterResponse, } var ( twitterResponse = `{ ) func TestRetrieveTweets(t *testing.T) { handler := func(w http.ResponseWriter, r *http.Request) { w.Header().Set("Content-Type", request.contenttype) io.WriteString(w, request.body) } server := httptest.NewServer(http.HandlerFunc(handler)) defer server.Close() resp, err := http.Get(server.URL) if err != nil { t.Fatalf("Get: %v", err) } checkBody(t, resp, twitterResponse) } func checkBody(t *testing.T, r *http.Response, body string) { b, err := ioutil.ReadAll(r.Body) if err != nil { t.Error("reading reponse body: %v, want %q", err, body) } if g, w := string(b), body; g != w { t.Errorf("request body mismatch: got %q, want %q", g, w) } }
func TestHeader3D(t *testing.T) { resp := httptest.NewRecorder() uri := "/3D/header/?" path := "/home/test" unlno := "997225821" param := make(url.Values) param["param1"] = []string{path} param["param2"] = []string{unlno} req, err := http.NewRequest("GET", uri+param.Encode(), nil) if err != nil { t.Fatal(err) } http.DefaultServeMux.ServeHTTP(resp, req) if p, err := ioutil.ReadAll(resp.Body); err != nil { t.Fail() } else { if strings.Contains(string(p), "Error") { t.Errorf("header response shouldn } else if !strings.Contains(string(p), `expected result`) { t.Errorf("header response doen } } }
func TestIt(t *testing.T){ ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Header().Set("Content-Type", "application/json") fmt.Fprintln(w, `{"fake twitter json string"}`) })) defer ts.Close() twitterUrl = ts.URL c := make(chan *twitterResult) go retrieveTweets(c) tweet := <-c if tweet != expected1 { t.Fail() } tweet = <-c if tweet != expected2 { t.Fail() } }
package myserver import ( "fmt" "io/ioutil" "net/http" "net/http/httptest" "testing" ) func TestMyHandler(t *testing.T) { handler := &MyHandler{} server := httptest.NewServer(handler) defer server.Close() for _, i := range []int{1, 2} { resp, err := http.Get(server.URL) if err != nil { t.Fatal(err) } if resp.StatusCode != 200 { t.Fatalf("Received non-200 response: %d\n", resp.StatusCode) } expected := fmt.Sprintf("Visitor count: %d.", i) actual, err := ioutil.ReadAll(resp.Body) if err != nil { t.Fatal(err) } if expected != string(actual) { t.Errorf("Expected the message } } }
package myserver import ( "fmt" "net/http" "sync" ) type MyHandler struct { sync.Mutex count int } func (h *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { var count int h.Lock() h.count++ count = h.count h.Unlock() fmt.Fprintf(w, "Visitor count: %d.", count) }
func downloadTweets(tweetsUrl string) (*twitterResult, error)
func(arg string) string { return "some String" + arg }
func(arg string) { fmt.Println("Some String " + arg) }
package main import ( "runtime" ) type Something struct { number int queue chan int } func gotest( s *Something, done chan bool ) { println( "from gotest:") println( &s ) for num := range s.queue { println( num ) s.number = num } done <- true } func main() { runtime.GOMAXPROCS(4) s := new(Something) println(&s) s.queue = make(chan int) done := make(chan bool) go gotest(s, done) s.queue <- 42 close(s.queue) <- done println(&s) println(s.number) }
package main import "fmt" func byval(q *int) { fmt.Printf("3. byval -- q %T: &q=%p q=&i=%p *q=i=%v\n", q, &q, q, *q) *q = 4143 fmt.Printf("4. byval -- q %T: &q=%p q=&i=%p *q=i=%v\n", q, &q, q, *q) q = nil } func main() { i := int(42) fmt.Printf("1. main -- i %T: &i=%p i=%v\n", i, &i, i) p := &i fmt.Printf("2. main -- p %T: &p=%p p=&i=%p *p=i=%v\n", p, &p, p, *p) byval(p) fmt.Printf("5. main -- p %T: &p=%p p=&i=%p *p=i=%v\n", p, &p, p, *p) fmt.Printf("6. main -- i %T: &i=%p i=%v\n", i, &i, i) }
1. main -- i int: &i=0xf840000040 i=42 2. main -- p *int: &p=0xf8400000f0 p=&i=0xf840000040 *p=i=42 3. byval -- q *int: &q=0xf8400000d8 q=&i=0xf840000040 *q=i=42 4. byval -- q *int: &q=0xf8400000d8 q=&i=0xf840000040 *q=i=4143 5. main -- p *int: &p=0xf8400000f0 p=&i=0xf840000040 *p=i=4143 6. main -- i int: &i=0xf840000040 i=4143
package main import "fmt" type SomeStruct struct { e int } func v(v SomeStruct) { fmt.Printf("v: %p %v\n", &v, v) v.e = 2 fmt.Printf("v: %p %v\n", &v, v) } func p(p *SomeStruct) { fmt.Printf("p: %p %v\n", p, *p) p.e = 2 fmt.Printf("p: %p %v\n", p, *p) } func main() { var s SomeStruct s.e = 1 fmt.Printf("s: %p %v\n", &s, s) v(s) fmt.Printf("s: %p %v\n", &s, s) p(&s) fmt.Printf("s: %p %v\n", &s, s) }
s: 0xf800000040 {1} v: 0xf8000000e0 {1} v: 0xf8000000e0 {2} s: 0xf800000040 {1} p: 0xf800000040 {1} p: 0xf800000040 {2} s: 0xf800000040 {2}
type sometype struct { } a := sometype {} b := int(2) println("Ptr to a", &a) println("Ptr to b", &b)
package main import "fmt" func zeroval(ival int) { ival = 0 } func zeroptr(iptr *int) { *iptr = 0 } func main() { i := 1 fmt.Println("initial:", i) zeroval(i) fmt.Println("zeroval:", i) zeroptr(&i) fmt.Println("zeroptr:", i) fmt.Println("pointer:", &i) }
$ go run pointers.go initial: 1 zeroval: 1 zeroptr: 0 pointer: 0x42131100
package main import ( "fmt" ) func main() { a := 42 fmt.Println(&a) }
167 168 169 func (l *Logger) Println(v ...interface{}) { l.Output(2, fmt.Sprintln(v...)) }
os.Mkdir("." + string(filepath.Separator) + c.Args().First(),0777);
import "path/filepath" path := filepath.Join(someRootPath, someSubPath)
func TestMkdirAll(t *testing.T) { tmpDir := TempDir() path := tmpDir + "/_TestMkdirAll_/dir/./dir2" err := MkdirAll(path, 0777) if err != nil { t.Fatalf("MkdirAll %q: %s", path, err) } defer RemoveAll(tmpDir + "/_TestMkdirAll_") ... }
import ( "os" "path/filepath" "log" ) func ensureDir(fileName string) { dirName := filepath.Dir(fileName) if _, serr := os.Stat(dirName); serr != nil { merr := os.MkdirAll(dirName, os.ModePerm) if merr != nil { panic(merr) } } } func main() { _, cerr := os.Create("a/b/c/d.txt") if cerr != nil { log.Fatal("error creating a/b/c", cerr) } log.Println("created file in a sub-directory.") }
package main import ( "io" "log" "os" "os/exec" ) func main() { c1 := exec.Command("ls") stdout1, err := c1.StdoutPipe() if err != nil { log.Fatal(err) } if err = c1.Start(); err != nil { log.Fatal(err) } if err = c1.Wait(); err != nil { log.Fatal(err) } c2 := exec.Command("wc", "-l") c2.Stdin = stdout1 stdout2, err := c2.StdoutPipe() if err != nil { log.Fatal(err) } if err = c2.Start(); err != nil { log.Fatal(err) } if err = c2.Wait(); err != nil { log.Fatal(err) } io.Copy(os.Stdout, stdout2) }
package main import ( "bytes" "io" "os" "os/exec" ) func main() { c1 := exec.Command("ls") c2 := exec.Command("wc", "-l") r, w := io.Pipe() c1.Stdout = w c2.Stdin = r var b2 bytes.Buffer c2.Stdout = &b2 c1.Start() c2.Start() c1.Wait() w.Close() c2.Wait() io.Copy(os.Stdout, &b2) }
func getCPUmodel() string { cmd := "cat /proc/cpuinfo | egrep out, err := exec.Command("bash","-c",cmd).Output() if err != nil { return fmt.Sprintf("Failed to execute command: %s", cmd) } return string(out) }
package main import ( "os" "os/exec" ) func main() { c1 := exec.Command("ls") c2 := exec.Command("wc", "-l") c2.Stdin, _ = c1.StdoutPipe() c2.Stdout = os.Stdout _ = c2.Start() _ = c1.Run() _ = c2.Wait() }
package main import ( "io" "os" "os/exec" ) func main() { c1 := exec.Command("ls") c2 := exec.Command("wc", "-l") pr, pw := io.Pipe() c1.Stdout = pw c2.Stdin = pr c2.Stdout = os.Stdout c1.Start() c2.Start() go func() { defer pw.Close() c1.Wait() }() c2.Wait() }
package main import ( "bytes" "io" "log" "os" "os/exec" ) func Execute(output_buffer *bytes.Buffer, stack ...*exec.Cmd) (err error) { var error_buffer bytes.Buffer pipe_stack := make([]*io.PipeWriter, len(stack)-1) i := 0 for ; i < len(stack)-1; i++ { stdin_pipe, stdout_pipe := io.Pipe() stack[i].Stdout = stdout_pipe stack[i].Stderr = &error_buffer stack[i+1].Stdin = stdin_pipe pipe_stack[i] = stdout_pipe } stack[i].Stdout = output_buffer stack[i].Stderr = &error_buffer if err := call(stack, pipe_stack); err != nil { log.Fatalln(string(error_buffer.Bytes()), err) } return err } func call(stack []*exec.Cmd, pipes []*io.PipeWriter) (err error) { if stack[0].Process == nil { if err = stack[0].Start(); err != nil { return err } } if len(stack) > 1 { if err = stack[1].Start(); err != nil { return err } defer func() { if err == nil { pipes[0].Close() err = call(stack[1:], pipes[1:]) } }() } return stack[0].Wait() } func main() { var b bytes.Buffer if err := Execute(&b, exec.Command("ls", "/Users/tyndyll/Downloads"), exec.Command("grep", "as"), exec.Command("sort", "-r"), ); err != nil { log.Fatalln(err) } io.Copy(os.Stdout, &b) }
package main import ( ... pipe "github.com/b4b4r07/go-pipe" ) func main() { var b bytes.Buffer pipe.Command(&b, exec.Command("ls", "/Users/b4b4r07/Downloads"), exec.Command("grep", "Vim"), ) io.Copy(os.Stdout, &b) }
func padNumberWithZero(value uint32) string { return fmt.Sprintf("%02d", value) }
fmt.Printf("%d", 12) fmt.Printf("%6d", 12) fmt.Printf("%06d", 12)
myWidth := 1 + int(math.Log10(float64(maxVal))) fmt.Printf("%*d", myWidth, nextVal)
1234567890 leftPad(str, "*", 3) ***1234567890 leftPad2Len(str, "*-", 13) -*-1234567890 leftPad2Len(str, "*-", 14) *-*-1234567890 leftPad2Len(str, "*", 14) ****1234567890 leftPad2Len(str, "*-x", 14) x*-x1234567890 leftPad2Len(str, "ABCDE", 14) BCDE1234567890 leftPad2Len(str, "ABCDE", 4) 7890 rightPad(str, "*", 3) 1234567890*** rightPad(str, "*!", 3) 1234567890*!*!*! rightPad2Len(str, "*-", 13) 1234567890*-* rightPad2Len(str, "*-", 14) 1234567890*-*- rightPad2Len(str, "*", 14) 1234567890**** rightPad2Len(str, "*-x", 14) 1234567890*-x* rightPad2Len(str, "ABCDE", 14) 1234567890ABCD rightPad2Len(str, "ABCDE", 4) 1234
func lpad(s string,pad string, plength int)string{ for i:=len(s);i<plength;i++{ s=pad+s } return s }
$ smitego-example go run main.go main.go:5:2: cannot find package "github.com/ /usr/local/go/src/pkg/github.com/ ($GOPATH not set) $ smitego-example export $GOPATH=$HOME -bash: export: `=/Users/
{ "shell": ["/bin/bash"], "env": {"GOPATH": "/Users/ }
export GOPATH=/Users/username/go export PATH=$GOPATH/bin:$PATH
sudo vi ~/.bash_profile export GOPATH=$HOME/go PATH=$PATH:$GOPATH/bin
mkdir $GOPATH/src/github.com/todsul/hello touch $GOPATH/src/github.com/todsul/hello/hello.go go install hello
export GOPATH=/usr/local/go export PATH=$PATH:$GOPATH/bin
export GOROOT="/usr/local/go" export GOPATH="$HOME/Documents/goWorkSpace" export PATH="$HOME/Documents/goWorkSpace/bin:$PATH"
package main import "fmt" type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} fmt.Println(getProperty(&v, "X")) } func getProperty(v *Vertex, property string) (string) { return v[property] }
package main import "fmt" import "reflect" type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} fmt.Println(getField(&v, "X")) } func getField(v *Vertex, field string) int { r := reflect.ValueOf(v) f := reflect.Indirect(r).FieldByName(field) return int(f.Int()) }
s := MyStruct { FirstField: "first value", SecondField: 2, ThirdField: "third value", } fieldsToExtract := []string{"FirstField", "ThirdField"} for _, fieldName := range fieldsToExtract { value, err := reflections.GetField(s, fieldName) DoWhatEverWithThatValue(value) } _ := reflections.SetField(&s, "FirstField", "new value") err := reflection.SetField(&s, "FirstField", 123)
package main import ( "fmt" ) var a = make([]int, 7, 8) func Test(slice []int) { slice = append(slice, 100) fmt.Println(slice) } func main() { for i := 0; i < 7; i++ { a[i] = i } Test(a) fmt.Println(a) }
func Test(slice []int) []int { slice = append(slice, 100) fmt.Println(slice) return slice } a = Test(a)
a := []int{1,2,3} a = append(a, 4) fmt.Println(a) append(a[:3], 5) fmt.Println(a)
func main() { for i := 0; i < 7; i++ { a[i] = i } Test(a) fmt.Println(a) fmt.Println(a[:cap(a)] }
b[0] = 9 Slice a len=7 cap=7 [0 0 9 0 0 0 0] Slice b len=3 cap=5 [9 0 0]
Slice a len=7 cap=7 [0 0 9 0 0 1 0] Slice b len=4 cap=5 [9 0 0 1]
Slice a len=7 cap=7 [0 0 9 0 0 1 2] Slice b len=5 cap=5 [9 0 0 1 2]
Slice a len=7 cap=7 [0 0 9 0 0 1 2] Slice b len=6 cap=12 [9 0 0 1 2 3]
b[1] = 8 Slice a len=7 cap=7 [0 0 9 0 0 1 2] Slice b len=6 cap=12 [9 8 0 1 2 3]
package main import ( "fmt" ) var a = make([]int, 7, 8) func Test(slice *[]int) { *slice = append(*slice, 100) fmt.Println(*slice) } func main() { for i := 0; i < 7; i++ { a[i] = i } Test(&a) fmt.Println(a) }
func Test(slice []int) { slice = append(slice, 100) fmt.Println(slice) }
func main() { for i := 0; i < 7; i++ { a[i] = i } Test(a) fmt.Println(a[:cap(a)]) }
package main import ( "fmt" ) func a() { x := []int{} x = append(x, 0) x = append(x, 1) y := append(x, 2) z := append(x, 3) fmt.Println(y, z) } func b() { x := []int{} x = append(x, 0) x = append(x, 1) x = append(x, 2) y := append(x, 3) z := append(x, 4) fmt.Println(y, z) } func main() { a() b() } First guess could be [0, 1, 2] [0, 1, 3] [0, 1, 2, 3] [0, 1, 2, 4] but in fact it results in [0, 1, 2] [0, 1, 3] [0, 1, 2, 4] [0, 1, 2, 4]
package main import "fmt" func main() { slice1 := []int{0, 1, 2, 3, 4} slice2 := []int{55, 66, 77} fmt.Println(slice1) slice1 = Append(slice1, slice2...) fmt.Println(slice1) } func Append(slice []int, items ...int) []int { for _, item := range items { slice = Extend(slice, item) } return slice } func Extend(slice []int, element int) []int { n := len(slice) if n == cap(slice) { newSlice := make([]int, len(slice), 2*len(slice)+1) copy(newSlice, slice) slice = newSlice } slice = slice[0 : n+1] slice[n] = element return slice }
package main import ( "fmt" "syscall" ) func block(c chan bool) { fmt.Println("block() enter") buf := make([]byte, 1024) _, _ = syscall.Read(0, buf) fmt.Println("block() exit") c <- true } func main() { c := make(chan bool) for i := 0; i < 1000; i++ { go block(c) } for i := 0; i < 1000; i++ { _ = <-c } }
package main import ( "fmt" "net/http" ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:]) } func main() { http.HandleFunc("/", handler) http.ListenAndServe(":8080", nil) }
type Foo struct { name string } func (f Foo) SetName(name string){ f.name=name } func (f Foo) GetName string (){ return f.name }
p:=new(Foo) p.SetName("Abc") name:=p.GetName() fmt.Println(name)
package main import "fmt" type Foo struct { name string } func (f *Foo) SetName(name string) { f.name = name } func (f Foo) Name() string { return f.name } func main() { p := Foo{} p.SetName("Abc") name := p.Name() fmt.Println(name) }
package main import "fmt" type Foo struct { name string } func (f *Foo) SetName(name string) { f.name = name } func (f *Foo) Name() string { return f.name } func main() { p := new(Foo) p.SetName("Abc") name := p.Name() fmt.Println(name) }
package main import ( "fmt" "io" "os" ) var _ io.Reader = (*os.File)(nil) func main() { fmt.Println("Hello, playground") }
file, err := os.Open("path/file.ext") return bufio.NewReader(file)
func CountWords(s string) map[string]int func TestCountWords(t *testing.T) { var tests = []struct { input string want map[string]int }{ {"foo", map[string]int{"foo":1}}, {"foo bar foo", map[string]int{"foo":2,"bar":1}}, } for i, c := range tests { got := CountWords(c.input) } }
func checkAsStrings(a,b interface{}) bool { return fmt.Sprintf("%v", a) != fmt.Sprintf("%v", b) } if checkAsStrings(got, c.want) { t.Errorf("Case }
import "reflect" eq := reflect.DeepEqual(m1, m2) if eq { fmt.Println("They } else { fmt.Println("They }
func eq(a, b map[string]int) bool { if len(a) != len(b) { return false } for k, v := range a { if w, ok := b[k]; !ok || v != w { return false } } return true }
rand.Reader = mathRand.New(mathRand.NewSource(0xDEADBEEF))
func isWindows() bool { return os.PathSeparator == }
if runtime.GOOS == "windows" { fmt.Println("Hello from Windows") }
package main import fmt "fmt" type Stringy func() string func foo() string{ return "Stringy function" } func takesAFunction(foo Stringy){ fmt.Printf("takesAFunction: %v\n", foo()) } func returnsAFunction()Stringy{ return func()string{ fmt.Printf("Inner stringy function\n"); return "bar" } } func main(){ takesAFunction(foo); var f Stringy = returnsAFunction(); f(); var baz Stringy = func()string{ return "anonymous stringy\n" }; fmt.Printf(baz()); }
package main import ( "fmt" ) type Lx func(int) int func cmb(f, g Lx) Lx { return func(x int) int { return g(f(x)) } } func inc(x int) int { return x + 1 } func sum(x int) int { result := 0 for i := 0; i < x; i++ { result += i } return result } func main() { n := 666 fmt.Println(cmb(inc, sum)(n)) fmt.Println(n * (n + 1) / 2) }
func CreateAdder() func(float64, float64) float64 { return func(x, y float64) float64 { return x + y } }
func Execute(a, b float64, op func(float64, float64) float64) float64 { return op(a, b) }
var adder func(float64, float64) float64 = CreateAdder() result := Execute(1.5, 2.5, adder) fmt.Println(result)
func CreateAdder() func(P float64, Q float64) float64 { return func(x, y float64) float64 { return x + y } }
var adder func(x1, x2 float64) float64 = CreateAdder()
package main import "fmt" var count int func increment(i int) int { return i + 1 } func decrement(i int) int { return i - 1 } func execute(f func(int) int) int { return f(count) } func main() { count = 2 count = execute(increment) fmt.Println(count) count = execute(decrement) fmt.Println(count) } 3 2
func MakeChain() (Chain, http.Handler) { nop := http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {}) var list []Middleware var final http.Handler = nop var f Chain f = func(m Middleware) Chain { if m != nil { list = append(list, m) } else { for i := len(list) - 1; i >= 0; i-- { mid := list[i] if mid == nil { continue } if next := mid(final); next != nil { final = next } else { final = nop } } if final == nil { final = nop } return nil } return f } return f, final } type ( Middleware func(http.Handler) http.Handler Chain func(Middleware) Chain )
func TestDummy(t *testing.T) { c, final := MakeChain() c(mw1(`OK!`))(mw2(t, `OK!`))(nil) log.Println(final) w1 := httptest.NewRecorder() r1, err := http.NewRequest("GET", "/api/v1", nil) if err != nil { t.Fatal(err) } final.ServeHTTP(w1, r1) } func mw2(t *testing.T, expectedState string) func(next http.Handler) http.Handler { return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { val := r.Context().Value(contextKey("state")) sval := fmt.Sprintf("%v", val) assert.Equal(t, sval, expectedState) }) } } func mw1(initialState string) func(next http.Handler) http.Handler { return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { ctx := context.WithValue(r.Context(), contextKey("state"), initialState) next.ServeHTTP(w, r.WithContext(ctx)) }) } } type contextKey string
Go 1.6.2 (April 2016) 32-bit x86 CPU (A10-7850K 4GHz) | Number of goroutines: 100000 | Per goroutine: | Memory: 4536.84 bytes | Time: 1.634248 µs 64-bit x86 CPU (A10-7850K 4GHz) | Number of goroutines: 100000 | Per goroutine: | Memory: 4707.92 bytes | Time: 1.842097 µs Go release.r60.3 (December 2011) 32-bit x86 CPU (1.6 GHz) | Number of goroutines: 100000 | Per goroutine: | Memory: 4243.45 bytes | Time: 5.815950 µs
package main import ( "flag" "fmt" "os" "runtime" "time" ) var n = flag.Int("n", 1e5, "Number of goroutines to create") var ch = make(chan byte) var counter = 0 func f() { counter++ <-ch } func main() { flag.Parse() if *n <= 0 { fmt.Fprintf(os.Stderr, "invalid number of goroutines") os.Exit(1) } runtime.GOMAXPROCS(1) var m0 runtime.MemStats runtime.ReadMemStats(&m0) t0 := time.Now().UnixNano() for i := 0; i < *n; i++ { go f() } runtime.Gosched() t1 := time.Now().UnixNano() runtime.GC() var m1 runtime.MemStats runtime.ReadMemStats(&m1) if counter != *n { fmt.Fprintf(os.Stderr, "failed to begin execution of all goroutines") os.Exit(1) } fmt.Printf("Number of goroutines: %d\n", *n) fmt.Printf("Per goroutine:\n") fmt.Printf(" Memory: %.2f bytes\n", float64(m1.Sys-m0.Sys)/float64(*n)) fmt.Printf(" Time: %f µs\n", float64(t1-t0)/float64(*n)/1e3) }
package main import ( "log" ) func main() { foo := New().(Faz) log.Println(foo) } type Foo interface { Bar() string } func New() Foo { return &Faz{} } type Faz struct { } func (f *Faz) Bar() string { return `Bar` }
func main() { foo := New().(*Faz) log.Println(foo) }
l := log.New(os.Stderr, "", 0) l.Println("log msg")
import "fmt" import "os" func main() { fmt.Fprintln(os.Stderr, "hello world") }
str := "Message" fmt.Fprintln(os.Stderr, str) io.WriteString(os.Stderr, str) io.Copy(os.Stderr, bytes.NewBufferString(str)) os.Stderr.Write([]byte(str))
Ldate = 1 << iota Ltime Lmicroseconds Llongfile Lshortfile LUTC LstdFlags = Ldate | Ltime
import ( "log" "os" ) func init() { log.SetOutput(os.Stdout) } func main() { log.Println("Gene Story SNP File Storage Server Started.") }
package main import ( "fmt" "reflect" ) func main() { a := 1 intPtr := reflect.New(reflect.TypeOf(a)) b := intPtr.Elem().Interface().(int) fmt.Println(b) var nilInt *int intType := reflect.TypeOf(nilInt).Elem() intPtr2 := reflect.New(intType) c := intPtr2.Elem().Interface().(int) fmt.Println(c) }
package main import ( "fmt" "reflect" ) type Config struct { Name string Meta struct { Desc string Properties map[string]string Users []string } } func initializeStruct(t reflect.Type, v reflect.Value) { for i := 0; i < v.NumField(); i++ { f := v.Field(i) ft := t.Field(i) switch ft.Type.Kind() { case reflect.Map: f.Set(reflect.MakeMap(ft.Type)) case reflect.Slice: f.Set(reflect.MakeSlice(ft.Type, 0, 0)) case reflect.Chan: f.Set(reflect.MakeChan(ft.Type, 0)) case reflect.Struct: initializeStruct(ft.Type, f) case reflect.Ptr: fv := reflect.New(ft.Type.Elem()) initializeStruct(ft.Type.Elem(), fv.Elem()) f.Set(fv) default: } } } func main() { t := reflect.TypeOf(Config{}) v := reflect.New(t) initializeStruct(t, v.Elem()) c := v.Interface().(*Config) c.Meta.Properties["color"] = "red" c.Meta.Users = append(c.Meta.Users, "srid") fmt.Println(v.Interface()) }
package main import ( "fmt" "reflect" ) func main() { type Product struct { Name string Price string } var product Product productType := reflect.TypeOf(product) productPointer := reflect.New(productType) productValue := productPointer.Elem() productInterface := productValue.Interface() product2 := productInterface.(Product) product2.Name = "Toothbrush" product2.Price = "2.50" fmt.Println(product2.Name) fmt.Println(product2.Price) }
var product Product productType := reflect.TypeOf(product) productValue := reflect.Zero(productType) productInterface := productValue.Interface() product2 := productInterface.(Product)
package main import ( "fmt" ) type MainInterface interface { GetId() string } type FirstType struct { Id string } func (ft *FirstType) GetId() string { return ft.Id } func InitializeFirstType(id string) MainInterface { return &FirstType{Id: id} } type SecondType struct { Id string } func (st *SecondType) GetId() string { return st.Id } func InitializeSecondType(id string) MainInterface { return &SecondType{Id: id} } func main() { classes := map[string]func(string) MainInterface{ "first": InitializeFirstType, "second": InitializeSecondType, } newObject := classes["first"]("10") fmt.Printf("%v\n", newObject.GetId()) newObject2 := classes["second"]("20") fmt.Printf("%v\n", newObject2.GetId()) }
type ValueConverter interface { ConvertValue(v interface{}) (Value, error) } var Bool boolType type boolType struct{} var _ ValueConverter = boolType{} func (boolType) String() string { return "Bool" } func (boolType) ConvertValue(src interface{}) (Value, error) {....}
package main import "fmt" func main() { fmt.Println("Hello World!") }
$ go build $ ls -la helloworld -rwxr-xr-x 1 janf group 2029206 Sep 11 16:58 helloworld
$ go build -ldflags "-s -w" $ ls -la helloworld -rwxr-xr-x 1 janf group 1323616 Sep 11 17:01 helloworld
package main func main() { print("Hello World!\n") }
$ go build -ldflags "-s -w" $ ls -la helloworld -rwxr-xr-x 1 janf group 714176 Sep 11 17:06 helloworld
float64(3) / float64(10) float64(3) / 10 3 / float64(10)
package main import "fmt" import "encoding/binary" func main() { var mySlice = []byte{244, 244, 244, 244, 244, 244, 244, 244} data := binary.BigEndian.Uint64(mySlice) fmt.Println(data) }
buf := bytes.NewBuffer(b) myfirstint, err := binary.ReadVarint(buf) anotherint, err := binary.ReadVarint(buf)
[TestFixture] public class SuccessTests { [SetUp] public void Init() { } }
func TestMain(m *testing.M) { mySetupFunction() retCode := m.Run() myTeardownFunction() os.Exit(retCode) }
package math func Sum(a, b int) int { return a + b }
package math import "testing" func setupTestCase(t *testing.T) func(t *testing.T) { t.Log("setup test case") return func(t *testing.T) { t.Log("teardown test case") } } func setupSubTest(t *testing.T) func(t *testing.T) { t.Log("setup sub test") return func(t *testing.T) { t.Log("teardown sub test") } } func TestAddition(t *testing.T) { cases := []struct { name string a int b int expected int }{ {"add", 2, 2, 4}, {"minus", 0, -2, -2}, {"zero", 0, 0, 0}, } teardownTestCase := setupTestCase(t) defer teardownTestCase(t) for _, tc := range cases { t.Run(tc.name, func(t *testing.T) { teardownSubTest := setupSubTest(t) defer teardownSubTest(t) result := Sum(tc.a, tc.b) if result != tc.expected { t.Fatalf("expected sum %v, but got %v", tc.expected, result) } }) } }
% go test -v === RUN TestAddition === RUN TestAddition/add === RUN TestAddition/minus === RUN TestAddition/zero --- PASS: TestAddition (0.00s) math_test.go:6: setup test case --- PASS: TestAddition/add (0.00s) math_test.go:13: setup sub test math_test.go:15: teardown sub test --- PASS: TestAddition/minus (0.00s) math_test.go:13: setup sub test math_test.go:15: teardown sub test --- PASS: TestAddition/zero (0.00s) math_test.go:13: setup sub test math_test.go:15: teardown sub test math_test.go:8: teardown test case PASS ok github.com/kare/go-unit-test-setup-teardown 0.010s %
type mytype struct { a, b int } func main() { a := []mytype{mytype{1, 2}, mytype{3, 4}} a = append(a, mytype{5, 6}) }
type a struct { b int c string } func main(){ var mySlice []a mySlice = append(mySlice,a{5,"pizza"}) }
type mytype struct { a, b int } func main() { sl := make([]mytype, 10, 50) sl[0] = mytype{1,2} for i, value := range sl { } }
a := []mytype{mytype{1, 2}, mytype{3, 4}, mytype{4, 5}}
a:= append([]mytype{}, mytype{1, 2}, mytype{3, 4}, mytype{4, 5})
func Foo() [32]byte { return [32]byte{ } func Bar(b []byte) { fmt.Println(string(b)) } func main() { x := Foo() Bar(x[:]) }
package main import ( "bytes" "fmt" "io" "mime/multipart" "net/http" "net/http/httptest" "net/http/httputil" "os" "strings" ) func main() { var client *http.Client var remoteURL string { ts := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { b, err := httputil.DumpRequest(r, true) if err != nil { panic(err) } fmt.Printf("%s", b) })) defer ts.Close() client = ts.Client() remoteURL = ts.URL } values := map[string]io.Reader{ "file": mustOpen("main.go"), "other": strings.NewReader("hello world!"), } err := Upload(client, remoteURL, values) if err != nil { panic(err) } } func Upload(client *http.Client, url string, values map[string]io.Reader) (err error) { var b bytes.Buffer w := multipart.NewWriter(&b) for key, r := range values { var fw io.Writer if x, ok := r.(io.Closer); ok { defer x.Close() } if x, ok := r.(*os.File); ok { if fw, err = w.CreateFormFile(key, x.Name()); err != nil { return } } else { if fw, err = w.CreateFormField(key); err != nil { return } } if _, err = io.Copy(fw, r); err != nil { return err } } w.Close() req, err := http.NewRequest("POST", url, &b) if err != nil { return } req.Header.Set("Content-Type", w.FormDataContentType()) res, err := client.Do(req) if err != nil { return } if res.StatusCode != http.StatusOK { err = fmt.Errorf("bad status: %s", res.Status) } return } func mustOpen(f string) *os.File { r, err := os.Open(f) if err != nil { panic(err) } return r }
w.Close() ... req.Header.Set("Content-Type", w.FormDataContentType())
req.Header.Set("Content-Type", w.FormDataContentType()) w.Close()
file, handler, err := r.FormFile("img") if err != nil { fmt.Println(err) return } defer file.Close() fmt.Println("File is good") fmt.Println(handler.Filename) fmt.Println() fmt.Println(handler.Header) f, err := os.OpenFile(handler.Filename, os.O_WRONLY|os.O_CREATE, 0666) if err != nil { fmt.Println(err) return } defer f.Close() io.Copy(f, file)
package main import "fmt" type MyType struct { field string } func main() { var array [10]MyType for _, e := range array { e.field = "foo" } for _, e := range array { fmt.Println(e.field) fmt.Println("--") } }
package main import "fmt" type MyType struct { field string } func main() { var array [10]MyType for idx, _ := range array { array[idx].field = "foo" } for _, e := range array { fmt.Println(e.field) fmt.Println("--") } }
/bin/ /pkg/ /src/ /src/my_prog/ /src/my_prog/main.go /src/my_prog/d_interface.go /src/my_prog/d_struct_that_implements_the_interface.go
fi, err := f.Stat() if err != nil { } fmt.Printf("The file is %d bytes long", fi.Size())
fi, err := os.Stat("/path/to/file"); if err != nil { return err } size := fi.Size()
file, err := os.Open( filepath ) if err != nil { log.Fatal(err) } fi, err := file.Stat() if err != nil { log.Fatal(err) } fmt.Println( fi.Size() )
func hello(){ fmt.Println("Hello World") } func main(){ pfunc := hello pfunc() }
type HelloFunc func(string) func SayHello(to string) { fmt.Printf("Hello, %s!\n", to) } func main() { var hf HelloFunc hf = SayHello hf("world") }
package main import "fmt" type ArithOp func(int, int)int func main() { calculate(Plus) calculate(Minus) calculate(Multiply) } func calculate(fp func(int, int)int) { ans := fp(3,2) fmt.Printf("\n%v\n", ans) } func Plus(a, b int) int { return a + b } func Minus(a, b int) int { return a - b } func Multiply(a,b int) int { return a * b }
package main import "fmt" func hello(){ fmt.Println("Hello World") } func main(){ var pfunc func() pfunc = hello pfunc() }
func hello(name string) int{ fmt.Println("Hello %s", name) return 0 }
fileBytes, err := ioutil.ReadFile("/absolute/path/to/file.txt")
/Users/matt/Dev/go/src/github.com/mholt/mypackage/data/file.txt
absPath, _ := filepath.Abs("../mypackage/data/file.txt")
import "os" import "io/ioutil" pwd, _ := os.Getwd() txt, _ := ioutil.ReadFile(pwd+"/path/to/file.txt")
for _, name := range bundle.Files() { r, _ := bundle.Open(name) b, _ := ioutil.ReadAll(r) fmt.Printf("file %s has length %d\n", name, len(b)) }
var av = []int{1,5,2,3,7} fmt.Println(av) sort.Ints(av) fmt.Println(av) return
var av = [...]int{1,5,2,3,7} var bv = [5]int{1,5,2,3,7}
var av = [...]int{1,5,2,3,7} fmt.Println(av) sort.Ints(av) fmt.Println(av)
a := []int{1,5,2,3,7} sortedA := make([]int, len(a)) copy(sortedA, a) sort.Ints(sortedA) fmt.Println(a) fmt.Println(sortedA)
package main import "fmt" import "bufio" import "os" func main() { var isLetterA bool fmt.Println("Enter the letter a") reader := bufio.NewReader(os.Stdin) input, _ := reader.ReadString( if(input == "a") { isLetterA = true } else { isLetterA = false } fmt.Println("You entered",input) fmt.Println("Is it the letter a?",isLetterA) }
if runtime.GOOS == "windows" { input = strings.TrimRight(input, "\r\n") } else { input = strings.TrimRight(input, "\n") }
func MyPrint(format string, args ...interface{}) { fmt.Printf("[MY PREFIX] " + format, ???) }
package main import "fmt" func MyPrint(format string, args ...interface{}) { fmt.Printf("[MY PREFIX] " + format, args...) } func main() { MyPrint("yay %d %d\n",123,234); MyPrint("yay %d\n ",123); MyPrint("yay %d\n"); }
|-- app.yaml |-- app | +-- http.go |-- templates | +-- base.html +-- github.com +-- storeski +-- appengine |-- products | |-- http.go | +-- templates | |-- list.html | +-- detail.html +-- account |-- http.go +-- templates |-- overview.html +-- notifications.html
<!DOCTYPE HTML> <html> <head> <title>{{.Store.Title}}</title> </head> <body> <div id="content"> {{template "content" .}} </div> </body> </html>
{{define "content"}} <h1> Products List </h1> {{end}}
func init() { http.HandleFunc("/products", listHandler) } var listTmpl = template.Must(template.ParseFiles("templates/base.html", "github.com/storeski/appengine/products/templates/list.html")) func listHandler(w http.ResponseWriter, r *http.Request) { tc := make(map[string]interface{}) tc["Store"] = Store tc["Products"] = Products if err := listTmpl.Execute(w, tc); err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) } }
req.Header.Get("X-Forwarded-For") req.Header.Get("x-forwarded-for") req.Header.Get("X-FORWARDED-FOR")
ips := strings.Split("10.0.0.1, 10.0.0.2, 10.0.0.3", ", ") for _, ip := range ips { fmt.Println(ip) }
package main import ( "fmt" "strconv" "log" "net" "net/http" "github.com/julienschmidt/httprouter" "github.com/skratchdot/open-golang/open" ) func getIP(w http.ResponseWriter, req *http.Request, _ httprouter.Params){ fmt.Fprintf(w, "<h1>static file server</h1><p><a href= ip, port, err := net.SplitHostPort(req.RemoteAddr) if err != nil { fmt.Fprintf(w, "userip: %q is not IP:port", req.RemoteAddr) } userIP := net.ParseIP(ip) if userIP == nil { fmt.Fprintf(w, "userip: %q is not IP:port", req.RemoteAddr) return } forward := req.Header.Get("X-Forwarded-For") fmt.Fprintf(w, "<p>IP: %s</p>", ip) fmt.Fprintf(w, "<p>Port: %s</p>", port) fmt.Fprintf(w, "<p>Forwarded for: %s</p>", forward) } func main() { myport := strconv.Itoa(10002); r := httprouter.New() r.GET("/ip", getIP) r.GET("/test", func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) { fmt.Fprint(w, "Welcome!\n") }) l, err := net.Listen("tcp", "localhost:" + myport) if err != nil { log.Fatal(err) } err = open.Start("http: if err != nil { log.Println(err) } log.Fatal(http.Serve(l, r)) }
package main import ( "fmt" "encoding/json" ) type s struct { Int int String string ByteSlice []byte } func main() { a := &s{42, "Hello World!", []byte{0,1,2,3,4}} out, err := json.Marshal(a) if err != nil { panic (err) } fmt.Println(string(out)) }
{"Int":42,"String":"Hello World!","ByteSlice":"AAECAwQ="}
type URL struct { Loc string `xml:"loc"` } type URLSET struct { URLS []URL `xml:"url"` } func (u URL) String() string { return fmt.Sprintf(u.Loc) }
func main() { r := mux.NewRouter() r.Handle("/", http.FileServer(http.Dir("./static/"))) r.HandleFunc("/search/{searchTerm}", Search) r.HandleFunc("/load/{dataId}", Load) http.Handle("/", r) http.ListenAndServe(":8100", nil) }
... main.go static\ | index.html | js\ | <js files> | css\ | <css files>
... <link rel="stylesheet" href="css/redmond/jquery-ui.min.css"/> <script src="js/jquery.min.js"></script> ...
func main() { r := mux.NewRouter() r.HandleFunc("/search/{searchTerm}", Search) r.HandleFunc("/load/{dataId}", Load) r.PathPrefix("/").Handler(http.FileServer(http.Dir("./static/"))) http.ListenAndServe(":8100", r) }
package main import ( "log" "net/http" "github.com/gorilla/mux" ) func main() { r := mux.NewRouter() s := http.StripPrefix("/static/", http.FileServer(http.Dir("./static/"))) r.PathPrefix("/static/").Handler(s) http.Handle("/", r) err := http.ListenAndServe(":8081", nil) }
func ServeStatic(router *mux.Router, staticDirectory string) { staticPaths := map[string]string{ "styles": staticDirectory + "/styles/", "bower_components": staticDirectory + "/bower_components/", "images": staticDirectory + "/images/", "scripts": staticDirectory + "/scripts/", } for pathName, pathValue := range staticPaths { pathPrefix := "/" + pathName + "/" router.PathPrefix(pathPrefix).Handler(http.StripPrefix(pathPrefix, http.FileServer(http.Dir(pathValue)))) } } router := mux.NewRouter() ServeStatic(router, "/static/")
fileHandler := http.StripPrefix("/static/", http.FileServer(http.Dir("/absolute/path/static"))) http.Handle("/static/", fileHandler)
go run main.go go run main.go -folder static/ go run main.go -folder ./
package main import ( "flag" "fmt" "net/http" "os" "strconv" "strings" "github.com/gorilla/handlers" "github.com/gorilla/mux" "github.com/kr/fs" ) func main() { mux := mux.NewRouter() var port int var folder string flag.IntVar(&port, "port", 8500, "help message for port") flag.StringVar(&folder, "folder", "", "help message for folder") flag.Parse() walker := fs.Walk("./" + folder) for walker.Step() { var www string if err := walker.Err(); err != nil { fmt.Fprintln(os.Stderr, "eroooooo") continue } www = walker.Path() if info, err := os.Stat(www); err == nil && !info.IsDir() { mux.HandleFunc("/"+strings.Replace(www, folder, "", -1), func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, www) }) } } mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, folder+"index.html") }) http.ListenAndServe(":"+strconv.Itoa(port), handlers.LoggingHandler(os.Stdout, mux)) }
func F() <-chan int { c := make(chan int) go func() { defer close(c) c <- 123 }() return c }
func consumeAll(c <-chan bool) { for b := range c { ... } }
func produce(l *net.TCPListener, c chan<- net.Conn) { for { conn, _ := l.Accept() c<-conn } } func consume(c <-chan net.Conn) { for conn := range c { } } func main() { c := make(chan net.Conn, 10) for i := 0; i < 10; i++ { go consume(c) } addr := net.TCPAddr{net.ParseIP("127.0.0.1"), 3000} l, _ := net.ListenTCP("tcp", &addr) produce(l, c) }
export GOPATH=$HOME/code/Go export GOROOT=/usr/local/opt/go/libexec export PATH=$PATH:$GOPATH/bin export PATH=$PATH:$GOROOT/bin
$ gvm use go1.7 $ go tool addr2line api asm cgo compile cover dist doc fix link nm objdump pack pprof trace vet yacc $ gym use go1.4 $ go tool 6a 6c 6g 6l addr2line cgo cover dist fix nm objdump pack pprof tour vet yacc
package main import "github.com/gonutz/w32" func main() { console := w32.GetConsoleWindow() if console != 0 { _, consoleProcID := w32.GetWindowThreadProcessId(console) if w32.GetCurrentProcessId() == consoleProcID { w32.ShowWindowAsync(console, w32.SW_HIDE) } } }
import( metrics "github.com/tevjef/go-runtime-metrics" ) func main() { metrics.DefaultConfig.CollectionInterval = time.Second if err := metrics.RunCollector(metrics.DefaultConfig); err != nil { } }
docker run --name influxdb -d -p 8086:8086 influxdb docker run -d -p 9090:3000/tcp --link influxdb --name=grafana grafana/grafana:4.1.0
HeapIdle minus HeapReleased estimates the amount of memory that could be returned to the OS, but is being retained by the runtime so it can grow the heap without requesting more memory from the OS.
func init() { go func() { t := time.Tick(time.Second) for { <-t debug.FreeOSMemory() } }() }
func makeTimestamp() int64 { return time.Now().UnixNano() % 1e6 / 1e3 }
func makeTimestamp() int64 { return time.Now().UnixNano() / int64(time.Millisecond) }
package main import ( "time" "fmt" ) func main() { a := makeTimestamp() fmt.Printf("%d \n", a) } func makeTimestamp() int64 { return time.Now().UnixNano() / int64(time.Millisecond) }
func makeTimestamp() int64 { return time.Now().UnixNano() / (int64(time.Millisecond)/int64(time.Nanosecond)) }
func NowAsUnixMilli() int64 { return time.Now().UnixNano() / 1e6 }
func makeTimestamp() int64 { return time.Now().Round(time.Millisecond).UnixNano() / (int64(time.Millisecond)/int64(time.Nanosecond)) }
package main import ( "fmt" "time" ) func main() { fmt.Println(unixMilli(time.Unix(0, 123400000))) fmt.Println(unixMilli(time.Unix(0, 123500000))) m := makeTimestampMilli() fmt.Println(m) fmt.Println(time.Unix(m/1e3, (m%1e3)*int64(time.Millisecond)/int64(time.Nanosecond))) } func unixMilli(t time.Time) int64 { return t.Round(time.Millisecond).UnixNano() / (int64(time.Millisecond) / int64(time.Nanosecond)) } func makeTimestampMilli() int64 { return unixMilli(time.Now()) }
123 124 1472313624305 2016-08-28 01:00:24.305 +0900 JST
go fmt proj go fmt proj/package go fmt proj/some_other_package
v := "4" if isInt(v) { fmt.Println("We have an int, we can safely cast this with strconv") }
if _, err := strconv.Atoi(v); err == nil { fmt.Printf("%q looks like a number.\n", v) }
if _, err := strconv.ParseInt(v,10,64); err == nil { fmt.Printf("%q looks like a number.\n", v) }
import "unicode" func isInt(s string) bool { for _, c := range s { if !unicode.IsDigit(c) { return false } } return true }
package main import ( "fmt" valid "github.com/asaskevich/govalidator" ) func main() { fmt.Println("Is it a Integer? ", valid.IsInt("978")) }
import "fmt" import "regexp" func main() { youString :="a12345" match, _ := regexp.MatchString("([a-z]+)", youString) if !match{ fmt.Println("Is Number") } else{ fmt.Println("Not Is Number") } }
func newModel(c string) Model { switch c { case "person": return newPerson() } return nil } func newPerson() *Person { return &Person{} }
func newModels(c string) []Model { switch c { case "person": return newPersons() } return nil } func newPersons() *[]Person { var models []Person return &models }
models := make([]Model, len(persons)) for i, v := range persons { models[i] = Model(v) } return models
package main import ( "fmt" ) type Model interface { Name() string } type Person struct {} func (p *Person) Name() string { return "Me" } func NewPersons() (models []*Person) { return models } func main() { var p Model p = new(Person) fmt.Println(p.Name()) arr := NewPersons() arr = append(arr, new(Person)) fmt.Println(arr[0].Name()) }
newPerson() *Person { ... } newPolitician() *Politician { ... }
newModel("person").ShowOff() newModel("person").Walk()
import "reflect" func ToIntf(s interface{}) []interface{} { v := reflect.ValueOf(s) intf := make([]interface{}, v.Len()) for i := 0; i < v.Len(); i++ { intf[i] = v.Index(i).Interface() } return intf }
for something := range fruits{ aMap := make(map[string]aStruct) aSuperMap := make(map[string]map[string]aStruct) for x := range something{ aMap[x] = aData aSuperMap[y] = aMap delete(aMap, x) } saveASuperMap(something) }
originalMap := make(map[string]int) originalMap["one"] = 1 originalMap["two"] = 2 targetMap := make(map[string]int) for key, value := range originalMap { targetMap[key] = value }
package utils func CopyMap(m map[string]interface{}) map[string]interface{} { cp := make(map[string]interface{}) for k, v := range m { vm, ok := v.(map[string]interface{}) if ok { cp[k] = CopyMap(vm) } else { cp[k] = v } } return cp }
package utils import ( "testing" "github.com/stretchr/testify/require" ) func TestCopyMap(t *testing.T) { m1 := map[string]interface{}{ "a": "bbb", "b": map[string]interface{}{ "c": 123, }, } m2 := CopyMap(m1) m1["a"] = "zzz" delete(m1, "b") require.Equal(t, map[string]interface{}{"a": "zzz"}, m1) require.Equal(t, map[string]interface{}{ "a": "bbb", "b": map[string]interface{}{ "c": 123, }, }, m2) }
maps := map[string]int { "alice":12, "jimmy":15, } maps2 := make(map[string]int) for k2,v2 := range maps { maps2[k2] = v2 } maps2["miki"]=rand.Intn(100) fmt.Println("maps: ",maps," vs. ","maps2: ",maps2)
a, err := doA() if err != nil { return nil, err } b, err := doB(a) if err != nil { return nil, err } c, err := doC(b) if err != nil { return nil, err } ... and so on ...
err := doA() if err != nil { return err } err := doB() if err != nil { return err } return nil
err := doA() if err != nil { return err } return doB()
func doStuff() (result string, err error) { a, err := doA() if err != nil { return } b, err := doB(a) if err != nil { return } result, err = doC(b) if err != nil { return } return }
func validError(errs ...error) error { for i, _ := range errs { if errs[i] != nil { return errs[i] } } return nil }
x, err1 := doSomething(2) y, err2 := doSomething(3) if e := validError(err1, err2); e != nil { return e }
type Type1 struct { a int b int c int err error } func (t *Type1) doA() { if t.err != nil { return } if err := do(); err != nil { t.err = err } } func (t *Type1) doB() { if t.err != nil { return } b, err := t.doWithA(a) if err != nil { t.err = err return } t.b = b } func (t *Type1) doC() { if t.err != nil { return } c, err := do() if err != nil { t.err = err return } t.c = c } func main() { t := Type1{} t.doA() t.doB() t.doC() if t.err != nil { } }
func doA() (A, error) { ... } func doB(a A, err error) (B, error) { ... } c, err := doB(doA())
func Must(t *Template, err error) *Template { if err != nil { panic(err) } return t }
queue := make([]int, 0) queue = append(queue, 1) x = queue[0] queue = queue[1:] if len(queue) == 0 { fmt.Println("Queue is empty !") }
type Stack struct { nodes []*Node count int } type Queue struct { nodes []*Node head int tail int count int }
func (q *Deque) PushBack(elem interface{}) { q.growIfFull() q.buf[q.tail] = elem q.tail = q.next(q.tail) q.count++ } func (q *Deque) next(i int) int { return (i + 1) & (len(q.buf) - 1) }
func (q *Deque) resize() { newBuf := make([]interface{}, q.count<<1) if q.tail > q.head { copy(newBuf, q.buf[q.head:q.tail]) } else { n := copy(newBuf, q.buf[q.head:]) copy(newBuf[n:], q.buf[:q.tail]) } q.head = 0 q.tail = q.count q.buf = newBuf }
type MyQueueElement struct { blah int } const MAX_QUEUE_SIZE = 16 type Queue struct { content [MAX_QUEUE_SIZE]MyQueueElement readHead int writeHead int len int } func (q *Queue) Push(e MyQueueElement) bool { if q.len >= MAX_QUEUE_SIZE { return false } q.content[q.writeHead] = e q.writeHead = (q.writeHead + 1) % MAX_QUEUE_SIZE q.len++ return true } func (q *Queue) Pop() (MyQueueElement, bool) { if q.len <= 0 { return MyQueueElement{}, false } result := q.content[q.readHead] q.content[q.readHead] = MyQueueElement{} q.readHead = (q.readHead + 1) % MAX_QUEUE_SIZE q.len-- return result, true }
package queue import ( "sync" ) type Queue struct { lock *sync.Mutex Values []int } func Init() Queue { return Queue{&sync.Mutex{}, make([]int, 0)} } func (q *Queue) Enqueue(x int) { for { q.lock.Lock() q.Values = append(q.Values, x) q.lock.Unlock() return } } func (q *Queue) Dequeue() *int { for { if (len(q.Values) > 0) { q.lock.Lock() x := q.Values[0] q.Values = q.Values[1:] q.lock.Unlock() return &x } return nil } return nil }
package types type queue struct { buf [][4]int head int tail int } func (q *queue) extend(need int) { if need-(len(q.buf)-q.head) > 0 { if need-len(q.buf) <= 0 { copy(q.buf, q.buf[q.head:q.tail]) q.tail = q.tail - q.head q.head = 0 return } newSize := len(q.buf) * 2 if newSize == 0 { newSize = 100 } newBuf := make([][4]int, newSize) copy(newBuf, q.buf[q.head:q.tail]) q.buf = newBuf q.tail = q.tail - q.head q.head = 0 } } func (q *queue) push(p [4]int) { q.extend(q.tail + 1) q.buf[q.tail] = p q.tail++ } func (q *queue) pop() [4]int { r := q.buf[q.head] q.head++ return r } func (q *queue) size() int { return q.tail - q.head } package types import ( "testing" "github.com/stretchr/testify/assert" ) func TestQueue(t *testing.T) { const total = 1000 q := &queue{} for i := 0; i < total; i++ { q.push([4]int{i, i, i, i}) assert.Equal(t, i+1, q.size()) } for i := 0; i < total; i++ { v := q.pop() assert.Equal(t, [4]int{i, i, i, i}, v) assert.Equal(t, total-1-i, q.size()) } }
type Queue struct{ enqueue, dequeue Stack } func (q *Queue) Enqueue(n *Thing){ q.enqueue.Push(n) } func (q *Queue) Dequeue()(*Thing, bool){ v, ok := q.dequeue.Pop() if ok{ return v, true } for { v, ok := d.enqueue.Pop() if !ok{ break } d.dequeue.Push(v) } return d.dequeue.Pop() } type Stack struct{ v []*Thing } func (s *Stack)Push(n *Thing){ s.v=append(s.v, n) } func (s *Stack) Pop()(*Thing, bool){ if len(s.v) == 0 { return nil, false } lastIdx := len(s.v)-1 v := s.v[lastIdx] s.v=s.v[:lastIdx] return v, true }
type queue struct { values []*int } func New() *queue { queue := &queue{} return queue } func (q *queue) enqueue(val *int) { q.values = append(q.values, val) }
x := go doSomething(arg) func doSomething(arg int) int{ ... return my_int_value }
func main() { c1 := make(chan string) c2 := make(chan string) go func() { time.Sleep(time.Second * 1) c1 <- "one" }() go func() { time.Sleep(time.Second * 2) c2 <- "two" }() for i := 0; i < 2; i++ { select { case msg1 := <-c1: fmt.Println("received", msg1) case msg2 := <-c2: fmt.Println("received", msg2) } } }
package main import ( "fmt" "runtime" "sync" "time" ) const ( Stopped = 0 Paused = 1 Running = 2 ) const WorkerCount = 1000 func main() { var wg sync.WaitGroup wg.Add(WorkerCount + 1) workers := make([]chan int, WorkerCount) for i := range workers { workers[i] = make(chan int) go func(i int) { worker(i, workers[i]) wg.Done() }(i) } go func() { controller(workers) wg.Done() }() wg.Wait() } func worker(id int, ws <-chan int) { state := Paused for { select { case state = <-ws: switch state { case Stopped: fmt.Printf("Worker %d: Stopped\n", id) return case Running: fmt.Printf("Worker %d: Running\n", id) case Paused: fmt.Printf("Worker %d: Paused\n", id) } default: runtime.Gosched() if state == Paused { break } } } } func controller(workers []chan int) { for i := range workers { workers[i] <- Running } <-time.After(1e9) for i := range workers { workers[i] <- Paused } <-time.After(1e9) for i := range workers { workers[i] <- Running } <-time.After(1e9) for i := range workers { close(workers[i]) } }
import ( "unsafe" "reflect" ) func isChanClosed(ch interface{}) bool { if reflect.TypeOf(ch).Kind() != reflect.Chan { panic("only channels!") } cptr := *(*uintptr)(unsafe.Pointer( unsafe.Pointer(uintptr(unsafe.Pointer(&ch)) + unsafe.Sizeof(uint(0))), )) cptr += unsafe.Sizeof(uint(0))*2 cptr += unsafe.Sizeof(unsafe.Pointer(uintptr(0))) cptr += unsafe.Sizeof(uint16(0)) return *(*uint32)(unsafe.Pointer(cptr)) > 0 }
package main import ( "fmt" "math/rand" "sync" "time" ) var wg sync.WaitGroup func init() { rand.Seed(time.Now().UnixNano()) } func main() { court := make(chan int) wg.Add(2) go player("Nadal", court) go player("Djokovic", court) court <- 1 wg.Wait() } func player(name string, court chan int) { defer wg.Done() for { ball, ok := <-court fmt.Printf("ok %t\n", ok) if !ok { fmt.Printf("Player %s Won\n", name) return } n := rand.Intn(100) if n%13 == 0 { fmt.Printf("Player %s Missed\n", name) close(court) return } fmt.Printf("Player %s Hit %d\n", name, ball) ball++ court <- ball } }
func main() { ch := make(chan int) go func() { select { case <-ch: log.Printf("1.channel") default: log.Printf("1.default") } select { case <-ch: log.Printf("2.channel") } close(ch) select { case <-ch: log.Printf("3.channel") default: log.Printf("3.default") } }() time.Sleep(time.Second) ch <- 1 time.Sleep(time.Second) }
case state, opened := <-ws: if !opened { } switch state { case Stopped:
func isChanClosed(ch chan interface{}) bool { if len(ch) == 0 { select { case _, ok := <-ch: return !ok } } return false }
main.go:8:2: cannot find package "github.com/Sirupsen/logrus" in any of: /usr/local/Cellar/go/1.3.3/libexec/src/pkg/github.com/Sirupsen/logrus (from $GOROOT) /Users/me/go/src/github.com/Sirupsen/logrus (from $GOPATH) main.go:14:2: cannot find package "github.com/alphagov/metadata-api/content_api" in any of: /usr/local/Cellar/go/1.3.3/libexec/src/pkg/github.com/alphagov/metadata-api/content_api (from $GOROOT) /Users/me/go/src/github.com/alphagov/metadata-api/content_api (from $GOPATH)
export GOROOT=$HOME/bin/go export GOBIN=$GOROOT/bin export GOPATH=$HOME/golang export PATH=$PATH:$GOBIN
type Place struct { Country string City sql.NullString TelephoneCode int `db:"telcode"` } place := Place{} rows, err := db.Queryx("SELECT * FROM place") for rows.Next() { err := rows.StructScan(&place) if err != nil { log.Fatalln(err) } fmt.Printf("% }
n := int64(123) fmt.Println(strconv.FormatInt(n, 2))
package main import ( "bytes" "fmt" ) func main() { fmt.Printf("<%s>\n", fmtBits([]byte{0xDE, 0xAD, 0xBE, 0xEF, 0xF0, 0x0D, 0xDE, 0xAD, 0xBE, 0xEF, 0xF0, 0x0D})) } func fmtBits(data []byte) []byte { var buf bytes.Buffer for _, b := range data { fmt.Fprintf(&buf, "%08b ", b) } buf.Truncate(buf.Len() - 1) return buf.Bytes() }
orgSlice := []int{1, 2, 3} newSlice := []int{} newInt := 2 newSlice = append(newSlice, newInt) for _, v := range orgSlice { if v != newInt { newSlice = append(newSlice, v) } } newSlice == [2 1 3]
set := make(map[int]struct{}) set[1] = struct{}{} set[2] = struct{}{} set[1] = struct{}{} for key := range(set) { fmt.Println(key) } if _, ok := set[1]; ok { fmt.Println("element found") } else { fmt.Println("element not found") }
func AppendIfMissing(slice []int, i int) []int { for _, ele := range slice { if ele == i { return slice } } return append(slice, i) }
func distinctObjects(objs []ObjectType) (distinctedObjs [] ObjectType){ var output []ObjectType for i:= range objs{ if output==nil || len(output)==0{ output=append(output,objs[i]) } else { founded:=false for j:= range output{ if output[j].fieldname1==objs[i].fieldname1 && output[j].fieldname2==objs[i].fieldname2 &&......... { founded=true } } if !founded{ output=append(output,objs[i]) } } } return output }
type ObjectType struct { fieldname1 string fieldname2 string ......... }
if output[j].fieldname1==objs[i].fieldname1 && output[j].fieldname2==objs[i].fieldname2 &&......... {
package main import ( "fmt" ) func main() { fmt.Println("This is main 1") }
package main import ( "fmt" ) func main() { fmt.Println("This is main 2") }
$ go build -tags ./main2.go:8: main redeclared in this block previous declaration at ./main1.go:8
package main import ( "fmt" ) func main() { fmt.Println("This is main 1") }
package main import ( "encoding/json" "fmt" "os" ) func main() { var b = []byte(` { "id": 12423434, "Name": "Fernando" } `) var f interface{} json.Unmarshal(b, &f) m := f.(map[string]interface{}) fmt.Println(m) result,_:= json.Marshal(m) os.Stdout.Write(result) }
package main import ( "strings" "encoding/json" "fmt" "log" ) var data = `{ "id": 12423434, "Name": "Fernando" }` func main() { d := json.NewDecoder(strings.NewReader(data)) d.UseNumber() var x interface{} if err := d.Decode(&x); err != nil { log.Fatal(err) } fmt.Printf("decoded to % result, err := json.Marshal(x) if err != nil { log.Fatal(err) } fmt.Printf("encoded to %s\n", result) }
decoded to map[string]interface {}{"id":"12423434", "Name":"Fernando"} encoded to {"Name":"Fernando","id":12423434}
package main import ( "encoding/json" "fmt" "os" ) type Person struct { Id int64 `json:"id"` Name string `json:"name"` } func main() { var b = []byte(`{"id": 12423434, "Name": "Fernando"}`) var f Person json.Unmarshal(b, &f) fmt.Println(f) result, _ := json.Marshal(f) os.Stdout.Write(result) }
type Container struct { Type string `json:"type"` Data json.RawMessage `json:"data"` } var b = []byte(`{"type": "person", "data":{"id": 12423434, "Name": "Fernando"}}`)
package main import( "os/exec" "bytes" "fmt" "log" ) func main() { cmd := exec.Command("somecommand", "parameter") var out bytes.Buffer cmd.Stdout = &out if err := cmd.Run() ; err != nil { log.Fatal( err ) } fmt.Printf("%q\n", out.String() ) }
package main import "os/exec" import "log" import "syscall" func main() { cmd := exec.Command("git", "blub") if err := cmd.Start(); err != nil { log.Fatalf("cmd.Start: %v") } if err := cmd.Wait(); err != nil { if exiterr, ok := err.(*exec.ExitError); ok { if status, ok := exiterr.Sys().(syscall.WaitStatus); ok { log.Printf("Exit Status: %d", status.ExitStatus()) } } else { log.Fatalf("cmd.Wait: %v", err) } } }
package utils import ( "bytes" "log" "os/exec" "syscall" ) const defaultFailedCode = 1 func RunCommand(name string, args ...string) (stdout string, stderr string, exitCode int) { log.Println("run command:", name, args) var outbuf, errbuf bytes.Buffer cmd := exec.Command(name, args...) cmd.Stdout = &outbuf cmd.Stderr = &errbuf err := cmd.Run() stdout = outbuf.String() stderr = errbuf.String() if err != nil { if exitError, ok := err.(*exec.ExitError); ok { ws := exitError.Sys().(syscall.WaitStatus) exitCode = ws.ExitStatus() } else { log.Printf("Could not get exit code for failed program: %v, %v", name, args) exitCode = defaultFailedCode if stderr == "" { stderr = err.Error() } } } else { ws := cmd.ProcessState.Sys().(syscall.WaitStatus) exitCode = ws.ExitStatus() } log.Printf("command result, stdout: %v, stderr: %v, exitCode: %v", stdout, stderr, exitCode) return }
{{range .Pages}} <li><a href="{{.}}">{{.}}</a></li> {{end}}
{{range .Pages}} <li><a href="{{$.Name}}/{{.}}">{{.}}</a></li> {{end}}
{{$name := .Name}} {{range $page := .Pages}} <li><a href="{{$name}}/{{$page}}">{{$page}}</a></li> {{end}}
type Site struct { Pages map[string]string } {{range $page, $name := .Pages}} <li><a href="{{$name}}/{{$page}}">{{$page}}</a></li> {{end}}
{{$out := .}} {{range .Pages}} <li><a href="{{$out.Name}}/{{.}}">{{.}}</a></li> {{end}}
func main() { var elems, mean int sum := 0 fmt.Print("Number of elements? ") fmt.Scan(&elems) var array = new([elems]int) for i := 0; i < elems; i++ { fmt.Printf("%d . Number? ", i+1) fmt.Scan(&array[i]) sum += array[i]; }............
package main import "fmt" func main() { fmt.Printf("%T %v\n", new([10]int), new([10]int)) fmt.Printf("%T %v\n", make([]int, 10), make([]int, 10)) }
*[10]int &[0 0 0 0 0 0 0 0 0 0] []int [0 0 0 0 0 0 0 0 0 0]
package main import "fmt" import "os" func main() { defer fmt.Println("!") os.Exit(3) }
package main import "fmt" import "os" func doTheStuff() int { defer fmt.Println("!") return 3 } func main() { os.Exit(doTheStuff()) }
package main import "fmt" import "os" type Exit struct{ Code int } func handleExit() { if e := recover(); e != nil { if exit, ok := e.(Exit); ok == true { os.Exit(exit.Code) } panic(e) } }
func main() { defer handleExit() defer fmt.Println("cleaning...") panic(Exit{3}) }
func main() { retcode := 0 defer func() { os.Exit(retcode) }() defer defer1() defer defer2() [...] if err != nil { retcode = 1 return } }
-samplego --pkg --src ---github.com ----xxxx -----a.go -----b.go --bin
cannot find package "a" in any of: /usr/local/go/src/pkg/a (from $GOROOT) /workspace/samplego/src/a (from $GOPATH)
one := []byte{} c.SetReadDeadline(time.Now()) if _, err := c.Read(one); err == io.EOF { l.Printf(logger.LevelDebug, "%s detected closed LAN connection", id) c.Close() c = nil } else { var zero time.Time c.SetReadDeadline(time.Now().Add(10 * time.Millisecond)) }
if neterr, ok := err.(net.Error); ok && neterr.Timeout() { ...
func Read(c *net.Conn, buffer []byte) bool { bytesRead, err := c.Read(buffer) if err != nil { c.Close() log.Println(err) return false } log.Println("Read ", bytesRead, " bytes") return true }
_, err := conn.Read(make([]byte, 0)) if err!=io.EOF{ logger.W("conn closed....",err) }else{ byt, _:= ioutil.ReadAll(conn); }
package main import ( "fmt" "os" "path/filepath" ) func main() { p := filepath.FromSlash("path/to/file") fmt.Println("Path: " + p) }
for i := 0; i < 5; i++ { defer fmt.Printf("%d ", i) }
func b() { for i := 0; i < 4; i++ { defer fmt.Print(i) } }
ckx := make([]byte, len(yC)+2) ckx[0] = byte(len(Yc)>>8) ckx[1] = byte(len(Yc)) copy(ckx[2:], yBytes)
var filename = "hello.blah" var extension = filepath.Ext(filename) var name = filename[0:len(filename)-len(extension)]
basename := "hello.blah" name := strings.TrimSuffix(basename, filepath.Ext(basename))
var filename = "hello.blah" var extension = filepath.Ext(filename) var name = TrimRight(filename, extension)
name, err := os.Hostname() if err != nil { fmt.Printf("Oops: %v\n", err) return } addrs, err := net.LookupHost(name) if err != nil { fmt.Printf("Oops: %v\n", err) return } for _, a := range addrs { fmt.Println(a) }
ifaces, err := net.Interfaces() for _, i := range ifaces { addrs, err := i.Addrs() for _, addr := range addrs { var ip net.IP switch v := addr.(type) { case *net.IPNet: ip = v.IP case *net.IPAddr: ip = v.IP } } }
import ( "log" "net" "strings" ) func GetOutboundIP() net.IP { conn, err := net.Dial("udp", "8.8.8.8:80") if err != nil { log.Fatal(err) } defer conn.Close() localAddr := conn.LocalAddr().(*net.UDPAddr) return localAddr.IP }
func GetLocalIP() string { addrs, err := net.InterfaceAddrs() if err != nil { return "" } for _, address := range addrs { if ipnet, ok := address.(*net.IPNet); ok && !ipnet.IP.IsLoopback() { if ipnet.IP.To4() != nil { return ipnet.IP.String() } } } return "" }
host, _ := os.Hostname() addrs, _ := net.LookupIP(host) for _, addr := range addrs { if ipv4 := addr.To4(); ipv4 != nil { fmt.Println("IPv4: ", ipv4) } }
func resolveHostIp() (string) { netInterfaceAddresses, err := net.InterfaceAddrs() if err != nil { return "" } for _, netInterfaceAddress := range netInterfaceAddresses { networkIp, ok := netInterfaceAddress.(*net.IPNet) if ok && !networkIp.IP.IsLoopback() && networkIp.IP.To4() != nil { ip := networkIp.IP.String() fmt.Println("Resolved Host IP: " + ip) return ip } } return "" }
func GetInternalIP() string { itf, _ := net.InterfaceByName("enp1s0") item, _ := itf.Addrs() var ip net.IP for _, addr := range item { switch v := addr.(type) { case *net.IPNet: if !v.IP.IsLoopback() { if v.IP.To4() != nil { ip = v.IP } } } } if ip != nil { return ip.String() } else { return "" } }
CURLcode curl_wrapper_easy_setopt_long(CURL* curl, CURLoption option, long param); CURLcode curl_wrapper_easy_setopt_str(CURL* curl, CURLoption option, char* param);
func (e *Easy)SetOption(option Option, param interface{})
func (e *Easy)SetOption(option Option, param interface{}) { switch v := param.(type) { default: fmt.Printf("unexpected type %T", v) case uint64: e.code = Code(C.curl_wrapper_easy_setopt_long(e.curl, C.CURLoption(option), C.long(v))) case string: e.code = Code(C.curl_wrapper_easy_setopt_str(e.curl, C.CURLoption(option), C.CString(v))) } }
import ( "fmt" "reflect" ) x := 42 y := float32(43.3) z := "hello" xt := reflect.TypeOf(x).Kind() yt := reflect.TypeOf(y).Kind() zt := reflect.TypeOf(z).Kind() fmt.Printf("%T: %s\n", xt, xt) fmt.Printf("%T: %s\n", yt, yt) fmt.Printf("%T: %s\n", zt, zt) if xt == reflect.Int { println(">> x is int") } if yt == reflect.Float32 { println(">> y is float32") } if zt == reflect.String { println(">> z is string") }
reflect.Kind: int reflect.Kind: float32 reflect.Kind: string >> x is int >> y is float32 >> z is string
type MyFloat float64 type Vertex struct { X, Y float64 } type EmptyInterface interface {} type Abser interface { Abs() float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (f MyFloat) Abs() float64 { return math.Abs(float64(f)) } var ia, ib Abser ia = Vertex{1, 2} ib = MyFloat(1) fmt.Println(reflect.TypeOf(ia)) fmt.Println(reflect.TypeOf(ia).Kind()) fmt.Println(reflect.TypeOf(ib)) fmt.Println(reflect.TypeOf(ib).Kind()) if reflect.TypeOf(ia) != reflect.TypeOf(ib) { fmt.Println("Not equal typeOf") } if reflect.TypeOf(ia).Kind() != reflect.TypeOf(ib).Kind() { fmt.Println("Not equal kind") } ib = Vertex{3, 4} if reflect.TypeOf(ia) == reflect.TypeOf(ib) { fmt.Println("Equal typeOf") } if reflect.TypeOf(ia).Kind() == reflect.TypeOf(ib).Kind() { fmt.Println("Equal kind") }
main.Vertex struct main.MyFloat float64 Not equal typeOf Not equal kind Equal typeOf Equal kind
if reflect.TypeOf(ia) == reflect.TypeOf(Vertex{}) { fmt.Println("self-defined") } else if reflect.TypeOf(ia).Kind() == reflect.Float64 { fmt.Println("basic types") }
func (e *Easy)SetStringOption(option Option, param string) func (e *Easy)SetLongOption(option Option, param long)
func parseIp(checkIpBody string) string { reg, err := regexp.Compile("[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+") if err == nil { return "" } return reg.FindString(checkIpBody) }
regexp.Compile("[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+")
"(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])"
package main import "fmt" func sum(a []int, c chan int) { sum := 0 for _, v := range a { sum += v } c <- sum } func main() { a := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(a[:len(a)/2], c) go sum(a[len(a)/2:], c) x, y := <-c, <-c fmt.Println(x, y, x+y) }
type A struct { b int } func f(a A) { a.b = 3 } func main() { s := A{} f(s) println(s.b) }
type JsonStruct struct { String *string Number *float64 }
package main import ( "fmt" "encoding/json" ) type JsonStruct struct { String *string Number *float64 } var rawJson = []byte(`{ "string":"We do not provide a number" }`) func main() { var s *JsonStruct err := json.Unmarshal(rawJson, &s) if err != nil { panic(err) } if s.String == nil { panic("String is missing or null!") } if s.Number == nil { panic("Number is missing or null!") } fmt.Printf("String: %s Number: %f\n", *s.String, *s.Number) }
type EnumItem struct { Named Value string } func (item *EnumItem) UnmarshalJSON(data []byte) (err error) { required := struct { Value *string `json:"value"` }{} all := struct { Named Value string `json:"value"` }{} err = json.Unmarshal(data, &required) if err != nil { return } else if required.Value == nil { err = fmt.Errorf("Required field for EnumItem missing") } else { err = json.Unmarshal(data, &all) item.Named = all.Named item.Value = all.Value } return }
type MyStruct struct { val1, val2, val3 int text1, text2, text3 string list []SomeType }
type MyStruct struct { F1, F2, F3, F4, F5, F6, F7 string I1, I2, I3, I4, I5, I6, I7 int64 } func BenchmarkAppendingStructs(b *testing.B) { var s []MyStruct for i := 0; i < b.N; i++ { s = append(s, MyStruct{}) } } func BenchmarkAppendingPointers(b *testing.B) { var s []*MyStruct for i := 0; i < b.N; i++ { s = append(s, &MyStruct{}) } }
BenchmarkAppendingStructs 1000000 3528 ns/op BenchmarkAppendingPointers 5000000 246 ns/op
package main import ( "fmt" ) type A struct { } func (a *A) Foo() { fmt.Println("A.Foo()") } func (a *A) Bar() { a.Foo() } type B struct { A } func (b *B) Foo() { fmt.Println("B.Foo()") } func main() { b := B{A: A{}} b.Bar() } output: A.Foo()
package main import ( "fmt" ) type I interface { Foo() } type A struct { i I } func (a *A) Foo() { fmt.Println("A.Foo()") } func (a *A) Bar() { a.i.Foo() } type B struct { A } func (b *B) Foo() { fmt.Println("B.Foo()") } func main() { b := B{A: A{}} b.i = &b b.Bar() output: B.Foo()
package main import ( "fmt" "log" ) type FruitType interface { Wash() FruitType Eat() string } type Fruit struct { name string dirty bool fruit FruitType } func (f *Fruit) Wash() FruitType { f.dirty = false if f.fruit != nil { return f.fruit } return f } func (f *Fruit) Eat() string { if f.dirty { return fmt.Sprintf("The %s is dirty, wash it first!", f.name) } return fmt.Sprintf("%s is so delicious!", f.name) } type Orange struct { *Fruit } func NewOrange() *Orange { ft := &Orange{&Fruit{"Orange", true, nil}} ft.fruit = ft return ft } func NewApple() *Fruit { ft := &Fruit{"apple", true, nil} return ft } func (o *Orange) Eat() string { return "The orange is so sour!" } func main() { log.Println(NewApple().Eat()) log.Println(NewApple().Wash().Eat()) log.Println(NewOrange().Eat()) log.Println(NewOrange().Wash().Eat()) }
package main import ( "fmt" ) type AChildInterface interface { Foo() } type A struct { child AChildInterface } func (a *A) Bar() { a.child.Foo() } type ADefaults struct{} func (ad ADefaults) Foo() { fmt.Println("A.Foo()") } type B struct { ADefaults } func (b B) Foo() { fmt.Println("B.Foo()") } func main() { a := A{ADefaults{}} a.Bar() b := A{B{}} b.Bar() }
package main import ( "fmt" ) type Fooer interface { Foo() } type A struct { f Fooer } func (a *A) Bar() { a.f.Foo() } func NewA(f Fooer) *A { return &A{f: f} } type B struct { } func (b *B) Foo() { fmt.Println("B.Foo()") } type C struct { } func (c *C) Foo() { fmt.Println("C.Foo()") } func main() { a := NewA(new(B)) a.Bar() a.f = &C{} a.Bar() }
package main import "fmt" type ABCD interface { Foo() } type A struct { } func (a *A) Foo() { fmt.Println("A.Foo()") } type B struct { A } func (b *B) Foo() { fmt.Println("B.Foo()") } func Bar(a ABCD) { a.Foo() } func main() { b := &B{} Bar(b) }
package main import "fmt" type aBase struct { ABCD } func (a *aBase) Bar() { a.Foo() } type a struct { aBase } func (a *a) Foo() { fmt.Println("A.Foo()") } type b struct { aBase } func (b *b) Foo() { fmt.Println("B.Foo()") } type ABCD interface { Foo() Bar() } func NewA() ABCD { a := &a{} a.ABCD = a return a } func NewB() ABCD { b := &b{} b.ABCD = b return b } func main() { b := NewB() b.Bar() a := NewA() a.Bar() }
func ConvertToMap(model interface{}) bson.M { ret := bson.M{} modelReflect := reflect.ValueOf(model) if modelReflect.Kind() == reflect.Ptr { modelReflect = modelReflect.Elem() } modelRefType := modelReflect.Type() fieldsCount := modelReflect.NumField() var fieldData interface{} for i := 0; i < fieldsCount; i++ { field := modelReflect.Field(i) switch field.Kind() { case reflect.Struct: fallthrough case reflect.Ptr: fieldData = ConvertToMap(field.Interface()) default: fieldData = field.Interface() } ret[modelRefType.Field(i).Name] = fieldData } return ret }
type Server struct { Name string ID int32 Enabled bool } s := &Server{ Name: "gopher", ID: 123456, Enabled: true, } m := structs.Map(s)
package main import ( "fmt" "encoding/json" ) type MyData struct { One int Two string Three int } func main() { in := &MyData{One: 1, Two: "second"} var inInterface map[string]interface{} inrec, _ := json.Marshal(in) json.Unmarshal(inrec, &inInterface) for field, val := range inInterface { fmt.Println("KV Pair: ", field, val) } }
// func ToMap(in interface{}, tag string) (map[string]interface{}, error){ out := make(map[string]interface{}) v := reflect.ValueOf(in) if v.Kind() == reflect.Ptr { v = v.Elem() } if v.Kind() != reflect.Struct { return nil, fmt.Errorf("ToMap only accepts structs; got %T", v) } typ := v.Type() for i := 0; i < v.NumField(); i++ { fi := typ.Field(i) if tagv := fi.Tag.Get(tag); tagv != "" { out[tagv] = v.Field(i).Interface() } } return out, nil }
package main import ( "fmt" "reflect" ) type bill struct { N1 int N2 string n3 string } func main() { a := bill{4, "dhfthf", "fdgdf"} v := reflect.ValueOf(a) values := make(map[string]interface{}, v.NumField()) for i := 0; i < v.NumField(); i++ { if v.Field(i).CanInterface() { values[v.Type().Field(i).Name] = v.Field(i).Interface() } else { fmt.Printf("sorry you have a unexported field (lower case) value you are trying to sneak past. I will not allow it: %v\n", v.Type().Field(i).Name) } } fmt.Println(values) passObject(&values) } func passObject(v1 *map[string]interface{}) { fmt.Println("yoyo") }
go run: cannot run *_test.go files (something_test.go)
package main import "fmt" import L "testing/lib" func main() { fmt.Println("Hello from main()") L.Somefunc() }
package lib import "fmt" func Somefunc() { fmt.Println("Hello from Somefunc()") return }
go run $(find . -name "*.go" -and -not -name "*_test.go" -maxdepth 1)
~/code/my-project - src - github.com + dependency-one + dependency-two - my-org - my-project * main.go + package-one + package-two - pkg - bin
func f() (result int) { defer func() { result++ }() return 0 }
for i := range whatever { defer func() { fmt. Println(i) }() }
for i := range whatever { defer func(n int) { fmt. Println(n) }(i) }
FunctionType = "func" Signature . Signature = Parameters [ Result ] . Result = Parameters | Type . Parameters = "(" [ ParameterList [ "," ] ] ")" . ParameterList = ParameterDecl { "," ParameterDecl } . ParameterDecl = [ IdentifierList ] [ "..." ] Type .
FunctionDecl = "func" FunctionName Signature [ Body ] . FunctionName = identifier . Body = Block .
package main import "container/vector" import "fmt" import "sort" func main() { m := map[string]string {"b":"15", "z":"123123", "x":"sdf", "a":"12"} var keys vector.StringVector; for k,_ := range ( m ) { keys.Push(k) } sort.Sort( &keys ) fmt.Printf("%v\n", keys) }
package main import ( "fmt" "sort" ) func main() { m := map[string]string{"b": "15", "z": "123123", "x": "sdf", "a": "12"} mk := make([]string, len(m)) i := 0 for k, _ := range m { mk[i] = k i++ } sort.Strings(mk) fmt.Println(mk) }
package main import ( "fmt" "sort" ) func main() { m := map[string]string{"b": "15", "z": "123123", "x": "sdf", "a": "12"} keys := make([]string, 0, len(m)) for key := range m { keys = append(keys, key) } sort.Strings(keys) fmt.Println(keys) }
package main import ( "fmt" "os" "path/filepath" "strings" ) func RemoveContents(dir string) error { d, err := os.Open(dir) if err != nil { return err } defer d.Close() names, err := d.Readdirnames(-1) if err != nil { return err } for _, name := range names { err = os.RemoveAll(filepath.Join(dir, name)) if err != nil { return err } } return nil } func main() { dir := strings.TrimSuffix(filepath.Base(os.Args[0]), filepath.Ext(os.Args[0])) dir = filepath.Join(os.TempDir(), dir) dirs := filepath.Join(dir, `tmpdir`) err := os.MkdirAll(dirs, 0777) if err != nil { fmt.Println(err) os.Exit(1) } file := filepath.Join(dir, `tmpfile`) f, err := os.Create(file) if err != nil { fmt.Println(err) os.Exit(1) } f.Close() file = filepath.Join(dirs, `tmpfile`) f, err = os.Create(file) if err != nil { fmt.Println(err) os.Exit(1) } f.Close() err = RemoveContents(dir) if err != nil { fmt.Println(err) os.Exit(1) } }
os.RemoveAll("/tmp/") os.MkdirAll("/tmp/",FileMode)
func RemoveContents(dir string) error { files, err := filepath.Glob(filepath.Join(dir, "*")) if err != nil { return err } for _, file := range files { err = os.RemoveAll(file) if err != nil { return err } } return nil }
package main import ( "io/ioutil" "os" "path" ) func main() { dir, err := ioutil.ReadDir("/tmp") for _, d := range dir { os.RemoveAll(path.Join([]string{"tmp", d.Name()}...)) } }
package main import "fmt" func x() { foo := 5 fmt.Printf("foo: %v\n", foo) } func main() { go x() fmt.Printf("Done.\n") }
package main import ( "fmt" "math/rand" "time" ) const ( NUMBER_OF_SIMULATIONS = 1000 NUMBER_OF_INTERACTIONS = 1000000 DROP_RATE = 0.0003 ) /** * Simulates a single interaction with a monster * * Returns 1 if the monster dropped an item and 0 otherwise */ func interaction() int { if rand.Float64() <= DROP_RATE { return 1 } return 0 } /** * Runs several interactions and retuns a slice representing the results */ func simulation(n int) []int { interactions := make([]int, n) for i := range interactions { interactions[i] = interaction() } return interactions } /** * Runs several simulations and returns the results */ func test(n int) []int { simulations := make([]int, n) for i := range simulations { successes := 0 for _, v := range simulation(NUMBER_OF_INTERACTIONS) { successes += v } simulations[i] = successes } return simulations } func main() { rand.Seed(time.Now().UnixNano()) fmt.Println("Successful interactions: ", test(NUMBER_OF_SIMULATIONS)) }
package main import ( "fmt" "math/rand" "time" "runtime" ) const ( NUMBER_OF_SIMULATIONS = 1000 NUMBER_OF_INTERACTIONS = 1000000 DROP_RATE = 0.0003 ) /** * Simulates a single interaction with a monster * * Returns 1 if the monster dropped an item and 0 otherwise */ func interaction() int { if rand.Float64() <= DROP_RATE { return 1 } return 0 } /** * Runs several interactions and retuns a slice representing the results */ func simulation(n int) []int { interactions := make([]int, n) for i := range interactions { interactions[i] = interaction() } return interactions } /** * Runs several simulations and returns the results */ func test(n int, c chan []int) { simulations := make([]int, n) for i := range simulations { for _, v := range simulation(NUMBER_OF_INTERACTIONS) { simulations[i] += v } } c <- simulations } func main() { rand.Seed(time.Now().UnixNano()) nCPU := runtime.NumCPU() runtime.GOMAXPROCS(nCPU) fmt.Println("Number of CPUs: ", nCPU) tests := make([]chan []int, nCPU) for i := range tests { c := make(chan []int) go test(NUMBER_OF_SIMULATIONS/nCPU, c) tests[i] = c } results := make([]int, NUMBER_OF_SIMULATIONS) for i, c := range tests { start := (NUMBER_OF_SIMULATIONS/nCPU) * i stop := (NUMBER_OF_SIMULATIONS/nCPU) * (i+1) copy(results[start:stop], <-c) } fmt.Println("Successful interactions: ", results) }
package main import ( "fmt" "math/rand" "time" "runtime" ) const ( NUMBER_OF_SIMULATIONS = 1000 NUMBER_OF_INTERACTIONS = 1000000 DROP_RATE = 0.0003 ) /** * Simulates a single interaction with a monster * * Returns 1 if the monster dropped an item and 0 otherwise */ func interaction(generator *rand.Rand) int { if generator.Float64() <= DROP_RATE { return 1 } return 0 } /** * Runs several interactions and retuns a slice representing the results */ func simulation(n int, generator *rand.Rand) []int { interactions := make([]int, n) for i := range interactions { interactions[i] = interaction(generator) } return interactions } /** * Runs several simulations and returns the results */ func test(n int, c chan []int) { source := rand.NewSource(time.Now().UnixNano()) generator := rand.New(source) simulations := make([]int, n) for i := range simulations { for _, v := range simulation(NUMBER_OF_INTERACTIONS, generator) { simulations[i] += v } } c <- simulations } func main() { rand.Seed(time.Now().UnixNano()) nCPU := runtime.NumCPU() runtime.GOMAXPROCS(nCPU) fmt.Println("Number of CPUs: ", nCPU) tests := make([]chan []int, nCPU) for i := range tests { c := make(chan []int) go test(NUMBER_OF_SIMULATIONS/nCPU, c) tests[i] = c } results := make([]int, NUMBER_OF_SIMULATIONS) for i, c := range tests { start := (NUMBER_OF_SIMULATIONS/nCPU) * i stop := (NUMBER_OF_SIMULATIONS/nCPU) * (i+1) copy(results[start:stop], <-c) } fmt.Println("Successful interactions: ", results) }
func test(n int, c chan []int) []int { source := rand.NewSource(time.Now().UnixNano()) generator := rand.New(source) simulations := make([]int, n) for i := range simulations { for _, v := range simulation(NUMBER_OF_INTERACTIONS, generator) { simulations[i] += v } } if c == nil { return simulations } c <- simulations return nil }
func main() { rand.Seed(time.Now().UnixNano()) nCPU := runtime.NumCPU() runtime.GOMAXPROCS(nCPU) fmt.Println("Number of CPUs: ", nCPU) start := time.Now() fmt.Println("Successful interactions: ", len(test(NUMBER_OF_SIMULATIONS, nil))) fmt.Println(time.Since(start)) start = time.Now() tests := make([]chan []int, nCPU) for i := range tests { c := make(chan []int) go test(NUMBER_OF_SIMULATIONS/nCPU, c) tests[i] = c } results := make([]int, NUMBER_OF_SIMULATIONS) for i, c := range tests { start := (NUMBER_OF_SIMULATIONS/nCPU) * i stop := (NUMBER_OF_SIMULATIONS/nCPU) * (i+1) copy(results[start:stop], <-c) } fmt.Println("Successful interactions: ", len(results)) fmt.Println(time.Since(start)) }
package main import ( "fmt" "math" "math/rand" ) type BinomialSampler []float64 func (bs BinomialSampler) Sample() int { r := rand.Float64() for i := 0; i < len(bs); i++ { if bs[i] >= r { return i } } return len(bs) } func NewBinomialSampler(N int, p float64) BinomialSampler { r := BinomialSampler(make([]float64, N+1)) T := 0.0 choice := 1.0 for i := 0; i <= N; i++ { T += choice * math.Pow(p, float64(i)) * math.Pow(1-p, float64(N-i)) r[i] = T choice *= float64(N-i) / float64(i+1) } return r } func WowSample(N int, p float64) int { if N%1000 != 0 { panic("N must be a multiple of 1000") } bs := NewBinomialSampler(1000, p) r := 0 for i := 0; i < N; i += 1000 { r += bs.Sample() } return r } func main() { for i := 0; i < 1000; i++ { fmt.Println(WowSample(1000000, 0.0003)) } }
$ go version go version devel +adf4e96e9aa4 Thu Jan 10 09:57:01 2013 +1100 linux/amd64 $ time go run temp.go Number of CPUs: 1 real 0m30.305s user 0m30.210s sys 0m0.044s $ time go run temp.go Number of CPUs: 4 real 0m9.980s user 0m35.146s sys 0m0.204s
package main import ( "fmt" "strconv" ) func main() { k := 10/3.0 i := fmt.Sprintf("%.2f", k) f,_ := strconv.ParseFloat(i, 2) fmt.Println(f) }
import ( "fmt" ) func main() { k := 10 / 3.0 fmt.Printf("%.2f", k) }
func round(num float64) int { return int(num + math.Copysign(0.5, num)) } func toFixed(num float64, precision int) float64 { output := math.Pow(10, float64(precision)) return float64(round(num * output)) / output }
fmt.Println(toFixed(1.2345678, 0)) fmt.Println(toFixed(1.2345678, 1)) fmt.Println(toFixed(1.2345678, 2)) fmt.Println(toFixed(1.2345678, 3))
package main import ( "fmt" ) func main() { untruncated := 10 / 3.0 truncated := float64(int(untruncated * 100)) / 100 fmt.Println(untruncated, truncated) }
package main import ( "math/big" "fmt" ) func main() { k := 10 / 3.0 fmt.Println(big.NewFloat(k).Text( }
j := 0.045 fmt.Println(big.NewFloat(j).SetMode(big.AwayFromZero).Text(
package main import ( "fmt" "math/big" ) func main() { f := new(big.Float).SetMode(big.ToNearestEven).SetFloat64(10/3.0) f.SetPrec(8) fmt.Printf("%.2f\n", f) }
j := 0.045 f := new(big.Float).SetMode(big.AwayFromZero).SetFloat64(j) f.SetPrec(8) fmt.Printf("%.2f\n", f)
package main import ( "fmt" "math" ) func main() { fmt.Println(Round(10/3.0, 0.01)) } func Round(x, unit float64) float64 { return math.Round(x/unit) * unit }
package main import ( "fmt" ) func main() { k := 10 / 3.0 k = float64(int(k*100)) / 100 fmt.Println(k) }
i := float64(1<<63) fmt.Println(i, float64(int64(i * 10)) / 10)
package main import ( "fmt" ) func main() { untruncated := 4.565 tmp := int(untruncated*100) last := int(untruncated*1000)-tmp*10 if last>=5{ tmp += 1 } truncated := float64(tmp)/100 fmt.Println(untruncated, truncated) }
s := []int{5, 2, 6, 3, 1, 4} sort.Reverse(sort.IntSlice(s)) fmt.Println(s)
type reverse struct { Interface } func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) } func Reverse(data Interface) Interface { return &reverse{data} }
package main import "fmt" func main() { s := []int{5, 2, 6, 3, 1, 4} for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 { s[i], s[j] = s[j], s[i] } fmt.Println(s) }
package main import ( "fmt" ) func main() { myInts := []int{ 8, 6, 7, 5, 3, 0, 9 } fmt.Printf("Ints %v reversed: %v\n", myInts, reverseInts(myInts)) } func reverseInts(input []int) []int { if len(input) == 0 { return input } return append(reverseInts(input[1:]), input[0]) }
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 { a[i], a[j] = a[j], a[i] }
package main import ( "fmt" "sort" ) func main() { s := []int{5, 2, 6, 3, 1, 4} sort.Sort(sort.Reverse(sort.IntSlice(s))) fmt.Println(s) }
func Reverse(data Interface) Interface func Sort(data Interface)
s := []int{5, 2, 6, 3, 1, 4} for i := len(s) - 1; i >= 0; i-- { fmt.Print(s[i]) if i > 0 { fmt.Print(", ") } } fmt.Println()
func ReverseSlice(s interface{}) { size := reflect.ValueOf(s).Len() swap := reflect.Swapper(s) for i, j := 0, size-1; i < j; i, j = i+1, j-1 { swap(i, j) } }
func main() { example := []int{1, 25, 3, 5, 4} sort.SliceStable(example, func(i, j int) bool { return true }) fmt.Println(example) }
func main() { xs := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} itemCount := len(xs) for i := 0; i < itemCount/2; i++ { mirrorIdx := itemCount - i -1 xs[i], xs[mirrorIdx] = xs[mirrorIdx], xs[i] } fmt.Printf("xs: %v\n", xs) }
i := 0 j := len(nums) - 1 for i < j { nums[i], nums[j] = nums[j], nums[i] i++ j-- }
0 -> 0 100 -> 100 1000 -> 1,000 1000000000 -> 1,000,000,000 -100000 -> -100,000
fmt.Printf("You owe $%s.\n", humanize.Comma(6582491))
package main import ( "golang.org/x/text/language" "golang.org/x/text/message" ) func main() { p := message.NewPrinter(language.English) p.Printf("%d\n", 1000) }
func Format(n int64) string { in := strconv.FormatInt(n, 10) out := make([]byte, len(in)+(len(in)-2+int(in[0]/ if in[0] == in, out[0] = in[1:], } for i, j, k := len(in)-1, len(out)-1, 0; ; i, j = i-1, j-1 { out[j] = in[i] if i == 0 { return string(out) } if k++; k == 3 { j, k = j-1, 0 out[j] = } } }
for _, v := range []int64{0, 1, 12, 123, 1234, 123456789} { fmt.Printf("%10d = %12s\n", v, Format(v)) fmt.Printf("%10d = %12s\n", -v, Format(-v)) }
0 = 0 0 = 0 1 = 1 -1 = -1 12 = 12 -12 = -12 123 = 123 -123 = -123 1234 = 1,234 -1234 = -1,234 123456789 = 123,456,789 -123456789 = -123,456,789
func Format2(n int64) string { if n < 0 { return "-" + Format2(-n) } in := strconv.FormatInt(n, 10) out := make([]byte, len(in)+(len(in)-1)/3) for i, j, k := len(in)-1, len(out)-1, 0; ; i, j = i-1, j-1 { out[j] = in[i] if i == 0 { return string(out) } if k++; k == 3 { j, k = j-1, 0 out[j] = } } }
func Format3(n int64) string { if n < 0 { return "-" + Format3(-n) } in := []byte(strconv.FormatInt(n, 10)) var out []byte if i := len(in) % 3; i != 0 { if out, in = append(out, in[:i]...), in[i:]; len(in) > 0 { out = append(out, } } for len(in) > 0 { if out, in = append(out, in[:3]...), in[3:]; len(in) > 0 { out = append(out, } } return string(out) }
func NumberToString(n int, sep rune) string { s := strconv.Itoa(n) startOffset := 0 var buff bytes.Buffer if n < 0 { startOffset = 1 buff.WriteByte( } l := len(s) commaIndex := 3 - ((l - startOffset) % 3) if (commaIndex == 3) { commaIndex = 0 } for i := startOffset; i < l; i++ { if (commaIndex == 3) { buff.WriteRune(sep) commaIndex = 0 } commaIndex++ buff.WriteByte(s[i]) } return buff.String() }
import ( "strconv" "regexp" ) func formatCommas(num int) string { str := strconv.Itoa(num) re := regexp.MustCompile("(\\d+)(\\d{3})") for i := 0; i < (len(str) - 1) / 3; i++ { str = re.ReplaceAllString(str, "$1,$2") } return str }
fmt.Println(formatCommas(1000)) fmt.Println(formatCommas(-1000000000))
import ( "strconv" ) func delimitNumeral(i int, delim rune) string { src := strconv.Itoa(i) strLen := utf8.RuneCountInString(src) outStr := "" digitCount := 0 for i := strLen - 1; i >= 0; i-- { outStr = src[i:i+1] + outStr if digitCount == 2 { outStr = string(delim) + outStr digitCount = 0 } else { digitCount++ } } return outStr }
import ("fmt"; "strings") func commas(s string) string { if len(s) <= 3 { return s } else { return commas(s[0:len(s)-3]) + "," + s[len(s)-3:] } } func toString(f float64) string { parts := strings.Split(fmt.Sprintf("%.2f", f), ".") if parts[0][0] == return "-" + commas(parts[0][1:]) + "." + parts[1] } return commas(parts[0]) + "." + parts[1] }
package main import ( "fmt" "github.com/dustin/go-humanize" ) func main() { fmt.Println(humanize.Commaf(float64(123456789))); fmt.Println(humanize.Commaf(float64(-1000000000))); fmt.Println(humanize.Commaf(float64(-100000.005))); fmt.Println(humanize.Commaf(float64(100000.000))); }
package main import ( "fmt" "container/list" ) func main() { x := make(map[string]*list.List) x["key"] = list.New() x["key"].PushBack("value") fmt.Println(x["key"].Front().Value) }
package main import "fmt" func main() { x := make(map[string][]string) x["key"] = append(x["key"], "value") x["key"] = append(x["key"], "value1") fmt.Println(x["key"][0]) fmt.Println(x["key"][1]) }
mapOfSlices := map[string][]string{ "first": {}, "second": []string{"one", "two", "three", "four", "five"}, "third": []string{"quarter", "half"}, }
package main import "fmt" type Car struct{ year int make string } func (c *Car)String() string{ return fmt.Sprintf("{make:%s, year:%d}", c.make, c.year) } func main() { myCar := Car{year:1996, make:"Toyota"} fmt.Println(myCar) }
switch v := v.(type) { case string: os.Stdout.WriteString(v) case fmt.Stringer: os.Stdout.WriteString(v.String()) }
package main import "fmt" type Car struct { year int make string } func (c Car) String() string { return fmt.Sprintf("{make:%s, year:%d}", c.make, c.year) } func main() { myCar := Car{year: 1996, make: "Toyota"} fmt.Println(myCar) fmt.Println(&myCar) }
package main import "fmt" type Car struct { year int make string } func (c *Car) String() string { return fmt.Sprintf("{maker:%s, produced:%d}", c.make, c.year) } func main() { myCar := Car{year: 1996, make: "Toyota"} myOtherCar := &Car{year: 2013, make: "Honda"} fmt.Println(&myCar) fmt.Println(myOtherCar) }
{maker:Toyota, produced:1996} {maker:Honda, produced:2013}
type Car struct { year int make string } func (c Car) String() string { s := fmt.Sprintf("{ptr:%p, make:%s, year:%d}", c, c.make, c.year) c.year += 1 return s } func main() { myCar := Car{year: 1996, make: "Toyota"} fmt.Println(&myCar) fmt.Println(&myCar) fmt.Println(myCar) fmt.Println(myCar) }
type Stat struct { counters map[string]*int64 countersLock sync.RWMutex averages map[string]*int64 averagesLock sync.RWMutex }
func (s *Stat) Count(name string) { s.countersLock.RLock() counter := s.counters[name] s.countersLock.RUnlock() if counter != nil { atomic.AddInt64(counter, int64(1)) return } }
type Stat struct { counters map[string]*int64 countersLock sync.RWMutex averages map[string]*int64 averagesLock sync.RWMutex } func (s *Stat) Count(name string) { s.countersLock.RLock() counter := s.counters[name] s.countersLock.RUnlock() if counter != nil { atomic.AddInt64(counter, int64(1)) return } }
type Stat struct { counters map[string]*int64 } func InitStat(names... string) Stat { counters := make(map[string]*int64) for _, name := range names { counter := int64(0) counters[name] = &counter } return Stat{counters} } func (s *Stat) Count(name string) int64 { counter := s.counters[name] if counter == nil { return -1 } return atomic.AddInt64(counter, 1) }
type Stat struct { counters map[string]*int64 mutex sync.Mutex } func InitStat() Stat { return Stat{counters: make(map[string]*int64)} } func (s *Stat) Count(name string) int64 { s.mutex.Lock() counter := s.counters[name] if counter == nil { value := int64(0) counter = &value s.counters[name] = counter } s.mutex.Unlock() return atomic.AddInt64(counter, 1) }
func (s *Stat) Count(name string) int64 { s.mutex.Lock() defer s.mutex.Unlock() counter := s.counters[name] if counter == nil { value := int64(0) counter = &value s.counters[name] = counter } return atomic.AddInt64(counter, 1) }
type Stat struct { counters map[string]*int64 mutex sync.RWMutex } func InitStat() Stat { return Stat{counters: make(map[string]*int64)} } func (s *Stat) Count(name string) int64 { var counter *int64 if counter = getCounter(name); counter == nil { counter = initCounter(name); } return atomic.AddInt64(counter, 1) } func (s *Stat) getCounter(name string) *int64 { s.mutex.RLock() defer s.mutex.RUnlock() return s.counters[name] } func (s *Stat) initCounter(name string) *int64 { s.mutex.Lock() defer s.mutex.Unlock() counter := s.counters[name] if counter == nil { value := int64(0) counter = &value s.counters[name] = counter } return counter }
type Stat struct { counters map[string]int64 mutex sync.Mutex } func InitStat() Stat { return Stat{counters: make(map[string]int64)} } func (s *Stat) Count(name string) int64 { s.mutex.Lock() defer s.mutex.Unlock() s.counters[name]++ return s.counters[name] }
package main import ( "fmt" "net/http" ) func main() { http.HandleFunc("/", HomeHandler) http.ListenAndServe(":8080", nil) } func HomeHandler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "HomeHandler") }
package main import ( "fmt" "net/http" "strings" ) var chttp = http.NewServeMux() func main() { chttp.Handle("/", http.FileServer(http.Dir("./"))) http.HandleFunc("/", HomeHandler) http.ListenAndServe(":8080", nil) } func HomeHandler(w http.ResponseWriter, r *http.Request) { if (strings.Contains(r.URL.Path, ".")) { chttp.ServeHTTP(w, r) } else { fmt.Fprintf(w, "HomeHandler") } }
package main import ( "fmt" "net/http" ) func HomeHandler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "HomeHandler") } func serveSingle(pattern string, filename string) { http.HandleFunc(pattern, func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, filename) }) } func main() { http.HandleFunc("/", HomeHandler) serveSingle("/sitemap.xml", "./sitemap.xml") serveSingle("/favicon.ico", "./favicon.ico") serveSingle("/robots.txt", "./robots.txt") http.Handle("/static", http.FileServer(http.Dir("./static/"))) http.ListenAndServe(":8080", nil) }
r := mux.NewRouter() r.HandleFunc("/", homePageHandler) r.PathPrefix("/").Handler(http.FileServer(http.Dir("./public/"))) http.Handle("/", r) http.ListenAndServe(":8080", nil)
+-----+---+--------------------------+ | rwx | 7 | Read, write and execute | | rw- | 6 | Read, write | | r-x | 5 | Read, and execute | | r-- | 4 | Read, | | -wx | 3 | Write and execute | | -w- | 2 | Write | | --x | 1 | Execute | | --- | 0 | no permissions | +------------------------------------+ +------------+------+-------+ | Permission | Octal| Field | +------------+------+-------+ | rwx------ | 0700 | User | | ---rwx--- | 0070 | Group | | ------rwx | 0007 | Other | +------------+------+-------+
ps -p $PID -o pid,vsz=MEMORY -o user,group=GROUP -o comm,args=ARGS
package main import ( "fmt" "io/ioutil" "os" "strconv" ) func Pids() ([]int, error) { f, err := os.Open(`/proc`) if err != nil { return nil, err } defer f.Close() names, err := f.Readdirnames(-1) if err != nil { return nil, err } pids := make([]int, 0, len(names)) for _, name := range names { if pid, err := strconv.ParseInt(name, 10, 0); err == nil { pids = append(pids, int(pid)) } } return pids, nil } func ProcPidStat(pid int) ([]byte, error) { filename := `/proc/` + strconv.FormatInt(int64(pid), 10) + `/stat` return ioutil.ReadFile(filename) } func main() { pids, err := Pids() if err != nil { fmt.Println("pids:", err) return } if len(pids) > 0 { pid := pids[0] stat, err := ProcPidStat(pid) if err != nil { fmt.Println("pid:", pid, err) return } fmt.Println(`/proc/[pid]/stat:`, string(stat)) } }
/proc/[pid]/stat: 1 (init) S 0 1 1 0 -1 4202752 11119 405425 21 57 78 92 6643 527 20 0 1 0 3 24768512 563 184467440737095
VarDecl = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) . VarSpec = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
const a, b, c = 3, 4, "foo" const u, v float32 = 0, 3
result, err := some_api(...) if err != nil { return err } result1, err := some_other_api(...) if err != nil { return err }
result, err := some_api(...) if err != nil { return err } if result1, err := some_other_api(...); err != nil { return err }
package main import "fmt" func main() { a, b := "a", "b"; var c, d string; fmt.Println(a,b); fmt.Println(c,d); }
func index_html() []byte { return []byte { .... } }
func index_html() []byte { data, err := ioutil.ReadFile("index.html") ... return data }
package coreinterfaces type FilterInterface interface { Filter(s *string) bool } type FieldFilter struct { Key string Val string } func (ff *FieldFilter) Filter(s *string) bool { } type FilterMapInterface interface { AddFilter(f *FilterInterface) uuid.UUID RemoveFilter(i uuid.UUID) GetFilterByID(i uuid.UUID) *FilterInterface } type FilterMap struct { mutex sync.Mutex Filters map[uuid.UUID]FilterInterface } func (fp *FilterMap) AddFilter(f *FilterInterface) uuid.UUID { } func (fp *FilterMap) RemoveFilter(i uuid.UUID) { } func (fp *FilterMap) GetFilterByID(i uuid.UUID) *FilterInterface { }
func DoFilter() { fieldfilter := &coreinterfaces.FieldFilter{Key: "app", Val: "152511"} filtermap := &coreinterfaces.FilterMap{} _ = filtermap.AddFilter(fieldfilter) }
func DoBid() error { bs := string(b) var ifilterfield coreinterfaces.FilterInterface fieldfilter := &coreinterfaces.FieldFilter{Key: "app", Val: "152511"} ifilterfield = fieldfilter filtermap := &coreinterfaces.FilterMap{} _ = filtermap.AddFilter(&ifilterfield) }
type Fooer interface { Foo() } type Foo struct{} func (f Foo) Foo() {} func main() { var f1 Foo var f2 *Foo = &Foo{} DoFoo(f1) DoFoo(f2) } func DoFoo(f Fooer) { fmt.Printf("[%T] %+v\n", f, f) }
func (fp *FilterMap) AddFilter(f FilterInterface) uuid.UUID
func (fp *FilterMap) GetFilterByID(i uuid.UUID) FilterInterface
http.Handle("/foo", fooHandler) http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path)) })
1216 type HandlerFunc func(ResponseWriter, *Request) 1217 1218 1219 func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { 1220 f(w, r) 1221 }
func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }
type Handler interface { ServeHTTP(ResponseWriter, *Request) }
HandleFunc(pattern string, func(w ResponseWriter, r *Request) { }
type HandlerFunc func(ResponseWriter, *Request) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) }
import "crypto/md5" var original = "my string comes here" var hash = md5.New(original)
package main import ( "crypto/md5" "fmt" ) func main() { data := []byte("hello") fmt.Printf("%x", md5.Sum(data)) }
package main import ( "crypto/md5" "fmt" "io" ) func main() { h := md5.New() io.WriteString(h, "The fog is getting thicker!") fmt.Printf("%x", h.Sum(nil)) }
package main import ( "crypto/md5" "encoding/hex" "fmt" ) func main() { var str string = "hello world" hasher := md5.New() hasher.Write([]byte(str)) fmt.Println(str) fmt.Println(hex.EncodeToString(hasher.Sum(nil))) }
import ( "crypto/md5" "encoding/hex" ) func GetMD5Hash(text string) string { hash := md5.Sum([]byte(text)) return hex.EncodeToString(hash[:]) }
import ( "crypto/md5" "encoding/hex" ) func GetMD5Hash(text string) string { hasher := md5.New() hasher.Write([]byte(text)) return hex.EncodeToString(hasher.Sum(nil)) }
func MD5(text string) string { algorithm := md5.New() algorithm.Write([]byte(text)) return hex.EncodeToString(algorithm.Sum(nil)) }
package main import ( "fmt" "io/ioutil" "net/http" ) func main() { client := &http.Client{} req, _ := http.NewRequest("GET", "http: req.Header.Add("Accept", "application/json") resp, err := client.Do(req) if err != nil { fmt.Println("Errored when sending request to the server") return } defer resp.Body.Close() resp_body, _ := ioutil.ReadAll(resp.Body) fmt.Println(resp.Status) fmt.Println(string(resp_body)) }
package main import ( "fmt" "log" "net/http" "os" ) func main() { req, err := http.NewRequest("GET", "http: if err != nil { log.Print(err) os.Exit(1) } q := req.URL.Query() q.Add("api_key", "key_from_environment_or_flag") q.Add("another_thing", "foo & bar") req.URL.RawQuery = q.Encode() fmt.Println(req.URL.String()) }
package main import ( "fmt" "log" "net/http" "net/url" "os" ) func main() { req, err := http.NewRequest("GET","http: if err != nil { log.Print(err) os.Exit(1) } q := req.URL.Query() q.Add("api_key", "key_from_environment_or_flag") q.Add("another_thing", "foo & bar") q := url.Values{} q.Add("api_key", "key_from_environment_or_flag") q.Add("another_thing", "foo & bar") req.URL.RawQuery = q.Encode() fmt.Println(req.URL.String()) }
var valueToSomeType = map[uint8]someType{...} var nameToSomeType = map[string]someType{...}
valueTo := &valueToSomeType nameTo := &nameToSomeType
package main import ( "errors" "fmt" "io/ioutil" "net/http" ) var BASE_URL = "https: var STORMPATH_API_KEY_ID = "xxx" var STORMPATH_API_KEY_SECRET = "xxx" func noRedirect(req *http.Request, via []*http.Request) error { return errors.New("Don } func main() { client := &http.Client{ CheckRedirect: noRedirect } req, err := http.NewRequest("GET", BASE_URL+"/tenants/current", nil) req.SetBasicAuth(STORMPATH_API_KEY_ID, STORMPATH_API_KEY_SECRET) resp, err := client.Do(req) if err != nil { if resp.StatusCode == 302 { fmt.Println("got redirect") } else { panic("HTTP request failed.") } } defer resp.Body.Close() }
client: &http.Client{ CheckRedirect: func(req *http.Request, via []*http.Request) error { return http.ErrUseLastResponse }, }
package redirects import ( "github.com/codegangsta/martini-contrib/auth" "github.com/go-martini/martini" "net/http" "net/http/httptest" "testing" ) func TestBasicAuthRedirect(t *testing.T) { server := setupBasicAuthServer() defer server.Close() req, err := http.NewRequest("GET", server.URL+"/redirect", nil) req.SetBasicAuth("username", "password") if err != nil { t.Fatal(err) } transport := http.Transport{} resp, err := transport.RoundTrip(req) if err != nil { t.Fatal(err) } if resp.StatusCode != 200 && resp.StatusCode != 302 { t.Fatal("Failed with status", resp.Status) } t.Log(resp.Header.Get("Location")) } func setupBasicAuthServer() *httptest.Server { m := martini.Classic() m.Use(auth.Basic("username", "password")) m.Get("/ping", func() string { return "pong" }) m.Get("/redirect", func(w http.ResponseWriter, r *http.Request) { http.Redirect(w, r, "/ping", 302) }) server := httptest.NewServer(m) return server }
mkdir redirects cd redirects go get github.com/codegangsta/martini-contrib/auth go get github.com/go-martini/martini go test -v
package main import ( "fmt" "io/ioutil" "net/http" "os" ) func main() { var DefaultTransport http.RoundTripper = &http.Transport{} req, _ := http.NewRequest("GET", "http: req.SetBasicAuth("user", "password") resp, _ := DefaultTransport.RoundTrip(req) defer resp.Body.Close() contents, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Printf("%s", err) os.Exit(1) } fmt.Printf("%s\n", string(contents)) }
{ "headers": { "Accept-Encoding": "gzip", "Authorization": "Basic dXNlcjpwYXNzd29yZA==", "Connection": "close", "Host": "httpbin.org", "User-Agent": "Go 1.1 package http", "X-Request-Id": "45b512f1-22e9-4e49-8acb-2f017e0a4e35" } }
for { select { case p, ok := <-mins: if ok { fmt.Println("Min:", p) } case p, ok := <-maxs: if ok { fmt.Println("Max:", p) } } }
for { minDone, maxDone := false, false select { case p, ok := <-mins: if ok { fmt.Println("Min:", p) } else { minDone = true } case p, ok := <-maxs: if ok { fmt.Println("Max:", p) } else { maxDone = true } } if (minDone && maxDone) {break} }
for { select { case x, ok := <-ch: fmt.Println("ch1", x, ok) if !ok { ch = nil } case x, ok := <-ch2: fmt.Println("ch2", x, ok) if !ok { ch2 = nil } } if ch == nil && ch2 == nil { break } }
for n := 2; n > 0; { select { case p := <-mins: fmt.Println("Min:", p) case p := <-maxs: fmt.Println("Max:", p) case <-done: n-- } }
func foo(c chan whatever, prefix s) { for v := range c { fmt.Println(prefix, v) } } go foo(mins, "Min:") go foo(maxs, "Max:")
package main import "fmt" import "io" import "reflect" func main(){ var temp io.Writer output := fmt.Sprint(temp) fmt.Println(reflect.TypeOf(output)) }
func SaySomething(i string = "Hello")(string){ ... }
func Concat1(a string, b int) string { if a == "" { a = "default-a" } if b == 0 { b = 5 } return fmt.Sprintf("%s%d", a, b) }
func Concat2(a string, b_optional ...int) string { b := 5 if len(b_optional) > 0 { b = b_optional[0] } return fmt.Sprintf("%s%d", a, b) }
type Parameters struct { A string `default:"default-a"` B string } func Concat3(prm Parameters) string { typ := reflect.TypeOf(prm) if prm.A == "" { f, _ := typ.FieldByName("A") prm.A = f.Tag.Get("default") } if prm.B == 0 { prm.B = 5 } return fmt.Sprintf("%s%d", prm.A, prm.B) }
func Concat4(args ...interface{}) string { a := "default-a" b := 5 for _, arg := range args { switch t := arg.(type) { case string: a = t case int: b = t default: panic("Unknown argument") } } return fmt.Sprintf("%s%d", a, b) }
func SaySomething(say string) { } func SayHello() { SaySomething("Hello") }
const goosList = "android darwin dragonfly freebsd linux nacl \ netbsd openbsd plan9 solaris windows " const goarchList = "386 amd64 amd64p32 arm arm64 ppc64 ppc64le \ mips mipsle mips64 mips64le mips64p32 mips64p32le \ ppc s390 s390x sparc sparc64 "
> go tool dist list -json [ { "GOOS": "android", "GOARCH": "386", "CgoSupported": true }, ... ]
$GOOS $GOARCH android arm darwin 386 darwin amd64 darwin arm darwin arm64 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm linux 386 linux amd64 linux arm linux arm64 linux ppc64 linux ppc64le linux mips linux mipsle linux mips64 linux mips64le netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 openbsd arm plan9 386 plan9 amd64 solaris amd64 windows 386 windows amd64
android/386 android/amd64 android/arm android/arm64 darwin/386 darwin/amd64 darwin/arm darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/s390x nacl/386 nacl/amd64p32 nacl/arm netbsd/386 netbsd/amd64 netbsd/arm openbsd/386 openbsd/amd64 openbsd/arm plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64
timein := time.Now().Local().AddDate(Hours, Mins, Sec)
timein := time.Now().Local().Add(time.Hour * time.Duration(Hours) + time.Minute * time.Duration(Mins) + time.Second * time.Duration(Sec))
func (t Time) AddDate(years int, months int, days int) Time
package main import ( "io/ioutil" "log" "net/http" ) func main() { client := &http.Client{} req, err := http.NewRequest("GET", "http: if err != nil { log.Fatalln(err) } req.Header.Set("User-Agent", "Golang_Spider_Bot/3.0") resp, err := client.Do(req) if err != nil { log.Fatalln(err) } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Fatalln(err) } log.Println(string(body)) }
2012/11/07 15:05:47 { "user-agent": "Golang_Spider_Bot/3.0" }
├─.bzr │ ├─branch │ │ └─lock │ ├─branch-lock │ ├─checkout │ │ └─lock │ └─repository │ ├─indices │ ├─lock │ ├─obsolete_packs │ ├─packs │ └─upload ├─bson └─testdb
auth.go:34:2: import "launchpad.net/mgo/bson": cannot find package
cd E:\WORKSPACE_GO\mgo\src\launchpad.net\mgo\bson go install cd .. go install
package main import "fmt" func main() { c := make(chan int) c <- 1 fmt.Println(<-c) }
fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() /home/tarrsalah/src/go/src/github.com/tarrsalah/tour.golang.org/65.go:8 +0x52 exit status 2
package main import "fmt" func main() { c := make(chan int) go func(){ c <- 1 }() fmt.Println(<-c) }
func main() { c := make(chan int) go func() { fmt.Println("received:", <-c) }() c <- 1 }
func main(){ ch :=make(chan int) go task(ch) ch <-10 } func task(ch chan int){ <- ch }
func main(){ ch := make(chan int) ch <- 10 go task(ch) }
func main(){ ch := make(chan int, 1) ch <-10 <- ch }
func main(){ ch := make(chan int, 1) ch <- 10 ch <- 20 <- ch <- ch }
package main import "fmt" func main() { c := make(chan int) c <- 1 fmt.Println(<-c) }
index Returns the result of indexing its first argument by the following arguments. Thus "index x 1 2 3" is, in Go syntax, x[1][2][3]. Each indexed item must be a map, slice, or array.
import "os/exec" import "strings" func main(){ plainCommand := "echo hello world" sliceA := strings.Fields(plainCommand) cmd := exec.Command(sliceA) }
package main import ( "fmt" "os/exec" ) func main() { name := "echo" args := []string{"hello", "world"} cmd := exec.Command(name, args...) out, err := cmd.Output() if err != nil { fmt.Println(err) } fmt.Println(string(out)) }
package main import "fmt" func echo(strings ...string) { for _, s := range strings { fmt.Println(s) } } func main() { strings := []string{"a", "b", "c"} echo(strings...) }
import "os/exec" import "strings" func main(){ plainCommand := "echo hello world" sliceA := strings.Fields(plainCommand) cmd := exec.Command(sliceA[0], sliceA[1:]...) }
type Event struct { Id int UserId int Start time.Time End time.Time Title string Notes string } func (e Event) IsValid() error { if e.Id <= 0 { return errors.New("Id must be greater than 0") } if e.UserId <= 0 { return errors.New("UserId must be greater than 0") } if e.End <= e.Start { return errors.New("End must be after Start") } if e.Start < time.Now() { return errors.New("Cannot create events in the past") } if e.Title == "" { return errors.New("Title cannot be empty") } return nil }
type NewUserRequest struct { Username string `validator:"min=3,max=40,regexp=^[a-zA-Z]$"` Name string `validator:"nonzero"` Age int `validator:"min=21"` Password string `validator:"min=8"` } nur := NewUserRequest{Username: "something", Age: 20} if valid, errs := validator.Validate(nur); !valid { }
package main import ( "fmt" "time" ) type Event struct { Id int UserId int Start time.Time End time.Time Title string Notes string } type Validator struct { err error } func (v *Validator) MustBeGreaterThan(high, value int) bool { if v.err != nil { return false } if value <= high { v.err = fmt.Errorf("Must be Greater than %d", high) return false } return true } func (v *Validator) MustBeBefore(high, value time.Time) bool { if v.err != nil { return false } if value.After(high) { v.err = fmt.Errorf("Must be Before than %v", high) return false } return true } func (v *Validator) MustBeNotEmpty(value string) bool { if v.err != nil { return false } if value == "" { v.err = fmt.Errorf("Must not be Empty") return false } return true } func (v *Validator) IsValid() bool { return v.err != nil } func (v *Validator) Error() string { return v.err.Error() } func main() { v := new(Validator) e := new(Event) v.MustBeGreaterThan(e.Id, 0) v.MustBeGreaterThan(e.UserId, 0) v.MustBeBefore(e.End, e.Start) v.MustBeNotEmpty(e.Title) if !v.IsValid() { fmt.Println(v) } else { fmt.Println("Valid") } } package main import ( "fmt" "time" ) type Event struct { Id int UserId int Start time.Time End time.Time Title string Notes string } type Validator struct { err error } func (v *Validator) MustBeGreaterThan(high, value int) bool { if v.err != nil { return false } if value <= high { v.err = fmt.Errorf("Must be Greater than %d", high) return false } return true } func (v *Validator) MustBeBefore(high, value time.Time) bool { if v.err != nil { return false } if value.After(high) { v.err = fmt.Errorf("Must be Before than %v", high) return false } return true } func (v *Validator) MustBeNotEmpty(value string) bool { if v.err != nil { return false } if value == "" { v.err = fmt.Errorf("Must not be Empty") return false } return true } func (v *Validator) IsValid() bool { return v.err != nil } func (v *Validator) Error() string { return v.err.Error() } func main() { v := new(Validator) e := new(Event) v.MustBeGreaterThan(e.Id, 0) v.MustBeGreaterThan(e.UserId, 0) v.MustBeBefore(e.End, e.Start) v.MustBeNotEmpty(e.Title) if !v.IsValid() { fmt.Println(v) } else { fmt.Println("Valid") } }
func (e *Event) IsValid() error { v := new(Validator) v.MustBeGreaterThan(e.Id, 0) v.MustBeGreaterThan(e.UserId, 0) v.MustBeBefore(e.End, e.Start) v.MustBeNotEmpty(e.Title) return v.IsValid() }
func check(ea *[]string, c bool, errMsg string, ...args) { if !c { *ea = append(*ea, fmt.Sprintf(errMsg, ...args)) } } func (e *Event) Validate() error { var ea []string check(&ea, e.ID >= 0, "want positive ID, got %d", e.ID) check(&ea, e.Start < e.End, "want start < end, got %s >= %s", e.Start, e.End) ... if len(ea) > 0 { return errors.New(strings.Join(ea, ", ")) } return nil }
package main import ( "fmt" "time" v "github.com/RussellLuo/validating" ) type Event struct { Id int UserId int Start time.Time End time.Time Title string Notes string } func (e *Event) Schema() v.Schema { return v.Schema{ v.F("id", &e.Id): v.Gt(0), v.F("user_id", &e.UserId): v.Gt(0), v.F("start", &e.Start): v.Gte(time.Now()), v.F("end", &e.End): v.Gt(e.Start), v.F("title", &e.Title): v.Nonzero(), v.F("notes", &e.Notes): v.Nonzero(), } } func main() { e := Event{} err := v.Validate(e.Schema()) fmt.Printf("err: %+v\n", err) }
type Event struct { Id int UserId int Start time.Time End time.Time Title string Notes string } func (e *Event) Validate() error { return Check( Cf(e.Id <= 0, "Expected ID <= 0, got %d.", e.Id), Cf(e.Start.UnixNano() > e.End.UnixNano(), "Expected start < end, got %s >= %s.", e.Start, e.End), ) } type C struct { Check bool Error error } func Cf(chk bool, errmsg string, params ...interface{}) C { return C{chk, fmt.Errorf(errmsg, params...)} } func Check(args ...C) error { for _, c := range args { if !c.Check { return c.Error } } return nil } func main() { a := Event{Id: 1, Start: time.Now()} b := Event{Id: -1} fmt.Println(a.Validate(), b.Validate()) }
type Person struct { Name string `minlength:"3" maxlength:"20"` Age int `min:"18" max:"80"` }
<plugin> <groupId>com.igormaznitsa</groupId> <artifactId>mvn-golang-wrapper</artifactId> <version>1.1.0</version> <executions> <execution> <id>golang-get</id> <goals> <goal>get</goal> </goals> <configuration> <packages> <package>github.com/gizak/termui</package> </packages> <buildFlags> <flag>-u</flag> </buildFlags> <goVersion>1.6</goVersion> </configuration> </execution> </plugin>
package main import ("image"; "image/png"; "math"; "bufio"; "os"; "time") const clock_size = 200; const radius = clock_size / 3; var colour image.RGBAColor; func circle (clock *image.RGBA) { for angle := float64(0); angle < 360; angle++ { radian_angle := math.Pi * 2 * angle / 360; x := radius * math.Sin (radian_angle) + clock_size/2; y := radius * math.Cos (radian_angle) + clock_size/2; clock.Set (int (x), int (y), colour);}} func hand (clock *image.RGBA, angle float64, length float64) { radian_angle := math.Pi * 2 * angle; x_inc := math.Sin (radian_angle); y_inc := -math.Cos (radian_angle); for i := float64(0); i < length; i++ { x := i * x_inc + clock_size/2; y := i * y_inc + clock_size/2; clock.Set (int (x), int (y), colour);}} func main () { clock := image.NewRGBA (clock_size, clock_size); colour.A = 255; circle (clock); time := time.LocalTime (); hand (clock, (float64(time.Hour) + float64(time.Minute)/60)/12, radius*0.6); hand (clock, (float64(time.Minute) + float64(time.Second)/60)/60, radius*0.8); out := bufio.NewWriter(os.Stdout); defer out.Flush(); png.Encode(out, clock); }
package main import ( "bufio" "image" "image/color" "image/png" "math" "os" "time" ) const clock_size = 200 const radius = clock_size / 3 var colour color.RGBA func circle(clock *image.RGBA) { for angle := float64(0); angle < 360; angle++ { radian_angle := math.Pi * 2 * angle / 360 x := radius*math.Sin(radian_angle) + clock_size/2 y := radius*math.Cos(radian_angle) + clock_size/2 clock.Set(int(x), int(y), colour) } } func hand(clock *image.RGBA, angle float64, length float64) { radian_angle := math.Pi * 2 * angle x_inc := math.Sin(radian_angle) y_inc := -math.Cos(radian_angle) for i := float64(0); i < length; i++ { x := i*x_inc + clock_size/2 y := i*y_inc + clock_size/2 clock.Set(int(x), int(y), colour) } } func main() { clock := image.NewRGBA(image.Rect(0, 0, clock_size, clock_size)) colour.A = 255 circle(clock) time := time.Now() hand(clock, (float64(time.Hour())+float64(time.Minute())/60)/12, radius*0.6) hand(clock, (float64(time.Minute())+float64(time.Second())/60)/60, radius*0.8) out := bufio.NewWriter(os.Stdout) defer out.Flush() png.Encode(out, clock) }
package main import ( "flag" "log" "net/http" "net/url" ) var target = flag.String("target", "http: var addr = flag.String("listen", ":12345", "Address/port on which to listen.") var auth = flag.String("auth", "", "Authorization header to add (optional).") func main() { flag.Parse() targetUrl, uerr := url.Parse(*target) if uerr != nil { log.Fatalf("Error parsing target ``%s } proxy := http.ReverseProxy{Director: func(req *http.Request) { req.URL.Scheme = targetUrl.Scheme req.URL.Host = targetUrl.Host req.Host = targetUrl.Host if *auth != "" { req.Header.Set("Authorization", *auth) } }} log.Fatal(http.ListenAndServe(*addr, &proxy)) }
package main import ("net";"container/vector";"bufio";"strings") type client struct { conn net.Conn; send chan string; receive chan string } func main() { if listener, err := net.Listen("tcp", "0.0.0.0:4242"); err == nil { master := make(chan string, 100); clients := vector.New(0); go runServer(master, clients); for { if conn, err := listener.Accept(); err == nil { c := client{ conn, master, make(chan string, 100) }; clients.Push(c); go runClient(c); } else { break } } } } func runServer(master chan string, clients *vector.Vector) { for { message := <-master; clients.Do(func (c interface{}) { c.(client).receive <- message }); } } func runClient(c client) { input := make(chan string, 10); go readLines(c, input); for { select { case inMessage := <-input: c.send <- inMessage; case outMessage := <-c.receive: c.conn.Write(strings.Bytes(outMessage)); } } } func readLines(c client, input chan string) { reader := bufio.NewReader(c.conn); for { if line, err := reader.ReadString( { input <- line; } else { break } } }
package main import ( "fmt" "math/rand" "time" ) func main() { timeout := time.After(300 * time.Millisecond) numbers := make(chan int) var numberCount int = 0 var maxNumber int = 0 go func() { for { numbers <- rand.Int() } }() for { select { case <- timeout: fmt.Printf("%v numbers generated. Max number found: %v.\n", numberCount, maxNumber) return case number := <- numbers: numberCount++ if number > maxNumber { maxNumber = number } } } }
package main import ("fmt"; "os" ;"bufio";"io") func main() { if len(os.Args) < 2 { fmt.Printf("usage: catfile \n") } else if pFile, err := os.OpenFile(os.Args[1], os.O_RDONLY, 0); err != nil { fmt.Printf("error opening file : %s\n", err) } else { defer pFile.Close() displayFile(pFile) } } func displayFile(pFile *os.File) { oReader := bufio.NewReader(pFile); for { if sLine, err := oReader.ReadString( fmt.Printf("%s", sLine) } else { if err != io.EOF {fmt.Printf("error reading file : %s\n", err)} break } } }
package main import ( "exec"; "io/ioutil"; ) func main() { if cmd, e := exec.Run("/bin/ls", nil, nil, exec.DevNull, exec.Pipe, exec.MergeWithStdout); e == nil { b, _ := ioutil.ReadAll(cmd.Stdout) println("output: " + string(b)) } }
package main import ( "fmt" "log" "os/exec" ) func main() { out, err := exec.Command("date").Output() if err != nil { log.Fatal(err) } fmt.Printf("The date is %s\n", out) }
cmd := exec.Command("date") var outb, errb bytes.Buffer cmd.Stdout = &outb cmd.Stderr = &errb err := cmd.Run() if err != nil { log.Fatal(err) } fmt.Println("out:", outb.String(), "err:", errb.String())
package main import ( "fmt" "os" ) func main() { file, err := os.Open(os.Args[1]) if err != nil { fmt.Println("Could not open file") } fmt.Printf("%s", file) }
func main() { if len(os.Args) != 2 { fmt.Printf("usage: %s [filename]\n", os.Args[0]) os.Exit(1) } file, err := os.Open(os.Args[1]) if err != nil { log.Fatal(err) } fmt.Printf("%s", file) }
func PanicExample(buf []int, i int) (x int, err error) { defer func() { if (recover() != nil) { err = errors.New("array index out of bounds") } }() x = buf[i] }
package main import ( "fmt" "os" ) func main() { defer func() { if err := recover(); err != nil { fmt.Fprintf(os.Stderr, "Exception: %v\n", err) os.Exit(1) } }() file, err := os.Open(os.Args[1]) if err != nil { fmt.Println("Could not open file") } fmt.Printf("%s", file) }
var errUnexpectedClose = errors.New("Unexpected Close") func closeTransaction(a bool) { if a == true { panic(errUnexpectedClose) } }
func TestExpectedPanic() { got := panicValue(func() { closeTransaction(true) }) a, ok := got.(error) if a != errUnexpectedClose || !ok { t.Error("Expected ", errUnexpectedClose.Error()) } } func panicValue(fn func()) (recovered interface{}) { defer func() { recovered = recover() }() fn() return }
defer func() { if r := recover(); r != nil { var ok bool err, ok = r.(error) if !ok { err = fmt.Errorf("pkg: %v", r) } } }()
godepgraph -s path/to/my/package | dot -Tpng -o godepgraph.png open ./godepgraph.png
for i:= 10; i>=0; i-- { fmt.Printf("\033[2K\r%d", i) time.Sleep(1 * time.Second) } fmt.Println()
package main import "fmt" func f(p string) { fmt.Println("function f parameter:", p) } func g(p string, q int) { fmt.Println("function g parameters:", p, q) } func main() { m := map[string]interface{}{ "f": f, "g": g, } for k, v := range m { switch k { case "f": v.(func(string))("astring") case "g": v.(func(string, int))("astring", 42) } } }
package main import "log" type fn func (string) func foo(msg string) { log.Printf("foo! Message is %s", msg) } func bar(msg string) { log.Printf("bar! Message is %s", msg) } func main() { m := map[string] fn { "f": foo, "b": bar, } log.Printf("map is %v", m) m["f"]("Hello") m["b"]("World") }
package main func main() { m := map[string]func(string) string{ "foo": func(s string) string { return s + "nurf" }, } m["foo"]("baz") }
type MyInteger int func (a MyInteger) MyMethod(b int) int { return a + b }
func valid(t *Triangle) error { if t.a + t.b > t.c && t.a + t.c > t.b && t.b + t.c > t.a { return nil } return errors.New("Triangle is not valid") } func perimeter(t *Triangle) (float64, error) { err := valid(t) if err != nil { return -1, err } return t.a + t.b + t.c, nil } func square(t *Triangle) (float64, error) { p, err := perimeter(t) if err != nil { return -1, err } p /= 2 s := p * (p - t.a) * (p - t.b) * (p - t.c) return math.Sqrt(s), nil }
func (t *Triangle) valid() error { if t.a + t.b > t.c && t.a + t.c > t.b && t.b + t.c > t.a { return nil } return errors.New("Triangle is not valid") } func (t *Triangle) perimeter() (float64, error) { err := t.valid() if err != nil { return -1, err } return t.a + t.b + t.c, nil } func (t *Triangle) square() (float64, error) { p, err := t.perimeter() if err != nil { return -1, err } p /= 2 s := p * (p - t.a) * (p - t.b) * (p - t.c) return math.Sqrt(s), nil }
func (t ReceiverType) FunctionName(Parameters...) ReturnTypes...
type MyType string t1 := MyType("sample") t1.add(1,2)
func FunctionName(*Pointers...,Parameters...) ReturnTypes...
type MyType string t1 := MyType("sample") add(&t1,4,5)
func (*Pointer) FunctionName(Parameters...) ReturnTypes...
type MyType string t1 := MyType("sample") t1.add(2,3)
type type1 []struct { Field1 string Field2 int } type type2 []struct { Field1 string Field2 int }
t1 := type1{{"A", 1}, {"B", 2}} t2 := type2(t1) fmt.Println(t2)
type t1 struct { Field1 string } type t2 struct { Field1 string `json:"field_1"` }
func GetT2FromT1(ob1 *t1) *t2 { ob2 := &t2 { Field1: t1.Field1, } return ob2 }
package main import "fmt" func main() { gen := newEven() fmt.Println(gen()) fmt.Println(gen()) fmt.Println(gen()) gen = nil } func newEven() func() int { n := 0 return func() int { n += 2 return n } }
package main import "fmt" func main() { gen := even(0) fmt.Println(gen.next()) fmt.Println(gen.next()) fmt.Println(gen.next()) } type even int func (e *even) next() int { *e += 2 return int(*e) }
package main import "fmt" func main() { gen := mapInt(newEven(), square) fmt.Println(gen()) fmt.Println(gen()) fmt.Println(gen()) gen = nil } type intGen func() int func newEven() intGen { n := 0 return func() int { n += 2 return n } } func mapInt(g intGen, f func(int) int) intGen { return func() int { return f(g()) } } func square(i int) int { return i * i }
package main import "fmt" type intIterator interface { Next() (value int, ok bool) } type iterableSlice struct { x int s []int } func (s *iterableSlice) Next() (value int, ok bool) { s.x++ if s.x >= len(s.s) { return 0, false } return s.s[s.x], true } func newSlice(s []int) *iterableSlice { return &iterableSlice{-1, s} } func main() { var ds intIterator ds = newSlice([]int{3, 1, 4}) for { v, ok := ds.Next() if !ok { break } fmt.Println(v) } }
l := Len(collection) for i := 0; i < l; i++ { value := collection.ValueAt(i) }
for next, hasNext := collection.Iterator(); hasNext; { value, hasNext = next() }
for iter := collection.Iterator(); iter.HasNext(); { value := iter.Next() }
type Foo struct { ... } func (f *Foo) Next() int { ... } foo := Foo(10) for f := foo.Next(); f >= 0; f = foo.Next() { ... }
package main import ( "fmt" ) func main() { c := nameIterator(3) for batch := range c { fmt.Println(batch) } } func nameIterator(batchSize int) <-chan []string { names := []string{"Cherry", "Cami", "Tildy", "Cory", "Ronnie", "Aleksandr", "Billie", "Reine", "Gilbertina", "Dotti"} c := make(chan []string) go func() { for i := 0; i < len(names); i++ { startIdx := i * batchSize endIdx := startIdx + batchSize if startIdx > len(names) { continue } if endIdx > len(names) { c <- names[startIdx:] } else { c <- names[startIdx:endIdx] } } close(c) }() return c }
type Person struct { Name string } func (p *Person) Label() string { return "This is " + p.Name }
package main import ( "html/template" "log" "os" ) type Person string func (p Person) Label() string { return "This is " + string(p) } func main() { tmpl, err := template.New("").Parse(`{{.Label}}`) if err != nil { log.Fatalf("Parse: %v", err) } tmpl.Execute(os.Stdout, Person("Bob")) }
type Person struct { Name string } func (p *Person) Label(param1 string) string { return "This is " + p.Name + " - " + param1 }
matt@stanley:~/gopath/src/bitbucket.org/anacrolix/meme/cmd/meme$ go get bitbucket.org/anacrolix/meme/cmd/meme can matt@stanley:~/gopath/src/bitbucket.org/anacrolix/meme/cmd/meme$ echo $GOPATH /home/matt/gopath
foo.com/api/[my-application-id]/getuserprofilejson/[username]/[session-id] foo.com/api/[my-application-id]/getuserprofilexml/[username]/[session-id]
package apitest import ( "fmt" ) test := "This is a test." func main() { fmt.Println(test) test = "Another value" fmt.Println(test) }
package main import "fmt" var test = "testing" func main() { var newVal string newVal = "Something Else" str := "Type can be inferred" fmt.Println(test) changeTest(newVal) fmt.Println(test) changeTest(str) fmt.Println(test) }
package main func changeTest(newTest string) { test = newTest }
package main import ( "fmt" ) var test map[string]int func init() { test = make(map[string]int) test["foo"] = 0 test["bar"] = 1 } func main() { fmt.Println(test) }
package main import ( "fmt" "time" ) var test = "testing" var currtime = "15:04:05" var date = "02/01/2006" func main() { t := time.Now() date := t.Format("02/01/2006") currtime := t.Format("15:04:05") fmt.Println(test) fmt.Println(currtime) fmt.Println(date) }
func getReport(filename string) (rep report, err error) { rep.data = make(map[string]float64) defer func() { if r := recover(); r != nil { fmt.Println("Recovered in f", r) err, _ = r.(error) return nil, err } }() panic("Report format not recognized.") ... }
defer func() { if r := recover(); r != nil { fmt.Println("Recovered in f", r) switch x := r.(type) { case string: err = errors.New(x) case error: err = x default: err = errors.New("Unknown panic") } rep = nil } }()
package main import "fmt" func iwillpanic() { panic("ops, panic") } func runner() (s string) { rtn_value := "" defer func() { if r := recover(); r != nil { s = "don } }() iwillpanic() return rtn_value } func main() { fmt.Println("Return Value:", runner()) }
. ├── bin │ └── hello ├── pkg └── src └── jacob.uk.com ├── greeting │ └── greeting.go └── helloworld.go 5 directories, 3 files
daemonize -p /var/run/myapp.pid -l /var/lock/subsys/myapp -u nobody /path/to/myapp.exe
func isNil(a interface{}) bool { defer func() { recover() }() return a == nil || reflect.ValueOf(a).IsNil() }
if c == nil || (reflect.ValueOf(c).Kind() == reflect.Ptr && reflect.ValueOf(c).IsNil())
package main; import "fmt"; func main()(){ var OBJ_OK *MyStruct = &( MyStruct{} ); var NOT_OK *MyStruct = nil; TakesInterface( OBJ_OK ); TakesInterface( NOT_OK ); } func TakesInterface( input_arg MyInterface ){ if( input_arg.IsInterfaceNil() ){ panic("[InputtedInterfaceIsNil]"); } input_arg.DoThing(); } type MyInterface interface{ DoThing()() IsInterfaceNil()(bool) } type MyStruct struct{} func(f *MyStruct)DoThing()(){ fmt.Println("[MyStruct.DoThing]"); } func(f *MyStruct)IsInterfaceNil()(bool){ if(nil==f){ return true; } return false; }
package main; import "fmt"; func main()(){ var OBJ_OK *IMPLMENTS_INTERFACE_01 = &( IMPLMENTS_INTERFACE_01{} ); TakesInterface( OBJ_OK ); var NOT_OK *IMPLMENTS_INTERFACE_01 = nil; TakesInterface( NOT_OK ); } func TakesInterface( hasDoThing MyInterface ){ if(nil==hasDoThing){ panic("[This_Error_Message_Will_Never_Happen]"); } switch v := hasDoThing.(type){ case (*IMPLMENTS_INTERFACE_01): if(nil==v){ panic("[Nil_PTR_01]"); } case (*IMPLMENTS_INTERFACE_02): if(nil==v){ panic("[Nil_PTR_02]"); } case (*IMPLMENTS_INTERFACE_03): if(nil==v){ panic("[Nil_PTR_03]"); } default: panic("[UnsupportedInterface]"); } hasDoThing.DoThing(); } type IMPLMENTS_INTERFACE_01 struct{}; type IMPLMENTS_INTERFACE_02 struct{}; type IMPLMENTS_INTERFACE_03 struct{}; func (f *IMPLMENTS_INTERFACE_01)DoThing()(){ fmt.Println( "DoingTheThing_01" ); } func (f *IMPLMENTS_INTERFACE_02)DoThing()(){ fmt.Println( "DoingTheThing_02" ); } func (f *IMPLMENTS_INTERFACE_03)DoThing()(){ fmt.Println( "DoingTheThing_03" ); } type MyInterface interface{ DoThing()() }
import ( "crypto/sha1" "encoding/base64" ) func (ms *MapServer) storee(bv []byte) { hasher := sha1.New() hasher.Write(bv) sha := base64.URLEncoding.EncodeToString(hasher.Sum(nil)) ... }
h := sha1.New() io.WriteString(h, "His money is twice tainted: fmt.Printf("% x", h.Sum(nil))
package main import ( "fmt" "crypto/sha1" "encoding/hex" ) func main() { s := "sha1 this string" h := sha1.New() h.Write([]byte(s)) sha1_hash := hex.EncodeToString(h.Sum(nil)) fmt.Println(s, sha1_hash) }
form_value := []byte(r.PostFormValue("login_password")) sha1_hash := fmt.Sprintf("%x", sha1.Sum(form_value)) fmt.Println(sha1_hash)
func New() hash.Hash { d := new(digest) d.Reset() return d } func Sum(data []byte) [Size]byte { var d digest d.Reset() d.Write(data) return d.checkSum() }
key := []byte(c.SKey) h := hmac.New(sha1.New, key) h.Write([]byte(requestDate)) hmacString := hex.EncodeToString(h.Sum(nil))
func SHA1(text string) string { algorithm := sha1.New() algorithm.Write([]byte(text)) return hex.EncodeToString(algorithm.Sum(nil)) }
package main type Document struct { Name string Content string Stamp time.Time Author string } func sendResponse(data interface{}, w http.ResponseWriter, r * http.Request){ _, err := json.Marshal(data) j := json.NewEncoder(w) if err == nil { encodedErr := j.Encode(data) if encodedErr != nil{ } }else{ } } func main() { http.HandleFunc("/document", control.HandleDocuments) http.ListenAndServe("localhost:4000", nil) } func HandleDocuments(w http.ResponseWriter,r *http.Request) { w.Header().Set("Content-Type", "application/json") w.Header().Set("Access-Control-Allow-Origin", "*") switch r.Method { case "GET": testDoc := model.Document{"Meeting Notes", "These are some notes", time.Now(), "Bacon"} sendResponse(testDoc, w,r) } case "POST": case "PUT": case "DELETE": default: } }
type Marshaler interface { MarshalJSON() ([]byte, error) }
type JSONTime time.Time func (t JSONTime)MarshalJSON() ([]byte, error) { stamp := fmt.Sprintf("\"%s\"", time.Time(t).Format("Mon Jan _2")) return []byte(stamp), nil }
type Document struct { Name string Content string Stamp JSONTime Author string }
testDoc := model.Document{"Meeting Notes", "These are some notes", JSONTime(time.Now()), "Bacon"}
type Document struct { Name string Content string Stamp time.Time Author string } func (d *Document) MarshalJSON() ([]byte, error) { type Alias Document return json.Marshal(&struct { *Alias Stamp string `json:"stamp"` }{ Alias: (*Alias)(d), Stamp: d.Stamp.Format("Mon Jan _2"), }) }
type JSONTime struct { time.Time } func (t JSONTime)MarshalJSON() ([]byte, error) { stamp := fmt.Sprintf("\"%s\"", t.Format("Mon Jan _2")) return []byte(stamp), nil }
type ShortDateFormattedTime time.Time func (s ShortDateFormattedTime) MarshalJSON() ([]byte, error) { t := time.Time(s) if y := t.Year(); y < 0 || y >= 10000 { return nil, errors.New("Time.MarshalJSON: year outside of range [0,9999]") } return []byte(t.Format(`"Jan 02, 2006"`)), nil }
package main import ( "fmt" "os/exec" "sync" ) func exe_cmd(cmd string, wg *sync.WaitGroup) { fmt.Println(cmd) c = cmd.Str out, err := exec.Command(cmd).Output() if err != nil { fmt.Println("error occured") fmt.Printf("%s", err) } fmt.Printf("%s", out) wg.Done() } func main() { wg := new(sync.WaitGroup) wg.Add(3) x := []string{"echo newline >> foo.o", "echo newline >> f1.o", "echo newline >> f2.o"} go exe_cmd(x[0], wg) go exe_cmd(x[1], wg) go exe_cmd(x[2], wg) wg.Wait() }
exec: "echo newline >> foo.o": executable file not found in $PATHexec: "echo newline >> f2.o": executable file not found in $PATHexec: "echo newline >> f1.o": executable file not found in $PATH
func exe_cmd(cmd string, wg *sync.WaitGroup) { fmt.Println("command is ",cmd) parts := strings.Fields(cmd) head := parts[0] parts = parts[1:len(parts)] out, err := exec.Command(head,parts...).Output() if err != nil { fmt.Printf("%s", err) } fmt.Printf("%s", out) wg.Done() }
package main import ( "fmt" "os/exec" "sync" "strings" ) func exe_cmd(cmd string, wg *sync.WaitGroup) { fmt.Println(cmd) parts := strings.Fields(cmd) out, err := exec.Command(parts[0],parts[1]).Output() if err != nil { fmt.Println("error occured") fmt.Printf("%s", err) } fmt.Printf("%s", out) wg.Done() } func main() { wg := new(sync.WaitGroup) commands := []string{"echo newline >> foo.o", "echo newline >> f1.o", "echo newline >> f2.o"} for _, str := range commands { wg.Add(1) go exe_cmd(str, wg) } wg.Wait() }
package main import ( "os" "os/exec" "fmt" "strings" "path/filepath" ) var ( output_path = filepath.Join("./output") bash_script = filepath.Join( "_script.sh" ) ) func checkError( e error){ if e != nil { panic(e) } } func exe_cmd(cmds []string) { os.RemoveAll(output_path) err := os.MkdirAll( output_path, os.ModePerm|os.ModeDir ) checkError(err) file, err := os.Create( filepath.Join(output_path, bash_script)) checkError(err) defer file.Close() file.WriteString(" file.WriteString( strings.Join(cmds, "\n")) err = os.Chdir(output_path) checkError(err) out, err := exec.Command("sh", bash_script).Output() checkError(err) fmt.Println(string(out)) } func main() { commands := []string{ "echo newline >> foo.o", "echo newline >> f1.o", "echo newline >> f2.o", } exe_cmd(commands) }
out, _ := exec.Command("sh", "-c", "date +\"%Y-%m-%d %H:%M:%S %Z\"").Output() exec.Command("sh","-c","ls -al -t | grep go >>test.txt").Output() fmt.Printf("%s\n\n",out)
package main import "fmt" import "strconv" func floattostr(input_num float64) string { return strconv.FormatFloat(input_num, } func main() { fmt.Println(floattostr(21312421.213123)) }
package main import "fmt" import "strconv" func FloatToString(input_num float64) string { return strconv.FormatFloat(input_num, } func main() { fmt.Println(FloatToString(21312421.213123)) }
package main import ( "bufio" "fmt" "os" "strings" "syscall" "golang.org/x/crypto/ssh/terminal" ) func main() { username, password := credentials() fmt.Printf("Username: %s, Password: %s\n", username, password) } func credentials() (string, string) { reader := bufio.NewReader(os.Stdin) fmt.Print("Enter Username: ") username, _ := reader.ReadString( fmt.Print("Enter Password: ") bytePassword, err := terminal.ReadPassword(int(syscall.Stdin)) if err == nil { fmt.Println("\nPassword typed: " + string(bytePassword)) } password := string(bytePassword) return strings.TrimSpace(username), strings.TrimSpace(password) }
package main import "fmt" import "github.com/howeyc/gopass" func main() { fmt.Printf("Password: ") pass := gopass.GetPasswd() }
func terminalEcho(show bool) { var termios = &syscall.Termios{} var fd = os.Stdout.Fd() if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, fd, syscall.TCGETS, uintptr(unsafe.Pointer(termios))); err != 0 { return } if show { termios.Lflag |= syscall.ECHO } else { termios.Lflag &^= syscall.ECHO } if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, fd, uintptr(syscall.TCSETS), uintptr(unsafe.Pointer(termios))); err != 0 { return } }
fmt.Print("password: ") terminalEcho(false) var pw string fmt.Scanln(&pw) terminalEcho(true) fmt.Println("")
import ( "bufio"; "fmt"; "os"; "strings"; "syscall" ) func getPassword(prompt string) string { fmt.Print(prompt) attrs := syscall.ProcAttr{ Dir: "", Env: []string{}, Files: []uintptr{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd()}, Sys: nil} var ws syscall.WaitStatus pid, err := syscall.ForkExec( "/bin/stty", []string{"stty", "-echo"}, &attrs) if err != nil { panic(err) } _, err = syscall.Wait4(pid, &ws, 0, nil) if err != nil { panic(err) } reader := bufio.NewReader(os.Stdin) text, err := reader.ReadString( if err != nil { panic(err) } pid, err = syscall.ForkExec( "/bin/stty", []string{"stty", "echo"}, &attrs) if err != nil { panic(err) } _, err = syscall.Wait4(pid, &ws, 0, nil) if err != nil { panic(err) } return strings.TrimSpace(text) }
package main import ( os "os" bufio "bufio" fmt "fmt" str "strings" ) func main() { fmt.Println(); if passwd, err := Getpasswd("Enter password: "); err == nil { fmt.Printf("\n\nPassword: } } func Getpasswd(prompt string) (passwd string, err os.Error) { fmt.Print(prompt); const stty_arg0 = "/bin/stty"; stty_argv_e_off := []string{"stty","-echo"}; stty_argv_e_on := []string{"stty","echo"}; const exec_cwdir = ""; fd := []*os.File{os.Stdin,os.Stdout,os.Stderr}; pid, err := os.ForkExec(stty_arg0,stty_argv_e_off,nil,exec_cwdir,fd); if err != nil { return passwd, os.NewError(fmt.Sprintf("Failed turning off console echo for password entry:\n\t%s",err)) } rd := bufio.NewReader(os.Stdin); os.Wait(pid,0); line, err := rd.ReadString( if err == nil { passwd = str.TrimSpace(line) } else { err = os.NewError(fmt.Sprintf("Failed during password entry: %s",err)) } pid, e := os.ForkExec(stty_arg0,stty_argv_e_on,nil,exec_cwdir,fd); if e == nil { os.Wait(pid,0) } else if err == nil { err = os.NewError(fmt.Sprintf("Failed turning on console echo post password entry:\n\t%s",e)) } return passwd, err }
import ( "fmt" "golang.org/x/crypto/ssh/terminal" ) func main() { fmt.Printf("Now, please type in the password (mandatory): ") password, _ := terminal.ReadPassword(0) fmt.Printf("Password is : %s", password) }
package main import "fmt" import "os" func main() { var input []byte = make( []byte, 100 ); os.Stdin.Read( input ); fmt.Printf( "%s", input ); }
func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte
func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error)
pemdata := pem.EncodeToMemory( &pem.Block{ Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(key), }, )
Priv := rsa.GenerateKey(rand.Reader, 4096) PubASN1, err := x509.MarshalPKIXPublicKey(&Priv.PublicKey) if err != nil { } pubBytes = pem.EncodeToMemory(&pem.Block{ Type: "RSA PUBLIC KEY", Bytes: PubASN1, }) ioutil.WriteFile("key.pub", PubBytes, 0644)
package main import ( "crypto/rand" "crypto/rsa" "crypto/x509" "encoding/pem" "errors" "fmt" ) func GenerateRsaKeyPair() (*rsa.PrivateKey, *rsa.PublicKey) { privkey, _ := rsa.GenerateKey(rand.Reader, 4096) return privkey, &privkey.PublicKey } func ExportRsaPrivateKeyAsPemStr(privkey *rsa.PrivateKey) string { privkey_bytes := x509.MarshalPKCS1PrivateKey(privkey) privkey_pem := pem.EncodeToMemory( &pem.Block{ Type: "RSA PRIVATE KEY", Bytes: privkey_bytes, }, ) return string(privkey_pem) } func ParseRsaPrivateKeyFromPemStr(privPEM string) (*rsa.PrivateKey, error) { block, _ := pem.Decode([]byte(privPEM)) if block == nil { return nil, errors.New("failed to parse PEM block containing the key") } priv, err := x509.ParsePKCS1PrivateKey(block.Bytes) if err != nil { return nil, err } return priv, nil } func ExportRsaPublicKeyAsPemStr(pubkey *rsa.PublicKey) (string, error) { pubkey_bytes, err := x509.MarshalPKIXPublicKey(pubkey) if err != nil { return "", err } pubkey_pem := pem.EncodeToMemory( &pem.Block{ Type: "RSA PUBLIC KEY", Bytes: pubkey_bytes, }, ) return string(pubkey_pem), nil } func ParseRsaPublicKeyFromPemStr(pubPEM string) (*rsa.PublicKey, error) { block, _ := pem.Decode([]byte(pubPEM)) if block == nil { return nil, errors.New("failed to parse PEM block containing the key") } pub, err := x509.ParsePKIXPublicKey(block.Bytes) if err != nil { return nil, err } switch pub := pub.(type) { case *rsa.PublicKey: return pub, nil default: break } return nil, errors.New("Key type is not RSA") } func main() { priv, pub := GenerateRsaKeyPair() priv_pem := ExportRsaPrivateKeyAsPemStr(priv) pub_pem, _ := ExportRsaPublicKeyAsPemStr(pub) priv_parsed, _ := ParseRsaPrivateKeyFromPemStr(priv_pem) pub_parsed, _ := ParseRsaPublicKeyFromPemStr(pub_pem) priv_parsed_pem := ExportRsaPrivateKeyAsPemStr(priv_parsed) pub_parsed_pem, _ := ExportRsaPublicKeyAsPemStr(pub_parsed) fmt.Println(priv_parsed_pem) fmt.Println(pub_parsed_pem) if priv_pem != priv_parsed_pem || pub_pem != pub_parsed_pem { fmt.Println("Failure: Export and Import did not result in same Keys") } else { fmt.Println("Success") } }
type T struct { Id int Name string } func Copy(a *T, b *T) error { b.Id=5 b.Name="gert" a = b return nil }
func Copy(a *T, b *T) error { b.Id = 5 b.Name = "gert" a.Id = b.Id a.Name = b.Name return nil }
import "fmt" type T struct { Id int Name string } func Copy(a *T, b *T) error { b.Id = 5 b.Name = "gert" a = b return nil } func CopyThatActuallyCopies(a *T, b *T) error { b.Id = 5 b.Name = "gert" *a = *b return nil } func main() { var a = &T{1, "one"} var b = &T{2, "two"} fmt.Println(a, b) Copy(a, b) fmt.Println(a, b) CopyThatActuallyCopies(a, b) fmt.Println(a, b) }
func CloneValue(source interface{}, destin interface{}) { x := reflect.ValueOf(source) if x.Kind() == reflect.Ptr { starX := x.Elem() y := reflect.New(starX.Type()) starY := y.Elem() starY.Set(starX) reflect.ValueOf(destin).Elem().Set(y.Elem()) } else { destin = x.Interface() } }
func (r *Request) WithContext(ctx context.Context) *Request { if ctx == nil { panic("nil context") } r2 := new(Request) *r2 = *r r2.ctx = ctx return r2 }
; Based on hello.asm from nasm SECTION .data ; data section msg: db "Hello World",10 ; the string to print, 10=cr len: equ $-msg ; "$" means "here" ; len is a value, not an address SECTION .text ; code section global go.main.hello ; make label available to linker (Go) go.main.hello: ; --- setup stack frame push rbp ; save old base pointer mov rbp,rsp ; use stack pointer as new base pointer ; --- print message mov edx,len ; arg3, length of string to print mov ecx,msg ; arg2, pointer to string mov ebx,1 ; arg1, where to write, screen mov eax,4 ; write sysout command to int 80 hex int 0x80 ; interrupt 80 hex, call kernel ; --- takedown stack frame mov rsp,rbp ; use base pointer as new stack pointer pop rbp ; get the old base pointer ; --- return mov rax,0 ; error code 0, normal, no error ret ; return
package main func hello(); func main() { hello() hello() }
main: main.go hello.o gccgo hello.o main.go -o main hello.o: hello.asm nasm -f elf64 -o hello.o hello.asm clean: rm -rf _obj *.o *~ *.6 *.gch a.out main
TEXT ·Abs(SB),NOSPLIT,$0 MOVQ $(1<<63), BX MOVQ BX, X0 MOVSD x+0(FP), X1 ANDNPD X1, X0 MOVSD X0, ret+8(FP) RET
const ( StateConnected = iota StateError StateDone internalStateMask = 0x2 )
owner := obj.Owner() if owner != user { obj.SetOwner(user) }
s := "12121211122" first3 := s[0:3] last3 := s[len(s)-3:]
s := []rune("世界世界世界") first3 := string(s[0:3]) last3 := string(s[len(s)-3:])
s := "12121211122" j := len(s) for i := 0; i < 3 && j > 0; i++ { _, size := utf8.DecodeLastRuneInString(s[:j]) j -= size } lastByRune := s[j:]
$ http_proxy=127.0.0.1:8080 go get code.google.com/p/go.crypto/bcrypt
$ graftcp-local/graftcp-local -h Usage of graftcp-local/graftcp-local: -config string Path to the configuration file -listen string Listen address (default ":2233") -logfile string Write logs to file -loglevel value Log level (0-6) (default 1) -pipepath string Pipe path for graftcp to send address info (default "/tmp/graftcplocal.fifo") -service string Control the system service: ["start" "stop" "restart" "install" "uninstall"] -socks5 string SOCKS5 address (default "127.0.0.1:1080") -syslog Send logs to the local system logger (Eventlog on Windows, syslog on Unix)
realout = sys.stdout sys.stdout = StringIO.StringIO() some_function() result = sys.stdout.getvalue() sys.stdout = realout
package main import ( "bytes" "fmt" "io" "os" ) func print() { fmt.Println("output") } func main() { old := os.Stdout r, w, _ := os.Pipe() os.Stdout = w print() outC := make(chan string) go func() { var buf bytes.Buffer io.Copy(&buf, r) outC <- buf.String() }() w.Close() os.Stdout = old out := <-outC fmt.Println("previous output:") fmt.Print(out) }
package main import ( "fmt" "io/ioutil" "os" "path/filepath" ) func print() { fmt.Println("output") } func main() { fname := filepath.Join(os.TempDir(), "stdout") fmt.Println("stdout is now set to", fname) old := os.Stdout temp, _ := os.Create(fname) os.Stdout = temp print() temp.Close() os.Stdout = old fmt.Println("previous output:") out, _ := ioutil.ReadFile(fname) fmt.Print(string(out)) }
package main import ( "bytes" "fmt" "io" "os" ) func print(w io.Writer) { fmt.Fprintln(w, "output") } func main() { fmt.Println("print with byes.Buffer:") var b bytes.Buffer print(&b) fmt.Print(b.String()) fmt.Println("print with os.Stdout:") print(os.Stdout) }
package main import ( "fmt" "io/ioutil" "os" ) func main() { rescueStdout := os.Stdout r, w, _ := os.Pipe() os.Stdout = w fmt.Println("Hello, playground") w.Close() out, _ := ioutil.ReadAll(r) os.Stdout = rescueStdout fmt.Printf("Captured: %s", out) }
a:= make([][]uint8, dy) for i:=0;i<dy;i++ { a[i] = make([]uint8, dx) }
a := make([][]uint8, dy) for i := range a { a[i] = make([]uint8, dx) }
a := [][]uint8{ {0, 1, 2, 3}, {4, 5, 6, 7}, } fmt.Println(a)
[[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]]
matrix := make([][]int, n) for i := 0; i < n; i++ { matrix[i] = make([]int, m) }
matrix := make([][]int, n) rows := make([]int, n*m) for i := 0; i < n; i++ { matrix[i] = rows[i*m : (i+1)*m] }
package main import "fmt" func main() { var row, col int fmt.Print("enter rows cols: ") fmt.Scan(&row, &col) a := make([][]int, row) for i := range a { a[i] = make([]int, col) } fmt.Println("a[0][0] =", a[0][0]) a[row-1][col-1] = 7 fmt.Printf("a[%d][%d] = %d\n", row-1, col-1, a[row-1][col-1]) a = nil }
➜ artisan git:(master) ✗ GOOS=linux GOARCH=amd64 go build
➜ artisan git:(master) ✗ ./artisan 10:14:04.925 [ERROR] artisan: need a command, one of server, provision or build
➜ artisan git:(master) ✗ cp artisan docker/build/bin/ ➜ artisan git:(master) ✗ cd docker ➜ docker git:(master) ✗ cat Dockerfile FROM docker:1.10 COPY build/ / ➜ docker git:(master) ✗ docker build -t artisan . Sending build context to Docker daemon 10.15 MB Step 1 : FROM docker:1.10 ... ➜ docker git:(master) ✗ docker run -it artisan sh / sh: /bin/artisan: not found
➜ docker git:(master) ✗ cat Dockerfile FROM phusion/baseimage COPY build/ / ➜ docker git:(master) ✗ docker build -t artisan . Sending build context to Docker daemon 10.15 MB Step 1 : FROM phusion/baseimage ... ➜ docker git:(master) ✗ docker run -it artisan sh 08:16:39.424 [ERROR] artisan: need a command, one of server, provision or build
FROM alpine:edge AS build RUN apk update RUN apk upgrade RUN apk add --update go=1.8.3-r0 gcc=6.3.0-r4 g++=6.3.0-r4 WORKDIR /app ENV GOPATH /app ADD src /app/src RUN go get server RUN CGO_ENABLED=1 GOOS=linux go install -a server FROM alpine:edge WORKDIR /app RUN cd /app COPY --from=build /app/bin/server /app/bin/server CMD ["bin/server"]
client := http.DefaultClient resp, err := client.Do(req) defer resp.Body.Close() if err != nil { return nil, err }
client := http.DefaultClient resp, err := client.Do(req) if err != nil { return nil, err } defer resp.Body.Close()
resp, err := http.Get("http: if err != nil { } defer resp.Body.Close()
client := http.DefaultClient resp, err := client.Do(req) if resp != nil { defer resp.Body.Close() } if err != nil { return nil, err }
package main type shower interface { getWater() []shower } type display struct { SubDisplay *display } func (d display) getWater() []shower { return []shower{display{}, d.SubDisplay} } func main() { s := display{} water := s.getWater() for _, x := range water { if x == nil { panic("everything ok, nil found") } x.getWater() } }
if x == (*display)(nil) { panic("everything ok, nil found") }
type MyErr string func (m MyErr) Error() string { return "big fail" } func doSomething(i int) error { switch i { default: return nil case 1: var p *MyErr return p case 2: return (*MyErr)(nil) case 3: var err error return err case 4: var p *MyErr return error(p) } } func main() { for i := 0; i <= 4; i++ { err := doSomething(i) fmt.Println(i, err, err == nil) } }
0 <nil> true 1 <nil> false 2 <nil> false 3 <nil> true 4 <nil> false
address | name | value 1000000 | a | 0 2000000 | b | 1000000
func question(anything interface{}) { switch v := anything.(type) { case string: fmt.Println(v) case int32, int64: fmt.Println(v) case SomeCustomType: fmt.Println(v) default: fmt.Println("unknown") } }
package main import ( "testing" ) type myint int64 type Inccer interface { inc() } func (i *myint) inc() { *i = *i + 1 } func BenchmarkIntmethod(b *testing.B) { i := new(myint) incnIntmethod(i, b.N) } func BenchmarkInterface(b *testing.B) { i := new(myint) incnInterface(i, b.N) } func BenchmarkTypeSwitch(b *testing.B) { i := new(myint) incnSwitch(i, b.N) } func BenchmarkTypeAssertion(b *testing.B) { i := new(myint) incnAssertion(i, b.N) } func incnIntmethod(i *myint, n int) { for k := 0; k < n; k++ { i.inc() } } func incnInterface(any Inccer, n int) { for k := 0; k < n; k++ { any.inc() } } func incnSwitch(any Inccer, n int) { for k := 0; k < n; k++ { switch v := any.(type) { case *myint: v.inc() } } } func incnAssertion(any Inccer, n int) { for k := 0; k < n; k++ { if newint, ok := any.(*myint); ok { newint.inc() } } }
$ go test -bench=. BenchmarkIntmethod 1000000000 2.71 ns/op BenchmarkInterface 1000000000 2.98 ns/op BenchmarkTypeSwitch 100000000 16.7 ns/op BenchmarkTypeAssertion 100000000 13.8 ns/op
func incnAssertionNoCheck(any Inccer, n int) { for k := 0; k < n; k++ { any.(*myint).inc() } } func BenchmarkTypeAssertionNoCheck(b *testing.B) { i := new(myint) incnAssertionNoCheck(i, b.N) }
BenchmarkIntmethod-12 2000000000 1.77 ns/op BenchmarkInterface-12 1000000000 2.30 ns/op BenchmarkTypeSwitch-12 500000000 3.76 ns/op BenchmarkTypeAssertion-12 2000000000 1.73 ns/op BenchmarkTypeAssertionNoCheck-12 2000000000 1.72 ns/op
BenchmarkIntmethod-4 1000000000 2.42 ns/op BenchmarkInterface-4 1000000000 2.84 ns/op BenchmarkTypeSwitch-4 1000000000 2.29 ns/op BenchmarkTypeAssertion-4 1000000000 2.14 ns/op BenchmarkTypeAssertionNoCheck-4 1000000000 2.34 ns/op
$ go test -bench . BenchmarkIntmethod-4 2000000000 1.99 ns/op BenchmarkInterface-4 1000000000 2.30 ns/op BenchmarkTypeSwitch-4 2000000000 1.80 ns/op BenchmarkTypeAssertion-4 2000000000 1.67 ns/op
switch v := anything.(type) { case SomeCustomType: fmt.Println(v) ...
switch anything.(type) { case SomeCustomType: fmt.Println("anything type is SomeCustomType", anything) ...
BenchmarkIntmethod-4 2000000000 1.67 ns/op BenchmarkInterface-4 2000000000 1.89 ns/op BenchmarkTypeSwitch-4 2000000000 1.26 ns/op BenchmarkTypeAssertion-4 2000000000 1.41 ns/op BenchmarkTypeAssertionNoCheck-4 2000000000 1.61 ns/op
package main import ( "testing" ) type myint0 int64 type myint1 int64 type myint2 int64 type myint3 int64 type myint4 int64 type myint5 int64 type myint6 int64 type myint7 int64 type myint8 int64 type myint9 int64 type DoStuff interface { doStuff() } func (i myint0) doStuff() { i += 0 } func (i myint1) doStuff() { i += 1 } func (i myint2) doStuff() { i += 2 } func (i myint3) doStuff() { i += 3 } func (i myint4) doStuff() { i += 4 } func (i myint5) doStuff() { i += 5 } func (i myint6) doStuff() { i += 6 } func (i myint7) doStuff() { i += 7 } func (i myint8) doStuff() { i += 8 } func (i myint9) doStuff() { i += 9 } var input []DoStuff = []DoStuff{myint0(0), myint1(0), myint1(0), myint5(0), myint6(0), myint7(0), myint6(0), myint9(0), myint7(0), myint7(0), myint6(0), myint2(0), myint9(0), myint0(0), myint2(0), myint3(0), myint5(0), myint1(0), myint4(0), myint0(0), myi nt4(0), myint3(0), myint9(0), myint3(0), myint9(0), myint5(0), myint0(0), myint0(0), myint8(0), myint1(0)} func BenchmarkInterface(b *testing.B) { doStuffInterface(b.N) } func BenchmarkTypeSwitch(b *testing.B) { doStuffSwitch(b.N) } func doStuffInterface(n int) { for k := 0; k < n; k++ { for _, in := range input { in.doStuff() } } } func doStuffSwitch(n int) { for k := 0; k < n; k++ { for _, in := range input { switch v := in.(type) { case *myint0: v.doStuff() case *myint1: v.doStuff() case *myint2: v.doStuff() case *myint3: v.doStuff() case *myint4: v.doStuff() case *myint5: v.doStuff() case *myint6: v.doStuff() case *myint7: v.doStuff() case *myint8: v.doStuff() case *myint9: v.doStuff() } } } }
go test -bench . goos: darwin goarch: amd64 pkg: test BenchmarkInterface-4 20000000 74.0 ns/op BenchmarkTypeSwitch-4 20000000 119 ns/op PASS ok test 4.067s
package main import ( "testing" ) type myint0 int64 type myint1 int64 type myint2 int64 type myint3 int64 type myint4 int64 type myint5 int64 type myint6 int64 type myint7 int64 type myint8 int64 type myint9 int64 type DoStuff interface { doStuff() } func (i myint0) doStuff() { i += 0 } func (i myint1) doStuff() { i += 1 } func (i myint2) doStuff() { i += 2 } func (i myint3) doStuff() { i += 3 } func (i myint4) doStuff() { i += 4 } func (i myint5) doStuff() { i += 5 } func (i myint6) doStuff() { i += 6 } func (i myint7) doStuff() { i += 7 } func (i myint8) doStuff() { i += 8 } func (i myint9) doStuff() { i += 9 } var randInput []DoStuff = []DoStuff{myint0(0), myint1(0), myint1(0), myint5(0), myint6(0), myint7(0), myint6(0), myint9(0), myint7(0), myint7(0), myint6(0), myint2(0), myint9(0), myint0(0), myint2(0), myint3(0), myint5(0), myint1(0), myint4(0), myint0(0), myint4(0), myint3(0), myint9(0), myint3(0), myint9(0), myint5(0), myint0(0), myint0(0), myint8(0), myint1(0)} var oneInput []DoStuff = []DoStuff{myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0), myint1(0)} func BenchmarkRandomInterface(b *testing.B) { doStuffInterface(randInput, b.N) } func BenchmarkRandomTypeSwitch(b *testing.B) { doStuffSwitch(randInput, b.N) } func BenchmarkOneInterface(b *testing.B) { doStuffInterface(oneInput, b.N) } func BenchmarkOneTypeSwitch(b *testing.B) { doStuffSwitch(oneInput, b.N) } func doStuffInterface(input []DoStuff, n int) { for k := 0; k < n; k++ { for _, in := range input { in.doStuff() } } } func doStuffSwitch(input []DoStuff, n int) { for k := 0; k < n; k++ { for _, in := range input { switch v := in.(type) { case *myint0: v.doStuff() case *myint1: v.doStuff() case *myint2: v.doStuff() case *myint3: v.doStuff() case *myint4: v.doStuff() case *myint5: v.doStuff() case *myint6: v.doStuff() case *myint7: v.doStuff() case *myint8: v.doStuff() case *myint9: v.doStuff() } } } }
BenchmarkRandomInterface-4 20000000 76.9 ns/op BenchmarkRandomTypeSwitch-4 20000000 115 ns/op BenchmarkOneInterface-4 20000000 76.6 ns/op BenchmarkOneTypeSwitch-4 20000000 68.1 ns/op
{ "name": "Cain", "parents": { "mother" : "Eve", "father" : "Adam" } }
type Person struct { Name string Parents map[string]string }
func (p *Person) Mother() string { return p.Parents["mother"] }
package main import ( "fmt" "encoding/json" ) type User struct { Name string Parents struct { Mother string Father string } } func main() { encoded := `{ "name": "Cain", "parents": { "mother": "Eve", "father": "Adam" } }` u := &User{} err := json.Unmarshal([]byte(encoded), &u) if err != nil { panic(err) } fmt.Printf("Mother: %s\n", u.Parents.Mother) fmt.Printf("Father: %s\n", u.Parents.Father) }
package main import ( "fmt" "encoding/json" ) func main() { encoded := `{ "name": "Cain", "parents": { "mother": "Eve" "father": "Adam" } }` var j map[string]interface{} err := json.Unmarshal([]byte(encoded), &j) if err != nil { panic(err) } parents := j["parents"].(map[string]interface{}) fmt.Printf("Mother: %s\n", parents["mother"].(string)) fmt.Printf("Father: %s\n", parents["father"].(string)) }
name := gjson.Get(json, "name") mother := gjson.Get(json, "parents.mother")
import ( "fmt" "encoding/json" ) type MyObject struct{ Name string Mother string } type MyParseObj struct{ Name string Parents struct { Mother string Father string } } func main() { encoded := `{ "name": "Cain", "parents": { "mother": "Eve", "father": "Adam" } }` pj := &MyParseObj{} if err := json.Unmarshal([]byte(encoded), pj); err != nil { return } final := &MyObject{Name: pj.Name, Mother: pj.Parents.Mother} fmt.Println(final) }
sudo apt-get install bzr debhelper build-essential golang-go bzr branch lp:~niemeyer/cobzr/package mypackage-build cd mypackage-build
fpm -s dir -t deb -n foobar -v 0.0.1 foobar=/usr/bin/
f := bufio.NewWriter(os.Stdout) defer f.Flush() f.Write(b)
$ cat foo.go package main func main() { a := "hello" b := "world" _ = a == b } $ go tool 6g -S foo.go --- prog list "main" --- 0000 (foo.go:3) TEXT main+0(SB),$40-0 0001 (foo.go:3) LOCALS ,$0 0002 (foo.go:4) LEAQ go.string."hello"+0(SB),BX 0003 (foo.go:4) MOVQ (BX),SI 0004 (foo.go:4) MOVQ 8(BX),CX 0005 (foo.go:5) LEAQ go.string."world"+0(SB),BX 0006 (foo.go:5) MOVQ (BX),DX 0007 (foo.go:5) MOVQ 8(BX),AX 0008 (foo.go:6) JMP ,11 0009 (foo.go:6) MOVQ $1,AX 0010 (foo.go:6) JMP ,23 0011 (foo.go:6) CMPQ CX,AX 0012 (foo.go:6) JNE ,22 0013 (foo.go:6) MOVQ SI,(SP) 0014 (foo.go:6) MOVQ CX,8(SP) 0015 (foo.go:6) MOVQ DX,16(SP) 0016 (foo.go:6) MOVQ AX,24(SP) 0017 (foo.go:6) CALL ,runtime.eqstring+0(SB) 0018 (foo.go:6) MOVBQZX 32(SP),BX 0019 (foo.go:6) CMPB BX,$0 0020 (foo.go:6) JEQ ,22 0021 (foo.go:6) JMP ,9 0022 (foo.go:6) MOVQ $0,AX 0023 (foo.go:7) RET , --- prog list "init" --- 0024 (foo.go:7) TEXT init+0(SB),$0-0 0025 (foo.go:7) MOVBQZX initdone·+0(SB),AX 0026 (foo.go:7) LOCALS ,$0 0027 (foo.go:7) CMPB AX,$0 0028 (foo.go:7) JEQ ,34 0029 (foo.go:7) CMPB AX,$2 0030 (foo.go:7) JNE ,32 0031 (foo.go:7) RET , 0032 (foo.go:7) CALL ,runtime.throwinit+0(SB) 0033 (foo.go:7) UNDEF , 0034 (foo.go:7) MOVB $2,initdone·+0(SB) 0035 (foo.go:7) RET ,
func eqstring(s1 String, s2 String) (v bool) { if(s1.len != s2.len) { v = false; return; } if(s1.str == s2.str) { v = true; return; } v = runtime·memeq(s1.str, s2.str, s1.len); } int32 runtime·strcmp(byte *s1, byte *s2) { uintptr i; byte c1, c2; for(i=0;; i++) { c1 = s1[i]; c2 = s2[i]; if(c1 < c2) return -1; if(c1 > c2) return +1; if(c1 == 0) return 0; } }
type A struct { Foo string } func (a *A) PrintFoo(){ fmt.Println("Foo value is " + a.Foo) } func main() { a := &A{Foo: "afoo"} val := reflect.Indirect(reflect.ValueOf(a)) fmt.Println(val.Field(0).Type().Name()) }
package main import "fmt" import "reflect" type A struct { Foo string } func (a *A) PrintFoo(){ fmt.Println("Foo value is " + a.Foo) } func main() { a := &A{Foo: "afoo"} val := reflect.Indirect(reflect.ValueOf(a)) fmt.Println(val.Type().Field(0).Name) }
package main import ( "fmt" "github.com/fatih/structs" ) type A struct { Foo string Bar int } func main() { names := structs.Names(&A{}) fmt.Println(names) }
func main() { a := &A{Foo: "afoo"} val := reflect.ValueOf(a).Elem() for i:=0; i<val.NumField();i++{ fmt.Println(val.Type().Field(i).Name) } }
fields := s.Fields() for _, f := range fields { fmt.Printf("field name: %+v\n", f.Name()) }
str.m.id undefined (cannot refer to unexported field or method mypackage.(*MyStruct)."".id
type MyStruct struct { id string } func (m *MyStruct) Id() { } func foo(str *MyStruct2) { str.m.Id() }
package first type MyStruct struct { id string } func (m *MyStruct) Id() string { return m.id } func NewMyStruct(id string) *MyStruct { return &MyStruct{ id: id, } }
package second import "first" type MyStruct2 struct { // *first.MyStruct } func foo(str *MyStruct2) { str.Id() } func run() { foo(&MyStruct2{ MyStruct: first.NewMyStruct("3"), }) }
package main import ( "fmt" "testing" ) func Function(n int) int64 { n64 := int64(n) return n64 * n64 } func BenchmarkFunction(b *testing.B) { n := 42 for i := 0; i < b.N; i++ { _ = Function(n) } } func main() { br := testing.Benchmark(BenchmarkFunction) fmt.Println(br) }
func trace(s string) (string, time.Time) { log.Println("START:", s) return s, time.Now() } func un(s string, startTime time.Time) { endTime := time.Now() log.Println(" END:", s, "ElapsedTime in seconds:", endTime.Sub(startTime)) }
func someFunction() { defer un(trace("SOME_ARBITRARY_STRING_SO_YOU_CAN_KEEP_TRACK")) }
func trace(s string) (string, int64) { log.Println("START:", s) return s, time.Nanoseconds() } func un(s string, startTime int64) { endTime := time.Nanoseconds() log.Println(" END:", s, "ElapsedTime in seconds:", float32(endTime-startTime)/1E9) }
func trace(s string) (string, time.Time) { log.Printf("trace start: %s\n", s) return s, time.Now() } func un(s string, startTime time.Time) { elapsed := time.Since(startTime) log.Printf("trace end: %s, elapsed %f secs\n", s, elapsed.Seconds()) }
import ( "fmt" "time" ) start := time.Now() elapsed := time.Since(start) fmt.Println(elapsed)
var a [0]int if r == a { fmt.Println("No return value") }
t, err := tail.TailFile("/var/log/nginx.log", tail.Config{Follow: true}) for line := range t.Lines { fmt.Println(line.Text) }
t, err := tail.TailFile("/var/log/nginx.log", tail.Config{ Follow: true, ReOpen: true}) for line := range t.Lines { fmt.Println(line.Text) }
-F The -F option implies the -f option, but tail will also check to see if the file being followed has been renamed or rotated. The file is closed and reopened when tail detects that the filename being read from has a new inode number. The -F option is ignored if reading from standard input rather than a file.
package main import ( "bufio" "fmt" "io" "os" "time" ) func tail(filename string, out io.Writer) { f, err := os.Open(filename) if err != nil { panic(err) } defer f.Close() r := bufio.NewReader(f) info, err := f.Stat() if err != nil { panic(err) } oldSize := info.Size() for { for line, prefix, err := r.ReadLine(); err != io.EOF; line, prefix, err = r.ReadLine() { if prefix { fmt.Fprint(out, string(line)) } else { fmt.Fprintln(out, string(line)) } } pos, err := f.Seek(0, io.SeekCurrent) if err != nil { panic(err) } for { time.Sleep(time.Second) newinfo, err := f.Stat() if err != nil { panic(err) } newSize := newinfo.Size() if newSize != oldSize { if newSize < oldSize { f.Seek(0, 0) } else { f.Seek(pos, io.SeekStart) } r = bufio.NewReader(f) oldSize = newSize break } } } } func main() { tail("x.txt", os.Stdout) }
watcher, err := fsnotify.NewWatcher() if err != nil { log.Fatal(err) } done := make(chan bool) err = watcher.Add(fileName) if err != nil { log.Fatal(err) } for { select { case event := <-watcher.Events: if event.Op&fsnotify.Write == fsnotify.Write { log.Println("modified file:", event.Name) } }
Context {{.}} After {{.}} O <a title= <a href="/{{.}}"> O&
import "encoding/binary" const SIZEOF_INT32 = 4 data := make([]int32, len(raw)/SIZEOF_INT32) for i := range data { data[i] = int32(binary.LittleEndian.Uint32(raw[i*SIZEOF_INT32:(i+1)*SIZEOF_INT32])) }
import ( "reflect" "unsafe" ) const SIZEOF_INT32 = 4 header := *(*reflect.SliceHeader)(unsafe.Pointer(&raw)) header.Len /= SIZEOF_INT32 header.Cap /= SIZEOF_INT32 data := *(*[]int32)(unsafe.Pointer(&header))
package main import ( "fmt" "unsafe" ) func main() { b := []byte{1, 0, 0, 0, 2, 0, 0, 0} pb := &b[0] up := unsafe.Pointer(pb) pi := (*[2]uint32)(up) i := (*pi)[:] fmt.Printf("b=%v i=%v\n", b, i) p := (*[2]uint32)(unsafe.Pointer(&b[0])) fmt.Printf("b=%v p=%v\n", b, p) }
package main import ( "fmt" "strings" ) func main() { s := []interface{}{"foo", "bar", "baz"} b := make([]string, len(s)) for i, v := range s { b[i] = v.(string) } fmt.Println(strings.Join(b, ", ")) }
package main import ( "fmt" "unsafe" ) func main() { var b [8]byte = [8]byte{1, 2, 3, 4, 5, 6, 7, 8} var s *[4]uint16 = (*[4]uint16)(unsafe.Pointer(&b)) var i *[2]uint32 = (*[2]uint32)(unsafe.Pointer(&b)) var l *uint64 = (*uint64)(unsafe.Pointer(&b)) fmt.Println(b) fmt.Printf("%04x, %04x, %04x, %04x\n", s[0], s[1], s[2], s[3]) fmt.Printf("%08x, %08x\n", i[0], i[1]) fmt.Printf("%016x\n", *l) } /* * example run: * $ go run /tmp/test.go * [1 2 3 4 5 6 7 8] * 0201, 0403, 0605, 0807 * 04030201, 08070605 * 0807060504030201 */
s := "hello" if s[1] != os.Exit(1) } s = "good bye" var p *string = &s *p = "ciao"
*p = "ciao" p = &t var r **string = &p w := ( r == &p) w = ( *r == p ) w = (**r == t ) n := &*p o := *&t y := &v z := (*y)[0]
package main import ( "fmt" ) func main() { var y int fmt.Println(y) fmt.Println(&y) var x *int x = &y fmt.Println(x) fmt.Println(&x) fmt.Println(*x) *x = 1; y = 1 fmt.Println(y); fmt.Println(*x) }
client := &http.Client{} client.SetProxy("someip:someport") resp, err := client.Get("http:
proxyUrl, err := url.Parse("http: myClient := &http.Client{Transport: &http.Transport{Proxy: http.ProxyURL(proxyUrl)}}
proxyUrl, err := url.Parse("http: http.DefaultTransport = &http.Transport{Proxy: http.ProxyURL(proxyUrl)}
os.Setenv("HTTP_PROXY", "http: resp, err := http.Get("http: if err != nil { panic(err) }
url_i := url.URL{} url_proxy, _ := url_i.Parse(proxy_addr) transport := http.Transport{} transport.Proxy = http.ProxyURL(url_proxy) transport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true} client := &http.Client{} client.Transport = transport resp, err := client.Get("http:
request := gorequest.New() resp, body, errs:= request.Proxy("http: resp2, body2, errs2 := request.Proxy("http:
request := gorequest.New().Proxy("http: resp, body, errs:= request.Get("http: resp2, body2, errs2 := request.Get("http:
package mypackage type mytype struct { size string hash uint32 } func (r *mytype) doPrivate() string { return r.size } func (r *mytype) Do() string { return doPrivate("dsdsd") }
package main type mytype struct { size string hash uint32 } type myinterface interface { do() string } func newMytype(size string, hash uint32) myinterface { return &mytype{size, hash} } func (r *mytype) doPrivate() string { return r.size } func (r *mytype) do() string { return r.doPrivate() } func main() { t := newMytype("100", 100) t.do() t2:= myinterface(&mytype{"100", 100}) t2.do() }
func serve(ch <-chan SomeType) { } func serve(ch chan<- SomeType) { }
chan <- writing to channel (output channel) <- chan reading from channel (input channel) chan read from or write to channel (input/output channel)
type Sender struct { BankCode string Name string Contact struct { Name string Phone string } }
s := &Sender{ BankCode: "BC", Name: "NAME", Contact { Name: "NAME", Phone: "PHONE", }, }
mixture of field:value and value initializers undefined: Contact
s := &Sender{ BankCode: "BC", Name: "NAME", Contact: Contact { Name: "NAME", Phone: "PHONE", }, }
s := &Sender{ BankCode: "BC", Name: "NAME", Contact: struct { Name string Phone string }{ Name: "NAME", Phone: "PHONE", }, }
type Sender struct { BankCode string Name string Contact } type Contact struct { Name string Phone string }
type NameType struct { First string Last string } type UserType struct { NameType Username string } user := UserType{NameType{"Eduardo", "Nunes"}, "esnunes"} user := UserType{ NameType: NameType{ First: "Eduardo", Last: "Nunes", }, Username: "esnunes", }
189 func Write(w io.Writer, order ByteOrder, data interface{}) error { 190 191 var b [8]byte 192 var bs []byte 193 switch v := data.(type) { 194 case *int8: 195 bs = b[:1] 196 b[0] = byte(*v) 197 case int8: 198 bs = b[:1] 199 b[0] = byte(v) 200 case *uint8: 201 bs = b[:1] 202 b[0] = *v ...
package main import ( "encoding/binary" "fmt" ) func main() { bs := make([]byte, 4) binary.LittleEndian.PutUint32(bs, 31415926) fmt.Println(bs) }
package main import ( "fmt" "strconv" ) func main() { bs := []byte(strconv.Itoa(31415926)) fmt.Println(bs) }
buf := new(bytes.Buffer) var num uint16 = 1234 err := binary.Write(buf, binary.LittleEndian, num) if err != nil { fmt.Println("binary.Write failed:", err) } fmt.Printf("% x", buf.Bytes())
var typeRegistry = make(map[string]reflect.Type) func init() { typeRegistry["MyString"] = reflect.TypeOf(MyString{}) ... }
func makeInstance(name string) interface{} { v := reflect.New(typeRegistry[name]).Elem() return v.Interface() }
package main import "fmt" type foo struct { a int } var factory map[string]interface{} = map[string]interface{}{ "foo": foo{}, "foo.with.val": foo{2}, } func main() { foo1 := factory["foo"] foo2 := factory["foo"] fmt.Println("foo1", &foo1, foo1) fmt.Println("foo2", &foo2, foo2) foowv1 := factory["foo.with.val"].(foo) foowv1.a = 123 foowv2 := factory["foo.with.val"] fmt.Println("foowv1", &foowv1, foowv1) fmt.Println("foowv2", &foowv2, foowv2) }
package main import ( "fmt" "reflect" ) var typeRegistry = make(map[string]reflect.Type) func registerType(typedNil interface{}) { t := reflect.TypeOf(typedNil).Elem() typeRegistry[t.PkgPath() + "." + t.Name()] = t } type MyString string type myString string func init() { registerType((*MyString)(nil)) registerType((*myString)(nil)) } func makeInstance(name string) interface{} { return reflect.New(typeRegistry[name]).Elem().Interface() } func main() { for k := range typeRegistry { fmt.Println(k) } fmt.Printf("%T\n", makeInstance("main.MyString")) fmt.Printf("%T\n", makeInstance("main.myString")) }
package main import "fmt" type Human struct { name string age int phone string } type Employee struct { Human company string } func (h *Human) SayHi() { fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone) } func (e *Employee) SayHi() { fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name, e.company, e.phone) } func main() { sam := Employee{Human{"Sam", 45, "111-888-XXXX"}, "Golang Inc"} sam.SayHi() }
sam := Employee{Human{"Sam", 45, "111-888-XXXX"}, "Golang Inc"} sam.SayHi() sam.Human.SayHi()
Hi, I am Sam, I work at Golang Inc. Call me on 111-888-XXXX Hi, I am Sam you can call me on 111-888-XXXX
type Person struct { name string age int } func main() { x := Person{"Andy Capp", 98} x.age = 99 fmt.Printf("age: %d\n", x.age) }
type Person struct { name string age int } type People map[string]Person func main() { p := make(People) p["HM"] = Person{"Hank McNamara", 39} p["HM"].age = p["HM"].age + 1 fmt.Printf("age: %d\n", p["HM"].age) }
package main import "fmt" type Person struct { name string age int } type People map[string]*Person func main() { p := make(People) p["HM"] = &Person{"Hank McNamara", 39} p["HM"].age += 1 fmt.Printf("age: %d\n", p["HM"].age) }
buf, _ := ioutil.ReadAll(r.Body) rdr1 := ioutil.NopCloser(bytes.NewBuffer(buf)) rdr2 := ioutil.NopCloser(bytes.NewBuffer(buf)) doStuff(rdr1) r.Body = rdr2
package main import ( "database/sql" "fmt" _ "github.com/go-sql-driver/mysql" "github.com/gorilla/mux" "log" "net/http" ) func main() { fmt.Println("starting up") db, err := sql.Open("mysql", "root:@/mydb?charset=utf8") if err != nil { log.Fatalf("Error opening database: %v", err) } db.SetMaxIdleConns(100) r := mux.NewRouter() r.HandleFunc("/", HomeHandler) http.Handle("/", r) http.ListenAndServe(":8080", nil) } func HomeHandler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "home") }
package main import ( "database/sql" "fmt" "github.com/gorilla/mux" _ "github.com/go-sql-driver/mysql" "log" "net/http" ) var db *sql.DB func main() { fmt.Println("starting up") var err error db, err = sql.Open("mysql", "root@unix(/tmp/mysql.sock)/mydb") if err != nil { log.Fatalf("Error on initializing database connection: %s", err.Error()) } db.SetMaxIdleConns(100) err = db.Ping() if err != nil { log.Fatalf("Error on opening database connection: %s", err.Error()) } r := mux.NewRouter() r.HandleFunc("/", HomeHandler) http.Handle("/", r) http.ListenAndServe(":8080", nil) } func HomeHandler(w http.ResponseWriter, r *http.Request) { var msg string err := db.QueryRow("SELECT msg FROM hello WHERE page=?", "home").Scan(&msg) if err != nil { fmt.Fprintf(w, "Database Error!") } else { fmt.Fprintf(w, msg) } }
[1,2,3] & [4,5] [1,2] & [3,4] & [5] [1,2] & [3,4,5] [1,2] & [3,4] & [5]
Function Main Cm ← ∅ Clique(∅,V) return Cm End function Main Function Clique(set C, set P) if (|C| > |Cm|) then Cm ← C End if if (|C|+|P|>|Cm|)then for all p ∈ P in predetermined order, do P ← P \ {p} Cp ←C ∪ {p} Pp ←P ∩ N(p) Clique(Cp,Pp) End for End if End function Clique
package main import ( "bufio" "fmt" "sort" "strconv" "strings" ) var adjmatrix map[int]map[int]int = make(map[int]map[int]int) var Cm []int = make([]int, 0) var frequency int type resoult [][]int var res resoult var filter map[int]bool = make(map[int]bool) var bf int func (r resoult) Less(i, j int) bool { return len(r[i]) > len(r[j]) } func (r resoult) Swap(i, j int) { r[i], r[j] = r[j], r[i] } func (r resoult) Len() int { return len(r) } func Clique(C []int, P map[int]bool) { if len(C) >= len(Cm) { Cm = make([]int, len(C)) copy(Cm, C) } if len(C)+len(P) >= len(Cm) { for k, _ := range P { delete(P, k) Cp := make([]int, len(C)+1) copy(Cp, append(C, k)) Pp := make(map[int]bool) for n, m := range adjmatrix[k] { _, ok := P[n] if ok && m >= frequency { Pp[n] = true } } Clique(Cp, Pp) res = append(res, Cp) bf := 0 for _, v := range Cp { bf += 1 << uint(v) } _, ok := filter[bf] if !ok { filter[bf] = true res = append(res, Cp) } } } } func main() { var toks []string var numbers []int var number int StrReader := strings.NewReader(`1,2,3 4,3,5 4,1,6 4,2,7 4,1,7 2,1,3 5,1,2 3,6`) scanner := bufio.NewScanner(StrReader) for scanner.Scan() { toks = strings.Split(scanner.Text(), ",") numbers = []int{} for _, v := range toks { number, _ = strconv.Atoi(v) numbers = append(numbers, number) } for k, v := range numbers { for _, m := range numbers[k:] { _, ok := adjmatrix[v] if !ok { adjmatrix[v] = make(map[int]int) } _, ok = adjmatrix[m] if !ok { adjmatrix[m] = make(map[int]int) } if m != v { adjmatrix[v][m]++ adjmatrix[m][v]++ if adjmatrix[v][m] > frequency { frequency = adjmatrix[v][m] } } } } } P1 := make(map[int]bool) for ; frequency > 0; frequency-- { for k, _ := range adjmatrix { P1[k] = true } Cm = make([]int, 0) res = make(resoult, 0) Clique(make([]int, 0), P1) sort.Sort(res) fmt.Print(frequency, "x-times ", res, " ") } }
Number of edges between pairs of vertices: 2 edges: (1, 2) (1, 3) (2, 3) (3, 4) 1 edge: (1, 4) (2, 4) (3, 5) (4, 5) Number of cliques in which a vertex appears: 3 cliques: 3 2 cliques: 1 2 4 1 clique: 5
package main import ( "bufio" "fmt" "os" "strconv" "strings" ) func main() { reader := bufio.NewReader(os.Stdin) writer := bufio.NewWriter(os.Stdout) defer writer.Flush() line, err := reader.ReadString( if err != nil { fmt.Fprintf(os.Stderr, "Error reading first line: %s\n", err) return } var numVertices, numCliques int numScanned, err := fmt.Sscanf(line, "%d %d", &numVertices, &numCliques) if numScanned != 2 || err != nil { fmt.Fprintf(os.Stderr, "Error parsing input parameters: %s\n", err) return } edgeCounts := make([][]int, numVertices+1) for u := 1; u <= numVertices; u++ { edgeCounts[u] = make([]int, numVertices+1) } vertexCounts := make([]int, numVertices+1) for c := 0; c < numCliques; c++ { line, err = reader.ReadString( if err != nil { fmt.Fprintf(os.Stderr, "Error reading clique: %s\n", err) return } tokens := strings.Split(strings.TrimSpace(line), " ") clique := make([]int, len(tokens)) for i, token := range tokens { u, err := strconv.Atoi(token) if err != nil { fmt.Fprintf(os.Stderr, "Atoi error: %s\n", err) return } vertexCounts[u]++ clique[i] = u for j := 0; j < i; j++ { v := clique[j] edgeCounts[u][v]++ edgeCounts[v][u]++ } } } count2edges := make([][][]int, numCliques+1) for u := 1; u < numVertices; u++ { for v := u + 1; v <= numVertices; v++ { count := edgeCounts[u][v] count2edges[count] = append(count2edges[count], []int{u, v}) } } writer.WriteString("Number of edges between pairs of vertices:\n") for count := numCliques; count >= 1; count-- { edges := count2edges[count] if len(edges) == 0 { continue } label := "edge" if count > 1 { label += "s:" } else { label += ": " } writer.WriteString(fmt.Sprintf("%5d %s", count, label)) for _, edge := range edges { writer.WriteString(fmt.Sprintf(" (%d, %d)", edge[0], edge[1])) } writer.WriteString("\n") } count2vertices := make([][]int, numCliques+1) for u := 1; u <= numVertices; u++ { count := vertexCounts[u] count2vertices[count] = append(count2vertices[count], u) } writer.WriteString("\nNumber of cliques in which a vertex appears:\n") for count := numCliques; count >= 1; count-- { vertices := count2vertices[count] if len(vertices) == 0 { continue } label := "clique" if count > 1 { label += "s:" } else { label += ": " } writer.WriteString(fmt.Sprintf("%5d %s", count, label)) for _, u := range vertices { writer.WriteString(fmt.Sprintf(" %d", u)) } writer.WriteString("\n") } }
|1|2|3|4|5|6| - numers as array positions ============== *1|1|1|1|1|0|0| *1 *2|0|0|1|1|1|0| *2 *4|1|1|1|0|0|0| *4 ============== +|2|2|3|2|1|0 - just a counters of occurence *|5|5|7|3|2|0 - so for first column number 1 mask will be: 1*1+1*4 = 5
function grps(a) { var r = []; var sum = []; var mask = []; var max = 0; var val; for (i=0; i < a.length; i++) { for (j=0; j < a[i].length; j++) { val = a[i][j]; sum[val] = sum[val]?sum[val]+1:1; mask[val] = mask[val]?mask[val]+Math.pow(2, i):1; if (val > max) { max = val; } } } for (j = 0; j < max; j++){ for (i = 0; i < max; i++){ r[sum[j]][mask[j]] = j; } } return r; }
func main() { if err := run(); err != nil { fmt.Fprintf(os.Stderr, "error: %v\n", err) os.Exit(1) } } func run() error { err := something() if err != nil { return err } }
func run() int { return 1 } func main() { os.Exit(run()) }
package main import "os" func main() { os.Exit(1) }
package pkg import ( "fmt" ) func SayHI(){ fmt.Println("this is t1") }
package pkg import ( "testing" ) func TestXYZ(t *testing.T) { SayHI() }
jnml@fsc-r630:~/src/pkg$ go help test usage: go test [-c] [-i] [build flags] [packages] [flags for test binary] It prints a summary of the test results in the format: ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... followed by detailed output for each failed package. the file pattern "*_test.go". These additional files can contain test functions, benchmark functions, and example functions. See By default, go test needs no arguments. It compiles and tests the package with source in the current directory, including tests, and runs the tests. The package is built in a temporary directory so it does not interfere with the non-test installation. In addition to the build flags, the flags handled by -c Compile the test binary to pkg.test but do not run it. -i Install packages that are dependencies of the test. Do not run the test. The test binary also accepts flags that control execution of the test; these flags are also accessible by For more about build flags, see For more about specifying packages, see See also: go build, go vet. jnml@fsc-r630:~/src/pkg$
type A struct { MemberA string } type B struct { A MemberB string }
b := B { MemberA: "test1", MemberB: "test2", } fmt.Printf("%+v\n", b)
b := B { A: A{MemberA: "test1"}, MemberB: "test2", }
package main import "fmt" type A struct { MemberA string } type B struct { MemA A MemberB string } func main() { b := B{MemA: A{MemberA: "test1"}, MemberB: "test2"} fmt.Println(b.MemberB) }
package main import ( "io" "net/http" "github.com/nytimes/gziphandler" ) func main() { withoutGz := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Header().Set("Content-Type", "text/plain") io.WriteString(w, "Hello, World") }) withGz := gziphandler.GzipHandler(withoutGz) http.Handle("/", withGz) http.ListenAndServe("0.0.0.0:8000", nil) }
if _, err := os.Stat(path); os.IsNotExist(err) { os.Mkdir(path, mode) }
import( "os" "path/filepath" ) newpath := filepath.Join(".", "public") os.MkdirAll(newpath, os.ModePerm)
package main import ( "fmt" "time" ) func main() { go forever() fmt.Scanln() } func forever() { for ; ; { fmt.Printf("%v+\n", time.Now()) time.Sleep(time.Second) } }
var goroutineDelta = make(chan int) func main() { go forever() numGoroutines := 0 for diff := range goroutineDelta { numGoroutines += diff if numGoroutines == 0 { os.Exit(0) } } } func forever() { for { if needToCreateANewGoroutine { goroutineDelta <- +1 go f() } } } func f() { goroutineDelta <- -1 }
var wg sync.WaitGroup func main() { wg.Add(1) go f() go forever() wg.Wait() } func forever() { for { if needToCreateANewGoroutine { wg.Add(1) go f() } } } func f() { wg.Done() }
package main import ( "fmt" "time" ) func main() { go forever() select {} } func forever() { for { fmt.Printf("%v+\n", time.Now()) time.Sleep(time.Second) } }
package main import ( "fmt" "runtime" "time" ) func main() { go func() { time.Sleep(time.Second) fmt.Println("Go 1") }() go func() { time.Sleep(time.Second * 2) fmt.Println("Go 2") }() runtime.Goexit() fmt.Println("Exit") }
package main import ( "fmt" "time" ) func main() { done := make(chan bool) go forever() <-done } func forever() { for { fmt.Printf("%v+\n", time.Now()) time.Sleep(time.Second) } }
mdi, err := page.Metadata() fmt.Println(mdi["title"])
title, ok := mdi["title"].(string) checkOk(ok) fmt.Println(title)
mdi, err := page.Metadata() md, ok := mdi.(map[string]interface{}) fmt.Println(md["title"])
package main import "fmt" type SomeCustomType map[string]interface{} func PageData() SomeCustomType { return SomeCustomType{"bar": "baz"} } func main() { fmt.Printf("%+v\n", PageData()) }
type Environment struct{ parent Environment symbol string value RCFAEValue } func (env Environment) lookup(lookupSymbol string) RCFAEValue{ if lookupSymbol == env.symbol{ return env.value } return env.parent.lookup(lookupSymbol) }
Environment{fun_Val.ds,fun_Val.param,exp.arg_exp.interp(env)}
type Environment struct { parent *Environment symbol string value RCFAEValue }
Environment{&fun_Val.ds, fun_Val.param, exp.arg_exp.interp(env)}
Environment{&fun_Val.ds,fun_Val.param,exp.arg_exp.interp(env)}
package bridge import "fmt" import "C" func Run() { fmt.Printf("Invoking c library...\n") C.x(10) fmt.Printf("Done\n") }
/var/folders/.../bridge.a(bridge.cgo2.o)(__TEXT/__text): x: not defined
/var/folders/rg/hj4s3qlj3sz1d1b5p50ws0vc0000gn/T/go-build442792776/bridge/_obj/_cgo_.o: 0000000100001048 S _NXArgc 0000000100001050 S _NXArgv 0000000100001060 S ___progname 0000000100000dc0 T __cgo_2d7eefe3d6d4_Cfunc_x 0000000100000da0 T __cgo_allocate 0000000100000db0 T __cgo_panic 0000000100000000 T __mh_execute_header 0000000100000d90 T _crosscall2 0000000100001058 S _environ U _exit 0000000100000d80 T _main U _puts 0000000100001000 s _pvars 0000000100000de0 T _x <------- Exists U dyld_stub_binder 0000000100000d40 T start
/var/folders/rg/hj4s3qlj3sz1d1b5p50ws0vc0000gn/T/go-build442792776/bridge.a(bridge.cgo2.o): 0000000000000368 s EH_frame0 0000000000000000 T __cgo_2d7eefe3d6d4_Cfunc_x 0000000000000380 S __cgo_2d7eefe3d6d4_Cfunc_x.eh U _x
int x(int y) { printf("Hello World\n"); return y; }
dougs-mini:go doug$ go run test.go ld: library not found for -l/Users/doug/projects/c/go-bridge/build/libgb.a collect2: ld returned 1 exit status dougs-mini:go doug$ ls -l /Users/doug/projects/c/go-bridge/build/libgb.a -rw-r--r-- 1 doug staff 872 25 May 14:02 /Users/doug/projects/c/go-bridge/build/libgb.a
dougs-mini:go doug$ go build -work -x test.go WORK=/var/folders/rg/hj4s3qlj3sz1d1b5p50ws0vc0000gn/T/go-build354497708 mkdir -p $WORK/bridge/_obj/ cd /Users/doug/projects/c/go-bridge/go/src/bridge /Users/doug/projects/go/go/pkg/tool/darwin_amd64/cgo -objdir $WORK/bridge/_obj/ -- -I/Users/doug/projects/c/go-bridge/include -I $WORK/bridge/_obj/ bridge.go /Users/doug/projects/go/go/pkg/tool/darwin_amd64/6c -FVw -I $WORK/bridge/_obj/ -I /Users/doug/projects/go/go/pkg/darwin_amd64 -o $WORK/bridge/_obj/_cgo_defun.6 -DGOOS_darwin -DGOARCH_amd64 $WORK/bridge/_obj/_cgo_defun.c gcc -I . -g -O2 -fPIC -m64 -pthread -fno-common -I/Users/doug/projects/c/go-bridge/include -I $WORK/bridge/_obj/ -o $WORK/bridge/_obj/_cgo_main.o -c $WORK/bridge/_obj/_cgo_main.c gcc -I . -g -O2 -fPIC -m64 -pthread -fno-common -I/Users/doug/projects/c/go-bridge/include -I $WORK/bridge/_obj/ -o $WORK/bridge/_obj/_cgo_export.o -c $WORK/bridge/_obj/_cgo_export.c gcc -I . -g -O2 -fPIC -m64 -pthread -fno-common -I/Users/doug/projects/c/go-bridge/include -I $WORK/bridge/_obj/ -o $WORK/bridge/_obj/bridge.cgo2.o -c $WORK/bridge/_obj/bridge.cgo2.c gcc -I . -g -O2 -fPIC -m64 -pthread -fno-common -o $WORK/bridge/_obj/_cgo_.o $WORK/bridge/_obj/_cgo_main.o $WORK/bridge/_obj/_cgo_export.o $WORK/bridge/_obj/bridge.cgo2.o -l/Users/doug/projects/c/go-bridge/build/libgb.a ld: library not found for -l/Users/doug/projects/c/go-bridge/build/libgb.a collect2: ld returned 1 exit status
gcc -I . -g -O2 -fPIC -m64 -pthread -fno-common -o ... -l/path/libgb.a
gcc -I . -g -O2 -fPIC -m64 -pthread -fno-common -o ... /path/libgb.a
CGO_ENABLED=0 go build -a -installsuffix cgo -ldflags
$ cat >toto.c int x( int y ) { return y+1; } $ cat >toto.h int x(int); $ gcc -O2 -c toto.c $ ar q libgb.a toto.o $ cat >test.go package main import "fmt" import "C" func main() { fmt.Printf("Invoking c library...\n") fmt.Println("Done ", C.x(10) ) } $ go build test.go $ ./test Invoking c library... Done 11
static: gcc -c gb.c ar -rcs libgb.a gb.o go build -ldflags "-linkmode external -extldflags -static" bridge.go dynamic: gcc -shared -o libgb.so gb.c go build bridge.go
{{ if !.loggedIn }} <h1>Not logged in</h1> {{ end }}
{{ if not .loggedIn }} <h1>Not logged in</h1> {{ end }}
var numbers []float64 for _, elem := range str_numbers { i, err := strconv.ParseFloat(elem, 64) if err != nil { numbers = append(numbers, i) } } fmt.Println(numbers)
testing: warning: no tests to run PASS BenchmarkGoLogging-4 1000000 2068 ns/op BenchmarkGoLoggingNullBackend-4 5000000 308 ns/op BenchmarkGoLoggingNullBackendWithFancyFormatter-4 3000000 435 ns/op BenchmarkGoLoggingOffLevel-4 20000000 109 ns/op BenchmarkGoLoggingNullBackendAndOffLevel-4 20000000 108 ns/op BenchmarkGoLoggingNullBackendWithFancyFormatterAndOffLevel-4 20000000 109 ns/op BenchmarkLog15-4 200000 7359 ns/op BenchmarkLog15WithDiscardHandler-4 2000000 922 ns/op BenchmarkLog15WithDiscardHandlerAndOffLevel-4 2000000 926 ns/op BenchmarkLog15WithNopLogger-4 20000000 108 ns/op BenchmarkLog15WithNopLoggerDiscardHandlerA-4 20000000 112 ns/op BenchmarkLog15WithNopLoggerAndDiscardHandlerAndOffLevel-4 20000000 112 ns/op BenchmarkLog-4 1000000 1217 ns/op BenchmarkLogIoDiscardWriter-4 2000000 724 ns/op BenchmarkLogIoDiscardWriterWithoutFlags-4 3000000 543 ns/op BenchmarkLogCustomNullWriter-4 2000000 731 ns/op BenchmarkLogCustomNullWriterWithoutFlags-4 3000000 549 ns/op BenchmarkNopLogger-4 20000000 113 ns/op BenchmarkNopLoggerWithoutFlags-4 20000000 112 ns/op BenchmarkLogrus-4 300000 3832 ns/op BenchmarkLogrusWithDiscardWriter-4 500000 3032 ns/op BenchmarkLogrusWithNullFormatter-4 500000 3814 ns/op BenchmarkLogrusWithPanicLevel-4 500000 3872 ns/op BenchmarkLogrusWithDiscardWriterAndPanicLevel-4 500000 3085 ns/op BenchmarkLogrusWithDiscardWriterAndNullFormatterAndPanicLevel-4 500000 3064 ns/op ok log-benchmarks 51.378s go test -bench . 62.17s user 3.90s system 126% cpu 52.065 total
import ( "log" "io/ioutil" ) func init() { log.SetOutput(ioutil.Discard) }
type NullWriter int func (NullWriter) Write([]byte) (int, error) { return 0, nil } log.SetOutput(new(NullWriter))
type LogWriter struct{ enabled bool } func (l *LogWriter) Enable() { l.enabled = true } func (l *LogWriter) Disable() { l.enabled = false } func (l *LogWriter) Write([]byte) (int, error) { if l.enabled { } return 0, nil }
type LogWriter struct{} func (l *LogWriter) Write([]byte) (int, error) { if some.Constant { } return 0, nil }
type LogWriter struct{ io.Writer } func (w *LogWriter) Enable() { w.Writer = os.Stdout } func (w *LogWriter) Disable() { w.Writer = ioutil.Discard }
cd ./vendor/github.com/mattn/go-sqlite3/ go install
sudo rm -rf $GOPATH cd yourproject go get -d go get -u -v github.com/mattn/go-sqlite3
package main import ( "time" "fmt" ) func main(){ fmt.Println(time.Now().Format(time.RFC3339)) }
package main import ( "fmt" "time" ) func main() { fmt.Println(time.Now().UTC().Format("2006-01-02T15:04:05-0700")) }
func (t *Template) Delims(left, right string) *Template
func (t Trans) TicketQty() (intQty int, err string) { defer func() { str := recover() if(str != nil){ err = "an error" } }() Qty := t.TransObject["qty"].(map[string] interface{})["ticket fv"].(float64) intQty = 10 return }
package main import ( "errors" "fmt" ) func assertFloat64(n interface{}) error { f, ok := n.(float64) if ok { fmt.Printf("%f is float64\n", f) return nil } return errors.New(fmt.Sprintf("could not assert that \"%v\" is float64.\n", n)) } func main() { err := assertFloat64(1024.0) if err != nil { fmt.Println(err) } err = assertFloat64("foo") if err != nil { fmt.Println(err) } }
func (t Trans) TicketQty() (intQty int, err error) { defer func() { ex := recover() if(ex != nil){ err = fmt.Errorf("%v", ex) } }() ... return }
package main import "fmt" func main() { fmt.Println(a) fmt.Println(b) }
package main import ( "io" "io/ioutil" "os" "strings" ) func main() { fs, _ := ioutil.ReadDir(".") out, _ := os.Create("textfiles.go") out.Write([]byte("package main \n\nconst (\n")) for _, f := range fs { if strings.HasSuffix(f.Name(), ".txt") { out.Write([]byte(strings.TrimSuffix(f.Name(), ".txt") + " = `")) f, _ := os.Open(f.Name()) io.Copy(out, f) out.Write([]byte("`\n")) } } out.Write([]byte(")\n")) }
main.go main scripts/includetxt.go textfiles.go a.txt b.txt
package main import "fmt" func main() { const text = ` Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur. Donec ut libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean ut gravida lorem. Ut turpis felis, pulvinar a semper sed, adipiscing id dolor. Pellentesque auctor nisi id magna consequat sagittis. Curabitur dapibus enim sit amet elit pharetra tincidunt feugiat nisl imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros. Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est. ` fmt.Println(text) }
package main import ( _ "./statik" "github.com/rakyll/statik/fs" ) func statikFile() {
s, _ := fs.New() f, _ := s.Open("/tmpl/login.html") b, _ := ioutil.ReadAll(f) t, _ := template.New("login").Parse(string(b)) t.Execute(w, nil) }
import argparse parser = argparse.ArgumentParser(description="something") parser.add_argument("-getList1",nargs= parser.add_argument("-getList2",nargs=
package main import "flag" type arrayFlags []string func (i *arrayFlags) String() string { return "my string representation" } func (i *arrayFlags) Set(value string) error { *i = append(*i, value) return nil } var myFlags arrayFlags func main() { flag.Var(&myFlags, "list1", "Some description for this param.") flag.Parse() }
package main import ( "flag" "fmt" ) var one string func main() { flag.StringVar(&one, "o", "default", "arg one") flag.Parse() tail := flag.Args() fmt.Printf("Tail: %+q\n", tail) }
package main import ( "fmt" "os" "os/exec" "runtime" "time" ) var clear map[string]func() func init() { clear = make(map[string]func()) clear["linux"] = func() { cmd := exec.Command("clear") cmd.Stdout = os.Stdout cmd.Run() } clear["windows"] = func() { cmd := exec.Command("cmd", "/c", "cls") cmd.Stdout = os.Stdout cmd.Run() } } func CallClear() { value, ok := clear[runtime.GOOS] if ok { value() } else { panic("Your platform is unsupported! I can } } func main() { fmt.Println("I will clean the screen in 2 seconds!") time.Sleep(2 * time.Second) CallClear() fmt.Println("I }
package main import ( tm "github.com/buger/goterm" "time" ) func main() { tm.Clear() for { tm.MoveCursor(1, 1) tm.Println("Current Time:", time.Now().Format(time.RFC1123)) tm.Flush() time.Sleep(time.Second) } }
c := exec.Command("clear") c.Stdout = os.Stdout c.Run()
package main import ( "fmt" "time" "github.com/inancgumus/screen" ) func main() { screen.Clear() for { screen.MoveTopLeft() fmt.Println(time.Now()) time.Sleep(time.Second) } }
package main import "fmt" type Foo int func (f Foo) Bar() { fmt.Printf("My receiver is %v\n", f) } func main() { a := Foo(46) a.Bar() b := Foo(51) Foo.Bar(b) }
func (w *ChunkWriter) Write(recId uint32, msg []byte) (recs uint64, err error) { recs = w.chunk.Records err = w.handle.Write(recId, msg) if err == nil { recs++ w.chunk.Records = recs } return }
type MyResponseWriter struct { http.ResponseWriter buf *bytes.Buffer } func (mrw *MyResponseWriter) Write(p []byte) (int, error) { return mrw.buf.Write(p) }
func loginmw(handler http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { body, err := ioutil.ReadAll(r.Body) if err != nil { log.Printf("Error reading body: %v", err) http.Error(w, "can return } r.Body = ioutil.NopCloser(bytes.NewBuffer(body)) mrw := &MyResponseWriter{ ResponseWriter: w, buf: &bytes.Buffer{}, } handler.ServeHTTP(mrw, r) if _, err := io.Copy(w, mrw.buf); err != nil { log.Printf("Failed to send out response: %v", err) } }) }
func identityMat4() [16]float { return { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 } }
func identityMat4() [16]float64 { return [...]float64{ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 } }
s := []int{5, 2, 6, 3, 1, 4} sort.Ints(s) fmt.Println(s)
package main import "fmt" func Identity(n int) []float { m := make([]float, n*n) for i := 0; i < n; i++ { for j := 0; j < n; j++ { if i == j { m[i*n+j] = 1.0 } } } return m } func main() { fmt.Println(Identity(4)) } Output: [1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1]
tables := []struct { input []string result string } { {[]string{"one ", " two", " three "}, "onetwothree"}, {[]string{" three", "four ", " five "}, "threefourfive"}, } for _, table := range tables { result := StrTrimConcat(table.input...) if result != table.result { t.Errorf("Result was incorrect. Expected: %v. Got: %v. Input: %v.", table.result, result, table.input) } }
panic: 530 5.5.1 Authentication Required. Learn more at
auth := smtp.PlainAuth("", "bjorkbjorksen@gmail.com", "PASSWORD", "smtp.gmail.com") msg := "Subject: Hello\r\n\r\nWorld!" e = smtp.SendMail("smtp.gmail.com:587", auth, "bjorkbjorksen@gmail.com", []string{email}, []byte(msg)) if e != nil { panic(e) }
func a() MyStruct { } tmpA := a() var b *MyStruct = &tmpA
func a2() *MyStruct { /* doesn } var a *MyStruct = a2()
var work_counter int func GoWorkerRoutine() { for { atomic.AddInt32(&work_counter,1) } }
var work_counter map[string]int var work_mux sync.Mutex func GoWorkerRoutine() { for { work_mux.Lock() work_counter["type1"]++ work_mux.Unlock() } }
var work_counter int var work_chan chan int func GoCounterRoutine() { for { select { case c := <- work_chan: work_counter += c break } } } func GoWorkerRoutine() { for { work_chan <- 1 } }
package helpers import ( ) type CounterIncrementStruct struct { bucket string value int } type CounterQueryStruct struct { bucket string channel chan int } var counter map[string]int var counterIncrementChan chan CounterIncrementStruct var counterQueryChan chan CounterQueryStruct var counterListChan chan chan map[string]int func CounterInitialize() { counter = make(map[string]int) counterIncrementChan = make(chan CounterIncrementStruct,0) counterQueryChan = make(chan CounterQueryStruct,100) counterListChan = make(chan chan map[string]int,100) go goCounterWriter() } func goCounterWriter() { for { select { case ci := <- counterIncrementChan: if len(ci.bucket)==0 { return } counter[ci.bucket]+=ci.value break case cq := <- counterQueryChan: val,found:=counter[cq.bucket] if found { cq.channel <- val } else { cq.channel <- -1 } break case cl := <- counterListChan: nm := make(map[string]int) for k, v := range counter { nm[k] = v } cl <- nm break } } } func CounterIncrement(bucket string, counter int) { if len(bucket)==0 || counter==0 { return } counterIncrementChan <- CounterIncrementStruct{bucket,counter} } func CounterQuery(bucket string) int { if len(bucket)==0 { return -1 } reply := make(chan int) counterQueryChan <- CounterQueryStruct{bucket,reply} return <- reply } func CounterList() map[string]int { reply := make(chan map[string]int) counterListChan <- reply return <- reply }
func bcRoutine(b *testing.B,e chan bool) { for i := 0; i < b.N; i++ { CounterIncrement("abc123",5) CounterIncrement("def456",5) CounterIncrement("ghi789",5) CounterIncrement("abc123",5) CounterIncrement("def456",5) CounterIncrement("ghi789",5) } e<-true } func BenchmarkChannels(b *testing.B) { b.StopTimer() CounterInitialize() e:=make(chan bool) b.StartTimer() go bcRoutine(b,e) go bcRoutine(b,e) go bcRoutine(b,e) go bcRoutine(b,e) go bcRoutine(b,e) <-e <-e <-e <-e <-e } var mux sync.Mutex var m map[string]int func bmIncrement(bucket string, value int) { mux.Lock() m[bucket]+=value mux.Unlock() } func bmRoutine(b *testing.B,e chan bool) { for i := 0; i < b.N; i++ { bmIncrement("abc123",5) bmIncrement("def456",5) bmIncrement("ghi789",5) bmIncrement("abc123",5) bmIncrement("def456",5) bmIncrement("ghi789",5) } e<-true } func BenchmarkMutex(b *testing.B) { b.StopTimer() m=make(map[string]int) e:=make(chan bool) b.StartTimer() for i := 0; i < b.N; i++ { bmIncrement("abc123",5) bmIncrement("def456",5) bmIncrement("ghi789",5) bmIncrement("abc123",5) bmIncrement("def456",5) bmIncrement("ghi789",5) } go bmRoutine(b,e) go bmRoutine(b,e) go bmRoutine(b,e) go bmRoutine(b,e) go bmRoutine(b,e) <-e <-e <-e <-e <-e }
$ go test --bench=. helpers PASS BenchmarkChannels 100000 15560 ns/op BenchmarkMutex 1000000 2669 ns/op ok helpers 4.452s
import "sync/atomic" type count32 int32 func (c *count32) increment() int32 { return atomic.AddInt32((*int32)(c), 1) } func (c *count32) get() int32 { return atomic.LoadInt32((*int32)(c)) }
import "sync/atomic" type UniqueID struct { counter int32 } func (c *UniqueID) Get() int32 { for { val := atomic.LoadInt32(&c.counter) if atomic.CompareAndSwapInt32(&c.counter, val, val+1) { return val } } }
requestID := client.msgID.Get() form.Set("id", requestID)
package main import "fmt" func main() { ch := make(chan int, 3) go GoCounterRoutine(ch) go GoWorkerRoutine(1, ch) GoWorkerRoutine(2, ch) } func GoCounterRoutine(ch chan int) { counter := 0 for { ch <- counter counter += 1 } } func GoWorkerRoutine(n int, ch chan int) { var seq int for seq := range ch { fmt.Println(n, seq) } }
package main import ( "fmt" "sync" ) type single struct { mu sync.Mutex values map[string]int64 } var counters = single{ values: make(map[string]int64), } func (s *single) Get(key string) int64 { s.mu.Lock() defer s.mu.Unlock() return s.values[key] } func (s *single) Incr(key string) int64 { s.mu.Lock() defer s.mu.Unlock() s.values[key]++ return s.values[key] } func main() { fmt.Println(counters.Incr("bar")) fmt.Println(counters.Incr("bar")) fmt.Println(counters.Incr("bar")) fmt.Println(counters.Get("foo")) fmt.Println(counters.Get("bar")) }
log := stdlog.GetFromFlags() log.Info("Connecting to the server...") log.Errorf("Connection failed: %q", err)
x := strings.Split("foo;bar", ";") a, b := x[0], x[1]
bookmark := make(map[string]string) x := strings.Split("foo\thttps: name, link := x[0], x[1] bookmark[name] = link
bookmark := make(map[string]string) name, line := strings.Split("foo\thttps: bookmark[name] = link
func splitLink(s, sep string) (string, string) { x := strings.Split(s, sep) return x[0], x[1] }
func unpack(s []string, vars... *string) { for i, str := range s { *vars[i] = str } }
var name, link string unpack(strings.Split("foo\thttps: bookmarks[name] = link
package main import ( "fmt" "strings" ) func Split(s, sep string) (string, string) { if len(s) == 0 { return s, s } slice := strings.SplitN(s, sep, 2) if len(slice) == 1 { return slice[0], "" } return slice[0], slice[1] } func main() { a, b := Split("foo;bar;foo", ";") fmt.Println(a, b) }
package mypkg func TestPrivateStruct(t *testing.T){ pf := private{ "Private Field" } .... }
package mypkg type private struct { privateField string }
func handle(res http.ResponseWriter, req *http.Request) { fmt.Fprintf(res, "sending first line of data") sleep(10) fmt.Fprintf(res, "sending second line of data") }
cmd := exec.Command("a long command that outputs lots of lines") cmd.Stdout = res cmd.Stderr = res err := cmd.Run()
pipeReader, pipeWriter := io.Pipe() cmd.Stdout = pipeWriter cmd.Stderr = pipeWriter go writeCmdOutput(res, pipeReader) err := cmd.Run() pipeWriter.Close() func writeCmdOutput(res http.ResponseWriter, pipeReader *io.PipeReader) { buffer := make([]byte, BUF_LEN) for { n, err := pipeReader.Read(buffer) if err != nil { pipeReader.Close() break } data := buffer[0:n] res.Write(data) if f, ok := res.(http.Flusher); ok { f.Flush() } for i := 0; i < n; i++ { buffer[i] = 0 } } }
func handle(res http.ResponseWriter, req *http.Request) { fmt.Fprintf(res, "sending first line of data") if f, ok := res.(http.Flusher); ok { f.Flush() } else { log.Println("Damn, no flush"); } sleep(10) fmt.Fprintf(res, "sending second line of data") }
package main import ( "bytes" "fmt" "net/http" ) func handler(w http.ResponseWriter, r *http.Request) { body := make([]byte, int(r.ContentLength)) b := bytes.NewBuffer(body) if _, err := b.ReadFrom(r.Body); err != nil { fmt.Fprintf(w, "%s", err) } if _, err := b.WriteTo(w); err != nil { fmt.Fprintf(w, "%s", err) } } func main() { http.HandleFunc("/", handler) if err := http.ListenAndServe(":8080", nil); err != nil { panic(err) } }
package main import "tour/tree" import "fmt" func Walk(t *tree.Tree, ch chan int) { if t.Left != nil { Walk(t.Left, ch) } ch <- t.Value if t.Right != nil { Walk(t.Right,ch) } } func Same(t1, t2 *tree.Tree) bool { ch1 := make(chan int) ch2 := make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for k := range ch1{ select { case g := <-ch2: if k != g { return false } default: break } } return true } func main() { fmt.Println(Same(tree.New(1), tree.New(1))) fmt.Println(Same(tree.New(1), tree.New(2))) }
func Walk(t *tree.Tree, ch chan int) { walkRecurse(t, ch) close(ch) }
func Same(t1, t2 *tree.Tree) bool { countT1 := countTreeNodes(t1) countT2 := countTreeNodes(t2) if countT1!= countT2 { return false } ch1:=make(chan int) ch2:=make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for i:=0; i<countT1; i++ { if <-ch1 != <-ch2 { return false } } return true }
func Walk(t *tree.Tree, ch chan int) { defer close(ch) var walk func(t *tree.Tree) walk = func(t *tree.Tree) { if t == nil { return } walk(t.Left) ch <- t.Value walk(t.Right) } walk(t) }
package main import "fmt" import "code.google.com/p/go-tour/tree" func Walk(t *tree.Tree, ch chan int) { var walker func(t *tree.Tree) walker = func (t *tree.Tree) { if (t == nil) { return } walker(t.Left) ch <- t.Value walker(t.Right) } walker(t) close(ch) } func Same(t1, t2 *tree.Tree) bool { ch1, ch2 := make(chan int), make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for { v1,ok1 := <- ch1 v2,ok2 := <- ch2 if v1 != v2 || ok1 != ok2 { return false } if !ok1 { break } } return true } func main() { fmt.Println("1 and 1 same: ", Same(tree.New(1), tree.New(1))) fmt.Println("1 and 2 same: ", Same(tree.New(1), tree.New(2))) }
package main import ( "golang.org/x/tour/tree" "fmt" ) func Walk(t *tree.Tree, ch chan int) { if t == nil { return } Walk(t.Left, ch) ch <- t.Value Walk(t.Right, ch) } func Same(t1, t2 *tree.Tree) bool { ch1, ch2 := make(chan int), make(chan int) go func() { defer close(ch1) Walk(t1, ch1) }() go func() { defer close(ch2) Walk(t2, ch2) }() for { v1, ok1 := <- ch1 v2, ok2 := <- ch2 if ok1 != ok2 || v1 != v2 { return false } if !ok1 && !ok2 { break } } return true } func main() { ch := make(chan int) go func () { defer close(ch) Walk(tree.New(3), ch) }() for i := range ch { fmt.Println(i) } fmt.Println(Same(tree.New(1), tree.New(1))) fmt.Println(Same(tree.New(1), tree.New(2))) fmt.Println(Same(tree.New(10), tree.New(10))) }
func Walker(t *tree.Tree, ch chan int){ if t==nil {return} Walker(t.Left,ch) ch<-t.Value Walker(t.Right,ch) } func Walk(t *tree.Tree, ch chan int){ Walker(t,ch) close(ch) } func Same(t1, t2 *tree.Tree) bool{ ch:=make(chan int) dh:=make(chan int) go Walk(t1,ch) go Walk(t2,dh) for i:=range ch { j,ok:=<-dh if(i!=j||!ok) {return false} } return true }
package main import "code.google.com/p/go-tour/tree" import "fmt" func Walk(t *tree.Tree, ch chan int) { var walker func (t *tree.Tree) walker = func (t *tree.Tree) { if t.Left != nil { walker(t.Left) } ch <- t.Value if t.Right != nil { walker(t.Right) } } walker(t) close(ch) } func Same(t1, t2 *tree.Tree) bool { chana := make (chan int) chanb := make (chan int) go Walk(t1, chana) go Walk(t2, chanb) for { n1, ok1 := <-chana n2, ok2 := <-chanb if n1 != n2 || ok1 != ok2 { return false } if (!ok1) { break } } return true; }
func Same(t1, t2 *tree.Tree) bool { ch1, ch2 := make(chan int), make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for i := range ch1 { j, more := <-ch2 if more { if i != j { return false } } else { return false } } return true }
func Same(t1, t2 *tree.Tree) bool { countMap := make(map[int]int) ch := make(chan int) go Walk(t1, ch) for v:= range ch { countMap[v]++ } ch = make(chan int) go Walk(t2, ch) for v:= range ch { countMap[v]-- if countMap[v] < 0 { return false } } return true }
fmt.Println("Should return true:", Same(tree.New(1), tree.New(1))) fmt.Println("Should return false:", Same(tree.New(1), tree.New(2)))
func Same(t1, t2 *tree.Tree) bool { ch1, ch2 := make(chan int), make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) var tv1=[]int{} for v:=range ch1 { tv1 = append(tv1, v) } inArray := func(arr []int, value int ) bool { for a:=range arr { if arr[a]==value { return true } } return false } for v2:=range ch2 { if ! inArray(tv1, v2) { return false } } return true }
package main import "code.google.com/p/go-tour/tree" import "fmt" func WalkRecurse(t *tree.Tree, ch chan int) { if t == nil { return } WalkRecurse(t.Left, ch) ch <- t.Value WalkRecurse(t.Right, ch) } func Walk(t *tree.Tree, ch chan int) { WalkRecurse(t, ch) close(ch) } func Same(t1, t2 *tree.Tree) bool { var ch1, ch2 chan int = make(chan int), make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) ret := true for { v1, ok1 := <- ch1 v2, ok2 := <- ch2 if ok1 != ok2 { ret = false } if ok1 && (v1 != v2) { ret = false } if !ok1 && !ok2 { break } } return ret } func main() { ch := make(chan int) go Walk(tree.New(1), ch) for v := range ch { fmt.Print(v, " ") } fmt.Println() fmt.Println(Same(tree.New(1), tree.New(1))) fmt.Println(Same(tree.New(1), tree.New(2))) }
package main import ( "fmt" "golang.org/x/tour/tree" ) func WalkRec(t *tree.Tree, ch chan int) { if t == nil { return } WalkRec(t.Left, ch) ch <- t.Value WalkRec(t.Right, ch) } func Walk(t *tree.Tree, ch chan int) { WalkRec(t, ch) close(ch) } func Same(t1, t2 *tree.Tree) bool { ch1 := make(chan int) ch2 := make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for { x, okx := <-ch1 y, oky := <-ch2 switch { case okx != oky: return false case x != y: return false case okx == oky && okx == false: return true } } } func main() { ch := make(chan int) go Walk(tree.New(1), ch) fmt.Println(Same(tree.New(1), tree.New(1))) fmt.Println(Same(tree.New(2), tree.New(1))) fmt.Println(Same(tree.New(1), tree.New(2))) }
package main import ( "fmt" "golang.org/x/tour/tree" ) func Walk(t *tree.Tree, ch chan int) { var walker func(t *tree.Tree) walker = func(t *tree.Tree) { if t == nil { return } walker(t.Left) ch <- t.Value walker(t.Right) } walker(t) close(ch) } func Same(t1, t2 *tree.Tree, sameChan func(ch1, ch2 chan int) bool) bool { ch1, ch2 := make(chan int), make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) return sameChan(ch1, ch2) } func sameChan1(ch1, ch2 chan int) bool { areSame := true for { v1, ok1 := <-ch1 v2, ok2 := <-ch2 if !ok1 && !ok2 { return areSame } if !ok1 || !ok2 || v1 != v2 { areSame = false } } } func sameChan2(ch1, ch2 chan int) bool { areSame := true for v1 := range ch1 { v2, ok2 := <-ch2 if !ok2 || v1 != v2 { areSame = false } } for _ = range ch2 { areSame = false } return areSame } func main() { fmt.Println(Same(tree.New(1), tree.New(1), sameChan1)) fmt.Println(Same(tree.New(2), tree.New(1), sameChan1)) fmt.Println(Same(tree.New(1), tree.New(2), sameChan1)) fmt.Println(Same(tree.New(1), tree.New(1), sameChan2)) fmt.Println(Same(tree.New(2), tree.New(1), sameChan2)) fmt.Println(Same(tree.New(1), tree.New(2), sameChan2)) }
package main import ( "golang.org/x/tour/tree" "fmt" ) func Walk(t *tree.Tree, ch chan int){ if t != nil { Walk(t.Left, ch) ch <- t.Value Walk(t.Right, ch) } } func Same(t1, t2 *tree.Tree) bool{ c1, c2 := make(chan int), make(chan int) go Walk(t1, c1) go Walk(t2, c2) if <-c1 == <-c2 { return true }else { return false } } func main() { t1 := tree.New(1) t2 := tree.New(8) fmt.Println("the two trees are same?", Same(t1, t2)) }
func Walk(t *tree.Tree, ch chan int) { defer close(ch) var walker func(t *tree.Tree) walker = func(t *tree.Tree) { if t == nil { return } walker(t.Left) ch <- t.Value walker(t.Right) } walker(t) } func Same(t1, t2 *tree.Tree) bool { ch1, ch2 := make(chan int), make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for range make([]struct{}, 10) { if <-ch1 != <-ch2 { return false } } return true }
package main import ( "fmt" "golang.org/x/tour/tree" ) func Walk(t *tree.Tree, ch chan int) { var walk func(*tree.Tree) walk = func(tr *tree.Tree) { if tr == nil { return } walk(tr.Left) ch <- tr.Value walk(tr.Right) } walk(t) close(ch) } func merge(ch chan int, m map[int]int) { for i := range ch { count, ok := m[i] if ok { m[i] = count + 1 } else { m[i] = 1 } } } func Same(t1, t2 *tree.Tree) bool { ch1 := make(chan int, 100) ch2 := make(chan int, 100) m := make(map[int]int) go Walk(t1, ch1) go Walk(t2, ch2) merge(ch1, m) merge(ch2, m) for _, count := range m { if count != 2 { return false } } return true }
func Walk(t *tree.Tree, ch chan int) { defer close(ch) visitStack := []*tree.Tree{t} visited := make(map[*tree.Tree]bool, 1) for len(visitStack) > 0 { var n *tree.Tree n, visitStack = visitStack[len(visitStack)-1], visitStack[:len(visitStack)-1] if visited[n] { ch <- n.Value continue } if n.Right != nil { visitStack = append(visitStack, n.Right) } visitStack = append(visitStack, n) if n.Left != nil { visitStack = append(visitStack, n.Left) } visited[n] = true } }
package main import "golang.org/x/tour/tree" import "fmt" func Walk(t *tree.Tree, ch chan int) { if t == nil { return } Walk(t.Left, ch) ch <- t.Value Walk(t.Right, ch) } func WalkATree(t *tree.Tree, ch chan int) { Walk(t, ch) close(ch) } func Same(t1, t2 *tree.Tree) bool { ch1 := make(chan int) ch2 := make(chan int) go WalkATree(t1, ch1) go WalkATree(t2, ch2) var v1, v2 int var ok1, ok2 bool for { v1, ok1 = <- ch1 v2, ok2 = <- ch2 if !ok1 && !ok2 { return true } if !ok1 && ok2 || ok1 && !ok2 { return false } if v1 != v2 { return false } } } func main() { fmt.Println(Same(tree.New(1), tree.New(1))) }
package main import ( "fmt" "golang.org/x/tour/tree" ) func Walk(t *tree.Tree, ch chan int) { if t.Left != nil { Walk(t.Left, ch) } ch <- t.Value if t.Right != nil { Walk(t.Right, ch) } } func Same(t1, t2 *tree.Tree) bool { ch1 := make(chan int) ch2 := make(chan int) defer close(ch1) defer close(ch2) go Walk(t1, ch1) go Walk(t2, ch2) for i := 0; i < 10; i++ { if <-ch1 != <-ch2 { return false } } return true } func main() { fmt.Println(Same(tree.New(1), tree.New(2))) }
package main import ( "fmt" "time" ) const ( timeFormat = "2006-01-02 15:04 MST" ) func main() { v := "2014-05-03 20:57 UTC" then, err := time.Parse(timeFormat, v) if err != nil { fmt.Println(err) return } duration := time.Since(then) fmt.Println(duration.Hours()) }
package main import "fmt" import "time" func main() { a, err := time.Parse("2006-01-02 15:04 MST", "2014-05-03 20:57 UTC") if err != nil { return } delta := time.Now().Sub(a) fmt.Println(delta.Hours()) }
import "io/ioutil" func main() { content, err = iotuil.ReadFile("somefile.txt") }
package main import ( . "fmt" . "io/ioutil" ) func main () { content, err := ReadFile("testfile") if err != nil { Println("Errors") } Println("My file:\n", string(content)) }
package main import "fmt" import "exec" func main() { cmd, err := exec.Run("/bin/ls", []string{"/bin/ls"}, []string{}, "", exec.DevNull, exec.PassThrough, exec.PassThrough) if (err != nil) { fmt.Println(err) return } cmd.Close()
package main import ( "fmt" "exec" "os" "bytes" "io" ) func main() { app := "/bin/ls" cmd, err := exec.Run(app, []string{app, "-l"}, nil, "", exec.DevNull, exec.Pipe, exec.Pipe) if (err != nil) { fmt.Fprintln(os.Stderr, err.String()) return } var b bytes.Buffer io.Copy(&b, cmd.Stdout) fmt.Println(b.String()) cmd.Close() }
package main import "os/exec" func main() { app := "echo" arg0 := "-e" arg1 := "Hello world" arg2 := "\n\tfrom" arg3 := "golang" cmd := exec.Command(app, arg0, arg1, arg2, arg3) stdout, err := cmd.Output() if err != nil { println(err.Error()) return } print(string(stdout)) }
package main import ( "bytes" "fmt" "log" "os/exec" ) const ShellToUse = "bash" func Shellout(command string) (error, string, string) { var stdout bytes.Buffer var stderr bytes.Buffer cmd := exec.Command(ShellToUse, "-c", command) cmd.Stdout = &stdout cmd.Stderr = &stderr err := cmd.Run() return err, stdout.String(), stderr.String() } func main() { err, out, errout := Shellout("ls -ltr") if err != nil { log.Printf("error: %v\n", err) } fmt.Println("--- stdout ---") fmt.Println(out) fmt.Println("--- stderr ---") fmt.Println(errout) }
func Cmd(cmd string, shell bool) []byte { if shell { out, err := exec.Command("bash", "-c", cmd).Output() if err != nil { panic("some error found") } return out } else { out, err := exec.Command(cmd).Output() if err != nil { panic("some error found") } return out } }
func RunCMD(path string, args []string, debug bool) (out string, err error) { cmd := exec.Command(path, args...) var b []byte b, err = cmd.CombinedOutput() out = string(b) if debug { fmt.Println(strings.Join(cmd.Args[:], " ")) if err != nil { fmt.Println("RunCMD ERROR") fmt.Println(out) } } return }
args := []string{"-y", "-i", "movie.mp4", "movie_audio.mp3", "INVALID-ARG!"} output, err := RunCMD("ffmpeg", args, true) if err != nil { fmt.Println("Error:", output) } else { fmt.Println("Result:", output) }
p, err := os.StartProcess(`c:\windows\system32\notepad.EXE`, []string{`c:\windows\system32\notepad.EXE`, outfile}, &os.ProcAttr{Env: nil, Dir: "", Files: []*os.File{os.Stdin, os.Stdout, os.Stderr}})
package main import "fmt" func main() { fmt.Println("Hello World!") }
package main import "fmt" func main() { fmt.Println("你好！") }
// // // func BasicAuth(handler http.HandlerFunc, username, password, realm string) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { user, pass, ok := r.BasicAuth() if !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 { w.Header().Set("WWW-Authenticate", `Basic realm="`+realm+`"`) w.WriteHeader(401) w.Write([]byte("Unauthorised.\n")) return } handler(w, r) } } ... http.HandleFunc("/", BasicAuth(handleIndex, "admin", "123456", "Please enter your username and password for this site"))
func auth(fn http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { user, pass, _ := r.BasicAuth() if !check(user, pass) { http.Error(w, "Unauthorized.", 401) return } fn(w, r) } }
func checkAuth(w http.ResponseWriter, r *http.Request) bool { s := strings.SplitN(r.Header.Get("Authorization"), " ", 2) if len(s) != 2 { return false } b, err := base64.StdEncoding.DecodeString(s[1]) if err != nil { return false } pair := strings.SplitN(string(b), ":", 2) if len(pair) != 2 { return false } return pair[0] == "user" && pair[1] == "pass" } yourRouter.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { if checkAuth(w, r) { yourOriginalHandler.ServeHTTP(w, r) return } w.Header().Set("WWW-Authenticate", `Basic realm="MY REALM"`) w.WriteHeader(401) w.Write([]byte("401 Unauthorized\n")) })
func basicAuthHandler(user, pass, realm string, next http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { if checkBasicAuth(r, user, pass) { next(w, r) return } w.Header().Set("WWW-Authenticate", fmt.Sprintf(`Basic realm="%s"`, realm)) w.WriteHeader(401) w.Write([]byte("401 Unauthorized\n")) } } func checkBasicAuth(r *http.Request, user, pass string) bool { u, p, ok := r.BasicAuth() if !ok { return false } return u == user && p == pass }
userhash := hasher("admin") passhash := hasher("$CrazyUnforgettablePassword?") realm := "Please enter username and password" http.HandleFunc("/", authHandler(indexHandler, userhash, passhash, realm)) func hasher(s string) []byte { val := sha256.Sum256([]byte(s)) return val[:] } func authHandler(handler http.HandlerFunc, userhash, passhash []byte, realm string) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { user, pass, ok := r.BasicAuth() if !ok || subtle.ConstantTimeCompare(hasher(user), userhash) != 1 || subtle.ConstantTimeCompare(hasher(pass), passhash) != 1 { w.Header().Set("WWW-Authenticate", `Basic realm="`+realm+`"`) http.Error(w, "Unauthorized.", http.StatusUnauthorized) return } handler(w, r) } }
type opt struct { shortnm char longnm, help string needArg bool } const basename_opts []opt { opt { shortnm: longnm: "multiple", needArg: false, help: "Usage for a"} }, opt { shortnm: longnm: "b-option", needArg: false, help: "Usage for b"} }
type opt struct { shortnm byte longnm, help string needArg bool } var basenameOpts = []opt { opt { shortnm: longnm: "multiple", needArg: false, help: "Usage for a", }, opt { shortnm: longnm: "b-option", needArg: false, help: "Usage for b", }, }
type opt struct { shortnm byte longnm, help string needArg bool } var basenameOpts []opt func init() { basenameOpts = []opt{ opt { shortnm: longnm: "multiple", needArg: false, help: "Usage for a", }, opt { shortnm: longnm: "b-option", needArg: false, help: "Usage for b", }, ) }
var opts = []struct { shortnm byte longnm, help string needArg bool }{ { { shortnm: longnm: "b-option", needArg: false, help: "Usage for b", }, }
package main import "testing" func TestReverse(t *testing.T) { cases := []struct { in, want string }{ {"Hello, world", "dlrow ,olleH"}, {"Hello, 世界", "界世 ,olleH"}, {"", ""}, } for _, c := range cases { got := Reverse(c.in) if got != c.want { t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want) } } }
GOARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="linux" GOOS="linux" GOPATH="/home/juan/go" GORACE="" GOROOT="/usr/lib/go" GOTOOLDIR="/usr/lib/go/pkg/tool/linux_amd64" TERM="dumb" CC="gcc" GOGCCFLAGS="-g -O2 -fPIC -m64 -pthread" CXX="g++" CGO_ENABLED="1"
. ├── Dockerfile ├── Makefile ├── README.md ├── auth/ │ ├── jwt.go │ ├── jwt_test.go ├── main.go
type Config struct { Key string Value string } var myconfig []Config if err := json.Unmarshal(respbody, &myconfig); err != nil { panic(err) } fmt.Println(config)
for _, v := range myconfig { if v.Key == "key1" { } }
for i := range myconfig { if myconfig[i].Key == "key1" { } }
for i := range myconfig { if myconfig[i].Key == "key1" { break } }
confMap := map[string]string{} for _, v := range myconfig { confMap[v.Key] = v.Value } if v, ok := confMap["key1"]; ok { }
type Person struct { Name string } func main() { crowd := []Person{{"Zoey"}, {"Anna"}, {"Benni"}, {"Chris"}} sort.Slice(crowd, func(i, j int) bool { return crowd[i].Name <= crowd[j].Name }) needle := "Benni" idx := sort.Search(len(crowd), func(i int) bool { return string(crowd[i].Name) >= needle }) if crowd[idx].Name == needle { fmt.Println("Found:", idx, crowd[idx]) } else { fmt.Println("Found noting: ", idx) } }
mapConfig := map[string]string{} for _, v := range myconfig { mapConfig[v.Key] = v.Value }
if v, ok := mapConfig["key1"]; ok { fmt.Printf("%s exists", v) }
for _, value := range myconfig { if value .Key == "key1" { } }
package main import ( "encoding/json" "fmt" ) func main() { type Config struct { Key string Value string } var respbody = []byte(`[ {"Key":"Key1", "Value":"Value1"}, {"Key":"Key2", "Value":"Value2"} ]`) var myconfig []Config err := json.Unmarshal(respbody, &myconfig) if err != nil { fmt.Println("error:", err) } fmt.Printf("%+v\n", myconfig) for _, v := range myconfig { if v.Key == "Key1" { fmt.Println("Value: ", v.Value) } } }
func namedReturn(i int) (ret int) { ret = i i += 2 return } func anonReturn(i int) int { ret := i i += 2 return ret }
func nextInt(b []byte, pos int) (value, nextPos int) {
package main import ( "errors" "fmt" ) func main() { fmt.Println(f()) } var harmlessError = errors.New("you should worry!") func f() (err error) { defer func() { if err == harmlessError { err = nil } }() return harmlessError }
func someFunc() (int, error) { var r int var e error ok := someOtherFunc(&r) if !ok { return r, someError() } return r, nil }
func someFunc() (r int, e error) { ok := someOtherFunc(&r) if !ok { e = someError() } return }
func foo() (a, b, c T) { if qux { b = bar() } return }
func foo() (T, T, T) { var a, b, c T if qux { b = bar() } return a, b, c }
func foo() (a, b, c T) { if a > c { b = bar() } return }
import { "strings" } strings.Contains("something", "some")
/Users/me/dev/go/src/client1 /Users/me/dev/go/src/client2 /Users/me/dev/go/src/client3
/Users/me/dev/client1/rails_project /Users/me/dev/client2/php_project etc.
$ go env GOROOT="/home/peter/go" GOPATH="/home/peter/gopath:/home/peter/public/gopath" $
type Payment struct { User *User } type User struct { Payments *[]Payments } func (u *User) Get(id int) *User { } func (p *Payment) Get(id int) *Payment { }
func GetUser(id int) *User { } func GetPayment(id int) *Payment { }
func (u *User) Get(id int) error { *u = User{ ... } return nil }
m := map[string]string{ "key1":"val1", "key2":"val2" };
package main import "fmt" func main() { m := map[string]string{"key1": "val1", "key2": "val2"} fmt.Println(m) delete(m, "key1") fmt.Println(m) }
package hello import ( "fmt" "http" ) func init() { http.HandleFunc("/", handler) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, "Host: " + r.URL.Host + " Scheme: " + r.URL.Scheme) }
t := time.Now() fmt.Println("Location:", t.Location(), ":Time:", t) utc, err := time.LoadLocation("America/New_York") if err != nil { fmt.Println("err: ", err.Error()) } fmt.Println("Location:", utc, ":Time:", t.In(utc))
loc, _ := time.LoadLocation("Asia/Shanghai") now := time.Now().In(loc)
package main import "fmt" func mapToAnotherFunction(m map[string]int) { m["hello"] = 3 m["world"] = 4 m["new_word"] = 5 } func main() { m := make(map[string]int) m["hello"] = 1 m["world"] = 2 for key, val := range m { fmt.Println(key, "=>", val) } fmt.Println("-----------------------") mapToAnotherFunction(m) for key, val := range m { fmt.Println(key, "=>", val) } fmt.Println("-----------------------") }
docker run -it alpine:3.3 sh apk add --no-cache curl DOCKER_BUCKET=get.docker.com DOCKER_VERSION=1.9.1 curl -fSL "https: chmod +x /usr/local/bin/docker docker help Usage: docker [OPTIONS] COMMAND [arg...] ...
RACK_BUCKET=ec4a542dbf90c03b9f75-b342aba65414ad802720b41e8159cf45.ssl.cf5.rackcdn.com RACK_VERSION=1.1.0-beta1 curl -fSL "https: chmod +x /usr/local/bin/rack rack help sh: rack: not found /usr/local/bin/rack help sh: /usr/local/bin/rack: not found ls -al /usr/local/bin/ total 43375 drwxr-xr-x 2 root root 1024 Jan 11 18:10 . drwxr-xr-x 8 root root 1024 Jan 11 18:09 .. -rwxr-xr-x 1 root root 30222575 Jan 11 18:09 docker -rwxr-xr-x 1 root root 14190576 Jan 11 18:10 rack which rack /usr/local/bin/rack
ldd /usr/local/bin/rack /lib64/ld-linux-x86-64.so.2 (0x7fdd15cd0000) libpthread.so.0 => /lib64/ld-linux-x86-64.so.2 (0x7fdd15cd0000) libc.so.6 => /lib64/ld-linux-x86-64.so.2 (0x7fdd15cd0000)
RUN mkdir /lib64 && ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2
GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o [name of binary]
docker run -v ${YOUR_CODE_PATH}:/go/src/example -it golang:alpine sh cd src/example go build . ldd example /lib/ld-musl-x86_64.so.1 (0x7f677fcf7000) libc.musl-x86_64.so.1 => /lib/ld-musl-x86_64.so.1 (0x7f677fcf7000)
package main import "fmt" func main() { ch := make(chan int, 1) ch <- 1 select { case ch <- 2: default: fmt.Println("Channel full. Discarding value") } }
for elem := range ch.input { select { case ch.output <- elem: default: } } close(ch.output)
package sample import ( "testing" "runtime" ) func TestGetFilename(t *testing.T) { _, filename, _, _ := runtime.Caller(0) fmt.Println("Current test filename: " + filename) }
package blah_test import ( "flag" "fmt" "os" "testing" ) var ( cwd_arg = flag.String("cwd", "", "set cwd") ) func init() { flag.Parse() if *cwd_arg != "" { if err := os.Chdir(*cwd_arg); err != nil { fmt.Println("Chdir error:", err) } } } func TestBlah(t *testing.T) { t.Errorf("cwd: %+q", *cwd_arg) }
┌─ oneofone@Oa [/tmp] └──➜ go test . -cwd="$PWD" --- FAIL: TestBlah (0.00 seconds) blah_test.go:16: cwd: "/tmp"
func TestMyFunction(t *testing.T) { os.Chdir("./path") os.Chdir("..") }
wd, _ := os.Getwd() for !strings.HasSuffix(wd, "<yourProjectDirName>") { wd = filepath.Dir(wd) } raw, err := ioutil.ReadFile(fmt.Sprintf("%s/src/conf/conf.dev.json", wd))
func exeDir() string { dir, exists := os.LookupEnv("MYAPPHOME") if exists { return dir } else { ex, err := os.Executable() if err != nil { panic(err) } exPath := path.Dir(ex) return exPath } }
type CustomTime struct { time.Time } const ctLayout = "2006/01/02|15:04:05" func (ct *CustomTime) UnmarshalJSON(b []byte) (err error) { s := strings.Trim(string(b), "\"") if s == "null" { ct.Time = time.Time{} return } ct.Time, err = time.Parse(ctLayout, s) return } func (ct *CustomTime) MarshalJSON() ([]byte, error) { if ct.Time.UnixNano() == nilTime { return []byte("null"), nil } return []byte(fmt.Sprintf("\"%s\"", ct.Time.Format(ctLayout))), nil } var nilTime = (time.Time{}).UnixNano() func (ct *CustomTime) IsSet() bool { return ct.UnixNano() != nilTime } type Args struct { Time CustomTime } var data = ` {"Time": "2014/08/01|11:27:18"} ` func main() { a := Args{} fmt.Println(json.Unmarshal([]byte(data), &a)) fmt.Println(a.Time.String()) }
type Time struct { time.Time } func (t *Time) UnmarshalJSON(b []byte) error { *t = Time{time.Now()} return nil } type Config struct { T Time } func main() { c := Config{} json.Unmarshal([]byte(`{"T": "bad-time"}`), &c) fmt.Printf("%+v\n", c) }
package main import ( "fmt" "regexp" ) func main() { r := regexp.MustCompile(`(?P<Year>\d{4})-(?P<Month>\d{2})-(?P<Day>\d{2})`) fmt.Printf("% fmt.Printf("% }
/** * Parses url with the given regular expression and returns the * group values defined in the expression. * */ func getParams(regEx, url string) (paramsMap map[string]string) { var compRegEx = regexp.MustCompile(regEx) match := compRegEx.FindStringSubmatch(url) paramsMap = make(map[string]string) for i, name := range compRegEx.SubexpNames() { if i > 0 && i <= len(match) { paramsMap[name] = match[i] } } return }
params := getParams(`(?P<Year>\d{4})-(?P<Month>\d{2})-(?P<Day>\d{2})`, `2015-05-27`) fmt.Println(params)
txt := `2001-01-20 2009-03-22 2018-02-25 2018-06-07` regex := *regexp.MustCompile(`(?s)(\d{4})-(\d{2})-(\d{2})`) res := regex.FindAllStringSubmatch(txt, -1) for i := range res { fmt.Printf("year: %s, month: %s, day: %s\n", res[i][1], res[i][2], res[i][3]) }
year: 2001, month: 01, day: 20 year: 2009, month: 03, day: 22 year: 2018, month: 02, day: 25 year: 2018, month: 06, day: 07
type date struct { y,m,d int } ... func main() { ... dates := make([]date, 0, len(res)) for ... { dates[index] = date{y: res[index][1], m: res[index][2], d: res[index][3]} } }
import "regexp" func ReplaceAllGroupFunc(re *regexp.Regexp, str string, repl func([]string) string) string { result := "" lastIndex := 0 for _, v := range re.FindAllSubmatchIndex([]byte(str), -1) { groups := []string{} for i := 0; i < len(v); i += 2 { groups = append(groups, str[v[i]:v[i+1]]) } result += str[lastIndex:v[0]] + repl(groups) lastIndex = v[1] } return result + str[lastIndex:] }
str := "abc foo:bar def baz:qux ghi" re := regexp.MustCompile("([a-z]+):([a-z]+)") result := ReplaceAllGroupFunc(re, str, func(groups []string) string { return groups[1] + "." + groups[2] }) fmt.Printf("
type Reminder struct { Id int CreatedAt time.Time RemindedAt *time.Time SenderId int ReceiverId int }
type NullTime struct { Time time.Time Valid bool } func (nt *NullTime) Scan(value interface{}) error { nt.Time, nt.Valid = value.(time.Time) return nil } func (nt NullTime) Value() (driver.Value, error) { if !nt.Valid { return nil, nil } return nt.Time, nil }
package client import ( "encoding/base64" "crypto/aes" "crypto/cipher" "fmt" ) var iv = []byte{34, 35, 35, 57, 68, 4, 35, 36, 7, 8, 35, 23, 35, 86, 35, 23} func encodeBase64(b []byte) string { return base64.StdEncoding.EncodeToString(b) } func decodeBase64(s string) []byte { data, err := base64.StdEncoding.DecodeString(s) if err != nil { panic(err) } return data } func Encrypt(key, text string) string { block, err := aes.NewCipher([]byte(key)) if err != nil { panic(err) } plaintext := []byte(text) cfb := cipher.NewCFBEncrypter(block, iv) ciphertext := make([]byte, len(plaintext)) cfb.XORKeyStream(ciphertext, plaintext) return encodeBase64(ciphertext) } func Decrypt(key, text string) string { block, err := aes.NewCipher([]byte(key)) if err != nil { panic(err) } ciphertext := decodeBase64(text) cfb := cipher.NewCFBEncrypter(block, iv) plaintext := make([]byte, len(ciphertext)) cfb.XORKeyStream(plaintext, ciphertext) }
package main import ( "crypto/aes" "crypto/cipher" "crypto/rand" "encoding/base64" "errors" "fmt" "io" "log" ) func main() { key := []byte("a very very very very secret key") plaintext := []byte("some really really really long plaintext") fmt.Printf("%s\n", plaintext) ciphertext, err := encrypt(key, plaintext) if err != nil { log.Fatal(err) } fmt.Printf("%0x\n", ciphertext) result, err := decrypt(key, ciphertext) if err != nil { log.Fatal(err) } fmt.Printf("%s\n", result) } func encrypt(key, text []byte) ([]byte, error) { block, err := aes.NewCipher(key) if err != nil { return nil, err } b := base64.StdEncoding.EncodeToString(text) ciphertext := make([]byte, aes.BlockSize+len(b)) iv := ciphertext[:aes.BlockSize] if _, err := io.ReadFull(rand.Reader, iv); err != nil { return nil, err } cfb := cipher.NewCFBEncrypter(block, iv) cfb.XORKeyStream(ciphertext[aes.BlockSize:], []byte(b)) return ciphertext, nil } func decrypt(key, text []byte) ([]byte, error) { block, err := aes.NewCipher(key) if err != nil { return nil, err } if len(text) < aes.BlockSize { return nil, errors.New("ciphertext too short") } iv := text[:aes.BlockSize] text = text[aes.BlockSize:] cfb := cipher.NewCFBDecrypter(block, iv) cfb.XORKeyStream(text, text) data, err := base64.StdEncoding.DecodeString(string(text)) if err != nil { return nil, err } return data, nil }
func Encrypt(key, text []byte) string { block, err := aes.NewCipher(key) if err != nil { panic(err) } ciphertext := make([]byte, aes.BlockSize+len(text)) iv := ciphertext[:aes.BlockSize] if _, err := io.ReadFull(crand.Reader, iv); err != nil { panic(err) } cfb := cipher.NewCFBEncrypter(block, iv) cfb.XORKeyStream(ciphertext[aes.BlockSize:], text) return encodeBase64(ciphertext) } func Decrypt(key []byte, b64 string) string { text := decodeBase64(b64) block, err := aes.NewCipher(key) if err != nil { panic(err) } if len(text) < aes.BlockSize { panic("ciphertext too short") } iv := text[:aes.BlockSize] text = text[aes.BlockSize:] cfb := cipher.NewCFBDecrypter(block, iv) cfb.XORKeyStream(text, text) return string(text) }
package main import ( "runtime" "fmt" ) func getGOMAXPROCS() int { return runtime.GOMAXPROCS(0) } func main() { fmt.Printf("GOMAXPROCS is %d\n", getGOMAXPROCS()) }
func basicAuth() string { var username string = "foo" var passwd string = "bar" client := &http.Client{} req, err := http.NewRequest("GET", "mydomain.com", nil) req.SetBasicAuth(username, passwd) resp, err := client.Do(req) if err != nil{ log.Fatal(err) } bodyText, err := ioutil.ReadAll(resp.Body) s := string(bodyText) return s }
func basicAuth(username, password string) string { auth := username + ":" + password return base64.StdEncoding.EncodeToString([]byte(auth)) } func redirectPolicyFunc(req *http.Request, via []*http.Request) error{ req.Header.Add("Authorization","Basic " + basicAuth("username1","password123")) return nil } func main() { client := &http.Client{ Jar: cookieJar, CheckRedirect: redirectPolicyFunc, } req, err := http.NewRequest("GET", "http: req.Header.Add("Authorization","Basic " + basicAuth("username1","password123")) resp, err := client.Do(req) }
dbmap := db.InitDb() var roles []entities.Role query := ` << Difficult to see with SO SELECT * FROM `Role` <<< Needs escaping ` << Difficult to see, but here is a back tick _, err := dbmap.Select(&roles, query, nil) if err != nil { panic(err) } fmt.Println(roles)
dbmap := db.InitDb() var roles []entities.Role query := ` SELECT * FROM ` + "`Role`" _, err := dbmap.Select(&roles, query, nil) if err != nil { panic(err) } fmt.Println(roles)
import "fmt" func main() { query :=fmt.Sprintf("SELECT * FROM `Role`") fmt.Println(query) fmt.Println( `SELECT * FROM ` + "`Role`") }
package main import ( "fmt" ) func main() { for i, j := 0, 1; i < 10; i, j = i+1, j+1 { fmt.Println("Hello, playground") } }
func (this *MyLinkedList) Get(index int) int { for i,list := 0,this; list != nil; i,list = i+1,list.Next{ if(i==index){ return list.Val } } return -1 }
type MyLinkedList struct { Val int Next *MyLinkedList }
for i, j := 0, 1; i < 10; i, j = i+1, j+1 { fmt.Println("i,j",i,j) }
void main() { char ch; ch = getchar(); printf("Input Char Is :%c",ch); }
package main import ( "bufio" "fmt" "os" ) func main() { reader := bufio.NewReader(os.Stdin) input, _ := reader.ReadString( fmt.Printf("Input Char Is : %v", string([]byte(input)[0])) }
package main import ( "fmt" "os" "os/exec" ) func main() { exec.Command("stty", "-F", "/dev/tty", "cbreak", "min", "1").Run() exec.Command("stty", "-F", "/dev/tty", "-echo").Run() defer exec.Command("stty", "-F", "/dev/tty", "echo").Run() var b []byte = make([]byte, 1) for { os.Stdin.Read(b) fmt.Println("I got the byte", b, "("+string(b)+")") } }
package main import ( "bytes" "fmt" "github.com/pkg/term" ) func getch() []byte { t, _ := term.Open("/dev/tty") term.RawMode(t) bytes := make([]byte, 3) numRead, err := t.Read(bytes) t.Restore() t.Close() if err != nil { return nil } return bytes[0:numRead] } func main() { for { c := getch() switch { case bytes.Equal(c, []byte{3}): return case bytes.Equal(c, []byte{27, 91, 68}): fmt.Println("LEFT pressed") default: fmt.Println("Unknown pressed", c) } } return }
package main import "C" import "fmt" func main() { c := C.getch() fmt.Println(c) }
package main /* char getch(){ char ch = 0; struct termios old = {0}; fflush(stdout); if( tcgetattr(0, &old) < 0 ) perror("tcsetattr()"); old.c_lflag &= ~ICANON; old.c_lflag &= ~ECHO; old.c_cc[VMIN] = 1; old.c_cc[VTIME] = 0; if( tcsetattr(0, TCSANOW, &old) < 0 ) perror("tcsetattr ICANON"); if( read(0, &ch,1) < 0 ) perror("read()"); old.c_lflag |= ICANON; old.c_lflag |= ECHO; if(tcsetattr(0, TCSADRAIN, &old) < 0) perror("tcsetattr ~ICANON"); return ch; } */ import "C" import "fmt" func main() { fmt.Println(C.getch()) fmt.Println() }
package main import ( "bufio" "fmt" "os" ) func main() { r := bufio.NewReader(os.Stdin) c, err := r.ReadByte() if err != nil { panic(err) } fmt.Println(c) }
reader := bufio.NewReader(os.Stdin) char, _, err := reader.ReadRune() if err != nil { fmt.Println("Error reading key...", err) }
type t1 struct { i int; s string } var v1 reflect.Type =
var v1 reflect.Type = reflect.TypeOf((*t1)(nil)).Elem() fmt.Println(v1)
package main import "fmt" type Thing interface { Item() float64 SetItem(float64) } func newThing() Thing { item := 0.0 return struct { Item (func() float64) SetItem (func(float64)) }{ Item: func() float64 { return item }, SetItem: func(x float64) { item = x }, } } func main() { thing := newThing() fmt.Println("Hello, playground") fmt.Println(thing) }
type ProtoThing struct { itemMethod func() float64 setItemMethod func(float64) } func (t ProtoThing) Item() float64 { return t.itemMethod() } func (t ProtoThing) SetItem(x float64) { t.setItemMethod(x) } t := struct { ProtoThing }{} t.itemMethod = func() float64 { return 2.0 } t.setItemMethod = func(x float64) { item = x }
package main import "fmt" type Thing interface { Item() float64 SetItem(float64) } type thingImpl struct { item func() float64 setItem func(float64) } func (i thingImpl) Item() float64 { return i.item() } func (i thingImpl) SetItem(v float64) { i.setItem(v) } func newThing() Thing { item := 0.0 return thingImpl{ item: func() float64 { return item }, setItem: func(x float64) { item = x }, } } func main() { thing := newThing() fmt.Println("Hello, playground") fmt.Println(thing) }
package main import "fmt" import "reflect" type Vector struct { x int y int } func main() { v := &Vector{} x := new(Vector) fmt.Println(reflect.TypeOf(v)) fmt.Println(reflect.TypeOf(x)) }
bin/ hello pkg/ linux_amd64/ github.com/user/ newmath.a src/ github.com/user/ hello/ hello.go newmath/ sqrt.go
$ mkdir $GOPATH/src/github.com/username/newmath $ cd $GOPATH/src/github.com/username/newmath $ git init $ ... more git setup $ touch sqrt.go $ gvim sqrt.go $ git add sqrt.go $ git commit -a -m $ git push
$ mkdir $GOPATH/src/github.com/username/hello $ cd $GOPATH/src/github.com/username/hello $ git init $ ... more git setup $ touch hello.go $ gvim hello.go $ git add hello.go $ git commit -a -m $ git push
$ go get github.com/username/hello $ go install github.com/username/hello
$GOPATH/ src/ github.com/ jmcvetta/ useless/ .git/ useless.go useless_test.go README.md uselessd/ .git/ uselessd.go uselessd_test.go README.md
regexp==== RUN .* colour=blue - regexp=--- PASS: .* colour=green - regexp=^PASS$ colour=green - regexp=^(ok|\?) .* colour=magenta - regexp=--- FAIL: .* colour=red - regexp=[^\s]+\.go(:\d+)? colour=cyan
func assert(tb testing.TB, condition bool, msg string, v ...interface{}) { if !condition { _, file, line, _ := runtime.Caller(1) fmt.Printf("\033[31m%s:%d: "+msg+"\033[39m\n\n", append([]interface{}{filepath.Base(file), line}, v...)...) tb.FailNow() } }
package main import ( "fmt" "strings" ) func TrimSuffix(s, suffix string) string { if strings.HasSuffix(s, suffix) { s = s[:len(s)-len(suffix)] } return s } func main() { s := "a string ++" fmt.Println("s: ", s) s1 := s if last := len(s1) - 1; last >= 0 && s1[last] == s1 = s1[:last] } fmt.Println("s1:", s1) s2 := s s2 = strings.TrimRight(s2, "+") fmt.Println("s2:", s2) s3 := s s3 = TrimSuffix(s3, "+") fmt.Println("s3:", s3) }
s: a string ++ s1: a string + s2: a string s3: a string +
s := "mystring+" sz := len(s) if sz > 0 && s[sz-1] == s = s[:sz-1] }
package main import ( "fmt" "io/ioutil" "strconv" "strings" "time" ) func getCPUSample() (idle, total uint64) { contents, err := ioutil.ReadFile("/proc/stat") if err != nil { return } lines := strings.Split(string(contents), "\n") for _, line := range(lines) { fields := strings.Fields(line) if fields[0] == "cpu" { numFields := len(fields) for i := 1; i < numFields; i++ { val, err := strconv.ParseUint(fields[i], 10, 64) if err != nil { fmt.Println("Error: ", i, fields[i], err) } total += val if i == 4 { idle = val } } return } } return } func main() { idle0, total0 := getCPUSample() time.Sleep(3 * time.Second) idle1, total1 := getCPUSample() idleTicks := float64(idle1 - idle0) totalTicks := float64(total1 - total0) cpuUsage := 100 * (totalTicks - idleTicks) / totalTicks fmt.Printf("CPU usage is %f%% [busy: %f, total: %f]\n", cpuUsage, totalTicks-idleTicks, totalTicks) }
stat, err := linuxproc.ReadStat("/proc/stat") if err != nil { t.Fatal("stat read fail") } for _, s := range stat.CPUStats { }
package main import ( "bytes" "log" "os/exec" "strconv" "strings" ) type Process struct { pid int cpu float64 } func main() { cmd := exec.Command("ps", "aux") var out bytes.Buffer cmd.Stdout = &out err := cmd.Run() if err != nil { log.Fatal(err) } processes := make([]*Process, 0) for { line, err := out.ReadString( if err!=nil { break; } tokens := strings.Split(line, " ") ft := make([]string, 0) for _, t := range(tokens) { if t!="" && t!="\t" { ft = append(ft, t) } } log.Println(len(ft), ft) pid, err := strconv.Atoi(ft[1]) if err!=nil { continue } cpu, err := strconv.ParseFloat(ft[2], 64) if err!=nil { log.Fatal(err) } processes = append(processes, &Process{pid, cpu}) } for _, p := range(processes) { log.Println("Process ", p.pid, " takes ", p.cpu, " % of the CPU") } }
import "C" import "time" var startTime = time.Now() var startTicks = C.clock() func CpuUsagePercent() float64 { clockSeconds := float64(C.clock()-startTicks) / float64(C.CLOCKS_PER_SEC) realSeconds := time.Since(startTime).Seconds() return clockSeconds / realSeconds * 100 }
func calcSingleCoreUsage(curr, prev linuxproc.CPUStat) float32 { PrevIdle := prev.Idle + prev.IOWait Idle := curr.Idle + curr.IOWait PrevNonIdle := prev.User + prev.Nice + prev.System + prev.IRQ + prev.SoftIRQ + prev.Steal NonIdle := curr.User + curr.Nice + curr.System + curr.IRQ + curr.SoftIRQ + curr.Steal PrevTotal := PrevIdle + PrevNonIdle Total := Idle + NonIdle totald := Total - PrevTotal idled := Idle - PrevIdle CPU_Percentage := (float32(totald) - float32(idled)) / float32(totald) return CPU_Percentage }
thinkerou@MacBook-Pro-thinkerou:~/xyz/src/ou$ pwd /Users/baidu/xyz/src/ou thinkerou@MacBook-Pro-thinkerou:~/xyz/src/ou$ ls main.go vendor
thinkerou@MacBook-Pro-thinkerou:~/xyz/src/ou$ ls main.go vendor thinkerou@MacBook-Pro-thinkerou:~/xyz/src/ou$ cd vendor/ thinkerou@MacBook-Pro-thinkerou:~/xyz/src/ou/vendor$ ls vendor.json thinkerou@MacBook-Pro-thinkerou:~/xyz/src/ou/vendor$ cd ../.. thinkerou@MacBook-Pro-thinkerou:~/xyz/src$ ls github.com ou thinkerou@MacBook-Pro-thinkerou:~/xyz/src$ cd github.com/ thinkerou@MacBook-Pro-thinkerou:~/xyz/src/github.com$ ls zenazn
{ "comment": "", "package": [ { "path": "github.com/zenazn/goji" } ] }
./vendor/github.com/zenazn/goji $GOPATH/src/github.com/zenazn/goji $GOROOT/src/github.com/zenazn/goji
mkdir -p $GOPATH/src/ou/vendor/github.com/zenazn/goji cp -r $GOPATH/src/github.com/zenazn/goji/ $GOPATH/src/ou/vendor/github.com/zenazn/goji
b := []byte{} something, err := rand.Read(b) fmt.Printf("something = %v\n", something) fmt.Printf("err = %v\n", err)
package main import "encoding/binary" import "crypto/rand" func main() { var n int32 binary.Read(rand.Reader, binary.LittleEndian, &n) println(n) }
package main import ( "fmt" "math/rand" "time" ) func main() { rand.Seed(time.Now().Unix()) fmt.Println(rand.Int()) }
package main import "fmt" import "time" import "math/rand" func main() { rand.Seed(time.Now().UnixNano()) fmt.Println(rand.Intn(100)) }
package main import "fmt" type name struct { X string } func main() { var a [3]name a[0] = name{"Abbed"} a[1] = name{"Ahmad"} a[2] = name{"Ghassan"} nameReader(a) } func nameReader(array []name) { for i := 0; i < len(array); i++ { fmt.Println(array[i].X) } }
.\structtest.go:15: cannot use a (type [3]name) as type []name in function argument
a := [3]int{1, 2, 3} b := a a[0] = 0 fmt.Println(a) fmt.Println(b)
a := []int{1, 2, 3} b := a a[0] = 0 fmt.Println(a) fmt.Println(b)
type int-slice struct { data *int len int cap int }
a := [5]int{1, 2, 3, 4, 5} b := a[1:4] fmt.Println(b)
a := []int{1, 2, 3} b := a[0:1] fmt.Println(b) b = b[0:3] fmt.Println(b)
package main import "fmt" type name struct { X string } func main() { a := [3]name{{"Abbed"}, {"Ahmed"}, {"Ghassan"}} nameReader(a[:]...) } func nameReader(a ...name) { for _, n := range a { fmt.Println(n.X) } }
package main import "fmt" func main() { var i []int i = make([]int, 2) i[0] = 3 i[1] = 4 fmt.Printf("Val - %d\n", i[0]) a(i) fmt.Printf("Val - %d\n", i[0]) } func a(i []int) { fmt.Printf("Val - %d\n", i[0]) i[0] = 33 fmt.Printf("Val - %d\n", i[0]) }
package main import "fmt" type name struct { X string } func main() { a := []name{name{"Abbed"}, name{"Ahmad"}, name{"Ghassan"}} nameReader(a) } func nameReader(array []name) { for i := 0; i < len(array); i++ { fmt.Println(array[i].X) } }
type numbers [1024*1024]int var nums *numbers = new(numbers)
nums[0] = 10 doSomething(nums) func doSomething(nums *numbers){ temp := nums[0] ... }
fs := http.FileServer(http.Dir("static")) http.Handle("/static/", http.StripPrefix("/static/", fs)) http.HandleFunc("/static2/", func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, r.URL.Path[1:]) }) http.ListenAndServe(":8080", nil)
fs := http.FileServer(http.Dir("/home/bob/static")) http.Handle("/static/", http.StripPrefix("/static", fs))
package main import ( "fmt" "io/ioutil" "os" ) func main() { bytes, _ := ioutil.ReadAll(os.Stdin) if len(bytes) > 0 { fmt.Println("Something on STDIN: " + string(bytes)) } else { fmt.Println("Nothing on STDIN") } }
stat, _ := os.Stdin.Stat() if (stat.Mode() & os.ModeCharDevice) == 0 { fmt.Println("data is being piped to stdin") } else { fmt.Println("stdin is from a terminal") }
package main import ( "fmt" "github.com/andrew-d/go-termutil" "io" "os" ) func main() { if termutil.Isatty(os.Stdin.Fd()) { fmt.Println("Nothing on STDIN") } else { fmt.Println("Something on STDIN") io.Copy(os.Stdout, os.Stdin) } }
$ ./isatty Nothing on STDIN $ echo "hello" | ./isatty Something on STDIN hello $ (sleep 1 ; echo "hello") | ./isatty Something on STDIN hello
stat, err := os.Stdin.Stat() if err != nil { return nil, fmt.Errorf("you have an error in stdin:%s", err) } if (stat.Mode() & os.ModeNamedPipe) == 0 { return nil, errors.New("you should pass smth to stdin") }
package main import ( "bufio" "fmt" "os" ) func main() { in := bufio.NewReader(os.Stdin) stats, err := os.Stdin.Stat() if err != nil { fmt.Println("file.Stat()", err) } if stats.Size() > 0 { in, _, err := in.ReadLine() if err != nil { fmt.Println("reader.ReadLine()", err) } fmt.Println("Something on STDIN: " + string(in)) } else { fmt.Println("Nothing on STDIN") } }
type tySurvey struct { Id int64 `json:"id,omitempty"` Name string `json:"name,omitempty"` }
json: cannot unmarshal string into Go value of type int64
type tySurvey struct { Id int64 `json:"id,string,omitempty"` Name string `json:"name,omitempty"` }
buffer := bytes.NewBufferString("") funcMap := template.FuncMap{ "label": strings.Title, } t, _ := template.New("alex").Funcs(funcMap).Parse("{{label \"alex\"}}") t.Execute(buffer, "") return string(buffer.Bytes())
t, _ := template.New("alex").Funcs(funcMap).ParseFiles("template.html")
t, err := template.New("_base.html").Funcs(funcs).ParseFiles("../view/_base.html", "../view/home.html") if err != nil { fmt.Fprint(w, "Error:", err) fmt.Println("Error:", err) return } err = t.Execute(w, data) if err != nil { fmt.Fprint(w, "Error:", err) fmt.Println("Error:", err) }
<!DOCTYPE html> <html><body> <h1>{{ template "title" }}</h1> {{ template "content" }} </body></html>
{{ define "title" }}Home{{ end }} {{ define "content" }} Stuff {{ end }}
package main import ("net/http";"io/ioutil") func main() { resp, err := http.Get("http: check(err) defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) check(err) err = ioutil.WriteFile("./data.txt", body, 0666) check(err) } func check(e error) { if e != nil { panic(e) } }
func main() { resp, err := http.Get("...") check(err) defer resp.Body.Close() out, err := os.Create("filename.ext") if err != nil { } defer out.Close() io.Copy(out, resp.Body) }
func conv(x []int, xlen int, h []int, hlen int, y *[]int) for i := 0; i<xlen; i++ { for j := 0; j<hlen; j++ { *y[i+j] += x[i]*h[j] } } }
sean@spray:~/dev$ 8g broke.go broke.go:8: invalid operation: y[i + j] (index of type *[]int)
func conv(x []int, xlen int, h []int, hlen int, y_ *[]int) { y := *y_ for i := 0; i<xlen; i++ { for j := 0; j<hlen; j++ { y[i+j] += x[i]*h[j] } } }
09 func sum(a []int) int { 10 s := 0 11 for i := 0; i < len(a); i++ { 12 s += a[i] 13 } 14 return s 15 }
package main import "fmt" func sumPointerToArray(a *[8]int) (sum int) { for _, value := range *a { sum += value } return } func sumSlice (a []int) (sum int) { for _, value := range a { sum += value } return } func main() { array := [...]int{ 1, 2, 3, 4, 5, 6, 7, 8 } slice := []int{ 1, 2, 3, 4 } fmt.Printf("sum arrray via pointer: %d\n", sumPointerToArray(&array)) fmt.Printf("sum slice: %d\n", sumSlice(slice)) slice = array[0:] fmt.Printf("sum array as slice: %d\n", sumSlice(slice)) }
func conv(x, h []int) []int { y := make([]int, len(x)+len(h)) for i, v := range x { for j, u := range h { y[i+j] = v * u } } return y }
package main import "fmt" func conv(x, h []int) []int { y := make([]int, len(x)+len(h)-1) for i := 0; i < len(x); i++ { for j := 0; j < len(h); j++ { y[i+j] += x[i] * h[j] } } return y } func main() { x := []int{1, 2} h := []int{7, 8, 9} y := conv(x, h) fmt.Println(len(y), y) }
import ( "log" "net/http" "github.com/foo/bar/myapp/common" "github.com/foo/bar/myapp/routers" )
myapp/main.go:7:3: cannot find package "common" in any of: /usr/local/go/src/common (from $GOROOT) /home/me/go/src/common (from $GOPATH) myapp/main.go:8:2: cannot find package "routers" in any of: /usr/local/go/src/routers (from $GOROOT) /home/me/go/src/routers (from $GOPATH)
import ( "log" "net/http" "myapp/common" "myapp/routers" )
myapp/ --vendor/ ----common/ ----routers/ ------middleware/ --main.go
package main import ( "fmt" "regexp" ) var myExp = regexp.MustCompile(`(?P<first>\d+)\.(\d+).(?P<second>\d+)`) func main() { fmt.Printf("%+v", myExp.FindStringSubmatch("1234.5678.9")) match := myExp.FindStringSubmatch("1234.5678.9") for i, name := range myExp.SubexpNames() { fmt.Printf(" } }
package main import ( "fmt" "regexp" ) var myExp = regexp.MustCompile(`(?P<first>\d+)\.(\d+).(?P<second>\d+)`) func main() { match := myExp.FindStringSubmatch("1234.5678.9") result := make(map[string]string) for i, name := range myExp.SubexpNames() { if i != 0 && name != "" { result[name] = match[i] } } fmt.Printf("by name: %s %s\n", result["first"], result["second"]) }
func reSubMatchMap(r *regexp.Regexp, str string) (map[string]string) { match := r.FindStringSubmatch(str) subMatchMap := make(map[string]string) for i, name := range r.SubexpNames() { if i != 0 { subMatchMap[name] = match[i] } } return subMatchMap }
func findNamedMatches(regex *regexp.Regexp, str string) map[string]string { match := regex.FindStringSubmatch(remote) results := map[string]string{} for i, name := range match { results[repoRegex.SubexpNames()[i]] = name } return results }
var settings struct { serverMode bool sourceDir string targetDir string } func main() { configFile, err := os.Open("config.json") if err != nil { printError("opening config file", err.Error()) } jsonParser := json.NewDecoder(configFile) if err = jsonParser.Decode(&settings); err != nil { printError("parsing config file", err.Error()) } fmt.Printf("%v %s %s", settings.serverMode, settings.sourceDir, settings.targetDir) return }
{ "serverMode": true, "sourceDir": ".", "targetDir": "." }
var settings struct { ServerMode bool `json:"serverMode"` SourceDir string `json:"sourceDir"` TargetDir string `json:"targetDir"` }
client := &http.Client{} req, err := http.NewRequest("GET", "http: req.SetBasicAuth("<username>","<password>") resp, err := client.Do(req) if err != nil { fmt.Printf("Error : %s", err) } req.URL, _ = url.Parse("http: resp, err = client.Do(req) if err != nil { fmt.Printf("Error : %s", err) }
type myjar struct { jar map[string] []*http.Cookie } func (p* myjar) SetCookies(u *url.URL, cookies []*http.Cookie) { fmt.Printf("The URL is : %s\n", u.String()) fmt.Printf("The cookie being set is : %s\n", cookies) p.jar [u.Host] = cookies } func (p *myjar) Cookies(u *url.URL) []*http.Cookie { fmt.Printf("The URL is : %s\n", u.String()) fmt.Printf("Cookie being returned is : %s\n", p.jar[u.Host]) return p.jar[u.Host] }
jar := &myjar{} jar.jar = make(map[string] []*http.Cookie) client.Jar = jar
package main import "fmt" func main() { var whatever [5]struct{} for i := range whatever { fmt.Println(i) } for i := range whatever { defer func() { fmt.Println(i) }() } for i := range whatever { defer func(n int) { fmt.Println(n) }(i) } }
package main import ( "fmt" ) type Component struct { val int } func (c Component) method() { fmt.Println(c.val) } func main() { c := Component{} defer c.method() c.val = 2 }
package main import ( "net/http" ) func main() { http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static")))) http.ListenAndServe(":8080", nil) }
%GOPATH%/src/project_name/main.go %GOPATH%/src/project_name/static/..files and folders ..
http.Handle("/tmpfiles/", http.StripPrefix("/tmpfiles/", http.FileServer(http.Dir("/tmp"))))
http.Handle("/static/", http.FileServer(http.Dir("static"))
func AddResourceHandler(rw http.ResponseWriter, r *http.Request) { switch r.Method { case "OPTIONS": case "PUT": } }
r := mux.NewRouter() r.HandleFunc("/someresource/item", AddResourceHandler).Methods("PUT") r.HandleFunc("/someresource/item", PreflightAddResourceHandler).Methods("OPTIONS")
func corsHandler(h http.Handler) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { if (r.Method == "OPTIONS") { } else { h.ServeHTTP(w,r) } } }
http.Handle("/endpoint/", corsHandler(restHandler))
router.Methods("OPTIONS").HandlerFunc( func(w http.ResponseWriter, r *http.Request){ myHttpLib.OptionsForBrowserPreflight(w, r) })
addCorsHeader(res) if req.Method == "OPTIONS" { res.WriteHeader(http.StatusOK) return } else { h.APIHandler.ServeHTTP(res, req) } func addCorsHeader(res http.ResponseWriter) { headers := res.Header() headers.Add("Access-Control-Allow-Origin", "*") headers.Add("Vary", "Origin") headers.Add("Vary", "Access-Control-Request-Method") headers.Add("Vary", "Access-Control-Request-Headers") headers.Add("Access-Control-Allow-Headers", "Content-Type, Origin, Accept, token") headers.Add("Access-Control-Allow-Methods", "GET, POST,OPTIONS") }
import ( "net/http" "github.com/gorilla/handlers" "github.com/gorilla/mux" ) func main() { r := mux.NewRouter() r.HandleFunc("/users", UserEndpoint) r.HandleFunc("/projects", ProjectEndpoint) http.ListenAndServe(":8000", handlers.CORS()(r)) }
cmd := exec.Command("find", "/", "-maxdepth", "1", "-exec", "wc", "-c", "{}", "\\") var out bytes.Buffer cmd.Stdout = &out err := cmd.Run() if err != nil { fmt.Println(err) return } fmt.Println("Result: " + out.String())
cmd := exec.Command("find", "/", "-maxdepth", "1", "-exec", "wc", "-c", "{}", "\\") var out bytes.Buffer var stderr bytes.Buffer cmd.Stdout = &out cmd.Stderr = &stderr err := cmd.Run() if err != nil { fmt.Println(fmt.Sprint(err) + ": " + stderr.String()) return } fmt.Println("Result: " + out.String())
cmd := exec.Command("find", "/", "-maxdepth", "1", "-exec", "wc", "-c", "{}", "\\") output, err := cmd.CombinedOutput() if err != nil { fmt.Println(fmt.Sprint(err) + ": " + string(output)) return } fmt.Println(string(output))
Tunnel Status online Version 1.3/1.3 Forwarding http: Forwarding https: Web Interface http: Avg Conn Time 0.00ms
package singleton type single struct { O interface{}; } var instantiated *single = nil func New() *single { if instantiated == nil { instantiated = new(single); } return instantiated; }
package singleton import "sync" type single struct { O interface{}; } var instantiated *single var once sync.Once func New() *single { once.Do(func() { instantiated = &single{} }) return instantiated }
if instantiated == nil { instantiated = new(single); }
import "sync" type MySingleton struct { } var _init_ctx sync.Once var _instance *MySingleton func New() * MySingleton { _init_ctx.Do( func () { _instance = new(MySingleton) } ) return _instance }
package singleton import "sync" type singleton struct { } var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = &singleton{} }) return instance }
package main import ( "errors" "fmt" ) func main() { err := errors.New("an error message") s := err.Error() fmt.Printf("type: %T; value: %q\n", s, s) }
package main import ( "fmt" "errors" "runtime" ) func main() { err := errors.New("use of err.String() detected!") s := err.Error() fmt.Printf( "version: %s\ntypes: %T / %T\nstring value via err.Error(): %q\n", runtime.Version(), err, s, s) }
go run main102.go version: go1.0.2 types: *errors.errorString / string string value via err.Error(): "use of err.String() detected!"
type Clock interface { Now() time.Time After(d time.Duration) <-chan time.Time }
type realClock struct{} func (realClock) Now() time.Time { return time.Now() } func (realClock) After(d time.Duration) <-chan time.Time { return time.After(d) }
package main import ( "fmt" "time" "github.com/bouk/monkey" ) func main() { wayback := time.Date(1974, time.May, 19, 1, 2, 3, 4, time.UTC) patch := monkey.Patch(time.Now, func() time.Time { return wayback }) defer patch.Unpatch() fmt.Printf("It is now %s\n", time.Now()) }
package foo import ( "testing" "time" ) var Now = func() time.Time { return ... }
func moonPhase(now func() time.Time) { if now == nil { now = time.Now } } moonPhase(nil) stubNow := func() time.Time { return time.Unix(1515151515, 0) } moonPhase(stubNow)
func (s *Service) Callback(r *http.Request, req *RequestOauth, resp *Response) error { c := endpoints.NewContext(r) consumer.HttpClient=urlfetch.Client(c) ====>requestToken := *oauth.RequestToken{Token:req.Oauth_token, Secret:""}<====== b, err := TwitterApi(requestToken, req.Oauth_verifier) resp.Message=b.Name return err } func TwitterApi(requestToken *oauth.RequestToken, verificationCode string) (u *UserT, err error) { accessToken, err := consumer.AuthorizeToken(requestToken, verificationCode) if err != nil {log.Fatal(err)} response, err := consumer.Get("https: if err != nil {log.Fatal(err)} defer response.Body.Close() b, err := ioutil.ReadAll(response.Body) err = json.Unmarshal(b, &u) return }
requestToken := *oauth.RequestToken{Token:req.Oauth_token, Secret:""}
requestToken := &oauth.RequestToken{Token:req.Oauth_token, Secret:""}
requestToken := oauth.RequestToken{Token:req.Oauth_token, Secret:""} b, err := TwitterApi(&requestToken, req.Oauth_verifier)
requestToken := &oauth.RequestToken{Token:req.Oauth_token, Secret:""}
requestToken := oauth.RequestToken{Token:req.Oauth_token, Secret:""}
b, err := TwitterApi(&requestToken, req.Oauth_verifier)
{{with .Inner}} Outer: {{$.OuterValue}} Inner: {{.InnerValue}} {{end}}
{{ $save := . }} {{ with .Inner }} Outer: {{ $save.OuterValue }} Inner: {{ .InnerValue }} {{ end }}
log.Println("The amount is: " + strconv.Itoa((charge.Amount)))
log.Println("The amount is: " + strconv.Itoa(int(charge.Amount)))
log.Println("The amount is: " + strconv.FormatUint(charge.Amount, 10))
log.Println("The amount is:", charge.Amount) log.Printf("The amount is: %d\n", charge.Amount)
package main import ( "fmt" "hash/fnv" ) func hash(s string) uint32 { h := fnv.New32a() h.Write([]byte(s)) return h.Sum32() } func main() { fmt.Println(hash("HelloWorld")) fmt.Println(hash("HelloWorld.")) }
func FNV32a(text string) uint32 { algorithm := fnv.New32a() algorithm.Write([]byte(text)) return algorithm.Sum32() }
func merge(array []int, start, middle, end int) { leftLength := middle - start + 1 rightLength := end - middle var left [leftLength]int var right [rightLength]int }
./mergesort.go:6: non-constant array bound leftLength ./mergesort.go:7: non-constant array bound rightLength
Usage of ./mysqlcsvdump: -compress-file=false: whether compress connection or not -hostname="": database host -outdir="": where output will be stored -password="": database password -port=3306: database port -single-transaction=true: whether to wrap everything in a transaction or not. -skip-header=false: whether column header should be included or not -user="root": database user
Usage: ./mysqlcsvdump [options] [table1 table2 ... tableN] Parameters: -compress-file=false: whether compress connection or not -hostname="": database host -outdir="": where output will be stored -password="": database password -port=3306: database port -single-transaction=true: whether to wrap everything in a transaction or not. -skip-header=false: whether column header should be included or not -user="root": database user
var Usage = func() { fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0]) flag.PrintDefaults() }
flag.Usage = func() { fmt.Fprintf(os.Stderr, "This is not helpful.\n") }
-test.bench pattern Run benchmarks matching the regular expression. By default, no benchmarks run. -test.run pattern Run only those tests and examples matching the regular expression.
go test -test.bench MapTravel go test -test.bench MapGet
go test -test.bench MapTravel -test.run=thisexpressionwontmatchanytest
x := float32(3.1) y,_ := strconv.Atoi((strconv.Ftoa32(x,
type Something struct { Id bson.ObjectId "_id,omitempty" Name string }
struct { microsec uint64 "field 1" serverIP6 uint64 "field 2" process string "field 3" }
const ( paragraph_hypothesis = 1<<iota paragraph_attachment = 1<<iota paragraph_menu = 1<<iota ) type Paragraph struct { Type int }
{{range .Paragraphs}} {{if .IsAttachment}} -- attachement presentation code -- {{else}}{{if .IsMenu}} -- menu -- {{else}} -- default code -- {{end}}{{end}} {{end}}
{{if .IsAttachment}} -- attachment presentation code -- {{end}} {{if .IsMenu}} -- menu -- {{end}} {{if .IsDefault}} -- default code -- {{end}}
package main import ( "fmt" "os" "html/template" ) func main() { const ( paragraph_hypothesis = 1 << iota paragraph_attachment = 1 << iota paragraph_menu = 1 << iota ) const text = "{{.Paratype | printpara}}\n" type Paragraph struct { Paratype int } var paralist = []*Paragraph{ &Paragraph{paragraph_hypothesis}, &Paragraph{paragraph_attachment}, &Paragraph{paragraph_menu}, } t := template.New("testparagraphs") printPara := func(paratype int) string { text := "" switch paratype { case paragraph_hypothesis: text = "This is a hypothesis\n" case paragraph_attachment: text = "This is an attachment\n" case paragraph_menu: text = "Menu\n1:\n2:\n3:\n\nPick any option:\n" } return text } template.Must(t.Funcs(template.FuncMap{"printpara": printPara}).Parse(text)) for _, p := range paralist { err := t.Execute(os.Stdout, p) if err != nil { fmt.Println("executing template:", err) } } }
$ echo $GOPATH && ls -r $GOPATH /home/cyrus/.go src pkg bin $ echo $GOROOT && ls $GOROOT /usr/local/go api AUTHORS bin CONTRIBUTORS doc favicon.ico include lib LICENSE misc PATENTS pkg README robots.txt src test VERSION
$ go get code.google.com/p/go-tour/gotour package code.google.com/p/go-tour/gotour: cannot download, $GOPATH not set. For more details see: go help gopath
package main import "myApp/database" func main() { var err error database.DBCon, err = sql.Open("postgres", "user=myname dbname=dbname sslmode=disable") }
package user import "myApp/database" func Index() { database.DBCon ... }
var DB *sql.DB func GetAllStuff() (*Stuff, error) { err := DB.Query("...") } var DB *sql.DB func GetAllThings() (*Thing, error) { err := DB.Query("...") } func main() { db, err := sql.Open("...") if err != nil { log.Fatal(err) } stuff.DB = db things.DB = db }
type DB struct { *sql.DB } func New(db *sql.DB) (*DB, error) { return &DB{db}, nil } func (db *DB) GetAllStuff() (*Stuff, error) { err := db.Query("...") } type DB struct { *sql.DB } func New(db *sql.DB) (*DB, error) { return &DB{db}, nil } func (db *DB) GetAllThings() (*Thing, error) { err := db.Query("...") } func main() { db, err := sql.Open("...") if err != nil { log.Fatal(err) } stuffDB, err := stuff.New(db) if err != nil { log.Fatal(err) } thingsDB, err := things.New(db) if err != nil { log.Fatal(err) } http.HandleFunc("/stuff/all", stuff.ShowStuffHandler(stuffDB)) http.HandleFunc("/things/all", things.ShowThingsHandler(thingsDB)) } func ShowStuffHandler(db *stuff.DB) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { stuff, err := db.GetAllStuff() } }
type somethingFuncy func(int) bool func funcy(i int) bool { return i%2 == 0 } var a interface{} = funcy func main() { _ = a.(func(int) bool) fmt.Println("Awesome -- apparently, literally specifying the func signature works.") _ = a.(somethingFuncy) fmt.Println("Darn -- doesn }
var a interface{} = int(10) var b MyInt = a.(MyInt)
func trace() { pc := make([]uintptr, 10) runtime.Callers(2, pc) f := runtime.FuncForPC(pc[0]) file, line := f.FileLine(pc[0]) fmt.Printf("%s:%d %s\n", file, line, f.Name()) }
func trace2() { pc := make([]uintptr, 15) n := runtime.Callers(2, pc) frames := runtime.CallersFrames(pc[:n]) frame, _ := frames.Next() fmt.Printf("%s,:%d %s\n", frame.File, frame.Line, frame.Function) }
var b bytes.Buffer w := gzip.NewWriter(&b) w.Write([]byte("hello, world\n")) w.Close()
r, err := gzip.NewReader(&b) io.Copy(os.Stdout, r) r.Close()
func ReadGzFile(filename string) ([]byte, error) { fi, err := os.Open(filename) if err != nil { return nil, err } defer fi.Close() fz, err := gzip.NewReader(fi) if err != nil { return nil, err } defer fz.Close() s, err := ioutil.ReadAll(fz) if err != nil { return nil, err } return s, nil }
import ( "bytes" "compress/gzip" "io/ioutil" ) var b bytes.Buffer w := gzip.NewWriter(&b) w.Write([]byte("hello, world\n")) w.Close() err := ioutil.WriteFile("hello_world.txt.gz", b.Bytes(), 0666)
func UnpackGzipFile(gzFilePath, dstFilePath string) (int64, error) { gzFile, err := os.Open(gzFilePath) if err != nil { return 0, fmt.Errorf("Failed to open file %s for unpack: %s", gzFilePath, err) } dstFile, err := os.OpenFile(dstFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0660) if err != nil { return 0, fmt.Errorf("Failed to create destination file %s for unpack: %s", dstFilePath, err) } ioReader, ioWriter := io.Pipe() go func() { gzReader, _ := gzip.NewReader(gzFile) defer func(){ gzFile.Close() gzReader.Close() ioWriter.Close() }() io.Copy(ioWriter, gzReader) }() written, err := io.Copy(dstFile, ioReader) if err != nil { return 0, err } ioReader.Close() dstFile.Close() return written, nil }
package main import ( "compress/gzip" "fmt" "io/ioutil" "os" ) var zipFile = "zipfile.gz" func main() { writeZip() readZip() } func writeZip() { handle, err := openFile(zipFile) if err != nil { fmt.Println("[ERROR] Opening file:", err) } zipWriter, err := gzip.NewWriterLevel(handle, 9) if err != nil { fmt.Println("[ERROR] New gzip writer:", err) } numberOfBytesWritten, err := zipWriter.Write([]byte("Hello, World!\n")) if err != nil { fmt.Println("[ERROR] Writing:", err) } err = zipWriter.Close() if err != nil { fmt.Println("[ERROR] Closing zip writer:", err) } fmt.Println("[INFO] Number of bytes written:", numberOfBytesWritten) closeFile(handle) } func readZip() { handle, err := openFile(zipFile) if err != nil { fmt.Println("[ERROR] Opening file:", err) } zipReader, err := gzip.NewReader(handle) if err != nil { fmt.Println("[ERROR] New gzip reader:", err) } defer zipReader.Close() fileContents, err := ioutil.ReadAll(zipReader) if err != nil { fmt.Println("[ERROR] ReadAll:", err) } fmt.Printf("[INFO] Uncompressed contents: %s\n", fileContents) // closeFile(handle) } func openFile(fileToOpen string) (*os.File, error) { return os.OpenFile(fileToOpen, openFileOptions, openFilePermissions) } func closeFile(handle *os.File) { if handle == nil { return } err := handle.Close() if err != nil { fmt.Println("[ERROR] Closing file:", err) } } const openFileOptions int = os.O_CREATE | os.O_RDWR const openFilePermissions os.FileMode = 0660
type Machine struct { m_ip string m_type string m_serial string }
m:= &Machine{ m_ip:"test", m_type:"test", m_serial:"test" } m_json:= json.Marshal(m) fmt.Println(m_json)
type Machine struct{ MachIp string MachType string MachSerial string }
type Machine struct{ MachIp string `json:"m_ip"` MachType string `json:"m_type"` MachSerial string `json:"m_serial"` }
var animals Animal err := json.Unmarshal(jsonBlob, &animals)
var animals *Animal err := json.Unmarshal(jsonBlob, animals)
/main.py /settings/routes.py contains main routes depends on app1/routes.py, app2/routes.py etc /settings/database.py function like connect() which opens db session /settings/constants.py general constants /apps/app1/views.py url handler functions /apps/app1/models.py app specific database functions depends on settings/database.py /apps/app1/routes.py app specific routes /apps/app2/views.py url handler functions /apps/app2/models.py app specific database functions depends on settings/database.py /apps/app2/routes.py app specific routes
type DB struct { *sql.DB } var db *DB func init() { dbinfo := fmt.Sprintf("user=%s password=%s dbname=%s sslmode=disable", DB_USER, DB_PASSWORD, DB_NAME) db, err := NewDB(dbinfo) checkErr(err) rows, err := db.Query("SELECT * FROM profile") checkErr(err) fmt.Println(rows) } func NewDB(dataSourceName string) (*DB, error) { db, err := sql.Open("postgres", dataSourceName) if err != nil { return nil, err } if err = db.Ping(); err != nil { return nil, err } return &DB{db}, nil }
func (p *Profile) InsertProfile() { if db != nil { _, err := db.Exec(...) checkErr(err) } else { fmt.Println("DB object is NULL") } }
var err error db, err = NewDB(dbinfo) if err != nil { log.Fatal(err) }
var db *sql.DB func init() { var err error db, err = sql.Open("yourdrivername", "somesource") if err != nil { log.Fatal(err) } if err = db.Ping(); err != nil { log.Fatal(err) } }
package main import "fmt" var foo string = "global" func main() { fmt.Println(foo) foo := "function scope" fmt.Println(foo) printGlobalFoo() if true { foo := "nested scope" fmt.Println(foo) printGlobalFoo() } fmt.Println(foo) printGlobalFoo() if true { foo = "nested scope" } fmt.Println(foo) printGlobalFoo() setGlobalFoo() printGlobalFoo() } func printGlobalFoo() { fmt.Println(foo) } func setGlobalFoo() { foo = "new value" }
type Foo struct { A int `json:"a"` B int `json:"b"` X map[string]interface{} `json:???` }
type _Foo Foo func (f *Foo) UnmarshalJSON(bs []byte) (err error) { foo := _Foo{} if err = json.Unmarshal(bs, &foo); err == nil { *f = Foo(foo) } m := make(map[string]interface{}) if err = json.Unmarshal(bs, &m); err == nil { delete(m, "a") delete(m, "b") f.X = m } return err }
type Foo struct { A int `json:"a"` B int `json:"b"` X map[string]interface{} `json:"-"` } func main() { s := `{"a":1, "b":2, "x":1, "y":1}` f := Foo{} if err := json.Unmarshal([]byte(s), &f); err != nil { panic(err) } if err := json.Unmarshal([]byte(s), &f.X); err != nil { panic(err) } delete(f.X, "a") delete(f.X, "b") fmt.Printf("%+v", f) }
type Foo struct { A int `json:"a"` B int `json:"b"` X map[string]interface{} `json:"-"` } func main() { s := `{"a":1, "b":2, "x":1, "y":1}` f := Foo{} if err := json.Unmarshal([]byte(s), &f.X); err != nil { panic(err) } if n, ok := f.X["a"].(float64); ok { f.A = int(n) } if n, ok := f.X["b"].(float64); ok { f.B = int(n) } delete(f.X, "a") delete(f.X, "b") fmt.Printf("%+v", f) }
var f interface{} s := `{"a":1, "b":2, "x":1, "y":1}` if err := json.Unmarshal([]byte(s), &f); err != nil { panic(err) }
func UnmarshalJsonObject(jsonStr []byte, obj interface{}, otherFields map[string]json.RawMessage) (err error) { objValue := reflect.ValueOf(obj).Elem() knownFields := map[string]reflect.Value{} for i := 0; i != objValue.NumField(); i++ { jsonName := strings.Split(objValue.Type().Field(i).Tag.Get("json"), ",")[0] knownFields[jsonName] = objValue.Field(i) } err = json.Unmarshal(jsonStr, &otherFields) if err != nil { return } for key, chunk := range otherFields { if field, found := knownFields[key]; found { err = json.Unmarshal(chunk, field.Addr().Interface()) if err != nil { return } delete(otherFields, key) } } return }
func UnmarshalJson(input []byte, result interface{}) (map[string]interface{}, error) { foomap := make(map[string]interface{}) json.Unmarshal(input, &foomap) var md mapstructure.Metadata decoder, err := mapstructure.NewDecoder( &mapstructure.DecoderConfig{ Metadata: &md, Result: result, }) if err != nil { return nil, err } if err := decoder.Decode(foomap); err != nil { return nil, err } unused := map[string]interface{}{} for _, k := range md.Unused { unused[k] = foomap[k] } return unused, nil } type Foo struct { A int B int X map[string]interface{} } func main() { s := []byte(`{"a":1, "b":2, "?":3, "??":4}`) var foo Foo unused, err := UnmarshalJson(s, &foo) if err != nil { panic(err) } foo.X = unused fmt.Println(foo) }
package main import ( "fmt" "github.com/ugorji/go/codec" ) type Foo struct { A int B int X map[string]interface{} } func (this *Foo) UnmarshalJSON(jsonStr []byte) (err error) { this.X = make(map[string]interface{}) this.X["a"] = &this.A this.X["b"] = &this.B return codec.NewDecoderBytes(jsonStr, &codec.JsonHandle{}).Decode(&this.X) } func main() { s := `{"a":1, "b":2, "x":3, "y":[]}` f := &Foo{} err := codec.NewDecoderBytes([]byte(s), &codec.JsonHandle{}).Decode(f) fmt.Printf("err = %v\n", err) fmt.Printf("%+v\n", f) }
type student struct { FirstName interface{} `json:"first_name"` MiddleName interface{} `json:"middle_name"` LastName interface{} `json:"last_name"` }
type student struct { FirstName *string `json:"first_name"` MiddleName *string `json:"middle_name"` LastName *string `json:"last_name"` }
type MyType string type MyStruct struct { A MyType `json:"my_type"` } func (c MyType) MarshalJSON() ([]byte, error) { var buf bytes.Buffer if len(string(c)) == 0 { buf.WriteString(`null`) } else { buf.WriteString(`"` + string(c) + `"`) } return buf.Bytes(), nil } func (c *MyType)UnmarshalJSON(in []byte) error { str := string(in) if str == `null` { *c = "" return nil } res := MyType(str) if len(res) >= 2 { res = res[1:len(res)-1] } *c = res return nil }
┌─ oneofone@Oa [/t/tst-tag] └──➜ ls a_test.go b_test.go c_test.go
package tags import "testing" func TestA(t *testing.T) {}
package tags import "testing" func TestB(t *testing.T) {}
package tags import "testing" func TestC(t *testing.T) {}
┌─ oneofone@Oa [/t/tst-tag] └──➜ go test -v . | grep PASS: --- PASS: TestA (0.00 seconds) --- PASS: TestB (0.00 seconds) --- PASS: TestC (0.00 seconds) ┌─ oneofone@Oa [/t/tst-tag] └──➜ go test -v -tags feature1 . | grep PASS: --- PASS: TestA (0.00 seconds) ┌─ oneofone@Oa [/t/tst-tag] └──➜ go test -v -tags feature2 . | grep PASS: --- PASS: TestA (0.00 seconds) --- PASS: TestB (0.00 seconds)
package tags import "testing" func TestA(t *testing.T) {}
package tags import "testing" func TestB(t *testing.T) {}
package tags import "testing" func TestC(t *testing.T) {} ┌─ oneofone@Oa [/t/tst-tag] └──➜ go test -v -tags all | grep PASS: --- PASS: TestA (0.00 seconds) --- PASS: TestB (0.00 seconds) --- PASS: TestC (0.00 seconds) ┌─ oneofone@Oa [/t/tst-tag] └──➜ go test -v -tags feature1 | grep PASS: --- PASS: TestB (0.00 seconds) ┌─ oneofone@Oa [/t/tst-tag] └──➜ go test -v -tags="feature1 feature2" | grep PASS: --- PASS: TestB (0.00 seconds) --- PASS: TestC (0.00 seconds)
package tags import "testing" func TestA1(t *testing.T) {} func TestB1(t *testing.T) {} func TestC1(t *testing.T) {} func TestD1(t *testing.T) {}
┌─ oneofone@Oa [/t/tst-tag] └──➜ go test -run="(A|B)1" -v | grep PASS: --- PASS: TestA1 (0.00 seconds) --- PASS: TestB1 (0.00 seconds) ┌─ oneofone@Oa [/t/tst-tag] └──➜ go test -run="D1" -v | grep PASS: --- PASS: TestD1 (0.00 seconds)
func skipCI(t *testing.T) { if os.GetEnv("CI") != "" { t.Skip("Skipping testing in CI environment") } } func TestNewFeature(t *testing.T) { skipCI(t) }
if testing.Short() { t.Skip("skipping testing in short mode") }
j := `{"bvu62fu6dq": { "name": "john", "age": 23, "xyz": "weu33s" ..... .....} }`
type Person struct { Name string `json:"name"` Age int `json:"age"` } type Info map[string]Person
fmt.Printf("%s: %d\n", info["bvu62fu6dq"].Name, info["bvu62fu6dq"].Age)
$ go env GOARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="darwin" GOOS="darwin" GOPATH="" GORACE="" GOROOT="/usr/local/Cellar/go/1.2.1/libexec" GOTOOLDIR="/usr/local/Cellar/go/1.2.1/libexec/pkg/tool/darwin_amd64" TERM="dumb" CC="clang" GOGCCFLAGS="-g -O2 -fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fno-common" CXX="clang++" CGO_ENABLED="1"
@ /usr/local/Cellar/go/1.2.1/libexec/src/pkg ± % ls archive container errors hash log path strconv text bufio crypto expvar html math reflect strings time builtin database flag image mime regexp sync unicode bytes debug fmt index net runtime syscall unsafe
export GOPATH=/home/user/workspace export GOROOT=/home/user/go export PATH=$GOPATH/bin:$PATH
func get_some_key(m map[int]int) int { for k := range m { return k } return 0 }
i := rand.Intn(len(choices)) var k string for k = range choices { if i == 0 { break } i-- } fmt.Println(k, choices[k])
func randIntMapKey(m map[int]string) int { i := rand.Intn(len(m)) for k := range m { if i == 0 { return k } i-- } panic("never") }
keys := reflect.ValueOf(mapI).MapKeys() return keys[rand.Intn(len(keys))].Interface()
package main import ( "fmt" "reflect" ) type Foo struct { FirstName string `tag_name:"tag 1"` LastName string `tag_name:"tag 2"` Age int `tag_name:"tag 3"` } func inspect(f interface{}) map[string]string { m := make(map[string]string) val := reflect.ValueOf(f).Elem() for i := 0; i < val.NumField(); i++ { valueField := val.Field(i) typeField := val.Type().Field(i) f := valueField.Interface() val := reflect.ValueOf(f) m[typeField.Name] = val.String() } return m } func dump(m map[string]string) { for k, v := range m { fmt.Printf("%s : %s\n", k, v) } } func main() { f := &Foo{ FirstName: "Drew", LastName: "Olson", Age: 30, } a := inspect(f) dump(a) }
FirstName : Drew LastName : Olson Age : <int Value>
switch val.Kind() { case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: m[typeField.Name] = strconv.FormatInt(val.Int(), 10) case reflect.String: m[typeField.Name] = val.String() }
package main import "os" import "log" import "io/ioutil" func main() { bytes, err := ioutil.ReadAll(os.Stdin) log.Println(err, string(bytes)) }
import "os" import "log" import "bufio" func main() { s := bufio.NewScanner(os.Stdin) for s.Scan() { log.Println("line", s.Text()) } }
package main import ( "code.google.com/p/go.crypto/ssh/terminal" "fmt" "io/ioutil" "os" ) func main() { if ! terminal.IsTerminal(0) { b, _ := ioutil.ReadAll(os.Stdin) fmt.Print(string(b)) } else { fmt.Println("no piped data") } }
fmt.Println("Enter position to delete::") fmt.Scanln(&pos) new_arr:=make([]int,(len(arr)-1)) k:=0 for i:=0;i<(len(arr)-1);{ if(i!=pos){ new_arr[i]=arr[k] k++ i++ }else{ k++ } } for i:=0;i<(len(arr)-1);i++{ fmt.Println(new_arr[i]) }
func remove(slice []int, s int) []int { return append(slice[:s], slice[s+1:]...) }
func remove(s []int, i int) []int { s[len(s)-1], s[i] = s[i], s[len(s)-1] return s[:len(s)-1] }
func remove(s []int, i int) []int { s[i] = s[len(s)-1] return s[:len(s)-1] }
func remove(s []int, i int) []int { s[i] = s[len(s)-1] return s[:len(s)-1] }
package main import ( "fmt" ) func RemoveIndex(s []int, index int) []int { return append(s[:index], s[index+1:]...) } func main() { all := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(all) n := RemoveIndex(all, 5) fmt.Println(n) }
pos := 0 arr := []int{1, 2, 3, 4, 5, 6, 7, 9} fmt.Println("input your position") fmt.Scanln(&pos) if (pos < len(arr)){ arr = append(arr[:pos], arr[pos+1:]...) } else { fmt.Println("position invalid") }
panic: gzip: invalid header [...] stack trace [...]
package main import ( "io" "fmt" "compress/gzip" "net/http" ) func main() { /* This works fine f, _ := os.Open("/tmp/test.gz") defer f.Close() reader, err := gzip.NewReader(f) */ resp, _ := http.Get("http: defer resp.Body.Close() reader, err := gzip.NewReader(resp.Body) if err != nil { panic(err) } buff := make([]byte, 1024) for { n, err := reader.Read(buff) if err != nil && err != io.EOF { panic(err) } if n == 0 { break } } s := fmt.Sprintf("%s", buff) fmt.Println(s) }
client := new(http.Client) request, err := http.NewRequest("GET", "http: request.Header.Add("Accept-Encoding", "gzip") response, err := client.Do(request) defer response.Body.Close() var reader io.ReadCloser switch response.Header.Get("Content-Encoding") { case "gzip": reader, err = gzip.NewReader(response.Body) defer reader.Close() default: reader = response.Body } io.Copy(os.Stdout, reader)
x := map[string]interface{}{"a": 1, "b": 2} b, err := json.MarshalIndent(x, "", " ") if err != nil { fmt.Println("error:", err) } fmt.Print(string(b))
x := map[string]interface{}{"a":1,"b":2} spew.Dump(x)
(map[string]interface {}) (len=2) { (string) (len=1) "a": (int) 1, (string) (len=1) "b": (int) 2 }
func printMap(m map[string]string) { var maxLenKey int for k, _ := range m { if len(k) > maxLenKey { maxLenKey = len(k) } } for k, v := range m { fmt.Println(k + ": " + strings.Repeat(" ", maxLenKey - len(k)) + v) } }
package main import ( "github.com/kardianos/osext" "fmt" ) func main() { filename, _ := osext.Executable() fmt.Println(filename) }
import ( "os" "path" "log" ) func main() { ex, err := os.Executable() if err != nil { log.Fatal(err) } dir := path.Dir(ex) log.Print(dir) }
src |-libfastget | |-libfastget.go | |-MainProgram |-main.go
package libfastget import ( "fmt" "io" ) func fastget(urlPtr *string, nPtr *int, outFilePtr *string) download { ..... return dl }
package main import ( "fmt" "net/http" "os" "libfastget" "path/filepath" "strings" "flag" "time" ) func uploadFunc(w http.ResponseWriter, r *http.Request) { n:=libfastget.fastget(url,4,filename) } }
./main.go:94: cannot refer to unexported name libfastget.fastget ./main.go:94: undefined: libfastget.fastget
export GOPATH=~/projects/GO_PROJECTS export PATH=$PATH:$GOPATH/bin:$PATH
package utils import "fmt" func SayHello() { fmt.Println("Hello, Ajinkya") }
package main import ( "go_proj1/utils" ) func main() { utils.SayHello() }
type stack []int func (s *stack) Push(v int) { *s = append(*s, v) } func (s *stack) Pop() int { res:=(*s)[len(*s)-1] *s=(*s)[:len(*s)-1] return res }
type stack []int func (s stack) Push(v int) stack { return append(s, v) } func (s stack) Pop() (stack, int) { l := len(s) return s[:l-1], s[l-1] } func main(){ s := make(stack,0) s = s.Push(1) s = s.Push(2) s = s.Push(3) s, p := s.Pop() fmt.Println(p) }
type stack struct { lock sync.Mutex s []int } func NewStack() *stack { return &stack {sync.Mutex{}, make([]int,0), } } func (s *stack) Push(v int) { s.lock.Lock() defer s.lock.Unlock() s.s = append(s.s, v) } func (s *stack) Pop() (int, error) { s.lock.Lock() defer s.lock.Unlock() l := len(s.s) if l == 0 { return 0, errors.New("Empty Stack") } res := s.s[l-1] s.s = s.s[:l-1] return res, nil } func main(){ s := NewStack() s.Push(1) s.Push(2) s.Push(3) fmt.Println(s.Pop()) fmt.Println(s.Pop()) fmt.Println(s.Pop()) }
package stack import "sync" type element struct { data interface{} next *element } type stack struct { lock *sync.Mutex head *element Size int } func (stk *stack) Push(data interface{}) { stk.lock.Lock() element := new(element) element.data = data temp := stk.head element.next = temp stk.head = element stk.Size++ stk.lock.Unlock() } func (stk *stack) Pop() interface{} { if stk.head == nil { return nil } stk.lock.Lock() r := stk.head.data stk.head = stk.head.next stk.Size-- stk.lock.Unlock() return r } func New() *stack { stk := new(stack) stk.lock = &sync.Mutex{} return stk }
col := rows.Columns() vals := make([]interface{}, len(cols)) rows.Scan(&vals)
package main import ( _ "github.com/lib/pq" "database/sql" "fmt" ) func main() { db, _ := sql.Open( "postgres", "user=postgres dbname=Go_Testing password=ssap sslmode=disable") rows, _ := db.Query("SELECT * FROM _users;") cols, _ := rows.Columns() for rows.Next() { data := make([]interface{}, len(cols)) rows.Scan(data...) fmt.Println(data) } }
[<nil> <nil> <nil> <nil> <nil>] [<nil> <nil> <nil> <nil> <nil>] [<nil> <nil> <nil> <nil> <nil>] [<nil> <nil> <nil> <nil> <nil>] [<nil> <nil> <nil> <nil> <nil>] [<nil> <nil> <nil> <nil> <nil>]
package main import ( "fmt" _ "github.com/lib/pq" "database/sql" ) func main() { db, _ := sql.Open( "postgres", "user=postgres dbname=go_testing password=pass sslmode=disable") rows, _ := db.Query("SELECT * FROM _user;") columns, _ := rows.Columns() count := len(columns) values := make([]interface{}, count) valuePtrs := make([]interface{}, count) for rows.Next() { for i, _ := range columns { valuePtrs[i] = &values[i] } rows.Scan(valuePtrs...) for i, col := range columns { var v interface{} val := values[i] b, ok := val.([]byte) if (ok) { v = string(b) } else { v = val } fmt.Println(col, v) } } }
var sql = "select * from table" rows, err := db.Query(sql) columns, err = rows.Columns() colNum := len(columns) var values = make([]interface{}, colNum) for i, _ := range values { var ii interface{} values[i] = &ii } for rows.Next() { err := rows.Scan(values...) for i, colName := range columns { var raw_value = *(values[i].(*interface{})) var raw_type = reflect.TypeOf(raw_value) fmt.Println(colName,raw_type,raw_value) } }
col := rows.Columns() vals := make([]interface{}, col) rows.Scan(vals...)
CREATE TABLE `salesOrder` ( `idOrder` int(10) unsigned NOT NULL AUTO_INCREMENT, `uid` int(10) unsigned NOT NULL, `changed` datetime NOT NULL, PRIMARY KEY (`idOrder`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
package main import ( "database/sql" "encoding/json" "fmt" _ "github.com/go-sql-driver/mysql" "log" "reflect" "strings" ) var ( db *sql.DB ) func initDB() { var err error db, err = sql.Open("mysql", "MyUser:MyPassword@tcp(localhost:3306)/MyDB") if err != nil { log.Fatalf("Error on initializing database connection: %v", err.Error()) } err = db.Ping() if err != nil { log.Fatalf("Error on opening database connection: %v", err.Error()) } } func StrutToSliceOfFieldAddress(s interface{}) []interface{} { fieldArr := reflect.ValueOf(s).Elem() fieldAddrArr := make([]interface{}, fieldArr.NumField()) for i := 0; i < fieldArr.NumField(); i++ { f := fieldArr.Field(i) fieldAddrArr[i] = f.Addr().Interface() } return fieldAddrArr } func testSelectMultipleRowsV3(optArr map[string]interface{}) { query := []string{} param := []interface{}{} if val, ok := optArr["idOrder"]; ok { query = append(query, "salesOrder.idOrder >= ?") param = append(param, val) } var sqlField = struct { IdOrder int Uid int Changed string }{} var rowArr []interface{} sqlFieldArrPtr := StrutToSliceOfFieldAddress(&sqlField) sql := "SELECT " sql += " salesOrder.idOrder " sql += ", salesOrder.uid " sql += ", salesOrder.changed " sql += "FROM salesOrder " sql += "WHERE " + strings.Join(query, " AND ") + " " sql += "ORDER BY salesOrder.idOrder " stmt, err := db.Prepare(sql) if err != nil { log.Printf("Error: %v", err) } defer stmt.Close() rows, err := stmt.Query(param...) if err != nil { log.Printf("Error: %v", err) } defer rows.Close() if err != nil { log.Printf("Error: %v", err) } for rows.Next() { err := rows.Scan(sqlFieldArrPtr...) if err != nil { log.Printf("Error: %v", err) } f1 := reflect.TypeOf(sqlField.IdOrder) f2 := reflect.TypeOf(sqlField.Uid) f3 := reflect.TypeOf(sqlField.Changed) fmt.Printf("Type: %v\t%v\t%v\n", f1, f2, f3) fmt.Printf("Row: %v\t%v\t%v\n\n", sqlField.IdOrder, sqlField.Uid, sqlField.Changed) rowArr = append(rowArr, sqlField) } if err := rows.Err(); err != nil { log.Printf("Error: %v", err) } if data, err := json.MarshalIndent(rowArr, "", " "); err != nil { log.Fatalf("JSON marshaling failed: %s", err) } else { fmt.Printf("json.MarshalIndent:\n%s\n\n", data) } } func main() { initDB() defer db.Close() optArr := map[string]interface{}{} optArr["idOrder"] = 1 testSelectMultipleRowsV3(optArr) }
Type: int int string Row: 1 1 2016-05-06 20:41:06 Type: int int string Row: 2 2 2016-05-06 20:41:35 json.MarshalIndent: [ { "IdOrder": 1, "Uid": 1, "Changed": "2016-05-06 20:41:06" }, { "IdOrder": 2, "Uid": 2, "Changed": "2016-05-06 20:41:35" } ]
var StartTime = time.Now() func main() { otherPackage.StartTime = StartTime }
package dif import ( "time" ) var StartTime = time.Now()
package main import ( dif "./dif" "fmt" ) func main() { fmt.Println(dif.StartTime) }
func main(){ var array [10]int sliceA := array[0:5] append(sliceA, 4) fmt.Println(sliceA) }
func main(){ var array [10]int sliceA := array[0:5] sliceA = append(sliceA, 4) fmt.Println(sliceA) }
package git@23.251.148.129/project.git: unrecognized import path "git@1.2.3.4/project.git"
before_script: - - eval $(ssh-agent -s) - ssh-add <(echo "$SSH_PRIVATE_KEY") - mkdir -p ~/.ssh -
git config --global url."git@1.2.3.4:".insteadOf "https:
git clone git@gitlab:private-developers/project.git $GOPATH/src/gitlab/private-developers/project
package main import ( "fmt" "time" ) func say(s string) { for i := 0; i < 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say("world") say("hello") }
package main import ( "fmt" "time" ) func say(s string) { for i := 0; i < 5; i++ { fmt.Println(s) } } func main() { go say("world") say("hello") time.Sleep(1*time.Second) }
package main import ( "image" "image/color" "image/png" "os" ) func main() { img := image.NewRGBA(image.Rect(0, 0, 320, 240)) x, y := 100, 100 addLabel(img, x, y, "Test123") png.Encode(os.Stdout, img) } func addLabel(img *image.RGBA, x, y int, label string) { col := color.Black }
func addLabel(img *image.RGBA, x, y int, label string) { c.SetDst(img) size := 12.0 pt := freetype.Pt(x, y+int(c.PointToFixed(size)>>6)) if _, err := c.DrawString(label, pt); err != nil { } }
import ( "golang.org/x/image/font" "golang.org/x/image/font/basicfont" "golang.org/x/image/math/fixed" "image" "image/color" ) func addLabel(img *image.RGBA, x, y int, label string) { col := color.RGBA{200, 100, 0, 255} point := fixed.Point26_6{fixed.Int26_6(x * 64), fixed.Int26_6(y * 64)} d := &font.Drawer{ Dst: img, Src: image.NewUniform(col), Face: basicfont.Face7x13, Dot: point, } d.DrawString(label) }
func main() { img := image.NewRGBA(image.Rect(0, 0, 300, 100)) addLabel(img, 20, 30, "Hello Go") f, err := os.Create("hello-go.png") if err != nil { panic(err) } defer f.Close() if err := png.Encode(f, img); err != nil { panic(err) } }
import "golang.org/x/image/font/inconsolata" Face: inconsolata.Regular8x16, Face: inconsolata.Bold8x16,
package main import ( "github.com/fogleman/gg" "log" ) func main() { const S = 1024 im, err := gg.LoadImage("src.jpg") if err != nil { log.Fatal(err) } dc := gg.NewContext(S, S) dc.SetRGB(1, 1, 1) dc.Clear() dc.SetRGB(0, 0, 0) if err := dc.LoadFontFace("/Library/Fonts/Arial.ttf", 96); err != nil { panic(err) } dc.DrawStringAnchored("Hello, world!", S/2, S/2, 0.5, 0.5) dc.DrawRoundedRectangle(0, 0, 512, 512, 0) dc.DrawImage(im, 0, 0) dc.DrawStringAnchored("Hello, world!", S/2, S/2, 0.5, 0.5) dc.Clip() dc.SavePNG("out.png") }
package main import "fmt" func main() { var i int i = 5 fmt.Println(&i) i = 6 fmt.Println(&i) var k = 7 i = k fmt.Println(&i) }
type Config struct { CommitIndex uint64 `json:"commitIndex"` Peers []*Peer `json:"peers"` }
struct { microsec uint64 "field 1" serverIP6 uint64 "field 2" process string "field 3" }
c, _ := ioutil.ReadFile("c") dec := json.NewDecoder(bytes.NewReader(c)) var d data dec.Decode(&d) json: cannot unmarshal array into Go value of type main.data
type YourJson struct { YourSample []struct { data map[string]string } }
package main import ( "encoding/json" "fmt" "io/ioutil" "log" ) type mytype []map[string]string func main() { var data mytype file, err := ioutil.ReadFile("test.json") if err != nil { log.Fatal(err) } err = json.Unmarshal(file, &data) if err != nil { log.Fatal(err) } fmt.Println(data) }
package main import ( "fmt" "strings" ) type Result struct { allCaps string length int } func capsAndLen(words []string, c chan Result) { defer close(c) for _, word := range words { res := new(Result) res.allCaps = strings.ToUpper(word) res.length = len(word) c <- *res } } func main() { words := []string{"lorem", "ipsum", "dolor", "sit", "amet"} c := make(chan Result) go capsAndLen(words, c) for res := range c { fmt.Println(res.allCaps, ",", res.length) } }
package main import ( "fmt" "strings" ) func capsAndLen(words []string, cs chan string, ci chan int) { defer close(cs) defer close(ci) for _, word := range words { cs <- strings.ToUpper(word) ci <- len(word) } } func main() { words := []string{"lorem", "ipsum", "dolor", "sit", "amet"} cs := make(chan string) ci := make(chan int) go capsAndLen(words, cs, ci) for allCaps := range cs { length := <-ci fmt.Println(allCaps, ",", length) } }
package main import "fmt" func f(c chan func() (int, string)) { c <- (func() (int, string) { return 0, "s" }) } func main() { c := make(chan func() (int, string)) go f(c) y, z := (<-c)() fmt.Println(y) fmt.Println(z) }
runtime.main: undefined: main.init runtime.main: undefined: main.main
package main import "fmt" func main() { fmt.Println("Hello, World!") }
func paintMix(c1, c2 image.RGBAColor) image.RGBAColor { r := 255 - ((255 - c1.R) + (255 - c2.R)) g := 255 - ((255 - c1.G) + (255 - c2.G)) b := 255 - ((255 - c1.B) + (255 - c2.B)) return image.RGBAColor{r, g, b, 255} }
from colorsys import rgb_to_hls,hls_to_rgb from math import sin,cos,atan2,pi def average_colors(rgb1, rgb2): h1, l1, s1 = rgb_to_hls(rgb1[0]/255., rgb1[1]/255., rgb1[2]/255.) h2, l2, s2 = rgb_to_hls(rgb2[0]/255., rgb2[1]/255., rgb2[2]/255.) s = 0.5 * (s1 + s2) l = 0.5 * (l1 + l2) x = cos(2*pi*h1) + cos(2*pi*h2) y = sin(2*pi*h1) + sin(2*pi*h2) if x != 0.0 or y != 0.0: h = atan2(y, x) / (2*pi) else: h = 0.0 s = 0.0 r, g, b = hls_to_rgb(h, l, s) return (int(r*255.), int(g*255.), int(b*255.)) >>> average_colors((255,255,0),(0,0,255)) (0, 255, 111) >>> average_colors((255,255,0),(0,255,255)) (0, 255, 0)
mauve is 0xE0B0FF sRGB=[224,176,255] HSV=[276, 31,100] vermilion is 0xE34234 sRGB=[227, 66, 52] HSV=[ 5, 77, 89] mix is 0xE2799A sRGB=[226,121,154] HSV=[341, 46, 89] red is 0xFF0000 sRGB=[255, 0, 0] HSV=[ 0,100,100] blue is 0x0000FF sRGB=[ 0, 0,255] HSV=[240,100,100] red+blue is 0x800080 sRGB=[128, 0,128] HSV=[300,100, 50] black is 0xFFFFFF sRGB=[255,255,255] HSV=[ 0, 0,100] white is 0x000000 sRGB=[ 0, 0, 0] HSV=[ 0, 0, 0] grey is 0x808080 sRGB=[128,128,128] HSV=[ 0, 0, 50] dark red is 0xFF8080 sRGB=[255,128,128] HSV=[ 0, 50,100] light red is 0x800000 sRGB=[128, 0, 0] HSV=[ 0,100, 50] pink is 0x800080 sRGB=[128, 0,128] HSV=[300,100, 50] deep purple is 0xBF80FF sRGB=[191,128,255] HSV=[270, 50,100]
use strict; use warnings; use Convert::Color; main(); exit; sub rgb($$$) { my($r, $g, $b) = @_; return new Convert::Color:: "rgb8:$r,$g,$b"; } sub show($$) { my ($name, $color) = @_; printf "%-12s is 0x%6s", $name, uc $color->hex; printf " sRGB=[%3d,%3d,%3d] ", $color->rgb8; my ($h,$s,$v) = $color->as_hsv->hsv; for ($s, $v) { $_ *= 100 } printf " HSV=[%3.0f,%3.0f,%3.0f] ", $h, $s, $v; print "\n"; } sub main { my $vermilion = rgb 227, 66, 52; my $mauve = rgb 224, 176, 255; show mauve => $mauve; show vermilion => $vermilion; my $mix = alpha_blend $mauve $vermilion; show mix => $mix; print "\n"; my $red = rgb 255, 0, 0; my $blue = rgb 0, 0, 255; show red => $red; show blue => $blue; $mix = alpha_blend $red $blue; show "red+blue" => $mix; print "\n"; my $black = rgb 255, 255, 255; my $white = rgb 0, 0, 0; show black => $black; show white => $white; my $grey = alpha_blend $black $white; show grey => $grey; print "\n"; my $dark_red = alpha_blend $red $black; my $light_red = alpha_blend $red $white; show "dark red" => $dark_red; show "light red" => $light_red; print "\n"; my $magenta = rgb 255, 0, 255; my $violet = rgb 127, 0, 255; my $pink = alpha_blend $magenta $white; my $deep_purple = alpha_blend $violet $black; show pink => $pink; show "deep purple" => $deep_purple;; }
type Person struct { First string Last string } func main() { p1 := Person{"alice", "bob"} bs, _ := json.Marshal(p1) fmt.Println(string(bs)) var p2 Person bs = []byte(`{"First":"alice","Last":"bob"}`) json.Unmarshal(bs, &p2) fmt.Println(p2) }
310 311 func Fatalln(v ...interface{}) { 312 std.Output(2, fmt.Sprintln(v...)) 313 os.Exit(1) 314 }
215 216 217 218 219 220 221 222 223 224 225 226 func panic(v interface{})
eg. : var tmpl = template.Must(template.ParseFiles( "templates/base.html", "templates/first.html", ))
template.Must(template.ParseGlob("YOURDIRECTORY/*"))
{{define "header"}} <head> <title>Index</title> </head> {{end}}
{{define "indexPage"}} <html> {{template "header"}} <body> <h1>Index</h1> </body> </html> {{end}}
package main import( "html/template" ) var templates = template.Must(template.ParseGlob("YOURTEMPLATEDIR/*")) func main(){ ... } func IndexHandler(w http.ResponseWriter, r *http.Request) { err := templates.ExecuteTemplate(w, "indexPage", nil) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } }
var tmpl = template.Must(template.ParseFiles( "templates/base.html", "templates/first.html", "templates/second.html", ))
package main import ( "log" "os" "text/template" ) const base= `<!DOCTYPE html> <html> <head><title>Title</title></head> <body> {{template .Content}} </body> </html>` const first = `{{define "first"}}This is the first page{{end}}` const second = `{{define "second"}}And here is the second{{end}}` type View struct { Content string } func main() { var view = &View{ "first" } t := template.Must(template.New("base").Parse(base)) t = template.Must(t.Parse(first)) t = template.Must(t.Parse(second)) err := t.Execute(os.Stdout, view) if err != nil { log.Println("executing template:", err) } }
package main import ( "text/template" "os" "fmt" ) func main() { fmt.Println("Load a set of templates with {{define}} clauses and execute:") s1, _ := template.ParseFiles("t1.tmpl", "t2.tmpl") s1.ExecuteTemplate(os.Stdout, "t_cd", nil) fmt.Println() s1.ExecuteTemplate(os.Stdout, "t_ab", nil) fmt.Println() s1.Execute(os.Stdout, nil) }
package main import ( "crypto/tls" "log" "net/http" "golang.org/x/crypto/acme/autocert" ) func main() { certManager := autocert.Manager{ Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist("example.com"), Cache: autocert.DirCache("certs"), } http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("Hello world")) }) server := &http.Server{ Addr: ":https", TLSConfig: &tls.Config{ GetCertificate: certManager.GetCertificate, }, } go http.ListenAndServe(":http", certManager.HTTPHandler(nil)) log.Fatal(server.ListenAndServeTLS("", "")) }
(go to the directory where you want to install the certbot client) git clone https: cd certbot ./certbot-auto --help`
func (fdata *FDataStore) saveToDBBulk(items map[fdataKey][]byte) (err error) { tx, err := fdata.db.Begin() if err != nil { return errors.Wrap(err, "begin transaction") } txOK := false defer func() { if !txOK { tx.Rollback() } }() _, err = tx.Exec(sqlFDataMakeTempTable) if err != nil { return errors.Wrap(err, "create temporary table") } stmt, err := tx.Prepare(pq.CopyIn(_sqlFDataTempTableName, "map", "key", "data")) for key, val := range items { _, err = stmt.Exec(string(key.Map), string(key.Key), string(val)) if err != nil { return errors.Wrap(err, "loading COPY data") } } _, err = stmt.Exec() if err != nil { return errors.Wrap(err, "flush COPY data") } err = stmt.Close() if err != nil { return errors.Wrap(err, "close COPY stmt") } _, err = tx.Exec(sqlFDataSetFromTemp) if err != nil { return errors.Wrap(err, "move from temporary to real table") } err = tx.Commit() if err != nil { return errors.Wrap(err, "commit transaction") } txOK = true return nil }
package main import ("fmt" "time" ) func main() { fmt.Println("getting memory") tmp := make([]uint32, 100000000) for kk, _ := range tmp { tmp[kk] = 0 } time.Sleep(5 * time.Second) fmt.Println("returning memory") tmp = make([]uint32, 1) tmp = nil time.Sleep(5 * time.Second) fmt.Println("getting memory") tmp = make([]uint32, 100000000) for kk, _ := range tmp { tmp[kk] = 0 } time.Sleep(5 * time.Second) fmt.Println("returning memory") tmp = make([]uint32, 1) tmp = nil time.Sleep(5 * time.Second) return }
// var forcegcperiod int64 = 2 * 60 * 1e9 (...) scavengelimit := int64(5 * 60 * 1e9)
$ GOGCTRACE=1 go run gc.go gc1(1): 0+0+0 ms 0 -> 0 MB 423 -> 350 (424-74) objects 0 handoff gc2(1): 0+0+0 ms 1 -> 0 MB 2664 -> 1437 (2880-1443) objects 0 handoff gc3(1): 0+0+0 ms 1 -> 0 MB 4117 -> 2213 (5712-3499) objects 0 handoff gc4(1): 0+0+0 ms 2 -> 1 MB 3128 -> 2257 (6761-4504) objects 0 handoff gc5(1): 0+0+0 ms 2 -> 0 MB 8892 -> 2531 (13734-11203) objects 0 handoff gc6(1): 0+0+0 ms 1 -> 1 MB 8715 -> 2689 (20173-17484) objects 0 handoff gc7(1): 0+0+0 ms 2 -> 1 MB 5231 -> 2406 (22878-20472) objects 0 handoff gc1(1): 0+0+0 ms 0 -> 0 MB 172 -> 137 (173-36) objects 0 handoff getting memory gc2(1): 0+0+0 ms 381 -> 381 MB 203 -> 202 (248-46) objects 0 handoff returning memory getting memory returning memory
returning memory scvg0: inuse: 1, idle: 1, sys: 3, released: 0, consumed: 3 (MB) scvg0: inuse: 381, idle: 0, sys: 382, released: 0, consumed: 382 (MB) scvg1: inuse: 1, idle: 1, sys: 3, released: 0, consumed: 3 (MB) scvg1: inuse: 381, idle: 0, sys: 382, released: 0, consumed: 382 (MB) gc9(1): 1+0+0 ms 1 -> 1 MB 4485 -> 2562 (26531-23969) objects 0 handoff gc10(1): 1+0+0 ms 1 -> 1 MB 2563 -> 2561 (26532-23971) objects 0 handoff scvg2: GC forced scvg2: inuse: 1, idle: 1, sys: 3, released: 0, consumed: 3 (MB) gc3(1): 0+0+0 ms 381 -> 381 MB 206 -> 206 (252-46) objects 0 handoff scvg2: GC forced scvg2: inuse: 381, idle: 0, sys: 382, released: 0, consumed: 382 (MB) getting memory
if(s->unusedsince != 0 && (now - s->unusedsince) > limit) { runtime·SysUnused((void*)(s->start << PageShift), s->npages << PageShift); }
file, _ := os.Open("/path/to/filename") fileScanner := bufio.NewScanner(file) lineCount := 0 for fileScanner.Scan() { lineCount++ } fmt.Println("number of lines:", lineCount)
func lineCounter(r io.Reader) (int, error) { buf := make([]byte, 32*1024) count := 0 lineSep := []byte{ for { c, err := r.Read(buf) count += bytes.Count(buf[:c], lineSep) switch { case err == io.EOF: return count, nil case err != nil: return count, err } } }
BenchmarkBuffioScan 500 6408963 ns/op 4208 B/op 2 allocs/op BenchmarkBytesCount 500 4323397 ns/op 8200 B/op 1 allocs/op BenchmarkBytes32k 500 3650818 ns/op 65545 B/op 1 allocs/op
func lineCounter(r io.Reader) (int, error) { var readSize int var err error var count int buf := make([]byte, 1024) for { readSize, err = r.Read(buf) if err != nil { break } var buffPosition int for { i := bytes.IndexByte(buf[buffPosition:], if i == -1 || readSize == buffPosition { break } buffPosition += i + 1 count++ } } if readSize > 0 && count == 0 || count > 0 { count++ } if err == io.EOF { return count, nil } return count, err }
BenchmarkIndexByteWithBuffer 2000000 653 ns/op 1024 B/op 1 allocs/op BenchmarkBytes32k 500000 3189 ns/op 32768 B/op 1 allocs/op
func lineCount(r io.Reader) (int n, error err) { buf := make([]byte, 8192) for { c, err := r.Read(buf) if err != nil { if err == io.EOF && c == 0 { break } else { return } } for _, b := range buf[:c] { if b == n++ } } } if err == io.EOF { err = nil } }
package main import ( "fmt" ) var DEBUG = "NO" func main() { fmt.Printf("DEBUG is %q\n", DEBUG) }
package main import ( "fmt" ) type IFace interface { SetSomeField(newValue string) GetSomeField() string } type Implementation struct { someField string } func (i Implementation) GetSomeField() string { return i.someField } func (i Implementation) SetSomeField(newValue string) { i.someField = newValue } func Create() IFace { obj := Implementation{someField: "Hello"} return obj } func main() { a := Create() a.SetSomeField("World") fmt.Println(a.GetSomeField()) }
func (i *Implementation) SetSomeField(newValue string) { ...
prog.go:26: cannot use obj (type Implementation) as type IFace in return argument: Implementation does not implement IFace (GetSomeField method has pointer receiver)
package main import ( "fmt" ) type IFace interface { SetSomeField(newValue string) GetSomeField() string } type Implementation struct { someField string } func (i *Implementation) GetSomeField() string { return i.someField } func (i *Implementation) SetSomeField(newValue string) { i.someField = newValue } func Create() *Implementation { return &Implementation{someField: "Hello"} } func main() { var a IFace a = Create() a.SetSomeField("World") fmt.Println(a.GetSomeField()) }
./Roman_Numerals.go:31: sort.Ints(keys) used as value
keys := []int{3, 2, 8, 1} sort.Sort(sort.Reverse(sort.IntSlice(keys))) fmt.Println(keys)
package main import ( "fmt" "sort" ) func main() { example := []int{1, 25, 3, 5, 4} sort.Sort(sort.Reverse(sort.IntSlice(example))) fmt.Println(example) }
package main import "fmt" func SomeFun() { } func main() { fmt.Println(SomeFun == SomeFun) }
./func-pointers.go:12: invalid operation: SomeFun == SomeFun (func can only be compared to nil)
package main import "fmt" import "reflect" func SomeFun() { } func AnotherFun() { } func main() { sf1 := reflect.ValueOf(SomeFun) sf2 := reflect.ValueOf(SomeFun) fmt.Println(sf1.Pointer() == sf2.Pointer()) af1 := reflect.ValueOf(AnotherFun) fmt.Println(sf1.Pointer() == af1.Pointer()) }
func SomeFun() {} func AnotherFun() {} func main() { sf1 := reflect.ValueOf(SomeFun) sf2 := reflect.ValueOf(SomeFun) fmt.Println(sf1.Pointer() == sf2.Pointer()) af1 := reflect.ValueOf(AnotherFun) fmt.Println(sf1.Pointer() == af1.Pointer()) }
package main import "fmt" func F1() {} func F2() {} var F1_ID = F1 var F2_ID = F2 func main() { f1 := &F1_ID f2 := &F2_ID fmt.Println(f1 == f1) fmt.Println(f1 == f2) }
package main import "fmt" type Salutation struct { name string greeting string } func Greet(salutation Salutation) { fmt.Println(salutation.name) fmt.Println(salutation.greeting) } func main() { var s = Salutation s.name = "Alex" s.greeting = "Hi" Greet(s) }
var s Salutation var s = Salutation{} s := Salutation{}
func (s *Salutation) Greet()() { fmt.Println(s.name) fmt.Println(s.greeting) }
package main import "fmt" func NewSalutation()(*Salutation){ return &( Salutation{} ); } type Salutation struct { name string greeting string } func (s *Salutation) Greet()() { fmt.Println(s.name) fmt.Println(s.greeting) } func main() { var s *Salutation; s = NewSalutation() s.name = "Alex" s.greeting = "Hi" s.Greet(); }
for idx, value := range array { } if num := runtime.NumCPU(); num > 1 { fmt.Println("Multicore CPU, cores:", num) }
var name = "myfile.txt" fi, err := os.Stat(name) if err != nil { log.Fatal(err) } fmt.Println(name, fi.Size(), "bytes") data, err := ioutil.ReadFile(name) if err != nil { log.Fatal(err) }
package zsdfsdf import ( "fmt" ) func Main() { fmt.Println("sddddddd") }
http.Handle("/resources/", http.StripPrefix("/resources/", http.FileServer(http.Dir("resources"))))
http.Handle("/resources/", http.StripPrefix("/resources/", http.FileServer(http.Dir("/home/www/"))))
type justFilesFilesystem struct { fs http.FileSystem } func (fs justFilesFilesystem) Open(name string) (http.File, error) { f, err := fs.fs.Open(name) if err != nil { return nil, err } return neuteredReaddirFile{f}, nil } type neuteredReaddirFile struct { http.File } func (f neuteredReaddirFile) Readdir(count int) ([]os.FileInfo, error) { return nil, nil }
fs := justFilesFilesystem{http.Dir("resources/")} http.Handle("/resources/", http.StripPrefix("/resources/", http.FileServer(fs)))
package main import ( "bytes" "encoding/json" "fmt" "log" "os" ) type myStruct struct { Data string `json:"data"` } func (s *myStruct) MarshalJSON() ([]byte, error) { return []byte(`{"data":"charlie"}`), nil } func (s *myStruct) UnmarshalJSON(b []byte) error { return json.Unmarshal(b, &s.Data) } func main() { ms := myStruct{"alpha"} if err := json.NewDecoder(bytes.NewBufferString(`"bravo"`)).Decode(&ms); err != nil { log.Fatal(err) } if err := json.NewEncoder(os.Stdout).Encode(ms); err != nil { log.Fatal(err) } if ret, err := json.Marshal(ms); err != nil { log.Fatal(err) } else { fmt.Println(string(ret)) } var marsh json.Marshaler marsh = &ms ret, _ := marsh.MarshalJSON() fmt.Println(string(ret)) }
{"data":"bravo"} {"data":"bravo"} {"data":"charlie"}
package main import ( "fmt" "encoding/json" ) type Data struct { Votes *Votes `json:"votes"` Count string `json:"count,omitempty"` } type Votes struct { OptionA string `json:"option_A"` } func main() { s := `{ "votes": { "option_A": "3" } }` data := &Data{ Votes: &Votes{}, } err := json.Unmarshal([]byte(s), data) fmt.Println(err) fmt.Println(data.Votes) s2, _ := json.Marshal(data) fmt.Println(string(s2)) data.Count = "2" s3, _ := json.Marshal(data) fmt.Println(string(s3)) }
package main import "encoding/json" func main() { in := []byte(`{ "votes": { "option_A": "3" } }`) var raw map[string]interface{} json.Unmarshal(in, &raw) raw["count"] = 1 out, _ := json.Marshal(raw) println(string(out)) }
package main import ( "fmt" "strings" ) func main() { fmt.Println(strings.EqualFold("HELLO", "hello")) fmt.Println(strings.EqualFold("ÑOÑO", "ñoño")) }
func CaseInsensitiveContains(s, substr string) bool { s, substr = strings.ToUpper(s), strings.ToUpper(substr) return strings.Contains(s, substr) }
reg := regexp.MustCompile("(?i)update") f, err := os.Open("test.txt") if err != nil { log.Fatal(err) } defer f.Close() println(reg.MatchReader(bufio.NewReader(f)))
func SearchForString(str string, substr string) (int, int) { m := search.New(language.English, search.IgnoreCase) return = m.IndexString(str, substr) } start, end := SearchForString( if start != -1 && end != -1 { fmt.Println("found at", start, end); }
func SearchForStringIndex(str string, substr string) (int, bool) { m := search.New(language.English, search.IgnoreCase) start, _ := m.IndexString(str, substr) if start == -1 { return 0, false } return start, true } index, found := SearchForStringIndex( if found { fmt.Println("match starts at", index); }
package main import ( "fmt" "strings" "golang.org/x/text/language" "golang.org/x/text/search" ) var s = `Æ` var s2 = `Ä` func main() { m := search.New(language.Finnish, search.IgnoreDiacritics) fmt.Println(m.IndexString(s, s2)) fmt.Println(CaseInsensitiveContains(s, s2)) } func CaseInsensitiveContains(s, substr string) bool { s, substr = strings.ToUpper(s), strings.ToUpper(substr) return strings.Contains(s, substr) }
func main() { reasons := make([]string, 0) reasons = append(reasons, "Locked out", "Pipes broke", "Food poisoning", "Not feeling well") message := fmt.Sprint("Gonna work from home...", pick a random reason ) }
import ( "math/rand" "time" ) rand.Seed(time.Now().Unix()) message := fmt.Sprint("Gonna work from home...", reasons[rand.Intn(len(reasons))])
s := rand.NewSource(time.Now().Unix()) r := rand.New(s) r.Intn(len(reasons))
rand.Seed(time.Now().Unix()) reasons := []string{ "Locked out", "Pipes broke", "Food poisoning", "Not feeling well", } n := rand.Int() % len(reasons) fmt.Print("Gonna work from home...", reasons[n])
func getenv(key, fallback string) string { value := os.Getenv(key) if len(value) == 0 { return fallback } return value }
func getEnv(key, fallback string) string { if value, ok := os.LookupEnv(key); ok { return value } return fallback }
func getEnv(key, fallback string) string { value, exists := os.LookupEnv(key) if !exists { value = fallback } return value }
mongo_password := "pass" if mp := os.Getenv("MONGO_PASS"); mp != "" { mongo_password = mp }
func getEnv(key, defaultValue string) string { value := os.Getenv(key) if len(value) == 0 { return defaultValue } return value }
package main import ( "os" "github.com/urfave/cli" ) func main() { app := cli.NewApp() app.Flags = []cli.Flag { cli.StringFlag{ Name: "lang, l", Value: "english", Usage: "language for the greeting", EnvVar: "APP_LANG", }, } app.Run(os.Args) }
mime := "MIME-version: 1.0;\nContent-Type: text/html; charset=\"UTF-8\";\n\n"; subject := "Subject: Test email from Go!\n" msg := []byte(subject + mime + "<html><body><h1>Hello World!</h1></body></html>") smtp.SendMail(server, auth, from, to, msg)
package main import ( "gopkg.in/gomail.v2" ) func main() { m := gomail.NewMessage() m.SetHeader("From", "alex@example.com") m.SetHeader("To", "bob@example.com") m.SetHeader("Subject", "Hello!") m.SetBody("text/html", "Hello <b>Bob</b>!") d := gomail.NewPlainDialer("smtp.example.com", 587, "user", "123456") if err := d.DialAndSend(m); err != nil { panic(err) } }
package main import "fmt" type Member struct { Name, Surname string Age int } type Members []Member func main() { members1 := Members{ {"Bob", "Doe", 30}, {"Jack", "Doe", 30}, {"John", "Doe", 30}, } members1.ModifyName() members1.ModifyAllNames1() members1.ModifyAllNames2() fmt.Println(members1) } func (members *Members) ModifyName() { *members[0].Name = "-" } func (members *Members) ModifyAllNames1() { for i := 0; i < len(*members); i++ { *members[i].Name = "-" } } func (members *Members) ModifyAllNames2() { for _, m := range *members { m.Name = "-" } }
invalid operation: members[0] (type *Members does not support indexing) invalid operation: members[i] (type *Members does not support indexing)
m := make([]Members, 5) pm := &m m[:2] pm[:2] (*pm)[:2]
package main import "fmt" type Member struct { Name, Surname string Age int } type Members []Member func main() { members1 := Members{ {"Bob", "Doe", 30}, {"Jack", "Doe", 30}, {"John", "Doe", 30}, } members1.ModifyName() members1.ModifyAllNames1() members1.ModifyAllNames2() fmt.Println(members1) } func (members *Members) ModifyName() { (*members)[0].Name = "-" } func (members *Members) ModifyAllNames1() { for i := 0; i < len(*members); i++ { (*members)[i].Name = "-" } } func (members *Members) ModifyAllNames2() { for _, m := range *members { m.Name = "-" } }
func (members *Members) ModifyName() { *members[0].Name = "-" }
output := fmt.Sprintf("%s%s%s%d", "key:", "value", ", key2:", 100)
output := strings.Join([]string{"key:", "value", ", key2:", strconv.Itoa(100)}, "")
BenchmarkFmt-4 2000000 685 ns/op BenchmarkJoins-4 5000000 244 ns/op
package main import ( "net/http" "fmt" "github.com/kr/pretty" ); func main(){ http.HandleFunc("/", foo) http.ListenAndServe(":80", nil) } func foo(w http.ResponseWriter, r * http.Request){ w.Header().Set("Server","A Go WebServer") w.Header().Set("Content-Type", "text/html") hostname := r.URL.Query()["hostname"] fmt.Printf("% w.Write([]byte(hostname)) }
"example.com"2014/09/01 02:57:22 http: panic serving 172.17.92.14:49411: runtime error: index out of range /usr/lib/go/src/pkg/net/http/server.go:576 (0x42dc41) _func_003: buf.Write(debug.Stack()) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:1443 (0x40f8b5) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:128 (0x410381) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:85 (0x410228) /root/go/src/api/main.go:34 (0x400d77) foo: fmt.Printf("% /usr/lib/go/src/pkg/net/http/server.go:690 (0x421bed) HandlerFunc.ServeHTTP: f(w, r) /usr/lib/go/src/pkg/net/http/server.go:926 (0x422a6f) (*ServeMux).ServeHTTP: mux.handler(r).ServeHTTP(w, r) /usr/lib/go/src/pkg/net/http/server.go:656 (0x421a00) (*conn).serve: handler.ServeHTTP(w, w.req) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:271 (0x40d9bb) 2014/09/01 02:57:22 http: panic serving 172.17.92.14:49412: runtime error: index out of range /usr/lib/go/src/pkg/net/http/server.go:576 (0x42dc41) _func_003: buf.Write(debug.Stack()) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:1443 (0x40f8b5) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:128 (0x410381) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:85 (0x410228) /root/go/src/api/main.go:34 (0x400d77) foo: fmt.Printf("% /usr/lib/go/src/pkg/net/http/server.go:690 (0x421bed) HandlerFunc.ServeHTTP: f(w, r) /usr/lib/go/src/pkg/net/http/server.go:926 (0x422a6f) (*ServeMux).ServeHTTP: mux.handler(r).ServeHTTP(w, r) /usr/lib/go/src/pkg/net/http/server.go:656 (0x421a00) (*conn).serve: handler.ServeHTTP(w, w.req) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:271 (0x40d9bb) 2014/09/01 02:57:22 http: panic serving 172.17.92.14:49413: runtime error: index out of range /usr/lib/go/src/pkg/net/http/server.go:576 (0x42dc41) _func_003: buf.Write(debug.Stack()) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:1443 (0x40f8b5) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:128 (0x410381) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:85 (0x410228) /root/go/src/api/main.go:34 (0x400d77) foo: fmt.Printf("% /usr/lib/go/src/pkg/net/http/server.go:690 (0x421bed) HandlerFunc.ServeHTTP: f(w, r) /usr/lib/go/src/pkg/net/http/server.go:926 (0x422a6f) (*ServeMux).ServeHTTP: mux.handler(r).ServeHTTP(w, r) /usr/lib/go/src/pkg/net/http/server.go:656 (0x421a00) (*conn).serve: handler.ServeHTTP(w, w.req) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:271 (0x40d9bb)
go/src/api/main.go:38: cannot convert hostname (type []string) to type []byte
2014/09/01 04:42:40 http: panic serving 172.17.92.14:50404: runtime error: index out of range /usr/lib/go/src/pkg/net/http/server.go:576 (0x42db27) _func_003: buf.Write(debug.Stack()) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:1443 (0x40f79b) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:128 (0x410267) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:85 (0x41010e) /root/go/src/api/main.go:38 (0x400d63) foo: newhost := hostname[0]; /usr/lib/go/src/pkg/net/http/server.go:690 (0x421ad3) HandlerFunc.ServeHTTP: f(w, r) /usr/lib/go/src/pkg/net/http/server.go:926 (0x422955) (*ServeMux).ServeHTTP: mux.handler(r).ServeHTTP(w, r) /usr/lib/go/src/pkg/net/http/server.go:656 (0x4218e6) (*conn).serve: handler.ServeHTTP(w, w.req) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:271 (0x40d8a1) 2014/09/01 04:42:40 http: panic serving 172.17.92.14:50405: runtime error: index out of range /usr/lib/go/src/pkg/net/http/server.go:576 (0x42db27) _func_003: buf.Write(debug.Stack()) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:1443 (0x40f79b) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:128 (0x410267) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:85 (0x41010e) /root/go/src/api/main.go:38 (0x400d63) foo: newhost := hostname[0]; /usr/lib/go/src/pkg/net/http/server.go:690 (0x421ad3) HandlerFunc.ServeHTTP: f(w, r) /usr/lib/go/src/pkg/net/http/server.go:926 (0x422955) (*ServeMux).ServeHTTP: mux.handler(r).ServeHTTP(w, r) /usr/lib/go/src/pkg/net/http/server.go:656 (0x4218e6) (*conn).serve: handler.ServeHTTP(w, w.req) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:271 (0x40d8a1) 2014/09/01 04:42:40 http: panic serving 172.17.92.14:50406: runtime error: index out of range /usr/lib/go/src/pkg/net/http/server.go:576 (0x42db27) _func_003: buf.Write(debug.Stack()) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:1443 (0x40f79b) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:128 (0x410267) /home/michael/DPKG/golang/src/pkg/runtime/runtime.c:85 (0x41010e) /root/go/src/api/main.go:38 (0x400d63) foo: newhost := hostname[0]; /usr/lib/go/src/pkg/net/http/server.go:690 (0x421ad3) HandlerFunc.ServeHTTP: f(w, r) /usr/lib/go/src/pkg/net/http/server.go:926 (0x422955) (*ServeMux).ServeHTTP: mux.handler(r).ServeHTTP(w, r) /usr/lib/go/src/pkg/net/http/server.go:656 (0x4218e6) (*conn).serve: handler.ServeHTTP(w, w.req) /home/michael/DPKG/golang/src/pkg/runtime/proc.c:271 (0x40d8a1)
"example.com" 11 2014/09/01 05:05:15 http: panic serving 172.17.92.14:50779: runtime error: index out of range /usr/lib/go/src/pkg/net/http/server.go:576 (0x42dd33)
hostname := r.URL.Query().Get("hostname") if len(hostname) != 0 { io.WriteString(w, hostname) w.Write([]byte(hostname)) }
package main import "fmt" func sender(out chan int, exit chan bool){ for i := 1; i <= 10; i++ { out <- i } exit <- true } func main(){ out := make(chan int, 10) exit := make(chan bool) go sender(out, exit) L: for { select { case i := <-out: fmt.Printf("Value: %d\n", i) case <-exit: fmt.Println("Exiting") break L } } fmt.Println("Did we get all 10? Most likely not") }
package main import "fmt" func sender(out chan int, exit chan bool) { for i := 1; i <= 10; i++ { out <- i } exit <- true } func main() { out := make(chan int, 10) exit := make(chan bool) go sender(out, exit) for { select { case i := <-out: fmt.Printf("Value: %d\n", i) continue default: } select { case i := <-out: fmt.Printf("Value: %d\n", i) continue case <-exit: fmt.Println("Exiting") } break } fmt.Println("Did we get all 10? I think so!") }
package main import ( "fmt" "math/rand" "time" ) var ( produced = 0 processed = 0 ) func produceEndlessly(out chan int, quit chan bool) { defer close(out) for { select { case <-quit: fmt.Println("RECV QUIT") return default: out <- rand.Int() time.Sleep(time.Duration(rand.Int63n(5e6))) produced++ } } } func quitRandomly(quit chan bool) { d := time.Duration(rand.Int63n(5e9)) fmt.Println("SLEEP", d) time.Sleep(d) fmt.Println("SEND QUIT") quit <- true } func main() { vals, quit := make(chan int, 10), make(chan bool) go produceEndlessly(vals, quit) go quitRandomly(quit) for { x, ok := <-vals if !ok { break } fmt.Println(x) processed++ time.Sleep(time.Duration(rand.Int63n(5e8))) } fmt.Println("Produced:", produced) fmt.Println("Processed:", processed) }
package main import "fmt" func sender(c chan int) chan int { go func() { for i := 1; i <= 15; i++ { c <- i } close(c) }() return c } func main() { for i := range sender(make(chan int, 10)) { fmt.Printf("Value: %d\n", i) } fmt.Println("Did we get all 15? Surely yes") }
$ go run main.go Value: 1 Value: 2 Value: 3 Value: 4 Value: 5 Value: 6 Value: 7 Value: 8 Value: 9 Value: 10 Value: 11 Value: 12 Value: 13 Value: 14 Value: 15 Did we get all 15? Surely yes $
exiting := false for !exiting || len(out)>0 { select { case i := <-out: fmt.Printf("Value: %d\n", i) case <-exit: exiting = true fmt.Println("Exiting") } }
OUTER: for channelA != nil || channelB != nil { select { case typeA, ok := <-channelA: if !ok { channelA = nil continue OUTER } doSomething(typeA) case nodeIn, ok := <-channelB: if !ok { channelB = nil continue OUTER } NESTED: for { select { case typeA, ok := <-channelA: if !ok { channelA = nil continue NESTED } doSomething(typeA) default: doSomethingElse(typeB) break NESTED } } } }
package main import "fmt" func sender(out chan int, exit chan bool){ for i := 1; i <= 10; i++ { out <- i } exit <- true } func main(){ out := make(chan int, 10) exit := make(chan bool) go sender(out, exit) L: for { select { case i := <-out: fmt.Printf("Value: %d\n", i) case <-exit: for{ select{ case i:=<-out: fmt.Printf("Value: %d\n", i) default: fmt.Println("Exiting") break L } } fmt.Println("Exiting") break L } } fmt.Println("Did we get all 10? Yes!") }
go func() { stop := false for { select { case item, _ := <-r.queue: doWork(item) case <-r.stopping: stop = true } if stop && len(r.queue) == 0 { break } } }()
*The great GopherBook* (logged in as Dewey) [Most popular] >> Huey >> Dewey >> Louie [Most active] >> Huey >> Louie [Most recent] >> Louie
{{template "userlist" dict "Users" .MostPopular "Current" .CurrentUser}}
var tmpl = template.Must(template.New("").Funcs(template.FuncMap{ "dict": func(values ...interface{}) (map[string]interface{}, error) { if len(values)%2 != 0 { return nil, errors.New("invalid dict call") } dict := make(map[string]interface{}, len(values)/2) for i := 0; i < len(values); i+=2 { key, ok := values[i].(string) if !ok { return nil, errors.New("dict keys must be strings") } dict[key] = values[i+1] } return dict, nil }, }).ParseGlob("templates/*.html")
template.FuncMap{"isUser": func(g Gopher) bool { return string(g) == string(data.User);},}
{{define "sub"}} {{range $y := .}}>> {{if isUser $y}}!!{{$y}}!!{{else}}{{$y}}{{end}} {{end}} {{end}}
*The great GopherBook* (logged in as Dewey) [Most popular] >> Huey >> !!Dewey!! >> Louie [Most active] >> Huey >> Louie [Most recent] >> Louie
var defaultfuncs = map[string]interface{} { "isUser": func(g Gopher) bool { return false;}, } func init() { t = template.New("home").Funcs(defaultfuncs) t, _ = t.Parse(subtmpl) t, _ = t.Parse(hometmpl) } func main() { data := &HomeData{ User: "Dewey", Popular: []Gopher{"Huey", "Dewey", "Louie"}, Active: []Gopher{"Huey", "Louie"}, Recent: []Gopher{"Louie"}, } t.Funcs(template.FuncMap{"isUser": func(g Gopher) bool { return string(g) == string(data.User); },}) t.ExecuteTemplate(os.Stdout, "home", data) }
{{template "userlist" dict "Users" .MostPopular "Current" .CurrentUser}}
{{template "userlist" dict .MostPopular .CurrentUser}}
{{template "userlist" dict .MostPopular "Current" .CurrentUser}}
{{template "userlist" dict .MostPopular "Name" .CurrentUser.name}}
var tmpl = template.Must(template.New("").Funcs(template.FuncMap{ "dict": func(values ...interface{}) (map[string]interface{}, error) { if len(values) == 0 { return nil, errors.New("invalid dict call") } dict := make(map[string]interface{}) for i := 0; i < len(values); i ++ { key, isset := values[i].(string) if !isset { if reflect.TypeOf(values[i]).Kind() == reflect.Map { m := values[i].(map[string]interface{}) for i, v := range m { dict[i] = v } }else{ return nil, errors.New("dict values must be maps") } }else{ i++ if i == len(values) { return nil, errors.New("specify the key for non array values") } dict[key] = values[i] } } return dict, nil }, }).ParseGlob("templates/*.html")
type PipelineDecorator struct { Data interface{} Deco interface{} } func decorate(data interface{}, deco interface{}) *PipelineDecorator { return &PipelineDecorator{ Data: data, Deco: deco, } }
type Gopher struct { Name string IsCurrent bool IsAdmin bool }
type HomeData struct { User Gopher Popular []Gopher Active []Gopher Recent []Gopher }
type HomeDataContext struct { *HomeData I interface{} }
t.ExecuteTemplate(os.Stdout, "home", &HomeDataContext{ HomeData: data, })
func (ctx *HomeDataContext) Using(data interface{}) *HomeDataContext { c := *ctx c.I = data return &c }
{{define "foo"}} {{if $args := . | require "arg1" | require "arg2" "int" | args }} {{with .Origin }} {{.Bar}} {{$args.arg1}} {{ end }} {{ end }} {{ end }} {{ template "foo" . | arg "arg1" "Arg1" | arg "arg2" 42 }} {{ template "foo" . | arg "arg1" "Arg1" | arg "arg2" "42" }}
const someTemplate = `insert into {{.Schema}}.{{.Table}} (field1, field2) values {{ range .Rows }} ({{.Field1}}, {{.Field2}}), {{end}};` data := struct { Schema string Table string Rows []MyCustomType }{ schema, table, someListOfMyCustomType, } t, err := template.New("new_tmpl").Parse(someTemplate) if err != nil { panic(err) } buf := &bytes.Buffer{} err = t.Execute(buf, data)
func (m *MyType) Iterate() []MyElementType { ... } mm := NewMyType() for i, v := range mm.Iterate() { ... }
func (m *MyType) Iterate() <-chan MyElementType { c := make(chan MyElementType) go func() { for _, v := range m.elements { c <- v } close(c) }() return c } mm := NewMyType() for v := range mm.Iterate() { ... }
mm := MyNewType() for mm.Next() { v := mm.Get() ... }
mm := MyNewType() for mm.Next() { v := mm.Get() ... } if err := mm.Error(); err != nil { ... }
iter := NewIterator(...) for iter.More() { item := iter.Item() }
func (s intSlice) chanIter() chan int { c := make(chan int) go func() { for _, i := range s { select { case c <- i: case <-c: close(c) return } } close(c) }() return c }
s := intSlice{1, 2, 3, 4, 5, 11, 22, 33, 44, 55} c := s.chanIter() for i := range c { fmt.Println(i) if i > 30 { c <- 0 } }
func (s intSlice) cloIter() func() (int, bool) { i := -1 return func() (int, bool) { i++ if i == len(s) { return 0, false } return s[i], true } }
iter := s.cloIter() for i, ok := iter(); ok; i, ok = iter() { fmt.Println(i) }
test.go:38: cannot use &ms (type *MyStruct) as type **interface {} in argument to doStuff
ms := MyStruct{1} doStuff(&ms) fmt.Printf("Hello, playground: %v\n", ms)
type MyRequest struct { http.Request PathParams map[string]string }
func New(origRequest *http.Request, pathParams map[string]string) *MyRequest { req := new(MyRequest) req.PathParams = pathParams return req }
func New(origRequest *http.Request, pathParams map[string]string) *MyRequest { return &MyRequest{*origRequest, pathParams} }
req := new(MyRequest) req.PathParams = pathParams req.Request = origRequest
req := &MyRequest{ PathParams: pathParams Request: origRequest }
go build runtime: linux/amd64 must be bootstrapped using make.bat
set GOARCH=amd64 set GOOS=linux go tool dist install -v pkg/runtime go install -v -a std
go env set GOARCH=amd64 set GOBIN= set GOEXE= set GOHOSTARCH=amd64 set GOHOSTOS=windows set GOOS=linux set GOPATH=T:\Projects\gopath set GORACE= set GOROOT=C:\Go set GOTOOLDIR=C:\Go\pkg\tool\windows_amd64 set GCCGO=gccgo set CC=gcc set GOGCCFLAGS=-fPIC -m64 -fmessage-length=0 set CXX=g++ set CGO_ENABLED=0 set PKG_CONFIG=pkg-config set CGO_CFLAGS=-g -O2 set CGO_CPPFLAGS= set CGO_CXXFLAGS=-g -O2 set CGO_FFLAGS=-g -O2 set CGO_LDFLAGS=-g -O2
func watchFile(filePath string) error { initialStat, err := os.Stat(filePath) if err != nil { return err } for { stat, err := os.Stat(filePath) if err != nil { return err } if stat.Size() != initialStat.Size() || stat.ModTime() != initialStat.ModTime() { break } time.Sleep(1 * time.Second) } return nil }
doneChan := make(chan bool) go func(doneChan chan bool) { defer func() { doneChan <- true }() err := watchFile("/path/to/file") if err != nil { fmt.Println(err) } fmt.Println("File has been changed") }(doneChan) <-doneChan
url := "http: response,err := http.Get(url) if err != nil { log.Fatal(err) } defer response.Body.Close() responseString :=
responseData,err := ioutil.ReadAll(response.Body) if err != nil { log.Fatal(err) }
package main import ( "fmt" "io/ioutil" "log" "net/http" ) func main() { url := "http: response, err := http.Get(url) if err != nil { log.Fatal(err) } defer response.Body.Close() responseData, err := ioutil.ReadAll(response.Body) if err != nil { log.Fatal(err) } responseString := string(responseData) fmt.Println(responseString) }
package main import ( "bufio" "bytes" "fmt" "log" "net/http" ) func main() { response, err := http.Get("http: if err != nil { log.Fatal(err) } defer response.Body.Close() scanner := bufio.NewScanner(response.Body) scanner.Split(bufio.ScanRunes) var buf bytes.Buffer for scanner.Scan() { buf.WriteString(scanner.Text()) } fmt.Println(buf.String()) }
package main import ( "fmt" "log" "net/http" ) func ServeHTTP(w http.ResponseWriter, r *http.Request) { body := "*Hello World* B=µH *" fmt.Fprint(w, body) } func main() { http.HandleFunc("/", ServeHTTP) if err := http.ListenAndServe(":80", nil); err != nil { log.Fatal(err) } }
resp, err := http.Get(server.URL + "/v1/ping") if err != nil { t.Errorf("failed to execute GET request: %s", err) } defer resp.Body.Close() var b bytes.Buffer if _, err := io.Copy(&b, resp.Body); err != nil { t.Errorf("failed to copy response body: %s", err) } fmt.Println(b.String())
db/base.go:4: import /home/asd/Dropbox/go/pkg/linux_amd64/projc1/libs/Bool.a: object is [linux amd64 go1.3.3 X:precisestack] expected [linux amd64 go1.4 X:precisestack]
func Die(format string, args ...interface{}) { str := fmt.Sprintf(format, args) fmt.Fprintf(os.Stderr, "%v\n", str) os.Exit(1) }
func c() (i int) { defer func() { i++ }() return 1 }
func a() (i int) { i = 2 return } func b() (i int) { i = 2 return 1 }
func c() (i int) { defer func() { i++ }() return 1 }
func c() (i int) { defer func() { fmt.Println("third") }() defer func() { fmt.Println("second") }() defer func() { fmt.Println("first") }() return 1 }
func main() { fmt.Println(c()) } func c() (j int) { defer changei(&j) return 6 } func changei(j *int) { *j--; }
func main() { fmt.Println(c()) } func c() int { j := 1 defer changei(&j) return 6 } func changei(j *int) { *j--; }
http.Handle("/", http.FileServer(http.Dir("static")))
http.Handle("/hello", http.FileServer(http.Dir("static/hello.html")))
http.HandleFunc("/static/", func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, r.URL.Path[1:]) })
/../file /.. /../ /../foo /..\\foo /file/a /file/a.. /file/a/.. /file/a\\..
http.Handle("/hello/", http.StripPrefix("/hello/",http.FileServer(http.Dir("static"))))
func downloadHandler(w http.ResponseWriter, r *http.Request) { r.ParseForm() StoredAs := r.Form.Get("StoredAs") data, err := ioutil.ReadFile("files/"+StoredAs) if err != nil { fmt.Fprint(w, err) } http.ServeContent(w, r, StoredAs, time.Now(), bytes.NewReader(data)) }
func main() { http.HandleFunc("/upload", uploadHandler) http.HandleFunc("/download", downloadHandler) http.ListenAndServe(":3001", nil) }
CA_Pool := x509.NewCertPool() severCert, err := ioutil.ReadFile("./cert.pem") if err != nil { log.Fatal("Could not load server certificate!") } CA_Pool.AppendCertsFromPEM(severCert) config := tls.Config{RootCAs: CA_Pool} conn, err := tls.Dial("tcp", "127.0.0.1:8000", &config) if err != nil { log.Fatalf("client: dial: %s", err) }
cert, err := tls.LoadX509KeyPair("./cert.pem", "./key.pem") config := tls.Config{Certificates: []tls.Certificate{cert}} listener, err := tls.Listen("tcp", "127.0.0.1:8000", &config) for { conn, err := listener.Accept() if err != nil { log.Printf("server: accept: %s", err) break } log.Printf("server: accepted from %s", conn.RemoteAddr()) go handleConnection(conn) }
client: dial: x509: certificate signed by unknown authority (possibly because of "x509: invalid signature: parent certificate cannot sign this kind of certificate" while trying to verify candidate authority certificate "serial:0")
smtpbox := "mail.foo.com:25" c, err := smtp.Dial(smtpbox) host, _, _ := net.SplitHostPort(smtpbox) tlc := &tls.Config{ InsecureSkipVerify: true, ServerName: host, } if err = c.StartTLS(tlc); err != nil { fmt.Printf(err) os.Exit(1) }
type State struct { id string `json:"id" bson:"id"` Cities } type City struct { id string `json:"id" bson:"id"` } type Cities struct { cities []City }
state := State { id: "CA", Cities: Cities{ []City { {"SF"}, }, }, }
state := State { "CA", Cities{ []City { {"SF"}, }, }, }
type State struct { id string `json:"id" bson:"id"` Cities []City } type City struct { id string `json:"id" bson:"id"` } func main(){ state := State { id: "CA", Cities: []City{ {"SF"}, }, } fmt.Println(state) }
state := State{ id: "Independent Republic of Stackoverflow", Cities: Cities{ cities: []City{ City{ id: "Postington O.P.", }, }, }, }
var opts struct { ... Name string `short:"n" long:"name" description:"A name" required:"true"` ... }
var opts struct { Flag string `short:"f" required:"true" name:"a flag"` Args struct { First string `positional-arg-name:"first arg"` Sencond string `positional-arg-name:"second arg"` } `positional-args:"true" required:"2"` } args, err := flags.Parse(&opts)
required := []string{"b", "s"} flag.Parse() seen := make(map[string]bool) flag.Visit(func(f *flag.Flag) { seen[f.Name] = true }) for _, req := range required { if !seen[req] { fmt.Fprintf(os.Stderr, "missing required -%s argument/flag\n", req) os.Exit(2) } }
var path = flag.String("f", "", "/path/to/access.log") flag.Parse() if *path == "" { usage() os.Exit(1) }
package main import ( "html/template" "os" ) func main() { funcMap := template.FuncMap{ "printSelected": func(s string) string { if s == "test" { return `selected="selected"` } return "" }, "safe": func(s string) template.HTML { return template.HTML(s) }, } template.Must(template.New("Template").Funcs(funcMap).Parse(` <option {{ printSelected "test" }} {{ printSelected "test" | safe }} >test</option> `)).Execute(os.Stdout, nil) }
import ( "html/template" "os" ) func main() { funcMap := template.FuncMap{ "attr":func(s string) template.HTMLAttr{ return template.HTMLAttr(s) }, "safe": func(s string) template.HTML { return template.HTML(s) }, } template.Must(template.New("Template").Funcs(funcMap).Parse(` <option {{ .attr |attr }} >test</option> {{.html|safe}} `)).Execute(os.Stdout, map[string]string{"attr":`selected="selected"`,"html":`<option selected="selected">option</option>`}) }
<option selected="selected" >test</option> <option selected="selected">option</option>
import "html/template" yourhref = template.URL(yourhref)
import "path" import "os" func expandPath() { if path.IsAbs(*destination) { return } cwd, err := os.Getwd() checkError(err) *destination = path.Join(cwd, *destination) }
if path == "~" { path = dir } else if strings.HasPrefix(path, "~/") { path = filepath.Join(dir, path[2:]) }
cmd := exec.Command(os.Getenv("SHELL"), "-c", "cat ~/.myrc") cmd.Stdout = os.Stdout if err := cmd.Run(); err != nil { fmt.Fprintln(os.Stderr, err) }
import "os/user" import "path/filepath" func expand(path string) (string, error) { if len(path) == 0 || path[0] != return path, nil } usr, err := user.Current() if err != nil { return "", err } return filepath.Join(usr.HomeDir, path[1:]), nil }
myPath := "~/.ssh" fmt.Printf("path: %s; with expansion: %s", myPath, homedir.Expand(myPath))
package main import ( "fmt" "os" ) func main() { name := "FileOrDir" fi, err := os.Stat(name) if err != nil { fmt.Println(err) return } switch mode := fi.Mode(); { case mode.IsDir(): fmt.Println("directory") case mode.IsRegular(): fmt.Println("file") } }
import "os" func IsDirectory(path string) (bool, error) { fileInfo, err := os.Stat(path) if err != nil{ return false, err } return fileInfo.IsDir(), err }
if info, err := os.Stat(path); err == nil && info.IsDir() { ... }
import "os" func FileExists(name string) bool { if fi, err := os.Stat(name); err == nil { if fi.Mode().IsRegular() { return true } } return false } func DirExists(name string) bool { if fi, err := os.Stat(name); err == nil { if fi.Mode().IsDir() { return true } } return false }
fileOrDir, err := os.Open(name) if err != nil { .... } if fileOrDir.Stat().IsDir() { .... } else { ... }
func sample() { var i = 1 for i > 0 { fmt.Println("Press 1 to run") fmt.Println("Press 2 to exit") var input string inpt, _ := fmt.Scanln(&input) switch inpt { case 1: fmt.Println("hi") case 2: os.Exit(2) default: fmt.Println("def") } } }
package main import ( "fmt" "os" ) func main() { fmt.Println("Press 1 to run") fmt.Println("Press 2 to exit") for { sample() } } func sample() { var input int n, err := fmt.Scanln(&input) if n < 1 || err != nil { fmt.Println("invalid input") return } switch input { case 1: fmt.Println("hi") case 2: os.Exit(2) default: fmt.Println("def") } }
var input int for ok := true; ok; ok = (input != 2) { n, err := fmt.Scanln(&input) if n < 1 || err != nil { fmt.Println("invalid input") break } switch input { case 1: fmt.Println("hi") case 2: default: fmt.Println("def") } }
package main import `fmt` func main() { for { var number float64 fmt.Print(`insert an Integer eq or gr than 10!!!`) fmt.Scanf(`%f`, &number) if number >= 10 { break } fmt.Println(`sorry the number is lower than 10....type again!!!`) }
func main() { var value int for { value++ fmt.Println(value) if value%6 != 0 { break } } }
package main import ( "fmt" ) func main() { i := 0 for { i++ if i > 10 { break } fmt.Printf("%v ", i) } fmt.Println() }
int i = 0; while (i < 10) { cout << "incrementing i now" << endl; i++ } cout << "done"
var i = 0 fmt.Println(i) for { if i < 10 { fmt.Println("incrementing i now") i++ } else { break } } fmt.Println("done")
package main import ( "fmt" "net/http" "net/http/fcgi" ) func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello from Go!") } func main() { http.HandleFunc("/", hello) fcgi.Serve(nil, nil) }
package main import ( "fmt" "net/http" "net/http/cgi" ) func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello from Go!") } func main() { http.HandleFunc("/", hello) cgi.Serve(nil) }
links := make([]string) parser := NewParser(htmlContent) parser.Parse(nil, func(e *HtmlElement, isEmpty bool) { if e.TagName == "link" { link,_ := e.GetAttributeValue("href") if(link != "") { links = appends(links, link) } } }, nil)
type Timeout struct { Connect time.Duration ReadWrite time.Duration } func TimeoutDialer(timeout *Timeout) func(net, addr string) (c net.Conn, err error) { return func(netw, addr string) (net.Conn, error) { conn, err := net.DialTimeout(netw, addr, timeout.Connect) if err != nil { return nil, err } conn.SetDeadline(time.Now().Add(timeout.ReadWrite)) return conn, nil } } func HttpClient(config Config) *http.Client { to := &Timeout{ Connect: time.Duration(config.MaxWait) * time.Second, ReadWrite: time.Duration(config.MaxWait) * time.Second, } return &http.Client{ Transport: &http.Transport{ Dial: TimeoutDialer(to), }, } }
if err, ok := err.(net.Error); ok && err.Timeout() {
switch err := err.(type) { case net.Error: if err.Timeout() { fmt.Println("This was a net.Error with a Timeout") } case *url.Error: fmt.Println("This is a *url.Error") if err, ok := err.Err.(net.Error); ok && err.Timeout() { fmt.Println("and it was because of a timeout") } }
if err != nil && strings.Contains(err.Error(), "use of closed network connection") { fmt.Println("Could be from a Transport.CancelRequest") }
if e,ok := err.(net.Error); ok && e.Timeout() { } else if err != nil { }
package main import ( "fmt" "github.com/gorilla/mux" "log" "net/http" "strconv" ) func HomeHandler(response http.ResponseWriter, request *http.Request) { fmt.Fprintf(response, "Hello home") } func main() { port := 3000 portstring := strconv.Itoa(port) r := mux.NewRouter() r.HandleFunc("/", HomeHandler) http.Handle("/", r) log.Print("Listening on port " + portstring + " ... ") err := http.ListenAndServe(":"+portstring, nil) if err != nil { log.Fatal("ListenAndServe error: ", err) } }
func HomeHandler(response http.ResponseWriter, request *http.Request) { fmt.Fprintf(response, "Hello home") } func Middleware(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { log.Println("middleware", r.URL) h.ServeHTTP(w, r) }) } func main() { r := mux.NewRouter() r.HandleFunc("/", HomeHandler) http.Handle("/", Middleware(r)) }
func main() { r.Handle("/",Middleware(http.HandlerFunc(homeHandler))) http.Handle("/", r) } func Middleware(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { h.ServeHTTP(w, r) })}
subRouter := router.PathPrefix("/use-a-b").Subrouter().Use(middlewareA, middlewareB) subRouter.Path("/hello").HandlerFunc(requestHandlerFunc)
package main import ( "bufio" "io" "os" "os/exec" ) func main() { cmd := exec.Command("echo", " outfile, err := os.Create("./out.txt") if err != nil { panic(err) } defer outfile.Close() stdoutPipe, err := cmd.StdoutPipe() if err != nil { panic(err) } writer := bufio.NewWriter(outfile) err = cmd.Start() if err != nil { panic(err) } go io.Copy(writer, stdoutPipe) cmd.Wait() }
writer := bufio.NewWriter(outfile) defer writer.Flush()
package main import ( "os" "os/exec" ) func main() { cmd := exec.Command("echo", " outfile, err := os.Create("./out.txt") if err != nil { panic(err) } defer outfile.Close() cmd.Stdout = outfile err = cmd.Start(); if err != nil { panic(err) } cmd.Wait() }
strings.Split(strings.Replace(windows, "\r\n", "\n", -1), "\n")
--langdef=Go --langmap=Go:.go --regex-Go=/func([ \t]+\([^)]+\))?[ \t]+([a-zA-Z0-9_]+)/\2/d,func/ --regex-Go=/var[ \t]+([a-zA-Z_][a-zA-Z0-9_]+)/\1/d,var/ --regex-Go=/type[ \t]+([a-zA-Z_][a-zA-Z0-9_]+)/\1/d,type/
--langdef=Go --langmap=Go:.go --regex-Go=/func([ \t]+\([^)]+\))?[ \t]+([a-zA-Z0-9_]+)/\2/f,func/ --regex-Go=/var[ \t]+([a-zA-Z_][a-zA-Z0-9_]+)/\1/v,var/ --regex-Go=/type[ \t]+([a-zA-Z_][a-zA-Z0-9_]+)/\1/t,type/
" I can set variables for go like this autocmd FileType go setlocal noexpandtab shiftwidth=4 tabstop=4 softtabstop=4 nolist " I can clean trailing spaces(conserving cursor position) on save like this autocmd BufWritePre * kz|:%s/\s\+$ " None of these worked: autocmd BufWritePre,FileType go Fmt autocmd BufWritePre,FileType go :Fmt
autocmd FileType go autocmd BufWritePre <buffer> Fmt
autocmd FileType go autocmd BufWritePre <buffer> execute "normal! mz:mkview\<esc>:Fmt\<esc>:loadview\<esc>`z"
package main import ( "fmt" "log" "net/http" ) func main() { http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { fmt.Println(r.URL) go HandleIndex(w, r) }) fmt.Println("Starting Server...") log.Fatal(http.ListenAndServe(":5678", nil)) } func HandleIndex(w http.ResponseWriter, r *http.Request) { w.WriteHeader(200) w.Write([]byte("Hello, World!")) }
Starting Server... / 2015/01/15 13:41:29 http: multiple response.WriteHeader calls /favicon.ico 2015/01/15 13:41:29 http: multiple response.WriteHeader calls
func(w http.ResponseWriter, r *http.Request) { fmt.Println(r.URL) go HandleIndex(w, r) }
http.HandleFunc("/Home", func(w http.ResponseWriter, r *http.Request)
func (w *response) WriteHeader(code int) { if w.conn.hijacked() { w.conn.server.logf("http: response.WriteHeader on hijacked connection") return } if w.wroteHeader { w.conn.server.logf("http: multiple response.WriteHeader calls") return } w.wroteHeader = true w.status = code if w.calledHeader && w.cw.header == nil { w.cw.header = w.handlerHeader.clone() } if cl := w.handlerHeader.get("Content-Length"); cl != "" { v, err := strconv.ParseInt(cl, 10, 64) if err == nil && v >= 0 { w.contentLength = v } else { w.conn.server.logf("http: invalid Content-Length of %q", cl) w.handlerHeader.Del("Content-Length") } } }
package bloom import ( "encoding/gob" "bytes" ) func ComputeHash(key interface{}) (uint, error) { var buf bytes.Buffer enc := gob.NewEncoder(&buf) err := enc.Encode(key) if err != nil { return 0, err } data := buf.Bytes() var a, b, c uint a, b = 0x9e3779b9, 0x9e3779b9 c = 0; i := 0; for i = 0; i < len(data)-12; { a += uint(data[i+1] | data[i+2] << 8 | data[i+3] << 16 | data[i+4] << 24) i += 4 b += uint(data[i+1] | data[i+2] << 8 | data[i+3] << 16 | data[i+4] << 24) i += 4 c += uint(data[i+1] | data[i+2] << 8 | data[i+3] << 16 | data[i+4] << 24) a, b, c = mix(a, b, c); } c += uint(len(data)) if i < len(data) { a += uint(data[i]) i++ } if i < len(data) { a += uint(data[i] << 8) i++ } if i < len(data) { a += uint(data[i] << 16) i++ } if i < len(data) { a += uint(data[i] << 24) i++ } if i < len(data) { b += uint(data[i]) i++ } if i < len(data) { b += uint(data[i] << 8) i++ } if i < len(data) { b += uint(data[i] << 16) i++ } if i < len(data) { b += uint(data[i] << 24) i++ } if i < len(data) { c += uint(data[i] << 8) i++ } if i < len(data) { c += uint(data[i] << 16) i++ } if i < len(data) { c += uint(data[i] << 24) i++ } a, b, c = mix(a, b, c) return c, nil } func mix(a, b, c uint) (uint, uint, uint){ a -= b; a -= c; a ^= (c>>13); b -= c; b -= a; b ^= (a<<8); c -= a; c -= b; c ^= (b>>13); a -= b; a -= c; a ^= (c>>12); b -= c; b -= a; b ^= (a<<16); c -= a; c -= b; c ^= (b>>5); a -= b; a -= c; a ^= (c>>3); b -= c; b -= a; b ^= (a<<10); c -= a; c -= b; c ^= (b>>15); return a, b, c }
package bloom import ( "encoding/gob" "bytes" ) func GetBytes(key interface{}) ([]byte, error) { var buf bytes.Buffer enc := gob.NewEncoder(&buf) err := enc.Encode(key) if err != nil { return nil, err } return buf.Bytes(), nil }
type Console struct { X int Y int } func (c *Console) init() { c.X = "5" } var console Console var console Console = new(Console)
package main import "fmt" type Console struct { X int Y int } func NewConsole() *Console { return &Console{X: 5} } var console Console = *NewConsole() func main() { fmt.Println(console) }
func test(args ...string) { var msg map[string] interface{} i := 0 msg["product"] = args[i++] msg["key"] = args[i++] msg["signature"] = args[i++] msg["string_to_sign"] = args[i++] } go build utils.go
./utils.go:28: syntax error: unexpected ++, expecting : ./utils.go:28: missing statement after label ./utils.go:29: syntax error: unexpected ++, expecting : ./utils.go:30: syntax error: unexpected ++, expecting : ./utils.go:31: syntax error: unexpected ++, expecting : ./utils.go:36: syntax error: unexpected ++, expecting : ./utils.go:37: syntax error: unexpected ++, expecting :
func test(args ...string) { var msg map[string]interface{} i := 0 msg["product"] = args[i] i++ msg["key"] = args[i] i++ msg["signature"] = args[i] i++ msg["string_to_sign"] = args[i] }
func test(args ...string) { var msg map[string]interface{} msg["product"] = args[0] msg["key"] = args[1] msg["signature"] = args[2] msg["string_to_sign"] = args[3] }
func test(args ...string) { msg := make(map[string]string) i := 0 msg["product"], i = args[i], i+1 msg["key"], i = args[i], i+1 msg["signature"], i = args[i], i+1 msg["string_to_sign"], i = args[i], i+1 fmt.Printf("%v\n", msg) }
conn, err := net.Dial("udp", "8.9.10.11:2342") if err != nil { fmt.Println("Error", err) } localaddr := conn.LocalAddr() addr, _ := net.ResolveUDPAddr("udp", localaddr.String()) ip := addr.IP fmt.Println(ip) fmt.Println(len(ip))
func IPv4(a, b, c, d byte) IP { p := make(IP, IPv6len) copy(p, v4InV6Prefix) p[12] = a p[13] = b p[14] = c p[15] = d return p }
var v4InV6Prefix = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff}
func (ip IP) To4() IP { if len(ip) == IPv4len { return ip } if len(ip) == IPv6len && isZeros(ip[0:10]) && ip[10] == 0xff && ip[11] == 0xff { return ip[12:16] } return nil }
func IsIPv6(str string) bool { ip := net.ParseIP(str) return ip != nil && strings.Contains(str, ":") }
import strings func IsIPv4(address string) bool { return strings.Count(address, ":") < 2 } func IsIPv6(address string) bool { return strings.Count(address, ":") >= 2 }
myRouter := mux.NewRouter() myRouter.Handle("/images/", http.StripPrefix("/images/", http.FileServer(http.Dir(HomeFolder + "images/"))))
http.Handle("/images/", http.StripPrefix("/images/", http.FileServer(http.Dir(HomeFolder + "images/"))))
package main import ( "fmt" "net/http" "io" "log" "github.com/gorilla/mux" ) const ( HomeFolder = "/root/test/" ) func HomeHandler(w http.ResponseWriter, req *http.Request) { io.WriteString(w, htmlContents) } func main() { myRouter := mux.NewRouter() myRouter.HandleFunc("/", HomeHandler) // // myRouter.Host("mydomain.com") http.Handle("/", myRouter) http.Handle("/images/", http.StripPrefix("/images/", http.FileServer(http.Dir(HomeFolder + "images/")))) err := http.ListenAndServe(":80", nil) if err != nil { log.Fatal("ListenAndServe: ", err) fmt.Printf("ListenAndServe:%s\n", err.Error()) } } const htmlContents = `<!DOCTYPE HTML> <html lang="en"> <head> <title>Test page</title> <meta charset = "UTF-8" /> </head> <body> <p align="center"> <img src="/images/test.png" height="640" width="480"> </p> </body> </html> `
myRouter.Handle( http.StripPrefix("/images/", http.FileServer(http.Dir(HomeFolder + "images/"))) )
myRouter.PathPrefix("/images/").Handler( http.StripPrefix("/images/", http.FileServer(http.Dir(HomeFolder + "images/"))) )
ui := http.FileServer(http.Dir("ui")) myRouter.Handle("/ui/", http.StripPrefix("/ui/", ui))
ui := handlers.CombinedLoggingHandler(os.Stderr,http.FileServer(http.Dir("ui")) myRouter.Handle("/ui/", ui)
func Unzip(src, dest string) error { r, err := zip.OpenReader(src) if err != nil { return err } defer r.Close() for _, f := range r.File { rc, err := f.Open() if err != nil { return err } defer rc.Close() path := filepath.Join(dest, f.Name) if f.FileInfo().IsDir() { os.MkdirAll(path, f.Mode()) } else { f, err := os.OpenFile( path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode()) if err != nil { return err } defer f.Close() _, err = io.Copy(f, rc) if err != nil { return err } } } return nil }
func Unzip(src, dest string) error { r, err := zip.OpenReader(src) if err != nil { return err } defer func() { if err := r.Close(); err != nil { panic(err) } }() os.MkdirAll(dest, 0755) extractAndWriteFile := func(f *zip.File) error { rc, err := f.Open() if err != nil { return err } defer func() { if err := rc.Close(); err != nil { panic(err) } }() path := filepath.Join(dest, f.Name) if f.FileInfo().IsDir() { os.MkdirAll(path, f.Mode()) } else { os.MkdirAll(filepath.Dir(path), f.Mode()) f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode()) if err != nil { return err } defer func() { if err := f.Close(); err != nil { panic(err) } }() _, err = io.Copy(f, rc) if err != nil { return err } } return nil } for _, f := range r.File { err := extractAndWriteFile(f) if err != nil { return err } } return nil }
import ( "archive/zip" "io" "log" "os" "path/filepath" "strings" ) func unzip(src, dest string) error { r, err := zip.OpenReader(src) if err != nil { return err } defer r.Close() for _, f := range r.File { rc, err := f.Open() if err != nil { return err } defer rc.Close() fpath := filepath.Join(dest, f.Name) if f.FileInfo().IsDir() { os.MkdirAll(fpath, f.Mode()) } else { var fdir string if lastIndex := strings.LastIndex(fpath,string(os.PathSeparator)); lastIndex > -1 { fdir = fpath[:lastIndex] } err = os.MkdirAll(fdir, f.Mode()) if err != nil { log.Fatal(err) return err } f, err := os.OpenFile( fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode()) if err != nil { return err } defer f.Close() _, err = io.Copy(f, rc) if err != nil { return err } } } return nil }
os.MkDirAll(dest, r.File.Mode) d, _ := os.Open(dest) io.Copy(r.File, d)
func extractZip() { fmt.Println("extracting", zip_path) commandString := fmt.Sprintf(`7za e %s %s`, zip_path, dest_path) commandSlice := strings.Fields(commandString) fmt.Println(commandString) c := exec.Command(commandSlice[0], commandSlice[1:]...) e := c.Run() checkError(e) }
func checkError(e error){ if e != nil { panic(e) } } func cloneZipItem(f *zip.File, dest string){ path := filepath.Join(dest, f.Name) fmt.Println("Creating", path) err := os.MkdirAll(filepath.Dir(path), os.ModeDir|os.ModePerm) checkError(err) rc, err := f.Open() checkError(err) if !f.FileInfo().IsDir() { fileCopy, err := os.Create(path) checkError(err) _, err = io.Copy(fileCopy, rc) fileCopy.Close() checkError(err) } rc.Close() } func Extract(zip_path, dest string) { r, err := zip.OpenReader(zip_path) checkError(err) defer r.Close() for _, f := range r.File { cloneZipItem(f, dest) } }
package main type Vertex struct { label string } type Graph struct { connections map[Vertex][]Vertex } func main() { v1 := Vertex{"v1"} v2 := Vertex{"v2"} g := new(Graph) g.connections[v1] = append(g.coonections[v1], v2) g.connections[v2] = append(g.connections[v2], v1) }
func (g *Graph) add_connection(v1, v2 Vertex) { if g.connections == nil { g.connections = make(map[Vertex][]Vertex) } g.connections[v1] = append(g.connections[v1], v2) g.connections[v2] = append(g.connections[v2], v1) }
func NewGraph() *Graph { var g Graph g.connections = make(map[Vertex][]Vertex) return &g }
type Alpha struct { Pix []uint8 Stride int Rect Rectangle } func NewAlpha(r Rectangle) *Alpha { w, h := r.Dx(), r.Dy() pix := make([]uint8, 1*w*h) return &Alpha{pix, 1 * w, r} }
g := &Graph{ connections: make(map[Vertex][]Vertex), }
func NewGraph(v1 Vertex, v2 Vertex) *Graph { return &Graph{ map[Vertex][]Vertex{ v1: []Vertex{v2}, v2: []Vertex{v1} }} } func main() { v1 := Vertex{"v1"} v2 := Vertex{"v2"} g := NewGraph(v1, v2) fmt.Println(g) }
type Lead struct { Magic [4]byte Major, Minor byte Type uint16 Arch uint16 Name string OS uint16 SigType uint16 }
for index, b := range someSlice { varLead.Magic[index] = b }
lead := Lead{} reader := bytes.NewReader(buffer) binary.Read(reader, binary.LittleEndian, &lead)
if uid, ok := sess.Values["user"].(bson.ObjectId); ok { ... }
var i interface{} i = int(42) a, ok := i.(int) b, ok := i.(string)
The test filter: (&(objectClass=user)(cn=wickd(bracketTest ))) Escaped Filter: (&(objectClass=user)(cn=wickd\28bracketTest \29))
go s.Config.Serve(s.Listener) if *serve != "" { fmt.Fprintln(os.Stderr, "httptest: serving on", s.URL) select {} }
if *serve != "" { fmt.Fprintln(os.Stderr, "httptest: serving on", s.URL) s.Config.Serve(s.Listener) } else { go s.Config.Serve(s.Listener) }
if [ `type -p go` = "" ]; then export PATH=$PATH:/usr/local/go/bin fi export GOPATH=$PWD export PATH=$PATH:$PWD/bin
export GORP_TEST_DSN=test/testuser/TestPasswd9 export GO_TEST_DSN=testuser:TestPasswd9@/test
ctx := context.WithValue(r.Context(), string("principal_id"), *id)
should not use basic type string as key in context.WithValue
func bootstrapCmd(c *commander.Command, inp []string) error { if inp[0] == "add" { fmt.Println("you typed add") } else if inp[0] == "" { fmt.Println("you didn } return nil }
if len(inp) == 0 { fmt.Println("you didn } else if inp[0] == "add" { fmt.Println("you typed add") }
func bootstrapCmd(c *commander.Command, inp []string) (err error) { if len(inp) == 0 { return errors.New("no input") } switch inp[0] { case "add": fmt.Println("you typed add") case "sub": fmt.Println("you typed sub") default: fmt.Println("invalid:", inp[0]) } return nil }
func takes(s []string, i int) string { defer func() { if err := recover(); err != nil { return } }() return s[i] } if takes(inp,0) == "add" { fmt.Println("you typed add") } else { fmt.Println("you didn }
type IA interface { FB() IB } type IB interface { Bar() string } type A struct { b *B } func (a *A) FB() *B { return a.b } type B struct{} func (b *B) Bar() string { return "Bar!" }
cannot use a (type *A) as type IA in function argument: *A does not implement IA (wrong type for FB method) have FB() *B want FB() IB
fs, err := os.Open("fileName"); if err != nil{ fmt.Println("error reading file") return } defer fs.Close() reader := bufio.NewReader(fs) buf := make([]byte, 1024) for{ v, _ := reader.Read(buf) if v == 0{ return } fmt.Print(string(buf)) }
select { case x, ok := <-ch: if ok { fmt.Printf("Value %d was read.\n", x) } else { fmt.Println("Channel closed!") } default: fmt.Println("No value ready, moving on.") }
package main import ( "bytes" "fmt" "strconv" ) func arrayToString(A []int, delim string) string { var buffer bytes.Buffer for i := 0; i < len(A); i++ { buffer.WriteString(strconv.Itoa(A[i])) if i != len(A)-1 { buffer.WriteString(delim) } } return buffer.String() } func main() { A := []int{1, 2, 3} fmt.Println(arrayToString(A, ", ")) }
strings.Trim(strings.Join(strings.Fields(fmt.Sprint(A)), delim), "[]")
strings.Trim(strings.Join(strings.Split(fmt.Sprint(A), " "), delim), "[]")
strings.Trim(strings.Replace(fmt.Sprint(A), " ", delim, -1), "[]")
package main import "fmt" import "strings" func arrayToString(a []int, delim string) string { return strings.Trim(strings.Replace(fmt.Sprint(a), " ", delim, -1), "[]") } func main() { A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(arrayToString(A, ",")) }
func IntToString1() string { a := []int{1, 2, 3, 4, 5} b := "" for _, v := range a { if len(b) > 0 { b += "," } b += strconv.Itoa(v) } return b }
func IntToString2() string { a := []int{1, 2, 3, 4, 5} b := make([]string, len(a)) for i, v := range a { b[i] = strconv.Itoa(v) } return strings.Join(b, ",") }
func IntToString3() string { a := []int{1, 2, 3, 4, 5} return strings.Trim(strings.Replace(fmt.Sprint(a), " ", ",", -1), "[]") }
BenchmarkIntToString1-12 3000000 539 ns/op BenchmarkIntToString2-12 5000000 359 ns/op BenchmarkIntToString3-12 1000000 1162 ns/op
func SplitToString(a []int, sep string) string { if len(a) == 0 { return "" } b := make([]string, len(a)) for i, v := range a { b[i] = strconv.Itoa(v) } return strings.Join(b, sep) }
data := []int{1,2,3} func(x string) string { return x[6:len(x)-1]; }(fmt.Sprintf("%
magic := func(s, d string) string { return strings.Replace(s[1:len(s)-1], " ", d, -1) } fmt.Println(magic(fmt.Sprint([]int{1, 2, 3}), "--")) fmt.Println(func(s, d string) string { return strings.Replace(s[1:len(s)-1], " ", d, -1) }(fmt.Sprint([]int{1, 2, 3}), "--"))
data := []int{1,2,3} s, _ := json.Marshal(data) fmt.Println(string(s))
$GOPATH/src/github.com <-- $GOROOT/src/pkg/github.com $GOPATH/src/code.google.com <-- $GOROOT/src/pkg/code.google.com ... etc
GOROOT=C:\Go GOBIN=%GOPATH%\bin PATH=%PATH%;c:\go\bin;%GOBIN%
db, err := sql.Open("mysql", connection_string) checkErr(err) defer db.Close() rows,err := db.Query(`SELECT id FROM table`) checkErr(err) defer rows.Close() var id uint for rows.Next() { err := rows.Scan(&id) checkErr(err) go processTheThing(id) } checkErr(err) rows.Close()
package main import "fmt" func main() { maxGoroutines := 10 guard := make(chan struct{}, maxGoroutines) for i := 0; i < 30; i++ { guard <- struct{}{} go func(n int) { worker(n) <-guard }(i) } } func worker(i int) { fmt.Println("doing work on", i) }
package main import ( "fmt" "sync" ) const xthreads = 5 func doSomething(a int) { fmt.Println("My job is",a) return } func main() { var ch = make(chan int, 50) var wg sync.WaitGroup wg.Add(xthreads) for i:=0; i<xthreads; i++ { go func() { for { a, ok := <-ch if !ok { wg.Done() return } doSomething(a) } }() } for i:=0; i<50; i++ { ch <- i } close(ch) wg.Wait() }
type idProcessor func(id uint) func SpawnStuff(limit uint, proc idProcessor) chan<- uint { ch := make(chan uint) for i := uint(0); i < limit; i++ { go func() { for { id, ok := <-ch if !ok { return } proc(id) } }() } return ch } func main() { runtime.GOMAXPROCS(4) var wg sync.WaitGroup fn := func(id uint) { fmt.Println(id) wg.Done() } wg.Add(1000) ch := SpawnStuff(10, fn) for i := uint(0); i < 1000; i++ { ch <- i } close(ch) wg.Wait() }
package main import "fmt" const MAX = 20 func main() { sem := make(int, MAX) for { sem <- 1 go func() { fmt.Println("hello again, world") <-sem }() } }
func producer() { var buffer = make(chan uint) for i := 0; i < 20; i++ { go consumer(buffer) } for _, id := range IDs { buffer <- id } } func consumer(buffer chan uint) { for { id := <- buffer } }
package main import "fmt" var battle = make(chan string) func warrior(name string, done chan struct{}) { select { case opponent := <-battle: fmt.Printf("%s beat %s\n", name, opponent) case battle <- name: } done <- struct{}{} } func main() { done := make(chan struct{}) langs := []string{"Go", "C", "C++", "Java", "Perl", "Python"} for _, l := range langs { go warrior(l, done) } for _ = range langs { <-done } }
func warrior(name string, done chan bool) { select { case opponent := <-battle: fmt.Printf("%s beat %s\n", name, opponent) case battle <- name: } done <- true } func main() { done := make(chan bool) langs := []string{"Go", "C", "C++", "Java", "Perl", "Python"} for _, l := range langs { go warrior(l, done) } for _ = range langs { <-done } }
package main import ( "fmt" ) func main() { fmt.Println("Hello World!") }
main.go:5:2: cannot find package "fmt" in any of: /home/user/go/src/pkg/fmt (from $GOROOT) /home/user/gocode/src/fmt (from $GOPATH) package test_program imports runtime: cannot find package "runtime" in any of: /home/user/go/src/pkg/runtime (from $GOROOT) /home/user/gocode/src/runtime (from $GOPATH)
GOARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="linux" GOOS="linux" GOPATH="/home/user/gocode" GORACE="" GOROOT="/home/user/go" GOTOOLDIR="/home/user/go/pkg/tool/linux_amd64" CC="gcc" GOGCCFLAGS="-g -O2 -fPIC -m64 -pthread" CGO_ENABLED="1"
u, err := url.Parse("http: u.Path = path.Join(u.Path, "bar.html") s := u.String()
package main import ( "fmt" "log" "net/url" ) func main() { u, err := url.Parse("../../.. if err != nil { log.Fatal(err) } base, err := url.Parse("http: if err != nil { log.Fatal(err) } fmt.Println(base.ResolveReference(u)) }
func Join(basePath string, paths ...string) (*url.URL, error) { u, err := url.Parse(basePath) if err != nil { return nil, fmt.Errorf("invalid url") } p2 := append([]string{u.Path}, paths...) result := path.Join(p2...) u.Path = result return u, nil }
if(err == errors.New("Token is expired")){ log.Printf("Unauthorised: %s\n", err) }
package fruits var NoMorePumpkins = errors.New("No more pumpkins")
package shop if err == fruits.NoMorePumpkins { ... }
var ErrTokenExpired error = errors.New("Token is expired")
if err == myPkg.ErrTokenExpired { log.Printf("Unauthorised: %s\n", err) }
type errorString struct { s string } func (e *errorString) Error() string { return e.s }
package main import ( "errors" "fmt" "io" ) func main() { err1 := fmt.Errorf("Error") err2 := errors.New("Error") err3 := io.EOF fmt.Println(err1) fmt.Printf("% fmt.Printf("% fmt.Printf("% }
Error &errors.errorString{s:"Error"} &errors.errorString{s:"Error"} &errors.errorString{s:"EOF"}
package main import ( "errors" "fmt" ) func main() { err1 := errors.New("Token is expired") err2 := errors.New("Token is expired") if err1.Error() == err2.Error() { fmt.Println(err1.Error() == err2.Error()) } }
package main import ( "errors" "fmt" ) func main() { err1 := errors.New("Token is expired") err2 := errors.New("Token is expired") if err1 != nil { fmt.Println(err1 == err2) } }
package main import ( "fmt" "io" ) func main() { err1 := io.EOF if err1 == io.EOF { fmt.Println("err1 is : ", err1) } }
type MyStruct struct { } func (p *MyStruct) MyMethod { println("My statement."); } CallFunc("MyStruct", "MyMethod");
package main import "fmt" import "reflect" type T struct {} func (t *T) Foo() { fmt.Println("foo") } func main() { var t T reflect.ValueOf(&t).MethodByName("Foo").Call([]reflect.Value{}) }
type YourT1 struct {} func (y YourT1) MethodBar() { } type YourT2 struct {} func (y YourT2) MethodFoo(i int, oo string) { } func Invoke(any interface{}, name string, args... interface{}) { inputs := make([]reflect.Value, len(args)) for i, _ := range args { inputs[i] = reflect.ValueOf(args[i]) } reflect.ValueOf(any).MethodByName(name).Call(inputs) } func main() { Invoke(YourT2{}, "MethodFoo", 10, "abc") Invoke(YourT1{}, "MethodBar") }
type Shape interface { Area() float64 } func Invoke(s Shape, name string, inputs...interface{}) []interface{} { }
map[string]reflect.Value{ "YourT1" : reflect.ValueOf(YourT1{}) "YourT2" : reflect.ValueOf(YourT2{}) "Circle" : reflect.ValueOf(Cirlce{}) }
func invoke(any interface{}, name string, args ...interface{}) (reflect.Value, error) { method := reflect.ValueOf(any).MethodByName(name) methodType := method.Type() numIn := methodType.NumIn() if numIn > len(args) { return reflect.ValueOf(nil), fmt.Errorf("Method %s must have minimum %d params. Have %d", name, numIn, len(args)) } if numIn != len(args) && !methodType.IsVariadic() { return reflect.ValueOf(nil), fmt.Errorf("Method %s must have %d params. Have %d", name, numIn, len(args)) } in := make([]reflect.Value, len(args)) for i := 0; i < len(args); i++ { var inType reflect.Type if methodType.IsVariadic() && i >= numIn-1 { inType = methodType.In(numIn - 1).Elem() } else { inType = methodType.In(i) } argValue := reflect.ValueOf(args[i]) if !argValue.IsValid() { return reflect.ValueOf(nil), fmt.Errorf("Method %s. Param[%d] must be %s. Have %s", name, i, inType, argValue.String()) } argType := argValue.Type() if argType.ConvertibleTo(inType) { in[i] = argValue.Convert(inType) } else { return reflect.ValueOf(nil), fmt.Errorf("Method %s. Param[%d] must be %s. Have %s", name, i, inType, argType) } } return method.Call(in)[0], nil }
package main import ( "fmt" "reflect" ) type Log struct { Path string Level string } func (l *Log) Conversion(i interface{}) { if data, ok := i.(*Log); ok { if data != nil { if len(data.Path) > 0 { l.Path = data.Path } if len(data.Level) > 0 { l.Level = data.Level } } } } type Storage struct { Type string ServerList []string } func (s *Storage) Conversion(i interface{}) { if data, ok := i.(*Storage); ok { if data != nil { if len(data.Type) > 0 { s.Type = data.Type } } } } type Server struct { LogConfig *Log StorageConfig *Storage } func main() { def := Server{ LogConfig: &Log{ Path: "/your/old/log/path/", Level: "info", }, StorageConfig: &Storage{ Type: "zookeeper", ServerList: []string{"127.0.0.1:2181"}, }, } fmt.Println(def) cur := Server{ LogConfig: &Log{ Path: "/your/new/log/path/", Level: "debug", }, StorageConfig: &Storage{ Type: "etcd", ServerList: []string{"127.0.0.1:2379"}, }, } fmt.Println(cur) defV := reflect.ValueOf(def) curV := reflect.ValueOf(cur) for k := 0; k < defV.NumField(); k++ { in := make([]reflect.Value, 1) in[0] = reflect.ValueOf(curV.Field(k).Interface()) defV.Field(k).MethodByName("Conversion").Call(in) } fmt.Println(def.LogConfig) fmt.Println(def.StorageConfig)
package main import ( "encoding/json" "fmt" "time" ) type MyStruct struct { Timestamp time.Time `json:",omitempty"` Date time.Time `json:",omitempty"` Field string `json:",omitempty"` } func main() { ms := MyStruct{ Timestamp: time.Date(2015, 9, 18, 0, 0, 0, 0, time.UTC), Field: "", } bb, err := json.Marshal(ms) if err != nil { panic(err) } fmt.Println(string(bb)) }
type MyStruct struct { Timestamp *time.Time `json:",omitempty"` Date *time.Time `json:",omitempty"` Field string `json:",omitempty"` }
ts := time.Date(2015, 9, 18, 0, 0, 0, 0, time.UTC) ms := MyStruct{ Timestamp: &ts, Field: "", }
package main import "fmt" import "time" import "encoding/json" type MyTime struct{ *time.Time } func (t MyTime) MarshalJSON() ([]byte, error) { return []byte(t.Format("\"2006-01-02T15:04:05Z\"")), nil } func (t *MyTime) UnmarshalJSON(data []byte) (err error) { tt, err := time.Parse("\"2006-01-02T15:04:05Z\"", string(data)) *t = MyTime{&tt} return } func main() { t := time.Now() d, err := json.Marshal(MyTime{&t}) fmt.Println(string(d), err) var mt MyTime json.Unmarshal(d, &mt) fmt.Println(mt) }
func IsZeroOfUnderlyingType(x interface{}) bool { return x == reflect.Zero(reflect.TypeOf(x)).Interface() }
func IsZeroOfUnderlyingType(x interface{}) bool { return reflect.DeepEqual(x, reflect.Zero(reflect.TypeOf(x)).Interface()) }
package main import "fmt" func main() { var v interface{} fmt.Println(v == nil, v == 0, v == "", v == false) }
package main import "fmt" func main() { fmt.Println("Hello from main.go.") Test() }
package main import "fmt" func Test() { fmt.Println("This is the Test function in lib.go.") }
package main import ( "bytes" "fmt" "reflect" ) func main() { a := []byte{} b := []byte(nil) fmt.Printf("%t\n%t", bytes.Equal(a, b), reflect.DeepEqual(a, b)) }
func IntArrayEquals(a []int, b []int) bool { if len(a) != len(b) { return false } for i, v := range a { if v != b[i] { return false } } return true }
func worker(linkChan chan string, wg *sync.WaitGroup) { defer wg.Done() for url := range linkChan { } } func main() { lCh := make(chan string) wg := new(sync.WaitGroup) for i := 0; i < 250; i++ { wg.Add(1) go worker(lCh, wg) } for _, link := range yourLinksSlice { lCh <- link } close(lCh) wg.Wait() }
var ( MaxWorker = os.Getenv("MAX_WORKERS") MaxQueue = os.Getenv("MAX_QUEUE") ) type Job struct { Payload Payload } var JobQueue chan Job type Worker struct { WorkerPool chan chan Job JobChannel chan Job quit chan bool } func NewWorker(workerPool chan chan Job) Worker { return Worker{ WorkerPool: workerPool, JobChannel: make(chan Job), quit: make(chan bool)} } func (w Worker) Start() { go func() { for { w.WorkerPool <- w.JobChannel select { case job := <-w.JobChannel: if err := job.Payload.UploadToS3(); err != nil { log.Errorf("Error uploading to S3: %s", err.Error()) } case <-w.quit: return } } }() } func (w Worker) Stop() { go func() { w.quit <- true }() }
package main import ( "fmt" "sync" ) var wg sync.WaitGroup func worker(input chan string, output chan string) { defer wg.Done() for value := range input { output <- value + " processed" } } func main() { var jobs = []string{"one", "two", "three", "four", "two", "three", "four", "two", "three", "four", "two", "three", "four", "two", "three", "four", "two"} input := make(chan string, len(jobs)) output := make(chan string, len(jobs)) workers := 250 for i := 0; i < workers; i++ { wg.Add(1) go worker(input, output) } for _, job := range jobs { input <- job } close(input) wg.Wait() close(output) for result := range output { fmt.Println(result) } }
type Place struct { ID int Name string Town Town } type Town struct { ID int Name string }
db, _ := gorm.Open("sqlite3", "./data.db") defer db.Close() places := []Place{} db.Find(&places) fmt.Println(places)
id name town_id 1 Place1 1 2 Place2 1 id name 1 Town1 2 Town2
type Place struct { ID int Name string Description string TownID int Town Town }
places := []Place{} db.Find(&places) for i, _ := range places { db.Model(places[i]).Related(&places[i].Town) }
[4.76ms] SELECT * FROM "places" [1.00ms] SELECT * FROM "towns" WHERE ("id" = [0.73ms] SELECT * FROM "towns" WHERE ("id" = [{1 Place1 {1 Town1} 1} {2 Place2 {1 Town1} 1}]
[22.24ms] SELECT * FROM "places" [0.92ms] SELECT * FROM "towns" WHERE ("id" in ( [{1 Place1 {1 Town1} 1} {2 Place2 {1 Town1} 1}]
package main import ( "fmt" "github.com/jinzhu/gorm" _ "github.com/mattn/go-sqlite3" ) type Place struct { Id int Name string Town Town TownId int } type Town struct { Id int Name string } func main() { db, _ := gorm.Open("sqlite3", "./data.db") defer db.Close() db.CreateTable(&Place{}) db.CreateTable(&Town{}) t := Town{ Name: "TestTown", } p1 := Place{ Name: "Test", TownId: 1, } p2 := Place{ Name: "Test2", TownId: 1, } err := db.Save(&t).Error err = db.Save(&p1).Error err = db.Save(&p2).Error if err != nil { panic(err) } places := []Place{} err = db.Find(&places).Error for i, _ := range places { db.Model(places[i]).Related(&places[i].Town) } if err != nil { panic(err) } else { fmt.Println(places) } }
places := []Place{} DB.Find(&places) keys := []uint{} for _, value := range places { keys = append(keys, value.TownID) } rows := []Town{} DB.Where(keys).Find(&rows) related := map[uint]Town{} for _, value := range rows { related[value.ID] = value } for key, value := range places { if _, ok := related[value.TownID]; ok { res[key].Town = related[value.TownID] } }
package main import ( "fmt" "os" ) func Crasher() { fmt.Println("Going down in flames!") os.Exit(1) }
package main import ( "os" "os/exec" "testing" ) func TestCrasher(t *testing.T) { if os.Getenv("BE_CRASHER") == "1" { Crasher() return } cmd := exec.Command(os.Args[0], "-test.run=TestCrasher") cmd.Env = append(os.Environ(), "BE_CRASHER=1") err := cmd.Run() if e, ok := err.(*exec.ExitError); ok && !e.Success() { return } t.Fatalf("process ran with err %v, want exit status 1", err) }
package main import "os" import "fmt" type exiter func (code int) func main() { doExit(func(code int){}) fmt.Println("got here") doExit(func(code int){ os.Exit(code)}) } func doExit(exit exiter) { exit(1) }
func TestDoomed(t *testing.T) { fakeExit := func(int) { panic("os.Exit called") } patch := monkey.Patch(os.Exit, fakeExit) defer patch.Unpatch() assert.PanicsWithValue(t, "os.Exit called", doomed, "os.Exit was not called") }
package main import "os" var my_private_exit_function func(code int) = os.Exit func main() { MyAbstractFunctionAndExit(1) } func MyAbstractFunctionAndExit(exit int) { my_private_exit_function(exit) }
package main import ( "os" "testing" ) func TestMyAbstractFunctionAndExit(t *testing.T) { var ok bool = false my_private_exit_function = func(c int) { ok = true } MyAbstractFunctionAndExit(1) if ok == false { t.Errorf("Error in AbstractFunction()") } my_private_exit_function = os.Exit }
func md(str string) []byte { h := md5.New() io.WriteString(h, str) fmt.Printf("%x", h.Sum(nil)) return h.Sum(nil) }
func md(str string) string { h := md5.New() io.WriteString(h, str) return fmt.Sprintf("%x", h.Sum(nil)) }
go install -buildmode=shared -linkshared userownpackage
type T1 struct { T1_Text string } type T2 struct { T2_Text string T1 }
t := T2{ T2_Text: "Test", T1: T1{T1_Text: "Test"}, }
t := T2{ T2_Text: "Test", T1: T1{T1_Text: "Test"}, }
cd ~/var/go/src CGO_ENABLED=0 GOOS=windows GOARCH=386 ./make.bash
GOOS=windows GOARCH=386 go build -o hello.exe hello.go
package main import "fmt" import "functions" func main(){ c:= functions.getValue() }
package functions func getValue() string{ return "Hello from this another package" }
package main import ( "fmt" "MyProj/functions" ) func main(){ fmt.Println(functions.GetValue()) }
package functions func GetValue() string{ return "Hello from this another package" }
include $(GOROOT)/src/Make.$(GOARCH) all:main main:main.$O $(LD) -Lsubpackage1/_obj -Lsubpackage2/_obj -o $@ $^ %.$O:%.go subpackage1 subpackage2 $(GC) -Isubpackage1/_obj -Isubpackage2/_obj -o $@ $^ subpackage1: $(MAKE) -C subpackage1 subpackage2: $(MAKE) -C subpackage2 .PHONY:subpackage1 subpackage2 TARG=subpackage1 GOFILES=sub1_1.go sub1_2.go include $(GOROOT)/src/Make.$(GOARCH) include $(GOROOT)/src/Make.pkg TARG=subpackage2 GOFILES=sub2_1.go sub2_2.go include $(GOROOT)/src/Make.$(GOARCH) include $(GOROOT)/src/Make.pkg GC+=-I../subpackage1/_obj LD+=-L../subpackage1/_obj sub2_1.$O sub2_2.$O:subpackage1 subpackage1: $(MAKE) -C ../subpackage1 .PHONY:subpackage1
cannot use buffer (type *bytes.Buffer) as type []byte in argument to w.Write
buffer := new(bytes.Buffer) for _, jsonRawMessage := range sliceOfJsonRawMessages{ if err := json.Compact(buffer, jsonRawMessage); err != nil{ fmt.Println("error") } } fmt.Println("json returned", buffer) w.Header().Set("Content-Type", contentTypeJSON) w.Write(buffer)
cannot use foo (type *bufio.Writer) as type *bytes.Buffer in argument to json.Compact cannot use foo (type *bufio.Writer) as type []byte in argument to w.Write var b bytes.Buffer foo := bufio.NewWriter(&b) for _, d := range t.J{ if err := json.Compact(foo, d); err != nil{ fmt.Println("error") } } w.Header().Set("Content-Type", contentTypeJSON) w.Write(foo)
var buf []byte buf, err = json.Marshal(thing) _, err = w.Write(buf)
readBuf, _ := ioutil.ReadAll(jsonStoredInBuffVariable)
main.go:5:2: found packages myproject (myproject.go) and main (main.go) in $GOPATH/src/whatever.io/myproject
user@user:~/p/go/test/so-multipack$ ls -R .: a main.go ./a: a.go user@user:~/p/go/test/so-multipack$ cat main.go package main import ( "../so-multipack/a" ) func main(){ a.Hello() } user@user:~/p/go/test/so-multipack$ cat a/a.go package a import ( "fmt" ) func Hello(){ fmt.Println("hello from a") } user@user:~/p/go/test/so-multipack$ go run main.go hello from a user@user:~/p/go/test/so-multipack$ go build user@user:~/p/go/test/so-multipack$ ls a main.go so-multipack user@user:~/p/go/test/so-multipack$
type Person struct { Name string } a := Person{"Bill DeRose"} b := Person{"Bill DeRose"} a == b
type Person struct { Friend *Person } a := Person{Friend: &Person{}} b := Person{Friend: &Person{}} a == b
import "reflect" a := Person{Friend: &Person{}} b := Person{Friend: &Person{}} reflect.DeepEqual(a, b)
type Message struct { Cmd string `json:"cmd"` Data interface{} `json:"data"` }
type CreateMessage struct { Conf map[string]int `json:"conf"` Info map[string]int `json:"info"` }
type Message struct { Cmd string `json:"cmd"` Data json.RawMessage } type CreateMessage struct { Conf map[string]int `json:"conf"` Info map[string]int `json:"info"` } func main() { var m Message if err := json.Unmarshal(data, &m); err != nil { log.Fatal(err) } switch m.Cmd { case "create": var cm CreateMessage if err := json.Unmarshal([]byte(m.Data), &cm); err != nil { log.Fatal(err) } fmt.Println(m.Cmd, cm.Conf, cm.Info) default: log.Fatal("bad command") } }
type Foo struct { Prop string } func (f Foo)Bar() string { return f.Prop }
fooType := reflect.TypeOf(Foo{}) for i := 0; i < fooType.NumMethod(); i++ { method := fooType.Method(i) fmt.Println(method.Name) }
func implementsBar(v interface{}) bool { type Barer interface { Bar() string } _, ok := v.(Barer) return ok } ... fmt.Println("Foo implements the Bar method:", implementsBar(Foo{}))
package main import "fmt" type A struct {} type B struct {} func (a *A) Foo() { fmt.Println("A") } func (b *B) Foo() { fmt.Println("B") } func main() { n := nil n.Foo() }
prog.go:17: use of untyped nil [process exited with non-zero status]
x := [0]int{} y := make(chan int) z := map[int]int{} a := func(int) {} b := 42 c := 42.0
package main import "fmt" type T1 struct { f1 [5]byte f2 int32 } func main() { t := T1{"abcde", 3} fmt.Println(t) }
package main import "fmt" type T1 struct { f1 [5]byte f2 int } func main() { t := T1{f2: 3} copy(t.f1[:], "abcde") fmt.Println(t) }
package main import "fmt" type T1 struct { f1 []byte f2 int } func main() { t := T1{[]byte("abcde"), 3} fmt.Println(t) }
func FormHandler(w http.RequestWriter, r *http.Request) { err := r.ParseForm() if err != nil { } person := new(Person) decoder := schema.NewDecoder() err = decoder.Decode(person, r.Form) if err != nil { } }
package main import "fmt" import "github.com/pasztorpisti/qs" type Query struct { Search string Page int PageSize int Categories []string `qs:"category"` } func main() { queryStr, err := qs.Marshal(&Query{ Search: "my search", Page: 2, PageSize: 50, Categories: []string{"c1", "c2"}, }) fmt.Println("Marshal-Result:", queryStr, err) var q Query err = qs.Unmarshal(&q, queryStr) fmt.Println("Unmarshal-Result:", q, err) }
package main import ( "encoding/json" "fmt" "reflect" "github.com/pasztorpisti/qs" ) type NonMarshalable func() func jsonEmptyMap() { var m = map[string]NonMarshalable{} j, err := json.Marshal(m) fmt.Println(string(j), err) } func jsonNonEmptyMap() { var m = map[string]NonMarshalable{ "f": func() {}, } j, err := json.Marshal(m) fmt.Println(string(j), err) } func qsEmptyMap() { var m = map[string]NonMarshalable{} s, err := qs.Marshal(m) fmt.Println(s, err) } func qsTypeCheck() { t := reflect.TypeOf((map[string]NonMarshalable)(nil)) err := qs.CheckMarshalType(t) fmt.Println(err) } func main() { jsonEmptyMap() jsonNonEmptyMap() qsEmptyMap() qsTypeCheck() }
type B struct { X string Y string } type D struct { B Z string }
func DeepFields(iface interface{}) []reflect.Value { fields := make([]reflect.Value, 0) ifv := reflect.ValueOf(iface) ift := reflect.TypeOf(iface) for i := 0; i < ift.NumField(); i++ { v := ifv.Field(i) switch v.Kind() { case reflect.Struct: fields = append(fields, DeepFields(v.Interface())...) default: fields = append(fields, v) } } return fields }
places := []Place{} err := db.Select(&places, "SELECT * FROM place ORDER BY telcode ASC") if err != nil { fmt.Printf(err) return }
var fArr []string fb := fieldbinding.NewFieldBinding() if fArr, err = rs.Columns(); err != nil { return nil, err } fb.PutFields(fArr) // outArr := []interface{}{} for rs.Next() { if err := rs.Scan(fb.GetFieldPtrArr()...); err != nil { return nil, err } fmt.Printf("Row: %v, %v, %v, %s\n", fb.Get("IDOrder"), fb.Get("IsConfirm"), fb.Get("IDUser"), fb.Get("Created")) outArr = append(outArr, fb.GetFieldArr()) }
Row: 1, 1, 1, 2016-07-15 10:39:37 +0000 UTC Row: 2, 1, 11, 2016-07-15 10:42:04 +0000 UTC Row: 3, 1, 10, 2016-07-15 10:46:20 +0000 UTC SampleQuery: [{"Created":"2016-07-15T10:39:37Z","IDOrder":1,"IDUser":1,"IsClose":0,"IsConfirm":1},{"Created":"2016-07-15T10:42:04Z","IDOrder":2,"IDUser":11,"IsClose":0,"IsConfirm":1},{"Created":"2016-07-15T10:46:20Z","IDOrder":3,"IDUser":10,"IsClose":0,"IsConfirm":1}]
package main import ( "bytes" "database/sql" "encoding/json" "fmt" ) import ( _ "github.com/go-sql-driver/mysql" "github.com/junhsieh/goexamples/fieldbinding/fieldbinding" ) var ( db *sql.DB ) func main() { var err error db, err = sql.Open("mysql", "Username:Password@tcp(Host:Port)/DBName?parseTime=true") if err != nil { panic(err.Error()) } defer db.Close() if v, err := SampleQuery(); err != nil { fmt.Printf("%s\n", err.Error()) } else { var b bytes.Buffer if err := json.NewEncoder(&b).Encode(v); err != nil { fmt.Printf("SampleQuery: %v\n", err.Error()) } fmt.Printf("SampleQuery: %v\n", b.String()) } } func SampleQuery() ([]interface{}, error) { param := []interface{}{} param = append(param, 1) sql := "SELECT " sql += " SalOrder.IDOrder " sql += ", SalOrder.IsClose " sql += ", SalOrder.IsConfirm " sql += ", SalOrder.IDUser " sql += ", SalOrder.Created " sql += "FROM SalOrder " sql += "WHERE " sql += "IsConfirm = ? " sql += "ORDER BY SalOrder.IDOrder ASC " rs, err := db.Query(sql, param...) if err != nil { return nil, err } defer rs.Close() var fArr []string fb := fieldbinding.NewFieldBinding() if fArr, err = rs.Columns(); err != nil { return nil, err } fb.PutFields(fArr) // outArr := []interface{}{} for rs.Next() { if err := rs.Scan(fb.GetFieldPtrArr()...); err != nil { return nil, err } fmt.Printf("Row: %v, %v, %v, %s\n", fb.Get("IDOrder"), fb.Get("IsConfirm"), fb.Get("IDUser"), fb.Get("Created")) outArr = append(outArr, fb.GetFieldArr()) } if err := rs.Err(); err != nil { return nil, err } return outArr, nil }
package fieldbinding import ( "sync" ) func NewFieldBinding() *FieldBinding { return &FieldBinding{} } type FieldBinding struct { sync.RWMutex FieldArr []interface{} FieldPtrArr []interface{} FieldCount int64 MapFieldToID map[string]int64 } func (fb *FieldBinding) put(k string, v int64) { fb.Lock() defer fb.Unlock() fb.MapFieldToID[k] = v } func (fb *FieldBinding) Get(k string) interface{} { fb.RLock() defer fb.RUnlock() return fb.FieldArr[fb.MapFieldToID[k]] } func (fb *FieldBinding) PutFields(fArr []string) { fCount := len(fArr) fb.FieldArr = make([]interface{}, fCount) fb.FieldPtrArr = make([]interface{}, fCount) fb.MapFieldToID = make(map[string]int64, fCount) for k, v := range fArr { fb.FieldPtrArr[k] = &fb.FieldArr[k] fb.put(v, int64(k)) } } func (fb *FieldBinding) GetFieldPtrArr() []interface{} { return fb.FieldPtrArr } func (fb *FieldBinding) GetFieldArr() map[string]interface{} { m := make(map[string]interface{}, fb.FieldCount) for k, v := range fb.MapFieldToID { m[k] = fb.FieldArr[v] } return m }
import ( "fmt" "go/parser" "go/token" "reflect" ) func main() { stub1 := `package main func myfunc(s string) error { return nil }` stub2 := `package main func myfunc(s string) error { return nil }` fset := token.NewFileSet() r1, err := parser.ParseFile(fset, "", stub1, parser.AllErrors) if err != nil { panic(err) } fset = token.NewFileSet() r2, err := parser.ParseFile(fset, "", stub2, parser.AllErrors) if err != nil { panic(err) } if !reflect.DeepEqual(r1, r2) { fmt.Printf("e %v, r %s, ", r1, r2) } }
package main import ( "fmt" "go/parser" "go/token" "go/printer" "bytes" ) func main() { stub1 := `package main func myfunc(s string) error { return nil }` stub2 := `package main func myfunc(s string) error { return nil }` fset1 := token.NewFileSet() r1, err := parser.ParseFile(fset1, "", stub1, parser.AllErrors) if err != nil { panic(err) } fset2 := token.NewFileSet() r2, err := parser.ParseFile(fset1, "", stub2, parser.AllErrors) if err != nil { panic(err) } out1 := bytes.NewBuffer(nil) out2 := bytes.NewBuffer(nil) conf := &printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8} if err := conf.Fprint(out1, fset1, r1); err != nil { panic(err) } if err := conf.Fprint(out2, fset2, r2); err != nil { panic(err) } if string(out1.Bytes()) != string(out2.Bytes()) { panic(string(out1.Bytes()) +"\n" + string(out2.Bytes())) } else { fmt.Println("A-OKAY!") } }
package main import ( "fmt" "go/format" "strings" ) func main() { a, err := fmtSource(stub1) if err != nil { panic(err) } b, err := fmtSource(stub2) if err != nil { panic(err) } if a != b { fmt.Printf("a %v, \n b %v", a, b) } } func fmtSource(source string) (string, error) { if !strings.Contains(source, "package") { source = "package main\n" + source } b, err := format.Source([]byte(source)) if err != nil { return "", err } cleanLine := func(s string)string{ sa := strings.Fields(s) return strings.Join(sa, " ") } lines := strings.Split(string(b), "\n") n := 0 var startLn *int for _, line := range lines { if line != "" { line = cleanLine(line) lines[n] = line if startLn == nil { x := n startLn = &x } n++ } } lines = lines[*startLn:n] if n > 0 && lines[n-1] != "" { lines = append(lines, "") } b, err = format.Source([]byte(strings.Join(lines, "\n"))) if err != nil { return "", err } return string(b), nil }
package generator import ( "bytes" "fmt" "go/ast" "go/parser" "go/printer" "go/token" "testing" ) func TestAst(t *testing.T) { source := `package a type B struct { C string }` fset := token.NewFileSet() file, err := parser.ParseFile(fset, "", []byte(source), parser.ParseComments) if err != nil { t.Error(err) } v := &visitor{ file: file, } ast.Walk(v, file) var output []byte buf := bytes.NewBuffer(output) if err := printer.Fprint(buf, fset, file); err != nil { t.Error(err) } expected := `package a type B struct { C string D int E float64 } ` if buf.String() != expected { t.Error(fmt.Sprintf("Test failed. Expected:\n%s\nGot:\n%s", expected, buf.String())) } /* actual output = `package a type B struct { C string D int E float64 } ` */ } type visitor struct { file *ast.File } func (v *visitor) Visit(node ast.Node) (w ast.Visitor) { if node == nil { return v } switch n := node.(type) { case *ast.GenDecl: if n.Tok != token.TYPE { break } ts := n.Specs[0].(*ast.TypeSpec) if ts.Name.Name == "B" { fields := ts.Type.(*ast.StructType).Fields addStructField(fields, v.file, "int", "D", "D comment") addStructField(fields, v.file, "float64", "E", "E comment") } } return v } func addStructField(fields *ast.FieldList, file *ast.File, typ string, name string, comment string) { c := &ast.Comment{Text: fmt.Sprint(" cg := &ast.CommentGroup{List: []*ast.Comment{c}} f := &ast.Field{ Doc: cg, Names: []*ast.Ident{ast.NewIdent(name)}, Type: ast.NewIdent(typ), } fields.List = append(fields.List, f) file.Comments = append(file.Comments, cg) }
package main import ( "bytes" "fmt" "go/ast" "go/parser" "go/printer" "go/token" "testing" ) func main() { tests := []testing.InternalTest{{"TestAst", TestAst}} matchAll := func(t string, pat string) (bool, error) { return true, nil } testing.Main(matchAll, tests, nil, nil) } func TestAst(t *testing.T) { source := `package a type B struct { C string }` buffer := make([]byte, 1024, 1024) for idx,_ := range buffer { buffer[idx] = 0x20 } copy(buffer[:], source) fset := token.NewFileSet() file, err := parser.ParseFile(fset, "", buffer, parser.ParseComments) if err != nil { t.Error(err) } v := &visitor{ file: file, fset: fset, } ast.Walk(v, file) var output []byte buf := bytes.NewBuffer(output) if err := printer.Fprint(buf, fset, file); err != nil { t.Error(err) } expected := `package a type B struct { C string D int E float64 } ` if buf.String() != expected { t.Error(fmt.Sprintf("Test failed. Expected:\n%s\nGot:\n%s", expected, buf.String())) } } type visitor struct { file *ast.File fset *token.FileSet } func (v *visitor) Visit(node ast.Node) (w ast.Visitor) { if node == nil { return v } switch n := node.(type) { case *ast.GenDecl: if n.Tok != token.TYPE { break } ts := n.Specs[0].(*ast.TypeSpec) if ts.Name.Name == "B" { fields := ts.Type.(*ast.StructType).Fields addStructField(v.fset, fields, v.file, "int", "D", "D comment") addStructField(v.fset, fields, v.file, "float64", "E", "E comment") } } return v } func addStructField(fset *token.FileSet, fields *ast.FieldList, file *ast.File, typ string, name string, comment string) { prevField := fields.List[fields.NumFields()-1] c := &ast.Comment{Text: fmt.Sprint(" cg := &ast.CommentGroup{List: []*ast.Comment{c}} o := ast.NewObj(ast.Var, name) f := &ast.Field{ Doc: cg, Names: []*ast.Ident{&ast.Ident{Name: name, Obj: o, NamePos: cg.End() + 1}}, } o.Decl = f f.Type = &ast.Ident{Name: typ, NamePos: f.Names[0].End() + 1} fset.File(c.End()).AddLine(int(c.End())) fset.File(f.End()).AddLine(int(f.End())) fields.List = append(fields.List, f) file.Comments = append(file.Comments, cg) }
import ( "encoding/xml" "golang.org/x/net/html/charset" ) decoder := xml.NewDecoder(reader) decoder.CharsetReader = charset.NewReaderLabel err = decoder.Decode(&parsed)
decoder := xml.NewDecoder(reader) decoder.CharsetReader = charset.NewReader err = decoder.Decode(&parsed)
charset.CharsetDir = ".../src/code.google.com/p/go-charset/datafiles"
import ( "code.google.com/p/go-charset/charset" _ "code.google.com/p/go-charset/data" ... )
package main import ( "bytes" "fmt" "io" "os" "strings" "utf8" "xml" ) type CharsetISO88591er struct { r io.ByteReader buf *bytes.Buffer } func NewCharsetISO88591(r io.Reader) *CharsetISO88591er { buf := bytes.NewBuffer(make([]byte, 0, utf8.UTFMax)) return &CharsetISO88591er{r.(io.ByteReader), buf} } func (cs *CharsetISO88591er) ReadByte() (b byte, err os.Error) { if cs.buf.Len() <= 0 { r, err := cs.r.ReadByte() if err != nil { return 0, err } if r < utf8.RuneSelf { return r, nil } cs.buf.WriteRune(int(r)) } return cs.buf.ReadByte() } func (cs *CharsetISO88591er) Read(p []byte) (int, os.Error) { return 0, os.EINVAL } func isCharset(charset string, names []string) bool { charset = strings.ToLower(charset) for _, n := range names { if charset == strings.ToLower(n) { return true } } return false } func IsCharsetISO88591(charset string) bool { names := []string{ "ISO_8859-1:1987", "ISO-8859-1", "iso-ir-100", "ISO_8859-1", "latin1", "l1", "IBM819", "CP819", "csISOLatin1", } return isCharset(charset, names) } func IsCharsetUTF8(charset string) bool { names := []string{ "UTF-8", "", } return isCharset(charset, names) } func CharsetReader(charset string, input io.Reader) (io.Reader, os.Error) { switch { case IsCharsetUTF8(charset): return input, nil case IsCharsetISO88591(charset): return NewCharsetISO88591(input), nil } return nil, os.NewError("CharsetReader: unexpected charset: " + charset) } func main() { r, err := os.Open("ISO88591.xml") if err != nil { fmt.Println(err) return } defer r.Close() fmt.Println("file:", r.Name()) p := xml.NewParser(r) p.CharsetReader = CharsetReader for t, err := p.Token(); t != nil && err == nil; t, err = p.Token() { switch t := t.(type) { case xml.ProcInst: fmt.Println(t.Target, string(t.Inst)) case xml.Comment: fmt.Println(string([]byte(t))) } } }
p := xml.NewParser(r) p.CharsetReader = CharsetReader err := p.Unmarshal(&result, nil)
package main import ( "bytes" "io" "strings" ) type CharsetISO88591er struct { r io.ByteReader buf *bytes.Buffer } func NewCharsetISO88591(r io.Reader) *CharsetISO88591er { buf := bytes.Buffer{} return &CharsetISO88591er{r.(io.ByteReader), &buf} } func (cs *CharsetISO88591er) Read(p []byte) (n int, err error) { for _ = range p { if r, err := cs.r.ReadByte(); err != nil { break } else { cs.buf.WriteRune(rune(r)) } } return cs.buf.Read(p) } func isCharset(charset string, names []string) bool { charset = strings.ToLower(charset) for _, n := range names { if charset == strings.ToLower(n) { return true } } return false } func IsCharsetISO88591(charset string) bool { names := []string{ "ISO_8859-1:1987", "ISO-8859-1", "iso-ir-100", "ISO_8859-1", "latin1", "l1", "IBM819", "CP819", "csISOLatin1", } return isCharset(charset, names) } func CharsetReader(charset string, input io.Reader) (io.Reader, error) { if IsCharsetISO88591(charset) { return NewCharsetISO88591(input), nil } return input, nil }
d := xml.NewDecoder(reader) d.CharsetReader = CharsetReader err := d.Decode(&dst)
func TestGetObject(t *testing.T) { firebaseRoot := New(firebase_url) body, err := firebaseRoot.Get("1") if err != nil { t.Errorf("Error: %s", err) } t.Logf("%q", body) } func TestPushObject(t *testing.T) { firebaseRoot := New(firebase_url) msg := Message{"testing", "1..2..3"} body, err := firebaseRoot.Push("/", msg) if err != nil { t.Errorf("Error: %s", err) } t.Logf("%q", body) }
func (f *firebaseRoot) SendRequest(method string, path string, body io.Reader) ([]byte, error) { url := f.BuildURL(path) req, err := http.NewRequest(method, url, body) if err != nil { return nil, err } resp, err := http.DefaultClient.Do(req) if err != nil { return nil, err } if resp.StatusCode != http.StatusOK { return nil, fmt.Errorf("Bad HTTP Response: %v", resp.Status) } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) if err != nil { return nil, err } return b, nil }
--- FAIL: TestGetObject (0.00 seconds) firebase_test.go:53: Error: Get https: firebase_test.go:55: "" --- FAIL: TestPushObject (0.00 seconds) firebase_test.go:63: Error: Post https: firebase_test.go:65: "" FAIL exit status 1 FAIL github.com/chourobin/go.firebase 3.422s
client := &http.Client{} req, err := http.NewRequest(method, url, httpBody) req.Close = true req.Header.Set("Content-Type", "application/json") req.SetBasicAuth("user", "pass") resp, err := client.Do(req) if err != nil { } defer resp.Body.Close() response, err = ioutil.ReadAll(resp.Body) if err != nil { }
func Round(x, unit float64) float64 { return math.Round(x/unit) * unit }
fmt.Println(Round(0.363636, 0.05)) fmt.Println(Round(3.232, 0.05)) fmt.Println(Round(0.4888, 0.05)) fmt.Println(Round(-0.363636, 0.05)) fmt.Println(Round(-3.232, 0.05)) fmt.Println(Round(-0.4888, 0.05))
var f float64 f = 12.3 fmt.Println(int64(f)) f = 12.6 fmt.Println(int64(f))
f = 12.3 fmt.Println(int64(f + 0.5)) f = 12.6 fmt.Println(int64(f + 0.5))
f = 12.31 fmt.Println(float64(int64(f*10+0.5)) / 10) f = 12.66 fmt.Println(float64(int64(f*10+0.5)) / 10)
f = 12.31 fmt.Println(float64(int64(f*20+0.5)) / 20) f = 12.66 fmt.Println(float64(int64(f*20+0.5)) / 20)
func Round(x, unit float64) float64 { return float64(int64(x/unit+0.5)) * unit }
fmt.Println(Round(0.363636, 0.05)) fmt.Println(Round(3.232, 0.05)) fmt.Println(Round(0.4888, 0.05))
fmt.Println(Round(-0.363636, 0.05)) fmt.Println(Round(-3.232, 0.05)) fmt.Println(Round(-0.4888, 0.05))
func Round2(x, unit float64) float64 { if x > 0 { return float64(int64(x/unit+0.5)) * unit } return float64(int64(x/unit-0.5)) * unit }
fmt.Println(Round2(-0.363636, 0.05)) fmt.Println(Round2(-3.232, 0.05)) fmt.Println(Round2(-0.4888, 0.05))
formatted, err := strconv.ParseFloat(fmt.Sprintf("%.2f", rounded), 64)
fmt.Printf("%.30f\n", Round(0.363636, 0.05)) fmt.Printf("%.30f\n", Round(3.232, 0.05)) fmt.Printf("%.30f\n", Round(0.4888, 0.05))
0.349999999999999977795539507497 3.250000000000000000000000000000 0.500000000000000000000000000000
func main() { fmt.Printf("%.3f\n", Round(0.363636, 0.05)) fmt.Printf("%.3f\n", Round(3.232, 0.05)) fmt.Printf("%.3f\n", Round(0.4888, 0.05)) } func Round(x, unit float64) float64 { return float64(int64(x/unit+0.5)) * unit }
package main import ( "fmt" "log" "net/http" ) func main() { resp, err := http.Get("http: if err != nil { log.Fatalf("http.Get => %v", err.Error()) } finalURL := magicFunctionThatTellsMeTheFinalURL(resp) fmt.Printf("The URL you ended up at is: %v", finalURL) }
package main import ( "fmt" "log" "net/http" ) func main() { resp, err := http.Get("http: if err != nil { log.Fatalf("http.Get => %v", err.Error()) } finalURL := resp.Request.URL.String() fmt.Printf("The URL you ended up at is: %v\n", finalURL) }
Equipment: {{$equipment := .Equipment}} {{ range $index, $element := .Equipment}} {{$element.Name}} {{if lt $index ((len $equipment) -1)}} , {{end}} {{end}}
Equipment: {{$equipment := .Equipment}} {{ range $index, $element := .Equipment}} {{if $index}},{{end}} {{$element.Name}} {{end}}
tmpl = tmpl.Funcs(template.FuncMap{"StringsJoin": strings.Join})
package main import ( "fmt" ) func mkAdd(a int) func(...int) int { return func(b... int) int { for _, i := range b { a += i } return a } } func main() { add2 := mkAdd(2) add3 := mkAdd(3) fmt.Println(add2(5,3), add3(6)) }
package main import ( "fmt" ) func mkAdd(a int) func(int) int { return func(b int) int { return a + b } } func main() { add2 := mkAdd(2) add3 := mkAdd(3) fmt.Println(add2(5), add3(6)) }
package main import "fmt" type Add func(int, int) int func (f Add) Apply(i int) func(int) int { return func(j int) int { return f(i, j) } } func main() { var add Add = func(i, j int) int { return i + j } add3 := add.Apply(3) fmt.Println("add 3 to 2:", add3(2)) }
package main import "fmt" type Multiply func(...int) int func (f Multiply) Apply(i int) func(...int) int { return func(values ...int) int { values = append([]int{i}, values...) return f(values...) } } func main() { var multiply Multiply = func(values ...int) int { var total int = 1 for _, value := range values { total *= value } return total } var times2 Multiply = multiply.Apply(2) fmt.Println("times 2:", times2(3, 4), "(expect 24)") times6 := times2.Apply(3) fmt.Println("times 6:", times6(2, 3, 5, 10), "(expect 1800)") }
var strPointer = new(string) *strPointer = "string" functions := map[string]func() { "string": func(){ fmt.Println("works") }, } functions[strPointerValue]()
set --universal -x GOPATH $HOME/path/to/goworkspace
package main import ( "fmt" ) func main() { fmt.Println(say(9)) } func say(num int)(total string){ return fmt.Sprintf("There are %s reasons to code!", num) }
%b base 2 %c the character represented by the corresponding Unicode code point %d base 10 %o base 8 %q a single-quoted character literal safely escaped with Go syntax. %x base 16, with lower-case letters for a-f %X base 16, with upper-case letters for A-F %U Unicode format: U+1234; same as "U+%04X"
0 h h 1 e e 2 l l 3 l l 4 o o package main import "fmt" func main() { str := "Hello" for i, elem := range str { fmt.Println(i, str[i], elem) } for elem := range str { fmt.Println(elem) } }
package main import "fmt" func main() { str := "Hello" for _, r := range str { c := string(r) fmt.Println(c) } fmt.Println() for i, r := range str { fmt.Println(i, r, string(r)) } }
import "fmt" func main() { str := "Hello" for i, elem := range str { fmt.Printf("%d %c %c\n", i, str[i], elem) } }
func (s *Sample) Append(name string) { d := &Stuff{ name: name, } s.data = append(s.data, d) }
func (s Sample) Append(name string) { d := &Stuff{ name: name, } s.data = append(s.data, d) }
func (s *MyStruct) pointerMethod() { } func (s MyStruct) valueMethod() { }
package main import ( "fmt" "time" ) func main() { fmt.Println("Hello world!") duration := time.Second time.Sleep(duration) }
package main import ( "fmt" "bufio" "os" ) func main() { fmt.Println("Hello world!") fmt.Print("Press bufio.NewReader(os.Stdin).ReadBytes( }
package main import "fmt" func main() { fmt.Println("Press the Enter Key to terminate the console screen!") var input string fmt.Scanln(&input) }
package main import "fmt" func main() { fmt.Println("Press the Enter Key to terminate the console screen!") fmt.Scanln() }
type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := &Vertex{3, 4} fmt.Println(v.Abs()) }
func (v *Vertex) Abs() float64 { [...] v := &Vertex{3, 4}
func (v Vertex) Abs() float64 { [...] v := Vertex{3, 4}
func (v Vertex) Abs() float64 { [...] v := &Vertex{3, 4}
func (v *Vertex) Abs() float64 { [...] v := Vertex{3, 4}
func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X+v.Y*v.Y) } func (v *Vertex) Abs() float64 { return Vertex.Abs(*v) }
func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X+v.Y*v.Y) } func main() { v := Vertex{3, 4} v.Abs() }
objdump -M reg-names-raw -d executable > disassembly
--- prog list "main" --- 0000 (x.go:3) TEXT main+0(SB),$8-0 0001 (x.go:3) FUNCDATA $0,gcargs·0+0(SB) 0002 (x.go:3) FUNCDATA $1,gclocals·0+0(SB) 0003 (x.go:4) MOVQ $3,(SP) 0004 (x.go:4) PCDATA $0,$8 0005 (x.go:4) CALL ,runtime.printint+0(SB) 0006 (x.go:4) PCDATA $0,$-1 0007 (x.go:4) PCDATA $0,$0 0008 (x.go:4) CALL ,runtime.printnl+0(SB) 0009 (x.go:4) PCDATA $0,$-1 0010 (x.go:5) RET ,
package main import ( "fmt" ) type MyBoxItem struct { Name string } type MyBox struct { Items []MyBoxItem } func (box *MyBox) AddItem(item MyBoxItem) []MyBoxItem { return append(box.Items, item) } func main() { item1 := MyBoxItem{Name: "Test Item 1"} item2 := MyBoxItem{Name: "Test Item 2"} items := []MyBoxItem{} box := MyBox{items} AddItem(box, item1) fmt.Println(len(box.Items)) }
func (box *MyBox) AddItem(item MyBoxItem) []MyBoxItem { box.Items = append(box.Items, item) return box.Items }
package main import ( "fmt" ) type MyBoxItem struct { Name string } type MyBox struct { Items []MyBoxItem } func (box *MyBox) AddItem(item MyBoxItem) []MyBoxItem { box.Items = append(box.Items, item) return box.Items } func main() { item1 := MyBoxItem{Name: "Test Item 1"} items := []MyBoxItem{} box := MyBox{items} box.AddItem(item1) fmt.Println(len(box.Items)) }
func HLine(x1, y, x2 int) { for ; x1 <= x2; x1++ { img.Set(x1, y, col) } } func VLine(x, y1, y2 int) { for ; y1 <= y2; y1++ { img.Set(x, y1, col) } } func Rect(x1, y1, x2, y2 int) { HLine(x1, y1, x2) HLine(x1, y2, x2) VLine(x1, y1, y2) VLine(x2, y1, y2) }
import ( "image" "image/color" "image/png" "os" ) var img = image.NewRGBA(image.Rect(0, 0, 100, 100)) var col color.Color func main() { col = color.RGBA{255, 0, 0, 255} HLine(10, 20, 80) col = color.RGBA{0, 255, 0, 255} Rect(10, 10, 80, 50) f, err := os.Create("draw.png") if err != nil { panic(err) } defer f.Close() png.Encode(f, img) }
package main import ( "github.com/llgcode/draw2d/draw2dimg" "image" "image/color" ) func main() { i := image.NewRGBA(image.Rect(0, 0, 200, 200)) gc := draw2dimg.NewGraphicContext(i) gc.Save() gc.SetStrokeColor(color.Black) gc.SetFillColor(color.Black) draw2d.Rect(gc, 10, 10, 100, 100) gc.FillStroke() gc.Restore() draw2dimg.SaveToPngFile("yay-rectangle.png", i) }
package main import ( "image" "image/color" "image/draw" "image/png" "os" ) func main() { new_png_file := "/tmp/two_rectangles.png" myimage := image.NewRGBA(image.Rect(0, 0, 220, 220)) mygreen := color.RGBA{0, 100, 0, 255} draw.Draw(myimage, myimage.Bounds(), &image.Uniform{mygreen}, image.ZP, draw.Src) red_rect := image.Rect(60, 80, 120, 160) myred := color.RGBA{200, 0, 0, 255} draw.Draw(myimage, red_rect, &image.Uniform{myred}, image.ZP, draw.Src) myfile, _ := os.Create(new_png_file) png.Encode(myfile, myimage) }
package main import ( "fmt" "image" "image/color" "image/draw" "image/png" "os" ) func main() { new_png_file := "/tmp/chessboard.png" board_num_pixels := 240 myimage := image.NewRGBA(image.Rect(0, 0, board_num_pixels, board_num_pixels)) colors := make(map[int]color.RGBA, 2) colors[0] = color.RGBA{0, 100, 0, 255} colors[1] = color.RGBA{50, 205, 50, 255} index_color := 0 size_board := 8 size_block := int(board_num_pixels / size_board) loc_x := 0 for curr_x := 0; curr_x < size_board; curr_x++ { loc_y := 0 for curr_y := 0; curr_y < size_board; curr_y++ { draw.Draw(myimage, image.Rect(loc_x, loc_y, loc_x+size_block, loc_y+size_block), &image.Uniform{colors[index_color]}, image.ZP, draw.Src) loc_y += size_block index_color = 1 - index_color } loc_x += size_block index_color = 1 - index_color } myfile, err := os.Create(new_png_file) if err != nil { panic(err.Error()) } defer myfile.Close() png.Encode(myfile, myimage) fmt.Println("firefox ", new_png_file) }
func Rect(x1, y1, x2, y2, thickness int, img *image.RGBA) { col := color.RGBA{0, 0, 0, 255} for t:=0; t<thickness; t++ { for x := x1; x<= x2; x++ { img.Set(x, y1+t, col) img.Set(x, y2-t, col) } for y := y1; y <= y2; y++ { img.Set(x1+t, y, col) img.Set(x2-t, y, col) } } } func draw(w http.ResponseWriter, r *http.Request) { img := image.NewRGBA(image.Rect(0, 0, 1200, 1800)) Rect(5, 5, 1195, 1795, 2, img) png.Encode(w, img) }
u, err := url.Parse("http: if err != nil { log.Fatal(err) } u.Scheme = "https" u.Host = "google.com" q := u.Query() q.Set("q", "golang") u.RawQuery = q.Encode() fmt.Println(u)
package main import ( "fmt" "net/url" ) func someURL() string { url := url.URL{ Scheme: "https", Host: "example.com", } return url.String() } func main() { fmt.Println(someURL()) }
package yelk type PhoneOptions struct { phone string cc string lang string }
number := os.Args[1] phoneOptions := yelk.PhoneOptions{phone: number}
package yelk type PhoneOptions struct { Phone string Cc string Lang string }
number := os.Args[1] phoneOptions := yelk.PhoneOptions{Phone: number}
package main import( "fmt" "os/exec" ) func main(){ c := exec.Command("cmd", "/C", "del", "D:\\a.txt") if err := c.Run(); err != nil { fmt.Println("Error: ", err) } }
if c, err := exec.Command("cmd","/c","del","a.txt").CombinedOutput(); err != nil { log.Fatal(err) } else { fmt.Printf("%s\n", c) }
type User struct { name string `json:name-field` age int } ... user := &User{"John Doe The Fourth", 20} getStructTag(user.name) ... func getStructTag(i interface{}) string{ }
field, ok := reflect.TypeOf(user).Elem().FieldByName("name") … tag = string(field.Tag)
one:=make([]byte, 2) two:=make([]byte, 2) one[0]=0x00 one[1]=0x01 two[0]=0x02 two[1]=0x03 log.Printf("%X", append(one[:], two[:])) three:=[]byte{0, 1} four:=[]byte{2, 3} five:=append(three, four)
cannot use four (type []uint8) as type uint8 in append cannot use two[:] (type []uint8) as type uint8 in append
package main import "fmt" func main() { one := make([]byte, 2) two := make([]byte, 2) one[0] = 0x00 one[1] = 0x01 two[0] = 0x02 two[1] = 0x03 fmt.Println(append(one[:], two[:]...)) three := []byte{0, 1} four := []byte{2, 3} five := append(three, four...) fmt.Println(five) }
package main import ( "bytes" "encoding/gob" "fmt" "log" ) type P struct { X, Y, Z int Name string } type Q struct { X, Y *int32 Name string } func main() { var network bytes.Buffer enc := gob.NewEncoder(&network) dec := gob.NewDecoder(&network) err := enc.Encode(P{3, 4, 5, "Pythagoras"}) if err != nil { log.Fatal("encode error:", err) } fmt.Println(network.Bytes()) var q Q err = dec.Decode(&q) if err != nil { log.Fatal("decode error:", err) } fmt.Printf("%q: {%d,%d}\n", q.Name, *q.X, *q.Y) }
package main import ( "crypto/sha1" "fmt" "encoding/binary" "bytes" ) type myStruct struct { ID string Data string } func main() { var bin_buf bytes.Buffer x := myStruct{"1", "Hello"} binary.Write(&bin_buf, binary.BigEndian, x) fmt.Printf("% x", sha1.Sum(bin_buf.Bytes())) }
import ( "bytes" "fmt" "encoding/json" ) type MyStruct struct { Name string `json:"name"` } testStruct := MyStruct{"hello world"} reqBodyBytes := new(bytes.Buffer) json.NewEncoder(reqBodyBytes).Encode(testStruct) reqBodyBytes.Bytes()
package main import ( "fmt" "unsafe" ) type A struct { Src int32 Dst int32 SrcPort uint16 DstPort uint16 } type ByteSliceA struct { Addr *A Len int Cap int } func main() { a := A{0x04030201,0x08070605,0x0A09, 0x0C0B} sb := &ByteSliceA{&a, 12, 12} var byteSlice []byte = *(*[]byte)(unsafe.Pointer(sb)) fmt.Printf("%v\n", byteSlice) }
func main() { x := 1 y := func() { fmt.Println("x:", x) x++ } for i := 0; i < 10; i++ { y() } }
package main import ( "fmt" ) func main() { f := do() f() f() } func do() (f func()){ var i int f = func(){ i++ fmt.Println(i) } return }
strs := []string{"first", "second"} names := make([]interface{}, len(strs)) for i, s := range strs { names[i] = s }
strs := []string{"first", "second"} var names []string names = append(names, strs...)
type Person struct { name string Age int } func main() { db, _ := couchdb.Database(host, database, username, password) joe := Person{ name: "mike", Age: 190, } m, _ := db.PostDocument(joe) }
type Sample struct { Name string age int } joe := Sample{ Name: "xx", age: 23, } byt, _ := json.Marshal(joe) post_data := strings.NewReader(string(byt)) fmt.Println(post_data)
type Sample struct { Name string `json:"name"` Age int `json:"age"` }
type Sample struct{ Name string `json:"name"` Age int `json:"age"` }
var startTime = time.Now() doSomeHardWork() var duration = time.Since(startTime)
start := time.Now() ... operation that takes 20 milliseconds ... t := time.Now() elapsed := t.Sub(start)
start := time.Now() ... operation that takes 20 milliseconds ... t := time.Now() elapsed := t.Sub(start)
var startTime = runtime.nanotime() doSomeHardWork() var duration = runtime.nanotime() - startTime
p1 := passport{} var p2 passport p3 := passport{ Photo: make([]byte, 0, 0), Name: "Scott", Surname: "Adam", DateOfBirth: "Some time", } fmt.Printf("%s\n%s\n%s\n", p1, p2, p3)
pointerp1 := &p3 fmt.Printf("%s", pointerp1) pointerp2 := new(passport) pointerp2.Name = "Anotherscott" fmt.Printf("%s", pointerp2)
pointerp2 := new(passport) pointerp2.Name = "Anotherscott"
go install: no install location for directory /Users/xwilly/Dropbox/go/project/src outside GOPATH
GOPATH=/Users/xwilly/Dropbox/go/project PATH=/Library/Frameworks/Python.framework/Versions/2.7/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/go/bin:/Users/xwilly/Dropbox/go/project/bin
..:src xwilly$ go build test.go ..:src xwilly$ go install test.go go install: no install location for directory /Users/xwilly/Dropbox/go/project/src outside GOPATH
xwilly$ cat test.go package main import ( "fmt" ) func main() { fmt.Println("Bonjour") } xwilly$ go run test.go Bonjour xwilly$ go install test.go go install: no install location for directory /Users/xwilly/Dropbox/go/project/src/learning outside GOPATH
GOPATH=/home/user/gocode /home/user/gocode/ src/ foo/ bar/ (go code in package bar) x.go quux/ (go code in package main) y.go bin/ quux (installed command) pkg/ linux_amd64/ foo/ bar.a (installed package object)
$ mkdir -p /Users/xwilly/Dropbox/go/project/src/billy
_, err := json.Marshal(make(chan int)) _, ok := err.(*json.UnsupportedTypeError)
_, err := json.Marshal(math.Inf(1)) _, ok := err.(*json.UnsupportedValueError)
package main import ( "encoding/json" "fmt" ) func main() { value := make(chan int) _, err := json.Marshal(value) fmt.Println(err) }
package main import "fmt" func main() { fmt.Printf("%d is %s \n", }
- main.go - main_darwin.go - main_windows.go - main_linux.go
package main import "fmt" func main() { fmt.Printf("%d is %s %s", }
package main import ( "fmt" ) func total(ch chan int) { res := 0 for iter := range ch { res += iter } ch <- res } func main() { ch := make(chan int) go total(ch) ch <- 1 ch <- 2 ch <- 3 fmt.Println("Total is ", <-ch) }
package main import ( "fmt" ) func total(in chan int, out chan int) { res := 0 for iter := range in { res += iter } out <- res } func main() { ch := make(chan int) rch := make(chan int) go total(ch, rch) ch <- 1 ch <- 2 ch <- 3 close (ch) result := <- rch fmt.Println("Total is ", result) }
package main import "fmt" func main() { c := make(chan int) go do(c) c <- 1 c <- 2 fmt.Println("Total is ", <-c) } func do(c chan int) { res := 0 for i := 0; i < 2; i++ { res += <-c } c <- res fmt.Println("something") }
import ( "fmt" "strconv" "github.com/hyperledger/fabric/core/chaincode/shim" pb "github.com/hyperledger/fabric/protos/peer" )
sess := session.NewSessionOptions(&session.SessOptions{ CAttrs: map[string]interface{}{"UserName": userName}, Attrs: map[string]interface{}{"Count": 1}, })
userName := sess.CAttr("UserName") count := sess.Attr("Count").(int) sess.SetAttr("Count", count+1)
ctx := appengine.NewContext(r) sessmgr := session.NewCookieManager(session.NewMemcacheStore(ctx)) defer sessmgr.Close() sess := sessmgr.Get(r) if sess != nil { ctx.Infof("Count: %v", sess.Attr("Count")) } else { sess = session.NewSession() sess.SetAttr("Count", 1) sessmgr.Add(sess, w) }
http.HandleFunc("/demo/purge", session.PurgeExpiredSessFromDSFunc(""))
package main import ( "fmt" "os" "syscall" "unsafe" ) func main() { const n = 1e3 t := int(unsafe.Sizeof(0)) * n map_file, err := os.Create("/tmp/test.dat") if err != nil { fmt.Println(err) os.Exit(1) } _, err = map_file.Seek(int64(t-1), 0) if err != nil { fmt.Println(err) os.Exit(1) } _, err = map_file.Write([]byte(" ")) if err != nil { fmt.Println(err) os.Exit(1) } mmap, err := syscall.Mmap(int(map_file.Fd()), 0, int(t), syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED) if err != nil { fmt.Println(err) os.Exit(1) } map_array := (*[n]int)(unsafe.Pointer(&mmap[0])) for i := 0; i < n; i++ { map_array[i] = i * i } fmt.Println(*map_array) err = syscall.Munmap(mmap) if err != nil { fmt.Println(err) os.Exit(1) } err = map_file.Close() if err != nil { fmt.Println(err) os.Exit(1) } }
type Group struct { Base Name string `json:"name" bson"name"` } type Investment struct { Base Symbol string `json:"symbol" bson:"symbol" binding:"required"` Group Group `json:"group" bson:"group"` Fields bson.M `json:"fields" bson:"fields"` }
type Investment struct { Base Symbol string `json:"symbol" binding:"required"` Group string `json:"group,omitempty" bson:",omitempty"` Fields bson.M `json:"fields"` }
func main() { c := Algo("abc") c := Algo([3]int{1,2,3}) } func Algo(list []interface{}) chan []interface{} { n := len(list) out := make(chan []interface{}) go func () { for i := 0; i < n; i++ { result := make([]interface{}, n) copy(result, list) if (result[0] > result[n-1]) { result[0], result[n-1] = result[n-1], result[0] } out <- result } close(out) }() return out }
a := [3]int{1,2,3} b := make([]interface{}, len(a)) for i, _ := range a { b[i] = a[i] }
type algoContainer interface { sort.Interface Copy() algoContainer }
package main import ( "fmt" "sort" ) func main() { s1 := sortableString("abc") c1 := Algo(s1) fmt.Println(s1, <-c1) s2 := sortable3Ints([3]int{1,2,3}) c2 := Algo(&s2) fmt.Println(s2, <-c2) } type algoContainer interface { sort.Interface Copy() algoContainer } type sortableString []byte func (s sortableString) Len() int { return len(s) } func (s sortableString) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s sortableString) Less(i, j int) bool { return s[i] < s[j] } func (s sortableString) Copy() algoContainer { return append(sortableString{}, s...) } func (s sortableString) String() string { return string(s) } type sortable3Ints [3]int func (sortable3Ints) Len() int { return 3 } func (s *sortable3Ints) Swap(i, j int) { (*s)[i], (*s)[j] = (*s)[j], (*s)[i] } func (s sortable3Ints) Less(i, j int) bool { return s[i] < s[j] } func (s sortable3Ints) Copy() algoContainer { c := s; return &c } func Algo(list algoContainer) chan algoContainer { n := list.Len() out := make(chan algoContainer) go func () { for i := 0; i < n; i++ { result := list.Copy() if result.Less(n-1, 0) { result.Swap(n-1, 0) } out <- result } close(out) }() return out }
type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) }
func After(d Duration) <-chan Time { return NewTimer(d).C } func NewTimer(d Duration) *Timer { c := make(chan Time, 1) t := &Timer{ C: c, r: runtimeTimer{ when: nano() + int64(d), f: sendTime, arg: c, }, } startTimer(&t.r) return t }
f1 10000 120860 ns/op 2433 B/op 28 allocs/op f2 10000 120288 ns/op 2288 B/op 26 allocs/op
const MaxLatin1 = func IsGraphic(r rune) bool { if uint32(r) <= MaxLatin1 { return properties[uint8(r)]&pg != 0 } return In(r, GraphicRanges...) }
type ColorGroup struct { ID int `json:",omitempty"` Name string Colors []string } type Total struct { A ColorGroup`json:",omitempty"` B string`json:",omitempty"` } group := Total{ A: ColorGroup{}, }
type Total struct { A *ColorGroup`json:",omitempty"` B string`json:",omitempty"` }
package main import ( "encoding/json" "fmt" "os" ) func main() { type colorGroup struct { ID int `json:",omitempty"` Name string Colors []string } type total struct { A *colorGroup `json:",omitempty"` B string `json:",omitempty"` } groupWithNilA := total{ B: "abc", } b, err := json.Marshal(groupWithNilA) if err != nil { fmt.Println("error:", err) } os.Stderr.Write(b) println() groupWithPointerToZeroA := total{ A: &colorGroup{}, B: "abc", } b, err = json.Marshal(groupWithPointerToZeroA) if err != nil { fmt.Println("error:", err) } os.Stderr.Write(b) }
type <name> struct { < varname > < vartype > \`json : -\` }
go get -u -d github.com/directmeasure/VScodeDebugGoAppEngine.git
export BASEFOLDER="/Users/Bryan/google-cloud-sdk/" . export GOROOT="/usr/local/go"
Verbose logs are written to: /var/folders/mw/0y88j8_54bjc93d_lg3120qw0000gp/T/vscode-go-debug.txt 16:02:31, 2018-4-5 InitializeRequest InitializeResponse Using GOPATH: /Users/Bryan/go fmt.Print(u) Please start a debug session to evaluate
{ "version": "0.2.0", "configurations": [ { "name": "Launch", "type": "go", "request": "launch", "mode": "debug", "remotePath": "", "port": 2345 "host": "127.0.0.1", "program": "${workspaceFolder}/hello.go", "env": {}, "args": [], "showLog": true, "trace": true, } ] }
go version go1.10 darwin/amd64 $ gcloud version . Google Cloud SDK 197.0.0 app-engine-go app-engine-python 1.9.68 bq 2.0.31 core 2018.04.06 gsutil 4.30 VS code extension: Go 0.6.78
$ lsof -n -i :8080 Bryan@Bryans-MacBook-Pro Thu Apr 12 17:02:04 ~ $ lsof -n -i :2345 Bryan@Bryans-MacBook-Pro Thu Apr 12 17:03:34 ~ $ ps aux | grep _go_app Bryan 7433 0.0 0.0 2434840 800 s000 S+ 5:03PM 0:00.00 grep _go_app Bryan 7426 0.0 0.0 556603172 3896 s002 S+ 5:02PM 0:00.01 /var/folders/mw/0y88j8_54bjc93d_lg3120qw0000gp/T/tmp8GWk1gappengine-go-bin/_go_app Bryan@Bryans-MacBook-Pro Thu Apr 12 17:03:52 ~ $ dlv attach --headless -l "localhost:2345" 7426 /var/folders/mw/0y88j8_54bjc93d_lg3120qw0000gp/T/tmp8GWk1gappengine-go-bin/_go_app API server listening at: 127.0.0.1:2345
Verbose logs are written to: /var/folders/mw/0y88j8_54bjc93d_lg3120qw0000gp/T/vscode-go-debug.txt couldn Process exiting with code: 1
go get github.com/GoogleCloudPlatform/golang-samples/tree/master/appengine/helloworld/...
package foo ... type Messages struct { Locale string ErrorDatastore string LoginSuccessful string ... }
const Messages ContextKey = iota ... k := datastore.NewKey(c, "Messages", "en_US", 0, nil) m := new(Messages) if err := datastore.Get(c, k, m); err != nil { ... } else { context.Set(r, Messages, m) }
~appname/ |~app/ | `-app.go |+github.com/ `-app.yaml
package app import ( "fmt" "log" "net/http" "github.com/samuel/go-gettext" ) func init () { http.HandleFunc("/", home) } func home(w http.ResponseWriter, r *http.Request) { d, err := gettext.NewDomain("appname", "locale") if err != nil { log.Fatal("Failed at NewDomain.") } cat := d.GetCatalog("fr_FR") if cat == gettext.NullCatalog { log.Fatal("Failed at GetCatalog.") } fmt.Fprintf(w, cat.GetText("Yes.")) }
$ xgettext -d appname -kGetText -s -o appname.pot app/app.go
$ mkdir -p locale/fr_FR/LC_MESSAGES $ msginit -l fr_FR -o french.po -i appname.pot
# msgid "" msgstr "" "Project-Id-Version: appname v0.1\n" "Report-Msgid-Bugs-To: \n" "POT-Creation-Date: 2013-01-13 11:03+1300\n" "PO-Revision-Date: 2013-01-13 11:10+1300\n" "Last-Translator: Rich <rich@example.com>\n" "Language-Team: French\n" "Language: fr\n" "MIME-Version: 1.0\n" "Content-Type: text/plain; charset=UTF-8\n" "Content-Transfer-Encoding: 8bit\n" "Plural-Forms: nplurals=2; plural=(n > 1);\n" msgid "Yes." msgstr "Oui."
$ msgfmt -c -v -o locale/fr_FR/LC_MESSAGES/appname.mo french.po
~appname/ |~app/ | `-app.go |~github.com/ | `~samuel/ | `~go-gettext/ | +locale/ | |-catalog.go | |-domain.go | `-mo.go |~locale/ | `~fr_FR/ | `LC_MESSAGES/ | `-appname.mo `-app.yaml
import "github.com/leonelquinteros/gotext" func main() { gotext.SetLibrary("/path/to/locales") gotext.SetLanguage("es_ES") println(gotext.Get("Translate this text")) }
import "github.com/leonelquinteros/gotext" func main() { str := ` msgid "One apple" msgstr "Una manzana" msgid "One orange" msgstr "Una naranja" msgid "My name is %s" msgstr "Mi nombre es %s" ` po := new(Po) po.Parse(str) println(po.Get("One orange")) name := "Tom" println(po.Get("My name is %s", name)) }
package main import ( "fmt" "net/http" ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hi there, I love %s!", r.URL.Path[1:]) } func main() { http.HandleFunc("/", handler) http.ListenAndServe("127.0.0.1:8080", nil) }
$ curl 127.0.0.1:8080 curl: (7) Failed to connect to 127.0.0.1 port 8080: Operation timed out $ nc -v -G 5 127.0.0.1 8080 nc: connectx to 127.0.0.1 port 8080 (tcp) failed: Operation timed out
$ tcpdump -i lo0 port 8080 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on lo0, link-type NULL (BSD loopback), capture size 262144 bytes 18:21:30.906638 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118569352 ecr 0,sackOK,eol], length 0 18:21:31.006824 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118569452 ecr 0,sackOK,eol], length 0 18:21:31.106989 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118569552 ecr 0,sackOK,eol], length 0 18:21:31.208141 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118569653 ecr 0,sackOK,eol], length 0 18:21:31.308288 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118569753 ecr 0,sackOK,eol], length 0 18:21:31.408336 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118569853 ecr 0,sackOK,eol], length 0 18:21:31.609143 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118570053 ecr 0,sackOK,eol], length 0 18:21:32.011215 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118570453 ecr 0,sackOK,eol], length 0 18:21:32.812512 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118571253 ecr 0,sackOK,eol], length 0 18:21:34.414686 IP localhost.52799 > localhost.http-alt: Flags [S], seq 3375761924, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 118572853 ecr 0,sackOK,eol], length 0
socket(0x2, 0x1, 0x0) = 3 0 fcntl(0x3, 0x2, 0x1) = 0 0 fcntl(0x3, 0x3, 0x0) = 2 0 fcntl(0x3, 0x4, 0x6) = 0 0 setsockopt(0x3, 0xFFFF, 0x20) = 0 0 setsockopt(0x3, 0xFFFF, 0x4) = 0 0 bind(0x3, 0xC8200BA6AC, 0x10) = 0 0 listen(0x3, 0xFDE8, 0x10) = 0 0 kqueue(0x3, 0xFDE8, 0x10) = 4 0 fcntl(0x4, 0x2, 0x1) = 0 0 kevent(0x4, 0xC8200558C0, 0x2) = 0 0 getsockname(0x3, 0xC82005592C, 0xC820055928) = 0 0 accept(0x3, 0xC820055AA4, 0xC820055A94) = -1 Err kevent(0x4, 0x0, 0x0) = 0 0 select(0x0, 0x0, 0x0, 0x0, 0x700000080DE8) = 0 0
sudo rm /etc/sysctl.conf sudo sysctl kern.ipc.somaxconn=128 sudo rm /Library/LaunchDaemons/limit.maxproc.plist sudo rm /Library/LaunchDaemons/limit.maxfiles.plist
sudo /opt/cisco/anyconnect/bin/websecurity_uninstall.sh
monitor_ 13105 root 101u sock 0,6 0t0 16960100 can monitor_ 13105 root 102u sock 0,6 0t0 21552427 can monitor_ 13105 root 103u sock 0,6 0t0 17565091 can monitor_ 13105 root 104u sock 0,6 0t0 18476870 can
[root@Monitor_q ~] Name: monitor_client State: S (sleeping) Tgid: 13105 Pid: 13105 PPid: 13104 TracerPid: 0 Uid: 0 0 0 0 Gid: 0 0 0 0 Utrace: 0 FDSize: 16384 Groups: ... [root@Monitor_q ~] Limit Soft Limit Hard Limit Units Max cpu time unlimited unlimited seconds Max file size unlimited unlimited bytes Max data size unlimited unlimited bytes Max stack size 10485760 unlimited bytes Max core file size 0 unlimited bytes Max resident set unlimited unlimited bytes Max processes 3870 3870 processes Max open files 9999 9999 files Max locked memory 65536 65536 bytes Max address space unlimited unlimited bytes Max file locks unlimited unlimited locks Max pending signals 3870 3870 signals Max msgqueue size 819200 819200 bytes Max nice priority 0 0 Max realtime priority 0 0 Max realtime timeout unlimited unlimited us [root@Monitor_q ~] lrwx------ 1 root root 64 Dec 7 00:15 8382 -> socket:[52023221] lrwx------ 1 root root 64 Dec 7 00:15 8383 -> socket:[51186627] lrwx------ 1 root root 64 Dec 7 00:15 8384 -> socket:[51864232] lrwx------ 1 root root 64 Dec 7 00:15 8385 -> socket:[52435453] lrwx------ 1 root root 64 Dec 7 00:15 8386 -> socket:[51596071] lrwx------ 1 root root 64 Dec 7 00:15 8387 -> socket:[52767667] lrwx------ 1 root root 64 Dec 7 00:15 8388 -> socket:[52090632] lrwx------ 1 root root 64 Dec 7 00:15 8389 -> socket:[51739068] lrwx------ 1 root root 64 Dec 7 00:15 839 -> socket:[22963529] lrwx------ 1 root root 64 Dec 7 00:15 8390 -> socket:[52023223] lrwx------ 1 root root 64 Dec 7 00:15 8391 -> socket:[52560389] lrwx------ 1 root root 64 Dec 7 00:15 8392 -> socket:[52402565] ...
package main import ( "crypto/tls" "encoding/json" "fmt" "log" "net" "net/http" nurl "net/url" "strconv" "strings" "syscall" "time" ) type Result struct { Error string `json:"error"` HttpStatus int `json:"http_status"` Stime time.Duration `json:"http_time"` } func MonitorHttp(w http.ResponseWriter, r *http.Request) { var host, servername, path, port, scheme string var timeout int u, err := nurl.Parse(r.RequestURI) if err != nil { log.Fatal(err) return } if host = u.Query().Get("host"); host == "" { host = "127.0.0.0" } if servername = u.Query().Get("servername"); servername == "" { servername = "localhost" } if path = u.Query().Get("path"); path == "" { path = "/" } if port = u.Query().Get("port"); port == "" { port = "80" } if scheme = u.Query().Get("scheme"); scheme == "" { scheme = "http" } if timeout, _ = strconv.Atoi(u.Query().Get("timeout")); timeout == 0 { timeout = 5 } w.Header().Set("Content-Type", "application/json") res := httptool(host, port, servername, scheme, path, timeout) result, _ := json.Marshal(res) fmt.Fprintf(w, "%s", result) } func httptool(ip, port, servername, scheme, path string, timeout int) Result { var result Result startTime := time.Now() host := ip + ":" + port transport := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, DisableKeepAlives: true, } dialer := net.Dialer{ Timeout: time.Duration(timeout) * time.Second, KeepAlive: 0 * time.Second, } transport.Dial = func(network, address string) (net.Conn, error) { return dialer.Dial(network, address) } client := &http.Client{ Transport: transport, } rawquery := "" url := fmt.Sprintf("%s: req, err := http.NewRequest("GET", url, nil) if err != nil { result.HttpStatus = -1 errs := strings.Split(err.Error(), ": ") result.Error = errs[len(errs)-1] result.Stime = time.Now().Sub(startTime) / time.Millisecond return result } req.Header.Set("User-Agent", "monitor worker") req.Header.Set("Connection", "close") req.Host = servername resp, err := client.Do(req) if err != nil { nerr, ok := err.(*nurl.Error) if ok { switch cerr := nerr.Err.(type) { case *net.OpError: switch cerr.Err.(type) { case *net.DNSError: errs := strings.Split(cerr.Error(), ": ") result.Error = "dns: " + errs[len(errs)-1] default: errs := strings.Split(cerr.Error(), ": ") result.Error = "server: " + errs[len(errs)-1] } default: switch nerr.Err.Error() { case "net/http: request canceled while waiting for connection": errs := strings.Split(cerr.Error(), ": ") result.Error = "timeout: " + errs[len(errs)-1] default: errs := strings.Split(cerr.Error(), ": ") result.Error = "unknown: " + errs[len(errs)-1] } } } else { result.Error = "unknown: " + err.Error() } result.HttpStatus = -2 result.Stime = time.Now().Sub(startTime) / time.Millisecond return result } resp.Body.Close() result.HttpStatus = resp.StatusCode result.Error = "noerror" result.Stime = time.Now().Sub(startTime) / time.Millisecond return result } func setRlimit() { var rLimit syscall.Rlimit err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &rLimit) if err != nil { log.Printf("Unable to obtain rLimit", err) } if rLimit.Cur < rLimit.Max { rLimit.Max = 9999 rLimit.Cur = 9999 err = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &rLimit) if err != nil { log.Printf("Unable to increase number of open files limit", err) } } } func main() { setRlimit() s := &http.Server{ Addr: ":59059", ReadTimeout: 7 * time.Second, WriteTimeout: 7 * time.Second, } http.HandleFunc("/http", MonitorHttp) log.Fatal(s.ListenAndServe()) }
% go doc http.transport.dial type Transport struct { connections. // Dial func(network, addr string) (net.Conn, error)
package main import ("net/http" "log" "net/url" ) func Login(user, password string) string { postUrl := "http: values := make(url.Values) values.Set("user", user) values.Set("password", password) resp, err := http.PostForm(postUrl, values) if err != nil { log.Fatal(err) } defer resp.Body.Close() return "Hello" } func ViewBill(url string, cookies) string { }
import ( "net/http" "net/http/cookiejar" ) cookieJar, _ := cookiejar.New(nil) client := &http.Client{ Jar: cookieJar, }
package main import ( "fmt" "net/http" "net/url" "io/ioutil" "sync" ) type Jar struct { lk sync.Mutex cookies map[string][]*http.Cookie } func NewJar() *Jar { jar := new(Jar) jar.cookies = make(map[string][]*http.Cookie) return jar } func (jar *Jar) SetCookies(u *url.URL, cookies []*http.Cookie) { jar.lk.Lock() jar.cookies[u.Host] = cookies jar.lk.Unlock() } func (jar *Jar) Cookies(u *url.URL) []*http.Cookie { return jar.cookies[u.Host] } func main() { jar := NewJar() client := http.Client{nil, nil, jar} resp, _ := client.PostForm("http: "email": {"myemail"}, "password": {"mypass"}, }) resp.Body.Close() resp, _ = client.Get("http: b, _ := ioutil.ReadAll(resp.Body) resp.Body.Close() fmt.Println(string(b)) }
package main import "fmt" import "net/http" import "io/ioutil" import "strings" func main() { client := &http.Client{} PostData := strings.NewReader("useId=5&age=12") req, err := http.NewRequest("POST", "http: req.Header.Set("Cookie", "name=xxxx; count=x") resp, err := client.Do(req) data, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Printf("error = %s \n", err); } fmt.Printf("Response = %s", string(data)); }
expiration := time.Now().Add(5 * time.Minute) cookie := http.Cookie{Name: "myCookie", Value: "Hello World", Expires: expiration} http.SetCookie(w, &cookie)
package main import ( "strconv" "fmt" ) func main() { t := strconv.Itoa64(1234) fmt.Println(t) }
import unsafe "unsafe" type INotifyInfo struct { Wd int32 Mask uint32 Cookie uint32 Len uint32 } func doSomething() { var info INotifyInfo const infoSize = unsafe.Sizeof(info) ... }
package main import ( "encoding/binary" "fmt" "reflect" ) type T struct { a uint32 b int8 } func main() { var t T r := reflect.ValueOf(t) s := binary.TotalSize(r) fmt.Println(s) }
package main import ( "fmt" "unsafe" ) type Coord3d struct { X, Y, Z int64 } func main() { var dummy *Coord3d fmt.Printf("sizeof(Coord3d) = %d\n", unsafe.Sizeof(*dummy)) }
var factor int for i, c := range s[:12] { if i % 2 == 0 { factor = 1 } else { factor = 3 } buf := make([]byte, 1) _ = utf8.EncodeRune(buf, c) value, _ := strconv.Atoi(string(buf)) sum += value * factor }
package main import ( "fmt" "strconv" "unicode/utf8" ) func main() { s := "9780486653556" var factor, sum1, sum2 int for i, c := range s[:12] { if i%2 == 0 { factor = 1 } else { factor = 3 } buf := make([]byte, 1) _ = utf8.EncodeRune(buf, c) value, _ := strconv.Atoi(string(buf)) sum1 += value * factor sum2 += (int(c) - } fmt.Println(sum1, sum2) }
> gols code.google.com/p/go.crypto/bcrypt github.com/golang/lint/golint github.com/kishorevaishnav/revelgen github.com/lukehoban/go-find-references github.com/lukehoban/go-outline github.com/newhook/go-symbols github.com/nsf/gocode github.com/revel/cmd/revel github.com/revel/revel github.com/rogpeppe/godef github.com/tpng/gopkgs golang.org/x/tools/cmd/goimports golang.org/x/tools/cmd/gorename gopkg.in/gorp.v1 sourcegraph.com/sqs/goreturns
