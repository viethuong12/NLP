int i, a[100]; for (i = 0; i < LEN(a); i++) { ... }
auto memblock=static_cast<T*>(malloc(n*sizeof(T)));
long x = 5; double *p = (double *)&x; double y = *p;
struct foo { int x; }; struct bar { int x; int y; }; struct bar b = { 1, 2}; struct foo *p = (struct foo *)&b; int z = p->x;
/* Force a compilation error if condition is true, but also produce a result (of value 0 and type size_t), so the expression can be used e.g. in a structure initializer (or where-ever else comma expressions aren
do { \ extern void you_did_something_bad(void); \ if (!(test)) \ you_did_something_bad(void); \ } while (0)
do { \ extern void this_isnt_five(void) __attribute__((error( \ "I asked for five and you gave me " if ((number) != 5) \ this_isnt_five(); \ } while (0)
({ \ typeof(number) n = (number); \ extern void this_number_is_five(void) __attribute__(( \ error("I told you not to give me a five!"))); \ if (n == 5) \ this_number_is_five(); \ n; \ })
double zero = 0.0; double a[] = { 0,0,0,0,0, zero/zero}; cout << (a[5] == 5[a] ? "true" : "false") << endl;
int a[] = { 2 , 3 , 3 , 2 , 4 }; int s = sizeof a / sizeof *a; for(int i = 0 ; i < s ; ++i) { cout << a[a[a[i]]] << endl; cout << i[a][a][a] << endl; }
class Sub { public: int operator [](size_t nIndex) { return 0; } }; int main() { Sub s; s[0]; 0[s]; }
Base Address of your Array a + (5*size of(data type for array a)) i.e. 1000 + (5*2) = 1010
Base Address of your Array a + (size of(data type for array a)*5) i.e. 1000 + (2*5) = 1010
Base Address of your Array a + (-5 * size of(data type for array a)) i.e. 1000 + (-5*2) = 990
int a[]={10,20,30,40,50}; int *p=a; printf("%d\n",*p++); printf("%d\n",*a++);
int add2to3(int (*functionPtr)(int, int)) { return (*functionPtr)(2, 3); }
int (*functionFactory(int n))(int, int) { printf("Got parameter %d", n); int (*functionPtr)(int,int) = &addInt; return functionPtr; }
typedef int (*myFuncDef)(int, int); myFuncDef functionFactory(int n) { printf("Got parameter %d", n); myFuncDef functionPtr = &addInt; return functionPtr; }
typedef struct String_Struct* String; struct String_Struct { char* (*get)(const void* self); void (*set)(const void* self, char* value); int (*length)(const void* self); }; char* getString(const void* self); void setString(const void* self, char* value); int lengthString(const void* self); String newString();
String newString() { String self = (String)malloc(sizeof(struct String_Struct)); self->get = &getString; self->set = &setString; self->length = &lengthString; self->set(self, ""); return self; }
char* getString(const void* self_obj) { return ((String)self_obj)->internal->value; }
typedef struct ImmutableString_Struct* ImmutableString; struct ImmutableString_Struct { String base; char* (*get)(const void* self); int (*length)(const void* self); }; ImmutableString newImmutableString(const char* value);
ImmutableString newImmutableString(const char* value) { ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct)); self->base = newString(); self->get = self->base->get; self->length = self->base->length; self->base->set(self->base, (char*)value); return self; }
int lengthOverrideMethod(const void* self) { return 0; }
ImmutableString newImmutableString(const char* value) { ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct)); self->base = newString(); self->get = self->base->get; self->length = &lengthOverrideMethod; self->base->set(self->base, (char*)value); return self; }
int eax = ((int(*)())("\xc3 <- This returns the value of the EAX register"))();
int a = 10, b = 20; ((void(*)(int*,int*))"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 <- This swaps the values of a and b")(&a,&b);
((int(*)())"\x66\x31\xc0\x8b\x5c\x24\x04\x66\x40\x50\xff\xd3\x58\x66\x3d\xe8\x03\x75\xf4\xc3")(&function);
const char* lol = "\x8b\x5c\x24\x4\x3d\xe8\x3\x0\x0\x7e\x2\x31\xc0\x83\xf8\x64\x7d\x6\x40\x53\xff\xd3\x5b\xc3\xc3 <- Recursively calls the function at address lol."; i = ((int(*)())(lol))(lol);
const char swap[] = "\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3 <- This swaps the values of a and b";
00000000 <swap>: 0: 8b 44 24 04 mov eax,DWORD PTR [esp+0x4] 4: 8b 5c 24 08 mov ebx,DWORD PTR [esp+0x8] 8: 8b 00 mov eax,DWORD PTR [eax] a: 8b 1b mov ebx,DWORD PTR [ebx] c: 31 c3 xor ebx,eax e: 31 d8 xor eax,ebx 10: 31 c3 xor ebx,eax 12: 8b 4c 24 04 mov ecx,DWORD PTR [esp+0x4] 16: 89 01 mov DWORD PTR [ecx],eax 18: 8b 4c 24 08 mov ecx,DWORD PTR [esp+0x8] 1c: 89 19 mov DWORD PTR [ecx],ebx 1e: c3 ret not shown: the later bytes are ASCII text documentation they
typedef struct { char* name; int red; int green; int blue; } Color; Color Colors[MAX_COLORS]; void eachColor (void (*fp)(Color *c)) { int i; for (i=0; i<MAX_COLORS; i++) (*fp)(&Colors[i]); } void printColor(Color* c) { if (c->name) printf("%s = %i,%i,%i\n", c->name, c->red, c->green, c->blue); } int main() { Colors[0].name="red"; Colors[0].red=255; Colors[1].name="blue"; Colors[1].blue=255; Colors[2].name="black"; eachColor(printColor); }
typedef int ReturnFunction(char); typedef int ParameterFunction(void); ReturnFunction *f(ParameterFunction *p);
function taking [pointer to [function taking [void] returning [int]]] returning [pointer to [function taking [char] returning [int]]]
pointer to: *ID1 ... function taking void returning: (*ID1)(void)
void board_init(); void noprintf(const char *c, ...); void (* zprintf)(const char*, ...);
/*****************************************************************************/ /** * @name board_init * * Sets up the application based on the version type defined in version.h. * Includes allowing or prohibiting printing to STDOUT. * * MUST BE CALLED FIRST THING IN MAIN * * @return None * *****************************************************************************/ void board_init() { zprintf = &printf; zprintf = &noprintf; } /*****************************************************************************/ /** * @name noprintf * * simply returns with no actions performed * * @return None * *****************************************************************************/ void noprintf(const char* c, ...) { return; }
int main() { board_init(); void *ptr = malloc(100); if (ptr == NULL) { zprintf("Unable to allocate memory\n"); return 1; } return 0; }
typedef int (*two_num_operation)(int, int); static int sum(int a, int b) { return a + b; } static int sum_via_pointer(int a, int b, two_num_operation funp) { return (*funp)(a, b); } static two_num_operation get_sum_fun() { return &sum; } void test_pointer_as_variable() { two_num_operation sum_p = &sum; printf("pointer as variable:\t %d + %d = %d\n", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B)); } void test_pointer_as_param() { printf("pointer as param:\t %d + %d = %d\n", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &sum)); } void test_pointer_as_return_value() { printf("pointer as return value:\t %d + %d = %d\n", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B)); } int main() { test_pointer_as_variable(); test_pointer_as_param(); test_pointer_as_return_value(); return 0; }
int add() { return (100+10); } int sub() { return (100-10); } void print(int x, int y, int (*func)()) { printf("value is : %d", (x+y+(*func)())); } int main() { int x=100, y=200; print(x,y,add); print(x,y,sub); return 0; }
void (*print)() ; void sayhello(); int main() { print=sayhello; print(); return 0; } void sayhello() { printf("\n Hello World"); }
int func (int a, char *pStr); int (*pFunc)(int a, char *pStr); int (*pFunc2) (); int (*pFunc3) (void);
int *pfunc(int a, char *pStr); int (*pFunc)(int a, char *pStr);
int (*pFunc) (int a, char *pStr); int (*pFunc[55])(int a, char *pStr); int (**pFunc)(int a, char *pStr); struct { int x22; int (*pFunc)(int a, char *pStr); } thing = {0, func}; char * xF (int x, int (*p)(int a, char *pStr)); char * (*pxF) (int x, int (*p)(int a, char *pStr));
int sum (int a, int b, ...); int (*psum)(int a, int b, ...);
int sum (); int (*psum)(); int sum2(void); int (*psum2)(void);
int sum (int a, char *b); int (*psplsum) (int a, int b); psplsum = sum; psplsum = (int (*)(int a, int b)) sum; psplsum = (int *(int a, int b)) sum;
static int func1(int a, int b) { return a + b; } static int func2(int a, int b, char *c) { return c[0] + a + b; } static int func3(int a, int b, char *x) { return a + b; } static char *func4(int a, int b, char *c, int (*p)()) { if (p == func1) { p(a, b); } else if (p == func2) { p(a, b, c); } else if (p == func3) { p(a, b, c); } return c; }
int(*p[])() = { func1, func2, func3 }; int(**pp)(); p[0](a, b); p[1](a, b, 0); p[2](a, b); func4(a, b, 0, func1); func4(a, b, 0, func2); func4(a, b, 0, func3); for (i = 0; i < sizeof(p) / sizeof(p[0]); i++) { func4(a, b, 0, p[i]); } for (pp = p; pp < p + sizeof(p)/sizeof(p[0]); pp++) { (*pp)(a, b, 0); func4(a, b, 0, *pp); }
typedef struct { int (*func1) (int a, int b); char *(*func2) (int a, int b, char *c); } FuncThings; extern const FuncThings FuncThingsGlobal;
static int func1 (int a, int b) { return a + b; } static char *func2 (int a, int b, char *c) { c[0] = a % 100; c[1] = b % 50; return c; } const FuncThings FuncThingsGlobal = {func1, func2};
typedef struct { HMODULE hModule; int (*Func1)(); int (*Func2)(); int(*Func3)(int a, int b); } LibraryFuncStruct; int LoadLibraryFunc LPCTSTR dllFileName, LibraryFuncStruct *pStruct) { int retStatus = 0; pStruct->hModule = LoadLibrary (dllFileName); if (pStruct->hModule) { pStruct->Func1 = (int (*)()) GetProcAddress (pStruct->hModule, "Func1"); pStruct->Func2 = (int (*)()) GetProcAddress (pStruct->hModule, "Func2"); pStruct->Func3 = (int (*)(int a, int b)) GetProcAddress(pStruct->hModule, "Func3"); retStatus = 1; } return retStatus; } void FreeLibraryFunc (LibraryFuncStruct *pStruct) { if (pStruct->hModule) FreeLibrary (pStruct->hModule); pStruct->hModule = 0; }
LibraryFuncStruct myLib = {0}; LoadLibraryFunc (L"library.dll", &myLib); myLib.Func1(); FreeLibraryFunc (&myLib);
void * ApplyAlgorithm (void *pArray, size_t sizeItem, size_t nItems, int (*p)(void *)) { unsigned char *pList = pArray; unsigned char *pListEnd = pList + nItems * sizeItem; for ( ; pList < pListEnd; pList += sizeItem) { p (pList); } return pArray; } int pIncrement(int *pI) { (*pI)++; return 1; } void * ApplyFold(void *pArray, size_t sizeItem, size_t nItems, void * pResult, int(*p)(void *, void *)) { unsigned char *pList = pArray; unsigned char *pListEnd = pList + nItems * sizeItem; for (; pList < pListEnd; pList += sizeItem) { p(pList, pResult); } return pArray; } int pSummation(int *pI, int *pSum) { (*pSum) += *pI; return 1; } int intList[30] = { 0 }, iSum = 0; ApplyAlgorithm(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), pIncrement); ApplyFold(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), &iSum, pSummation);
gcc -std=c90 -pedantic ... gcc -std=c99 -pedantic gcc -std=c11 -pedantic
main() { printf(&unix["\021%six\012\0"],(unix)["have"]+"fun"-0x60);}
$ cpp --std=c89 -dM < /dev/null | grep linux $ cpp --std=gnu89 -dM < /dev/null | grep linux $ cpp --std=c99 -dM < /dev/null | grep linux $ cpp --std=gnu99 -dM < /dev/null | grep linux
main(_){_^448&&main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8][">
!! !!!!!! !! !!!!!! !! !!!!!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!!!!! !! !! !! !! !! !!!!!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!!!!! !! !! !! !!!!!!
sykes2.c:1:1: warning: return type defaults to ‘int’ [-Wreturn-type] sykes2.c: In function ‘main’: sykes2.c:1:14: warning: value computed is not used [-Wunused-value] sykes2.c:1:1: warning: implicit declaration of function ‘putchar’ [-Wimplicit-function-declaration] sykes2.c:1:1: warning: suggest parentheses around arithmetic in operand of ‘|’ [-Wparentheses] sykes2.c:1:1: warning: suggest parentheses around arithmetic in operand of ‘|’ [-Wparentheses] sykes2.c:1:1: warning: control reaches end of non-void function [-Wreturn-type]
main(_) { _^448 && main(-~_); putchar(--_%64 ? 32 | -~7[__TIME__-_/8%8]["> : 10); }
main(int i) { if(i^448) main(-~i); if(--i % 64) { char a = -~7[__TIME__-i/8%8]["> char b = a >> ";;;====~$::199"[i*2&8|i/64]/(i&2?1:8)%8; putchar(32 | (b & 1)); } else { putchar(10); } }
main(int i) { if(i != 448) main(i+1); i--; if(i % 64 == 0) { putchar( } else { char a = -~7[__TIME__-i/8%8]["> char b = a >> ";;;====~$::199"[i*2&8|i/64]/(i&2?1:8)%8; putchar(32 | (b & 1)); } }
main(int i) { if(i != 448) main(i+1); i--; if(i % 64 == 0) { putchar( } else { char a = ("> char b = a >> ";;;====~$::199"[(i*2&8)|i/64]/(i&2?1:8)%8; putchar(32 | (b & 1)); } }
main() { int i; for(i=447; i>=0; i--) { if(i % 64 == 0) { putchar( } else { char t = __TIME__[7 - i/8%8]; char a = "> int shift = ";;;====~$::199"[(i*2&8) | (i/64)]; if((i & 2) == 0) shift /= 8; shift = shift % 8; char b = a >> shift; putchar(32 | (b & 1)); } } }
row col val 6 6-7 0 6 4-5 0 6 2-3 5 6 0-1 7 5 6-7 1 5 4-5 7 5 2-3 5 5 0-1 7 4 6-7 1 4 4-5 7 4 2-3 5 4 0-1 7 3 6-7 1 3 4-5 6 3 2-3 5 3 0-1 7 2 6-7 2 2 4-5 7 2 2-3 3 2 0-1 7 1 6-7 2 1 4-5 7 1 2-3 3 1 0-1 7 0 6-7 4 0 4-5 4 0 2-3 3 0 0-1 7
00005577 11775577 11775577 11665577 22773377 22773377 44443377
0 00111111 1 00101000 2 01110101 3 01111001 4 01101010 5 01011011 6 01011111 7 00101001 8 01111111 9 01111011 : 01000000
----!!-- !!--!!-- !!--!!-- !!!!!!-- ----!!-- ----!!-- ----!!--
main(_){_^448&&main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8][">
!! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !! !!
main(_){ _^448&&main(-~_); putchar((--_%64) ? (32|-(~7[__TIME__-_/8%8])["> }
main(int argc) { if (argc^448) main(-(~argc)); if (argc % 64) { putchar((32|-(~7[__TIME__-argc/8%8])["> } else putchar( }
-(~(7[__TIME__-argc/8%8]["> (";;;====~$::199"[argc*2&8|argc/64]) / (argc&2?1:8) % 8
int pixelX, line, digit ; for(line=6; line >= 0; line--){ for (digit =0; digit<8; digit++){ for(pixelX=7;pixelX > 0; pixelX--){ putchar( (";;;====~$::199"[pixel*2 & 8 | line] / (pixelX&2 ? 1 : 8) ) % 8 & 1); } } putchar( }
int pixelX, line, digit, shift; char shiftChar; for(line=6; line >= 0; line--){ for (digit =0; digit<8; digit++){ for(pixelX=7;pixelX >= 0; pixelX--){ shiftChar = ";;;====~$::199"[pixelX*2 & 8 | line]; if (pixelX & 2) shift = shiftChar & 7; else shift = shiftChar >> 3; putchar( } } putchar( }
void foo() { int a = 10; static int sa = 10; a += 5; sa += 5; printf("a = %d, sa = %d\n", a, sa); } int main() { int i; for (i = 0; i < 10; ++i) foo(); }
a = 15, sa = 15 a = 15, sa = 20 a = 15, sa = 25 a = 15, sa = 30 a = 15, sa = 35 a = 15, sa = 40 a = 15, sa = 45 a = 15, sa = 50 a = 15, sa = 55 a = 15, sa = 60
/* Undefined behavior: already defined in main. Binutils 2.24 gives an error and refuses to link. https: */ /* Works in GCC as an extension: https: extern int i; static int si = 0; void a() { i++; si++; puts("a()"); printf("i = %d\n", i); printf("si = %d\n", si); puts(""); }
int i = 0; static int si = 0; void a(); void m() { i++; si++; puts("m()"); printf("i = %d\n", i); printf("si = %d\n", si); puts(""); } int main() { m(); m(); a(); a(); return 0; }
gcc -c a.c -o a.o gcc -c main.c -o main.o gcc -o main main.o a.o
m() i = 1 si = 1 m() i = 2 si = 2 a() i = 3 si = 1 a() i = 4 si = 2
Num: Value Size Type Bind Vis Ndx Name 5: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 si 10: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 i
void foo () { static int i = 0; printf("%d", i); i++ }
void function() { static int var = 1; var++; printf("%d", var); } int main() { function(); function(); }
static int x; int main() { printf("Accessing in same file%d", x): }
extern int x; func() { printf("accessing in different file %d",x); } run gcc -c file1.c gcc -c file2.c
to create permanent storage for local variables in a function. to specify internal linkage. to declare member functions that act like non-member functions. to create a single copy of a data member.
void func(){ static int count; printf("%d, ", count); count++; } void main(){ while(true){ func(); } }
int global_variable = 37; int increment(void) { return global_variable++; }
void use_it(void) { printf("Global variable: %d\n", global_variable++); }
extern void use_it(void); extern int increment(void);
int main(void) { use_it(); global_variable += 19; use_it(); printf("Increment: %d\n", increment()); return 0; }
PROGRAM = prog1 FILES.c = prog1.c file1.c file2.c FILES.h = prog1.h file3.h FILES.o = ${FILES.c:.c=.o} CC = gcc SFLAGS = -std=c11 GFLAGS = -g OFLAGS = -O3 WFLAG1 = -Wall WFLAG2 = -Wextra WFLAG3 = -Werror WFLAG4 = -Wstrict-prototypes WFLAG5 = -Wmissing-prototypes WFLAGS = ${WFLAG1} ${WFLAG2} ${WFLAG3} ${WFLAG4} ${WFLAG5} UFLAGS = CFLAGS = ${SFLAGS} ${GFLAGS} ${OFLAGS} ${WFLAGS} ${UFLAGS} LDFLAGS = LDLIBS = all: ${PROGRAM} ${PROGRAM}: ${FILES.o} ${CC} -o $@ ${CFLAGS} ${FILES.o} ${LDFLAGS} ${LDLIBS} prog1.o: ${FILES.h} file1.o: ${FILES.h} file2.o: ${FILES.h} DEBRIS = a.out core *~ *.dSYM RM_FR = rm -fr clean: ${RM_FR} ${FILES.o} ${PROGRAM} ${DEBRIS}
int i = 9; void put(void) { printf("i = %d\n", i); }
extern void dec(void); extern void put(void); extern void inc(void);
int main(void) { inc(); put(); dec(); put(); dec(); put(); }
void use_it(void) { printf("Global variable: %d\n", global_variable++); }
extern void use_it(void); extern int increment(void);
int main(void) { use_it(); global_variable += 19; use_it(); printf("Increment: %d\n", increment()); return 0; }
EXTERN int global_variable INITIALIZER(37); EXTERN struct { int a; int b; } oddball_struct INITIALIZER({ 41, 43 });
int increment(void) { return global_variable++; } int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
void use_them(void) { printf("Global variable: %d\n", global_variable++); oddball_struct.a += global_variable; oddball_struct.b -= global_variable / 2; }
extern int increment(void); extern int oddball_value(void); extern void use_them(void);
int main(void) { use_them(); global_variable += 19; use_them(); printf("Increment: %d\n", increment()); printf("Oddball: %d\n", oddball_value()); return 0; }
/* ** This header must not contain header guards (like <assert.h> must not). ** Each time it is invoked, it redefines the macros EXTERN, INITIALIZE ** based on whether macro DEFINE_VARIABLES is currently defined. */
struct oddball { int a; int b; }; extern void use_them(void); extern int increment(void); extern int oddball_value(void);
/* Global variable declarations / definitions */ EXTERN int global_variable INITIALIZE(37); EXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });
int increment(void) { return global_variable++; } int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
void use_them(void) { printf("Global variable: %d\n", global_variable++); oddball_struct.a += global_variable; oddball_struct.b -= global_variable / 2; }
int increment(void) { return global_variable++; } int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
int increment(void) { return global_variable++; } int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
int main(void) { use_them(); global_variable += 19; use_them(); printf("Increment: %d\n", increment()); printf("Oddball: %d\n", oddball_value()); return 0; }
/* Global variable declarations / definitions */ EXTERN int global_variable INITIALIZE(37); EXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });
/* ** This header must not contain header guards (like <assert.h> must not). ** Each time it is included, the macro HEADER_DEFINING_VARIABLES should ** be defined with the name (in quotes - or possibly angle brackets) of ** the header to be included that defines variables when the macro ** DEFINE_VARIABLES is defined. See also: external.h (which uses ** DEFINE_VARIABLES and defines macros EXTERN and INITIALIZE ** appropriately). ** ** ** */
int increment(void) { return global_variable++; } int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
/* Global variable declarations / definitions */ EXTERN struct oddball another INITIALIZE({ 14, 34 });
int increment(void) { return global_variable++; } int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }
int main(void) { use_them(); global_variable += 19; use_them(); printf("Increment: %d\n", increment()); printf("Oddball: %d\n", oddball_value()); return 0; }
void use_them(void) { printf("Global variable: %d\n", global_variable++); oddball_struct.a += global_variable; oddball_struct.b -= global_variable / 2; }
$ cat test1.c int test1_var = 5; $ cat test2.c extern int test1_var; int main(void) { printf("test1_var = %d\n", test1_var); return 0; } $ gcc test1.c test2.c -o test $ ./test test1_var = 5
extern int a; main(){ printf("The value of a is <%d>\n",a); }
int not_extern_int = 1; extern int extern_int; void main() { printf("%d\n", not_extern_int); printf("%d\n", extern_int); }
Num: Value Size Type Bind Vis Ndx Name 9: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 not_extern_int 12: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND extern_int
declare | define | initialize | ---------------------------------- extern int a; yes no no ------------- int a = 2019; yes yes yes ------------- int a; yes yes no -------------
int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
int myArray[53] = { VAL_32X, VAL_16X, VAL_4X, VAL_1X };
struct Pair { char key[16]; char val[32]; }; struct Pair p_data[] = { STRUCTVAL_48("Key", "Value") }; int a_data[][4] = { STRUCTVAL_48(12, 19, 23, 37) };
int myPoints[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9} };
int myPoints[][] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9} };
enum { ERR_OK, ERR_FAIL, ERR_MEMORY }; char* array[] = { _ITEM(ERR_OK), _ITEM(ERR_FAIL), _ITEM(ERR_MEMORY) };
int i; for (i = 0; i < ARRAY_SIZE; ++i) { myArray[i] = VALUE; }
int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5...
static void unhandled_interrupt(struct trap_frame *frame, int irq, void *arg) { } static struct irqtbl_s vector_tbl[XCHAL_NUM_INTERRUPTS] = { [0 ... XCHAL_NUM_INTERRUPTS-1] {unhandled_interrupt, NULL}, };
void memfill(void *dest, size_t destsize, size_t elemsize) { char *nextdest = (char *) dest + elemsize; size_t movesize, donesize = elemsize; destsize -= elemsize; while (destsize) { movesize = (donesize < destsize) ? donesize : destsize; memcpy(nextdest, dest, movesize); nextdest += movesize; destsize -= movesize; donesize += movesize; } } int main() { clock_t timeStart; double runTime; int i, a[ARR_SIZE]; timeStart = clock(); for (i = 0; i < ARR_SIZE; i++) a[i] = 9; runTime = (double)(clock() - timeStart) / (double)CLOCKS_PER_SEC; printf("loop runtime %f [seconds]\n",runTime); timeStart = clock(); a[0] = 10; memfill(a, sizeof(a), sizeof(a[0])); runTime = (double)(clock() - timeStart) / (double)CLOCKS_PER_SEC; printf("memfill() runtime %f [seconds]\n",runTime); return 0; }
void PrintArray(int a[3][3]) { std::cout << "a11 = " << a[0][0] << "\t\t" << "a12 = " << a[0][1] << "\t\t" << "a13 = " << a[0][2] << std::endl; std::cout << "a21 = " << a[1][0] << "\t\t" << "a22 = " << a[1][1] << "\t\t" << "a23 = " << a[1][2] << std::endl; std::cout << "a31 = " << a[2][0] << "\t\t" << "a32 = " << a[2][1] << "\t\t" << "a33 = " << a[2][2] << std::endl; std::cout << std::endl; } int wmain(int argc, wchar_t * argv[]) { int a1[3][3] = { 11, 12, 13, 21, 22, 23, 31, 32, 33 }; int a2[][3] = { 11, 12, 13, 21, 22, 23, 31, 32, 33 }; int a3[3][3] = { {11, 12, 13}, {21, 22, 23}, {31, 32, 33} }; int a4[][3] = { {11, 12, 13}, {21, 22, 23}, {31, 32, 33} }; PrintArray(a1); PrintArray(a2); PrintArray(a3); PrintArray(a4); int * b = (int *) a1; for (int i=0; i<9; i++) { std::cout << b[i] << } return 0; }
a11 = 11 a12 = 12 a13 = 13 a21 = 21 a22 = 22 a23 = 23 a31 = 31 a32 = 32 a33 = 33 a11 = 11 a12 = 12 a13 = 13 a21 = 21 a22 = 22 a23 = 23 a31 = 31 a32 = 32 a33 = 33 a11 = 11 a12 = 12 a13 = 13 a21 = 21 a22 = 22 a23 = 23 a31 = 31 a32 = 32 a33 = 33 a11 = 11 a12 = 12 a13 = 13 a21 = 21 a22 = 22 a23 = 23 a31 = 31 a32 = 32 a33 = 33 11 12 13 21 22 23 31 32 33
int i,value=5,array[1000]; for(i=0;i<1000;i++) array[i]=value;
int main(){ int i,a[50]; for (i=0;i<50;i++){ a[i]=5; } for (i=0;i<50;i++) printf("%d\n",a[i]); return 0; }
typedef const unsigned int cUINT; typedef unsigned int UINT; cUINT size = 10; cUINT initVal = 5; void arrayInitializer( UINT* myArray, cUINT size, cUINT initVal ); void printArray( UINT* myArray ); int main() { UINT myArray[size]; arrayInitializer( myArray, size, initVal ); printArray( myArray ); return 0; } void arrayInitializer( UINT* myArray, cUINT size, cUINT initVal ) { for ( UINT n = 0; n < size; n++ ) { myArray[n] = initVal; } } void printArray( UINT* myArray ) { printf( "myArray = { " ); for ( UINT n = 0; n < size; n++ ) { printf( "%u", myArray[n] ); if ( n < size-1 ) printf( ", " ); } printf( " }\n" ); }
int a[4]; unsigned int size = sizeof(a) / sizeof(a[0]); for (unsigned int i = 0; i < size; i++) a[i] = 0;
void array_init( void *start, size_t element_size, size_t elements, void *initval ){ memcpy( start, initval, element_size ); memcpy( (char*)start+element_size, start, element_size*(elements-1) ); } struct s { int a; char b; } array[2][3], init; int main(){ init = (struct s){.a = 3, .b = array_init( array, sizeof(array[0][0]), 2*3, &init ); for( int i=0; i<2; i++ ) for( int j=0; j<3; j++ ) printf("array[%i][%i].a = %i .b = }
array[0][0].a = 3 .b = array[0][1].a = 3 .b = array[0][2].a = 3 .b = array[1][0].a = 3 .b = array[1][1].a = 3 .b = array[1][2].a = 3 .b =
void printSizeOf(int intArray[]); void printLength(int intArray[]); int main(int argc, char* argv[]) { int array[] = { 0, 1, 2, 3, 4, 5, 6 }; printf("sizeof of array: %d\n", (int) sizeof(array)); printSizeOf(array); printf("Length of array: %d\n", (int)( sizeof(array) / sizeof(array[0]) )); printLength(array); } void printSizeOf(int intArray[]) { printf("sizeof of parameter: %d\n", (int) sizeof(intArray)); } void printLength(int intArray[]) { printf("Length of parameter: %d\n", (int)( sizeof(intArray) / sizeof(intArray[0]) )); }
sizeof of array: 28 sizeof of parameter: 8 Length of array: 7 Length of parameter: 2
sizeof of array: 28 sizeof of parameter: 4 Length of array: 7 Length of parameter: 1
int a[10]; int* p = a; assert(sizeof(a) / sizeof(a[0]) == 10); assert(sizeof(p) == sizeof(int*)); assert(sizeof(*p) == sizeof(int));
int arr[] = {23, 12, 423, 43, 21, 43, 65, 76, 22}; int noofele = sizeof(arr)/sizeof(int);
/* Compile as: CL /P "macro.c" */ ARRAYELEMENTCOUNT(p + 1);
/* Compile as: CL /P "macro.c" */ ARRAYELEMENTCOUNT(p + 1);
static char const* g_rgDialog[g_rgDialogRows][g_rgDialogCols] = { { " ", " ", " ", " 494", " 210", " Generic Sample Dialog", " " }, { " 1", " 330", " 174", " 88", " ", " OK", " " }, };
(sizeof(name ) / sizeof(name[0][0]) / columns_of_array(name)) (sizeof(name[0]) / sizeof(name[0][0])) static char* g_rgDialog[][7] = { }; assert( rows_of_array(g_rgDialog) == 2); assert(columns_of_array(g_rgDialog) == 7);
int a[10]; size_t size_of_array = sizeof(a); int n = sizeof (a) / sizeof (a[0]); size_t size_of_element = sizeof(a[0]);
vector<int> numbers; for (int i = 0; i < 10; i++) numbers.push_back(i); cout << numbers.size();
typedef struct MyType { int age; char name[20]; } MyType; typedef struct MyTypeArray { int size; MyType *arr; } MyTypeArray; MyType new_MyType(int age, char *name); MyTypeArray newMyTypeArray(int size, MyType *first); MyType new_MyType(int age, char *name) { MyType d; d.age = age; strcpy(d.name, name); return d; } MyTypeArray new_MyTypeArray(int size, MyType *first) { MyTypeArray d; d.size = size; d.arr = first; return d; } void print_MyType_names(MyTypeArray d) { int i; for (i = 0; i < d.size; i++) { printf("Name: %s, Age: %d\n", d.arr[i].name, d.arr[i].age); } } int main() { MyType arr[] = {new_MyType(10, "Sam"), new_MyType(3, "Baxter")}; MyTypeArray array = new_MyTypeArray(2, arr); /* MyTypeArray array = new_MyTypeArray(sizeof(arr)/sizeof(arr[0]), arr); */ print_MyType_names(array); return 0; }
typedef struct { int *array; int elements; } list_s;
int array[10]; int sizeOfArray = sizeof(array)/sizeof(int);
int main(){ int a[10]; int *p; printf("%p\n", (void *)a); printf("%p\n", (void *)(&a+1)); printf("---- diff----\n"); printf("%zu\n", sizeof(a[0])); printf("The size of array a is %zu\n", ((char *)(&a+1)-(char *)a)/(sizeof(a[0]))); return 0; };
1549216672 1549216712 ---- diff---- 4 The size of array a is 10
void Logger_log(...){} TEST(FactorialTest, Zero) { EXPECT_EQ(1, Factorial(0)); }
int main () { plan(5); ok(3 == 3); is("fnord", "eek", "two different strings not that way?"); ok(3 <= 8732, "%d <= %d", 3, 8732); like("fnord", "f(yes|no)r*[a-f]$"); cmp_ok(3, ">=", 10); done_testing(); }
static void null_test_success(void **state) { (void) state; } int main(void) { const struct CMUnitTest tests[] = { cmocka_unit_test(null_test_success), }; return cmocka_run_group_tests(tests, NULL, NULL); }
CHEAT_TEST(mathematics_still_work, cheat_assert(2 + 2 == 4); cheat_assert_not(2 + 2 == 5); )
$ gcc -I . tests.c $ ./a.out .. --- 2 successful of 2 run SUCCESS
check_PROGRAMS = test_oe_amqp test_oe_amqp_SOURCES = test_oe_amqp.c test_oe_amqp_LDADD = -L$(top_builddir)/components/common -loecommon test_oe_amqp_CFLAGS = -I$(top_srcdir)/components/common -static TESTS = test_oe_amqp
extern int bar; extern int g(int, int); double f(int, double); class foo;
int bar; int g(int lhs, int rhs) {return lhs*rhs;} double f(int i, double d) {return i+d;} class foo {};
double f(int, double); double f(int, double); extern double f(int, double); extern double f(int, double);
extern const int i = 0; extern int j; extern "C" { void foo(); }
typedef void T(); T t; struct X { T t; }; typedef int T; T t;
template <typename T> struct X { static int member; }; template<typename T> int X<T>::member; template<> int X<bool>::member;
extern int a; struct _tagExample { int a; int b; }; int myFunc (int a, int b);
int a; int b = 0; int myFunc (int a, int b) { return a + b; } struct _tagExample example;
int a; extern const int c = 1; int f(int x) { return x + a; } struct S { int a; int b; }; struct X { int x; static int y; X(): x(0) { } }; int X::y = 1; enum { up , down }; namespace N { int d; } namespace N1 = N; X anX; extern int a; extern const int c; int f(int); struct S; typedef int Int; extern X anotherX; using N::d; enum X : int; using IntVector = std::vector<int>; static_assert(X::y == 1, "Oops!"); template <class T> class C; ;
void print(int a) { printf("%d",a); } main() { print(5); }
void print(int a); main() { print(5); } void print(int a) { printf("%d",a); }
uint8_t ui8 = 5; | movb $0x5,-0x45(%rbp) int i = 5; | movl $0x5,-0x3c(%rbp) uint32_t ui32 = 5; | movl $0x5,-0x38(%rbp) uint64_t ui64 = 5; | movq $0x5,-0x10(%rbp) double doub = 5; | movsd 0x328(%rip),%xmm0 movsd %xmm0,-0x8(%rbp)
ui8 = 5; | movb $0x5,-0x45(%rbp) i = 5; | movl $0x5,-0x3c(%rbp) ui32 = 5; | movl $0x5,-0x38(%rbp) ui64 = 5; | movq $0x5,-0x10(%rbp) doub = 5; | movsd 0x328(%rip),%xmm0 movsd %xmm0,-0x8(%rbp)
uint def; | no instructions printf("some stuff..."); | [...] callq 0x400450 <printf@plt> def=5; | movb $0x5,-0x45(%rbp)
int max(int a, int b) { if(a>b) return a; return b; }
int max(int a, int b) { if(a>b) return a; return b; }
int main(void) { int i = 0; i = i++ + ++i; printf("%d\n", i); i = 1; i = (i++); printf("%d\n", i); volatile int u = 0; u = u++ + ++u; printf("%d\n", u); u = 1; u = (u++); printf("%d\n", u); register int v = 0; v = v++ + ++v; printf("%d\n", v); int w = 0; printf("%d %d %d\n", w++, ++w, w); int x[2] = { 5, 8 }, y = 0; x[y] = y ++; printf("%d %d\n", x[0], x[1]); }
$ cat evil.c void evil(){ int i = 0; i+= i++ + ++i; } $ gcc evil.c -c -o evil.bin $ gdb evil.bin (gdb) disassemble evil Dump of assembler code for function evil: 0x00000000 <+0>: push %ebp 0x00000001 <+1>: mov %esp,%ebp 0x00000003 <+3>: sub $0x10,%esp 0x00000006 <+6>: movl $0x0,-0x4(%ebp) 0x0000000d <+13>: addl $0x1,-0x4(%ebp) 0x00000011 <+17>: mov -0x4(%ebp),%eax 0x00000014 <+20>: add %eax,%eax 0x00000016 <+22>: add %eax,-0x4(%ebp) 0x00000019 <+25>: addl $0x1,-0x4(%ebp) 0x0000001d <+29>: leave 0x0000001e <+30>: ret End of assembler dump.
i = i++ + ++i; ^ ^ ^ i = (i++); ^ ^ u = u++ + ++u; ^ ^ ^ u = (u++); ^ ^ v = v++ + ++v; ^ ^ ^
In a single operation, read `i` and lock it to prevent access until further notice Compute (1+read_value) In a single operation, unlock `i` and store the computed value
int i = 5; int j; j = (++i, i++); printf("i=%d j=%d\n",i, j);
% gcc plusplus.c -Wall -Werror -pedantic plusplus.c: In function ‘main’: plusplus.c:6:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point] i = i++ + ++i; ~~^~~~~~~~~~~ plusplus.c:6:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point] plusplus.c:10:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point] i = (i++); ~~^~~~~~~ plusplus.c:14:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point] u = u++ + ++u; ~~^~~~~~~~~~~ plusplus.c:14:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point] plusplus.c:18:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point] u = (u++); ~~^~~~~~~ plusplus.c:22:6: error: operation on ‘v’ may be undefined [-Werror=sequence-point] v = v++ + ++v; ~~^~~~~~~~~~~ plusplus.c:22:6: error: operation on ‘v’ may be undefined [-Werror=sequence-point] cc1: all warnings being treated as errors
int k[] = {0,1,2,3,4,5,6,7,8,9,10}; int i = 0; int num; num = k[++i+k[++i]] + k[++i]; printf("%d", num);
int main(int argc, char ** argv) { int i = 0; i = i++ + ++i; printf("%d\n", i); i = 1; i = (i++); printf("%d\n", i); volatile int u = 0; u = u++ + ++u; printf("%d\n", u); u = 1; u = (u++); printf("%d\n", u); register int v = 0; v = v++ + ++v; printf("%d\n", v);
int main(int argc, char ** argv) { int i = 0; int r; r=i; i++; ++i; r+=i; i=r; printf("%d\n", i); i = 1; r=i; i++; i=r; printf("%d\n", i); volatile int u = 0; r=u; u++; ++u; r+=u; u=r; printf("%d\n", u); u = 1; r=u; u++; u=r; printf("%d\n", u); register int v = 0; r=v; v++; ++v; r+=v; v=r; printf("%d\n", v); }
int main(int argc, char ** argv) { int i = 0; i = i++ + ++i; printf("%d\n", i); i = 1; i = (i++); printf("%d\n", i); volatile int u = 0; u = u++ + ++u; printf("%d\n", u); u = 1; u = (u++); printf("%d\n", u); register int v = 0; v = v++ + ++v; printf("%d\n", v); }
int main(int argc, char ** argv) { int r; int i = 0; ++i; r = i + i; i = r; i++; printf("%d\n", i); i = 1; r = i; i = r; i++; printf("%d\n", i); volatile int u = 0; ++u; r = u + u; u = r; u++; printf("%d\n", u); u = 1; r = u; u = r; u++; printf("%d\n", u); register int v = 0; ++v; r = v + v; v = r; v++; printf("%d\n", v); }
y = x++; z = x++ + y++; x = x + 1; x = a[i++]; x = a[i++] + b[j++]; x[i++] = a[j++] + b[k++]; x = *p++; x = *p++ + *q++;
x = x++; x = x++ + ++x; y = x + x++; a[i] = i++; a[i++] = i; printf("%d %d %d\n", x, ++x, x++);
typedef struct Msg { unsigned int a; unsigned int b; } Msg; void SendWord(uint32_t); int main(void) { uint32_t* buff = malloc(sizeof(Msg)); Msg* msg = (Msg*)(buff); for (int i =0; i < 10; ++i) { msg->a = i; msg->b = i+1; SendWord(buff[0]); SendWord(buff[1]); } }
void SendMessage(uint32_t* buff, size_t size32) { for (int i = 0; i < size32; ++i) { SendWord(buff[i]); } }
for (int i = 0; i < 10; ++i) { msg->a = i; msg->b = i+1; SendMessage(buff, 2); }
union { Msg msg; unsigned int asBuffer[sizeof(Msg)/sizeof(unsigned int)]; };
int x = 10; int *ip = &x; std::cout << *ip << "\n"; *ip = 12; std::cout << x << "\n";
int foo( float *f, int *i ) { *i = 1; *f = 0.f; return *i; } int main() { int x = 0; std::cout << x << "\n"; x = foo(reinterpret_cast<float*>(&x), &x); std::cout << x << "\n"; }
foo(float*, int*): mov dword ptr [rsi], 1 mov dword ptr [rdi], 0 mov eax, 1 ret
int x = 1; unsigned int *p = (unsigned int*)&x; printf("%u\n", *p );
int x = 1; const unsigned int *p = (const unsigned int*)&x; printf("%u\n", *p );
struct foo { int x; }; void foobar( struct foo *fp, int *ip ); foo f; foobar( &f, &f.x );
int x = 65; char *p = (char *)&x; printf("%c\n", *p );
void *p = malloc( sizeof(int) ); int *ip = new (p) int{0}; std::cout << *ip << "\n";
int x = 1; const int *cip = &x; std::cout << *cip << "\n";
signed int foo( signed int &si, unsigned int &ui ) { si = 1; ui = 2; return si; }
struct foo { int x; }; int foobar( foo &fp, int &ip ) { fp.x = 1; ip = 2; return fp.x; } foo f; foobar( f, f.x );
struct foo { int x ; }; struct bar : public foo {}; int foobar( foo &f, bar &b ) { f.x = 1; b.x = 2; return f.x; }
int foo( std::byte &b, uint32_t &ui ) { b = static_cast<std::byte>( ui = 0xFFFFFFFF; return std::to_integer<int>( b ); }
int x = 1 ; float *fp = (float*)&x ; float *fp = reinterpret_cast<float*>(&x) ; printf( "%f\n", *fp ) ;
union u1 { int n; float f; } ; union u1 u; u.f = 1.0f; printf( "%d\n”, u.n );
static_assert( sizeof( double ) == sizeof( int64_t ) );
void func1( double d ) { std::int64_t n; std::memcpy(&n, &d, sizeof d);
struct uint_chars { unsigned char arr[sizeof( unsigned int )] = {} ; }; int bar( unsigned char *p, size_t len ) { int result = 0; for( size_t index = 0; index < len; index += sizeof(unsigned int) ) { uint_chars f; std::memcpy( f.arr, &p[index], sizeof(unsigned int)); unsigned int result = bit_cast<unsigned int>(f); result += foo( result ); } return result ; }
int a = 1; short j; float f = 1.f; printf("%i\n", j = *(reinterpret_cast<short*>(&a))); printf("%i\n", j = *(reinterpret_cast<int*>(&f)));
int *p; p=&a; printf("%i\n", j = *(reinterpret_cast<short*>(p)));
int *x = new int[2]; int *u = (int*)((char*)x + 6); *u = 1; printf( "%d\n", *u );
int a = 1; short j; float f = 1.0 ; printf("%i\n", j = *((short*)&a)); printf("%i\n", j = *((int*)&f)); int *p; p=&a; printf("%i\n", j = *((short*)p));
./bin/tis-kernel -sa example1.c ... example1.c:9:[sa] warning: The pointer (short *)(& a) has type short *. It violates strict aliasing rules by accessing a cell with effective type int. ... example1.c:10:[sa] warning: The pointer (int *)(& f) has type int *. It violates strict aliasing rules by accessing a cell with effective type float. Callstack: main ... example1.c:15:[sa] warning: The pointer (short *)p has type short *. It violates strict aliasing rules by accessing a cell with effective type int.
void check(short *h,long *k) { *h=5; *k=6; if (*h == 5) printf("strict aliasing problem\n"); } int main(void) { long k[1]; check((short *)k,k); return 0; }
movw $5, (%rdi) movq $6, (%rsi) movl $.LC0, %edi jmp puts
int x; int test(double *p) { x=5; *p = 1.0; return x; }
int test(int *ip, double *dp) { *ip = 1; *dp = 1.23; return *ip; } int test2(void) { union U { int i; double d; } u; return test(&u.i, &u.d); }
void inc_int(int *p) { *p = 3; } int test(void) { int *p; struct S { int x; } s; s.x = 1; p = &s.x; inc_int(p); return s.x; }
void inc_int(int *p) { *p = 3; } int test(void) { int *p; struct S { int x; } s; p = &s.x; s.x = 1; *p += 1; return s.x; }
void merge_two_ints(int *a, int *b) { *b += *a; *a += *b; }
void merge_two_ints(int * restrict a, int * restrict b) {...}
int i = 0; printf("i: %d\n", i); printf("i++: %d\n", i++); printf("++i: %d\n", ++i);
int i, j, k, l; i = 1; j = i+1; k = i++; l = ++i; cout << i << return 0;
int i=4; printf("%d\n",pow(++i,2)); i=4; printf("%d",pow(i++,2));
int j=0; System.out.println(j); System.out.println(j++); int k=0; System.out.println(k); System.out.println(++k);
int m=0; if((m == 0 || m++ == 0) && (m++ == 1)) { System.out.println("post-increment "+m); } int n=0; if((n == 0 || n++ == 0) && (++n == 1)) { System.out.println("pre-increment "+n); }
System.out.println("In Array"); int[] a = { 55, 11, 15, 20, 25 } ; int ii, jj, kk = 1, mm; ii = ++a[1]; System.out.println(a[1]); jj = a[1]++; System.out.println(a[1]); mm = a[1]; System.out.printf ( "\n%d %d %d\n", ii, jj, mm ) ; for (int val: a) { System.out.print(" " +val); }
using namespace std; int main() { int x=10; int* p = &x; std::cout<<"address = "<<p<<"\n"; std::cout<<"address = "<<p<<"\n"; std::cout<<"address = "<<&x<<"\n"; std::cout<<"address = "<<++&x<<"\n"; }
int i = 10, j = 10; printf ("i is %i \n", i); printf ("i++ is %i \n", i++); printf ("i is %i \n\n", i); printf ("j is %i \n", j); printf ("++j is %i \n", ++j); printf ("j is %i \n", j);
i is 10 i++ is 10 i is 11 j is 10 ++j is 11 j is 11
int i, j; For (i = 0; i <= 3; i++) printf (" > iteration printf ("\n"); for (j = 0; j <= 3; ++j) printf (" > iteration
i++; /* you can think as, * i; * i= i+1; */ ++i; /* you can think as, * i = i+i; * i; */
ptr = (char **) malloc (MAXELEMS * sizeof(char *));
size_t count = get_int32(file); struct foo *bar = malloc(count * sizeof *bar);
size_t count = get_int32(file); struct foo *bar = calloc(count, sizeof *bar);
ptr=malloc(sizeof(Item)); memset(ptr, 0, sizeof(Item));
size_t count = SIZE_MAX/sizeof disk_sector; disk_sector *p = malloc(count * sizeof *p);
size_t count = something_in_the_range(SIZE_MAX/sizeof disk_sector + 1, SIZE_MAX) disk_sector *p = calloc(count, sizeof *p);
void *malloc( size_t n); void *calloc( size_t n, size_t t)
int *arr; arr = (int *)malloc(10 * sizeof(int)); arr = (int *)calloc(10, sizeof(int));
arr= (int *)malloc(10 * sizeof(int)); memset(arr, 0, 10 * sizeof(int));
typedef struct node { int data; struct node *next; /* can } node;
typedef struct myStruct{ int one; int two; } myStruct;
typedef struct myStruct someStruct; someStruct myVariable;
typedef struct { field_1; ... }myStruct,*myStructP;
typedef struct myStructElement { myStructElement* nextSE; field_1; ... }myStruct;
int add(int x, int y) { while (x) { int t = (x & y) << 1; y ^= x; x = t; } return y; } int divideby3(int num) { int sum = 0; while (num > 3) { sum = add(num >> 2, sum); num = add(num >> 2, num & 3); } if (num == 3) sum = add(sum, 1); return sum; }
int main() { FILE * fp=fopen("temp.dat","w+b"); int number=12346; int divisor=3; char * buf = calloc(number,1); fwrite(buf,number,1,fp); rewind(fp); int result=fread(buf,divisor,number,fp); printf("%d / %d = %d", number, divisor, result); free(buf); fclose(fp); return 0; }
log(pow(exp(number),0.33333333333333333333)) /* :-) */
int main(int argc, char *argv[]) { int num = 1234567; int den = 3; div_t r = div(num,den); printf("%d\n", r.quot); return 0; }
int main() { int dividend = -42, divisor = 5, quotient, remainder; __asm__ ( "cdq; idivl %%ebx;" : "=a" (quotient), "=d" (remainder) : "a" (dividend), "b" (divisor) : ); printf("%i / %i = %i, remainder: %i\n", dividend, divisor, quotient, remainder); return 0; }
int div3(int i) { char str[42]; sprintf(str, "%d", INT_MIN); if (i>0) str[0] = itoa(abs(i), &str[1], 3); str[strlen(&str[1])] = return strtol(str, NULL, 3); }
unsigned div_by(unsigned const x, unsigned const by) { unsigned floor = 0; for (unsigned cmp = 0, r = 0; cmp <= x;) { for (unsigned i = 0; i < by; i++) cmp++; floor = r; r++; } return floor; }
unsigned inc(unsigned x) { for (unsigned mask = 1; mask; mask <<= 1) { if (mask & x) x &= ~mask; else return x & mask; } return 0; }
unsigned add(char const zero[], unsigned const x, unsigned const y) { return (int)(uintptr_t)(&((&zero[x])[y])); } unsigned div_by(unsigned const x, unsigned const by) { unsigned floor = 0; for (unsigned cmp = 0, r = 0; cmp <= x;) { cmp = add(0,cmp,by); floor = r; r = add(0,r,1); } return floor; }
int mul(int const x, int const y) { return sizeof(struct { char const ignore[y]; }[x]); }
public static int div_by_3(long a) { a <<= 30; for(int i = 2; i <= 32 ; i <<= 1) { a = add(a, a >> i); } return (int) (a >> 32); } public static long add(long a, long b) { long carry = (a & b) << 1; long sum = (a ^ b); return carry == 0 ? sum : add(carry, sum); }
a/3 = a * 1/3 a/3 = a * (1/4 + 1/16 + 1/64 + ...) a/3 = a/4 + a/16 + 1/64 + ... a/3 = a >> 2 + a >> 4 + a >> 6 + ...
11 + 6 1011 + 0110 sum = 1011 ^ 0110 = 1101 carry = (1011 & 0110) << 1 = 0010 << 1 = 0100 Now you recurse! 1101 + 0100 sum = 1101 ^ 0100 = 1001 carry = (1101 & 0100) << 1 = 0100 << 1 = 1000 Again! 1001 + 1000 sum = 1001 ^ 1000 = 0001 carry = (1001 & 1000) << 1 = 1000 << 1 = 10000 One last time! 0001 + 10000 sum = 0001 ^ 10000 = 10001 = 17 carry = (0001 & 10000) << 1 = 0 Done!
a / 3 = a/4 + a/4^2 + a/4^3 + ... + a/4^i + ... = f(a, i) + a * 1/3 * 1/4^i f(a, i) = a/4 + a/4^2 + ... + a/4^i
public static int DivideBy3(int a) { bool negative = a < 0; if (negative) a = Negate(a); int result; int sub = 3 << 29; int threes = 1 << 29; result = 0; while (threes > 0) { if (a >= sub) { a = Add(a, Negate(sub)); result = Add(result, threes); } sub >>= 1; threes >>= 1; } if (negative) result = Negate(result); return result; } public static int Negate(int a) { return Add(~a, 1); } public static int Add(int a, int b) { int x = 0; x = a ^ b; while ((a & b) != 0) { b = (a & b) << 1; a = x; x = a ^ b; } return x; }
if (number == 0) return 0; if (number == 1) return 0; if (number == 2) return 0; if (number == 3) return 1; if (number == 4) return 1; if (number == 5) return 1; if (number == 6) return 2;
int DivBy3(int num) { int result = 0; int counter = 0; while (1) { if (num == counter) return result; counter = abs(~counter); if (num == counter) return result; counter = abs(~counter); if (num == counter) return result; counter = abs(~counter); result = abs(~result); } }
int main() { uint32_t mod3[6] = { 0,1,2,0,1,2 }; uint32_t x = 1234567; uint32_t y = 0; int bit = 31; printf("X=%u X/3=%u\n",x,x/3); while (bit>0) { printf("BIT=%d X=%u Y=%u\n",bit,x,y); int h = 1; while (1) { bit ^= h; if ( bit&h ) h <<= 1; else break; } uint32_t r = x>>bit; x ^= r<<bit; if (r >= 3) y |= 1<<bit; x |= mod3[r]<<bit; } printf("Y=%u\n",y); }
int div3(int x) { int reminder = abs(x); int result = 0; while(reminder >= 3) { result++; reminder--; reminder--; reminder--; } return result; }
unit Divide_By_3; interface function div_by_3(n: integer): integer; cdecl; export; implementation function div_by_3(n: integer): integer; cdecl; begin div_by_3 := n div 3; end; end.
extern int div_by_3(int n); int main(void) { int n; fputs("Enter a number: ", stdout); fflush(stdout); scanf("%d", &n); printf("%d / 3 = %d\n", n, div_by_3(n)); return 0; }
fpc divide_by_3.pas && gcc divide_by_3.o main.c -o main
int main() { int aNumber = 500; int gResult = 0; int aLoop = 0; int i = 0; for(i = 0; i < aNumber; i++) { if(aLoop == 3) { gResult++; aLoop = 0; } aLoop++; } printf("Reulst of %d / 3 = %d", aNumber, gResult); return 0; }
unsigned sub(unsigned two, unsigned one); unsigned bitdiv(unsigned top, unsigned bot); unsigned sub(unsigned two, unsigned one) { unsigned bor; bor = one; do { one = ~two & bor; two ^= bor; bor = one<<1; } while (one); return two; } unsigned bitdiv(unsigned top, unsigned bot) { unsigned result, shift; if (!bot || top < bot) return 0; for(shift=1;top >= (bot<<=1); shift++) {;} bot >>= 1; for (result=0; shift--; bot >>= 1 ) { result <<=1; if (top >= bot) { top = sub(top,bot); result |= 1; } } return result; } int main(void) { unsigned arg,val; for (arg=2; arg < 40; arg++) { val = bitdiv(arg,3); printf("Arg=%u Val=%u\n", arg, val); } return 0; }
function div3 (n) { var div = String.fromCharCode(47); return eval([n, div, 3].join("")); }
irb(main):101:0> div3 = -> n { s = => irb(main):102:0> div3[12] => 4 irb(main):103:0> div3[666] => 222
print( const int32_t div_by_3(const int32_t input) { for i in range(-2**31, 2**31): print( print(r return 42; } int main() { const int32_t number = 8; printf("%d / 3 = %d\n", number, div_by_3(number)); }
int divideByThree(int num) { return (fma(num, 1431655766, 0) >> 32); }
private int dividedBy3(int n) { List<Object> a = new Object[n].ToList(); List<Object> b = new List<object>(); while (a.Count > 2) { a.RemoveRange(0, 3); b.Add(new Object()); } return b.Count; }
int main() { int number = 8; int temp = 3, result = 0; while(temp <= number){ temp = fma(temp, 1, 3); result = fma(result, 1, 1); } printf("\n\n%d divided by 3 = %d\n", number, result); }
[02:31:59] [william@relativity ~]$ cat div3.c int main() { float multiplicand = 123456.0; float multiplier = 0.333333; printf("%f * %f == ", multiplicand, multiplier); cblas_sscal(1, multiplier, &multiplicand, 1); printf("%f\n", multiplicand); } [02:32:07] [william@relativity ~]$ clang div3.c -framework Accelerate -o div3 && ./div3 123456.000000 * 0.333333 == 41151.957031
x/(1-1/y) = x * (1+y) / (1-y^2) = x * (1+y) * (1+y^2) / (1-y^4) = ... = x * (1+y) * (1+y^2) * (1+y^4) * ... * (1+y^(2^i)) / (1-y^(2^(i+i)) = x * (1+y) * (1+y^2) * (1+y^4) * ... * (1+y^(2^i))
int div3(int x) { x <<= 6; x += x>>2; x += x>>4; x += x>>8; x += x>>16; return (x+1)>>8; }
with Ada.Text_IO; procedure Divide_By_3 is protected type Divisor_Type is entry Poke; entry Finish; private entry Release; entry Stop_Emptying; Emptying : Boolean := False; end Divisor_Type; protected type Collector_Type is entry Poke; entry Finish; private Emptying : Boolean := False; end Collector_Type; task type Input is end Input; task type Output is end Output; protected body Divisor_Type is entry Poke when not Emptying and Stop_Emptying begin requeue Release; end Poke; entry Release when Release New_Output : access Output; begin if not Emptying then New_Output := new Output; Emptying := True; requeue Stop_Emptying; end if; end Release; entry Stop_Emptying when Release begin Emptying := False; end Stop_Emptying; entry Finish when Poke begin Emptying := True; requeue Stop_Emptying; end Finish; end Divisor_Type; protected body Collector_Type is entry Poke when Emptying is begin null; end Poke; entry Finish when True is begin Ada.Text_IO.Put_Line (Poke Emptying := True; end Finish; end Collector_Type; Collector : Collector_Type; Divisor : Divisor_Type; task body Input is begin Divisor.Poke; end Input; task body Output is begin Collector.Poke; end Output; Cur_Input : access Input; -- Input value: Number : Integer := 18; begin for I in 1 .. Number loop Cur_Input := new Input; end loop; Divisor.Finish; Collector.Finish; end Divide_By_3;
int factorCount (long n) { double square = sqrt (n); int isquare = (int) square; int count = isquare == square ? -1 : 0; long candidate; for (candidate = 1; candidate <= isquare; candidate ++) if (0 == n % candidate) count += 2; return count; } int main () { long triangle = 1; int index = 1; while (factorCount (triangle) < 1001) { index ++; triangle += index; } printf ("%ld\n", triangle); }
typedef enum { OPT_ON, OPT_OFF } foo_option; void foo(foo_option option);
typedef enum { myfalse = 0, mytrue = !myfalse } mybool;
mybool somebool; int someint = 5; somebool = !!someint;
void foo(bool flag); ... int flag = TRUE; foo(flag);
bool isVisible = FALSE; bool isWorking = TRUE; isVisible = NOT(isVisible);
.file "main.c" .intel_syntax noprefix .def __main; .scl 2; .type 32; .endef .text .globl main .def main; .scl 2; .type 32; .endef .seh_proc main main: push rbp .seh_pushreg rbp mov rbp, rsp .seh_setframe rbp, 0 sub rsp, 32 .seh_stackalloc 32 .seh_endprologue call __main .L2: jmp .L2 .seh_endproc .ident "GCC: (tdm64-2) 4.8.1"
.file "main.c" .intel_syntax noprefix .def __main; .scl 2; .type 32; .endef .text .globl main .def main; .scl 2; .type 32; .endef .seh_proc main main: sub rsp, 40 .seh_stackalloc 40 .seh_endprologue call __main .L2: jmp .L2 .seh_endproc .ident "GCC: (tdm64-2) 4.8.1"
.file "main.c" .intel_syntax noprefix .def __main; .scl 2; .type 32; .endef .section .text.startup,"x" .p2align 4,,15 .globl main .def main; .scl 2; .type 32; .endef .seh_proc main main: sub rsp, 40 .seh_stackalloc 40 .seh_endprologue call __main .L2: jmp .L2 .seh_endproc .ident "GCC: (tdm64-2) 4.8.1"
.L2: jmp .L2 .seh_endproc .ident "GCC: (tdm64-2) 4.8.1"
while(42) {} while(1==1) {} while(2==2) {} while(4<7) {} while(3==3 && 4==4) {} while(8-9 < 0) {} while(4.3 * 3e4 >= 2 << 6) {} while(-0.1 + 02) {}
.L4: call x testl %eax, %eax jne .L4 movl $0, %eax addq $32, %rsp popq %rbp ret .seh_endproc .ident "GCC: (tdm64-2) 4.8.1"
.L4: call x xorpd %xmm1, %xmm1 ucomisd %xmm1, %xmm0 jp .L4 xorpd %xmm1, %xmm1 ucomisd %xmm1, %xmm0 jne .L4 movl $0, %eax addq $32, %rsp popq %rbp ret .seh_endproc .ident "GCC: (tdm64-2) 4.8.1"
int n = 4; switch (n) { case 2+2: break; case 4: break; }
yyy: xor eax, eax cmp eax, 1 (or 2, depending on your code) je xxx jmp yyy xxx: ...
unsigned long i = 0; while (1) { if (++i == 1000000000) break; } unsigned long i = 0; while (2) { if (++i == 1000000000) break; }
while (1 + 5 - 2 - (1 * 3) == 0.5 - 4 + ((9 * 2) / 4)) { if (succeed()) break; }
int mltovf(int a, int b) { if (a && b) return abs(a) > MAX/abs(b); else return 0; } main() { int a, b; for (a = 0; a <= MAX; a++) for (b = 0; b < MAX; b++) { if (mltovf(a, b) != (a*b > MAX)) printf("Bad calculation: a: %d b: %d\n", a, b); } }
size_t s1 = strlen(str1); size_t s2 = strlen(str2);
int main() { const size_t N = 10; int a[N]; for (size_t n = 0; n < N; ++n) a[n] = n; for (size_t n = N-1; n >= 0; --n) printf("%d ", a[n]); } Output Infinite loop and then segmentation fault
for ( int ctr = 0 ; ctr < 5 ; ctr++ ) { print(ctr); }
void func ( void (*f)(int) ) { for ( int ctr = 0 ; ctr < 5 ; ctr++ ) { (*f)(ctr); } }
void dosomething() { } functiontype func = &dosomething; func();
int dosomethingwithchar(char a) { return 1; } functiontype2 func2 = &dosomethingwithchar int result = func2(
double Combiner(double a, double b, std::function<double (double,double)> func){ return func(a,b); } double Add(double a, double b){ return a+b; } double Mult(double a, double b){ return a*b; } int main(){ Combiner(12,13,Add); Combiner(12,13,Mult); }
template<class T> double Combiner(double a, double b, T func){ return func(a,b); } double Add(double a, double b){ return a+b; } double Mult(double a, double b){ return a*b; } int main(){ Combiner(12,13,Add); Combiner(12,13,Mult); }
void print(); void execute(void()); int main() { execute(print); return 0; } void print() { printf("Hello!"); } void execute(void f()) { f(); }
void print(); void execute(void (*f)()); int main() { execute(&print); return 0; } void print() { printf("Hello!"); } void execute(void (*f)()) { f(); }
static int const var = VAR; static int const var = 5;
const int maxlen = 5; void foo() { int bar[maxlen]; }
static int const NUMBER_OF_FINGERS_PER_HAND = 5; static int const NUMBER_OF_HANDS = 2; static int const NUMBER_OF_FINGERS = NUMBER_OF_FINGERS_PER_HAND * NUMBER_OF_HANDS;
static uint8_t const ARRAY_SIZE = 16; static int8_t const lookup_table[ARRAY_SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
enum {ENUM_DEFINED=16}; enum {ENUM_DEFINED=32}; int main(int argc, char *argv[]) { printf("%d, %d\n", DEFINED_DEFINED, ENUM_DEFINED); return(0); }
main.c:6:7: error: redefinition of enumerator enum {ENUM_DEFINED=32}; ^ main.c:5:7: note: previous definition is here enum {ENUM_DEFINED=16}; ^ main.c:9:9: warning: ^ main.c:8:9: note: previous definition is here ^
struct mystruct { int var; }; int main() { struct mystruct foo; foo.var = 1; return 0; }
const int const_value = 5; int *mutable_value = (int*) &const_value; *mutable_value = 3; printf("%i", const_value);
int main(int argc, char **argv) { char * path = argc > 1 ? argv[1] : "input.txt"; FILE * fp = fopen(path, "r"); if( fp == NULL ) { perror(path); return EXIT_FAILURE; } while( !feof(fp) ) { } if( fclose(fp) == 0 ) { return EXIT_SUCCESS; } else { perror(path); return EXIT_FAILURE; } }
for (;;) { size_t n = fread(buf, 1, bufsize, infile); consume(buf, n); if (n < bufsize) { break; } }
for (int a, b, c; scanf("%d %d %d", &a, &b, &c) == 3; ) { consume(a, b, c); }
for (std::string line; std::getline(std::cin, line); ) { consume(line); }
char const * p = buf; ssize_t n = bufsize; for (ssize_t k = bufsize; (k = write(fd, p, n)) > 0; p += k, n -= k) {} if (n != 0) { }
char *buffer = NULL; size_t bufsiz = 0; ssize_t nbytes; while ((nbytes = getline(&buffer, &bufsiz, fp)) != -1) { } free(buffer);
std::string input = " 123 "; std::istringstream iss(input); int value; if (iss >> value >> std::ws && iss.get() == EOF) { consume(value); } else { }
FILE *Fopen(const char *path, const char *mode); int main(int argc, char **argv) { FILE *in; unsigned count; in = argc > 1 ? Fopen(argv[1], "r") : stdin; count = 0; while (!feof(in)) { fgetc(in); count++; } printf("Number of characters read: %u\n", count); return EXIT_SUCCESS; } FILE * Fopen(const char *path, const char *mode) { FILE *f = fopen(path, mode); if (f == NULL) { perror(path); exit(EXIT_FAILURE); } return f; }
while (fgets(line, sizeof(line), file)) { /* note that fgets don presence allow to handle lines longer that sizeof(line), not showed here */ ... } if (ferror(file)) { } else if (feof(file)) { /* format error (not possible with fgets, but would be with fscanf) or end of file */ } else { /* format error (not possible with fgets, but would be with fscanf) */ }
int main(int argc, char *argv[]) { struct stat buf; FILE *fp = fopen(argv[0], "r"); stat(filename, &buf); while (ftello(fp) != buf.st_size) { (void)fgetc(fp); } }
/* Returns an integer in the range [0, n). * * Uses rand(), and so is affected-by/affects the same seed. */ int randint(int n) { if ((n - 1) == RAND_MAX) { return rand(); } else { assert (n <= RAND_MAX) int end = RAND_MAX / n; assert (end > 0); end *= n; int r; while ((r = rand()) >= end); return r % n; } }
int foo() { char myString[32]; uint32_t myInt; if (sodium_init() < 0) { return 1; } randombytes_buf(myString, 32); myInt = randombytes_uniform(10); }
int random_number(int min_num, int max_num); int main(void) { printf("Min : 1 Max : 40 %d\n", random_number(1,40)); printf("Min : 100 Max : 1000 %d\n",random_number(100,1000)); return 0; } int random_number(int min_num, int max_num) { int result = 0, low_num = 0, hi_num = 0; if (min_num < max_num) { low_num = min_num; hi_num = max_num + 1; } else { low_num = max_num + 1; hi_num = min_num; } srand(time(NULL)); result = (rand() % (hi_num - low_num)) + low_num; return result; }
/* Random integer in [0, limit) */ unsigned int random_uint(unsigned int limit) { union { unsigned int i; unsigned char c[sizeof(unsigned int)]; } u; do { if (!RAND_bytes(u.c, sizeof(u.c))) { fprintf(stderr, "Can exit(1); } } while (u.i < (-limit % limit)); /* u.i < (2**size % limit) */ return u.i % limit; } /* Random double in [0.0, 1.0) */ double random_double() { union { uint64_t i; unsigned char c[sizeof(uint64_t)]; } u; if (!RAND_bytes(u.c, sizeof(u.c))) { fprintf(stderr, "Can exit(1); } /* 53 bits / 2**53 */ return (u.i >> 11) * (1.0/9007199254740992.0); } int main() { printf("Dice: %d\n", (int)(random_uint(6) + 1)); printf("Double: %f\n", random_double()); return 0; }
uint32_t arc4random(void) void arc4random_buf(void *buf, size_t bytes) uint32_t arc4random_uniform(uint32_t limit) void arc4random_stir(void) void arc4random_addrandom(unsigned char *dat, int datlen)
int urandom_fd = -2; void urandom_init() { urandom_fd = open("/dev/urandom", O_RDONLY); if (urandom_fd == -1) { int errsv = urandom_fd; printf("Error opening [/dev/urandom]: %i\n", errsv); exit(1); } } unsigned long urandom() { unsigned long buf_impl; unsigned long *buf = &buf_impl; if (urandom_fd == -2) { urandom_init(); } /* Read 4 bytes, or 32 bits into *buf, which points to buf_impl */ read(urandom_fd, buf, sizeof(long)); return buf_impl; }
int myRandom(int bottom, int top){ return (RAND_IMPL() % (top - bottom)) + bottom; }
int main(int argc, char **argv) { srand((unsigned int)**main + (unsigned int)&argc + (unsigned int)time(NULL)); srand(rand()); for (int i = 0; i < 10; i++) printf("%d\n", rand()); }
((rand() % (int)(((max) + 1) - (min))) + (min)) int main() { srand(time(NULL)); printf("%d\n", randnum(1, 70)); }
int main() { srand(time(NULL)); int lowerLimit = 10, upperLimit = 50; int r = lowerLimit + rand() % (upperLimit - lowerLimit); printf("%d", r); }
void main() { int visited[100]; int randValue, a, b, vindex = 0; randValue = (rand() % 100) + 1; while (vindex < 100) { for (b = 0; b < vindex; b++) { if (visited[b] == randValue) { randValue = (rand() % 100) + 1; b = 0; } } visited[vindex++] = randValue; } for (a = 0; a < 100; a++) printf("%d ", visited[a]); }
int random(int range); int main(void) { printf("%d", random(10)); return 0; } int random(int range) { struct time t; int r; gettime(&t); r = t.ti_sec % range; return r; }
uint64_t randVal; if(!_rdrand64_step(&randVal)) { }
int main(int argc, char *argv[]) { int i; int dice[6]; for (i = 0; i < 6; i++) dice[i] = 0; srand(time(NULL)); const int TOTAL = 10000000; for (i = 0; i < TOTAL; i++) dice[(rand() % 6)] += 1; double pers = 0.0, tpers = 0.0; for (i = 0; i < 6; i++) { pers = (dice[i] * 100.0) / TOTAL; printf("\t%1d %5.2f%%\n", dice[i], pers); tpers += pers; } printf("\ttotal: %6.2f%%\n", tpers); }
$ gcc -o t3 t3.c $ ./t3 1666598 16.67% 1668630 16.69% 1667682 16.68% 1666049 16.66% 1665948 16.66% 1665093 16.65% total: 100.00% $ ./t3 1667634 16.68% 1665914 16.66% 1665542 16.66% 1667828 16.68% 1663649 16.64% 1669433 16.69% total: 100.00%
struct timespec nanos; clock_gettime(CLOCK_MONOTONIC, &nanos) srand(nanos.tv_nsec);
struct timespec nanos; clock_gettime(CLOCK_MONOTONIC, &nanos) srand(nanos.tv_nsec | getHashOfString(outputName));
int range_rand(int min_num, int max_num) { if (min_num >= max_num) { fprintf(stderr, "min_num is greater or equal than max_num!\n"); } return min_num + (rand() % (max_num - min_num)); }
/* Uses the srand() function to seed the random number generator based on time value, then returns an integer in the range 1 to max. Call this with random(n) where n is an integer, and you get an integer as a return value. */ int random(int max) { srand((unsigned) time(NULL)); return (rand() % max) + 1; }
int main() { int x = 5; printf("%d and ", sizeof(x++)); printf("%d\n", x); return 0; }
short func(short x) { printf("%d", x); return x; } int main() { printf("%d", sizeof(func(3))); return 0; }
int f(); int main(void) { printf("%d", sizeof(f()) ); return 0; }
struct A { A(); int f(); }; int main() { std::cout << sizeof(A().f())<< std::endl; return 0; }
int main() { char *a = malloc(1024); /* Do some arbitrary stuff with return 0; }
char *t; for (i=0; i < 255; i++) { t = strdup(foo->name); let_strtok_eat_away_at(t); }
char *x = "Foo"; static const char __secret_anonymous_array[] = "Foo"; char *x = (char *) __secret_anonymous_array;
char *s0 = "hello world"; char s1[] = "hello world";
sizeof s0 == sizeof (char*) sizeof s1 == 12 type of &s0 == char ** type of &s1 == char (*)[12]
static char __unnamed[] = "abc"; char *c = __unnamed;
int main(void) { char *s = "abc"; printf("%s\n", s); return 0; }
char *s = "abc"; 8: 48 c7 45 f8 00 00 00 movq $0x0,-0x8(%rbp) f: 00 c: R_X86_64_32S .rodata
17: c7 45 f0 61 62 63 00 movl $0x636261,-0x10(%rbp)
Section to Segment mapping: Segment Sections... 02 .text .rodata
printf("sizeof s[] = %zu\n", sizeof(s)); printf("sizeof *s = %zu\n", sizeof(s));
const DBJ* p means "p points to a DBJ that is const"
const DBJ* const p means "p is a const pointer to a const DBJ"
printf("Buffered, will be flushed"); fflush(stdout);
program A output program B output program B output program A output program B output
proprogrgraam m AB ououtputputt prproogrgram amB A ououtputtput program B output
typedef struct { int (*open)(void *self, char *fspec); int (*close)(void *self); int (*read)(void *self, void *buff, size_t max_sz, size_t *p_act_sz); int (*write)(void *self, void *buff, size_t max_sz, size_t *p_act_sz); } tCommClass; tCommClass commRs232; commRs232.open = &rs232Open; : : commRs232.write = &rs232Write; tCommClass commTcp; commTcp.open = &tcpOpen; : : commTcp.write = &tcpWrite;
int stat = (commTcp.open)(commTcp, "bigiron.box.com:5000");
typedef struct sCommClass { int (*open)(struct sCommClass *self, char *fspec); } tCommClass;
static int tcpOpen (tCommClass *tcp, char *fspec) { printf ("Opening TCP: %s\n", fspec); return 0; } static int tcpInit (tCommClass *tcp) { tcp->open = &tcpOpen; return 0; }
static int httpOpen (tCommClass *http, char *fspec) { printf ("Opening HTTP: %s\n", fspec); return 0; } static int httpInit (tCommClass *http) { http->open = &httpOpen; return 0; }
int main (void) { int status; tCommClass commTcp, commHttp; tcpInit (&commTcp); httpInit (&commHttp); status = (commTcp.open)(&commTcp, "bigiron.box.com:5000"); status = (commHttp.open)(&commHttp, "http: return 0; }
Opening TCP: bigiron.box.com:5000 Opening HTTP: http:
class stack { public: stack(); void push(thing *); thing * pop(); static int this_is_here_as_an_example_only; private: ... };
struct stack { struct stack_type * my_type; }; struct stack_type { void (* construct)(struct stack * this); struct stack * (* operator_new)(); void (*push)(struct stack * this, thing * t); thing * (*pop)(struct stack * this); int this_is_here_as_an_example_only; }Stack = { .construct = stack_construct, .operator_new = stack_operator_new, .push = stack_push, .pop = stack_pop };
struct stack * st = Stack.operator_new(); if (!st) { } else { stack_push(st, thing0); Stack.push(st, thing1); st->my_type.push(st, thing2); }
struct Animal_Vtable{ typedef void (*Walk_Fun)(struct Animal *a_This); typedef struct Animal * (*Dtor_Fun)(struct Animal *a_This); Walk_Fun Walk; Dtor_Fun Dtor; }; struct Animal{ Animal_Vtable vtable; char *Name; }; struct Dog{ Animal_Vtable vtable; char *Name; char *Type; }; void Animal_Walk(struct Animal *a_This){ printf("Animal (%s) walking\n", a_This->Name); } struct Animal* Animal_Dtor(struct Animal *a_This){ printf("animal::dtor\n"); return a_This; } Animal *Animal_Alloc(){ return (Animal*)malloc(sizeof(Animal)); } Animal *Animal_New(Animal *a_Animal){ a_Animal->vtable.Walk = Animal_Walk; a_Animal->vtable.Dtor = Animal_Dtor; a_Animal->Name = "Anonymous"; return a_Animal; } void Animal_Free(Animal *a_This){ a_This->vtable.Dtor(a_This); free(a_This); } void Dog_Walk(struct Dog *a_This){ printf("Dog walking %s (%s)\n", a_This->Type, a_This->Name); } Dog* Dog_Dtor(struct Dog *a_This){ Animal_Dtor((Animal*)a_This); printf("dog::dtor\n"); return a_This; } Dog *Dog_Alloc(){ return (Dog*)malloc(sizeof(Dog)); } Dog *Dog_New(Dog *a_Dog){ Animal_New((Animal*)a_Dog); a_Dog->Type = "Dog type"; a_Dog->vtable.Walk = (Animal_Vtable::Walk_Fun) Dog_Walk; a_Dog->vtable.Dtor = (Animal_Vtable::Dtor_Fun) Dog_Dtor; return a_Dog; } int main(int argc, char **argv){ /* Base class: Animal *a_Animal = Animal_New(Animal_Alloc()); */ Animal *a_Animal = (Animal*)Dog_New(Dog_Alloc()); a_Animal->vtable.Walk(a_Animal); Animal_Free(a_Animal); }
... typedef struct FOO_type FOO_type; FOO_type *FOO_new(void); void FOO_free(FOO_type *this); ... void FOO_dosomething(FOO_type *this, param ...): char *FOO_getName(FOO_type *this, etc);
... struct FOO_type { whatever... }; FOO_type *FOO_new(void) { FOO_type *this = calloc(1, sizeof (FOO_type)); ... FOO_dosomething(this, ); return this; }
struct foobarbaz{ int one; int two; int three; int (*exampleMethod)(int, int); }; int addTwoNumbers(int a, int b){ return a+b; } int main() { int (*pointerToFunction)(int, int) = addTwoNumbers; int test = (*pointerToFunction)(12,12); printf ("test: %u \n", test); struct foobarbaz fbb; fbb.one = 1; fbb.two = 2; fbb.three = 3; fbb.exampleMethod = addTwoNumbers; int test2 = fbb.exampleMethod(13,36); printf ("test2: %u \n", test2); printf("\nDone\n"); return 0; }
struct Node { int somevar; }; void print() { printf("Hello from an object-oriented C method!"); }; struct Tree { struct Node * NIL; void (*FPprint)(void); struct Node *root; struct Node NIL_t; } TreeA = {&TreeA.NIL_t,print}; int main() { struct Tree TreeB; TreeB = TreeA; TreeB.FPprint(); return 0; }
CLASS(Animal) { char *name; STATIC(Animal); vFn talk; }; static int Animal_load(Animal *THIS,void *name) { THIS->name = name; return 0; } ASM(Animal, Animal_load, NULL, NULL, NULL) CLASS_EX(Cat,Animal) { STATIC_EX(Cat, Animal); }; static void Meow(Animal *THIS){ printf("Meow!My name is %s!\n", THIS->name); } static int Cat_loadSt(StAnimal *THIS, void *PARAM){ THIS->talk = (void *)Meow; return 0; } ASM_EX(Cat,Animal, NULL, NULL, Cat_loadSt, NULL) CLASS_EX(Dog,Animal){ STATIC_EX(Dog, Animal); }; static void Woof(Animal *THIS){ printf("Woof!My name is %s!\n", THIS->name); } static int Dog_loadSt(StAnimal *THIS, void *PARAM) { THIS->talk = (void *)Woof; return 0; } ASM_EX(Dog, Animal, NULL, NULL, Dog_loadSt, NULL) int main(){ Animal *animals[4000]; StAnimal *f; int i = 0; for (i=0; i<4000; i++) { if(i%2==0) animals[i] = NEW(Dog,"Jack"); else animals[i] = NEW(Cat,"Lily"); }; f = ST(animals[0]); for(i=0; i<4000; ++i) { f->talk(animals[i]); } for (i=0; i<4000; ++i) { DELETE0(animals[i]); } return 0; }
struct private_class; extern struct private_class * new_private_class(); extern int ret_a_value(struct private_class *, int a, int b); extern void delete_private_class(struct private_class *); void (*late_bind_function)(struct private_class *p); struct inherited_class_1; struct inherited_class_2; struct private_class { int a; int b; struct inherited_class_1 *p1; struct inherited_class_2 *p2; }; struct inherited_class_1 * new_inherited_class_1(); struct inherited_class_2 * new_inherited_class_2(); struct private_class * new_private_class() { struct private_class *p; p = (struct private_class*) malloc(sizeof(struct private_class)); p->a = 0; p->b = 0; p->p1 = new_inherited_class_1(); p->p2 = new_inherited_class_2(); return p; } int ret_a_value(struct private_class *p, int a, int b) { return p->a + p->b + a + b; } void delete_private_class(struct private_class *p) { free(p); } struct private_class *p; p = new_private_class(); late_bind_function = &implementation_function; delete_private_class(p);
typedef struct _peeker { log_t *log; symbols_t *sym; scanner_t scan; peek_t pk; int trace; void (*push) ( SELF *d, symbol_t *symbol ); short (*peek) ( SELF *d, int level ); short (*get) ( SELF *d ); int (*get_line_number) ( SELF *d ); } peeker_t, SlkToken; INSTANCE_METHOD int (get_line_number) ( peeker_t *d ) { return d->scan.line_number; } PUBLIC void InitializePeeker ( peeker_t *peeker, int trace, symbols_t *symbols, log_t *log, list_t *list ) { InitializeScanner ( &peeker->scan, trace, symbols, log, list ); peeker->log = log; peeker->sym = symbols; peeker->pk.current = peeker->pk.buffer; peeker->pk.count = 0; peeker->trace = trace; peeker->get_line_number = get_line_number; peeker->push = push; peeker->get = get; peeker->peek = peek; }
struct { char a; char b; char c; char d; } mystruct; mystruct.a = mystruct.b = mystruct.c = mystruct.d = char* my_pointer; my_pointer = &mystruct.b; printf("Start: my_pointer = %c\n", *my_pointer); my_pointer++; printf("After: my_pointer = %c\n", *my_pointer); my_pointer = &mystruct.a; printf("Then: my_pointer = %c\n", *my_pointer); my_pointer = my_pointer + 3; printf("End: my_pointer = %c\n", *my_pointer);
int * put_off(const int newrow[2]) { static int mymatrix[3][2]; static int (*rowp)[2] = mymatrix; int (* const border)[] = mymatrix + NUM_ELEM(mymatrix); memcpy(rowp, newrow, sizeof(*rowp)); rowp += 1; if (rowp == border) { rowp = mymatrix; } return *rowp; } int main(int argc, char *argv[]) { int i = 0; int row[2] = {0, 1}; int *rout; for (i = 0; i < 6; i++) { row[0] = i; row[1] += i; rout = put_off(row); printf("%d (%p): [%d, %d]\n", i, (void *) rout, rout[0], rout[1]); } return 0; }
typedef int (*PointerToIntArray)[]; typedef int *ArrayOfIntPointers[];
static void foo(); namespace { void this_function_has_internal_linkage() { } }
/* Undefined behavior: already defined in main. * Binutils 2.24 gives an error and refuses to link. * https: */ /*void f() { puts("a f"); }*/ void f(void); static void sf() { puts("a sf"); } void a() { f(); sf(); }
void a(void); void f() { puts("main f"); } static void sf() { puts("main sf"); } void m() { f(); sf(); } int main() { m(); a(); return 0; }
gcc -c a.c -o a.o gcc -c main.c -o main.o gcc -o main main.o a.o
int f() { return 0; } static int sf() { return 0; }
Num: Value Size Type Bind Vis Ndx Name 5: 000000000000000b 11 FUNC LOCAL DEFAULT 1 sf 9: 0000000000000000 11 FUNC GLOBAL DEFAULT 1 f
int inline FixedPointMul (int a, int b) { long long a_long = a; long long product = a_long * b; return (int) (product >> 16); }
int inline FixedPointMul (int a, int b) { return (int) __ll_rshift(__emul(a,b),16); }
float KahanSum ( const float *data, int n ) { float sum = 0.0f, C = 0.0f, Y, T; for (int i = 0 ; i < n ; ++i) { Y = *data++ - C; T = sum + Y; C = T - sum - Y; sum = T; } return sum; } float AsmSum ( const float *data, int n ) { float result = 0.0f; _asm { mov esi,data mov ecx,n fldz fldz l1: fsubr [esi] add esi,4 fld st(0) fadd st(0),st(2) fld st(0) fsub st(0),st(3) fsub st(0),st(2) fstp st(2) fstp st(2) loop l1 fstp result fstp result } return result; } int main (int, char **) { int count = 1000000; float *source = new float [count]; for (int i = 0 ; i < count ; ++i) { source [i] = static_cast <float> (rand ()) / static_cast <float> (RAND_MAX); } LARGE_INTEGER start, mid, end; float sum1 = 0.0f, sum2 = 0.0f; QueryPerformanceCounter (&start); sum1 = KahanSum (source, count); QueryPerformanceCounter (&mid); sum2 = AsmSum (source, count); QueryPerformanceCounter (&end); cout << " C code: " << sum1 << " in " << (mid.QuadPart - start.QuadPart) << endl; cout << "asm code: " << sum2 << " in " << (end.QuadPart - mid.QuadPart) << endl; return 0; }
C code: 500137 in 103884668 asm code: 500137 in 52129147
for (int y=0; y < imageHeight; y++) { for (int x=0; x < imageWidth; x++) { } }
int16_t x, y; int16_t prod = (int16_t)(((int32_t)x*y)>>16);`
uint8_t x[32]; for (int i = 32; --i > 0; ) { x[i] = (x[i] >> 1) | (x[i-1] << 7); } x[0] >>= 1;
mov esi, offset string mov edi, esi xor ecx, ecx lp: mov ax, byte ptr [esi] cmp al, cl je end_1 cmp ah, cl je end_2 mov bx, byte ptr [esi + 2] cmp bl, cl je end_3 cmp bh, cl je end_4 add esi, 4 jmp lp end_4: inc esi end_3: inc esi end_2: inc esi end_1: inc esi mov ecx, esi sub ecx, edi
add edx,[DeltaVFrac] ; add in dVFrac sbb ebp,ebp ; store carry mov [edi],al ; write pixel n mov al,[esi] ; fetch pixel n+1 add ecx,ebx ; add in dUFrac adc esi,[4*ebp + UVStepVCarry]; add in steps
long n; unsigned long un; printf("%ld", n); printf("%lu", un);
long long n; unsigned long long un; printf("%lld", n); printf("%llu", un);
# int main() { printf("Hello, World!"); return 0; }
$ cat i++.c extern void g(int i); void f() { int i; for (i = 0; i < 100; i++) g(i); }
$ diff i++.c ++i.c 6c6 < for (i = 0; i < 100; i++) --- > for (i = 0; i < 100; ++i)
$ md5 i++.s ++i.s MD5 (i++.s) = 90f620dda862cd0205cd5db1f2c8c06e MD5 (++i.s) = 90f620dda862cd0205cd5db1f2c8c06e $ md5 *.o MD5 (++i.o) = dd3ef1408d3a9e4287facccec53f7d22 MD5 (i++.o) = dd3ef1408d3a9e4287facccec53f7d22
Foo Foo::operator++() { Foo oldFoo = *this; return oldFoo; }
Integer& Integer::operator++() { *this += 1; return *this; } const Integer Integer::operator++(int) { Integer oldValue = *this; ++(*this); return oldValue; }
a = ++b + c; ; increment b LD A, [&b] INC A ST A, [&b] ; add with c ADD A, [&c] ; store in a ST A, [&a]
a = b++ + c; ; load b LD A, [&b] ; add with c ADD A, [&c] ; store in a ST A, [&a] ; increment b LD A, [&b] INC A ST A, [&b]
CGPoint cgPoint = CGPointMake(0,0); NSLog(@"%@",cgPoint);
NSStringFromCGPoint NSStringFromCGSize NSStringFromCGRect NSStringFromCGAffineTransform NSStringFromUIEdgeInsets
NSLog(@"%@", CGRectCreateDictionaryRepresentation(rect));
@define LogCGPoint(POINT) NSLog(@"%s: (%0.0f, %0.0f)",
CGPoint cgPoint = CGPointMake(10,30); NSLog(@"%@",[NSValue valueWithCGPoint:cgPoint]);
1) NSStringFromCGPoint, 2) NSStringFromCGSize, 3) NSStringFromCGRect, 4) NSStringFromCGAffineTransform, 5) NSStringFromUIEdgeInsets,
1) NSLog(@"NSStringFromCGPoint = %@", NSStringFromCGRect(cgPointValue));
NSLog(@"%@",CGRectCreateDictionaryRepresentation(rect));
int main() { ... LOG_INFO("end, press key to close"); getchar(); return 0; }
Console.WriteLine("Press any key to exit..."); Console.ReadKey();
extern "C" int __stdcall IsDebuggerPresent(void); int main(int argc, char** argv) { if (IsDebuggerPresent()) atexit([] {system("PAUSE"); }); ... }
/* run this program using the console pauser or add your own getch, system("pause") or input loop */ int main() { . . . getch(); return 0; }
Tools->Options->Debugging->Automatically close the console
typedef struct MY_TYPE { bool flag; short int value; double stuff; } MY_TYPE; void function(void) { MY_TYPE a; ... a = { true, 15, 0.123 } }
MY_TYPE a = { .flag = true, .value = 123, .stuff = 0.456 };
MY_TYPE a; a = (MY_TYPE) { .flag = true, .value = 123, .stuff = 0.456 }; ... a = (MY_TYPE) { .value = 234, .stuff = 1.234, .flag = false };
a = (MY_TYPE) { true, 123, 0.456 }; ... a = (MY_TYPE) { false, 234, 1.234 };
typedef struct Item { int a; float b; char* name; } Item; int main(void) { Item item = { 5, 2.2, "George" }; return 0; }
typedef struct Item { int a; float b; char* name; } Item; int main(void) { Item item = {5, 2.2, "George"}; return 0; }
MY_TYPE a = { .stuff = 0.456, .flag = true, .value = 123 };
typedef unsigned char uchar; struct fields { uchar num; uchar lbl[35]; }; struct fields labels[] = { {0,"Package"}, {1,"Version"}, {2,"Apport"}, {3,"Architecture"}, {4,"Bugs"}, {5,"Description-md5"}, {6,"Essential"}, {7,"Filename"}, {8,"Ghc-Package"}, {9,"Gstreamer-Version"}, {10,"Homepage"}, {11,"Installed-Size"}, {12,"MD5sum"}, {13,"Maintainer"}, {14,"Modaliases"}, {15,"Multi-Arch"}, {16,"Npp-Description"}, {17,"Npp-File"}, {18,"Npp-Name"}, {19,"Origin"} };
typedef struct book { char title[10]; char author[10]; float price; } book; int main() { book b1={"DS", "Ajay", 250.0}; printf("%s \t %s \t %f", b1.title, b1.author, b1.price); return 0; }
void init_MyStruct(MyStruct* thiz, int a, int b) { thiz->a = a; thiz->b = b; }
typedef struct { char *str; size_t len; jsmntok_t *tok; int tsz; } jsmn_ts;
jsmn_ts mydata = jsmn_ts_default; jsmn_ts myarray[10] = {jsmn_ts_default, jsmn_ts_default};
{ void *mem; void *ptr; memset_16aligned(ptr, 0, 1024); }
{ void *mem = malloc(1024+16); void *ptr = ((char *)mem+16) & ~ 0x0F; memset_16aligned(ptr, 0, 1024); free(mem); }
{ void *mem = malloc(1024+15); void *ptr = ((uintptr_t)mem+15) & ~ (uintptr_t)0x0F; memset_16aligned(ptr, 0, 1024); free(mem); }
static void memset_16aligned(void *space, char byte, size_t nbytes) { assert((nbytes & 0x0F) == 0); assert(((uintptr_t)space & 0x0F) == 0); memset(space, byte, nbytes); } int main(void) { void *mem = malloc(1024+15); void *ptr = (void *)(((uintptr_t)mem+15) & ~ (uintptr_t)0x0F); printf("0x%08" PRIXPTR ", 0x%08" PRIXPTR "\n", (uintptr_t)mem, (uintptr_t)ptr); memset_16aligned(ptr, 0, 1024); free(mem); return(0); }
static void memset_16aligned(void *space, char byte, size_t nbytes) { assert((nbytes & 0x0F) == 0); assert(((uintptr_t)space & 0x0F) == 0); memset(space, byte, nbytes); } static void test_mask(size_t align) { uintptr_t mask = ~(uintptr_t)(align - 1); void *mem = malloc(1024+align-1); void *ptr = (void *)(((uintptr_t)mem+align-1) & mask); assert((align & (align - 1)) == 0); printf("0x%08" PRIXPTR ", 0x%08" PRIXPTR "\n", (uintptr_t)mem, (uintptr_t)ptr); memset_16aligned(ptr, 0, 1024); free(mem); } int main(void) { test_mask(16); test_mask(32); test_mask(64); test_mask(128); return(0); }
void *aligned_alloc(size_t alignment, size_t size);
int posix_memalign(void **memptr, size_t alignment, size_t size);
void *mem = malloc(1024+15); ASSERT(mem); void *ptr = ((char*)mem+15) & ~ (size_t)0x0F;
void *mem = malloc(1024+15+sizeof(void*)); if (!mem) return mem; void *ptr = ((char*)mem+sizeof(void*)+15) & ~ (size_t)0x0F; ((void**)ptr)[-1] = mem; return ptr;
struct alignment { char c; union { intmax_t imax; long double ldbl; void *vptr; void (*fptr)(void); } u; } align_data; size_t align = (char *)&align_data.u.imax - &align_data.c;
void *mem = malloc(1024 + 15); void *ptr = (void*) ((uintptr_t) mem + 15) / 16 * 16; memset_16aligned(ptr, 0, 1024); free(mem);
void my_func( void ) { uint8_t array[1024] __attribute__ ((aligned(16))); ... }
void *buf = NULL; int err = posix_memalign( &buf, 32 , 1024 ); if( err ) RunInCirclesWaivingArmsWildly(); ... free(buf);
void My_func( uint8_t *tempBuf, ... ) { uint8_t *alignedBuf = (uint8_t*) (((uintptr_t) tempBuf + ((uintptr_t)alignment-1)) & -((uintptr_t) alignment)); ... }
int main () { void *mem; void *ptr; struct __attribute__((packed)) s_CozyMem { char acSpace[16]; }; mem = malloc(sizeof(struct s_CozyMem)); ptr = mem; if(((unsigned long)ptr & 15) == 0) printf("Aligned to 16 bytes.\n"); else printf("Rubbish.\n"); free(mem); return 1; }
char* p = malloc (size + 15); p += (- (unsigned int) p) % 16;
main(){ void *mem1 = malloc(1024+16); void *mem = ((char*)mem1)+1; printf ( " ptr = %p \n ", mem ); void *ptr = ((long)mem+16) & ~ 0x0F; printf ( " aligned ptr = %p \n ", ptr ); printf (" ptr after adding diff mod %p (same as above ) ", (long)mem1 + (16 -((long)mem1%16)) ); free(mem1); }
void *mem; void *ptr; try: mem = malloc(1024); if (mem % 16 != 0) { free(mem); goto try; } ptr = mem; memset_16aligned(ptr, 0, 1024);
void *mem = malloc(1024+16); void *ptr = ((char *)mem+16) & ~ 0x0F; memset_16aligned(ptr, 0, 1024); free(mem);
long add; mem = (void*)malloc(1024 +15); add = (long)mem; add = add - (add % 16); ptr = (whatever*)(add);
int func(); int func(param) { return param; } int main() { int bla = func(10); printf("%d", bla); }
return-type function-name(parameter-list,...) { body... }
foo.c: In function ‘func’: foo.c:5:5: warning: type of ‘param’ defaults to ‘int’ [-Wmissing-parameter-type]
foo.c:5:10: warning: parameter defaulting to type int func(param) ^ 1 warning generated.
foo.c: In function ‘func’: foo.c:6:1: error: number of arguments doesn’t match prototype foo.c:3:5: error: prototype declaration foo.c: In function ‘main’: foo.c:12:5: error: too many arguments to function ‘func’ foo.c:5:5: note: declared here
foo.c:5:5: error: conflicting types for int func(param) ^ foo.c:3:5: note: previous declaration is here int func(void); ^ foo.c:12:20: error: too many arguments to function call, expected 0, have 1 int bla = func(10); ~~~~ ^~ foo.c:3:1: note: int func(void); ^ 2 errors generated.
cc -Wmissing-variable-declarations -Wstrict-variable-declarations -Wold-style-definition
static __inline__ int sort6(int * d){ char j, i, imin; int tmp; for (j = 0 ; j < 5 ; j++){ imin = j; for (i = j + 1; i < 6 ; i++){ if (d[i] < d[imin]){ imin = i; } } tmp = d[j]; d[j] = d[imin]; d[imin] = tmp; } } static __inline__ unsigned long long rdtsc(void) { unsigned long long int x; __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x)); return x; } int main(int argc, char ** argv){ int i; int d[6][5] = { {1, 2, 3, 4, 5, 6}, {6, 5, 4, 3, 2, 1}, {100, 2, 300, 4, 500, 6}, {100, 2, 3, 4, 500, 6}, {1, 200, 3, 4, 5, 600}, {1, 1, 2, 1, 2, 1} }; unsigned long long cycles = rdtsc(); for (i = 0; i < 6 ; i++){ sort6(d[i]); /* * printf("d%d : %d %d %d %d %d %d\n", i, * d[i][0], d[i][6], d[i][7], * d[i][8], d[i][9], d[i][10]); */ } cycles = rdtsc() - cycles; printf("Time is %d\n", (unsigned)cycles); }
static inline void sort6_sorting_network_simple_swap(int * d){ const int b = max(d[x], d[y]); \ d[x] = a; d[y] = b; } SWAP(1, 2); SWAP(4, 5); SWAP(0, 2); SWAP(3, 5); SWAP(0, 1); SWAP(3, 4); SWAP(1, 4); SWAP(0, 3); SWAP(2, 5); SWAP(1, 3); SWAP(2, 4); SWAP(2, 3); }
static __inline__ int sort6(int *d){ int i, j; for (i = 1; i < 6; i++) { int tmp = d[i]; for (j = i; j >= 1 && tmp < d[j-1]; j--) d[j] = d[j-1]; d[j] = tmp; } }
static __inline__ int sort6(int * d){ SWAP(1, 2); SWAP(0, 2); SWAP(0, 1); SWAP(4, 5); SWAP(3, 5); SWAP(3, 4); SWAP(0, 3); SWAP(1, 4); SWAP(2, 5); SWAP(2, 4); SWAP(1, 3); SWAP(2, 3); }
inline void Sort2(int *p0, int *p1) { const int temp = min(*p0, *p1); *p1 = max(*p0, *p1); *p0 = temp; } inline void Sort3(int *p0, int *p1, int *p2) { Sort2(p0, p1); Sort2(p1, p2); Sort2(p0, p1); } inline void Sort4(int *p0, int *p1, int *p2, int *p3) { Sort2(p0, p1); Sort2(p2, p3); Sort2(p0, p2); Sort2(p1, p3); Sort2(p1, p2); } inline void Sort6(int *p0, int *p1, int *p2, int *p3, int *p4, int *p5) { Sort3(p0, p1, p2); Sort3(p3, p4, p5); Sort2(p0, p3); Sort2(p2, p5); Sort4(p1, p2, p3, p4); }
inline void sort6(int *d) { int e[6]; memcpy(e,d,6*sizeof(int)); int o0 = (d[0]>d[1])+(d[0]>d[2])+(d[0]>d[3])+(d[0]>d[4])+(d[0]>d[5]); int o1 = (d[1]>=d[0])+(d[1]>d[2])+(d[1]>d[3])+(d[1]>d[4])+(d[1]>d[5]); int o2 = (d[2]>=d[0])+(d[2]>=d[1])+(d[2]>d[3])+(d[2]>d[4])+(d[2]>d[5]); int o3 = (d[3]>=d[0])+(d[3]>=d[1])+(d[3]>=d[2])+(d[3]>d[4])+(d[3]>d[5]); int o4 = (d[4]>=d[0])+(d[4]>=d[1])+(d[4]>=d[2])+(d[4]>=d[3])+(d[4]>d[5]); int o5 = 15-(o0+o1+o2+o3+o4); d[o0]=e[0]; d[o1]=e[1]; d[o2]=e[2]; d[o3]=e[3]; d[o4]=e[4]; d[o5]=e[5]; }
static inline void sort6_fast(int * d) { register int x0,x1,x2,x3,x4,x5; x1 = d[1]; x2 = d[2]; SWAP(x1, x2); x4 = d[4]; x5 = d[5]; SWAP(x4, x5); x0 = d[0]; SWAP(x0, x2); x3 = d[3]; SWAP(x3, x5); SWAP(x0, x1); SWAP(x3, x4); SWAP(x1, x4); SWAP(x0, x3); d[0] = x0; SWAP(x2, x5); d[5] = x5; SWAP(x1, x3); d[1] = x1; SWAP(x2, x4); d[4] = x4; SWAP(x2, x3); d[2] = x2; d[3] = x3; } static __inline__ unsigned long long rdtsc(void) { unsigned long long int x; __asm__ volatile ("rdtsc; shlq $32, %%rdx; orq %%rdx, %0" : "=a" (x) : : "rdx"); return x; } void ran_fill(int n, int *a) { static int seed = 76521; while (n--) *a++ = (seed = seed *1812433253 + 12345); } int main() { int i; int d[6*NTESTS]; ran_fill(6*NTESTS, d); unsigned long long cycles = rdtsc(); for (i = 0; i < 6*NTESTS ; i+=6) { sort6_fast(d+i); } cycles = rdtsc() - cycles; printf("Time is %.2lf\n", (double)cycles/(double)NTESTS); for (i = 0; i < 6*NTESTS ; i+=6) { if (d[i+0] > d[i+1] || d[i+1] > d[i+2] || d[i+2] > d[i+3] || d[i+3] > d[i+4] || d[i+4] > d[i+5]) printf("d%d : %d %d %d %d %d %d\n", i, d[i+0], d[i+1], d[i+2], d[i+3], d[i+4], d[i+5]); } return 0; }
Clarkdale (i5-650) ================== Direct call to qsort library function 635.14 575.65 581.61 577.76 521.12 Naive implementation (insertion sort) 538.30 135.36 134.89 240.62 101.23 Insertion Sort (Daniel Stutzbach) 424.48 159.85 160.76 152.01 151.92 Insertion Sort Unrolled 339.16 125.16 125.81 129.93 123.16 Rank Order 184.34 106.58 54.74 93.24 94.09 Rank Order with registers 127.45 104.65 53.79 98.05 97.95 Sorting Networks (Daniel Stutzbach) 269.77 130.56 128.15 126.70 127.30 Sorting Networks (Paul R) 551.64 103.20 64.57 73.68 73.51 Sorting Networks 12 with Fast Swap 321.74 61.61 63.90 67.92 67.76 Sorting Networks 12 reordered Swap 318.75 60.69 65.90 70.25 70.06 Reordered Sorting Network w/ fast swap 145.91 34.17 32.66 32.22 32.18 Kentsfield (Core 2 Quad) ======================== Direct call to qsort library function 870.01 736.39 723.39 725.48 721.85 Naive implementation (insertion sort) 503.67 174.09 182.13 284.41 191.10 Insertion Sort (Daniel Stutzbach) 345.32 152.84 157.67 151.23 150.96 Insertion Sort Unrolled 316.20 133.03 129.86 118.96 105.06 Rank Order 164.37 138.32 46.29 99.87 99.81 Rank Order with registers 115.44 116.02 44.04 116.04 116.03 Sorting Networks (Daniel Stutzbach) 230.35 114.31 119.15 110.51 111.45 Sorting Networks (Paul R) 498.94 77.24 63.98 62.17 65.67 Sorting Networks 12 with Fast Swap 315.98 59.41 58.36 60.29 55.15 Sorting Networks 12 reordered Swap 307.67 55.78 51.48 51.67 50.74 Reordered Sorting Network w/ fast swap 149.68 31.46 30.91 31.54 31.58 Sandy Bridge (i7-2600k) ======================= Direct call to qsort library function 559.97 451.88 464.84 491.35 458.11 Naive implementation (insertion sort) 341.15 160.26 160.45 154.40 106.54 Insertion Sort (Daniel Stutzbach) 284.17 136.74 132.69 123.85 121.77 Insertion Sort Unrolled 239.40 110.49 114.81 110.79 117.30 Rank Order 114.24 76.42 45.31 36.96 36.73 Rank Order with registers 105.09 32.31 48.54 32.51 33.29 Sorting Networks (Daniel Stutzbach) 210.56 115.68 116.69 107.05 124.08 Sorting Networks (Paul R) 364.03 66.02 61.64 45.70 44.19 Sorting Networks 12 with Fast Swap 246.97 41.36 59.03 41.66 38.98 Sorting Networks 12 reordered Swap 235.39 38.84 47.36 38.61 37.29 Reordered Sorting Network w/ fast swap 115.58 27.23 27.75 27.25 26.54 Nehalem (Xeon E5640) ==================== Direct call to qsort library function 911.62 890.88 681.80 876.03 872.89 Naive implementation (insertion sort) 457.69 236.87 127.68 388.74 175.28 Insertion Sort (Daniel Stutzbach) 317.89 279.74 147.78 247.97 245.09 Insertion Sort Unrolled 259.63 220.60 116.55 221.66 212.93 Rank Order 140.62 197.04 52.10 163.66 153.63 Rank Order with registers 84.83 96.78 50.93 109.96 54.73 Sorting Networks (Daniel Stutzbach) 214.59 220.94 118.68 120.60 116.09 Sorting Networks (Paul R) 459.17 163.76 56.40 61.83 58.69 Sorting Networks 12 with Fast Swap 284.58 95.01 50.66 53.19 55.47 Sorting Networks 12 reordered Swap 281.20 96.72 44.15 56.38 54.57 Reordered Sorting Network w/ fast swap 128.34 50.87 26.87 27.91 28.02
PUBLIC simd_sort_6 .DATA ALIGN 16 pass1_shuffle OWORD 0F0E0D0C0B0A09080706040503010200h pass1_add OWORD 0F0E0D0C0B0A09080706050503020200h pass2_shuffle OWORD 0F0E0D0C0B0A09080706030405000102h pass2_and OWORD 00000000000000000000FE00FEFE00FEh pass2_add OWORD 0F0E0D0C0B0A09080706050405020102h pass3_shuffle OWORD 0F0E0D0C0B0A09080706020304050001h pass3_and OWORD 00000000000000000000FDFFFFFDFFFFh pass3_add OWORD 0F0E0D0C0B0A09080706050404050101h pass4_shuffle OWORD 0F0E0D0C0B0A09080706050100020403h pass4_and OWORD 0000000000000000000000FDFD00FDFDh pass4_add OWORD 0F0E0D0C0B0A09080706050403020403h pass5_shuffle OWORD 0F0E0D0C0B0A09080706050201040300h pass5_and OWORD 0000000000000000000000FEFEFEFE00h pass5_add OWORD 0F0E0D0C0B0A09080706050403040300h pass6_shuffle OWORD 0F0E0D0C0B0A09080706050402030100h pass6_add OWORD 0F0E0D0C0B0A09080706050403030100h .CODE simd_sort_6 PROC FRAME .endprolog ; pxor xmm4, xmm4 ; pinsrd xmm4, dword ptr [rcx], 0 ; pinsrb xmm4, byte ptr [rcx + 4], 4 ; pinsrb xmm4, byte ptr [rcx + 5], 5 ; The benchmarked 38% faster mentioned in the text was with the above slower sequence that tied up the shuffle port longer. Same on extract ; avoiding pins/extrb also means we don movd xmm4, dword ptr [rcx] pinsrw xmm4, word ptr [rcx + 4], 2 ; word 2 = bytes 4 and 5 movdqa xmm5, xmm4 pshufb xmm5, oword ptr [pass1_shuffle] pcmpgtb xmm5, xmm4 paddb xmm5, oword ptr [pass1_add] pshufb xmm4, xmm5 movdqa xmm5, xmm4 pshufb xmm5, oword ptr [pass2_shuffle] pcmpgtb xmm5, xmm4 pand xmm5, oword ptr [pass2_and] paddb xmm5, oword ptr [pass2_add] pshufb xmm4, xmm5 movdqa xmm5, xmm4 pshufb xmm5, oword ptr [pass3_shuffle] pcmpgtb xmm5, xmm4 pand xmm5, oword ptr [pass3_and] paddb xmm5, oword ptr [pass3_add] pshufb xmm4, xmm5 movdqa xmm5, xmm4 pshufb xmm5, oword ptr [pass4_shuffle] pcmpgtb xmm5, xmm4 pand xmm5, oword ptr [pass4_and] paddb xmm5, oword ptr [pass4_add] pshufb xmm4, xmm5 movdqa xmm5, xmm4 pshufb xmm5, oword ptr [pass5_shuffle] pcmpgtb xmm5, xmm4 pand xmm5, oword ptr [pass5_and] paddb xmm5, oword ptr [pass5_add] pshufb xmm4, xmm5 movdqa xmm5, xmm4 pshufb xmm5, oword ptr [pass6_shuffle] pcmpgtb xmm5, xmm4 paddb xmm5, oword ptr [pass6_add] pshufb xmm4, xmm5 ;pextrd dword ptr [rcx], xmm4, 0 ; benchmarked with this ;pextrb byte ptr [rcx + 4], xmm4, 4 ; slower version ;pextrb byte ptr [rcx + 5], xmm4, 5 movd dword ptr [rcx], xmm4 pextrw word ptr [rcx + 4], xmm4, 2 ; x86 is little-endian, so this is the right order ret simd_sort_6 ENDP END
SWAP(0,1); SWAP(1,2); SWAP(2,3); SWAP(3,4); SWAP(4,5); SWAP(0,1); SWAP(1,2); SWAP(2,3); SWAP(3,4); SWAP(0,1); SWAP(1,2); SWAP(2,3); SWAP(0,1); SWAP(1,2); SWAP(0,1);
static inline void sort6_insertion_sort_unrolled_v2(int * d){ int t; t = d[1]; ITER(0); t = d[2]; ITER(1); ITER(0); t = d[3]; ITER(2); ITER(1); ITER(0); t = d[4]; ITER(3); ITER(2); ITER(1); ITER(0); t = d[5]; ITER(4); ITER(3); ITER(2); ITER(1); ITER(0);
MOV r6, r2 CMP r6, r1 MOVLT r2, r1 MOVLT r1, r6 CMP r6, r0 MOVLT r1, r0 MOVLT r0, r6
void xorSwap (int *x, int *y) { if (*x != *y) { *x ^= *y; *y ^= *x; *x ^= *y; } }
**Direct call to qsort library function** : 164 **Naive implementation (insertion sort)** : 138 **Insertion Sort (Daniel Stutzbach)** : 85 **Insertion Sort Unrolled** : 97 **Sorting Networks (Daniel Stutzbach)** : 457 **Sorting Networks (Paul R)** : 179 **Sorting Networks 12 with Fast Swap** : 238 **Sorting Networks 12 reordered Swap** : 236 **Rank Order** : 116
void shellsort (int *valp) { int c,a,*cp,*ip=valp,*ep=valp+5; c=*valp; a=*(valp+4);if (c>a) {*valp= a;*(valp+4)=c;} c=*(valp+1);a=*(valp+5);if (c>a) {*(valp+1)=a;*(valp+5)=c;} cp=ip; do { c=*cp; a=*(cp+1); do { if (c<a) break; *cp=a; *(cp+1)=c; cp-=1; c=*cp; } while (cp>=valp); ip+=1; cp=ip; } while (ip<ep); }
static __inline__ int sort6(int * d) { char j, i; int tmp; for (inc = 4; inc > 0; inc -= 3) { for (i = inc; i < 5; i++) { tmp = a[i]; j = i; while (j >= inc && a[j - inc] > tmp) { a[j] = a[j - inc]; j -= inc; } a[j] = tmp; } } }
void sort3(int* array) { if (array[1] < array[0]) { if (array[2] < array[0]) { if (array[2] < array[1]) { std::swap(array[0], array[2]); } else { int tmp = array[0]; array[0] = array[1]; array[1] = array[2]; array[2] = tmp; } } else { std::swap(array[0], array[1]); } } else { if (array[2] < array[1]) { if (array[2] < array[0]) { int tmp = array[2]; array[2] = array[1]; array[1] = array[0]; array[0] = tmp; } else { std::swap(array[1], array[2]); } } } }
void sort4(int* array) { sort3(array); if (array[3] < array[2]) { std::swap(array[2], array[3]); if (array[2] < array[1]) { std::swap(array[1], array[2]); if (array[1] < array[0]) { std::swap(array[0], array[1]); } } } }
void sort6(int* array) { sort4(array+1); if (array[5] < array[0]) { std::swap(array[0], array[5]); } if (array[1] < array[0]) { std::swap(array[0], array[1]); if (array[2] < array[1]) { std::swap(array[1], array[2]); if (array[3] < array[2]) { std::swap(array[2], array[3]); if (array[4] < array[3]) { std::swap(array[3], array[4]); } } } } if (array[5] < array[4]) { std::swap(array[4], array[5]); if (array[4] < array[3]) { std::swap(array[3], array[4]); if (array[3] < array[2]) { std::swap(array[2], array[3]); if (array[2] < array[1]) { std::swap(array[1], array[2]); } } } } }
static inline void sort6_insertion_sort_avx(int* d) { __m256i src = _mm256_setr_epi32(d[0], d[1], d[2], d[3], d[4], d[5], 0, 0); __m256i index = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7); __m256i shlpermute = _mm256_setr_epi32(7, 0, 1, 2, 3, 4, 5, 6); __m256i sorted = _mm256_setr_epi32(d[0], INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX); __m256i val, gt, permute; unsigned j; val = _mm256_permutevar8x32_epi32(src, _mm256_set1_epi32(I));\ gt = _mm256_cmpgt_epi32(sorted, val);\ permute = _mm256_blendv_epi8(index, shlpermute, gt);\ j = ffs( _mm256_movemask_epi8(gt)) >> 2;\ sorted = _mm256_blendv_epi8(_mm256_permutevar8x32_epi32(sorted, permute),\ val, _mm256_cmpeq_epi32(index, _mm256_set1_epi32(j))) ITER(1); ITER(2); ITER(3); ITER(4); ITER(5); int x[8]; _mm256_storeu_si256((__m256i*)x, sorted); d[0] = x[0]; d[1] = x[1]; d[2] = x[2]; d[3] = x[3]; d[4] = x[4]; d[5] = x[5]; }
static inline void sort6_rank_order_avx(int* d) { __m256i ror = _mm256_setr_epi32(5, 0, 1, 2, 3, 4, 6, 7); __m256i one = _mm256_set1_epi32(1); __m256i src = _mm256_setr_epi32(d[0], d[1], d[2], d[3], d[4], d[5], INT_MAX, INT_MAX); __m256i rot = src; __m256i index = _mm256_setzero_si256(); __m256i gt, permute; __m256i shl = _mm256_setr_epi32(1, 2, 3, 4, 5, 6, 6, 6); __m256i dstIx = _mm256_setr_epi32(0,1,2,3,4,5,6,7); __m256i srcIx = dstIx; __m256i eq = one; __m256i rotIx = _mm256_setzero_si256(); rot = _mm256_permutevar8x32_epi32(rot, ror);\ gt = _mm256_cmpgt_epi32(src, rot);\ index = _mm256_add_epi32(index, _mm256_and_si256(gt, one));\ index = _mm256_add_epi32(index, _mm256_and_si256(eq,\ _mm256_cmpeq_epi32(src, rot)));\ eq = _mm256_insert_epi32(eq, 0, I) INC(0); INC(1); INC(2); INC(3); INC(4); int e[6]; e[0] = d[0]; e[1] = d[1]; e[2] = d[2]; e[3] = d[3]; e[4] = d[4]; e[5] = d[5]; int i[8]; _mm256_storeu_si256((__m256i*)i, index); d[i[0]] = e[0]; d[i[1]] = e[1]; d[i[2]] = e[2]; d[i[3]] = e[3]; d[i[4]] = e[4]; d[i[5]] = e[5]; }
static __inline__ int MIN(int a, int b){ int result =a; __asm__ ("pminsw %1, %0" : "+x" (result) : "x" (b)); return result; } static __inline__ int MAX(int a, int b){ int result = a; __asm__ ("pmaxsw %1, %0" : "+x" (result) : "x" (b)); return result; } static __inline__ unsigned long long rdtsc(void){ unsigned long long int x; __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x)); return x; } static __inline__ void sort6(int * in) { const int A=in[0], B=in[1], C=in[2], D=in[3], E=in[4], F=in[5]; in[0] = MIN( MIN4(A,B,C,D),MIN(E,F) ); const int AB = MAX(A, B), AC = MAX(A, C), AD = MAX(A, D), AE = MAX(A, E), AF = MAX(A, F), BC = MAX(B, C), BD = MAX(B, D), BE = MAX(B, E), BF = MAX(B, F), CD = MAX(C, D), CE = MAX(C, E), CF = MAX(C, F), DE = MAX(D, E), DF = MAX(D, F), EF = MAX(E, F); in[1] = MIN4 ( MIN4( AB, AC, AD, AE ), MIN4( AF, BC, BD, BE ), MIN4( BF, CD, CE, CF ), MIN3( DE, DF, EF) ); const int ABC = MAX(AB,C), ABD = MAX(AB,D), ABE = MAX(AB,E), ABF = MAX(AB,F), ACD = MAX(AC,D), ACE = MAX(AC,E), ACF = MAX(AC,F), ADE = MAX(AD,E), ADF = MAX(AD,F), AEF = MAX(AE,F), BCD = MAX(BC,D), BCE = MAX(BC,E), BCF = MAX(BC,F), BDE = MAX(BD,E), BDF = MAX(BD,F), BEF = MAX(BE,F), CDE = MAX(CD,E), CDF = MAX(CD,F), CEF = MAX(CE,F), DEF = MAX(DE,F); in[2] = MIN( MIN4 ( MIN4( ABC, ABD, ABE, ABF ), MIN4( ACD, ACE, ACF, ADE ), MIN4( ADF, AEF, BCD, BCE ), MIN4( BCF, BDE, BDF, BEF )), MIN4( CDE, CDF, CEF, DEF ) ); const int ABCD = MAX(ABC,D), ABCE = MAX(ABC,E), ABCF = MAX(ABC,F), ABDE = MAX(ABD,E), ABDF = MAX(ABD,F), ABEF = MAX(ABE,F), ACDE = MAX(ACD,E), ACDF = MAX(ACD,F), ACEF = MAX(ACE,F), ADEF = MAX(ADE,F), BCDE = MAX(BCD,E), BCDF = MAX(BCD,F), BCEF = MAX(BCE,F), BDEF = MAX(BDE,F), CDEF = MAX(CDE,F); in[3] = MIN4 ( MIN4( ABCD, ABCE, ABCF, ABDE ), MIN4( ABDF, ABEF, ACDE, ACDF ), MIN4( ACEF, ADEF, BCDE, BCDF ), MIN3( BCEF, BDEF, CDEF ) ); const int ABCDE= MAX(ABCD,E), ABCDF= MAX(ABCD,F), ABCEF= MAX(ABCE,F), ABDEF= MAX(ABDE,F), ACDEF= MAX(ACDE,F), BCDEF= MAX(BCDE,F); in[4]= MIN ( MIN4( ABCDE, ABCDF, ABCEF, ABDEF ), MIN ( ACDEF, BCDEF ) ); in[5] = MAX(ABCDE,F); } int main(int argc, char ** argv) { int d[6][6] = { {1, 2, 3, 4, 5, 6}, {6, 5, 4, 3, 2, 1}, {100, 2, 300, 4, 500, 6}, {100, 2, 3, 4, 500, 6}, {1, 200, 3, 4, 5, 600}, {1, 1, 2, 1, 2, 1} }; unsigned long long cycles = rdtsc(); for (int i = 0; i < 6; i++) { sort6(d[i]); } cycles = rdtsc() - cycles; printf("Time is %d\n", (unsigned)cycles); for (int i = 0; i < 6; i++) { printf("d%d : %d %d %d %d %d %d\n", i, d[i][0], d[i][1], d[i][2], d[i][3], d[i][4], d[i][5]); } }
static void sort6(int *o) { const int A=o[0],B=o[1],C=o[2],D=o[3],E=o[4],F=o[5]; const unsigned char AB = A>B, AC = A>C, AD = A>D, AE = A>E, BC = B>C, BD = B>D, BE = B>E, CD = C>D, CE = C>E, DE = D>E, a = AB + AC + AD + AE + (A>F), b = 1 - AB + BC + BD + BE + (B>F), c = 2 - AC - BC + CD + CE + (C>F), d = 3 - AD - BD - CD + DE + (D>F), e = 4 - AE - BE - CE - DE + (E>F); o[a]=A; o[b]=B; o[c]=C; o[d]=D; o[e]=E; o[15-a-b-c-d-e]=F; }
template<class IterType> inline void sort6_iterator(IterType it) { const auto b = MAX(*(it + x), *(it + y)); \ *(it + x) = a; *(it + y) = b; } SWAP(1, 2) SWAP(4, 5) SWAP(0, 2) SWAP(3, 5) SWAP(0, 1) SWAP(3, 4) SWAP(1, 4) SWAP(0, 3) SWAP(2, 5) SWAP(1, 3) SWAP(2, 4) SWAP(2, 3) }
template<class IterType> inline void sort6_iterator_local(IterType it) { const auto b = MAX(data data DD2(1,2) SWAP(1, 2) DD2(4,5) SWAP(4, 5) DD1(0) SWAP(0, 2) DD1(3) SWAP(3, 5) SWAP(0, 1) SWAP(3, 4) SWAP(1, 4) SWAP(0, 3) CB(0) SWAP(2, 5) CB(5) SWAP(1, 3) CB(1) SWAP(2, 4) CB(4) SWAP(2, 3) CB(2) CB(3) }
template<class T> inline void sort6(T it) { DD2(1,2) SORT2(1,2) DD2(4,5) SORT2(4,5) DD1(0) SORT2(0,2) DD1(3) SORT2(3,5) SORT2(0,1) SORT2(3,4) SORT2(2,5) CB1(5) SORT2(1,4) SORT2(0,3) CB1(0) SORT2(2,4) CB1(4) SORT2(1,3) CB1(1) SORT2(2,3) CB2(2,3) }
template<class T> inline void sort6(T& e0, T& e1, T& e2, T& e3, T& e4, T& e5) { DD2(1,2) SORT2(1,2) DD2(4,5) SORT2(4,5) DD1(0) SORT2(0,2) DD1(3) SORT2(3,5) SORT2(0,1) SORT2(3,4) SORT2(2,5) CB1(5) SORT2(1,4) SORT2(0,3) CB1(0) SORT2(2,4) CB1(4) SORT2(1,3) CB1(1) SORT2(2,3) CB2(2,3) }
function sort4DG(cmp,start,end,n) { var n = typeof(n) !== var cmp = typeof(cmp) !== var start = typeof(start)!== var end = typeof(end) !== var count = end - start; var pos = -1; var i = start; var cc = []; cc[01] = cmp(arr[n][i+0],arr[n][i+1]); cc[23] = cmp(arr[n][i+2],arr[n][i+3]); if (cc[01]>0) {swap(n,i+0,i+1);} if (cc[23]>0) {swap(n,i+2,i+3);} cc[12] = cmp(arr[n][i+1],arr[n][i+2]); if (!(cc[12]>0)) {return n;} cc[02] = cc[01]==0 ? cc[12] : cmp(arr[n][i+0],arr[n][i+2]); if (cc[02]>0) { swap(n,i+1,i+2); swap(n,i+0,i+1); cc[13] = cc[23]==0 ? cc[12] : cmp(arr[n][i+1],arr[n][i+3]); if (cc[13]>0) { swap(n,i+2,i+3); swap(n,i+1,i+2); return n; } else { cc[23] = cc[23]==0 ? cc[12] : (cc[01]==0 ? cc[30] : cmp(arr[n][i+2],arr[n][i+3])); if (cc[23]>0) { swap(n,i+2,i+3); return n; } return n; } } else { if (cc[12]>0) { swap(n,i+1,i+2); cc[23] = cc[23]==0 ? cc[12] : cmp(arr[n][i+2],arr[n][i+3]); if (cc[23]>0) { swap(n,i+2,i+3); return n; } return n; } else { return n; } } return n; }
typedef signed char Dif; typedef signed int Dif; static int walksort (int *arr, int cnt); static void countdifs (int *arr, Dif *dif, int cnt); static void calcranks(int *arr, Dif *dif); int wsort6(int *arr); void do_print_a(char *msg, int *arr, unsigned cnt) { fprintf(stderr,"%s:", msg); for (; cnt--; arr++) { fprintf(stderr, " %3d", *arr); } fprintf(stderr,"\n"); } void do_print_d(char *msg, Dif *arr, unsigned cnt) { fprintf(stderr,"%s:", msg); for (; cnt--; arr++) { fprintf(stderr, " %3d", (int) *arr); } fprintf(stderr,"\n"); } static void inline countdifs (int *arr, Dif *dif, int cnt) { int top, bot; for (top = 0; top < cnt; top++ ) { for (bot = 0; bot < top; bot++ ) { if (arr[top] < arr[bot]) { dif[top]--; dif[bot]++; } } } return ; } static void inline calcranks(int *arr, Dif *dif){ dif[0] = (arr[0]>arr[1])+(arr[0]>arr[2])+(arr[0]>arr[3])+(arr[0]>arr[4])+(arr[0]>arr[5]); dif[1] = -1+ (arr[1]>=arr[0])+(arr[1]>arr[2])+(arr[1]>arr[3])+(arr[1]>arr[4])+(arr[1]>arr[5]); dif[2] = -2+ (arr[2]>=arr[0])+(arr[2]>=arr[1])+(arr[2]>arr[3])+(arr[2]>arr[4])+(arr[2]>arr[5]); dif[3] = -3+ (arr[3]>=arr[0])+(arr[3]>=arr[1])+(arr[3]>=arr[2])+(arr[3]>arr[4])+(arr[3]>arr[5]); dif[4] = -4+ (arr[4]>=arr[0])+(arr[4]>=arr[1])+(arr[4]>=arr[2])+(arr[4]>=arr[3])+(arr[4]>arr[5]); dif[5] = -(dif[0]+dif[1]+dif[2]+dif[3]+dif[4]); } static int walksort (int *arr, int cnt) { int idx, src,dst, nswap; Dif difs[cnt]; calcranks(arr, difs); for (idx=0; idx < cnt; idx++) difs[idx] =0; countdifs(arr, difs, cnt); calcranks(arr, difs); do_print_d("ISteps ", difs, cnt); nswap = 0; for (idx=0; idx < cnt; idx++) { int newval; int step,cyc; if ( !difs[idx] ) continue; newval = arr[idx]; cyc = 0; src = idx; do { int oldval; step = difs[src]; difs[src] =0; dst = src + step; cyc += step ; if(dst == idx+1)idx=dst; oldval = arr[dst]; fprintf(stderr, "[Nswap=%d] Cyc=%d Step=%2d Idx=%d Old=%2d New=%2d , nswap, cyc, step, idx, oldval, newval , src, dst, difs[dst], arr[dst] , newval ); do_print_a("Array ", arr, cnt); do_print_d("Steps ", difs, cnt); arr[dst] = newval; newval = oldval; nswap++; src = dst; } while( cyc); } return nswap; } /*************/ int wsort6(int *arr) { return walksort(arr, 6); }
Insertion Sort: Θ(n^2) Heap Sort: Θ(n log n) Count Sort: Θ(3n)
if (fabs(x-y) < K * FLT_EPSILON * fabs(x+y) || fabs(x-y) < FLT_MIN)
if (fabs(theView.frame.origin.x) < VISIBLE_SHIFT) { }
if (fabs(x-y) < K * DBL_EPSILON * fabs(x+y) || fabs(x-y) < DBL_MIN)
void main (void) { double x = 1e-13; double y = 0.0; double K = 1e22; int i = 0; for (; i < 32; i++, K = K/10.0) { printf ("K:%40.16lf -> ", K); if (fabs(x-y) < K * DBL_EPSILON * fabs(x+y) || fabs(x-y) < DBL_MIN) printf ("YES\n"); else printf ("NO\n"); } } ebg@ebg$ gcc -o test test.c ebg@ebg$ ./test K:10000000000000000000000.0000000000000000 -> YES K: 1000000000000000000000.0000000000000000 -> YES K: 100000000000000000000.0000000000000000 -> YES K: 10000000000000000000.0000000000000000 -> YES K: 1000000000000000000.0000000000000000 -> YES K: 100000000000000000.0000000000000000 -> YES K: 10000000000000000.0000000000000000 -> YES K: 1000000000000000.0000000000000000 -> NO K: 100000000000000.0000000000000000 -> NO K: 10000000000000.0000000000000000 -> NO K: 1000000000000.0000000000000000 -> NO K: 100000000000.0000000000000000 -> NO K: 10000000000.0000000000000000 -> NO K: 1000000000.0000000000000000 -> NO K: 100000000.0000000000000000 -> NO K: 10000000.0000000000000000 -> NO K: 1000000.0000000000000000 -> NO K: 100000.0000000000000000 -> NO K: 10000.0000000000000000 -> NO K: 1000.0000000000000000 -> NO K: 100.0000000000000000 -> NO K: 10.0000000000000000 -> NO K: 1.0000000000000000 -> NO K: 0.1000000000000000 -> NO K: 0.0100000000000000 -> NO K: 0.0010000000000000 -> NO K: 0.0001000000000000 -> NO K: 0.0000100000000000 -> NO K: 0.0000010000000000 -> NO K: 0.0000001000000000 -> NO K: 0.0000000100000000 -> NO K: 0.0000000010000000 -> NO
union foo { int a; char b; } foo; struct bar { int a; char b; } bar; union foo x; x.a = 3; x.b = struct bar y; y.a = 3; y.b =
union foo x; x.a = 3; x.b = printf("%i, %i\n", x.a, x.b);
union foo x; x.a = 387439; x.b = printf("%i, %i\n", x.a, x.b);
union foo x; x.a = 0xDEADBEEF; x.b = 0x22; printf("%x, %x\n", x.a, x.b);
struct foobarbazquux_t { int foo; long bar; double baz; long double quux; }
union foobarbazquux_u { int foo; long bar; double baz; long double quux; }
struct packetheader { int sourceaddress; int destaddress; int messagetype; union request { char fourcc[4]; int requestnumber; }; };
struct test { int a; double b; } * some_test_pointer;
union a * v = (union a*)some_int_pointer; *some_int_pointer = 5; v->a = 10; return *some_int_pointer;
union foo { struct float_guts { unsigned int fraction : 23; unsigned int exponent : 8; unsigned int sign : 1; } fg; float f; }; void print_float(float f) { union foo ff; ff.f = f; printf("%f: %d 0x%X 0x%X\n", f, ff.fg.sign, ff.fg.exponent, ff.fg.fraction); } int main(){ print_float(0.15625); return 0; }
struct MAIN_STRUCT { UINT64 bufferaddr; union { UINT32 data; struct INNER_STRUCT{ UINT16 length; UINT8 cso; UINT8 cmd; } flags; } data1; };
union SIGSELECT { SIGNAL_1 signal1; SIGNAL_2 signal2; ..... };
union pw { short int i; char ch[2]; }; int putw(short int num, FILE *fp); int main (void) { FILE *fp; fp fopen("test.tmp", "wb "); putw(1000, fp); fclose(fp); return 0; } int putw(short int num, FILE *fp) { pw word; word.i = num; putc(word.c[0] , fp); return putc(word.c[1] , fp); }
struct s_tag { int a; long int b; } x; union u_tag { int a; long int b; } y;
struct s_tag { int a; long int b; } x; union u_tag { int a; long int b; } y; int main() { printf("Memory allocation for structure = %d", sizeof(x)); printf("\nMemory allocation for union = %d", sizeof(y)); return 0; }
int main(int argc, char **argv) { union { short s; char c[sizeof(short)]; } un; un.s = 0x0102; if (sizeof(short) == 2) { if (un.c[0] == 1 && un.c[1] == 2) printf("big-endian\n"); else if (un.c[0] == 2 && un.c[1] == 1) printf("little-endian\n"); else printf("unknown\n"); } else printf("sizeof(short) = %d\n", sizeof(short)); exit(0); }
double m[] = {7709179928849219.0, 771}; int main() { m[1]--?m[0]*=2,main():printf((char*)m); }
01000011 00111011 01100011 01110101 01010011 00101011 00101011 01000011 +^^^^^^^ ^^^^---- -------- -------- -------- -------- -------- --------
01110011 01101011 01100011 01110101 01010011 00101011 00101011 01000011 -------- -------- -------- -------- -------- -------- -------- -------- 0x73
double m[2] = {7709179928849219.0, 771}; int main() { if (m[1]-- != 0) { m[0] *= 2; main(); } else { printf((char*) m); } }
double m[] = {7709179928849219.0, 0}; for (int i = 0; i < 771; i++) { m[0] *= 2; } printf((char*) m);
char string[] = "skcoR++C"; int main(){ printf("%f\n", *(double*)string); }
double x [] = { 978874550692723072, 8 }; char *y = (char *)x; int main(int argc, char **argv){ if (x[1]) { x[0] /= 2; main(--x[1], (char **)++y); } putchar(*--y); }
x[1] && (x[0] /= 2, main(--x[1], (char **)++y)); putchar(*--y);
x[1] && (x[0] /= 2, putchar(main(--x[1], (char **)++y))); return *--y;
double m[] = {7709179928849219.0, 0}; printf("%s\n", (char *)m);
void f() { if (m[1]-- != 0) { m[0] *= 2; f(); } else { printf((char*)m); } }
void transform (float *output, float const * input, float const * matrix, int *n) { int i; for (i=0; i<*n; i++) { float x = input[i*2+0]; float y = input[i*2+1]; output[i*2+0] = matrix[0] * x + matrix[1] * y; output[i*2+1] = matrix[2] * x + matrix[3] * y; } }
strcpy(char *d, const char* s) { while(*d++ = *s++); }
printf("%d %x %o\n", 10, 10, 10); print("%b\n", 10);
(byte & 0x80 ? (byte & 0x40 ? (byte & 0x20 ? (byte & 0x10 ? (byte & 0x08 ? (byte & 0x04 ? (byte & 0x02 ? (byte & 0x01 ?
printf("Leading text "BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(byte));
printf("m: "BYTE_TO_BINARY_PATTERN" "BYTE_TO_BINARY_PATTERN"\n", BYTE_TO_BINARY(m>>8), BYTE_TO_BINARY(m));
void printBits(size_t const size, void const * const ptr) { unsigned char *b = (unsigned char*) ptr; unsigned char byte; int i, j; for (i=size-1;i>=0;i--) { for (j=7;j>=0;j--) { byte = (b[i] >> j) & 1; printf("%u", byte); } } puts(""); }
int main(int argv, char* argc[]) { int i = 23; uint ui = UINT_MAX; float f = 23.45f; printBits(sizeof(i), &i); printBits(sizeof(ui), &ui); printBits(sizeof(f), &f); return 0; }
const char *byte_to_binary(int x) { static char b[9]; b[0] = int z; for (z = 128; z > 0; z >>= 1) { strcat(b, ((x & z) == z) ? "1" : "0"); } return b; } int main(void) { { char *tmp; char *b = "0101"; printf("%d\n", strtol(b, &tmp, 2)); } { printf("%s\n", byte_to_binary(5)); } return 0; }
const char *bit_rep[16] = { [ 0] = "0000", [ 1] = "0001", [ 2] = "0010", [ 3] = "0011", [ 4] = "0100", [ 5] = "0101", [ 6] = "0110", [ 7] = "0111", [ 8] = "1000", [ 9] = "1001", [10] = "1010", [11] = "1011", [12] = "1100", [13] = "1101", [14] = "1110", [15] = "1111", }; void print_byte(uint8_t byte) { printf("%s%s", bit_rep[byte >> 4], bit_rep[byte & 0x0F]); }
(((i) & 0x80ll) ? (((i) & 0x40ll) ? (((i) & 0x20ll) ? (((i) & 0x10ll) ? (((i) & 0x08ll) ? (((i) & 0x04ll) ? (((i) & 0x02ll) ? (((i) & 0x01ll) ? PRINTF_BINARY_PATTERN_INT8 PRINTF_BINARY_PATTERN_INT8 PRINTF_BYTE_TO_BINARY_INT8((i) >> 8), PRINTF_BYTE_TO_BINARY_INT8(i) PRINTF_BINARY_PATTERN_INT16 PRINTF_BINARY_PATTERN_INT16 PRINTF_BYTE_TO_BINARY_INT16((i) >> 16), PRINTF_BYTE_TO_BINARY_INT16(i) PRINTF_BINARY_PATTERN_INT32 PRINTF_BINARY_PATTERN_INT32 PRINTF_BYTE_TO_BINARY_INT32((i) >> 32), PRINTF_BYTE_TO_BINARY_INT32(i) int main() { long long int flag = 1648646756487983144ll; printf("My Flag " PRINTF_BINARY_PATTERN_INT64 "\n", PRINTF_BYTE_TO_BINARY_INT64(flag)); return 0; }
My Flag 0001011011100001001010110111110101111000100100001111000000101000
My Flag 00010110,11100001,00101011,01111101,01111000,10010000,11110000,00101000
char *binary_fmt(uintmax_t x, char buf[static FMT_BUF_SIZE]) { char *s = buf + FMT_BUF_SIZE; *--s = 0; if (!x) *--s = for(; x; x/=2) *--s = return s; }
char tmp[FMT_BUF_SIZE]; printf("%s\n", binary_fmt(x, tmp));
void print_binary(int number) { if (number) { print_binary(number >> 1); putc((number & 1) ? } }
const char* byte_to_binary( int x ) { static char b[sizeof(int)*8+1] = {0}; int y; long long z; for (z=1LL<<sizeof(int)*8-1,y=0; z>0; z>>=1,y++) { b[y] = ( ((x & z) == z) ? } b[y] = 0; return b; }
/* * File: main.c * Author: Techplex.Engineer * * Created on February 14, 2012, 9:16 PM */ static int printf_arginfo_M(const struct printf_info *info, size_t n, int *argtypes) { if (n > 0) { argtypes[0] = PA_POINTER; } return 1; } static int printf_output_M(FILE *stream, const struct printf_info *info, const void *const *args) { int value = 0; int len; value = *(int **) (args[0]); char buffer [50] = ""; char buffer2 [50] = ""; int bits = info->width; if (bits <= 0) bits = 8; int mask = pow(2, bits - 1); while (mask > 0) { sprintf(buffer, "%s", (((value & mask) > 0) ? "1" : "0")); strcat(buffer2, buffer); mask >>= 1; } strcat(buffer2, "\n"); len = fprintf(stream, "%s", buffer2); return len; } int main(int argc, char** argv) { register_printf_specifier( printf("%4B\n", 65); return (EXIT_SUCCESS); }
char* pBinFill(long int x,char *so, char fillChar); char* pBin(long int x, char *so); char* pBin(long int x,char *so) { char s[kDisplayWidth+1]; int i=kDisplayWidth; s[i--]=0x00; do { s[i--]=(x & 1) ? x>>=1; } while( x > 0); i++; sprintf(so,"%s",s+i); return so; }
char* pBinFill(long int x,char *so, char fillChar) { char s[kDisplayWidth+1]; int i=kDisplayWidth; s[i--]=0x00; do { s[i--]=(x & 1) ? x>>=1; } while( x > 0); while(i>=0) s[i--]=fillChar; sprintf(so,"%s",s); return so; }
void test() { char so[kDisplayWidth+1]; long int val=1; do { printf("%ld =\t\t% val*=11; } while (val < 100000000); } Output: 00000001 = 0x000001 = 0b00000000000000000000000000000001 00000011 = 0x00000b = 0b00000000000000000000000000001011 00000121 = 0x000079 = 0b00000000000000000000000001111001 00001331 = 0x000533 = 0b00000000000000000000010100110011 00014641 = 0x003931 = 0b00000000000000000011100100110001 00161051 = 0x02751b = 0b00000000000000100111010100011011 01771561 = 0x1b0829 = 0b00000000000110110000100000101001 19487171 = 0x12959c3 = 0b00000001001010010101100111000011
inline std::string format_binary(unsigned int x) { static char b[33]; b[32] = for (int z = 0; z < 32; z++) { b[31-z] = ((x>>z) & 0x1) ? } return b; }
void bin(int n) { if (n > 1) bin(n/2); printf("%d", n % 2); }
char *my_to_base(char *buf, unsigned i, int base) { assert(base >= 2 && base <= 36); char *s = &buf[TO_BASE_N - 1]; *s = do { s--; *s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i % base]; i /= base; } while (i); return s; } int main(void) { int ip1 = 0x01020304; int ip2 = 0x05060708; printf("%s %s\n", TO_BASE(ip1, 16), TO_BASE(ip2, 16)); printf("%s %s\n", TO_BASE(ip1, 2), TO_BASE(ip2, 2)); puts(TO_BASE(ip1, 8)); puts(TO_BASE(ip1, 36)); return 0; }
1020304 5060708 1000000100000001100000100 101000001100000011100001000 100401404 A2F44
void print_binary(unsigned int n) { unsigned int mask = 0; mask = ~mask ^ (~mask >> 1); for(; mask != 0; mask >>= 1) { putchar((n & mask) ? } }
char * format_binary(unsigned int x) { static char fmtbuf[(MAXLEN+1)*MAXCNT]; static int count = 0; char *b; count = count % MAXCNT + 1; b = &fmtbuf[(MAXLEN+1)*count]; b[MAXLEN] = for (int z = 0; z < MAXLEN; z++) { b[MAXLEN-1-z] = ((x>>z) & 0x1) ? return b; }
({ \ typeof(value) _v = value; \ __printb((typeof(_v) *) &_v, sizeof(_v)); \ }) void __printb(void *value, size_t size) { uint8_t byte; size_t blen = sizeof(byte) * 8; uint8_t bits[blen + 1]; bits[blen] = for_endian(size) { byte = ((uint8_t *) value)[i]; memset(bits, for (int j = 0; byte && j < blen; ++j) { if (byte & 0x80) bits[j] = byte <<= 1; } printf("%s ", bits); } printf("\n"); } int main(void) { uint8_t c1 = 0xff, c2 = 0x44; uint8_t c3 = c1 + c2; printb(c1); printb((char) 0xff); printb((short) 0xff); printb(0xff); printb(c2); printb(0x44); printb(0x4411ff01); printb((uint16_t) c3); printf("\n"); return 0; }
long unsigned int i; for(i = 0u; i < sizeof(integer) * CHAR_BIT; i++) { if(integer & LONG_MIN) printf("1"); else printf("0"); integer <<= 1; } printf("\n");
(((i) & 0x80ll) ? (((i) & 0x40ll) ? (((i) & 0x20ll) ? (((i) & 0x10ll) ? (((i) & 0x08ll) ? (((i) & 0x04ll) ? (((i) & 0x02ll) ? (((i) & 0x01ll) ? PRINTF_BINARY_PATTERN_INT8 PRINTF_BINARY_SEPARATOR PRINTF_BINARY_PATTERN_INT8 PRINTF_BYTE_TO_BINARY_INT8((i) >> 8), PRINTF_BYTE_TO_BINARY_INT8(i) PRINTF_BINARY_PATTERN_INT16 PRINTF_BINARY_SEPARATOR PRINTF_BINARY_PATTERN_INT16 PRINTF_BYTE_TO_BINARY_INT16((i) >> 16), PRINTF_BYTE_TO_BINARY_INT16(i) PRINTF_BINARY_PATTERN_INT32 PRINTF_BINARY_SEPARATOR PRINTF_BINARY_PATTERN_INT32 PRINTF_BYTE_TO_BINARY_INT32((i) >> 32), PRINTF_BYTE_TO_BINARY_INT32(i) int main() { long long int flag = 1648646756487983144ll; printf("My Flag " PRINTF_BINARY_PATTERN_INT64 "\n", PRINTF_BYTE_TO_BINARY_INT64(flag)); return 0; }
My Flag 0001011011100001001010110111110101111000100100001111000000101000
My Flag 00010110,11100001,00101011,01111101,01111000,10010000,11110000,00101000
My Flag 00010110 11100001 00101011 01111101 01111000 10010000 11110000 00101000
void print_ulong_bin(const unsigned long * const var, int bits) { int i; if( (bits > 64) || (bits <= 0) ) if( (bits > 32) || (bits <= 0) ) return; for(i = 0; i < bits; i++) { printf("%lu", (*var >> (bits - 1 - i)) & 0x01); } }
char *int2bin(int num, int pad) { char *str = malloc(sizeof(char) * (pad+1)); if (str) { str[pad]= while (--pad>=0) { str[pad] = num & 1 ? num >>= 1; } } else { return ""; } return str; } printf("The number 5 in binary is %s", int2bin(5, 4));
using namespace std; template<class T> string binary_text(T dec, string byte_separator = " ") { char* pch = (char*)&dec; string res; for (int i = 0; i < sizeof(T); i++) { for (int j = 1; j < 8; j++) { res.append(pch[i] & 1 ? "1" : "0"); pch[i] /= 2; } res.append(byte_separator); } return res; } int main() { cout << binary_text(5) << endl; cout << binary_text(.1) << endl; return 0; }
template<class T> inline std::string format_binary(T x) { char b[sizeof(T)*8+1] = {0}; for (size_t z = 0; z < sizeof(T)*8; z++) b[sizeof(T)*8-1-z] = ((x>>z) & 0x1) ? return std::string(b); }
unsigned int value32 = 0x1e127ad; printf( " 0x%x: %s\n", value32, format_binary(value32).c_str() ); unsigned long long value64 = 0x2e0b04ce0; printf( "0x%llx: %s\n", value64, format_binary(value64).c_str() );
0x1e127ad: 00000001111000010010011110101101 0x2e0b04ce0: 0000000000000000000000000000001011100000101100000100110011100000
void print_binary(unsigned char c) { unsigned char i1 = (1 << (sizeof(c)*8-1)); for(; i1; i1 >>= 1) printf("%d",(c&i1)!=0); } void get_binary(unsigned char c, unsigned char bin[]) { unsigned char i1 = (1 << (sizeof(c)*8-1)), i2=0; for(; i1; i1>>=1, i2++) bin[i2] = ((c&i1)!=0); }
void printb(unsigned int v) { unsigned int i, s = 1<<((sizeof(v)<<3)-1); for (i = s; i; i>>=1) printf("%d", v & i || 0 ); }
void printStringAsBinary(char * input) { char * temp = input; int i = 7, j =0;; int inputLen = strlen(input); /* Go over the string, check first bit..bit by bit and print 1 or 0 **/ for (j = 0; j < inputLen; j++) { printf("\n"); while (i>=0) { if (*temp & (1 << i)) { printf("1"); } else { printf("0"); } i--; } temp = temp+1; i = 7; printf("\n"); } }
int exists(const char *fname) { FILE *file; if ((file = fopen(fname, "r"))) { fclose(file); return 1; } return 0; }
int file_exist (char *filename) { struct stat buffer; return (stat (filename, &buffer) == 0); }
if (file_exist ("myfile.txt")) { printf ("It exists\n"); }
fd = open(pathname, O_CREAT | O_WRONLY | O_EXCL, S_IRUSR | S_IWUSR); if (fd < 0) { if (errno == EEXIST) { ... } } else { }
FILE *file; if((file = fopen("sample.txt","r"))!=NULL) { fclose(file); } else { }
/* ACCESS.C: This example uses _access to check the * file named "ACCESS.C" to see if it exists and if * writing is allowed. */ void main( void ) { if( (_access( "ACCESS.C", 0 )) != -1 ) { printf( "File ACCESS.C exists\n" ); if( (_access( "ACCESS.C", 2 )) != -1 ) printf( "File ACCESS.C has write permission\n" ); } }
void fileCheck(const char *fileName); int main (void) { char *fileName = "/etc/sudoers"; fileCheck(fileName); return 0; } void fileCheck(const char *fileName){ if(!access(fileName, F_OK )){ printf("The File %s\t was Found\n",fileName); }else{ printf("The File %s\t not Found\n",fileName); } if(!access(fileName, R_OK )){ printf("The File %s\t can be read\n",fileName); }else{ printf("The File %s\t cannot be read\n",fileName); } if(!access( fileName, W_OK )){ printf("The File %s\t it can be Edited\n",fileName); }else{ printf("The File %s\t it cannot be Edited\n",fileName); } if(!access( fileName, X_OK )){ printf("The File %s\t is an Executable\n",fileName); }else{ printf("The File %s\t is not an Executable\n",fileName); } }
The File /etc/sudoers was Found The File /etc/sudoers cannot be read The File /etc/sudoers it cannot be Edited The File /etc/sudoers is not an Executable
resolved_file = realpath(file_path, NULL); if (!resolved_keyfile) { perror(keyfile); return -1; }
typedef struct { int command; int data; int isbusy; } MyHardwareGadget;
void SendCommand (MyHardwareGadget * gadget, int command, int data) { while (gadget->isbusy) { } gadget->data = data; gadget->command = command; }
void SendCommand (volatile MyHardwareGadget * gadget, int command, int data) { while (gadget->isbusy) { } gadget->data = data; gadget->command = command; }
bool usb_interface_flag = 0; while(usb_interface_flag == 0) { }
double der_f(double x) { static const double h = 1e-3; return (f(x + h) - f(x)) / h; }
double der_f2(double x) { static const double h = 1e-3; double hh = x + h - x; return (f(x + hh) - f(x)) / hh; }
void SendCommand (volatile MyHardwareGadget * gadget, int command, int data) { while (gadget->isbusy) { } gadget->data = data; gadget->command = command; }
void DoSomething() { wchar_t* pStr = alloca(100); }
void Process() { for (i = 0; i < 1000000; i++) { DoSomething(); } }
struct Base { virtual ~Base() { } virtual int to_int() const = 0; }; struct Integer : Base { Integer(int n) : n_(n) { } int to_int() const { return n_; } int n_; }; struct Double : Base { Double(double n) : n_(n) { } int to_int() const { return -n_; } double n_; }; inline Base* factory(double d) __attribute__((always_inline)); inline Base* factory(double d) { if ((double)(int)d != d) return new (alloca(sizeof(Double))) Double(d); else return new (alloca(sizeof(Integer))) Integer(d); } int main() { std::vector<Base*> numbers; numbers.push_back(factory(29.3)); numbers.push_back(factory(29)); numbers.push_back(factory(7.1)); numbers.push_back(factory(2)); numbers.push_back(factory(231.0)); for (std::vector<Base*>::const_iterator i = numbers.begin(); i != numbers.end(); ++i) { std::cout << *i << (*i)->~Base(); } }
char x; char *y=malloc(1); char *z=alloca(&x-y); *z = 1;
void f() { char array_on_stack[ MAX_BYTES_TO_ALLOCATE ]; SomeType *p = (SomeType *)array; (...) }
void foo() { int x = 50000; char array[x]; char *parray = (char *)alloca(x); }
while (condition) { char* buffer = _alloca(0x100); }
typedef struct { int x, y; } Point; Point point_new(int x, int y) { Point a; a.x = x; a.y = y; return a; }
typedef struct Point Point; Point * point_new(int x, int y);
struct Point { int x, y; }; Point * point_new(int x, int y) { Point *p; if((p = malloc(sizeof *p)) != NULL) { p->x = x; p->y = y; } return p; }
struct foo *foo; printf("foo->bar = %p", foo->bar);
struct elem { int i; char k; }; elem user; struct elem user;
enum EnumDef { FIRST_ITEM, SECOND_ITEM }; struct StructDef { enum EnuumDef MyEnum; unsigned int MyVar; } MyStruct;
typedef { FIRST_ITEM, SECOND_ITEM } EnumDef; typedef struct { EnuumDef MyEnum; /* compiler error (unknown type) */ unsigned int MyVar; } StructDef; StrructDef MyStruct; /* compiler error (unknown type) */
Type_ptr var1, var2; struct Tag *myTagType1, myTagType2;
typedef struct MyWriter_t{ MyPipe super; MyQueue relative; uint32_t flags; ... }MyWriter;
void my_writer_func(MyPipe *s) { MyWriter *self = (MyWriter *) s; uint32_t myFlags = self->flags; ... }
struct point { int x, y; } first_point, second_point;
struct point { int x, y; }; struct point first_point, second_point;
typedef struct point { int x, y; } Points; Points first_point, second_point;
struct MyStruct { int i; }; MyStruct obj; obj.i = 7;
struct bar; struct foo; struct foo { struct bar *b; }; struct bar { struct foo *f; };
typedef struct foo foo_t; typedef struct bar bar_t;
struct complex{ int real_part, img_part }COMPLEX; main(){ struct KOMPLEKS number; number.real_part = 3; number.img_part = -1; printf("Number: %d.%d i \n",number.real_part, number.img_part); }
typedef struct complex{int real_part, img_part; }COMPLEX; main(){ COMPLEX number; number.real_part = 1; number.img)part = 5; printf("%d %d \n", number.real_part, number.img_part); }
struct a { int i; }; struct b { struct a; int i; int j; };
extern int UIApplicationMain(int, ...); int main(int argc, char *argv[]) { id autoreleasePool = objc_msgSend(objc_msgSend(objc_getClass("NSAutoreleasePool"), sel_registerName("alloc")), sel_registerName("init")); UIApplicationMain(argc, argv, nil, CFSTR("AppDelegate")); objc_msgSend(autoreleasePool, sel_registerName("drain")); }
struct AppDel { Class isa; id window; }; Class AppDelClass; BOOL AppDel_didFinishLaunching(struct AppDel *self, SEL _cmd, void *application, void *options) { self->window = objc_msgSend(objc_getClass("UIWindow"), sel_getUid("alloc")); self->window = objc_msgSend(self->window, sel_getUid("initWithFrame:"), (struct CGRect) { 0, 0, 320, 480 }); id viewController = objc_msgSend(objc_msgSend(objc_getClass("UIViewController"), sel_getUid("alloc")), sel_getUid("init")); id view = objc_msgSend(objc_msgSend(objc_getClass("View"), sel_getUid("alloc")), sel_getUid("initWithFrame:"), (struct CGRect) { 0, 0, 320, 480 }); objc_msgSend(objc_msgSend(viewController, sel_getUid("view")), sel_getUid("addSubview:"), view); objc_msgSend(self->window, sel_getUid("setRootViewController:"), viewController); objc_msgSend(self->window, sel_getUid("makeKeyAndVisible")); return YES; } __attribute__((constructor)) static void initAppDel() { AppDelClass = objc_allocateClassPair(objc_getClass("UIResponder"), "AppDelegate", 0); class_addIvar(AppDelClass, "window", sizeof(id), 0, "@"); class_addMethod(AppDelClass, sel_getUid("application:didFinishLaunchingWithOptions:"), (IMP) AppDel_didFinishLaunching, "i@:@@"); objc_registerClassPair(AppDelClass); }
Class ViewClass; void View_drawRect(id self, SEL _cmd, struct CGRect rect) { CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColor(context, (CGFloat []){ 1, 1, 1, 1 }); CGContextAddRect(context, (struct CGRect) { 0, 0, 320, 480 }); CGContextFillPath(context); CGContextSetFillColor(context, (CGFloat []) { 1, 0, 0, 1 }); CGContextAddRect(context, (struct CGRect) { 10, 10, 20, 20 }); CGContextFillPath(context); } __attribute__((constructor)) static void initView() { ViewClass = objc_allocateClassPair(objc_getClass("UIView"), "View", 0); class_addMethod(ViewClass, sel_getUid("drawRect:"), (IMP) View_drawRect, "v@:"); objc_registerClassPair(ViewClass); }
extern id NSApp; struct AppDel { Class isa; id window; }; Class AppDelClass; BOOL AppDel_didFinishLaunching(struct AppDel *self, SEL _cmd, id notification) { self->window = objc_msgSend(objc_getClass("NSWindow"), sel_getUid("alloc")); self->window = objc_msgSend(self->window, sel_getUid("initWithContentRect:styleMask:backing:defer:"),(NSRect){0,0,1024,460}, (NSTitledWindowMask|NSClosableWindowMask|NSResizableWindowMask|NSMiniaturizableWindowMask),NSBackingStoreRetained,NO); id view = objc_msgSend(objc_msgSend(objc_getClass("View"), sel_getUid("alloc")), sel_getUid("initWithFrame:"), (struct CGRect) { 0, 0, 320, 480 }); objc_msgSend(self->window, sel_getUid("setContentView:"), view); objc_msgSend(self->window, sel_getUid("becomeFirstResponder")); objc_msgSend(self->window, sel_getUid("makeKeyAndOrderFront:"), self); return YES; } static void initAppDel() { AppDelClass = objc_allocateClassPair((Class) objc_getClass("NSObject"), "AppDelegate", 0); class_addMethod(AppDelClass, sel_getUid("applicationDidFinishLaunching:"), (IMP) AppDel_didFinishLaunching, "i@:@"); objc_registerClassPair(AppDelClass); } void init_app(void) { objc_msgSend( objc_getClass("NSApplication"), sel_getUid("sharedApplication")); if (NSApp == NULL) { fprintf(stderr,"Failed to initialized NSApplication... terminating...\n"); return; } id appDelObj = objc_msgSend( objc_getClass("AppDelegate"), sel_getUid("alloc")); appDelObj = objc_msgSend(appDelObj, sel_getUid("init")); objc_msgSend(NSApp, sel_getUid("setDelegate:"), appDelObj); objc_msgSend(NSApp, sel_getUid("run")); } int main(int argc, char** argv) { initAppDel(); init_app(); return EXIT_SUCCESS; }
Class ViewClass; void View_drawRect(id self, SEL _cmd, CGRect rect) { id red = objc_msgSend(objc_getClass("NSColor"), sel_getUid("redColor")); NSRect rect1 = NSMakeRect ( 21,21,210,210 ); objc_msgSend(red, sel_getUid("set")); NSRectFill ( rect1 ); } __attribute__((constructor)) static void initView() { ViewClass = objc_allocateClassPair((Class) objc_getClass("NSView"), "View", 0); class_addMethod(ViewClass, sel_getUid("drawRect:"), (IMP) View_drawRect, "v@:"); objc_registerClassPair(ViewClass); }
- (void) drawRect:(CGRect)dirtyRect { CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0); CGContextFillRect(context, dirtyRect); }
fseek(f, 0, SEEK_END); size = ftell(f); fseek(f, 0, SEEK_SET);
struct stat st; stat(filename, &st); size = st.st_size;
struct stat buf; fstat(fd, &buf); off_t size = buf.st_size;
int fsize(FILE *fp){ int prev=ftell(fp); fseek(fp, 0L, SEEK_END); int sz=ftell(fp); fseek(fp,prev,SEEK_SET); return sz; }
/* Read the contents of a file into a buffer. Return the size of the file * and set buf to point to a buffer allocated with malloc that contains * the file contents. */ int read_file(FILE *fp, char **buf) { int n, np; char *b, *b2; n = CHUNK; np = n; b = malloc(sizeof(char)*n); while ((r = fread(b, sizeof(char), CHUNK, fp)) > 0) { n += r; if (np - n < CHUNK) { np *= 2; b2 = malloc(np*sizeof(char)); memcpy(b2, b, n * sizeof(char)); free(b); b = b2; } } *buf = b; return n; }
void fseek_filesize(const char *filename) { FILE *fp = NULL; long off; fp = fopen(filename, "r"); if (fp == NULL) { printf("failed to fopen %s\n", filename); exit(EXIT_FAILURE); } if (fseek(fp, 0, SEEK_END) == -1) { printf("failed to fseek %s\n", filename); exit(EXIT_FAILURE); } off = ftell(fp); if (off == (long)-1) { printf("failed to ftell %s\n", filename); exit(EXIT_FAILURE); } printf("[*] fseek_filesize - file: %s, size: %ld\n", filename, off); if (fclose(fp) != 0) { printf("failed to fclose %s\n", filename); exit(EXIT_FAILURE); } } void fstat_filesize(const char *filename) { int fd; struct stat statbuf; fd = open(filename, O_RDONLY, S_IRUSR | S_IRGRP); if (fd == -1) { printf("failed to open %s\n", filename); exit(EXIT_FAILURE); } if (fstat(fd, &statbuf) == -1) { printf("failed to fstat %s\n", filename); exit(EXIT_FAILURE); } printf("[*] fstat_filesize - file: %s, size: %lld\n", filename, statbuf.st_size); if (close(fd) == -1) { printf("failed to fclose %s\n", filename); exit(EXIT_FAILURE); } } void stat_filesize(const char *filename) { struct stat statbuf; if (stat(filename, &statbuf) == -1) { printf("failed to stat %s\n", filename); exit(EXIT_FAILURE); } printf("[*] stat_filesize - file: %s, size: %lld\n", filename, statbuf.st_size); } void seek_filesize(const char *filename) { int fd; off_t off; if (filename == NULL) { printf("invalid filename\n"); exit(EXIT_FAILURE); } fd = open(filename, O_RDONLY, S_IRUSR | S_IRGRP); if (fd == -1) { printf("failed to open %s\n", filename); exit(EXIT_FAILURE); } off = lseek(fd, 0, SEEK_END); if (off == (off_t)-1) { printf("failed to lseek %s\n", filename); exit(EXIT_FAILURE); } printf("[*] seek_filesize - file: %s, size: %lld\n", filename, off); if (close(fd) == -1) { printf("failed to close %s\n", filename); exit(EXIT_FAILURE); } } int main(int argc, const char *argv[]) { int i; if (argc < 2) { printf("%s <file1> <file2>...\n", argv[0]); exit(0); } for(i = 1; i < argc; i++) { seek_filesize(argv[i]); stat_filesize(argv[i]); fstat_filesize(argv[i]); fseek_filesize(argv[i]); } return 0; }
int main() { int i; char a[MAXNUMBER]; FILE *fp = popen("du -b /bin/bash", "r"); while((a[i++] = getc(fp))!= 9) ; a[i] = printf(" a is %s\n", a); pclose(fp); return 0; }
static int bool_arginfo(const struct printf_info *info, size_t n, int *argtypes, int *size) { if (n) { argtypes[0] = PA_INT; *size = sizeof(bool); } return 1; } static int bool_printf(FILE *stream, const struct printf_info *info, const void *const *args) { bool b = *(const bool*)(args[0]); int r = fputs(b ? "true" : "false", stream); return r == EOF ? -1 : (b ? 4 : 5); } static int setup_bool_specifier() { int r = register_printf_specifier( return r; } int main(int argc, char **argv) { int r = setup_bool_specifier(); if (r) return 1; bool b = argc > 1; r = printf("The result is: %B\n", b); printf("(written %d characters)\n", r); return 0; }
int flags = MY_FLAG; printf("%d\n", !!(flags & MY_FLAG));
bool b = IsSomethingTrue(); std::cout << std::boolalpha << b;
main () { int i,j; static int x[4000][4000]; for (i = 0; i < 4000; i++) { for (j = 0; j < 4000; j++) { x[j][i] = i + j; } } }
main () { int i,j; static int x[4000][4000]; for (j = 0; j < 4000; j++) { for (i = 0; i < 4000; i++) { x[j][i] = i + j; } } }
0,0 | 0,1 | 0,2 | 0,3 ----+-----+-----+---- 1,0 | 1,1 | 1,2 | 1,3 ----+-----+-----+---- 2,0 | 2,1 | 2,2 | 2,3
0,0 | 0,1 | 0,2 | 0,3 | 1,0 | 1,1 | 1,2 | 1,3 | 2,0 | 2,1 | 2,2 | 2,3
0,0 | 1,0 | 2,0 | 0,1 | 1,1 | 2,1 | 0,2 | 1,2 | 2,2 | 0,3 | 1,3 | 2,3
for (j=0; j<4000; j++) { int *p = x[j]; for (i=0; i<4000; i++) { *p++ = i+j; } }
typedef struct { size_t numElements int elements[1]; } IntArray_t; IntArray_t* myArray = malloc(sizeof(intArray_t) + SIZE * sizeof(int)); myArray->numElements = SIZE;
void format_string(char *fmt, ...); void debug_print(int dbg_lvl, char *fmt, ...) { format_string(fmt, ); fprintf(stdout, fmt); }
void format_string(char *fmt,va_list argptr, char *formatted_string); void debug_print(int dbg_lvl, char *fmt, ...) { char formatted_string[MAX_FMT_SIZE]; va_list argptr; va_start(argptr,fmt); format_string(fmt, argptr, formatted_string); va_end(argptr); fprintf(stdout, "%s",formatted_string); }
void func(type* values) { while(*values) { x = *values++; } } func((type[]){val1,val2,val3,val4,0});
template <typename ... Ts> void format_string(char *fmt, Ts ... ts) {} template <typename ... Ts> void debug_print(int dbg_lvl, char *fmt, Ts ... ts) { format_string(fmt, ts...); }
void format_string(char *fmt, ...); void debug_print(int dbg_level, int numOfArgs, char *fmt, ...) { va_list argumentsToPass; va_start(argumentsToPass, fmt); char *list = new char[numOfArgs]; for(int n = 0; n < numOfArgs; n++) list[n] = va_arg(argumentsToPass, char); va_end(argumentsToPass); for(int n = numOfArgs - 1; n >= 0; n--) { char next; next = list[n]; __asm push next; } __asm push fmt; __asm call format_string; fprintf(stdout, fmt); }
void print(char const* fmt, ...) { va_list arg; va_start(arg, fmt); vprintf(fmt, arg); va_end(arg); } void printFormatted(char const* fmt, va_list arg) { vprintf(fmt, arg); } void showLog(int mdl, char const* type, ...) { print("\nMDL: %d, TYPE: %s", mdl, type); va_list arg; va_start(arg, type); char const* fmt = va_arg(arg, char const*); printFormatted(fmt, arg); va_end(arg); } int main() { int x = 3, y = 6; showLog(1, "INF, ", "Value = %d, %d Looks Good! %s", x, y, "Infact Awesome!!"); showLog(1, "ERR"); }
DEBUG(WHERESTR _fmt, WHEREARG,__VA_ARGS__) int main() { int x=10; DEBUG_PRINT(DBG, "i am x %d\n", x); return 0; }
((void)__android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__))
void inner_func(int &i) { va_list vars; va_start(vars, i); int j = va_arg(vars); va_end(vars); } void func(int i, ...) { inner_func(i); }
size_t x = <something>; printf( "size = %u\n", x ); warning: format but argument 2 has type
size_t x = ...; ssize_t y = ...; printf("%zu\n", x); printf("%zx\n", x); printf("%zd\n", y);
size_t foo; ... printf("foo = %lu\n", (unsigned long) foo);
int main() { size_t x = 1; SSIZE_T y = 2; printf("%zu\n", x); printf("%zx\n", x); printf("%zd\n", y); return 0; }
C11 - <stdalign.h> C11 - <stdatomic.h> C11 - <stdnoreturn.h> C99 - <tgmath.h> C11 - <threads.h>
std::cout << boost::format("Sizeof(Var) is %d\n") % sizeof(Var);
char text[] = "Lets go fishing in stead of sitting on our but !!"; size_t line = 2337200120702199116; printf("number: %I64d\n",*(size_t*)&text); printf("text: %s\n",*(char(*)[])&line);
int main() { unsigned long long int num = 285212672; int normalInt = 5; printf("My number is %d bytes wide and its value is %ul. A normal number is %d.\n", sizeof(num), num, normalInt); return 0; }
My number is 8 bytes wide and its value is 285212672l. A normal number is 0.
uint64_t x; uint32_t y; printf("x: %"PRId64", y: %"PRId32"\n", x, y);
__int64 a; time_t b; ... fprintf(outFile,"%I64d,%I64d\n",a,b);
int main() { unsigned long long int num = 285212672; int normalInt = 5; printf("My number is %d bytes wide and its value is %" PRIu64 ". A normal number is %d.\n", sizeof(num), num, normalInt); return 0; }
My number is 8 bytes wide and its value is 285212672. A normal number is 5.
int normalInt = 5; unsigned long long int num=285212672; printf( "My number is %d bytes wide and its value is %ul. A normal number is %d \n", sizeof(num), num, normalInt);
int normalInt = 5; unsigned __int64 num=285212672; printf( "My number is %d bytes wide and its value is %I64u. A normal number is %d", sizeof(num), num, normalInt);
bool f1() { int var1 = 1000; int var2 = 2000; int var3 = var1 + var2; return (var3 == 0) ? true : false; }
int main() { printf( f1() == true ? "true\n" : "false\n"); if( f1() ) { printf("executed\n"); } return 0; }
gcc -Wall -Wextra -Werror -std=gnu99 -o main.exe main.c
main.c: In function main.c:14:5: error: implicit declaration of function icit-function-declaration] printf( f1() == true ? "true\n" : "false\n"); ^ cc1.exe: all warnings being treated as errors
void RDP_G_SETFOGCOLOR(void) { Gfx.FogColor.R = _SHIFTR(w1, 24, 8) * 0.0039215689f; Gfx.FogColor.G = _SHIFTR(w1, 16, 8) * 0.0039215689f; Gfx.FogColor.B = _SHIFTR(w1, 8, 8) * 0.0039215689f; Gfx.FogColor.A = _SHIFTR(w1, 0, 8) * 0.0039215689f; } void RDP_G_SETBLENDCOLOR(void) { Gfx.BlendColor.R = _SHIFTR(w1, 24, 8) * 0.0039215689f; Gfx.BlendColor.G = _SHIFTR(w1, 16, 8) * 0.0039215689f; Gfx.BlendColor.B = _SHIFTR(w1, 8, 8) * 0.0039215689f; Gfx.BlendColor.A = _SHIFTR(w1, 0, 8) * 0.0039215689f; if(OpenGL.Ext_FragmentProgram && (System.Options & BRDP_COMBINER)) { glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 2, Gfx.BlendColor.R, Gfx.BlendColor.G, Gfx.BlendColor.B, Gfx.BlendColor.A); } }
for (i = 0; i < 100; i++) { printf("%d\n", rand()); }
for (i = 0; i < 100; i++) { printf("%d = %d\n", rand(), (rand() + rand())); }
int rnum; for (rnum = rand(); rnum == 0; rnum = rand()) {}
int main(void) { int i=0; for (i=0; i<100; i++) printf(" %d : %d \n", rand(), ((rand() % (INT_MAX/2))+(rand() % (INT_MAX/2)))); for (i=0; i<100; i++) printf(" %d : %ld \n", rand(), ((rand() % (LONG_MAX/2))+(rand() % (LONG_MAX/2)))); return 0; }
void *PrintHello(void *threadid) { long tid; tid = (long)threadid; printf("Hello World! It pthread_exit(NULL); } int main (int argc, char *argv[]) { pthread_t threads[NUM_THREADS]; int rc; long t; for(t=0; t<NUM_THREADS; t++){ printf("In main: creating thread %ld\n", t); rc = pthread_create(&threads[t], NULL, PrintHello, (void *)t); if (rc){ printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); } } pthread_exit(NULL); }
corey@ubuntu:~/demo$ gcc -o term term.c term.c: In function ‘main’: term.c:23: warning: incompatible implicit declaration of built-in function ‘exit’ /tmp/cc8BMzwx.o: In function `main term.c:(.text+0x82): undefined reference to `pthread_create' collect2: ld returned 1 exit status
1.......2.......3.......4.......5.......6.......7.......8.......
12345678........................................................
000000a00b000000 00000000a00b0000 + ---------------- 000000a0ab0b0000 xxxxxxxxab......
00000000a00b00c00 000000a00b00c0000 0000a00b00c000000 ----------------- 0000a0ababcbc0c00 xxxxxxxxabc......
a: << 0 ( x 1 ) b: << 5 ( x 32 ) c: << 11 ( x 2048 ) d: << 5 ( x 32 ) !! duplicate e: << 0 ( x 1 ) !! duplicate
ABCDEFGHIJKLMNOP a000e0b000d00c00 0b000d00c0000000 000d00c000000000 00c0000000000000 + ---------------- abcded(b+c)0c0d00c00
Q0 > 1 Q0 == 1 && Q1 >= 2 Q0 == 0 && Q1 >= 4 Q0 == 1 && Q1 > 1 && Q2 >=2 ...
(set-logic BV) (declare-const mask (_ BitVec 64)) (declare-const multiplicand (_ BitVec 64)) (assert (forall ((x (_ BitVec 64))) (let ((y (bvmul (bvand mask x) multiplicand))) (and (= ((_ extract 63 63) x) ((_ extract 63 63) y)) (= ((_ extract 55 55) x) ((_ extract 62 62) y)) (= ((_ extract 47 47) x) ((_ extract 61 61) y)) (= ((_ extract 39 39) x) ((_ extract 60 60) y)) (= ((_ extract 31 31) x) ((_ extract 59 59) y)) (= ((_ extract 23 23) x) ((_ extract 58 58) y)) (= ((_ extract 15 15) x) ((_ extract 57 57) y)) (= ((_ extract 7 7) x) ((_ extract 56 56) y)) ) ) ) ) (check-sat) (get-model)
z3.exe /m /smt2 ExtractBitsThroughAndWithMultiplication.smt2
sat (model (define-fun mask () (_ BitVec 64) (define-fun multiplicand () (_ BitVec 64) )
a000b00c000d + 0b00c000d000 + 00c000d00000 + 000d00000000 = abcdX.......
+ a0000b00c000d00 + 0b00c000d000000 + 00c000d00000000 + 000d00000000000 = abcd...0X......
int main() { unsigned long long d; scanf("%llu",&d); printf("%llu",d); getch(); }
const char *sql_query = "SELECT statuses.word_id FROM lang1_words, statuses WHERE statuses.word_id = lang1_words.word_id ORDER BY lang1_words.word ASC";
const char *sql_query = "SELECT word_id FROM table1, table2 WHERE table2.word_id = table1.word_id ORDER BY table1.word ASC";
const char *sql_query = QUOTE( SELECT word_id FROM table1, table2 WHERE table2.word_id = table1.word_id ORDER BY table1.word ASC );
const char *sql_query = "SELECT word_id FROM table1, table2 WHERE table2.word_id = table1.word_id ORDER BY table1.word ASC";
if (you && short on windows) { then your code will end up squished against th e side li k e t h i s }
NSString *sql = NSStringMultiline( SELECT name, age FROM users WHERE loggedin = true );
const char *sql_query = R"(SELECT word_id FROM table1, table2 WHERE table2.word_id = table1.word_id ORDER BY table1.word ASC)";
const char *sql_query = R"T3RM!N8( SELECT word_id FROM table1, table2 WHERE table2.word_id = table1.word_id ORDER BY table1.word ASC )T3RM!N8";
NSString * query = @"SELECT * FROM foo " @"WHERE " @"bar = 42 " @"AND baz = datetime() " @"ORDER BY fizbit ASC";
int main() { int a[2]={ 10, 1 }; while( a[ 0xFULL? printf("?"); return 0; }
01010 >> 1 == 00101 00101 >> 1 == 00010 00010 >> 1 == 00001 00001 >> 1 == 00000
all:ll ll:ll.c gcc -c -Wall -Werror -02 c.c ll.c -o ll $@ $< clean : \rm -fr ll
Kaizen ~/so_test $ cat -e -t -v mk.t all:ll$ $ ll:ll.c $ ^Igcc -c -Wall -Werror -02 c.c ll.c -o ll $@ $<$ $ clean :$ \rm -fr ll$
%-linux: force$ ^I@if [ "$(GCC_VERSION)" = "2.96" ] ; then \$ ^I^Iecho ===== Generating build tree for legacy $@ architecture =====; \$ ^I^I$(CONFIGURE) $(CWD) $@ legacy; \$ ^Ielse \$ ^I^Iecho ===== Generating build tree for $@ architecture =====; \$ ^I^I$(CONFIGURE) $(CWD) $@; \$ ^Ifi$ ^Icd build-$@;make$
std::string getFmt ( int wid, long val ) { char buf[64]; sprintf ( buf, "% *ld", wid, val ); return buf; } printf ( " COUNT USED FREE\n" ); printf ( "A: %s %s %s\n", FMT(C[0]), FMT(U[0]), FMT(F[0]) ); printf ( "B: %s %s %s\n", FMT(C[1]), FMT(U[1]), FMT(F[1]) ); printf ( "C: %s %s %s\n", FMT(C[2]), FMT(U[2]), FMT(F[2]) ); COUNT USED FREE A: 354 148523 3283 B: 54138259 12392759 200391 C: 91239 3281 61423
do { if (error) { break; } if (error) { break; } } while (0);
do { \ sprintf(str, "%s: " fmt, "myprog", } while (0) ({ \ sprintf(str, "%s: " fmt, "myprog", }) int main() { char buf[1000]; int n = 0; log_to_string1(buf, "%s\n", "No assignment, OK"); n += log_to_string1(buf + n, "%s\n", "NOT OK: gcc: error: expected expression before n += log_to_string2(buf + n, "%s\n", "This fixes it"); n += log_to_string2(buf + n, "%s\n", "Assignment worked!"); printf("%s", buf); return 0; }
do { char c = read_input(); process_input(c); } while (c !=
> ldd /bin/ls ... libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f3927b1d000) libacl.so.1 => /lib/x86_64-linux-gnu/libacl.so.1 (0x00007f3927914000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f392754f000) libpcre.so.3 => /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f3927311000) libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f392710c000) /lib64/ld-linux-x86-64.so.2 (0x00007f3927d65000) libattr.so.1 => /lib/x86_64-linux-gnu/libattr.so.1 (0x00007f3926f07000)
>ldd /bin/ls ... libselinux.so.1 => /home/patric/libselinux.so.1 (0x00007fb9245d8000) ...
message = strcat("TEXT ", var); message2 = strcat(strcat("TEXT ", foo), strcat(" TEXT ", bar));
char str[80]; strcpy(str, "these "); strcat(str, "strings "); strcat(str, "are "); strcat(str, "concatenated.");
char *foo = "foo"; char *bar = "bar"; char str[80]; strcpy(str, "TEXT "); strcat(str, foo); strcat(str, bar);
char buf[256]; snprintf(buf, sizeof buf, "%s%s%s%s", str1, str2, str3, str4);
void example(const char *header, const char **words, size_t num_words) { size_t message_len = strlen(header) + 1; char *message = (char*) malloc(message_len); strncat(message, header, message_len); for(int i = 0; i < num_words; ++i) { message_len += 1 + strlen(words[i]); message = (char*) realloc(message, message_len); strncat(strncat(message, ";", message_len), words[i], message_len); } puts(message); free(message); }
const char *table = SCHEMA "." TABLE ; const char *qry = " SELECT * " " FROM " SCHEMA "." TABLE " WHERE x = 1 " ;
char out[1024] = ""; strcat( out, null_terminated_string );
char bigEnough[64] = ""; strcat(bigEnough, "TEXT"); strcat(bigEnough, foo);
void appendToHello(const char *s) { const char *const hello = "hello "; const size_t sLength = strlen(s); const size_t helloLength = strlen(hello); const size_t totalLength = sLength + helloLength; char *const strBuf = malloc(totalLength + 1); if (strBuf == NULL) { fprintf(stderr, "malloc failed\n"); exit(EXIT_FAILURE); } strcpy(strBuf, hello); strcpy(strBuf + helloLength, s); puts(strBuf); free(strBuf); } int main (void) { appendToHello("blah blah"); return 0; }
char* concat(const char* str1, const char* str2) { char* result; asprintf(&result, "%s%s", str1, str2); return result; }
char message[1000]; strcpy (message, "TEXT "); strcat (message, var);
const static char TEXT[] = "TEXT "; char *message = malloc (sizeof(TEXT) + strlen(var) + 1); if (message == NULL) handleOutOfMemoryIntelligently(); strcpy (message, TEXT); strcat (message, var);
char *strcat_const(const char *str1,const char *str2){ static char buffer[MAX_STRING_LENGTH]; strncpy(buffer,str1,MAX_STRING_LENGTH); if(strlen(str1) < MAX_STRING_LENGTH){ strncat(buffer,str2,MAX_STRING_LENGTH - strlen(buffer)); } buffer[MAX_STRING_LENGTH - 1] = return buffer; } int main(int argc,char *argv[]){ printf("%s",strcat_const("Hello ","world")); return 0; }
char *bp=(char*)(buf+offset); \ const char *s, \ *a[] = { __VA_ARGS__,NULL}, \ **ss=a; \ while((s=*ss++)) \ while((*s)&&(++offset<(int)sizeof(buf))) \ *bp++=*s++; \ if (offset!=sizeof(buf))*bp=0; \ }while(0) char buf[256]; int len=0; strcpyALL(buf,len, "The config file is in:\n\t",getenv("HOME"),"/.config/",argv[0],"/config.rc\n" ); if (len<sizeof(buf)) write(1,buf,len); else write(2,"error\n",6); strcpyALL(buf,len,"Thanks for using ",argv[0],"!\n"); if (len<sizeof(buf)) write(1,buf,len); else write(2,"error\n",6);
int main() { char input[100]; gets(input); char str[101]; strcpy(str, " "); strcat(str, input); char *p = str; while(*p) { if(*p == printf("%c",*(p+1)); p++; } return 0; }
Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string.
message2 = strcat(strcat("TEXT ", foo), strcat(" TEXT ", bar));
char *strconcat(int num_args, ...) { int strsize = 0; va_list ap; va_start(ap, num_args); for (int i = 0; i < num_args; i++) strsize += strlen(va_arg(ap, char*)); char *res = malloc(strsize+1); strsize = 0; va_start(ap, num_args); for (int i = 0; i < num_args; i++) { char *s = va_arg(ap, char*); strcpy(res+strsize, s); strsize += strlen(s); } va_end(ap); res[strsize] = return res; }
char *str = strconcat(3, "testing ", "this ", "thing");
(gdb) bt (gdb) info locals No symbol table info available. (gdb) select-frame 5 (gdb) info locals i = 28 (gdb)
int main(int argc, char *argv[]) { argc = 6*7; return 0; }
char *strdup (const char *s) { char *d = malloc (strlen (s) + 1); if (d == NULL) return NULL; strcpy (d,s); return d; }
char * strdup(const char * s) { size_t len = 1+strlen(s); char *p = malloc(len); return p ? memcpy(p, s, len) : NULL; }
char *strdup (const char *s) { char *p = malloc (strlen (s) + 1); if (p != NULL) strcpy (p,s); return p; }
char *strdup(const char *str); char *strndup(const char *str, size_t len);
int main() { int days[] = {1,2,3,4,5}; int *ptr = days; printf("%u\n", sizeof(days)); printf("%u\n", sizeof(ptr)); return 0; }
int main() { int days[] = {1,2,3,4,5}; int *ptr = days; printf("%u\n", ARRAY_SIZE(days)); printf("%u\n", sizeof(ptr)); return 0; }
template<typename T, size_t SIZE> size_t getSize(T (&)[SIZE]) { return SIZE; }
template<typename T, size_t SIZE> size_t getSize(T (&)[SIZE]) { return SIZE; } struct foo_t { int ball; }; int main() { foo_t foos3[] = {{1},{2},{3}}; foo_t foos5[] = {{1},{2},{3},{4},{5}}; printf("%u\n", getSize(foos3)); printf("%u\n", getSize(foos5)); return 0; }
typedef int days_t[ NUM_DAYS ]; int main() { days_t days; days_t *ptr = &days; printf( "SIZEOF_DAYS: %u\n", SIZEOF_DAYS ); printf( "sizeof(days): %u\n", sizeof(days) ); printf( "sizeof(*ptr): %u\n", sizeof(*ptr) ); printf( "sizeof(ptr): %u\n", sizeof(ptr) ); return 0; }
SIZEOF_DAYS: 20 sizeof(days): 20 sizeof(*ptr): 20 sizeof(ptr): 4
void foo (int (*arr)[ARRAY_SZ]) { printf("%u\n", (unsigned)sizeof(*arr)/sizeof(**arr)); }
struct Array { int length; double *array; }; typedef struct Array Array; Array* NewArray(int length) { Array *newArray = (Array*) malloc(sizeof(Array)); newArray->length = (length > 0) ? length : 0; newArray->array = (double*) malloc(length*sizeof(double)); return newArray; } void SetArray(Array *structure,int length,double* array) { structure->length = length; structure->array = array; } void PrintArray(Array *structure) { if(structure->length > 0) { int i; printf("length: %d\n", structure->length); for (i = 0; i < structure->length; i++) printf("%g\n", structure->array[i]); } else printf("Empty Array. Length 0\n"); } int main() { int i; Array *negativeTest, *days = NewArray(5); double moreDays[] = {1,2,3,4,5,6,7,8,9,10}; for (i = 0; i < days->length; i++) days->array[i] = i+1; PrintArray(days); SetArray(days,10,moreDays); PrintArray(days); negativeTest = NewArray(-5); PrintArray(negativeTest); return 0; }
int main() { int days[] = {1,2,3,4,5}; int *ptr = days; printf("%u\n", sizeof(days)); printf("%u\n", sizeof(ptr)); return 0; }
int days[] = { 5, 1,2,3,4,5 }; int *ptr = days + 1; printf("array length: %u\n", ptr[-1]); return 0;
struct { int16 size; int16 array[array_size]; int16 property1[(array_size/16)+1] int16 property2[(array_size/16)+1] } array1 = {array_size, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
struct { int16 size; int16 array[array_size]; int16 property1[(array_size/16)+1] int16 property2[(array_size/16)+1] } array2 = {array_size};
void main() { int16 size = array1.size; for (int i=0; i!=size; i++) { array1.array[i] *= 2; } }
/* http: /* the following function will produce the warning: * ‘sizeof’ on array function parameter ‘a’ will * return size of ‘int *’ [-Wsizeof-array-argument] */ void foo( int a[] ) { printf( "%lu\n", sizeof a ); } /* so we have to implement something else one possible * idea is to use the NULL pointer as a control value * the same way * the pointer passed to a function should address pointers * so the actual implementation of an array type will * be a pointer to pointer */ typedef char * type_t; typedef type_t ** array_t; /* * -- -- * -**-**- * -$$$$$- * -999- * -^- * - */ int main( void ) { array_t initialize( int, ... ); /* initialize an array with four values "foo", "bar", "baz", "foobar" * if one wants to use integers rather than strings than in the typedef * declaration at line 18 the char * type should be changed with int * and in the format used for printing the array values * at line 45 and 51 "%s" should be changed with "%i" */ array_t array = initialize( 4, "foo", "bar", "baz", "foobar" ); int size( array_t ); printf( "size %i:\n", size( array )); void aprint( char *, array_t ); aprint( "%s\n", array ); type_t getval( array_t, int ); int i = 2; type_t val = getval( array, i ); printf( "%i: %s\n", i, val ); void delete( array_t ); delete( array ); return 0; } /* the output of the program should be: * size 4: * foo * bar * baz * foobar * 2: baz */ array_t initialize( int n, ... ) { type_t *v = (type_t *) malloc( sizeof( type_t ) * n ); va_list ap; va_start( ap, n ); int j; for ( j = 0; j < n; j++ ) v[j] = va_arg( ap, type_t ); va_end( ap ); /* the actual array will hold the addresses of those * values plus a NULL pointer */ array_t a = (array_t) malloc( sizeof( type_t *) * ( n + 1 )); a[n] = NULL; for ( j = 0; j < n; j++ ) a[j] = v + j; return a; } int size( array_t a ) { int n = 0; while ( *a++ != NULL ) n++; return n; } void aprint( char *fmt, array_t a ) { while ( *a != NULL ) printf( fmt, **a++ ); } type_t getval( array_t a, int i ) { return *a[i]; } void delete( array_t a ) { free( *a ); free( a ); }
if (!pointer) if (pointer == NULL) if (pointer == 0)
NULL - 0x00000000 or 0x00000000 NUL - 0x00 or 0x0000 (ascii vs 2byte unicode)
64-bit data models Data model short int long long long pointers Sample operating systems LLP64 16 32 32 64 64 Microsoft Win64 (X64/IA64) LP64 16 32 64 64 64 Most Unix and Unix-like systems (Solaris, Linux, etc.) ILP64 16 64 64 64 64 HAL SILP64 64 64 64 64 64 ?
The one "l" NUL ends an ASCII string, The two "l" NULL points to no thing. Apologies to Ogden Nash, but the three "l" nulll means check your spelling.
int main () { size_t ii; int *ptr = NULL; unsigned long *null_value = (unsigned long *)&ptr; if (NULL == 0) { printf ("NULL == 0\n"); } printf ("NULL = 0x"); for (ii = 0; ii < sizeof (ptr); ii++) { printf ("%02X", null_value[ii]); } printf ("\n"); return 0; }
0 int sys_open(const char *filename, int flags, int mode) { 1 char *tmp = getname(filename); 2 int fd = get_unused_fd(); 3 struct file *f = filp_open(tmp, flags, mode); 4 fd_install(fd, f); 5 putname(tmp); 6 return fd; 7 }
struct file *filp_open(const char *filename, int flags, int mode) { struct nameidata nd; open_namei(filename, flags, mode, &nd); return dentry_open(nd.dentry, nd.mnt, flags); }
enum {RANDOM, IMMEDIATE, SEARCH} strategy; strategy = IMMEDIATE;
error: conflicting types for ‘strategy’ error: previous declaration of ‘strategy’ was here
enum strategy {RANDOM, IMMEDIATE, SEARCH}; enum strategy my_strategy = IMMEDIATE;
typedef enum {RANDOM, IMMEDIATE, SEARCH} strategy; strategy my_strategy = IMMEDIATE;
typedef enum {RANDOM, IMMEDIATE, SEARCH} strategy_type; strategy_type my_strategy = IMMEDIATE;
enum strategy { RANDOM, IMMEDIATE, SEARCH }; enum strategy my_strategy = IMMEDIATE;
enum { RANDOM, IMMEDIATE, SEARCH } strategy = IMMEDIATE; int main(int argc, char** argv){ printf("strategy: %d\n", strategy); return 0; }
... enum { RANDOM, IMMEDIATE, SEARCH } strategy; strategy = IMMEDIATE; ...
enums.c:5:1: warning: data definition has no type or storage class [enabled by default] enums.c:5:1: warning: type defaults to ‘int’ in declaration of ‘strategy’ [-Wimplicit-int] enums.c:5:1: error: conflicting types for ‘strategy’ enums.c:4:36: note: previous declaration of ‘strategy’ was here
enum { RANDOM, IMMEDIATE, SEARCH } strategy = IMMEDIATE; int main(int argc, char** argv){ strategy=SEARCH; printf("strategy: %d\n", strategy); return 0; }
typedef enum {RANDOM, IMMEDIATE, SEARCH} StrategyType; StrategyType strategy = IMMEDIATE;
int strategy; ... enum {RANDOM, IMMEDIATE, SEARCH} strategy;
enum {a,b,c}; int main(){ printf("%d\n",b); return 0; }
enum {a,b,c}; int bb=b; int main(){ printf("%d\n",bb); return 0; }
enum tag1 {a,b,c}; enum tag1 var1= a; enum tag1 var2= b;
typedef enum {a,b,c} Tag1; Tag1 var1= a; Tag1 var2= b;
typedef enum tag1{a,b,c}Tag1; Tag1 var1= a; enum tag1 var2= b;
enum Strategy {RANDOM, IMMEDIATE, SEARCH}; ... Strategy myStrategy = IMMEDIATE;
enum strategy {RANDOM, IMMEDIATE, SEARCH}; strategy a;
enum strategy {RANDOM, IMMEDIATE, SEARCH}; enum strategy queen = RANDOM; enum strategy king = SEARCH; enum strategy pawn[100];
enum {RANDOM, IMMEDIATE, SEARCH} strategy; strategy = RANDOM;
enum {RANDOM, IMMEDIATE, SEARCH} strategy; enum strategy a = RANDOM;
enum strategy {RANDOM, IMMEDIATE, SEARCH} a, b; a = RANDOM; b = SEARCH; enum strategy c = IMMEDIATE;
typedef enum strategyName {RANDOM, IMMEDIATE, SEARCH} strategy;
typedef enum strategyName {RANDOM, IMMEDIATE, SEARCH} strategy; enum strategyName a = RANDOM; strategy b = SEARCH;
enum enum_name {RANDOM, IMMEDIATE, SEARCH} strategy; strategy = IMMEDIATE;
int strategy; strategy = 1; void some_function(void) { }
int strategy; void some_function(void) { strategy = 1; }
enum {RANDOM, IMMEDIATE, SEARCH} strategy; strategy = IMMEDIATE; void some_function(void) { }
enum {RANDOM, IMMEDIATE, SEARCH} strategy = IMMEDIATE; void some_function(void) { }
enum {RANDOM, IMMEDIATE, SEARCH} strategy; void some_function(void) { strategy = IMMEDIATE; }
void some_function(void) { enum {RANDOM, IMMEDIATE, SEARCH} strategy; strategy = IMMEDIATE; }
typedef enum state {a = 0, b = 1, c = 2} state; typedef enum state old; typedef enum state new; new now = a; old before = b; printf("State now = %d \n", now); printf("Sate before = %d \n\n", before);
label.frame = (inPseudoEditMode) ? kLabelIndentedRect : kLabelRect;
label.frame = (inPseudoEditMode) ? kLabelIndentedRect : kLabelRect;
if(inPseudoEditMode) { label.frame = kLabelIndentedRect; } else { label.frame = kLabelRect; }
[NSString stringWithFormat: @"Status: %@", (statusBool ? @"Approved" : @"Rejected")]
[NSString stringWithFormat: @"Status: %@", statusString]
if (inPseudoEditMode) label.frame = kLabelIndentedRec; else label.frame = kLabelRect;
if(inPseudoEditMode) label.frame = kLabelIndentedRect; else label.frame = kLabelRect;
(a > b) ? what to do if true : what to do if false;
let imageObject: UIImage = (UIImage(named: "ImageName")) ?? (initialOfUsername.capitalizedString).imageFromString
int a = 6, c= 5; if (a > c) { a is greater } else { c is greater }
int padding = ([[UIScreen mainScreen] bounds].size.height <= 480) ? 15 : 55;
int padding; if ([[UIScreen mainScreen] bounds].size.height <= 480) padding = 15; else padding = 55;
? means = execute the codes before the : if the condition is true. : means = execute the codes after the : if the condition is false.
BOOL isFemale = YES; NSString *valueToPrint = (isFemale == YES) ? @"GENDER IS FEMALE" : @"GENDER IS MALE"; NSLog(valueToPrint);
let isFemale = false let valueToPrint:String = (isFemale == true) ? "GENDER IS FEMALE" : "GENDER IS MALE" print(valueToPrint)
-(NSString*) getSomeStringSafeCheck { NSString *string = [self getSomeString]; if(string != nil){ return String; } return @""; }
-(NSString*) getSomeStringSafeCheck { return [self getSomeString] != nil ? [self getSomeString] : @""; }
-(NSString*) getSomeStringSafeCheck { return [self getSomeString]?: @""; }
char *str = "string"; str[0] = printf("%s\n", str);
char str[] = "string"; str[0] = printf("%s\n", str);
static char __unnamed[] = "abc"; char *c = __unnamed;
int main(void) { char *s = "abc"; printf("%s\n", s); return 0; }
char *s = "abc"; 8: 48 c7 45 f8 00 00 00 movq $0x0,-0x8(%rbp) f: 00 c: R_X86_64_32S .rodata
17: c7 45 f0 61 62 63 00 movl $0x636261,-0x10(%rbp)
Section to Segment mapping: Segment Sections... 02 .text .rodata
char *str_p; str_p = "String constant"; char *arr_p; char arr[] = "String in an array"; arr_p = &arr[0]; *arr_p = *str_p = /*----------------------------------------------------------------------------- * String constants can * because most operating systems will not allow a write * operation on read only memory. *-----------------------------------------------------------------------------*/ printf("%s\n", str_p); printf("%s\n", arr_p);
int main(void) { long long bal = 0; if(bal < INT32_MIN ) { printf("Failed!!!"); } else { printf("Success!!!"); } return 0; }
Suffix Decimal Constant Octal or Hexadecimal Constant none int int long int unsigned int long long int long int unsigned long int long long int unsigned long long int
-0x80000000 = ~0x80000000 + 1 => 0x7FFFFFFF + 1 => 0x80000000
~0x80000000 = 0x7FFFFFFF 0x7FFFFFFF + 1 = 0x80000000
load first number from memory load second number from memory add the two store answer into memory
int main(int argc, char** argv) { register int numIterations = 20000; register int i=0; unsigned long val=0; for (i; i<numIterations+1; i++) { register int j=0; for (j;j<i;j++) { val=j+i; } } printf("%d", val); return 0; }
int main(int argc, char *argv[]) { uint64_t cps, cycle1, cycle2, ncycles; double sec; register int a=0, b = 1, c = 3, i; cycle1 = ClockCycles(); for(i = 0; i < 100000000; i++) a = ((a + b + c) * c) / 2; cycle2 = ClockCycles(); ncycles = cycle2 - cycle1; printf("%lld cycles elapsed\n", ncycles); cps = SYSPAGE_ENTRY(qtime) -> cycles_per_sec; printf("This system has %lld cycles per second\n", cps); sec = (double)ncycles/cps; printf("The cycles in seconds is %f\n", sec); return EXIT_SUCCESS; }
double var_f(f_args in){ int i_out = in.i ? in.i : 8; double x_out = in.x ? in.x : 3.14; return f_base(i_out, x_out); }
int f1(int arg1, double arg2, char* name, char *opt); int f2(int arg1, double arg2, char* name) { return f1(arg1, arg2, name, "Some option"); }
struct range { int from; int to; int step; }; void (range)(struct range r) { for (int i = r.from; i <= r.to; i += r.step) printf("%d ", i); puts(""); } int main() { range(); range(.from=2, .to=4); range(.step=2); }
void window_set_size(unsigned int width DEFAULT_VALUE(640), unsigned int height DEFAULT_VALUE(400));
int f(int arg1, double arg2, char* name, char *opt);
struct func_opts { int arg1; char * arg2; int arg3; }; void func(int arg, struct func_opts *opts) { int arg1 = 0, arg3 = 0; char *arg2 = "Default"; if(opts) { if(opts->arg1) arg1 = opts->arg1; if(opts->arg2) arg2 = opts->arg2; if(opts->arg3) arg3 = opts->arg3; } } func(3, NULL); struct func_opts opts = {0}; func(3, &opts); opts.arg3 = 3; opts.arg2 = "Yes"; func(3, &opts);
int foo3(int a, int b, int c) { return ...; } int foo2(int a, int b) { return foo3(a, b, 0); } int foo1(int a) { return foo3(a, 1, 0); }
int funcA( int a, int b, ... ){ return a+b; } int funcB( int a, int b ){ if( b == -1 ) b = 8; return a+b; } int main(void){ printf("funcA(1,2): %i\n", funcA(1,2) ); printf("funcA(1): %i\n", funcA(1) ); printf("funcB(1, 2): %i\n", funcB(1, 2) ); printf("funcB(1,-1): %i\n", funcB(1,-1) ); }
const uint32* uint32_frombytes(uint32* out, const uint8* in, size_t bytes);
const uint8* uint16_tobytes(const uint16* in, uint8* out, size_t bytes); const uint16* uint16_frombytes(uint16* out, const uint8* in, size_t bytes); const uint8* uint32_tobytes(const uint32* in, uint8* out, size_t bytes); const uint32* uint32_frombytes(uint32* out, const uint8* in, size_t bytes); const uint16*: uint16_tobytes, \ const uint32*: uint32_tobytes) (VARIADIC2( uint32_tobytes, NUMARG3(a, __VA_ARGS__), a, __VA_ARGS__)) uint16*: uint16_frombytes, \ uint32*: uint32_frombytes)(VARIADIC2(uint32_frombytes, NUMARG3(a, __VA_ARGS__), a, __VA_ARGS__))
int (func)(int a, int b) { return a + b; } int main(void) { printf("%d\n", func(1)); printf("%d\n", func(1, 2)); return 0; }
typedef enum { my_input_set1 = 0, my_input_set2, my_input_set3} INPUT_SET; typedef struct{ INPUT_SET type; char* text; } input_set1; typedef struct{ INPUT_SET type; char* text; int var; } input_set2; typedef struct{ INPUT_SET type; int text; } input_set3; typedef union { INPUT_SET type; input_set1 set1; input_set2 set2; input_set3 set3; } MY_INPUT; void my_func(MY_INPUT input) { switch(input.type) { case my_input_set1: break; case my_input_set2: break; case my_input_set3: break; default: break; } }
void my_func3(char a, int b, float c) { printf("a=%c; b=%d; c=%f\n", a, b, c); }
void my_func4(char a, int b, float c, const char* d) { printf("a=%c; b=%d; c=%f; d=%s\n", a, b, c, d); }
int main(void) { my_func( my_func( my_func( my_func( return 0; }
a=a; b=10; c=0.500000; d=default a=b; b=20; c=0.500000; d=default a=c; b=200; c=10.500000; d=default a=d; b=2000; c=100.500000; d=hello
int main() { int array[10],i; for (i = 0; i <=10 ; i++) { array[i]=0; printf("test \n"); } printf("%d \n", sizeof(array)/sizeof(int)); return 0; }
int main() { int array[10],i; printf ("array: %p, &i: %p\n", array, &i); printf ("i is offset %d from array\n", &i - array); for (i = 0; i <=11 ; i++) { printf ("%d: Writing 0 to address %p\n", i, &array[i]); array[i]=0; } return 0; }
int array[10],i; for (i = 0; i <=10 ; i++) array[i]=0;
.L3: movl -52(%rbp), %eax ; load i to register eax cltq movl $0, -48(%rbp,%rax,4) ; set array[i] to 0 movl $.LC0, %edi call puts ; printf of a constant string was optimized to puts addl $1, -52(%rbp) ; add 1 to i .L2: cmpl $10, -52(%rbp) ; compare i to 10 jle .L3
movl $11, %ebx .L3: movl $.LC0, %edi call puts subl $1, %ebx jne .L3
void use_array(int *array); int main() { int array[10],i; for (i = 0; i <=10 ; i++) { array[i]=0; printf("test \n"); } printf("%zd \n", sizeof(array)/sizeof(int)); use_array(array); return 0; }
gcc -c use_array.c gcc -O1 -S -o with_use_array1.c with_use_array.c use_array.o
movq %rsp, %rbx leaq 44(%rsp), %rbp .L3: movl $0, (%rbx) movl $.LC0, %edi call puts addq $4, %rbx cmpq %rbp, %rbx jne .L3
$ cat /proc/sys/kernel/core_pattern |/usr/lib/systemd/systemd-coredump %p %u %g %s %t %e
$ ln -s /dev/null /etc/sysctl.d/50-coredump.conf $ sysctl -w kernel.core_pattern=core
/var/spool/abrt/ccpp-2017-02-16-16:36:51-2974/coredump
int64_t my_int = 999999999999999999; printf("This is my_int: %I64d\n", my_int);
warning: format ‘%I64d’ expects type ‘int’, but argument 2 has type ‘int64_t’
~/dev/c$ cc -v Using built-in specs. Target: i686-apple-darwin10 Configured with: /var/tmp/gcc/gcc-5664~89/src/configure --disable-checking --enable-werror --prefix=/usr --mandir=/share/man --enable-languages=c,objc,c++,obj-c++ --program-transform-name=/^[cg][^.-]*$/s/$/-4.2/ --with-slibdir=/usr/lib --build=i686-apple-darwin10 --program-prefix=i686-apple-darwin10- --host=x86_64-apple-darwin10 --target=i686-apple-darwin10 --with-gxx-include-dir=/include/c++/4.2.1 Thread model: posix gcc version 4.2.1 (Apple Inc. build 5664)
int64_t my_int = 999999999999999999; printf("%" PRId64 "\n", my_int);
printf("%ld", (long)my_int); printf("%lld", (long long)my_int); printf("%f", (double)my_int);
int main(int argc, char *argv[]) { int64_t a = 1LL << 63; uint64_t b = 1ULL << 63; printf("a=%jd (0x%jx)\n", a, a); printf("b=%ju (0x%jx)\n", b, b); return 0; }
a=-9223372036854775808 (0x8000000000000000) b=9223372036854775808 (0x8000000000000000)
char* ullx(uint64_t val) { static char buf[34] = { [0 ... 33] = 0 }; char* out = &buf[33]; uint64_t hval = val; unsigned int hbase = 16; do { *out = "0123456789abcdef"[hval % hbase]; --out; hval /= hbase; } while(hval); *out-- = return out; }
__int64 my_qw_var = 0x1234567890abcdef; __int32 v_dw_h; __int32 v_dw_l; __asm { mov eax,[dword ptr my_qw_var + 4] mov [dword ptr v_dw_h],eax mov eax,[dword ptr my_qw_var] mov [dword ptr v_dw_l],eax } printf("val = 0x%0.8x%0.8x\n", (__int32)v_dw_h, (__int32)v_dw_l);
int main(){ int a[4]={0,1,5,3}; int a0 = a[0]; int a1 = *(a+1); int a2 = *(2+a); int a3 = 3[a]; return a2; }
int * mutable_pointer_to_mutable_int; int const * mutable_pointer_to_constant_int; int *const constant_pointer_to_mutable_int; int const *const constant_pointer_to_constant_int;
/*const char * p; char * const p; const char * const p;*/ /*int main() { const char * p; char z; p = &z; printf(" %c\n",*p); return 0; }*/ /*int main() { char * const p; char z; *p = printf(" %c\n",*p); return 0; }*/ /*int main() { const char * const p; char z; *p = p = &z; printf(" %c\n",*p); return 0; }*/
int main(){ int a=10; int *const ptr=&a; *ptr=100; printf("%d",*ptr); return 0; }
int main(){ int a=10,b=20; int const *ptr=&a; printf("%d\n",*ptr); /* *ptr=100 is not possible i.e we cannot change the value of the object pointed by the pointer*/ ptr=&b; printf("%d",*ptr); return 0; }
int main(void) { char ca1[10]= "aaaa"; char ca2[10]= "bbbb"; char *pca1= ca1; char *pca2= ca2; char const *ccs= pca1; char * const csc= pca2; ccs[1]= ccs= csc; csc[1]= csc= ccs; char const **ccss= &ccs; char const **ccss1= &csc; char * const *cscs= &csc; char * const *cscs1= &ccs; char ** const cssc= &pca1; char ** const cssc1= &ccs; char ** const cssc2= &csc; *ccss[1]= *ccss= ccs; *ccss= csc; ccss= ccss1; ccss= cscs; *cscs[1]= *cscs= ccs; *cscs= csc; cscs= cscs1; cscs= cssc; *cssc[1]= *cssc= ccs; *cssc= csc; *cssc= pca2; cssc= ccss; cssc= cscs; cssc= cssc1; }
int arr[10]; ... foo(arr); ... void foo(int *arr) { ... }
int arr[N]; ... foo(&arr); void foo(int (*p)[N]) {...}
void swap(int x, int y) { int tmp = x; x = y; y = tmp; } ... int a = 1, b = 2; printf("before swap: a = %d, b = %d\n", a, b); swap(a, b); printf("after swap: a = %d, b = %d\n", a, b);
void swap(int *x, int *y) {int tmp = *x; *x = *y; *y = tmp; } ... int a = 1, b = 2; printf("before swap: a = %d, b = %d\n", a, b); swap(&a, &b); printf("after swap: a = %d, b = %d\n", a, b);
int myFopen(FILE *stream) {stream = fopen("myfile.dat", "r"); } ... FILE *in; myFopen(in);
int myFopen(FILE **stream) {*stream = fopen("myFile.dat", "r"); } ... FILE *in; myFopen(&in);
int arr[N]; init(arr, N); ... void init(int *arr, int N) {size_t i; for (i = 0; i < N; i++) arr[i] = i*i;}
int int_value = 1; int * int_ptr; int int_array1[10]; int int_array3[] = {1,2,3,4,5}; int int_array4[5] = {1,2,3,4,5}; void func_takes_int_ptr1(int *int_ptr){} void func_takes int_ptr2(int int_ptr[]){}
int *x = NULL; int *y = malloc(sizeof(int)), *z = NULL; int* f(int *x) { ... }
int main(){ int x, *p; p = &x; /* initialise pointer(take the address of x) */ *p = 0; printf("x is %d\n", x); printf("*p is %d\n", *p); *p += 1; printf("x is %d\n", x); (*p)++; printf("x is %d\n", x); return 0; }
int main() { int x; int *p; /* A pointer to an integer ("*p" is an integer, so p must be a pointer to an integer) */ p = &x; scanf( "%d", &x ); printf( "%d\n", *p ); /* Note the use of the * to get the value */ getchar(); }
Foo_1(double *bar, int size){ return bar[size-1]; } Foo_2(double bar[], int size){ return bar[size-1]; }
({ __typeof__ (a) _a = (a); \ __typeof__ (b) _b = (b); \ _a > _b ? _a : _b; })
$ uname -sr Linux 2.6.11 $ cat /etc/debian_version 5.0.2 $ egrep $ head -n 2 /usr/include/sys/param.h | grep GNU This file is part of the GNU C Library.
_Generic((x), \ int: GENERIC_MAX(x, ENSURE_int(y)) \ float: GENERIC_MAX(x, ENSURE_float(y)) \ )
(type)GENERIC_MAX(ENSURE_ int main (void) { int ia = 1, ib = 2; float fa = 3.0f, fb = 4.0f; double da = 5.0, db = 6.0; printf("%d\n", MAX(int, ia, ib)); printf("%f\n", MAX(float, fa, fb)); return 0; }
{ __auto_type __x = (x); __auto_type __y = (y); \ __x > __y ? __x : __y; })
({ \ decltype(lexpr) lvar = (lexpr); \ decltype(rexpr) rvar = (rexpr); \ lvar binoper rvar ? lvar : rvar; \ }) _CHOOSE2( \ binoper, \ lexpr, _CHOOSE_VAR(_left, __COUNTER__), \ rexpr, _CHOOSE_VAR(_right, __COUNTER__) \ )
template<class T> T min(T a, T b) { return a < b ? a : b; }
typedef enum { FALSE, TRUE } boolean; boolean b = FALSE; if (b) { ... }
typedef enum { false = ( 1 == 0 ), true = ( ! false ) } bool;
struct S { int a, b; }; struct T { float x, y, z; }; struct T c; c.b = 55;
int main() { int i=0; char *buf[10]; while(i<10) { buf[i] = (char*)calloc(1,BLOCK_SIZE); i++; } }
time ./a.out **real 0m0.287s** user 0m0.095s sys 0m0.192s
int main() { int i=0; char *buf[10]; while(i<10) { buf[i] = (char*)malloc(BLOCK_SIZE); memset(buf[i], i++; } }
time ./a.out **real 0m2.693s** user 0m0.973s sys 0m1.721s
function memset(dest, c, len) while (len > 0 && ((unsigned int)dest & 15)) *dest++ = c len -= 1 while (len >= 16) dest += 16 len -= 16 while (len > 0) *dest++ = c len -= 1
int main() { int fd; int *map; int size = sizeof(int); char *name = "/a"; shm_unlink(name); fd = shm_open(name, O_RDWR | O_CREAT, (mode_t)0600); /*ftruncate(fd, size);*/ map = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); *map = 0; }
unsigned char data[6]; (unsigned int *) (data + 2) = 0xdeadf00d;
int main(void) { char buffer[120]; fgets(buffer, sizeof buffer, stdin); strcat("foo", buffer); return 0; }
for (j = 0; i < n; j++) { for (i =0; i < m; i++) { a[n+1][j] += a[i][j]; } }
{ char buf[255]; sprintf(buf,"%s:%s\n", ifname, message); }
unsigned int reverse(register unsigned int x) { x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)); x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)); x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)); x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)); return((x >> 16) | (x << 16)); }
static const unsigned char BitReverseTable256[] = { 0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0, 0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8, 0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4, 0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC, 0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2, 0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA, 0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6, 0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE, 0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1, 0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9, 0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5, 0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD, 0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3, 0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB, 0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7, 0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF }; unsigned int v; unsigned int c; c = (BitReverseTable256[v & 0xff] << 24) | (BitReverseTable256[(v >> 8) & 0xff] << 16) | (BitReverseTable256[(v >> 16) & 0xff] << 8) | (BitReverseTable256[(v >> 24) & 0xff]); unsigned char * p = (unsigned char *) &v; unsigned char * q = (unsigned char *) &c; q[3] = BitReverseTable256[p[0]]; q[2] = BitReverseTable256[p[1]]; q[1] = BitReverseTable256[p[2]]; q[0] = BitReverseTable256[p[3]];
unsigned int v; unsigned int r = v & 1; int s = sizeof(v) * CHAR_BIT - 1; for (v >>= 1; v; v >>= 1) { r <<= 1; r |= v & 1; s--; } r <<= s;
unsigned char b = x; b = ((b * 0x0802LU & 0x22110LU) | (b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
unsigned char b; b = (b * 0x0202020202ULL & 0x010884422010ULL) % 1023;
unsigned int toReverse; unsigned int reversed; unsigned char inByte0 = (toReverse & 0xFF); unsigned char inByte1 = (toReverse & 0xFF00) >> 8; unsigned char inByte2 = (toReverse & 0xFF0000) >> 16; unsigned char inByte3 = (toReverse & 0xFF000000) >> 24; reversed = (reverseBits(inByte0) << 24) | (reverseBits(inByte1) << 16) | (reverseBits(inByte2) << 8) | (reverseBits(inByte3);
unsigned int reverse(register unsigned int x) { x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)); x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)); x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)); x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)); return((x >> 16) | (x << 16)); } int main() { unsigned int *ints = malloc(100000000*sizeof(unsigned int)); unsigned int *ints2 = malloc(100000000*sizeof(unsigned int)); for(unsigned int i = 0; i < 100000000; i++) ints[i] = rand(); unsigned int *inptr = ints; unsigned int *outptr = ints2; unsigned int *endptr = ints + 100000000; double start = omp_get_wtime(); while(inptr != endptr) { (*outptr) = reverse(*inptr); inptr++; outptr++; } double end = omp_get_wtime(); printf("Time: %f seconds\n", end-start); free(ints); free(ints2); return 0; }
static const unsigned char BitReverseTable256[] = { 0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0, 0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8, 0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4, 0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC, 0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2, 0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA, 0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6, 0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE, 0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1, 0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9, 0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5, 0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD, 0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3, 0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB, 0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7, 0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF }; int main() { unsigned int *ints = malloc(100000000*sizeof(unsigned int)); unsigned int *ints2 = malloc(100000000*sizeof(unsigned int)); for(unsigned int i = 0; i < 100000000; i++) ints[i] = rand(); unsigned int *inptr = ints; unsigned int *outptr = ints2; unsigned int *endptr = ints + 100000000; double start = omp_get_wtime(); while(inptr != endptr) { unsigned int in = *inptr; unsigned char * p = (unsigned char *) &(*inptr); unsigned char * q = (unsigned char *) &(*outptr); q[3] = BitReverseTable256[p[0]]; q[2] = BitReverseTable256[p[1]]; q[1] = BitReverseTable256[p[2]]; q[0] = BitReverseTable256[p[3]]; inptr++; outptr++; } double end = omp_get_wtime(); printf("Time: %f seconds\n", end-start); free(ints); free(ints2); return 0; }
mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -o reverse reverse.c mrj10@mjlap:~/code$ ./reverse Time: 2.000593 seconds mrj10@mjlap:~/code$ ./reverse Time: 1.938893 seconds mrj10@mjlap:~/code$ ./reverse Time: 1.936365 seconds mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -O2 -o reverse reverse.c mrj10@mjlap:~/code$ ./reverse Time: 0.942709 seconds mrj10@mjlap:~/code$ ./reverse Time: 0.991104 seconds mrj10@mjlap:~/code$ ./reverse Time: 0.947203 seconds mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -O3 -o reverse reverse.c mrj10@mjlap:~/code$ ./reverse Time: 0.922639 seconds mrj10@mjlap:~/code$ ./reverse Time: 0.892372 seconds mrj10@mjlap:~/code$ ./reverse Time: 0.891688 seconds
mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -o reverse_lookup reverse_lookup.c mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.201127 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.196129 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.235972 seconds mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -O2 -o reverse_lookup reverse_lookup.c mrj10@mjlap:~/code$ ./reverse_lookup Time: 0.633042 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 0.655880 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 0.633390 seconds mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -O3 -o reverse_lookup reverse_lookup.c mrj10@mjlap:~/code$ ./reverse_lookup Time: 0.652322 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 0.631739 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 0.652431 seconds
mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -o reverse_lookup reverse_lookup.c mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.671537 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.688173 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.664662 seconds mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -O2 -o reverse_lookup reverse_lookup.c mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.049851 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.048403 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.085086 seconds mrj10@mjlap:~/code$ gcc -fopenmp -std=c99 -O3 -o reverse_lookup reverse_lookup.c mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.082223 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.053431 seconds mrj10@mjlap:~/code$ ./reverse_lookup Time: 1.081224 seconds
.L3: movl (%r12,%rsi), %ecx movzbl %cl, %eax movzbl BitReverseTable256(%rax), %edx movl %ecx, %eax shrl $24, %eax mov %eax, %eax movzbl BitReverseTable256(%rax), %eax sall $24, %edx orl %eax, %edx movzbl %ch, %eax shrl $16, %ecx movzbl BitReverseTable256(%rax), %eax movzbl %cl, %ecx sall $16, %eax orl %eax, %edx movzbl BitReverseTable256(%rcx), %eax sall $8, %eax orl %eax, %edx movl %edx, (%r13,%rsi) addq $4, %rsi cmpq $400000000, %rsi jne .L3
.L3: movq (%r12,%rsi), %rdx movq %rdx, %rax shrq $24, %rax andl $255, %eax movzbl BitReverseTable256(%rax), %ecx movzbq %dl,%rax movzbl BitReverseTable256(%rax), %eax salq $24, %rax orq %rax, %rcx movq %rdx, %rax shrq $56, %rax movzbl BitReverseTable256(%rax), %eax salq $32, %rax orq %rax, %rcx movzbl %dh, %eax shrq $16, %rdx movzbl BitReverseTable256(%rax), %eax salq $16, %rax orq %rax, %rcx movzbq %dl,%rax shrq $16, %rdx movzbl BitReverseTable256(%rax), %eax salq $8, %rax orq %rax, %rcx movzbq %dl,%rax shrq $8, %rdx movzbl BitReverseTable256(%rax), %eax salq $56, %rax orq %rax, %rcx movzbq %dl,%rax shrq $8, %rdx movzbl BitReverseTable256(%rax), %eax andl $255, %edx salq $48, %rax orq %rax, %rcx movzbl BitReverseTable256(%rdx), %eax salq $40, %rax orq %rax, %rcx movq %rcx, (%r13,%rsi) addq $8, %rsi cmpq $400000000, %rsi jne .L3
using namespace std; __attribute__ ((aligned(32))) static unsigned char k1[32*3]={ 0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f, 0x00,0x08,0x04,0x0c,0x02,0x0a,0x06,0x0e,0x01,0x09,0x05,0x0d,0x03,0x0b,0x07,0x0f,0x00,0x08,0x04,0x0c,0x02,0x0a,0x06,0x0e,0x01,0x09,0x05,0x0d,0x03,0x0b,0x07,0x0f, 0x00,0x80,0x40,0xc0,0x20,0xa0,0x60,0xe0,0x10,0x90,0x50,0xd0,0x30,0xb0,0x70,0xf0,0x00,0x80,0x40,0xc0,0x20,0xa0,0x60,0xe0,0x10,0x90,0x50,0xd0,0x30,0xb0,0x70,0xf0 }; __attribute__ ((aligned(32))) static unsigned char data[NUM_DATA_BYTES+32]={}; extern "C" { void bitflipbyte(unsigned char[],unsigned int,unsigned char[]); } int main() { for(unsigned int i = 0; i < NUM_DATA_BYTES; i++) { data[i] = rand(); } printf ("\r\nData in(start):\r\n"); for (unsigned int j = 0; j < 4; j++) { for (unsigned int i = 0; i < DISPLAY_WIDTH; i++) { printf ("0x%02x,",data[i+(j*DISPLAY_WIDTH)]); } printf ("\r\n"); } printf ("\r\nNumber of 32-byte chunks to convert: %d\r\n",(unsigned int)ceil(NUM_DATA_BYTES/32.0)); double start_time = omp_get_wtime(); bitflipbyte(data,(unsigned int)ceil(NUM_DATA_BYTES/32.0),k1); double end_time = omp_get_wtime(); printf ("\r\nData out:\r\n"); for (unsigned int j = 0; j < 4; j++) { for (unsigned int i = 0; i < DISPLAY_WIDTH; i++) { printf ("0x%02x,",data[i+(j*DISPLAY_WIDTH)]); } printf ("\r\n"); } printf("\r\n\r\nTime to bitflip %d bytes: %f seconds\r\n\r\n",NUM_DATA_BYTES, end_time-start_time); return 0; }
bits 64 global bitflipbyte bitflipbyte: vmovdqa ymm2, [rdx] add rdx, 20h vmovdqa ymm3, [rdx] add rdx, 20h vmovdqa ymm4, [rdx] bitflipp_loop: vmovdqa ymm0, [rdi] vpand ymm1, ymm2, ymm0 vpandn ymm0, ymm2, ymm0 vpsrld ymm0, ymm0, 4h vpshufb ymm1, ymm4, ymm1 vpshufb ymm0, ymm3, ymm0 vpor ymm0, ymm0, ymm1 vmovdqa [rdi], ymm0 add rdi, 20h dec rsi jnz bitflipp_loop ret
Illustrated in the example below. Ex : If Input is 00101010 ==> Expected output is 01010100 1. Divide the input into 2 halves 0010 --- 1010 2. Swap the 2 Halves 1010 0010 3. Repeat the same for each half. 10 -- 10 --- 00 -- 10 10 10 10 00 1-0 -- 1-0 --- 1-0 -- 0-0 0 1 0 1 0 1 0 0 Done! Output is 01010100
int reverse_bits_recursive(unsigned int num, unsigned int numBits) { unsigned int reversedNum;; unsigned int mask = 0; mask = (0x1 << (numBits/2)) - 1; if (numBits == 1) return num; reversedNum = reverse_bits_recursive(num >> numBits/2, numBits/2) | reverse_bits_recursive((num & mask), numBits/2) << numBits/2; return reversedNum; } int main() { unsigned int reversedNum; unsigned int num; num = 0x55; reversedNum = reverse_bits_recursive(num, 8); printf ("Bit Reversal Input = 0x%x Output = 0x%x\n", num, reversedNum); num = 0xabcd; reversedNum = reverse_bits_recursive(num, 16); printf ("Bit Reversal Input = 0x%x Output = 0x%x\n", num, reversedNum); num = 0x123456; reversedNum = reverse_bits_recursive(num, 24); printf ("Bit Reversal Input = 0x%x Output = 0x%x\n", num, reversedNum); num = 0x11223344; reversedNum = reverse_bits_recursive(num,32); printf ("Bit Reversal Input = 0x%x Output = 0x%x\n", num, reversedNum); }
Bit Reversal Input = 0x55 Output = 0xaa Bit Reversal Input = 0xabcd Output = 0xb3d5 Bit Reversal Input = 0x123456 Output = 0x651690 Bit Reversal Input = 0x11223344 Output = 0x22cc4488
size_t reverse(size_t n, unsigned int bytes) { __asm__("BSWAP %0" : "=r"(n) : "0"(n)); n >>= ((sizeof(size_t) - bytes) * 8); n = ((n & 0xaaaaaaaaaaaaaaaa) >> 1) | ((n & 0x5555555555555555) << 1); n = ((n & 0xcccccccccccccccc) >> 2) | ((n & 0x3333333333333333) << 2); n = ((n & 0xf0f0f0f0f0f0f0f0) >> 4) | ((n & 0x0f0f0f0f0f0f0f0f) << 4); return n; }
size_t reverse(size_t n, unsigned int bytes) { __asm__("BSWAP %0" : "=r"(n) : "0"(n)); n >>= ((sizeof(size_t) - bytes) * 8); n = ((n & 0xaaaaaaaaaaaaaaaa) >> 1) | ((n & 0x5555555555555555) << 1); n = ((n & 0xcccccccccccccccc) >> 2) | ((n & 0x3333333333333333) << 2); n = ((n & 0xf0f0f0f0f0f0f0f0) >> 4) | ((n & 0x0f0f0f0f0f0f0f0f) << 4); return n; }
n = reverse(n, sizeof(char)); n = reverse(n, sizeof(short)); n = reverse(n, sizeof(int)); n = reverse(n, sizeof(size_t));
inline uint32_t brev_classic (uint32_t a) { uint32_t m; a = (a >> 16) | (a << 16); m = 0x00ff00ff; a = ((a >> 8) & m) | ((a << 8) & ~m); m = m^(m << 4); a = ((a >> 4) & m) | ((a << 4) & ~m); m = m^(m << 2); a = ((a >> 2) & m) | ((a << 2) & ~m); m = m^(m << 1); a = ((a >> 1) & m) | ((a << 1) & ~m); return a; }
/* Knuth inline uint32_t brev_knuth (uint32_t a) { uint32_t t; a = (a << 15) | (a >> 17); t = (a ^ (a >> 10)) & 0x003f801f; a = (t + (t << 10)) ^ a; t = (a ^ (a >> 4)) & 0x0e038421; a = (t + (t << 4)) ^ a; t = (a ^ (a >> 2)) & 0x22488842; a = (t + (t << 2)) ^ a; return a; }
Stack stack = new Stack(); Bit[] bits = new Bit[] { 0, 0, 1, 0, 0, 0, 0, 0 }; for (int i = 0; i < bits.Length; i++) { stack.push(bits[i]); } for (int i = 0; i < bits.Length; i++) { bits[i] = stack.pop(); }
uint64_t reverse(const uint64_t n, const uint64_t k) { uint64_t r, i; for (r = 0, i = 0; i < k; ++i) r |= ((n >> i) & 1) << (k - i - 1); return r; } int main() { const uint64_t size = 64; uint64_t sum = 0; uint64_t a; for (a = 0; a < (uint64_t)1 << 30; ++a) sum += reverse(a, size); printf("%" PRIu64 "\n", sum); return 0; }
var1 dw 0f0f0 clc push ax push cx mov cx 16 loop1: shl var1 shr ax loop loop1 pop ax pop cx
private Byte BitReverse(Byte bData) { Byte[] lookup = { 0, 8, 4, 12, 2, 10, 6, 14 , 1, 9, 5, 13, 3, 11, 7, 15 }; Byte ret_val = (Byte)(((lookup[(bData & 0x0F)]) << 4) + lookup[((bData & 0xF0) >> 4)]); return ret_val; }
static unsigned long long swap64(unsigned long long val) { /* val = (((val) >>16) & 0xFFFF0000FFFF) | (((val) & 0xFFFF0000FFFF)<<16); */ val = ZZZZ(val,32, 0x00000000FFFFFFFFull ); val = ZZZZ(val,16, 0x0000FFFF0000FFFFull ); val = ZZZZ(val,8, 0x00FF00FF00FF00FFull ); val = ZZZZ(val,4, 0x0F0F0F0F0F0F0F0Full ); val = ZZZZ(val,2, 0x3333333333333333ull ); val = ZZZZ(val,1, 0x5555555555555555ull ); return val; } int main(void) { unsigned long long val, aaaa[16] = { 0xfedcba9876543210,0xedcba9876543210f,0xdcba9876543210fe,0xcba9876543210fed , 0xba9876543210fedc,0xa9876543210fedcb,0x9876543210fedcba,0x876543210fedcba9 , 0x76543210fedcba98,0x6543210fedcba987,0x543210fedcba9876,0x43210fedcba98765 , 0x3210fedcba987654,0x210fedcba9876543,0x10fedcba98765432,0x0fedcba987654321 }; unsigned iii; for (iii=0; iii < 16; iii++) { val = swap64 (aaaa[iii]); printf("A[]=%016llX Sw=%016llx\n", aaaa[iii], val); } return 0; }
template<size_t N> const std::bitset<N> reverse(const std::bitset<N>& ordered) { std::bitset<N> reversed; for(size_t i = 0, j = N - 1; i < N; ++i, --j) reversed[j] = ordered[i]; return reversed; }; int main() { unsigned long num; const size_t N = sizeof(num)*8; std::cin >> num; std::cout << std::showbase << std::hex; std::cout << "ordered = " << num << std::endl; std::cout << "reversed = " << reverse<N>(num).to_ulong() << std::endl; std::cout << "double_reversed = " << reverse<N>(reverse<N>(num)).to_ulong() << std::endl; }
unsigned long long reverse_long(unsigned long long x) { return (((x >> 0) & 1) << 63) | (((x >> 1) & 1) << 62) | (((x >> 2) & 1) << 61) | (((x >> 3) & 1) << 60) | (((x >> 4) & 1) << 59) | (((x >> 5) & 1) << 58) | (((x >> 6) & 1) << 57) | (((x >> 7) & 1) << 56) | (((x >> 8) & 1) << 55) | (((x >> 9) & 1) << 54) | (((x >> 10) & 1) << 53) | (((x >> 11) & 1) << 52) | (((x >> 12) & 1) << 51) | (((x >> 13) & 1) << 50) | (((x >> 14) & 1) << 49) | (((x >> 15) & 1) << 48) | (((x >> 16) & 1) << 47) | (((x >> 17) & 1) << 46) | (((x >> 18) & 1) << 45) | (((x >> 19) & 1) << 44) | (((x >> 20) & 1) << 43) | (((x >> 21) & 1) << 42) | (((x >> 22) & 1) << 41) | (((x >> 23) & 1) << 40) | (((x >> 24) & 1) << 39) | (((x >> 25) & 1) << 38) | (((x >> 26) & 1) << 37) | (((x >> 27) & 1) << 36) | (((x >> 28) & 1) << 35) | (((x >> 29) & 1) << 34) | (((x >> 30) & 1) << 33) | (((x >> 31) & 1) << 32) | (((x >> 32) & 1) << 31) | (((x >> 33) & 1) << 30) | (((x >> 34) & 1) << 29) | (((x >> 35) & 1) << 28) | (((x >> 36) & 1) << 27) | (((x >> 37) & 1) << 26) | (((x >> 38) & 1) << 25) | (((x >> 39) & 1) << 24) | (((x >> 40) & 1) << 23) | (((x >> 41) & 1) << 22) | (((x >> 42) & 1) << 21) | (((x >> 43) & 1) << 20) | (((x >> 44) & 1) << 19) | (((x >> 45) & 1) << 18) | (((x >> 46) & 1) << 17) | (((x >> 47) & 1) << 16) | (((x >> 48) & 1) << 15) | (((x >> 49) & 1) << 14) | (((x >> 50) & 1) << 13) | (((x >> 51) & 1) << 12) | (((x >> 52) & 1) << 11) | (((x >> 53) & 1) << 10) | (((x >> 54) & 1) << 9) | (((x >> 55) & 1) << 8) | (((x >> 56) & 1) << 7) | (((x >> 57) & 1) << 6) | (((x >> 58) & 1) << 5) | (((x >> 59) & 1) << 4) | (((x >> 60) & 1) << 3) | (((x >> 61) & 1) << 2) | (((x >> 62) & 1) << 1) | (((x >> 63) & 1) << 0); }
unsigned char num = 0xaa; int s = sizeof(num) * 8; int i, x, y, p; int var = 0; for (i = 0; i < (s / 2); i++) { p = s - i - 1; x = num & (1 << p); x = x >> p; printf("x: %d\n", x); y = num & (1 << i); y = y >> i; printf("y: %d\n", y); var = var | (x << i); var = var | (y << p); } printf("new: 0x%x\n", new);
uint reverseMSBToLSB32ui(uint input) { uint output = 0x00000000; uint toANDVar = 0; int places = 0; for (int i = 1; i < 32; i++) { places = (32 - i); toANDVar = (uint)(1 << places); output |= (uint)(input & (toANDVar)) >> places; } return output; }
void bit_reverse(ui32 *data) { ui32 temp = 0; ui32 i, bit_len; { for(i = 0, bit_len = 31; i <= bit_len; i++) { temp |= (*data & 1 << i)? (1 << bit_len-i) : 0; } *data = temp; } return; }
unsigned char ReverseBits(unsigned char data) { unsigned char k = 0, rev = 0; unsigned char n = data; while(n) { k = n & (~(n - 1)); n &= (n - 1); rev |= (128 / k); } return rev; }
unsigned char rev(char MSB) { unsigned char LSB=0; _FOR(i,0,8) { LSB= LSB << 1; if(MSB&1) LSB = LSB | 1; MSB= MSB >> 1; } return LSB; }
unsigned short ReverseBits( unsigned short a ) { const char num_bits = sizeof(a) * CHAR_BIT; bitset<num_bits> bitset_a(a); bitset<num_bits> bitset_b(0); bitset<num_bits> mask(1); for ( char i = 0; i < num_bits; ++i ) { bitset_b = (bitset_b << 1) | bitset_a & mask; bitset_a >>= 1; } return (unsigned short) bitset_b.to_ulong(); } void PrintBits( unsigned short a ) { bitset<sizeof(a) * CHAR_BIT> bitset(a); cout << bitset << endl; } int main () { unsigned short a = 17, b; cout << "Original: "; PrintBits(a); b = ReverseBits( a ); cout << "Reversed: "; PrintBits(b); } Original: 0000000000010001 Reversed: 1000100000000000
template<class T> T reverse_bits(T in) { T bit = static_cast<T>(1) << (sizeof(T) * 8 - 1); T out; for (out = 0; bit && in; bit >>= 1, in >>= 1) { if (in & 1) { out |= bit; } } return out; }
unsigned int reverse_bits(unsigned int in) { unsigned int bit = 1u << (sizeof(T) * 8 - 1); unsigned int out; for (out = 0; bit && in; bit >>= 1, in >>= 1) { if (in & 1) out |= bit; } return out; }
char ReverseBits(char character) { char reversed_character = 0; for (int i = 0; i < 8; i++) { char ith_bit = (c >> i) & 1; reversed_character |= (ith_bit << (sizeof(char) - 1 - i)); } return reversed_character; }
void ReverseNumber(char* number, int bit_count_in_number) { int bytes_occupied = bit_count_in_number / sizeof(char); for (int i = 0; i <= (bytes_occupied / 2); i++) { swap(long_number[i], long_number[n - i]); } for (int i = 0; i < bytes_occupied; i++) { long_number[i] = ReverseBits(long_number[i]); } }
set bit8 (msb) of reversed = reversed | b10000000 else do not set bit8 shift bytecopy left 1 place bytecopy = bytecopy << 1 = b0101100 result shift result right 1 place reversed = reversed >> 1 = b00000000 8 times no then up^ LOOP8 8 times yes then done.
BitReverse(IN) OUT = 0x00; R = 1; L = 0; L = ~0; L = ~(i >> 1); int size = sizeof(IN) * 4; while(size--){ if(IN & L) OUT = OUT | R; if(IN & R) OUT = OUT | L; L = L >> 1; R = R << 1; } return OUT;
void bitReverse(int num) { int num_reverse = 0; int size = (sizeof(int)*8) -1; int i=0,j=0; for(i=0,j=size;i<=size,j>=0;i++,j--) { if((num >> i)&1) { num_reverse = (num_reverse | (1<<j)); } } printf("\n rev num = %d\n",num_reverse); }
int bit_reverse(int w, int bits) { int r = 0; for (int i = 0; i < bits; i++) { int bit = (w & (1 << i)) >> i; r |= bit << (bits - i - 1); } return r; }
int set = 1; setsockopt(sd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&set, sizeof(int));
char buf[888]; send( sockfd, buf, sizeof(buf), MSG_NOSIGNAL );
void block_signal(int signal_to_block ) { sigset_t set; sigset_t old_state; // sigprocmask(SIG_BLOCK, NULL, &old_state); // set = old_state; sigaddset(&set, signal_to_block); // sigprocmask(SIG_BLOCK, &set, NULL); }
size_t counter = 0; size_t testSwitch() { clock_t start = clock(); size_t i; for (i = 0; i < MAX_COUNT; i++) { switch (counter % 4 + 1) { case 1: counter += 4; break; case 2: counter += 3; break; case 3: counter += 2; break; case 4: counter += 1; break; } } return 1000 * (clock() - start) / CLOCKS_PER_SEC; } size_t testIf() { clock_t start = clock(); size_t i; for (i = 0; i < MAX_COUNT; i++) { const size_t c = counter % 4 + 1; if (c == 1) { counter += 4; } else if (c == 2) { counter += 3; } else if (c == 3) { counter += 2; } else if (c == 4) { counter += 1; } } return 1000 * (clock() - start) / CLOCKS_PER_SEC; } int main() { printf("Starting...\n"); printf("Switch statement: %u ms\n", testSwitch()); printf("If statement: %u ms\n", testIf()); }
testIf: 13FE81B10 sub rsp,48h 13FE81B14 call qword ptr [__imp_clock (13FE81128h)] 13FE81B1A mov dword ptr [start],eax 13FE81B1E mov qword ptr [i],0 13FE81B27 jmp testIf+26h (13FE81B36h) 13FE81B29 mov rax,qword ptr [i] 13FE81B2E inc rax 13FE81B31 mov qword ptr [i],rax 13FE81B36 cmp qword ptr [i],20000000h 13FE81B3F jae testIf+0C3h (13FE81BD3h) 13FE81B45 xor edx,edx 13FE81B47 mov rax,qword ptr [counter (13FE835D0h)] 13FE81B4E mov ecx,4 13FE81B53 div rax,rcx 13FE81B56 mov rax,rdx 13FE81B59 inc rax 13FE81B5C mov qword ptr [c],rax 13FE81B61 cmp qword ptr [c],1 13FE81B67 jne testIf+6Dh (13FE81B7Dh) 13FE81B69 mov rax,qword ptr [counter (13FE835D0h)] 13FE81B70 add rax,4 13FE81B74 mov qword ptr [counter (13FE835D0h)],rax 13FE81B7B jmp testIf+0BEh (13FE81BCEh) 13FE81B7D cmp qword ptr [c],2 13FE81B83 jne testIf+89h (13FE81B99h) 13FE81B85 mov rax,qword ptr [counter (13FE835D0h)] 13FE81B8C add rax,3 13FE81B90 mov qword ptr [counter (13FE835D0h)],rax 13FE81B97 jmp testIf+0BEh (13FE81BCEh) 13FE81B99 cmp qword ptr [c],3 13FE81B9F jne testIf+0A5h (13FE81BB5h) 13FE81BA1 mov rax,qword ptr [counter (13FE835D0h)] 13FE81BA8 add rax,2 13FE81BAC mov qword ptr [counter (13FE835D0h)],rax 13FE81BB3 jmp testIf+0BEh (13FE81BCEh) 13FE81BB5 cmp qword ptr [c],4 13FE81BBB jne testIf+0BEh (13FE81BCEh) 13FE81BBD mov rax,qword ptr [counter (13FE835D0h)] 13FE81BC4 inc rax 13FE81BC7 mov qword ptr [counter (13FE835D0h)],rax 13FE81BCE jmp testIf+19h (13FE81B29h) 13FE81BD3 call qword ptr [__imp_clock (13FE81128h)] 13FE81BD9 sub eax,dword ptr [start] 13FE81BDD imul eax,eax,3E8h 13FE81BE3 cdq 13FE81BE4 mov ecx,3E8h 13FE81BE9 idiv eax,ecx 13FE81BEB cdqe 13FE81BED add rsp,48h 13FE81BF1 ret
testSwitch: 13FE81C00 sub rsp,48h 13FE81C04 call qword ptr [__imp_clock (13FE81128h)] 13FE81C0A mov dword ptr [start],eax 13FE81C0E mov qword ptr [i],0 13FE81C17 jmp testSwitch+26h (13FE81C26h) 13FE81C19 mov rax,qword ptr [i] 13FE81C1E inc rax 13FE81C21 mov qword ptr [i],rax 13FE81C26 cmp qword ptr [i],20000000h 13FE81C2F jae testSwitch+0C5h (13FE81CC5h) 13FE81C35 xor edx,edx 13FE81C37 mov rax,qword ptr [counter (13FE835D0h)] 13FE81C3E mov ecx,4 13FE81C43 div rax,rcx 13FE81C46 mov rax,rdx 13FE81C49 inc rax 13FE81C4C mov qword ptr [rsp+30h],rax 13FE81C51 cmp qword ptr [rsp+30h],1 13FE81C57 je testSwitch+73h (13FE81C73h) 13FE81C59 cmp qword ptr [rsp+30h],2 13FE81C5F je testSwitch+87h (13FE81C87h) 13FE81C61 cmp qword ptr [rsp+30h],3 13FE81C67 je testSwitch+9Bh (13FE81C9Bh) 13FE81C69 cmp qword ptr [rsp+30h],4 13FE81C6F je testSwitch+0AFh (13FE81CAFh) 13FE81C71 jmp testSwitch+0C0h (13FE81CC0h) 13FE81C73 mov rax,qword ptr [counter (13FE835D0h)] 13FE81C7A add rax,4 13FE81C7E mov qword ptr [counter (13FE835D0h)],rax 13FE81C85 jmp testSwitch+0C0h (13FE81CC0h) 13FE81C87 mov rax,qword ptr [counter (13FE835D0h)] 13FE81C8E add rax,3 13FE81C92 mov qword ptr [counter (13FE835D0h)],rax 13FE81C99 jmp testSwitch+0C0h (13FE81CC0h) 13FE81C9B mov rax,qword ptr [counter (13FE835D0h)] 13FE81CA2 add rax,2 13FE81CA6 mov qword ptr [counter (13FE835D0h)],rax 13FE81CAD jmp testSwitch+0C0h (13FE81CC0h) 13FE81CAF mov rax,qword ptr [counter (13FE835D0h)] 13FE81CB6 inc rax 13FE81CB9 mov qword ptr [counter (13FE835D0h)],rax 13FE81CC0 jmp testSwitch+19h (13FE81C19h) 13FE81CC5 call qword ptr [__imp_clock (13FE81128h)] 13FE81CCB sub eax,dword ptr [start] 13FE81CCF imul eax,eax,3E8h 13FE81CD5 cdq 13FE81CD6 mov ecx,3E8h 13FE81CDB idiv eax,ecx 13FE81CDD cdqe 13FE81CDF add rsp,48h 13FE81CE3 ret
test_switch(char): movl %edi, %eax cmpl $19, %edi jbe .LBB0_1 retq .LBB0_1: jmpq *.LJTI0_0(,%rax,8) jmp void call<0u>() jmp void call<1u>() jmp void call<2u>() jmp void call<3u>() jmp void call<4u>() jmp void call<5u>() jmp void call<6u>() jmp void call<7u>() jmp void call<8u>() jmp void call<9u>() jmp void call<10u>() jmp void call<11u>() jmp void call<12u>() jmp void call<13u>() jmp void call<14u>() jmp void call<15u>() jmp void call<16u>() jmp void call<17u>() jmp void call<18u>() jmp void call<19u>() .LJTI0_0: .quad .LBB0_2 .quad .LBB0_3 .quad .LBB0_4 .quad .LBB0_5 .quad .LBB0_6 .quad .LBB0_7 .quad .LBB0_8 .quad .LBB0_9 .quad .LBB0_10 .quad .LBB0_11 .quad .LBB0_12 .quad .LBB0_13 .quad .LBB0_14 .quad .LBB0_15 .quad .LBB0_16 .quad .LBB0_17 .quad .LBB0_18 .quad .LBB0_19 .quad .LBB0_20 .quad .LBB0_21
13FE81C51 cmp qword ptr [rsp+30h],1 13FE81C57 je testSwitch+73h (13FE81C73h) 13FE81C59 cmp qword ptr [rsp+30h],2 13FE81C5F je testSwitch+87h (13FE81C87h) 13FE81C61 cmp qword ptr [rsp+30h],3 13FE81C67 je testSwitch+9Bh (13FE81C9Bh) 13FE81C69 cmp qword ptr [rsp+30h],4 13FE81C6F je testSwitch+0AFh (13FE81CAFh)
00B14538 D8 09 AB 00 D8 09 AB 00 D8 09 AB 00 D8 09 AB 00 Ø.«.Ø.«.Ø.«.Ø.«. 00B14548 D8 09 AB 00 D8 09 AB 00 D8 09 AB 00 00 00 00 00 Ø.«.Ø.«.Ø.«..... 00B14558 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00B14568 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
size_t counter = 0; long long testSwitch() { clock_t start = clock(); size_t i; for (i = 0; i < MAX_COUNT; i++) { const size_t c = rand() % 20 + 1; switch (c) { case 1: counter += 20; break; case 2: counter += 33; break; case 3: counter += 62; break; case 4: counter += 15; break; case 5: counter += 416; break; case 6: counter += 3545; break; case 7: counter += 23; break; case 8: counter += 81; break; case 9: counter += 256; break; case 10: counter += 15865; break; case 11: counter += 3234; break; case 12: counter += 22345; break; case 13: counter += 1242; break; case 14: counter += 12341; break; case 15: counter += 41; break; case 16: counter += 34321; break; case 17: counter += 232; break; case 18: counter += 144231; break; case 19: counter += 32; break; case 20: counter += 1231; break; } } return 1000 * (long long)(clock() - start) / CLOCKS_PER_SEC; } long long testIf() { clock_t start = clock(); size_t i; for (i = 0; i < MAX_COUNT; i++) { const size_t c = rand() % 20 + 1; if (c == 1) { counter += 20; } else if (c == 2) { counter += 33; } else if (c == 3) { counter += 62; } else if (c == 4) { counter += 15; } else if (c == 5) { counter += 416; } else if (c == 6) { counter += 3545; } else if (c == 7) { counter += 23; } else if (c == 8) { counter += 81; } else if (c == 9) { counter += 256; } else if (c == 10) { counter += 15865; } else if (c == 11) { counter += 3234; } else if (c == 12) { counter += 22345; } else if (c == 13) { counter += 1242; } else if (c == 14) { counter += 12341; } else if (c == 15) { counter += 41; } else if (c == 16) { counter += 34321; } else if (c == 17) { counter += 232; } else if (c == 18) { counter += 144231; } else if (c == 19) { counter += 32; } else if (c == 20) { counter += 1231; } } return 1000 * (long long)(clock() - start) / CLOCKS_PER_SEC; } int main() { srand(time(NULL)); printf("Starting...\n"); printf("Switch statement: %lld ms\n", testSwitch()); fflush(stdout); printf("counter: %d\n", counter); counter = 0; srand(time(NULL)); printf("If statement: %lld ms\n", testIf()); fflush(stdout); printf("counter: %d\n", counter); }
Test Name: F000003 Class Name: Style CPU Time: 0.781 nanoseconds plus or minus 0.0715 Wall/CPU: 1.00 ratio. Iteration Count: 1677721600 Test Description: Time to test a global using a 2-way if/else if statement compare this test with F000004 Test Name: F000004 Class Name: Style CPU Time: 1.53 nanoseconds plus or minus 0.0767 Wall/CPU: 1.00 ratio. Iteration Count: 1677721600 Test Description: Time to test a global using a 2-way switch statement compare this test with F000003 Test Name: F000005 Class Name: Style CPU Time: 7.70 nanoseconds plus or minus 0.385 Wall/CPU: 1.00 ratio. Iteration Count: 1677721600 Test Description: Time to test a global using a 10-way if/else if statement compare this test with F000006 Test Name: F000006 Class Name: Style CPU Time: 2.00 nanoseconds plus or minus 0.0999 Wall/CPU: 1.00 ratio. Iteration Count: 1677721600 Test Description: Time to test a global using a 10-way switch statement compare this test with F000005 Test Name: F000007 Class Name: Style CPU Time: 3.41 nanoseconds plus or minus 0.171 Wall/CPU: 1.00 ratio. Iteration Count: 1677721600 Test Description: Time to test a global using a 10-way sparse switch statement compare this test with F000005 and F000006
char a[2][14]; strcpy(a[0], "blah"); strcpy(a[1], "hmm");
char strs[NUMBER_OF_STRINGS][STRING_LENGTH+1]; ... strcpy(strs[0], aString); strcpy(strs[1], "foo");
char strs[NUMBER_OF_STRINGS][STRING_LENGTH+1] = {"foo", "bar", "bletch", ...};
char *strs[NUMBER_OF_STRINGS] = {"foo", "bar", "bletch", ...};
strs[i] = malloc(strlen("foo") + 1); strcpy(strs[i], "foo");
char arr[MAX_NUMBER_STRINGS][MAX_STRING_SIZE]; strcpy(arr[0], "blah");
char a1[][14] = { "blah", "hmm" }; char* a2[] = { "blah", "hmm" }; char (*a3[])[] = { &"blah", &"hmm" }; printf(a1[0]); printf(a2[0]); printf(*a3[0]);
typedef struct name { char name[100]; }name; main() { name yourString[10]; printf("Enter something\n:); scanf("%s",yourString[0].name); scanf("%s",yourString[1].name); }
char* strings[3]; strings[0] = "foo"; strings[1] = "bar"; strings[2] = "baz";
char *strings[]={ "one", "two", "three", NULL }; int i=0; while(strings[i]) { printf("%s\n", strings[i]); i++; };
const char *my_array[] = {"eenie","meenie","miney"};
char name[10][10] int i,j,n; printf("\nEnter size of array = "); scanf("%d",&n); for(i=0;i<n;i++) { for(j=0;j<1;j++) { printf("\nEnter name = "); scanf("%s",&name[i]); } } for(i=0;i<n;i++) { for(j=0;j<1;j++) { printf("%d\t|\t%s\t|\t%s",rollno[i][j],name[i],sex[i]); } printf("\n"); }
{ \ char* args[] = __VA_ARGS__; \ ev = args; \ count = _countof(args); \ } void InitEnumIfAny(String& key, CMFCPropertyGridProperty* item) { USES_CONVERSION; char** ev = nullptr; int count = 0; if( key.Compare("horizontal_alignment") ) INIT_STRING_ARRAY( { "top", "bottom" } ) if (key.Compare("boolean")) INIT_STRING_ARRAY( { "yes", "no" } ) if( ev == nullptr ) return; for( int i = 0; i < count; i++) item->AddOption(A2T(ev[i])); item->AllowEdit(FALSE); }
char arr[nb_of_string][max_string_length]; strcpy(arr[0], "word");
int main(int argc, char *argv[]){ int i, j, k; char array[3][100]; char temp[100]; char word[100]; for (i = 0; i < 3; i++){ printf("type word %d : ",i+1); scanf("%s", word); strcpy(array[i], word); } for (k=0; k<3-1; k++){ for (i=0; i<3-1; i++) { for (j=0; j<strlen(array[i]); j++) { if (array[i][j] > array[i+1][j]) { strcpy(temp, array[i+1]); strcpy(array[i+1], array[i]); strcpy(array[i], temp); j = 999; } if (array[i][j] < array[i+1][j]) { j = 999; } } } } for (i=0; i<3; i++) { printf("%s\n",array[i]); } return 0; }
typedef char string[] int main() { string test = "string"; return 0; }
ld -dynamic-linker /lib/ld-linux.so.2 /usr/lib/crt1.o /usr/lib/crti.o /usr/libgcc-lib /i686/3.3.1/crtbegin.o -L/usr/lib/gcc-lib/i686/3.3.1 hello.o -lgcc -lgcc_eh -lc -lgcc -lgcc_eh /usr/lib/gcc-lib/i686/3.3.1/crtend.o /usr/lib/crtn.o
autocmd BufNewFile,BufRead *.cpp set formatprg=astyle\ -T4pb
int main(){if(x<2){x=3;}} float test() { if(x<2) x=3; }
int main() { if (x < 2) { x = 3; } } float test() { if (x < 2) x = 3; }
int main(){if(x<2){x=3;}} float test() { if(x<2) x=3; }
int main(){if(x<2){x=3;}} float test() { if(x<2) x=3; }
int main() { if (x < 2) { x = 3; } } float test() { if (x < 2) x = 3; }
autocmd FileType c,cpp setlocal equalprg=clang-format
>objdump --help [...] -S, --source Intermix source code with disassembly -l, --line-numbers Include line numbers and filenames in output
> gcc -g -c test.c > objdump -d -M intel -S test.o test.o: file format elf32-i386 Disassembly of section .text: 00000000 <main>: int main(void) { 0: 55 push ebp 1: 89 e5 mov ebp,esp 3: 83 e4 f0 and esp,0xfffffff0 6: 83 ec 10 sub esp,0x10 puts("test"); 9: c7 04 24 00 00 00 00 mov DWORD PTR [esp],0x0 10: e8 fc ff ff ff call 11 <main+0x11> return 0; 15: b8 00 00 00 00 mov eax,0x0 } 1a: c9 leave 1b: c3 ret
int ipow(int base, int exp) { int result = 1; for (;;) { if (exp & 1) result *= base; exp >>= 1; if (!exp) break; base *= base; } return result; }
x^15 = (x^7)*(x^7)*x x^7 = (x^3)*(x^3)*x x^3 = x*x*x
n*n = n^2 n^2*n = n^3 n^3*n^3 = n^6 n^6*n^6 = n^12 n^12*n^3 = n^15
2 ** 3 == 1 << 3 == 8 2 ** 30 == 1 << 30 == 1073741824 (A Gigabyte)
private int ipow(int base, int exp) { int result = 1; while (exp != 0) { if ((exp & 1) == 1) result *= base; exp >>= 1; base *= base; } return result; }
int pow( int base, int exponent) { if (exponent == 0) return 1; int temp = pow(base, exponent/2); if (exponent % 2 == 0) return temp * temp; else return (base * temp * temp); }
struct IeeeFloat { unsigned int base : 23; unsigned int exponent : 8; unsigned int signBit : 1; }; union IeeeFloatUnion { IeeeFloat brokenOut; float f; }; inline float twoToThe(char exponent) { static IeeeFloatUnion u; u.f = 2.0; u.brokenOut.exponent += (exponent - 1); return (u.f); }
int power(int base, unsigned int exp){ if (exp == 0) return 1; int temp = power(base, exp/2); if (exp%2 == 0) return temp*temp; else return base*temp*temp; }
float power(float base, int exp) { if( exp == 0) return 1; float temp = power(base, exp/2); if (exp%2 == 0) return temp*temp; else { if(exp > 0) return base*temp*temp; else return (temp*temp)/base; } }
intmax_t powjii(int x, int y) { if (y < 0) { switch (x) { case 0: return INTMAX_MAX; case 1: return 1; case -1: return y % 2 ? -1 : 1; } return 0; } intmax_t z = 1; intmax_t base = x; for (;;) { if (y % 2) { z *= base; } y /= 2; if (y == 0) { break; } base *= base; } return z; }
public static long pow(long base, long exp){ if(exp ==0){ return 1; } if(exp ==1){ return base; } if(exp % 2 == 0){ long half = pow(base, exp/2); return half * half; }else{ long half = pow(base, (exp -1)/2); return base * half * half; } }
private static int pow(int base, int exponent) { int result = 1; if (exponent == 0) return result; if (exponent < 0) return 1 / pow(base, -exponent); int temp = pow(base, exponent / 2); if (exponent % 2 == 0) return temp * temp; else return (base * temp * temp); }
public static int Power(int base, int exp) { int tab[] = new int[exp + 1]; tab[0] = 1; tab[1] = base; return Power(base, exp, tab); } public static int Power(int base, int exp, int tab[]) { if(exp == 0) return 1; if(exp == 1) return base; int i = 1; while(i < exp/2) { if(tab[2 * i] <= 0) tab[2 * i] = tab[i] * tab[i]; i = i << 1; } if(exp <= i) return tab[i]; else return tab[i] * Power(base, exp - i, tab); }
int pow(float base,float exp){ if (exp==0)return 1; else if(exp>0&&exp%2==0){ return pow(base*base,exp/2); }else if (exp>0&&exp%2!=0){ return base*pow(base,exp-1); } }
Mask1 = 1 << (Exponent - 1); Mask2 = Mask1 - 1; return Mask1 + Mask2;
template<unsigned long N> unsigned long inline exp_unroll(unsigned base) { return base * exp_unroll<N-1>(base); }
template<> unsigned long inline exp_unroll<1>(unsigned base) { return base; }
int main(int argc, char * argv[]) { std::cout << argv[1] <<"**5= " << exp_unroll<5>(atoi(argv[1])) << ;std::endl; }
int pow(int base, int pow) { int res = 1; for(int i=pow; i<pow; i++) res *= base; return res; }
for (var i = 1; i <= 100; i++) { if (i % 3 == 0) Console.Write("Fizz"); if (i % 5 == 0) Console.Write("Buzz"); if (i % 3 != 0 && i % 5 != 0) Console.Write(i); Console.WriteLine(); }
.locals init ( [0] int32 i) L_0000: ldc.i4.1 L_0001: stloc.0 L_0002: br.s L_003b L_0004: ldloc.0 L_0005: ldc.i4.3 L_0006: rem L_0007: brtrue.s L_0013 L_0009: ldstr "Fizz" L_000e: call void [mscorlib]System.Console::Write(string) L_0013: ldloc.0 L_0014: ldc.i4.5 L_0015: rem L_0016: brtrue.s L_0022 L_0018: ldstr "Buzz" L_001d: call void [mscorlib]System.Console::Write(string) L_0022: ldloc.0 L_0023: ldc.i4.3 L_0024: rem L_0025: brfalse.s L_0032 L_0027: ldloc.0 L_0028: ldc.i4.5 L_0029: rem L_002a: brfalse.s L_0032 L_002c: ldloc.0 L_002d: call void [mscorlib]System.Console::Write(int32) L_0032: call void [mscorlib]System.Console::WriteLine() L_0037: ldloc.0 L_0038: ldc.i4.1 L_0039: add L_003a: stloc.0 L_003b: ldloc.0 L_003c: ldc.i4.s 100 L_003e: ble.s L_0004 L_0040: ret
mov eax, 0x123 add eax, 0x456 push eax call printInt
_Generic(1, float: 2.0, char *: "2", int: 2, default: get_two_object());
long double: cbrtl, \ default: cbrt, \ float: cbrtf \ )(X)
foo_int (int a) foo_char (char b) foo_float_int (float c , int d) int: foo_int, \ char: foo_char, \ float: _Generic((FIRST(__VA_ARGS__,)), \ int: foo_float_int))(_1, __VA_ARGS__)
void print_ii(int a, int b) { printf("int, int\n"); } void print_di(double a, int b) { printf("double, int\n"); } void print_iii(int a, int b, int c) { printf("int, int, int\n"); } void print_default(void) { printf("unknown arguments\n"); } (print_ii, (int, int)), \ (print_di, (double, int)), \ (print_iii, (int, int, int)) \ ) int main(void) { print(44, 47); print(4.4, 47); print(1, 2, 3); print(""); }
typedef enum { T_INT, T_FLOAT, T_CHAR, } my_type; typedef struct { my_type type; union { int a; float b; char c; } my_union; } my_struct; void set_overload (my_struct *whatever) { switch (whatever->type) { case T_INT: whatever->my_union.a = 1; break; case T_FLOAT: whatever->my_union.b = 2.0; break; case T_CHAR: whatever->my_union.c = } } void printf_overload (my_struct *whatever) { switch (whatever->type) { case T_INT: printf("%d\n", whatever->my_union.a); break; case T_FLOAT: printf("%f\n", whatever->my_union.b); break; case T_CHAR: printf("%c\n", whatever->my_union.c); break; } } int main (int argc, char* argv[]) { my_struct s; s.type=T_INT; set_overload(&s); printf_overload(&s); s.type=T_FLOAT; set_overload(&s); printf_overload(&s); s.type=T_CHAR; set_overload(&s); printf_overload(&s); }
((__builtin_types_compatible_p(int, a)?foo(a):(__builtin_types_compatible_p(float, a)?foo(a):)
int addi(int a, int b) { return a + b; } char *adds(char *a, char *b) { char *res = malloc(strlen(a) + strlen(b) + 1); strcpy(res, a); strcat(res, b); return res; } int main(void) { int a = 1, b = 2; printf("%d\n", add(a, b)); char *c = "hello ", *d = "world"; printf("%s\n", add(c, d)); return 0; }
void printA(int a){ printf("Hello world from printA : %d\n",a); } void printB(const char *buff){ printf("Hello world from printB : %s\n",buff); } CHECK_ARGS_MIN_LIMIT(1) printf("error");fflush(stdout); \ CHECK_ARGS_MAX_LIMIT(4) printf("error");fflush(stdout); \ ({ \ if (__builtin_types_compatible_p (typeof (x), int)) \ printA(x, else \ printB (x, }) int main(int argc, char** argv) { int a=0; print(a); print("hello"); return (EXIT_SUCCESS); }
enum sum_arg_types { SUM_LONG, SUM_ULONG, SUM_DOUBLE }; struct sum_arg { enum sum_arg_types type; union { long as_long; unsigned long as_ulong; double as_double; } value; }; long double _sum(size_t count, struct sum_arg * args) { long double value = 0; for(size_t i = 0; i < count; ++i) { switch(args[i].type) { case SUM_LONG: value += args[i].value.as_long; break; case SUM_ULONG: value += args[i].value.as_ulong; break; case SUM_DOUBLE: value += args[i].value.as_double; break; } } return value; } int main() { unsigned long foo = -1; long double value = sum(sum_long(42), sum_ulong(foo), sum_double(1e10)); printf("%Le\n", value); return 0; }
extern void DecodeImageNow(CGImageRef image, CGContextRef usingContext) __attribute__((overloadable)); extern void DecodeImageNow(CGImageRef image) __attribute__((overloadable));
void __attribute__((overloadable)) DecodeImageNow(CGImageRef image, CGContextRef usingContext { ... } void __attribute__((overloadable)) DecodeImageNow(CGImageRef image) { ... }
int: foo_int, \ char: foo_char, \ double: foo_double \ ) double: _Generic((_2), \ int: foo_double_int \ ) \ )
( \ HAS_COMMA(__VA_ARGS__), \ HAS_COMMA(__VA_ARGS__ ()), \ HAS_COMMA(SET_COMMA __VA_ARGS__), \ HAS_COMMA(SET_COMMA __VA_ARGS__ ()) \ )
/* * demo.c * * Created on: 2017-09-14 * Author: sboehler */ void foo_void(void) { puts("void"); } void foo_int(int c) { printf("int: %d\n", c); } void foo_char(char c) { printf("char: %c\n", c); } void foo_double(double c) { printf("double: %.2f\n", c); } void foo_double_int(double c, int d) { printf("double: %.2f, int: %d\n", c, d); } int: foo_int, \ char: foo_char, \ double: foo_double \ ) double: _Generic((_2), \ int: foo_double_int \ ) \ ) ( \ HAS_COMMA(__VA_ARGS__), \ HAS_COMMA(__VA_ARGS__ ()), \ HAS_COMMA(SET_COMMA __VA_ARGS__), \ HAS_COMMA(SET_COMMA __VA_ARGS__ ()) \ ) int main(int argc, char** argv) { foo(); foo(7); foo(10.12); foo(12.10, 7); foo((char) return 0; }
int fun(int a, ...); int main(int argc, char *argv[]){ fun(1,10); fun(2,"cquestionbank"); return 0; } int fun(int a, ...){ va_list vl; va_start(vl,a); if(a==1) printf("%d",va_arg(vl,int)); else printf("\n%s",va_arg(vl,char *)); }
union { int i; float f; } u; u.f = 3.14159f; printf("As integer: %08x\n", u.i);
enum Type { INTS, FLOATS, DOUBLE }; struct S { Type s_type; union { int s_ints[2]; float s_floats[2]; double s_double; }; }; void do_something(struct S *s) { switch(s->s_type) { case INTS: break; case FLOATS: break; case DOUBLE: break; } }
typedef union { struct { unsigned char byte1; unsigned char byte2; unsigned char byte3; unsigned char byte4; } bytes; unsigned int dword; } HW_Register; HW_Register reg;
typedef union { struct { unsigned char b1:1; unsigned char b2:1; unsigned char b3:1; unsigned char b4:1; unsigned char reserved:4; } bits; unsigned char byte; } HW_RegisterB; HW_RegisterB reg;
typedef union { unsigned char control_byte; struct { unsigned int nibble : 4; unsigned int nmi : 1; unsigned int enabled : 1; unsigned int fired : 1; unsigned int control : 1; }; } ControlRegister;
struct Connection { int type; union { struct Network network; struct USB usb; struct Virtual virtual; } };
struct _mydata { int which_one; union _data { int a; float b; char c; } foo; } bar; switch (bar.which_one) { case INTEGER : break; case FLOATING : break; case CHARACTER: break; }
typedef struct { int typ; union { char *str; int val; } } tElem;
tElem e; e.typ = ELEM_VARIABLE; e.str = strdup ("b");
+-----------+ 0x1010 | | 0x1011 | typ | 0x1012 | | 0x1013 | | +-----+-----+ 0x1014 | | | 0x1015 | str | val | 0x1016 | | | 0x1017 | | | +-----+-----+
+-------+ 0x1010 | | 0x1011 | typ | 0x1012 | | 0x1013 | | +-------+ 0x1014 | | 0x1015 | str | 0x1016 | | 0x1017 | | +-------+ 0x1018 | | 0x1019 | val | 0x101A | | 0x101B | | +-------+
struct variant { int type; double number; char *string; };
struct variant { int type; union { double number; char *string; } value; };
typedef union MyUnion MYUNION; union MyUnion { int MyInt; float MyFloat; };
typedef union { UINT8 buffer[PACKET_SIZE]; struct { UINT8 size; UINT8 cmd; UINT8 payload[PAYLOAD_SIZE]; UINT8 crc; } fields; }PACKET_T; void packet_builder(UINT8* buffer, UINT8 data) { static UINT8 received_bytes = 0; buffer[received_bytes] = data; received_bytes++; } void packet_handler(PACKET_T* packet) { if(packet->fields.size > TOO_BIG) { } if(packet->fields.cmd == CMD_X) { } }
typedef union { unsigned char color[4]; int new_color; } u_color;
union data { int data; struct { unsigned char higher; unsigned char lower; } parts; };
union _Obj { union _Obj* _M_free_list_link; char _M_client_data[1]; };
struct x {int x_mode; int q; float x_f}; struct y {int y_mode; int q; int y_l}; struct z {int z_mode; char name[20];};
union un { uint16_t array16[4]; uint32_t array32[2]; }
double cosinus(double x,double prec) { double t , s ; int p; p = 0; s = 1.0; t = 1.0; while(fabs(t/s) > prec) { p++; t = (-t * x * x) / ((2 * p - 1) * (2 * p)); s += t; } return s;}
float sin(float x) { float res=0, pow=x, fact=1; for(int i=0; i<5; ++i) { res+=pow/fact; pow*=-1*x*x; fact*=(2*(i+1))*(2*(i+1)+1); } return res; }
double sin (double x){ int i = 1; double cur = x; double acc = 1; double fact= 1; double pow = x; while (fabs(acc) > .00000001 && i < 100){ fact *= ((2*i)*(2*i+1)); pow *= -1 * x*x; acc = pow / fact; cur += acc; i++; } return cur; }
double _pow(double a, double b) { double c = 1; for (int i=0; i<b; i++) c *= a; return c; } double _fact(double x) { double ret = 1; for (int i=1; i<=x; i++) ret *= i; return ret; } double _sin(double x) { double y = x; double s = -1; for (int i=3; i<=100; i+=2) { y+=s*(_pow(x,i)/_fact(i)); s *= -1; } return y; } double _cos(double x) { double y = 1; double s = -1; for (int i=2; i<=100; i+=2) { y+=s*(_pow(x,i)/_fact(i)); s *= -1; } return y; } double _tan(double x) { return (_sin(x)/_cos(x)); }
typedef struct { char* model; int year; ... } car_t;
typedef unsigned char uint8_t; typedef unsigned short int uint16_t; typedef unsigned int uint32_t; typedef unsigned long int uint64_t; __extension__ typedef unsigned long long int uint64_t;
extern int function_1(void); static int function_2(void); int function_3(void);
void main(void){ int v1 = function_1(); int v2 = function_2(); int v3 = function_3(); } int function_2(void) return 1234;
void old_main_test(void){ int v1 = function_1(); int v2 = function_2(); int v3 = function_3(); } int function_2(void) return 5678; int function_1(void) return 12; int function_3(void) return 34;
long long strtonum(const char *nptr, long long minval, long long maxval, const char **errstr);
uintmax_t num = strtoumax(s, NULL, 10); if (num == UINTMAX_MAX && errno == ERANGE)
typedef enum { STR2INT_SUCCESS, STR2INT_OVERFLOW, STR2INT_UNDERFLOW, STR2INT_INCONVERTIBLE } str2int_errno; /* Convert string s to int out. * * @param[out] out The converted int. Cannot be NULL. * * @param[in] s Input string to be converted. * * The format is the same as strtol, * except that the following are inconvertible: * * - empty string * - leading whitespace * - any trailing characters that are not part of the number * * Cannot be NULL. * * @param[in] base Base to interpret string in. Same range as strtol (2 to 36). * * @return Indicates if the operation succeeded, or why it failed. */ str2int_errno str2int(int *out, char *s, int base) { char *end; if (s[0] == return STR2INT_INCONVERTIBLE; errno = 0; long l = strtol(s, &end, base); if (l > INT_MAX || (errno == ERANGE && l == LONG_MAX)) return STR2INT_OVERFLOW; if (l < INT_MIN || (errno == ERANGE && l == LONG_MIN)) return STR2INT_UNDERFLOW; if (*end != return STR2INT_INCONVERTIBLE; *out = l; return STR2INT_SUCCESS; } int main(void) { int i; char s[256]; assert(str2int(&i, "11", 10) == STR2INT_SUCCESS); assert(i == 11); assert(str2int(&i, "-11", 10) == STR2INT_SUCCESS); assert(i == -11); assert(str2int(&i, "11", 16) == STR2INT_SUCCESS); assert(i == 17); assert(str2int(&i, "0", 10) == STR2INT_SUCCESS); assert(i == 0); sprintf(s, "%d", INT_MAX); assert(str2int(&i, s, 10) == STR2INT_SUCCESS); assert(i == INT_MAX); sprintf(s, "%d", INT_MIN); assert(str2int(&i, s, 10) == STR2INT_SUCCESS); assert(i == INT_MIN); assert(str2int(&i, " 1", 10) == STR2INT_INCONVERTIBLE); assert(str2int(&i, "1 ", 10) == STR2INT_INCONVERTIBLE); assert(str2int(&i, "a10", 10) == STR2INT_INCONVERTIBLE); assert(str2int(&i, "10a", 10) == STR2INT_INCONVERTIBLE); /* int overflow. * * `if` needed to avoid undefined behaviour * on `INT_MAX + 1` if INT_MAX == LONG_MAX. */ if (INT_MAX < LONG_MAX) { sprintf(s, "%ld", (long int)INT_MAX + 1L); assert(str2int(&i, s, 10) == STR2INT_OVERFLOW); } if (LONG_MIN < INT_MIN) { sprintf(s, "%ld", (long int)INT_MIN - 1L); assert(str2int(&i, s, 10) == STR2INT_UNDERFLOW); } sprintf(s, "%ld0", LONG_MAX); assert(str2int(&i, s, 10) == STR2INT_OVERFLOW); sprintf(s, "%ld0", LONG_MIN); assert(str2int(&i, s, 10) == STR2INT_UNDERFLOW); return EXIT_SUCCESS; }
int my_getnbr(char *str) { int result; int puiss; result = 0; puiss = 1; while (( { if (*str == puiss = puiss * -1; str++; } while ((*str >= { result = (result * 10) + ((*str) - str++; } return (result * puiss); }
unsigned long ToUInt(char* str) { unsigned long mult = 1; unsigned long re = 0; int len = strlen(str); for(int i = len -1 ; i >= 0 ; i--) { re = re + ((int)str[i] -48)*mult; mult = mult*10; } return re; }
int my_atoi(const char* snum) { int idx, strIdx = 0, accum = 0, numIsNeg = 0; const unsigned int NUMLEN = (int)strlen(snum); if(snum[0] == 0x2d) numIsNeg = 1; for(idx = NUMLEN - 1; idx >= 0; idx--) { if(snum[strIdx] >= 0x30 && snum[strIdx] <= 0x39) accum += (snum[strIdx] - 0x30) * pow(10, idx); strIdx++; } if(!numIsNeg) return accum; else return accum * -1; } int main() { printf("Returned number is: %d\n", my_atoi("34574")); printf("Returned number is: %d\n", my_atoi("-23")); return 0; }
int strtoint_n(char* str, int n) { int sign = 1; int place = 1; int ret = 0; int i; for (i = n-1; i >= 0; i--, place *= 10) { int c = str[i]; switch (c) { case if (i == 0) sign = -1; else return -1; break; default: if (c >= else return -1; } } return sign * ret; } int strtoint(char* str) { char* temp = str; int n = 0; while (*temp != { n++; temp++; } return strtoint_n(str, n); }
void splitInput(int arr[], int sizeArr, char num[]) { for(int i = 0; i < sizeArr; i++) arr[i] = (int)num[i] - 48; }
int my_atoi(const char* snum) { int nInt(0); int index(0); while(snum[index]) { if(!nInt) nInt= ( (int) snum[index]) - 48; else { nInt = (nInt *= 10) + ((int) snum[index] - 48); } index++; } return(nInt); } int main() { printf("Returned number is: %d\n", my_atoi("676987")); return 0; }
template <typename T> T to(const std::string & s) { std::istringstream stm(s); T result; stm >> result; if(stm.tellg() != s.size()) throw error; return result; }
int main(void) { char foo = switch(foo) { printf("Cant Touch This\n"); case case case case } return 0; }
switch (foo) { int i; case 0: i = 0; case 1: i = 1; }
switch (expr) { int i = 4; f(i); case 0: i = 17; default: printf("%d\n", i); }
switch (a) { int i; case 0: i = f(); g(); h(i); break; case 1: i = g(); f(); h(i); break; }
switch (i) { for (;;) { f(); case 1: g(); case 2: if (h()) break; } }
int n = (count+3)/4; switch (count % 4) { do { case 0: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n > 0); }
int main() { int i = 1; switch(i) { nocase: printf("no case\n"); case 0: printf("0\n"); break; case 1: printf("1\n"); goto nocase; } return 0; }
int n = ...; int iterations = n/8; switch(n%8) { while(iterations--) { sum += *ptr++; case 7: sum += *ptr++; case 6: sum += *ptr++; case 5: sum += *ptr++; case 4: sum += *ptr++; case 3: sum += *ptr++; case 2: sum += *ptr++; case 1: sum += *ptr++; case 0: ; } }
switch (expr) { int i = 4; f(i); case 0: i = 17; default: printf("%d\n", i); }
char password[100]; switch(0) do { printf("Invalid password, try again.\n"); default: read_password(password, sizeof(password)); } while (!is_valid_password(password));
struct foo { int x; float y; }; struct foo var; struct foo* pvar; var.x = 5; (&var)->y = 14.3; pvar->y = 22.4; (*pvar).x = 6;
struct Node { int i; int j; }; struct Node a, *p = &a;
int main() { struct foo { int x; float y; }; struct foo var; struct foo* pvar; pvar = &var; var.x = 5; (&var)->y = 14.3; printf("%i - %.02f\n", var.x, (&var)->y); pvar->x = 6; pvar->y = 22.4; printf("%i - %.02f\n", pvar->x, pvar->y); return 0; }
int main() { struct foo { int x; float y; } var1; struct foo var; struct foo* pvar; pvar = &var1; var.x = 5; (&var)->y = 14.3; printf("%i - %.02f\n", var.x, (&var)->y); pvar->x = 6; pvar->y = 22.4; printf("%i - %.02f\n", pvar->x, pvar->y); return 0; }
typedef EFI_STATUS (EFIAPI *EFI_BLOCK_READ)( IN EFI_BLOCK_IO_PROTOCOL *This, IN UINT32 MediaId, IN EFI_LBA Lba, IN UINTN BufferSize, OUT VOID *Buffer ); struct _EFI_BLOCK_IO_PROTOCOL { UINT64 Revision; EFI_BLOCK_IO_MEDIA *Media; EFI_BLOCK_RESET Reset; EFI_BLOCK_READ ReadBlocks; EFI_BLOCK_WRITE WriteBlocks; EFI_BLOCK_FLUSH FlushBlocks; };
struct student { int s.no; Char name []; int age; } s1,s2; main() { s1.name; s2.name; }
struct examp{ int number; }; struct examp a,*b=&a;`enter code here` main() { a.number=5; /* a.number,b->number,(*b).number produces same output. b->number is mostly used in linked list*/ printf("%d \n %d \n %d",a.number,b->number,(*b).number); }
unsigned int x = 0; unsigned short *p = (unsigned short*)&x; p[0] = 1; printf("%u = %u\n", x, *p);
$ c99 -O2 -Wall a.c && ./a.out a.c: In function ‘main’: a.c:6: warning: dereferencing pointer ‘p’ does break strict-aliasing rules a.c:5: note: initialized from here 0 = 1?
int main(int argc, char *argv[]) { int q = 10; int *p = &q; printf("address of q is %p\n", (void *)&q); printf("p contains %p\n", (void *)p); p = NULL; printf("NULL p now contains %p\n", (void *)p); return 0; }
LinearAddress = SegmentRegister[SegNum].base << 4 + Offset
LinearAddress = SegmentRegister[SegNum].base + offset
+ : A variable of type integer (usually called offset) can be added to yield a new pointer - : A variable of type integer (usually called offset) can be subtracted to yield a new pointer : A variable of type pointer can be subtracted to yield an integer (usually called offset) * : De-referencing. Retrieve the value of the variable (called address) and map to the object the address refers to. ++: It --: It
unsigned int i = 0; unsigned short* p = (unsigned short*)&i; p[0]=p[1]=1; if (i == 2 + (unsigned short)(-1)) { } if (i == 0) { }
Selector +--------------+ +-----------+ ---------->| | | | | Segmentation | ------->| Paging | Offset | Mechanism | | Mechanism | ---------->| | | | +--------------+ +-----------+ Virtual Linear Physical
int wordsinsentence(char **x) { int w = 0; while (*x) { w += 1; x++; } return w; } int wordsinmono(char ***x) { int w = 0; while (*x) { w += wordsinsentence(*x); x++; } return w; } int wordsinbio(char ****x) { int w = 0; while (*x) { w += wordsinmono(*x); x++; } return w; } int wordsinlib(char *****x) { int w = 0; while (*x) { w += wordsinbio(*x); x++; } return w; } int wordsinlol(char ******x) { int w = 0; while (*x) { w += wordsinlib(*x); x++; } return w; } int main(void) { char *word; char **sentence; char ***monologue; char ****biography; char *****biolibrary; char ******lol; word = malloc(4 * sizeof *word); strcpy(word, "foo"); sentence = malloc(4 * sizeof *sentence); sentence[0] = word; sentence[1] = word; sentence[2] = word; sentence[3] = NULL; monologue = malloc(4 * sizeof *monologue); monologue[0] = sentence; monologue[1] = sentence; monologue[2] = sentence; monologue[3] = NULL; biography = malloc(4 * sizeof *biography); biography[0] = monologue; biography[1] = monologue; biography[2] = monologue; biography[3] = NULL; biolibrary = malloc(4 * sizeof *biolibrary); biolibrary[0] = biography; biolibrary[1] = biography; biolibrary[2] = biography; biolibrary[3] = NULL; lol = malloc(4 * sizeof *lol); lol[0] = biolibrary; lol[1] = biolibrary; lol[2] = biolibrary; lol[3] = NULL; printf("total words in my lol: %d\n", wordsinlol(lol)); free(lol); free(biolibrary); free(biography); free(monologue); free(sentence); free(word); }
void allocate(int** p) { *p = (int*)malloc(sizeof(int)); } int main() { int* p = NULL; allocate(&p); *p = 42; free(p); }
int main() { int c = 1; int d = 2; int e = 3; int * a = &c; int * b = &d; int * f = &e; int ** pp = &a; printf("\n a printf("\n b printf("\n f printf("\n can we change a?, lets see \n"); printf("\n a = b \n"); a = b; printf("\n a printf("\n cant_change(a, f); \n"); cant_change(a, f); printf("\n a printf("\n NOW! lets see if a pointer to a pointer solution can help us... remember that printf("\n change(pp, f); \n"); change(pp, f); printf("\n a return 0; } void cant_change(int * x, int * z){ x = z; printf("\n ----> value of } void change(int ** x, int * z){ *x = z; printf("\n ----> value of }
a b f can we change a?, lets see a = b a cant_change(a, f); ----> value of a NOW! lets see if a pointer to a pointer solution can help us... remember that change(pp, f); ----> value of a
void alloc2(int** p) { *p = (int*)malloc(sizeof(int)); **p = 10; } void alloc1(int* p) { p = (int*)malloc(sizeof(int)); *p = 10; } int main(){ int *p; alloc1(p); alloc2(&p); printf("%d ",*p); free(p); return 0; }
int main() { char **p; p = (char **)malloc(100); p[0] = (char *)"Apple"; p[1] = (char *)"Banana"; cout << *p << endl; cout << **p << endl; *p++; cout << *p; }
void func(char ch) { ch = } int main() { char ptr; ptr = printf("%c", ptr); func(ptr); printf("%c\n", ptr); }
void func( char *ptr) { *ptr = } int main() { char *ptr; ptr = (char *)malloc(sizeof(char) * 1); *ptr = printf("%c\n", *ptr); func(ptr); printf("%c\n", *ptr); }
void func(char **str) { strcpy(str, "Second"); } int main() { char **str; *str = (char **)malloc(sizeof(char) * 10); int i = 0; for(i=0;i<10;i++) { str = (char *)malloc(sizeof(char) * 1); } strcpy(str, "First"); printf("%s\n", str); func(str); printf("%s\n", str); }
typedef struct node { struct node * next; .... } node;
for (node * prev = NULL, * curr = head; curr != NULL; ) { node * const next = curr->next; if (rm(curr)) { if (prev) prev->next = next; else head = next; free(curr); } else prev = curr; curr = next; }
for (node** curr = head; *curr; ) { node * entry = *curr; if (rm(entry)) { *curr = entry->next; free(entry); } else curr = &entry->next; }
typedef unsigned char** handle_type; typedef struct { int data_a; int data_b; int data_c; } LIB_OBJECT; handle_type lib_create_handle() { handle_type handle = malloc(sizeof(handle_type)); *handle = malloc(sizeof(LIB_OBJECT) * 10); return handle; } void lib_func_a(handle_type handle) { } void lib_func_b(handle_type handle) { *handle = realloc(*handle, sizeof(LIB_OBJECT) * 20); } void lib_func_c(handle_type handle) { } void lib_free_handle(handle_type handle) { free(*handle); free(handle); } int main() { handle_type my_handle = lib_create_handle(); lib_func_a(my_handle); lib_func_b(my_handle); lib_func_c(my_handle); lib_free_handle(my_handle); return 0; }
void Function_1(std::string* a, std::string* b) { b = a; std::cout << (b == nullptr); } void Function_2(std::string* a, std::string** b) { *b = a; std::cout << (b == nullptr); } int main() { std::string a("Hello!"); std::string* b(nullptr); std::cout << (b == nullptr); Function_1(&a, b); std::cout << (b == nullptr); Function_2(&a, &b); std::cout << (b == nullptr); }
void safeFree(void** memory) { if (*memory) { free(*memory); *memory = NULL; } }
void* myMemory = someCrazyFunctionThatAllocatesMemory(); safeFree(&myMemory);
T ** p = (T **) malloc(sizeof(T*) * n); p[0] = (T*) malloc(sizeof(T)); p[1] = (T*) malloc(sizeof(T));
int num_objects; OBJECT *original_array = malloc(sizeof(OBJECT)*num_objects);
int compare_object_by_name( const void *v1, const void *v2 ) { OBJECT *o1 = *(OBJECT **)v1; OBJECT *o2 = *(OBJECT **)v2; return (strcmp(o1->name, o2->name); } OBJECT **object_ptrs_by_name = malloc(sizeof(OBJECT *)*num_objects); int i = 0; for( ; i<num_objects; i++) object_ptrs_by_name[i] = original_array+i; qsort(object_ptrs_by_name, num_objects, sizeof(OBJECT *), compare_object_by_name);
using namespace std; void change(char **temp) { strcpy(temp[0],"new"); strcpy(temp[1],"value"); } int main() { char **str; str = (char **)malloc(sizeof(char *)*3); str[0]=(char *)malloc(10); str[1]=(char *)malloc(10); strcpy(str[0],"old"); strcpy(str[1],"name"); char **temp = str; while(*temp!=NULL) { cout<<*temp<<endl; temp++; } temp = str; change(str); while(*temp!=NULL) { cout<<*temp<<endl; temp++; } free(temp); free(str[0]); free(str[1]); free(str);
typedef struct Person{ char * name; } Person; /** * we need a ponter to a pointer, example: &studentA */ void change(Person ** x, Person * y){ *x = y; } void dontChange(Person * x, Person * y){ x = y; } int main() { Person * studentA = (Person *)malloc(sizeof(Person)); studentA->name = "brian"; Person * studentB = (Person *)malloc(sizeof(Person)); studentB->name = "erich"; /** * we could have done the job as simple as this! * but we need more work if we want to use a function to do the job! */ printf("1. studentA = %s (not changed)\n", studentA->name); dontChange(studentA, studentB); printf("2. studentA = %s (not changed)\n", studentA->name); change(&studentA, studentB); printf("3. studentA = %s (changed!)\n", studentA->name); return 0; } /** * OUTPUT: * 1. studentA = brian (not changed) * 2. studentA = brian (not changed) * 3. studentA = erich (changed!) */
int* setptr(int *x) { printf("%u\n",&x); x=malloc(sizeof(int)); *x=1; return x; } In the above function setptr we can manipulate x either 1. by taking fn arg as int *x , doing malloc and setting value of x and return x Or 2. By taking arg as int ** and malloc and then set **x value to some value. Note: we cant set any general pointer directly without doing malloc.Pointer indicates that it is a type of variable which can hold address of any data type.Now either we define a variable and give reference to it or we declare a pointer(int *x=NULL) and allocate some memory to it inside the called function where we pass x or a reference to it .. In either case we need to have address of a memory in the pointer and in the case pointer initially points to NULL or it is defined like int *x where it points to any random address then we need to assign a valid memory address to pointer 1. either we need to allocate memory to it by malloc int *x=NULL means its address is 0. Now we need to either o following 1. void main() { int *x; x=malloc *x=some_val; } Or void main() { int *x Fn(x); } void Fn(int **x) { *x=malloc; **x=5; } OR int * Fn(int *x) { x=malloc(); *x=4; Return x; } 2. Or we need to point it to a valid memory like a defined variable inside the function where pointer is defined. OR int main() { int a; int *x=&a; Fn(x); printf("%d",*x); } void Fn(int *x) { *x=2; } in both cases value pointed by x is changed inside fn But suppose if we do like int main() { int *x=NULL; printf("%u\n",sizeof(x)); printf("%u\n",&x); x=setptr(x); printf("%d\n",*x); return 0; } void setptr(int *x) { printf("inside setptr\n"); printf("x=%u\n",x); printf("&x=%u\n",&x); *x=1; } int main() { int *x=NULL; printf("x=%u\n",x); printf("&x=%u\n",&x); int a; x=&a; printf("x=%u\n",x); printf("&a=%u\n",&a); printf("&x=%u\n",&x); setptr(x); printf("inside main again\n"); printf("x=%u\n",x); printf("&x=%u\n",&x); printf("*x=%d\n",*x); printf("a=%d\n",a); return 0; }
void func(char **str) { strcpy(str[0],"second"); } int main(){ char **str; str = (char **)malloc(sizeof(char*)*1); str[0] = (char *)malloc(sizeof(char)*10); strcpy(str[0],"first"); printf("%s\n",*str); func(str); printf("%s\n",*str); free(str[0]); free(str); }
1) try to understand the following statements char **str ; a) str is of type char ** whose value is an address of another pointer. b) *str is of type char * whose value is an address of variable or (it is a string itself). c) **str is of type char ,gives the value stored, in this case a character.
str = (char **)malloc(sizeof(char *) *2); str[0]=(char *)"abcdefghij"; str[1]=(char *)"xyzlmnopqr";
extern SignalHandler signal(int signum, SignalHandler handler);
extern void (*signal(int, void()(int)))(int); typedef void (*SignalHandler)(int signum); extern SignalHandler signal(int signum, SignalHandler handler);
static void alarm_catcher(int signum) { fprintf(stderr, "%s() called (%d)\n", __func__, signum); } static void signal_catcher(int signum) { fprintf(stderr, "%s() called (%d) - exiting\n", __func__, signum); exit(1); } static struct Handlers { int signum; SignalHandler handler; } handler[] = { { SIGALRM, alarm_catcher }, { SIGINT, signal_catcher }, { SIGQUIT, signal_catcher }, }; int main(void) { size_t num_handlers = sizeof(handler) / sizeof(handler[0]); size_t i; for (i = 0; i < num_handlers; i++) { SignalHandler old_handler = signal(handler[i].signum, SIG_IGN); if (old_handler != SIG_IGN) old_handler = signal(handler[i].signum, handler[i].handler); assert(old_handler == SIG_IGN); } ...continue with ordinary processing... return(EXIT_SUCCESS); }
extern SignalHandler signal(int signum, SignalHandler handler);
extern void (*signal(int signum, void(*handler)(int signum)))(int signum);
extern void (*signal(int signum, SignalHandler handler))(int signum); extern void (*signal(int signum, void (*handler)(int signum)))(int signum);
float doMultiplication (float num1, float num2 ) { return num1 * num2; }
int add(int a, int b) { return (a+b); } typedef int (*add_integer)(int, int); int main() { add_integer addition = add; int c = addition(11, 11); printf("%d",c); return 0; }
typedef int (*FUNC_TYPE_1)(void); typedef double (*FUNC_TYPE_2)(void); typedef FUNC_TYPE_1 (*FUNC_TYPE_3)(FUNC_TYPE_2);
typedef int (*(*FUNC_TYPE_3)(double (*)(void)))(void);
cdecl> explain int (*FUNC_TYPE_1)(void) declare FUNC_TYPE_1 as pointer to function (void) returning int cdecl> explain double (*FUNC_TYPE_2)(void) declare FUNC_TYPE_2 as pointer to function (void) returning double cdecl> declare FUNC_TYPE_3 as pointer to function (pointer to function (void) returning double) returning pointer to function (void) returning int int (*(*FUNC_TYPE_3)(double (*)(void )))(void )
int add(int a, int b) { return (a+b); } int minus(int a, int b) { return (a-b); } typedef int (*math_func)(int, int); int main() { math_func addition = add; math_func substract = minus; int c = addition(11, 11); printf("%d\n",c); c = substract(11, 5); printf("%d",c); return 0; }
typedef double (*pf)(double x); double f1(double x) { return(x+x);} double f2(double x) { return(x*x);} pf pa[] = {f1, f2}; main() { pf p; p = pa[0]; printf("%f\n", p(3.0)); p = pa[1]; printf("%f\n", p(3.0)); }
typedef int (*action_handler_t)(void *ctx, void *data);
typedef struct { state_t curr_state; event_t event; state_t next_state; action_handler_t event_handler; }state_element;
int handle_event_a(void *fsm_ctx, void *in_msg ); int handle_event_b(void *fsm_ctx, void *in_msg );
typedef struct { uint8_t flag1:1; uint8_t flag2:1; padding1 reserved:6; uint32_t sequence_no; uint8_t data[8]; uint32_t crc32; } s_mypacket __attribute__((packed));
int main(void) { int x; for (x = 0; x < 10; x++) if (x % 2) printf("%d is odd\n", x); return 0; } int main(void) { int x; for (x = 0; x < 10; x++) if (x & 1) printf("%d is odd\n", x); return 0; }
public boolean isOdd(int num) { int i = 0; boolean odd = false; while (i != num) { odd = !odd; i = i + 1; } return odd; }
if((x & 1) == 0) printf("EVEN!\n"); else printf("ODD!\n");
public enum Evenness { Unknown = 0, Even = 1, Odd = 2 } public static Evenness AnalyzeEvenness(object o) { if (o == null) return Evenness.Unknown; string foo = o.ToString(); if (String.IsNullOrEmpty(foo)) return Evenness.Unknown; char bar = foo[foo.Length - 1]; switch (bar) { case case case case case return Evenness.Even; case case case case case return Evenness.Odd; default: return Evenness.Unknown; } }
isEven = (x & 1) ^ ((-1 & 1) | ((x < 0) ? 0 : 1)));
bool isOdd(unsigned int n); bool isEven(unsigned int n) { if (n == 0) return true ; else return isOdd(n-1) ; } bool isOdd(unsigned int n) { if (n == 0) return false ; else return isEven(n-1) ; }
public static boolean isOdd(int num){ return num % 2 != 0; } int isOdd(int num){ return num % 2; }
bool isEven(unsigned int x) { unsigned int half1 = 0, half2 = 0; while (x) { if (x) { half1++; x--; } if (x) { half2++; x--; } } return half1 == half2; }
typedef unsigned int uint; char parity_uint [UINT_MAX]; char parity_sint_shifted [((uint) INT_MAX) + ((uint) abs (INT_MIN))]; char* parity_sint = parity_sint_shifted - INT_MIN; void build_parity_tables () { char parity = 0; unsigned int ui; for (ui = 1; ui <= UINT_MAX; ++ui) { parity_uint [ui - 1] = parity; parity = !parity; } parity = 0; int si; for (si = 1; si <= INT_MAX; ++si) { parity_sint [si - 1] = parity; parity = !parity; } parity = 1; for (si = -1; si >= INT_MIN; --si) { parity_sint [si] = parity; parity = !parity; } } char uparity (unsigned int n) { if (n == 0) { return 0; } return parity_uint [n - 1]; } char sparity (int n) { if (n == 0) { return 0; } if (n < 0) { ++n; } return parity_sint [n - 1]; }
char even (int n) { int k; for (k = INT_MIN; k <= INT_MAX; ++k) { if (n == 2 * k) { return 1; } } return 0; } char odd (int n) { int k; for (k = INT_MIN; k <= INT_MAX; ++k) { if (n == 2 * k + 1) { return 1; } } return 0; }
if ((x & 1) == 0) total += 1; else total -= 1; System.Math.DivRem((long)x, (long)2, out outvalue); if ( outvalue == 0) total += 1; else total -= 1; if (((x / 2) * 2) == x) total += 1; else total -= 1; if (((x >> 1) << 1) == x) total += 1; else total -= 1; while (index > 1) index -= 2; if (index == 0) total += 1; else total -= 1; tempstr = x.ToString(); index = tempstr.Length - 1; if (tempstr[index] == total += 1; else total -= 1;
public static boolean isEven (Integer Number) { Pattern number = Pattern.compile("^.*?(?:[02]|8|(?:6|4))$"); String num = Number.toString(Number); Boolean numbr = new Boolean(number.matcher(num).matches()); return numbr.booleanValue(); }
a = 10101011 ----------------- a>>1 --> 01010101 a<<1 --> 10101010 b = 10011100 ----------------- b>>1 --> 01001110 b<<1 --> 10011100
static dbl IntPow(dbl st0, int x) { UINT OrMask = UINT_MAX -1; dbl st1=1.0; if(0==x) return (dbl)1.0; while(1 != x) { if (UINT_MAX == (x|OrMask)) { st1 *= st0; } x = x >> 1; st0 *= st0; } return st1 * st0; }
int isOdd_mod(unsigned x) { return (x % 2); } int isOdd_and(unsigned x) { return (x & 1); } int isOdd_or(unsigned x) { return (0xFFFFFFFF == (x | 0xFFFFFFFE)); }
isOdd_mod(unsigned int): and edi, 1 mov eax, edi ret isOdd_and(unsigned int): and edi, 1 mov eax, edi ret isOdd_or(unsigned int): and edi, 1 mov eax, edi ret
isOdd_mod(unsigned int): mov eax, edi and eax, 1 ret isOdd_and(unsigned int): mov eax, edi and eax, 1 ret isOdd_or(unsigned int): or edi, -2 xor eax, eax cmp edi, -1 sete al ret
test bl,1 je (some address) test bl,1 je (some address) mov eax,ebx or eax,0FFFFFFFEh cmp eax,0FFFFFFFFh jne (some address)
double get_time() { struct timeval t; struct timezone tzp; gettimeofday(&t, &tzp); return t.tv_sec + t.tv_usec*1e-6; } double get_time() { LARGE_INTEGER t, f; QueryPerformanceCounter(&t); QueryPerformanceFrequency(&f); return (double)t.QuadPart / (double)f.QuadPart * 1000.0; } double startTime = get_time(); \ double dummySum = 0.0, elapsed; \ int x; \ for (x = 0; x < NUM_ITERATIONS; x++) { \ if (operation) dummySum += x; \ } \ elapsed = get_time() - startTime; \ accumulator += elapsed; \ if (dummySum > 2000) \ printf("[Test: %-12s] %0.2f ms\r\n", name, elapsed); \ } void DumpAverage(char *test, double totalTime, double reference) { printf("[Test: %-12s] AVERAGE TIME: %0.2f ms (Relative diff.: %+6.3f%%)\r\n", test, totalTime, (totalTime - reference) / reference * 100.0); } int main(void) { int repeats = 20; double runningTimes[3] = { 0 }; int k; for (k = 0; k < repeats; k++) { printf("Run %d of %d...\r\n", k + 1, repeats); Benchmark(runningTimes[0], "Plain mod 2", (x % 2)); Benchmark(runningTimes[1], "Bitwise or", (0xFFFFFFFF == (x | 0xFFFFFFFE))); Benchmark(runningTimes[2], "Bitwise and", (x & 1)); } { double reference = runningTimes[0] / repeats; printf("\r\n"); DumpAverage("Plain mod 2", runningTimes[0] / repeats, reference); DumpAverage("Bitwise or", runningTimes[1] / repeats, reference); DumpAverage("Bitwise and", runningTimes[2] / repeats, reference); } getchar(); return 0; }
public static class RudiGroblerExtensions { public static bool IsOdd(this int i) { return ((i % 2) != 0); } }
int isOdd(int n) { return n ^ n * n ? isOdd(n * n) : n; }
__declspec(naked) bool __fastcall isOdd(const int x) { __asm { mov eax,ecx mul eax mul eax mul eax mul eax mul eax mul eax ret } }
i & 1 ? odd : even; i << (BITS_PER_INT - 1) ? odd : even;
def parity(number): return (number == 0 and or (number&1 and for number in range(0, 14): print "{0:>4} : {0:08b} : {1:}".format(number, parity(number))
0 : 00000000 : Zero neither ODD nor EVEN 1 : 00000001 : ODD 2 : 00000010 : EVEN 3 : 00000011 : ODD 4 : 00000100 : EVEN 5 : 00000101 : ODD 6 : 00000110 : EVEN 7 : 00000111 : ODD 8 : 00001000 : EVEN 9 : 00001001 : ODD 10 : 00001010 : EVEN 11 : 00001011 : ODD 12 : 00001100 : EVEN 13 : 00001101 : ODD
I execute this code for ODD & EVEN: int main() { int number; printf("Enter an integer: "); scanf("%d", &number); if(number % 2 == 0) printf("%d is even.", number); else printf("%d is odd.", number); }
void tellMeIfItIsAnOddNumberPlease(int iToTest){ int iLastDigit; iLastDigit = iToTest - (iToTest / 10 * 10); if (iLastDigit % 2 == 0){ printf("The number %d is even!\n", iToTest); } else { printf("The number %d is odd!\n", iToTest); } }
printf("%d%s\n",iToTest,0==(iToTest-iToTest/10*10)%2?" is even":" is odd");
if(num%2 ==0) { printf("Even"); } else { printf("Odd"); }
if(num & 1) { printf("Odd"); } else { printf("Even"); }
Binary : Decimal ------------------- 0000 = 0 0001 = 1 0010 = 2 0011 = 3 0100 = 4 0101 = 5 0110 = 6 0111 = 7 1000 = 8 1001 = 9 and so on...
7 (1-byte int)| 0 0 0 0 0 1 1 1 & 1 (1-byte int)| 0 0 0 0 0 0 0 1 ******************************************** Result | F F F F F F F T
int f(int x, int y); ^^^^^^^^^^^^^^^ int f(int x, int y) { return x + y; } ^^^^^^^^^^^^^^^ int f(); ^^^ int f(x, y) int x; int y; { return x + y; } ^^^^^^^
direct-declarator: [...] direct-declarator ( parameter-type-list ) direct-declarator ( identifier-list_opt )
void f(void v); void f(int i, void); void f(void, int);
function RemoveAllAFromB(a, b: string): string; var before, after :string; begin Result := b; if 0 < Pos(a,b) then begin before := Copy(b,1,Pos(a,b)-Length(a)); after := Copy(b,Pos(a,b)+Length(a),Length(b)); Result := before + after; Result := RemoveAllAFromB(a,Result); end; end;
char *s1, *s2, *result; int len1, len2; for (i = 0; i < len1; i++) { for (j = 0; j < len2; j++) { if (s1[i] == s2[j]) { break; } } if (j == len2) { *result = s1[i]; result++; } }
WNDCLASS wc; MSG msg; wc.style = 0; wc.lpfnWndProc = &WndProc; wc.cbClsExtra = 0; wc.cbWndExtra = 0; wc.hInstance = hInstance; wc.hIcon = NULL; wc.hCursor = LoadCursor(NULL, IDC_ARROW); wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1); wc.lpszMenuName = NULL; wc.lpszClassName = "MainWndCls"; RegisterClass(&wc); CreateWindow("MainWndCls", "", WS_OVERLAPPEDWINDOW | WS_VISIBLE, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL); while(GetMessage(&msg, NULL, 0, 0)){ TranslateMessage(&msg); DispatchMessage(&msg); }
if (createParams == null) { createParams = new CreateParams(); }
int pipes[2]; pipe(pipes) if (fork() == 0) { close(pipes[1]); dup2(0, pipes[0]); exec("sh -c } close(pipes[0]);
void noteProcDeath( CFFileDescriptorRef fdref, CFOptionFlags callBackTypes, void* info) { struct kevent kev; int fd = CFFileDescriptorGetNativeDescriptor(fdref); kevent(fd, NULL, 0, &kev, 1, NULL); unsigned int dead_pid = (unsigned int)kev.ident; CFFileDescriptorInvalidate(fdref); CFRelease(fdref); int our_pid = getpid(); LOG_INFO(@"exit! parent process (pid %u) died. no need for us (pid %i) to stick around", dead_pid, our_pid); exit(EXIT_SUCCESS); } void suicide_if_we_become_a_zombie(int parent_pid) { int fd = kqueue(); struct kevent kev; EV_SET(&kev, parent_pid, EVFILT_PROC, EV_ADD|EV_ENABLE, NOTE_EXIT, 0, NULL); kevent(fd, &kev, 1, NULL, 0, NULL); CFFileDescriptorRef fdref = CFFileDescriptorCreate(kCFAllocatorDefault, fd, true, noteProcDeath, NULL); CFFileDescriptorEnableCallBacks(fdref, kCFFileDescriptorReadCallBack); CFRunLoopSourceRef source = CFFileDescriptorCreateRunLoopSource(kCFAllocatorDefault, fdref, 0); CFRunLoopAddSource(CFRunLoopGetMain(), source, kCFRunLoopDefaultMode); CFRelease(source); }
pid_t ppid_before_fork = getpid(); pid_t pid = fork(); if (pid == -1) { perror(0); exit(1); } if (pid) { ; } else { int r = prctl(PR_SET_PDEATHSIG, SIGTERM); if (r == -1) { perror(0); exit(1); } if (getppid() != ppid_before_fork) exit(1);
pid_t pid = fork(); if (pid == -1) { perror(0); exit(1); } if (pid) { ; } else { int r = prctl(PR_SET_PDEATHSIG, SIGTERM); if (r == -1) { perror(0); exit(1); } if (getppid() == 1) exit(1);
int p[2]; pipe(p); pid_t child = fork(); if (child == 0) { close(p[1]); setpgid(0, 0); child = fork(); if (child == 0) { close(p[0]); exec(...child process here...); exit(1); } read(p[0], 1); kill(child, 9); exit(1); }
def run(*args): (r, w) = os.pipe() child = os.fork() if child == 0: os.close(w) os.setpgid(0, 0) child = os.fork() if child == 0: os.close(r) os.execl(args[0], *args) os._exit(1) os.read(r, 1) os.kill(child, 9) os._exit(1) os.close(r)
pit_t pid = getpid(); switch (fork()) { case -1: { abort(); } default: { exit(0); } case 0: { } } while (getppid() != pid) ;
int main(int argc, char ** argv) { int sv[2]; socketpair(AF_UNIX, SOCK_STREAM, 0, sv); pid_t pid = fork(); if ( pid > 0 ) { close(sv[1]); fprintf(stderr, "parent: pid = %d\n", getpid()); sleep(100); exit(0); } else { close(sv[0]); fprintf(stderr, "child: pid = %d\n", getpid()); struct pollfd mon; mon.fd = sv[1]; mon.events = POLLIN; poll(&mon, 1, -1); if ( mon.revents & POLLHUP ) fprintf(stderr, "child: parent hung up\n"); exit(0); } }
check_parent () { parent=`ps -f|awk echo "parent:$parent" let parent=$parent+0 if [[ $parent -eq 1 ]]; then echo "parent is dead, exiting" exit; fi } PID=$$ cnt=0 while [[ 1 = 1 ]]; do check_parent ... something done
var childProc = require( var counter=0; setInterval(function(){ console.log( },1000); if (process.platform.slice(0,3) != function killMeAndChildren() { /* * On Linux/Unix(Include Mac OS X), kill (-pid) will kill process group, usually * the process itself and children. * On Windows, an JOB object has been applied to current process and children, * so all children will be terminated if current process dies by anyway. */ console.log( process.kill(-process.pid, } /* * When you use "kill pid_of_this_process", this callback will be called */ process.on( console.log( killMeAndChildren(); }); }
var pty = require( pty.spawn( name: cols: 80, rows: 30, cwd: process.cwd(), env: process.env }); /*optionally you can install data handler term.on( process.stdout.write(data); }); term.write(.....); */
private void startWebpackDevServer() { String cmd = isWindows() ? "cmd /c gradlew webPackStart" : "gradlew webPackStart"; logger.info("webpack dev-server " + cmd); Thread thread = new Thread(() -> { ProcessBuilder pb = new ProcessBuilder(cmd.split(" ")); pb.redirectOutput(ProcessBuilder.Redirect.INHERIT); pb.redirectError(ProcessBuilder.Redirect.INHERIT); pb.directory(new File(".")); Process process = null; try { process = pb.start(); process.waitFor(); process.destroyForcibly(); System.setProperty(WEBPACK_SERVER_PROPERTY, "true"); } catch (InterruptedException | IOException e) { logger.info("killing webpack dev-server", e); if (process != null) { process.destroyForcibly(); } } }); thread.start(); }
| 1 | 2 | 3 | 4 | | AA(1) | pad.................. | | BB(1) | BB(2) | BB(3) | BB(4) | | CC(1) | pad.................. |
| 1 | | AA(1) | | BB(1) | | BB(2) | | BB(3) | | BB(4) | | CC(1) |
| 1 | 2 | | AA(1) | pad.. | | BB(1) | BB(2) | | BB(3) | BB(4) | | CC(1) | pad.. |
struct a { char one; char two[2]; char eight[8]; char four[4]; }; struct b { char one; short two; long int eight; int four; }; int main(int argc, char** argv) { struct a twoa[2] = {}; struct b twob[2] = {}; printf("sizeof(struct a): %i, sizeof(struct b): %i\n", sizeof(struct a), sizeof(struct b)); printf("sizeof(twoa): %i, sizeof(twob): %i\n", sizeof(twoa), sizeof(twob)); }
**** stack smashing detected ***: ./a.out terminated* *======= Backtrace: =========* */lib/tls/i686/cmov/libc.so.6(__fortify_fail+0x48)Aborted*
void func() { char array[10]; gets(array); } int main(int argc, char **argv) { func(); }
ab@cd-x:$ cat test_overflow.c int check_password(char *password){ int flag = 0; char buffer[20]; strcpy(buffer, password); if(strcmp(buffer, "mypass") == 0){ flag = 1; } if(strcmp(buffer, "yourpass") == 0){ flag = 1; } return flag; } int main(int argc, char *argv[]){ if(argc >= 2){ if(check_password(argv[1])){ printf("%s", "Access granted\n"); }else{ printf("%s", "Access denied\n"); } }else{ printf("%s", "Please enter password!\n"); } } ab@cd-x:$ gcc -g -fno-stack-protector test_overflow.c ab@cd-x:$ ./a.out mypass Access granted ab@cd-x:$ ./a.out yourpass Access granted ab@cd-x:$ ./a.out wepass Access denied ab@cd-x:$ ./a.out wepassssssssssssssssss Access granted ab@cd-x:$ gcc -g -fstack-protector test_overflow.c ab@cd-x:$ ./a.out wepass Access denied ab@cd-x:$ ./a.out mypass Access granted ab@cd-x:$ ./a.out yourpass Access granted ab@cd-x:$ ./a.out wepassssssssssssssssss *** stack smashing detected ***: ./a.out terminated ======= Backtrace: ========= /lib/tls/i686/cmov/libc.so.6(__fortify_fail+0x48)[0xce0ed8] /lib/tls/i686/cmov/libc.so.6(__fortify_fail+0x0)[0xce0e90] ./a.out[0x8048524] ./a.out[0x8048545] /lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xe6)[0xc16b56] ./a.out[0x8048411] ======= Memory map: ======== 007d9000-007f5000 r-xp 00000000 08:06 5776 /lib/libgcc_s.so.1 007f5000-007f6000 r--p 0001b000 08:06 5776 /lib/libgcc_s.so.1 007f6000-007f7000 rw-p 0001c000 08:06 5776 /lib/libgcc_s.so.1 0090a000-0090b000 r-xp 00000000 00:00 0 [vdso] 00c00000-00d3e000 r-xp 00000000 08:06 1183 /lib/tls/i686/cmov/libc-2.10.1.so 00d3e000-00d3f000 ---p 0013e000 08:06 1183 /lib/tls/i686/cmov/libc-2.10.1.so 00d3f000-00d41000 r--p 0013e000 08:06 1183 /lib/tls/i686/cmov/libc-2.10.1.so 00d41000-00d42000 rw-p 00140000 08:06 1183 /lib/tls/i686/cmov/libc-2.10.1.so 00d42000-00d45000 rw-p 00000000 00:00 0 00e0c000-00e27000 r-xp 00000000 08:06 4213 /lib/ld-2.10.1.so 00e27000-00e28000 r--p 0001a000 08:06 4213 /lib/ld-2.10.1.so 00e28000-00e29000 rw-p 0001b000 08:06 4213 /lib/ld-2.10.1.so 08048000-08049000 r-xp 00000000 08:05 1056811 /dos/hacking/test/a.out 08049000-0804a000 r--p 00000000 08:05 1056811 /dos/hacking/test/a.out 0804a000-0804b000 rw-p 00001000 08:05 1056811 /dos/hacking/test/a.out 08675000-08696000 rw-p 00000000 00:00 0 [heap] b76fe000-b76ff000 rw-p 00000000 00:00 0 b7717000-b7719000 rw-p 00000000 00:00 0 bfc1c000-bfc31000 rw-p 00000000 00:00 0 [stack] Aborted ab@cd-x:$
void myfunc(char *const src, int len) { int i; for (i = 0; i < len; ++i) { src[i] = 42; } } int main(void) { char arr[] = { int len = sizeof(arr); myfunc(arr, len + 1); return 0; }
gcc -fstack-protector -g -O0 -std=c99 a.c ulimit -c unlimited && rm -f core ./a.out
*** stack smashing detected ***: ./a.out terminated Aborted (core dumped)
int main (void){ 400579: 55 push %rbp 40057a: 48 89 e5 mov %rsp,%rbp 40057d: 48 83 ec 10 sub $0x10,%rsp 400581: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 400588: 00 00 40058a: 48 89 45 f8 mov %rax,-0x8(%rbp) 40058e: 31 c0 xor %eax,%eax char arr[] = { 400590: c6 45 f4 61 movb $0x61,-0xc(%rbp) 400594: c6 45 f5 62 movb $0x62,-0xb(%rbp) 400598: c6 45 f6 63 movb $0x63,-0xa(%rbp) 40059c: c6 45 f7 64 movb $0x64,-0x9(%rbp) int len = sizeof(arr); 4005a0: c7 45 f0 04 00 00 00 movl $0x4,-0x10(%rbp) myfunc(arr, len + 1); 4005a7: 8b 45 f0 mov -0x10(%rbp),%eax 4005aa: 8d 50 01 lea 0x1(%rax),%edx 4005ad: 48 8d 45 f4 lea -0xc(%rbp),%rax 4005b1: 89 d6 mov %edx,%esi 4005b3: 48 89 c7 mov %rax,%rdi 4005b6: e8 8b ff ff ff callq 400546 <myfunc> return 0; 4005bb: b8 00 00 00 00 mov $0x0,%eax }
4005c0: 48 8b 4d f8 mov -0x8(%rbp),%rcx 4005c4: 64 48 33 0c 25 28 00 xor %fs:0x28,%rcx 4005cb: 00 00 4005cd: 74 05 je 4005d4 <main+0x5b> 4005cf: e8 4c fe ff ff callq 400420 <__stack_chk_fail@plt> 4005d4: c9 leaveq 4005d5: c3 retq 4005d6: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 4005dd: 00 00 00
myfunc(arr, len); myfunc(arr, len + 1); myfunc(arr, len);
400581: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 400588: 00 00 40058a: 48 89 45 f8 mov %rax,-0x8(%rbp)
(gdb) p $rbp - 0x8 $1 = (void *) 0x7fffffffcf18 (gdb) watch 0x7fffffffcf18 Hardware watchpoint 2: *0x7fffffffcf18 (gdb) c Continuing. Hardware watchpoint 2: *0x7fffffffcf18 Old value = 1800814336 New value = 1800814378 myfunc (src=0x7fffffffcf14 "*****?Vk\266", <incomplete sequence \355\216>, len=5) at a.c:3 3 for (i = 0; i < len; ++i) { (gdb) p len $2 = 5 (gdb) p i $3 = 4 (gdb) bt
void swap ( char *a , char *b ); void revSTR ( char *const src ); int main ( void ){ char arr[] = "A-B-C-D-E"; revSTR( arr ); printf("ARR = %s\n", arr ); } void swap ( char *a , char *b ){ char tmp = *a; *a = *b; *b = tmp; } void revSTR ( char *const src ){ char *start = src; char *end = start + ( strlen( src ) - 1 ); while ( start < end ){ swap( &( *start ) , &( *end ) ); start++; end--; } }
void swap ( char *a , char *b ); void revSTR ( char *const src, size_t len ); int main ( void ){ char arr[] = "A-B-C-D-E"; size_t len = strlen( arr ); revSTR( arr, len ); printf("ARR = %s\n", arr ); } void swap ( char *a , char *b ){ char tmp = *a; *a = *b; *b = tmp; } void revSTR ( char *const src, size_t len ){ char *start = src; char *end = start + ( len - 1 ); while ( start < end ){ swap( &( *start ) , &( *end ) ); start++; end--; } }
==7125== Command: ./program ==7125== ARR = A- *** stack smashing detected ***: ./program terminated ==7125== ==7125== Process terminating with default action of signal 6 (SIGABRT) ==7125== at 0x4E6F428: raise (raise.c:54) ==7125== by 0x4E71029: abort (abort.c:89) ==7125== by 0x4EB17E9: __libc_message (libc_fatal.c:175) ==7125== by 0x4F5311B: __fortify_fail (fortify_fail.c:37) ==7125== by 0x4F530BF: __stack_chk_fail (stack_chk_fail.c:28) ==7125== by 0x400637: main (program.c:14)
NSLog(@"Size of BOOL %d", sizeof(BOOL)); NSLog(@"Size of bool %d", sizeof(bool));
bool b1 = 2; if (b1) printf("REAL b1 \n"); if (b1 != true) printf("NOT REAL b1 \n"); BOOL b2 = 2; if (b2) printf("REAL b2 \n"); if (b2 != YES) printf("NOT REAL b2 \n");
b2 = b1; if (b2) printf("ONCE AGAIN - REAL b2 \n"); if (b2 != true) printf("ONCE AGAIN - NOT REAL b2 \n");
BOOL b22 = b1 ? 2 : NO; if (b22) printf("ONCE AGAIN MORE - REAL b22 \n"); if (b22 != YES) printf("ONCE AGAIN MORE- NOT REAL b22 \n");
int myValue = 256; BOOL myBool = myValue; if (myBool) { printf("i } else { printf("i }
bool ansicBool = 64; if(ansicBool != true) printf("This will not print\n"); printf("Any given vlaue other than 0 to ansicBool is evaluated to %i\n", ansicBool); BOOL objcBOOL = 64; if(objcBOOL != YES) printf("This might print depnding on your architecture\n"); printf("BOOL will keep whatever value you assign it: %i\n", objcBOOL); if(!objcBOOL) printf("This will not print\n"); printf("! operator will zero objcBOOL %i\n", !objcBOOL); if(!!objcBOOL) printf("!! will evaluate objcBOOL value to %i\n", !!objcBOOL);
int F=00,OO=00;main(){F_OO();printf("%1.3f\n",4.*-F/OO/OO);}F_OO() { _-_-_-_ _-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_-_-_-_-_ _-_-_-_-_-_-_-_ _-_-_-_ }
a[900]; b;c;d=1 ;e=1;f; g;h;O; main(k, l)char* *l;{g= atoi(* ++l); for(k= 0;k*k< g;b=k ++>>1) ;for(h= 0;h*h<= g;++h); --h;c=( (h+=g>h *(h+1)) -1)>>1; while(d <=g){ ++O;for (f=0;f< O&&d<=g ;++f)a[ b<<5|c] =d++,b+= e;for( f=0;f<O &&d<=g; ++f)a[b <<5|c]= d++,c+= e;e= -e ;}for(c =0;c<h; ++c){ for(b=0 ;b<k;++ b){if(b <k/2)a[ b<<5|c] ^=a[(k -(b+1)) <<5|c]^= a[b<<5 |c]^=a[ (k-(b+1 ))<<5|c] ;printf( a[b<<5|c ]?"%-4d" :" " ,a[b<<5 |c]);} putchar(
try{ ... throw NoErrorException; ... } catch (const NoErrorException& noe){ } do { ...break; ...break; } while (false); for(int i = 0;...) { bool restartOuter = false; for (int j = 0;...) { if (...) restartOuter = true; if (restartOuter) { i = -1; } } etc etc
switch(value) { case 0: Console.Writeln("In case 0"); goto case 1; case 1: Console.Writeln("In case 1"); goto case 2; case 2: Console.Writeln("In case 2"); goto default; default: Console.Writeln("In default"); break; }
sub factorial { my ($n, $acc) = (@_, 1); return $acc if $n < 1; @_ = ($n - 1, $acc * $n); goto &factorial; }
int big_function() { if([error]) { return [error]; } if([error]) { return [error]; } if([error]) { return [error]; } if([error]) { return [error]; } return [success]; }
int big_function() { int ret_val = [success]; if([error]) { ret_val = [error]; goto end; } if([error]) { ret_val = [error]; goto end; } if([error]) { ret_val = [error]; goto end; } if([error]) { ret_val = [error]; goto end; } end: return ret_val; }
for (add_index=0; add_index < ELEMENTS_PER_BUCKET; add_index++) if (slot_p[add_index].hash_key == hash_key) goto add; for (add_index=0; add_index < ELEMENTS_PER_BUCKET; add_index++) if ((slot_p[add_index].type == TT_ELEMENT_EMPTY) goto add; add:
for (add_index=0; add_index < ELEMENTS_PER_BUCKET; add_index++) if (slot_p[add_index].hash_key == hash_key) break; if (add_index >= ELEMENTS_PER_BUCKET) { for (add_index=0; add_index < ELEMENTS_PER_BUCKET; add_index++) if ((slot_p[add_index].type == TT_ELEMENT_EMPTY) break; if (add_index >= ELEMENTS_PER_BUCKET) }
loop1: a loop2: b if(cond1) goto loop1 c if(cond2) goto loop2
If A <> 0 Then A = 0 EndIf Write("Value of A:" + A)
If A == 0 Then GOTO FINAL EndIf A = 0 FINAL: Write("Value of A:" + A)
if (something()) goto fail; goto fail; printf("Never reached\n"); fail:
struct Fail {}; try { if (something()) throw Fail(); throw Fail(); printf("Never reached\n"); } catch (Fail&) { }
int computation1() { return 1; } int computation2() { return computation1(); }
void tough1() { if (computation1() != computation2()) printf("Unreachable\n"); } void tough2() { if (computation1() == computation2()) goto out; printf("Unreachable\n"); out:; } struct Out{}; void tough3() { try { if (computation1() == computation2()) throw Out(); printf("Unreachable\n"); } catch (Out&) { } }
int doSomething (struct my_complicated_stuff *ctx) { db_conn *conn; RSA *key; char *temp_data; conn = db_connect(); if (ctx->smth->needs_alloc) { temp_data=malloc(ctx->some_size); if (!temp_data) { db_disconnect(conn); return -1; } } ... if (!ctx->smth->needs_to_be_processed) { free(temp_data); db_disconnect(conn); return -2; } pthread_mutex_lock(ctx->mutex); if (ctx->some_other_thing->error) { pthread_mutex_unlock(ctx->mutex); free(temp_data); db_disconnect(conn); return -3; } ... key=rsa_load_key(....); ... if (ctx->something_else->error) { rsa_free(key); pthread_mutex_unlock(ctx->mutex); free(temp_data); db_disconnect(conn); return -4; } if (ctx->something_else->additional_check) { rsa_free(key); pthread_mutex_unlock(ctx->mutex); free(temp_data); db_disconnect(conn); return -5; } pthread_mutex_unlock(ctx->mutex); free(temp_data); db_disconnect(conn); return 0; }
int doSomething_goto (struct my_complicated_stuff *ctx) { int ret=0; db_conn *conn; RSA *key; char *temp_data; conn = db_connect(); if (ctx->smth->needs_alloc) { temp_data=malloc(ctx->some_size); if (!temp_data) { ret=-1; goto exit_db; } } ... if (!ctx->smth->needs_to_be_processed) { ret=-2; goto exit_freetmp; } pthread_mutex_lock(ctx->mutex); if (ctx->some_other_thing->error) { ret=-3; goto exit; } ... key=rsa_load_key(....); ... if (ctx->something_else->error) { ret=-4; goto exit_freekey; } if (ctx->something_else->additional_check) { ret=-5; goto exit_freekey; } exit_freekey: rsa_free(key); exit: pthread_mutex_unlock(ctx->mutex); exit_freetmp: free(temp_data); exit_db: db_disconnect(conn); return ret; }
int i; PROMPT_INSERT_NUMBER: std::cout << "insert number: "; std::cin >> i; if(std::cin.fail()) { std::cin.clear(); std::cin.ignore(1000, goto PROMPT_INSERT_NUMBER; } std::cout << "your number is " << i;
int i; bool loop; do { loop = false; std::cout << "insert number: "; std::cin >> i; if(std::cin.fail()) { std::cin.clear(); std::cin.ignore(1000, loop = true; } } while(loop); std::cout << "your number is " << i;
void sort(int* array, int length) { SORT: for(int i=0; i<length-1; ++i) if(array[i]>array[i+1]) { swap(data[i], data[i+1]); goto SORT; } }
void sort(int* array, int length) { bool seemslegit; do { seemslegit = true; for(int i=0; i<length-1; ++i) if(array[i]>array[i+1]) { swap(data[i], data[i+1]); seemslegit = false; } } while(!seemslegit); }
void sort(int* array, int length) { for(int i=0; i<length-1; ++i) if(array[i]>array[i+1]) { swap(data[i], data[i+1]); i = -1; } }
; P1 states loops ; 11111110 <- ; 11111101 | ; 11111011 | ; 11110111 | ; 11101111 | ; 11011111 | ; |_________| init_roll_state: MOV P1, ACALL delay next_roll_state: MOV A,P1 RL A MOV P1,A ACALL delay JNB P1.5, init_roll_state SJMP next_roll_state
if(!valid) goto NOTVALID; LOOPBACK: if(loop) goto LOOPBACK; NOTVALID:;
if(read(fd, buf, 1)==-1) { printf("Oh dear, something went wrong with read()! %s\n", strerror(errno)); }
char *strerror(int errnum); static char strerror_buf[1024]; const char *sys_errlist[] = { [EPERM] = "Operation not permitted", [ENOENT] = "No such file or directory", [ESRCH] = "No such process", [EINTR] = "Interrupted system call", [EIO] = "I/O error", [ENXIO] = "No such device or address", [E2BIG] = "Argument list too long", }; int sys_nerr = sizeof(sys_errlist) / sizeof(char *); char *strerror(int errnum) { if (0 <= errnum && errnum < sys_nerr && sys_errlist[errnum]) strcpy(strerror_buf, sys_errlist[errnum]); else sprintf(strerror_buf, "Unknown error %d", errnum); return strerror_buf; }
void perror(const char *s); void perror(const char *s) { fprintf(stderr, "%s: %s\n", s, strerror(errno)); }
int main(int i, char *c[]) { if (i != 2) fprintf(stderr, "Usage: perror errno\n"); else { errno = atoi(c[1]); perror(""); } exit(0); }
import errno import os import sys toname = dict((str(getattr(errno, x)), x) for x in dir(errno) if x.startswith("E")) tocode = dict((x, getattr(errno, x)) for x in dir(errno) if x.startswith("E")) for arg in sys.argv[1:]: if arg in tocode: print arg, tocode[arg], os.strerror(tocode[arg]) elif arg in toname: print toname[arg], arg, os.strerror(int(arg)) else: print "Unknown:", arg
function errno() { local arg=$1 if [[ "x$arg" == "x-h" ]]; then cat <<EOF Usage: errno <num> Prints text that describes errno error number EOF else pushd /usr/include find . -name "errno*.h" | xargs grep "[[:space:]]${arg}[[:space:]]" popd fi }
typedef struct Foo { char a; double d; char e; int f; } Foo ;
struct s { char c; int i; char buffer[13]; }; void compare(const struct s *left, const struct s *right) { if (0 == memcmp(left, right, sizeof(struct s))) { } }
void f(int *j) { (*j)++; } int main() { int i = 20; int *p = &i; f(p); printf("i = %d\n", i); return 0; }
void function(int param) { printf("I param++; } int main(void) { int variable = 111; function(variable); printf("variable %d\m", variable); return 0; }
void function2(int *param) { printf("I (*param)++; } int main(void) { int variable = 111; function2(&variable); printf("variable %d\n", variable); return 0; }
void function2(int *param) { printf("param param = NULL; } int main(void) { int variable = 111; int *ptr = &variable; function2(ptr); printf("ptr return 0; }
void f(int &j) { j++; } int main() { int i = 20; f(i); printf("i = %d\n", i); return 0; }
void add_number(int *a) { *a = *a + 2; } int main(int argc, char *argv[]) { int a = 2; printf("before pass by reference, a == %i\n", a); add_number(&a); printf("after pass by reference, a == %i\n", a); printf("before pass by reference, a == %p\n", &a); add_number(&a); printf("after pass by reference, a == %p\n", &a); } before pass by reference, a == 2 after pass by reference, a == 4 before pass by reference, a == 0x7fff5cf417ec after pass by reference, a == 0x7fff5cf417ec
void f(int &j) { j++; } int main() { int i = 20; f(i); printf("i = %d\n", i); return 0; }
float val = 37.777779; float rounded_down = floorf(val * 100) / 100; float nearest = roundf(val * 100) / 100; float rounded_up = ceilf(val * 100) / 100;
float value = 37.777779; float rounded = ((int)(value * 100 + .5) / 100.0);
char number[24]; sprintf(number, "%.2f", 37.777779);
string prd(const double x, const int decDigits) { stringstream ss; ss << fixed; ss.precision(decDigits); ss << x; return ss.str(); }
float valueToRound = 37.777779; float roundedValue = ceilf(valueToRound * 100) / 100;
double showDecimals(const double& x, const int& numDecimals) { int y=x; double z=x-y; double m=pow(10,numDecimals); double q=z*m; double r=round(q); return static_cast<double>(y)+(1.0/m)*r; }
double f_round(double dval, int n) { char l_fmtp[32], l_buf[64]; char *p_str; sprintf (l_fmtp, "%%.%df", n); if (dval>=0) sprintf (l_buf, l_fmtp, dval); else sprintf (l_buf, l_fmtp, dval); return ((double)strtod(l_buf, &p_str)); }
double d = 100.23456; printf("%f", f_round(d, 4)); printf("%f", f_round(d, 2));
void r100(const char *s) { float x, y; sscanf(s, "%f", &x); y = round(x*100.0)/100.0; printf("%6s %.12e %.12e\n", s, x, y); } int main(void) { r100("1.115"); r100("1.125"); r100("1.135"); return 0; } 1.115 1.115000009537e+00 1.120000004768e+00 1.125 1.125000000000e+00 1.129999995232e+00 1.135 1.134999990463e+00 1.139999985695e+00
a = 8.000000 sqrt(a) = r = 2.828427 roundz(r,2) = 2.830000 roundz(r,3) = 2.828000 roundz(r,5) = 2.828430
double Round(double x, int p) { if (x != 0.0) { return ((floor((fabs(x)*pow(double(10.0),p))+0.5))/pow(double(10.0),p))*(x/fabs(x)); } else { return 0.0; } }
double val; String(Round(Round(Round(val,8),6),2));
double val; String(Round(Round(Round(val,N+2),N),2));
float roundoff(float num,int precision) { int temp=(int )(num*pow(10,precision)); int num1=num*pow(10,precision+1); temp*=10; temp+=5; if(num1>=temp) num1+=10; num1/=10; num1*=10; num=num1/pow(10,precision+1); return num; }
char* fgets(char *string, int length, FILE * stream);
char *gets(char *buffer) { assert(buffer != 0); abort(); return 0; }
fputs("obsolete and dangerous function gets() called\n", stderr);
char buffer[BUFSIZ]; while (fgets(buffer, sizeof(buffer), stdin) != 0) { ...process line of data... }
char *fgets_wrapper(char *buffer, size_t buflen, FILE *fp) { if (fgets(buffer, buflen, fp) != 0) { size_t len = strlen(buffer); if (len > 0 && buffer[len-1] == buffer[len-1] = return buffer; } return 0; }
char *fgets_wrapper(char *buffer, size_t buflen, FILE *fp) { if (fgets(buffer, buflen, fp) != 0) { buffer[strcspn(buffer, "\n")] = return buffer; } return 0; }
if (len > 0 && buffer[len-1] == buffer[len-1] = else { int ch; while ((ch = getc(fp)) != EOF && ch != ; }
char array1[] = "12345"; char array2[] = "67890"; gets(array1);
static int getLine (char *prmpt, char *buff, size_t sz) { int ch, extra; if (prmpt != NULL) { printf ("%s", prmpt); fflush (stdout); } if (fgets (buff, sz, stdin) == NULL) return NO_INPUT; if (buff[strlen(buff)-1] != extra = 0; while (((ch = getchar()) != extra = 1; return (extra == 1) ? TOO_LONG : OK; } buff[strlen(buff)-1] = return OK; }
int main (void) { int rc; char buff[10]; rc = getLine ("Enter string> ", buff, sizeof(buff)); if (rc == NO_INPUT) { printf ("No input\n"); return 1; } if (rc == TOO_LONG) { printf ("Input too long\n"); return 1; } printf ("OK [%s]\n", buff); return 0; }
char string[512]; fgets(string, sizeof(string), stdin);
char *gets(char *str) { strcpy(str, "Never use gets!"); return str; }
+--------+ | pid=7 | | ppid=4 | | bash | +--------+ | | calls fork V +--------+ +--------+ | pid=7 | forks | pid=22 | | ppid=4 | ----------> | ppid=7 | | bash | | bash | +--------+ +--------+ | | | waits for pid 22 | calls exec to run ls | V | +--------+ | | pid=22 | | | ppid=7 | | | ls | V +--------+ +--------+ | | pid=7 | | exits | ppid=4 | <---------------+ | bash | +--------+ | | continues V
int pid = fork(); if (pid == 0) { printf("I } else { printf("I }
int cpid = fork( ); if (cpid = = 0) { exit(0); } wait(cpid);
int cpid = fork( ); if (cpid = = 0) { exec(foo); exit(0); } wait(cpid);
child = fork(); if (child < 0) { std::cout << "Failed to fork GUI process...Exiting" << std::endl; exit (-1); } else if (child == 0) { execvp (argv[0], const_cast<char**>(argv)); } else { }
int main( void ) { int pid = fork(); if ( pid == 0 ) { execvp( "find", argv ); } wait( 2 ); return 0; }
int main(int argc, char **argv) { printf("--beginning of program\n"); int counter = 0; pid_t pid = fork(); if (pid == 0) { int i = 0; for (; i < 5; ++i) { printf("child process: counter=%d\n", ++counter); } } else if (pid > 0) { int j = 0; for (; j < 5; ++j) { printf("parent process: counter=%d\n", ++counter); } } else { printf("fork() failed!\n"); return 1; } printf("--end of program--\n"); return 0; }
--beginning of program parent process: counter=1 parent process: counter=2 parent process: counter=3 child process: counter=1 parent process: counter=4 child process: counter=2 parent process: counter=5 child process: counter=3 --end of program-- child process: counter=4 child process: counter=5 --end of program--
main() { char program[80],*args[3]; int i; printf("Ready to exec()...\n"); strcpy(program,"date"); args[0]="date"; args[1]="-u"; args[2]=NULL; i=execvp(program,args); printf("i=%d ... did it work?\n",i); }
int fast_trunc_one(int i) { int mantissa, exponent, sign, r; mantissa = (i & 0x07fffff) | 0x800000; exponent = 150 - ((i >> 23) & 0xff); sign = i & 0x80000000; if (exponent < 0) { r = mantissa << -exponent; } else { r = mantissa >> exponent; } return (r ^ -sign) + sign; }
int fast_trunc_two(int i) { int mantissa, exponent, sign, r; mantissa = (i & 0x07fffff) | 0x800000; exponent = 150 - ((i >> 23) & 0xff); sign = i & 0x80000000; if (exponent < 0) { r = (mantissa << -exponent) ^ -sign; } else { r = (mantissa >> exponent) ^ -sign; } return r + sign; }
_fast_trunc_one: LFB0: .cfi_startproc movl 4(%esp), %eax movl $150, %ecx movl %eax, %edx andl $8388607, %edx sarl $23, %eax orl $8388608, %edx andl $255, %eax subl %eax, %ecx movl %edx, %eax sarl %cl, %eax testl %ecx, %ecx js L5 rep ret .p2align 4,,7 L5: negl %ecx movl %edx, %eax sall %cl, %eax ret .cfi_endproc
_fast_trunc_two: LFB1: .cfi_startproc pushl %ebx .cfi_def_cfa_offset 8 .cfi_offset 3, -8 movl 8(%esp), %eax movl $150, %ecx movl %eax, %ebx movl %eax, %edx sarl $23, %ebx andl $8388607, %edx andl $255, %ebx orl $8388608, %edx andl $-2147483648, %eax subl %ebx, %ecx js L9 sarl %cl, %edx movl %eax, %ecx negl %ecx xorl %ecx, %edx addl %edx, %eax popl %ebx .cfi_remember_state .cfi_def_cfa_offset 4 .cfi_restore 3 ret .p2align 4,,7 L9: .cfi_restore_state negl %ecx sall %cl, %edx movl %eax, %ecx negl %ecx xorl %ecx, %edx addl %edx, %eax popl %ebx .cfi_restore 3 .cfi_def_cfa_offset 4 ret .cfi_endproc
int fast_trunc_one(int i) { int mantissa, exponent; mantissa = (i & 0x07fffff) | 0x800000; exponent = 150 - ((i >> 23) & 0xff); if (exponent < 0) { return (mantissa << -exponent); } else { return (mantissa >> exponent); } }
int fast_trunc_one(int i) { int mantissa, exponent, sign, r; mantissa = (i & 0x07fffff) | 0x800000; exponent = 150 - ((i >> 23) & 0xff); sign = i & 0x80000000; if (exponent < 0) { r = mantissa << -exponent; } else { r = mantissa >> exponent; } return (r ^ sign) + sign; }
int fast_trunc_one(int i) { int mantissa, exponent, sign, r; mantissa = (i & 0x07fffff) | 0x800000; exponent = 150 - ((i >> 23) & 0xff); sign = i & 0x80000000; if (exponent < 0) { r = (mantissa << -exponent); } else { r = (mantissa >> exponent); } return r; }
int fast_trunc_one(int i) { int mantissa, exponent; mantissa = (i & 0x07fffff) | 0x800000; exponent = 150 - ((i >> 23) & 0xff); if (exponent < 0) { return (mantissa << -exponent); } else { return (mantissa >> exponent); } }
int fast_trunc_two(int i) { int mantissa, exponent, sign, r; mantissa = (i & 0x07fffff) | 0x800000; exponent = 150 - ((i >> 23) & 0xff); sign = i & 0x80000000; if (exponent < 0) { r = ((mantissa << -exponent) ^ -sign) + sign; } else { r = ((mantissa >> exponent) ^ -sign) + sign; } return r; }
if (exponent < 0) { r = mantissa << -exponent; } else { r = mantissa >> exponent; } return (r ^ -sign) + sign;
if (exponent < 0) { return((mantissa << -exponent)^-sign)+sign; } else { return((mantissa << -exponent)^-sign)+sign; }
_fast_trunc_two: movl %edi, %edx andl $-2147483648, %edx movl %edi, %esi andl $8388607, %esi orl $8388608, %esi shrl $23, %edi movzbl %dil, %eax movl $150, %ecx subl %eax, %ecx js LBB0_1 shrl %cl, %esi jmp LBB0_3 LBB0_1: negl %ecx shll %cl, %esi LBB0_3: movl %edx, %eax negl %eax xorl %esi, %eax addl %edx, %eax ret
fast_trunc_one: movl %edi, %ecx shrl $23, %ecx movl %edi, %eax movzbl %cl, %edx andl $8388607, %eax negl %edx orl $8388608, %eax addl $150, %edx movl %eax, %esi movl %edx, %ecx andl $-2147483648, %edi negl %ecx movl %edi, %r8d shll %cl, %esi negl %r8d movl %edx, %ecx shrl %cl, %eax testl %edx, %edx cmovl %esi, %eax xorl %r8d, %eax addl %edi, %eax ret
fast_trunc_one: movl %edi,%r9d sarl $23,%r9d movzbl %r9b,%r9d addl $-150,%r9d movl %edi,%eax movl %r9d,%r8d andl $8388607,%eax negl %r8d orl $8388608,%eax testl %r8d,%r8d jl .LBB2_fast_trunc_one movl %r8d,%ecx movl %eax,%edx sarl %cl,%edx .Lt_0_1538: andl $-2147483648,%edi movl %edi,%eax negl %eax xorl %edx,%eax addl %edi,%eax ret .p2align 5,,31 .LBB2_fast_trunc_one: movl %r9d,%ecx movl %eax,%edx shll %cl,%edx jmp .Lt_0_1538
int open(const char *pathname, int flags, mode_t mode);
while (retval = close(fd), retval == -1 && ernno == EINTR) ;
1.firstly it searches on the disk the file to be opened. 2.then it loads the file from the disk into a place in memory called buffer. 3.it sets up a character pointer that points to the first character of the buffer.
typedef int twoInts[2]; void print(twoInts *twoIntsPtr); void intermediate (twoInts twoIntsAppearsByValue); int main () { twoInts a; a[0] = 0; a[1] = 1; print(&a); intermediate(a); return 0; } void intermediate(twoInts b) { print(&b); } void print(twoInts *c){ printf("%d\n%d\n", (*c)[0], (*c)[1]); }
In function ‘intermediate’: warning: passing argument 1 of ‘print’ from incompatible pointer type [enabled by default] print(&b); ^ note: expected ‘int (*)[2]’ but argument is of type ‘int **’ void print(twoInts *twoIntsPtr); ^
typedef struct type24 { char& operator[](int i) { return byte[i]; } char byte[3]; } type24; type24 x; x[2] = char c = x[2];
T *a[] -- a is an array of pointer to T T (*a)[] -- a is a pointer to an array of T T *f() -- f is a function returning a pointer to T T (*f)() -- f is a pointer to a function returning T
f -- f f[] -- is an array *f[] -- of pointers ([] has higher precedence than *) (*f[])() -- to functions *(*f[])() -- returning pointers (*(*f[])())() -- to functions void (*(*f[])())(); -- returning void
signal -- signal signal( ) -- is a function with parameters signal( sig, ) -- sig signal(int sig, ) -- which is an int and signal(int sig, func ) -- func signal(int sig, *func ) -- which is a pointer signal(int sig, (*func)(int)) -- to a function taking an int signal(int sig, void (*func)(int)) -- returning void *signal(int sig, void (*func)(int)) -- returning a pointer (*signal(int sig, void (*func)(int)))(int) -- to a function taking an int void (*signal(int sig, void (*func)(int)))(int); -- and returning void
typedef void outerfunc(void); typedef outerfunc *innerfunc(void); innerfunc *f[N];
int *a[10]; "a is" ^ int *a[10]; "a is an array" ^^^^ int *a[10]; "a is an array of pointers" ^ int *a[10]; "a is an array of pointers to `int`". ^^^
void ( *(*f[]) () ) (); "f is" ^ void ( *(*f[]) () ) (); "f is an array" ^^ void ( *(*f[]) () ) (); "f is an array of pointers" ^ void ( *(*f[]) () ) (); "f is an array of pointers to function" ^^ void ( *(*f[]) () ) (); "f is an array of pointers to function returning pointer" ^ void ( *(*f[]) () ) (); "f is an array of pointers to function returning pointer to function" ^^ void ( *(*f[]) () ) (); "f is an array of pointers to function returning pointer to function returning `void`" ^^^^
typedef void (*ResultFunction)(); typedef ResultFunction (*Function)();
void * (*(*fp1)(int))[10]; float (*(*fp2)(int,int,float))(int); typedef double (*(*(*fp3)())[10])(); fp3 a; int (*(*f4())[10])(); int main() {}
if if if = then then then = else else else = if then ...
struct sockaddr_in addr; inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr);
void printSomething(char *p) { printf("p: %s",p); }
int main() { char *p = "hello"; char q[] = "hello"; printf("%zu\n", sizeof(p)); printf("%zu\n", sizeof(q)); printf("%zu\n", strlen(p)); printf("%zu\n", strlen(q)); return 0; }
char a[] = "string literal"; char *p = "string literal";
static char __unnamed[] = "abc"; char *c = __unnamed;
int main(void) { char *s = "abc"; printf("%s\n", s); return 0; }
char *s = "abc"; 8: 48 c7 45 f8 00 00 00 movq $0x0,-0x8(%rbp) f: 00 c: R_X86_64_32S .rodata
17: c7 45 f0 61 62 63 00 movl $0x636261,-0x10(%rbp)
Section to Segment mapping: Segment Sections... 02 .text .rodata
printf("Enter your Name: "); if (!(fgets(Name, sizeof Name, stdin) != NULL)) { fprintf(stderr, "Error reading Name.\n"); exit(1); }
size_t ln = strlen(name) - 1; if (*name && name[ln] == name[ln] =
char buffer[100]; if (fgets(buffer, sizeof buffer, stdin) != NULL) { size_t len = strlen(buffer); if (len > 0 && buffer[len-1] == buffer[--len] = }
size_t len = strlen(buffer); if (buffer[len - 1] == buffer[len -1] = }
void remove_newline_ch(char *line) { int new_line = strlen(line) -1; if (line[new_line] == line[new_line] = }
void remove_new_line(char* string) { size_t length = strlen(string); if((length > 0) && (string[length-1] == { string[length-1] = } }
void remove_multi_new_line(char* string) { size_t length = strlen(string); while((length>0) && (string[length-1] == { --length; string[length] = } }
size_t strrspn (const char *s, const char *accept) { const char *ch; size_t len = strlen(s); more: if (len > 0) { for (ch = accept ; *ch != 0 ; ch++) { if (s[len - 1] == *ch) { len--; goto more; } } } return len; }
size_t strrcspn (const char *s, const char *reject) { const char *ch; size_t len = strlen(s); size_t origlen = len; while (len > 0) { for (ch = reject ; *ch != 0 ; ch++) { if (s[len - 1] == *ch) { return len; } } len--; } return origlen; }
int main(){ char *fname,*lname; size_t size=32,nchar; fname=malloc(size*sizeof *fname); lname=malloc(size*sizeof *lname); if(NULL == fname || NULL == lname){ printf("Error in memory allocation."); exit(1); } printf("Enter first name "); nchar=getline(&fname,&size,stdin); if(nchar == -1){ printf("Line couldn exit(1); } printf("Number of characters read :%zu\n",nchar); fname[nchar-1]= printf("Enter last name "); nchar=getline(&lname,&size,stdin); printf("Number of characters read :%zu\n",nchar); lname[nchar-1]= printf("Name entered %s %s\n",fname,lname); return 0; }
int zstring_search_chr(const char *token,char s){ if (!token || s== return 0; for (;*token; token++) if (*token == s) return 1; return 0; } char *zstring_remove_chr(char *str,const char *bad) { char *src = str , *dst = str; while(*src) if(zstring_search_chr(bad,*src)) src++; else *dst++ = *src++; *dst= return str; }
Example Usage char s[]="this is a trial string to test the function."; char const *d=" ."; printf("%s\n",zstring_remove_chr(s,d)); Example Output thisisatrialstringtotestthefunction
for(int i = 0; i < strlen(Name); i++ ) { if(Name[i] == }
int remove_cr_lf(char *str) { int len =0; len = strlen(str); for(int i=0;i<5;i++) { if (len>0) if (str[len-1] == { str[len-1] = 0; len--; } if (len>0) if (str[len-1] == { str[len-1] = 0; len--; } } return 0; }
char name[1024]; unsigned int len; printf("Enter your name: "); fflush(stdout); if (fgets(name, sizeof(name), stdin) == NULL) { fprintf(stderr, "error reading name\n"); exit(1); } len = strlen(name); if (name[len - 1] == name[len - 1] =
do { if (DEBUG) fprintf(stderr, fmt, __VA_ARGS__); } while (0)
do { if (DEBUG) fprintf(stderr, "%s:%d:%s(): " fmt, __FILE__, \ __LINE__, __func__, __VA_ARGS__); } while (0)
void dbg_printf(const char *fmt, ...) { va_list args; va_start(args, fmt); vfprintf(stderr, fmt, args); va_end(args); }
/* @( @( @( @( @( @( @( */ /* ** Usage: TRACE((level, fmt, ...)) ** "level" is the debugging level which must be operational for the output ** to appear. "fmt" is a printf format string. "..." is whatever extra ** arguments fmt requires (possibly nothing). ** The non-debug macro means that the code is validated but never called. ** -- See chapter 8 of */ static const char jlss_id_debug_enabled[] = "@( const char jlss_id_debug_h[] = "@( extern int db_getdebug(void); extern int db_newindent(void); extern int db_oldindent(void); extern int db_setdebug(int level); extern int db_setindent(int i); extern void db_print(int level, const char *fmt,...); extern void db_setfilename(const char *fn); extern void db_setfileptr(FILE *fp); extern FILE *db_getfileptr(void); extern const char *db_indent(void); /**************************************\ ** MULTIPLE DEBUGGING SUBSYSTEMS CODE ** \**************************************/ /* ** Usage: MDTRACE((subsys, level, fmt, ...)) ** "subsys" is the debugging system to which this statement belongs. ** The significance of the subsystems is determined by the programmer, ** except that the functions such as db_print refer to subsystem 0. ** "level" is the debugging level which must be operational for the ** output to appear. "fmt" is a printf format string. "..." is ** whatever extra arguments fmt requires (possibly nothing). ** The non-debug macro means that the code is validated but never called. */ extern int db_mdgetdebug(int subsys); extern int db_mdparsearg(char *arg); extern int db_mdsetdebug(int subsys, int level); extern void db_mdprint(int subsys, int level, const char *fmt,...); extern void db_mdsubsysnames(char const * const *names);
do { if (DEBUG) fprintf(stderr, __VA_ARGS__); } while (0)
if (x > y) debug_print("x (%d) > y (%d)\n", x, y); else do_something_useful(x, y);
if (x > y) { if (DEBUG) fprintf(stderr, "x (%d) > y (%d)\n", x, y); else do_something_useful(x, y); }
if (x > y) if (DEBUG) { fprintf(stderr, "x (%d) > y (%d)\n", x, y); } ; else do_something_useful(x, y);
((void)((DEBUG) ? fprintf(stderr, __VA_ARGS__) : 0))
void stderr_printf(const char *fmt, ...) { va_list ap; va_start(ap, fmt); vfprintf(stderr, fmt, ap); va_end(ap); } int main(int argc, char *argv[]) { debug_print(("argv[0] is %s, argc is %d\n", argv[0], argc)); return 0; }
int main(int argc, char *argv[]) { debug_print("argv[0] is %s, argc is %d"_ argv[0] _ argc); return 0; }
fprintf(stderr, "%s() in %s, line %i: " FORMAT "\n", \ __func__, __FILE__, __LINE__, __VA_ARGS__)
if (DEBUG) \ fprintf(stderr, "%s:%d " FMT "\n", __FUNCTION__, __LINE__, } while (0)
void debug_vprintf(const char *fmt, ...) { va_list args; va_start(args, fmt); vfprintf(stderr, fmt, args); va_end(args); } /* Call as: (DOUBLE PARENTHESES ARE MANDATORY) */ /* var_debug(("outfd = %d, somefailed = %d\n", outfd, somefailed)); */ __FILE__, __LINE__, __func__); debug_vprintf x; }} while (0) /* var_dump("%s" variable_name); */ __FILE__, __LINE__, __func__); debug_vprintf ("%s = " fmt, __FILE__, __LINE__, __func__); }} while (0)
printf("%i\n", DBGI(1*2*3*4*5*6)); hello.c:86:main(): 1*2*3*4*5*6->720 720
DBGI(printf("%i\n", DBGI(1*2*3*4*5*6))); hello.c:86:main(): 1*2*3*4*5*6->720 720 hello.c:86:main(): printf("%i\n", DBGI(1*2*3*4*5*6))->4
void debuglog_init(char *filename); void debuglog_close(void); void debuglog_log(char* format, ...);
FILE *hndl; char *savedFilename; void debuglog_init(char *filename) { savedFilename = filename; hndl = fopen(savedFilename, "wt"); fclose(hndl); } void debuglog_close(void) { } void debuglog_log(char* format, ...) { hndl = fopen(savedFilename,"at"); va_list argptr; va_start(argptr, format); vfprintf(hndl, format, argptr); va_end(argptr); fputc( fclose(hndl); }
@implementation View1Controller typedef enum playerStateTypes { PLAYER_OFF, PLAYER_PLAYING, PLAYER_PAUSED } PlayerState;
@interface View1Controller : UIViewController { PlayerState thePlayerState;
typedef NS_ENUM(NSInteger, PlayerStateType) { PlayerStateOff, PlayerStatePlaying, PlayerStatePaused };
typedef enum { PlayerStateOff, PlayerStatePlaying, PlayerStatePaused } PlayerState;
typedef NS_ENUM(NSUInteger, PlayerState) { PLAYER_OFF, PLAYER_PLAYING, PLAYER_PAUSED };
enum { PlayerStateOff, PlayerStatePlaying, PlayerStatePaused }; typedef NSInteger PlayerState;
typedef NS_OPTIONS(NSUInteger, BSTCMBorder) { BSTCMBOrderNoBorder = 0, BSTCMBorderTop = 1 << 0, BSTCMBorderRight = 1 << 1, BSTCMBorderBottom = 1 << 2, BSTCMBOrderLeft = 1 << 3 }; @interface BSTCMBorderUtility : NSObject + (void)setBorderOnView:(UIView *)view border:(BSTCMBorder)border width:(CGFloat)width color:(UIColor *)color; @end
@implementation BSTCMBorderUtility + (void)setBorderOnView:(UIView *)view border:(BSTCMBorder)border width:(CGFloat)width color:(UIColor *)color { if (border & BSTCMBOrderLeft) { } if (border & BSTCMBorderRight) { } } @end
char b = _BYTE_(0100, 0001); unsigned int w = _WORD_(1101, 1111, 0100, 0011); unsigned long int dw = _DWORD_(1101, 1111, 0100, 0011, 1111, 1101, 0010, 1000);
Bool NullFunc(const struct timespec *when, const char *who) { return TRUE; }
auto lambda = [](__attribute__((unused)) _workerid_t workerId) -> void { } ;
int foo (__attribute__((unused)) int bar) { return 0; }
void foo(int key) { int hash = 0; int bkt __attribute__((unused)) = 0; api_call(x, hash, bkt); }
If (MSVC) Set (CMAKE_EXE_LINKER_FLAGS "$ {CMAKE_EXE_LINKER_FLAGS} / NODEFAULTLIB: LIBCMT") Add_definitions (/W4 /wd4512 /wd4702 /wd4100 /wd4510 /wd4355 /wd4127) Add_definitions (/D_CRT_SECURE_NO_WARNINGS) Elseif (CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_GNUC) Add_definitions (-Wall -W -pedantic) Else () Message ("Unknown compiler") Endif ()
int main(int argc, char** argv) { time_t test; return 0; }
typedef long int __time_t; typedef __time_t time_t;
FILE *stream = [stream file pointer that you fprintf (stream, "%d\n", (int)time_t);
time_t now; struct tm local_date_time; now = time(NULL); memcpy (&local_date_time, localtime(&now), sizeof(local_date_time)); printf ("Year is: 19%02d\n", local_date_time.tm_year);
printf ("Year is: %d\n", local_date_time.tm_year + 1900);
typedef long int __quad_t; __extension__ typedef long long int __quad_t;
time_t now = 0; time(&now); printf("%jd", (intmax_t) now); printf("%lld", (long long) now);
int main() { size_t i = 9; size_t j = i / 5; printf("%zu\n",j); return 0; }
mov rax, QWORD PTR [rbp-16] ; Move i (=9) to RAX movabs rdx, -3689348814741910323 ; Move some magic number to RDX (?) mul rdx ; Multiply 9 by magic number mov rax, rdx ; Take only the upper 64 bits of the result shr rax, 2 ; Shift these bits 2 places to the right (?) mov QWORD PTR [rbp-8], rax ; Magically, RAX contains 9/5=1 now, ; so we can assign it to j
; upper 8 bytes of numerator = 2^(ℓ) = (upper part of 2^(N+ℓ)) ; lower 8 bytes of numerator for mlow = 0 ; lower 8 bytes of numerator for mhigh = 2^(N+ℓ-prec) = 2^(ℓ+shpre) = 2^(ℓ+e) numerator dq 2 dup(?) ;16 byte numerator divisor dq 1 dup(?) ; 8 byte divisor ; ... mov rcx,divisor mov rdx,0 mov rax,numerator+8 ;upper 8 bytes of numerator div rcx ;after div, rax == 1 mov rax,numerator ;lower 8 bytes of numerator div rcx mov rdx,1 ;rdx:rax = N+1 bit value = 65 bit value
$ myprog < inputfile.dat > output.txt 2> errors.txt
$ cat test.cc struct exception_fmt : std::exception { exception_fmt(char const* fmt, ...) __attribute__ ((format(printf,2,3))); char const* what() const throw() { return msg_; } char msg_[0x800]; }; exception_fmt::exception_fmt(char const* fmt, ...) { va_list ap; va_start(ap, fmt); vsnprintf(msg_, sizeof msg_, fmt, ap); va_end(ap); } int main(int ac, char** av) { throw exception_fmt("%s: bad number of arguments %d", *av, ac); } $ g++ -Wall -o test test.cc $ ./test terminate called after throwing an instance of what(): ./test: bad number of arguments 1 Aborted (core dumped)
int sprintf (char *string, const char *format [,item [,item]…]);
int vals[5] = {10, 20, 30, 40, 50}; int *ptr; ptr = vals; array element pointer notation number vals notation vals[0] 0 10 *(ptr + 0) ptr[0] *(vals + 0) vals[1] 1 20 *(ptr + 1) ptr[1] *(vals + 1) vals[2] 2 30 *(ptr + 2) ptr[2] *(vals + 2) vals[3] 3 40 *(ptr + 3) ptr[3] *(vals + 3) vals[4] 4 50 *(ptr + 4) ptr[4] *(vals + 4)
void func(int*& rpInt); int main() { int nvar=2; int* pvar=&nvar; func(pvar); .... return 0; }
void func(int** ppInt); int main() { int nvar=2; int* pvar=&nvar; func(&pvar); .... return 0; }
memcpy(destination, source, sizeof(source)); memcpy(&destination, source, sizeof(source)); memcpy(&destination[0], source, sizeof(source)); memcpy(destination, &source, sizeof(source)); memcpy(&destination, &source, sizeof(source)); memcpy(&destination[0], &source, sizeof(source)); memcpy(destination, &source[0], sizeof(source)); memcpy(&destination, &source[0], sizeof(source)); memcpy(&destination[0], &source[0], sizeof(source));
int foo(struct frog * f, int x, int y) { struct leg * g = f->left_leg; struct toe * t = g->big_toe; process(t);
int foo(struct frog * f, int x, int y) { process(f->left_leg->big_toe);
eisbaw@leno:~$ cdecl explain declare foo as pointer to function (pointer to const void) returning pointer to array 3 of int
typedef struct g_list GList; void g_list_foreach (GList *list, void (*func)(void *data, void *user_data), void* user_data);
int main(void) { int i = 5; i = (i, ++i, 1) + 1; printf("%d\n", i); return 0; }
do { } while ( prepAnything(), doSomethingElse(), logic_operation);
uint8_t raw_r[pixel_width][pixel_height]; uint8_t raw_g[pixel_width][pixel_height]; uint8_t raw_b[pixel_width][pixel_height]; uint8_t blue(uint32_t x, uint32_t y) { return (rand()%2)? (x+y)%rand() : ((x*y%1024)%rand())%2 ? (x-y)%rand() : rand(); } uint8_t green(uint32_t x, uint32_t y) { return (rand()%2)? (x-y)%rand() : ((x*y%1024)%rand())%2 ? (x+y)%rand() : rand(); } uint8_t red(uint32_t x, uint32_t y) { return (rand()%2)? (y-x)%rand() : ((x*y%1024)%rand())%2 ? (x+y)%rand() : rand(); } for (y=0; y<pixel_height; ++y) { for (x=0; x<pixel_width; ++x) { raw_b[x][y]=blue(x, y); raw_g[x][y]=green(x, y); raw_r[x][y]=red(x, y); } }
for (x=0; x<pixel_width; ++x) for (y=0; y<pixel_height; ++y) { r[x][y] = (x+y); g[x][y] = (y-x); /* b[x][y] = rand()%2? x : y; */ }
uint8_t blue(uint32_t x, uint32_t y) { return (rand() % 2) ? (x + y) % rand() : ((x * y % 1024) % rand()) % 2 ? (x - y) % rand() : rand(); }
int arr[7]; foo(arr); int x = *(arr + 1); size_t bytes = sizeof arr; void *q = &arr;
+---+ a: | | a[0] +---+ | | a[1] +---+ | | a[2] +---+ ... +---+ | | a[9] +---+
int a[7]; a[0] = 1976; a[1] = 1984; printf("memory location of a: %p", a); printf("value at memory location %p is %d", a, *a);
printf("value at memory location %p is %d", a + 1, *(a + 1));
printf("value at memory location %p is %d", &a[1], a[1]);
int main() { int a[3] = {9, 10, 11}; int **b = &a; printf("a == &a: %d\n", a == b); return 0; }
p.c: In function ‘main’: pp.c:6:12: warning: initialization from incompatible pointer type int **b = &a; ^ p.c:8:28: warning: comparison of distinct pointer types lacks a cast printf("a == &a: %d\n", a == b);
int main() { int a[3] = {9, 10, 11}; void *c = a; void *b = &a; void *d = &c; printf("a == &a: %d\n", a == b); printf("c == &c: %d\n", c == d); return 0; }
int a[]={1,2,3}; printf("%p\n",a); printf("%p\n",&a[0]);
char array = "hello wordl"; char* ptr = array; char c = array[2]; char *c1 = ptr[2];
clock_t begin = clock(); clock_t end = clock(); double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
struct timeval tv1, tv2; gettimeofday(&tv1, NULL); gettimeofday(&tv2, NULL); printf ("Total time = %f seconds\n", (double) (tv2.tv_usec - tv1.tv_usec) / 1000000 + (double) (tv2.tv_sec - tv1.tv_sec));
int main() { clock_t tic = clock(); my_expensive_function_which_can_spawn_threads(); clock_t toc = clock(); printf("Elapsed: %f seconds\n", (double)(toc - tic) / CLOCKS_PER_SEC); return 0; }
int main(){ clock_t start = clock(); clock_t stop = clock(); double elapsed = (double)(stop - start) * 1000.0 / CLOCKS_PER_SEC; printf("Time elapsed in ms: %f", elapsed); }
/* ISO/IEC 9899:1990 7.12.1: <time.h> The macro `CLOCKS_PER_SEC returned by the `clock extern long int __sysconf (int);
ruse.ru_stime.tv_sec + 1e-6 * \ (ruse.ru_utime.tv_usec + ruse.ru_stime.tv_usec)) int main(void) { time_t start, end; double first, second; time(&start); first = CPU_TIME; ... time(&end); second = CPU_TIME; printf("cpu : %.2f secs\n", second - first); printf("user : %d secs\n", (int)(end - start)); }
int main(){ clock_t begin=clock(); int i; for(i=0;i<100000;i++){ printf("%d",i); } clock_t end=clock(); printf("Time taken:%lf",(double)(end-begin)/CLOCKS_PER_SEC); }
TICK(TIME_A); functionA(); TOCK(TIME_A); TICK(TIME_B); functionB(); TOCK(TIME_B);
time TIME_A: 0.001652 sec. time TIME_B: 0.004028 sec.
int main() { struct timespec begin, end; clock_gettime(CLOCK_MONOTONIC_RAW, &begin); sleep(1); clock_gettime(CLOCK_MONOTONIC_RAW, &end); printf ("Total time = %f seconds\n", (end.tv_nsec - begin.tv_nsec) / 1000000000.0 + (end.tv_sec - begin.tv_sec)); }
CLOCK_MONOTONIC Clock that cannot be set and represents monotonic time since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g., if the system administrator manually changes the clock), but is affected by the incremental adjustments performed by adjtime(3) and NTP.
clock_t start=clock(); … clock_t end=clock(); CLOCKS_PER_SEC is constant in time.h library
int main() { int a[10000],i,j,min,temp; for(i=0;i<10000;i++) { a[i]=rand()%10000; } clock_t start,end; start=clock(); for(i=0;i<10000;i++) { for(j=i+1;j<10000;j++) { if(a[i]>a[j]) { int temp=a[i]; a[i]=a[j]; a[j]=temp; } } } end=clock(); double extime=(double) (end-start)/CLOCKS_PER_SEC; printf("\n\tExecution time for the bubble sort is %f seconds\n ",extime); for(i=0;i<10000;i++) { a[i]=rand()%10000; } clock_t start1,end1; start1=clock(); for(i=0;i<10000;i++) { min=i; for(j=i+1;j<10000;j++) { if(a[min]>a[j]) { min=j; } } temp=a[min]; a[min]=a[i]; a[i]=temp; } end1=clock(); double extime1=(double) (end1-start1)/CLOCKS_PER_SEC; printf("\n"); printf("\tExecution time for the selection sort is %f seconds\n\n", extime1); if(extime1<extime) printf("\tSelection sort is faster than Bubble sort by %f seconds\n\n", extime - extime1); else if(extime1>extime) printf("\tBubble sort is faster than Selection sort by %f seconds\n\n", extime1 - extime); else printf("\tBoth algorithms have the same execution time\n\n"); }
int main () { int i; char buffer [33]; printf ("Enter a number: "); scanf ("%d",&i); itoa (i,buffer,10); printf ("decimal: %s\n",buffer); itoa (i,buffer,16); printf ("hexadecimal: %s\n",buffer); itoa (i,buffer,2); printf ("binary: %s\n",buffer); return 0; }
int someInt = 368; char str[12]; sprintf(str, "%d", someInt);
char* itoa(int i, char b[]){ char const digit[] = "0123456789"; char* p = b; if(i<0){ *p++ = i *= -1; } int shifter = i; do{ ++p; shifter = shifter/10; }while(shifter); *p = do{ *--p = digit[i%10]; i = i/10; }while(i); return b; }
DISABLE_WARNING(unused-variable,unused-variable,42) [.... some code with warnings in here ....] ENABLE_WARNING(unused-variable,unused-variable,42)
CPPFLAGS:=-std=c11 -W -Wall -pedantic -Werror .PHONY: all all: puts
int main(int argc, const char *argv[]) { while (*++argv) puts(*argv); return 0; }
int main(__attribute__((unused)) int argc, const char *argv[]) { while (*++argv) puts(*argv); return 0; }
_Pragma("GCC diagnostic push") _Pragma("GCC diagnostic ignored \"-Wunused-parameter\"") int main(int argc, const char *argv[]) { while (*++argv) puts(*argv); return 0; } _Pragma("GCC diagnostic pop") \
int main(int argc, const char *argv[]) { while (*++argc) puts(*argv); return 0; }
CPPFLAGS:=-std=c11 -W -Wall -pedantic -Werror .PHONY: all all: puts puts.o: CPPFLAGS+=-Wno-unused-parameter
set(CMAKE_CXX_FLAGS "-std=c++0x -Wall -Wextra -Wstrict-aliasing -pedantic -Werror -Wunreachable-code ${CMAKE_CXX_FLAGS}")
void foo1( void ) { /* The following line of code would normally provoke diagnostic message Instead, we have suppressed this warning throughout the entire scope of foo1(). */ int x; }
void print(const char *fmt, ...) { va_list args; va_start(args, fmt); vsprintf(str, fmt, args); va_end(args); printf("%s\n", str); } int main() { PRINT("[%s %d, %d] Hello World", "March", 26, 2009); return 0; }
struct mystruct_A { char a; int b; char c; } x; struct mystruct_B { int b; char a; } y;
struct mystruct_A { char a; char gap_0[3]; int b; char c; char gap_1[3]; } x;
struct __attribute__((__packed__)) mystruct_A { char a; int b; char c; };
/** * Memory align & padding - for struct. * compile: gcc memory_align.c * execute: ./a.out */ struct stu_a { int i; char c; }; struct stu_b { long l; char c; }; struct stu_c { int i; long l; char c; }; struct stu_d { long l; int i; char c; }; struct stu_e { double d; int i; char c; }; struct stu_f { int i; double d; char c; }; struct stu_g { int i; }; struct stu_h { long l; }; int test_struct_padding() { printf("%s: %ld\n", "stu_a", sizeof(struct stu_a)); printf("%s: %ld\n", "stu_b", sizeof(struct stu_b)); printf("%s: %ld\n", "stu_c", sizeof(struct stu_c)); printf("%s: %ld\n", "stu_d", sizeof(struct stu_d)); printf("%s: %ld\n", "stu_e", sizeof(struct stu_e)); printf("%s: %ld\n", "stu_f", sizeof(struct stu_f)); printf("%s: %ld\n", "stu_g", sizeof(struct stu_g)); printf("%s: %ld\n", "stu_h", sizeof(struct stu_h)); return 0; } int test_struct_address() { printf("%s: %ld\n", "stu_g", sizeof(struct stu_g)); printf("%s: %ld\n", "stu_h", sizeof(struct stu_h)); printf("%s: %ld\n", "stu_f", sizeof(struct stu_f)); struct stu_g g; struct stu_h h; struct stu_f f1; struct stu_f f2; int x = 1; long y = 1; printf("address of %s: %p\n", "g", &g); printf("address of %s: %p\n", "h", &h); printf("address of %s: %p\n", "f1", &f1); printf("address of %s: %p\n", "f2", &f2); printf("address of %s: %p\n", "x", &x); printf("address of %s: %p\n", "y", &y); printf("space between %s and %s: %ld\n", "g", "h", (long)(&h) - (long)(&g)); printf("space between %s and %s: %ld\n", "h", "f1", (long)(&f1) - (long)(&h)); printf("space between %s and %s: %ld\n", "f1", "f2", (long)(&f2) - (long)(&f1)); printf("space between %s and %s: %ld\n", "x", "f2", (long)(&x) - (long)(&f2)); printf("space between %s and %s: %ld\n", "g", "x", (long)(&x) - (long)(&g)); printf("space between %s and %s: %ld\n", "x", "y", (long)(&y) - (long)(&x)); printf("space between %s and %s: %ld\n", "g", "y", (long)(&y) - (long)(&h)); return 0; } int main(int argc, char * argv[]) { test_struct_padding(); return 0; }
stu_a: 8 stu_b: 16 stu_c: 24 stu_d: 16 stu_e: 16 stu_f: 24 stu_g: 4 stu_h: 8
stu_g: 4 stu_h: 8 stu_f: 24 address of g: 0x7fffd63a95d0 address of h: 0x7fffd63a95e0 address of f1: 0x7fffd63a95f0 address of f2: 0x7fffd63a9610 address of x: 0x7fffd63a95dc address of y: 0x7fffd63a95e8 space between g and h: 16 space between h and f1: 16 space between f1 and f2: 32 space between x and f2: -52 space between g and x: 12 space between x and y: 12 space between g and y: 8
my_array = 0022FF00 &my_array = 0022FF00 pointer_to_array = 0022FF00 &pointer_to_array = 0022FEFC
int main() { char my_array[100] = "some cool string"; printf("my_array = %p\n", my_array); printf("&my_array = %p\n", &my_array); char *pointer_to_array = my_array; printf("pointer_to_array = %p\n", pointer_to_array); printf("&pointer_to_array = %p\n", &pointer_to_array); printf("Press ENTER to continue...\n"); getchar(); return 0; }
char array[16]; printf("%p\t%p", (void*)&array, (void*)(&array+1));
+---+---+---+---+---+---+---+---+---+---+ | | | | | | | | | | | +---+---+---+---+---+---+---+---+---+---+ ^ | Address of my_array.
my_array[0] | v +---+---+---+---+---+---+---+---+---+---+ | | | | | | | | | | | +---+---+---+---+---+---+---+---+---+---+ ^ | Address of my_array[0].
printf("my_array = %p\n", my_array); printf("my_array = %p\n", &my_array);
printf("my_array = %s\n", my_array); printf("my_array = %p\n", my_array);
int integerDivisionResultPositive= 125/100; double flooringResultPositive= floor(125.0/100.0);
int integerDivisionResultNegative= -125/100; double flooringResultNegative= floor(-125.0/100.0);
free((float *)velocity); free((float *)acceleration); free((char *)label);
const float* velocity = malloc(2*sizeof(float)); free(velocity);
main.c: In function ‘main’: main.c:9:5: warning: passing argument 1 of ‘free’ discards ‘const’ qualifier from pointer target type [enabled by default] free(velocity); ^ In file included from main.c:2:0: /usr/include/stdlib.h:482:13: note: expected ‘void *’ but argument is of type ‘const float *’ extern void free (void *__ptr) __THROW;
volatile int* p = (volatile int*)malloc(5 * sizeof(int)); free(p); free((int*)p); free((void*)p);
void free_test(const char *cp, volatile char *vp, char * restrict rp, char * restrict *rp2) { free(cp); free(vp); free(rp); free(rp2); } int main(void) { free_test(0,0,0,0); return 0; }
free_stuff(a, b, c) float *a; char *b; int *c; { free(a); free(b); free(c); }
typedef struct foo_t { int a, b, c; } foo_t; const foo_t foo_init = { 1, 2, 3 }; foo_t my_foo = foo_init; int main() { return 0; }
int initializer(void) { return 50; } int main() { int j; for (j=0;j<10;j++) { static int i = initializer(); printf(" value of i = %d ", i); i++; } return 0; }
typedef struct foo_t { int a; int b; int c; } foo_t; static const foo_t s_FooInit = { .a=1, .b=2, .c=3 }; static const foo_t *const s_pFooInit = (&(const foo_t){ .a=2, .b=4, .c=6 }); int main (int argc, char **argv) { const foo_t *const f1 = &s_FooInit; const foo_t *const f2 = s_pFooInit; printf("Foo1 = %d, %d, %d\n", f1->a, f1->b, f1->c); printf("Foo2 = %d, %d, %d\n", f2->a, f2->b, f2->c); return 0; }
thread: initialise. lock mutex. while thread not told to stop working: wait on condvar using mutex. if work is available to be done: do the work. unlock mutex. clean up. exit thread.
thread: initialise. lock mutex. while thread not told to stop working: wait on condvar using mutex. if work is available to be done: copy work to thread local storage. unlock mutex. do the work. lock mutex. unlock mutex. clean up. exit thread.
lock mutex. flag work as available. signal condition variable. unlock mutex.
while(1) { pthread_cond_wait(&cond); char *data = some_data; some_data = NULL; handle(data); }
while(1) { pthread_cond_wait(&cond); pthread_mutex_lock(&mutex); char *data = some_data; some_data = NULL; pthread_mutex_unlock(&mutex); handle(data); }
while(1) { pthread_mutex_lock(&mutex); while(some_data == NULL) { pthread_cond_wait(&cond,&mutex); } char *data = some_data; some_data = NULL; pthread_mutex_unlock(&mutex); handle(data); }
while(1) { pthread_mutex_lock(&work_mutex); while (work_queue_empty()) pthread_cond_wait(&work_cv, &work_mutex); work = get_work_from_queue(); pthread_mutex_unlock(&work_mutex); do_work(work); }
void AssignWork(WorkItem work) { pthread_mutex_lock(&work_mutex); add_work_to_queue(work); pthread_cond_signal(&work_cv); pthread_mutex_unlock(&work_mutex); }
while (notDone) { pthread_mutex_lock(&mutex); bool ready = protectedReadyToRunVariable pthread_mutex_unlock(&mutex); if (ready) { doWork(); } else { pthread_cond_wait(&cond1); } } prepareToRunThread1(); pthread_mutex_lock(&mutex); protectedReadyToRuNVariable = true; pthread_mutex_unlock(&mutex); pthread_cond_signal(&cond1); Now, lets look at a particularly nasty interleaving of these operations pthread_mutex_lock(&mutex); bool ready = protectedReadyToRunVariable; pthread_mutex_unlock(&mutex); pthread_mutex_lock(&mutex); protectedReadyToRuNVariable = true; pthread_mutex_unlock(&mutex); pthread_cond_signal(&cond1); if (ready) { pthread_cond_wait(&cond1);
while (notDone) { pthread_mutex_lock(&mutex); bool ready = protectedReadyToRunVariable if (ready) { pthread_mutex_unlock(&mutex); doWork(); } else { pthread_cond_wait(&mutex, &cond1); } } prepareToRunThread1(); pthread_mutex_lock(&mutex); protectedReadyToRuNVariable = true; pthread_cond_signal(&mutex, &cond1); pthread_mutex_unlock(&mutex);
mutex.lock() while(!check()) condition.wait() mutex.unlock()
int compteur = 0; pthread_cond_t varCond = PTHREAD_COND_INITIALIZER; pthread_mutex_t mutex_compteur; void attenteSeuil(arg) { pthread_mutex_lock(&mutex_compteur); while(compteur < 10) { printf("Compteur : %d<10 so i am waiting...\n", compteur); pthread_cond_wait(&varCond, &mutex_compteur); } printf("I waited nicely and now the compteur = %d\n", compteur); pthread_mutex_unlock(&mutex_compteur); pthread_exit(NULL); } void incrementCompteur(arg) { while(1) { pthread_mutex_lock(&mutex_compteur); if(compteur == 10) { printf("Compteur = 10\n"); pthread_cond_signal(&varCond); pthread_mutex_unlock(&mutex_compteur); pthread_exit(NULL); } else { printf("Compteur ++\n"); compteur++; } pthread_mutex_unlock(&mutex_compteur); } } int main(int argc, char const *argv[]) { int i; pthread_t threads[2]; pthread_mutex_init(&mutex_compteur, NULL); pthread_create(&threads[0], NULL, incrementCompteur, NULL); pthread_create(&threads[1], NULL, attenteSeuil, NULL); pthread_exit(NULL); }
error: format specifies type [-Werror,-Wformat] printf("PRINTF(d) \t: %d\n", -2147483648); ~~ ^~~~~~~~~~~ %ld
int f1(int); static int f2(int); int f1(int foo) { return f2(foo); /* (basically same .c file) as f1 */ } int f2(int foo) { return 42 + foo; }
int f1(int); int f2(int); int main(void) { f1(10); f2(12); return 0; }
static void FunctionInHeader(); void FunctionInHeader() { printf("Calling function inside header\n"); }
void FunctionInHeader() { printf("Calling function inside header\n"); }
main() { int a,b,c; int count = 1; for (b=c=10;a="- FIGURE?, UMKC,XYZHello Folks,\ TFy!QJu ROo TNn(ROo)SLq SLq ULo+\ UHs UJq TNn*RPn/QPbEWS_JSWQAIJO^\ NBELPeHBFHT}TnALVlBLOFAkHFOuFETp\ HCStHAUFAgcEAelclcn^r^r\\tZvYxXy\ T|S~Pn SPm SOn TNn ULo0ULo Hq!WFs XDt!" [b+++21]; ) for(; a-- > 64 ; ) putchar ( ++c== return 0; }
int main (void) { int a=10, b=0, c=10; char* bits ="TFy!QJu ROo TNn(ROo)SLq SLq ULo+UHs UJq TNn*RPn/QPbEWS_JSWQAIJO^NBELPeHBFHT}TnALVlBLOFAkHFOuFETpHCStHAUFAgcEAelclcn^r^r\\tZvYxXyT|S~Pn SPm SOn TNn ULo0ULo a = bits[b]; while (a != 0) { a = bits[b]; b++; while (a > 64) { a--; if (++c == c /= 9; putchar(c); } else { putchar(33 ^ (b & 0x01)); } } } return 0; }
++c; if (c==90) { c = 10; putchar( } else { if (b % 2 == 0) putchar( else putchar( }
do { \ func1(x); \ func2(x); \ func3(x); \ } while (0)
if (thisValue == FALSE) if (thatValue == TRUE) if (otherValue != TRUE)
if (someBoolValue == FALSE) if (!someBoolValue) return (x > 0) ? TRUE : FALSE; return (x > 0); if (ptr == NULL) if (!ptr) if (ptr == FALSE)
void foo(bool x) { std::puts("bool"); } void foo(int x) { std::puts("int"); } int main() { foo(1 == 1); foo(1); return 0; }
int my_printf(char *fmt, ...) { fprintf(stderr, "Calling printf with fmt %s", fmt); return SOMEHOW_INVOKE_LIBC_PRINTF; }
void myfun(const char *fmt, va_list argp) { vfprintf(stderr, fmt, argp); }
int m_printf(char *fmt, ...) { int ret; va_list myargs; va_start(myargs, fmt); ret = vprintf(fmt, myargs); va_end(myargs); return ret; }
do { \ fprintf(stderr, "Calling printf with fmt %s\n", format); \ some_other_variadac_function(format, } while(0)
int my_printf(char *format, ...) { va_list args; va_start(args, format); int r = vprintf(format, args); va_end(args); return r; }
/* This macros allow wrapping variadic functions. * Currently we don * we assume that the standard calling conventions are used. * * The wrapper function has to start with VA_WRAP_PROLOGUE() * and the original function can be called by * VA_WRAP_CALL(function, ret), whereas the return value will * be stored in ret. The caller has to provide ret * even if the original function was returning void. */ uintptr_t va_wrap_this_bp,va_wrap_old_bp; \ va_wrap_this_bp = va_wrap_get_bp(); \ va_wrap_old_bp = *(uintptr_t *) va_wrap_this_bp; \ va_wrap_this_bp += 2 * sizeof(uintptr_t); \ size_t volatile va_wrap_size = va_wrap_old_bp - va_wrap_this_bp; \ uintptr_t *va_wrap_stack = alloca(va_wrap_size); \ memcpy((void *) va_wrap_stack, \ (void *)(va_wrap_this_bp), va_wrap_size); static inline uintptr_t __attribute__((always_inline)) va_wrap_get_bp() { uintptr_t ret; asm volatile ("mov %%rbp, %0":"=r"(ret)); return ret; } uintptr_t va_wrap_ret; \ uintptr_t va_wrap_saved_args[7]; \ asm volatile ( \ "mov %%rsi, (%%rax)\n\t" \ "mov %%rdi, 0x8(%%rax)\n\t" \ "mov %%rdx, 0x10(%%rax)\n\t" \ "mov %%rcx, 0x18(%%rax)\n\t" \ "mov %%r8, 0x20(%%rax)\n\t" \ "mov %%r9, 0x28(%%rax)\n\t" \ : \ :"a"(va_wrap_saved_args) \ ); VA_WRAP_CALL_COMMON(); \ va_wrap_saved_args[6] = (uintptr_t)va_wrap_stack; \ asm volatile ( \ "mov (%%rax), %%rsi \n\t" \ "mov 0x8(%%rax), %%rdi \n\t" \ "mov 0x10(%%rax), %%rdx \n\t" \ "mov 0x18(%%rax), %%rcx \n\t" \ "mov 0x20(%%rax), %%r8 \n\t" \ "mov 0x28(%%rax), %%r9 \n\t" \ "mov $0, %%rax \n\t" \ "call *%%rbx \n\t" \ : "=a" (va_wrap_ret) \ : "b" (func), "a" (va_wrap_saved_args) \ : "%rcx", "%rdx", \ "%rsi", "%rdi", "%r8", "%r9", \ "%r10", "%r11", "%r12", "%r14", \ "%r15" \ ); \ ret = (typeof(ret)) va_wrap_ret; static inline uintptr_t __attribute__((always_inline)) va_wrap_get_bp() { uintptr_t ret; asm volatile ("mov %%ebp, %0":"=a"(ret)); return ret; } uintptr_t va_wrap_ret; VA_WRAP_CALL_COMMON(); \ asm volatile ( \ "mov %2, %%esp \n\t" \ "call *%1 \n\t" \ : "=a"(va_wrap_ret) \ : "r" (func), \ "r"(va_wrap_stack) \ : "%ebx", "%ecx", "%edx" \ ); \ ret = (typeof(ret))va_wrap_ret;
int __VA_WRAP_CALL_FUNC wrap_printf(char *str, ...) { VA_WRAP_PROLOGUE(); int ret; VA_WRAP_CALL(printf, ret); printf("printf returned with %d \n", ret); return ret; }
int my_printf(char *fmt, ...) { va_list va; int ret; va_start(va, fmt); ret = vfprintf(stderr, fmt, va); va_end(va); return ret; }
int old_variadic_function(int n, ...) { va_list args; int i = 0; va_start(args, n); if(i++<n) printf("arg %d is 0x%x\n", i, va_arg(args, int)); if(i++<n) printf("arg %d is %g\n", i, va_arg(args, double)); if(i++<n) printf("arg %d is %g\n", i, va_arg(args, double)); va_end(args); return n; } int old_variadic_function_wrapper(int n, ...) { va_list args; int a1; int a2; int a3; int a4; int a5; int a6; int a7; int a8; va_start(args, n); a1 = va_arg(args, int); a2 = va_arg(args, int); a3 = va_arg(args, int); a4 = va_arg(args, int); a5 = va_arg(args, int); a6 = va_arg(args, int); a7 = va_arg(args, int); va_end(args); return old_variadic_function(n, a1, a2, a3, a4, a5, a6, a7, a8); } int main(void) { printf("Call 1: 1, 0x123\n"); old_variadic_function(1, 0x123); printf("Call 2: 2, 0x456, 1.234\n"); old_variadic_function(2, 0x456, 1.234); printf("Call 3: 3, 0x456, 4.456, 7.789\n"); old_variadic_function(3, 0x456, 4.456, 7.789); printf("Wrapped call 1: 1, 0x123\n"); old_variadic_function_wrapper(1, 0x123); printf("Wrapped call 2: 2, 0x456, 1.234\n"); old_variadic_function_wrapper(2, 0x456, 1.234); printf("Wrapped call 3: 3, 0x456, 4.456, 7.789\n"); old_variadic_function_wrapper(3, 0x456, 4.456, 7.789); return 0; }
printf("printing using format: %s", f);\ printf(f, __VA_ARGS__) int Option_ResolveVariadicAndPassOn(const char * f, ... ) { int r; va_list args; printf("printing using format: %s", f); va_start(args, f); r = vprintf(f, args); va_end(args); return r; } void main() { const char * f = "%s %s %s\n"; const char * a = "One"; const char * b = "Two"; const char * c = "Three"; printf("---- Normal Print ----\n"); printf(f, a, b, c); printf("\n"); printf("---- Option_VariadicMacro ----\n"); Option_VariadicMacro(f, a, b, c); printf("\n"); printf("---- Option_ResolveVariadicAndPassOn ----\n"); Option_ResolveVariadicAndPassOn(f, a, b, c); printf("\n"); }
$ echo " [..] /usr/local/include /usr/lib/gcc/i686-apple-darwin9/4.0.1/include /usr/include /System/Library/Frameworks (framework directory) /Library/Frameworks (framework directory) End of search list. [..] t.c:1:32: error: bogus.h: No such file or directory
/usr/local/include libdir/gcc/target/version/include /usr/target/include /usr/include
$ LC_ALL=C gcc -v -E -xc - < /dev/null 2>&1 | LC_ALL=C sed -ne
/usr/lib/gcc/x86_64-linux-gnu/5/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed /usr/include/x86_64-linux-gnu /usr/include End of search list.
void MultiplyArrays(int* dest, int* src1, int* src2, int n) { for(int i = 0; i < n; i++) { dest[i] = src1[i]*src2[i]; } }
void f(int *a, int *b, int *x) { *a += *x; *b += *x; }
load R1 ← *x ; Load the value of x pointer load R2 ← *a ; Load the value of a pointer add R2 += R1 ; Perform Addition set R2 → *a ; Update the value of a pointer ; Similarly for b, note that x is loaded twice, ; because a may be equal to x. load R1 ← *x load R2 ← *b add R2 += R1 set R2 → *b
void fr(int *restrict a, int *restrict b, int *restrict x);
load R1 ← *x load R2 ← *a add R2 += R1 set R2 → *a ; Note that x is not reloaded, ; because the compiler knows it is unchanged ; load R1 ← *x load R2 ← *b add R2 += R1 set R2 → *b
void f(int *a, int *b, int *x) { *a += *x; 0: 8b 02 mov (%rdx),%eax 2: 01 07 add %eax,(%rdi) *b += *x; 4: 8b 02 mov (%rdx),%eax 6: 01 06 add %eax,(%rsi) void fr(int *restrict a, int *restrict b, int *restrict x) { *a += *x; 10: 8b 02 mov (%rdx),%eax 12: 01 07 add %eax,(%rdi) *b += *x; 14: 01 06 add %eax,(%rsi)
void f(char *restrict p1, char *restrict p2) { for (int i = 0; i < 50; i++) { p1[i] = 4; p2[i] = 9; } }
3f0: 48 85 d2 test %rdx,%rdx 3f3: 74 33 je 428 <fr+0x38> 3f5: 55 push %rbp 3f6: 53 push %rbx 3f7: 48 89 f5 mov %rsi,%rbp 3fa: be 04 00 00 00 mov $0x4,%esi 3ff: 48 89 d3 mov %rdx,%rbx 402: 48 83 ec 08 sub $0x8,%rsp 406: e8 00 00 00 00 callq 40b <fr+0x1b> 407: R_X86_64_PC32 memset-0x4 40b: 48 83 c4 08 add $0x8,%rsp 40f: 48 89 da mov %rbx,%rdx 412: 48 89 ef mov %rbp,%rdi 415: 5b pop %rbx 416: 5d pop %rbp 417: be 09 00 00 00 mov $0x9,%esi 41c: e9 00 00 00 00 jmpq 421 <fr+0x31> 41d: R_X86_64_PC32 memset-0x4 421: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 428: f3 c3 repz retq
int main() { fun(2, "21"); return 0; } int fun(int x, char *p) { }
int main() { some_main("Hello, World\n"); } int some_main(const char *name) { printf("%s", name); }
static int some_main(const char *name); int some_main(const char *name) { }
int *start = ..., *end = ...; int *mid = start + (end - start) / 2; int *mid = (start + end) / 2;
int start = 0x7ffffffe, end = 0x7fffffff; int mid = start + (end - start) / 2; int mid = (start + end) / 2;
unsigned start = 0xfffffffeu, end = 0xffffffffu; unsigned mid = start + (end - start) / 2; unsigned mid = (start + end) / 2;
int start = -3, end = 0; int mid = start + (end - start) / 2; int mid = (start + end) / 2;
54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+ | | 58 | | | 63 | | 55 | | | h | e | l | l | o | \0 | | +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
int getValueOf5(int *p) { *p = 5; return 1; } int get1024HeapMemory(int **p) { *p = malloc(1024); if(*p == 0) return -1; else return 0; }
int x; getValueOf5(&x); int *p; get1024HeapMemory(&p);
void test() { double **a; int i1 = sizeof(a[0]); double matrix[ROWS][COLUMNS]; int i2 = sizeof(matrix[0]); }
if (prev) prev->next = entry->next; else list_head = entry->next;
- struct combine_diff_path *p, *pprev, *ptmp; + struct combine_diff_path *p, **tail = &curr;
typedef struct list_entry { int val; struct list_entry *next; } list_entry;
list_entry *entry = head; list_entry *prev = NULL; while (entry) { if (entry->val == to_remove) if (prev) prev->next = entry->next; else head = entry->next; prev = entry; entry = entry->next; }
list_entry **pp = &head; list_entry *entry = head; while (entry) { if (entry->val == to_remove) *pp = entry->next; pp = &entry->next; entry = entry->next; }
Address of variable num has : 1000 Address of Pointer ptr1 is: 2000 Address of Pointer ptr2 is: 3000
int main () { int num = 10; int *ptr1; int **ptr2; ptr1 = &num; ptr2 = &ptr1; printf("Value of num = %d\n", num ); printf("Value available at *ptr1 = %d\n", *ptr1 ); printf("Value available at **ptr2 = %d\n", **ptr2); }
Value of num = 10 Value available at *ptr1 = 10 Value available at **ptr2 = 10
int fun( int **i ) { int *j; *i = (int*)malloc ( 2*sizeof(int) ); **i = 11; j = *i; j++; *j = 12; ; return 2; } int main() { int *i; int n = fun( &i ); for ( int j=0; j<n; j++ ) printf( "roll no = %d \n", i[j] ); return 0; }
int a, *p_a; a = 56; p_a = &a; *p_a = 15; printf("pointer p_a is having value %d and targeting at variable value %d", p_a, *p_a);
~(x+y) == ~x + ~y <==> ~(x+y) + (x+y) == ~x + ~y + (x+y) <==> ~(x+y) + (x+y) == (~x + x) + (~y + y) <==> ~(x+y) + (x+y) == -1 + -1 <==> ~(x+y) + (x+y) == -2 <==> -1 == -2
~x = (2^n - 1) - x ~y = (2^n - 1) - y ~x + ~y = (2^n - 1) +(2^n - 1) - x - y => (2^n + (2^n - 1) - x - y ) - 1 => modulo: (2^n - 1) - x - y - 1.
~(x + y) = (2^n - 1) - (x + y) = (2^n - 1) - x - y.
volatile unsigned int stop_now = 0; extern void bar_function(void); int main(void) { while (1) { bar_function(); stop_now = 1; } return 0; }
extern volatile unsigned int stop_now; void bar_function(void) { while (! stop_now) { printf("Hello, world!\n"); sleep(30); } }
static int g(); extern int g(); extern int j(); extern int h(); static int h();
char *trimwhitespace(char *str) { char *end; while(isspace((unsigned char)*str)) str++; if(*str == 0) return str; end = str + strlen(str) - 1; while(end > str && isspace((unsigned char)*end)) end--; end[1] = return str; }
size_t trimwhitespace(char *out, size_t len, const char *str) { if(len == 0) return 0; const char *end; size_t out_size; while(isspace((unsigned char)*str)) str++; if(*str == 0) { *out = 0; return 1; } end = str + strlen(str) - 1; while(end > str && isspace((unsigned char)*end)) end--; end++; out_size = (end - str) < len-1 ? (end - str) : len-1; memcpy(out, str, out_size); out[out_size] = 0; return out_size; }
char *trim(char *str) { size_t len = 0; char *frontp = str; char *endp = NULL; if( str == NULL ) { return NULL; } if( str[0] == len = strlen(str); endp = str + len; /* Move the front and back pointers to address the first non-whitespace * characters from each end. */ while( isspace((unsigned char) *frontp) ) { ++frontp; } if( endp != frontp ) { while( isspace((unsigned char) *(--endp)) && endp != frontp ) {} } if( str + len - 1 != endp ) *(endp + 1) = else if( frontp != str && endp == frontp ) *str = /* Shift the string so that it starts at str so that if it * allocated, we can still free it on the returned pointer. Note the reuse * of endp to mean the front of the string buffer now. */ endp = str; if( frontp != str ) { while( *frontp ) { *endp++ = *frontp++; } *endp = } return str; }
int main(int argc, char *argv[]) { char *sample_strings[] = { "nothing to trim", " trim the front", "trim the back ", " trim one char front and back ", " trim one char front", "trim one char back ", " ", " ", "a", "", NULL }; char test_buffer[64]; int index; for( index = 0; sample_strings[index] != NULL; ++index ) { strcpy( test_buffer, sample_strings[index] ); printf("[%s] -> [%s]\n", sample_strings[index], trim(test_buffer)); } return 0; }
void trim(char * s) { char * p = s; int l = strlen(p); while(isspace(p[l - 1])) p[--l] = 0; while(* p && isspace(* p)) ++p, --l; memmove(s, p, l + 1); }
char * trim(char * s) { int l = strlen(s); while(isspace(s[l - 1])) --l; while(* s && isspace(* s)) ++s, --l; return strndup(s, l); }
enum strtrim_mode_t { STRLIB_MODE_ALL = 0, STRLIB_MODE_RIGHT = 0x01, STRLIB_MODE_LEFT = 0x02, STRLIB_MODE_BOTH = 0x03 }; char *strcpytrim(char *d, char *s, int mode, char *delim ); char *strtriml(char *d, char *s); char *strtrimr(char *d, char *s); char *strtrim(char *d, char *s); char *strkill(char *d, char *s); char *triml(char *s); char *trimr(char *s); char *trim(char *s); char *kill(char *s);
char *strcpytrim(char *d, char *s, int mode, char *delim ) { char *o = d; char *e = 0; char dtab[256] = {0}; if (!s || !d) return 0; if (!delim) delim = " \t\n\f"; while (*delim) dtab[*delim++] = 1; while ( (*d = *s++) != 0 ) { if (!dtab[0xFF & (unsigned int)*d]) { e = 0; } else { if (!e) e = d; if ( mode == STRLIB_MODE_ALL || ((mode != STRLIB_MODE_RIGHT) && (d == o)) ) continue; } d++; } if (mode != STRLIB_MODE_LEFT && e) { *e = 0; } return o; } char *strtriml(char *d, char *s) { return strcpytrim(d, s, STRLIB_MODE_LEFT, 0); } char *strtrimr(char *d, char *s) { return strcpytrim(d, s, STRLIB_MODE_RIGHT, 0); } char *strtrim(char *d, char *s) { return strcpytrim(d, s, STRLIB_MODE_BOTH, 0); } char *strkill(char *d, char *s) { return strcpytrim(d, s, STRLIB_MODE_ALL, 0); } char *triml(char *s) { return strcpytrim(s, s, STRLIB_MODE_LEFT, 0); } char *trimr(char *s) { return strcpytrim(s, s, STRLIB_MODE_RIGHT, 0); } char *trim(char *s) { return strcpytrim(s, s, STRLIB_MODE_BOTH, 0); } char *kill(char *s) { return strcpytrim(s, s, STRLIB_MODE_ALL, 0); }
void trim(char *str) { int i; int begin = 0; int end = strlen(str) - 1; while (isspace((unsigned char) str[begin])) begin++; while ((end >= begin) && isspace((unsigned char) str[end])) end--; for (i = begin; i <= end; i++) str[i - begin] = str[i]; str[i - begin] = }
int main() { const char *target = " haha "; char buf[256]; sscanf(target, "%s", buf); printf("<%s>\n", buf); }
void trim(char * const a) { char *p = a, *q = a; while (isspace(*q)) ++q; while (*q) *p++ = *q++; *p = while (p > a && isspace(*--p)) *p = } /* See http: FCT_BGN() { FCT_QTEST_BGN(trim) { { char s[] = ""; trim(s); fct_chk_eq_str("", s); } { char s[] = " "; trim(s); fct_chk_eq_str("", s); } { char s[] = "\t"; trim(s); fct_chk_eq_str("", s); } { char s[] = "a"; trim(s); fct_chk_eq_str("a", s); } { char s[] = "abc"; trim(s); fct_chk_eq_str("abc", s); } { char s[] = " a"; trim(s); fct_chk_eq_str("a", s); } { char s[] = " a c"; trim(s); fct_chk_eq_str("a c", s); } { char s[] = "a "; trim(s); fct_chk_eq_str("a", s); } { char s[] = "a c "; trim(s); fct_chk_eq_str("a c", s); } { char s[] = " a "; trim(s); fct_chk_eq_str("a", s); } { char s[] = " a c "; trim(s); fct_chk_eq_str("a c", s); } { char s[] = "a "; trim(s + 2); fct_chk_eq_str("", s + 2); fct_chk_eq_str("a ", s); } { char s[] = " foobar"; trim(s); fct_chk_eq_str("foobar", s); char r[16] = { fct_chk_eq_int(0, memcmp(s, r, sizeof(s))); } } FCT_QTEST_END(); } FCT_END();
void fnStrTrimInPlace(char *szWrite) { const char *szWriteOrig = szWrite; char *szLastSpace = szWrite, *szRead = szWrite; int bNotSpace; while( *szRead != bNotSpace = !isspace((unsigned char)(*szRead)); if( (szWrite != szWriteOrig) || bNotSpace ) { *szWrite = *szRead; szWrite++; if( bNotSpace ) szLastSpace = szWrite; } szRead++; } *szLastSpace = }
char *string_trim_inplace(char *s) { while (isspace((unsigned char) *s)) s++; if (*s) { char *p = s; while (*p) p++; while (isspace((unsigned char) *(--p))); p[1] = } return s; }
char *string_trim_inplace(char *s) { char *original = s; size_t len = 0; while (isspace((unsigned char) *s)) { s++; } if (*s) { char *p = s; while (*p) p++; while (isspace((unsigned char) *(--p))); p[1] = len = (size_t) (p - s); } return (s == original) ? s : memove(original, s, len + 1); }
int main() { char *foo=" teststring "; char *bar; sscanf(foo,"%s",bar); printf("String is >%s<\n",bar); return 0; }
char * trim2(char *d, const char *s) { if (s == NULL || d == NULL) return NULL; const unsigned char * p = (const unsigned char *)s; while (isspace(*p)) p++; unsigned char * dst = (unsigned char *)d; unsigned char * end = dst; while (*p != { if (!isspace(*dst++ = *p++)) end = dst; } *end = return d; } char * trim(char *s) { return trim2(s, s); }
Ustr *s1 = USTR1(\7, " 12345 "); ustr_sc_trim_cstr(&s1, " "); assert(ustr_cmp_cstr_eq(s1, "12345"));
int main(int argc, char* argv[]) { char *ptr = (char*)malloc(sizeof(char)*30); strcpy(ptr," Hel lo wo rl d G eo rocks!!! by shahil sucks b i g tim e"); int i = 0, j = 0; while(ptr[j]!= { if(ptr[j] == { j++; ptr[i] = ptr[j]; } else { i++; j++; ptr[i] = ptr[j]; } } printf("\noutput-%s\n",ptr); return 0; }
int _tmain(int argc, _TCHAR* argv[]) { FILE * fp; char currDBSStatstr[100] = {"/0"}; char *beg; char *end; char *str1; char str[] = "Initializing DBS Configuration"; fp = fopen("file2-1.txt","r"); if (fp != NULL) { printf("File exists.\n"); fgets(currDBSStatstr, sizeof(currDBSStatstr), fp); } else { printf("Error.\n"); exit(2); } printf("String: %s\n", currDBSStatstr); str1 = strtok(currDBSStatstr, ":-"); printf("%s\n", str1); while(1) { str1 = strtok(NULL, ":-"); if (str1 == NULL) { printf("Tokenizing Done.\n"); exit(0); } printf("%s\n", str1); end = str1 + strlen(str1) - 1; while((end > str1) && (*end == { end--; *(end+1) = 0; beg = str1; while(isspace(*str1)) str1++; } printf("%s\n", str1); if (strcmp(str, str1) == 0) printf("Strings are equal.\n"); } return 0;
void trimString(char *string) { size_t i = 0, j = strlen(string); while (j > 0 && isspace((unsigned char)string[j - 1])) string[--j] = while (isspace((unsigned char)string[i])) i++; if (i > 0) memmove(string, string + i, j - i + 1); }
size_t trim(char *out, size_t n, const char *str) { if(n == 0) return 0; while(isspace(*str)) str++; if(*str == out[0] = return 0; } size_t i = 0; for(i = 0; i < n - 1 && *str != out[i] = *str++; } while(isspace(out[--i])); out[++i] = return i; }
void stripWS_LT(char *str) { char *a = str, *b = str; while (isspace((unsigned char)*a)) a++; while (*b = *a++) b++; while (b > str && isspace((unsigned char)*--b)) *b = 0; }
char* ltrim(char* s) { char* newstart = s; while (isspace( *newstart)) { ++newstart; } memmove( s, newstart, strlen( newstart) + 1); return s; } char* rtrim( char* s) { char* end = s + strlen( s); while ((end != s) && isspace( *(end-1))) { --end; } *end = return s; } char* trim( char* s) { return rtrim( ltrim( s)); }
static char const WHITESPACE[] = " \t\n\r"; static void get_trim_bounds(char const *s, char const **firstWord, char const **trailingSpace) { char const *lastWord; *firstWord = lastWord = s + strspn(s, WHITESPACE); do { *trailingSpace = lastWord + strcspn(lastWord, WHITESPACE); lastWord = *trailingSpace + strspn(*trailingSpace, WHITESPACE); } while (*lastWord != } char *copy_trim(char const *s) { char const *firstWord, *trailingSpace; char *result; size_t newLength; get_trim_bounds(s, &firstWord, &trailingSpace); newLength = trailingSpace - firstWord; result = malloc(newLength + 1); memcpy(result, firstWord, newLength); result[newLength] = return result; } void inplace_trim(char *s) { char const *firstWord, *trailingSpace; size_t newLength; get_trim_bounds(s, &firstWord, &trailingSpace); newLength = trailingSpace - firstWord; memmove(s, firstWord, newLength); s[newLength] = }
static const char *WhiteSpace=" \n\r\t"; char* trim(char *t) { char *e=t+(t!=NULL?strlen(t):0); if (t==NULL) return; do --e; while (strchr(WhiteSpace, *e) && e>=t); *(++e)=0; e=t+strspn (t,WhiteSpace); return e>t?memmove(t,e,strlen(e)+1):t; }
void rstrip(char *string) { int l; if (!string) return; l = strlen(string) - 1; while (isspace(string[l]) && l >= 0) string[l--] = 0; } void lstrip(char *string) { int i, l; if (!string) return; l = strlen(string); while (isspace(string[(i = 0)])) while(i++ < l) string[i-1] = string[i]; } void strip(char *string) { lstrip(string); rstrip(string); }
char *trimAll(char *strData) { unsigned int L = strlen(strData); if(L > 0){ L--; }else{ return strData; } size_t S = 0, E = L; while((!(strData[S] > { if(strData[S] <= if(strData[E] <= } if(S == 0 && E == L){ return strData; } if((S >= 0) && (S <= L) && (E >= 0) && (E <= L)){ L = E - S + 1; memmove(strData,&strData[S],L); strData[L] = }else{ strData[0] = return strData; }
void inplace_trim(char* s) { int start, end = strlen(s); for (start = 0; isspace(s[start]); ++start) {} if (s[start]) { while (end > 0 && isspace(s[end-1])) --end; memmove(s, &s[start], end - start); } s[end - start] = } char* copy_trim(const char* s) { int start, end; for (start = 0; isspace(s[start]); ++start) {} for (end = strlen(s); end > 0 && isspace(s[end-1]); --end) {} return strndup(s + start, end - start); }
char *trimStr(char *str){ char *tmp = str; printf("input string %s\n",str); int nc = 0; while(*tmp!= if (*tmp != nc++; } tmp++; } printf("total nonempty characters are %d\n",nc); char *trim = NULL; trim = malloc(sizeof(char)*(nc+1)); if (trim == NULL) return NULL; tmp = str; int ne = 0; while(*tmp!= if (*tmp != trim[ne] = *tmp; ne++; } tmp++; } trim[nc] = printf("trimmed string is %s\n",trim); return trim; } int main(void){ char str[] = " s ta ck ove r fl o w "; char *trim = trimStr(str); if (trim != NULL )free(trim); return 0; }
void trim_str(char *s) { const size_t s_len = strlen(s); int i; for (i = 0; i < s_len; i++) { if (!isspace( (unsigned char) s[i] )) break; } if (i == s_len) { s[0] = } else { const char *non_space_beginning = s + i; char *non_space_ending = s + s_len - 1; while ( isspace( (unsigned char) *non_space_ending ) ) non_space_ending--; size_t trimmed_s_len = non_space_ending - non_space_beginning + 1; if (s != non_space_beginning) { memmove(s, non_space_beginning, trimmed_s_len); } s[trimmed_s_len] = } }
char* strtrim(char* const str) { if (str != nullptr) { char const* begin{ str }; while (std::isspace(*begin)) { ++begin; } auto end{ begin }; auto scout{ begin }; while (*scout != { if (!std::isspace(*scout++)) { end = scout; } } auto const length{ end - begin }; if (begin != str) { std::memmove(str, begin, length); } str[length] = } return str; }
warning: incompatible implicit declaration of built-in function ‘strcpy’ warning: incompatible implicit declaration of built-in function ‘strlen’ warning: incompatible implicit declaration of built-in function ‘exit’
CFLAGS = -fno-builtin-exit -fno-builtin-strcat -fno-builtin-strncat -fno-builtin-strcpy -fno-builtin-strlen -fno-builtin-calloc
el@defiant ~/foo2 $ gcc -o n n2.c n2.c: In function ‘main’: n2.c:2:3: warning: incompatible implicit declaration of built-in function ‘exit’ [enabled by default] el@defiant ~/foo2 $ ./n el@defiant ~/foo2 $
switch( value ) { case 1: return 1; default: value++; case 2: return value * 2; }
switch (expr) { int i = 4; f(i); case 0: i=17; default: printf("%d\n", i); }
switch(5) { case 1: echo "1"; break; case 2: default: echo "2, default"; break; case 3; echo "3"; break; } Outputs
switch(poll(fds, 1, 1000000)){ default: break; case 0: break; case -1: }
send(to, from, count) register short *to, *from; register count; { register n=(count+7)/8; switch(count%8){ case 0: do{ *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; }while(--n>0); } }
switch (style) { default: MSPUB_DEBUG_MSG(("Couldn case SOLID: return Dash(0, RECT_DOT); case DASH_SYS: { Dash ret(shapeLineWidth, dotStyle); ret.m_dots.push_back(Dot(1, 3 * shapeLineWidth)); return ret; } }
switch(textureMode) { case ModeTiled: default: break; case ModeStretched: break; }
printf("0=%d\n", test(0)); printf("1=%d\n", test(1)); printf("2=%d\n", test(2)); printf("3=%d\n", test(3)); printf("4=%d\n", test(4));
Example from UCS-2 to UTF-8 conversion r is the destination array, wc is the input wchar_t switch(utf8_length) { case 3: r[2] = 0x80 | (wc & 0x3f); wc >>= 6; wc |= 0x800; case 2: r[1] = 0x80 | (wc & 0x3f); wc >>= 6; wc |= 0x0c0; case 1: r[0] = wc; }
if( utf8_length >= 1 ) { r[0] = wc; if( utf8_length >= 2 ) { r[1] = 0x80 | (wc & 0x3f); wc >>= 6; wc |= 0x0c0; if( utf8_length == 3 ) { r[2] = 0x80 | (wc & 0x3f); wc >>= 6; wc |= 0x800; } } }
for(i=0; s[i]; i++) { switch(s[i]) { case case case d[dlen++] = default: d[dlen++] = s[i]; } }
bool isComment(char charInQuestion) { bool charIsComment = false; switch(charInQuestion) { case case case charIsComment = true; default: charIsComment = false; } return charIsComment; } for(i=0; s[i]; i++) { if( isComment(s[i]) ) { d[dlen++] = } d[dlen++] = s[i]; }
void foo() { int c[100]; int *p; { int d[200]; p = d; } return; }
void foo(int[]); void bar(void); void foobar(int); void foobar(int flag) { if (flag) { int big[100000000]; foo(big); } bar(); }
_foobar: pushl %ebp movl %esp, %ebp movl $400000008, %eax call __alloca cmpl $0, 8(%ebp) je L2 leal -400000000(%ebp), %eax movl %eax, (%esp) call _foo L2: call _bar leave ret
char var = getch(); { char next_var = var + 1; use_variable(next_char); }
int main() { int* x; int* y; { int a; x = &a; printf("%p\n", (void*) x); } { int b; y = &b; printf("%p\n", (void*) y); } }
int main() { int* x; int* y; { int a; x = &a; } { int b; y = &b; } printf("%p\n", (void*) x); printf("%p\n", (void*) y); }
unsigned int v; v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++;
unsigned long upper_power_of_two(unsigned long v) { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }
/** * return the smallest power of two value * greater than x * * Input range: [2..2147483648] * Output range: [2..2147483648] * */ __attribute__ ((const)) static inline uint32_t p2(uint32_t x) { assert(x > 1); assert(x <= ((UINT32_MAX/2) + 1)); return 1 << (32 - __builtin_clz (x - 1)); }
unsigned power_floor(unsigned x) { int power = 1; while (x >>= 1) power <<= 1; return power; } unsigned power_ceil(unsigned x) { if (x <= 1) return 1; int power = 2; x--; while (x >>= 1) power <<= 1; return power; }
template <typename UnsignedType> UnsignedType round_up_to_power_of_2(UnsignedType v) { static_assert(std::is_unsigned<UnsignedType>::value, "Only works for unsigned types"); v--; for (size_t i = 1; i < sizeof(v) * CHAR_BIT; i *= 2) { v |= v >> i; } return ++v; }
int next_power_of_two(float a_F){ int f = *(int*)&a_F; int b = f << 9 != 0; f >>= 23; f -= 127; return (1 << (f + b)); }
double next_power_of_two(double value) { int exp; if(frexp(value, &exp) == 0.5) { return value; } return ldexp(1.0, exp); }
/* ** http: */ static inline uint64_t next_power_of_2(uint64_t i) { return 1UL <<(1 +(63 -__builtin_clzl(i -1))); i =i -1; i =LOG2_UINT64(i); return 1UL <<(1 +i); }
popcnt edx,eax lzcnt ecx,eax cmp edx,1 jle @done mov eax,2 shl eax,cl @done: rep ret
inline unsigned int ExpandToPowerOf2(unsigned int Value) { unsigned long Index; _BitScanReverse(&Index, Value - 1); return (1U << (Index + 1)); } inline unsigned long long ExpandToPowerOf2(unsigned long long Value) { unsigned long Index; _BitScanReverse64(&Index, Value - 1); return (1ULL << (Index + 1)); }
dec eax bsr rcx, rax inc ecx mov eax, 1 shl rax, cl
inline unsigned int ExpandToPowerOf2(unsigned int Value) { unsigned long Index; _BitScanReverse(&Index, --Value); if (Value == 0) Index = (unsigned long) -1; return (1U << (Index + 1)); }
using namespace std; uint32_t arrTble[FLOG2(63)]; int main(){ int8_t n; DBG_PRINT(SZ4); DBG_PRINT(SZ6); DBG_PRINT(SZ7); DBG_PRINT(SZ8); DBG_PRINT(SZ9); DBG_PRINT(SZ16); DBG_PRINT(SZ17); DBG_PRINT(SZ127); DBG_PRINT(SZ1023); DBG_PRINT(SZ1024); DBG_PRINT(SZ2_17); return(0); }
Line:39 SZ4 = 2 Line:40 SZ6 = 3 Line:41 SZ7 = 3 Line:42 SZ8 = 3 Line:43 SZ9 = 4 Line:44 SZ16 = 4 Line:45 SZ17 = 5 Line:46 SZ127 = 7 Line:47 SZ1023 = 10 Line:48 SZ1024 = 10 Line:49 SZ2_16 = 17
int nearest_upper_power(int number){ int temp=number; while((number&(number-1))!=0){ temp<<=1; number&=temp; } number*=2; return number; }
__attribute__ ((const)) static inline uint32_t p2(uint32_t x) { assert(x > 0); assert(x <= ((UINT32_MAX/2) + 1)); int clz; uint32_t xm1 = x-1; asm( "lzcnt %1,%0" :"=r" (clz) :"rm" (xm1) :"cc" ); return 1 << (32 - clz); }
int next_power_of_two(int n) { int i = 0; for (--n; n > 0; n >>= 1) { i++; } return 1 << i; }
/* Compute the nearest power of 2 number that is * less than or equal to the value passed in. */ static GLuint nearestPower( GLuint value ) { int i = 1; if (value == 0) return -1; for (;;) { if (value == 1) return i; else if (value == 3) return i*4; value >>= 1; i *= 2; } }
char * myMessage; printf(myMessage); puts(myMessage); printf("%s\n",myMessage);
push rbp mov rbp,rsp mov edi,str.Helloworld! call dword imp.puts mov eax,0x0 pop rbp ret
static const char my_text[] = "Using fwrite.\n"; fwrite(my_text, 1, sizeof(my_text) - sizeof(
ERRNO(3) Linux Programmer’s Manual ERRNO(3) NAME errno - number of last error SYNOPSIS DESCRIPTION ... errno is defined by the ISO C standard to be a modifiable lvalue of type int, and must not be explicitly declared; errno may be a macro. errno is thread-local; setting it in one thread does not affect its value in any other thread.
$ cat > test.c f() { g(errno); } $ cc -E test.c | grep ^f f() { g((*__errno_location ())); } $
extern int *__errno_location (void) __THROW __attribute__ ((__const__));
> cat essai.c int main(void) { errno = 0; return 0; } > gcc -c -Wall -Wextra -pedantic essai.c > objdump -d -M intel essai.o essai.o: file format elf32-i386 Disassembly of section .text: 00000000 <main>: 0: 55 push ebp 1: 89 e5 mov ebp,esp 3: 83 e4 f0 and esp,0xfffffff0 6: e8 fc ff ff ff call 7 <main+0x7> ; get address of errno in EAX b: c7 00 00 00 00 00 mov DWORD PTR [eax],0x0 ; store 0 in errno 11: b8 00 00 00 00 mov eax,0x0 16: 89 ec mov esp,ebp 18: 5d pop ebp 19: c3 ret
__BEGIN_DECLS extern int * __error(void); __END_DECLS
void sig_alarm(int signo) { int errno_save; errno_save = errno; errno = errno_save; }
We can check by running a simple program on a machine. void *thread_function(void *); int main() { pthread_t thread_id[NTHREADS]; int i, j; for(i=0; i < NTHREADS; i++) { pthread_create( &thread_id[i], NULL, thread_function, NULL ); } for(j=0; j < NTHREADS; j++) { pthread_join( thread_id[j], NULL); } return 0; } void *thread_function(void *dummyPtr) { printf("Thread number %ld addr(errno):%p\n", pthread_self(), &errno); } Running this program and you can see different addresses for errno in each thread. The output of a run on my machine looked like:- Thread number 140672336922368 addr(errno):0x7ff0d4ac0698 Thread number 140672345315072 addr(errno):0x7ff0d52c1698 Thread number 140672328529664 addr(errno):0x7ff0d42bf698 Thread number 140672320136960 addr(errno):0x7ff0d3abe698 Thread number 140672311744256 addr(errno):0x7ff0d32bd698 Notice that address is different for all threads.
int main(void) { void *b = sbrk(0); int *p = (int *)b; *p = 1; return 0; }
int main(void) { void *b = sbrk(0); int *p = (int *)b; brk(p + 2); *p = 1; *(p + 1) = 2; assert(*p == 1); assert(*(p + 1) == 2); brk(b); return 0; }
int main(void) { void *b; char *p, *end; b = sbrk(0); p = (char *)b; end = p + 0x1000000; brk(end); while (p < end) { *(p++) = 1; } brk(b); return 0; }
+------+ <-- Heap Start + 2 * sizof(int) == Heap End | | | You can now write your ints | in this memory area. | | +------+ <-- Heap Start
void *memorypool; void initmemorypool(void){ memorypool = sbrk(0); } void resetmemorypool(void){ brk(memorypool); }
_1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \ _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \ _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \ _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \ _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \ _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \ _61,_62,_63,N,...) N 63,62,61,60, \ 59,58,57,56,55,54,53,52,51,50, \ 49,48,47,46,45,44,43,42,41,40, \ 39,38,37,36,35,34,33,32,31,30, \ 29,28,27,26,25,24,23,22,21,20, \ 19,18,17,16,15,14,13,12,11,10, \ 9,8,7,6,5,4,3,2,1,0
int FOO4(int a, int b, int c, int d) { return a + b + c + d; }
using namespace std; int main() { ff (counter, 3, 5) cout << "counter = " << counter << endl; ff (abc, 4) cout << "abc = " << abc << endl; ii (3) cout << "i = " << i << endl; ii (100, 103) cout << "i = " << i << endl; return 0; }
User@Table 13:06:16 /c/T $ g++ test_overloaded_macros.cpp User@Table 13:16:26 /c/T $ ./a.exe counter = 3 counter = 4 abc = 0 abc = 1 abc = 2 abc = 3 i = 0 i = 1 i = 2 i = 100 i = 101 i = 102
// // // // // _HAS_ZERO_OR_ONE_ARGS( \ \ HAS_COMMA(__VA_ARGS__), \ \ HAS_COMMA(_TRIGGER_PARENTHESIS_ __VA_ARGS__), \ \ HAS_COMMA(__VA_ARGS__ (~)), \ \ HAS_COMMA(_TRIGGER_PARENTHESIS_ __VA_ARGS__ (~)) \ ) _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \ _11,_12,_13,_14,_15,_16,N,...) N _VA16(__VA_ARGS__),_VA15(__VA_ARGS__),_VA14(__VA_ARGS__),_VA13(__VA_ARGS__), \ _VA12(__VA_ARGS__),_VA11(__VA_ARGS__),_VA10(__VA_ARGS__), _VA9(__VA_ARGS__), \ _VA8(__VA_ARGS__),_VA7(__VA_ARGS__),_VA6(__VA_ARGS__),_VA5(__VA_ARGS__), \ _VA4(__VA_ARGS__),_VA3(__VA_ARGS__),_VA2(__VA_ARGS__),_VA1(__VA_ARGS__), \ _VA0(__VA_ARGS__)
int main() { char input[40]; char check[40]; int i=0; printf("Hello!\nPlease enter a word or character:\n"); gets(input); printf("I will now repeat this until you type it back to me.\n"); while (check != input) { printf("%s\n", input); gets(check); } printf("Good bye!"); return 0; }
int checker(char input[],char check[]); int main() { char input[40]; char check[40]; int i=0; printf("Hello!\nPlease enter a word or character:\n"); scanf("%s",input); printf("I will now repeat this until you type it back to me.\n"); scanf("%s",check); while (!checker(input,check)) { printf("%s\n", input); scanf("%s",check); } printf("Good bye!"); return 0; } int checker(char input[],char check[]) { int i,result=1; for(i=0; input[i]!= if(input[i] != check[i]) { result=0; break; } } return result; }
int main() { char s[]="STACKOVERFLOW"; char s1[200]; printf("Enter the string to be checked\n"); scanf("%s",s1); if(strcmp(s,s1)==0) { printf("Both the Strings match\n"); } else { printf("Entered String does not match\n"); } system("pause"); }
int strcmp(char input[], char check[]) { for (int i = 0;; i++) { if (input[i] == { break; } else if (input[i] == { return 1; } else if (input[i] != { return -1; } else if (input[i] > check[i]) { return 1; } else if (input[i] < check[i]) { return -1; } else { } } return 0; }
int main() { char s1[50],s2[50]; printf("Enter the character of strings: "); gets(s1); printf("\nEnter different character of string to repeat: \n"); while(strcmp(s1,s2)) { printf("%s\n",s1); gets(s2); } return 0; }
int main() { char input[MAXLEN]; char check[MAXLEN]; int i=0; printf("Hello!\nPlease enter a word or character:\n"); gets(input); printf("I will now repeat this until you type it back to me.\n"); while (strcmp(check, input)) { printf("%s\n", input); gets(check); } printf("Good bye!"); return 0; }
int main() { char input[MAXLEN]; char check[MAXLEN]; int i=0; printf("Hello!\nPlease enter a word or character:\n"); gets(input); int len = strlen(input); for (; i < 10000; ++i) input [len - 2 + i] = printf("I will now repeat this until you type it back to me.\n"); while (strncmp(check, input, MAXLEN)) { printf("%s\n", input); gets(check); } printf("Good bye!"); return 0; }
char input[40]; char check[40]; strcpy(input, "Hello"); strcpy(check, "Hello"); while (check != input) while (strcmp(check, input) != 0) while (strcmp(check, input))
$ cat mf.c int main() { int a[10]; a[10]=1; } $ gcc -fmudflap mf.c -lmudflap $ ./a.out ******* mudflap violation 1 (check/write): time=1280862302.170759 ptr=0x7fff96eb3d00 size=44 pc=0x7f3a575503c1 location=`mf.c:4:2 (main)' /usr/lib/libmudflap.so.0(__mf_check+0x41) [0x7f3a575503c1] ./a.out(main+0x90) [0x400a54] /lib/libc.so.6(__libc_start_main+0xfd) [0x7f3a571e2c4d] Nearby object 1: checked region begins 0B into and ends 4B after mudflap object 0xf9c560: name=`mf.c:3:6 (main) a' bounds=[0x7fff96eb3d00,0x7fff96eb3d27] size=40 area=stack check=0r/3w liveness=3 alloc time=1280862302.170749 pc=0x7f3a57550cb1 number of nearby objects: 1
CFLAGS= -Wall -Wextra -Weffc++ -Os -ggdb ... g++ $(CFLAGS) -o junk $< gcc $(CFLAGS) -o $@ $< rm -f junk
CPPFLAGS += -MD -MP SRC = $(wildcard *.cpp) my_executable: $(SRC:%.cpp=%.o) g++ $(LDFLAGS) -o $@ $^ -include $(SRC:%.cpp=%.d)
-s Remove all symbol table and relocation information from the executable.
x = 5 % (-3); y = (-5) % (3); z = (-5) % (-3); printf("%d ,%d ,%d", x, y, z);
int remainder(int a, int b) { return a - (a / b) * b; }
int mod(int a, int b) { int r = a % b; return r < 0 ? r + b : r; }
7 % 3 --> 1 7 % -3 --> 1 -7 % 3 --> -1 -7 % -3 --> -1
int modulo_Euclidean(int a, int b) { int m = a % b; if (m < 0) { m = (b < 0) ? m - b : m + b; } return m; } modulo_Euclidean( 7, 3) --> 1 modulo_Euclidean( 7, -3) --> 1 modulo_Euclidean(-7, 3) --> 2 modulo_Euclidean(-7, -3) --> 2
(-3 / 2) * 2 + -3 % 2 = -3 (-3 / 2) * 2 = -2 (-3 % 2) must be -1
(3 / -2) * -2 + 3 % -2 = 3 (3 / -2) * -2 = 2 (3 % -2) must be 1
(-3 / -2) * -2 + -3 % -2 = -3 (-3 / -2) * -2 = -2 (-3 % -2) must be -1
unsigned long long memory_to_eat = 1024 * 50000; size_t eaten_memory = 0; void *memory = NULL; int eat_kilobyte() { memory = realloc(memory, (eaten_memory * 1024) + 1024); if (memory == NULL) { return 1; } else { eaten_memory++; return 0; } } int main(int argc, char **argv) { printf("I will try to eat %i kb of ram\n", memory_to_eat); int megabyte = 0; while (memory_to_eat > 0) { memory_to_eat--; if (eat_kilobyte()) { printf("Failed to allocate more memory! Stucked at %i kb :(\n", eaten_memory); return 200; } if (megabyte++ >= 1024) { printf("Eaten 1 MB of ram\n"); megabyte = 0; } } printf("Successfully eaten requested memory!\n"); free(memory); return 0; }
int eat_kilobyte() { if (memory == NULL) memory = malloc(1024); else memory = realloc(memory, (eaten_memory * 1024) + 1024); if (memory == NULL) { return 1; } else { ((char*)memory)[1024*eaten_memory] = 42; eaten_memory++; return 0; } }
size_t memory_to_eat = 1024 * 50000; size_t eaten_memory = 0; char *memory = NULL; void write_kilobyte(char *pointer, size_t offset) { int size = 0; while (size < 1024) { pointer[offset + (size_t) size++] = 1; } } int eat_kilobyte() { if (memory == NULL) { memory = malloc(1024); } else { memory = realloc(memory, (eaten_memory * 1024) + 1024); } if (memory == NULL) { return 1; } else { write_kilobyte(memory, eaten_memory * 1024); eaten_memory++; return 0; } } int main(int argc, char **argv) { if (argc >= 2) memory_to_eat = atoll(argv[1]); printf("I will try to eat %zi kb of ram\n", memory_to_eat); int megabyte = 0; int megabytes = 0; while (memory_to_eat-- > 0) { if (eat_kilobyte()) { printf("Failed to allocate more memory at %zi kb :(\n", eaten_memory); return 200; } if (megabyte++ >= 1024) { megabytes++; printf("Eaten %i MB of ram\n", megabytes); megabyte = 0; } } printf("Successfully eaten requested memory!\n"); free(memory); return 0; }
void main(int j) { printf("%d\n", j); (&main + (&exit - &main)*(j/1000))(j+1); }
int func(char* str) { char buffer[100]; unsigned short len = strlen(str); if(len >= 100) { return (-1); } strncpy(buffer,str,strlen(str)); return 0; }
char buffer[100]; size_t len = strlen(str); if (len >= sizeof(buffer) / sizeof(buffer[0])) return -1; memcpy(buffer, str, len + 1);
strncpy(buffer,str, sizeof(buff) - 1); buffer[sizeof(buff) - 1] =
int func (char *str) { char buffer[100]; unsigned short size = sizeof(buffer); unsigned short len = strlen(str); if (len > size - 1) return(-1); memcpy(buffer, str, len + 1); buffer[size - 1] = return(0); }
The strlen() function returns the number of characters that precede the terminating NUL character. The strnlen() function returns either the same result as strlen() or maxlen, whichever is smaller.
int func(char *str) { char buffer[100]; unsigned short len = strnlen(str, 100); if (len >= 100) { return -1; } strcpy(buffer, str); return 0; }
char *strdupe(char const *src) { size_t len = strlen(src); char *dest = malloc(len+1); if (!dest) return (OUT_OF_MEMORY(),(char*)0); memcpy(dest, src, len); dest[len]=0; return dest; }
void examine_data(const char *ptr, size_t len) { ... } char *p = ...; size_t l = ...; examine_data(p, l);
char *get_data(size_t *len); { ... *len = ...datalen...; return ...data...; } size_t len; char *p = get_data(&len);
void examine_data(const struct blob data) { ... use data.tr and data.len ... } struct blob = { .ptr = ..., .len = ... }; examine_data(blob); struct blob get_data(void); { ... return (struct blob){ .ptr = ...data..., .len = ...len... }; } struct blob data = get_data();
typedef struct { double x, y; } point; void give_two_doubles(double * x, double * y) { *x = 1.0; *y = 2.0; } point give_point() { point a = {1.0, 2.0}; return a; } int main() { return 0; }
0000000000400480 <give_two_doubles>: 400480: 48 ba 00 00 00 00 00 mov $0x3ff0000000000000,%rdx 400487: 00 f0 3f 40048a: 48 b8 00 00 00 00 00 mov $0x4000000000000000,%rax 400491: 00 00 40 400494: 48 89 17 mov %rdx,(%rdi) 400497: 48 89 06 mov %rax,(%rsi) 40049a: c3 retq 40049b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 00000000004004a0 <give_point>: 4004a0: 66 0f 28 05 28 01 00 movapd 0x128(%rip),%xmm0 4004a7: 00 4004a8: 66 0f 29 44 24 e8 movapd %xmm0,-0x18(%rsp) 4004ae: f2 0f 10 05 12 01 00 movsd 0x112(%rip),%xmm0 4004b5: 00 4004b6: f2 0f 10 4c 24 f0 movsd -0x10(%rsp),%xmm1 4004bc: c3 retq 4004bd: 0f 1f 00 nopl (%rax)
void examine_data(const char *c, size_t l) { c[0] = } void examine_data(const struct blob blob) { blob.ptr[0] = }
struct person { int no; int age; }; struct person create() { struct person jingguo = { .no = 1, .age = 2}; return jingguo; } int main(int argc, const char *argv[]) { struct person result; result = create(); return 0; }
.file "foo.c" .text .globl create .type create, @function create: pushl %ebp movl %esp, %ebp subl $16, %esp movl 8(%ebp), %ecx movl $1, -8(%ebp) movl $2, -4(%ebp) movl -8(%ebp), %eax movl -4(%ebp), %edx movl %eax, (%ecx) movl %edx, 4(%ecx) movl %ecx, %eax leave ret $4 .size create, .-create .globl main .type main, @function main: pushl %ebp movl %esp, %ebp subl $20, %esp leal -8(%ebp), %eax movl %eax, (%esp) call create subl $4, %esp movl $0, %eax leave ret .size main, .-main .ident "GCC: (Ubuntu 4.4.3-4ubuntu5) 4.4.3" .section .note.GNU-stack,"",@progbits
+---------------------------+ ebp | saved ebp | +---------------------------+ ebp-4 | age part of struct person | +---------------------------+ ebp-8 | no part of struct person | +---------------------------+ ebp-12 | | +---------------------------+ ebp-16 | | +---------------------------+ ebp-20 | ebp-8 (address) | +---------------------------+
+---------------------------+ | ebp-8 (address) | +---------------------------+ | return address | +---------------------------+ ebp,esp | saved ebp | +---------------------------+
int main(void) { int y = foo(3); printf("%d\n", y); return 0; }
short socketConnect(char *host,unsigned short port,char *sendbuf,char *recievebuf, long rbufsize);
short socketConnect(char *host,unsigned short port,char *sendbuf,char *recievebuf, long rbufsize) { short ret = -1; return ret; }
int** someNumbers = malloc(arrayRows*sizeof(int*)); for (i = 0; i < arrayRows; i++) { someNumbers[i] = malloc(arrayColumns*sizeof(int)); }
warning: passing argument 1 of ‘function1’ from incompatible pointer type
| sometype_t | sometype_t | sometype_t | sometype_t |
unsigned char MultiArray[5][2]={{0,1},{2,3},{4,5},{6,7},{8,9}};
unsigned char SingleArray[10]={0,1,2,3,4,5,6,7,8,9};
int a[2][2] ={{0,1},{2,3}}; void f1(int *ptr); void f1(int *ptr) { int a=0; int b=0; a=ptr[0]; b=ptr[1]; printf("%d\n",a); printf("%d\n",b); } int main() { f1(a[0]); f1(a[1]); return 0; }
$_memeq(buf1, buf2, length)` $_streq(str1, str2) $_strlen(str) $_regex(str, regex)
$ gdb -n -quiet -batch -ex --with-python=/usr (relocatable)
struct { enum { is_int, is_float, is_char } type; union { int ival; float fval; char cval; } val; } my_array[10];
my_array[0].type = is_int; my_array[0].val.ival = 3;
switch (my_array[n].type) { case is_int: break; case is_float: break; case is_char: break; default: }
union { int ival; float fval; void *pval; } array[10];
typedef enum __VarType { V_INT, V_CHAR, V_FLOAT, } VarType; typedef struct __Var { VarType type; union { int i; char c; float f; }; } Var; void var_init_int(Var *v, int i) { v->type = V_INT; v->i = i; } void var_init_char(Var *v, char c) { v->type = V_CHAR; v->c = c; } void var_init_float(Var *v, float f) { v->type = V_FLOAT; v->f = f; } int main(int argc, char **argv) { Var v[SIZE]; int i; var_init_int(&v[0], 10); var_init_char(&v[1], var_init_float(&v[2], 3.14); for( i = 0 ; i < SIZE ; i++ ) { switch( v[i].type ) { case V_INT : printf("INT %d\n", v[i].i); break; case V_CHAR : printf("CHAR %c\n", v[i].c); break; case V_FLOAT: printf("FLOAT %f\n", v[i].f); break; } } return 0; }
typedef struct { int tag; int val; } integer; typedef struct { int tag; float val; } real;
typedef union { int tag; integer int_; real real_; } record; enum types { INVALID, INT, REAL };
record i; i.tag = INT; i.int_.val = 12; record r; r.tag = REAL; r.real_.val = 57.0;
if (r.tag == INT) { integer x = r; x.val = 36; } else if (r.tag == REAL) { real x = r; x.val = 25.0; } integer g = { INT, 100 }; record rg = g;
record problem = { .tag = INT, .int_.val = 3 }; problem.tag;
record not_a_problem = { .int_.tag = INT, .int_.val = 3 }; not_a_problem.tag;
void* tp; enum { is_int, is_double, is_char_p, is_char } type; intptr_t addr = (intptr_t)tp & ~0x03; switch ((intptr_t)tp & 0x03) { case is_int: printf("%d\n", *((int*)addr)); break; case is_double: printf("%f\n", *((double*)addr)); break; case is_char_p: printf("%s\n", (char*)addr); break; case is_char: printf("%c\n", *((char*)addr)); break; }
WIN32 _WIN32 __WIN32 __WIN32__ __MINGW32__ WINNT __WINNT __WINNT__ _X86_ i386 __i386
/** * Determination a platform of an operation system * Fully supported supported only GNU GCC/G++, partially on Clang/LLVM */ char * get_platform_name() { return (PLATFORM_NAME == NULL) ? "" : PLATFORM_NAME; } int main(int argc, char *argv[]) { puts(get_platform_name()); return 0; }
int main() { printf("%s\n", operating_system()); return 0; }
int num = 321; char snum[5]; itoa(num, snum, 10); printf("%s\n", snum);
int x = -42; int length = snprintf( NULL, 0, "%d", x ); char* str = malloc( length + 1 ); snprintf( str, length + 1, "%d", x ); ... free(str);
char * itoa (int value, char *result, int base) { if (base < 2 || base > 36) { *result = char* ptr = result, *ptr1 = result, tmp_char; int tmp_value; do { tmp_value = value; value /= base; *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)]; } while ( value ); if (tmp_value < 0) *ptr++ = *ptr-- = while (ptr1 < ptr) { tmp_char = *ptr; *ptr--= *ptr1; *ptr1++ = tmp_char; } return result; }
int main(int argc, char *argv[]) { char *string = atoa(1234567890); printf("%s\n", string); return 0; }
char* str; asprintf (&str, "%i", 12313); free(str);
char *int_to_string_alloc(int x) { int i = x; char buf[INT_DECIMAL_STRING_SIZE(int)]; char *p = &buf[sizeof buf - 1]; *p = if (i >= 0) { i = -i; } do { p--; *p = (char) ( i /= 10; } while (i); if (x < 0) { p--; *p = } size_t len = (size_t) (&buf[sizeof buf] - p); char *s = malloc(len); if (s) { memcpy(s, p, len); } return s; }
static char *int_to_string_helper(char *dest, size_t n, int x) { if (n == 0) { return NULL; } if (x <= -10) { dest = int_to_string_helper(dest, n - 1, x / 10); if (dest == NULL) return NULL; } *dest = (char) ( return dest + 1; } char *int_to_string(char *dest, size_t n, int x) { char *p = dest; if (n == 0) { return NULL; } n--; if (x < 0) { if (n == 0) return NULL; n--; *p++ = } else { x = -x; } p = int_to_string_helper(p, n, x); if (p == NULL) return NULL; *p = 0; return dest; }
static char *itoa_simple_helper(char *dest, int i) { if (i <= -10) { dest = itoa_simple_helper(dest, i/10); } *dest++ = return dest; } char *itoa_simple(char *dest, int i) { char *s = dest; if (i < 0) { *s++ = } else { i = -i; } *itoa_simple_helper(s, i) = return dest; } int main() { char s[100]; puts(itoa_simple(s, 0)); puts(itoa_simple(s, 1)); puts(itoa_simple(s, -1)); puts(itoa_simple(s, 12345)); puts(itoa_simple(s, INT_MAX-1)); puts(itoa_simple(s, INT_MAX)); puts(itoa_simple(s, INT_MIN+1)); puts(itoa_simple(s, INT_MIN)); }
0 1 -1 12345 2147483646 2147483647 -2147483647 -2147483648
/*Function return size of string and convert signed * *integer to ascii value and store them in array of * *character with NULL at the end of the array */ int itoa(int value,char *ptr) { int count=0,temp; if(ptr==NULL) return 0; if(value==0) { *ptr= return 1; } if(value<0) { value*=(-1); *ptr++= count++; } for(temp=value;temp>0;temp/=10,ptr++); *ptr= for(temp=value;temp>0;temp/=10) { *--ptr=temp%10+ count++; } return count; }
int main() { char *s = "abc"; printf("%s\n", s); return 0; }
char *s = "abc"; 8: 48 c7 45 f8 00 00 00 movq $0x0,-0x8(%rbp) f: 00 c: R_X86_64_32S .rodata
Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000704 0x0000000000000704 R E 200000 Section to Segment mapping: Segment Sections... 02 .text .rodata
17: c7 45 f0 61 62 63 00 movl $0x636261,-0x10(%rbp)
>dumpbin vec1.exe Microsoft (R) COFF/PE Dumper Version 8.00.50727.762 Copyright (C) Microsoft Corporation. All rights reserved. Dump of file vec1.exe File Type: EXECUTABLE IMAGE Summary 4000 .data 5000 .rdata <-- here are strings and other read-only stuff. 14000 .text
char *tabHeader = "Sound"; *tabHeader = printf("%s\n",tabHeader);
Contents of section .rdata: 0000 77686174 65766572 00000000 whatever....
regex_t regex; int reti; char msgbuf[100]; reti = regcomp(&regex, "^a[[:alnum:]]", 0); if (reti) { fprintf(stderr, "Could not compile regex\n"); exit(1); } reti = regexec(&regex, "abc", 0, NULL, 0); if (!reti) { puts("Match"); } else if (reti == REG_NOMATCH) { puts("No match"); } else { regerror(reti, &regex, msgbuf, sizeof(msgbuf)); fprintf(stderr, "Regex match failed: %s\n", msgbuf); exit(1); } /* Free memory allocated to the pattern buffer by regcomp() */ regfree(&regex);
void print_regerror (int errcode, size_t length, regex_t *compiled); int main (int argc, char *argv[]) { regex_t regex; int result; if (argc < 3) { fputs ("Missing command line arguments\n", stderr); return EXIT_FAILURE; } result = regcomp (&regex, argv[1], REG_EXTENDED); if (result) { if (result == REG_ESPACE) fprintf (stderr, "%s\n", strerror(ENOMEM)); else fputs ("Syntax error in the regular expression passed as first argument\n", stderr); return EXIT_FAILURE; } for (int i = 2; i < argc; i++) { result = regexec (&regex, argv[i], 0, NULL, 0); if (!result) { printf (" } else if (result == REG_NOMATCH) { printf (" } else { size_t length = regerror (result, &regex, NULL, 0); print_regerror (result, length, &regex); return EXIT_FAILURE; } } /* Free the memory allocated from regcomp(). */ regfree (&regex); return EXIT_SUCCESS; } void print_regerror (int errcode, size_t length, regex_t *compiled) { char buffer[length]; (void) regerror (errcode, compiled, buffer, length); fprintf(stderr, "Regex match failed: %s\n", buffer); }
int main(){ bool Debug = true; bool Found = false; pcre2_code *re; PCRE2_SPTR pattern; PCRE2_SPTR subject; int errornumber; int i; int rc; PCRE2_SIZE erroroffset; PCRE2_SIZE *ovector; size_t subject_length; pcre2_match_data *match_data; char * RegexStr = "(?:\\D|^)(5[1-5][0-9]{2}(?:\\ |\\-|)[0-9]{4}(?:\\ |\\-|)[0-9]{4}(?:\\ |\\-|)[0-9]{4})(?:\\D|$)"; char * source = "5111 2222 3333 4444"; pattern = (PCRE2_SPTR)RegexStr; subject = (PCRE2_SPTR)source; subject_length = strlen((char *)subject); re = pcre2_compile( pattern, PCRE2_ZERO_TERMINATED, 0, &errornumber, &erroroffset, NULL); if (re == NULL) { PCRE2_UCHAR buffer[256]; pcre2_get_error_message(errornumber, buffer, sizeof(buffer)); printf("PCRE2 compilation failed at offset %d: %s\n", (int)erroroffset,buffer); return 1; } match_data = pcre2_match_data_create_from_pattern(re, NULL); rc = pcre2_match( re, subject, subject_length, 0, 0, match_data, NULL); if (rc < 0) { switch(rc) { case PCRE2_ERROR_NOMATCH: pcre2_match_data_free(match_data); pcre2_code_free(re); Found = 0; return Found; default: printf("Matching error %d\n", rc); } pcre2_match_data_free(match_data); pcre2_code_free(re); Found = 0; return Found; } if (Debug){ ovector = pcre2_get_ovector_pointer(match_data); printf("Match succeeded at offset %d\n", (int)ovector[0]); if (rc == 0) printf("ovector was not big enough for all the captured substrings\n"); if (ovector[0] > ovector[1]) { printf("\\K was used in an assertion to set the match start after its end.\n" "From end to start the match was: %.*s\n", (int)(ovector[0] - ovector[1]), (char *)(subject + ovector[1])); printf("Run abandoned\n"); pcre2_match_data_free(match_data); pcre2_code_free(re); return 0; } for (i = 0; i < rc; i++) { PCRE2_SPTR substring_start = subject + ovector[2*i]; size_t substring_length = ovector[2*i+1] - ovector[2*i]; printf("%2d: %.*s\n", i, (int)substring_length, (char *)substring_start); } } else{ if(rc > 0){ Found = true; } } pcre2_match_data_free(match_data); pcre2_code_free(re); return Found; }
regex_t regex; int reti; char msgbuf[100]; int main(int argc, char const *argv[]) { while(1){ fgets( msgbuf, 100, stdin ); reti = regcomp(&regex, "^(-)?([0-9]+)((,|.)([0-9]+))?\n$", REG_EXTENDED); if (reti) { fprintf(stderr, "Could not compile regex\n"); exit(1); } printf("%s\n", msgbuf); reti = regexec(&regex, msgbuf, 0, NULL, 0); if (!reti) { puts("Match"); } else if (reti == REG_NOMATCH) { puts("No match"); } else { regerror(reti, &regex, msgbuf, sizeof(msgbuf)); fprintf(stderr, "Regex match failed: %s\n", msgbuf); exit(1); } /* Free memory allocated to the pattern buffer by regcomp() */ regfree(&regex); } }
void foo(int arg) { if (unlikely(arg == 0)) { do_this(); return; } do_that(); ... }
int j = (printf("Assigning variable j\n"), getValueFromSomewhere());
struct cat { unsigned int legs:3; unsigned int lives:4; }; cat make_cat() { cat kitty; kitty.legs = 4; kitty.lives = 9; return kitty; }
FSM { STATE(x) { ... NEXTSTATE(y); } STATE(y) { ... if (x == 0) NEXTSTATE(y); else NEXTSTATE(x); } }
strncpy(to, from, count) char *to, *from; int count; { int n = (count + 7) / 8; switch (count % 8) { case 0: do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n > 0); } }
myStructType_t myStuff[] = { [FOO] = { foo1, foo2, foo3 }, [BAR] = { bar1, bar2, bar3 }, ...
struct foo{ int x; int y; char* name; }; void main(){ struct foo f = { .y = 23, .name = "awesome", .x = -38 }; }
setsockopt(yourSocket, SOL_SOCKET, SO_REUSEADDR, (int[]){1}, sizeof(int));
void myFunction(type* values) { while(*values) x=*values++; } myFunction((type[]){val1,val2,val3,val4,0});
int my_printf (void *my_object, const char *my_format, ...) __attribute__ ((format (printf, 2, 3)));
int main() { int a = 3; float b = 6.412355; printf("%.*f\n",a,b); return 0; }
typedef struct { \ char static_assertion[condition ? 1 : -1]; \ } static_assertion_t STATIC_ASSERT(sizeof(mystruct_t) <= 4096);
char buffer[256]; snprintf(buffer, 256, "%s/file", PATH); fd = open(buffer, flags);
int x[] = { 1, 2, 3, }; enum foo { bar, baz, boom, };
Point point_new(int x, int y) { Point p; p.x = x; p.y = y; return p; }
sscanf ( string, "%d%n", &number, &length ); string += length;
int main() { 1 || puts("Hello\n"); 0 || puts("Hi\n"); 1 && puts("ROFL\n"); 0 && puts("LOL\n"); exit( 0 ); }
enum CompileTimeCheck { MAKE_SURE_DD_IS_TWICE_D = 1/(2*(D) == (DD)), MAKE_SURE_DD_IS_POW2 = 1/((((DD) - 1) & (DD)) == 0) };
struct { int a:3; int b:2; int :0; int c:4; int d:3; };
ERR(errCantOpen, "File %s cannot be opened", filename);
void foo(uint32_t extraPadding) { uint8_t commBuffer[sizeof(myProtocol_t) + extraPadding];
<ApplicationDelegate:applicationDidFinishLaunching:10>Hello world
print(__FUNCTION__) NSLog(@"%@", NSStringFromSelector(_cmd));
NSLog(@"<%@:%@:%d>", NSStringFromClass([self class]), NSStringFromSelector(_cmd), __LINE__);
NSLog( @"ERROR %@ METHOD %s:%d ", @"DescriptionGoesHere", __func__, __LINE__ );
NSLog(@"%s:%d someObject=%@", __func__, __LINE__, someObject);
NSLog( @"ERROR %@ METHOD %s:%d ", @"DescriptionGoesHere", __func__, __LINE__ );
NSLog( @"TRACE %@ METHOD %s:%d ", @"DescriptionGoesHere", __func__, __LINE__ );
NSLog( @"TRACE %@ METHOD %s:%d.", [NSString stringWithFormat:@"
NSLog(@"%@", NSStringFromSelector(_cmd)); print(__FUNCTION__)
int testlib() { printf("Hello world\n"); return (0); }
int main (int argc, char *argv[]) { testlib(); return (0); }
char str1[7] = "aabbcc"; int main( void ) { printf( "The string: %s\n", str1 ); memcpy( str1 + 2, str1, 4 ); printf( "New string: %s\n", str1 ); strcpy_s( str1, sizeof(str1), "aabbcc" ); printf( "The string: %s\n", str1 ); memmove( str1 + 2, str1, 4 ); printf( "New string: %s\n", str1 ); }
The string: aabbcc New string: aaaabb The string: aabbcc New string: aaaabb
char a[16]; char b[16]; memcpy(a,b,16); memmove(a,b,16); memcpy(&a[0], &a[1],10); memmove(&a[0], &a[1],10);
char str1[17] = "abcdef"; int main() { printf( "The string: %s\n", str1 ); memcpy( (str1+6), str1, 10 ); printf( "New string: %s\n", str1 ); strcpy_s( str1, sizeof(str1), "aabbcc" ); printf( "The string: %s\n", str1 ); memmove( (str1+6), str1, 10 ); printf( "New string: %s\n", str1 ); }
The string: abcdef New string: abcdefabcdefabcd The string: abcdef New string: abcdefabcdef
memcpy(str1 + 2, str1, 4); 00241013 mov eax,dword ptr [str1 (243018h)] printf("New string: %s\n", str1); 00241018 push offset str1 (243018h) 0024101D push offset string "New string: %s\n" (242104h) 00241022 mov dword ptr [str1+2 (24301Ah)],eax 00241027 call esi
char str1[9] = "aabbccdd"; int main( void ) { printf("The string: %s\n", str1); memcpy(str1 + 2, str1, 6); printf("New string: %s\n", str1); strcpy_s(str1, sizeof(str1), "aabbccdd"); printf("The string: %s\n", str1); memmove(str1 + 2, str1, 6); printf("New string: %s\n", str1); }
The string: aabbccdd New string: aaaabbbb The string: aabbccdd New string: aaaabbcc
memcpy(str1 + 2, str1, 6); 00341013 mov eax,dword ptr [str1 (343018h)] 00341018 mov dword ptr [str1+2 (34301Ah)],eax 0034101D mov cx,word ptr [str1+4 (34301Ch)] printf("New string: %s\n", str1); 00341024 push offset str1 (343018h) 00341029 push offset string "New string: %s\n" (342104h) 0034102E mov word ptr [str1+6 (34301Eh)],cx 00341035 call esi
int main(){ char a[]="hare rama hare rama"; char b[]="hare rama hare rama"; memmove(a+5,a,20); puts(a); memcpy(b+5,b,20); puts(b); }
hare hare rama hare rama hare hare hare hare hare hare rama hare rama
char str1[11] = "abcdefghij"; void *memcpyCustom(void *dest, const void *src, size_t n) { char *dp = (char *)dest; const char *sp = (char *)src; while (n--) *dp++ = *sp++; return dest; } void *memmoveCustom(void *dest, const void *src, size_t n) { unsigned char *pd = (unsigned char *)dest; const unsigned char *ps = (unsigned char *)src; if ( ps < pd ) for (pd += n, ps += n; n--;) *--pd = *--ps; else while(n--) *pd++ = *ps++; return dest; } int main( void ) { printf( "The string: %s\n", str1 ); memcpy( str1 + 1, str1, 9 ); printf( "Actual memcpy output: %s\n", str1 ); strcpy_s( str1, sizeof(str1), "abcdefghij" ); memcpyCustom( str1 + 1, str1, 9 ); printf( "Implemented memcpy output: %s\n", str1 ); strcpy_s( str1, sizeof(str1), "abcdefghij" ); memmoveCustom( str1 + 1, str1, 9 ); printf( "Implemented memmove output: %s\n", str1 ); getchar(); }
The string: abcdefghij Actual memcpy output: aabcdefghi Implemented memcpy output: aaaaaaaaaa Implemented memmove output: aabcdefghi
int main() { char *str1 = "string Literal"; const char *str2 = "string Literal"; char source[] = "Sample string"; strcpy(str1,source); strcpy(str2,source); return 0; }
char mystring[101] = "My sample string"; const char * constcharp = mystring; char const * charconstp = mystring; char * const charpconst = mystring; constcharp++; charconstp++; charpconst++; constcharp[3] = charconstp[3] = charpconst[3] = char * lcharp = "My string literal"; const char * lconstcharp = "My string literal"; lcharp[0] = lconstcharp[0] = const char astr[101] = "My mutable string"; astr[0] = ((char*)astr)[0] =
std::cout << typeid(2.3).name() << std::cout << typeid(typeid(2.3).name()).name() << const char* charptr charptr = typeid(2.3).name(); std::cout << charptr[3];
char* charptr2="hubble"; strcpy(charptr, charptr2);
void *p = malloc(sizeof(char)*10); p++; char * c = (char *)p; c++;
int main() { int arr[2] = {1, 2}; void *ptr = &arr; ptr = ptr + sizeof(int); printf("%d\n", *(int *)ptr); return 0; }
({ \ return_type anon_func_name_ function_body \ anon_func_name_; \ })
int (*max)(int, int) = lambda (int, (int x, int y) { return x > y ? x : y; });
/* * with constraints desribed above we could have * good approximation of FP style in plain C */ int increment_int(int x) { return x + 1; } WRAP_PLAIN_FUNCTION_TO_FIRST_CLASS(increment, increment_int); map(increment, list(number(0), number(1)); function_t* computation = compose( increment, increment, increment ); *(int*) call(computation, number(1)) == 4;
struct list_t { void* head; struct list_t* tail; }; struct function_t { void* (*thunk)(list_t*); struct list_t* arguments; } void* apply(struct function_t* fn, struct list_t* arguments) { return fn->thunk(concat(fn->arguments, arguments)); } void* increment_thunk(struct list_t* arguments) { int x_arg = *(int*) arguments->head; int value = increment_int(x_arg); int* number = malloc(sizeof *number); return number ? (*number = value, number) : NULL; } struct function_t* increment = &(struct function_t) { increment_thunk, NULL }; /* call(increment, number(1)) expands to */ apply(increment, &(struct list_t) { number(1), NULL });
short needle long needle short haystack ? ? long haystack ? ?
unsigned char *findFirstByte32(unsigned char *ptr, unsigned char byte) { uint32_t *ptr32 = (uint32_t *)ptr, firstByte32 = 0u, byteMask32 = (byte) | (byte << 8); byteMask32 |= byteMask32 << 16; while((firstByte32 = findFirstZeroByte32((*ptr32) ^ byteMask32)) == 0) { ptr32++; } return(ptr + ((((unsigned char *)ptr32) - ptr) + firstByte32 - 1)); }
unsigned char *findFirstByte64(unsigned char *ptr, unsigned char byte) { uint64_t *ptr64 = (uint64_t *)ptr, firstByte64 = 0u, byteMask64 = (byte) | (byte << 8); byteMask64 |= byteMask64 << 16; byteMask64 |= byteMask64 << 32; while((firstByte64 = findFirstZeroByte64((*ptr64) ^ byteMask64)) == 0) { ptr64++; } return(ptr + ((((unsigned char *)ptr64) - ptr) + firstByte64 - 1)); }
struct monkey { float age; bool is_male; int happiness; }; void monkey_dance(struct monkey *monkey) { }
struct base { }; struct derived { struct base super; }; struct derived d; struct base *base_ptr = (struct base *)&d; struct derived *derived_ptr = (struct derived *)base_ptr;
struct base; struct base_vtable { void (*dance)(struct base *); void (*jump)(struct base *, int how_high); }; struct base { struct base_vtable *vtable; }; void base_dance(struct base *b) { b->vtable->dance(b); } void base_jump(struct base *b, int how_high) { b->vtable->jump(b, how_high); } struct derived1 { struct base super; }; void derived1_dance(struct derived1 *d) { } void derived1_jump(struct derived1 *d, int how_high) { } struct base_vtable derived1_vtable = { &derived1_dance, &derived1_jump }; void derived1_init(struct derived1 *d) { d->super.vtable = &derived1_vtable; } struct derived2 { struct base super; }; void derived2_dance(struct derived2 *d) { } void derived2_jump(struct derived2 *d, int how_high) { } struct base_vtable derived2_vtable = { &derived2_dance, &derived2_jump }; void derived2_init(struct derived2 *d) { d->super.vtable = &derived2_vtable; } int main(void) { struct derived1 d1; derived1_init(&d1); struct derived2 d2; derived2_init(&d2); struct base *b1_ptr = (struct base *)&d1; struct base *b2_ptr = (struct base *)&d2; base_dance(b1_ptr); base_dance(b2_ptr); base_jump(b1_ptr, 42); base_jump(b2_ptr, 42); return 0; }
struct van { struct vehicle base; int cubic_size; }
struct van my_van; struct vehicle *something = &my_van; vehicle_function( something );
static void dtb_xlt(void *dst, const void *src, vint len, const byte *tbl); DTABUF *dtb_crt(vint minsiz,vint incsiz,vint maxsiz) { DTABUF *dbp; if(!minsiz) { return NULL; } if(!incsiz) { incsiz=minsiz; } if(!maxsiz || maxsiz<minsiz) { maxsiz=minsiz; } if(minsiz+incsiz>maxsiz) { incsiz=maxsiz-minsiz; } if((dbp=(DTABUF*)malloc(sizeof(*dbp))) == NULL) { return NULL; } memset(dbp,0,sizeof(*dbp)); dbp->min=minsiz; dbp->inc=incsiz; dbp->max=maxsiz; dbp->siz=minsiz; dbp->cur=0; if((dbp->dta=(byte*)malloc((vuns)minsiz)) == NULL) { free(dbp); return NULL; } return dbp; } DTABUF *dtb_dlt(DTABUF *dbp) { if(dbp) { free(dbp->dta); free(dbp); } return NULL; } vint dtb_adddta(DTABUF *dbp,const byte *xlt256,const void *dtaptr,vint dtalen) { if(!dbp) { errno=EINVAL; return -1; } if(dtalen==-1) { dtalen=(vint)strlen((byte*)dtaptr); } if((dbp->cur + dtalen) > dbp->siz) { void *newdta; vint newsiz; if((dbp->siz+dbp->inc)>=(dbp->cur+dtalen)) { newsiz=dbp->siz+dbp->inc; } else { newsiz=dbp->cur+dtalen; } if(newsiz>dbp->max) { errno=ETRUNC; return -1; } if((newdta=realloc(dbp->dta,(vuns)newsiz))==NULL) { return -1; } dbp->dta=newdta; dbp->siz=newsiz; } if(dtalen) { if(xlt256) { dtb_xlt(((byte*)dbp->dta+dbp->cur),dtaptr,dtalen,xlt256); } else { memcpy(((byte*)dbp->dta+dbp->cur),dtaptr,(vuns)dtalen); } dbp->cur+=dtalen; } return 0; } static void dtb_xlt(void *dst,const void *src,vint len,const byte *tbl) { byte *sp,*dp; for(sp=(byte*)src,dp=(byte*)dst; len; len--,sp++,dp++) { *dp=tbl[*sp]; } } vint dtb_addtxt(DTABUF *dbp,const byte *xlt256,const byte *format,...) { byte textÝ501¨; va_list ap; vint len; va_start(ap,format); len=sprintf_len(format,ap)-1; va_end(ap); if(len<0 || len>=sizeof(text)) { sprintf_safe(text,sizeof(text),"STRTOOLNG: %s",format); len=(int)strlen(text); } else { va_start(ap,format); vsprintf(text,format,ap); va_end(ap); } return dtb_adddta(dbp,xlt256,text,len); } vint dtb_rmvdta(DTABUF *dbp,vint len) { if(!dbp) { errno=EINVAL; return -1; } if(len > dbp->cur) { len=dbp->cur; } dbp->cur-=len; return 0; } vint dtb_reset(DTABUF *dbp) { if(!dbp) { errno=EINVAL; return -1; } dbp->cur=0; if(dbp->siz > dbp->min) { byte *newdta; if((newdta=(byte*)realloc(dbp->dta,(vuns)dbp->min))==NULL) { free(dbp->dta); dbp->dta=null; dbp->siz=0; return -1; } dbp->dta=newdta; dbp->siz=dbp->min; } return 0; } void *dtb_elmptr(DTABUF *dbp,vint elmidx,vint elmlen) { if(!elmlen || (elmidx*elmlen)>=dbp->cur) { return NULL; } return ((byte*)dbp->dta+(elmidx*elmlen)); }
typedef _Packed struct { vint min; vint inc; vint max; vint siz; vint cur; void *dta; } DTABUF; DTABUF *dtb_crt(vint minsiz,vint incsiz,vint maxsiz); DTABUF *dtb_dlt(DTABUF *dbp); vint dtb_adddta(DTABUF *dbp,const byte *xlt256,const void *dtaptr,vint dtalen); vint dtb_addtxt(DTABUF *dbp,const byte *xlt256,const byte *format,...); vint dtb_rmvdta(DTABUF *dbp,vint len); vint dtb_reset(DTABUF *dbp); void *dtb_elmptr(DTABUF *dbp,vint elmidx,vint elmlen);
typedef void *Class; typedef struct __class_Foo { Class isa; int ivar; } Foo; typedef struct __meta_Foo { Foo *(*alloc)(void); Foo *(*init)(Foo *self); int (*ivar)(Foo *self); void (*setIvar)(Foo *self); } meta_Foo; meta_Foo *class_Foo; void __meta_Foo_init(void) __attribute__((constructor)); void __meta_Foo_init(void) { class_Foo = malloc(sizeof(meta_Foo)); if (class_Foo) { class_Foo = {__imp_Foo_alloc, __imp_Foo_init, __imp_Foo_ivar, __imp_Foo_setIvar}; } } Foo *__imp_Foo_alloc(void) { Foo *foo = malloc(sizeof(Foo)); if (foo) { memset(foo, 0, sizeof(Foo)); foo->isa = class_Foo; } return foo; } Foo *__imp_Foo_init(Foo *self) { if (self) { self->ivar = 42; } return self; }
int main(void) { Foo *foo = (class_Foo->init)((class_Foo->alloc)()); printf("%d\n", (foo->isa->ivar)(foo)); foo->isa->setIvar(foo, 60); printf("%d\n", (foo->isa->ivar)(foo)); free(foo); }
@interface Foo : NSObject { int ivar; } - (int)ivar; - (void)setIvar:(int)ivar; @end @implementation Foo - (id)init { if (self = [super init]) { ivar = 42; } return self; } @end int main(void) { Foo *foo = [[Foo alloc] init]; printf("%d\n", [foo ivar]); [foo setIvar:60]; printf("%d\n", [foo ivar]); [foo release]; }
struct _monkey; typedef struct _monkey monkey; monkey * monkey_new(); int monkey_delete(monkey *thisobj); void monkey_dance(monkey *thisobj);
GHastTable* my_hash = g_hash_table_new(g_str_hash, g_str_equal); int size = g_hash_table_size(my_hash); ... g_hash_table_remove(my_hash, some_key);
int main() { Triangle tr1= CTriangle->new(); Rectangle rc1= CRectangle->new(); tr1->width= rc1->width= 3.2; tr1->height= rc1->height= 4.1; CPolygon->printArea((Polygon)tr1); printf("\n"); CPolygon->printArea((Polygon)rc1); }
/* * OOP in C * * gcc -o oop oop.c */ struct obj2d { float x; float y; float (* area)(void *); }; void * _new_obj2d(int size, void * areafn) { struct obj2d * x = calloc(1, size); x->area = areafn; return x; } struct rectangle { struct obj2d b1; float width; float height; float rotation; }; float rectangle_area(struct rectangle * self) { return self->width * self->height; } struct triangle { struct obj2d b1; }; struct circle { struct obj2d b1; float radius; }; float circle_area(struct circle * self) { return M_PI * self->radius * self->radius; } int main(int ac, char * av[]) { struct rectangle * obj1 = NEW(rectangle); struct circle * obj2 = NEW(circle); X(obj1) = 1; Y(obj1) = 1; WIDTH(obj1) = 2; obj1->height = 3; printf("obj1 position (%f,%f) area %f\n", X(obj1), Y(obj1), AREA(obj1)); X(obj2) = 10; Y(obj2) = 10; RADIUS(obj2) = 1.5; printf("obj2 position (%f,%f) area %f\n", X(obj2), Y(obj2), AREA(obj2)); }
CLASS (People) { int age; }; int main() { People *p = NEW (People); p->age = 10; printf("%d\n", p->age); }
if (0) { } else if (some_fn_call()) { } else if (some_other_fn_call()) { ... } else { }
if (0) { } else if (test1()) { action1(); } else if (test2()) { action2(); }
void defer(void *fun, void *arg); if(0) f(arg); \ else defer(f, (void *)arg); void myfunction(int *p); DEFER(myfunction, 42); int *b; DEFER(myfunction, b);
if (feature_a_active()) { use_feature_a(); } else if (some_fn()) { ...
Actually according to my opinion, if we put any variable for checking inside e.g:- public static void main(string args[]) { var status; var empList=_unitofWork.EmpRepository.Get(con=>con.isRetired==true); if(empList.count>0) { status=true; } if(status) { } else { } } if then its dynamically get the value in run time and invoke the logic inside it, else its simply extra line of code i guess. Anybody have any depth knowledge why this thing is used....or agree with me. kindly respond.
if(0) { } else if( cond1 ) { } else if( cond2 ) { ... } else { }
(cond (test1 action1) (test2 action2) ... (testn actionn))
(cond (test1 action1) (test2 action2) ... (testn actionn) )
IF :: cond1 THEN code1 :: cond2 THEN code2 ... :: condN THEN codeN FI
IF 0 THEN **FORC i FROM 1 TO 10 DOC** ELSE IF signal%i% THEN **ENDC** ELSE ENDIF
IF 0 THEN ELSE IF signal1 THEN ELSE IF signal2 THEN ... ELSE IF signal100 THEN ELSE ENDIF
IF 0 THEN ELSE IF signal1 THEN found := 1 ELSE IF signal2 THEN found := 2 ... ELSE IF signal100 THEN found := 100 ELSE ENDIF
using namespace std; int main() { int i = 5, j = 6, k = 7; int *ip1 = &i, *ip2 = &j; int** ipp = &ip1; printf("address of value i: %p\n", &i); printf("address of value j: %p\n", &j); printf("value ip1: %p\n", ip1); printf("value ip2: %p\n", ip2); printf("value ipp: %p\n", ipp); printf("address value of ipp: %p\n", *ipp); printf("value of address value of ipp: %d\n", **ipp); *ipp = ip2; printf("value ipp: %p\n", ipp); printf("address value of ipp: %p\n", *ipp); printf("value of address value of ipp: %d\n", **ipp); }
Address Data Meaning 0x12345678 00 00 00 05 0x1234567C 00 00 00 06
Address Data Meaning 0x12345680 12 34 56 78 0x12345684 12 34 56 7C
Address Data Meaning 0x12345680 12 34 56 7C 0x12345684 12 34 56 7C
name: i j ip1 ip2 ipp addr: 0 1 2 3 4 mem : [ | | | | ]
name: i j ip1 ip2 addr: 0 1 2 3 mem : [ 5| 6| 0| 1]
name: i j ip1 ip2 ipp addr: 0 1 2 3 4 mem : [ 5| 6| 0| 1| 2]
name: i j ip1 ip2 ipp addr: 0 1 2 3 4 mem : [ 5| 6| 1| 1| 2]
int : ( i , &i , 5 ); ( j , &j , 6); ( k , &k , 5 ) int* : (ip1, &ip1, &i); (ip1, &ip1, &j) int** : (ipp, &ipp, &ip1)
printf("0x%" PRIXPTR "\n", (uintptr_t)your_pointer);
void some_func () { int *nPtr; nPtr = malloc (100); free (nPtr); nPtr = NULL; return; }
void myfree(void **ptr) { free(*ptr); *ptr = null; }
void safe_free(void** ptr) { free(*ptr); *ptr = NULL; }
void other_func() { int *p; if (p) { *p = 1; } } void caller() { some_func(); other_func(); }
*ptr = 20; free(ptr); int *q = (int *)malloc(sizeof(int) * 2); *ptr = 30;
int i = 7; printf("% printf("0x%08x\n", i); printf("%
int main(void) { int j = 0; printf("0x%.8X = % for (int i = 0; i < 8; i++) { j = (j << 4) | (i + 6); printf("0x%.8X = % } return(0); }
0x00000000 = 00000000 = 00000000 = 0000000000 0x00000006 = 0X000006 = 0X00000006 = 0x00000006 0x00000067 = 0X000067 = 0X00000067 = 0x00000067 0x00000678 = 0X000678 = 0X00000678 = 0x00000678 0x00006789 = 0X006789 = 0X00006789 = 0x00006789 0x0006789A = 0X06789A = 0X0006789A = 0x0006789a 0x006789AB = 0X6789AB = 0X006789AB = 0x006789ab 0x06789ABC = 0X6789ABC = 0X06789ABC = 0x06789abc 0x6789ABCD = 0X6789ABCD = 0X6789ABCD = 0x6789abcd
int foo = 1; int *bar = &foo; printf("%p\n", (void *)&foo); printf("%i\n", *bar);
bar foo +-----+ +-----+ |0x100| ---> | 1 | +-----+ +-----+ 0x200 0x100
• Pointer can hold address but not value • Pointer contains the address of an existing variable. • Pointer points to an existing variable
int main() { int foo = 1; int *bar = &foo; printf("%i\n", foo); printf("%p\n", &foo); printf("%p\n", (void *)&foo); printf("%p\n", &bar); printf("%p\n", bar); printf("%i\n", *bar); return 0; }
int foo = 1; int* bar = &foo; printf("%p\n", &foo); printf("%p\n", bar); printf("%i\n", foo); printf("%i\n", *bar);
int main(int argc, char **argv, char **env) { char str[] = "This is Pointer examples!"; char *pstr0 = str; char *pstr1 = &str[0]; unsigned int straddr = (unsigned int)pstr0; printf("Pointer examples: pstr0 = %08x\n", pstr0); printf("Pointer examples: &str[0] = %08x\n", &str[0]); printf("Pointer examples: str = %08x\n", str); printf("Pointer examples: straddr = %08x\n", straddr); printf("Pointer examples: str[0] = %c\n", str[0]); return 0; }
~/work/test_c_code$ ./testptr Pointer examples: pstr0 = 2a6b7ed0 Pointer examples: &str[0] = 2a6b7ed0 Pointer examples: str = 2a6b7ed0 Pointer examples: straddr = 2a6b7ed0 Pointer examples: str[0] = T
int *ip, i = 10; float *fp, f = 12.2; ip = &i; fp = &f;
int main (int argc, char **argv) { char a = char b = char * const pc1 = &a; const char * pc2 = &a; printf ("Before\n"); printf ("pc1=%p\n", pc1); printf ("*pc1=%c\n", *pc1); printf ("pc2=%p\n", pc2); printf ("*pc2=%c\n", *pc2); *pc1 = b; /* *pc2 = b; */ pc2 = &b; printf ("\n\n"); printf ("After\n"); printf ("pc1=%p\n", pc1); printf ("*pc1=%c\n", *pc1); printf ("pc2=%p\n", pc2); printf ("*pc2=%c\n", *pc2); return EXIT_SUCCESS; }
Before pc1=ffbfd7e7 *pc1=x pc2=ffbfd7e7 *pc2=x After pc1=ffbfd7e7 *pc1=y pc2=ffbfd7e6 *pc2=x
char * const pc1 = &a; const char * pc2 = &a; *pc1 = *pc2 = pc1 = &b; pc2 = &b;
void Foo( int * ptr, int const * ptrToConst, int * const constPtr, int const * const constPtrToConst ) { *ptr = 0; ptr = 0; *ptrToConst = 0; ptrToConst = 0; *constPtr = 0; constPtr = 0; *constPtrToConst = 0; constPtrToConst = 0; }
char * const a; => a is (const) constant (*) pointer of type char {L <- R}. =>( Constant Pointer ) const char * a; => a is (*) pointer to char constant {L <- R}. =>( Pointer to Constant)
char b= char * const a =&b; printf("\n print a : [%c]\n",*a); *a = printf("\n now print a : [%c]\n",*a);
const char *a; char b = const char * a =&b; char c; a=&c; *a =
int main() { char cwd[PATH_MAX]; if (getcwd(cwd, sizeof(cwd)) != NULL) { printf("Current working dir: %s\n", cwd); } else { perror("getcwd() error"); return 1; } return 0; }
DWORD WINAPI GetCurrentDirectory( _In_ DWORD nBufferLength, _Out_ LPTSTR lpBuffer );
int main(){ char buff[FILENAME_MAX]; GetCurrentDir( buff, FILENAME_MAX ); printf("Current working dir: %s\n", buff); return 1; }
int main(void) { struct foo { char c; int x; } __attribute__((packed)); struct foo arr[2] = { { int *p0 = &arr[0].x; int *p1 = &arr[1].x; printf("sizeof(struct foo) = %d\n", (int)sizeof(struct foo)); printf("offsetof(struct foo, c) = %d\n", (int)offsetof(struct foo, c)); printf("offsetof(struct foo, x) = %d\n", (int)offsetof(struct foo, x)); printf("arr[0].x = %d\n", arr[0].x); printf("arr[1].x = %d\n", arr[1].x); printf("p0 = %p\n", (void*)p0); printf("p1 = %p\n", (void*)p1); printf("*p0 = %d\n", *p0); printf("*p1 = %d\n", *p1); return 0; }
sizeof(struct foo) = 5 offsetof(struct foo, c) = 0 offsetof(struct foo, x) = 1 arr[0].x = 10 arr[1].x = 20 p0 = 0xbffc104f p1 = 0xbffc1054 *p0 = 10 *p1 = 20
sizeof(struct foo) = 5 offsetof(struct foo, c) = 0 offsetof(struct foo, x) = 1 arr[0].x = 10 arr[1].x = 20 p0 = ffbff317 p1 = ffbff31c Bus error
c.c: In function ‘main’: c.c:10:15: warning: taking address of packed member of ‘struct foo’ may result in an unaligned pointer value [-Waddress-of-packed-member] 10 | int *p0 = &arr[0].x; | ^~~~~~~~~ c.c:11:15: warning: taking address of packed member of ‘struct foo’ may result in an unaligned pointer value [-Waddress-of-packed-member] 11 | int *p1 = &arr[1].x; | ^~~~~~~~~
struct __attribute__((__packed__)) my_struct { char c; int i; }; struct my_struct a = { struct my_struct *b = &a; int c = a.i; int d = b->i; int *e __attribute__((aligned(1))) = &a.i; int *f = &a.i;
0: message type (1 byte) 1: target address, MSB 2: target address, LSB 3: data (chars) ... F: checksum (1 byte)
typedef struct { uint8_t msgType; uint16_t targetAddr; uint8_t data[12]; uint8_t checksum; } __attribute__((packed)) myStruct;
-(NSString *) toString:(FormatType)formatType { return []; }
- (NSString*)formatTypeToString:(FormatType)formatType { NSString *result = nil; switch(formatType) { case JSON: result = @"JSON"; break; case XML: result = @"XML"; break; case Atom: result = @"Atom"; break; case RSS: result = @"RSS"; break; default: [NSException raise:NSGenericException format:@"Unexpected FormatType."]; } return result; }
typedef enum FormatType { JSON, XML, Atom, RSS } FormatType; extern NSString * const FormatType_toString[]; NSString * const FormatType_toString[] = { [JSON] = @"JSON", [XML] = @"XML", [Atom] = @"Atom", [RSS] = @"RSS" }; ... NSString *str = FormatType_toString[theEnumValue];
typedef enum { JSON, XML, Atom, RSS } FormatType; + (NSArray *)names { static NSMutableArray * _names = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ _names = [NSMutableArray arrayWithCapacity:4]; [_names insertObject:@"JSON" atIndex:JSON]; [_names insertObject:@"XML" atIndex:XML]; [_names insertObject:@"Atom" atIndex:Atom]; [_names insertObject:@"RSS" atIndex:RSS]; }); return _names; } + (NSString *)nameForType:(FormatType)type { return [[self names] objectAtIndex:type]; }
typedef NS_ENUM(NSUInteger, UserType) { UserTypeParent = 0, UserTypeStudent = 1, UserTypeTutor = 2, UserTypeUnknown = NSUIntegerMax }; @property (nonatomic) UserType type; + (NSDictionary *)typeDisplayNames { return @{@(UserTypeParent) : @"Parent", @(UserTypeStudent) : @"Student", @(UserTypeTutor) : @"Tutor", @(UserTypeUnknown) : @"Unknown"}; } - (NSString *)typeDisplayName { return [[self class] typeDisplayNames][@(self.type)]; }
typedef enum { JSON = 0, XML, Atom, RSS, FormatTypeCount, } FormatType; extern NSString *const FormatTypeName[FormatTypeCount]; NSString *const FormatTypeName[FormatTypeCount] = { [JSON] = @"JSON", [XML] = @"XML", [Atom] = @"Atom", [RSS] = @"RSS", }; NSLog(@"%@", FormatTypeName[XML]);
typedef enum { IngredientType_text = 0, IngredientType_audio = 1, IngredientType_video = 2, IngredientType_image = 3 } IngredientType;
+ (NSString*)typeStringForType:(IngredientType)_type { NSString *key = [NSString stringWithFormat:@"IngredientType_%i", _type]; return NSLocalizedString(key, nil); }
"IngredientType_0" = "Text"; "IngredientType_1" = "Audio"; "IngredientType_2" = "Video"; "IngredientType_3" = "Image";
NSString* ret; \ switch(value) { case evalue: \ ret = @ break; } \ return ret; NSString* _CvtCBCentralManagerStateToString(CBCentralManagerState value) { ENUM_START ENUM_CASE(CBCentralManagerStateUnknown) ENUM_CASE(CBCentralManagerStateResetting) ENUM_CASE(CBCentralManagerStateUnsupported) ENUM_CASE(CBCentralManagerStateUnauthorized) ENUM_CASE(CBCentralManagerStatePoweredOff) ENUM_CASE(CBCentralManagerStatePoweredOn) ENUM_END }
typedef enum { JPG, PNG, GIF, PVR } kImageType; -(NSString*) imageTypeEnumToString:(kImageType)enumVal { NSArray *imageTypeArray = [[NSArray alloc] initWithObjects:kImageTypeArray]; return [imageTypeArray objectAtIndex:enumVal]; }
typedef NS_ENUM(NSUInteger, MPIMyWonderfulType) { MPIMyWonderfulTypeOne = 1, MPIMyWonderfulTypeTwo = 2, MPIMyWonderfulTypeGreen = 3, MPIMyWonderfulTypeYellow = 4, MPIMyWonderfulTypePumpkin = 5 }; @interface MyWonderfulType : NSObject + (NSString *)displayNameForWonderfulType:(MPIMyWonderfulType)wonderfulType; + (NSString *)urlForWonderfulType:(MPIMyWonderfulType)wonderfulType; @end
@implementation MyWonderfulType + (NSDictionary *)myWonderfulTypeTitles { return @{ @(MPIMyWonderfulTypeOne) : @"One", @(MPIMyWonderfulTypeTwo) : @"Two", @(MPIMyWonderfulTypeGreen) : @"Green", @(MPIMyWonderfulTypeYellow) : @"Yellow", @(MPIMyWonderfulTypePumpkin) : @"Pumpkin" }; } + (NSDictionary *)myWonderfulTypeURLs { return @{ @(MPIMyWonderfulTypeOne) : @"http: @(MPIMyWonderfulTypeTwo) : @"http: @(MPIMyWonderfulTypeGreen) : @"http: @(MPIMyWonderfulTypeYellow) : @"http: @(MPIMyWonderfulTypePumpkin) : @"http: }; } + (NSString *)displayNameForWonderfulType:(MPIMyWonderfulType)wonderfulType { return [MPIMyWonderfulType myWonderfulTypeTitles][@(wonderfulType)]; } + (NSString *)urlForWonderfulType:(MPIMyWonderfulType)wonderfulType { return [MPIMyWonderfulType myWonderfulTypeURLs][@(wonderfulType)]; } @end
typedef enum BollettinoMavRavTypes { AMZCartServiceOperationCreate, AMZCartServiceOperationAdd, AMZCartServiceOperationGet, AMZCartServiceOperationModify } AMZCartServiceOperation;
NSString *operationCheck = AMZCartServiceOperationValue(operation);
typedef NS_ENUM(NSUInteger, UserType) { UserTypeParent = 0, UserTypeStudent = 1, UserTypeTutor = 2, UserTypeUnknown = NSUIntegerMax }; @property (nonatomic) UserType type; + (NSDictionary *)typeDisplayNames { return @{@(UserTypeParent) : VariableName(UserTypeParent), @(UserTypeStudent) : VariableName(UserTypeStudent), @(UserTypeTutor) : VariableName(UserTypeTutor), @(UserTypeUnknown) : VariableName(UserTypeUnknown)}; } - (NSString *)typeDisplayName { return [[self class] typeDisplayNames][@(self.type)]; }
typedef enum : int { ObservationTypePulse = 1, ObservationTypeRespRate = 2, ObservationTypeTemperature = 3, . . }
@(ObservationTypePulse) : @"ObservationTypePulse", @(ObservationTypeRespRate) : @"ObservationTypeRespRate", @(ObservationTypeTemperature) : @"ObservationTypeTemperature", . .
-(NSDictionary *)observationDictionary { static NSDictionary *observationDictionary; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ observationDictionary = [[NSDictionary alloc] initWithDictionary:@{ @(ObservationTypePulse) : @"ObservationTypePulse", @(ObservationTypeRespRate) : @"ObservationTypeRespRate", . . }]; }); return observationDictionary; }
- (NSString*)describeFormatType:(FormatType)formatType { switch(formatType) { case JSON: return @"JSON"; case XML: return @"XML"; case Atom: return @"Atom"; case RSS: return @"RSS"; } [NSException raise:NSInvalidArgumentException format:@"The given format type number, %ld, is not known.", formatType]; return nil; }
enum ZZObjectType { XXOBJECTTYPE_TABLE }; typedef NSUInteger TPObjectType; X(ZZObjectTypeZero, = 0, @"ZZObjectTypeZero") \ X(ZZObjectTypeOne, , @"ZZObjectTypeOne") \ X(ZZObjectTypeTwo, , @"ZZObjectTypeTwo") \ X(ZZObjectTypeThree, , @"ZZObjectTypeThree") + (NSString*)nameForObjectType:(ZZObjectType)objectType { NSDictionary *dict = @{XXOBJECTTYPE_TABLE}; return dict[objectType]; }
typedef NS_ENUM(NSInteger, AssetIdentifier) { Isabella, William, Olivia };
^(AssetIdentifier identifier) { \ switch (identifier) { \ case asset: \ default: \ return @ } \ }(asset)
typedef NS_ENUM(NSUInteger, FormatType) { FormatTypeJSON = 0, FormatTypeXML, FormatTypeAtom, FormatTypeRSS, FormatTypeCount }; NS_INLINE NSString *FormatTypeToString(FormatType t) { if (t >= FormatTypeCount) return nil; NSString *table[FormatTypeCount] = {FormatTypeMapping(FormatTypeJSON), FormatTypeMapping(FormatTypeXML), FormatTypeMapping(FormatTypeAtom), FormatTypeMapping(FormatTypeRSS)}; return table[t]; }
tbd(GENDER_MALE) \ tbd(GENDER_FEMALE) \ tbd(GENDER_INTERSEX) \ enum { FOR_EACH_GENDER(ONE_GENDER_ENUM) MAX_GENDER }; static const char *enumGENDER_TO_STRING[] = { FOR_EACH_GENDER(ONE_GENDER) }; static const char *enumGenderToString(unsigned int value) { if (value < MAX_GENDER) { return enumGENDER_TO_STRING[value]; } return NULL; } static void printAllGenders(void) { for (int ii = 0; ii < MAX_GENDER; ii++) { printf("%d) gender %s\n", ii, enumGENDER_TO_STRING[ii]); } } tbd(2, PERSON_FRED, "Fred", "Weasley", GENDER_MALE, 12) \ tbd(4, PERSON_GEORGE, "George", "Weasley", GENDER_MALE, 12) \ tbd(6, PERSON_HARRY, "Harry", "Potter", GENDER_MALE, 10) \ tbd(8, PERSON_HERMIONE, "Hermione", "Granger", GENDER_FEMALE, 10) \ enum { FOR_EACH_PERSON(ONE_PERSON_ENUM) }; typedef struct PersonInfoRec { int value; const char *ename; const char *first; const char *last; int gender; int age; } PersonInfo; { ename, static const PersonInfo personInfo[] = { FOR_EACH_PERSON(ONE_PERSON_INFO) { 0, NULL, NULL, NULL, 0, 0 } }; static void printAllPersons(void) { for (int ii = 0; ; ii++) { const PersonInfo *pPI = &personInfo[ii]; if (!pPI->ename) { break; } printf("%d) enum %-15s %8s %-8s %13s %2d\n", pPI->value, pPI->ename, pPI->first, pPI->last, enumGenderToString(pPI->gender), pPI->age); } }
enum(chain_done,=0)\ enum(chain_entry)\ enum(chain_bg)\ enum(chain_mt)\ enum(chain_alt)\ enum(chain_for_c)\ enum(chain_while)\ enum(chain_continue_for)\ enum(chain_continue_while)\ enum(chain_break_for)\ enum(chain_break_while)\ enum(chain_previous)\ enum(chain_if)\ enum(chain_else)\ interface_NSString_Enum_DefinitionAndConverters(Dispatch_chain_cmd)
implementation_NSString_Enum_Converters(Dispatch_chain_cmd)
NSString *NSStringFromEnumDispatch_chain_cmd(enum Dispatch_chain_cmd value);
enum Dispatch_chain_cmd enumDispatch_chain_cmdFromNSString(NSString *value);
interface_NSString_Enum_Converters(CAEdgeAntialiasingMask_SETTINGS_PARAMS)
enum(kCALayerLeftEdge)\ enum(kCALayerRightEdge)\ enum(kCALayerBottomEdge)\ enum(kCALayerTopEdge) implementation_NSString_Enum_Converters(CAEdgeAntialiasingMask_SETTINGS_PARAMS)
+(NSString *)secondApproach_convertEnumToString:(StudentProgressReport)status { char *str = calloc(sizeof(kgood)+1, sizeof(char)); int goodsASInteger = NSSwapInt((unsigned int)kgood); memcpy(str, (const void*)&goodsASInteger, sizeof(goodsASInteger)); NSLog(@"%s", str); NSString *enumString = [NSString stringWithUTF8String:str]; free(str); return enumString; } NSString *const kNitin = @"Nitin"; NSString *const kSara = @"Sara"; typedef NS_ENUM(NSUInteger, Name) { NameNitin, NameSara, }; + (NSString *)thirdApproach_convertEnumToString :(Name)weekday { __strong NSString **pointer = (NSString **)&kNitin; pointer +=weekday; return *pointer; }
string s; read_string(s); while(s.len() > 5) { read_string(s); }
for (low = 0, high = MAXSIZE; low < high; low = newlow, high = newhigh) { }
unsigned char outbuff[BUFFSIZE]; unsigned char *ptr = outbuff; *ptr++ = first_byte_value; *ptr++ = second_byte_value; send_buff(outbuff, (int)(ptr - outbuff));
*((short *)ptr)++ = short_value; *((int *)ptr)++ = int_value;
if (need_to_output_short) ASSIGN_INCR(ptr, short_value, short); latest_pos = ASSIGN_INCR(ptr, int_value, int); send_buff(outbuff, (int)(ASSIGN_INCR(ptr, last_value, int) - outbuff));
void rev(char *s, size_t len) { char *first; for ( first = s, s += len - 1; s >= first; --s) putchar(*s); }
expression: assignment-expression expression , assignment-expression
int main() { int x, y ; x = 1, 2 ; y = (3,4) ; printf( "%d %d\n", x, y ) ; }
int f() { return 7; } int g() { return 8; } int x = (printf("assigning x"), f(), g() );
int count = 0; for(int i=0; i<x; i++) { ... count++; }
bool arraysAreMirrored(int a1[], int a2[], size_t size) { size_t i1, i2; for(i1 = 0, i2 = size - 1; i1 < size; i1++, i2--) { if(a1[i1] != a2[i2]) { return false; } } return true; }
int i = (5,4,3,2,1); int j; j = 5,4,3,2,1; printf("%d %d\n", i , j);
(&a)[n] -a = (a + sizeof(a[n])*n -a) /sizeof(int) = sizeof(a[n])*n / sizeof(int) = sizeof(int) * n * n / sizeof(int) = n * n
int a[10]; int *p1 = &a[1]; int *p2 = &a[3]; printf( "%d\n", p2 - p1 );
Expression | Value | Explanation a | a | point to array of int elements a[n] | a + n*sizeof(int) | refer to n-th element in array of int elements ------------------------------------------------------------------------------------------------- &a | a | point to array of (n int elements array) (&a)[n] | a + n*sizeof(int[n]) | refer to n-th element in array of (n int elements array) ------------------------------------------------------------------------------------------------- sizeof(int[n]) | n * sizeof(int) | int[n] is a type of n-int-element array
(&a)[n]-a = ((a + n*sizeof(int[n])) - a) / sizeof(int) = (n * sizeof(int[n])) / sizeof(int) = (n * n * sizeof(int)) / sizeof(int) = n * n
MYAPI_ERROR getObjectSize(MYAPIHandle h, int* returnedSize);
int getObjectSize(MYAPIHandle h, MYAPI_ERROR* returnedError);
int size; if(getObjectSize(h, &size) != MYAPI_SUCCESS) { }
MYAPIError error; int size; size = getObjectSize(h, &error); if(error != MYAPI_SUCCESS) { }
rc = func(..., int **return_array, size_t *array_length);
if (NULL == return_array || NULL == array_length) return API_INVALID_ARGS;
jmp_buf x; void f() { longjmp(x,5); } int main() { int i = 0; if ( (i = setjmp(x)) == 0 ) { f(); } else { switch( i ) { case 1: case 2: default: fprintf( stdout, "error code = %d\n", i); break; } } return 0; }
int main(int argc, char** argv) { TRY { printf("In Try Statement\n"); THROW; printf("I do not appear\n"); } CATCH { printf("Got Exception!\n"); } ETRY; return 0; }
NSError *error = nil; if ([myThing doThingError: &error] == NO) { }
MyHandle * h = MyApiCreateHandle(); if (h == NULL) return 0; MyApiError * err = MyApiGetError(h); MyApiFileDescriptor * fd = MyApiOpenFile("/path/to/file.ext"); if (err->code != MyApi_ERROR_OK) { fprintf(stderr, "(%d) %s\n", err->code, err->message); MyApiDestroy(h); return 0; } MyApiRecord record; MyApiReadFileRecord(h, &record, sizeof(record)); if (MyApi_FAILED(err)) { fprintf(stderr, "(%d) %s\n", err->code, err->message); MyApiDestroy(h); return 0; }
int size; if(getObjectSize(h, &size) != MYAPI_SUCCESS) { }
int size; MYAPIError rc; rc = getObjectSize(h, &size) if ( rc != MYAPI_SUCCESS) { }
!hold_my_beer() && !hold_my_cigarette() && !hold_my_pants() || abort();
void look_ma(enum error *e, char *what_broke); enum error e; look_ma(e); if(e == FURNITURE) { reorder(what_broke); } else if(e == SELF) { tell_doctor(what_broke); }
struct collection friends; enum error *e = malloc(c.size * sizeof(enum error)); ... ask_for_favor(friends, reason); for(int i = 0; i < c.size; i++) { if(reason[i] == NOT_FOUND) find(friends[i]); }
struct foo { ... void (error_handler)(char *); }; void default_error_handler(char *message) { assert(f); printf("%s", message); } void foo_set_error_handler(struct foo *f, void (*eh)(char *)) { assert(f); f->error_handler = eh; } struct foo *foo_init() { struct foo *f = malloc(sizeof(struct foo)); foo_set_error_handler(f, default_error_handler); return f; } struct foo *f = foo_init(); foo_something();
typedef struct { enum {SUCCESS, ERROR} status; union { int errCode; MyType value; } ret; } MyTypeWrapper;
MyTypeWrapper MYAPIFunction(MYAPIHandle h) { MyTypeWrapper wrapper; wrapper.status = ERROR; wrapper.ret.errCode = MY_ERROR_CODE; wrapper.status = SUCCESS; wrapper.ret.value = myProcessedData; return wrapper; }
int getObjectSize(MYAPIHandle h, int* returnedSize); MYAPI_ERROR LastError; MYAPI_ERROR* getLastError() {return LastError;}; if(getObjectSize(h, &size) != FUNC_SUCCESS ) { MYAPI_ERROR* error = getLastError(); }
struct lnode *insert(char *data, int len, struct lnode *list) { struct lnode *p, *q; uint8_t good; struct { uint8_t alloc_node : 1; uint8_t alloc_str : 1; } cleanup = { 0, 0 }; p = (struct lnode *)malloc(sizeof(struct lnode)); good = cleanup.alloc_node = (p != NULL); if (good) { p->str = (char *)malloc(sizeof(char)*len); good = cleanup.alloc_str = (p->str != NULL); } if(good) { memcpy ( p->str, data, len ); } if(good) { if(NULL == list) { p->next = NULL; list = p; } else { q = list; while(q->next != NULL && good) { good = (strcmp(q->str,p->str) != 0); q = q->next; } if (good) { p->next = q->next; q->next = p; } } } if(!good) { if(cleanup.alloc_str) free(p->str); if(cleanup.alloc_node) free(p); } return (good ? list : NULL); }
if( !doit(a, b, c, &errcode) ) { (* handle *) (* thine *) (* error *) }
{ int yes=1; setsockopt(yourSocket, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)); }
setsockopt(yourSocket, SOL_SOCKET, SO_REUSEADDR, (int[]){1}, sizeof(int));
void func(type* values) { while(*values) { x = *values++; } } func((type[]){val1,val2,val3,val4,0});
int main() { struct llist { int a; struct llist* next;}; struct llist *list=cons(1, cons(2, cons(3, cons(4, NULL)))); struct llist *p = list; while(p != 0) { printf("%d\n", p->a); p = p->next; } }
typedef struct{ int value; int otherValue; } s; s test = {.value = 15, .otherValue = 16}; int a[100] = {1,2,[50]=3,4,5,[23]=6,7};
struct X { int len; char str[1]; }; int n = strlen("hello world"); struct X *string = malloc(sizeof(struct X) + n); strcpy(string->str, "hello world"); string->len = n;
typedef struct { char studentNumber COLUMNS( 1, 9); char firstName COLUMNS(10, 30); char lastName COLUMNS(31, 51); } StudentRecord;
unsigned int shiftmystuff (unsigned int a, unsigned int v) { return (a>>(v>>1))>>((v+1)>>1); }
unsigned int shiftmystuff (unsigned int a, unsigned int v) { unsigned int halfshift = v>>1; unsigned int otherhalf = (v+1)>>1; return (a >> halfshift) >> otherhalf; }
unsigned int shiftmystuff (unsigned int a, unsigned int v) { if (v<=31) return a>>v; else return 0; }
do { \ if( !(cond) ) { \ printf("MY_ASSERT(%s) failed\n", exit(-1); \ } \ } while( 0 )
typedef char __compile_time_assert[ (cond) ? 0 : -1]
LLNode * first = head; LLNode * second = first.linked_nodes; LLNode * third = second.linked_nodes ^ first; LLNode * fourth = third.linked_nodes ^ second;
LLNode * last = tail; LLNode * second_to_last = last.linked_nodes; LLNode * third_to_last = second_to_last.linked_nodes ^ last; LLNode * fourth_to_last = third_to_last.linked_nodes ^ second_to_last;
struct foo { char string[5]; int x; }; char *foo_string(struct foo *foo) { BUILD_ASSERT(offsetof(struct foo, string) == 0); return (char *)foo; }
int a = 1; int b = 2; printf("a = %d, b = %d\n", a, b); a ^= b; b ^= a; a ^= b; printf("a = %d, b = %d\n", a, b);
void * my_malloc_debug(int amt, char* file, int line) void * my_malloc(int amt) { }
F(ZERO, zero) \ F(ONE, one) \ F(TWO, two) enum Constants { SOME_ENUMS(DEFINE_ENUMS) }; const char *ToString(int c) { switch (c) { default: return NULL; SOME_ENUMS(CASE_MACRO) } }
typedef unsigned char ubyte; typedef void (*F_ParameterlessFunction)() ; typedef void (*F_CommandFunction)(ubyte byte) ; void F_SetupLowerLayer ( F_ParameterlessFunction initRequest, F_CommandFunction sending_command, F_CommandFunction *receiving_command); static F_ParameterlessFunction Init_Lower_Layer = NULL; static F_CommandFunction Send_Command = NULL; static ubyte init = 0; void recieve_value(ubyte my_input) { if(init == 0) { Init_Lower_Layer(); init = 1; } printf("Receiving 0x%02x\n",my_input); Send_Command(++my_input); } void F_SetupLowerLayer ( F_ParameterlessFunction initRequest, F_CommandFunction sending_command, F_CommandFunction *receiving_command) { Init_Lower_Layer = initRequest; Send_Command = sending_command; *receiving_command = &recieve_value; } int my_hw_do_init() { printf("Doing HW init\n"); return 0; } int my_hw_do_sending(ubyte send_this) { printf("doing HW sending 0x%02x\n",send_this); return 0; } F_CommandFunction my_hw_send_to_read = NULL; int main (void) { ubyte rx = 0x40; F_SetupLowerLayer(my_hw_do_init,my_hw_do_sending,&my_hw_send_to_read); my_hw_send_to_read(rx); getchar(); return 0; }
fileinfo_list* tempList = malloc(sizeof(fileinfo_list));
typedef struct { fileinfo** filedata; size_t nFiles; size_t size; size_t fileblock; } fileinfo_list;
* reverse-continue ( * reverse-finish -- Execute backward until just before the selected stack frame is called * reverse-next ( * reverse-nexti ( * reverse-step ( * reverse-stepi -- Step backward exactly one instruction * set exec-direction (forward/reverse) -- Set direction of execution.
define mallocinfo set $__f = fopen("/dev/tty", "w") call malloc_info(0, $__f) call fclose($__f)
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) { for (size_t i=0; i<arraySize; i++) array[i] = getNextValue(); } int getNextRandomValue(void) { return rand(); } int main(void) { int myarray[10]; populate_array(myarray, 10, getNextRandomValue); ... }
typedef void (*event_cb_t)(const struct event *evt, void *userdata);
int event_cb_register(event_cb_t cb, void *userdata);
static void my_event_cb(const struct event *evt, void *data) { } ... event_cb_register(my_event_cb, &my_custom_data); ...
struct event_cb *callback; ... callback->cb(event, callback->data);
typedef void (*call_back) (S32, S32); void test_call_back(S32 a, S32 b) { printf("In call back function, a:%d \t b:%d \n", a, b); } void call_callback_func(call_back back) { S32 a = 5; S32 b = 7; back(a, b); } S32 main(S32 argc, S8 *argv[]) { S32 ret = SUCCESS; call_back back; back = test_call_back; call_callback_func(back); return ret; }
void PrintTwoNumbers(int (*numberSource)(void)) { printf("%d and %d\n", numberSource(), numberSource()); } int overNineThousand(void) { return (rand() % 1000) + 9001; } int meaningOfLife(void) { return 42; } /* Here we call PrintTwoNumbers() with three different callbacks. */ int main(void) { PrintTwoNumbers(&rand); PrintTwoNumbers(&overNineThousand); PrintTwoNumbers(&meaningOfLife); return 0; }
typedef struct { int iValue; int kValue; char label[6]; } MyData; int cmpMyData_iValue (MyData *item1, MyData *item2) { if (item1->iValue < item2->iValue) return -1; if (item1->iValue > item2->iValue) return 1; return 0; } int cmpMyData_kValue (MyData *item1, MyData *item2) { if (item1->kValue < item2->kValue) return -1; if (item1->kValue > item2->kValue) return 1; return 0; } int cmpMyData_label (MyData *item1, MyData *item2) { return strcmp (item1->label, item2->label); } void bsearch_results (MyData *srch, MyData *found) { if (found) { printf ("found - iValue = %d, kValue = %d, label = %s\n", found->iValue, found->kValue, found->label); } else { printf ("item not found, iValue = %d, kValue = %d, label = %s\n", srch->iValue, srch->kValue, srch->label); } } int main () { MyData dataList[256] = {0}; { int i; for (i = 0; i < 20; i++) { dataList[i].iValue = i + 100; dataList[i].kValue = i + 1000; sprintf (dataList[i].label, "%2.2d", i + 10); } } { MyData srchItem = { 105, 1018, "13"}; MyData *foundItem = bsearch (&srchItem, dataList, 20, sizeof(MyData), cmpMyData_iValue ); bsearch_results (&srchItem, foundItem); foundItem = bsearch (&srchItem, dataList, 20, sizeof(MyData), cmpMyData_kValue ); bsearch_results (&srchItem, foundItem); foundItem = bsearch (&srchItem, dataList, 20, sizeof(MyData), cmpMyData_label ); bsearch_results (&srchItem, foundItem); } }
int _stdcall ioThread(void (*pOutput)()) { WSADATA wsaData; int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData); if (iResult != NO_ERROR) { printf("WSAStartup failed with error: %ld\n", iResult); return 1; } SOCKET ListenSocket; ListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (ListenSocket == INVALID_SOCKET) { wprintf(L"socket failed with error: %ld\n", WSAGetLastError()); WSACleanup(); return 1; } struct sockaddr_in service; service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr("127.0.0.1"); service.sin_port = htons(8282); if (bind(ListenSocket, (SOCKADDR *)& service, sizeof(service)) == SOCKET_ERROR) { printf("bind failed with error: %ld\n", WSAGetLastError()); closesocket(ListenSocket); WSACleanup(); return 1; } if (listen(ListenSocket, 1) == SOCKET_ERROR) { printf("listen failed with error: %ld\n", WSAGetLastError()); closesocket(ListenSocket); WSACleanup(); return 1; } SOCKET AcceptSocket; printf("Waiting for client to connect...\n"); AcceptSocket = accept(ListenSocket, NULL, NULL); if (AcceptSocket == INVALID_SOCKET) { printf("accept failed with error: %ld\n", WSAGetLastError()); closesocket(ListenSocket); WSACleanup(); return 1; } else pOutput (); closesocket(ListenSocket); WSACleanup(); return 0; } void printOut(void) { printf("connection received.\n"); } int main() { _beginthreadex(NULL, 0, ioThread, printOut, 0, NULL); Sleep(30000); }
int arr[]={56,90,45,1234,12,3,7,18}; int compare_s2b(const void *a,const void *b); int compare_b2s(const void *a,const void *b); int compare_s2b(const void* a, const void* b) { const int* p=(const int*)a; const int* q=(const int*)b; return *p-*q; } int compare_b2s(const void* a, const void* b) { const int* p=(const int*)a; const int* q=(const int*)b; return *q-*p; } int main() { printf("Before sorting\n\n"); int N=sizeof(arr)/sizeof(int); for(int i=0;i<N;i++) { printf("%d\t",arr[i]); } printf("\n"); qsort(arr,N,sizeof(int),compare_s2b); printf("\nSorted small to big\n\n"); for(int j=0;j<N;j++) { printf("%d\t",arr[j]); } qsort(arr,N,sizeof(int),compare_b2s); printf("\nSorted big to small\n\n"); for(int j=0;j<N;j++) { printf("%d\t",arr[j]); } exit(0); }
printf("value: %" PRId32, some_int32_t); printf("value: %" PRIu16, some_uint16_t);
if sizeof(size_t) == 4 use PRIu32 if sizeof(size_t) == 8 use PRIu64
printf("sizeof(int) = %lu", (unsigned long) sizeof(int));
CMTimeMakeWithSeconds( newDurationSeconds, 1000*1000*1000 )
1111101000₂ (1000₁₀) 0000000011₂ (3₁₀) 1111101011₂ (1003₁₀)
1111101001₂ (1001₁₀) 0000000011₂ (3₁₀) 1111101010₂ (1002₁₀)
long long Duration = 1000 * 1000 * 1000 * 1000; long long Duration = 1000000000000;
double Duration = 1000.0 * 1000 * 1000; long long Duration = 1000LL * 1000 * 1000 * 1000;
$ cat comma-expr.c && gcc -o comma-expr comma-expr.c && ./comma-expr int main() { printf("%d, %d\n", BILLION1, BILLION2); } 0, 1003 $
const char *readLine(FILE *file) { if (file == NULL) { printf("Error: file pointer is null."); exit(1); } int maximumLineLength = 128; char *lineBuffer = (char *)malloc(sizeof(char) * maximumLineLength); if (lineBuffer == NULL) { printf("Error allocating memory for line buffer."); exit(1); } char ch = getc(file); int count = 0; while ((ch != if (count == maximumLineLength) { maximumLineLength += 128; lineBuffer = realloc(lineBuffer, maximumLineLength); if (lineBuffer == NULL) { printf("Error reallocating space for line buffer."); exit(1); } } lineBuffer[count] = ch; count++; ch = getc(file); } lineBuffer[count] = char line[count + 1]; strncpy(line, lineBuffer, (count + 1)); free(lineBuffer); const char *constLine = line; return constLine; }
while (!feof(myFile)) { const char *line = readLine(myFile); printf("%s\n", line); }
int main(void) { FILE * fp; char * line = NULL; size_t len = 0; ssize_t read; fp = fopen("/etc/motd", "r"); if (fp == NULL) exit(EXIT_FAILURE); while ((read = getline(&line, &len, fp)) != -1) { printf("Retrieved line of length %zu:\n", read); printf("%s", line); } fclose(fp); if (line) free(line); exit(EXIT_SUCCESS); }
lineBuffer[count] = realloc(lineBuffer, count + 1); return lineBuffer; }
char *line = readLine(file); printf("LOG: read a line: %s\n", line); if (strchr(line, free(line); /* After this point, the memory allocated for the line has been reclaimed. You can to the `line` variable if you want). */
FILE* fp; char buffer[255]; fp = fopen("file.txt", "r"); while(fgets(buffer, 255, (FILE*) fp)) { printf("%s\n", buffer); } fclose(fp);
FILE* fh; fopen_s(&fh, filename, "r"); if (fh == NULL){ printf("file does not exists %s", filename); return 0; } const size_t line_size = 300; char* line = malloc(line_size); while (fgets(line, line_size, fh) != NULL) { printf(line); } free(line);
char buffer [BUFFER_SIZE]; strncpy(buffer, sourceString, BUFFER_SIZE - 1); buffer[BUFFER_SIZE - 1] =
void readLine(FILE* file, char* line, int limit) { int i; int read; read = fread(line, sizeof(char), limit, file); line[read] = for(i = 0; i <= read;i++) { if( { line[i] = break; } } if(i != read) { fseek(file, i - read + 1, SEEK_CUR); } }
char * readline(FILE *fp, char *buffer) { int ch; int i = 0; size_t buff_len = 0; buffer = malloc(buff_len + 1); if (!buffer) return NULL; while ((ch = fgetc(fp)) != { buff_len++; void *tmp = realloc(buffer, buff_len + 1); if (tmp == NULL) { free(buffer); return NULL; } buffer = tmp; buffer[i] = (char) ch; i++; } buffer[i] = if (ch == EOF && (i == 0 || ferror(fp))) { free(buffer); return NULL; } return buffer; } void lineByline(FILE * file){ char *s; while ((s = readline(file, 0)) != NULL) { puts(s); free(s); printf("\n"); } } int main() { char *fileName = "input-1.txt"; FILE* file = fopen(fileName, "r"); lineByline(file); return 0; }
const char *readLine(FILE *file, char* line) { if (file == NULL) { printf("Error: file pointer is null."); exit(1); } int maximumLineLength = 128; char *lineBuffer = (char *)malloc(sizeof(char) * maximumLineLength); if (lineBuffer == NULL) { printf("Error allocating memory for line buffer."); exit(1); } char ch = getc(file); int count = 0; while ((ch != if (count == maximumLineLength) { maximumLineLength += 128; lineBuffer = realloc(lineBuffer, maximumLineLength); if (lineBuffer == NULL) { printf("Error reallocating space for line buffer."); exit(1); } } lineBuffer[count] = ch; count++; ch = getc(file); } lineBuffer[count] = char line[count + 1]; strncpy(line, lineBuffer, (count + 1)); free(lineBuffer); return line; } char linebuffer[256]; while (!feof(myFile)) { const char *line = readLine(myFile, linebuffer); printf("%s\n", line); }
... const char *entirecontent=readLine(myFile); puts(entirecontent); free(entirecontent); ... const char *readLine(FILE *file) { char *lineBuffer=calloc(1,1), line[128]; if ( !file || !lineBuffer ) { fprintf(stderr,"an ErrorNo 1: ..."); exit(1); } for(; fgets(line,sizeof line,file) ; strcat(lineBuffer,line) ) { if( strchr(line, lineBuffer=realloc(lineBuffer,strlen(lineBuffer)+strlen(line)+1); if( !lineBuffer ) { fprintf(stderr,"an ErrorNo 2: ..."); exit(2); } } return lineBuffer; }
void testGetFile() { FILE *fp = fopen("input1.txt", "r"); size_t len = 255; char *line = malloc(sizeof(char) * len); if (fp == NULL) { printf("can open file input1.txt!"); return; } while(fgets(line, len, fp) != NULL) { printf("%s\n", line); } free(line); }
const char* func x(){ char line[100]; return (const char*) line; }
int main() { int i; char temp_ch; FILE *fp=fopen("data.txt","r"); while(temp_ch!=EOF) { i=0; char temp_str[20]={ while(temp_ch!= { temp_ch=fgetc(fp); temp_str[i]=temp_ch; i++; } if(temp_ch== { temp_ch=fgetc(fp); temp_str[i]=temp_ch; } printf("%s",temp_str); } return 0; }
FILE *pFile = fopen(your_file_path, "r"); int nbytes = 1024; char *line = (char *) malloc(nbytes); char *buf = (char *) malloc(nbytes); size_t bytes_read; int linesize = 0; while (fgets(buf, nbytes, pFile) != NULL) { bytes_read = strlen(buf); if (linesize + bytes_read > nbytes) { char *tmp = line; nbytes += nbytes / 2; line = (char *) malloc(nbytes); memcpy(line, tmp, linesize); free(tmp); } memcpy(line + linesize, buf, bytes_read); linesize += bytes_read; if (feof(pFile) || buf[bytes_read-1] == handle_line(line); linesize = 0; memset(line, } } free(buf); free(line);
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__FILENAME__= ${CMAKE_SOURCE_DIR}/,,$(abspath $<))\"
string(LENGTH "${CMAKE_SOURCE_DIR}/" SOURCE_PATH_SIZE) add_definitions("-DSOURCE_PATH_SIZE=${SOURCE_PATH_SIZE}")
(sizeof(s) > 2 && (s)[sizeof(s)-2] == sizeof(s) > 3 && (s)[sizeof(s)-3] == sizeof(s) > 4 && (s)[sizeof(s)-4] == sizeof(s) > 5 && (s)[sizeof(s)-5] == sizeof(s) > 6 && (s)[sizeof(s)-6] == sizeof(s) > 7 && (s)[sizeof(s)-7] == sizeof(s) > 8 && (s)[sizeof(s)-8] == sizeof(s) > 9 && (s)[sizeof(s)-9] == sizeof(s) > 10 && (s)[sizeof(s)-10] == sizeof(s) > 11 && (s)[sizeof(s)-11] ==
static const char* const THIS_FILE_NAME = \ strrchr(__FILE__,
static __declspec( thread ) const char* fileAndThreadLocal_strFilePath = NULL; static __declspec( thread ) const char* fileAndThreadLocal_strFileName = NULL;
GetSourceFileName(__FILE__, fileAndThreadLocal_strFilePath, fileAndThreadLocal_strFileName)
const char* GetSourceFileName(const char* strFilePath, const char*& rstrFilePathHolder, const char*& rstrFileNameHolder) { if(strFilePath != rstrFilePathHolder) { // rstrFileNameHolder = removePath(strFilePath); rstrFilePathHolder = strFilePath; } return rstrFileNameHolder; }
const char* removePath(const char* path) { const char* pDelimeter = strrchr (path, if (pDelimeter) path = pDelimeter+1; pDelimeter = strrchr (path, if (pDelimeter) path = pDelimeter+1; return path; }
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__MY_FILE__=
const char* GetFileName(const char *path) { const char *name = NULL, *tmp = NULL; if (path && *path) { name = strrchr(path, tmp = strrchr(path, if (tmp) { return name && name > tmp ? name + 1 : tmp + 1; } } return name ? name + 1 : path; } int main() { const char *name = NULL, *path = NULL; path = __FILE__; name = GetFileName(path); printf("path: %s, filename: %s\n", path, name); path ="/tmp/device.log"; name = GetFileName(path); printf("path: %s, filename: %s\n", path, name); path = "C:\\Downloads\\crisis.avi"; name = GetFileName(path); printf("path: %s, filename: %s\n", path, name); path = "C:\\Downloads/nda.pdf"; name = GetFileName(path); printf("path: %s, filename: %s\n", path, name); path = "C:/Downloads\\word.doc"; name = GetFileName(path); printf("path: %s, filename: %s\n", path, name); path = NULL; name = GetFileName(NULL); printf("path: %s, filename: %s\n", path, name); path = ""; name = GetFileName(""); printf("path: %s, filename: %s\n", path, name); return 0; }
path: test.c, filename: test.c path: /tmp/device.log, filename: device.log path: C:\Downloads\crisis.avi, filename: crisis.avi path: C:\Downloads/nda.pdf, filename: nda.pdf path: C:/Downloads\word.doc, filename: word.doc path: (null), filename: (null) path: , filename:
const char* filename_start = __FILE__; \ const char* filename = filename_start; \ while(*filename != filename++; \ while((filename != filename_start) && (*(filename - 1) != filename--; \ filename; })
constexpr auto* getFileName(const char* const path) { const auto* startPosition = path; for (const auto* currentCharacter = path;*currentCharacter != { if (*currentCharacter == { startPosition = currentCharacter; } } if (startPosition != path) { ++startPosition; } return startPosition; } std::cout << getFileName(__FILE__);
struct MyObj{ double x, y; }; struct MyObj foo(){ struct MyObj a; a.x = 10; a.y = 10; return a; } int main () { struct MyObj a; a = foo(); struct b = a; return 0; }
struct a { int i; }; struct a f(struct a x) { struct a r = x; return r; } int main(void) { struct a x = { 12 }; struct a y = f(x); printf("%d\n", y.i); return 0; }
int f(int x) { int r = x; return r; } int main(void) { int x = 12; int y = f(x); printf("%d\n", y); return 0; }
void foo(MyObj *r) { struct MyObj a; *r = a; } foo(&a);
struct marks{ int maths; int physics; int chem; }; struct marks deviation(struct marks student1 , struct marks student2 ); int main(){ struct marks student; student.maths= 87; student.chem = 67; student.physics=96; struct marks avg; avg.maths= 55; avg.chem = 45; avg.physics=34; struct marks dev= deviation(student, avg ); printf("%d %d %d" ,dev.maths,dev.chem,dev.physics); return 0; } struct marks deviation(struct marks student , struct marks student2 ){ struct marks dev; dev.maths = student.maths-student2.maths; dev.chem = student.chem-student2.chem; dev.physics = student.physics-student2.physics; return dev; }
struct emp { int id; char *name; }; struct emp get() { char *name = "John"; struct emp e1 = {100, name}; return (e1); } int main() { struct emp e2 = get(); printf("%s\n", e2.name); }
struct emp { int id; char *name; }; struct emp get() { char *name = "John"; struct emp e1 = {100, name}; return (e1); } int main() { struct emp e2 = get(); printf("%s\n", e2.name); }
* LIBC.LIB is a statically linked library for single-threaded programs. * LIBCMT.LIB is a statically linked library that supports multithreaded programs. * CRTDLL.LIB is an import library for CRTDLL.DLL that also supports multithreaded programs. CRTDLL.DLL itself is part of Windows NT.
int main () { int a = 5,b = 2; printf("%d",a+++++b); return 0; }
int main () { int a = 5,b = 2; printf("%d",a++ + ++b); return 0; }
[ SYMBOL_NAME(name = "a"), SYMBOL_PLUS_PLUS, SYMBOL_PLUS_PLUS, SYMBOL_PLUS, SYMBOL_NAME(name = "b") ]
struct bad_code { bad_code &operator++(int) { return *this; } int operator+(bad_code const &other) { return 1; } }; int main() { bad_code a, b; int c = a+++++b; return 0; }
c = (a++)++ + b c = (a) + ++(++b) c = (a++) + (++b)
char amessage[] = "now is the time"; char *pmessage = "now is the time";
0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x00008000: 0x00008008: ... amessage: 0x00500000: 0x00500008: pmessage: 0x00500010: 0x00 0x00 0x80 0x00
strcpy(amessage, pmessage); strcpy(pmessage, amessage); strtok(amessage, " "); strtok(pmessage, " "); scanf("%15s", amessage); scanf("%15s", pmessage);
char amessage[16]; amessage[0] = amessage[1] = ... amessage[15] =
char arr[] = "now is the time"; char *pchar = "later is the time"; char arr2[] = "Another String"; pchar = arr2; arr = arr2;
int main () { char amessage[] = "now is the time"; char *pmessage = "now is the time"; pmessage = NULL; amessage = NULL; printf ("%d\n", sizeof (amessage)); printf ("%d\n", sizeof (pmessage)); /* Size of pmessage is platform dependent - size of memory bus (1,2,4,8 bytes)*/ printf ("%p, %p\n", pmessage, &pmessage); printf ("%p, %p\n", amessage, &amessage); if (pmessage == amessage) { printf ("A string literal is defined only once. You are sharing space"); "now is the time"[0] = printf ("You have modified both!! %s == %s \n", amessage, pmessage); } return 0; }
int main (int argc, char *argv []) { char amessage [] = "now is the time"; char *pmessage = "now is the time"; printf("&amessage : % printf("&amessage[0]: % printf("&pmessage : % printf("&pmessage[0]: % printf("&\"now is the time\": % (uintptr_t)&"now is the time"); return 0; }
int main(char argc, char** argv) { char amessage[] = "now is the time"; char *pmessage = "now is the time"; amessage[3] = printf("%s\n",amessage); pmessage[3] = printf("%s\n",pmessage); }
static char __unnamed[] = "abc"; char *c = __unnamed;
int main(void) { char *s = "abc"; printf("%s\n", s); return 0; }
char *s = "abc"; 8: 48 c7 45 f8 00 00 00 movq $0x0,-0x8(%rbp) f: 00 c: R_X86_64_32S .rodata
17: c7 45 f0 61 62 63 00 movl $0x636261,-0x10(%rbp)
Section to Segment mapping: Segment Sections... 02 .text .rodata
int marr[] = {1,13,25,37,45,56}; int* pmarr = marr; int* point = (marr + 1); int** ppmarr = &pmarr; std::cout << "type of marr is: " << typeid(marr).name() << std::endl; std::cout << "type of &marr is: " << typeid(&marr).name() << std::endl; std::cout << "type of pmarr is: " << typeid(pmarr).name() << std::endl; std::cout << "type of &pmarr is: " << typeid(&pmarr).name() << std::endl;
float x = 3.141592653589793238; double z = 3.141592653589793238; printf("x=%f\n", x); printf("z=%f\n", z); printf("x=%20.18f\n", x); printf("z=%20.18f\n", z);
x=3.141593 z=3.141593 x=3.141592741012573242 z=3.141592653589793116
pax$ cat qq.c int main (vooid) { return 42; } pax$ rm qq ; gcc -Wall -o qq qq.c ; ./qq pax$ echo $? 42
BAR("here is a log message"); BAR("here is a log message with a param: %d", 42);
/* * if there * than one argument, expands to a comma followed by everything but * the first argument. only supports up to 9 arguments but can be * trivially expanded. */ SELECT_10TH(__VA_ARGS__, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\ TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, ONE, throwaway) int main(int argc, char *argv[]) { BAR("first test"); BAR("second test: %s", "a string"); return 0; }
BOOST_PP_VARIADIC_SIZE() BOOST_PP_VARIADIC_SIZE(,) BOOST_PP_VARIADIC_SIZE(,,) BOOST_PP_VARIADIC_SIZE(a) BOOST_PP_VARIADIC_SIZE(a,) BOOST_PP_VARIADIC_SIZE(,b) BOOST_PP_VARIADIC_SIZE(a,b) BOOST_PP_VARIADIC_SIZE(a, ,c)
BOOST_PP_CAT(BAR_, BOOST_PP_GREATER( BOOST_PP_VARIADIC_SIZE(__VA_ARGS__), 1))(__VA_ARGS__) \ /**/
BOOST_PP_GREATER(BOOST_PP_VARIADIC_SIZE(__VA_ARGS__), 1), \ BAR_1, BAR_0)(__VA_ARGS__) \ /**/
BOOST_PP_VARIADIC_ELEM(0, __VA_ARGS__) "\n" \ BOOST_PP_COMMA_IF( \ BOOST_PP_GREATER(BOOST_PP_VARIADIC_SIZE(__VA_ARGS__), 1)) \ BOOST_PP_ARRAY_ENUM(BOOST_PP_ARRAY_POP_FRONT( \ BOOST_PP_VARIADIC_TO_ARRAY(__VA_ARGS__)))) \ /**/
BOOST_PP_COMMA_IF(BOOST_PP_ARRAY_SIZE(array)) BOOST_PP_ARRAY_ENUM(array) \ /**/ BOOST_PP_VARIADIC_ELEM(0, __VA_ARGS__) "\n" \ BOOST_PP_ARRAY_ENUM_TRAILING(BOOST_PP_ARRAY_POP_FRONT( \ BOOST_PP_VARIADIC_TO_ARRAY(__VA_ARGS__)))) \ /**/
/** * A variadic macro which counts the number of arguments which it is * passed. Or, more precisely, it counts the number of commas which it is * passed, plus one. * * Danger: It can * will evaluate to 1, rather than to 0. */ NUM_ARGS_COUNTER(__VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, \ 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) a8, a9, a10, a11, a12, a13, \ a14, a15, a16, a17, a18, a19, a20, \ N, ...) \ N
/* * A variant of NUM_ARGS that evaluates to 1 if given 1 or 0 args, or * evaluates to 2 if given more than 1 arg. Behavior is nasty and undefined if * it */ NUM_ARGS_COUNTER(__VA_ARGS__, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \ 2, 2, 2, 2, 2, 2, 2, 1)
log("My creator has forsaken me. %s:%s:%d." msg, __FILE__, \ __func__, __LINE__) log("My creator has forsaken me. %s:%s:%d." msg, __FILE__, \ __func__, __LINE__, __VA_ARGS__)
CONCAT(_UNIMPLEMENTED, NUM_ARGS_CEIL2(__VA_ARGS__))(__VA_ARGS__)
int main() { DBG("No warning here"); DBG("and we can add as many arguments as needed. %s", "nice!"); return 0; }
int main(int argc, char *argv[]) { BAR("here is a log message"); BAR("here is a log message with a param: %d", 42); return 0; }
int main(int argc, char *argv[]) { LOG(INFO); LOG(DEBUG, "here is a log message"); LOG(WARN, "here is a log message with param: %d", 42); return 0; } /* outputs: [INFO] (no message) [DEBUG] here is a log message [WARN] here is a log message with param: 42 */
int main() { BAR("here is a log message"); BAR("here is a log message with a param: %d", 42); }
int main() { bool a = true; printf("%zu\n", sizeof(bool)); printf("%zu\n", sizeof(a)); printf("%zu\n", sizeof(a ? true : false)); return 0; }
void print(sll * n){ printf("%d -> ",n->val); if(n->next)print(n->next); }
char* str = "JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC"; str_split(str,
char** str_split(char* a_str, const char a_delim) { char** result = 0; size_t count = 0; char* tmp = a_str; char* last_comma = 0; char delim[2]; delim[0] = a_delim; delim[1] = 0; while (*tmp) { if (a_delim == *tmp) { count++; last_comma = tmp; } tmp++; } count += last_comma < (a_str + strlen(a_str) - 1); count++; result = malloc(sizeof(char*) * count); if (result) { size_t idx = 0; char* token = strtok(a_str, delim); while (token) { assert(idx < count); *(result + idx++) = strdup(token); token = strtok(0, delim); } assert(idx == count - 1); *(result + idx) = 0; } return result; } int main() { char months[] = "JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC"; char** tokens; printf("months=[%s]\n\n", months); tokens = str_split(months, if (tokens) { int i; for (i = 0; *(tokens + i); i++) { printf("month=[%s]\n", *(tokens + i)); free(*(tokens + i)); } printf("\n"); free(tokens); } return 0; }
$ ./main.exe months=[JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC] month=[JAN] month=[FEB] month=[MAR] month=[APR] month=[MAY] month=[JUN] month=[JUL] month=[AUG] month=[SEP] month=[OCT] month=[NOV] month=[DEC]
const char *my_str_literal = "JAN,FEB,MAR"; char *token, *str, *tofree; tofree = str = strdup(my_str_literal); while ((token = strsep(&str, ","))) my_fn(token); free(tofree);
char *strsep(char **stringp, const char *delim) { if (*stringp == NULL) { return NULL; } char *token_start = *stringp; *stringp = strpbrk(token_start, delim); if (*stringp) { **stringp = (*stringp)++; } return token_start; }
int main(void) { char st[] ="Where there is will, there is a way."; char *ch; ch = strtok(st, " "); while (ch != NULL) { printf("%s\n", ch); ch = strtok(NULL, " ,"); } getch(); return 0; }
int split (const char *str, char c, char ***arr) { int count = 1; int token_len = 1; int i = 0; char *p; char *t; p = str; while (*p != { if (*p == c) count++; p++; } *arr = (char**) malloc(sizeof(char*) * count); if (*arr == NULL) exit(1); p = str; while (*p != { if (*p == c) { (*arr)[i] = (char*) malloc( sizeof(char) * token_len ); if ((*arr)[i] == NULL) exit(1); token_len = 0; i++; } p++; token_len++; } (*arr)[i] = (char*) malloc( sizeof(char) * token_len ); if ((*arr)[i] == NULL) exit(1); i = 0; p = str; t = ((*arr)[i]); while (*p != { if (*p != c && *p != { *t = *p; t++; } else { *t = i++; t = ((*arr)[i]); } p++; } return count; }
int main (int argc, char ** argv) { int i; char *s = "Hello, this is a test module for the string splitting."; int c = 0; char **arr = NULL; c = split(s, printf("found %d tokens.\n", c); for (i = 0; i < c; i++) printf("string return 0; }
char** str_split( char* str, char delim, int* numSplits ) { char** ret; int retLen; char* c; if ( ( str == NULL ) || ( delim == { ret = NULL; retLen = -1; } else { retLen = 0; c = str; do { if ( *c == delim ) { retLen++; } c++; } while ( *c != ret = malloc( ( retLen + 1 ) * sizeof( *ret ) ); ret[retLen] = NULL; c = str; retLen = 1; ret[0] = str; do { if ( *c == delim ) { ret[retLen++] = &c[1]; *c = } c++; } while ( *c != } if ( numSplits != NULL ) { *numSplits = retLen; } return ret; } int main( int argc, char* argv[] ) { const char* str = "JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC"; char* strCpy; char** split; int num; int i; strCpy = malloc( strlen( str ) * sizeof( *strCpy ) ); strcpy( strCpy, str ); split = str_split( strCpy, if ( split == NULL ) { puts( "str_split returned NULL" ); } else { printf( "%i Results: \n", num ); for ( i = 0; i < num; i++ ) { puts( split[i] ); } } free( split ); free( strCpy ); return 0; }
int split (const char *txt, char delim, char ***tokens) { int *tklen, *t, count = 1; char **arr, *p = (char *) txt; while (*p != t = tklen = calloc (count, sizeof (int)); for (p = (char *) txt; *p != *tokens = arr = malloc (count * sizeof (char *)); t = tklen; p = *arr++ = calloc (*(t++) + 1, sizeof (char *)); while (*txt != { if (*txt == delim) { p = *arr++ = calloc (*(t++) + 1, sizeof (char *)); txt++; } else *p++ = *txt++; } free (tklen); return count; }
char **tokens; int count, i; const char *str = "JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC"; count = split (str, for (i = 0; i < count; i++) printf ("%s\n", tokens[i]); for (i = 0; i < count; i++) free (tokens[i]); free (tokens);
char** str_split(char *src_str, const char deliminator, size_t &num_sub_str){ num_sub_str = 0; char *src_str_tmp = src_str; bool found_delim = true; while(*src_str_tmp){ if(*src_str_tmp == deliminator){ *src_str_tmp = 0; found_delim = true; } else if(found_delim){ num_sub_str++; found_delim = false; } src_str_tmp++; } printf("Start - found %d sub strings\n", num_sub_str); if(num_sub_str <= 0){ printf("str_split() - no substrings were found\n"); return(0); } char **sub_strings = (char **)malloc( (sizeof(char*) * num_sub_str) + 1); const char *src_str_terminator = src_str_tmp; src_str_tmp = src_str; bool found_null = true; size_t idx = 0; while(src_str_tmp < src_str_terminator){ if(!*src_str_tmp) found_null = true; else if(found_null){ sub_strings[idx++] = src_str_tmp; found_null = false; } src_str_tmp++; } sub_strings[num_sub_str] = NULL; return(sub_strings); }
char months[] = "JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC"; char *str = strdup(months); size_t num_sub_str; char **sub_strings = str_split(str, char *endptr; if(sub_strings){ for(int i = 0; sub_strings[i]; i++) printf("[%s]\n", sub_strings[i]); } free(sub_strings); free(str);
/** * splits str on delim and dynamically allocates an array of pointers. * * On error -1 is returned, check errno * On success size of array is returned, which may be 0 on an empty string * or 1 if no delim was found. * * You could rewrite this to return the char ** array instead and upon NULL * know it * upon the hitting two delim * { "foo", NULL, "bar" } * * You need to define the semantics of a trailing delim Like "foo," is that a * 2 count array or an array of one? I choose the two count with the second entry * set to NULL since it * Modifies str so make a copy if this is a problem */ int split( char * str, char delim, char ***array, int *length ) { char *p; char **res; int count=0; int k=0; p = str; while( (p=strchr(p,delim)) != NULL ) { *p = 0; p++; count++; } res = calloc( 1, count * sizeof(char *)); if( !res ) return -1; p = str; for( k=0; k<count; k++ ){ if( *p ) res[k] = p; p = strchr(p, 0 ); p++; } *array = res; *length = count; return 0; } char str[] = "JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC,"; int main() { char **res; int k=0; int count =0; int rc; rc = split( str, if( rc ) { printf("Error: %s errno: %d \n", strerror(errno), errno); } printf("count: %d\n", count ); for( k=0; k<count; k++ ) { printf("str: %s\n", res[k]); } free(res ); return 0; }
char** strsplit(char* str, const char* delim){ char** res = NULL; char* part; int i = 0; char* aux = strdup(str); part = strdup(strtok(aux, delim)); while(part){ res = (char**)realloc(res, (i + 1) * sizeof(char*)); *(res + i) = strdup(part); part = strdup(strtok(NULL, delim)); i++; } res = (char**)realloc(res, i * sizeof(char*)); *(res + i) = NULL; return res; }
char *zstring_strtok(char *str, const char *delim) { static char *static_str=0; int index=0, strlength=0; int found = 0; /* delimiter cannot be NULL * if no more char left, return NULL as well */ if (delim==0 || (str == 0 && static_str == 0)) return 0; if (str == 0) str = static_str; while(str[strlength]) strlength++; for (index=0;index<strlength;index++) if (str[index]==delim[0]) { found=1; break; } if (!found) { static_str = 0; return str; } /* check for consecutive delimiters *if first char is delim, return delim */ if (str[0]==delim[0]) { static_str = (str + 1); return (char *)delim; } /* terminate the string * this assignmetn requires char[], so str has to * be char[] rather than *char */ str[index] = if ((str + index + 1)!=0) static_str = (str + index + 1); else static_str = 0; return str; }
Example Usage char str[] = "A,B,,,C"; printf("1 %s\n",zstring_strtok(s,",")); printf("2 %s\n",zstring_strtok(NULL,",")); printf("3 %s\n",zstring_strtok(NULL,",")); printf("4 %s\n",zstring_strtok(NULL,",")); printf("5 %s\n",zstring_strtok(NULL,",")); printf("6 %s\n",zstring_strtok(NULL,",")); Example Output 1 A 2 B 3 , 4 , 5 C 6 (null)
void splitString(const char *original, const char *delimiter, char ** & buffer, int & numStrings, int * & stringLengths){ const int lo = strlen(original); const int ld = strlen(delimiter); if(ld > lo){ buffer = (void *)0; numStrings = 0; stringLengths = (void *)0; return; } numStrings = 1; for(int i = 0;i < (lo - ld);i++){ if(strncmp(&original[i], delimiter, ld) == 0) { i += (ld - 1); numStrings++; } } stringLengths = (int *) malloc(sizeof(int) * numStrings); int currentStringLength = 0; int currentStringNumber = 0; int delimiterTokenDecrementCounter = 0; for(int i = 0;i < lo;i++){ if(delimiterTokenDecrementCounter > 0){ delimiterTokenDecrementCounter--; } else if(i < (lo - ld)){ if(strncmp(&original[i], delimiter, ld) == 0){ stringLengths[currentStringNumber] = currentStringLength; currentStringNumber++; currentStringLength = 0; delimiterTokenDecrementCounter = ld - 1; } else { currentStringLength++; } } else { currentStringLength++; } if(i == (lo - 1)){ stringLengths[currentStringNumber] = currentStringLength; } } buffer = (char **) malloc(sizeof(char *) * numStrings); for(int i = 0;i < numStrings;i++){ buffer[i] = (char *) malloc(sizeof(char) * (stringLengths[i] + 1)); } currentStringNumber = 0; currentStringLength = 0; delimiterTokenDecrementCounter = 0; for(int i = 0;i < lo;i++){ if(delimiterTokenDecrementCounter > 0){ delimiterTokenDecrementCounter--; } else if(currentStringLength >= stringLengths[currentStringNumber]){ buffer[currentStringNumber][currentStringLength] = 0; delimiterTokenDecrementCounter = ld - 1; currentStringLength = 0; currentStringNumber++; } else { buffer[currentStringNumber][currentStringLength] = (char)original[i]; currentStringLength++; } } buffer[currentStringNumber][currentStringLength] = 0; }
int main(){ const char *string = "STRING-1 DELIM string-2 DELIM sTrInG-3"; char **buffer; int numStrings; int * stringLengths; splitString(string, " DELIM ", buffer, numStrings, stringLengths); for(int i = 0;i < numStrings;i++){ printf("String: %s\n", buffer[i]); } }
*char[] str_split(char* str, char delim) { int begin = 0; int end = 0; int j = 0; int i = 0; char *buf[NUM]; while (i < strlen(str)) { if(*str == delim) { buf[j] = malloc(sizeof(char) * (end-begin)); strncpy(buf[j], *(str + begin), (end-begin)); begin = end; j++; } end++; i++; } return buf; }
char** split(char* a_str, const char a_delim, int* len){ char* s = (char*)malloc(sizeof(char) * strlen(a_str)); strcpy(s, a_str); char* tmp = a_str; int count = 0; while (*tmp != if (*tmp == a_delim) count += 1; tmp += 1; } *len = count; char** results = (char**)malloc(count * sizeof(char*)); results[0] = s; int i = 1; while (*s!= if (*s == a_delim){ *s = s += 1; results[i++] = s; } else s += 1; } return results; }
char *c=delim; while(*c && *c!=str[i]) c++; if (*c) {
char **split(char *str, size_t len, char delim, char ***result, unsigned long *count, unsigned long max) { size_t i; char **_result; *count=1; _result= *result; if (_result) { _result[0]=str; } for (i=0; i<len; ++i) { // if (str[i]==delim) { str[i]=0; if (_result) { _result[*count]=str+i+1; } ++(*count); if (max && *count==max) { break; } } } if (_result) { return _result; } *result=malloc((*count)*sizeof(char*)); if (!*result) { return NULL; } _result=*result; _result[0]=str; for (i=1; i<*count; ++i) { while(*str) ++str; ++str; _result[i]=str; } return _result; }
int main(int argc, char **argv) { char *str="JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC"; char **result=malloc(6*sizeof(char*)); char **result2=0; unsigned long count; unsigned long count2; unsigned long i; split(strdup(str),strlen(str), split(strdup(str),strlen(str), if (result) for (i=0; i<count; ++i) { printf("%s\n",result[i]); } printf("\n"); if (result2) for (i=0; i<count2; ++i) { printf("%s\n", result2[i]); } return 0; }
int dtmsplit(char *str, const char *delim, char ***array, int *length ) { int i=0; char *token; char **res = (char **) malloc(0 * sizeof(char *)); token = strtok(str, delim); while( token != NULL ) { res = (char **) realloc(res, (i + 1) * sizeof(char *)); res[i] = token; i++; token = strtok(NULL, delim); } *array = res; *length = i; return 1; } int main() { int i; int c = 0; char **arr = NULL; int count =0; char str[80] = "JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC"; c = dtmsplit(str, ",", &arr, &count); printf("Found %d tokens.\n", count); for (i = 0; i < count; i++) printf("string return(0); }
Found 12 tokens. string string string string string string string string string string string string
typedef struct { const char *start; size_t len; } token; char **split(const char *str, char sep) { char **array; unsigned int start = 0, stop, toks = 0, t; token *tokens = malloc((strlen(str) + 1) * sizeof(token)); for (stop = 0; str[stop]; stop++) { if (str[stop] == sep) { tokens[toks].start = str + start; tokens[toks].len = stop - start; toks++; start = stop + 1; } } tokens[toks].start = str + start; tokens[toks].len = stop - start; toks++; array = malloc((toks + 1) * sizeof(char*)); for (t = 0; t < toks; t++) { char *token = calloc(tokens[t].len + 1, 1); memcpy(token, tokens[t].start, tokens[t].len); array[t] = token; } array[t] = NULL; free(tokens); return array; }
int split(char* str, const char delimeter, char*** args) { int cnt = 1; char* t = str; while (*t == delimeter) t++; char* t2 = t; while (*(t2++)) if (*t2 == delimeter && *(t2 + 1) != delimeter && *(t2 + 1) != 0) cnt++; (*args) = malloc(sizeof(char*) * cnt); for(int i = 0; i < cnt; i++) { char* ts = t; while (*t != delimeter && *t != 0) t++; int len = (t - ts + 1); (*args)[i] = malloc(sizeof(char) * len); memcpy((*args)[i], ts, sizeof(char) * (len - 1)); (*args)[i][len - 1] = 0; while (*t == delimeter) t++; } return cnt; }
typedef struct { uintptr_t ptr; int size; } token_t; int explode(char *str, int slen, const char *delimiter, token_t **tokens) { int i = 0, c1 = 0, c2 = 0; for(i = 0; i <= slen; i++) { if(str[i] == *delimiter) { c1++; } } if(c1 == 0) { return -1; } *tokens = (token_t*)calloc((c1 + 1), sizeof(token_t)); ((*tokens)[c2]).ptr = (uintptr_t)str; i = 0; while(i <= slen) { if((str[i] == *delimiter) || (i == slen)) { ((*tokens)[c2]).size = (int)((uintptr_t)&(str[i]) - (uintptr_t)(((*tokens)[c2]).ptr)); if(i < slen) { c2++; ((*tokens)[c2]).ptr = (uintptr_t)&(str[i + 1]); } } i++; } return (c1 + 1); } char* implode(token_t *tokens, int size, const char *delimiter) { int i, len = 0; char *str; for(i = 0; i < len; i++) { len += tokens[i].size + 1; } str = (char*)calloc(len, sizeof(char)); len = 0; for(i = 0; i < size; i++) { memcpy((void*)&str[len], (void*)tokens[i].ptr, tokens[i].size); len += tokens[i].size; str[(len++)] = *delimiter; } str[len - 1] = return str; }
int main(int argc, char **argv) { int i, c; char *exp = "JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC"; token_t *tokens; char *imp; printf("%s\n", exp); if((c = explode(exp, strlen(exp), ",", &tokens)) > 0) { imp = implode(tokens, c, ","); printf("%s\n", imp); for(i = 0; i < c; i++) { printf("%.*s, %d\n", tokens[i].size, (char*)tokens[i].ptr, tokens[i].size); } } free((void*)tokens); free((void*)imp); return 0; }
int main() { int i; char *tmp = "Hello,World,sak"; bstring bstr = bfromcstr(tmp); struct bstrList *blist = bsplit(bstr, printf("num %d\n", blist->qty); for(i=0;i<blist->qty;i++) { printf("%d: %s\n", i, bstr2cstr(blist->entry[i], } }
int strCSV2Float(float *strFloatArray , char *myCSVStringing , char delim);
int strCSV2Float(float *strFloatArray , char *myCSVStringing , char delim); void main() { char myCSVString[101] = "-1.4,2.6,,-0.24,1.26"; float floatArr[10]; int totalValues = 0; char myDelim = printf("myCSVString == %s \n",&myCSVString[0]); totalValues = strCSV2Float(&floatArr[0] , &myCSVString[0], myDelim); int floatValueCount = 0; for (floatValueCount = 0 ; floatValueCount < totalValues ; floatValueCount++) { printf("floatArr[%d] = %f\n",floatValueCount , floatArr[floatValueCount]); } } int strCSV2Float(float *strFloatArray , char *myCSVStringing , char delim) { int strLen = 0; int commaCount =0; int commaCountOld =0; int wordEndChar = 0; int wordStartChar = -1; int wordLength =0; for(strLen=0; myCSVStringing[strLen] != { if ( (myCSVStringing[strLen] == delim) || ( myCSVStringing[strLen+1] == { commaCount++; wordEndChar = strLen; } if ( (commaCount - commaCountOld) > 0 ) { int aIter =0; wordLength = (wordEndChar - wordStartChar); char word[55] = ""; for (aIter = 0; aIter < wordLength; aIter++) { word[aIter] = myCSVStringing[strLen-wordLength+aIter+1]; } if (word[aIter-1] == delim) word[aIter-1] = word[wordLength] = strFloatArray[commaCount-1] = atof(&word[0]); wordLength = 0; wordStartChar = wordEndChar; commaCountOld = commaCount; } } return commaCount; }
myCSVString == -1.4,2.6,,-0.24,1.26 floatArr[0] = -1.400000 floatArr[1] = 2.600000 floatArr[2] = 0.000000 floatArr[3] = -0.240000 floatArr[4] = 1.260000
' int countChar(char *str) { int count; int i; i = 0; count = 0; while (str[i] != { i++; count++; } return (count); } void split(char *str) { int i; int j; int count; int restCount; char *str1; char *str2; i = 0; j = 0; count = countChar(str) - 1; restCount = (strlen(str) - count) -1; str1 = malloc(sizeof(char) * count); str2 = malloc(sizeof(char) * restCount); while(i < count) { str1[i] = str[i++]; } i = i + 2; while (str[i]) { str2[j++] = str[i++]; } printf("str1 = %s, str2 = %s\n", str1, str2); } int main() { char *str = "Xo = 100k"; split(str); return (0); }'
char **Split(char *in_text, char *in_sep) { char **ret = NULL; int count = 0; char *tmp = strdup(in_text); char *pos = tmp; while ((pos = strtok(pos, in_sep)) != NULL) { count++; pos = NULL; } free(tmp); pos = tmp = strdup(in_text); ret = calloc(count+1, sizeof(char*)); count = 0; while ((pos = strtok(pos, in_sep)) != NULL) { ret[count] = strdup(pos); count++; pos = NULL; } free(tmp); return count; } void Free_Array(char** in_array) { char *pos = in_array; while (pos[0] != NULL) { free(pos[0]); pos++; } free(in_array); }
int main(void) { char **array = Split("Hello World!", " "); Free_Array(array); array = NULL; return 0; }
static int count_token(char *iptr, char delim) { int token_count = 0; while (*iptr && isspace(*iptr)) iptr++; while (*iptr) { if ((*iptr != delim)) { token_count++; while (*iptr && (*iptr != delim)) iptr++; } else { iptr++; } } return token_count; } static char** split(char* input, int* argc){ char** argv; int token_count = count_token(input, argv = (char**)malloc(sizeof(char*)*token_count); int i = 0; char *token = strtok(input, " "); while(token) { puts(token); argv[i] = strdup(token); token = strtok(NULL, " "); i++; } assert(i == token_count); *argc = token_count; return argv; }
int main() { int i = 0,j = 0,k = 0; char name[] = "jrSmith-Rock"; int length = strlen(name); char store[100][100]; for(i = 0, j = 0,k = 0; i < length;) { if((name[i] >= store[j][k] = name[i]; k++; i++; } else{ while(! isalpha(name[i])) { i++; } j++; k = 0; } } for(i = 0; i <= j; i++) { printf("%s\n", store[i]); } return 0; }
static volatile int keepRunning = 1; void intHandler(int dummy) { keepRunning = 0; } int main(void) { signal(SIGINT, intHandler); while (keepRunning) {
void INThandler(int); int main(void) { signal(SIGINT, INThandler); while (1) pause(); return 0; } void INThandler(int sig) { char c; signal(sig, SIG_IGN); printf("OUCH, did you hit Ctrl-C?\n" "Do you really want to quit? [y/n] "); c = getchar(); if (c == exit(0); else signal(SIGINT, INThandler); getchar(); }
static bool keepRunning = true; void intHandler(int) { keepRunning = false; } int main(int argc, char *argv[]) { struct sigaction act; act.sa_handler = intHandler; sigaction(SIGINT, &act, NULL); while (keepRunning) { } }
struct termios term; term.c_iflag |= IGNBRK; term.c_iflag &= ~(INLCR | ICRNL | IXON | IXOFF); term.c_lflag &= ~(ICANON | ECHO | ECHOK | ECHOE | ECHONL | ISIG | IEXTEN); term.c_cc[VMIN] = 1; term.c_cc[VTIME] = 0; tcsetattr(fileno(stdin), TCSANOW, &term);
void sigint_handler(int); int main(void) { signal(SIGINT, sigint_handler); while (1){ pause(); } return 0; } void sigint_handler(int sig) { printf("killing process %d\n",getpid()); exit(0); }
void sig_handler(int signo) { if (signo == SIGINT) printf("received SIGINT\n"); } int main(void) { if (signal(SIGINT, sig_handler) == SIG_ERR) printf("\ncan while(1) sleep(1); return 0; }
$ cat xx.c extern void NAME(mine)(char *x); $ gcc -E xx.c extern void mine_3(char *x); $
float f(float x[]) { float p = 1.0; for (int i = 0; i < 959; i++) p += 1; return p; }
.LCPI0_0: .long 1148190720 f: vmovss xmm0, dword ptr [rip + .LCPI0_0] ret
float f(float x[]) { float p = 1.0; for (int i = 0; i < 960; i++) p += 1; return p; }
.LCPI0_0: .long 1065353216 .LCPI0_1: .long 1086324736 f: vmovss xmm0, dword ptr [rip + .LCPI0_0] vxorps ymm1, ymm1, ymm1 mov eax, 960 vbroadcastss ymm2, dword ptr [rip + .LCPI0_1] vxorps ymm3, ymm3, ymm3 vxorps ymm4, ymm4, ymm4 .LBB0_1: vaddps ymm0, ymm0, ymm2 vaddps ymm1, ymm1, ymm2 vaddps ymm3, ymm3, ymm2 vaddps ymm4, ymm4, ymm2 add eax, -192 jne .LBB0_1 vaddps ymm0, ymm1, ymm0 vaddps ymm0, ymm3, ymm0 vaddps ymm0, ymm4, ymm0 vextractf128 xmm1, ymm0, 1 vaddps ymm0, ymm0, ymm1 vpermilpd xmm1, xmm0, 1 vaddps ymm0, ymm0, ymm1 vhaddps ymm0, ymm0, ymm0 vzeroupper ret
$ head test.c.151t.cunroll ;; Function f (f, funcdef_no=0, decl_uid=1919, cgraph_uid=0, symbol_order=0) Not peeling: upper bound is known so can unroll completely
if (maxiter >= 0 && maxiter <= npeel) { if (dump_file) fprintf (dump_file, "Not peeling: upper bound is known so can " "unroll completely\n"); return false; }
Loop 1 iterates 959 times. Loop 1 iterates at most 959 times. Not unrolling loop 1 (--param max-completely-peeled-times limit reached). Not peeling: upper bound is known so can unroll completely
-march=core-avx2 -Ofast --param max-completely-peeled-insns=1000 --param max-completely-peel-times=1000
f: vmovss xmm0, DWORD PTR .LC0[rip] ret .LC0: .long 1148207104
.LCPI0_0: .long 1148207104 f: vmovss xmm0, dword ptr [rip + .LCPI0_0] ret
int count; { int n = (count + 7) / 8; switch (count % 8) { case 0: do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n > 0); } }
int count; // { int n = (count + 7) / 8; // // switch (count % 8) { // // case 0: // do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n > 0); } }
int count; // { int n = (count + 7) / 8; // // switch (count % 8) { // // case 0: // do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n > 0); } }
for (i = 0; i < len; ++i) { HAL_IO_PORT = *pSource++; }
int n = len / 8; for (i = 0; i < n; ++i) { HAL_IO_PORT = *pSource++; HAL_IO_PORT = *pSource++; HAL_IO_PORT = *pSource++; HAL_IO_PORT = *pSource++; HAL_IO_PORT = *pSource++; HAL_IO_PORT = *pSource++; HAL_IO_PORT = *pSource++; HAL_IO_PORT = *pSource++; } n = len % 8; for (i = 0; i < n; ++i) { HAL_IO_PORT = *pSource++; }
int n = (len + 8 - 1) / 8; switch (len % 8) { case 0: do { HAL_IO_PORT = *pSource++; case 7: HAL_IO_PORT = *pSource++; case 6: HAL_IO_PORT = *pSource++; case 5: HAL_IO_PORT = *pSource++; case 4: HAL_IO_PORT = *pSource++; case 3: HAL_IO_PORT = *pSource++; case 2: HAL_IO_PORT = *pSource++; case 1: HAL_IO_PORT = *pSource++; } while (--n > 0); }
void dsend(char* to, char* from, count) { int n = (count + 7) / 8; switch (count % 8) { case 0: do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n > 0); } }
for(int i = 0; i < 100; i+10) { myArray[i] += 1; myArray[i+1] += 1; myArray[i+2] += 1; myArray[i+3] += 1; myArray[i+4] += 1; myArray[i+5] += 1; myArray[i+6] += 1; myArray[i+7] += 1; myArray[i+8] += 1; myArray[i+9] += 1; }
instruction label1: instruction instruction instruction instruction jump to label1 some condition
evaluate expression into register r compare r with first case value branch to first case label if equal compare r with second case value branch to second case label if equal etc.... first_case_label: instruction instruction second_case_label: instruction instruction etc...
int n = (count + 1) / 8; switch (count % 8) { LOOP: case 0: if(n-- == 0) break; putchar( case 7: putchar( case 6: putchar( case 5: putchar( case 4: putchar( case 3: putchar( case 2: putchar( case 1: putchar( default: goto LOOP; }
char subbuff[5]; memcpy( subbuff, &buff[10], 4 ); subbuff[4] =
char *buff = "this is a test string"; printf("%.*s", 4, buff + 10);
char* substr = malloc(4); strncpy(substr, buff+10, 4);
if (mybool == TRUE) { } else if (mybool == FALSE) { } else { }
if ( x < 0 ) { log_error(3); x = 0; } else if ( y < 0 ) { x = 3; } else { }
if(condition_1 || condition_2 || ... condition_n) { }
if(condition_1 || condition_2 || ... condition_n) { } else if(condition_1 || condition_2 || ... condition_n) { } .... else { }
if ( x < 0 ) { x = 0; } else if ( y < 0 ) { x = 3; } else { printk(" \n [function or module name]: this should never happen \n"); /* It is always good to mention function/module name with the logs. If you end up with "this should never happen" message and the same message is used in many places in the software it will be hard to track/debug. */ }
if(something) doSomething; else doSomethingIForgot; doSomethingElse;
if(something) { if(anotherThing) { doSomething; } }
if(something) { if(!notMyThing) { if(anotherThing) { doSomething; } else { dontDoAnything; }} }
void print (char * text) { if (text == null) return; printf(text); }
int absolute_value (int n) { if (n == 0) { return 0; } else if (n > 0) { return n; } else /* if (n < 0) */ { return (n * (-1)); } }
double square_root (int n) { if (n > 5) return sqrt((double)n); else if (n == 5) return SQRT_FIVE; else if (n == 4) return 2.0; else if (n == 3) return SQRT_THREE; else if (n == 2) return SQRT_TWO; else if (n == 1) return 1.0; else if (n == 0) return 0.0; else return sqrt(-1); }
int a = 0; bool b = true; uint8_t* bPtr = (uint8_t*)&b; *bPtr = 0xCC; if(b == true) { a += 3; } else if(b == false) { a += 5; } else { exit(3); }
int WINAPI WinMain ( HINSTANCE instance, HINSTANCE prev_instance, PSTR cmd_line, int cmd_show )
void __stdcall fnname ( int, int* ) { ... } int main() { CreateThread ( NULL, 0, fnname, int, int*...... ) }
_beginthreadex(NULL, 0, ExecuteCommand, currCommand, 0, 0);
unsigned int __stdcall Scene::ExecuteCommand(void* command) { return system(static_cast<char*>(command)); }
int sum(int a, int b); int subtract(int a, int b); int mul(int a, int b); int div(int a, int b); int (*p[4]) (int x, int y); int main(void) { int result; int i, j, op; p[0] = sum; /* address of sum() */ p[1] = subtract; /* address of subtract() */ p[2] = mul; /* address of mul() */ p[3] = div; /* address of div() */ [...]
void fun1() { } void fun2() { } void fun3() { } void (*func_ptr[3]) = {fun1, fun2, fun3}; main() { int option; printf("\nEnter function number you want"); printf("\nYou should not enter other than 0 , 1, 2"); scanf("%d",&option); if((option>=0)&&(option<=2)) { (*func_ptr[option])(); } return 0; }
typedef int speed; speed fun(int x); enum fp { f1, f2, f3, f4, f5 }; void F1(); void F2(); void F3(); void F4(); void F5();
speed fun(int x) { int Vel; Vel = x; return Vel; } void F1() { printf("From F1\n"); } void F2() { printf("From F2\n"); } void F3() { printf("From F3\n"); } void F4() { printf("From F4\n"); } void F5() { printf("From F5\n"); }
int main() { int (*F_P)(int y); void (*F_A[5])() = { F1, F2, F3, F4, F5 }; int xyz, i; printf("Hello Function Pointer!\n"); F_P = fun; xyz = F_P(5); printf("The Value is %d\n", xyz); for (i = 0; i < 5; i++) { F_A[i](); } printf("\n\n"); F_A[f1](); F_A[f2](); F_A[f3](); F_A[f4](); return 0; }
typedef int FUNC(int, int); FUNC sum, subtract, mul, div; FUNC *p[4] = { sum, subtract, mul, div }; int main(void) { int result; int i = 2, j = 3, op = 2; result = p[op](i, j); } int sum(int a, int b) { return a+b; } int subtract(int a, int b) { return a-b; } int mul(int a, int b) { return a*b; } int div(int a, int b) { return a/b; }
static void gtk_button_class_init (GtkButtonClass *klass) { GObjectClass *gobject_class; GtkObjectClass *object_class; GtkWidgetClass *widget_class; GtkContainerClass *container_class; gobject_class = G_OBJECT_CLASS (klass); object_class = (GtkObjectClass*) klass; widget_class = (GtkWidgetClass*) klass; container_class = (GtkContainerClass*) klass; gobject_class->constructor = gtk_button_constructor; gobject_class->set_property = gtk_button_set_property; gobject_class->get_property = gtk_button_get_property;
struct _GtkObjectClass { GInitiallyUnownedClass parent_class; void (*set_arg) (GtkObject *object, GtkArg *arg, guint arg_id); void (*get_arg) (GtkObject *object, GtkArg *arg, guint arg_id); /* Default signal handler for the ::destroy signal, which is * invoked to request that references to the widget be dropped. * If an object class overrides destroy() in order to perform class * specific destruction then it must still invoke its superclass' * implementation of the method after it is finished with its * own cleanup. (See gtk_widget_real_destroy() for an example of * how to do this). */ void (*destroy) (GtkObject *object); };
struct function_table { char *name; void (*some_fun)(int arg1, double arg2); }; void function1(int arg1, double arg2).... struct function_table my_table [] = { {"function1", function1}, ...
using namespace std; void F0(){ printf("Print F%d\n", 0); } void F1(){ printf("Print F%d\n", 1); } void F2(){ printf("Print F%d\n", 2); } void F3(){ printf("Print F%d\n", 3); } void F4(){ printf("Print F%d\n", 4); } void (*fArrVoid[N_FUNC])() = {F0, F1, F2, F3, F4}; int Sum(int a, int b){ return(a+b); } int Sub(int a, int b){ return(a-b); } int Mul(int a, int b){ return(a*b); } int Div(int a, int b){ return(a/b); } int (*fArrArgs[4])(int a, int b) = {Sum, Sub, Mul, Div}; int main(){ for(int i = 0; i < 5; i++) (*fArrVoid[i])(); printf("\n"); DBG_PRINT((*fArrArgs[0])(3,2)) DBG_PRINT((*fArrArgs[1])(3,2)) DBG_PRINT((*fArrArgs[2])(3,2)) DBG_PRINT((*fArrArgs[3])(3,2)) return(0); }
char * func1(char *a) { *a = return a; } char * func2(char *a) { *a = return a; } int main() { char a = /* declare array of function pointers * the function pointer types are char * name(char *) * A pointer to this type of function would be just * put * before name, and parenthesis around *name: * char * (*name)(char *) * An array of these pointers is the same with [x] */ char * (*functions[2])(char *) = {func1, func2}; printf("%c, ", a); /* the functions return a pointer, so I need to deference pointer * Thats why the * in front of the parenthesis (in case it confused you) */ printf("%c, ", *(*functions[0])(&a)); printf("%c\n", *(*functions[1])(&a)); a = /* creating * funcp is equivalent to type char *(*funcname)(char *) */ typedef char *(*funcp)(char *); /* Now the declaration of the array of function pointers * becomes easier */ funcp functions2[2] = {func1, func2}; printf("%c, ", a); printf("%c, ", *(*functions2[0])(&a)); printf("%c\n", *(*functions2[1])(&a)); return 0; }
void one( int a, int b){ printf(" \n[ ONE ] a = %d b = %d",a,b);} void two( int a, int b){ printf(" \n[ TWO ] a = %d b = %d",a,b);} void three( int a, int b){ printf("\n [ THREE ] a = %d b = %d",a,b);} void four( int a, int b){ printf(" \n[ FOUR ] a = %d b = %d",a,b);} void five( int a, int b){ printf(" \n [ FIVE ] a = %d b = %d",a,b);} void(*p[2][2])(int,int) ; int main() { int i,j; printf("multidimensional array with function pointers\n"); p[0][0] = one; p[0][1] = two; p[1][0] = three; p[1][1] = four; for ( i = 1 ; i >=0; i--) for ( j = 0 ; j <2; j++) (*p[i][j])( (i, i*j); return 0; }
void calculation(double result[] ){ result[0] = 10+5; result[1] = 10 +6; ..... } int main(){ double result[10] = {0}; calculation(result); }
int (*pFunctions[F_NUM])(void * arg); int someFunction(void * arg) { int a= *((int*)arg); return a*a; } pFunctions[0]= someFunction; int someMethod(int idx, void * arg, int * result) { int done= 0; if (idx < F_NUM && pFunctions[idx] != NULL) { *result= pFunctions[idx](arg); done= 1; } return done; } int x= 2; int z= 0; someMethod(0, (void*)&x, &z); assert(z == 4);
enum ord __attribute__ ((__packed__)) { FIRST = 1, SECOND, THIRD }; STATIC_ASSERT( sizeof(enum ord) == 1 )
enum value{a,b,c,d,e,f,g,h,i,j,l,m,n}; value s; cout << sizeof(s) << endl;
typedef struct A_s_s { char m[113]; } A_s_t; typedef char A_c_t[113]; A_s_t v_s(void); A_c_t v_c(void); void s__v(A_s_t); void sP_v(A_s_t *); void c__v(A_c_t); void cP_v(A_c_t *);
char name; int number; FILE *f; f = fopen("contacts.pcl", "a"); printf("\nNew contact name: "); scanf("%s", &name); printf("New contact number: "); scanf("%i", &number); fprintf(f, "%c\n[ %d ]\n\n", name, number); fclose(f);
FILE *f = fopen("file.txt", "w"); if (f == NULL) { printf("Error opening file!\n"); exit(1); } const char *text = "Write this to the file"; fprintf(f, "Some text: %s\n", text); int i = 1; float py = 3.1415927; fprintf(f, "Integer: %d, float: %f\n", i, py); char c = fprintf(f, "A character: %c\n", c); fclose(f);
FILE *fp; char* str = "string"; int x = 10; fp=fopen("test.txt", "w"); if(fp == NULL) exit(-1); fprintf(fp, "This is a string which is written to a file\n"); fprintf(fp, "The string has %d words and keyword %s\n", x, str); fclose(fp);
FILE *fp; fp = fopen("c:\\test.txt", "wb"); if(fp == null) return; char x[10]="ABCDEFGHIJ"; fwrite(x, sizeof(x[0]), sizeof(x)/sizeof(x[0]), fp); fclose(fp);
clear i top_of_loop: call foo increment i compare 10, i jump_less top_of_loop
load i, 10 top_of_loop: call foo decrement i jump_not_neg top_of_loop
for (i = someObject.getAllObjects.size(); i >= 0; i--) {…}
size = someObject.getAllObjects.size(); for (i = 0; i < size; i++) {…}
<?php print "<br>".PHP_VERSION; $iter = 100000000; $i=$t1=$t2=0; $t1 = microtime(true); for($i=0;$i<$iter;$i++){} $t2 = microtime(true); print $t1 = microtime(true); for($i=$iter;$i>0;$i--){} $t2 = microtime(true); print $t1 = microtime(true); for($i=0;$i<$iter;++$i){} $t2 = microtime(true); print $t1 = microtime(true); for($i=$iter;$i>0;--$i){} $t2 = microtime(true); print
PHP 5.2.13 $i++ : 8.8842368125916 $i-- : 8.1797409057617 ++$i : 8.0271911621094 --$i : 7.1027431488037 PHP 5.3.1 $i++ : 8.9625310897827 $i-- : 8.5790238380432 ++$i : 5.9647901058197 --$i : 5.4021768569946
ldw r2,-3340(fp) %load i to r2 addi r2,r2,1 %increase i by 1 stw r2,-3340(fp) %save value of i ldw r2,-3340(fp) %load value again (???) cmplti r2,r2,100 %compare if less than equal 100 bne r2,zero,0xa018 %jump
ldw r2,-3340(fp) addi r3,r2,-1 stw r3,-3340(fp) bne r2,zero,0xa01c
int i,j,a=0; for(i=100;i--;){ for(j=10000;j--;){ a = j+1; } }
Ave. Up Memory = 4839 mus Ave. Down Memory = 5552 mus Ave. Up Memory = 18638 mus Ave. Down Memory = 19053 mus
template<class Iterator, typename T> void FillWithRandomNumbers(Iterator start, Iterator one_past_end, T a, T b) { std::random_device rnd_device; std::mt19937 generator(rnd_device()); std::uniform_int_distribution<T> dist(a, b); for (auto it = start; it != one_past_end; it++) *it = dist(generator); return ; } template<class Iterator> void FillWithRandomNumbers(Iterator start, Iterator one_past_end, double a, double b) { std::random_device rnd_device; std::mt19937_64 generator(rnd_device()); std::uniform_real_distribution<double> dist(a, b); for (auto it = start; it != one_past_end; it++) *it = dist(generator); return ; } template<class Iterator, class T> inline void sum_abs_up(Iterator first, Iterator one_past_last, T &total) { T sum = 0; auto it = first; do { sum += *it; it++; } while (it != one_past_last); total += sum; } template<class Iterator, class T> inline void sum_abs_down(Iterator first, Iterator one_past_last, T &total) { T sum = 0; auto it = one_past_last; do { it--; sum += *it; } while (it != first); total += sum; } template<class T> std::chrono::nanoseconds TimeDown(std::vector<T> &vec, const std::vector<T> &vec_original, std::size_t num_repititions, T &running_sum) { std::chrono::nanoseconds total{0}; for (std::size_t i = 0; i < num_repititions; i++) { auto start_time = std::chrono::high_resolution_clock::now(); sum_abs_down(vec.begin(), vec.end(), running_sum); total += std::chrono::high_resolution_clock::now() - start_time; vec = vec_original; } return total; } template<class T> std::chrono::nanoseconds TimeUp(std::vector<T> &vec, const std::vector<T> &vec_original, std::size_t num_repititions, T &running_sum) { std::chrono::nanoseconds total{0}; for (std::size_t i = 0; i < num_repititions; i++) { auto start_time = std::chrono::high_resolution_clock::now(); sum_abs_up(vec.begin(), vec.end(), running_sum); total += std::chrono::high_resolution_clock::now() - start_time; vec = vec_original; } return total; } template<class ValueType> void TimeFunctions(std::size_t num_repititions, std::size_t vec_size = (1u << 24)) { auto lower = std::numeric_limits<ValueType>::min(); auto upper = std::numeric_limits<ValueType>::max(); std::vector<ValueType> vec(vec_size); FillWithRandomNumbers(vec.begin(), vec.end(), lower, upper); const auto vec_original = vec; ValueType sum_up = 0, sum_down = 0; auto time_up = TimeUp(vec, vec_original, num_repititions, sum_up).count(); auto time_down = TimeDown(vec, vec_original, num_repititions, sum_down).count(); std::cout << "Ave. Up Memory = " << time_up/(num_repititions * 1000) << " mus\n"; std::cout << "Ave. Down Memory = " << time_down/(num_repititions * 1000) << " mus" << std::endl; return ; } int main() { std::size_t num_repititions = 1 << 10; TimeFunctions<int>(num_repititions); std::cout << TimeFunctions<double>(num_repititions); return 0; }
for(int i=myCollection.size(); i >= 0; i--) { ... }
-------- C7 45 B0 00 00 00 00 mov dword ptr [i],0 -------- EB 09 jmp labelB labelA 8B 45 B0 mov eax,dword ptr [i] -------- 83 C0 01 add eax,1 -------- 89 45 B0 mov dword ptr [i],eax labelB 83 7D B0 0A cmp dword ptr [i],0Ah -------- 7D 02 jge out1 -------- EB EF jmp labelA out1:
00074EBC C7 45 B0 01 00 00 00 mov dword ptr [i],1 00074EC3 8B 45 B0 mov eax,dword ptr [i] 00074EC6 83 E8 01 sub eax,1 00074EC9 89 45 B0 mov dword ptr [i],eax 00074ECC 75 F5 jne main+0C3h (074EC3h)
00144ECE B9 0A 00 00 00 mov ecx,0Ah label: 00144ED3 E2 FE loop label (0144ED3h)
System.out.println("top->down"); int n = 999; for (int i = n; i >= 0; i--) { n++; System.out.println("i = " + i + "\t n = " + n); } System.out.println("bottom->up"); n = 1; for (int i = 0; i < n; i++) { n++; System.out.println("i = " + i + "\t n = " + n); }
char *sent = "this is my sample example"; char *word = "sample"; if ( ) { }
char *sent = "this is my sample example"; char *word = "sample"; char *pch = strstr(sent, word); if(pch) { ... }
int main() { char str[] = "String1 subString1 Strinstrnd subStr ing1subString"; char sub[] = "subString"; char *p1, *p2, *p3; int i=0,j=0,flag=0; p1 = str; p2 = sub; for(i = 0; i<strlen(str); i++) { if(*p1 == *p2) { p3 = p1; for(j = 0;j<strlen(sub);j++) { if(*p3 == *p2) { p3++;p2++; } else break; } p2 = sub; if(j == strlen(sub)) { flag = 1; printf("\nSubstring found at index : %d\n",i); } } p1++; } if(flag==0) { printf("Substring NOT found"); } return (0); }
int main(void) { char mainstring[]="The quick brown fox jumps over the lazy dog"; char substring[20], *ret; int i=0; puts("enter the sub string to find"); fgets(substring, sizeof(substring), stdin); substring[strlen(substring)-1]= ret=strstr(mainstring,substring); if(strcmp((ret=strstr(mainstring,substring)),substring)) { printf("substring is present\t"); } printf("and the sub string is:::"); for(i=0;i<strlen(substring);i++) { printf("%c",*(ret+i)); } puts("\n"); return 0; }
public int findSubString(char[] original, char[] searchString) { int returnCode = 0; int counter = 0; int ctr = 0; if (original.Length < 1 || (original.Length)<searchString.Length || searchString.Length<1) { returnCode = -1; } while (ctr <= (original.Length - searchString.Length) && searchString.Length > 0) { if ((original[ctr]) == searchString[0]) { counter = 0; for (int count = ctr; count < (ctr + searchString.Length); count++) { if (original[count] == searchString[counter]) { counter++; } else { counter = 0; break; } } if (counter == (searchString.Length)) { returnCode = 1; } } ctr++; } return returnCode; }
printf("substring %s was found at position %d \n", substring,((int) (substring - mainstring)));
int main(void) { char mainstring[]="The quick brown fox jumps over the lazy dog"; char substring[20]; int i=0; puts("enter the sub stirng to find"); fgets(substring, sizeof(substring), stdin); substring[strlen(substring)-1]= if (strstr(mainstring,substring)) { printf("substring is present\t"); } printf("and the sub string is:::"); printf("%s",substring,"\n"); return 0; }
My code to find out if substring is exist in string or not following n lines -->> string to check if substring or not.. int len,len1; int isSubstring(char *s, char *sub,int i,int j) { int ans =0; for(;i<len,j<len1;i++,j++) { if(s[i] != sub[j]) { ans =1; break; } } if(j == len1 && ans ==0) { return 1; } else if(ans==1) return 0; return 0; } int main(){ char s[100001]; char sub[100001]; scanf("%s", &s); int no; scanf("%d",&no); int i ,j; i=0; j=0; int ans =0; len = strlen(s); while(no--) { i=0; j=0; ans=0; scanf("%s",&sub); len1=strlen(sub); int value; for(i=0;i<len;i++) { if(s[i]==sub[j]) { value = isSubstring(s,sub,i,j); if(value) { printf("Yes\n"); ans = 1; break; } } } if(ans==0) printf("No\n"); } }
int is_substr(char *str, char *sub) { int num_matches = 0; int sub_size = 0; while (*sub != sub_size++; sub++; } sub = sub - sub_size; while (*str != while (*sub == *str && *sub != num_matches++; sub++; str++; } if (num_matches == sub_size) { return 1; } num_matches = 0; str++; } return 0; }
int findSubstr(char *inpText, char *pattern); int main() { printf("Hello, World!\n"); char *Text = "This is my sample program"; char *pattern = "sample"; int pos = findSubstr(Text, pattern); if (pos > -1) { printf("Found the substring at position %d \n", pos); } else printf("No match found \n"); return 0; } int findSubstr(char *inpText, char *pattern) { int inplen = strlen(inpText); while (inpText != NULL) { char *remTxt = inpText; char *remPat = pattern; if (strlen(remTxt) < strlen(remPat)) { /* printf ("length issue remTxt %s \nremPath %s \n", remTxt, remPat); */ return -1; } while (*remTxt++ == *remPat++) { printf("remTxt %s \nremPath %s \n", remTxt, remPat); if (*remPat == printf ("match found \n"); return inplen - strlen(inpText+1); } if (remTxt == NULL) { return -1; } } remPat = pattern; inpText++; } }
int main(){ printf("C%d\n",(int)(90-(-4.5 -4.5))); return 0; }
int main(){ printf("C%d\n",(int)(90-(-4.5/ -4.5))); return 0; } /* 90 - (-4.5 / -4.5) = 89 */
int main(){ printf("C%d\n",(int)(90-(-4.5 -4.5))); return 0; } /* 90 - (-4.5 - 4.5) = 99*/
int main (void) { int vers; vers = 99; vers = 99; vers = 90; printf("C%d", vers); return 0; }
int main (void) { int vers; vers = 11; vers = 99; vers = 90; printf("C%d", vers); return 0; }
ENABLE_WALK = 0 ENABLE_RUN = 1 ENABLE_SHOOT = 2 ENABLE_SHOOTRUN = 3 value = ENABLE_RUN value |= ENABLE_SHOOT
0 0 0 0 0 0 1 1 (current value) & 1 1 1 1 1 1 0 1 (~ENABLE_SHOOT) --------------- 0 0 0 0 0 0 0 1 (result)
uint32_t i; uint32_t *array_ptr = &theArray[0]; uint32_t compareVal = 0x1234ABCD; bool validFlag = false; for (i=256; i!=0; i--) { if (compareVal == *array_ptr++) { validFlag = true; break; } }
; r0 = count, r1 = source ptr, r2 = comparison value stmfd sp!,{r4-r11} ; save non-volatile registers mov r3,r0,LSR pld [r1, ldmia r1!,{r4-r7} ; pre load first set loop_top: pld [r1, ldmia r1!,{r8-r11} ; pre load second set cmp r4,r2 ; search for match cmpne r5,r2 ; use conditional execution to avoid extra branch instructions cmpne r6,r2 cmpne r7,r2 beq found_it ldmia r1!,{r4-r7} ; use 2 sets of registers to hide load delays cmp r8,r2 cmpne r9,r2 cmpne r10,r2 cmpne r11,r2 beq found_it subs r3,r3, bne loop_top mov r0, ldmia sp!,{r4-r11} ; restore non-volatile registers bx lr ; return found_it: mov r0, ldmia sp!,{r4-r11} bx lr
.L9: cmp r3, r0 beq .L8 .L3: ldr r2, [r3, cmp r2, r1 bne .L9 mov r0, .L2: add sp, sp, bx lr .L8: mov r0, b .L2
loop_top: ldr r3,[r1], cmp r3,r2 beq true_exit subs r0,r0, bne loop_top false_exit: xxx bx lr true_exit: xxx bx lr
My Code MS Code Surface RT 297ns 562ns Surface RT 2 172ns 296ns
bool check(uint32_t theArray[], uint32_t compareVal) { uint32_t i; uint32_t x = theArray[SIZE-1]; if (x == compareVal) return true; theArray[SIZE-1] = compareVal; for (i = 0; theArray[i] != compareVal; i++); theArray[SIZE-1] = x; return i != SIZE-1; }
bool check(uint32_t theArray[], uint32_t compareVal) { uint32_t i; theArray[SIZE] = compareVal; for (i = 0; theArray[i] != compareVal; i++); return i != SIZE; }
bool check(uint32_t theArray[], uint32_t compareVal) { uint32_t *arrayPtr; theArray[SIZE] = compareVal; for (arrayPtr = theArray; *arrayPtr != compareVal; arrayPtr++); return arrayPtr != theArray+SIZE; }
i = 0; if (key >= a[i+512]) i += 512; if (key >= a[i+256]) i += 256; if (key >= a[i+128]) i += 128; if (key >= a[i+ 64]) i += 64; if (key >= a[i+ 32]) i += 32; if (key >= a[i+ 16]) i += 16; if (key >= a[i+ 8]) i += 8; if (key >= a[i+ 4]) i += 4; if (key >= a[i+ 2]) i += 2; if (key >= a[i+ 1]) i += 1; return (key == a[i]);
uint32_t my_hash[HASH_LEN]; int lookup(uint32_t value) { int i = HASH(value); while (my_hash[i] != 0 && my_hash[i] != value) i = (i + 1) % HASH_LEN; return i; } void store(uint32_t value) { int i = lookup(value); if (my_hash[i] == 0) my_hash[i] = value; } bool contains(uint32_t value) { return (my_hash[lookup(value)] == value); }
bool arrayContains(const uint32_t *array, size_t length) { const uint32_t * const end = array + length; while(array != end) { if(*array++ == 0x1234ABCD) return true; } return false; }
for (i=0; i<256; i++) { if (compareVal == the_array[i]) { [...] } }
bool theArray[MAX_VALUE]; uint32_t compareVal = 0x1234ABCD; bool validFlag = theArray[compareVal];
for (ptr = &the_array[0]; ptr < the_array+1024; ptr++) { if (compareVal == *ptr) { break; } } ... compare ptr and the_array+1024 here - you do not need validFlag at all.
if (compareVal == the_array[0]) { validFlag = true; goto end_of_compare; } if (compareVal == the_array[1]) { validFlag = true; goto end_of_compare; } ...and so on... end_of_compare:
binaryfilter = 0; for (int i = 0; i < array.length; i++) { binaryfilter = binaryfilter | array[i]; }
if ((binaryfilter & valuetosearch) != valuetosearch) { return false; } else { }
[8-bit] signed char: -127 to 127 [8-bit] unsigned char: 0 to 255 [16-bit]signed short: -32767 to 32767 [16-bit]unsigned short: 0 to 65535 [32-bit]signed long: -2147483647 to 2147483647 [32-bit]unsigned long: 0 to 4294967295 [64-bit]signed long long: -9223372036854775807 to 9223372036854775807 [64-bit]unsigned long long: 0 to 18446744073709551615
main() { printf("%d",sizeof(int)); printf("%d",sizeof(short)); printf("%d",sizeof(long)); }
int main(void) { printf("size of int: %d", (int)sizeof(int)); return 0; }
printf("(int) Bit size %zu\n", sizeof(int) * CHAR_BIT);
typedef int array[12]; int function(array t){ int size_of_t = sizeof(t)/sizeof(t[0]); return size_of_t; } void main(){ array t = {1,1,1}; int a = function(t); print(a); }
struct S { char * p; }; struct S s1, s2; s1.p = malloc(100); s2 = s1;
struct Foo { char a; int b; double c; } foo1,foo2; void foo_assign(void) { foo1 = foo2; } int main(/*char *argv[],int argc*/) { foo_assign(); return 0; }
00401050 <_foo_assign>: 401050: 55 push %ebp 401051: 89 e5 mov %esp,%ebp 401053: a1 20 20 40 00 mov 0x402020,%eax 401058: a3 30 20 40 00 mov %eax,0x402030 40105d: a1 24 20 40 00 mov 0x402024,%eax 401062: a3 34 20 40 00 mov %eax,0x402034 401067: a1 28 20 40 00 mov 0x402028,%eax 40106c: a3 38 20 40 00 mov %eax,0x402038 401071: a1 2c 20 40 00 mov 0x40202c,%eax 401076: a3 3c 20 40 00 mov %eax,0x40203c 40107b: 5d pop %ebp 40107c: c3 ret
0000000000400536 <main>: 400536: 55 push %rbp 400537: 48 89 e5 mov %rsp,%rbp 40053a: 48 83 ec 10 sub $0x10,%rsp 40053e: 8b 45 fc mov -0x4(%rbp),%eax 400541: 89 c6 mov %eax,%esi 400543: bf e4 05 40 00 mov $0x4005e4,%edi 400548: b8 00 00 00 00 mov $0x0,%eax 40054d: e8 be fe ff ff callq 400410 <printf@plt> 400552: b8 00 00 00 00 mov $0x0,%eax 400557: c9 leaveq 400558: c3 retq
int f() { int i = 13; return i; } int g() { int i; return i; } int main() { f(); assert(g() == 13); }
int i; int main() { printf("%d\n", i); } gcc -00 -std=c99 a.c
0000000000400536 <main>: 400536: 55 push %rbp 400537: 48 89 e5 mov %rsp,%rbp 40053a: 8b 05 04 0b 20 00 mov 0x200b04(%rip),%eax 400540: 89 c6 mov %eax,%esi 400542: bf e4 05 40 00 mov $0x4005e4,%edi 400547: b8 00 00 00 00 mov $0x0,%eax 40054c: e8 bf fe ff ff callq 400410 <printf@plt> 400551: b8 00 00 00 00 mov $0x0,%eax 400556: 5d pop %rbp 400557: c3 retq 400558: 0f 1f 84 00 00 00 00 nopl 0x0(%rax,%rax,1) 40055f: 00
[25] .bss NOBITS 0000000000601040 001040 000008 00 WA 0 0 4
uint16_t hey(uint32_t x, uint32_t mode) { uint16_t q; if (mode==1) q=2; if (mode==3) q=4; return q; } uint32_t wow(uint32_t mode) { return hey(1234567, mode); }
void moo(int mode) { if (mode < 5) launch_nukes(); hey(0, mode); }
switch (int) { case 1 : { printf("1\n"); break; } case 2 : { printf("2\n"); } case 3 : { printf("3\n"); } }
switch (operator->num_of_operands) { case 2: process_operand( operator->operand_2); case 1: process_operand( operator->operand_1); break; }
dsend(to, from, count) char *to, *from; int count; { int n = (count + 7) / 8; switch (count % 8) { case 0: do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n > 0); } }
case 0: case 1: case 2: break; case 3: case 4: break; default:
case optionA: case optionB: break; case optionC: break;
switch (nShorts) { case 4: frame.leadV1 = shortArray[3]; case 3: frame.leadIII = shortArray[2]; case 2: frame.leadII = shortArray[1]; case 1: frame.leadI = shortArray[0]; break; default: TS_ASSERT(false); }
uint8_t stuff(...) { uint8_t mask = 0x0f; uint8_t value = 0x55; return mask & value; }
void more_stuff(uint32_t value) { uint32_t byte1 = (value >> 24); uint32_t byte2 = (value >> 16) & 0xff; uint32_t byte3 = (value >> 8) & 0xff; uint32_t byte4 = value & 0xff; ... }
1 1 1 0 1 1 0 1 [input] (&) 0 0 1 1 1 1 0 0 [mask] ------------------------------ 0 0 1 0 1 1 0 0 [output]
1 1 1 0 1 1 0 1 [input] (^) 0 0 1 1 1 1 0 0 [mask] ------------------------------ 1 1 0 1 0 0 0 1 [output]
55 -> 0 0 1 1 0 1 1 1 [input] (&) 1 -> 0 0 0 0 0 0 0 1 [mask] --------------------------------------- 1 <- 0 0 0 0 0 0 0 1 [output]
630 bytes in 1 blocks are still reachable in loss record 5 of 5 at 0x4004F1B: calloc (vg_replace_malloc.c:418) by 0x931CD2: _dl_new_object (dl-object.c:52) by 0x92DD36: _dl_map_object_from_fd (dl-load.c:972) by 0x92EFB6: _dl_map_object (dl-load.c:2251) by 0x939F1B: dl_open_worker (dl-open.c:255) by 0x935965: _dl_catch_error (dl-error.c:178) by 0x9399C5: _dl_open (dl-open.c:584) by 0xA64E31: do_dlopen (dl-libc.c:86) by 0x935965: _dl_catch_error (dl-error.c:178) by 0xA64FF4: __libc_dlopen_mode (dl-libc.c:47) by 0xAE6086: pthread_cancel_init (unwind-forcedunwind.c:53) by 0xAE61FC: _Unwind_ForcedUnwind (unwind-forcedunwind.c:126)
void *runner(void *param) { pthread_exit(NULL); } int n; int main(void) { int i; pthread_t *threadIdArray; n=10; threadIdArray = malloc((n+n-1)*sizeof(pthread_t)); for(i=0;i<(n+n-1);i++) { if( pthread_create(&threadIdArray[i],NULL,runner,NULL) != 0 ) { printf("Couldn exit(1); } } for(i=0;i<(n+n-1);i++) { pthread_join(threadIdArray[i],NULL); } free(threadIdArray); return(0); }
valgrind -v --leak-check=full --show-reachable=yes ./a.out
==18933== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 4 from 4) --18933-- --18933-- used_suppression: 2 dl-hack3-cond-1 --18933-- used_suppression: 2 glibc-2.5.x-on-SUSE-10.2-(PPC)-2a
int foo(void) { static char *working_buf = NULL; char *temp_buf; if (!working_buf) { working_buf = (char *) malloc(16 * 1024); } temp_buf = (char *) malloc(5 * 1024); .... .... .... }
warning: type defaults to ‘int’ in declaration of ‘a’
_Static uint32_t my_arr[2]; _Static_assert(sizeof(my_arr) == 8, ""); _Static_assert(sizeof(my_arr[0]) == 4, ""); _Static_assert(sizeof(my_arr)[0] == 4, "");
off_t fsize(const char *filename) { struct stat st; if (stat(filename, &st) == 0) return st.st_size; return -1; }
off_t fsize(const char *filename) { struct stat st; if (stat(filename, &st) == 0) return st.st_size; fprintf(stderr, "Cannot determine size of %s: %s\n", filename, strerror(errno)); return -1; }
unsigned long fsize(char* file) { FILE * f = fopen(file, "r"); fseek(f, 0, SEEK_END); unsigned long len = (unsigned long)ftell(f); fclose(f); return len; }
int fsize(char* file) { int size; FILE* fh; fh = fopen(file, "rb"); if(fh != NULL){ if( fseek(fh, 0, SEEK_END) ){ fclose(fh); return -1; } size = ftell(fh); fclose(fh); return size; } return -1; }
off_t fsize(char *file) { struct stat filestat; if (stat(file, &filestat) == 0) { return filestat.st_size; } return 0; }
FILE * i_file; i_file = fopen(source, "r"); long f_d = fileno(i_file); struct stat buffer; fstat(f_d, &buffer); long file_length = buffer.st_size; fclose(i_file);
long get_file_size(char *path) { FILE *fp; fp = fopen(path, "r"); fseek(fp, 0, SEEK_END); return ftell(fp); }
fseek(fp, 0, SEEK_END); unsigned long int file_size = ftell(fp); rewind(fp);
int main(int argc, char** argv) { struct stat info; stat(argv[1], &info); printf("%s: size=%ld\n", argv[1], info.st_size); }
int main(int argc, char** argv) { struct stat64 info; stat64(argv[1], &info); printf("%s: size=%ld\n", argv[1], info.st_size); }
int main(int argc, char** argv) { FILE* fp = fopen(argv[1]); int f_size; fseek(fp, 0, SEEK_END); f_size = ftell(fp); rewind(fp); printf("%s: size=%ld", (unsigned long)f_size); }
long size ; size = ftell(FILENAME); printf("total size is %ld bytes",size);
typedef char BYTE1; typedef unsigned char BYTE2; BYTE1 a; BYTE2 b;
typedef struct { float (*computeArea)(const ShapeClass *shape); } ShapeClass; float shape_computeArea(const ShapeClass *shape) { return shape->computeArea(shape); }
typedef struct { ShapeClass shape; float width, height; } RectangleClass; static float rectangle_computeArea(const ShapeClass *shape) { const RectangleClass *rect = (const RectangleClass *) shape; return rect->width * rect->height; }
void rectangle_new(RectangleClass *rect) { rect->width = rect->height = 0.f; rect->shape.computeArea = rectangle_computeArea; }
void rectangle_new_with_lengths(RectangleClass *rect, float width, float height) { rectangle_new(rect); rect->width = width; rect->height = height; }
int main(void) { RectangleClass r1; rectangle_new_with_lengths(&r1, 4.f, 5.f); printf("rectangle r1 return 0; }
struct Queue { } typedef struct Queue Queue; void push(Queue* q, int element); void pop(Queue* q);
FOO *myfoo; myfoo = foo_create(...); foo_something(myfoo, ...); myfoo = foo_append(myfoo, ...); foo_delete(myfoo);
typedef struct Object { uuid_t uuid; } Object; int Object_init(Object *self); uuid_t Object_get_uuid(Object *self); int Object_clean(Object *self); typedef struct Person { Object obj; char *name; } Person; int Person_init(Person *self, char *name); int Person_greet(Person *self); int Person_clean(Person *self); int Object_init(Object *self) { self->uuid = uuid_new(); return 0; } uuid_t Object_get_uuid(Object *self) { return self->uuid; } int Object_clean(Object *self) { uuid_free(self->uuid); return 0; } int Person_init(Person *self, char *name) { Object_init(&self->obj); self->name = strdup(name); return 0; } int Person_greet(Person *self) { printf("Hello, %s", self->name); return 0; } int Person_clean(Person *self) { free(self->name); Object_clean(self); return 0; } int main(void) { Person p; Person_init(&p, "John"); Person_greet(&p); Object_get_uuid(&p); Person_clean(&p); return 0; }
/** * Define Shape class */ typedef struct Shape Shape; struct Shape { /** * Variables header... */ double width, height; /** * Functions header... */ double (*area)(Shape *shape); }; /** * Functions */ double calc(Shape *shape) { return shape->width * shape->height; } /** * Constructor */ Shape _Shape() { Shape s; s.width = 1; s.height = 1; s.area = calc; return s; } /********************************************/ int main() { Shape s1 = _Shape(); s1.width = 5.35; s1.height = 12.5462; printf("Hello World\n\n"); printf("User.width = %f\n", s1.width); printf("User.height = %f\n", s1.height); printf("User.area = %f\n\n", s1.area(&s1)); printf("Made with \xe2\x99\xa5 \n"); return 0; };
void abc(void *a, int b) { if(b==1) printf("%d",*(int*)a); else if(b==2) printf("%c",*(char*)a); else if(b==3) printf("%f",*(float*)a); }
uint16_t value = *(uint16_t*)ptr; uint16_t value = *(uint8_t*)ptr | ((*((uint8_t*)ptr+1))<<8);
void absolute_value ( void *j) { if ( *j < 0 ) *j = *j * (-1); } int main() { int i = 40; float f = -40; printf("print intiger i = %d \n",i); printf("print float f = %f \n",f); absolute_value(&i); absolute_value(&f); printf("print intiger i = %d \n",i); printf("print float f = %f \n",f); return 0; }
void main() { int a=10; float b=35.75; void *ptr; ptr=&a; printf("The value of integer variable is= %d",*( (int*) ptr) ); ptr=&b; printf("The value of float variable is= %f",*( (float*) ptr) ); }
void funct(void *a, int z) { if(z==1) printf("%d",*(int*)a); else if(z==2) printf("%c",*(char*)a); else if(z==3) printf("%f",*(float*)a); }
void absolute_value ( void *j, int *n) { if ( *n == INT) { if ( *((int*)j) < 0 ) *((int*)j) = *((int*)j) * (-1); } if ( *n == FLOAT ) { if ( *((float*)j) < 0 ) *((float*)j) = *((float*)j) * (-1); } } int main() { int i = 0,n=0; float f = 0; printf("Press 1 to enter integer or 2 got float then enter the value to get absolute value\n"); scanf("%d",&n); printf("\n"); if( n == 1) { scanf("%d",&i); printf("value entered before absolute function exec = %d \n",i); absolute_value(&i,&n); printf("value entered after absolute function exec = %d \n",i); } if( n == 2) { scanf("%f",&f); printf("value entered before absolute function exec = %f \n",f); absolute_value(&f,&n); printf("value entered after absolute function exec = %f \n",f); } else printf("unknown entry try again\n"); return 0; }
void abc(void *a, int b) { char *format[] = {"%d", "%c", "%f"}; printf(format[b-1], a); }
int a = 10; float b = 3.14; void *ptr; ptr = &a; printf( "data is %d " , *((int *)ptr)); ptr = &b; printf( "data is %f " , *((float *)ptr));
int main () { int i; char buffer [33]; printf ("Enter a number: "); scanf ("%d",&i); itoa (i,buffer,10); printf ("decimal: %s\n",buffer); itoa (i,buffer,16); printf ("hexadecimal: %s\n",buffer); itoa (i,buffer,2); printf ("binary: %s\n",buffer); return 0; }
Enter a number: 1750 decimal: 1750 hexadecimal: 6d6 binary: 11011010110
const char *my_itoa_buf(char *buf, size_t len, int num) { static char loc_buf[sizeof(int) * CHAR_BITS]; if (!buf) { buf = loc_buf; len = sizeof(loc_buf); } if (snprintf(buf, len, "%d", num) == -1) return ""; return buf; } const char *my_itoa(int num) { return my_itoa_buf(NULL, 0, num); }
void itoa(int n, char s[]) { int i, sign; if ((sign = n) < 0) n = -n; i = 0; do { s[i++] = n % 10 + } while ((n /= 10) > 0); if (sign < 0) s[i++] = s[i] = reverse(s); }
void reverse(char s[]) { int i, j; char c; for (i = 0, j = strlen(s)-1; i<j; i++, j--) { c = s[i]; s[i] = s[j]; s[j] = c; } }
std::string itos(int n) { const int max_size = std::numeric_limits<int>::digits10 + 1 + 1 ; char buffer[max_size] = {0}; sprintf(buffer, "%d", n); return std::string(buffer); }
char *itoa(long n) { int len = n==0 ? 1 : floor(log10l(labs(n)))+1; if (n<0) len++; char *buf = calloc(sizeof(char), len+1); snprintf(buf, len+1, "%ld", n); return buf; }
static char _numberSystem[] = "0123456789ABCDEF"; static char _twosComp[] = "FEDCBA9876543210"; static void safestrrev(char *buffer, const int bufferSize, const int strlen) { int len = strlen; if (len > bufferSize) { len = bufferSize; } for (int index = 0; index < (len / 2); index++) { char ch = buffer[index]; buffer[index] = buffer[len - index - 1]; buffer[len - index - 1] = ch; } } static int negateBuffer(char *buffer, const int bufferSize, const int strlen, const int radix) { int len = strlen; if (len > bufferSize) { len = bufferSize; } if (radix == 10) { if (len < (bufferSize - 1)) { buffer[len++] = buffer[len] = } } else { int twosCompIndex = 0; for (int index = 0; index < len; index++) { if ((buffer[index] >= { twosCompIndex = buffer[index] - } else if ((buffer[index] >= { twosCompIndex = buffer[index] - } else if ((buffer[index] >= { twosCompIndex = buffer[index] - } twosCompIndex += (16 - radix); buffer[index] = _twosComp[twosCompIndex]; } if (len < (bufferSize - 1)) { buffer[len++] = _numberSystem[radix - 1]; buffer[len] = 0; } } return len; } static int twosNegation(const int x, const int radix) { int n = x; if (x < 0) { if (radix == 10) { n = -x; } else { n = ~x; } } return n; } static char *safeitoa(const int x, char *buffer, const int bufferSize, const int radix) { int strlen = 0; int n = twosNegation(x, radix); int nuberSystemIndex = 0; if (radix <= 16) { do { if (strlen < (bufferSize - 1)) { nuberSystemIndex = (n % radix); buffer[strlen++] = _numberSystem[nuberSystemIndex]; buffer[strlen] = n = n / radix; } else { break; } } while (n != 0); if (x < 0) { strlen = negateBuffer(buffer, bufferSize, strlen, radix); } safestrrev(buffer, bufferSize, strlen); return buffer; } return NULL; }
char* itoa (unsigned long long value, char str[], int radix) { char buf [66]; char* dest = buf + sizeof(buf); boolean sign = false; if (value == 0) { memcpy (str, "0", 2); return str; } if (radix < 0) { radix = -radix; if ( (long long) value < 0) { value = -value; sign = true; } } *--dest = switch (radix) { case 16: while (value) { * --dest = if (*dest > value >>= 4; } break; case 10: while (value) { *--dest = value /= 10; } break; case 8: while (value) { *--dest = value >>= 3; } break; case 2: while (value) { *--dest = value >>= 1; } break; default: while (value) { *--dest = if (*dest > value /= radix; } break; } if (sign) *--dest = memcpy (str, dest, buf +sizeof(buf) - dest); return str; }
char* itoah(long num, char* s, int len) { long n, m = 16; int i = 16+2; int shift = if(!s || len < 1) return 0; n = num < 0 ? -1 : 1; n = n * num; len = len > i ? i : len; i = len < i ? len : i; s[i-1] = 0; i--; if(!num) { if(len < 2) return &s[i]; s[i-1]= return &s[i-1]; } while(i && n) { s[i-1] = n % m + if (s[i-1] > s[i-1] += shift ; n = n/m; i--; } if(num < 0) { if(i) { s[i-1] = i--; } } return &s[i]; }
static char * my_itoa ( int value, char * str, int base ) { int i,n =2,tmp; char buf[BIN_LEN+1]; switch(base) { case 16: for(i = 0;i<HEX_LEN;++i) { if(value/base>0) { n++; } } snprintf(str, n, "%x" ,value); break; case 10: for(i = 0;i<INT_LEN;++i) { if(value/base>0) { n++; } } snprintf(str, n, "%d" ,value); break; case 8: for(i = 0;i<OCT_LEN;++i) { if(value/base>0) { n++; } } snprintf(str, n, "%o" ,value); break; case 2: for(i = 0,tmp = value;i<BIN_LEN;++i) { if(tmp/base>0) { n++; } tmp/=base; } for(i = 1 ,tmp = value; i<n;++i) { if(tmp%2 != 0) { buf[n-i-1] = } else { buf[n-i-1] = } tmp/=base; } buf[n-1] = strcpy(str,buf); break; default: return NULL; } return str; }
void binary(unsigned int n) { for(int shift=sizeof(int)*8-1;shift>=0;shift--) { if (n >> shift & 1) printf("1"); else printf("0"); } printf("\n"); }
char * int2str(long int val, char *dst, int radix, int upcase) { char buffer[65]; char *p; long int new_val; char *dig_vec= upcase ? _dig_vec_upper : _dig_vec_lower; ulong uval= (ulong) val; if (radix < 0) { if (radix < -36 || radix > -2) return NullS; if (val < 0) { *dst++ = /* Avoid integer overflow in (-val) for LLONG_MIN (BUG uval = (ulong)0 - uval; } radix = -radix; } else if (radix > 36 || radix < 2) return NullS; /* The slightly contorted code which follows is due to the fact that few machines directly support unsigned long / and %. Certainly the VAX C compiler generates a subroutine call. In the interests of efficiency (hollow laugh) I let this happen for the first digit only; after that "val" will be in range so that signed integer division will do. Sorry YOUR C COMPILER. The first % and / should be unsigned, the second % and / signed, but C compilers tend to be extraordinarily sensitive to minor details of style. This works on a VAX, that all I claim for it. */ p = &buffer[sizeof(buffer)-1]; *p = new_val= uval / (ulong) radix; *--p = dig_vec[(uchar) (uval- (ulong) new_val*(ulong) radix)]; val = new_val; while (val != 0) { ldiv_t res; res=ldiv(val,radix); *--p = dig_vec[res.rem]; val= res.quot; } while ((*dst++ = *p++) != 0) ; return dst-1; }
char *itoa_x(int number, char *dest, size_t dest_size) { if (dest == NULL) { return NULL; } char buf[SIGNED_PRINT_SIZE(number)]; char *p = &buf[sizeof buf - 1]; int neg_num = number < 0 ? number : -number; *p = do { *--p = (char) ( neg_num /= 10; } while (neg_num); if (number < 0) { *--p = } size_t src_size = (size_t) (&buf[sizeof buf] - p); if (src_size > dest_size) { return NULL; } return memcpy(dest, p, src_size); }
char *itoa_x(int number, char *dest, size_t dest_size, int base) { if (dest == NULL || base < 2 || base > 36) { return NULL; } char buf[sizeof number * CHAR_BIT + 2]; char *p = &buf[sizeof buf - 1]; int neg_num = number < 0 ? number : -number; *p = do { *--p = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[-(neg_num % base)]; neg_num /= base; } while (neg_num); if (number < 0) { *--p = } size_t src_size = (size_t) (&buf[sizeof buf] - p); if (src_size > dest_size) { return NULL; } return memcpy(dest, p, src_size); }
div_t qr; do { qr = div(neg_num, base); *--p = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[-qr.rem]; neg_num = qr.quot; } while (neg_num);
void itochar(int x, char *buffer, int radix); int main() { char buffer[10]; itochar(725, buffer, 10); printf ("\n %s \n", buffer); return 0; } void itochar(int x, char *buffer, int radix) { int i = 0 , n,s; n = s; while (n > 0) { s = n%radix; n = n/radix; buffer[i++] = } buffer[i] = strrev(buffer); }
union float_uint { float f; unsigned int ui; }; int main() { float v = 241; union float_uint fui = {.f = v}; printf("Your IEEE 754 float sir: %08x\n", fui.ui); unsigned int* pp = (unsigned int*) &v; printf("Your IEEE 754 float, again, sir: %08x\n", *pp); return 0; }
clang -emit-llvm -o foo.bc -c foo.c clang -o foo foo.bc
clang -flto -c program1.c -o program1.o clang -flto -c program2.c -o program2.o
clang -flto -Wl,-plugin-opt=also-emit-llvm program1.o program2.o -o program
opt-3.8 -S -O3 -aa -basicaaa -tbaa -licm single.ll -o optimised.ll
int* allocateIntArray(int* ptr, int size){ if (ptr != NULL){ for (int i = 0; i < size; i++){ ptr[i] = i; } } return ptr; } void increasePointer(int** ptr){ if (ptr != NULL){ *ptr += 1; } } int main() { int* p1 = (int*)malloc(sizeof(int)* 10); allocateIntArray(p1, 10); for (int i = 0; i < 10; i++){ printf("%d\n", p1[i]); } increasePointer(&p1); printf("%d\n", *p1); p1--; free(p1); fgets(string, sizeof(string), stdin); return 0; }
for(int i = 0; i < length; i++) { *dest++ = *src++; *(dest++) = *(src++); }
variables declared and defined in main function -----> heap
pointers(ex:char *arr,int *arr) -------> heap dynamically allocated space(using malloc,calloc) --------> stack
int x = 10; void func() { int a = 0; int *p = &a: int *p2 = &x; chat *name = "ashok" char *name2 = malloc(10); ... }
static void Main(string[] args) { if(args == null || args.Length == 0) { Console.WriteLine("Please specify arguments!"); } else { Console.WriteLine(args[0]); Console.WriteLine(args[1]); } }
int main(int c, char **argv); int main(int c, char *argv[]); int main(int c, char *argv[1]); int main(int c, char *argv[42]);
int main(int c, char *argv[static 5]); int main(int c, char *argv[const]); int main(int c, char ** const argv);
char c[10]; char **c = &c; typedef char array[10]; array *pc = &c; char (*array)[10] = &c;
int main(int argc, char **argv) { while (--argc > 0) { printf("%s ", *++argv); } printf("\n"); return 0; } int main(int argc, char *argv[]) { int i; for (i=1; i<argc; i++) { printf("%s ", argv[i]); } printf("\n"); return 0; }
char *returnArray(char array []){ char returned [10]; return &(returned[0]); }
int main(){ int i=0; char array []={1,0,0,0,0,1,1}; char arrayCount=0; char* returnedArray = returnArray(&arrayCount); for (i=0; i<10;i++) printf(%d, ",", returnedArray[i]); }
char *returnArray(char array []){ char returned [10]; return &(returned[0]); }
char *foo(int count) { char *ret = malloc(count); if(!ret) return NULL; for(int i = 0; i < count; ++i) ret[i] = i; return ret; }
int main() { char *p = foo(10); if(p) { free(p); } return 0; }
void foo(char *buf, int count) { for(int i = 0; i < count; ++i) buf[i] = i; }
void foo(char *a, size_t asize) { } int bar(void) { char str[6] = "Hello"; foo(str, sizeof str); }
void returnArray(const char *srcArray, size_t srcSize, char *dstArray, char dstSize) { ... dstArray[i] = some_value_derived_from(srcArray[i]); ... } int main(void) { char src[] = "This is a test"; char dst[sizeof src]; ... returnArray(src, sizeof src, dst, sizeof dst); ... }
char *returnArray(const char *srcArray, size_t srcSize, size_t *dstSize) { char *dstArray = malloc(srcSize); if (dstArray) { *dstSize = srcSize; ... } return dstArray; } int main(void) { char src[] = "This is a test"; char *dst; size_t dstSize; dst = returnArray(src, sizeof src, &dstSize); ... free(dst); ... }
char (*returnArray(const char *srcArr, size_t srcSize))[SOME_SIZE] { char (*dstArr)[SOME_SIZE] = malloc(sizeof *dstArr); if (dstArr) { ... (*dstArr)[i] = ...; ... } return dstArr; } int main(void) { char src[] = "This is a test"; char (*dst)[SOME_SIZE]; ... dst = returnArray(src, sizeof src); ... printf("%c", (*dst)[j]); ... }
\ struct TYPE TYPE* contents; \ size_t size; \ }; \ \ struct TYPE struct TYPE a.contents = NULL; \ a.size = 0; \ return a; \ } \ \ void array_add(struct TYPE TYPE* a = malloc((o->size + 1) * sizeof(TYPE)); \ TYPE i; \ for(i = 0; i < o->size; ++i) { \ a[i] = o->contents[i]; \ } \ ++(o->size); \ a[o->size - 1] = value; \ free(o->contents); \ o->contents = a; \ } \ void array_destroy(struct TYPE free(o->contents); \ } \ TYPE* array_begin(struct TYPE return o->contents; \ } \ TYPE* array_end(struct TYPE return o->contents + o->size; \ }
IMPORT_ARRAY(int); struct intArray return_an_array() { struct intArray a; a = new_intArray(); array_add(&a, 1); array_add(&a, 2); array_add(&a, 3); return a; } int main() { struct intArray a; int* it; int* begin; int* end; a = return_an_array(); begin = array_begin(&a); end = array_end(&a); for(it = begin; it != end; ++it) { printf("%d ", *it); } array_destroy(&a); getchar(); return 0; }
char * returnArray(char *arr, int size) { char *new_arr = malloc(sizeof(char) * size); for(int i = 0; i < size; ++i) { new_arr[i] = arr[i]; } return new_arr; } int main() { char arr[7]= {1,0,0,0,0,1,1}; char *new_arr = returnArray(arr, 7); free(new_arr); }
typedef struct { char v[10]; } CHAR_ARRAY; CHAR_ARRAY returnArray(CHAR_ARRAY array_in, int size) { CHAR_ARRAY returned; for (int i = 0; i < size; i++ ) returned.v[i] = array_in.v[i] + 1; return returned; } int main(int argc, char * argv[]) { CHAR_ARRAY array = {1,0,0,0,0,1,1}; char arrayCount = 7; CHAR_ARRAY returnedArray = returnArray(array, arrayCount); for (int i = 0; i < arrayCount; i++) printf("%d, ", returnedArray.v[i]); getchar(); return 0; }
char* returnArrayPointer() { static char array[SIZE]; return array; }
int main() { char* myArray = returnArrayPointer(); }
void returnArray(int size, char *retArray) { } int main(void) { char foo[ARRAY_SIZE]; returnArray(ARRAY_SIZE, foo); }
char *MyFunction(some arguments...) { char *pointer = malloc(size for the new array); if (!pointer) An error occurred, abort or do something about the error. return pointer; }
static char encoding_table[] = { static char *decoding_table = NULL; static int mod_table[] = {0, 2, 1}; char *base64_encode(const unsigned char *data, size_t input_length, size_t *output_length) { *output_length = 4 * ((input_length + 2) / 3); char *encoded_data = malloc(*output_length); if (encoded_data == NULL) return NULL; for (int i = 0, j = 0; i < input_length;) { uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0; uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0; uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0; uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c; encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F]; encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F]; encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F]; encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F]; } for (int i = 0; i < mod_table[input_length % 3]; i++) encoded_data[*output_length - 1 - i] = return encoded_data; } unsigned char *base64_decode(const char *data, size_t input_length, size_t *output_length) { if (decoding_table == NULL) build_decoding_table(); if (input_length % 4 != 0) return NULL; *output_length = input_length / 4 * 3; if (data[input_length - 1] == if (data[input_length - 2] == unsigned char *decoded_data = malloc(*output_length); if (decoded_data == NULL) return NULL; for (int i = 0, j = 0; i < input_length;) { uint32_t sextet_a = data[i] == uint32_t sextet_b = data[i] == uint32_t sextet_c = data[i] == uint32_t sextet_d = data[i] == uint32_t triple = (sextet_a << 3 * 6) + (sextet_b << 2 * 6) + (sextet_c << 1 * 6) + (sextet_d << 0 * 6); if (j < *output_length) decoded_data[j++] = (triple >> 2 * 8) & 0xFF; if (j < *output_length) decoded_data[j++] = (triple >> 1 * 8) & 0xFF; if (j < *output_length) decoded_data[j++] = (triple >> 0 * 8) & 0xFF; } return decoded_data; } void build_decoding_table() { decoding_table = malloc(256); for (int i = 0; i < 64; i++) decoding_table[(unsigned char) encoding_table[i]] = i; } void base64_cleanup() { free(decoding_table); }
jounimalinen 25.1544 apache 25.5309 NibbleAndAHalf 38.4165 internetsoftwareconsortium 48.2879 polfosol 48.7955 wikibooks_org_c 51.9659 gnome 74.8188 elegantdice 118.899 libb64 120.601 manuelmartinez 120.801 arduino 126.262 daedalusalpha 126.473 CppCodec 151.866 wikibooks_org_cpp 343.2 adp_gmbh 381.523 LihO 406.693 libcurl 3246.39 user152949 4828.21
/* * Base64 encoding/decoding (RFC1341) * Copyright (c) 2005-2011, Jouni Malinen <j@w1.fi> * * This software may be distributed under the terms of the BSD license. * See README for more details. */ static const unsigned char base64_table[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; /** * base64_encode - Base64 encode * @src: Data to be encoded * @len: Length of the data to be encoded * @out_len: Pointer to output length variable, or %NULL if not used * Returns: Allocated buffer of out_len bytes of encoded data, * or empty string on failure */ std::string base64_encode(const unsigned char *src, size_t len) { unsigned char *out, *pos; const unsigned char *end, *in; size_t olen; olen = 4*((len + 2) / 3); if (olen < len) return std::string(); std::string outStr; outStr.resize(olen); out = (unsigned char*)&outStr[0]; end = src + len; in = src; pos = out; while (end - in >= 3) { *pos++ = base64_table[in[0] >> 2]; *pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)]; *pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)]; *pos++ = base64_table[in[2] & 0x3f]; in += 3; } if (end - in) { *pos++ = base64_table[in[0] >> 2]; if (end - in == 1) { *pos++ = base64_table[(in[0] & 0x03) << 4]; *pos++ = } else { *pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)]; *pos++ = base64_table[(in[1] & 0x0f) << 2]; } *pos++ = } return outStr; }
polfosol 45.2335 wikibooks_org_c 74.7347 apache 77.1438 libb64 100.332 gnome 114.511 manuelmartinez 126.579 elegantdice 138.514 daedalusalpha 151.561 jounimalinen 206.163 arduino 335.95 wikibooks_org_cpp 350.437 CppCodec 526.187 internetsoftwareconsortium 862.833 libcurl 1280.27 LihO 1852.4 adp_gmbh 1934.43 user152949 5332.87
static const int B64index[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 }; std::string b64decode(const void* data, const size_t len) { unsigned char* p = (unsigned char*)data; int pad = len > 0 && (len % 4 || p[len - 1] == const size_t L = ((len + 3) / 4 - pad) * 4; std::string str(L / 4 * 3 + pad, for (size_t i = 0, j = 0; i < L; i += 4) { int n = B64index[p[i]] << 18 | B64index[p[i + 1]] << 12 | B64index[p[i + 2]] << 6 | B64index[p[i + 3]]; str[j++] = n >> 16; str[j++] = n >> 8 & 0xFF; str[j++] = n & 0xFF; } if (pad) { int n = B64index[p[L]] << 18 | B64index[p[L + 1]] << 12; str[str.size() - 1] = n >> 16; if (len > L + 2 && p[L + 2] != { n |= B64index[p[L + 2]] << 6; str.push_back(n >> 8 & 0xFF); } } return str; }
char *base64encode (const void *b64_encode_this, int encode_this_many_bytes){ BIO *b64_bio, *mem_bio; BUF_MEM *mem_bio_mem_ptr; b64_bio = BIO_new(BIO_f_base64()); mem_bio = BIO_new(BIO_s_mem()); BIO_push(b64_bio, mem_bio); BIO_set_flags(b64_bio, BIO_FLAGS_BASE64_NO_NL); BIO_write(b64_bio, b64_encode_this, encode_this_many_bytes); BIO_flush(b64_bio); BIO_get_mem_ptr(mem_bio, &mem_bio_mem_ptr); BIO_set_close(mem_bio, BIO_NOCLOSE); BIO_free_all(b64_bio); BUF_MEM_grow(mem_bio_mem_ptr, (*mem_bio_mem_ptr).length + 1); (*mem_bio_mem_ptr).data[(*mem_bio_mem_ptr).length] = return (*mem_bio_mem_ptr).data; } char *base64decode (const void *b64_decode_this, int decode_this_many_bytes){ BIO *b64_bio, *mem_bio; char *base64_decoded = calloc( (decode_this_many_bytes*3)/4+1, sizeof(char) ); b64_bio = BIO_new(BIO_f_base64()); mem_bio = BIO_new(BIO_s_mem()); BIO_write(mem_bio, b64_decode_this, decode_this_many_bytes); BIO_push(b64_bio, mem_bio); BIO_set_flags(b64_bio, BIO_FLAGS_BASE64_NO_NL); int decoded_byte_index = 0; while ( 0 < BIO_read(b64_bio, base64_decoded+decoded_byte_index, 1) ){ decoded_byte_index++; } BIO_free_all(b64_bio); return base64_decoded; } /*Here int main(void){ char data_to_encode[] = "Base64 encode this string!"; int bytes_to_encode = strlen(data_to_encode); char *base64_encoded = base64encode(data_to_encode, bytes_to_encode); int bytes_to_decode = strlen(base64_encoded); char *base64_decoded = base64decode(base64_encoded, bytes_to_decode); printf("Original character string is: %s\n", data_to_encode); printf("Base-64 encoded string is: %s\n", base64_encoded); printf("Base-64 decoded string is: %s\n", base64_decoded); free(base64_encoded); free(base64_decoded); }
/* base64.cpp and base64.h Copyright (C) 2004-2008 René Nyffenegger This source code is provided warranty. In no event will the author be held liable for any damages arising from the use of this software. Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions: 1. The origin of this source code must not be misrepresented; you must not claim that you wrote the original source code. If you use this source code in a product, an acknowledgment in the product documentation would be appreciated but is not required. 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original source code. 3. This notice may not be removed or altered from any source distribution. René Nyffenegger rene.nyffenegger@adp-gmbh.ch */ static const std::string base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz" "0123456789+/"; static inline bool is_base64(unsigned char c) { return (isalnum(c) || (c == } std::string base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) { std::string ret; int i = 0; int j = 0; unsigned char char_array_3[3]; unsigned char char_array_4[4]; while (in_len--) { char_array_3[i++] = *(bytes_to_encode++); if (i == 3) { char_array_4[0] = (char_array_3[0] & 0xfc) >> 2; char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4); char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6); char_array_4[3] = char_array_3[2] & 0x3f; for(i = 0; (i <4) ; i++) ret += base64_chars[char_array_4[i]]; i = 0; } } if (i) { for(j = i; j < 3; j++) char_array_3[j] = char_array_4[0] = (char_array_3[0] & 0xfc) >> 2; char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4); char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6); char_array_4[3] = char_array_3[2] & 0x3f; for (j = 0; (j < i + 1); j++) ret += base64_chars[char_array_4[j]]; while((i++ < 3)) ret += } return ret; } std::string base64_decode(std::string const& encoded_string) { int in_len = encoded_string.size(); int i = 0; int j = 0; int in_ = 0; unsigned char char_array_4[4], char_array_3[3]; std::string ret; while (in_len-- && ( encoded_string[in_] != char_array_4[i++] = encoded_string[in_]; in_++; if (i ==4) { for (i = 0; i <4; i++) char_array_4[i] = base64_chars.find(char_array_4[i]); char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4); char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2); char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3]; for (i = 0; (i < 3); i++) ret += char_array_3[i]; i = 0; } } if (i) { for (j = i; j <4; j++) char_array_4[j] = 0; for (j = 0; j <4; j++) char_array_4[j] = base64_chars.find(char_array_4[j]); char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4); char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2); char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3]; for (j = 0; (j < i - 1); j++) ret += char_array_3[j]; } return ret; }
std::string base64_encode(unsigned char const* , unsigned int len); std::string base64_decode(std::string const& s);
const std::string s = "test"; std::string encoded = base64_encode(reinterpret_cast<const unsigned char*>(s.c_str()), s.length()); std::string decoded = base64_decode(encoded);
char base64_digit (n) unsigned n; { if (n < 10) return n - else if (n < 10 + 26) return n - else if (n < 10 + 26 + 26) return n - else assert(0); return 0; } unsigned char base64_decode_digit(char c) { switch (c) { case case default : if (isdigit(c)) return c - else if (islower(c)) return c - else if (isupper(c)) return c - else assert(0); } return 0xff; } unsigned base64_decode(char *s) { char *p; unsigned n = 0; for (p = s; *p; p++) n = 64 * n + base64_decode_digit(*p); return n; }
static const char table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; static const int BASE64_INPUT_SIZE = 57; BOOL isbase64(char c) { return c && strchr(table, c) != NULL; } inline char value(char c) { const char *p = strchr(table, c); if(p) { return p-table; } else { return 0; } } int UnBase64(unsigned char *dest, const unsigned char *src, int srclen) { *dest = 0; if(*src == 0) { return 0; } unsigned char *p = dest; do { char a = value(src[0]); char b = value(src[1]); char c = value(src[2]); char d = value(src[3]); *p++ = (a << 2) | (b >> 4); *p++ = (b << 4) | (c >> 2); *p++ = (c << 6) | d; if(!isbase64(src[1])) { p -= 2; break; } else if(!isbase64(src[2])) { p -= 2; break; } else if(!isbase64(src[3])) { p--; break; } src += 4; while(*src && (*src == 13 || *src == 10)) src++; } while(srclen-= 4); *p = 0; return p-dest; }
/** Static Base64 character encoding lookup table */ const char CBase64::encodeCharacterTable[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; /** Static Base64 character decoding lookup table */ const char CBase64::decodeCharacterTable[256] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 ,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21 ,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1}; void CBase64::Encode(std::istream &in, std::ostringstream &out) { char buff1[3]; char buff2[4]; _UINT8 i=0, j; while(in.readsome(&buff1[i++], 1)) if (i==3) { out << encodeCharacterTable[(buff1[0] & 0xfc) >> 2]; out << encodeCharacterTable[((buff1[0] & 0x03) << 4) + ((buff1[1] & 0xf0) >> 4)]; out << encodeCharacterTable[((buff1[1] & 0x0f) << 2) + ((buff1[2] & 0xc0) >> 6)]; out << encodeCharacterTable[buff1[2] & 0x3f]; i=0; } if (--i) { for(j=i;j<3;j++) buff1[j] = buff2[0] = (buff1[0] & 0xfc) >> 2; buff2[1] = ((buff1[0] & 0x03) << 4) + ((buff1[1] & 0xf0) >> 4); buff2[2] = ((buff1[1] & 0x0f) << 2) + ((buff1[2] & 0xc0) >> 6); buff2[3] = buff1[2] & 0x3f; for (j=0;j<(i+1);j++) out << encodeCharacterTable[buff2[j]]; while(i++<3) out << } } void CBase64::Decode(std::istringstream &in, std::ostream &out) { char buff1[4]; char buff2[4]; _UINT8 i=0, j; while(in.readsome(&buff2[i], 1) && buff2[i] != { if (++i==4) { for (i=0;i!=4;i++) buff2[i] = decodeCharacterTable[buff2[i]]; out << (char)((buff2[0] << 2) + ((buff2[1] & 0x30) >> 4)); out << (char)(((buff2[1] & 0xf) << 4) + ((buff2[2] & 0x3c) >> 2)); out << (char)(((buff2[2] & 0x3) << 6) + buff2[3]); i=0; } } if (i) { for (j=i;j<4;j++) buff2[j] = for (j=0;j<4;j++) buff2[j] = decodeCharacterTable[buff2[j]]; buff1[0] = (buff2[0] << 2) + ((buff2[1] & 0x30) >> 4); buff1[1] = ((buff2[1] & 0xf) << 4) + ((buff2[2] & 0x3c) >> 2); buff1[2] = ((buff2[2] & 0x3) << 6) + buff2[3]; for (j=0;j<(i-1); j++) out << (char)buff1[j]; } }
string base64_encode( const string &str ){ BIO *base64_filter = BIO_new( BIO_f_base64() ); BIO_set_flags( base64_filter, BIO_FLAGS_BASE64_NO_NL ); BIO *bio = BIO_new( BIO_s_mem() ); BIO_set_flags( bio, BIO_FLAGS_BASE64_NO_NL ); bio = BIO_push( base64_filter, bio ); BIO_write( bio, str.c_str(), str.length() ); BIO_flush( bio ); char *new_data; long bytes_written = BIO_get_mem_data( bio, &new_data ); string result( new_data, bytes_written ); BIO_free_all( bio ); return result; } string base64_decode( const string &str ){ BIO *bio, *base64_filter, *bio_out; char inbuf[512]; int inlen; base64_filter = BIO_new( BIO_f_base64() ); BIO_set_flags( base64_filter, BIO_FLAGS_BASE64_NO_NL ); bio = BIO_new_mem_buf( (void*)str.c_str(), str.length() ); bio = BIO_push( base64_filter, bio ); bio_out = BIO_new( BIO_s_mem() ); while( (inlen = BIO_read(bio, inbuf, 512)) > 0 ){ BIO_write( bio_out, inbuf, inlen ); } BIO_flush( bio_out ); char *new_data; long bytes_written = BIO_get_mem_data( bio_out, &new_data ); string result( new_data, bytes_written ); BIO_free_all( bio ); BIO_free_all( bio_out ); return result; }
const char encoding_table[] = { unsigned char decoding_table[256]; for (int i = 0; i < 256; i++) decoding_table[i] = for (int i = 0; i < 64; i++) decoding_table[(unsigned char)encoding_table[i]] = i; for (int i = 0; i < 256; i++) cout << "0x" << (int(decoding_table[i]) < 16 ? "0" : "") << hex << int(decoding_table[i]) << (i != 255 ? "," : "") << ((i+1) % 16 == 0 ? cin.ignore();
static const char encoding_table[] = { static const unsigned char decoding_table[256] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; char* base64_encode(const unsigned char *data, size_t input_length, size_t &output_length) { const int mod_table[] = { 0, 2, 1 }; output_length = 4 * ((input_length + 2) / 3); char *encoded_data = (char*)malloc(output_length); if (encoded_data == nullptr) return nullptr; for (int i = 0, j = 0; i < input_length;) { uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0; uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0; uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0; uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c; encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F]; encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F]; encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F]; encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F]; } for (int i = 0; i < mod_table[input_length % 3]; i++) encoded_data[output_length - 1 - i] = return encoded_data; }; unsigned char* base64_decode(const char *data, size_t input_length, size_t &output_length) { if (input_length % 4 != 0) return nullptr; output_length = input_length / 4 * 3; if (data[input_length - 1] == if (data[input_length - 2] == unsigned char* decoded_data = (unsigned char*)malloc(output_length); if (decoded_data == nullptr) return nullptr; for (int i = 0, j = 0; i < input_length;) { uint32_t sextet_a = data[i] == uint32_t sextet_b = data[i] == uint32_t sextet_c = data[i] == uint32_t sextet_d = data[i] == uint32_t triple = (sextet_a << 3 * 6) + (sextet_b << 2 * 6) + (sextet_c << 1 * 6) + (sextet_d << 0 * 6); if (j < output_length) decoded_data[j++] = (triple >> 2 * 8) & 0xFF; if (j < output_length) decoded_data[j++] = (triple >> 1 * 8) & 0xFF; if (j < output_length) decoded_data[j++] = (triple >> 0 * 8) & 0xFF; } return decoded_data; };
std::string base64_encode(const std::string &input) { BIO *p_bio_b64 = nullptr; BIO *p_bio_mem = nullptr; try { p_bio_b64 = BIO_new(BIO_f_base64()); if (!p_bio_b64) { throw std::runtime_error("BIO_new failed"); } BIO_set_flags(p_bio_b64, BIO_FLAGS_BASE64_NO_NL); p_bio_mem = BIO_new(BIO_s_mem()); if (!p_bio_mem) { throw std::runtime_error("BIO_new failed"); } BIO_push(p_bio_b64, p_bio_mem); if (BIO_write(p_bio_b64, input.c_str(), input.size()) <= 0) { throw std::runtime_error("BIO_write failed"); } if (BIO_flush(p_bio_b64) <= 0) { throw std::runtime_error("BIO_flush failed"); } char *p_encoded_data = nullptr; auto encoded_len = BIO_get_mem_data(p_bio_mem, &p_encoded_data); if (!p_encoded_data) { throw std::runtime_error("BIO_get_mem_data failed"); } std::string result(p_encoded_data, encoded_len); BIO_free_all(p_bio_b64); return result; } catch (...) { if (p_bio_b64) { BIO_free_all(p_bio_b64); } throw; } } std::string base64_decode(const std::string &input) { BIO *p_bio_mem = nullptr; BIO *p_bio_b64 = nullptr; try { p_bio_b64 = BIO_new(BIO_f_base64()); if (!p_bio_b64) { throw std::runtime_error("BIO_new failed"); } BIO_set_flags(p_bio_b64, BIO_FLAGS_BASE64_NO_NL); p_bio_mem = BIO_new_mem_buf((void*)input.c_str(), input.length()); if (!p_bio_mem) { throw std::runtime_error("BIO_new failed"); } BIO_push(p_bio_b64, p_bio_mem); std::vector<char> buf((input.size()*3/4)+1); std::string result; for (;;) { auto nread = BIO_read(p_bio_b64, buf.data(), buf.size()); if (nread < 0) { throw std::runtime_error("BIO_read failed"); } if (nread == 0) { break; } result.append(buf.data(), nread); } BIO_free_all(p_bio_b64); return result; } catch (...) { if (p_bio_b64) { BIO_free_all(p_bio_b64); } throw; } }
char *base64_encode(const unsigned char *data, size_t input_length, size_t *output_length, bool addLineBreaks) *output_length = 4 * ((input_length + 2) / 3); if (addLineBreaks) *output_length += *output_length / 38; char *encoded_data = malloc(*output_length); if (encoded_data == NULL) return NULL; UInt32 octet_a; UInt32 octet_b; UInt32 octet_c; UInt32 triple; int lineCount = 0; int sizeMod = size - (size % 3); for (; offset < sizeMod; ) { octet_a = data[offset++]; octet_b = data[offset++]; octet_c = data[offset++]; triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c; encoded_data[mBufferPos++] = encoding_table[(triple >> 3 * 6) & 0x3F]; encoded_data[mBufferPos++] = encoding_table[(triple >> 2 * 6) & 0x3F]; encoded_data[mBufferPos++] = encoding_table[(triple >> 1 * 6) & 0x3F]; encoded_data[mBufferPos++] = encoding_table[(triple >> 0 * 6) & 0x3F]; if (addLineBreaks) { if (++lineCount == 19) { encoded_data[mBufferPos++] = 13; encoded_data[mBufferPos++] = 10; lineCount = 0; } } } if (sizeMod < size) { octet_a = data[offset++]; octet_b = offset < size ? data[offset++] : (UInt32)0; octet_c = (UInt32)0; triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c; encoded_data[mBufferPos++] = encoding_table[(triple >> 3 * 6) & 0x3F]; encoded_data[mBufferPos++] = encoding_table[(triple >> 2 * 6) & 0x3F]; encoded_data[mBufferPos++] = encoding_table[(triple >> 1 * 6) & 0x3F]; encoded_data[mBufferPos++] = encoding_table[(triple >> 0 * 6) & 0x3F]; sizeMod = size % 3; encoded_data[mBufferPos - 1] = (byte) if (sizeMod == 1) encoded_data[mBufferPos - 2] = (byte) } }
(ptr)->next = (ptr); (ptr)->prev = (ptr); \ } while (0)
This signal() facility is a simplified interface to the more general sigaction(2) facility.
char *name = malloc(sizeof(char) + 256); printf("What is your name? "); scanf("%s", name); printf("Hello %s. Nice to meet you.\n", name);
int main(int argC, char *argV[]) { char *name = malloc(MAX_NAME_SZ); if (name == NULL) { printf("No memory\n"); return 1; } printf("What is your name? "); fgets(name, MAX_NAME_SZ, stdin); if ((strlen(name) > 0) && (name[strlen (name) - 1] == name[strlen (name) - 1] = printf("Hello %s. Nice to meet you.\n", name); free (name); return 0; }
int main (int argc, char const *argv[]) { char name[20]; scanf("%[^\n]s",name); printf("%s\n", name); return 0; }
void getText(char *message, char *variable, int size){ printf("\n %s: ", message); fgets(variable, sizeof(char) * size, stdin); sscanf(variable, "%[^\n]", variable); } char name[20]; getText("Your name", name, 20);
int main(void) { static char name[NAME_MAX + 1]; if(scanf("%" NAME_MAX_S "[^\n]", name) != 1) { fputs("io error or premature end of line\n", stderr); return 1; } printf("Hello %s. Nice to meet you.\n", name); }
int main(void) { static char name[NAME_MAX + 2]; if(!fgets(name, sizeof(name), stdin)) { fputs("io error\n", stderr); return 1; } printf("Hello %.*s. Nice to meet you.\n", strlen(name) - 1, name); }
char *name; scanf ("%m[^\n]s",&name); printf ("%s\n",name);
int main() { char string[100], c; int i; printf("Enter the string: "); scanf("%s", string); i = strlen(string); do { scanf("%c", &c); string[i++] = c; } while (c != string[i - 1] = 0; return 0; }
char* scan_line(char* buffer, int buffer_size); char* scan_line(char* buffer, int buffer_size) { char* p = buffer; int count = 0; do { char c; scanf("%c", &c); if (c == *p = 0; break; } *p++ = c; } while (count < buffer_size - 1); buffer[buffer_size - 1] = 0; return buffer; } int main() { char s[MAX_SCAN_LENGTH]; printf("Enter a string: "); scan_line(s, MAX_SCAN_LENGTH); printf("got: \"%s\"\n\n", s); return 0; }
int set_interface_attribs (int fd, int speed, int parity) { struct termios tty; memset (&tty, 0, sizeof tty); if (tcgetattr (fd, &tty) != 0) { error_message ("error %d from tcgetattr", errno); return -1; } cfsetospeed (&tty, speed); cfsetispeed (&tty, speed); tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8; tty.c_iflag &= ~IGNBRK; tty.c_lflag = 0; tty.c_oflag = 0; tty.c_cc[VMIN] = 0; tty.c_cc[VTIME] = 5; tty.c_iflag &= ~(IXON | IXOFF | IXANY); tty.c_cflag |= (CLOCAL | CREAD); tty.c_cflag &= ~(PARENB | PARODD); tty.c_cflag |= parity; tty.c_cflag &= ~CSTOPB; tty.c_cflag &= ~CRTSCTS; if (tcsetattr (fd, TCSANOW, &tty) != 0) { error_message ("error %d from tcsetattr", errno); return -1; } return 0; } void set_blocking (int fd, int should_block) { struct termios tty; memset (&tty, 0, sizeof tty); if (tcgetattr (fd, &tty) != 0) { error_message ("error %d from tggetattr", errno); return; } tty.c_cc[VMIN] = should_block ? 1 : 0; tty.c_cc[VTIME] = 5; if (tcsetattr (fd, TCSANOW, &tty) != 0) error_message ("error %d setting term attributes", errno); } ... char *portname = "/dev/ttyUSB1" ... int fd = open (portname, O_RDWR | O_NOCTTY | O_SYNC); if (fd < 0) { error_message ("error %d opening %s: %s", errno, portname, strerror (errno)); return; } set_interface_attribs (fd, B115200, 0); set_blocking (fd, 0); write (fd, "hello!\n", 7); usleep ((7 + 25) * 100); char buf [100]; int n = read (fd, buf, sizeof buf);
/* These are defined by the user (or the compiler) to specify the desired environment: ... _BSD_SOURCE ISO C, POSIX, and 4.3BSD things. _SVID_SOURCE ISO C, POSIX, and SVID things. ... */
int set_interface_attribs(int fd, int speed) { struct termios tty; if (tcgetattr(fd, &tty) < 0) { printf("Error from tcgetattr: %s\n", strerror(errno)); return -1; } cfsetospeed(&tty, (speed_t)speed); cfsetispeed(&tty, (speed_t)speed); tty.c_cflag |= (CLOCAL | CREAD); tty.c_cflag &= ~CSIZE; tty.c_cflag |= CS8; tty.c_cflag &= ~PARENB; tty.c_cflag &= ~CSTOPB; tty.c_cflag &= ~CRTSCTS; tty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON); tty.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN); tty.c_oflag &= ~OPOST; tty.c_cc[VMIN] = 1; tty.c_cc[VTIME] = 1; if (tcsetattr(fd, TCSANOW, &tty) != 0) { printf("Error from tcsetattr: %s\n", strerror(errno)); return -1; } return 0; } void set_mincount(int fd, int mcount) { struct termios tty; if (tcgetattr(fd, &tty) < 0) { printf("Error tcgetattr: %s\n", strerror(errno)); return; } tty.c_cc[VMIN] = mcount ? 1 : 0; tty.c_cc[VTIME] = 5; if (tcsetattr(fd, TCSANOW, &tty) < 0) printf("Error tcsetattr: %s\n", strerror(errno)); } int main() { char *portname = "/dev/ttyUSB0"; int fd; int wlen; fd = open(portname, O_RDWR | O_NOCTTY | O_SYNC); if (fd < 0) { printf("Error opening %s: %s\n", portname, strerror(errno)); return -1; } set_interface_attribs(fd, B115200); wlen = write(fd, "Hello!\n", 7); if (wlen != 7) { printf("Error from write: %d, %d\n", wlen, errno); } tcdrain(fd); do { unsigned char buf[80]; int rdlen; rdlen = read(fd, buf, sizeof(buf) - 1); if (rdlen > 0) { buf[rdlen] = 0; printf("Read %d: \"%s\"\n", rdlen, buf); unsigned char *p; printf("Read %d:", rdlen); for (p = buf; rdlen-- > 0; p++) printf(" 0x%x", *p); printf("\n"); } else if (rdlen < 0) { printf("Error from read: %d: %s\n", rdlen, strerror(errno)); } else { printf("Timeout from read\n"); } } while (1); }
char recv_buffer[3000]; recv(socket, recv_buffer, 3000, 0);
recv(socket, recv_buffer + idx, recv_buffer_size - idx, 0);
ssize_t size = recv(sockfd, buf, len, MSG_PEEK | MSG_TRUNC);
int main( int argc, char *argv[] ) { FILE *fp; char path[1035]; fp = popen("/bin/ls /etc/", "r"); if (fp == NULL) { printf("Failed to run command\n" ); exit(1); } while (fgets(path, sizeof(path)-1, fp) != NULL) { printf("%s", path); } pclose(fp); return 0; }
..reaching the } that terminates the main function returns a value of 0.
int sum(int a,int b) { return (a + b); } int main() { int a=10; int b=5; int ans; ans=sum(a,b); printf("sum is %d",ans); }
int fac_times (int n, int acc) { if (n == 0) return acc; else return fac_times(n - 1, acc * n); } int factorial (int n) { return fac_times (n, 1); } int factorial (int n) { if (n == 0) return 1; else return n * factorial(n - 1); }
int fac_times (int n, int acc) { if (n == 0) return acc; else return fac_times(n - 1, acc * n); }
int fac_times (int n, int acc) { label: if (n == 0) return acc; acc *= n--; goto label; }
int fac_times (int n, int acc = 1) { if (n == 0) return acc; else return fac_times(n - 1, acc * n); }
int fac_times (int n) { int acc = 1; while (n > 0) { acc *= n; n -= 1; } return acc; }
int factorial (int n) { if (n == 0) return 1; else return n * factorial(n - 1); }
[Stack_f(5): return 5 * [Stack_f(4): 4 * [Stack_f(3): 3 * ... [1[1]]
[Stack f(4, 5): Stack f(3, 20): [Stack f(2,60): [Stack f(1, 120): 120]]]]
type regular(n) base_case computation return (result of computation) combined with (regular(n towards base case))
type tail(n): type helper(n, accumulator): if n == base case return accumulator computation accumulator = computation combined with accumulator return helper(n towards base case, accumulator) helper(n, base case)
long f (long n) { if (n == 0) return 0; return f(n-1) + 1; }
void tail(int i) { if(i<=0) return; else { system.out.print(i+""); tail(i-1); } }
void tail(int i) { blockToJump:{ if(i<=0) return; else { system.out.print(i+""); i=i-1; continue blockToJump; } } }
if (__builtin_expect(x, 0)) { foo(); ... } else { bar(); ... }
cmp $x, 0 jne _foo _bar: call bar ... jmp after_if _foo: call foo ... after_if:
int main() { int i = !time(NULL); if (i) puts("a"); return 0; }
0000000000000000 <main>: 0: 48 83 ec 08 sub $0x8,%rsp 4: 31 ff xor %edi,%edi 6: e8 00 00 00 00 callq b <main+0xb> 7: R_X86_64_PC32 time-0x4 b: 48 85 c0 test %rax,%rax e: 75 0a jne 1a <main+0x1a> 10: bf 00 00 00 00 mov $0x0,%edi 11: R_X86_64_32 .rodata.str1.1 15: e8 00 00 00 00 callq 1a <main+0x1a> 16: R_X86_64_PC32 puts-0x4 1a: 31 c0 xor %eax,%eax 1c: 48 83 c4 08 add $0x8,%rsp 20: c3 retq
0000000000000000 <main>: 0: 48 83 ec 08 sub $0x8,%rsp 4: 31 ff xor %edi,%edi 6: e8 00 00 00 00 callq b <main+0xb> 7: R_X86_64_PC32 time-0x4 b: 48 85 c0 test %rax,%rax e: 74 07 je 17 <main+0x17> 10: 31 c0 xor %eax,%eax 12: 48 83 c4 08 add $0x8,%rsp 16: c3 retq 17: bf 00 00 00 00 mov $0x0,%edi 18: R_X86_64_32 .rodata.str1.1 1c: e8 00 00 00 00 callq 21 <main+0x21> 1d: R_X86_64_PC32 puts-0x4 21: eb ed jmp 10 <main+0x10>
int i = !time(NULL); if (i) goto puts; ret: return 0; puts: puts("a"); goto ret;
p = 0; if (p) { ... } p = (void*)-1; if ((void*)(p) != (void*)(-1)) { ... }
int* wellKnownIoPort = CREATE_HW_ADDR(0x00000000); printf("IoPortIs" DEREFERENCE_HW_ADDR(wellKnownIoPort));
unsigned x = 0x3f800000, y = 0x40000000; return _float_add(x, y);
void main() { int myInt=10; printf("%d\n", myInt); }
.file "test.c" .section .rodata.str1.1,"aMS",@progbits,1 .LC0: .string "%d\n" .section .text.unlikely,"ax",@progbits .LCOLDB1: .section .text.startup,"ax",@progbits .LHOTB1: .p2align 4,,15 .globl main .type main, @function main: .LFB24: .cfi_startproc movl $10, %edx movl $.LC0, %esi movl $1, %edi xorl %eax, %eax jmp __printf_chk .cfi_endproc .LFE24: .size main, .-main .section .text.unlikely .LCOLDE1: .section .text.startup .LHOTE1: .ident "GCC: (Ubuntu 4.9.1-16ubuntu6) 4.9.1" .section .note.GNU-stack,"",@progbits
using namespace std; class MyClass { int myVar; public: void set_myVar(int); int get_myVar(void); }; void MyClass::set_myVar(int val) { myVar = val; } int MyClass::get_myVar(void) { return myVar; } int main() { MyClass myClass; myClass.set_myVar(10); cout << myClass.get_myVar() << endl; return 0; }
.file "test.cpp" .section .text.unlikely,"ax",@progbits .align 2 .LCOLDB0: .text .LHOTB0: .align 2 .p2align 4,,15 .globl _ZN7MyClass9set_myVarEi .type _ZN7MyClass9set_myVarEi, @function _ZN7MyClass9set_myVarEi: .LFB1047: .cfi_startproc movl %esi, (%rdi) ret .cfi_endproc .LFE1047: .size _ZN7MyClass9set_myVarEi, .-_ZN7MyClass9set_myVarEi .section .text.unlikely .LCOLDE0: .text .LHOTE0: .section .text.unlikely .align 2 .LCOLDB1: .text .LHOTB1: .align 2 .p2align 4,,15 .globl _ZN7MyClass9get_myVarEv .type _ZN7MyClass9get_myVarEv, @function _ZN7MyClass9get_myVarEv: .LFB1048: .cfi_startproc movl (%rdi), %eax ret .cfi_endproc .LFE1048: .size _ZN7MyClass9get_myVarEv, .-_ZN7MyClass9get_myVarEv .section .text.unlikely .LCOLDE1: .text .LHOTE1: .section .text.unlikely .LCOLDB2: .section .text.startup,"ax",@progbits .LHOTB2: .p2align 4,,15 .globl main .type main, @function main: .LFB1049: .cfi_startproc subq $8, %rsp .cfi_def_cfa_offset 16 movl $10, %esi movl $_ZSt4cout, %edi call _ZNSolsEi movq %rax, %rdi call _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ xorl %eax, %eax addq $8, %rsp .cfi_def_cfa_offset 8 ret .cfi_endproc .LFE1049: .size main, .-main .section .text.unlikely .LCOLDE2: .section .text.startup .LHOTE2: .section .text.unlikely .LCOLDB3: .section .text.startup .LHOTB3: .p2align 4,,15 .type _GLOBAL__sub_I__ZN7MyClass9set_myVarEi, @function _GLOBAL__sub_I__ZN7MyClass9set_myVarEi: .LFB1056: .cfi_startproc subq $8, %rsp .cfi_def_cfa_offset 16 movl $_ZStL8__ioinit, %edi call _ZNSt8ios_base4InitC1Ev movl $__dso_handle, %edx movl $_ZStL8__ioinit, %esi movl $_ZNSt8ios_base4InitD1Ev, %edi addq $8, %rsp .cfi_def_cfa_offset 8 jmp __cxa_atexit .cfi_endproc .LFE1056: .size _GLOBAL__sub_I__ZN7MyClass9set_myVarEi, .-_GLOBAL__sub_I__ZN7MyClass9set_myVarEi .section .text.unlikely .LCOLDE3: .section .text.startup .LHOTE3: .section .init_array,"aw" .align 8 .quad _GLOBAL__sub_I__ZN7MyClass9set_myVarEi .local _ZStL8__ioinit .comm _ZStL8__ioinit,1,1 .hidden __dso_handle .ident "GCC: (Ubuntu 4.9.1-16ubuntu6) 4.9.1" .section .note.GNU-stack,"",@progbits
struct timeval tval_before, tval_after, tval_result; gettimeofday(&tval_before, NULL); sleep(1); gettimeofday(&tval_after, NULL); timersub(&tval_after, &tval_before, &tval_result); printf("Time elapsed: %ld.%06ld\n", (long int)tval_result.tv_sec, (long int)tval_result.tv_usec);
clock_t uptime = clock() / (CLOCKS_PER_SEC / 1000);
int64_t timespecDiff(struct timespec *timeA_p, struct timespec *timeB_p) { return ((timeA_p->tv_sec * 1000000000) + timeA_p->tv_nsec) - ((timeB_p->tv_sec * 1000000000) + timeB_p->tv_nsec); } int main(int argc, char **argv) { struct timespec start, end; clock_gettime(CLOCK_MONOTONIC, &start); clock_gettime(CLOCK_MONOTONIC, &end); uint64_t timeElapsed = timespecDiff(&end, &start); }
LARGE_INTEGER tcounter; LARGE_INTEGER freq; if (QueryPerformanceFrequency (&tcounter) != 0) freq = tcounter.QuadPart;
LARGE_INTEGER tcounter; LARGE_INTEGER tick_value; if (QueryPerformanceCounter (&tcounter) != 0) tick_value = tcounter.QuadPart;
LARGE_INTEGER usecs = (tick_value - prev_tick_value) / (freq / 1000000);
static uint64_t freq_num = 0; static uint64_t freq_denom = 0; void init_clock_frequency () { mach_timebase_info_data_t tb; if (mach_timebase_info (&tb) == KERN_SUCCESS && tb.denom != 0) { freq_num = (uint64_t) tb.numer; freq_denom = (uint64_t) tb.denom; } }
uint64_t value_diff = tick_value - prev_tick_value; value_diff /= 1000; value_diff *= freq_num; value_diff /= freq_denom;
uint64_t get_posix_clock_time () { struct timespec ts; if (clock_gettime (CLOCK_MONOTONIC, &ts) == 0) return (uint64_t) (ts.tv_sec * 1000000 + ts.tv_nsec / 1000); else return 0; }
uint64_t prev_time_value, time_value; uint64_t time_diff; prev_time_value = get_posix_clock_time (); time_value = get_posix_clock_time (); time_diff = time_value - prev_time_value;
uint64_t get_gtod_clock_time () { struct timeval tv; if (gettimeofday (&tv, NULL) == 0) return (uint64_t) (tv.tv_sec * 1000000 + tv.tv_usec); else return 0; }
void time_measure_example () { hrtime_t prev_time_value, time_value; hrtime_t time_diff; prev_time_value = gethrtime (); time_value = gethrtime (); time_diff = time_value - prev_time_value; }
void time_measure_example () { bigtime_t prev_time_value, time_value; bigtime_t time_diff; prev_time_value = system_time (); time_value = system_time (); time_diff = time_value - prev_time_value; }
QWORD tcounter; unit64_t time_low; unit64_t time_high; unit64_t timestamp; if (DosTmrQueryTime (&tcounter) == NO_ERROR) { time_low = (unit64_t) tcounter.ulLo; time_high = (unit64_t) tcounter.ulHi; timestamp = (time_high << 32) | time_low; }
uint64_t usecs = (prev_timestamp - timestamp) / (freq / 1000000);
static long get_nanos(void) { struct timespec ts; timespec_get(&ts, TIME_UTC); return (long)ts.tv_sec * 1000000000L + ts.tv_nsec; } int main(void) { long nanos; long last_nanos; long start; nanos = get_nanos(); last_nanos = nanos; start = nanos; while (1) { nanos = get_nanos(); if (nanos - last_nanos > 100000000L) { printf("current nanos: %ld\n", nanos - start); last_nanos = nanos; } } return EXIT_SUCCESS; }
int timespec_get (struct timespec *ts, int base) { switch (base) { case TIME_UTC: if (__clock_gettime (CLOCK_REALTIME, ts) < 0) return 0; break; default: return 0; } return base; }
long currentTimeMillis() { struct timeval time; gettimeofday(&time, NULL); return time.tv_sec * 1000 + time.tv_usec / 1000; } int main() { printf("%ld\n", currentTimeMillis()); sleep(1); printf("%ld\n", currentTimeMillis()); return 0; }
SYSTEMTIME t; GetLocalTime(&t); swprintf_s(buff, L"[%02d:%02d:%02d:%d]\t", t.wHour, t.wMinute, t.wSecond, t.wMilliseconds);
HEADERS = program.h headers.h default: program program.o: program.c $(HEADERS) gcc -c program.c -o program.o program: program.o gcc program.o -o program clean: -rm -f program.o -rm -f program
HEADERS = program.h headers.h OBJECTS = program.o default: program %.o: %.c $(HEADERS) gcc -c $< -o $@ program: $(OBJECTS) gcc $(OBJECTS) -o $@ clean: -rm -f $(OBJECTS) -rm -f program
TARGET = prog LIBS = -lm CC = gcc CFLAGS = -g -Wall .PHONY: default all clean default: $(TARGET) all: default OBJECTS = $(patsubst %.c, %.o, $(wildcard *.c)) HEADERS = $(wildcard *.h) %.o: %.c $(HEADERS) $(CC) $(CFLAGS) -c $< -o $@ .PRECIOUS: $(TARGET) $(OBJECTS) $(TARGET): $(OBJECTS) $(CC) $(OBJECTS) -Wall $(LIBS) -o $@ clean: -rm -f *.o -rm -f $(TARGET)
all : test test : test.o gcc -o test test.o test.o : test.c gcc -c test.c clean : rm test *.o
const unsigned arraySize = 32768; int data[arraySize]; long long sum = 0;
for (int i = 0; i < 100000; ++i) for (int c = 0; c < arraySize; ++c) if (data[c] >= 128) sum += data[c];
for (int c = 0; c < arraySize; ++c) if (data[c] >= 128) for (int i = 0; i < 100000; ++i) sum += data[c];
for (int c = 0; c < arraySize; ++c) if (data[c] >= 128) sum += 100000 * data[c];
for (int c = 0; c < arraySize; ++c) if (data[c] >= 128) for (int i = 0; i < 100000; ++i) sum += data[c];
for (int c = 0; c < arraySize; ++c) if (data[c] >= 128) sum += 100000 * data[c];
for (int c = 0; c < arraySize; ++c) if (data[c] >= 128) sum += 100000LL * data[c];
for (int c = 0; c < arraySize; ++c) if (condition(data[c])) for (int i = 0; i < 100000; ++i) sum += data[c];
for (int i = 0; i < 100000; ++i) for (int c = 0; c < arraySize; ++c) if (condition(data[c])) sum += data[c];
float const step = 1e-15; float const init = 1; long int const count = 1000000000; float result1 = init; for( int i = 0; i < count; ++i ) result1 += step; float result2 = init; result2 += step * count; cout << (result1 - result2);
for(int i = low; i <= high; ++i) { res = runalg(i); if (res > highestres) { highestres = res; } }
int main() { int i; for (i = 10; i < 20; i++) { printf("i: %d\n", i); } return 0; }
int i; for(i = low; i <= high; ++i) { res = runalg(i); if (res > highestres) { highestres = res; } }
QMAKE_CFLAGS_DEBUG = \ -std=gnu99 QMAKE_CFLAGS_RELEASE = \ -std=gnu99
for(int i = low; i <= high; ++i) { res = runalg(i); if (res > highestres) { highestres = res; } }
typedef struct Cell { int isParent; Cell child; } Cell;
typedef struct Cell { bool isParent; struct Cell* child; } Cell;
typedef struct Cell { int cellSeq; struct Cell* next; /* } tCell; int main(void) { int i; tCell *curr; tCell *first; tCell *last; first = malloc (sizeof (tCell)); last = first; first->cellSeq = 100; first->next = NULL; for (i = 0; i < 20; i++) { curr = malloc (sizeof (tCell)); curr->cellSeq = last->cellSeq - 1; curr->next = NULL; last->next = curr; last = curr; } curr = first; while (curr != NULL) { printf ("Sequence = %d\n", curr->cellSeq); curr = curr->next; } return 0; }
struct Cell { bool isParent; struct Cell* child; }; struct Cell; typedef struct Cell Cell;
typedef struct Cell Cell; struct Cell { int isParent; Cell *child; }; struct Cell { int isParent; struct Cell *child; }; Cell newCell;
typedef struct{ bool isParent; struct Cell* child;} Cell; typedef struct{ bool isParent; struct Cell* child; } Cell; struct Cell { bool isParent; struct Cell* child; }; typedef struct Cell Cell;
typedef struct Node Node; struct Node { int data; Node *nextNode; }; Node *node;
switch (i) { case 0: NSLog(@"wtf"); int j = 1; break; }
if (1) int i; else int i; for (int answer = 1; answer <= 42; answer ++) int i; while (1) int i; do int i; while (1);
struct bts_action { u16 type; u16 size; u8 data[0]; } __attribute__ ((packed));
struct bts_action *var = kmalloc(sizeof(*var) + extra, GFP_KERNEL);
struct bts_action { u16 type; u16 size; u8 data[]; } __attribute__ ((packed));
struct something { char data[]; } struct something *var = malloc(sizeof(*var) + extra);
struct s { int n; double d[]; }; int m = ; struct s *p = malloc(sizeof (struct s) + sizeof (double [m]));
struct bts_action *bts = malloc(sizeof(struct bts_action) + sizeof(char)*100);
struct bts_action{ u16 type; u16 size; u8 data[100]; };
size_t size = 1024; struct bts_action* action = (struct bts_action*)malloc(sizeof(struct bts_action) + size);
struct example_large_s { u32 first; u32 data; .... u64 *second; .... };
ASSERT (offsetof (example_large_s, first) == 0); ASSERT (offsetof (example_large_s, second) == CACHE_LINE_BYTES);
assert (offsetof (one_struct, <name_of_first_member>) == 0); assert (offsetof (one_struct, <name_of_second_member>) == CACHE_LINE_BYTES); assert (offsetof (another_struct, <name_of_first_member>) == 0); assert (offsetof (another_struct, <name_of_second_member>) == CACHE_LINE_BYTES);
struct example_large_s { CACHE_LINE_ALIGN_MARK (cacheline0); u32 first; u32 data; .... CACHE_LINE_ALIGN_MARK (cacheline1); u64 *second; .... };
assert (offsetof (one_struct, cacheline0) == 0); assert (offsetof (one_struct, cacheline1) == CACHE_LINE_BYTES); assert (offsetof (another_struct, cacheline0) == 0); assert (offsetof (another_struct, cacheline1) == CACHE_LINE_BYTES);
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
int iArr[10]; double dArr[30]; long lArr[50]; ... qsort(iArr, sizeof iArr/sizeof iArr[0], sizeof iArr[0], compareInt); qsort(dArr, sizeof dArr/sizeof dArr[0], sizeof dArr[0], compareDouble); qsort(lArr, sizeof lArr/sizeof lArr[0], sizeof lArr[0], compareLong);
int compareInt(const void *lhs, const void *rhs) { const int *x = lhs; const int *y = rhs; if (*x > *y) return 1; if (*x == *y) return 0; return -1; }
qsort(dArr, sizeof dArr/sizeof dArr[0], sizeof dArr[0], compareInt);
char * data = "blah"; send(data, strlen(data)); POINT p; p.x = 1; p.y = 2; send(&p, sizeof(POINT));
void *PrintHello(void *threadid) { long tid; tid = (long)threadid; printf("Hello World! It pthread_exit(NULL); } int main (int argc, char *argv[]) { pthread_t threads[NUM_THREADS]; int rc; long t; for(t=0; t<NUM_THREADS; t++){ rc = pthread_create(&threads[t], NULL, PrintHello, (void *)t); if (rc){ printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); } } /* Last thing that main() should do */ pthread_exit(NULL); }
float a = 2.0f, b = 10.0f, c = 20.0f, d = 3.14159f, e; e = (a - b) / d + c;
subset Nonnegative::Float of Float where { $_ >= 0 };
int main () { complex double a = 1.0 + 1.0 * I; double f = sqrt(a); return 0; }
void main() { if("a" == "a") printf("Yes, equal"); else printf("No, not equal"); }
if(0x00403064 == 0x002D316A) { printf("Yes, equal"); }
int a1[] = {1, 2, 3}; int a2[] = {3, 4, 5}; a1 == a2
void main() { if("a" == "a") printf("Yes, equal"); else printf("No, not equal"); }
void main() { if("a" == "a") { printf("Yes, equal"); } else { printf("No, not equal"); } }
int main() { int i; for (i = 0; i < 10; i++) { char c = (i % 95) + 32; printf("%i: %c\n", i, c); char *s; s = "some string"; puts(s); } return 0; }
int foo = 0; <code that uses foo> int bar = 1; <code that uses bar> <code that uses foo>
{ int foo = 0; <code that uses foo> } int bar = 1; <code that uses bar> >>> First compilation error here <code that uses foo>
{ int foo = 0; <code that uses foo> } <code that uses foo> int bar = 1; <code that uses bar>
int i; for(i = 0; i < 8; ++i){ ... } <some stuff> for(i = 3; i < 32; ++i){ ... }
struct node { int data; struct node *link; }; void reverse() { struct node *p = first, *q = NULL, *r; while (p != NULL) { r = q; q = p; p = p->link; q->link = r; } q = first; }
typedef struct Node { char data; struct Node* next; } Node; void print_list(Node* root) { while (root) { printf("%c ", root->data); root = root->next; } printf("\n"); } Node* reverse(Node* root) { Node* new_root = 0; while (root) { Node* next = root->next; root->next = new_root; new_root = root; root = next; } return new_root; } int main() { Node d = { Node c = { Node b = { Node a = { Node* root = &a; print_list(root); root = reverse(root); print_list(root); return 0; }
struct node { int data; struct node *link; }; static struct node *first = NULL; void reverse() { struct node *curNode = first, *nxtNode; first = NULL; while (curNode != NULL) { nxtNode = curNode->link; curNode->link = first; first = curNode; curNode = nxtNode; } } static void dumpNodes() { struct node *curNode = first; printf ("==========\n"); while (curNode != NULL) { printf ("%d\n", curNode->data); curNode = curNode->link; } } int main (void) { int i; struct node *newnode; for (i = 0; i < 5; i++) { newnode = malloc (sizeof (struct node)); newnode->data = i; newnode->link = first; first = newnode; } dumpNodes(); reverse(); dumpNodes(); printf ("==========\n"); return 0; }
========== 4 3 2 1 0 ========== 0 1 2 3 4 ==========
typedef struct Node { struct Node *next; int data; } Node; Node * reverse(Node *cur) { Node *prev = NULL; while (cur) { Node *temp = cur; cur = cur->next; temp->next = prev; prev = temp; } return prev; }
typedef struct node Node; struct node { int data; Node *next; }; void spec_reverse(); Node *reverse(Node *head); int main() { spec_reverse(); return 0; } void print(Node *head) { while (head) { printf("[%d]->", head->data); head = head->next; } printf("NULL\n"); } void spec_reverse() { Node node2 = {2, NULL}; Node node1 = {1, &node2}; Node node0 = {0, &node1}; Node *head = &node0; print(head); head = reverse(head); print(head); assert(head == &node2); assert(head->next == &node1); assert(head->next->next == &node0); printf("Passed!"); } // // // // Node *reverse(Node *head) { Node *prev = NULL; Node *next; while (head) { next = head->next; head->next = prev; prev = head; head = next; } return prev; }
typedef struct node* link; struct node{ int item; link next; }; /* you send the existing list to reverse() and returns the reversed one */ link reverse(link x){ link t, y = x, r = NULL; while(y != NULL){ t = y->next; y-> next = r; r = y; y = t; } return r; }
Node* reverse (Node *root, Node *end) { Node *next = root->next; root->next = end; return (next ? reverse(next, root) : root); } root = reverse(root, NULL);
c = a ^ b ^ c ^ (a=b) ^ (b=c) b = a ^ b ^ c ^ (c=a) ^ (a=b) a = a ^ b ^ c ^ (b=c) ^ (c=a)
typedef struct List { int info; struct List *next; }List; List* reverseList(List *head) { p=head; q=p->next; p->next=NULL; while(q) { q = (List*) ((int)p ^ (int)q ^ (int)q->next ^ (int)(q->next=p) ^ (int)(p=q)); } head = p; return head; }
Node* reverselist( ) { Node *first = NULL; Node *second = head; Node *track = head; while(track!=NULL) { track = track->next; second->next = first; first = second; second = track; } track = first; return track;
Node *pop (Node **root) { Node *popped = *root; if (*root) { *root = (*root)->next; } return (popped); } void push (Node **root, Node *new_node) { new_node->next = *root; *root = new_node; } Node *reverse (Node *root) { Node *new_root = NULL; Node *next; while ((next = pop(&root))) { push (&new_root, next); } return (new_root); }
public void reverse(Node head) { Node curr = head, prev = null; while (head.next != null) { head = head.next; curr.next = prev; prev = curr; curr = head; } head.next = prev; }
struct NODE { struct NODE *next; int value; }; typedef struct NODE node; void reverse(node **head); void add_end(node **head,int val); void alloc(node **p); void print_all(node *head); void main() { node *head; clrscr(); head = NULL; add_end( &head, 1 ); add_end( &head, 2 ); add_end( &head, 3 ); print_all( head ); reverse( &head ); print_all( head ); getch(); } void alloc(node **p) { node *temp; temp = (node *) malloc( sizeof(node *) ); temp->next = NULL; *p = temp; } void add_end(node **head,int val) { node *temp,*new_node; alloc(&new_node); new_node->value = val; if( *head == NULL ) { *head = new_node; return; } for(temp = *head;temp->next!=NULL;temp=temp->next); temp->next = new_node; } void print_all(node *head) { node *temp; int index=0; printf ("\n\n"); if (head == NULL) { printf (" List is Empty \n"); return; } for (temp=head; temp != NULL; temp=temp->next,index++) printf (" %d ==> %d \n",index,temp->value); } void reverse(node **head) { node *next,*new_head; new_head=NULL; while(*head != NULL) { next = (*head)->next; (*head)->next = new_head; new_head = (*head); (*head) = next; } (*head)=new_head; }
tydef struct node { int info; struct node *link; } *start; void main() { rev(); } void rev() { struct node *p = start, *q = NULL, *r; while (p != NULL) { r = q; q = p; p = p->link; q->link = r; } start = q; }
typedef struct node { int num; struct node* next; }node; void reverse(node* head) { node* ptr; if(!head || !head->next || !head->next->next) return; ptr = head->next->next; head->next->next = NULL; while(ptr) { head->next = (unsigned)(ptr =\ (unsigned)ptr ^ (unsigned)(head->next =\ (unsigned)head->next ^ (unsigned)ptr)) ^ (unsigned)head->next; head->next->next = (unsigned)(ptr =\ (unsigned)ptr ^ (unsigned)(head->next->next =\ (unsigned)head->next->next ^ (unsigned)ptr)) ^ (unsigned)head->next->next; } } void add_end(node* ptr, int n) { while(ptr->next) ptr = ptr->next; ptr->next = malloc(sizeof(node)); ptr->next->num = n; ptr->next->next = NULL; } void print(node* ptr) { while(ptr = ptr->next) printf("%d ", ptr->num); putchar( } void erase(node* ptr) { node *end; while(ptr->next) { if(ptr->next->next) ptr = ptr->next; else { end = ptr->next; ptr->next = NULL; free(end); } } } void main() { int i, n = 5; node* dummy_head; dummy_head->next = NULL; for(i = 1; i <= n ; ++i) add_end(dummy_head, i); print(dummy_head); reverse(dummy_head); print(dummy_head); erase(dummy_head); }
struct node { int data; struct node* next; }; struct node* head = NULL; void printList(char* msg) { struct node* current = head; printf("\n%s\n", msg); while (current != NULL) { printf("%d ", current->data); current = current->next; } } void insert_beginning(int data) { struct node* newNode = (struct node*) malloc(sizeof(struct node)); newNode->data = data; newNode->next = NULL; if (head == NULL) { head = newNode; } else { newNode->next = head; head = newNode; } } void insert_at(int data, int location) { struct node* newNode = (struct node*) malloc(sizeof(struct node)); newNode->data = data; newNode->next = NULL; if (head == NULL) { head = newNode; } else { struct node* currentNode = head; int index = 0; while (currentNode != NULL && index < (location - 1)) { currentNode = currentNode->next; index++; } if (currentNode != NULL) { if (location == 0) { newNode->next = currentNode; head = newNode; } else { newNode->next = currentNode->next; currentNode->next = newNode; } } } } int delete_from(int location) { int retValue = -1; if (location < 0 || head == NULL) { printf("\nList is empty or invalid index"); return -1; } else { struct node* currentNode = head; int index = 0; while (currentNode != NULL && index < (location - 1)) { currentNode = currentNode->next; index++; } if (currentNode != NULL) { if (location == 0) { if (currentNode->next == NULL) { retValue = currentNode->data; free(currentNode); head = NULL; } else { struct node* nextNode = currentNode->next; head = nextNode; retValue = currentNode->data; free(currentNode); } } else { struct node* nextNode = currentNode->next; currentNode->next = nextNode->next; if (nextNode != NULL ) { retValue = nextNode->data; free(nextNode); } } } else { printf("\nInvalid index"); return -1; } } return retValue; } void another_reverse() { if (head == NULL) { printf("\nList is empty\n"); return; } else { struct node* tailNode = head; int index = 0, counter = 0; while (tailNode->next != NULL) { tailNode = tailNode->next; index++; } while (counter != index) { int data = delete_from(index); insert_at(data, counter); counter++; } } } int main(int argc, char** argv) { insert_beginning(4); insert_beginning(3); insert_beginning(2); insert_beginning(1); insert_beginning(0); /* insert_at(5, 0); insert_at(4, 1); insert_at(3, 2); insert_at(1, 1);*/ printList("Original List\0"); another_reverse(); printList("Reversed List\0"); /* delete_from(2); delete_from(2);*/ return 0; }
using 2-pointers....bit large but simple and efficient void reverse() { int n=0; node *temp,*temp1; temp=strptr; while(temp->next!=NULL) { n++; temp=temp->next; } int i=n/2; temp=strptr; for(int j=1;j<=(n-i+1);j++) temp=temp->next; while(i>0) { temp1=strptr; for(int j=1;j<=i;j++) temp1=temp1->next; int t; t=temp1->info; temp1->info=temp->info; temp->info=t; i--; temp=temp->next; } }
struct node { int data; struct node *link; }; struct node *first=NULL,*last=NULL,*next,*pre,*cur,*temp; void create() { cur=(struct node*) malloc(sizeof(struct node)); printf("enter first data to insert"); scanf("%d",&cur->data); first=last=cur; first->link=NULL; } void insert() { int pos,c; cur=(struct node*) malloc(sizeof(struct node)); printf("enter data to insert and also its position"); scanf("%d%d",&cur->data,&pos); if(pos==1) { cur->link=first; first=cur; } else { c=1; next=first; while(c<pos) { pre=next; next=next->link; c++; } if(pre==NULL) { printf("Invalid position"); } else { cur->link=pre->link; pre->link=cur; } } } void display() { cur=first; while(cur!=NULL) { printf("data= %d\t address= %u\n",cur->data,cur); cur=cur->link; } printf("\n"); } void rev() { pre=NULL; cur=first; while(cur!=NULL) { next=cur->link; cur->link=pre; pre=cur; cur=next; } first=pre; } void main() { int choice; clrscr(); do { printf("Options are: -\n1:Create\n2:Insert\n3:Display\n4:Reverse\n0:Exit\n"); printf("Enter your choice: - "); scanf("%d",&choice); switch(choice) { case 1: create(); break; case 2: insert(); break; case 3: display(); break; case 4: rev(); break; case 0: exit(0); default: printf("wrong choice"); } } while(1); }
void reverse(ListElem *&head) { ListElem* temp; ListElem* elem = head->next(); ListElem* prev = head; head->next(0); while(temp = elem->next()) { elem->next(prev); prev = elem; elem = temp; } elem->next(prev); head = elem; }
class ListElem{ public: ListElem(int val): _val(val){} ListElem *next() const { return _next; } void next(ListElem *elem) { _next = elem; } void val(int val){ _val = val; } int val() const { return _val;} private: ListElem *_next; int _val; };
package com.adnan.linkedlist; /** * User : Adnan * Email : sendtoadnan@gmail.com * Date : 9/21/13 * Time : 12:02 PM */ public class Node { public Node(int value, Node node){ this.value = value; this.node = node; } private int value; private Node node; public int getValue() { return value; } public Node getNode() { return node; } public void setNode(Node node){ this.node = node; } }
package com.adnan.linkedlist; /** * User : Adnan * Email : sendtoadnan@gmail.com * Date : 9/21/13 * Time : 11:54 AM */ public class SinglyLinkedListReversal { private static final SinglyLinkedListReversal service = new SinglyLinkedListReversal(); public static SinglyLinkedListReversal getService(){ return service; } public Node reverse(Node start){ if (hasOnlyNodeInLinkedList(start)){ return start; } Node firstNode, secondNode, thirdNode; firstNode = start; secondNode = firstNode.getNode(); while (secondNode != null ){ thirdNode = secondNode.getNode(); secondNode.setNode(firstNode); firstNode = secondNode; secondNode = thirdNode; } start.setNode(null); return firstNode; } private boolean hasOnlyNodeInLinkedList(Node start) { return start.getNode() == null; } }
package com.adnan.linkedlist; import org.testng.annotations.Test; import static org.testng.AssertJUnit.assertTrue; /** * User : Adnan * Email : sendtoadnan@gmail.com * Date : 9/21/13 * Time : 12:11 PM */ public class SinglyLinkedListReversalTest { private SinglyLinkedListReversal reversalService = SinglyLinkedListReversal.getService(); @Test public void test_reverseSingleElement() throws Exception { Node node = new Node(1, null); reversalService.reverse(node); assertTrue(node.getNode() == null); assertTrue(node.getValue() == 1); } @Test public void test_reverseThreeElement() throws Exception { Node node3 = new Node(3, null); Node node2 = new Node(2, node3); Node start = new Node(1, node2); start = reversalService.reverse(start); Node test = start; for (int i = 3; i >=1 ; i -- ){ assertTrue(test.getValue() == i); test = test.getNode(); } } @Test public void test_reverseFourElement() throws Exception { Node node4 = new Node(4, null); Node node3 = new Node(3, node4); Node node2 = new Node(2, node3); Node start = new Node(1, node2); start = reversalService.reverse(start); Node test = start; for (int i = 4; i >=1 ; i -- ){ assertTrue(test.getValue() == i); test = test.getNode(); } } @Test public void test_reverse10Element() throws Exception { Node node10 = new Node(10, null); Node node9 = new Node(9, node10); Node node8 = new Node(8, node9); Node node7 = new Node(7, node8); Node node6 = new Node(6, node7); Node node5 = new Node(5, node6); Node node4 = new Node(4, node5); Node node3 = new Node(3, node4); Node node2 = new Node(2, node3); Node start = new Node(1, node2); start = reversalService.reverse(start); Node test = start; for (int i = 10; i >=1 ; i -- ){ assertTrue(test.getValue() == i); test = test.getNode(); } } @Test public void test_reverseTwoElement() throws Exception { Node node2 = new Node(2, null); Node start = new Node(1, node2); start = reversalService.reverse(start); Node test = start; for (int i = 2; i >=1 ; i -- ){ assertTrue(test.getValue() == i); test = test.getNode(); } } }
typedef struct list { int key; char value; struct list* next; } list; void print(list*); void add(list**, int, char); void reverse(list**); void deleteList(list*); int main(void) { list* head = NULL; int i=0; while ( i++ < 26 ) add(&head, i, i+ printf("Before reverse: \n"); print(head); printf("After reverse: \n"); reverse(&head); print(head); deleteList(head); } void deleteList(list* l) { list* t = l; while ( t != NULL ) { list* tmp = t; t = t->next; free(tmp); } } void print(list* l) { list* t = l; while ( t != NULL) { printf("%d:%c\n", t->key, t->value); t = t->next; } } void reverse(list** head) { list* tmp = *head; list* reversed = NULL; while ( tmp != NULL ) { add(&reversed, tmp->key, tmp->value); tmp = tmp->next; } deleteList(*head); *head = reversed; } void add(list** head, int k, char v) { list* t = calloc(1, sizeof(list)); t->key = k; t->value = v; t->next = *head; *head = t; }
struct Node{ Node(): next(NULL){} Node *next; std::string data; }; void printlist(Node* l){ while(l){ std::cout<<l->data<<std::endl; l = l->next; } std::cout<<"----"<<std::endl; } void reverse(Node*& l) { Node* prev = NULL; while(l){ auto next = l->next; l->next = prev; prev=l; l=next; } l = prev; } int main() { Node s,t,u,v; s.data = "1"; t.data = "2"; u.data = "3"; v.data = "4"; s.next = &t; t.next = &u; u.next = &v; Node* ptr = &s; printlist(ptr); reverse(ptr); printlist(ptr); return 0; }
ListNode * reverse(ListNode* head) { ListNode *r = NULL; if(head) { r = head->next; head->next = NULL; } while(r) { head = reinterpret_cast<ListNode*>(size_t(head) ^ size_t(r->next)); r->next = reinterpret_cast<ListNode*>(size_t(r->next) ^ size_t(head)); head = reinterpret_cast<ListNode*>(size_t(head) ^ size_t(r->next)); head = reinterpret_cast<ListNode*>(size_t(head) ^ size_t(r)); r = reinterpret_cast<ListNode*>(size_t(r) ^ size_t(head)); head = reinterpret_cast<ListNode*>(size_t(head) ^ size_t(r)); } return head; }
void reverse() { node * pointer1 = head->next; if(pointer1 != NULL) { node *pointer2 = pointer1->next; pointer1->next = head; head->next = NULL; head = pointer1; if(pointer2 != NULL) { while(pointer2 != NULL) { pointer1 = pointer2; pointer2 = pointer2->next; pointer1->next = head; head = pointer1; } pointer1->next = head; head = pointer1; } } }
typedef struct List* List; struct List { int val; List next; }; List reverse(List list) { static List tail; if(!list || !list->next) { tail = list; return tail; } else { reverse1(list->next); list->next->next = list; list->next = NULL; return tail; } }
struct node* reverseList(struct node *head) { if(head == NULL) return NULL; if(head->next == NULL) return head; struct node* second = head->next; head->next = NULL; struct node* remaining = reverseList(second); second->next = head; return remaining; }
curr = head; prev = NULL; while (curr != NULL) { next = curr->next; curr->next = prev; prev = curr; curr = next; } head = prev;
typedef unsigned long AddressType; p = first; while( first->link ) { A = A + B + C; B = A - B - C; A = A - B; C = A - C; A = A - C; } first = p;
gcc ./t1.c -o aaa gcc ./t2.c -o bbb 98c1a86e593fd0181383662e68bac22f aaa c10293cbe6031b13dc6244d01b4d2793 bbb gcc ./t2.c -Ofast -o bbb gcc ./t1.c -Ofast -o aaa 2f65a6d5bc9bf1351bdd6919a766fa10 aaa c0bee139c47183ce62e10c3dbc13c614 bbb gcc ./t1.c -O3 -o aaa gcc ./t2.c -O3 -o bbb 564a39d982710b0070bb9349bfc0e2cd aaa ad89b15e73b26e32026fd0f1dc152cd2 bbb
$ cp code.c code2.c subdir/code.c $ gcc code.c -o a $ gcc code2.c -o b $ gcc subdir/code.c -o a2 $ diff a b Binary files a and b differ $ diff a2 b Binary files a2 and b differ $ diff -s a a2 Files a and a2 are identical
$ strip a a2 b $ diff -s a b Files a and b are identical $ diff -s a2 b Files a2 and b are identical $ diff -s a a2 Files a and a2 are identical
$ strings -a program > x ...recompile program... $ strings -a program > y $ diff x y
typedef struct { int *array; size_t used; size_t size; } Array; void initArray(Array *a, size_t initialSize) { a->array = (int *)malloc(initialSize * sizeof(int)); a->used = 0; a->size = initialSize; } void insertArray(Array *a, int element) { if (a->used == a->size) { a->size *= 2; a->array = (int *)realloc(a->array, a->size * sizeof(int)); } a->array[a->used++] = element; } void freeArray(Array *a) { free(a->array); a->array = NULL; a->used = a->size = 0; }
Array a; int i; initArray(&a, 5); for (i = 0; i < 100; i++) insertArray(&a, i); printf("%d\n", a.array[9]); printf("%d\n", a.used); freeArray(&a);
int push_back(struct int_list **fubar, int value) { size_t x = *fubar ? fubar[0]->size : 0 , y = x + 1; if ((x & y) == 0) { void *temp = realloc(*fubar, sizeof **fubar + (x + y) * sizeof fubar[0]->value[0]); if (!temp) { return 1; } *fubar = temp; } fubar[0]->value[x] = value; fubar[0]->size = y; return 0; } struct int_list *array = NULL;
struct int_list *array = NULL; if (!push_back(&array, 42)) { }
extern "C" { typedef struct { int *array; size_t size; } Array; void Array_Init(Array *array); void Array_Add(Array *array, int item); void Array_Delete(Array *array, int index); void Array_Free(Array *array); }
void Array_Init(Array *array) { int *int_pointer; int_pointer = (int *)malloc(sizeof(int)); if (int_pointer == NULL) { printf("Unable to allocate memory, exiting.\n"); free(int_pointer); exit(0); } else { array->array = int_pointer; array->size = 0; } } void Array_Add(Array *array, int item) { int *int_pointer; array->size += 1; int_pointer = (int *)realloc(array->array, array->size * sizeof(int)); if (int_pointer == NULL) { printf("Unable to reallocate memory, exiting.\n"); free(int_pointer); exit(0); } else { array->array = int_pointer; array->array[array->size-1] = item; } } void Array_Delete(Array *array, int index) { int i; Array temp; int *int_pointer; Array_Init(&temp); for(i=index; i<array->size; i++) { array->array[i] = array->array[i + 1]; } array->size -= 1; for (i = 0; i < array->size; i++) { Array_Add(&temp, array->array[i]); } int_pointer = (int *)realloc(temp.array, temp.size * sizeof(int)); if (int_pointer == NULL) { printf("Unable to reallocate memory, exiting.\n"); free(int_pointer); exit(0); } else { array->array = int_pointer; } } void Array_Free(Array *array) { free(array->array); array->array = NULL; array->size = 0; }
int main(int argc, char** argv) { Array pointers; int i; Array_Init(&pointers); for (i = 0; i < 60; i++) { Array_Add(&pointers, i); } Array_Delete(&pointers, 3); Array_Delete(&pointers, 6); Array_Delete(&pointers, 30); for (i = 0; i < pointers.size; i++) { printf("Value: %d Size:%d \n", pointers.array[i], pointers.size); } Array_Free(&pointers); return (EXIT_SUCCESS); }
typedef struct STRUCT_SS_VECTOR { size_t size; void** items; } ss_vector; ss_vector* ss_init_vector(size_t item_size) { ss_vector* vector; vector = malloc(sizeof(ss_vector)); vector->size = 0; vector->items = calloc(0, item_size); return vector; } void ss_vector_append(ss_vector* vec, void* item) { vec->size++; vec->items = realloc(vec->items, vec->size * sizeof(item)); vec->items[vec->size - 1] = item; }; void ss_vector_free(ss_vector* vec) { for (int i = 0; i < vec->size; i++) free(vec->items[i]); free(vec->items); free(vec); }
typedef struct APPLE_STRUCT { int id; } apple; apple* init_apple(int id) { apple* a; a = malloc(sizeof(apple)); a-> id = id; return a; }; int main(int argc, char* argv[]) { ss_vector* vector = ss_init_vector(sizeof(apple)); for (int i = 0; i < 10; i++) ss_vector_append(vector, init_apple(i)); ss_vector_free(vector); return 0; }
void* element_2_remove = getElement2BRemove(); for (int i = 0; i < vector->size; i++){ if(vector[i]!=element_2_remove) copy2TempVector(vector[i]); } free(vector->items); free(vector); fillFromTempVector(vector); //
unsigned int u = 1234; int i = -5678; unsigned int result = u + i;
int main(void) { unsigned int plus_one = 1; int minus_one = -1; if(plus_one < minus_one) printf("1 < -1"); else printf("boring"); return 0; }
unsigned int u = 1234; int i = -5678; unsigned int result = u + i;
double (*e)[n+1] = malloc( sizeof(double[n+1][n+1]) );
int arr[N][10][5]; int (*p)[10][5]; ... int x = p[i][j][k];
T **arr = malloc( sizeof *arr * N ); if ( arr ) { for ( size_t i = 0; i < N; i++ ) { arr[i] = malloc( sizeof *arr[i] * M ); } }
int main() { int val; printf("blah %n blah\n", &val); printf("val = %d\n", val); return 0; }
int n; printf("%s: %nFoo\n", "hello", &n); printf("%*sBar\n", n, "");
int n = printf("%s: ", "hello"); printf("Foo\n"); printf("%*sBar\n", n, "");
void authorizeUser( char * username, char * password){ ...code here setting authorized to false... printf(username); if ( authorized ) { giveControl(username); } }
int n_chars = 0; printf("Hello, World%n", &n_chars);
char buf[256]; int start; int end; snprintf(buf, sizeof buf, "blah blah %s %f yada yada %n%s%n yakety yak", someUserSpecifiedString, someFloat, &start, boldString, &end); control->set_text(buf); control->set_bold(start, end);
int main(int argc, char* argv[]) { int resultOfNSpecifier = 0; _set_printf_count_output(1); printf("Some format string%n\n", &resultOfNSpecifier); printf("Count of chars before the %%n: %d\n", resultOfNSpecifier); return 0; }
int a; printf("Hello World %n \n", &a); printf("Characters printed so far = %d",a);
Program received signal SIGSEGV, Segmentation fault. 0x00000002 in ?? () (gdb) bt Backtrace stopped: previous frame inner to this frame (corrupt stack?) (gdb)
(gdb) set $pc = *(void **)$esp (gdb) set $esp = $esp + 4
(gdb) set $pc = *(void **)$rsp (gdb) set $rsp = $rsp + 8
struct T { int len; char s[1]; }; struct T *p = malloc(sizeof(struct T) + 100); p->len = 100; strcpy(p->s, "hello world");
load register A with the value at memory address y load register B with a value of 3 multiply register A and B, saving the result in A write register A to memory address x
int a, b; a = 10; b = 20; /* NOTE : ++ ( exp ); ++ ( 10 + 20 ); ++ ( 30 ); */ ++(a+b);
static void *gostruct[] = { [0 ... 255] = &&l_bad, [ [ [ [ [ [ [65 ... 90] = &&l_bare, [97 ... 122] = &&l_bare }; ........ ....... l_bad: *vlen = cur - json; return 0; ........ ........
int widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };
typedef void (*stdfx)(int); void fx_typ(stdfx fx); void fx_def(FX_TYPE fx);
typedef int* int_p1; int_p1 a, b, c; int_p2 a, b, c;
typedef int (*CALLBACK)(void); typedef int *(*(*OBNOXIOUSFUNC)(void))[20]; ... CALLBACK aCallbackFunc; OBNOXIOUSFUNC anObnoxiousFunc;
new.c:7: warning: implicit declaration of function ‘malloc’ new.c:7: warning: incompatible implicit declaration of built-in function ‘malloc’
int fibo(int n); int main() { printf("Fib(4) = %d", fibo(4)); return 0; } int fibo(int n) { double phi = 1.61803399; return (int)(floor((float)(pow(phi, n) / sqrt(5)) + .5f)); }
gab@testvm:~/work/c/fibo$ gcc fib.c -o fibo /tmp/ccNSjm4q.o: In function `fibo fib.c:(.text+0x4a): undefined reference to `pow' fib.c:(.text+0x68): undefined reference to `floor' collect2: ld returned 1 exit status
struct S { int i; }; void swap(struct S *a, struct S *b) { struct S temp; temp = *a *a = *b; *b = temp; } int main(void) { struct S a = { 1 }; struct S b = { 2 }; swap(&a, &b); }
prog.c: In function prog.c:12:5: error: invalid operands to binary * (have *a = *b; ^
int main(void) { unsigned short int length = 10; printf("Enter length : "); scanf("%u", &length); printf("value is %u \n", length); return 0; }
for(int i = 0; i < 10; i++) { for(int i = 0; i < 10; i++) { } }
for (int i = 1 ; i < 100 ; i++) { for ( ; i % 10 != 0 ; i++) { printf("%02d ", i); } printf("%d\n", i); }
for(int i = 0; i < 10; i++) { for(int i = 0; i < 10; i++) { } }
for(int i = 0; i < 10; i++) { for(int i = 0; i < 10; i++) { } }
for(int i = 0; i < 10; i++) { for(int i = 0; i < 10; i++) { } }
for(int i = 0; i < 10; i++) { for(int j = 0; j < 10; j++) { } }
for(int i ,j= 0; i < 10; (j>9) ? (i++,j=0) : 0 ,j++) { printf("%d %d\n",i,j); }
for(int i = 0; i < 10; i++){ for(int i = 1; i < 10; i++){ } }
for(int i = 0; i < 10; i++){ for(int j = 1; j < 10; j++){ } }
for(int i = 0; i < 10; i++) { for(int i = 0; i < 10; i++) { } }
int main(void) { int i = 2; if(1) { int i = 5; for(int i = 0; i < 10; i++) { printf("i value in first loop: %d \n", i); for(int i = 8; i < 15; i++) { printf("i value in nested loop: %d \n", i); } } } return 0; }
for(int i = 0; i < 10; i++) { for(int i = 0; i < 10; i++) { puts("Test"); } }
for(int i = 0; i < 10; i++) { for(i = 0; i < 10; i++) { puts("Test"); } }
signed int x1 = 5; assert((x1 >> 1) == 2); signed int x2 = -5; assert((x2 >> 1) == -3); unsigned int x3 = (unsigned int)-5; assert((x3 >> 1) == 0x7FFFFFFD);
| Direction | Type | Value (i) | Result | | ---------- | -------- | --------- | ------------------------ | | Right (>>) | unsigned | ≥ 0 | −∞ ← (i ÷ 2ⁿ) | | Right | signed | ≥ 0 | −∞ ← (i ÷ 2ⁿ) | | Right | signed | < 0 | Implementation-defined† | | Left (<<) | unsigned | ≥ 0 | (i * 2ⁿ) % (T_MAX + 1) | | Left | signed | ≥ 0 | (i * 2ⁿ) ‡ | | Left | signed | < 0 | Undefined |
int logicalRightShift(int x, int n) { return (unsigned)x >> n; } int arithmeticRightShift(int x, int n) { if (x < 0 && n > 0) return x >> n | ~(~0U >> n); else return x >> n; }
x = 5 x >> 1 x = 2 ( x=5/2) x = 5 x << 1 x = 10 (x=5*2)
NSString *string = [[NSString alloc] init]; string = @"something";
unsigned char a[] = { 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x0a }; unsigned int a_len = 12;
R"=====(Line 1 Line 2 Line 3 Now you can use "( and )" in the text file, too. Line 5 Line 6)====="
int main() { int c; while((c = fgetc(stdin)) != EOF) { printf(" } printf(" }
int main(void) { char *test = "this is test\n file\n" ; return 0; }
int main() { const char* text = " "; printf("%s", text); return 0; }
"Something evil\n"\ "this way comes!" int main() { const char* text = ; printf("%s", text); return 0; }
fileSize () { [ -e "$1" ] && { set -- `ls -l "$1"`; echo $5; } } echo unsigned char $1 ./xtr -fhex -p 0x -s echo echo echo echo unsigned long int ${1}_length = $(fileSize "$2")
objcopy --input binary --output elf64-x86-64 myfile.txt myfile.o
function(make_includable input_file output_file) file(READ ${input_file} content) set(delim "for_c++_include") set(content "R\"${delim}(\n${content})${delim}\"") file(WRITE ${output_file} "${content}") endfunction(make_includable) make_includable(external/shaders/cool.frag generated/cool.frag)
extern const char pyxxd[]; extern const size_t pyxxd_len; const char pyxxd[] = " "\n" "import sys\n" "import re\n" "\n" "def is_printable_ascii(byte):\n" " return byte >= ord( "\n" "def needs_escaping(byte):\n" " return byte == ord( "\n" "def stringify_nibble(nibble):\n" " if nibble < 10:\n" " return chr(nibble + ord( " return chr(nibble - 10 + ord( "\n" "def write_byte(of, byte):\n" " if is_printable_ascii(byte):\n" " if needs_escaping(byte):\n" " of.write( " of.write(chr(byte))\n" " elif byte == ord( " of.write( " else:\n" " of.write( " of.write(stringify_nibble(byte >> 4))\n" " of.write(stringify_nibble(byte & 0xf))\n" "\n" "def mk_valid_identifier(s):\n" " s = re.sub( " s = re.sub( " return s\n" "\n" "def main():\n" " " if len(sys.argv) != 4 or sys.argv[1] != \"-i\":\n" " print(\"Usage: xxd -i infile outfile\")\n" " exit(2)\n" "\n" " with open(sys.argv[2], \"rb\") as infile:\n" " with open(sys.argv[3], \"w\") as outfile:\n" "\n" " identifier = mk_valid_identifier(sys.argv[2]);\n" " outfile.write( " outfile.write( " outfile.write( " outfile.write( "\n" " while True:\n" " byte = infile.read(1)\n" " if byte == b\"\":\n" " break\n" " write_byte(outfile, ord(byte))\n" "\n" " outfile.write( " outfile.write( "\n" "if __name__ == " main()\n" ""; const size_t pyxxd_len = sizeof(pyxxd) - 1;
extern const char pyxxd[]; extern const size_t pyxxd_len; int main() { fwrite(pyxxd, 1, pyxxd_len, stdout); }
int main(void) { char *textFileContents = ; printf("%s\n", textFileContents); return 0 }
printk ( MODULE_NAME " built " __DATE__ " at " __TIME__ " on host " STRGF( hostname ) "\n" );
printk ( MODULE_NAME " built " __DATE__ " at " __TIME__ " on host " STRGF( ) "\n" );
/etc/hostname: In function ‘init_module’: /etc/hostname:1:0: error: unterminated argument list invoking macro "STRGF"
const char main_js_file_data[8][4]= { { { { { { { { {
int main(int argc, char * argv[]) { if (argc < 4) { return 1; } std::vector<char> bufferedData; { std::ifstream fStr(argv[1], std::ios::binary); if (!fStr.is_open()) { return 1; } bufferedData.assign(std::istreambuf_iterator<char>(fStr), std::istreambuf_iterator<char>() ); } { std::ofstream fStr(argv[2]); if (!fStr.is_open()) { return 1; } const std::size_t numChunks = std::size_t(std::ceil(double(bufferedData.size()) / (MAX_CHARS_PER_ARRAY - 1))); fStr << "const char " << argv[3] << "[" << numChunks << "]" << "[" << MAX_CHARS_PER_ARRAY << "]= {" << std::endl; std::size_t count = 0; fStr << std::hex; while (count < bufferedData.size()) { std::size_t n = 0; fStr << "{"; for (; n < MAX_CHARS_PER_ARRAY - 1 && count < bufferedData.size(); ++n) { fStr << " } for (std::size_t j = 0; j < (MAX_CHARS_PER_ARRAY - 1) - n; ++j) { fStr << " } fStr << " if (count < bufferedData.size()) { fStr << ",\n"; } } fStr << "};\n"; } return 0; }
int main() { double complex z1 = 1.0 + 3.0 * I; double complex z2 = 1.0 - 4.0 * I; printf("Working with complex numbers:\n\v"); printf("Starting values: Z1 = %.2f + %.2fi\tZ2 = %.2f %+.2fi\n", creal(z1), cimag(z1), creal(z2), cimag(z2)); double complex sum = z1 + z2; printf("The sum: Z1 + Z2 = %.2f %+.2fi\n", creal(sum), cimag(sum)); double complex difference = z1 - z2; printf("The difference: Z1 - Z2 = %.2f %+.2fi\n", creal(difference), cimag(difference)); double complex product = z1 * z2; printf("The product: Z1 x Z2 = %.2f %+.2fi\n", creal(product), cimag(product)); double complex quotient = z1 / z2; printf("The quotient: Z1 / Z2 = %.2f %+.2fi\n", creal(quotient), cimag(quotient)); double complex conjugate = conj(z1); printf("The conjugate of Z1 = %.2f %+.2fi\n", creal(conjugate), cimag(conjugate)); return 0; }
__real__ a = 1.4; __imag__ a = 2.0; float b = __real__ a;
int main() { double complex z1 = 1.0 + 3.0 * I; double complex z2 = 1.0 - 4.0 * I; printf("Working with complex numbers:\n\v"); printf("Starting values: Z1 = %.2f + %.2fi\tZ2 = %.2f %+.2fi\n", creal(z1), cimag(z1), creal(z2), cimag(z2)); double complex sum = z1 + z2; printf("The sum: Z1 + Z2 = %.2f %+.2fi\n", creal(sum), cimag(sum)); }
int main() { int negNum; printf("Calculate negative square roots:\n" "Enter negative number:"); scanf("%d", &negNum); double complex negSqrt = csqrt(negNum); double pReal = creal(negSqrt); double pImag = cimag(negSqrt); printf("\nReal part %f, imaginary part %f" ", for negative square root.(%d)", pReal, pImag, negNum); return 0; }
int main(void) { double complex z1=1./4.*M_PI+1./4.*M_PI*I; double complex z2, z3, z4, z5; z2=exp(z1); z3=sin(z1); z4=sqrt(z1); z5=log(z1); printf("exp(z1)=%lf + %lf I\n", creal(z2),cimag(z2)); printf("sin(z1)=%lf + %lf I\n", creal(z3),cimag(z3)); printf("sqrt(z1)=%lf + %lf I\n", creal(z4),cimag(z4)); printf("log(z1)=%lf + %lf I\n", creal(z5),cimag(z5)); return 0; }
__complex__ float z; float r; float i; r = __real__ z; i = __imag__ z;
char* concat(const char *s1, const char *s2) { char *result = malloc(strlen(s1) + strlen(s2) + 1); strcpy(result, s1); strcat(result, s2); return result; }
char* concat(const char *s1, const char *s2) { const size_t len1 = strlen(s1); const size_t len2 = strlen(s2); char *result = malloc(len1 + len2 + 1); memcpy(result, s1, len1); memcpy(result + len1, s2, len2 + 1); return result; }
int main(){ char name[] = "derp" "herp"; printf("\"%s\"\n", name); return 0; }
char* concat(int count, ...) { va_list ap; int i; int len = 1; va_start(ap, count); for(i=0 ; i<count ; i++) len += strlen(va_arg(ap, char*)); va_end(ap); char *merged = calloc(sizeof(char),len); int null_pos = 0; va_start(ap, count); for(i=0 ; i<count ; i++) { char *s = va_arg(ap, char*); strcpy(merged+null_pos, s); null_pos += strlen(s); } va_end(ap); return merged; }
void println(char *line) { printf("%s\n", line); } int main(int argc, char* argv[]) { char *str; str = concat(0); println(str); free(str); str = concat(1,"a"); println(str); free(str); str = concat(2,"a","b"); println(str); free(str); str = concat(3,"a","b","c"); println(str); free(str); return 0; }
char *str = concat(2,"a","b"); println(str); free(str);
int main() { char s1[] = "oppa"; char s2[] = "gangnam"; char s3[] = "style"; { char result[STR_SIZE] = {0}; snprintf(result, sizeof(result), "%s %s %s", s1, s2, s3); printf("%s\n", result); } }
int main(void) { const char str1[] = "First"; const char str2[] = "Second"; char *res; res = malloc(strlen(str1) + strlen(str2) + 1); if (!res) { fprintf(stderr, "malloc() failed: insufficient memory!\n"); return EXIT_FAILURE; } strcpy(res, str1); strcat(res, str2); printf("Result: free(res); return EXIT_SUCCESS; }
int main(void) { const char str1[] = "First"; const char str2[] = "Second"; char *res; if (-1 == asprintf(&res, "%s%s", str1, str2)) { fprintf(stderr, "asprintf() failed: insufficient memory!\n"); return EXIT_FAILURE; } printf("Result: free(res); return EXIT_SUCCESS; }
int main() { int a,l; char str[50],str1[50],str3[100]; printf("\nEnter a string: "); scanf("%s",str); str3[0]= printf("\nEnter the string which you want to concat with string one: "); scanf("%s",str1); strcat(str3,str); strcat(str3,str1); printf("\nThe string is %s\n",str3); }
int main() { char str1[MAX],str2[MAX]; int i,j=0; printf("Input string 1: "); gets(str1); printf("\nInput string 2: "); gets(str2); for(i=strlen(str1);str2[j]!= { str1[i]=str2[j]; j++; } str1[i]= printf("\nConcatenated string: "); puts(str1); return 0; }
int main() { char str1[MAX],str2[MAX],str3[MAX]; int i,j=0,count=0; printf("Input string 1: "); gets(str1); printf("\nInput string 2: "); gets(str2); for(i=0;str1[i]!= { str3[i]=str1[i]; count++; } for(i=count;str2[j]!= { str3[i]=str2[j]; j++; } str3[i]= printf("\nConcatenated string : "); puts(str3); return 0; }
int main() { char str1[MAX],str2[MAX]; printf("Input string 1: "); gets(str1); printf("\nInput string 2: "); gets(str2); strcat(str1,str2); printf("\nConcatenated string : "); puts(str1); return 0; }
$ strings /usr/bin/clang | grep __ | grep -i clang __clang__
size_t size; int *list = (int *)malloc(size); if (list == NULL) { } else { }
==16740== Command: ./malloc0 ==16740== p1 = 0x5204040 ==16740== ==16740== HEAP SUMMARY: ==16740== in use at exit: 0 bytes in 0 blocks ==16740== total heap usage: 2 allocs, 2 frees, 1,024 bytes allocated ==16740== ==16740== All heap blocks were freed -- no leaks are possible
int main() { char *p1; p1 = (char *)malloc(0); printf("p1 = %p\n", p1); free(p1); return 0; }
char *ptr; if( (ptr = (char *) malloc(0)) == NULL ) puts("Got a null pointer"); else puts("Got a valid pointer");
unsigned char *p=NULL; p =(char *)malloc(0); free(p);
struct MyStruct ; struct MyStruct { } ; void doSomething(struct MyStruct * p) { struct MyStruct a ; }
struct MyStructTag ; typedef struct MyStructTag { } MyStruct ; void doSomething(MyStruct * p) { MyStruct a ; }
void _start() { int ret = my_main(); exit(ret); } int my_main() { puts("This is a program without main!\n"); return 0; }
HEDLEY_GNUC_HAS_ATTRIBUTE(noinline,4,0,0) || \ HEDLEY_INTEL_VERSION_CHECK(16,0,0) || \ HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \ HEDLEY_ARM_VERSION_CHECK(4,1,0) || \ HEDLEY_IBM_VERSION_CHECK(10,1,0) || \ HEDLEY_TI_VERSION_CHECK(8,0,0) || \ (HEDLEY_TI_VERSION_CHECK(7,3,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))
switch(state) { case STATE_1: state = DoState1(transition); break; case STATE_2: state = DoState2(transition); break; } ... DoState2(int transition) { ... if(transition == FROM_STATE_2) { } if(transition == FROM_STATE_1) { } return new_state; }
typedef enum { STATE_INITIAL, STATE_FOO, STATE_BAR, NUM_STATES } state_t; typedef struct instance_data instance_data_t; typedef state_t state_func_t( instance_data_t *data ); state_t do_state_initial( instance_data_t *data ); state_t do_state_foo( instance_data_t *data ); state_t do_state_bar( instance_data_t *data ); state_func_t* const state_table[ NUM_STATES ] = { do_state_initial, do_state_foo, do_state_bar }; state_t run_state( state_t cur_state, instance_data_t *data ) { return state_table[ cur_state ]( data ); }; int main( void ) { state_t cur_state = STATE_INITIAL; instance_data_t data; while ( 1 ) { cur_state = run_state( cur_state, &data ); } }
typedef void transition_func_t( instance_data_t *data ); void do_initial_to_foo( instance_data_t *data ); void do_foo_to_bar( instance_data_t *data ); void do_bar_to_initial( instance_data_t *data ); void do_bar_to_foo( instance_data_t *data ); void do_bar_to_bar( instance_data_t *data ); transition_func_t * const transition_table[ NUM_STATES ][ NUM_STATES ] = { { NULL, do_initial_to_foo, NULL }, { NULL, NULL, do_foo_to_bar }, { do_bar_to_initial, do_bar_to_foo, do_bar_to_bar } }; state_t run_state( state_t cur_state, instance_data_t *data ) { state_t new_state = state_table[ cur_state ]( data ); transition_func_t *transition = transition_table[ cur_state ][ new_state ]; if ( transition ) { transition( data ); } return new_state; };
FSM { STATE(x) { ... NEXTSTATE(y); } STATE(y) { ... if (x == 0) NEXTSTATE(y); else NEXTSTATE(x); } }
struct state; typedef void (*state_func_t)( struct state* ); typedef struct state { state_func_t function; } state_t; void do_state_initial( state_t* ); void do_state_foo( state_t* ); void do_state_bar( state_t* ); void run_state( state_t* i ) { i->function(i); }; int main( void ) { state_t state = { do_state_initial }; while ( 1 ) { run_state( state ); } }
typedef enum { STATE_1 = 0, STATE_2, STATE_3 } my_state_t; my_state_t state = STATE_1; void foo(char input) { ... switch(state) { case STATE_1: if(input) state = STATE_2; break; case STATE_2: if(input) state = STATE_3; else state = STATE_1; break; case STATE_3: ... break; } ... }
void state_one(int set, int reset); void state_two(int set, int reset); void (*next_state)(int set, int reset) = state_one; /* Users should call next_state(set, reset). This could also be wrapped by a real function that validated input and dealt with output rather than calling the function pointer directly. */ void state_one(int set, int reset) { if(set) next_state = state_two; } void state_two(int set, int reset) { if(reset) next_state = state_one; }
public void HandleEvent(PhoneEvent anEvent) { switch (CurrentState) { case PhoneState.ScreenOff: switch (anEvent) { case PhoneEvent.PressButton: if (powerLow) { DisplayLowPowerMessage(); } else { CurrentState = PhoneState.ScreenOn; } break; case PhoneEvent.PlugPower: CurrentState = PhoneState.ScreenCharging; break; } break; case PhoneState.ScreenOn: switch (anEvent) { case PhoneEvent.PressButton: CurrentState = PhoneState.ScreenOff; break; case PhoneEvent.PlugPower: CurrentState = PhoneState.ScreenCharging; break; } break; case PhoneState.ScreenCharging: switch (anEvent) { case PhoneEvent.UnplugPower: CurrentState = PhoneState.ScreenOff; break; } break; } }
static int current_state; void state_leave(int new_state) { } void state_enter(int new_state) { current_state = new_state; } void state_process() { }
struct State { unsigned long Out; unsigned long Time; unsigned long Next[4]; }; typedef const struct State STyp; STyp FSM[4]={ {0x21,3000,{goN,waitN,goN,waitN}}, {0x22, 500,{goE,goE,goE,goE}}, {0x0C,3000,{goE,goE,waitE,waitE}}, {0x14, 500,{goN,goN,goN,goN}}}; unsigned long currentState; int main(void){ volatile unsigned long delay; currentState = goN; while(1){ LIGHTS = FSM[currentState].Out; SysTick_Wait10ms(FSM[currentState].Time); currentState = FSM[currentState].Next[INPUT_SENSORS]; } }
typedef enum fsmSignal { eEnter =0, eNormal, eExit }FsmSignalT; typedef struct fsm { FsmSignalT signal; StateT currentState; }FsmT; extern int STATECTXT_Init(void); extern STATECTXT_Set(StateT stateID); extern void STATECTXT_Handle(void *pvEvent);
typedef STATE (*pfnStateT)(FsmSignalT signal, void *pvEvent); static FsmT fsm; static pfnStateT UsbState ; int STATECTXT_Init(void) { UsbState = State1; fsm.signal = eEnter; fsm.currentState = (*UsbState)( &fsm, pvEvent); return 0; } static void ChangeState( FsmT *pFsm, pfnStateT targetState ) { if (targetState != NULL) { pFsm->signal = eExit; STATE dummyState = (*UsbState)( pFsm, pvEvent); UsbState = targetState ; pFsm->signal = eEnter; dummyState = (*UsbState)( pFsm, pvEvent); } } void STATECTXT_Handle(void *pvEvent) { pfnStateT newState; if (UsbState != NULL) { fsm.signal = eNormal; newState = (*UsbState)( &fsm, pvEvent ); ChangeState( &fsm, newState ); } } void STATECTXT_Set(StateT stateID) { prevState = UsbState; switch (stateID) { case ChangeState( State1 ); break; case ChangeState( State2); break; case ChangeState( State3); break; } }
extern STATE State1(void); extern STATE State2(void); extern STATE State3(void);
STATE State1(FsmT *fsm, void *pvEvent) { STATE nextState; /* do some state specific behaviours * here */ /* fsm->currentState currently contains the previous state * just before it gets updated, so you can implement behaviours * which depend on previous state here */ fsm->currentState = /* Now, specify the next state * to transition to, or return null if you * more stuff to process. */ switch (fsm->signal) { case eEnter: nextState = State2; break; case eNormal: nextState = null; break; case eExit: nextState = State2; break; } return nextState; } STATE State3(FsmT *fsm, void *pvEvent) { /* do some state specific behaviours * here */ fsm->currentState = /* Now, specify the next state * to transition to */ return State1; } STATE State2(FsmT *fsm, void *pvEvent) { /* do some state specific behaviours * here */ fsm->currentState = /* Now, specify the next state * to transition to */ return State3; }
int run = 1; state = START; while(run) { switch (state) { case __COUNTER__: state++; break; case __COUNTER__: if (input) state = END; else state++; break; . . . case __COUNTER__: if (input) state = START; else state++; break; case __COUNTER__: state++; break; case END: run = 0; state = START; break; default: state++; break; } }
/** FSM enum type */ typedef enum { fsm_User = 0, fsm_Reset = -1, fsm_None = -2, fsm_Any = -3, fsm_Empty = -4, fsm_End = -5, fsm_Enter = 0, fsm_State, fsm_Leave } fsm_e; typedef int FsmEvent; typedef struct FsmState FsmState; typedef struct FsmEdge FsmEdge; /** State action functor @param state Pointer to this state @param type Action type (Enter/State/Leave) @param frto Pointer to from(Enter)/to(Leave) state, NULL otherwise @param data User data @return Event id in case of a new triggered event, fsm_None otherwise */ typedef FsmEvent (*FsmAction)(FsmState *state, fsm_e type, FsmState *frto, void *data); /** FSM state object */ struct FsmState { FsmAction action; void *data; }; /** State jump functor @param edge Pointer to this edge @param state Pointer to the actual current state @param event Event id that triggered the transition @param data User data @return Pointer to the next state and NULL for end state */ typedef FsmState *(*FsmJump)(FsmEdge *edge, FsmState *state, FsmEvent event, void *data); /** Guard function @param edge Pointer to this edge @param state Pointer to the actual current state @param event Event id that triggered the transition @param data User data @return Guard result */ typedef bool (*FsmGuard)(FsmEdge *edge, FsmState *state, FsmEvent event, void *data); /** FSM edge transition */ struct FsmEdge { FsmState *state; FsmEvent event; void *next; FsmGuard guard; void *data; }; typedef struct Fsm Fsm; struct Fsm { FsmState *state; size_t states; void **stateData; FsmEdge *edge; size_t edges; void **edgeData; FsmEvent event; fsm_e type; FsmState *current; void *data; }; static inline FsmEvent fsmStep(Fsm *f, FsmEvent e) { FsmState *cp = f->current; FsmEvent ne = fsm_None; void *us = (f->stateData && cp) ? f->stateData[cp - f->state] : NULL; if (!cp && e == fsm_None) e = fsm_Reset; f->event = e; switch (e) { case fsm_Reset: { if (cp && cp->action) { f->type = fsm_Leave, ne = cp->action(cp, fsm_Leave, f->state, us); if (ne != fsm_None) return ne; } FsmState *ps = cp; cp = f->current = f->state; if (!cp) return fsm_End; if (cp->action) { us = f->stateData ? f->stateData[0] : NULL; f->type = fsm_Enter, ne = cp->action(cp, fsm_Enter, ps, us); } } break; case fsm_None: if (cp->action) f->type = fsm_State, ne = cp->action(cp, fsm_State, NULL, us); break; default: ne = fsm_Empty; for (size_t i = 0; i < f->edges; ++i) { FsmEdge *ep = &f->edge[i]; if (ep->state && ep->state != cp) continue; if (ep->event == fsm_End) break; ne = fsm_None; if (ep->event == e || ep->event == fsm_Any) { void *ue = f->edgeData ? f->edgeData[i] : NULL; if (!ep->guard || ep->guard(ep, cp, e, ue)) { FsmState *np = (!ep->next) ? NULL : ((FsmState *)(ep->next) >= f->state && (FsmState *)(ep->next) < (f->state + f->states)) ? (FsmState *)(ep->next) : ((FsmJump)(ep->next))(ep, cp, e, ue); if (cp->action) { f->type = fsm_Leave, ne = cp->action(cp, fsm_Leave, np, us); if (ne != fsm_None) return ne; } if (!np) ne = fsm_End; else if (np->action) { us = f->stateData ? f->stateData[np - f->state] : NULL; f->type = fsm_Enter, ne = np->action(np, fsm_Enter, cp, us); } cp = np; break; } } } } f->current = cp; return ne; } static inline FsmEvent fsmReset(Fsm *f) { return fsmStep(f, fsm_Reset); }
static FsmEvent state_action(FsmState *s, fsm_e t, FsmState *ft, void *us) { FsmEvent e = fsm_None; const char *q = "?"; switch (t) { case fsm_Enter: q = "enter"; break; case fsm_Leave: q = "leave"; break; default : q = "state"; } printf("%s %s\n", (const char *)s->data, q); return e; } FsmState fs[] = { { state_action, "S0" }, { state_action, "S1" }, { state_action, "S2" }, }; static FsmState * state_jump(FsmEdge *t, FsmState *s, FsmEvent e, void *ue) { if (s == &fs[0]) return &fs[1]; if (s == &fs[2]) return NULL; return NULL; } static bool count_attempt(FsmEdge *t, FsmState *s, FsmEvent e, void *ue) { static int c = 0; ++c; bool b = c == 3; printf("guard is %s\n", b ? "true" : "false"); return b; } FsmEdge fe[] = { { &fs[0], fsm_Any, state_jump }, { &fs[1], fsm_Any, &fs[2], count_attempt }, { &fs[2], fsm_Any, state_jump }, }; int main(int argc, char **argv) { Fsm f = { fs, 3, NULL, fe, 3, NULL, }; fsmReset(&f); do { fsmStep(&f, fsm_None); } while (fsmStep(&f, fsm_Any) != fsm_End); return 0; }
7 % 3 --> 1 7 % -3 --> 1 -7 % 3 --> -1 -7 % -3 --> -1
7 modulo 3 --> 1 7 modulo -3 --> 1 -7 modulo 3 --> 2 -7 modulo -3 --> 2
int modulo_Euclidean(int a, int b) { int m = a % b; if (m < 0) { m = (b < 0) ? m - b : m + b; } return m; }
fmod( 7, 3) --> 1.0 fmod( 7, -3) --> 1.0 fmod(-7, 3) --> -1.0 fmod(-7, -3) --> -1.0
7 modulo 3 --> 1 7 modulo -3 --> -2 -7 modulo 3 --> 2 -7 modulo -3 --> -1
int main (int argc, char const *argv[]) { printf(ANSI_COLOR_RED "This text is RED!" ANSI_COLOR_RESET "\n"); printf(ANSI_COLOR_GREEN "This text is GREEN!" ANSI_COLOR_RESET "\n"); printf(ANSI_COLOR_YELLOW "This text is YELLOW!" ANSI_COLOR_RESET "\n"); printf(ANSI_COLOR_BLUE "This text is BLUE!" ANSI_COLOR_RESET "\n"); printf(ANSI_COLOR_MAGENTA "This text is MAGENTA!" ANSI_COLOR_RESET "\n"); printf(ANSI_COLOR_CYAN "This text is CYAN!" ANSI_COLOR_RESET "\n"); return 0; }
int main(void) { printf("this is " RED("red") "!\n"); printf("this is " BLUE("%s") "!\n","blue"); return 0; }
int main (int,char**) { int n=1; for (;;++n) { int msb; asm("bsrl %1,%0" : "=r"(msb) : "r"(n)); std::cout << n << " : " << msb << std::endl; } return 0; }
unsigned int v; unsigned r = 0; while (v >>= 1) { r++; }
int msb(unsigned int v) { static const int pos[32] = {0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9}; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v = (v >> 1) + 1; return pos[(v * 0x077CB531UL) >> 27]; }
double ff=(double)(v|1); return ((*(1+(uint32_t *)&ff))>>20)-1023;
double ff=(double)(v|1); uint32_t tmp; memcpy(&tmp, ((const char*)&ff)+sizeof(uint32_t), sizeof(uint32_t)); return (tmp>>20)-1023;
int highest_bit_unrolled(long long n) { if (n & 0x7FFFFFFF00000000) { if (n & 0x7FFF000000000000) { if (n & 0x7F00000000000000) { if (n & 0x7000000000000000) { if (n & 0x4000000000000000) return 63; else return (n & 0x2000000000000000) ? 62 : 61; } else { if (n & 0x0C00000000000000) return (n & 0x0800000000000000) ? 60 : 59; else return (n & 0x0200000000000000) ? 58 : 57; } } else { if (n & 0x00F0000000000000) { if (n & 0x00C0000000000000) return (n & 0x0080000000000000) ? 56 : 55; else return (n & 0x0020000000000000) ? 54 : 53; } else { if (n & 0x000C000000000000) return (n & 0x0008000000000000) ? 52 : 51; else return (n & 0x0002000000000000) ? 50 : 49; } } } else { if (n & 0x0000FF0000000000) { if (n & 0x0000F00000000000) { if (n & 0x0000C00000000000) return (n & 0x0000800000000000) ? 48 : 47; else return (n & 0x0000200000000000) ? 46 : 45; } else { if (n & 0x00000C0000000000) return (n & 0x0000080000000000) ? 44 : 43; else return (n & 0x0000020000000000) ? 42 : 41; } } else { if (n & 0x000000F000000000) { if (n & 0x000000C000000000) return (n & 0x0000008000000000) ? 40 : 39; else return (n & 0x0000002000000000) ? 38 : 37; } else { if (n & 0x0000000C00000000) return (n & 0x0000000800000000) ? 36 : 35; else return (n & 0x0000000200000000) ? 34 : 33; } } } } else { if (n & 0x00000000FFFF0000) { if (n & 0x00000000FF000000) { if (n & 0x00000000F0000000) { if (n & 0x00000000C0000000) return (n & 0x0000000080000000) ? 32 : 31; else return (n & 0x0000000020000000) ? 30 : 29; } else { if (n & 0x000000000C000000) return (n & 0x0000000008000000) ? 28 : 27; else return (n & 0x0000000002000000) ? 26 : 25; } } else { if (n & 0x0000000000F00000) { if (n & 0x0000000000C00000) return (n & 0x0000000000800000) ? 24 : 23; else return (n & 0x0000000000200000) ? 22 : 21; } else { if (n & 0x00000000000C0000) return (n & 0x0000000000080000) ? 20 : 19; else return (n & 0x0000000000020000) ? 18 : 17; } } } else { if (n & 0x000000000000FF00) { if (n & 0x000000000000F000) { if (n & 0x000000000000C000) return (n & 0x0000000000008000) ? 16 : 15; else return (n & 0x0000000000002000) ? 14 : 13; } else { if (n & 0x0000000000000C00) return (n & 0x0000000000000800) ? 12 : 11; else return (n & 0x0000000000000200) ? 10 : 9; } } else { if (n & 0x00000000000000F0) { if (n & 0x00000000000000C0) return (n & 0x0000000000000080) ? 8 : 7; else return (n & 0x0000000000000020) ? 6 : 5; } else { if (n & 0x000000000000000C) return (n & 0x0000000000000008) ? 4 : 3; else return (n & 0x0000000000000002) ? 2 : (n ? 1 : 0); } } } } } int highest_bit(long long n) { const long long mask[] = { 0x000000007FFFFFFF, 0x000000000000FFFF, 0x00000000000000FF, 0x000000000000000F, 0x0000000000000003, 0x0000000000000001 }; int hi = 64; int lo = 0; int i = 0; if (n == 0) return 0; for (i = 0; i < sizeof mask / sizeof mask[0]; i++) { int mi = lo + (hi - lo) / 2; if ((n >> mi) != 0) lo = mi; else if ((n & (mask[i] << lo)) != 0) hi = mi; } return lo + 1; }
int highest_bit_unrolled(long long n); int highest_bit(long long n); main(int argc, char **argv) { long long n = strtoull(argv[1], NULL, 0); int b1, b2; long i; clock_t start = clock(), mid, end; for (i = 0; i < 1000000000; i++) b1 = highest_bit_unrolled(n); mid = clock(); for (i = 0; i < 1000000000; i++) b2 = highest_bit(n); end = clock(); printf("highest bit of 0x%llx/%lld = %d, %d\n", n, n, b1, b2); printf("time1 = %d\n", (int) (mid - start)); printf("time2 = %d\n", (int) (end - mid)); return 0; }
int highest_bit_shift(long long n) { int i = 0; for (; n; n >>= 1, i++) ; return i; }
int highest_bit(unsigned int a) { int count; std::frexp(a, &count); return count - 1; }
unsigned int msb32(register unsigned int x) { x |= (x >> 1); x |= (x >> 2); x |= (x >> 4); x |= (x >> 8); x |= (x >> 16); return(x & ~(x >> 1)); }
/***************** math ********************/ ((unsigned) log2(a)) ? (1U << POS_OF_HIGHESTBITmath(a)) \ : 0) /***************** clz ********************/ unsigned NUM_BITS_U = ((sizeof(unsigned) << 3) - 1); ? (1U << POS_OF_HIGHESTBITclz(a)) \ : 0) /***************** i2f ********************/ double FF; ? (1U << POS_OF_HIGHESTBITi2f(a)) \ : 0) /***************** asm ********************/ unsigned OUT; ? (1U << POS_OF_HIGHESTBITasm(a)) \ : 0) /***************** bitshift1 ********************/ OUT = a; \ OUT |= (OUT >> 1); \ OUT |= (OUT >> 2); \ OUT |= (OUT >> 4); \ OUT |= (OUT >> 8); \ OUT |= (OUT >> 16); \ }), (OUT & ~(OUT >> 1))) \ /***************** bitshift2 ********************/ int POS[32] = {0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9}; OUT = a; \ OUT |= OUT >> 1; \ OUT |= OUT >> 2; \ OUT |= OUT >> 4; \ OUT |= OUT >> 8; \ OUT |= OUT >> 16; \ OUT = (OUT >> 1) + 1; \ }), POS[(OUT * 0x077CB531UL) >> 27]) ? (1U << POS_OF_HIGHESTBITbitshift2(a)) \ : 0) int main() { time_t start, end; unsigned ui; unsigned n; /********* Checking the first few unsigned values (you printf("math\n"); for (ui = 0U; ui < 18; ++ui) printf("%i\t%i\n", ui, NUM_OF_HIGHESTBITmath(ui)); printf("\n\n"); printf("clz\n"); for (ui = 0U; ui < 18U; ++ui) printf("%i\t%i\n", ui, NUM_OF_HIGHESTBITclz(ui)); printf("\n\n"); printf("i2f\n"); for (ui = 0U; ui < 18U; ++ui) printf("%i\t%i\n", ui, NUM_OF_HIGHESTBITi2f(ui)); printf("\n\n"); printf("asm\n"); for (ui = 0U; ui < 18U; ++ui) { printf("%i\t%i\n", ui, NUM_OF_HIGHESTBITasm(ui)); } printf("\n\n"); printf("bitshift1\n"); for (ui = 0U; ui < 18U; ++ui) { printf("%i\t%i\n", ui, NUM_OF_HIGHESTBITbitshift1(ui)); } printf("\n\n"); printf("bitshift2\n"); for (ui = 0U; ui < 18U; ++ui) { printf("%i\t%i\n", ui, NUM_OF_HIGHESTBITbitshift2(ui)); } printf("\n\nPlease wait...\n\n"); /************************* Simple clock() benchmark ******************/ start = clock(); for (ui = 0; ui < LOOPS; ++ui) n = NUM_OF_HIGHESTBITmath(ui); end = clock(); printf("math:\t%e\n", (double)(end-start)/CLOCKS_PER_SEC); start = clock(); for (ui = 0; ui < LOOPS; ++ui) n = NUM_OF_HIGHESTBITclz(ui); end = clock(); printf("clz:\t%e\n", (double)(end-start)/CLOCKS_PER_SEC); start = clock(); for (ui = 0; ui < LOOPS; ++ui) n = NUM_OF_HIGHESTBITi2f(ui); end = clock(); printf("i2f:\t%e\n", (double)(end-start)/CLOCKS_PER_SEC); start = clock(); for (ui = 0; ui < LOOPS; ++ui) n = NUM_OF_HIGHESTBITasm(ui); end = clock(); printf("asm:\t%e\n", (double)(end-start)/CLOCKS_PER_SEC); start = clock(); for (ui = 0; ui < LOOPS; ++ui) n = NUM_OF_HIGHESTBITbitshift1(ui); end = clock(); printf("bitshift1:\t%e\n", (double)(end-start)/CLOCKS_PER_SEC); start = clock(); for (ui = 0; ui < LOOPS; ++ui) n = NUM_OF_HIGHESTBITbitshift2(ui); end = clock(); printf("bitshift2\t%e\n", (double)(end-start)/CLOCKS_PER_SEC); printf("\nThe lower, the better. Take note that a negative exponent is good! ;)\n"); return EXIT_SUCCESS; }
asm ("bsrl %1, %0" : "=r" (position) : "r" (number));
int highest_bit(unsigned int a) { static const unsigned int maskv[] = { 0xffff, 0xff, 0xf, 0x3, 0x1 }; const unsigned int *mask = maskv; int l, h; if (a == 0) return -1; l = 0; h = 32; do { int m = l + (h - l) / 2; if ((a >> m) != 0) l = m; else if ((a & (*mask << l)) != 0) h = m; mask++; } while (l < h - 1); return l; }
u8 inline log2 (u32 val) { u8 k = 0; if (val > 0x0000FFFFu) { val >>= 16; k = 16; } if (val > 0x000000FFu) { val >>= 8; k |= 8; } if (val > 0x0000000Fu) { val >>= 4; k |= 4; } if (val > 0x00000003u) { val >>= 2; k |= 2; } k |= (val & 2) >> 1; return k; }
u8 kTableLog2[256] = { 0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5, 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6, 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6, 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 }; u8 log2_table(u32 val) { u8 k = 0; if (val > 0x0000FFFFuL) { val >>= 16; k = 16; } if (val > 0x000000FFuL) { val >>= 8; k |= 8; } k |= kTableLog2[val]; return k; }
/* CHAR_BIT (or include limits.h) */ /* * Find the log base 2 of an integer with the MSB N set in O(N) * operations. (on 64bit & 32bit architectures) */ int getmsb (uint32_t word) { int r = 0; if (word < 1) return 0; union { uint32_t u[2]; double d; } t; t.u[__FLOAT_WORD_ORDER==LITTLE_ENDIAN] = 0x43300000; t.u[__FLOAT_WORD_ORDER!=LITTLE_ENDIAN] = word; t.d -= 4503599627370496.0; r = (t.u[__FLOAT_WORD_ORDER==LITTLE_ENDIAN] >> 20) - 0x3FF; while (word >>= 1) { r++; } return r; }
unsigned int getMsb(unsigned int n) { unsigned int msb = sizeof(n) * 4; unsigned int step = msb; while (step > 1) { step /=2; if (n>>msb) msb += step; else msb -= step; } if (n>>msb) msb++; return (msb - 1); }
int msb(UINT x) { if(0 == x) return -1; int c = 0; for(UINT i=UINT_BIT>>1; 0<i; i>>=1) if(static_cast<UINT>(x >> i)) { x >>= i; c |= i; } return c; }
int lsb(UINT x) { if(0 == x) return -1; int c = UINT_BIT-1; for(UINT i=UINT_BIT>>1; 0<i; i>>=1) if(static_cast<UINT>(x << i)) { x <<= i; c ^= i; } return c; }
const auto n = 13UL; const auto Index = (unsigned long)log2(n); printf("MSB is: %u\n", Index);
const auto n = 13UL; unsigned long Index; _BitScanReverse(&Index, n); printf("MSB is: %u\n", Index);
position = sizeof(int)*8 while(!(n & cmp)){ n <<=1; position--; }
/***************** clz2 ********************/ ? (((1U) << (sizeof(unsigned)*8-1)) >> __builtin_clz(a)) \ : 0)
unsigned int Log2(unsigned long x) { unsigned long n = x; int bits = sizeof(x)*8; int step = 1; int k=0; for( step = 1; step < bits; ) { n |= (n >> step); step *= 2; ++k; } return(x - (n >> 1)); }
unsigned int Log2_a(unsigned long x) { unsigned long n = x; int bits = sizeof(x)*8; int step = 1; int step2 = 0; for( step2=0; x>1L<<step2+8; ) { step2+=8; } for( step = 0; x>1L<<(step+step2); ) { step+=1; } printf("log2(%ld) %d\n",x,step+step2); return(step+step2); }
unsigned int Log2_b(unsigned long x) { unsigned long n = x; unsigned int bits = sizeof(x)*8; unsigned int hbit = bits-1; unsigned int lbit = 0; unsigned long guess = bits/2; int found = 0; while ( hbit-lbit>1 ) { if( (x<=(1L<<guess)) ) { hbit=guess; guess=(hbit+lbit)/2; } if( (x>(1L<<guess)) ) { lbit=guess; guess=(hbit+lbit)/2; } } if( (x>(1L<<guess)) ) ++guess; printf("log2(x%ld)=r%d\n",x,guess); return(guess); }
unsigned int Log2_c(unsigned long x) { unsigned long v = x; unsigned int bits = sizeof(x)*8; unsigned int step = bits; unsigned int res = 0; for( step = bits/2; step>0; ) { while ( v>>step ) { v>>=step; res+=step; } step /= 2; } if( (x>(1L<<res)) ) ++res; printf("log2(x%ld)=r%ld\n",x,res); return(res); }
int main() { unsigned long int x = 3; for( x=2; x<1000000000; x*=2 ) { printf("x %ld, x+1 %ld, log2_a(x+1) %d\n",x,x+1,Log2_a(x+1)); printf("x %ld, x+1 %ld, log2_b(x+1) %d\n",x,x+1,Log2_b(x+1)); printf("x %ld, x+1 %ld, log2_c(x+1) %d\n",x,x+1,Log2_c(x+1)); } return(0); }
int log2floor( unsigned x ){ static const signed char wtab[16] = {-1,0,1,1, 2,2,2,2, 3,3,3,3,3,3,3,3}; int r = 0; unsigned xk = x >> 16; if( xk != 0 ){ r = 16; x = xk; } xk = x >> 8; if( xk != 0){ r += 8; x = xk; } xk = x >> 4; if( xk != 0){ r += 4; x = xk; } return r + wtab[x]; }
template <typename T> auto msb(T n) -> int { static_assert(std::is_integral<T>::value && !std::is_signed<T>::value, "msb<T>(): T must be an unsigned integral type."); for (T i = std::numeric_limits<T>::digits - 1, mask = 1 << i; i >= 0; --i, mask >>= 1) { if ((n & mask) != 0) return i; } return 0; }
int result = 0; if(value){ if(0xFFFFFFFF00000000&value){ value>>=(1<<5); result|=(1<<5); } if(0x00000000FFFF0000&value){ value>>=(1<<4); result|=(1<<4); } if(0x000000000000FF00&value){ value>>=(1<<3); result|=(1<<3); } if(0x00000000000000F0&value){ value>>=(1<<2); result|=(1<<2); } if(0x000000000000000C&value){ value>>=(1<<1); result|=(1<<1); } if(0x0000000000000002&value){ result|=(1<<0); } }else{ result=-1; }
unsigned func(unsigned x) { double d = x ; int p= (*reinterpret_cast<long long*>(&d) >> 52) - 1023; printf( "The left-most non zero bit of %d is bit %d\n", x, p); }
int v = 612635685; unsigned int get_msb(int v) { int r = 31; while (!(v & 0x8000000) && r--) { v <<= 1; } return r; }
readonly static byte[] msb_tab_15; static MyStaticInit() { var p = new byte[0x8000]; for (byte n = 0; n < 16; n++) for (int c = (1 << n) >> 1, i = 0; i < c; i++) p[c + i] = n; msb_tab_15 = p; }
public static int HighestOne(this ulong v) { if ((long)v <= 0) return (int)((v >> 57) & 0x40) - 1; int j = /**/ (int)((0xFFFFFFFFU - v /****/) >> 58) & 0x20; j |= /*****/ (int)((0x0000FFFFU - (v >> j)) >> 59) & 0x10; return j + msb_tab_15[v >> (j + 1)]; }
public static int HighestOne(uint v) { if ((int)v <= 0) return (int)((v >> 26) & 0x20) - 1; int j = (int)((0x0000FFFFU - v) >> 27) & 0x10; return j + msb_tab_15[v >> (j + 1)]; }
public static int HighestOne(long v) => HighestOne((ulong)v); public static int HighestOne(int v) => HighestOne((uint)v); public static int HighestOne(ushort v) => msb_tab_15[v >> 1]; public static int HighestOne(short v) => msb_tab_15[(ushort)v >> 1]; public static int HighestOne(char ch) => msb_tab_15[ch >> 1]; public static int HighestOne(sbyte v) => msb_tab_15[(byte)v >> 1]; public static int HighestOne(byte v) => msb_tab_15[v >> 1];
[DllImport("ntdll.dll"), SuppressUnmanagedCodeSecurity, SecuritySafeCritical] public static extern int RtlFindMostSignificantBit(ulong ul);
RtlFindMostSignificantBit: bsr rdx, rcx mov eax,0FFFFFFFFh movzx ecx, dl cmovne eax,ecx ret
public static int HighestOne_Tab8A(ulong v) { if ((long)v <= 0) return (int)((v >> 57) & 64) - 1; int j; j = /**/ (int)((0xFFFFFFFFU - v) >> 58) & 32; j += /**/ (int)((0x0000FFFFU - (v >> j)) >> 59) & 16; j += /**/ (int)((0x000000FFU - (v >> j)) >> 60) & 8; return j + msb_tab_8[v >> j]; }
const ulong N_bsf64 = 0x07EDD5E59A4E28C2, N_bsr64 = 0x03F79D71B4CB0A89; readonly public static sbyte[] bsf64 = { 63, 0, 58, 1, 59, 47, 53, 2, 60, 39, 48, 27, 54, 33, 42, 3, 61, 51, 37, 40, 49, 18, 28, 20, 55, 30, 34, 11, 43, 14, 22, 4, 62, 57, 46, 52, 38, 26, 32, 41, 50, 36, 17, 19, 29, 10, 13, 21, 56, 45, 25, 31, 35, 16, 9, 12, 44, 24, 15, 8, 23, 7, 6, 5, }, bsr64 = { 0, 47, 1, 56, 48, 27, 2, 60, 57, 49, 41, 37, 28, 16, 3, 61, 54, 58, 35, 52, 50, 42, 21, 44, 38, 32, 29, 23, 17, 11, 4, 62, 46, 55, 26, 59, 40, 36, 15, 53, 34, 51, 20, 43, 31, 22, 10, 45, 25, 39, 14, 33, 19, 30, 9, 24, 13, 18, 8, 12, 7, 6, 5, 63, }; public static int IndexOfLSB(ulong v) => v != 0 ? bsf64[((v & (ulong)-(long)v) * N_bsf64) >> 58] : -1; public static int IndexOfMSB(ulong v) { if ((long)v <= 0) return (int)((v >> 57) & 64) - 1; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v |= v >> 32; return bsr64[(v * N_bsr64) >> 58]; }
typedef int Vector3d[3]; void transform(Vector3d *vector); /* equivalent to `void transform(int (*vector)[3])` */ ... Vector3d vec; ... transform(&vec);
extern void foo(char (*p)[10]); void bar() { char p[10]; foo(p); }
char p[10]; char* p = (char*)malloc(10 * sizeof(char));
void foo(char (*p)[10]) { char c = (*p)[3]; (*p)[0] = 1; }
void foo(char (*p)[10]) { char *cp = (char *)p; char c = cp[3]; cp[0] = 1; }
int main() { int* p; p = (int*)malloc(sizeof(int)); *p = 10; return 0; }
Buffer I/O error on device dm-0, logical block 12345 lost page write due to I/O error on dm-0
Buffer I/O error on dev dm-0, logical block 12345, lost async page write
set_bit(AS_EIO, &page->mapping->flags); set_buffer_write_io_error(bh); clear_buffer_uptodate(bh); SetPageError(page);
set_bit(AS_EIO, &page->mapping->flags); set_buffer_write_io_error(bh); clear_buffer_uptodate(bh); SetPageError(page);
168 * SYNC_FILE_RANGE_WAIT_BEFORE and SYNC_FILE_RANGE_WAIT_AFTER will detect any 169 * I/O errors or ENOSPC conditions and will return those to the caller, after 170 * clearing the EIO and ENOSPC flags in the address_space.
301 302 if (test_and_clear_bit(AS_ENOSPC, &mapping->flags)) 303 ret = -ENOSPC; 304 if (test_and_clear_bit(AS_EIO, &mapping->flags)) 305 ret = -EIO;
buffer_io_error(bh, ", lost async page write"); mapping_set_error(page->mapping, -EIO); set_buffer_write_io_error(bh); clear_buffer_uptodate(bh); SetPageError(page);
if (test_bit(AS_EIO, &mapping->flags) && test_and_clear_bit(AS_EIO, &mapping->flags)) ret = -EIO;
if (test_bit(AS_EIO, &mapping->flags) && test_and_clear_bit(AS_EIO, &mapping->flags)) ret = -EIO; return ret;
sudo dd if=/dev/zero of=/tmp/ext bs=1M count=100 sudo mke2fs -j -T ext4 /tmp/ext sudo mount -o loop /tmp/ext /mnt/tmp sudo perf probe filemap_check_errors sudo perf record -g -e probe:end_buffer_async_write -e probe:filemap_check_errors dd if=/dev/zero of=/mnt/tmp/test bs=4k count=1 conv=fsync
---__GI___libc_fsync entry_SYSCALL_64_fastpath sys_fsync do_fsync vfs_fsync_range ext4_sync_file filemap_write_and_wait_range filemap_check_errors
int main() { int fd; char * myfifo = "/tmp/myfifo"; /* create the FIFO (named pipe) */ mkfifo(myfifo, 0666); fd = open(myfifo, O_WRONLY); write(fd, "Hi", sizeof("Hi")); close(fd); unlink(myfifo); return 0; }
int main() { int fd; char * myfifo = "/tmp/myfifo"; char buf[MAX_BUF]; fd = open(myfifo, O_RDONLY); read(fd, buf, MAX_BUF); printf("Received: %s\n", buf); close(fd); return 0; }
/***************************************************************************** Excerpt from "Linux Programmer (C)opyright 1994-1995, Scott Burkett ***************************************************************************** MODULE: pipe.c *****************************************************************************/ int main(void) { int fd[2], nbytes; pid_t childpid; char string[] = "Hello, world!\n"; char readbuffer[80]; pipe(fd); if((childpid = fork()) == -1) { perror("fork"); exit(1); } if(childpid == 0) { close(fd[0]); write(fd[1], string, (strlen(string)+1)); exit(0); } else { close(fd[1]); nbytes = read(fd[0], readbuffer, sizeof(readbuffer)); printf("Received string: %s", readbuffer); } return(0); }
char reading[ 1025 ]; int fdin = 0, r_control; if( dup2( STDIN_FILENO, fdin ) < 0 ){ perror( "dup2( )" ); exit( errno ); } memset( reading, while( ( r_control = read( fdin, reading, 1024 ) ) > 0 ){ printf( "<%s>", reading ); memset( reading, } if( r_control < 0 ) perror( "read( )" ); close( fdin );
int main() { char buff[1024] = {0}; FILE* cvt; int status; cvt = popen("converter", "w"); if (!cvt) { printf("couldn exit(1) } printf("enter Fahrenheit degrees: " ); fgets(buff, sizeof (buff), stdin); fprintf(cvt, "%s\n", buff); fflush(cvt); status=pclose(cvt); /* Check the exit status of pclose() */ if (!WIFEXITED(status)) printf("error on closing the pipe\n"); return 0; }
int main(){ int p, f; int rw_setup[2]; char message[20]; p = pipe(rw_setup); if(p < 0){ printf("An error occured. Could not create the pipe."); _exit(1); } f = fork(); if(f > 0){ write(rw_setup[1], "Hi from Parent", 15); } else if(f == 0){ read(rw_setup[0],message,15); printf("%s %d\n", message, r_return); } else{ printf("Could not create the child process"); } return 0; }
/* * Now find a thread we can wake up to take the signal off the queue. * * If the main thread wants the signal, it gets first crack. * Probably the least surprising to the average bear. */ if (wants_signal(sig, p)) t = p; else if (!group || thread_group_empty(p)) /* * There is just one thread and it does not need to be woken. * It will dequeue unblocked signals before it runs again. */ return; else { /* * Otherwise try to find a suitable thread. */ t = signal->curr_target; while (!wants_signal(sig, t)) { t = next_thread(t); if (t == signal->curr_target) /* * No thread needs to be woken. * Any eligible threads will see * the signal in the queue soon. */ return; } signal->curr_target = t; } /* * Found a killable thread. If the signal will be fatal, * then start taking the whole group down immediately. */ if (sig_fatal(p, sig) && !(signal->flags & SIGNAL_GROUP_EXIT) && !sigismember(&t->real_blocked, sig) && (sig == SIGKILL || !p->ptrace)) { /* * This signal will be fatal to the whole group. */
void *sys_call_table[__NR_syscalls] = { [0 ... __NR_syscalls-1] = sys_ni_syscall, };
int widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };
int nanosleep(const struct timespec *req, struct timespec *rem);
void sleep_ms(int milliseconds) { Sleep(milliseconds); struct timespec ts; ts.tv_sec = milliseconds / 1000; ts.tv_nsec = (milliseconds % 1000) * 1000000; nanosleep(&ts, NULL); usleep(milliseconds * 1000); }
int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);
int main () { puts("Program Will Sleep For 2 Seconds"); system("sleep 2"); return 0; }
int main (void) { char string [] = "stackoverflow"; char *first, *second; first = string; second = string; puts(string); memcpy(first+5, first, 5); puts(first); memmove(second+5, second, 5); puts(second); return 0; }
int main (void) { char string [] = "stackoverflow"; char *third, *fourth; third = string; fourth = string; puts(string); memcpy(third+5, third, 7); puts(third); memmove(fourth+5, fourth, 7); puts(fourth); return 0; }
1. stackoverflow 2. stacksverflow 3. stacksterflow 4. stackstarflow 5. stackstacflow 6. stackstacklow 7. stackstacksow 8. stackstackstw
void memmove ( void * dst, const void * src, size_t count ) { if ((uintptr_t)src < (uintptr_t)dst) { } else if ((uintptr_t)dst < (uintptr_t)src) { } } void mempy ( void * dst, const void * src, size_t count ) { if ((uintptr_t)src != (uintptr_t)dst) { } }
void memmove ( void * dst, const void * src, size_t count ) { if ((uintptr_t)src < (uintptr_t)dst && (uintptr_t)src + count > (uintptr_t)dst) { } else if ((uintptr_t)dst < (uintptr_t)src && (uintptr_t)dst + count > (uintptr_t)src ) { } else { memcpy(dst, src, count); } }
int main (void) { char string [] = "stackoverflow"; char *third, *fourth; third = string; fourth = string; puts(string); memcpy(third+5, third, 7); puts(third); memmove(fourth+5, fourth, 7); puts(fourth); return 0; }
int main (void) { char string [] = "stackoverflow"; char *first, *second; first = string; second = string; puts(string); memcpy(first+5, first,7); puts(first); memcpy(second+5, second, 7); puts(second); return 0; }
char *first, *second; first = string; second = string; puts(string);
struct PackedStructure { char a; int b; short c; };
struct PackedStructure __attribute__((__packed__)) { char a; int b; short c; };
int main() { { int i = omp_get_thread_num(); printf_s("Hello from thread %d\n", i); } }
Hello from thread 0 Hello from thread 1 Hello from thread 2 Hello from thread 3 Note that the order of output can vary on different machines.
void __attribute__((constructor)) func1(); void __attribute__((destructor)) func2();
int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9}; int b[20]; /* Uninitialized, so in the .bss and will not occupy space for 20 * sizeof (int) */ int main () { ; }
int var[10]; int main () { var[0] = 20 /* **Initialized, where this }
for(i=0; i<all_explicitly_initialized_objects; i++) { .data[i] = init_value[i]; } memset(.bss, 0, all_implicitly_initialized_objects);
static uint8_t l_matrix[10][20]; void test(){ uint8_t **matrix_ptr = l_matrix; }
typedef uint8_t array_of_20_uint8_t[20]; array_of_20_uint8_t *matrix_ptr = l_matrix;
(*matrix_ptr)[0][1] = ...; matrix_ptr[0][0][1] = ...;
matrix_ptr[0] = ...; matrix_ptr[19] = ...; matrix_ptr[20] = ...; matrix_ptr[10*20-1] = ...;
{ {1, 2, 3, 4, 5} {6, 7, 8, 9, 10} {11, 12, 13, 14, 15} } { {16, 17, 18, 19, 20} {21, 22, 23, 24, 25} {26, 27, 28, 29, 30} } { {31, 32, 33, 34, 35} {36, 37, 38, 39, 40} {41, 42, 43, 44, 45} } { {46, 47, 48, 49, 50} {51, 52, 53, 54, 55} {56, 57, 58, 59, 60} }
typedef uint8_t array_of_20_uint8_t[20]; array_of_20_uint8_t *matrix_ptr = l_matrix;
int l_matrix[10][20]; void test(int matrix_ptr[static 10][20]) { } int main(void) { test(l_matrix); }
static uint8_t l_matrix[200]; void test(int row, int col, uint8_t val) { uint8_t* matrix_ptr = l_matrix; matrix_ptr [col+y*row] = val; }
static uint8_t l_matrix[10][20]; void test(){ uint8_t *matrix_ptr = l_matrix[0]; }
int main() { char balance[5][100] = { {"Subham"},{"Messi"} }; char (*p)[5][100]=&balance; printf("%s\n",(*p)[0]); printf("%s\n",(*p)[1]); return 0; }
uint8_t l_matrix[10][20]; uint8_t (*matrix_ptr)[20] = l_matrix+5; matrix_ptr[-4][1]=7;
uint8_t (*matrix_ptr)[20] = (uint8_t (*)[20]) l_matrix;
long random_at_most(long max) { unsigned long num_bins = (unsigned long) max + 1, num_rand = (unsigned long) RAND_MAX + 1, bin_size = num_rand / num_bins, defect = num_rand % num_bins; long x; do { x = random(); } while (num_rand - defect <= (unsigned long)x); return x/bin_size; }
unsigned int rand_interval(unsigned int min, unsigned int max) { int r; const unsigned int range = 1 + max - min; const unsigned int buckets = RAND_MAX / range; const unsigned int limit = buckets * range; /* Create equal size buckets all in a row, then fire randomly towards * the buckets until you land in one of them. All buckets are equally * likely. If you land off the end of the line of buckets, try again. */ do { r = rand(); } while (r >= limit); return min + (r / buckets); }
unsigned int randr(unsigned int min, unsigned int max) { double scaled = (double)rand()/RAND_MAX; return (max - min +1)*scaled + min; }
r = n / 2; r = (rand() * n + r) / (RAND_MAX + 1); r = (rand() * n + r) / (RAND_MAX + 1); r = (rand() * n + r) / (RAND_MAX + 1); ...
arc4random_uniform(20-10)+10 arc4random_uniform(10)+10
uint32_t getRandInterval(uint32_t begin, uint32_t end) { uint32_t range = (end - begin) + 1; uint32_t limit = ((uint64_t)RAND_MAX + 1) - (((uint64_t)RAND_MAX + 1) % range); /* Imagine range-sized buckets all in a row, then fire randomly towards * the buckets until you land in one of them. All buckets are equally * likely. If you land off the end of the line of buckets, try again. */ uint32_t randVal = rand(); while (randVal >= limit) randVal = rand(); return (randVal % range) + begin; }
Example (RAND_MAX := 16, begin := 2, end := 7) => range := 6 (1 + end - begin) => limit := 12 (RAND_MAX + 1) - ((RAND_MAX + 1) % range) The limit is always a multiple of the range, so we can split it into range-sized buckets: Possible-rand-output: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Buckets: [0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5][X, X, X, X, X] Buckets + begin: [2, 3, 4, 5, 6, 7][2, 3, 4, 5, 6, 7][X, X, X, X, X] 1st call to rand() => 13 → 13 is not in the bucket-range anymore (>= limit), while-condition is true → retry... 2nd call to rand() => 7 → 7 is in the bucket-range (< limit), while-condition is false → Get the corresponding bucket-value 1 (randVal % range) and add begin => 3
Rnd distribution test (22 boxes, numbers of entries in each box): 1: 409443 4.55% 2: 408736 4.54% 3: 408557 4.54% 4: 409125 4.55% 5: 408812 4.54% 6: 409418 4.55% 7: 408365 4.54% 8: 407992 4.53% 9: 409262 4.55% 10: 408112 4.53% 11: 409995 4.56% 12: 409810 4.55% 13: 409638 4.55% 14: 408905 4.54% 15: 408484 4.54% 16: 408211 4.54% 17: 409773 4.55% 18: 409597 4.55% 19: 409727 4.55% 20: 409062 4.55% 21: 409634 4.55% 22: 409342 4.55% total: 100.00%
int rdrand64_step(unsigned long long int *therand) { unsigned long long int foo; int cf_error_status; asm("rdrand %%rax; \ mov $1,%%edx; \ cmovae %%rax,%%rdx; \ mov %%edx,%1; \ mov %%rax, %0;":"=r"(foo),"=r"(cf_error_status)::"%rax","%rdx"); *therand = foo; return cf_error_status; }
static uint32_t randomInRange(uint32_t a,uint32_t b) { uint32_t v; uint32_t range; uint32_t upper; uint32_t lower; uint32_t mask; if(a == b) { return a; } if(a > b) { upper = a; lower = b; } else { upper = b; lower = a; } range = upper - lower; mask = 0; while(1) { if(mask >= range) { break; } mask = (mask << 1) | 1; } while(1) { v = rand() & mask; if(v <= range) { return lower + v; } } }
int main() { unsigned long long int i; unsigned int n = 10; unsigned int numbers[n]; for (i = 0; i < n; i++) { numbers[i] = 0; } for (i = 0 ; i < 10000000 ; i++){ uint32_t rand = random_in_range(0,n - 1); if(rand >= n){ printf("bug: rand out of range %u\n",(unsigned int)rand); return 1; } numbers[rand] += 1; } for(i = 0; i < n; i++) { printf("%u: %u\n",i,numbers[i]); } }
static int Inc(int i) {return i+1}; .... int i; .... for (i=0; i<999999; i = Inc(i)) { };
printf("%1.3f", 359.01335); printf("%1.3f", 359.00999);
char str[50]; sprintf (str,"%.20g",num); morphNumericString (str, 3); : : void morphNumericString (char *s, int n) { char *p; int count; p = strchr (s, if (p != NULL) { count = n; while (count >= 0) { count--; if (*p == break; p++; } *p-- = while (*p == *p-- = if (*p == *p = } } }
void nDecimals (char *s, double d, int n) { int sz; double d2; d2 = (d >= 0) ? d : -d; sz = (d >= 0) ? 0 : 1; if (d2 < 1) sz++; while (d2 >= 1) { d2 /= 10.0; sz++; } sz += 1 + n; sprintf (s, "%*.*f", sz, n, d); } int main (void) { char str[50]; double num[] = { 40, 359.01335, -359.00999, 359.01, 3.01357, 0.111111111, 1.1223344 }; for (int i = 0; i < sizeof(num)/sizeof(*num); i++) { nDecimals (str, num[i], 3); printf ("%30.20f -> %s\n", num[i], str); } return 0; }
40.00000000000000000000 -> 40.000 359.01335000000000263753 -> 359.013 -359.00999000000001615263 -> -359.010 359.00999999999999090505 -> 359.010 3.01357000000000008200 -> 3.014 0.11111111099999999852 -> 0.111 1.12233439999999995429 -> 1.122
nDecimals (str, num[i], 3); morphNumericString (str, 3);
40.00000000000000000000 -> 40 359.01335000000000263753 -> 359.013 -359.00999000000001615263 -> -359.01 359.00999999999999090505 -> 359.01 3.01357000000000008200 -> 3.014 0.11111111099999999852 -> 0.111 1.12233439999999995429 -> 1.122
float f = 1234.56789; printf("%d.%.0f", f, 1000*(f-(int)f));
double f = 1234.05678900; char s[100]; int decimals = 10; sprintf(s,"%.*g", decimals, ((int)(pow(10, decimals)*(fabs(f) - abs((int)f)) +0.5))/pow(10,decimals)); printf("10 decimals: %d%s\n", (int)f, s+1);
int main(void){ double f = 1234.05678900; char s[100]; int decimals; decimals = 10; sprintf(s,"%.*g", decimals, ((int)(pow(10, decimals)*(fabs(f) - abs((int)f)) +0.5))/pow(10,decimals)); printf("10 decimals: %d%s\n", (int)f, s+1); decimals = 3; sprintf(s,"%.*g", decimals, ((int)(pow(10, decimals)*(fabs(f) - abs((int)f)) +0.5))/pow(10,decimals)); printf(" 3 decimals: %d%s\n", (int)f, s+1); f = -f; decimals = 10; sprintf(s,"%.*g", decimals, ((int)(pow(10, decimals)*(fabs(f) - abs((int)f)) +0.5))/pow(10,decimals)); printf(" negative 10: %d%s\n", (int)f, s+1); decimals = 3; sprintf(s,"%.*g", decimals, ((int)(pow(10, decimals)*(fabs(f) - abs((int)f)) +0.5))/pow(10,decimals)); printf(" negative 3: %d%s\n", (int)f, s+1); decimals = 2; f = 1.012; sprintf(s,"%.*g", decimals, ((int)(pow(10, decimals)*(fabs(f) - abs((int)f)) +0.5))/pow(10,decimals)); printf(" additional : %d%s\n", (int)f, s+1); return 0; }
10 decimals: 1234.056789 3 decimals: 1234.057 negative 10: -1234.056789 negative 3: -1234.057 additional : 1.01
void stripTrailingZeros(void) { int i = 20; unsigned char char1 = 0; while ((char1 > 57) || (char1 < 49)) { i--; char1 = sprintfBuffer[i]; } for (int j = i; j < 20; j++) { sprintfBuffer[i] = 0; } }
printf("%.0d%.4g\n", (int)f/10, f-((int)f-(int)f%10));
int DoubleEquals(double i, double j) { return (fabs(i - j) < 0.000001); } void PrintMaxThreeDecimal(double d) { if (DoubleEquals(d, floor(d))) printf("%.0f", d); else if (DoubleEquals(d * 10, floor(d * 10))) printf("%.1f", d); else if (DoubleEquals(d * 100, floor(d* 100))) printf("%.2f", d); else printf("%.3f", d); }
void PrintMaxTwoDecimal(double d) { if (DoubleEquals(d, floor(d))) printf("%.0f", d); else if (DoubleEquals(d * 10, floor(d * 10))) printf("%.1f", d); else printf("%.2f", d); }
void PrintAlignedMaxThreeDecimal(double d) { if (DoubleEquals(d, floor(d))) printf("%7.0f", d); else if (DoubleEquals(d * 10, floor(d * 10))) printf("%9.1f", d); else if (DoubleEquals(d * 100, floor(d* 100))) printf("%10.2f", d); else printf("%11.3f", d); }
void PrintAlignedWidthMaxThreeDecimal(int w, double d) { if (DoubleEquals(d, floor(d))) printf("%*.0f", w-4, d); else if (DoubleEquals(d * 10, floor(d * 10))) printf("%*.1f", w-2, d); else if (DoubleEquals(d * 100, floor(d* 100))) printf("%*.2f", w-1, d); else printf("%*.3f", w, d); }
int doubleEquals(double i, double j) { return (fabs(i - j) < 0.000001); } void printTruncatedDouble(double dd, int max_len) { char str[50]; int match = 0; for ( int ii = 0; ii < max_len; ii++ ) { if (doubleEquals(dd * pow(10,ii), floor(dd * pow(10,ii)))) { sprintf (str,"%f", round(dd*pow(10,ii))/pow(10,ii)); match = 1; break; } } if ( match != 1 ) { sprintf (str,"%f", round(dd*pow(10,max_len))/pow(10,max_len)); } char *pp; int count; pp = strchr (str, if (pp != NULL) { count = max_len; while (count >= 0) { count--; if (*pp == break; pp++; } *pp-- = while (*pp == *pp-- = if (*pp == *pp = } } printf ("%s\n", str); } int main(int argc, char **argv) { printTruncatedDouble( -1.999, 2 ); printTruncatedDouble( -1.006, 2 ); printTruncatedDouble( -1.005, 2 ); printf("\n"); printTruncatedDouble( 1.005, 2 ); printTruncatedDouble( 1.006, 2 ); printTruncatedDouble( 1.999, 2 ); printf("\n"); printTruncatedDouble( -1.999, 3 ); printTruncatedDouble( -1.001, 3 ); printTruncatedDouble( -1.0005, 3 ); printTruncatedDouble( -1.0004, 3 ); printf("\n"); printTruncatedDouble( 1.0004, 3 ); printTruncatedDouble( 1.0005, 3 ); printTruncatedDouble( 1.001, 3 ); printTruncatedDouble( 1.999, 3 ); printf("\n"); exit(0); }
char* format_double(double d) { int size = snprintf(NULL, 0, "%.3f", d); char *str = malloc(size + 1); snprintf(str, size + 1, "%.3f", d); for (int i = size - 1, end = size; i >= 0; i--) { if (str[i] == if (end == i + 1) { end = i; } } else if (str[i] == if (end == i + 1) { end = i; } str[end] = break; } } return str; }
double f = 359.01335; printf("%g", round(f * 1000.0) / 1000.0);
void EliminateTrailingFloatZeros(char *iValue) { char *p = 0; for(p=iValue; *p; ++p) { if( while(*++p); while( if(*p == break; } } }
printf("%1.3f", 359.01335); printf("%1.3f", 359.00999);
printf("%1.3f", 359.01335); printf("%1.2f", 359.00999);
printf("%1.3f\n", 359.01335); printf("%1.2f\n", 359.00999);
int main() { printf("%1.3f\n", 359.01335); printf("%1.2f\n", 359.00999); while (true){} return 0; }
int main (void) { char buffer[512]; snprintf(buffer, sizeof(buffer), "SomeString"); return 0; }
int snprintf( char* buffer, std::size_t buf_size, const char* format, ... );
__inline int c99_vsnprintf(char *outBuf, size_t size, const char *format, va_list ap) { int count = -1; if (size != 0) count = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap); if (count == -1) count = _vscprintf(format, ap); return count; } __inline int c99_snprintf(char *outBuf, size_t size, const char *format, ...) { int count; va_list ap; va_start(ap, format); count = c99_vsnprintf(outBuf, size, format, ap); va_end(ap); return count; }
extern "C" { int vasprintf(char **strp, const char *fmt, va_list ap); int asprintf(char **strp, const char *fmt, ...); }
int asprintf(char **strp, const char *fmt, ...) { int r; va_list ap; va_start(ap, fmt); r = vasprintf(strp, fmt, ap); va_end(ap); return(r); }
int vasprintf(char **strp, const char *fmt, va_list ap) { int r = -1, size = _vscprintf(fmt, ap); if ((size >= 0) && (size < INT_MAX)) { *strp = (char *)malloc(size+1); if (*strp) { r = vsnprintf(*strp, size+1, fmt, ap); if ((r < 0) || (r > size)) { insane_free(*strp); r = -1; } } } else { *strp = 0; } return(r); }
int main() { char *s; if (asprintf(&s, "Hello, %d in hex padded to 8 digits is: %08x\n", 15, 15) != -1) { puts(s); insane_free(s); } }
|a|b|c|d|e|f|g| ^------------ arr[0] ^---------- arr[1] ^---------------- arr[-2]
Base Address of your Array a + (index of array *size of(data type for array a)) Base Address of your Array a + (5*size of(data type for array a)) i.e. 1000 + (5*2) = 1010
Base Address of your Array a + (index of array *size of(data type for array a)) Base Address of your Array a + (-5 * size of(data type for array a)) i.e. 1000 + (-5*2) = 990
typedef struct __attribute__((packed, aligned(4))) Ball { float2 delta; float2 position; float size; } Ball_t; Ball_t *balls;
typedef struct { char Data1; int Data2; unsigned short Data3; char Data4; }sSampleStruct;
typedef struct { char Data1; int Data2; unsigned short Data3; char Data4; }sSampleStruct;
typedef struct { char Data1; int Data2; unsigned short Data3; char Data4; }__attribute__((packed, aligned(1))) sSampleStruct;
void PrintSize(int p_someArray[10]); int main () { int myArray[10]; printf("%d\n", sizeof(myArray)); PrintSize(myArray); } void PrintSize(int p_someArray[10]){ printf("%d\n", sizeof(p_someArray)); }
void PrintSize(int p_someArray[10]) { printf("%zu\n", sizeof(p_someArray)); }
void PrintSize(int *p_someArray) { printf("%zu\n", sizeof(p_someArray)); }
void PrintSize1 ( int someArray[][10] ); void PrintSize2 ( int someArray[10] ); int main () { int myArray[10]; printf ( "%d\n", sizeof myArray ); printf ( "%d\n", sizeof ( int[10] ) ); PrintSize1 ( 0 ); PrintSize2 ( 0 ); } void PrintSize1 ( int someArray[][10] ) { printf ( "%d\n", sizeof someArray[0] ); } void PrintSize2 ( int someArray[10] ) { printf ( "%d\n", sizeof ( int[10] ) ); }
void func(int *a) void func(int a[]) void func(int a typedef int array_plz[5]; void func(array_plz a)
struct array_rly { int a[5]; }; void func(struct array_rly a) { printf("%zd\n", sizeof(a.a)/sizeof(a.a[0])); }
void func(const int (*a)[5]) { printf("%zd\n", sizeof(*a)/sizeof((*a)[0])); }
void func(int n, const int (*a)[n]) { printf("%zd\n", sizeof(*a)/sizeof((*a)[0])); }
void foo(int (&array)[10]) { std::cout << sizeof(array) << "\n"; }
void PrintSize(int (*p_anArray)[10]); int main(void) { int myArray[10]; printf("%d\n", sizeof(myArray)); PrintSize(&myArray); } void PrintSize(int (*p_anArray)[10]){ printf("%d\n", (int) sizeof(*p_anArray)); }
main(){ int n[10]; printf("Size of n is: %d \n", sizeof(n)); }
int n[] = { 1, 2, 3, 44, 6, 7 }; printf("Number of elements: %d \n", sizeof(n) / sizeof(int)); return 0;
void function(int* array) { int a =5; } void main() { int array[]={2,4}; function(array); getch(); }
push ebp mov ebp, esp sub esp, 18h and esp, 0FFFFFFF0h mov eax, 0 add eax, 0Fh add eax, 0Fh shr eax, 4 shl eax, 4 mov [ebp+var_C], eax mov eax, [ebp+var_C] call sub_401730 call sub_4013D0 mov [ebp+var_8], 2 mov [ebp+var_4], 4 lea eax, [ebp+var_8] mov [esp+18h+var_18], eax call sub_401290 call _getch leave retn
int a[5]={a[2]=1}; printf("%d %d %d %d %d\n", a[0], a[1],a[2], a[3], a[4]);
char str[10]={‘H’,‘a’,‘i’}; char str[0] = ‘H’; char str[1] = ‘a’; char str[2] = ‘i;
0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 3 1 2 3 1 2 3
char *p = "String"; char p2[] = "String"; char p3[7] = "String";
char *p = "String"; means pointer to a string type variable.
int main() { printf("%sred\n", KRED); printf("%sgreen\n", KGRN); printf("%syellow\n", KYEL); printf("%sblue\n", KBLU); printf("%smagenta\n", KMAG); printf("%scyan\n", KCYN); printf("%swhite\n", KWHT); printf("%snormal\n", KNRM); return 0; }
int main() { printf(RED "red\n" RESET); printf(GRN "green\n" RESET); printf(YEL "yellow\n" RESET); printf(BLU "blue\n" RESET); printf(MAG "magenta\n" RESET); printf(CYN "cyan\n" RESET); printf(WHT "white\n" RESET); return 0; }
printf("This is " RED "red" RESET " and this is " BLU "blue" RESET "\n");
man free The free() function deallocates the memory allocation pointed to by ptr. If ptr is a NULL pointer, no operation is performed.
for(T * item = list->head; item != NULL; item = item->next)
for(int keep = 1, \ count = 0,\ size = sizeof (array) / sizeof *(array); \ keep && count != size; \ keep = !keep, count++) \ for(item = (array) + count; keep; keep = !keep)
int values[] = { 1, 2, 3 }; foreach(int *v, values) { printf("value: %d\n", *v); }
typedef struct list_node list_node; struct list_node { list_node *next; void *data; }; for (list_node *(item) = (list); (item); (item) = (item)->next) int main(int argc, char *argv[]) { list_node list[] = { { .next = &list[1], .data = "test 1" }, { .next = &list[2], .data = "test 2" }, { .next = NULL, .data = "test 3" } }; FOR_EACH(item, list) puts((char *) item->data); return 0; }
char* nullTerm; nullTerm = "Loop through my characters"; for(;nullTerm != NULL;nullTerm++) { }
__extension__ \ ({ \ bool ret = 0; \ if (__builtin_types_compatible_p (const char*, ARRAY_TYPE)) \ ret = INDEX < strlen ((const char*)ARRAY); \ else \ ret = INDEX < SIZE; \ ret; \ }) __extension__ \ ({ \ TYPE *tmp_array_ = ARRAY; \ &tmp_array_[INDEX]; \ }) for (void *array_ = (void*)(ARRAY); array_; array_ = 0) \ for (size_t i_ = 0; i_ && array_ && FOREACH_COMP (i_, array_, \ __typeof__ (ARRAY), \ sizeof (ARRAY) / sizeof ((ARRAY)[0])); \ i_++) \ for (bool b_ = 1; b_; (b_) ? array_ = 0 : 0, b_ = 0) \ for (VAR = FOREACH_ELEM (i_, array_, __typeof__ ((ARRAY)[0])); b_; b_ = 0) int main (int argc, char **argv) { int array[10]; int i = 0; FOREACH (int *x, array) { *x = i; ++i; } char *str = "hello, world!"; FOREACH (char *c, str) printf ("%c\n", *c); return EXIT_SUCCESS; }
int arr[] = {1,2,3,4,5}; for(int *a = arr; a < (&arr)[1]; ++a) printf("%d\n", *a);
(typeof(*(array)) *p = (array), (item) = *p; p < &((array)[length]); p++, (item) = *p)
typedef struct _point { double x; double y; } Point; int main(void) { double some_nums[] = {4.2, 4.32, -9.9, 7.0}; for each (element, some_nums, 4) printf("element = %lf\n", element); int numbers[] = {4, 2, 99, -3, 54}; for each (number, numbers, 5) { printf("number = %d\n", number); if (number % 2 == 0) printf("%d is even.\n", number); } char *dictionary[] = {"Hello", "World"}; for each (word, dictionary, 2) printf("word = Point points[] = {{3.4, 4.2}, {9.9, 6.7}, {-9.8, 7.0}}; for each (point, points, 3) printf("point = (%lf, %lf)\n", point.x, point.y); return 0; }
for ( Element* element = GetFirstElement(&collection); element != 0; element = GetNextElement(&collection, element) ) { }
for (unsigned i = 0, __a = 1; i < B.size(); i++, __a = 1)
for (unsigned i = 0, __a = 1; __a && i < B.size(); i++, __a = 1)
type it = array[0]; \ for(int i = 0; i < size; i++, it = array[i]) int array[] = { 1, 2, 3, 4, 5 }; FOREACH(int, array, 5) { printf("element: %d. index: %d\n", it, i); } ENDFOR
for(int i = start, keep = 1;\ keep && i < size;\ keep = !keep, i++)\ for (item = array[i]; keep; keep = !keep) int array[] = { 1, 2, 3, 4, 5 }; FOREACH(int x, array, 2, 5) printf("index: %d. element: %d\n", i, x);
index: 2. element: 3 index: 3. element: 4 index: 4. element: 5
typedef struct job_t { int count; int* arr; } arr_t;
size_t X(keep), X(i); \ type item; \ for (X(keep) = 1, X(i) = 0 ; X(i) < (size); X(keep) = !X(keep), X(i)++) \ for (item = (array)[X(i)]; X(keep); X(keep) = 0)
int ints[] = {1, 2, 0, 3, 4}; foreach (i in ints) printf("%i", i); foreach (x in ints) printf("%i", x);
({ return_type __fn__ function_body __fn__; }) void (*action)(type item) = func;\ for (int i = 0; i<arr_length; i++) action(arr[i]);\ } foreachnf(type, item, arr, array_len(arr), func) foreachnf(type, item, arr, arr_length, lambda(void, (type item) body)) foreachn(type, item, arr, array_len(arr), body)
int ints[] = { 1, 2, 3, 4, 5 }; foreach(int, i, ints, { printf("%d\n", i); }); char* strs[] = { "hi!", "hello!!", "hello world", "just", "testing" }; foreach(char*, s, strs, { printf("%s\n", s); }); char** strsp = malloc(sizeof(char*)*2); strsp[0] = "abcd"; strsp[1] = "efgh"; foreachn(char*, s, strsp, 2, { printf("%s\n", s); }); void (*myfun)(int i) = somefunc; foreachf(int, i, ints, myfun);
template <typename t> struct list { struct elem { t Data; elem* Next; }; elem* Head; elem* Tail; }; bool _ for (list<TYPE>::elem* NAME NAME _ for (auto& NAME = NAME void example() { list<string> Words; for_list(string, Word, Words) { print(Word); } }
void example2() { list<string> Words; for_each_item(string, Elem, Words) { string& Word = Elem->Data; print(Word); } }
Struct TitleCase Struct Members lower_case or lowerCase Enum ETitleCase Enum Members ALL_CAPS or lowerCase Public functions pfx_TitleCase (pfx = two or three letter module prefix) Private functions TitleCase Trivial variables i,x,n,f etc... Local variables lower_case or lowerCase Global variables g_lowerCase or g_lower_case (searchable by g_ prefix)
class MyClass { enum TheEnumeration { FIRST_ELEMENT, SECOND_ELEMENT, } int class_variable; int MyMethod(int first_param, int second_parameter) { int local_variable; TheEnumeration local_enum; for(int myindex=0, myindex<class_variable, myindex++) { localEnum = FIRST_ELEMENT; } } }
Bluetooth_Init() CommsHub_Update() Serial_TxBuffer[]
typdef struct TheName TheName; struct TheName{ int var; TheName *p_link; };
int main(int argc, char ** argv) { printf("this is a test message.\n"); system("ls"); return 0; }
int main(int argc, char ** argv) { printf("this is a test message.\n"); fflush(stdout); system("ls"); return 0; }
$ ./main > foo $ cat foo main main.c this is a test message.
$ ./main > foo $ cat foo this is a test message. foo main main.c
enum E { E0, E1, E2 = 3, E3 = 3, E4, E5 = INT_MAX, }; assert(E0 == 0); assert(E1 == 1); assert(E2 == 3); assert(E3 == 3); assert(E4 == 4); assert(E5 == INT_MAX);
char * getline(void) { char * line = malloc(100), * linep = line; size_t lenmax = 100, len = lenmax; int c; if(line == NULL) return NULL; for(;;) { c = fgetc(stdin); if(c == EOF) break; if(--len == 0) { len = lenmax; char * linen = realloc(linep, lenmax *= 2); if(linen == NULL) { free(linep); return NULL; } line = linen + (line - linep); linep = linen; } if((*line++ = c) == break; } *line = return linep; }
int main() { char string [256]; printf ("Insert your full address: "); gets (string); printf ("Your address is: %s\n",string); return 0; }
int main(void) { char *line = NULL; size_t len = 0; ssize_t read = 0; while (read != -1) { puts("enter a line"); read = getline(&line, &len, stdin); printf("line = %s", line); printf("line length = %zu\n", read); puts(""); } free(line); return 0; }
char line[1024]; char *eof; line[0] = line[sizeof(line)-1] = ~ eof = fgets(line, sizeof(line), stdin);
char* scan_line(char *line) { int ch; if( (line = malloc(sizeof(char))) == NULL) { printf("unsuccessful allocation"); exit(1); } line[0]= for(int index = 0; ( (ch = getchar())!= { if( (line = realloc(line, (index + 2)*sizeof(char))) == NULL ) { printf("unsuccessful reallocation"); exit(1); } line[index] = (char) ch; line[index + 1] = } return line; }
char* scan_line(char *line) { .......... } int main(void) { char *a = NULL; a = scan_line(a); printf("%s\n",a); free(a); }
/* * Initial size of the read buffer */ /* * Standard boolean type definition */ typedef enum{ false = 0, true = 1 }bool; /* * Flags errors in pointer returning functions */ bool has_err = false; /* * Reads the next line of text from file and returns it. * The line must be free()d afterwards. * * This function will segfault on binary data. */ char *readLine(FILE *file){ char *buffer = NULL; char *tmp_buf = NULL; bool line_read = false; int iteration = 0; int offset = 0; if(file == NULL){ fprintf(stderr, "readLine: NULL file pointer passed!\n"); has_err = true; return NULL; } while(!line_read){ if((tmp_buf = malloc(DEFAULT_BUFFER)) == NULL){ fprintf(stderr, "readLine: Unable to allocate temporary buffer!\n"); if(buffer != NULL) free(buffer); has_err = true; return NULL; } if(fgets(tmp_buf, DEFAULT_BUFFER, file) == NULL){ free(tmp_buf); break; } if(tmp_buf[strlen(tmp_buf) - 1] == line_read = true; offset = DEFAULT_BUFFER * (iteration + 1); if((buffer = realloc(buffer, offset)) == NULL){ fprintf(stderr, "readLine: Unable to reallocate buffer!\n"); free(tmp_buf); has_err = true; return NULL; } offset = DEFAULT_BUFFER * iteration - iteration; if(memcpy(buffer + offset, tmp_buf, DEFAULT_BUFFER) == NULL){ fprintf(stderr, "readLine: Cannot copy to buffer\n"); free(tmp_buf); if(buffer != NULL) free(buffer); has_err = true; return NULL; } free(tmp_buf); iteration++; } return buffer; }
size_t line_len; const char *line = fgetln(stdin, &line_len);
unsigned int getConsoleInput(char **pStrBfr) { char * strbfr; int c; unsigned int i; i = 0; strbfr = (char*)malloc(sizeof(char)); if(strbfr==NULL) goto error; while( (c = getchar()) != { strbfr[i] = (char)c; i++; strbfr = (void*)realloc((void*)strbfr,sizeof(char)*(i+1)); if(strbfr==NULL) goto error; } strbfr[i] = *pStrBfr = strbfr; return i + 1; error: *pStrBfr = strbfr; return i + 1; }
char* readLine( FILE* file ) { char buffer[1024]; char* result = 0; int length = 0; while( !feof(file) ) { fgets( buffer, sizeof(buffer), file ); int len = strlen(buffer); buffer[len] = 0; length += len; char* tmp = (char*)malloc(length+1); tmp[0] = 0; if( result ) { strcpy( tmp, result ); free( result ); result = tmp; } strcat( result, buffer ); if( strstr( buffer, "\n" ) break; } return result; } char* line = readLine( stdin ); free( line );
struct nlist { struct nlist *next; char *name; char *defn; }; static struct nlist *hashtab[HASHSIZE]; unsigned hash(char *s) { unsigned hashval; for (hashval = 0; *s != hashval = *s + 31 * hashval; return hashval % HASHSIZE; } struct nlist *lookup(char *s) { struct nlist *np; for (np = hashtab[hash(s)]; np != NULL; np = np->next) if (strcmp(s, np->name) == 0) return np; return NULL; } char *strdup(char *); /* install: put (name, defn) in hashtab */ struct nlist *install(char *name, char *defn) { struct nlist *np; unsigned hashval; if ((np = lookup(name)) == NULL) { np = (struct nlist *) malloc(sizeof(*np)); if (np == NULL || (np->name = strdup(name)) == NULL) return NULL; hashval = hash(name); np->next = hashtab[hashval]; hashtab[hashval] = np; } else free((void *) np->defn); if ((np->defn = strdup(defn)) == NULL) return NULL; return np; } char *strdup(char *s) { char *p; p = (char *) malloc(strlen(s)+1); if (p != NULL) strcpy(p, s); return p; }
typedef struct dict_entry_s { const char *key; int value; } dict_entry_s; typedef struct dict_s { int len; int cap; dict_entry_s *entry; } dict_s, *dict_t; int dict_find_index(dict_t dict, const char *key) { for (int i = 0; i < dict->len; i++) { if (!strcmp(dict->entry[i], key)) { return i; } } return -1; } int dict_find(dict_t dict, const char *key, int def) { int idx = dict_find_index(dict, key); return idx == -1 ? def : dict->entry[idx].value; } void dict_add(dict_t dict, const char *key, int value) { int idx = dict_find_index(dict, key); if (idx != -1) { dict->entry[idx].value = value; return; } if (dict->len == dict->cap) { dict->cap *= 2; dict->entry = realloc(dict->entry, dict->cap * sizeof(dict_entry_s)); } dict->entry[dict->len].key = strdup(key); dict->entry[dict->len].value = value; dict->len++; } dict_t dict_new(void) { dict_s proto = {0, 10, malloc(10 * sizeof(dict_entry_s))}; dict_t d = malloc(sizeof(dict_s)); *d = proto; return d; } void dict_free(dict_t dict) { for (int i = 0; i < dict->len; i++) { free(dict->entry[i].key); } free(dict->entry); free(dict); }
typedef struct { int** lines; int isDefined; }mat; mat matA, matB, matC, matD, matE, matF; typedef struct { char* str; mat *matrix; }stringToMat; stringToMat matCases [] = { { "mat_a", &matA }, { "mat_b", &matB }, { "mat_c", &matC }, { "mat_d", &matD }, { "mat_e", &matE }, { "mat_f", &matF }, }; mat* getMat(char * str) { stringToMat* pCase; mat * selected = NULL; if (str != NULL) { for(pCase = matCases; pCase != matCases + sizeof(matCases) / sizeof(matCases[0]); pCase++ ) { if(!strcmp( pCase->str, str)) selected = (pCase->matrix); } if (selected == NULL) printf("%s is not a valid matrix name\n", str); } else printf("expected matrix name, got NULL\n"); return selected; }
main() { int c, nl, nw, nc, state; state = OUT; nl = nw = nc = 0; while ((c = getchar()) != EOF) { ++nc; if (c == ++nl; if (c == state = OUT; else if (state == OUT) { state = IN; ++nw; } } printf("%d %d %d\n", nl, nw, nc); }
$ gcc wc.c wc.c: In function ‘main’: wc.c:18: error: ‘else’ without a previous ‘if’ wc.c:18: error: expected ‘)’ before ‘;’ token
if (c == state = 0;; else if (state == 0;) { state = 1;;
if (c == state = OUT; } else if (state == OUT) { state = IN; ++nw; }
if (c == ++nl; } if (c == state = OUT; } else if (state == OUT) { state = IN; ++nw; }
if (c == ++nl; } if (c == { state = OUT; } else if (state == OUT) { state = IN; ++nw; }
bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr));
listen(sockfd,5); newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen); read(newsockfd,buffer,255);
void InitializeSSL() { SSL_load_error_strings(); SSL_library_init(); OpenSSL_add_all_algorithms(); } void DestroySSL() { ERR_free_strings(); EVP_cleanup(); } void ShutdownSSL() { SSL_shutdown(cSSL); SSL_free(cSSL); }
int sockfd, newsockfd; SSL_CTX *sslctx; SSL *cSSL; InitializeSSL(); sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd< 0) { return; } struct sockaddr_in saiServerAddress; bzero((char *) &saiServerAddress, sizeof(saiServerAddress)); saiServerAddress.sin_family = AF_INET; saiServerAddress.sin_addr.s_addr = serv_addr; saiServerAddress.sin_port = htons(aPortNumber); bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)); listen(sockfd,5); newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen); sslctx = SSL_CTX_new( SSLv23_server_method()); SSL_CTX_set_options(sslctx, SSL_OP_SINGLE_DH_USE); int use_cert = SSL_CTX_use_certificate_file(sslctx, "/serverCertificate.pem" , SSL_FILETYPE_PEM); int use_prv = SSL_CTX_use_PrivateKey_file(sslctx, "/serverCertificate.pem", SSL_FILETYPE_PEM); cSSL = SSL_new(sslctx); SSL_set_fd(cSSL, newsockfd ); ssl_err = SSL_accept(cSSL); if(ssl_err <= 0) { ShutdownSSL(); }
SSL_read(cSSL, (char *)charBuffer, nBytesToRead); SSL_write(cSSL, "Hi :3\n", 6);
using namespace std; int main(int argc, char *argv[]) { BreakermindSslServer boom; boom.Start(123,"/home/user/c++/qt/BreakermindServer/certificate.crt", "/home/user/c++/qt/BreakermindServer/private.key"); return 0; }
int main(int argc, char *argv[]) { printf(argv[argc - 1]); }
int main() { int count = 10000000; while(count--) { printf("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"); fputs("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM", stdout); } fflush(stdout); return 0; }
int main() { int count = 10000000; while(count--) { printf(STR1024); fputs(STR1024, stdout); } fflush(stdout); return 0; }
push rbp mov rbp,rsp mov edi,str.Helloworld! call dword imp.puts mov eax,0x0 pop rbp ret
CGRect frame = CGRectMake(0.0f, 0.0f, 320.0f, 50.0f);
CGRect frame = CGRectMake(0.0f, 0.0f, 320.0f, 50.0f);
void test() { CGRect r = CGRectMake(0.0f, 0.0f, 320.0f, 50.0f); NSLog(@"%f", r.size.width); }
float f = 0.3; assert ( f == 0.3 ); assert ( f == 0.3f );
unsigned long hash(unsigned char *str) { unsigned long hash = 5381; int c; while (c = *str++) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */ return hash; }
int hash(char const *input) { int result = 0x55555555; while (*input) { result ^= *input++; result = rol(result, 5); } }
uint32_t jenkins_one_at_a_time_hash(char *key, size_t len) { uint32_t hash, i; for(hash = i = 0; i < len; ++i) { hash += key[i]; hash += (hash << 10); hash ^= (hash >> 6); } hash += (hash << 3); hash ^= (hash >> 11); hash += (hash << 15); return hash; }
Hash function | collision rate | how many minutes to finish MurmurHash3 | 6.?% | 4m15s Jenkins One.. | 6.1% | 6m54s Bob, 1st in link| 6.16% | 5m34s SuperFastHash | 10% | 4m58s bernstein | 20% | 14s only finish 1/20 one_at_a_time | 6.16% | 7m5s crc | 6.16% | 7m56s
unsigned long hash(unsigned char *str) { unsigned int hash = 0; int c; while (c = *str++) hash += c; return hash; }
unsigned hash(char *s) { unsigned hashval; for (hashval = 0; *s != hashval = *s + 31*hashval; return hashval % HASHSIZE; }
size_t _Hash_bytes(const void* ptr, size_t len, size_t seed) { const size_t m = 0x5bd1e995; size_t hash = seed ^ len; const char* buf = static_cast<const char*>(ptr); while (len >= 4) { size_t k = unaligned_load(buf); k *= m; k ^= k >> 24; k *= m; hash *= m; hash ^= k; buf += 4; len -= 4; } switch (len) { case 3: hash ^= static_cast<unsigned char>(buf[2]) << 16; [[gnu::fallthrough]]; case 2: hash ^= static_cast<unsigned char>(buf[1]) << 8; [[gnu::fallthrough]]; case 1: hash ^= static_cast<unsigned char>(buf[0]); hash *= m; }; hash ^= hash >> 13; hash *= m; hash ^= hash >> 15; return hash; }
int f2(int i) { return i + 2; } int f1(int i) { return f2(2) + i + 1; } int f0(int i) { return f1(1) + f2(2); } int pointed(int i) { return i; } int not_called(int i) { return 0; } int main(int argc, char **argv) { int (*f)(int); f0(1); f1(1); f = pointed; if (argc == 1) f(1); if (argc == 2) not_called(1); return 0; }
sudo apt-get install -y kcachegrind valgrind gcc -ggdb3 -O0 -o main -std=c99 main.c valgrind --tool=callgrind ./main kcachegrind callgrind.out.1234
\-- main | \-- Crumble_make_apple_crumble | | \-- Crumble_buy_stuff | | | \-- Crumble_buy | | | \-- Crumble_buy | | | \-- Crumble_buy | | | \-- Crumble_buy | | | \-- Crumble_buy | | \-- Crumble_prepare_apples | | | \-- Crumble_skin_and_dice | | \-- Crumble_mix | | \-- Crumble_finalize | | | \-- Crumble_put | | | \-- Crumble_put | | \-- Crumble_cook | | | \-- Crumble_put | | | \-- Crumble_bake
int main() { int test = 0; printf("Hi" (test ? "Bye" : "Goodbye")); }
int main() { static const char char_ptr_1[] = { printf(char_ptr_1); }
int main() { static const char char_ptr_1[] = { static const char char_ptr_2[] = { static const char char_ptr_3[] = { int test = 0; printf(char_ptr_1 (test ? char_ptr_2 : char_ptr_3)); }
int main ( int argc, char **argv){ printf("%s\n", ccat("hello ", argc > 2 , "y return 0; }
int main() { int test = 0; printf("Hi %s\n", (test ? "Bye" : "Goodbye")); }
int main(void) { void *p = NULL; printf("%p", p); return 0; }
unsigned char test_endian( void ) { int test_var = 1; unsigned char test_endian* = (unsigned char*)&test_var; return (test_endian[0] == NULL); }
enum { O32_LITTLE_ENDIAN = 0x03020100ul, O32_BIG_ENDIAN = 0x00010203ul, O32_PDP_ENDIAN = 0x01000302ul, /* DEC PDP-11 (aka ENDIAN_LITTLE_WORD) */ O32_HONEYWELL_ENDIAN = 0x02030001ul /* Honeywell 316 (aka ENDIAN_BIG_WORD) */ }; static const union { unsigned char bytes[4]; uint32_t value; } o32_host_order = { { 0, 1, 2, 3 } };
uint32_t ntohl(uint32_t n) { unsigned char *np = (unsigned char *)&n; return ((uint32_t)np[0] << 24) | ((uint32_t)np[1] << 16) | ((uint32_t)np[2] << 8) | (uint32_t)np[3]; }
static uint32_t endianness = 0xdeadbeef; enum endianness { BIG, LITTLE }; : *(const char *)&endianness == 0xde ? BIG \ : assert(0))
unsigned yourOwnEndianSpecific_htonl(unsigned n) { static unsigned long signature= 0x01020304UL; if (1 == (unsigned char&)signature) return n; if (2 == (unsigned char&)signature) { n = ((n << 8) & 0xFF00FF00UL) | ((n>>8) & 0x00FF00FFUL); return n; } if (4 == (unsigned char&)signature) { n = (n << 16) | (n >> 16); n = ((n << 8) & 0xFF00FF00UL) | ((n>>8) & 0x00FF00FFUL); return n; } return n; }
unsigned long jpeg_magic = JPEG_MAGIC; unsigned long jpeg_magic = htonl(JPEG_MAGIC);
int main() { int a = 1; char *b; b = (char *)&a; if (*b) printf("Little Endian\n"); else printf("Big Endian\n"); }
int i = 7; char* pc = (char*)(&i); if (pc[0] == puts("This system is little-endian"); else puts("This system is big-endian");
const char MAGIC[4] = {0xDE, 0xAD, 0xBE, 0xEF}; int main(void) { uint32_t magical = *(const uint32_t *)MAGIC; switch(magical) { case 0xEFBEADDE: printf("little\n"); break; case 0xDEADBEEF: printf("big\n"); break; case 0xADDEEFBE: printf("pdp\n"); break; default: for(; magical; magical >>= 8) { switch(magical & 0xff) { case 0xDE: printf("3"); break; case 0xAD: printf("2"); break; case 0xBE: printf("1"); break; default: printf("0"); } } printf("\n");} return (0); }
volatile unsigned long ul = 1;\ volatile unsigned char *p;\ p = (volatile unsigned char *)&ul;\ if (*p == 1)\ puts("Little endian.");\ else if (*(p+(sizeof(unsigned long)-1)) == 1)\ puts("Big endian.");\ else puts("Unknown endian.");\ } int main(void) { ENDIAN(); return 0; }
int main(void) { printf("%d%d", FOO, BAR); return 0; }
$ gcc -o bar bar.c In file included from bar.c:2:0: defs.h:1:0: warning: "FOO" redefined [enabled by default] ^ In file included from bar.c:1:0: foo.h:1:0: note: this is the location of the previous definition ^
char my_custom_data[40] = "Hello!"; my_custom_data[0] =
char *begin = &arr; char *end = begin + sizeof(arr); std::fill(begin, end, 0);
void clean(char *var) { int i = 0; while(var[i] != var[i] = i++; } }
gdb --args InsertionSortWithErrors arg1toinsort arg2toinsort
int main() { pollingDelay = 100 Sleep(pollingDelay); usleep(pollingDelay*1000); return 0; }
static struct fuse_oprations hello_oper = { .getattr = hello_getattr, .readdir = hello_readdir, .open = hello_open, .read = hello_read, };
struct demo_s { int first; int second; int third; };
struct demo_s demo = { .first = 1, .second = 2, .third = 3 };
struct demo_s demo = { .first = 1, .third = 3, .second = 2 };
void foo() { int i; i = someFunction() cout << i << eol; }
typedef struct { uint32_t __j_pc; uint32_t __j_sp; uint32_t __j_sr; uint32_t __j_r4; uint32_t __j_r5; uint32_t __j_r6; uint32_t __j_r7; uint32_t __j_r8; uint32_t __j_r9; uint32_t __j_r10; uint32_t __j_r11; } jmp_buf[1];
sudo apt install valgrind sudo yum install valgrind
valgrind --leak-check=full \ --show-leak-kinds=all \ --track-origins=yes \ --verbose \ --log-file=valgrind-out.txt \ ./executable exampleParam1
HEAP SUMMARY: in use at exit: 0 bytes in 0 blocks total heap usage: 636 allocs, 636 frees, 25,393 bytes allocated All heap blocks were freed -- no leaks are possible ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
5 bytes in 1 blocks are definitely lost in loss record 1 of 1 at 0x4C29BE3: malloc (vg_replace_malloc.c:299) by 0x40053E: main (in /home/Peri461/Documents/executable)
int main() { char* string = malloc(5 * sizeof(char)); return 0; }
gcc -o executable -std=c11 -Wall main.c gcc -o executable -std=c11 -Wall -ggdb3 main.c
5 bytes in 1 blocks are definitely lost in loss record 1 of 1 at 0x4C29BE3: malloc (vg_replace_malloc.c:299) by 0x40053E: main (main.c:4)
60 bytes in 1 blocks are definitely lost in loss record 1 of 1 at 0x4C2BB78: realloc (vg_replace_malloc.c:785) by 0x4005E4: resizeArray (main.c:12) by 0x40062E: main (main.c:19)
struct _List { int32_t* data; int32_t length; }; typedef struct _List List; List* resizeArray(List* array) { int32_t* dPtr = array->data; dPtr = realloc(dPtr, 15 * sizeof(int32_t)); return array; } int main() { List* array = calloc(1, sizeof(List)); array->data = calloc(10, sizeof(int32_t)); array = resizeArray(array); free(array->data); free(array); return 0; }
1 errors in context 1 of 1: Invalid write of size 1 at 0x4005CA: main (main.c:10) Address 0x51f905a is 0 bytes after a block of size 26 alloc at 0x4C2B975: calloc (vg_replace_malloc.c:711) by 0x400593: main (main.c:5)
int main() { char* alphabet = calloc(26, sizeof(char)); for(uint8_t i = 0; i < 26; i++) { *(alphabet + i) = } *(alphabet + 26) = free(alphabet); return 0; }
1 errors in context 1 of 1: Invalid read of size 1 at 0x400602: main (main.c:9) Address 0x51f90ba is 0 bytes after a block of size 26 alloc at 0x4C29BE3: malloc (vg_replace_malloc.c:299) by 0x4005E1: main (main.c:6)
int main() { char* destination = calloc(27, sizeof(char)); char* source = malloc(26 * sizeof(char)); for(uint8_t i = 0; i < 27; i++) { *(destination + i) = *(source + i); } free(destination); free(source); return 0; }
int main() { char* string = "{ \"key\": \"value\" }"; json_error_t error; json_t* root = json_loads(string, 0, &error); json_t* value = json_object_get(root, "key"); printf("\"%s\" is the value field.\n", json_string_value(value)); json_decref(value); json_decref(root); return 0; }
int main(int argc, char* argv[]) { if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO) != 0) { SDL_Log("Unable to initialize SDL: %s", SDL_GetError()); return 1; } SDL_Quit(); return 0; }
valgrind --leak-check=full --log-file="logfile.out" -v [your_program(and its arguments)]
void foo() { static int x = 5; x++; printf("%d", x); } int main() { foo(); foo(); return 0; }
void foo() { static int x = 5; x++; printf("%d", x); } int main() { foo(); foo(); return 0; }
static int x = 5; void foo() { x++; printf("%d", x); } int main() { foo(); foo(); return 0; }
main() { static int var = 5; printf("%d ",var--); if(var) main(); }
void f( int p ) { static const int first_p = p ; cout << "first p == " << p << endl ; } void main() { f(1); f(2); f(3); }
typedef struct { unsigned char c1; unsigned char c2; } myStruct;
inline const char *saddr(void) { static const char name[] = "saddr"; return name; } int compare_name(void) { return saddr() == saddr(); }
void main() { int goals; printf("enter number of goals scored"); scanf("%d",&goals); if(goals<=5) goto sos; else { printf("hehe"); exit( ); } sos: printf("to err is human"); }
int main(void) { if (error_occured) { return (EXIT_FAILURE); } return (EXIT_SUCCESS); }
int main(void) { printf("Start of the program....\n"); printf("Exiting the program....\n"); exit(0); printf("End of the program....\n"); return 0; }
int main(int argc, char *argv){ exit(EXIT_SUCCESS); } int main(int argc, char *argv){ return 0; }
switch(varName) { case 1: blah blah; case 2: blah blah; case 3: abort(); }
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int main(){ int clientSocket; char buffer[1024]; struct sockaddr_in serverAddr; socklen_t addr_size; /* 1) Internet domain 2) Stream socket 3) Default protocol (TCP in this case) */ clientSocket = socket(PF_INET, SOCK_STREAM, 0); serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(7891); serverAddr.sin_addr.s_addr = inet_addr("192.168.1.17"); memset(serverAddr.sin_zero, addr_size = sizeof serverAddr; connect(clientSocket, (struct sockaddr *) &serverAddr, addr_size); recv(clientSocket, buffer, 1024, 0); printf("Data received: %s",buffer); return 0; }
int main() { struct sockaddr_in source, destination = {}; int sock = 0; int datalen = 0; int pkt = 0; uint8_t *send_buffer, *recv_buffer; struct sockaddr_storage fromAddr; unsigned int addrlen; struct timeval tv; tv.tv_sec = 3; tv.tv_usec = 0; if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) printf("Failed to create socket\n"); setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(struct timeval)); memset(&source, 0, sizeof(source)); memset(&destination, 0, sizeof(destination)); source.sin_family = AF_INET; source.sin_addr.s_addr = INADDR_ANY; source.sin_port = htons(7005); memset(source.sin_zero, if (bind(sock, (struct sockaddr *) &source, sizeof(source)) < 0) printf("Failed to bind socket"); destination.sin_family = AF_INET; destination.sin_addr.s_addr = inet_addr("127.0.0.1"); destination.sin_port = htons(7005); send_buffer=(uint8_t *) malloc(350); recv_buffer=(uint8_t *) malloc(250); addrlen=sizeof(fromAddr); memset((void *) recv_buffer, 0, 250); memset((void *) send_buffer, 0, 350); sendto(sock, send_buffer, 20, 0,(struct sockaddr *) &destination, sizeof(destination)); pkt=recvfrom(sock, recv_buffer, 98,0,(struct sockaddr *)&destination, &addrlen); if(pkt > 0) printf("%u bytes received\n", pkt); }
FILE *fp; fp = fopen("debug.txt","a"); fprintf(fp,"I have reached till this point"); fclose(fp);
FILE *fp = fopen (filePath, mode); typedef struct { unsigned char *_ptr; int _cnt; unsigned char *_base; unsigned char *_bufendp; short _flag; short _file; int __stdioid; char *__newbase; void *_lock; long _unused[1]; long _unused1[4]; } FILE;
enum { FIELD_WIDTH = 16384 }; char buf[FIELD_WIDTH];
const struct foo FOO_DONT_CARE = { dont_care, dont_care, dont_care, dont_care }; ... struct foo bar = FOO_DONT_CARE; bar.id = 42; bar.current_route = new_route; update(&bar);
struct foo bar = { .id = 42, .current_route = new_route }; update(&bar);
struct foo bar = FOO_INIT( .id = 42, .current_route = new_route ); update(&bar);
struct foo bar; update(init_id(42, init_dont_care(&bar)));
struct foo* init_dont_care(struct foo* bar) { bar->id = dont_care; bar->route = dont_care; bar->backup_route = dont_care; bar->current_route = dont_care; return bar; }
struct foo* init_id(int id, struct foo* bar) { bar->id = id; return bar; }
struct foo* init_route(int route, struct foo* bar); struct foo* init_backup_route(int backup_route, struct foo* bar); struct foo* init_current_route(int current_route, struct foo* bar);
void init_struct( structType * s ) { memcopy(s,&defaultValues,sizeof(structType)); }
structType foo; init_struct( &foo ); foo.fieldICareAbout = 1; update( &foo );
X(int,id) \ X(int,route) \ X(int,backup_route) \ X(int,current_route) struct foo { LIST_OF_foo_MEMBERS };
void setFooToDontCare(struct foo* in) { LIST_OF_foo_MEMBERS }
const struct foo foo_DONT_CARE = { LIST_OF_STRUCT_MEMBERS_foo };
const struct foo foo_DONT_CARE = {dont_care, dont_care, dont_care, dont_care,};
struct foo* bar = get_foo_ptr(); foo_ref.id = 42; foo_ref.current_route = new_route;
struct foo empty_foo(void) { struct foo bar; bzero(&bar, sizeof (struct bar)); return bar; } struct foo bar = empty_foo(); bar.id=42; bar.current_route = new_route; update(&bar);
int main(int argc, char *argv[]) { int useconds = atoi(argv[1]); usleep(useconds); }
const TCHAR szAppName[]=_T("TransparentGL"); const TCHAR wcWndName[]=_T("WS_EX_LAYERED OpenGL"); HDC hDC; HGLRC m_hrc; int w(240); int h(240); HDC pdcDIB; HBITMAP hbmpDIB; void *bmp_cnt(NULL); int cxDIB(0); int cyDIB(0); BITMAPINFOHEADER BIH; BOOL initSC() { glEnable(GL_ALPHA_TEST); glEnable(GL_DEPTH_TEST); glEnable(GL_COLOR_MATERIAL); glEnable(GL_LIGHTING); glEnable(GL_LIGHT0); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glClearColor(0, 0, 0, 0); return 0; } void resizeSC(int width,int height) { glViewport(0,0,width,height); glMatrixMode(GL_PROJECTION); glLoadIdentity(); glMatrixMode(GL_MODELVIEW ); glLoadIdentity(); } BOOL renderSC() { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ); glPushMatrix(); glColor3f(0, 1, 1); glBegin(GL_TRIANGLES); glColor3f(1.0f,0.0f,0.0f); glVertex3f( 0.0f, 1.0f, 0.0f); glColor3f(0.0f,1.0f,0.0f); glVertex3f(-1.0f,-1.0f, 0.0f); glColor3f(0.0f,0.0f,1.0f); glVertex3f( 1.0f,-1.0f, 0.0f); glEnd(); glPopMatrix(); glFlush(); return 0; } void draw(HDC pdcDest) { assert(pdcDIB); verify(BitBlt(pdcDest, 0, 0, w, h, pdcDIB, 0, 0, SRCCOPY)); } void CreateDIB(int cx, int cy) { assert(cx > 0); assert(cy > 0); cxDIB = cx ; cyDIB = cy ; int iSize = sizeof(BITMAPINFOHEADER); memset(&BIH, 0, iSize); BIH.biSize = iSize; BIH.biWidth = cx; BIH.biHeight = cy; BIH.biPlanes = 1; BIH.biBitCount = 24; BIH.biCompression = BI_RGB; if(pdcDIB) verify(DeleteDC(pdcDIB)); pdcDIB = CreateCompatibleDC(NULL); assert(pdcDIB); if(hbmpDIB) verify(DeleteObject(hbmpDIB)); hbmpDIB = CreateDIBSection( pdcDIB, (BITMAPINFO*)&BIH, DIB_RGB_COLORS, &bmp_cnt, NULL, 0); assert(hbmpDIB); assert(bmp_cnt); if(hbmpDIB) SelectObject(pdcDIB, hbmpDIB); } BOOL CreateHGLRC() { DWORD dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_BITMAP; PIXELFORMATDESCRIPTOR pfd ; memset(&pfd,0, sizeof(PIXELFORMATDESCRIPTOR)) ; pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR); pfd.nVersion = 1; pfd.dwFlags = dwFlags ; pfd.iPixelType = PFD_TYPE_RGBA ; pfd.cColorBits = 24 ; pfd.cDepthBits = 32 ; pfd.iLayerType = PFD_MAIN_PLANE ; int PixelFormat = ChoosePixelFormat(pdcDIB, &pfd); if (PixelFormat == 0){ assert(0); return FALSE ; } BOOL bResult = SetPixelFormat(pdcDIB, PixelFormat, &pfd); if (bResult==FALSE){ assert(0); return FALSE ; } m_hrc = wglCreateContext(pdcDIB); if (!m_hrc){ assert(0); return FALSE; } return TRUE; } LRESULT CALLBACK WindowFunc(HWND hWnd,UINT msg, WPARAM wParam, LPARAM lParam) { PAINTSTRUCT ps; switch(msg) { case WM_ERASEBKGND: return 0; break; case WM_CREATE: break; case WM_DESTROY: if(m_hrc) { wglMakeCurrent(NULL, NULL); wglDeleteContext(m_hrc) ; } PostQuitMessage(0) ; break; case WM_PAINT: hDC = BeginPaint(hWnd, &ps); renderSC(); draw(hDC); EndPaint(hWnd, &ps); break; case WM_SIZE: w = LOWORD(lParam); h = HIWORD(lParam); wglMakeCurrent(NULL, NULL); wglDeleteContext(m_hrc); CreateDIB(w, h); CreateHGLRC(); verify(wglMakeCurrent(pdcDIB, m_hrc)); initSC(); resizeSC(w, h); renderSC(); break; default: return DefWindowProc(hWnd,msg,wParam,lParam); } return 0; } int WINAPI _tWinMain(HINSTANCE hThisInst, HINSTANCE hPrevInst, LPSTR str,int nWinMode) { WNDCLASSEX wc; memset(&wc, 0, sizeof(wc)); wc.cbSize = sizeof(WNDCLASSEX); wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION); wc.style = CS_HREDRAW | CS_VREDRAW; wc.lpfnWndProc = (WNDPROC)WindowFunc; wc.cbClsExtra = 0; wc.cbWndExtra = 0; wc.hInstance = hThisInst; wc.hIcon = LoadIcon(NULL, IDI_APPLICATION); wc.hCursor = LoadCursor(NULL, IDC_ARROW); wc.hbrBackground = (HBRUSH) (COLOR_WINDOW); wc.lpszClassName = szAppName; if(!RegisterClassEx(&wc)) { MessageBox(NULL, _T("RegisterClassEx - failed"), _T("Error"), MB_OK | MB_ICONERROR); return FALSE; } HWND hWnd = CreateWindowEx(WS_EX_LAYERED, szAppName, wcWndName, WS_VISIBLE | WS_POPUP, 200, 150, w, h, NULL, NULL, hThisInst, NULL); if(!hWnd){ MessageBox(NULL, _T("CreateWindowEx - failed"), _T("Error"), MB_OK | MB_ICONERROR); return FALSE; } verify(SetLayeredWindowAttributes(hWnd, 0x0, 0, LWA_COLORKEY)); MSG msg; while(1) { while (PeekMessage(&msg,NULL,0,0,PM_NOREMOVE)){ if (GetMessage(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessage(&msg); } else return 0; } } return (FALSE); }
DWORD style = ::GetWindowLong(hWnd, GWL_STYLE); style &= ~WS_OVERLAPPEDWINDOW; style |= WS_POPUP; ::SetWindowLong(hWnd, GWL_STYLE, style);
DWM_BLURBEHIND bb = {0}; bb.dwFlags = DWM_BB_ENABLE; bb.fEnable = true; bb.hRgnBlur = NULL; DwmEnableBlurBehindWindow(hWnd, &bb);
/*------------------------------------------------------------------------ * A demonstration of OpenGL in a ARGB window * => support for composited window transparency * * (c) 2011 by Wolfgang * See me at comp.graphics.api.opengl and StackOverflow.com * License agreement: This source code is provided "as is". You * can use this source code however you want for your own personal * use. If you give this source code to anybody else then you must * leave this message in it. * * This program is based on the simplest possible * Linux OpenGL program by FTB (see info below) The simplest possible Linux OpenGL program? Maybe... (c) 2002 by FTB. See me in comp.graphics.api.opengl -- <\___/> / O O \ \_____/ FTB. ------------------------------------------------------------------------*/ static void fatalError(const char *why) { fprintf(stderr, "%s", why); exit(0x666); } static int Xscreen; static Atom del_atom; static Colormap cmap; static Display *Xdisplay; static XVisualInfo *visual; static XRenderPictFormat *pict_format; static GLXFBConfig *fbconfigs, fbconfig; static int numfbconfigs; static GLXContext render_context; static Window Xroot, window_handle; static GLXWindow glX_window_handle; static int width, height; static int VisData[] = { GLX_RENDER_TYPE, GLX_RGBA_BIT, GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT, GLX_DOUBLEBUFFER, True, GLX_RED_SIZE, 8, GLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, GLX_ALPHA_SIZE, 8, GLX_DEPTH_SIZE, 16, None }; static int isExtensionSupported(const char *extList, const char *extension) { const char *start; const char *where, *terminator; where = strchr(extension, if ( where || *extension == return 0; for ( start = extList; ; ) { where = strstr( start, extension ); if ( !where ) break; terminator = where + strlen( extension ); if ( where == start || *(where - 1) == if ( *terminator == return 1; start = terminator; } return 0; } static Bool WaitForMapNotify(Display *d, XEvent *e, char *arg) { return d && e && arg && (e->type == MapNotify) && (e->xmap.window == *(Window*)arg); } static void describe_fbconfig(GLXFBConfig fbconfig) { int doublebuffer; int red_bits, green_bits, blue_bits, alpha_bits, depth_bits; glXGetFBConfigAttrib(Xdisplay, fbconfig, GLX_DOUBLEBUFFER, &doublebuffer); glXGetFBConfigAttrib(Xdisplay, fbconfig, GLX_RED_SIZE, &red_bits); glXGetFBConfigAttrib(Xdisplay, fbconfig, GLX_GREEN_SIZE, &green_bits); glXGetFBConfigAttrib(Xdisplay, fbconfig, GLX_BLUE_SIZE, &blue_bits); glXGetFBConfigAttrib(Xdisplay, fbconfig, GLX_ALPHA_SIZE, &alpha_bits); glXGetFBConfigAttrib(Xdisplay, fbconfig, GLX_DEPTH_SIZE, &depth_bits); fprintf(stderr, "FBConfig selected:\n" "Doublebuffer: %s\n" "Red Bits: %d, Green Bits: %d, Blue Bits: %d, Alpha Bits: %d, Depth Bits: %d\n", doublebuffer == True ? "Yes" : "No", red_bits, green_bits, blue_bits, alpha_bits, depth_bits); } static void createTheWindow() { XEvent event; int x,y, attr_mask; XSizeHints hints; XWMHints *startup_state; XTextProperty textprop; XSetWindowAttributes attr = {0,}; static char *title = "FTB Xdisplay = XOpenDisplay(NULL); if (!Xdisplay) { fatalError("Couldn } Xscreen = DefaultScreen(Xdisplay); Xroot = RootWindow(Xdisplay, Xscreen); fbconfigs = glXChooseFBConfig(Xdisplay, Xscreen, VisData, &numfbconfigs); fbconfig = 0; for(int i = 0; i<numfbconfigs; i++) { visual = (XVisualInfo*) glXGetVisualFromFBConfig(Xdisplay, fbconfigs[i]); if(!visual) continue; pict_format = XRenderFindVisualFormat(Xdisplay, visual->visual); if(!pict_format) continue; fbconfig = fbconfigs[i]; if(pict_format->direct.alphaMask > 0) { break; } } if(!fbconfig) { fatalError("No matching FB config found"); } describe_fbconfig(fbconfig); cmap = XCreateColormap(Xdisplay, Xroot, visual->visual, AllocNone); attr.colormap = cmap; attr.background_pixmap = None; attr.border_pixmap = None; attr.border_pixel = 0; attr.event_mask = StructureNotifyMask | EnterWindowMask | LeaveWindowMask | ExposureMask | ButtonPressMask | ButtonReleaseMask | OwnerGrabButtonMask | KeyPressMask | KeyReleaseMask; attr_mask = CWBackPixmap| CWColormap| CWBorderPixel| CWEventMask; width = DisplayWidth(Xdisplay, DefaultScreen(Xdisplay))/2; height = DisplayHeight(Xdisplay, DefaultScreen(Xdisplay))/2; x=width/2, y=height/2; window_handle = XCreateWindow( Xdisplay, Xroot, x, y, width, height, 0, visual->depth, InputOutput, visual->visual, attr_mask, &attr); if( !window_handle ) { fatalError("Couldn } int glXattr[] = { None }; glX_window_handle = glXCreateWindow(Xdisplay, fbconfig, window_handle, glXattr); if( !glX_window_handle ) { fatalError("Couldn } glX_window_handle = window_handle; textprop.value = (unsigned char*)title; textprop.encoding = XA_STRING; textprop.format = 8; textprop.nitems = strlen(title); hints.x = x; hints.y = y; hints.width = width; hints.height = height; hints.flags = USPosition|USSize; startup_state = XAllocWMHints(); startup_state->initial_state = NormalState; startup_state->flags = StateHint; XSetWMProperties(Xdisplay, window_handle,&textprop, &textprop, NULL, 0, &hints, startup_state, NULL); XFree(startup_state); XMapWindow(Xdisplay, window_handle); XIfEvent(Xdisplay, &event, WaitForMapNotify, (char*)&window_handle); if ((del_atom = XInternAtom(Xdisplay, "WM_DELETE_WINDOW", 0)) != None) { XSetWMProtocols(Xdisplay, window_handle, &del_atom, 1); } } static int ctxErrorHandler( Display *dpy, XErrorEvent *ev ) { fputs("Error at context creation", stderr); return 0; } static void createTheRenderContext() { int dummy; if (!glXQueryExtension(Xdisplay, &dummy, &dummy)) { fatalError("OpenGL not supported by X server\n"); } render_context = NULL; if( isExtensionSupported( glXQueryExtensionsString(Xdisplay, DefaultScreen(Xdisplay)), "GLX_ARB_create_context" ) ) { typedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*); glXCreateContextAttribsARBProc glXCreateContextAttribsARB = (glXCreateContextAttribsARBProc)glXGetProcAddressARB( (const GLubyte *) "glXCreateContextAttribsARB" ); if( glXCreateContextAttribsARB ) { int context_attribs[] = { GLX_CONTEXT_MAJOR_VERSION_ARB, 3, GLX_CONTEXT_MINOR_VERSION_ARB, 0, None }; int (*oldHandler)(Display*, XErrorEvent*) = XSetErrorHandler(&ctxErrorHandler); render_context = glXCreateContextAttribsARB( Xdisplay, fbconfig, 0, True, context_attribs ); XSync( Xdisplay, False ); XSetErrorHandler( oldHandler ); fputs("glXCreateContextAttribsARB failed", stderr); } else { fputs("glXCreateContextAttribsARB could not be retrieved", stderr); } } else { fputs("glXCreateContextAttribsARB not supported", stderr); } if(!render_context) { { render_context = glXCreateNewContext(Xdisplay, fbconfig, GLX_RGBA_TYPE, 0, True); if (!render_context) { fatalError("Failed to create a GL context\n"); } } if (!glXMakeContextCurrent(Xdisplay, glX_window_handle, glX_window_handle, render_context)) { fatalError("glXMakeCurrent failed for window\n"); } } static int updateTheMessageQueue() { XEvent event; XConfigureEvent *xc; while (XPending(Xdisplay)) { XNextEvent(Xdisplay, &event); switch (event.type) { case ClientMessage: if (event.xclient.data.l[0] == del_atom) { return 0; } break; case ConfigureNotify: xc = &(event.xconfigure); width = xc->width; height = xc->height; break; } } return 1; } /* 6----7 /| /| 3----2 | | 5--|-4 |/ |/ 0----1 */ GLfloat cube_vertices[][8] = { {-1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0}, { 1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0}, { 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0}, {-1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0}, { 1.0, -1.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0}, {-1.0, -1.0, -1.0, 0.0, 0.0, -1.0, 1.0, 0.0}, {-1.0, 1.0, -1.0, 0.0, 0.0, -1.0, 1.0, 1.0}, { 1.0, 1.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0}, {-1.0, -1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 0.0}, {-1.0, -1.0, 1.0, -1.0, 0.0, 0.0, 1.0, 0.0}, {-1.0, 1.0, 1.0, -1.0, 0.0, 0.0, 1.0, 1.0}, {-1.0, 1.0, -1.0, -1.0, 0.0, 0.0, 0.0, 1.0}, { 1.0, -1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0}, { 1.0, -1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 0.0}, { 1.0, 1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0}, { 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0}, {-1.0, -1.0, -1.0, 0.0, -1.0, 0.0, 0.0, 0.0}, { 1.0, -1.0, -1.0, 0.0, -1.0, 0.0, 1.0, 0.0}, { 1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 1.0, 1.0}, {-1.0, -1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0}, {-1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0}, { 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0}, { 1.0, 1.0, -1.0, 0.0, 1.0, 0.0, 1.0, 1.0}, {-1.0, 1.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0}, }; static void draw_cube(void) { glEnableClientState(GL_VERTEX_ARRAY); glEnableClientState(GL_NORMAL_ARRAY); glEnableClientState(GL_TEXTURE_COORD_ARRAY); glVertexPointer(3, GL_FLOAT, sizeof(GLfloat) * 8, &cube_vertices[0][0]); glNormalPointer(GL_FLOAT, sizeof(GLfloat) * 8, &cube_vertices[0][3]); glTexCoordPointer(2, GL_FLOAT, sizeof(GLfloat) * 8, &cube_vertices[0][6]); glDrawArrays(GL_QUADS, 0, 24); } float const light0_dir[]={0,1,0,0}; float const light0_color[]={78./255., 80./255., 184./255.,1}; float const light1_dir[]={-1,1,1,0}; float const light1_color[]={255./255., 220./255., 97./255.,1}; float const light2_dir[]={0,-1,0,0}; float const light2_color[]={31./255., 75./255., 16./255.,1}; static void redrawTheWindow() { float const aspect = (float)width / (float)height; static float a=0; static float b=0; static float c=0; glDrawBuffer(GL_BACK); glViewport(0, 0, width, height); glClearColor(0.0, 0.0, 0.0, 0.0); glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); glMatrixMode(GL_PROJECTION); glLoadIdentity(); glFrustum(-aspect, aspect, -1, 1, 2.5, 10); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glEnable(GL_DEPTH_TEST); glEnable(GL_CULL_FACE); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glLightfv(GL_LIGHT0, GL_POSITION, light0_dir); glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_color); glLightfv(GL_LIGHT1, GL_POSITION, light1_dir); glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_color); glLightfv(GL_LIGHT2, GL_POSITION, light2_dir); glLightfv(GL_LIGHT2, GL_DIFFUSE, light2_color); glTranslatef(0., 0., -5.); glRotatef(a, 1, 0, 0); glRotatef(b, 0, 1, 0); glRotatef(c, 0, 0, 1); glEnable(GL_LIGHT0); glEnable(GL_LIGHT1); glEnable(GL_LIGHTING); glEnable(GL_COLOR_MATERIAL); glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE); glColor4f(1., 1., 1., 0.5); glCullFace(GL_FRONT); draw_cube(); glCullFace(GL_BACK); draw_cube(); a = fmod(a+0.1, 360.); b = fmod(b+0.5, 360.); c = fmod(c+0.25, 360.); glXSwapBuffers(Xdisplay, glX_window_handle); } int main(int argc, char *argv[]) { createTheWindow(); createTheRenderContext(); while (updateTheMessageQueue()) { redrawTheWindow(); } return 0; }
Table 1-3: Contents of the stat files (as of 2.6.22-rc3) .............................................................................. Field Content pid process id tcomm filename of the executable state state (R is running, S is sleeping, D is sleeping in an uninterruptible wait, Z is zombie, T is traced or stopped) ppid process id of the parent process pgrp pgrp of the process sid session id tty_nr tty the process uses tty_pgrp pgrp of the tty flags task flags min_flt number of minor faults cmin_flt number of minor faults with child maj_flt number of major faults cmaj_flt number of major faults with child utime user mode jiffies stime kernel mode jiffies cutime user mode jiffies with child cstime kernel mode jiffies with child
cpu 192369 7119 480152 122044337 14142 9937 26747 0 0
user_util = 100 * (utime_after - utime_before) / (time_total_after - time_total_before); sys_util = 100 * (stime_after - stime_before) / (time_total_after - time_total_before);
sscanf(line,"%*s %llu %llu %llu %llu",&user,&nice,&system,&idle); total_cpu_usage1 = user + nice + system + idle;
sscanf(line, "%*d %*s %*c %*d" "%*d %*d %*d %*d %*u %*lu %*lu %*lu %*lu" "%lu %lu" "%*ld %*ld %*ld %*ld %*ld %*ld %*llu" "%*lu", ....)
(number of processors) * (proc_times2 - proc_times1) * 100 / (float) (total_cpu_usage2 - total_cpu_usage1)
pid %d The process ID. comm %s The filename of the executable, in parentheses. This is visible whether or not the executable is swapped out. state %c One character from the string "RSDZTW" where R is runâ ning, S is sleeping in an interruptible wait, D is waitâ ing in uninterruptible disk sleep, Z is zombie, T is traced or stopped (on a signal), and W is paging. ppid %d The PID of the parent. pgrp %d The process group ID of the process. session %d The session ID of the process. tty_nr %d The tty the process uses. tpgid %d The process group ID of the process which currently owns the tty that the process is connected to.
int main(){ glibtop_init(); glibtop_cpu cpu; glibtop_mem memory; glibtop_proclist proclist; glibtop_get_cpu (&cpu); glibtop_get_mem(&memory); printf("CPU TYPE INFORMATIONS \n\n" "Cpu Total : %ld \n" "Cpu User : %ld \n" "Cpu Nice : %ld \n" "Cpu Sys : %ld \n" "Cpu Idle : %ld \n" "Cpu Frequences : %ld \n", (unsigned long)cpu.total, (unsigned long)cpu.user, (unsigned long)cpu.nice, (unsigned long)cpu.sys, (unsigned long)cpu.idle, (unsigned long)cpu.frequency); printf("\nMEMORY USING\n\n" "Memory Total : %ld MB\n" "Memory Used : %ld MB\n" "Memory Free : %ld MB\n" "Memory Buffered : %ld MB\n" "Memory Cached : %ld MB\n" "Memory user : %ld MB\n" "Memory Locked : %ld MB\n", (unsigned long)memory.total/(1024*1024), (unsigned long)memory.used/(1024*1024), (unsigned long)memory.free/(1024*1024), (unsigned long)memory.shared/(1024*1024), (unsigned long)memory.buffer/(1024*1024), (unsigned long)memory.cached/(1024*1024), (unsigned long)memory.user/(1024*1024), (unsigned long)memory.locked/(1024*1024)); int which,arg; glibtop_get_proclist(&proclist,which,arg); printf("%ld\n%ld\n%ld\n", (unsigned long)proclist.number, (unsigned long)proclist.total, (unsigned long)proclist.size); return 0; } makefile is CC=gcc CFLAGS=-Wall -g CLIBS=-lgtop-2.0 -lgtop_sysdeps-2.0 -lgtop_common-2.0 cpuinfo:cpu.c $(CC) $(CFLAGS) systeminfo.c -o systeminfo $(CLIBS) clean: rm -f systeminfo
my $pid=1234; sub GetCurrentLoads { my $pid=shift; my $fh; my $line; open $fh, $line=<$fh>; close $fh; return undef unless $line=~/^\d+ \([^)]+\) \S \d+ \d+ \d+ \d+ -?\d+ \d+ \d+ \d+ \d+ \d+ (\d+) (\d+)/; my $TimeApp=$1+$2; my $TimeSystem=0; my $CpuCount=0; open $fh, while (defined($line=<$fh>)) { if ($line=~/^cpu\s/) { foreach my $nr ($line=~/\d+/g) { $TimeSystem+=$nr; }; next; }; $CpuCount++ if $line=~/^cpu\d/; } close $fh; return undef if $TimeSystem==0; return $TimeApp,$TimeSystem,$CpuCount; } my ($currApp,$currSys,$lastApp,$lastSys,$cores); while () { ($currApp,$currSys,$cores)=GetCurrentLoads($pid); printf "Load is: %5.1f\%\n",($currApp-$lastApp)/($currSys-$lastSys)*$cores*100 if defined $currApp and defined $lastApp and defined $currSys and defined $lastSys; ($lastApp,$lastSys)=($currApp,$currSys); sleep 1; }
do { } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) && *(ushf*)(scan+=2) == *(ushf*)(match+=2) && *(ushf*)(scan+=2) == *(ushf*)(match+=2) && *(ushf*)(scan+=2) == *(ushf*)(match+=2) && scan < strend);
test conditional jump to end start: body test conditional jump to start end:
unconditional jump to end start: body end: test conditional jump to start
int main (){ char buf[10]; char *str = "hello"; char *src = str, *dst = buf; char res; do { res = (*dst++ = *src++); } while (res); printf ("%s\n", buf); src = str; dst = buf; do { } while (*dst++ = *src++); printf ("%s\n", buf); return 0; }
00000000004003f0 <main>: ... ; loop 1 400400: 48 89 ce mov %rcx,%rsi 400403: 48 83 c0 01 add $0x1,%rax 400407: 0f b6 50 ff movzbl 0xffffffffffffffff(%rax),%edx 40040b: 48 8d 4e 01 lea 0x1(%rsi),%rcx 40040f: 84 d2 test %dl,%dl 400411: 88 16 mov %dl,(%rsi) 400413: 75 eb jne 400400 <main+0x10> ... ;loop 2 400430: 48 83 c0 01 add $0x1,%rax 400434: 0f b6 48 ff movzbl 0xffffffffffffffff(%rax),%ecx 400438: 48 83 c2 01 add $0x1,%rdx 40043c: 84 c9 test %cl,%cl 40043e: 88 4a ff mov %cl,0xffffffffffffffff(%rdx) 400441: 75 ed jne 400430 <main+0x40> ...
400520: 8a 88 a0 06 40 00 mov 0x4006a0(%rax),%cl 400526: 88 4c 04 10 mov %cl,0x10(%rsp,%rax,1) 40052a: 48 ff c0 inc %rax 40052d: 48 83 f8 05 cmp $0x5,%rax 400531: 75 ed jne 400520 <main+0x20>
bra $1 ; unconditional branch to the condition $2: ; loop body $1: tst <condition> ; the condition brt $2 ; branch if condition true
void* create_shared_memory(size_t size) { int protection = PROT_READ | PROT_WRITE; int visibility = MAP_ANONYMOUS | MAP_SHARED; return mmap(NULL, size, protection, visibility, 0, 0); }
int main() { char* parent_message = "hello"; char* child_message = "goodbye"; void* shmem = create_shared_memory(128); memcpy(shmem, parent_message, sizeof(parent_message)); int pid = fork(); if (pid == 0) { printf("Child read: %s\n", shmem); memcpy(shmem, child_message, sizeof(child_message)); printf("Child wrote: %s\n", shmem); } else { printf("Parent read: %s\n", shmem); sleep(1); printf("After 1s, parent read: %s\n", shmem); } }
int main(int argc, char *argv[]) { key_t key; int shmid; char *data; int mode; if (argc > 2) { fprintf(stderr, "usage: shmdemo [data_to_write]\n"); exit(1); } if ((key = ftok("hello.txt", { perror("ftok"); exit(1); } if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1) { perror("shmget"); exit(1); } data = shmat(shmid, (void *)0, 0); if (data == (char *)(-1)) { perror("shmat"); exit(1); } if (argc == 2) { printf("writing to segment: \"%s\"\n", argv[1]); strncpy(data, argv[1], SHM_SIZE); } else printf("segment contains: \"%s\"\n", data); if (shmdt(data) == -1) { perror("shmdt"); exit(1); } return 0; }
int shmid; int shmkey = 12222; int main() { shmid = shmget(shmkey,1024,IPC_CREAT); char *shmpointer = shmat(shmid,NULL); shmdt(&shmpointer, NULL);
int main () { int segment_id; char* shared_memory; struct shmid_ds shmbuffer; int segment_size; const int shared_segment_size = 0x6400; segment_id = shmget (IPC_PRIVATE, shared_segment_size, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR); shared_memory = (char*) shmat (segment_id, 0, 0); printf ("shared memory attached at address %p\n", shared_memory); shmctl (segment_id, IPC_STAT, &shmbuffer); segment_size = shmbuffer.shm_segsz; printf ("segment size: %d\n", segment_size); sprintf (shared_memory, "Hello, world."); shmdt (shared_memory); shared_memory = (char*) shmat (segment_id, (void*) 0x5000000, 0); printf ("shared memory reattached at address %p\n", shared_memory); printf ("%s\n", shared_memory); shmdt (shared_memory); shmctl (segment_id, IPC_RMID, 0); return 0; }
/* * pvtmMmapAlloc - creates a memory mapped file area. * The return value is a page-aligned memory value, or NULL if there is a failure. * Here * @mmapFileName - the name of the memory mapped file * @size - the size of the memory mapped file (should be a multiple of the system page for best performance) * @create - determines whether or not the area should be created. */ void* pvtmMmapAlloc (char * mmapFileName, size_t size, char create) { void * retv = NULL; if (create) { mode_t origMask = umask(0); int mmapFd = open(mmapFileName, O_CREAT|O_RDWR, 00666); umask(origMask); if (mmapFd < 0) { perror("open mmapFd failed"); return NULL; } if ((ftruncate(mmapFd, size) == 0)) { int result = lseek(mmapFd, size - 1, SEEK_SET); if (result == -1) { perror("lseek mmapFd failed"); close(mmapFd); return NULL; } /* Something needs to be written at the end of the file to * have the file actually have the new size. * Just writing an empty string at the current file position will do. * Note: * - The current position in the file is at the end of the stretched * file due to the call to lseek(). * - The current position in the file is at the end of the stretched * file due to the call to lseek(). * - An empty string is actually a single * will be written at the last byte of the file. */ result = write(mmapFd, "", 1); if (result != 1) { perror("write mmapFd failed"); close(mmapFd); return NULL; } retv = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, mmapFd, 0); if (retv == MAP_FAILED || retv == NULL) { perror("mmap"); close(mmapFd); return NULL; } } } else { int mmapFd = open(mmapFileName, O_RDWR, 00666); if (mmapFd < 0) { return NULL; } int result = lseek(mmapFd, 0, SEEK_END); if (result == -1) { perror("lseek mmapFd failed"); close(mmapFd); return NULL; } if (result == 0) { perror("The file has 0 bytes"); close(mmapFd); return NULL; } retv = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, mmapFd, 0); if (retv == MAP_FAILED || retv == NULL) { perror("mmap"); close(mmapFd); return NULL; } close(mmapFd); } return retv; }
D:\dev\cygwin\lib\gcc\i686-pc-cygwin\3.4.4\include D:\dev\cygwin\usr\include
D:\dev\cygwin\lib\gcc\i686-pc-cygwin\3.4.4\include D:\dev\cygwin\lib\gcc\i686-pc-cygwin\3.4.4\include\c++ D:\dev\cygwin\usr\include
gcc -x c -v -E /dev/null gcc -x c++ -v -E /dev/null
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1 /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/7.0.2/include /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks (framework directory) End of search list.
if (str) fprintf(stderr, "%s: %s\n", str, strerror(errno)); else fprintf(stderr, "%s\n", strerror(errno));
fprintf(stdout, "Error: %s", strerror(errno)); fprintf(stderr, "Error: %s", strerror(errno));
recursive_find6.c:29:20: error: use of undeclared identifier char *current_path[PATH_MAX]; ^
./x86_64-linux-gnu/bits/posix1_lim.h: ./X11/InitialI.h: ./X11/InitialI.h: ./X11/InitialI.h: ./X11/InitialI.h: ./X11/InitialI.h: ./X11/Xos.h: ./X11/Xwindows.h: ./X11/Xwindows.h: ./X11/Xwindows.h: ./X11/Xosdefs.h: ./X11/Xosdefs.h: ./X11/Xosdefs.h: ./X11/Xosdefs.h: ./X11/extensions/XKBsrv.h: ./X11/extensions/XKBsrv.h: ./python2.7/osdefs.h: ./python2.7/osdefs.h: ./python2.7/osdefs.h: ./python2.7/osdefs.h: ./linux/limits.h: ./linux/btrfs.h: ./linux/un.h:
Feature Test Macro Requirements for glibc (see feature_test_macros(7)): strdup(): _SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE >= 500 strndup(), strdupa(), strndupa(): _GNU_SOURCE
double f1(double x) { double res = sin(x); return 0; } int main(void) { return 0; }
/tmp/ccOF5bis.o: In function `f1 test2.c:(.text+0x13): undefined reference to `sin' collect2: ld returned 1 exit status
gcc -Wall -lm mtest.c -o mtest.o mtest.c: In function mtest.c:6:12: warning: unused variable /tmp/cc925Nmf.o: In function `f1 mtest.c:(.text+0x19): undefined reference to `sin' collect2: ld returned 1 exit status
int first_occurence(int k, int array[], int n); int main(void){ int a[] = {4,3,2,3,2,3,4,5,4,5,6,7,8,7,8}; printf("7 first occurs at index %d\n",first_occurence(7,a,15)); printf("but 9 first \"occurs\" at index %d\n",first_occurence(9,a,15)); return 0; } int first_occurence(int k, int array[], int n){ int i = 0; while(i < n){ if(array[i] == k) return i; i += abs(k-array[i]); } return -1; }
7 first occurs at index 11 but 9 first "occurs" at index -1
int main (void) { int array[] = {4,5,6,5,4,3,2,3,4,5,6,7,8}; int len = sizeof array / sizeof array[0]; int i = 0; int steps = 0; while (i < len && array[i] != 7) { i += abs(7 - array[i]); steps++; } printf("Steps %d, index %d\n", steps, i); return 0; }
array[i + 3] = 1 or 3 or 5 array[i + 5] = 1 or 3 or 5 or 7
public static void main(String[] args) { int arr[]={4,5,6,5,4,3,2,3,4,5,6,7,8}; int pos=searchArray(arr,7); if(pos==-1) System.out.println("not found"); else System.out.println("position="+pos); } public static int searchArray(int[] array,int value) { int i=0; int strtValue=0; int pos=-1; while(i<array.length) { strtValue=array[i]; if(strtValue<value) { i+=value-strtValue; } else if (strtValue==value) { pos=i; break; } else { i=i+(strtValue-value); } } return pos; }
int could_contain(int k, int left, int right, int width); int find(int k, int array[], int lower, int upper); int main(void){ int a[] = {4,3,2,3,2,3,4,5,4,5,6,7,8,7,8}; printf("7 first occurs at index %d\n",find(7,a,0,14)); printf("but 9 first \"occurs\" at index %d\n",find(9,a,0,14)); return 0; } int could_contain(int k, int left, int right, int width){ return (width >= 0) && (left <= k && k <= right) || (right <= k && k <= left) || (abs(k - left) + abs(k - right) < width); } int find(int k, int array[], int lower, int upper){ if( !could_contain(k, array[lower], array[upper], upper - lower )) return -1; int mid = (upper + lower) / 2; if(array[mid] == k) return mid; lower = find(k, array, lower + abs(k - array[lower]), mid - abs(k - array[mid])); if(lower >= 0 ) return lower; upper = find(k, array, mid + abs(k - array[mid]), upper - abs(k - array[upper])); if(upper >= 0 ) return upper; return -1; }
char *some_memory; size_t size_to_allocate = A_MEGABYTE; some_memory = (char *)malloc(size_to_allocate); sprintf(some_memory, "Hello World"); printf("%s\n", some_memory); free(some_memory);
char *some_memory = "Hello World"; sprintf(some_memory, "Goodbye...");
char some_memory[LINE_LEN] = "Hello World"; strcpy(some_memory, "Goodbye, sad world..."); printf("%s\n", some_memory);
void what(int n) { int i; for (i = 1; i <= n; i++) { int x = n; while (x > 0) x -= i; } }
unsigned long long what(int n) { unsigned long long cnt = 0; int i; for (i = 1; i <= n; i++) { int x = n; while (x > 0) { x -= i; cnt++; } } return cnt; } void wtest(int n) { unsigned long long cnt = what(n); printf("%d %llu\n", n, cnt); fflush(stdout); } void wtests(void) { int i = INT_MAX/2 + 1; while (i > 0) { wtest(i); i /= 2; } } int main(void) { wtests(); return 0; }
1073741824 23567395117 536870912 11411566988 268435456 5519718329 134217728 2666826555 67108864 1286897093 33554432 620190504 16777216 298466265 8388608 143418602 4194304 68802063 2097152 32947406 1048576 15746897 524288 7510048 262144 3573331 131072 1695816 65536 802493 32768 378537 16384 177921 8192 83286 4096 38803 2048 17973 1024 8275 512 3782 256 1713 128 765 64 337 32 145 16 61 8 24 4 9 2 3 1 1
struct Vector { int size; int limit; int* ints; } Vector* Vector_new() { Vector* res = (Vector*) malloc(sizeof(Vector)); res->limit = 10; res->size = 0; res->ints = (int*) malloc(sizeof(int) * res.limit); return res; } void Vector_destroy(Vector* v) { free(v->ints); free(v); } void Vector_add(Vector* v, int n) { if(v->size == v->limit) { v->limit = v->limit * 2 + 10; v->ints = realloc(v->ints, v->limit); } v->ints[v->size] = n; ++v->size; } int Vector_get(Vector* v, int index) { if(index >= 0 && index < v->size) return v->ints[index]; assert false; }
volatile int tmp; tmp = pageptr[0]; pageptr[0] = tmp;
unsigned char *pageptr = ...; ((unsigned char volatile *)pageptr)[0] = pageptr[0];
void __attribute__((optimize("O0"))) foo(unsigned char data) { }
int main () { char str[] ="- This, a sample string."; char * pch; printf ("Splitting string \"%s\" into tokens:\n",str); pch = strtok (str," ,.-"); while (pch != NULL) { printf ("%s\n",pch); pch = strtok (NULL, " ,.-"); } return 0; }
for (char *p = strtok(s," "); p != NULL; p = strtok(NULL, " ")) { puts(p); }
char str[] = "this, is the string - I want to parse"; char delim[] = " ,-"; char* token; for (token = strtok(str, delim); token; token = strtok(NULL, delim)) { printf("token=%s\n", token); }
char *zStrtok(char *str, const char *delim) { static char *static_str=0; int index=0, strlength=0; int found = 0; /* delimiter cannot be NULL * if no more char left, return NULL as well */ if (delim==0 || (str == 0 && static_str == 0)) return 0; if (str == 0) str = static_str; while(str[strlength]) strlength++; for (index=0;index<strlength;index++) if (str[index]==delim[0]) { found=1; break; } if (!found) { static_str = 0; return str; } /* check for consecutive delimiters *if first char is delim, return delim */ if (str[0]==delim[0]) { static_str = (str + 1); return (char *)delim; } /* terminate the string * this assignmetn requires char[], so str has to * be char[] rather than *char */ str[index] = if ((str + index + 1)!=0) static_str = (str + index + 1); else static_str = 0; return str; }
Example Usage char str[] = "A,B,,,C"; printf("1 %s\n",zStrtok(s,",")); printf("2 %s\n",zStrtok(NULL,",")); printf("3 %s\n",zStrtok(NULL,",")); printf("4 %s\n",zStrtok(NULL,",")); printf("5 %s\n",zStrtok(NULL,",")); printf("6 %s\n",zStrtok(NULL,",")); Example Output 1 A 2 B 3 , 4 , 5 C 6 (null)
int *create_delim_dict(char *delim) { int *d = (int*)malloc(sizeof(int)*DICT_LEN); memset((void*)d, 0, sizeof(int)*DICT_LEN); int i; for(i=0; i< strlen(delim); i++) { d[delim[i]] = 1; } return d; } char *my_strtok(char *str, char *delim) { static char *last, *to_free; int *deli_dict = create_delim_dict(delim); if(!deli_dict) { if(to_free) { free(to_free); } return NULL; } if(str) { last = (char*)malloc(strlen(str)+1); if(!last) { free(deli_dict); return NULL; } to_free = last; strcpy(last, str); } while(deli_dict[*last] && *last != last++; } str = last; if(*last == free(deli_dict); free(to_free); deli_dict = NULL; to_free = NULL; return NULL; } while (*last != last++; } *last = last++; free(deli_dict); return str; } int main() { char * str = "- This, a sample string."; char *del = " ,.-"; char *s = my_strtok(str, del); while(s) { printf("%s\n", s); s = my_strtok(NULL, del); } return 0; }
using namespace std; char* mystrtok(char str[],char filter[]) { if(filter == NULL) { return str; } static char *ptr = str; static int flag = 0; if(flag == 1) { return NULL; } char* ptrReturn = ptr; for(int j = 0; ptr != for(int i=0 ; filter[i] != if(ptr[j] == flag = 1; return ptrReturn; } if( ptr[j] == filter[i]) { ptr[j] = ptr+=j+1; return ptrReturn; } } } return NULL; } int _tmain(int argc, _TCHAR* argv[]) { char str[200] = "This,is my,string.test"; char *ppt = mystrtok(str,", ."); while(ppt != NULL ) { cout<< ppt << endl; ppt = mystrtok(NULL,", ."); } return 0; }
int main() { char s[] = "Hello, my name is? Matthew! Hey."; char* p; for (char *p = strtok(s," ,?!."); p != NULL; p = strtok(NULL, " ,?!.")) { puts(p); } return 0; }
char buf[10] = ""; char buf[10] = {0}; char buf[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
char buf[10] = " "; char buf[10] = { char buf[10] = {
char buf[10] = "a"; char buf[10] = { char buf[10] = {
struct ccont { char array[32]; }; struct icont { int array[32]; }; int main() { int cnt; char carray[32] = { int iarray[32] = { 67, 42, 25 }; struct ccont cc = { 0 }; struct icont ic = { 0 }; /* these don carray = { [0]=1 }; carray = { [0 ... 31]=1 }; carray = (char[32]){ [0]=3 }; iarray = (int[32]){ 1 }; */ cc = (struct ccont){ .array= cc = (struct ccont){ .array={ [0 ... 2]= ic = (struct icont){ .array={ 42,67 } }; ic = (struct icont){ .array={ [0 ... 1]=42, [1 ... 2]=67 } }; for (cnt=0; cnt<5; cnt++) printf("%2d %c %2d %c\n",iarray[cnt], carray[cnt],ic.array[cnt],cc.array[cnt]); return 0; }
main() { void something(char[]); char s[100] = ""; something(s); printf("%s", s); } void something(char s[]) { }
F_GETPATH Get the path of the file descriptor Fildes. The argu- ment must be a buffer of size MAXPATHLEN or greater.
char filePath[PATH_MAX]; if (fcntl(fd, F_GETPATH, filePath) != -1) { }
int main() { char *x=NULL; if (x==NULL) printf("is NULL\n"); return EXIT_SUCCESS; }
int * p = NULL; ... if (...) { p = (int*) malloc(...); ... } ... free(p);
int main() { char * x = NULL; if (x==NULL) printf("is NULL\n"); return EXIT_SUCCESS; }
int main() { char* x = 0; if ( !x ) printf(" x points to NULL\n"); return EXIT_SUCCESS; }
int main() { char* x = NULL; x = alloc( sizeof( char )); *x = if ( *x == printf(" x points to an address/location that contains a return EXIT_SUCCESS; } x is the street address of a house. *x examines the contents of that house.
typedef struct _parent { float calc ; char text[255] ; int used ; } parent_t ;
typedef struct _child { char flag ; char text[sizeof(parent_t.text)] ; int used ; } child_t ;
parent_t* dummy ; typedef struct _child { char flag ; char text[sizeof(dummy->text)] ; int used ; } child_t ;
typedef struct { float calc; char text[255]; int used; } Parent; typedef struct { char flag; char text[member_size(Parent, text)]; int used; } Child;
sizeof(((parent_t *)0)->text) sizeof(((parent_t){0}).text)
typedef struct _parent { float calc ; char text[TEXT_LEN] ; int used ; } parent_t ; typedef struct _child { char flag ; char text[TEXT_LEN] ; int used ; } child_t ;
struct Penguin { char name[128]; struct Penguin *child[16]; }; static const int name_size = fldsiz(Penguin, name) / sizeof(char); static const int child_size = fldsiz(Penguin, child) / sizeof(struct Penguin *); int main(void) { printf("Penguin.name is %d chars and Penguin.child is %d Penguin *.\n", name_size, child_size); return EXIT_SUCCESS; }
struct Parent { float calc; char text[255]; int used; }; struct Child { char flag; char text[sizeof(Parent::text)]; int used; };
sizeof(((type*)0)->member[0]) struct parent { int array[20]; }; struct child { int array[member_dim(struct parent, array)]; }; int main ( void ) { return member_dim(struct child, array); }
square(1 + 2) --> 1 + 2 * 1 + 2 --> 1 + 2 + 2 --> 5 square(x++) --> x++ * x++ --> increments x twice
if (x < y) swap(x, y); --> if (x < y) t = x; x = y; y = t; --> if (x < y) { t = x; } x = y; y = t;
struct shirt { int numButtons; }; struct webpage { int numButtons; }; struct webpage page; page.numButtons = 2; num_button_holes(page) -> 8
int foo(int *a, int *b){ side_effect0(); side_effect1(); return a[0] + b[0]; }
int main() { int x = 2; int y = SQUARE(x++); return 0; }
int square(int x) { return x * x; } int main() { int x = 2; int y = square(x++); return 0; }
struct foo { int bar; }; int main() { struct foo f; int a = GET_BAR(&f); int b = GET_BAR(&a); return 0; }
struct foo { int bar; }; int get_bar(struct foo *f) { return f->bar; } int main() { struct foo f; int a = get_bar(&f); int b = get_bar(&a); return 0; }
inline float _square_fl(float a) { return a * a; } inline double _square_dbl(float a) { return a * a; } inline int _square_i(int a) { return a * a; } inline unsigned int _square_ui(unsigned int a) { return a * a; } inline short _square_s(short a) { return a * a; } inline unsigned short _square_us(unsigned short a) { return a * a; } _Generic((a), \ float: _square_fl(a), \ double: _square_dbl(a), \ int: _square_i(a), \ unsigned int: _square_ui(a), \ short: _square_s(a), \ unsigned short: _square_us(a))
int mask = 1 << k; int masked_n = n & mask; int thebit = masked_n >> k;
int *get_bits(int n, int bitswanted){ int *bits = malloc(sizeof(int) * bitswanted); int k; for(k=0; k<bitswanted; k++){ int mask = 1 << k; int masked_n = n & mask; int thebit = masked_n >> k; bits[k] = thebit; } return bits; } int main(){ int n=7; int bitswanted = 5; int *bits = get_bits(n, bitswanted); printf("%d = ", n); int i; for(i=bitswanted-1; i>=0;i--){ printf("%d ", bits[i]); } printf("\n"); }
int main(int argc, char** argv) { unsigned input = 0b0111u, n_bits = 4u, *bits = (unsigned*)malloc(sizeof(unsigned) * n_bits), bit = 0; for(bit = 0; bit < n_bits; ++bit) bits[bit] = (input >> bit) & 1; for(bit = n_bits; bit--;) printf("%u", bits[bit]); printf("\n"); free(bits); }
for(bit = 0; bit < n_bits; ++bit, input >>= 1) bits[bit] = input & 1;
bool b[4]; int v = 7; for (int j = 0; j < 4; ++j) b [j] = 0 != (v & (1 << j));
int main() { int s=7,l=1; vector <bool> v; v.clear(); while (l <= 4) { v.push_back(s%2); s /= 2; l++; } for (l=(v.size()-1); l >= 0; l--) { cout<<v[l]<<" "; } return 0; }
std::vector <bool> bits_from_int (int integer) { std::vector <bool> bool_bits; for (int i = 0; i < 8; i++) { bool_bits.push_back (integer%2); integer /= 2; } return bool_bits; }
int main(void) { int num = 7; bool arr[4] = { (num&1) ?true: false, (num&2) ?true: false, (num&4) ?true: false, (num&8) ?true: false }; bool arr[4] = { BTB(num,0), BTB(num,1), BTB(num,2), BTB(num,3)}; printf("%d %d %d %d\n", arr[3], arr[2], arr[1], arr[0]); return 0; }
int value = 123; std::bitset<sizeof(int)> bits(value); std::cout <<bits.to_string();
int main(void) { int number = 7; int vbool[8 * sizeof(int)]; int i; for (i = 0; i < 8 * sizeof(int); i++) { vbool[i] = number<<i < 0; printf("%d", vbool[i]); } return 0; }
void print_with_indent(int indent, char * string) { printf("%*s%s", indent, "", string); }
printf("%*d",10,10); printf("%*c",20, printf("%*s",30,"Hello");
% [ param-no $] flags width [ . precision ] type conversion
% [ param-no $] flags width . * [ param-no $] type conversion
fwrite(your_string, sizeof(char), number_of_chars, stdout);
int main() { int i; for(i=0;i<n;i++) { printf("%c",str[i]); } return 0; }
int main() { printf ("%.5s","fahaduddin"); return 0; }
int main(void) { char name[100]; printf("Enter your name: "); scanf("%s", name); printf("Your Name is: %s", name); return 0; }
int main() { char name[100]; printf("Enter your name: "); fgets(name, 100, stdin); printf("Your Name is: %s", name); return 0; }
int main() { int i,size; char a[100]; fgets(a,100,stdin);; size = strlen(a); a[size-1]= return 0; }
int main() { char name[100]; printf("Enter your name: "); scanf("%[^\n]s",name); printf("Your Name is: %s",name); return 0; }
char ch[100]; int i; for (i = 0; ch[i] != { scanf("%c ", &ch[i]); }
int read_line(char str[]) { int c, i=0; c = getchar(); while (c != str[i] = c; c = getchar(); i++; } str[i] = return i; }
int n; scanf("%d", &n); char str[1001]; char temp; scanf("%c",&temp); scanf("%[^\n]",str);
int main() { printf("Enter your name\n"); char a[80]; gets(a); printf("Your name is %s\n", a); return 0; }
char *s; size_t size = 10; int main(){ s = (char *)malloc(size+1); getline(&s,&size,stdin); printf("%s",s); return 0; }
int main(void) { char name[100]; printf("Enter your name: "); scanf(" %[^\n]s", name); printf("Your Name is: %s", name); return 0; }
size_t i = 0; uint32_t k = 0; printf("i [ %lu ] k [ %u ]\n", i, k);
format ‘%lu’ expects type ‘long unsigned int’, but argument has type ‘uint32_t’
Format argument 1 to printf (%u) expects unsigned int gets size_t: k
size_t sz; printf("%zu\n", sz); printf("%lu\n", (unsigned long)sz);
Makefile.am:10: error: Libtool library used but Makefile.am:10: The usual way to define Makefile.am:10: to Makefile.am:10: If Makefile.am:10: its definition is in aclocal
AC_PREREQ([2.69]) AC_INIT([orientdb-c],[0.9]) AC_CONFIG_SRCDIR([src/o_query_internal.h]) AC_CONFIG_HEADERS([config.h]) AM_INIT_AUTOMAKE() AC_PROG_CXX AC_PROG_AWK AC_PROG_CC AC_PROG_CPP AC_PROG_INSTALL AC_PROG_LN_S AC_PROG_MAKE_SET LT_INIT AC_CHECK_HEADERS([malloc.h memory.h netdb.h netinet/in.h stdlib.h string.h sys/ioctl.h sys/socket.h sys/time.h unistd.h]) AC_TYPE_SIZE_T AC_FUNC_MALLOC AC_FUNC_REALLOC AC_CHECK_FUNCS([gethostbyname memset socket strchr strcspn strdup strerror]) AC_CONFIG_FILES([Makefile]) AC_OUTPUT
int main(void) { float a[4] __attribute__((aligned(0x1000))) = {1.0, 2.0, 3.0, 4.0}; printf("%p %p %p %p\n", &a[0], &a[1], &a[2], &a[3]); }
0x7fffbfcd2da0 0x7fffbfcd2da4 0x7fffbfcd2da8 0x7fffbfcd2dac
float a[4] __attribute__((aligned(0x1000))) = {1.0, 2.0, 3.0, 4.0}; int main(void) { printf("%p %p %p %p\n", &a[0], &a[1], &a[2], &a[3]); }
int main(void) { float a[4] = { 1.0, 2.0, 3.0, 4.0 }; float b[4] __attribute__((aligned(0x1000))) = { 1.0, 2.0, 3.0, 4.0 }; float c[4] __attribute__((aligned(0x10000))) = { 1.0, 2.0, 3.0, 4.0 }; printf("%p %p %p %p\n", &a[0], &a[1], &a[2], &a[3]); printf("%p %p %p %p\n", &b[0], &b[1], &b[2], &b[3]); printf("%p %p %p %p\n", &c[0], &c[1], &c[2], &c[3]); }
0x7ffffffefff0 0x7ffffffefff4 0x7ffffffefff8 0x7ffffffefffc 0x7ffffffef000 0x7ffffffef004 0x7ffffffef008 0x7ffffffef00c 0x7ffffffe0000 0x7ffffffe0004 0x7ffffffe0008 0x7ffffffe000c
struct my_float { float number; } __attribute__((aligned(0x1000))); struct my_float a[4] = { {1.0}, {2.0}, {3.0}, {4.0} }; int main(void) { printf("%p %p %p %p\n", &a[0], &a[1], &a[2], &a[3]); }
$ ./test_orig-3.4.6 0x7fffe217d200 0x7fffe217d204 0x7fffe217d208 0x7fffe217d20c $ ./test_orig-4.4.1 0x7fff81db9000 0x7fff81db9004 0x7fff81db9008 0x7fff81db900c
std::wstring BuildDate = std::wstring(WIDEN(__DATE__)) + L" " + WIDEN(__TIME__);
int CREATE_3_VARS(myInts); myInts1 = 13; myInts2 = 19; myInts3 = 77;
int main() { printf( "buggy results:\n"); printf( "%s\n", STRINGIFY( BAD_PASTE( SOME_MACRO, __LINE__))); printf( "%s\n", BAD_STRINGIFY( BAD_PASTE( SOME_MACRO, __LINE__))); printf( "%s\n", BAD_STRINGIFY( PASTE( SOME_MACRO, __LINE__))); printf( "\n" "desired result:\n"); printf( "%s\n", STRINGIFY( PASTE( SOME_MACRO, __LINE__))); }
buggy results: SOME_MACRO__LINE__ BAD_PASTE( SOME_MACRO, __LINE__) PASTE( SOME_MACRO, __LINE__) desired result: function_name21
foo.cpp:16:1: pasting "1" and "+" does not give a valid preprocessing token foo.cpp:16:1: pasting "+" and "2" does not give a valid preprocessing token foo.cpp:16:1: pasting "std" and "::" does not give a valid preprocessing token foo.cpp:16:1: pasting "::" and "vector" does not give a valid preprocessing token
LOAD_IMGLIB_FN (library, XpmFreeAttributes); LOAD_IMGLIB_FN (library, XpmCreateImageFromBuffer); LOAD_IMGLIB_FN (library, XpmReadFileToImage); LOAD_IMGLIB_FN (library, XImageFree);
ENUM_BEGIN( Color ) ENUM(RED), ENUM(GREEN), ENUM(BLUE) ENUM_END( Color )
const char *ColorStringTable[] = { "RED", "GREEN", "BLUE" };
STATUS activeCall_constructor( HANDLE *pInst ) STATUS activeCall_eventHandler( HANDLE *pInst, TOKEN *pEvent ); STATUS activeCall_destructor( HANDLE *pInst );
SCREEN_HANDLER( activeCall ) SCREEN_HANDLER( ringingCall ) SCREEN_HANDLER( heldCall )
struct list_int { int value; struct list_int *next; };
void f(const char *str, int str_len) { printf("%.*s\n", str_len, str); }
int main() { int precision = 8; int biggerPrecision = 16; const char *greetings = "Hello world"; printf("|%.8s|\n", greetings); printf("|%.*s|\n", precision , greetings); printf("|%16s|\n", greetings); printf("|%*s|\n", biggerPrecision , greetings); return 0; }
|Hello wo| |Hello wo| | Hello world| | Hello world|
static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) { (void)ud; (void)osize; return ptr; }
unused.c: In function ‘l_alloc’: unused.c:3:22: warning: unused parameter ‘ud’ [-Wunused-parameter] void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) { ^~
unused.c:5:5: warning: statement with no effect [-Wunused-value] ud; ^~
int begin() -> int decode(a,n,i,m,a,t,e)() -> int m
/* This must be compiled with the flag -nostdlib because otherwise the * linker will complain about multiple definitions of the symbol _start * (one here and one in glibc) and a missing reference to symbol main * (that the libc expects to be linked against). */ void _start () { /* calling the write system call, with the arguments in this order: * 1. the stdout file descriptor * 2. the buffer we want to print (Here it * 3. the amount of bytes we want to write. */ asm ("int $0x80"::"a"(4), "b"(1), "c"("Hello world!\n"), "d"(13)); asm ("int $0x80"::"a"(1), "b"(0)); }
/* These values are extracted from the decimal representation of the instructions * of a hello world program written in asm, that gdb provides. */ const int main[] = { -443987883, 440, 113408, -1922629632, 4149, 899584, 84869120, 15544, 266023168, 1818576901, 1461743468, 1684828783, -1017312735 };
int flags = fcntl(fd, F_GETFL, 0); fcntl(fd, F_SETFL, flags | O_NONBLOCK);
if (dest_size > 0) { dest[0] = strncat(dest, source, dest_size - 1); }
char buf[10]; scanf("%9[^\n]%*[^\n]", buf)); getchar();
char buf[10]; if (fgets(buf, sizeof buf, stdin) != NULL) { char *nl; if ((nl = strrchr(buf, int c; while ((c = getchar()) != EOF && c != ; } } else { *nl = 0; } }
memset(Buffer,0x00,sizeof(Buffer)); strncpy(Buffer,BUFSIZE,"12345678901234567890");
memset(Buffer,0x00,sizeof(Buffer)); if(snprintf(Buffer,BUFIZE,"Data: %s","Too much data") > BUFSIZE) { } /* If using MFC, you need if(... < 0), instead */
void rmdup(int *array, int length) { int *current , *end = array + length - 1; for ( current = array + 1; array < end; array++, current = array + 1 ) { while ( current <= end ) { if ( *current == *array ) { *current = *end--; } else { current++; } } } }
void uniqueInPlace(T)(ref T[] dataIn) { uniqueInPlaceImpl(dataIn, 0); } void uniqueInPlaceImpl(T)(ref T[] dataIn, size_t start) { if(dataIn.length - start < 2) return; invariant T sentinel = dataIn[start]; T[] data = dataIn[start + 1..$]; static hash_t getHash(T elem) { static if(is(T == uint) || is(T == int)) { return cast(hash_t) elem; } else static if(__traits(compiles, elem.toHash)) { return elem.toHash; } else { static auto ti = typeid(typeof(elem)); return ti.getHash(&elem); } } for(size_t index = 0; index < data.length;) { if(data[index] == sentinel) { index++; continue; } auto hash = getHash(data[index]) % data.length; if(index == hash) { index++; continue; } if(data[index] == data[hash]) { data[index] = sentinel; index++; continue; } if(data[hash] == sentinel) { swap(data[hash], data[index]); index++; continue; } auto hashHash = getHash(data[hash]) % data.length; if(hashHash != hash) { swap(data[index], data[hash]); if(hash < index) index++; } else { index++; } } size_t swapPos = 0; foreach(i; 0..data.length) { if(data[i] != sentinel && i == getHash(data[i]) % data.length) { swap(data[i], data[swapPos++]); } } size_t sentinelPos = data.length; for(size_t i = swapPos; i < sentinelPos;) { if(data[i] == sentinel) { swap(data[i], data[--sentinelPos]); } else { i++; } } dataIn = dataIn[0..sentinelPos + start + 1]; uniqueInPlaceImpl(dataIn, start + swapPos + 1); }
int i, j; int NewLength = 1; for(i=1; i< Length; i++){ for(j=0; j< NewLength ; j++) { if(array[i] == array[j]) break; } if (j==NewLength ) array[NewLength++] = array[i]; }
foreach $i (@myary) { if(!defined $seen{$i}) { $seen{$i} = 1; push @newary, $i; } }
size_t rmdup(int *arr, size_t len) { size_t prev = 0; size_t curr = 1; size_t last = len - 1; while (curr <= last) { for (prev = 0; prev < curr && arr[curr] != arr[prev]; ++prev); if (prev == curr) { ++curr; } else { arr[curr] = arr[last]; --last; } } return curr; } void print_array(int *arr, size_t len) { printf("{"); size_t curr = 0; for (curr = 0; curr < len; ++curr) { if (curr > 0) printf(", "); printf("%d", arr[curr]); } printf("}"); } int main() { int arr[] = {4, 8, 4, 1, 1, 2, 9}; printf("Before: "); size_t len = sizeof (arr) / sizeof (arr[0]); print_array(arr, len); len = rmdup(arr, len); printf("\nAfter: "); print_array(arr, len); printf("\n"); return 0; }
int[] removeDuplicate(int[] input){ int arrayLen = input.length; for(int i=0;i<arrayLen;i++){ for(int j = i+1; j< arrayLen ; j++){ if(((input[i]^input[j]) == 0)){ input[j] = 0; } if((input[j]==0) && j<arrayLen-1){ input[j] = input[j+1]; input[j+1] = 0; } } } return input; }
void unique(int* input, int n) { merge_sort(input, 0, n) ; int prev = 0 ; for(int i = 1 ; i < n ; i++) { if(input[i] != input[prev]) if(prev < i-1) input[prev++] = input[i] ; } }
int length = array.length; for (int i = 0; i < length; i++) { for (int j = i + 1; j < length; j++) { if (array[i] == array[j]) { int k, j; for (k = j + 1, l = j; k < length; k++, l++) { if (array[k] != array[i]) { array[l] = array[k]; } else { l--; } } length = l; } } }
int algorithm(int[] a, int n) { int i, j; for (j = 0, i = 1; i < n; i++) { if (heapInsert(a, j, a[i])) j++; } return j; } bool heapInsert(a[], int n, int val) { ...code omitted for brevity... if (duplicate element a[k] == val) return false; a[k] = val; return true; }
int* temp = malloc(sizeof(int)*len); int count = 0; int x =0; int y =0; for(x=0;x<len;x++) { for(y=0;y<count;y++) { if(*(temp+y)==*(array+x)) { break; } } if(y==count) { *(temp+count) = *(array+x); count++; } } memcpy(array, temp, sizeof(int)*len);
var A: Array of Integer; I,J,C,K, P: Integer; begin C:=10; SetLength(A,10); A[0]:=1; A[1]:=4; A[2]:=2; A[3]:=6; A[4]:=3; A[5]:=4; A[6]:=3; A[7]:=4; A[8]:=2; A[9]:=5; for I := 0 to C-1 do begin for J := I+1 to C-1 do if A[I]=A[J] then begin for K := C-1 Downto J do if A[J]<>A[k] then begin P:=A[K]; A[K]:=0; A[J]:=P; C:=K; break; end else begin A[K]:=0; C:=K; end; end; end; setlength(A,C); end;
def check_dump(x): if not x in t: t.append(x) return True t=[] output = filter(check_dump, input) print(output) True
import java.util.ArrayList; public class C { public static void main(String[] args) { int arr[] = {2,5,5,5,9,11,11,23,34,34,34,45,45}; ArrayList<Integer> arr1 = new ArrayList<Integer>(); for(int i=0;i<arr.length-1;i++){ if(arr[i] == arr[i+1]){ arr[i] = 99999; } } for(int i=0;i<arr.length;i++){ if(arr[i] != 99999){ arr1.add(arr[i]); } } System.out.println(arr1); } }
int numbers[] = {4, 8, 4, 1, 1, 2, 9}; size_t undup_it(int array[], size_t len) { size_t src,dst; if (len <2) return len; for (src=dst=1; src < len; src++) { size_t cur; for (cur=0; cur < dst; cur++ ) { if (array[cur] == array[src]) break; } if (cur != dst) continue; if (dst < src) array[dst] = array[src]; dst++; } return dst; } void print_it(int array[], size_t len) { size_t idx; for (idx=0; idx < len; idx++) { printf("%c %d", (idx) ? } printf("}\n" ); } int main(void) { size_t cnt = COUNT; printf("Before undup:" ); print_it(numbers, cnt); cnt = undup_it(numbers,cnt); printf("After undup:" ); print_it(numbers, cnt); return 0; }
Integer[] arrayInteger = {1,2,3,4,3,2,4,6,7,8,9,9,10}; String value =""; for(Integer i:arrayInteger) { if(!value.contains(Integer.toString(i))){ value +=Integer.toString(i)+","; } } String[] arraySplitToString = value.split(","); Integer[] arrayIntResult = new Integer[arraySplitToString.length]; for(int i = 0 ; i < arraySplitToString.length ; i++){ arrayIntResult[i] = Integer.parseInt(arraySplitToString[i]); }
{ if (check[arr[i]] != 1) { arr[i] = 0; } else { check[arr[i]] = 0; } }
Algorithm delete_duplicates (a[1....n]) { temp[1:n]; temp[i]=a[i];for i=1 to n temp[i].value=a[i] temp[i].key=i p[i]=temp[i]value return p.
int main(void){ int x,n,myvar=0; printf("Enter a number: \t"); scanf("%d",&n); int arr[n],changedarr[n]; for(x=0;x<n;x++){ printf("Enter a number for array[%d]: ",x); scanf("%d",&arr[x]); } printf("\nOriginal Number in an array\n"); for(x=0;x<n;x++){ printf("%d\t",arr[x]); } int i=0,j=0; for (int i = 0; i < n; i++) { for (int j = 0; j <n; j++) { if (i==j) { continue; } else if(arr[i]==arr[j]){ changedarr[j]=0; } else{ changedarr[i]=arr[i]; } } myvar+=1; } int count=0; printf("\nThe unique items:\n"); for (int i = 0; i < myvar; i++) { if(changedarr[i]!=0){ count+=1; printf("%d\t",changedarr[i]); } } printf("\n"); }
DataStructure elementsSeen = new DataStructure(); int elementsRemoved = 0; for(int i=0;i<array.Length;i++){ if(elementsSeen.Contains(array[i]) elementsRemoved++; else array[i-elementsRemoved] = array[i]; } array.Length = array.Length - elementsRemoved;
Definition in header: Definition in implementation: +---------------------------------+ +---------------------------------+ | struct s { | | struct s; | | int internal; | | | | int other_stuff; | | extern void | | }; | | api_func(struct s *foo, int x); | | | +---------------------------------+ | extern void | +---------------------------------+ | api_func(struct s *foo, int x); | | +---------------------------------+ | | +---------------------------------+ | struct s { | | | | | int other_stuff; | | void | | }; | | api_func(struct s *foo, int x) | | | | { | | void | | foo->internal = x; | | api_func(struct s *foo, int x) | | } | | { | +---------------------------------+ | foo->internal = x; | | } | +---------------------------------+
$ gcc -Wall -c bad.c bad.c: In function bad.c:5: error: dereferencing pointer to incomplete type $
swapped = ((num>>24)&0xff) | ((num<<8)&0xff0000) | ((num>>8)&0xff00) | ((num<<24)&0xff000000);
uint16_t swap_uint16( uint16_t val ) { return (val << 8) | (val >> 8 ); } int16_t swap_int16( int16_t val ) { return (val << 8) | ((val >> 8) & 0xFF); } uint32_t swap_uint32( uint32_t val ) { val = ((val << 8) & 0xFF00FF00 ) | ((val >> 8) & 0xFF00FF ); return (val << 16) | (val >> 16); } int32_t swap_int32( int32_t val ) { val = ((val << 8) & 0xFF00FF00) | ((val >> 8) & 0xFF00FF ); return (val << 16) | ((val >> 16) & 0xFFFF); }
int64_t swap_int64( int64_t val ) { val = ((val << 8) & 0xFF00FF00FF00FF00ULL ) | ((val >> 8) & 0x00FF00FF00FF00FFULL ); val = ((val << 16) & 0xFFFF0000FFFF0000ULL ) | ((val >> 16) & 0x0000FFFF0000FFFFULL ); return (val << 32) | ((val >> 32) & 0xFFFFFFFFULL); } uint64_t swap_uint64( uint64_t val ) { val = ((val << 8) & 0xFF00FF00FF00FF00ULL ) | ((val >> 8) & 0x00FF00FF00FF00FFULL ); val = ((val << 16) & 0xFFFF0000FFFF0000ULL ) | ((val >> 16) & 0x0000FFFF0000FFFFULL ); return (val << 32) | (val >> 32); }
void SwapBytes(void *pv, size_t n) { assert(n > 0); char *p = pv; size_t lo, hi; for(lo=0, hi=n-1; hi>lo; lo++, hi--) { char tmp=p[lo]; p[lo] = p[hi]; p[hi] = tmp; } }
uint32 cq_ntohl(uint32 a) { __asm{ mov eax, a; bswap eax; } }
int main (int argc, char *argv[]) { size_t sizeofInt = sizeof (int); int i; union { int x; char c[sizeof (int)]; } original, swapped; original.x = 0x12345678; for (i = 0; i < sizeofInt; i++) swapped.c[sizeofInt - i - 1] = original.c[i]; fprintf (stderr, "%x\n", swapped.x); return 0; }
uint32_t swapped, result; ((byte*)&swapped)[0] = ((byte*)&result)[3]; ((byte*)&swapped)[1] = ((byte*)&result)[2]; ((byte*)&swapped)[2] = ((byte*)&result)[1]; ((byte*)&swapped)[3] = ((byte*)&result)[0];
unsigned int *bswap(unsigned int *destination, unsigned int *source, int length) { int i; __m128i mask = _mm_set_epi8(12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3); for (i = 0; i < length; i += 4) { _mm_storeu_si128((__m128i *)&destination[i], _mm_shuffle_epi8(_mm_loadu_si128((__m128i *)&source[i]), mask)); } return destination; }
// // // // inline void SwapBytes(void *source, int size) { typedef unsigned char TwoBytes[2]; typedef unsigned char FourBytes[4]; typedef unsigned char EightBytes[8]; unsigned char temp; if(size == 2) { TwoBytes *src = (TwoBytes *)source; temp = (*src)[0]; (*src)[0] = (*src)[1]; (*src)[1] = temp; return; } if(size == 4) { FourBytes *src = (FourBytes *)source; temp = (*src)[0]; (*src)[0] = (*src)[3]; (*src)[3] = temp; temp = (*src)[1]; (*src)[1] = (*src)[2]; (*src)[2] = temp; return; } if(size == 8) { EightBytes *src = (EightBytes *)source; temp = (*src)[0]; (*src)[0] = (*src)[7]; (*src)[7] = temp; temp = (*src)[1]; (*src)[1] = (*src)[6]; (*src)[6] = temp; temp = (*src)[2]; (*src)[2] = (*src)[5]; (*src)[5] = temp; temp = (*src)[3]; (*src)[3] = (*src)[4]; (*src)[4] = temp; return; } }
void ChangeMemEndianness(uint64_t *mem, size_t size) { uint64_t m1 = 0xFF00FF00FF00FF00ULL, m2 = m1 >> CHAR_BIT; size = (size + (sizeof (uint64_t) - 1)) / sizeof (uint64_t); for(; size; size--, mem++) *mem = ((*mem & m1) >> CHAR_BIT) | ((*mem & m2) << CHAR_BIT); }
main(){ unsigned int i = 0xfafbfcfd; unsigned int j; j= ((i&0xff000000)>>24)| ((i&0xff0000)>>8) | ((i&0xff00)<<8) | ((i&0xff)<<24); printf("unsigned int j = %x\n ", j); }
unsigned short wBigE = value; unsigned short wLittleE = ((wBigE & 0xFF) << 8) | (wBigE >> 8);
unsigned int iBigE = value; unsigned int iLittleE = ((iBigE & 0xFF) << 24) | ((iBigE & 0xFF00) << 8) | ((iBigE >> 8) & 0xFF00) | (iBigE >> 24);
+--------+ | pid=7 | | ppid=4 | | bash | +--------+ | | calls fork V +--------+ +--------+ | pid=7 | forks | pid=22 | | ppid=4 | ----------> | ppid=7 | | bash | | bash | +--------+ +--------+ | | | waits for pid 22 | calls exec to run ls | V | +--------+ | | pid=22 | | | ppid=7 | | | ls | V +--------+ +--------+ | | pid=7 | | exits | ppid=4 | <---------------+ | bash | +--------+ | | continues V
int X = open("./output_file.txt", O_WRONLY); pid_t fk = fork(); if (!fk) { dup2(X, 1); close(X); execl("/bin/echo", "/bin/echo", "hello world"); _exit(127); } else if (fk == -1) { perror("fork"); } close(X);
unsigned int To, Tf; To = getcounter(); while (1) { Tf = getcounter(); if ((Tf-To) >= TIME_LIMIT) { break; } }
unsigned int five = 5, seven = 7; unsigned int a = five - seven; int one = 1, six = 6; unsigned int b = one - six;
if (abs(five - seven) < seven) if (five - seven < -1) if (one - six < 1) if ((int)(five - seven) < 1)
char num_str[10]; int process_numbers_str(Numbers num) { switch(num) { case ONE: case TWO: case THREE: { strcpy(num_str, num); } break; default: return 0; return 1; }
enum EnumType { \ ENUM_DEF(ENUM_VALUE) \ }; \ const char *GetString(EnumType dummy); \ EnumType Get const char *GetString(EnumType value) \ { \ switch(value) \ { \ ENUM_DEF(ENUM_CASE) \ default: return ""; \ } \ } \ EnumType Get { \ ENUM_DEF(ENUM_STRCMP) \ return (EnumType)0; \ } \
XX(FirstValue,) \ XX(SecondValue,) \ XX(SomeOtherValue,=50) \ XX(OneMoreValue,=100) \ DECLARE_ENUM(SomeEnum,SOME_ENUM)
ENUM_BEGIN( Numbers ) ENUM(ONE), ENUM(TWO), ENUM(FOUR) ENUM_END( Numbers ) char num_str[10]; int process_numbers_str(Numbers num) { switch(num) { case ONE: case TWO: case THREE: { strcpy(num_str, Numbers_name_table[num]); } break; default: return 0; return 1; }
X(ONE, "one") \ X(TWO, "two") \ X(THREE, "three") ... typedef enum { X_NUMBERS } Numbers; ... switch(num) { case Enum: strcpy(num_str, String); break; X_NUMBERS default: return 0; break; } return 1;
typedef enum { kZero, kOne, kTwo, kThree } kConst; static char *kConstStr[] = { MACROSTR(kZero), MACROSTR(kOne), MACROSTR(kTwo), MACROSTR(kThree) }; static void kConstPrinter(kConst k) { printf("%s", kConstStr[k]); }
const char *myenum_str(myenum e) { switch(e) { case ONE: return "one"; case TWO: return "two"; } return "invalid"; }
typedef enum { ONE, TWO, THREE } Numbers; char *strNumbers[] = {"one","two","three"}; printf ("Value for TWO is %s\n",strNumbers[TWO]);
typedef enum { ONE, FOUR_THOUSAND = 4000 } Numbers;
td::cout << "Number of Elements: " << TestDataCount << std::endl;
std::cout << "Value of " << TestData2String(x) << " is " << x << std::endl; std::cout << "Value of " << TestData2String(y) << " is " << y << std::endl; std::cout << "Value of " << TestData2String(z) << " is " << z << std::endl;
std::cout << "Value of x is " << TestData2Enum("x") << std::endl; std::cout << "Value of y is " << TestData2Enum("y") << std::endl; std::cout << "Value of z is " << TestData2Enum("z") << std::endl;
enum eName { BOOST_PP_SEQ_FOR_EACH(MACRO1, , SEQ) \ last_ const int eName static std::string eName { \ switch (eel) \ { \ BOOST_PP_SEQ_FOR_EACH(MACRO1_STRING, , SEQ) \ default: return "Unknown enumerator value."; \ }; \ }; \ static enum eName eName { \ BOOST_PP_SEQ_FOR_EACH(MACRO1_ENUM, , SEQ) \ return (enum eName)0; \ };
enum eName { \ BOOST_PP_SEQ_FOR_EACH(MACRO2, _, SEQ) \ last_ const int eName static std::string eName { \ switch (eel) \ { \ BOOST_PP_SEQ_FOR_EACH(MACRO2_STRING, _, SEQ) \ default: return "Unknown enumerator value."; \ }; \ };
X(kZero ) \ X(kOne ) \ X(kTwo ) \ X(kThree ) \ X(kFour ) \ X(kMax ) enum { X_NUMBERS } kConst; static char *kConstStr[] = { X_NUMBERS }; int main(void) { int k; printf("Hello World!\n\n"); for (k = 0; k < kMax; k++) { printf("%s\n", kConstStr[k]); } return 0; }
/* @( @( @( @( */ /* * Common case when someone just includes this file. In this case, * they just get the various E* tokens as good old enums. */ enum { ETYPE(PERM, "Operation not permitted") ETYPE(NOENT, "No such file or directory") ETYPE(SRCH, "No such process") ETYPE(INTR, "Interrupted system call") ETYPE(IO, "I/O error") ETYPE(NXIO, "No such device or address") ETYPE(2BIG, "Arg list too long") /* * Close up the enum block in the common case of someone including * this file. */ ETYPE_MAX };
/* @( @( @( @( */ static const char *sys_errlist_internal[] = { 0 }; static const char *xerror(int err) { if (err >= ETYPE_MAX || err <= 0) return "Unknown error"; return sys_errlist_internal[err]; } static const char*errlist_mnemonics[] = { }; int main(void) { int i; for (i = 0; i < ETYPE_MAX; i++) { printf("%d: %-6s: %s\n", i, errlist_mnemonics[i], xerror(i)); } return(0); }
enum MyEnum { ENUMVAL1 }; ...stuff... stringify(EnumName::ENUMVAL1);
template <typename E> class streamable_enum { public: typedef typename std::map<E, std::string> tostr_map_t; typedef typename std::map<std::string, E> fromstr_map_t; streamable_enum() {} streamable_enum(E val) : Val_(val) {} operator E() { return Val_; } bool operator==(const streamable_enum<E>& e) { return this->Val_ == e.Val_; } bool operator==(const E& e) { return this->Val_ == e; } static const tostr_map_t& to_string_map() { static tostr_map_t to_str_(get_enum_strings<E>()); return to_str_; } static const fromstr_map_t& from_string_map() { static fromstr_map_t from_str_(reverse_map(to_string_map())); return from_str_; } private: E Val_; static fromstr_map_t reverse_map(const tostr_map_t& eToS) { fromstr_map_t sToE; for (auto pr : eToS) { sToE.emplace(pr.second, pr.first); } return sToE; } }; template <typename E> streamable_enum<E> stream_enum(E e) { return streamable_enum<E>(e); } template <typename E> typename streamable_enum<E>::tostr_map_t get_enum_strings() { return {}; } template <typename E> std::ostream& operator<<(std::ostream& os, streamable_enum<E> e) { auto& mp = streamable_enum<E>::to_string_map(); auto res = mp.find(e); if (res != mp.end()) { os << res->second; } else { os.setstate(std::ios_base::failbit); } return os; } template <typename E> std::istream& operator>>(std::istream& is, streamable_enum<E>& e) { std::string str; is >> str; if (str.empty()) { is.setstate(std::ios_base::failbit); } auto& mp = streamable_enum<E>::from_string_map(); auto res = mp.find(str); if (res != mp.end()) { e = res->second; } else { is.setstate(std::ios_base::failbit); } return is; }
using std::cout; using std::cin; using std::endl; enum Animal { CAT, DOG, TIGER, RABBIT }; template <> streamable_enum<Animal>::tostr_map_t get_enum_strings<Animal>() { return { { CAT, "Cat"}, { DOG, "Dog" }, { TIGER, "Tiger" }, { RABBIT, "Rabbit" } }; } int main(int argc, char* argv []) { cout << "What animal do you want to buy? Our offering:" << endl; for (auto pr : streamable_enum<Animal>::to_string_map()) { cout << " " << pr.second << endl; } streamable_enum<Animal> anim; cin >> anim; if (!cin) { cout << "We don } else if (anim == Animal::TIGER) { cout << stream_enum(Animal::TIGER) << " was a joke..." << endl; } else { cout << "Here you are!" << endl; } return 0; }
SMART_ENUM(State, enum State { RUNNING, SLEEPING, FAULT, UNKNOWN })
std::stringstream ss; ss << State::FAULT; std::string myEnumStr = ss.str(); std::cout << State::FAULT << std::endl; std::string myStr = State::to_string(State::FAULT); State::State myEnumVal = State::from_string(State::FAULT);
namespace enumTypeArg { \ __VA_ARGS__; \ std::ostream& operator<<(std::ostream& os, const enumTypeArg& val) { \ os << swissarmyknife::enums::to_string( return os; \ } \ \ std::string to_string(const enumTypeArg& val) { \ return swissarmyknife::enums::to_string( } \ \ enumTypeArg from_string(const std::string &str) { \ return swissarmyknife::enums::from_string<enumTypeArg>( } \ } \ namespace swissarmyknife { namespace enums { static inline std::string to_string(const std::string completeEnumDeclaration, size_t enumVal) throw (std::runtime_error) { size_t begin = completeEnumDeclaration.find_first_of( size_t end = completeEnumDeclaration.find_last_of( const std::string identifiers = completeEnumDeclaration.substr(begin + 1, end ); size_t count = 0; size_t found = 0; do { found = identifiers.find_first_of(",}", found+1); if (enumVal == count) { std::string identifiersSubset = identifiers.substr(0, found); size_t beginId = identifiersSubset.find_last_of("{,"); identifiersSubset = identifiersSubset.substr(beginId+1); boost::algorithm::trim(identifiersSubset); return identifiersSubset; } ++count; } while (found != std::string::npos); throw std::runtime_error("The enum declaration provided doesn } template <typename EnumType> static inline EnumType from_string(const std::string completeEnumDeclaration, const std::string &enumStr) throw (std::runtime_error) { size_t begin = completeEnumDeclaration.find_first_of( size_t end = completeEnumDeclaration.find_last_of( const std::string identifiers = completeEnumDeclaration.substr(begin + 1, end ); size_t count = 0; size_t found = 0; do { found = identifiers.find_first_of(",}", found+1); std::string identifiersSubset = identifiers.substr(0, found); size_t beginId = identifiersSubset.find_last_of("{,"); identifiersSubset = identifiersSubset.substr(beginId+1); boost::algorithm::trim(identifiersSubset); if (identifiersSubset == enumStr) { return static_cast<EnumType>(count); } ++count; } while (found != std::string::npos); throw std::runtime_error("No valid enum value for the provided string"); } }}
int main(void) { double x = 0.5; double result = sqrt(x); printf("The square root of %lf is %lf\n", x, result); return 0; }
/tmp/cc58XvyX.o: In function `main test.c:(.text+0x2f): undefined reference to `sqrt' collect2: ld returned 1 exit status
struct s1 { char a; int b; char c; char d; char e; }
struct s2 { int b; char a; char c; char d; char e; }
struct __attribute__((__packed__)) LocalFileHeader { uint32_t signature; uint16_t minVersion, flag, method, modTime, modDate; uint32_t crc32, compressedSize, uncompressedSize; uint16_t nameLength, extraLength; };
struct S { char a; int b; char c; }; struct S_head { char a; }; struct S_ext { char a; int b; char c; int d; char e; }; struct S s; struct S_head *head = (struct S_head*)&s; fn1(head); struct S_ext ext; struct S *sp = (struct S*)&ext; fn2(sp);
struct S { char a; int b; char c, d, e; }; struct T { char a; struct S s; char b; };
struct BC { int b; char c; }; struct S { char a; struct BC bc; char d, e; };
/* * Structure of an internet header, naked of options. */ struct ip { unsigned int ip_hl:4, ip_v:4; unsigned int ip_v:4, ip_hl:4; u_int8_t ip_tos; u_int16_t ip_len; u_int16_t ip_id; u_int16_t ip_off; u_int8_t ip_ttl; u_int8_t ip_p; u_int16_t ip_sum; struct in_addr ip_src, ip_dst; } __packed;
struct { uint32_t data_size; uint8_t data[1]; } _vv_a;
struct s1 { char a; int b; char c; char d; char e; }
static jmp_buf s_jumpBuffer; void Example() { if (setjmp(s_jumpBuffer)) { printf("Exception happened here\n"); } else { Test(); } } void Test() { longjmp(s_jumpBuffer, 42); }
int main(void) { try { printf("One\n"); throw(); printf("Two\n"); } catch(...) { printf("Error\n"); } return 0; }
int main(void) { bool HadError=false; { printf("One\n"); HadError=true; goto ExitJmp; printf("Two\n"); } ExitJmp: if(HadError) { printf("Error\n"); } return 0; }
jmp_buf *g_ActiveBuf; int main(void) { jmp_buf LocalJmpBuff; jmp_buf *OldActiveBuf=g_ActiveBuf; bool WasThrown=false; g_ActiveBuf=&LocalJmpBuff; if(setjmp(LocalJmpBuff)) { WasThrown=true; } else { printf("One\n"); longjmp(*g_ActiveBuf,1); printf("Two\n"); } g_ActiveBuf=OldActiveBuf; if(WasThrown) { printf("Error\n"); } return 0; }
static jmp_buf s_jumpBuffer; void Example() { if (setjmp(s_jumpBuffer)) { printf("Exception happened\n"); } else { Test(); } } void Test() { longjump(s_jumpBuffer, 42); }
struct exception_state { jmp_buf s_jumpBuffer[MAX_EXCEPTION_DEPTH]; int current_depth; }; int try_point(struct exception_state * state) { if(current_depth==MAX_EXCEPTION_DEPTH) { abort(); } int ok = setjmp(state->jumpBuffer[state->current_depth]); if(ok) { state->current_depth++; } else { state->current_depth--; } return ok; } void throw_exception(struct exception_state * state) { longjump(state->current_depth-1,1); } void catch_point(struct exception_state * state) { state->current_depth--; } void end_try_point(struct exception_state * state) { state->current_depth--; } __thread struct exception_state g_exception_state; void Example() { if (try_point(&g_exception_state)) { catch_point(&g_exception_state); printf("Exception happened\n"); } else { Test(); end_try_point(&g_exception_state); } } void Test() { throw_exception(g_exception_state); }
typedef struct { unsigned int id; char *name; char *msg; } error; error* new_ error* self = malloc(sizeof(error)); \ self->id = _id; \ self->name = self->msg = msg; \ return self; \ } \ error* new_ error * err_name = NULL; \ error ** __err = & err_name; \ void __try_fn() try_block \ __try_fn(); \ void __catch_fn() { \ if (err_name == NULL) return; \ unsigned int __ if (__ printuncaughterr(); \ else if (__ catch_block \ } \ __catch_fn(); \ } _errordef(any, 0)
errordef(my_err1) errordef(my_err2) try ({ printf("Helloo\n"); throw(new_my_err1_error_msg("hiiiii!")); printf("This will not be printed!\n"); }, any, e, { printf("My lovely error: %s %s\n", e->name, e->msg); }) printf("\n"); try ({ printf("Helloo\n"); throw(new_my_err2_error_msg("my msg!")); printf("This will not be printed!\n"); }, my_err2, e, { printerr("%s", e->msg); }) printf("\n"); try ({ printf("Helloo\n"); throw(new_my_err1_error()); printf("This will not be printed!\n"); }, my_err2, e, { printf("Catch %s if you can!\n", e->name); })
Helloo My lovely error: my_err1 hiiiii! Helloo /home/naheel/Desktop/aa.c:28: error: ‘my_err2_error’ my msg! Helloo /home/naheel/Desktop/aa.c:38: uncaught error: ‘my_err1_error’
GameEngine *CreateGameEngine(GameEngineParams const *params) { /* Declare an error handler variable. This will hold the address to jump to if an error occurs to cleanup pending resources. Initialize it to the err label which simply returns an error value (NULL in this example). The && operator resolves to the address of the label err */ void *eh = &&err; GameEngine *engine = malloc(sizeof *engine); if (!engine) goto *eh; eh = &&undo_malloc; engine->window = OpenWindow(...); if (!engine->window) goto *eh; /* The neat trick about using approach is that you don need to remember what "undo" label to go to in code. Simply go to *eh. */ eh = &&undo_window_open; return device; undo_window_open: CloseWindow(engine->window); undo_malloc: free(engine); err: return NULL; }
GameEngine *CreateGameEngine(GameEngineParams const *params) { declthrows; GameEngine *engine = malloc(sizeof *engine); checkpoint(malloc, engine); engine->window = OpenWindow(...); checkpoint(window_open, engine->window); return device; undo_window_open: CloseWindow(engine->window); undo_malloc: free(engine); err: return NULL; }
int rdbSave(char *filename) { char tmpfile[256]; FILE *fp; rio rdb; int error = 0; snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid()); fp = fopen(tmpfile,"w"); if (!fp) { redisLog(REDIS_WARNING, "Failed opening .rdb for saving: %s", strerror(errno)); return REDIS_ERR; } rioInitWithFile(&rdb,fp); if (rdbSaveRio(&rdb,&error) == REDIS_ERR) { errno = error; goto werr; } if (fflush(fp) == EOF) goto werr; if (fsync(fileno(fp)) == -1) goto werr; if (fclose(fp) == EOF) goto werr; /* Use RENAME to make sure the DB file is changed atomically only * if the generate DB file is ok. */ if (rename(tmpfile,filename) == -1) { redisLog(REDIS_WARNING,"Error moving temp DB file on the final destination: %s", strerror(errno)); unlink(tmpfile); return REDIS_ERR; } redisLog(REDIS_NOTICE,"DB saved on disk"); server.dirty = 0; server.lastsave = time(NULL); server.lastbgsave_status = REDIS_OK; return REDIS_OK; werr: fclose(fp); unlink(tmpfile); redisLog(REDIS_WARNING,"Write error saving DB on disk: %s", strerror(errno)); return REDIS_ERR; }
typedef int errcode; errcode init_or_fail( foo *f, goo *g, poo *p, loo *l ) { errcode ret = 0; if ( ( ret = foo_init( f ) ) ) goto FAIL; if ( ( ret = goo_init( g ) ) ) goto FAIL_F; if ( ( ret = poo_init( p ) ) ) goto FAIL_G; if ( ( ret = loo_init( l ) ) ) goto FAIL_P; assert( 0 == ret ); goto END; /* Note that we finalize in opposite order of initialization because we are unwinding a *STACK* of initialized objects */ FAIL_P: poo_fini( p ); FAIL_G: goo_fini( g ); FAIL_F: foo_fini( f ); FAIL: assert( 0 != ret ); END: return ret; }
typedef int errcode; errcode init_or_fail( foo *f, goo *g, poo *p, loo *l ) { errcode ret = 0; TRY( ret = foo_init( f ), FAIL ); TRY( ret = goo_init( g ), FAIL_F ); TRY( ret = poo_init( p ), FAIL_G ); TRY( ret = loo_init( l ), FAIL_P ); assert( 0 == ret ); goto END; FAIL_P: poo_fini( p ); FAIL_G: goo_fini( g ); FAIL_F: foo_fini( f ); FAIL: assert( 0 != ret ); END: return ret; }
curl_code = curl_easy_perform (session); long http_code = 0; curl_easy_getinfo (session, CURLINFO_RESPONSE_CODE, &http_code); if (http_code == 200 && curl_code != CURLE_ABORTED_BY_CALLBACK) { } else { }
int foo(int bar) { int return_value = 0; if (!do_something( bar )) { goto error_1; } if (!init_stuff( bar )) { goto error_2; } if (!prepare_stuff( bar )) { goto error_3; } return_value = do_the_thing( bar ); error_3: cleanup_3(); error_2: cleanup_2(); error_1: cleanup_1(); return return_value; }
int foo(int bar) { int return_value = 0; if (!do_something(bar)) { goto error_1; } if (!init_stuff(bar)) { goto error_2; } if (prepare_stuff(bar)) { return_value = do_the_thing(bar); cleanup_3(); } error_2: cleanup_2(); error_1: cleanup_1(); return return_value; }
int foo(int bar) { int return_value = 0; if (do_something(bar)) { if (init_stuff(bar)) { if (prepare_stuff(bar)) { return_value = do_the_thing(bar); cleanup_3(); } cleanup_2(); } cleanup_1(); } return return_value; }
int foo(int bar) { int return_value = 0; int something_done = 0; int stuff_inited = 0; int stuff_prepared = 0; /* * Prepare */ if (do_something(bar)) { something_done = 1; } else { goto cleanup; } if (init_stuff(bar)) { stuff_inited = 1; } else { goto cleanup; } if (prepare_stuff(bar)) { stufF_prepared = 1; } else { goto cleanup; } /* * Do the thing */ return_value = do_the_thing(bar); /* * Clean up */ cleanup: if (stuff_prepared) { unprepare_stuff(); } if (stuff_inited) { uninit_stuff(); } if (something_done) { undo_something(); } return return_value; }
int fd = -1; .... fd = open(...); if (fd == -1) { goto cleanup; } ... cleanup: if (fd != -1) { close(fd); }
int foo(int bar) { int return_value = 0; int something_done = 0; int stuff_inited = 0; int stuff_prepared = 0; int oksofar = 1; /* * Prepare */ if (oksofar) { /* NB This "if" statement is optional (it always executes) but included for consistency */ if (do_something(bar)) { something_done = 1; } else { oksofar = 0; } } if (oksofar) { if (init_stuff(bar)) { stuff_inited = 1; } else { oksofar = 0; } } if (oksofar) { if (prepare_stuff(bar)) { stuff_prepared = 1; } else { oksofar = 0; } } /* * Do the thing */ if (oksofar) { return_value = do_the_thing(bar); } /* * Clean up */ if (stuff_prepared) { unprepare_stuff(); } if (stuff_inited) { uninit_stuff(); } if (something_done) { undo_something(); } return return_value; }
int return_value = 0; if (!return_value) { return_value = do_something(bar); } if (!return_value) { return_value = init_stuff(bar); } if (!return_value) { return_value = prepare_stuff(bar); }
int foo(int bar) { int return_value = 0 ; int failure_value = 0 ; if (!do_something(bar)) { failure_value = 1; } else if (!init_stuff(bar)) { failure_value = 2; } else if (prepare_stuff(bar)) { return_value = do_the_thing(bar); cleanup_3(); } switch (failure_value) { case 2: cleanup_2(); case 1: cleanup_1(); default: break ; } }
int decode ( char * path_in , char * path_out ) { FILE * in , * out ; code c ; int len ; int res = 0 ; if ( path_in == NULL ) in = stdin ; else { if ( ( in = fopen ( path_in , "r" ) ) == NULL ) goto error_open_file_in ; } if ( path_out == NULL ) out = stdout ; else { if ( ( out = fopen ( path_out , "w" ) ) == NULL ) goto error_open_file_out ; } if( read_code ( in , & c , & longueur ) ) goto error_code_construction ; if ( decode_h ( in , c , out , longueur ) ) goto error_decode ; if ( 0 ) { error_decode: res = 1 ;} free_code ( c ) ; if ( 0 ) { error_code_construction: res = 1 ; } if ( out != stdout ) fclose ( stdout ) ; if ( 0 ) { error_open_file_out: res = 1 ; } if ( in != stdin ) fclose ( in ) ; if ( 0 ) { error_open_file_in: res = 1 ; } return res ; }
bool do_something(void **ptr1, void **ptr2) { if (!ptr1 || !ptr2) { err("Missing arguments"); return false; } bool ret = false; void *some_pointer = NULL, *another_pointer = NULL; if (allocate_some_stuff(&some_pointer) != STUFF_OK) { err("allocate_some_stuff step1 failed, abort"); goto out; } if (allocate_some_stuff(&another_pointer) != STUFF_OK) { err("allocate_some_stuff step 2 failed, abort"); goto out; } void *some_temporary_malloc = malloc(1000); info("do_something OK"); ret = true; *ptr1 = some_pointer; *ptr2 = another_pointer; out: if (!ret) { deallocate_some_stuff(some_pointer); deallocate_some_stuff(another_pointer); } free(some_temporary_malloc); return ret; }
struct lnode *insert(char *data, int len, struct lnode *list) { struct lnode *p, *q; uint8_t good; struct { uint8_t alloc_node : 1; uint8_t alloc_str : 1; } cleanup = { 0, 0 }; p = (struct lnode *)malloc(sizeof(struct lnode)); good = cleanup.alloc_node = (p != NULL); if (good) { p->str = (char *)malloc(sizeof(char)*len); good = cleanup.alloc_str = (p->str != NULL); } if(good) { memcpy ( p->str, data, len ); } if(good) { if(NULL == list) { p->next = NULL; list = p; } else { q = list; while(q->next != NULL && good) { good = (strcmp(q->str,p->str) != 0); q = q->next; } if (good) { p->next = q->next; q->next = p; } } } if(!good) { if(cleanup.alloc_str) free(p->str); if(cleanup.alloc_node) free(p); } return (good? list: NULL);
for(int i=0; i<size; i+=16) { y1 = _mm_load_ps(output[i]); … y4 = _mm_load_ps(output[i+12]); for(k=0; k<ksize; k++){ for(l=0; l<ksize; l++){ w = _mm_set_ps1(weight[i+k+l]); x1 = _mm_load_ps(input[i+k+l]); y1 = _mm_add_ps(y1,_mm_mul_ps(w,x1)); … x4 = _mm_load_ps(input[i+k+l+12]); y4 = _mm_add_ps(y4,_mm_mul_ps(w,x4)); } } _mm_store_ps(&output[i],y1); … _mm_store_ps(&output[i+12],y4); }
… Block x: movapsx (%rax,%rcx,4), %xmm0 movapsx 0x10(%rax,%rcx,4), %xmm1 movapsx 0x20(%rax,%rcx,4), %xmm2 movapsx 0x30(%rax,%rcx,4), %xmm3 movssl (%rdx,%rcx,4), %xmm4 inc %rcx shufps $0x0, %xmm4, %xmm4 {fill weight vector} cmp $0x32, %rcx mulps %xmm4, %xmm0 mulps %xmm4, %xmm1 mulps %xmm4, %xmm2 mulps %xmm3, %xmm4 addps %xmm0, %xmm5 addps %xmm1, %xmm6 addps %xmm2, %xmm7 addps %xmm4, %xmm8 jl 0x401ad6 <Block x> …
int main () { int a = 5,b = 2; printf("%d",a+++++b); return 0; }
int main () { int a = 5,b = 2; printf("%d",a++ + ++b); return 0; }
[ SYMBOL_NAME(name = "a"), SYMBOL_PLUS_PLUS, SYMBOL_PLUS_PLUS, SYMBOL_PLUS, SYMBOL_NAME(name = "b") ]
struct bad_code { bad_code &operator++(int) { return *this; } int operator+(bad_code const &other) { return 1; } }; int main() { bad_code a, b; int c = a+++++b; return 0; }
c = (a++)++ + b c = (a) + ++(++b) c = (a++) + (++b)
for(j = 0; j < n; j++) { for(i = 0; i < m; i++) { array[i][j] = 0; } }
void f(int (*arr)[5]) { printf("f: sizeof arr: %zu\n", sizeof arr); printf("f: sizeof arr[0]: %zu\n", sizeof arr[0]); printf("f: sizeof arr[0][0]: %zu\n", sizeof arr[0][0]); } int main(void) { int arr[10][5]; printf("main: sizeof arr: %zu\n", sizeof arr); printf("main: sizeof arr[0]: %zu\n", sizeof arr[0]); printf("main: sizeof arr[0][0]: %zu\n\n", sizeof arr[0][0]); f(arr); return 0; }
main: sizeof arr: 200 main: sizeof arr[0]: 20 main: sizeof arr[0][0]: 4 f: sizeof arr: 8 f: sizeof arr[0]: 20 f: sizeof arr[0][0]: 4
int array [][]; bool array_is_empty; void ClearArray () { array_is_empty = true; } int ReadValue (int x, int y) { return array_is_empty ? 0 : array [x][y]; } void SetValue (int x, int y, int value) { if (array_is_empty) { memset (array, 0, number of byte the array uses); array_is_empty = false; } array [x][y] = value; }
clear array for each set of data for each element in data set array += element
for set 0 and set 1 for each element in each set array = element1 + element2 for remaining data sets for each element in data set array += element
__m128i _mm_setzero_si128 (); void _mm_storeu_si128 (__m128i *p, __m128i a);
const int mr = roundUpToNearestMultiple(m, 4); const int nr = roundUpToNearestMultiple(n, 4); int i = 0; int array[mr][nr] __attribute__ ((aligned (16))); __m128i* px = (__m128i*)array; const int incr = s >> 2; const __m128i zero128 = _mm_setzero_si128(); for(i = 0; i < s; i += incr) { _mm_storeu_si128(px++, zero128); _mm_storeu_si128(px++, zero128); _mm_storeu_si128(px++, zero128); _mm_storeu_si128(px++, zero128); }
int *ptr, *ptr1; ptr = &array[0][0]; ptr1 = ptr + SIZE_X*SIZE_Y*sizeof(array[0][0]);
size_t arrayByteSize = sizeof(int) * i * j; int *array = malloc(array2dByteSite); bzero(array, arrayByteSize);
void A() { int a; printf("%i",a); } void B() { int a; a = 5; } int main() { B(); A(); return 0; }
0804840c <A>: 804840c: 55 push ebp 804840d: 89 e5 mov ebp,esp 804840f: 83 ec 28 sub esp,0x28 8048412: 8b 45 f4 mov eax,DWORD PTR [ebp-0xc] 8048415: 89 44 24 04 mov DWORD PTR [esp+0x4],eax 8048419: c7 04 24 e8 84 04 08 mov DWORD PTR [esp],0x80484e8 8048420: e8 cb fe ff ff call 80482f0 <printf@plt> 8048425: c9 leave 8048426: c3 ret 08048427 <B>: 8048427: 55 push ebp 8048428: 89 e5 mov ebp,esp 804842a: 83 ec 10 sub esp,0x10 804842d: c7 45 fc 05 00 00 00 mov DWORD PTR [ebp-0x4],0x5 8048434: c9 leave 8048435: c3 ret 08048436 <main>: 8048436: 55 push ebp 8048437: 89 e5 mov ebp,esp 8048439: 83 e4 f0 and esp,0xfffffff0 804843c: e8 e6 ff ff ff call 8048427 <B> 8048441: e8 c6 ff ff ff call 804840c <A> 8048446: b8 00 00 00 00 mov eax,0x0 804844b: c9 leave 804844c: c3 ret 804844d: 66 90 xchg ax,ax 804844f: 90 nop
In function 11:9: warning: variable In function 6:11: warning:
— if it has pointer type, it is initialized to a null pointer; — if it has arithmetic type, it is initialized to (positive or unsigned) zero; — if it is an aggregate, every member is initialized (recursively) according to these rules; — if it is a union, the first named member is initialized (recursively) according to these rules.
static uint8_t togglecode[256] = { [0x3A] CAPSLOCK, [0x45] NUMLOCK, [0x46] SCROLLLOCK };
togglecode[0x3A] == CAPSLOCK togglecode[0x45] == NUMLOCK togglecode[0x46] == SCROLLLOCK
.file "strange.c" .text .globl foo .type foo, @function foo: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl %edi, -4(%rbp) nop popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: (GNU) 5.3.0" .section .note.GNU-stack,"",@progbits
int main() { printf("sizeof(2i) = %zd\n", sizeof(2i)); printf("sizeof(2ui) = %zd\n", sizeof(2ui)); printf("sizeof(2li) = %zd\n", sizeof(2li)); printf("sizeof(2lli) = %zd\n", sizeof(2lli)); printf("sizeof(2.i) = %zd\n", sizeof(2.i)); printf("sizeof(2.fi) = %zd\n", sizeof(2.fi)); printf("sizeof(2e0fi) = %zd\n", sizeof(2e0fi)); printf("sizeof(2e0i) = %zd\n", sizeof(2e0i)); printf("sizeof(2il) = %zd\n", sizeof(2il)); printf("sizeof(2ill) = %zd\n", sizeof(2ill)); printf("sizeof(2.if) = %zd\n", sizeof(2.if)); return 0; }
sizeof(2i) = 8 sizeof(2ui) = 8 sizeof(2li) = 16 sizeof(2lli) = 16 sizeof(2.i) = 16 sizeof(2.fi) = 8 sizeof(2e0fi) = 8 sizeof(2e0i) = 16 sizeof(2il) = 16 sizeof(2ill) = 16 sizeof(2.if) = 8
function fibcps(n, c) { if (n <= 1) { c(n); } else { fibcps(n - 1, function (x) { fibcps(n - 2, function (y) { c(x + y) }) }); } }
function fibt(n, c) { function trampoline(x) { while (x && x.func) { x = x.func.apply(null, x.args); } } function fibtramp(n, c) { if (n <= 1) { return {func: c, args: [n]}; } else { return { func: fibtramp, args: [n - 1, function (x) { return { func: fibtramp, args: [n - 2, function (y) { return {func: c, args: [x + y]} }] } } ] } } } trampoline({func: fibtramp, args: [n, c]}); }
typedef struct _trampoline_data { void(*callback)(struct _trampoline_data*); void* parameters; } trampoline_data; void trampoline(trampoline_data* data) { while(data->callback != NULL) data->callback(data); } typedef struct _factorialParameters { int n; int product; } factorialParameters; void factorial(trampoline_data* data) { factorialParameters* parameters = (factorialParameters*) data->parameters; if (parameters->n <= 1) { data->callback = NULL; } else { parameters->product *= parameters->n; parameters->n--; } } int main() { factorialParameters params = {5, 1}; trampoline_data t = {&factorial, &params}; trampoline(&t); printf("\n%d\n", params.product); return 0; }
/* sort an array, starting at address `base`, * containing `nmemb` members, separated by `size`, * comparing on the first `nbytes` only. */ void sort_bytes(void *base, size_t nmemb, size_t size, size_t nbytes) { int compar(const void *a, const void *b) { return memcmp(a, b, nbytes); } qsort(base, nmemb, size, compar); }
typedef void *(*CONTINUATION)(int); void trampoline(CONTINUATION cont) { int counter = 0; CONTINUATION currentCont = cont; while (currentCont != NULL) { currentCont = (CONTINUATION) currentCont(counter); counter++; } printf("got off the trampoline - happy happy joy joy !\n"); } void *thunk3(int param) { printf("*boing* last thunk\n"); return NULL; } void *thunk2(int param) { printf("*boing* thunk 2\n"); return thunk3; } void *thunk1(int param) { printf("*boing* thunk 1\n"); return thunk2; } int main(int argc, char **argv) { trampoline(thunk1); }
meincompi $ ./trampoline *boing* thunk 1 *boing* thunk 2 *boing* last thunk got off the trampoline - happy happy joy joy !
size_t (*trampoline_example)(const char *, const char *); trampoline_example= strcspn; size_t result_1= trampoline_example("xyzbxz", "abc"); trampoline_example= strspn; size_t result_2= trampoline_example("xyzbxz", "abc");
typedef void* (*state_type)(void); void* state1(); void* state2(); void* state1() { return state2; } void* state2() { return state1; } state_type state = state1; while (1) { state = state(); }
struct body { double p[3]; double v[3]; double a[3]; double radius; double mass; };
int a, b; for(a = 0; a < n; a++) { for(b = 0; b < 3; b++) { bodies[a].p[b] = 0; bodies[a].v[b] = 0; bodies[a].a[b] = 0; } bodies[a].mass = 0; bodies[a].radius = 1.0; }
struct body { double p[3]; double v[3]; double a[3]; double radius; double mass; }; struct body bodies[n]; int main() { int a, b; for(a = 0; a < n; a++) { for(b = 0; b < 3; b++) { bodies[a].p[b] = 0; bodies[a].v[b] = 0; bodies[a].a[b] = 0; } bodies[a].mass = 0; bodies[a].radius = 1.0; } return 0; }
struct { double p[3]; double v[3]; double a[3]; double radius; double mass; }bodies[n];
struct body { double p[3]; double v[3]; double a[3]; double radius; double mass; };
int main(int argc, char** argv) { typedef struct{ char* firstName; char* lastName; int day; int month; int year; }STUDENT; int numStudents=3; int x; STUDENT* students = malloc(numStudents * sizeof *students); for (x = 0; x < numStudents; x++){ students[x].firstName=(char*)malloc(sizeof(char*)); scanf("%s",students[x].firstName); students[x].lastName=(char*)malloc(sizeof(char*)); scanf("%s",students[x].lastName); scanf("%d",&students[x].day); scanf("%d",&students[x].month); scanf("%d",&students[x].year); } for (x = 0; x < numStudents; x++) printf("first name: %s, surname: %s, day: %d, month: %d, year: %d\n",students[x].firstName,students[x].lastName,students[x].day,students[x].month,students[x].year); return (EXIT_SUCCESS); }
struct body { double p[3]; double v[3]; double a[3]; double radius; double *mass; }; int main() { struct body *bodies = (struct body*)malloc(n*sizeof(struct body)); int a, b; for(a = 0; a < n; a++) { for(b = 0; b < 3; b++) { bodies[a].p[b] = 0; bodies[a].v[b] = 0; bodies[a].a[b] = 0; } bodies[a].mass = 0; bodies[a].radius = 1.0; } return 0; }
typedef struct { double p[3]; double v[3]; double a[3]; double radius; double mass; }Body;
Body bodies[n] = {{{0,0,0}, {0,0,0}, {0,0,0}, 0, 1.0}, {{0,0,0}, {0,0,0}, {0,0,0}, 0, 1.0}, {{0,0,0}, {0,0,0}, {0,0,0}, 0, 1.0}};
$ cat Makefile all: echo foo | gcc $(USER_DEFINES) -E -xc - $ make USER_DEFINES="-Dfoo=one" echo foo | gcc -Dfoo=one -E -xc - ... one $ make USER_DEFINES="-Dfoo=bar" echo foo | gcc -Dfoo=bar -E -xc - ... bar $ make echo foo | gcc -E -xc - ... foo
main () { int a = MAKE_DEFINE; printf ("MAKE_DEFINE value:%d\n", a); }
... double val = ((double)arc4random() / ARC4RANDOM_MAX);
srand48(time(0)); double x = drand48(); srand48(Int(Date().timeIntervalSince1970)) let x = drand48()
srand48(Int(Date.timeIntervalSinceReferenceDate)) let val = drand48()
let arc4random64 = UInt64(arc4random()) << 32 &+ UInt64(arc4random()) let val = Float80(arc4random64) / Float80(UInt64.max)
var arc4random64: UInt64 = 0 arc4random_buf(&arc4random64, MemoryLayout.size(ofValue: arc4random64)) let val = Float80(arc4random64) / Float80(UInt64.max)
float randomFloat(float Min, float Max){ return ((arc4random()%RAND_MAX)/(RAND_MAX*1.0))*(Max-Min)+Min; }
let x = Float.random(in: 0.0...1.0) let y = Double.random(in: 0.0...1.0) let z = Float80.random(in: 0.0...1.0)
public extension Float { public static var random: Float { return Float(arc4random()) / Float(UInt32.max)) } public static func random(min: Float, max: Float) -> Float { return Float.random * (max - min) + min } }
let intBetween0to9 = Int.random(in: 0...9) let doubleBetween0to1 = Double.random(in: 0...1)
u_int32_t upper_bound = 1000000; float r = arc4random_uniform(upper_bound)*1.0/upper_bound;
char *strdup(char *src) { char * dest; dest = malloc(strlen(src) + 1); if (dest == NULL) abort(); strcpy(dest, src); return dest; }
main() { char *s; s = strdup("hello"); printf("%s\n", s); s = strdup("world"); printf("%s\n", s); }
for (i = 0; i < 1000000000; ++i) s = strdup("hello world");
s = strdup("hello"); free(s); s = strdup("world"); ...
int main() { char* myString = (char*)malloc(5*sizeof(char)); myString = "abcd"; }
typedef struct listelem { struct listelem *next; void *data;} listelem; listelem * create(void * data) { listelem *p = calloc(1, sizeof(listelem)); if(p) p->data = data; return p; } listelem * delete(listelem * p) { listelem next = p->next; free(p); return next; } void deleteall(listelem * p) { while(p) p = delete(p); } void foreach(listelem * p, void (*fun)(void *data) ) { for( ; p != NULL; p = p->next) fun(p->data); } listelem * merge(listelem *p, listelem *q) { while(p != NULL && p->next != NULL) p = p->next; if(p) { p->next = q; return p; } else return q; }
class MyClass { SomeOtherClass *myObject; public MyClass() { myObject = (SomeOtherClass*)malloc(sizeof(myObject)); } public ~MyClass() { free(myObject); } public void SomeMemberFunction() { myObject->SomeOperation(); } };
printn(n, b) { extrn putchar; auto a; if (a = n / b) printn(a, b); putchar(n % b + }
{ auto int x=8; printf("%d",x); { auto int x=3; printf("%d",x); } printf("%d",x); }
900 memset(&new_ckpt_info, (gdb) **903 prev_offset = cp_node->offset;** (gdb) **905 m_CPND_CKPTINFO_READ(ckpt_info,(char *)cb->shm_addr.ckpt_addr+sizeof(CKPT_** HDR),i_offset); (gdb) **903 prev_offset = cp_node->offset;** (gdb) **905 m_CPND_CKPTINFO_READ(ckpt_info,(char *)cb->shm_addr.ckpt_addr+sizeof(CKPT_ HDR),i_offset);** (gdb) **908 bitmap_offset = client_hdl/32;** (gdb) **910 bitmap_value = cpnd_client_bitmap_set(client_hdl%32);** (gdb) **908 bitmap_offset = client_hdl/32;** (gdb) **910 bitmap_value = cpnd_client_bitmap_set(client_hdl%32);** (gdb) **908 bitmap_offset = client_hdl/32;** (gdb) **910 bitmap_value = cpnd_client_bitmap_set(client_hdl%32);** (gdb) 913 found = cpnd_find_exact_ckptinfo(cb , &ckpt_info , bitmap_offset , &offset , &prev_offset); (gdb) 916 if(!found) (gdb) p found $1 = <value optimized out> (gdb) set found=0 Left operand of assignment is not an lvalue.
int a = SomeFunction(); bool result = --a >= 0; if ( result ) { foo(); } else { bar(); } return;
call .SomeFunction ; calls to SomeFunction(), which stores its return value in eax sub eax, 1 ; subtract 1 from eax and store in eax, set S (sign) flag if result is negative jl ELSEBLOCK ; GOTO label "ELSEBLOCK" if S flag is set call .foo ; this is the "if" black, call foo() j FINISH ; GOTO FINISH; skip over the "else" block ELSEBLOCK: ; label this location to the assembler call .bar FINISH: ; both paths end up here ret ; return
QMAKE_CXXFLAGS += -O0 QMAKE_CXXFLAGS -= -O1 QMAKE_CXXFLAGS -= -O2 QMAKE_CXXFLAGS -= -O3
int main (int argc, char **argv) { pid_t pID = fork(); if (pID == 0) { sIdentifier = "Child Process: "; } else if (pID < 0) { cerr << "Failed to fork" << endl; exit(1); } else { sIdentifier = "Parent Process:"; } return 0; }
/* * daemonize.c * This example daemonizes a process, writes a few log messages, * sleeps 20 seconds and terminates afterwards. */ static void skeleton_daemon() { pid_t pid; pid = fork(); if (pid < 0) exit(EXIT_FAILURE); if (pid > 0) exit(EXIT_SUCCESS); if (setsid() < 0) exit(EXIT_FAILURE); signal(SIGCHLD, SIG_IGN); signal(SIGHUP, SIG_IGN); pid = fork(); if (pid < 0) exit(EXIT_FAILURE); if (pid > 0) exit(EXIT_SUCCESS); umask(0); chdir("/"); int x; for (x = sysconf(_SC_OPEN_MAX); x>=0; x--) { close (x); } openlog ("firstdaemon", LOG_PID, LOG_DAEMON); }
int main() { skeleton_daemon(); while (1) { syslog (LOG_NOTICE, "First daemon started."); sleep (20); break; } syslog (LOG_NOTICE, "First daemon terminated."); closelog(); return EXIT_SUCCESS; }
int daemonize(char* name, char* path, char* outfile, char* errfile, char* infile ) { if(!path) { path="/"; } if(!name) { name="medaemon"; } if(!infile) { infile="/dev/null"; } if(!outfile) { outfile="/dev/null"; } if(!errfile) { errfile="/dev/null"; } pid_t child; if( (child=fork())<0 ) { fprintf(stderr,"error: failed fork\n"); exit(EXIT_FAILURE); } if (child>0) { exit(EXIT_SUCCESS); } if( setsid()<0 ) { fprintf(stderr,"error: failed setsid\n"); exit(EXIT_FAILURE); } signal(SIGCHLD,SIG_IGN); signal(SIGHUP,SIG_IGN); if ( (child=fork())<0) { fprintf(stderr,"error: failed fork\n"); exit(EXIT_FAILURE); } if( child>0 ) { exit(EXIT_SUCCESS); } umask(0); chdir(path); int fd; for( fd=sysconf(_SC_OPEN_MAX); fd>0; --fd ) { close(fd); } stdin=fopen(infile,"r"); stdout=fopen(outfile,"w+"); stderr=fopen(errfile,"w+"); openlog(name,LOG_PID,LOG_DAEMON); return(0); }
int main() { int res; int ttl=120; int delay=5; if( (res=daemonize("mydaemon","/tmp",NULL,NULL,NULL)) != 0 ) { fprintf(stderr,"error: daemonize failed\n"); exit(EXIT_FAILURE); } while( ttl>0 ) { syslog(LOG_NOTICE,"daemon ttl %d",ttl); sleep(delay); ttl-=delay; } syslog(LOG_NOTICE,"daemon ttl expired"); closelog(); return(EXIT_SUCCESS); }
{ ".sh": "bash", ".py": "python", ".rb": "ruby", ".coffee" : "coffee", ".php": "php", ".pl" : "perl", ".js" : "node" }
npm install -g pm2 pm2 start yourapp.yourext --name "fred" pm2 start yourapp.yourext -i 0 --name "fred" pm2 list
int nums[] = {5, 2, 1, 4}; printf("%d\n", nums[0]);
int nums[] = {5, 2, 1, 4}; int* ptr = nums; int* ptr = (int[]){5, 2, 1, 4};
unsigned int hash(unsigned int x) { x = ((x >> 16) ^ x) * 0x45d9f3b; x = ((x >> 16) ^ x) * 0x45d9f3b; x = (x >> 16) ^ x; return x; }
unsigned int unhash(unsigned int x) { x = ((x >> 16) ^ x) * 0x119de1f3; x = ((x >> 16) ^ x) * 0x119de1f3; x = (x >> 16) ^ x; return x; }
uint64_t hash(uint64_t x) { x = (x ^ (x >> 30)) * UINT64_C(0xbf58476d1ce4e5b9); x = (x ^ (x >> 27)) * UINT64_C(0x94d049bb133111eb); x = x ^ (x >> 31); return x; }
uint64_t unhash(uint64_t x) { x = (x ^ (x >> 31) ^ (x >> 62)) * UINT64_C(0x319642b2d24d8ec3); x = (x ^ (x >> 27) ^ (x >> 54)) * UINT64_C(0x96de1b173f119089); x = x ^ (x >> 30) ^ (x >> 60); return x; }
unsigned hashtab[1<<H_BITS] .... unsigned slot = hash32(x) >> H_SHIFT
void *my_alloc(size_t size) { void *block = malloc(sizeof(size) + size); *(size_t *)block = size; return (void *) ((size_t *)block + 1); } void my_free(void *block) { block = (size_t *)block - 1; mfree(block, *(size_t *)block); }
void * p = malloc(20); free(p, 25); free(NULL, 10);
printf("True = %d, False = %d\n", (0 == 0), (0 != 0));
static char *foo(unsigned int flags) { static char ret[2] = { 0 }; if (flags & FOO_BAR) ret[0] = else if (flags & BAR_FOO) ret[0] = else ret[0] = ret[1] = return ret; }
int t; void swap(int *x, int *y) { t = *x; *x = *y; *y = t; }
/* We use a thread local variable: the function is now thread-safe but still not reentrant (within the same thread). */ __thread int t; void swap(int *x, int *y) { t = *x; *x = *y; *y = t; }
int t; void swap(int *x, int *y) { int s; s = t; t = *x; *x = *y; *y = t; t = s; }
void swap(int *x, int *y) { int t; t = *x; *x = *y; *y = t; }
struct data { char buf[256]; }; struct data Foo(const char *buf); int main(void) { struct data obj; obj = Foo("This is a sentence."); printf("%s\n", obj.buf); return 0; } struct data Foo(const char *buf) { struct data X; strcpy(X.buf, buf); return X; }
struct foo { ... }; struct foo func( void ) { struct foo someFoo; ... return someFoo; }
int main ( void ) { bool b = true; if ( b ) printf ( "Yes\n" ); else printf ( "No\n" ); return 0; }
int main(int argc, char** argv) { char * p = /*(char*)*/malloc(10); strcpy(p, "hello"); printf("%s\n", p); return 0; }
anon@anon:~/$ gcc -Wextra nostdlib_malloc.c -o nostdlib_malloc nostdlib_malloc.c: In function ‘main’: nostdlib_malloc.c:7: warning: incompatible implicit declaration of built-in function ‘malloc’ anon@anon:~/$ ./nostdlib_malloc hello
static const int NUM_TYPES = 4; static int types[NUM_TYPES] = { 1, 2, 3, 4 };
typedef enum { typeNo1 = 1, typeNo2, typeNo3, typeNo4, NumOfTypes = typeNo4 } TypeOfSomething;
enum { NUM_TYPES = 4 }; static int types[NUM_TYPES] = { 1, 2, 3, 4 };
int main (void) { struct addrinfo hints; memset (&hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_DGRAM; hints.ai_flags = AI_CANONNAME; struct addrinfo *res; getaddrinfo ("example.com", "http", &hints, &res); printf ("Host: %s\n", "example.com"); void *ptr; while (res != NULL) { printf("AI Family for current addrinfo: %i\n", res->ai_family); switch (res->ai_family) { case AF_INET: ptr = (struct sockaddr_in *) res->ai_addr; struct sockaddr_in *sockAddrIn = (struct sockaddr_in *) res->ai_addr; break; } res = res->ai_next; } return 0; }
$ gcc ex4.c ex4.c:30:9: error: expected expression struct sockaddr_in *sockAddrIn = (struct sockaddr_in *) res->ai_addr; ^ 1 error generated.
struct sockaddr_in *sockAddrIn = (struct sockaddr_in *) res->ai_addr;
int main (void) { struct addrinfo hints; memset (&hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_DGRAM; hints.ai_flags = AI_CANONNAME; struct addrinfo *res; getaddrinfo ("example.com", "http", &hints, &res); printf ("Host: %s\n", "example.com"); void *ptr; while (res != NULL) { printf("AI Family for current addrinfo: %i\n", res->ai_family); switch (res->ai_family) { case AF_INET: { ptr = (struct sockaddr_in *) res->ai_addr; struct sockaddr_in *sockAddrIn = (struct sockaddr_in *) res->ai_addr; break; } } res = res->ai_next; } return 0; }
int bcmp(const void *, const void *, size_t); void bcopy(const void *, void *, size_t); void bzero(void *, size_t); int ffs(int); char *index(const char *, int); char *rindex(const char *, int); int strcasecmp(const char *, const char *); int strncasecmp(const char *, const char *, size_t);
for (i = 0; i < 256; i++) { temp = i; for (j = 0; j < 8; j++) { if (temp & 1) { temp >>= 1; temp ^= 0xEDB88320; } else {temp >>= 1;} } testcrc[i] = temp; }
(x^3 + x^2 + x^0)(x^3 + x^1 + x^0) = (x^6 + x^4 + x^3 + x^5 + x^3 + x^2 + x^3 + x^1 + x^0) = x^6 + x^5 + x^4 + 3*x^3 + x^2 + x^1 + x^0
=1x^110 + 1x^101 + 1x^100 + 11x^11 + 1x^10 + 1x^1 + x^0 =1x^110 + 1x^101 + 1x^100 + 1x^100 + 1x^11 + 1x^10 + 1x^1 + x^0 =1x^110 + 1x^101 + 1x^101 + 1x^11 + 1x^10 + 1x^1 + x^0 =1x^110 + 1x^110 + 1x^11 + 1x^10 + 1x^1 + x^0 =1x^111 + 1x^11 + 1x^10 + 1x^1 + x^0
=( 1x^110 + 1x^101 + 1x^100 + 11x^11 + 1x^10 + 1x^1 + x^0 ) MOD 2 =( 1x^110 + 1x^101 + 1x^100 + 1x^11 + 1x^10 + 1x^1 + x^0 ) = x^6 + x^5 + x^4 + 3*x^3 + x^2 + x^1 + x^0 (or that original number we had)
Original message : 1101011011 Polynomial of (W)idth 4 : 10011 Message after appending W zeros : 11010110110000
1100001010 = Quotient (nobody cares about the quotient) _______________ 10011 ) 11010110110000 = Augmented message (1101011011 + 0000) =Poly 10011,,.,,.... -----,,.,,.... 10011,.,,.... 10011,.,,.... -----,.,,.... 00001.,,.... 00000.,,.... -----.,,.... 00010,,.... 00000,,.... -----,,.... 00101,.... 00000,.... -----,.... 01011.... 00000.... -----.... 10110... 10011... -----... 01010.. 00000.. -----.. 10100. 10011. -----. 01110 00000 ----- 1110 = Remainder = THE CHECKSUM!!!!
calculate the CRC-32 hash for the ASCII string inputs: dividend: binary for polynomial: 0b100000100110000010001110110110111 = 0x104C11DB7 011000010110001001100011 reverse bits in each byte: 100001100100011011000110 append 32 0 bits: 10000110010001101100011000000000000000000000000000000000 XOR the first 4 bytes with 0xFFFFFFFF: 01111001101110010011100111111111000000000000000000000000 01111001101110010011100111111111000000000000000000000000 100000100110000010001110110110111 --------------------------------- 111000100010010111111010010010110 100000100110000010001110110110111 --------------------------------- 110000001000101011101001001000010 100000100110000010001110110110111 --------------------------------- 100001011101010011001111111101010 100000100110000010001110110110111 --------------------------------- 111101101000100000100101110100000 100000100110000010001110110110111 --------------------------------- 111010011101000101010110000101110 100000100110000010001110110110111 --------------------------------- 110101110110001110110001100110010 100000100110000010001110110110111 --------------------------------- 101010100000011001111110100001010 100000100110000010001110110110111 --------------------------------- 101000011001101111000001011110100 100000100110000010001110110110111 --------------------------------- 100011111110110100111110100001100 100000100110000010001110110110111 --------------------------------- 110110001101101100000101110110000 100000100110000010001110110110111 --------------------------------- 101101010111011100010110000001110 100000100110000010001110110110111 --------------------------------- 110111000101111001100011011100100 100000100110000010001110110110111 --------------------------------- 10111100011111011101101101010011 remainder: 0b10111100011111011101101101010011 = 0xBC7DDB53 XOR the remainder with 0xFFFFFFFF: 0b01000011100000100010010010101100 = 0x438224AC reverse bits: 0b00110101001001000100000111000010 = 0x352441C2 thus the CRC-32 hash for the ASCII string
int add(int x, int y) { while(x) { int t = (x & y) <<1; y ^= x; x = t; } return y; }
a | b | sum (a^b) | carry bit (a&b) (goes to next) --+---+-----------+-------------------------------- 0 | 0 | 0 | 0 0 | 1 | 1 | 0 1 | 0 | 1 | 0 1 | 1 | 0 | 1
a+b = sum_without_carry(a, b) + carry_bits(a, b) shifted by 1 bit left = a^b + ((a&b) << 1)
Add(a, b) if b == 0 return a; else carry_bits = a & b; sum_bits = a ^ b; return Add(sum_bits, carry_bits << 1);
Add(a, b) while(b != 0) { carry_bits = a & b; sum_bits = a ^ b; a = sum_bits; b = carrry_bits << 1; } return a;
int add(int x, int y) { return (y == 0) ? x : add(x ^ y, (x&y) << 1); }
static int foo(int a, int b) { return a + b; } [...] int a = foo(1, 17); int b = foo(x, x); some_other_function(a, b);
objdump --debugging libvoidincr.a In archive libvoidincr.a: voidincr.o: file format elf64-x86-64
objdump --debugging libinspected.a objdump --debugging libinspected.so
libinspected.a: file format elf64-x86-64 libinspected.so: file format elf64-x86-64
Reading symbols from mylib.so...(no debugging symbols found)...done.
-W --dwarf Displays the contents of the DWARF debug sections in the file, if any are present.
has_debug_info() { readelf -S "$1" | grep -q " \(.debug_info\)\|\(.gnu_debuglink\) " }
int main() { char * p = "abc"; char * p1 = "abc"; printf("%d %d", p, p1); }
int main() { char * p = "abcdef"; char * p1 = "def"; printf("%d %d", p, p1); }
int main (void) { struct ttysize ts; ioctl(0, TIOCGSIZE, &ts); printf ("lines %d\n", ts.ts_lines); printf ("columns %d\n", ts.ts_cols); }
austin@:~$ gcc test.c -o test test.c: In function ‘main’: test.c:6: error: storage size of ‘ts’ isn’t known test.c:7: error: ‘TIOCGSIZE’ undeclared (first use in this function) test.c:7: error: (Each undeclared identifier is reported only once test.c:7: error: for each function it appears in.)
int main (void) { struct winsize w; ioctl(0, TIOCGWINSZ, &w); printf ("lines %d\n", w.ws_row); printf ("columns %d\n", w.ws_col); return 0; }
struct winsize w; ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
int main (int argc, char **argv) { struct winsize w; ioctl(STDOUT_FILENO, TIOCGWINSZ, &w); printf ("lines %d\n", w.ws_row); printf ("columns %d\n", w.ws_col); return 0; }
void handle_winch(int sig){ signal(SIGWINCH, SIG_IGN); endwin(); initscr(); refresh(); clear(); char tmp[128]; sprintf(tmp, "%dx%d", COLS, LINES); int x = COLS / 2 - strlen(tmp) / 2; int y = LINES / 2 - 1; mvaddstr(y, x, tmp); refresh(); signal(SIGWINCH, handle_winch); } int main(int argc, char *argv[]){ initscr(); signal(SIGWINCH, handle_winch); while(getch() != 27){ } endwin(); return(0); }
static char termbuf[2048]; int main(void) { char *termtype = getenv("TERM"); if (tgetent(termbuf, termtype) < 0) { error(EXIT_FAILURE, 0, "Could not access the termcap data base.\n"); } int lines = tgetnum("li"); int columns = tgetnum("co"); printf("lines = %d; columns = %d.\n", lines, columns); return 0; }
int lines = atoi(getenv("LINES")); int columns = atoi(getenv("COLUMNS"));
WARNING: "sys_read" [xxx.ko] undefined! WARNING: "sys_open" [xxx.ko] undefined!
struct file *file_open(const char *path, int flags, int rights) { struct file *filp = NULL; mm_segment_t oldfs; int err = 0; oldfs = get_fs(); set_fs(get_ds()); filp = filp_open(path, flags, rights); set_fs(oldfs); if (IS_ERR(filp)) { err = PTR_ERR(filp); return NULL; } return filp; }
void file_close(struct file *file) { filp_close(file, NULL); }
int file_read(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size) { mm_segment_t oldfs; int ret; oldfs = get_fs(); set_fs(get_ds()); ret = vfs_read(file, data, size, &offset); set_fs(oldfs); return ret; }
int file_write(struct file *file, unsigned long long offset, unsigned char *data, unsigned int size) { mm_segment_t oldfs; int ret; oldfs = get_fs(); set_fs(get_ds()); ret = vfs_write(file, data, size, &offset); set_fs(oldfs); return ret; }
int file_sync(struct file *file) { vfs_fsync(file, 0); return 0; }
ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos); ssize_t kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos);
main( n ) { gets( &n ); printf("%d", n % 85 - 43); }
(B*256*256 + space*256 + A) % 85 = (B + space + A) % 85
(A*256*256*256 + space*256*256 + B*256) % 85 = (B + space + A) % 85
(B + space + A) % 85 = (b + 48 + 32 + a + 48) % 85 = (a + b + 128) % 85 = (a + b + 43) % 85 (B + space + A) % 85 - 43 = (a + b + 43) % 85 - 43 = (a + b) % 85 = a + b
char myFunction() { char array[] = "my string"; return array; }
const char * myFunction() { return "My String"; } int main() { const char* szSomeString = myFunction(); printf("%s", szSomeString); }
const char * myFunction(const char* name) { char szBuffer[255]; snprintf(szBuffer, sizeof(szBuffer), "Hi %s", name); return szBuffer; }
const char* calculateMonth(int month) { static char* months[] = {"Jan", "Feb", "Mar" .... }; static char badFood[] = "Unknown"; if (month<1 || month>12) return badFood; else return months[month-1]; } int main() { printf("%s", calculateMonth(2)); }
class Foo { char _someData[12]; public: const char* someFunction() const { return _someData; } }
void calculateMonth(int month, char* pszMonth, int buffersize) { const char* months[] = {"Jan", "Feb", "Mar" .... }; if (!pszMonth || buffersize<1) return; if (month<1 || month>12) { *pszMonth = } else { strncpy(pszMonth, months[month-1], buffersize-1); } pszMonth[buffersize-1] = } int main() { char month[16]; calculateMonth(3, month, sizeof(month)); printf("%s", month); }
const char* myFunction() { static char array[] = "my string"; return array; }
char* myFunction( char* output_str, size_t max_len ) { const char *str = "my string"; size_t l = strlen(str); if (l+1 > max_len) { return NULL; } strcpy(str, str, l); return input; }
char* myFunction(char * buf, int buf_len){ strncpy(buf, "my string", buf_len); return buf; }
char array[51]; memset(array,0,51); printf("%s", myFunction(array,50));/*buf_len arguement is 50 not 51. This is to make sure the string in buf is always null-terminated(array[50] is always
void print_month(int month) { switch (month) { case 0: printf("january"); break; case 1: printf("february"); break; ...etc... } }
char get_string_char(int index) { static char array[] = "my string"; return array[index]; } int main() { for (int i = 0; i < 9; ++i) printf("%c", get_string_char(i)); printf("\n"); return 0; }
int sc_and(int a, int b){ return a?b:0; } int a(){ cout<<"called a!"<<endl; return 0; } int b(){ cout<<"called b!"<<endl; return 1; } int main(char* argc, char** argv){ int x = sc_and(a(), b()); return 0; }
int a() { printf("I return 0; } int b() { printf("And I return 1; } int sc_and(int (*a)(), int (*b)()) { a() ? b() : 0; } int main() { sc_and(a, b); return 0; }
call *%rdx <-- call a() testl %eax, %eax <-- test result je .L8 <-- skip if 0 (false) movq -16(%rbp), %rdx movl $0, %eax call *%rdx <- calls b() only if not skipped .L8:
int comp (const void * elem1, const void * elem2) { int f = *((int*)elem1); int s = *((int*)elem2); if (f > s) return 1; if (f < s) return -1; return 0; } int main(int argc, char* argv[]) { int x[] = {4,5,2,3,1,0,9,8,6,7}; qsort (x, sizeof(x)/sizeof(*x), sizeof(*x), comp); for (int i = 0 ; i < 10 ; i++) printf ("%d ", x[i]); return 0; }
qsort(<arrayname>,<size>,sizeof(<elementsize>),compare_function);
int compare_function(const void *a,const void *b) { int *x = (int *) a; int *y = (int *) b; return *x - *y; }
int compare_function(const void *a,const void *b) { return (strcmp((char *)a,(char *)b)); }
int compare_function(const void *a,const void *b) { double *x = (double *) a; double *y = (double *) b; if (*x < *y) return -1; else if (*x > *y) return 1; return 0; }
typedef struct { int key; double value; } the_record; int compare_function(const void *a,const void *b) { the_record *x = (the_record *) a; the_record *y = (the_record *) b; return x->key - y->key; }
int64_quick_sort(arr, 128); /* Assumes you have some int *arr or int arr[128]; */
int main () { int *p = malloc(10 * sizeof *p); *p = 42; return 0; }
112 .opt 118 .def 140 .cc 185 .x 250 .exp 353 .md 366 .mm 414 .f 430 .f03 521 .m 625 .a 1082 .go 1371 .h 1602 .ads 1655 .adb 1828 .ada 3860 .f90 11231 .C 23811 .c
int func_prim (int zahl) { int count; if (zahl < 0) return -1; for (count = 2; zahl % count != 0 && zahl >= count; count++); if (count == zahl) return 1; return 0; }
v for (count = 2; zahl % count != 0 && zahl >= count; count++);
for(count = 2; zahl % count != 0 && zahl >= count; count++) { }
for ( clause-1 ; expression-2 ; expression-3 ) statement
for (count = 2; zahl % count != 0 && zahl >= count; count++);
for(count=2; zahl % count != 0 && zahl >= count; count++);
count=2; while(zahl % count != 0 && zahl >= count) { count++; }
for (x = 1; x <= 5; printf ("x is now %d\n", x), x++) ;
int func_prim (int zahl) { int count; if (zahl < 0) return -1; for (count = 2; zahl % count != 0 && zahl >= count; count++) ; if (count == zahl) return 1; return 0; }
int func_prim (int zahl) { int count; if (zahl < 0) return -1; for (count = 2; zahl % count != 0 && zahl >= count; count++) if (count == zahl) return 1; return 0; }
__attribute__ ((pure)) int fun(int i) { return i*i; } int main() { int i=10; printf("%d",fun(i)); return 0; }
for (int i = 0; i < 1000; i++) { printf("%d", fun(10)); }
constexpr unsigned static_strlen(const char * str, unsigned offset = 0) { return (*str == } constexpr const char * str = "asdfjkl;"; constexpr unsigned len = static_strlen(str); int main() { std::cout << len << std::endl << std::strlen(str) << std::endl; return 0; }
char int c0 -> ffffffc0 80 -> ffffff80 61 -> 00000061
uint8_t a = 0x0a; printf("%02hhX", a); printf("0x%02hhx", a);
int main() { printf("%x %x %x %x %x %x %x %x\n", 0xC0, 0xC0, 0x61, 0x62, 0x63, 0x31, 0x32, 0x33); }
int child_process_id = fork(); if (child_process_id) { waitpid(child_process_id, ...); } else { const char *argv[] = {"arg1", "arg2", "arg3", NULL}; exec("/path/to/a/program", argv); }
void main(void) { pid_t pid; int i; char buf[BUF_SIZE]; fork(); pid = getpid(); for (i = 1; i <= MAX_COUNT; i++) { sprintf(buf, "This line is from pid %d, value = %d\n", pid, i); write(1, buf, strlen(buf)); } }
................ This line is from pid 3456, value 13 This line is from pid 3456, value 14 ................ This line is from pid 3456, value 20 This line is from pid 4617, value 100 This line is from pid 4617, value 101 ................ This line is from pid 3456, value 21 This line is from pid 3456, value 22 ................
int main() { int t1,t2,p,i,n,ab; p=getpid(); printf("enter the number of levels\n");fflush(stdout); scanf("%d",&n); printf("root %d\n",p);fflush(stdout); for(i=1;i<n;i++) { t1=fork(); if(t1!=0) t2=fork(); if(t1!=0 && t2!=0) break; printf("child pid %d parent pid %d\n",getpid(),getppid());fflush(stdout); } waitpid(t1,&ab,0); waitpid(t2,&ab,0); return 0; }
enter the number of levels 3 root 20665 child pid 20670 parent pid 20665 child pid 20669 parent pid 20665 child pid 20672 parent pid 20670 child pid 20671 parent pid 20670 child pid 20674 parent pid 20669 child pid 20673 parent pid 20669
int var_glb; int main(void) { pid_t childPID; int var_lcl = 0; childPID = fork(); if(childPID >= 0) { if(childPID == 0) { var_lcl++; var_glb++; printf("\n Child Process :: var_lcl = [%d], var_glb[%d]\n", var_lcl, var_glb); } else { var_lcl = 10; var_glb = 20; printf("\n Parent process :: var_lcl = [%d], var_glb[%d]\n", var_lcl, var_glb); } } else { printf("\n Fork failed, quitting!!!!!!\n"); return 1; } return 0; }
$ ./fork Parent process :: var_lcl = [10], var_glb[20] Child Process :: var_lcl = [1], var_glb[1]
for(int i = 0; str[i]; i++){ str[i] = tolower(str[i]); }
for(char *p = pstr;*p;++p) *p=*p>0x40&&*p<0x5b?*p|0x60:*p;
char blah[] = "blah blah Blah BLAH blAH\0"; int i=0; while(blah[i]|=
int main(void) { int i; if(0) { i = 1/0; } return 0; }
size_t fread_buf( void* ptr, size_t size, FILE* stream) { return fread( ptr, 1, size, stream); } size_t fwrite_buf( void const* ptr, size_t size, FILE* stream) { return fwrite( ptr, 1, size, stream); }
int intArray[10]; fwrite(intArray, sizeof(int), 10, fd);
int intArray[10]; fwrite(intArray, sizeof(int)*10, fd);
int sprintf ( char * str, const char * format, ... );
char *hello_world = (char*)malloc(13 * sizeof(char)); sprintf(hello_world, "%s %s!", "Hello" "world");
void foo( char* s); void foofmt( char* fmt, ...) { char buf[100]; va_list vl; va_start(vl, fmt); vsnprintf( buf, sizeof( buf), fmt, vl); va_end( vl); foo( buf); } int main() { int val = 42; foofmt( "Some value: %d\n", val); return 0; }
char* string; if(0 > asprintf(&string, "Formatting a number: %d\n", 42)) return error; log_out(string); free(string);
void log_out_wrapper(const char *format, ...) __attribute__ ((format (printf, 1, 2))); void log_out_wrapper(const char *format, ...) { char* string; va_list args; va_start(args, format); if(0 > vasprintf(&string, format, args)) string = NULL; va_end(args); if(string) { log_out(string); free(string); } else { log_out("Error while logging a message: Memory allocation failed.\n"); } }
static FILE *logfp = ...; void log_out(const char *fmt, ...) { va_list args; va_start(args, fmt); vfprintf(logfp, fmt, args); va_end(args); }
void log_out_wrapper(const char *fmt, ...) { va_list args; size_t len; char *space; va_start(args, fmt); len = vsnprintf(0, 0, fmt, args); va_end(args); if ((space = malloc(len + 1)) != 0) { va_start(args, fmt); vsnprintf(space, len+1, fmt, args); va_end(args); log_out(space); free(space); } }
void eprintf (const char *template, ...) { va_list ap; extern char *program_invocation_short_name; fprintf (stderr, "%s: ", program_invocation_short_name); va_start (ap, template); vfprintf (stderr, template, ap); va_end (ap); }
static unsigned long next = 1; int myrand(void) { next = next * 1103515245 + 12345; return((unsigned)(next/65536) % 32768); } void mysrand(unsigned seed) { next = seed; }
signed long int i = -42; printf("%u\n", (unsigned)i);
unsigned = unsigned int (Integer type) signed = signed int (Integer type)
Argument Vector, argv[] = { "mysort", "2", "8", "9", "1", "4", "5" };
$ cat mysort.c int main( int argc, char * argv [] ) { printf( "argc = %d\n", argc ); for( int i = 0; i < argc; ++i ) { printf( "argv[ %d ] = %s\n", i, argv[ i ] ); } } $ gcc mysort.c -o mysort $ ./mysort 2 8 9 1 4 5 argc = 7 argv[ 0 ] = ./mysort argv[ 1 ] = 2 argv[ 2 ] = 8 argv[ 3 ] = 9 argv[ 4 ] = 1 argv[ 5 ] = 4 argv[ 6 ] = 5
double nan(const char *tagp); float nanf(const char *tagp); long double nanl(const char *tagp);
double NAN = 0.0/0.0; double POS_INF = 1.0 /0.0; double NEG_INF = -1.0/0.0;
int inf = 0x7F800000; return *(float*)&inf; int nan = 0x7F800001; return *(float*)&nan;
double a_nan = strtod("NaN", NULL); double a_inf = strtod("Inf", NULL);
<bits/nan.h> (__extension__ \ ((union { unsigned __l __attribute__ ((__mode__ (__SI__))); float __d; }) \ { __l: 0x7fc00000UL }).__d) static union { unsigned char __c[4]; float __d; } __nan_union __attribute_used__ = { __nan_bytes };
int main() { time_t timer; char buffer[26]; struct tm* tm_info; time(&timer); tm_info = localtime(&timer); strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", tm_info); puts(buffer); return 0; }
int main() { char buffer[26]; int millisec; struct tm* tm_info; struct timeval tv; gettimeofday(&tv, NULL); millisec = lrint(tv.tv_usec/1000.0); if (millisec>=1000) { millisec -=1000; tv.tv_sec++; } tm_info = localtime(&tv.tv_sec); strftime(buffer, 26, "%Y:%m:%d %H:%M:%S", tm_info); printf("%s.%03d\n", buffer, millisec); return 0; }
int main (void) { char buff[100]; time_t now = time (0); strftime (buff, 100, "%Y-%m-%d %H:%M:%S.000", localtime (&now)); printf ("%s\n", buff); return 0; }
int main(void) { struct timeval tmnow; struct tm *tm; char buf[30], usec_buf[6]; gettimeofday(&tmnow, NULL); tm = localtime(&tmnow.tv_sec); strftime(buf,30,"%Y:%m:%dT%H:%M:%S", tm); strcat(buf,"."); sprintf(usec_buf,"%dZ",(int)tmnow.tv_usec); strcat(buf,usec_buf); printf("%s",buf); return 0; }
struct tm tm; char s[20]; /* strlen("2009-08-10 18:17:54") + 1 */ strftime(s, 20, "%F %H:%M:%S", &tm);
int main(char *argv[]){ float k; printf("this is consumer\n"); k=(float)sqrt(atoi(argv[1])); printf("%s\n",k); return 0; }
static void full_write(int fd, const char *buf, size_t len) { while (len > 0) { ssize_t ret = write(fd, buf, len); if ((ret == -1) && (errno != EINTR)) break; buf += (size_t) ret; len -= (size_t) ret; } } void print_backtrace(void) { static const char start[] = "BACKTRACE ------------\n"; static const char end[] = "----------------------\n"; void *bt[1024]; int bt_size; char **bt_syms; int i; bt_size = backtrace(bt, 1024); bt_syms = backtrace_symbols(bt, bt_size); full_write(STDERR_FILENO, start, strlen(start)); for (i = 1; i < bt_size; i++) { size_t len = strlen(bt_syms[i]); full_write(STDERR_FILENO, bt_syms[i], len); full_write(STDERR_FILENO, "\n", 1); } full_write(STDERR_FILENO, end, strlen(end)); free(bt_syms); } void foo() { print_backtrace(); } int main() { foo(); return 0; }
static void full_write(int fd, const char *buf, size_t len) { while (len > 0) { ssize_t ret = write(fd, buf, len); if ((ret == -1) { if (errno != EINTR)) break; continue; } buf += (size_t) ret; len -= (size_t) ret; } }
U+0000 .. U+007F 1 byte 0xxx xxxx U+0080 .. U+07FF 2 bytes 110x xxxx 10xx xxxx U+0800 .. U+FFFF 3 bytes 1110 xxxx 10xx xxxx 10xx xxxx U+10000 .. U+10FFFF 4 bytes 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
typedef unsigned char utf8_t; typedef unsigned short utf16_t; typedef unsigned long utf32_t; int main ( int argc, char *argv[] ) { int msgBoxId; utf16_t lpText[] = { 0x03B1, 0x0009, 0x03B2, 0x0009, 0x03B3, 0x0009, 0x03B4, 0x0000 }; utf16_t lpCaption[] = L"Greek Characters"; unsigned int uType = MB_OK; msgBoxId = MessageBoxW( NULL, lpText, lpCaption, uType ); return 0; }
int strlonger(char *s1, char *s2) { return strlen(s1) - strlen(s2) > 0; }
int sum_array_elements(int a[], unsigned length) { int i; int result = 0; for (i = 0; i <= length-1; i++) result += a[i]; return result; }
return ptrdiff_t(strlen(s1)) - ptrdiff_t(strlen(s2)) > 0;
void print_current_time_with_ms (void) { long ms; time_t s; struct timespec spec; clock_gettime(CLOCK_REALTIME, &spec); s = spec.tv_sec; ms = round(spec.tv_nsec / 1.0e6); if (ms > 999) { s++; ms = 0; } printf("Current time: %"PRIdMAX".%03ld seconds since the Epoch\n", (intmax_t)s, ms); }
struct timeval tv; gettimeofday(&tv, NULL); double time_in_mill = (tv.tv_sec) * 1000 + (tv.tv_usec) / 1000 ;
long long current_timestamp() { struct timeval te; gettimeofday(&te, NULL); long long milliseconds = te.tv_sec*1000LL + te.tv_usec/1000; return milliseconds; }
struct timespec ts; timespec_get(&ts, TIME_UTC); struct timespec { time_t tv_sec; long tv_nsec; };
Starting initialization...Ok. Checking init scripts...Ok.
Starting initialization... Ok. Checking init scripts... Ok.
printf( "%-30s %s\n", "Starting initialization...", "Ok." );
int width = 30; printf( "%-*s %s\n", width, "Starting initialization...", "Ok." ); printf( "%-.*s %s\n", width, "Starting initialization...", "Ok." );
int width1, width2; int values[6][2]; printf("|%s%n|%s%n|\n", header1, &width1, header2, &width2); for(i=0; i<6; i++) printf("|%*d|%*d|\n", width1, values[i][0], width2, values[i][1]);
long max value: 9223372036854775807 float max value: 340282346638528859811704183484516925440.000000 double max value: 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
int Digs = DECIMAL_DIG; double OneSeventh = 1.0/7.0; printf("%.*e\n", Digs, OneSeventh);
OneSeventh before = 0.1428571428571428 214571170656199683435261249542236328125 OneSeventh = 0.1428571428571428 49212692681248881854116916656494140625 OneSeventh after = 0.1428571428571428 769682682968777953647077083587646484375
FLT_DECIMAL_DIG 6, 9 (float) (C11) DBL_DECIMAL_DIG 10, 17 (double) (C11) LDBL_DECIMAL_DIG 10, 21 (long double) (C11) DECIMAL_DIG 10, 21 (widest supported floating type) (C99)
FLT_DIG 6, 6 (float) DBL_DIG 10, 15 (double) LDBL_DIG 10, 18 (long double)
printf("%.*f\n", OP_DBL_Digs , OneSeventh); printf("%.*f\n", OP_DBL_Digs + 6, OneSeventh/1000000.0);
float r = 0; printf( "%.6f\n", r ) ; r+=0.1 ; printf( "%.6f\n", r ) ;
r = 1e27; printf( "%.6f\n", r ) ; r+=0.1 ; printf( "%.6f\n", r ) ;
float f = 3.14159265358979323846; printf("%.*f\n", FLT_DIG, f);
static unsigned int ilog10(uintmax_t v); /* * Note: As presented this demo code prints a whole line including information * about how the form was arrived with, as well as in certain cases a couple of * interesting details about the number, such as the number of decimal places, * and possibley the magnitude of the value and the number of significant * digits. */ void print_decimal(double d) { size_t sigdig; int dplaces; double flintmax; /* * If we really want to see a plain decimal presentation with all of * the possible significant digits of precision for a floating point * number, then we must calculate the correct number of decimal places * to show with "%.*f" as follows. * * This is in lieu of always using either full on scientific notation * with "%e" (where the presentation is always in decimal format so we * can directly print the maximum number of significant digits * supported by the representation, taking into acount the one digit * represented by by the leading digit) * * printf("%1.*e", DBL_DECIMAL_DIG - 1, d) * * or using the built-in human-friendly formatting with "%g" (where a * * and so we can just print exactly the maximum number supported by the * representation) * * printf("%.*g", DBL_DECIMAL_DIG, d) * * * N.B.: If we want the printed result to again survive a round-trip * conversion to binary and back, and to be rounded to a human-friendly * number, then we can only print DBL_DIG significant digits (instead * of the larger DBL_DECIMAL_DIG digits). * * Note: "flintmax" here refers to the largest consecutive integer * that can be safely stored in a floating point variable without * losing precision. */ sigdig = DBL_DIG; sigdig = ilog10(uipow(FLT_RADIX, DBL_MANT_DIG - 1)); sigdig = DBL_DECIMAL_DIG; sigdig = (size_t) lrint(ceil(DBL_MANT_DIG * log10((double) FLT_RADIX))) + 1; flintmax = pow((double) FLT_RADIX, (double) DBL_MANT_DIG); /* xxx use uipow() */ if (d == 0.0) { printf("z = %.*s\n", (int) sigdig + 1, "0.000000000000000000000"); } else if (fabs(d) >= 0.1 && fabs(d) <= flintmax) { dplaces = (int) (sigdig - (size_t) lrint(ceil(log10(ceil(fabs(d)))))); if (dplaces < 0) { /* * XXX the last digit is not significant!!! XXX * * This should also be printed with sprintf() and edited... */ printf("R = %.0f [%d too many significant digits!!!, zero decimal places]\n", d, abs(dplaces)); } else if (dplaces == 0) { /* * The decimal fraction here is not significant and * should always be zero (XXX I */ printf("R = %.0f [zero decimal places]\n", d); } else { if (fabs(d) == 1.0) { /* * This is a special case where the calculation * is off by one because log10(1.0) is 0, but * we still have the leading * count as a significant digit. */ printf("ceil(1.0) = %f, log10(ceil(1.0)) = %f, ceil(log10(ceil(1.0))) = %f\n", ceil(fabs(d)), log10(ceil(fabs(d))), ceil(log10(ceil(fabs(d))))); dplaces--; } printf("r = %.*f [%d decimal places]\n", dplaces, d, dplaces); } } else { if (fabs(d) < 1.0) { int lz; lz = abs((int) lrint(floor(log10(fabs(d))))); dplaces = (int) sigdig - 1 + lz; printf("f = %.*f [%d decimal places]\n", dplaces, d, dplaces); } else { size_t n; size_t i; char *df; /* * hmmmm... the easy way to suppress the "invalid", * i.e. non-significant digits is to do a string * replacement of all dgits after the first * DBL_DECIMAL_DIG to convert them to zeros, and to * round the least significant digit. */ df = malloc((size_t) 1); n = (size_t) snprintf(df, (size_t) 1, "%.1f", d); n++; df = realloc(df, n); (void) snprintf(df, n, "%.1f", d); if ((n - 2) > sigdig) { /* * XXX rounding the integer part here is "hard" * -- we would have to convert the digits up to * this point back into a binary format and * round that value appropriately in order to * do it correctly. */ if (df[sigdig] >= if (df[sigdig - 1] == /* * xxx fixing this is left as * an exercise to the reader! */ printf("F = *** failed to round integer part at the least significant digit!!! ***\n"); free(df); return; } else { df[sigdig - 1]++; } } for (i = sigdig; df[i] != df[i] = } } else { i = n - 1; if (isnan(d) || isinf(d)) { sigdig = 0; } } printf("F = %.*s. [0 decimal places, %lu digits, %lu digits significant]\n", (int) i, df, (unsigned long int) i, (unsigned long int) sigdig); free(df); } } return; } static unsigned int msb(uintmax_t v) { unsigned int mb = 0; while (v >>= 1) { /* unroll for more speed... (see ilog2()) */ mb++; } return mb; } static unsigned int ilog10(uintmax_t v) { unsigned int r; static unsigned long long int const PowersOf10[] = { 1LLU, 10LLU, 100LLU, 1000LLU, 10000LLU, 100000LLU, 1000000LLU, 10000000LLU, 100000000LLU, 1000000000LLU, 10000000000LLU, 100000000000LLU, 1000000000000LLU, 10000000000000LLU, 100000000000000LLU, 1000000000000000LLU, 10000000000000000LLU, 100000000000000000LLU, 1000000000000000000LLU, 10000000000000000000LLU }; if (!v) { return ~0U; } /* * By the relationship "log10(v) = log2(v) / log2(10)", we need to * multiply "log2(v)" by "1 / log2(10)", which is approximately * 1233/4096, or (1233, followed by a right shift of 12). * * Finally, since the result is only an approximation that may be off * by one, the exact value is found by subtracting "v < PowersOf10[r]" * from the result. */ r = ((msb(v) * 1233) >> 12) + 1; return r - (v < PowersOf10[r]); }
union { short s[4]; double d; } u; void test(int digits) { int i, j; char buff[40]; double d2; int n, num_equal, bin_equal; srand(17); n = num_equal = bin_equal = 0; for (i = 0; i < 1000000; i++) { for (j = 0; j < 4; j++) u.s[j] = rand(); if (isnan(u.d)) continue; n++; sprintf(buff, "%.*g", digits, u.d); sscanf(buff, "%lg", &d2); if (u.d == d2) num_equal++; if (memcmp(&u.d, &d2, sizeof(double)) == 0) bin_equal++; } printf("Tested %d values with %d digits: %d found numericaly equal, %d found binary equal\n", n, digits, num_equal, bin_equal); } int main() { test(DBL_DECIMAL_DIG); test(DBL_DECIMAL_DIG - 1); return 0; }
... void* callstack[128]; int i, frames = backtrace(callstack, 128); char** strs = backtrace_symbols(callstack, frames); for (i = 0; i < frames; ++i) { printf("%s\n", strs[i]); } free(strs); ...
class MyException : public std::exception { char ** strs; MyException( const std::string & message ) { int i, frames = backtrace(callstack, 128); strs = backtrace_symbols(callstack, frames); } void printStackTrace() { for (i = 0; i
try { throw MyException("Oops!"); } catch ( MyException e ) { e.printStackTrace(); }
unw_cursor_t cursor; unw_context_t uc; unw_word_t ip, sp; unw_getcontext(&uc); unw_init_local(&cursor, &uc); unsigned long a[100]; int ctr = 0; while (unw_step(&cursor) > 0) { unw_get_reg(&cursor, UNW_REG_IP, &ip); unw_get_reg(&cursor, UNW_REG_SP, &sp); if (ctr >= 10) break; a[ctr++] = ip; }
If the RST bit is set If this connection was initiated with a passive OPEN (i.e., came from the LISTEN state), then return this connection to LISTEN state and return. The user need not be informed. If this connection was initiated with an active OPEN (i.e., came from SYN-SENT state) then the connection was refused, signal the user "connection refused". In either case, all segments on the retransmission queue should be removed. And in the active OPEN case, enter the CLOSED state and delete the TCB, and return.
vim /etc/sysconfig/iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT
main() { int i = 0; for(i=0;i<7;++i) printf("%d\n", i); return 0; }
(gdb) break if ((int)i == 5) No default breakpoint address now. (gdb) run Starting program: /home/SIFE/run 0 1 2 3 4 5 6 Program exited normally. (gdb)
(gdb) break iter.c:6 if i == 5 Breakpoint 2 at 0x4004dc: file iter.c, line 6. (gdb) c Continuing. 0 1 2 3 4 Breakpoint 2, main () at iter.c:6 6 printf("%d\n", i);
main() { int i = 0; for(i=0;i<7;++i) { looping: printf("%d\n", i); } return 0; } (gdb) break main:looping if i == 5
(gdb) list 1 2 int main(void) 3 { 4 int i = 0; 5 for(i=0;i<7;++i) 6 printf("%d\n", i); 7 8 return 0; 9 }
(gdb) b 5 Breakpoint 1 at 0x4004fb: file ex1.c, line 5. (gdb) rwatch i if i==5 Hardware read watchpoint 5: i
(gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00000000004004fb in main at ex1.c:5 breakpoint already hit 1 time 5 read watchpoint keep y i stop only if i==5
(gdb) c Continuing. 0 1 2 3 4 Hardware read watchpoint 5: i Value = 5 0x0000000000400523 in main () at ex1.c:5 5 for(i=0;i<7;++i)
gcc -m64 -std=c99 -pedantic -Wall -Wshadow -Wpointer-arith -Wcast-qual \ -Wstrict-prototypes -Wmissing-prototypes
gcc -Wall -W -Wunused-parameter -Wmissing-declarations -Wstrict-prototypes -Wmissing-prototypes -Wsign-compare -Wconversion -Wshadow -Wcast-align -Wparentheses -Wsequence-point -Wdeclaration-after-statement -Wundef -Wpointer-arith -Wnested-externs -Wredundant-decls -Werror -Wdisabled-optimization -pedantic -funit-at-a-time -o
int the_spams; double the_eggs; int spam() { return the_spams++; } double eggs() { return the_eggs--; }
int spam(int new_spams); double eggs(double new_eggs);
int the_spams; double the_eggs; int spam(int new_spams) { int old_spams = the_spams; the_spams = new_spams; return old_spams; } double eggs(double new_eggs) { double old_eggs = the_eggs; the_eggs = new_eggs; return old_eggs; }
int main() { const int new_bar_spam = 3; const double new_bar_eggs = 5.0f; printf("foo: spam = %d, eggs = %f\n", spam(), eggs() ); printf("bar: old spam = %d, new spam = %d ; old eggs = %f, new eggs = %f\n", spam(new_bar_spam), new_bar_spam, eggs(new_bar_eggs), new_bar_eggs ); return 0; }
example/ex01/ $ make cc -c -o foobar.o foobar.c In file included from foobar.c:4: bar.h:1: error: conflicting types for ‘spam’ foo.h:1: note: previous declaration of ‘spam’ was here bar.h:2: error: conflicting types for ‘eggs’ foo.h:2: note: previous declaration of ‘eggs’ was here foobar.c: In function ‘main’: foobar.c:11: error: too few arguments to function ‘spam’ foobar.c:11: error: too few arguments to function ‘eggs’ make: *** [foobar.o] Error 1
int main() { const int new_bar_spam = 3; const double new_bar_eggs = 5.0f; printf("foo: spam = %d, eggs = %f\n", foo_spam(), foo_eggs() ); printf("bar: old spam = %d, new spam = %d ; old eggs = %f, new eggs = %f\n", bar_spam(new_bar_spam), new_bar_spam, bar_eggs(new_bar_eggs), new_bar_eggs ); return 0; }
example/ex02/ $ make cc -c -o foobar.o foobar.c cc foobar.o foo.o bar.o -o foobar bar.o: In function `spam bar.c:(.text+0x0): multiple definition of `spam' foo.o:foo.c:(.text+0x0): first defined here bar.o: In function `eggs bar.c:(.text+0x1e): multiple definition of `eggs' foo.o:foo.c:(.text+0x19): first defined here foobar.o: In function `main foobar.c:(.text+0x1e): undefined reference to `foo_eggs' foobar.c:(.text+0x28): undefined reference to `foo_spam' foobar.c:(.text+0x4d): undefined reference to `bar_eggs' foobar.c:(.text+0x5c): undefined reference to `bar_spam' collect2: ld returned 1 exit status make: *** [foobar] Error 1
example/ex02/ $ nm foo.o 0000000000000019 T eggs 0000000000000000 T spam 0000000000000008 C the_eggs 0000000000000004 C the_spams example/ex02/ $ nm bar.o 0000000000000019 T eggs 0000000000000000 T spam 0000000000000008 C the_eggs 0000000000000004 C the_spams
example/ex03/ $ objcopy --prefix-symbols=foo_ foo.o example/ex03/ $ objcopy --prefix-symbols=bar_ bar.o
example/ex03/ $ nm foo.o 0000000000000019 T foo_eggs 0000000000000000 T foo_spam 0000000000000008 C foo_the_eggs 0000000000000004 C foo_the_spams example/ex03/ $ nm bar.o 000000000000001e T bar_eggs 0000000000000000 T bar_spam 0000000000000008 C bar_the_eggs 0000000000000004 C bar_the_spams
example/ex03/ $ make cc foobar.o foo.o bar.o -o foobar
example/ex03/ $ ./foobar foo: spam = 0, eggs = 0.000000 bar: old spam = 0, new spam = 3 ; old eggs = 0.000000, new eggs = 5.000000
int q = 10; int s = 5; int a[3]; printf("Address of a: %d\n", (int)a); printf("Address of a[1]: %d\n", (int)&a[1]); printf("Address of a[2]: %d\n", (int)&a[2]); printf("Address of q: %d\n", (int)&q); printf("Address of s: %d\n", (int)&s);
Address of a: 2293584 Address of a[1]: 2293588 Address of a[2]: 2293592 Address of q: 2293612 Address of s: 2293608
direction of | | growth of +---------------------------------+ stack | Parameters passed by fn1(caller)| from higher addr.| | to lower addr. | Direction of growth is opposite | | | to direction of stack growth | | +---------------------------------+ <-- SP on entry to fn2 | | Return address from fn2(callee) | V +---------------------------------+ | Callee saved registers being | | used in the callee function | +---------------------------------+ | Local variables of fn2 | |(Direction of growth of frame is | | same as direction of growth of | | stack) | +---------------------------------+ | Arguments to functions called | | by fn2 | +---------------------------------+ <- Current SP after stack frame is allocated
int f(int *x) { int a; return x == NULL ? f(&a) : &a - x; } int main(void) { printf("stack grows %s!\n", f(NULL) < 0 ? "down" : "up"); return 0; }
$ cat stack.c int stack(int x) { printf("level %d: x is at %p\n", x, (void*)&x); if (x == 0) return 0; return stack(x - 1); } int main(void) { stack(4); return 0; }
void fun(int *main_local_addr) { int fun_local; if (main_local_addr < &fun_local) printf("Stack grows upward\n"); else printf("Stack grows downward\n"); } int main() { int main_local; fun(&main_local); return 0; }
void main() { clock_t start, end; double runTime; start = clock(); int i, num = 1, primes = 0; while (num <= 1000) { i = 2; while (i <= num) { if(num % i == 0) break; i++; } if (i == num) primes++; system("clear"); printf("%d prime numbers calculated\n",primes); num++; } end = clock(); runTime = (end - start) / (double) CLOCKS_PER_SEC; printf("This machine calculated all %d prime numbers under 1000 in %g seconds\n", primes, runTime); }
int main() { double start, end; double runTime; start = omp_get_wtime(); int num = 1,primes = 0; int limit = 1000000; for (num = 1; num <= limit; num++) { int i = 2; while(i <= num) { if(num % i == 0) break; i++; } if(i == num) primes++; } end = omp_get_wtime(); runTime = end - start; printf("This machine calculated all %d prime numbers under %d in %g seconds\n",primes,limit,runTime); return 0; }
void do_primes() { unsigned long i, num, primes = 0; for (num = 1; num <= MAX_PRIME; ++num) { for (i = 2; (i <= num) && (num % i != 0); ++i); if (i == num) ++primes; } printf("Calculated %d primes.\n", primes); } int main(int argc, char ** argv) { time_t start, end; time_t run_time; unsigned long i; pid_t pids[NUM_OF_CORES]; start = time(NULL); for (i = 0; i < NUM_OF_CORES; ++i) { if (!(pids[i] = fork())) { do_primes(); exit(0); } if (pids[i] < 0) { perror("Fork"); exit(1); } } for (i = 0; i < NUM_OF_CORES; ++i) { waitpid(pids[i], NULL, 0); } end = time(NULL); run_time = (end - start); printf("This machine calculated all prime numbers under %d %d times " "in %d seconds\n", MAX_PRIME, NUM_OF_CORES, run_time); return 0; }
$ ./primes Calculated 9592 primes. Calculated 9592 primes. Calculated 9592 primes. Calculated 9592 primes. Calculated 9592 primes. Calculated 9592 primes. Calculated 9592 primes. Calculated 9592 primes. This machine calculated all prime numbers under 100000 8 times in 8 seconds
system("clear"); printf("%d prime numbers calculated\n",primes);
using namespace std; struct prime_range { int min; int max; int total; }; void* findPrime(void *threadarg) { int i, primes = 0; struct prime_range *this_range; this_range = (struct prime_range *) threadarg; int minLimit = this_range -> min ; int maxLimit = this_range -> max ; int flag = false; while (minLimit <= maxLimit) { i = 2; int lim = ceil(sqrt(minLimit)); while (i <= lim) { if (minLimit % i == 0){ flag = true; break; } i++; } if (!flag){ primes++; } flag = false; minLimit++; } this_range ->total = primes; pthread_exit(NULL); } int main (int argc, char *argv[]) { struct timespec start, finish; double elapsed; clock_gettime(CLOCK_MONOTONIC, &start); pthread_t threads[NUM_THREADS]; struct prime_range pr[NUM_THREADS]; int rc; pthread_attr_t attr; void *status; pthread_attr_init(&attr); pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE); for(int t=1; t<= NUM_THREADS; t++){ pr[t].min = (t-1) * THREAD_LOAD + 1; pr[t].max = t*THREAD_LOAD; rc = pthread_create(&threads[t], NULL, findPrime,(void *)&pr[t]); if (rc){ printf("ERROR; return code from pthread_create() is %d\n", rc); exit(-1); } } int totalPrimesFound = 0; pthread_attr_destroy(&attr); for(int t=1; t<= NUM_THREADS; t++){ rc = pthread_join(threads[t], &status); if (rc) { printf("Error:unable to join, %d" ,rc); exit(-1); } totalPrimesFound += pr[t].total; } clock_gettime(CLOCK_MONOTONIC, &finish); elapsed = (finish.tv_sec - start.tv_sec); elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0; printf("This machine calculated all %d prime numbers under %d in %lf seconds\n",totalPrimesFound, NUM_THREADS*THREAD_LOAD, elapsed); pthread_exit(NULL); }
struct { int x, y; } a[10] = { [3] = { .y = 12, .x = 1 } };
enum { Iron = 26, Aluminium = 13, Beryllium = 4, ... }; const char *element_names[] = { [Iron] = "Iron", [Aluminium] = "Aluminium", [Beryllium] = "Beryllium", ... };
int x; scanf("%d", &x); int a[x]; for (int i = 0; i < x; ++i) a[i] = i * i; for (int i = 0; i < x; ++i) printf("%d\n", a[i]);
typedef struct { int len; char buf[]; } buffer; int bufsize = 100; buffer *b = malloc(sizeof(buffer) + sizeof(int[bufsize]));
struct A *a = malloc(sizeof(*a)); *a = (struct A){0}; *a = (struct A){.bufsiz=1024, .fd=2};
int main(void) { fork() && (fork() || fork()); printf("forked!\n"); return 0; }
int main(void) { if(printf("A printf() results in logic true\n")) ; if(0 && printf("Short circuiting will not let me execute\n")) ; else if(0 || printf("I have to be executed\n")) ; else if(1 || printf("No need for me to get executed\n")) ; else printf("The answer wasn return 0; }
A printf() results in logic true I have to be executed
fork() / \ 0/ \>0 || fork() && fork() /\ / \ / \ 0/ \>0 * * || fork() * / \ * *
int main(){ long child = fork() && (fork() || fork()); printf("forked! PID=%ld Child=%ld\n", getpid(), child); return 0; }
forked! PID=3694 Child = 0 forked! PID=3696 Child = 0 forked! PID=3693 Child = 1 forked! PID=3695 Child = 1
struct x { char a[10]; char b[20]; int i; char *c; char *d[10]; };
struct x myStruct; memset(&myStruct, 0, sizeof(myStruct));
struct x x_instance; memset (&x_instance, 0, sizeof(x_instance));
struct x instance; for(i = 0; i < n; i++) { instance = {}; }
int v; unsigned int r; int const mask = v >> sizeof(int) * CHAR_BIT - 1; r = (v + mask) ^ mask;
int const mask = v >> sizeof(int) * CHAR_BIT - 1; int const mask = -((unsigned)v >> sizeof(int) * CHAR_BIT - 1);
char *str_replace(char *orig, char *rep, char *with) { char *result; char *ins; char *tmp; int len_rep; int len_with; int len_front; int count; if (!orig || !rep) return NULL; len_rep = strlen(rep); if (len_rep == 0) return NULL; if (!with) with = ""; len_with = strlen(with); ins = orig; for (count = 0; tmp = strstr(ins, rep); ++count) { ins = tmp + len_rep; } tmp = result = malloc(strlen(orig) + (len_with - len_rep) * count + 1); if (!result) return NULL; while (count--) { ins = strstr(orig, rep); len_front = ins - orig; tmp = strncpy(tmp, orig, len_front) + len_front; tmp = strcpy(tmp, with) + len_with; orig += len_front + len_rep; } strcpy(tmp, orig); return result; }
char * replace( char const * const original, char const * const pattern, char const * const replacement ) { size_t const replen = strlen(replacement); size_t const patlen = strlen(pattern); size_t const orilen = strlen(original); size_t patcnt = 0; const char * oriptr; const char * patloc; for (oriptr = original; patloc = strstr(oriptr, pattern); oriptr = patloc + patlen) { patcnt++; } { size_t const retlen = orilen + patcnt * (replen - patlen); char * const returned = (char *) malloc( sizeof(char) * (retlen + 1) ); if (returned != NULL) { char * retptr = returned; for (oriptr = original; patloc = strstr(oriptr, pattern); oriptr = patloc + patlen) { size_t const skplen = patloc - oriptr; strncpy(retptr, oriptr, skplen); retptr += skplen; strncpy(retptr, replacement, replen); retptr += replen; } strcpy(retptr, oriptr); } return returned; } } int main(int argc, char * argv[]) { if (argc != 4) { fprintf(stderr,"usage: %s <original text> <pattern> <replacement>\n", argv[0]); exit(-1); } else { char * const newstr = replace(argv[1], argv[2], argv[3]); if (newstr) { printf("%s\n", newstr); free(newstr); } else { fprintf(stderr,"allocation error\n"); exit(-2); } } return 0; }
int mystrstr(wchar_t *txt1,wchar_t *txt2) { wchar_t *posstr=wcsstr(txt1,txt2); if(posstr!=NULL) { return (posstr-txt1); }else { return -1; } } void StringReplace(wchar_t *buff,wchar_t *txt1,wchar_t *txt2) { wchar_t *tmp; wchar_t *nextStr; int pos; tmp=wcsdup(buff); pos=mystrstr(tmp,txt1); if(pos!=-1) { buff[0]=0; wcsncpy(buff,tmp,pos); buff[pos]=0; wcscat(buff,txt2); nextStr=tmp+pos+wcslen(txt1); while(wcslen(nextStr)!=0) { pos=mystrstr(nextStr,txt1); if(pos==-1) { wcscat(buff,nextStr); break; } wcsncat(buff,nextStr,pos); wcscat(buff,txt2); nextStr=nextStr+pos+wcslen(txt1); } } free(tmp); }
static char *dull_replace(const char *in, const char *pattern, const char *by) { size_t outsize = strlen(in) + 1; char *res = malloc(outsize); size_t resoffset = 0; char *needle; while (needle = strstr(in, pattern)) { memcpy(res + resoffset, in, needle - in); resoffset += needle - in; in = needle + strlen(pattern); outsize = outsize - strlen(pattern) + strlen(by); res = realloc(res, outsize); memcpy(res + resoffset, by, strlen(by)); resoffset += strlen(by); } strcpy(res + resoffset, in); return res; }
int replacestr(char *line, const char *search, const char *replace) { int count; char *sp; if ((sp = strstr(line, search)) == NULL) { return(0); } count = 1; int sLen = strlen(search); int rLen = strlen(replace); if (sLen > rLen) { char *src = sp + sLen; char *dst = sp + rLen; while((*dst = *src) != } else if (sLen < rLen) { int tLen = strlen(sp) - sLen; char *stop = sp + rLen; char *src = sp + sLen + tLen; char *dst = sp + rLen + tLen; while(dst >= stop) { *dst = *src; dst--; src--; } } memcpy(sp, replace, rLen); count += replacestr(sp + rLen, search, replace); return(count); }
char* replace_char(char* str, char in, char out) { char * p = str; while(p != if(*p == in) *p == out; ++p; } return str; }
void strreplace(char *string, const char *find, const char *replaceWith){ if(strstr(string, replaceWith) != NULL){ char *temporaryString = malloc(strlen(strstr(string, find) + strlen(find)) + 1); strcpy(temporaryString, strstr(string, find) + strlen(find)); *strstr(string, find) = strcat(string, replaceWith); strcat(string, temporaryString); free(temporaryString); } }
static void replacestr(char *line, const char *search, const char *replace) { char *sp; if ((sp = strstr(line, search)) == NULL) { return; } int search_len = strlen(search); int replace_len = strlen(replace); int tail_len = strlen(sp+search_len); memmove(sp+replace_len,sp+search_len,tail_len+1); memcpy(sp, replace, replace_len); }
char *zStrrep(char *str, char x, char y){ char *tmp=str; while(*tmp) if(*tmp == x) *tmp++ = y; else *tmp++; *tmp= return str; }
Exmaple Usage char s[]="this is a trial string to test the function."; char x= printf("%s\n",zStrrep(s,x,y)); Example Output this_is_a_trial_string_to_test_the_function.
char *zstring_replace_str(char *str, const char *x, const char *y){ char *tmp_str = str, *tmp_x = x, *dummy_ptr = tmp_x, *tmp_y = y; int len_str=0, len_y=0, len_x=0; for(; *tmp_y; ++len_y, ++tmp_y) ; for(; *tmp_str; ++len_str, ++tmp_str) ; for(; *tmp_x; ++len_x, ++tmp_x) ; if (len_y >= len_str) return str; tmp_y = y; tmp_x = x; for (tmp_str = str ; *tmp_str; ++tmp_str) if(*tmp_str == *tmp_x) { for (dummy_ptr=tmp_str; *dummy_ptr == *tmp_x; ++tmp_x, ++dummy_ptr) if (*(tmp_x+1) == /* Reached end of x, we got something to replace then! * Copy y only if there is enough room for it */ for(tmp_y=y; *tmp_y; ++tmp_y, ++tmp_str) *tmp_str = *tmp_y; } tmp_x = x; } return str; } int main() { char s[]="Free software is a matter of liberty, not price.\n" "To understand the concept, you should think of "as in printf("%s\n\n",s); printf("%s\n",zstring_replace_str(s,"ree","XYZ")); return 0; }
Free software is a matter of liberty, not price. To understand the concept, you should think of as in FXYZ software is a matter of liberty, not price. To understand the concept, you should think of as in
DWORD ReplaceString(__inout PCHAR source, __in DWORD dwSourceLen, __in const char* pszTextToReplace, __in const char* pszReplaceWith) { DWORD dwRC = NO_ERROR; PCHAR foundSeq = NULL; PCHAR restOfString = NULL; PCHAR searchStart = source; size_t szReplStrcLen = strlen(pszReplaceWith), szRestOfStringLen = 0, sztextToReplaceLen = strlen(pszTextToReplace), remainingSpace = 0, dwSpaceRequired = 0; if (strcmp(pszTextToReplace, "") == 0) dwRC = ERROR_INVALID_PARAMETER; else if (strcmp(pszTextToReplace, pszReplaceWith) != 0) { do { foundSeq = strstr(searchStart, pszTextToReplace); if (foundSeq) { szRestOfStringLen = (strlen(foundSeq) - sztextToReplaceLen) + 1; remainingSpace = dwSourceLen - (foundSeq - source); dwSpaceRequired = szReplStrcLen + (szRestOfStringLen); if (dwSpaceRequired > remainingSpace) { dwRC = ERROR_MORE_DATA; } else { restOfString = CMNUTIL_calloc(szRestOfStringLen, sizeof(CHAR)); strcpy_s(restOfString, szRestOfStringLen, foundSeq + sztextToReplaceLen); strcpy_s(foundSeq, remainingSpace, pszReplaceWith); strcat_s(foundSeq, remainingSpace, restOfString); } CMNUTIL_free(restOfString); searchStart = foundSeq + szReplStrcLen; } } while (foundSeq && dwRC == NO_ERROR); } return dwRC; }
char *replace(const char*instring, const char *old_part, const char *new_part) { if(!instring || !old_part || !new_part) { return (char*)NULL; } size_t instring_len=strlen(instring); size_t new_len=strlen(new_part); size_t old_len=strlen(old_part); if(instring_len<old_len || old_len==0) { return (char*)NULL; } const char *in=instring; const char *found=NULL; size_t count=0; size_t out=0; size_t ax=0; char *outstring=NULL; if(new_len> old_len ) { size_t Diff=EXPECTED_REPLACEMENTS*(new_len-old_len); size_t outstring_len=instring_len + Diff; outstring =(char*) malloc(outstring_len); if(!outstring){ return (char*)NULL; } while((found = strstr(in, old_part))!=NULL) { if(count==EXPECTED_REPLACEMENTS) { outstring_len+=Diff; if((outstring=realloc(outstring,outstring_len))==NULL) { return (char*)NULL; } count=0; } ax=found-in; strncpy(outstring+out,in,ax); out+=ax; strncpy(outstring+out,new_part,new_len); out+=new_len; in=found+old_len; count++; } } else { outstring =(char*) malloc(instring_len); if(!outstring){ return (char*)NULL; } while((found = strstr(in, old_part))!=NULL) { ax=found-in; strncpy(outstring+out,in,ax); out+=ax; strncpy(outstring+out,new_part,new_len); out+=new_len; in=found+old_len; } } ax=(instring+instring_len)-in; strncpy(outstring+out,in,ax); out+=ax; outstring[out]= return outstring; }
void replace_str(char *str,char *org,char *rep) { char *ToRep = strstr(str,org); char *Rest = (char*)malloc(strlen(ToRep)); strcpy(Rest,((ToRep)+strlen(org))); strcpy(ToRep,rep); strcat(ToRep,Rest); free(Rest); }
void strrepl(char *str, const char *a, const char *b) { for (char *cursor = str; (cursor = strstr(cursor, a)) != NULL;){ memmove(cursor + strlen(b), cursor + strlen(a), strlen(cursor) - strlen(a) + 1); for (int i = 0; b[i] != cursor[i] = b[i]; cursor += strlen(b); } }
char* astrrepl(const char *str, const char *a, const char *b) { char* strd = strdup(str); for (char *cursor = strd; (cursor = strstr(cursor, a)) != NULL;){ memmove(cursor + strlen(b), cursor + strlen(a), strlen(cursor) - strlen(a) + 1); for (int i = 0; b[i] != cursor[i] = b[i]; cursor += strlen(b); } return strd; }
int main(int argc, char const *argv[]) { char *a = strdup("Hello This Is Jack"); char *b = astrrepl(a, " ", "~~~"); printf("Out of place modification : %s\n", b); strrepl(a, "Jack", "Fourchette"); printf("In place modification : %s\n", a); return 0; }
Out of place modification : Hello~~~This~~~Is~~~Jack In place modification : Hello This Is Fourchette
int main () { printf("Hello "); goto Cleanup; Cleanup: char *str = "World\n"; printf("%s\n", str); }
int main () { printf("Hello "); goto Cleanup; Cleanup: ; char *str = "World\n"; printf("%s\n", str); }
int main (void) { char *str; printf("Hello "); goto Cleanup; Cleanup: str = "World\n"; printf("%s\n", str); return 0; }
static const char BLUEZ_SCO_SK_PATH[] = "\0bluez_sco_socket";
struct IAnimal { int (*eat)(int food); int (*sleep)(int secs); }; /* "Subclass"/"implement" IAnimal, relying on C * of memory layouts */ struct Cat { struct IAnimal _base; int (*meow)(void); }; int cat_eat(int food) { ... } int cat_sleep(int secs) { ... } int cat_meow(void) { ... } struct Cat* CreateACat(void) { struct Cat* x = (Cat*) malloc(sizeof (struct Cat)); x->_base.eat = cat_eat; x->_base.sleep = cat_sleep; x->meow = cat_meow; } struct IAnimal* pa = CreateACat(); pa->eat(42); /* Calls cat_eat() */ ((struct Cat*) pa)->meow();
/* These macros are used to mark some functions or * initialized data (doesn * as `initialization * as hint that the function is used only during the initialization * phase and free up used memory resources after * * Usage: * For functions: * * You should add __init immediately before the function name, like: * * static void __init initme(int x, int y) * { * extern int z; z = x * y; * } * * If the function has a prototype somewhere, you can also add * __init between closing brace of the prototype and semicolon: * * extern int initialize_foobar_device(int, int, int) __init; * * For initialized data: * You should insert __initdata between the variable name and equal * sign followed by value, e.g.: * * static int init_variable __initdata = 0; * static const char linux_logo[] __initconst = { 0x32, 0x36, ... }; * * Don * as gcc otherwise puts the data into the bss section and not into the init * section. * * Also note, that this data cannot be "const". */ /* These are for everybody (although not all archs will actually discard it in modules) */
⚡⚡⚡ more test.c int main(int argc, char **argv) { printf("argc = %d\n", argc); printf("Size of argc = %d\n", sizeof(argc)); return 0; }
⚡⚡⚡ ls -h bigfile -rw-r--r-- 1 ehwas ehwas 355M Jan 22 16:54 bigfile
⚡⚡⚡ ls -h notsobigfile -rw-r--r-- 1 ehwas ehwas 6.7M Jan 22 17:04 notsobigfile
⚡⚡⚡ ./test $(more notsobigfile) bash: ./test: Argument list too long
int a = 5; int *b = &a; int *c = &b; int *d = &c; int *e = &d; int *f = &e;
char *cp = 0x1000; short *sp = 0x1000; int *ip = 0x1000; long *lp = 0x1000;
void foo( T *p ) { *p = new_value(); } void bar( void ) { T val; foo( &val ); }
void foo( P **p ) { *p = new_value(); } void bar( void ) { P *val; foo( &val ); }
char c = char* pc = &c; char** ppc = &pc; printf("%c\n", **ppc); printf("%c\n", **pc);
char c = char* pc = &c; char* ppc = &pc; printf("%c\n", **ppc); printf("%c\n", **pc);
..... memory address ...... value ........ type a ... 0x00000002 .......... 5 ............ int b ... 0x00000010 .......... 0x00000002 ... int*
..... memory address ...... value ........ type a ... 0x00000002 .......... 5 ............ int b ... 0x00000010 .......... 0x00000002 ... int* c ... 0x00000020 .......... 0x00000010 ... int**
..... memory address .............. value ................ type a ... 0x0000000000000002 .......... 5 .................... int b ... 0x0000000000000010 .......... 0x0000000000000002 ... int* c ... 0x0000000000000020 .......... 0x0000000000000010 ... int**
void f(int* pi); int main() { int x; int *px = &x; int *ppx = &px; int *pppx = &ppx; f(pppx); } void f(int* pi) { int i = *pi; }
int main() { double *a = (double*) malloc(sizeof(double)*100) printf("%f", *a); }
int main() { int *a = (int*) malloc(sizeof(int)*200000); a[10] = 3; printf("%d", *(a+10)); free(a); a = (double*) malloc(sizeof(double)*200000); printf("%d", *(a+10)); } OUTPUT: 3 0 (initialized)
int main(void) { { double *a = malloc(sizeof(double)*100); *a = 100; printf("%f\n", *a); free(a); } { double *a = malloc(sizeof(double)*100); printf("%f\n", *a); free(a); } return 0; }
int getMax(int a, int b) { int c = a - b; int k = (c >> 31) & 0x1; int max = a - k * c; return max; }
int getMax(int a, int b) { int c = a - b; int k = (c >> 31) & 0x1; int max = a - k * c; return max; }
r = x - ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1)));
int Max(int x, int y) { return (float)(x + y) / 2.0 + abs((float)(x - y) / 2); } int Min(int x, int y) { return (float)(x + y) / 2.0 - abs((float)(x - y) / 2); }
int max(int i, int j) { int m = ((i-j) >> 31); return (m & j) + ((~m) & i); }
int findmax(int a, int b) { int rets[] = {a, b}; return rets[unsigned(a-b)>>BITS]; }
int getMax(int a, int b){ return (a+b+((a-b)>>sizeof(int)*8-1|1)*(a-b))/2; }
max = ( max + max ) / 2 = ( max + (min+differenceOfMaxMin) ) / 2 = ( max + min + differenceOfMaxMin ) / 2 = ( max + min + | max - min | ) ) / 2
absolute(x) = x * ( 1 [if = x * ( ( x >> (numberOfBitsInInteger-1) ) | 1 ) = x * ( ( x >> ((numberOfBytesInInteger*bitsInOneByte) - 1) ) | 1 ) = x * ( ( x >> ((sizeOf(int)*8) - 1) ) | 1 )
getMax(a, b) = ( a + b + absolute(a - b) ) / 2 = ( a + b + ((a-b) * ( ( (a-b) >> ((sizeOf(int)*8) - 1) ) | 1 )) ) / 2
{ int[] arr; arr = new int[3]; arr[0] = b; arr[1] = a; arr[2] = a; return arr[Math.Sign(a - b) + 1]; }
main() { int num1,num2,diff; printf("Enter number 1 : "); scanf("%d",&num1); printf("Enter number 2 : "); scanf("%d",&num2); diff=num1-num2; num1=abs(diff); num2=num1+diff; if(num1==num2) printf("Both number are equal\n"); else if(num2==0) printf("Num2 > Num1\n"); else printf("Num1 > Num2\n"); }
double findmax(double a, double b) { double diff=a-b; double temp_diff=diff; int int_diff=temp_diff; /* For the floating point numbers the difference contains decimal values (for example 0.0009, 2.63 etc.) if the left side of to get a non-zero number on the left side of */ while ( (!(int_diff|0)) && ((temp_diff-int_diff)||(0.0)) ) { temp_diff = temp_diff * 10; int_diff = temp_diff; } /* shift the sign bit of variable 1(difference is -ve) or 0(difference is +ve) , then multiply it with the difference of the two numbers (variable */ return a- (diff * ( int_diff >> (sizeof(int) * 8 - 1 ) & 1 )); }
int max1(int a, int b) { static const size_t SIGN_BIT_SHIFT = sizeof(a) * 8 - 1; int mask = (a - b) >> SIGN_BIT_SHIFT; return (a & ~mask) | (b & mask); }
int max2(int a, int b) { static const size_t SIGN_BIT_SHIFT = sizeof(a) * 8 - 1; int mask = (a - b) >> SIGN_BIT_SHIFT; return a ^ ((a ^ b) & mask); }
c=|a/b|+1; d=(c-1)/b; smallest number= a - d*(a-b);
int a=151; int b=121; int k=Math.abs(a-b); int j= a+b; double k1=(double)(k); double j1= (double) (j); double c=Math.ceil(k1/2) + Math.floor(j1/2); int c1= (int) (c); System.out.println(" Max value = " + c1);
public static int Min(int a, int b) { int dif = (int)(((uint)(a - b)) >> 31); return a * dif + b * (1 - dif); }
21 * 5 = 10101_2 * 101_2 (Initial step) = 10101_2 * (1 * 2^2 + 0 * 2^1 + 1 * 2^0) = 10101_2 * 2^2 + 10101_2 * 2^0 = 10101_2 << 2 + 10101_2 << 0 (Decomposed) = 10101_2 * 4 + 10101_2 * 1 = 10101_2 * 5 = 21 * 5 (Same as initial expression)
int No_divide(int nDivisor, int nDividend, int *nRemainder) { int nQuotient = 0; int nPos = -1; unsigned long long ullDivisor = nDivisor; unsigned long long ullDividend = nDividend; while (ullDivisor < ullDividend) { ullDivisor <<= 1; nPos ++; } ullDivisor >>= 1; while (nPos > -1) { if (ullDividend >= ullDivisor) { nQuotient += (1 << nPos); ullDividend -= ullDivisor; } ullDivisor >>= 1; nPos -= 1; } *nRemainder = (int) ullDividend; return nQuotient; }
uint32_t bitwise_division (uint32_t dividend, uint32_t divisor) { uint32_t quot; __asm { mov eax, [dividend]; mov ecx, [divisor]; mov edx, 32; mov ebx, 0; $div_loop: add eax, eax; adc ebx, ebx; cmp ebx, ecx; jb $quot_bit_is_0; $quot_bit_is_1: sub ebx, ecx; add eax, 1; $quot_bit_is_0: dec edx; jnz $div_loop; mov [quot], eax; } return quot; } uint32_t bitwise_division (uint32_t dividend, uint32_t divisor) { uint32_t quot, rem, t; int bits_left = CHAR_BIT * sizeof (uint32_t); quot = dividend; rem = 0; do { t = quot; quot = quot + quot; rem = rem + rem + (quot < t); if (rem >= divisor) { rem = rem - divisor; quot = quot + 1; } bits_left--; } while (bits_left); return quot; }
int add(int a, int b) { int partialSum, carry; do { partialSum = a ^ b; carry = (a & b) << 1; a = partialSum; b = carry; } while (carry != 0); return partialSum; } int subtract(int a, int b) { return add(a, add(~b, 1)); } int division(int dividend, int divisor) { boolean negative = false; if ((dividend & (1 << 31)) == (1 << 31)) { negative = !negative; dividend = add(~dividend, 1); } if ((divisor & (1 << 31)) == (1 << 31)) { negative = !negative; divisor = add(~divisor, 1); } int quotient = 0; long r; for (int i = 30; i >= 0; i = subtract(i, 1)) { r = (divisor << i); if (r < Integer.MAX_VALUE && r >= 0) { if (r <= dividend) { quotient |= (1 << i); dividend = subtract(dividend, (int) r); } } } if (negative) { quotient = add(~quotient, 1); } return quotient; }
.data .text .globl main main: addi $4, $0, 0x9 addi $5, $0, 0x6 add $2, $0, $0 Loop: beq $5, $0, Exit andi $3, $5, 1 beq $3, $0, Shift addu $2, $2, $4 Shift: sll $4, $4, 1 srl $5, $5, 1 j Loop Exit: # EXIT: li $v0,10 syscall
-(int)binaryDivide:(int)numerator with:(int)denominator { if (numerator == 0 || denominator == 1) { return numerator; } if (denominator == 0) { NSAssert(denominator==0, @"denominator should be greater then 0"); return INFINITY; } int maxBitDenom = [self getMaxBit:denominator]; int maxBitNumerator = [self getMaxBit:numerator]; int msbNumber = [self getMSB:maxBitDenom ofNumber:numerator]; int qoutient = 0; int subResult = 0; int remainingBits = maxBitNumerator-maxBitDenom; if (msbNumber >= denominator) { qoutient |=1; subResult = msbNumber - denominator; } else { subResult = msbNumber; } while (remainingBits > 0) { int msbBit = (numerator & (1 << (remainingBits-1)))>0?1:0; subResult = (subResult << 1) | msbBit; if(subResult >= denominator) { subResult = subResult - denominator; qoutient= (qoutient << 1) | 1; } else{ qoutient = qoutient << 1; } remainingBits--; } return qoutient; } -(int)getMaxBit:(int)inputNumber { int maxBit = 0; BOOL isMaxBitSet = NO; for (int i=0; i<sizeof(inputNumber)*8; i++) { if (inputNumber & (1<<i)) { maxBit = i; isMaxBitSet=YES; } } if (isMaxBitSet) { maxBit+=1; } return maxBit; } -(int)getMSB:(int)bits ofNumber:(int)number { int numbeMaxBit = [self getMaxBit:number]; return number >> (numbeMaxBit - bits); }
-(int)multiplyNumber:(int)num1 withNumber:(int)num2 { int mulResult = 0; int ithBit; BOOL isNegativeSign = (num1<0 && num2>0) || (num1>0 && num2<0); num1 = abs(num1); num2 = abs(num2); for (int i=0; i<sizeof(num2)*8; i++) { ithBit = num2 & (1<<i); if (ithBit>0) { mulResult += (num1 << i); } } if (isNegativeSign) { mulResult = ((~mulResult)+1); } return mulResult; }
softwareMultiply: ; INPUT CX,BX ; OUTPUT DX:AX - 32 bits ; CLOBBERS BX,CX,DI xor ax,ax ; cheap way to zero a reg mov dx,ax ; 1 clock faster than xor mov di,cx or di,bx ; cheap way to test for zero on both regs jz @done mov di,ax ; DI used for reg,reg adc @loop: shr cx,1 ; divide by two, bottom bit moved to carry flag jnc @skipAddToResult add ax,bx adc dx,di ; reg,reg is faster than reg,imm16 @skipAddToResult: add bx,bx ; faster than shift or mul adc di,di or cx,cx ; fast zero check jnz @loop @done: ret
asm("mov $0,%%ax\n\t" "mov $0,%%dx\n\t" "mov %%cx,%%di\n\t" "or %%bx,%%di\n\t" "jz done\n\t" "mov %%ax,%%di\n\t" "loop:\n\t" "shr $1,%%cx\n\t" "jnc skipAddToResult\n\t" "add %%bx,%%ax\n\t" "adc %%di,%%dx\n\t" "skipAddToResult:\n\t" "add %%bx,%%bx\n\t" "adc %%di,%%di\n\t" "or %%cx,%%cx\n\t" "jnz loop\n\t" "done:\n\t" : "=d" (dx), "=a" (ax) : "b" (bx), "c" (cx) : "ecx", "edi" );
import sys def divAndMod_slow(y,x, debug=0): r = 0 while y >= x: r += 1 y -= x return r,y def divAndMod(y,x, debug=0): pos = -1 while y >= x: pos += 1 x <<= 1 x >>= 1 if debug: print "y=%d, x=%d, pos=%d" % (y,x,pos) if pos == -1: return 0, y r = 0 while pos >= 0: if y >= x: r += (1 << pos) y -= x if debug: print "y=%d, x=%d, r=%d, pos=%d" % (y,x,r,pos) x >>= 1 pos -= 1 return r, y if __name__ =="__main__": if len(sys.argv) == 3: y = int(sys.argv[1]) x = int(sys.argv[2]) else: y = 313271356 x = 7 print "=== Slow Version ...." res = divAndMod_slow( y, x) print "%d = %d * %d + %d" % (y, x, res[0], res[1]) print "=== Fast Version ...." res = divAndMod( y, x, debug=1) print "%d = %d * %d + %d" % (y, x, res[0], res[1])
const int a = 10; const int* ptr = &a; *ptr = 5; ptr++;
int main(void) { int a[] = {10,11}; int* const ptr = a; *ptr = 11; printf("\n value at ptr is : [%d]\n",*ptr); printf("\n Address pointed by ptr : [%p]\n",(unsigned int*)ptr); ptr++; printf("\n Address pointed by ptr : [%p]\n",(unsigned int*)ptr); return 0; }
practice constant_pointer.c: In function ‘main’: constant_pointer.c:13: error: increment of read-only variable ‘ptr’
int main(void) { int a = 10; const int* ptr = &a; printf("\n value at ptr is : [%d]\n",*ptr); printf("\n Address pointed by ptr : [%p]\n",(unsigned int*)ptr); *ptr = 11; return 0; }
practice pointer_to_constant.c: In function ‘main’: pointer_to_constant.c:12: error: assignment of read-only location ‘*ptr’
int main(void) { int var1 = 0, var2 = 0; int *const ptr = &var1; ptr = &var2; printf("%d\n", *ptr); return 0; }
int main(void) { int var1 = 0; const int* ptr = &var1; *ptr = 1; printf("%d\n", *ptr); return 0; }
i = 4; printf("before: %d\n", *ptr2); i = 5; printf("after: %d\n", *ptr2); *ptr2 = 6;
ProcessIntenseFunction(); printf("Time taken %d seconds %d milliseconds", sec, msec);
clock_t start = clock(), diff; ProcessIntenseFunction(); diff = clock() - start; int msec = diff * 1000 / CLOCKS_PER_SEC; printf("Time taken %d seconds %d milliseconds", msec/1000, msec%1000);
inline uint64_t rdtsc() { uint32_t lo, hi; __asm__ __volatile__ ( "xorl %%eax, %%eax\n" "cpuid\n" "rdtsc\n" : "=a" (lo), "=d" (hi) : : "%ebx", "%ecx"); return (uint64_t)hi << 32 | lo; } main() { unsigned long long x; unsigned long long y; x = rdtsc(); printf("%lld\n",x); y = rdtsc(); printf("%lld\n",y); printf("it took this long to call printf: %lld\n",y-x); }
PERFTIME(ProcessIntenseFunction()); or PERFTIME_INIT PERFTIME_START ProcessIntenseFunction() PERFTIME_END
int timeval_subtract(struct timeval *result, struct timeval end, struct timeval start) { if (start.tv_usec < end.tv_usec) { int nsec = (end.tv_usec - start.tv_usec) / 1000000 + 1; end.tv_usec -= 1000000 * nsec; end.tv_sec += nsec; } if (start.tv_usec - end.tv_usec > 1000000) { int nsec = (end.tv_usec - start.tv_usec) / 1000000; end.tv_usec += 1000000 * nsec; end.tv_sec -= nsec; } result->tv_sec = end.tv_sec - start.tv_sec; result->tv_usec = end.tv_usec - start.tv_usec; return end.tv_sec < start.tv_sec; } void set_exec_time(int end) { static struct timeval time_start; struct timeval time_end; struct timeval time_diff; if (end) { gettimeofday(&time_end, NULL); if (timeval_subtract(&time_diff, time_end, time_start) == 0) { if (end == 1) printf("\nexec time: %1.2fs\n", time_diff.tv_sec + (time_diff.tv_usec / 1000000.0f)); else if (end == 2) printf("%1.2fs", time_diff.tv_sec + (time_diff.tv_usec / 1000000.0f)); } return; } gettimeofday(&time_start, NULL); } void start_exec_timer() { set_exec_time(0); } void print_exec_timer() { set_exec_time(1); }
void f(void) { void g(void); g(); } void g(void) { }
int main(void) { int customerArray[3][3] = {{1, 1000, 600}, {2, 5000, 2500}, {3, 10000, 2000}}; int x, y; char inquiry; void displayAccounts(void) { puts("\t\tBank Of Despair\n\nCustomer List:\n--------------"); puts("Account for(x = 0; x <= 2; x++) { for(y = 0; y <= 2; y++) printf("%9d\t", customerArray[x][y]); puts("\n"); } } displayAccounts(); printf("Is there currently a recession (y or n)? "); return 0; }
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400340
void nomain() { printf("Hello World...\n"); printf("Successfully run without main...\n"); }
.LC0: .string "Hello World..." .LC1: .string "Successfully run without main..." nomain: push rbp mov rbp, rsp mov edi, OFFSET FLAT:.LC0 call puts mov edi, OFFSET FLAT:.LC1 call puts nop pop rbp ret
_Noreturn void nomain(void) { printf("Hello World...\n"); printf("Successfully run without main...\n"); exit(0); }
struct stat st = {0}; if (stat("/some/directory", &st) == -1) { mkdir("/some/directory", 0700); }
void rek_mkdir(char *path) { char *sep = strrchr(path, if(sep != NULL) { *sep = 0; rek_mkdir(path); *sep = } if( mkdir(path,0777) && errno != EEXIST ) printf("error while trying to create } FILE *fopen_mkdir( char *path, char *mode ) { char *sep = strrchr(path, if(sep ) { char *path0 = strdup(path); path0[ sep - path ] = 0; rek_mkdir(path0); free(path0); } return fopen(path,mode); }
int main() { enum Days{Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday}; Days TheDay; int j = 0; printf("Please enter the day of the week (0 to 6)\n"); scanf("%d",&j); TheDay = Days(j); printf("%s",TheDay); return 0; }
const char* getDayName(enum Days day) { switch (day) { case Sunday: return "Sunday"; case Monday: return "Monday"; } } printf("%s", getDayName(TheDay));
const char* dayNames[] = {"Sunday", "Monday", "Tuesday", }; printf("%s", dayNames[TheDay]);
BEGIN_ENUM(Days) { DECL_ENUM_ELEMENT(Sunday) DECL_ENUM_ELEMENT(Monday) DECL_ENUM_ELEMENT_STR(Tuesday, "Tuesday string") DECL_ENUM_ELEMENT(Wednesday) DECL_ENUM_ELEMENT_VAL_STR(Thursday, 500, "Thursday string") } END_ENUM(MyEnum)
int main(int argc, char* argv[]) { Days TheDay = Monday; printf( "%d - %s\n", TheDay, GetStringDay(TheDay) ); TheDay = Thursday; printf( "%d - %s\n", TheDay, GetStringDay(TheDay) ); return 0; }
const char *DayNames[] = { "Sunday", "Monday", "Tuesday", }; printf("%s", DayNames[Sunday]);
int main() { enum Days{Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday}; Days TheDay = Monday; }
X(Sunday) S X(Monday) S X(Tuesday) S X(Wednesday) S X(Thursday) S X(Friday) S X(Saturday) enum dow { DOW(DOW_ENUM, COMMA) }; const char * const dow_str[] = { DOW(DOW_ARR, COMMA) }; static const char * dowstr(int i) { switch(i) { DOW(DOW_CASE, ;); default: return NULL; } } int main(void) { for(int i = 0; i < 7; i++) printf("[%d] = «%s»\n", i, dow_str[i]); printf("\n"); for(int i = 0; i < 7; i++) printf("[%d] = «%s»\n", i, dowstr(i)); return 0; }
const char* dayNames[] = { [Sunday] = "Sunday", [Monday] = "Monday", }; printf("%s", dayNames[Sunday]);
enum mycolor; int main(int argc, const char * argv[]) { enum Days{Sunday=1,Monday=2,Tuesday=3,Wednesday=4,Thursday=5,Friday=6,Saturday=7}; enum Days TheDay; printf("Please enter the day of the week (0 to 6)\n"); scanf("%d",&TheDay); switch (TheDay) { case Sunday: printf("the selected day is sunday"); break; case Monday: printf("the selected day is monday"); break; case Tuesday: printf("the selected day is Tuesday"); break; case Wednesday: printf("the selected day is Wednesday"); break; case Thursday: printf("the selected day is thursday"); break; case Friday: printf("the selected day is friday"); break; case Saturday: printf("the selected day is Saturaday"); break; default: break; } return 0; }
const char* dayNames[] = { EP(Sunday), EP(Monday)};
static_assert(sizeof(someThing) == PAGE_SIZE, "Data structure doesn
extern char __CHECK__[1/!(<<EXPRESSION THAT SHOULD COME TO ZERO>>)];
typedef char p__LINE__[ (sizeof(PARS) == 4184) ? 1 : -1]; typedef char p__LINE__[ ((sizeof(PARS) % 8) == 0) ? 1 : 1]; typedef char p__LINE__[ (offsetof(PARS, SUB_PARS) == 912) ? 1 : -1];
/* * Simple compile time assertion. * Example: CT_ASSERT(sizeof foo <= 16, foo_can_not_exceed_16_bytes); */ struct compile_time_assertion { \ char message_identifier : 8 + !(exp); \ }
static union { char int8_t_incorrect[sizeof( int8_t) == 1 ? 1: -1]; char uint8_t_incorrect[sizeof( uint8_t) == 1 ? 1: -1]; char int16_t_incorrect[sizeof( int16_t) == 2 ? 1: -1]; char uint16_t_incorrect[sizeof(uint16_t) == 2 ? 1: -1]; char int32_t_incorrect[sizeof( int32_t) == 4 ? 1: -1]; char uint32_t_incorrect[sizeof(uint32_t) == 4 ? 1: -1]; };
_Static_assert(sizeof(someThing) == PAGE_SIZE, "Data structure doesn
elem_t n; if (compiler_size(elem_t) == sizeof(int)) { printf("%d",(int)n); } else { printf("%lf",(double)n); }
typedef short INT16; typedef int INT32; typedef long INT64;
typedef signed char int8_t; typedef signed short int16_t; typedef signed int int32_t; typedef unsigned char uint8_t;
... 08048394 <main>: 8048394: 55 push %ebp 8048395: 89 e5 mov %esp,%ebp 8048397: 83 ec 10 sub $0x10,%esp 804839a: c7 45 fc 00 00 00 00 movl $0x0,-0x4(%ebp) 80483a1: 83 45 fc 01 addl $0x1,-0x4(%ebp) 80483a5: b8 00 00 00 00 mov $0x0,%eax 80483aa: c9 leave 80483ab: c3 ret 80483ac: 90 nop 80483ad: 90 nop 80483ae: 90 nop 80483af: 90 nop ...
int f(void) { return 0; } int g(void) { return 0; }
align.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 <f>: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: b8 00 00 00 00 mov $0x0,%eax 9: c9 leaveq a: c3 retq 000000000000000b <g>: b: 55 push %rbp c: 48 89 e5 mov %rsp,%rbp f: b8 00 00 00 00 mov $0x0,%eax 14: c9 leaveq 15: c3 retq
align.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 <f>: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: b8 00 00 00 00 mov $0x0,%eax 9: c9 leaveq a: c3 retq b: eb 03 jmp 10 <g> d: 90 nop e: 90 nop f: 90 nop 0000000000000010 <g>: 10: 55 push %rbp 11: 48 89 e5 mov %rsp,%rbp 14: b8 00 00 00 00 mov $0x0,%eax 19: c9 leaveq 1a: c3 retq
6 * 16^3 + 11 * 16^2 + 15 * 16^1 = 27632 24576 + 2816 + 240 = 27632
0x6400 = (0*1) + (0*16^1) + (4*16^2) + (6*16^3) = 25600
0x6400 = (0*1) + (0*16) + (4*256) + (6*4096) = 25600
/* item one is a parameter and it comes in as: const void* item1 */ const Emp* emp1 = (const Emp*) item1; printf("\n comp1-> emp1 = %p; item1 = %p \n", emp1, item1 );
printf("%p", (void *)emp1); printf("%p", (void *)*emp1);
printf("a points at this memory location: %p", a); printf("which points at this other memory location: %p", *a);
char c = printf("ptr: %p,\t value: %c,\t and also address: %zu",&c, c,&c);
struct arg_struct { int arg1; int arg2; }; void *print_the_arguments(void *arguments) { struct arg_struct *args = (struct arg_struct *)args; printf("%d\n", args -> arg1); printf("%d\n", args -> arg2); pthread_exit(NULL); return NULL; } int main() { pthread_t some_thread; struct arg_struct args; args.arg1 = 5; args.arg2 = 7; if (pthread_create(&some_thread, NULL, &print_the_arguments, (void *)&args) != 0) { printf("Uh-oh!\n"); return -1; } return pthread_join(some_thread, NULL); }
struct arg_struct *args = (struct arg_struct *)arguments;
struct arg_struct *args = (struct arg_struct *)args;
struct arg_struct *args = malloc(sizeof(struct arg_struct));
pthread_create(&tr, NULL, print_the_arguments, (void *)args);
struct arg_struct *args = (struct arg_struct *)arguments.
view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
enum DownloadViewStatus { FileNotDownloaded, FileDownloading, FileDownloaded };
for (UIView *subview in self.subviews) { if (subview.tag == viewStatus) subview.hidden = NO; else subview.hidden = YES; }
typedef enum : NSUInteger { FileNotDownloaded = (1 << 0), FileDownloading = (1 << 1), FileDownloaded = (1 << 2) } DownloadViewStatus;
typedef NS_OPTIONS(NSUInteger, DownloadViewStatus) { FileNotDownloaded = (1 << 0), FileDownloading = (1 << 1), FileDownloaded = (1 << 2) };
DownloadViewStatus status = FileNotDownloaded | FileDownloaded;
DownloadViewStatus status = FileNotDownloaded | FileDownloaded;
BOOL contains = (status & FileNotDownloaded) != 0; 00000101 & 00000100 ----------- = 00000100 != 00000000 ----------- = 00000001
typedef NS_OPTIONS(NSUInteger, DownloadViewStatus) { FileNotDownloaded = 0, FileDownloading = 1 << 0, FileDownloaded = 1 << 1 };
enum DownloadViewStatus { FileNotDownloaded = 1, FileDownloading = 2, FileDowloaded = 4 };
bool dobreak = false; for ( ..; !dobreak && ..; .. ) { for ( ... ) { if (...) { dobreak = true; break; } } }
for (;;) { for (;;) { break; } for (;;) { goto outer; } } outer:;
void do_lots_of_work(void) { int i, j; for(i=0; i<10 ; i++) { for(j=0;j< 10; j++) { .. .. if(disaster_struck()) return; } } }
@try { for() { for() { @throw ... } } } @catch{ ... }
for (int i = 0; i < 10; i++) { if (timeToStop(i)) break; } -(bool) timeToStop: (int) i { for (int j = 0; j < 10; j++) { if (somethingBadHappens) return true; } return false; }
bool isTerminated = false; for (...) { if (!isTerminated) { for(...) { ... isTerminated = true; break; } } else { break; } }
for(i=0; i<10 ; i++) for(j=0;j< 10; j++){ .. .. i = 10; break; }
for(i=0; i<10 && (done==false); i++) for(j=0;j< 10; j++){ .. .. if(...){done=true; break;} }
int i; for(i=0; i<10 ; i++){ if !innerLoop(i) { break; } } bool innerLoop(int i) int j; for(j=0;j< 10; j++){ doSomthing(i,j); if(endcondtion){ return false; } } }
for(i=0;i<a;i++){ for(j=0;j<a;j++){ if(Something_goes_wrong){ i=a; break; } } }
- (bool) checkTrueFalse: parameters{ for ( ...) { for ( ... ) { if (...) { return true; } } } return false; }
static void utility() { } static void a_func() { utility(); } static void b_func() { utility(); }
printf("%zd\n", sizeof( (char) printf("%zd\n", sizeof(+(char)
int main(void) { char ch; short sh; int i; long l; printf("%d %d %d %d\n",sizeof(ch),sizeof(sh),sizeof(i),sizeof(l)); printf("%d %d %d %d\n",sizeof(+ch),sizeof(+sh),sizeof(+i),sizeof(+l)); return 0; }
unsigned int const volatile *status_reg; unsigned char const volatile *recv_reg; int get_next_char() { while ((*status_reg & UART_CHAR_READY) == 0) { } return *recv_reg; }
const volatile char *port = (const volatile char *)0x30;
char* func() { char str[10]; strcpy(str,"Hello!"); return(str); }
int *call(); void main(){ int *ptr; ptr=call(); fflush(stdin); printf("%d",*ptr); } int * call(){ int x=25; ++x; return &x; }
char *myarea=(char *)malloc(10); char *newarea=(char *)malloc(10); myarea=newarea;
void main() { int *ptr = (int *)malloc(sizeof(int)); free(ptr); }
char *foo( int rc ) { switch (rc) { case 1: return("one"); case 2: return("two"); default: return("whatever"); } }
int main() { char *str1 = "string Literal"; const char *str2 = "string Literal"; char source[]="Sample string"; strcpy(str1,source); strcpy(str2,source); return 0; }
prog.c:3: error: lvalue required as unary ‘&’ operand
/* * This program displays the names of all files in the current directory. */ int main(void) { DIR *d; struct dirent *dir; d = opendir("."); if (d) { while ((dir = readdir(d)) != NULL) { printf("%s\n", dir->d_name); } closedir(d); } return(0); }
if (dir->d_type == DT_REG) { printf("%s\n", dir->d_name); }
void show_dir_content(char * path) { DIR * d = opendir(path); if(d==NULL) return; struct dirent * dir; while ((dir = readdir(d)) != NULL) { if(dir-> d_type != DT_DIR) printf("%s%s\n",BLUE, dir->d_name); else if(dir -> d_type == DT_DIR && strcmp(dir->d_name,".")!=0 && strcmp(dir->d_name,"..")!=0 ) { printf("%s%s\n",GREEN, dir->d_name); char d_path[255]; sprintf(d_path, "%s/%s", path, dir->d_name); show_dir_content(d_path); } } closedir(d); } int main(int argc, char **argv) { printf("%s\n", NORMAL_COLOR); show_dir_content(argv[1]); printf("%s\n", NORMAL_COLOR); return(0); }
switch (something) { case 0: return "blah"; break; case 1: case 4: return "foo"; break; case 2: case 3: return "bar"; break; default: return "foobar"; break; }
String result = ""; switch (something) { case 0: result = "blah"; break; case 1: result = "foo"; break; } return result;
char const *rets[] = {"blah", "foo", "bar"}; return rets[something];
char const *rets[] = { "blah", "foo", "bar", "bar", "foo"}; if ((unsigned)something < 5) return rets[something] return "foobar";
LRESULT WindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_SIZE: return sizeHandler (...); case WM_DESTROY: return destroyHandler (...); ... } return DefWindowProc(hwnd, uMsg, wParam, lParam); }
Switch ( Algorithm ) { case 1: { Call_911; Jump; }**break**; case 2: { Call Samantha_28; Forget; }**break**; case 3: { Call it_a_day; }**break**; Return thinkAboutIt?1:return 0; void Samantha_28(int oBed) { LONG way_from_right; SHORT Forget_is_my_job; LONG JMP_is_for_assembly; LONG assembly_I_work_for_cops; BOOL allOfTheAbove; int Elligence_says_anyways_thinkAboutIt_**break**_if_we_code_like_this_we_d_be_monkeys; }
private int basePerCapitaIncomeRaw(int tl) { switch (tl) { case 0: return 7500; case 1: return 7800; case 2: return 8100; case 3: return 8400; case 4: return 9600; case 5: return 13000; case 6: return 19000; case 7: return 25000; case 8: return 31000; case 9: return 43000; case 10: return 67000; case 11: return 97000; default: return 130000; } }
int array[width * height]; int SetElement(int row, int col, int value) { array[width * row + col] = value; }
void set_array( int x, int y, int val ) { array[ x * SIZE_Y + y ] = val; }
int get_array( int x, int y ) { return array[ x * SIZE_Y + y ]; }
int main(int argc, char **argv) { int i, j, k; int arr[5][3]; int *arr2 = (int*)arr; for (k=0; k<15; k++) { arr2[k] = k; printf("arr[%d] = %2d\n", k, arr2[k]); } for (i=0; i<5; i++) { for (j=0; j< 3; j++) { printf("arr2[%d][%d] = %2d\n", i, j ,arr[i][j]); } } }
arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 arr[4] = 4 arr[5] = 5 arr[6] = 6 arr[7] = 7 arr[8] = 8 arr[9] = 9 arr[10] = 10 arr[11] = 11 arr[12] = 12 arr[13] = 13 arr[14] = 14 arr2[0][0] = 0 arr2[0][1] = 1 arr2[0][2] = 2 arr2[1][0] = 3 arr2[1][1] = 4 arr2[1][2] = 5 arr2[2][0] = 6 arr2[2][1] = 7 arr2[2][2] = 8 arr2[3][0] = 9 arr2[3][1] = 10 arr2[3][2] = 11 arr2[4][0] = 12 arr2[4][1] = 13 arr2[4][2] = 14
A(i,j) = a[i + j*ld]; double *A = ...; size_t ld = ...; A(i,j) = ...; ... = A(j,i);
void die(const char *message) { if(errno) { perror(message); } else { printf("ERROR: %s\n", message); } exit(1); }
void cleanup(void){ if (fp) fclose(fp); if (ptr) free(ptr); } int main(int argc, char **argv){ atexit(cleanup); return 0; }
unsigned char cbShowDataThenExit( unsigned char *data, unsigned short dataSz,unsigned char status) { printf("cbShowDataThenExit with status %X (dataSz %d)\n", status, dataSz); printf("status:%d\n",status); printArray(data,dataSz); cleanUp(); exit(0); }
struct s { int a; }; struct z { int a; struct s b[]; }; int main(void) { return 0; }
length = strlen(my_string); foo = malloc(sizeof(MYSTRUCTURE) + length + 1); foo->name = (void *)foo + sizeof(MYSTRUCTURE); memcpy(foo->name, my_string, length + 1);
struct s1 { int a; short b; char c; }; struct s2 { char c; short b; int a; };
struct s2 { char c; char pad1; short b; short pad2; short pad3; int a; };
struct s { int a; } struct z { struct s b[10]; int a; } int main(void) { return 0; }
static int alarm_fired = 0; void ding(int sig) { alarm_fired = 1; } int main() { pid_t pid; printf("alarm application starting\n"); pid = fork(); switch(pid) { case -1: perror("fork failed"); exit(1); case 0: sleep(5); kill(getppid(), SIGALRM); exit(0); } printf("waiting for alarm to go off\n"); (void) signal(SIGALRM, ding); pause(); if (alarm_fired) printf("Ding!\n"); printf("done\n"); exit(0); }
_Exit() fexecve() posix_trace_event() sigprocmask() _exit() fork() pselect() sigqueue() … fcntl() pipe() sigpause() write() fdatasync() poll() sigpending()
_Exit() getppid() sendmsg() tcgetpgrp() _exit() getsockname() sendto() tcsendbreak() abort() getsockopt() setgid() tcsetattr() accept() getuid() setpgid() tcsetpgrp() access() htonl() setsid() time() aio_error() htons() setsockopt() timer_getoverrun() aio_return() kill() setuid() timer_gettime() aio_suspend() link() shutdown() timer_settime() alarm() linkat() sigaction() times() bind() listen() sigaddset() umask() cfgetispeed() longjmp() sigdelset() uname() cfgetospeed() lseek() sigemptyset() unlink() cfsetispeed() lstat() sigfillset() unlinkat() cfsetospeed() memccpy() sigismember() utime() chdir() memchr() siglongjmp() utimensat() chmod() memcmp() signal() utimes() chown() memcpy() sigpause() wait() clock_gettime() memmove() sigpending() waitpid() close() memset() sigprocmask() wcpcpy() connect() mkdir() sigqueue() wcpncpy() creat() mkdirat() sigset() wcscat() dup() mkfifo() sigsuspend() wcschr() dup2() mkfifoat() sleep() wcscmp() execl() mknod() sockatmark() wcscpy() execle() mknodat() socket() wcscspn() execv() ntohl() socketpair() wcslen() execve() ntohs() stat() wcsncat() faccessat() open() stpcpy() wcsncmp() fchdir() openat() stpncpy() wcsncpy() fchmod() pause() strcat() wcsnlen() fchmodat() pipe() strchr() wcspbrk() fchown() poll() strcmp() wcsrchr() fchownat() posix_trace_event() strcpy() wcsspn() fcntl() pselect() strcspn() wcsstr() fdatasync() pthread_kill() strlen() wcstok() fexecve() pthread_self() strncat() wmemchr() ffs() pthread_sigmask() strncmp() wmemcmp() fork() raise() strncpy() wmemcpy() fstat() read() strnlen() wmemmove() fstatat() readlink() strpbrk() wmemset() fsync() readlinkat() strrchr() write() ftruncate() recv() strspn() futimens() recvfrom() strstr() getegid() recvmsg() strtok_r() geteuid() rename() symlink() getgid() renameat() symlinkat() getgroups() rmdir() tcdrain() getpeername() select() tcflow() getpgrp() sem_post() tcflush() getpid() send() tcgetattr()
static int sigPipe[2]; static void gotSig ( int num ) { write(sigPipe[1], "!", 1); } int main ( void ) { pipe(sigPipe); /* use sigaction to point signal(s) at gotSig() */ FD_SET(sigPipe[0], &readFDs); for (;;) { n = select(nFDs, &readFDs, ...); if (FD_ISSET(sigPipe[0], &readFDs)) { read(sigPipe[0], ch, 1); } } }
/* Calculate the minimal buffer size for a given type. * * Here we overestimate and reserve 8 chars per byte. * * With this size we could even print a binary string. * * - +1 for NULL terminator * - +1 for * * A tight limit for base 10 can be found at: * https: * * TODO: get tight limits for all bases, possibly by looking into * glibc */ /* async-signal-safe implementation of integer to string conversion. * * Null terminates the output string. * * The input buffer size must be large enough to contain the output, * the caller must calculate it properly. * * @param[out] value Input integer value to convert. * @param[out] result Buffer to output to. * @param[in] base Base to convert to. * @return Pointer to the end of the written string. */ char *itoa_safe(intmax_t value, char *result, int base) { intmax_t tmp_value; char *ptr, *ptr2, tmp_char; if (base < 2 || base > 36) { return NULL; } ptr = result; do { tmp_value = value; value /= base; *ptr++ = "ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[35 + (tmp_value - value * base)]; } while (value); if (tmp_value < 0) *ptr++ = ptr2 = result; result = ptr; *ptr-- = while (ptr2 < ptr) { tmp_char = *ptr; *ptr--= *ptr2; *ptr2++ = tmp_char; } return result; } volatile sig_atomic_t global = 0; void signal_handler(int sig) { char key_str[] = "count, sigid: "; /* This is exact: * - the null after the first int will contain the space * - the null after the second int will contain the newline */ char buf[2 * ITOA_SAFE_STRLEN(sig_atomic_t) + sizeof(key_str)]; enum { base = 10 }; char *end; end = buf; strcpy(end, key_str); end += sizeof(key_str); end = itoa_safe(global, end, base); *end++ = end = itoa_safe(sig, end, base); *end++ = write(STDOUT_FILENO, buf, end - buf); global += 1; signal(sig, signal_handler); } int main(int argc, char **argv) { { typedef struct { intmax_t n; int base; char out[1024]; } InOut; char result[1024]; size_t i; InOut io; InOut ios[] = { {0, 10, "0"}, {1, 10, "1"}, {9, 10, "9"}, {10, 10, "10"}, {100, 10, "100"}, {-1, 10, "-1"}, {-9, 10, "-9"}, {-10, 10, "-10"}, {-100, 10, "-100"}, {0, 2, "0"}, {1, 2, "1"}, {10, 2, "1010"}, {100, 2, "1100100"}, {-1, 2, "-1"}, {-100, 2, "-1100100"}, {0, 35, "0"}, {1, 35, "1"}, {34, 35, "Y"}, {35, 35, "10"}, {100, 35, "2U"}, {-1, 35, "-1"}, {-34, 35, "-Y"}, {-35, 35, "-10"}, {-100, 35, "-2U"}, }; for (i = 0; i < sizeof(ios)/sizeof(ios[0]); ++i) { io = ios[i]; itoa_safe(io.n, result, io.base); if (strcmp(result, io.out)) { printf("%ju %d %s\n", io.n, io.base, io.out); assert(0); } } } if (argc > 1 && !strcmp(argv[1], "1")) { signal(SIGINT, signal_handler); while(1); } return EXIT_SUCCESS; }
^Ccount, sigid: 0 2 ^Ccount, sigid: 1 2 ^Ccount, sigid: 2 2 ^Ccount, sigid: 3 2 ^Ccount, sigid: 4 2 ^Ccount, sigid: 5 2 ^Ccount, sigid: 6 2 ^Ccount, sigid: 7 2 ^Ccount, sigid: 8 2 ^Ccount, sigid: 9 2 ^Ccount, sigid: 10 2 ^Ccount, sigid: 11 2 ^Ccount, sigid: 12 2 ^Ccount, sigid: 13 2 ^Ccount, sigid: 14 2
int main(void) { unsigned int a; printf("%u %u\n", a^a, a-a); return 0; }
struct q { uint16_t x,y; }; volatile uint16_t zz; int32_t foo(uint32_t x, uint32_t y) { struct q temp1,temp2; temp1.x = 3; if (y & 1) temp1.y = zz; memmove(&temp2,&temp1,sizeof temp1); return temp2.y; }
# # TARGET = projectname CC = gcc -std=c99 -c CFLAGS = -Wall -I. LINKER = gcc -o LFLAGS = -Wall SOURCES := $(wildcard *.c) INCLUDES := $(wildcard *.h) OBJECTS := $(SOURCES:.c=*.o) rm = rm -f $(TARGET): obj @$(LINKER) $(TARGET) $(LFLAGS) $(OBJECTS) @echo "Linking complete!" obj: $(SOURCES) $(INCLUDES) @$(CC) $(CFLAGS) $(SOURCES) @echo "Compilation complete!" clean: @$(rm) $(TARGET) $(OBJECTS) @echo "Cleanup complete!"
./ ./Makefile ./src/*.c;*.h ./obj/*.o ./bin/<executable>
# # TARGET = projectname CC = gcc CFLAGS = -std=c99 -Wall -I. LINKER = gcc LFLAGS = -Wall -I. -lm SRCDIR = src OBJDIR = obj BINDIR = bin SOURCES := $(wildcard $(SRCDIR)/*.c) INCLUDES := $(wildcard $(SRCDIR)/*.h) OBJECTS := $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o) rm = rm -f $(BINDIR)/$(TARGET): $(OBJECTS) @$(LINKER) $(OBJECTS) $(LFLAGS) -o $@ @echo "Linking complete!" $(OBJECTS): $(OBJDIR)/%.o : $(SRCDIR)/%.c @$(CC) $(CFLAGS) -c $< -o $@ @echo "Compiled "$<" successfully!" .PHONY: clean clean: @$(rm) $(OBJECTS) @echo "Cleanup complete!" .PHONY: remove remove: clean @$(rm) $(BINDIR)/$(TARGET) @echo "Executable removed!"
OBJECTS := $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o) $(OBJECTS): $(OBJDIR)/%.o : $(SRCDIR)/%.c $(CC) $(CFLAGS) -c $< -o $@ @echo "Compiled "$<" successfully!"
$(BINDIR)/$(TARGET): $(OBJECTS) $(LINKER) $@ $(LFLAGS) $(OBJECTS) @echo "Linking complete!"
CFLAGS = -Wall -I./src TARGETPATH = ./bin $(TARGET): obj @$(LINKER) $(TARGETPATH)/$(TARGET) $(LFLAGS) $(OBJECTS) @echo "Linking complete!"
CFLAGS= -g -Wall -O3 OBJDIR= ./obj SRCS=$(wildcard *.c) OBJS=$(SRCS:.c=.o ) all:$(OBJS) %.o: %.c $(CC) $(CFLAGS) -c $< -o $(OBJDIR)/$@
int function () { if (!somecondition) return false; internalStructure *str1; internalStructure *str2; char *dataPointer; float xyz; }
int foo() { int x; return 5; } int bar() { int x; int y; return 5; }
foo: push ebp mov ebp, esp sub esp, 8 ; 1. this is the first line which is different between the two mov eax, 5 ; this is how we return the value add esp, 8 ; 2. this is the second line which is different between the two ret bar: push ebp mov ebp, esp sub esp, 16 ; 1. this is the first line which is different between the two mov eax, 5 ; this is how we return the value add esp, 16 ; 2. this is the second line which is different between the two ret
int function () { { sometype foo; bool somecondition; if (!somecondition) return false; } internalStructure *str1; internalStructure *str2; char *dataPointer; float xyz; }
int function_unchecked(); int function () { if (!someGlobalValue) return false; return function_unchecked(); } int function_unchecked() { internalStructure *str1; internalStructure *str2; char *dataPointer; float xyz; }
int function(int a, int b) { int x, y, z, t; if(a == 2) { return 15; } x = 1; y = 2; z = 3; t = 4; return x + y + z + t + a + b; }
function(int, int): push rbp mov rbp, rsp mov DWORD PTR [rbp-20], edi mov DWORD PTR [rbp-24], esi cmp DWORD PTR [rbp-20], 2 jne .L2 mov eax, 15 jmp .L3 .L2: -- snip -- .L3: pop rbp ret
int function(int a, int b) { if(a == 2) { return 15; } return a + b; }
function(int, int): push rbp mov rbp, rsp mov DWORD PTR [rbp-4], edi mov DWORD PTR [rbp-8], esi cmp DWORD PTR [rbp-4], 2 jne .L2 mov eax, 15 jmp .L3 .L2: mov edx, DWORD PTR [rbp-4] mov eax, DWORD PTR [rbp-8] add eax, edx .L3: pop rbp ret
time_t now; struct tm *mytime = localtime(&now); if ( strftime(buffer, sizeof buffer, "%X", mytime) ) { printf("time1 = \"%s\"\n", buffer); }
int main () { time_t rawtime; struct tm * timeinfo; time ( &rawtime ); timeinfo = localtime ( &rawtime ); printf ( "Current local time and date: %s", asctime (timeinfo) ); return 0; }
int main(void) { time_t mytime = time(NULL); char * time_str = ctime(&mytime); time_str[strlen(time_str)-1] = printf("Current Time : %s\n", time_str); return 0; }
void format_time(char *output){ time_t rawtime; struct tm * timeinfo; time ( &rawtime ); timeinfo = localtime ( &rawtime ); sprintf(output, "[%d %d %d %d:%d:%d]",timeinfo->tm_mday, timeinfo->tm_mon + 1, timeinfo->tm_year + 1900, timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec); }
void main() { time_t t; time(&t); printf("\n current time is : %s",ctime(&t)); }
time_t my_time; struct tm * timeinfo; time (&my_time); timeinfo = localtime (&my_time); CCLog("year->%d",timeinfo->tm_year+1900); CCLog("month->%d",timeinfo->tm_mon+1); CCLog("date->%d",timeinfo->tm_mday); CCLog("hour->%d",timeinfo->tm_hour); CCLog("minutes->%d",timeinfo->tm_min); CCLog("seconds->%d",timeinfo->tm_sec);
void main() { time_t t; time(&t); clrscr(); printf("Today getch(); }
int main() { FILE *fp; char hc1,hc2,mc1,mc2; int hi1,hi2,mi1,mi2,hour,minute; system("echo %time% >time.txt"); fp=fopen("time.txt","r"); if(fp==NULL) exit(1) ; hc1=fgetc(fp); hc2=fgetc(fp); fgetc(fp); mc1=fgetc(fp); mc2=fgetc(fp); fclose(fp); remove("time.txt"); hi1=hc1; hi2=hc2; mi1=mc1; mi2=mc2; hi1-=48; hi2-=48; mi1-=48; mi2-=48; hour=hi1*10+hi2; minute=mi1*10+mi2; printf("Current time is %d:%d\n",hour,minute); return 0; }
typedef struct { double r; double g; double b; } rgb; typedef struct { double h; double s; double v; } hsv; rgb hsv2rgb(hsv HSV) { rgb RGB; double H = HSV.h, S = HSV.s, V = HSV.v, P, Q, T, fract; (H == 360.)?(H = 0.):(H /= 60.); fract = H - floor(H); P = V*(1. - S); Q = V*(1. - S*fract); T = V*(1. - S*(1. - fract)); if (0. <= H && H < 1.) RGB = (rgb){.r = V, .g = T, .b = P}; else if (1. <= H && H < 2.) RGB = (rgb){.r = Q, .g = V, .b = P}; else if (2. <= H && H < 3.) RGB = (rgb){.r = P, .g = V, .b = T}; else if (3. <= H && H < 4.) RGB = (rgb){.r = P, .g = Q, .b = V}; else if (4. <= H && H < 5.) RGB = (rgb){.r = T, .g = P, .b = V}; else if (5. <= H && H < 6.) RGB = (rgb){.r = V, .g = P, .b = Q}; else RGB = (rgb){.r = 0., .g = 0., .b = 0.}; return RGB; }
gcc -g main.c utmpib2.c -o main.o and: cc -g main.c utmpib2.c -o main.o and also: g++ -g main.c utmpib2.c -o main.o
(gdb)exec-file main.o (gdb)break 59 No symbol table is loaded. Use the "file" command.
(gdb) exec-file test (gdb) b 2 No symbol table is loaded. Use the "file" command. (gdb) file test Reading symbols from /home/user/test/test...done. (gdb) b 2 Breakpoint 1 at 0x80483ea: file test.c, line 2. (gdb)
$ gdb test GNU gdb (GDB) 7.4 Copyright (C) 2012 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http: [...] Reading symbols from /home/user/test/test...done. (gdb) b 2 Breakpoint 1 at 0x80483ea: file test.c, line 2. (gdb)
gcc -gdwarf-3 ... gcc -gdwarf-2 ... gcc -gstabs ... gcc -gstabs+ ... gcc -gcoff ... gcc -gxcoff ... gcc -gxcoff+ ...
void f(){ printf("Executing f\n"); return; } int main(){ f(); printf("Back from f\n"); }
void f(){ printf("Executing f\n"); exit(0); } int main(){ f(); printf("Back from f\n"); }
static jmp_buf buf; void second(void) { printf("second\n"); longjmp(buf,1); } void first(void) { second(); printf("first\n"); } int main() { if ( ! setjmp(buf) ) { first(); } else { printf("main"); } return 0; }
extern void *__cxa_allocate_exception(size_t thrown_size); extern void __cxa_throw (void *thrown_exception, void* *tinfo, void (*dest) (void *) ); extern void * _ZTIl; int bar1() { int64_t * p = (int64_t*)__cxa_allocate_exception(8); *p = 1976; __cxa_throw(p,&_ZTIl,0); return 10; }
extern "C" int bar1(); void foo() { try{ bar1(); }catch(int64_t x){ printf("good %ld",x); } } int main(int argc, char *argv[]) { foo(); return 0; }
if (__builtin_expect (x, 0)) foo (); [This] would indicate that we do not expect to call `foo expect `x
int main(void) { CURL *curl; CURLcode res; curl = curl_easy_init(); if(curl) { curl_easy_setopt(curl, CURLOPT_URL, "curl.haxx.se"); res = curl_easy_perform(curl); curl_easy_cleanup(curl); } return 0; }
function_pt(void *ptr, size_t size, size_t nmemb, void *stream){ printf("%d", atoi(ptr)); } int main(void) { CURL *curl; curl = curl_easy_init(); if(curl) { curl_easy_setopt(curl, CURLOPT_URL, "curl.haxx.se"); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, function_pt); curl_easy_perform(curl); curl_easy_cleanup(curl); } system("pause"); return 0; }
struct string { char *ptr; size_t len; }; void init_string(struct string *s) { s->len = 0; s->ptr = malloc(s->len+1); if (s->ptr == NULL) { fprintf(stderr, "malloc() failed\n"); exit(EXIT_FAILURE); } s->ptr[0] = } size_t writefunc(void *ptr, size_t size, size_t nmemb, struct string *s) { size_t new_len = s->len + size*nmemb; s->ptr = realloc(s->ptr, new_len+1); if (s->ptr == NULL) { fprintf(stderr, "realloc() failed\n"); exit(EXIT_FAILURE); } memcpy(s->ptr+s->len, ptr, size*nmemb); s->ptr[new_len] = s->len = new_len; return size*nmemb; } int main(void) { CURL *curl; CURLcode res; curl = curl_easy_init(); if(curl) { struct string s; init_string(&s); curl_easy_setopt(curl, CURLOPT_URL, "curl.haxx.se"); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &s); res = curl_easy_perform(curl); printf("%s\n", s.ptr); free(s.ptr); curl_easy_cleanup(curl); } return 0; }
size_t CurlWrite_CallbackFunc_StdString(void *contents, size_t size, size_t nmemb, std::string *s) { size_t newLength = size*nmemb; size_t oldLength = s->size(); try { s->resize(oldLength + newLength); } catch(std::bad_alloc &e) { return 0; } std::copy((char*)contents,(char*)contents+newLength,s->begin()+oldLength); return size*nmemb; } int main() { CURL *curl; CURLcode res; curl_global_init(CURL_GLOBAL_DEFAULT); curl = curl_easy_init(); std::string s; if(curl) { curl_easy_setopt(curl, CURLOPT_URL, "curl.haxx.se"); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlWrite_CallbackFunc_StdString); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &s); curl_easy_setopt (curl, CURLOPT_VERBOSE, 1L); res = curl_easy_perform(curl); if(res != CURLE_OK) { fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res)); } curl_easy_cleanup(curl); } std::cout<<s<<std::endl; std::cout<< "Program finished!" << std::endl; }
curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, function_ptr);
size_t function( void *ptr, size_t size, size_t nmemb, void *stream)
jmp_buf bufferA, bufferB; void routineB(); void routineA() { int r ; printf("(A1)\n"); r = setjmp(bufferA); if (r == 0) routineB(); printf("(A2) r=%d\n",r); r = setjmp(bufferA); if (r == 0) longjmp(bufferB, 20001); printf("(A3) r=%d\n",r); r = setjmp(bufferA); if (r == 0) longjmp(bufferB, 20002); printf("(A4) r=%d\n",r); } void routineB() { int r; printf("(B1)\n"); r = setjmp(bufferB); if (r == 0) longjmp(bufferA, 10001); printf("(B2) r=%d\n", r); r = setjmp(bufferB); if (r == 0) longjmp(bufferA, 10002); printf("(B3) r=%d\n", r); r = setjmp(bufferB); if (r == 0) longjmp(bufferA, 10003); } int main(int argc, char **argv) { routineA(); return 0; }
struct { void (*destructor)(void *ptr); }; void LockForceUnlock(void *vlock) { LOCK* lock = vlock; } LOCK func_lock; void func() { ref = add_destructor(LockForceUnlock, mylock); Lock(func_lock) ... func2(); Unlock(func_lock); remove_destructor(ref); }
int my_div(int x, int y) { if (y==0) exit(2); return x/y; }
int my_div(int x, int y); static int rslt; static int expected_code; static int should_exit; static jmp_buf jump_env; static int done; static int num_tests; static int tests_passed; void TestStart(char *name) { num_tests++; rslt = 1; printf("-- Testing %s ... ",name); } void TestEnd() { if (rslt) tests_passed++; printf("%s\n", rslt ? "success" : "fail"); } void exit(int code) { if (!done) { assert(should_exit==1); assert(expected_code==code); longjmp(jump_env, 1); } else { _exit(code); } } void test_normal() { int jmp_rval; int r; TestStart("test_normal"); should_exit = 0; if (!(jmp_rval=setjmp(jump_env))) { r = my_div(12,3); } assert(jmp_rval==0); assert(r==4); TestEnd(); } void test_div0() { int jmp_rval; int r; TestStart("test_div0"); should_exit = 1; expected_code = 2; if (!(jmp_rval=setjmp(jump_env))) { r = my_div(2,0); } assert(jmp_rval==1); TestEnd(); } int main() { num_tests = 0; tests_passed = 0; done = 0; test_normal(); test_div0(); printf("Total tests passed: %d\n", tests_passed); done = 1; return !(tests_passed == num_tests); }
try { *((int *)0) = 0; } catch (SegmentationFault, e) { long f[] = { ((void(*)())f)(); } finally { return(1 / strcmp("", "")); }
typedef void (* Handler)(int); typedef struct _Class *ClassRef; struct _Class { int notRethrown; /* always 1 (used by throw()) */ ClassRef parent; char * name; int signalNumber; }; typedef struct _Class Class[1]; typedef enum _Scope { OUTSIDE = -1, INTERNAL, TRY, /* in CATCH, /* in FINALLY /* in } Scope; typedef enum _State { EMPTY, PENDING, CAUGHT } State; typedef struct _Except { int notRethrown; /* always 0 (used by throw()) */ State state; JMP_BUF throwBuf; JMP_BUF finalBuf; ClassRef class; void * pData; /* exception associated (user) data */ char * file; int line; int ready; Scope scope; int first; List * checkList; char* tryFile; int tryLine; ClassRef (*getClass)(void); char * (*getMessage)(void); void * (*getData)(void); void (*printTryTrace)(FILE*); } Except; typedef struct _Context { Except * pEx; Lifo * exStack; char message[1024]; /* used by ExceptGetMessage() */ Handler sigAbrtHandler; Handler sigFpeHandler; Handler sigIllHandler; Handler sigSegvHandler; Handler sigBusHandler; } Context; extern Context * pC; extern Class Throwable; except_class_declare(Exception, Throwable); except_class_declare(OutOfMemoryError, Exception); except_class_declare(FailedAssertion, Exception); except_class_declare(RuntimeException, Exception); except_class_declare(AbnormalTermination, RuntimeException); except_class_declare(ArithmeticException, RuntimeException); except_class_declare(IllegalInstruction, RuntimeException); except_class_declare(SegmentationFault, RuntimeException); except_class_declare(BusError, RuntimeException); static int checked ExceptCheckBegin(pC, pChecked, file, line) ExceptCheck(pC, pChecked, class, file, line) !checked ExceptTry(pC, __FILE__, __LINE__); \ while (1) \ { \ Context * pTmpC = ExceptGetContext(pC); \ Context * pC = pTmpC; \ CHECKED; \ \ if (CHECK_BEGIN(pC, &checked, __FILE__, __LINE__) && \ pC->pEx->ready && SETJMP(pC->pEx->throwBuf) == 0) \ { \ pC->pEx->scope = TRY; \ do \ { } \ while (0); \ } \ else if (CHECK(pC, &checked, class, __FILE__, __LINE__) && \ pC->pEx->ready && ExceptCatch(pC, class)) \ { \ Except *e = LifoPeek(pC->exStack, 1); \ pC->pEx->scope = CATCH; \ do \ { } \ while (0); \ } \ if (CHECK_END) \ continue; \ if (!pC->pEx->ready && SETJMP(pC->pEx->finalBuf) == 0) \ pC->pEx->ready = 1; \ else \ break; \ } \ ExceptGetContext(pC)->pEx->scope = FINALLY; \ while (ExceptGetContext(pC)->pEx->ready > 0 || ExceptFinally(pC)) \ while (ExceptGetContext(pC)->pEx->ready-- > 0) ExceptThrow(pC, (ClassRef)pExceptOrClass, pData, __FILE__, __LINE__) { \ if (ExceptGetScope(pC) != OUTSIDE) \ { \ void * pData = malloc(sizeof(JMP_BUF)); \ ExceptGetContext(pC)->pEx->pData = pData; \ if (SETJMP(*(JMP_BUF *)pData) == 0) \ ExceptReturn(pC); \ else \ free(pData); \ } \ return x; \ } (ExceptGetContext(pC)->pEx->state == PENDING) extern Scope ExceptGetScope(Context *pC); extern Context *ExceptGetContext(Context *pC); extern void ExceptThreadCleanup(int threadId); extern void ExceptTry(Context *pC, char *file, int line); extern void ExceptThrow(Context *pC, void * pExceptOrClass, void *pData, char *file, int line); extern int ExceptCatch(Context *pC, ClassRef class); extern int ExceptFinally(Context *pC); extern void ExceptReturn(Context *pC); extern int ExceptCheckBegin(Context *pC, int *pChecked, char *file, int line); extern int ExceptCheck(Context *pC, int *pChecked, ClassRef class, char *file, int line);
constexpr int c_strcmp( char const* lhs, char const* rhs ) { return (( : (lhs[0] != rhs[0]) ? (lhs[0] - rhs[0]) : c_strcmp( lhs+1, rhs+1 ); }
S (VS (jack)) S (jack) S (VS (queen)) S (queen) S (USER) S (USER_VS)
[... later on in code ...] compile_queen_func(); compile_jack_func();
ch0==c0 && ch1==c1 && ch2==c2 && ch3==c3 && ch4==c4 && ch5==c5 && ch6==c6 && ch7==c7 ;
char str[999]; FILE * file; file = fopen( "test.txt" , "r"); if (file) { while (fscanf(file, "%s", str)!=EOF) printf("%s",str); fclose(file); }
int c; FILE *file; file = fopen("test.txt", "r"); if (file) { while ((c = getc(file)) != EOF) putchar(c); fclose(file); }
char buf[CHUNK]; FILE *file; size_t nread; file = fopen("test.txt", "r"); if (file) { while ((nread = fread(buf, 1, sizeof buf, file)) > 0) fwrite(buf, 1, nread, stdout); if (ferror(file)) { } fclose(file); }
char *buf = malloc(chunk); if (buf == NULL) { /* deal with malloc() failure */ } while ((nread = fread(buf, 1, chunk, file)) > 0) { }
char* ReadFile(char *filename) { char *buffer = NULL; int string_size, read_size; FILE *handler = fopen(filename, "r"); if (handler) { fseek(handler, 0, SEEK_END); string_size = ftell(handler); rewind(handler); buffer = (char*) malloc(sizeof(char) * (string_size + 1) ); read_size = fread(buffer, sizeof(char), string_size, handler); buffer[string_size] = if (string_size != read_size) { free(buffer); buffer = NULL; } fclose(handler); } return buffer; } int main() { char *string = ReadFile("yourfile.txt"); if (string) { puts(string); free(string); } return 0; }
int main() { FILE *f; char c; f=fopen("test.txt","rt"); while((c=fgetc(f))!=EOF){ printf("%c",c); } fclose(f); return 0; }
f=open(argv[1],O_RDONLY); while ((n=read(f,l,80)) > 0) write(1,l,n);
int main() { int num; FILE *fptr; if ((fptr = fopen("/root/Desktop/my_pass.txt","r")) == NULL) { puts("File not exists"); exit(1); } else fscanf(fptr,"%d", &num); printf("My pass is: %d\n", num); fclose(fptr); return 0; }
while (fgets(str, 100, file)) /* printf("%s", str) */;
int main() { FILE *f=fopen("teste.txt","r"); int size; char buffer[BLOCK]; while((size=fread(buffer,BLOCK,sizeof(char),f)>0) fwrite(buffer,size,sizeof(char),stdout); fclose(f); return 0; }
